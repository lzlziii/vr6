#define DEBUG_LOCOMOTION_PANEL
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using AOT;
using Appnori;
using Appnori.Boxing;
using Appnori.Util;
using Appnori.XR;
using BADMINTON;
using BallPool;
using BallPool.AI;
using BallPool.Mechanics;
using Billiards;
using CueSports;
using Dart;
using ExitGames.Client.Photon;
using GOLF;
using Jisu.Boxing.SingleAI;
using Jisu.Utils;
using KTSuperVRGame;
using Mechanics;
using NetworkManagement;
using Oculus.Avatar;
using Oculus.Platform;
using Oculus.Platform.Models;
using Oculus.Spatializer.Propagation;
using PINGPONG;
using POpusCodec.Enums;
using Photon.Chat;
using Photon.Pun;
using Photon.Realtime;
using Photon.Voice.PUN;
using Photon.Voice.Unity;
using Photon.Voice.Unity.UtilityScripts;
using RootMotion.FinalIK;
using SingletonBase;
using SingletonPunBase;
using TENNIS;
using TMPro;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Animations;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Experimental.Rendering;
using UnityEngine.InputSystem.XR;
using UnityEngine.Jobs;
using UnityEngine.Networking;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.SpatialTracking;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using UnityEngine.XR.Interaction.Toolkit;
using UnityStandardAssets.CrossPlatformInput;
using UnityStandardAssets.CrossPlatformInput.PlatformSpecific;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
public class ButtonAnimation : MonoBehaviour
{
	private float initial_size_x;

	private float initial_size_y;

	public float factor = 0.5f;

	public float speed = 1.15f;

	private bool GO;

	private void Awake()
	{
		initial_size_x = base.transform.localScale.x;
		initial_size_y = base.transform.localScale.y;
	}

	private void FixedUpdate()
	{
		if (GO)
		{
			float x = base.transform.localScale.x;
			float y = base.transform.localScale.y;
			if (base.transform.localScale.y < initial_size_y)
			{
				x *= speed;
				y *= speed;
				base.transform.localScale = new Vector3(x, y, 1f);
			}
			else
			{
				x = initial_size_x;
				y = initial_size_y;
				base.transform.localScale = new Vector3(x, y, 1f);
				GO = false;
			}
		}
	}

	private void Go()
	{
		GO = true;
		base.transform.localScale = new Vector3(initial_size_x * factor, initial_size_y * factor, 1f);
	}
}
public class GameManager : MonoBehaviour
{
	public TextMesh text_fx_name;

	public GameObject[] fx_prefabs;

	public int index_fx;

	private Ray ray;

	private RaycastHit2D ray_cast_hit;

	private void Start()
	{
		text_fx_name.text = "[" + (index_fx + 1) + "] " + fx_prefabs[index_fx].name;
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			ray = Camera.main.ScreenPointToRay(Input.mousePosition);
			ray_cast_hit = Physics2D.Raycast(new Vector2(ray.origin.x, ray.origin.y), new Vector2(0f, 0f));
			if ((bool)ray_cast_hit)
			{
				switch (ray_cast_hit.transform.name)
				{
				case "BG":
					UnityEngine.Object.Instantiate(fx_prefabs[index_fx], new Vector3(ray.origin.x, ray.origin.y, 0f), Quaternion.identity);
					break;
				case "UI-arrow-right":
					ray_cast_hit.transform.SendMessage("Go");
					index_fx++;
					if (index_fx >= fx_prefabs.Length)
					{
						index_fx = 0;
					}
					text_fx_name.text = "[" + (index_fx + 1) + "] " + fx_prefabs[index_fx].name;
					break;
				case "UI-arrow-left":
					ray_cast_hit.transform.SendMessage("Go");
					index_fx--;
					if (index_fx <= -1)
					{
						index_fx = fx_prefabs.Length - 1;
					}
					text_fx_name.text = "[" + (index_fx + 1) + "] " + fx_prefabs[index_fx].name;
					break;
				case "Instructions":
					UnityEngine.Object.Destroy(ray_cast_hit.transform.gameObject);
					break;
				}
			}
		}
		if (Input.GetKeyDown("z") || Input.GetKeyDown("left"))
		{
			GameObject.Find("UI-arrow-left").SendMessage("Go");
			index_fx--;
			if (index_fx <= -1)
			{
				index_fx = fx_prefabs.Length - 1;
			}
			text_fx_name.text = "[" + (index_fx + 1) + "] " + fx_prefabs[index_fx].name;
		}
		if (Input.GetKeyDown("x") || Input.GetKeyDown("right"))
		{
			GameObject.Find("UI-arrow-right").SendMessage("Go");
			index_fx++;
			if (index_fx >= fx_prefabs.Length)
			{
				index_fx = 0;
			}
			text_fx_name.text = "[" + (index_fx + 1) + "] " + fx_prefabs[index_fx].name;
		}
		if (Input.GetKeyDown("space"))
		{
			UnityEngine.Object.Instantiate(fx_prefabs[index_fx], new Vector3(0f, 0f, 0f), Quaternion.identity);
		}
	}
}
public class SelfDestruct : MonoBehaviour
{
	public float selfdestruct_in = 4f;

	private void Start()
	{
		if (selfdestruct_in != 0f)
		{
			UnityEngine.Object.Destroy(base.gameObject, selfdestruct_in);
		}
	}
}
public class DemoShooting : MonoBehaviour
{
	public GameObject FirePoint;

	public Camera Cam;

	public float MaxLength;

	public GameObject[] Prefabs;

	private Ray RayMouse;

	private Vector3 direction;

	private Quaternion rotation;

	[Header("GUI")]
	private float windowDpi;

	private int Prefab;

	private GameObject Instance;

	private float hSliderValue = 0.1f;

	private float fireCountdown;

	private float buttonSaver;

	public Animation camAnim;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			windowDpi = 1f;
		}
		if (Screen.dpi < 200f)
		{
			windowDpi = 1f;
		}
		else
		{
			windowDpi = Screen.dpi / 200f;
		}
		Counter(0);
	}

	private void Update()
	{
		if (Input.GetButtonDown("Fire1"))
		{
			camAnim.Play(camAnim.clip.name);
			UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
		}
		if (Input.GetMouseButton(1) && fireCountdown <= 0f)
		{
			UnityEngine.Object.Instantiate(Prefabs[Prefab], FirePoint.transform.position, FirePoint.transform.rotation);
			fireCountdown = 0f;
			fireCountdown += hSliderValue;
		}
		fireCountdown -= Time.deltaTime;
		if ((Input.GetKey(KeyCode.A) || Input.GetAxis("Horizontal") < 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(-1);
		}
		if ((Input.GetKey(KeyCode.D) || Input.GetAxis("Horizontal") > 0f) && buttonSaver >= 0.4f)
		{
			buttonSaver = 0f;
			Counter(1);
		}
		buttonSaver += Time.deltaTime;
		if (Cam != null)
		{
			Vector3 mousePosition = Input.mousePosition;
			RayMouse = Cam.ScreenPointToRay(mousePosition);
			if (Physics.Raycast(RayMouse.origin, RayMouse.direction, out var hitInfo, MaxLength))
			{
				RotateToMouseDirection(base.gameObject, hitInfo.point);
			}
		}
		else
		{
			UnityEngine.Debug.Log("No camera");
		}
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(10f * windowDpi, 5f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use left mouse button to single shoot!");
		GUI.Label(new Rect(10f * windowDpi, 25f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use and hold the right mouse button for quick shooting!");
		GUI.Label(new Rect(10f * windowDpi, 45f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Fire rate:");
		hSliderValue = GUI.HorizontalSlider(new Rect(70f * windowDpi, 50f * windowDpi, 100f * windowDpi, 20f * windowDpi), hSliderValue, 0f, 1f);
		GUI.Label(new Rect(10f * windowDpi, 65f * windowDpi, 400f * windowDpi, 20f * windowDpi), "Use the keyboard buttons A/<- and D/-> to change projectiles!");
	}

	private void Counter(int count)
	{
		Prefab += count;
		if (Prefab > Prefabs.Length - 1)
		{
			Prefab = 0;
		}
		else if (Prefab < 0)
		{
			Prefab = Prefabs.Length - 1;
		}
	}

	private void RotateToMouseDirection(GameObject obj, Vector3 destination)
	{
		direction = destination - obj.transform.position;
		rotation = Quaternion.LookRotation(direction);
		obj.transform.localRotation = Quaternion.Lerp(obj.transform.rotation, rotation, 1f);
	}
}
public class AutoDestroyPS : MonoBehaviour
{
	private float timeLeft;

	private void Awake()
	{
		ParticleSystem.MainModule main = GetComponent<ParticleSystem>().main;
		timeLeft = main.startLifetimeMultiplier + main.duration;
		UnityEngine.Object.Destroy(base.gameObject, timeLeft);
	}
}
public class ParticleCollisionInstance : MonoBehaviour
{
	public GameObject[] EffectsOnCollision;

	public float DestroyTimeDelay = 5f;

	public bool UseWorldSpacePosition;

	public float Offset;

	public Vector3 rotationOffset = new Vector3(0f, 0f, 0f);

	public bool useOnlyRotationOffset = true;

	public bool UseFirePointRotation;

	public bool DestoyMainEffect = true;

	private ParticleSystem part;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem ps;

	private void Start()
	{
		part = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = part.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			GameObject[] effectsOnCollision = EffectsOnCollision;
			for (int j = 0; j < effectsOnCollision.Length; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(effectsOnCollision[j], collisionEvents[i].intersection + collisionEvents[i].normal * Offset, default(Quaternion));
				if (!UseWorldSpacePosition)
				{
					gameObject.transform.parent = base.transform;
				}
				if (UseFirePointRotation)
				{
					gameObject.transform.LookAt(base.transform.position);
				}
				else if (rotationOffset != Vector3.zero && useOnlyRotationOffset)
				{
					gameObject.transform.rotation = Quaternion.Euler(rotationOffset);
				}
				else
				{
					gameObject.transform.LookAt(collisionEvents[i].intersection + collisionEvents[i].normal);
					gameObject.transform.rotation *= Quaternion.Euler(rotationOffset);
				}
				UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
			}
		}
		if (DestoyMainEffect)
		{
			UnityEngine.Object.Destroy(base.gameObject, DestroyTimeDelay + 0.5f);
		}
	}
}
public class ProjectileMover : MonoBehaviour
{
	public float speed = 15f;

	public float hitOffset;

	public bool UseFirePointRotation;

	public Vector3 rotationOffset = new Vector3(0f, 0f, 0f);

	public GameObject hit;

	public GameObject flash;

	private Rigidbody rb;

	public GameObject[] Detached;

	private void Start()
	{
		rb = GetComponent<Rigidbody>();
		if (flash != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(flash, base.transform.position, Quaternion.identity);
			gameObject.transform.forward = base.gameObject.transform.forward;
			ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
			if (component != null)
			{
				UnityEngine.Object.Destroy(gameObject, component.main.duration);
			}
			else
			{
				ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
				UnityEngine.Object.Destroy(gameObject, component2.main.duration);
			}
		}
		UnityEngine.Object.Destroy(base.gameObject, 5f);
	}

	private void FixedUpdate()
	{
		if (speed != 0f)
		{
			rb.velocity = base.transform.forward * speed;
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		rb.constraints = RigidbodyConstraints.FreezeAll;
		speed = 0f;
		ContactPoint contactPoint = collision.contacts[0];
		Quaternion rotation = Quaternion.FromToRotation(Vector3.up, contactPoint.normal);
		Vector3 position = contactPoint.point + contactPoint.normal * hitOffset;
		if (hit != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(hit, position, rotation);
			if (UseFirePointRotation)
			{
				gameObject.transform.rotation = base.gameObject.transform.rotation * Quaternion.Euler(0f, 180f, 0f);
			}
			else if (rotationOffset != Vector3.zero)
			{
				gameObject.transform.rotation = Quaternion.Euler(rotationOffset);
			}
			else
			{
				gameObject.transform.LookAt(contactPoint.point + contactPoint.normal);
			}
			ParticleSystem component = gameObject.GetComponent<ParticleSystem>();
			if (component != null)
			{
				UnityEngine.Object.Destroy(gameObject, component.main.duration);
			}
			else
			{
				ParticleSystem component2 = gameObject.transform.GetChild(0).GetComponent<ParticleSystem>();
				UnityEngine.Object.Destroy(gameObject, component2.main.duration);
			}
		}
		GameObject[] detached = Detached;
		foreach (GameObject gameObject2 in detached)
		{
			if (gameObject2 != null)
			{
				gameObject2.transform.parent = null;
			}
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class ME_AnimatorEvents : MonoBehaviour
{
	public GameObject EffectPrefab;

	public GameObject SwordPrefab;

	public Transform SwordPosition;

	public Transform StartSwordPosition;

	private GameObject EffectInstance;

	private GameObject SwordInstance;

	private void Start()
	{
		if (SwordInstance != null)
		{
			UnityEngine.Object.Destroy(SwordInstance);
		}
		SwordInstance = UnityEngine.Object.Instantiate(SwordPrefab, StartSwordPosition.position, StartSwordPosition.rotation);
		SwordInstance.transform.parent = StartSwordPosition.transform;
	}

	public void ActivateEffect()
	{
		if (!(EffectPrefab == null) && !(SwordInstance == null))
		{
			if (EffectInstance != null)
			{
				UnityEngine.Object.Destroy(EffectInstance);
			}
			EffectInstance = UnityEngine.Object.Instantiate(EffectPrefab);
			EffectInstance.transform.parent = SwordInstance.transform;
			EffectInstance.transform.localPosition = Vector3.zero;
			EffectInstance.transform.localRotation = default(Quaternion);
			EffectInstance.GetComponent<PSMeshRendererUpdater>().UpdateMeshEffect(SwordInstance);
		}
	}

	public void ActivateSword()
	{
		SwordInstance.transform.parent = SwordPosition.transform;
		SwordInstance.transform.position = SwordPosition.position;
		SwordInstance.transform.rotation = SwordPosition.rotation;
	}

	public void UpdateColor(float HUE)
	{
		if (!(EffectInstance == null))
		{
			ME_EffectSettingColor mE_EffectSettingColor = EffectInstance.GetComponent<ME_EffectSettingColor>();
			if (mE_EffectSettingColor == null)
			{
				mE_EffectSettingColor = EffectInstance.AddComponent<ME_EffectSettingColor>();
			}
			ME_ColorHelper.HSBColor hsbColor = ME_ColorHelper.ColorToHSV(mE_EffectSettingColor.Color);
			hsbColor.H = HUE;
			mE_EffectSettingColor.Color = ME_ColorHelper.HSVToColor(hsbColor);
		}
	}
}
public static class ME_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material[] array = (UnityEngine.Application.isPlaying ? renderer.materials : renderer.sharedMaterials);
			if (array.Length == 0)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name in array2)
			{
				Material[] array3 = array;
				foreach (Material material in array3)
				{
					if (material != null && material.HasProperty(name))
					{
						setMatHUEColor(material, name, hue);
					}
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array2 = colorProperties;
			foreach (string name2 in array2)
			{
				if (trailMaterial != null && trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren3)
		{
			Material[] array4 = (UnityEngine.Application.isPlaying ? skinnedMeshRenderer.materials : skinnedMeshRenderer.sharedMaterials);
			if (array4.Length == 0)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name3 in array2)
			{
				Material[] array3 = array4;
				foreach (Material material3 in array3)
				{
					if (material3 != null && material3.HasProperty(name3))
					{
						setMatHUEColor(material3, name3, hue);
					}
				}
			}
		}
		Projector[] componentsInChildren4 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren4)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material4 = projector.material;
			if (material4 == null)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name4 in array2)
			{
				if (material4 != null && material4.HasProperty(name4))
				{
					projector.material = setMatHUEColor(material4, name4, hue);
				}
			}
		}
		Light[] componentsInChildren5 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren5)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren6 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren6)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int l = 1; l < colorKeys.Length; l++)
			{
				hsbColor2 = ColorToHSV(colorKeys[l].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[l].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class ME_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		Update();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		float h = ME_ColorHelper.ColorToHSV(Color).H;
		ME_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		previousColor = Color;
	}
}
public class ME_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class ME_MeshMaterialEffect : MonoBehaviour
{
	public Material Material;

	public bool IsFirstMaterial;
}
public class ME_ParticleTrails : MonoBehaviour
{
	public GameObject TrailPrefab;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private Dictionary<uint, GameObject> hashTrails = new Dictionary<uint, GameObject>();

	private Dictionary<uint, GameObject> newHashTrails = new Dictionary<uint, GameObject>();

	private List<GameObject> currentGO = new List<GameObject>();

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
	}

	private void OnEnable()
	{
		InvokeRepeating("ClearEmptyHashes", 1f, 1f);
	}

	private void OnDisable()
	{
		Clear();
		CancelInvoke("ClearEmptyHashes");
	}

	public void Clear()
	{
		foreach (GameObject item in currentGO)
		{
			UnityEngine.Object.Destroy(item);
		}
		currentGO.Clear();
	}

	private void Update()
	{
		UpdateTrail();
	}

	private void UpdateTrail()
	{
		newHashTrails.Clear();
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			if (!hashTrails.ContainsKey(particles[i].randomSeed))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(TrailPrefab, base.transform.position, default(Quaternion));
				gameObject.transform.parent = base.transform;
				currentGO.Add(gameObject);
				newHashTrails.Add(particles[i].randomSeed, gameObject);
				gameObject.GetComponent<LineRenderer>().widthMultiplier *= particles[i].startSize;
				continue;
			}
			GameObject gameObject2 = hashTrails[particles[i].randomSeed];
			if (gameObject2 != null)
			{
				LineRenderer component = gameObject2.GetComponent<LineRenderer>();
				component.startColor *= (Color)particles[i].GetCurrentColor(ps);
				component.endColor *= (Color)particles[i].GetCurrentColor(ps);
				if (ps.main.simulationSpace == ParticleSystemSimulationSpace.World)
				{
					gameObject2.transform.position = particles[i].position;
				}
				if (ps.main.simulationSpace == ParticleSystemSimulationSpace.Local)
				{
					gameObject2.transform.position = ps.transform.TransformPoint(particles[i].position);
				}
				newHashTrails.Add(particles[i].randomSeed, gameObject2);
			}
			hashTrails.Remove(particles[i].randomSeed);
		}
		foreach (KeyValuePair<uint, GameObject> hashTrail in hashTrails)
		{
			if (hashTrail.Value != null)
			{
				hashTrail.Value.GetComponent<ME_TrailRendererNoise>().IsActive = false;
			}
		}
		AddRange(hashTrails, newHashTrails);
	}

	public void AddRange<T, S>(Dictionary<T, S> source, Dictionary<T, S> collection)
	{
		if (collection == null)
		{
			return;
		}
		foreach (KeyValuePair<T, S> item in collection)
		{
			if (!source.ContainsKey(item.Key))
			{
				source.Add(item.Key, item.Value);
			}
		}
	}

	private void ClearEmptyHashes()
	{
		hashTrails = hashTrails.Where((KeyValuePair<uint, GameObject> h) => h.Value != null).ToDictionary((KeyValuePair<uint, GameObject> h) => h.Key, (KeyValuePair<uint, GameObject> h) => h.Value);
	}
}
public class ME_TrailRendererNoise : MonoBehaviour
{
	[Range(0.01f, 10f)]
	public float MinVertexDistance = 0.1f;

	public float VertexTime = 1f;

	public float TotalLifeTime = 3f;

	public bool SmoothCurves;

	public bool IsRibbon;

	public bool IsActive = true;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float TimeScale = 0.1f;

	[Range(0.001f, 10f)]
	public float Amplitude = 1f;

	public float Gravity = 1f;

	public float TurbulenceStrength = 1f;

	public bool AutodestructWhenNotActive;

	private LineRenderer lineRenderer;

	private Transform t;

	private Vector3 prevPos;

	private List<Vector3> points = new List<Vector3>(500);

	private List<float> lifeTimes = new List<float>(500);

	private List<Vector3> velocities = new List<Vector3>(500);

	private float randomOffset;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private void Start()
	{
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.useWorldSpace = true;
		t = base.transform;
		prevPos = t.position;
		points.Insert(0, t.position);
		lifeTimes.Insert(0, VertexTime);
		velocities.Insert(0, Vector3.zero);
		randomOffset = (float)UnityEngine.Random.Range(0, 10000000) / 1000000f;
	}

	private void OnEnable()
	{
		points.Clear();
		lifeTimes.Clear();
		velocities.Clear();
	}

	private void Update()
	{
		if (IsActive)
		{
			AddNewPoints();
		}
		UpdatetPoints();
		if (SmoothCurves && points.Count > 2)
		{
			UpdateLineRendererBezier();
		}
		else
		{
			UpdateLineRenderer();
		}
		if (AutodestructWhenNotActive && !IsActive && points.Count <= 1)
		{
			UnityEngine.Object.Destroy(base.gameObject, TotalLifeTime);
		}
	}

	private void AddNewPoints()
	{
		if ((t.position - prevPos).magnitude > MinVertexDistance || (IsRibbon && points.Count == 0) || (IsRibbon && points.Count > 0 && (t.position - points[0]).magnitude > MinVertexDistance))
		{
			prevPos = t.position;
			points.Insert(0, t.position);
			lifeTimes.Insert(0, VertexTime);
			velocities.Insert(0, Vector3.zero);
		}
	}

	private void UpdatetPoints()
	{
		for (int i = 0; i < lifeTimes.Count; i++)
		{
			lifeTimes[i] -= Time.deltaTime;
			if (lifeTimes[i] <= 0f)
			{
				int count = lifeTimes.Count - i;
				lifeTimes.RemoveRange(i, count);
				points.RemoveRange(i, count);
				velocities.RemoveRange(i, count);
				break;
			}
			CalculateTurbuelence(points[i], TimeScale, Frequency, Amplitude, Gravity, i);
		}
	}

	private void UpdateLineRendererBezier()
	{
		if (SmoothCurves && points.Count > 2)
		{
			InterpolateBezier(points, 0.5f);
			List<Vector3> drawingPoints = GetDrawingPoints();
			lineRenderer.positionCount = drawingPoints.Count - 1;
			lineRenderer.SetPositions(drawingPoints.ToArray());
		}
	}

	private void UpdateLineRenderer()
	{
		lineRenderer.positionCount = Mathf.Clamp(points.Count - 1, 0, int.MaxValue);
		lineRenderer.SetPositions(points.ToArray());
	}

	private void CalculateTurbuelence(Vector3 position, float speed, float scale, float height, float gravity, int index)
	{
		float num = Time.timeSinceLevelLoad * speed + randomOffset;
		float x = position.x * scale + num;
		float num2 = position.y * scale + num + 10f;
		float y = position.z * scale + num + 25f;
		position.x = (Mathf.PerlinNoise(num2, y) - 0.5f) * height * Time.deltaTime;
		position.y = (Mathf.PerlinNoise(x, y) - 0.5f) * height * Time.deltaTime - gravity * Time.deltaTime;
		position.z = (Mathf.PerlinNoise(x, num2) - 0.5f) * height * Time.deltaTime;
		points[index] += position * TurbulenceStrength;
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1] - vector;
				Vector3 item = vector + scale * vector2;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector3 = segmentPoints[i - 1];
				Vector3 vector4 = segmentPoints[i];
				Vector3 vector5 = vector4 - vector3;
				Vector3 item2 = vector4 - scale * vector5;
				controlPoints.Add(item2);
				controlPoints.Add(vector4);
			}
			else
			{
				Vector3 vector6 = segmentPoints[i - 1];
				Vector3 vector7 = segmentPoints[i];
				Vector3 vector8 = segmentPoints[i + 1];
				Vector3 normalized = (vector8 - vector6).normalized;
				Vector3 item3 = vector7 - scale * normalized * (vector7 - vector6).magnitude;
				Vector3 item4 = vector7 + scale * normalized * (vector8 - vector7).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector7);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}
[ExecuteInEditMode]
public class PSMeshRendererUpdater : MonoBehaviour
{
	private class ParticleStartInfo
	{
		public ParticleSystem.MinMaxCurve StartSize;

		public ParticleSystem.MinMaxCurve StartSpeed;
	}

	public GameObject MeshObject;

	public float StartScaleMultiplier = 1f;

	public Color Color = Color.black;

	private const string materialName = "MeshEffect";

	private List<Material[]> rendererMaterials = new List<Material[]>();

	private List<Material[]> skinnedMaterials = new List<Material[]>();

	public bool IsActive = true;

	public float FadeTime = 1.5f;

	private bool currentActiveStatus;

	private bool needUpdateAlpha;

	private Color oldColor = Color.black;

	private float currentAlphaTime;

	private string[] colorProperties = new string[9] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor" };

	private float alpha;

	private float prevAlpha;

	private Dictionary<string, float> startAlphaColors;

	private bool previousActiveStatus;

	private bool needUpdate;

	private bool needLastUpdate;

	private Dictionary<ParticleSystem, ParticleStartInfo> startParticleParameters;

	private void OnEnable()
	{
		alpha = 0f;
		prevAlpha = 0f;
		IsActive = true;
	}

	private void Update()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			return;
		}
		if (startAlphaColors == null)
		{
			InitStartAlphaColors();
		}
		if (IsActive && alpha < 1f)
		{
			alpha += Time.deltaTime / FadeTime;
		}
		if (!IsActive && alpha > 0f)
		{
			alpha -= Time.deltaTime / FadeTime;
		}
		if (alpha > 0f && alpha < 1f)
		{
			needUpdate = true;
		}
		else
		{
			needUpdate = false;
			alpha = Mathf.Clamp01(alpha);
			if (Mathf.Abs(prevAlpha - alpha) >= Mathf.Epsilon)
			{
				UpdateVisibleStatus();
			}
		}
		prevAlpha = alpha;
		if (needUpdate)
		{
			UpdateVisibleStatus();
		}
		if (Color != oldColor)
		{
			oldColor = Color;
			UpdateColor(Color);
		}
	}

	private void InitStartAlphaColors()
	{
		startAlphaColors = new Dictionary<string, float>();
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material[] materials = renderer.materials;
			for (int j = 0; j < materials.Length; j++)
			{
				if (materials[j].name.Contains("MeshEffect"))
				{
					GetStartAlphaByProperties(renderer.GetHashCode().ToString(), j, materials[j]);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren2 = GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren2)
		{
			Material[] materials2 = skinnedMeshRenderer.materials;
			for (int k = 0; k < materials2.Length; k++)
			{
				if (materials2[k].name.Contains("MeshEffect"))
				{
					GetStartAlphaByProperties(skinnedMeshRenderer.GetHashCode().ToString(), k, materials2[k]);
				}
			}
		}
		Light[] componentsInChildren3 = GetComponentsInChildren<Light>(includeInactive: true);
		for (int l = 0; l < componentsInChildren3.Length; l++)
		{
			ME_LightCurves component = componentsInChildren3[l].GetComponent<ME_LightCurves>();
			float value = 1f;
			if (component != null)
			{
				value = component.GraphIntensityMultiplier;
			}
			startAlphaColors.Add(componentsInChildren3[l].GetHashCode().ToString() + l, value);
		}
		componentsInChildren = MeshObject.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer2 in componentsInChildren)
		{
			Material[] materials3 = renderer2.materials;
			for (int m = 0; m < materials3.Length; m++)
			{
				if (materials3[m].name.Contains("MeshEffect"))
				{
					GetStartAlphaByProperties(renderer2.GetHashCode().ToString(), m, materials3[m]);
				}
			}
		}
		componentsInChildren2 = MeshObject.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer2 in componentsInChildren2)
		{
			Material[] materials4 = skinnedMeshRenderer2.materials;
			for (int n = 0; n < materials4.Length; n++)
			{
				if (materials4[n].name.Contains("MeshEffect"))
				{
					GetStartAlphaByProperties(skinnedMeshRenderer2.GetHashCode().ToString(), n, materials4[n]);
				}
			}
		}
	}

	private void InitStartParticleParameters()
	{
		startParticleParameters = new Dictionary<ParticleSystem, ParticleStartInfo>();
		ParticleSystem[] componentsInChildren = MeshObject.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			startParticleParameters.Add(particleSystem, new ParticleStartInfo
			{
				StartSize = particleSystem.main.startSize,
				StartSpeed = particleSystem.main.startSpeed
			});
		}
	}

	private void UpdateVisibleStatus()
	{
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material[] materials = renderer.materials;
			for (int j = 0; j < materials.Length; j++)
			{
				if (materials[j].name.Contains("MeshEffect"))
				{
					UpdateAlphaByProperties(renderer.GetHashCode().ToString(), j, materials[j], alpha);
				}
			}
		}
		componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer2 in componentsInChildren)
		{
			Material[] materials2 = renderer2.materials;
			for (int k = 0; k < materials2.Length; k++)
			{
				if (materials2[k].name.Contains("MeshEffect"))
				{
					UpdateAlphaByProperties(renderer2.GetHashCode().ToString(), k, materials2[k], alpha);
				}
			}
		}
		componentsInChildren = MeshObject.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer3 in componentsInChildren)
		{
			Material[] materials3 = renderer3.materials;
			for (int l = 0; l < materials3.Length; l++)
			{
				if (materials3[l].name.Contains("MeshEffect"))
				{
					UpdateAlphaByProperties(renderer3.GetHashCode().ToString(), l, materials3[l], alpha);
				}
			}
		}
		componentsInChildren = MeshObject.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer4 in componentsInChildren)
		{
			Material[] materials4 = renderer4.materials;
			for (int m = 0; m < materials4.Length; m++)
			{
				if (materials4[m].name.Contains("MeshEffect"))
				{
					UpdateAlphaByProperties(renderer4.GetHashCode().ToString(), m, materials4[m], alpha);
				}
			}
		}
		ME_LightCurves[] componentsInChildren2 = GetComponentsInChildren<ME_LightCurves>(includeInactive: true);
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].enabled = IsActive;
		}
		Light[] componentsInChildren3 = GetComponentsInChildren<Light>(includeInactive: true);
		for (int n = 0; n < componentsInChildren3.Length; n++)
		{
			if (!IsActive)
			{
				float num = startAlphaColors[componentsInChildren3[n].GetHashCode().ToString() + n];
				componentsInChildren3[n].intensity = alpha * num;
			}
		}
		ParticleSystem[] componentsInChildren4 = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem particleSystem in componentsInChildren4)
		{
			if (!IsActive && !particleSystem.isStopped)
			{
				particleSystem.Stop();
			}
			if (IsActive && particleSystem.isStopped)
			{
				particleSystem.Play();
			}
		}
		ME_TrailRendererNoise[] componentsInChildren5 = GetComponentsInChildren<ME_TrailRendererNoise>();
		for (int i = 0; i < componentsInChildren5.Length; i++)
		{
			componentsInChildren5[i].IsActive = IsActive;
		}
	}

	private void UpdateAlphaByProperties(string rendName, int materialNumber, Material mat, float alpha)
	{
		string[] array = colorProperties;
		foreach (string text in array)
		{
			if (mat.HasProperty(text))
			{
				float num = startAlphaColors[rendName + materialNumber + text.ToString()];
				Color color = mat.GetColor(text);
				color.a = alpha * num;
				mat.SetColor(text, color);
			}
		}
	}

	private void GetStartAlphaByProperties(string rendName, int materialNumber, Material mat)
	{
		string[] array = colorProperties;
		foreach (string text in array)
		{
			if (mat.HasProperty(text))
			{
				string key = rendName + materialNumber + text.ToString();
				if (!startAlphaColors.ContainsKey(key))
				{
					startAlphaColors.Add(rendName + materialNumber + text.ToString(), mat.GetColor(text).a);
				}
			}
		}
	}

	public void UpdateColor(Color color)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.HSBColor hSBColor = ME_ColorHelper.ColorToHSV(color);
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, hSBColor.H);
		}
	}

	public void UpdateColor(float HUE)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, HUE);
		}
	}

	public void UpdateMeshEffect()
	{
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = default(Quaternion);
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (!(MeshObject == null))
		{
			UpdatePSMesh(MeshObject);
			AddMaterialToMesh(MeshObject);
		}
	}

	private void CheckScaleIncludedParticles()
	{
	}

	public void UpdateMeshEffect(GameObject go)
	{
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (go == null)
		{
			UnityEngine.Debug.Log("You need set a gameObject");
			return;
		}
		MeshObject = go;
		UpdatePSMesh(MeshObject);
		AddMaterialToMesh(MeshObject);
	}

	private void UpdatePSMesh(GameObject go)
	{
		if (startParticleParameters == null)
		{
			InitStartParticleParameters();
		}
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		MeshRenderer componentInChildren = go.GetComponentInChildren<MeshRenderer>();
		SkinnedMeshRenderer componentInChildren2 = go.GetComponentInChildren<SkinnedMeshRenderer>();
		Light[] componentsInChildren2 = GetComponentsInChildren<Light>();
		float num = 1f;
		float num2 = 1f;
		if (componentInChildren != null)
		{
			num = componentInChildren.bounds.size.magnitude;
			num2 = componentInChildren.transform.lossyScale.magnitude;
		}
		if (componentInChildren2 != null)
		{
			num = componentInChildren2.bounds.size.magnitude;
			num2 = componentInChildren2.transform.lossyScale.magnitude;
		}
		ParticleSystem[] array = componentsInChildren;
		foreach (ParticleSystem particleSystem in array)
		{
			particleSystem.transform.gameObject.SetActive(value: false);
			ParticleSystem.ShapeModule shape = particleSystem.shape;
			if (shape.enabled)
			{
				if (componentInChildren != null)
				{
					shape.shapeType = ParticleSystemShapeType.MeshRenderer;
					shape.meshRenderer = componentInChildren;
				}
				if (componentInChildren2 != null)
				{
					shape.shapeType = ParticleSystemShapeType.SkinnedMeshRenderer;
					shape.skinnedMeshRenderer = componentInChildren2;
				}
			}
			ParticleSystem.MainModule main = particleSystem.main;
			ParticleStartInfo particleStartInfo = startParticleParameters[particleSystem];
			main.startSize = UpdateParticleParam(particleStartInfo.StartSize, main.startSize, num / num2 * StartScaleMultiplier);
			main.startSpeed = UpdateParticleParam(particleStartInfo.StartSpeed, main.startSpeed, num / num2 * StartScaleMultiplier);
			particleSystem.transform.gameObject.SetActive(value: true);
		}
		if (componentInChildren != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren.bounds.center;
			}
		}
		if (componentInChildren2 != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren2.bounds.center;
			}
		}
	}

	private ParticleSystem.MinMaxCurve UpdateParticleParam(ParticleSystem.MinMaxCurve startParam, ParticleSystem.MinMaxCurve currentParam, float scale)
	{
		if (currentParam.mode == ParticleSystemCurveMode.TwoConstants)
		{
			currentParam.constantMin = startParam.constantMin * scale;
			currentParam.constantMax = startParam.constantMax * scale;
		}
		else if (currentParam.mode == ParticleSystemCurveMode.Constant)
		{
			currentParam.constant = startParam.constant * scale;
		}
		return currentParam;
	}

	private void AddMaterialToMesh(GameObject go)
	{
		ME_MeshMaterialEffect componentInChildren = GetComponentInChildren<ME_MeshMaterialEffect>();
		if (!(componentInChildren == null))
		{
			MeshRenderer componentInChildren2 = go.GetComponentInChildren<MeshRenderer>();
			SkinnedMeshRenderer componentInChildren3 = go.GetComponentInChildren<SkinnedMeshRenderer>();
			if (componentInChildren2 != null)
			{
				rendererMaterials.Add(componentInChildren2.sharedMaterials);
				componentInChildren2.sharedMaterials = AddToSharedMaterial(componentInChildren2.sharedMaterials, componentInChildren);
			}
			if (componentInChildren3 != null)
			{
				skinnedMaterials.Add(componentInChildren3.sharedMaterials);
				componentInChildren3.sharedMaterials = AddToSharedMaterial(componentInChildren3.sharedMaterials, componentInChildren);
			}
		}
	}

	private Material[] AddToSharedMaterial(Material[] sharedMaterials, ME_MeshMaterialEffect meshMatEffect)
	{
		if (meshMatEffect.IsFirstMaterial)
		{
			return new Material[1] { meshMatEffect.Material };
		}
		List<Material> list = sharedMaterials.ToList();
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].name.Contains("MeshEffect"))
			{
				list.RemoveAt(i);
			}
		}
		list.Add(meshMatEffect.Material);
		return list.ToArray();
	}

	private void OnDestroy()
	{
		if (MeshObject == null)
		{
			return;
		}
		MeshRenderer[] componentsInChildren = MeshObject.GetComponentsInChildren<MeshRenderer>();
		SkinnedMeshRenderer[] componentsInChildren2 = MeshObject.GetComponentsInChildren<SkinnedMeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (rendererMaterials.Count == componentsInChildren.Length)
			{
				componentsInChildren[i].sharedMaterials = rendererMaterials[i];
			}
			List<Material> list = componentsInChildren[i].sharedMaterials.ToList();
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j].name.Contains("MeshEffect"))
				{
					list.RemoveAt(j);
				}
			}
			componentsInChildren[i].sharedMaterials = list.ToArray();
		}
		for (int k = 0; k < componentsInChildren2.Length; k++)
		{
			if (skinnedMaterials.Count == componentsInChildren2.Length)
			{
				componentsInChildren2[k].sharedMaterials = skinnedMaterials[k];
			}
			List<Material> list2 = componentsInChildren2[k].sharedMaterials.ToList();
			for (int l = 0; l < list2.Count; l++)
			{
				if (list2[l].name.Contains("MeshEffect"))
				{
					list2.RemoveAt(l);
				}
			}
			componentsInChildren2[k].sharedMaterials = list2.ToArray();
		}
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
	}
}
public class ME_LegacyRenderDistortion : MonoBehaviour
{
	public bool IsActive = true;

	private CommandBuffer buf;

	private Camera cam;

	private bool bufferIsAdded;

	private void Awake()
	{
		cam = GetComponent<Camera>();
		CreateBuffer();
	}

	private void CreateBuffer()
	{
		_ = Camera.main;
		buf = new CommandBuffer();
		buf.name = "_GrabOpaqueColor";
		int num = Shader.PropertyToID("_ScreenCopyOpaqueColor");
		int num2 = -1;
		RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB565) ? RenderTextureFormat.RGB565 : RenderTextureFormat.Default);
		buf.GetTemporaryRT(num, num2, num2, 0, FilterMode.Bilinear, format);
		buf.Blit(BuiltinRenderTextureType.CurrentActive, num);
		buf.SetGlobalTexture("_GrabTexture", num);
		buf.SetGlobalTexture("_GrabTextureMobile", num);
	}

	private void OnEnable()
	{
		AddBuffer();
	}

	private void OnDisable()
	{
		RemoveBuffer();
	}

	private void AddBuffer()
	{
		cam.AddCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = true;
	}

	private void RemoveBuffer()
	{
		cam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = false;
	}

	private void Update()
	{
		if (IsActive)
		{
			if (!bufferIsAdded)
			{
				AddBuffer();
			}
		}
		else if (bufferIsAdded)
		{
			RemoveBuffer();
		}
	}

	private bool IsSupportedHdr()
	{
		return Camera.main.allowHDR;
	}
}
public class ME_PerPlatformSettings : MonoBehaviour
{
	public bool DisableOnMobiles;

	public bool RenderMobileDistortion;

	[Range(0.1f, 1f)]
	public float ParticleBudgetForMobiles = 1f;

	private bool isMobile;

	private void Awake()
	{
		isMobile = IsMobilePlatform();
		if (isMobile)
		{
			if (DisableOnMobiles)
			{
				base.gameObject.SetActive(value: false);
			}
			else if (ParticleBudgetForMobiles < 0.99f)
			{
				ChangeParticlesBudget(ParticleBudgetForMobiles);
			}
		}
	}

	private void OnEnable()
	{
		Camera main = Camera.main;
		LWRP_Rendering_Check(main);
		Legacy_Rendering_Check(main);
	}

	private void Update()
	{
		Camera main = Camera.main;
		LWRP_Rendering_Check(main);
		Legacy_Rendering_Check(main);
	}

	private void LWRP_Rendering_Check(Camera cam)
	{
	}

	private void Legacy_Rendering_Check(Camera cam)
	{
		if (!(cam == null) && RenderMobileDistortion && !DisableOnMobiles && isMobile)
		{
			ME_LegacyRenderDistortion mE_LegacyRenderDistortion = cam.GetComponent<ME_LegacyRenderDistortion>();
			if (mE_LegacyRenderDistortion == null)
			{
				mE_LegacyRenderDistortion = cam.gameObject.AddComponent<ME_LegacyRenderDistortion>();
			}
			mE_LegacyRenderDistortion.IsActive = true;
		}
	}

	private void OnDisable()
	{
		Camera main = Camera.main;
		if (!(main == null) && RenderMobileDistortion && !DisableOnMobiles && isMobile)
		{
			ME_LegacyRenderDistortion component = main.GetComponent<ME_LegacyRenderDistortion>();
			if (component != null)
			{
				component.IsActive = false;
			}
		}
	}

	private bool IsMobilePlatform()
	{
		bool result = false;
		if (UnityEngine.Application.isMobilePlatform)
		{
			result = true;
		}
		return result;
	}

	private void ChangeParticlesBudget(float particlesMul)
	{
		ParticleSystem component = GetComponent<ParticleSystem>();
		if (component == null)
		{
			return;
		}
		ParticleSystem.MainModule main = component.main;
		main.maxParticles = Mathf.Max(1, (int)((float)main.maxParticles * particlesMul));
		ParticleSystem.EmissionModule emission = component.emission;
		if (!emission.enabled)
		{
			return;
		}
		ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
		if (rateOverTime.constantMin > 1f)
		{
			rateOverTime.constantMin *= particlesMul;
		}
		if (rateOverTime.constantMax > 1f)
		{
			rateOverTime.constantMax *= particlesMul;
		}
		emission.rateOverTime = rateOverTime;
		ParticleSystem.MinMaxCurve rateOverDistance = emission.rateOverDistance;
		if (rateOverDistance.constantMin > 1f)
		{
			if (rateOverDistance.constantMin > 1f)
			{
				rateOverDistance.constantMin *= particlesMul;
			}
			if (rateOverDistance.constantMax > 1f)
			{
				rateOverDistance.constantMax *= particlesMul;
			}
			emission.rateOverDistance = rateOverDistance;
		}
		ParticleSystem.Burst[] array = new ParticleSystem.Burst[emission.burstCount];
		emission.GetBursts(array);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].minCount > 1)
			{
				array[i].minCount = (short)((float)array[i].minCount * particlesMul);
			}
			if (array[i].maxCount > 1)
			{
				array[i].maxCount = (short)((float)array[i].maxCount * particlesMul);
			}
		}
		emission.SetBursts(array);
	}
}
public class Callback_LeaderBoard : MonoBehaviour
{
}
public class LeaderBoardCtrl : MonoBehaviour
{
	public class SlotInfo
	{
		public Text text_name;

		public Text text_score;

		public RawImage image_profile;
	}

	[Serializable]
	public class LeaderBoardInfo
	{
		[Serializable]
		public class UserInfo
		{
			public string Rank;

			public string Nick;

			public string Score;

			public string Image;
		}

		public UserInfo[] users;
	}

	private SlotInfo[] slotInfos;

	private Text text_myRank;

	private Animator anim;

	private int score;

	private bool isUpload;

	private bool isInit;

	private Text[] text_topB_t;

	private Text[] text_myB_t;

	private Text text_rank_t;

	private Text text_name_t;

	private Text text_score_t;

	private Coroutine coroutine_MyScoreUpdate;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		if (!isInit)
		{
			anim = GetComponent<Animator>();
			slotInfos = new SlotInfo[11];
			Transform transform = base.transform.Find("Board/Image_Bar_Mine");
			text_myRank = transform.Find("Text_Rank").GetComponent<Text>();
			slotInfos[0] = new SlotInfo();
			slotInfos[0].text_name = transform.Find("Text_Name").GetComponent<Text>();
			slotInfos[0].text_score = transform.Find("Text_Score").GetComponent<Text>();
			slotInfos[0].image_profile = transform.Find("Image_Profile").GetComponent<RawImage>();
			transform = base.transform.Find("Board/List");
			for (int i = 0; i < 10; i++)
			{
				slotInfos[i + 1] = new SlotInfo();
				slotInfos[i + 1].text_name = transform.GetChild(i).Find("Text_Name").GetComponent<Text>();
				slotInfos[i + 1].text_score = transform.GetChild(i).Find("Text_Score").GetComponent<Text>();
				slotInfos[i + 1].image_profile = transform.GetChild(i).Find("Image_Profile").GetComponent<RawImage>();
			}
			transform = base.transform.Find("Board/Image_TopBar");
			text_topB_t = new Text[2];
			text_topB_t[0] = transform.Find("Text_TopBestScore").GetComponent<Text>();
			text_topB_t[1] = transform.Find("Text_TopBestScore_S").GetComponent<Text>();
			text_rank_t = transform.Find("Text_Rank").GetComponent<Text>();
			text_name_t = transform.Find("Text_Name").GetComponent<Text>();
			text_score_t = transform.Find("Text_Score").GetComponent<Text>();
			transform = base.transform.Find("Board/Image_Bar_Mine");
			text_myB_t = new Text[2];
			text_myB_t[0] = transform.Find("Text_MyBestScore").GetComponent<Text>();
			text_myB_t[1] = transform.Find("Text_MyBestScore_S").GetComponent<Text>();
			base.gameObject.SetActive(value: false);
			isUpload = false;
			isInit = true;
		}
	}

	private void InitSlot()
	{
		for (int i = 0; i < slotInfos.Length; i++)
		{
			slotInfos[i].text_name.text = "-";
			slotInfos[i].text_score.text = "-";
			slotInfos[i].image_profile.texture = null;
		}
		text_myRank.text = "-";
	}

	public void MyScoreUpdate(int setScore, int count = 0)
	{
		Init();
		if (!isUpload)
		{
			isUpload = true;
			base.gameObject.SetActive(value: true);
			score = setScore;
			if (coroutine_MyScoreUpdate != null)
			{
				StopCoroutine(coroutine_MyScoreUpdate);
			}
			coroutine_MyScoreUpdate = StartCoroutine(Coroutine_MyScoreUpdate(count));
		}
	}

	private IEnumerator Coroutine_MyScoreUpdate(int count = 0)
	{
		while (!SingletonBase.Singleton<UserInfoManager>.GetInstance.isGetNetData)
		{
			yield return null;
		}
		InitSlot();
		List<IMultipartFormSection> list = new List<IMultipartFormSection>();
		string data = "all";
		if (SceneManager.GetActiveScene().name == "Scene_Lobby")
		{
			score = 0;
		}
		else
		{
			switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType)
			{
			case GameData_DDOL.GameType.Bowling:
				data = "bowling";
				break;
			case GameData_DDOL.GameType.Basketball:
				data = "basketball";
				break;
			case GameData_DDOL.GameType.Baseball:
				data = "baseball";
				break;
			case GameData_DDOL.GameType.Boxing:
				data = "boxing_hb";
				break;
			}
		}
		list.Add(new MultipartFormDataSection("Game", data));
		list.Add(new MultipartFormDataSection("UserID", SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id));
		list.Add(new MultipartFormDataSection("Score", score.ToString()));
		UnityWebRequest www = UnityWebRequest.Post("https://api-global.appnori.com/AIO/UpdateScore.php", list);
		www.timeout = 5;
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			if (count >= 3)
			{
				UnityEngine.Debug.Log("Error");
				yield break;
			}
			yield return new WaitForSeconds(2f);
			MyScoreUpdate(score, count + 1);
		}
		else
		{
			UnityEngine.Debug.Log("Form upload complete!");
			UnityEngine.Debug.Log(www.downloadHandler.text);
			SetTextUI(JsonUtility.FromJson<LeaderBoardInfo>("{\"users\":" + www.downloadHandler.text + "}"));
		}
	}

	private void SetTextUI(LeaderBoardInfo leaderBoardInfo)
	{
		for (int i = 0; i < slotInfos.Length && i < leaderBoardInfo.users.Length; i++)
		{
			slotInfos[i].text_score.text = leaderBoardInfo.users[i].Score;
			if (i == 0)
			{
				if (SceneManager.GetActiveScene().name == "Scene_Lobby")
				{
					int result = 0;
					if (int.TryParse(leaderBoardInfo.users[i].Score, out result))
					{
						if (result >= 3000)
						{
							SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach09", 1);
						}
						if (result >= 1500)
						{
							SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach08", 1);
						}
					}
				}
				text_myRank.text = leaderBoardInfo.users[0].Rank;
				slotInfos[i].text_name.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick;
				SingletonBase.Singleton<UserInfoManager>.GetInstance.SetImage(UserInfoManager.image_url_mine, slotInfos[i].image_profile);
			}
			else
			{
				slotInfos[i].text_name.text = leaderBoardInfo.users[i].Nick;
				SingletonBase.Singleton<UserInfoManager>.GetInstance.SetImage(leaderBoardInfo.users[i].Image, slotInfos[i].image_profile);
			}
		}
		text_topB_t[0].text = GameSettingCtrl.GetLocalizationText("0015");
		text_topB_t[1].text = GameSettingCtrl.GetLocalizationText("0015");
		text_myB_t[0].text = GameSettingCtrl.GetLocalizationText("0016");
		text_myB_t[1].text = GameSettingCtrl.GetLocalizationText("0016");
		text_rank_t.text = GameSettingCtrl.GetLocalizationText("0060");
		text_name_t.text = GameSettingCtrl.GetLocalizationText("0056");
		text_score_t.text = GameSettingCtrl.GetLocalizationText("0037");
		anim.SetTrigger("OnStart");
	}

	public void Close()
	{
		Init();
		isUpload = false;
		base.gameObject.SetActive(value: false);
	}
}
[RequireComponent(typeof(CharacterController))]
public class DemoPlayerController : MonoBehaviour
{
	public Camera mainCamera;

	private CharacterController characterController;

	private float movementSpeed = 5f;

	private float rotationX;

	private float rotationY;

	private const float clampAngleDegrees = 80f;

	private const float sensitivity = 2f;

	private void Start()
	{
		characterController = GetComponent<CharacterController>();
		Vector3 eulerAngles = mainCamera.transform.localRotation.eulerAngles;
		rotationX = eulerAngles.x;
		rotationY = eulerAngles.y;
	}

	private void LateUpdate()
	{
		float num = Input.GetAxis("Mouse X");
		float num2 = 0f - Input.GetAxis("Mouse Y");
		if (Input.touchCount > 0 && Input.GetTouch(0).phase == TouchPhase.Began)
		{
			num = 0f;
			num2 = 0f;
		}
		rotationX += 2f * num2;
		rotationY += 2f * num;
		rotationX = Mathf.Clamp(rotationX, -80f, 80f);
		mainCamera.transform.localRotation = Quaternion.Euler(rotationX, rotationY, 0f);
		float axis = Input.GetAxis("Horizontal");
		float axis2 = Input.GetAxis("Vertical");
		Vector3 vector = new Vector3(axis, 0f, axis2);
		vector = mainCamera.transform.localRotation * vector;
		vector.y = 0f;
		characterController.SimpleMove(movementSpeed * vector);
	}

	private void SetCursorLock(bool lockCursor)
	{
		if (lockCursor)
		{
			Cursor.lockState = CursorLockMode.Locked;
			Cursor.visible = false;
		}
		else
		{
			Cursor.lockState = CursorLockMode.None;
			Cursor.visible = true;
		}
	}
}
[RequireComponent(typeof(Renderer))]
public class ResonanceAudioDemoCubeController : MonoBehaviour
{
	private Material material;

	private void Start()
	{
		material = GetComponent<Renderer>().material;
		SetGazedAt(gazedAt: false);
	}

	public void SetGazedAt(bool gazedAt)
	{
		material.color = (gazedAt ? Color.green : Color.red);
	}

	public void TeleportRandomly()
	{
		Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
		onUnitSphere.y = Mathf.Clamp(onUnitSphere.y, 0.5f, 1f);
		float num = 2f * UnityEngine.Random.value + 1.5f;
		base.transform.localPosition = num * onUnitSphere;
	}
}
public class ResonanceAudioDemoManager : MonoBehaviour
{
	public Camera mainCamera;

	public ResonanceAudioDemoCubeController cube;

	private void Start()
	{
		Screen.sleepTimeout = -1;
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
		RaycastHit hitInfo;
		bool flag = Physics.Raycast(mainCamera.ViewportPointToRay(0.5f * Vector2.one), out hitInfo) && hitInfo.transform == cube.transform;
		cube.SetGazedAt(flag);
		if (flag && ((Input.touchCount == 0 && Input.GetMouseButtonDown(0)) || (Input.touchCount > 0 && Input.GetTouch(0).tapCount > 1 && Input.GetTouch(0).phase == TouchPhase.Began)))
		{
			cube.TeleportRandomly();
		}
	}
}
public static class ResonanceAudio
{
	[StructLayout(0)]
	private class RoomProperties
	{
		public float positionX;

		public float positionY;

		public float positionZ;

		public float rotationX;

		public float rotationY;

		public float rotationZ;

		public float rotationW;

		public float dimensionsX;

		public float dimensionsY;

		public float dimensionsZ;

		public ResonanceAudioRoomManager.SurfaceMaterial materialLeft;

		public ResonanceAudioRoomManager.SurfaceMaterial materialRight;

		public ResonanceAudioRoomManager.SurfaceMaterial materialBottom;

		public ResonanceAudioRoomManager.SurfaceMaterial materialTop;

		public ResonanceAudioRoomManager.SurfaceMaterial materialFront;

		public ResonanceAudioRoomManager.SurfaceMaterial materialBack;

		public float reflectionScalar;

		public float reverbGain;

		public float reverbTime;

		public float reverbBrightness;
	}

	private static Transform listenerTransform = null;

	public static readonly Color listenerDirectivityColor = 0.65f * Color.magenta;

	public static readonly Color sourceDirectivityColor = 0.65f * Color.blue;

	public const float distanceEpsilon = 0.01f;

	public const float maxDistanceLimit = 1000000f;

	public const float minDistanceLimit = 990099f;

	public const float maxGainDb = 24f;

	public const float minGainDb = -24f;

	public const float maxReverbBrightness = 1f;

	public const float minReverbBrightness = -1f;

	public const float maxReverbTime = 10f;

	public const float maxReflectivity = 2f;

	public const int maxNumOcclusionHits = 12;

	public const float occlusionDetectionInterval = 0.2f;

	private static readonly Matrix4x4 flipZ = Matrix4x4.Scale(new Vector3(1f, 1f, -1f));

	private static RaycastHit[] occlusionHits = new RaycastHit[12];

	private static int occlusionMaskValue = -1;

	private static float[] roomPosition = new float[3];

	private static RoomProperties roomProperties = new RoomProperties();

	private static IntPtr roomPropertiesPtr = IntPtr.Zero;

	private static Matrix4x4 transformMatrix = Matrix4x4.identity;

	private const string pluginName = "audiopluginresonanceaudio";

	public static Transform ListenerTransform
	{
		get
		{
			if (listenerTransform == null)
			{
				AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
				if (audioListener != null)
				{
					listenerTransform = audioListener.transform;
				}
			}
			return listenerTransform;
		}
	}

	public static void UpdateAudioListener(ResonanceAudioListener listener)
	{
		occlusionMaskValue = listener.occlusionMask.value;
		SetListenerGain(ConvertAmplitudeFromDb(listener.globalGainDb));
		SetListenerStereoSpeakerMode(listener.stereoSpeakerModeEnabled);
	}

	public static void DisableRoomEffects()
	{
		SetRoomProperties(IntPtr.Zero, null);
		if (roomPropertiesPtr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(roomPropertiesPtr);
			roomPropertiesPtr = IntPtr.Zero;
		}
	}

	public static void UpdateRoom(ResonanceAudioRoom room)
	{
		if (roomPropertiesPtr == IntPtr.Zero)
		{
			roomPropertiesPtr = Marshal.AllocHGlobal(Marshal.SizeOf(roomProperties));
		}
		UpdateRoomProperties(room);
		Marshal.StructureToPtr(roomProperties, roomPropertiesPtr, fDeleteOld: false);
		SetRoomProperties(roomPropertiesPtr, null);
		Marshal.DestroyStructure(roomPropertiesPtr, typeof(RoomProperties));
	}

	public static void UpdateReverbProbe(ResonanceAudioReverbProbe reverbPobe)
	{
		if (roomPropertiesPtr == IntPtr.Zero)
		{
			roomPropertiesPtr = Marshal.AllocHGlobal(Marshal.SizeOf(roomProperties));
		}
		UpdateRoomProperties(reverbPobe);
		Marshal.StructureToPtr(roomProperties, roomPropertiesPtr, fDeleteOld: false);
		SetRoomProperties(roomPropertiesPtr, reverbPobe.rt60s);
		Marshal.DestroyStructure(roomPropertiesPtr, typeof(RoomProperties));
	}

	public static bool StartRecording()
	{
		return false;
	}

	public static bool StopRecordingAndSaveToFile(string filePath, bool seamless)
	{
		return false;
	}

	public static void InitializeReverbComputer(float[] vertices, int[] triangles, int[] materialIndices, float scatteringCoefficient)
	{
	}

	public static bool ComputeRt60sAndProxyRoom(ResonanceAudioReverbProbe reverbProbe, int totalNumPaths, int numPathsPerBatch, int maxDepth, float energyThreshold, float listenerSphereRadius)
	{
		return false;
	}

	public static float ComputeOcclusion(Transform sourceTransform)
	{
		float num = 0f;
		if (ListenerTransform != null)
		{
			Vector3 position = listenerTransform.position;
			Vector3 direction = sourceTransform.position - position;
			int num2 = Physics.RaycastNonAlloc(position, direction, occlusionHits, direction.magnitude, occlusionMaskValue);
			for (int i = 0; i < num2; i++)
			{
				if (occlusionHits[i].transform != listenerTransform && occlusionHits[i].transform != sourceTransform)
				{
					num += 1f;
				}
			}
		}
		return num;
	}

	public static float ConvertAmplitudeFromDb(float db)
	{
		return Mathf.Pow(10f, 0.05f * db);
	}

	public static Vector2[] Generate2dPolarPattern(float alpha, float order, int resolution)
	{
		Vector2[] array = new Vector2[resolution];
		float num = (float)Math.PI * 2f / (float)resolution;
		for (int i = 0; i < resolution; i++)
		{
			float f = (float)i * num;
			float num2 = Mathf.Pow(Mathf.Abs(1f - alpha + alpha * Mathf.Cos(f)), order);
			array[i] = new Vector2(num2 * Mathf.Sin(f), num2 * Mathf.Cos(f));
		}
		return array;
	}

	private static void ConvertAudioTransformFromUnity(ref Vector3 position, ref Quaternion rotation)
	{
		transformMatrix = flipZ * Matrix4x4.TRS(position, rotation, Vector3.one) * flipZ;
		position = transformMatrix.GetColumn(3);
		rotation = Quaternion.LookRotation(transformMatrix.GetColumn(2), transformMatrix.GetColumn(1));
	}

	private static void SetProxyRoomProperties(ResonanceAudioReverbProbe reverbProbe, RoomProperties proxyRoomProperties)
	{
		reverbProbe.proxyRoomPosition.x = proxyRoomProperties.positionX;
		reverbProbe.proxyRoomPosition.y = proxyRoomProperties.positionY;
		reverbProbe.proxyRoomPosition.z = proxyRoomProperties.positionZ;
		reverbProbe.proxyRoomRotation.x = proxyRoomProperties.rotationX;
		reverbProbe.proxyRoomRotation.y = proxyRoomProperties.rotationY;
		reverbProbe.proxyRoomRotation.z = proxyRoomProperties.rotationZ;
		reverbProbe.proxyRoomRotation.w = proxyRoomProperties.rotationW;
		reverbProbe.proxyRoomSize.x = proxyRoomProperties.dimensionsX;
		reverbProbe.proxyRoomSize.y = proxyRoomProperties.dimensionsY;
		reverbProbe.proxyRoomSize.z = proxyRoomProperties.dimensionsZ;
		reverbProbe.proxyRoomLeftWall = proxyRoomProperties.materialLeft;
		reverbProbe.proxyRoomRightWall = proxyRoomProperties.materialRight;
		reverbProbe.proxyRoomFloor = proxyRoomProperties.materialBottom;
		reverbProbe.proxyRoomCeiling = proxyRoomProperties.materialTop;
		reverbProbe.proxyRoomBackWall = proxyRoomProperties.materialBack;
		reverbProbe.proxyRoomFrontWall = proxyRoomProperties.materialFront;
	}

	private static void UpdateRoomProperties(ResonanceAudioRoom room)
	{
		FillGeometryOfRoomProperties(room.transform.position, room.transform.rotation, Vector3.Scale(room.transform.lossyScale, room.size));
		FillWallMaterialsOfRoomProperties(room.leftWall, room.rightWall, room.floor, room.ceiling, room.frontWall, room.backWall);
		FillModifiersOfRoomProperties(room.reverbGainDb, room.reverbTime, room.reverbBrightness, room.reflectivity);
	}

	private static void UpdateRoomProperties(ResonanceAudioReverbProbe reverbProbe)
	{
		FillGeometryOfRoomProperties(reverbProbe.proxyRoomPosition, reverbProbe.proxyRoomRotation, reverbProbe.proxyRoomSize);
		FillWallMaterialsOfRoomProperties(reverbProbe.proxyRoomLeftWall, reverbProbe.proxyRoomRightWall, reverbProbe.proxyRoomFloor, reverbProbe.proxyRoomCeiling, reverbProbe.proxyRoomFrontWall, reverbProbe.proxyRoomBackWall);
		float reflectivity = 1f;
		FillModifiersOfRoomProperties(reverbProbe.reverbGainDb, reverbProbe.reverbTime, reverbProbe.reverbBrightness, reflectivity);
	}

	private static void FillGeometryOfRoomProperties(Vector3 position, Quaternion rotation, Vector3 scale)
	{
		ConvertAudioTransformFromUnity(ref position, ref rotation);
		roomProperties.positionX = position.x;
		roomProperties.positionY = position.y;
		roomProperties.positionZ = position.z;
		roomProperties.rotationX = rotation.x;
		roomProperties.rotationY = rotation.y;
		roomProperties.rotationZ = rotation.z;
		roomProperties.rotationW = rotation.w;
		roomProperties.dimensionsX = scale.x;
		roomProperties.dimensionsY = scale.y;
		roomProperties.dimensionsZ = scale.z;
	}

	private static void FillWallMaterialsOfRoomProperties(ResonanceAudioRoomManager.SurfaceMaterial leftWall, ResonanceAudioRoomManager.SurfaceMaterial rightWall, ResonanceAudioRoomManager.SurfaceMaterial floor, ResonanceAudioRoomManager.SurfaceMaterial ceiling, ResonanceAudioRoomManager.SurfaceMaterial frontWall, ResonanceAudioRoomManager.SurfaceMaterial backWall)
	{
		roomProperties.materialLeft = leftWall;
		roomProperties.materialRight = rightWall;
		roomProperties.materialBottom = floor;
		roomProperties.materialTop = ceiling;
		roomProperties.materialFront = frontWall;
		roomProperties.materialBack = backWall;
	}

	private static void FillModifiersOfRoomProperties(float reverbGainDb, float reverbTime, float reverbBrightness, float reflectivity)
	{
		roomProperties.reverbGain = ConvertAmplitudeFromDb(reverbGainDb);
		roomProperties.reverbTime = reverbTime;
		roomProperties.reverbBrightness = reverbBrightness;
		roomProperties.reflectionScalar = reflectivity;
	}

	[DllImport("audiopluginresonanceaudio")]
	private static extern void SetListenerGain(float gain);

	[DllImport("audiopluginresonanceaudio")]
	private static extern void SetListenerStereoSpeakerMode(bool enableStereoSpeakerMode);

	[DllImport("audiopluginresonanceaudio")]
	private static extern void SetRoomProperties(IntPtr roomProperties, float[] rt60s);
}
public class ResonanceAudioAcousticMesh
{
	public bool isIncludedByObjectFiltering;

	private ResonanceAudioRoomManager.SurfaceMaterial[] surfaceMaterialsFromSubMesh;

	private RangeInt[] triangleRangesFromSubMesh;

	private const int unityMaxNumVerticesPerMesh = 65000;

	private const int maxNumSubMeshes = 256;

	private Material visualizationMaterial;

	public Mesh mesh { get; private set; }

	public GameObject sourceObject { get; private set; }

	public static ResonanceAudioAcousticMesh GenerateFromMeshFilter(MeshFilter meshFilter, Shader surfaceMaterialShader)
	{
		GameObject gameObject = meshFilter.gameObject;
		Mesh sharedMesh = meshFilter.sharedMesh;
		if (sharedMesh == null)
		{
			UnityEngine.Debug.LogWarning("GameObject: " + gameObject.name + " has no mesh and will not be included in reverb baking.");
			return null;
		}
		int numTriangleIndices = CountTriangleIndices(sharedMesh);
		int vertexCount = sharedMesh.vertexCount;
		ResonanceAudioAcousticMesh resonanceAudioAcousticMesh = new ResonanceAudioAcousticMesh();
		int[] triangles = null;
		Vector3[] vertices = null;
		resonanceAudioAcousticMesh.InitializeMesh(numTriangleIndices, vertexCount, out triangles, out vertices);
		resonanceAudioAcousticMesh.FillVerticesAndTrianglesFromMesh(sharedMesh, gameObject.transform, ref vertices, ref triangles);
		resonanceAudioAcousticMesh.mesh.vertices = vertices;
		resonanceAudioAcousticMesh.mesh.triangles = triangles;
		resonanceAudioAcousticMesh.mesh.RecalculateNormals();
		resonanceAudioAcousticMesh.InitializeSubMeshMaterials();
		resonanceAudioAcousticMesh.InitializeVisualizationMaterial(surfaceMaterialShader);
		resonanceAudioAcousticMesh.sourceObject = gameObject;
		return resonanceAudioAcousticMesh;
	}

	public static ResonanceAudioAcousticMesh GenerateFromTerrain(Terrain terrain, Shader surfaceMaterialShader)
	{
		TerrainData terrainData = terrain.terrainData;
		float[,] heights = terrainData.GetHeights(0, 0, terrainData.heightmapResolution, terrainData.heightmapResolution);
		SubSampleHeightMap(heights.GetLength(0), heights.GetLength(1), out var m, out var n, out var subSampleStep, out var subSampledNumTriangleIndices);
		ResonanceAudioAcousticMesh resonanceAudioAcousticMesh = new ResonanceAudioAcousticMesh();
		resonanceAudioAcousticMesh.InitializeMesh(subSampledNumTriangleIndices, subSampledNumTriangleIndices, out var triangles, out var vertices);
		resonanceAudioAcousticMesh.FillTrianglesAndVerticesFromHeightMap(terrain.transform.position, terrainData.size, heights, m, n, subSampleStep, ref triangles, ref vertices);
		resonanceAudioAcousticMesh.mesh.vertices = vertices;
		resonanceAudioAcousticMesh.mesh.triangles = triangles;
		resonanceAudioAcousticMesh.mesh.RecalculateNormals();
		resonanceAudioAcousticMesh.InitializeSubMeshMaterials();
		resonanceAudioAcousticMesh.InitializeVisualizationMaterial(surfaceMaterialShader);
		resonanceAudioAcousticMesh.sourceObject = terrain.gameObject;
		return resonanceAudioAcousticMesh;
	}

	public int[] GetSurfaceMaterialIndicesFromTriangle()
	{
		int[] array = new int[mesh.triangles.Length / 3];
		for (int i = 0; i < surfaceMaterialsFromSubMesh.Length; i++)
		{
			int num = (int)surfaceMaterialsFromSubMesh[i];
			for (int j = triangleRangesFromSubMesh[i].start; j < triangleRangesFromSubMesh[i].end; j++)
			{
				array[j] = num;
			}
		}
		return array;
	}

	public void SetSurfaceMaterialToAllSubMeshes(ResonanceAudioRoomManager.SurfaceMaterial surfaceMaterial)
	{
		for (int i = 0; i < surfaceMaterialsFromSubMesh.Length; i++)
		{
			surfaceMaterialsFromSubMesh[i] = surfaceMaterial;
		}
		SetSubMeshSurfaceMaterials();
	}

	public void SetSurfaceMaterialToSubMesh(ResonanceAudioRoomManager.SurfaceMaterial surfaceMaterial, int subMeshIndex)
	{
		if (subMeshIndex < 0 || subMeshIndex >= triangleRangesFromSubMesh.Length)
		{
			UnityEngine.Debug.LogError("subMeshIndex= " + subMeshIndex + " out of range [0, " + triangleRangesFromSubMesh.Length + "]");
		}
		else
		{
			surfaceMaterialsFromSubMesh[subMeshIndex] = surfaceMaterial;
			SetSubMeshSurfaceMaterials();
		}
	}

	public bool Render()
	{
		if (mesh == null)
		{
			return false;
		}
		Graphics.DrawMesh(mesh, Matrix4x4.identity, visualizationMaterial, 0);
		return true;
	}

	public bool IsIncluded()
	{
		if (!isIncludedByObjectFiltering)
		{
			return false;
		}
		if (mesh == null)
		{
			return false;
		}
		if (sourceObject == null || !sourceObject.activeInHierarchy)
		{
			return false;
		}
		return true;
	}

	public bool IsSubMeshTriangular(int subMeshIndex)
	{
		return triangleRangesFromSubMesh[subMeshIndex].length > 0;
	}

	private static int CountTriangleIndices(Mesh sourceMesh)
	{
		int num = 0;
		for (int i = 0; i < sourceMesh.subMeshCount; i++)
		{
			if (sourceMesh.GetTopology(i) == MeshTopology.Triangles)
			{
				num += (int)sourceMesh.GetIndexCount(i);
			}
		}
		return num;
	}

	private static void SubSampleHeightMap(int originalM, int originalN, out int m, out int n, out int subSampleStep, out int subSampledNumTriangleIndices)
	{
		m = originalM;
		n = originalN;
		subSampledNumTriangleIndices = (m - 1) * (n - 1) * 6;
		subSampleStep = 1;
		while (subSampledNumTriangleIndices >= 65000)
		{
			subSampleStep *= 2;
			m = (m - 1) / 2 + 1;
			n = (n - 1) / 2 + 1;
			subSampledNumTriangleIndices = (m - 1) * (n - 1) * 6;
		}
	}

	private void InitializeMesh(int numTriangleIndices, int numVertices, out int[] triangles, out Vector3[] vertices)
	{
		if (mesh == null)
		{
			mesh = new Mesh();
		}
		triangles = mesh.triangles;
		Array.Resize(ref triangles, numTriangleIndices);
		vertices = mesh.vertices;
		Array.Resize(ref vertices, numVertices);
	}

	private void InitializeSubMeshMaterials()
	{
		int num = triangleRangesFromSubMesh.Length;
		if (surfaceMaterialsFromSubMesh == null || surfaceMaterialsFromSubMesh.Length != num)
		{
			surfaceMaterialsFromSubMesh = new ResonanceAudioRoomManager.SurfaceMaterial[num];
			for (int i = 0; i < num; i++)
			{
				surfaceMaterialsFromSubMesh[i] = ResonanceAudioRoomManager.SurfaceMaterial.Transparent;
			}
		}
	}

	private void InitializeVisualizationMaterial(Shader surfaceMaterialShader)
	{
		if (visualizationMaterial == null)
		{
			visualizationMaterial = new Material(surfaceMaterialShader);
		}
		SetSubMeshEnds();
	}

	private void FillVerticesAndTrianglesFromMesh(Mesh sourceMesh, Transform sourceObjectTransform, ref Vector3[] vertices, ref int[] triangles)
	{
		Vector3[] vertices2 = sourceMesh.vertices;
		for (int i = 0; i < vertices2.Length; i++)
		{
			vertices[i] = sourceObjectTransform.TransformPoint(vertices2[i]);
		}
		Array.Resize(ref triangleRangesFromSubMesh, sourceMesh.subMeshCount);
		Vector3 lossyScale = sourceObjectTransform.lossyScale;
		bool flag = lossyScale.x * lossyScale.y * lossyScale.z < 0f;
		int num = 0;
		for (int j = 0; j < sourceMesh.subMeshCount; j++)
		{
			triangleRangesFromSubMesh[j].start = num / 3;
			if (sourceMesh.GetTopology(j) != 0)
			{
				triangleRangesFromSubMesh[j].length = 0;
				continue;
			}
			int[] triangles2 = sourceMesh.GetTriangles(j);
			for (int k = 0; k < triangles2.Length; k += 3)
			{
				if (flag)
				{
					triangles[num] = triangles2[k + 2];
					triangles[num + 1] = triangles2[k + 1];
					triangles[num + 2] = triangles2[k];
				}
				else
				{
					triangles[num] = triangles2[k];
					triangles[num + 1] = triangles2[k + 1];
					triangles[num + 2] = triangles2[k + 2];
				}
				num += 3;
			}
			triangleRangesFromSubMesh[j].length = triangles2.Length / 3;
		}
	}

	private void FillTrianglesAndVerticesFromHeightMap(Vector3 terrainPosition, Vector3 terrainSize, float[,] heightMap, int m, int n, int subSampleStep, ref int[] triangles, ref Vector3[] vertices)
	{
		int num = 6;
		int[,] array = new int[6, 2]
		{
			{ 0, 0 },
			{ 1, 0 },
			{ 0, 1 },
			{ 0, 1 },
			{ 1, 0 },
			{ 1, 1 }
		};
		int length = heightMap.GetLength(0);
		int length2 = heightMap.GetLength(1);
		Vector3 b = Vector3.Scale(terrainSize, new Vector3(1f / (float)(length2 - 1), 1f, 1f / (float)(length - 1)));
		Vector3 a = default(Vector3);
		for (int i = 0; i < m - 1; i++)
		{
			for (int j = 0; j < n - 1; j++)
			{
				int num2 = i * (n - 1) + j;
				for (int k = 0; k < num; k++)
				{
					int num3 = num * num2 + k;
					triangles[num3] = num3;
					int num4 = (i + array[k, 0]) * subSampleStep;
					int num5 = (j + array[k, 1]) * subSampleStep;
					a.Set(num5, heightMap[num4, num5], num4);
					vertices[num3] = terrainPosition + Vector3.Scale(a, b);
				}
			}
		}
		Array.Resize(ref triangleRangesFromSubMesh, 1);
		triangleRangesFromSubMesh[0].start = 0;
		triangleRangesFromSubMesh[0].length = triangles.Length / 3;
	}

	private void SetSubMeshEnds()
	{
		int num = surfaceMaterialsFromSubMesh.Length;
		if (num > 256)
		{
			UnityEngine.Debug.LogError("Too many sub-meshes: " + sourceObject.name + " has " + num + " sub-meshes. Sub-meshes more than " + 256 + " are not allowed.");
		}
		else
		{
			float[] array = new float[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = triangleRangesFromSubMesh[i].end;
			}
			visualizationMaterial.SetFloatArray("_SubMeshEnds", array);
			visualizationMaterial.SetInt("_NumSubMeshes", num);
		}
	}

	private void SetSubMeshSurfaceMaterials()
	{
		int num = surfaceMaterialsFromSubMesh.Length;
		float[] array = visualizationMaterial.GetFloatArray("_SubMeshMaterials");
		if (array == null)
		{
			array = new float[num];
		}
		for (int i = 0; i < surfaceMaterialsFromSubMesh.Length; i++)
		{
			array[i] = (float)surfaceMaterialsFromSubMesh[i];
		}
		visualizationMaterial.SetFloatArray("_SubMeshSurfaceMaterials", array);
	}
}
[AddComponentMenu("ResonanceAudio/ResonanceAudioListener")]
[RequireComponent(typeof(AudioListener))]
[ExecuteInEditMode]
public class ResonanceAudioListener : MonoBehaviour
{
	[Tooltip("Sets the global gain for all spatialized audio sources. Can be used to adjust the overall output volume.")]
	public float globalGainDb;

	[Tooltip("Sets the global layer mask for occlusion detection.")]
	public LayerMask occlusionMask = -1;

	[Tooltip("Disables HRTF-based rendering and force stereo-panning only rendering for all spatialized audio sources. This mode is recommended only when the audio output is routed to a stereo loudspeaker configuration.")]
	public bool stereoSpeakerModeEnabled;

	[Tooltip("Sets whether the recorded soundfield clip should be saved as a seamless loop.")]
	public bool recorderSeamless;

	[Tooltip("Specify by tag which spatialized audio sources will be recorded. Choose \"Untagged\" to include all enabled spatialized audio sources in the scene.")]
	public string recorderSourceTag = "Untagged";

	[SerializeField]
	private bool recorderFoldout;

	private List<AudioSource> recorderTaggedSources;

	private double recorderStartTime;

	public bool IsRecording { get; private set; }

	private void OnEnable()
	{
		if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying)
		{
			IsRecording = false;
			recorderStartTime = 0.0;
			recorderTaggedSources = new List<AudioSource>();
		}
	}

	private void OnDisable()
	{
		if (UnityEngine.Application.isEditor && IsRecording)
		{
			StopSoundfieldRecorder(null);
			UnityEngine.Debug.LogWarning("Soundfield recording is stopped.");
		}
	}

	private void Update()
	{
		if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying && !IsRecording)
		{
			UpdateTaggedSources();
		}
		else
		{
			ResonanceAudio.UpdateAudioListener(this);
		}
	}

	public double GetCurrentRecordDuration()
	{
		if (IsRecording)
		{
			return AudioSettings.dspTime - recorderStartTime;
		}
		return 0.0;
	}

	public void StartSoundfieldRecorder()
	{
		if (!UnityEngine.Application.isEditor || UnityEngine.Application.isPlaying)
		{
			UnityEngine.Debug.LogError("Soundfield recording is only supported in Unity Editor \"Edit Mode\".");
			return;
		}
		if (IsRecording)
		{
			UnityEngine.Debug.LogWarning("Soundfield recording is already in progress.");
			return;
		}
		recorderStartTime = AudioSettings.dspTime;
		for (int i = 0; i < recorderTaggedSources.Count; i++)
		{
			if (recorderTaggedSources[i].playOnAwake)
			{
				recorderTaggedSources[i].PlayScheduled(recorderStartTime);
			}
		}
		IsRecording = ResonanceAudio.StartRecording();
		if (!IsRecording)
		{
			UnityEngine.Debug.LogError("Failed to start soundfield recording.");
			IsRecording = false;
			for (int j = 0; j < recorderTaggedSources.Count; j++)
			{
				recorderTaggedSources[j].Stop();
			}
		}
	}

	public void StopSoundfieldRecorder(string filePath)
	{
		if (!UnityEngine.Application.isEditor || UnityEngine.Application.isPlaying)
		{
			UnityEngine.Debug.LogError("Soundfield recording is only supported in Unity Editor \"Edit Mode\".");
			return;
		}
		if (!IsRecording)
		{
			UnityEngine.Debug.LogWarning("No recorded soundfield was found.");
			return;
		}
		IsRecording = false;
		recorderStartTime = 0.0;
		if (!ResonanceAudio.StopRecordingAndSaveToFile(filePath, recorderSeamless))
		{
			UnityEngine.Debug.LogError("Failed to save soundfield recording into file.");
		}
		for (int i = 0; i < recorderTaggedSources.Count; i++)
		{
			recorderTaggedSources[i].Stop();
		}
	}

	private void UpdateTaggedSources()
	{
		recorderTaggedSources.Clear();
		AudioSource[] array = UnityEngine.Object.FindObjectsOfType<AudioSource>();
		for (int i = 0; i < array.Length; i++)
		{
			if ((recorderSourceTag == "Untagged" || array[i].tag == recorderSourceTag) && array[i].enabled && array[i].spatialize)
			{
				recorderTaggedSources.Add(array[i]);
			}
		}
	}
}
[CreateAssetMenu(fileName = "New Material Map", menuName = "ResonanceAudio/Material Map", order = 1000)]
public class ResonanceAudioMaterialMap : ScriptableObject
{
	public static readonly Color[] surfaceMaterialColors = new Color[23]
	{
		new Color(0.5f, 0.5f, 0.5f),
		new Color(0.545098f, 0.909804f, 0.678431f),
		new Color(0.184314f, 0.258824f, 0.521569f),
		new Color(0.552941f, 0.737255f, 0.976471f),
		new Color(0.035294f, 0.376471f, 0.07451f),
		new Color(0.952941f, 0.415686f, 0.835294f),
		new Color(0.105882f, 0.894118f, 0.427451f),
		new Color(0.541176f, 0.015686f, 0.345098f),
		new Color(0.631373f, 0.847059f, 0.196078f),
		new Color(0.513725f, 0.003922f, 0.741176f),
		new Color(0.94902f, 0.690196f, 0.964706f),
		new Color(0.082353f, 0.305882f, 0.337255f),
		new Color(0.152941f, 0.792157f, 0.901961f),
		new Color(0.921569f, 0.070588f, 0.254902f),
		new Color(0.27451f, 0.635294f, 0.423529f),
		new Color(0.556863f, 0.215686f, 0.066667f),
		new Color(0.960784f, 0.803922f, 0.686275f),
		new Color(0.305882f, 0.282353f, 0.035294f),
		new Color(0.917647f, 0.839216f, 0.141176f),
		new Color(0.521569f, 0.458824f, 0.858824f),
		new Color(0.937255f, 0.592157f, 0.176471f),
		new Color(0.980392f, 0.105882f, 0.988235f),
		new Color(0.72549f, 0.423529f, 0.552941f)
	};

	[SerializeField]
	private ResonanceAudioRoomManager.SurfaceMaterialDictionary surfaceMaterialFromGuid;

	private const ResonanceAudioRoomManager.SurfaceMaterial defaultSurfaceMaterial = ResonanceAudioRoomManager.SurfaceMaterial.Transparent;

	public List<string> GuidList()
	{
		return surfaceMaterialFromGuid.Keys.ToList();
	}

	public ResonanceAudioRoomManager.SurfaceMaterial GetMaterialFromGuid(string guid)
	{
		return surfaceMaterialFromGuid[guid];
	}

	public void AddDefaultMaterialIfGuidUnmapped(string guid)
	{
		if (!surfaceMaterialFromGuid.ContainsKey(guid))
		{
			surfaceMaterialFromGuid.Add(guid, ResonanceAudioRoomManager.SurfaceMaterial.Transparent);
		}
	}
}
public class ResonanceAudioMaterialMapper : ScriptableObject
{
	private class UnityMaterialAcousticMeshData
	{
		public List<ResonanceAudioAcousticMesh> acousticMeshes;

		public List<int> subMeshIndices;

		public UnityMaterialAcousticMeshData()
		{
			acousticMeshes = new List<ResonanceAudioAcousticMesh>();
			subMeshIndices = new List<int>();
		}
	}

	private class TerrainAcousticMeshData
	{
		public List<ResonanceAudioAcousticMesh> acousticMeshes;

		public TerrainAcousticMeshData()
		{
			acousticMeshes = new List<ResonanceAudioAcousticMesh>();
		}
	}

	[SerializeField]
	private ResonanceAudioMaterialMap materialMap;

	private Dictionary<string, UnityMaterialAcousticMeshData> unityMaterialAcousticMeshDataFromGuid;

	private Dictionary<string, TerrainAcousticMeshData> terrainAcousticMeshDataFromGuid;

	[SerializeField]
	private LayerMask reverbLayerMask = -1;

	[SerializeField]
	private bool includeNonStaticGameObjects = true;

	public void Initialize()
	{
		unityMaterialAcousticMeshDataFromGuid = new Dictionary<string, UnityMaterialAcousticMeshData>();
		terrainAcousticMeshDataFromGuid = new Dictionary<string, TerrainAcousticMeshData>();
	}

	public void ApplyMaterialMapping(MeshRenderer[] meshRenderers, List<string>[] guidsForMeshRenderers, Terrain[] activeTerrains, string[] guidsForTerrains, Shader surfaceMaterialShader)
	{
		BuildUnityMaterialData(meshRenderers, guidsForMeshRenderers, surfaceMaterialShader);
		BuildTerrainData(activeTerrains, guidsForTerrains, surfaceMaterialShader);
		ApplyMaterialMappingToGuids(materialMap.GuidList());
		ApplyObjectFiltering();
	}

	public void RenderAcousticMeshes()
	{
		List<ResonanceAudioAcousticMesh> includedAcousticMeshes = GetIncludedAcousticMeshes();
		for (int i = 0; i < includedAcousticMeshes.Count; i++)
		{
			includedAcousticMeshes[i].Render();
		}
	}

	public List<ResonanceAudioAcousticMesh> GetIncludedAcousticMeshes()
	{
		List<ResonanceAudioAcousticMesh> list = new List<ResonanceAudioAcousticMesh>();
		foreach (UnityMaterialAcousticMeshData value in unityMaterialAcousticMeshDataFromGuid.Values)
		{
			for (int i = 0; i < value.acousticMeshes.Count; i++)
			{
				ResonanceAudioAcousticMesh resonanceAudioAcousticMesh = value.acousticMeshes[i];
				if (resonanceAudioAcousticMesh.IsIncluded())
				{
					list.Add(resonanceAudioAcousticMesh);
				}
			}
		}
		foreach (TerrainAcousticMeshData value2 in terrainAcousticMeshDataFromGuid.Values)
		{
			for (int j = 0; j < value2.acousticMeshes.Count; j++)
			{
				ResonanceAudioAcousticMesh resonanceAudioAcousticMesh2 = value2.acousticMeshes[j];
				if (resonanceAudioAcousticMesh2.IsIncluded())
				{
					list.Add(resonanceAudioAcousticMesh2);
				}
			}
		}
		return list;
	}

	private void BuildUnityMaterialData(MeshRenderer[] meshRenderers, List<string>[] guidsForMeshRenderers, Shader surfaceMaterialShader)
	{
		unityMaterialAcousticMeshDataFromGuid.Clear();
		for (int i = 0; i < meshRenderers.Length; i++)
		{
			MeshRenderer obj = meshRenderers[i];
			GameObject gameObject = obj.gameObject;
			Material[] sharedMaterials = obj.sharedMaterials;
			if (sharedMaterials.Length == 0 || !gameObject.activeInHierarchy)
			{
				continue;
			}
			ResonanceAudioAcousticMesh resonanceAudioAcousticMesh = ResonanceAudioAcousticMesh.GenerateFromMeshFilter(gameObject.GetComponent<MeshFilter>(), surfaceMaterialShader);
			if (resonanceAudioAcousticMesh == null)
			{
				continue;
			}
			List<string> list = guidsForMeshRenderers[i];
			for (int j = 0; j < sharedMaterials.Length; j++)
			{
				if (resonanceAudioAcousticMesh.IsSubMeshTriangular(j))
				{
					string text = list[j];
					materialMap.AddDefaultMaterialIfGuidUnmapped(text);
					if (!unityMaterialAcousticMeshDataFromGuid.ContainsKey(text))
					{
						unityMaterialAcousticMeshDataFromGuid[text] = new UnityMaterialAcousticMeshData();
					}
					UnityMaterialAcousticMeshData unityMaterialAcousticMeshData = unityMaterialAcousticMeshDataFromGuid[text];
					unityMaterialAcousticMeshData.acousticMeshes.Add(resonanceAudioAcousticMesh);
					unityMaterialAcousticMeshData.subMeshIndices.Add(j);
				}
			}
		}
	}

	private void BuildTerrainData(Terrain[] activeTerrains, string[] guidsForTerrains, Shader surfaceMaterialShader)
	{
		terrainAcousticMeshDataFromGuid.Clear();
		for (int i = 0; i < activeTerrains.Length; i++)
		{
			Terrain terrain = activeTerrains[i];
			string text = guidsForTerrains[i];
			ResonanceAudioAcousticMesh item = ResonanceAudioAcousticMesh.GenerateFromTerrain(terrain, surfaceMaterialShader);
			materialMap.AddDefaultMaterialIfGuidUnmapped(text);
			if (!terrainAcousticMeshDataFromGuid.ContainsKey(text))
			{
				terrainAcousticMeshDataFromGuid[text] = new TerrainAcousticMeshData();
			}
			terrainAcousticMeshDataFromGuid[text].acousticMeshes.Add(item);
		}
	}

	private void ApplyMaterialMappingToGuids(List<string> guids)
	{
		for (int i = 0; i < guids.Count; i++)
		{
			string text = guids[i];
			ResonanceAudioRoomManager.SurfaceMaterial materialFromGuid = materialMap.GetMaterialFromGuid(text);
			if (unityMaterialAcousticMeshDataFromGuid.ContainsKey(text))
			{
				ApplySurfaceMaterialToGameObjects(materialFromGuid, text);
			}
			else if (terrainAcousticMeshDataFromGuid.ContainsKey(text))
			{
				ApplySurfaceMaterialToTerrains(materialFromGuid, text);
			}
		}
	}

	private void ApplySurfaceMaterialToGameObjects(ResonanceAudioRoomManager.SurfaceMaterial surfaceMaterial, string guid)
	{
		UnityMaterialAcousticMeshData unityMaterialAcousticMeshData = unityMaterialAcousticMeshDataFromGuid[guid];
		if (unityMaterialAcousticMeshData.acousticMeshes.Count != unityMaterialAcousticMeshData.subMeshIndices.Count)
		{
			UnityEngine.Debug.LogError("Number of acoustic meshes (" + unityMaterialAcousticMeshData.acousticMeshes.Count + ") != number of sub-mesh indices (" + unityMaterialAcousticMeshData.subMeshIndices.Count + ")");
		}
		List<ResonanceAudioAcousticMesh> acousticMeshes = unityMaterialAcousticMeshData.acousticMeshes;
		List<int> subMeshIndices = unityMaterialAcousticMeshData.subMeshIndices;
		for (int i = 0; i < acousticMeshes.Count; i++)
		{
			acousticMeshes[i].SetSurfaceMaterialToSubMesh(surfaceMaterial, subMeshIndices[i]);
		}
	}

	private void ApplySurfaceMaterialToTerrains(ResonanceAudioRoomManager.SurfaceMaterial surfaceMaterial, string guid)
	{
		List<ResonanceAudioAcousticMesh> list = terrainAcousticMeshDataFromGuid[guid].acousticMeshes.ToList();
		for (int i = 0; i < list.Count; i++)
		{
			list[i].SetSurfaceMaterialToAllSubMeshes(surfaceMaterial);
		}
	}

	private void ApplyObjectFiltering()
	{
		List<UnityMaterialAcousticMeshData> list = unityMaterialAcousticMeshDataFromGuid.Values.ToList();
		for (int i = 0; i < list.Count; i++)
		{
			UnityMaterialAcousticMeshData unityMaterialAcousticMeshData = list[i];
			for (int j = 0; j < unityMaterialAcousticMeshData.acousticMeshes.Count; j++)
			{
				ResonanceAudioAcousticMesh resonanceAudioAcousticMesh = unityMaterialAcousticMeshData.acousticMeshes[j];
				resonanceAudioAcousticMesh.isIncludedByObjectFiltering = IsIncludedByObjectFiltering(resonanceAudioAcousticMesh.sourceObject);
			}
		}
		List<TerrainAcousticMeshData> list2 = terrainAcousticMeshDataFromGuid.Values.ToList();
		for (int k = 0; k < list2.Count; k++)
		{
			TerrainAcousticMeshData terrainAcousticMeshData = list2[k];
			for (int l = 0; l < terrainAcousticMeshData.acousticMeshes.Count; l++)
			{
				ResonanceAudioAcousticMesh resonanceAudioAcousticMesh2 = terrainAcousticMeshData.acousticMeshes[l];
				resonanceAudioAcousticMesh2.isIncludedByObjectFiltering = IsIncludedByObjectFiltering(resonanceAudioAcousticMesh2.sourceObject);
			}
		}
	}

	private bool IsIncludedByObjectFiltering(GameObject gameObject)
	{
		if (((1 << gameObject.layer) & reverbLayerMask.value) == 0)
		{
			return false;
		}
		if (!includeNonStaticGameObjects)
		{
			return gameObject.isStatic;
		}
		return true;
	}
}
[AddComponentMenu("")]
[ExecuteInEditMode]
public class ResonanceAudioMaterialMapperUpdater : MonoBehaviour
{
	public delegate void RefreshMaterialMapperDelegate();

	public RefreshMaterialMapperDelegate RefreshMaterialMapper;

	private void Update()
	{
		if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying && RefreshMaterialMapper != null)
		{
			RefreshMaterialMapper();
		}
	}
}
[AddComponentMenu("ResonanceAudio/ResonanceAudioReverbProbe")]
[ExecuteInEditMode]
public class ResonanceAudioReverbProbe : MonoBehaviour
{
	public enum RegionShape
	{
		Sphere,
		Box
	}

	[Tooltip("Time required in seconds for the reverb to decay by 60 dB for each frequency band.")]
	public float[] rt60s = new float[9];

	[Tooltip("Adjusts the reverb gain in the room.")]
	public float reverbGainDb;

	[Tooltip("Adjusts the balance between high and low frequencies in the reverb. Increasing this value will increase high frequencies in the reverb, while decreasing the low frequencies respectively.")]
	public float reverbBrightness;

	[Tooltip("Adjusts the overall duration of the reverb by a positive scaling factor.")]
	public float reverbTime = 1f;

	[Tooltip("Shape of the region of application of this reverb.")]
	public RegionShape regionShape = RegionShape.Box;

	[Tooltip("Sets the dimensions of a box-shaped region of application in meters relative to the scale of the game object.")]
	public Vector3 boxRegionSize = Vector3.one;

	[Tooltip("Sets the radius of a spherical region of application in meters relative to the scale of the game object.")]
	public float sphereRegionRadius = 1f;

	[Tooltip("Applies this reverb only when the center of the probe is visible from the listener. The visibility check will be done using physics raycast with respect to the Occlusion Mask selection in the ResonanceAudioListener component.")]
	public bool onlyApplyWhenVisible = true;

	public Vector3 proxyRoomPosition = Vector3.zero;

	public Quaternion proxyRoomRotation = Quaternion.identity;

	public Vector3 proxyRoomSize = Vector3.one;

	public ResonanceAudioRoomManager.SurfaceMaterial proxyRoomLeftWall;

	public ResonanceAudioRoomManager.SurfaceMaterial proxyRoomRightWall;

	public ResonanceAudioRoomManager.SurfaceMaterial proxyRoomFloor;

	public ResonanceAudioRoomManager.SurfaceMaterial proxyRoomCeiling;

	public ResonanceAudioRoomManager.SurfaceMaterial proxyRoomBackWall;

	public ResonanceAudioRoomManager.SurfaceMaterial proxyRoomFrontWall;

	private void OnEnable()
	{
		ResonanceAudioRoomManager.UpdateReverbProbe(this);
	}

	private void OnDisable()
	{
		ResonanceAudioRoomManager.RemoveReverbProbe(this);
	}

	private void Update()
	{
		ResonanceAudioRoomManager.UpdateReverbProbe(this);
	}

	public float GetScaledSphericalRegionRadius()
	{
		Vector3 lossyScale = base.transform.lossyScale;
		float num = Mathf.Max(Mathf.Max(lossyScale.x, lossyScale.y), lossyScale.z);
		return sphereRegionRadius * num;
	}

	public Vector3 GetScaledBoxRegionSize()
	{
		return Vector3.Scale(base.transform.lossyScale, boxRegionSize);
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.magenta;
		switch (regionShape)
		{
		case RegionShape.Sphere:
			Gizmos.DrawWireSphere(base.transform.position, GetScaledSphericalRegionRadius());
			break;
		case RegionShape.Box:
			Gizmos.matrix = base.transform.localToWorldMatrix;
			Gizmos.DrawWireCube(Vector3.zero, boxRegionSize);
			break;
		}
	}
}
[AddComponentMenu("ResonanceAudio/ResonanceAudioRoom")]
public class ResonanceAudioRoom : MonoBehaviour
{
	[Tooltip("Left wall surface material used to calculate the acoustic properties of the room.")]
	public ResonanceAudioRoomManager.SurfaceMaterial leftWall = ResonanceAudioRoomManager.SurfaceMaterial.ConcreteBlockCoarse;

	[Tooltip("Right wall surface material used to calculate the acoustic properties of the room.")]
	public ResonanceAudioRoomManager.SurfaceMaterial rightWall = ResonanceAudioRoomManager.SurfaceMaterial.ConcreteBlockCoarse;

	[Tooltip("Floor surface material used to calculate the acoustic properties of the room.")]
	public ResonanceAudioRoomManager.SurfaceMaterial floor = ResonanceAudioRoomManager.SurfaceMaterial.ParquetOnConcrete;

	[Tooltip("Ceiling surface material used to calculate the acoustic properties of the room.")]
	public ResonanceAudioRoomManager.SurfaceMaterial ceiling = ResonanceAudioRoomManager.SurfaceMaterial.PlasterRough;

	[Tooltip("Back wall surface material used to calculate the acoustic properties of the room.")]
	public ResonanceAudioRoomManager.SurfaceMaterial backWall = ResonanceAudioRoomManager.SurfaceMaterial.ConcreteBlockCoarse;

	[Tooltip("Front wall surface material used to calculate the acoustic properties of the room.")]
	public ResonanceAudioRoomManager.SurfaceMaterial frontWall = ResonanceAudioRoomManager.SurfaceMaterial.ConcreteBlockCoarse;

	[Tooltip("Adjusts what proportion of the direct sound is reflected back by each surface, after an appropriate delay. Reverberation is unaffected by this setting.")]
	public float reflectivity = 1f;

	[Tooltip("Adjusts the reverb gain in the room.")]
	public float reverbGainDb;

	[Tooltip("Adjusts the balance between high and low frequencies in the reverb. Increasing this value will increase high frequencies in the reverb, while decreasing the low frequencies respectively.")]
	public float reverbBrightness;

	[Tooltip("Adjusts the overall duration of the reverb by a positive scaling factor.")]
	public float reverbTime = 1f;

	[Tooltip("Sets the room dimensions in meters relative to the scale of the game object.")]
	public Vector3 size = Vector3.one;

	private void OnEnable()
	{
		ResonanceAudioRoomManager.UpdateRoom(this);
	}

	private void OnDisable()
	{
		ResonanceAudioRoomManager.RemoveRoom(this);
	}

	private void Update()
	{
		ResonanceAudioRoomManager.UpdateRoom(this);
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.yellow;
		Gizmos.matrix = base.transform.localToWorldMatrix;
		Gizmos.DrawWireCube(Vector3.zero, size);
	}
}
public static class ResonanceAudioRoomManager
{
	public enum SurfaceMaterial
	{
		Transparent,
		AcousticCeilingTiles,
		BrickBare,
		BrickPainted,
		ConcreteBlockCoarse,
		ConcreteBlockPainted,
		CurtainHeavy,
		FiberglassInsulation,
		GlassThin,
		GlassThick,
		Grass,
		LinoleumOnConcrete,
		Marble,
		Metal,
		ParquetOnConcrete,
		PlasterRough,
		PlasterSmooth,
		PlywoodPanel,
		PolishedConcreteOrTile,
		Sheetrock,
		WaterOrIceSurface,
		WoodCeiling,
		WoodPanel
	}

	[Serializable]
	public class SurfaceMaterialDictionary : Dictionary<string, SurfaceMaterial>, ISerializationCallbackReceiver
	{
		[SerializeField]
		private List<string> guids;

		[SerializeField]
		private List<SurfaceMaterial> surfaceMaterials;

		public SurfaceMaterialDictionary()
		{
			guids = new List<string>();
			surfaceMaterials = new List<SurfaceMaterial>();
		}

		public void OnBeforeSerialize()
		{
			guids.Clear();
			surfaceMaterials.Clear();
			using Enumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				KeyValuePair<string, SurfaceMaterial> current = enumerator.Current;
				guids.Add(current.Key);
				surfaceMaterials.Add(current.Value);
			}
		}

		public void OnAfterDeserialize()
		{
			Clear();
			for (int i = 0; i < guids.Count; i++)
			{
				Add(guids[i], surfaceMaterials[i]);
			}
		}
	}

	private struct RoomEffectsRegion
	{
		public ResonanceAudioRoom room;

		public ResonanceAudioReverbProbe reverbProbe;

		public RoomEffectsRegion(ResonanceAudioRoom room, ResonanceAudioReverbProbe reverbProbe)
		{
			this.room = room;
			this.reverbProbe = reverbProbe;
		}
	}

	private static List<RoomEffectsRegion> roomEffectsRegions = new List<RoomEffectsRegion>();

	private static Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

	public static float ComputeRoomEffectsGain(Vector3 sourcePosition)
	{
		if (roomEffectsRegions.Count == 0)
		{
			return 1f;
		}
		float num = 0f;
		RoomEffectsRegion roomEffectsRegion = roomEffectsRegions[roomEffectsRegions.Count - 1];
		if (roomEffectsRegion.room != null)
		{
			ResonanceAudioRoom room = roomEffectsRegion.room;
			bounds.size = Vector3.Scale(room.transform.lossyScale, room.size);
			Vector3 vector = Quaternion.Inverse(room.transform.rotation) * (sourcePosition - room.transform.position);
			Vector3 b = bounds.ClosestPoint(vector);
			num = Vector3.Distance(vector, b);
		}
		else
		{
			ResonanceAudioReverbProbe reverbProbe = roomEffectsRegion.reverbProbe;
			Vector3 vector2 = sourcePosition - reverbProbe.transform.position;
			if (reverbProbe.regionShape == ResonanceAudioReverbProbe.RegionShape.Box)
			{
				bounds.size = reverbProbe.GetScaledBoxRegionSize();
				vector2 = Quaternion.Inverse(reverbProbe.transform.rotation) * vector2;
				Vector3 b2 = bounds.ClosestPoint(vector2);
				num = Vector3.Distance(vector2, b2);
			}
			else
			{
				float scaledSphericalRegionRadius = reverbProbe.GetScaledSphericalRegionRadius();
				num = Mathf.Max(0f, vector2.magnitude - scaledSphericalRegionRadius);
			}
		}
		return ComputeRoomEffectsAttenuation(num);
	}

	public static void UpdateRoom(ResonanceAudioRoom room)
	{
		UpdateRoomEffectsRegions(room, IsListenerInsideRoom(room));
		UpdateRoomEffects();
	}

	public static void RemoveRoom(ResonanceAudioRoom room)
	{
		UpdateRoomEffectsRegions(room, isEnabled: false);
		UpdateRoomEffects();
	}

	public static void UpdateReverbProbe(ResonanceAudioReverbProbe reverbProbe)
	{
		UpdateRoomEffectsRegions(reverbProbe, IsListenerInsideVisibleReverbProbe(reverbProbe));
		UpdateRoomEffects();
	}

	public static void RemoveReverbProbe(ResonanceAudioReverbProbe reverbProbe)
	{
		UpdateRoomEffectsRegions(reverbProbe, isEnabled: false);
		UpdateRoomEffects();
	}

	private static void UpdateRoomEffectsRegions(ResonanceAudioRoom room, bool isEnabled)
	{
		int num = -1;
		for (int i = 0; i < roomEffectsRegions.Count; i++)
		{
			if (roomEffectsRegions[i].room == room)
			{
				num = i;
				break;
			}
		}
		if (isEnabled && num == -1)
		{
			roomEffectsRegions.Add(new RoomEffectsRegion(room, null));
		}
		else if (!isEnabled && num != -1)
		{
			roomEffectsRegions.RemoveAt(num);
		}
	}

	private static void UpdateRoomEffectsRegions(ResonanceAudioReverbProbe reverbProbe, bool isEnabled)
	{
		int num = -1;
		for (int i = 0; i < roomEffectsRegions.Count; i++)
		{
			if (roomEffectsRegions[i].reverbProbe == reverbProbe)
			{
				num = i;
				break;
			}
		}
		if (isEnabled && num == -1)
		{
			roomEffectsRegions.Add(new RoomEffectsRegion(null, reverbProbe));
		}
		else if (!isEnabled && num != -1)
		{
			roomEffectsRegions.RemoveAt(num);
		}
	}

	private static void UpdateRoomEffects()
	{
		if (roomEffectsRegions.Count == 0)
		{
			ResonanceAudio.DisableRoomEffects();
			return;
		}
		RoomEffectsRegion roomEffectsRegion = roomEffectsRegions[roomEffectsRegions.Count - 1];
		if (roomEffectsRegion.room != null)
		{
			ResonanceAudio.UpdateRoom(roomEffectsRegion.room);
		}
		else
		{
			ResonanceAudio.UpdateReverbProbe(roomEffectsRegion.reverbProbe);
		}
	}

	private static float ComputeRoomEffectsAttenuation(float distanceToRoom)
	{
		float f = 1f + distanceToRoom;
		return 1f / Mathf.Pow(f, 2f);
	}

	private static bool IsListenerInsideRoom(ResonanceAudioRoom room)
	{
		bool result = false;
		Transform listenerTransform = ResonanceAudio.ListenerTransform;
		if (listenerTransform != null)
		{
			Vector3 vector = listenerTransform.position - room.transform.position;
			Quaternion quaternion = Quaternion.Inverse(room.transform.rotation);
			bounds.size = Vector3.Scale(room.transform.lossyScale, room.size);
			result = bounds.Contains(quaternion * vector);
		}
		return result;
	}

	private static bool IsListenerInsideVisibleReverbProbe(ResonanceAudioReverbProbe reverbProbe)
	{
		Transform listenerTransform = ResonanceAudio.ListenerTransform;
		if (listenerTransform == null)
		{
			return false;
		}
		Vector3 vector = listenerTransform.position - reverbProbe.transform.position;
		if (reverbProbe.regionShape == ResonanceAudioReverbProbe.RegionShape.Sphere)
		{
			if (vector.magnitude > reverbProbe.GetScaledSphericalRegionRadius())
			{
				return false;
			}
		}
		else
		{
			Quaternion quaternion = Quaternion.Inverse(reverbProbe.transform.rotation);
			bounds.size = reverbProbe.GetScaledBoxRegionSize();
			if (!bounds.Contains(quaternion * vector))
			{
				return false;
			}
		}
		if (reverbProbe.onlyApplyWhenVisible && ResonanceAudio.ComputeOcclusion(reverbProbe.transform) > 0f)
		{
			return false;
		}
		return true;
	}
}
[AddComponentMenu("ResonanceAudio/ResonanceAudioSource")]
[RequireComponent(typeof(AudioSource))]
[ExecuteInEditMode]
public class ResonanceAudioSource : MonoBehaviour
{
	public enum Quality
	{
		Stereo,
		Low,
		High
	}

	private enum EffectData
	{
		Id,
		DistanceAttenuation,
		RoomEffectsGain,
		Gain,
		DirectivityAlpha,
		DirectivitySharpness,
		ListenerDirectivityAlpha,
		ListenerDirectivitySharpness,
		Occlusion,
		Quality,
		NearFieldEffectGain,
		Volume
	}

	[Tooltip("Sets whether the room effects for the source should be bypassed.")]
	public bool bypassRoomEffects;

	[Range(0f, 1f)]
	[Tooltip("Controls the balance between a dipole pattern and an omnidirectional pattern for source emission. By varying this value, different directivity patterns can be formed.")]
	public float directivityAlpha;

	[Range(1f, 10f)]
	[Tooltip("Sets the sharpness of the source directivity pattern. Higher values will result in increased directivity.")]
	public float directivitySharpness = 1f;

	[Range(0f, 1f)]
	[Tooltip("Controls the balance between a dipole pattern and an omnidirectional pattern for listener sensitivity. By varying this value, different directivity patterns can be formed.")]
	public float listenerDirectivityAlpha;

	[Range(1f, 10f)]
	[Tooltip("Sets the sharpness of the listener directivity pattern. Higher values will result in increased directivity.")]
	public float listenerDirectivitySharpness = 1f;

	[Tooltip("Applies a gain to the source for adjustment of relative loudness.")]
	public float gainDb;

	[Tooltip("Sets whether the near field effect should be applied when the distance between the source and the listener is less than 1m (in Unity units).")]
	public bool nearFieldEffectEnabled;

	[Range(0f, 9f)]
	[Tooltip("Sets the nearfield effect gain. Note that the near field effect could result in up to ~9x gain boost on the source input, therefore, it is advised to set smaller gain values for louder sound sources to avoid clipping of the output signal.")]
	public float nearFieldEffectGain = 1f;

	[Tooltip("Sets whether the sound of the source should be occluded when there are other objects between the source and the listener.")]
	public bool occlusionEnabled;

	[Range(0f, 10f)]
	[Tooltip("Sets the occlusion effect intensity. Higher values will result in a stronger effect when the source is occluded.")]
	public float occlusionIntensity = 1f;

	[Tooltip("Sets the quality mode in which the spatial audio will be rendered. Higher quality modes allow increased fidelity at the cost of greater CPU usage.")]
	public Quality quality = Quality.High;

	private float currentOcclusion;

	private float nextOcclusionUpdate;

	public AudioSource audioSource { get; private set; }

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
	}

	private void Update()
	{
		if (!occlusionEnabled)
		{
			currentOcclusion = 0f;
		}
		else if (Time.time >= nextOcclusionUpdate)
		{
			nextOcclusionUpdate = Time.time + 0.2f;
			currentOcclusion = occlusionIntensity * ResonanceAudio.ComputeOcclusion(base.transform);
		}
		UpdateSource();
	}

	private void UpdateSource()
	{
		if (audioSource.clip != null && audioSource.clip.ambisonic)
		{
			audioSource.SetAmbisonicDecoderFloat(2, bypassRoomEffects ? 0f : ResonanceAudioRoomManager.ComputeRoomEffectsGain(base.transform.position));
			audioSource.SetAmbisonicDecoderFloat(3, ResonanceAudio.ConvertAmplitudeFromDb(gainDb));
		}
		else if (audioSource.spatialize)
		{
			audioSource.SetSpatializerFloat(2, bypassRoomEffects ? 0f : ResonanceAudioRoomManager.ComputeRoomEffectsGain(base.transform.position));
			audioSource.SetSpatializerFloat(3, ResonanceAudio.ConvertAmplitudeFromDb(gainDb));
			audioSource.SetSpatializerFloat(4, directivityAlpha);
			audioSource.SetSpatializerFloat(5, directivitySharpness);
			audioSource.SetSpatializerFloat(6, listenerDirectivityAlpha);
			audioSource.SetSpatializerFloat(7, listenerDirectivitySharpness);
			audioSource.SetSpatializerFloat(8, currentOcclusion);
			audioSource.SetSpatializerFloat(9, (float)quality);
			audioSource.SetSpatializerFloat(10, nearFieldEffectEnabled ? nearFieldEffectGain : 0f);
		}
	}
}
public class CameraFade_SGT : SingletonBase.Singleton<CameraFade_SGT>
{
	private Material fadeMaterial;

	private bool isFadeIn;

	private bool isFadeOut;

	private Coroutine fadeIn_C;

	private Coroutine fadeOut_C;

	protected override void Awake()
	{
		base.Awake();
		fadeMaterial = GetComponent<MeshRenderer>().material;
		isFadeIn = false;
		isFadeOut = false;
	}

	public void StartFadeIn(Action DLG = null)
	{
		if (fadeIn_C != null)
		{
			StopCoroutine(fadeIn_C);
		}
		if (fadeOut_C != null)
		{
			StopCoroutine(fadeOut_C);
		}
		fadeIn_C = StartCoroutine(StartFadeIn_C(0.01f));
		DLG?.Invoke();
	}

	public void StartFadeOut(Action DLG = null)
	{
		if (fadeIn_C != null)
		{
			StopCoroutine(fadeIn_C);
		}
		if (fadeOut_C != null)
		{
			StopCoroutine(fadeOut_C);
		}
		fadeOut_C = StartCoroutine(StartFadeOut_C(0.01f));
		DLG?.Invoke();
	}

	private IEnumerator StartFadeIn_C(float fadeSpeed)
	{
		isFadeIn = true;
		Color color = Color.black;
		color.a = 1f;
		fadeMaterial.SetColor("_BaseColor", color);
		while (isFadeIn)
		{
			color.a -= fadeSpeed;
			fadeMaterial.SetColor("_BaseColor", color);
			yield return new WaitForSecondsRealtime(Time.unscaledDeltaTime);
			if (color.a <= 0f)
			{
				isFadeIn = false;
				color.a = 0f;
				fadeMaterial.SetColor("_BaseColor", color);
				break;
			}
		}
	}

	private IEnumerator StartFadeOut_C(float fadeSpeed)
	{
		isFadeOut = true;
		Color color = Color.black;
		color.a = 0f;
		fadeMaterial.SetColor("_BaseColor", color);
		while (isFadeOut)
		{
			color.a += fadeSpeed;
			fadeMaterial.SetColor("_BaseColor", color);
			yield return new WaitForSecondsRealtime(Time.unscaledDeltaTime);
			if (color.a >= 1f)
			{
				isFadeOut = false;
				color.a = 1f;
				fadeMaterial.SetColor("_BaseColor", color);
				break;
			}
		}
	}
}
public class ChineseLocalization : MonoBehaviour
{
	[Serializable]
	public class AudioCustomize
	{
		public AudioSource source;

		public AudioClip clip_Us;

		public AudioClip clip_Cn;
	}

	[Serializable]
	public class ImageCustomize
	{
		public Image source;

		public Sprite sprite_Us;

		public Sprite sprite_Cn;
	}

	[Serializable]
	public class MaterialCustomize
	{
		public Material source;

		public string[] key;

		public Texture[] sprite_Us;

		public Texture[] sprite_Cn;
	}

	[Serializable]
	public class VideoCustomize
	{
		public VideoPlayer source;

		public VideoClip video_Us;

		public VideoClip video_Cn;
	}

	public List<AudioCustomize> listAudio = new List<AudioCustomize>();

	public List<ImageCustomize> listImage = new List<ImageCustomize>();

	public List<MaterialCustomize> listMaterial = new List<MaterialCustomize>();

	public List<VideoCustomize> listVideo = new List<VideoCustomize>();

	private void Start()
	{
		Custom(PublicGameUIManager.gameSetting.GetLanguageState());
		PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
	}

	public void Custom(LanguageState language)
	{
		if (language == LanguageState.schinese)
		{
			foreach (AudioCustomize item in listAudio)
			{
				item.source.clip = item.clip_Cn;
			}
			foreach (ImageCustomize item2 in listImage)
			{
				item2.source.sprite = item2.sprite_Cn;
			}
			foreach (MaterialCustomize item3 in listMaterial)
			{
				for (int i = 0; i < item3.key.Length; i++)
				{
					item3.source.SetTexture(item3.key[i], item3.sprite_Cn[i]);
				}
			}
			{
				foreach (VideoCustomize item4 in listVideo)
				{
					item4.source.clip = item4.video_Cn;
				}
				return;
			}
		}
		foreach (AudioCustomize item5 in listAudio)
		{
			item5.source.clip = item5.clip_Us;
		}
		foreach (ImageCustomize item6 in listImage)
		{
			item6.source.sprite = item6.sprite_Us;
		}
		foreach (MaterialCustomize item7 in listMaterial)
		{
			for (int j = 0; j < item7.key.Length; j++)
			{
				item7.source.SetTexture(item7.key[j], item7.sprite_Us[j]);
			}
		}
		foreach (VideoCustomize item8 in listVideo)
		{
			item8.source.clip = item8.video_Us;
		}
	}

	private void Update()
	{
	}
}
public class Data : MonoBehaviour
{
}
public class LumpsData<T> : SerializableClass
{
	public T lumps;

	public override void DeSerialize(string data)
	{
		LumpsData<T> lumpsData = JsonUtility.FromJson<LumpsData<T>>(data);
		lumps = lumpsData.lumps;
	}

	public override string Serialize()
	{
		return JsonUtility.ToJson(this);
	}
}
public class LumpsData<T1, T2> : SerializableClass
{
	public T1 lumps1;

	public T2 lumps2;

	public override void DeSerialize(string data)
	{
		LumpsData<T1, T2> lumpsData = JsonUtility.FromJson<LumpsData<T1, T2>>(data);
		lumps1 = lumpsData.lumps1;
		lumps2 = lumpsData.lumps2;
	}

	public override string Serialize()
	{
		return JsonUtility.ToJson(this);
	}
}
public class LumpsData<T1, T2, T3> : SerializableClass
{
	public T1 lumps1;

	public T2 lumps2;

	public T3 lumps3;

	public override void DeSerialize(string data)
	{
		LumpsData<T1, T2, T3> lumpsData = JsonUtility.FromJson<LumpsData<T1, T2, T3>>(data);
		lumps1 = lumpsData.lumps1;
		lumps2 = lumpsData.lumps2;
		lumps3 = lumpsData.lumps3;
	}

	public override string Serialize()
	{
		return JsonUtility.ToJson(this);
	}
}
public class LumpsData<T1, T2, T3, T4> : SerializableClass
{
	public T1 lumps1;

	public T2 lumps2;

	public T3 lumps3;

	public T4 lumps4;

	public override void DeSerialize(string data)
	{
		LumpsData<T1, T2, T3, T4> lumpsData = JsonUtility.FromJson<LumpsData<T1, T2, T3, T4>>(data);
		lumps1 = lumpsData.lumps1;
		lumps2 = lumpsData.lumps2;
		lumps3 = lumpsData.lumps3;
		lumps4 = lumpsData.lumps4;
	}

	public override string Serialize()
	{
		return JsonUtility.ToJson(this);
	}
}
public class PinData : SerializableClass
{
	public int playerNum;

	public bool[] active = new bool[10];

	public Vector3[] pos = new Vector3[10];

	public Vector3[] velocity = new Vector3[10];

	public Vector3[] angularVelocity = new Vector3[10];

	public Quaternion[] rot = new Quaternion[10];

	public override void DeSerialize(string data)
	{
		PinData pinData = JsonUtility.FromJson<PinData>(data);
		playerNum = pinData.playerNum;
		active = pinData.active;
		pos = pinData.pos;
		rot = pinData.rot;
		velocity = pinData.velocity;
		angularVelocity = pinData.angularVelocity;
	}

	public override string Serialize()
	{
		return JsonUtility.ToJson(this);
	}
}
public class BallData : SerializableClass
{
	public Vector3 position;

	public Vector3 velocity;

	public Vector3 angularVelocity;

	public double photonTime;

	public override void DeSerialize(string data)
	{
		BallData ballData = JsonUtility.FromJson<BallData>(data);
		position = ballData.position;
		velocity = ballData.velocity;
		angularVelocity = ballData.angularVelocity;
		photonTime = ballData.photonTime;
	}

	public override string Serialize()
	{
		return JsonUtility.ToJson(this);
	}
}
public class GameData_DDOL : SingletonPunBase.Singleton<GameData_DDOL>
{
	public enum GameType
	{
		None,
		Bowling,
		Archery,
		Basketball,
		Badminton,
		Billiards,
		Darts,
		TableTennis,
		Boxing,
		Golf,
		Baseball,
		Tennis,
		Customize
	}

	public enum PlayType
	{
		None,
		Single,
		Multi
	}

	public enum ControllerType
	{
		Oculus,
		Vive
	}

	public class CustomRotPos
	{
		public Vector3 pos;

		public Quaternion rot;

		public CustomRotPos(Vector3 pos_c, Quaternion rot_c)
		{
			pos = pos_c;
			rot = rot_c;
		}
	}

	public GameType gameType;

	public PlayType playType;

	public ControllerType controllerType;

	public CustomRotPos CustomLeftHand;

	public CustomRotPos CustomRightHand;

	public CustomRotPos CustomGrabAnything;

	public int[] clearLevelDatas;

	public int[] clearLevelDatas_sub;

	private CustomModelData customModelData_mine;

	private CustomModelData customModelData_opponent;

	public CustomModelData[] customModelDatas_single;

	public CustomModelData[] customModelDatas_multi;

	public static WaitingSingleManager singleManager;

	[HideInInspector]
	public int GolfMapIndex = -1;

	private Coroutine coroutine_downloadUserData;

	public int Level { get; set; } = 1;


	public int Mode { get; set; } = 1;


	protected override void Awake()
	{
		base.Awake();
		customModelDatas_multi = new CustomModelData[2];
		char[] array = PlayerPrefs.GetString("clearLevelData_sub", "00000000000").ToCharArray();
		clearLevelDatas_sub = new int[11];
		for (int i = 0; i < clearLevelDatas_sub.Length; i++)
		{
			if (i >= array.Length)
			{
				clearLevelDatas_sub[i] = 0;
			}
			else
			{
				clearLevelDatas_sub[i] = (int)char.GetNumericValue(array[i]);
			}
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		GetDeviceName();
	}

	public void SetRandomLevel()
	{
		Level = (int)UnityEngine.Random.Range(1f, 5.9999f);
	}

	private void CheckClearLevelDatas(int findIndex)
	{
		if (findIndex >= clearLevelDatas.Length)
		{
			int[] array = new int[findIndex + 1];
			for (int i = 0; i < clearLevelDatas.Length; i++)
			{
				array[i] = clearLevelDatas[i];
			}
			clearLevelDatas = array;
		}
		if (findIndex >= clearLevelDatas_sub.Length)
		{
			int[] array2 = new int[findIndex + 1];
			for (int j = 0; j < clearLevelDatas_sub.Length; j++)
			{
				array2[j] = clearLevelDatas_sub[j];
			}
			clearLevelDatas_sub = array2;
		}
	}

	public void SetClearLevelData()
	{
		if (singleManager != null || playType != PlayType.Single)
		{
			return;
		}
		int num = (int)(gameType - 1);
		CheckClearLevelDatas(num);
		if (gameType == GameType.Boxing && Mode == 1)
		{
			if (clearLevelDatas_sub[num] < Level)
			{
				clearLevelDatas_sub[num] = Level;
				PlayerPrefs.SetString("clearLevelData_sub", string.Join("", clearLevelDatas_sub));
			}
		}
		else if (clearLevelDatas[num] < Level)
		{
			clearLevelDatas[num] = Level;
			PlayerPrefs.SetString("clearLevelData", string.Join("", clearLevelDatas));
		}
	}

	public void SetClearLevelData(int level)
	{
		if (singleManager != null || playType != PlayType.Single)
		{
			return;
		}
		int num = (int)(gameType - 1);
		CheckClearLevelDatas(num);
		if (gameType == GameType.Boxing && Mode == 1)
		{
			if (clearLevelDatas_sub[num] < level)
			{
				clearLevelDatas_sub[num] = level;
				PlayerPrefs.SetString("clearLevelData_sub", string.Join("", clearLevelDatas_sub));
			}
		}
		else if (clearLevelDatas[num] < level)
		{
			clearLevelDatas[num] = level;
			PlayerPrefs.SetString("clearLevelData", string.Join("", clearLevelDatas));
		}
	}

	public int GetClearLevelData()
	{
		try
		{
			int num = (int)(gameType - 1);
			if (gameType == GameType.Boxing && Mode == 1)
			{
				return clearLevelDatas_sub[num];
			}
			return clearLevelDatas[num];
		}
		catch
		{
			UnityEngine.Debug.Log("None");
			return -1;
		}
	}

	public CustomModelData GetCustomModelData(int playerNum)
	{
		if (playType != PlayType.Multi)
		{
			if (playerNum == 0)
			{
				return customModelData_mine;
			}
			return customModelDatas_single[Level - 1];
		}
		if (playType == PlayType.Multi)
		{
			return customModelDatas_multi[playerNum];
		}
		return null;
	}

	public RenderTexture GetRenderTexture(int playerNum)
	{
		return null;
	}

	public CustomModelData GetCustomModelData()
	{
		return customModelData_mine;
	}

	public CustomModelData GetOpponentModelData()
	{
		return customModelData_opponent;
	}

	public bool IsCustomModelData()
	{
		return customModelData_mine != null;
	}

	public void SetCustomModelData(CustomModelData _mine)
	{
		customModelData_mine = _mine;
	}

	public void StartDownloadUserData(CustomModelSettingCtrl customModelSetting, string userId, int count = 0)
	{
		if (coroutine_downloadUserData != null)
		{
			StopCoroutine(coroutine_downloadUserData);
		}
		coroutine_downloadUserData = StartCoroutine(Cor_Download_UserData(customModelSetting, userId, count));
	}

	private IEnumerator Cor_Download_UserData(CustomModelSettingCtrl customModelSetting, string userId, int count = 0)
	{
		CustomModelData customModelData = GetCustomModelData();
		if (userId == SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id && customModelData != null)
		{
			customModelSetting.SetModelData(customModelData);
			customModelSetting.SetMedel();
			yield break;
		}
		List<IMultipartFormSection> list = new List<IMultipartFormSection>();
		list.Add(new MultipartFormDataSection("UserID", userId));
		UnityWebRequest www = UnityWebRequest.Post("https://api-global.appnori.com/AIO/GetCustomInfo.php", list);
		www.timeout = 5;
		yield return www.SendWebRequest();
		while (!SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.IsInit())
		{
			yield return null;
		}
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			if (count >= 3)
			{
				UnityEngine.Debug.Log("Error");
				if (userId == SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id)
				{
					customModelData = GetLocalModelData();
					SetCustomModelData(customModelData);
				}
				else
				{
					customModelData = CustomModelSettingCtrl.GetRandomModelData();
				}
				customModelSetting.SetModelData(customModelData);
				customModelSetting.SetMedel();
			}
			else
			{
				yield return new WaitForSeconds(2f);
				StartDownloadUserData(customModelSetting, userId, count + 1);
			}
		}
		else
		{
			UnityEngine.Debug.Log("Form upload complete!");
			customModelData = JsonUtility.FromJson<CustomModelData>(www.downloadHandler.text);
			if (userId == SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id)
			{
				SetCustomModelData(customModelData);
			}
			customModelSetting.SetModelData(customModelData);
			customModelSetting.SetMedel();
		}
	}

	public CustomModelData GetLocalModelData()
	{
		CustomModelData customModelData = new CustomModelData();
		customModelData.Gender = PlayerPrefs.GetString("gender", "m");
		string gender = customModelData.Gender;
		if (!(gender == "m"))
		{
			if (gender == "f")
			{
				customModelData.ID_Face_I = PlayerPrefs.GetString("id_item_face_f", "1000");
				customModelData.ID_Hair_I = PlayerPrefs.GetString("id_item_hair_f", "2000");
				customModelData.ID_Wear_I = PlayerPrefs.GetString("id_item_wear_f", "3000");
				customModelData.ID_Acc_I = PlayerPrefs.GetString("id_item_acc_f", "4000");
				float num = UnityEngine.Random.Range(0.1f, 0.7f);
				float num2 = UnityEngine.Random.Range(num, num + 0.15f);
				float r = Mathf.Clamp01(UnityEngine.Random.Range(num2 + 0.1f, num2 + 0.5f));
				customModelData.Hex_Skin_C = PlayerPrefs.GetString("hex_color_skin_f", ColorUtility.ToHtmlStringRGB(new Color(r, num2, num)));
				Color color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
				customModelData.Hex_Hair_C = PlayerPrefs.GetString("hex_color_hair_f", ColorUtility.ToHtmlStringRGB(color));
				customModelData.Hex_Eyebrow_C = PlayerPrefs.GetString("hex_color_eyebrow_f", ColorUtility.ToHtmlStringRGB(Color.Lerp(color, Color.black, UnityEngine.Random.Range(0f, 1f))));
				customModelData.Hex_Eye_C = PlayerPrefs.GetString("hex_color_eye_f", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
				customModelData.Hex_Upper_C = PlayerPrefs.GetString("hex_color_upper_f", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
				customModelData.Hex_Lower_C = PlayerPrefs.GetString("hex_color_lower_f", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
				customModelData.Hex_Foot_C = PlayerPrefs.GetString("hex_color_foot_f", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
				customModelData.Hex_Pattern_C = PlayerPrefs.GetString("hex_color_pattern_f", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
				customModelData.Hex_Acc_C = PlayerPrefs.GetString("hex_color_acc_f", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
			}
		}
		else
		{
			customModelData.ID_Face_I = PlayerPrefs.GetString("id_item_face_m", "1000");
			customModelData.ID_Hair_I = PlayerPrefs.GetString("id_item_hair_m", "2000");
			customModelData.ID_Wear_I = PlayerPrefs.GetString("id_item_wear_m", "3000");
			customModelData.ID_Acc_I = PlayerPrefs.GetString("id_item_acc_m", "4000");
			float num3 = UnityEngine.Random.Range(0.1f, 0.7f);
			float num4 = UnityEngine.Random.Range(num3, num3 + 0.15f);
			float r2 = Mathf.Clamp01(UnityEngine.Random.Range(num4 + 0.1f, num4 + 0.5f));
			customModelData.Hex_Skin_C = PlayerPrefs.GetString("hex_color_skin_m", ColorUtility.ToHtmlStringRGB(new Color(r2, num4, num3)));
			Color color2 = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
			customModelData.Hex_Hair_C = PlayerPrefs.GetString("hex_color_hair_m", ColorUtility.ToHtmlStringRGB(color2));
			customModelData.Hex_Eyebrow_C = PlayerPrefs.GetString("hex_color_eyebrow_m", ColorUtility.ToHtmlStringRGB(Color.Lerp(color2, Color.black, UnityEngine.Random.Range(0f, 1f))));
			customModelData.Hex_Eye_C = PlayerPrefs.GetString("hex_color_eye_m", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
			customModelData.Hex_Upper_C = PlayerPrefs.GetString("hex_color_upper_m", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
			customModelData.Hex_Lower_C = PlayerPrefs.GetString("hex_color_lower_m", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
			customModelData.Hex_Foot_C = PlayerPrefs.GetString("hex_color_foot_m", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
			customModelData.Hex_Pattern_C = PlayerPrefs.GetString("hex_color_pattern_m", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
			customModelData.Hex_Acc_C = PlayerPrefs.GetString("hex_color_acc_m", ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f))));
		}
		return customModelData;
	}

	public void GetDeviceName()
	{
		controllerType = ControllerType.Oculus;
		CustomLeftHand = new CustomRotPos(new Vector3(-0.04f, -0.015f, -0.1f), Quaternion.Euler(new Vector3(0.4f, -92f, -100f)));
		CustomRightHand = new CustomRotPos(new Vector3(0.04f, -0.015f, -0.1f), Quaternion.Euler(new Vector3(0.4f, 92f, 100f)));
		CustomGrabAnything = new CustomRotPos(new Vector3(0.029f, 0.089f, -0.072f), Quaternion.Euler(new Vector3(-45.08f, -94.797f, 102.361f)));
	}

	public void CustomHand()
	{
		StartCoroutine(CustomHand_C());
	}

	private IEnumerator CustomHand_C()
	{
		while (UnityEngine.Object.FindObjectOfType<XRRig>() == null)
		{
			yield return null;
		}
		GameObject gameObject = UnityEngine.Object.FindObjectOfType<XRRig>().gameObject;
		UnityEngine.XR.Interaction.Toolkit.XRController[] controllers = gameObject.transform.GetComponentsInChildren<UnityEngine.XR.Interaction.Toolkit.XRController>();
		while (controllers.Length != 2)
		{
			controllers = UnityEngine.Object.FindObjectsOfType<UnityEngine.XR.Interaction.Toolkit.XRController>();
			yield return null;
		}
		UnityEngine.XR.Interaction.Toolkit.XRController[] array = controllers;
		foreach (UnityEngine.XR.Interaction.Toolkit.XRController xRController in array)
		{
			if (xRController.controllerNode == XRNode.RightHand)
			{
				FindHand(xRController, isRight: true);
			}
			else if (xRController.controllerNode == XRNode.LeftHand)
			{
				FindHand(xRController, isRight: false);
			}
		}
	}

	private void FindHand(UnityEngine.XR.Interaction.Toolkit.XRController controller, bool isRight)
	{
		List<GameObject> list = new List<GameObject>();
		if (controller.transform.childCount == 0)
		{
			return;
		}
		for (int i = 0; i < controller.transform.childCount; i++)
		{
			list.Add(controller.transform.GetChild(i).gameObject);
		}
		for (int j = 0; j < list.Count; j++)
		{
			if (list[j].gameObject.name.ToLower().Contains("handmodel"))
			{
				if (isRight)
				{
					list[j].gameObject.transform.localPosition = CustomRightHand.pos;
					list[j].gameObject.transform.localRotation = CustomRightHand.rot;
				}
				else
				{
					list[j].gameObject.transform.localPosition = CustomLeftHand.pos;
					list[j].gameObject.transform.localRotation = CustomLeftHand.rot;
				}
			}
		}
	}
}
public class Localization_CTRL : MonoBehaviour
{
	public string ID;

	private Text text;

	private void Awake()
	{
		text = GetComponent<Text>();
	}

	private void Start()
	{
		if (!(ID == ""))
		{
			SingletonBase.Singleton<StaticLocalizationCtrl>.GetInstance.AddData(ID, text);
		}
	}
}
public class Localization_DDOL : SingletonBase.Singleton<Localization_DDOL>
{
	public enum GameLanguageState
	{
		systemLanguage,
		korean,
		chinese,
		taiwan,
		english
	}

	public GameLanguageState gameLanguage;

	protected override void Awake()
	{
		base.Awake();
		if (gameLanguage == GameLanguageState.systemLanguage)
		{
			gameLanguage = (GameLanguageState)GetSystemLanguage();
		}
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	[DllImport("KERNEL32.DLL")]
	private static extern int GetSystemDefaultLCID();

	private CultureInfo GetSystemCulture()
	{
		return new CultureInfo(GetSystemDefaultLCID());
	}

	private int GetSystemLanguage()
	{
		return GetSystemCulture().Name switch
		{
			"ko" => 1, 
			"ko-KR" => 1, 
			"zh-CN" => 2, 
			"zh-TW" => 3, 
			_ => 4, 
		};
	}
}
public class PlatformHand : MonoBehaviour
{
	[SerializeField]
	private bool isGrab;

	private void Start()
	{
		if (!isGrab)
		{
			StartCoroutine(CustomHand_C());
		}
		else
		{
			StartCoroutine(CustomGrabSomething_C());
		}
	}

	private IEnumerator CustomHand_C()
	{
		while (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance == null)
		{
			yield return null;
		}
		string text = base.transform.parent.name;
		text = text.ToLower();
		if (text.Contains("left"))
		{
			base.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomLeftHand.pos;
			base.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomLeftHand.rot;
		}
		else if (text.Contains("right"))
		{
			base.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomRightHand.pos;
			base.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomRightHand.rot;
		}
	}

	private IEnumerator CustomGrabSomething_C()
	{
		while (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance == null)
		{
			yield return null;
		}
		base.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.pos;
		base.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.rot;
	}
}
public class PvDontDestroy : MonoBehaviour
{
	private PhotonView pv;

	private void Start()
	{
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance != null && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
		{
			pv = GetComponent<PhotonView>();
			pv.isRuntimeInstantiated = false;
		}
	}

	private void Update()
	{
	}
}
public class RPCCaller_SGT : SingletonPunBase.Singleton<RPCCaller_SGT>
{
}
[Serializable]
public abstract class SerializableClass
{
	public abstract string Serialize();

	public abstract void DeSerialize(string data);
}
public class RPC_SGT : SingletonPunBase.Singleton<RPC_SGT>
{
	private PhotonView pv;

	private Dictionary<string, object> registeredInstanceDict = new Dictionary<string, object>();

	protected override void Awake()
	{
		base.Awake();
		pv = GetComponent<PhotonView>();
	}

	public void PreRegisterTarget(Action<SerializableClass> invocationTarget)
	{
		string key = invocationTarget.GetMethodInfo().ReflectedType.ToString();
		object target = invocationTarget.Target;
		registeredInstanceDict[key] = target;
	}

	public bool TrySend(Action<SerializableClass> invocationTarget, SerializableClass data, RpcTarget target)
	{
		PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = CreatePacket(invocationTarget, data);
		if (packetInfo == null)
		{
			return false;
		}
		Send(packetInfo.Serialize(), target);
		return true;
	}

	public PacketInfo<Action<SerializableClass>, SerializableClass> CreatePacket(Action<SerializableClass> invocationTarget, SerializableClass data)
	{
		if (!registeredInstanceDict.ContainsKey(invocationTarget.GetMethodInfo().ReflectedType.ToString()))
		{
			UnityEngine.Debug.LogError("invocationTarget is NOT Registered.");
			return null;
		}
		PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = new PacketInfo<Action<SerializableClass>, SerializableClass>();
		packetInfo.Set(invocationTarget, data);
		return packetInfo;
	}

	public void Send(string data, RpcTarget target)
	{
		pv.RPC("Receive", target, data);
	}

	[PunRPC]
	private void Receive(string data)
	{
		PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = PacketInfo<Action<SerializableClass>, SerializableClass>.ToInfo(data);
		packetInfo.Get((string name) => registeredInstanceDict[name])(packetInfo.argsData);
	}
}
[Serializable]
public class PacketInfo<T, Args> where T : Delegate where Args : SerializableClass
{
	public string typeName;

	public string assem;

	public string functionName;

	public string ArgsType;

	public string ArgsAssem;

	public string serializedArgs;

	[NonSerialized]
	public Args argsData;

	public void Set(T caller, Args data)
	{
		functionName = caller.GetMethodInfo().Name;
		assem = caller.GetMethodInfo().ReflectedType.Assembly.ToString();
		typeName = caller.GetMethodInfo().ReflectedType.ToString();
		ArgsAssem = data.GetType().Assembly.ToString();
		ArgsType = data.GetType().FullName;
		argsData = data;
	}

	public string Serialize()
	{
		serializedArgs = argsData.Serialize();
		return JsonUtility.ToJson(this);
	}

	public static PacketInfo<T, Args> ToInfo(string json)
	{
		PacketInfo<T, Args> packetInfo = JsonUtility.FromJson<PacketInfo<T, Args>>(json);
		Type type = Type.GetType(packetInfo.ArgsType + ", " + packetInfo.ArgsAssem);
		packetInfo.argsData = Activator.CreateInstance(type) as Args;
		packetInfo.argsData.DeSerialize(packetInfo.serializedArgs);
		return packetInfo;
	}

	public T Get(Func<string, object> predicate)
	{
		MethodInfo method = Type.GetType(typeName + ", " + assem).GetMethod(functionName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		return (T)Delegate.CreateDelegate(typeof(T), predicate(typeName), method);
	}
}
public class Referee_SGT : SingletonBase.Singleton<Referee_SGT>
{
	private Animator anim;

	private LookAtIK ik;

	public bool isBadminton;

	private void Start()
	{
		anim = GetComponent<Animator>();
		GetComponent<CustomModelSettingCtrl>().InitRandom();
		if (isBadminton)
		{
			ik = GetComponent<LookAtIK>();
		}
	}

	public void Play(int state)
	{
		if (isBadminton)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					if (state == 0)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
					}
				}
				else if (state == 0)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
				}
			}
			else if (state == 0)
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
			}
			else
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
			}
		}
		switch (state)
		{
		case 0:
			anim.SetTrigger("Let_L");
			break;
		case 1:
			anim.SetTrigger("Let_R");
			break;
		case 2:
			anim.SetTrigger("Out_L");
			break;
		case 3:
			anim.SetTrigger("Out_R");
			break;
		}
	}

	public void IKSet(Transform target)
	{
		if (target == null)
		{
			ik.enabled = false;
		}
		else
		{
			ik.enabled = true;
		}
		ik.solver.target = target;
	}
}
public struct RigidPose
{
	public Vector3 pos;

	public Quaternion rot;

	public static RigidPose identity => new RigidPose(Vector3.zero, Quaternion.identity);

	public Vector3 forward => rot * Vector3.forward;

	public Vector3 right => rot * Vector3.right;

	public Vector3 up => rot * Vector3.up;

	public RigidPose(Vector3 pos, Quaternion rot)
	{
		this.pos = pos;
		this.rot = rot;
	}

	public RigidPose(Transform t, bool useLocal = false)
	{
		if (t == null)
		{
			pos = Vector3.zero;
			rot = Quaternion.identity;
		}
		else if (!useLocal)
		{
			pos = t.position;
			rot = t.rotation;
		}
		else
		{
			pos = t.localPosition;
			rot = t.localRotation;
		}
	}

	public override bool Equals(object o)
	{
		if (o is RigidPose rigidPose)
		{
			if (pos == rigidPose.pos)
			{
				return rot == rigidPose.rot;
			}
			return false;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return pos.GetHashCode() ^ rot.GetHashCode();
	}

	public static bool operator ==(RigidPose a, RigidPose b)
	{
		if (a.pos.x == b.pos.x && a.pos.y == b.pos.y && a.pos.z == b.pos.z && a.rot.x == b.rot.x && a.rot.y == b.rot.y && a.rot.z == b.rot.z)
		{
			return a.rot.w == b.rot.w;
		}
		return false;
	}

	public static bool operator !=(RigidPose a, RigidPose b)
	{
		return !(a == b);
	}

	public static RigidPose operator *(RigidPose a, RigidPose b)
	{
		RigidPose result = default(RigidPose);
		result.rot = a.rot * b.rot;
		result.pos = a.pos + a.rot * b.pos;
		return result;
	}

	public void Multiply(RigidPose a, RigidPose b)
	{
		rot = a.rot * b.rot;
		pos = a.pos + a.rot * b.pos;
	}

	public void Inverse()
	{
		rot = Quaternion.Inverse(rot);
		pos = -(rot * pos);
	}

	public RigidPose GetInverse()
	{
		RigidPose result = new RigidPose(pos, rot);
		result.Inverse();
		return result;
	}

	public Vector3 InverseTransformPoint(Vector3 point)
	{
		return Quaternion.Inverse(rot) * (point - pos);
	}

	public Vector3 TransformPoint(Vector3 point)
	{
		return pos + rot * point;
	}

	public static RigidPose Lerp(RigidPose a, RigidPose b, float t)
	{
		return new RigidPose(Vector3.Lerp(a.pos, b.pos, t), Quaternion.Slerp(a.rot, b.rot, t));
	}

	public void Lerp(RigidPose to, float t)
	{
		pos = Vector3.Lerp(pos, to.pos, t);
		rot = Quaternion.Slerp(rot, to.rot, t);
	}

	public static RigidPose LerpUnclamped(RigidPose a, RigidPose b, float t)
	{
		return new RigidPose(Vector3.LerpUnclamped(a.pos, b.pos, t), Quaternion.SlerpUnclamped(a.rot, b.rot, t));
	}

	public void LerpUnclamped(RigidPose to, float t)
	{
		pos = Vector3.LerpUnclamped(pos, to.pos, t);
		rot = Quaternion.SlerpUnclamped(rot, to.rot, t);
	}

	public static void SetPose(Transform target, RigidPose pose, Transform origin = null)
	{
		if (origin != null && origin != target.parent)
		{
			target.position = origin.transform.TransformPoint(pose.pos);
			target.rotation = origin.rotation * pose.rot;
		}
		else
		{
			target.localPosition = pose.pos;
			target.localRotation = pose.rot;
		}
	}

	public static void SetRigidbodyVelocity(Rigidbody rigidbody, Vector3 from, Vector3 to, float duration)
	{
		Vector3 vector = to - from;
		if (Mathf.Approximately(vector.sqrMagnitude, 0f))
		{
			rigidbody.velocity = Vector3.zero;
		}
		else
		{
			rigidbody.velocity = vector / duration;
		}
	}

	public static void SetRigidbodyAngularVelocity(Rigidbody rigidbody, Quaternion from, Quaternion to, float duration, bool overrideMaxAngularVelocity = true)
	{
		(to * Quaternion.Inverse(from)).ToAngleAxis(out var angle, out var axis);
		while (angle > 180f)
		{
			angle -= 360f;
		}
		if (Mathf.Approximately(angle, 0f) || float.IsNaN(axis.x) || float.IsNaN(axis.y) || float.IsNaN(axis.z))
		{
			rigidbody.angularVelocity = Vector3.zero;
			return;
		}
		angle *= (float)Math.PI / 180f / duration;
		if (overrideMaxAngularVelocity && rigidbody.maxAngularVelocity < angle)
		{
			rigidbody.maxAngularVelocity = angle;
		}
		rigidbody.angularVelocity = axis * angle;
	}

	public static RigidPose FromToPose(RigidPose from, RigidPose to)
	{
		Quaternion quaternion = Quaternion.Inverse(from.rot);
		return new RigidPose(quaternion * (to.pos - from.pos), quaternion * to.rot);
	}

	public static implicit operator RigidPose(Pose v)
	{
		return new RigidPose(v.position, v.rotation);
	}

	public static implicit operator Pose(RigidPose v)
	{
		return new Pose(v.pos, v.rot);
	}

	public override string ToString()
	{
		return "{p" + pos.ToString() + ",r" + rot.ToString() + "}";
	}

	public string ToString(string format)
	{
		return "{p" + pos.ToString(format) + ",r" + rot.ToString(format) + "}";
	}
}
public class RootPhysics : SingletonPunBase.Singleton<RootPhysics>
{
	public struct PosTime
	{
		public Vector3 position;

		public float time;
	}

	public struct Pose
	{
		public float time;

		public RigidPose pose;
	}

	private Queue<Pose> m_poseSamples = new Queue<Pose>();

	public static Vector3 GetVelocity(Vector3 Departure, Vector3 Arrival, float time, bool isGravity = true)
	{
		Vector3 result = (Arrival - Departure) / time;
		if (isGravity)
		{
			result.y -= Physics.gravity.y * time * 0.5f;
		}
		return result;
	}

	public static Vector3 GetVelocity(Vector3 Departure, Vector3 Arrival, Vector3 force, float drag, float time)
	{
		Vector3 vector = (Arrival - Departure) / time;
		vector.y -= force.y * time * 0.5f;
		return vector * (1f + drag * time);
	}

	public static Vector3 GetPreviewHitPos(Rigidbody rigid, ConstantForce constatForce = null, string hitColliderTag = "Untagged", bool isUpToDouwn = true)
	{
		List<Vector3> list = new List<Vector3>();
		float num = 0f;
		bool flag = true;
		Vector3 position = rigid.position;
		float num2 = Time.fixedDeltaTime * (float)Physics.defaultSolverVelocityIterations;
		Vector3 vector = Physics.gravity * Mathf.Pow(num2, 2f);
		Vector3 vector2 = default(Vector3);
		if (constatForce != null)
		{
			vector2 = constatForce.force / rigid.mass * Mathf.Pow(num2, 2f);
		}
		float num3 = 1f - num2 * rigid.drag;
		Vector3 vector3 = rigid.velocity * num2;
		while (flag)
		{
			num += Time.fixedDeltaTime;
			if (constatForce != null)
			{
				vector3 += vector2;
			}
			vector3 += vector;
			vector3 *= num3;
			position += vector3;
			list.Add(position);
			if (list.Count < 2)
			{
				continue;
			}
			Vector3 vector4 = list[list.Count - 2];
			Vector3 direction = list[list.Count - 1] - vector4;
			if (Physics.Raycast(vector4, direction, out var hitInfo, direction.magnitude) && hitInfo.collider.CompareTag(hitColliderTag))
			{
				if (!isUpToDouwn)
				{
					return hitInfo.point;
				}
				if (direction.y < 0f)
				{
					return hitInfo.point;
				}
			}
			if (list.Count > 200)
			{
				break;
			}
		}
		return Vector3.zero;
	}

	public static PosTime GetPreviewHitPosTime(Rigidbody rigid, ConstantForce constatForce = null, string hitColliderTag = "Untagged", bool isUpToDouwn = true)
	{
		List<Vector3> list = new List<Vector3>();
		PosTime result = default(PosTime);
		float num = 0f;
		bool flag = true;
		Vector3 position = rigid.position;
		float num2 = Time.fixedDeltaTime * (float)Physics.defaultSolverVelocityIterations;
		Vector3 vector = Physics.gravity * Mathf.Pow(num2, 2f);
		Vector3 vector2 = default(Vector3);
		if (constatForce != null)
		{
			vector2 = constatForce.force / rigid.mass * Mathf.Pow(num2, 2f);
		}
		float num3 = 1f - num2 * rigid.drag;
		Vector3 vector3 = rigid.velocity * num2;
		while (flag)
		{
			num += Time.fixedDeltaTime;
			if (constatForce != null)
			{
				vector3 += vector2;
			}
			vector3 += vector;
			vector3 *= num3;
			position += vector3;
			list.Add(position);
			if (list.Count < 2)
			{
				continue;
			}
			Vector3 vector4 = list[list.Count - 2];
			Vector3 direction = list[list.Count - 1] - vector4;
			if (Physics.Raycast(vector4, direction, out var hitInfo, direction.magnitude) && hitInfo.collider.CompareTag(hitColliderTag))
			{
				if (!isUpToDouwn)
				{
					result.position = hitInfo.point;
					result.time = num;
					return result;
				}
				if (direction.y < 0f)
				{
					result.position = hitInfo.point;
					result.time = num;
					return result;
				}
			}
			if (list.Count > 200)
			{
				break;
			}
		}
		result.position = Vector3.zero;
		result.time = 0f;
		return result;
	}

	public static void SetRigidbodyVelocity(Rigidbody rigidbody, Vector3 from, Vector3 to, float duration)
	{
		Vector3 vector = to - from;
		if (Mathf.Approximately(vector.sqrMagnitude, 0f))
		{
			rigidbody.velocity = Vector3.zero;
		}
		else
		{
			rigidbody.velocity = vector / duration;
		}
	}

	public static void SetRigidbodyAngularVelocity(Rigidbody rigidbody, Quaternion from, Quaternion to, float duration, bool overrideMaxAngularVelocity = true)
	{
		(to * Quaternion.Inverse(from)).ToAngleAxis(out var angle, out var axis);
		while (angle > 180f)
		{
			angle -= 360f;
		}
		if (Mathf.Approximately(angle, 0f) || float.IsNaN(axis.x) || float.IsNaN(axis.y) || float.IsNaN(axis.z))
		{
			rigidbody.angularVelocity = Vector3.zero;
			return;
		}
		angle *= (float)Math.PI / 180f / duration;
		if (overrideMaxAngularVelocity && rigidbody.maxAngularVelocity < angle)
		{
			rigidbody.maxAngularVelocity = angle;
		}
		rigidbody.angularVelocity = axis * angle;
	}

	public static Vector3 SetAngularVelocity(Quaternion from, Quaternion to, float duration, bool overrideMaxAngularVelocity = true)
	{
		(to * Quaternion.Inverse(from)).ToAngleAxis(out var angle, out var axis);
		while (angle > 180f)
		{
			angle -= 360f;
		}
		if (Mathf.Approximately(angle, 0f) || float.IsNaN(axis.x) || float.IsNaN(axis.y) || float.IsNaN(axis.z))
		{
			return Vector3.zero;
		}
		angle *= (float)Math.PI / 180f / duration;
		return axis * angle;
	}

	public void RecordLatestPosesForDrop(Transform currentBall, float currentTime, float recordLength)
	{
		while (m_poseSamples.Count > 0 && currentTime - m_poseSamples.Peek().time > recordLength)
		{
			m_poseSamples.Dequeue();
		}
		m_poseSamples.Enqueue(new Pose
		{
			time = currentTime,
			pose = new RigidPose(currentBall)
		});
	}

	public Pose GetPoseQueue()
	{
		return m_poseSamples.Dequeue();
	}

	public void ClearPoseQueue()
	{
		m_poseSamples.Clear();
	}
}
public class SelfDestroy_CTRL : MonoBehaviour
{
	private void Start()
	{
		StartCoroutine(DelayDestory_C(10f));
	}

	private IEnumerator DelayDestory_C(float time)
	{
		yield return YieldInstructionCache.WaitForSeconds(time);
		UnityEngine.Object.Destroy(base.gameObject);
	}
}
public class SetTagLayer : MonoBehaviour
{
	public string TagName;

	public string LayerName;

	private void Start()
	{
		base.gameObject.tag = TagName;
		base.gameObject.layer = LayerMask.NameToLayer(LayerName);
	}
}
public class TestNetwork_SGT : SingletonPunBase.Singleton<TestNetwork_SGT>, IConnectionCallbacks, IMatchmakingCallbacks, ILobbyCallbacks, IInRoomCallbacks
{
	private const string PHOTON_REALTIME_APP_ID = "c639c9c5-24aa-431f-8e20-290f1bf81bee";

	private PhotonView pv;

	private byte maxPlayers;

	private bool isConnectComplete;

	private bool isGuiEnd;

	public string loadingGameName;

	private void Start()
	{
		pv = GetComponent<PhotonView>();
		maxPlayers = 10;
		isGuiEnd = false;
		isConnectComplete = false;
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.Disconnect();
		}
		Connect();
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			SceneManager.LoadScene(loadingGameName);
		}
	}

	public void DisConnect()
	{
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.Disconnect();
		}
	}

	public void Connect()
	{
		PhotonNetwork.PhotonServerSettings.AppSettings.AppIdRealtime = "c639c9c5-24aa-431f-8e20-290f1bf81bee";
		PhotonNetwork.PhotonServerSettings.AppSettings.UseNameServer = true;
		PhotonNetwork.PhotonServerSettings.AppSettings.FixedRegion = "kr";
		PhotonNetwork.ConnectUsingSettings();
	}

	public override void OnConnectedToMaster()
	{
		PhotonNetwork.JoinRandomRoom();
	}

	public override void OnJoinRandomFailed(short sh, string st)
	{
		Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
		roomOptions.CleanupCacheOnLeave = false;
		roomOptions.BroadcastPropsChangeToAll = true;
		roomOptions.MaxPlayers = maxPlayers;
		roomOptions.CustomRoomProperties = new ExitGames.Client.Photon.Hashtable();
		PhotonNetwork.CreateRoom(null, roomOptions, TypedLobby.Default);
	}

	public override void OnJoinedRoom()
	{
		UnityEngine.Debug.Log("룸에 들어옴");
	}

	public override void OnPlayerEnteredRoom(Player player)
	{
		if (PhotonNetwork.IsMasterClient && PhotonNetwork.CurrentRoom.PlayerCount == 2)
		{
			pv.RPC("LoadScene", RpcTarget.All, null);
		}
	}

	[PunRPC]
	public void LoadScene()
	{
		StopAllCoroutines();
		StartCoroutine(CorLoadScene());
	}

	private IEnumerator CorLoadScene()
	{
		yield return YieldInstructionCache.WaitForSeconds(Time.unscaledDeltaTime * 100f);
		SceneManager.LoadScene(loadingGameName);
	}
}
internal static class YieldInstructionCache
{
	private class FloatComparer : IEqualityComparer<float>
	{
		bool IEqualityComparer<float>.Equals(float x, float y)
		{
			return x == y;
		}

		int IEqualityComparer<float>.GetHashCode(float obj)
		{
			return obj.GetHashCode();
		}
	}

	public static readonly WaitForEndOfFrame WaitForEndOfFrame = new WaitForEndOfFrame();

	public static readonly WaitForFixedUpdate WaitForFixedUpdate = new WaitForFixedUpdate();

	private static readonly Dictionary<float, WaitForSeconds> _timeInterval = new Dictionary<float, WaitForSeconds>(new FloatComparer());

	public static WaitForSeconds WaitForSeconds(float seconds)
	{
		if (!_timeInterval.TryGetValue(seconds, out var value))
		{
			_timeInterval.Add(seconds, value = new WaitForSeconds(seconds));
		}
		return value;
	}
}
public class IKAnimationWeightControl : MonoBehaviour
{
	[SerializeField]
	private VRIK ik;

	[SerializeField]
	private AvatarMask mask;

	[SerializeField]
	private bool useIKPositionWeightInstead;

	public float ikWeight;

	private void OnEnable()
	{
		if (ik != null)
		{
			IKSolver iKSolver = ik.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}
	}

	private void Update()
	{
		if (ik == null)
		{
			OnUpdate();
		}
	}

	private void OnUpdate()
	{
		if (useIKPositionWeightInstead)
		{
			ik.solver.IKPositionWeight = ikWeight;
			return;
		}
		for (int i = 0; i <= 13; i++)
		{
			if (mask.GetHumanoidBodyPartActive((AvatarMaskBodyPart)i))
			{
				switch ((AvatarMaskBodyPart)i)
				{
				case AvatarMaskBodyPart.Root:
					ik.solver.locomotion.weight = ikWeight;
					break;
				case AvatarMaskBodyPart.Body:
					ik.solver.spine.positionWeight = ikWeight;
					ik.solver.spine.rotationWeight = ikWeight;
					break;
				case AvatarMaskBodyPart.LeftLeg:
				case AvatarMaskBodyPart.RightLeg:
				case AvatarMaskBodyPart.LeftFootIK:
				case AvatarMaskBodyPart.RightFootIK:
					ik.solver.locomotion.weight = ikWeight;
					break;
				case AvatarMaskBodyPart.LeftArm:
				case AvatarMaskBodyPart.LeftFingers:
				case AvatarMaskBodyPart.LeftHandIK:
					ik.solver.leftArm.positionWeight = ikWeight;
					ik.solver.leftArm.rotationWeight = ikWeight;
					break;
				case AvatarMaskBodyPart.RightArm:
				case AvatarMaskBodyPart.RightFingers:
				case AvatarMaskBodyPart.RightHandIK:
					ik.solver.rightArm.positionWeight = ikWeight;
					ik.solver.rightArm.rotationWeight = ikWeight;
					break;
				}
			}
		}
	}

	private void OnDisable()
	{
		if (ik != null)
		{
			IKSolver iKSolver = ik.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}
	}
}
public class IKLookAt : MonoBehaviour
{
	[SerializeField]
	private IK ik;

	[SerializeField]
	private Transform Root;

	[SerializeField]
	private string key;

	private Quaternion defaultRotation;

	private static Dictionary<string, Transform> TargetDict = new Dictionary<string, Transform>();

	public static void SetTarget(in string key, in Transform target)
	{
		TargetDict[key] = target;
	}

	private void Awake()
	{
		defaultRotation = Quaternion.Inverse(Root.rotation) * base.transform.rotation;
	}

	private void OnEnable()
	{
		if (ik != null)
		{
			IKSolver iKSolver = ik.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}
	}

	private void Update()
	{
		if (ik == null)
		{
			OnUpdate();
		}
	}

	private void OnUpdate()
	{
		if (TargetDict.TryGetValue(key, out var value))
		{
			base.transform.rotation = Quaternion.LookRotation(value.position - base.transform.position) * defaultRotation;
		}
	}

	private void OnDisable()
	{
		if (ik != null)
		{
			IKSolver iKSolver = ik.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}
	}
}
public class IKLookTarget : MonoBehaviour
{
	[SerializeField]
	private string key;

	private void OnEnable()
	{
		ref string reference = ref key;
		Transform target = base.transform;
		IKLookAt.SetTarget(in reference, in target);
	}
}
public class IKRotationLimit : MonoBehaviour
{
	[SerializeField]
	private bool isLeft;

	[SerializeField]
	private IK ik;

	[SerializeField]
	private RotationLimit limit;

	[SerializeField]
	private bool useRotationWeight;

	private void OnEnable()
	{
		IKSolver iKSolver = ik.GetIKSolver();
		iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
	}

	private void OnPostUpdate()
	{
		if (useRotationWeight)
		{
			bool changed;
			Quaternion limitedLocalRotation = limit.GetLimitedLocalRotation(base.transform.localRotation, out changed);
			IKSolverVR.Arm arm = (isLeft ? (ik as VRIK).solver.leftArm : (ik as VRIK).solver.rightArm);
			if (changed)
			{
				Quaternion quaternion = Quaternion.Inverse(limit.defaultLocalRotation) * limitedLocalRotation;
				Quaternion quaternion2 = Quaternion.Inverse(limit.defaultLocalRotation) * base.transform.localRotation;
				float num = (isLeft ? (-1f) : 1f);
				Vector3 vector = quaternion * limit.axis;
				Vector3 vector2 = quaternion2 * limit.axis;
				float num2 = 14f * arm.shoulderRotationWeight;
				float value = Mathf.Clamp((vector2.z - vector.z) * 57.29578f * num, 0f, num2);
				(float, float) input = (0f, num2);
				(float, float) output = (1f, 0.1f);
				float b = Jisu.Utils.VectorExtension.Remap(value, in input, in output);
				arm.shoulderRotationWeight = Mathf.Lerp(arm.shoulderRotationWeight, b, 0.5f);
			}
			else
			{
				int num3 = 1;
				arm.shoulderRotationWeight = Mathf.Lerp(arm.shoulderRotationWeight, num3, 0.5f);
			}
		}
		else
		{
			limit.Apply();
		}
	}

	private void OnDisable()
	{
		IKSolver iKSolver = ik.GetIKSolver();
		iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
	}
}
[ExecuteInEditMode]
public class CopyAllComponents : MonoBehaviour
{
	[SerializeField]
	private bool dataCopy;

	[SerializeField]
	private Transform OriginRoot;

	[SerializeField]
	private Transform TargetRoot;

	private void OnEnable()
	{
		if (OriginRoot == null || TargetRoot == null)
		{
			base.enabled = false;
			return;
		}
		Process(OriginRoot, TargetRoot);
		base.enabled = false;
	}

	private void Process(Transform origin, Transform target)
	{
		if (origin.childCount != 0)
		{
			for (int i = 0; i < origin.childCount; i++)
			{
				string n = origin.GetChild(i).name;
				Transform transform = target.Find(n);
				if (transform != null)
				{
					Process(origin.GetChild(i), transform);
				}
			}
		}
		foreach (Component item in from component in origin.GetComponents<Component>()
			where !(component is Transform) && !(component is MeshRenderer) && !(component is SkinnedMeshRenderer) && !(component is MeshFilter)
			select component)
		{
			if (dataCopy)
			{
				PasteComponent(item, target.gameObject);
			}
			else
			{
				CopyComponent(item, target.gameObject);
			}
		}
	}

	public static T PasteComponent<T>(T original, GameObject destination) where T : Component
	{
		Type type = original.GetType();
		return DeepCopy(destination.GetComponent(type), original);
	}

	public static T CopyComponent<T>(T original, GameObject destination) where T : Component
	{
		Type type = original.GetType();
		Component component = destination.AddComponent(type);
		FieldInfo[] fields = type.GetFields();
		foreach (FieldInfo fieldInfo in fields)
		{
			fieldInfo.SetValue(component, fieldInfo.GetValue(original));
		}
		return component as T;
	}

	public static T DeepCopy<T>(Component comp, T other) where T : Component
	{
		Type type = comp.GetType();
		if (type != other.GetType())
		{
			return null;
		}
		BindingFlags bindingAttr = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
		PropertyInfo[] properties = type.GetProperties(bindingAttr);
		foreach (PropertyInfo propertyInfo in properties)
		{
			if (propertyInfo.CanWrite)
			{
				try
				{
					propertyInfo.SetValue(comp, propertyInfo.GetValue(other, null), null);
				}
				catch
				{
				}
			}
		}
		FieldInfo[] fields = type.GetFields(bindingAttr);
		foreach (FieldInfo fieldInfo in fields)
		{
			fieldInfo.SetValue(comp, fieldInfo.GetValue(other));
		}
		return comp as T;
	}
}
[Obsolete]
public class RaycastTest : MonoBehaviour
{
	[SerializeField]
	private Transform model;

	[SerializeField]
	private SphereCollider detector;

	[SerializeField]
	private VRIK ik;

	public CapsuleCollider TunnelingTester;

	[Header("State")]
	public bool isTunnelTested;

	private GameObject hitMarker;

	private void Awake()
	{
		hitMarker = GameObject.CreatePrimitive(PrimitiveType.Sphere);
		UnityEngine.Object.DestroyImmediate(hitMarker.GetComponent<SphereCollider>());
	}

	private void OnEnable()
	{
	}

	private void FixedUpdate()
	{
		CheckCollision();
	}

	private void CheckCollision()
	{
		float magnitude = (model.transform.position - detector.transform.position).magnitude;
		TunnelingTester.transform.position = Vector3.Lerp(model.transform.position, detector.transform.position, 0.5f);
		TunnelingTester.transform.LookAt(detector.transform);
		TunnelingTester.transform.localScale = detector.transform.localScale;
		TunnelingTester.height = magnitude / TunnelingTester.transform.localScale.x + detector.radius * 2f;
	}

	private void OnDisable()
	{
		IKSolverVR solver = ik.solver;
		solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(CheckCollision));
	}
}
public class TestCubicSpline : MonoBehaviour
{
	public enum Type
	{
		None,
		Bezier,
		Hermite
	}

	[SerializeField]
	private Type type;

	[SerializeField]
	private LineRenderer line;

	[SerializeField]
	private int SampleCount;

	[SerializeField]
	private Transform start;

	[SerializeField]
	private Transform startAfterVector;

	[SerializeField]
	private Transform end;

	[SerializeField]
	private Transform endBeforeVector;

	public static Vector3 Bezier4(in Vector3 p0, in Vector3 p1, in Vector3 p2, in Vector3 p3, in float t)
	{
		Vector3 p4 = Vector3.Lerp(p0, p1, t);
		Vector3 p5 = Vector3.Lerp(p1, p2, t);
		Vector3 p6 = Vector3.Lerp(p2, p3, t);
		return Bezier3(in p4, in p5, in p6, in t);
	}

	public static Vector3 Bezier3(in Vector3 p0, in Vector3 p1, in Vector3 p2, in float t)
	{
		return Vector3.Lerp(Vector3.Lerp(p0, p1, t), Vector3.Lerp(p1, p2, t), t);
	}

	private void Update()
	{
		switch (type)
		{
		case Type.Bezier:
			SimulateBezierLine();
			break;
		case Type.Hermite:
			SimulateHermiteLine();
			break;
		}
	}

	private void SimulateBezierLine()
	{
		line.positionCount = SampleCount;
		for (int i = 0; i < SampleCount; i++)
		{
			LineRenderer lineRenderer = line;
			int index = i;
			Vector3 p = start.position;
			Vector3 p2 = startAfterVector.position;
			Vector3 p3 = endBeforeVector.position;
			Vector3 p4 = end.position;
			float t = (float)i / (float)SampleCount;
			lineRenderer.SetPosition(index, Bezier4(in p, in p2, in p3, in p4, in t));
		}
	}

	private void SimulateHermiteLine()
	{
		line.positionCount = SampleCount;
		for (int i = 0; i < SampleCount; i++)
		{
			Vector3 position = CatmulRom.CatmullRomLerp(start.position, startAfterVector.position, endBeforeVector.position, end.position, (float)i / (float)SampleCount * 2f);
			line.SetPosition(i, position);
		}
	}

	public void RenderLine(List<Vector3> list)
	{
		line.positionCount = list.Count;
		for (int i = 0; i < list.Count; i++)
		{
			line.SetPosition(i, list[i]);
		}
	}
}
public class TestPatrolObject : MonoBehaviour
{
	[SerializeField]
	private Transform Target;

	[SerializeField]
	private Transform Start;

	[SerializeField]
	private Transform End;

	[SerializeField]
	private float RepeatTime;

	[SerializeField]
	private AnimationCurve curve;

	private void Update()
	{
		Target.transform.LookAt(End);
		Target.transform.position = Vector3.Lerp(Start.position, End.position, curve.Evaluate(Mathf.PingPong(Time.time / RepeatTime, 1f)));
	}
}
public class TestRotation : MonoBehaviour
{
	[SerializeField]
	private Transform Source;

	[SerializeField]
	private bool useEulerMulRot;

	[SerializeField]
	private Vector3 Euler;

	[SerializeField]
	private Transform Destination;

	private void Update()
	{
		if (useEulerMulRot)
		{
			Destination.rotation = Quaternion.Euler(Euler) * Source.rotation;
		}
		else
		{
			Destination.rotation = Source.rotation * Quaternion.Euler(Euler);
		}
	}
}
public class TestSetLine : MonoBehaviour
{
	[SerializeField]
	private int sampleCount = 20;

	[SerializeField]
	private int idx;

	[Header("Circle")]
	[SerializeField]
	private LineRenderer line;

	[SerializeField]
	private float distance;

	[Header("Lines")]
	[SerializeField]
	private int Line1SampeCount = 20;

	[SerializeField]
	private List<LineRenderer> lines;

	[SerializeField]
	private float lineDistance;

	private void OnEnable()
	{
		SetLine();
		base.enabled = false;
	}

	private void SetLine()
	{
	}

	private void SetCircle()
	{
		line.positionCount = sampleCount + 1;
		for (int i = 0; i <= sampleCount; i++)
		{
			float f = (float)i * (float)(360 / sampleCount) * ((float)Math.PI / 180f);
			Vector2 xzVector = new Vector2(Mathf.Cos(f), Mathf.Sin(f)) * distance;
			line.SetPosition(i, Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector));
		}
	}

	private void SetLineFromCenter(Transform Center)
	{
		for (int i = 0; i < lines.Count; i++)
		{
			float f = (float)i * (float)(360 / lines.Count) * ((float)Math.PI / 180f);
			Vector2 xzVector = new Vector2(Mathf.Cos(f), Mathf.Sin(f)) * distance;
			lines[i].transform.localPosition = Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector);
		}
		foreach (LineRenderer line in lines)
		{
			line.positionCount = Line1SampeCount + 1;
			Vector3 vector = (line.transform.position - Center.transform.position).normalized;
			Vector2 xzVector2 = Jisu.Utils.VectorExtension.ToXZ(in vector);
			Vector3 vector2 = Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector2);
			for (int j = 0; j <= Line1SampeCount; j++)
			{
				line.SetPosition(j, vector2 * ((float)j * (lineDistance / (float)Line1SampeCount) + 0.05f));
			}
		}
	}
}
public class PointEffectCtrl : MonoBehaviour
{
	private Animator anim;

	public Sprite[] sprite_combo;

	public Sprite[] sprite_point;

	public Image image_point;

	public Image[] image_combo;

	private void Start()
	{
		anim = GetComponent<Animator>();
	}

	public void SetViewPoint(Vector3 pos, int point, int combo)
	{
		base.transform.position = pos;
		int num = ((point < 2000) ? ((point >= 1500) ? 1 : ((point >= 1000) ? 2 : 3)) : 0);
		switch (num)
		{
		case 0:
			image_point.transform.localPosition = Vector3.right * -0.7f;
			break;
		case 1:
			image_point.transform.localPosition = Vector3.right * -0.45f;
			break;
		case 2:
			image_point.transform.localPosition = Vector3.right * -0.45f;
			break;
		default:
			image_point.transform.localPosition = Vector3.zero;
			break;
		}
		image_point.sprite = sprite_point[num];
		if (combo < 2)
		{
			for (int i = 0; i < 4; i++)
			{
				image_combo[i].enabled = false;
			}
		}
		else
		{
			for (int j = 0; j < 4; j++)
			{
				image_combo[j].enabled = true;
			}
			int[] array = new int[3]
			{
				(int)((float)(combo % 1000) * 0.01f),
				(int)((float)(combo % 100) * 0.1f),
				combo % 10
			};
			int num2 = 0;
			if (combo >= 100)
			{
				image_combo[num2].sprite = sprite_combo[array[0]];
				num2++;
			}
			if (combo >= 10)
			{
				image_combo[num2].sprite = sprite_combo[array[1]];
				num2++;
			}
			if (combo >= 0)
			{
				image_combo[num2].sprite = sprite_combo[array[2]];
				num2++;
			}
			for (int k = num2; k < 3; k++)
			{
				image_combo[k].sprite = sprite_combo[10];
			}
		}
		anim.SetTrigger("OnUp");
	}

	private void LateUpdate()
	{
		base.transform.rotation = Quaternion.LookRotation(base.transform.position - Camera.main.transform.position + Vector3.up * 0.1f);
	}
}
public static class RagdollBones
{
	public static readonly int Hips = 0;

	public static readonly int LeftUpperLeg = 1;

	public static readonly int RightUpperLeg = 2;

	public static readonly int LeftLowerLeg = 3;

	public static readonly int RightLowerLeg = 4;

	public static readonly int LeftFoot = 5;

	public static readonly int RightFoot = 6;

	public static readonly int UpperChest = 7;

	public static readonly int Head = 8;

	public static readonly int LeftUpperArm = 9;

	public static readonly int RightUpperArm = 10;

	public static readonly int LeftLowerArm = 11;

	public static readonly int RightLowerArm = 12;

	public static readonly int LeftHand = 13;

	public static readonly int RightHand = 14;

	public static HumanBodyBones GetHumanBodyBone(int boneNum)
	{
		return boneNum switch
		{
			1 => HumanBodyBones.LeftUpperLeg, 
			2 => HumanBodyBones.RightUpperLeg, 
			3 => HumanBodyBones.LeftLowerLeg, 
			4 => HumanBodyBones.RightLowerLeg, 
			5 => HumanBodyBones.LeftFoot, 
			6 => HumanBodyBones.RightFoot, 
			7 => HumanBodyBones.UpperChest, 
			8 => HumanBodyBones.Head, 
			9 => HumanBodyBones.LeftUpperArm, 
			10 => HumanBodyBones.RightUpperArm, 
			11 => HumanBodyBones.LeftLowerArm, 
			12 => HumanBodyBones.RightLowerArm, 
			13 => HumanBodyBones.LeftHand, 
			14 => HumanBodyBones.RightHand, 
			_ => HumanBodyBones.Hips, 
		};
	}
}
public class Xorshift
{
	protected const uint SEED_X = 123456789u;

	protected const uint SEED_Y = 362436069u;

	protected const uint SEED_Z = 521288629u;

	protected const uint SEED_W = 88675123u;

	protected const float denominator = 2.3283064E-10f;

	private static uint x;

	private static uint y;

	private static uint z;

	private static uint w;

	public static uint NativeNext
	{
		get
		{
			uint num = x ^ (x << 11);
			x = y;
			y = z;
			z = w;
			w = w ^ (w >> 19) ^ (num ^ (num >> 8));
			return w;
		}
	}

	public static float Next => (float)NativeNext * 2.3283064E-10f;

	static Xorshift()
	{
		x = 123456789u;
		y = 362436069u;
		z = 521288629u;
		w = (uint)Guid.NewGuid().GetHashCode();
	}
}
public class RandAnimation_JIP : MonoBehaviour
{
	public struct HeadAniJob : IJobParallelForTransform, IDisposable
	{
		[ReadOnly]
		public NativeArray<float> AniSpeed;

		[ReadOnly]
		public NativeArray<Type> AniType;

		[ReadOnly]
		public NativeArray<float> AniDt;

		public float deltaTime;

		public const float SpeedMin = 1f;

		public const float SpeedMax = 1.2f;

		private const float rotDt = 0.5f;

		private const float rotHeadSpeed = 20f;

		private float GetRandom()
		{
			return Xorshift.Next;
		}

		private float GetRandom(in float min, in float max)
		{
			float next = Xorshift.Next;
			(float, float) input = (0f, 1f);
			(float, float) output = (min, max);
			return Billiards.VectorExtension.Remap(next, in input, in output);
		}

		public void Execute(int num, TransformAccess transform)
		{
			float num2 = deltaTime * AniSpeed[num];
			if (AniType[num] == Type.LeftRot)
			{
				transform.localRotation = Quaternion.Euler(transform.localRotation.eulerAngles + Vector3.down * num2 * 20f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					AniType[num] = Type.LeftRotReturn;
				}
			}
			else if (AniType[num] == Type.LeftRotReturn)
			{
				transform.localRotation = Quaternion.Euler(transform.localRotation.eulerAngles + Vector3.up * num2 * 20f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					if (GetRandom() < 0.7f)
					{
						AniType[num] = Type.RightRot;
					}
					else
					{
						AniType[num] = Type.Up;
					}
				}
			}
			else if (AniType[num] == Type.RightRot)
			{
				transform.localRotation = Quaternion.Euler(transform.localRotation.eulerAngles + Vector3.up * num2 * 20f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					AniType[num] = Type.RightRotReturn;
				}
			}
			else
			{
				if (AniType[num] != Type.RightRotReturn)
				{
					return;
				}
				transform.localRotation = Quaternion.Euler(transform.localRotation.eulerAngles + Vector3.down * num2 * 20f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					if (GetRandom() < 0.7f)
					{
						AniType[num] = Type.LeftRot;
					}
					else
					{
						AniType[num] = Type.Up;
					}
				}
			}
		}

		public void Dispose()
		{
			AniSpeed.Dispose();
			AniType.Dispose();
			AniDt.Dispose();
		}
	}

	public struct AniJob : IJobParallelForTransform, IDisposable
	{
		public NativeArray<float> AniSpeed;

		public NativeArray<Type> AniType;

		public NativeArray<float> AniDt;

		public NativeArray<Vector3> ArrPos;

		public NativeArray<Vector3> ArrTargetPos;

		public float deltaTime;

		public const float SpeedMin = 1f;

		public const float SpeedMax = 1.2f;

		private const float rotDt = 0.5f;

		private const float rotSpeed = 4f;

		private float GetRandom()
		{
			return Xorshift.Next;
		}

		private float GetRandom(in float min, in float max)
		{
			float next = Xorshift.Next;
			(float, float) input = (0f, 1f);
			(float, float) output = (min, max);
			return Billiards.VectorExtension.Remap(next, in input, in output);
		}

		public void Execute(int num, TransformAccess transform)
		{
			float num2 = deltaTime * AniSpeed[num];
			AniDt[num] += num2;
			if (AniType[num] == Type.Up)
			{
				transform.position = Vector3.Lerp(transform.position, ArrTargetPos[num], deltaTime * 2f * AniSpeed[num]);
				if (0.7f < AniDt[num])
				{
					AniDt[num] = 0f;
					AniType[num] = Type.Down;
				}
			}
			else if (AniType[num] == Type.Down)
			{
				transform.position = Vector3.Lerp(transform.position, ArrPos[num], deltaTime * 2f * AniSpeed[num]);
				if (0.7f < AniDt[num])
				{
					AniDt[num] = 0f;
					if (GetRandom() < 0.7f)
					{
						AniType[num] = Type.Up;
					}
					else
					{
						AniType[num] = Type.LeftRot;
					}
					ref NativeArray<float> aniSpeed = ref AniSpeed;
					float min = 1f;
					float max = 1.2f;
					aniSpeed[num] = GetRandom(in min, in max);
				}
			}
			else if (AniType[num] == Type.LeftRot)
			{
				transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles + Vector3.forward * num2 * 4f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					AniType[num] = Type.LeftRotReturn;
				}
			}
			else if (AniType[num] == Type.LeftRotReturn)
			{
				transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles + Vector3.back * num2 * 4f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					float min = 0f;
					float max = 1f;
					if (GetRandom(in min, in max) < 0.7f)
					{
						AniType[num] = Type.RightRot;
					}
					else
					{
						AniType[num] = Type.Up;
					}
				}
			}
			else if (AniType[num] == Type.RightRot)
			{
				transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles + Vector3.back * num2 * 4f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					AniType[num] = Type.RightRotReturn;
				}
			}
			else
			{
				if (AniType[num] != Type.RightRotReturn)
				{
					return;
				}
				transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles + Vector3.forward * num2 * 4f);
				if (0.5f < AniDt[num])
				{
					AniDt[num] = 0f;
					float min = 0f;
					float max = 1f;
					if (GetRandom(in min, in max) < 0.7f)
					{
						AniType[num] = Type.LeftRot;
					}
					else
					{
						AniType[num] = Type.Up;
					}
				}
			}
		}

		public void Dispose()
		{
			AniSpeed.Dispose();
			AniType.Dispose();
			AniDt.Dispose();
			ArrPos.Dispose();
			ArrTargetPos.Dispose();
		}
	}

	public enum Type
	{
		Up,
		Down,
		LeftRot,
		RightRot,
		LeftRotReturn,
		RightRotReturn
	}

	public float SpeedMin = 1f;

	public float SpeedMax = 1.2f;

	[SerializeField]
	private int AndroidOverrideSkipIteration = 1;

	[SerializeField]
	private float height = 0.2f;

	private float rotDt = 0.5f;

	private float rotSpeed = 4f;

	private float rotHeadSpeed = 20f;

	private Transform[] ArrChild;

	private Transform[] ArrChildHead;

	private float[] AniSpeed;

	private Type[] AniType;

	private float[] AniDt;

	private Vector3[] ArrPos;

	private Vector3[] ArrTargetPos;

	[NativeDisableUnsafePtrRestriction]
	private TransformAccessArray ecs_ArrChild;

	[NativeDisableUnsafePtrRestriction]
	public TransformAccessArray ecs_ArrChildHead;

	public NativeArray<float> native_AniSpeed;

	public NativeArray<Type> native_AniType;

	public NativeArray<float> native_AniDt;

	public NativeArray<float> readOnly_native_AniSpeed;

	public NativeArray<Type> readOnly_native_AniType;

	public NativeArray<float> readOnly_native_AniDt;

	public NativeArray<Vector3> native_ArrPos;

	public NativeArray<Vector3> native_ArrTargetPos;

	private int UpdateTargetIdx;

	private const int UpdateInterval = 3;

	private float lastTime;

	private JobHandle aniHandler;

	private AniJob instanceJob;

	private bool dependentCompleted;

	private bool job_initialized;

	private int SkipIteration => AndroidOverrideSkipIteration;

	private void Awake()
	{
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < base.transform.childCount; i++)
		{
			list.Add(base.transform.GetChild(i));
		}
		list.Sort((Transform a, Transform b) => a.position.z.CompareTo(b.position.z));
		foreach (Transform item in list)
		{
			item.SetAsLastSibling();
		}
	}

	private void Start()
	{
		int num = base.transform.childCount / SkipIteration;
		ArrChild = new Transform[num];
		ArrChildHead = new Transform[num];
		AniSpeed = new float[num];
		AniType = new Type[num];
		AniDt = new float[num];
		ArrPos = new Vector3[num];
		ArrTargetPos = new Vector3[num];
		if (SkipIteration > 1)
		{
			for (int i = 0; i < num; i++)
			{
				for (int j = 1; j < SkipIteration; j++)
				{
					base.transform.GetChild(i * SkipIteration + j).gameObject.SetActive(value: false);
				}
			}
		}
		for (int k = 0; k < num; k++)
		{
			Transform child = base.transform.GetChild(k * SkipIteration);
			ArrChild[k] = child;
			ArrChildHead[k] = child.GetChild(0).GetChild(0);
			AniSpeed[k] = UnityEngine.Random.Range(SpeedMin, SpeedMax);
			AniType[k] = Type.Up;
			ArrPos[k] = ArrChild[k].position;
			ArrTargetPos[k] = ArrChild[k].position;
			ArrTargetPos[k].y += height;
		}
		ecs_ArrChild = new TransformAccessArray(ArrChild);
		ecs_ArrChildHead = new TransformAccessArray(ArrChildHead);
	}

	private void AssignData()
	{
		native_AniSpeed = new NativeArray<float>(AniSpeed, Allocator.TempJob);
		native_AniType = new NativeArray<Type>(AniType, Allocator.TempJob);
		native_AniDt = new NativeArray<float>(AniDt, Allocator.TempJob);
		native_ArrPos = new NativeArray<Vector3>(ArrPos, Allocator.TempJob);
		native_ArrTargetPos = new NativeArray<Vector3>(ArrTargetPos, Allocator.TempJob);
		readOnly_native_AniSpeed = new NativeArray<float>(AniSpeed, Allocator.TempJob);
		readOnly_native_AniType = new NativeArray<Type>(AniType, Allocator.TempJob);
		readOnly_native_AniDt = new NativeArray<float>(AniDt, Allocator.TempJob);
	}

	private AniJob GenerateAniJob()
	{
		AniJob result = default(AniJob);
		result.AniSpeed = native_AniSpeed;
		result.AniType = native_AniType;
		result.AniDt = native_AniDt;
		result.ArrPos = native_ArrPos;
		result.ArrTargetPos = native_ArrTargetPos;
		return result;
	}

	private HeadAniJob GenerateHeadAniJob()
	{
		HeadAniJob result = default(HeadAniJob);
		result.AniSpeed = readOnly_native_AniSpeed;
		result.AniType = readOnly_native_AniType;
		result.AniDt = readOnly_native_AniDt;
		return result;
	}

	private void CopyData()
	{
		AniSpeed = native_AniSpeed.ToArray();
		AniType = native_AniType.ToArray();
		AniDt = native_AniDt.ToArray();
		ArrPos = native_ArrPos.ToArray();
		ArrTargetPos = native_ArrTargetPos.ToArray();
		native_AniSpeed.Dispose();
		native_AniType.Dispose();
		native_AniDt.Dispose();
		native_ArrPos.Dispose();
		native_ArrTargetPos.Dispose();
		readOnly_native_AniSpeed.Dispose();
		readOnly_native_AniType.Dispose();
		readOnly_native_AniDt.Dispose();
	}

	private void RunJob()
	{
		AniJob jobData = GenerateAniJob();
		HeadAniJob jobData2 = GenerateHeadAniJob();
		jobData.deltaTime = Time.time - lastTime;
		jobData2.deltaTime = Time.time - lastTime;
		lastTime = Time.time;
		aniHandler = JobHandle.CombineDependencies(jobData.Schedule(ecs_ArrChild), jobData2.Schedule(ecs_ArrChildHead));
		dependentCompleted = false;
	}

	private void Update()
	{
		if (!job_initialized)
		{
			AssignData();
			RunJob();
			job_initialized = true;
		}
	}

	private void OnEnable()
	{
		StartCoroutine(DelayComplete());
	}

	private IEnumerator DelayComplete()
	{
		while (base.enabled)
		{
			yield return YieldInstructionCache.WaitForEndOfFrame;
			if (job_initialized)
			{
				aniHandler.Complete();
				CopyData();
				job_initialized = false;
			}
		}
	}

	private void OnDestroy()
	{
		try
		{
			ecs_ArrChild.Dispose();
			ecs_ArrChildHead.Dispose();
			native_AniSpeed.Dispose();
			native_AniType.Dispose();
			native_AniDt.Dispose();
			native_ArrPos.Dispose();
			native_ArrTargetPos.Dispose();
			readOnly_native_AniSpeed.Dispose();
			readOnly_native_AniType.Dispose();
			readOnly_native_AniDt.Dispose();
		}
		catch (InvalidOperationException)
		{
		}
		catch (Exception message)
		{
			UnityEngine.Debug.LogError(message);
		}
	}
}
public class AutoGeneratePlanarShadow : MonoBehaviour
{
	private class Pair
	{
		public Renderer renderer;

		public GameObject Target;

		public Renderer planarRenderer;

		public GameObject planarInstance;

		public bool Initialize(in Renderer target, in Material material, in Transform root)
		{
			Target = target.gameObject;
			renderer = target;
			if (!RendererInstantiate(in target, out planarInstance))
			{
				return false;
			}
			planarInstance.transform.SetParent(Target.transform, worldPositionStays: false);
			planarRenderer = planarInstance.GetComponent<Renderer>();
			planarRenderer.material = material;
			return true;
		}

		public void Clear()
		{
			if (planarInstance != null)
			{
				UnityEngine.Object.Destroy(planarInstance);
			}
		}
	}

	[SerializeField]
	private Material PlanarShadowMaterial;

	private Material OverrideShadowMaterial;

	[SerializeField]
	private float Height = 0.005f;

	private const float defaultPlanarHeight = 0.005f;

	[SerializeField]
	private bool useAreaControlHeight;

	[SerializeField]
	private Bounds AreaBound;

	[SerializeField]
	private float InnerHeight;

	[SerializeField]
	private float OutterHeight;

	[SerializeField]
	private Light MainLight;

	private readonly List<Pair> pairs = new List<Pair>();

	private void Awake()
	{
		if (useAreaControlHeight)
		{
			OverrideShadowMaterial = UnityEngine.Object.Instantiate(PlanarShadowMaterial);
			Initialize(in OverrideShadowMaterial);
		}
		else if (Height != 0.005f)
		{
			OverrideShadowMaterial = UnityEngine.Object.Instantiate(PlanarShadowMaterial);
			OverrideShadowMaterial.SetFloat("_PlaneHeight", Height);
			Initialize(in OverrideShadowMaterial);
		}
		else
		{
			Initialize(in PlanarShadowMaterial);
		}
	}

	private void Update()
	{
		if (useAreaControlHeight && pairs != null && pairs.Count > 0 && pairs.Count <= 2)
		{
			Vector3 position = pairs.First().planarInstance.transform.position;
			Vector3 forward = MainLight.transform.forward;
			float num = position.y - InnerHeight;
			float num2 = 0f - forward.y;
			float num3 = num / num2;
			Vector3 point = position + forward * num3;
			float value = (AreaBound.Contains(point) ? InnerHeight : OutterHeight);
			OverrideShadowMaterial.SetFloat("_PlaneHeight", value);
		}
	}

	private static bool RendererInstantiate(in Renderer originRenderer, out GameObject instance)
	{
		if (!originRenderer.enabled || !originRenderer.gameObject.activeInHierarchy)
		{
			instance = null;
			return false;
		}
		instance = new GameObject();
		instance.name = originRenderer.transform.name + " (planarShadow)";
		Component component = instance.AddComponent(originRenderer.GetType());
		if ((object)component != null)
		{
			if (!(component is MeshRenderer meshRenderer))
			{
				if (!(component is SkinnedMeshRenderer skinnedMeshRenderer))
				{
					goto IL_0191;
				}
				SkinnedMeshRenderer skinnedMeshRenderer2 = skinnedMeshRenderer;
				SkinnedMeshRenderer skinnedMeshRenderer3 = originRenderer as SkinnedMeshRenderer;
				if (skinnedMeshRenderer3.sharedMesh == null || skinnedMeshRenderer3.rootBone == null)
				{
					UnityEngine.Object.Destroy(instance);
					instance = null;
					return false;
				}
				skinnedMeshRenderer2.bones = skinnedMeshRenderer3.bones;
				skinnedMeshRenderer2.sharedMesh = skinnedMeshRenderer3.sharedMesh;
				skinnedMeshRenderer2.rootBone = skinnedMeshRenderer3.rootBone;
				skinnedMeshRenderer2.localBounds = new Bounds(Vector3.zero, Vector3.one * 10f);
				skinnedMeshRenderer2.shadowCastingMode = ShadowCastingMode.Off;
				skinnedMeshRenderer2.lightProbeUsage = LightProbeUsage.Off;
				skinnedMeshRenderer2.reflectionProbeUsage = ReflectionProbeUsage.Off;
			}
			else
			{
				MeshRenderer meshRenderer2 = meshRenderer;
				MeshFilter component2 = originRenderer.GetComponent<MeshFilter>();
				if (component2.sharedMesh == null || component2.mesh == null)
				{
					UnityEngine.Object.Destroy(instance);
					instance = null;
					return false;
				}
				MeshFilter meshFilter = instance.AddComponent<MeshFilter>();
				meshFilter.mesh = component2.sharedMesh;
				meshFilter.sharedMesh.bounds = new Bounds(Vector3.zero, Vector3.one * 10f);
				meshRenderer2.shadowCastingMode = ShadowCastingMode.Off;
				meshRenderer2.lightProbeUsage = LightProbeUsage.Off;
				meshRenderer2.reflectionProbeUsage = ReflectionProbeUsage.Off;
			}
			return true;
		}
		goto IL_0191;
		IL_0191:
		UnityEngine.Object.Destroy(instance);
		instance = null;
		return false;
	}

	public void Initialize(in Material shadowMaterial)
	{
		foreach (Pair pair2 in pairs)
		{
			pair2.Clear();
		}
		pairs.Clear();
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>(includeInactive: false);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Renderer target = componentsInChildren[i];
			Pair pair = new Pair();
			Transform root = base.transform;
			if (pair.Initialize(in target, in shadowMaterial, in root))
			{
				pairs.Add(pair);
			}
		}
	}
}
public class PlanarShadow : MonoBehaviour
{
	public float planeHeight;

	private void Start()
	{
		if ((bool)GetComponent<Renderer>())
		{
			GetComponent<Renderer>().material.SetFloat("planeHeight", planeHeight);
		}
	}
}
public class PlatformCameraSetting : Billiards.MonoSingleton<PlatformCameraSetting>
{
	private readonly Appnori.Util.NotifierClass<Camera> MainCamera = new Appnori.Util.NotifierClass<Camera>();

	private const int CheckFrameCount = 10;

	private int frameCount;

	private bool isChecked;

	[Header("기억용 프로파일들")]
	[SerializeField]
	private List<VolumeProfile> profiles;

	protected override void Awake()
	{
		base.Awake();
		if (Billiards.MonoSingleton<PlatformCameraSetting>._instance != this)
		{
			UnityEngine.Object.DestroyImmediate(base.gameObject);
			return;
		}
		SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
		MainCamera.OnDataChanged += MainCamera_OnDataChanged;
	}

	private void MainCamera_OnDataChanged(Camera mainCamera)
	{
		if (!(mainCamera == null))
		{
			isChecked = true;
			if (mainCamera.TryGetComponent<UniversalAdditionalCameraData>(out var component))
			{
				component.antialiasing = AntialiasingMode.None;
				component.renderPostProcessing = false;
				component.renderShadows = false;
				mainCamera.allowHDR = false;
			}
		}
	}

	private void SceneManager_activeSceneChanged(Scene arg0, Scene arg1)
	{
		isChecked = false;
	}

	private void Update()
	{
		if (!isChecked && ++frameCount > 10)
		{
			MainCamera.CurrentData = Camera.main;
		}
	}
}
public class PlatformDependentFactory : MonoBehaviour
{
	[Serializable]
	public class Pair
	{
		public bool enabled;

		public GameObject Origin;
	}

	[SerializeField]
	private List<Pair> Pairs;

	protected void Awake()
	{
		foreach (Pair pair in Pairs)
		{
			if (pair.enabled)
			{
				UnityEngine.Object.Instantiate(pair.Origin).name = pair.Origin.name;
			}
		}
	}
}
public class HaloScaler : MonoBehaviour
{
}
public class ButtonAttribute : PropertyAttribute
{
	public string methodName;

	public string buttonName;

	public bool useValue;

	public BindingFlags flags;

	public ButtonAttribute(string methodName, string buttonName, bool useValue, BindingFlags flags = BindingFlags.Instance | BindingFlags.Public)
	{
		this.methodName = methodName;
		this.buttonName = buttonName;
		this.useValue = useValue;
		this.flags = flags;
	}

	public ButtonAttribute(string methodName, bool useValue, BindingFlags flags)
		: this(methodName, methodName, useValue, flags)
	{
	}

	public ButtonAttribute(string methodName, bool useValue)
		: this(methodName, methodName, useValue)
	{
	}

	public ButtonAttribute(string methodName, string buttonName, BindingFlags flags)
		: this(methodName, buttonName, useValue: false, flags)
	{
	}

	public ButtonAttribute(string methodName, string buttonName)
		: this(methodName, buttonName, useValue: false)
	{
	}

	public ButtonAttribute(string methodName, BindingFlags flags)
		: this(methodName, methodName, useValue: false, flags)
	{
	}

	public ButtonAttribute(string methodName)
		: this(methodName, methodName, useValue: false)
	{
	}
}
public class HierarchySelectData : ScriptableObject
{
	public Predicate<GameObject> predicate = (GameObject obj) => obj.name.ToLower().Contains("box");
}
public class TestHierarchySelect : MonoBehaviour
{
}
public class AightBallPoolNetworkGameAdapter : NetworkGameAdapter
{
	[Obsolete]
	public static bool is3DGraphics
	{
		get
		{
			return true;
		}
		set
		{
		}
	}

	[Obsolete]
	public static bool isSameGraphicsMode
	{
		get
		{
			return true;
		}
		set
		{
		}
	}

	public void SetTurn(int turnId)
	{
		BallPoolPlayer.turnId = turnId;
	}

	public void OnMainPlayerLoaded(int playerId, string name, int coins, object avatar, string avatarURL, int prize)
	{
		if (!BallPoolPlayer.initialized)
		{
			BallPoolPlayer.players = new BallPoolPlayer[2];
			BallPoolPlayer.playersCount = 2;
		}
		BallPoolPlayer.players[0] = new AightBallPoolPlayer(0, name, coins);
	}

	public void OnUpdateMainPlayerName(string name)
	{
		AightBallPoolPlayer.mainPlayer.name = name;
	}
}
public class Cue3DSet : MonoBehaviour
{
	public void Set()
	{
		GameObject gameObject = GameObject.Find("Cue3D");
		if ((bool)gameObject)
		{
			base.name = "Cue3DObject";
			base.transform.parent = gameObject.transform;
			base.transform.localPosition = Vector3.zero;
			base.transform.localRotation = Quaternion.identity;
		}
	}
}
public class ShotSlider : MonoBehaviour
{
	[SerializeField]
	private Slider shotSlider;

	[SerializeField]
	private Image cueSliderImage;

	private void Update()
	{
		cueSliderImage.fillAmount = 1f - shotSlider.value;
	}
}
public class BallsUIManager : MonoBehaviour
{
	public Sprite defaultBall;

	public Color defaultColor;

	public Sprite solidsBall;

	public Sprite stripesBall;

	public Color[] ballsColors;
}
[Obsolete("Not use")]
public class Camera3DRotator : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	[SerializeField]
	private RectTransform point;

	private RectTransform rectTransform;

	private float radius;

	private float currentRadius;

	private Vector3 localPosition;

	private Vector3 checkLocalPosition;

	private bool canControl;

	[SerializeField]
	private Transform tableCameraCenter;

	[SerializeField]
	private float cameraRotateSpeed = 3f;

	private float yRotation;

	private float zRotation;

	private void Awake()
	{
		rectTransform = GetComponent<RectTransform>();
	}

	private void Start()
	{
		radius = 0.5f * (rectTransform.sizeDelta.x - point.sizeDelta.x);
	}

	private void OnEnable()
	{
		localPosition = point.localPosition;
		UnityEngine.Debug.Log("OnEnable");
		InputOutput.OnMouseState += InputOutput_OnMouseState;
	}

	private void OnDisable()
	{
		InputOutput.OnMouseState -= InputOutput_OnMouseState;
	}

	private void InputOutput_OnMouseState(MouseState mouseState)
	{
		if (canControl && mouseState == MouseState.Up)
		{
			Resset();
			ShotController.canControl = true;
			canControl = false;
		}
		if (canControl && mouseState == MouseState.Press)
		{
			localPosition -= 0.3f * InputOutput.mouseScreenSpeed * Time.deltaTime;
			yRotation += (0f - cameraRotateSpeed) * localPosition.x * Time.deltaTime;
			zRotation += (0f - cameraRotateSpeed) * localPosition.y * Time.deltaTime;
			zRotation = Mathf.Clamp(zRotation, -15f, 0f);
			tableCameraCenter.localRotation = Quaternion.Euler(0f, yRotation, zRotation);
			currentRadius = Mathf.Sqrt(localPosition.x * localPosition.x + localPosition.y * localPosition.y);
			if (currentRadius < radius)
			{
				checkLocalPosition = localPosition;
				point.localPosition = localPosition;
			}
			else
			{
				localPosition = checkLocalPosition;
			}
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		canControl = true;
		ShotController.canControl = false;
	}

	public void Resset()
	{
		point.localPosition = (localPosition = Vector3.zero);
		ShotController.canControl = true;
	}

	public void SetPointTargetingPosition(Vector3 normalizedPosition)
	{
		point.localPosition = normalizedPosition * radius;
	}
}
public class PlayAgainMenu : MonoBehaviour
{
	[SerializeField]
	private GameObject menu;

	[SerializeField]
	private RectTransform root;

	[SerializeField]
	private Text winnerName;

	[SerializeField]
	private RawImage winnerImage;

	[SerializeField]
	private GameObject ButtonRoot;

	[SerializeField]
	private InteractableButton playAgainButton;

	[SerializeField]
	private Text playAgainText;

	[SerializeField]
	private GameUIController controller;

	[SerializeField]
	private CameraLook cameraLook;

	private bool isWin;

	private RenderTexture MainPlayerTexture
	{
		get
		{
			if (BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI)
			{
				return SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetRenderTexture(0);
			}
			return SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetRenderTexture(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(BallPoolPlayer.mainPlayer.name));
		}
	}

	private RenderTexture OtherPlayerTexture
	{
		get
		{
			if (BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI)
			{
				return SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetRenderTexture(1);
			}
			return SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetRenderTexture(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(BallPoolPlayer.players[1].name));
		}
	}

	public bool wasOpened { get; private set; }

	public event Action<bool> onActive;

	public void OnClickRematch()
	{
		DisablePlayAgainButton();
		controller.Rematch(isWin);
	}

	public void DisablePlayAgainButton()
	{
		playAgainButton.interactable = false;
		playAgainText.text = "Waiting";
	}

	public void HidePlayAgainButton()
	{
		playAgainButton.gameObject.SetActive(value: false);
	}

	public void Hide()
	{
		menu.SetActive(value: false);
		Billiards.Singleton<HandLineManager>.Instance.MainHand.RequestShow(enable: false, this);
		Billiards.Singleton<HandLineManager>.Instance.SubHand.RequestShow(enable: false, this);
		this.onActive?.Invoke(obj: false);
		wasOpened = false;
	}

	public void Show(BallPoolPlayer player)
	{
		this.onActive?.Invoke(obj: true);
		winnerName.text = player.name;
		if (player == BallPoolPlayer.mainPlayer)
		{
			winnerImage.texture = MainPlayerTexture;
		}
		else
		{
			winnerImage.texture = OtherPlayerTexture;
		}
		menu.SetActive(value: true);
		Billiards.Singleton<HandLineManager>.Instance.MainHand.RequestShow(enable: true, this);
		Billiards.Singleton<HandLineManager>.Instance.SubHand.RequestShow(enable: true, this);
		wasOpened = true;
		StartCoroutine(MenuOpenAnimation(1f));
		RebuildLayout();
	}

	public void SetNextStage(bool isWin)
	{
		if (BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI)
		{
			this.isWin = isWin;
			if (isWin)
			{
				playAgainText.text = "Next Level";
			}
			else
			{
				playAgainText.text = "Rematch";
			}
		}
	}

	private IEnumerator MenuOpenAnimation(float runTime)
	{
		cameraLook.enabled = false;
		ButtonRoot.SetActive(value: false);
		RebuildLayout();
		float t = 0f;
		while (t < runTime)
		{
			base.transform.Rotate(Vector3.up, (runTime - t) * 10f);
			t += Time.deltaTime;
			yield return null;
		}
		cameraLook.enabled = true;
		ButtonRoot.SetActive(value: true);
		RebuildLayout();
	}

	private void RebuildLayout()
	{
		LayoutRebuilder.ForceRebuildLayoutImmediate(root);
		LayoutRebuilder.ForceRebuildLayoutImmediate(root);
		LayoutRebuilder.ForceRebuildLayoutImmediate(root);
	}

	public void ShowMainPlayer()
	{
		HidePlayAgainButton();
		Show(BallPoolPlayer.mainPlayer);
		Billiards.SoundManager.PlaySound(Billiards.SoundManager.AudioClipType.Win);
	}
}
[Obsolete]
public class Targeting2DManager : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	[SerializeField]
	private RectTransform point;

	[SerializeField]
	private ShotController shotController;

	private RectTransform rectTransform;

	private float radius;

	private float currentRadius;

	private Vector3 localPosition;

	private Vector3 checkLocalPosition;

	private bool canControl;

	private void Awake()
	{
		rectTransform = GetComponent<RectTransform>();
	}

	private void Start()
	{
		radius = 0.5f * (rectTransform.sizeDelta.x - point.sizeDelta.x);
	}

	private void OnEnable()
	{
		localPosition = point.localPosition;
		UnityEngine.Debug.Log("OnEnable");
		InputOutput.OnMouseState += InputOutput_OnMouseState;
	}

	private void OnDisable()
	{
		InputOutput.OnMouseState -= InputOutput_OnMouseState;
	}

	private void InputOutput_OnMouseState(MouseState mouseState)
	{
		if (canControl && mouseState == MouseState.Up)
		{
			ShotController.canControl = true;
			canControl = false;
			shotController.ResetCueAfterTargeting();
		}
		if (canControl && mouseState == MouseState.PressAndMove)
		{
			localPosition -= 0.3f * InputOutput.mouseScreenSpeed * Time.deltaTime;
			currentRadius = Mathf.Sqrt(localPosition.x * localPosition.x + localPosition.y * localPosition.y);
			if (currentRadius < radius)
			{
				checkLocalPosition = localPosition;
				point.localPosition = localPosition;
			}
			else
			{
				localPosition = checkLocalPosition;
			}
			SetCuePosition(-localPosition / radius);
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		canControl = true;
		ShotController.canControl = false;
		shotController.ResetCueForTargeting();
	}

	private void SetCuePosition(Vector3 normalizedPosition)
	{
		shotController.SetCueTargetingPosition(normalizedPosition);
	}

	public void Reset()
	{
		point.localPosition = (localPosition = Vector3.zero);
		ShotController.canControl = true;
	}

	public void SetPointTargetingPosition(Vector3 normalizedPosition)
	{
		point.localPosition = normalizedPosition * radius;
	}
}
public class BoardCollider : MonoBehaviour
{
	private void Awake()
	{
		Mesh sharedMesh = GetComponent<MeshFilter>().sharedMesh;
		Mesh mesh = new Mesh();
		mesh.vertices = sharedMesh.vertices;
		mesh.triangles = sharedMesh.triangles;
		Vector3[] array = new Vector3[sharedMesh.normals.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Vector3.ProjectOnPlane(sharedMesh.normals[i], Vector3.up).normalized;
		}
		mesh.normals = array;
		mesh.RecalculateNormals();
		GetComponent<MeshCollider>().sharedMesh = mesh;
	}
}
public enum MouseState
{
	Down,
	Stay,
	Move,
	Press,
	PressAndStay,
	PressAndMove,
	Up
}
public class InputOutput : MonoBehaviour
{
	public delegate void OnMause(MouseState mouseState);

	private static Vector3 _mouseScreenSpeed;

	private static Vector3 _mouseViewportPoint;

	private static Vector3 _mouseWordSpeed;

	private static Vector3 _mouseScreenPosition;

	private static Vector3 _mouseScreenSymmetricalPosition;

	private static Vector3 _mouseScreenRelativePosition;

	private static Vector3 _mouseScreenRelativeSymmetricalPosition;

	private static Vector3 _mouseWordPosition;

	private static Vector3 _view;

	private static Ray _mouseWordRay;

	[SerializeField]
	private bool _isMobilePlatform;

	[SerializeField]
	private Camera _usedCamera;

	public static bool isMobilePlatform
	{
		get
		{
			return false;
		}
		private set
		{
		}
	}

	public static Camera usedCamera { get; set; }

	public static Vector3 mouseScreenPosition => _mouseScreenPosition;

	public static Vector3 mouseViewportPoint => _mouseViewportPoint;

	public static Vector3 mouseViewportSymmetricalPoint => new Vector3(_mouseViewportPoint.x - 0.5f, _mouseViewportPoint.y - 0.5f, 0f);

	public static Vector3 mouseScreenSymmetricalPosition => _mouseScreenSymmetricalPosition;

	public static Vector3 mouseScreenRelativePosition => _mouseScreenRelativePosition;

	public static Vector3 mouseScreenRelativeSymmetricalPosition => _mouseScreenRelativeSymmetricalPosition;

	public static Vector3 mouseWordPosition => _mouseWordPosition;

	public static Vector3 mouseScreenSpeed => _mouseScreenSpeed;

	public static Vector3 mouseWordSpeed => _mouseWordSpeed;

	public static Vector3 view => _view;

	public static Ray mouseWordRay => _mouseWordRay;

	public static bool inUsedCameraScreen
	{
		get
		{
			Vector3 mousePosition = Input.mousePosition;
			Vector3 vector = usedCamera.ScreenToViewportPoint(mousePosition);
			_ = usedCamera.rect;
			if (vector.x >= 0f && vector.x <= 1f && vector.y >= 0f)
			{
				return vector.y <= 1f;
			}
			return false;
		}
	}

	public static event OnMause OnMouseState;

	public static Vector3 WorldToScreenPoint(Vector3 position)
	{
		return usedCamera.WorldToScreenPoint(position);
	}

	public static float WorldToScreenRadius(float radius, Transform sphere)
	{
		Vector3 a = WorldToScreenPoint(sphere.position);
		Vector3 b = WorldToScreenPoint(sphere.position + radius * usedCamera.transform.right);
		return Vector3.Distance(a, b);
	}

	private void Awake()
	{
		if ((bool)_usedCamera)
		{
			usedCamera = _usedCamera;
		}
		if (UnityEngine.Application.isEditor)
		{
			isMobilePlatform = _isMobilePlatform;
		}
		else
		{
			isMobilePlatform = UnityEngine.Application.isMobilePlatform;
		}
	}

	private void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			_ = inUsedCameraScreen;
			Vector3 mousePosition = Input.mousePosition;
			Vector3 vector = usedCamera.ScreenToViewportPoint(mousePosition);
			_mouseScreenSymmetricalPosition = new Vector3(mousePosition.x - 0.5f * (float)Screen.width, mousePosition.y - 0.5f * (float)Screen.height, 0f);
			_mouseScreenPosition = mousePosition;
			Rect rect = usedCamera.rect;
			_mouseScreenRelativePosition = new Vector3(mousePosition.x - (float)Screen.width * rect.x, mousePosition.y - (float)Screen.height * rect.y, 0f);
			_mouseScreenRelativeSymmetricalPosition = new Vector3(mousePosition.x - (float)Screen.width * (rect.x + 0.5f * rect.width), mousePosition.y - (float)Screen.height * (rect.y + 0.5f * rect.height), 0f);
			_mouseViewportPoint = vector;
			_mouseWordPosition = usedCamera.ScreenToWorldPoint(_mouseScreenPosition);
			_mouseWordRay = usedCamera.ScreenPointToRay(_mouseScreenPosition);
			_mouseScreenSpeed = Vector3.zero;
			_mouseWordSpeed = Vector3.zero;
			if (InputOutput.OnMouseState != null)
			{
				InputOutput.OnMouseState(MouseState.Down);
			}
		}
		bool mouseButton = Input.GetMouseButton(0);
		if (!isMobilePlatform || mouseButton)
		{
			_ = inUsedCameraScreen;
			Vector3 mousePosition2 = Input.mousePosition;
			Vector3 vector2 = usedCamera.ScreenToViewportPoint(mousePosition2);
			Vector3 vector3 = usedCamera.ScreenToWorldPoint(mousePosition2);
			_mouseScreenSpeed = (mousePosition2 - _mouseScreenPosition) / Time.deltaTime;
			_mouseScreenPosition = mousePosition2;
			_mouseViewportPoint = vector2;
			_mouseScreenSymmetricalPosition = new Vector3(mousePosition2.x - 0.5f * (float)Screen.width, mousePosition2.y - 0.5f * (float)Screen.height, 0f);
			Rect rect2 = usedCamera.rect;
			_mouseScreenRelativePosition = new Vector3(mousePosition2.x - (float)Screen.width * rect2.x, mousePosition2.y - (float)Screen.height * rect2.y, 0f);
			_mouseScreenRelativeSymmetricalPosition = new Vector3(mousePosition2.x - (float)Screen.width * (rect2.x + 0.5f * rect2.width), mousePosition2.y - (float)Screen.height * (rect2.y + 0.5f * rect2.height), 0f);
			_mouseWordSpeed = (vector3 - _mouseWordPosition) / Time.deltaTime;
			_mouseWordPosition = usedCamera.ScreenToWorldPoint(_mouseScreenPosition);
			_mouseWordRay = usedCamera.ScreenPointToRay(_mouseScreenPosition);
			if (InputOutput.OnMouseState != null)
			{
				if (_mouseScreenSpeed.magnitude == 0f)
				{
					if (mouseButton)
					{
						InputOutput.OnMouseState(MouseState.Press);
						InputOutput.OnMouseState(MouseState.PressAndStay);
					}
					else
					{
						InputOutput.OnMouseState(MouseState.Stay);
					}
				}
				else if (mouseButton)
				{
					InputOutput.OnMouseState(MouseState.Press);
					InputOutput.OnMouseState(MouseState.PressAndMove);
				}
				else
				{
					InputOutput.OnMouseState(MouseState.Move);
				}
			}
		}
		if (Input.GetMouseButtonUp(0))
		{
			Vector3 mousePosition3 = Input.mousePosition;
			_mouseScreenSpeed = Vector3.zero;
			_mouseWordSpeed = Vector3.zero;
			_mouseScreenPosition = mousePosition3;
			_mouseScreenSymmetricalPosition = new Vector3(mousePosition3.x - 0.5f * (float)Screen.width, mousePosition3.y - 0.5f * (float)Screen.height, 0f);
			Rect rect3 = usedCamera.rect;
			_mouseScreenRelativePosition = new Vector3(mousePosition3.x - (float)Screen.width * rect3.x, mousePosition3.y - (float)Screen.height * rect3.y, 0f);
			_mouseScreenRelativeSymmetricalPosition = new Vector3(mousePosition3.x - (float)Screen.width * (rect3.x + 0.5f * rect3.width), mousePosition3.y - (float)Screen.height * (rect3.y + 0.5f * rect3.height), 0f);
			_mouseViewportPoint = usedCamera.ScreenToViewportPoint(mousePosition3);
			_view = Vector3.zero;
			_mouseWordRay = default(Ray);
			if (InputOutput.OnMouseState != null)
			{
				InputOutput.OnMouseState(MouseState.Up);
			}
		}
		else
		{
			_view = usedCamera.transform.forward;
		}
	}
}
public class GizmosCircle : MonoBehaviour
{
	public int nodeCounts = 12;

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.cyan;
		float num = 0.5f * base.transform.lossyScale.x;
		Vector3 position = base.transform.position;
		Vector3 forward = base.transform.forward;
		Vector3 right = base.transform.right;
		float num2 = (float)Math.PI * 2f / (float)nodeCounts;
		float num3 = (float)Math.PI * 2f;
		for (float num4 = 0f; num4 < num3; num4 += num2)
		{
			float num5 = num * Mathf.Sin(num4);
			float num6 = num * Mathf.Cos(num4);
			float num7 = num * Mathf.Sin(num4 + num2);
			float num8 = num * Mathf.Cos(num4 + num2);
			Vector3 from = position + num5 * right + num6 * forward;
			Vector3 to = position + num7 * right + num8 * forward;
			Gizmos.DrawLine(from, to);
		}
	}
}
public class GizmosCube : MonoBehaviour
{
	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.white;
		DrawGizmosCube(base.transform);
	}

	public static void DrawGizmosCube(Transform cube)
	{
		Vector3 position = cube.position;
		Vector3 vector = 0.5f * cube.lossyScale.x * cube.right + 0.5f * cube.lossyScale.y * cube.up + 0.5f * cube.lossyScale.z * cube.forward;
		Vector3 vector2 = -0.5f * cube.lossyScale.x * cube.right + 0.5f * cube.lossyScale.y * cube.up + 0.5f * cube.lossyScale.z * cube.forward;
		Vector3 vector3 = -0.5f * cube.lossyScale.x * cube.right - 0.5f * cube.lossyScale.y * cube.up + 0.5f * cube.lossyScale.z * cube.forward;
		Vector3 vector4 = 0.5f * cube.lossyScale.x * cube.right - 0.5f * cube.lossyScale.y * cube.up + 0.5f * cube.lossyScale.z * cube.forward;
		Vector3 vector5 = 0.5f * cube.lossyScale.x * cube.right + 0.5f * cube.lossyScale.y * cube.up - 0.5f * cube.lossyScale.z * cube.forward;
		Vector3 vector6 = -0.5f * cube.lossyScale.x * cube.right + 0.5f * cube.lossyScale.y * cube.up - 0.5f * cube.lossyScale.z * cube.forward;
		Vector3 vector7 = -0.5f * cube.lossyScale.x * cube.right - 0.5f * cube.lossyScale.y * cube.up - 0.5f * cube.lossyScale.z * cube.forward;
		Vector3 vector8 = 0.5f * cube.lossyScale.x * cube.right - 0.5f * cube.lossyScale.y * cube.up - 0.5f * cube.lossyScale.z * cube.forward;
		Gizmos.DrawLine(position + vector, position + vector2);
		Gizmos.DrawLine(position + vector2, position + vector3);
		Gizmos.DrawLine(position + vector3, position + vector4);
		Gizmos.DrawLine(position + vector4, position + vector);
		Gizmos.DrawLine(position + vector5, position + vector6);
		Gizmos.DrawLine(position + vector6, position + vector7);
		Gizmos.DrawLine(position + vector7, position + vector8);
		Gizmos.DrawLine(position + vector8, position + vector5);
		Gizmos.DrawLine(position + vector, position + vector5);
		Gizmos.DrawLine(position + vector2, position + vector6);
		Gizmos.DrawLine(position + vector3, position + vector7);
		Gizmos.DrawLine(position + vector4, position + vector8);
	}
}
public class GizmosLine : MonoBehaviour
{
	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.blue;
		DrawGizmosQuad(base.transform);
	}

	public static void DrawGizmosQuad(Transform quad)
	{
		Vector3 position = quad.position;
		Vector3 vector = 0.5f * quad.lossyScale.x * quad.right;
		Vector3 vector2 = -0.5f * quad.lossyScale.x * quad.right;
		Gizmos.DrawLine(position + vector, position + vector2);
		Gizmos.DrawLine(quad.position, quad.position - quad.lossyScale.z * quad.forward);
	}
}
public class GizmosNode : MonoBehaviour
{
	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.yellow;
		Gizmos.DrawWireSphere(base.transform.position, 0.5f * base.transform.lossyScale.x);
	}
}
public class GizmosQuad : MonoBehaviour
{
	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.green;
		Vector3 lossyScale = base.transform.lossyScale;
		Gizmos.DrawCube(base.transform.position, new Vector3(lossyScale.x, 0f, lossyScale.y));
	}

	public static void DrawGizmosQuad(Transform quad)
	{
		Vector3 position = quad.position;
		Vector3 vector = 0.5f * quad.lossyScale.x * quad.right + 0.5f * quad.lossyScale.y * quad.up;
		Vector3 vector2 = -0.5f * quad.lossyScale.x * quad.right + 0.5f * quad.lossyScale.y * quad.up;
		Vector3 vector3 = -0.5f * quad.lossyScale.x * quad.right - 0.5f * quad.lossyScale.y * quad.up;
		Vector3 vector4 = 0.5f * quad.lossyScale.x * quad.right - 0.5f * quad.lossyScale.y * quad.up;
		Gizmos.DrawLine(position + vector, position + vector2);
		Gizmos.DrawLine(position + vector2, position + vector3);
		Gizmos.DrawLine(position + vector3, position + vector4);
		Gizmos.DrawLine(position + vector4, position + vector);
		Gizmos.DrawLine(quad.position, quad.position - quad.lossyScale.z * quad.forward);
	}
}
public class GizmosSphere : MonoBehaviour
{
	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.red;
		Gizmos.DrawSphere(base.transform.position, 0.5f * base.transform.lossyScale.x);
	}
}
public interface NetworkGameAdapter
{
	void SetTurn(int turnId);

	void OnMainPlayerLoaded(int playerId, string name, int coins, object avatar, string avatarURL, int prize);

	void OnUpdateMainPlayerName(string name);
}
public class LocalNetwork : NetworkEngine
{
	public override void Initialize()
	{
	}

	public override void Disconnect()
	{
	}

	public override void SendRemoteMessage(string message, params object[] args)
	{
	}

	public override void OnGoToPLayWithPlayer(PlayerProfile player)
	{
	}

	protected override void Update()
	{
	}

	public override void OnSendTime(float time01)
	{
	}

	public override void Connect()
	{
	}

	public override void CreateRoom()
	{
	}

	public override void LeftRoom()
	{
	}

	public override void Reset()
	{
	}

	public override void StartSimulate(string ballsState)
	{
	}

	public override void EndSimulate(string ballsState)
	{
	}

	public override void OnOpponenReadToPlay(string playerData, bool is3DGraphicMode)
	{
	}

	public override void OnOpponenStartToPlay(int turnId)
	{
	}

	public override void OnOpponenInGameScene()
	{
	}

	public override void OnOpponentForceGoHome()
	{
	}

	public override void StartUpdatePlayers()
	{
	}

	public override void LoadPlayers(ref PlayerProfile[] players)
	{
		players = null;
	}

	public override bool ChackIsFriend(string id)
	{
		return false;
	}
}
public class PunNetwork : NetworkEngine, AightBallPoolMessenger, IConnectionCallbacks, IInRoomCallbacks, ILobbyCallbacks, IMatchmakingCallbacks, IPunObservable
{
	private PhotonView photonView;

	private string gameVersion = "0.01";

	private Player opponentPlayer;

	private AightBallPoolNetworkMessenger messenger;

	private List<RoomInfo> cachedRoomList;

	public override void Initialize()
	{
		if (!messenger)
		{
			messenger = base.gameObject.AddComponent<AightBallPoolNetworkMessenger>();
		}
		if (cachedRoomList == null)
		{
			cachedRoomList = new List<RoomInfo>();
		}
	}

	protected override void Awake()
	{
		base.Awake();
		UnityEngine.Debug.Log("Connect ");
		base.sendRate = 10;
		PhotonNetwork.SendRate = base.sendRate;
		PhotonNetwork.SerializationRate = base.sendRate;
		photonView = base.gameObject.AddComponent<PhotonView>();
		photonView.ObservedComponents = new List<Component>(0);
		photonView.ObservedComponents.Add(this);
		photonView.ViewID = 5;
		PhotonNetwork.AddCallbackTarget(this);
	}

	public void OnDestroy()
	{
		if (photonView != null)
		{
			photonView.ObservedComponents.Clear();
		}
		PhotonNetwork.RemoveCallbackTarget(this);
	}

	public override void Disable()
	{
		base.Disable();
	}

	protected override void Update()
	{
		base.Update();
	}

	public override void SendRemoteMessage(string message, params object[] args)
	{
		photonView.RPC(message, opponentPlayer, args);
	}

	public override void OnGoToPLayWithPlayer(PlayerProfile player)
	{
		if (PhotonNetwork.LocalPlayer != PhotonNetwork.MasterClient)
		{
			NetworkManager.opponentPlayer = player;
			PhotonNetwork.JoinRoom(NetworkManager.PlayerToString(NetworkManager.opponentPlayer));
		}
		else
		{
			photonView.RPC("OnOpponenReadToPlay", opponentPlayer, NetworkManager.PlayerToString(NetworkManager.mainPlayer), AightBallPoolNetworkGameAdapter.is3DGraphics);
		}
	}

	public override void CreateRoom()
	{
		if (PhotonNetwork.NetworkClientState == ClientState.Joined)
		{
			PhotonNetwork.LeaveRoom();
		}
		if (PhotonNetwork.IsConnectedAndReady && PhotonNetwork.NetworkClientState == ClientState.JoinedLobby)
		{
			PhotonNetwork.CreateRoom(NetworkManager.PlayerToString(NetworkManager.mainPlayer), new Photon.Realtime.RoomOptions
			{
				MaxPlayers = 2
			});
		}
	}

	public override void Reset()
	{
		LeftRoom();
	}

	public override void LeftRoom()
	{
		if (PhotonNetwork.NetworkClientState == ClientState.Joined)
		{
			PhotonNetwork.LeaveRoom();
		}
	}

	public override void Connect()
	{
		if ((bool)photonView && base.reachable)
		{
			UnityEngine.Debug.Log(string.Concat("photonView ", photonView, "  reachable ", base.reachable.ToString(), "   PhotonNetwork.NetworkClientState ", PhotonNetwork.NetworkClientState));
			if (!PhotonNetwork.IsConnected)
			{
				PhotonNetwork.ConnectUsingSettings();
			}
			else if (PhotonNetwork.NetworkClientState == ClientState.ConnectingToMasterServer)
			{
				PhotonNetwork.Disconnect();
			}
		}
	}

	public override void Disconnect()
	{
		if (PhotonNetwork.NetworkClientState != ClientState.Disconnected)
		{
			PhotonNetwork.Disconnect();
		}
	}

	void IConnectionCallbacks.OnConnected()
	{
		CallNetworkState(NetworkState.Connected);
		UnityEngine.Debug.Log("state " + base.state);
	}

	void IConnectionCallbacks.OnConnectedToMaster()
	{
	}

	void IConnectionCallbacks.OnRegionListReceived(RegionHandler regionHandler)
	{
	}

	void IConnectionCallbacks.OnCustomAuthenticationResponse(Dictionary<string, object> data)
	{
	}

	void IConnectionCallbacks.OnCustomAuthenticationFailed(string debugMessage)
	{
	}

	void IConnectionCallbacks.OnDisconnected(DisconnectCause parameters)
	{
		switch (parameters)
		{
		case DisconnectCause.ExceptionOnConnect:
		case DisconnectCause.Exception:
		case DisconnectCause.InvalidAuthentication:
		case DisconnectCause.CustomAuthenticationFailed:
		case DisconnectCause.AuthenticationTicketExpired:
		case DisconnectCause.MaxCcuReached:
		case DisconnectCause.InvalidRegion:
			CallNetworkState(NetworkState.FiledToConnect);
			break;
		case DisconnectCause.ServerTimeout:
		case DisconnectCause.ClientTimeout:
		case DisconnectCause.DisconnectByServerLogic:
		case DisconnectCause.DisconnectByServerReasonUnknown:
		case DisconnectCause.OperationNotAllowedInCurrentState:
		case DisconnectCause.DisconnectByClientLogic:
			CallNetworkState(NetworkState.LostConnection);
			break;
		}
		CallNetworkState(NetworkState.FiledToConnect);
		UnityEngine.Debug.LogWarning($"OnDisconnected is invoked. Cause : {parameters}");
		UnityEngine.Debug.LogWarning(base.state);
	}

	void ILobbyCallbacks.OnJoinedLobby()
	{
		UnityEngine.Debug.Log("Lobby Joined ");
	}

	void ILobbyCallbacks.OnRoomListUpdate(List<RoomInfo> roomInfos)
	{
		cachedRoomList = roomInfos;
		StartUpdatePlayers();
	}

	void ILobbyCallbacks.OnLobbyStatisticsUpdate(List<TypedLobbyInfo> lobbyStatistics)
	{
	}

	void ILobbyCallbacks.OnLeftLobby()
	{
		UnityEngine.Debug.Log("Lobby Left");
	}

	void IMatchmakingCallbacks.OnJoinedRoom()
	{
		if (PhotonNetwork.LocalPlayer != PhotonNetwork.MasterClient)
		{
			opponentPlayer = PhotonNetwork.MasterClient;
			photonView.RPC("OnOpponenReadToPlay", opponentPlayer, NetworkManager.PlayerToString(NetworkManager.mainPlayer), AightBallPoolNetworkGameAdapter.is3DGraphics);
		}
		CallNetworkState(NetworkState.JoinedToRoom);
	}

	void IMatchmakingCallbacks.OnCreateRoomFailed(short code, string msg)
	{
	}

	void IMatchmakingCallbacks.OnCreatedRoom()
	{
		StartUpdatePlayers();
		CallNetworkState(NetworkState.CreatedRoom);
	}

	void IMatchmakingCallbacks.OnLeftRoom()
	{
		opponentPlayer = null;
		PhotonNetwork.RemoveRPCs(PhotonNetwork.LocalPlayer);
		CallNetworkState(NetworkState.LeftRoom);
	}

	void IMatchmakingCallbacks.OnFriendListUpdate(List<FriendInfo> friendList)
	{
	}

	void IMatchmakingCallbacks.OnJoinRoomFailed(short returnCode, string message)
	{
		CallNetworkState(NetworkState.JoinRoomFailed);
	}

	void IMatchmakingCallbacks.OnJoinRandomFailed(short returnCode, string message)
	{
		CallNetworkState(NetworkState.JoinRoomFailed);
	}

	void IInRoomCallbacks.OnPlayerEnteredRoom(Player newPlayer)
	{
		UnityEngine.Debug.Log("OnPhotonPlayerConnected " + newPlayer.UserId);
		opponentPlayer = newPlayer;
	}

	void IInRoomCallbacks.OnMasterClientSwitched(Player newMasterClient)
	{
		UnityEngine.Debug.LogWarning("OnMasterClientSwitched");
	}

	void IInRoomCallbacks.OnPlayerLeftRoom(Player otherPlayer)
	{
		UnityEngine.Debug.LogWarning("OnPhotonPlayerDisconnected");
		PhotonNetwork.LeaveRoom();
		PhotonNetwork.RemoveRPCs(otherPlayer);
		PhotonNetwork.DestroyPlayerObjects(otherPlayer);
	}

	void IInRoomCallbacks.OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
	{
	}

	void IInRoomCallbacks.OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
	{
	}

	public override void LoadPlayers(ref PlayerProfile[] players)
	{
		cachedRoomList.ToArray();
		List<PlayerProfile> list = new List<PlayerProfile>(0);
		foreach (RoomInfo cachedRoom in cachedRoomList)
		{
			if (cachedRoom.PlayerCount < cachedRoom.MaxPlayers)
			{
				list.Add(NetworkManager.PlayerFromString(cachedRoom.Name, ChackIsFriend));
			}
		}
		players = list.ToArray();
	}

	public override bool ChackIsFriend(string id)
	{
		string[] friendsId = NetworkManager.social.GetFriendsId();
		if (friendsId != null)
		{
			string[] array = friendsId;
			foreach (string text in array)
			{
				if (id == text)
				{
					return true;
				}
			}
		}
		return false;
	}

	public override void StartUpdatePlayers()
	{
		StartCoroutine(UpdatePlayers());
	}

	private IEnumerator UpdatePlayers()
	{
		NetworkManager.social.UpdateFriendsList();
		while (!NetworkManager.social.friendsListIsUpdated)
		{
			yield return null;
		}
		NetworkManager.UpdatePlayers();
		StartCoroutine(NetworkManager.LoadRandomPlayer());
		StartCoroutine(NetworkManager.LoadFriendsAndRandomPlayers(50));
	}

	[PunRPC]
	public override void OnOpponenReadToPlay(string playerData, bool is3DGraphicMode)
	{
		NetworkManager.opponentPlayer = NetworkManager.PlayerFromString(playerData, ChackIsFriend);
		AightBallPoolNetworkGameAdapter.isSameGraphicsMode = AightBallPoolNetworkGameAdapter.is3DGraphics == is3DGraphicMode;
		UnityEngine.Debug.Log("OnOpponenReadToPlay " + playerData);
		CallNetworkState(NetworkState.OpponentReadToPlay);
		if (PhotonNetwork.LocalPlayer != PhotonNetwork.MasterClient)
		{
			int num = UnityEngine.Random.Range(0, 2);
			int num2 = ((num != 1) ? 1 : 0);
			OnOpponenStartToPlay(num);
			photonView.RPC("OnOpponenStartToPlay", opponentPlayer, num2);
		}
	}

	[PunRPC]
	public override void OnOpponenStartToPlay(int turnId)
	{
		UnityEngine.Debug.Log(" OnOpponenStartToPlay " + turnId);
		base.adapter.SetTurn(turnId);
	}

	[PunRPC]
	public override void OnSendTime(float time01)
	{
		messenger.SetTime(time01);
	}

	[PunRPC]
	public override void StartSimulate(string impulse)
	{
		messenger.StartSimulate(impulse);
	}

	[PunRPC]
	public override void EndSimulate(string ballsState)
	{
		messenger.EndSimulate(ballsState);
	}

	[PunRPC]
	public override void OnOpponenWaitingForYourTurn()
	{
		base.OnOpponenWaitingForYourTurn();
	}

	[PunRPC]
	public override void OnOpponenInGameScene()
	{
		StartCoroutine(messenger.OnOpponenInGameScene());
	}

	[PunRPC]
	public override void OnOpponentForceGoHome()
	{
		messenger.OnOpponentForceGoHome();
	}

	[PunRPC]
	public void OnSendGameState(int state)
	{
		messenger.OnSendGameState(state);
	}

	[PunRPC]
	public void OnSendMainHanded(int isRightHanded)
	{
		messenger.OnSendMainHanded(isRightHanded == 1);
	}

	[PunRPC]
	public void OnSendCueControl(Vector3 cuePivotPosition, float cuePivotLocalRotationY, float cueVerticalLocalRotationX, Vector2 cueDisplacementLocalPositionXY, float cueSliderLocalPositionZ, float force)
	{
		messenger.OnSendCueControl(cuePivotPosition, cuePivotLocalRotationY, cueVerticalLocalRotationX, cueDisplacementLocalPositionXY, cueSliderLocalPositionZ, force);
	}

	[PunRPC]
	public void OnForceSendCueControl(Vector3 cuePivotPosition, float cuePivotLocalRotationY, float cueVerticalLocalRotationX, Vector2 cueDisplacementLocalPositionXY, float cueSliderLocalPositionZ, float force)
	{
		messenger.OnForceSendCueControl(cuePivotPosition, cuePivotLocalRotationY, cueVerticalLocalRotationX, cueDisplacementLocalPositionXY, cueSliderLocalPositionZ, force);
	}

	[PunRPC]
	public void OnMoveBall(Vector3 ballPosition)
	{
		messenger.OnMoveBall(ballPosition);
	}

	[PunRPC]
	public void SelectBallPosition(Vector3 ballPosition)
	{
		messenger.SelectBallPosition(ballPosition);
	}

	[PunRPC]
	public void SetBallPosition(Vector3 ballPosition)
	{
		messenger.SetBallPosition(ballPosition);
	}

	[PunRPC]
	public void SetMechanicalStatesFromNetwork(int ballId, string mechanicalStateData)
	{
		messenger.SetMechanicalStatesFromNetwork(ballId, mechanicalStateData);
	}

	[PunRPC]
	public void WaitAndStopMoveFromNetwork(float time)
	{
		messenger.WaitAndStopMoveFromNetwork(time);
	}

	[PunRPC]
	public void SendOpponentCueURL(string url)
	{
		messenger.SetOpponentCueURL(url);
	}

	[PunRPC]
	public void SendOpponentTableURLs(string boardURL, string clothURL, string clothColor)
	{
		messenger.SetOpponentTableURLs(boardURL, clothURL, clothColor);
	}

	[PunRPC]
	public void SendPlayerTransform(string uuid, Vector3 worldPosition, Quaternion rotation, Vector3 worldPosition2, Quaternion rotation2, Vector3 worldPosition3, Quaternion rotation3)
	{
		messenger.SetPlayerTransform(uuid, worldPosition, rotation, worldPosition2, rotation2, worldPosition3, rotation3);
	}

	[PunRPC]
	public void SendRequestRematch(bool value)
	{
		UnityEngine.Debug.Log("Received RemoteMessage : SendRequestRematch " + value);
		messenger.SetRequestRematch(value);
	}

	[PunRPC]
	public void SendFoulInfo(int FoulType, int ballId, int pocketId)
	{
		UnityEngine.Debug.Log("Received RemoteMessage : SendFoulInfo " + FoulType);
		messenger.SetFoul(FoulType, ballId, pocketId);
	}

	public bool isMasterClient()
	{
		return PhotonNetwork.LocalPlayer == PhotonNetwork.MasterClient;
	}

	public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
	}
}
public class GameModeManager : MonoBehaviour
{
	[SerializeField]
	private string homeScene;

	public void SetGameMode(int modeId)
	{
		AightBallPoolNetworkGameAdapter.is3DGraphics = modeId == 0;
		SceneManager.LoadScene(homeScene);
	}
}
public class InfoManager : MonoBehaviour
{
	private static InfoManager[] instances;

	private Component sender;

	private string message;

	[SerializeField]
	private string infoName;

	[SerializeField]
	private Text infoText;

	private void Awake()
	{
		instances = UnityEngine.Object.FindObjectsOfType<InfoManager>();
		base.transform.GetChild(0).gameObject.SetActive(value: false);
	}

	public static void Open(string infoName, Component sender, string message, string info = "")
	{
		InfoManager[] array = instances;
		foreach (InfoManager infoManager in array)
		{
			if (infoManager.infoName == infoName)
			{
				infoManager.OpenWindow(sender, message, info);
				return;
			}
		}
		UnityEngine.Debug.LogWarning("There is no InfoManager with name " + infoName);
	}

	private void OpenWindow(Component sender, string message, string info = "")
	{
		this.sender = sender;
		this.message = message;
		if (infoText != null && !string.IsNullOrEmpty(info))
		{
			infoText.text = info;
		}
		base.transform.GetChild(0).gameObject.SetActive(value: true);
	}

	public void CLose()
	{
		if ((bool)sender && !string.IsNullOrEmpty(message))
		{
			sender.SendMessage(message);
		}
		base.transform.GetChild(0).gameObject.SetActive(value: false);
	}
}
public class FacebookWindowManager : MonoBehaviour
{
	[SerializeField]
	private Text publicProfileText;

	[SerializeField]
	private Text publishActionsText;

	[SerializeField]
	private Text allActionsText;

	private void OnEnable()
	{
	}
}
public class SocialExample : SocialEngine
{
	private bool requestForLogin;

	public SocialExample()
	{
		FacebookManager.instance.OnLoggedIn += FacebookManager_instance_OnLoggedIn;
		FacebookManager.instance.OnInitialized += delegate
		{
			CallFacebokInitialized();
		};
		if (!FacebookManager.instance.IsInitialized)
		{
			FacebookManager.instance.Init();
		}
	}

	public override void ShareOnFacebook()
	{
		UnityEngine.Debug.Log("ShareOnFacebook");
		FacebookManager.instance.ShareLink();
	}

	public override void ShareOnTwitter()
	{
		UnityEngine.Debug.Log("ShareOnTwitter");
	}

	public override void ShareOnGoogle()
	{
		UnityEngine.Debug.Log("ShareOnGoogle");
	}

	public override void ShareByEmail()
	{
		UnityEngine.Debug.Log("ShareByEmail");
	}

	public override void SaveMainPlayerName(string playerName)
	{
		DataManager.SetStringData("MainPlayerName", playerName);
	}

	public override string GetMainPlayerName()
	{
		string text = DataManager.GetStringData("MainPlayerName");
		if (string.IsNullOrEmpty(text))
		{
			text = "Guest " + UnityEngine.Random.Range(1, 1000);
		}
		return text;
	}

	public override void SaveMainPlayerCoins(int playerCoins)
	{
		int value = Mathf.Clamp(playerCoins, base.minCoinsCount, playerCoins);
		DataManager.SetInt("MainPlayerCoins", value);
	}

	public override int GetMainPlayerCoins()
	{
		int num = DataManager.GetInt("MainPlayerCoins");
		if (num == 0)
		{
			num = 1500;
			DataManager.SetInt("MainPlayerCoins", num);
		}
		return num;
	}

	public override void SaveMainPlayerPrize(int prize)
	{
		DataManager.SetIntData("MainPlayerPrize", prize);
	}

	public override int GetMainPlayerPrize()
	{
		int intData = DataManager.GetIntData("MainPlayerPrize");
		if (intData == 0)
		{
			intData = base.minOnLinePrize;
		}
		return intData;
	}

	public override void SaveAvatarURL(string url)
	{
		DataManager.SetStringData("MainPlayerAvatarURL", url);
	}

	public override string GetAvatarURL()
	{
		return DataManager.GetStringData("MainPlayerAvatarURL");
	}

	public override string GetMainPlayerEmail()
	{
		return "vagho.srapyan@gmail.com";
	}

	public override string GetPrivacyPolicyURL()
	{
		return "https://www.linkedin.com/in/vaghinak-srapyan-95016773";
	}

	public override string[] GetFriendsId()
	{
		return FacebookManager.instance.friendsId;
	}

	public override void SignUp(string email, string password)
	{
		CallSignUpEvent(LoginedState.Successful);
	}

	public override void Login(string email, string password)
	{
		CallLoginEvent(LoginedState.Successful);
	}

	public override void LoginWithFacebok()
	{
		if (FacebookManager.instance.IsInitialized)
		{
			requestForLogin = true;
			FacebookManager.instance.Login();
		}
	}

	public override void UpdateFriendsList()
	{
		base.friendsListIsUpdated = false;
		FacebookManager.instance.OnUpdatedFriendsList += FacebookManager_instance_OnUpdatedFriendsList;
		FacebookManager.instance.UpdateFriendsList();
	}

	private void FacebookManager_instance_OnLoggedIn(LoginedState info)
	{
		if (info == LoginedState.Successful)
		{
			_ = FacebookManager.instance.IsLoggedInWithPublishPermissions;
			if (requestForLogin)
			{
				SetAvatarDataIsLocal(isLocal: false);
			}
			base.mainPlayerId = FacebookManager.instance.mainUserId;
			CallLoginWithFacebokEvent(info);
			NetworkManager.network.StartUpdatePlayers();
		}
	}

	private void FacebookManager_instance_OnUpdatedFriendsList()
	{
		FacebookManager.instance.OnUpdatedFriendsList -= FacebookManager_instance_OnUpdatedFriendsList;
		base.friendsListIsUpdated = true;
	}

	public override bool AvatarDataIsLocal()
	{
		return DataManager.GetIntData("AvatarDataIsLocal") == 1;
	}

	public override void SetAvatarDataIsLocal(bool isLocal)
	{
		DataManager.SetIntData("AvatarDataIsLocal", isLocal ? 1 : 0);
	}

	public override void CallOnApplicationPause(bool pauseStatus)
	{
		if (!pauseStatus)
		{
			if (FacebookManager.instance.IsInitialized)
			{
				FacebookManager.instance.Activate();
			}
			else
			{
				FacebookManager.instance.Init();
			}
		}
	}

	public override bool IsLoggedIn()
	{
		return FacebookManager.instance.IsLoggedIn;
	}

	public override bool IsLoggedInWithPublishPermissions()
	{
		return FacebookManager.instance.IsLoggedInWithPublishPermissions;
	}
}
public class TurnamentManager : MonoBehaviour
{
	[SerializeField]
	private TurnamentPlayers[] turnamentPlayers;

	private List<TurnamentPlayers> currentTurPlayers;

	public bool IsStarted { get; private set; }

	public bool IsReady
	{
		get
		{
			if (!IsStarted && currentTurPlayers != null)
			{
				return currentTurPlayers.Count == turnamentPlayers.Length;
			}
			return false;
		}
	}

	public void Reset()
	{
		TurnamentPlayer[] componentsInChildren = GetComponentsInChildren<TurnamentPlayer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].Reset();
		}
		currentTurPlayers = new List<TurnamentPlayers>(0);
		IsStarted = false;
	}

	public void Add(string playerName, Texture playerTexture)
	{
		if (!IsStarted)
		{
			if (currentTurPlayers == null)
			{
				Reset();
			}
			if (currentTurPlayers.Count != this.turnamentPlayers.Length)
			{
				TurnamentPlayers turnamentPlayers = this.turnamentPlayers[currentTurPlayers.Count];
				turnamentPlayers.Set(playerName, playerTexture);
				currentTurPlayers.Add(turnamentPlayers);
			}
		}
	}

	public void StartGame()
	{
		if (IsReady)
		{
			IsStarted = true;
		}
	}
}
public class TurnamentPlayer : MonoBehaviour
{
	public Text nameText;

	public RawImage avatar;

	public bool isFull { get; private set; }

	public void Set(string playerName, Texture image)
	{
		isFull = true;
		nameText.text = playerName;
		if ((bool)image)
		{
			avatar.texture = image;
		}
	}

	public void Set(TurnamentPlayer player)
	{
		isFull = true;
		Set(player.nameText.text, player.avatar.texture);
	}

	public void Reset()
	{
		isFull = false;
	}
}
public class TurnamentPlayers : MonoBehaviour
{
	[SerializeField]
	private TurnamentPlayer player1;

	[SerializeField]
	private TurnamentPlayer player2;

	[SerializeField]
	private TurnamentPlayers turnamentPlayers;

	public void SetToParent(TurnamentPlayer player)
	{
		turnamentPlayers.Set(player);
	}

	private void Set(TurnamentPlayer player)
	{
		if (!player1.isFull)
		{
			player1.Set(player);
		}
		else
		{
			player2.Set(player);
		}
	}

	public void Set(string playerName, Texture image)
	{
		if (!player1.isFull)
		{
			player1.Set(playerName, image);
		}
		else
		{
			player2.Set(playerName, image);
		}
	}
}
public class HomeAdsManager : MonoBehaviour
{
	[SerializeField]
	private Button adsButton;

	[SerializeField]
	private Button upgradeButton;

	[SerializeField]
	private float animateTime;

	private Vector3 startAdsButtonSqale;

	private Vector3 startUpgradeButtonSqale;

	private void Awake()
	{
		startAdsButtonSqale = adsButton.targetGraphic.rectTransform.localScale;
		startUpgradeButtonSqale = upgradeButton.targetGraphic.rectTransform.localScale;
	}

	public void OfferAd()
	{
		StartCoroutine(AnimateAdsButton());
	}

	private IEnumerator AnimateAdsButton()
	{
		float time = animateTime;
		while (time > 0f)
		{
			time -= Time.deltaTime;
			yield return new WaitForEndOfFrame();
			float num = Mathf.Sin(time * 20f);
			adsButton.targetGraphic.rectTransform.localScale = startAdsButtonSqale * (1f + 0.1f * num);
			upgradeButton.targetGraphic.rectTransform.localScale = startUpgradeButtonSqale * (1f - 0.1f * num);
		}
		adsButton.targetGraphic.rectTransform.localScale = startAdsButtonSqale;
	}
}
public class PlayerProfileUI : MonoBehaviour
{
	public RawImage avatarImage;

	private Texture nullTexture;

	private Texture2D defaulImage;

	[SerializeField]
	private Text userName;

	[SerializeField]
	private Text coins;

	[SerializeField]
	private Text prize;

	[SerializeField]
	private Image state;

	[SerializeField]
	private Text isFriend;

	[SerializeField]
	private Text waitingOpponent;

	private float waitingProgress;

	private int waitingProgressInt;

	private float orient = 1f;

	private bool isFirstTimeSet = true;

	public PlayerProfile player { get; private set; }

	public void SetPrizeColor(Color color)
	{
		prize.color = color;
	}

	private void Update()
	{
		if (!waitingOpponent)
		{
			base.enabled = false;
		}
		waitingProgress += 2f * orient * Time.deltaTime;
		int num = (int)waitingProgress;
		if (waitingProgress > 3.49f || waitingProgress < -0.49f)
		{
			orient *= -1f;
		}
		if (waitingProgressInt != num)
		{
			waitingProgressInt = num;
			string text = "Waiting";
			for (int i = 1; i <= waitingProgressInt; i++)
			{
				text += ".";
			}
			waitingOpponent.text = text;
		}
	}

	public void UpdateCoinsFromPlayer()
	{
		if (player != null)
		{
			coins.text = string.Concat(player.coins);
		}
	}

	public void UpdatePrizeFromPlayer()
	{
		if (player != null)
		{
			prize.text = string.Concat(player.prize);
		}
	}

	public void SetPlayer(PlayerProfile player)
	{
		if (isFirstTimeSet)
		{
			defaulImage = (Texture2D)avatarImage.mainTexture;
			isFirstTimeSet = false;
		}
		if (nullTexture == null)
		{
			nullTexture = avatarImage.texture;
		}
		this.player = player;
		if (player == null)
		{
			base.enabled = true;
			avatarImage.texture = nullTexture;
			userName.text = "";
			coins.text = "";
			prize.text = "";
			state.enabled = false;
			if ((bool)isFriend)
			{
				isFriend.gameObject.SetActive(value: false);
			}
			waitingOpponent.gameObject.SetActive(value: true);
			return;
		}
		base.enabled = false;
		if ((bool)waitingOpponent)
		{
			waitingOpponent.gameObject.SetActive(value: false);
		}
		if ((bool)player.image)
		{
			avatarImage.texture = player.image;
		}
		else
		{
			player.SetImage(defaulImage);
			avatarImage.texture = defaulImage;
		}
		userName.text = player.userName;
		coins.text = string.Concat(player.coins);
		prize.text = string.Concat(player.prize);
		state.enabled = true;
		switch (player.state)
		{
		case PlayerState.Offline:
			state.color = Color.Lerp(Color.black, Color.white, 0.7f);
			break;
		case PlayerState.Online:
			state.color = Color.green;
			break;
		case PlayerState.Away:
			state.color = Color.yellow;
			break;
		case PlayerState.Busy:
			state.color = Color.red;
			break;
		case PlayerState.Playing:
			state.color = Color.blue;
			break;
		}
		if ((bool)isFriend)
		{
			isFriend.gameObject.SetActive(player.isFriend);
		}
	}

	[Obsolete]
	private IEnumerator DownloadAvatar()
	{
		yield break;
	}
}
public delegate void SelecButtonHandler(NetworkManagement.Pointer pointer);
public class Rotate : MonoBehaviour
{
	public float x;

	public float y;

	public float z;

	private void Update()
	{
		base.transform.Rotate(Vector3.right * Time.deltaTime * -55f * x);
		base.transform.Rotate(Vector3.up * Time.deltaTime * -55f * y);
		base.transform.Rotate(Vector3.forward * Time.deltaTime * -55f * z);
	}
}
public class RandAnimation : MonoBehaviour
{
	private Animator anim;

	public int MaxRandValue;

	public float randTime;

	private float currentTime;

	private void Start()
	{
		anim = GetComponent<Animator>();
	}

	private void Update()
	{
		RandAnim();
	}

	private void RandAnim()
	{
		currentTime += Time.deltaTime;
		if (currentTime >= randTime)
		{
			currentTime = 0f;
			int value = UnityEngine.Random.Range(0, MaxRandValue);
			anim.SetInteger("rand", value);
		}
	}
}
public static class ColorExtension
{
	public static Vector3 ConvertRgbToHsv(double r, double b, double g)
	{
		double num = 0.0;
		double num2 = Math.Min(Math.Min(r, g), b);
		double num3 = Math.Max(Math.Max(r, g), b);
		double num4 = num3 - num2;
		double num5 = ((!num3.Equals(0.0)) ? (num4 / num3) : 0.0);
		if (num5.Equals(0.0))
		{
			num = 360.0;
		}
		else
		{
			if (r.Equals(num3))
			{
				num = (g - b) / num4;
			}
			else if (g.Equals(num3))
			{
				num = 2.0 + (b - r) / num4;
			}
			else if (b.Equals(num3))
			{
				num = 4.0 + (r - g) / num4;
			}
			num *= 60.0;
			if (num <= 0.0)
			{
				num += 360.0;
			}
		}
		Vector3 result = default(Vector3);
		result.x = (float)(360.0 - num);
		result.y = (float)num5;
		result.z = (float)(num3 / 255.0);
		return result;
	}

	public static Color ConvertHsvToRgb(double h, double s, double v, float alpha)
	{
		double num;
		double num2;
		double num3;
		if (s.Equals(0.0))
		{
			num = v;
			num2 = v;
			num3 = v;
		}
		else
		{
			h = ((!h.Equals(360.0)) ? (h / 60.0) : 0.0);
			int num4 = (int)h;
			double num5 = h - (double)num4;
			double num6 = v * (1.0 - s);
			double num7 = v * (1.0 - s * num5);
			double num8 = v * (1.0 - s * (1.0 - num5));
			switch (num4)
			{
			case 0:
				num = v;
				num2 = num8;
				num3 = num6;
				break;
			case 1:
				num = num7;
				num2 = v;
				num3 = num6;
				break;
			case 2:
				num = num6;
				num2 = v;
				num3 = num8;
				break;
			case 3:
				num = num6;
				num2 = num7;
				num3 = v;
				break;
			case 4:
				num = num8;
				num2 = num6;
				num3 = v;
				break;
			default:
				num = v;
				num2 = num6;
				num3 = num7;
				break;
			}
		}
		return new Color((float)num, (float)num2, (float)num3, alpha);
	}
}
public static class CoroutineExtension
{
	public static IEnumerator WaitforTimeWhileCondition(this MonoBehaviour runner, float time, Func<bool> condition, Action<bool> onComplete = null)
	{
		bool passed = false;
		bool timeOver = false;
		runner.StartCoroutine(WaitForTime(time, delegate
		{
			passed = true;
			timeOver = true;
		}));
		runner.StartCoroutine(WaitWhileConditino(condition, delegate
		{
			passed = true;
		}));
		yield return new WaitUntil(() => passed);
		onComplete?.Invoke(!timeOver);
	}

	private static IEnumerator WaitForTime(float time, Action onComplete)
	{
		yield return YieldInstructionCache.WaitForSeconds(time);
		onComplete?.Invoke();
	}

	private static IEnumerator WaitWhileConditino(Func<bool> condition, Action onComplete)
	{
		yield return new WaitWhile(condition);
		onComplete?.Invoke();
	}

	public static IEnumerator Easy(float runtime, Action<float> onUpdate)
	{
		float t = 0f;
		while (t < runtime)
		{
			onUpdate?.Invoke(t / runtime);
			t += Time.deltaTime;
			yield return null;
		}
		onUpdate?.Invoke(1f);
	}
}
public class CoroutineWrapper
{
	private IEnumerator Target;

	public Action OnCompleteOnce { get; set; }

	public MonoBehaviour Runner { get; private set; }

	public Coroutine Routine { get; private set; }

	public bool IsPlaying => Routine != null;

	public static CoroutineWrapper Generate(MonoBehaviour runner)
	{
		return new CoroutineWrapper(runner);
	}

	public CoroutineWrapper(MonoBehaviour runner)
	{
		Runner = runner;
	}

	public CoroutineWrapper Start(IEnumerator target)
	{
		Target = target;
		Runner.StartCoroutine(RunTarget());
		return this;
	}

	public CoroutineWrapper StartSingleton(IEnumerator target)
	{
		if (Routine != null)
		{
			Stop();
		}
		return Start(target);
	}

	public CoroutineWrapper SetOnComplete(Action onComplete)
	{
		OnCompleteOnce = (Action)Delegate.Combine(OnCompleteOnce, onComplete);
		return this;
	}

	private IEnumerator RunTarget()
	{
		Routine = Runner.StartCoroutine(Target);
		yield return Routine;
		Routine = null;
		OnCompleteOnce?.Invoke();
		OnCompleteOnce = null;
	}

	public void Stop()
	{
		if (Routine != null)
		{
			Runner.StopCoroutine(Routine);
			Routine = null;
		}
	}
}
public class HapticTest : MonoBehaviour
{
	[SerializeField]
	private UnityEngine.XR.Interaction.Toolkit.XRController mainController;

	[SerializeField]
	private UnityEngine.XR.Interaction.Toolkit.XRController subController;

	private void Update()
	{
		InputDevice device = mainController.inputDevice;
		InputDevice device2 = subController.inputDevice;
		float threshold = mainController.axisToPressThreshold;
		DeviceControl(in device, in threshold);
		threshold = subController.axisToPressThreshold;
		DeviceControl(in device2, in threshold);
	}

	private void DeviceControl(in InputDevice device, in float threshold)
	{
		if (device.IsPressed(InputHelpers.Button.Trigger, out var isPressed, threshold) && isPressed)
		{
			TrySendHaptic(in device);
		}
	}

	private bool TrySendHaptic(in InputDevice device)
	{
		if (!device.TryGetHapticCapabilities(out var capabilities))
		{
			return false;
		}
		if (!capabilities.supportsImpulse)
		{
			return false;
		}
		device.SendHapticImpulse(0u, 1f * PublicGameUIManager.gameSetting.GetHapticValue());
		return true;
	}
}
public class SoundPlayTest : MonoBehaviour
{
	[SerializeField]
	private AudioSource Foul;

	[SerializeField]
	private AudioSource FreeBall;

	private Appnori.Util.Notifier<bool> isFoulPlaying = new Appnori.Util.Notifier<bool>();

	private CoroutineWrapper wrapper;

	private void Awake()
	{
		wrapper = CoroutineWrapper.Generate(this);
	}

	private void OnEnable()
	{
		Foul.Play();
		isFoulPlaying.CurrentData = true;
		StartCoroutine(WaitWhilePlay(Foul, delegate
		{
			isFoulPlaying.CurrentData = false;
		}));
		if (isFoulPlaying.CurrentData)
		{
			isFoulPlaying.OnDataChangedOnce += IsFoulPlaying_OnDataChangedOnce;
		}
		else
		{
			FreeBall.Play();
		}
	}

	private void IsFoulPlaying_OnDataChangedOnce(bool obj)
	{
		if (!obj)
		{
			FreeBall.Play();
		}
	}

	private IEnumerator WaitWhilePlay(AudioSource target, Action onComplete)
	{
		yield return new WaitWhile(() => target.isPlaying);
		onComplete?.Invoke();
	}
}
public class BoxLevelData : ScriptableObject
{
	[Header("Level Info")]
	[SerializeField]
	private TextAsset songData;

	[SerializeField]
	private AudioClip song;

	[SerializeField]
	private int bpm;

	[Header("Scene Environment Info")]
	public Color FogColor;

	public Cubemap cubemap;

	public Material SkyboxMaterial;

	public float ReflectionProbeIntensity;

	[Header("Game Environment Info")]
	public float RunRate;

	public TextAsset SongData => songData;

	public AudioClip Song => song;

	public int BPM => bpm;
}
[Serializable]
public class DataFormat
{
	public string _version;

	public List<DataEvent> _events;

	public List<DataNote> _notes;

	public List<DataObstacle> _obstacles;
}
[Serializable]
public class DataEvent
{
	public float _time;

	public int _type;

	public int _value;
}
[Serializable]
public class DataNote
{
	public float _time;

	public int _lineIndex;

	public int _lineLayer;

	public int _type;

	public int _cutDirection;
}
[Serializable]
public class DataObstacle
{
	public float _time;

	public float _duration;

	public int _type;

	public int _lineIndex;

	public int _width;
}
public class AchieveSlotCtrl : MonoBehaviour
{
	private Text text_title;

	private Text text_info;

	private Text text_progress;

	private Image image_fill;

	private RawImage image_icon;

	private int index = -10;

	private void Start()
	{
		text_title = base.transform.Find("Text_Title").GetComponent<Text>();
		text_info = base.transform.Find("Text_Info").GetComponent<Text>();
		text_progress = base.transform.Find("Text_Progress").GetComponent<Text>();
		image_fill = base.transform.Find("Image_Fill").GetComponent<Image>();
		image_icon = base.transform.Find("Image_Icon").GetComponent<RawImage>();
		SingletonBase.Singleton<LobbyUIManager>.GetInstance.achievement.SetInitSlot(this);
	}

	public void SetSlot(int _index, bool isInit)
	{
		if (!isInit && index == _index)
		{
			return;
		}
		index = _index;
		if (index < 0 || index >= SingletonBase.Singleton<LobbyUIManager>.GetInstance.achievement.achieves.Length)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		if (!base.gameObject.activeSelf)
		{
			base.gameObject.SetActive(value: true);
		}
		UserInfoManager.AchievementInfo achievementInfo = SingletonBase.Singleton<LobbyUIManager>.GetInstance.achievement.achieves[index];
		if (achievementInfo.is_archived)
		{
			text_title.text = "<color=#9DFF53>" + achievementInfo.title + "</color>";
			text_info.text = "<color=#FFFFFF>" + achievementInfo.unlocked_description_override + "</color>";
			image_fill.gameObject.SetActive(value: false);
			text_progress.gameObject.SetActive(value: false);
		}
		else
		{
			text_title.text = "<color=#969696>" + achievementInfo.title + "</color>";
			text_info.text = "<color=#C8C8C8>" + achievementInfo.description + "</color>";
			float num = 0f;
			if (achievementInfo.velue_target != 0)
			{
				num = (float)achievementInfo.velue_current / (float)achievementInfo.velue_target;
			}
			image_fill.fillAmount = Mathf.Clamp01(1f - num);
			text_progress.text = (num * 100f).ToString("F1") + "%";
			image_fill.gameObject.SetActive(value: true);
			text_progress.gameObject.SetActive(value: true);
		}
		SingletonBase.Singleton<UserInfoManager>.GetInstance.SetImage(achievementInfo.image_uri, image_icon);
		base.transform.localPosition = new Vector3(47.5f, (float)_index * -23.5f - 11.5f, 0f);
	}
}
public class AchievementCtrl : MonoBehaviour
{
	public UserInfoManager.AchievementInfo[] achieves;

	public RectTransform rect_content;

	public AchieveSlotCtrl[] achieveSlots;

	private bool isInit;

	private GameObject[] active_gos;

	private void Start()
	{
		isInit = false;
		active_gos = new GameObject[3];
		active_gos[0] = base.transform.Find("Board/Image_Disconnect").gameObject;
		active_gos[1] = base.transform.Find("Board/Image_Bar_Mine").gameObject;
		active_gos[2] = base.transform.Find("Board/Scroll View").gameObject;
		active_gos[0].SetActive(value: true);
		active_gos[1].SetActive(value: false);
		active_gos[2].SetActive(value: false);
	}

	public void SetInitSlot(AchieveSlotCtrl achieveSlot)
	{
		if (achieveSlots == null || achieveSlots.Length == 0)
		{
			achieveSlots = new AchieveSlotCtrl[6];
		}
		Transform parent = achieveSlot.transform.parent;
		for (int i = 0; i < parent.childCount; i++)
		{
			if (parent.GetChild(i) == achieveSlot.transform)
			{
				achieveSlots[i] = achieveSlot;
				break;
			}
		}
	}

	public IEnumerator SetAchieve()
	{
		while (achieveSlots == null || achieveSlots.Length == 0)
		{
			yield return null;
		}
		for (int i = 0; i < 6; i++)
		{
			while (achieveSlots[i] == null)
			{
				yield return null;
			}
		}
		while (SingletonBase.Singleton<UserInfoManager>.GetInstance.dict_achieve == null || SingletonBase.Singleton<UserInfoManager>.GetInstance.dict_achieve.Count == 0)
		{
			yield return null;
		}
		active_gos[0].SetActive(value: false);
		active_gos[1].SetActive(value: true);
		active_gos[2].SetActive(value: true);
		achieves = SingletonBase.Singleton<UserInfoManager>.GetInstance.dict_achieve.Values.ToArray();
		int num = 0;
		for (int j = 0; j < achieves.Length; j++)
		{
			if (achieves[j].is_archived)
			{
				num++;
			}
		}
		rect_content.sizeDelta = new Vector2(0f, 23.5f * (float)achieves.Length);
		rect_content.anchoredPosition = new Vector2(0f, 0f);
		for (int k = 0; k < achieveSlots.Length; k++)
		{
			achieveSlots[k].SetSlot(k, isInit: true);
		}
		base.transform.Find("Board/Image_Bar_Mine/Text_Progress01").GetComponent<Text>().text = num + " / " + achieves.Length;
		base.transform.Find("Board/Image_Bar_Mine/Text_Progress02").GetComponent<Text>().text = Mathf.RoundToInt(100f / (float)achieves.Length * (float)num) + "%";
		isInit = true;
	}

	private void Update()
	{
		if (isInit)
		{
			int num = (int)(rect_content.anchoredPosition.y / 23.5f);
			for (int i = 0; i < achieveSlots.Length; i++)
			{
				achieveSlots[Mathf.Abs(num % 6)].SetSlot(num, isInit: false);
				num++;
			}
		}
	}
}
public class AnimSyncCtrl : MonoBehaviour
{
	public GameData_DDOL.GameType gameType;

	public Animator anim_h;

	public Animator[] anim_g;

	private bool isPlay;

	private bool isCenter;

	private bool isMale;

	private void OnEnable()
	{
		SetAnim();
	}

	public void Init(bool _isMale)
	{
		isMale = _isMale;
		SetAnim();
	}

	private void SetAnim()
	{
		for (int i = 0; i < anim_g.Length; i++)
		{
			anim_g[i].SetBool("IsMale", isMale);
			anim_g[i].SetInteger("StateNum", (int)gameType);
			anim_g[i].SetTrigger("OnState");
			anim_g[i].SetBool("IsPlay", isPlay);
			anim_g[i].SetBool("IsCenter", isCenter);
		}
	}

	private void LateUpdate()
	{
		for (int i = 0; i < anim_g.Length; i++)
		{
			if (anim_h.GetBool("IsCenter"))
			{
				if (!isCenter)
				{
					if (i == anim_g.Length - 1)
					{
						isCenter = true;
					}
					anim_g[i].SetBool("IsCenter", value: true);
				}
			}
			else if (isCenter)
			{
				if (i == anim_g.Length - 1)
				{
					isCenter = false;
				}
				anim_g[i].SetBool("IsCenter", value: false);
			}
			if (anim_h.GetBool("IsPlay"))
			{
				if (!isPlay)
				{
					if (i == anim_g.Length - 1)
					{
						isPlay = true;
					}
					anim_g[i].SetBool("IsPlay", value: true);
				}
			}
			else if (isPlay)
			{
				if (i == anim_g.Length - 1)
				{
					isPlay = false;
				}
				anim_g[i].SetBool("IsPlay", value: false);
			}
			if (isPlay || isCenter)
			{
				anim_g[i].SetFloat("time", anim_h.GetCurrentAnimatorStateInfo(0).normalizedTime);
			}
		}
	}
}
public class AtlasPacker : MonoBehaviour
{
	public string savePath = "Assets/03. Individual Resources/Lee Jaeheung/Atlas/Lobby";

	public bool isNormalMap;

	public bool isGetChilds;

	public int texture_size = 8192;

	public int texture_padding;

	public void Create()
	{
	}

	private void CreateMesh(string setName, Mesh mesh_orizin, Rect rect)
	{
		GameObject obj = new GameObject(setName, typeof(MeshFilter), typeof(MeshRenderer));
		obj.transform.parent = base.transform;
		obj.transform.localPosition = Vector3.zero;
		obj.transform.localRotation = Quaternion.identity;
		MeshFilter component = obj.GetComponent<MeshFilter>();
		int[] triangles = mesh_orizin.GetTriangles(0);
		component.mesh = new Mesh();
		List<int> list = new List<int>();
		List<Vector3> list2 = new List<Vector3>();
		List<Color> list3 = new List<Color>();
		List<Vector3> list4 = new List<Vector3>();
		List<Vector4> list5 = new List<Vector4>();
		List<Vector2> list6 = new List<Vector2>();
		List<Vector2> list7 = new List<Vector2>();
		List<Vector2> list8 = new List<Vector2>();
		List<Vector2> list9 = new List<Vector2>();
		List<int> list10 = new List<int>();
		component.sharedMesh.Clear();
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < triangles.Length; i++)
		{
			num = triangles[i];
			int item;
			if (!list.Contains(num))
			{
				item = num2;
				list.Add(num);
				list2.Add(mesh_orizin.vertices[num]);
				if (mesh_orizin.colors != null && mesh_orizin.colors.Length > num)
				{
					list3.Add(mesh_orizin.colors[num]);
				}
				list4.Add(mesh_orizin.normals[num]);
				list5.Add(mesh_orizin.tangents[num]);
				if (mesh_orizin.uv != null && mesh_orizin.uv.Length > num)
				{
					list6.Add(new Vector2(mesh_orizin.uv[num].x * rect.width, mesh_orizin.uv[num].y * rect.height) + rect.position);
				}
				if (mesh_orizin.uv2 != null && mesh_orizin.uv2.Length > num)
				{
					list7.Add(new Vector2(mesh_orizin.uv2[num].x * rect.width, mesh_orizin.uv2[num].y * rect.height) + rect.position);
				}
				if (mesh_orizin.uv3 != null && mesh_orizin.uv3.Length > num)
				{
					list8.Add(new Vector2(mesh_orizin.uv3[num].x * rect.width, mesh_orizin.uv3[num].y * rect.height) + rect.position);
				}
				if (mesh_orizin.uv4 != null && mesh_orizin.uv4.Length > num)
				{
					list9.Add(new Vector2(mesh_orizin.uv4[num].x * rect.width, mesh_orizin.uv4[num].y * rect.height) + rect.position);
				}
				num2++;
			}
			else
			{
				item = list.IndexOf(num);
			}
			list10.Add(item);
		}
		component.sharedMesh.vertices = list2.ToArray();
		component.sharedMesh.triangles = list10.ToArray();
		component.sharedMesh.normals = list4.ToArray();
		component.sharedMesh.tangents = list5.ToArray();
		if (list6.Count > 0)
		{
			component.sharedMesh.uv = list6.ToArray();
		}
		if (list7.Count > 0)
		{
			component.sharedMesh.uv2 = list7.ToArray();
		}
		if (list8.Count > 0)
		{
			component.sharedMesh.uv3 = list8.ToArray();
		}
		if (list9.Count > 0)
		{
			component.sharedMesh.uv4 = list9.ToArray();
		}
		if (list3.Count > 0)
		{
			component.sharedMesh.colors = list3.ToArray();
		}
		component.sharedMesh.Optimize();
		component.sharedMesh.RecalculateBounds();
	}
}
public class BoxerCtrl : MonoBehaviour
{
	[Serializable]
	public struct Bone
	{
		public Transform orizin;

		public ConfigurableJoint ragdoll_joint;

		public Rigidbody ragdoll_rb;

		public int connect_num;

		public Quaternion startQ;
	}

	private enum State
	{
		Idle,
		Attack,
		Guard
	}

	public static BoxerCtrl instance;

	public Bone[] bones;

	private Animator anim;

	public Transform spine0Tr;

	public Transform spine1Tr;

	public Transform neckTr;

	public Transform clavicleLTr;

	public Transform clavicleRTr;

	public Transform eyeL;

	public Transform eyeR;

	private Quaternion[] recoveryQ;

	private Vector3 recoveryP;

	private Quaternion headForce;

	private Vector3 bodyForce;

	public AnimationCurve bodyDamageCurve;

	private float bodyDamageTime;

	private float physicsWeight;

	private float physicsWeight_armL;

	private float physicsWeight_armR;

	public AnimationCurve damageRecoveryCurve;

	private bool isUpdateBone;

	public bool isGuard;

	private float eyeHeight = 1.68f;

	public Transform lookPoint_eye;

	public Transform lookPoint_head;

	public Transform lookPoint_body;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		anim = base.transform.GetComponent<Animator>();
		JointDrive slerpDrive = default(JointDrive);
		slerpDrive.positionSpring = 500f;
		slerpDrive.positionDamper = 10f;
		slerpDrive.maximumForce = 500f;
		for (int i = 0; i < bones.Length; i++)
		{
			bones[i].ragdoll_joint.slerpDrive = slerpDrive;
			bones[i].ragdoll_joint.autoConfigureConnectedAnchor = false;
			if (bones[i].ragdoll_joint.connectedBody == null)
			{
				bones[i].connect_num = -1;
				continue;
			}
			for (int j = 0; j < i; j++)
			{
				if (bones[i].ragdoll_joint.connectedBody.name == bones[j].orizin.name)
				{
					bones[i].connect_num = j;
					Quaternion startQ = Quaternion.Inverse(bones[bones[i].connect_num].orizin.transform.rotation) * bones[i].orizin.rotation;
					bones[i].startQ = startQ;
					break;
				}
			}
		}
		recoveryQ = new Quaternion[bones.Length];
		MeshRenderer[] componentsInChildren = bones[0].ragdoll_rb.transform.parent.GetComponentsInChildren<MeshRenderer>();
		for (int k = 0; k < componentsInChildren.Length; k++)
		{
			componentsInChildren[k].enabled = false;
		}
		StartCoroutine(UpdateBoneRecovery());
	}

	public void SetDamage(int stateNum, Vector3 veloc)
	{
		if (!isGuard)
		{
			physicsWeight_armL = 0f;
			physicsWeight_armR = 0f;
		}
		Vector3 vector = veloc;
		if (vector.magnitude > 5f)
		{
			vector = vector.normalized * 5f;
		}
		switch (stateNum)
		{
		case 0:
			bones[11].ragdoll_rb.velocity = vector * 3.5f;
			vector = base.transform.InverseTransformDirection(-vector);
			vector.x *= 35f;
			vector.z += 0.0001f;
			if (Mathf.Abs(vector.y) > Mathf.Abs(vector.z))
			{
				vector.z = 0f - vector.y;
			}
			vector.z *= Mathf.Lerp(10f, 20f, Mathf.Abs(vector.y) / (Mathf.Abs(vector.y) + Mathf.Abs(vector.z)));
			headForce = Quaternion.Euler(vector);
			physicsWeight = 1f;
			break;
		case 1:
			bones[7].ragdoll_rb.velocity = -vector * 1f;
			bones[11].ragdoll_rb.velocity = -vector * 1f;
			bodyForce = vector * 0.01f * 5f;
			bodyDamageTime = 0f;
			physicsWeight = 1f;
			break;
		case 2:
			bones[7].ragdoll_rb.velocity = vector * 3f;
			bones[11].ragdoll_rb.velocity = -vector * 2f;
			physicsWeight = 1f;
			break;
		case 3:
			bones[8].ragdoll_rb.velocity = vector * 1f;
			bones[11].ragdoll_rb.velocity = -vector * 1f;
			physicsWeight = 1f;
			break;
		case 4:
			bones[12].ragdoll_rb.velocity = vector * 1f;
			bones[11].ragdoll_rb.velocity = -vector * 1f;
			physicsWeight = 1f;
			break;
		case 5:
			bones[7].ragdoll_rb.velocity = vector * 3f;
			physicsWeight = 1f;
			break;
		case 6:
			bones[7].ragdoll_rb.velocity = -vector * 1f;
			bones[11].ragdoll_rb.velocity = -vector * 1f;
			bodyForce = vector * 0.01f * 3f;
			bodyDamageTime = 0f;
			physicsWeight = 1f;
			break;
		}
	}

	public void SetArmWeight(bool isRight)
	{
		if (isRight)
		{
			physicsWeight_armR = 1f;
		}
		else
		{
			physicsWeight_armL = 1f;
		}
	}

	private void DelayForce_Head()
	{
		SetDamage(0, Vector3.right * 5f);
	}

	private void DelayForce1_Head()
	{
		bones[11].ragdoll_rb.velocity = -base.transform.forward * 15f;
		headForce = Quaternion.Euler(Vector3.forward * 50f);
		physicsWeight = 1f;
	}

	private void DelayForce2_Head()
	{
		bones[11].ragdoll_rb.velocity = -base.transform.right * 15f;
		headForce = Quaternion.Euler(Vector3.right * 150f);
		physicsWeight = 1f;
	}

	private void DelayForce3_Head()
	{
		bones[11].ragdoll_rb.velocity = base.transform.right * 15f;
		headForce = Quaternion.Euler(-Vector3.right * 120f);
		physicsWeight = 1f;
	}

	private void DelayForce5_Head()
	{
		bones[7].ragdoll_rb.velocity = (base.transform.up * 2f + -base.transform.forward * 1f).normalized * 5f;
		bones[11].ragdoll_rb.velocity = base.transform.up * 10f;
		headForce = Quaternion.Euler(Vector3.forward * 100f);
		physicsWeight = 1f;
	}

	private void DelayForce1_Body()
	{
		bones[7].ragdoll_rb.velocity = base.transform.forward * 5f;
		bones[11].ragdoll_rb.velocity = base.transform.forward * 5f;
		bodyForce = (-base.transform.forward * 0.01f + -base.transform.up * 0.01f) * 15f;
		bodyDamageTime = 0f;
		physicsWeight = 1f;
	}

	private void DelayForce2_Body()
	{
		bones[7].ragdoll_rb.velocity = base.transform.right * 5f;
		bones[11].ragdoll_rb.velocity = base.transform.right * 5f;
		bodyForce = (-base.transform.right * 0.01f + -base.transform.up * 0.01f) * 15f;
		bodyDamageTime = 0f;
		physicsWeight = 1f;
	}

	private void DelayForce3_Body()
	{
		bones[7].ragdoll_rb.velocity = -base.transform.right * 5f;
		bones[11].ragdoll_rb.velocity = -base.transform.right * 5f;
		bodyForce = (base.transform.right * 0.01f + -base.transform.up * 0.01f) * 15f;
		bodyDamageTime = 0f;
		physicsWeight = 1f;
	}

	private void FixedUpdate()
	{
		bones[0].ragdoll_rb.velocity = Vector3.zero;
		bones[0].ragdoll_rb.angularVelocity = Vector3.zero;
		headForce = Quaternion.Lerp(headForce, Quaternion.identity, Time.fixedDeltaTime * 5f);
		bodyDamageTime = Mathf.Clamp01(bodyDamageTime + Time.fixedDeltaTime * 1.5f);
		Vector3 vector = Vector3.Lerp(Vector3.zero, bodyForce, bodyDamageCurve.Evaluate(bodyDamageTime));
		bones[0].ragdoll_rb.MovePosition(bones[0].orizin.position + vector);
		bones[0].ragdoll_rb.MoveRotation(bones[0].orizin.rotation);
		physicsWeight = Mathf.Clamp01(physicsWeight - Time.fixedDeltaTime * 0.5f);
		physicsWeight_armL = Mathf.Clamp01(physicsWeight_armL - Time.fixedDeltaTime * 0.5f);
		physicsWeight_armR = Mathf.Clamp01(physicsWeight_armR - Time.fixedDeltaTime * 0.5f);
		Quaternion identity = Quaternion.identity;
		for (int i = 1; i < bones.Length; i++)
		{
			switch (i)
			{
			case 8:
			case 9:
			case 10:
				identity = Quaternion.Lerp(bones[i].orizin.transform.rotation, bones[i].ragdoll_rb.transform.rotation, damageRecoveryCurve.Evaluate(physicsWeight_armL));
				break;
			case 12:
			case 13:
			case 14:
				identity = Quaternion.Lerp(bones[i].orizin.transform.rotation, bones[i].ragdoll_rb.transform.rotation, damageRecoveryCurve.Evaluate(physicsWeight_armR));
				break;
			default:
				identity = Quaternion.Lerp(bones[i].orizin.transform.rotation, bones[i].ragdoll_rb.transform.rotation, damageRecoveryCurve.Evaluate(physicsWeight));
				break;
			}
			bones[i].ragdoll_rb.MoveRotation(identity);
			switch (i)
			{
			case 7:
				bones[i].ragdoll_joint.anchor = bones[i].orizin.InverseTransformPoint(spine1Tr.position);
				bones[i].ragdoll_joint.connectedAnchor = bones[0].orizin.InverseTransformPoint(spine1Tr.position);
				break;
			case 8:
				bones[i].ragdoll_joint.anchor = bones[i].orizin.InverseTransformPoint(clavicleLTr.position);
				bones[i].ragdoll_joint.connectedAnchor = bones[7].orizin.InverseTransformPoint(clavicleLTr.position);
				break;
			case 11:
				bones[i].ragdoll_joint.anchor = bones[i].orizin.InverseTransformPoint(neckTr.position);
				bones[i].ragdoll_joint.connectedAnchor = bones[7].orizin.InverseTransformPoint(neckTr.position);
				break;
			case 12:
				bones[i].ragdoll_joint.anchor = bones[i].orizin.InverseTransformPoint(clavicleRTr.position);
				bones[i].ragdoll_joint.connectedAnchor = bones[7].orizin.InverseTransformPoint(clavicleRTr.position);
				break;
			default:
				bones[i].ragdoll_joint.connectedAnchor = bones[i].orizin.parent.InverseTransformPoint(bones[i].orizin.transform.position);
				break;
			}
			if (i == 11)
			{
				identity = Quaternion.Inverse(bones[bones[i].connect_num].orizin.transform.rotation) * bones[i].orizin.rotation * headForce;
				bones[i].ragdoll_joint.targetRotation = Quaternion.Inverse(identity) * bones[i].startQ;
			}
			else
			{
				identity = Quaternion.Inverse(bones[bones[i].connect_num].orizin.transform.rotation) * bones[i].orizin.rotation;
				bones[i].ragdoll_joint.targetRotation = Quaternion.Inverse(identity) * bones[i].startQ;
			}
		}
	}

	private void Update()
	{
		isUpdateBone = true;
		Vector3 position = bones[1].orizin.position;
		Vector3 position2 = bones[2].orizin.position;
		Vector3 position3 = bones[3].orizin.position;
		Vector3 vector = bones[0].ragdoll_rb.transform.position + (position - bones[0].orizin.position);
		Vector3 vector2 = position3 - position;
		float num = (position2 - position).magnitude + (position3 - position2).magnitude;
		float num2 = (position2 - position).magnitude / num;
		Vector3 vector3 = position + vector2 * num2;
		Vector3 vector4 = vector3 - position;
		Vector3 vector5 = position2 - position;
		Mathf.Sqrt(vector5.sqrMagnitude - vector4.sqrMagnitude);
		Vector3 normalized = (position2 - vector3).normalized;
		Vector3 vector6 = position3 - vector;
		if (vector6.magnitude > num)
		{
			vector6 = vector6.normalized * num;
		}
		Vector3 vector7 = vector + vector6 * num2;
		Vector3 vector8 = vector3 - vector;
		float num3 = vector5.sqrMagnitude - vector8.sqrMagnitude + 0.01f;
		num3 = ((!(num3 > 0f)) ? 0f : Mathf.Sqrt(num3));
		Vector3 vector9 = vector7 + normalized * num3;
		Vector3 vector10 = position3;
		Quaternion rotation = bones[3].orizin.rotation;
		position = bones[4].orizin.position;
		position2 = bones[5].orizin.position;
		position3 = bones[6].orizin.position;
		Vector3 vector11 = bones[0].ragdoll_rb.transform.position + (position - bones[0].orizin.position);
		vector2 = position3 - position;
		num = (position2 - position).magnitude + (position3 - position2).magnitude;
		num2 = (position2 - position).magnitude / num;
		vector3 = position + vector2 * num2;
		vector4 = vector3 - position;
		vector5 = position2 - position;
		Mathf.Sqrt(vector5.sqrMagnitude - vector4.sqrMagnitude);
		Vector3 normalized2 = (position2 - vector3).normalized;
		Vector3 vector12 = position3 - vector11;
		if (vector12.magnitude > num)
		{
			vector12 = vector12.normalized * num;
		}
		Vector3 vector13 = vector11 + vector12 * num2;
		vector8 = vector3 - vector11;
		num3 = vector5.sqrMagnitude - vector8.sqrMagnitude + 0.01f;
		num3 = ((!(num3 > 0f)) ? 0f : Mathf.Sqrt(num3));
		Vector3 vector14 = vector13 + normalized2 * num3;
		Vector3 vector15 = position3;
		Quaternion rotation2 = bones[6].orizin.rotation;
		recoveryP = bones[0].orizin.localPosition;
		recoveryQ[0] = bones[0].orizin.localRotation;
		bones[0].orizin.position = bones[0].ragdoll_rb.transform.position;
		bones[0].orizin.rotation = bones[0].ragdoll_rb.transform.rotation;
		for (int i = 1; i < bones.Length; i++)
		{
			if (i == 7)
			{
				recoveryQ[i] = spine1Tr.localRotation;
				spine1Tr.rotation = bones[i].ragdoll_rb.transform.rotation;
			}
			else
			{
				recoveryQ[i] = bones[i].orizin.localRotation;
				bones[i].orizin.rotation = bones[i].ragdoll_rb.transform.rotation;
			}
		}
		Vector3 vector16 = Vector3.Cross(-vector6.normalized, normalized);
		bones[1].orizin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector9 - vector).normalized));
		bones[2].orizin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector10 - vector9).normalized));
		bones[3].orizin.rotation = rotation;
		vector16 = Vector3.Cross(-vector12.normalized, normalized2);
		bones[4].orizin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector14 - vector11).normalized));
		bones[5].orizin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector15 - vector14).normalized));
		bones[6].orizin.rotation = rotation2;
		if (Vector3.Dot(bones[11].orizin.up, (lookPoint_eye.position - eyeL.position).normalized) >= 0.71f && Vector3.Dot(bones[11].orizin.up, (lookPoint_eye.position - eyeR.position).normalized) >= 0.71f)
		{
			eyeL.rotation = Quaternion.Slerp(eyeL.rotation, Quaternion.LookRotation(lookPoint_eye.position - eyeL.position), Time.deltaTime * 10f);
			eyeR.rotation = Quaternion.Slerp(eyeR.rotation, Quaternion.LookRotation(lookPoint_eye.position - eyeR.position), Time.deltaTime * 10f);
		}
	}

	private IEnumerator UpdateBoneRecovery()
	{
		while (true)
		{
			yield return new WaitForEndOfFrame();
			if (!isUpdateBone)
			{
				continue;
			}
			isUpdateBone = false;
			bones[0].orizin.localPosition = recoveryP;
			bones[0].orizin.localRotation = recoveryQ[0];
			for (int i = 1; i < bones.Length; i++)
			{
				if (i == 7)
				{
					spine1Tr.localRotation = recoveryQ[i];
				}
				else
				{
					bones[i].orizin.localRotation = recoveryQ[i];
				}
			}
		}
	}

	public void SetGuard(bool isGuard)
	{
		this.isGuard = isGuard;
		anim.SetBool("isGuard", isGuard);
	}

	public void SetAttack()
	{
		anim.SetTrigger("onAttack");
	}
}
public class CheckEventSystem : MonoBehaviour
{
	private EventSystem eventSystem;

	private GameObject currentSelected;

	private Slider slider;

	private Scrollbar scrollbar;

	private void Start()
	{
		eventSystem = base.transform.GetComponent<EventSystem>();
	}

	private void Update()
	{
		if (eventSystem.currentSelectedGameObject == currentSelected)
		{
			return;
		}
		currentSelected = eventSystem.currentSelectedGameObject;
		if (!(currentSelected == null))
		{
			if (currentSelected.TryGetComponent<Slider>(out slider))
			{
				eventSystem.pixelDragThreshold = 0;
			}
			else if (currentSelected.TryGetComponent<Scrollbar>(out scrollbar))
			{
				eventSystem.pixelDragThreshold = 0;
			}
			else
			{
				eventSystem.pixelDragThreshold = 30;
			}
		}
	}
}
public enum ColorUIPart
{
	Skin,
	Eye,
	Eyebrow,
	Hair,
	Upper,
	Lower,
	Foot,
	Pattern,
	Acc
}
public class ColorPaletteCtrl : MonoBehaviour
{
	private ButtonRatio buttonRatio;

	public Color colorVelue;

	public string hexColor;

	public ColorUIPart color_part;

	public LayerMask layerMask;

	private float halfExtents;

	private float ray_dist;

	private Vector3 center;

	public MeshRenderer renderer_palette;

	public Transform transform_h;

	public TextMesh text_h;

	public MeshRenderer renderer_h;

	public Transform transform_sv;

	public TextMesh text_sv;

	public MeshRenderer renderer_sv;

	private float colorSumVelue;

	private float colorMulVelue;

	private Vector3 hsv = new Vector3(0.5f, 0.5f, 0.5f);

	private Vector3 keep_hsv = new Vector3(0.5f, 0.5f, 0.5f);

	public MeshButtonCtrl[] buttons_part;

	private float delayTIme_sound;

	private void Start()
	{
		BoxCollider component = base.transform.GetComponent<BoxCollider>();
		center = base.transform.TransformPoint(component.center);
		Vector3 size = component.size;
		colorSumVelue = size.y * 0.5f;
		colorMulVelue = 1f / size.y;
		if (Mathf.Abs(size.x - size.y) >= 0.001f)
		{
			if (size.x - size.y < 0f)
			{
				buttonRatio = ButtonRatio.Height;
				halfExtents = size.x * 0.5f;
				ray_dist = (size.y - size.x) * 0.5f;
			}
			else
			{
				buttonRatio = ButtonRatio.Width;
				halfExtents = size.y * 0.5f;
				ray_dist = (size.x - size.y) * 0.5f;
			}
		}
		else
		{
			buttonRatio = ButtonRatio.Square;
			halfExtents = size.x * 0.5f;
		}
		SingletonBase.Singleton<CustomizeManager>.GetInstance.InitColorSlot(this);
	}

	private void Update()
	{
		if (delayTIme_sound > 0f)
		{
			delayTIme_sound -= Time.deltaTime;
		}
	}

	public void SetSlot()
	{
		string colorInfo = SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(color_part);
		if (!ColorUtility.TryParseHtmlString("#" + colorInfo, out colorVelue))
		{
			return;
		}
		Color.RGBToHSV(colorVelue, out hsv.x, out hsv.y, out hsv.z);
		transform_h.localPosition = new Vector3(0f, (1f - hsv.x) / colorMulVelue - colorSumVelue, 0f);
		transform_sv.localPosition = new Vector3((1f - hsv.y) / colorMulVelue - colorSumVelue, hsv.z / colorMulVelue - colorSumVelue, 0f);
		keep_hsv = hsv;
		renderer_h.material.SetColor("_Color", Color.HSVToRGB(hsv.x, 1f, 1f));
		renderer_sv.material.SetColor("_Color", colorVelue);
		renderer_palette.material.SetFloat("_Hue", hsv.x);
		text_h.text = $"H : {hsv.x:F2}";
		text_sv.text = $"S : {hsv.y:F2} / V : {hsv.z:F2}";
		switch (color_part)
		{
		case ColorUIPart.Skin:
		{
			for (int j = 0; j < buttons_part.Length; j++)
			{
				if (j == 0)
				{
					buttons_part[j].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[j].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[j].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[j].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Eye:
		{
			for (int n = 0; n < buttons_part.Length; n++)
			{
				if (n == 1)
				{
					buttons_part[n].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[n].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[n].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[n].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Eyebrow:
		{
			for (int num2 = 0; num2 < buttons_part.Length; num2++)
			{
				if (num2 == 2)
				{
					buttons_part[num2].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[num2].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[num2].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[num2].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Hair:
		{
			for (int l = 0; l < buttons_part.Length; l++)
			{
				if (l == 3)
				{
					buttons_part[l].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[l].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[l].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[l].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Upper:
		{
			for (int num3 = 0; num3 < buttons_part.Length; num3++)
			{
				if (num3 == 4)
				{
					buttons_part[num3].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[num3].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[num3].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[num3].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Lower:
		{
			for (int num = 0; num < buttons_part.Length; num++)
			{
				if (num == 5)
				{
					buttons_part[num].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[num].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[num].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[num].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Foot:
		{
			for (int m = 0; m < buttons_part.Length; m++)
			{
				if (m == 6)
				{
					buttons_part[m].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[m].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[m].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[m].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Pattern:
		{
			for (int k = 0; k < buttons_part.Length; k++)
			{
				if (k == 7)
				{
					buttons_part[k].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[k].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[k].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[k].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		case ColorUIPart.Acc:
		{
			for (int i = 0; i < buttons_part.Length; i++)
			{
				if (i == 8)
				{
					buttons_part[i].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[1]);
					buttons_part[i].SetInteractable(_isInteractable: false);
				}
				else
				{
					buttons_part[i].SetMaterial(SingletonBase.Singleton<CustomizeManager>.GetInstance.materials_customUI[0]);
					buttons_part[i].SetInteractable(_isInteractable: true);
				}
			}
			break;
		}
		}
	}

	private void OnTriggerStay(Collider other)
	{
		RaycastHit hitInfo = default(RaycastHit);
		RaycastHit hitInfo2 = default(RaycastHit);
		bool flag = false;
		bool flag2 = false;
		switch (buttonRatio)
		{
		case ButtonRatio.Square:
			flag = Physics.BoxCast(center + base.transform.forward * -1f, Vector3.one * halfExtents, base.transform.forward, out hitInfo, base.transform.rotation, 2f, layerMask);
			break;
		case ButtonRatio.Height:
			flag = Physics.BoxCast(center + base.transform.forward * -1f + base.transform.up * (0f - ray_dist), Vector3.one * halfExtents, base.transform.forward, out hitInfo, base.transform.rotation, 2f, layerMask);
			flag2 = Physics.BoxCast(center + base.transform.forward * -1f + base.transform.up * ray_dist, Vector3.one * halfExtents, base.transform.forward, out hitInfo2, base.transform.rotation, 2f, layerMask);
			break;
		case ButtonRatio.Width:
			flag = Physics.BoxCast(center + base.transform.forward * -1f + base.transform.right * (0f - ray_dist), Vector3.one * halfExtents, base.transform.forward, out hitInfo, base.transform.rotation, 2f, layerMask);
			flag2 = Physics.BoxCast(center + base.transform.forward * -1f + base.transform.right * ray_dist, Vector3.one * halfExtents, base.transform.forward, out hitInfo2, base.transform.rotation, 2f, layerMask);
			break;
		}
		if (!(flag || flag2))
		{
			return;
		}
		Vector3 localPosition;
		if (buttonRatio == ButtonRatio.Square)
		{
			localPosition = base.transform.InverseTransformPoint(hitInfo.point);
		}
		else
		{
			Vector3 vector = base.transform.InverseTransformPoint(hitInfo.point);
			Vector3 vector2 = base.transform.InverseTransformPoint(hitInfo2.point);
			localPosition = ((!flag2) ? vector : (flag ? ((vector.z < vector2.z) ? vector : vector2) : vector2));
		}
		if (localPosition.z > 0f || (localPosition.x > 0.11f && localPosition.x < 0.14f))
		{
			return;
		}
		localPosition.z = 0f;
		if (localPosition.x > 0.125f)
		{
			localPosition.x = 0f;
			transform_h.localPosition = localPosition;
			hsv.x = 1f - Mathf.Clamp01((transform_h.localPosition.y + colorSumVelue) * colorMulVelue);
			if (Mathf.Abs(keep_hsv.x - hsv.x) >= 0.05f && delayTIme_sound <= 0f)
			{
				delayTIme_sound = 0.05f;
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
				keep_hsv.x = hsv.x;
			}
			Color color = Color.HSVToRGB(hsv.x, hsv.y, hsv.z);
			renderer_h.material.SetColor("_Color", Color.HSVToRGB(hsv.x, 1f, 1f));
			renderer_sv.material.SetColor("_Color", color);
			renderer_palette.material.SetFloat("_Hue", hsv.x);
			text_h.text = $"H : {hsv.x:F2}";
			SingletonBase.Singleton<CustomizeManager>.GetInstance.characterCtrl.SetColor(color_part, ColorUtility.ToHtmlStringRGB(color));
		}
		else
		{
			transform_sv.localPosition = localPosition;
			hsv.y = 1f - Mathf.Clamp01((transform_sv.localPosition.x + colorSumVelue) * colorMulVelue);
			hsv.z = Mathf.Clamp01((transform_sv.localPosition.y + colorSumVelue) * colorMulVelue);
			if ((new Vector2(keep_hsv.y, keep_hsv.z) - new Vector2(hsv.y, hsv.z)).sqrMagnitude >= 0.005f && delayTIme_sound <= 0f)
			{
				delayTIme_sound = 0.05f;
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
				keep_hsv.y = hsv.y;
				keep_hsv.z = hsv.z;
			}
			Color color2 = Color.HSVToRGB(hsv.x, hsv.y, hsv.z);
			renderer_sv.material.SetColor("_Color", color2);
			text_sv.text = $"S : {hsv.y:F2} / V : {hsv.z:F2}";
			SingletonBase.Singleton<CustomizeManager>.GetInstance.characterCtrl.SetColor(color_part, ColorUtility.ToHtmlStringRGB(color2));
		}
	}

	public int GetPaletteState(Vector3 point)
	{
		Vector3 vector = base.transform.InverseTransformPoint(point);
		if (vector.x > 0.11f && vector.x < 0.14f)
		{
			return -1;
		}
		if (vector.x > 0.125f)
		{
			return 1;
		}
		return 2;
	}

	public void Click_Palette(bool isHue, Vector3 point)
	{
		Vector3 localPosition = base.transform.InverseTransformPoint(point);
		localPosition.z = 0f;
		if (isHue)
		{
			localPosition.x = 0f;
			transform_h.localPosition = localPosition;
			hsv.x = 1f - Mathf.Clamp01((transform_h.localPosition.y + colorSumVelue) * colorMulVelue);
			transform_h.localPosition = new Vector3(0f, (1f - hsv.x) / colorMulVelue - colorSumVelue, 0f);
			if (Mathf.Abs(keep_hsv.x - hsv.x) >= 0.05f && delayTIme_sound <= 0f)
			{
				delayTIme_sound = 0.05f;
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
				keep_hsv.x = hsv.x;
			}
			Color color = Color.HSVToRGB(hsv.x, hsv.y, hsv.z);
			renderer_h.material.SetColor("_Color", Color.HSVToRGB(hsv.x, 1f, 1f));
			renderer_sv.material.SetColor("_Color", color);
			renderer_palette.material.SetFloat("_Hue", hsv.x);
			text_h.text = $"H : {hsv.x:F2}";
			SingletonBase.Singleton<CustomizeManager>.GetInstance.characterCtrl.SetColor(color_part, ColorUtility.ToHtmlStringRGB(color));
		}
		else
		{
			transform_sv.localPosition = localPosition;
			hsv.y = 1f - Mathf.Clamp01((transform_sv.localPosition.x + colorSumVelue) * colorMulVelue);
			hsv.z = Mathf.Clamp01((transform_sv.localPosition.y + colorSumVelue) * colorMulVelue);
			transform_sv.localPosition = new Vector3((1f - hsv.y) / colorMulVelue - colorSumVelue, hsv.z / colorMulVelue - colorSumVelue, 0f);
			if ((new Vector2(keep_hsv.y, keep_hsv.z) - new Vector2(hsv.y, hsv.z)).sqrMagnitude >= 0.005f && delayTIme_sound <= 0f)
			{
				delayTIme_sound = 0.05f;
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
				keep_hsv.y = hsv.y;
				keep_hsv.z = hsv.z;
			}
			Color color2 = Color.HSVToRGB(hsv.x, hsv.y, hsv.z);
			renderer_sv.material.SetColor("_Color", color2);
			text_sv.text = $"S : {hsv.y:F2} / V : {hsv.z:F2}";
			SingletonBase.Singleton<CustomizeManager>.GetInstance.characterCtrl.SetColor(color_part, ColorUtility.ToHtmlStringRGB(color2));
		}
	}

	public void Click_InputKey(string key)
	{
		SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(3);
		switch (key)
		{
		case "Skin":
			color_part = ColorUIPart.Skin;
			break;
		case "Eye":
			color_part = ColorUIPart.Eye;
			break;
		case "Eyebrow":
			color_part = ColorUIPart.Eyebrow;
			break;
		case "Hair":
			color_part = ColorUIPart.Hair;
			break;
		case "Upper":
			color_part = ColorUIPart.Upper;
			break;
		case "Lower":
			color_part = ColorUIPart.Lower;
			break;
		case "Foot":
			color_part = ColorUIPart.Foot;
			break;
		case "Pattern":
			color_part = ColorUIPart.Pattern;
			break;
		case "Acc":
			color_part = ColorUIPart.Acc;
			break;
		}
		SetSlot();
	}

	public void CreateColorPalette()
	{
		Texture2D texture2D = new Texture2D(16, 256);
		for (int i = 0; i < texture2D.width; i++)
		{
			for (int j = 0; j < texture2D.height; j++)
			{
				texture2D.SetPixel(i, j, Color.HSVToRGB(1f - (float)j / ((float)texture2D.height - 1f), 1f, 1f));
			}
		}
		File.WriteAllBytes("Assets/03. Individual Resources/Lee Jaeheung/Images/Image_ColorPalette_H.png", texture2D.EncodeToPNG());
	}
}
[Serializable]
public class CustomModelData
{
	public string Gender;

	public string ID_Face_I;

	public string Hex_Skin_C;

	public string Hex_Eye_C;

	public string Hex_Eyebrow_C;

	public string ID_Hair_I;

	public string Hex_Hair_C;

	public string ID_Wear_I;

	public string Hex_Upper_C;

	public string Hex_Lower_C;

	public string Hex_Foot_C;

	public string Hex_Pattern_C;

	public string Hex_Acc_C;

	public string ID_Acc_I;
}
public enum CustomModelViewState
{
	Normal,
	HandCut,
	HalfCut,
	HalfCut2
}
public class CustomModelSettingCtrl : MonoBehaviour
{
	public class BindPoseInfo
	{
		public int boneNum_origin;

		public int[] boneNums;

		public int index;
	}

	private string user_id;

	private CustomModelViewState state;

	private Renderer renderer_hand;

	private CustomModelData modelData;

	private float toneVelue = 0.5f;

	private bool isOptimizeGameObjects;

	private List<MeshRenderer> list_meshRenderer = new List<MeshRenderer>();

	private List<SkinnedMeshRenderer> list_skinnedMesh = new List<SkinnedMeshRenderer>();

	private List<int[]> list_boneInfos = new List<int[]>();

	public bool isCombinedMesh;

	public int texture_size = 8192;

	public int texture_padding;

	private Transform[] boneTrs = new Transform[59];

	public void Init(string _user_id, CustomModelViewState _state = CustomModelViewState.Normal, Renderer _renderer_hand = null, float _toneVelue = 0.5f)
	{
		if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id == _user_id)
		{
			Init(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(0), _state, _renderer_hand, _toneVelue);
			return;
		}
		if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id == _user_id)
		{
			Init(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(1), _state, _renderer_hand, _toneVelue);
			return;
		}
		user_id = _user_id;
		state = _state;
		renderer_hand = _renderer_hand;
		toneVelue = _toneVelue;
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.StartDownloadUserData(this, user_id);
	}

	public void Init(CustomModelData _modelData, CustomModelViewState _state = CustomModelViewState.Normal, Renderer _renderer_hand = null, float _toneVelue = 0.5f)
	{
		modelData = _modelData;
		state = _state;
		renderer_hand = _renderer_hand;
		toneVelue = _toneVelue;
		SetMedel();
	}

	public void InitRandom(CustomModelViewState _state = CustomModelViewState.Normal, Renderer _renderer_hand = null, float _toneVelue = 0.5f)
	{
		user_id = "";
		state = _state;
		renderer_hand = _renderer_hand;
		toneVelue = _toneVelue;
		modelData = GetRandomModelData();
		SetMedel();
	}

	public void InitRandom(int genderNum, CustomModelViewState _state = CustomModelViewState.Normal, Renderer _renderer_hand = null, float _toneVelue = 0.5f)
	{
		user_id = "";
		state = _state;
		renderer_hand = _renderer_hand;
		toneVelue = _toneVelue;
		modelData = GetRandomModelData(genderNum);
		SetMedel();
	}

	public void InitCPU(CustomModelViewState _state = CustomModelViewState.Normal, Renderer _renderer_hand = null, float _toneVelue = 0.5f)
	{
		modelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(1);
		if (modelData == null)
		{
			InitRandom(_state, _renderer_hand, _toneVelue);
			return;
		}
		user_id = "";
		state = _state;
		renderer_hand = _renderer_hand;
		toneVelue = _toneVelue;
		SetMedel();
	}

	public static CustomModelData GetRandomModelData(int genderNum = -1)
	{
		CustomModelData customModelData = new CustomModelData();
		switch (genderNum)
		{
		case 0:
			customModelData.Gender = "m";
			break;
		case 1:
			customModelData.Gender = "f";
			break;
		case -1:
			customModelData.Gender = ((UnityEngine.Random.Range(0f, 1f) >= 0.5f) ? "m" : "f");
			break;
		}
		customModelData.ID_Face_I = ((int)UnityEngine.Random.Range(1000f, 1008.9999f)).ToString();
		customModelData.ID_Hair_I = ((int)UnityEngine.Random.Range(2000f, 2008.9999f)).ToString();
		customModelData.ID_Wear_I = ((int)UnityEngine.Random.Range(3000f, 3009f)).ToString();
		customModelData.ID_Acc_I = ((int)UnityEngine.Random.Range(4000f, 4019f)).ToString();
		float num = UnityEngine.Random.Range(0.1f, 0.7f);
		float num2 = UnityEngine.Random.Range(num, num + 0.15f);
		float r = Mathf.Clamp01(UnityEngine.Random.Range(num2 + 0.1f, num2 + 0.5f));
		customModelData.Hex_Skin_C = ColorUtility.ToHtmlStringRGB(new Color(r, num2, num));
		Color color = new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f));
		customModelData.Hex_Hair_C = ColorUtility.ToHtmlStringRGB(color);
		customModelData.Hex_Eyebrow_C = ColorUtility.ToHtmlStringRGB(Color.Lerp(color, Color.black, UnityEngine.Random.Range(0f, 1f)));
		customModelData.Hex_Eye_C = ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f)));
		customModelData.Hex_Upper_C = ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f)));
		customModelData.Hex_Lower_C = ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f)));
		customModelData.Hex_Foot_C = ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f)));
		customModelData.Hex_Pattern_C = ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f)));
		customModelData.Hex_Acc_C = ColorUtility.ToHtmlStringRGB(new Color(UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(0f, 1f)));
		return customModelData;
	}

	public void SetModelData(CustomModelData _modelData)
	{
		modelData = _modelData;
	}

	public void SetMedel()
	{
		int num = ((!(modelData.Gender == "m")) ? 1 : 0);
		isOptimizeGameObjects = false;
		Transform[] componentsInChildren = base.transform.GetComponentsInChildren<Transform>(includeInactive: true);
		Animator animator = null;
		Transform transform = null;
		AccInfo accInfo = null;
		if (state != CustomModelViewState.HalfCut)
		{
			animator = base.transform.GetComponent<Animator>();
			if (modelData.Gender == "m")
			{
				animator.avatar = Resources.Load<UnityEngine.Avatar>("Customize/Bodies/Avatar_MALE");
			}
			else
			{
				animator.avatar = Resources.Load<UnityEngine.Avatar>("Customize/Bodies/Avatar_FEMALE");
			}
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				int num2 = WearInfoCreator.BoneNameToIndex(componentsInChildren[i].name);
				if (num2 == -1)
				{
					if (componentsInChildren[i].name == "BODY_ORG_HIDDEN")
					{
						isOptimizeGameObjects = base.transform.Find("BODY_ORG_HIDDEN").GetComponent<SkinnedMeshRenderer>().rootBone == null;
					}
				}
				else
				{
					boneTrs[num2] = componentsInChildren[i];
				}
			}
		}
		for (int j = 0; j < componentsInChildren.Length; j++)
		{
			switch (componentsInChildren[j].name)
			{
			case "ITEM_HEAD":
			{
				if (transform == null)
				{
					transform = componentsInChildren[j];
				}
				else if (transform != null && transform.name == "ITEM_HEAD_ACC")
				{
					transform.parent = componentsInChildren[j];
					transform.localRotation = Quaternion.identity;
					if (accInfo != null)
					{
						transform.localPosition = accInfo.pos;
						transform.localScale = accInfo.scale;
					}
					else if (num == 0)
					{
						transform.localPosition = Vector3.zero;
						transform.localScale = Vector3.one * 1f;
					}
					else
					{
						transform.localPosition = Vector3.zero;
						transform.localScale = Vector3.one * 0.925f;
					}
				}
				if (modelData.Gender == "m")
				{
					componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_HEAD");
				}
				else
				{
					componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_HEAD");
				}
				ItemSlotInfo itemSlotInfo11 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Face_I);
				MeshRenderer component17 = componentsInChildren[j].GetComponent<MeshRenderer>();
				component17.material = Resources.Load<Material>("Customize/Bodies/Mat_Custom_Face");
				component17.material.SetTexture("_SubTex_Eye", null);
				component17.material.SetTexture("_SubTex_Pupil", null);
				component17.material.SetTexture("_SubTex_Eyebrow", null);
				component17.material.SetTexture("_SubTex_Mouth", null);
				component17.material.SetTexture("_BaseTex", null);
				component17.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color17))
				{
					component17.material.SetColor("_BaseColor", color17);
				}
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Eye_C, out color17))
				{
					component17.material.SetColor("_EyeColor", color17);
				}
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Eyebrow_C, out color17))
				{
					component17.material.SetColor("_EyebrowColor", color17);
				}
				for (int num18 = 0; num18 < itemSlotInfo11.list_partId.Count; num18++)
				{
					switch (itemSlotInfo11.list_partId[num18][1])
					{
					case '0':
						component17.material.SetTexture("_SubTex_Eye", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo11.list_partId[num18]).matPath));
						break;
					case '1':
						component17.material.SetTexture("_SubTex_Pupil", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo11.list_partId[num18]).matPath));
						break;
					case '2':
						component17.material.SetTexture("_SubTex_Eyebrow", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo11.list_partId[num18]).matPath));
						break;
					case '3':
						component17.material.SetTexture("_SubTex_Mouth", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo11.list_partId[num18]).matPath));
						break;
					case '4':
						component17.material.SetTexture("_BaseTex", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo11.list_partId[num18]).matPath));
						break;
					}
				}
				bool flag3 = true;
				itemSlotInfo11 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Acc_I);
				if (itemSlotInfo11.list_partId[0] != "40000" && itemSlotInfo11.list_partId[0][1] == '0')
				{
					flag3 = false;
				}
				component17.enabled = flag3;
				break;
			}
			case "BODY_HALF":
			{
				MeshRenderer component13 = componentsInChildren[j].GetComponent<MeshRenderer>();
				if (modelData.Gender == "m")
				{
					component13.material = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
					componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_CUT_HIDDEN_02");
				}
				else
				{
					component13.material = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
					componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_CUT_HIDDEN_02");
				}
				if (state == CustomModelViewState.HalfCut)
				{
					component13.material.SetInt("_STATE", 3);
					component13.material.shader = Shader.Find(component13.material.shader.name);
				}
				component13.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color13))
				{
					component13.material.SetColor("_BaseColor", color13);
				}
				break;
			}
			case "WEAR_HALF":
			{
				ItemSlotInfo itemSlotInfo3 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Wear_I);
				for (int num4 = 0; num4 < itemSlotInfo3.list_partId.Count; num4++)
				{
					if (itemSlotInfo3.list_partId[num4][1] == '1')
					{
						ItemInfo itemInfo3 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo3.list_partId[num4]);
						MeshRenderer component5 = componentsInChildren[j].GetComponent<MeshRenderer>();
						componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo3.meshPath);
						component5.material = Resources.Load<Material>("Customize/Wears/" + itemInfo3.matPath);
						component5.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
						if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Upper_C, out var color5))
						{
							component5.material.SetColor("_BaseColor", color5);
						}
						if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Pattern_C, out color5))
						{
							component5.material.SetColor("_PatternColor", color5);
						}
						component5.material.SetColor("_Color_R", Color.white);
						component5.material.SetColor("_Color_G", Color.white);
						component5.material.SetColor("_Color_B", Color.white);
					}
				}
				break;
			}
			case "BODY_CUT":
			{
				SkinnedMeshRenderer component18 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
				TextAsset textAsset;
				if (modelData.Gender == "m")
				{
					component18.material = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
					component18.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_CUT");
					textAsset = Resources.Load("ItemInfos/BodyInfo_M_Cut") as TextAsset;
				}
				else
				{
					component18.material = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
					component18.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_CUT");
					textAsset = Resources.Load("ItemInfos/BodyInfo_F_Cut") as TextAsset;
				}
				WearInfo wearInfo11 = JsonUtility.FromJson<WearInfo>(textAsset.text);
				component18.localBounds = new Bounds(wearInfo11.bounds_center, wearInfo11.bounds_extent * 2f);
				if (!isOptimizeGameObjects)
				{
					component18.rootBone = boneTrs[wearInfo11.rootBone];
					Transform[] array11 = new Transform[wearInfo11.bones.Length];
					for (int num19 = 0; num19 < wearInfo11.bones.Length; num19++)
					{
						array11[num19] = boneTrs[wearInfo11.bones[num19]];
					}
					component18.bones = array11;
				}
				component18.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color18))
				{
					component18.material.SetColor("_BaseColor", color18);
				}
				componentsInChildren[j].gameObject.SetActive(value: false);
				break;
			}
			case "BODY_CUT_02":
			{
				SkinnedMeshRenderer component3 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
				TextAsset textAsset;
				if (modelData.Gender == "m")
				{
					component3.material = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
					component3.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_CUT_02");
					textAsset = Resources.Load("ItemInfos/BodyInfo_M_Cut_02") as TextAsset;
				}
				else
				{
					component3.material = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
					component3.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_CUT_02");
					textAsset = Resources.Load("ItemInfos/BodyInfo_F_Cut_02") as TextAsset;
				}
				WearInfo wearInfo2 = JsonUtility.FromJson<WearInfo>(textAsset.text);
				component3.localBounds = new Bounds(wearInfo2.bounds_center, wearInfo2.bounds_extent * 2f);
				if (!isOptimizeGameObjects)
				{
					component3.rootBone = boneTrs[wearInfo2.rootBone];
					Transform[] array2 = new Transform[wearInfo2.bones.Length];
					for (int m = 0; m < wearInfo2.bones.Length; m++)
					{
						array2[m] = boneTrs[wearInfo2.bones[m]];
					}
					component3.bones = array2;
				}
				component3.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color3))
				{
					component3.material.SetColor("_BaseColor", color3);
				}
				componentsInChildren[j].gameObject.SetActive(value: false);
				break;
			}
			case "BODY_CUT_HIDDEN":
			{
				SkinnedMeshRenderer component2 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
				TextAsset textAsset;
				if (modelData.Gender == "m")
				{
					component2.material = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
					component2.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_CUT_HIDDEN");
					textAsset = Resources.Load("ItemInfos/BodyInfo_M_Cut_H") as TextAsset;
				}
				else
				{
					component2.material = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
					component2.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_CUT_HIDDEN");
					textAsset = Resources.Load("ItemInfos/BodyInfo_F_Cut_H") as TextAsset;
				}
				WearInfo wearInfo = JsonUtility.FromJson<WearInfo>(textAsset.text);
				component2.localBounds = new Bounds(wearInfo.bounds_center, wearInfo.bounds_extent * 2f);
				if (!isOptimizeGameObjects)
				{
					component2.rootBone = boneTrs[wearInfo.rootBone];
					Transform[] array = new Transform[wearInfo.bones.Length];
					for (int l = 0; l < wearInfo.bones.Length; l++)
					{
						array[l] = boneTrs[wearInfo.bones[l]];
					}
					component2.bones = array;
				}
				component2.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color2))
				{
					component2.material.SetColor("_BaseColor", color2);
				}
				componentsInChildren[j].gameObject.SetActive(state != CustomModelViewState.Normal);
				break;
			}
			case "BODY_CUT_HIDDEN_02":
			{
				SkinnedMeshRenderer component9 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
				TextAsset textAsset;
				if (modelData.Gender == "m")
				{
					component9.material = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
					component9.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_CUT_HIDDEN_02");
					textAsset = Resources.Load("ItemInfos/BodyInfo_M_Cut_H_02") as TextAsset;
				}
				else
				{
					component9.material = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
					component9.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_CUT_HIDDEN_02");
					textAsset = Resources.Load("ItemInfos/BodyInfo_F_Cut_H_02") as TextAsset;
				}
				WearInfo wearInfo7 = JsonUtility.FromJson<WearInfo>(textAsset.text);
				component9.localBounds = new Bounds(wearInfo7.bounds_center, wearInfo7.bounds_extent * 2f);
				if (!isOptimizeGameObjects)
				{
					component9.rootBone = boneTrs[wearInfo7.rootBone];
					Transform[] array7 = new Transform[wearInfo7.bones.Length];
					for (int num10 = 0; num10 < wearInfo7.bones.Length; num10++)
					{
						array7[num10] = boneTrs[wearInfo7.bones[num10]];
					}
					component9.bones = array7;
				}
				component9.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color9))
				{
					component9.material.SetColor("_BaseColor", color9);
				}
				if (state == CustomModelViewState.HalfCut2)
				{
					componentsInChildren[j].gameObject.SetActive(value: true);
				}
				else
				{
					componentsInChildren[j].gameObject.SetActive(value: false);
				}
				break;
			}
			case "BODY_ORG":
			{
				SkinnedMeshRenderer component7 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
				TextAsset textAsset;
				if (modelData.Gender == "m")
				{
					component7.material = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
					component7.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_ORG");
					textAsset = Resources.Load("ItemInfos/BodyInfo_M_Origin") as TextAsset;
				}
				else
				{
					component7.material = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
					component7.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_ORG");
					textAsset = Resources.Load("ItemInfos/BodyInfo_F_Origin") as TextAsset;
				}
				WearInfo wearInfo5 = JsonUtility.FromJson<WearInfo>(textAsset.text);
				component7.localBounds = new Bounds(wearInfo5.bounds_center, wearInfo5.bounds_extent * 2f);
				if (!isOptimizeGameObjects)
				{
					component7.rootBone = boneTrs[wearInfo5.rootBone];
					Transform[] array5 = new Transform[wearInfo5.bones.Length];
					for (int num7 = 0; num7 < wearInfo5.bones.Length; num7++)
					{
						array5[num7] = boneTrs[wearInfo5.bones[num7]];
					}
					component7.bones = array5;
				}
				component7.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color7))
				{
					component7.material.SetColor("_BaseColor", color7);
				}
				componentsInChildren[j].gameObject.SetActive(value: false);
				break;
			}
			case "BODY_ORG_HIDDEN":
			{
				SkinnedMeshRenderer component16 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
				TextAsset textAsset;
				if (modelData.Gender == "m")
				{
					component16.material = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
					component16.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_ORG_HIDDEN");
					textAsset = Resources.Load("ItemInfos/BodyInfo_M_Origin_H") as TextAsset;
				}
				else
				{
					component16.material = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
					component16.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_ORG_HIDDEN");
					textAsset = Resources.Load("ItemInfos/BodyInfo_F_Origin_H") as TextAsset;
				}
				WearInfo wearInfo10 = JsonUtility.FromJson<WearInfo>(textAsset.text);
				component16.localBounds = new Bounds(wearInfo10.bounds_center, wearInfo10.bounds_extent * 2f);
				list_skinnedMesh.Add(component16);
				list_boneInfos.Add(wearInfo10.bones);
				if (!isOptimizeGameObjects)
				{
					component16.rootBone = boneTrs[wearInfo10.rootBone];
					Transform[] array10 = new Transform[wearInfo10.bones.Length];
					for (int num17 = 0; num17 < wearInfo10.bones.Length; num17++)
					{
						array10[num17] = boneTrs[wearInfo10.bones[num17]];
					}
					component16.bones = array10;
				}
				component16.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
				if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color16))
				{
					component16.material.SetColor("_BaseColor", color16);
				}
				componentsInChildren[j].gameObject.SetActive(state == CustomModelViewState.Normal);
				break;
			}
			case "ITEM_HAIR_F":
			{
				ItemSlotInfo itemSlotInfo7 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Hair_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				for (int num13 = 0; num13 < itemSlotInfo7.list_partId.Count; num13++)
				{
					if (itemSlotInfo7.list_partId[num13][1] == '0')
					{
						ItemInfo itemInfo7 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo7.list_partId[num13]);
						MeshRenderer component11 = componentsInChildren[j].GetComponent<MeshRenderer>();
						componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Hairs/" + itemInfo7.meshPath);
						component11.material = Resources.Load<Material>("Customize/Hairs/" + itemInfo7.matPath);
						component11.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
						if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Hair_C, out var color11))
						{
							component11.material.SetColor("_BaseColor", color11);
						}
						bool flag = true;
						itemSlotInfo7 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Acc_I);
						if ((itemSlotInfo7.list_partId[0] != "40000" && itemSlotInfo7.list_partId[0][1] == '0') || itemSlotInfo7.list_partId[0][1] == '1' || itemSlotInfo7.list_partId[0][1] == '2')
						{
							flag = false;
						}
						if (flag)
						{
							list_meshRenderer.Add(component11);
						}
						componentsInChildren[j].gameObject.SetActive(flag);
					}
				}
				break;
			}
			case "ITEM_HAIR_B":
			{
				ItemSlotInfo itemSlotInfo9 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Hair_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				ItemSlotInfo itemSlotInfo10 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Acc_I);
				if (itemSlotInfo10.list_partId[0][1] == '2')
				{
					ItemInfo itemInfo9 = ((num != 0) ? SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo("21012") : SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo("21000"));
					MeshRenderer component14 = componentsInChildren[j].GetComponent<MeshRenderer>();
					list_meshRenderer.Add(component14);
					componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Hairs/" + itemInfo9.meshPath);
					component14.material = Resources.Load<Material>("Customize/Hairs/" + itemInfo9.matPath);
					component14.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Hair_C, out var color14))
					{
						component14.material.SetColor("_BaseColor", color14);
					}
					componentsInChildren[j].gameObject.SetActive(value: true);
					break;
				}
				for (int num16 = 0; num16 < itemSlotInfo9.list_partId.Count; num16++)
				{
					if (itemSlotInfo9.list_partId[num16][1] == '1')
					{
						ItemInfo itemInfo10 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo9.list_partId[num16]);
						MeshRenderer component15 = componentsInChildren[j].GetComponent<MeshRenderer>();
						componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Hairs/" + itemInfo10.meshPath);
						component15.material = Resources.Load<Material>("Customize/Hairs/" + itemInfo10.matPath);
						component15.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
						if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Hair_C, out var color15))
						{
							component15.material.SetColor("_BaseColor", color15);
						}
						bool flag2 = true;
						if ((itemSlotInfo10.list_partId[0] != "40000" && itemSlotInfo10.list_partId[0][1] == '0') || itemSlotInfo10.list_partId[0][1] == '1')
						{
							flag2 = false;
						}
						if (flag2)
						{
							list_meshRenderer.Add(component15);
						}
						componentsInChildren[j].gameObject.SetActive(flag2);
					}
				}
				break;
			}
			case "ITEM_UPPER":
			{
				ItemSlotInfo itemSlotInfo8 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Wear_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				for (int num14 = 0; num14 < itemSlotInfo8.list_partId.Count; num14++)
				{
					if (itemSlotInfo8.list_partId[num14][1] != '0')
					{
						continue;
					}
					ItemInfo itemInfo8 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo8.list_partId[num14]);
					SkinnedMeshRenderer component12 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
					component12.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo8.meshPath);
					component12.material = Resources.Load<Material>("Customize/Wears/" + itemInfo8.matPath);
					TextAsset textAsset = Resources.Load("ItemInfos/WearInfo_" + itemInfo8.meshPath) as TextAsset;
					WearInfo wearInfo9 = JsonUtility.FromJson<WearInfo>(textAsset.text);
					component12.localBounds = new Bounds(wearInfo9.bounds_center, wearInfo9.bounds_extent * 2f);
					list_skinnedMesh.Add(component12);
					list_boneInfos.Add(wearInfo9.bones);
					if (!isOptimizeGameObjects)
					{
						component12.rootBone = boneTrs[wearInfo9.rootBone];
						Transform[] array9 = new Transform[wearInfo9.bones.Length];
						for (int num15 = 0; num15 < wearInfo9.bones.Length; num15++)
						{
							array9[num15] = boneTrs[wearInfo9.bones[num15]];
						}
						component12.bones = array9;
					}
					component12.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Upper_C, out var color12))
					{
						component12.material.SetColor("_BaseColor", color12);
					}
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Pattern_C, out color12))
					{
						component12.material.SetColor("_PatternColor", color12);
					}
					component12.material.SetColor("_Color_R", Color.white);
					component12.material.SetColor("_Color_G", Color.white);
					component12.material.SetColor("_Color_B", Color.white);
					component12.gameObject.SetActive(state == CustomModelViewState.Normal);
				}
				break;
			}
			case "ITEM_UPPER_CUT":
			{
				ItemSlotInfo itemSlotInfo6 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Wear_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				for (int num11 = 0; num11 < itemSlotInfo6.list_partId.Count; num11++)
				{
					if (itemSlotInfo6.list_partId[num11][1] != '1')
					{
						continue;
					}
					ItemInfo itemInfo6 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo6.list_partId[num11]);
					SkinnedMeshRenderer component10 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
					component10.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo6.meshPath);
					component10.material = Resources.Load<Material>("Customize/Wears/" + itemInfo6.matPath);
					TextAsset textAsset = Resources.Load("ItemInfos/WearInfo_" + itemInfo6.meshPath) as TextAsset;
					WearInfo wearInfo8 = JsonUtility.FromJson<WearInfo>(textAsset.text);
					component10.localBounds = new Bounds(wearInfo8.bounds_center, wearInfo8.bounds_extent * 2f);
					if (!isOptimizeGameObjects)
					{
						component10.rootBone = boneTrs[wearInfo8.rootBone];
						Transform[] array8 = new Transform[wearInfo8.bones.Length];
						for (int num12 = 0; num12 < wearInfo8.bones.Length; num12++)
						{
							array8[num12] = boneTrs[wearInfo8.bones[num12]];
						}
						component10.bones = array8;
					}
					component10.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Upper_C, out var color10))
					{
						component10.material.SetColor("_BaseColor", color10);
					}
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Pattern_C, out color10))
					{
						component10.material.SetColor("_PatternColor", color10);
					}
					component10.material.SetColor("_Color_R", Color.white);
					component10.material.SetColor("_Color_G", Color.white);
					component10.material.SetColor("_Color_B", Color.white);
					component10.gameObject.SetActive(state != CustomModelViewState.Normal);
				}
				break;
			}
			case "ITEM_LOWER":
			{
				ItemSlotInfo itemSlotInfo5 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Wear_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				for (int num8 = 0; num8 < itemSlotInfo5.list_partId.Count; num8++)
				{
					if (itemSlotInfo5.list_partId[num8][1] != '2')
					{
						continue;
					}
					ItemInfo itemInfo5 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo5.list_partId[num8]);
					SkinnedMeshRenderer component8 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
					component8.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo5.meshPath);
					component8.material = Resources.Load<Material>("Customize/Wears/" + itemInfo5.matPath);
					TextAsset textAsset = Resources.Load("ItemInfos/WearInfo_" + itemInfo5.meshPath) as TextAsset;
					WearInfo wearInfo6 = JsonUtility.FromJson<WearInfo>(textAsset.text);
					component8.localBounds = new Bounds(wearInfo6.bounds_center, wearInfo6.bounds_extent * 2f);
					list_skinnedMesh.Add(component8);
					list_boneInfos.Add(wearInfo6.bones);
					if (!isOptimizeGameObjects)
					{
						component8.rootBone = boneTrs[wearInfo6.rootBone];
						Transform[] array6 = new Transform[wearInfo6.bones.Length];
						for (int num9 = 0; num9 < wearInfo6.bones.Length; num9++)
						{
							array6[num9] = boneTrs[wearInfo6.bones[num9]];
						}
						component8.bones = array6;
					}
					component8.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Lower_C, out var color8))
					{
						component8.material.SetColor("_BaseColor", color8);
					}
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Pattern_C, out color8))
					{
						component8.material.SetColor("_PatternColor", color8);
					}
					component8.material.SetColor("_Color_R", Color.white);
					component8.material.SetColor("_Color_G", Color.white);
					component8.material.SetColor("_Color_B", Color.white);
					component8.gameObject.SetActive(value: true);
				}
				break;
			}
			case "ITEM_LOWER_SUB":
			{
				ItemSlotInfo itemSlotInfo4 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Wear_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				for (int num5 = 0; num5 < itemSlotInfo4.list_partId.Count; num5++)
				{
					if (itemSlotInfo4.list_partId[num5][1] != '3')
					{
						continue;
					}
					ItemInfo itemInfo4 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo4.list_partId[num5]);
					SkinnedMeshRenderer component6 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
					component6.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo4.meshPath);
					component6.material = Resources.Load<Material>("Customize/Wears/" + itemInfo4.matPath);
					TextAsset textAsset = Resources.Load("ItemInfos/WearInfo_" + itemInfo4.meshPath) as TextAsset;
					WearInfo wearInfo4 = JsonUtility.FromJson<WearInfo>(textAsset.text);
					component6.localBounds = new Bounds(wearInfo4.bounds_center, wearInfo4.bounds_extent * 2f);
					list_skinnedMesh.Add(component6);
					list_boneInfos.Add(wearInfo4.bones);
					if (!isOptimizeGameObjects)
					{
						component6.rootBone = boneTrs[wearInfo4.rootBone];
						Transform[] array4 = new Transform[wearInfo4.bones.Length];
						for (int num6 = 0; num6 < wearInfo4.bones.Length; num6++)
						{
							array4[num6] = boneTrs[wearInfo4.bones[num6]];
						}
						component6.bones = array4;
					}
					component6.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Lower_C, out var color6))
					{
						component6.material.SetColor("_BaseColor", color6);
					}
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Pattern_C, out color6))
					{
						component6.material.SetColor("_PatternColor", color6);
					}
					component6.material.SetColor("_Color_R", Color.white);
					component6.material.SetColor("_Color_G", Color.white);
					component6.material.SetColor("_Color_B", Color.white);
					component6.gameObject.SetActive(value: true);
				}
				break;
			}
			case "ITEM_FOOT":
			{
				ItemSlotInfo itemSlotInfo2 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Wear_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				for (int n = 0; n < itemSlotInfo2.list_partId.Count; n++)
				{
					if (itemSlotInfo2.list_partId[n][1] != '4')
					{
						continue;
					}
					ItemInfo itemInfo2 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo2.list_partId[n]);
					SkinnedMeshRenderer component4 = componentsInChildren[j].GetComponent<SkinnedMeshRenderer>();
					component4.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo2.meshPath);
					component4.material = Resources.Load<Material>("Customize/Wears/" + itemInfo2.matPath);
					TextAsset textAsset = Resources.Load("ItemInfos/WearInfo_" + itemInfo2.meshPath) as TextAsset;
					WearInfo wearInfo3 = JsonUtility.FromJson<WearInfo>(textAsset.text);
					component4.localBounds = new Bounds(wearInfo3.bounds_center, wearInfo3.bounds_extent * 2f);
					list_skinnedMesh.Add(component4);
					list_boneInfos.Add(wearInfo3.bones);
					if (!isOptimizeGameObjects)
					{
						component4.rootBone = boneTrs[wearInfo3.rootBone];
						Transform[] array3 = new Transform[wearInfo3.bones.Length];
						for (int num3 = 0; num3 < wearInfo3.bones.Length; num3++)
						{
							array3[num3] = boneTrs[wearInfo3.bones[num3]];
						}
						component4.bones = array3;
					}
					component4.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Foot_C, out var color4))
					{
						component4.material.SetColor("_BaseColor", color4);
					}
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Pattern_C, out color4))
					{
						component4.material.SetColor("_PatternColor", color4);
					}
					component4.material.SetColor("_Color_R", Color.white);
					component4.material.SetColor("_Color_G", Color.white);
					component4.material.SetColor("_Color_B", Color.white);
					component4.gameObject.SetActive(value: true);
				}
				break;
			}
			case "ITEM_HEAD_ACC":
			{
				ItemSlotInfo itemSlotInfo = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(num, modelData.ID_Acc_I);
				componentsInChildren[j].gameObject.SetActive(value: false);
				if (modelData.ID_Acc_I == "4000")
				{
					break;
				}
				for (int k = 0; k < itemSlotInfo.list_partId.Count; k++)
				{
					ItemInfo itemInfo = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(itemSlotInfo.list_partId[k]);
					MeshRenderer component = componentsInChildren[j].GetComponent<MeshRenderer>();
					list_meshRenderer.Add(component);
					componentsInChildren[j].GetComponent<MeshFilter>().sharedMesh = Resources.Load<Mesh>("Customize/Accs/" + itemInfo.meshPath);
					component.material = Resources.Load<Material>("Customize/Accs/" + itemInfo.matPath);
					component.material.SetColor("_ToneColor", Color.Lerp(Color.black, Color.white, toneVelue));
					if (ColorUtility.TryParseHtmlString("#" + modelData.Hex_Acc_C, out var color))
					{
						component.material.SetColor("_BaseColor", color);
					}
					TextAsset textAsset = ((num != 0) ? (Resources.Load("ItemInfos/AccInfo_F_" + itemSlotInfo.list_partId[k]) as TextAsset) : (Resources.Load("ItemInfos/AccInfo_M_" + itemSlotInfo.list_partId[k]) as TextAsset));
					if (textAsset != null)
					{
						accInfo = JsonUtility.FromJson<AccInfo>(textAsset.text);
					}
					if (transform == null)
					{
						transform = componentsInChildren[j];
					}
					else if (transform != null && transform.name == "ITEM_HEAD")
					{
						componentsInChildren[j].parent = transform;
						componentsInChildren[j].localRotation = Quaternion.identity;
						if (accInfo != null)
						{
							componentsInChildren[j].localPosition = accInfo.pos;
							componentsInChildren[j].localScale = accInfo.scale;
						}
						else if (num == 0)
						{
							componentsInChildren[j].localPosition = Vector3.zero;
							componentsInChildren[j].localScale = Vector3.one * 1f;
						}
						else
						{
							componentsInChildren[j].localPosition = Vector3.zero;
							componentsInChildren[j].localScale = Vector3.one * 0.925f;
						}
					}
					componentsInChildren[j].gameObject.SetActive(value: true);
				}
				break;
			}
			}
		}
		if (renderer_hand != null && ColorUtility.TryParseHtmlString("#" + modelData.Hex_Skin_C, out var color19))
		{
			renderer_hand.sharedMaterial.SetColor("_BaseColor", color19);
		}
		if (animator != null)
		{
			animator.Rebind();
		}
		base.enabled = false;
	}

	private void CombineSkinnedMeshes()
	{
		Texture2D value = new Texture2D(2, 2);
		Texture2D value2 = new Texture2D(2, 2, GraphicsFormat.RGBA_DXT5_UNorm, -1, TextureCreationFlags.MipChain);
		Texture2D value3 = new Texture2D(2, 2);
		Texture2D value4 = new Texture2D(2, 2);
		Texture2D[] array = new Texture2D[list_skinnedMesh.Count + list_meshRenderer.Count];
		Texture2D[] array2 = new Texture2D[list_skinnedMesh.Count + list_meshRenderer.Count];
		Texture2D[] array3 = new Texture2D[list_skinnedMesh.Count + list_meshRenderer.Count];
		Texture2D[] array4 = new Texture2D[list_skinnedMesh.Count + list_meshRenderer.Count];
		Texture2D texture2D = new Texture2D(2, 2);
		for (int i = 0; i < list_skinnedMesh.Count; i++)
		{
			Texture2D texture2D2 = (Texture2D)list_skinnedMesh[i].sharedMaterial.GetTexture("_ChannelMap");
			if (texture2D2 == null)
			{
				texture2D2 = Resources.Load<Texture2D>("Customize/Image_None_Black");
			}
			Texture2D texture2D3 = (Texture2D)list_skinnedMesh[i].sharedMaterial.GetTexture("_BumpMap");
			Texture2D texture2D4 = (Texture2D)list_skinnedMesh[i].sharedMaterial.GetTexture("_SpecGlossMap");
			if (texture2D4 == null)
			{
				texture2D4 = Resources.Load<Texture2D>("Customize/Image_None_SPEC");
			}
			list_skinnedMesh[i].sharedMaterial.GetFloat("_Smoothness");
			Texture2D texture2D5 = null;
			_ = Color.black;
			if (list_skinnedMesh[i].material.shader.name == "Shader Graphs/WearShader")
			{
				texture2D5 = (Texture2D)list_skinnedMesh[i].sharedMaterial.GetTexture("_EmissionMap");
				list_skinnedMesh[i].sharedMaterial.GetColor("_EmissionColor");
			}
			if (texture2D5 == null)
			{
				texture2D5 = Resources.Load<Texture2D>("Customize/Image_None_Black");
			}
			list_skinnedMesh[i].sharedMaterial.GetColor("_BaseColor");
			list_skinnedMesh[i].sharedMaterial.GetColor("_Color_R");
			list_skinnedMesh[i].sharedMaterial.GetColor("_Color_G");
			list_skinnedMesh[i].sharedMaterial.GetColor("_Color_B");
			Texture2D texture2D6 = (Texture2D)list_skinnedMesh[i].sharedMaterial.GetTexture("_PatternTex");
			list_skinnedMesh[i].sharedMaterial.GetColor("_PatternColor");
			texture2D = new Texture2D(2, 2);
			Color[] pixels = texture2D2.GetPixels(0);
			if (texture2D6 != null)
			{
				texture2D6.GetPixels(0);
				_ = Color.black;
				_ = Color.black;
			}
			else
			{
				_ = Color.black;
				_ = Color.black;
			}
			texture2D.SetPixels(pixels);
			array[i] = texture2D;
			array2[i] = texture2D3;
			pixels = texture2D4.GetPixels(0);
			texture2D.SetPixels(pixels);
			array3[i] = texture2D;
			pixels = texture2D5.GetPixels(0);
			texture2D.SetPixels(pixels);
			array4[i] = texture2D;
		}
		for (int j = 0; j < list_meshRenderer.Count; j++)
		{
			Texture2D texture2D7 = (Texture2D)list_meshRenderer[j].sharedMaterial.GetTexture("_ChannelMap");
			if (texture2D7 == null)
			{
				texture2D7 = Resources.Load<Texture2D>("Customize/Image_None_Black");
			}
			Texture2D texture2D8 = (Texture2D)list_meshRenderer[j].sharedMaterial.GetTexture("_BumpMap");
			Texture2D texture2D9 = (Texture2D)list_meshRenderer[j].sharedMaterial.GetTexture("_SpecGlossMap");
			if (texture2D9 == null)
			{
				texture2D9 = Resources.Load<Texture2D>("Customize/Image_None_SPEC");
			}
			float @float = list_meshRenderer[j].sharedMaterial.GetFloat("_Smoothness");
			Texture2D texture2D10 = null;
			Color color = Color.black;
			if (list_meshRenderer[j].material.shader.name == "Shader Graphs/WearShader")
			{
				texture2D10 = (Texture2D)list_meshRenderer[j].sharedMaterial.GetTexture("_EmissionMap");
				color = list_meshRenderer[j].sharedMaterial.GetColor("_EmissionColor");
			}
			if (texture2D10 == null)
			{
				texture2D10 = Resources.Load<Texture2D>("Customize/Image_None_Black");
			}
			Color color2 = list_meshRenderer[j].sharedMaterial.GetColor("_BaseColor");
			Color color3 = list_meshRenderer[j].sharedMaterial.GetColor("_Color_R");
			Color color4 = list_meshRenderer[j].sharedMaterial.GetColor("_Color_G");
			Color color5 = list_meshRenderer[j].sharedMaterial.GetColor("_Color_B");
			Texture2D texture2D11 = null;
			Color color6 = Color.black;
			if (list_meshRenderer[j].sharedMaterial.shader.name == "Shader Graphs/WearShader")
			{
				texture2D11 = (Texture2D)list_meshRenderer[j].sharedMaterial.GetTexture("_PatternTex");
				color6 = list_meshRenderer[j].sharedMaterial.GetColor("_PatternColor");
			}
			texture2D = new Texture2D(texture2D7.width, texture2D7.height);
			Color[] pixels2 = texture2D7.GetPixels(0);
			if (texture2D11 != null)
			{
				Color[] pixels3 = texture2D11.GetPixels(0);
				for (int k = 0; k < texture2D7.height; k++)
				{
					for (int l = 0; l < texture2D7.width; l++)
					{
						Color linear = pixels2[k * texture2D7.width + l].linear;
						Color a2 = Color.LerpUnclamped(color2, color3, linear.r);
						a2 = Color.LerpUnclamped(a2, color4, linear.g);
						a2 = Color.LerpUnclamped(a2, color5, linear.b);
						a2 = Color.LerpUnclamped(a2, pixels3[k * texture2D7.width + l] * color6, pixels3[k * texture2D7.width + l].a);
						pixels2[k * texture2D7.width + l] = a2;
					}
				}
			}
			else
			{
				for (int m = 0; m < texture2D7.height; m++)
				{
					for (int n = 0; n < texture2D7.width; n++)
					{
						Color linear2 = pixels2[m * texture2D7.width + n].linear;
						Color a3 = Color.LerpUnclamped(color2, color3, linear2.r);
						a3 = Color.LerpUnclamped(a3, color4, linear2.g);
						a3 = Color.LerpUnclamped(a3, color5, linear2.b);
						pixels2[m * texture2D7.width + n] = a3;
					}
				}
			}
			texture2D.SetPixels(pixels2);
			array[j + list_skinnedMesh.Count] = texture2D;
			array2[j + list_skinnedMesh.Count] = texture2D8;
			Texture2D texture2D12 = new Texture2D(texture2D7.width, texture2D7.height);
			pixels2 = texture2D9.GetPixels(0);
			for (int num = 0; num < pixels2.Length; num++)
			{
				pixels2[num].a *= @float;
			}
			texture2D12.SetPixels(pixels2);
			array3[j + list_skinnedMesh.Count] = texture2D12;
			Texture2D texture2D13 = new Texture2D(texture2D7.width, texture2D7.height);
			pixels2 = texture2D10.GetPixels(0);
			for (int num2 = 0; num2 < pixels2.Length; num2++)
			{
				pixels2[num2] *= color;
			}
			texture2D13.SetPixels(pixels2);
			array4[j + list_skinnedMesh.Count] = texture2D13;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = new GameObject("CombineSkin").AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.transform.parent = base.transform;
		skinnedMeshRenderer.transform.localPosition = Vector3.zero;
		skinnedMeshRenderer.transform.localRotation = Quaternion.identity;
		skinnedMeshRenderer.transform.localScale = Vector3.one;
		Material material = new Material(Shader.Find("Shader Graphs/CombineShader"));
		material.SetTexture("_MainTex", value);
		material.SetTexture("_BumpMap", value2);
		material.SetTexture("_SpecGlossMap", value3);
		material.SetTexture("_EmissionMap", value4);
		skinnedMeshRenderer.sharedMaterial = material;
		Mesh mesh = new Mesh();
		List<int> list = new List<int>();
		List<Vector3> list2 = new List<Vector3>();
		new List<Color>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector4> list4 = new List<Vector4>();
		List<Vector2> list5 = new List<Vector2>();
		new List<Vector2>();
		new List<Vector2>();
		new List<Vector2>();
		List<int> list6 = new List<int>();
		List<BoneWeight> list7 = new List<BoneWeight>();
		List<BindPoseInfo> list8 = new List<BindPoseInfo>();
		new List<Transform>();
		TextAsset textAsset;
		if (modelData.Gender == "m")
		{
			mesh = UnityEngine.Object.Instantiate(Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_ALL"));
			textAsset = Resources.Load("ItemInfos/BodyInfo_M_ALL") as TextAsset;
		}
		else
		{
			mesh = UnityEngine.Object.Instantiate(Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_ALL"));
			textAsset = Resources.Load("ItemInfos/BodyInfo_F_ALL") as TextAsset;
		}
		WearInfo wearInfo = JsonUtility.FromJson<WearInfo>(textAsset.text);
		skinnedMeshRenderer.localBounds = new Bounds(wearInfo.bounds_center, wearInfo.bounds_extent * 2f);
		Transform[] array5 = new Transform[wearInfo.bones.Length];
		for (int num3 = 0; num3 < wearInfo.bones.Length; num3++)
		{
			if (!isOptimizeGameObjects)
			{
				array5[num3] = boneTrs[wearInfo.bones[num3]];
			}
			BindPoseInfo bindPoseInfo = new BindPoseInfo();
			bindPoseInfo.boneNum_origin = wearInfo.bones[num3];
			bindPoseInfo.boneNums = new int[list_skinnedMesh.Count];
			for (int num4 = 0; num4 < bindPoseInfo.boneNums.Length; num4++)
			{
				bindPoseInfo.boneNums[num4] = -1;
			}
			bindPoseInfo.index = list8.Count;
			list8.Add(bindPoseInfo);
		}
		if (!isOptimizeGameObjects)
		{
			skinnedMeshRenderer.rootBone = boneTrs[wearInfo.rootBone];
			skinnedMeshRenderer.bones = array5;
		}
		for (int num5 = 0; num5 < list_boneInfos.Count; num5++)
		{
			for (int num6 = 0; num6 < list_boneInfos[num5].Length; num6++)
			{
				for (int num7 = 0; num7 < list8.Count; num7++)
				{
					if (list8[num7].boneNum_origin == list_boneInfos[num5][num6])
					{
						list8[num7].boneNums[num5] = num6;
						break;
					}
				}
			}
		}
		int num8 = 0;
		int num9 = 0;
		for (int rect_i = 0; rect_i < list_skinnedMesh.Count; rect_i++)
		{
			Mesh sharedMesh = list_skinnedMesh[rect_i].sharedMesh;
			int[] triangles = sharedMesh.GetTriangles(0);
			int num10 = 0;
			for (int num11 = 0; num11 < triangles.Length; num11++)
			{
				num10 = triangles[num11] + num8;
				int item;
				if (!list.Contains(num10))
				{
					item = num9;
					list.Add(num10);
					list2.Add(sharedMesh.vertices[num10 - num8]);
					list3.Add(sharedMesh.normals[num10 - num8]);
					list4.Add(sharedMesh.tangents[num10 - num8]);
					if (sharedMesh.uv != null)
					{
						_ = sharedMesh.uv.Length;
						_ = num10 - num8;
					}
					BoneWeight boneWeight = sharedMesh.boneWeights[num10 - num8];
					BindPoseInfo bindPoseInfo2 = list8.Find((BindPoseInfo a) => a.boneNums[rect_i] == boneWeight.boneIndex0);
					boneWeight.boneIndex0 = bindPoseInfo2.index;
					bindPoseInfo2 = list8.Find((BindPoseInfo a) => a.boneNums[rect_i] == boneWeight.boneIndex1);
					boneWeight.boneIndex1 = bindPoseInfo2.index;
					bindPoseInfo2 = list8.Find((BindPoseInfo a) => a.boneNums[rect_i] == boneWeight.boneIndex2);
					boneWeight.boneIndex2 = bindPoseInfo2.index;
					bindPoseInfo2 = list8.Find((BindPoseInfo a) => a.boneNums[rect_i] == boneWeight.boneIndex3);
					boneWeight.boneIndex3 = bindPoseInfo2.index;
					list7.Add(boneWeight);
					num9++;
				}
				else
				{
					item = list.IndexOf(num10);
				}
				list6.Add(item);
			}
			num8 += (int)list_skinnedMesh[rect_i].sharedMesh.GetIndexCount(0);
			list_skinnedMesh[rect_i].gameObject.SetActive(value: false);
		}
		for (int num12 = 0; num12 < list_meshRenderer.Count; num12++)
		{
			Mesh sharedMesh2 = list_meshRenderer[num12].transform.GetComponent<MeshFilter>().sharedMesh;
			int[] triangles2 = sharedMesh2.GetTriangles(0);
			int num13 = 0;
			for (int num14 = 0; num14 < triangles2.Length; num14++)
			{
				num13 = triangles2[num14] + num8;
				int item2;
				if (!list.Contains(num13))
				{
					item2 = num9;
					list.Add(num13);
					Quaternion quaternion = default(Quaternion);
					quaternion.eulerAngles = new Vector3(180f, 90f, 0f);
					Vector3 vector = new Vector3(mesh.bindposes[0].m23, mesh.bindposes[0].m13, mesh.bindposes[0].m03);
					Vector3 vector2 = sharedMesh2.vertices[num13 - num8];
					if (list_meshRenderer[num12].gameObject.name == "ITEM_HEAD_ACC")
					{
						vector2.x *= list_meshRenderer[num12].transform.localScale.x;
						vector2.y *= list_meshRenderer[num12].transform.localScale.y;
						vector2.z *= list_meshRenderer[num12].transform.localScale.z;
						vector2 += list_meshRenderer[num12].transform.localPosition;
					}
					list2.Add(quaternion * vector2 + vector);
					list3.Add(quaternion * sharedMesh2.normals[num13 - num8]);
					list4.Add(quaternion * sharedMesh2.tangents[num13 - num8]);
					if (sharedMesh2.uv != null)
					{
						_ = sharedMesh2.uv.Length;
						_ = num13 - num8;
					}
					BoneWeight item3 = default(BoneWeight);
					item3.boneIndex0 = 0;
					item3.weight0 = 1f;
					list7.Add(item3);
					num9++;
				}
				else
				{
					item2 = list.IndexOf(num13);
				}
				list6.Add(item2);
			}
			num8 += (int)list_meshRenderer[num12].transform.GetComponent<MeshFilter>().sharedMesh.GetIndexCount(0);
			list_meshRenderer[num12].gameObject.SetActive(value: false);
		}
		mesh.vertices = list2.ToArray();
		mesh.triangles = list6.ToArray();
		mesh.normals = list3.ToArray();
		mesh.tangents = list4.ToArray();
		if (list5.Count > 0)
		{
			mesh.uv = list5.ToArray();
		}
		mesh.boneWeights = list7.ToArray();
		Bounds bounds = mesh.bounds;
		bounds.center = Vector3.zero;
		skinnedMeshRenderer.localBounds = bounds;
		skinnedMeshRenderer.sharedMesh = mesh;
		GetComponent<Animator>().Rebind();
	}
}
public class CustomizeDataInfo : SingletonBase.Singleton<CustomizeDataInfo>
{
	private Dictionary<string, ItemInfo> dict_itemInfo;

	private Dictionary<string, ItemSlotInfo>[] dict_itemSlotInfos;

	private bool isInit;

	private void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		Init();
	}

	public void Init()
	{
		if (isInit)
		{
			return;
		}
		dict_itemInfo = new Dictionary<string, ItemInfo>();
		TextAsset textAsset = Resources.Load("ItemInfos/ItemInfo_Face_Item") as TextAsset;
		List<ItemInfo> list_itemInfo = JsonUtility.FromJson<JsonParsing<ItemInfo>>(textAsset.text).list_itemInfo;
		for (int i = 0; i < list_itemInfo.Count; i++)
		{
			dict_itemInfo.Add(list_itemInfo[i].id, list_itemInfo[i]);
		}
		textAsset = Resources.Load("ItemInfos/ItemInfo_Hair_Item") as TextAsset;
		list_itemInfo.Clear();
		list_itemInfo = JsonUtility.FromJson<JsonParsing<ItemInfo>>(textAsset.text).list_itemInfo;
		for (int j = 0; j < list_itemInfo.Count; j++)
		{
			dict_itemInfo.Add(list_itemInfo[j].id, list_itemInfo[j]);
		}
		textAsset = Resources.Load("ItemInfos/ItemInfo_Wear_Item") as TextAsset;
		list_itemInfo.Clear();
		list_itemInfo = JsonUtility.FromJson<JsonParsing<ItemInfo>>(textAsset.text).list_itemInfo;
		for (int k = 0; k < list_itemInfo.Count; k++)
		{
			dict_itemInfo.Add(list_itemInfo[k].id, list_itemInfo[k]);
		}
		textAsset = Resources.Load("ItemInfos/ItemInfo_Acc_Item") as TextAsset;
		list_itemInfo.Clear();
		list_itemInfo = JsonUtility.FromJson<JsonParsing<ItemInfo>>(textAsset.text).list_itemInfo;
		for (int l = 0; l < list_itemInfo.Count; l++)
		{
			dict_itemInfo.Add(list_itemInfo[l].id, list_itemInfo[l]);
		}
		dict_itemSlotInfos = new Dictionary<string, ItemSlotInfo>[2];
		for (int m = 0; m < dict_itemSlotInfos.Length; m++)
		{
			dict_itemSlotInfos[m] = new Dictionary<string, ItemSlotInfo>();
			textAsset = ((m != 0) ? (Resources.Load("ItemInfos/ItemInfo_Face_F_ItemUISlot") as TextAsset) : (Resources.Load("ItemInfos/ItemInfo_Face_M_ItemUISlot") as TextAsset));
			List<ItemSlotInfo> list_itemInfo2 = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
			for (int n = 0; n < list_itemInfo2.Count; n++)
			{
				dict_itemSlotInfos[m].Add(list_itemInfo2[n].id, list_itemInfo2[n]);
			}
			textAsset = ((m != 0) ? (Resources.Load("ItemInfos/ItemInfo_Hair_F_ItemUISlot") as TextAsset) : (Resources.Load("ItemInfos/ItemInfo_Hair_M_ItemUISlot") as TextAsset));
			List<ItemSlotInfo> list_itemInfo3 = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
			for (int num = 0; num < list_itemInfo3.Count; num++)
			{
				dict_itemSlotInfos[m].Add(list_itemInfo3[num].id, list_itemInfo3[num]);
			}
			textAsset = ((m != 0) ? (Resources.Load("ItemInfos/ItemInfo_Wear_F_ItemUISlot") as TextAsset) : (Resources.Load("ItemInfos/ItemInfo_Wear_M_ItemUISlot") as TextAsset));
			List<ItemSlotInfo> list_itemInfo4 = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
			for (int num2 = 0; num2 < list_itemInfo4.Count; num2++)
			{
				dict_itemSlotInfos[m].Add(list_itemInfo4[num2].id, list_itemInfo4[num2]);
			}
			textAsset = ((m != 0) ? (Resources.Load("ItemInfos/ItemInfo_Acc_F_ItemUISlot") as TextAsset) : (Resources.Load("ItemInfos/ItemInfo_Acc_M_ItemUISlot") as TextAsset));
			List<ItemSlotInfo> list_itemInfo5 = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
			for (int num3 = 0; num3 < list_itemInfo5.Count; num3++)
			{
				dict_itemSlotInfos[m].Add(list_itemInfo5[num3].id, list_itemInfo5[num3]);
			}
		}
		isInit = true;
	}

	public bool IsInit()
	{
		return isInit;
	}

	public ItemInfo GetItemInfo(string _id)
	{
		Init();
		if (dict_itemInfo.ContainsKey(_id))
		{
			return dict_itemInfo[_id];
		}
		return null;
	}

	public ItemSlotInfo GetItemSlotInfo(int genderNum, string _id)
	{
		Init();
		if (dict_itemSlotInfos[genderNum].ContainsKey(_id))
		{
			return dict_itemSlotInfos[genderNum][_id];
		}
		return null;
	}
}
public enum ItemUIPart
{
	Face,
	Hair,
	Wear,
	Acc
}
public class CustomizeItemCtrl : CustomizeProp
{
	public class CachingData
	{
		public MeshFilter meshFilter;

		public MeshRenderer meshRenderer;
	}

	public ItemSlotInfo slotInfo;

	public ItemUIPart item_part;

	private Vector3 pos_orizin;

	private Quaternion rot_orizin;

	private PropState propState;

	private Transform handTr;

	private int handNum;

	public bool isLock;

	private CachingData[] cachingDatas;

	private void Start()
	{
		pos_orizin = base.transform.position;
		rot_orizin = base.transform.rotation;
		switch (item_part)
		{
		case ItemUIPart.Face:
		{
			cachingDatas = new CachingData[1];
			Transform transform4 = base.transform.Find("ITEM_HEAD");
			cachingDatas[0] = new CachingData();
			cachingDatas[0].meshFilter = transform4.GetComponent<MeshFilter>();
			cachingDatas[0].meshRenderer = transform4.GetComponent<MeshRenderer>();
			break;
		}
		case ItemUIPart.Hair:
		{
			cachingDatas = new CachingData[4];
			Transform transform2 = null;
			for (int j = 0; j < cachingDatas.Length; j++)
			{
				switch (j)
				{
				case 0:
					transform2 = base.transform.Find("ITEM_HEAD");
					break;
				case 1:
					transform2 = base.transform.Find("ITEM_HAIR_F");
					break;
				case 2:
					transform2 = base.transform.Find("ITEM_HAIR_B");
					break;
				}
				cachingDatas[j] = new CachingData();
				cachingDatas[j].meshFilter = transform2.GetComponent<MeshFilter>();
				cachingDatas[j].meshRenderer = transform2.GetComponent<MeshRenderer>();
			}
			break;
		}
		case ItemUIPart.Wear:
		{
			cachingDatas = new CachingData[3];
			Transform transform3 = null;
			for (int k = 0; k < cachingDatas.Length; k++)
			{
				switch (k)
				{
				case 0:
					transform3 = base.transform.Find("ITEM_UPPER");
					break;
				case 1:
					transform3 = base.transform.Find("ITEM_LOWER");
					break;
				case 2:
					transform3 = base.transform.Find("ITEM_LOWER_SUB");
					break;
				}
				cachingDatas[k] = new CachingData();
				cachingDatas[k].meshFilter = transform3.GetComponent<MeshFilter>();
				cachingDatas[k].meshRenderer = transform3.GetComponent<MeshRenderer>();
			}
			break;
		}
		case ItemUIPart.Acc:
		{
			cachingDatas = new CachingData[1];
			Transform transform = null;
			for (int i = 0; i < cachingDatas.Length; i++)
			{
				if (i == 0)
				{
					transform = base.transform.Find("ITEM_HEAD_ACC");
				}
				cachingDatas[i] = new CachingData();
				cachingDatas[i].meshFilter = transform.GetComponent<MeshFilter>();
				cachingDatas[i].meshRenderer = transform.GetComponent<MeshRenderer>();
			}
			break;
		}
		}
		SingletonBase.Singleton<CustomizeManager>.GetInstance.InitItemSlot(this);
	}

	public override Vector3 GetCenterPos()
	{
		return base.transform.position;
	}

	public void SetPropState(PropState _propState, Transform _handTr = null, int _handNum = 0)
	{
		propState = _propState;
		if (propState == PropState.Grab && _handTr != null)
		{
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play((int)UnityEngine.Random.Range(0f, 2.9999f));
			handTr = _handTr;
			handNum = _handNum;
		}
	}

	public void SetIdlePos()
	{
		base.transform.position = pos_orizin;
		base.transform.rotation = rot_orizin;
	}

	public override void SetSize(bool isSelect)
	{
		if (isSelect)
		{
			base.transform.localScale = Vector3.one * 1.2f;
		}
		else
		{
			base.transform.localScale = Vector3.one;
		}
	}

	private void LateUpdate()
	{
		switch (propState)
		{
		case PropState.Idle:
			base.transform.position = Vector3.MoveTowards(base.transform.position, pos_orizin, Time.deltaTime * 7f);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, rot_orizin, Time.deltaTime * 700f);
			break;
		case PropState.Grab:
		{
			Vector3 target = handTr.position + handTr.forward * -0.05f + ((handNum == 0) ? (-handTr.right) : handTr.right) * ((item_part == ItemUIPart.Face) ? (-0.11f) : (-0.08f));
			base.transform.position = Vector3.MoveTowards(base.transform.position, target, Time.deltaTime * 5f);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, handTr.rotation * Quaternion.Euler(0f, 90f, -45f), Time.deltaTime * 500f);
			break;
		}
		case PropState.Set:
		{
			Transform transform = ((item_part != ItemUIPart.Wear) ? SingletonBase.Singleton<CustomizeManager>.GetInstance.customSetPos_head : SingletonBase.Singleton<CustomizeManager>.GetInstance.customSetPos_body);
			base.transform.position = Vector3.MoveTowards(base.transform.position, transform.position, Time.deltaTime * 3f);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, transform.rotation, Time.deltaTime * 500f);
			if ((base.transform.position - transform.position).sqrMagnitude <= 0.0001f)
			{
				SingletonBase.Singleton<CustomizeManager>.GetInstance.characterCtrl.SetItem(slotInfo);
				SetIdlePos();
				propState = PropState.Idle;
			}
			break;
		}
		}
	}

	public void SetSlot(ItemSlotInfo _slotInfo)
	{
		slotInfo = _slotInfo;
		if (slotInfo == null)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		base.gameObject.SetActive(value: true);
		switch (item_part)
		{
		case ItemUIPart.Face:
		{
			int selectGenderNum4 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
			cachingDatas[0].meshFilter.sharedMesh = SingletonBase.Singleton<CustomizeManager>.GetInstance.meshes_head[selectGenderNum4];
			Material material = cachingDatas[0].meshRenderer.material;
			material.SetTexture("_SubTex_Eye", null);
			material.SetTexture("_SubTex_Pupil", null);
			material.SetTexture("_SubTex_Eyebrow", null);
			material.SetTexture("_SubTex_Mouth", null);
			material.SetTexture("_BaseTex", null);
			for (int l = 0; l < _slotInfo.list_partId.Count; l++)
			{
				switch (_slotInfo.list_partId[l][1])
				{
				case '0':
					material.SetTexture("_SubTex_Eye", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(slotInfo.list_partId[l]).matPath));
					break;
				case '1':
					material.SetTexture("_SubTex_Pupil", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(slotInfo.list_partId[l]).matPath));
					break;
				case '2':
					material.SetTexture("_SubTex_Eyebrow", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(slotInfo.list_partId[l]).matPath));
					break;
				case '3':
					material.SetTexture("_SubTex_Mouth", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(slotInfo.list_partId[l]).matPath));
					break;
				case '4':
					material.SetTexture("_BaseTex", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(slotInfo.list_partId[l]).matPath));
					break;
				}
			}
			if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Skin), out var color7))
			{
				material.SetColor("_BaseColor", color7);
			}
			if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eye), out color7))
			{
				material.SetColor("_EyeColor", color7);
			}
			if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eyebrow), out color7))
			{
				material.SetColor("_EyebrowColor", color7);
			}
			base.gameObject.SetActive(SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum4].ID_Face_I != slotInfo.id);
			break;
		}
		case ItemUIPart.Hair:
		{
			int selectGenderNum3 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
			cachingDatas[0].meshFilter.sharedMesh = SingletonBase.Singleton<CustomizeManager>.GetInstance.meshes_head[selectGenderNum3];
			cachingDatas[1].meshFilter.gameObject.SetActive(value: false);
			cachingDatas[2].meshFilter.gameObject.SetActive(value: false);
			cachingDatas[3].meshFilter.gameObject.SetActive(value: false);
			for (int k = 0; k < _slotInfo.list_partId.Count; k++)
			{
				switch (_slotInfo.list_partId[k][1])
				{
				case '0':
				{
					ItemInfo itemInfo6 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[k]);
					cachingDatas[1].meshFilter.sharedMesh = Resources.Load<Mesh>("Customize/Hairs/" + itemInfo6.meshPath);
					cachingDatas[1].meshRenderer.material = Resources.Load<Material>("Customize/Hairs/" + itemInfo6.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Hair), out var color6))
					{
						cachingDatas[1].meshRenderer.material.SetColor("_BaseColor", color6);
					}
					cachingDatas[1].meshFilter.gameObject.SetActive(value: true);
					break;
				}
				case '1':
				{
					ItemInfo itemInfo5 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[k]);
					cachingDatas[2].meshFilter.sharedMesh = Resources.Load<Mesh>("Customize/Hairs/" + itemInfo5.meshPath);
					cachingDatas[2].meshRenderer.material = Resources.Load<Material>("Customize/Hairs/" + itemInfo5.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Hair), out var color5))
					{
						cachingDatas[2].meshRenderer.material.SetColor("_BaseColor", color5);
					}
					cachingDatas[2].meshFilter.gameObject.SetActive(value: true);
					break;
				}
				}
			}
			base.gameObject.SetActive(SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum3].ID_Hair_I != slotInfo.id);
			break;
		}
		case ItemUIPart.Wear:
		{
			int selectGenderNum2 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
			cachingDatas[0].meshFilter.gameObject.SetActive(value: false);
			cachingDatas[1].meshFilter.gameObject.SetActive(value: false);
			cachingDatas[2].meshFilter.gameObject.SetActive(value: false);
			for (int j = 0; j < _slotInfo.list_partId.Count; j++)
			{
				switch (_slotInfo.list_partId[j][1])
				{
				case '0':
				{
					ItemInfo itemInfo4 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[j]);
					cachingDatas[0].meshFilter.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo4.meshPath);
					cachingDatas[0].meshRenderer.material = Resources.Load<Material>("Customize/Wears/" + itemInfo4.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Upper), out var color4))
					{
						cachingDatas[0].meshRenderer.material.SetColor("_BaseColor", color4);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color4))
					{
						cachingDatas[0].meshRenderer.material.SetColor("_PatternColor", color4);
					}
					cachingDatas[0].meshRenderer.material.SetColor("_Color_R", Color.white);
					cachingDatas[0].meshRenderer.material.SetColor("_Color_G", Color.white);
					cachingDatas[0].meshRenderer.material.SetColor("_Color_B", Color.white);
					cachingDatas[0].meshFilter.gameObject.SetActive(value: true);
					break;
				}
				case '2':
				{
					ItemInfo itemInfo3 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[j]);
					cachingDatas[1].meshFilter.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo3.meshPath);
					cachingDatas[1].meshRenderer.material = Resources.Load<Material>("Customize/Wears/" + itemInfo3.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Lower), out var color3))
					{
						cachingDatas[1].meshRenderer.material.SetColor("_BaseColor", color3);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color3))
					{
						cachingDatas[1].meshRenderer.material.SetColor("_PatternColor", color3);
					}
					cachingDatas[1].meshRenderer.material.SetColor("_Color_R", Color.white);
					cachingDatas[1].meshRenderer.material.SetColor("_Color_G", Color.white);
					cachingDatas[1].meshRenderer.material.SetColor("_Color_B", Color.white);
					cachingDatas[1].meshFilter.gameObject.SetActive(value: true);
					break;
				}
				case '3':
				{
					ItemInfo itemInfo2 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[j]);
					cachingDatas[2].meshFilter.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo2.meshPath);
					cachingDatas[2].meshRenderer.material = Resources.Load<Material>("Customize/Wears/" + itemInfo2.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Lower), out var color2))
					{
						cachingDatas[2].meshRenderer.material.SetColor("_BaseColor", color2);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color2))
					{
						cachingDatas[2].meshRenderer.material.SetColor("_PatternColor", color2);
					}
					cachingDatas[2].meshRenderer.material.SetColor("_Color_R", Color.white);
					cachingDatas[2].meshRenderer.material.SetColor("_Color_G", Color.white);
					cachingDatas[2].meshRenderer.material.SetColor("_Color_B", Color.white);
					cachingDatas[2].meshFilter.gameObject.SetActive(value: true);
					break;
				}
				}
			}
			base.gameObject.SetActive(SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum2].ID_Wear_I != slotInfo.id);
			break;
		}
		case ItemUIPart.Acc:
		{
			int selectGenderNum = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
			if (_slotInfo.list_partId[0] == "40000")
			{
				cachingDatas[0].meshFilter.sharedMesh = SingletonBase.Singleton<CustomizeManager>.GetInstance.meshes_head[selectGenderNum];
				cachingDatas[0].meshRenderer.material = Resources.Load<Material>("Customize/Bodies/Mat_Custom_Face");
			}
			else
			{
				for (int i = 0; i < _slotInfo.list_partId.Count; i++)
				{
					ItemInfo itemInfo = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[i]);
					cachingDatas[0].meshFilter.sharedMesh = Resources.Load<Mesh>("Customize/Accs/" + itemInfo.meshPath);
					cachingDatas[0].meshRenderer.material = Resources.Load<Material>("Customize/Accs/" + itemInfo.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Acc), out var color))
					{
						cachingDatas[0].meshRenderer.material.SetColor("_BaseColor", color);
					}
				}
			}
			base.gameObject.SetActive(SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum].ID_Acc_I != slotInfo.id);
			break;
		}
		}
	}

	public void SetColor(ColorUIPart part, string setHexColor)
	{
		Color color;
		switch (part)
		{
		case ColorUIPart.Skin:
			if (ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[0].meshRenderer.material.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Eye:
			if (ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[0].meshRenderer.material.SetColor("_EyeColor", color);
			}
			break;
		case ColorUIPart.Eyebrow:
			if (ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[0].meshRenderer.material.SetColor("_EyebrowColor", color);
			}
			break;
		case ColorUIPart.Hair:
			if (ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[1].meshRenderer.material.SetColor("_BaseColor", color);
				cachingDatas[2].meshRenderer.material.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Upper:
			if (ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[0].meshRenderer.material.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Lower:
			if (ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[1].meshRenderer.material.SetColor("_BaseColor", color);
				cachingDatas[2].meshRenderer.material.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Pattern:
			if (ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[0].meshRenderer.material.SetColor("_PatternColor", color);
				cachingDatas[1].meshRenderer.material.SetColor("_PatternColor", color);
				cachingDatas[2].meshRenderer.material.SetColor("_PatternColor", color);
			}
			break;
		case ColorUIPart.Acc:
			if (slotInfo != null && slotInfo.list_partId.Count != 0 && !(slotInfo.list_partId[0] == "40000") && ColorUtility.TryParseHtmlString("#" + setHexColor, out color))
			{
				cachingDatas[0].meshRenderer.material.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Foot:
			break;
		}
	}
}
[Serializable]
public class ItemInfo
{
	public string id;

	public string name;

	public string meshPath;

	public string matPath;

	public ItemInfo(int group, string csv)
	{
		string[] array = csv.Split(',');
		id = group.ToString() + array[2][0] + array[0];
		name = array[1];
		if (group != 1)
		{
			meshPath = array[3];
			matPath = array[4].Split('\r')[0];
		}
		else
		{
			matPath = array[3].Split('\r')[0];
		}
	}
}
[Serializable]
public class ItemSlotInfo
{
	public string id;

	public string name;

	public List<string> list_partId;

	public ItemSlotInfo(int group, string csv)
	{
		string[] array = csv.Split(',');
		id = group + array[0];
		name = array[1];
		list_partId = new List<string>();
		for (int i = 2; i < array.Length; i++)
		{
			if (array[i] != "" && array[i] != "\r")
			{
				list_partId.Add(group.ToString() + (i - 2) + array[i].Split('\r')[0]);
			}
		}
	}
}
[Serializable]
public class WearInfo
{
	public Vector3 bounds_center;

	public Vector3 bounds_extent;

	public int rootBone;

	public int[] bones;
}
[Serializable]
public class AccInfo
{
	public Vector3 pos;

	public Vector3 scale;
}
[Serializable]
public class JsonParsing<T> where T : class
{
	public List<T> list_itemInfo;

	public JsonParsing(int group, string csvName)
	{
		string[] array = File.ReadAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/" + csvName).Split('\n');
		list_itemInfo = new List<T>();
		if (typeof(T) == typeof(ItemInfo))
		{
			for (int i = 1; i < array.Length; i++)
			{
				list_itemInfo.Add(new ItemInfo(group, array[i]) as T);
			}
		}
		else if (typeof(T) == typeof(ItemSlotInfo))
		{
			for (int j = 1; j < array.Length; j++)
			{
				list_itemInfo.Add(new ItemSlotInfo(group, array[j]) as T);
			}
		}
	}
}
public abstract class CustomizeProp : MonoBehaviour
{
	public abstract Vector3 GetCenterPos();

	public abstract void SetSize(bool isSelect);
}
public class CustomizeManager : SingletonBase.Singleton<CustomizeManager>
{
	[Serializable]
	public class LockPropInfo
	{
		public string slot_id;

		public string api_name;
	}

	[Serializable]
	public class AllModelData
	{
		public CustomModelData[] modelDatas;
	}

	private List<ItemSlotInfo> list_itemSlot_face_M = new List<ItemSlotInfo>();

	private List<ItemSlotInfo> list_itemSlot_hair_M = new List<ItemSlotInfo>();

	private List<ItemSlotInfo> list_itemSlot_wear_M = new List<ItemSlotInfo>();

	private List<ItemSlotInfo> list_itemSlot_acc_M = new List<ItemSlotInfo>();

	private List<ItemSlotInfo> list_itemSlot_face_F = new List<ItemSlotInfo>();

	private List<ItemSlotInfo> list_itemSlot_hair_F = new List<ItemSlotInfo>();

	private List<ItemSlotInfo> list_itemSlot_wear_F = new List<ItemSlotInfo>();

	private List<ItemSlotInfo> list_itemSlot_acc_F = new List<ItemSlotInfo>();

	private List<CustomizeProp> list_ui_prop = new List<CustomizeProp>();

	private CustomizeItemCtrl[] items_face = new CustomizeItemCtrl[9];

	private CustomizeItemCtrl[] items_hair = new CustomizeItemCtrl[9];

	private CustomizeItemCtrl[] items_wear = new CustomizeItemCtrl[9];

	private CustomizeItemCtrl[] items_acc = new CustomizeItemCtrl[9];

	private UIPageCtrl[] uiPages = new UIPageCtrl[4];

	private int page_max_face;

	private int page_current_face;

	private int page_max_hair;

	private int page_current_hair;

	private int page_max_wear;

	private int page_current_wear;

	private int page_max_acc;

	private int page_current_acc;

	public ColorPaletteCtrl colorPalette;

	private bool isInit;

	private CustomizeProp[] keep_items = new CustomizeProp[2];

	public Transform customSetPos_head;

	public Transform customSetPos_body;

	public MyCharacterCtrl characterCtrl;

	public AllModelData modelData;

	public int selectGenderNum;

	public MeshButtonCtrl[] buttons_gender;

	public Mesh[] meshes_head;

	public Material[] materials_customUI;

	public GameObject[] icons_lock;

	public LockPropInfo[] lockPropInfos;

	private string keep_check_id;

	public Text text_lock;

	private Coroutine setUICoroutine;

	private void Start()
	{
		isInit = false;
		keep_check_id = "";
		text_lock.transform.parent.gameObject.SetActive(value: false);
		_ = (bool)PublicGameUIManager.GetInstance;
		Read_UIInfo();
		Download_UserData();
		Invoke("SetAchieve", 1.5f);
	}

	private void SetAchieve()
	{
		SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach10", 1);
	}

	public void Read_UIInfo()
	{
		materials_customUI = new Material[2];
		materials_customUI[0] = Resources.Load<Material>("UI/Mat_CustomUI");
		materials_customUI[1] = Resources.Load<Material>("UI/Mat_CustomUI_Light");
		meshes_head = new Mesh[2];
		meshes_head[0] = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_HEAD");
		meshes_head[1] = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_HEAD");
		list_itemSlot_face_M = new List<ItemSlotInfo>();
		TextAsset textAsset = Resources.Load("ItemInfos/ItemInfo_Face_M_ItemUISlot") as TextAsset;
		list_itemSlot_face_M = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_face_F = new List<ItemSlotInfo>();
		textAsset = Resources.Load("ItemInfos/ItemInfo_Face_F_ItemUISlot") as TextAsset;
		list_itemSlot_face_F = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_hair_M = new List<ItemSlotInfo>();
		textAsset = Resources.Load("ItemInfos/ItemInfo_Hair_M_ItemUISlot") as TextAsset;
		list_itemSlot_hair_M = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_hair_F = new List<ItemSlotInfo>();
		textAsset = Resources.Load("ItemInfos/ItemInfo_Hair_F_ItemUISlot") as TextAsset;
		list_itemSlot_hair_F = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_wear_M = new List<ItemSlotInfo>();
		textAsset = Resources.Load("ItemInfos/ItemInfo_Wear_M_ItemUISlot") as TextAsset;
		list_itemSlot_wear_M = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_wear_F = new List<ItemSlotInfo>();
		textAsset = Resources.Load("ItemInfos/ItemInfo_Wear_F_ItemUISlot") as TextAsset;
		list_itemSlot_wear_F = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_acc_M = new List<ItemSlotInfo>();
		textAsset = Resources.Load("ItemInfos/ItemInfo_Acc_M_ItemUISlot") as TextAsset;
		list_itemSlot_acc_M = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_acc_F = new List<ItemSlotInfo>();
		textAsset = Resources.Load("ItemInfos/ItemInfo_Acc_F_ItemUISlot") as TextAsset;
		list_itemSlot_acc_F = JsonUtility.FromJson<JsonParsing<ItemSlotInfo>>(textAsset.text).list_itemInfo;
		list_itemSlot_face_M.Reverse();
		list_itemSlot_face_F.Reverse();
		list_itemSlot_hair_M.Reverse();
		list_itemSlot_hair_F.Reverse();
		list_itemSlot_wear_M.Reverse();
		list_itemSlot_wear_F.Reverse();
		list_itemSlot_acc_M.Reverse(1, list_itemSlot_acc_M.Count - 1);
		list_itemSlot_acc_F.Reverse(1, list_itemSlot_acc_M.Count - 1);
	}

	private IEnumerator InitData()
	{
		while (!SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.IsInit())
		{
			yield return null;
		}
		for (int m = 0; m < items_face.Length; m++)
		{
			while (items_face[m] == null)
			{
				yield return null;
			}
		}
		for (int m = 0; m < items_hair.Length; m++)
		{
			while (items_hair[m] == null)
			{
				yield return null;
			}
		}
		for (int m = 0; m < items_wear.Length; m++)
		{
			while (items_wear[m] == null)
			{
				yield return null;
			}
		}
		for (int m = 0; m < items_acc.Length; m++)
		{
			while (items_acc[m] == null)
			{
				yield return null;
			}
		}
		for (int m = 0; m < uiPages.Length; m++)
		{
			while (uiPages[m] == null)
			{
				yield return null;
			}
		}
		while (colorPalette == null)
		{
			yield return null;
		}
		characterCtrl.SetGender(selectGenderNum);
		isInit = true;
		SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.StartFade(_isFadeIn: true);
	}

	public void CheckSlotLock(CustomizeItemCtrl item)
	{
		if (item == null || keep_check_id == item.slotInfo.id)
		{
			return;
		}
		keep_check_id = item.slotInfo.id;
		if (item.isLock)
		{
			for (int i = 0; i < lockPropInfos.Length; i++)
			{
				if (lockPropInfos[i].slot_id == keep_check_id)
				{
					text_lock.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.GetAchieveInfo(lockPropInfos[i].api_name);
					text_lock.transform.parent.position = item.transform.position + item.transform.up * 0.1f + item.transform.right * -0.1f + item.transform.forward * -0.75f * item.transform.localPosition.x;
					text_lock.transform.parent.gameObject.SetActive(value: true);
					return;
				}
			}
		}
		text_lock.transform.parent.gameObject.SetActive(value: false);
	}

	public void SetUI()
	{
		if (setUICoroutine != null)
		{
			StopCoroutine(setUICoroutine);
		}
		setUICoroutine = StartCoroutine(SetUICoroutine());
	}

	private IEnumerator SetUICoroutine()
	{
		while (colorPalette == null)
		{
			yield return null;
		}
		colorPalette.SetSlot();
		switch (selectGenderNum)
		{
		case 0:
		{
			page_max_face = (list_itemSlot_face_M.Count - 1) / 9;
			int n;
			for (n = 0; n < list_itemSlot_face_M.Count && !(list_itemSlot_face_M[n].id == modelData.modelDatas[selectGenderNum].ID_Face_I); n++)
			{
			}
			page_current_face = (n - 1) / 9;
			uiPages[0].SetPage(page_current_face, page_max_face);
			page_max_hair = (list_itemSlot_hair_M.Count - 1) / 9;
			for (n = 0; n < list_itemSlot_hair_M.Count && !(list_itemSlot_hair_M[n].id == modelData.modelDatas[selectGenderNum].ID_Hair_I); n++)
			{
			}
			page_current_hair = (n - 1) / 9;
			uiPages[1].SetPage(page_current_hair, page_max_hair);
			page_max_wear = (list_itemSlot_wear_M.Count - 1) / 9;
			for (n = 0; n < list_itemSlot_wear_M.Count && !(list_itemSlot_wear_M[n].id == modelData.modelDatas[selectGenderNum].ID_Wear_I); n++)
			{
			}
			page_current_wear = (n - 1) / 9;
			uiPages[2].SetPage(page_current_wear, page_max_wear);
			page_max_acc = (list_itemSlot_acc_M.Count - 1) / 9;
			for (n = 0; n < list_itemSlot_acc_M.Count && !(list_itemSlot_acc_M[n].id == modelData.modelDatas[selectGenderNum].ID_Acc_I); n++)
			{
			}
			page_current_acc = (n - 1) / 9;
			uiPages[3].SetPage(page_current_acc, page_max_acc);
			break;
		}
		case 1:
		{
			page_max_face = (list_itemSlot_face_F.Count - 1) / 9;
			int m;
			for (m = 0; m < list_itemSlot_face_F.Count && !(list_itemSlot_face_F[m].id == modelData.modelDatas[selectGenderNum].ID_Face_I); m++)
			{
			}
			page_current_face = (m - 1) / 9;
			uiPages[0].SetPage(page_current_face, page_max_face);
			page_max_hair = (list_itemSlot_hair_F.Count - 1) / 9;
			for (m = 0; m < list_itemSlot_hair_F.Count && !(list_itemSlot_hair_F[m].id == modelData.modelDatas[selectGenderNum].ID_Hair_I); m++)
			{
			}
			page_current_hair = (m - 1) / 9;
			uiPages[1].SetPage(page_current_hair, page_max_hair);
			page_max_wear = (list_itemSlot_wear_F.Count - 1) / 9;
			for (m = 0; m < list_itemSlot_wear_F.Count && !(list_itemSlot_wear_F[m].id == modelData.modelDatas[selectGenderNum].ID_Wear_I); m++)
			{
			}
			page_current_wear = (m - 1) / 9;
			uiPages[2].SetPage(page_current_wear, page_max_wear);
			page_max_acc = (list_itemSlot_acc_F.Count - 1) / 9;
			for (m = 0; m < list_itemSlot_acc_F.Count && !(list_itemSlot_acc_F[m].id == modelData.modelDatas[selectGenderNum].ID_Acc_I); m++)
			{
			}
			page_current_acc = (m - 1) / 9;
			uiPages[3].SetPage(page_current_acc, page_max_acc);
			break;
		}
		}
		for (int l = 0; l < items_face.Length; l++)
		{
			while (items_face[l] == null)
			{
				yield return null;
			}
			switch (selectGenderNum)
			{
			case 0:
				if (page_current_face * 9 + l < list_itemSlot_face_M.Count)
				{
					items_face[l].SetSlot(list_itemSlot_face_M[page_current_face * 9 + l]);
				}
				else
				{
					items_face[l].SetSlot(null);
				}
				break;
			case 1:
				if (page_current_face * 9 + l < list_itemSlot_face_F.Count)
				{
					items_face[l].SetSlot(list_itemSlot_face_F[page_current_face * 9 + l]);
				}
				else
				{
					items_face[l].SetSlot(null);
				}
				break;
			}
		}
		for (int l = 0; l < items_hair.Length; l++)
		{
			while (items_hair[l] == null)
			{
				yield return null;
			}
			switch (selectGenderNum)
			{
			case 0:
				if (page_current_hair * 9 + l < list_itemSlot_hair_M.Count)
				{
					items_hair[l].SetSlot(list_itemSlot_hair_M[page_current_hair * 9 + l]);
				}
				else
				{
					items_hair[l].SetSlot(null);
				}
				break;
			case 1:
				if (page_current_hair * 9 + l < list_itemSlot_hair_F.Count)
				{
					items_hair[l].SetSlot(list_itemSlot_hair_F[page_current_hair * 9 + l]);
				}
				else
				{
					items_hair[l].SetSlot(null);
				}
				break;
			}
		}
		for (int l = 0; l < items_wear.Length; l++)
		{
			while (items_wear[l] == null)
			{
				yield return null;
			}
			switch (selectGenderNum)
			{
			case 0:
				if (page_current_wear * 9 + l < list_itemSlot_wear_M.Count)
				{
					items_wear[l].SetSlot(list_itemSlot_wear_M[page_current_wear * 9 + l]);
				}
				else
				{
					items_wear[l].SetSlot(null);
				}
				break;
			case 1:
				if (page_current_wear * 9 + l < list_itemSlot_wear_F.Count)
				{
					items_wear[l].SetSlot(list_itemSlot_wear_F[page_current_wear * 9 + l]);
				}
				else
				{
					items_wear[l].SetSlot(null);
				}
				break;
			}
		}
		for (int l = 0; l < items_acc.Length; l++)
		{
			while (items_acc[l] == null)
			{
				yield return null;
			}
			int num = page_current_acc * 9 + l;
			switch (selectGenderNum)
			{
			case 0:
				if (num < list_itemSlot_acc_M.Count)
				{
					items_acc[l].SetSlot(list_itemSlot_acc_M[num]);
				}
				else
				{
					items_acc[l].SetSlot(null);
				}
				break;
			case 1:
				if (num < list_itemSlot_acc_F.Count)
				{
					items_acc[l].SetSlot(list_itemSlot_acc_F[num]);
				}
				else
				{
					items_acc[l].SetSlot(null);
				}
				break;
			}
			int num2;
			for (num2 = 0; num2 < lockPropInfos.Length; num2++)
			{
				if (items_acc[l].slotInfo != null && lockPropInfos[num2].slot_id == items_acc[l].slotInfo.id)
				{
					if (lockPropInfos[num2].api_name == "-" || SingletonBase.Singleton<UserInfoManager>.GetInstance.IsUnlockAchieve(lockPropInfos[num2].api_name))
					{
						items_acc[l].isLock = false;
						icons_lock[l].SetActive(value: false);
					}
					else
					{
						items_acc[l].isLock = true;
						icons_lock[l].SetActive(value: true);
					}
					break;
				}
			}
			if (num2 == lockPropInfos.Length)
			{
				items_acc[l].isLock = false;
				icons_lock[l].SetActive(value: false);
			}
		}
	}

	public void SetNextPage(int state)
	{
		switch (state)
		{
		case 0:
		{
			if (page_current_face + 1 > page_max_face)
			{
				break;
			}
			page_current_face++;
			for (int l = 0; l < items_face.Length && !(items_face[l] == null); l++)
			{
				switch (selectGenderNum)
				{
				case 0:
					if (page_current_face * 9 + l < list_itemSlot_face_M.Count)
					{
						items_face[l].SetSlot(list_itemSlot_face_M[page_current_face * 9 + l]);
					}
					else
					{
						items_face[l].SetSlot(null);
					}
					break;
				case 1:
					if (page_current_face * 9 + l < list_itemSlot_face_F.Count)
					{
						items_face[l].SetSlot(list_itemSlot_face_F[page_current_face * 9 + l]);
					}
					else
					{
						items_face[l].SetSlot(null);
					}
					break;
				}
			}
			uiPages[state].SetPage(page_current_face, page_max_face);
			break;
		}
		case 1:
		{
			if (page_current_hair + 1 > page_max_hair)
			{
				break;
			}
			page_current_hair++;
			for (int m = 0; m < items_hair.Length && !(items_hair[m] == null); m++)
			{
				switch (selectGenderNum)
				{
				case 0:
					if (page_current_hair * 9 + m < list_itemSlot_hair_M.Count)
					{
						items_hair[m].SetSlot(list_itemSlot_hair_M[page_current_hair * 9 + m]);
					}
					else
					{
						items_hair[m].SetSlot(null);
					}
					break;
				case 1:
					if (page_current_hair * 9 + m < list_itemSlot_hair_F.Count)
					{
						items_hair[m].SetSlot(list_itemSlot_hair_F[page_current_hair * 9 + m]);
					}
					else
					{
						items_hair[m].SetSlot(null);
					}
					break;
				}
			}
			uiPages[state].SetPage(page_current_hair, page_max_hair);
			break;
		}
		case 2:
		{
			if (page_current_wear + 1 > page_max_wear)
			{
				break;
			}
			page_current_wear++;
			for (int k = 0; k < items_wear.Length && !(items_wear[k] == null); k++)
			{
				switch (selectGenderNum)
				{
				case 0:
					if (page_current_wear * 9 + k < list_itemSlot_wear_M.Count)
					{
						items_wear[k].SetSlot(list_itemSlot_wear_M[page_current_wear * 9 + k]);
					}
					else
					{
						items_wear[k].SetSlot(null);
					}
					break;
				case 1:
					if (page_current_wear * 9 + k < list_itemSlot_wear_F.Count)
					{
						items_wear[k].SetSlot(list_itemSlot_wear_F[page_current_wear * 9 + k]);
					}
					else
					{
						items_wear[k].SetSlot(null);
					}
					break;
				}
			}
			uiPages[state].SetPage(page_current_wear, page_max_wear);
			break;
		}
		case 3:
		{
			if (page_current_acc + 1 > page_max_acc)
			{
				break;
			}
			page_current_acc++;
			for (int i = 0; i < items_acc.Length && !(items_acc[i] == null); i++)
			{
				int num = page_current_acc * 9 + i;
				switch (selectGenderNum)
				{
				case 0:
					if (num < list_itemSlot_acc_M.Count)
					{
						items_acc[i].SetSlot(list_itemSlot_acc_M[num]);
					}
					else
					{
						items_acc[i].SetSlot(null);
					}
					break;
				case 1:
					if (num < list_itemSlot_acc_F.Count)
					{
						items_acc[i].SetSlot(list_itemSlot_acc_F[num]);
					}
					else
					{
						items_acc[i].SetSlot(null);
					}
					break;
				}
				int j;
				for (j = 0; j < lockPropInfos.Length; j++)
				{
					if (items_acc[i].slotInfo != null && lockPropInfos[j].slot_id == items_acc[i].slotInfo.id)
					{
						if (lockPropInfos[j].api_name == "-" || SingletonBase.Singleton<UserInfoManager>.GetInstance.IsUnlockAchieve(lockPropInfos[j].api_name))
						{
							items_acc[i].isLock = false;
							icons_lock[i].SetActive(value: false);
						}
						else
						{
							items_acc[i].isLock = true;
							icons_lock[i].SetActive(value: true);
						}
						break;
					}
				}
				if (j == lockPropInfos.Length)
				{
					items_acc[i].isLock = false;
					icons_lock[i].SetActive(value: false);
				}
			}
			uiPages[state].SetPage(page_current_acc, page_max_acc);
			break;
		}
		}
	}

	public void SetBackPage(int state)
	{
		switch (state)
		{
		case 0:
		{
			if (page_current_face - 1 < 0)
			{
				break;
			}
			page_current_face--;
			for (int l = 0; l < items_face.Length && !(items_face[l] == null); l++)
			{
				switch (selectGenderNum)
				{
				case 0:
					items_face[l].SetSlot(list_itemSlot_face_M[page_current_face * 9 + l]);
					break;
				case 1:
					items_face[l].SetSlot(list_itemSlot_face_F[page_current_face * 9 + l]);
					break;
				}
			}
			uiPages[state].SetPage(page_current_face, page_max_face);
			break;
		}
		case 1:
		{
			if (page_current_hair - 1 < 0)
			{
				break;
			}
			page_current_hair--;
			for (int m = 0; m < items_hair.Length && !(items_hair[m] == null); m++)
			{
				switch (selectGenderNum)
				{
				case 0:
					items_hair[m].SetSlot(list_itemSlot_hair_M[page_current_hair * 9 + m]);
					break;
				case 1:
					items_hair[m].SetSlot(list_itemSlot_hair_F[page_current_hair * 9 + m]);
					break;
				}
			}
			uiPages[state].SetPage(page_current_hair, page_max_hair);
			break;
		}
		case 2:
		{
			if (page_current_wear - 1 < 0)
			{
				break;
			}
			page_current_wear--;
			for (int k = 0; k < items_wear.Length && !(items_wear[k] == null); k++)
			{
				switch (selectGenderNum)
				{
				case 0:
					items_wear[k].SetSlot(list_itemSlot_wear_M[page_current_wear * 9 + k]);
					break;
				case 1:
					items_wear[k].SetSlot(list_itemSlot_wear_F[page_current_wear * 9 + k]);
					break;
				}
			}
			uiPages[state].SetPage(page_current_wear, page_max_wear);
			break;
		}
		case 3:
		{
			if (page_current_acc - 1 < 0)
			{
				break;
			}
			page_current_acc--;
			for (int i = 0; i < items_acc.Length && !(items_acc[i] == null); i++)
			{
				int index = page_current_acc * 9 + i;
				switch (selectGenderNum)
				{
				case 0:
					items_acc[i].SetSlot(list_itemSlot_acc_M[index]);
					break;
				case 1:
					items_acc[i].SetSlot(list_itemSlot_acc_F[index]);
					break;
				}
				int j;
				for (j = 0; j < lockPropInfos.Length; j++)
				{
					if (items_acc[i].slotInfo != null && lockPropInfos[j].slot_id == items_acc[i].slotInfo.id)
					{
						if (lockPropInfos[j].api_name == "-" || SingletonBase.Singleton<UserInfoManager>.GetInstance.IsUnlockAchieve(lockPropInfos[j].api_name))
						{
							items_acc[i].isLock = false;
							icons_lock[i].SetActive(value: false);
						}
						else
						{
							items_acc[i].isLock = true;
							icons_lock[i].SetActive(value: true);
						}
						break;
					}
				}
				if (j == lockPropInfos.Length)
				{
					items_acc[i].isLock = false;
					icons_lock[i].SetActive(value: false);
				}
			}
			uiPages[state].SetPage(page_current_acc, page_max_acc);
			break;
		}
		}
	}

	public void CSVToJson()
	{
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Face_Item.csv"))
		{
			string contents = JsonUtility.ToJson(new JsonParsing<ItemInfo>(1, "Sheet_ItemInfo - Face_Item.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Face_Item.json", contents);
			UnityEngine.Debug.Log("Save JsonFile - Face_Item");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Face_Item_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Face_M_ItemUISlot.csv"))
		{
			string contents2 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(1, "Sheet_ItemInfo - Face_M_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Face_M_ItemUISlot.json", contents2);
			UnityEngine.Debug.Log("Save JsonFile - Face_M_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Face_M_ItemUISlot_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Face_F_ItemUISlot.csv"))
		{
			string contents3 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(1, "Sheet_ItemInfo - Face_F_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Face_F_ItemUISlot.json", contents3);
			UnityEngine.Debug.Log("Save JsonFile - Face_F_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Face_F_ItemUISlot_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Hair_Item.csv"))
		{
			string contents4 = JsonUtility.ToJson(new JsonParsing<ItemInfo>(2, "Sheet_ItemInfo - Hair_Item.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Hair_Item.json", contents4);
			UnityEngine.Debug.Log("Save JsonFile - Hair_Item");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Hair_Item_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Hair_M_ItemUISlot.csv"))
		{
			string contents5 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(2, "Sheet_ItemInfo - Hair_M_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Hair_M_ItemUISlot.json", contents5);
			UnityEngine.Debug.Log("Save JsonFile - Hair_M_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Hair_M_ItemUISlot_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Hair_F_ItemUISlot.csv"))
		{
			string contents6 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(2, "Sheet_ItemInfo - Hair_F_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Hair_F_ItemUISlot.json", contents6);
			UnityEngine.Debug.Log("Save JsonFile - Hair_F_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Hair_F_ItemUISlot_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Wear_Item.csv"))
		{
			string contents7 = JsonUtility.ToJson(new JsonParsing<ItemInfo>(3, "Sheet_ItemInfo - Wear_Item.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Wear_Item.json", contents7);
			UnityEngine.Debug.Log("Save JsonFile - Wear_Item");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Wear_Item_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Wear_M_ItemUISlot.csv"))
		{
			string contents8 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(3, "Sheet_ItemInfo - Wear_M_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Wear_M_ItemUISlot.json", contents8);
			UnityEngine.Debug.Log("Save JsonFile - Wear_M_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Wear_M_ItemUISlot_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Wear_F_ItemUISlot.csv"))
		{
			string contents9 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(3, "Sheet_ItemInfo - Wear_F_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Wear_F_ItemUISlot.json", contents9);
			UnityEngine.Debug.Log("Save JsonFile - Wear_F_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Wear_F_ItemUISlot_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Acc_Item.csv"))
		{
			string contents10 = JsonUtility.ToJson(new JsonParsing<ItemInfo>(4, "Sheet_ItemInfo - Acc_Item.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Acc_Item.json", contents10);
			UnityEngine.Debug.Log("Save JsonFile - Acc_Item");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Acc_Item_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Acc_M_ItemUISlot.csv"))
		{
			string contents11 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(4, "Sheet_ItemInfo - Acc_M_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Acc_M_ItemUISlot.json", contents11);
			UnityEngine.Debug.Log("Save JsonFile - Acc_M_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Acc_M_ItemUISlot_Sheet");
		}
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_ItemInfo - Acc_F_ItemUISlot.csv"))
		{
			string contents12 = JsonUtility.ToJson(new JsonParsing<ItemSlotInfo>(4, "Sheet_ItemInfo - Acc_F_ItemUISlot.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/ItemInfo_Acc_F_ItemUISlot.json", contents12);
			UnityEngine.Debug.Log("Save JsonFile - Acc_F_ItemUISlot");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Acc_F_ItemUISlot_Sheet");
		}
	}

	public string GetColorInfo(ColorUIPart part)
	{
		return part switch
		{
			ColorUIPart.Skin => modelData.modelDatas[selectGenderNum].Hex_Skin_C, 
			ColorUIPart.Eye => modelData.modelDatas[selectGenderNum].Hex_Eye_C, 
			ColorUIPart.Eyebrow => modelData.modelDatas[selectGenderNum].Hex_Eyebrow_C, 
			ColorUIPart.Hair => modelData.modelDatas[selectGenderNum].Hex_Hair_C, 
			ColorUIPart.Upper => modelData.modelDatas[selectGenderNum].Hex_Upper_C, 
			ColorUIPart.Lower => modelData.modelDatas[selectGenderNum].Hex_Lower_C, 
			ColorUIPart.Foot => modelData.modelDatas[selectGenderNum].Hex_Foot_C, 
			ColorUIPart.Pattern => modelData.modelDatas[selectGenderNum].Hex_Pattern_C, 
			ColorUIPart.Acc => modelData.modelDatas[selectGenderNum].Hex_Acc_C, 
			_ => "000000", 
		};
	}

	public void SetColorInfo(ColorUIPart part, string hexColor)
	{
		switch (part)
		{
		case ColorUIPart.Skin:
			modelData.modelDatas[selectGenderNum].Hex_Skin_C = hexColor;
			break;
		case ColorUIPart.Eye:
			modelData.modelDatas[selectGenderNum].Hex_Eye_C = hexColor;
			break;
		case ColorUIPart.Eyebrow:
			modelData.modelDatas[selectGenderNum].Hex_Eyebrow_C = hexColor;
			break;
		case ColorUIPart.Hair:
			modelData.modelDatas[selectGenderNum].Hex_Hair_C = hexColor;
			break;
		case ColorUIPart.Upper:
			modelData.modelDatas[selectGenderNum].Hex_Upper_C = hexColor;
			break;
		case ColorUIPart.Lower:
			modelData.modelDatas[selectGenderNum].Hex_Lower_C = hexColor;
			break;
		case ColorUIPart.Foot:
			modelData.modelDatas[selectGenderNum].Hex_Foot_C = hexColor;
			break;
		case ColorUIPart.Pattern:
			modelData.modelDatas[selectGenderNum].Hex_Pattern_C = hexColor;
			break;
		case ColorUIPart.Acc:
			modelData.modelDatas[selectGenderNum].Hex_Acc_C = hexColor;
			break;
		}
	}

	public void InitItemSlot(CustomizeProp itemCtrl)
	{
		Transform parent = itemCtrl.transform.parent;
		for (int i = 0; i < parent.childCount; i++)
		{
			if (parent.GetChild(i) == itemCtrl.transform)
			{
				list_ui_prop.Add(itemCtrl);
				switch (((CustomizeItemCtrl)itemCtrl).item_part)
				{
				case ItemUIPart.Face:
					items_face[i] = (CustomizeItemCtrl)itemCtrl;
					return;
				case ItemUIPart.Hair:
					items_hair[i] = (CustomizeItemCtrl)itemCtrl;
					return;
				case ItemUIPart.Wear:
					items_wear[i] = (CustomizeItemCtrl)itemCtrl;
					return;
				case ItemUIPart.Acc:
					items_acc[i] = (CustomizeItemCtrl)itemCtrl;
					return;
				}
			}
		}
	}

	public void InitPageUI(UIPageCtrl pageCtrl)
	{
		uiPages[(int)pageCtrl.item_part] = pageCtrl;
	}

	public void InitColorSlot(ColorPaletteCtrl colorCtrl)
	{
		colorPalette = colorCtrl;
	}

	public CustomizeProp FindNearProp(LobbyHandInfo handInfo, int index)
	{
		if (!isInit)
		{
			return null;
		}
		CustomizeProp customizeProp = null;
		for (int i = 0; i < list_ui_prop.Count; i++)
		{
			if (list_ui_prop[i].gameObject.activeSelf)
			{
				if (customizeProp == null && (handInfo.rayDir.position - list_ui_prop[i].GetCenterPos()).sqrMagnitude - ((list_ui_prop[i] == keep_items[index]) ? 0.001f : 0f) <= 0.01f)
				{
					customizeProp = list_ui_prop[i];
				}
				else if (customizeProp != null && (customizeProp.GetCenterPos() - handInfo.rayDir.position).sqrMagnitude - ((customizeProp == keep_items[index]) ? 0.001f : 0f) > (list_ui_prop[i].GetCenterPos() - handInfo.rayDir.position).sqrMagnitude - ((list_ui_prop[i] == keep_items[index]) ? 0.001f : 0f))
				{
					customizeProp = list_ui_prop[i];
				}
			}
		}
		if (customizeProp != null)
		{
			if (keep_items[index] != customizeProp)
			{
				if (keep_items[index] != null)
				{
					keep_items[index].SetSize(isSelect: false);
				}
				keep_items[index] = customizeProp;
				customizeProp.SetSize(isSelect: true);
			}
			return customizeProp;
		}
		for (int j = 0; j < list_ui_prop.Count; j++)
		{
			if (list_ui_prop[j].gameObject.activeSelf)
			{
				if (customizeProp == null && Vector3.Dot(handInfo.rayDir.forward, (list_ui_prop[j].GetCenterPos() - handInfo.rayDir.position).normalized) + ((list_ui_prop[j] == keep_items[index]) ? 0.002f : 0f) >= 0.85f)
				{
					customizeProp = list_ui_prop[j];
				}
				else if (customizeProp != null && Vector3.Dot(handInfo.rayDir.forward, (customizeProp.GetCenterPos() - handInfo.rayDir.position).normalized) + ((customizeProp == keep_items[index]) ? 0.002f : 0f) < Vector3.Dot(handInfo.rayDir.forward, (list_ui_prop[j].GetCenterPos() - handInfo.rayDir.position).normalized) + ((list_ui_prop[j] == keep_items[index]) ? 0.002f : 0f))
				{
					customizeProp = list_ui_prop[j];
				}
			}
		}
		if (customizeProp != null)
		{
			if (keep_items[index] != null)
			{
				keep_items[index].SetSize(isSelect: false);
			}
			keep_items[index] = customizeProp;
			customizeProp.SetSize(isSelect: true);
			handInfo.line_transform.position = handInfo.rayDir.position;
			Vector3 forward = customizeProp.GetCenterPos() - handInfo.rayDir.position;
			handInfo.line_transform.rotation = Quaternion.Lerp(handInfo.rayDir.rotation, Quaternion.LookRotation(forward), 0.7f);
			handInfo.line_transform.localScale = Vector3.forward * forward.magnitude;
		}
		else
		{
			if (keep_items[index] != null)
			{
				keep_items[index].SetSize(isSelect: false);
				keep_items[index] = null;
			}
			handInfo.line_transform.position = handInfo.rayDir.position;
			handInfo.line_transform.rotation = handInfo.rayDir.rotation;
			handInfo.line_transform.localScale = Vector3.one;
		}
		return customizeProp;
	}

	public void SetSelectUISlotID(string _id)
	{
		switch (_id[0])
		{
		case '1':
		{
			for (int k = 0; k < items_face.Length; k++)
			{
				if (items_face[k].slotInfo != null)
				{
					if (items_face[k].slotInfo.id == _id)
					{
						items_face[k].gameObject.SetActive(value: false);
					}
					else if (items_face[k].slotInfo.id == modelData.modelDatas[selectGenderNum].ID_Face_I)
					{
						items_face[k].gameObject.SetActive(value: true);
					}
				}
			}
			modelData.modelDatas[selectGenderNum].ID_Face_I = _id;
			break;
		}
		case '2':
		{
			for (int j = 0; j < items_hair.Length; j++)
			{
				if (items_hair[j].slotInfo != null)
				{
					if (items_hair[j].slotInfo.id == _id)
					{
						items_hair[j].gameObject.SetActive(value: false);
					}
					else if (items_hair[j].slotInfo.id == modelData.modelDatas[selectGenderNum].ID_Hair_I)
					{
						items_hair[j].gameObject.SetActive(value: true);
					}
				}
			}
			modelData.modelDatas[selectGenderNum].ID_Hair_I = _id;
			break;
		}
		case '3':
		{
			for (int l = 0; l < items_wear.Length; l++)
			{
				if (items_wear[l].slotInfo != null)
				{
					if (items_wear[l].slotInfo.id == _id)
					{
						items_wear[l].gameObject.SetActive(value: false);
					}
					else if (items_wear[l].slotInfo.id == modelData.modelDatas[selectGenderNum].ID_Wear_I)
					{
						items_wear[l].gameObject.SetActive(value: true);
					}
				}
			}
			modelData.modelDatas[selectGenderNum].ID_Wear_I = _id;
			break;
		}
		case '4':
		{
			for (int i = 0; i < items_acc.Length; i++)
			{
				if (items_acc[i].slotInfo != null)
				{
					if (items_acc[i].slotInfo.id == _id)
					{
						items_acc[i].gameObject.SetActive(value: false);
					}
					else if (items_acc[i].slotInfo.id == modelData.modelDatas[selectGenderNum].ID_Acc_I)
					{
						items_acc[i].gameObject.SetActive(value: true);
					}
				}
			}
			modelData.modelDatas[selectGenderNum].ID_Acc_I = _id;
			break;
		}
		}
	}

	public void SetSelectGenderUI(int _genderNum)
	{
		selectGenderNum = _genderNum;
		for (int i = 0; i < buttons_gender.Length; i++)
		{
			if (selectGenderNum == i)
			{
				buttons_gender[i].SetMaterial(materials_customUI[1]);
				buttons_gender[i].SetInteractable(_isInteractable: false);
			}
			else
			{
				buttons_gender[i].SetMaterial(materials_customUI[0]);
				buttons_gender[i].SetInteractable(_isInteractable: true);
			}
		}
	}

	public void SetColor_Others(ColorUIPart part, string setHexColor)
	{
		switch (part)
		{
		case ColorUIPart.Skin:
		case ColorUIPart.Eye:
		case ColorUIPart.Eyebrow:
		{
			for (int l = 0; l < items_face.Length; l++)
			{
				items_face[l].SetColor(part, setHexColor);
			}
			break;
		}
		case ColorUIPart.Hair:
		{
			for (int j = 0; j < items_hair.Length; j++)
			{
				items_hair[j].SetColor(part, setHexColor);
			}
			break;
		}
		case ColorUIPart.Upper:
		case ColorUIPart.Lower:
		case ColorUIPart.Foot:
		case ColorUIPart.Pattern:
		{
			for (int k = 0; k < items_hair.Length; k++)
			{
				items_wear[k].SetColor(part, setHexColor);
			}
			break;
		}
		case ColorUIPart.Acc:
		{
			for (int i = 0; i < items_hair.Length; i++)
			{
				items_acc[i].SetColor(part, setHexColor);
			}
			break;
		}
		}
	}

	public void SetRotationCharacter(float rotP)
	{
		characterCtrl.transform.rotation *= Quaternion.Euler(0f, rotP, 0f);
	}

	public void Upload_UserData()
	{
		PlayerPrefs.SetString("gender", (selectGenderNum == 0) ? "m" : "f");
		modelData.modelDatas[0].Gender = "m";
		PlayerPrefs.SetString("id_item_face_m", modelData.modelDatas[0].ID_Face_I);
		PlayerPrefs.SetString("hex_color_skin_m", modelData.modelDatas[0].Hex_Skin_C);
		PlayerPrefs.SetString("hex_color_eye_m", modelData.modelDatas[0].Hex_Eye_C);
		PlayerPrefs.SetString("hex_color_eyebrow_m", modelData.modelDatas[0].Hex_Eyebrow_C);
		PlayerPrefs.SetString("id_item_hair_m", modelData.modelDatas[0].ID_Hair_I);
		PlayerPrefs.SetString("hex_color_hair_m", modelData.modelDatas[0].Hex_Hair_C);
		PlayerPrefs.SetString("id_item_wear_m", modelData.modelDatas[0].ID_Wear_I);
		PlayerPrefs.SetString("hex_color_upper_m", modelData.modelDatas[0].Hex_Upper_C);
		PlayerPrefs.SetString("hex_color_lower_m", modelData.modelDatas[0].Hex_Lower_C);
		PlayerPrefs.SetString("hex_color_foot_m", modelData.modelDatas[0].Hex_Foot_C);
		PlayerPrefs.SetString("hex_color_pattern_m", modelData.modelDatas[0].Hex_Pattern_C);
		PlayerPrefs.SetString("id_item_acc_m", modelData.modelDatas[0].ID_Acc_I);
		PlayerPrefs.SetString("hex_color_acc_m", modelData.modelDatas[0].Hex_Acc_C);
		modelData.modelDatas[1].Gender = "f";
		PlayerPrefs.SetString("id_item_face_f", modelData.modelDatas[1].ID_Face_I);
		PlayerPrefs.SetString("hex_color_skin_f", modelData.modelDatas[1].Hex_Skin_C);
		PlayerPrefs.SetString("hex_color_eye_f", modelData.modelDatas[1].Hex_Eye_C);
		PlayerPrefs.SetString("hex_color_eyebrow_f", modelData.modelDatas[1].Hex_Eyebrow_C);
		PlayerPrefs.SetString("id_item_hair_f", modelData.modelDatas[1].ID_Hair_I);
		PlayerPrefs.SetString("hex_color_hair_f", modelData.modelDatas[1].Hex_Hair_C);
		PlayerPrefs.SetString("id_item_wear_f", modelData.modelDatas[1].ID_Wear_I);
		PlayerPrefs.SetString("hex_color_upper_f", modelData.modelDatas[1].Hex_Upper_C);
		PlayerPrefs.SetString("hex_color_lower_f", modelData.modelDatas[1].Hex_Lower_C);
		PlayerPrefs.SetString("hex_color_foot_f", modelData.modelDatas[1].Hex_Foot_C);
		PlayerPrefs.SetString("hex_color_pattern_f", modelData.modelDatas[1].Hex_Pattern_C);
		PlayerPrefs.GetString("id_item_acc_f", modelData.modelDatas[1].ID_Acc_I);
		PlayerPrefs.SetString("hex_color_acc_f", modelData.modelDatas[1].Hex_Acc_C);
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetCustomModelData(modelData.modelDatas[selectGenderNum]);
		StartCoroutine(Cor_Upload_UserData());
	}

	private IEnumerator Cor_Upload_UserData()
	{
		List<IMultipartFormSection> list = new List<IMultipartFormSection>();
		list.Add(new MultipartFormDataSection("UserID", SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id));
		list.Add(new MultipartFormDataSection("Gender", (selectGenderNum == 0) ? "m" : "f"));
		list.Add(new MultipartFormDataSection("ID_Face_I_M", modelData.modelDatas[0].ID_Face_I));
		list.Add(new MultipartFormDataSection("Hex_Skin_C_M", modelData.modelDatas[0].Hex_Skin_C));
		list.Add(new MultipartFormDataSection("Hex_Eye_C_M", modelData.modelDatas[0].Hex_Eye_C));
		list.Add(new MultipartFormDataSection("Hex_Eyebrow_C_M", modelData.modelDatas[0].Hex_Eyebrow_C));
		list.Add(new MultipartFormDataSection("ID_Hair_I_M", modelData.modelDatas[0].ID_Hair_I));
		list.Add(new MultipartFormDataSection("Hex_Hair_C_M", modelData.modelDatas[0].Hex_Hair_C));
		list.Add(new MultipartFormDataSection("ID_Wear_I_M", modelData.modelDatas[0].ID_Wear_I));
		list.Add(new MultipartFormDataSection("Hex_Upper_C_M", modelData.modelDatas[0].Hex_Upper_C));
		list.Add(new MultipartFormDataSection("Hex_Lower_C_M", modelData.modelDatas[0].Hex_Lower_C));
		list.Add(new MultipartFormDataSection("Hex_Foot_C_M", modelData.modelDatas[0].Hex_Foot_C));
		list.Add(new MultipartFormDataSection("Hex_Pattern_C_M", modelData.modelDatas[0].Hex_Pattern_C));
		list.Add(new MultipartFormDataSection("ID_Acc_I_M", modelData.modelDatas[0].ID_Acc_I));
		list.Add(new MultipartFormDataSection("Hex_Acc_C_M", modelData.modelDatas[0].Hex_Acc_C));
		list.Add(new MultipartFormDataSection("ID_Face_I_F", modelData.modelDatas[1].ID_Face_I));
		list.Add(new MultipartFormDataSection("Hex_Skin_C_F", modelData.modelDatas[1].Hex_Skin_C));
		list.Add(new MultipartFormDataSection("Hex_Eye_C_F", modelData.modelDatas[1].Hex_Eye_C));
		list.Add(new MultipartFormDataSection("Hex_Eyebrow_C_F", modelData.modelDatas[1].Hex_Eyebrow_C));
		list.Add(new MultipartFormDataSection("ID_Hair_I_F", modelData.modelDatas[1].ID_Hair_I));
		list.Add(new MultipartFormDataSection("Hex_Hair_C_F", modelData.modelDatas[1].Hex_Hair_C));
		list.Add(new MultipartFormDataSection("ID_Wear_I_F", modelData.modelDatas[1].ID_Wear_I));
		list.Add(new MultipartFormDataSection("Hex_Upper_C_F", modelData.modelDatas[1].Hex_Upper_C));
		list.Add(new MultipartFormDataSection("Hex_Lower_C_F", modelData.modelDatas[1].Hex_Lower_C));
		list.Add(new MultipartFormDataSection("Hex_Foot_C_F", modelData.modelDatas[1].Hex_Foot_C));
		list.Add(new MultipartFormDataSection("Hex_Pattern_C_F", modelData.modelDatas[1].Hex_Pattern_C));
		list.Add(new MultipartFormDataSection("ID_Acc_I_F", modelData.modelDatas[1].ID_Acc_I));
		list.Add(new MultipartFormDataSection("Hex_Acc_C_F", modelData.modelDatas[1].Hex_Acc_C));
		UnityWebRequest www = UnityWebRequest.Post("https://api-global.appnori.com/AIO/SetCustomInfo.php", list);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		UnityEngine.Debug.Log("Form upload complete!");
		UnityEngine.Debug.Log(www.downloadHandler.text);
	}

	public void Download_UserData()
	{
		StartCoroutine(Cor_Download_UserData());
	}

	private IEnumerator Cor_Download_UserData()
	{
		List<IMultipartFormSection> formData = new List<IMultipartFormSection>();
		if (UnityEngine.Application.internetReachability != 0)
		{
			while (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id == null || SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id == "")
			{
				yield return null;
			}
			formData.Add(new MultipartFormDataSection("UserID", SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id));
		}
		else
		{
			formData.Add(new MultipartFormDataSection("UserID", "Player01"));
		}
		formData.Add(new MultipartFormDataSection("Select", "All"));
		UnityWebRequest www = UnityWebRequest.Post("https://api-global.appnori.com/AIO/GetCustomInfo.php", formData);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			string @string = PlayerPrefs.GetString("gender", "m");
			if (!(@string == "m"))
			{
				if (@string == "f")
				{
					selectGenderNum = 1;
				}
			}
			else
			{
				selectGenderNum = 0;
			}
			modelData = new AllModelData();
			modelData.modelDatas = new CustomModelData[2];
			modelData.modelDatas[0] = new CustomModelData();
			modelData.modelDatas[0].Gender = "m";
			modelData.modelDatas[0].ID_Face_I = PlayerPrefs.GetString("id_item_face_m", "1000");
			modelData.modelDatas[0].Hex_Skin_C = PlayerPrefs.GetString("hex_color_skin_m", "FFAA80");
			modelData.modelDatas[0].Hex_Eye_C = PlayerPrefs.GetString("hex_color_eye_m", "000000");
			modelData.modelDatas[0].Hex_Eyebrow_C = PlayerPrefs.GetString("hex_color_eyebrow_m", "000000");
			modelData.modelDatas[0].ID_Hair_I = PlayerPrefs.GetString("id_item_hair_m", "2000");
			modelData.modelDatas[0].Hex_Hair_C = PlayerPrefs.GetString("hex_color_hair_m", "000000");
			modelData.modelDatas[0].ID_Wear_I = PlayerPrefs.GetString("id_item_wear_m", "3000");
			modelData.modelDatas[0].Hex_Upper_C = PlayerPrefs.GetString("hex_color_upper_m", "808080");
			modelData.modelDatas[0].Hex_Lower_C = PlayerPrefs.GetString("hex_color_lower_m", "808080");
			modelData.modelDatas[0].Hex_Foot_C = PlayerPrefs.GetString("hex_color_foot_m", "808080");
			modelData.modelDatas[0].Hex_Pattern_C = PlayerPrefs.GetString("hex_color_pattern_m", "000000");
			modelData.modelDatas[0].ID_Acc_I = PlayerPrefs.GetString("id_item_acc_m", "4000");
			modelData.modelDatas[0].Hex_Acc_C = PlayerPrefs.GetString("hex_color_acc_m", "808080");
			modelData.modelDatas[1] = new CustomModelData();
			modelData.modelDatas[1].Gender = "f";
			modelData.modelDatas[1].ID_Face_I = PlayerPrefs.GetString("id_item_face_f", "1000");
			modelData.modelDatas[1].Hex_Skin_C = PlayerPrefs.GetString("hex_color_skin_f", "FFAA80");
			modelData.modelDatas[1].Hex_Eye_C = PlayerPrefs.GetString("hex_color_eye_f", "000000");
			modelData.modelDatas[1].Hex_Eyebrow_C = PlayerPrefs.GetString("hex_color_eyebrow_f", "000000");
			modelData.modelDatas[1].ID_Hair_I = PlayerPrefs.GetString("id_item_hair_f", "2000");
			modelData.modelDatas[1].Hex_Hair_C = PlayerPrefs.GetString("hex_color_hair_f", "000000");
			modelData.modelDatas[1].ID_Wear_I = PlayerPrefs.GetString("id_item_wear_f", "3000");
			modelData.modelDatas[1].Hex_Upper_C = PlayerPrefs.GetString("hex_color_upper_f", "808080");
			modelData.modelDatas[1].Hex_Lower_C = PlayerPrefs.GetString("hex_color_lower_f", "808080");
			modelData.modelDatas[1].Hex_Foot_C = PlayerPrefs.GetString("hex_color_foot_f", "808080");
			modelData.modelDatas[1].Hex_Pattern_C = PlayerPrefs.GetString("hex_color_pattern_f", "000000");
			modelData.modelDatas[1].ID_Acc_I = PlayerPrefs.GetString("id_item_acc_f", "4000");
			modelData.modelDatas[1].Hex_Acc_C = PlayerPrefs.GetString("hex_color_acc_f", "808080");
		}
		else
		{
			UnityEngine.Debug.Log("Form upload complete!");
			UnityEngine.Debug.Log(www.downloadHandler.text);
			modelData = JsonUtility.FromJson<AllModelData>("{\"modelDatas\":" + www.downloadHandler.text + "}");
			string @string = modelData.modelDatas[0].Gender;
			if (!(@string == "m"))
			{
				if (@string == "f")
				{
					selectGenderNum = 1;
				}
			}
			else
			{
				selectGenderNum = 0;
			}
		}
		StartCoroutine(InitData());
	}
}
public class CustomizeMidUICtrl : MonoBehaviour
{
	private bool isEndScene;

	private void Awake()
	{
		isEndScene = false;
	}

	public void Click_InputKey(string key)
	{
		if (!isEndScene)
		{
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play((int)UnityEngine.Random.Range(0f, 2.9999f));
			switch (key)
			{
			case "Lobby":
				isEndScene = true;
				SingletonBase.Singleton<CustomizeManager>.GetInstance.Upload_UserData();
				SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Lobby");
				break;
			case "Male":
				SingletonBase.Singleton<CustomizeManager>.GetInstance.characterCtrl.SetGender(0);
				break;
			case "Female":
				SingletonBase.Singleton<CustomizeManager>.GetInstance.characterCtrl.SetGender(1);
				break;
			}
		}
	}
}
public class EyeAnimationCtrl : MonoBehaviour
{
	private int stateNum;

	private float playTime;

	private float endTime;

	private float setTime;

	private Vector2 offset;

	private Vector2 offset_idle = new Vector2(0.5f, 0f);

	private MeshRenderer renderer;

	private bool isOpenEye;

	public bool isSingleton;

	private static EyeAnimationCtrl Instance;

	public static EyeAnimationCtrl GetInstance => Instance;

	private void Start()
	{
		if (isSingleton)
		{
			Instance = this;
		}
		renderer = base.transform.GetComponent<MeshRenderer>();
		SetExpression(0, 0f);
	}

	private void Update()
	{
		playTime -= Time.unscaledDeltaTime;
		if (playTime <= 0f)
		{
			playTime = UnityEngine.Random.Range(1f, 3.5f);
		}
		if (!isOpenEye && playTime > 0.1f)
		{
			isOpenEye = true;
			renderer.material.SetVector("_Offset_Eye", offset);
		}
		else if (isOpenEye && playTime <= 0.1f)
		{
			isOpenEye = false;
			renderer.material.SetVector("_Offset_Eye", offset_idle);
		}
		if (stateNum == 0)
		{
			return;
		}
		endTime -= Time.unscaledDeltaTime;
		if (endTime <= 0f)
		{
			if (stateNum == 15)
			{
				SetExpression(16, setTime);
			}
			else if (stateNum == 16)
			{
				SetExpression(17, setTime);
			}
			else
			{
				SetExpression(0, 0f);
			}
		}
	}

	public void SetExpression(int setState, float _setTime)
	{
		stateNum = setState;
		setTime = _setTime;
		switch (setState)
		{
		case 0:
			offset = new Vector2(0f, 0f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0f, 0f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0f, 0f));
			break;
		case 1:
			offset = new Vector2(0f, 0f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0.5f, 0.5f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0.5f, 0f));
			break;
		case 2:
			offset = new Vector2(0.5f, 0.5f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0.5f, 0f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0.5f, 0.5f));
			break;
		case 3:
			offset = new Vector2(0f, 0.5f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0f, 0.5f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0f, 0.5f));
			break;
		case 4:
		{
			float num = UnityEngine.Random.Range(0f, 1f);
			if (num >= 0.667f)
			{
				offset = new Vector2(0.5f, 0f);
			}
			else if (num >= 0.333f)
			{
				offset = new Vector2(0f, 0.5f);
			}
			else
			{
				offset = new Vector2(0.5f, 0.5f);
			}
			renderer.material.SetVector("_Offset_Eye", offset);
			if (UnityEngine.Random.Range(0f, 1f) >= 0.5f)
			{
				renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0.5f, 0f));
			}
			else
			{
				renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0f, 0.5f));
			}
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0f, 0.5f));
			break;
		}
		case 15:
			offset = new Vector2(0f, 0.5f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0f, 0.5f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0f, 0.5f));
			endTime = 0.15f;
			return;
		case 16:
			offset = new Vector2(0f, 0.5f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0f, 0.5f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0.5f, 0f));
			endTime = 0.35f;
			return;
		case 17:
			offset = new Vector2(0f, 0.5f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2(0f, 0.5f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2(0.5f, 0.5f));
			endTime = setTime;
			return;
		default:
			offset = new Vector2((UnityEngine.Random.Range(0f, 1f) >= 0.5f) ? 0f : 0.5f, (UnityEngine.Random.Range(0f, 1f) >= 0.5f) ? 0f : 0.5f);
			renderer.material.SetVector("_Offset_Eye", offset);
			renderer.material.SetVector("_Offset_Eyebrow", new Vector2((UnityEngine.Random.Range(0f, 1f) >= 0.5f) ? 0f : 0.5f, (UnityEngine.Random.Range(0f, 1f) >= 0.5f) ? 0f : 0.5f));
			renderer.material.SetVector("_Offset_Mouth", new Vector2((UnityEngine.Random.Range(0f, 1f) >= 0.5f) ? 0f : 0.5f, (UnityEngine.Random.Range(0f, 1f) >= 0.5f) ? 0f : 0.5f));
			break;
		}
		endTime = setTime;
	}
}
public class GameSettingCtrl : MonoBehaviour
{
	[Serializable]
	public class JsonParsing
	{
		[Serializable]
		public class LocalizationInfo
		{
			public string id;

			public List<string> list_data;

			public LocalizationInfo(string csv)
			{
				string[] array = csv.Split(',');
				id = array[0];
				list_data = new List<string>();
				for (int i = 1; i < 14; i++)
				{
					list_data.Add(array[i].Split('\r')[0]);
				}
			}
		}

		public List<LocalizationInfo> list_localizationInfo;

		public JsonParsing(string csvName)
		{
			string[] array = File.ReadAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/" + csvName).Split('\n');
			list_localizationInfo = new List<LocalizationInfo>();
			for (int i = 1; i < array.Length; i++)
			{
				list_localizationInfo.Add(new LocalizationInfo(array[i]));
			}
		}
	}

	[Serializable]
	public class SettingInfo
	{
		public float value_bgm;

		public bool on_sound_bgm;

		public float value_eff;

		public bool on_sound_eff;

		public float value_haptic;

		public bool on_haptic;

		public bool on_right_handed;

		public float value_voice;

		public bool on_sound_voice;

		public string language;

		public SettingInfo()
		{
			value_bgm = 0.85f;
			on_sound_bgm = true;
			value_eff = 0.85f;
			on_sound_eff = true;
			value_haptic = 1f;
			on_haptic = true;
			on_right_handed = true;
			value_voice = 0.85f;
			on_sound_voice = true;
			language = "system";
		}
	}

	private bool isInit;

	private AudioMixer audioMixer;

	private Text text_sound;

	private Text text_bgm;

	private Text text_eff;

	private Slider slider_bgm;

	private Slider slider_eff;

	private Toggle toggle_bgm;

	private Toggle toggle_eff;

	private Text text_title_haptic;

	private Text text_info_haptic;

	private Slider slider_haptic;

	private Toggle toggle_haptic;

	private Text text_hand;

	private Text text_handL;

	private Text text_handR;

	private Toggle toggle_handL;

	private Toggle toggle_handR;

	private Text text_title_voice_chat;

	private Text text_info_voice_chat;

	private Slider slider_voice_chat;

	private Toggle toggle_voice_chat;

	private Text text_language;

	private Dropdown dropdown_language;

	private bool isChangeData;

	private static LanguageState languageState;

	private static SettingInfo settingInfo;

	public static Dictionary<string, List<string>> localizationInfos;

	public static MicAmplifier micAmplifier;

	private event Action<bool> action_hand;

	private event Action action_localization;

	private event Action<LanguageState> action_localization_put;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		if (isInit)
		{
			return;
		}
		isInit = true;
		audioMixer = Resources.Load<AudioMixer>("AudioMixer_AIO");
		Transform transform = base.transform.Find("Board/Scroll View/Viewport/Content/Slot (0)");
		text_sound = transform.Find("Text_Title").GetComponent<Text>();
		text_bgm = transform.Find("Text_BGM").GetComponent<Text>();
		text_eff = transform.Find("Text_Effect").GetComponent<Text>();
		slider_bgm = transform.Find("Slider_BGM").GetComponent<Slider>();
		slider_eff = transform.Find("Slider_Effect").GetComponent<Slider>();
		toggle_bgm = transform.Find("Toggle_BGM").GetComponent<Toggle>();
		toggle_eff = transform.Find("Toggle_Effect").GetComponent<Toggle>();
		transform = base.transform.Find("Board/Scroll View/Viewport/Content/Slot (1)");
		text_title_haptic = transform.Find("Text_Title").GetComponent<Text>();
		text_info_haptic = transform.Find("Text_Value").GetComponent<Text>();
		slider_haptic = transform.Find("Slider_Haptic").GetComponent<Slider>();
		toggle_haptic = transform.Find("Toggle_Haptic").GetComponent<Toggle>();
		transform = base.transform.Find("Board/Scroll View/Viewport/Content/Slot (2)");
		text_hand = transform.Find("Text_Title").GetComponent<Text>();
		text_handL = transform.Find("Text_LeftHand").GetComponent<Text>();
		text_handR = transform.Find("Text_RightHand").GetComponent<Text>();
		toggle_handL = transform.Find("Toggles/Toggle_LeftHand").GetComponent<Toggle>();
		toggle_handR = transform.Find("Toggles/Toggle_RightHand").GetComponent<Toggle>();
		transform = base.transform.Find("Board/Scroll View/Viewport/Content/Slot (3)");
		text_title_voice_chat = transform.Find("Text_Title").GetComponent<Text>();
		text_info_voice_chat = transform.Find("Text_Value").GetComponent<Text>();
		slider_voice_chat = transform.Find("Slider_Voice").GetComponent<Slider>();
		toggle_voice_chat = transform.Find("Toggle_Voice").GetComponent<Toggle>();
		transform = base.transform.Find("Board/Scroll View/Viewport/Content/Slot (4)");
		text_language = transform.Find("Text_Title").GetComponent<Text>();
		dropdown_language = transform.Find("Dropdown").GetComponent<Dropdown>();
		toggle_bgm.onValueChanged.RemoveAllListeners();
		toggle_bgm.onValueChanged.AddListener(delegate
		{
			OnValueToggle(toggle_bgm);
		});
		slider_bgm.onValueChanged.RemoveAllListeners();
		slider_bgm.onValueChanged.AddListener(delegate
		{
			OnValueSlider(slider_bgm);
		});
		toggle_eff.onValueChanged.RemoveAllListeners();
		toggle_eff.onValueChanged.AddListener(delegate
		{
			OnValueToggle(toggle_eff);
		});
		slider_eff.onValueChanged.RemoveAllListeners();
		slider_eff.onValueChanged.AddListener(delegate
		{
			OnValueSlider(slider_eff);
		});
		EventTrigger.Entry entry = new EventTrigger.Entry();
		entry.eventID = EventTriggerType.PointerUp;
		entry.callback.AddListener(delegate
		{
			PublicGameUIManager.GetInstance.Play_Voice(7);
		});
		slider_eff.transform.GetComponent<EventTrigger>().triggers.Add(entry);
		toggle_haptic.onValueChanged.RemoveAllListeners();
		toggle_haptic.onValueChanged.AddListener(delegate
		{
			OnValueToggle(toggle_haptic);
		});
		slider_haptic.onValueChanged.RemoveAllListeners();
		slider_haptic.onValueChanged.AddListener(delegate
		{
			OnValueSlider(slider_haptic);
		});
		toggle_handL.onValueChanged.RemoveAllListeners();
		toggle_handL.onValueChanged.AddListener(delegate
		{
			OnValueToggle(toggle_handL);
		});
		toggle_handR.onValueChanged.RemoveAllListeners();
		toggle_handR.onValueChanged.AddListener(delegate
		{
			OnValueToggle(toggle_handR);
		});
		toggle_voice_chat.onValueChanged.RemoveAllListeners();
		toggle_voice_chat.onValueChanged.AddListener(delegate
		{
			OnValueToggle(toggle_voice_chat);
		});
		slider_voice_chat.onValueChanged.RemoveAllListeners();
		slider_voice_chat.onValueChanged.AddListener(delegate
		{
			OnValueSlider(slider_voice_chat);
		});
		List<Dropdown.OptionData> list = new List<Dropdown.OptionData>();
		for (int i = 0; i < 13; i++)
		{
			switch (i)
			{
			case 0:
			{
				Dropdown.OptionData item13 = new Dropdown.OptionData("English");
				list.Add(item13);
				break;
			}
			case 1:
			{
				Dropdown.OptionData item12 = new Dropdown.OptionData("한국어");
				list.Add(item12);
				break;
			}
			case 2:
			{
				Dropdown.OptionData item11 = new Dropdown.OptionData("日本語");
				list.Add(item11);
				break;
			}
			case 3:
			{
				Dropdown.OptionData item10 = new Dropdown.OptionData("Español");
				list.Add(item10);
				break;
			}
			case 4:
			{
				Dropdown.OptionData item9 = new Dropdown.OptionData("Deutsch");
				list.Add(item9);
				break;
			}
			case 5:
			{
				Dropdown.OptionData item8 = new Dropdown.OptionData("Português");
				list.Add(item8);
				break;
			}
			case 6:
			{
				Dropdown.OptionData item7 = new Dropdown.OptionData("русский язык");
				list.Add(item7);
				break;
			}
			case 7:
			{
				Dropdown.OptionData item6 = new Dropdown.OptionData("Italiano");
				list.Add(item6);
				break;
			}
			case 8:
			{
				Dropdown.OptionData item5 = new Dropdown.OptionData("język polski");
				list.Add(item5);
				break;
			}
			case 9:
			{
				Dropdown.OptionData item4 = new Dropdown.OptionData("Türkçe");
				list.Add(item4);
				break;
			}
			case 10:
			{
				Dropdown.OptionData item3 = new Dropdown.OptionData("简体中文");
				list.Add(item3);
				break;
			}
			case 11:
			{
				Dropdown.OptionData item2 = new Dropdown.OptionData("繁體中文");
				list.Add(item2);
				break;
			}
			case 12:
			{
				Dropdown.OptionData item = new Dropdown.OptionData("Français");
				list.Add(item);
				break;
			}
			}
		}
		dropdown_language.ClearOptions();
		dropdown_language.AddOptions(list);
		dropdown_language.onValueChanged.RemoveAllListeners();
		dropdown_language.onValueChanged.AddListener(delegate
		{
			OnValueDropdown(dropdown_language);
		});
		if (settingInfo == null)
		{
			if (File.Exists(UnityEngine.Application.persistentDataPath + "/SettingData.json"))
			{
				try
				{
					settingInfo = JsonUtility.FromJson<SettingInfo>(File.ReadAllText(UnityEngine.Application.persistentDataPath + "/SettingData.json"));
				}
				catch (Exception)
				{
					settingInfo = new SettingInfo();
				}
			}
			else
			{
				settingInfo = new SettingInfo();
			}
		}
		if (micAmplifier == null)
		{
			micAmplifier = PhotonVoiceNetwork.Instance.transform.GetComponent<MicAmplifier>();
		}
		if (settingInfo == null)
		{
			if (File.Exists(UnityEngine.Application.persistentDataPath + "/SettingData.json"))
			{
				try
				{
					settingInfo = JsonUtility.FromJson<SettingInfo>(File.ReadAllText(UnityEngine.Application.persistentDataPath + "/SettingData.json"));
				}
				catch (Exception)
				{
					settingInfo = new SettingInfo();
				}
			}
			else
			{
				settingInfo = new SettingInfo();
			}
		}
		if (localizationInfos == null)
		{
			localizationInfos = new Dictionary<string, List<string>>();
			List<JsonParsing.LocalizationInfo> list_localizationInfo = JsonUtility.FromJson<JsonParsing>((Resources.Load("ItemInfos/LocalizationData") as TextAsset).text).list_localizationInfo;
			for (int j = 0; j < list_localizationInfo.Count; j++)
			{
				localizationInfos.Add(list_localizationInfo[j].id, list_localizationInfo[j].list_data);
			}
		}
		languageState = GetChangeLanguageState(settingInfo.language);
		if (SingletonBase.Singleton<StaticLocalizationCtrl>.IsInstance)
		{
			SingletonBase.Singleton<StaticLocalizationCtrl>.GetInstance.SetLocaliztion();
		}
		if (SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.IsInstance)
		{
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.SetLocaliztion();
		}
		if (SingletonBase.Singleton<StaticResourcesChangeCtrl>.IsInstance)
		{
			SingletonBase.Singleton<StaticResourcesChangeCtrl>.GetInstance.SetData();
		}
		base.gameObject.SetActive(value: false);
	}

	public void View()
	{
		Init();
		settingInfo.value_bgm = Mathf.Clamp01(settingInfo.value_bgm);
		settingInfo.value_eff = Mathf.Clamp01(settingInfo.value_eff);
		if (settingInfo.on_sound_bgm)
		{
			toggle_bgm.isOn = true;
			slider_bgm.value = settingInfo.value_bgm;
			audioMixer.SetFloat("BGM", LinearToDecibel(settingInfo.value_bgm));
		}
		else
		{
			toggle_bgm.isOn = false;
			slider_bgm.value = 0f;
			audioMixer.SetFloat("BGM", LinearToDecibel(0f));
		}
		if (settingInfo.on_sound_eff)
		{
			toggle_eff.isOn = true;
			slider_eff.value = settingInfo.value_eff;
			audioMixer.SetFloat("Effect", LinearToDecibel(settingInfo.value_eff));
		}
		else
		{
			toggle_eff.isOn = false;
			slider_eff.value = 0f;
			audioMixer.SetFloat("Effect", LinearToDecibel(0f));
		}
		settingInfo.value_haptic = Mathf.Clamp(settingInfo.value_haptic, 0f, 2f);
		if (settingInfo.on_haptic)
		{
			toggle_haptic.isOn = true;
			slider_haptic.value = settingInfo.value_haptic;
		}
		else
		{
			toggle_haptic.isOn = false;
			slider_haptic.value = 0f;
		}
		if (settingInfo.on_right_handed)
		{
			toggle_handR.isOn = true;
			toggle_handL.isOn = false;
		}
		else
		{
			toggle_handL.isOn = true;
			toggle_handR.isOn = false;
		}
		settingInfo.value_voice = Mathf.Clamp(settingInfo.value_voice, 0f, 1f);
		if (settingInfo.on_sound_voice)
		{
			toggle_voice_chat.isOn = true;
			slider_voice_chat.value = settingInfo.value_voice;
		}
		else
		{
			toggle_voice_chat.isOn = false;
			slider_voice_chat.value = 0f;
		}
		micAmplifier.AmplificationFactor = slider_voice_chat.value * 3f;
		languageState = GetChangeLanguageState(settingInfo.language);
		dropdown_language.value = (int)languageState;
		base.gameObject.SetActive(value: true);
	}

	public void OnValueSlider(Slider slider)
	{
		switch (slider.gameObject.name)
		{
		case "Slider_BGM":
			if ((slider.value != 0f || toggle_bgm.isOn) && settingInfo.value_bgm != slider.value)
			{
				settingInfo.value_bgm = slider.value;
				audioMixer.SetFloat("BGM", LinearToDecibel(settingInfo.value_bgm));
				settingInfo.on_sound_bgm = true;
				toggle_bgm.isOn = settingInfo.on_sound_bgm;
				isChangeData = true;
			}
			break;
		case "Slider_Effect":
			if ((slider.value != 0f || toggle_eff.isOn) && settingInfo.value_eff != slider.value)
			{
				settingInfo.value_eff = slider.value;
				audioMixer.SetFloat("Effect", LinearToDecibel(settingInfo.value_eff));
				settingInfo.on_sound_eff = true;
				toggle_eff.isOn = settingInfo.on_sound_eff;
				isChangeData = true;
			}
			break;
		case "Slider_Haptic":
			if ((slider.value != 0f || toggle_haptic.isOn) && settingInfo.value_haptic != slider.value)
			{
				settingInfo.value_haptic = slider.value;
				settingInfo.on_haptic = true;
				toggle_haptic.isOn = settingInfo.on_haptic;
				PublicGameUIManager.GetInstance.SetHaptic(0.5f, 0.05f);
				isChangeData = true;
			}
			break;
		case "Slider_Voice":
			if ((slider.value != 0f || toggle_voice_chat.isOn) && settingInfo.value_voice != slider.value)
			{
				settingInfo.value_voice = slider.value;
				audioMixer.SetFloat("VoiceChat", LinearToDecibel(settingInfo.value_voice));
				micAmplifier.AmplificationFactor = settingInfo.value_voice * 3f;
				settingInfo.on_sound_voice = true;
				toggle_voice_chat.isOn = settingInfo.on_sound_voice;
				isChangeData = true;
			}
			break;
		}
	}

	private float LinearToDecibel(float linear)
	{
		if (linear != 0f)
		{
			return 20f * Mathf.Log10(linear);
		}
		return -144f;
	}

	public void OnValueToggle(Toggle toggle)
	{
		UnityEngine.Debug.LogError("OnValueToggle");
		switch (toggle.gameObject.name)
		{
		case "Toggle_BGM":
			if (settingInfo.on_sound_bgm != toggle.isOn)
			{
				settingInfo.on_sound_bgm = toggle.isOn;
				if (settingInfo.on_sound_bgm)
				{
					slider_bgm.value = settingInfo.value_bgm;
					audioMixer.SetFloat("BGM", LinearToDecibel(settingInfo.value_bgm));
				}
				else
				{
					slider_bgm.value = 0f;
					audioMixer.SetFloat("BGM", LinearToDecibel(0f));
				}
				isChangeData = true;
			}
			break;
		case "Toggle_Effect":
			if (settingInfo.on_sound_eff != toggle.isOn)
			{
				settingInfo.on_sound_eff = toggle.isOn;
				if (settingInfo.on_sound_eff)
				{
					slider_eff.value = settingInfo.value_eff;
					audioMixer.SetFloat("Effect", LinearToDecibel(settingInfo.value_eff));
				}
				else
				{
					slider_eff.value = 0f;
					audioMixer.SetFloat("Effect", LinearToDecibel(0f));
				}
				isChangeData = true;
			}
			break;
		case "Toggle_Haptic":
			if (settingInfo.on_haptic != toggle.isOn)
			{
				settingInfo.on_haptic = toggle.isOn;
				if (settingInfo.on_haptic)
				{
					slider_haptic.value = settingInfo.value_haptic;
				}
				else
				{
					slider_haptic.value = 0f;
				}
				isChangeData = true;
			}
			break;
		case "Toggle_LeftHand":
			if (settingInfo.on_right_handed != !toggle.isOn)
			{
				settingInfo.on_right_handed = !toggle.isOn;
				if (this.action_hand != null)
				{
					this.action_hand(settingInfo.on_right_handed);
				}
				isChangeData = true;
			}
			break;
		case "Toggle_RightHand":
			if (settingInfo.on_right_handed != toggle.isOn)
			{
				settingInfo.on_right_handed = toggle.isOn;
				if (this.action_hand != null)
				{
					this.action_hand(settingInfo.on_right_handed);
				}
				isChangeData = true;
			}
			break;
		case "Toggle_Voice":
			if (settingInfo.on_sound_voice != toggle.isOn)
			{
				settingInfo.on_sound_voice = toggle.isOn;
				if (settingInfo.on_sound_voice)
				{
					slider_voice_chat.value = settingInfo.value_voice;
					audioMixer.SetFloat("VoiceChat", LinearToDecibel(settingInfo.value_voice));
				}
				else
				{
					slider_voice_chat.value = 0f;
					audioMixer.SetFloat("VoiceChat", LinearToDecibel(0f));
				}
				micAmplifier.AmplificationFactor = slider_voice_chat.value * 3f;
				isChangeData = true;
			}
			break;
		}
	}

	public void OnValueDropdown(Dropdown dropdown)
	{
		_ = dropdown.gameObject.name;
		if (languageState != (LanguageState)dropdown.value)
		{
			languageState = (LanguageState)dropdown.value;
			switch (languageState)
			{
			case LanguageState.english:
				settingInfo.language = "english";
				break;
			case LanguageState.koreana:
				settingInfo.language = "koreana";
				break;
			case LanguageState.japanese:
				settingInfo.language = "japanese";
				break;
			case LanguageState.spanish:
				settingInfo.language = "spanish";
				break;
			case LanguageState.german:
				settingInfo.language = "german";
				break;
			case LanguageState.portuguese:
				settingInfo.language = "portuguese";
				break;
			case LanguageState.russian:
				settingInfo.language = "russian";
				break;
			case LanguageState.italian:
				settingInfo.language = "italian";
				break;
			case LanguageState.polish:
				settingInfo.language = "polish";
				break;
			case LanguageState.turkish:
				settingInfo.language = "turkish";
				break;
			case LanguageState.schinese:
				settingInfo.language = "schinese";
				break;
			case LanguageState.tchinese:
				settingInfo.language = "tchinese";
				break;
			case LanguageState.french:
				settingInfo.language = "french";
				break;
			}
			if (SingletonBase.Singleton<StaticLocalizationCtrl>.IsInstance)
			{
				SingletonBase.Singleton<StaticLocalizationCtrl>.GetInstance.SetLocaliztion();
			}
			if (SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.IsInstance)
			{
				SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.SetLocaliztion();
			}
			if (SingletonBase.Singleton<StaticResourcesChangeCtrl>.IsInstance)
			{
				SingletonBase.Singleton<StaticResourcesChangeCtrl>.GetInstance.SetData();
			}
			PublicGameUIManager.GetInstance.SetLocaliztion();
			if (SingletonBase.Singleton<LobbyUIManager>.IsInstance)
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetModeLocalization();
				SingletonBase.Singleton<UserInfoManager>.GetInstance.StartGetAchieveList();
			}
			if (this.action_localization != null)
			{
				this.action_localization();
			}
			if (this.action_localization_put != null)
			{
				this.action_localization_put(languageState);
			}
			isChangeData = true;
		}
	}

	public AudioMixerGroup GetAudioMixerGroup(string subPath)
	{
		Init();
		if (audioMixer == null)
		{
			return null;
		}
		return audioMixer.FindMatchingGroups(subPath)[0];
	}

	public float GetHapticValue()
	{
		Init();
		if (settingInfo.on_haptic)
		{
			return settingInfo.value_haptic;
		}
		return 0f;
	}

	public void SetRightHanded()
	{
		Init();
		settingInfo.on_right_handed = !settingInfo.on_right_handed;
		if (this.action_hand != null)
		{
			this.action_hand(settingInfo.on_right_handed);
		}
		UnityEngine.Debug.LogWarning("SetRightHanded() - " + (settingInfo.on_right_handed ? "RightHanded" : "LeftHanded"));
	}

	public bool IsRightHanded()
	{
		Init();
		return settingInfo.on_right_handed;
	}

	public void AddHandChangedEvent(Action<bool> action)
	{
		action_hand += action;
	}

	public void ClearHandChangedEvent()
	{
		this.action_hand = null;
	}

	public void AddLocalizationChangedEvent(Action action)
	{
		action_localization += action;
	}

	public void AddLocalizationChangedEvent(Action<LanguageState> action)
	{
		action(languageState);
		action_localization_put += action;
	}

	public void ClearLocalizationChangedEvent()
	{
		this.action_localization = null;
		this.action_localization_put = null;
	}

	public LanguageState GetLanguageState()
	{
		Init();
		return languageState;
	}

	private void OnDisable()
	{
		if (isChangeData)
		{
			isChangeData = false;
			SaveData();
		}
	}

	public void SaveData()
	{
		if (settingInfo != null)
		{
			File.WriteAllText(UnityEngine.Application.persistentDataPath + "/SettingData.json", JsonUtility.ToJson(settingInfo));
		}
	}

	public void CSVToJson()
	{
		if (File.Exists(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Sheets/Sheet_Localization.csv"))
		{
			string contents = JsonUtility.ToJson(new JsonParsing("Sheet_Localization.csv"));
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/LocalizationData.json", contents);
			UnityEngine.Debug.Log("Save JsonFile - LocalizationData");
		}
		else
		{
			UnityEngine.Debug.LogError("Not find Sheet_Localization");
		}
	}

	public LanguageState GetChangeLanguageState(string lang)
	{
		return lang switch
		{
			"english" => LanguageState.english, 
			"koreana" => LanguageState.koreana, 
			"japanese" => LanguageState.japanese, 
			"spanish" => LanguageState.spanish, 
			"german" => LanguageState.german, 
			"portuguese" => LanguageState.portuguese, 
			"russian" => LanguageState.russian, 
			"italian" => LanguageState.italian, 
			"polish" => LanguageState.polish, 
			"turkish" => LanguageState.turkish, 
			"schinese" => LanguageState.schinese, 
			"tchinese" => LanguageState.tchinese, 
			"french" => LanguageState.french, 
			_ => LanguageState.english, 
		};
	}

	public static string GetLocalizationText(string id)
	{
		try
		{
			return localizationInfos[id][(int)languageState];
		}
		catch (Exception)
		{
			return "None";
		}
	}

	public static string GetUILanguage()
	{
		return settingInfo.language;
	}
}
public enum LanguageState
{
	english,
	koreana,
	japanese,
	spanish,
	german,
	portuguese,
	russian,
	italian,
	polish,
	turkish,
	schinese,
	tchinese,
	french
}
public class LobbyBillboardCtrl : MonoBehaviour
{
	public Transform camTr;

	private void LateUpdate()
	{
		Vector3 vector = base.transform.position - camTr.position;
		vector.y = 0f;
		base.transform.rotation = Quaternion.LookRotation(vector.normalized);
	}
}
public class LobbyHandCtrl : MonoBehaviour
{
	private bool isTrigger;

	private Animator anim;

	private void Start()
	{
		anim = base.transform.GetComponent<Animator>();
	}

	private void FixedUpdate()
	{
		if (!isTrigger)
		{
			anim.SetBool("IsPoint", value: false);
		}
		isTrigger = false;
	}

	private void OnTriggerStay(Collider other)
	{
		anim.SetBool("IsPoint", value: true);
		isTrigger = true;
	}
}
public class LobbyHologramCtrl : SingletonBase.Singleton<LobbyHologramCtrl>
{
	private bool isPlay;

	private int gameNum;

	private Animator anim;

	public GameObject arrow;

	private LobbyPropData lobbyPropData;

	public GameObject[] gos_activeProp;

	private Transform[] boneTrs;

	public Vector3[] setPoses;

	public Vector3[] setRots;

	private void Start()
	{
		anim = base.transform.GetChild(0).GetComponent<Animator>();
		anim.gameObject.SetActive(value: false);
		arrow.SetActive(value: false);
		boneTrs = new Transform[59];
		Transform[] componentsInChildren = anim.transform.GetComponentsInChildren<Transform>(includeInactive: true);
		lobbyPropData = new LobbyPropData();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			switch (componentsInChildren[i].name)
			{
			case "ITEM_HEAD":
				lobbyPropData.mesh_head = componentsInChildren[i].GetComponent<MeshFilter>();
				break;
			case "ITEM_HAIR_F":
				lobbyPropData.mesh_hair_f = componentsInChildren[i].GetComponent<MeshFilter>();
				break;
			case "ITEM_HAIR_B":
				lobbyPropData.mesh_hair_b = componentsInChildren[i].GetComponent<MeshFilter>();
				break;
			case "BODY_ORG_HIDDEN":
				lobbyPropData.mesh_body = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				break;
			case "ITEM_UPPER":
				lobbyPropData.mesh_upper = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				break;
			case "ITEM_LOWER":
				lobbyPropData.mesh_lower = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				break;
			case "ITEM_LOWER_SUB":
				lobbyPropData.mesh_lower_s = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				break;
			case "ITEM_FOOT":
				lobbyPropData.mesh_foot = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				break;
			case "ITEM_HEAD_ACC":
				lobbyPropData.mesh_acc = componentsInChildren[i].GetComponent<MeshFilter>();
				break;
			}
			int num = WearInfoCreator.BoneNameToIndex(componentsInChildren[i].name);
			if (num != -1)
			{
				boneTrs[num] = componentsInChildren[i];
			}
		}
	}

	public void PlayHologram()
	{
		if (!isPlay)
		{
			anim.gameObject.SetActive(value: true);
			arrow.SetActive(value: true);
			anim.SetInteger("StateNum", gameNum);
			anim.SetTrigger("OnState");
			anim.SetBool("IsPlay", value: true);
			isPlay = true;
		}
	}

	public void StopHologram()
	{
		if (isPlay)
		{
			anim.gameObject.SetActive(value: false);
			arrow.SetActive(value: false);
			isPlay = false;
		}
	}

	public void SetHologram(LobbyPropData _propData, GameData_DDOL.GameType _gameType)
	{
		lobbyPropData.mesh_head.sharedMesh = _propData.mesh_head.sharedMesh;
		if (_propData.mesh_hair_f != null)
		{
			lobbyPropData.mesh_hair_f.sharedMesh = _propData.mesh_hair_f.sharedMesh;
			lobbyPropData.mesh_hair_f.gameObject.SetActive(value: true);
		}
		else
		{
			lobbyPropData.mesh_hair_f.gameObject.SetActive(value: false);
		}
		if (_propData.mesh_hair_b != null)
		{
			lobbyPropData.mesh_hair_b.sharedMesh = _propData.mesh_hair_b.sharedMesh;
			lobbyPropData.mesh_hair_b.gameObject.SetActive(value: true);
		}
		else
		{
			lobbyPropData.mesh_hair_b.gameObject.SetActive(value: false);
		}
		lobbyPropData.mesh_body.sharedMesh = _propData.mesh_body.sharedMesh;
		lobbyPropData.mesh_body.localBounds = new Bounds(_propData.mesh_body.localBounds.center, _propData.mesh_body.localBounds.extents * 2f);
		lobbyPropData.mesh_upper.sharedMesh = _propData.mesh_upper.sharedMesh;
		lobbyPropData.mesh_upper.localBounds = new Bounds(_propData.mesh_upper.localBounds.center, _propData.mesh_upper.localBounds.extents * 2f);
		if (_propData.mesh_lower != null)
		{
			lobbyPropData.mesh_lower.sharedMesh = _propData.mesh_lower.sharedMesh;
			lobbyPropData.mesh_lower.localBounds = new Bounds(_propData.mesh_lower.localBounds.center, _propData.mesh_lower.localBounds.extents * 2f);
			lobbyPropData.mesh_lower.gameObject.SetActive(value: true);
		}
		else
		{
			lobbyPropData.mesh_lower.gameObject.SetActive(value: false);
		}
		if (_propData.mesh_lower_s != null)
		{
			lobbyPropData.mesh_lower_s.sharedMesh = _propData.mesh_lower_s.sharedMesh;
			lobbyPropData.mesh_lower_s.localBounds = new Bounds(_propData.mesh_lower_s.localBounds.center, _propData.mesh_lower_s.localBounds.extents * 2f);
			lobbyPropData.mesh_lower_s.gameObject.SetActive(value: true);
		}
		else
		{
			lobbyPropData.mesh_lower_s.gameObject.SetActive(value: false);
		}
		if (_propData.mesh_foot != null)
		{
			lobbyPropData.mesh_foot.sharedMesh = _propData.mesh_foot.sharedMesh;
			lobbyPropData.mesh_foot.localBounds = new Bounds(_propData.mesh_foot.localBounds.center, _propData.mesh_foot.localBounds.extents * 2f);
			lobbyPropData.mesh_foot.gameObject.SetActive(value: true);
		}
		else
		{
			lobbyPropData.mesh_foot.gameObject.SetActive(value: false);
		}
		if (_propData.mesh_acc != null)
		{
			lobbyPropData.mesh_acc.sharedMesh = _propData.mesh_acc.sharedMesh;
			lobbyPropData.mesh_acc.gameObject.SetActive(value: true);
		}
		else
		{
			lobbyPropData.mesh_acc.gameObject.SetActive(value: false);
		}
		gameNum = (int)_gameType;
		anim.transform.localPosition = setPoses[gameNum - 1];
		anim.transform.localRotation = Quaternion.Euler(setRots[gameNum - 1]);
		switch (_gameType)
		{
		case GameData_DDOL.GameType.Bowling:
		{
			for (int num2 = 0; num2 < gos_activeProp.Length; num2++)
			{
				if (num2 == 0)
				{
					gos_activeProp[num2].SetActive(value: true);
				}
				else
				{
					gos_activeProp[num2].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Archery:
		{
			for (int num6 = 0; num6 < gos_activeProp.Length; num6++)
			{
				if (num6 == 1)
				{
					gos_activeProp[num6].SetActive(value: true);
				}
				else
				{
					gos_activeProp[num6].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Basketball:
		{
			for (int l = 0; l < gos_activeProp.Length; l++)
			{
				if (l == 2)
				{
					gos_activeProp[l].SetActive(value: true);
				}
				else
				{
					gos_activeProp[l].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Badminton:
		{
			for (int num4 = 0; num4 < gos_activeProp.Length; num4++)
			{
				if (num4 == 3 || num4 == 4)
				{
					gos_activeProp[num4].SetActive(value: true);
				}
				else
				{
					gos_activeProp[num4].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Billiards:
		{
			for (int n = 0; n < gos_activeProp.Length; n++)
			{
				if (n == 5)
				{
					gos_activeProp[n].SetActive(value: true);
				}
				else
				{
					gos_activeProp[n].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Darts:
		{
			for (int j = 0; j < gos_activeProp.Length; j++)
			{
				if (j == 6)
				{
					gos_activeProp[j].SetActive(value: true);
				}
				else
				{
					gos_activeProp[j].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.TableTennis:
		{
			for (int num5 = 0; num5 < gos_activeProp.Length; num5++)
			{
				if (num5 == 7 || num5 == 8)
				{
					gos_activeProp[num5].SetActive(value: true);
				}
				else
				{
					gos_activeProp[num5].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Boxing:
		{
			for (int num3 = 0; num3 < gos_activeProp.Length; num3++)
			{
				if (num3 == 9)
				{
					gos_activeProp[num3].SetActive(value: true);
				}
				else
				{
					gos_activeProp[num3].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Golf:
		{
			for (int num = 0; num < gos_activeProp.Length; num++)
			{
				if (num == 10 || num == 11)
				{
					gos_activeProp[num].SetActive(value: true);
				}
				else
				{
					gos_activeProp[num].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Baseball:
		{
			for (int m = 0; m < gos_activeProp.Length; m++)
			{
				if (m == 12 || m == 13)
				{
					gos_activeProp[m].SetActive(value: true);
				}
				else
				{
					gos_activeProp[m].SetActive(value: false);
				}
			}
			break;
		}
		case GameData_DDOL.GameType.Tennis:
		{
			for (int k = 0; k < gos_activeProp.Length; k++)
			{
				if (k == 14 || k == 15)
				{
					gos_activeProp[k].SetActive(value: true);
				}
				else
				{
					gos_activeProp[k].SetActive(value: false);
				}
			}
			break;
		}
		default:
		{
			for (int i = 0; i < gos_activeProp.Length; i++)
			{
				gos_activeProp[i].SetActive(value: false);
			}
			break;
		}
		}
	}
}
public class LobbyPhotonManager : SingletonPunBase.Singleton<LobbyPhotonManager>
{
	public enum MatchState
	{
		Random,
		Friend
	}

	public class ServerInfo
	{
		public string name;

		public string code;

		public string ping;

		public int grade;
	}

	private const string PHOTON_REALTIME_APP_ID = "a0444e18-b386-4d89-b8c8-776e1aefe0ff";

	private const string PHOTON_VOICE_APP_ID = "7939b848-5a46-4592-a5fc-df2c5cb65750";

	private MatchState matchState;

	public bool isReady;

	private List<RoomInfo> keep_roomInfos;

	private GameData_DDOL.GameType find_gameType;

	public ServerInfo[] serverInfos;

	public int index_server;

	private Coroutine timeCoroutine;

	private void Start()
	{
		PhotonNetwork.SerializationRate = 10;
		PhotonNetwork.SendRate = 20;
		PhotonNetwork.AutomaticallySyncScene = true;
		PhotonNetwork.MinimalTimeScaleToDispatchInFixedUpdate = 1f;
		StartDisconnect();
	}

	public void StartConnect(bool isRandom)
	{
		matchState = ((!isRandom) ? MatchState.Friend : MatchState.Random);
		StartConnect();
	}

	public void StartConnect(string regionCode = "")
	{
		isReady = false;
		PhotonNetwork.LocalPlayer.NickName = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick;
		PhotonNetwork.LocalPlayer.CustomProperties = new ExitGames.Client.Photon.Hashtable();
		PhotonNetwork.LocalPlayer.CustomProperties.Add("AppnoriID", SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id);
		PhotonNetwork.LocalPlayer.CustomProperties.Add("Win", SingletonBase.Singleton<UserInfoManager>.GetInstance.score_win_mine);
		PhotonNetwork.LocalPlayer.CustomProperties.Add("Lose", SingletonBase.Singleton<UserInfoManager>.GetInstance.score_lose_mine);
		PhotonNetwork.LocalPlayer.CustomProperties.Add("Dis", SingletonBase.Singleton<UserInfoManager>.GetInstance.score_disconnect_mine);
		PhotonNetwork.LocalPlayer.CustomProperties.Add("GameReady", true);
		PhotonNetwork.LocalPlayer.CustomProperties.Add("ModelData", JsonUtility.ToJson(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData()));
		PhotonNetwork.PhotonServerSettings.AppSettings.AppIdRealtime = "a0444e18-b386-4d89-b8c8-776e1aefe0ff";
		PhotonNetwork.PhotonServerSettings.AppSettings.AppIdVoice = "7939b848-5a46-4592-a5fc-df2c5cb65750";
		PhotonNetwork.PhotonServerSettings.AppSettings.AppVersion = UnityEngine.Application.version + "_aio";
		PhotonNetwork.PhotonServerSettings.AppSettings.UseNameServer = true;
		PhotonNetwork.PhotonServerSettings.AppSettings.FixedRegion = regionCode;
		PhotonNetwork.PhotonServerSettings.AppSettings.Server = "";
		PhotonNetwork.PhotonServerSettings.AppSettings.Port = 0;
		PhotonNetwork.ConnectUsingSettings();
	}

	public void StartDisconnect()
	{
		isReady = false;
		PhotonNetwork.IsSyncScene = false;
		if (PhotonNetwork.IsConnected)
		{
			PhotonNetwork.Disconnect();
		}
		if (timeCoroutine != null)
		{
			StopCoroutine(timeCoroutine);
		}
		SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_time.text = "";
	}

	public void ClearServerInfos()
	{
		serverInfos = null;
	}

	public override void OnConnectedToMaster()
	{
		if (serverInfos == null && string.IsNullOrEmpty(PhotonNetwork.PhotonServerSettings.AppSettings.FixedRegion))
		{
			serverInfos = new ServerInfo[PhotonNetwork.NetworkingClient.RegionHandler.EnabledRegions.Count];
			for (int i = 0; i < serverInfos.Length; i++)
			{
				serverInfos[i] = new ServerInfo();
				serverInfos[i].code = PhotonNetwork.NetworkingClient.RegionHandler.EnabledRegions[i].Code;
				serverInfos[i].name = GetServerName(serverInfos[i].code);
				serverInfos[i].ping = PhotonNetwork.NetworkingClient.RegionHandler.EnabledRegions[i].Ping + "ms";
				if (PhotonNetwork.NetworkingClient.RegionHandler.EnabledRegions[i].Ping >= 200)
				{
					serverInfos[i].grade = 2;
				}
				else if (PhotonNetwork.NetworkingClient.RegionHandler.EnabledRegions[i].Ping >= 100)
				{
					serverInfos[i].grade = 1;
				}
				else
				{
					serverInfos[i].grade = 0;
				}
			}
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.InitServerUI();
		}
		PhotonNetwork.JoinLobby();
	}

	public string GetServerName(string code)
	{
		return code.ToLower() switch
		{
			"us" => "USA", 
			"eu" => "Europe", 
			"ru" => "Russia", 
			"sa" => "<size=40>S.America</size>", 
			"kr" => "Korea", 
			"asia" => "Asia", 
			"cn" => "China", 
			_ => code, 
		};
	}

	public void SetFindRoom(GameData_DDOL.GameType gameType)
	{
		isReady = false;
		find_gameType = gameType;
		if (PhotonNetwork.InRoom)
		{
			PhotonNetwork.LeaveRoom();
		}
	}

	public override void OnRoomListUpdate(List<RoomInfo> roomList)
	{
		if (matchState == MatchState.Random)
		{
			GameData_DDOL.GameType gameType = find_gameType;
			find_gameType = GameData_DDOL.GameType.None;
			keep_roomInfos = roomList;
			if (gameType == GameData_DDOL.GameType.None)
			{
				for (int i = 0; i < roomList.Count; i++)
				{
					if (roomList[i].CustomProperties != null && roomList[i].CustomProperties.ContainsKey("GameType") && roomList[i].CustomProperties.ContainsKey("Code") && (GameData_DDOL.GameType)roomList[i].CustomProperties["GameType"] == SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType && (string)roomList[i].CustomProperties["Code"] == "" && roomList[i].PlayerCount != roomList[i].MaxPlayers)
					{
						PhotonNetwork.JoinRoom(roomList[i].Name);
						return;
					}
				}
			}
			else
			{
				for (int j = 0; j < roomList.Count; j++)
				{
					if (roomList[j].CustomProperties != null && roomList[j].CustomProperties.ContainsKey("GameType") && roomList[j].CustomProperties.ContainsKey("Code") && (GameData_DDOL.GameType)roomList[j].CustomProperties["GameType"] == gameType && (string)roomList[j].CustomProperties["Code"] == "" && roomList[j].PlayerCount != roomList[j].MaxPlayers)
					{
						SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = gameType;
						PhotonNetwork.JoinRoom(roomList[j].Name);
						return;
					}
				}
			}
			for (int k = 0; k < SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType.Length; k++)
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[k].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[0]);
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[k].SetInteractable(_isInteractable: false);
			}
			for (int l = 0; l < roomList.Count; l++)
			{
				if (roomList[l].CustomProperties != null && roomList[l].CustomProperties.ContainsKey("GameType") && roomList[l].CustomProperties.ContainsKey("Code") && !((string)roomList[l].CustomProperties["Code"] != "") && roomList[l].PlayerCount != roomList[l].MaxPlayers)
				{
					switch ((GameData_DDOL.GameType)roomList[l].CustomProperties["GameType"])
					{
					case GameData_DDOL.GameType.Bowling:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[0].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[0].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Archery:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[1].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[1].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Basketball:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[2].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[2].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Badminton:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[3].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[3].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Billiards:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[4].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[4].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Darts:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[5].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[5].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.TableTennis:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[6].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[6].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Boxing:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[7].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[7].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Golf:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[8].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[8].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Baseball:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[9].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[9].SetInteractable(_isInteractable: true);
						break;
					case GameData_DDOL.GameType.Tennis:
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[10].SetMaterial(SingletonBase.Singleton<LobbyUIManager>.GetInstance.materials_lobbyUI[1]);
						SingletonBase.Singleton<LobbyUIManager>.GetInstance.meshButtons_gameType[10].SetInteractable(_isInteractable: true);
						break;
					}
				}
			}
		}
		else
		{
			for (int m = 0; m < roomList.Count; m++)
			{
				if (roomList[m].CustomProperties != null && roomList[m].CustomProperties.ContainsKey("GameType") && roomList[m].CustomProperties.ContainsKey("Code") && (string)roomList[m].CustomProperties["Code"] == SingletonBase.Singleton<LobbyUIManager>.GetInstance.GetRoomCode() && roomList[m].PlayerCount != roomList[m].MaxPlayers)
				{
					PhotonNetwork.JoinRoom(roomList[m].Name);
					return;
				}
			}
		}
		CreateRoom();
	}

	public override void OnJoinedRoom()
	{
		isReady = true;
		UpdateRoomInfo();
	}

	public override void OnJoinRoomFailed(short returnCode, string message)
	{
		PhotonNetwork.JoinLobby();
	}

	private void CreateRoom()
	{
		Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
		roomOptions.PublishUserId = true;
		roomOptions.MaxPlayers = 2;
		roomOptions.CustomRoomProperties = new ExitGames.Client.Photon.Hashtable();
		roomOptions.CustomRoomProperties.Add("GameType", SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType);
		GameData_DDOL.GameType gameType = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType;
		if ((uint)(gameType - 1) <= 3u)
		{
			roomOptions.CleanupCacheOnLeave = false;
		}
		if (matchState == MatchState.Friend)
		{
			roomOptions.CustomRoomProperties.Add("Code", SingletonBase.Singleton<LobbyUIManager>.GetInstance.GetRoomCode());
		}
		else
		{
			roomOptions.CustomRoomProperties.Add("Code", "");
		}
		roomOptions.CustomRoomPropertiesForLobby = new string[2] { "GameType", "Code" };
		PhotonNetwork.CreateRoom("Lobby" + Time.time, roomOptions);
	}

	public override void OnPlayerEnteredRoom(Player newPlayer)
	{
		UpdateRoomInfo();
	}

	public override void OnPlayerLeftRoom(Player otherPlayer)
	{
		UpdateRoomInfo();
	}

	public override void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
	{
		UpdateRoomInfo();
	}

	private void UpdateRoomInfo()
	{
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = (GameData_DDOL.GameType)PhotonNetwork.CurrentRoom.CustomProperties["GameType"];
		SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetViewGameType();
		int num = 0;
		foreach (KeyValuePair<int, Player> item in PhotonNetwork.CurrentRoom.Players.OrderBy((KeyValuePair<int, Player> i) => i.Value.ActorNumber))
		{
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[num].id = (string)item.Value.CustomProperties["AppnoriID"];
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[num].nick = item.Value.NickName;
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[num] = JsonUtility.FromJson<CustomModelData>((string)item.Value.CustomProperties["ModelData"]);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_userNick[num].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[num].nick;
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_userInfo[num].text = (int)item.Value.CustomProperties["Win"] + "W " + (int)item.Value.CustomProperties["Lose"] + "L";
			num++;
		}
		if (num == 1)
		{
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_userNick[1].text = "Waiting...";
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_userInfo[1].text = "";
			PublicGameUIManager.profileCapture.PlayImages(new string[1] { SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id }, ProfileCaptureCtrl.ShotState.Multi);
			if (matchState == MatchState.Random)
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id = "AI";
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id;
			}
			else
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_time.text = "";
			}
			StartTimeCoroutine(isMatch: false);
		}
		else
		{
			PublicGameUIManager.profileCapture.PlayImages(new string[2]
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id,
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id
			}, ProfileCaptureCtrl.ShotState.Multi);
			StartTimeCoroutine(isMatch: true);
		}
	}

	public void StartTimeCoroutine(bool isMatch)
	{
		if (timeCoroutine != null)
		{
			StopCoroutine(timeCoroutine);
		}
		timeCoroutine = StartCoroutine(TimeCoroutine(isMatch));
	}

	private IEnumerator TimeCoroutine(bool isMatch)
	{
		if (!isMatch)
		{
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetMatchBackButton(isActive: true);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetOtherGames(matchState == MatchState.Random);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetServerUI(isActive: true);
			if (matchState == MatchState.Friend || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf)
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_time.text = "";
				yield break;
			}
			for (int countTime2 = 30; countTime2 > 0; countTime2--)
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_time.text = countTime2.ToString();
				yield return new WaitForSecondsRealtime(1f);
			}
			if (PhotonNetwork.IsConnected)
			{
				PhotonNetwork.Disconnect();
			}
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Networks/WaitingSingleManager")).GetComponent<WaitingSingleManager>().keep_serverCode = GetServerInfo().code;
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_userNick[1].text = "AI";
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetViewMatchText();
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetOtherGames(isActive: false);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetServerUI(isActive: false);
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetRandomLevel();
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single = new CustomModelData[5];
			for (int i = 0; i < SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single.Length; i++)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[i] = CustomModelSettingCtrl.GetRandomModelData();
			}
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.Single;
			PublicGameUIManager.profileCapture.PlayImages(new string[2]
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id,
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id
			}, ProfileCaptureCtrl.ShotState.Multi);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetMatchBackButton(isActive: false);
			yield return new WaitForSecondsRealtime(1f);
			PhotonNetwork.IsSyncScene = false;
			PhotonNetwork.isLoadLevel = false;
			for (int countTime2 = 3; countTime2 > 0; countTime2--)
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_time.text = countTime2.ToString();
				yield return new WaitForSecondsRealtime(1f);
			}
			SingletonBase.Singleton<LobbyPropManager>.GetInstance.StartGame();
		}
		else
		{
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetMatchBackButton(isActive: false);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetOtherGames(isActive: false);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetServerUI(isActive: false);
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetViewMatchText();
			yield return new WaitForSecondsRealtime(1f);
			PhotonNetwork.IsSyncScene = true;
			PhotonNetwork.isLoadLevel = true;
			for (int countTime2 = 3; countTime2 > 0; countTime2--)
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.text_time.text = countTime2.ToString();
				yield return new WaitForSecondsRealtime(1f);
			}
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.Multi;
			SingletonBase.Singleton<LobbyPropManager>.GetInstance.StartGame();
		}
	}

	public ServerInfo GetServerInfo()
	{
		return serverInfos[index_server];
	}
}
public enum LobbyState
{
	Lobby,
	Customize
}
[Serializable]
public class LobbyHandInfo
{
	public enum PointState
	{
		IdleHand,
		PointHand,
		PropPoint,
		UIPoint
	}

	public Animator anim;

	public bool isExit;

	public bool isUI;

	public PointState pointState;

	public Transform rayDir;

	public Transform line_transform;

	public Transform ball_transform;
}
public class TriggerButtonInfo
{
	public InputDevice inputDevice;

	public bool isOn;
}
public class LobbyPlayerCtrl : MonoBehaviour
{
	public LobbyState lobbyState;

	public LobbyPropCtrl grab_prop_lobby;

	public CustomizeItemCtrl grab_prop_custom;

	private int handActiveState = -1;

	public LobbyHandInfo[] handInfos = new LobbyHandInfo[2];

	private TriggerButtonInfo[] triggerButtons;

	public LayerMask layerMask;

	private float previousDirY;

	private float previousUIY;

	private bool isRotation;

	private bool isPalette_h;

	private bool isPalette_sv;

	private Vector2 previousDir_hand;

	private Vector2 previousDir_arm;

	private float rotForce;

	private float drag = 2f;

	private Vector3 system_buttons = new Vector3(0f, 0.73f, 0.64f);

	private void Awake()
	{
		triggerButtons = new TriggerButtonInfo[2];
	}

	private void OnEnable()
	{
		InputDevices_Update(default(InputDevice));
		InputDevices.deviceConnected += InputDevices_Update;
		InputDevices.deviceDisconnected += InputDevices_Update;
	}

	private void OnDisable()
	{
		InputDevices.deviceConnected -= InputDevices_Update;
		InputDevices.deviceDisconnected -= InputDevices_Update;
	}

	private void InputDevices_Update(InputDevice _device)
	{
		List<InputDevice> list = new List<InputDevice>();
		InputDevices.GetDevicesAtXRNode(XRNode.LeftHand, list);
		bool flag = false;
		foreach (InputDevice item in list)
		{
			if (item.TryGetFeatureValue(CommonUsages.trigger, out var _))
			{
				triggerButtons[0] = new TriggerButtonInfo();
				triggerButtons[0].inputDevice = item;
				triggerButtons[0].isOn = true;
				flag = true;
			}
		}
		if (!flag)
		{
			triggerButtons[0] = null;
		}
		list.Clear();
		InputDevices.GetDevicesAtXRNode(XRNode.RightHand, list);
		flag = false;
		foreach (InputDevice item2 in list)
		{
			if (item2.TryGetFeatureValue(CommonUsages.trigger, out var _))
			{
				triggerButtons[1] = new TriggerButtonInfo();
				triggerButtons[1].inputDevice = item2;
				triggerButtons[1].isOn = true;
				flag = true;
			}
		}
		if (!flag)
		{
			triggerButtons[1] = null;
		}
	}

	private void Update()
	{
		if (!OVRManager.hasInputFocus)
		{
			if (handInfos[0].pointState != 0)
			{
				handInfos[0].pointState = LobbyHandInfo.PointState.IdleHand;
				handInfos[0].anim.SetBool("IsPoint", value: false);
				handInfos[0].ball_transform.gameObject.SetActive(value: false);
				handInfos[0].line_transform.gameObject.SetActive(value: false);
			}
		}
		else
		{
			if (PublicGameUIManager.GetInstance.GetCurrentState() != 0)
			{
				return;
			}
			if (lobbyState == LobbyState.Lobby)
			{
				if (SingletonBase.Singleton<LobbyPropManager>.GetInstance.isStartGame)
				{
					return;
				}
				for (int i = 0; i < 2; i++)
				{
					if ((handInfos[i].rayDir.position - system_buttons).sqrMagnitude <= 0.03f)
					{
						handInfos[i].isExit = true;
						if (handInfos[i].pointState != LobbyHandInfo.PointState.PointHand)
						{
							handInfos[i].pointState = LobbyHandInfo.PointState.PointHand;
							handInfos[i].anim.SetBool("IsPoint", value: true);
							handInfos[i].ball_transform.gameObject.SetActive(value: false);
							handInfos[i].line_transform.gameObject.SetActive(value: false);
						}
					}
					else
					{
						handInfos[i].isExit = false;
					}
				}
				if (SingletonBase.Singleton<LobbyUIManager>.GetInstance.lobbyUIState != 0)
				{
					for (int j = 0; j < 2; j++)
					{
						if (handInfos[j].isExit)
						{
							continue;
						}
						if (Physics.Raycast(handInfos[j].rayDir.position, handInfos[j].rayDir.forward, out var hitInfo, 3f, layerMask))
						{
							Vector3 forward = hitInfo.point - handInfos[j].rayDir.position;
							handInfos[j].isUI = true;
							if (handInfos[j].pointState != LobbyHandInfo.PointState.UIPoint)
							{
								handInfos[j].pointState = LobbyHandInfo.PointState.UIPoint;
								handInfos[j].anim.SetBool("IsPoint", value: true);
								handInfos[j].ball_transform.gameObject.SetActive(value: true);
								handInfos[j].line_transform.gameObject.SetActive(value: true);
							}
							handInfos[j].ball_transform.position = hitInfo.point;
							handInfos[j].line_transform.position = handInfos[j].rayDir.position;
							handInfos[j].line_transform.rotation = Quaternion.LookRotation(forward);
							handInfos[j].line_transform.localScale = Vector3.forward * forward.magnitude;
							float value = 0.5f;
							if (!triggerButtons[j].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out value))
							{
								continue;
							}
							bool flag = value >= 0.6f && !triggerButtons[j].isOn;
							bool flag2 = value <= 0.4f && triggerButtons[j].isOn;
							if (!(flag || flag2))
							{
								continue;
							}
							triggerButtons[j].isOn = flag;
							if (triggerButtons[j].isOn)
							{
								MeshButtonCtrl component = hitInfo.collider.GetComponent<MeshButtonCtrl>();
								if (component != null && component.IsInteractable())
								{
									component.event_click.Invoke();
								}
								else if (hitInfo.collider.gameObject.layer == 5)
								{
									handActiveState = j;
								}
							}
						}
						else
						{
							handInfos[j].isUI = false;
							if (handInfos[j].pointState != LobbyHandInfo.PointState.PointHand)
							{
								handInfos[j].pointState = LobbyHandInfo.PointState.PointHand;
								handInfos[j].anim.SetBool("IsPoint", value: true);
								handInfos[j].ball_transform.gameObject.SetActive(value: false);
								handInfos[j].line_transform.gameObject.SetActive(value: false);
							}
						}
					}
					return;
				}
				if (grab_prop_lobby == null || (grab_prop_lobby != null && grab_prop_lobby.GetPropState() == PropState.Idle))
				{
					if (!handInfos[0].isExit && !handInfos[0].isUI)
					{
						if (SingletonBase.Singleton<LobbyPropManager>.GetInstance.FindNearProp(handInfos[0], 0) != null)
						{
							if (handInfos[0].pointState != LobbyHandInfo.PointState.PropPoint)
							{
								handInfos[0].pointState = LobbyHandInfo.PointState.PropPoint;
								handInfos[0].anim.SetBool("IsPoint", value: false);
								handInfos[0].ball_transform.gameObject.SetActive(value: false);
								handInfos[0].line_transform.gameObject.SetActive(value: true);
							}
						}
						else if (handInfos[0].pointState != 0)
						{
							handInfos[0].pointState = LobbyHandInfo.PointState.IdleHand;
							handInfos[0].anim.SetBool("IsPoint", value: false);
							handInfos[0].ball_transform.gameObject.SetActive(value: false);
							handInfos[0].line_transform.gameObject.SetActive(value: false);
						}
					}
					if (!handInfos[1].isExit && !handInfos[1].isUI)
					{
						if (SingletonBase.Singleton<LobbyPropManager>.GetInstance.FindNearProp(handInfos[1], 1) != null)
						{
							if (handInfos[1].pointState != LobbyHandInfo.PointState.PropPoint)
							{
								handInfos[1].pointState = LobbyHandInfo.PointState.PropPoint;
								handInfos[1].anim.SetBool("IsPoint", value: false);
								handInfos[1].ball_transform.gameObject.SetActive(value: false);
								handInfos[1].line_transform.gameObject.SetActive(value: true);
							}
						}
						else if (handInfos[1].pointState != 0)
						{
							handInfos[1].pointState = LobbyHandInfo.PointState.IdleHand;
							handInfos[1].anim.SetBool("IsPoint", value: false);
							handInfos[1].ball_transform.gameObject.SetActive(value: false);
							handInfos[1].line_transform.gameObject.SetActive(value: false);
						}
					}
				}
				else
				{
					for (int k = 0; k < 2; k++)
					{
						SingletonBase.Singleton<LobbyPropManager>.GetInstance.SetSelectPointActive(isActive: false, k);
					}
				}
				for (int l = 0; l < 2; l++)
				{
					if (l == 0)
					{
						if (handActiveState == 1 || triggerButtons[0] == null)
						{
							continue;
						}
					}
					else if (handActiveState == 0 || triggerButtons[1] == null)
					{
						continue;
					}
					if (!handInfos[l].isExit)
					{
						if (Physics.Raycast(handInfos[l].rayDir.position, handInfos[l].rayDir.forward, out var hitInfo2, 3f, layerMask))
						{
							if (hitInfo2.collider.gameObject.layer == 5)
							{
								handInfos[l].isUI = true;
								if (handInfos[l].pointState != LobbyHandInfo.PointState.UIPoint)
								{
									handInfos[l].pointState = LobbyHandInfo.PointState.UIPoint;
									handInfos[l].anim.SetBool("IsPoint", value: true);
									handInfos[l].ball_transform.gameObject.SetActive(value: true);
									handInfos[l].line_transform.gameObject.SetActive(value: true);
								}
								handInfos[l].line_transform.position = handInfos[l].rayDir.position;
								handInfos[l].line_transform.rotation = handInfos[l].rayDir.rotation;
								Vector3 vector = hitInfo2.point - handInfos[l].rayDir.position;
								handInfos[l].line_transform.localScale = Vector3.forward * vector.magnitude;
								handInfos[l].ball_transform.position = hitInfo2.point;
							}
							else
							{
								handInfos[l].isUI = false;
							}
						}
						else
						{
							handInfos[l].isUI = false;
						}
					}
					float value2 = 0.5f;
					if (triggerButtons[l].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out value2))
					{
						bool flag3 = value2 >= 0.6f && !triggerButtons[l].isOn;
						bool flag4 = value2 <= 0.4f && triggerButtons[l].isOn;
						if (flag3 || flag4)
						{
							triggerButtons[l].isOn = flag3;
							if (triggerButtons[l].isOn)
							{
								handActiveState = l;
								if (grab_prop_lobby != null)
								{
									grab_prop_lobby.SetPropState(PropState.Idle);
								}
								if (handInfos[l].isUI)
								{
									grab_prop_lobby = null;
								}
								else
								{
									grab_prop_lobby = SingletonBase.Singleton<LobbyPropManager>.GetInstance.FindNearProp(handInfos[l], l);
								}
								if (handInfos[l].pointState != 0)
								{
									handInfos[l].pointState = LobbyHandInfo.PointState.IdleHand;
									handInfos[l].anim.SetBool("IsPoint", value: false);
									handInfos[l].ball_transform.gameObject.SetActive(value: false);
									handInfos[l].line_transform.gameObject.SetActive(value: false);
								}
								if (grab_prop_lobby != null)
								{
									SingletonBase.Singleton<LobbyPropManager>.GetInstance.StopSelectGame();
									if (SingletonBase.Singleton<LobbyUIManager>.GetInstance.lobbyUIState != 0)
									{
										SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetLobbyUI(LobbyUIManager.LobbyUIState.Close);
									}
									if (SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop != null && SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop != grab_prop_lobby)
									{
										SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop.SetIdlePos();
										SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop.SetPropState(PropState.Idle);
										SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop = null;
										SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.None;
									}
									grab_prop_lobby.SetPropState(PropState.Grab, handInfos[l].rayDir, l);
								}
								else if (handInfos[l].isUI)
								{
									handActiveState = l;
								}
							}
							else
							{
								handActiveState = -1;
								if (grab_prop_lobby != null)
								{
									Vector3 forward2 = handInfos[l].rayDir.forward;
									forward2.y = 0f;
									forward2 = forward2.normalized;
									Vector3 vector2 = SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position - handInfos[l].rayDir.position;
									vector2.y = 0f;
									vector2 = vector2.normalized;
									if ((grab_prop_lobby.gameType != 0 && (handInfos[l].rayDir.position - SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position).sqrMagnitude <= 0.1f) || Vector3.Dot(forward2, vector2) >= 0.75f)
									{
										grab_prop_lobby.SetPropState(PropState.Set);
										SingletonBase.Singleton<LobbyPropManager>.GetInstance.SetSelectPointActive(isActive: false, 0);
										SingletonBase.Singleton<LobbyPropManager>.GetInstance.SetSelectPointActive(isActive: false, 1);
										break;
									}
									grab_prop_lobby.SetPropState(PropState.Idle);
								}
							}
						}
					}
					handInfos[l].anim.SetFloat("Value", value2);
				}
			}
			else
			{
				if (lobbyState != LobbyState.Customize)
				{
					return;
				}
				if (isRotation)
				{
					Vector2 normalized = new Vector2(handInfos[handActiveState].rayDir.forward.x, handInfos[handActiveState].rayDir.forward.z).normalized;
					Vector3 vector3 = handInfos[handActiveState].rayDir.position - Camera.main.transform.position;
					Vector2 normalized2 = new Vector2(vector3.x, vector3.z).normalized;
					rotForce = Vector2.SignedAngle(previousDir_hand, normalized) * 0.5f + Vector2.SignedAngle(previousDir_arm, normalized2) * 3f;
					SingletonBase.Singleton<CustomizeManager>.GetInstance.SetRotationCharacter(rotForce);
					rotForce *= 5000f * Time.deltaTime;
					previousDir_hand = normalized;
					previousDir_arm = normalized2;
				}
				else if (rotForce != 0f)
				{
					rotForce *= 1f - Time.deltaTime * drag;
					SingletonBase.Singleton<CustomizeManager>.GetInstance.SetRotationCharacter(rotForce * Time.deltaTime);
					if (Mathf.Abs(rotForce) <= 5f)
					{
						rotForce = 0f;
					}
				}
				CustomizeItemCtrl customizeItemCtrl = null;
				for (int num = 1; num >= 0; num--)
				{
					if (num == 0)
					{
						if (handActiveState == -1 && triggerButtons[0] != null)
						{
							if (Physics.Raycast(handInfos[num].rayDir.position, handInfos[num].rayDir.forward, out var hitInfo3, 3f, layerMask))
							{
								if (!handInfos[num].isUI)
								{
									handInfos[num].isUI = true;
									handInfos[num].anim.SetBool("IsPoint", handInfos[num].isUI);
								}
								Vector3 forward3 = hitInfo3.point - handInfos[num].rayDir.position;
								handInfos[num].ball_transform.position = hitInfo3.point;
								handInfos[num].line_transform.position = handInfos[num].rayDir.position;
								handInfos[num].line_transform.rotation = Quaternion.LookRotation(forward3);
								handInfos[num].line_transform.localScale = Vector3.forward * forward3.magnitude;
								float value3 = 0.5f;
								if (triggerButtons[num].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out value3))
								{
									bool flag5 = value3 >= 0.6f && !triggerButtons[num].isOn;
									bool flag6 = value3 <= 0.4f && triggerButtons[num].isOn;
									if (flag5 || flag6)
									{
										triggerButtons[num].isOn = flag5;
										if (triggerButtons[num].isOn)
										{
											MeshButtonCtrl component2 = hitInfo3.collider.GetComponent<MeshButtonCtrl>();
											if (component2 != null && component2.IsInteractable())
											{
												component2.event_click.Invoke();
												handInfos[num].line_transform.gameObject.SetActive(value: false);
												handInfos[num].ball_transform.gameObject.SetActive(value: false);
												if (handInfos[num].isUI)
												{
													handInfos[num].isUI = false;
													handInfos[num].anim.SetBool("IsPoint", handInfos[num].isUI);
												}
												continue;
											}
											ColorPaletteCtrl component3 = hitInfo3.collider.GetComponent<ColorPaletteCtrl>();
											if (component3 != null)
											{
												switch (component3.GetPaletteState(hitInfo3.point))
												{
												case 1:
													isPalette_h = true;
													handActiveState = num;
													component3.Click_Palette(isHue: true, hitInfo3.point);
													handInfos[num].line_transform.gameObject.SetActive(value: false);
													handInfos[num].ball_transform.gameObject.SetActive(value: false);
													continue;
												case 2:
													isPalette_sv = true;
													handActiveState = num;
													component3.Click_Palette(isHue: false, hitInfo3.point);
													handInfos[num].line_transform.gameObject.SetActive(value: false);
													handInfos[num].ball_transform.gameObject.SetActive(value: false);
													continue;
												}
											}
										}
									}
								}
								handInfos[num].line_transform.gameObject.SetActive(value: true);
								handInfos[num].ball_transform.gameObject.SetActive(value: true);
								continue;
							}
							handInfos[num].line_transform.gameObject.SetActive(value: true);
							handInfos[num].ball_transform.gameObject.SetActive(value: false);
							if (handInfos[num].isUI)
							{
								handInfos[num].isUI = false;
								handInfos[num].anim.SetBool("IsPoint", handInfos[num].isUI);
							}
						}
						else if ((isPalette_h || isPalette_sv) && handActiveState == 0 && triggerButtons[0] != null)
						{
							int num2 = (isPalette_h ? 1 : 2);
							if (Physics.Raycast(handInfos[num].rayDir.position, handInfos[num].rayDir.forward, out var hitInfo4, 3f, layerMask))
							{
								switch (num2)
								{
								case 1:
									SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: true, hitInfo4.point);
									break;
								case 2:
									SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: false, hitInfo4.point);
									break;
								}
							}
							else
							{
								switch (num2)
								{
								case 1:
									SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: true, handInfos[num].rayDir.position + handInfos[num].rayDir.forward);
									break;
								case 2:
									SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: false, handInfos[num].rayDir.position + handInfos[num].rayDir.forward);
									break;
								}
							}
						}
						else if (handActiveState == 1 || triggerButtons[0] == null)
						{
							handInfos[num].line_transform.gameObject.SetActive(value: false);
							handInfos[num].ball_transform.gameObject.SetActive(value: false);
							if (!handInfos[num].isUI)
							{
								handInfos[num].isUI = true;
								handInfos[num].anim.SetBool("IsPoint", handInfos[num].isUI);
							}
							continue;
						}
					}
					else if (handActiveState == -1 && triggerButtons[1] != null)
					{
						if (Physics.Raycast(handInfos[num].rayDir.position, handInfos[num].rayDir.forward, out var hitInfo5, 3f, layerMask))
						{
							if (!handInfos[num].isUI)
							{
								handInfos[num].isUI = true;
								handInfos[num].anim.SetBool("IsPoint", handInfos[num].isUI);
							}
							Vector3 forward4 = hitInfo5.point - handInfos[num].rayDir.position;
							handInfos[num].ball_transform.position = hitInfo5.point;
							handInfos[num].line_transform.position = handInfos[num].rayDir.position;
							handInfos[num].line_transform.rotation = Quaternion.LookRotation(forward4);
							handInfos[num].line_transform.localScale = Vector3.forward * forward4.magnitude;
							float value4 = 0.5f;
							if (triggerButtons[num].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out value4))
							{
								bool flag7 = value4 >= 0.6f && !triggerButtons[num].isOn;
								bool flag8 = value4 <= 0.4f && triggerButtons[num].isOn;
								if (flag7 || flag8)
								{
									triggerButtons[num].isOn = flag7;
									if (triggerButtons[num].isOn)
									{
										MeshButtonCtrl component4 = hitInfo5.collider.GetComponent<MeshButtonCtrl>();
										if (component4 != null && component4.IsInteractable())
										{
											component4.event_click.Invoke();
											handInfos[num].line_transform.gameObject.SetActive(value: false);
											handInfos[num].ball_transform.gameObject.SetActive(value: false);
											continue;
										}
										ColorPaletteCtrl component5 = hitInfo5.collider.GetComponent<ColorPaletteCtrl>();
										if (component5 != null)
										{
											switch (component5.GetPaletteState(hitInfo5.point))
											{
											case 1:
												isPalette_h = true;
												handActiveState = num;
												component5.Click_Palette(isHue: true, hitInfo5.point);
												handInfos[num].line_transform.gameObject.SetActive(value: false);
												handInfos[num].ball_transform.gameObject.SetActive(value: false);
												continue;
											case 2:
												isPalette_sv = true;
												handActiveState = num;
												component5.Click_Palette(isHue: false, hitInfo5.point);
												handInfos[num].line_transform.gameObject.SetActive(value: false);
												handInfos[num].ball_transform.gameObject.SetActive(value: false);
												continue;
											}
										}
									}
								}
							}
							handInfos[num].line_transform.gameObject.SetActive(value: true);
							handInfos[num].ball_transform.gameObject.SetActive(value: true);
							continue;
						}
						handInfos[num].line_transform.gameObject.SetActive(value: true);
						handInfos[num].ball_transform.gameObject.SetActive(value: false);
						if (handInfos[num].isUI)
						{
							handInfos[num].isUI = false;
							handInfos[num].anim.SetBool("IsPoint", handInfos[num].isUI);
						}
					}
					else if ((isPalette_h || isPalette_sv) && handActiveState == 1 && triggerButtons[1] != null)
					{
						int num3 = (isPalette_h ? 1 : 2);
						if (Physics.Raycast(handInfos[num].rayDir.position, handInfos[num].rayDir.forward, out var hitInfo6, 3f, layerMask))
						{
							switch (num3)
							{
							case 1:
								isPalette_h = true;
								handActiveState = num;
								SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: true, hitInfo6.point);
								break;
							case 2:
								isPalette_sv = true;
								handActiveState = num;
								SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: false, hitInfo6.point);
								break;
							}
						}
						else
						{
							switch (num3)
							{
							case 1:
								isPalette_h = true;
								handActiveState = num;
								SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: true, handInfos[num].rayDir.position + handInfos[num].rayDir.forward);
								break;
							case 2:
								isPalette_sv = true;
								handActiveState = num;
								SingletonBase.Singleton<CustomizeManager>.GetInstance.colorPalette.Click_Palette(isHue: false, handInfos[num].rayDir.position + handInfos[num].rayDir.forward);
								break;
							}
						}
					}
					else if (handActiveState == 0 || triggerButtons[1] == null)
					{
						handInfos[num].line_transform.gameObject.SetActive(value: false);
						handInfos[num].ball_transform.gameObject.SetActive(value: false);
						if (!handInfos[num].isUI)
						{
							handInfos[num].isUI = true;
							handInfos[num].anim.SetBool("IsPoint", handInfos[num].isUI);
						}
						continue;
					}
					if (grab_prop_custom == null && !isRotation && !isPalette_h && !isPalette_sv)
					{
						CustomizeProp customizeProp = SingletonBase.Singleton<CustomizeManager>.GetInstance.FindNearProp(handInfos[num], num);
						if (customizeProp is CustomizeItemCtrl)
						{
							if (customizeItemCtrl == null)
							{
								customizeItemCtrl = (CustomizeItemCtrl)customizeProp;
							}
							else if (!customizeItemCtrl.isLock)
							{
								customizeItemCtrl = (CustomizeItemCtrl)customizeProp;
							}
						}
					}
					float value5 = 0.5f;
					if (triggerButtons[num].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out value5))
					{
						bool flag9 = value5 >= 0.6f && !triggerButtons[num].isOn;
						bool flag10 = value5 <= 0.4f && triggerButtons[num].isOn;
						if (flag9 || flag10)
						{
							triggerButtons[num].isOn = flag9;
							if (triggerButtons[num].isOn)
							{
								handActiveState = num;
								CustomizeProp customizeProp2 = SingletonBase.Singleton<CustomizeManager>.GetInstance.FindNearProp(handInfos[num], num);
								Vector3 forward5 = handInfos[num].rayDir.forward;
								forward5.y = 0f;
								Vector3 vector4 = SingletonBase.Singleton<CustomizeManager>.GetInstance.customSetPos_body.position - handInfos[num].rayDir.position;
								vector4.y = 0f;
								vector4 = vector4.normalized;
								if (customizeProp2 != null)
								{
									if (customizeProp2 is CustomizeItemCtrl)
									{
										grab_prop_custom = (CustomizeItemCtrl)customizeProp2;
										if (grab_prop_custom.isLock)
										{
											grab_prop_custom = null;
										}
										if (grab_prop_custom != null)
										{
											grab_prop_custom.SetPropState(PropState.Grab, handInfos[num].rayDir, num);
										}
									}
									else if (customizeProp2 is MeshButtonCtrl && ((MeshButtonCtrl)customizeProp2).IsInteractable())
									{
										((MeshButtonCtrl)customizeProp2).event_click.Invoke();
									}
								}
								else if ((handInfos[num].rayDir.position - SingletonBase.Singleton<CustomizeManager>.GetInstance.customSetPos_body.position).sqrMagnitude <= 0.1f || Vector3.Dot(forward5, vector4) >= 0.75f)
								{
									isRotation = true;
									previousDir_hand.x = handInfos[num].rayDir.forward.x;
									previousDir_hand.y = handInfos[num].rayDir.forward.z;
									previousDir_hand = previousDir_hand.normalized;
									Vector3 vector5 = handInfos[num].rayDir.position - Camera.main.transform.position;
									previousDir_arm.x = vector5.x;
									previousDir_arm.y = vector5.z;
									previousDir_arm = previousDir_arm.normalized;
								}
								handInfos[num].line_transform.gameObject.SetActive(value: false);
								handInfos[num].ball_transform.gameObject.SetActive(value: false);
							}
							else
							{
								handActiveState = -1;
								if (grab_prop_custom != null)
								{
									Vector3 forward6 = handInfos[num].rayDir.forward;
									forward6.y = 0f;
									forward6 = forward6.normalized;
									Vector3 vector6 = SingletonBase.Singleton<CustomizeManager>.GetInstance.customSetPos_body.position - handInfos[num].rayDir.position;
									vector6.y = 0f;
									vector6 = vector6.normalized;
									if ((handInfos[num].rayDir.position - SingletonBase.Singleton<CustomizeManager>.GetInstance.customSetPos_body.position).sqrMagnitude <= 0.1f || Vector3.Dot(forward6, vector6) >= 0.75f)
									{
										grab_prop_custom.SetPropState(PropState.Set);
										grab_prop_custom = null;
									}
									else
									{
										grab_prop_custom.SetPropState(PropState.Idle);
										grab_prop_custom = null;
									}
								}
								handInfos[num].line_transform.gameObject.SetActive(value: true);
								handInfos[num].ball_transform.gameObject.SetActive(value: true);
								isRotation = false;
								isPalette_h = false;
								isPalette_sv = false;
							}
						}
					}
					handInfos[num].anim.SetFloat("Value", value5);
				}
				if (grab_prop_custom == null)
				{
					if (customizeItemCtrl != null)
					{
						SingletonBase.Singleton<CustomizeManager>.GetInstance.CheckSlotLock(customizeItemCtrl);
					}
					else
					{
						SingletonBase.Singleton<CustomizeManager>.GetInstance.CheckSlotLock(null);
					}
				}
			}
		}
	}
}
public enum PropState
{
	Idle,
	Grab,
	Set,
	Keep
}
[Serializable]
public class LobbyPropData
{
	public MeshFilter mesh_head;

	public MeshFilter mesh_hair_f;

	public MeshFilter mesh_hair_b;

	public SkinnedMeshRenderer mesh_body;

	public SkinnedMeshRenderer mesh_upper;

	public SkinnedMeshRenderer mesh_lower;

	public SkinnedMeshRenderer mesh_lower_s;

	public SkinnedMeshRenderer mesh_foot;

	public MeshFilter mesh_foot_l;

	public MeshFilter mesh_foot_r;

	public MeshFilter mesh_acc;
}
public class LobbyPropCtrl : MonoBehaviour
{
	[Serializable]
	public class CatchTransform
	{
		public Vector3 pos;

		public Vector3 rot;

		public Quaternion rot_q;
	}

	private Vector3 pos_orizin;

	private Quaternion rot_orizin;

	private PropState propState;

	public GameData_DDOL.GameType gameType;

	public Vector3 pos_center;

	public CatchTransform[] catchTransforms = new CatchTransform[2];

	private Animator anim;

	private PropState animState;

	private LobbyPropData lobbyPropData;

	private Transform handTr;

	private int handNum;

	private GameObject shadow;

	private void Start()
	{
		anim = base.transform.GetComponent<Animator>();
		shadow = base.transform.Find("Shadow").gameObject;
		animState = PropState.Idle;
		pos_orizin = base.transform.position;
		rot_orizin = base.transform.rotation;
		for (int i = 0; i < catchTransforms.Length; i++)
		{
			catchTransforms[i].rot_q = Quaternion.Euler(catchTransforms[i].rot);
		}
		SingletonBase.Singleton<LobbyPropManager>.GetInstance.AddProp(this);
		StartCoroutine(CheckPropData());
	}

	private IEnumerator CheckPropData()
	{
		if (gameType == GameData_DDOL.GameType.Customize)
		{
			while (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id == null || SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id == "")
			{
				yield return null;
			}
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos = new UserInfoManager.UserInfo[2];
			base.transform.GetComponent<CustomModelSettingCtrl>().Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id);
		}
		else if (gameType != 0)
		{
			int num = (int)UnityEngine.Random.Range(0f, 1.9999f);
			base.transform.GetComponent<CustomModelSettingCtrl>().InitRandom(num);
			anim.SetBool("IsMale", num == 0);
			anim.SetInteger("StateNum", (int)gameType);
			anim.SetTrigger("OnState");
			anim.SetBool("IsPlay", value: true);
			AnimSyncCtrl component = base.transform.GetComponent<AnimSyncCtrl>();
			if (component != null)
			{
				component.Init(num == 0);
			}
		}
		yield return new WaitForSeconds(0.1f);
		CustomModelSettingCtrl modelSettingCtrl = base.transform.GetComponent<CustomModelSettingCtrl>();
		while (modelSettingCtrl.enabled)
		{
			yield return null;
		}
		Transform[] componentsInChildren = base.transform.GetComponentsInChildren<Transform>(includeInactive: true);
		lobbyPropData = new LobbyPropData();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			switch (componentsInChildren[i].name)
			{
			case "ITEM_HEAD":
				lobbyPropData.mesh_head = componentsInChildren[i].GetComponent<MeshFilter>();
				break;
			case "ITEM_HAIR_F":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_hair_f = componentsInChildren[i].GetComponent<MeshFilter>();
				}
				else
				{
					lobbyPropData.mesh_hair_f = null;
				}
				break;
			case "ITEM_HAIR_B":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_hair_b = componentsInChildren[i].GetComponent<MeshFilter>();
				}
				else
				{
					lobbyPropData.mesh_hair_b = null;
				}
				break;
			case "BODY_ORG_HIDDEN":
				lobbyPropData.mesh_body = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				break;
			case "ITEM_UPPER":
				lobbyPropData.mesh_upper = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				break;
			case "ITEM_LOWER":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_lower = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				}
				else
				{
					lobbyPropData.mesh_lower = null;
				}
				break;
			case "ITEM_LOWER_SUB":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_lower_s = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				}
				else
				{
					lobbyPropData.mesh_lower_s = null;
				}
				break;
			case "ITEM_FOOT":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_foot = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				}
				else
				{
					lobbyPropData.mesh_foot = null;
				}
				break;
			case "ITEM_FOOT_L_SUB":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_foot_l = componentsInChildren[i].GetComponent<MeshFilter>();
				}
				else
				{
					lobbyPropData.mesh_foot_l = null;
				}
				break;
			case "ITEM_FOOT_R_SUB":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_foot_r = componentsInChildren[i].GetComponent<MeshFilter>();
				}
				else
				{
					lobbyPropData.mesh_foot_r = null;
				}
				break;
			case "ITEM_HEAD_ACC":
				if (componentsInChildren[i].gameObject.activeSelf)
				{
					lobbyPropData.mesh_acc = componentsInChildren[i].GetComponent<MeshFilter>();
				}
				else
				{
					lobbyPropData.mesh_acc = null;
				}
				break;
			}
		}
	}

	public Vector3 GetCenterPos()
	{
		return base.transform.TransformPoint(pos_center);
	}

	public void SetPropState(PropState _propState, Transform _handTr = null, int _handNum = 0)
	{
		propState = _propState;
		if (gameType == GameData_DDOL.GameType.None)
		{
			return;
		}
		switch (propState)
		{
		case PropState.Idle:
			shadow.SetActive(value: true);
			SingletonBase.Singleton<LobbyHologramCtrl>.GetInstance.StopHologram();
			break;
		case PropState.Grab:
			shadow.SetActive(value: false);
			if (_handTr != null)
			{
				handTr = _handTr;
				handNum = _handNum;
			}
			if (lobbyPropData != null)
			{
				SingletonBase.Singleton<LobbyHologramCtrl>.GetInstance.SetHologram(lobbyPropData, gameType);
				SingletonBase.Singleton<LobbyHologramCtrl>.GetInstance.PlayHologram();
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play((int)UnityEngine.Random.Range(0f, 2.9999f));
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play_Voice((int)(gameType - 1));
			break;
		case PropState.Set:
			shadow.SetActive(value: false);
			SingletonBase.Singleton<LobbyHologramCtrl>.GetInstance.StopHologram();
			break;
		}
	}

	public void SetIdlePos()
	{
		base.transform.position = pos_orizin;
		base.transform.rotation = rot_orizin;
	}

	private void LateUpdate()
	{
		switch (propState)
		{
		case PropState.Idle:
		{
			if (gameType != 0 && animState != 0)
			{
				anim.SetBool("IsPlay", value: true);
				anim.SetBool("IsCenter", value: false);
				animState = PropState.Idle;
			}
			Vector3 position2 = Vector3.MoveTowards(base.transform.position, pos_orizin, Time.deltaTime * 7f);
			Quaternion rotation2 = Quaternion.RotateTowards(base.transform.rotation, rot_orizin, Time.deltaTime * 700f);
			base.transform.SetPositionAndRotation(position2, rotation2);
			break;
		}
		case PropState.Grab:
		{
			if (gameType != 0 && animState != PropState.Grab)
			{
				anim.SetBool("IsPlay", value: false);
				anim.SetBool("IsCenter", value: false);
				animState = PropState.Grab;
			}
			float sqrMagnitude = (handTr.position - SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position).sqrMagnitude;
			Vector3 vector = handTr.TransformPoint(catchTransforms[handNum].pos);
			Quaternion to = handTr.rotation * Quaternion.Euler(catchTransforms[handNum].rot);
			if (sqrMagnitude > 0.1f)
			{
				base.transform.position = Vector3.MoveTowards(base.transform.position, vector, Time.deltaTime * 5f);
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, to, Time.deltaTime * 500f);
			}
			else
			{
				vector.y = Mathf.Clamp(vector.y, SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position.y, 5f);
				base.transform.position = Vector3.MoveTowards(base.transform.position, Vector3.Lerp(SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position, vector, sqrMagnitude * 10f), Time.deltaTime * 3f);
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.rotation, Time.deltaTime * 300f);
			}
			break;
		}
		case PropState.Set:
		{
			if (gameType != 0 && animState != PropState.Set)
			{
				anim.SetBool("IsPlay", value: true);
				anim.SetBool("IsCenter", value: true);
				animState = PropState.Set;
			}
			Vector3 position = Vector3.MoveTowards(base.transform.position, SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position, Time.deltaTime * 3f);
			Quaternion rotation = Quaternion.RotateTowards(base.transform.rotation, SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.rotation, Time.deltaTime * 500f);
			if ((base.transform.position - SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position).sqrMagnitude <= 0.0001f && Vector3.Dot(base.transform.forward, SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.forward) >= 0.98f)
			{
				base.transform.SetPositionAndRotation(SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.position, SingletonBase.Singleton<LobbyPropManager>.GetInstance.gameStartPos.rotation);
				propState = PropState.Keep;
				SingletonBase.Singleton<LobbyPropManager>.GetInstance.SelectGame(this);
			}
			else
			{
				base.transform.SetPositionAndRotation(position, rotation);
			}
			break;
		}
		}
	}

	public PropState GetPropState()
	{
		return propState;
	}
}
public class LobbyPropManager : SingletonBase.Singleton<LobbyPropManager>
{
	private List<LobbyPropCtrl> propCtrls = new List<LobbyPropCtrl>();

	public Transform gameStartPos;

	public ParticleSystem par_gameStart;

	private Vector3 keep_pos;

	public bool isStartGame;

	public Transform[] selectpointTrs;

	public LobbyPropCtrl keep_prop;

	private Coroutine selectGameCoroutine;

	protected override void Awake()
	{
		base.Awake();
		Physics.autoSimulation = true;
		Time.timeScale = 1f;
		Time.fixedDeltaTime = 0.02f;
		Physics.bounceThreshold = 1f;
		Physics.sleepThreshold = 0.005f;
		Physics.defaultContactOffset = 0.01f;
		Physics.defaultSolverIterations = 6;
		Physics.defaultSolverVelocityIterations = 1;
		keep_pos = par_gameStart.transform.position;
		par_gameStart.transform.position = Vector3.up * -10f;
		_ = (bool)PublicGameUIManager.GetInstance;
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.None;
		SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.StartFade(_isFadeIn: true);
	}

	public void AddProp(LobbyPropCtrl lobbyProp)
	{
		propCtrls.Add(lobbyProp);
	}

	public void SetSelectPointActive(bool isActive, int index)
	{
		if (isActive != selectpointTrs[index].gameObject.activeSelf)
		{
			selectpointTrs[index].gameObject.SetActive(isActive);
		}
	}

	public LobbyPropCtrl FindNearProp(LobbyHandInfo handInfo, int index)
	{
		if (propCtrls.Count == 0)
		{
			return null;
		}
		LobbyPropCtrl lobbyPropCtrl = null;
		for (int i = 0; i < propCtrls.Count; i++)
		{
			if (lobbyPropCtrl == null && (handInfo.rayDir.position - propCtrls[i].GetCenterPos()).sqrMagnitude <= 0.1f)
			{
				lobbyPropCtrl = propCtrls[i];
			}
			else if (lobbyPropCtrl != null && (lobbyPropCtrl.GetCenterPos() - handInfo.rayDir.position).sqrMagnitude > (propCtrls[i].GetCenterPos() - handInfo.rayDir.position).sqrMagnitude)
			{
				lobbyPropCtrl = propCtrls[i];
			}
		}
		if (lobbyPropCtrl != null)
		{
			SetSelectPointActive(isActive: true, index);
			selectpointTrs[index].position = lobbyPropCtrl.GetCenterPos() + Vector3.up * 0.15f;
			return lobbyPropCtrl;
		}
		for (int j = 0; j < propCtrls.Count; j++)
		{
			if (lobbyPropCtrl == null && Vector3.Dot(handInfo.rayDir.forward, (propCtrls[j].GetCenterPos() - handInfo.rayDir.position).normalized) >= 0.85f)
			{
				lobbyPropCtrl = propCtrls[j];
			}
			else if (lobbyPropCtrl != null && Vector3.Dot(handInfo.rayDir.forward, (lobbyPropCtrl.GetCenterPos() - handInfo.rayDir.position).normalized) < Vector3.Dot(handInfo.rayDir.forward, (propCtrls[j].GetCenterPos() - handInfo.rayDir.position).normalized))
			{
				lobbyPropCtrl = propCtrls[j];
			}
		}
		if (lobbyPropCtrl != null)
		{
			SetSelectPointActive(isActive: true, index);
			selectpointTrs[index].position = lobbyPropCtrl.GetCenterPos() + Vector3.up * 0.15f;
			handInfo.line_transform.position = handInfo.rayDir.position;
			Vector3 forward = lobbyPropCtrl.GetCenterPos() - handInfo.rayDir.position;
			handInfo.line_transform.rotation = Quaternion.Lerp(handInfo.rayDir.rotation, Quaternion.LookRotation(forward), 0.7f);
			handInfo.line_transform.localScale = Vector3.forward * forward.magnitude;
		}
		else
		{
			SetSelectPointActive(isActive: false, index);
			handInfo.line_transform.position = handInfo.rayDir.position;
			handInfo.line_transform.rotation = handInfo.rayDir.rotation;
			handInfo.line_transform.localScale = Vector3.one;
		}
		return lobbyPropCtrl;
	}

	public void SelectGame(LobbyPropCtrl prop)
	{
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = prop.gameType;
		keep_prop = prop;
		par_gameStart.transform.position = keep_pos;
		par_gameStart.Play();
		SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(3);
		if (prop.gameType == GameData_DDOL.GameType.Customize)
		{
			isStartGame = true;
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.None;
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene(1);
		}
		else
		{
			selectGameCoroutine = StartCoroutine(SelectGameCoroutine());
		}
	}

	public void StopSelectGame()
	{
		if (selectGameCoroutine != null)
		{
			StopCoroutine(selectGameCoroutine);
		}
	}

	private IEnumerator SelectGameCoroutine()
	{
		yield return new WaitForSeconds(1f);
		SingletonBase.Singleton<LobbyUIManager>.GetInstance.OpenStartPage();
	}

	public void StartGame()
	{
		if (isStartGame)
		{
			return;
		}
		isStartGame = true;
		SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play_Voice(21);
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && !PhotonNetwork.LocalPlayer.IsMasterClient)
		{
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.StartFade(_isFadeIn: false);
			return;
		}
		switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType)
		{
		case GameData_DDOL.GameType.Bowling:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Bowling");
			break;
		case GameData_DDOL.GameType.Archery:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Archery");
			break;
		case GameData_DDOL.GameType.Basketball:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_BasketBall");
			break;
		case GameData_DDOL.GameType.Badminton:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Badminton");
			break;
		case GameData_DDOL.GameType.Billiards:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Billiards");
			break;
		case GameData_DDOL.GameType.Darts:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Darts");
			break;
		case GameData_DDOL.GameType.TableTennis:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_PingPong");
			break;
		case GameData_DDOL.GameType.Boxing:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Boxing_MT");
				break;
			}
			switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode)
			{
			case 2:
				SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Boxing");
				break;
			case 3:
				SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Boxing_HB");
				break;
			default:
				SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Boxing_AI");
				break;
			}
			break;
		case GameData_DDOL.GameType.Golf:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Golf");
			break;
		case GameData_DDOL.GameType.Baseball:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_BaseBall");
			break;
		case GameData_DDOL.GameType.Tennis:
			SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene("Scene_Game_Tennis");
			break;
		}
		if (PhotonNetwork.InRoom)
		{
			PhotonNetwork.CurrentRoom.IsOpen = false;
			PhotonNetwork.CurrentRoom.IsVisible = false;
		}
	}
}
public class LobbyShadowCtrl : MonoBehaviour
{
	public Transform target;

	private float posY;

	private void Awake()
	{
		posY = base.transform.localPosition.y;
	}

	private void LateUpdate()
	{
		Vector3 localPosition = target.localPosition;
		localPosition.y = posY;
		base.transform.localPosition = localPosition;
	}
}
public class LobbySoundManager : SingletonBase.Singleton<LobbySoundManager>
{
	public AudioClip audio_bgm;

	public AudioClip[] audios_voice_op;

	public AudioClip[] audios_effect;

	public AudioClip[] audios_voice;

	private AudioSource audioSource_bgm;

	private AudioSource audioSource_effect;

	private AudioSource audioSource_voice;

	private void Start()
	{
		audioSource_bgm = base.gameObject.AddComponent<AudioSource>();
		audioSource_bgm.loop = false;
		audioSource_bgm.volume = 0.7f;
		audioSource_bgm.playOnAwake = false;
		audioSource_bgm.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("BGM");
		audioSource_effect = base.gameObject.AddComponent<AudioSource>();
		audioSource_effect.loop = false;
		audioSource_effect.volume = 1f;
		audioSource_effect.playOnAwake = false;
		audioSource_effect.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("Effect");
		audioSource_voice = base.gameObject.AddComponent<AudioSource>();
		audioSource_voice.loop = false;
		audioSource_voice.volume = 1f;
		audioSource_voice.playOnAwake = false;
		audioSource_voice.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("Effect");
		StartCoroutine(StartPlaySound());
	}

	private IEnumerator StartPlaySound()
	{
		yield return new WaitForSeconds(1f);
		if (audios_voice_op.Length != 0)
		{
			audioSource_bgm.clip = audios_voice_op[(int)UnityEngine.Random.Range(0f, 2.9999f)];
			audioSource_bgm.Play();
			yield return new WaitForSeconds(1f);
			while (audioSource_bgm.isPlaying)
			{
				yield return null;
			}
		}
		audioSource_bgm.loop = true;
		audioSource_bgm.clip = audio_bgm;
		audioSource_bgm.Play();
	}

	public void Play(int index, bool isLoop = false)
	{
		audioSource_effect.loop = isLoop;
		audioSource_effect.clip = audios_effect[index];
		audioSource_effect.Play();
	}

	public void Stop()
	{
		audioSource_effect.Stop();
	}

	public void Play_Voice(int index, bool isLoop = false)
	{
		audioSource_voice.loop = isLoop;
		audioSource_voice.clip = audios_voice[index];
		audioSource_voice.Play();
	}

	public void Stop_Voice()
	{
		audioSource_voice.Stop();
	}
}
public class LobbyUIManager : SingletonBase.Singleton<LobbyUIManager>
{
	[Serializable]
	public class ModeButton
	{
		public Transform tr;

		public Text name;

		public MeshFilter meshFilter;
	}

	public enum LobbyUIState
	{
		Close,
		Menu,
		Mode,
		Level,
		InputCode,
		Random,
		Friend,
		Match_S,
		Server,
		RoomOut
	}

	public enum StartViewState
	{
		Idle,
		Disconnect
	}

	public LobbyPlayerCtrl lobbyPlayer;

	public Text text_code;

	private int codeSize_min = 4;

	private int codeSize_max = 8;

	private string inputString = "";

	public Animator anim_mainUI;

	public Animator anim_keyboardUI;

	public Animator anim_otherGameUI;

	public Animator anim_serverUI;

	public GameObject[] gos_ui;

	private bool isActive;

	public GameObject button_connect;

	public GameObject go_connect;

	public GameObject go_disconnect;

	public GameObject go_update;

	public GameObject go_roomOut;

	public GameObject button_match;

	public LobbyUIState lobbyUIState;

	public Text text_gameType;

	public Text text_time;

	public Text[] text_userNick;

	public Text[] text_userInfo;

	private float connectTime;

	public MeshButtonCtrl[] meshButtons_gameType;

	public MeshButtonCtrl[] meshButtons_level_05;

	public MeshButtonCtrl[] meshButtons_level_10;

	public GameObject[] medals_level;

	public Material[] materials_lobbyUI;

	public Sprite[] sprites_ping;

	public Text text_serverName;

	public Text text_ping;

	public Image image_ping;

	public GameObject pref_page;

	private List<GameObject> list_pageIcon = new List<GameObject>();

	public HorizontalLayoutGroup layoutGroup;

	public LeaderBoardCtrl leaderBoard;

	public AchievementCtrl achievement;

	public GameSettingCtrl gameSetting;

	public MedalViewCtrl medalView;

	public XRRayInteractor[] rayInteractors;

	public ModeButton[] modeButtons;

	public Mesh[] mesh_modeButtons;

	public Transform exitButtonTr;

	private float exitDelayTime = 2f;

	public static StartViewState startViewState;

	private Coroutine stateCoroutine;

	private Coroutine serverChangeCoroutine;

	private void Start()
	{
		lobbyUIState = LobbyUIState.Close;
		for (int i = 0; i < gos_ui.Length; i++)
		{
			gos_ui[i].SetActive(value: false);
		}
		anim_keyboardUI.gameObject.SetActive(value: false);
		anim_otherGameUI.gameObject.SetActive(value: false);
		anim_serverUI.gameObject.SetActive(value: false);
		materials_lobbyUI = new Material[2];
		materials_lobbyUI[0] = Resources.Load<Material>("UI/Mat_LobbyUI_Dim");
		materials_lobbyUI[1] = Resources.Load<Material>("UI/Mat_LobbyUI");
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.None;
		int @int = PlayerPrefs.GetInt("count_dis", 0);
		if (PlayerPrefs.GetInt("isDisCheck", 0) == 1)
		{
			@int++;
			PlayerPrefs.SetInt("count_dis", @int);
			PlayerPrefs.SetInt("isDisCheck", 0);
		}
		leaderBoard.MyScoreUpdate(0);
		gameSetting.View();
		StartCoroutine(TextCoroutine());
		Invoke("DelayInit", 1f);
		if (startViewState == StartViewState.Disconnect)
		{
			startViewState = StartViewState.Idle;
			SetLobbyUI(LobbyUIState.RoomOut);
		}
	}

	private void DelayInit()
	{
		for (int i = 0; i < rayInteractors.Length; i++)
		{
			rayInteractors[i].enabled = true;
		}
	}

	public void OpenStartPage()
	{
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Basketball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Bowling)
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 2;
		}
		else
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 1;
		}
		SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
		SetLobbyUI(LobbyUIState.Menu);
	}

	public void SetPageLevel()
	{
		PublicGameUIManager.profileCapture.ShotSingleImages();
		if ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1) || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Boxing && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 3))
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single = null;
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id;
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick;
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id = "AI";
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick = GameSettingCtrl.GetLocalizationText("0173") + 1;
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level = 1;
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.Single;
			SingletonBase.Singleton<LobbyPropManager>.GetInstance.StartGame();
			anim_mainUI.SetTrigger("OnClose");
			isActive = false;
		}
		else
		{
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SetLobbyUI(LobbyUIState.Level);
		}
	}

	public void SetLobbyUI(LobbyUIState setState)
	{
		isActive = false;
		if (stateCoroutine != null)
		{
			StopCoroutine(stateCoroutine);
		}
		stateCoroutine = StartCoroutine(StateCoroutine(setState));
	}

	private IEnumerator StateCoroutine(LobbyUIState setState)
	{
		switch (lobbyUIState)
		{
		case LobbyUIState.InputCode:
			anim_keyboardUI.SetTrigger("OnClose");
			break;
		case LobbyUIState.Random:
			if (serverChangeCoroutine != null)
			{
				StopCoroutine(serverChangeCoroutine);
			}
			anim_otherGameUI.SetTrigger("OnClose");
			anim_serverUI.SetTrigger("OnClose");
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.StartDisconnect();
			break;
		case LobbyUIState.Friend:
			if (serverChangeCoroutine != null)
			{
				StopCoroutine(serverChangeCoroutine);
			}
			anim_serverUI.SetTrigger("OnClose");
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.StartDisconnect();
			break;
		}
		if (lobbyUIState != 0)
		{
			anim_mainUI.SetTrigger("OnClose");
			yield return new WaitForSeconds(0.1f);
			while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
			{
				yield return null;
			}
		}
		else
		{
			for (int i = 0; i < 2; i++)
			{
				lobbyPlayer.handInfos[i].anim.SetBool("IsPoint", value: true);
			}
		}
		for (int j = 0; j < gos_ui.Length; j++)
		{
			gos_ui[j].SetActive(value: false);
		}
		LobbyUIState tempState = lobbyUIState;
		lobbyUIState = setState;
		if (lobbyUIState == LobbyUIState.Close)
		{
			if (SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop != null)
			{
				SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop.SetIdlePos();
				SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop.SetPropState(PropState.Idle);
				SingletonBase.Singleton<LobbyPropManager>.GetInstance.keep_prop = null;
				lobbyPlayer.grab_prop_lobby = null;
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.None;
			}
			for (int k = 0; k < 2; k++)
			{
				lobbyPlayer.handInfos[k].anim.SetBool("IsPoint", value: false);
			}
			yield break;
		}
		anim_mainUI.SetTrigger("OnOpen");
		yield return null;
		switch (lobbyUIState)
		{
		case LobbyUIState.Menu:
			gos_ui[0].SetActive(value: true);
			break;
		case LobbyUIState.Mode:
			switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType)
			{
			case GameData_DDOL.GameType.Bowling:
			case GameData_DDOL.GameType.Basketball:
				modeButtons[0].tr.gameObject.SetActive(value: true);
				modeButtons[1].tr.gameObject.SetActive(value: true);
				modeButtons[2].tr.gameObject.SetActive(value: false);
				modeButtons[0].tr.localPosition = new Vector3(-0.1f, -0.03f, 0f);
				modeButtons[1].tr.localPosition = new Vector3(0.1f, -0.03f, 0f);
				modeButtons[0].meshFilter.mesh = mesh_modeButtons[0];
				modeButtons[1].meshFilter.mesh = mesh_modeButtons[1];
				SetModeLocalization();
				break;
			case GameData_DDOL.GameType.Boxing:
				modeButtons[0].tr.gameObject.SetActive(value: true);
				modeButtons[1].tr.gameObject.SetActive(value: true);
				modeButtons[2].tr.gameObject.SetActive(value: true);
				modeButtons[0].tr.localPosition = new Vector3(0.15f, -0.03f, 0f);
				modeButtons[1].tr.localPosition = new Vector3(0f, -0.03f, 0f);
				modeButtons[2].tr.localPosition = new Vector3(-0.15f, -0.03f, 0f);
				modeButtons[0].meshFilter.mesh = mesh_modeButtons[6];
				modeButtons[1].meshFilter.mesh = mesh_modeButtons[2];
				modeButtons[2].meshFilter.mesh = mesh_modeButtons[3];
				SetModeLocalization();
				break;
			case GameData_DDOL.GameType.Baseball:
				modeButtons[0].tr.gameObject.SetActive(value: true);
				modeButtons[1].tr.gameObject.SetActive(value: true);
				modeButtons[2].tr.gameObject.SetActive(value: false);
				modeButtons[0].tr.localPosition = new Vector3(-0.1f, -0.03f, 0f);
				modeButtons[1].tr.localPosition = new Vector3(0.1f, -0.03f, 0f);
				modeButtons[0].meshFilter.mesh = mesh_modeButtons[0];
				modeButtons[1].meshFilter.mesh = mesh_modeButtons[1];
				SetModeLocalization();
				break;
			}
			gos_ui[1].SetActive(value: true);
			break;
		case LobbyUIState.Level:
		{
			int clearLevelData;
			for (clearLevelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData(); clearLevelData == -1; clearLevelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData())
			{
				yield return null;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf)
			{
				for (int m = 0; m < meshButtons_level_10.Length; m++)
				{
					if (m <= clearLevelData)
					{
						meshButtons_level_10[m].SetMaterial(materials_lobbyUI[1]);
						meshButtons_level_10[m].SetInteractable(_isInteractable: true);
					}
					else
					{
						meshButtons_level_10[m].SetMaterial(materials_lobbyUI[0]);
						meshButtons_level_10[m].SetInteractable(_isInteractable: false);
					}
					switch (m)
					{
					case 8:
						medals_level[3].SetActive(m < clearLevelData);
						break;
					case 7:
						medals_level[4].SetActive(m < clearLevelData);
						break;
					case 6:
						medals_level[5].SetActive(m < clearLevelData);
						break;
					}
				}
				meshButtons_level_05[0].transform.parent.gameObject.SetActive(value: false);
				meshButtons_level_10[0].transform.parent.gameObject.SetActive(value: true);
			}
			else
			{
				for (int n = 0; n < meshButtons_level_05.Length; n++)
				{
					if (n <= clearLevelData)
					{
						meshButtons_level_05[n].SetMaterial(materials_lobbyUI[1]);
						meshButtons_level_05[n].SetInteractable(_isInteractable: true);
					}
					else
					{
						meshButtons_level_05[n].SetMaterial(materials_lobbyUI[0]);
						meshButtons_level_05[n].SetInteractable(_isInteractable: false);
					}
					switch (n)
					{
					case 4:
						if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Boxing && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
						{
							medals_level[0].SetActive(value: false);
						}
						else
						{
							medals_level[0].SetActive(n < clearLevelData);
						}
						break;
					case 3:
						if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Boxing && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
						{
							medals_level[1].SetActive(value: false);
						}
						else
						{
							medals_level[1].SetActive(n < clearLevelData);
						}
						break;
					case 2:
						if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Boxing && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
						{
							medals_level[2].SetActive(value: false);
						}
						else
						{
							medals_level[2].SetActive(n < clearLevelData);
						}
						break;
					}
				}
				meshButtons_level_10[0].transform.parent.gameObject.SetActive(value: false);
				meshButtons_level_05[0].transform.parent.gameObject.SetActive(value: true);
			}
			gos_ui[2].SetActive(value: true);
			break;
		}
		case LobbyUIState.InputCode:
			inputString = "";
			text_code.text = inputString;
			gos_ui[3].SetActive(value: true);
			gos_ui[6].SetActive(value: true);
			break;
		case LobbyUIState.Random:
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.Multi;
			gos_ui[5].SetActive(value: true);
			if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
			{
				button_connect.SetActive(value: true);
				go_connect.SetActive(value: false);
				go_disconnect.SetActive(value: true);
				go_update.SetActive(value: false);
				go_roomOut.SetActive(value: false);
				break;
			}
			while (SingletonBase.Singleton<UserInfoManager>.GetInstance.UpdateState() == 0)
			{
				yield return null;
			}
			if (SingletonBase.Singleton<UserInfoManager>.GetInstance.UpdateState() == -1)
			{
				button_connect.SetActive(value: true);
				go_connect.SetActive(value: false);
				go_disconnect.SetActive(value: false);
				go_update.SetActive(value: true);
				go_roomOut.SetActive(value: false);
				break;
			}
			connectTime = 5f;
			button_connect.SetActive(value: false);
			go_connect.SetActive(value: true);
			go_disconnect.SetActive(value: false);
			go_update.SetActive(value: false);
			go_roomOut.SetActive(value: false);
			while (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id.Length == 0)
			{
				yield return null;
			}
			while (!SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.IsCustomModelData())
			{
				yield return null;
			}
			while (SingletonBase.Singleton<UserInfoManager>.GetInstance.state_setNetData == 1)
			{
				yield return null;
			}
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.ClearServerInfos();
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.StartConnect(isRandom: true);
			yield return new WaitForSeconds(0.1f);
			while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
			{
				yield return null;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(9, isLoop: true);
			while (!SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.isReady)
			{
				yield return null;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			anim_mainUI.SetTrigger("OnClose");
			yield return new WaitForSeconds(0.1f);
			while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
			{
				yield return null;
			}
			gos_ui[5].SetActive(value: false);
			gos_ui[4].SetActive(value: true);
			anim_mainUI.SetTrigger("OnOpen");
			yield return null;
			break;
		case LobbyUIState.Friend:
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.Multi;
			gos_ui[5].SetActive(value: true);
			if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable)
			{
				button_connect.SetActive(value: true);
				go_connect.SetActive(value: false);
				go_disconnect.SetActive(value: true);
				go_update.SetActive(value: false);
				go_roomOut.SetActive(value: false);
				break;
			}
			connectTime = 5f;
			button_connect.SetActive(value: false);
			go_connect.SetActive(value: true);
			go_disconnect.SetActive(value: false);
			go_update.SetActive(value: false);
			go_roomOut.SetActive(value: false);
			while (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id.Length == 0)
			{
				yield return null;
			}
			while (!SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.IsCustomModelData())
			{
				yield return null;
			}
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.ClearServerInfos();
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.StartConnect(isRandom: false);
			yield return new WaitForSeconds(0.1f);
			while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
			{
				yield return null;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(9, isLoop: true);
			while (!SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.isReady)
			{
				yield return null;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			anim_mainUI.SetTrigger("OnClose");
			yield return new WaitForSeconds(0.1f);
			while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
			{
				yield return null;
			}
			gos_ui[5].SetActive(value: false);
			gos_ui[4].SetActive(value: true);
			anim_mainUI.SetTrigger("OnOpen");
			yield return null;
			break;
		case LobbyUIState.Match_S:
		{
			gos_ui[4].SetActive(value: true);
			anim_mainUI.SetTrigger("OnOpen");
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[0] = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData();
			PublicGameUIManager.profileCapture.PlayImages(new string[2]
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id,
				"AI"
			}, ProfileCaptureCtrl.ShotState.Multi);
			for (int l = 0; l < 2; l++)
			{
				text_userNick[l].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[l].nick;
				text_userInfo[l].text = "";
			}
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetViewGameType();
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetViewMatchText();
			yield return new WaitForSecondsRealtime(1f);
			isActive = true;
			for (int countTime = 3; countTime > 0; countTime--)
			{
				text_time.text = countTime.ToString();
				yield return new WaitForSecondsRealtime(1f);
			}
			SetMatchBackButton(isActive: false);
			SingletonBase.Singleton<LobbyPropManager>.GetInstance.StartGame();
			isActive = false;
			break;
		}
		case LobbyUIState.Server:
			gos_ui[5].SetActive(value: true);
			connectTime = 5f;
			button_connect.SetActive(value: false);
			while (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id.Length == 0)
			{
				yield return null;
			}
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.StartConnect(SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.GetServerInfo().code);
			yield return new WaitForSeconds(0.1f);
			while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
			{
				yield return null;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(9, isLoop: true);
			while (!SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.isReady)
			{
				yield return null;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			anim_mainUI.SetTrigger("OnClose");
			yield return new WaitForSeconds(0.1f);
			while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
			{
				yield return null;
			}
			gos_ui[5].SetActive(value: false);
			gos_ui[4].SetActive(value: true);
			anim_mainUI.SetTrigger("OnOpen");
			lobbyUIState = tempState;
			yield return null;
			break;
		case LobbyUIState.RoomOut:
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.None;
			gos_ui[5].SetActive(value: true);
			button_connect.SetActive(value: true);
			go_connect.SetActive(value: false);
			go_disconnect.SetActive(value: false);
			go_update.SetActive(value: false);
			go_roomOut.SetActive(value: true);
			break;
		}
		yield return new WaitForSeconds(0.1f);
		while (1f > anim_mainUI.GetCurrentAnimatorStateInfo(0).normalizedTime)
		{
			yield return null;
		}
		isActive = true;
	}

	public void SetRoomOutUI()
	{
		isActive = false;
		if (stateCoroutine != null)
		{
			StopCoroutine(stateCoroutine);
		}
	}

	public void SetModeLocalization()
	{
		switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType)
		{
		case GameData_DDOL.GameType.Bowling:
		case GameData_DDOL.GameType.Basketball:
			modeButtons[1].name.text = GameSettingCtrl.GetLocalizationText("0006");
			break;
		case GameData_DDOL.GameType.Boxing:
			modeButtons[0].name.text = GameSettingCtrl.GetLocalizationText("0006");
			modeButtons[1].name.text = GameSettingCtrl.GetLocalizationText("0092");
			modeButtons[2].name.text = GameSettingCtrl.GetLocalizationText("0093");
			break;
		case GameData_DDOL.GameType.Baseball:
			modeButtons[0].name.text = GameSettingCtrl.GetLocalizationText("0007");
			modeButtons[1].name.text = GameSettingCtrl.GetLocalizationText("0006");
			break;
		}
	}

	private void Update()
	{
		if (exitDelayTime > 0f)
		{
			exitDelayTime -= Time.deltaTime;
		}
		if (gos_ui[5].activeSelf && !button_connect.activeSelf)
		{
			connectTime = Mathf.Clamp(connectTime - Time.deltaTime, 0f, 10f);
			if (connectTime <= 0f)
			{
				button_connect.SetActive(value: true);
				isActive = true;
			}
		}
		if (lobbyUIState == LobbyUIState.Close)
		{
			if (!SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.IsCustomModelData())
			{
				return;
			}
			if (((Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)) && Input.GetKeyDown(KeyCode.Alpha1)) || ((Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)) && Input.GetKeyDown(KeyCode.Keypad1)))
			{
				UnityEngine.Debug.Log("GameType - Tennis");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Tennis;
				OpenStartPage();
			}
			else if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1))
			{
				UnityEngine.Debug.Log("GameType - Bowling");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Bowling;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2))
			{
				UnityEngine.Debug.Log("GameType - Archery");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Archery;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3))
			{
				UnityEngine.Debug.Log("GameType - BasketBall");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Basketball;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha4) || Input.GetKeyDown(KeyCode.Keypad4))
			{
				UnityEngine.Debug.Log("GameType - Badminton");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Badminton;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha5) || Input.GetKeyDown(KeyCode.Keypad5))
			{
				UnityEngine.Debug.Log("GameType - Billiards");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Billiards;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha6) || Input.GetKeyDown(KeyCode.Keypad6))
			{
				UnityEngine.Debug.Log("GameType - Darts");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Darts;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha7) || Input.GetKeyDown(KeyCode.Keypad7))
			{
				UnityEngine.Debug.Log("GameType - PingPong");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.TableTennis;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha8) || Input.GetKeyDown(KeyCode.Keypad8))
			{
				UnityEngine.Debug.Log("GameType - Boxing");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Boxing;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha9) || Input.GetKeyDown(KeyCode.Keypad9))
			{
				UnityEngine.Debug.Log("GameType - Golf");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Golf;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.Alpha0) || Input.GetKeyDown(KeyCode.Keypad0))
			{
				UnityEngine.Debug.Log("GameType - BaseBall");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType = GameData_DDOL.GameType.Baseball;
				OpenStartPage();
			}
			if (Input.GetKeyDown(KeyCode.P))
			{
				UnityEngine.Debug.Log("GameType - CharCustom");
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.None;
				SingletonBase.Singleton<MeshFadeCtrl>.GetInstance.LoadScene(1);
			}
		}
		if (!isActive)
		{
			return;
		}
		switch (lobbyUIState)
		{
		case LobbyUIState.Menu:
			if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1))
			{
				UnityEngine.Debug.Log("Menu - Single");
				Click_InputKey("Single");
			}
			if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2))
			{
				UnityEngine.Debug.Log("Menu - RandomMatch");
				Click_InputKey("Random");
			}
			if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3))
			{
				UnityEngine.Debug.Log("Menu - FriendMatch");
				Click_InputKey("Code");
			}
			if (Input.GetKeyDown(KeyCode.B))
			{
				UnityEngine.Debug.Log("Back State");
				Click_InputKey("PageBack");
			}
			break;
		case LobbyUIState.Mode:
			if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1))
			{
				UnityEngine.Debug.Log("Mode - Mode1");
				Click_InputKey("Mode1");
			}
			if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2))
			{
				UnityEngine.Debug.Log("Mode - Mode2");
				Click_InputKey("Mode2");
			}
			if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3))
			{
				UnityEngine.Debug.Log("Mode - Mode3");
				Click_InputKey("Mode3");
			}
			if (Input.GetKeyDown(KeyCode.B))
			{
				UnityEngine.Debug.Log("Back State");
				Click_InputKey("PageBack");
			}
			break;
		case LobbyUIState.Level:
			if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1))
			{
				UnityEngine.Debug.Log("Level_1 Start");
				Click_InputKey("Level1");
			}
			if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2))
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 1)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_2 Start");
				Click_InputKey("Level2");
			}
			if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3))
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 2)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_3 Start");
				Click_InputKey("Level3");
			}
			if (Input.GetKeyDown(KeyCode.Alpha4) || Input.GetKeyDown(KeyCode.Keypad4))
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 3)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_4 Start");
				Click_InputKey("Level4");
			}
			if (Input.GetKeyDown(KeyCode.Alpha5) || Input.GetKeyDown(KeyCode.Keypad5))
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 4)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_5 Start");
				Click_InputKey("Level5");
			}
			if ((Input.GetKeyDown(KeyCode.Alpha6) || Input.GetKeyDown(KeyCode.Keypad6)) && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 5)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_6 Start");
				Click_InputKey("Level6");
			}
			if ((Input.GetKeyDown(KeyCode.Alpha7) || Input.GetKeyDown(KeyCode.Keypad7)) && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 6)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_7 Start");
				Click_InputKey("Level7");
			}
			if ((Input.GetKeyDown(KeyCode.Alpha8) || Input.GetKeyDown(KeyCode.Keypad8)) && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 7)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_8 Start");
				Click_InputKey("Level8");
			}
			if ((Input.GetKeyDown(KeyCode.Alpha9) || Input.GetKeyDown(KeyCode.Keypad9)) && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetClearLevelData() < 8)
				{
					break;
				}
				UnityEngine.Debug.Log("Level_9 Start");
				Click_InputKey("Level9");
			}
			if (Input.GetKeyDown(KeyCode.B))
			{
				UnityEngine.Debug.Log("Back State");
				Click_InputKey("PageBack");
			}
			break;
		case LobbyUIState.InputCode:
			if (Input.GetKeyDown(KeyCode.Alpha0) || Input.GetKeyDown(KeyCode.Keypad0))
			{
				Click_InputKey("0");
			}
			if (Input.GetKeyDown(KeyCode.Alpha1) || Input.GetKeyDown(KeyCode.Keypad1))
			{
				Click_InputKey("1");
			}
			if (Input.GetKeyDown(KeyCode.Alpha2) || Input.GetKeyDown(KeyCode.Keypad2))
			{
				Click_InputKey("2");
			}
			if (Input.GetKeyDown(KeyCode.Alpha3) || Input.GetKeyDown(KeyCode.Keypad3))
			{
				Click_InputKey("3");
			}
			if (Input.GetKeyDown(KeyCode.Alpha4) || Input.GetKeyDown(KeyCode.Keypad4))
			{
				Click_InputKey("4");
			}
			if (Input.GetKeyDown(KeyCode.Alpha5) || Input.GetKeyDown(KeyCode.Keypad5))
			{
				Click_InputKey("5");
			}
			if (Input.GetKeyDown(KeyCode.Alpha6) || Input.GetKeyDown(KeyCode.Keypad6))
			{
				Click_InputKey("6");
			}
			if (Input.GetKeyDown(KeyCode.Alpha7) || Input.GetKeyDown(KeyCode.Keypad7))
			{
				Click_InputKey("7");
			}
			if (Input.GetKeyDown(KeyCode.Alpha8) || Input.GetKeyDown(KeyCode.Keypad8))
			{
				Click_InputKey("8");
			}
			if (Input.GetKeyDown(KeyCode.Alpha9) || Input.GetKeyDown(KeyCode.Keypad9))
			{
				Click_InputKey("9");
			}
			if (Input.GetKeyDown(KeyCode.Backspace))
			{
				Click_InputKey("Back");
			}
			if (Input.GetKeyDown(KeyCode.KeypadEnter) || Input.GetKeyDown(KeyCode.Return))
			{
				Click_InputKey("Enter");
			}
			if (Input.GetKeyDown(KeyCode.B))
			{
				UnityEngine.Debug.Log("Back State");
				Click_InputKey("PageBack");
			}
			break;
		case LobbyUIState.Random:
			if (Input.GetKeyDown(KeyCode.B))
			{
				UnityEngine.Debug.Log("Back State");
				Click_InputKey("PageBack");
			}
			break;
		case LobbyUIState.Friend:
			if (Input.GetKeyDown(KeyCode.B))
			{
				UnityEngine.Debug.Log("Back State");
				Click_InputKey("PageBack");
			}
			break;
		case LobbyUIState.RoomOut:
			if (Input.GetKeyDown(KeyCode.B))
			{
				UnityEngine.Debug.Log("Back State");
				Click_InputKey("PageBack");
			}
			break;
		case LobbyUIState.Match_S:
		case LobbyUIState.Server:
			break;
		}
	}

	private bool CheckExitButton()
	{
		if (exitDelayTime > 0f)
		{
			return false;
		}
		if (Camera.main == null)
		{
			return false;
		}
		return Vector3.Dot((exitButtonTr.position - Camera.main.transform.position).normalized, Camera.main.transform.forward) >= 0.7f;
	}

	public void Click_InputKey(string key)
	{
		if (CheckExitButton())
		{
			if (!(key == "Exit"))
			{
				if (key == "Setting")
				{
					SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
					UnityEngine.Debug.LogError("Setting");
					PublicGameUIManager.GetInstance.Click_InputKey("Setting");
				}
			}
			else
			{
				gameSetting.SaveData();
				UnityEngine.Application.Quit();
			}
		}
		if (!isActive)
		{
			return;
		}
		switch (key)
		{
		case "0":
		case "1":
		case "2":
		case "3":
		case "4":
		case "5":
		case "6":
		case "7":
		case "8":
		case "9":
			SetCodeText(key);
			break;
		case "ServerB":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SetServerPage(isNext: false);
			break;
		case "ServerN":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SetServerPage(isNext: true);
			break;
		case "Back":
			if (inputString.Length <= 0)
			{
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(8);
				break;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(6);
			inputString = inputString.Remove(inputString.Length - 1);
			text_code.text = inputString;
			break;
		case "Enter":
			if (inputString.Length < codeSize_min)
			{
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(8);
				break;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(7);
			SetLobbyUI(LobbyUIState.Friend);
			break;
		case "Menu":
			OpenStartPage();
			break;
		case "Single":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play_Voice(13);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Boxing)
			{
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
				SetLobbyUI(LobbyUIState.Mode);
			}
			else
			{
				Click_InputKey("Level");
			}
			break;
		case "Level":
			SetPageLevel();
			break;
		case "Code":
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Basketball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Bowling)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 2;
			}
			else
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 1;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play_Voice(15);
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SetLobbyUI(LobbyUIState.InputCode);
			break;
		case "Random":
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Basketball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Bowling)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 2;
			}
			else
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 1;
			}
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play_Voice(14);
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Close":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SetLobbyUI(LobbyUIState.Close);
			break;
		case "Mode1":
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 1;
			Click_InputKey("Level");
			break;
		case "Mode2":
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 2;
			Click_InputKey("Level");
			break;
		case "Mode3":
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode = 3;
			Click_InputKey("Level");
			break;
		case "Level1":
		case "Level2":
		case "Level3":
		case "Level4":
		case "Level5":
		case "Level6":
		case "Level7":
		case "Level8":
		case "Level9":
		{
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			int num = int.Parse(key.Substring(5));
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level = num;
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id;
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick;
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id = "AI";
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick = GameSettingCtrl.GetLocalizationText("0173") + SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.Single;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Boxing && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2))
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single = null;
				SingletonBase.Singleton<LobbyPropManager>.GetInstance.StartGame();
				anim_mainUI.SetTrigger("OnClose");
				isActive = false;
			}
			else
			{
				SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play_Voice(15 + num);
				SetLobbyUI(LobbyUIState.Match_S);
			}
			break;
		}
		case "Bowling":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Bowling);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Archery":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Archery);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "BasketBall":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Basketball);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Badminton":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Badminton);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Billiards":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Billiards);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Darts":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Darts);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "TableTennis":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.TableTennis);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Boxing":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Boxing);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Golf":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Golf);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "BaseBall":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Baseball);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "Tennis":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.SetFindRoom(GameData_DDOL.GameType.Tennis);
			SetLobbyUI(LobbyUIState.Random);
			break;
		case "PageBack":
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(4);
			switch (lobbyUIState)
			{
			case LobbyUIState.Level:
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Boxing)
				{
					SetLobbyUI(LobbyUIState.Mode);
				}
				else
				{
					SetLobbyUI(LobbyUIState.Menu);
				}
				break;
			case LobbyUIState.Mode:
				SetLobbyUI(LobbyUIState.Menu);
				break;
			case LobbyUIState.InputCode:
			case LobbyUIState.Random:
			case LobbyUIState.Friend:
				SetLobbyUI(LobbyUIState.Menu);
				break;
			case LobbyUIState.Match_S:
				SetLobbyUI(LobbyUIState.Level);
				break;
			default:
				SetLobbyUI(LobbyUIState.Close);
				break;
			}
			break;
		}
	}

	public void SetCodeText(string key)
	{
		if (inputString.Length >= codeSize_max)
		{
			SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(8);
			return;
		}
		SingletonBase.Singleton<LobbySoundManager>.GetInstance.Play(5);
		inputString += key;
		text_code.text = inputString;
	}

	private IEnumerator TextCoroutine()
	{
		while (true)
		{
			text_code.text = inputString + "_";
			yield return new WaitForSeconds(0.5f);
			text_code.text = inputString;
			yield return new WaitForSeconds(0.5f);
		}
	}

	public string GetRoomCode()
	{
		return inputString;
	}

	public void SetMatchBackButton(bool isActive)
	{
		button_match.SetActive(isActive);
	}

	public void SetOtherGames(bool isActive)
	{
		if (isActive)
		{
			gos_ui[7].transform.localScale = Vector3.zero;
		}
		gos_ui[7].SetActive(isActive);
	}

	public void SetServerUI(bool isActive)
	{
		if (isActive)
		{
			gos_ui[8].transform.localScale = Vector3.zero;
		}
		gos_ui[8].SetActive(isActive);
	}

	public void InitServerUI()
	{
		SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.index_server = 0;
		LobbyPhotonManager.ServerInfo serverInfo = SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.GetServerInfo();
		text_serverName.text = serverInfo.name;
		text_serverName.rectTransform.sizeDelta = new Vector2(text_serverName.preferredWidth, 80f);
		text_ping.text = serverInfo.ping;
		image_ping.sprite = sprites_ping[serverInfo.grade];
		pref_page.SetActive(value: true);
		for (int num = list_pageIcon.Count - 1; num >= 0; num--)
		{
			UnityEngine.Object.Destroy(list_pageIcon[num]);
		}
		list_pageIcon.Clear();
		for (int i = 0; i < SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.serverInfos.Length; i++)
		{
			list_pageIcon.Add(UnityEngine.Object.Instantiate(pref_page, pref_page.transform.parent));
		}
		pref_page.SetActive(value: false);
		SetServerPageIcon();
	}

	public void SetServerPageIcon()
	{
		int index_server = SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.index_server;
		for (int i = 0; i < list_pageIcon.Count; i++)
		{
			if (index_server == i)
			{
				list_pageIcon[i].transform.localScale = Vector3.one * 1.5f;
			}
			else
			{
				list_pageIcon[i].transform.localScale = Vector3.one;
			}
		}
	}

	public void SetServerPage(bool isNext)
	{
		int index_server = SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.index_server;
		index_server = ((!isNext) ? (index_server - 1) : (index_server + 1));
		if (index_server > SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.serverInfos.Length - 1)
		{
			index_server = 0;
		}
		else if (index_server < 0)
		{
			index_server = SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.serverInfos.Length - 1;
		}
		SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.index_server = index_server;
		LobbyPhotonManager.ServerInfo serverInfo = SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.GetServerInfo();
		text_serverName.text = serverInfo.name;
		text_serverName.rectTransform.sizeDelta = new Vector2(text_serverName.preferredWidth, 80f);
		text_ping.text = serverInfo.ping;
		image_ping.sprite = sprites_ping[serverInfo.grade];
		SetServerPageIcon();
		StartServerChange();
	}

	public void StartServerChange()
	{
		if (serverChangeCoroutine != null)
		{
			StopCoroutine(serverChangeCoroutine);
		}
		SingletonPunBase.Singleton<LobbyPhotonManager>.GetInstance.StartDisconnect();
		serverChangeCoroutine = StartCoroutine(ServerChangeCoroutine());
	}

	private IEnumerator ServerChangeCoroutine()
	{
		yield return new WaitForSeconds(3f);
		SetLobbyUI(LobbyUIState.Server);
	}

	public void SetViewGameType()
	{
		switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType)
		{
		case GameData_DDOL.GameType.Bowling:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0159");
			break;
		case GameData_DDOL.GameType.Archery:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0160");
			break;
		case GameData_DDOL.GameType.Basketball:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0161");
			break;
		case GameData_DDOL.GameType.Badminton:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0162");
			break;
		case GameData_DDOL.GameType.Billiards:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0163");
			break;
		case GameData_DDOL.GameType.Darts:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0164");
			break;
		case GameData_DDOL.GameType.TableTennis:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0165");
			break;
		case GameData_DDOL.GameType.Boxing:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0166");
			break;
		case GameData_DDOL.GameType.Golf:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0167");
			break;
		case GameData_DDOL.GameType.Baseball:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0168");
			break;
		case GameData_DDOL.GameType.Tennis:
			text_gameType.text = GameSettingCtrl.GetLocalizationText("0172");
			break;
		}
	}

	public void SetViewMatchText()
	{
		text_time.text = GameSettingCtrl.GetLocalizationText("0170");
	}
}
public class MedalViewCtrl : MonoBehaviour
{
	public class MedalInfo
	{
		public Transform transform;

		public Vector3 startPos;
	}

	public Mesh[] meshes_medal;

	private MedalInfo[] medalInfos;

	public AnimationCurve animationCurve_pos;

	private float timeP;

	private float speed = 0.5f;

	private bool isInit;

	private void Awake()
	{
		medalInfos = new MedalInfo[base.transform.childCount];
		for (int i = 0; i < medalInfos.Length; i++)
		{
			medalInfos[i] = new MedalInfo();
			medalInfos[i].transform = base.transform.GetChild(i);
			medalInfos[i].startPos = medalInfos[i].transform.position;
			medalInfos[i].transform.gameObject.SetActive(value: false);
		}
		isInit = true;
	}

	private void Update()
	{
		if (isInit)
		{
			timeP += Time.deltaTime * speed;
			if (timeP > 1f)
			{
				timeP -= 1f;
			}
			Vector3 vector = new Vector3(0f, animationCurve_pos.Evaluate(timeP), 0f);
			Quaternion rotation = Quaternion.Euler(0f, timeP * 360f, 90f);
			for (int i = 0; i < medalInfos.Length; i++)
			{
				medalInfos[i].transform.SetPositionAndRotation(medalInfos[i].startPos + vector, rotation);
			}
		}
	}

	public void Init()
	{
		medalInfos = new MedalInfo[base.transform.childCount];
		for (int i = 0; i < medalInfos.Length; i++)
		{
			medalInfos[i] = new MedalInfo();
			medalInfos[i].transform = base.transform.GetChild(i);
			medalInfos[i].startPos = medalInfos[i].transform.position;
			medalInfos[i].transform.GetComponent<MeshFilter>().sharedMesh = meshes_medal[0];
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		for (int j = 0; j < SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas.Length; j++)
		{
			if (j == 8)
			{
				switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas[j])
				{
				case 9:
					medalInfos[j].transform.GetComponent<MeshFilter>().sharedMesh = meshes_medal[0];
					medalInfos[j].transform.gameObject.SetActive(value: true);
					num3++;
					num2++;
					num++;
					break;
				case 8:
					medalInfos[j].transform.GetComponent<MeshFilter>().sharedMesh = meshes_medal[1];
					medalInfos[j].transform.gameObject.SetActive(value: true);
					num2++;
					num++;
					break;
				case 7:
					medalInfos[j].transform.GetComponent<MeshFilter>().sharedMesh = meshes_medal[2];
					medalInfos[j].transform.gameObject.SetActive(value: true);
					num++;
					break;
				default:
					medalInfos[j].transform.gameObject.SetActive(value: false);
					break;
				}
			}
			else
			{
				switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas[j])
				{
				case 5:
					medalInfos[j].transform.GetComponent<MeshFilter>().sharedMesh = meshes_medal[0];
					medalInfos[j].transform.gameObject.SetActive(value: true);
					num3++;
					num2++;
					num++;
					break;
				case 4:
					medalInfos[j].transform.GetComponent<MeshFilter>().sharedMesh = meshes_medal[1];
					medalInfos[j].transform.gameObject.SetActive(value: true);
					num2++;
					num++;
					break;
				case 3:
					medalInfos[j].transform.GetComponent<MeshFilter>().sharedMesh = meshes_medal[2];
					medalInfos[j].transform.gameObject.SetActive(value: true);
					num++;
					break;
				default:
					medalInfos[j].transform.gameObject.SetActive(value: false);
					break;
				}
			}
		}
		if (num > 0)
		{
			SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach01", num, UserInfoManager.UnlockAchieveState.Change);
		}
		if (num2 > 0)
		{
			SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach02", num2, UserInfoManager.UnlockAchieveState.Change);
		}
		if (num3 > 0)
		{
			SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach03", num3, UserInfoManager.UnlockAchieveState.Change);
		}
		isInit = true;
	}
}
public enum ButtonRatio
{
	Square,
	Height,
	Width
}
public class MeshButtonCtrl : CustomizeProp
{
	public enum ButtonType
	{
		Normal,
		Keyboard
	}

	public ButtonType buttonType;

	private ButtonRatio buttonRatio;

	private Transform moveButtonTr;

	public LayerMask layerMask;

	private float halfExtents;

	public float limitPos = 0.15f;

	private bool isTrigger;

	private float startPosZ;

	private float ray_dist;

	private bool isDown;

	private float delayTime;

	private bool isInteractable = true;

	private float interactableTime;

	private bool isInit;

	public UnityEvent event_click;

	private MeshRenderer renderer_button;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		if (isInit)
		{
			return;
		}
		Vector3 size = base.transform.GetComponent<BoxCollider>().size;
		if (Mathf.Abs(size.x - size.y) >= 0.001f)
		{
			if (size.x - size.y < 0f)
			{
				buttonRatio = ButtonRatio.Height;
				halfExtents = size.x * 0.5f;
				ray_dist = (size.y - size.x) * 0.5f;
			}
			else
			{
				buttonRatio = ButtonRatio.Width;
				halfExtents = size.y * 0.5f;
				ray_dist = (size.x - size.y) * 0.5f;
			}
		}
		else
		{
			buttonRatio = ButtonRatio.Square;
			halfExtents = size.x * 0.5f;
		}
		moveButtonTr = base.transform.Find("Button");
		startPosZ = moveButtonTr.localPosition.z;
		renderer_button = moveButtonTr.GetComponentInChildren<MeshRenderer>();
		isInit = true;
	}

	private void FixedUpdate()
	{
		if (isInteractable)
		{
			if (!Physics.autoSimulation)
			{
				MoveButton();
			}
			if (!isTrigger)
			{
				moveButtonTr.localPosition = Vector3.forward * startPosZ;
				isDown = false;
				delayTime = 0f;
				interactableTime = 0.1f;
			}
			isTrigger = false;
			delayTime = Mathf.Clamp01(delayTime - Time.fixedUnscaledDeltaTime);
		}
	}

	public bool IsInteractable()
	{
		return isInteractable;
	}

	public void SetInteractable(bool _isInteractable)
	{
		Init();
		isInteractable = _isInteractable;
		if (!isInteractable)
		{
			moveButtonTr.localPosition = Vector3.forward * limitPos;
		}
	}

	private void OnEnable()
	{
		Init();
		if (isInteractable)
		{
			moveButtonTr.localPosition = Vector3.forward * startPosZ;
		}
		else
		{
			moveButtonTr.localPosition = Vector3.forward * limitPos;
		}
	}

	public void SetMaterial(Material mat)
	{
		Init();
		renderer_button.sharedMaterial = mat;
	}

	private void OnTriggerStay(Collider other)
	{
		MoveButton();
	}

	private void MoveButton()
	{
		if (!isInteractable)
		{
			return;
		}
		RaycastHit hitInfo = default(RaycastHit);
		RaycastHit hitInfo2 = default(RaycastHit);
		bool flag = false;
		bool flag2 = false;
		switch (buttonRatio)
		{
		case ButtonRatio.Square:
			flag = Physics.BoxCast(base.transform.position + base.transform.forward * -0.1f, Vector3.one * halfExtents, base.transform.forward, out hitInfo, base.transform.rotation, 2f, layerMask);
			break;
		case ButtonRatio.Height:
			flag = Physics.BoxCast(base.transform.position + base.transform.forward * -0.1f + base.transform.up * (0f - ray_dist), Vector3.one * halfExtents, base.transform.forward, out hitInfo, base.transform.rotation, 2f, layerMask);
			flag2 = Physics.BoxCast(base.transform.position + base.transform.forward * -0.1f + base.transform.up * ray_dist, Vector3.one * halfExtents, base.transform.forward, out hitInfo2, base.transform.rotation, 2f, layerMask);
			break;
		case ButtonRatio.Width:
			flag = Physics.BoxCast(base.transform.position + base.transform.forward * -0.1f + base.transform.right * (0f - ray_dist), Vector3.one * halfExtents, base.transform.forward, out hitInfo, base.transform.rotation, 2f, layerMask);
			flag2 = Physics.BoxCast(base.transform.position + base.transform.forward * -0.1f + base.transform.right * ray_dist, Vector3.one * halfExtents, base.transform.forward, out hitInfo2, base.transform.rotation, 2f, layerMask);
			break;
		}
		if (!(flag || flag2))
		{
			return;
		}
		Vector3 vector;
		if (buttonRatio == ButtonRatio.Square)
		{
			vector = base.transform.InverseTransformPoint(hitInfo.point);
		}
		else
		{
			Vector3 vector2 = base.transform.InverseTransformPoint(hitInfo.point);
			Vector3 vector3 = base.transform.InverseTransformPoint(hitInfo2.point);
			vector = ((!flag2) ? vector2 : (flag ? ((vector2.z < vector3.z) ? vector2 : vector3) : vector3));
		}
		moveButtonTr.localPosition = Vector3.forward * Mathf.Clamp(vector.z, limitPos, startPosZ);
		isTrigger = true;
		if (interactableTime > 0f)
		{
			interactableTime -= Time.fixedDeltaTime;
		}
		else if (moveButtonTr.localPosition.z == limitPos && delayTime <= 0f)
		{
			if (buttonType == ButtonType.Keyboard)
			{
				if (!isDown)
				{
					isDown = true;
					delayTime = 0.5f;
				}
				else
				{
					delayTime = 0.1f;
				}
				event_click.Invoke();
			}
			else if (!isDown)
			{
				isDown = true;
				event_click.Invoke();
			}
		}
		else if (isDown && moveButtonTr.localPosition.z - limitPos >= 0.001f)
		{
			isDown = false;
			delayTime = 0f;
		}
	}

	public override Vector3 GetCenterPos()
	{
		return base.transform.position;
	}

	public override void SetSize(bool isSelect)
	{
	}
}
public class MeshFadeCtrl : SingletonBase.Singleton<MeshFadeCtrl>
{
	public enum FadeState
	{
		Normal,
		LoadScene
	}

	private MeshRenderer render;

	private FadeState fadeState;

	private bool isFadeIn;

	private float fadeSpeed;

	private int sceneIndex;

	private string sceneName;

	private bool isInit;

	private Coroutine cor_fade;

	protected override void Awake()
	{
		base.Awake();
		InitData();
	}

	private void InitData()
	{
		if (!isInit)
		{
			isInit = true;
			render = base.gameObject.AddComponent<MeshRenderer>();
			render.materials = new Material[1]
			{
				new Material(Shader.Find("Oculus/Unlit Transparent Color"))
			};
			render.materials[0].renderQueue = 5000;
			render.materials[0].SetColor("_Color", Color.black);
			Mesh mesh2 = (base.gameObject.AddComponent<MeshFilter>().mesh = new Mesh());
			Vector3[] array = new Vector3[4];
			float num = 2f;
			float num2 = 2f;
			float z = 1f;
			array[0] = new Vector3(0f - num, 0f - num2, z);
			array[1] = new Vector3(num, 0f - num2, z);
			array[2] = new Vector3(0f - num, num2, z);
			array[3] = new Vector3(num, num2, z);
			mesh2.vertices = array;
			mesh2.triangles = new int[6] { 0, 2, 1, 2, 3, 1 };
			mesh2.normals = new Vector3[4]
			{
				-Vector3.forward,
				-Vector3.forward,
				-Vector3.forward,
				-Vector3.forward
			};
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(1f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f)
			};
		}
	}

	public void StartFade(bool _isFadeIn, float _fadeSpeed = 0.75f)
	{
		InitData();
		if (cor_fade != null)
		{
			StopCoroutine(cor_fade);
		}
		fadeState = FadeState.Normal;
		isFadeIn = _isFadeIn;
		fadeSpeed = _fadeSpeed;
		cor_fade = StartCoroutine(FadeCoroutine());
	}

	public void LoadScene(int _sceneIndex, float _fadeSpeed = 0.75f)
	{
		if (cor_fade != null)
		{
			StopCoroutine(cor_fade);
		}
		fadeState = FadeState.LoadScene;
		isFadeIn = false;
		sceneIndex = _sceneIndex;
		fadeSpeed = _fadeSpeed;
		cor_fade = StartCoroutine(FadeCoroutine());
	}

	public void LoadScene(string _sceneName, float _fadeSpeed = 0.75f)
	{
		if (cor_fade != null)
		{
			StopCoroutine(cor_fade);
		}
		fadeState = FadeState.LoadScene;
		isFadeIn = false;
		sceneIndex = -1;
		sceneName = _sceneName;
		fadeSpeed = _fadeSpeed;
		if (SceneManager.GetActiveScene().name == "Scene_Lobby")
		{
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.gameSetting.SaveData();
		}
		cor_fade = StartCoroutine(FadeCoroutine());
	}

	private IEnumerator FadeCoroutine()
	{
		float velueP = 0f;
		if (isFadeIn)
		{
			render.materials[0].SetColor("_Color", Color.black);
			yield return new WaitForSeconds(0.3f);
			while (true)
			{
				velueP = Mathf.Clamp01(velueP + Time.deltaTime * fadeSpeed);
				render.materials[0].SetColor("_Color", Color.Lerp(Color.black, Color.clear, velueP));
				if (velueP == 1f)
				{
					break;
				}
				yield return null;
			}
			render.enabled = false;
			yield break;
		}
		render.enabled = true;
		while (true)
		{
			velueP = Mathf.Clamp01(velueP + Time.deltaTime * fadeSpeed);
			render.materials[0].SetColor("_Color", Color.Lerp(Color.clear, Color.black, velueP));
			if (velueP == 1f)
			{
				break;
			}
			yield return null;
		}
		if (fadeState == FadeState.LoadScene)
		{
			if (sceneIndex == -1)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					PhotonNetwork.LoadLevel(sceneName);
				}
				else
				{
					SceneManager.LoadScene(sceneName);
				}
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel(sceneIndex);
			}
			else
			{
				SceneManager.LoadScene(sceneIndex);
			}
		}
		else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
		{
			yield return new WaitForSeconds(6f);
			if (PhotonNetwork.IsConnected)
			{
				PhotonNetwork.Disconnect();
			}
			render.materials[0].SetColor("_Color", Color.clear);
			render.enabled = false;
			SingletonBase.Singleton<LobbyPropManager>.GetInstance.isStartGame = false;
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.SetLobbyUI(LobbyUIManager.LobbyUIState.RoomOut);
		}
	}
}
public class MyCharacterCtrl : MonoBehaviour
{
	public Animator anim;

	private Material mat_body;

	private MeshFilter meshFilter_head;

	private MeshRenderer renderer_head;

	private SkinnedMeshRenderer renderer_body_cut;

	private SkinnedMeshRenderer renderer_body_cut_h;

	private SkinnedMeshRenderer renderer_body_origin;

	private SkinnedMeshRenderer renderer_body_origin_h;

	private MeshFilter meshFilter_hair_f;

	private MeshFilter meshFilter_hair_b;

	private MeshRenderer renderer_hair_f;

	private MeshRenderer renderer_hair_b;

	private SkinnedMeshRenderer renderer_wear_u;

	private SkinnedMeshRenderer renderer_wear_u_c;

	private SkinnedMeshRenderer renderer_wear_l;

	private SkinnedMeshRenderer renderer_wear_l_s;

	private SkinnedMeshRenderer renderer_wear_h;

	private SkinnedMeshRenderer renderer_wear_f;

	private MeshFilter meshFilter_acc;

	private MeshRenderer renderer_acc;

	public bool isInit;

	private Transform[] boneTrs;

	private bool isOptimizeGameObjects;

	public UnityEngine.Avatar[] avatars;

	private void Start()
	{
		InitData();
	}

	private void InitData()
	{
		if (isInit)
		{
			return;
		}
		boneTrs = new Transform[59];
		anim = base.transform.GetComponent<Animator>();
		isOptimizeGameObjects = base.transform.Find("BODY_ORG_HIDDEN").GetComponent<SkinnedMeshRenderer>().rootBone == null;
		if (isOptimizeGameObjects)
		{
			meshFilter_head = base.transform.Find("ITEM_HEAD").GetComponent<MeshFilter>();
			renderer_head = base.transform.Find("ITEM_HEAD").GetComponent<MeshRenderer>();
			renderer_body_cut = base.transform.Find("BODY_CUT").GetComponent<SkinnedMeshRenderer>();
			renderer_body_cut_h = base.transform.Find("BODY_CUT_HIDDEN").GetComponent<SkinnedMeshRenderer>();
			renderer_body_origin = base.transform.Find("BODY_ORG").GetComponent<SkinnedMeshRenderer>();
			renderer_body_origin_h = base.transform.Find("BODY_ORG_HIDDEN").GetComponent<SkinnedMeshRenderer>();
			mat_body = renderer_body_cut.sharedMaterial;
			meshFilter_hair_f = base.transform.Find("ITEM_HAIR_F").GetComponent<MeshFilter>();
			meshFilter_hair_b = base.transform.Find("ITEM_HAIR_B").GetComponent<MeshFilter>();
			renderer_hair_f = base.transform.Find("ITEM_HAIR_F").GetComponent<MeshRenderer>();
			renderer_hair_b = base.transform.Find("ITEM_HAIR_B").GetComponent<MeshRenderer>();
			renderer_wear_u = base.transform.Find("ITEM_UPPER").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_u_c = base.transform.Find("ITEM_UPPER_CUT").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_l = base.transform.Find("ITEM_LOWER").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_l_s = base.transform.Find("ITEM_LOWER_SUB").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_f = base.transform.Find("ITEM_FOOT").GetComponent<SkinnedMeshRenderer>();
			meshFilter_acc = base.transform.Find("ITEM_HEAD_ACC").GetComponent<MeshFilter>();
			renderer_acc = base.transform.Find("ITEM_HEAD_ACC").GetComponent<MeshRenderer>();
		}
		else
		{
			Transform[] componentsInChildren = base.transform.Find("Bip001").GetComponentsInChildren<Transform>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				int num = WearInfoCreator.BoneNameToIndex(componentsInChildren[i].name);
				if (num != -1)
				{
					boneTrs[num] = componentsInChildren[i];
				}
			}
			Transform transform = base.transform.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Spine2/Bip001 Neck/Bip001 Head");
			meshFilter_head = transform.Find("ITEM_HEAD").GetComponent<MeshFilter>();
			renderer_head = transform.Find("ITEM_HEAD").GetComponent<MeshRenderer>();
			renderer_body_cut = base.transform.Find("BODY_CUT").GetComponent<SkinnedMeshRenderer>();
			renderer_body_cut_h = base.transform.Find("BODY_CUT_HIDDEN").GetComponent<SkinnedMeshRenderer>();
			renderer_body_origin = base.transform.Find("BODY_ORG").GetComponent<SkinnedMeshRenderer>();
			renderer_body_origin_h = base.transform.Find("BODY_ORG_HIDDEN").GetComponent<SkinnedMeshRenderer>();
			meshFilter_hair_f = transform.Find("ITEM_HAIR_F").GetComponent<MeshFilter>();
			meshFilter_hair_b = transform.Find("ITEM_HAIR_B").GetComponent<MeshFilter>();
			renderer_hair_f = transform.Find("ITEM_HAIR_F").GetComponent<MeshRenderer>();
			renderer_hair_b = transform.Find("ITEM_HAIR_B").GetComponent<MeshRenderer>();
			renderer_wear_u = base.transform.Find("ITEM_UPPER").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_u_c = base.transform.Find("ITEM_UPPER_CUT").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_l = base.transform.Find("ITEM_LOWER").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_l_s = base.transform.Find("ITEM_LOWER_SUB").GetComponent<SkinnedMeshRenderer>();
			renderer_wear_f = base.transform.Find("ITEM_FOOT").GetComponent<SkinnedMeshRenderer>();
			meshFilter_acc = transform.Find("ITEM_HEAD_ACC").GetComponent<MeshFilter>();
			renderer_acc = transform.Find("ITEM_HEAD_ACC").GetComponent<MeshRenderer>();
		}
		meshFilter_acc.transform.parent = meshFilter_head.transform;
		isInit = true;
	}

	public void SetGender(int genderNum)
	{
		InitData();
		SingletonBase.Singleton<CustomizeManager>.GetInstance.SetSelectGenderUI(genderNum);
		switch (genderNum)
		{
		case 0:
		{
			anim.avatar = avatars[0];
			meshFilter_head.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_HEAD");
			mat_body = Resources.Load<Material>("Customize/Bodies/Mat_M_SKIN");
			renderer_body_cut.sharedMaterial = mat_body;
			renderer_body_cut_h.sharedMaterial = mat_body;
			renderer_body_origin.sharedMaterial = mat_body;
			renderer_body_origin_h.sharedMaterial = mat_body;
			renderer_body_cut.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_CUT");
			WearInfo wearInfo2 = JsonUtility.FromJson<WearInfo>((Resources.Load("ItemInfos/BodyInfo_M_Cut") as TextAsset).text);
			renderer_body_cut.localBounds = new Bounds(wearInfo2.bounds_center, wearInfo2.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_cut.rootBone = boneTrs[wearInfo2.rootBone];
				Transform[] array5 = new Transform[wearInfo2.bones.Length];
				for (int m = 0; m < wearInfo2.bones.Length; m++)
				{
					array5[m] = boneTrs[wearInfo2.bones[m]];
				}
				renderer_body_cut.bones = array5;
			}
			renderer_body_cut_h.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_CUT_HIDDEN");
			TextAsset obj4 = Resources.Load("ItemInfos/BodyInfo_M_Cut_H") as TextAsset;
			wearInfo2 = null;
			wearInfo2 = JsonUtility.FromJson<WearInfo>(obj4.text);
			renderer_body_cut_h.localBounds = new Bounds(wearInfo2.bounds_center, wearInfo2.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_cut_h.rootBone = boneTrs[wearInfo2.rootBone];
				Transform[] array6 = new Transform[wearInfo2.bones.Length];
				for (int n = 0; n < wearInfo2.bones.Length; n++)
				{
					array6[n] = boneTrs[wearInfo2.bones[n]];
				}
				renderer_body_cut_h.bones = array6;
			}
			renderer_body_origin.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_ORG");
			TextAsset obj5 = Resources.Load("ItemInfos/BodyInfo_M_Origin") as TextAsset;
			wearInfo2 = null;
			wearInfo2 = JsonUtility.FromJson<WearInfo>(obj5.text);
			renderer_body_origin.localBounds = new Bounds(wearInfo2.bounds_center, wearInfo2.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_origin.rootBone = boneTrs[wearInfo2.rootBone];
				Transform[] array7 = new Transform[wearInfo2.bones.Length];
				for (int num = 0; num < wearInfo2.bones.Length; num++)
				{
					array7[num] = boneTrs[wearInfo2.bones[num]];
				}
				renderer_body_origin.bones = array7;
			}
			renderer_body_origin_h.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_M_BODY_ORG_HIDDEN");
			TextAsset obj6 = Resources.Load("ItemInfos/BodyInfo_M_Origin_H") as TextAsset;
			wearInfo2 = null;
			wearInfo2 = JsonUtility.FromJson<WearInfo>(obj6.text);
			renderer_body_origin_h.localBounds = new Bounds(wearInfo2.bounds_center, wearInfo2.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_origin_h.rootBone = boneTrs[wearInfo2.rootBone];
				Transform[] array8 = new Transform[wearInfo2.bones.Length];
				for (int num2 = 0; num2 < wearInfo2.bones.Length; num2++)
				{
					array8[num2] = boneTrs[wearInfo2.bones[num2]];
				}
				renderer_body_origin_h.bones = array8;
			}
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[0].ID_Face_I));
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[0].ID_Hair_I));
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[0].ID_Wear_I));
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[0].ID_Acc_I));
			SetColor(ColorUIPart.Skin, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Skin));
			SetColor(ColorUIPart.Eye, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eye));
			SetColor(ColorUIPart.Eyebrow, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eyebrow));
			SetColor(ColorUIPart.Hair, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Hair));
			SetColor(ColorUIPart.Upper, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Upper));
			SetColor(ColorUIPart.Lower, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Lower));
			SetColor(ColorUIPart.Foot, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Foot));
			SetColor(ColorUIPart.Pattern, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern));
			SetColor(ColorUIPart.Acc, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Acc));
			SingletonBase.Singleton<CustomizeManager>.GetInstance.SetUI();
			break;
		}
		case 1:
		{
			anim.avatar = avatars[1];
			meshFilter_head.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_HEAD");
			mat_body = Resources.Load<Material>("Customize/Bodies/Mat_F_SKIN");
			renderer_body_cut.sharedMaterial = mat_body;
			renderer_body_cut_h.sharedMaterial = mat_body;
			renderer_body_origin.sharedMaterial = mat_body;
			renderer_body_origin_h.sharedMaterial = mat_body;
			renderer_body_cut.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_CUT");
			WearInfo wearInfo = JsonUtility.FromJson<WearInfo>((Resources.Load("ItemInfos/BodyInfo_F_Cut") as TextAsset).text);
			renderer_body_cut.localBounds = new Bounds(wearInfo.bounds_center, wearInfo.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_cut.rootBone = boneTrs[wearInfo.rootBone];
				Transform[] array = new Transform[wearInfo.bones.Length];
				for (int i = 0; i < wearInfo.bones.Length; i++)
				{
					array[i] = boneTrs[wearInfo.bones[i]];
				}
				renderer_body_cut.bones = array;
			}
			renderer_body_cut_h.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_CUT_HIDDEN");
			TextAsset obj = Resources.Load("ItemInfos/BodyInfo_F_Cut_H") as TextAsset;
			wearInfo = null;
			wearInfo = JsonUtility.FromJson<WearInfo>(obj.text);
			renderer_body_cut.localBounds = new Bounds(wearInfo.bounds_center, wearInfo.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_cut.rootBone = boneTrs[wearInfo.rootBone];
				Transform[] array2 = new Transform[wearInfo.bones.Length];
				for (int j = 0; j < wearInfo.bones.Length; j++)
				{
					array2[j] = boneTrs[wearInfo.bones[j]];
				}
				renderer_body_cut.bones = array2;
			}
			renderer_body_origin.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_ORG");
			TextAsset obj2 = Resources.Load("ItemInfos/BodyInfo_F_Origin") as TextAsset;
			wearInfo = null;
			wearInfo = JsonUtility.FromJson<WearInfo>(obj2.text);
			renderer_body_cut.localBounds = new Bounds(wearInfo.bounds_center, wearInfo.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_cut.rootBone = boneTrs[wearInfo.rootBone];
				Transform[] array3 = new Transform[wearInfo.bones.Length];
				for (int k = 0; k < wearInfo.bones.Length; k++)
				{
					array3[k] = boneTrs[wearInfo.bones[k]];
				}
				renderer_body_cut.bones = array3;
			}
			renderer_body_origin_h.sharedMesh = Resources.Load<Mesh>("Customize/Bodies/Mesh_F_BODY_ORG_HIDDEN");
			TextAsset obj3 = Resources.Load("ItemInfos/BodyInfo_F_Origin_H") as TextAsset;
			wearInfo = null;
			wearInfo = JsonUtility.FromJson<WearInfo>(obj3.text);
			renderer_body_cut.localBounds = new Bounds(wearInfo.bounds_center, wearInfo.bounds_extent * 2f);
			if (!isOptimizeGameObjects)
			{
				renderer_body_cut.rootBone = boneTrs[wearInfo.rootBone];
				Transform[] array4 = new Transform[wearInfo.bones.Length];
				for (int l = 0; l < wearInfo.bones.Length; l++)
				{
					array4[l] = boneTrs[wearInfo.bones[l]];
				}
				renderer_body_cut.bones = array4;
			}
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[1].ID_Face_I));
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[1].ID_Hair_I));
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[1].ID_Wear_I));
			SetItem(SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(genderNum, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[1].ID_Acc_I));
			SetColor(ColorUIPart.Skin, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Skin));
			SetColor(ColorUIPart.Eye, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eye));
			SetColor(ColorUIPart.Eyebrow, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eyebrow));
			SetColor(ColorUIPart.Hair, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Hair));
			SetColor(ColorUIPart.Upper, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Upper));
			SetColor(ColorUIPart.Lower, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Lower));
			SetColor(ColorUIPart.Foot, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Foot));
			SetColor(ColorUIPart.Pattern, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern));
			SetColor(ColorUIPart.Acc, SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Acc));
			SingletonBase.Singleton<CustomizeManager>.GetInstance.SetUI();
			break;
		}
		}
		anim.Rebind();
	}

	public void SetItem(ItemSlotInfo _slotInfo)
	{
		SingletonBase.Singleton<CustomizeManager>.GetInstance.SetSelectUISlotID(_slotInfo.id);
		switch (_slotInfo.id[0])
		{
		case '1':
		{
			renderer_head.sharedMaterial.SetTexture("_SubTex_Eye", null);
			renderer_head.sharedMaterial.SetTexture("_SubTex_Pupil", null);
			renderer_head.sharedMaterial.SetTexture("_SubTex_Eyebrow", null);
			renderer_head.sharedMaterial.SetTexture("_SubTex_Mouth", null);
			renderer_head.sharedMaterial.SetTexture("_BaseTex", null);
			for (int l = 0; l < _slotInfo.list_partId.Count; l++)
			{
				switch (_slotInfo.list_partId[l][1])
				{
				case '0':
					renderer_head.sharedMaterial.SetTexture("_SubTex_Eye", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[l]).matPath));
					break;
				case '1':
					renderer_head.sharedMaterial.SetTexture("_SubTex_Pupil", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[l]).matPath));
					break;
				case '2':
					renderer_head.sharedMaterial.SetTexture("_SubTex_Eyebrow", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[l]).matPath));
					break;
				case '3':
					renderer_head.sharedMaterial.SetTexture("_SubTex_Mouth", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[l]).matPath));
					break;
				case '4':
					renderer_head.sharedMaterial.SetTexture("_BaseTex", Resources.Load<Texture>("Customize/Faces/" + SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[l]).matPath));
					break;
				}
			}
			if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Skin), out var color2))
			{
				renderer_head.sharedMaterial.SetColor("_BaseColor", color2);
			}
			if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eye), out color2))
			{
				renderer_head.sharedMaterial.SetColor("_EyeColor", color2);
			}
			if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Eyebrow), out color2))
			{
				renderer_head.sharedMaterial.SetColor("_EyebrowColor", color2);
			}
			int selectGenderNum4 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
			string text = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(selectGenderNum4, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum4].ID_Acc_I).list_partId[0];
			if (text != "40000" && text[1] == '0' && text != "40004")
			{
				meshFilter_head.GetComponent<MeshRenderer>().enabled = false;
			}
			else
			{
				meshFilter_head.GetComponent<MeshRenderer>().enabled = true;
			}
			break;
		}
		case '2':
		{
			renderer_hair_f.gameObject.SetActive(value: false);
			renderer_hair_b.gameObject.SetActive(value: false);
			for (int m = 0; m < _slotInfo.list_partId.Count; m++)
			{
				switch (_slotInfo.list_partId[m][1])
				{
				case '0':
				{
					ItemInfo itemInfo3 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[m]);
					meshFilter_hair_f.sharedMesh = Resources.Load<Mesh>("Customize/Hairs/" + itemInfo3.meshPath);
					renderer_hair_f.sharedMaterial = Resources.Load<Material>("Customize/Hairs/" + itemInfo3.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Hair), out var color4))
					{
						renderer_hair_f.sharedMaterial.SetColor("_BaseColor", color4);
					}
					int selectGenderNum6 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
					string text3 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(selectGenderNum6, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum6].ID_Acc_I).list_partId[0];
					if (text3 != "40000" && text3[1] == '0')
					{
						renderer_hair_f.gameObject.SetActive(value: false);
					}
					else
					{
						renderer_hair_f.gameObject.SetActive(value: true);
					}
					break;
				}
				case '1':
				{
					ItemInfo itemInfo2 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[m]);
					meshFilter_hair_b.sharedMesh = Resources.Load<Mesh>("Customize/Hairs/" + itemInfo2.meshPath);
					renderer_hair_b.sharedMaterial = Resources.Load<Material>("Customize/Hairs/" + itemInfo2.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Hair), out var color3))
					{
						renderer_hair_b.sharedMaterial.SetColor("_BaseColor", color3);
					}
					int selectGenderNum5 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
					string text2 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(selectGenderNum5, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum5].ID_Acc_I).list_partId[0];
					if (text2 != "40000" && text2[1] == '0')
					{
						renderer_hair_b.gameObject.SetActive(value: false);
					}
					else
					{
						renderer_hair_b.gameObject.SetActive(value: true);
					}
					break;
				}
				}
			}
			break;
		}
		case '3':
		{
			renderer_wear_u.gameObject.SetActive(value: false);
			renderer_wear_u_c.gameObject.SetActive(value: false);
			renderer_wear_l.gameObject.SetActive(value: false);
			renderer_wear_l_s.gameObject.SetActive(value: false);
			renderer_wear_f.gameObject.SetActive(value: false);
			for (int n = 0; n < _slotInfo.list_partId.Count; n++)
			{
				switch (_slotInfo.list_partId[n][1])
				{
				case '0':
				{
					ItemInfo itemInfo7 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[n]);
					renderer_wear_u.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo7.meshPath);
					renderer_wear_u.sharedMaterial = Resources.Load<Material>("Customize/Wears/" + itemInfo7.matPath);
					WearInfo wearInfo4 = JsonUtility.FromJson<WearInfo>((Resources.Load("ItemInfos/WearInfo_" + itemInfo7.meshPath) as TextAsset).text);
					renderer_wear_u.localBounds = new Bounds(wearInfo4.bounds_center, wearInfo4.bounds_extent * 2f);
					if (!isOptimizeGameObjects)
					{
						renderer_wear_u.rootBone = boneTrs[wearInfo4.rootBone];
						Transform[] array4 = new Transform[wearInfo4.bones.Length];
						for (int num4 = 0; num4 < wearInfo4.bones.Length; num4++)
						{
							array4[num4] = boneTrs[wearInfo4.bones[num4]];
						}
						renderer_wear_u.bones = array4;
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Upper), out var color8))
					{
						renderer_wear_u.sharedMaterial.SetColor("_BaseColor", color8);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color8))
					{
						renderer_wear_u.sharedMaterial.SetColor("_PatternColor", color8);
					}
					renderer_wear_u.sharedMaterial.SetColor("_Color_R", Color.white);
					renderer_wear_u.sharedMaterial.SetColor("_Color_G", Color.white);
					renderer_wear_u.sharedMaterial.SetColor("_Color_B", Color.white);
					renderer_wear_u.gameObject.SetActive(value: true);
					break;
				}
				case '1':
				{
					ItemInfo itemInfo6 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[n]);
					renderer_wear_u_c.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo6.meshPath);
					renderer_wear_u_c.sharedMaterial = Resources.Load<Material>("Customize/Wears/" + itemInfo6.matPath);
					WearInfo wearInfo3 = JsonUtility.FromJson<WearInfo>((Resources.Load("ItemInfos/WearInfo_" + itemInfo6.meshPath) as TextAsset).text);
					renderer_wear_u_c.localBounds = new Bounds(wearInfo3.bounds_center, wearInfo3.bounds_extent * 2f);
					if (!isOptimizeGameObjects)
					{
						renderer_wear_u_c.rootBone = boneTrs[wearInfo3.rootBone];
						Transform[] array3 = new Transform[wearInfo3.bones.Length];
						for (int num3 = 0; num3 < wearInfo3.bones.Length; num3++)
						{
							array3[num3] = boneTrs[wearInfo3.bones[num3]];
						}
						renderer_wear_u_c.bones = array3;
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Upper), out var color7))
					{
						renderer_wear_u_c.sharedMaterial.SetColor("_BaseColor", color7);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color7))
					{
						renderer_wear_u_c.sharedMaterial.SetColor("_PatternColor", color7);
					}
					renderer_wear_u_c.sharedMaterial.SetColor("_Color_R", Color.white);
					renderer_wear_u_c.sharedMaterial.SetColor("_Color_G", Color.white);
					renderer_wear_u_c.sharedMaterial.SetColor("_Color_B", Color.white);
					break;
				}
				case '2':
				{
					ItemInfo itemInfo8 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[n]);
					renderer_wear_l.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo8.meshPath);
					renderer_wear_l.sharedMaterial = Resources.Load<Material>("Customize/Wears/" + itemInfo8.matPath);
					WearInfo wearInfo5 = JsonUtility.FromJson<WearInfo>((Resources.Load("ItemInfos/WearInfo_" + itemInfo8.meshPath) as TextAsset).text);
					renderer_wear_l.localBounds = new Bounds(wearInfo5.bounds_center, wearInfo5.bounds_extent * 2f);
					if (!isOptimizeGameObjects)
					{
						renderer_wear_l.rootBone = boneTrs[wearInfo5.rootBone];
						Transform[] array5 = new Transform[wearInfo5.bones.Length];
						for (int num5 = 0; num5 < wearInfo5.bones.Length; num5++)
						{
							array5[num5] = boneTrs[wearInfo5.bones[num5]];
						}
						renderer_wear_l.bones = array5;
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Lower), out var color9))
					{
						renderer_wear_l.sharedMaterial.SetColor("_BaseColor", color9);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color9))
					{
						renderer_wear_l.sharedMaterial.SetColor("_PatternColor", color9);
					}
					renderer_wear_l.sharedMaterial.SetColor("_Color_R", Color.white);
					renderer_wear_l.sharedMaterial.SetColor("_Color_G", Color.white);
					renderer_wear_l.sharedMaterial.SetColor("_Color_B", Color.white);
					renderer_wear_l.gameObject.SetActive(value: true);
					break;
				}
				case '3':
				{
					ItemInfo itemInfo5 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[n]);
					renderer_wear_l_s.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo5.meshPath);
					renderer_wear_l_s.sharedMaterial = Resources.Load<Material>("Customize/Wears/" + itemInfo5.matPath);
					WearInfo wearInfo2 = JsonUtility.FromJson<WearInfo>((Resources.Load("ItemInfos/WearInfo_" + itemInfo5.meshPath) as TextAsset).text);
					renderer_wear_l_s.localBounds = new Bounds(wearInfo2.bounds_center, wearInfo2.bounds_extent * 2f);
					if (!isOptimizeGameObjects)
					{
						renderer_wear_l_s.rootBone = boneTrs[wearInfo2.rootBone];
						Transform[] array2 = new Transform[wearInfo2.bones.Length];
						for (int num2 = 0; num2 < wearInfo2.bones.Length; num2++)
						{
							array2[num2] = boneTrs[wearInfo2.bones[num2]];
						}
						renderer_wear_l_s.bones = array2;
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Lower), out var color6))
					{
						renderer_wear_l_s.sharedMaterial.SetColor("_BaseColor", color6);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color6))
					{
						renderer_wear_l_s.sharedMaterial.SetColor("_PatternColor", color6);
					}
					renderer_wear_l_s.sharedMaterial.SetColor("_Color_R", Color.white);
					renderer_wear_l_s.sharedMaterial.SetColor("_Color_G", Color.white);
					renderer_wear_l_s.sharedMaterial.SetColor("_Color_B", Color.white);
					renderer_wear_l_s.gameObject.SetActive(value: true);
					break;
				}
				case '4':
				{
					ItemInfo itemInfo4 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[n]);
					renderer_wear_f.sharedMesh = Resources.Load<Mesh>("Customize/Wears/" + itemInfo4.meshPath);
					renderer_wear_f.sharedMaterial = Resources.Load<Material>("Customize/Wears/" + itemInfo4.matPath);
					WearInfo wearInfo = JsonUtility.FromJson<WearInfo>((Resources.Load("ItemInfos/WearInfo_" + itemInfo4.meshPath) as TextAsset).text);
					renderer_wear_f.localBounds = new Bounds(wearInfo.bounds_center, wearInfo.bounds_extent * 2f);
					if (!isOptimizeGameObjects)
					{
						renderer_wear_f.rootBone = boneTrs[wearInfo.rootBone];
						Transform[] array = new Transform[wearInfo.bones.Length];
						for (int num = 0; num < wearInfo.bones.Length; num++)
						{
							array[num] = boneTrs[wearInfo.bones[num]];
						}
						renderer_wear_f.bones = array;
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Foot), out var color5))
					{
						renderer_wear_f.sharedMaterial.SetColor("_BaseColor", color5);
					}
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Pattern), out color5))
					{
						renderer_wear_f.sharedMaterial.SetColor("_PatternColor", color5);
					}
					renderer_wear_f.sharedMaterial.SetColor("_Color_R", Color.white);
					renderer_wear_f.sharedMaterial.SetColor("_Color_G", Color.white);
					renderer_wear_f.sharedMaterial.SetColor("_Color_B", Color.white);
					renderer_wear_f.gameObject.SetActive(value: true);
					break;
				}
				}
			}
			break;
		}
		case '4':
		{
			renderer_acc.gameObject.SetActive(value: false);
			if (_slotInfo.id != "4000")
			{
				for (int i = 0; i < _slotInfo.list_partId.Count; i++)
				{
					ItemInfo itemInfo = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemInfo(_slotInfo.list_partId[i]);
					meshFilter_acc.sharedMesh = Resources.Load<Mesh>("Customize/Accs/" + itemInfo.meshPath);
					renderer_acc.sharedMaterial = Resources.Load<Material>("Customize/Accs/" + itemInfo.matPath);
					if (ColorUtility.TryParseHtmlString("#" + SingletonBase.Singleton<CustomizeManager>.GetInstance.GetColorInfo(ColorUIPart.Acc), out var color))
					{
						renderer_acc.sharedMaterial.SetColor("_BaseColor", color);
					}
					int selectGenderNum = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
					TextAsset textAsset = ((selectGenderNum != 0) ? (Resources.Load("ItemInfos/AccInfo_F_" + _slotInfo.list_partId[i]) as TextAsset) : (Resources.Load("ItemInfos/AccInfo_M_" + _slotInfo.list_partId[i]) as TextAsset));
					AccInfo accInfo = null;
					if (textAsset != null)
					{
						accInfo = JsonUtility.FromJson<AccInfo>(textAsset.text);
					}
					if (accInfo != null)
					{
						renderer_acc.transform.localPosition = accInfo.pos;
						renderer_acc.transform.localScale = accInfo.scale;
					}
					else if (selectGenderNum == 0)
					{
						renderer_acc.transform.localPosition = Vector3.zero;
						renderer_acc.transform.localScale = Vector3.one * 1f;
					}
					else
					{
						renderer_acc.transform.localPosition = Vector3.zero;
						renderer_acc.transform.localScale = Vector3.one * 0.925f;
					}
					renderer_acc.transform.localRotation = Quaternion.identity;
					renderer_acc.gameObject.SetActive(value: true);
				}
				if (_slotInfo.list_partId[0][1] == '0')
				{
					renderer_head.enabled = false;
					meshFilter_hair_f.gameObject.SetActive(value: false);
					meshFilter_hair_b.gameObject.SetActive(value: false);
					break;
				}
				if (_slotInfo.list_partId[0][1] == '1')
				{
					renderer_head.enabled = true;
					meshFilter_hair_f.gameObject.SetActive(value: false);
					meshFilter_hair_b.gameObject.SetActive(value: false);
					break;
				}
				renderer_head.enabled = true;
				int selectGenderNum2 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
				ItemSlotInfo itemSlotInfo = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(selectGenderNum2, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum2].ID_Hair_I);
				for (int j = 0; j < itemSlotInfo.list_partId.Count; j++)
				{
					if (itemSlotInfo.list_partId[j][1] == '0')
					{
						meshFilter_hair_f.gameObject.SetActive(value: true);
					}
					else if (itemSlotInfo.list_partId[j][1] == '1')
					{
						meshFilter_hair_b.gameObject.SetActive(value: true);
					}
				}
				break;
			}
			renderer_head.enabled = true;
			int selectGenderNum3 = SingletonBase.Singleton<CustomizeManager>.GetInstance.selectGenderNum;
			ItemSlotInfo itemSlotInfo2 = SingletonBase.Singleton<CustomizeDataInfo>.GetInstance.GetItemSlotInfo(selectGenderNum3, SingletonBase.Singleton<CustomizeManager>.GetInstance.modelData.modelDatas[selectGenderNum3].ID_Hair_I);
			for (int k = 0; k < itemSlotInfo2.list_partId.Count; k++)
			{
				if (itemSlotInfo2.list_partId[k][1] == '0')
				{
					meshFilter_hair_f.gameObject.SetActive(value: true);
				}
				else if (itemSlotInfo2.list_partId[k][1] == '1')
				{
					meshFilter_hair_b.gameObject.SetActive(value: true);
				}
			}
			break;
		}
		}
		base.gameObject.SetActive(value: false);
		base.gameObject.SetActive(value: true);
		anim.Update(1f);
	}

	public void SetColor(ColorUIPart part, string setHexColor)
	{
		if (!ColorUtility.TryParseHtmlString("#" + setHexColor, out var color))
		{
			return;
		}
		SingletonBase.Singleton<CustomizeManager>.GetInstance.SetColorInfo(part, setHexColor);
		switch (part)
		{
		case ColorUIPart.Skin:
			renderer_head.sharedMaterial.SetColor("_BaseColor", color);
			mat_body.SetColor("_BaseColor", color);
			break;
		case ColorUIPart.Eye:
			renderer_head.sharedMaterial.SetColor("_EyeColor", color);
			break;
		case ColorUIPart.Eyebrow:
			renderer_head.sharedMaterial.SetColor("_EyebrowColor", color);
			break;
		case ColorUIPart.Hair:
			if (renderer_hair_f.sharedMaterial != null)
			{
				renderer_hair_f.sharedMaterial.SetColor("_BaseColor", color);
			}
			if (renderer_hair_b.sharedMaterial != null)
			{
				renderer_hair_b.sharedMaterial.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Upper:
			if (renderer_wear_u.sharedMaterial != null)
			{
				renderer_wear_u.sharedMaterial.SetColor("_BaseColor", color);
			}
			if (renderer_wear_u_c.sharedMaterial != null)
			{
				renderer_wear_u_c.sharedMaterial.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Lower:
			if (renderer_wear_l.sharedMaterial != null)
			{
				renderer_wear_l.sharedMaterial.SetColor("_BaseColor", color);
			}
			if (renderer_wear_l_s.sharedMaterial != null)
			{
				renderer_wear_l_s.sharedMaterial.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Foot:
			if (renderer_wear_f.sharedMaterial != null)
			{
				renderer_wear_f.sharedMaterial.SetColor("_BaseColor", color);
			}
			break;
		case ColorUIPart.Pattern:
			if (renderer_wear_u.sharedMaterial != null)
			{
				renderer_wear_u.sharedMaterial.SetColor("_PatternColor", color);
			}
			if (renderer_wear_u_c.sharedMaterial != null)
			{
				renderer_wear_u_c.sharedMaterial.SetColor("_PatternColor", color);
			}
			if (renderer_wear_l.sharedMaterial != null)
			{
				renderer_wear_l.sharedMaterial.SetColor("_PatternColor", color);
			}
			if (renderer_wear_l_s.sharedMaterial != null)
			{
				renderer_wear_l_s.sharedMaterial.SetColor("_PatternColor", color);
			}
			if (renderer_wear_f.sharedMaterial != null)
			{
				renderer_wear_f.sharedMaterial.SetColor("_PatternColor", color);
			}
			break;
		case ColorUIPart.Acc:
			renderer_acc.sharedMaterial.SetColor("_BaseColor", color);
			break;
		}
		SingletonBase.Singleton<CustomizeManager>.GetInstance.SetColor_Others(part, setHexColor);
	}
}
public class PhotonVoicePrefCtrl : MonoBehaviour
{
	private static PhotonVoicePrefCtrl instance;

	private void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}
}
public class PostProcessFadeCtrl : SingletonBase.Singleton<PostProcessFadeCtrl>
{
	public enum FadeState
	{
		Normal,
		LoadScene
	}

	private ColorAdjustments color;

	private FadeState fadeState;

	private bool isFadeIn;

	private float fadeSpeed;

	private int sceneIndex;

	private string sceneName;

	private Coroutine cor_fade;

	protected override void Awake()
	{
		base.Awake();
		base.transform.GetComponent<Volume>().sharedProfile.TryGet<ColorAdjustments>(out color);
		color.colorFilter.value = Color.black;
	}

	public void StartFade(bool _isFadeIn, float _fadeSpeed = 0.75f)
	{
		if (cor_fade != null)
		{
			StopCoroutine(cor_fade);
		}
		fadeState = FadeState.Normal;
		isFadeIn = _isFadeIn;
		fadeSpeed = _fadeSpeed;
		cor_fade = StartCoroutine(FadeCoroutine());
	}

	public void LoadScene(int _sceneIndex, float _fadeSpeed = 0.75f)
	{
		if (cor_fade != null)
		{
			StopCoroutine(cor_fade);
		}
		fadeState = FadeState.LoadScene;
		isFadeIn = false;
		sceneIndex = _sceneIndex;
		fadeSpeed = _fadeSpeed;
		cor_fade = StartCoroutine(FadeCoroutine());
	}

	public void LoadScene(string _sceneName, float _fadeSpeed = 0.75f)
	{
		if (cor_fade != null)
		{
			StopCoroutine(cor_fade);
		}
		fadeState = FadeState.LoadScene;
		isFadeIn = false;
		sceneIndex = -1;
		sceneName = _sceneName;
		fadeSpeed = _fadeSpeed;
		if (SceneManager.GetActiveScene().name == "Scene_Lobby")
		{
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.gameSetting.SaveData();
		}
		cor_fade = StartCoroutine(FadeCoroutine());
	}

	private IEnumerator FadeCoroutine()
	{
		float velueP = 0f;
		if (isFadeIn)
		{
			color.colorFilter.value = Color.black;
			yield return new WaitForSeconds(0.3f);
			while (true)
			{
				velueP = Mathf.Clamp01(velueP + Time.deltaTime * fadeSpeed);
				color.colorFilter.value = Color.Lerp(Color.black, Color.white, velueP);
				if (velueP != 1f)
				{
					yield return null;
					continue;
				}
				break;
			}
			yield break;
		}
		while (true)
		{
			velueP = Mathf.Clamp01(velueP + Time.deltaTime * fadeSpeed);
			color.colorFilter.value = Color.Lerp(Color.white, Color.black, velueP);
			if (velueP == 1f)
			{
				break;
			}
			yield return null;
		}
		if (fadeState == FadeState.LoadScene)
		{
			if (sceneIndex == -1)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					PhotonNetwork.LoadLevel(sceneName);
				}
				else
				{
					SceneManager.LoadScene(sceneName);
				}
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel(sceneIndex);
			}
			else
			{
				SceneManager.LoadScene(sceneIndex);
			}
		}
		else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
		{
			yield return new WaitForSeconds(5f);
			color.colorFilter.value = Color.white;
			SingletonBase.Singleton<LobbyPropManager>.GetInstance.isStartGame = false;
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.OpenStartPage();
		}
	}
}
public class ProfileCaptureCtrl : MonoBehaviour
{
	public enum ShotState
	{
		Multi,
		Profile
	}

	private ShotState shotState;

	private int index_win;

	public CustomModelSettingCtrl[] customModels;

	public Transform[] customModels_center;

	public Transform[] customModels_hand;

	public Animator[] anims_customModel;

	private Camera cam;

	public Light[] lights;

	private GameObject parentGO;

	private RenderTexture[] renderTextures_single = new RenderTexture[5];

	private RenderTexture[] renderTextures_multi = new RenderTexture[2];

	private RenderTexture[] renderTextures_profile = new RenderTexture[2];

	private SpriteRenderer sprite_backGround;

	public Sprite[] sprites_backGround;

	public Transform[] propTrs;

	public MeshRenderer renderer_cam_view;

	private Coroutine shotImagesCoroutine;

	private void Awake()
	{
		renderTextures_multi = new RenderTexture[2];
		renderTextures_profile = new RenderTexture[2];
		for (int i = 0; i < renderTextures_single.Length; i++)
		{
			renderTextures_single[i] = Resources.Load<RenderTexture>("UI/RenderTexture_Single0" + (i + 1));
		}
		for (int j = 0; j < renderTextures_multi.Length; j++)
		{
			renderTextures_multi[j] = Resources.Load<RenderTexture>("UI/RenderTexture_Multi0" + (j + 1));
		}
		for (int k = 0; k < renderTextures_profile.Length; k++)
		{
			renderTextures_profile[k] = Resources.Load<RenderTexture>("UI/RenderTexture_Profile0" + (k + 1));
		}
		cam = base.transform.GetComponentInChildren<Camera>();
		int num = 31;
		cam.cullingMask = 1 << num;
		Transform[] componentsInChildren = base.transform.GetComponentsInChildren<Transform>();
		for (int l = 0; l < componentsInChildren.Length; l++)
		{
			if (!(componentsInChildren[l].name == "Post-process Volume"))
			{
				componentsInChildren[l].gameObject.layer = num;
			}
		}
		sprite_backGround = cam.transform.Find("BackGround").GetComponent<SpriteRenderer>();
		parentGO = base.transform.GetChild(0).gameObject;
		parentGO.SetActive(value: false);
	}

	public void ShotSingleImages()
	{
		sprite_backGround.enabled = false;
		Light[] array = Light.GetLights(LightType.Directional, 0);
		lights[0].gameObject.SetActive(value: true);
		lights[1].gameObject.SetActive(value: true);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == lights[0])
			{
				array[i] = null;
			}
			else if (array[i].enabled)
			{
				array[i].enabled = false;
			}
			else
			{
				array[i] = null;
			}
		}
		parentGO.SetActive(value: true);
		renderer_cam_view.enabled = false;
		cam.fieldOfView = 50f;
		RenderTexture active = RenderTexture.active;
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single = new CustomModelData[renderTextures_single.Length];
		customModels[0].gameObject.SetActive(value: true);
		customModels[1].gameObject.SetActive(value: false);
		customModels[0].transform.localPosition = Vector3.zero;
		cam.transform.localRotation = Quaternion.Euler(0f, 15f, 0f);
		for (int j = 0; j < propTrs.Length; j++)
		{
			propTrs[j].gameObject.SetActive(value: false);
		}
		Animator[] array2 = null;
		for (int k = 0; k < SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single.Length; k++)
		{
			customModels[0].enabled = true;
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k] = CustomModelSettingCtrl.GetRandomModelData();
			customModels[0].Init(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k], CustomModelViewState.Normal, null, 0.3f);
			customModels[0].gameObject.SetActive(value: false);
			customModels[0].gameObject.SetActive(value: true);
			string stateName = "";
			switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType)
			{
			case GameData_DDOL.GameType.Bowling:
				stateName = ((!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k].Gender == "m")) ? "Bowling_F" : "Bowling");
				propTrs[0].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[0].GetComponent<Animator>() };
				break;
			case GameData_DDOL.GameType.Archery:
				stateName = ((!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k].Gender == "m")) ? "Archery_F" : "Archery");
				propTrs[1].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[1].GetComponent<Animator>() };
				break;
			case GameData_DDOL.GameType.Basketball:
				stateName = ((!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k].Gender == "m")) ? "Basketball_F" : "Basketball");
				propTrs[2].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[2].GetComponent<Animator>() };
				break;
			case GameData_DDOL.GameType.Badminton:
				stateName = "Badminton";
				propTrs[3].gameObject.SetActive(value: true);
				propTrs[4].gameObject.SetActive(value: true);
				array2 = new Animator[2]
				{
					propTrs[3].GetComponent<Animator>(),
					propTrs[4].GetComponent<Animator>()
				};
				break;
			case GameData_DDOL.GameType.Billiards:
				stateName = ((!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k].Gender == "m")) ? "Billiard_F" : "Billiard");
				propTrs[5].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[5].GetComponent<Animator>() };
				break;
			case GameData_DDOL.GameType.Darts:
				stateName = ((!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k].Gender == "m")) ? "Darts_F" : "Darts");
				propTrs[6].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[6].GetComponent<Animator>() };
				break;
			case GameData_DDOL.GameType.TableTennis:
				stateName = "TableTennis";
				propTrs[7].gameObject.SetActive(value: true);
				break;
			case GameData_DDOL.GameType.Boxing:
				stateName = "Boxing";
				propTrs[8].gameObject.SetActive(value: true);
				break;
			case GameData_DDOL.GameType.Golf:
				stateName = ((!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[k].Gender == "m")) ? "Golf_F" : "Golf");
				propTrs[9].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[9].GetComponent<Animator>() };
				break;
			case GameData_DDOL.GameType.Baseball:
				stateName = "Baseball";
				propTrs[10].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[10].GetComponent<Animator>() };
				break;
			case GameData_DDOL.GameType.Tennis:
				stateName = "Tennis";
				propTrs[11].gameObject.SetActive(value: true);
				propTrs[12].gameObject.SetActive(value: true);
				array2 = new Animator[1] { propTrs[12].GetComponent<Animator>() };
				break;
			}
			float normalizedTime = 0f;
			switch (k)
			{
			case 1:
				normalizedTime = 0.25f;
				break;
			case 2:
				normalizedTime = 0.5f;
				break;
			case 3:
				normalizedTime = 0.75f;
				break;
			case 4:
				normalizedTime = 1f;
				break;
			}
			anims_customModel[0].Play(stateName, -1, normalizedTime);
			anims_customModel[0].Update(1f);
			if (array2 != null)
			{
				for (int l = 0; l < array2.Length; l++)
				{
					array2[l].Play(stateName, -1, normalizedTime);
					array2[l].Update(1f);
				}
			}
			Vector3 position = customModels_hand[0].position;
			position += customModels_hand[1].position;
			position *= 0.5f;
			cam.transform.position = customModels_center[0].position + new Vector3(-0.45f, 0.1f, -1.8f);
			position = Vector3.Lerp(customModels_center[0].position, position, 0.3f);
			position.y = customModels_center[0].position.y;
			cam.transform.position = position + new Vector3(-0.45f, 0.1f, -1.8f);
			cam.targetTexture = renderTextures_single[k];
			RenderTexture.active = renderTextures_single[k];
			cam.Render();
		}
		cam.targetTexture = null;
		RenderTexture.active = active;
		renderer_cam_view.enabled = true;
		parentGO.SetActive(value: false);
		for (int m = 0; m < array.Length; m++)
		{
			if (array[m] != null)
			{
				array[m].enabled = true;
			}
		}
	}

	public void ShotImages(string[] user_id, ShotState _shotState)
	{
		if (shotImagesCoroutine != null)
		{
			StopCoroutine(shotImagesCoroutine);
		}
		shotState = _shotState;
		shotImagesCoroutine = StartCoroutine(ShotImagesCoroutine(user_id));
	}

	private IEnumerator ShotImagesCoroutine(string[] user_id)
	{
		sprite_backGround.enabled = true;
		bool[] isOk = new bool[user_id.Length];
		cam.fieldOfView = 20f;
		for (int i = 0; i < user_id.Length; i++)
		{
			if (user_id[i] == "AI")
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[i] = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level);
			}
			isOk[i] = false;
		}
		while (true)
		{
			for (int j = 0; j < isOk.Length; j++)
			{
				if (isOk[j] || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[j] == null)
				{
					continue;
				}
				SetBackGroundColor(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[j].Hex_Hair_C);
				Light[] array = Light.GetLights(LightType.Directional, 31);
				for (int k = 0; k < array.Length; k++)
				{
					if (array[k] == lights[0])
					{
						array[k] = null;
					}
					else if (array[k].enabled)
					{
						array[k].enabled = false;
					}
					else
					{
						array[k] = null;
					}
				}
				parentGO.SetActive(value: true);
				if (j == 0)
				{
					cam.transform.localPosition = new Vector3(-0.32f, 1.37f, -2.5f);
					cam.transform.localRotation = Quaternion.Euler(0f, 7.5f, 0f);
				}
				else
				{
					cam.transform.localPosition = new Vector3(0.32f, 1.37f, -2.5f);
					cam.transform.localRotation = Quaternion.Euler(0f, -7.5f, 0f);
				}
				RenderTexture active = RenderTexture.active;
				customModels[0].enabled = true;
				customModels[0].Init(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[j]);
				customModels[0].gameObject.SetActive(value: false);
				customModels[0].gameObject.SetActive(value: true);
				customModels[0].GetComponent<Animator>().Update(1f);
				if (shotState == ShotState.Multi)
				{
					cam.targetTexture = renderTextures_multi[j];
					RenderTexture.active = renderTextures_multi[j];
				}
				else
				{
					cam.targetTexture = renderTextures_profile[j];
					RenderTexture.active = renderTextures_profile[j];
				}
				cam.Render();
				RenderTexture.active = active;
				cam.targetTexture = null;
				isOk[j] = true;
				parentGO.SetActive(value: false);
				for (int l = 0; l < array.Length; l++)
				{
					if (array[l] != null)
					{
						array[l].enabled = true;
					}
				}
			}
			if (!isOk.Contains(value: false))
			{
				break;
			}
			yield return null;
		}
	}

	public void PlayImages(string[] user_id, ShotState _shotState, int _index_win = 0)
	{
		if (shotImagesCoroutine != null)
		{
			StopCoroutine(shotImagesCoroutine);
		}
		shotState = _shotState;
		index_win = _index_win;
		shotImagesCoroutine = StartCoroutine(PlayImagesCoroutine(user_id));
	}

	public void StopImages()
	{
		if (shotImagesCoroutine != null)
		{
			StopCoroutine(shotImagesCoroutine);
		}
		parentGO.SetActive(value: false);
	}

	private IEnumerator PlayImagesCoroutine(string[] user_id)
	{
		sprite_backGround.enabled = false;
		bool[] isOk = new bool[user_id.Length];
		Vector3[] poss = new Vector3[user_id.Length];
		cam.fieldOfView = 40f;
		cam.backgroundColor = Color.clear;
		sprite_backGround.transform.localPosition = new Vector3(0f, 0f, 2.8f);
		for (int i = 0; i < propTrs.Length; i++)
		{
			propTrs[i].gameObject.SetActive(value: false);
		}
		customModels[0].gameObject.SetActive(value: false);
		customModels[1].gameObject.SetActive(value: false);
		if (shotState == ShotState.Multi)
		{
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = renderTextures_multi[0];
			GL.Clear(clearDepth: true, clearColor: true, Color.clear);
			RenderTexture.active = renderTextures_multi[1];
			GL.Clear(clearDepth: true, clearColor: true, Color.clear);
			RenderTexture.active = active;
		}
		else
		{
			RenderTexture active2 = RenderTexture.active;
			RenderTexture.active = renderTextures_profile[0];
			GL.Clear(clearDepth: true, clearColor: true, Color.clear);
			RenderTexture.active = renderTextures_profile[1];
			GL.Clear(clearDepth: true, clearColor: true, Color.clear);
			RenderTexture.active = active2;
		}
		for (int j = 0; j < user_id.Length; j++)
		{
			if (user_id[j] == "AI")
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[j] = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level);
			}
			isOk[j] = false;
		}
		yield return new WaitForSecondsRealtime(0.5f);
		parentGO.SetActive(value: true);
		sprite_backGround.color = Color.white;
		sprite_backGround.sprite = sprites_backGround[2];
		while (true)
		{
			Light[] array = Light.GetLights(LightType.Directional, 0);
			for (int k = 0; k < array.Length; k++)
			{
				if (array[k] == lights[0])
				{
					array[k] = null;
				}
				else if (array[k].enabled)
				{
					array[k].enabled = false;
				}
				else
				{
					array[k] = null;
				}
			}
			lights[0].gameObject.SetActive(value: true);
			lights[1].gameObject.SetActive(value: true);
			renderer_cam_view.enabled = false;
			RenderTexture active3 = RenderTexture.active;
			for (int l = 0; l < isOk.Length; l++)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[l] == null)
				{
					continue;
				}
				if (!isOk[l])
				{
					isOk[l] = true;
					customModels[l].gameObject.SetActive(value: true);
					customModels[l].enabled = true;
					customModels[l].Init(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[l], CustomModelViewState.Normal, null, 0.3f);
					string stateName;
					if (shotState == ShotState.Multi)
					{
						stateName = ((!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[l].Gender == "m")) ? "Wait_Pose_F" : "Wait_Pose");
					}
					else
					{
						stateName = ((l == 0) ? ((index_win == 0) ? "Result_Win" : ((index_win != 1) ? "Result_Draw" : "Result_Lose")) : ((index_win == 1) ? "Result_Win" : ((index_win != 0) ? "Result_Draw" : "Result_Lose")));
						cam.transform.localRotation = Quaternion.identity;
					}
					anims_customModel[l].Play(stateName, -1, 0f);
					customModels[l].transform.localPosition = Vector3.zero;
					poss[l] = customModels_center[l].position + new Vector3(0f, 0.1f, -4f);
				}
				customModels[l].transform.localPosition = Vector3.zero;
				if (shotState == ShotState.Multi)
				{
					if (l == 0)
					{
						poss[l] = Vector3.Lerp(poss[l], customModels_center[l].position + new Vector3(-0.35f, 0.15f, -1.3f), Time.unscaledDeltaTime * 5f);
						cam.transform.position = poss[l];
						cam.transform.localRotation = Quaternion.Euler(0f, 20f, 0f);
					}
					else
					{
						poss[l] = Vector3.Lerp(poss[l], customModels_center[l].position + new Vector3(0.35f, 0.15f, -1.3f), Time.unscaledDeltaTime * 5f);
						cam.transform.position = poss[l];
						cam.transform.localRotation = Quaternion.Euler(0f, -20f, 0f);
					}
					cam.targetTexture = renderTextures_multi[l];
					RenderTexture.active = renderTextures_multi[l];
					cam.Render();
				}
				else
				{
					if (l == 0)
					{
						poss[l] = Vector3.Lerp(poss[l], customModels_center[l].position + new Vector3(0f, 0.1f, -1.5f), Time.unscaledDeltaTime * 5f);
						cam.transform.position = poss[l];
						PublicGameUIManager.GetInstance.SyncProfileLight(anims_customModel[l].GetCurrentAnimatorStateInfo(0).normalizedTime);
						if (index_win == 0)
						{
							sprite_backGround.sprite = sprites_backGround[0];
						}
						else if (index_win == 1)
						{
							sprite_backGround.sprite = sprites_backGround[1];
						}
						else
						{
							sprite_backGround.sprite = sprites_backGround[2];
						}
					}
					else
					{
						poss[l] = Vector3.Lerp(poss[l], customModels_center[l].position + new Vector3(0f, 0.05f, -1.5f), Time.unscaledDeltaTime * 5f);
						cam.transform.position = poss[l];
						if (index_win == 1)
						{
							sprite_backGround.sprite = sprites_backGround[0];
						}
						else if (index_win == 0)
						{
							sprite_backGround.sprite = sprites_backGround[1];
						}
						else
						{
							sprite_backGround.sprite = sprites_backGround[2];
						}
					}
					sprite_backGround.enabled = true;
					cam.targetTexture = renderTextures_profile[l];
					RenderTexture.active = renderTextures_profile[l];
					cam.Render();
					sprite_backGround.enabled = false;
				}
				customModels[l].transform.localPosition = new Vector3(0f, -100f, 0f);
			}
			RenderTexture.active = active3;
			cam.targetTexture = null;
			renderer_cam_view.enabled = true;
			lights[0].gameObject.SetActive(value: false);
			lights[1].gameObject.SetActive(value: false);
			for (int m = 0; m < array.Length; m++)
			{
				if (array[m] != null)
				{
					array[m].enabled = true;
				}
			}
			yield return null;
		}
	}

	private void SetBackGroundColor(string hexColor_origin)
	{
		if (ColorUtility.TryParseHtmlString("#" + hexColor_origin, out var color))
		{
			Color.RGBToHSV(color, out var H, out var S, out var _);
			H = (H + 0.5f) % 1f;
			sprite_backGround.color = Color.HSVToRGB(H, S, 1f);
		}
		else
		{
			sprite_backGround.color = Color.white;
		}
	}

	public void ShotImages_Baseball()
	{
		sprite_backGround.enabled = false;
		Light[] array = Light.GetLights(LightType.Directional, 0);
		lights[0].gameObject.SetActive(value: true);
		lights[1].gameObject.SetActive(value: true);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == lights[0])
			{
				array[i] = null;
			}
			else if (array[i].enabled)
			{
				array[i].enabled = false;
			}
			else
			{
				array[i] = null;
			}
		}
		parentGO.SetActive(value: true);
		cam.fieldOfView = 50f;
		RenderTexture active = RenderTexture.active;
		customModels[0].gameObject.SetActive(value: true);
		customModels[1].gameObject.SetActive(value: false);
		customModels[0].transform.localPosition = Vector3.zero;
		cam.transform.localRotation = Quaternion.Euler(0f, 15f, 0f);
		for (int j = 0; j < propTrs.Length; j++)
		{
			propTrs[j].gameObject.SetActive(value: false);
		}
		Animator[] array2 = null;
		List<int> list = new List<int>();
		for (int k = 0; k < 5; k++)
		{
			list.Add(k);
		}
		for (int l = 0; l < 2; l++)
		{
			customModels[0].enabled = true;
			customModels[0].Init(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(l), CustomModelViewState.Normal, null, 0.3f);
			customModels[0].gameObject.SetActive(value: false);
			customModels[0].gameObject.SetActive(value: true);
			string text = "";
			text = "Baseball";
			propTrs[10].gameObject.SetActive(value: true);
			array2 = new Animator[1] { propTrs[10].GetComponent<Animator>() };
			int num = list[(int)UnityEngine.Random.Range(0f, (float)list.Count - 0.0001f)];
			list.Remove(num);
			float normalizedTime = 0f;
			switch (num)
			{
			case 1:
				normalizedTime = 0.25f;
				break;
			case 2:
				normalizedTime = 0.5f;
				break;
			case 3:
				normalizedTime = 0.75f;
				break;
			case 4:
				normalizedTime = 1f;
				break;
			}
			anims_customModel[0].Play(text, -1, normalizedTime);
			anims_customModel[0].Update(1f);
			if (array2 != null)
			{
				for (int m = 0; m < array2.Length; m++)
				{
					array2[m].Play(text, -1, normalizedTime);
					array2[m].Update(1f);
				}
			}
			Vector3 position = customModels_hand[0].position;
			position += customModels_hand[1].position;
			position *= 0.5f;
			cam.transform.position = customModels_center[0].position + new Vector3(-0.45f, 0.1f, -1.8f);
			position = Vector3.Lerp(customModels_center[0].position, position, 0.3f);
			position.y = customModels_center[0].position.y;
			cam.transform.position = position + new Vector3(-0.45f, 0.1f, -1.8f);
			cam.targetTexture = renderTextures_single[l];
			RenderTexture.active = renderTextures_single[l];
			cam.Render();
		}
		cam.targetTexture = null;
		RenderTexture.active = active;
		parentGO.SetActive(value: false);
		for (int n = 0; n < array.Length; n++)
		{
			if (array[n] != null)
			{
				array[n].enabled = true;
			}
		}
	}
}
public class PublicGameUIManager : MonoBehaviour
{
	public enum ViewState
	{
		None,
		Menu,
		Result,
		Wait,
		Match,
		Setting
	}

	public class UserInfo
	{
		public Text text_nick_result;

		public Text text_score;

		public Text text_nick_match;

		public Text text_info_match;
	}

	private static PublicGameUIManager Instance;

	public static RenderOriginCamCtrl renderOriginCam;

	public static LeaderBoardCtrl leaderBoard;

	public static GameSettingCtrl gameSetting;

	public static ProfileCaptureCtrl profileCapture;

	private bool isInteractable;

	private ViewState viewState;

	private ViewState viewState_keep;

	private bool isViewCenter;

	private bool isOverlay;

	private Camera camera_main;

	private UnityEngine.XR.Interaction.Toolkit.XRController[] controllers_main = new UnityEngine.XR.Interaction.Toolkit.XRController[2];

	private Camera camera_overlay;

	private UnityEngine.XR.Interaction.Toolkit.XRController[] controllers_overlay = new UnityEngine.XR.Interaction.Toolkit.XRController[2];

	private MeshButtonCtrl[] buttons_menu;

	private MeshButtonCtrl[] buttons_result;

	private Transform windowTr_menu;

	private Animator anim_result;

	private Transform windowTr_wait;

	private Transform windowTr_match;

	private MeshRenderer renderer_grid;

	private MeshRenderer renderer_arrow;

	private GameObject grid_clone;

	private float gridSize = 2f;

	private float distP_min;

	private float distP_max;

	private float distP_pause;

	private Vector3 targetPos;

	private Quaternion targetRot;

	private UserInfo[] userInfos;

	private GameObject typeA;

	private GameObject typeB;

	private GameObject typeC;

	private Text text_info_A;

	private Text text_info_C;

	private Text text_userName_B;

	private Text text_mainScore_B;

	private GameObject mainScoreTitle_B;

	private GameObject[] subScore_images_B;

	private Text[] text_result_infos_B;

	private Text text_userName_C;

	private Text text_mainScore_C;

	private GameObject mainScoreTitle_C;

	private GameObject[] subScore_images_C;

	private Text[] text_result_infos_C;

	private Text text_wait_info;

	private Text text_wait_time;

	private GameObject button_wait;

	private Image image_medal;

	private Sprite[] sprites_medal;

	private GameObject eff_win_f;

	private GameObject eff_win_b;

	private Animator eff_win_light;

	private Image[] resultTexts;

	private Text text_matchTime;

	public Sprite[] sprite_resultText_eng;

	public Sprite[] sprite_resultText_cn;

	private bool lastButtonState;

	private List<InputDevice> devicesWithPrimaryButton;

	public LobbyHandInfo[] handInfos = new LobbyHandInfo[2];

	private TriggerButtonInfo[] triggerButtons;

	public LayerMask layerMask;

	public AudioClip[] audios_effect;

	public AudioClip[] audios_voice;

	public AudioClip[] audios_voice_cn;

	private AudioSource audioSource_effect;

	private AudioSource audioSource_voice;

	private bool isResultUpload;

	private bool isSetFirst = true;

	public StaticLocalizationCtrl.DataSlot[] dataSlots_localization;

	public bool isFocus = true;

	public Recorder recorder;

	private bool isDisCheck;

	public XRRayInteractor[] xRRayInteractors;

	public EventSystem eventSystem;

	private Coroutine checkDisconnect;

	private Coroutine waitUICoroutine;

	private Coroutine delayActiveCoroutine;

	private Coroutine endResultCoroutine;

	private List<Renderer> keep_object = new List<Renderer>();

	private bool isPause;

	private float saveTimeScale = 1f;

	public static PublicGameUIManager GetInstance
	{
		get
		{
			if (Instance == null)
			{
				return UnityEngine.Object.Instantiate(Resources.Load<Transform>("UI/PublicGameUIManager")).GetComponent<PublicGameUIManager>();
			}
			return Instance;
		}
	}

	private event Action action_lobby;

	private event Action action_replay;

	private event Action<bool> action_menu;

	private event Action action_disconnect;

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		recorder = PhotonVoiceNetwork.Instance.transform.GetComponent<Recorder>();
		recorder.IsRecording = true;
		devicesWithPrimaryButton = new List<InputDevice>();
		triggerButtons = new TriggerButtonInfo[2];
		audioSource_effect = base.gameObject.AddComponent<AudioSource>();
		audioSource_effect.loop = false;
		audioSource_effect.volume = 1f;
		audioSource_effect.playOnAwake = false;
		audioSource_voice = base.gameObject.AddComponent<AudioSource>();
		audioSource_voice.loop = false;
		audioSource_voice.volume = 1f;
		audioSource_voice.playOnAwake = false;
		camera_main = Camera.main;
		controllers_main = camera_main.transform.parent.GetComponentsInChildren<UnityEngine.XR.Interaction.Toolkit.XRController>();
		camera_overlay = base.transform.GetComponentInChildren<Camera>();
		controllers_overlay = camera_overlay.transform.parent.GetComponentsInChildren<UnityEngine.XR.Interaction.Toolkit.XRController>();
		if (controllers_overlay != null)
		{
			for (int i = 0; i < controllers_overlay.Length; i++)
			{
				controllers_overlay[i].enableInputActions = false;
			}
		}
		renderOriginCam = base.transform.GetComponentInChildren<RenderOriginCamCtrl>();
		renderOriginCam.Init(camera_main.transform, camera_overlay.transform);
		windowTr_menu = base.transform.Find("Window_Menu");
		anim_result = base.transform.Find("Window_Result").GetComponent<Animator>();
		windowTr_wait = base.transform.Find("Window_Wait");
		windowTr_match = base.transform.Find("Window_Match");
		renderer_grid = base.transform.Find("Static/Grid").GetComponent<MeshRenderer>();
		renderer_arrow = base.transform.Find("Static/Arrow").GetComponent<MeshRenderer>();
		buttons_menu = new MeshButtonCtrl[3];
		buttons_menu[0] = windowTr_menu.Find("Button_Play").GetComponent<MeshButtonCtrl>();
		buttons_menu[1] = windowTr_menu.Find("Button_Lobby").GetComponent<MeshButtonCtrl>();
		buttons_menu[2] = windowTr_menu.Find("Button_Exit").GetComponent<MeshButtonCtrl>();
		buttons_result = new MeshButtonCtrl[3];
		buttons_result[0] = anim_result.transform.Find("Button_Restart").GetComponent<MeshButtonCtrl>();
		buttons_result[1] = anim_result.transform.Find("Button_Next").GetComponent<MeshButtonCtrl>();
		buttons_result[2] = anim_result.transform.Find("Button_Lobby").GetComponent<MeshButtonCtrl>();
		leaderBoard = base.transform.GetComponentInChildren<LeaderBoardCtrl>(includeInactive: true);
		gameSetting = base.transform.GetComponentInChildren<GameSettingCtrl>(includeInactive: true);
		audioSource_effect.outputAudioMixerGroup = gameSetting.GetAudioMixerGroup("Effect");
		audioSource_voice.outputAudioMixerGroup = gameSetting.GetAudioMixerGroup("Effect");
		profileCapture = base.transform.GetComponentInChildren<ProfileCaptureCtrl>(includeInactive: true);
		image_medal = anim_result.transform.Find("Canvas/Image_Medal").GetComponent<Image>();
		sprites_medal = new Sprite[3];
		sprites_medal[0] = Resources.Load<Sprite>("UI/Image_Medal_Gold");
		sprites_medal[1] = Resources.Load<Sprite>("UI/Image_Medal_Silver");
		sprites_medal[2] = Resources.Load<Sprite>("UI/Image_Medal_Bronze");
		typeA = anim_result.transform.Find("Canvas/TypeA").gameObject;
		typeB = anim_result.transform.Find("Canvas/TypeB").gameObject;
		typeC = anim_result.transform.Find("Canvas/TypeC").gameObject;
		userInfos = new UserInfo[2];
		Transform transform = null;
		for (int j = 0; j < userInfos.Length; j++)
		{
			userInfos[j] = new UserInfo();
			transform = ((j != 0) ? windowTr_match.Find("Canvas/P2") : windowTr_match.Find("Canvas/P1"));
			userInfos[j].text_nick_match = transform.Find("Text_Nick").GetComponent<Text>();
			userInfos[j].text_info_match = transform.Find("Text_Info").GetComponent<Text>();
			transform = ((j != 0) ? typeA.transform.Find("User02") : typeA.transform.Find("User01"));
			userInfos[j].text_nick_result = transform.Find("Text_Nick").GetComponent<Text>();
			userInfos[j].text_score = transform.Find("Text_Score").GetComponent<Text>();
		}
		text_wait_info = windowTr_wait.Find("Canvas/Text_Info").GetComponent<Text>();
		text_wait_time = windowTr_wait.Find("Canvas/Text_Time").GetComponent<Text>();
		button_wait = windowTr_wait.Find("Button_Lobby").gameObject;
		text_userName_B = typeB.transform.Find("User/Text_Nick").GetComponent<Text>();
		text_mainScore_B = typeB.transform.Find("Text_MainScore").GetComponent<Text>();
		mainScoreTitle_B = typeB.transform.Find("Text_MainScore_T").gameObject;
		transform = typeB.transform.Find("SubScores/Images");
		subScore_images_B = new GameObject[transform.childCount];
		for (int k = 0; k < subScore_images_B.Length; k++)
		{
			subScore_images_B[k] = transform.GetChild(k).gameObject;
		}
		transform = typeB.transform.Find("SubScores/Texts");
		text_result_infos_B = new Text[transform.childCount];
		for (int l = 0; l < text_result_infos_B.Length; l++)
		{
			text_result_infos_B[l] = transform.GetChild(l).GetComponent<Text>();
		}
		text_userName_C = typeC.transform.Find("User/Text_Nick").GetComponent<Text>();
		text_mainScore_C = typeC.transform.Find("Text_MainScore").GetComponent<Text>();
		mainScoreTitle_C = typeC.transform.Find("Text_MainScore_T").gameObject;
		transform = typeC.transform.Find("SubScores/Images");
		subScore_images_C = new GameObject[transform.childCount];
		for (int m = 0; m < subScore_images_C.Length; m++)
		{
			subScore_images_C[m] = transform.GetChild(m).gameObject;
		}
		transform = typeC.transform.Find("SubScores/Texts");
		text_result_infos_C = new Text[transform.childCount];
		for (int n = 0; n < text_result_infos_C.Length; n++)
		{
			text_result_infos_C[n] = transform.GetChild(n).GetComponent<Text>();
		}
		eff_win_b = typeA.transform.Find("Eff_Back").gameObject;
		eff_win_f = typeA.transform.Find("Eff_Front").gameObject;
		eff_win_light = eff_win_f.transform.Find("Image_Mask/Image").GetComponent<Animator>();
		resultTexts = new Image[3];
		resultTexts[0] = typeA.transform.Find("Image_Win").GetComponent<Image>();
		resultTexts[1] = typeA.transform.Find("Image_Lose").GetComponent<Image>();
		resultTexts[2] = typeA.transform.Find("Image_Draw").GetComponent<Image>();
		text_info_A = typeA.transform.Find("Text_Info").GetComponent<Text>();
		text_info_C = typeC.transform.Find("Text_Info").GetComponent<Text>();
		text_matchTime = windowTr_match.Find("Canvas/Text_Time").GetComponent<Text>();
		int num = 31;
		camera_overlay.cullingMask = 1 << num;
		base.transform.Find("LeftHand Controller/HandL/HAND").gameObject.layer = num;
		base.transform.Find("RightHand Controller/HandR/HAND").gameObject.layer = num;
		eff_win_f.layer = num;
		for (int num2 = 0; num2 < 2; num2++)
		{
			handInfos[num2].line_transform.gameObject.layer = num;
			handInfos[num2].ball_transform.gameObject.layer = num;
		}
		Transform[] componentsInChildren = windowTr_menu.GetComponentsInChildren<Transform>(includeInactive: true);
		for (int num3 = 0; num3 < componentsInChildren.Length; num3++)
		{
			componentsInChildren[num3].gameObject.layer = num;
		}
		componentsInChildren = anim_result.transform.GetComponentsInChildren<Transform>(includeInactive: true);
		for (int num4 = 0; num4 < componentsInChildren.Length; num4++)
		{
			componentsInChildren[num4].gameObject.layer = num;
		}
		componentsInChildren = windowTr_wait.GetComponentsInChildren<Transform>(includeInactive: true);
		for (int num5 = 0; num5 < componentsInChildren.Length; num5++)
		{
			componentsInChildren[num5].gameObject.layer = num;
		}
		componentsInChildren = windowTr_match.GetComponentsInChildren<Transform>(includeInactive: true);
		for (int num6 = 0; num6 < componentsInChildren.Length; num6++)
		{
			componentsInChildren[num6].gameObject.layer = num;
		}
		componentsInChildren = base.transform.Find("Static").GetComponentsInChildren<Transform>(includeInactive: true);
		for (int num7 = 0; num7 < componentsInChildren.Length; num7++)
		{
			componentsInChildren[num7].gameObject.layer = num;
		}
		componentsInChildren = leaderBoard.GetComponentsInChildren<Transform>(includeInactive: true);
		for (int num8 = 0; num8 < componentsInChildren.Length; num8++)
		{
			componentsInChildren[num8].gameObject.layer = num;
		}
		componentsInChildren = gameSetting.GetComponentsInChildren<Transform>(includeInactive: true);
		for (int num9 = 0; num9 < componentsInChildren.Length; num9++)
		{
			componentsInChildren[num9].gameObject.layer = num;
		}
		gridSize = 3f;
		SetGridSize(gridSize);
		if (SceneManager.GetActiveScene().buildIndex == 0)
		{
			buttons_menu[0].transform.localPosition = new Vector3(0.135f, 0f, 0f);
			buttons_menu[1].gameObject.SetActive(value: false);
			buttons_menu[2].transform.localPosition = new Vector3(-0.135f, 0f, 0f);
		}
		else
		{
			buttons_menu[0].transform.localPosition = new Vector3(0.19f, 0f, 0f);
			buttons_menu[1].gameObject.SetActive(value: true);
			buttons_menu[2].transform.localPosition = new Vector3(-0.19f, 0f, 0f);
		}
		for (int num10 = 0; num10 < 2; num10++)
		{
			handInfos[num10].anim.gameObject.SetActive(value: false);
			handInfos[num10].line_transform.gameObject.SetActive(value: false);
			handInfos[num10].ball_transform.gameObject.SetActive(value: false);
		}
		isOverlay = false;
		camera_overlay.enabled = false;
		viewState = ViewState.None;
		isViewCenter = false;
		windowTr_menu.gameObject.SetActive(value: false);
		anim_result.gameObject.SetActive(value: false);
		windowTr_wait.gameObject.SetActive(value: false);
		windowTr_match.gameObject.SetActive(value: false);
		renderer_arrow.gameObject.SetActive(value: false);
		renderer_grid.gameObject.SetActive(value: false);
		SetCloneGrid();
		isSetFirst = true;
		isInteractable = true;
		XRInteractionManager interactionManager = UnityEngine.Object.FindObjectOfType<XRInteractionManager>();
		for (int num11 = 0; num11 < 2; num11++)
		{
			xRRayInteractors[num11].interactionManager = interactionManager;
		}
		EventSystem.current = eventSystem;
		if (GameSettingCtrl.localizationInfos != null && GameSettingCtrl.localizationInfos.Count != 0)
		{
			SetLocaliztion();
		}
	}

	private void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void OnEnable()
	{
		InputDevices_Update(default(InputDevice));
		InputDevices.deviceConnected += InputDevices_Update;
		InputDevices.deviceDisconnected += InputDevices_Update;
		List<InputDevice> list = new List<InputDevice>();
		InputDevices.GetDevices(list);
		foreach (InputDevice item in list)
		{
			InputDevices_deviceConnected(item);
		}
		InputDevices.deviceConnected += InputDevices_deviceConnected;
		InputDevices.deviceDisconnected += InputDevices_deviceDisconnected;
		SceneManager.sceneLoaded += OnSceneLoaded;
		SceneManager.sceneUnloaded += OnSceneUnloaded;
	}

	private void OnDisable()
	{
		SceneManager.sceneLoaded -= OnSceneLoaded;
		SceneManager.sceneUnloaded -= OnSceneUnloaded;
		InputDevices.deviceConnected -= InputDevices_Update;
		InputDevices.deviceDisconnected -= InputDevices_Update;
		InputDevices.deviceConnected -= InputDevices_deviceConnected;
		InputDevices.deviceDisconnected -= InputDevices_deviceDisconnected;
		devicesWithPrimaryButton.Clear();
	}

	private void InputDevices_Update(InputDevice _device)
	{
		List<InputDevice> list = new List<InputDevice>();
		InputDevices.GetDevicesAtXRNode(XRNode.LeftHand, list);
		bool flag = false;
		foreach (InputDevice item in list)
		{
			if (item.TryGetFeatureValue(CommonUsages.trigger, out var _))
			{
				triggerButtons[0] = new TriggerButtonInfo();
				triggerButtons[0].inputDevice = item;
				triggerButtons[0].isOn = false;
				SetHandState(0);
				flag = true;
			}
		}
		if (!flag)
		{
			triggerButtons[0] = null;
		}
		list.Clear();
		InputDevices.GetDevicesAtXRNode(XRNode.RightHand, list);
		flag = false;
		foreach (InputDevice item2 in list)
		{
			if (item2.TryGetFeatureValue(CommonUsages.trigger, out var _))
			{
				triggerButtons[1] = new TriggerButtonInfo();
				triggerButtons[1].inputDevice = item2;
				triggerButtons[1].isOn = false;
				SetHandState(1);
				flag = true;
			}
		}
		if (!flag)
		{
			triggerButtons[1] = null;
		}
	}

	private void InputDevices_deviceConnected(InputDevice device)
	{
		if (device.TryGetFeatureValue(CommonUsages.primaryButton, out var _))
		{
			devicesWithPrimaryButton.Add(device);
		}
	}

	private void InputDevices_deviceDisconnected(InputDevice device)
	{
		if (devicesWithPrimaryButton.Contains(device))
		{
			devicesWithPrimaryButton.Remove(device);
		}
	}

	private void StartDisconnectCheck()
	{
		if (checkDisconnect != null)
		{
			StopCoroutine(checkDisconnect);
		}
		checkDisconnect = StartCoroutine(DisconnectCheck());
	}

	private IEnumerator DisconnectCheck()
	{
		WaitForSeconds wait_1 = new WaitForSeconds(1f);
		do
		{
			yield return wait_1;
			if (UnityEngine.Application.internetReachability != 0 && PhotonNetwork.InRoom && PhotonNetwork.CurrentRoom.PlayerCount == 1)
			{
				if (this.action_disconnect != null)
				{
					this.action_disconnect();
				}
				OpenResultBoard("", (!(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id == SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id)) ? 1 : 0);
				yield break;
			}
		}
		while (PhotonNetwork.InRoom);
		if (this.action_disconnect != null)
		{
			this.action_disconnect();
		}
		OpenResultBoard("", (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id == SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id) ? 1 : 0);
	}

	private void Update()
	{
		CheckOculusFocus();
		if (!isInteractable)
		{
			isSetFirst = true;
			return;
		}
		switch (viewState)
		{
		case ViewState.Menu:
		{
			if (Input.GetKeyDown(KeyCode.Z))
			{
				Click_InputKey("Play");
			}
			else if (Input.GetKeyDown(KeyCode.X))
			{
				if (SceneManager.GetActiveScene().name != "Scene_Lobby")
				{
					Click_InputKey("Lobby");
				}
			}
			else if (Input.GetKeyDown(KeyCode.C))
			{
				Click_InputKey("Exit");
			}
			else if (Input.GetKeyDown(KeyCode.M))
			{
				Click_InputKey("Menu");
			}
			Vector3 forward3 = camera_overlay.transform.forward;
			forward3.y = 0f;
			float num5 = Vector3.Dot(forward3.normalized, targetRot * -Vector3.forward);
			Vector3 vector3 = targetPos - camera_overlay.transform.position;
			vector3.y = 0f;
			float sqrMagnitude3 = vector3.sqrMagnitude;
			if (num5 < 0.2f || sqrMagnitude3 < 0.05f || sqrMagnitude3 > 1f)
			{
				forward3 = forward3.normalized * 0.6f;
				forward3.y = -0.3f;
				targetPos = camera_overlay.transform.position + forward3;
				targetRot = Quaternion.LookRotation(-forward3);
			}
			float num6 = (windowTr_menu.position - targetPos).sqrMagnitude + 0.02f;
			windowTr_menu.position = Vector3.MoveTowards(windowTr_menu.position, targetPos, Time.unscaledDeltaTime * num6 * 30f);
			windowTr_menu.rotation = Quaternion.RotateTowards(windowTr_menu.rotation, targetRot, Time.unscaledDeltaTime * num6 * 3600f);
			gameSetting.transform.position = windowTr_menu.TransformPoint(Vector3.right * -1.2f + Vector3.forward * -0.3f + Vector3.up * 0.3f);
			Vector3 vector4 = camera_overlay.transform.position - gameSetting.transform.position;
			vector4.y = 0f;
			gameSetting.transform.rotation = Quaternion.LookRotation(vector4.normalized);
			break;
		}
		case ViewState.Result:
		{
			if (Input.GetKeyDown(KeyCode.Z))
			{
				Click_InputKey("Replay");
			}
			else if (Input.GetKeyDown(KeyCode.X))
			{
				Click_InputKey("Lobby");
			}
			else if (Input.GetKeyDown(KeyCode.M))
			{
				Click_InputKey("Menu");
			}
			Vector3 forward5 = camera_overlay.transform.forward;
			forward5.y = 0f;
			float num9 = Vector3.Dot(forward5.normalized, targetRot * -Vector3.forward);
			Vector3 vector6 = targetPos - camera_overlay.transform.position;
			vector6.y = 0f;
			float sqrMagnitude5 = vector6.sqrMagnitude;
			if (num9 < 0.3f || sqrMagnitude5 < 0.05f || sqrMagnitude5 > 2.5f)
			{
				forward5 = forward5.normalized * 1.3f;
				forward5.y = -0.1f;
				targetPos = camera_overlay.transform.position + forward5;
				targetRot = Quaternion.LookRotation(-forward5);
			}
			float value = (anim_result.transform.position - targetPos).sqrMagnitude + 0.02f;
			value = Mathf.Clamp(value, 0f, 1f);
			anim_result.transform.position = Vector3.MoveTowards(anim_result.transform.position, targetPos, Time.unscaledDeltaTime * value * 30f);
			anim_result.transform.rotation = Quaternion.RotateTowards(anim_result.transform.rotation, targetRot, Time.unscaledDeltaTime * value * 3600f);
			if (leaderBoard.gameObject.activeSelf)
			{
				leaderBoard.transform.position = anim_result.transform.TransformPoint(Vector3.right * -0.9f + Vector3.forward * 0.1f);
				Vector3 vector7 = camera_overlay.transform.position - leaderBoard.transform.position;
				vector7.y = 0f;
				leaderBoard.transform.rotation = Quaternion.LookRotation(vector7.normalized);
			}
			break;
		}
		case ViewState.Wait:
		{
			Vector3 forward4 = camera_overlay.transform.forward;
			forward4.y = 0f;
			float num7 = Vector3.Dot(forward4.normalized, targetRot * -Vector3.forward);
			Vector3 vector5 = targetPos - camera_overlay.transform.position;
			vector5.y = 0f;
			float sqrMagnitude4 = vector5.sqrMagnitude;
			if (num7 < 0.35f || sqrMagnitude4 < 0.05f || sqrMagnitude4 > 1f)
			{
				forward4 = forward4.normalized * 0.9f;
				forward4.y = -0.1f;
				targetPos = camera_overlay.transform.position + forward4;
				targetRot = Quaternion.LookRotation(-forward4);
			}
			float num8 = (windowTr_wait.position - targetPos).sqrMagnitude + 0.02f;
			windowTr_wait.position = Vector3.MoveTowards(windowTr_wait.position, targetPos, Time.unscaledDeltaTime * num8 * 30f);
			windowTr_wait.rotation = Quaternion.RotateTowards(windowTr_wait.rotation, targetRot, Time.unscaledDeltaTime * num8 * 3600f);
			break;
		}
		case ViewState.Match:
		{
			Vector3 forward = camera_overlay.transform.forward;
			forward.y = 0f;
			float num = Vector3.Dot(forward.normalized, targetRot * -Vector3.forward);
			Vector3 vector = targetPos - camera_overlay.transform.position;
			vector.y = 0f;
			float sqrMagnitude = vector.sqrMagnitude;
			if (num < 0.35f || sqrMagnitude < 0.05f || sqrMagnitude > 1f)
			{
				forward = forward.normalized * 0.9f;
				forward.y = -0.1f;
				targetPos = camera_overlay.transform.position + forward;
				targetRot = Quaternion.LookRotation(-forward);
			}
			float num2 = (windowTr_match.position - targetPos).sqrMagnitude + 0.02f;
			windowTr_match.position = Vector3.MoveTowards(windowTr_match.position, targetPos, Time.unscaledDeltaTime * num2 * 30f);
			windowTr_match.rotation = Quaternion.RotateTowards(windowTr_match.rotation, targetRot, Time.unscaledDeltaTime * num2 * 3600f);
			break;
		}
		case ViewState.Setting:
		{
			Vector3 forward2 = camera_overlay.transform.forward;
			forward2.y = 0f;
			float num3 = Vector3.Dot(forward2.normalized, targetRot * -Vector3.forward);
			Vector3 vector2 = targetPos - camera_overlay.transform.position;
			vector2.y = 0f;
			float sqrMagnitude2 = vector2.sqrMagnitude;
			if (num3 < 0.3f || sqrMagnitude2 < 0.05f || sqrMagnitude2 > 2.5f)
			{
				forward2.y = 0f;
				forward2 = forward2.normalized * 1.3f;
				targetPos = camera_overlay.transform.position + forward2;
				targetRot = Quaternion.LookRotation(-forward2);
			}
			float num4 = (gameSetting.transform.position - targetPos).sqrMagnitude + 0.02f;
			gameSetting.transform.position = Vector3.MoveTowards(gameSetting.transform.position, targetPos, Time.unscaledDeltaTime * num4 * 30f);
			gameSetting.transform.rotation = Quaternion.RotateTowards(gameSetting.transform.rotation, targetRot, Time.unscaledDeltaTime * num4 * 3600f);
			windowTr_menu.position = gameSetting.transform.position + Vector3.down * 0.7f;
			windowTr_menu.rotation = gameSetting.transform.rotation;
			break;
		}
		case ViewState.None:
			if (Input.GetKeyDown(KeyCode.M))
			{
				Click_InputKey("Menu");
			}
			break;
		}
		Vector3 position = camera_overlay.transform.position;
		if (!isOverlay)
		{
			position.y += 100f;
		}
		renderer_grid.sharedMaterial.SetVector("_TrackerPos00", position);
		for (int i = 0; i < 2; i++)
		{
			position = handInfos[i].rayDir.position;
			if (!isOverlay)
			{
				position.y += 100f;
			}
			if (i == 0)
			{
				renderer_grid.sharedMaterial.SetVector("_TrackerPos01", position);
			}
			else
			{
				renderer_grid.sharedMaterial.SetVector("_TrackerPos02", position);
			}
		}
		renderer_grid.sharedMaterial.SetFloat("_TimeP", Time.unscaledTime);
		renderer_arrow.sharedMaterial.SetFloat("_TimeP", Time.unscaledTime);
		Vector3 localPosition = camera_overlay.transform.localPosition;
		localPosition.y = 0f;
		float sqrMagnitude6 = localPosition.sqrMagnitude;
		if (isSetFirst)
		{
			if (sqrMagnitude6 >= distP_pause)
			{
				SetViewCenter(isActive: true);
			}
			else
			{
				SetViewCenter(isActive: false);
			}
		}
		else if (sqrMagnitude6 >= distP_pause && !isViewCenter)
		{
			SetViewCenter(isActive: true);
		}
		else if (sqrMagnitude6 <= distP_max && isViewCenter)
		{
			SetViewCenter(isActive: false);
		}
		if (gridSize > 1.5f)
		{
			for (int j = 0; j < 2; j++)
			{
				Vector3 vector8 = handInfos[j].rayDir.position - base.transform.position;
				vector8.y = 0f;
				if (sqrMagnitude6 < (vector8 - vector8.normalized * ((gridSize > 1.5f) ? 0.3f : 0.1f)).sqrMagnitude)
				{
					sqrMagnitude6 = (vector8 - vector8.normalized * ((gridSize > 1.5f) ? 0.3f : 0.1f)).sqrMagnitude;
				}
			}
		}
		float value2 = Mathf.Lerp(1f, 0.05f, Mathf.Clamp01(Mathf.InverseLerp(distP_min, distP_max, sqrMagnitude6)));
		renderer_grid.sharedMaterial.SetFloat("_LineP", value2);
		bool flag = false;
		foreach (InputDevice item in devicesWithPrimaryButton)
		{
			bool value3 = false;
			flag = (item.TryGetFeatureValue(CommonUsages.primaryButton, out value3) && value3) || (item.TryGetFeatureValue(CommonUsages.menuButton, out value3) && value3) || flag;
		}
		if (flag != lastButtonState)
		{
			lastButtonState = flag;
			if (lastButtonState)
			{
				Click_InputKey("Menu");
			}
		}
		if (viewState == ViewState.Menu || viewState == ViewState.Result || viewState == ViewState.Wait || viewState == ViewState.Setting)
		{
			for (int k = 0; k < 2; k++)
			{
				if (Physics.Raycast(handInfos[k].rayDir.position, handInfos[k].rayDir.forward, out var hitInfo, 3f, layerMask))
				{
					Vector3 forward6 = hitInfo.point - handInfos[k].rayDir.position;
					if (!handInfos[k].ball_transform.gameObject.activeSelf)
					{
						handInfos[k].ball_transform.gameObject.SetActive(value: true);
					}
					if (!handInfos[k].line_transform.gameObject.activeSelf)
					{
						handInfos[k].line_transform.gameObject.SetActive(value: true);
					}
					handInfos[k].ball_transform.position = hitInfo.point;
					handInfos[k].line_transform.position = handInfos[k].rayDir.position;
					handInfos[k].line_transform.rotation = Quaternion.LookRotation(forward6);
					handInfos[k].line_transform.localScale = Vector3.forward * forward6.magnitude;
					float value4 = 0.5f;
					if (triggerButtons[k] == null || !triggerButtons[k].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out value4))
					{
						continue;
					}
					bool flag2 = value4 >= 0.7f && !triggerButtons[k].isOn;
					bool flag3 = value4 <= 0.3f && triggerButtons[k].isOn;
					if (!(flag2 || flag3))
					{
						continue;
					}
					triggerButtons[k].isOn = flag2;
					if (triggerButtons[k].isOn)
					{
						MeshButtonCtrl component = hitInfo.collider.GetComponent<MeshButtonCtrl>();
						if (component != null && component.IsInteractable())
						{
							component.event_click.Invoke();
						}
					}
				}
				else
				{
					if (handInfos[k].ball_transform.gameObject.activeSelf)
					{
						handInfos[k].ball_transform.gameObject.SetActive(value: false);
					}
					if (handInfos[k].line_transform.gameObject.activeSelf)
					{
						handInfos[k].line_transform.gameObject.SetActive(value: false);
					}
				}
			}
		}
		isSetFirst = false;
		if (Input.GetKeyDown(KeyCode.H))
		{
			gameSetting.SetRightHanded();
		}
	}

	public void OpenResultBoard(string[] arr_score, int winnerPlayer, int medal_info = -1)
	{
		if (viewState == ViewState.Result || viewState == ViewState.Wait || SceneManager.GetActiveScene().name == "Scene_Lobby" || SceneManager.GetActiveScene().name == "Scene_Custom_Q")
		{
			return;
		}
		for (int i = 0; i < 2; i++)
		{
			if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[i].nick != null && SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[i].nick.Length > 0)
			{
				userInfos[i].text_nick_result.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[i].nick;
			}
			else
			{
				userInfos[i].text_nick_result.text = "Player0" + i;
			}
			userInfos[i].text_score.text = arr_score[i];
		}
		text_info_A.text = "";
		switch (winnerPlayer)
		{
		case 0:
			eff_win_b.transform.localPosition = new Vector3(-190f, 55f, 0f);
			eff_win_f.transform.localPosition = eff_win_b.transform.localPosition;
			eff_win_b.SetActive(value: true);
			eff_win_f.SetActive(value: true);
			break;
		case 1:
			eff_win_b.transform.localPosition = new Vector3(190f, 55f, 0f);
			eff_win_f.transform.localPosition = eff_win_b.transform.localPosition;
			eff_win_b.SetActive(value: true);
			eff_win_f.SetActive(value: true);
			break;
		default:
			eff_win_b.SetActive(value: false);
			eff_win_f.SetActive(value: false);
			break;
		}
		if (winnerPlayer != 0 && winnerPlayer != 1)
		{
			LanguageState languageState = gameSetting.GetLanguageState();
			if (languageState == LanguageState.schinese)
			{
				resultTexts[2].sprite = sprite_resultText_cn[2];
			}
			else
			{
				resultTexts[2].sprite = sprite_resultText_eng[2];
			}
			resultTexts[0].gameObject.SetActive(value: false);
			resultTexts[1].gameObject.SetActive(value: false);
			resultTexts[2].gameObject.SetActive(value: true);
			if (!isResultUpload)
			{
				Play_Voice(2);
			}
		}
		else if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[winnerPlayer].id == SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id)
		{
			LanguageState languageState = gameSetting.GetLanguageState();
			if (languageState == LanguageState.schinese)
			{
				resultTexts[0].sprite = sprite_resultText_cn[0];
			}
			else
			{
				resultTexts[0].sprite = sprite_resultText_eng[0];
			}
			resultTexts[0].gameObject.SetActive(value: true);
			resultTexts[1].gameObject.SetActive(value: false);
			resultTexts[2].gameObject.SetActive(value: false);
			if (!isResultUpload)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && GameData_DDOL.singleManager != null))
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.SetMultiResultScore(new string[2]
					{
						SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id,
						SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id
					}, winnerPlayer);
					SingletonBase.Singleton<UserInfoManager>.GetInstance.score_win_mine++;
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach07", 1);
				}
				Play_Voice(0);
			}
		}
		else
		{
			LanguageState languageState = gameSetting.GetLanguageState();
			if (languageState == LanguageState.schinese)
			{
				resultTexts[1].sprite = sprite_resultText_cn[1];
			}
			else
			{
				resultTexts[1].sprite = sprite_resultText_eng[1];
			}
			resultTexts[0].gameObject.SetActive(value: false);
			resultTexts[1].gameObject.SetActive(value: true);
			resultTexts[2].gameObject.SetActive(value: false);
			if (!isResultUpload)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && GameData_DDOL.singleManager != null))
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.score_lose_mine++;
				}
				Play_Voice(1);
			}
		}
		isResultUpload = true;
		StopDisconnectCheck();
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[0] = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData();
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[1] = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(1);
		}
		profileCapture.PlayImages(new string[2]
		{
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id,
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id
		}, ProfileCaptureCtrl.ShotState.Profile, winnerPlayer);
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && GameData_DDOL.singleManager == null && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level < 5 && winnerPlayer == 0 && (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode != 1))
		{
			buttons_result[0].transform.localPosition = new Vector3(0.19f, -0.3f, -0.007f);
			buttons_result[2].transform.localPosition = new Vector3(-0.19f, -0.3f, -0.007f);
			buttons_result[1].gameObject.SetActive(value: true);
			buttons_result[0].gameObject.SetActive(value: true);
		}
		else
		{
			buttons_result[0].transform.localPosition = new Vector3(0.1f, -0.3f, -0.007f);
			buttons_result[2].transform.localPosition = new Vector3(-0.1f, -0.3f, -0.007f);
			buttons_result[1].gameObject.SetActive(value: false);
			buttons_result[0].gameObject.SetActive(value: true);
		}
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && GameData_DDOL.singleManager == null && winnerPlayer == 0)
		{
			if ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1) || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Basketball && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1) || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Bowling && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1))
			{
				image_medal.gameObject.SetActive(value: false);
			}
			else
			{
				switch (medal_info)
				{
				case 5:
					image_medal.sprite = sprites_medal[0];
					image_medal.gameObject.SetActive(value: true);
					break;
				case 4:
					image_medal.sprite = sprites_medal[1];
					image_medal.gameObject.SetActive(value: true);
					break;
				case 3:
					image_medal.sprite = sprites_medal[2];
					image_medal.gameObject.SetActive(value: true);
					break;
				default:
					image_medal.gameObject.SetActive(value: false);
					break;
				case -1:
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level >= 3)
					{
						switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level)
						{
						case 5:
							image_medal.sprite = sprites_medal[0];
							break;
						case 4:
							image_medal.sprite = sprites_medal[1];
							break;
						case 3:
							image_medal.sprite = sprites_medal[2];
							break;
						}
						image_medal.gameObject.SetActive(value: true);
					}
					else
					{
						image_medal.gameObject.SetActive(value: false);
					}
					break;
				}
			}
		}
		else
		{
			image_medal.gameObject.SetActive(value: false);
		}
		typeC.SetActive(value: false);
		typeB.SetActive(value: false);
		typeA.SetActive(value: true);
		SetViewState(ViewState.Result);
	}

	public void OpenResultBoard(string info, int winnerPlayer)
	{
		if (viewState == ViewState.Result || viewState == ViewState.Wait || SceneManager.GetActiveScene().name == "Scene_Lobby" || SceneManager.GetActiveScene().name == "Scene_Custom_Q")
		{
			return;
		}
		for (int i = 0; i < 2; i++)
		{
			userInfos[i].text_nick_result.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[i].nick;
			userInfos[i].text_score.text = "";
		}
		switch (winnerPlayer)
		{
		case 0:
			eff_win_b.transform.localPosition = new Vector3(-190f, 55f, 0f);
			eff_win_f.transform.localPosition = eff_win_b.transform.localPosition;
			eff_win_b.SetActive(value: true);
			eff_win_f.SetActive(value: true);
			break;
		case 1:
			eff_win_b.transform.localPosition = new Vector3(190f, 55f, 0f);
			eff_win_f.transform.localPosition = eff_win_b.transform.localPosition;
			eff_win_b.SetActive(value: true);
			eff_win_f.SetActive(value: true);
			break;
		default:
			eff_win_b.SetActive(value: false);
			eff_win_f.SetActive(value: false);
			break;
		}
		if (winnerPlayer != 0 && winnerPlayer != 1)
		{
			LanguageState languageState = gameSetting.GetLanguageState();
			if (languageState == LanguageState.schinese)
			{
				resultTexts[2].sprite = sprite_resultText_cn[2];
			}
			else
			{
				resultTexts[2].sprite = sprite_resultText_eng[2];
			}
			resultTexts[0].gameObject.SetActive(value: false);
			resultTexts[1].gameObject.SetActive(value: false);
			resultTexts[2].gameObject.SetActive(value: true);
			if (!isResultUpload)
			{
				Play_Voice(2);
			}
		}
		else if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[winnerPlayer].id == SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id)
		{
			LanguageState languageState = gameSetting.GetLanguageState();
			if (languageState == LanguageState.schinese)
			{
				resultTexts[0].sprite = sprite_resultText_cn[0];
			}
			else
			{
				resultTexts[0].sprite = sprite_resultText_eng[0];
			}
			Text text = text_info_A;
			string text2 = (text_wait_info.text = GameSettingCtrl.GetLocalizationText("0034"));
			text.text = text2;
			resultTexts[0].gameObject.SetActive(value: true);
			resultTexts[1].gameObject.SetActive(value: false);
			resultTexts[2].gameObject.SetActive(value: false);
			if (!isResultUpload)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && isDisCheck && PhotonNetwork.IsConnected)
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.SetMultiResultScore(new string[2]
					{
						SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id,
						SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id
					}, winnerPlayer, isDisconnect: true);
					SingletonBase.Singleton<UserInfoManager>.GetInstance.score_win_mine++;
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach07", 1);
				}
				Play_Voice(0);
			}
		}
		else
		{
			LanguageState languageState = gameSetting.GetLanguageState();
			if (languageState == LanguageState.schinese)
			{
				resultTexts[1].sprite = sprite_resultText_cn[1];
			}
			else
			{
				resultTexts[1].sprite = sprite_resultText_eng[1];
			}
			Text text3 = text_info_A;
			string text2 = (text_wait_info.text = GameSettingCtrl.GetLocalizationText("0090"));
			text3.text = text2;
			resultTexts[0].gameObject.SetActive(value: false);
			resultTexts[1].gameObject.SetActive(value: true);
			resultTexts[2].gameObject.SetActive(value: false);
			if (!isResultUpload)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && GameData_DDOL.singleManager != null))
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.score_lose_mine++;
					SingletonBase.Singleton<UserInfoManager>.GetInstance.score_disconnect_mine++;
				}
				Play_Voice(1);
			}
		}
		isResultUpload = true;
		StopDisconnectCheck();
		profileCapture.PlayImages(new string[2]
		{
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id,
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id
		}, ProfileCaptureCtrl.ShotState.Profile, winnerPlayer);
		image_medal.gameObject.SetActive(value: false);
		buttons_result[2].transform.localPosition = new Vector3(0f, -0.3f, -0.007f);
		buttons_result[1].gameObject.SetActive(value: false);
		buttons_result[0].gameObject.SetActive(value: false);
		typeC.SetActive(value: false);
		typeB.SetActive(value: false);
		typeA.SetActive(value: true);
		SetViewState(ViewState.Result);
	}

	public void OpenResultBoard(string mainScore, string[] arr_subScore, int medal_info = -1)
	{
		if (viewState == ViewState.Result || viewState == ViewState.Wait || SceneManager.GetActiveScene().name == "Scene_Lobby" || SceneManager.GetActiveScene().name == "Scene_Custom_Q")
		{
			return;
		}
		Play_Voice(5);
		text_userName_B.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick;
		text_mainScore_B.text = mainScore;
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Basketball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Bowling)
		{
			mainScoreTitle_B.SetActive(value: true);
		}
		else
		{
			mainScoreTitle_B.SetActive(value: false);
		}
		int num = Math.Min(arr_subScore.Length, text_result_infos_B.Length);
		int i;
		for (i = 0; i < num; i++)
		{
			text_result_infos_B[i].text = arr_subScore[i];
			text_result_infos_B[i].gameObject.SetActive(value: true);
			if (i % 2 == 0)
			{
				subScore_images_B[(int)Mathf.Round((float)i * 0.5f)].SetActive(value: true);
			}
		}
		for (; i < text_result_infos_B.Length; i++)
		{
			text_result_infos_B[i].gameObject.SetActive(value: false);
			if (i % 2 == 0)
			{
				subScore_images_B[(int)Mathf.Round((float)i * 0.5f)].SetActive(value: false);
			}
		}
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[0] = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData();
		profileCapture.PlayImages(new string[1] { SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id }, ProfileCaptureCtrl.ShotState.Profile);
		if (GameData_DDOL.singleManager == null && (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level < 5 || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level < 9)) && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Basketball && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Bowling && (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode != 1) && (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Boxing || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode != 3))
		{
			buttons_result[0].transform.localPosition = new Vector3(0.19f, -0.3f, -0.007f);
			buttons_result[2].transform.localPosition = new Vector3(-0.19f, -0.3f, -0.007f);
			buttons_result[1].gameObject.SetActive(value: true);
			buttons_result[0].gameObject.SetActive(value: true);
		}
		else
		{
			buttons_result[0].transform.localPosition = new Vector3(0.1f, -0.3f, -0.007f);
			buttons_result[2].transform.localPosition = new Vector3(-0.1f, -0.3f, -0.007f);
			buttons_result[1].gameObject.SetActive(value: false);
			buttons_result[0].gameObject.SetActive(value: true);
		}
		if (GameData_DDOL.singleManager == null)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				image_medal.gameObject.SetActive(value: false);
			}
			else
			{
				switch (medal_info)
				{
				case 5:
					image_medal.sprite = sprites_medal[0];
					image_medal.gameObject.SetActive(value: true);
					break;
				case 4:
					image_medal.sprite = sprites_medal[1];
					image_medal.gameObject.SetActive(value: true);
					break;
				case 3:
					image_medal.sprite = sprites_medal[2];
					image_medal.gameObject.SetActive(value: true);
					break;
				default:
					image_medal.gameObject.SetActive(value: false);
					break;
				case -1:
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level >= 7)
					{
						switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level)
						{
						case 9:
							image_medal.sprite = sprites_medal[0];
							break;
						case 8:
							image_medal.sprite = sprites_medal[1];
							break;
						case 7:
							image_medal.sprite = sprites_medal[2];
							break;
						}
						image_medal.gameObject.SetActive(value: true);
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level >= 3)
					{
						switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level)
						{
						case 5:
							image_medal.sprite = sprites_medal[0];
							break;
						case 4:
							image_medal.sprite = sprites_medal[1];
							break;
						case 3:
							image_medal.sprite = sprites_medal[2];
							break;
						}
						image_medal.gameObject.SetActive(value: true);
					}
					else
					{
						image_medal.gameObject.SetActive(value: false);
					}
					break;
				}
			}
		}
		else
		{
			image_medal.gameObject.SetActive(value: false);
		}
		typeA.SetActive(value: false);
		typeC.SetActive(value: false);
		typeB.SetActive(value: true);
		SetViewState(ViewState.Result);
	}

	public void OpenResultBoard(string mainScore, string[] arr_subScore, bool isSuccess, int medal_info = -1)
	{
		if (viewState == ViewState.Result || viewState == ViewState.Wait || SceneManager.GetActiveScene().name == "Scene_Lobby" || SceneManager.GetActiveScene().name == "Scene_Custom_Q")
		{
			return;
		}
		if (isSuccess)
		{
			Play_Voice(3);
			text_info_C.text = "<color=#B3FFFA>" + GameSettingCtrl.GetLocalizationText("0035") + "</color>";
		}
		else
		{
			Play_Voice(4);
			text_info_C.text = "<color=#FF897A>" + GameSettingCtrl.GetLocalizationText("0036") + "</color>";
		}
		text_userName_C.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick;
		text_mainScore_C.text = mainScore;
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Basketball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Bowling)
		{
			mainScoreTitle_C.SetActive(value: true);
		}
		else
		{
			mainScoreTitle_C.SetActive(value: false);
		}
		int num = Math.Min(arr_subScore.Length, text_result_infos_C.Length);
		int i;
		for (i = 0; i < num; i++)
		{
			text_result_infos_C[i].text = arr_subScore[i];
			text_result_infos_C[i].gameObject.SetActive(value: true);
			if (i % 2 == 0)
			{
				subScore_images_C[(int)Mathf.Round((float)i * 0.5f)].SetActive(value: true);
			}
		}
		for (; i < text_result_infos_C.Length; i++)
		{
			text_result_infos_C[i].gameObject.SetActive(value: false);
			if (i % 2 == 0)
			{
				subScore_images_C[(int)Mathf.Round((float)i * 0.5f)].SetActive(value: false);
			}
		}
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[0] = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData();
		profileCapture.PlayImages(new string[1] { SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id }, ProfileCaptureCtrl.ShotState.Profile, (!isSuccess) ? 1 : 0);
		if (GameData_DDOL.singleManager == null && (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level < 5 || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level < 9)) && isSuccess && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Basketball && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Bowling && (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Baseball || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode != 1))
		{
			buttons_result[0].transform.localPosition = new Vector3(0.19f, -0.3f, -0.007f);
			buttons_result[2].transform.localPosition = new Vector3(-0.19f, -0.3f, -0.007f);
			buttons_result[1].gameObject.SetActive(value: true);
			buttons_result[0].gameObject.SetActive(value: true);
		}
		else
		{
			buttons_result[0].transform.localPosition = new Vector3(0.1f, -0.3f, -0.007f);
			buttons_result[2].transform.localPosition = new Vector3(-0.1f, -0.3f, -0.007f);
			buttons_result[1].gameObject.SetActive(value: false);
			buttons_result[0].gameObject.SetActive(value: true);
		}
		if (GameData_DDOL.singleManager == null && isSuccess)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				image_medal.gameObject.SetActive(value: false);
			}
			else
			{
				switch (medal_info)
				{
				case 5:
					image_medal.sprite = sprites_medal[0];
					image_medal.gameObject.SetActive(value: true);
					break;
				case 4:
					image_medal.sprite = sprites_medal[1];
					image_medal.gameObject.SetActive(value: true);
					break;
				case 3:
					image_medal.sprite = sprites_medal[2];
					image_medal.gameObject.SetActive(value: true);
					break;
				default:
					image_medal.gameObject.SetActive(value: false);
					break;
				case -1:
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level >= 7)
					{
						switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level)
						{
						case 9:
							image_medal.sprite = sprites_medal[0];
							break;
						case 8:
							image_medal.sprite = sprites_medal[1];
							break;
						case 7:
							image_medal.sprite = sprites_medal[2];
							break;
						}
						image_medal.gameObject.SetActive(value: true);
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level >= 3)
					{
						switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level)
						{
						case 5:
							image_medal.sprite = sprites_medal[0];
							break;
						case 4:
							image_medal.sprite = sprites_medal[1];
							break;
						case 3:
							image_medal.sprite = sprites_medal[2];
							break;
						}
						image_medal.gameObject.SetActive(value: true);
					}
					else
					{
						image_medal.gameObject.SetActive(value: false);
					}
					break;
				}
			}
		}
		else
		{
			image_medal.gameObject.SetActive(value: false);
		}
		typeA.SetActive(value: false);
		typeB.SetActive(value: false);
		typeC.SetActive(value: true);
		SetViewState(ViewState.Result);
	}

	public void CloseResultBoard()
	{
		if (viewState == ViewState.Result)
		{
			SetViewState(ViewState.None);
		}
	}

	public void OpenWaitUI()
	{
		if (waitUICoroutine != null)
		{
			StopCoroutine(waitUICoroutine);
		}
		PhotonNetwork.IsSyncScene = true;
		PhotonNetwork.isLoadLevel = true;
		waitUICoroutine = StartCoroutine(WaitUICoroutine());
	}

	private IEnumerator WaitUICoroutine()
	{
		PhotonNetwork.LocalPlayer.CustomProperties["GameReady"] = true;
		PhotonNetwork.LocalPlayer.SetCustomProperties(PhotonNetwork.LocalPlayer.CustomProperties);
		text_wait_info.text = GameSettingCtrl.GetLocalizationText("0038");
		text_wait_time.text = "";
		text_wait_time.gameObject.SetActive(value: true);
		button_wait.SetActive(value: false);
		SetViewState(ViewState.Wait);
		float timeP = 0f;
		yield return new WaitForSeconds(1f);
		while (true)
		{
			try
			{
				if (PhotonNetwork.CurrentRoom.PlayerCount < 2)
				{
					text_wait_info.text = GameSettingCtrl.GetLocalizationText("0034");
					break;
				}
			}
			catch (Exception)
			{
				text_wait_info.text = GameSettingCtrl.GetLocalizationText("0034");
				break;
			}
			int num = 0;
			using (IEnumerator<KeyValuePair<int, Player>> enumerator = PhotonNetwork.CurrentRoom.Players.OrderBy((KeyValuePair<int, Player> i) => i.Value.ActorNumber).GetEnumerator())
			{
				while (enumerator.MoveNext() && (bool)enumerator.Current.Value.CustomProperties["GameReady"])
				{
					num++;
					if (num == 2)
					{
						if (PhotonNetwork.LocalPlayer.IsMasterClient)
						{
							StartLoadLevel();
						}
						SetViewState(ViewState.None);
						yield break;
					}
				}
			}
			timeP += Time.unscaledDeltaTime;
			if (timeP >= 10f)
			{
				break;
			}
			text_wait_time.text = ((int)timeP).ToString();
			yield return null;
		}
		text_wait_time.gameObject.SetActive(value: false);
		button_wait.SetActive(value: true);
		yield return null;
		while (true)
		{
			try
			{
				if (PhotonNetwork.CurrentRoom.PlayerCount < 2)
				{
					text_wait_info.text = GameSettingCtrl.GetLocalizationText("0034");
					break;
				}
			}
			catch (Exception)
			{
				text_wait_info.text = GameSettingCtrl.GetLocalizationText("0034");
				break;
			}
			int num = 0;
			using (IEnumerator<KeyValuePair<int, Player>> enumerator = PhotonNetwork.CurrentRoom.Players.OrderBy((KeyValuePair<int, Player> i) => i.Value.ActorNumber).GetEnumerator())
			{
				while (enumerator.MoveNext() && (bool)enumerator.Current.Value.CustomProperties["GameReady"])
				{
					num++;
					if (num == 2)
					{
						if (PhotonNetwork.LocalPlayer.IsMasterClient)
						{
							StartLoadLevel();
						}
						SetViewState(ViewState.None);
						yield break;
					}
				}
			}
			yield return null;
		}
	}

	public void AddLoadLobbyEvent(Action _action_lobby)
	{
		action_lobby += _action_lobby;
	}

	public void AddReplayEvent(Action _action_replay)
	{
		action_replay += _action_replay;
	}

	public void AddMenuEvent(Action<bool> _action_menu)
	{
		action_menu += _action_menu;
	}

	public void AddDisconnectEvent(Action _action_dis)
	{
		action_disconnect += _action_dis;
	}

	public void SetInteractable(bool _isInteractable)
	{
		isInteractable = _isInteractable;
		if (!isInteractable)
		{
			SetViewState(ViewState.None);
		}
	}

	private IEnumerator DelayActive()
	{
		yield return new WaitForSeconds(0.5f);
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && SceneManager.GetActiveScene().name != "Scene_Lobby" && SceneManager.GetActiveScene().name != "Scene_Custom_Q")
		{
			if (UnityEngine.Application.internetReachability == NetworkReachability.NotReachable || !PhotonNetwork.InRoom || PhotonNetwork.CurrentRoom.PlayerCount == 1)
			{
				if (this.action_lobby != null)
				{
					this.action_lobby();
				}
				if (leaderBoard.gameObject.activeSelf)
				{
					leaderBoard.Close();
				}
				if (PhotonNetwork.IsConnected)
				{
					PhotonNetwork.IsSyncScene = false;
					PhotonNetwork.Disconnect();
				}
				SetViewState(ViewState.None);
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.None;
				isDisCheck = false;
				LobbyUIManager.startViewState = LobbyUIManager.StartViewState.Disconnect;
				SceneManager.LoadScene(0);
				yield break;
			}
			StartDisconnectCheck();
		}
		camera_main = Camera.main;
		controllers_main = camera_main.transform.parent.GetComponentsInChildren<UnityEngine.XR.Interaction.Toolkit.XRController>();
		renderOriginCam.Init(camera_main.transform);
		XRInteractionManager interactionManager = UnityEngine.Object.FindObjectOfType<XRInteractionManager>();
		for (int i = 0; i < 2; i++)
		{
			xRRayInteractors[i].interactionManager = interactionManager;
		}
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Baseball && (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode != 1)))
		{
			profileCapture.ShotImages_Baseball();
		}
		SetCloneGrid();
		isInteractable = true;
		yield return new WaitForSeconds(3f);
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
		{
			PhotonNetwork.LocalPlayer.CustomProperties["GameReady"] = false;
			PhotonNetwork.LocalPlayer.SetCustomProperties(PhotonNetwork.LocalPlayer.CustomProperties);
			if (PhotonNetwork.LocalPlayer.IsMasterClient)
			{
				PhotonNetwork.CurrentRoom.CustomProperties["curScn"] = "";
				PhotonNetwork.CurrentRoom.SetCustomProperties(PhotonNetwork.CurrentRoom.CustomProperties);
			}
			PhotonNetwork.IsSyncScene = false;
			PhotonNetwork.isLoadLevel = false;
			SceneManagerHelper.ActiveSceneName = "";
		}
		if (!(SceneManager.GetActiveScene().name == "Scene_Lobby") && !(SceneManager.GetActiveScene().name == "Scene_Custom_Q"))
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && GameData_DDOL.singleManager != null)
			{
				PlayerPrefs.SetInt("isDisCheck", 1);
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				yield return new WaitForSeconds(30f);
				isDisCheck = true;
			}
		}
	}

	private IEnumerator AddPxrManager()
	{
		while (UnityEngine.Object.FindObjectOfType<XRRig>() == null)
		{
			yield return null;
		}
	}

	private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
	{
		if (mode == LoadSceneMode.Single)
		{
			isOverlay = false;
			camera_overlay.enabled = false;
			renderer_grid.gameObject.SetActive(value: false);
			if (scene.name == "Scene_Lobby")
			{
				gridSize = 3f;
				SetGridSize(gridSize);
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.medalView.Init();
				StartCoroutine(SingletonBase.Singleton<LobbyUIManager>.GetInstance.achievement.SetAchieve());
			}
			else
			{
				buttons_menu[0].transform.localPosition = new Vector3(0.19f, 0f, 0f);
				buttons_menu[1].gameObject.SetActive(value: true);
				buttons_menu[2].transform.localPosition = new Vector3(-0.19f, 0f, 0f);
			}
			delayActiveCoroutine = StartCoroutine(DelayActive());
		}
	}

	private void StopDisconnectCheck()
	{
		if (checkDisconnect != null)
		{
			StopCoroutine(checkDisconnect);
		}
		if (delayActiveCoroutine != null)
		{
			StopCoroutine(delayActiveCoroutine);
		}
		isDisCheck = false;
		PlayerPrefs.SetInt("isDisCheck", 0);
	}

	private void OnSceneUnloaded(Scene current)
	{
		profileCapture.StopImages();
		SetViewState(ViewState.None);
		isInteractable = false;
		isResultUpload = false;
		this.action_lobby = null;
		this.action_replay = null;
		this.action_menu = null;
		this.action_disconnect = null;
		gameSetting.ClearHandChangedEvent();
		gameSetting.ClearLocalizationChangedEvent();
	}

	private void SetOverlay(bool _isOverlay)
	{
		if (isOverlay == _isOverlay && !isSetFirst)
		{
			return;
		}
		isOverlay = _isOverlay;
		if (isOverlay)
		{
			if (camera_main != null)
			{
				camera_main.enabled = false;
				camera_overlay.enabled = true;
				renderer_grid.gameObject.SetActive(value: true);
				grid_clone.SetActive(value: false);
				SetKeepObjectEnable(isEnable: false);
			}
		}
		else if (camera_main != null)
		{
			camera_main.enabled = true;
			camera_overlay.enabled = false;
			renderer_grid.gameObject.SetActive(value: false);
			grid_clone.SetActive(value: true);
			SetKeepObjectEnable(isEnable: true);
		}
	}

	public void SetViewState(ViewState setViewState)
	{
		if (viewState == setViewState)
		{
			return;
		}
		if (setViewState == ViewState.None && viewState_keep == ViewState.Result && viewState == ViewState.Match)
		{
			setViewState = ViewState.Result;
		}
		viewState_keep = viewState;
		if (setViewState == ViewState.Menu)
		{
			if (this.action_menu != null)
			{
				this.action_menu(obj: true);
			}
		}
		else if (viewState == ViewState.Menu && this.action_menu != null)
		{
			this.action_menu(obj: false);
		}
		if (viewState == ViewState.Setting && SingletonBase.Singleton<LobbyUIManager>.IsInstance)
		{
			SingletonBase.Singleton<LobbyUIManager>.GetInstance.gameSetting.View();
		}
		viewState = setViewState;
		SetHandState(0);
		SetHandState(1);
		gameSetting.gameObject.SetActive(value: false);
		camera_overlay.tag = "Untagged";
		if (camera_main != null)
		{
			camera_main.tag = "MainCamera";
		}
		if (viewState != 0)
		{
			if (controllers_main != null)
			{
				for (int i = 0; i < controllers_main.Length; i++)
				{
					controllers_main[i].enableInputActions = false;
				}
			}
			if (controllers_overlay != null)
			{
				for (int j = 0; j < controllers_overlay.Length; j++)
				{
					controllers_overlay[j].enableInputActions = true;
				}
			}
			if (!isViewCenter)
			{
				SetOverlay(_isOverlay: true);
			}
			Vector3 forward = camera_overlay.transform.forward;
			forward.y = 0f;
			forward = forward.normalized * 0.5f;
			forward.y = -0.3f;
			targetPos = camera_overlay.transform.position;
			switch (viewState)
			{
			case ViewState.Menu:
				windowTr_menu.position = camera_overlay.transform.position + camera_overlay.transform.forward * 0.5f + camera_overlay.transform.up * 0.5f;
				targetRot = Quaternion.LookRotation(camera_overlay.transform.position - windowTr_menu.position);
				windowTr_menu.rotation = targetRot;
				if (SceneManager.GetActiveScene().name == "Scene_Lobby")
				{
					buttons_menu[0].transform.localPosition = new Vector3(0.135f, 0f, 0f);
					buttons_menu[1].gameObject.SetActive(value: false);
					buttons_menu[2].transform.localPosition = new Vector3(-0.135f, 0f, 0f);
					buttons_menu[2].gameObject.SetActive(value: true);
				}
				else
				{
					camera_main.tag = "Untagged";
					camera_overlay.tag = "MainCamera";
					SetLocaliztion();
					gameSetting.View();
					buttons_menu[0].transform.localPosition = new Vector3(0.19f, 0f, 0f);
					buttons_menu[1].gameObject.SetActive(value: true);
					buttons_menu[2].transform.localPosition = new Vector3(-0.19f, 0f, 0f);
					buttons_menu[2].gameObject.SetActive(value: true);
				}
				windowTr_match.gameObject.SetActive(value: false);
				anim_result.gameObject.SetActive(value: false);
				windowTr_wait.gameObject.SetActive(value: false);
				windowTr_menu.gameObject.SetActive(value: true);
				break;
			case ViewState.Result:
				anim_result.transform.position = camera_overlay.transform.position + camera_overlay.transform.forward * 0.5f + camera_overlay.transform.up * 0.5f;
				targetRot = Quaternion.LookRotation(camera_overlay.transform.position - anim_result.transform.position);
				anim_result.transform.rotation = targetRot;
				windowTr_match.gameObject.SetActive(value: false);
				windowTr_menu.gameObject.SetActive(value: false);
				windowTr_wait.gameObject.SetActive(value: false);
				anim_result.gameObject.SetActive(value: true);
				break;
			case ViewState.Wait:
				windowTr_wait.position = camera_overlay.transform.position + camera_overlay.transform.forward * 0.5f + camera_overlay.transform.up * 0.5f;
				targetRot = Quaternion.LookRotation(camera_overlay.transform.position - windowTr_wait.position);
				windowTr_wait.rotation = targetRot;
				anim_result.gameObject.SetActive(value: false);
				windowTr_menu.gameObject.SetActive(value: false);
				windowTr_match.gameObject.SetActive(value: false);
				windowTr_wait.gameObject.SetActive(value: true);
				break;
			case ViewState.Match:
				windowTr_match.position = camera_overlay.transform.position + camera_overlay.transform.forward * 0.5f + camera_overlay.transform.up * 0.5f;
				targetRot = Quaternion.LookRotation(camera_overlay.transform.position - windowTr_match.position);
				windowTr_match.rotation = targetRot;
				anim_result.gameObject.SetActive(value: false);
				windowTr_menu.gameObject.SetActive(value: false);
				windowTr_wait.gameObject.SetActive(value: false);
				windowTr_match.gameObject.SetActive(value: true);
				break;
			case ViewState.Setting:
			{
				gameSetting.transform.position = camera_overlay.transform.position + camera_overlay.transform.forward * 0.5f + camera_overlay.transform.up * 0.5f;
				Vector3 forward2 = camera_overlay.transform.position - gameSetting.transform.position;
				forward2.y = 0f;
				targetRot = Quaternion.LookRotation(forward2);
				gameSetting.transform.rotation = targetRot;
				camera_main.tag = "Untagged";
				camera_overlay.tag = "MainCamera";
				SetLocaliztion();
				gameSetting.View();
				buttons_menu[0].transform.localPosition = new Vector3(0f, 0f, 0f);
				buttons_menu[1].gameObject.SetActive(value: false);
				buttons_menu[2].gameObject.SetActive(value: false);
				windowTr_match.gameObject.SetActive(value: false);
				anim_result.gameObject.SetActive(value: false);
				windowTr_wait.gameObject.SetActive(value: false);
				windowTr_menu.gameObject.SetActive(value: true);
				break;
			}
			}
			return;
		}
		if (controllers_overlay != null)
		{
			for (int k = 0; k < controllers_overlay.Length; k++)
			{
				controllers_overlay[k].enableInputActions = false;
			}
		}
		if (controllers_main != null)
		{
			for (int l = 0; l < controllers_main.Length; l++)
			{
				controllers_main[l].enableInputActions = true;
			}
		}
		EndResultAnim();
		windowTr_menu.gameObject.SetActive(value: false);
		windowTr_wait.gameObject.SetActive(value: false);
		windowTr_match.gameObject.SetActive(value: false);
		if (!isViewCenter)
		{
			SetOverlay(_isOverlay: false);
		}
	}

	public void SetViewCenter(bool isActive)
	{
		if (isViewCenter == isActive && !isSetFirst)
		{
			return;
		}
		isViewCenter = isActive;
		if (isViewCenter)
		{
			if (isSetFirst || viewState == ViewState.None)
			{
				SetOverlay(_isOverlay: true);
			}
			renderer_arrow.gameObject.SetActive(value: true);
		}
		else
		{
			renderer_arrow.gameObject.SetActive(value: false);
			if (isSetFirst || viewState == ViewState.None)
			{
				SetOverlay(_isOverlay: false);
			}
		}
	}

	public void Click_InputKey(string key)
	{
		if (!isInteractable || viewState == ViewState.Match)
		{
			return;
		}
		switch (key)
		{
		case "Play":
			if (viewState == ViewState.Setting || viewState == ViewState.Menu)
			{
				SetViewState(ViewState.None);
			}
			break;
		case "Lobby":
			if (this.action_lobby != null)
			{
				this.action_lobby();
			}
			if (delayActiveCoroutine != null)
			{
				StopCoroutine(delayActiveCoroutine);
			}
			if (leaderBoard.gameObject.activeSelf)
			{
				leaderBoard.Close();
			}
			if (PlayerPrefs.GetInt("isDisCheck", 0) == 1 || isDisCheck)
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.score_lose_mine++;
			}
			if (PhotonNetwork.IsConnected)
			{
				PhotonNetwork.IsSyncScene = false;
				PhotonNetwork.Disconnect();
			}
			SetViewState(ViewState.None);
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.None;
			isDisCheck = false;
			SceneManager.LoadScene(0);
			break;
		case "Exit":
			UnityEngine.Application.Quit();
			break;
		case "Setting":
			if (viewState == ViewState.Setting)
			{
				SetViewState(ViewState.None);
			}
			else if (viewState == ViewState.None)
			{
				SetViewState(ViewState.Setting);
			}
			break;
		case "Replay":
			if (leaderBoard.gameObject.activeSelf)
			{
				leaderBoard.Close();
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				OpenWaitUI();
			}
			else
			{
				StartLoadLevel();
			}
			break;
		case "Menu":
			if (viewState != ViewState.Setting)
			{
				if (viewState == ViewState.Menu)
				{
					SetViewState(ViewState.None);
				}
				else if (viewState == ViewState.None)
				{
					SetViewState(ViewState.Menu);
				}
			}
			break;
		case "Next":
			if (leaderBoard.gameObject.activeSelf)
			{
				leaderBoard.Close();
			}
			SetViewState(ViewState.None);
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level++;
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick = "Level" + SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			StartLoadLevel();
			break;
		}
	}

	public void SetGridSize(float sizeP)
	{
		gridSize = sizeP;
		renderer_grid.transform.localScale = new Vector3(gridSize, 2f, gridSize);
		if (grid_clone != null)
		{
			grid_clone.transform.localScale = renderer_grid.transform.localScale;
		}
		renderer_grid.sharedMaterial.SetVector("_Tiling", new Vector2(8f * gridSize, 5f));
		renderer_grid.sharedMaterial.SetVector("_TrackerPos00", Vector3.zero);
		renderer_grid.sharedMaterial.SetVector("_TrackerPos01", Vector3.zero);
		renderer_grid.sharedMaterial.SetVector("_TrackerPos02", Vector3.zero);
		if (sizeP > 1.5f)
		{
			distP_pause = gridSize * 0.5f;
			distP_min = distP_pause - 0.4f;
			distP_min *= distP_min;
			distP_max = distP_pause - 0.35f;
			distP_max *= distP_max;
			distP_pause *= distP_pause;
		}
		else
		{
			distP_pause = gridSize * 0.5f;
			distP_min = distP_pause - 0.1f;
			distP_min *= distP_min;
			distP_max = distP_pause - 0.05f;
			distP_max *= distP_max;
			distP_pause *= distP_pause;
		}
	}

	private void SetCloneGrid()
	{
		grid_clone = UnityEngine.Object.Instantiate(renderer_grid.gameObject, camera_main.transform.parent);
		grid_clone.transform.localPosition = Vector3.zero;
		grid_clone.transform.localRotation = Quaternion.identity;
		grid_clone.transform.localScale = renderer_grid.transform.localScale;
		grid_clone.layer = 0;
		grid_clone.SetActive(value: true);
	}

	public void UpdateMatchRoomInfo()
	{
		int num = 0;
		foreach (KeyValuePair<int, Player> item in PhotonNetwork.CurrentRoom.Players.OrderBy((KeyValuePair<int, Player> i) => i.Value.ActorNumber))
		{
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[num].id = (string)item.Value.CustomProperties["AppnoriID"];
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[num].nick = item.Value.NickName;
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[num] = JsonUtility.FromJson<CustomModelData>((string)item.Value.CustomProperties["ModelData"]);
			userInfos[num].text_nick_match.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[num].nick;
			userInfos[num].text_info_match.text = (int)item.Value.CustomProperties["Win"] + "W " + (int)item.Value.CustomProperties["Lose"] + "L";
			num++;
		}
		if (num == 1)
		{
			userInfos[1].text_nick_match.text = "Waiting...";
			userInfos[1].text_info_match.text = "";
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id = "AI";
			SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id;
			profileCapture.PlayImages(new string[1] { SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id }, ProfileCaptureCtrl.ShotState.Multi);
		}
		else
		{
			Play_Voice(6);
			profileCapture.PlayImages(new string[2]
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id,
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id
			}, ProfileCaptureCtrl.ShotState.Multi);
		}
	}

	public void SetMatchTime(string setText)
	{
		text_matchTime.text = setText;
	}

	public void EndResultAnim()
	{
		if (viewState_keep == ViewState.Result)
		{
			if (endResultCoroutine != null)
			{
				StopCoroutine(endResultCoroutine);
			}
			anim_result.SetTrigger("OnClose");
			endResultCoroutine = StartCoroutine(EndResultCoroutine());
		}
	}

	private IEnumerator EndResultCoroutine()
	{
		yield return new WaitForSeconds(0.1f);
		while (1f > anim_result.GetCurrentAnimatorStateInfo(0).normalizedTime)
		{
			yield return null;
		}
		anim_result.gameObject.SetActive(value: false);
	}

	private void SetHandState(int index)
	{
		switch (viewState)
		{
		case ViewState.None:
			handInfos[index].anim.gameObject.SetActive(value: false);
			handInfos[index].line_transform.gameObject.SetActive(value: false);
			handInfos[index].ball_transform.gameObject.SetActive(value: false);
			break;
		case ViewState.Menu:
		case ViewState.Result:
		case ViewState.Wait:
		case ViewState.Setting:
			handInfos[index].anim.gameObject.SetActive(value: true);
			handInfos[index].anim.SetBool("IsPoint", value: true);
			handInfos[index].line_transform.gameObject.SetActive(value: true);
			handInfos[index].ball_transform.gameObject.SetActive(value: true);
			break;
		case ViewState.Match:
			handInfos[index].anim.gameObject.SetActive(value: true);
			handInfos[index].anim.SetBool("IsPoint", value: false);
			handInfos[index].line_transform.gameObject.SetActive(value: false);
			handInfos[index].ball_transform.gameObject.SetActive(value: false);
			break;
		}
	}

	public void StartLoadLevel()
	{
		switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType)
		{
		case GameData_DDOL.GameType.Bowling:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Bowling");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_Bowling");
			}
			break;
		case GameData_DDOL.GameType.Archery:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Archery");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_Archery");
			}
			break;
		case GameData_DDOL.GameType.Basketball:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_BasketBall");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_BasketBall");
			}
			break;
		case GameData_DDOL.GameType.Badminton:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Badminton");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_Badminton");
			}
			break;
		case GameData_DDOL.GameType.Billiards:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Billiards");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_Billiards");
			}
			break;
		case GameData_DDOL.GameType.Darts:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Darts");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_Darts");
			}
			break;
		case GameData_DDOL.GameType.TableTennis:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_PingPong");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_PingPong");
			}
			break;
		case GameData_DDOL.GameType.Boxing:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Boxing_MT");
				break;
			}
			switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode)
			{
			case 2:
				SceneManager.LoadScene("Scene_Game_Boxing");
				break;
			case 3:
				SceneManager.LoadScene("Scene_Game_Boxing_HB");
				break;
			default:
				SceneManager.LoadScene("Scene_Game_Boxing_AI");
				break;
			}
			break;
		case GameData_DDOL.GameType.Golf:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Golf");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_Golf");
			}
			break;
		case GameData_DDOL.GameType.Baseball:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_BaseBall");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_BaseBall");
			}
			break;
		case GameData_DDOL.GameType.Tennis:
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PhotonNetwork.LoadLevel("Scene_Game_Tennis");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_Tennis");
			}
			break;
		}
	}

	public void Play(int index, bool isLoop = false)
	{
		audioSource_effect.loop = isLoop;
		audioSource_effect.clip = audios_effect[index];
		audioSource_effect.Play();
	}

	public void Stop()
	{
		audioSource_effect.Stop();
	}

	public void Play_Voice(int index, bool isLoop = false)
	{
		audioSource_voice.loop = isLoop;
		LanguageState languageState = gameSetting.GetLanguageState();
		if (languageState == LanguageState.schinese)
		{
			audioSource_voice.clip = audios_voice_cn[index];
		}
		else
		{
			audioSource_voice.clip = audios_voice[index];
		}
		audioSource_voice.Play();
	}

	public void Stop_Voice()
	{
		audioSource_voice.Stop();
	}

	public void SyncProfileLight(float _time)
	{
		eff_win_light.SetFloat("Time", _time);
	}

	public void SetHaptic(float amplitude = 0.5f, float duration = 0.5f)
	{
		if (controllers_main != null)
		{
			for (int i = 0; i < controllers_main.Length; i++)
			{
				controllers_main[i].SendHapticImpulse(amplitude * gameSetting.GetHapticValue(), duration);
			}
		}
	}

	public ViewState GetCurrentState()
	{
		return viewState;
	}

	public void SetLocaliztion()
	{
		for (int i = 0; i < dataSlots_localization.Length; i++)
		{
			dataSlots_localization[i].ui.text = GameSettingCtrl.GetLocalizationText(dataSlots_localization[i].id);
		}
	}

	public bool IsOverlay()
	{
		return isOverlay;
	}

	private void OnApplicationPause(bool pause)
	{
		isPause = pause;
		UnityEngine.Debug.Log("OnApplicationPause");
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
		{
			recorder.IsRecording = UnityEngine.Application.isFocused && !isPause;
		}
	}

	private void CheckOculusFocus()
	{
		if (OVRManager.hasInputFocus == isFocus)
		{
			return;
		}
		isFocus = OVRManager.hasInputFocus;
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
		{
			if (isFocus)
			{
				Time.timeScale = saveTimeScale;
			}
			else
			{
				saveTimeScale = Time.timeScale;
				Time.timeScale = 0f;
			}
		}
		if (!isFocus && viewState == ViewState.Menu)
		{
			SetViewState(ViewState.None);
			SetOverlay(_isOverlay: true);
		}
		else if (!isFocus)
		{
			SetOverlay(_isOverlay: true);
		}
		else if (isFocus && viewState == ViewState.None)
		{
			SetOverlay(_isOverlay: false);
		}
	}

	private void OnApplicationFocus(bool focus)
	{
		UnityEngine.Debug.Log("OnApplicationFocus");
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
		{
			recorder.IsRecording = focus && !isPause;
		}
	}

	private void SetKeepObjectEnable(bool isEnable)
	{
		if (isEnable)
		{
			uint renderingLayerMask = 1u;
			for (int i = 0; i < keep_object.Count; i++)
			{
				if (keep_object[i] != null)
				{
					keep_object[i].renderingLayerMask = renderingLayerMask;
				}
			}
			keep_object.Clear();
			return;
		}
		if (SceneManager.GetActiveScene().name == "AightBallPool")
		{
			try
			{
				keep_object.AddRange(GameObject.Find("AightBallPoolGameManager/CuePivot/CueVertical/CueDisplacement").GetComponentsInChildren<Renderer>(includeInactive: true));
				keep_object.AddRange(GameObject.Find("FreeLeftHand").GetComponentsInChildren<Renderer>(includeInactive: true));
				keep_object.AddRange(GameObject.Find("FreeRightHand").GetComponentsInChildren<Renderer>(includeInactive: true));
			}
			catch
			{
				return;
			}
		}
		else
		{
			for (int j = 0; j < controllers_main.Length; j++)
			{
				keep_object.AddRange(controllers_main[j].GetComponentsInChildren<Renderer>(includeInactive: true));
			}
		}
		for (int k = 0; k < keep_object.Count; k++)
		{
			if (keep_object[k] != null)
			{
				keep_object[k].renderingLayerMask = 0u;
			}
		}
	}
}
public class RagdollCreator : MonoBehaviour
{
	public void CreateRagdoll()
	{
		Transform transform = new GameObject(base.gameObject.name).transform;
		transform.SetPositionAndRotation(base.transform.position, base.transform.rotation);
		Transform transform2 = UnityEngine.Object.Instantiate(base.transform, base.transform.position, base.transform.rotation, transform);
		transform2.name = "Orizin";
		UnityEngine.Object.DestroyImmediate(transform2.GetComponent<RagdollCreator>());
		Transform transform3 = UnityEngine.Object.Instantiate(base.transform, base.transform.position, base.transform.rotation, transform);
		transform3.name = "Ragdoll";
		UnityEngine.Object.DestroyImmediate(transform3.GetComponent<RagdollCreator>());
		UnityEngine.Object.DestroyImmediate(transform3.GetComponent<Animator>());
		UnityEngine.Debug.Log("복제 완료.");
		Renderer[] componentsInChildren = transform3.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int num = componentsInChildren.Length - 1; num >= 0; num--)
		{
			UnityEngine.Object.DestroyImmediate(componentsInChildren[num].gameObject);
		}
		UnityEngine.Debug.Log("메시 오브젝트 제거.");
		Transform[] componentsInChildren2 = transform3.GetComponentsInChildren<Transform>();
		List<GameObject> list = new List<GameObject>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			if (componentsInChildren2[i].name.Contains("Footstep") || componentsInChildren2[i].name.Contains("Twist") || componentsInChildren2[i].name.Contains("Clavicle") || componentsInChildren2[i].name.Contains("Neck") || componentsInChildren2[i].name.Contains("Finger") || componentsInChildren2[i].name.Contains("HeadNub") || (componentsInChildren2[i].name.Contains("Spine") && !componentsInChildren2[i].name.Contains("Spine2")) || componentsInChildren2[i].name.Contains("Toe") || componentsInChildren2[i].name.Contains("Eye") || componentsInChildren2[i].name.Equals("Bip001"))
			{
				list.Add(componentsInChildren2[i].gameObject);
			}
		}
		for (int num2 = list.Count - 1; num2 >= 0; num2--)
		{
			if (list[num2].name.Equals("Bip001") || list[num2].name.Contains("Clavicle") || list[num2].name.Contains("Neck") || list[num2].name.Contains("Spine"))
			{
				list[num2].transform.GetChild(0).parent = list[num2].transform.parent;
			}
			UnityEngine.Object.DestroyImmediate(list[num2]);
		}
		UnityEngine.Debug.Log("필요없는 Bone 제거.");
		Transform[] componentsInChildren3 = transform3.GetComponentsInChildren<Transform>();
		for (int j = 0; j < componentsInChildren3.Length; j++)
		{
			if (componentsInChildren3[j].name.Equals("Ragdoll"))
			{
				continue;
			}
			Rigidbody rigidbody = componentsInChildren3[j].gameObject.AddComponent<Rigidbody>();
			rigidbody.drag = 5f;
			rigidbody.angularDrag = 1f;
			if (componentsInChildren3[j].name.Contains("Pelvis"))
			{
				rigidbody.mass = 50f;
			}
			else if (componentsInChildren3[j].name.Contains("Thigh"))
			{
				rigidbody.mass = 17f;
			}
			else if (componentsInChildren3[j].name.Contains("Calf"))
			{
				rigidbody.mass = 13f;
			}
			else if (componentsInChildren3[j].name.Contains("Foot"))
			{
				rigidbody.mass = 12f;
			}
			else if (componentsInChildren3[j].name.Contains("Spine"))
			{
				rigidbody.mass = 12f;
			}
			else if (componentsInChildren3[j].name.Contains("UpperArm"))
			{
				rigidbody.mass = 0.5f;
				if (!componentsInChildren3[j].name.Contains(" L "))
				{
				}
			}
			else if (componentsInChildren3[j].name.Contains("Forearm"))
			{
				rigidbody.mass = 0.5f;
			}
			else if (componentsInChildren3[j].name.Contains("Hand"))
			{
				rigidbody.mass = 0.5f;
			}
			else if (componentsInChildren3[j].name.Contains("Head"))
			{
				rigidbody.mass = 5f;
			}
		}
		UnityEngine.Debug.Log("리지드바디/태그 추가.");
		for (int k = 0; k < componentsInChildren3.Length; k++)
		{
			if (!componentsInChildren3[k].name.Equals("Ragdoll"))
			{
				ConfigurableJoint configurableJoint = componentsInChildren3[k].gameObject.AddComponent<ConfigurableJoint>();
				configurableJoint.axis = Vector3.right;
				configurableJoint.secondaryAxis = Vector3.up;
				if (componentsInChildren3[k].name.Contains("Pelvis"))
				{
					configurableJoint.xMotion = ConfigurableJointMotion.Free;
					configurableJoint.yMotion = ConfigurableJointMotion.Free;
					configurableJoint.zMotion = ConfigurableJointMotion.Free;
				}
				else
				{
					configurableJoint.connectedBody = componentsInChildren3[k].parent.GetComponent<Rigidbody>();
					configurableJoint.xMotion = ConfigurableJointMotion.Locked;
					configurableJoint.yMotion = ConfigurableJointMotion.Locked;
					configurableJoint.zMotion = ConfigurableJointMotion.Locked;
				}
				configurableJoint.angularXMotion = ConfigurableJointMotion.Free;
				configurableJoint.angularYMotion = ConfigurableJointMotion.Free;
				configurableJoint.angularZMotion = ConfigurableJointMotion.Free;
				configurableJoint.rotationDriveMode = RotationDriveMode.Slerp;
				if (componentsInChildren3[k].name.Contains("Spine"))
				{
					configurableJoint.anchor = Vector3.right * 0.15f;
				}
				else if (componentsInChildren3[k].name.Contains("Bip001 Head"))
				{
					configurableJoint.anchor = Vector3.right * 0.15f;
				}
			}
		}
		UnityEngine.Debug.Log("조인트 추가.");
		for (int l = 0; l < componentsInChildren3.Length; l++)
		{
			if (componentsInChildren3[l].name.Contains("Pelvis"))
			{
				CapsuleCollider capsuleCollider = componentsInChildren3[l].gameObject.AddComponent<CapsuleCollider>();
				capsuleCollider.center = new Vector3(-0.13f, 0.01f, 0f);
				capsuleCollider.radius = 0.13f;
				capsuleCollider.height = 0.3f;
				capsuleCollider.direction = 2;
			}
			else if (componentsInChildren3[l].name.Contains("Thigh"))
			{
				CapsuleCollider capsuleCollider2 = componentsInChildren3[l].gameObject.AddComponent<CapsuleCollider>();
				capsuleCollider2.center = new Vector3(-0.35f, 0f, 0f);
				capsuleCollider2.radius = 0.1f;
				capsuleCollider2.height = 0.35f;
				capsuleCollider2.direction = 0;
			}
			else if (componentsInChildren3[l].name.Contains("Calf"))
			{
				CapsuleCollider capsuleCollider3 = componentsInChildren3[l].gameObject.AddComponent<CapsuleCollider>();
				capsuleCollider3.center = new Vector3(-0.2f, 0f, 0f);
				capsuleCollider3.radius = 0.08f;
				capsuleCollider3.height = 0.25f;
				capsuleCollider3.direction = 0;
			}
			else if (componentsInChildren3[l].name.Contains("Foot"))
			{
				BoxCollider boxCollider = componentsInChildren3[l].gameObject.AddComponent<BoxCollider>();
				boxCollider.center = new Vector3(-0.03f, 0.1f, 0f);
				boxCollider.size = new Vector3(0.1f, 0.3f, 0.1f);
			}
			else if (componentsInChildren3[l].name.Contains("Spine"))
			{
				CapsuleCollider capsuleCollider4 = componentsInChildren3[l].gameObject.AddComponent<CapsuleCollider>();
				capsuleCollider4.center = new Vector3(0.02f, -0.02f, 0f);
				capsuleCollider4.radius = 0.1f;
				capsuleCollider4.height = 0.33f;
				capsuleCollider4.direction = 2;
			}
			else if (componentsInChildren3[l].name.Contains("UpperArm"))
			{
				CapsuleCollider capsuleCollider5 = componentsInChildren3[l].gameObject.AddComponent<CapsuleCollider>();
				capsuleCollider5.center = new Vector3(-0.2f, 0f, 0f);
				capsuleCollider5.radius = 0.05f;
				capsuleCollider5.height = 0.3f;
				capsuleCollider5.direction = 0;
			}
			else if (componentsInChildren3[l].name.Contains("Forearm"))
			{
				CapsuleCollider capsuleCollider6 = componentsInChildren3[l].gameObject.AddComponent<CapsuleCollider>();
				capsuleCollider6.center = new Vector3(-0.15f, 0f, 0f);
				capsuleCollider6.radius = 0.05f;
				capsuleCollider6.height = 0.2f;
				capsuleCollider6.direction = 0;
			}
			else if (componentsInChildren3[l].name.Contains("Hand"))
			{
				SphereCollider sphereCollider = componentsInChildren3[l].gameObject.AddComponent<SphereCollider>();
				sphereCollider.center = new Vector3(-0.07f, 0.035f, 0f);
				sphereCollider.radius = 0.1f;
			}
			else if (componentsInChildren3[l].name.Contains("Head"))
			{
				CapsuleCollider capsuleCollider7 = componentsInChildren3[l].gameObject.AddComponent<CapsuleCollider>();
				capsuleCollider7.center = new Vector3(-0.05f, 0.05f, 0f);
				capsuleCollider7.radius = 0.1f;
				capsuleCollider7.height = 0.3f;
				capsuleCollider7.direction = 0;
			}
		}
		UnityEngine.Debug.Log("콜라이더 추가.");
		Transform[] componentsInChildren4 = transform2.GetComponentsInChildren<Transform>();
		BoxerCtrl boxerCtrl = transform2.gameObject.AddComponent<BoxerCtrl>();
		UnityEngine.Debug.Log("BoxerCtrl 스크립트 추가.");
		boxerCtrl.bones = new BoxerCtrl.Bone[15];
		string text = "Pelvis";
		boxerCtrl.bones[0].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[0].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[0].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "L Thigh";
		boxerCtrl.bones[1].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[1].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[1].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "L Calf";
		boxerCtrl.bones[2].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[2].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[2].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "L Foot";
		boxerCtrl.bones[3].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[3].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[3].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "R Thigh";
		boxerCtrl.bones[4].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[4].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[4].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "R Calf";
		boxerCtrl.bones[5].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[5].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[5].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "R Foot";
		boxerCtrl.bones[6].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[6].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[6].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "Spine2";
		boxerCtrl.bones[7].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[7].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[7].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "L UpperArm";
		boxerCtrl.bones[8].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[8].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[8].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "L Forearm";
		boxerCtrl.bones[9].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[9].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[9].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "L Hand";
		boxerCtrl.bones[10].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[10].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[10].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "Head";
		boxerCtrl.bones[11].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[11].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[11].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "R UpperArm";
		boxerCtrl.bones[12].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[12].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[12].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "R Forearm";
		boxerCtrl.bones[13].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[13].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[13].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		text = "R Hand";
		boxerCtrl.bones[14].orizin = FindObject(text, componentsInChildren4);
		boxerCtrl.bones[14].ragdoll_joint = FindObject(text, componentsInChildren3).GetComponent<ConfigurableJoint>();
		boxerCtrl.bones[14].ragdoll_rb = FindObject(text, componentsInChildren3).GetComponent<Rigidbody>();
		boxerCtrl.spine0Tr = FindObject("Spine", componentsInChildren4);
		boxerCtrl.spine1Tr = FindObject("Spine1", componentsInChildren4);
		boxerCtrl.neckTr = FindObject("Neck", componentsInChildren4);
		boxerCtrl.clavicleLTr = FindObject("L Clavicle", componentsInChildren4);
		boxerCtrl.clavicleRTr = FindObject("R Clavicle", componentsInChildren4);
		UnityEngine.Debug.Log("BoxerCtrl Bone 등록");
	}

	private Transform FindObject(string name, Transform[] transforms)
	{
		for (int i = 0; i < transforms.Length; i++)
		{
			if (transforms[i].name.Contains(name) && (!(name == "Spine") || (!transforms[i].name.Contains("1") && !transforms[i].name.Contains("2"))))
			{
				return transforms[i];
			}
		}
		return null;
	}
}
public class RenderOriginCamCtrl : MonoBehaviour
{
	private Camera cam_renderTex;

	private Transform cam_orizin;

	private Transform cam_overlay;

	public Transform plane;

	private RenderTexture renderTexture;

	private MeshRenderer meshRenderer;

	private bool isInit;

	public void Init(Transform _cam_orizin, Transform _cam_overlay)
	{
		cam_renderTex = base.transform.GetComponent<Camera>();
		renderTexture = cam_renderTex.targetTexture;
		cam_orizin = _cam_orizin;
		cam_overlay = _cam_overlay;
		cam_renderTex.cullingMask = cam_orizin.GetComponent<Camera>().cullingMask;
		plane.gameObject.layer = 31;
		meshRenderer = plane.GetComponent<MeshRenderer>();
		isInit = true;
	}

	public void Init(Transform _cam_orizin)
	{
		cam_orizin = _cam_orizin;
		cam_renderTex.cullingMask = cam_orizin.GetComponent<Camera>().cullingMask;
	}

	private void LateUpdate()
	{
		if (isInit && !(cam_orizin == null) && PublicGameUIManager.GetInstance.IsOverlay())
		{
			base.transform.SetPositionAndRotation(cam_orizin.position, cam_orizin.rotation);
			plane.SetPositionAndRotation(cam_overlay.position + cam_overlay.forward * 20f, cam_overlay.rotation);
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = renderTexture;
			cam_renderTex.Render();
			RenderTexture.active = active;
			Vector3 localPosition = cam_overlay.localPosition;
			localPosition.y = 0f;
			meshRenderer.sharedMaterial.SetFloat("_Black", Mathf.Lerp(0.05f, 0f, localPosition.sqrMagnitude - 3f));
		}
	}
}
public class StaticLocalizationCtrl : SingletonBase.Singleton<StaticLocalizationCtrl>
{
	[Serializable]
	public class DataSlot
	{
		public string id;

		public Text ui;
	}

	public DataSlot[] dataSlots;

	private bool isInit;

	private void Start()
	{
		if (GameSettingCtrl.localizationInfos != null && GameSettingCtrl.localizationInfos.Count != 0)
		{
			SetLocaliztion();
		}
	}

	public void AddData(string _id, Text ui_text)
	{
		Array.Resize(ref dataSlots, dataSlots.Length + 1);
		int num = dataSlots.Length - 1;
		dataSlots[num] = new DataSlot();
		dataSlots[num].id = _id;
		dataSlots[num].ui = ui_text;
		if (isInit)
		{
			dataSlots[num].ui.text = GameSettingCtrl.GetLocalizationText(dataSlots[num].id);
		}
	}

	public void SetLocaliztion()
	{
		isInit = true;
		SetDataReduction();
		for (int i = 0; i < dataSlots.Length; i++)
		{
			dataSlots[i].ui.text = GameSettingCtrl.GetLocalizationText(dataSlots[i].id);
		}
	}

	public void SetDataReduction()
	{
		List<DataSlot> list = new List<DataSlot>();
		for (int i = 0; i < dataSlots.Length; i++)
		{
			if (!(dataSlots[i].ui == null) && !string.IsNullOrWhiteSpace(dataSlots[i].id))
			{
				list.Add(dataSlots[i]);
			}
		}
		dataSlots = list.ToArray();
	}
}
public class StaticLocalizationCtrl_TextMesh : SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>
{
	[Serializable]
	public class DataSlot
	{
		public string id;

		public TextMesh ui;
	}

	[Serializable]
	public class DataSlot_Pro
	{
		public string id;

		public TextMeshPro ui;
	}

	public TextMesh textMesh;

	public TextMeshPro textMeshPro;

	public DataSlot[] dataSlots;

	public DataSlot_Pro[] dataSlots_pro;

	private bool isInit;

	private void Start()
	{
		if (GameSettingCtrl.localizationInfos != null && GameSettingCtrl.localizationInfos.Count != 0)
		{
			SetLocaliztion();
		}
	}

	public void AddData(string _id, TextMesh ui_text)
	{
		Array.Resize(ref dataSlots, dataSlots.Length + 1);
		int num = dataSlots.Length - 1;
		dataSlots[num] = new DataSlot();
		dataSlots[num].id = _id;
		dataSlots[num].ui = ui_text;
		if (isInit)
		{
			dataSlots[num].ui.text = GameSettingCtrl.GetLocalizationText(dataSlots[num].id);
		}
	}

	public void AddData(string _id, TextMeshPro ui_text)
	{
		Array.Resize(ref dataSlots_pro, dataSlots_pro.Length + 1);
		int num = dataSlots_pro.Length - 1;
		dataSlots_pro[num] = new DataSlot_Pro();
		dataSlots_pro[num].id = _id;
		dataSlots_pro[num].ui = ui_text;
		if (isInit)
		{
			dataSlots_pro[num].ui.text = GameSettingCtrl.GetLocalizationText(dataSlots_pro[num].id);
		}
	}

	public void SetLocaliztion()
	{
		isInit = true;
		SetDataReduction();
		for (int i = 0; i < dataSlots.Length; i++)
		{
			dataSlots[i].ui.text = GameSettingCtrl.GetLocalizationText(dataSlots[i].id);
		}
		for (int j = 0; j < dataSlots_pro.Length; j++)
		{
			dataSlots_pro[j].ui.text = GameSettingCtrl.GetLocalizationText(dataSlots_pro[j].id);
		}
	}

	public void SetDataReduction()
	{
		List<DataSlot> list = new List<DataSlot>();
		for (int i = 0; i < dataSlots.Length; i++)
		{
			if (!(dataSlots[i].ui == null) && !string.IsNullOrWhiteSpace(dataSlots[i].id))
			{
				list.Add(dataSlots[i]);
			}
		}
		dataSlots = list.ToArray();
		List<DataSlot_Pro> list2 = new List<DataSlot_Pro>();
		for (int j = 0; j < dataSlots_pro.Length; j++)
		{
			if (!(dataSlots_pro[j].ui == null) && !string.IsNullOrWhiteSpace(dataSlots_pro[j].id))
			{
				list2.Add(dataSlots_pro[j]);
			}
		}
		dataSlots_pro = list2.ToArray();
	}
}
public class StaticResourcesChangeCtrl : SingletonBase.Singleton<StaticResourcesChangeCtrl>
{
	[Serializable]
	public class DataSlot_SetActive
	{
		public GameObject[] gos;
	}

	[Serializable]
	public class DataSlot_SetTexture
	{
		public string name;

		public Material mat;

		public Texture[] tex;
	}

	[Serializable]
	public class DataSlot_SetMesh
	{
		public MeshFilter meshFilter;

		public Mesh[] meshes;
	}

	[Serializable]
	public class DataSlot_SetVoice
	{
		public string field;

		public MonoBehaviour sound_script;

		public AudioClipSlot[] clipSlots = new AudioClipSlot[0];
	}

	[Serializable]
	public class AudioClipSlot
	{
		public AudioClip[] clips = new AudioClip[0];
	}

	public LanguageState[] languageStates;

	public DataSlot_SetActive[] dataSlots_setActive;

	public DataSlot_SetTexture[] dataSlots_setTexture;

	public DataSlot_SetMesh[] dataSlots_setMesh;

	public DataSlot_SetVoice[] dataSlots_setVoice;

	private bool isInit;

	private void Start()
	{
		SetData();
	}

	public void SetData()
	{
		isInit = true;
		SetDataReduction();
		LanguageState languageState = PublicGameUIManager.gameSetting.GetLanguageState();
		int num = languageStates.Length;
		for (int i = 0; i < languageStates.Length; i++)
		{
			if (languageState == languageStates[i])
			{
				num = i;
				break;
			}
		}
		if (dataSlots_setActive != null)
		{
			for (int j = 0; j < dataSlots_setActive.Length; j++)
			{
				for (int k = 0; k < dataSlots_setActive[j].gos.Length; k++)
				{
					dataSlots_setActive[j].gos[k].SetActive(k == num);
				}
			}
		}
		if (dataSlots_setTexture != null)
		{
			for (int l = 0; l < dataSlots_setTexture.Length; l++)
			{
				dataSlots_setTexture[l].mat.SetTexture(dataSlots_setTexture[l].name, dataSlots_setTexture[l].tex[num]);
			}
		}
		if (dataSlots_setMesh != null)
		{
			for (int m = 0; m < dataSlots_setMesh.Length; m++)
			{
				dataSlots_setMesh[m].meshFilter.mesh = dataSlots_setMesh[m].meshes[num];
			}
		}
		if (dataSlots_setVoice != null)
		{
			for (int n = 0; n < dataSlots_setVoice.Length; n++)
			{
				dataSlots_setVoice[n].sound_script.GetType().GetField(dataSlots_setVoice[n].field).SetValue(dataSlots_setVoice[n].sound_script, dataSlots_setVoice[n].clipSlots[num].clips);
			}
		}
	}

	public void SetDataReduction()
	{
	}
}
public class TestCameraShotCtrl : MonoBehaviour
{
	public Transform targetTr;

	public Vector3 sumPos = Vector3.zero;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.P))
		{
			string text = UnityEngine.Application.dataPath + "/" + DateTime.Now.ToString("MMddyyHHmmss") + "_SS.png";
			ScreenCapture.CaptureScreenshot(text, 4);
			UnityEngine.Debug.LogError(text);
		}
		if (targetTr != null)
		{
			base.transform.rotation = Quaternion.LookRotation((targetTr.position + sumPos - base.transform.position).normalized);
		}
	}
}
public class TestCustomCharKeep : MonoBehaviour
{
	public List<CustomModelData> customizeModelDatas;

	public void SetData(int index)
	{
		customizeModelDatas[index] = CustomModelSettingCtrl.GetRandomModelData();
	}

	public void AddData()
	{
		if (customizeModelDatas.Count != 50)
		{
			customizeModelDatas.Add(new CustomModelData());
		}
	}

	public void RemoveData()
	{
		if (customizeModelDatas.Count != 0)
		{
			customizeModelDatas.RemoveAt(customizeModelDatas.Count - 1);
		}
	}
}
public class TestDrawingCtrl : MonoBehaviour
{
	public Transform rayTr;

	public LayerMask layerMask;

	private RenderTexture drawTex;

	public Texture2D brushTex;

	public float brushSize = 1f;

	private void Start()
	{
		base.transform.GetComponent<MeshRenderer>().material = new Material(Shader.Find("Universal Render Pipeline/Lit"));
		drawTex = new RenderTexture(64, 64, 32);
		Graphics.Blit(Texture2D.whiteTexture, drawTex);
		base.transform.GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", drawTex);
	}

	private void Update()
	{
		if (Physics.Raycast(rayTr.position, rayTr.forward, out var hitInfo, 0.5f, layerMask))
		{
			UnityEngine.Debug.LogError(hitInfo.textureCoord.x + "  " + hitInfo.textureCoord.y);
			DrawTexture(drawTex, hitInfo.textureCoord.x * 64f, hitInfo.textureCoord.y * 64f);
		}
	}

	private void DrawTexture(RenderTexture rt, float posX, float posY)
	{
		RenderTexture.active = rt;
		GL.PushMatrix();
		GL.LoadPixelMatrix(0f, 64f, 64f, 0f);
		Graphics.DrawTexture(new Rect(posX - (float)brushTex.width / brushSize, (float)rt.height - posY - (float)brushTex.height / brushSize, (float)brushTex.width / (brushSize * 0.5f), (float)brushTex.height / (brushSize * 0.5f)), brushTex);
		GL.PopMatrix();
		RenderTexture.active = null;
	}
}
public class UIPageCtrl : MonoBehaviour
{
	private bool isInit;

	private Text text_page;

	public ItemUIPart item_part;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		if (!isInit)
		{
			isInit = true;
			text_page = base.transform.Find("Canvas/Text").GetComponent<Text>();
			SingletonBase.Singleton<CustomizeManager>.GetInstance.InitPageUI(this);
		}
	}

	public void SetPage(int current_page, int max_page)
	{
		UnityEngine.Debug.LogError(string.Concat(item_part, " - ", max_page));
		Init();
		text_page.text = current_page + 1 + " / " + (max_page + 1);
		base.gameObject.SetActive(max_page != 0);
	}

	public void ClickNextPage()
	{
		SingletonBase.Singleton<CustomizeManager>.GetInstance.SetNextPage((int)item_part);
	}

	public void ClickBackPage()
	{
		SingletonBase.Singleton<CustomizeManager>.GetInstance.SetBackPage((int)item_part);
	}
}
public class UserInfoManager : SingletonBase.Singleton<UserInfoManager>
{
	[Serializable]
	public class UserInfoData_DB
	{
		public string ClearData;

		public int Win;

		public int Lose;

		public int Disconnect;
	}

	[Serializable]
	public class DisCount_DB
	{
		public string ClearData;

		public int Disconnect;
	}

	[Serializable]
	public class AchievementInfo
	{
		public string api_name;

		public bool is_archived;

		public string title;

		public string description;

		public string unlocked_description_override;

		public string image_uri;

		public int velue_current;

		public int velue_target;
	}

	[Serializable]
	public class AchievementInfo_Steam
	{
		[Serializable]
		public class SteamData
		{
			public AvailableGameStats availableGameStats;
		}

		[Serializable]
		public class AvailableGameStats
		{
			public Achievement[] achievements;
		}

		[Serializable]
		public class Achievement
		{
			public string name;

			public string displayName;

			public string description;

			public string icon;
		}

		public SteamData game;
	}

	[Serializable]
	public class PlayerData_Steam
	{
		[Serializable]
		public class Response
		{
			public Player[] players;
		}

		[Serializable]
		public class Player
		{
			public string avatar;
		}

		public Response response;
	}

	[Serializable]
	public class AchievementInfo_Oculus
	{
		[Serializable]
		public class OculusData
		{
			public string api_name;

			public int target;

			public string title;

			public string description;

			public string unlocked_description_override;

			public string unlocked_image_uri;
		}

		public OculusData[] data;
	}

	[Serializable]
	public struct UserInfo
	{
		public string id;

		public string nick;
	}

	public enum UnlockAchieveState
	{
		Add,
		Change
	}

	private string appID = "3840611616056575";

	private string access_token = "OC|3840611616056575|2dca2ef3e8288879b3ad728697005d23";

	public const string addr = "https://api-global.appnori.com/AIO/";

	public static string image_url_mine;

	private static string imageCachePath;

	private static SHA1CryptoServiceProvider s_SHA1 = new SHA1CryptoServiceProvider();

	public bool isGetNetData;

	public int state_setNetData;

	public int score_win_mine;

	public int score_lose_mine;

	public int score_disconnect_mine;

	private int state_setMultiResult;

	private float delayTime_setMultiResult;

	public Dictionary<string, AchievementInfo> dict_achieve;

	public bool isInit;

	public UserInfo userInfo_mine;

	public UserInfo[] userInfos;

	private int updateInfoNum;

	private Coroutine getAchieveListCoroutine;

	private Coroutine updateDisCountCoroutine;

	private Coroutine getUserDataCoroutine;

	private Coroutine setMultiResultScoreCoroutine;

	private void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		isInit = false;
		isGetNetData = false;
		userInfo_mine = default(UserInfo);
		userInfo_mine.id = "";
		userInfo_mine.nick = "";
		userInfos = new UserInfo[2];
		for (int i = 0; i < userInfos.Length; i++)
		{
			userInfos[i] = default(UserInfo);
			userInfos[i].id = "";
			userInfos[i].nick = "";
		}
		Init();
	}

	private void Init()
	{
		UnityEngine.Debug.Log("Start OCULUS_PLATFORM.");
		try
		{
			Core.AsyncInitialize(appID).OnComplete(delegate(Message<PlatformInitialize> msg)
			{
				if (msg.IsError)
				{
					UnityEngine.Debug.LogError("Init failed.");
				}
				else
				{
					UnityEngine.Debug.Log("Init success.");
				}
			});
			Users.GetLoggedInUser().OnComplete(delegate(Message<User> msg)
			{
				Oculus.Platform.Application.GetVersion().OnComplete(delegate(Message<ApplicationVersion> msg_version)
				{
					if (msg_version.Data.CurrentCode == -1)
					{
						updateInfoNum = 1;
					}
					else if (msg_version.Data.CurrentCode >= msg_version.Data.LatestCode)
					{
						updateInfoNum = 1;
					}
					else
					{
						updateInfoNum = -1;
					}
				});
				if (msg.IsError)
				{
					UnityEngine.Debug.LogError("GetUserInfo failed." + msg.GetError().Message);
				}
				else
				{
					UnityEngine.Debug.Log("GetUserInfo success.");
					isInit = true;
					userInfo_mine = default(UserInfo);
					userInfo_mine.id = "OC" + msg.Data.ID;
					userInfo_mine.nick = msg.Data.OculusID;
					image_url_mine = msg.Data.ImageURL;
					if (string.IsNullOrWhiteSpace(image_url_mine))
					{
						image_url_mine = "Null";
					}
					userInfos = new UserInfo[2];
					userInfos[0] = default(UserInfo);
					userInfos[1] = default(UserInfo);
					GetUserData();
					StartCoroutine(GetAchieveList());
				}
			});
			Request.RunCallbacks();
		}
		catch (UnityException)
		{
			UnityEngine.Debug.LogError("OCULUS_PLATFORM failed.");
			throw;
		}
	}

	public int UpdateState()
	{
		return updateInfoNum;
	}

	public void GetTest(int count = 0)
	{
		StartCoroutine(GetTestCoroutine(count));
	}

	private IEnumerator GetTestCoroutine(int count = 0)
	{
		List<IMultipartFormSection> multipartFormSections = new List<IMultipartFormSection>();
		UnityWebRequest www = UnityWebRequest.Post("8.218.90.99/AIO/TestTest.php", multipartFormSections);
		yield return www.SendWebRequest();
		UnityEngine.Debug.Log(www.downloadHandler.text);
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
		}
		else
		{
			UnityEngine.Debug.Log("Form upload complete!");
		}
	}

	private void Update()
	{
		if (delayTime_setMultiResult > 0f)
		{
			delayTime_setMultiResult -= Time.deltaTime;
		}
	}

	public void StartGetAchieveList()
	{
		if (getAchieveListCoroutine != null)
		{
			StopCoroutine(getAchieveListCoroutine);
		}
		getAchieveListCoroutine = StartCoroutine(GetAchieveList());
	}

	private IEnumerator GetAchieveList()
	{
		string uri = "https://graph.oculus.com/" + appID + "/achievement_definitions?access_token=" + access_token + "&fields=api_name,title,description,unlocked_description_override,locked_image_uri,unlocked_image_uri,target";
		UnityWebRequest www = UnityWebRequest.Get(uri);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		UnityEngine.Debug.Log(www.downloadHandler.text);
		AchievementInfo_Oculus jsonAchievement = JsonUtility.FromJson<AchievementInfo_Oculus>(www.downloadHandler.text);
		Array.Reverse((Array)jsonAchievement.data);
		for (int i = 0; i < jsonAchievement.data.Length; i++)
		{
			UnityEngine.Debug.Log(jsonAchievement.data[i].api_name);
		}
		Achievements.GetAllProgress().OnComplete(delegate(Message<AchievementProgressList> msg)
		{
			if (msg.IsError)
			{
				UnityEngine.Debug.LogError("Platform: GetLoggedInUser() failed. Reason: " + msg.GetError().Message);
			}
			else
			{
				AchievementProgress[] array = msg.Data.ToArray();
				int num = jsonAchievement.data.Length;
				dict_achieve = new Dictionary<string, AchievementInfo>();
				for (int j = 0; j < num; j++)
				{
					AchievementInfo achievementInfo = new AchievementInfo
					{
						api_name = jsonAchievement.data[j].api_name,
						title = jsonAchievement.data[j].title,
						description = jsonAchievement.data[j].description,
						unlocked_description_override = jsonAchievement.data[j].unlocked_description_override,
						image_uri = jsonAchievement.data[j].unlocked_image_uri,
						velue_target = jsonAchievement.data[j].target
					};
					for (int k = 0; k < array.Length; k++)
					{
						if (array[k].Name.Contains(achievementInfo.api_name))
						{
							achievementInfo.is_archived = array[k].IsUnlocked;
							achievementInfo.velue_current = (int)array[k].Count;
							break;
						}
					}
					dict_achieve.Add(achievementInfo.api_name, achievementInfo);
				}
				if (SceneManager.GetActiveScene().name == "Scene_Lobby")
				{
					StartCoroutine(SingletonBase.Singleton<LobbyUIManager>.GetInstance.achievement.SetAchieve());
				}
			}
		});
	}

	public void UpdateDisCount()
	{
		if (updateDisCountCoroutine != null)
		{
			StopCoroutine(updateDisCountCoroutine);
		}
		updateDisCountCoroutine = StartCoroutine(UpdateDisCountCoroutine());
	}

	private IEnumerator UpdateDisCountCoroutine()
	{
		List<IMultipartFormSection> list = new List<IMultipartFormSection>();
		list.Add(new MultipartFormDataSection("UserID", userInfo_mine.id));
		list.Add(new MultipartFormDataSection("Count_Dis", PlayerPrefs.GetInt("count_dis", 0).ToString()));
		UnityWebRequest www = UnityWebRequest.Post("https://api-global.appnori.com/AIO/UpdateDisCount.php", list);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		UnityEngine.Debug.Log(www.downloadHandler.text);
		PlayerPrefs.SetInt("count_dis", 0);
		DisCount_DB disCount_DB = JsonUtility.FromJson<DisCount_DB>(www.downloadHandler.text);
		UnityEngine.Debug.Log(disCount_DB.Disconnect);
		score_disconnect_mine = disCount_DB.Disconnect;
	}

	public void GetUserData(int count = 0)
	{
		state_setNetData = 1;
		if (getUserDataCoroutine != null)
		{
			StopCoroutine(getUserDataCoroutine);
		}
		getUserDataCoroutine = StartCoroutine(GetUserDataCoroutine(count));
	}

	private IEnumerator GetUserDataCoroutine(int count = 0)
	{
		List<IMultipartFormSection> list = new List<IMultipartFormSection>();
		list.Add(new MultipartFormDataSection("UserID", userInfo_mine.id));
		list.Add(new MultipartFormDataSection("Nick", userInfo_mine.nick));
		list.Add(new MultipartFormDataSection("Image_URL", image_url_mine));
		string @string = PlayerPrefs.GetString("clearLevelData", "00000000000");
		char[] array = @string.ToCharArray();
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas = new int[11];
		for (int i = 0; i < SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas.Length; i++)
		{
			if (i >= array.Length)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas[i] = 0;
			}
			else
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas[i] = (int)char.GetNumericValue(array[i]);
			}
		}
		list.Add(new MultipartFormDataSection("ClearData", @string));
		list.Add(new MultipartFormDataSection("Count_Dis", "0"));
		UnityWebRequest www = UnityWebRequest.Post("https://api-global.appnori.com/AIO/UpdateUserInfo.php", list);
		www.timeout = 5;
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			if (count >= 10)
			{
				UnityEngine.Debug.Log(www.error);
				state_setNetData = -1;
			}
			else
			{
				yield return new WaitForSeconds(2f);
				GetUserData(count + 1);
			}
		}
		else
		{
			UnityEngine.Debug.Log("Form upload complete!");
			UserInfoData_DB userInfoData_DB = JsonUtility.FromJson<UserInfoData_DB>(www.downloadHandler.text);
			array = userInfoData_DB.ClearData.ToCharArray();
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas = new int[11];
			for (int j = 0; j < SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas.Length; j++)
			{
				if (j >= array.Length)
				{
					SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas[j] = 0;
				}
				else
				{
					SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.clearLevelDatas[j] = (int)char.GetNumericValue(array[j]);
				}
			}
			score_win_mine = userInfoData_DB.Win;
			score_lose_mine = userInfoData_DB.Lose;
			score_disconnect_mine = userInfoData_DB.Disconnect + PlayerPrefs.GetInt("count_dis", 0);
			state_setNetData = 0;
			isGetNetData = true;
			UpdateDisCount();
		}
		if (SceneManager.GetActiveScene().name == "Scene_Lobby")
		{
			while (dict_achieve == null || dict_achieve.Count == 0)
			{
				yield return null;
			}
			if (SceneManager.GetActiveScene().name == "Scene_Lobby" && SingletonBase.Singleton<LobbyUIManager>.Instance != null)
			{
				SingletonBase.Singleton<LobbyUIManager>.GetInstance.medalView.Init();
			}
		}
	}

	public void SetMultiResultScore(string[] players, int win_index, bool isDisconnect = false, int count = 0)
	{
		if ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi || (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && GameData_DDOL.singleManager != null)) && !(userInfos[0].id == userInfos[0].nick) && !(userInfos[1].id == userInfos[1].nick) && !(players[0] == players[1]) && !(delayTime_setMultiResult > 0f))
		{
			state_setMultiResult = 1;
			delayTime_setMultiResult = 5f;
			if (setMultiResultScoreCoroutine != null)
			{
				StopCoroutine(setMultiResultScoreCoroutine);
			}
			setMultiResultScoreCoroutine = StartCoroutine(SetMultiResultScoreCoroutine(players, win_index, isDisconnect, count));
		}
	}

	private IEnumerator SetMultiResultScoreCoroutine(string[] players, int win_index, bool isDisconnect, int count = 0)
	{
		List<IMultipartFormSection> list = new List<IMultipartFormSection>();
		list.Add(new MultipartFormDataSection("UserID_0", players[0]));
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
		{
			list.Add(new MultipartFormDataSection("UserID_1", "C"));
		}
		else
		{
			list.Add(new MultipartFormDataSection("UserID_1", players[1]));
		}
		list.Add(new MultipartFormDataSection("Win", win_index.ToString()));
		list.Add(new MultipartFormDataSection("State", isDisconnect ? "D" : "N"));
		UnityWebRequest www = UnityWebRequest.Post("https://api-global.appnori.com/AIO/SetResultScore.php", list);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			if (count >= 3)
			{
				state_setMultiResult = -1;
				yield break;
			}
			yield return new WaitForSeconds(2f);
			SetMultiResultScore(players, win_index, isDisconnect, count + 1);
		}
		else
		{
			UnityEngine.Debug.Log("Form upload complete!");
			UnityEngine.Debug.Log(www.downloadHandler.text);
			state_setMultiResult = 0;
		}
	}

	public void UnlockAchieve(string achieveName, int velue, UnlockAchieveState unlockAchieveState = UnlockAchieveState.Add)
	{
		switch (achieveName)
		{
		case "Ach04":
		case "Ach05":
		case "Ach06":
		case "Ach07":
			achieveName = "Ach04";
			break;
		}
		if (!dict_achieve.ContainsKey(achieveName) || dict_achieve[achieveName].is_archived)
		{
			return;
		}
		if (dict_achieve[achieveName].velue_target == 0)
		{
			Achievements.Unlock(dict_achieve[achieveName].api_name);
			dict_achieve[achieveName].is_archived = true;
			return;
		}
		_ = dict_achieve[achieveName].velue_current;
		if (unlockAchieveState == UnlockAchieveState.Add)
		{
			dict_achieve[achieveName].velue_current = Mathf.Clamp(dict_achieve[achieveName].velue_current + velue, 0, dict_achieve[achieveName].velue_target);
		}
		else
		{
			if (dict_achieve[achieveName].velue_current >= velue)
			{
				return;
			}
			dict_achieve[achieveName].velue_current = Mathf.Clamp(velue, 0, dict_achieve[achieveName].velue_target);
		}
		Achievements.AddCount(achieveName, (ulong)dict_achieve[achieveName].velue_current);
		if (dict_achieve[achieveName].velue_current >= dict_achieve[achieveName].velue_target)
		{
			dict_achieve[achieveName].is_archived = true;
			Achievements.Unlock(achieveName);
		}
	}

	public void SetImage(string url, RawImage set_ui_image)
	{
		set_ui_image.texture = null;
		if (url != null && url.Length >= 10)
		{
			StartCoroutine(SetImageCoroutine(url, set_ui_image));
		}
	}

	private IEnumerator SetImageCoroutine(string url, RawImage set_ui_image)
	{
		string check_url = CheckCacheData(url);
		Texture2D texture = new Texture2D(2, 2);
		if (!check_url.Contains("https://"))
		{
			texture.LoadImage(File.ReadAllBytes(check_url));
			set_ui_image.texture = texture;
			yield break;
		}
		UnityWebRequest www = UnityWebRequest.Get(check_url);
		yield return www.SendWebRequest();
		if (www.isNetworkError || www.isHttpError)
		{
			UnityEngine.Debug.Log(www.error);
			yield break;
		}
		byte[] data = www.downloadHandler.data;
		if (check_url.Contains(url))
		{
			File.WriteAllBytes(GetCachePath(url), data);
		}
		texture.LoadImage(data);
		set_ui_image.texture = texture;
	}

	public static string GetCachePath(string url)
	{
		if (imageCachePath == null)
		{
			imageCachePath = UnityEngine.Application.temporaryCachePath + "/Cache/";
		}
		if (!Directory.Exists(imageCachePath))
		{
			Directory.CreateDirectory(imageCachePath);
		}
		return imageCachePath + Convert.ToBase64String(s_SHA1.ComputeHash(Encoding.Default.GetBytes(url))).Replace('/', '_');
	}

	public static string CheckCacheData(string url)
	{
		string cachePath = GetCachePath(url);
		if (new FileInfo(cachePath).Exists)
		{
			return cachePath;
		}
		return url;
	}

	public bool IsUnlockAchieve(string achieveName)
	{
		if (dict_achieve == null || dict_achieve.Count == 0)
		{
			return false;
		}
		if (!dict_achieve.ContainsKey(achieveName))
		{
			return false;
		}
		return dict_achieve[achieveName].is_archived;
	}

	public string GetAchieveInfo(string achieveName)
	{
		if (dict_achieve == null || dict_achieve.Count == 0)
		{
			return "";
		}
		if (!dict_achieve.ContainsKey(achieveName))
		{
			return "";
		}
		return dict_achieve[achieveName].description;
	}

	private void OnDestroy()
	{
	}
}
public class VersionCtrl : MonoBehaviour
{
	private void Start()
	{
		PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetText);
	}

	public void SetText(LanguageState languageState)
	{
		base.transform.GetComponent<TextMesh>().text = GameSettingCtrl.GetLocalizationText("0158") + "\n" + UnityEngine.Application.version;
	}
}
public class WaitingSingleManager : MonoBehaviourPunCallbacks
{
	private float keep_timeScale = 1f;

	public string keep_serverCode = "";

	private Coroutine matchCoroutine;

	private void Start()
	{
		SceneManager.sceneLoaded += OnSceneLoaded;
		SceneManager.sceneUnloaded += OnSceneUnloaded;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		GameData_DDOL.singleManager = this;
	}

	private void OnSceneLoaded(Scene scene, LoadSceneMode mode)
	{
		if (scene.name == "Scene_Lobby")
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi || scene.buildIndex == 0)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		UnityEngine.Debug.Log(scene.buildIndex);
		Invoke("StartConnect", 2f);
	}

	private void OnSceneUnloaded(Scene current)
	{
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
		{
			UnityEngine.Debug.Log("OnSceneUnloaded: " + current);
			if (PhotonNetwork.IsConnected)
			{
				PhotonNetwork.Disconnect();
			}
		}
	}

	public void StartConnect()
	{
		PhotonNetwork.PhotonServerSettings.AppSettings.FixedRegion = keep_serverCode;
		PhotonNetwork.ConnectUsingSettings();
	}

	public override void OnConnectedToMaster()
	{
		if (!PhotonNetwork.InLobby)
		{
			PhotonNetwork.JoinLobby();
		}
	}

	public override void OnJoinedLobby()
	{
		Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
		roomOptions.PublishUserId = true;
		roomOptions.MaxPlayers = 2;
		roomOptions.CustomRoomProperties = new ExitGames.Client.Photon.Hashtable();
		roomOptions.CustomRoomProperties.Add("GameType", SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType);
		roomOptions.CustomRoomProperties.Add("Code", "");
		roomOptions.CustomRoomPropertiesForLobby = new string[2] { "GameType", "Code" };
		GameData_DDOL.GameType gameType = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType;
		if ((uint)(gameType - 1) <= 3u)
		{
			roomOptions.CleanupCacheOnLeave = false;
		}
		PhotonNetwork.CreateRoom("Lobby" + Time.time, roomOptions);
	}

	public override void OnPlayerEnteredRoom(Player newPlayer)
	{
		UpdateRoomInfo();
	}

	public override void OnPlayerLeftRoom(Player otherPlayer)
	{
		UpdateRoomInfo();
	}

	private void UpdateRoomInfo()
	{
		PublicGameUIManager.GetInstance.UpdateMatchRoomInfo();
		if (PhotonNetwork.CurrentRoom.Players.Count == 1)
		{
			StartMatchCoroutine(isMatch: false);
		}
		else
		{
			StartMatchCoroutine(isMatch: true);
		}
	}

	public void StartMatchCoroutine(bool isMatch)
	{
		if (isMatch)
		{
			keep_timeScale = Time.timeScale;
		}
		if (matchCoroutine != null)
		{
			StopCoroutine(matchCoroutine);
		}
		matchCoroutine = StartCoroutine(MatchCoroutine(isMatch));
	}

	private IEnumerator MatchCoroutine(bool isMatch)
	{
		Time.timeScale = 0f;
		PublicGameUIManager.GetInstance.SetViewState(PublicGameUIManager.ViewState.Match);
		if (!isMatch)
		{
			PublicGameUIManager.GetInstance.SetMatchTime("Other player has left.");
			PhotonNetwork.IsSyncScene = false;
			PhotonNetwork.isLoadLevel = false;
			yield return new WaitForSecondsRealtime(1.5f);
			Time.timeScale = keep_timeScale;
			PublicGameUIManager.GetInstance.SetViewState(PublicGameUIManager.ViewState.None);
			yield break;
		}
		PublicGameUIManager.GetInstance.SetMatchTime("Match!");
		yield return new WaitForSecondsRealtime(1f);
		PhotonNetwork.IsSyncScene = true;
		PhotonNetwork.isLoadLevel = true;
		for (int countTime = 3; countTime > 0; countTime--)
		{
			PublicGameUIManager.GetInstance.SetMatchTime(countTime.ToString());
			yield return new WaitForSecondsRealtime(1f);
		}
		Time.timeScale = 1f;
		SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType = GameData_DDOL.PlayType.Multi;
		PublicGameUIManager.GetInstance.StartLoadLevel();
		PhotonNetwork.CurrentRoom.IsOpen = false;
		PhotonNetwork.CurrentRoom.IsVisible = false;
		PublicGameUIManager.GetInstance.SetViewState(PublicGameUIManager.ViewState.None);
		UnityEngine.Object.Destroy(base.gameObject);
	}

	private void OnDestroy()
	{
		SceneManager.sceneLoaded -= OnSceneLoaded;
		SceneManager.sceneUnloaded -= OnSceneUnloaded;
	}
}
public enum WearState
{
	None,
	Upper,
	Upper_Cut,
	Lower,
	Lower_Sub,
	Foot,
	Hand,
	Body
}
public class WearInfoCreator : MonoBehaviour
{
	public WearState state;

	public string meshName;

	public void CreateWearInfo()
	{
		if (string.IsNullOrEmpty(meshName))
		{
			UnityEngine.Debug.Log("No ID");
			return;
		}
		WearInfo wearInfo = new WearInfo();
		SkinnedMeshRenderer component = base.transform.GetComponent<SkinnedMeshRenderer>();
		wearInfo.bounds_center = component.localBounds.center;
		wearInfo.bounds_extent = component.localBounds.extents;
		wearInfo.rootBone = BoneNameToIndex(component.rootBone.name);
		wearInfo.bones = new int[component.bones.Length];
		for (int i = 0; i < component.bones.Length; i++)
		{
			wearInfo.bones[i] = BoneNameToIndex(component.bones[i].name);
		}
		string contents = JsonUtility.ToJson(wearInfo);
		string text = "";
		switch (state)
		{
		case WearState.Upper:
			text = "30";
			break;
		case WearState.Upper_Cut:
			text = "31";
			break;
		case WearState.Lower:
			text = "32";
			break;
		case WearState.Lower_Sub:
			text = "33";
			break;
		case WearState.Foot:
			text = "34";
			break;
		case WearState.Hand:
			text = "35";
			break;
		case WearState.Body:
			File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/BodyInfo_" + meshName + ".json", contents);
			UnityEngine.Debug.Log("Save JsonFile - BodyInfo_" + text + meshName);
			return;
		}
		File.WriteAllText(UnityEngine.Application.dataPath + "/03. Individual Resources/Lee Jaeheung/Resources/ItemInfos/WearInfo_" + text + meshName + ".json", contents);
		UnityEngine.Debug.Log("Save JsonFile - WearInfo_" + text + meshName);
	}

	public static int BoneNameToIndex(string _boneName)
	{
		return _boneName switch
		{
			"Bip001" => 0, 
			"Bip001 Pelvis" => 1, 
			"Bip001 L Thigh" => 2, 
			"Bip001 LThighTwist" => 3, 
			"Bip001 L Calf" => 4, 
			"Bip001 L Foot" => 5, 
			"Bip001 L Toe0" => 6, 
			"Bip001 R Thigh" => 7, 
			"Bip001 RThighTwist" => 8, 
			"Bip001 R Calf" => 9, 
			"Bip001 R Foot" => 10, 
			"Bip001 R Toe0" => 11, 
			"Bip001 Spine" => 12, 
			"Bip001 Spine1" => 13, 
			"Bip001 Spine2" => 14, 
			"Bip001 L Clavicle" => 15, 
			"Bip001 L UpperArm" => 16, 
			"Bip001 LUpArmTwist" => 17, 
			"Bip001 L Forearm" => 18, 
			"Bip001 L ForeTwist" => 19, 
			"Bip001 L Hand" => 20, 
			"Bip001 L Finger0" => 21, 
			"Bip001 L Finger01" => 22, 
			"Bip001 L Finger02" => 23, 
			"Bip001 L Finger1" => 24, 
			"Bip001 L Finger11" => 25, 
			"Bip001 L Finger12" => 26, 
			"Bip001 L Finger2" => 27, 
			"Bip001 L Finger21" => 28, 
			"Bip001 L Finger22" => 29, 
			"Bip001 L Finger3" => 30, 
			"Bip001 L Finger31" => 31, 
			"Bip001 L Finger32" => 32, 
			"Bip001 L Finger4" => 33, 
			"Bip001 L Finger41" => 34, 
			"Bip001 L Finger42" => 35, 
			"Bip001 Neck" => 36, 
			"Bip001 Head" => 37, 
			"Bip001 R Clavicle" => 38, 
			"Bip001 R UpperArm" => 39, 
			"Bip001 RUpArmTwist" => 40, 
			"Bip001 R Forearm" => 41, 
			"Bip001 R ForeTwist" => 42, 
			"Bip001 R Hand" => 43, 
			"Bip001 R Finger0" => 44, 
			"Bip001 R Finger01" => 45, 
			"Bip001 R Finger02" => 46, 
			"Bip001 R Finger1" => 47, 
			"Bip001 R Finger11" => 48, 
			"Bip001 R Finger12" => 49, 
			"Bip001 R Finger2" => 50, 
			"Bip001 R Finger21" => 51, 
			"Bip001 R Finger22" => 52, 
			"Bip001 R Finger3" => 53, 
			"Bip001 R Finger31" => 54, 
			"Bip001 R Finger32" => 55, 
			"Bip001 R Finger4" => 56, 
			"Bip001 R Finger41" => 57, 
			"Bip001 R Finger42" => 58, 
			_ => -1, 
		};
	}
}
public class WearPrefCreator : MonoBehaviour
{
	public string pref_name;

	public void CreateWearPref()
	{
		List<Transform> list = new List<Transform>();
		Transform parent = new GameObject(pref_name).transform;
		Transform transform = new GameObject("Bip001").transform;
		transform.parent = parent;
		Transform transform2 = base.transform.parent.Find("Bip001");
		transform.localPosition = transform2.localPosition;
		transform.localRotation = transform2.localRotation;
		for (int j = 0; j < base.transform.childCount; j++)
		{
			Transform obj = new GameObject(pref_name + "_" + j).transform;
			obj.parent = parent;
			SkinnedMeshRenderer skin_orizin = base.transform.GetChild(j).GetComponent<SkinnedMeshRenderer>();
			SkinnedMeshRenderer skinnedMeshRenderer = obj.gameObject.AddComponent<SkinnedMeshRenderer>();
			skinnedMeshRenderer.sharedMesh = skin_orizin.sharedMesh;
			skinnedMeshRenderer.sharedMaterial = skin_orizin.sharedMaterial;
			skinnedMeshRenderer.localBounds = skin_orizin.localBounds;
			if (!list.Exists((Transform bone) => bone.name == skin_orizin.rootBone.name))
			{
				Transform transform3 = new GameObject(skin_orizin.rootBone.name).transform;
				transform3.parent = transform;
				transform3.localPosition = transform2.InverseTransformPoint(skin_orizin.rootBone.position);
				transform3.localRotation = Quaternion.Inverse(transform2.rotation) * skin_orizin.rootBone.rotation;
				list.Add(transform3);
			}
			skinnedMeshRenderer.rootBone = list.Find((Transform bone) => bone.name == skin_orizin.rootBone.name);
			Transform[] array = new Transform[skin_orizin.bones.Length];
			int i;
			for (i = 0; i < skin_orizin.bones.Length; i++)
			{
				if (!list.Exists((Transform bone) => bone.name == skin_orizin.bones[i].name))
				{
					Transform transform4 = new GameObject(skin_orizin.bones[i].name).transform;
					transform4.parent = transform;
					transform4.localPosition = transform2.InverseTransformPoint(skin_orizin.bones[i].position);
					transform4.localRotation = Quaternion.Inverse(transform2.rotation) * skin_orizin.bones[i].rotation;
					list.Add(transform4);
				}
				array[i] = list.Find((Transform bone) => bone.name == skin_orizin.bones[i].name);
			}
			skinnedMeshRenderer.bones = array;
		}
	}
}
public class CheckGenderCtrl : MonoBehaviour
{
	private Animator anim;

	private CustomModelSettingCtrl customModelSettingCtrl;

	public bool isMan;

	private void Awake()
	{
		anim = base.transform.GetComponent<Animator>();
		customModelSettingCtrl = base.transform.GetComponent<CustomModelSettingCtrl>();
	}

	private void OnEnable()
	{
		StartCoroutine(CheckGenderCoroutine());
	}

	private IEnumerator CheckGenderCoroutine()
	{
		while (customModelSettingCtrl.enabled)
		{
			yield return null;
		}
		isMan = !anim.avatar.name.ToLower().Contains("female");
		anim.SetBool("isMan", isMan);
	}
}
public class CrowdLookAt : MonoBehaviour
{
	private Transform[] ArrChildHead;

	private Transform PBTR;

	private void Start()
	{
		ArrChildHead = new Transform[base.transform.childCount];
		for (int i = 0; i < base.transform.childCount; i++)
		{
			ArrChildHead[i] = base.transform.GetChild(i).transform;
		}
		PBTR = UnityEngine.Object.FindObjectOfType<GOLF.PlayerBehaviour>().transform;
	}

	private void Update()
	{
		if (!(PBTR == null))
		{
			for (int i = 0; i < ArrChildHead.Length; i++)
			{
				Ani(i);
			}
		}
	}

	private void Ani(int num)
	{
		Vector3 normalized = (PBTR.position - ArrChildHead[num].position).normalized;
		normalized.y = 0f;
		Quaternion rotation = Quaternion.LookRotation(normalized);
		ArrChildHead[num].rotation = rotation;
	}
}
public class InputDeviceState : MonoBehaviour
{
	public enum AxisPad
	{
		none,
		Right,
		Left,
		Up,
		Down
	}

	private UnityEngine.XR.Interaction.Toolkit.XRController controller;

	public string DeviceName;

	public bool trigger;

	public bool grip;

	public bool primary;

	public bool primaryDown;

	public bool primaryTouch;

	public bool primaryTouchDown;

	public bool primaryClick;

	public bool primaryClickDown;

	public bool secondClick;

	public bool secondClickDown;

	public Vector3 deviceVelo;

	public Vector3 deviceAngularVelo;

	private XRInteractorLineVisual xrInteractorLineVisual;

	public AxisPad axisPadState;

	private AxisPad axisChecker;

	private bool usePrimaryPad;

	private bool useSecondPad;

	public float HapTicValue;

	public float HapTicDuration;

	private void Start()
	{
		controller = GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
		xrInteractorLineVisual = GetComponent<XRInteractorLineVisual>();
		StartCoroutine(GetDeviceName());
	}

	private void FixedUpdate()
	{
		if (DeviceName != null)
		{
			InputButton();
		}
	}

	private IEnumerator GetDeviceName()
	{
		while (true)
		{
			DeviceName = controller.inputDevice.name;
			yield return new WaitForSeconds(5f);
		}
	}

	public void UseXRInteractorLineVisual(bool isUse)
	{
		xrInteractorLineVisual.enabled = isUse;
	}

	private void LateUpdate()
	{
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceAngularVelocity, out var value))
		{
			deviceAngularVelo = value;
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value2))
		{
			deviceVelo = value2;
		}
	}

	private void InputButton()
	{
		axisPadState = AxisPad.none;
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.trigger, out var value))
		{
			trigger = value >= 0.7f;
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.gripButton, out var value2))
		{
			grip = value2;
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.primaryButton, out var value3))
		{
			primaryDown = ((!primary && value3) ? true : false);
			primary = value3;
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxisClick, out var value4) && !DeviceName.Contains("Oculus") && !DeviceName.Contains("Miramar"))
		{
			primaryClickDown = ((!primaryClick && value4) ? true : false);
			primaryClick = value4;
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxisTouch, out var value5))
		{
			primaryTouchDown = ((!primaryTouch && value5) ? true : false);
			primaryTouch = value5;
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.secondary2DAxisClick, out var value6))
		{
			secondClickDown = ((!secondClick && value6) ? true : false);
			secondClick = value6;
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxis, out var value7) && !useSecondPad)
		{
			Vector2 vector = value7;
			Vector3 vector2 = Vector3.right * vector.x;
			Vector3 vector3 = Vector3.up * vector.y;
			Vector3 normalized = (vector2 + vector3).normalized;
			normalized.z = 0f;
			Vector3 up = Vector3.up;
			float num = Vector3.Dot(up, normalized);
			Vector3 vector4 = Vector3.Cross(up, normalized);
			if (value7.magnitude < 0.5f)
			{
				axisPadState = AxisPad.none;
			}
			else
			{
				usePrimaryPad = true;
				if (vector4.z > 0f)
				{
					if (num > 0.5f)
					{
						axisPadState = AxisPad.Up;
					}
					else if (num < 0.5f && num > -0.5f)
					{
						axisPadState = AxisPad.Left;
					}
					else
					{
						axisPadState = AxisPad.Down;
					}
				}
				else if (num > 0.5f)
				{
					axisPadState = AxisPad.Up;
				}
				else if (num < 0.5f && num > -0.5f)
				{
					axisPadState = AxisPad.Right;
				}
				else
				{
					axisPadState = AxisPad.Down;
				}
				if (DeviceName.Contains("Oculus") || DeviceName.Contains("Miramar"))
				{
					primaryClickDown = ((axisChecker != axisPadState) ? true : false);
				}
			}
		}
		if (controller.inputDevice.TryGetFeatureValue(CommonUsages.secondary2DAxis, out var value8) && !usePrimaryPad)
		{
			Vector2 vector5 = value8;
			Vector3 vector6 = Vector3.right * vector5.x;
			Vector3 vector7 = Vector3.up * vector5.y;
			Vector3 normalized2 = (vector6 + vector7).normalized;
			normalized2.z = 0f;
			Vector3 up2 = Vector3.up;
			float num2 = Vector3.Dot(up2, normalized2);
			Vector3 vector8 = Vector3.Cross(up2, normalized2);
			if (value8.magnitude < 0.5f)
			{
				axisPadState = AxisPad.none;
			}
			else
			{
				useSecondPad = true;
				if (vector8.z > 0f)
				{
					if (num2 > 0.5f)
					{
						axisPadState = AxisPad.Up;
					}
					else if (num2 < 0.5f && num2 > -0.5f)
					{
						axisPadState = AxisPad.Left;
					}
					else
					{
						axisPadState = AxisPad.Down;
					}
				}
				else if (num2 > 0.5f)
				{
					axisPadState = AxisPad.Up;
				}
				else if (num2 < 0.5f && num2 > -0.5f)
				{
					axisPadState = AxisPad.Right;
				}
				else
				{
					axisPadState = AxisPad.Down;
				}
			}
		}
		axisChecker = axisPadState;
	}

	public void HapticPulse()
	{
		if (controller.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
		{
			controller.inputDevice.SendHapticImpulse(0u, HapTicValue * PublicGameUIManager.gameSetting.GetHapticValue(), HapTicDuration);
		}
	}
}
[RequireComponent(typeof(Camera))]
public class NoFogOnCamera : MonoBehaviour
{
	public bool AllowFog;

	private bool FogOn;

	private void OnPreRender()
	{
		FogOn = RenderSettings.fog;
		RenderSettings.fog = AllowFog;
	}

	private void OnPostRender()
	{
		RenderSettings.fog = FogOn;
	}
}
public class RandIdle : StateMachineBehaviour
{
	private float checkTime;

	private float value;

	private float value2;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		checkTime -= Time.deltaTime;
		if (checkTime > 0f)
		{
			value2 += value;
			value2 = Mathf.Clamp(value2, 0f, 1f);
			animator.SetFloat("Blend", value2);
		}
		else if (checkTime <= 0f)
		{
			checkTime = UnityEngine.Random.Range(3f, 5f);
			value = UnityEngine.Random.Range(-0.01f, 0.01f);
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
	}
}
public class RandMoveObject : MonoBehaviour
{
	private enum Type
	{
		Up,
		Down,
		LeftRot,
		RightRot,
		LeftRotReturn,
		RightRotReturn
	}

	public float SpeedMin = 1f;

	public float SpeedMax = 1.2f;

	private float rotDt = 0.5f;

	private float rotSpeed = 4f;

	private float rotHeadSpeed = 50f;

	private Transform[] ArrChild;

	private float[] AniSpeed;

	private Type[] AniType;

	private float[] AniDt;

	private Vector3[] ArrPos;

	private Vector3[] ArrTargetPos;

	private void Start()
	{
		ArrChild = new Transform[base.transform.childCount];
		AniSpeed = new float[base.transform.childCount];
		AniType = new Type[base.transform.childCount];
		AniDt = new float[base.transform.childCount];
		ArrPos = new Vector3[base.transform.childCount];
		ArrTargetPos = new Vector3[base.transform.childCount];
		for (int i = 0; i < base.transform.childCount; i++)
		{
			ArrChild[i] = base.transform.GetChild(i).GetComponent<Transform>();
			AniSpeed[i] = UnityEngine.Random.Range(SpeedMin, SpeedMax);
			AniType[i] = Type.Up;
			ArrPos[i] = ArrChild[i].position;
			ArrTargetPos[i] = ArrChild[i].position;
			ArrTargetPos[i].y += 2.5f;
		}
	}

	private void Update()
	{
		for (int i = 0; i < ArrChild.Length; i++)
		{
			Ani(i);
		}
	}

	private void Ani(int num)
	{
		float num2 = Time.deltaTime * AniSpeed[num];
		AniDt[num] += num2;
		if (AniType[num] == Type.Up)
		{
			ArrChild[num].position = Vector3.Lerp(ArrChild[num].position, ArrTargetPos[num], Time.deltaTime * 2f * AniSpeed[num]);
			if (0.7f < AniDt[num])
			{
				AniDt[num] = 0f;
				AniType[num] = Type.Down;
			}
		}
		else if (AniType[num] == Type.Down)
		{
			ArrChild[num].position = Vector3.Lerp(ArrChild[num].position, ArrPos[num], Time.deltaTime * 2f * AniSpeed[num]);
			if (0.7f < AniDt[num])
			{
				AniDt[num] = 0f;
				if (UnityEngine.Random.Range(0f, 1f) < 0.7f)
				{
					AniType[num] = Type.Up;
				}
				else
				{
					AniType[num] = Type.LeftRot;
				}
				AniSpeed[num] = UnityEngine.Random.Range(SpeedMin, SpeedMax);
			}
		}
		else if (AniType[num] == Type.LeftRot)
		{
			Vector3 localEulerAngles = ArrChild[num].localEulerAngles;
			localEulerAngles.z += num2 * rotSpeed;
			ArrChild[num].localEulerAngles = localEulerAngles;
			localEulerAngles.y -= num2 * rotHeadSpeed;
			if (rotDt < AniDt[num])
			{
				AniDt[num] = 0f;
				AniType[num] = Type.LeftRotReturn;
			}
		}
		else if (AniType[num] == Type.LeftRotReturn)
		{
			Vector3 localEulerAngles2 = ArrChild[num].localEulerAngles;
			localEulerAngles2.z -= num2 * rotSpeed;
			ArrChild[num].localEulerAngles = localEulerAngles2;
			localEulerAngles2.y += num2 * rotHeadSpeed;
			if (rotDt < AniDt[num])
			{
				AniDt[num] = 0f;
				if (UnityEngine.Random.Range(0f, 1f) < 0.7f)
				{
					AniType[num] = Type.RightRot;
				}
				else
				{
					AniType[num] = Type.Up;
				}
			}
		}
		else if (AniType[num] == Type.RightRot)
		{
			Vector3 localEulerAngles3 = ArrChild[num].localEulerAngles;
			localEulerAngles3.z -= num2 * rotSpeed;
			ArrChild[num].localEulerAngles = localEulerAngles3;
			localEulerAngles3.y += num2 * rotHeadSpeed;
			if (rotDt < AniDt[num])
			{
				AniDt[num] = 0f;
				AniType[num] = Type.RightRotReturn;
			}
		}
		else
		{
			if (AniType[num] != Type.RightRotReturn)
			{
				return;
			}
			Vector3 localEulerAngles4 = ArrChild[num].localEulerAngles;
			localEulerAngles4.z += num2 * rotSpeed;
			ArrChild[num].localEulerAngles = localEulerAngles4;
			localEulerAngles4.y -= num2 * rotHeadSpeed;
			if (rotDt < AniDt[num])
			{
				AniDt[num] = 0f;
				if (UnityEngine.Random.Range(0f, 1f) < 0.7f)
				{
					AniType[num] = Type.LeftRot;
				}
				else
				{
					AniType[num] = Type.Up;
				}
			}
		}
	}
}
public class RotateSkyBox : MonoBehaviour
{
	private Material skyBox;

	private float value;

	private void Start()
	{
		skyBox = RenderSettings.skybox;
	}

	private void Update()
	{
		RotateSky();
	}

	private void RotateSky()
	{
		if (!(RenderSettings.skybox == null))
		{
			value += UnityEngine.Random.Range(0.01f, Time.deltaTime);
			skyBox.SetFloat("_Rotation", value);
		}
	}
}
public class ServiceText : MonoBehaviour
{
	private TextMeshPro text;

	private void Start()
	{
		text = GetComponent<TextMeshPro>();
		PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(changefontSize);
	}

	private void changefontSize(LanguageState languageState)
	{
		text.fontSize = ((languageState == LanguageState.schinese) ? 8f : 5.25f);
	}
}
public class CustomFixedUpdate
{
	public delegate void OnFixedUpdateCallback(float aDeltaTime);

	private float m_FixedTimeStep;

	private float m_Timer;

	private OnFixedUpdateCallback m_Callback;

	private float m_MaxAllowedTimeStep;

	public float MaxAllowedTimeStep
	{
		get
		{
			return m_MaxAllowedTimeStep;
		}
		set
		{
			m_MaxAllowedTimeStep = value;
		}
	}

	public float deltaTime
	{
		get
		{
			return m_FixedTimeStep;
		}
		set
		{
			m_FixedTimeStep = Mathf.Max(value, 1E-06f);
		}
	}

	public float updateRate
	{
		get
		{
			return 1f / deltaTime;
		}
		set
		{
			deltaTime = 1f / value;
		}
	}

	public CustomFixedUpdate(float aTimeStep, OnFixedUpdateCallback aCallback, float aMaxAllowedTimestep)
	{
		if (aCallback == null)
		{
			throw new ArgumentException("CustomFixedUpdate needs a valid callback");
		}
		if (aTimeStep <= 0f)
		{
			throw new ArgumentException("TimeStep needs to be greater than 0");
		}
		deltaTime = aTimeStep;
		m_Callback = aCallback;
		m_MaxAllowedTimeStep = aMaxAllowedTimestep;
	}

	public CustomFixedUpdate(float aTimeStep, OnFixedUpdateCallback aCallback)
		: this(aTimeStep, aCallback, 0f)
	{
	}

	public CustomFixedUpdate(OnFixedUpdateCallback aCallback)
		: this(0.01f, aCallback, 0f)
	{
	}

	public CustomFixedUpdate(OnFixedUpdateCallback aCallback, float aFPS, float aMaxAllowedTimestep)
		: this(1f / aFPS, aCallback, aMaxAllowedTimestep)
	{
	}

	public CustomFixedUpdate(OnFixedUpdateCallback aCallback, float aFPS)
		: this(aCallback, aFPS, 0f)
	{
	}

	public void Update(float aDeltaTime)
	{
		m_Timer -= aDeltaTime;
		if (m_MaxAllowedTimeStep > 0f)
		{
			float num = Time.realtimeSinceStartup + m_MaxAllowedTimeStep;
			while (m_Timer < 0f && Time.realtimeSinceStartup < num)
			{
				m_Callback(m_FixedTimeStep);
				m_Timer += m_FixedTimeStep;
			}
		}
		else
		{
			while (m_Timer < 0f)
			{
				m_Callback(m_FixedTimeStep);
				m_Timer += m_FixedTimeStep;
			}
		}
	}

	public void Update()
	{
		Update(Time.deltaTime);
	}
}
public class LanguageChanger : MonoBehaviour
{
	[Serializable]
	public class Mat
	{
		public Material mat;

		public Texture global;

		public Texture globalE;

		public Texture china;

		public Texture chinaE;
	}

	[Serializable]
	public class GO
	{
		public bool isChina;

		public GameObject go;
	}

	public List<Mat> MatList = new List<Mat>();

	public List<GO> GOList = new List<GO>();

	public TMP_Asset[] tMP_Assets;

	private void Start()
	{
		PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(languageChanger);
	}

	private void languageChanger(LanguageState languageState)
	{
		UnityEngine.Debug.Log("changeLange" + languageState);
		StaticLocalizationCtrl_TextMesh.DataSlot_Pro[] dataSlots_pro = SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.dataSlots_pro;
		TextMeshPro[] array = new TextMeshPro[dataSlots_pro.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = dataSlots_pro[i].ui;
		}
		if (languageState == LanguageState.schinese)
		{
			for (int j = 0; j < MatList.Count; j++)
			{
				MatList[j].mat.SetTexture("_BaseMap", MatList[j].china);
				if (MatList[j].chinaE != null)
				{
					MatList[j].mat.SetTexture("_EmissionMap", MatList[j].chinaE);
				}
			}
			for (int k = 0; k < GOList.Count; k++)
			{
				GOList[k].go.SetActive(GOList[k].isChina);
			}
			for (int l = 0; l < array.Length; l++)
			{
				array[l].font = (TMP_FontAsset)tMP_Assets[0];
			}
			return;
		}
		for (int m = 0; m < MatList.Count; m++)
		{
			MatList[m].mat.SetTexture("_BaseMap", MatList[m].global);
			if (MatList[m].globalE != null)
			{
				MatList[m].mat.SetTexture("_EmissionMap", MatList[m].globalE);
			}
		}
		for (int n = 0; n < GOList.Count; n++)
		{
			GOList[n].go.SetActive(!GOList[n].isChina);
		}
		for (int num = 0; num < array.Length; num++)
		{
			array[num].font = (TMP_FontAsset)tMP_Assets[1];
		}
	}
}
public class ShowFPS : MonoBehaviour
{
	public TextMesh fpsText;

	public float deltaTime;

	private void Update()
	{
		deltaTime += (Time.deltaTime - deltaTime) * 0.1f;
		float f = 1f / deltaTime;
		fpsText.text = Mathf.Ceil(f).ToString();
	}
}
public class Smash : StateMachineBehaviour
{
	private float time;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		time += Time.fixedDeltaTime;
		if (time >= 0.66f)
		{
			animator.speed = 1.7f;
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		time = 0f;
		animator.speed = 1f;
	}
}
public class TimeManager : MonoBehaviour
{
	public static TimeManager instance;

	public static float PhotonPing;

	public static float PhysicsSimulatorWorkTime;

	private void Awake()
	{
		base.enabled = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi;
	}

	private void FixedUpdate()
	{
		PhotonPing = (float)PhotonNetwork.GetPing() * 0.001f;
	}
}
public class testPhysicsSimulate : MonoBehaviour
{
	public Vector3 testVelo;

	public Vector3 testAngularVelo;

	public Vector3 testSpinForce;

	public float ReveiseValue;

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.LeftShift))
		{
			Preview_Ctrl.instance.GetPreviewHitPos(base.transform.position, testVelo, testSpinForce, testAngularVelo, useAI: false, isMine: false);
		}
	}

	public Vector3 ReviseVelo(Vector3 velo, Transform tr, float ReviseValue)
	{
		Vector3 forward = tr.forward;
		Vector3 normalized = velo.normalized;
		normalized.y = 0f;
		float num = Vector3.Angle(forward, normalized);
		if (num == 0f)
		{
			return velo;
		}
		num *= ReviseValue;
		float num2 = Vector3.Dot(tr.right, normalized);
		num2 /= Mathf.Abs(num2) * -1f;
		num *= num2;
		Vector3 vector = Quaternion.AngleAxis(num, tr.up) * normalized * velo.magnitude;
		vector.y = velo.y;
		UnityEngine.Debug.DrawRay(base.transform.position, forward * 10f, Color.white, 30f);
		UnityEngine.Debug.DrawRay(base.transform.position, vector * 10f, Color.red, 30f);
		return vector;
	}
}
public class ADBanner : MonoBehaviour
{
	public static ADBanner instance;

	private MeshRenderer meshRenderer;

	private Coroutine c;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void OnDisable()
	{
		meshRenderer.sharedMaterials[0].SetTextureOffset("_BaseMap", Vector2.zero);
	}

	private void Start()
	{
		meshRenderer = GetComponent<MeshRenderer>();
	}

	public void ChangeAD()
	{
		if (c == null)
		{
			c = StartCoroutine(IEnum_ChangeAD());
		}
	}

	private IEnumerator IEnum_ChangeAD()
	{
		Vector2 OffSet2 = meshRenderer.sharedMaterials[0].GetTextureOffset("_BaseMap");
		float startY = OffSet2.y;
		float gole = OffSet2.y + 0.125f;
		_ = gole;
		while (OffSet2.y < gole)
		{
			OffSet2.y += Time.deltaTime * 0.05f;
			meshRenderer.sharedMaterials[0].SetTextureOffset("_BaseMap", OffSet2);
			yield return null;
		}
		OffSet2 = new Vector2(0f, startY + 0.125f);
		meshRenderer.sharedMaterials[0].SetTextureOffset("_BaseMap", OffSet2);
		c = null;
	}
}
public class SetFloorColor : MonoBehaviour
{
	public Color[] Out;

	public Color[] In;

	public MeshRenderer renderer;

	public Texture[] textures;

	public int MapIndex;

	public static SetFloorColor instance;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
		{
			setFloorColor();
		}
	}

	public void setFloorColor()
	{
		MapIndex = UnityEngine.Random.Range(0, Out.Length);
		renderer.sharedMaterials[0].SetColor("_BaseColor", Out[MapIndex]);
		renderer.sharedMaterials[1].SetColor("_BaseColor", In[MapIndex]);
		if (MapIndex == 2)
		{
			renderer.sharedMaterials[1].SetTexture("_BaseMap", textures[0]);
		}
		else
		{
			renderer.sharedMaterials[1].SetTexture("_BaseMap", textures[1]);
		}
		SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
	}

	public void ReceiveFloorColor()
	{
		renderer.sharedMaterials[0].SetColor("_BaseColor", Out[MapIndex]);
		renderer.sharedMaterials[1].SetColor("_BaseColor", In[MapIndex]);
		if (MapIndex == 2)
		{
			renderer.sharedMaterials[1].SetTexture("_BaseMap", textures[0]);
		}
		else
		{
			renderer.sharedMaterials[1].SetTexture("_BaseMap", textures[1]);
		}
		SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
	}
}
public class AniSpeed : MonoBehaviour
{
	[Header("스피드가 0일때 0.3")]
	public float Speed;

	private void Start()
	{
		if (Speed == 0f)
		{
			Speed = 0.3f;
		}
		Animation component = GetComponent<Animation>();
		foreach (AnimationState item in component)
		{
			UnityEngine.Debug.Log(item.name);
			component[item.name].speed = Speed;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class AICatcher : MonoBehaviour
{
	private static AICatcher instance;

	public GameObject pCatcherPoint;

	public GameObject pTargetAimCircle;

	private Vector3 PrePos = Vector3.zero;

	private CatcherIK gCatcherIK;

	public static AICatcher GetInstance()
	{
		return instance;
	}

	private void Start()
	{
		instance = this;
		gCatcherIK = GetComponent<CatcherIK>();
		gCatcherIK.StartSet();
		gCatcherIK.setTargetPos(pCatcherPoint.transform.position);
		PrePos = base.transform.position;
	}

	public void CatcherMovement(Vector3 pos)
	{
		gCatcherIK.setTargetPos(new Vector3(pos.x + 0.5f, pos.y + 0.2f, pCatcherPoint.transform.position.z));
		if (base.transform.position.x == 0f && 1f < Mathf.Abs(pos.x))
		{
			StartCoroutine(CatcherLegMovement(pos));
		}
	}

	private IEnumerator CatcherLegMovement(Vector3 Pos)
	{
		float value = 1.1f;
		if (Pos.x < 0f)
		{
			value = -1.1f;
		}
		float dis = base.transform.position.x - Pos.x;
		Vector3 LerpPos = base.transform.position;
		LerpPos.x = Pos.x;
		while (0.1f < Mathf.Abs(dis))
		{
			dis = base.transform.position.x - (Pos.x - value);
			Vector3 position = Vector3.Lerp(base.transform.position, LerpPos, Time.deltaTime * 5f);
			base.transform.position = position;
			yield return null;
		}
	}

	public void CatcherIdle()
	{
		gCatcherIK.setTargetPos(pCatcherPoint.transform.position);
	}

	public void CatcherTakeAimBall(Vector3 targetPos)
	{
		pTargetAimCircle.transform.position = new Vector3(targetPos.x, targetPos.y, pTargetAimCircle.transform.position.z);
		gCatcherIK.setTargetPos(pTargetAimCircle.transform.position);
	}

	public void CatcherLookAt(Transform Ball)
	{
		gCatcherIK.GetComponent<LookAtIK>().solver.target = Ball;
	}
}
public class CatcherIK : MonoBehaviour
{
	public Transform mGlove;

	private FullBodyBipedIK ik;

	private Vector2 clampX;

	private Vector2 clampY;

	private float clampZ;

	private float aniSpeed = 8f;

	private bool isActive;

	private Vector3 tarPos;

	public Transform CatcherPoint;

	private void Start()
	{
	}

	public void StartSet()
	{
		ik = GetComponent<FullBodyBipedIK>();
		BoxCollider component = GetComponent<BoxCollider>();
		Vector3 size = component.bounds.size;
		float x = size.x;
		float y = size.y;
		clampZ = CatcherPoint.position.z + 0f;
		clampX = new Vector2(-0.5f * x, 0.5f * x);
		clampY = new Vector2(0.1f * y, y);
		isActive = false;
		setTargetPos(new Vector3(0f, 0f, 0f));
		OnAnimatorIK(0);
		component.enabled = false;
	}

	public void setTargetPos(Vector3 tPos)
	{
		isActive = true;
		tarPos = tPos;
	}

	private void OnAnimatorIK(int layerIndex)
	{
		if (isActive)
		{
			if (1.4f < tarPos.x - base.transform.position.x)
			{
				tarPos.x = base.transform.position.x + 1.4f;
			}
			else if (tarPos.x - base.transform.position.x < -1.4f)
			{
				tarPos.x = base.transform.position.x - 1.4f;
			}
			if (3.4f < tarPos.y)
			{
				tarPos.y = 3.4f;
			}
			else if (tarPos.y < 0.45f)
			{
				tarPos.y = 0.45f;
			}
			tarPos.z = clampZ;
			float t = Time.deltaTime * aniSpeed;
			Vector3 position = ik.solver.leftHandEffector.position;
			if (Vector3.Distance(position, tarPos) < 0.1f)
			{
				isActive = false;
				ik.solver.leftHandEffector.position = tarPos;
			}
			else
			{
				ik.solver.leftHandEffector.position = Vector3.Lerp(position, tarPos, t);
			}
		}
	}

	public void ResetHand()
	{
		ik.solver.leftHandEffector.position = CatcherPoint.position;
	}
}
public class CsExit : MonoBehaviourPunCallbacks
{
	private void Start()
	{
	}

	private void Update()
	{
	}

	public override void OnPlayerLeftRoom(Player otherPlayer)
	{
		string nickName = PhotonNetwork.LocalPlayer.NickName;
		int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
		PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
	}
}
public class CsFollow : MonoBehaviour
{
	public Transform Obj;

	public Transform Target;

	private void Update()
	{
		Obj.transform.position = Target.transform.position;
	}

	public void SetActiveObj(bool _bool)
	{
		Obj.gameObject.SetActive(_bool);
	}
}
public class CsTextUI : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class NoTurn : MonoBehaviour
{
	private void Update()
	{
		Quaternion rotation = Quaternion.Euler(0f, 0f, 0f);
		base.transform.rotation = rotation;
	}
}
public class CsStrikeZone : MonoBehaviour
{
	public Material Mat;

	private int add;

	private int max = 10;

	public int delayFrame;

	private void OnEnable()
	{
		StartCoroutine(DelayAni());
	}

	private IEnumerator DelayAni()
	{
		bool fade = true;
		Color Value = new Color(1f, 1f, 1f, 1f);
		while (true)
		{
			yield return null;
			Mat.color = Value;
			if (fade)
			{
				Value.a += Time.deltaTime * 0.8f;
			}
			else
			{
				Value.a -= Time.deltaTime * 0.8f;
			}
			if (Value.a < 0.3f)
			{
				fade = true;
			}
			else if (1f <= Value.a)
			{
				fade = false;
				yield return YieldInstructionCache.WaitForSeconds(0.6f);
			}
		}
	}
}
public class TEMPNEW : MonoBehaviourPunCallbacks, ILobbyCallbacks, IInRoomCallbacks
{
	private void Start()
	{
		StartCoroutine(DelayStart());
	}

	private IEnumerator DelayStart()
	{
		yield return YieldInstructionCache.WaitForSeconds(1f);
		PhotonNetwork.ConnectUsingSettings();
		yield return YieldInstructionCache.WaitForSeconds(1.5f);
		UnityEngine.Debug.Log("PhotonNetwork.IsConnected : " + PhotonNetwork.IsConnected);
		PhotonNetwork.JoinRandomRoom();
	}

	public override void OnJoinRandomFailed(short _sho, string _str)
	{
		UnityEngine.Debug.Log("Join RandomRoom Failed CreateRoom???");
		Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
		roomOptions.MaxPlayers = 2;
		roomOptions.CustomRoomProperties = new ExitGames.Client.Photon.Hashtable();
		PhotonNetwork.CreateRoom("", roomOptions);
	}

	public override void OnJoinRoomFailed(short returnCode, string message)
	{
		UnityEngine.Debug.Log("JoinFailed CreateRoom???");
	}

	public override void OnJoinedRoom()
	{
		UnityEngine.Debug.Log("JoinedRoom");
	}

	public override void OnPlayerEnteredRoom(Player newPlayer)
	{
		UnityEngine.Debug.Log("Enter Player");
	}
}
public class CsBatState : MonoBehaviour
{
	public int LevelLimit;

	public int IDNumber;

	public float Power = 1f;

	public float Radius = 0.2f;

	public float Height = 1.8f;

	[Header("0 == Default")]
	[Header("1 == Metal")]
	[Header("2 == Tennis ")]
	[Header("3 == ToyHammer")]
	[Header("4 == Stone")]
	[Header("5 == Explosion")]
	[Header("6 == Ice")]
	[Header("7 == Royal")]
	public int Type;

	public GameObject BatPF;
}
public class ScrollingUVs_Layers : MonoBehaviour
{
	public Vector2 uvAnimationRate = new Vector2(1f, 0f);

	public string textureName = "_MainTex";

	private Vector2 uvOffset = Vector2.zero;

	private void LateUpdate()
	{
		uvOffset += uvAnimationRate * Time.deltaTime;
		if (GetComponent<Renderer>().enabled)
		{
			GetComponent<Renderer>().sharedMaterial.SetTextureOffset(textureName, uvOffset);
		}
	}
}
public class ForArmCtrl : MonoBehaviour
{
	public Transform targetTr;

	public Transform handBone;

	public Transform up;

	private void Update()
	{
		base.transform.rotation = Quaternion.LookRotation(targetTr.position - base.transform.position, up.position - handBone.position);
	}
}
public class CrowdAnimation : MonoBehaviour
{
	public Texture2D[] textures;

	public float fps;

	public Material material;

	private int current;

	private void Start()
	{
		material = GetComponent<Renderer>().sharedMaterial;
		current = 0;
		StartCoroutine(UpdateAnimation());
	}

	private IEnumerator UpdateAnimation()
	{
		while (true)
		{
			current++;
			if (current >= textures.Length)
			{
				current = 0;
			}
			material.SetTexture("_MainTex", textures[current]);
			yield return new WaitForSeconds(1f / fps);
		}
	}
}
public class UseTest : MonoBehaviour
{
	public Transform HeadTrs;

	public Transform TargetTrs;

	public float angle;

	private void Update()
	{
		Vector3 forward = HeadTrs.forward;
		forward.y = 0f;
		forward.Normalize();
		Vector3 to = TargetTrs.position - HeadTrs.position;
		to.y = 0f;
		angle = Vector3.Angle(forward, to);
	}
}
public class TestCtrl : MonoBehaviour
{
	private void Start()
	{
		Invoke("TestView", 1f);
		Invoke("TestView", 2f);
	}

	public void TestView()
	{
	}

	private void YYYYY()
	{
		UnityEngine.Debug.Log("YYYYY");
	}

	private void NNNNN()
	{
		UnityEngine.Debug.Log("NNNNN");
	}
}
public class CsAutoMove : MonoBehaviour
{
	public Transform HeadCamera;

	public Transform RightCont;

	public Transform LeftCont;

	public Transform F_HeadTrs;

	public Transform F_RightTrs;

	public Transform F_LeftTrs;

	private void Update()
	{
		F_HeadTrs.position = HeadCamera.position;
		F_HeadTrs.rotation = HeadCamera.rotation;
		F_RightTrs.position = RightCont.position;
		F_RightTrs.rotation = RightCont.rotation;
		F_LeftTrs.position = LeftCont.position;
		F_LeftTrs.rotation = LeftCont.rotation;
	}
}
public class LocalizingDart : MonoBehaviour
{
	public GameObject[] LocalzingFbx_global;

	public GameObject[] LocalzingFbx_chinese;

	public GameObject BackObjParent;

	public Material BackMat_global;

	public Material BackMat_chinese;

	public TextMeshPro[] TextPro;

	public TMP_FontAsset TMP_Font_global;

	public TMP_FontAsset TMP_Font_chinese;

	public GameObject GlobalPosObj;

	public GameObject ChinesePosObj;

	private void Start()
	{
		Localizing(PublicGameUIManager.gameSetting.GetLanguageState());
		PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Localizing);
	}

	private void Localizing(LanguageState languageState)
	{
		StartCoroutine(DelayCorou(languageState));
	}

	private IEnumerator DelayCorou(LanguageState languageState)
	{
		yield return null;
		Material material;
		TMP_FontAsset font;
		if (languageState == LanguageState.schinese || languageState == LanguageState.tchinese)
		{
			material = BackMat_chinese;
			font = TMP_Font_chinese;
			for (int i = 0; i < LocalzingFbx_global.Length; i++)
			{
				LocalzingFbx_global[i].SetActive(value: false);
				LocalzingFbx_chinese[i].SetActive(value: true);
			}
			TextPro[3].rectTransform.localPosition = new Vector3(-0.282f, 0f, 0f);
		}
		else
		{
			material = BackMat_global;
			font = TMP_Font_global;
			for (int j = 0; j < LocalzingFbx_global.Length; j++)
			{
				LocalzingFbx_global[j].SetActive(value: true);
				LocalzingFbx_chinese[j].SetActive(value: false);
			}
			TextPro[3].rectTransform.localPosition = new Vector3(-0.485f, 0f, 0f);
		}
		Material[] materials = BackObjParent.transform.GetChild(0).GetComponent<MeshRenderer>().materials;
		materials[0] = material;
		for (int k = 0; k < BackObjParent.transform.childCount; k++)
		{
			BackObjParent.transform.GetChild(k).GetComponent<MeshRenderer>().materials = materials;
		}
		for (int l = 0; l < TextPro.Length; l++)
		{
			TextPro[l].font = font;
		}
		if (languageState != LanguageState.schinese && languageState != LanguageState.tchinese)
		{
			TextPro[0].text = "BUST";
			TextPro[1].text = "SET";
			TextPro[2].text = "BUST";
		}
	}
}
public class BallSpinTest : MonoBehaviour
{
	public Vector3 angleVelo;

	public Transform trans_Ball;

	private Rigidbody rigid_Ball;

	private void Start()
	{
		rigid_Ball = trans_Ball.GetComponent<Rigidbody>();
	}

	private void FixedUpdate()
	{
		rigid_Ball.AddForce(new Vector3(30f, 0f, 60f), ForceMode.Acceleration);
		if (Input.GetKeyDown(KeyCode.Space))
		{
			rigid_Ball.AddForce(0f, 100f, 20f, ForceMode.Impulse);
			StartCoroutine(DelayGetPreviewHitPos(rigid_Ball, GetComponent<ConstantForce>()));
		}
		if (Input.GetKeyDown(KeyCode.Mouse0))
		{
			rigid_Ball.velocity = Vector3.zero;
			rigid_Ball.angularVelocity = Vector3.zero;
			trans_Ball.position = new Vector3(0f, 0.5f, 0f);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
	}

	private IEnumerator DelayGetPreviewHitPos(Rigidbody rigid_Ball, ConstantForce constatForce = null)
	{
		yield return YieldInstructionCache.WaitForSeconds(Time.fixedDeltaTime);
		RootPhysics.GetPreviewHitPos(rigid_Ball, constatForce);
	}
}
public class Pelvis_CTRL : MonoBehaviour
{
	public Transform root;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.position = root.position + new Vector3(0f, -0.57f, 0f);
		base.transform.rotation = root.rotation;
	}
}
public class VRIK_CTRL : MonoBehaviour
{
	private struct Pose
	{
		public float time;

		public RigidPose pose;
	}

	public enum CheckList
	{
		None,
		Velo,
		Height,
		Both
	}

	public CheckList checkList;

	public Transform trans_Head;

	public GameObject[] activeFalseOB;

	public GameObject[] activeOnOB;

	private float MaxHeight = 1.6f;

	private float MinHeight = 0.6f;

	private bool isActiveHeight = true;

	private bool isActiveVelocity = true;

	private bool isSafe;

	private VRIK vrik;

	private Action Check;

	private Vector3 pos_Before;

	private int count;

	private bool isDone;

	private void Start()
	{
		vrik = GetComponent<VRIK>();
		GetComponent<CustomModelSettingCtrl>().InitCPU(CustomModelViewState.HalfCut2);
	}

	private void FixedUpdate()
	{
	}

	private void VelocityActive()
	{
		if (!(trans_Head == null))
		{
			Vector3 a = new Vector3(trans_Head.position.x, 0f, trans_Head.position.z);
			Vector3 b = new Vector3(pos_Before.x, 0f, pos_Before.z);
			float num = Vector3.Distance(a, b) * 10f;
			if (num > 0.1f)
			{
				isSafe = false;
			}
			else
			{
				isSafe = true;
			}
			if (num >= 5f && isActiveVelocity)
			{
				Active(isOn: false);
				isActiveVelocity = false;
			}
			else if (num < 0.5f && !isActiveVelocity && !isDone)
			{
				Invoke("OnVrik", 1f);
				isActiveVelocity = true;
			}
			count++;
			if (count % 10 == 0)
			{
				count = 0;
				pos_Before = trans_Head.position;
			}
		}
	}

	private void HeightActive()
	{
		if (!(trans_Head == null))
		{
			float y = trans_Head.position.y;
			if (y >= MinHeight && y <= MaxHeight && !isActiveHeight)
			{
				SetVrik(isOn: true);
				isActiveHeight = true;
			}
			else if ((y < MinHeight || y > MaxHeight) && isActiveHeight)
			{
				SetVrik(isOn: false);
				isActiveHeight = false;
			}
		}
	}

	private void SetVrik(bool isOn)
	{
		Active(isOn);
		vrik.solver.plantFeet = isOn;
	}

	private void OnVrik()
	{
		isDone = true;
		if (isSafe)
		{
			SetVrik(isOn: true);
		}
		isDone = false;
	}

	private void Active(bool isOn)
	{
		GameObject[] array = activeFalseOB;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(isOn);
		}
	}

	private IEnumerator ActiveFalseOn()
	{
		while (activeFalseOB[0].activeSelf)
		{
			yield return null;
		}
		yield return new WaitForSeconds(0.2f);
		GameObject[] array = activeFalseOB;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: false);
		}
		array = activeOnOB;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(value: true);
		}
	}

	private void SetCheckList()
	{
		switch (checkList)
		{
		case CheckList.Velo:
			Check = (Action)Delegate.Combine(Check, (Action)delegate
			{
				VelocityActive();
			});
			break;
		case CheckList.Height:
			Check = (Action)Delegate.Combine(Check, (Action)delegate
			{
				HeightActive();
			});
			break;
		case CheckList.Both:
			Check = (Action)Delegate.Combine(Check, (Action)delegate
			{
				VelocityActive();
			});
			Check = (Action)Delegate.Combine(Check, (Action)delegate
			{
				HeightActive();
			});
			break;
		case CheckList.None:
			break;
		}
	}
}
public class Arrow : XRGrabInteractable
{
	public float speed = 2000f;

	public Transform tip;

	private bool inAir;

	private Vector3 lastPosition = Vector3.zero;

	private Rigidbody rigidBody;

	protected override void Awake()
	{
		base.Awake();
		rigidBody = GetComponent<Rigidbody>();
	}

	private void FixedUpdate()
	{
		if (inAir)
		{
			CheckForCollision();
			lastPosition = tip.position;
		}
	}

	private void CheckForCollision()
	{
		if (Physics.Linecast(lastPosition, tip.position))
		{
			Stop();
		}
	}

	private void Stop()
	{
		inAir = false;
		SetPhysics(usePhysics: false);
	}

	public void Release(float pullValue)
	{
		inAir = true;
		SetPhysics(usePhysics: true);
		MaskAndFire(pullValue);
		StartCoroutine(RotateWithVelocity());
		lastPosition = tip.position;
	}

	private void SetPhysics(bool usePhysics)
	{
		rigidBody.isKinematic = !usePhysics;
		rigidBody.useGravity = usePhysics;
	}

	private void MaskAndFire(float power)
	{
		base.colliders[0].enabled = false;
		base.interactionLayerMask = 1 << Layer.NameToLayer(Layer.GameType.Billiards, "Ignore");
		Vector3 force = base.transform.forward * (power * speed);
		rigidBody.AddForce(force);
	}

	private IEnumerator RotateWithVelocity()
	{
		yield return new WaitForFixedUpdate();
		while (inAir)
		{
			Quaternion rotation = Quaternion.LookRotation(rigidBody.velocity, base.transform.up);
			base.transform.rotation = rotation;
			yield return null;
		}
	}

	public new void OnSelectEnter(XRBaseInteractor interactor)
	{
		base.OnSelectEnter(interactor);
	}

	public new void OnSelectExit(XRBaseInteractor interactor)
	{
		base.OnSelectExit(interactor);
	}
}
public class Bow : XRGrabInteractable
{
	private Animator animator;

	private Puller puller;

	protected override void Awake()
	{
		base.Awake();
		animator = GetComponent<Animator>();
		puller = GetComponentInChildren<Puller>();
	}

	public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)
	{
		base.ProcessInteractable(updatePhase);
		if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic && base.isSelected)
		{
			AnimateBow(puller.pullAmount);
		}
	}

	private void AnimateBow(float value)
	{
		animator.SetFloat("Blend", value);
	}
}
public class Notch : XRSocketInteractor
{
	private Puller puller;

	private Arrow currentArrow;

	public override XRBaseInteractable.MovementType? selectedInteractableMovementTypeOverride => XRBaseInteractable.MovementType.Instantaneous;

	protected override void Awake()
	{
		base.Awake();
		puller = GetComponent<Puller>();
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		puller.onSelectExit.AddListener(TryToReleaseArrow);
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		puller.onSelectExit.RemoveListener(TryToReleaseArrow);
	}

	protected override void OnSelectEnter(XRBaseInteractable interactable)
	{
		base.OnSelectEnter(interactable);
		StoreArrow(interactable);
	}

	private void StoreArrow(XRBaseInteractable interactable)
	{
		if (interactable is Arrow arrow)
		{
			currentArrow = arrow;
		}
	}

	private void TryToReleaseArrow(XRBaseInteractor interactor)
	{
		if ((bool)currentArrow)
		{
			ForceDeselect();
			ReleaseArrow();
		}
	}

	private void ForceDeselect()
	{
		OnSelectExit(currentArrow);
		currentArrow.OnSelectExit(this);
	}

	private void ReleaseArrow()
	{
		currentArrow.Release(puller.pullAmount);
		currentArrow = null;
	}
}
public class Puller : XRBaseInteractable
{
	public Transform start;

	public Transform end;

	public XRBaseInteractor pullingInteractor;

	public float pullAmount { get; private set; }

	protected override void OnSelectEnter(XRBaseInteractor interactor)
	{
		base.OnSelectEnter(interactor);
		pullingInteractor = interactor;
	}

	protected override void OnSelectExit(XRBaseInteractor interactor)
	{
		base.OnSelectExit(interactor);
		pullingInteractor = null;
		pullAmount = 0f;
	}

	public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)
	{
		base.ProcessInteractable(updatePhase);
		if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic && base.isSelected)
		{
			Vector3 position = pullingInteractor.transform.position;
			pullAmount = CalculatePull(position);
		}
	}

	private float CalculatePull(Vector3 pullPosition)
	{
		Vector3 lhs = pullPosition - start.position;
		Vector3 rhs = end.position - start.position;
		float magnitude = rhs.magnitude;
		rhs.Normalize();
		return Mathf.Clamp(Vector3.Dot(lhs, rhs) / magnitude, 0f, 1f);
	}
}
public class Quiver : XRSocketInteractor
{
	public GameObject arrowPrefab;

	private Vector3 attachOffset = Vector3.zero;

	protected override void Awake()
	{
		base.Awake();
		CreateAndSelectArrow();
		SetAttachOffset();
	}

	protected override void OnSelectExit(XRBaseInteractable interactable)
	{
		UnityEngine.Debug.Log("화살 생성");
		base.OnSelectExit(interactable);
		CreateAndSelectArrow();
	}

	private void CreateAndSelectArrow()
	{
		Arrow arrow = CreateArrow();
		SelectArrow(arrow);
	}

	private Arrow CreateArrow()
	{
		return UnityEngine.Object.Instantiate(arrowPrefab, base.transform.position - attachOffset, base.transform.rotation).GetComponent<Arrow>();
	}

	private void SelectArrow(Arrow arrow)
	{
		OnSelectEnter(arrow);
		arrow.OnSelectEnter(this);
	}

	private void SetAttachOffset()
	{
		if (base.selectTarget is XRGrabInteractable xRGrabInteractable)
		{
			attachOffset = xRGrabInteractable.attachTransform.localPosition;
		}
	}
}
public class Interpolation : MonoBehaviour, IPunObservable
{
	private Transform trans;

	private PhotonView pv;

	private Vector3 currPos = Vector3.zero;

	private Quaternion currRot = Quaternion.identity;

	private void Awake()
	{
		trans = GetComponent<Transform>();
		pv = GetComponent<PhotonView>();
		pv.Synchronization = ViewSynchronization.UnreliableOnChange;
		pv.ObservedComponents[0] = this;
		currPos = trans.position;
		currRot = trans.rotation;
	}

	private void OnEnable()
	{
		pv.Synchronization = ViewSynchronization.UnreliableOnChange;
	}

	private void OnDisable()
	{
		pv.Synchronization = ViewSynchronization.Off;
	}

	void IPunObservable.OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
	{
		if (PhotonNetwork.IsConnected)
		{
			if (stream.IsWriting)
			{
				stream.SendNext(trans.position);
				stream.SendNext(trans.rotation);
			}
			else
			{
				currPos = (Vector3)stream.ReceiveNext();
				currRot = (Quaternion)stream.ReceiveNext();
			}
		}
	}

	private void Start()
	{
	}

	private void Update()
	{
		if (!pv.IsMine)
		{
			trans.position = Vector3.Lerp(trans.position, currPos, Time.deltaTime * 3f);
			trans.rotation = Quaternion.Slerp(trans.rotation, currRot, Time.deltaTime * 3f);
		}
	}
}
public class Rot_CTRL : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(Vector3.up * 0.1f);
	}
}
public class Flag_SGT : SingletonBase.Singleton<Flag_SGT>
{
	private Transform[] trans_Flag;

	private MeshFilter[] meshFilter_Flag;

	private float[] speed = new float[10] { 10f, 10f, 10f, 10f, 10f, 10f, 10f, 10f, 10f, 10f };

	private int windDirection;

	private int[] globalScale = new int[10] { 20, 20, 20, 20, 20, 20, 20, 20, 20, 20 };

	private bool randomize;

	private float scaleX = 0.04f;

	private float scaleY = 0.01f;

	private float scaleZ = 0.011f;

	private bool waveX;

	private bool waveY = true;

	private bool waveZ = true;

	private Vector3[][] baseHeight = new Vector3[10][];

	private int count;

	private void Start()
	{
		trans_Flag = new Transform[base.transform.childCount];
		meshFilter_Flag = new MeshFilter[base.transform.childCount];
		for (int i = 0; i < base.transform.childCount; i++)
		{
			trans_Flag[i] = base.transform.GetChild(i);
			meshFilter_Flag[i] = trans_Flag[i].GetComponentInChildren<MeshFilter>();
		}
	}

	private void Update()
	{
		Play();
	}

	private void Play()
	{
		if (base.transform.gameObject.isStatic)
		{
			return;
		}
		for (int i = 0; i < trans_Flag.Length; i++)
		{
			Mesh mesh = meshFilter_Flag[i].mesh;
			if (baseHeight[i] == null)
			{
				baseHeight[i] = mesh.vertices;
			}
			Vector3[] array = new Vector3[baseHeight[i].Length];
			for (int j = 0; j < array.Length; j++)
			{
				Vector3 vector = baseHeight[i][j];
				if (waveY)
				{
					vector.y += Mathf.Sin(Time.time * speed[i] + baseHeight[i][j].x * (float)globalScale[i] + baseHeight[i][j].y * (float)globalScale[i] + baseHeight[i][j].z * (float)globalScale[i]) * scaleY;
				}
				if (waveZ)
				{
					vector.z += Mathf.Sin(Time.time * speed[i] + baseHeight[i][j].x * (float)globalScale[i] + baseHeight[i][j].y * (float)globalScale[i] + baseHeight[i][j].z * (float)globalScale[i]) * scaleZ;
				}
				if (waveX)
				{
					vector.x += Mathf.Sin(Time.time * speed[i] + baseHeight[i][j].x * (float)globalScale[i] + baseHeight[i][j].y * (float)globalScale[i] + baseHeight[i][j].z * (float)globalScale[i]) * scaleX;
				}
				array[j] = vector;
			}
			mesh.vertices = array;
			mesh.RecalculateNormals();
		}
	}

	public void SetWindRots(Quaternion Q)
	{
		for (int i = 0; i < trans_Flag.Length; i++)
		{
			trans_Flag[i].localRotation = Q;
		}
	}
}
public class CatchBallCtrl : MonoBehaviour
{
	public static CatchBallCtrl instance;

	public Animator anim;

	public GameObject[] renderGO;

	private Transform childTr;

	private float possibleDist = 0.01f;

	private Transform handTr;

	private bool isCheckStart;

	private bool isPossibleDist;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		childTr = base.transform.GetChild(0);
		base.gameObject.SetActive(value: false);
	}

	private void LateUpdate()
	{
		Vector3 position = Camera.main.transform.position;
		Vector3 normalized = new Vector3(Camera.main.transform.forward.x, 0f, Camera.main.transform.forward.z).normalized;
		Vector3 b = new Vector3(position.x, position.y * 0.9f, position.z) + normalized * 0.5f;
		base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * 5f);
		base.transform.rotation = Quaternion.LookRotation(base.transform.position - Camera.main.transform.position);
		childTr.Rotate(0f, Time.deltaTime * 30f, 0f);
		if (isCheckStart)
		{
			DistanceChack();
		}
	}

	public void SetHandTr(Transform m_handTr)
	{
		handTr = m_handTr;
	}

	public bool IsPossibleDist()
	{
		return isPossibleDist;
	}

	private void DistanceChack()
	{
		if ((base.transform.position - handTr.position).sqrMagnitude <= possibleDist && !isPossibleDist)
		{
			for (int i = 0; i < renderGO.Length; i++)
			{
				renderGO[i].SetActive(value: false);
			}
			isPossibleDist = true;
		}
		else if ((base.transform.position - handTr.position).sqrMagnitude > possibleDist && isPossibleDist)
		{
			for (int j = 0; j < renderGO.Length; j++)
			{
				renderGO[j].SetActive(value: true);
			}
			isPossibleDist = false;
		}
	}

	private void OnEnable()
	{
		isCheckStart = false;
		base.transform.position = Vector3.up * 0.5f;
		for (int i = 0; i < renderGO.Length; i++)
		{
			renderGO[i].SetActive(value: false);
		}
		CancelInvoke("StartCheck");
		Invoke("StartCheck", 1f);
	}

	private void OnDisable()
	{
		CancelInvoke("StartCheck");
		isPossibleDist = false;
	}

	private void StartCheck()
	{
		isCheckStart = true;
		anim.SetTrigger("Start");
		for (int i = 0; i < renderGO.Length; i++)
		{
			renderGO[i].SetActive(value: true);
		}
	}
}
public class RefereeCtrl : MonoBehaviour
{
	public static RefereeCtrl instance;

	private Animator anim;

	private LookAtIK[] lookAtIK;

	private Transform idleTarget;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private void Start()
	{
		anim = base.transform.Find("referee_1").GetComponent<Animator>();
		lookAtIK = GetComponentsInChildren<LookAtIK>();
		idleTarget = base.transform.Find("Target");
		SetTarget();
	}

	public void SetAnim(int state)
	{
		switch (state)
		{
		case 0:
			anim.SetTrigger("Let_L");
			break;
		case 1:
			anim.SetTrigger("Let_R");
			break;
		case 2:
			anim.SetTrigger("Out_L");
			break;
		case 3:
			anim.SetTrigger("Out_R");
			break;
		}
	}

	public void SetTarget(Transform ballTr = null)
	{
		if (ballTr == null)
		{
			ballTr = idleTarget;
		}
		for (int i = 0; i < lookAtIK.Length; i++)
		{
			lookAtIK[i].solver.target = ballTr;
		}
	}
}
public class ServicePlaneCtrl : MonoBehaviour
{
	public static ServicePlaneCtrl instance;

	public Animator anim;

	private void Awake()
	{
		if (instance == null)
		{
			instance = this;
		}
		if (instance != this)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void SetState(int num)
	{
		switch (num)
		{
		case 0:
			anim.SetTrigger("State00");
			break;
		case 1:
			anim.SetTrigger("State01");
			break;
		case 2:
			anim.SetTrigger("State02");
			break;
		}
	}
}
public class LookCamera : MonoBehaviour
{
	public float speedNormal = 10f;

	public float speedFast = 50f;

	public float mouseSensitivityX = 5f;

	public float mouseSensitivityY = 5f;

	private float rotY;

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void Update()
	{
		if (Input.GetMouseButton(1))
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * mouseSensitivityX;
			rotY += Input.GetAxis("Mouse Y") * mouseSensitivityY;
			rotY = Mathf.Clamp(rotY, -89.5f, 89.5f);
			base.transform.localEulerAngles = new Vector3(0f - rotY, y, 0f);
		}
		if (Input.GetKey(KeyCode.U))
		{
			base.gameObject.transform.localPosition = new Vector3(0f, 3500f, 0f);
		}
	}
}
public class BallCount_CTRL : MonoBehaviour
{
	public Image[] image;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void RightOn(int num)
	{
		switch (num)
		{
		case 0:
		{
			Image[] array = image;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].color = Color.red;
			}
			break;
		}
		case 1:
			image[0].color = Color.white;
			break;
		case 2:
			image[1].color = Color.white;
			break;
		case 3:
			StartCoroutine(Right_On_C());
			break;
		}
	}

	private IEnumerator Right_On_C()
	{
		image[2].color = Color.white;
		yield return YieldInstructionCache.WaitForSeconds(1f);
		Image[] array = image;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].color = Color.red;
		}
	}
}
public class BasketballMovie : MonoBehaviour
{
	public GameObject[] Cameras;

	public bool isDone;

	private void Start()
	{
		Time.timeScale = 1.2f;
		StartCoroutine(StartAutoSwichCamera(5f));
	}

	private void Update()
	{
	}

	private IEnumerator StartAutoSwichCamera(float deleyTime)
	{
		yield return YieldInstructionCache.WaitForSeconds(deleyTime);
		Cameras[0].SetActive(value: true);
		yield return YieldInstructionCache.WaitForSeconds(deleyTime);
		Cameras[1].SetActive(value: true);
		yield return YieldInstructionCache.WaitForSeconds(deleyTime);
		Cameras[2].SetActive(value: true);
	}
}
public class TreeLODSetter : MonoBehaviour
{
}
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
public class OvrAvatarTestDriver : OvrAvatarDriver
{
	private Vector3 headPos = new Vector3(0f, 1.6f, 0f);

	private Quaternion headRot = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = headPos,
			headRotation = headRot,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class PoseEditHelper : MonoBehaviour
{
	public Transform poseRoot;

	private void OnDrawGizmos()
	{
		if (poseRoot != null)
		{
			DrawJoints(poseRoot);
		}
	}

	private void DrawJoints(Transform joint)
	{
		Gizmos.DrawWireSphere(joint.position, 0.005f);
		for (int i = 0; i < joint.childCount; i++)
		{
			Transform child = joint.GetChild(i);
			if (!child.name.EndsWith("_grip") && !child.name.EndsWith("hand_ignore"))
			{
				Gizmos.DrawLine(joint.position, child.position);
				DrawJoints(child);
			}
		}
	}
}
public class GazeTargetSpawner : MonoBehaviour
{
	public GameObject GazeTargetPrefab;

	public int NumberOfDummyTargets = 100;

	public int RadiusMultiplier = 3;

	[SerializeField]
	private bool isVisible;

	public bool IsVisible
	{
		get
		{
			return isVisible;
		}
		set
		{
			isVisible = value;
			GazeTarget[] componentsInChildren = base.gameObject.GetComponentsInChildren<GazeTarget>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				MeshRenderer component = componentsInChildren[i].GetComponent<MeshRenderer>();
				if (component != null)
				{
					component.enabled = isVisible;
				}
			}
		}
	}

	private void Start()
	{
		for (int i = 0; i < NumberOfDummyTargets; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(GazeTargetPrefab, base.transform);
			obj.name = obj.name + "_" + i;
			obj.transform.localPosition = UnityEngine.Random.insideUnitSphere * RadiusMultiplier;
			obj.transform.rotation = Quaternion.identity;
			obj.GetComponent<MeshRenderer>().enabled = IsVisible;
		}
	}

	private void OnValidate()
	{
		IsVisible = isVisible;
	}
}
public class RemoteLoopbackManager : MonoBehaviour
{
	private class PacketLatencyPair
	{
		public byte[] PacketData;

		public float FakeLatency;
	}

	[Serializable]
	public class SimulatedLatencySettings
	{
		[Range(0f, 0.5f)]
		public float FakeLatencyMax = 0.25f;

		[Range(0f, 0.5f)]
		public float FakeLatencyMin = 0.002f;

		[Range(0f, 1f)]
		public float LatencyWeight = 0.25f;

		[Range(0f, 10f)]
		public int MaxSamples = 4;

		internal float AverageWindow;

		internal float LatencySum;

		internal LinkedList<float> LatencyValues = new LinkedList<float>();

		public float NextValue()
		{
			AverageWindow = LatencySum / (float)LatencyValues.Count;
			float num = UnityEngine.Random.Range(FakeLatencyMin, FakeLatencyMax);
			float num2 = AverageWindow * (1f - LatencyWeight) + LatencyWeight * num;
			if (LatencyValues.Count >= MaxSamples)
			{
				LatencySum -= LatencyValues.First.Value;
				LatencyValues.RemoveFirst();
			}
			LatencySum += num2;
			LatencyValues.AddLast(num2);
			return num2;
		}
	}

	public OvrAvatar LocalAvatar;

	public OvrAvatar LoopbackAvatar;

	public SimulatedLatencySettings LatencySettings = new SimulatedLatencySettings();

	private int PacketSequence;

	private LinkedList<PacketLatencyPair> packetQueue = new LinkedList<PacketLatencyPair>();

	private void Start()
	{
		LocalAvatar.RecordPackets = true;
		OvrAvatar localAvatar = LocalAvatar;
		localAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(localAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		float num = UnityEngine.Random.Range(LatencySettings.FakeLatencyMin, LatencySettings.FakeLatencyMax);
		LatencySettings.LatencyValues.AddFirst(num);
		LatencySettings.LatencySum += num;
	}

	private void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (LocalAvatar.UseSDKPackets)
		{
			uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
			byte[] buffer = new byte[num];
			Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
			binaryWriter.Write(PacketSequence++);
			binaryWriter.Write(num);
			binaryWriter.Write(buffer);
		}
		else
		{
			binaryWriter.Write(PacketSequence++);
			args.Packet.Write(memoryStream);
		}
		SendPacketData(memoryStream.ToArray());
	}

	private void Update()
	{
		if (packetQueue.Count <= 0)
		{
			return;
		}
		List<PacketLatencyPair> list = new List<PacketLatencyPair>();
		foreach (PacketLatencyPair item in packetQueue)
		{
			item.FakeLatency -= Time.deltaTime;
			if (item.FakeLatency < 0f)
			{
				ReceivePacketData(item.PacketData);
				list.Add(item);
			}
		}
		foreach (PacketLatencyPair item2 in list)
		{
			packetQueue.Remove(item2);
		}
	}

	private void SendPacketData(byte[] data)
	{
		PacketLatencyPair packetLatencyPair = new PacketLatencyPair();
		packetLatencyPair.PacketData = data;
		packetLatencyPair.FakeLatency = LatencySettings.NextValue();
		packetQueue.AddLast(packetLatencyPair);
	}

	private void ReceivePacketData(byte[] data)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(memoryStream);
		int sequence = binaryReader.ReadInt32();
		OvrAvatarPacket packet;
		if (LoopbackAvatar.UseSDKPackets)
		{
			int count = binaryReader.ReadInt32();
			byte[] buffer = binaryReader.ReadBytes(count);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
			packet = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
		}
		else
		{
			packet = OvrAvatarPacket.Read(memoryStream);
		}
		LoopbackAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet);
	}
}
public class P2PManager
{
	private enum MessageType : byte
	{
		Update = 1
	}

	public P2PManager()
	{
		Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
		Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Net.Connect(userID);
			SocialPlatformManager.LogOutput("P2P connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Net.Close(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("P2P request accepted from " + msg.Data.ID);
			Net.Accept(msg.Data.ID);
		}
	}

	private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.p2pConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Net.Connect(msg.Data.ID);
				SocialPlatformManager.LogOutput("P2P re-connect to " + msg.Data.ID);
			}
		}
	}

	public void SendAvatarUpdate(ulong userID, Transform rootTransform, uint sequence, byte[] avatarPacket)
	{
		byte[] array = new byte[avatarPacket.Length + 41];
		int offset = 0;
		PackByte(1, array, ref offset);
		PackULong(SocialPlatformManager.MyID, array, ref offset);
		PackFloat(rootTransform.position.x, array, ref offset);
		PackFloat(0f, array, ref offset);
		PackFloat(rootTransform.position.z, array, ref offset);
		PackFloat(rootTransform.rotation.x, array, ref offset);
		PackFloat(rootTransform.rotation.y, array, ref offset);
		PackFloat(rootTransform.rotation.z, array, ref offset);
		PackFloat(rootTransform.rotation.w, array, ref offset);
		PackUInt32(sequence, array, ref offset);
		Buffer.BlockCopy(avatarPacket, 0, array, offset, avatarPacket.Length);
		Net.SendPacket(userID, array, SendPolicy.Unreliable);
	}

	public void GetRemotePackets()
	{
		Packet packet;
		while ((packet = Net.ReadPacket()) != null)
		{
			byte[] packet2 = new byte[packet.Size];
			packet.ReadBytes(packet2);
			int offset = 0;
			MessageType messageType = (MessageType)ReadByte(packet2, ref offset);
			ulong num = ReadULong(packet2, ref offset);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(num);
			if (remoteUser == null)
			{
				SocialPlatformManager.LogOutput("Unknown remote player: " + num);
			}
			else if (messageType == MessageType.Update)
			{
				processAvatarPacket(remoteUser, ref packet2, ref offset);
			}
			else
			{
				SocialPlatformManager.LogOutput("Invalid packet type: " + packet.Size);
			}
		}
	}

	public void processAvatarPacket(RemotePlayer remote, ref byte[] packet, ref int offset)
	{
		if (remote != null)
		{
			remote.receivedRootPositionPrior = remote.receivedRootPosition;
			remote.receivedRootPosition.x = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.y = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotationPrior = remote.receivedRootRotation;
			remote.receivedRootRotation.x = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.y = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.w = ReadFloat(packet, ref offset);
			remote.RemoteAvatar.transform.position = remote.receivedRootPosition;
			remote.RemoteAvatar.transform.rotation = remote.receivedRootRotation;
			int sequence = (int)ReadUInt32(packet, ref offset);
			byte[] array = new byte[packet.Length - offset];
			Buffer.BlockCopy(packet, offset, array, 0, array.Length);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)array.Length, array);
			OvrAvatarPacket packet2 = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
			remote.RemoteAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet2);
		}
	}

	private void PackByte(byte b, byte[] buf, ref int offset)
	{
		buf[offset] = b;
		offset++;
	}

	private byte ReadByte(byte[] buf, ref int offset)
	{
		byte result = buf[offset];
		offset++;
		return result;
	}

	private void PackFloat(float f, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
		offset += 4;
	}

	private float ReadFloat(byte[] buf, ref int offset)
	{
		float result = BitConverter.ToSingle(buf, offset);
		offset += 4;
		return result;
	}

	private void PackULong(ulong u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 8);
		offset += 8;
	}

	private ulong ReadULong(byte[] buf, ref int offset)
	{
		ulong result = BitConverter.ToUInt64(buf, offset);
		offset += 8;
		return result;
	}

	private void PackUInt32(uint u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 4);
		offset += 4;
	}

	private uint ReadUInt32(byte[] buf, ref int offset)
	{
		uint result = BitConverter.ToUInt32(buf, offset);
		offset += 4;
		return result;
	}
}
public class PlayerController : SocialPlatformManager
{
	public Camera spyCamera;

	private GameObject cameraRig;

	private bool showUI = true;

	public override void Awake()
	{
		base.Awake();
		cameraRig = localPlayerHead.gameObject;
	}

	public override void Start()
	{
		base.Start();
		spyCamera.enabled = false;
	}

	public override void Update()
	{
		base.Update();
		checkInput();
	}

	private void checkInput()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			if (OVRInput.GetDown(OVRInput.Button.Back))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
			{
				ToggleUI();
			}
		}
		else
		{
			if (OVRInput.GetDown(OVRInput.Button.Three))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.Four))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick))
			{
				ToggleUI();
			}
		}
	}

	private void ToggleCamera()
	{
		spyCamera.enabled = !spyCamera.enabled;
		localAvatar.ShowThirdPerson = !localAvatar.ShowThirdPerson;
		cameraRig.SetActive(!cameraRig.activeSelf);
	}

	private void ToggleUI()
	{
		showUI = !showUI;
		helpPanel.SetActive(showUI);
		localAvatar.ShowLeftController(showUI);
	}
}
public class RemotePlayer
{
	public ulong remoteUserID;

	public bool stillInRoom;

	public PeerConnectionState p2pConnectionState;

	public PeerConnectionState voipConnectionState;

	public OvrAvatar RemoteAvatar;

	public Vector3 receivedRootPosition;

	public Vector3 receivedRootPositionPrior;

	public Quaternion receivedRootRotation;

	public Quaternion receivedRootRotationPrior;

	public VoipAudioSourceHiLevel voipSource;
}
public class RoomManager
{
	public ulong roomID;

	private ulong invitedRoomID;

	private bool amIServer;

	private bool startupDone;

	public RoomManager()
	{
		amIServer = false;
		startupDone = false;
		Rooms.SetRoomInviteAcceptedNotificationCallback(AcceptingInviteCallback);
		Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
	}

	private void AcceptingInviteCallback(Message<string> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		SocialPlatformManager.LogOutput("Launched Invite to join Room: " + msg.Data);
		invitedRoomID = Convert.ToUInt64(msg.GetString());
		if (startupDone)
		{
			CheckForInvite();
		}
	}

	public bool CheckForInvite()
	{
		startupDone = true;
		if (invitedRoomID != 0L)
		{
			JoinExistingRoom(invitedRoomID);
			return true;
		}
		return false;
	}

	public void CreateRoom()
	{
		Rooms.CreateAndJoinPrivate(RoomJoinPolicy.FriendsOfOwner, 4u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
	}

	private void CreateAndJoinPrivateRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		roomID = msg.Data.ID;
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}

	private void OnLaunchInviteWorkflowComplete(Message msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
		}
	}

	public void JoinExistingRoom(ulong roomID)
	{
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.JOINING_A_ROOM);
		Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
	}

	private void JoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (!msg.IsError)
		{
			string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			SocialPlatformManager.LogOutput("Joined Room " + msg.Data.ID + " owner: " + text + " count: " + num);
			roomID = msg.Data.ID;
			ProcessRoomData(msg);
		}
	}

	private void RoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
		int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
		SocialPlatformManager.LogOutput("Room Update " + msg.Data.ID + " owner: " + text + " count: " + num);
		ProcessRoomData(msg);
	}

	public void LeaveCurrentRoom()
	{
		if (roomID != 0L)
		{
			Rooms.Leave(roomID);
			roomID = 0uL;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.LEAVING_A_ROOM);
	}

	private void ProcessRoomData(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		}
		else
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.CONNECTED_IN_A_ROOM);
		}
		SocialPlatformManager.MarkAllRemoteUsersAsNotInRoom();
		if (msg.Data.UsersOptional != null)
		{
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != SocialPlatformManager.MyID)
				{
					if (!SocialPlatformManager.IsUserInRoom(item.ID))
					{
						SocialPlatformManager.AddRemoteUser(item.ID);
					}
					else
					{
						SocialPlatformManager.MarkRemoteUserInRoom(item.ID);
					}
				}
			}
		}
		SocialPlatformManager.ForgetRemoteUsersNotInRoom();
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}
}
public class SocialPlatformManager : MonoBehaviour
{
	public enum State
	{
		INITIALIZING,
		CHECKING_LAUNCH_STATE,
		CREATING_A_ROOM,
		WAITING_IN_A_ROOM,
		JOINING_A_ROOM,
		CONNECTED_IN_A_ROOM,
		LEAVING_A_ROOM,
		SHUTDOWN
	}

	private static readonly Vector3 START_ROTATION_ONE = new Vector3(0f, 180f, 0f);

	private static readonly Vector3 START_POSITION_ONE = new Vector3(0f, 4f, 5f);

	private static readonly Vector3 START_ROTATION_TWO = new Vector3(0f, 0f, 0f);

	private static readonly Vector3 START_POSITION_TWO = new Vector3(0f, 4f, -5f);

	private static readonly Vector3 START_ROTATION_THREE = new Vector3(0f, 270f, 0f);

	private static readonly Vector3 START_POSITION_THREE = new Vector3(5f, 4f, 0f);

	private static readonly Vector3 START_ROTATION_FOUR = new Vector3(0f, 90f, 0f);

	private static readonly Vector3 START_POSITION_FOUR = new Vector3(-5f, 4f, 0f);

	private static readonly Color BLACK = new Color(0f, 0f, 0f);

	private static readonly Color WHITE = new Color(1f, 1f, 1f);

	private static readonly Color CYAN = new Color(0f, 1f, 1f);

	private static readonly Color BLUE = new Color(0f, 0f, 1f);

	private static readonly Color GREEN = new Color(0f, 1f, 0f);

	private float voiceCurrent;

	private uint packetSequence;

	public OvrAvatar localAvatarPrefab;

	public OvrAvatar remoteAvatarPrefab;

	public GameObject helpPanel;

	protected MeshRenderer helpMesh;

	public Material riftMaterial;

	public Material gearMaterial;

	protected OvrAvatar localAvatar;

	protected GameObject localTrackingSpace;

	protected GameObject localPlayerHead;

	protected Dictionary<ulong, RemotePlayer> remoteUsers = new Dictionary<ulong, RemotePlayer>();

	public GameObject roomSphere;

	protected MeshRenderer sphereMesh;

	public GameObject roomFloor;

	protected MeshRenderer floorMesh;

	protected State currentState;

	protected static SocialPlatformManager s_instance = null;

	protected RoomManager roomManager;

	protected P2PManager p2pManager;

	protected VoipManager voipManager;

	protected ulong myID;

	protected string myOculusID;

	public static readonly float VOIP_SCALE = 2f;

	public static State CurrentState => s_instance.currentState;

	public static ulong MyID
	{
		get
		{
			if (s_instance != null)
			{
				return s_instance.myID;
			}
			return 0uL;
		}
	}

	public static string MyOculusID
	{
		get
		{
			if (s_instance != null && s_instance.myOculusID != null)
			{
				return s_instance.myOculusID;
			}
			return string.Empty;
		}
	}

	public virtual void Update()
	{
		p2pManager.GetRemotePackets();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			if (remoteUser.Value.voipSource == null && remoteUser.Value.RemoteAvatar.MouthAnchor != null)
			{
				remoteUser.Value.voipSource = remoteUser.Value.RemoteAvatar.MouthAnchor.AddComponent<VoipAudioSourceHiLevel>();
				remoteUser.Value.voipSource.senderID = remoteUser.Value.remoteUserID;
			}
			if (remoteUser.Value.voipSource != null)
			{
				float voiceAmplitude = Mathf.Clamp(remoteUser.Value.voipSource.peakAmplitude * VOIP_SCALE, 0f, 1f);
				remoteUser.Value.RemoteAvatar.VoiceAmplitude = voiceAmplitude;
			}
		}
		if (localAvatar != null)
		{
			localAvatar.VoiceAmplitude = Mathf.Clamp(voiceCurrent * VOIP_SCALE, 0f, 1f);
		}
		Request.RunCallbacks();
	}

	public virtual void Awake()
	{
		LogOutputLine("Start Log.");
		helpMesh = helpPanel.GetComponent<MeshRenderer>();
		sphereMesh = roomSphere.GetComponent<MeshRenderer>();
		floorMesh = roomFloor.GetComponent<MeshRenderer>();
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localPlayerHead = base.transform.Find("OVRCameraRig/TrackingSpace/CenterEyeAnchor").gameObject;
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		TransitionToState(State.INITIALIZING);
		Core.AsyncInitialize().OnComplete(InitCallback);
		roomManager = new RoomManager();
		p2pManager = new P2PManager();
		voipManager = new VoipManager();
	}

	private void InitCallback(Message<PlatformInitialize> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		LaunchDetails launchDetails = ApplicationLifecycle.GetLaunchDetails();
		LogOutput("App launched with LaunchType " + launchDetails.LaunchType);
		Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
	}

	public virtual void Start()
	{
	}

	private void IsEntitledCallback(Message msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
		}
		else
		{
			Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
		}
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		myID = msg.Data.ID;
		myOculusID = msg.Data.OculusID;
		localAvatar = UnityEngine.Object.Instantiate(localAvatarPrefab);
		localAvatar.CanOwnMicrophone = false;
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localAvatar.transform.SetParent(localTrackingSpace.transform, worldPositionStays: false);
		localAvatar.transform.localPosition = new Vector3(0f, 0f, 0f);
		localAvatar.transform.localRotation = Quaternion.identity;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("body"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 1f, 1f);
			helpMesh.material = gearMaterial;
		}
		else
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("hand_left"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 0.2f, 0.2f);
			helpMesh.material = riftMaterial;
		}
		localAvatar.oculusUserID = myID.ToString();
		localAvatar.RecordPackets = true;
		OvrAvatar ovrAvatar = localAvatar;
		ovrAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(ovrAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		localAvatar.EnableMouthVertexAnimation = true;
		Quaternion identity = Quaternion.identity;
		switch (UnityEngine.Random.Range(0, 4))
		{
		case 0:
			identity.eulerAngles = START_ROTATION_ONE;
			base.transform.localPosition = START_POSITION_ONE;
			base.transform.localRotation = identity;
			break;
		case 1:
			identity.eulerAngles = START_ROTATION_TWO;
			base.transform.localPosition = START_POSITION_TWO;
			base.transform.localRotation = identity;
			break;
		case 2:
			identity.eulerAngles = START_ROTATION_THREE;
			base.transform.localPosition = START_POSITION_THREE;
			base.transform.localRotation = identity;
			break;
		default:
			identity.eulerAngles = START_ROTATION_FOUR;
			base.transform.localPosition = START_POSITION_FOUR;
			base.transform.localRotation = identity;
			break;
		}
		TransitionToState(State.CHECKING_LAUNCH_STATE);
		if (!roomManager.CheckForInvite())
		{
			LogOutput("No invite on launch, looking for a friend to join.");
			Users.GetLoggedInUserFriendsAndRooms().OnComplete(GetLoggedInUserFriendsAndRoomsCallback);
		}
		Voip.SetMicrophoneFilterCallback(MicFilter);
	}

	private void GetLoggedInUserFriendsAndRoomsCallback(Message<UserAndRoomList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		foreach (UserAndRoom datum in msg.Data)
		{
			if (datum.User != null && datum.RoomOptional != null && !datum.RoomOptional.IsMembershipLocked && datum.RoomOptional.Joinability == RoomJoinability.CanJoin && datum.RoomOptional.JoinPolicy != 0)
			{
				LogOutput("Trying to join room " + datum.RoomOptional.ID + ", friend " + datum.User.OculusID);
				roomManager.JoinExistingRoom(datum.RoomOptional.ID);
				return;
			}
		}
		LogOutput("No friend to join. Creating my own room.");
		roomManager.CreateRoom();
		TransitionToState(State.CREATING_A_ROOM);
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] array = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, array);
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.SendAvatarUpdate(remoteUser.Key, localTrackingSpace.transform, packetSequence, array);
		}
		packetSequence++;
	}

	public void OnApplicationQuit()
	{
		roomManager.LeaveCurrentRoom();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.Disconnect(remoteUser.Key);
			voipManager.Disconnect(remoteUser.Key);
		}
		LogOutputLine("End Log.");
	}

	public void AddUser(ulong userID, ref RemotePlayer remoteUser)
	{
		remoteUsers.Add(userID, remoteUser);
	}

	public void LogOutputLine(string line)
	{
		UnityEngine.Debug.Log(Time.time + ": " + line);
	}

	public static void TerminateWithError(Message msg)
	{
		s_instance.LogOutputLine("Error: " + msg.GetError().Message);
		UnityEngine.Application.Quit();
	}

	public static void TransitionToState(State newState)
	{
		if ((bool)s_instance)
		{
			s_instance.LogOutputLine(string.Concat("State ", s_instance.currentState, " -> ", newState));
		}
		if ((bool)s_instance && s_instance.currentState != newState)
		{
			s_instance.currentState = newState;
			if (newState == State.SHUTDOWN)
			{
				s_instance.OnApplicationQuit();
			}
		}
		SetSphereColorForState();
	}

	private static void SetSphereColorForState()
	{
		switch (s_instance.currentState)
		{
		case State.INITIALIZING:
		case State.SHUTDOWN:
			s_instance.sphereMesh.material.color = BLACK;
			break;
		case State.WAITING_IN_A_ROOM:
			s_instance.sphereMesh.material.color = WHITE;
			break;
		case State.CONNECTED_IN_A_ROOM:
			s_instance.sphereMesh.material.color = CYAN;
			break;
		}
	}

	public static void SetFloorColorForState(bool host)
	{
		if (host)
		{
			s_instance.floorMesh.material.color = BLUE;
		}
		else
		{
			s_instance.floorMesh.material.color = GREEN;
		}
	}

	public static void MarkAllRemoteUsersAsNotInRoom()
	{
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			remoteUser.Value.stillInRoom = false;
		}
	}

	public static void MarkRemoteUserInRoom(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			value.stillInRoom = true;
		}
	}

	public static void ForgetRemoteUsersNotInRoom()
	{
		List<ulong> list = new List<ulong>();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			if (!remoteUser.Value.stillInRoom)
			{
				list.Add(remoteUser.Key);
			}
		}
		foreach (ulong item in list)
		{
			RemoveRemoteUser(item);
		}
	}

	public static void LogOutput(string line)
	{
		s_instance.LogOutputLine(Time.time + ": " + line);
	}

	public static bool IsUserInRoom(ulong userID)
	{
		return s_instance.remoteUsers.ContainsKey(userID);
	}

	public static void AddRemoteUser(ulong userID)
	{
		RemotePlayer remoteUser = new RemotePlayer();
		remoteUser.RemoteAvatar = UnityEngine.Object.Instantiate(s_instance.remoteAvatarPrefab);
		remoteUser.RemoteAvatar.oculusUserID = userID.ToString();
		remoteUser.RemoteAvatar.ShowThirdPerson = true;
		remoteUser.RemoteAvatar.EnableMouthVertexAnimation = true;
		remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
		remoteUser.voipConnectionState = PeerConnectionState.Unknown;
		remoteUser.stillInRoom = true;
		remoteUser.remoteUserID = userID;
		s_instance.AddUser(userID, ref remoteUser);
		s_instance.p2pManager.ConnectTo(userID);
		s_instance.voipManager.ConnectTo(userID);
		s_instance.LogOutputLine("Adding User " + userID);
	}

	public static void RemoveRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			UnityEngine.Object.Destroy(value.RemoteAvatar.MouthAnchor.GetComponent<VoipAudioSourceHiLevel>(), 0f);
			UnityEngine.Object.Destroy(value.RemoteAvatar.gameObject, 0f);
			s_instance.remoteUsers.Remove(userID);
			s_instance.LogOutputLine("Removing User " + userID);
		}
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (localAvatar != null)
		{
			localAvatar.UpdateVoiceData(pcmData, numChannels);
		}
		float num = 0f;
		float[] array = new float[pcmData.Length];
		for (int i = 0; i < pcmData.Length; i++)
		{
			float num2 = (array[i] = (float)pcmData[i] / 32767f);
			if (num2 > num)
			{
				num = num2;
			}
		}
		voiceCurrent = num;
	}

	[MonoPInvokeCallback(typeof(Oculus.Platform.CAPI.FilterCallback))]
	public static void MicFilter(short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels)
	{
		s_instance.UpdateVoiceData(pcmData, numChannels);
	}

	public static RemotePlayer GetRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			return value;
		}
		return null;
	}
}
public class VoipManager
{
	public VoipManager()
	{
		Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
		Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Voip.Start(userID);
			SocialPlatformManager.LogOutput("Voip connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Voip.Stop(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.voipConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("Voip request accepted from " + msg.Data.ID);
			Voip.Accept(msg.Data.ID);
		}
	}

	private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.voipConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Voip.Start(msg.Data.ID);
				SocialPlatformManager.LogOutput("Voip re-connect to " + msg.Data.ID);
			}
		}
	}
}
public class GazeTarget : MonoBehaviour
{
	public ovrAvatarGazeTargetType Type;

	private static ovrAvatarGazeTargets RuntimeTargetList;

	static GazeTarget()
	{
		RuntimeTargetList.targets = new ovrAvatarGazeTarget[128];
		RuntimeTargetList.targetCount = 1u;
	}

	private void Start()
	{
		UpdateGazeTarget();
		base.transform.hasChanged = false;
	}

	private void Update()
	{
		if (base.transform.hasChanged)
		{
			base.transform.hasChanged = false;
			UpdateGazeTarget();
		}
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.ovrAvatar_RemoveGazeTargets(1u, new uint[1] { (uint)base.transform.GetInstanceID() });
	}

	private void UpdateGazeTarget()
	{
		ovrAvatarGazeTarget ovrAvatarGazeTarget2 = CreateOvrGazeTarget((uint)base.transform.GetInstanceID(), base.transform.position, Type);
		RuntimeTargetList.targets[0] = ovrAvatarGazeTarget2;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateGazeTargets(RuntimeTargetList);
	}

	private ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}
}
[Serializable]
public class AvatarLayer
{
	public int layerIndex;
}
[Serializable]
public class PacketRecordSettings
{
	internal bool RecordingFrames;

	public float UpdateRate = 1f / 30f;

	internal float AccumulatedTime;
}
public class OvrAvatar : MonoBehaviour
{
	public class PacketEventArgs : EventArgs
	{
		public readonly OvrAvatarPacket Packet;

		public PacketEventArgs(OvrAvatarPacket packet)
		{
			Packet = packet;
		}
	}

	public enum HandType
	{
		Right,
		Left,
		Max
	}

	public enum HandJoint
	{
		HandBase,
		IndexBase,
		IndexTip,
		ThumbBase,
		ThumbTip,
		Max
	}

	[Header("Avatar")]
	public IntPtr sdkAvatar = IntPtr.Zero;

	public string oculusUserID;

	public OvrAvatarDriver Driver;

	[Header("Capabilities")]
	public bool EnableBody = true;

	public bool EnableHands = true;

	public bool EnableBase = true;

	public bool EnableExpressive;

	[Header("Network")]
	public bool RecordPackets;

	public bool UseSDKPackets = true;

	public PacketRecordSettings PacketSettings = new PacketRecordSettings();

	[Header("Visibility")]
	public bool StartWithControllers;

	public AvatarLayer FirstPersonLayer;

	public AvatarLayer ThirdPersonLayer;

	public bool ShowFirstPerson = true;

	public bool ShowThirdPerson;

	internal ovrAvatarCapabilities Capabilities = ovrAvatarCapabilities.Body;

	[Header("Performance")]
	[Tooltip("LOD mesh complexity and texture resolution. Highest LOD recommended on PC and simple mobile apps. Medium LOD recommended on mobile devices or for background characters on PC. Lowest LOD recommended for background characters on mobile.")]
	[SerializeField]
	internal ovrAvatarAssetLevelOfDetail LevelOfDetail = ovrAvatarAssetLevelOfDetail.Medium;

	[Tooltip("Enable to use combined meshes to reduce draw calls. Currently only available on mobile devices. Will be forced to false on PC.")]
	private bool CombineMeshes = true;

	[Tooltip("Enable to use transparent queue, disable to use geometry queue. Requires restart to take effect.")]
	public bool UseTransparentRenderQueue = true;

	[Header("Shaders")]
	public Shader Monochrome_SurfaceShader;

	public Shader Monochrome_SurfaceShader_SelfOccluding;

	public Shader Monochrome_SurfaceShader_PBS;

	public Shader Skinshaded_SurfaceShader_SingleComponent;

	public Shader Skinshaded_VertFrag_SingleComponent;

	public Shader Skinshaded_VertFrag_CombinedMesh;

	public Shader Skinshaded_Expressive_SurfaceShader_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_CombinedMesh;

	public Shader Loader_VertFrag_CombinedMesh;

	public Shader EyeLens;

	public Shader ControllerShader;

	[Header("Other")]
	public bool CanOwnMicrophone = true;

	[Tooltip("Enable laughter detection and animation as part of OVRLipSync.")]
	public bool EnableLaughter = true;

	public GameObject MouthAnchor;

	public Transform LeftHandCustomPose;

	public Transform RightHandCustomPose;

	private HashSet<ulong> assetLoadingIds = new HashSet<ulong>();

	private bool assetsFinishedLoading;

	private OvrAvatarMaterialManager materialManager;

	private bool waitingForCombinedMesh;

	private static bool doneExpressiveGlobalInit;

	private Vector4 clothingAlphaOffset = new Vector4(0f, 0f, 0f, 1f);

	private ulong clothingAlphaTexture;

	private OVRLipSyncMicInput micInput;

	private OVRLipSyncContext lipsyncContext;

	private OVRLipSync.Frame currentFrame = new OVRLipSync.Frame();

	private float[] visemes = new float[16];

	private AudioSource audioSource;

	private ONSPAudioSource spatializedSource;

	private List<float[]> voiceUpdates = new List<float[]>();

	private static ovrAvatarVisemes RuntimeVisemes;

	private Transform cachedLeftHandCustomPose;

	private Transform[] cachedCustomLeftHandJoints;

	private ovrAvatarTransform[] cachedLeftHandTransforms;

	private Transform cachedRightHandCustomPose;

	private Transform[] cachedCustomRightHandJoints;

	private ovrAvatarTransform[] cachedRightHandTransforms;

	private bool showLeftController;

	private bool showRightController;

	private const bool USE_MOBILE_TEXTURE_FORMAT = true;

	private static readonly Vector3 MOUTH_HEAD_OFFSET;

	private const string MOUTH_HELPER_NAME = "MouthAnchor";

	private const int VISEME_COUNT = 16;

	private const float ACTION_UNIT_ONSET_SPEED = 30f;

	private const float ACTION_UNIT_FALLOFF_SPEED = 20f;

	private const float VISEME_LEVEL_MULTIPLIER = 1.5f;

	internal ulong oculusUserIDInternal;

	internal OvrAvatarBase Base;

	internal OvrAvatarTouchController ControllerLeft;

	internal OvrAvatarTouchController ControllerRight;

	internal OvrAvatarBody Body;

	internal OvrAvatarHand HandLeft;

	internal OvrAvatarHand HandRight;

	internal ovrAvatarLookAndFeelVersion LookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	internal ovrAvatarLookAndFeelVersion FallbackLookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	private OvrAvatarPacket CurrentUnityPacket;

	public EventHandler<PacketEventArgs> PacketRecorded;

	private static string[,] HandJoints;

	private static Vector3 MOUTH_POSITION_OFFSET;

	private static string VOICE_PROPERTY;

	private static string MOUTH_POSITION_PROPERTY;

	private static string MOUTH_DIRECTION_PROPERTY;

	private static string MOUTH_SCALE_PROPERTY;

	private static float MOUTH_SCALE_GLOBAL;

	private static float MOUTH_MAX_GLOBAL;

	private static string NECK_JONT;

	public float VoiceAmplitude;

	public bool EnableMouthVertexAnimation;

	private static ovrAvatarLights ovrLights;

	static OvrAvatar()
	{
		doneExpressiveGlobalInit = false;
		MOUTH_HEAD_OFFSET = new Vector3(0f, -0.085f, 0.09f);
		HandJoints = new string[2, 5]
		{
			{ "hands:r_hand_world", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1/hands:b_r_index2/hands:b_r_index3/hands:b_r_index_ignore", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2/hands:b_r_thumb3/hands:b_r_thumb_ignore" },
			{ "hands:l_hand_world", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1/hands:b_l_index2/hands:b_l_index3/hands:b_l_index_ignore", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2/hands:b_l_thumb3/hands:b_l_thumb_ignore" }
		};
		MOUTH_POSITION_OFFSET = new Vector3(0f, -0.018f, 0.1051f);
		VOICE_PROPERTY = "_Voice";
		MOUTH_POSITION_PROPERTY = "_MouthPosition";
		MOUTH_DIRECTION_PROPERTY = "_MouthDirection";
		MOUTH_SCALE_PROPERTY = "_MouthEffectScale";
		MOUTH_SCALE_GLOBAL = 0.007f;
		MOUTH_MAX_GLOBAL = 0.007f;
		NECK_JONT = "root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT";
		ovrLights = default(ovrAvatarLights);
		RuntimeVisemes.visemeParams = new float[32];
		RuntimeVisemes.visemeParamCount = 16u;
	}

	private void OnDestroy()
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_Destroy(sdkAvatar);
		}
	}

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		assetLoadingIds.Remove(asset.assetID);
	}

	public void CombinedMeshLoadedCallback(IntPtr assetPtr)
	{
		if (waitingForCombinedMesh)
		{
			ulong[] array = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshIDs(assetPtr);
			foreach (ulong item in array)
			{
				assetLoadingIds.Remove(item);
			}
			Oculus.Avatar.CAPI.ovrAvatar_GetCombinedMeshAlphaData(sdkAvatar, ref clothingAlphaTexture, ref clothingAlphaOffset);
			waitingForCombinedMesh = false;
		}
	}

	private OvrAvatarSkinnedMeshRenderComponent AddSkinnedMeshRenderComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender)
	{
		OvrAvatarSkinnedMeshRenderComponent ovrAvatarSkinnedMeshRenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderComponent>();
		ovrAvatarSkinnedMeshRenderComponent.Initialize(skinnedMeshRender, Monochrome_SurfaceShader, Monochrome_SurfaceShader_SelfOccluding, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderComponent;
	}

	private OvrAvatarSkinnedMeshRenderPBSComponent AddSkinnedMeshRenderPBSComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS)
	{
		OvrAvatarSkinnedMeshRenderPBSComponent ovrAvatarSkinnedMeshRenderPBSComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderPBSComponent>();
		ovrAvatarSkinnedMeshRenderPBSComponent.Initialize(skinnedMeshRenderPBS, Monochrome_SurfaceShader_PBS, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderPBSComponent;
	}

	private OvrAvatarSkinnedMeshPBSV2RenderComponent AddSkinnedMeshRenderPBSV2Component(IntPtr renderPart, GameObject go, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRenderPBSV2, bool isBodyPartZero, bool isControllerModel)
	{
		OvrAvatarSkinnedMeshPBSV2RenderComponent ovrAvatarSkinnedMeshPBSV2RenderComponent = go.AddComponent<OvrAvatarSkinnedMeshPBSV2RenderComponent>();
		ovrAvatarSkinnedMeshPBSV2RenderComponent.Initialize(renderPart, skinnedMeshRenderPBSV2, materialManager, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, isBodyPartZero && CombineMeshes, LevelOfDetail, isBodyPartZero && EnableExpressive, this, isControllerModel);
		return ovrAvatarSkinnedMeshPBSV2RenderComponent;
	}

	public static IntPtr GetRenderPart(ovrAvatarComponent component, uint renderPartIndex)
	{
		return Marshal.ReadIntPtr(component.renderParts, Marshal.SizeOf(typeof(IntPtr)) * (int)renderPartIndex);
	}

	private static string GetRenderPartName(ovrAvatarComponent component, uint renderPartIndex)
	{
		return component.name + "_renderPart_" + (int)renderPartIndex;
	}

	internal static void ConvertTransform(float[] transform, ref ovrAvatarTransform target)
	{
		target.position.x = transform[0];
		target.position.y = transform[1];
		target.position.z = transform[2];
		target.orientation.x = transform[3];
		target.orientation.y = transform[4];
		target.orientation.z = transform[5];
		target.orientation.w = transform[6];
		target.scale.x = transform[7];
		target.scale.y = transform[8];
		target.scale.z = transform[9];
	}

	internal static void ConvertTransform(ovrAvatarTransform transform, Transform target)
	{
		Vector3 position = transform.position;
		position.z = 0f - position.z;
		Quaternion orientation = transform.orientation;
		orientation.x = 0f - orientation.x;
		orientation.y = 0f - orientation.y;
		target.localPosition = position;
		target.localRotation = orientation;
		target.localScale = transform.scale;
	}

	public static ovrAvatarTransform CreateOvrAvatarTransform(Vector3 position, Quaternion orientation)
	{
		ovrAvatarTransform result = default(ovrAvatarTransform);
		result.position = new Vector3(position.x, position.y, 0f - position.z);
		result.orientation = new Quaternion(0f - orientation.x, 0f - orientation.y, orientation.z, orientation.w);
		result.scale = Vector3.one;
		return result;
	}

	private static ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}

	private void BuildRenderComponents()
	{
		ovrAvatarBaseComponent component = default(ovrAvatarBaseComponent);
		ovrAvatarHandComponent component2 = default(ovrAvatarHandComponent);
		ovrAvatarHandComponent component3 = default(ovrAvatarHandComponent);
		ovrAvatarControllerComponent component4 = default(ovrAvatarControllerComponent);
		ovrAvatarControllerComponent component5 = default(ovrAvatarControllerComponent);
		ovrAvatarBodyComponent component6 = default(ovrAvatarBodyComponent);
		ovrAvatarComponent component7 = default(ovrAvatarComponent);
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(sdkAvatar, ref component2))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component2.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandLeft, component7);
			HandLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(sdkAvatar, ref component3))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component3.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandRight, component7);
			HandRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref component6))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component6.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Body, component7);
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(sdkAvatar, ref component4))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component4.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerLeft, component7);
			ControllerLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(sdkAvatar, ref component5))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component5.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerRight, component7);
			ControllerRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Base, component7);
		}
	}

	private void AddAvatarComponent<T>(ref T root, ovrAvatarComponent nativeComponent) where T : OvrAvatarComponent
	{
		GameObject gameObject = new GameObject();
		gameObject.name = nativeComponent.name;
		gameObject.transform.SetParent(base.transform);
		root = gameObject.AddComponent<T>();
		root.SetOvrAvatarOwner(this);
		AddRenderParts(root, nativeComponent, gameObject.transform);
	}

	private void UpdateCustomPoses()
	{
		if (UpdatePoseRoot(LeftHandCustomPose, ref cachedLeftHandCustomPose, ref cachedCustomLeftHandJoints, ref cachedLeftHandTransforms) && cachedLeftHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (UpdatePoseRoot(RightHandCustomPose, ref cachedRightHandCustomPose, ref cachedCustomRightHandJoints, ref cachedRightHandTransforms) && cachedRightHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (sdkAvatar != IntPtr.Zero)
		{
			if (cachedLeftHandCustomPose != null && UpdateTransforms(cachedCustomLeftHandJoints, cachedLeftHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandCustomGesture(sdkAvatar, (uint)cachedLeftHandTransforms.Length, cachedLeftHandTransforms);
			}
			if (cachedRightHandCustomPose != null && UpdateTransforms(cachedCustomRightHandJoints, cachedRightHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetRightHandCustomGesture(sdkAvatar, (uint)cachedRightHandTransforms.Length, cachedRightHandTransforms);
			}
		}
	}

	private static bool UpdatePoseRoot(Transform poseRoot, ref Transform cachedPoseRoot, ref Transform[] cachedPoseJoints, ref ovrAvatarTransform[] transforms)
	{
		if (poseRoot == cachedPoseRoot)
		{
			return false;
		}
		if (!poseRoot)
		{
			cachedPoseRoot = null;
			cachedPoseJoints = null;
			transforms = null;
		}
		else
		{
			List<Transform> list = new List<Transform>();
			OrderJoints(poseRoot, list);
			cachedPoseRoot = poseRoot;
			cachedPoseJoints = list.ToArray();
			transforms = new ovrAvatarTransform[list.Count];
		}
		return true;
	}

	private static bool UpdateTransforms(Transform[] joints, ovrAvatarTransform[] transforms)
	{
		bool result = false;
		for (int i = 0; i < joints.Length; i++)
		{
			Transform transform = joints[i];
			ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(transform.localPosition, transform.localRotation);
			if (ovrAvatarTransform2.position != transforms[i].position || ovrAvatarTransform2.orientation != transforms[i].orientation)
			{
				transforms[i] = ovrAvatarTransform2;
				result = true;
			}
		}
		return result;
	}

	private static void OrderJoints(Transform transform, List<Transform> joints)
	{
		joints.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			OrderJoints(transform.GetChild(i), joints);
		}
	}

	private void AvatarSpecificationCallback(IntPtr avatarSpecification)
	{
		sdkAvatar = Oculus.Avatar.CAPI.ovrAvatar_Create(avatarSpecification, Capabilities);
		ShowLeftController(showLeftController);
		ShowRightController(showRightController);
		if (Driver != null)
		{
			Driver.UpdateTransformsFromPose(sdkAvatar);
		}
		uint num = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAssetCount(sdkAvatar);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			ulong num3 = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAsset(sdkAvatar, num2);
			if (OvrAvatarSDKManager.Instance.GetAsset(num3) == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(num3, LevelOfDetail, AssetLoadedCallback);
				assetLoadingIds.Add(num3);
			}
		}
		if (CombineMeshes)
		{
			OvrAvatarSDKManager.Instance.RegisterCombinedMeshCallback(sdkAvatar, CombinedMeshLoadedCallback);
		}
	}

	private void Start()
	{
		if (!(OvrAvatarSDKManager.Instance == null))
		{
			materialManager = base.gameObject.AddComponent<OvrAvatarMaterialManager>();
			try
			{
				oculusUserIDInternal = ulong.Parse(oculusUserID);
			}
			catch (Exception)
			{
				oculusUserIDInternal = 0uL;
			}
			if (oculusUserIDInternal == 0L)
			{
				CombineMeshes = false;
			}
			Capabilities = (ovrAvatarCapabilities)0;
			if (EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Body;
			}
			if (EnableHands)
			{
				Capabilities |= ovrAvatarCapabilities.Hands;
			}
			if (EnableBase && EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Base;
			}
			if (EnableExpressive)
			{
				Capabilities |= ovrAvatarCapabilities.Expressive;
			}
			if (OVRPlugin.positionSupported)
			{
				Capabilities |= ovrAvatarCapabilities.BodyTilt;
			}
			ShowLeftController(StartWithControllers);
			ShowRightController(StartWithControllers);
			OvrAvatarSDKManager.AvatarSpecRequestParams avatarSpecRequest = new OvrAvatarSDKManager.AvatarSpecRequestParams(oculusUserIDInternal, AvatarSpecificationCallback, CombineMeshes, LevelOfDetail, forceMobileTextureFormat: true, LookAndFeelVersion, FallbackLookAndFeelVersion, EnableExpressive);
			OvrAvatarSDKManager.Instance.RequestAvatarSpecification(avatarSpecRequest);
			OvrAvatarSDKManager.Instance.AddLoadingAvatar(GetInstanceID());
			waitingForCombinedMesh = CombineMeshes;
			if (Driver != null)
			{
				Driver.Mode = ((!UseSDKPackets) ? OvrAvatarDriver.PacketMode.Unity : OvrAvatarDriver.PacketMode.SDK);
			}
		}
	}

	private void Update()
	{
		if (!OvrAvatarSDKManager.Instance || sdkAvatar == IntPtr.Zero || materialManager == null)
		{
			return;
		}
		if (Driver != null)
		{
			Driver.UpdateTransforms(sdkAvatar);
			foreach (float[] voiceUpdate in voiceUpdates)
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateVoiceVisualization(sdkAvatar, voiceUpdate);
			}
			voiceUpdates.Clear();
			Oculus.Avatar.CAPI.ovrAvatarPose_Finalize(sdkAvatar, Time.deltaTime);
		}
		if (RecordPackets)
		{
			RecordFrame();
		}
		if (assetLoadingIds.Count != 0)
		{
			return;
		}
		if (!assetsFinishedLoading)
		{
			try
			{
				BuildRenderComponents();
			}
			catch (Exception ex)
			{
				assetsFinishedLoading = true;
				throw ex;
			}
			InitPostLoad();
			assetsFinishedLoading = true;
			OvrAvatarSDKManager.Instance.RemoveLoadingAvatar(GetInstanceID());
		}
		UpdateVoiceBehavior();
		UpdateCustomPoses();
		if (EnableExpressive)
		{
			UpdateExpressive();
		}
	}

	public static ovrAvatarHandInputState CreateInputState(ovrAvatarTransform transform, OvrAvatarDriver.ControllerPose pose)
	{
		ovrAvatarHandInputState result = default(ovrAvatarHandInputState);
		result.transform = transform;
		result.buttonMask = pose.buttons;
		result.touchMask = pose.touches;
		result.joystickX = pose.joystickPosition.x;
		result.joystickY = pose.joystickPosition.y;
		result.indexTrigger = pose.indexTrigger;
		result.handTrigger = pose.handTrigger;
		result.isActive = pose.isActive;
		return result;
	}

	public void ShowControllers(bool show)
	{
		ShowLeftController(show);
		ShowRightController(show);
	}

	public void ShowLeftController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftControllerVisibility(sdkAvatar, show);
		}
		showLeftController = show;
	}

	public void ShowRightController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightControllerVisibility(sdkAvatar, show);
		}
		showRightController = show;
	}

	public void UpdateVoiceVisualization(float[] voiceSamples)
	{
		voiceUpdates.Add(voiceSamples);
	}

	private void RecordFrame()
	{
		if (UseSDKPackets)
		{
			RecordSDKFrame();
		}
		else
		{
			RecordUnityFrame();
		}
	}

	private void RecordUnityFrame()
	{
		float num = Time.deltaTime;
		OvrAvatarDriver.PoseFrame currentPose = Driver.GetCurrentPose();
		if (CurrentUnityPacket == null)
		{
			CurrentUnityPacket = new OvrAvatarPacket(currentPose);
			num = 0f;
		}
		float num2 = 0f;
		while (num2 < num)
		{
			float num3 = num - num2;
			float num4 = PacketSettings.UpdateRate - CurrentUnityPacket.Duration;
			if (num3 < num4)
			{
				CurrentUnityPacket.AddFrame(currentPose, num3);
				num2 += num3;
				continue;
			}
			OvrAvatarDriver.PoseFrame finalFrame = CurrentUnityPacket.FinalFrame;
			OvrAvatarDriver.PoseFrame b = currentPose;
			float t = num4 / num3;
			OvrAvatarDriver.PoseFrame poseFrame = OvrAvatarDriver.PoseFrame.Interpolate(finalFrame, b, t);
			CurrentUnityPacket.AddFrame(poseFrame, num4);
			num2 += num4;
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(CurrentUnityPacket));
			}
			CurrentUnityPacket = new OvrAvatarPacket(poseFrame);
		}
	}

	private void RecordSDKFrame()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (!PacketSettings.RecordingFrames)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			PacketSettings.AccumulatedTime = 0f;
			PacketSettings.RecordingFrames = true;
		}
		PacketSettings.AccumulatedTime += Time.deltaTime;
		if (PacketSettings.AccumulatedTime >= PacketSettings.UpdateRate)
		{
			PacketSettings.AccumulatedTime = 0f;
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarPacket_EndRecording(sdkAvatar);
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(new OvrAvatarPacket
				{
					ovrNativePacket = intPtr
				}));
			}
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(intPtr);
		}
	}

	private void AddRenderParts(OvrAvatarComponent ovrComponent, ovrAvatarComponent component, Transform parent)
	{
		bool flag = ovrComponent.name == "body";
		bool flag2 = ovrComponent.name == "controller_left";
		bool flag3 = ovrComponent.name == "controller_right";
		for (uint num = 0u; num < component.renderPartCount; num++)
		{
			GameObject gameObject = new GameObject();
			gameObject.name = GetRenderPartName(component, num);
			gameObject.transform.SetParent(parent);
			IntPtr renderPart = GetRenderPart(component, num);
			ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
			OvrAvatarRenderComponent ovrAvatarRenderComponent = null;
			switch (ovrAvatarRenderPartType2)
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSV2Component(renderPart, gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(renderPart), flag && num == 0, flag2 || flag3);
				break;
			}
			if (ovrAvatarRenderComponent != null)
			{
				ovrComponent.RenderParts.Add(ovrAvatarRenderComponent);
			}
		}
	}

	public void RefreshBodyParts()
	{
		if (!(Body != null))
		{
			return;
		}
		foreach (OvrAvatarRenderComponent renderPart in Body.RenderParts)
		{
			UnityEngine.Object.Destroy(renderPart.gameObject);
		}
		Body.RenderParts.Clear();
		ovrAvatarComponent? nativeAvatarComponent = Body.GetNativeAvatarComponent();
		if (nativeAvatarComponent.HasValue)
		{
			AddRenderParts(Body, nativeAvatarComponent.Value, Body.gameObject.transform);
		}
	}

	public ovrAvatarBodyComponent? GetBodyComponent()
	{
		if (Body != null)
		{
			Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref Body.component);
			return Body.component;
		}
		return null;
	}

	public Transform GetHandTransform(HandType hand, HandJoint joint)
	{
		if (hand >= HandType.Max || joint >= HandJoint.Max)
		{
			return null;
		}
		OvrAvatarHand ovrAvatarHand = ((hand == HandType.Left) ? HandLeft : HandRight);
		if (ovrAvatarHand != null)
		{
			OvrAvatarComponent component = ovrAvatarHand.GetComponent<OvrAvatarComponent>();
			if (component != null && component.RenderParts.Count > 0)
			{
				return component.RenderParts[0].transform.Find(HandJoints[(int)hand, (int)joint]);
			}
		}
		return null;
	}

	public void GetPointingDirection(HandType hand, ref Vector3 forward, ref Vector3 up)
	{
		Transform handTransform = GetHandTransform(hand, HandJoint.HandBase);
		if (handTransform != null)
		{
			forward = handTransform.forward;
			up = handTransform.up;
		}
	}

	private void UpdateVoiceBehavior()
	{
		if (EnableMouthVertexAnimation && Body != null)
		{
			OvrAvatarComponent component = Body.GetComponent<OvrAvatarComponent>();
			VoiceAmplitude = Mathf.Clamp(VoiceAmplitude, 0f, 1f);
			if (component.RenderParts.Count > 0)
			{
				Material sharedMaterial = component.RenderParts[0].mesh.sharedMaterial;
				Transform transform = component.RenderParts[0].mesh.transform.Find(NECK_JONT);
				Vector3 vector = transform.TransformPoint(Vector3.up) - transform.position;
				sharedMaterial.SetFloat(MOUTH_SCALE_PROPERTY, vector.magnitude);
				sharedMaterial.SetFloat(VOICE_PROPERTY, Mathf.Min(vector.magnitude * MOUTH_MAX_GLOBAL, vector.magnitude * VoiceAmplitude * MOUTH_SCALE_GLOBAL));
				sharedMaterial.SetVector(MOUTH_POSITION_PROPERTY, transform.TransformPoint(MOUTH_POSITION_OFFSET));
				sharedMaterial.SetVector(MOUTH_DIRECTION_PROPERTY, transform.up);
			}
		}
	}

	private bool IsValidMic()
	{
		string[] devices = Microphone.devices;
		if (devices.Length < 1)
		{
			return false;
		}
		int num = 0;
		string deviceName = devices[num];
		Microphone.GetDeviceCaps(deviceName, out var _, out var maxFreq);
		if (maxFreq == 0)
		{
			maxFreq = 44100;
		}
		if (Microphone.Start(deviceName, loop: true, 1, maxFreq) == null)
		{
			return false;
		}
		Microphone.End(deviceName);
		return true;
	}

	private void InitPostLoad()
	{
		ExpressiveGlobalInit();
		ConfigureHelpers();
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			lipsyncContext.audioLoopback = false;
			if (CanOwnMicrophone && IsValidMic())
			{
				micInput = MouthAnchor.gameObject.AddComponent<OVRLipSyncMicInput>();
				micInput.enableMicSelectionGUI = false;
				micInput.MicFrequency = 44100f;
				micInput.micControl = OVRLipSyncMicInput.micActivation.ConstantSpeak;
			}
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitOnsetSpeed(sdkAvatar, 30f);
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitFalloffSpeed(sdkAvatar, 20f);
			Oculus.Avatar.CAPI.ovrAvatar_SetVisemeMultiplier(sdkAvatar, 1.5f);
		}
	}

	private static void ExpressiveGlobalInit()
	{
		if (!doneExpressiveGlobalInit)
		{
			doneExpressiveGlobalInit = true;
			ovrLights.lights = new ovrAvatarLight[16];
			InitializeLights();
		}
	}

	private static void InitializeLights()
	{
		ovrLights.ambientIntensity = RenderSettings.ambientLight.grayscale * 0.5f;
		Light[] array = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		int num = 0;
		for (num = 0; num < array.Length && num < ovrLights.lights.Length; num++)
		{
			Light light = array[num];
			if ((bool)light && light.enabled)
			{
				uint instanceID = (uint)light.transform.GetInstanceID();
				switch (light.type)
				{
				case LightType.Directional:
					CreateLightDirectional(instanceID, light.transform.forward, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Point:
					CreateLightPoint(instanceID, light.transform.position, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Spot:
					CreateLightSpot(instanceID, light.transform.position, light.transform.forward, light.spotAngle, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				}
			}
		}
		ovrLights.lightCount = (uint)num;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateLights(ovrLights);
	}

	private static ovrAvatarLight CreateLightDirectional(uint id, Vector3 direction, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Direction;
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightPoint(uint id, Vector3 position, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Point;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightSpot(uint id, Vector3 position, Vector3 direction, float spotAngleDeg, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Spot;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.spotAngleDeg = spotAngleDeg;
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private void UpdateExpressive()
	{
		ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(base.transform.position, base.transform.rotation);
		Oculus.Avatar.CAPI.ovrAvatar_UpdateWorldTransform(sdkAvatar, ovrAvatarTransform2);
		UpdateFacewave();
	}

	private void ConfigureHelpers()
	{
		Transform transform = base.transform.Find("body/body_renderPart_0/root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT/head_JNT");
		if (transform == null)
		{
			transform = base.transform;
		}
		if (MouthAnchor == null)
		{
			MouthAnchor = CreateHelperObject(transform, MOUTH_HEAD_OFFSET, "MouthAnchor");
		}
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			if (audioSource == null)
			{
				audioSource = MouthAnchor.gameObject.AddComponent<AudioSource>();
			}
			spatializedSource = MouthAnchor.GetComponent<ONSPAudioSource>();
			if (spatializedSource == null)
			{
				spatializedSource = MouthAnchor.gameObject.AddComponent<ONSPAudioSource>();
			}
			spatializedSource.UseInvSqr = true;
			spatializedSource.EnableRfl = false;
			spatializedSource.EnableSpatialization = true;
			spatializedSource.Far = 100f;
			spatializedSource.Near = 0.1f;
			lipsyncContext = MouthAnchor.GetComponent<OVRLipSyncContext>();
			if (lipsyncContext == null)
			{
				lipsyncContext = MouthAnchor.gameObject.AddComponent<OVRLipSyncContext>();
			}
			lipsyncContext.provider = ((!EnableLaughter) ? OVRLipSync.ContextProviders.Enhanced : OVRLipSync.ContextProviders.Enhanced_with_Laughter);
			lipsyncContext.skipAudioSource = !CanOwnMicrophone;
			StartCoroutine(WaitForMouthAudioSource());
		}
		if (GetComponent<OvrAvatarRemoteDriver>() != null)
		{
			transform.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHead;
			Transform transform2 = base.transform.Find("hand_left");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
			transform2 = base.transform.Find("hand_right");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
		}
	}

	private IEnumerator WaitForMouthAudioSource()
	{
		while (MouthAnchor.GetComponent<AudioSource>() == null)
		{
			yield return new WaitForSeconds(0.1f);
		}
		AudioSource component = MouthAnchor.GetComponent<AudioSource>();
		component.minDistance = 0.3f;
		component.maxDistance = 4f;
		component.rolloffMode = AudioRolloffMode.Logarithmic;
		component.loop = true;
		component.playOnAwake = true;
		component.spatialBlend = 1f;
		component.spatialize = true;
		component.spatializePostEffects = true;
	}

	public void DestroyHelperObjects()
	{
		if ((bool)MouthAnchor)
		{
			UnityEngine.Object.DestroyImmediate(MouthAnchor.gameObject);
		}
	}

	public GameObject CreateHelperObject(Transform parent, Vector3 localPositionOffset, string helperName, string helperTag = "")
	{
		GameObject gameObject = new GameObject();
		gameObject.name = helperName;
		if (helperTag != "")
		{
			gameObject.tag = helperTag;
		}
		gameObject.transform.SetParent(parent);
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localPosition = localPositionOffset;
		return gameObject;
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	public void UpdateVoiceData(float[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	private void UpdateFacewave()
	{
		if (!(lipsyncContext != null) || (!(micInput != null) && CanOwnMicrophone))
		{
			return;
		}
		currentFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentFrame.Visemes.Length != 15)
		{
			UnityEngine.Debug.LogError("Unexpected number of visemes " + currentFrame.Visemes);
			return;
		}
		currentFrame.Visemes.CopyTo(visemes, 0);
		visemes[15] = (EnableLaughter ? currentFrame.laughterScore : 0f);
		for (int i = 0; i < 16; i++)
		{
			RuntimeVisemes.visemeParams[i] = visemes[i];
		}
		Oculus.Avatar.CAPI.ovrAvatar_SetVisemes(sdkAvatar, RuntimeVisemes);
	}
}
public class OvrAvatarAsset
{
	public ulong assetID;
}
public class OvrAvatarAssetMesh : OvrAvatarAsset
{
	public Mesh mesh;

	private ovrAvatarSkinnedMeshPose skinnedBindPose;

	public string[] jointNames;

	public OvrAvatarAssetMesh(ulong _assetId, IntPtr asset, ovrAvatarAssetType meshType)
	{
		assetID = _assetId;
		mesh = new Mesh();
		mesh.name = "Procedural Geometry for asset " + _assetId;
		SetSkinnedBindPose(asset, meshType);
		long vertexCount = 0L;
		IntPtr vertexBuffer = IntPtr.Zero;
		uint indexCount = 0u;
		IntPtr indexBuffer = IntPtr.Zero;
		GetVertexAndIndexData(asset, meshType, out vertexCount, out vertexBuffer, out indexCount, out indexBuffer);
		Vector3[] array = new Vector3[vertexCount];
		Vector3[] array2 = new Vector3[vertexCount];
		Vector4[] array3 = new Vector4[vertexCount];
		Vector2[] array4 = new Vector2[vertexCount];
		Color[] array5 = new Color[vertexCount];
		BoneWeight[] array6 = new BoneWeight[vertexCount];
		long num = vertexBuffer.ToInt64();
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
		{
			long num5 = Marshal.SizeOf(typeof(ovrAvatarMeshVertex));
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				long num7 = num5 * num6;
				ovrAvatarMeshVertex ovrAvatarMeshVertex2 = (ovrAvatarMeshVertex)Marshal.PtrToStructure(new IntPtr(num + num7), typeof(ovrAvatarMeshVertex));
				array[num6] = new Vector3(ovrAvatarMeshVertex2.x, ovrAvatarMeshVertex2.y, 0f - ovrAvatarMeshVertex2.z);
				array2[num6] = new Vector3(ovrAvatarMeshVertex2.nx, ovrAvatarMeshVertex2.ny, 0f - ovrAvatarMeshVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarMeshVertex2.tx, ovrAvatarMeshVertex2.ty, 0f - ovrAvatarMeshVertex2.tz, ovrAvatarMeshVertex2.tw);
				array4[num6] = new Vector2(ovrAvatarMeshVertex2.u, ovrAvatarMeshVertex2.v);
				array5[num6] = new Color(0f, 0f, 0f, 1f);
				array6[num6].boneIndex0 = ovrAvatarMeshVertex2.blendIndices[0];
				array6[num6].boneIndex1 = ovrAvatarMeshVertex2.blendIndices[1];
				array6[num6].boneIndex2 = ovrAvatarMeshVertex2.blendIndices[2];
				array6[num6].boneIndex3 = ovrAvatarMeshVertex2.blendIndices[3];
				array6[num6].weight0 = ovrAvatarMeshVertex2.blendWeights[0];
				array6[num6].weight1 = ovrAvatarMeshVertex2.blendWeights[1];
				array6[num6].weight2 = ovrAvatarMeshVertex2.blendWeights[2];
				array6[num6].weight3 = ovrAvatarMeshVertex2.blendWeights[3];
			}
			break;
		}
		case ovrAvatarAssetType.CombinedMesh:
		{
			long num2 = Marshal.SizeOf(typeof(ovrAvatarMeshVertexV2));
			for (long num3 = 0L; num3 < vertexCount; num3++)
			{
				long num4 = num2 * num3;
				ovrAvatarMeshVertexV2 ovrAvatarMeshVertexV3 = (ovrAvatarMeshVertexV2)Marshal.PtrToStructure(new IntPtr(num + num4), typeof(ovrAvatarMeshVertexV2));
				array[num3] = new Vector3(ovrAvatarMeshVertexV3.x, ovrAvatarMeshVertexV3.y, 0f - ovrAvatarMeshVertexV3.z);
				array2[num3] = new Vector3(ovrAvatarMeshVertexV3.nx, ovrAvatarMeshVertexV3.ny, 0f - ovrAvatarMeshVertexV3.nz);
				array3[num3] = new Vector4(ovrAvatarMeshVertexV3.tx, ovrAvatarMeshVertexV3.ty, 0f - ovrAvatarMeshVertexV3.tz, ovrAvatarMeshVertexV3.tw);
				array4[num3] = new Vector2(ovrAvatarMeshVertexV3.u, ovrAvatarMeshVertexV3.v);
				array5[num3] = new Color(ovrAvatarMeshVertexV3.r, ovrAvatarMeshVertexV3.g, ovrAvatarMeshVertexV3.b, ovrAvatarMeshVertexV3.a);
				array6[num3].boneIndex0 = ovrAvatarMeshVertexV3.blendIndices[0];
				array6[num3].boneIndex1 = ovrAvatarMeshVertexV3.blendIndices[1];
				array6[num3].boneIndex2 = ovrAvatarMeshVertexV3.blendIndices[2];
				array6[num3].boneIndex3 = ovrAvatarMeshVertexV3.blendIndices[3];
				array6[num3].weight0 = ovrAvatarMeshVertexV3.blendWeights[0];
				array6[num3].weight1 = ovrAvatarMeshVertexV3.blendWeights[1];
				array6[num3].weight2 = ovrAvatarMeshVertexV3.blendWeights[2];
				array6[num3].weight3 = ovrAvatarMeshVertexV3.blendWeights[3];
			}
			break;
		}
		default:
			throw new Exception("Bad Mesh Asset Type");
		}
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.uv = array4;
		mesh.tangents = array3;
		mesh.boneWeights = array6;
		mesh.colors = array5;
		LoadBlendShapes(asset, vertexCount);
		LoadSubmeshes(asset, indexBuffer, indexCount);
		uint jointCount = skinnedBindPose.jointCount;
		jointNames = new string[jointCount];
		for (uint num8 = 0u; num8 < jointCount; num8++)
		{
			jointNames[num8] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num8]);
		}
	}

	private void LoadSubmeshes(IntPtr asset, IntPtr indexBufferPtr, ulong indexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshCount(asset);
		short[] array = new short[indexCount];
		Marshal.Copy(indexBufferPtr, array, 0, (int)indexCount);
		mesh.subMeshCount = (int)num;
		uint num2 = 0u;
		for (uint num3 = 0u; num3 < num; num3++)
		{
			uint num4 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshLastIndex(asset, num3);
			uint num5 = num4 - num2;
			int[] array2 = new int[num5];
			int num6 = 0;
			for (ulong num7 = num2; num7 < num4; num7 += 3)
			{
				array2[num6 + 2] = array[num7];
				array2[num6 + 1] = array[num7 + 1];
				array2[num6] = array[num7 + 2];
				num6 += 3;
			}
			num2 += num5;
			mesh.SetIndices(array2, MeshTopology.Triangles, (int)num3);
		}
	}

	private void LoadBlendShapes(IntPtr asset, long vertexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeCount(asset);
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeVertices(asset);
		if (!(intPtr != IntPtr.Zero))
		{
			return;
		}
		long num2 = 0L;
		long num3 = Marshal.SizeOf(typeof(ovrAvatarBlendVertex));
		long num4 = intPtr.ToInt64();
		for (uint num5 = 0u; num5 < num; num5++)
		{
			Vector3[] array = new Vector3[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				ovrAvatarBlendVertex ovrAvatarBlendVertex2 = (ovrAvatarBlendVertex)Marshal.PtrToStructure(new IntPtr(num4 + num2), typeof(ovrAvatarBlendVertex));
				array[num6] = new Vector3(ovrAvatarBlendVertex2.x, ovrAvatarBlendVertex2.y, 0f - ovrAvatarBlendVertex2.z);
				array2[num6] = new Vector3(ovrAvatarBlendVertex2.nx, ovrAvatarBlendVertex2.ny, 0f - ovrAvatarBlendVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarBlendVertex2.tx, ovrAvatarBlendVertex2.ty, 0f - ovrAvatarBlendVertex2.tz);
				num2 += num3;
			}
			string shapeName = Marshal.PtrToStringAnsi(Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeName(asset, num5));
			mesh.AddBlendShapeFrame(shapeName, 100f, array, array2, array3);
		}
	}

	private void SetSkinnedBindPose(IntPtr asset, ovrAvatarAssetType meshType)
	{
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).skinnedBindPose;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).skinnedBindPose;
			break;
		}
	}

	private void GetVertexAndIndexData(IntPtr asset, ovrAvatarAssetType meshType, out long vertexCount, out IntPtr vertexBuffer, out uint indexCount, out IntPtr indexBuffer)
	{
		vertexCount = 0L;
		vertexBuffer = IntPtr.Zero;
		indexCount = 0u;
		indexBuffer = IntPtr.Zero;
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexBuffer;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexBuffer;
			break;
		}
	}

	public SkinnedMeshRenderer CreateSkinnedMeshRendererOnObject(GameObject target)
	{
		SkinnedMeshRenderer skinnedMeshRenderer = target.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = mesh;
		mesh.name = "AvatarMesh_" + assetID;
		uint jointCount = skinnedBindPose.jointCount;
		GameObject[] array = new GameObject[jointCount];
		Transform[] array2 = new Transform[jointCount];
		Matrix4x4[] array3 = new Matrix4x4[jointCount];
		for (uint num = 0u; num < jointCount; num++)
		{
			array[num] = new GameObject();
			array2[num] = array[num].transform;
			array[num].name = jointNames[num];
			int num2 = skinnedBindPose.jointParents[num];
			if (num2 == -1)
			{
				array[num].transform.parent = skinnedMeshRenderer.transform;
				skinnedMeshRenderer.rootBone = array[num].transform;
			}
			else
			{
				array[num].transform.parent = array[num2].transform;
			}
			Vector3 position = skinnedBindPose.jointTransform[num].position;
			position.z = 0f - position.z;
			array[num].transform.localPosition = position;
			Quaternion orientation = skinnedBindPose.jointTransform[num].orientation;
			orientation.x = 0f - orientation.x;
			orientation.y = 0f - orientation.y;
			array[num].transform.localRotation = orientation;
			array[num].transform.localScale = skinnedBindPose.jointTransform[num].scale;
			array3[num] = array[num].transform.worldToLocalMatrix * skinnedMeshRenderer.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.bones = array2;
		mesh.bindposes = array3;
		return skinnedMeshRenderer;
	}
}
public class OvrAvatarAssetTexture : OvrAvatarAsset
{
	public Texture2D texture;

	private const int ASTCHeaderSize = 16;

	public OvrAvatarAssetTexture(ulong _assetId, IntPtr asset)
	{
		assetID = _assetId;
		ovrAvatarTextureAssetData ovrAvatarTextureAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetTextureData(asset);
		IntPtr data = ovrAvatarTextureAssetData2.textureData;
		int num = (int)ovrAvatarTextureAssetData2.textureDataSize;
		TextureFormat textureFormat;
		switch (ovrAvatarTextureAssetData2.format)
		{
		case ovrAvatarTextureFormat.RGB24:
			textureFormat = TextureFormat.RGB24;
			break;
		case ovrAvatarTextureFormat.DXT1:
			textureFormat = TextureFormat.DXT1;
			break;
		case ovrAvatarTextureFormat.DXT5:
			textureFormat = TextureFormat.DXT5;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6:
			textureFormat = TextureFormat.ASTC_6x6;
			data = new IntPtr(data.ToInt64() + 16);
			num -= 16;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6_MIPMAPS:
			textureFormat = TextureFormat.ASTC_6x6;
			break;
		default:
			throw new NotImplementedException($"Unsupported texture format {ovrAvatarTextureAssetData2.format.ToString()}");
		}
		texture = new Texture2D((int)ovrAvatarTextureAssetData2.sizeX, (int)ovrAvatarTextureAssetData2.sizeY, textureFormat, ovrAvatarTextureAssetData2.mipCount > 1, (QualitySettings.activeColorSpace != 0) ? true : false)
		{
			filterMode = FilterMode.Trilinear,
			anisoLevel = 4
		};
		texture.LoadRawTextureData(data, num);
		texture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
	}
}
public class OvrAvatarBase : OvrAvatarComponent
{
	private ovrAvatarBaseComponent component;

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Base = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarBody : OvrAvatarComponent
{
	public ovrAvatarBodyComponent component;

	public ovrAvatarComponent? GetNativeAvatarComponent()
	{
		if (owner == null)
		{
			return null;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref nativeAvatarComponent);
			return nativeAvatarComponent;
		}
		return null;
	}

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Body = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarComponent : MonoBehaviour
{
	public static readonly string[] LayerKeywords = new string[9] { "LAYERS_0", "LAYERS_1", "LAYERS_2", "LAYERS_3", "LAYERS_4", "LAYERS_5", "LAYERS_6", "LAYERS_7", "LAYERS_8" };

	public static readonly string[] LayerSampleModeParameters = new string[8] { "_LayerSampleMode0", "_LayerSampleMode1", "_LayerSampleMode2", "_LayerSampleMode3", "_LayerSampleMode4", "_LayerSampleMode5", "_LayerSampleMode6", "_LayerSampleMode7" };

	public static readonly string[] LayerBlendModeParameters = new string[8] { "_LayerBlendMode0", "_LayerBlendMode1", "_LayerBlendMode2", "_LayerBlendMode3", "_LayerBlendMode4", "_LayerBlendMode5", "_LayerBlendMode6", "_LayerBlendMode7" };

	public static readonly string[] LayerMaskTypeParameters = new string[8] { "_LayerMaskType0", "_LayerMaskType1", "_LayerMaskType2", "_LayerMaskType3", "_LayerMaskType4", "_LayerMaskType5", "_LayerMaskType6", "_LayerMaskType7" };

	public static readonly string[] LayerColorParameters = new string[8] { "_LayerColor0", "_LayerColor1", "_LayerColor2", "_LayerColor3", "_LayerColor4", "_LayerColor5", "_LayerColor6", "_LayerColor7" };

	public static readonly string[] LayerSurfaceParameters = new string[8] { "_LayerSurface0", "_LayerSurface1", "_LayerSurface2", "_LayerSurface3", "_LayerSurface4", "_LayerSurface5", "_LayerSurface6", "_LayerSurface7" };

	public static readonly string[] LayerSampleParametersParameters = new string[8] { "_LayerSampleParameters0", "_LayerSampleParameters1", "_LayerSampleParameters2", "_LayerSampleParameters3", "_LayerSampleParameters4", "_LayerSampleParameters5", "_LayerSampleParameters6", "_LayerSampleParameters7" };

	public static readonly string[] LayerMaskParametersParameters = new string[8] { "_LayerMaskParameters0", "_LayerMaskParameters1", "_LayerMaskParameters2", "_LayerMaskParameters3", "_LayerMaskParameters4", "_LayerMaskParameters5", "_LayerMaskParameters6", "_LayerMaskParameters7" };

	public static readonly string[] LayerMaskAxisParameters = new string[8] { "_LayerMaskAxis0", "_LayerMaskAxis1", "_LayerMaskAxis2", "_LayerMaskAxis3", "_LayerMaskAxis4", "_LayerMaskAxis5", "_LayerMaskAxis6", "_LayerMaskAxis7" };

	private Dictionary<Material, ovrAvatarMaterialState> materialStates = new Dictionary<Material, ovrAvatarMaterialState>();

	public List<OvrAvatarRenderComponent> RenderParts = new List<OvrAvatarRenderComponent>();

	protected OvrAvatar owner;

	protected ovrAvatarComponent nativeAvatarComponent;

	public void SetOvrAvatarOwner(OvrAvatar ovrAvatarOwner)
	{
		owner = ovrAvatarOwner;
	}

	public void UpdateAvatar(IntPtr nativeComponent)
	{
		Oculus.Avatar.CAPI.ovrAvatarComponent_Get(nativeComponent, includeName: false, ref nativeAvatarComponent);
		OvrAvatar.ConvertTransform(nativeAvatarComponent.transform, base.transform);
		for (uint num = 0u; num < nativeAvatarComponent.renderPartCount && RenderParts.Count > num; num++)
		{
			OvrAvatarRenderComponent ovrAvatarRenderComponent = RenderParts[(int)num];
			IntPtr renderPart = OvrAvatar.GetRenderPart(nativeAvatarComponent, num);
			switch (Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart))
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				((OvrAvatarSkinnedMeshRenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				((OvrAvatarSkinnedMeshRenderPBSComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRenderPBS(owner, renderPart, ovrAvatarRenderComponent.mesh.sharedMaterial);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				((OvrAvatarSkinnedMeshPBSV2RenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			}
		}
	}

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	public void UpdateAvatarMaterial(Material mat, ovrAvatarMaterialState matState)
	{
		mat.SetColor("_BaseColor", matState.baseColor);
		mat.SetInt("_BaseMaskType", (int)matState.baseMaskType);
		mat.SetVector("_BaseMaskParameters", matState.baseMaskParameters);
		mat.SetVector("_BaseMaskAxis", matState.baseMaskAxis);
		if (matState.alphaMaskTextureID != 0L)
		{
			mat.SetTexture("_AlphaMask", GetLoadedTexture(matState.alphaMaskTextureID));
			mat.SetTextureScale("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.x, matState.alphaMaskScaleOffset.y));
			mat.SetTextureOffset("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.z, matState.alphaMaskScaleOffset.w));
		}
		if (matState.normalMapTextureID != 0L)
		{
			mat.EnableKeyword("NORMAL_MAP_ON");
			mat.SetTexture("_NormalMap", GetLoadedTexture(matState.normalMapTextureID));
			mat.SetTextureScale("_NormalMap", new Vector2(matState.normalMapScaleOffset.x, matState.normalMapScaleOffset.y));
			mat.SetTextureOffset("_NormalMap", new Vector2(matState.normalMapScaleOffset.z, matState.normalMapScaleOffset.w));
		}
		if (matState.parallaxMapTextureID != 0L)
		{
			mat.SetTexture("_ParallaxMap", GetLoadedTexture(matState.parallaxMapTextureID));
			mat.SetTextureScale("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.x, matState.parallaxMapScaleOffset.y));
			mat.SetTextureOffset("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.z, matState.parallaxMapScaleOffset.w));
		}
		if (matState.roughnessMapTextureID != 0L)
		{
			mat.EnableKeyword("ROUGHNESS_ON");
			mat.SetTexture("_RoughnessMap", GetLoadedTexture(matState.roughnessMapTextureID));
			mat.SetTextureScale("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.x, matState.roughnessMapScaleOffset.y));
			mat.SetTextureOffset("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.z, matState.roughnessMapScaleOffset.w));
		}
		mat.EnableKeyword(LayerKeywords[matState.layerCount]);
		for (ulong num = 0uL; num < matState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = matState.layers[num];
			mat.SetInt(LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			mat.SetInt(LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			mat.SetInt(LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			mat.SetColor(LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = LayerSurfaceParameters[num];
				mat.SetTexture(text, GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				mat.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				mat.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				mat.EnableKeyword("PARALLAX_ON");
			}
			mat.SetColor(LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			mat.SetColor(LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			mat.SetColor(LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
		materialStates[mat] = matState;
	}

	public static Texture2D GetLoadedTexture(ulong assetId)
	{
		return ((OvrAvatarAssetTexture)OvrAvatarSDKManager.Instance.GetAsset(assetId))?.texture;
	}
}
public abstract class OvrAvatarDriver : MonoBehaviour
{
	public enum PacketMode
	{
		SDK,
		Unity
	}

	public struct ControllerPose
	{
		public ovrAvatarButton buttons;

		public ovrAvatarTouch touches;

		public Vector2 joystickPosition;

		public float indexTrigger;

		public float handTrigger;

		public bool isActive;

		public static ControllerPose Interpolate(ControllerPose a, ControllerPose b, float t)
		{
			ControllerPose result = default(ControllerPose);
			result.buttons = ((t < 0.5f) ? a.buttons : b.buttons);
			result.touches = ((t < 0.5f) ? a.touches : b.touches);
			result.joystickPosition = Vector2.Lerp(a.joystickPosition, b.joystickPosition, t);
			result.indexTrigger = Mathf.Lerp(a.indexTrigger, b.indexTrigger, t);
			result.handTrigger = Mathf.Lerp(a.handTrigger, b.handTrigger, t);
			result.isActive = ((t < 0.5f) ? a.isActive : b.isActive);
			return result;
		}
	}

	public struct PoseFrame
	{
		public Vector3 headPosition;

		public Quaternion headRotation;

		public Vector3 handLeftPosition;

		public Quaternion handLeftRotation;

		public Vector3 handRightPosition;

		public Quaternion handRightRotation;

		public float voiceAmplitude;

		public ControllerPose controllerLeftPose;

		public ControllerPose controllerRightPose;

		public static PoseFrame Interpolate(PoseFrame a, PoseFrame b, float t)
		{
			PoseFrame result = default(PoseFrame);
			result.headPosition = Vector3.Lerp(a.headPosition, b.headPosition, t);
			result.headRotation = Quaternion.Slerp(a.headRotation, b.headRotation, t);
			result.handLeftPosition = Vector3.Lerp(a.handLeftPosition, b.handLeftPosition, t);
			result.handLeftRotation = Quaternion.Slerp(a.handLeftRotation, b.handLeftRotation, t);
			result.handRightPosition = Vector3.Lerp(a.handRightPosition, b.handRightPosition, t);
			result.handRightRotation = Quaternion.Slerp(a.handRightRotation, b.handRightRotation, t);
			result.voiceAmplitude = Mathf.Lerp(a.voiceAmplitude, b.voiceAmplitude, t);
			result.controllerLeftPose = ControllerPose.Interpolate(a.controllerLeftPose, b.controllerLeftPose, t);
			result.controllerRightPose = ControllerPose.Interpolate(a.controllerRightPose, b.controllerRightPose, t);
			return result;
		}
	}

	public PacketMode Mode;

	protected PoseFrame CurrentPose;

	private ovrAvatarControllerType ControllerType = ovrAvatarControllerType.Quest;

	public PoseFrame GetCurrentPose()
	{
		return CurrentPose;
	}

	public abstract void UpdateTransforms(IntPtr sdkAvatar);

	private void Start()
	{
		switch (OVRPlugin.GetSystemHeadsetType())
		{
		case OVRPlugin.SystemHeadset.Oculus_Quest:
		case OVRPlugin.SystemHeadset.Rift_S:
			ControllerType = ovrAvatarControllerType.Quest;
			break;
		default:
			ControllerType = ovrAvatarControllerType.Touch;
			break;
		}
	}

	public void UpdateTransformsFromPose(IntPtr sdkAvatar)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			ovrAvatarTransform headPose = OvrAvatar.CreateOvrAvatarTransform(CurrentPose.headPosition, CurrentPose.headRotation);
			ovrAvatarHandInputState inputStateLeft = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handLeftPosition, CurrentPose.handLeftRotation), CurrentPose.controllerLeftPose);
			ovrAvatarHandInputState inputStateRight = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handRightPosition, CurrentPose.handRightRotation), CurrentPose.controllerRightPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateBody(sdkAvatar, headPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateHandsWithType(sdkAvatar, inputStateLeft, inputStateRight, ControllerType);
		}
	}

	public static bool GetIsTrackedRemote()
	{
		return false;
	}
}
public class OvrAvatarHand : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarHandComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.HandLeft = null;
		}
		else
		{
			owner.HandRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class OvrAvatarLocalDriver : OvrAvatarDriver
{
	private Vector3 centerEyePosition = Vector3.zero;

	private Quaternion centerEyeRotation = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		OVRNodeStateProperties.GetNodeStatePropertyVector3(XRNode.CenterEye, NodeStatePropertyType.Position, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyePosition);
		OVRNodeStateProperties.GetNodeStatePropertyQuaternion(XRNode.CenterEye, NodeStatePropertyType.Orientation, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyeRotation);
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = centerEyePosition,
			headRotation = centerEyeRotation,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarMaterialManager : MonoBehaviour
{
	public enum TextureType
	{
		DiffuseTextures,
		NormalMaps,
		RoughnessMaps,
		Count
	}

	public struct AvatarComponentMaterialProperties
	{
		public ovrAvatarBodyPartType TypeIndex;

		public Color Color;

		public Texture2D[] Textures;

		public float DiffuseIntensity;

		public float RimIntensity;

		public float ReflectionIntensity;
	}

	public struct AvatarTextureArrayProperties
	{
		public Texture2D[] Textures;

		public Texture2DArray TextureArray;
	}

	public struct AvatarMaterialPropertyBlock
	{
		public Vector4[] Colors;

		public float[] DiffuseIntensities;

		public float[] RimIntensities;

		public float[] ReflectionIntensities;
	}

	[Serializable]
	public class AvatarMaterialConfig
	{
		public AvatarComponentMaterialProperties[] ComponentMaterialProperties;

		public AvatarMaterialPropertyBlock MaterialPropertyBlock;
	}

	private Renderer TargetRenderer;

	private AvatarTextureArrayProperties[] TextureArrays;

	private readonly string[] TextureTypeToShaderProperties = new string[3] { "_MainTex", "_NormalMap", "_RoughnessMap" };

	public AvatarMaterialConfig LocalAvatarConfig = new AvatarMaterialConfig();

	public List<ReflectionProbeBlendInfo> ReflectionProbes = new List<ReflectionProbeBlendInfo>();

	private Shader CombinedShader;

	public static string AVATAR_SHADER_LOADER = "OvrAvatar/Avatar_Mobile_Loader";

	public static string AVATAR_SHADER_MAINTEX = "_MainTex";

	public static string AVATAR_SHADER_NORMALMAP = "_NormalMap";

	public static string AVATAR_SHADER_ROUGHNESSMAP = "_RoughnessMap";

	public static string AVATAR_SHADER_COLOR = "_BaseColor";

	public static string AVATAR_SHADER_DIFFUSEINTENSITY = "_DiffuseIntensity";

	public static string AVATAR_SHADER_RIMINTENSITY = "_RimIntensity";

	public static string AVATAR_SHADER_REFLECTIONINTENSITY = "_ReflectionIntensity";

	public static string AVATAR_SHADER_CUBEMAP = "_Cubemap";

	public static string AVATAR_SHADER_ALPHA = "_Alpha";

	public static string AVATAR_SHADER_LOADING_DIMMER = "_LoadingDimmer";

	public static string AVATAR_SHADER_IRIS_COLOR = "_MaskColorIris";

	public static string AVATAR_SHADER_LIP_COLOR = "_MaskColorLips";

	public static string AVATAR_SHADER_BROW_COLOR = "_MaskColorBrows";

	public static string AVATAR_SHADER_LASH_COLOR = "_MaskColorLashes";

	public static string AVATAR_SHADER_SCLERA_COLOR = "_MaskColorSclera";

	public static string AVATAR_SHADER_GUM_COLOR = "_MaskColorGums";

	public static string AVATAR_SHADER_TEETH_COLOR = "_MaskColorTeeth";

	public static string AVATAR_SHADER_LIP_SMOOTHNESS = "_LipSmoothness";

	public static float[] DiffuseIntensities = new float[5] { 0.3f, 0.1f, 0f, 0.15f, 0.15f };

	public static float[] RimIntensities = new float[5] { 5f, 2f, 2.84f, 4f, 4f };

	public static float[] ReflectionIntensities = new float[5] { 0f, 0.3f, 0.4f, 0f, 0f };

	private const float LOADING_ANIMATION_AMPLITUDE = 0.5f;

	private const float LOADING_ANIMATION_PERIOD = 0.35f;

	private const float LOADING_ANIMATION_CURVE_SCALE = 0.25f;

	private const float LOADING_ANIMATION_DIMMER_MIN = 0.3f;

	public void CreateTextureArrays()
	{
		LocalAvatarConfig.ComponentMaterialProperties = new AvatarComponentMaterialProperties[5];
		LocalAvatarConfig.MaterialPropertyBlock.Colors = new Vector4[5];
		LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.RimIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities = new float[5];
		for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
		{
			LocalAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
		}
		TextureArrays = new AvatarTextureArrayProperties[3];
	}

	public void SetRenderer(Renderer renderer)
	{
		TargetRenderer = renderer;
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
	}

	public void OnCombinedMeshReady()
	{
		InitTextureArrays();
		SetMaterialPropertyBlock();
		StartCoroutine(RunLoadingAnimation(DeleteTextureSet));
	}

	public void AddTextureIDToTextureManager(ulong assetID, bool isSingleComponent)
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().AddTextureIDToTextureSet(GetInstanceID(), assetID, isSingleComponent);
	}

	private void DeleteTextureSet()
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().DeleteTextureSet(GetInstanceID());
	}

	public void InitTextureArrays()
	{
		AvatarComponentMaterialProperties avatarComponentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties[0];
		for (int i = 0; i < TextureArrays.Length && i < avatarComponentMaterialProperties.Textures.Length; i++)
		{
			TextureArrays[i].TextureArray = new Texture2DArray(avatarComponentMaterialProperties.Textures[0].height, avatarComponentMaterialProperties.Textures[0].width, LocalAvatarConfig.ComponentMaterialProperties.Length, avatarComponentMaterialProperties.Textures[0].format, mipChain: true, (QualitySettings.activeColorSpace != 0) ? true : false)
			{
				filterMode = FilterMode.Trilinear,
				anisoLevel = ((i == 2) ? 16 : 4)
			};
			TextureArrays[i].TextureArray.name = $"Texture Array Type: {(TextureType)i}";
			TextureArrays[i].Textures = new Texture2D[LocalAvatarConfig.ComponentMaterialProperties.Length];
			for (int j = 0; j < LocalAvatarConfig.ComponentMaterialProperties.Length; j++)
			{
				TextureArrays[i].Textures[j] = LocalAvatarConfig.ComponentMaterialProperties[j].Textures[i];
				TextureArrays[i].Textures[j].name = $"Texture Type: {(TextureType)i} Component: {j}";
			}
			ProcessTexturesWithMips(TextureArrays[i].Textures, avatarComponentMaterialProperties.Textures[i].height, TextureArrays[i].TextureArray);
		}
	}

	private void ProcessTexturesWithMips(Texture2D[] textures, int texArrayResolution, Texture2DArray texArray)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			int num = texArrayResolution;
			for (int num2 = textures[i].mipmapCount - 1; num2 >= 0; num2--)
			{
				int mipSize = texArrayResolution / num;
				OvrAvatarSDKManager.Instance.GetTextureCopyManager().CopyTexture(textures[i], texArray, num2, mipSize, i, useQueue: false);
				num /= 2;
			}
		}
	}

	private void SetMaterialPropertyBlock()
	{
		if (TargetRenderer != null)
		{
			for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
			{
				LocalAvatarConfig.MaterialPropertyBlock.Colors[i] = LocalAvatarConfig.ComponentMaterialProperties[i].Color;
				LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities[i] = DiffuseIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.RimIntensities[i] = RimIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities[i] = ReflectionIntensities[i];
			}
		}
	}

	private void ApplyMaterialPropertyBlock()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetVectorArray(AVATAR_SHADER_COLOR, LocalAvatarConfig.MaterialPropertyBlock.Colors);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_DIFFUSEINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_RIMINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.RimIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_REFLECTIONINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities);
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
		if (ReflectionProbes != null && ReflectionProbes.Count > 0 && ReflectionProbes[0].probe.texture != null)
		{
			materialPropertyBlock.SetTexture(AVATAR_SHADER_CUBEMAP, ReflectionProbes[0].probe.texture);
		}
		for (int i = 0; i < TextureArrays.Length; i++)
		{
			materialPropertyBlock.SetTexture(TextureTypeToShaderProperties[i], TextureArrays[i].TextureArray);
		}
		TargetRenderer.SetPropertyBlock(materialPropertyBlock);
	}

	public static ovrAvatarBodyPartType GetComponentType(string objectName)
	{
		if (objectName.Contains("0"))
		{
			return ovrAvatarBodyPartType.Body;
		}
		if (objectName.Contains("1"))
		{
			return ovrAvatarBodyPartType.Clothing;
		}
		if (objectName.Contains("2"))
		{
			return ovrAvatarBodyPartType.Eyewear;
		}
		if (objectName.Contains("3"))
		{
			return ovrAvatarBodyPartType.Hair;
		}
		if (objectName.Contains("4"))
		{
			return ovrAvatarBodyPartType.Beard;
		}
		return ovrAvatarBodyPartType.Count;
	}

	private ulong GetTextureIDForType(ovrAvatarPBSMaterialState materialState, TextureType type)
	{
		return type switch
		{
			TextureType.DiffuseTextures => materialState.albedoTextureID, 
			TextureType.NormalMaps => materialState.normalTextureID, 
			TextureType.RoughnessMaps => materialState.metallicnessTextureID, 
			_ => 0uL, 
		};
	}

	public void ValidateTextures(ovrAvatarPBSMaterialState[] materialStates)
	{
		AvatarComponentMaterialProperties[] componentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties;
		int[] array = new int[3];
		TextureFormat[] array2 = new TextureFormat[3];
		for (int i = 0; i < componentMaterialProperties.Length; i++)
		{
			for (int j = 0; j < componentMaterialProperties[i].Textures.Length; j++)
			{
				if (componentMaterialProperties[i].Textures[j] == null)
				{
					string text = componentMaterialProperties[i].TypeIndex.ToString();
					TextureType textureType = (TextureType)j;
					throw new Exception(text + "Invalid: " + textureType);
				}
				array[j] = componentMaterialProperties[i].Textures[j].height;
				array2[j] = componentMaterialProperties[i].Textures[j].format;
			}
		}
		for (int k = 0; k < 3; k++)
		{
			for (int l = 1; l < componentMaterialProperties.Length; l++)
			{
				if (componentMaterialProperties[l - 1].Textures[k].height != componentMaterialProperties[l].Textures[k].height)
				{
					object[] obj = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Resolutions: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj[2] = textureType.ToString();
					obj[3] = " ";
					obj[4] = componentMaterialProperties[l - 1].Textures[k].height;
					obj[5] = " (ID: ";
					obj[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj[7] = ") vs ";
					obj[8] = componentMaterialProperties[l].Textures[k].height;
					obj[9] = " (ID: ";
					obj[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj));
				}
				if (componentMaterialProperties[l - 1].Textures[k].format != componentMaterialProperties[l].Textures[k].format)
				{
					object[] obj2 = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Formats: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj2[2] = textureType.ToString();
					obj2[3] = " ";
					obj2[4] = componentMaterialProperties[l - 1].Textures[k].format;
					obj2[5] = " (ID: ";
					obj2[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj2[7] = ") vs ";
					obj2[8] = componentMaterialProperties[l].Textures[k].format;
					obj2[9] = " (ID: ";
					obj2[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj2[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj2));
				}
			}
		}
	}

	private IEnumerator RunLoadingAnimation(Action callBack)
	{
		CombinedShader = TargetRenderer.sharedMaterial.shader;
		int srcBlend = TargetRenderer.sharedMaterial.GetInt("_SrcBlend");
		int dstBlend = TargetRenderer.sharedMaterial.GetInt("_DstBlend");
		string lightModeTag = TargetRenderer.sharedMaterial.GetTag("LightMode", searchFallbacks: false);
		string renderTypeTag = TargetRenderer.sharedMaterial.GetTag("RenderType", searchFallbacks: false);
		string renderQueueTag = TargetRenderer.sharedMaterial.GetTag("Queue", searchFallbacks: false);
		string ignoreProjectorTag = TargetRenderer.sharedMaterial.GetTag("IgnoreProjector", searchFallbacks: false);
		int renderQueue = TargetRenderer.sharedMaterial.renderQueue;
		bool transparentQueue = TargetRenderer.sharedMaterial.IsKeywordEnabled("_ALPHATEST_ON");
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_LOADER);
		TargetRenderer.sharedMaterial.SetColor(AVATAR_SHADER_COLOR, Color.white);
		while (OvrAvatarSDKManager.Instance.GetTextureCopyManager().GetTextureCount() > 0)
		{
			float value = (0.5f * Mathf.Sin(Time.timeSinceLevelLoad / 0.35f) + 0.5f) * 0.25f + 0.3f;
			TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, value);
			yield return null;
		}
		TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, 1f);
		TargetRenderer.sharedMaterial.shader = CombinedShader;
		TargetRenderer.sharedMaterial.SetInt("_SrcBlend", srcBlend);
		TargetRenderer.sharedMaterial.SetInt("_DstBlend", dstBlend);
		TargetRenderer.sharedMaterial.SetOverrideTag("LightMode", lightModeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("RenderType", renderTypeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("Queue", renderQueueTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("IgnoreProjector", ignoreProjectorTag);
		if (transparentQueue)
		{
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		else
		{
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		TargetRenderer.sharedMaterial.renderQueue = renderQueue;
		ApplyMaterialPropertyBlock();
		callBack?.Invoke();
	}
}
public class OvrAvatarPacket
{
	public IntPtr ovrNativePacket = IntPtr.Zero;

	private List<float> frameTimes = new List<float>();

	private List<OvrAvatarDriver.PoseFrame> frames = new List<OvrAvatarDriver.PoseFrame>();

	private List<byte[]> encodedAudioPackets = new List<byte[]>();

	public float Duration => frameTimes[frameTimes.Count - 1];

	public OvrAvatarDriver.PoseFrame FinalFrame => frames[frames.Count - 1];

	public OvrAvatarPacket()
	{
	}

	public OvrAvatarPacket(OvrAvatarDriver.PoseFrame initialPose)
	{
		frameTimes.Add(0f);
		frames.Add(initialPose);
	}

	private OvrAvatarPacket(List<float> frameTimes, List<OvrAvatarDriver.PoseFrame> frames, List<byte[]> audioPackets)
	{
		this.frameTimes = frameTimes;
		this.frames = frames;
	}

	public void AddFrame(OvrAvatarDriver.PoseFrame frame, float deltaSeconds)
	{
		frameTimes.Add(Duration + deltaSeconds);
		frames.Add(frame);
	}

	public OvrAvatarDriver.PoseFrame GetPoseFrame(float seconds)
	{
		if (frames.Count == 1)
		{
			return frames[0];
		}
		int i;
		for (i = 1; i < frameTimes.Count && frameTimes[i] < seconds; i++)
		{
		}
		OvrAvatarDriver.PoseFrame a = frames[i - 1];
		OvrAvatarDriver.PoseFrame b = frames[i];
		float num = frameTimes[i - 1];
		float num2 = frameTimes[i];
		float t = (seconds - num) / (num2 - num);
		return OvrAvatarDriver.PoseFrame.Interpolate(a, b, t);
	}

	public static OvrAvatarPacket Read(Stream stream)
	{
		BinaryReader binaryReader = new BinaryReader(stream);
		int num = binaryReader.ReadInt32();
		List<float> list = new List<float>(num);
		for (int i = 0; i < num; i++)
		{
			list.Add(binaryReader.ReadSingle());
		}
		List<OvrAvatarDriver.PoseFrame> list2 = new List<OvrAvatarDriver.PoseFrame>(num);
		for (int j = 0; j < num; j++)
		{
			list2.Add(binaryReader.ReadPoseFrame());
		}
		int num2 = binaryReader.ReadInt32();
		List<byte[]> list3 = new List<byte[]>(num2);
		for (int k = 0; k < num2; k++)
		{
			int count = binaryReader.ReadInt32();
			byte[] item = binaryReader.ReadBytes(count);
			list3.Add(item);
		}
		return new OvrAvatarPacket(list, list2, list3);
	}

	public void Write(Stream stream)
	{
		BinaryWriter binaryWriter = new BinaryWriter(stream);
		int count = frameTimes.Count;
		binaryWriter.Write(count);
		for (int i = 0; i < count; i++)
		{
			binaryWriter.Write(frameTimes[i]);
		}
		for (int j = 0; j < count; j++)
		{
			OvrAvatarDriver.PoseFrame frame = frames[j];
			binaryWriter.Write(frame);
		}
		int count2 = encodedAudioPackets.Count;
		binaryWriter.Write(count2);
		for (int k = 0; k < count2; k++)
		{
			byte[] array = encodedAudioPackets[k];
			binaryWriter.Write(array.Length);
			binaryWriter.Write(array);
		}
	}
}
internal static class BinaryWriterExtensions
{
	public static void Write(this BinaryWriter writer, OvrAvatarDriver.PoseFrame frame)
	{
		writer.Write(frame.headPosition);
		writer.Write(frame.headRotation);
		writer.Write(frame.handLeftPosition);
		writer.Write(frame.handLeftRotation);
		writer.Write(frame.handRightPosition);
		writer.Write(frame.handRightRotation);
		writer.Write(frame.voiceAmplitude);
		writer.Write(frame.controllerLeftPose);
		writer.Write(frame.controllerRightPose);
	}

	public static void Write(this BinaryWriter writer, Vector3 vec3)
	{
		writer.Write(vec3.x);
		writer.Write(vec3.y);
		writer.Write(vec3.z);
	}

	public static void Write(this BinaryWriter writer, Vector2 vec2)
	{
		writer.Write(vec2.x);
		writer.Write(vec2.y);
	}

	public static void Write(this BinaryWriter writer, Quaternion quat)
	{
		writer.Write(quat.x);
		writer.Write(quat.y);
		writer.Write(quat.z);
		writer.Write(quat.w);
	}

	public static void Write(this BinaryWriter writer, OvrAvatarDriver.ControllerPose pose)
	{
		writer.Write((uint)pose.buttons);
		writer.Write((uint)pose.touches);
		writer.Write(pose.joystickPosition);
		writer.Write(pose.indexTrigger);
		writer.Write(pose.handTrigger);
		writer.Write(pose.isActive);
	}
}
internal static class BinaryReaderExtensions
{
	public static OvrAvatarDriver.PoseFrame ReadPoseFrame(this BinaryReader reader)
	{
		OvrAvatarDriver.PoseFrame result = default(OvrAvatarDriver.PoseFrame);
		result.headPosition = reader.ReadVector3();
		result.headRotation = reader.ReadQuaternion();
		result.handLeftPosition = reader.ReadVector3();
		result.handLeftRotation = reader.ReadQuaternion();
		result.handRightPosition = reader.ReadVector3();
		result.handRightRotation = reader.ReadQuaternion();
		result.voiceAmplitude = reader.ReadSingle();
		result.controllerLeftPose = reader.ReadControllerPose();
		result.controllerRightPose = reader.ReadControllerPose();
		return result;
	}

	public static Vector2 ReadVector2(this BinaryReader reader)
	{
		Vector2 result = default(Vector2);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		return result;
	}

	public static Vector3 ReadVector3(this BinaryReader reader)
	{
		Vector3 result = default(Vector3);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		return result;
	}

	public static Quaternion ReadQuaternion(this BinaryReader reader)
	{
		Quaternion result = default(Quaternion);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		result.w = reader.ReadSingle();
		return result;
	}

	public static OvrAvatarDriver.ControllerPose ReadControllerPose(this BinaryReader reader)
	{
		OvrAvatarDriver.ControllerPose result = default(OvrAvatarDriver.ControllerPose);
		result.buttons = (ovrAvatarButton)reader.ReadUInt32();
		result.touches = (ovrAvatarTouch)reader.ReadUInt32();
		result.joystickPosition = reader.ReadVector2();
		result.indexTrigger = reader.ReadSingle();
		result.handTrigger = reader.ReadSingle();
		result.isActive = reader.ReadBoolean();
		return result;
	}
}
public class OvrAvatarRemoteDriver : OvrAvatarDriver
{
	private Queue<OvrAvatarPacket> packetQueue = new Queue<OvrAvatarPacket>();

	private IntPtr CurrentSDKPacket = IntPtr.Zero;

	private float CurrentPacketTime;

	private const int MinPacketQueue = 1;

	private const int MaxPacketQueue = 4;

	private int CurrentSequence = -1;

	private bool isStreaming;

	private OvrAvatarPacket currentPacket;

	public void QueuePacket(int sequence, OvrAvatarPacket packet)
	{
		if (sequence > CurrentSequence)
		{
			CurrentSequence = sequence;
			packetQueue.Enqueue(packet);
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		switch (Mode)
		{
		case PacketMode.SDK:
			UpdateFromSDKPacket(sdkAvatar);
			break;
		case PacketMode.Unity:
			UpdateFromUnityPacket(sdkAvatar);
			break;
		}
	}

	private void UpdateFromSDKPacket(IntPtr sdkAvatar)
	{
		if (CurrentSDKPacket == IntPtr.Zero && packetQueue.Count >= 1)
		{
			CurrentSDKPacket = packetQueue.Dequeue().ovrNativePacket;
		}
		if (!(CurrentSDKPacket != IntPtr.Zero))
		{
			return;
		}
		float num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetDurationSeconds(CurrentSDKPacket);
		Oculus.Avatar.CAPI.ovrAvatar_UpdatePoseFromPacket(sdkAvatar, CurrentSDKPacket, Mathf.Min(num, CurrentPacketTime));
		CurrentPacketTime += Time.deltaTime;
		if (CurrentPacketTime > num)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(CurrentSDKPacket);
			CurrentSDKPacket = IntPtr.Zero;
			CurrentPacketTime -= num;
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
		}
	}

	private void UpdateFromUnityPacket(IntPtr sdkAvatar)
	{
		if (!isStreaming && packetQueue.Count > 1)
		{
			currentPacket = packetQueue.Dequeue();
			isStreaming = true;
		}
		if (!isStreaming)
		{
			return;
		}
		CurrentPacketTime += Time.deltaTime;
		while (CurrentPacketTime > currentPacket.Duration)
		{
			if (packetQueue.Count == 0)
			{
				CurrentPose = currentPacket.FinalFrame;
				CurrentPacketTime = 0f;
				currentPacket = null;
				isStreaming = false;
				return;
			}
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
			CurrentPacketTime -= currentPacket.Duration;
			currentPacket = packetQueue.Dequeue();
		}
		CurrentPose = currentPacket.GetPoseFrame(CurrentPacketTime);
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarRenderComponent : MonoBehaviour
{
	private bool firstSkinnedUpdate = true;

	public SkinnedMeshRenderer mesh;

	public Transform[] bones;

	private bool isBodyComponent;

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		if (isBodyComponent && avatar.EnableExpressive && avatar.ShowFirstPerson && !avatar.ShowThirdPerson)
		{
			bool num = (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			bool flag = (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag || flag);
			if (!num)
			{
				mesh.enabled = false;
			}
		}
		else
		{
			bool flag2 = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			flag2 |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag2);
			mesh.enabled = flag2;
		}
	}

	protected SkinnedMeshRenderer CreateSkinnedMesh(ulong assetID, ovrAvatarVisibilityFlags visibilityMask, int thirdPersonLayer, int firstPersonLayer)
	{
		isBodyComponent = base.name.Contains("body");
		OvrAvatarAssetMesh obj = ((OvrAvatarAssetMesh)OvrAvatarSDKManager.Instance.GetAsset(assetID)) ?? throw new Exception("Couldn't find mesh for asset " + assetID);
		if ((visibilityMask & ovrAvatarVisibilityFlags.ThirdPerson) != 0)
		{
			base.gameObject.layer = thirdPersonLayer;
		}
		else
		{
			base.gameObject.layer = firstPersonLayer;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = obj.CreateSkinnedMeshRendererOnObject(base.gameObject);
		skinnedMeshRenderer.quality = SkinQuality.Bone2;
		skinnedMeshRenderer.updateWhenOffscreen = true;
		if ((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0)
		{
			skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		}
		base.gameObject.SetActive(value: false);
		return skinnedMeshRenderer;
	}

	protected void UpdateSkinnedMesh(OvrAvatar avatar, Transform[] bones, ovrAvatarTransform localTransform, ovrAvatarVisibilityFlags visibilityMask, IntPtr renderPart)
	{
		UpdateActive(avatar, visibilityMask);
		OvrAvatar.ConvertTransform(localTransform, base.transform);
		ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
		ulong num = ovrAvatarRenderPartType2 switch
		{
			ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(renderPart), 
			_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
		};
		for (uint num2 = 0u; num2 < 64; num2++)
		{
			ulong num3 = (ulong)(1L << (int)num2);
			if ((firstSkinnedUpdate && num2 < bones.Length) || (num3 & num) != 0L)
			{
				Transform target = bones[num2];
				OvrAvatar.ConvertTransform(ovrAvatarRenderPartType2 switch
				{
					ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(renderPart, num2), 
					_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
				}, target);
			}
		}
		firstSkinnedUpdate = false;
	}

	protected Material CreateAvatarMaterial(string name, Shader shader)
	{
		if (shader == null)
		{
			throw new Exception("No shader provided for avatar material.");
		}
		return new Material(shader)
		{
			name = name
		};
	}
}
[Flags]
public enum ovrAvatarCapabilities
{
	Body = 1,
	Hands = 2,
	Base = 4,
	BodyTilt = 0x10,
	Expressive = 0x20,
	All = -1
}
public enum ovrAvatarMessageType
{
	AvatarSpecification,
	AssetLoaded,
	Count
}
public struct ovrAvatarMessage_AvatarSpecification
{
	public IntPtr avatarSpec;

	public ulong oculusUserID;
}
public struct ovrAvatarMessage_AssetLoaded
{
	public ulong assetID;

	public IntPtr asset;
}
public enum ovrAvatarAssetType
{
	Mesh,
	Texture,
	Pose,
	Material,
	CombinedMesh,
	PBSMaterial,
	FailedLoad,
	Count
}
public struct ovrAvatarMeshVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshVertexV2
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	public float r;

	public float g;

	public float b;

	public float a;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarBlendVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;
}
public struct ovrAvatarMeshAssetData
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public struct ovrAvatarMeshAssetDataV2
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public enum ovrAvatarTextureFormat
{
	RGB24,
	DXT1,
	DXT5,
	ASTC_RGB_6x6,
	ASTC_RGB_6x6_MIPMAPS,
	Count
}
public struct ovrAvatarTextureAssetData
{
	public ovrAvatarTextureFormat format;

	public uint sizeX;

	public uint sizeY;

	public uint mipCount;

	public ulong textureDataSize;

	public IntPtr textureData;
}
public enum ovrAvatarRenderPartType
{
	SkinnedMeshRender,
	SkinnedMeshRenderPBS,
	ProjectorRender,
	SkinnedMeshRenderPBS_V2,
	Count
}
public enum ovrAvatarLogLevel
{
	Unknown,
	Default,
	Verbose,
	Debug,
	Info,
	Warn,
	Error,
	Fatal,
	Silent
}
public struct ovrAvatarTransform
{
	public Vector3 position;

	public Quaternion orientation;

	public Vector3 scale;
}
[Flags]
public enum ovrAvatarButton
{
	One = 1,
	Two = 2,
	Three = 4,
	Joystick = 8
}
[Flags]
public enum ovrAvatarTouch
{
	One = 1,
	Two = 2,
	Joystick = 4,
	ThumbRest = 8,
	Index = 0x10,
	Pointing = 0x40,
	ThumbUp = 0x80
}
public struct ovrAvatarHandInputState
{
	public ovrAvatarTransform transform;

	public ovrAvatarButton buttonMask;

	public ovrAvatarTouch touchMask;

	public float joystickX;

	public float joystickY;

	public float indexTrigger;

	public float handTrigger;

	[MarshalAs(UnmanagedType.I1)]
	public bool isActive;
}
public struct ovrAvatarComponent
{
	public ovrAvatarTransform transform;

	public uint renderPartCount;

	public IntPtr renderParts;

	[MarshalAs(UnmanagedType.LPStr)]
	public string name;
}
[StructLayout(0, Size = 1)]
internal struct ovrAvatarComponent_Offsets
{
	public static long transform = Marshal.OffsetOf(typeof(ovrAvatarComponent), "transform").ToInt64();

	public static int renderPartCount = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderPartCount").ToInt32();

	public static int renderParts = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderParts").ToInt32();

	public static int name = Marshal.OffsetOf(typeof(ovrAvatarComponent), "name").ToInt32();
}
public struct ovrAvatarBaseComponent
{
	public Vector3 basePosition;

	public IntPtr renderComponent;
}
public struct ovrAvatarBodyComponent
{
	public ovrAvatarTransform leftEyeTransform;

	public ovrAvatarTransform rightEyeTransform;

	public ovrAvatarTransform centerEyeTransform;

	public IntPtr renderComponent;
}
[StructLayout(0, Size = 1)]
public struct ovrAvatarBodyComponent_Offsets
{
	public static long leftEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "leftEyeTransform").ToInt64();

	public static long rightEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "rightEyeTransform").ToInt64();

	public static long centerEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "centerEyeTransform").ToInt64();

	public static long renderComponent = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "renderComponent").ToInt64();
}
public struct ovrAvatarControllerComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public struct ovrAvatarHandComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public enum ovrAvatarMaterialLayerBlendMode
{
	Add,
	Multiply,
	Count
}
public enum ovrAvatarMaterialLayerSampleMode
{
	Color,
	Texture,
	TextureSingleChannel,
	Parallax,
	Count
}
public enum ovrAvatarMaterialMaskType
{
	None,
	Positional,
	ViewReflection,
	Fresnel,
	Pulse,
	Count
}
public enum ovrAvatarControllerType
{
	Touch,
	Malibu,
	Go,
	Quest,
	Count
}
public enum ovrAvatarAssetLevelOfDetail
{
	Lowest = 1,
	Medium = 3,
	Highest = 5
}
public enum ovrAvatarLookAndFeelVersion
{
	Unknown = -1,
	One,
	Two
}
public struct ovrAvatarMaterialLayerState
{
	public ovrAvatarMaterialLayerBlendMode blendMode;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ovrAvatarMaterialMaskType maskType;

	public Vector4 layerColor;

	public Vector4 sampleParameters;

	public ulong sampleTexture;

	public Vector4 sampleScaleOffset;

	public Vector4 maskParameters;

	public Vector4 maskAxis;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2))
		{
			return false;
		}
		if (blendMode != ovrAvatarMaterialLayerState2.blendMode)
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialLayerState2.sampleMode)
		{
			return false;
		}
		if (maskType != ovrAvatarMaterialLayerState2.maskType)
		{
			return false;
		}
		if (!VectorEquals(layerColor, ovrAvatarMaterialLayerState2.layerColor))
		{
			return false;
		}
		if (!VectorEquals(sampleParameters, ovrAvatarMaterialLayerState2.sampleParameters))
		{
			return false;
		}
		if (sampleTexture != ovrAvatarMaterialLayerState2.sampleTexture)
		{
			return false;
		}
		if (!VectorEquals(sampleScaleOffset, ovrAvatarMaterialLayerState2.sampleScaleOffset))
		{
			return false;
		}
		if (!VectorEquals(maskParameters, ovrAvatarMaterialLayerState2.maskParameters))
		{
			return false;
		}
		if (!VectorEquals(maskAxis, ovrAvatarMaterialLayerState2.maskAxis))
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return blendMode.GetHashCode() ^ sampleMode.GetHashCode() ^ maskType.GetHashCode() ^ layerColor.GetHashCode() ^ sampleParameters.GetHashCode() ^ sampleTexture.GetHashCode() ^ sampleScaleOffset.GetHashCode() ^ maskParameters.GetHashCode() ^ maskAxis.GetHashCode();
	}
}
public struct ovrAvatarMaterialState
{
	public Vector4 baseColor;

	public ovrAvatarMaterialMaskType baseMaskType;

	public Vector4 baseMaskParameters;

	public Vector4 baseMaskAxis;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ulong alphaMaskTextureID;

	public Vector4 alphaMaskScaleOffset;

	public ulong normalMapTextureID;

	public Vector4 normalMapScaleOffset;

	public ulong parallaxMapTextureID;

	public Vector4 parallaxMapScaleOffset;

	public ulong roughnessMapTextureID;

	public Vector4 roughnessMapScaleOffset;

	public uint layerCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
	public ovrAvatarMaterialLayerState[] layers;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialState ovrAvatarMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarMaterialState2.baseColor))
		{
			return false;
		}
		if (baseMaskType != ovrAvatarMaterialState2.baseMaskType)
		{
			return false;
		}
		if (!VectorEquals(baseMaskParameters, ovrAvatarMaterialState2.baseMaskParameters))
		{
			return false;
		}
		if (!VectorEquals(baseMaskAxis, ovrAvatarMaterialState2.baseMaskAxis))
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialState2.sampleMode)
		{
			return false;
		}
		if (alphaMaskTextureID != ovrAvatarMaterialState2.alphaMaskTextureID)
		{
			return false;
		}
		if (!VectorEquals(alphaMaskScaleOffset, ovrAvatarMaterialState2.alphaMaskScaleOffset))
		{
			return false;
		}
		if (normalMapTextureID != ovrAvatarMaterialState2.normalMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(normalMapScaleOffset, ovrAvatarMaterialState2.normalMapScaleOffset))
		{
			return false;
		}
		if (parallaxMapTextureID != ovrAvatarMaterialState2.parallaxMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(parallaxMapScaleOffset, ovrAvatarMaterialState2.parallaxMapScaleOffset))
		{
			return false;
		}
		if (roughnessMapTextureID != ovrAvatarMaterialState2.roughnessMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(roughnessMapScaleOffset, ovrAvatarMaterialState2.roughnessMapScaleOffset))
		{
			return false;
		}
		if (layerCount != ovrAvatarMaterialState2.layerCount)
		{
			return false;
		}
		for (int i = 0; i < layerCount; i++)
		{
			if (!layers[i].Equals(ovrAvatarMaterialState2.layers[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode()
	{
		int num = 0;
		num ^= baseColor.GetHashCode();
		num ^= baseMaskType.GetHashCode();
		num ^= baseMaskParameters.GetHashCode();
		num ^= baseMaskAxis.GetHashCode();
		num ^= sampleMode.GetHashCode();
		num ^= alphaMaskTextureID.GetHashCode();
		num ^= alphaMaskScaleOffset.GetHashCode();
		num ^= normalMapTextureID.GetHashCode();
		num ^= normalMapScaleOffset.GetHashCode();
		num ^= parallaxMapTextureID.GetHashCode();
		num ^= parallaxMapScaleOffset.GetHashCode();
		num ^= roughnessMapTextureID.GetHashCode();
		num ^= roughnessMapScaleOffset.GetHashCode();
		num ^= layerCount.GetHashCode();
		for (int i = 0; i < layerCount; i++)
		{
			num ^= layers[i].GetHashCode();
		}
		return num;
	}
}
public struct ovrAvatarExpressiveParameters
{
	public Vector4 irisColor;

	public Vector4 scleraColor;

	public Vector4 lashColor;

	public Vector4 browColor;

	public Vector4 lipColor;

	public Vector4 teethColor;

	public Vector4 gumColor;

	public float browLashIntensity;

	public float lipSmoothness;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarExpressiveParameters ovrAvatarExpressiveParameters2))
		{
			return false;
		}
		if (!VectorEquals(irisColor, ovrAvatarExpressiveParameters2.irisColor))
		{
			return false;
		}
		if (!VectorEquals(scleraColor, ovrAvatarExpressiveParameters2.scleraColor))
		{
			return false;
		}
		if (!VectorEquals(lashColor, ovrAvatarExpressiveParameters2.lashColor))
		{
			return false;
		}
		if (!VectorEquals(browColor, ovrAvatarExpressiveParameters2.browColor))
		{
			return false;
		}
		if (!VectorEquals(lipColor, ovrAvatarExpressiveParameters2.lipColor))
		{
			return false;
		}
		if (!VectorEquals(teethColor, ovrAvatarExpressiveParameters2.teethColor))
		{
			return false;
		}
		if (!VectorEquals(gumColor, ovrAvatarExpressiveParameters2.gumColor))
		{
			return false;
		}
		if (browLashIntensity != ovrAvatarExpressiveParameters2.browLashIntensity)
		{
			return false;
		}
		if (lipSmoothness != ovrAvatarExpressiveParameters2.lipSmoothness)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return irisColor.GetHashCode() ^ scleraColor.GetHashCode() ^ lashColor.GetHashCode() ^ browColor.GetHashCode() ^ lipColor.GetHashCode() ^ teethColor.GetHashCode() ^ gumColor.GetHashCode() ^ browLashIntensity.GetHashCode() ^ lipSmoothness.GetHashCode();
	}
}
public struct ovrAvatarPBSMaterialState
{
	public Vector4 baseColor;

	public ulong albedoTextureID;

	public Vector4 albedoMultiplier;

	public ulong metallicnessTextureID;

	public float glossinessScale;

	public ulong normalTextureID;

	public ulong heightTextureID;

	public ulong occlusionTextureID;

	public ulong emissionTextureID;

	public Vector4 emissionMultiplier;

	public ulong detailMaskTextureID;

	public ulong detailAlbedoTextureID;

	public ulong detailNormalTextureID;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarPBSMaterialState2.baseColor))
		{
			return false;
		}
		if (albedoTextureID != ovrAvatarPBSMaterialState2.albedoTextureID)
		{
			return false;
		}
		if (!VectorEquals(albedoMultiplier, ovrAvatarPBSMaterialState2.albedoMultiplier))
		{
			return false;
		}
		if (metallicnessTextureID != ovrAvatarPBSMaterialState2.metallicnessTextureID)
		{
			return false;
		}
		if (glossinessScale != ovrAvatarPBSMaterialState2.glossinessScale)
		{
			return false;
		}
		if (normalTextureID != ovrAvatarPBSMaterialState2.normalTextureID)
		{
			return false;
		}
		if (heightTextureID != ovrAvatarPBSMaterialState2.heightTextureID)
		{
			return false;
		}
		if (occlusionTextureID != ovrAvatarPBSMaterialState2.occlusionTextureID)
		{
			return false;
		}
		if (emissionTextureID != ovrAvatarPBSMaterialState2.emissionTextureID)
		{
			return false;
		}
		if (!VectorEquals(emissionMultiplier, ovrAvatarPBSMaterialState2.emissionMultiplier))
		{
			return false;
		}
		if (detailMaskTextureID != ovrAvatarPBSMaterialState2.detailMaskTextureID)
		{
			return false;
		}
		if (detailAlbedoTextureID != ovrAvatarPBSMaterialState2.detailAlbedoTextureID)
		{
			return false;
		}
		if (detailNormalTextureID != ovrAvatarPBSMaterialState2.detailNormalTextureID)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return baseColor.GetHashCode() ^ albedoTextureID.GetHashCode() ^ albedoMultiplier.GetHashCode() ^ metallicnessTextureID.GetHashCode() ^ glossinessScale.GetHashCode() ^ normalTextureID.GetHashCode() ^ heightTextureID.GetHashCode() ^ occlusionTextureID.GetHashCode() ^ emissionTextureID.GetHashCode() ^ emissionMultiplier.GetHashCode() ^ detailMaskTextureID.GetHashCode() ^ detailAlbedoTextureID.GetHashCode() ^ detailNormalTextureID.GetHashCode();
	}
}
public class OvrAvatarAssetMaterial : OvrAvatarAsset
{
	public ovrAvatarMaterialState material;

	public OvrAvatarAssetMaterial(ulong id, IntPtr mat)
	{
		assetID = id;
		material = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMaterialState(mat);
	}
}
public struct ovrAvatarSkinnedMeshPose
{
	public uint jointCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public ovrAvatarTransform[] jointTransform;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public int[] jointParents;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public IntPtr[] jointNames;
}
[Flags]
public enum ovrAvatarVisibilityFlags
{
	FirstPerson = 1,
	ThirdPerson = 2,
	SelfOccluding = 4
}
public struct ovrAvatarRenderPart_SkinnedMeshRender
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ulong albedoTextureAssetID;

	public ulong surfaceTextureAssetID;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_ProjectorRender
{
	public ovrAvatarTransform localTransform;

	public uint componentIndex;

	public uint renderPartIndex;

	public ovrAvatarMaterialState materialState;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarPBSMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public enum ovrAvatarHandGesture
{
	Default,
	GripSphere,
	GripCube,
	Count
}
public enum ovrAvatarBodyPartType
{
	Body,
	Clothing,
	Eyewear,
	Hair,
	Beard,
	Count
}
public struct ovrAvatarBlendShapeParams
{
	public uint blendShapeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public float[] blendShapeParams;
}
[StructLayout(0, Size = 1)]
internal struct ovrAvatarBlendShapeParams_Offsets
{
	public static int blendShapeParamCount = Marshal.OffsetOf(typeof(ovrAvatarBlendShapeParams), "blendShapeParamCount").ToInt32();

	public static long blendShapeParams = Marshal.SizeOf(typeof(uint));
}
public struct ovrAvatarVisemes
{
	public uint visemeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	public float[] visemeParams;
}
[StructLayout(0, Size = 1)]
internal struct ovrAvatarVisemes_Offsets
{
	public static int visemeParamCount = Marshal.OffsetOf(typeof(ovrAvatarVisemes), "visemeParamCount").ToInt32();

	public static long visemeParams = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarGazeTargetType
{
	AvatarHead,
	AvatarHand,
	Object,
	ObjectStatic,
	Count
}
public struct ovrAvatarGazeTarget
{
	public uint id;

	public Vector3 worldPosition;

	public ovrAvatarGazeTargetType type;
}
[StructLayout(0, Size = 1)]
internal struct ovrAvatarGazeTarget_Offsets
{
	public static int id = 0;

	public static int worldPosition = Marshal.SizeOf(typeof(uint));

	public static int type = worldPosition + Marshal.SizeOf(typeof(Vector3));
}
public struct ovrAvatarGazeTargets
{
	public uint targetCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	public ovrAvatarGazeTarget[] targets;
}
[StructLayout(0, Size = 1)]
internal struct ovrAvatarGazeTargets_Offsets
{
	public static int targetCount = Marshal.OffsetOf(typeof(ovrAvatarGazeTargets), "targetCount").ToInt32();

	public static long targets = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarLightType
{
	Point,
	Direction,
	Spot,
	Count
}
public struct ovrAvatarLight
{
	public uint id;

	public ovrAvatarLightType type;

	public float intensity;

	public Vector3 worldDirection;

	public Vector3 worldPosition;

	public float range;

	public float spotAngleDeg;
}
[StructLayout(0, Size = 1)]
internal struct ovrAvatarLight_Offsets
{
	public static long id = Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64();

	public static long type = Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64();

	public static long intensity = Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64();

	public static long worldDirection = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64();

	public static long worldPosition = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64();

	public static long range = Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64();

	public static long spotAngleDeg = Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64();
}
public struct ovrAvatarLights
{
	public float ambientIntensity;

	public uint lightCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
	public ovrAvatarLight[] lights;
}
[StructLayout(0, Size = 1)]
internal struct ovrAvatarLights_Offsets
{
	public static long ambientIntensity = Marshal.OffsetOf(typeof(ovrAvatarLights), "ambientIntensity").ToInt64();

	public static long lightCount = Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64();

	public static long lights = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
}
[Flags]
public enum ovrAvatarDebugContext : uint
{
	None = 0u,
	GazeTarget = 1u,
	Any = uint.MaxValue
}
public struct ovrAvatarDebugLine
{
	public Vector3 startPoint;

	public Vector3 endPoint;

	public Vector3 color;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public struct ovrAvatarDebugTransform
{
	public ovrAvatarTransform transform;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public delegate void specificationCallback(IntPtr specification);
public delegate void assetLoadedCallback(OvrAvatarAsset asset);
public delegate void combinedMeshLoadedCallback(IntPtr asset);
public class OvrAvatarSDKManager : MonoBehaviour
{
	public struct AvatarSpecRequestParams
	{
		public ulong _userId;

		public specificationCallback _callback;

		public bool _useCombinedMesh;

		public ovrAvatarAssetLevelOfDetail _lod;

		public bool _forceMobileTextureFormat;

		public ovrAvatarLookAndFeelVersion _lookVersion;

		public ovrAvatarLookAndFeelVersion _fallbackVersion;

		public bool _enableExpressive;

		public AvatarSpecRequestParams(ulong userId, specificationCallback callback, bool useCombinedMesh, ovrAvatarAssetLevelOfDetail lod, bool forceMobileTextureFormat, ovrAvatarLookAndFeelVersion lookVersion, ovrAvatarLookAndFeelVersion fallbackVersion, bool enableExpressive)
		{
			_userId = userId;
			_callback = callback;
			_useCombinedMesh = useCombinedMesh;
			_lod = lod;
			_forceMobileTextureFormat = forceMobileTextureFormat;
			_lookVersion = lookVersion;
			_fallbackVersion = fallbackVersion;
			_enableExpressive = enableExpressive;
		}
	}

	private static OvrAvatarSDKManager _instance;

	private bool initialized;

	private Dictionary<ulong, HashSet<specificationCallback>> specificationCallbacks;

	private Dictionary<ulong, HashSet<assetLoadedCallback>> assetLoadedCallbacks;

	private Dictionary<IntPtr, combinedMeshLoadedCallback> combinedMeshLoadedCallbacks;

	private Dictionary<ulong, OvrAvatarAsset> assetCache;

	private OvrAvatarTextureCopyManager textureCopyManager;

	public ovrAvatarLogLevel LoggingLevel = ovrAvatarLogLevel.Info;

	private Queue<AvatarSpecRequestParams> avatarSpecificationQueue;

	private List<int> loadingAvatars;

	private bool avatarSpecRequestAvailable = true;

	private float lastDispatchedAvatarSpecRequestTime;

	private const float AVATAR_SPEC_REQUEST_TIMEOUT = 5f;

	public static OvrAvatarSDKManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<OvrAvatarSDKManager>();
				if (_instance == null)
				{
					GameObject gameObject = new GameObject("OvrAvatarSDKManager");
					_instance = gameObject.AddComponent<OvrAvatarSDKManager>();
					_instance.textureCopyManager = gameObject.AddComponent<OvrAvatarTextureCopyManager>();
					_instance.initialized = _instance.Initialize();
				}
			}
			if (!_instance.initialized)
			{
				return null;
			}
			return _instance;
		}
	}

	private bool Initialize()
	{
		Oculus.Avatar.CAPI.Initialize();
		string text = GetAppId();
		if (text == "")
		{
			text = "0";
		}
		Oculus.Avatar.CAPI.ovrAvatar_InitializeAndroidUnity(text);
		specificationCallbacks = new Dictionary<ulong, HashSet<specificationCallback>>();
		assetLoadedCallbacks = new Dictionary<ulong, HashSet<assetLoadedCallback>>();
		combinedMeshLoadedCallbacks = new Dictionary<IntPtr, combinedMeshLoadedCallback>();
		assetCache = new Dictionary<ulong, OvrAvatarAsset>();
		avatarSpecificationQueue = new Queue<AvatarSpecRequestParams>();
		loadingAvatars = new List<int>();
		Oculus.Avatar.CAPI.ovrAvatar_SetLoggingLevel(LoggingLevel);
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(Oculus.Avatar.CAPI.LoggingCallback);
		return true;
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.Shutdown();
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(null);
		Oculus.Avatar.CAPI.ovrAvatar_Shutdown();
	}

	private void Update()
	{
		if (Instance == null)
		{
			return;
		}
		if (avatarSpecificationQueue.Count > 0 && (avatarSpecRequestAvailable || Time.time - lastDispatchedAvatarSpecRequestTime >= 5f))
		{
			avatarSpecRequestAvailable = false;
			AvatarSpecRequestParams avatarSpecRequest = avatarSpecificationQueue.Dequeue();
			DispatchAvatarSpecificationRequest(avatarSpecRequest);
			lastDispatchedAvatarSpecRequestTime = Time.time;
		}
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarMessage_Pop();
		if (intPtr == IntPtr.Zero)
		{
			return;
		}
		ovrAvatarMessageType ovrAvatarMessageType2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetType(intPtr);
		switch (ovrAvatarMessageType2)
		{
		case ovrAvatarMessageType.AssetLoaded:
		{
			ovrAvatarMessage_AssetLoaded ovrAvatarMessage_AssetLoaded2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAssetLoaded(intPtr);
			IntPtr asset = ovrAvatarMessage_AssetLoaded2.asset;
			ulong assetID = ovrAvatarMessage_AssetLoaded2.assetID;
			ovrAvatarAssetType ovrAvatarAssetType2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetType(asset);
			OvrAvatarAsset ovrAvatarAsset = null;
			IntPtr key = IntPtr.Zero;
			switch (ovrAvatarAssetType2)
			{
			case ovrAvatarAssetType.Mesh:
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.Mesh);
				break;
			case ovrAvatarAssetType.Texture:
				ovrAvatarAsset = new OvrAvatarAssetTexture(assetID, asset);
				break;
			case ovrAvatarAssetType.Material:
				ovrAvatarAsset = new OvrAvatarAssetMaterial(assetID, asset);
				break;
			case ovrAvatarAssetType.CombinedMesh:
				key = Oculus.Avatar.CAPI.ovrAvatarAsset_GetAvatar(asset);
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.CombinedMesh);
				break;
			default:
				throw new NotImplementedException($"Unsupported asset type format {ovrAvatarAssetType2.ToString()}");
			case ovrAvatarAssetType.FailedLoad:
				break;
			}
			if (ovrAvatarAssetType2 == ovrAvatarAssetType.CombinedMesh)
			{
				if (!assetCache.ContainsKey(assetID))
				{
					assetCache.Add(assetID, ovrAvatarAsset);
				}
				if (combinedMeshLoadedCallbacks.TryGetValue(key, out var value2))
				{
					value2(asset);
					combinedMeshLoadedCallbacks.Remove(key);
				}
			}
			else
			{
				if (ovrAvatarAsset == null || !assetLoadedCallbacks.TryGetValue(ovrAvatarMessage_AssetLoaded2.assetID, out var value3))
				{
					break;
				}
				assetCache.Add(assetID, ovrAvatarAsset);
				foreach (assetLoadedCallback item in value3)
				{
					item(ovrAvatarAsset);
				}
				assetLoadedCallbacks.Remove(ovrAvatarMessage_AssetLoaded2.assetID);
			}
			break;
		}
		case ovrAvatarMessageType.AvatarSpecification:
		{
			avatarSpecRequestAvailable = true;
			ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_AvatarSpecification2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAvatarSpecification(intPtr);
			if (!specificationCallbacks.TryGetValue(ovrAvatarMessage_AvatarSpecification2.oculusUserID, out var value))
			{
				break;
			}
			foreach (specificationCallback item2 in value)
			{
				item2(ovrAvatarMessage_AvatarSpecification2.avatarSpec);
			}
			specificationCallbacks.Remove(ovrAvatarMessage_AvatarSpecification2.oculusUserID);
			break;
		}
		default:
			throw new NotImplementedException("Unhandled ovrAvatarMessageType: " + ovrAvatarMessageType2);
		}
		Oculus.Avatar.CAPI.ovrAvatarMessage_Free(intPtr);
	}

	public bool IsAvatarSpecWaiting()
	{
		return avatarSpecificationQueue.Count > 0;
	}

	public bool IsAvatarLoading()
	{
		return loadingAvatars.Count > 0;
	}

	public void AddLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Add(gameobjectID);
	}

	public void RemoveLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Remove(gameobjectID);
	}

	public void RequestAvatarSpecification(AvatarSpecRequestParams avatarSpecRequest)
	{
		avatarSpecificationQueue.Enqueue(avatarSpecRequest);
	}

	private void DispatchAvatarSpecificationRequest(AvatarSpecRequestParams avatarSpecRequest)
	{
		textureCopyManager.CheckFallbackTextureSet(avatarSpecRequest._lod);
		Oculus.Avatar.CAPI.ovrAvatar_SetForceASTCTextures(avatarSpecRequest._forceMobileTextureFormat);
		if (!specificationCallbacks.TryGetValue(avatarSpecRequest._userId, out var value))
		{
			value = new HashSet<specificationCallback>();
			specificationCallbacks.Add(avatarSpecRequest._userId, value);
			IntPtr specificationRequest = Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Create(avatarSpecRequest._userId);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLookAndFeelVersion(specificationRequest, avatarSpecRequest._lookVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(specificationRequest, avatarSpecRequest._fallbackVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLevelOfDetail(specificationRequest, avatarSpecRequest._lod);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetCombineMeshes(specificationRequest, avatarSpecRequest._useCombinedMesh);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetExpressiveFlag(specificationRequest, avatarSpecRequest._enableExpressive);
			Oculus.Avatar.CAPI.ovrAvatar_RequestAvatarSpecificationFromSpecRequest(specificationRequest);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Destroy(specificationRequest);
		}
		value.Add(avatarSpecRequest._callback);
	}

	public void BeginLoadingAsset(ulong assetId, ovrAvatarAssetLevelOfDetail lod, assetLoadedCallback callback)
	{
		if (!assetLoadedCallbacks.TryGetValue(assetId, out var value))
		{
			value = new HashSet<assetLoadedCallback>();
			assetLoadedCallbacks.Add(assetId, value);
		}
		Oculus.Avatar.CAPI.ovrAvatarAsset_BeginLoadingLOD(assetId, lod);
		value.Add(callback);
	}

	public void RegisterCombinedMeshCallback(IntPtr sdkAvatar, combinedMeshLoadedCallback callback)
	{
		if (!combinedMeshLoadedCallbacks.TryGetValue(sdkAvatar, out var _))
		{
			combinedMeshLoadedCallbacks.Add(sdkAvatar, callback);
			return;
		}
		throw new Exception("Adding second combind mesh callback for same avatar");
	}

	public OvrAvatarAsset GetAsset(ulong assetId)
	{
		if (assetCache.TryGetValue(assetId, out var value))
		{
			return value;
		}
		return null;
	}

	public void DeleteAssetFromCache(ulong assetId)
	{
		if (assetCache.ContainsKey(assetId))
		{
			assetCache.Remove(assetId);
		}
	}

	public string GetAppId()
	{
		if (UnityEngine.Application.platform != RuntimePlatform.Android)
		{
			return OvrAvatarSettings.AppID;
		}
		return OvrAvatarSettings.MobileAppID;
	}

	public OvrAvatarTextureCopyManager GetTextureCopyManager()
	{
		if (textureCopyManager != null)
		{
			return textureCopyManager;
		}
		return null;
	}
}
public sealed class OvrAvatarSettings : ScriptableObject
{
	private static OvrAvatarSettings instance;

	[SerializeField]
	private string ovrAppID = "";

	[SerializeField]
	private string ovrGearAppID = "";

	public static string AppID
	{
		get
		{
			return Instance.ovrAppID;
		}
		set
		{
			Instance.ovrAppID = value;
		}
	}

	public static string MobileAppID
	{
		get
		{
			return Instance.ovrGearAppID;
		}
		set
		{
			Instance.ovrGearAppID = value;
		}
	}

	public static OvrAvatarSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<OvrAvatarSettings>("OvrAvatarSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<OvrAvatarSettings>();
				}
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class OvrAvatarSkinnedMeshRenderComponent : OvrAvatarRenderComponent
{
	private Shader surface;

	private Shader surfaceSelfOccluding;

	private bool previouslyActive;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender, Shader surface, Shader surfaceSelfOccluding, int thirdPersonLayer, int firstPersonLayer)
	{
		this.surfaceSelfOccluding = ((surfaceSelfOccluding != null) ? surfaceSelfOccluding : Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
		this.surface = ((surface != null) ? surface : Shader.Find("OvrAvatar/AvatarSurfaceShader"));
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		bones = mesh.bones;
		UpdateMeshMaterial(skinnedMeshRender.visibilityMask, mesh);
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		UpdateMeshMaterial(visibilityMask, mesh);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && (Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_MaterialStateChanged(renderPart) || (!previouslyActive && activeSelf)))
		{
			ovrAvatarMaterialState matState = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetMaterialState(renderPart);
			component.UpdateAvatarMaterial(mesh.sharedMaterial, matState);
		}
		previouslyActive = activeSelf;
	}

	private void UpdateMeshMaterial(ovrAvatarVisibilityFlags visibilityMask, SkinnedMeshRenderer rootMesh)
	{
		Shader shader = (((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) != 0) ? surfaceSelfOccluding : surface);
		if (rootMesh.sharedMaterial == null || rootMesh.sharedMaterial.shader != shader)
		{
			rootMesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		}
	}
}
public class OvrAvatarSkinnedMeshRenderPBSComponent : OvrAvatarRenderComponent
{
	private bool isMaterialInitilized;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS, Shader shader, int thirdPersonLayer, int firstPersonLayer)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShaderPBS");
		}
		mesh = CreateSkinnedMesh(skinnedMeshRenderPBS.meshAssetID, skinnedMeshRenderPBS.visibilityMask, thirdPersonLayer, firstPersonLayer);
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		bones = mesh.bones;
	}

	internal void UpdateSkinnedMeshRenderPBS(OvrAvatar avatar, IntPtr renderPart, Material mat)
	{
		if (!isMaterialInitilized)
		{
			isMaterialInitilized = true;
			ulong assetId = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(renderPart);
			ulong assetId2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(renderPart);
			mat.SetTexture("_Albedo", OvrAvatarComponent.GetLoadedTexture(assetId));
			mat.SetTexture("_Surface", OvrAvatarComponent.GetLoadedTexture(assetId2));
		}
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
	}
}
public class OvrAvatarSkinnedMeshPBSV2RenderComponent : OvrAvatarRenderComponent
{
	private OvrAvatarMaterialManager avatarMaterialManager;

	private bool previouslyActive;

	private bool isCombinedMaterial;

	private ovrAvatarExpressiveParameters ExpressiveParameters;

	private bool EnableExpressive;

	private int blendShapeCount;

	private ovrAvatarBlendShapeParams blendShapeParams;

	private const string MAIN_MATERIAL_NAME = "main_material";

	private const string EYE_MATERIAL_NAME = "eye_material";

	private const string DEFAULT_MATERIAL_NAME = "_material";

	internal void Initialize(IntPtr renderPart, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRender, OvrAvatarMaterialManager materialManager, int thirdPersonLayer, int firstPersonLayer, bool combinedMesh, ovrAvatarAssetLevelOfDetail lod, bool assignExpressiveParams, OvrAvatar avatar, bool isControllerModel)
	{
		avatarMaterialManager = materialManager;
		isCombinedMaterial = combinedMesh;
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		EnableExpressive = assignExpressiveParams;
		Shader shader = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_SingleComponent : avatar.Skinshaded_VertFrag_SingleComponent);
		Shader shader2 = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_CombinedMesh : avatar.Skinshaded_VertFrag_CombinedMesh);
		Shader shader3 = (isCombinedMaterial ? shader2 : shader);
		if (isControllerModel)
		{
			shader3 = avatar.ControllerShader;
		}
		if (EnableExpressive)
		{
			ExpressiveParameters = Oculus.Avatar.CAPI.ovrAvatar_GetExpressiveParameters(avatar.sdkAvatar);
			Shader eyeLens = avatar.EyeLens;
			Material[] array = new Material[2]
			{
				CreateAvatarMaterial(base.gameObject.name + "main_material", shader3),
				CreateAvatarMaterial(base.gameObject.name + "eye_material", eyeLens)
			};
			if (avatar.UseTransparentRenderQueue)
			{
				SetMaterialTransparent(array[0]);
			}
			else
			{
				SetMaterialOpaque(array[0]);
			}
			array[1].renderQueue = -1;
			mesh.materials = array;
		}
		else
		{
			mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader3);
			if (avatar.UseTransparentRenderQueue && !isControllerModel)
			{
				SetMaterialTransparent(mesh.sharedMaterial);
			}
			else
			{
				SetMaterialOpaque(mesh.sharedMaterial);
			}
		}
		bones = mesh.bones;
		if (isCombinedMaterial)
		{
			avatarMaterialManager.SetRenderer(mesh);
			InitializeCombinedMaterial(renderPart, (int)lod);
			avatarMaterialManager.OnCombinedMeshReady();
		}
		blendShapeParams = default(ovrAvatarBlendShapeParams);
		blendShapeParams.blendShapeParamCount = 0u;
		blendShapeParams.blendShapeParams = new float[64];
		blendShapeCount = mesh.sharedMesh.blendShapeCount;
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && !previouslyActive && activeSelf && !isCombinedMaterial)
		{
			InitializeSingleComponentMaterial(renderPart, (int)(avatar.LevelOfDetail - 1));
		}
		if (blendShapeCount > 0)
		{
			Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetBlendShapeParams(renderPart, ref blendShapeParams);
			for (uint num = 0u; num < blendShapeParams.blendShapeParamCount && num < blendShapeCount; num++)
			{
				float num2 = blendShapeParams.blendShapeParams[num];
				mesh.SetBlendShapeWeight((int)num, num2 * 100f);
			}
		}
		previouslyActive = activeSelf;
	}

	private void InitializeSingleComponentMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(renderPart);
		int componentType = (int)OvrAvatarMaterialManager.GetComponentType(base.gameObject.name);
		Texture2D texture2D = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.albedoTextureID);
		Texture2D texture2D2 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.normalTextureID);
		Texture2D texture2D3 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.metallicnessTextureID);
		if (texture2D != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.albedoTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D.anisoLevel = 4;
		if (texture2D2 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.normalTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D2 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
		}
		texture2D2.anisoLevel = 4;
		if (texture2D3 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.metallicnessTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D3 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D3.anisoLevel = 16;
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_MAINTEX, texture2D);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_NORMALMAP, texture2D2);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_ROUGHNESSMAP, texture2D3);
		mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_COLOR, ovrAvatarPBSMaterialState2.albedoMultiplier);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_DIFFUSEINTENSITY, OvrAvatarMaterialManager.DiffuseIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_RIMINTENSITY, OvrAvatarMaterialManager.RimIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_REFLECTIONINTENSITY, OvrAvatarMaterialManager.ReflectionIntensities[componentType]);
		mesh.GetClosestReflectionProbes(avatarMaterialManager.ReflectionProbes);
		if (avatarMaterialManager.ReflectionProbes != null && avatarMaterialManager.ReflectionProbes.Count > 0)
		{
			mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_CUBEMAP, avatarMaterialManager.ReflectionProbes[0].probe.texture);
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
	}

	private void InitializeCombinedMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState[] array = Oculus.Avatar.CAPI.ovrAvatar_GetBodyPBSMaterialStates(renderPart);
		if (array.Length != 5)
		{
			return;
		}
		avatarMaterialManager.CreateTextureArrays();
		OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = avatarMaterialManager.LocalAvatarConfig.ComponentMaterialProperties;
		for (int i = 0; i < array.Length; i++)
		{
			componentMaterialProperties[i].TypeIndex = (ovrAvatarBodyPartType)i;
			componentMaterialProperties[i].Color = array[i].albedoMultiplier;
			componentMaterialProperties[i].DiffuseIntensity = OvrAvatarMaterialManager.DiffuseIntensities[i];
			componentMaterialProperties[i].RimIntensity = OvrAvatarMaterialManager.RimIntensities[i];
			componentMaterialProperties[i].ReflectionIntensity = OvrAvatarMaterialManager.ReflectionIntensities[i];
			Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(array[i].albedoTextureID);
			Texture2D loadedTexture2 = OvrAvatarComponent.GetLoadedTexture(array[i].normalTextureID);
			Texture2D loadedTexture3 = OvrAvatarComponent.GetLoadedTexture(array[i].metallicnessTextureID);
			if (loadedTexture != null)
			{
				componentMaterialProperties[i].Textures[0] = loadedTexture;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].albedoTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[0] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[0].anisoLevel = 4;
			if (loadedTexture2 != null)
			{
				componentMaterialProperties[i].Textures[1] = loadedTexture2;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].normalTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[1] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
			}
			componentMaterialProperties[i].Textures[1].anisoLevel = 4;
			if (loadedTexture3 != null)
			{
				componentMaterialProperties[i].Textures[2] = loadedTexture3;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].metallicnessTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[2] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[2].anisoLevel = 16;
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
		avatarMaterialManager.ValidateTextures(array);
	}

	private void SetMaterialTransparent(Material mat)
	{
		mat.SetOverrideTag("Queue", "Transparent");
		mat.SetOverrideTag("RenderType", "Transparent");
		mat.SetInt("_SrcBlend", 5);
		mat.SetInt("_DstBlend", 10);
		mat.EnableKeyword("_ALPHATEST_ON");
		mat.EnableKeyword("_ALPHABLEND_ON");
		mat.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 3000;
	}

	private void SetMaterialOpaque(Material mat)
	{
		mat.SetOverrideTag("Queue", "Geometry");
		mat.SetOverrideTag("RenderType", "Opaque");
		mat.SetInt("_SrcBlend", 1);
		mat.SetInt("_DstBlend", 0);
		mat.DisableKeyword("_ALPHATEST_ON");
		mat.DisableKeyword("_ALPHABLEND_ON");
		mat.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 2000;
	}
}
public class OvrAvatarTextureCopyManager : MonoBehaviour
{
	[Serializable]
	public struct FallbackTextureSet
	{
		public bool Initialized;

		public Texture2D DiffuseRoughness;

		public Texture2D Normal;
	}

	private struct CopyTextureParams
	{
		public Texture Src;

		public Texture Dst;

		public int Mip;

		public int SrcSize;

		public int DstElement;

		public CopyTextureParams(Texture src, Texture dst, int mip, int srcSize, int dstElement)
		{
			Src = src;
			Dst = dst;
			Mip = mip;
			SrcSize = srcSize;
			DstElement = dstElement;
		}
	}

	public struct TextureSet
	{
		public Dictionary<ulong, bool> TextureIDSingleMeshPair;

		public bool IsProcessed;

		public TextureSet(Dictionary<ulong, bool> textureIDSingleMeshPair, bool isProcessed)
		{
			TextureIDSingleMeshPair = textureIDSingleMeshPair;
			IsProcessed = isProcessed;
		}
	}

	public FallbackTextureSet[] FallbackTextureSets = new FallbackTextureSet[6];

	private Queue<CopyTextureParams> texturesToCopy;

	private Dictionary<int, TextureSet> textureSets;

	private const int TEXTURES_TO_COPY_QUEUE_CAPACITY = 256;

	private const int COPIES_PER_FRAME = 8;

	private readonly string[] FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS = new string[6] { "null", "FallbackTextures/fallback_diffuse_roughness_256", "null", "FallbackTextures/fallback_diffuse_roughness_1024", "null", "FallbackTextures/fallback_diffuse_roughness_2048" };

	private readonly string[] FALLBACK_TEXTURE_PATHS_NORMAL = new string[6] { "null", "FallbackTextures/fallback_normal_256", "null", "FallbackTextures/fallback_normal_1024", "null", "FallbackTextures/fallback_normal_2048" };

	private const string PATH_HIGHEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_2048";

	private const string PATH_MEDIUM_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_1024";

	private const string PATH_LOWEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_256";

	private const string PATH_HIGHEST_NORMAL = "FallbackTextures/fallback_normal_2048";

	private const string PATH_MEDIUM_NORMAL = "FallbackTextures/fallback_normal_1024";

	private const string PATH_LOWEST_NORMAL = "FallbackTextures/fallback_normal_256";

	private const int GPU_TEXTURE_COPY_WAIT_TIME = 10;

	public OvrAvatarTextureCopyManager()
	{
		texturesToCopy = new Queue<CopyTextureParams>(256);
		textureSets = new Dictionary<int, TextureSet>();
	}

	public void Update()
	{
		if (texturesToCopy.Count == 0)
		{
			return;
		}
		lock (texturesToCopy)
		{
			for (int i = 0; i < Mathf.Min(8, texturesToCopy.Count); i++)
			{
				CopyTexture(texturesToCopy.Dequeue());
			}
		}
	}

	public int GetTextureCount()
	{
		return texturesToCopy.Count;
	}

	public void CopyTexture(Texture src, Texture dst, int mipLevel, int mipSize, int dstElement, bool useQueue = true)
	{
		CopyTextureParams copyTextureParams = new CopyTextureParams(src, dst, mipLevel, mipSize, dstElement);
		if (useQueue)
		{
			lock (texturesToCopy)
			{
				if (texturesToCopy.Count < 256)
				{
					texturesToCopy.Enqueue(copyTextureParams);
				}
				else
				{
					CopyTexture(copyTextureParams);
				}
				return;
			}
		}
		CopyTexture(copyTextureParams);
	}

	private void CopyTexture(CopyTextureParams copyTextureParams)
	{
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip);
	}

	public void AddTextureIDToTextureSet(int gameobjectID, ulong textureID, bool isSingleMesh)
	{
		bool value2;
		if (!textureSets.ContainsKey(gameobjectID))
		{
			TextureSet value = new TextureSet(new Dictionary<ulong, bool>(), isProcessed: false);
			value.TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
			textureSets.Add(gameobjectID, value);
		}
		else if (textureSets[gameobjectID].TextureIDSingleMeshPair.TryGetValue(textureID, out value2))
		{
			if (!value2 && isSingleMesh)
			{
				textureSets[gameobjectID].TextureIDSingleMeshPair[textureID] = true;
			}
		}
		else
		{
			textureSets[gameobjectID].TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
		}
	}

	public void DeleteTextureSet(int gameobjectID)
	{
		if (textureSets.TryGetValue(gameobjectID, out var value) && !value.IsProcessed)
		{
			StartCoroutine(DeleteTextureSetCoroutine(value, gameobjectID));
		}
	}

	private IEnumerator DeleteTextureSetCoroutine(TextureSet textureSetToDelete, int gameobjectID)
	{
		yield return new WaitForSeconds(10f);
		while (OvrAvatarSDKManager.Instance.IsAvatarLoading())
		{
			yield return null;
		}
		foreach (KeyValuePair<ulong, bool> item in textureSetToDelete.TextureIDSingleMeshPair)
		{
			bool flag = !item.Value;
			if (flag)
			{
				foreach (KeyValuePair<int, TextureSet> textureSet in textureSets)
				{
					if (textureSet.Key == gameobjectID)
					{
						continue;
					}
					foreach (KeyValuePair<ulong, bool> item2 in textureSet.Value.TextureIDSingleMeshPair)
					{
						if (item2.Key == item.Key && (!textureSet.Value.IsProcessed || item2.Value))
						{
							flag = false;
							break;
						}
					}
					if (!flag)
					{
						break;
					}
				}
			}
			if (flag)
			{
				Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(item.Key);
				if (loadedTexture != null)
				{
					OvrAvatarSDKManager.Instance.DeleteAssetFromCache(item.Key);
					UnityEngine.Object.Destroy(loadedTexture);
				}
			}
		}
		textureSetToDelete.IsProcessed = true;
		textureSets.Remove(gameobjectID);
	}

	public void CheckFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		if (!FallbackTextureSets[(int)lod].Initialized)
		{
			InitFallbackTextureSet(lod);
		}
	}

	private void InitFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		FallbackTextureSets[(int)lod].DiffuseRoughness = (FallbackTextureSets[(int)lod].DiffuseRoughness = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS[(int)lod]));
		FallbackTextureSets[(int)lod].Normal = (FallbackTextureSets[(int)lod].Normal = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_NORMAL[(int)lod]));
		FallbackTextureSets[(int)lod].Initialized = true;
	}
}
public class OvrAvatarTouchController : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarControllerComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.ControllerLeft = null;
		}
		else
		{
			owner.ControllerRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class EnableSwitch : MonoBehaviour
{
	public GameObject[] SwitchTargets;

	public bool SetActive<T>(int target) where T : MonoBehaviour
	{
		if (target < 0 || target >= SwitchTargets.Length)
		{
			return false;
		}
		for (int i = 0; i < SwitchTargets.Length; i++)
		{
			SwitchTargets[i].SetActive(value: false);
			OVRLipSyncContextMorphTarget component = SwitchTargets[i].GetComponent<OVRLipSyncContextMorphTarget>();
			if ((bool)component)
			{
				component.enabled = false;
			}
			OVRLipSyncContextTextureFlip component2 = SwitchTargets[i].GetComponent<OVRLipSyncContextTextureFlip>();
			if ((bool)component2)
			{
				component2.enabled = false;
			}
		}
		SwitchTargets[target].SetActive(value: true);
		MonoBehaviour component3 = SwitchTargets[target].GetComponent<T>();
		if (component3 != null)
		{
			component3.enabled = true;
		}
		return true;
	}
}
public class LipSyncDemo_Control : MonoBehaviour
{
	[Tooltip("Key used to rotate the demo object up to 45 degrees to the left.")]
	public KeyCode rotateLeftKey = KeyCode.LeftArrow;

	[Tooltip("Key used to rotate the demo object up to 45 degrees to the right.")]
	public KeyCode rotateRightKey = KeyCode.RightArrow;

	[Tooltip("Key used to reset demo object rotation.")]
	public KeyCode resetRotationKey = KeyCode.DownArrow;

	private float resetRotation = 180f;

	private float rotationAmount = 20f;

	private float rotationMax = 45f;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(rotateLeftKey))
		{
			RotateObject(rotationAmount);
		}
		else if (Input.GetKey(rotateRightKey))
		{
			RotateObject(0f - rotationAmount);
		}
		else if (Input.GetKey(resetRotationKey))
		{
			RotateObject(resetRotation, absolute: true);
		}
	}

	private void RotateObject(float amountDegrees, bool absolute = false)
	{
		GameObject gameObject = GameObject.Find("LipSyncMorphTarget_Female");
		if (gameObject == null)
		{
			gameObject = GameObject.Find("RobotHead_TextureFlip");
		}
		if (!gameObject)
		{
			return;
		}
		if (absolute)
		{
			float num = amountDegrees - gameObject.transform.eulerAngles.y;
			gameObject.transform.Rotate(Vector3.up * num);
			return;
		}
		float num2 = Time.deltaTime * amountDegrees;
		if (num2 + gameObject.transform.eulerAngles.y >= resetRotation - rotationMax && num2 + gameObject.transform.eulerAngles.y <= resetRotation + rotationMax)
		{
			gameObject.transform.Rotate(Vector3.up * num2);
		}
	}
}
public class LipSyncDemo_SetCurrentTarget : MonoBehaviour
{
	public EnableSwitch[] SwitchTargets;

	private int targetSet;

	private int maxTarget = 6;

	private bool XRButtonBeingPressed;

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
		targetSet = 0;
		SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
		SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			targetSet = 0;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			targetSet = 1;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			targetSet = 2;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			targetSet = 3;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			targetSet = 4;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			targetSet = 5;
			SetCurrentTarget();
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
		List<InputDevice> list = new List<InputDevice>();
		InputDevices.GetDevicesWithCharacteristics(InputDeviceCharacteristics.HeldInHand, list);
		bool flag = false;
		bool flag2 = false;
		foreach (InputDevice item in list)
		{
			if (item.TryGetFeatureValue(CommonUsages.primaryButton, out var value) && value)
			{
				flag = true;
			}
			if (item.TryGetFeatureValue(CommonUsages.secondaryButton, out value) && value)
			{
				flag2 = true;
			}
		}
		if (flag && !XRButtonBeingPressed)
		{
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
		}
		if (flag2 && !XRButtonBeingPressed)
		{
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
		}
		XRButtonBeingPressed = flag || flag2;
	}

	private void SetCurrentTarget()
	{
		switch (targetSet)
		{
		case 0:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(0);
			break;
		case 1:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(0);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(1);
			break;
		case 2:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(2);
			break;
		case 3:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(1);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(3);
			break;
		case 4:
			SwitchTargets[0].SetActive<OVRLipSyncContextMorphTarget>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextMorphTarget>(4);
			break;
		case 5:
			SwitchTargets[0].SetActive<OVRLipSyncContextTextureFlip>(2);
			SwitchTargets[1].SetActive<OVRLipSyncContextTextureFlip>(5);
			break;
		}
		OVRLipSyncDebugConsole.Clear();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.Left:
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = maxTarget - 1;
			}
			SetCurrentTarget();
			break;
		case OVRTouchpad.TouchEvent.Right:
			targetSet++;
			if (targetSet >= maxTarget)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
			break;
		}
	}
}
public class OVRLipSyncDebugConsole : MonoBehaviour
{
	public ArrayList messages = new ArrayList();

	public int maxMessages = 15;

	public Text textMsg;

	private static OVRLipSyncDebugConsole s_Instance;

	private bool clearTimeoutOn;

	private float clearTimeout;

	public static OVRLipSyncDebugConsole instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				if (s_Instance == null)
				{
					GameObject obj = new GameObject();
					obj.AddComponent<OVRLipSyncDebugConsole>();
					obj.name = "OVRLipSyncDebugConsole";
					s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				}
			}
			return s_Instance;
		}
	}

	private void Awake()
	{
		s_Instance = this;
		Init();
	}

	private void Update()
	{
		if (clearTimeoutOn)
		{
			clearTimeout -= Time.deltaTime;
			if (clearTimeout < 0f)
			{
				Clear();
				clearTimeout = 0f;
				clearTimeoutOn = false;
			}
		}
	}

	public void Init()
	{
		if (textMsg == null)
		{
			UnityEngine.Debug.LogWarning("DebugConsole Init WARNING::UI text not set. Will not be able to display anything.");
		}
		Clear();
	}

	public static void Log(string message)
	{
		instance.AddMessage(message, Color.white);
	}

	public static void Log(string message, Color color)
	{
		instance.AddMessage(message, color);
	}

	public static void Clear()
	{
		instance.ClearMessages();
	}

	public static void ClearTimeout(float timeToClear)
	{
		instance.SetClearTimeout(timeToClear);
	}

	public void AddMessage(string message, Color color)
	{
		messages.Add(message);
		if (textMsg != null)
		{
			textMsg.color = color;
		}
		Display();
	}

	public void ClearMessages()
	{
		messages.Clear();
		Display();
	}

	public void SetClearTimeout(float timeout)
	{
		clearTimeout = timeout;
		clearTimeoutOn = true;
	}

	private void Prune()
	{
		if (messages.Count > maxMessages)
		{
			int count = ((messages.Count > 0) ? (messages.Count - maxMessages) : 0);
			messages.RemoveRange(0, count);
		}
	}

	private void Display()
	{
		if (messages.Count > maxMessages)
		{
			Prune();
		}
		if (textMsg != null)
		{
			textMsg.text = "";
			for (int i = 0; i < messages.Count; i++)
			{
				textMsg.text += (string)messages[i];
				textMsg.text += "\n";
			}
		}
	}
}
public class OVRNamedArrayAttribute : PropertyAttribute
{
	public readonly string[] names;

	public OVRNamedArrayAttribute(string[] names)
	{
		this.names = names;
	}
}
public static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		DoubleTap,
		Left,
		Right,
		Up,
		Down
	}

	public delegate void OVRTouchpadCallback<TouchEvent>(TouchEvent arg);

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	public static Delegate touchPadCallbacks = null;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if ((object)touchPadCallbacks == null)
		{
			return;
		}
		OVRTouchpadCallback<TouchEvent> oVRTouchpadCallback = touchPadCallbacks as OVRTouchpadCallback<TouchEvent>;
		if (move.magnitude < minMovMagnitudeMouse)
		{
			oVRTouchpadCallback(TouchEvent.SingleTap);
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				oVRTouchpadCallback(TouchEvent.Left);
			}
			else
			{
				oVRTouchpadCallback(TouchEvent.Right);
			}
		}
		else if (move.y > 0f)
		{
			oVRTouchpadCallback(TouchEvent.Down);
		}
		else
		{
			oVRTouchpadCallback(TouchEvent.Up);
		}
	}

	public static void AddListener(OVRTouchpadCallback<TouchEvent> handler)
	{
		touchPadCallbacks = (OVRTouchpadCallback<TouchEvent>)Delegate.Combine((OVRTouchpadCallback<TouchEvent>)touchPadCallbacks, handler);
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRTouchpad.AddListener(LocalTouchEventCallback);
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		}
	}
}
public class OVRLipSync : MonoBehaviour
{
	public enum Result
	{
		Success = 0,
		Unknown = -2200,
		CannotCreateContext = -2201,
		InvalidParam = -2202,
		BadSampleRate = -2203,
		MissingDLL = -2204,
		BadVersion = -2205,
		UndefinedFunction = -2206
	}

	public enum AudioDataType
	{
		S16_Mono,
		S16_Stereo,
		F32_Mono,
		F32_Stereo
	}

	public enum Viseme
	{
		sil,
		PP,
		FF,
		TH,
		DD,
		kk,
		CH,
		SS,
		nn,
		RR,
		aa,
		E,
		ih,
		oh,
		ou
	}

	public enum Signals
	{
		VisemeOn,
		VisemeOff,
		VisemeAmount,
		VisemeSmoothing,
		LaughterAmount
	}

	public enum ContextProviders
	{
		Original,
		Enhanced,
		Enhanced_with_Laughter
	}

	[Serializable]
	public class Frame
	{
		public int frameNumber;

		public int frameDelay;

		public float[] Visemes = new float[VisemeCount];

		public float laughterScore;

		public void CopyInput(Frame input)
		{
			frameNumber = input.frameNumber;
			frameDelay = input.frameDelay;
			input.Visemes.CopyTo(Visemes, 0);
			laughterScore = input.laughterScore;
		}

		public void Reset()
		{
			frameNumber = 0;
			frameDelay = 0;
			Array.Clear(Visemes, 0, VisemeCount);
			laughterScore = 0f;
		}
	}

	public static readonly int VisemeCount = Enum.GetNames(typeof(Viseme)).Length;

	public static readonly int SignalCount = Enum.GetNames(typeof(Signals)).Length;

	public const string strOVRLS = "OVRLipSync";

	private static Result sInitialized = Result.Unknown;

	public static OVRLipSync sInstance = null;

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_Initialize(int samplerate, int buffersize);

	[DllImport("OVRLipSync")]
	private static extern void ovrLipSyncDll_Shutdown();

	[DllImport("OVRLipSync")]
	private static extern IntPtr ovrLipSyncDll_GetVersion(ref int Major, ref int Minor, ref int Patch);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextEx(ref uint context, ContextProviders provider, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate, bool enableAcceleration);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_DestroyContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ResetContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_SendSignal(uint context, Signals signal, int arg1, int arg2);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrameEx(uint context, IntPtr audioBuffer, uint bufferSize, AudioDataType dataType, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount, ref float laughterScore, float[] laughterCategories, int laughterCategoriesLength);

	private void Awake()
	{
		if (sInstance == null)
		{
			sInstance = this;
			if (IsInitialized() != 0)
			{
				sInitialized = Initialize();
				if (sInitialized != 0)
				{
					UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Failed to init Speech Rec library");
				}
			}
			OVRTouchpad.Create();
		}
		else
		{
			UnityEngine.Debug.LogWarning($"OVRLipSync Awake: Only one instance of OVRPLipSync can exist in the scene.");
		}
	}

	private void OnDestroy()
	{
		if (sInstance != this)
		{
			UnityEngine.Debug.LogWarning("OVRLipSync OnDestroy: This is not the correct OVRLipSync instance.");
		}
	}

	public static Result Initialize()
	{
		int outputSampleRate = AudioSettings.outputSampleRate;
		AudioSettings.GetDSPBufferSize(out var bufferLength, out var _);
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {outputSampleRate:F0} BufferSize: {bufferLength:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(outputSampleRate, bufferLength);
		return sInitialized;
	}

	public static Result Initialize(int sampleRate, int bufferSize)
	{
		UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {sampleRate:F0} BufferSize: {bufferSize:F0}");
		sInitialized = (Result)ovrLipSyncDll_Initialize(sampleRate, bufferSize);
		return sInitialized;
	}

	public static void Shutdown()
	{
		ovrLipSyncDll_Shutdown();
		sInitialized = Result.Unknown;
	}

	public static Result IsInitialized()
	{
		return sInitialized;
	}

	public static Result CreateContext(ref uint context, ContextProviders provider, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextEx(ref context, provider, sampleRate, enableAcceleration);
	}

	public static Result CreateContextWithModelFile(ref uint context, ContextProviders provider, string modelPath, int sampleRate = 0, bool enableAcceleration = false)
	{
		if (IsInitialized() != 0 && Initialize() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContextWithModelFile(ref context, provider, modelPath, sampleRate, enableAcceleration);
	}

	public static Result DestroyContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_DestroyContext(context);
	}

	public static Result ResetContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ResetContext(context);
	}

	public static Result SendSignal(uint context, Signals signal, int arg1, int arg2)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_SendSignal(context, signal, arg1, arg2);
	}

	public static Result ProcessFrame(uint context, float[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.F32_Stereo : AudioDataType.F32_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}

	public static Result ProcessFrame(uint context, short[] audioBuffer, Frame frame, bool stereo = true)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		AudioDataType dataType = (stereo ? AudioDataType.S16_Stereo : AudioDataType.S16_Mono);
		uint bufferSize = (uint)(stereo ? (audioBuffer.Length / 2) : audioBuffer.Length);
		GCHandle gCHandle = GCHandle.Alloc(audioBuffer, GCHandleType.Pinned);
		int result = ovrLipSyncDll_ProcessFrameEx(context, gCHandle.AddrOfPinnedObject(), bufferSize, dataType, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length, ref frame.laughterScore, null, 0);
		gCHandle.Free();
		return (Result)result;
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContext : OVRLipSyncContextBase
{
	[Tooltip("Allow capturing of keyboard input to control operation.")]
	public bool enableKeyboardInput;

	[Tooltip("Register a mouse/touch callback to control loopback and gain (requires script restart).")]
	public bool enableTouchInput;

	[Tooltip("Play input audio back through audio output.")]
	public bool audioLoopback;

	[Tooltip("Key to toggle audio loopback.")]
	public KeyCode loopbackKey = KeyCode.L;

	[Tooltip("Show viseme scores in an OVRLipSyncDebugConsole display.")]
	public bool showVisemes;

	[Tooltip("Key to toggle viseme score display.")]
	public KeyCode debugVisemesKey = KeyCode.D;

	[Tooltip("Skip data from the Audio Source. Use if you intend to pass audio data in manually.")]
	public bool skipAudioSource;

	[Tooltip("Adjust the linear audio gain multiplier before processing lipsync")]
	public float gain = 1f;

	private bool hasDebugConsole;

	public KeyCode debugLaughterKey = KeyCode.H;

	public bool showLaughter;

	public float laughterScore;

	private void Start()
	{
		if (enableTouchInput)
		{
			OVRTouchpad.AddListener(LocalTouchEventCallback);
		}
		OVRLipSyncDebugConsole[] array = UnityEngine.Object.FindObjectsOfType<OVRLipSyncDebugConsole>();
		if (array.Length != 0)
		{
			hasDebugConsole = array[0];
		}
	}

	private void HandleKeyboard()
	{
		if (Input.GetKeyDown(loopbackKey))
		{
			ToggleAudioLoopback();
		}
		else if (Input.GetKeyDown(debugVisemesKey))
		{
			showVisemes = !showVisemes;
			if (showVisemes)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW VISEMES: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showVisemes = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW VISEMES: DISABLED");
			}
		}
		else if (Input.GetKeyDown(debugLaughterKey))
		{
			showLaughter = !showLaughter;
			if (showLaughter)
			{
				if (hasDebugConsole)
				{
					UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: ENABLED");
					return;
				}
				UnityEngine.Debug.LogWarning("Warning: No OVRLipSyncDebugConsole in the scene!");
				showLaughter = false;
			}
			else
			{
				if (hasDebugConsole)
				{
					OVRLipSyncDebugConsole.Clear();
				}
				UnityEngine.Debug.Log("DEBUG SHOW LAUGHTER: DISABLED");
			}
		}
		else if (Input.GetKeyDown(KeyCode.LeftArrow))
		{
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			string text = "LINEAR GAIN: ";
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
		else if (Input.GetKeyDown(KeyCode.RightArrow))
		{
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			string text2 = "LINEAR GAIN: ";
			text2 += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text2);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
		}
	}

	private void Update()
	{
		if (enableKeyboardInput)
		{
			HandleKeyboard();
		}
		laughterScore = base.Frame.laughterScore;
		DebugShowVisemesAndLaughter();
	}

	public void PreprocessAudioSamples(float[] data, int channels)
	{
		for (int i = 0; i < data.Length; i++)
		{
			data[i] *= gain;
		}
	}

	public void PostprocessAudioSamples(float[] data, int channels)
	{
		if (!audioLoopback)
		{
			for (int i = 0; i < data.Length; i++)
			{
				data[i] *= 0f;
			}
		}
	}

	public void ProcessAudioSamplesRaw(float[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamplesRaw(short[] data, int channels)
	{
		lock (this)
		{
			if (base.Context != 0 && OVRLipSync.IsInitialized() == OVRLipSync.Result.Success)
			{
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrame(base.Context, data, frame, channels == 2);
			}
		}
	}

	public void ProcessAudioSamples(float[] data, int channels)
	{
		if (OVRLipSync.IsInitialized() == OVRLipSync.Result.Success && !(audioSource == null))
		{
			PreprocessAudioSamples(data, channels);
			ProcessAudioSamplesRaw(data, channels);
			PostprocessAudioSamples(data, channels);
		}
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		if (!skipAudioSource)
		{
			ProcessAudioSamples(data, channels);
		}
	}

	private void DebugShowVisemesAndLaughter()
	{
		if (!hasDebugConsole)
		{
			return;
		}
		string text = "";
		if (showLaughter)
		{
			text += "Laughter:";
			int num = (int)(50f * base.Frame.laughterScore);
			for (int i = 0; i < num; i++)
			{
				text += "*";
			}
			text += "\n";
		}
		if (showVisemes)
		{
			for (int j = 0; j < base.Frame.Visemes.Length; j++)
			{
				string text2 = text;
				OVRLipSync.Viseme viseme = (OVRLipSync.Viseme)j;
				text = text2 + viseme;
				text += ":";
				int num2 = (int)(50f * base.Frame.Visemes[j]);
				for (int k = 0; k < num2; k++)
				{
					text += "*";
				}
				text += "\n";
			}
		}
		OVRLipSyncDebugConsole.Clear();
		if (text != "")
		{
			OVRLipSyncDebugConsole.Log(text);
		}
	}

	private void ToggleAudioLoopback()
	{
		audioLoopback = !audioLoopback;
		if (hasDebugConsole)
		{
			OVRLipSyncDebugConsole.Clear();
			OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			if (audioLoopback)
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: ENABLED");
			}
			else
			{
				OVRLipSyncDebugConsole.Log("LOOPBACK MODE: DISABLED");
			}
		}
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		string text = "LINEAR GAIN: ";
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.SingleTap:
			ToggleAudioLoopback();
			break;
		case OVRTouchpad.TouchEvent.Up:
			gain += 1f;
			if (gain > 15f)
			{
				gain = 15f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		case OVRTouchpad.TouchEvent.Down:
			gain -= 1f;
			if (gain < 1f)
			{
				gain = 1f;
			}
			text += gain;
			if (hasDebugConsole)
			{
				OVRLipSyncDebugConsole.Clear();
				OVRLipSyncDebugConsole.Log(text);
				OVRLipSyncDebugConsole.ClearTimeout(1.5f);
			}
			break;
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextBase : MonoBehaviour
{
	public AudioSource audioSource;

	[Tooltip("Which lip sync provider to use for viseme computation.")]
	public OVRLipSync.ContextProviders provider = OVRLipSync.ContextProviders.Enhanced;

	[Tooltip("Enable DSP offload on supported Android devices.")]
	public bool enableAcceleration = true;

	private OVRLipSync.Frame frame = new OVRLipSync.Frame();

	private uint context;

	private int _smoothing;

	public int Smoothing
	{
		get
		{
			return _smoothing;
		}
		set
		{
			switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeSmoothing, value, 0))
			{
			case OVRLipSync.Result.InvalidParam:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: A viseme smoothing parameter is invalid, it should be between 1 and 100!");
				break;
			default:
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetSmoothing: An unexpected error occured.");
				break;
			case OVRLipSync.Result.Success:
				break;
			}
			_smoothing = value;
		}
	}

	public uint Context => context;

	protected OVRLipSync.Frame Frame => frame;

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		lock (this)
		{
			if (context == 0 && OVRLipSync.CreateContext(ref context, provider, 0, enableAcceleration) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.Start ERROR: Could not create Phoneme context.");
			}
		}
	}

	private void OnDestroy()
	{
		lock (this)
		{
			if (context != 0 && OVRLipSync.DestroyContext(context) != 0)
			{
				UnityEngine.Debug.LogError("OVRLipSyncContextBase.OnDestroy ERROR: Could not delete Phoneme context.");
			}
		}
	}

	public OVRLipSync.Frame GetCurrentPhonemeFrame()
	{
		return frame;
	}

	public void SetVisemeBlend(int viseme, int amount)
	{
		switch (OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeAmount, viseme, amount))
		{
		case OVRLipSync.Result.InvalidParam:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: Viseme ID is invalid.");
			break;
		default:
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetVisemeBlend: An unexpected error occured.");
			break;
		case OVRLipSync.Result.Success:
			break;
		}
	}

	public void SetLaughterBlend(int amount)
	{
		if (OVRLipSync.SendSignal(context, OVRLipSync.Signals.LaughterAmount, amount, 0) != 0)
		{
			UnityEngine.Debug.LogError("OVRLipSyncContextBase.SetLaughterBlend: An unexpected error occured.");
		}
	}

	public OVRLipSync.Result ResetContext()
	{
		frame.Reset();
		return OVRLipSync.ResetContext(context);
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextCanned : OVRLipSyncContextBase
{
	[Tooltip("Pre-computed viseme sequence asset. Compute from audio in Unity with Tools -> Oculus -> Generate Lip Sync Assets.")]
	public OVRLipSyncSequence currentSequence;

	private void Update()
	{
		if (audioSource.isPlaying && currentSequence != null)
		{
			OVRLipSync.Frame frameAtTime = currentSequence.GetFrameAtTime(audioSource.time);
			base.Frame.CopyInput(frameAtTime);
		}
	}
}
public class OVRLipSyncContextMorphTarget : MonoBehaviour
{
	[Tooltip("Skinned Mesh Rendered target to be driven by Oculus Lipsync")]
	public SkinnedMeshRenderer skinnedMeshRenderer;

	[Tooltip("Blendshape index to trigger for each viseme.")]
	public int[] visemeToBlendTargets = Enumerable.Range(0, OVRLipSync.VisemeCount).ToArray();

	[Tooltip("Enable using the test keys defined below to manually trigger each viseme.")]
	public bool enableVisemeTestKeys;

	[Tooltip("Test keys used to manually trigger an individual viseme - by default the QWERTY row of a US keyboard.")]
	public KeyCode[] visemeTestKeys = new KeyCode[15]
	{
		KeyCode.BackQuote,
		KeyCode.Tab,
		KeyCode.Q,
		KeyCode.W,
		KeyCode.E,
		KeyCode.R,
		KeyCode.T,
		KeyCode.Y,
		KeyCode.U,
		KeyCode.I,
		KeyCode.O,
		KeyCode.P,
		KeyCode.LeftBracket,
		KeyCode.RightBracket,
		KeyCode.Backslash
	};

	[Tooltip("Test key used to manually trigger laughter and visualise the results")]
	public KeyCode laughterKey = KeyCode.CapsLock;

	[Tooltip("Blendshape index to trigger for laughter")]
	public int laughterBlendTarget = OVRLipSync.VisemeCount;

	[Range(0f, 1f)]
	[Tooltip("Laughter probability threshold above which the laughter blendshape will be activated")]
	public float laughterThreshold = 0.5f;

	[Range(0f, 3f)]
	[Tooltip("Laughter animation linear multiplier, the final output will be clamped to 1.0")]
	public float laughterMultiplier = 1.5f;

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme, 100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private void Start()
	{
		if (skinnedMeshRenderer == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: Please set the target Skinned Mesh Renderer to be controlled!");
			return;
		}
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogError("LipSyncContextMorphTarget.Start Error: No OVRLipSyncContext component on this object!");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && skinnedMeshRenderer != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				SetVisemeToMorphTarget(currentPhonemeFrame);
				SetLaughterToMorphTarget(currentPhonemeFrame);
			}
			CheckForKeys();
			if (smoothAmount != lipsyncContext.Smoothing)
			{
				lipsyncContext.Smoothing = smoothAmount;
			}
		}
	}

	private void CheckForKeys()
	{
		if (enableVisemeTestKeys)
		{
			for (int i = 0; i < OVRLipSync.VisemeCount; i++)
			{
				CheckVisemeKey(visemeTestKeys[i], i, 100);
			}
		}
		CheckLaughterKey();
	}

	private void SetVisemeToMorphTarget(OVRLipSync.Frame frame)
	{
		for (int i = 0; i < visemeToBlendTargets.Length; i++)
		{
			if (visemeToBlendTargets[i] != -1)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(visemeToBlendTargets[i], frame.Visemes[i] * 100f);
			}
		}
	}

	private void SetLaughterToMorphTarget(OVRLipSync.Frame frame)
	{
		if (laughterBlendTarget != -1)
		{
			float laughterScore = frame.laughterScore;
			laughterScore = ((laughterScore < laughterThreshold) ? 0f : (laughterScore - laughterThreshold));
			laughterScore = Mathf.Min(laughterScore * laughterMultiplier, 1f);
			laughterScore *= 1f / laughterThreshold;
			skinnedMeshRenderer.SetBlendShapeWeight(laughterBlendTarget, laughterScore * 100f);
		}
	}

	private void CheckVisemeKey(KeyCode key, int viseme, int amount)
	{
		if (Input.GetKeyDown(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], amount);
		}
		if (Input.GetKeyUp(key))
		{
			lipsyncContext.SetVisemeBlend(visemeToBlendTargets[viseme], 0);
		}
	}

	private void CheckLaughterKey()
	{
		if (Input.GetKeyDown(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(100);
		}
		if (Input.GetKeyUp(laughterKey))
		{
			lipsyncContext.SetLaughterBlend(0);
		}
	}
}
public class OVRLipSyncContextTextureFlip : MonoBehaviour
{
	public Material material;

	[Tooltip("The texture used for each viseme.")]
	[OVRNamedArray(new string[]
	{
		"sil", "PP", "FF", "TH", "DD", "kk", "CH", "SS", "nn", "RR",
		"aa", "E", "ih", "oh", "ou"
	})]
	public Texture[] Textures = new Texture[OVRLipSync.VisemeCount];

	[Range(1f, 100f)]
	[Tooltip("Smoothing of 1 will yield only the current predicted viseme,100 will yield an extremely smooth viseme response.")]
	public int smoothAmount = 70;

	private OVRLipSyncContextBase lipsyncContext;

	private OVRLipSync.Frame oldFrame = new OVRLipSync.Frame();

	private void Start()
	{
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: No lip sync context component set to object");
		}
		else
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
		if (material == null)
		{
			UnityEngine.Debug.LogWarning("LipSyncContextTextureFlip.Start WARNING: Lip sync context texture flip has no material target to control!");
		}
	}

	private void Update()
	{
		if (lipsyncContext != null && material != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				if (lipsyncContext.provider == OVRLipSync.ContextProviders.Original)
				{
					for (int i = 0; i < currentPhonemeFrame.Visemes.Length; i++)
					{
						float num = (float)(smoothAmount - 1) / 100f;
						oldFrame.Visemes[i] = oldFrame.Visemes[i] * num + currentPhonemeFrame.Visemes[i] * (1f - num);
					}
				}
				else
				{
					oldFrame.Visemes = currentPhonemeFrame.Visemes;
				}
				SetVisemeToTexture();
			}
		}
		if (smoothAmount != lipsyncContext.Smoothing)
		{
			lipsyncContext.Smoothing = smoothAmount;
		}
	}

	private void SetVisemeToTexture()
	{
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < oldFrame.Visemes.Length; i++)
		{
			if (oldFrame.Visemes[i] > num2)
			{
				num = i;
				num2 = oldFrame.Visemes[i];
			}
		}
		if (num != -1 && num < Textures.Length)
		{
			Texture texture = Textures[num];
			if (texture != null)
			{
				material.SetTexture("_MainTex", texture);
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncMicInput : MonoBehaviour
{
	public enum micActivation
	{
		HoldToSpeak,
		PushToSpeak,
		ConstantSpeak
	}

	[Tooltip("Manual specification of Audio Source - by default will use any attached to the same object.")]
	public AudioSource audioSource;

	[Tooltip("Enable a keypress to toggle the microphone device selection GUI.")]
	public bool enableMicSelectionGUI;

	[Tooltip("Key to toggle the microphone selection GUI if enabled.")]
	public KeyCode micSelectionGUIKey = KeyCode.M;

	[SerializeField]
	[Range(0f, 100f)]
	[Tooltip("Microphone input volume control.")]
	private float micInputVolume = 100f;

	[SerializeField]
	[Tooltip("Requested microphone input frequency")]
	private int micFrequency = 48000;

	[Tooltip("Microphone input control method. Hold To Speak and Push To Speak are driven with the Mic Activation Key.")]
	public micActivation micControl = micActivation.ConstantSpeak;

	[Tooltip("Key used to drive Hold To Speak and Push To Speak methods of microphone input control.")]
	public KeyCode micActivationKey = KeyCode.Space;

	[Tooltip("Will contain the string name of the selected microphone device - read only.")]
	public string selectedDevice;

	private bool micSelected;

	private int minFreq;

	private int maxFreq;

	private bool focused = true;

	private bool initialized;

	public float MicFrequency
	{
		get
		{
			return micFrequency;
		}
		set
		{
			micFrequency = (int)Mathf.Clamp(value, 0f, 96000f);
		}
	}

	private void Awake()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		_ = (bool)audioSource;
	}

	private void Start()
	{
		audioSource.loop = true;
		audioSource.mute = false;
		InitializeMicrophone();
	}

	private void InitializeMicrophone()
	{
		if (!initialized && Microphone.devices.Length != 0)
		{
			selectedDevice = Microphone.devices[0].ToString();
			micSelected = true;
			GetMicCaps();
			initialized = true;
		}
	}

	private void Update()
	{
		if (!focused)
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			return;
		}
		if (!UnityEngine.Application.isPlaying)
		{
			StopMicrophone();
			return;
		}
		if (!initialized)
		{
			InitializeMicrophone();
		}
		audioSource.volume = micInputVolume / 100f;
		if (micControl == micActivation.HoldToSpeak)
		{
			if (Input.GetKey(micActivationKey))
			{
				if (!Microphone.IsRecording(selectedDevice))
				{
					StartMicrophone();
				}
			}
			else if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
		}
		if (micControl == micActivation.PushToSpeak && Input.GetKeyDown(micActivationKey))
		{
			if (Microphone.IsRecording(selectedDevice))
			{
				StopMicrophone();
			}
			else if (!Microphone.IsRecording(selectedDevice))
			{
				StartMicrophone();
			}
		}
		if (micControl == micActivation.ConstantSpeak && !Microphone.IsRecording(selectedDevice))
		{
			StartMicrophone();
		}
		if (enableMicSelectionGUI && Input.GetKeyDown(micSelectionGUIKey))
		{
			micSelected = false;
		}
	}

	private void OnApplicationFocus(bool focus)
	{
		focused = focus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnApplicationPause(bool pauseStatus)
	{
		focused = !pauseStatus;
		if (!focused)
		{
			StopMicrophone();
		}
	}

	private void OnDisable()
	{
		StopMicrophone();
	}

	private void OnGUI()
	{
		MicDeviceGUI(Screen.width / 2 - 150, Screen.height / 2 - 75, 300f, 50f, 10f, -300f);
	}

	public void MicDeviceGUI(float left, float top, float width, float height, float buttonSpaceTop, float buttonSpaceLeft)
	{
		if (Microphone.devices.Length < 1 || !enableMicSelectionGUI || micSelected)
		{
			return;
		}
		for (int i = 0; i < Microphone.devices.Length; i++)
		{
			if (GUI.Button(new Rect(left + (width + buttonSpaceLeft) * (float)i, top + (height + buttonSpaceTop) * (float)i, width, height), Microphone.devices[i].ToString()))
			{
				StopMicrophone();
				selectedDevice = Microphone.devices[i].ToString();
				micSelected = true;
				GetMicCaps();
				StartMicrophone();
			}
		}
	}

	public void GetMicCaps()
	{
		if (micSelected)
		{
			Microphone.GetDeviceCaps(selectedDevice, out minFreq, out maxFreq);
			if (minFreq == 0 && maxFreq == 0)
			{
				UnityEngine.Debug.LogWarning("GetMicCaps warning:: min and max frequencies are 0");
				minFreq = 44100;
				maxFreq = 44100;
			}
			if (micFrequency > maxFreq)
			{
				micFrequency = maxFreq;
			}
		}
	}

	public void StartMicrophone()
	{
		if (micSelected)
		{
			audioSource.clip = Microphone.Start(selectedDevice, loop: true, 1, micFrequency);
			Stopwatch stopwatch = Stopwatch.StartNew();
			while (Microphone.GetPosition(selectedDevice) <= 0 && stopwatch.Elapsed.TotalMilliseconds < 1000.0)
			{
				Thread.Sleep(50);
			}
			if (Microphone.GetPosition(selectedDevice) <= 0)
			{
				throw new Exception("Timeout initializing microphone " + selectedDevice);
			}
			audioSource.Play();
		}
	}

	public void StopMicrophone()
	{
		if (micSelected)
		{
			if (audioSource != null && audioSource.clip != null && audioSource.clip.name == "Microphone")
			{
				audioSource.Stop();
			}
			GetComponent<OVRLipSyncContext>().ResetContext();
			Microphone.End(selectedDevice);
		}
	}

	private float GetAveragedVolume()
	{
		return 0f;
	}
}
[Serializable]
public class OVRLipSyncSequence : ScriptableObject
{
	public List<OVRLipSync.Frame> entries = new List<OVRLipSync.Frame>();

	public float length;

	public OVRLipSync.Frame GetFrameAtTime(float time)
	{
		OVRLipSync.Frame result = null;
		if (time < length && entries.Count > 0)
		{
			float num = time / length;
			result = entries[(int)((float)entries.Count * num)];
		}
		return result;
	}
}
public class DebugUIBuilder : MonoBehaviour
{
	public delegate void OnClick();

	public delegate void OnToggleValueChange(Toggle t);

	public delegate void OnSlider(float f);

	public delegate bool ActiveUpdate();

	public const int DEBUG_PANE_CENTER = 0;

	public const int DEBUG_PANE_RIGHT = 1;

	public const int DEBUG_PANE_LEFT = 2;

	[SerializeField]
	private RectTransform buttonPrefab;

	[SerializeField]
	private RectTransform labelPrefab;

	[SerializeField]
	private RectTransform sliderPrefab;

	[SerializeField]
	private RectTransform dividerPrefab;

	[SerializeField]
	private RectTransform togglePrefab;

	[SerializeField]
	private RectTransform radioPrefab;

	[SerializeField]
	private GameObject uiHelpersToInstantiate;

	[SerializeField]
	private Transform[] targetContentPanels;

	private bool[] reEnable;

	[SerializeField]
	private List<GameObject> toEnable;

	[SerializeField]
	private List<GameObject> toDisable;

	public static DebugUIBuilder instance;

	private const float elementSpacing = 16f;

	private const float marginH = 16f;

	private const float marginV = 16f;

	private Vector2[] insertPositions;

	private List<RectTransform>[] insertedElements;

	private Vector3 menuOffset;

	private OVRCameraRig rig;

	private Dictionary<string, ToggleGroup> radioGroups = new Dictionary<string, ToggleGroup>();

	private LaserPointer lp;

	private LineRenderer lr;

	public LaserPointer.LaserBeamBehavior laserBeamBehavior;

	public void Awake()
	{
		instance = this;
		menuOffset = base.transform.position;
		base.gameObject.SetActive(value: false);
		rig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		for (int i = 0; i < toEnable.Count; i++)
		{
			toEnable[i].SetActive(value: false);
		}
		insertPositions = new Vector2[targetContentPanels.Length];
		for (int j = 0; j < insertPositions.Length; j++)
		{
			insertPositions[j].x = 16f;
			insertPositions[j].y = -16f;
		}
		insertedElements = new List<RectTransform>[targetContentPanels.Length];
		for (int k = 0; k < insertedElements.Length; k++)
		{
			insertedElements[k] = new List<RectTransform>();
		}
		if ((bool)uiHelpersToInstantiate)
		{
			UnityEngine.Object.Instantiate(uiHelpersToInstantiate);
		}
		lp = UnityEngine.Object.FindObjectOfType<LaserPointer>();
		if (!lp)
		{
			UnityEngine.Debug.LogError("Debug UI requires use of a LaserPointer and will not function without it. Add one to your scene, or assign the UIHelpers prefab to the DebugUIBuilder in the inspector.");
			return;
		}
		lp.laserBeamBehavior = laserBeamBehavior;
		if (!toEnable.Contains(lp.gameObject))
		{
			toEnable.Add(lp.gameObject);
		}
		GetComponent<OVRRaycaster>().pointer = lp.gameObject;
		lp.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		Relayout();
		base.gameObject.SetActive(value: true);
		base.transform.position = rig.transform.TransformPoint(menuOffset);
		Vector3 eulerAngles = rig.transform.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		base.transform.eulerAngles = eulerAngles;
		if (reEnable == null || reEnable.Length < toDisable.Count)
		{
			reEnable = new bool[toDisable.Count];
		}
		reEnable.Initialize();
		int count = toDisable.Count;
		for (int i = 0; i < count; i++)
		{
			if ((bool)toDisable[i])
			{
				reEnable[i] = toDisable[i].activeSelf;
				toDisable[i].SetActive(value: false);
			}
		}
		count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: true);
		}
		int num = targetContentPanels.Length;
		for (int k = 0; k < num; k++)
		{
			targetContentPanels[k].gameObject.SetActive(insertedElements[k].Count > 0);
		}
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
		for (int i = 0; i < reEnable.Length; i++)
		{
			if ((bool)toDisable[i] && reEnable[i])
			{
				toDisable[i].SetActive(value: true);
			}
		}
		int count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: false);
		}
	}

	private void Relayout()
	{
		for (int i = 0; i < targetContentPanels.Length; i++)
		{
			RectTransform component = targetContentPanels[i].GetComponent<RectTransform>();
			List<RectTransform> list = insertedElements[i];
			int count = list.Count;
			float x = 16f;
			float num = -16f;
			float num2 = 0f;
			for (int j = 0; j < count; j++)
			{
				RectTransform rectTransform = list[j];
				rectTransform.anchoredPosition = new Vector2(x, num);
				num -= rectTransform.rect.height + 16f;
				num2 = Mathf.Max(rectTransform.rect.width + 32f, num2);
			}
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, num2);
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 0f - num + 16f);
		}
	}

	private void AddRect(RectTransform r, int targetCanvas)
	{
		if (targetCanvas > targetContentPanels.Length)
		{
			UnityEngine.Debug.LogError("Attempted to add debug panel to canvas " + targetCanvas + ", but only " + targetContentPanels.Length + " panels were provided. Fix in the inspector or pass a lower value for target canvas.");
		}
		else
		{
			r.transform.SetParent(targetContentPanels[targetCanvas], worldPositionStays: false);
			insertedElements[targetCanvas].Add(r);
			if (base.gameObject.activeInHierarchy)
			{
				Relayout();
			}
		}
	}

	public RectTransform AddButton(string label, OnClick handler, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(buttonPrefab).GetComponent<RectTransform>();
		component.GetComponentInChildren<Button>().onClick.AddListener(delegate
		{
			handler();
		});
		((Text)component.GetComponentsInChildren(typeof(Text), includeInactive: true)[0]).text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddLabel(string label, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(labelPrefab).GetComponent<RectTransform>();
		component.GetComponent<Text>().text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddSlider(string label, float min, float max, OnSlider onValueChanged, bool wholeNumbersOnly = false, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(sliderPrefab);
		Slider componentInChildren = rectTransform.GetComponentInChildren<Slider>();
		componentInChildren.minValue = min;
		componentInChildren.maxValue = max;
		componentInChildren.onValueChanged.AddListener(delegate(float f)
		{
			onValueChanged(f);
		});
		componentInChildren.wholeNumbers = wholeNumbersOnly;
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddDivider(int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(dividerPrefab);
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, bool defaultValue, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.isOn = defaultValue;
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddRadio(string label, string group, OnToggleValueChange handler, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(radioPrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle tb = rectTransform.GetComponentInChildren<Toggle>();
		if (group == null)
		{
			group = "default";
		}
		ToggleGroup toggleGroup = null;
		bool isOn = false;
		if (!radioGroups.ContainsKey(group))
		{
			toggleGroup = tb.gameObject.AddComponent<ToggleGroup>();
			radioGroups[group] = toggleGroup;
			isOn = true;
		}
		else
		{
			toggleGroup = radioGroups[group];
		}
		tb.group = toggleGroup;
		tb.isOn = isOn;
		tb.onValueChanged.AddListener(delegate
		{
			handler(tb);
		});
		return rectTransform;
	}

	public void ToggleLaserPointer(bool isOn)
	{
		if ((bool)lp)
		{
			if (isOn)
			{
				lp.enabled = true;
			}
			else
			{
				lp.enabled = false;
			}
		}
	}
}
public class HandedInputSelector : MonoBehaviour
{
	private OVRCameraRig m_CameraRig;

	private OVRInputModule m_InputModule;

	private void Start()
	{
		m_CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		m_InputModule = UnityEngine.Object.FindObjectOfType<OVRInputModule>();
	}

	private void Update()
	{
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			SetActiveController(OVRInput.Controller.LTouch);
		}
		else
		{
			SetActiveController(OVRInput.Controller.RTouch);
		}
	}

	private void SetActiveController(OVRInput.Controller c)
	{
		Transform rayTransform = ((c != OVRInput.Controller.LTouch) ? m_CameraRig.rightHandAnchor : m_CameraRig.leftHandAnchor);
		m_InputModule.rayTransform = rayTransform;
	}
}
public class LaserPointer : OVRCursor
{
	public enum LaserBeamBehavior
	{
		On,
		Off,
		OnWhenHitTarget
	}

	public GameObject cursorVisual;

	public float maxLength = 10f;

	private LaserBeamBehavior _laserBeamBehavior;

	private bool m_restoreOnInputAcquired;

	private Vector3 _startPoint;

	private Vector3 _forward;

	private Vector3 _endPoint;

	private bool _hitTarget;

	private LineRenderer lineRenderer;

	public LaserBeamBehavior laserBeamBehavior
	{
		get
		{
			return _laserBeamBehavior;
		}
		set
		{
			_laserBeamBehavior = value;
			if (laserBeamBehavior == LaserBeamBehavior.Off || laserBeamBehavior == LaserBeamBehavior.OnWhenHitTarget)
			{
				lineRenderer.enabled = false;
			}
			else
			{
				lineRenderer.enabled = true;
			}
		}
	}

	private void Awake()
	{
		lineRenderer = GetComponent<LineRenderer>();
	}

	private void Start()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
		OVRManager.InputFocusAcquired += OnInputFocusAcquired;
		OVRManager.InputFocusLost += OnInputFocusLost;
	}

	public override void SetCursorStartDest(Vector3 start, Vector3 dest, Vector3 normal)
	{
		_startPoint = start;
		_endPoint = dest;
		_hitTarget = true;
	}

	public override void SetCursorRay(Transform t)
	{
		_startPoint = t.position;
		_forward = t.forward;
		_hitTarget = false;
	}

	private void LateUpdate()
	{
		lineRenderer.SetPosition(0, _startPoint);
		if (_hitTarget)
		{
			lineRenderer.SetPosition(1, _endPoint);
			UpdateLaserBeam(_startPoint, _endPoint);
			if ((bool)cursorVisual)
			{
				cursorVisual.transform.position = _endPoint;
				cursorVisual.SetActive(value: true);
			}
		}
		else
		{
			UpdateLaserBeam(_startPoint, _startPoint + maxLength * _forward);
			lineRenderer.SetPosition(1, _startPoint + maxLength * _forward);
			if ((bool)cursorVisual)
			{
				cursorVisual.SetActive(value: false);
			}
		}
	}

	private void UpdateLaserBeam(Vector3 start, Vector3 end)
	{
		if (laserBeamBehavior == LaserBeamBehavior.Off)
		{
			return;
		}
		if (laserBeamBehavior == LaserBeamBehavior.On)
		{
			lineRenderer.SetPosition(0, start);
			lineRenderer.SetPosition(1, end);
		}
		else
		{
			if (laserBeamBehavior != LaserBeamBehavior.OnWhenHitTarget)
			{
				return;
			}
			if (_hitTarget)
			{
				if (!lineRenderer.enabled)
				{
					lineRenderer.enabled = true;
					lineRenderer.SetPosition(0, start);
					lineRenderer.SetPosition(1, end);
				}
			}
			else if (lineRenderer.enabled)
			{
				lineRenderer.enabled = false;
			}
		}
	}

	private void OnDisable()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
	}

	public void OnInputFocusLost()
	{
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			m_restoreOnInputAcquired = true;
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnInputFocusAcquired()
	{
		if (m_restoreOnInputAcquired && (bool)base.gameObject)
		{
			m_restoreOnInputAcquired = false;
			base.gameObject.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
		OVRManager.InputFocusLost -= OnInputFocusLost;
	}
}
public class CharacterCameraConstraint : MonoBehaviour
{
	private const float FADE_RAY_LENGTH = 0.25f;

	private const float FADE_OVERLAP_MAXIMUM = 0.1f;

	private const float FADE_AMOUNT_MAXIMUM = 1f;

	[Tooltip("This should be a reference to the OVRCameraRig that is usually a child of the PlayerController.")]
	public OVRCameraRig CameraRig;

	[Tooltip("Collision layers to be used for the purposes of fading out the screen when the HMD is inside world geometry and adjusting the capsule height.")]
	public LayerMask CollideLayers;

	[Tooltip("Offset is added to camera's real world height, effectively treating it as though the player was taller/standing higher.")]
	public float HeightOffset;

	[Tooltip("Minimum height that the character capsule can shrink to.  To disable, set to capsule's height.")]
	public float MinimumHeight;

	[Tooltip("Maximum height that the character capsule can grow to.  To disable, set to capsule's height.")]
	public float MaximumHeight;

	private CapsuleCollider _character;

	private SimpleCapsuleWithStickMovement _simplePlayerController;

	private CharacterCameraConstraint()
	{
	}

	private void Awake()
	{
		_character = GetComponent<CapsuleCollider>();
		_simplePlayerController = GetComponent<SimpleCapsuleWithStickMovement>();
	}

	private void OnEnable()
	{
		_simplePlayerController.CameraUpdated += CameraUpdate;
	}

	private void OnDisable()
	{
		_simplePlayerController.CameraUpdated -= CameraUpdate;
	}

	private void CameraUpdate()
	{
		float result = 0f;
		if (CheckCameraOverlapped())
		{
			OVRScreenFade.instance.SetExplicitFade(1f);
		}
		else if (CheckCameraNearClipping(out result))
		{
			float t = Mathf.InverseLerp(0f, 0.1f, result);
			float explicitFade = Mathf.Lerp(0f, 1f, t);
			OVRScreenFade.instance.SetExplicitFade(explicitFade);
		}
		else
		{
			OVRScreenFade.instance.SetExplicitFade(0f);
		}
		float num = 0.25f;
		float value = CameraRig.centerEyeAnchor.localPosition.y + HeightOffset + num;
		float minimumHeight = MinimumHeight;
		minimumHeight = Mathf.Min(_character.height, minimumHeight);
		float b = MaximumHeight;
		if (Physics.SphereCast(_character.transform.position, _character.radius * 0.2f, Vector3.up, out var hitInfo, MaximumHeight - _character.transform.position.y, CollideLayers, QueryTriggerInteraction.Ignore))
		{
			b = hitInfo.point.y;
		}
		b = Mathf.Max(_character.height, b);
		_character.height = Mathf.Clamp(value, minimumHeight, b);
		float y = HeightOffset - _character.height * 0.5f - num;
		CameraRig.transform.localPosition = new Vector3(0f, y, 0f);
	}

	private bool CheckCameraOverlapped()
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3 position = _character.transform.position;
		float num = Mathf.Max(0f, _character.height * 0.5f - component.nearClipPlane - 0.01f);
		position.y = Mathf.Clamp(CameraRig.centerEyeAnchor.position.y, _character.transform.position.y - num, _character.transform.position.y + num);
		Vector3 vector = CameraRig.centerEyeAnchor.position - position;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		RaycastHit hitInfo;
		return Physics.SphereCast(position, component.nearClipPlane, direction, out hitInfo, magnitude, CollideLayers, QueryTriggerInteraction.Ignore);
	}

	private bool CheckCameraNearClipping(out float result)
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3[] array = new Vector3[4];
		component.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), component.nearClipPlane, Camera.MonoOrStereoscopicEye.Mono, array);
		Vector3 vector = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[0])) * 0.25f;
		Vector3 vector2 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[1])) * 0.25f;
		Vector3 vector3 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[2])) * 0.25f;
		Vector3 vector4 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[3])) * 0.25f;
		Vector3 vector5 = (vector2 + vector4) / 2f;
		bool result2 = false;
		result = 0f;
		Vector3[] array2 = new Vector3[5] { vector, vector2, vector3, vector4, vector5 };
		foreach (Vector3 vector6 in array2)
		{
			if (Physics.Linecast(CameraRig.centerEyeAnchor.position, vector6, out var hitInfo, CollideLayers, QueryTriggerInteraction.Ignore))
			{
				result2 = true;
				result = Mathf.Max(result, Vector3.Distance(hitInfo.point, vector6));
			}
		}
		return result2;
	}
}
public class LocomotionController : MonoBehaviour
{
	public OVRCameraRig CameraRig;

	public CapsuleCollider CharacterController;

	public SimpleCapsuleWithStickMovement PlayerController;

	private void Start()
	{
		if (CameraRig == null)
		{
			CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		}
	}
}
public class LocomotionTeleport : MonoBehaviour
{
	public enum States
	{
		Ready,
		Aim,
		CancelAim,
		PreTeleport,
		CancelTeleport,
		Teleporting,
		PostTeleport
	}

	public enum TeleportIntentions
	{
		None,
		Aim,
		PreTeleport,
		Teleport
	}

	public enum AimCollisionTypes
	{
		Point,
		Sphere,
		Capsule
	}

	public class AimData
	{
		public RaycastHit TargetHitInfo;

		public bool TargetValid;

		public Vector3? Destination;

		public float Radius;

		public List<Vector3> Points { get; private set; }

		public AimData()
		{
			Points = new List<Vector3>();
		}

		public void Reset()
		{
			Points.Clear();
			TargetValid = false;
			Destination = null;
		}
	}

	[Tooltip("Allow linear movement prior to the teleport system being activated.")]
	public bool EnableMovementDuringReady = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableMovementDuringAim = true;

	[Tooltip("Allow linear movement while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableMovementDuringPreTeleport = true;

	[Tooltip("Allow linear movement after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableMovementDuringPostTeleport = true;

	[Tooltip("Allow rotation prior to the teleport system being activated.")]
	public bool EnableRotationDuringReady = true;

	[Tooltip("Allow rotation while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableRotationDuringAim = true;

	[Tooltip("Allow rotation while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableRotationDuringPreTeleport = true;

	[Tooltip("Allow rotation after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableRotationDuringPostTeleport = true;

	[NonSerialized]
	public TeleportAimHandler AimHandler;

	[Tooltip("This prefab will be instantiated as needed and updated to match the current aim target.")]
	public TeleportDestination TeleportDestinationPrefab;

	[Tooltip("TeleportDestinationPrefab will be instantiated into this layer.")]
	public int TeleportDestinationLayer;

	[NonSerialized]
	public TeleportInputHandler InputHandler;

	[NonSerialized]
	public TeleportIntentions CurrentIntention;

	[NonSerialized]
	public bool IsPreTeleportRequested;

	[NonSerialized]
	public bool IsTransitioning;

	[NonSerialized]
	public bool IsPostTeleportRequested;

	private TeleportDestination _teleportDestination;

	[Tooltip("When aiming at possible destinations, the aim collision type determines which shape to use for collision tests.")]
	public AimCollisionTypes AimCollisionType;

	[Tooltip("Use the character collision radius/height/skinwidth for sphere/capsule collision tests.")]
	public bool UseCharacterCollisionData;

	[Tooltip("Radius of the sphere or capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionRadius;

	[Tooltip("Height of the capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionHeight;

	public States CurrentState { get; private set; }

	public Quaternion DestinationRotation => _teleportDestination.OrientationIndicator.rotation;

	public LocomotionController LocomotionController { get; private set; }

	public event Action<bool, Vector3?, Quaternion?, Quaternion?> UpdateTeleportDestination;

	public event Action EnterStateReady;

	public event Action EnterStateAim;

	public event Action<AimData> UpdateAimData;

	public event Action ExitStateAim;

	public event Action EnterStateCancelAim;

	public event Action EnterStatePreTeleport;

	public event Action EnterStateCancelTeleport;

	public event Action EnterStateTeleporting;

	public event Action EnterStatePostTeleport;

	public event Action<Transform, Vector3, Quaternion> Teleported;

	public void EnableMovement(bool ready, bool aim, bool pre, bool post)
	{
		EnableMovementDuringReady = ready;
		EnableMovementDuringAim = aim;
		EnableMovementDuringPreTeleport = pre;
		EnableMovementDuringPostTeleport = post;
	}

	public void EnableRotation(bool ready, bool aim, bool pre, bool post)
	{
		EnableRotationDuringReady = ready;
		EnableRotationDuringAim = aim;
		EnableRotationDuringPreTeleport = pre;
		EnableRotationDuringPostTeleport = post;
	}

	public void OnUpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		if (this.UpdateTeleportDestination != null)
		{
			this.UpdateTeleportDestination(isValidDestination, position, rotation, landingRotation);
		}
	}

	public bool AimCollisionTest(Vector3 start, Vector3 end, LayerMask aimCollisionLayerMask, out RaycastHit hitInfo)
	{
		Vector3 vector = end - start;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		switch (AimCollisionType)
		{
		case AimCollisionTypes.Capsule:
		{
			float num;
			float num2;
			if (UseCharacterCollisionData)
			{
				CapsuleCollider characterController = LocomotionController.CharacterController;
				num = characterController.height;
				num2 = characterController.radius;
			}
			else
			{
				num = AimCollisionHeight;
				num2 = AimCollisionRadius;
			}
			return Physics.CapsuleCast(start + new Vector3(0f, num2, 0f), start + new Vector3(0f, num + num2, 0f), num2, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		case AimCollisionTypes.Point:
			return Physics.Raycast(start, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		case AimCollisionTypes.Sphere:
		{
			float radius = ((!UseCharacterCollisionData) ? AimCollisionRadius : LocomotionController.CharacterController.radius);
			return Physics.SphereCast(start, radius, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		default:
			throw new Exception();
		}
	}

	[Conditional("DEBUG_TELEPORT_STATES")]
	protected void LogState(string msg)
	{
		UnityEngine.Debug.Log(Time.frameCount + ": " + msg);
	}

	protected void CreateNewTeleportDestination()
	{
		TeleportDestinationPrefab.gameObject.SetActive(value: false);
		TeleportDestination teleportDestination = UnityEngine.Object.Instantiate(TeleportDestinationPrefab);
		teleportDestination.LocomotionTeleport = this;
		teleportDestination.gameObject.layer = TeleportDestinationLayer;
		_teleportDestination = teleportDestination;
		_teleportDestination.LocomotionTeleport = this;
	}

	private void DeactivateDestination()
	{
		_teleportDestination.OnDeactivated();
	}

	public void RecycleTeleportDestination(TeleportDestination oldDestination)
	{
		if (oldDestination == _teleportDestination)
		{
			CreateNewTeleportDestination();
		}
		UnityEngine.Object.Destroy(oldDestination.gameObject);
	}

	private void EnableMotion(bool enableLinear, bool enableRotation)
	{
		LocomotionController.PlayerController.EnableLinearMovement = enableLinear;
		LocomotionController.PlayerController.EnableRotation = enableRotation;
	}

	private void Awake()
	{
		LocomotionController = GetComponent<LocomotionController>();
		CreateNewTeleportDestination();
	}

	public virtual void OnEnable()
	{
		CurrentState = States.Ready;
		StartCoroutine(ReadyStateCoroutine());
	}

	public virtual void OnDisable()
	{
		StopAllCoroutines();
	}

	protected IEnumerator ReadyStateCoroutine()
	{
		yield return null;
		CurrentState = States.Ready;
		EnableMotion(EnableMovementDuringReady, EnableRotationDuringReady);
		if (this.EnterStateReady != null)
		{
			this.EnterStateReady();
		}
		while (CurrentIntention != TeleportIntentions.Aim)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(AimStateCoroutine());
	}

	public void OnUpdateAimData(AimData aimData)
	{
		if (this.UpdateAimData != null)
		{
			this.UpdateAimData(aimData);
		}
	}

	protected IEnumerator AimStateCoroutine()
	{
		CurrentState = States.Aim;
		EnableMotion(EnableMovementDuringAim, EnableRotationDuringAim);
		if (this.EnterStateAim != null)
		{
			this.EnterStateAim();
		}
		_teleportDestination.gameObject.SetActive(value: true);
		while (CurrentIntention == TeleportIntentions.Aim)
		{
			yield return null;
		}
		if (this.ExitStateAim != null)
		{
			this.ExitStateAim();
		}
		yield return null;
		if ((CurrentIntention == TeleportIntentions.PreTeleport || CurrentIntention == TeleportIntentions.Teleport) && _teleportDestination.IsValidDestination)
		{
			StartCoroutine(PreTeleportStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelAimStateCoroutine());
		}
	}

	protected IEnumerator CancelAimStateCoroutine()
	{
		CurrentState = States.CancelAim;
		if (this.EnterStateCancelAim != null)
		{
			this.EnterStateCancelAim();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator PreTeleportStateCoroutine()
	{
		CurrentState = States.PreTeleport;
		EnableMotion(EnableMovementDuringPreTeleport, EnableRotationDuringPreTeleport);
		if (this.EnterStatePreTeleport != null)
		{
			this.EnterStatePreTeleport();
		}
		while (CurrentIntention == TeleportIntentions.PreTeleport || IsPreTeleportRequested)
		{
			yield return null;
		}
		if (_teleportDestination.IsValidDestination)
		{
			StartCoroutine(TeleportingStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelTeleportStateCoroutine());
		}
	}

	protected IEnumerator CancelTeleportStateCoroutine()
	{
		CurrentState = States.CancelTeleport;
		if (this.EnterStateCancelTeleport != null)
		{
			this.EnterStateCancelTeleport();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator TeleportingStateCoroutine()
	{
		CurrentState = States.Teleporting;
		EnableMotion(enableLinear: false, enableRotation: false);
		if (this.EnterStateTeleporting != null)
		{
			this.EnterStateTeleporting();
		}
		while (IsTransitioning)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(PostTeleportStateCoroutine());
	}

	protected IEnumerator PostTeleportStateCoroutine()
	{
		CurrentState = States.PostTeleport;
		EnableMotion(EnableMovementDuringPostTeleport, EnableRotationDuringPostTeleport);
		if (this.EnterStatePostTeleport != null)
		{
			this.EnterStatePostTeleport();
		}
		while (IsPostTeleportRequested)
		{
			yield return null;
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	public void DoTeleport()
	{
		CapsuleCollider characterController = LocomotionController.CharacterController;
		Transform transform = characterController.transform;
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += characterController.height * 0.5f;
		Quaternion landingRotation = _teleportDestination.LandingRotation;
		if (this.Teleported != null)
		{
			this.Teleported(transform, position, landingRotation);
		}
		transform.position = position;
		transform.rotation = landingRotation;
	}

	public Vector3 GetCharacterPosition()
	{
		return LocomotionController.CharacterController.transform.position;
	}

	public Quaternion GetHeadRotationY()
	{
		Quaternion value = Quaternion.identity;
		InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.Head);
		if (deviceAtXRNode.isValid)
		{
			deviceAtXRNode.TryGetFeatureValue(CommonUsages.deviceRotation, out value);
		}
		Vector3 eulerAngles = value.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		return Quaternion.Euler(eulerAngles);
	}

	public void DoWarp(Vector3 startPos, float positionPercent)
	{
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += LocomotionController.CharacterController.height / 2f;
		Transform obj = LocomotionController.CharacterController.transform;
		Vector3 position2 = Vector3.Lerp(startPos, position, positionPercent);
		obj.position = position2;
	}
}
public class SimpleCapsuleWithStickMovement : MonoBehaviour
{
	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	public bool HMDRotatesPlayer = true;

	public bool RotationEitherThumbstick;

	public float RotationAngle = 45f;

	public float Speed;

	public OVRCameraRig CameraRig;

	private bool ReadyToSnapTurn;

	private Rigidbody _rigidbody;

	public event Action CameraUpdated;

	public event Action PreCharacterMove;

	private void Awake()
	{
		_rigidbody = GetComponent<Rigidbody>();
		if (CameraRig == null)
		{
			CameraRig = GetComponentInChildren<OVRCameraRig>();
		}
	}

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (this.CameraUpdated != null)
		{
			this.CameraUpdated();
		}
		if (this.PreCharacterMove != null)
		{
			this.PreCharacterMove();
		}
		if (HMDRotatesPlayer)
		{
			RotatePlayerToHMD();
		}
		if (EnableLinearMovement)
		{
			StickMovement();
		}
		if (EnableRotation)
		{
			SnapTurn();
		}
	}

	private void RotatePlayerToHMD()
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		Vector3 position = trackingSpace.position;
		Quaternion rotation = trackingSpace.rotation;
		base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
		trackingSpace.position = position;
		trackingSpace.rotation = rotation;
	}

	private void StickMovement()
	{
		Vector3 eulerAngles = CameraRig.centerEyeAnchor.rotation.eulerAngles;
		eulerAngles.z = (eulerAngles.x = 0f);
		Quaternion quaternion = Quaternion.Euler(eulerAngles);
		Vector3 zero = Vector3.zero;
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
		zero += quaternion * (vector.x * Vector3.right);
		zero += quaternion * (vector.y * Vector3.forward);
		_rigidbody.MovePosition(_rigidbody.position + zero * Speed * Time.fixedDeltaTime);
	}

	private void SnapTurn()
	{
		Vector3 eulerAngles = base.transform.rotation.eulerAngles;
		if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickLeft) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickLeft)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y -= RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickRight) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickRight)))
		{
			if (ReadyToSnapTurn)
			{
				eulerAngles.y += RotationAngle;
				ReadyToSnapTurn = false;
			}
		}
		else
		{
			ReadyToSnapTurn = true;
		}
		base.transform.rotation = Quaternion.Euler(eulerAngles);
	}
}
public abstract class TeleportAimHandler : TeleportSupport
{
	protected override void OnEnable()
	{
		base.OnEnable();
		base.LocomotionTeleport.AimHandler = this;
	}

	protected override void OnDisable()
	{
		if (base.LocomotionTeleport.AimHandler == this)
		{
			base.LocomotionTeleport.AimHandler = null;
		}
		base.OnDisable();
	}

	public abstract void GetPoints(List<Vector3> points);
}
public class TeleportAimHandlerLaser : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range = 100f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		points.Add(aimRay.origin);
		points.Add(aimRay.origin + aimRay.direction * Range);
	}
}
public class TeleportAimHandlerParabolic : TeleportAimHandler
{
	[Tooltip("Maximum range for aiming.")]
	public float Range;

	[Tooltip("The MinimumElevation is relative to the AimPosition.")]
	public float MinimumElevation = -100f;

	[Tooltip("The Gravity is used in conjunction with AimVelocity and the aim direction to simulate a projectile.")]
	public float Gravity = -9.8f;

	[Tooltip("The AimVelocity is the initial speed of the faked projectile.")]
	[Range(0.001f, 50f)]
	public float AimVelocity = 1f;

	[Tooltip("The AimStep is the how much to subdivide the iteration.")]
	[Range(0.001f, 1f)]
	public float AimStep = 1f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		Vector3 origin = aimRay.origin;
		Vector3 vector = aimRay.direction * AimVelocity;
		float num = Range * Range;
		do
		{
			points.Add(origin);
			Vector3 vector2 = vector;
			vector2.y += Gravity * (1f / 90f) * AimStep;
			vector = vector2;
			origin += vector2 * AimStep;
		}
		while (origin.y - aimRay.origin.y > MinimumElevation && (aimRay.origin - origin).sqrMagnitude <= num);
	}
}
public class TeleportAimVisualLaser : TeleportSupport
{
	[Tooltip("This prefab will be instantiated when the aim visual is awakened, and will be set active when the user is aiming, and deactivated when they are done aiming.")]
	public LineRenderer LaserPrefab;

	private readonly Action _enterAimStateAction;

	private readonly Action _exitAimStateAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	private LineRenderer _lineRenderer;

	private Vector3[] _linePoints;

	public TeleportAimVisualLaser()
	{
		_enterAimStateAction = EnterAimState;
		_exitAimStateAction = ExitAimState;
		_updateAimDataAction = UpdateAimData;
	}

	private void EnterAimState()
	{
		_lineRenderer.gameObject.SetActive(value: true);
	}

	private void ExitAimState()
	{
		_lineRenderer.gameObject.SetActive(value: false);
	}

	private void Awake()
	{
		LaserPrefab.gameObject.SetActive(value: false);
		_lineRenderer = UnityEngine.Object.Instantiate(LaserPrefab);
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim += _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateAim -= _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim -= _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
		base.RemoveEventHandlers();
	}

	private void UpdateAimData(LocomotionTeleport.AimData obj)
	{
		_lineRenderer.sharedMaterial.color = (obj.TargetValid ? Color.green : Color.red);
		List<Vector3> points = obj.Points;
		_lineRenderer.positionCount = points.Count;
		for (int i = 0; i < points.Count; i++)
		{
			_lineRenderer.SetPosition(i, points[i]);
		}
	}
}
public class TeleportDestination : MonoBehaviour
{
	[Tooltip("If the target handler provides a target position, this transform will be moved to that position and it's game object enabled. A target position being provided does not mean the position is valid, only that the aim handler found something to test as a destination.")]
	public Transform PositionIndicator;

	[Tooltip("This transform will be rotated to match the rotation of the aiming target. Simple teleport destinations should assign this to the object containing this component. More complex teleport destinations might assign this to a sub-object that is used to indicate the landing orientation independently from the rest of the destination indicator, such as when world space effects are required. This will typically be a child of the PositionIndicator.")]
	public Transform OrientationIndicator;

	[Tooltip("After the player teleports, the character controller will have it's rotation set to this value. It is different from the OrientationIndicator transform.rotation in order to support both head-relative and forward-facing teleport modes (See TeleportOrientationHandlerThumbstick.cs).")]
	public Quaternion LandingRotation;

	[NonSerialized]
	public LocomotionTeleport LocomotionTeleport;

	[NonSerialized]
	public LocomotionTeleport.States TeleportState;

	private readonly Action<bool, Vector3?, Quaternion?, Quaternion?> _updateTeleportDestinationAction;

	private bool _eventsActive;

	public bool IsValidDestination { get; private set; }

	public event Action<TeleportDestination> Deactivated;

	private TeleportDestination()
	{
		_updateTeleportDestinationAction = UpdateTeleportDestination;
	}

	public void OnEnable()
	{
		PositionIndicator.gameObject.SetActive(value: false);
		if (OrientationIndicator != null)
		{
			OrientationIndicator.gameObject.SetActive(value: false);
		}
		LocomotionTeleport.UpdateTeleportDestination += _updateTeleportDestinationAction;
		_eventsActive = true;
	}

	private void TryDisableEventHandlers()
	{
		if (_eventsActive)
		{
			LocomotionTeleport.UpdateTeleportDestination -= _updateTeleportDestinationAction;
			_eventsActive = false;
		}
	}

	public void OnDisable()
	{
		TryDisableEventHandlers();
	}

	public void OnDeactivated()
	{
		if (this.Deactivated != null)
		{
			this.Deactivated(this);
		}
		else
		{
			Recycle();
		}
	}

	public void Recycle()
	{
		LocomotionTeleport.RecycleTeleportDestination(this);
	}

	public virtual void UpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		IsValidDestination = isValidDestination;
		LandingRotation = landingRotation.GetValueOrDefault();
		GameObject gameObject = PositionIndicator.gameObject;
		bool activeInHierarchy = gameObject.activeInHierarchy;
		if (!position.HasValue)
		{
			if (activeInHierarchy)
			{
				gameObject.SetActive(value: false);
			}
			return;
		}
		if (!activeInHierarchy)
		{
			gameObject.SetActive(value: true);
		}
		base.transform.position = position.GetValueOrDefault();
		if (OrientationIndicator == null)
		{
			if (rotation.HasValue)
			{
				base.transform.rotation = rotation.GetValueOrDefault();
			}
			return;
		}
		GameObject gameObject2 = OrientationIndicator.gameObject;
		bool activeInHierarchy2 = gameObject2.activeInHierarchy;
		if (!rotation.HasValue)
		{
			if (activeInHierarchy2)
			{
				gameObject2.SetActive(value: false);
			}
			return;
		}
		OrientationIndicator.rotation = rotation.GetValueOrDefault();
		if (!activeInHierarchy2)
		{
			gameObject2.SetActive(value: true);
		}
	}
}
public abstract class TeleportInputHandler : TeleportSupport
{
	private readonly Action _startReadyAction;

	private readonly Action _startAimAction;

	protected TeleportInputHandler()
	{
		_startReadyAction = delegate
		{
			StartCoroutine(TeleportReadyCoroutine());
		};
		_startAimAction = delegate
		{
			StartCoroutine(TeleportAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.InputHandler = this;
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateReady += _startReadyAction;
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		if (base.LocomotionTeleport.InputHandler == this)
		{
			base.LocomotionTeleport.InputHandler = null;
		}
		base.LocomotionTeleport.EnterStateReady -= _startReadyAction;
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
		base.RemoveEventHandlers();
	}

	private IEnumerator TeleportReadyCoroutine()
	{
		while (GetIntention() != LocomotionTeleport.TeleportIntentions.Aim)
		{
			yield return null;
		}
		base.LocomotionTeleport.CurrentIntention = LocomotionTeleport.TeleportIntentions.Aim;
	}

	private IEnumerator TeleportAimCoroutine()
	{
		LocomotionTeleport.TeleportIntentions intention = GetIntention();
		while (intention == LocomotionTeleport.TeleportIntentions.Aim || intention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			base.LocomotionTeleport.CurrentIntention = intention;
			yield return null;
			intention = GetIntention();
		}
		base.LocomotionTeleport.CurrentIntention = intention;
	}

	public abstract LocomotionTeleport.TeleportIntentions GetIntention();

	public abstract void GetAimData(out Ray aimRay);
}
public class TeleportInputHandlerHMD : TeleportInputHandler
{
	[Tooltip("The button used to begin aiming for a teleport.")]
	public OVRInput.RawButton AimButton;

	[Tooltip("The button used to trigger the teleport after aiming. It can be the same button as the AimButton, however you cannot abort a teleport if it is.")]
	public OVRInput.RawButton TeleportButton;

	[Tooltip("When true, the system will not use the PreTeleport intention which will allow a teleport to occur on a button downpress. When false, the button downpress will trigger the PreTeleport intention and the Teleport intention when the button is released.")]
	public bool FastTeleport;

	public Transform Pointer { get; private set; }

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(TeleportButton))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (OVRInput.GetUp(TeleportButton))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.Get(AimButton))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (AimButton == TeleportButton)
		{
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
		aimRay = new Ray(centerEyeAnchor.position, centerEyeAnchor.forward);
	}
}
public class TeleportInputHandlerTouch : TeleportInputHandlerHMD
{
	public enum InputModes
	{
		CapacitiveButtonForAimAndTeleport,
		SeparateButtonsForAimAndTeleport,
		ThumbstickTeleport,
		ThumbstickTeleportForwardBackOnly
	}

	public enum AimCapTouchButtons
	{
		A,
		B,
		LeftTrigger,
		LeftThumbstick,
		RightTrigger,
		RightThumbstick,
		X,
		Y
	}

	public Transform LeftHand;

	public Transform RightHand;

	[Tooltip("CapacitiveButtonForAimAndTeleport=Activate aiming via cap touch detection, press the same button to teleport.\nSeparateButtonsForAimAndTeleport=Use one button to begin aiming, and another to trigger the teleport.\nThumbstickTeleport=Push a thumbstick to begin aiming, release to teleport.")]
	public InputModes InputMode;

	private readonly OVRInput.RawButton[] _rawButtons = new OVRInput.RawButton[8]
	{
		OVRInput.RawButton.A,
		OVRInput.RawButton.B,
		OVRInput.RawButton.LIndexTrigger,
		OVRInput.RawButton.LThumbstick,
		OVRInput.RawButton.RIndexTrigger,
		OVRInput.RawButton.RThumbstick,
		OVRInput.RawButton.X,
		OVRInput.RawButton.Y
	};

	private readonly OVRInput.RawTouch[] _rawTouch = new OVRInput.RawTouch[8]
	{
		OVRInput.RawTouch.A,
		OVRInput.RawTouch.B,
		OVRInput.RawTouch.LIndexTrigger,
		OVRInput.RawTouch.LThumbstick,
		OVRInput.RawTouch.RIndexTrigger,
		OVRInput.RawTouch.RThumbstick,
		OVRInput.RawTouch.X,
		OVRInput.RawTouch.Y
	};

	[Tooltip("Select the controller to be used for aiming. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller AimingController;

	private OVRInput.Controller InitiatingController;

	[Tooltip("Select the button to use for triggering aim and teleport when InputMode==CapacitiveButtonForAimAndTeleport")]
	public AimCapTouchButtons CapacitiveAimAndTeleportButton;

	[Tooltip("The thumbstick magnitude required to trigger aiming and teleports when InputMode==InputModes.ThumbstickTeleport")]
	public float ThumbstickTeleportThreshold = 0.5f;

	private void Start()
	{
	}

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (InputMode == InputModes.SeparateButtonsForAimAndTeleport)
		{
			return base.GetIntention();
		}
		if (InputMode == InputModes.ThumbstickTeleport || InputMode == InputModes.ThumbstickTeleportForwardBackOnly)
		{
			Vector2 lhs = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 lhs2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			OVRInput.Controller controller = OVRInput.Controller.Touch;
			bool flag = OVRInput.Get(OVRInput.RawTouch.LThumbstick);
			bool flag2 = OVRInput.Get(OVRInput.RawTouch.RThumbstick);
			if (InputMode == InputModes.ThumbstickTeleportForwardBackOnly && base.LocomotionTeleport.CurrentIntention != LocomotionTeleport.TeleportIntentions.Aim)
			{
				num = Mathf.Abs(Vector2.Dot(lhs, Vector2.up));
				num2 = Mathf.Abs(Vector2.Dot(lhs2, Vector2.up));
			}
			else
			{
				num = lhs.magnitude;
				num2 = lhs2.magnitude;
			}
			if (AimingController == OVRInput.Controller.LTouch)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else if (AimingController == OVRInput.Controller.RTouch)
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			else if (num > num2)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			if (!(num3 > ThumbstickTeleportThreshold) && (AimingController != OVRInput.Controller.Touch || !(flag || flag2)) && !(AimingController == OVRInput.Controller.LTouch && flag) && !(AimingController == OVRInput.Controller.RTouch && flag2))
			{
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
				{
					if (!FastTeleport)
					{
						return LocomotionTeleport.TeleportIntentions.PreTeleport;
					}
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
				{
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
			}
			else if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
			{
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			if (num3 > ThumbstickTeleportThreshold)
			{
				InitiatingController = controller;
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			return LocomotionTeleport.TeleportIntentions.None;
		}
		OVRInput.RawButton rawMask = _rawButtons[(int)CapacitiveAimAndTeleportButton];
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(rawMask))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (FastTeleport || OVRInput.GetUp(rawMask))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.GetDown(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && !OVRInput.GetUp(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		OVRInput.Controller controller = AimingController;
		if (controller == OVRInput.Controller.Touch)
		{
			controller = InitiatingController;
		}
		Transform transform = ((controller == OVRInput.Controller.LTouch) ? LeftHand : RightHand);
		aimRay = new Ray(transform.position, transform.forward);
	}
}
public abstract class TeleportOrientationHandler : TeleportSupport
{
	public enum OrientationModes
	{
		HeadRelative,
		ForwardFacing
	}

	private readonly Action _updateOrientationAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	protected LocomotionTeleport.AimData AimData;

	protected TeleportOrientationHandler()
	{
		_updateOrientationAction = delegate
		{
			StartCoroutine(UpdateOrientationCoroutine());
		};
		_updateAimDataAction = UpdateAimData;
	}

	private void UpdateAimData(LocomotionTeleport.AimData aimData)
	{
		AimData = aimData;
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
	}

	private IEnumerator UpdateOrientationCoroutine()
	{
		InitializeTeleportDestination();
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport)
		{
			if (AimData != null)
			{
				UpdateTeleportDestination();
			}
			yield return null;
		}
	}

	protected abstract void InitializeTeleportDestination();

	protected abstract void UpdateTeleportDestination();

	protected Quaternion GetLandingOrientation(OrientationModes mode, Quaternion rotation)
	{
		if (mode != 0)
		{
			return rotation * Quaternion.Euler(0f, 0f - base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.localEulerAngles.y, 0f);
		}
		return rotation;
	}
}
public class TeleportOrientationHandler360 : TeleportOrientationHandler
{
	protected override void InitializeTeleportDestination()
	{
	}

	protected override void UpdateTeleportDestination()
	{
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, null, null);
	}
}
public class TeleportOrientationHandlerHMD : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Should the destination orientation be updated during the aim state in addition to the PreTeleport state?")]
	public bool UpdateOrientationDuringAim;

	[Tooltip("How far from the destination must the HMD be pointing before using it for orientation")]
	public float AimDistanceThreshold;

	[Tooltip("How far from the destination must the HMD be pointing before rejecting the teleport")]
	public float AimDistanceMaxRange;

	private Quaternion _initialRotation;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = Quaternion.identity;
	}

	protected override void UpdateTeleportDestination()
	{
		if (AimData.Destination.HasValue && (UpdateOrientationDuringAim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport))
		{
			Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
			Vector3 valueOrDefault = AimData.Destination.GetValueOrDefault();
			if (new Plane(Vector3.up, valueOrDefault).Raycast(new Ray(centerEyeAnchor.position, centerEyeAnchor.forward), out var enter))
			{
				Vector3 vector = centerEyeAnchor.position + centerEyeAnchor.forward * enter - valueOrDefault;
				vector.y = 0f;
				float magnitude = vector.magnitude;
				if (magnitude > AimDistanceThreshold)
				{
					vector.Normalize();
					Quaternion quaternion = (_initialRotation = Quaternion.LookRotation(new Vector3(vector.x, 0f, vector.z), Vector3.up));
					if (AimDistanceMaxRange > 0f && magnitude > AimDistanceMaxRange)
					{
						AimData.TargetValid = false;
					}
					base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, quaternion, GetLandingOrientation(OrientationMode, quaternion));
					return;
				}
			}
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _initialRotation, GetLandingOrientation(OrientationMode, _initialRotation));
	}
}
public class TeleportOrientationHandlerThumbstick : TeleportOrientationHandler
{
	[Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[Tooltip("Which thumbstick is to be used for adjusting the teleport orientation. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller Thumbstick;

	[Tooltip("The orientation will only change if the thumbstick magnitude is above this value. This will usually be larger than the TeleportInputHandlerTouch.ThumbstickTeleportThreshold.")]
	public float RotateStickThreshold = 0.8f;

	private Quaternion _initialRotation;

	private Quaternion _currentRotation;

	private Vector2 _lastValidDirection;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
		_currentRotation = _initialRotation;
		_lastValidDirection = default(Vector2);
	}

	protected override void UpdateTeleportDestination()
	{
		float num;
		Vector2 lastValidDirection;
		if (Thumbstick == OVRInput.Controller.Touch)
		{
			Vector2 vector = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 vector2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float magnitude = vector.magnitude;
			float magnitude2 = vector2.magnitude;
			if (magnitude > magnitude2)
			{
				num = magnitude;
				lastValidDirection = vector;
			}
			else
			{
				num = magnitude2;
				lastValidDirection = vector2;
			}
		}
		else
		{
			lastValidDirection = ((Thumbstick != OVRInput.Controller.LTouch) ? OVRInput.Get(OVRInput.RawAxis2D.RThumbstick) : OVRInput.Get(OVRInput.RawAxis2D.LThumbstick));
			num = lastValidDirection.magnitude;
		}
		if (!AimData.TargetValid)
		{
			_lastValidDirection = default(Vector2);
		}
		if (num < RotateStickThreshold)
		{
			lastValidDirection = _lastValidDirection;
			num = lastValidDirection.magnitude;
			if (num < RotateStickThreshold)
			{
				_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
				lastValidDirection.x = 0f;
				lastValidDirection.y = 1f;
			}
		}
		else
		{
			_lastValidDirection = lastValidDirection;
		}
		Quaternion rotation = base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.rotation;
		if (num > RotateStickThreshold)
		{
			lastValidDirection /= num;
			Quaternion quaternion = _initialRotation * Quaternion.LookRotation(new Vector3(lastValidDirection.x, 0f, lastValidDirection.y), Vector3.up);
			_currentRotation = rotation * quaternion;
		}
		else
		{
			_currentRotation = rotation * base.LocomotionTeleport.GetHeadRotationY();
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _currentRotation, GetLandingOrientation(OrientationMode, _currentRotation));
	}
}
public class TeleportPoint : MonoBehaviour
{
	public float dimmingSpeed = 1f;

	public float fullIntensity = 1f;

	public float lowIntensity = 0.5f;

	public Transform destTransform;

	private float lastLookAtTime;

	private void Start()
	{
	}

	public Transform GetDestTransform()
	{
		return destTransform;
	}

	private void Update()
	{
		float value = Mathf.SmoothStep(fullIntensity, lowIntensity, (Time.time - lastLookAtTime) * dimmingSpeed);
		GetComponent<MeshRenderer>().material.SetFloat("_Intensity", value);
	}

	public void OnLookAt()
	{
		lastLookAtTime = Time.time;
	}
}
public abstract class TeleportSupport : MonoBehaviour
{
	private bool _eventsActive;

	protected LocomotionTeleport LocomotionTeleport { get; private set; }

	protected virtual void OnEnable()
	{
		LocomotionTeleport = GetComponent<LocomotionTeleport>();
		AddEventHandlers();
	}

	protected virtual void OnDisable()
	{
		RemoveEventHandlers();
		LocomotionTeleport = null;
	}

	[Conditional("DEBUG_TELEPORT_EVENT_HANDLERS")]
	private void LogEventHandler(string msg)
	{
		UnityEngine.Debug.Log("EventHandler: " + GetType().Name + ": " + msg);
	}

	protected virtual void AddEventHandlers()
	{
		_eventsActive = true;
	}

	protected virtual void RemoveEventHandlers()
	{
		_eventsActive = false;
	}
}
public abstract class TeleportTargetHandler : TeleportSupport
{
	[Tooltip("This bitmask controls which game object layers will be included in the targeting collision tests.")]
	public LayerMask AimCollisionLayerMask;

	protected readonly LocomotionTeleport.AimData AimData = new LocomotionTeleport.AimData();

	private readonly Action _startAimAction;

	private readonly List<Vector3> _aimPoints = new List<Vector3>();

	private const float ERROR_MARGIN = 0.1f;

	protected TeleportTargetHandler()
	{
		_startAimAction = delegate
		{
			StartCoroutine(TargetAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
	}

	private IEnumerator TargetAimCoroutine()
	{
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim)
		{
			ResetAimData();
			Vector3 start = base.LocomotionTeleport.transform.position;
			_aimPoints.Clear();
			base.LocomotionTeleport.AimHandler.GetPoints(_aimPoints);
			for (int i = 0; i < _aimPoints.Count; i++)
			{
				Vector3 end = _aimPoints[i];
				AimData.TargetValid = ConsiderTeleport(start, ref end);
				AimData.Points.Add(end);
				if (AimData.TargetValid)
				{
					AimData.Destination = ConsiderDestination(end);
					AimData.TargetValid = AimData.Destination.HasValue;
					break;
				}
				start = _aimPoints[i];
			}
			base.LocomotionTeleport.OnUpdateAimData(AimData);
			yield return null;
		}
	}

	protected virtual void ResetAimData()
	{
		AimData.Reset();
	}

	protected abstract bool ConsiderTeleport(Vector3 start, ref Vector3 end);

	public virtual Vector3? ConsiderDestination(Vector3 location)
	{
		CapsuleCollider characterController = base.LocomotionTeleport.LocomotionController.CharacterController;
		float num = characterController.radius - 0.1f;
		Vector3 vector = location;
		vector.y += num + 0.1f;
		Vector3 end = vector;
		end.y += characterController.height - 0.1f;
		if (Physics.CheckCapsule(vector, end, num, AimCollisionLayerMask, QueryTriggerInteraction.Ignore))
		{
			return null;
		}
		return location;
	}
}
public class TeleportTargetHandlerNavMesh : TeleportTargetHandler
{
	public int NavMeshAreaMask = -1;

	private NavMeshPath _path;

	private void Awake()
	{
		_path = new NavMeshPath();
	}

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}

	public override Vector3? ConsiderDestination(Vector3 location)
	{
		Vector3? result = base.ConsiderDestination(location);
		if (result.HasValue)
		{
			Vector3 characterPosition = base.LocomotionTeleport.GetCharacterPosition();
			Vector3 valueOrDefault = result.GetValueOrDefault();
			NavMesh.CalculatePath(characterPosition, valueOrDefault, NavMeshAreaMask, _path);
			if (_path.status == NavMeshPathStatus.PathComplete)
			{
				return result;
			}
		}
		return null;
	}

	[Conditional("SHOW_PATH_RESULT")]
	private void OnDrawGizmos()
	{
	}
}
public class TeleportTargetHandlerNode : TeleportTargetHandler
{
	[Tooltip("When checking line of sight to the destination, add this value to the vertical offset for targeting collision checks.")]
	public float LOSOffset = 1f;

	[Tooltip("Teleport logic will only work with TeleportPoint components that exist in the layers specified by this mask.")]
	public LayerMask TeleportLayerMask;

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (!base.LocomotionTeleport.AimCollisionTest(start, end, (int)AimCollisionLayerMask | (int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		TeleportPoint component = AimData.TargetHitInfo.collider.gameObject.GetComponent<TeleportPoint>();
		if (component == null)
		{
			return false;
		}
		Vector3 position = component.destTransform.position;
		Vector3 end2 = new Vector3(position.x, position.y + LOSOffset, position.z);
		if (base.LocomotionTeleport.AimCollisionTest(start, end2, (int)AimCollisionLayerMask & ~(int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		end = position;
		return true;
	}
}
public class TeleportTargetHandlerPhysical : TeleportTargetHandler
{
	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}
}
public abstract class TeleportTransition : TeleportSupport
{
	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting += LocomotionTeleportOnEnterStateTeleporting;
		base.AddEventHandlers();
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting -= LocomotionTeleportOnEnterStateTeleporting;
		base.RemoveEventHandlers();
	}

	protected abstract void LocomotionTeleportOnEnterStateTeleporting();
}
public class TeleportTransitionBlink : TeleportTransition
{
	[Tooltip("How long the transition takes. Usually this is greater than Teleport Delay.")]
	[Range(0.01f, 2f)]
	public float TransitionDuration = 0.5f;

	[Tooltip("At what percentage of the elapsed transition time does the teleport occur?")]
	[Range(0f, 1f)]
	public float TeleportDelay = 0.5f;

	[Tooltip("Fade to black over the duration of the transition")]
	public AnimationCurve FadeLevels = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f));

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(BlinkCoroutine());
	}

	protected IEnumerator BlinkCoroutine()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		float elapsedTime = 0f;
		float teleportTime = TransitionDuration * TeleportDelay;
		bool teleported = false;
		while (elapsedTime < TransitionDuration)
		{
			yield return null;
			elapsedTime += Time.deltaTime;
			if (!teleported && elapsedTime >= teleportTime)
			{
				teleported = true;
				base.LocomotionTeleport.DoTeleport();
			}
		}
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public class TeleportTransitionInstant : TeleportTransition
{
	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		base.LocomotionTeleport.DoTeleport();
	}
}
public class TeleportTransitionWarp : TeleportTransition
{
	[Tooltip("How much time the warp transition takes to complete.")]
	[Range(0.01f, 1f)]
	public float TransitionDuration = 0.5f;

	[HideInInspector]
	public AnimationCurve PositionLerp = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(DoWarp());
	}

	private IEnumerator DoWarp()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		Vector3 startPosition = base.LocomotionTeleport.GetCharacterPosition();
		float elapsedTime = 0f;
		while (elapsedTime < TransitionDuration)
		{
			elapsedTime += Time.deltaTime;
			float time = elapsedTime / TransitionDuration;
			float positionPercent = PositionLerp.Evaluate(time);
			base.LocomotionTeleport.DoWarp(startPosition, positionPercent);
			yield return null;
		}
		base.LocomotionTeleport.DoWarp(startPosition, 1f);
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public static class NativeVideoPlayer
{
	public enum PlabackState
	{
		Idle = 1,
		Preparing,
		Buffering,
		Ready,
		Ended
	}

	private static IntPtr? _Activity;

	private static IntPtr? _VideoPlayerClass;

	private static readonly jvalue[] EmptyParams = new jvalue[0];

	private static IntPtr getIsPlayingMethodId;

	private static IntPtr getCurrentPlaybackStateMethodId;

	private static IntPtr getDurationMethodId;

	private static IntPtr getPlaybackPositionMethodId;

	private static IntPtr setPlaybackPositionMethodId;

	private static jvalue[] setPlaybackPositionParams;

	private static IntPtr playVideoMethodId;

	private static jvalue[] playVideoParams;

	private static IntPtr stopMethodId;

	private static IntPtr resumeMethodId;

	private static IntPtr pauseMethodId;

	private static IntPtr setPlaybackSpeedMethodId;

	private static jvalue[] setPlaybackSpeedParams;

	private static IntPtr setLoopingMethodId;

	private static jvalue[] setLoopingParams;

	private static IntPtr setListenerRotationQuaternionMethodId;

	private static jvalue[] setListenerRotationQuaternionParams;

	private static IntPtr VideoPlayerClass
	{
		get
		{
			if (!_VideoPlayerClass.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/oculus/videoplayer/NativeVideoPlayer");
					if (intPtr != IntPtr.Zero)
					{
						_VideoPlayerClass = AndroidJNI.NewGlobalRef(intPtr);
						AndroidJNI.DeleteLocalRef(intPtr);
					}
					else
					{
						UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
						_VideoPlayerClass = IntPtr.Zero;
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
					UnityEngine.Debug.LogException(exception);
					_VideoPlayerClass = IntPtr.Zero;
				}
			}
			return _VideoPlayerClass.GetValueOrDefault();
		}
	}

	private static IntPtr Activity
	{
		get
		{
			if (!_Activity.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/unity3d/player/UnityPlayer");
					IntPtr staticFieldID = AndroidJNI.GetStaticFieldID(intPtr, "currentActivity", "Landroid/app/Activity;");
					IntPtr staticObjectField = AndroidJNI.GetStaticObjectField(intPtr, staticFieldID);
					_Activity = AndroidJNI.NewGlobalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(intPtr);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					_Activity = IntPtr.Zero;
				}
			}
			return _Activity.GetValueOrDefault();
		}
	}

	public static bool IsAvailable => VideoPlayerClass != IntPtr.Zero;

	public static bool IsPlaying
	{
		get
		{
			if (getIsPlayingMethodId == IntPtr.Zero)
			{
				getIsPlayingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getIsPlaying", "()Z");
			}
			return AndroidJNI.CallStaticBooleanMethod(VideoPlayerClass, getIsPlayingMethodId, EmptyParams);
		}
	}

	public static PlabackState CurrentPlaybackState
	{
		get
		{
			if (getCurrentPlaybackStateMethodId == IntPtr.Zero)
			{
				getCurrentPlaybackStateMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getCurrentPlaybackState", "()I");
			}
			return (PlabackState)AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getCurrentPlaybackStateMethodId, EmptyParams);
		}
	}

	public static long Duration
	{
		get
		{
			if (getDurationMethodId == IntPtr.Zero)
			{
				getDurationMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getDuration", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getDurationMethodId, EmptyParams);
		}
	}

	public static long PlaybackPosition
	{
		get
		{
			if (getPlaybackPositionMethodId == IntPtr.Zero)
			{
				getPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getPlaybackPosition", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getPlaybackPositionMethodId, EmptyParams);
		}
		set
		{
			if (setPlaybackPositionMethodId == IntPtr.Zero)
			{
				setPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackPosition", "(J)V");
				setPlaybackPositionParams = new jvalue[1];
			}
			setPlaybackPositionParams[0].j = value;
			AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackPositionMethodId, setPlaybackPositionParams);
		}
	}

	public static void PlayVideo(string path, string drmLicenseUrl, IntPtr surfaceObj)
	{
		if (playVideoMethodId == IntPtr.Zero)
		{
			playVideoMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "playVideo", "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;Landroid/view/Surface;)V");
			playVideoParams = new jvalue[4];
		}
		IntPtr intPtr = AndroidJNI.NewStringUTF(path);
		IntPtr intPtr2 = AndroidJNI.NewStringUTF(drmLicenseUrl);
		playVideoParams[0].l = Activity;
		playVideoParams[1].l = intPtr;
		playVideoParams[2].l = intPtr2;
		playVideoParams[3].l = surfaceObj;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, playVideoMethodId, playVideoParams);
		AndroidJNI.DeleteLocalRef(intPtr);
		AndroidJNI.DeleteLocalRef(intPtr2);
	}

	public static void Stop()
	{
		if (stopMethodId == IntPtr.Zero)
		{
			stopMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "stop", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, stopMethodId, EmptyParams);
	}

	public static void Play()
	{
		if (resumeMethodId == IntPtr.Zero)
		{
			resumeMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "resume", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, resumeMethodId, EmptyParams);
	}

	public static void Pause()
	{
		if (pauseMethodId == IntPtr.Zero)
		{
			pauseMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "pause", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, pauseMethodId, EmptyParams);
	}

	public static void SetPlaybackSpeed(float speed)
	{
		if (setPlaybackSpeedMethodId == IntPtr.Zero)
		{
			setPlaybackSpeedMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackSpeed", "(F)V");
			setPlaybackSpeedParams = new jvalue[1];
		}
		setPlaybackSpeedParams[0].f = speed;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackSpeedMethodId, setPlaybackSpeedParams);
	}

	public static void SetLooping(bool looping)
	{
		if (setLoopingMethodId == IntPtr.Zero)
		{
			setLoopingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setLooping", "(Z)V");
			setLoopingParams = new jvalue[1];
		}
		setLoopingParams[0].z = looping;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setLoopingMethodId, setLoopingParams);
	}

	public static void SetListenerRotation(Quaternion rotation)
	{
		if (setListenerRotationQuaternionMethodId == IntPtr.Zero)
		{
			setListenerRotationQuaternionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setListenerRotationQuaternion", "(FFFF)V");
			setListenerRotationQuaternionParams = new jvalue[4];
		}
		setListenerRotationQuaternionParams[0].f = rotation.x;
		setListenerRotationQuaternionParams[1].f = rotation.y;
		setListenerRotationQuaternionParams[2].f = rotation.z;
		setListenerRotationQuaternionParams[3].f = rotation.w;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setListenerRotationQuaternionMethodId, setListenerRotationQuaternionParams);
	}
}
public class ButtonDownListener : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public event Action onButtonDown;

	public void OnPointerDown(PointerEventData eventData)
	{
		if (this.onButtonDown != null)
		{
			this.onButtonDown();
		}
	}
}
public class MediaPlayerImage : Image
{
	public enum ButtonType
	{
		Play,
		Pause,
		FastForward,
		Rewind,
		SkipForward,
		SkipBack,
		Stop
	}

	[SerializeField]
	private ButtonType m_ButtonType;

	public ButtonType buttonType
	{
		get
		{
			return m_ButtonType;
		}
		set
		{
			if (m_ButtonType != value)
			{
				m_ButtonType = value;
				SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper toFill)
	{
		Rect pixelAdjustedRect = GetPixelAdjustedRect();
		Vector4 vector = new Vector4(pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height);
		Color32 color = this.color;
		toFill.Clear();
		switch (m_ButtonType)
		{
		case ButtonType.Play:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			break;
		case ButtonType.Pause:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.w), color, new Vector2(0.35f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.y), color, new Vector2(0.35f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.y), color, new Vector2(0.65f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.w), color, new Vector2(0.65f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(6, 7, 4);
			break;
		case ButtonType.FastForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.Rewind:
			toFill.AddVert(new Vector3(vector.x, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.SkipForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.4375f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.y), color, new Vector2(0.4375f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.w), color, new Vector2(0.4375f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.875f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.y), color, new Vector2(0.875f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.w), color, new Vector2(0.875f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			toFill.AddTriangle(6, 7, 8);
			toFill.AddTriangle(8, 9, 6);
			break;
		case ButtonType.SkipBack:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.w), color, new Vector2(0.125f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.y), color, new Vector2(0.125f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.125f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.w), color, new Vector2(0.5625f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.y), color, new Vector2(0.5625f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5625f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(7, 8, 9);
			break;
		default:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			break;
		}
	}
}
public class MoviePlayerSample : MonoBehaviour
{
	public enum VideoShape
	{
		_360,
		_180,
		Quad
	}

	public enum VideoStereo
	{
		Mono,
		TopBottom,
		LeftRight,
		BottomTop
	}

	private bool videoPausedBeforeAppPause;

	private VideoPlayer videoPlayer;

	private OVROverlay overlay;

	private Renderer mediaRenderer;

	private RenderTexture copyTexture;

	private Material externalTex2DMaterial;

	public string MovieName;

	public string DrmLicenseUrl;

	public bool LoopVideo;

	public VideoShape Shape;

	public VideoStereo Stereo;

	public bool DisplayMono;

	private VideoShape _LastShape = (VideoShape)(-1);

	private VideoStereo _LastStereo = (VideoStereo)(-1);

	private bool _LastDisplayMono;

	public bool IsPlaying { get; private set; }

	public long Duration { get; private set; }

	public long PlaybackPosition { get; private set; }

	private void Awake()
	{
		UnityEngine.Debug.Log("MovieSample Awake");
		mediaRenderer = GetComponent<Renderer>();
		videoPlayer = GetComponent<VideoPlayer>();
		if (videoPlayer == null)
		{
			videoPlayer = base.gameObject.AddComponent<VideoPlayer>();
		}
		videoPlayer.isLooping = LoopVideo;
		overlay = GetComponent<OVROverlay>();
		if (overlay == null)
		{
			overlay = base.gameObject.AddComponent<OVROverlay>();
		}
		overlay.enabled = false;
		overlay.isExternalSurface = NativeVideoPlayer.IsAvailable;
		overlay.enabled = overlay.currentOverlayShape != OVROverlay.OverlayShape.Equirect || UnityEngine.Application.platform == RuntimePlatform.Android;
	}

	private bool IsLocalVideo(string movieName)
	{
		return !movieName.Contains("://");
	}

	private void UpdateShapeAndStereo()
	{
		if (Shape != _LastShape || Stereo != _LastStereo || DisplayMono != _LastDisplayMono)
		{
			Rect rect = new Rect(0f, 0f, 1f, 1f);
			switch (Shape)
			{
			case VideoShape._360:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				break;
			case VideoShape._180:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				rect = new Rect(0.25f, 0f, 0.5f, 1f);
				break;
			default:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
				break;
			}
			overlay.overrideTextureRectMatrix = true;
			Rect rect2 = new Rect(0f, 0f, 1f, 1f);
			Rect rect3 = new Rect(0f, 0f, 1f, 1f);
			switch (Stereo)
			{
			case VideoStereo.LeftRight:
				rect2 = new Rect(0f, 0f, 0.5f, 1f);
				rect3 = new Rect(0.5f, 0f, 0.5f, 1f);
				break;
			case VideoStereo.TopBottom:
				rect2 = new Rect(0f, 0.5f, 1f, 0.5f);
				rect3 = new Rect(0f, 0f, 1f, 0.5f);
				break;
			case VideoStereo.BottomTop:
				rect2 = new Rect(0f, 0f, 1f, 0.5f);
				rect3 = new Rect(0f, 0.5f, 1f, 0.5f);
				break;
			}
			overlay.invertTextureRects = false;
			overlay.SetSrcDestRects(rect2, DisplayMono ? rect2 : rect3, rect, rect);
			_LastDisplayMono = DisplayMono;
			_LastStereo = Stereo;
			_LastShape = Shape;
		}
	}

	private IEnumerator Start()
	{
		if (mediaRenderer.material == null)
		{
			UnityEngine.Debug.LogError("No material for movie surface");
			yield break;
		}
		yield return new WaitForSeconds(1f);
		if (!string.IsNullOrEmpty(MovieName))
		{
			if (IsLocalVideo(MovieName))
			{
				Play(UnityEngine.Application.streamingAssetsPath + "/" + MovieName, null);
			}
			else
			{
				Play(MovieName, DrmLicenseUrl);
			}
		}
	}

	public void Play(string moviePath, string drmLicencesUrl)
	{
		if (moviePath != string.Empty)
		{
			UnityEngine.Debug.Log("Playing Video: " + moviePath);
			if (overlay.isExternalSurface)
			{
				OVROverlay.ExternalSurfaceObjectCreated externalSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("Playing ExoPlayer with SurfaceObject");
					NativeVideoPlayer.PlayVideo(moviePath, drmLicencesUrl, overlay.externalSurfaceObject);
					NativeVideoPlayer.SetLooping(LoopVideo);
				};
				if (overlay.externalSurfaceObject == IntPtr.Zero)
				{
					overlay.externalSurfaceObjectCreated = externalSurfaceObjectCreated;
				}
				else
				{
					externalSurfaceObjectCreated();
				}
			}
			else
			{
				UnityEngine.Debug.Log("Playing Unity VideoPlayer");
				videoPlayer.url = moviePath;
				videoPlayer.Prepare();
				videoPlayer.Play();
			}
			UnityEngine.Debug.Log("MovieSample Start");
			IsPlaying = true;
		}
		else
		{
			UnityEngine.Debug.LogError("No media file name provided");
		}
	}

	public void Play()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Play();
		}
		else
		{
			videoPlayer.Play();
		}
		IsPlaying = true;
	}

	public void Pause()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Pause();
		}
		else
		{
			videoPlayer.Pause();
		}
		IsPlaying = false;
	}

	public void SeekTo(long position)
	{
		long num = Math.Max(0L, Math.Min(Duration, position));
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.PlaybackPosition = num;
		}
		else
		{
			videoPlayer.time = (double)num / 1000.0;
		}
	}

	private void Update()
	{
		UpdateShapeAndStereo();
		if (!overlay.isExternalSurface)
		{
			Texture texture = ((videoPlayer.texture != null) ? videoPlayer.texture : Texture2D.blackTexture);
			if (overlay.enabled)
			{
				if (overlay.textures[0] != texture)
				{
					overlay.enabled = false;
					overlay.textures[0] = texture;
					overlay.enabled = true;
				}
			}
			else
			{
				mediaRenderer.material.mainTexture = texture;
				mediaRenderer.material.SetVector("_SrcRectLeft", overlay.srcRectLeft.ToVector());
				mediaRenderer.material.SetVector("_SrcRectRight", overlay.srcRectRight.ToVector());
			}
			IsPlaying = videoPlayer.isPlaying;
			PlaybackPosition = (long)(videoPlayer.time * 1000.0);
			Duration = (long)(videoPlayer.length * 1000.0);
		}
		else
		{
			NativeVideoPlayer.SetListenerRotation(Camera.main.transform.rotation);
			IsPlaying = NativeVideoPlayer.IsPlaying;
			PlaybackPosition = NativeVideoPlayer.PlaybackPosition;
			Duration = NativeVideoPlayer.Duration;
			if (IsPlaying && (int)OVRManager.display.displayFrequency != 60)
			{
				OVRManager.display.displayFrequency = 60f;
			}
			else if (!IsPlaying && (int)OVRManager.display.displayFrequency != 72)
			{
				OVRManager.display.displayFrequency = 72f;
			}
		}
	}

	public void SetPlaybackSpeed(float speed)
	{
		speed = Mathf.Max(0f, speed);
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.SetPlaybackSpeed(speed);
		}
		else
		{
			videoPlayer.playbackSpeed = speed;
		}
	}

	public void Stop()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Stop();
		}
		else
		{
			videoPlayer.Stop();
		}
		IsPlaying = false;
	}

	private void OnApplicationPause(bool appWasPaused)
	{
		UnityEngine.Debug.Log("OnApplicationPause: " + appWasPaused);
		if (appWasPaused)
		{
			videoPausedBeforeAppPause = !IsPlaying;
		}
		if (!videoPausedBeforeAppPause)
		{
			if (appWasPaused)
			{
				Pause();
			}
			else
			{
				Play();
			}
		}
	}
}
public class MoviePlayerSampleControls : MonoBehaviour
{
	private enum PlaybackState
	{
		Playing,
		Paused,
		Rewinding,
		FastForwarding
	}

	public MoviePlayerSample Player;

	public OVRInputModule InputModule;

	public OVRGazePointer GazePointer;

	public GameObject LeftHand;

	public GameObject RightHand;

	public Canvas Canvas;

	public ButtonDownListener PlayPause;

	public MediaPlayerImage PlayPauseImage;

	public Slider ProgressBar;

	public ButtonDownListener FastForward;

	public MediaPlayerImage FastForwardImage;

	public ButtonDownListener Rewind;

	public MediaPlayerImage RewindImage;

	public float TimeoutTime = 10f;

	private bool _isVisible;

	private float _lastButtonTime;

	private bool _didSeek;

	private long _seekPreviousPosition;

	private long _rewindStartPosition;

	private float _rewindStartTime;

	private PlaybackState _state;

	private void Start()
	{
		PlayPause.onButtonDown += OnPlayPauseClicked;
		FastForward.onButtonDown += OnFastForwardClicked;
		Rewind.onButtonDown += OnRewindClicked;
		ProgressBar.onValueChanged.AddListener(OnSeekBarMoved);
		PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
		FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
		RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
		SetVisible(visible: false);
	}

	private void OnPlayPauseClicked()
	{
		switch (_state)
		{
		case PlaybackState.Paused:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.FastForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.Rewind;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Playing:
			Player.Pause();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
			_state = PlaybackState.Paused;
			break;
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		}
	}

	private void OnFastForwardClicked()
	{
		switch (_state)
		{
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			Player.SetPlaybackSpeed(2f);
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Playing:
			Player.SetPlaybackSpeed(2f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition + 15000);
			break;
		}
	}

	private void OnRewindClicked()
	{
		switch (_state)
		{
		case PlaybackState.Playing:
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			Player.Pause();
			_rewindStartPosition = Player.PlaybackPosition;
			_rewindStartTime = Time.time;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.Rewinding;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition - 15000);
			break;
		}
	}

	private void OnSeekBarMoved(float value)
	{
		long num = (long)(value * (float)Player.Duration);
		if (Mathf.Abs(num - Player.PlaybackPosition) > 200f)
		{
			Seek(num);
		}
	}

	private void Seek(long pos)
	{
		_didSeek = true;
		_seekPreviousPosition = Player.PlaybackPosition;
		Player.SeekTo(pos);
	}

	private void Update()
	{
		if (OVRInput.Get(OVRInput.Button.One) || OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.Get(OVRInput.Button.SecondaryIndexTrigger))
		{
			_lastButtonTime = Time.time;
			if (!_isVisible)
			{
				SetVisible(visible: true);
			}
		}
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			InputModule.rayTransform = LeftHand.transform;
			GazePointer.rayTransform = LeftHand.transform;
		}
		else
		{
			InputModule.rayTransform = RightHand.transform;
			GazePointer.rayTransform = RightHand.transform;
		}
		if (OVRInput.Get(OVRInput.Button.Back) && _isVisible)
		{
			SetVisible(visible: false);
		}
		if (_state == PlaybackState.Rewinding)
		{
			ProgressBar.value = Mathf.Clamp01(((float)_rewindStartPosition - 1000f * (Time.time - _rewindStartTime)) / (float)Player.Duration);
		}
		if (_isVisible && _state == PlaybackState.Playing && Time.time - _lastButtonTime > TimeoutTime)
		{
			SetVisible(visible: false);
		}
		if (_isVisible && (!_didSeek || Mathf.Abs(_seekPreviousPosition - Player.PlaybackPosition) > 50f))
		{
			_didSeek = false;
			if (Player.Duration > 0)
			{
				ProgressBar.value = (float)((double)Player.PlaybackPosition / (double)Player.Duration);
			}
			else
			{
				ProgressBar.value = 0f;
			}
		}
	}

	private void SetVisible(bool visible)
	{
		Canvas.enabled = visible;
		_isVisible = visible;
		Player.DisplayMono = visible;
		LeftHand.SetActive(visible);
		RightHand.SetActive(visible);
		UnityEngine.Debug.Log("Controls Visible: " + visible);
	}
}
public static class VectorUtil
{
	public static Vector4 ToVector(this Rect rect)
	{
		return new Vector4(rect.x, rect.y, rect.width, rect.height);
	}
}
public class DebugUISample : MonoBehaviour
{
	private bool inMenu;

	private Text sliderText;

	private void Start()
	{
		DebugUIBuilder.instance.AddButton("Button Pressed", LogButtonPressed);
		DebugUIBuilder.instance.AddLabel("Label");
		RectTransform rectTransform = DebugUIBuilder.instance.AddSlider("Slider", 1f, 10f, SliderPressed, wholeNumbersOnly: true);
		Text[] componentsInChildren = rectTransform.GetComponentsInChildren<Text>();
		sliderText = componentsInChildren[1];
		sliderText.text = rectTransform.GetComponentInChildren<Slider>().value.ToString();
		DebugUIBuilder.instance.AddDivider();
		DebugUIBuilder.instance.AddToggle("Toggle", TogglePressed);
		DebugUIBuilder.instance.AddRadio("Radio1", "group", delegate(Toggle t)
		{
			RadioPressed("Radio1", "group", t);
		});
		DebugUIBuilder.instance.AddRadio("Radio2", "group", delegate(Toggle t)
		{
			RadioPressed("Radio2", "group", t);
		});
		DebugUIBuilder.instance.AddLabel("Secondary Tab", 1);
		DebugUIBuilder.instance.AddDivider(1);
		DebugUIBuilder.instance.AddRadio("Side Radio 1", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 1", "group2", t);
		}, 1);
		DebugUIBuilder.instance.AddRadio("Side Radio 2", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 2", "group2", t);
		}, 1);
		DebugUIBuilder.instance.Show();
		inMenu = true;
	}

	public void TogglePressed(Toggle t)
	{
		UnityEngine.Debug.Log("Toggle pressed. Is on? " + t.isOn);
	}

	public void RadioPressed(string radioLabel, string group, Toggle t)
	{
		UnityEngine.Debug.Log("Radio value changed: " + radioLabel + ", from group " + group + ". New value: " + t.isOn);
	}

	public void SliderPressed(float f)
	{
		UnityEngine.Debug.Log("Slider: " + f);
		sliderText.text = f.ToString();
	}

	private void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	private void LogButtonPressed()
	{
		UnityEngine.Debug.Log("Button pressed");
	}
}
public class HandsActiveChecker : MonoBehaviour
{
	[SerializeField]
	private GameObject _notificationPrefab;

	private GameObject _notification;

	private OVRCameraRig _cameraRig;

	private Transform _centerEye;

	private void Awake()
	{
		_notification = UnityEngine.Object.Instantiate(_notificationPrefab);
		StartCoroutine(GetCenterEye());
	}

	private void Update()
	{
		if (OVRPlugin.GetHandTrackingEnabled())
		{
			_notification.SetActive(value: false);
			return;
		}
		_notification.SetActive(value: true);
		if ((bool)_centerEye)
		{
			_notification.transform.position = _centerEye.position + _centerEye.forward * 0.5f;
			_notification.transform.rotation = _centerEye.rotation;
		}
	}

	private IEnumerator GetCenterEye()
	{
		if ((_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>()) != null)
		{
			while (!_centerEye)
			{
				_centerEye = _cameraRig.centerEyeAnchor;
				yield return null;
			}
		}
	}
}
[ExecuteInEditMode]
public class CharacterCapsule : MonoBehaviour
{
	private CharacterController _character;

	private MeshFilter _meshFilter;

	private float _height;

	private float _radius;

	[Range(4f, 32f)]
	public int SubdivisionsU;

	[Range(4f, 32f)]
	public int SubdivisionsV;

	private int _subdivisionU;

	private int _subdivisionV;

	private Vector3[] _vertices;

	private int[] _triangles;

	private void Update()
	{
		if (_character == null)
		{
			_character = GetComponentInParent<CharacterController>();
			if (_character == null)
			{
				return;
			}
		}
		if (_height == _character.height && _radius == _character.radius && _subdivisionU == SubdivisionsU && _subdivisionV == SubdivisionsV)
		{
			return;
		}
		_height = _character.height;
		_radius = _character.radius;
		_subdivisionU = SubdivisionsU;
		_subdivisionV = SubdivisionsV;
		List<Vector3> list = new List<Vector3>();
		Vector3 vector = new Vector3(1f, 0f, 0f);
		Vector3 vector2 = new Vector3(0f, _height / 2f - _radius, 0f);
		Vector3 vector3 = new Vector3(0f, _radius - _height / 2f, 0f);
		list.Add(new Vector3(0f, _height / 2f, 0f));
		for (int num = SubdivisionsU - 1; num >= 0; num--)
		{
			float num2 = (float)num / (float)SubdivisionsU;
			for (int i = 0; i < SubdivisionsV; i++)
			{
				float num3 = (float)i / (float)SubdivisionsV;
				Vector3 item = Quaternion.Euler(0f, num3 * 360f, num2 * 90f) * vector * _radius + vector2;
				list.Add(item);
			}
		}
		for (int j = 0; j < SubdivisionsU; j++)
		{
			float num4 = (float)j / (float)SubdivisionsU;
			for (int k = 0; k < SubdivisionsV; k++)
			{
				float num5 = (float)k / (float)SubdivisionsV;
				Vector3 vector4 = Quaternion.Euler(0f, num5 * 360f + 180f, num4 * 90f) * vector;
				vector4 *= _radius;
				Vector3 item2 = vector3 - vector4;
				list.Add(item2);
			}
		}
		list.Add(new Vector3(0f, (0f - _height) / 2f, 0f));
		List<int> list2 = new List<int>();
		int item3;
		for (int l = 0; l < SubdivisionsV; l++)
		{
			item3 = 0;
			list2.Add(item3);
			list2.Add(l);
			list2.Add(l + 1);
		}
		list2.Add(0);
		list2.Add(SubdivisionsV);
		list2.Add(1);
		int num6;
		for (int m = 0; m < SubdivisionsU - 1; m++)
		{
			num6 = m * SubdivisionsV + 1;
			for (int n = 0; n < SubdivisionsV - 1; n++)
			{
				item3 = num6 + n;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		num6 = (SubdivisionsU - 1) * SubdivisionsV + 1;
		for (int num7 = 0; num7 < SubdivisionsV - 1; num7++)
		{
			item3 = num6 + num7;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
			list2.Add(item3 + 1);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + SubdivisionsV + 1);
		}
		item3 = num6 + SubdivisionsV - 1;
		list2.Add(item3);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1);
		for (int num8 = 0; num8 < SubdivisionsU - 1; num8++)
		{
			num6 = num8 * SubdivisionsV + SubdivisionsU * SubdivisionsV + 1;
			for (int num9 = 0; num9 < SubdivisionsV - 1; num9++)
			{
				item3 = num6 + num9;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		int num10 = list.Count - 1;
		int num11 = num10 - SubdivisionsV;
		for (int num12 = 0; num12 < SubdivisionsV; num12++)
		{
			item3 = 0;
			list2.Add(num10);
			list2.Add(num11 + num12 + 1);
			list2.Add(num11 + num12);
		}
		list2.Add(num10);
		list2.Add(num11);
		list2.Add(num10 - 1);
		_vertices = list.ToArray();
		_triangles = list2.ToArray();
		_meshFilter = base.gameObject.GetComponent<MeshFilter>();
		_meshFilter.mesh = new Mesh();
		_meshFilter.sharedMesh.vertices = _vertices;
		_meshFilter.sharedMesh.triangles = _triangles;
		_meshFilter.sharedMesh.RecalculateNormals();
	}
}
public class LocomotionSampleSupport : MonoBehaviour
{
	private LocomotionController lc;

	private bool inMenu;

	private LocomotionTeleport TeleportController => lc.GetComponent<LocomotionTeleport>();

	public void Start()
	{
		lc = UnityEngine.Object.FindObjectOfType<LocomotionController>();
		DebugUIBuilder.instance.AddButton("Node Teleport w/ A", SetupNodeTeleport);
		DebugUIBuilder.instance.AddButton("Dual-stick teleport", SetupTwoStickTeleport);
		DebugUIBuilder.instance.AddButton("L Strafe R Teleport", SetupLeftStrafeRightTeleport);
		DebugUIBuilder.instance.AddButton("Walk Only", SetupWalkOnly);
		if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
		{
			UnityEngine.Debug.LogError("Need EventSystem");
		}
		SetupTwoStickTeleport();
		Physics.IgnoreLayerCollision(0, 4);
	}

	public void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	[Conditional("DEBUG_LOCOMOTION_PANEL")]
	private static void Log(string msg)
	{
		UnityEngine.Debug.Log(msg);
	}

	public static TActivate ActivateCategory<TCategory, TActivate>(GameObject target) where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		TCategory[] components = target.GetComponents<TCategory>();
		Log(string.Concat("Activate ", typeof(TActivate), " derived from ", typeof(TCategory), "[", components.Length, "]"));
		TActivate result = null;
		foreach (MonoBehaviour monoBehaviour in components)
		{
			bool flag = monoBehaviour.GetType() == typeof(TActivate);
			Log(string.Concat(monoBehaviour.GetType(), " is ", typeof(TActivate), " = ", flag.ToString()));
			if (flag)
			{
				result = (TActivate)monoBehaviour;
			}
			if (monoBehaviour.enabled != flag)
			{
				monoBehaviour.enabled = flag;
			}
		}
		return result;
	}

	protected void ActivateHandlers<TInput, TAim, TTarget, TOrientation, TTransition>() where TInput : TeleportInputHandler where TAim : TeleportAimHandler where TTarget : TeleportTargetHandler where TOrientation : TeleportOrientationHandler where TTransition : TeleportTransition
	{
		ActivateInput<TInput>();
		ActivateAim<TAim>();
		ActivateTarget<TTarget>();
		ActivateOrientation<TOrientation>();
		ActivateTransition<TTransition>();
	}

	protected void ActivateInput<TActivate>() where TActivate : TeleportInputHandler
	{
		ActivateCategory<TeleportInputHandler, TActivate>();
	}

	protected void ActivateAim<TActivate>() where TActivate : TeleportAimHandler
	{
		ActivateCategory<TeleportAimHandler, TActivate>();
	}

	protected void ActivateTarget<TActivate>() where TActivate : TeleportTargetHandler
	{
		ActivateCategory<TeleportTargetHandler, TActivate>();
	}

	protected void ActivateOrientation<TActivate>() where TActivate : TeleportOrientationHandler
	{
		ActivateCategory<TeleportOrientationHandler, TActivate>();
	}

	protected void ActivateTransition<TActivate>() where TActivate : TeleportTransition
	{
		ActivateCategory<TeleportTransition, TActivate>();
	}

	protected TActivate ActivateCategory<TCategory, TActivate>() where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		return ActivateCategory<TCategory, TActivate>(lc.gameObject);
	}

	protected void UpdateToggle(Toggle toggle, bool enabled)
	{
		if (enabled != toggle.isOn)
		{
			toggle.isOn = enabled;
		}
	}

	private void SetupNonCap()
	{
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.SeparateButtonsForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
	}

	private void SetupTeleportDefaults()
	{
		TeleportController.enabled = true;
		lc.PlayerController.RotationEitherThumbstick = false;
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		TeleportController.EnableRotation(ready: false, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.CapacitiveButtonForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
		component.CapacitiveAimAndTeleportButton = TeleportInputHandlerTouch.AimCapTouchButtons.A;
		component.FastTeleport = false;
		TeleportInputHandlerHMD component2 = TeleportController.GetComponent<TeleportInputHandlerHMD>();
		component2.AimButton = OVRInput.RawButton.A;
		component2.TeleportButton = OVRInput.RawButton.A;
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.LTouch;
	}

	protected GameObject AddInstance(GameObject template, string label)
	{
		GameObject obj = UnityEngine.Object.Instantiate(template);
		obj.transform.SetParent(base.transform, worldPositionStays: false);
		obj.name = label;
		return obj;
	}

	private void SetupNodeTeleport()
	{
		SetupTeleportDefaults();
		SetupNonCap();
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerLaser, TeleportTargetHandlerNode, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportInputHandlerTouch>().AimingController = OVRInput.Controller.RTouch;
	}

	private void SetupTwoStickTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.Touch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.Touch;
	}

	private void SetupWalkOnly()
	{
		SetupTeleportDefaults();
		TeleportController.enabled = false;
		lc.PlayerController.EnableLinearMovement = true;
		lc.PlayerController.RotationEitherThumbstick = false;
	}

	private void SetupLeftStrafeRightTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: true, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.RTouch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.RTouch;
	}
}
[RequireComponent(typeof(Canvas))]
public class OVROverlayCanvas : MonoBehaviour
{
	public enum DrawMode
	{
		Opaque,
		OpaqueWithClip,
		TransparentDefaultAlpha,
		TransparentCorrectAlpha
	}

	[SerializeField]
	[HideInInspector]
	private Shader _transparentShader;

	[SerializeField]
	[HideInInspector]
	private Shader _opaqueShader;

	private RectTransform _rectTransform;

	private Canvas _canvas;

	private Camera _camera;

	private OVROverlay _overlay;

	private RenderTexture _renderTexture;

	private MeshRenderer _meshRenderer;

	private Mesh _quad;

	private Material _defaultMat;

	public int MaxTextureSize = 1600;

	public int MinTextureSize = 200;

	public float PixelsPerUnit = 1f;

	public int DrawRate = 1;

	public int DrawFrameOffset;

	public bool Expensive;

	public int Layer;

	public DrawMode Opacity = DrawMode.OpaqueWithClip;

	private bool ScaleViewport = UnityEngine.Application.isMobilePlatform;

	private static readonly Plane[] _FrustumPlanes = new Plane[6];

	public bool overlayEnabled
	{
		get
		{
			if ((bool)_overlay)
			{
				return _overlay.enabled;
			}
			return false;
		}
		set
		{
			if ((bool)_overlay)
			{
				_overlay.enabled = value;
				_defaultMat.color = (value ? Color.black : Color.white);
			}
		}
	}

	private void Start()
	{
		_canvas = GetComponent<Canvas>();
		_rectTransform = _canvas.GetComponent<RectTransform>();
		float width = _rectTransform.rect.width;
		float height = _rectTransform.rect.height;
		float num = ((width >= height) ? 1f : (width / height));
		float num2 = ((height >= width) ? 1f : (height / width));
		int num3 = ((!ScaleViewport) ? 8 : 0);
		int num4 = Mathf.CeilToInt(num * (float)(MaxTextureSize - num3 * 2));
		int num5 = Mathf.CeilToInt(num2 * (float)(MaxTextureSize - num3 * 2));
		int num6 = num4 + num3 * 2;
		int num7 = num5 + num3 * 2;
		float x = width * ((float)num6 / (float)num4);
		float num8 = height * ((float)num7 / (float)num5);
		float num9 = (float)num4 / (float)num6;
		float num10 = (float)num5 / (float)num7;
		Vector2 vector = ((Opacity == DrawMode.Opaque) ? new Vector2(0.005f / _rectTransform.lossyScale.x, 0.005f / _rectTransform.lossyScale.y) : Vector2.zero);
		_renderTexture = new RenderTexture(num6, num7, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
		_renderTexture.useMipMap = !ScaleViewport;
		GameObject gameObject = new GameObject(base.name + " Overlay Camera")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject.transform.SetParent(base.transform, worldPositionStays: false);
		_camera = gameObject.AddComponent<Camera>();
		_camera.stereoTargetEye = StereoTargetEyeMask.None;
		_camera.transform.position = base.transform.position - base.transform.forward;
		_camera.orthographic = true;
		_camera.enabled = false;
		_camera.targetTexture = _renderTexture;
		_camera.cullingMask = 1 << base.gameObject.layer;
		_camera.clearFlags = CameraClearFlags.Color;
		_camera.backgroundColor = Color.clear;
		_camera.orthographicSize = 0.5f * num8 * _rectTransform.localScale.y;
		_camera.nearClipPlane = 0.99f;
		_camera.farClipPlane = 1.01f;
		_quad = new Mesh
		{
			name = base.name + " Overlay Quad",
			hideFlags = HideFlags.HideAndDontSave
		};
		_quad.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f),
			new Vector3(-0.5f, 0.5f),
			new Vector3(0.5f, 0.5f),
			new Vector3(0.5f, -0.5f)
		};
		_quad.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		_quad.triangles = new int[6] { 0, 1, 2, 2, 3, 0 };
		_quad.bounds = new Bounds(Vector3.zero, Vector3.one);
		_quad.UploadMeshData(markNoLongerReadable: true);
		switch (Opacity)
		{
		case DrawMode.Opaque:
			_defaultMat = new Material(_opaqueShader);
			break;
		case DrawMode.OpaqueWithClip:
			_defaultMat = new Material(_opaqueShader);
			_defaultMat.EnableKeyword("WITH_CLIP");
			break;
		case DrawMode.TransparentDefaultAlpha:
			_defaultMat = new Material(_transparentShader);
			_defaultMat.EnableKeyword("ALPHA_SQUARED");
			break;
		case DrawMode.TransparentCorrectAlpha:
			_defaultMat = new Material(_transparentShader);
			break;
		}
		_defaultMat.mainTexture = _renderTexture;
		_defaultMat.color = Color.black;
		_defaultMat.mainTextureOffset = new Vector2(0.5f - 0.5f * num9, 0.5f - 0.5f * num10);
		_defaultMat.mainTextureScale = new Vector2(num9, num10);
		GameObject gameObject2 = new GameObject(base.name + " MeshRenderer")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject2.transform.SetParent(base.transform, worldPositionStays: false);
		gameObject2.AddComponent<MeshFilter>().sharedMesh = _quad;
		_meshRenderer = gameObject2.AddComponent<MeshRenderer>();
		_meshRenderer.sharedMaterial = _defaultMat;
		gameObject2.layer = Layer;
		gameObject2.transform.localScale = new Vector3(width - vector.x, height - vector.y, 1f);
		GameObject gameObject3 = new GameObject(base.name + " Overlay")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject3.transform.SetParent(base.transform, worldPositionStays: false);
		_overlay = gameObject3.AddComponent<OVROverlay>();
		_overlay.isDynamic = true;
		_overlay.noDepthBufferTesting = true;
		_overlay.isAlphaPremultiplied = !UnityEngine.Application.isMobilePlatform;
		_overlay.textures[0] = _renderTexture;
		_overlay.currentOverlayType = OVROverlay.OverlayType.Underlay;
		_overlay.transform.localScale = new Vector3(x, num8, 1f);
		_overlay.useExpensiveSuperSample = Expensive;
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(_defaultMat);
		UnityEngine.Object.Destroy(_quad);
		UnityEngine.Object.Destroy(_renderTexture);
	}

	private void OnEnable()
	{
		if ((bool)_overlay)
		{
			_meshRenderer.enabled = true;
			_overlay.enabled = true;
		}
		if ((bool)_camera)
		{
			_camera.enabled = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)_overlay)
		{
			_overlay.enabled = false;
			_meshRenderer.enabled = false;
		}
		if ((bool)_camera)
		{
			_camera.enabled = false;
		}
	}

	protected virtual bool ShouldRender()
	{
		if (DrawRate > 1 && Time.frameCount % DrawRate != DrawFrameOffset % DrawRate)
		{
			return false;
		}
		if (Camera.main != null)
		{
			for (int i = 0; i < 2; i++)
			{
				Camera.StereoscopicEye eye = (Camera.StereoscopicEye)i;
				GeometryUtility.CalculateFrustumPlanes(Camera.main.GetStereoProjectionMatrix(eye) * Camera.main.GetStereoViewMatrix(eye), _FrustumPlanes);
				if (GeometryUtility.TestPlanesAABB(_FrustumPlanes, _meshRenderer.bounds))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	private void Update()
	{
		if (ShouldRender())
		{
			if (ScaleViewport && Camera.main != null)
			{
				float magnitude = (Camera.main.transform.position - base.transform.position).magnitude;
				float value = Mathf.Ceil(PixelsPerUnit * Mathf.Max(_rectTransform.rect.width * base.transform.lossyScale.x, _rectTransform.rect.height * base.transform.lossyScale.y) / magnitude / 8f * (float)_renderTexture.height) * 8f;
				value = Mathf.Clamp(value, MinTextureSize, _renderTexture.height);
				float num = value - 2f;
				_camera.orthographicSize = 0.5f * _rectTransform.rect.height * _rectTransform.localScale.y * value / num;
				float num2 = _rectTransform.rect.width / _rectTransform.rect.height;
				float num3 = num * num2;
				float num4 = Mathf.Ceil((num3 + 2f) * 0.5f) * 2f / (float)_renderTexture.width;
				float num5 = value / (float)_renderTexture.height;
				float num6 = ((Opacity == DrawMode.Opaque) ? 1.001f : 0f);
				float num7 = (num3 - num6) / (float)_renderTexture.width;
				float num8 = (num - num6) / (float)_renderTexture.height;
				_camera.rect = new Rect((1f - num4) / 2f, (1f - num5) / 2f, num4, num5);
				Rect rect = new Rect(0.5f - 0.5f * num7, 0.5f - 0.5f * num8, num7, num8);
				_defaultMat.mainTextureOffset = rect.min;
				_defaultMat.mainTextureScale = rect.size;
				_overlay.overrideTextureRectMatrix = true;
				rect.y = 1f - rect.height - rect.y;
				Rect rect2 = new Rect(0f, 0f, 1f, 1f);
				_overlay.SetSrcDestRects(rect, rect, rect2, rect2);
			}
			_camera.Render();
		}
	}
}
public class StartMenu : MonoBehaviour
{
	public OVROverlay overlay;

	public OVROverlay text;

	public OVRCameraRig vrRig;

	private void Start()
	{
		DebugUIBuilder.instance.AddLabel("Select Sample Scene");
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			string scenePathByBuildIndex = SceneUtility.GetScenePathByBuildIndex(i);
			int sceneIndex = i;
			DebugUIBuilder.instance.AddButton(Path.GetFileNameWithoutExtension(scenePathByBuildIndex), delegate
			{
				LoadScene(sceneIndex);
			});
		}
		DebugUIBuilder.instance.Show();
	}

	private void LoadScene(int idx)
	{
		DebugUIBuilder.instance.Hide();
		UnityEngine.Debug.Log("Load scene: " + idx);
		SceneManager.LoadScene(idx);
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private AudioSource source;

	private static int numFOAChannels = 4;

	private static int paramVSpeakerMode = 6;

	private static int paramAmbiStat = 7;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	[SerializeField]
	private bool useVirtualSpeakers;

	public bool UseVirtualSpeakers
	{
		get
		{
			return useVirtualSpeakers;
		}
		set
		{
			useVirtualSpeakers = value;
		}
	}

	private void OnEnable()
	{
		source = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (source == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (source.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			source.spatialize = false;
		}
		if (source.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (source.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		if (source == null)
		{
			return;
		}
		if (useVirtualSpeakers)
		{
			source.SetAmbisonicDecoderFloat(paramVSpeakerMode, 1f);
		}
		else
		{
			source.SetAmbisonicDecoderFloat(paramVSpeakerMode, 0f);
		}
		float value = 0f;
		source.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_VSPEAKERMODE,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(10, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = "";

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1] { base.gameObject.AddComponent<ONSPPropagationMaterial>() };
		array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapResolution = terrainData.heightmapResolution;
			int heightmapResolution2 = terrainData.heightmapResolution;
			int num = (heightmapResolution - 1) / terrainDecimation + 1;
			int num2 = (heightmapResolution2 - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance = treeInstances[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
		float[] array3 = new float[totalVertexCount * 3];
		int[] array4 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapResolution3 = terrainData2.heightmapResolution;
			int heightmapResolution4 = terrainData2.heightmapResolution;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapResolution3, heightmapResolution4);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapResolution3 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapResolution4 - 1) * (float)terrainDecimation);
			int num7 = (heightmapResolution3 - 1) / terrainDecimation + 1;
			int num8 = (heightmapResolution4 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array2[groupOffset].faceType = FaceType.TRIANGLES;
			array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && item3.materials.Length != 0)
			{
				item3.materials[0].StartInternal();
				array2[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array2[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array3[num11] = vector.x;
					array3[num11 + 1] = vector.y;
					array3[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array4[indexOffset] = vertexOffset + num12 * num7 + num13;
					array4[indexOffset + 1] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 2] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 4] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 5] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances = terrainData2.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance2 = treeInstances[l];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_2 = 14u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	[MonoPInvokeCallback(typeof(AudioRaycastCallback))]
	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(AudioRaycastCallback callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class OptiTest : MonoBehaviour
{
	public GameObject OB_CUBE_Each;

	public GameObject OB_CUBE_Con;

	private float count = -5f;

	private int time = -700;

	public UnityEngine.XR.Interaction.Toolkit.XRController LeftControlle;

	public UnityEngine.XR.Interaction.Toolkit.XRController RightController;

	private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

	private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

	private void Start()
	{
		OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
		OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
	}

	private void Update()
	{
		if (!(RightController != null))
		{
			_ = RightController.inputDevice;
		}
		if (RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
		{
			OnTriggerR.CurrentData = isPressed;
		}
		if (!(LeftControlle != null))
		{
			_ = LeftControlle.inputDevice;
		}
		if (LeftControlle.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
		{
			OnTriggerL.CurrentData = isPressed2;
		}
		if (Input.GetKeyDown(KeyCode.A))
		{
			UnityEngine.Object.Instantiate(OB_CUBE_Each, new Vector3(0f, 0f, 10f), Quaternion.identity);
		}
		if (Input.GetKeyDown(KeyCode.S))
		{
			UnityEngine.Object.Instantiate(OB_CUBE_Con, new Vector3(0f, 0f, 10f), Quaternion.identity);
		}
	}

	private void OnTriggerL_OnDataChanged(bool obj)
	{
		UnityEngine.Object.Instantiate(OB_CUBE_Each, new Vector3(0f, 0f, 10f), Quaternion.identity);
	}

	private void OnTriggerR_OnDataChanged(bool obj)
	{
		UnityEngine.Object.Instantiate(OB_CUBE_Con, new Vector3(0f, 0f, 10f), Quaternion.identity);
	}
}
public static class AppSettingsExtensions
{
	public static ChatAppSettings GetChatSettings(this AppSettings appSettings)
	{
		return new ChatAppSettings
		{
			AppIdChat = appSettings.AppIdChat,
			AppVersion = appSettings.AppVersion,
			FixedRegion = (appSettings.IsBestRegion ? null : appSettings.FixedRegion),
			NetworkLogging = appSettings.NetworkLogging,
			Protocol = appSettings.Protocol,
			EnableProtocolFallback = appSettings.EnableProtocolFallback,
			Server = (appSettings.IsDefaultNameServer ? null : appSettings.Server),
			Port = (ushort)appSettings.Port
		};
	}
}
public class ChannelSelector : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public string Channel;

	public void SetChannel(string channel)
	{
		Channel = channel;
		GetComponentInChildren<Text>().text = Channel;
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		UnityEngine.Object.FindObjectOfType<ChatGui>().ShowChannel(Channel);
	}
}
[ExecuteInEditMode]
public class ChatAppIdCheckerUI : MonoBehaviour
{
	public Text Description;

	public void Update()
	{
		if (string.IsNullOrEmpty(PhotonNetwork.PhotonServerSettings.AppSettings.AppIdChat))
		{
			if (Description != null)
			{
				Description.text = "<Color=Red>WARNING:</Color>\nPlease setup a Chat AppId in the PhotonServerSettings file.";
			}
		}
		else if (Description != null)
		{
			Description.text = string.Empty;
		}
	}
}
public class ChatGui : MonoBehaviour, IChatClientListener
{
	public string[] ChannelsToJoinOnConnect;

	public string[] FriendsList;

	public int HistoryLengthToFetch;

	private string selectedChannelName;

	public ChatClient chatClient;

	protected internal ChatAppSettings chatAppSettings;

	public GameObject missingAppIdErrorPanel;

	public GameObject ConnectingLabel;

	public RectTransform ChatPanel;

	public GameObject UserIdFormPanel;

	public InputField InputFieldChat;

	public Text CurrentChannelText;

	public Toggle ChannelToggleToInstantiate;

	public GameObject FriendListUiItemtoInstantiate;

	private readonly Dictionary<string, Toggle> channelToggles = new Dictionary<string, Toggle>();

	private readonly Dictionary<string, FriendItem> friendListItemLUT = new Dictionary<string, FriendItem>();

	public bool ShowState = true;

	public GameObject Title;

	public Text StateText;

	public Text UserIdText;

	private static string HelpText = "\n    -- HELP --\nTo subscribe to channel(s) (channelnames are case sensitive) :  \n\t<color=#E07B00>\\subscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\s</color> <color=green><list of channelnames></color>\n\nTo leave channel(s):\n\t<color=#E07B00>\\unsubscribe</color> <color=green><list of channelnames></color>\n\tor\n\t<color=#E07B00>\\u</color> <color=green><list of channelnames></color>\n\nTo switch the active channel\n\t<color=#E07B00>\\join</color> <color=green><channelname></color>\n\tor\n\t<color=#E07B00>\\j</color> <color=green><channelname></color>\n\nTo send a private message: (username are case sensitive)\n\t\\<color=#E07B00>msg</color> <color=green><username></color> <color=green><message></color>\n\nTo change status:\n\t\\<color=#E07B00>state</color> <color=green><stateIndex></color> <color=green><message></color>\n<color=green>0</color> = Offline <color=green>1</color> = Invisible <color=green>2</color> = Online <color=green>3</color> = Away \n<color=green>4</color> = Do not disturb <color=green>5</color> = Looking For Group <color=green>6</color> = Playing\n\nTo clear the current chat tab (private chats get closed):\n\t<color=#E07B00>\\clear</color>";

	public int TestLength = 2048;

	private byte[] testBytes = new byte[2048];

	public string UserName { get; set; }

	public void Start()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		UserIdText.text = "";
		StateText.text = "";
		StateText.gameObject.SetActive(value: true);
		UserIdText.gameObject.SetActive(value: true);
		Title.SetActive(value: true);
		ChatPanel.gameObject.SetActive(value: false);
		ConnectingLabel.SetActive(value: false);
		if (string.IsNullOrEmpty(UserName))
		{
			UserName = "user" + Environment.TickCount % 99;
		}
		chatAppSettings = PhotonNetwork.PhotonServerSettings.AppSettings.GetChatSettings();
		bool flag = !string.IsNullOrEmpty(chatAppSettings.AppIdChat);
		missingAppIdErrorPanel.SetActive(!flag);
		UserIdFormPanel.gameObject.SetActive(flag);
		if (!flag)
		{
			UnityEngine.Debug.LogError("You need to set the chat app ID in the PhotonServerSettings file in order to continue.");
		}
	}

	public void Connect()
	{
		UserIdFormPanel.gameObject.SetActive(value: false);
		chatClient = new ChatClient(this);
		chatClient.UseBackgroundWorkerForSending = true;
		chatClient.AuthValues = new Photon.Chat.AuthenticationValues(UserName);
		chatClient.ConnectUsingSettings(chatAppSettings);
		ChannelToggleToInstantiate.gameObject.SetActive(value: false);
		UnityEngine.Debug.Log("Connecting as: " + UserName);
		ConnectingLabel.SetActive(value: true);
	}

	public void OnDestroy()
	{
		if (chatClient != null)
		{
			chatClient.Disconnect();
		}
	}

	public void OnApplicationQuit()
	{
		if (chatClient != null)
		{
			chatClient.Disconnect();
		}
	}

	public void Update()
	{
		if (chatClient != null)
		{
			chatClient.Service();
		}
		if (StateText == null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		else
		{
			StateText.gameObject.SetActive(ShowState);
		}
	}

	public void OnEnterSend()
	{
		if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
		{
			SendChatMessage(InputFieldChat.text);
			InputFieldChat.text = "";
		}
	}

	public void OnClickSend()
	{
		if (InputFieldChat != null)
		{
			SendChatMessage(InputFieldChat.text);
			InputFieldChat.text = "";
		}
	}

	private void SendChatMessage(string inputLine)
	{
		if (string.IsNullOrEmpty(inputLine))
		{
			return;
		}
		if ("test".Equals(inputLine))
		{
			if (TestLength != testBytes.Length)
			{
				testBytes = new byte[TestLength];
			}
			chatClient.SendPrivateMessage(chatClient.AuthValues.UserId, testBytes, forwardAsWebhook: true);
		}
		bool flag = chatClient.PrivateChannels.ContainsKey(selectedChannelName);
		string target = string.Empty;
		if (flag)
		{
			target = selectedChannelName.Split(':')[1];
		}
		if (inputLine[0].Equals('\\'))
		{
			string[] array = inputLine.Split(new char[1] { ' ' }, 2);
			if (array[0].Equals("\\help"))
			{
				PostHelpToCurrentChannel();
			}
			if (array[0].Equals("\\state"))
			{
				int num = 0;
				List<string> list = new List<string>();
				list.Add("i am state " + num);
				string[] array2 = array[1].Split(' ', ',');
				if (array2.Length != 0)
				{
					num = int.Parse(array2[0]);
				}
				if (array2.Length > 1)
				{
					list.Add(array2[1]);
				}
				chatClient.SetOnlineStatus(num, list.ToArray());
			}
			else if ((array[0].Equals("\\subscribe") || array[0].Equals("\\s")) && !string.IsNullOrEmpty(array[1]))
			{
				chatClient.Subscribe(array[1].Split(' ', ','));
			}
			else if ((array[0].Equals("\\unsubscribe") || array[0].Equals("\\u")) && !string.IsNullOrEmpty(array[1]))
			{
				chatClient.Unsubscribe(array[1].Split(' ', ','));
			}
			else if (array[0].Equals("\\clear"))
			{
				ChatChannel channel;
				if (flag)
				{
					chatClient.PrivateChannels.Remove(selectedChannelName);
				}
				else if (chatClient.TryGetChannel(selectedChannelName, flag, out channel))
				{
					channel.ClearMessages();
				}
			}
			else if (array[0].Equals("\\msg") && !string.IsNullOrEmpty(array[1]))
			{
				string[] array3 = array[1].Split(new char[2] { ' ', ',' }, 2);
				if (array3.Length >= 2)
				{
					string target2 = array3[0];
					string message = array3[1];
					chatClient.SendPrivateMessage(target2, message);
				}
			}
			else if ((array[0].Equals("\\join") || array[0].Equals("\\j")) && !string.IsNullOrEmpty(array[1]))
			{
				string[] array4 = array[1].Split(new char[2] { ' ', ',' }, 2);
				if (channelToggles.ContainsKey(array4[0]))
				{
					ShowChannel(array4[0]);
					return;
				}
				chatClient.Subscribe(new string[1] { array4[0] });
			}
			else
			{
				UnityEngine.Debug.Log("The command '" + array[0] + "' is invalid.");
			}
		}
		else if (flag)
		{
			chatClient.SendPrivateMessage(target, inputLine);
		}
		else
		{
			chatClient.PublishMessage(selectedChannelName, inputLine);
		}
	}

	public void PostHelpToCurrentChannel()
	{
		CurrentChannelText.text += HelpText;
	}

	public void DebugReturn(DebugLevel level, string message)
	{
		switch (level)
		{
		case DebugLevel.ERROR:
			UnityEngine.Debug.LogError(message);
			break;
		case DebugLevel.WARNING:
			UnityEngine.Debug.LogWarning(message);
			break;
		default:
			UnityEngine.Debug.Log(message);
			break;
		}
	}

	public void OnConnected()
	{
		if (ChannelsToJoinOnConnect != null && ChannelsToJoinOnConnect.Length != 0)
		{
			chatClient.Subscribe(ChannelsToJoinOnConnect, HistoryLengthToFetch);
		}
		ConnectingLabel.SetActive(value: false);
		UserIdText.text = "Connected as " + UserName;
		ChatPanel.gameObject.SetActive(value: true);
		if (FriendsList != null && FriendsList.Length != 0)
		{
			chatClient.AddFriends(FriendsList);
			string[] friendsList = FriendsList;
			foreach (string text in friendsList)
			{
				if (FriendListUiItemtoInstantiate != null && text != UserName)
				{
					InstantiateFriendButton(text);
				}
			}
		}
		if (FriendListUiItemtoInstantiate != null)
		{
			FriendListUiItemtoInstantiate.SetActive(value: false);
		}
		chatClient.SetOnlineStatus(2);
	}

	public void OnDisconnected()
	{
		ConnectingLabel.SetActive(value: false);
	}

	public void OnChatStateChange(ChatState state)
	{
		StateText.text = state.ToString();
	}

	public void OnSubscribed(string[] channels, bool[] results)
	{
		foreach (string channelName in channels)
		{
			chatClient.PublishMessage(channelName, "says 'hi'.");
			if (ChannelToggleToInstantiate != null)
			{
				InstantiateChannelButton(channelName);
			}
		}
		UnityEngine.Debug.Log("OnSubscribed: " + string.Join(", ", channels));
		ShowChannel(channels[0]);
	}

	public void OnSubscribed(string channel, string[] users, Dictionary<object, object> properties)
	{
		UnityEngine.Debug.LogFormat("OnSubscribed: {0}, users.Count: {1} Channel-props: {2}.", channel, users.Length, properties.ToStringFull());
	}

	private void InstantiateChannelButton(string channelName)
	{
		if (channelToggles.ContainsKey(channelName))
		{
			UnityEngine.Debug.Log("Skipping creation for an existing channel toggle.");
			return;
		}
		Toggle toggle = UnityEngine.Object.Instantiate(ChannelToggleToInstantiate);
		toggle.gameObject.SetActive(value: true);
		toggle.GetComponentInChildren<ChannelSelector>().SetChannel(channelName);
		toggle.transform.SetParent(ChannelToggleToInstantiate.transform.parent, worldPositionStays: false);
		channelToggles.Add(channelName, toggle);
	}

	private void InstantiateFriendButton(string friendId)
	{
		GameObject obj = UnityEngine.Object.Instantiate(FriendListUiItemtoInstantiate);
		obj.gameObject.SetActive(value: true);
		FriendItem component = obj.GetComponent<FriendItem>();
		component.FriendId = friendId;
		obj.transform.SetParent(FriendListUiItemtoInstantiate.transform.parent, worldPositionStays: false);
		friendListItemLUT[friendId] = component;
	}

	public void OnUnsubscribed(string[] channels)
	{
		foreach (string text in channels)
		{
			if (channelToggles.ContainsKey(text))
			{
				UnityEngine.Object.Destroy(channelToggles[text].gameObject);
				channelToggles.Remove(text);
				UnityEngine.Debug.Log("Unsubscribed from channel '" + text + "'.");
				if (text == selectedChannelName && channelToggles.Count > 0)
				{
					IEnumerator<KeyValuePair<string, Toggle>> enumerator = channelToggles.GetEnumerator();
					enumerator.MoveNext();
					ShowChannel(enumerator.Current.Key);
					enumerator.Current.Value.isOn = true;
				}
			}
			else
			{
				UnityEngine.Debug.Log("Can't unsubscribe from channel '" + text + "' because you are currently not subscribed to it.");
			}
		}
	}

	public void OnGetMessages(string channelName, string[] senders, object[] messages)
	{
		if (channelName.Equals(selectedChannelName))
		{
			ShowChannel(selectedChannelName);
		}
	}

	public void OnPrivateMessage(string sender, object message, string channelName)
	{
		InstantiateChannelButton(channelName);
		if (message is byte[] array)
		{
			UnityEngine.Debug.Log("Message with byte[].Length: " + array.Length);
		}
		if (selectedChannelName.Equals(channelName))
		{
			ShowChannel(channelName);
		}
	}

	public void OnStatusUpdate(string user, int status, bool gotMessage, object message)
	{
		UnityEngine.Debug.LogWarning("status: " + $"{user} is {status}. Msg:{message}");
		if (friendListItemLUT.ContainsKey(user))
		{
			FriendItem friendItem = friendListItemLUT[user];
			if (friendItem != null)
			{
				friendItem.OnFriendStatusUpdate(status, gotMessage, message);
			}
		}
	}

	public void OnUserSubscribed(string channel, string user)
	{
		UnityEngine.Debug.LogFormat("OnUserSubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
	}

	public void OnUserUnsubscribed(string channel, string user)
	{
		UnityEngine.Debug.LogFormat("OnUserUnsubscribed: channel=\"{0}\" userId=\"{1}\"", channel, user);
	}

	public void OnChannelPropertiesChanged(string channel, string userId, Dictionary<object, object> properties)
	{
		UnityEngine.Debug.LogFormat("OnChannelPropertiesChanged: {0} by {1}. Props: {2}.", channel, userId, properties.ToStringFull());
	}

	public void OnUserPropertiesChanged(string channel, string targetUserId, string senderUserId, Dictionary<object, object> properties)
	{
		UnityEngine.Debug.LogFormat("OnUserPropertiesChanged: (channel:{0} user:{1}) by {2}. Props: {3}.", channel, targetUserId, senderUserId, properties.ToStringFull());
	}

	public void OnErrorInfo(string channel, string error, object data)
	{
		UnityEngine.Debug.LogFormat("OnErrorInfo for channel {0}. Error: {1} Data: {2}", channel, error, data);
	}

	public void AddMessageToSelectedChannel(string msg)
	{
		ChatChannel channel = null;
		if (!chatClient.TryGetChannel(selectedChannelName, out channel))
		{
			UnityEngine.Debug.Log("AddMessageToSelectedChannel failed to find channel: " + selectedChannelName);
		}
		else
		{
			channel?.Add("Bot", msg, 0);
		}
	}

	public void ShowChannel(string channelName)
	{
		if (string.IsNullOrEmpty(channelName))
		{
			return;
		}
		ChatChannel channel = null;
		if (!chatClient.TryGetChannel(channelName, out channel))
		{
			UnityEngine.Debug.Log("ShowChannel failed to find channel: " + channelName);
			return;
		}
		selectedChannelName = channelName;
		CurrentChannelText.text = channel.ToStringMessages();
		UnityEngine.Debug.Log("ShowChannel: " + selectedChannelName);
		foreach (KeyValuePair<string, Toggle> channelToggle in channelToggles)
		{
			channelToggle.Value.isOn = ((channelToggle.Key == channelName) ? true : false);
		}
	}

	public void OpenDashboard()
	{
		UnityEngine.Application.OpenURL("https://dashboard.photonengine.com");
	}
}
public class FriendItem : MonoBehaviour
{
	public Text NameLabel;

	public Text StatusLabel;

	public Text Health;

	[HideInInspector]
	public string FriendId
	{
		get
		{
			return NameLabel.text;
		}
		set
		{
			NameLabel.text = value;
		}
	}

	public void Awake()
	{
		Health.text = string.Empty;
	}

	public void OnFriendStatusUpdate(int status, bool gotMessage, object message)
	{
		StatusLabel.text = status switch
		{
			1 => "Invisible", 
			2 => "Online", 
			3 => "Away", 
			4 => "Do not disturb", 
			5 => "Looking For Game/Group", 
			6 => "Playing", 
			_ => "Offline", 
		};
		if (gotMessage)
		{
			string text = string.Empty;
			if (message != null && message is string[] array && array.Length >= 2)
			{
				text = array[1] + "%";
			}
			Health.text = text;
		}
	}
}
public class IgnoreUiRaycastWhenInactive : MonoBehaviour, ICanvasRaycastFilter
{
	public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		return base.gameObject.activeInHierarchy;
	}
}
[RequireComponent(typeof(ChatGui))]
public class NamePickGui : MonoBehaviour
{
	private const string UserNamePlayerPref = "NamePickUserName";

	public ChatGui chatNewComponent;

	public InputField idInput;

	public void Start()
	{
		chatNewComponent = UnityEngine.Object.FindObjectOfType<ChatGui>();
		string @string = PlayerPrefs.GetString("NamePickUserName");
		if (!string.IsNullOrEmpty(@string))
		{
			idInput.text = @string;
		}
	}

	public void EndEditOnEnter()
	{
		if (Input.GetKey(KeyCode.Return) || Input.GetKey(KeyCode.KeypadEnter))
		{
			StartChat();
		}
	}

	public void StartChat()
	{
		ChatGui chatGui = UnityEngine.Object.FindObjectOfType<ChatGui>();
		chatGui.UserName = idInput.text.Trim();
		chatGui.Connect();
		base.enabled = false;
		PlayerPrefs.SetString("NamePickUserName", chatGui.UserName);
	}
}
[RequireComponent(typeof(Renderer))]
[RequireComponent(typeof(PhotonView))]
public class ChangeColor : MonoBehaviour
{
	private PhotonView photonView;

	private void Start()
	{
		photonView = GetComponent<PhotonView>();
		if (photonView.IsMine)
		{
			Color color = UnityEngine.Random.ColorHSV();
			photonView.RPC("ChangeColour", RpcTarget.AllBuffered, new Vector3(color.r, color.g, color.b));
		}
	}

	[PunRPC]
	private void ChangeColour(Vector3 randomColor)
	{
		GetComponent<Renderer>().material.SetColor("_Color", new Color(randomColor.x, randomColor.y, randomColor.z));
	}
}
[RequireComponent(typeof(PhotonView))]
public class ChangeName : MonoBehaviour
{
	private void Start()
	{
		PhotonView component = GetComponent<PhotonView>();
		base.name = $"ActorNumber {component.OwnerActorNr}";
	}
}
[RequireComponent(typeof(PhotonVoiceView))]
public class PointersController : MonoBehaviour
{
	[SerializeField]
	private GameObject pointerDown;

	[SerializeField]
	private GameObject pointerUp;

	private PhotonVoiceView photonVoiceView;

	private void Awake()
	{
		photonVoiceView = GetComponent<PhotonVoiceView>();
		SetActiveSafe(pointerUp, active: false);
		SetActiveSafe(pointerDown, active: false);
	}

	private void Update()
	{
		SetActiveSafe(pointerDown, photonVoiceView.IsSpeaking);
		SetActiveSafe(pointerUp, photonVoiceView.IsRecording);
	}

	private void SetActiveSafe(GameObject go, bool active)
	{
		if (go != null && go.activeSelf != active)
		{
			go.SetActive(active);
		}
	}
}
[RequireComponent(typeof(Collider))]
[RequireComponent(typeof(Rigidbody))]
public class ProximityVoiceTrigger : VoiceComponent
{
	private List<byte> groupsToAdd = new List<byte>();

	private List<byte> groupsToRemove = new List<byte>();

	[SerializeField]
	private byte[] subscribedGroups;

	private PhotonVoiceView photonVoiceView;

	private PhotonView photonView;

	public byte TargetInterestGroup
	{
		get
		{
			if (photonView != null)
			{
				return (byte)photonView.OwnerActorNr;
			}
			return 0;
		}
	}

	protected override void Awake()
	{
		photonVoiceView = GetComponentInParent<PhotonVoiceView>();
		photonView = GetComponentInParent<PhotonView>();
		GetComponent<Collider>().isTrigger = true;
		IsLocalCheck();
	}

	private void ToggleTransmission()
	{
		if (!(photonVoiceView.RecorderInUse != null))
		{
			return;
		}
		byte targetInterestGroup = TargetInterestGroup;
		if (photonVoiceView.RecorderInUse.InterestGroup != targetInterestGroup)
		{
			if (base.Logger.IsInfoEnabled)
			{
				base.Logger.LogInfo("Setting RecorderInUse's InterestGroup to {0}", targetInterestGroup);
			}
			photonVoiceView.RecorderInUse.InterestGroup = targetInterestGroup;
		}
		bool flag = subscribedGroups != null && subscribedGroups.Length != 0;
		if (photonVoiceView.RecorderInUse.TransmitEnabled != flag)
		{
			if (base.Logger.IsInfoEnabled)
			{
				base.Logger.LogInfo("Setting RecorderInUse's TransmitEnabled to {0}", flag);
			}
			photonVoiceView.RecorderInUse.TransmitEnabled = flag;
		}
		photonVoiceView.RecorderInUse.IsRecording = true;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!IsLocalCheck())
		{
			return;
		}
		ProximityVoiceTrigger component = other.GetComponent<ProximityVoiceTrigger>();
		if (component != null)
		{
			byte targetInterestGroup = component.TargetInterestGroup;
			if (base.Logger.IsDebugEnabled)
			{
				base.Logger.LogDebug("OnTriggerEnter {0}", targetInterestGroup);
			}
			if (targetInterestGroup != TargetInterestGroup && targetInterestGroup != 0 && !groupsToAdd.Contains(targetInterestGroup))
			{
				groupsToAdd.Add(targetInterestGroup);
			}
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!IsLocalCheck())
		{
			return;
		}
		ProximityVoiceTrigger component = other.GetComponent<ProximityVoiceTrigger>();
		if (!(component != null))
		{
			return;
		}
		byte targetInterestGroup = component.TargetInterestGroup;
		if (base.Logger.IsDebugEnabled)
		{
			base.Logger.LogDebug("OnTriggerExit {0}", targetInterestGroup);
		}
		if (targetInterestGroup != TargetInterestGroup && targetInterestGroup != 0)
		{
			if (groupsToAdd.Contains(targetInterestGroup))
			{
				groupsToAdd.Remove(targetInterestGroup);
			}
			if (!groupsToRemove.Contains(targetInterestGroup))
			{
				groupsToRemove.Add(targetInterestGroup);
			}
		}
	}

	private void Update()
	{
		if (!PhotonVoiceNetwork.Instance.Client.InRoom)
		{
			subscribedGroups = null;
		}
		else
		{
			if (!IsLocalCheck())
			{
				return;
			}
			if (groupsToAdd.Count > 0 || groupsToRemove.Count > 0)
			{
				byte[] array = null;
				byte[] array2 = null;
				if (groupsToAdd.Count > 0)
				{
					array = groupsToAdd.ToArray();
				}
				if (groupsToRemove.Count > 0)
				{
					array2 = groupsToRemove.ToArray();
				}
				if (base.Logger.IsInfoEnabled)
				{
					base.Logger.LogInfo("client of actor number {0} trying to change groups, to_be_removed#:{1} to_be_added#={2}", TargetInterestGroup, groupsToRemove.Count, groupsToAdd.Count);
				}
				if (PhotonVoiceNetwork.Instance.Client.OpChangeGroups(array2, array))
				{
					if (subscribedGroups != null)
					{
						List<byte> list = new List<byte>();
						for (int i = 0; i < subscribedGroups.Length; i++)
						{
							list.Add(subscribedGroups[i]);
						}
						for (int j = 0; j < groupsToRemove.Count; j++)
						{
							if (list.Contains(groupsToRemove[j]))
							{
								list.Remove(groupsToRemove[j]);
							}
						}
						for (int k = 0; k < groupsToAdd.Count; k++)
						{
							if (!list.Contains(groupsToAdd[k]))
							{
								list.Add(groupsToAdd[k]);
							}
						}
						subscribedGroups = list.ToArray();
					}
					else
					{
						subscribedGroups = array;
					}
					groupsToAdd.Clear();
					groupsToRemove.Clear();
				}
				else if (base.Logger.IsErrorEnabled)
				{
					base.Logger.LogError("Error changing groups");
				}
			}
			ToggleTransmission();
		}
	}

	private bool IsLocalCheck()
	{
		if (photonVoiceView.IsPhotonViewReady)
		{
			if (photonView.IsMine)
			{
				return true;
			}
			if (base.enabled)
			{
				if (base.Logger.IsInfoEnabled)
				{
					base.Logger.LogInfo("Disabling ProximityVoiceTrigger as does not belong to local player, actor number {0}", TargetInterestGroup);
				}
				base.enabled = false;
			}
		}
		return false;
	}
}
[Serializable]
public class MouseLookHelper
{
	public float XSensitivity = 2f;

	public float YSensitivity = 2f;

	public bool clampVerticalRotation = true;

	public float MinimumX = -90f;

	public float MaximumX = 90f;

	public bool smooth;

	public float smoothTime = 5f;

	private Quaternion m_CharacterTargetRot;

	private Quaternion m_CameraTargetRot;

	public void Init(Transform character, Transform camera)
	{
		m_CharacterTargetRot = character.localRotation;
		m_CameraTargetRot = camera.localRotation;
	}

	public void LookRotation(Transform character, Transform camera)
	{
		float y = CrossPlatformInputManager.GetAxis("Mouse X") * XSensitivity;
		float num = CrossPlatformInputManager.GetAxis("Mouse Y") * YSensitivity;
		m_CharacterTargetRot *= Quaternion.Euler(0f, y, 0f);
		m_CameraTargetRot *= Quaternion.Euler(0f - num, 0f, 0f);
		if (clampVerticalRotation)
		{
			m_CameraTargetRot = ClampRotationAroundXAxis(m_CameraTargetRot);
		}
		if (smooth)
		{
			character.localRotation = Quaternion.Slerp(character.localRotation, m_CharacterTargetRot, smoothTime * Time.deltaTime);
			camera.localRotation = Quaternion.Slerp(camera.localRotation, m_CameraTargetRot, smoothTime * Time.deltaTime);
		}
		else
		{
			character.localRotation = m_CharacterTargetRot;
			camera.localRotation = m_CameraTargetRot;
		}
	}

	private Quaternion ClampRotationAroundXAxis(Quaternion q)
	{
		q.x /= q.w;
		q.y /= q.w;
		q.z /= q.w;
		q.w = 1f;
		float value = 114.59156f * Mathf.Atan(q.x);
		value = Mathf.Clamp(value, MinimumX, MaximumX);
		q.x = Mathf.Tan((float)Math.PI / 360f * value);
		return q;
	}
}
public class SoundsForJoinAndLeave : MonoBehaviourPunCallbacks
{
	public AudioClip JoinClip;

	public AudioClip LeaveClip;

	private AudioSource source;

	public override void OnPlayerEnteredRoom(Player newPlayer)
	{
		if (JoinClip != null)
		{
			if (source == null)
			{
				source = UnityEngine.Object.FindObjectOfType<AudioSource>();
			}
			source.PlayOneShot(JoinClip);
		}
	}

	public override void OnPlayerLeftRoom(Player otherPlayer)
	{
		if (LeaveClip != null)
		{
			if (source == null)
			{
				source = UnityEngine.Object.FindObjectOfType<AudioSource>();
			}
			source.PlayOneShot(LeaveClip);
		}
	}
}
public class TestSSCtrl : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Space))
		{
			string text = UnityEngine.Application.dataPath + "/" + DateTime.Now.ToString("MMddyyHHmmss") + "_SS.png";
			ScreenCapture.CaptureScreenshot(text, 8);
			UnityEngine.Debug.LogError(text);
		}
	}
}
public class ChatController : MonoBehaviour
{
	public TMP_InputField TMP_ChatInput;

	public TMP_Text TMP_ChatOutput;

	public Scrollbar ChatScrollbar;

	private void OnEnable()
	{
		TMP_ChatInput.onSubmit.AddListener(AddToChatOutput);
	}

	private void OnDisable()
	{
		TMP_ChatInput.onSubmit.RemoveListener(AddToChatOutput);
	}

	private void AddToChatOutput(string newText)
	{
		TMP_ChatInput.text = string.Empty;
		DateTime now = DateTime.Now;
		TMP_Text tMP_ChatOutput = TMP_ChatOutput;
		tMP_ChatOutput.text = tMP_ChatOutput.text + "[<#FFFF80>" + now.Hour.ToString("d2") + ":" + now.Minute.ToString("d2") + ":" + now.Second.ToString("d2") + "</color>] " + newText + "\n";
		TMP_ChatInput.ActivateInputField();
		ChatScrollbar.value = 0f;
	}
}
public class EnvMapAnimator : MonoBehaviour
{
	public Vector3 RotationSpeeds;

	private TMP_Text m_textMeshPro;

	private Material m_material;

	private void Awake()
	{
		m_textMeshPro = GetComponent<TMP_Text>();
		m_material = m_textMeshPro.fontSharedMaterial;
	}

	private IEnumerator Start()
	{
		Matrix4x4 matrix = default(Matrix4x4);
		while (true)
		{
			matrix.SetTRS(Vector3.zero, Quaternion.Euler(Time.time * RotationSpeeds.x, Time.time * RotationSpeeds.y, Time.time * RotationSpeeds.z), Vector3.one);
			m_material.SetMatrix("_EnvMatrix", matrix);
			yield return null;
		}
	}
}
public class AUBUBU : MonoBehaviour
{
	public UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

	public UnityEngine.XR.Interaction.Toolkit.XRController RightController;

	private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

	private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

	private int sceneCount = 5;

	private float Dt;

	private float limitDt = 1.5f;

	private void Update()
	{
		if (LeftController.inputDevice.TryGetFeatureValue(CommonUsages.triggerButton, out var value) && value)
		{
			Func();
		}
		if (RightController.inputDevice.TryGetFeatureValue(CommonUsages.triggerButton, out var value2) && value2)
		{
			Func();
		}
		Dt += Time.deltaTime;
	}

	private void OnTriggerL_OnDataChanged(bool obj)
	{
		if (obj)
		{
			Func();
		}
	}

	private void OnTriggerR_OnDataChanged(bool obj)
	{
		if (obj)
		{
			Func();
		}
	}

	private void Func()
	{
		if (limitDt < Dt)
		{
			Dt = 0f;
			int num = SceneManager.GetActiveScene().buildIndex + 1;
			if (num == sceneCount)
			{
				num = 0;
			}
			SceneManager.LoadScene(num);
		}
	}
}
public class PlaneCrowdsAnimCtrl : MonoBehaviour
{
	public Material mat;

	public float speed = 10f;

	public int width = 2;

	public int height = 2;

	private float time_float;

	private int time_int;

	private bool isFor = true;

	private Vector2[] offsets;

	private void Start()
	{
		SetData();
	}

	public void SetData()
	{
		float num = 1f / (float)width;
		float num2 = 1f / (float)height;
		mat.SetTextureScale("_BaseMap", new Vector2(num, num2));
		offsets = new Vector2[width * height];
		for (int i = 0; i < height; i++)
		{
			for (int j = 0; j < width; j++)
			{
				offsets[i * width + j] = new Vector2((float)j * num, (float)(height - i - 1) * num2);
			}
		}
	}

	private void Update()
	{
		if (isFor)
		{
			time_float += Time.deltaTime * speed;
		}
		else
		{
			time_float -= Time.deltaTime * speed;
		}
		if (isFor && time_float >= 15.5f)
		{
			isFor = false;
			time_float = 15.5f - (time_float - 15.5f);
		}
		else if (!isFor && time_float <= 0.5f)
		{
			isFor = true;
			time_float = 0.5f + (0.5f - time_float);
		}
		else if (time_int != (int)time_float)
		{
			time_int = Mathf.Clamp((int)time_float, 0, 15);
			mat.SetTextureOffset("_BaseMap", offsets[time_int]);
		}
	}
}
namespace TMPro
{
	[Serializable]
	public class TMP_DigitValidator : TMP_InputValidator
	{
		public override char Validate(ref string text, ref int pos, char ch)
		{
			if (ch >= '0' && ch <= '9')
			{
				pos++;
				return ch;
			}
			return '\0';
		}
	}
	[Serializable]
	public class TMP_PhoneNumberValidator : TMP_InputValidator
	{
		public override char Validate(ref string text, ref int pos, char ch)
		{
			UnityEngine.Debug.Log("Trying to validate...");
			if (ch < '0' && ch > '9')
			{
				return '\0';
			}
			int length = text.Length;
			for (int i = 0; i < length + 1; i++)
			{
				switch (i)
				{
				case 0:
					if (i == length)
					{
						text = "(" + ch;
					}
					pos = 2;
					break;
				case 1:
					if (i == length)
					{
						text += ch;
					}
					pos = 2;
					break;
				case 2:
					if (i == length)
					{
						text += ch;
					}
					pos = 3;
					break;
				case 3:
					if (i == length)
					{
						text = text + ch + ") ";
					}
					pos = 6;
					break;
				case 4:
					if (i == length)
					{
						text = text + ") " + ch;
					}
					pos = 7;
					break;
				case 5:
					if (i == length)
					{
						text = text + " " + ch;
					}
					pos = 7;
					break;
				case 6:
					if (i == length)
					{
						text += ch;
					}
					pos = 7;
					break;
				case 7:
					if (i == length)
					{
						text += ch;
					}
					pos = 8;
					break;
				case 8:
					if (i == length)
					{
						text = text + ch + "-";
					}
					pos = 10;
					break;
				case 9:
					if (i == length)
					{
						text = text + "-" + ch;
					}
					pos = 11;
					break;
				case 10:
					if (i == length)
					{
						text += ch;
					}
					pos = 11;
					break;
				case 11:
					if (i == length)
					{
						text += ch;
					}
					pos = 12;
					break;
				case 12:
					if (i == length)
					{
						text += ch;
					}
					pos = 13;
					break;
				case 13:
					if (i == length)
					{
						text += ch;
					}
					pos = 14;
					break;
				}
			}
			return ch;
		}
	}
	public class TMP_TextEventHandler : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		[Serializable]
		public class CharacterSelectionEvent : UnityEvent<char, int>
		{
		}

		[Serializable]
		public class SpriteSelectionEvent : UnityEvent<char, int>
		{
		}

		[Serializable]
		public class WordSelectionEvent : UnityEvent<string, int, int>
		{
		}

		[Serializable]
		public class LineSelectionEvent : UnityEvent<string, int, int>
		{
		}

		[Serializable]
		public class LinkSelectionEvent : UnityEvent<string, string, int>
		{
		}

		[SerializeField]
		private CharacterSelectionEvent m_OnCharacterSelection = new CharacterSelectionEvent();

		[SerializeField]
		private SpriteSelectionEvent m_OnSpriteSelection = new SpriteSelectionEvent();

		[SerializeField]
		private WordSelectionEvent m_OnWordSelection = new WordSelectionEvent();

		[SerializeField]
		private LineSelectionEvent m_OnLineSelection = new LineSelectionEvent();

		[SerializeField]
		private LinkSelectionEvent m_OnLinkSelection = new LinkSelectionEvent();

		private TMP_Text m_TextComponent;

		private Camera m_Camera;

		private Canvas m_Canvas;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		private int m_lastLineIndex = -1;

		public CharacterSelectionEvent onCharacterSelection
		{
			get
			{
				return m_OnCharacterSelection;
			}
			set
			{
				m_OnCharacterSelection = value;
			}
		}

		public SpriteSelectionEvent onSpriteSelection
		{
			get
			{
				return m_OnSpriteSelection;
			}
			set
			{
				m_OnSpriteSelection = value;
			}
		}

		public WordSelectionEvent onWordSelection
		{
			get
			{
				return m_OnWordSelection;
			}
			set
			{
				m_OnWordSelection = value;
			}
		}

		public LineSelectionEvent onLineSelection
		{
			get
			{
				return m_OnLineSelection;
			}
			set
			{
				m_OnLineSelection = value;
			}
		}

		public LinkSelectionEvent onLinkSelection
		{
			get
			{
				return m_OnLinkSelection;
			}
			set
			{
				m_OnLinkSelection = value;
			}
		}

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
			if (m_TextComponent.GetType() == typeof(TextMeshProUGUI))
			{
				m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
				if (m_Canvas != null)
				{
					if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
					{
						m_Camera = null;
					}
					else
					{
						m_Camera = m_Canvas.worldCamera;
					}
				}
			}
			else
			{
				m_Camera = Camera.main;
			}
		}

		private void LateUpdate()
		{
			if (!TMP_TextUtilities.IsIntersectingRectTransform(m_TextComponent.rectTransform, Input.mousePosition, m_Camera))
			{
				return;
			}
			int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextComponent, Input.mousePosition, m_Camera, visibleOnly: true);
			if (num != -1 && num != m_lastCharIndex)
			{
				m_lastCharIndex = num;
				switch (m_TextComponent.textInfo.characterInfo[num].elementType)
				{
				case TMP_TextElementType.Character:
					SendOnCharacterSelection(m_TextComponent.textInfo.characterInfo[num].character, num);
					break;
				case TMP_TextElementType.Sprite:
					SendOnSpriteSelection(m_TextComponent.textInfo.characterInfo[num].character, num);
					break;
				}
			}
			int num2 = TMP_TextUtilities.FindIntersectingWord(m_TextComponent, Input.mousePosition, m_Camera);
			if (num2 != -1 && num2 != m_lastWordIndex)
			{
				m_lastWordIndex = num2;
				TMP_WordInfo tMP_WordInfo = m_TextComponent.textInfo.wordInfo[num2];
				SendOnWordSelection(tMP_WordInfo.GetWord(), tMP_WordInfo.firstCharacterIndex, tMP_WordInfo.characterCount);
			}
			int num3 = TMP_TextUtilities.FindIntersectingLine(m_TextComponent, Input.mousePosition, m_Camera);
			if (num3 != -1 && num3 != m_lastLineIndex)
			{
				m_lastLineIndex = num3;
				TMP_LineInfo tMP_LineInfo = m_TextComponent.textInfo.lineInfo[num3];
				char[] array = new char[tMP_LineInfo.characterCount];
				for (int i = 0; i < tMP_LineInfo.characterCount && i < m_TextComponent.textInfo.characterInfo.Length; i++)
				{
					array[i] = m_TextComponent.textInfo.characterInfo[i + tMP_LineInfo.firstCharacterIndex].character;
				}
				string line = new string(array);
				SendOnLineSelection(line, tMP_LineInfo.firstCharacterIndex, tMP_LineInfo.characterCount);
			}
			int num4 = TMP_TextUtilities.FindIntersectingLink(m_TextComponent, Input.mousePosition, m_Camera);
			if (num4 != -1 && num4 != m_selectedLink)
			{
				m_selectedLink = num4;
				TMP_LinkInfo tMP_LinkInfo = m_TextComponent.textInfo.linkInfo[num4];
				SendOnLinkSelection(tMP_LinkInfo.GetLinkID(), tMP_LinkInfo.GetLinkText(), num4);
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
		}

		public void OnPointerExit(PointerEventData eventData)
		{
		}

		private void SendOnCharacterSelection(char character, int characterIndex)
		{
			if (onCharacterSelection != null)
			{
				onCharacterSelection.Invoke(character, characterIndex);
			}
		}

		private void SendOnSpriteSelection(char character, int characterIndex)
		{
			if (onSpriteSelection != null)
			{
				onSpriteSelection.Invoke(character, characterIndex);
			}
		}

		private void SendOnWordSelection(string word, int charIndex, int length)
		{
			if (onWordSelection != null)
			{
				onWordSelection.Invoke(word, charIndex, length);
			}
		}

		private void SendOnLineSelection(string line, int charIndex, int length)
		{
			if (onLineSelection != null)
			{
				onLineSelection.Invoke(line, charIndex, length);
			}
		}

		private void SendOnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			if (onLinkSelection != null)
			{
				onLinkSelection.Invoke(linkID, linkText, linkIndex);
			}
		}
	}
}
namespace TMPro.Examples
{
	public class Benchmark01 : MonoBehaviour
	{
		public int BenchmarkType;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshPro m_textMeshPro;

		private TextContainer m_textContainer;

		private TextMesh m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>{0}";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
				m_textMeshPro.autoSizeTextContainer = true;
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_textMeshPro.enableWordWrapping = false;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Drop Shadow");
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<TextMesh>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				else
				{
					m_textMesh.font = Resources.Load("Fonts/ARIAL", typeof(Font)) as Font;
					m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.anchor = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.SetText("The <#0050FF>count is: </color>{0}", i % 1000);
					if (i % 1000 == 999)
					{
						TextMeshPro textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (!(m_textMeshPro.fontSharedMaterial == m_material01))
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material01);
							fontSharedMaterial = material2;
						}
						else
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material02);
							fontSharedMaterial = material2;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark01_UGUI : MonoBehaviour
	{
		public int BenchmarkType;

		public Canvas canvas;

		public TMP_FontAsset TMProFont;

		public Font TextMeshFont;

		private TextMeshProUGUI m_textMeshPro;

		private Text m_textMesh;

		private const string label01 = "The <#0050FF>count is: </color>";

		private const string label02 = "The <color=#0050FF>count is: </color>";

		private Material m_material01;

		private Material m_material02;

		private IEnumerator Start()
		{
			if (BenchmarkType == 0)
			{
				m_textMeshPro = base.gameObject.AddComponent<TextMeshProUGUI>();
				if (TMProFont != null)
				{
					m_textMeshPro.font = TMProFont;
				}
				m_textMeshPro.fontSize = 48f;
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.extraPadding = true;
				m_material01 = m_textMeshPro.font.material;
				m_material02 = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - BEVEL");
			}
			else if (BenchmarkType == 1)
			{
				m_textMesh = base.gameObject.AddComponent<Text>();
				if (TextMeshFont != null)
				{
					m_textMesh.font = TextMeshFont;
				}
				m_textMesh.fontSize = 48;
				m_textMesh.alignment = TextAnchor.MiddleCenter;
			}
			for (int i = 0; i <= 1000000; i++)
			{
				if (BenchmarkType == 0)
				{
					m_textMeshPro.text = "The <#0050FF>count is: </color>" + i % 1000;
					if (i % 1000 == 999)
					{
						TextMeshProUGUI textMeshPro = m_textMeshPro;
						Material fontSharedMaterial;
						if (!(m_textMeshPro.fontSharedMaterial == m_material01))
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material01);
							fontSharedMaterial = material2;
						}
						else
						{
							Material material2 = (m_textMeshPro.fontSharedMaterial = m_material02);
							fontSharedMaterial = material2;
						}
						textMeshPro.fontSharedMaterial = fontSharedMaterial;
					}
				}
				else if (BenchmarkType == 1)
				{
					m_textMesh.text = "The <color=#0050FF>count is: </color>" + i % 1000;
				}
				yield return null;
			}
			yield return null;
		}
	}
	public class Benchmark02 : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		private TextMeshProFloatingText floatingText_Script;

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.25f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.autoSizeTextContainer = true;
					textMeshPro.rectTransform.pivot = new Vector2(0.5f, 0f);
					textMeshPro.alignment = TextAlignmentOptions.Bottom;
					textMeshPro.fontSize = 96f;
					textMeshPro.enableKerning = false;
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshPro.text = "!";
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else if (SpawnType == 1)
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.25f, UnityEngine.Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
					textMesh.GetComponent<Renderer>().sharedMaterial = textMesh.font.material;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
				else if (SpawnType == 2)
				{
					GameObject gameObject3 = new GameObject();
					gameObject3.AddComponent<Canvas>().worldCamera = Camera.main;
					gameObject3.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
					gameObject3.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 5f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshProUGUI textMeshProUGUI = new GameObject().AddComponent<TextMeshProUGUI>();
					textMeshProUGUI.rectTransform.SetParent(gameObject3.transform, worldPositionStays: false);
					textMeshProUGUI.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMeshProUGUI.alignment = TextAlignmentOptions.Bottom;
					textMeshProUGUI.fontSize = 96f;
					textMeshProUGUI.text = "!";
					floatingText_Script = gameObject3.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
			}
		}
	}
	public class Benchmark03 : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		public Font TheFont;

		private void Awake()
		{
		}

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject obj = new GameObject();
					obj.transform.position = new Vector3(0f, 0f, 0f);
					TextMeshPro textMeshPro = obj.AddComponent<TextMeshPro>();
					textMeshPro.alignment = TextAlignmentOptions.Center;
					textMeshPro.fontSize = 96f;
					textMeshPro.text = "@";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
				}
				else
				{
					GameObject obj2 = new GameObject();
					obj2.transform.position = new Vector3(0f, 0f, 0f);
					TextMesh textMesh = obj2.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
					textMesh.font = TheFont;
					textMesh.anchor = TextAnchor.MiddleCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "@";
				}
			}
		}
	}
	public class Benchmark04 : MonoBehaviour
	{
		public int SpawnType;

		public int MinPointSize = 12;

		public int MaxPointSize = 64;

		public int Steps = 4;

		private Transform m_Transform;

		private void Start()
		{
			m_Transform = base.transform;
			float num = 0f;
			float num3 = (Camera.main.orthographicSize = Screen.height / 2);
			float num4 = num3;
			float num5 = (float)Screen.width / (float)Screen.height;
			for (int i = MinPointSize; i <= MaxPointSize; i += Steps)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject("Text - " + i + " Pts");
					if (num > num4 * 2f)
					{
						break;
					}
					gameObject.transform.position = m_Transform.position + new Vector3(num5 * (0f - num4) * 0.975f, num4 * 0.975f - num, 0f);
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.rectTransform.pivot = new Vector2(0f, 0.5f);
					textMeshPro.enableWordWrapping = false;
					textMeshPro.extraPadding = true;
					textMeshPro.isOrthographic = true;
					textMeshPro.fontSize = i;
					textMeshPro.text = i + " pts - Lorem ipsum dolor sit...";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
					num += (float)i;
				}
			}
		}
	}
	public class CameraController : MonoBehaviour
	{
		public enum CameraModes
		{
			Follow,
			Isometric,
			Free
		}

		private Transform cameraTransform;

		private Transform dummyTarget;

		public Transform CameraTarget;

		public float FollowDistance = 30f;

		public float MaxFollowDistance = 100f;

		public float MinFollowDistance = 2f;

		public float ElevationAngle = 30f;

		public float MaxElevationAngle = 85f;

		public float MinElevationAngle;

		public float OrbitalAngle;

		public CameraModes CameraMode;

		public bool MovementSmoothing = true;

		public bool RotationSmoothing;

		private bool previousSmoothing;

		public float MovementSmoothingValue = 25f;

		public float RotationSmoothingValue = 5f;

		public float MoveSensitivity = 2f;

		private Vector3 currentVelocity = Vector3.zero;

		private Vector3 desiredPosition;

		private float mouseX;

		private float mouseY;

		private Vector3 moveVector;

		private float mouseWheel;

		private const string event_SmoothingValue = "Slider - Smoothing Value";

		private const string event_FollowDistance = "Slider - Camera Zoom";

		private void Awake()
		{
			if (QualitySettings.vSyncCount > 0)
			{
				UnityEngine.Application.targetFrameRate = 60;
			}
			else
			{
				UnityEngine.Application.targetFrameRate = -1;
			}
			if (UnityEngine.Application.platform == RuntimePlatform.IPhonePlayer || UnityEngine.Application.platform == RuntimePlatform.Android)
			{
				Input.simulateMouseWithTouches = false;
			}
			cameraTransform = base.transform;
			previousSmoothing = MovementSmoothing;
		}

		private void Start()
		{
			if (CameraTarget == null)
			{
				dummyTarget = new GameObject("Camera Target").transform;
				CameraTarget = dummyTarget;
			}
		}

		private void LateUpdate()
		{
			GetPlayerInput();
			if (CameraTarget != null)
			{
				if (CameraMode == CameraModes.Isometric)
				{
					desiredPosition = CameraTarget.position + Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance);
				}
				else if (CameraMode == CameraModes.Follow)
				{
					desiredPosition = CameraTarget.position + CameraTarget.TransformDirection(Quaternion.Euler(ElevationAngle, OrbitalAngle, 0f) * new Vector3(0f, 0f, 0f - FollowDistance));
				}
				if (MovementSmoothing)
				{
					cameraTransform.position = Vector3.SmoothDamp(cameraTransform.position, desiredPosition, ref currentVelocity, MovementSmoothingValue * Time.fixedDeltaTime);
				}
				else
				{
					cameraTransform.position = desiredPosition;
				}
				if (RotationSmoothing)
				{
					cameraTransform.rotation = Quaternion.Lerp(cameraTransform.rotation, Quaternion.LookRotation(CameraTarget.position - cameraTransform.position), RotationSmoothingValue * Time.deltaTime);
				}
				else
				{
					cameraTransform.LookAt(CameraTarget);
				}
			}
		}

		private void GetPlayerInput()
		{
			moveVector = Vector3.zero;
			mouseWheel = Input.GetAxis("Mouse ScrollWheel");
			float num = Input.touchCount;
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift) || num > 0f)
			{
				mouseWheel *= 10f;
				if (Input.GetKeyDown(KeyCode.I))
				{
					CameraMode = CameraModes.Isometric;
				}
				if (Input.GetKeyDown(KeyCode.F))
				{
					CameraMode = CameraModes.Follow;
				}
				if (Input.GetKeyDown(KeyCode.S))
				{
					MovementSmoothing = !MovementSmoothing;
				}
				if (Input.GetMouseButton(1))
				{
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					if (mouseY > 0.01f || mouseY < -0.01f)
					{
						ElevationAngle -= mouseY * MoveSensitivity;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (mouseX > 0.01f || mouseX < -0.01f)
					{
						OrbitalAngle += mouseX * MoveSensitivity;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (num == 1f && Input.GetTouch(0).phase == TouchPhase.Moved)
				{
					Vector2 deltaPosition = Input.GetTouch(0).deltaPosition;
					if (deltaPosition.y > 0.01f || deltaPosition.y < -0.01f)
					{
						ElevationAngle -= deltaPosition.y * 0.1f;
						ElevationAngle = Mathf.Clamp(ElevationAngle, MinElevationAngle, MaxElevationAngle);
					}
					if (deltaPosition.x > 0.01f || deltaPosition.x < -0.01f)
					{
						OrbitalAngle += deltaPosition.x * 0.1f;
						if (OrbitalAngle > 360f)
						{
							OrbitalAngle -= 360f;
						}
						if (OrbitalAngle < 0f)
						{
							OrbitalAngle += 360f;
						}
					}
				}
				if (Input.GetMouseButton(0) && Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out var hitInfo, 300f, 23552))
				{
					if (hitInfo.transform == CameraTarget)
					{
						OrbitalAngle = 0f;
					}
					else
					{
						CameraTarget = hitInfo.transform;
						OrbitalAngle = 0f;
						MovementSmoothing = previousSmoothing;
					}
				}
				if (Input.GetMouseButton(2))
				{
					if (dummyTarget == null)
					{
						dummyTarget = new GameObject("Camera Target").transform;
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					else if (dummyTarget != CameraTarget)
					{
						dummyTarget.position = CameraTarget.position;
						dummyTarget.rotation = CameraTarget.rotation;
						CameraTarget = dummyTarget;
						previousSmoothing = MovementSmoothing;
						MovementSmoothing = false;
					}
					mouseY = Input.GetAxis("Mouse Y");
					mouseX = Input.GetAxis("Mouse X");
					moveVector = cameraTransform.TransformDirection(mouseX, mouseY, 0f);
					dummyTarget.Translate(-moveVector, Space.World);
				}
			}
			if (num == 2f)
			{
				Touch touch = Input.GetTouch(0);
				Touch touch2 = Input.GetTouch(1);
				Vector2 vector = touch.position - touch.deltaPosition;
				Vector2 vector2 = touch2.position - touch2.deltaPosition;
				float magnitude = (vector - vector2).magnitude;
				float magnitude2 = (touch.position - touch2.position).magnitude;
				float num2 = magnitude - magnitude2;
				if (num2 > 0.01f || num2 < -0.01f)
				{
					FollowDistance += num2 * 0.25f;
					FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
				}
			}
			if (mouseWheel < -0.01f || mouseWheel > 0.01f)
			{
				FollowDistance -= mouseWheel * 5f;
				FollowDistance = Mathf.Clamp(FollowDistance, MinFollowDistance, MaxFollowDistance);
			}
		}
	}
	public class ObjectSpin : MonoBehaviour
	{
		public enum MotionType
		{
			Rotation,
			BackAndForth,
			Translation
		}

		public float SpinSpeed = 5f;

		public int RotationRange = 15;

		private Transform m_transform;

		private float m_time;

		private Vector3 m_prevPOS;

		private Vector3 m_initial_Rotation;

		private Vector3 m_initial_Position;

		private Color32 m_lightColor;

		private int frames;

		public MotionType Motion;

		private void Awake()
		{
			m_transform = base.transform;
			m_initial_Rotation = m_transform.rotation.eulerAngles;
			m_initial_Position = m_transform.position;
			Light component = GetComponent<Light>();
			m_lightColor = ((component != null) ? component.color : Color.black);
		}

		private void Update()
		{
			if (Motion == MotionType.Rotation)
			{
				m_transform.Rotate(0f, SpinSpeed * Time.deltaTime, 0f);
				return;
			}
			if (Motion == MotionType.BackAndForth)
			{
				m_time += SpinSpeed * Time.deltaTime;
				m_transform.rotation = Quaternion.Euler(m_initial_Rotation.x, Mathf.Sin(m_time) * (float)RotationRange + m_initial_Rotation.y, m_initial_Rotation.z);
				return;
			}
			m_time += SpinSpeed * Time.deltaTime;
			float x = 15f * Mathf.Cos(m_time * 0.95f);
			float z = 10f;
			float y = 0f;
			m_transform.position = m_initial_Position + new Vector3(x, y, z);
			m_prevPOS = m_transform.position;
			frames++;
		}
	}
	public class ShaderPropAnimator : MonoBehaviour
	{
		private Renderer m_Renderer;

		private Material m_Material;

		public AnimationCurve GlowCurve;

		public float m_frame;

		private void Awake()
		{
			m_Renderer = GetComponent<Renderer>();
			m_Material = m_Renderer.material;
		}

		private void Start()
		{
			StartCoroutine(AnimateProperties());
		}

		private IEnumerator AnimateProperties()
		{
			m_frame = UnityEngine.Random.Range(0f, 1f);
			while (true)
			{
				float value = GlowCurve.Evaluate(m_frame);
				m_Material.SetFloat(ShaderUtilities.ID_GlowPower, value);
				m_frame += Time.deltaTime * UnityEngine.Random.Range(0.2f, 0.3f);
				yield return new WaitForEndOfFrame();
			}
		}
	}
	public class SimpleScript : MonoBehaviour
	{
		private TextMeshPro m_textMeshPro;

		private const string label = "The <#0050FF>count is: </color>{0:2}";

		private float m_frame;

		private void Start()
		{
			m_textMeshPro = base.gameObject.AddComponent<TextMeshPro>();
			m_textMeshPro.autoSizeTextContainer = true;
			m_textMeshPro.fontSize = 48f;
			m_textMeshPro.alignment = TextAlignmentOptions.Center;
			m_textMeshPro.enableWordWrapping = false;
		}

		private void Update()
		{
			m_textMeshPro.SetText("The <#0050FF>count is: </color>{0:2}", m_frame % 1000f);
			m_frame += 1f * Time.deltaTime;
		}
	}
	public class SkewTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float CurveScale = 1f;

		public float ShearAmount = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			return new AnimationCurve
			{
				keys = curve.keys
			};
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			float old_ShearValue = ShearAmount;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value && old_ShearValue == ShearAmount)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				old_ShearValue = ShearAmount;
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float x = m_TextComponent.bounds.min.x;
				float x2 = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = ShearAmount * 0.01f;
						Vector3 vector2 = new Vector3(num * (textInfo.characterInfo[i].topRight.y - textInfo.characterInfo[i].baseLine), 0f, 0f);
						Vector3 vector3 = new Vector3(num * (textInfo.characterInfo[i].baseLine - textInfo.characterInfo[i].bottomRight.y), 0f, 0f);
						vertices[vertexIndex] += -vector3;
						vertices[vertexIndex + 1] += vector2;
						vertices[vertexIndex + 2] += vector2;
						vertices[vertexIndex + 3] += -vector3;
						float num2 = (vector.x - x) / (x2 - x);
						float num3 = num2 + 0.0001f;
						float y = VertexCurve.Evaluate(num2) * CurveScale;
						float y2 = VertexCurve.Evaluate(num3) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num3 * (x2 - x) + x, y2) - new Vector3(vector.x, y);
						float num4 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((Vector3.Cross(lhs, rhs).z > 0f) ? num4 : (360f - num4));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);
						vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return null;
			}
		}
	}
	public class TMP_ExampleScript_01 : MonoBehaviour
	{
		public enum objectType
		{
			TextMeshPro,
			TextMeshProUGUI
		}

		public objectType ObjectType;

		public bool isStatic;

		private TMP_Text m_text;

		private const string k_label = "The count is <#0080ff>{0}</color>";

		private int count;

		private void Awake()
		{
			if (ObjectType == objectType.TextMeshPro)
			{
				m_text = GetComponent<TextMeshPro>() ?? base.gameObject.AddComponent<TextMeshPro>();
			}
			else
			{
				m_text = GetComponent<TextMeshProUGUI>() ?? base.gameObject.AddComponent<TextMeshProUGUI>();
			}
			m_text.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/Anton SDF");
			m_text.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/Anton SDF - Drop Shadow");
			m_text.fontSize = 120f;
			m_text.text = "A <#0080ff>simple</color> line of text.";
			Vector2 preferredValues = m_text.GetPreferredValues(float.PositiveInfinity, float.PositiveInfinity);
			m_text.rectTransform.sizeDelta = new Vector2(preferredValues.x, preferredValues.y);
		}

		private void Update()
		{
			if (!isStatic)
			{
				m_text.SetText("The count is <#0080ff>{0}</color>", count % 1000);
				count++;
			}
		}
	}
	public class TMP_FrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

		private TextMeshPro m_TextMeshPro;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				UnityEngine.Application.targetFrameRate = -1;
				GameObject gameObject = new GameObject("Frame Counter");
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
				m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.SetParent(m_camera.transform);
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 24f;
				m_TextMeshPro.isOverlay = true;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			m_TextMeshPro.margin = new Vector4(1f, 1f, 1f, 1f);
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_TextMeshPro.rectTransform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_TextMeshPro.rectTransform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class TMP_TextEventCheck : MonoBehaviour
	{
		public TMP_TextEventHandler TextEventHandler;

		private void OnEnable()
		{
			if (TextEventHandler != null)
			{
				TextEventHandler.onCharacterSelection.AddListener(OnCharacterSelection);
				TextEventHandler.onSpriteSelection.AddListener(OnSpriteSelection);
				TextEventHandler.onWordSelection.AddListener(OnWordSelection);
				TextEventHandler.onLineSelection.AddListener(OnLineSelection);
				TextEventHandler.onLinkSelection.AddListener(OnLinkSelection);
			}
		}

		private void OnDisable()
		{
			if (TextEventHandler != null)
			{
				TextEventHandler.onCharacterSelection.RemoveListener(OnCharacterSelection);
				TextEventHandler.onSpriteSelection.RemoveListener(OnSpriteSelection);
				TextEventHandler.onWordSelection.RemoveListener(OnWordSelection);
				TextEventHandler.onLineSelection.RemoveListener(OnLineSelection);
				TextEventHandler.onLinkSelection.RemoveListener(OnLinkSelection);
			}
		}

		private void OnCharacterSelection(char c, int index)
		{
			UnityEngine.Debug.Log("Character [" + c.ToString() + "] at Index: " + index + " has been selected.");
		}

		private void OnSpriteSelection(char c, int index)
		{
			UnityEngine.Debug.Log("Sprite [" + c.ToString() + "] at Index: " + index + " has been selected.");
		}

		private void OnWordSelection(string word, int firstCharacterIndex, int length)
		{
			UnityEngine.Debug.Log("Word [" + word + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
		}

		private void OnLineSelection(string lineText, int firstCharacterIndex, int length)
		{
			UnityEngine.Debug.Log("Line [" + lineText + "] with first character index of " + firstCharacterIndex + " and length of " + length + " has been selected.");
		}

		private void OnLinkSelection(string linkID, string linkText, int linkIndex)
		{
			UnityEngine.Debug.Log("Link Index: " + linkIndex + " with ID [" + linkID + "] and Text \"" + linkText + "\" has been selected.");
		}
	}
	public class TMP_TextInfoDebugTool : MonoBehaviour
	{
	}
	public class TMP_TextSelector_A : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private TextMeshPro m_TextMeshPro;

		private Camera m_Camera;

		private bool m_isHoveringObject;

		private int m_selectedLink = -1;

		private int m_lastCharIndex = -1;

		private int m_lastWordIndex = -1;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshPro>();
			m_Camera = Camera.main;
			m_TextMeshPro.ForceMeshUpdate();
		}

		private void LateUpdate()
		{
			m_isHoveringObject = false;
			if (TMP_TextUtilities.IsIntersectingRectTransform(m_TextMeshPro.rectTransform, Input.mousePosition, Camera.main))
			{
				m_isHoveringObject = true;
			}
			if (!m_isHoveringObject)
			{
				return;
			}
			int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, Camera.main, visibleOnly: true);
			if (num != -1 && num != m_lastCharIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
			{
				m_lastCharIndex = num;
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
				Color32 color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				colors[vertexIndex] = color;
				colors[vertexIndex + 1] = color;
				colors[vertexIndex + 2] = color;
				colors[vertexIndex + 3] = color;
				m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].mesh.colors32 = colors;
			}
			int num2 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
			if ((num2 == -1 && m_selectedLink != -1) || num2 != m_selectedLink)
			{
				m_selectedLink = -1;
			}
			if (num2 != -1 && num2 != m_selectedLink)
			{
				m_selectedLink = num2;
				TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num2];
				RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out var _);
				string linkID = tMP_LinkInfo.GetLinkID();
				if (!(linkID == "id_01"))
				{
					_ = linkID == "id_02";
				}
			}
			int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, Camera.main);
			if (num3 != -1 && num3 != m_lastWordIndex)
			{
				m_lastWordIndex = num3;
				TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[num3];
				Vector3 position = m_TextMeshPro.transform.TransformPoint(m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex].bottomLeft);
				position = Camera.main.WorldToScreenPoint(position);
				Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[0].colors32;
				Color32 color2 = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				for (int i = 0; i < tMP_WordInfo.characterCount; i++)
				{
					int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[tMP_WordInfo.firstCharacterIndex + i].vertexIndex;
					colors2[vertexIndex2] = color2;
					colors2[vertexIndex2 + 1] = color2;
					colors2[vertexIndex2 + 2] = color2;
					colors2[vertexIndex2 + 3] = color2;
				}
				m_TextMeshPro.mesh.colors32 = colors2;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			UnityEngine.Debug.Log("OnPointerEnter()");
			m_isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			UnityEngine.Debug.Log("OnPointerExit()");
			m_isHoveringObject = false;
		}
	}
	public class TMP_TextSelector_B : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler, IPointerClickHandler, IPointerUpHandler
	{
		public RectTransform TextPopup_Prefab_01;

		private RectTransform m_TextPopup_RectTransform;

		private TextMeshProUGUI m_TextPopup_TMPComponent;

		private const string k_LinkText = "You have selected link <#ffff00>";

		private const string k_WordText = "Word Index: <#ffff00>";

		private TextMeshProUGUI m_TextMeshPro;

		private Canvas m_Canvas;

		private Camera m_Camera;

		private bool isHoveringObject;

		private int m_selectedWord = -1;

		private int m_selectedLink = -1;

		private int m_lastIndex = -1;

		private Matrix4x4 m_matrix;

		private TMP_MeshInfo[] m_cachedMeshInfoVertexData;

		private void Awake()
		{
			m_TextMeshPro = base.gameObject.GetComponent<TextMeshProUGUI>();
			m_Canvas = base.gameObject.GetComponentInParent<Canvas>();
			if (m_Canvas.renderMode == RenderMode.ScreenSpaceOverlay)
			{
				m_Camera = null;
			}
			else
			{
				m_Camera = m_Canvas.worldCamera;
			}
			m_TextPopup_RectTransform = UnityEngine.Object.Instantiate(TextPopup_Prefab_01);
			m_TextPopup_RectTransform.SetParent(m_Canvas.transform, worldPositionStays: false);
			m_TextPopup_TMPComponent = m_TextPopup_RectTransform.GetComponentInChildren<TextMeshProUGUI>();
			m_TextPopup_RectTransform.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextMeshPro)
			{
				m_cachedMeshInfoVertexData = m_TextMeshPro.textInfo.CopyMeshInfoVertexData();
			}
		}

		private void LateUpdate()
		{
			if (isHoveringObject)
			{
				int num = TMP_TextUtilities.FindIntersectingCharacter(m_TextMeshPro, Input.mousePosition, m_Camera, visibleOnly: true);
				if (num == -1 || num != m_lastIndex)
				{
					RestoreCachedVertexAttributes(m_lastIndex);
					m_lastIndex = -1;
				}
				if (num != -1 && num != m_lastIndex && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)))
				{
					m_lastIndex = num;
					int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[num].materialReferenceIndex;
					int vertexIndex = m_TextMeshPro.textInfo.characterInfo[num].vertexIndex;
					Vector3[] vertices = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
					Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
					vertices[vertexIndex] -= vector;
					vertices[vertexIndex + 1] -= vector;
					vertices[vertexIndex + 2] -= vector;
					vertices[vertexIndex + 3] -= vector;
					float num2 = 1.5f;
					m_matrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one * num2);
					vertices[vertexIndex] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex]);
					vertices[vertexIndex + 1] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 1]);
					vertices[vertexIndex + 2] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 2]);
					vertices[vertexIndex + 3] = m_matrix.MultiplyPoint3x4(vertices[vertexIndex + 3]);
					vertices[vertexIndex] += vector;
					vertices[vertexIndex + 1] += vector;
					vertices[vertexIndex + 2] += vector;
					vertices[vertexIndex + 3] += vector;
					Color32 color = new Color32(byte.MaxValue, byte.MaxValue, 192, byte.MaxValue);
					Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
					colors[vertexIndex] = color;
					colors[vertexIndex + 1] = color;
					colors[vertexIndex + 2] = color;
					colors[vertexIndex + 3] = color;
					TMP_MeshInfo tMP_MeshInfo = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex];
					int dst = vertices.Length - 4;
					tMP_MeshInfo.SwapVertexData(vertexIndex, dst);
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num3 = TMP_TextUtilities.FindIntersectingWord(m_TextMeshPro, Input.mousePosition, m_Camera);
				if (m_TextPopup_RectTransform != null && m_selectedWord != -1 && (num3 == -1 || num3 != m_selectedWord))
				{
					TMP_WordInfo tMP_WordInfo = m_TextMeshPro.textInfo.wordInfo[m_selectedWord];
					for (int i = 0; i < tMP_WordInfo.characterCount; i++)
					{
						int num4 = tMP_WordInfo.firstCharacterIndex + i;
						int materialReferenceIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].materialReferenceIndex;
						int vertexIndex2 = m_TextMeshPro.textInfo.characterInfo[num4].vertexIndex;
						Color32[] colors2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex2].colors32;
						colors2[vertexIndex2 + 3] = (colors2[vertexIndex2 + 2] = (colors2[vertexIndex2 + 1] = (colors2[vertexIndex2] = colors2[vertexIndex2].Tint(1.33333f))));
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
					m_selectedWord = -1;
				}
				if (num3 != -1 && num3 != m_selectedWord && !Input.GetKey(KeyCode.LeftShift) && !Input.GetKey(KeyCode.RightShift))
				{
					m_selectedWord = num3;
					TMP_WordInfo tMP_WordInfo2 = m_TextMeshPro.textInfo.wordInfo[num3];
					for (int j = 0; j < tMP_WordInfo2.characterCount; j++)
					{
						int num5 = tMP_WordInfo2.firstCharacterIndex + j;
						int materialReferenceIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].materialReferenceIndex;
						int vertexIndex3 = m_TextMeshPro.textInfo.characterInfo[num5].vertexIndex;
						Color32[] colors3 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex3].colors32;
						colors3[vertexIndex3 + 3] = (colors3[vertexIndex3 + 2] = (colors3[vertexIndex3 + 1] = (colors3[vertexIndex3] = colors3[vertexIndex3].Tint(0.75f))));
					}
					m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
				}
				int num6 = TMP_TextUtilities.FindIntersectingLink(m_TextMeshPro, Input.mousePosition, m_Camera);
				if ((num6 == -1 && m_selectedLink != -1) || num6 != m_selectedLink)
				{
					m_TextPopup_RectTransform.gameObject.SetActive(value: false);
					m_selectedLink = -1;
				}
				if (num6 == -1 || num6 == m_selectedLink)
				{
					return;
				}
				m_selectedLink = num6;
				TMP_LinkInfo tMP_LinkInfo = m_TextMeshPro.textInfo.linkInfo[num6];
				RectTransformUtility.ScreenPointToWorldPointInRectangle(m_TextMeshPro.rectTransform, Input.mousePosition, m_Camera, out var worldPoint);
				string linkID = tMP_LinkInfo.GetLinkID();
				if (!(linkID == "id_01"))
				{
					if (linkID == "id_02")
					{
						m_TextPopup_RectTransform.position = worldPoint;
						m_TextPopup_RectTransform.gameObject.SetActive(value: true);
						m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 02";
					}
				}
				else
				{
					m_TextPopup_RectTransform.position = worldPoint;
					m_TextPopup_RectTransform.gameObject.SetActive(value: true);
					m_TextPopup_TMPComponent.text = "You have selected link <#ffff00> ID 01";
				}
			}
			else if (m_lastIndex != -1)
			{
				RestoreCachedVertexAttributes(m_lastIndex);
				m_lastIndex = -1;
			}
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHoveringObject = true;
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHoveringObject = false;
		}

		public void OnPointerClick(PointerEventData eventData)
		{
		}

		public void OnPointerUp(PointerEventData eventData)
		{
		}

		private void RestoreCachedVertexAttributes(int index)
		{
			if (index != -1 && index <= m_TextMeshPro.textInfo.characterCount - 1)
			{
				int materialReferenceIndex = m_TextMeshPro.textInfo.characterInfo[index].materialReferenceIndex;
				int vertexIndex = m_TextMeshPro.textInfo.characterInfo[index].vertexIndex;
				Vector3[] vertices = m_cachedMeshInfoVertexData[materialReferenceIndex].vertices;
				Vector3[] vertices2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].vertices;
				vertices2[vertexIndex] = vertices[vertexIndex];
				vertices2[vertexIndex + 1] = vertices[vertexIndex + 1];
				vertices2[vertexIndex + 2] = vertices[vertexIndex + 2];
				vertices2[vertexIndex + 3] = vertices[vertexIndex + 3];
				Color32[] colors = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				Color32[] colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				colors[vertexIndex] = colors2[vertexIndex];
				colors[vertexIndex + 1] = colors2[vertexIndex + 1];
				colors[vertexIndex + 2] = colors2[vertexIndex + 2];
				colors[vertexIndex + 3] = colors2[vertexIndex + 3];
				Vector2[] uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				Vector2[] uvs2 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				uvs2[vertexIndex] = uvs[vertexIndex];
				uvs2[vertexIndex + 1] = uvs[vertexIndex + 1];
				uvs2[vertexIndex + 2] = uvs[vertexIndex + 2];
				uvs2[vertexIndex + 3] = uvs[vertexIndex + 3];
				Vector2[] uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				Vector2[] uvs4 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				uvs4[vertexIndex] = uvs3[vertexIndex];
				uvs4[vertexIndex + 1] = uvs3[vertexIndex + 1];
				uvs4[vertexIndex + 2] = uvs3[vertexIndex + 2];
				uvs4[vertexIndex + 3] = uvs3[vertexIndex + 3];
				int num = (vertices.Length / 4 - 1) * 4;
				vertices2[num] = vertices[num];
				vertices2[num + 1] = vertices[num + 1];
				vertices2[num + 2] = vertices[num + 2];
				vertices2[num + 3] = vertices[num + 3];
				colors2 = m_cachedMeshInfoVertexData[materialReferenceIndex].colors32;
				Color32[] colors3 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].colors32;
				colors3[num] = colors2[num];
				colors3[num + 1] = colors2[num + 1];
				colors3[num + 2] = colors2[num + 2];
				colors3[num + 3] = colors2[num + 3];
				uvs = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
				Vector2[] uvs5 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs0;
				uvs5[num] = uvs[num];
				uvs5[num + 1] = uvs[num + 1];
				uvs5[num + 2] = uvs[num + 2];
				uvs5[num + 3] = uvs[num + 3];
				uvs3 = m_cachedMeshInfoVertexData[materialReferenceIndex].uvs2;
				Vector2[] uvs6 = m_TextMeshPro.textInfo.meshInfo[materialReferenceIndex].uvs2;
				uvs6[num] = uvs3[num];
				uvs6[num + 1] = uvs3[num + 1];
				uvs6[num + 2] = uvs3[num + 2];
				uvs6[num + 3] = uvs3[num + 3];
				m_TextMeshPro.UpdateVertexData(TMP_VertexDataUpdateFlags.All);
			}
		}
	}
	public class TMP_UiFrameRateCounter : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public float UpdateInterval = 5f;

		private float m_LastInterval;

		private int m_Frames;

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.TopRight;

		private string htmlColorTag;

		private const string fpsLabel = "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS";

		private TextMeshProUGUI m_TextMeshPro;

		private RectTransform m_frameCounter_transform;

		private FpsCounterAnchorPositions last_AnchorPosition;

		private void Awake()
		{
			if (base.enabled)
			{
				UnityEngine.Application.targetFrameRate = 1000;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.AddComponent<RectTransform>();
				m_frameCounter_transform.SetParent(base.transform, worldPositionStays: false);
				m_TextMeshPro = gameObject.AddComponent<TextMeshProUGUI>();
				m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
				m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");
				m_TextMeshPro.enableWordWrapping = false;
				m_TextMeshPro.fontSize = 36f;
				m_TextMeshPro.isOverlay = true;
				Set_FrameCounter_Position(AnchorPosition);
				last_AnchorPosition = AnchorPosition;
			}
		}

		private void Start()
		{
			m_LastInterval = Time.realtimeSinceStartup;
			m_Frames = 0;
		}

		private void Update()
		{
			if (AnchorPosition != last_AnchorPosition)
			{
				Set_FrameCounter_Position(AnchorPosition);
			}
			last_AnchorPosition = AnchorPosition;
			m_Frames++;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (realtimeSinceStartup > m_LastInterval + UpdateInterval)
			{
				float num = (float)m_Frames / (realtimeSinceStartup - m_LastInterval);
				float arg = 1000f / Mathf.Max(num, 1E-05f);
				if (num < 30f)
				{
					htmlColorTag = "<color=yellow>";
				}
				else if (num < 10f)
				{
					htmlColorTag = "<color=red>";
				}
				else
				{
					htmlColorTag = "<color=green>";
				}
				m_TextMeshPro.SetText(htmlColorTag + "{0:2}</color> <#8080ff>FPS \n<#FF8000>{1:2} <#8080ff>MS", num, arg);
				m_Frames = 0;
				m_LastInterval = realtimeSinceStartup;
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomLeft;
				m_frameCounter_transform.pivot = new Vector2(0f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.01f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(0f, 0f);
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.TopRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 1f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.99f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 1f);
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_TextMeshPro.alignment = TextAlignmentOptions.BottomRight;
				m_frameCounter_transform.pivot = new Vector2(1f, 0f);
				m_frameCounter_transform.anchorMin = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchorMax = new Vector2(0.99f, 0.01f);
				m_frameCounter_transform.anchoredPosition = new Vector2(1f, 0f);
				break;
			}
		}
	}
	public class TMPro_InstructionOverlay : MonoBehaviour
	{
		public enum FpsCounterAnchorPositions
		{
			TopLeft,
			BottomLeft,
			TopRight,
			BottomRight
		}

		public FpsCounterAnchorPositions AnchorPosition = FpsCounterAnchorPositions.BottomLeft;

		private const string instructions = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";

		private TextMeshPro m_TextMeshPro;

		private TextContainer m_textContainer;

		private Transform m_frameCounter_transform;

		private Camera m_camera;

		private void Awake()
		{
			if (base.enabled)
			{
				m_camera = Camera.main;
				GameObject gameObject = new GameObject("Frame Counter");
				m_frameCounter_transform = gameObject.transform;
				m_frameCounter_transform.parent = m_camera.transform;
				m_frameCounter_transform.localRotation = Quaternion.identity;
				m_TextMeshPro = gameObject.AddComponent<TextMeshPro>();
				m_TextMeshPro.font = Resources.Load<TMP_FontAsset>("Fonts & Materials/LiberationSans SDF");
				m_TextMeshPro.fontSharedMaterial = Resources.Load<Material>("Fonts & Materials/LiberationSans SDF - Overlay");
				m_TextMeshPro.fontSize = 30f;
				m_TextMeshPro.isOverlay = true;
				m_textContainer = gameObject.GetComponent<TextContainer>();
				Set_FrameCounter_Position(AnchorPosition);
				m_TextMeshPro.text = "Camera Control - <#ffff00>Shift + RMB\n</color>Zoom - <#ffff00>Mouse wheel.";
			}
		}

		private void Set_FrameCounter_Position(FpsCounterAnchorPositions anchor_position)
		{
			switch (anchor_position)
			{
			case FpsCounterAnchorPositions.TopLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.TopLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomLeft:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomLeft;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(0f, 0f, 100f));
				break;
			case FpsCounterAnchorPositions.TopRight:
				m_textContainer.anchorPosition = TextContainerAnchors.TopRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 1f, 100f));
				break;
			case FpsCounterAnchorPositions.BottomRight:
				m_textContainer.anchorPosition = TextContainerAnchors.BottomRight;
				m_frameCounter_transform.position = m_camera.ViewportToWorldPoint(new Vector3(1f, 0f, 100f));
				break;
			}
		}
	}
	public class TeleType : MonoBehaviour
	{
		private string label01 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=1>";

		private string label02 = "Example <sprite=2> of using <sprite=7> <#ffa000>Graphics Inline</color> <sprite=5> with Text in <font=\"Bangers SDF\" material=\"Bangers SDF - Drop Shadow\">TextMesh<#40a0ff>Pro</color></font><sprite=0> and Unity<sprite=2>";

		private TMP_Text m_textMeshPro;

		private void Awake()
		{
			m_textMeshPro = GetComponent<TMP_Text>();
			m_textMeshPro.text = label01;
			m_textMeshPro.enableWordWrapping = true;
			m_textMeshPro.alignment = TextAlignmentOptions.Top;
		}

		private IEnumerator Start()
		{
			m_textMeshPro.ForceMeshUpdate();
			int totalVisibleCharacters = m_textMeshPro.textInfo.characterCount;
			int counter = 0;
			while (true)
			{
				int num = counter % (totalVisibleCharacters + 1);
				m_textMeshPro.maxVisibleCharacters = num;
				if (num >= totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
					m_textMeshPro.text = label02;
					yield return new WaitForSeconds(1f);
					m_textMeshPro.text = label01;
					yield return new WaitForSeconds(1f);
				}
				counter++;
				yield return new WaitForSeconds(0.05f);
			}
		}
	}
	public class TextConsoleSimulator : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(RevealCharacters(m_TextComponent));
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			hasTextChanged = true;
		}

		private IEnumerator RevealCharacters(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = textComponent.textInfo;
			int totalVisibleCharacters = textInfo.characterCount;
			int visibleCount = 0;
			while (true)
			{
				if (hasTextChanged)
				{
					totalVisibleCharacters = textInfo.characterCount;
					hasTextChanged = false;
				}
				if (visibleCount > totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
					visibleCount = 0;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				visibleCount++;
				yield return null;
			}
		}

		private IEnumerator RevealWords(TMP_Text textComponent)
		{
			textComponent.ForceMeshUpdate();
			int totalWordCount = textComponent.textInfo.wordCount;
			int totalVisibleCharacters = textComponent.textInfo.characterCount;
			int counter = 0;
			int visibleCount = 0;
			while (true)
			{
				int num = counter % (totalWordCount + 1);
				if (num == 0)
				{
					visibleCount = 0;
				}
				else if (num < totalWordCount)
				{
					visibleCount = textComponent.textInfo.wordInfo[num - 1].lastCharacterIndex + 1;
				}
				else if (num == totalWordCount)
				{
					visibleCount = totalVisibleCharacters;
				}
				textComponent.maxVisibleCharacters = visibleCount;
				if (visibleCount >= totalVisibleCharacters)
				{
					yield return new WaitForSeconds(1f);
				}
				counter++;
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class TextMeshProFloatingText : MonoBehaviour
	{
		public Font TheFont;

		private GameObject m_floatingText;

		private TextMeshPro m_textMeshPro;

		private TextMesh m_textMesh;

		private Transform m_transform;

		private Transform m_floatingText_Transform;

		private Transform m_cameraTransform;

		private Vector3 lastPOS = Vector3.zero;

		private Quaternion lastRotation = Quaternion.identity;

		public int SpawnType;

		private void Awake()
		{
			m_transform = base.transform;
			m_floatingText = new GameObject(base.name + " floating text");
			m_cameraTransform = Camera.main.transform;
		}

		private void Start()
		{
			if (SpawnType == 0)
			{
				m_textMeshPro = m_floatingText.AddComponent<TextMeshPro>();
				m_textMeshPro.rectTransform.sizeDelta = new Vector2(3f, 3f);
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMeshPro.alignment = TextAlignmentOptions.Center;
				m_textMeshPro.color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				m_textMeshPro.fontSize = 24f;
				m_textMeshPro.enableKerning = false;
				m_textMeshPro.text = string.Empty;
				StartCoroutine(DisplayTextMeshProFloatingText());
			}
			else if (SpawnType == 1)
			{
				m_floatingText_Transform = m_floatingText.transform;
				m_floatingText_Transform.position = m_transform.position + new Vector3(0f, 15f, 0f);
				m_textMesh = m_floatingText.AddComponent<TextMesh>();
				m_textMesh.font = Resources.Load<Font>("Fonts/ARIAL");
				m_textMesh.GetComponent<Renderer>().sharedMaterial = m_textMesh.font.material;
				m_textMesh.color = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue);
				m_textMesh.anchor = TextAnchor.LowerCenter;
				m_textMesh.fontSize = 24;
				StartCoroutine(DisplayTextMeshFloatingText());
			}
			else
			{
				_ = SpawnType;
				_ = 2;
			}
		}

		public IEnumerator DisplayTextMeshProFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = UnityEngine.Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMeshPro.color;
			float alpha = 255f;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMeshPro.text = ((int)current_Count).ToString();
				m_textMeshPro.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return new WaitForEndOfFrame();
			}
			yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshProFloatingText());
		}

		public IEnumerator DisplayTextMeshFloatingText()
		{
			float CountDuration = 2f;
			float starting_Count = UnityEngine.Random.Range(5f, 20f);
			float current_Count = starting_Count;
			Vector3 start_pos = m_floatingText_Transform.position;
			Color32 start_color = m_textMesh.color;
			float alpha = 255f;
			float fadeDuration = 3f / starting_Count * CountDuration;
			while (current_Count > 0f)
			{
				current_Count -= Time.deltaTime / CountDuration * starting_Count;
				if (current_Count <= 3f)
				{
					alpha = Mathf.Clamp(alpha - Time.deltaTime / fadeDuration * 255f, 0f, 255f);
				}
				m_textMesh.text = ((int)current_Count).ToString();
				m_textMesh.color = new Color32(start_color.r, start_color.g, start_color.b, (byte)alpha);
				m_floatingText_Transform.position += new Vector3(0f, starting_Count * Time.deltaTime, 0f);
				if (!lastPOS.Compare(m_cameraTransform.position, 1000) || !lastRotation.Compare(m_cameraTransform.rotation, 1000))
				{
					lastPOS = m_cameraTransform.position;
					lastRotation = m_cameraTransform.rotation;
					m_floatingText_Transform.rotation = lastRotation;
					Vector3 vector = m_transform.position - lastPOS;
					m_transform.forward = new Vector3(vector.x, 0f, vector.z);
				}
				yield return new WaitForEndOfFrame();
			}
			yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 1f));
			m_floatingText_Transform.position = start_pos;
			StartCoroutine(DisplayTextMeshFloatingText());
		}
	}
	public class TextMeshSpawner : MonoBehaviour
	{
		public int SpawnType;

		public int NumberOfNPC = 12;

		public Font TheFont;

		private TextMeshProFloatingText floatingText_Script;

		private void Awake()
		{
		}

		private void Start()
		{
			for (int i = 0; i < NumberOfNPC; i++)
			{
				if (SpawnType == 0)
				{
					GameObject gameObject = new GameObject();
					gameObject.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.5f, UnityEngine.Random.Range(-95f, 95f));
					TextMeshPro textMeshPro = gameObject.AddComponent<TextMeshPro>();
					textMeshPro.fontSize = 96f;
					textMeshPro.text = "!";
					textMeshPro.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					floatingText_Script = gameObject.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 0;
				}
				else
				{
					GameObject gameObject2 = new GameObject();
					gameObject2.transform.position = new Vector3(UnityEngine.Random.Range(-95f, 95f), 0.5f, UnityEngine.Random.Range(-95f, 95f));
					TextMesh textMesh = gameObject2.AddComponent<TextMesh>();
					textMesh.GetComponent<Renderer>().sharedMaterial = TheFont.material;
					textMesh.font = TheFont;
					textMesh.anchor = TextAnchor.LowerCenter;
					textMesh.fontSize = 96;
					textMesh.color = new Color32(byte.MaxValue, byte.MaxValue, 0, byte.MaxValue);
					textMesh.text = "!";
					floatingText_Script = gameObject2.AddComponent<TextMeshProFloatingText>();
					floatingText_Script.SpawnType = 1;
				}
			}
		}
	}
	public class VertexColorCycler : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int currentCharacter = 0;
			_ = (Color32)m_TextComponent.color;
			while (true)
			{
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int materialReferenceIndex = textInfo.characterInfo[currentCharacter].materialReferenceIndex;
				Color32[] colors = textInfo.meshInfo[materialReferenceIndex].colors32;
				int vertexIndex = textInfo.characterInfo[currentCharacter].vertexIndex;
				if (textInfo.characterInfo[currentCharacter].isVisible)
				{
					colors[vertexIndex + 3] = (colors[vertexIndex + 2] = (colors[vertexIndex + 1] = (colors[vertexIndex] = new Color32((byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), (byte)UnityEngine.Random.Range(0, 255), byte.MaxValue))));
					m_TextComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
				}
				currentCharacter = (currentCharacter + 1) % characterCount;
				yield return new WaitForSeconds(0.05f);
			}
		}
	}
	public class VertexJitter : MonoBehaviour
	{
		private struct VertexAnim
		{
			public float angleRange;

			public float angle;

			public float speed;
		}

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			int loopCount = 0;
			hasTextChanged = true;
			VertexAnim[] vertexAnim = new VertexAnim[1024];
			for (int i = 0; i < 1024; i++)
			{
				vertexAnim[i].angleRange = UnityEngine.Random.Range(10f, 25f);
				vertexAnim[i].speed = UnityEngine.Random.Range(1f, 3f);
			}
			TMP_MeshInfo[] cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfo = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				for (int j = 0; j < characterCount; j++)
				{
					if (textInfo.characterInfo[j].isVisible)
					{
						VertexAnim vertexAnim2 = vertexAnim[j];
						int materialReferenceIndex = textInfo.characterInfo[j].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[j].vertexIndex;
						Vector3[] vertices = cachedMeshInfo[materialReferenceIndex].vertices;
						Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						vertices2[vertexIndex] = vertices[vertexIndex] - vector;
						vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
						vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
						vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
						vertexAnim2.angle = Mathf.SmoothStep(0f - vertexAnim2.angleRange, vertexAnim2.angleRange, Mathf.PingPong((float)loopCount / 25f * vertexAnim2.speed, 1f));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(UnityEngine.Random.Range(-0.25f, 0.25f), UnityEngine.Random.Range(-0.25f, 0.25f), 0f) * CurveScale, Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-5f, 5f) * AngleMultiplier), Vector3.one);
						vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);
						vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector;
						vertices2[vertexIndex + 1] += vector;
						vertices2[vertexIndex + 2] += vector;
						vertices2[vertexIndex + 3] += vector;
						vertexAnim[j] = vertexAnim2;
					}
				}
				for (int k = 0; k < textInfo.meshInfo.Length; k++)
				{
					textInfo.meshInfo[k].mesh.vertices = textInfo.meshInfo[k].vertices;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[k].mesh, k);
				}
				loopCount++;
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexShakeA : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float ScaleMultiplier = 1f;

		public float RotationMultiplier = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-0.25f, 0.25f) * RotationMultiplier);
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
							float num2 = UnityEngine.Random.Range(0.995f - 0.001f * ScaleMultiplier, 1.005f + 0.001f * ScaleMultiplier);
							Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, q, Vector3.one * num2);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexShakeB : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if ((bool)(obj = m_TextComponent))
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			Vector3[][] copyOfVertices = new Vector3[0][];
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					if (copyOfVertices.Length < textInfo.meshInfo.Length)
					{
						copyOfVertices = new Vector3[textInfo.meshInfo.Length][];
					}
					for (int i = 0; i < textInfo.meshInfo.Length; i++)
					{
						int num = textInfo.meshInfo[i].vertices.Length;
						copyOfVertices[i] = new Vector3[num];
					}
					hasTextChanged = false;
				}
				if (textInfo.characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				int lineCount = textInfo.lineCount;
				for (int j = 0; j < lineCount; j++)
				{
					int firstCharacterIndex = textInfo.lineInfo[j].firstCharacterIndex;
					int lastCharacterIndex = textInfo.lineInfo[j].lastCharacterIndex;
					Vector3 vector = (textInfo.characterInfo[firstCharacterIndex].bottomLeft + textInfo.characterInfo[lastCharacterIndex].topRight) / 2f;
					Quaternion q = Quaternion.Euler(0f, 0f, UnityEngine.Random.Range(-0.25f, 0.25f));
					for (int k = firstCharacterIndex; k <= lastCharacterIndex; k++)
					{
						if (textInfo.characterInfo[k].isVisible)
						{
							int materialReferenceIndex = textInfo.characterInfo[k].materialReferenceIndex;
							int vertexIndex = textInfo.characterInfo[k].vertexIndex;
							Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
							Vector3 vector2 = (vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f;
							copyOfVertices[materialReferenceIndex][vertexIndex] = vertices[vertexIndex] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = vertices[vertexIndex + 1] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = vertices[vertexIndex + 2] - vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = vertices[vertexIndex + 3] - vector2;
							float num2 = UnityEngine.Random.Range(0.95f, 1.05f);
							Matrix4x4 matrix4x = Matrix4x4.TRS(Vector3.one, Quaternion.identity, Vector3.one * num2);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector2;
							copyOfVertices[materialReferenceIndex][vertexIndex] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] -= vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] -= vector;
							matrix4x = Matrix4x4.TRS(Vector3.one, q, Vector3.one);
							copyOfVertices[materialReferenceIndex][vertexIndex] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 1]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 2]);
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] = matrix4x.MultiplyPoint3x4(copyOfVertices[materialReferenceIndex][vertexIndex + 3]);
							copyOfVertices[materialReferenceIndex][vertexIndex] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 1] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 2] += vector;
							copyOfVertices[materialReferenceIndex][vertexIndex + 3] += vector;
						}
					}
				}
				for (int l = 0; l < textInfo.meshInfo.Length; l++)
				{
					textInfo.meshInfo[l].mesh.vertices = copyOfVertices[l];
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[l].mesh, l);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class VertexZoom : MonoBehaviour
	{
		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private TMP_Text m_TextComponent;

		private bool hasTextChanged;

		private void Awake()
		{
			m_TextComponent = GetComponent<TMP_Text>();
		}

		private void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		}

		private void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
		}

		private void Start()
		{
			StartCoroutine(AnimateVertexColors());
		}

		private void ON_TEXT_CHANGED(UnityEngine.Object obj)
		{
			if (obj == m_TextComponent)
			{
				hasTextChanged = true;
			}
		}

		private IEnumerator AnimateVertexColors()
		{
			m_TextComponent.ForceMeshUpdate();
			TMP_TextInfo textInfo = m_TextComponent.textInfo;
			TMP_MeshInfo[] cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
			List<float> modifiedCharScale = new List<float>();
			List<int> scaleSortingOrder = new List<int>();
			hasTextChanged = true;
			while (true)
			{
				if (hasTextChanged)
				{
					cachedMeshInfoVertexData = textInfo.CopyMeshInfoVertexData();
					hasTextChanged = false;
				}
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					yield return new WaitForSeconds(0.25f);
					continue;
				}
				modifiedCharScale.Clear();
				scaleSortingOrder.Clear();
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						Vector3[] vertices = cachedMeshInfoVertexData[materialReferenceIndex].vertices;
						Vector3 vector = (Vector2)((vertices[vertexIndex] + vertices[vertexIndex + 2]) / 2f);
						Vector3[] vertices2 = textInfo.meshInfo[materialReferenceIndex].vertices;
						vertices2[vertexIndex] = vertices[vertexIndex] - vector;
						vertices2[vertexIndex + 1] = vertices[vertexIndex + 1] - vector;
						vertices2[vertexIndex + 2] = vertices[vertexIndex + 2] - vector;
						vertices2[vertexIndex + 3] = vertices[vertexIndex + 3] - vector;
						float num = UnityEngine.Random.Range(1f, 1.5f);
						modifiedCharScale.Add(num);
						scaleSortingOrder.Add(modifiedCharScale.Count - 1);
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, 0f, 0f), Quaternion.identity, Vector3.one * num);
						vertices2[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex]);
						vertices2[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 1]);
						vertices2[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 2]);
						vertices2[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices2[vertexIndex + 3]);
						vertices2[vertexIndex] += vector;
						vertices2[vertexIndex + 1] += vector;
						vertices2[vertexIndex + 2] += vector;
						vertices2[vertexIndex + 3] += vector;
						Vector2[] uvs = cachedMeshInfoVertexData[materialReferenceIndex].uvs0;
						Vector2[] uvs2 = textInfo.meshInfo[materialReferenceIndex].uvs0;
						uvs2[vertexIndex] = uvs[vertexIndex];
						uvs2[vertexIndex + 1] = uvs[vertexIndex + 1];
						uvs2[vertexIndex + 2] = uvs[vertexIndex + 2];
						uvs2[vertexIndex + 3] = uvs[vertexIndex + 3];
						Color32[] colors = cachedMeshInfoVertexData[materialReferenceIndex].colors32;
						Color32[] colors2 = textInfo.meshInfo[materialReferenceIndex].colors32;
						colors2[vertexIndex] = colors[vertexIndex];
						colors2[vertexIndex + 1] = colors[vertexIndex + 1];
						colors2[vertexIndex + 2] = colors[vertexIndex + 2];
						colors2[vertexIndex + 3] = colors[vertexIndex + 3];
					}
				}
				for (int j = 0; j < textInfo.meshInfo.Length; j++)
				{
					scaleSortingOrder.Sort((int a, int b) => modifiedCharScale[a].CompareTo(modifiedCharScale[b]));
					textInfo.meshInfo[j].SortGeometry(scaleSortingOrder);
					textInfo.meshInfo[j].mesh.vertices = textInfo.meshInfo[j].vertices;
					textInfo.meshInfo[j].mesh.uv = textInfo.meshInfo[j].uvs0;
					textInfo.meshInfo[j].mesh.colors32 = textInfo.meshInfo[j].colors32;
					m_TextComponent.UpdateGeometry(textInfo.meshInfo[j].mesh, j);
				}
				yield return new WaitForSeconds(0.1f);
			}
		}
	}
	public class WarpTextExample : MonoBehaviour
	{
		private TMP_Text m_TextComponent;

		public AnimationCurve VertexCurve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.25f, 2f), new Keyframe(0.5f, 0f), new Keyframe(0.75f, 2f), new Keyframe(1f, 0f));

		public float AngleMultiplier = 1f;

		public float SpeedMultiplier = 1f;

		public float CurveScale = 1f;

		private void Awake()
		{
			m_TextComponent = base.gameObject.GetComponent<TMP_Text>();
		}

		private void Start()
		{
			StartCoroutine(WarpText());
		}

		private AnimationCurve CopyAnimationCurve(AnimationCurve curve)
		{
			return new AnimationCurve
			{
				keys = curve.keys
			};
		}

		private IEnumerator WarpText()
		{
			VertexCurve.preWrapMode = WrapMode.Once;
			VertexCurve.postWrapMode = WrapMode.Once;
			m_TextComponent.havePropertiesChanged = true;
			CurveScale *= 10f;
			float old_CurveScale = CurveScale;
			AnimationCurve old_curve = CopyAnimationCurve(VertexCurve);
			while (true)
			{
				if (!m_TextComponent.havePropertiesChanged && old_CurveScale == CurveScale && old_curve.keys[1].value == VertexCurve.keys[1].value)
				{
					yield return null;
					continue;
				}
				old_CurveScale = CurveScale;
				old_curve = CopyAnimationCurve(VertexCurve);
				m_TextComponent.ForceMeshUpdate();
				TMP_TextInfo textInfo = m_TextComponent.textInfo;
				int characterCount = textInfo.characterCount;
				if (characterCount == 0)
				{
					continue;
				}
				float x = m_TextComponent.bounds.min.x;
				float x2 = m_TextComponent.bounds.max.x;
				for (int i = 0; i < characterCount; i++)
				{
					if (textInfo.characterInfo[i].isVisible)
					{
						int vertexIndex = textInfo.characterInfo[i].vertexIndex;
						int materialReferenceIndex = textInfo.characterInfo[i].materialReferenceIndex;
						Vector3[] vertices = textInfo.meshInfo[materialReferenceIndex].vertices;
						Vector3 vector = new Vector2((vertices[vertexIndex].x + vertices[vertexIndex + 2].x) / 2f, textInfo.characterInfo[i].baseLine);
						vertices[vertexIndex] += -vector;
						vertices[vertexIndex + 1] += -vector;
						vertices[vertexIndex + 2] += -vector;
						vertices[vertexIndex + 3] += -vector;
						float num = (vector.x - x) / (x2 - x);
						float num2 = num + 0.0001f;
						float y = VertexCurve.Evaluate(num) * CurveScale;
						float y2 = VertexCurve.Evaluate(num2) * CurveScale;
						Vector3 lhs = new Vector3(1f, 0f, 0f);
						Vector3 rhs = new Vector3(num2 * (x2 - x) + x, y2) - new Vector3(vector.x, y);
						float num3 = Mathf.Acos(Vector3.Dot(lhs, rhs.normalized)) * 57.29578f;
						float z = ((Vector3.Cross(lhs, rhs).z > 0f) ? num3 : (360f - num3));
						Matrix4x4 matrix4x = Matrix4x4.TRS(new Vector3(0f, y, 0f), Quaternion.Euler(0f, 0f, z), Vector3.one);
						vertices[vertexIndex] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex]);
						vertices[vertexIndex + 1] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 1]);
						vertices[vertexIndex + 2] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 2]);
						vertices[vertexIndex + 3] = matrix4x.MultiplyPoint3x4(vertices[vertexIndex + 3]);
						vertices[vertexIndex] += vector;
						vertices[vertexIndex + 1] += vector;
						vertices[vertexIndex + 2] += vector;
						vertices[vertexIndex + 3] += vector;
					}
				}
				m_TextComponent.UpdateVertexData();
				yield return new WaitForSeconds(0.025f);
			}
		}
	}
}
namespace UnityStandardAssets.CrossPlatformInput
{
	public class AxisTouchButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public string axisName = "Horizontal";

		public float axisValue = 1f;

		public float responseSpeed = 3f;

		public float returnToCentreSpeed = 3f;

		private AxisTouchButton m_PairedWith;

		private CrossPlatformInputManager.VirtualAxis m_Axis;

		private void OnEnable()
		{
			if (!CrossPlatformInputManager.AxisExists(axisName))
			{
				m_Axis = new CrossPlatformInputManager.VirtualAxis(axisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_Axis);
			}
			else
			{
				m_Axis = CrossPlatformInputManager.VirtualAxisReference(axisName);
			}
			FindPairedButton();
		}

		private void FindPairedButton()
		{
			if (!(UnityEngine.Object.FindObjectsOfType(typeof(AxisTouchButton)) is AxisTouchButton[] array))
			{
				return;
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].axisName == axisName && array[i] != this)
				{
					m_PairedWith = array[i];
				}
			}
		}

		private void OnDisable()
		{
			m_Axis.Remove();
		}

		public void OnPointerDown(PointerEventData data)
		{
			if (m_PairedWith == null)
			{
				FindPairedButton();
			}
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, axisValue, responseSpeed * Time.deltaTime));
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Axis.Update(Mathf.MoveTowards(m_Axis.GetValue, 0f, responseSpeed * Time.deltaTime));
		}
	}
	public class ButtonHandler : MonoBehaviour
	{
		public string Name;

		private void OnEnable()
		{
		}

		public void SetDownState()
		{
			CrossPlatformInputManager.SetButtonDown(Name);
		}

		public void SetUpState()
		{
			CrossPlatformInputManager.SetButtonUp(Name);
		}

		public void SetAxisPositiveState()
		{
			CrossPlatformInputManager.SetAxisPositive(Name);
		}

		public void SetAxisNeutralState()
		{
			CrossPlatformInputManager.SetAxisZero(Name);
		}

		public void SetAxisNegativeState()
		{
			CrossPlatformInputManager.SetAxisNegative(Name);
		}

		public void Update()
		{
		}
	}
	public static class CrossPlatformInputManager
	{
		public enum ActiveInputMethod
		{
			Hardware,
			Touch
		}

		public class VirtualAxis
		{
			private float m_Value;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public float GetValue => m_Value;

			public float GetValueRaw => m_Value;

			public VirtualAxis(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualAxis(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Remove()
			{
				UnRegisterVirtualAxis(name);
			}

			public void Update(float value)
			{
				m_Value = value;
			}
		}

		public class VirtualButton
		{
			private int m_LastPressedFrame = -5;

			private int m_ReleasedFrame = -5;

			private bool m_Pressed;

			public string name { get; private set; }

			public bool matchWithInputManager { get; private set; }

			public bool GetButton => m_Pressed;

			public bool GetButtonDown => m_LastPressedFrame - Time.frameCount == -1;

			public bool GetButtonUp => m_ReleasedFrame == Time.frameCount - 1;

			public VirtualButton(string name)
				: this(name, matchToInputSettings: true)
			{
			}

			public VirtualButton(string name, bool matchToInputSettings)
			{
				this.name = name;
				matchWithInputManager = matchToInputSettings;
			}

			public void Pressed()
			{
				if (!m_Pressed)
				{
					m_Pressed = true;
					m_LastPressedFrame = Time.frameCount;
				}
			}

			public void Released()
			{
				m_Pressed = false;
				m_ReleasedFrame = Time.frameCount;
			}

			public void Remove()
			{
				UnRegisterVirtualButton(name);
			}
		}

		private static VirtualInput activeInput;

		private static VirtualInput s_TouchInput;

		private static VirtualInput s_HardwareInput;

		public static Vector3 mousePosition => activeInput.MousePosition();

		static CrossPlatformInputManager()
		{
			s_TouchInput = new MobileInput();
			s_HardwareInput = new StandaloneInput();
			activeInput = s_TouchInput;
		}

		public static void SwitchActiveInputMethod(ActiveInputMethod activeInputMethod)
		{
			switch (activeInputMethod)
			{
			case ActiveInputMethod.Hardware:
				activeInput = s_HardwareInput;
				break;
			case ActiveInputMethod.Touch:
				activeInput = s_TouchInput;
				break;
			}
		}

		public static bool AxisExists(string name)
		{
			return activeInput.AxisExists(name);
		}

		public static bool ButtonExists(string name)
		{
			return activeInput.ButtonExists(name);
		}

		public static void RegisterVirtualAxis(VirtualAxis axis)
		{
			activeInput.RegisterVirtualAxis(axis);
		}

		public static void RegisterVirtualButton(VirtualButton button)
		{
			activeInput.RegisterVirtualButton(button);
		}

		public static void UnRegisterVirtualAxis(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			activeInput.UnRegisterVirtualAxis(name);
		}

		public static void UnRegisterVirtualButton(string name)
		{
			activeInput.UnRegisterVirtualButton(name);
		}

		public static VirtualAxis VirtualAxisReference(string name)
		{
			return activeInput.VirtualAxisReference(name);
		}

		public static float GetAxis(string name)
		{
			return GetAxis(name, raw: false);
		}

		public static float GetAxisRaw(string name)
		{
			return GetAxis(name, raw: true);
		}

		private static float GetAxis(string name, bool raw)
		{
			return activeInput.GetAxis(name, raw);
		}

		public static bool GetButton(string name)
		{
			return activeInput.GetButton(name);
		}

		public static bool GetButtonDown(string name)
		{
			return activeInput.GetButtonDown(name);
		}

		public static bool GetButtonUp(string name)
		{
			return activeInput.GetButtonUp(name);
		}

		public static void SetButtonDown(string name)
		{
			activeInput.SetButtonDown(name);
		}

		public static void SetButtonUp(string name)
		{
			activeInput.SetButtonUp(name);
		}

		public static void SetAxisPositive(string name)
		{
			activeInput.SetAxisPositive(name);
		}

		public static void SetAxisNegative(string name)
		{
			activeInput.SetAxisNegative(name);
		}

		public static void SetAxisZero(string name)
		{
			activeInput.SetAxisZero(name);
		}

		public static void SetAxis(string name, float value)
		{
			activeInput.SetAxis(name, value);
		}

		public static void SetVirtualMousePositionX(float f)
		{
			activeInput.SetVirtualMousePositionX(f);
		}

		public static void SetVirtualMousePositionY(float f)
		{
			activeInput.SetVirtualMousePositionY(f);
		}

		public static void SetVirtualMousePositionZ(float f)
		{
			activeInput.SetVirtualMousePositionZ(f);
		}
	}
	public class InputAxisScrollbar : MonoBehaviour
	{
		public string axis;

		private void Update()
		{
		}

		public void HandleInput(float value)
		{
			CrossPlatformInputManager.SetAxis(axis, value * 2f - 1f);
		}
	}
	public class Joystick : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public int MovementRange = 100;

		public AxisOption axesToUse;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		private Vector3 m_StartPos;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private void OnEnable()
		{
			CreateVirtualAxes();
		}

		private void Start()
		{
			m_StartPos = base.transform.position;
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			Vector3 vector = m_StartPos - value;
			vector.y = 0f - vector.y;
			vector /= (float)MovementRange;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(0f - vector.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(vector.y);
			}
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		public void OnDrag(PointerEventData data)
		{
			Vector3 zero = Vector3.zero;
			if (m_UseX)
			{
				int value = (int)(data.position.x - m_StartPos.x);
				value = Mathf.Clamp(value, -MovementRange, MovementRange);
				zero.x = value;
			}
			if (m_UseY)
			{
				int value2 = (int)(data.position.y - m_StartPos.y);
				value2 = Mathf.Clamp(value2, -MovementRange, MovementRange);
				zero.y = value2;
			}
			base.transform.position = new Vector3(m_StartPos.x + zero.x, m_StartPos.y + zero.y, m_StartPos.z + zero.z);
			UpdateVirtualAxes(base.transform.position);
		}

		public void OnPointerUp(PointerEventData data)
		{
			base.transform.position = m_StartPos;
			UpdateVirtualAxes(m_StartPos);
		}

		public void OnPointerDown(PointerEventData data)
		{
		}

		private void OnDisable()
		{
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Remove();
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Remove();
			}
		}
	}
	[ExecuteInEditMode]
	public class MobileControlRig : MonoBehaviour
	{
		private void OnEnable()
		{
			CheckEnableControlRig();
		}

		private void Start()
		{
			if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>();
			}
		}

		private void CheckEnableControlRig()
		{
			EnableControlRig(enabled: true);
		}

		private void EnableControlRig(bool enabled)
		{
			try
			{
				foreach (Transform item in base.transform)
				{
					item.gameObject.SetActive(enabled);
				}
			}
			catch (Exception)
			{
			}
		}
	}
	[RequireComponent(typeof(Image))]
	public class TouchPad : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler
	{
		public enum AxisOption
		{
			Both,
			OnlyHorizontal,
			OnlyVertical
		}

		public enum ControlStyle
		{
			Absolute,
			Relative,
			Swipe
		}

		public AxisOption axesToUse;

		public ControlStyle controlStyle;

		public string horizontalAxisName = "Horizontal";

		public string verticalAxisName = "Vertical";

		public float Xsensitivity = 1f;

		public float Ysensitivity = 1f;

		private Vector3 m_StartPos;

		private Vector2 m_PreviousDelta;

		private Vector3 m_JoytickOutput;

		private bool m_UseX;

		private bool m_UseY;

		private CrossPlatformInputManager.VirtualAxis m_HorizontalVirtualAxis;

		private CrossPlatformInputManager.VirtualAxis m_VerticalVirtualAxis;

		private bool m_Dragging;

		private int m_Id = -1;

		private Vector2 m_PreviousTouchPos;

		private Vector3 m_Center;

		private Image m_Image;

		private void OnEnable()
		{
			CreateVirtualAxes();
		}

		private void Start()
		{
			m_Image = GetComponent<Image>();
			m_Center = m_Image.transform.position;
		}

		private void CreateVirtualAxes()
		{
			m_UseX = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyHorizontal;
			m_UseY = axesToUse == AxisOption.Both || axesToUse == AxisOption.OnlyVertical;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(horizontalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis = new CrossPlatformInputManager.VirtualAxis(verticalAxisName);
				CrossPlatformInputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);
			}
		}

		private void UpdateVirtualAxes(Vector3 value)
		{
			value = value.normalized;
			if (m_UseX)
			{
				m_HorizontalVirtualAxis.Update(value.x);
			}
			if (m_UseY)
			{
				m_VerticalVirtualAxis.Update(value.y);
			}
		}

		public void OnPointerDown(PointerEventData data)
		{
			m_Dragging = true;
			m_Id = data.pointerId;
			if (controlStyle != 0)
			{
				m_Center = data.position;
			}
		}

		private void Update()
		{
			if (m_Dragging && Input.touchCount >= m_Id + 1 && m_Id != -1)
			{
				if (controlStyle == ControlStyle.Swipe)
				{
					m_Center = m_PreviousTouchPos;
					m_PreviousTouchPos = Input.touches[m_Id].position;
				}
				Vector2 normalized = new Vector2(Input.touches[m_Id].position.x - m_Center.x, Input.touches[m_Id].position.y - m_Center.y).normalized;
				normalized.x *= Xsensitivity;
				normalized.y *= Ysensitivity;
				UpdateVirtualAxes(new Vector3(normalized.x, normalized.y, 0f));
			}
		}

		public void OnPointerUp(PointerEventData data)
		{
			m_Dragging = false;
			m_Id = -1;
			UpdateVirtualAxes(Vector3.zero);
		}

		private void OnDisable()
		{
			if (CrossPlatformInputManager.AxisExists(horizontalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(horizontalAxisName);
			}
			if (CrossPlatformInputManager.AxisExists(verticalAxisName))
			{
				CrossPlatformInputManager.UnRegisterVirtualAxis(verticalAxisName);
			}
		}
	}
	public abstract class VirtualInput
	{
		protected Dictionary<string, CrossPlatformInputManager.VirtualAxis> m_VirtualAxes = new Dictionary<string, CrossPlatformInputManager.VirtualAxis>();

		protected Dictionary<string, CrossPlatformInputManager.VirtualButton> m_VirtualButtons = new Dictionary<string, CrossPlatformInputManager.VirtualButton>();

		protected List<string> m_AlwaysUseVirtual = new List<string>();

		public Vector3 virtualMousePosition { get; private set; }

		public bool AxisExists(string name)
		{
			return m_VirtualAxes.ContainsKey(name);
		}

		public bool ButtonExists(string name)
		{
			return m_VirtualButtons.ContainsKey(name);
		}

		public void RegisterVirtualAxis(CrossPlatformInputManager.VirtualAxis axis)
		{
			if (m_VirtualAxes.ContainsKey(axis.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual axis named " + axis.name + " registered.");
				return;
			}
			m_VirtualAxes.Add(axis.name, axis);
			if (!axis.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(axis.name);
			}
		}

		public void RegisterVirtualButton(CrossPlatformInputManager.VirtualButton button)
		{
			if (m_VirtualButtons.ContainsKey(button.name))
			{
				UnityEngine.Debug.LogError("There is already a virtual button named " + button.name + " registered.");
				return;
			}
			m_VirtualButtons.Add(button.name, button);
			if (!button.matchWithInputManager)
			{
				m_AlwaysUseVirtual.Add(button.name);
			}
		}

		public void UnRegisterVirtualAxis(string name)
		{
			if (m_VirtualAxes.ContainsKey(name))
			{
				m_VirtualAxes.Remove(name);
			}
		}

		public void UnRegisterVirtualButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				m_VirtualButtons.Remove(name);
			}
		}

		public CrossPlatformInputManager.VirtualAxis VirtualAxisReference(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				return null;
			}
			return m_VirtualAxes[name];
		}

		public void SetVirtualMousePositionX(float f)
		{
			virtualMousePosition = new Vector3(f, virtualMousePosition.y, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionY(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, f, virtualMousePosition.z);
		}

		public void SetVirtualMousePositionZ(float f)
		{
			virtualMousePosition = new Vector3(virtualMousePosition.x, virtualMousePosition.y, f);
		}

		public abstract float GetAxis(string name, bool raw);

		public abstract bool GetButton(string name);

		public abstract bool GetButtonDown(string name);

		public abstract bool GetButtonUp(string name);

		public abstract void SetButtonDown(string name);

		public abstract void SetButtonUp(string name);

		public abstract void SetAxisPositive(string name);

		public abstract void SetAxisNegative(string name);

		public abstract void SetAxisZero(string name);

		public abstract void SetAxis(string name, float value);

		public abstract Vector3 MousePosition();
	}
}
namespace UnityStandardAssets.CrossPlatformInput.PlatformSpecific
{
	public class MobileInput : VirtualInput
	{
		private void AddButton(string name)
		{
			CrossPlatformInputManager.RegisterVirtualButton(new CrossPlatformInputManager.VirtualButton(name));
		}

		private void AddAxes(string name)
		{
			CrossPlatformInputManager.RegisterVirtualAxis(new CrossPlatformInputManager.VirtualAxis(name));
		}

		public override float GetAxis(string name, bool raw)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			return m_VirtualAxes[name].GetValue;
		}

		public override void SetButtonDown(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Pressed();
		}

		public override void SetButtonUp(string name)
		{
			if (!m_VirtualButtons.ContainsKey(name))
			{
				AddButton(name);
			}
			m_VirtualButtons[name].Released();
		}

		public override void SetAxisPositive(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(1f);
		}

		public override void SetAxisNegative(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(-1f);
		}

		public override void SetAxisZero(string name)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(0f);
		}

		public override void SetAxis(string name, float value)
		{
			if (!m_VirtualAxes.ContainsKey(name))
			{
				AddAxes(name);
			}
			m_VirtualAxes[name].Update(value);
		}

		public override bool GetButtonDown(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonDown;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonDown;
		}

		public override bool GetButtonUp(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButtonUp;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButtonUp;
		}

		public override bool GetButton(string name)
		{
			if (m_VirtualButtons.ContainsKey(name))
			{
				return m_VirtualButtons[name].GetButton;
			}
			AddButton(name);
			return m_VirtualButtons[name].GetButton;
		}

		public override Vector3 MousePosition()
		{
			return base.virtualMousePosition;
		}
	}
	public class StandaloneInput : VirtualInput
	{
		public override float GetAxis(string name, bool raw)
		{
			if (!raw)
			{
				return Input.GetAxis(name);
			}
			return Input.GetAxisRaw(name);
		}

		public override bool GetButton(string name)
		{
			return Input.GetButton(name);
		}

		public override bool GetButtonDown(string name)
		{
			return Input.GetButtonDown(name);
		}

		public override bool GetButtonUp(string name)
		{
			return Input.GetButtonUp(name);
		}

		public override void SetButtonDown(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetButtonUp(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisPositive(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisNegative(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxisZero(string name)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override void SetAxis(string name, float value)
		{
			throw new Exception(" This is not possible to be called for standalone input. Please check your platform and code where this is called");
		}

		public override Vector3 MousePosition()
		{
			return Input.mousePosition;
		}
	}
}
namespace ExitGames.Demos.DemoPunVoice
{
	[RequireComponent(typeof(PhotonView))]
	[RequireComponent(typeof(Rigidbody))]
	[RequireComponent(typeof(Animator))]
	public abstract class BaseController : MonoBehaviour
	{
		public Camera ControllerCamera;

		protected Rigidbody rigidBody;

		protected Animator animator;

		protected Transform camTrans;

		private float h;

		private float v;

		[SerializeField]
		protected float speed = 5f;

		[SerializeField]
		private float cameraDistance;

		protected virtual void OnEnable()
		{
			ChangePOV.CameraChanged += ChangePOV_CameraChanged;
		}

		protected virtual void OnDisable()
		{
			ChangePOV.CameraChanged -= ChangePOV_CameraChanged;
		}

		protected virtual void ChangePOV_CameraChanged(Camera camera)
		{
			if (camera != ControllerCamera)
			{
				base.enabled = false;
				HideCamera(ControllerCamera);
			}
			else
			{
				ShowCamera(ControllerCamera);
			}
		}

		protected virtual void Start()
		{
			if (GetComponent<PhotonView>().IsMine)
			{
				Init();
				SetCamera();
			}
			else
			{
				base.enabled = false;
			}
		}

		protected virtual void Init()
		{
			rigidBody = GetComponent<Rigidbody>();
			animator = GetComponent<Animator>();
		}

		protected virtual void SetCamera()
		{
			camTrans = ControllerCamera.transform;
			camTrans.position += cameraDistance * base.transform.forward;
		}

		protected virtual void UpdateAnimator(float h, float v)
		{
			bool value = h != 0f || v != 0f;
			animator.SetBool("IsWalking", value);
		}

		protected virtual void FixedUpdate()
		{
			h = CrossPlatformInputManager.GetAxisRaw("Horizontal");
			v = CrossPlatformInputManager.GetAxisRaw("Vertical");
			if (Mathf.Abs(h) < 0.5f)
			{
				h = 0f;
			}
			else
			{
				h = Mathf.Sign(h);
			}
			if (Mathf.Abs(v) < 0.5f)
			{
				v = 0f;
			}
			else
			{
				v = Mathf.Sign(v);
			}
			UpdateAnimator(h, v);
			Move(h, v);
		}

		protected virtual void ShowCamera(Camera camera)
		{
			if (camera != null)
			{
				camera.gameObject.SetActive(value: true);
			}
		}

		protected virtual void HideCamera(Camera camera)
		{
			if (camera != null)
			{
				camera.gameObject.SetActive(value: false);
			}
		}

		protected abstract void Move(float h, float v);
	}
	[RequireComponent(typeof(Toggle))]
	[DisallowMultipleComponent]
	public class BetterToggle : MonoBehaviour
	{
		public delegate void OnToggle(Toggle toggle);

		private Toggle toggle;

		public static event OnToggle ToggleValueChanged;

		private void Start()
		{
			toggle = GetComponent<Toggle>();
			toggle.onValueChanged.AddListener(delegate
			{
				OnToggleValueChanged();
			});
		}

		public void OnToggleValueChanged()
		{
			if (BetterToggle.ToggleValueChanged != null)
			{
				BetterToggle.ToggleValueChanged(toggle);
			}
		}
	}
	public class ChangePOV : MonoBehaviour, IMatchmakingCallbacks
	{
		public delegate void OnCameraChanged(Camera newCamera);

		private FirstPersonController firstPersonController;

		private ThirdPersonController thirdPersonController;

		private OrthographicController orthographicController;

		private Vector3 initialCameraPosition;

		private Quaternion initialCameraRotation;

		private Camera defaultCamera;

		[SerializeField]
		private GameObject ButtonsHolder;

		[SerializeField]
		private Button FirstPersonCamActivator;

		[SerializeField]
		private Button ThirdPersonCamActivator;

		[SerializeField]
		private Button OrthographicCamActivator;

		public static event OnCameraChanged CameraChanged;

		private void OnEnable()
		{
			CharacterInstantiation.CharacterInstantiated += OnCharacterInstantiated;
			PhotonNetwork.AddCallbackTarget(this);
		}

		private void OnDisable()
		{
			CharacterInstantiation.CharacterInstantiated -= OnCharacterInstantiated;
			PhotonNetwork.RemoveCallbackTarget(this);
		}

		private void Start()
		{
			defaultCamera = Camera.main;
			initialCameraPosition = new Vector3(defaultCamera.transform.position.x, defaultCamera.transform.position.y, defaultCamera.transform.position.z);
			initialCameraRotation = new Quaternion(defaultCamera.transform.rotation.x, defaultCamera.transform.rotation.y, defaultCamera.transform.rotation.z, defaultCamera.transform.rotation.w);
			FirstPersonCamActivator.gameObject.SetActive(value: false);
			ThirdPersonCamActivator.onClick.AddListener(ThirdPersonMode);
			OrthographicCamActivator.onClick.AddListener(OrthographicMode);
		}

		private void OnCharacterInstantiated(GameObject character)
		{
			firstPersonController = character.GetComponent<FirstPersonController>();
			firstPersonController.enabled = false;
			thirdPersonController = character.GetComponent<ThirdPersonController>();
			thirdPersonController.enabled = false;
			orthographicController = character.GetComponent<OrthographicController>();
			ButtonsHolder.SetActive(value: true);
		}

		private void FirstPersonMode()
		{
			ToggleMode(firstPersonController);
		}

		private void ThirdPersonMode()
		{
			ToggleMode(thirdPersonController);
		}

		private void OrthographicMode()
		{
			ToggleMode(orthographicController);
		}

		private void ToggleMode(BaseController controller)
		{
			if (!(controller == null) && !(controller.ControllerCamera == null))
			{
				controller.ControllerCamera.gameObject.SetActive(value: true);
				controller.enabled = true;
				FirstPersonCamActivator.interactable = !(controller == firstPersonController);
				ThirdPersonCamActivator.interactable = !(controller == thirdPersonController);
				OrthographicCamActivator.interactable = !(controller == orthographicController);
				BroadcastChange(controller.ControllerCamera);
			}
		}

		private void BroadcastChange(Camera camera)
		{
			if (!(camera == null) && ChangePOV.CameraChanged != null)
			{
				ChangePOV.CameraChanged(camera);
			}
		}

		public void OnFriendListUpdate(List<FriendInfo> friendList)
		{
		}

		public void OnCreatedRoom()
		{
		}

		public void OnCreateRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinedRoom()
		{
		}

		public void OnJoinRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinRandomFailed(short returnCode, string message)
		{
		}

		public void OnLeftRoom()
		{
			if (!ConnectionHandler.AppQuits)
			{
				defaultCamera.gameObject.SetActive(value: true);
				FirstPersonCamActivator.interactable = true;
				ThirdPersonCamActivator.interactable = true;
				OrthographicCamActivator.interactable = false;
				defaultCamera.transform.position = initialCameraPosition;
				defaultCamera.transform.rotation = initialCameraRotation;
				ButtonsHolder.SetActive(value: false);
			}
		}
	}
	public class CharacterInstantiation : MonoBehaviourPunCallbacks, IOnEventCallback
	{
		public enum SpawnSequence
		{
			Connection,
			Random,
			RoundRobin
		}

		public delegate void OnCharacterInstantiated(GameObject character);

		public Transform SpawnPosition;

		public float PositionOffset = 2f;

		public GameObject[] PrefabsToInstantiate;

		public List<Transform> SpawnPoints;

		public bool AutoSpawn = true;

		public bool UseRandomOffset = true;

		public SpawnSequence Sequence;

		[SerializeField]
		private byte manualInstantiationEventCode = 1;

		protected int lastUsedSpawnPointIndex = -1;

		[SerializeField]
		private bool manualInstantiation;

		[SerializeField]
		private bool differentPrefabs;

		[SerializeField]
		private string localPrefabSuffix;

		[SerializeField]
		private string remotePrefabSuffix;

		public static event OnCharacterInstantiated CharacterInstantiated;

		public override void OnJoinedRoom()
		{
			if (!AutoSpawn || PrefabsToInstantiate == null)
			{
				return;
			}
			int num = PhotonNetwork.LocalPlayer.ActorNumber;
			if (num < 1)
			{
				num = 1;
			}
			int num2 = (num - 1) % PrefabsToInstantiate.Length;
			GetSpawnPoint(out var spawnPos, out var spawnRot);
			Camera.main.transform.position += spawnPos;
			if (manualInstantiation)
			{
				ManualInstantiation(num2, spawnPos, spawnRot);
				return;
			}
			GameObject gameObject = PrefabsToInstantiate[num2];
			gameObject = PhotonNetwork.Instantiate(gameObject.name, spawnPos, spawnRot, 0);
			if (CharacterInstantiation.CharacterInstantiated != null)
			{
				CharacterInstantiation.CharacterInstantiated(gameObject);
			}
		}

		private void ManualInstantiation(int index, Vector3 position, Quaternion rotation)
		{
			GameObject gameObject = PrefabsToInstantiate[index];
			GameObject gameObject2 = ((!differentPrefabs) ? UnityEngine.Object.Instantiate(gameObject, position, rotation) : UnityEngine.Object.Instantiate(Resources.Load($"{gameObject.name}{localPrefabSuffix}") as GameObject, position, rotation));
			PhotonView component = gameObject2.GetComponent<PhotonView>();
			if (PhotonNetwork.AllocateViewID(component))
			{
				object[] eventContent = new object[4]
				{
					index,
					gameObject2.transform.position,
					gameObject2.transform.rotation,
					component.ViewID
				};
				RaiseEventOptions raiseEventOptions = new RaiseEventOptions
				{
					Receivers = ReceiverGroup.Others,
					CachingOption = EventCaching.AddToRoomCache
				};
				PhotonNetwork.RaiseEvent(manualInstantiationEventCode, eventContent, raiseEventOptions, SendOptions.SendReliable);
				if (CharacterInstantiation.CharacterInstantiated != null)
				{
					CharacterInstantiation.CharacterInstantiated(gameObject2);
				}
			}
			else
			{
				UnityEngine.Debug.LogError("Failed to allocate a ViewId.");
				UnityEngine.Object.Destroy(gameObject2);
			}
		}

		public void OnEvent(EventData photonEvent)
		{
			if (photonEvent.Code == manualInstantiationEventCode)
			{
				object[] array = photonEvent.CustomData as object[];
				int num = (int)array[0];
				GameObject gameObject = PrefabsToInstantiate[num];
				Vector3 position = (Vector3)array[1];
				Quaternion rotation = (Quaternion)array[2];
				GameObject gameObject2 = ((!differentPrefabs) ? UnityEngine.Object.Instantiate(gameObject, position, Quaternion.identity) : UnityEngine.Object.Instantiate(Resources.Load($"{gameObject.name}{remotePrefabSuffix}") as GameObject, position, rotation));
				gameObject2.GetComponent<PhotonView>().ViewID = (int)array[3];
			}
		}

		protected virtual void GetSpawnPoint(out Vector3 spawnPos, out Quaternion spawnRot)
		{
			Transform spawnPoint = GetSpawnPoint();
			if (spawnPoint != null)
			{
				spawnPos = spawnPoint.position;
				spawnRot = spawnPoint.rotation;
			}
			else
			{
				spawnPos = new Vector3(0f, 0f, 0f);
				spawnRot = new Quaternion(0f, 0f, 0f, 1f);
			}
			if (UseRandomOffset)
			{
				UnityEngine.Random.InitState((int)(Time.time * 10000f));
				Vector3 insideUnitSphere = UnityEngine.Random.insideUnitSphere;
				insideUnitSphere.y = 0f;
				insideUnitSphere = insideUnitSphere.normalized;
				spawnPos += PositionOffset * insideUnitSphere;
			}
		}

		protected virtual Transform GetSpawnPoint()
		{
			if (SpawnPoints == null || SpawnPoints.Count == 0)
			{
				return null;
			}
			switch (Sequence)
			{
			case SpawnSequence.Connection:
			{
				int actorNumber = PhotonNetwork.LocalPlayer.ActorNumber;
				return SpawnPoints[(actorNumber != -1) ? (actorNumber % SpawnPoints.Count) : 0];
			}
			case SpawnSequence.RoundRobin:
				lastUsedSpawnPointIndex++;
				if (lastUsedSpawnPointIndex >= SpawnPoints.Count)
				{
					lastUsedSpawnPointIndex = 0;
				}
				return SpawnPoints[lastUsedSpawnPointIndex];
			case SpawnSequence.Random:
				return SpawnPoints[UnityEngine.Random.Range(0, SpawnPoints.Count)];
			default:
				return null;
			}
		}
	}
	public class FirstPersonController : BaseController
	{
		[SerializeField]
		private MouseLookHelper mouseLook = new MouseLookHelper();

		private float oldYRotation;

		private Quaternion velRotation;

		public Vector3 Velocity => rigidBody.velocity;

		protected override void SetCamera()
		{
			base.SetCamera();
			mouseLook.Init(base.transform, camTrans);
		}

		protected override void Move(float h, float v)
		{
			Vector3 velocity = camTrans.forward * v + camTrans.right * h;
			velocity.x *= speed;
			velocity.z *= speed;
			velocity.y = 0f;
			rigidBody.velocity = velocity;
		}

		private void Update()
		{
			RotateView();
		}

		private void RotateView()
		{
			oldYRotation = base.transform.eulerAngles.y;
			mouseLook.LookRotation(base.transform, camTrans);
			velRotation = Quaternion.AngleAxis(base.transform.eulerAngles.y - oldYRotation, Vector3.up);
			rigidBody.velocity = velRotation * rigidBody.velocity;
		}
	}
	[RequireComponent(typeof(Canvas))]
	public class Highlighter : MonoBehaviour
	{
		private Canvas canvas;

		private PhotonVoiceView photonVoiceView;

		[SerializeField]
		private Image recorderSprite;

		[SerializeField]
		private Image speakerSprite;

		[SerializeField]
		private Text bufferLagText;

		private bool showSpeakerLag;

		private void OnEnable()
		{
			ChangePOV.CameraChanged += ChangePOV_CameraChanged;
			VoiceDemoUI.DebugToggled += VoiceDemoUI_DebugToggled;
		}

		private void OnDisable()
		{
			ChangePOV.CameraChanged -= ChangePOV_CameraChanged;
			VoiceDemoUI.DebugToggled -= VoiceDemoUI_DebugToggled;
		}

		private void VoiceDemoUI_DebugToggled(bool debugMode)
		{
			showSpeakerLag = debugMode;
		}

		private void ChangePOV_CameraChanged(Camera camera)
		{
			canvas.worldCamera = camera;
		}

		private void Awake()
		{
			canvas = GetComponent<Canvas>();
			if (canvas != null && canvas.worldCamera == null)
			{
				canvas.worldCamera = Camera.main;
			}
			photonVoiceView = GetComponentInParent<PhotonVoiceView>();
		}

		private void Update()
		{
			recorderSprite.enabled = photonVoiceView.IsRecording;
			speakerSprite.enabled = photonVoiceView.IsSpeaking;
			bufferLagText.enabled = showSpeakerLag && photonVoiceView.IsSpeaking;
			if (bufferLagText.enabled)
			{
				bufferLagText.text = $"{photonVoiceView.SpeakerInUse.Lag}";
			}
		}

		private void LateUpdate()
		{
			if (!(canvas == null) && !(canvas.worldCamera == null))
			{
				base.transform.rotation = Quaternion.Euler(0f, canvas.worldCamera.transform.eulerAngles.y, 0f);
			}
		}
	}
	public class OrthographicController : ThirdPersonController
	{
		public float smoothing = 5f;

		private Vector3 offset;

		protected override void Init()
		{
			base.Init();
			ControllerCamera = Camera.main;
		}

		protected override void SetCamera()
		{
			base.SetCamera();
			offset = camTrans.position - base.transform.position;
		}

		protected override void Move(float h, float v)
		{
			base.Move(h, v);
			CameraFollow();
		}

		private void CameraFollow()
		{
			Vector3 b = base.transform.position + offset;
			camTrans.position = Vector3.Lerp(camTrans.position, b, smoothing * Time.deltaTime);
		}
	}
	public class ThirdPersonController : BaseController
	{
		[SerializeField]
		private float movingTurnSpeed = 360f;

		protected override void Move(float h, float v)
		{
			rigidBody.velocity = v * speed * base.transform.forward;
			base.transform.rotation *= Quaternion.AngleAxis(movingTurnSpeed * h * Time.deltaTime, Vector3.up);
		}
	}
	public class VoiceDemoUI : MonoBehaviour
	{
		public delegate void OnDebugToggle(bool debugMode);

		[SerializeField]
		private Text punState;

		[SerializeField]
		private Text voiceState;

		private PhotonVoiceNetwork punVoiceNetwork;

		private Canvas canvas;

		[SerializeField]
		private Button punSwitch;

		private Text punSwitchText;

		[SerializeField]
		private Button voiceSwitch;

		private Text voiceSwitchText;

		[SerializeField]
		private Button calibrateButton;

		private Text calibrateText;

		[SerializeField]
		private Text voiceDebugText;

		public Recorder recorder;

		[SerializeField]
		private GameObject inGameSettings;

		[SerializeField]
		private GameObject globalSettings;

		[SerializeField]
		private Text devicesInfoText;

		private GameObject debugGO;

		private bool debugMode;

		private float volumeBeforeMute;

		private DebugLevel previousDebugLevel;

		[SerializeField]
		private int calibrationMilliSeconds = 2000;

		public bool DebugMode
		{
			get
			{
				return debugMode;
			}
			set
			{
				debugMode = value;
				debugGO.SetActive(debugMode);
				voiceDebugText.text = string.Empty;
				if (debugMode)
				{
					previousDebugLevel = punVoiceNetwork.Client.LoadBalancingPeer.DebugOut;
					punVoiceNetwork.Client.LoadBalancingPeer.DebugOut = DebugLevel.ALL;
				}
				else
				{
					punVoiceNetwork.Client.LoadBalancingPeer.DebugOut = previousDebugLevel;
				}
				if (VoiceDemoUI.DebugToggled != null)
				{
					VoiceDemoUI.DebugToggled(debugMode);
				}
			}
		}

		public static event OnDebugToggle DebugToggled;

		private void Awake()
		{
			punVoiceNetwork = PhotonVoiceNetwork.Instance;
		}

		private void OnEnable()
		{
			ChangePOV.CameraChanged += OnCameraChanged;
			BetterToggle.ToggleValueChanged += BetterToggle_ToggleValueChanged;
			CharacterInstantiation.CharacterInstantiated += CharacterInstantiation_CharacterInstantiated;
			punVoiceNetwork.Client.StateChanged += VoiceClientStateChanged;
			PhotonNetwork.NetworkingClient.StateChanged += PunClientStateChanged;
		}

		private void OnDisable()
		{
			ChangePOV.CameraChanged -= OnCameraChanged;
			BetterToggle.ToggleValueChanged -= BetterToggle_ToggleValueChanged;
			CharacterInstantiation.CharacterInstantiated -= CharacterInstantiation_CharacterInstantiated;
			punVoiceNetwork.Client.StateChanged -= VoiceClientStateChanged;
			PhotonNetwork.NetworkingClient.StateChanged -= PunClientStateChanged;
		}

		private void CharacterInstantiation_CharacterInstantiated(GameObject character)
		{
			if (!recorder)
			{
				PhotonVoiceView component = character.GetComponent<PhotonVoiceView>();
				if (component.IsRecorder)
				{
					recorder = component.RecorderInUse;
				}
			}
		}

		private void InitToggles(Toggle[] toggles)
		{
			if (toggles == null)
			{
				return;
			}
			foreach (Toggle toggle in toggles)
			{
				switch (toggle.name)
				{
				case "Mute":
					toggle.isOn = AudioListener.volume <= 0.001f;
					break;
				case "VoiceDetection":
					toggle.isOn = recorder != null && recorder.VoiceDetection;
					break;
				case "DebugVoice":
					toggle.isOn = DebugMode;
					break;
				case "Transmit":
					toggle.isOn = recorder != null && recorder.TransmitEnabled;
					break;
				case "DebugEcho":
					toggle.isOn = recorder != null && recorder.DebugEchoMode;
					break;
				case "AutoConnectAndJoin":
					toggle.isOn = punVoiceNetwork.AutoConnectAndJoin;
					break;
				case "AutoLeaveAndDisconnect":
					toggle.isOn = punVoiceNetwork.AutoLeaveAndDisconnect;
					break;
				}
			}
		}

		private void BetterToggle_ToggleValueChanged(Toggle toggle)
		{
			switch (toggle.name)
			{
			case "Mute":
				if (toggle.isOn)
				{
					volumeBeforeMute = AudioListener.volume;
					AudioListener.volume = 0f;
				}
				else
				{
					AudioListener.volume = volumeBeforeMute;
					volumeBeforeMute = 0f;
				}
				break;
			case "Transmit":
				if ((bool)recorder)
				{
					recorder.TransmitEnabled = toggle.isOn;
				}
				break;
			case "VoiceDetection":
				if ((bool)recorder)
				{
					recorder.VoiceDetection = toggle.isOn;
				}
				break;
			case "DebugEcho":
				if ((bool)recorder)
				{
					recorder.DebugEchoMode = toggle.isOn;
				}
				break;
			case "DebugVoice":
				DebugMode = toggle.isOn;
				break;
			case "AutoConnectAndJoin":
				punVoiceNetwork.AutoConnectAndJoin = toggle.isOn;
				break;
			case "AutoLeaveAndDisconnect":
				punVoiceNetwork.AutoLeaveAndDisconnect = toggle.isOn;
				break;
			}
		}

		private void OnCameraChanged(Camera newCamera)
		{
			canvas.worldCamera = newCamera;
		}

		private void Start()
		{
			canvas = GetComponentInChildren<Canvas>();
			if (punSwitch != null)
			{
				punSwitchText = punSwitch.GetComponentInChildren<Text>();
				punSwitch.onClick.AddListener(PunSwitchOnClick);
			}
			if (voiceSwitch != null)
			{
				voiceSwitchText = voiceSwitch.GetComponentInChildren<Text>();
				voiceSwitch.onClick.AddListener(VoiceSwitchOnClick);
			}
			if (calibrateButton != null)
			{
				calibrateButton.onClick.AddListener(CalibrateButtonOnClick);
				calibrateText = calibrateButton.GetComponentInChildren<Text>();
			}
			if (punState != null)
			{
				debugGO = punState.transform.parent.gameObject;
			}
			volumeBeforeMute = AudioListener.volume;
			previousDebugLevel = punVoiceNetwork.Client.LoadBalancingPeer.DebugOut;
			if (globalSettings != null)
			{
				globalSettings.SetActive(value: true);
				InitToggles(globalSettings.GetComponentsInChildren<Toggle>());
			}
			if (!(devicesInfoText != null))
			{
				return;
			}
			if (UnityMicrophone.devices == null || UnityMicrophone.devices.Length == 0)
			{
				devicesInfoText.enabled = true;
				devicesInfoText.color = Color.red;
				devicesInfoText.text = "No microphone device detected!";
				return;
			}
			if (UnityMicrophone.devices.Length == 1)
			{
				devicesInfoText.text = $"Mic.: {UnityMicrophone.devices[0]}";
				return;
			}
			devicesInfoText.text = $"Multi.Mic.Devices:\n0. {UnityMicrophone.devices[0]} (active)\n";
			for (int i = 1; i < UnityMicrophone.devices.Length; i++)
			{
				devicesInfoText.text += $"{i}. {UnityMicrophone.devices[i]}\n";
			}
		}

		private void PunSwitchOnClick()
		{
			if (PhotonNetwork.NetworkClientState == ClientState.Joined)
			{
				PhotonNetwork.Disconnect();
			}
			else if (PhotonNetwork.NetworkClientState == ClientState.Disconnected || PhotonNetwork.NetworkClientState == ClientState.PeerCreated)
			{
				PhotonNetwork.ConnectUsingSettings();
			}
		}

		private void VoiceSwitchOnClick()
		{
			if (punVoiceNetwork.ClientState == ClientState.Joined)
			{
				punVoiceNetwork.Disconnect();
			}
			else if (punVoiceNetwork.ClientState == ClientState.PeerCreated || punVoiceNetwork.ClientState == ClientState.Disconnected)
			{
				punVoiceNetwork.ConnectAndJoinRoom();
			}
		}

		private void CalibrateButtonOnClick()
		{
			if ((bool)recorder && !recorder.VoiceDetectorCalibrating)
			{
				recorder.VoiceDetectorCalibrate(calibrationMilliSeconds);
			}
		}

		private void Update()
		{
			if (recorder != null && recorder.LevelMeter != null)
			{
				voiceDebugText.text = $"Amp: avg. {recorder.LevelMeter.CurrentAvgAmp:0.000000}, peak {recorder.LevelMeter.CurrentPeakAmp:0.000000}";
			}
		}

		private void PunClientStateChanged(ClientState fromState, ClientState toState)
		{
			punState.text = $"PUN: {toState}";
			switch (toState)
			{
			case ClientState.PeerCreated:
			case ClientState.Disconnected:
				punSwitch.interactable = true;
				punSwitchText.text = "PUN Connect";
				break;
			case ClientState.Joined:
				punSwitch.interactable = true;
				punSwitchText.text = "PUN Disconnect";
				break;
			default:
				punSwitch.interactable = false;
				punSwitchText.text = "PUN busy";
				break;
			}
			UpdateUiBasedOnVoiceState(punVoiceNetwork.ClientState);
		}

		private void VoiceClientStateChanged(ClientState fromState, ClientState toState)
		{
			UpdateUiBasedOnVoiceState(toState);
		}

		private void UpdateUiBasedOnVoiceState(ClientState voiceClientState)
		{
			voiceState.text = $"PhotonVoice: {voiceClientState}";
			switch (voiceClientState)
			{
			case ClientState.Joined:
				voiceSwitch.interactable = true;
				inGameSettings.SetActive(value: true);
				voiceSwitchText.text = "Voice Disconnect";
				InitToggles(inGameSettings.GetComponentsInChildren<Toggle>());
				if (recorder != null)
				{
					calibrateButton.interactable = !recorder.VoiceDetectorCalibrating;
					calibrateText.text = (recorder.VoiceDetectorCalibrating ? "Calibrating" : $"Calibrate ({calibrationMilliSeconds / 1000}s)");
				}
				else
				{
					calibrateButton.interactable = false;
					calibrateText.text = "Unavailable";
				}
				break;
			case ClientState.PeerCreated:
			case ClientState.Disconnected:
				if (PhotonNetwork.InRoom)
				{
					voiceSwitch.interactable = true;
					voiceSwitchText.text = "Voice Connect";
					voiceDebugText.text = string.Empty;
				}
				else
				{
					voiceSwitch.interactable = false;
					voiceSwitchText.text = "Voice N/A";
					voiceDebugText.text = string.Empty;
				}
				calibrateButton.interactable = false;
				voiceSwitchText.text = "Voice Connect";
				calibrateText.text = "Unavailable";
				inGameSettings.SetActive(value: false);
				break;
			default:
				voiceSwitch.interactable = false;
				voiceSwitchText.text = "Voice busy";
				break;
			}
		}
	}
}
namespace Photon.Voice.Unity.Demos
{
	public class BackgroundMusicController : MonoBehaviour
	{
		[SerializeField]
		private Text volumeText;

		[SerializeField]
		private Slider volumeSlider;

		[SerializeField]
		private AudioSource audioSource;

		[SerializeField]
		private float initialVolume = 0.125f;

		private void Awake()
		{
			volumeSlider.minValue = 0f;
			volumeSlider.maxValue = 1f;
			volumeSlider.SetSingleOnValueChangedCallback(OnVolumeChanged);
			volumeSlider.value = initialVolume;
			OnVolumeChanged(initialVolume);
		}

		private void OnVolumeChanged(float newValue)
		{
			volumeText.text = $"BG Volume: {newValue:0.###}";
			audioSource.volume = newValue;
		}
	}
	public class SidebarToggle : MonoBehaviour
	{
		[SerializeField]
		private Button sidebarButton;

		[SerializeField]
		private RectTransform panelsHolder;

		private float sidebarWidth = 300f;

		private bool sidebarOpen = true;

		private void Awake()
		{
			sidebarButton.onClick.RemoveAllListeners();
			sidebarButton.onClick.AddListener(ToggleSidebar);
			ToggleSidebar(sidebarOpen);
		}

		[ContextMenu("ToggleSidebar")]
		private void ToggleSidebar()
		{
			sidebarOpen = !sidebarOpen;
			ToggleSidebar(sidebarOpen);
		}

		private void ToggleSidebar(bool open)
		{
			if (!open)
			{
				panelsHolder.SetPosX(0f);
			}
			else
			{
				panelsHolder.SetPosX(sidebarWidth);
			}
		}
	}
	public static class UiExtensions
	{
		public static void SetPosX(this RectTransform rectTransform, float x)
		{
			rectTransform.anchoredPosition3D = new Vector3(x, rectTransform.anchoredPosition3D.y, rectTransform.anchoredPosition3D.z);
		}

		public static void SetHeight(this RectTransform rectTransform, float h)
		{
			rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, h);
		}

		public static void SetValue(this Toggle toggle, bool isOn)
		{
			toggle.SetIsOnWithoutNotify(isOn);
		}

		public static void SetValue(this Slider slider, float v)
		{
			slider.SetValueWithoutNotify(v);
		}

		public static void SetValue(this InputField inputField, string v)
		{
			inputField.SetTextWithoutNotify(v);
		}

		public static void DestroyChildren(this Transform transform)
		{
			if ((bool)transform && transform != null)
			{
				for (int num = transform.childCount - 1; num >= 0; num--)
				{
					UnityEngine.Object.Destroy(transform.GetChild(num).gameObject);
				}
				transform.DetachChildren();
			}
		}

		public static void Hide(this CanvasGroup canvasGroup, bool blockRaycasts = false, bool interactable = false)
		{
			canvasGroup.alpha = 0f;
			canvasGroup.blocksRaycasts = blockRaycasts;
			canvasGroup.interactable = interactable;
		}

		public static void Show(this CanvasGroup canvasGroup, bool blockRaycasts = true, bool interactable = true)
		{
			canvasGroup.alpha = 1f;
			canvasGroup.blocksRaycasts = blockRaycasts;
			canvasGroup.interactable = interactable;
		}

		public static bool IsHidden(this CanvasGroup canvasGroup)
		{
			return canvasGroup.alpha <= 0f;
		}

		public static bool IsShown(this CanvasGroup canvasGroup)
		{
			return canvasGroup.alpha > 0f;
		}

		public static void SetSingleOnClickCallback(this Button button, UnityAction action)
		{
			button.onClick.RemoveAllListeners();
			button.onClick.AddListener(action);
		}

		public static void SetSingleOnValueChangedCallback(this Toggle toggle, UnityAction<bool> action)
		{
			toggle.onValueChanged.RemoveAllListeners();
			toggle.onValueChanged.AddListener(action);
		}

		public static void SetSingleOnValueChangedCallback(this InputField inputField, UnityAction<string> action)
		{
			inputField.onValueChanged.RemoveAllListeners();
			inputField.onValueChanged.AddListener(action);
		}

		public static void SetSingleOnEndEditCallback(this InputField inputField, UnityAction<string> action)
		{
			inputField.onEndEdit.RemoveAllListeners();
			inputField.onEndEdit.AddListener(action);
		}

		public static void SetSingleOnValueChangedCallback(this Dropdown inputField, UnityAction<int> action)
		{
			inputField.onValueChanged.RemoveAllListeners();
			inputField.onValueChanged.AddListener(action);
		}

		public static void SetSingleOnValueChangedCallback(this Slider slider, UnityAction<float> action)
		{
			slider.onValueChanged.RemoveAllListeners();
			slider.onValueChanged.AddListener(action);
		}
	}
}
namespace Photon.Voice.Unity.Demos.DemoVoiceUI
{
	public class CodecSettingsUI : MonoBehaviour
	{
		[SerializeField]
		private Dropdown frameDurationDropdown;

		[SerializeField]
		private Dropdown samplingRateDropdown;

		[SerializeField]
		private InputField bitrateInputField;

		[SerializeField]
		private Recorder recorder;

		private static readonly List<string> frameDurationOptions = new List<string> { "2.5ms", "5ms", "10ms", "20ms", "40ms", "60ms" };

		private static readonly List<string> samplingRateOptions = new List<string> { "8kHz", "12kHz", "16kHz", "24kHz", "48kHz" };

		private void Awake()
		{
			frameDurationDropdown.ClearOptions();
			frameDurationDropdown.AddOptions(frameDurationOptions);
			InitFrameDuration();
			frameDurationDropdown.SetSingleOnValueChangedCallback(OnFrameDurationChanged);
			samplingRateDropdown.ClearOptions();
			samplingRateDropdown.AddOptions(samplingRateOptions);
			InitSamplingRate();
			samplingRateDropdown.SetSingleOnValueChangedCallback(OnSamplingRateChanged);
			bitrateInputField.SetSingleOnValueChangedCallback(OnBitrateChanged);
			InitBitrate();
		}

		private void Update()
		{
			InitFrameDuration();
			InitSamplingRate();
			InitBitrate();
		}

		private void OnBitrateChanged(string newBitrateString)
		{
			if (int.TryParse(newBitrateString, out var result))
			{
				recorder.Bitrate = result;
				if (recorder.RequiresRestart)
				{
					recorder.RestartRecording();
				}
			}
		}

		private void OnFrameDurationChanged(int index)
		{
			OpusCodec.FrameDuration frameDuration = recorder.FrameDuration;
			switch (index)
			{
			case 0:
				frameDuration = OpusCodec.FrameDuration.Frame2dot5ms;
				break;
			case 1:
				frameDuration = OpusCodec.FrameDuration.Frame5ms;
				break;
			case 2:
				frameDuration = OpusCodec.FrameDuration.Frame10ms;
				break;
			case 3:
				frameDuration = OpusCodec.FrameDuration.Frame20ms;
				break;
			case 4:
				frameDuration = OpusCodec.FrameDuration.Frame40ms;
				break;
			case 5:
				frameDuration = OpusCodec.FrameDuration.Frame60ms;
				break;
			}
			recorder.FrameDuration = frameDuration;
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		private void OnSamplingRateChanged(int index)
		{
			SamplingRate samplingRate = recorder.SamplingRate;
			switch (index)
			{
			case 0:
				samplingRate = SamplingRate.Sampling08000;
				break;
			case 1:
				samplingRate = SamplingRate.Sampling12000;
				break;
			case 2:
				samplingRate = SamplingRate.Sampling16000;
				break;
			case 3:
				samplingRate = SamplingRate.Sampling24000;
				break;
			case 4:
				samplingRate = SamplingRate.Sampling48000;
				break;
			}
			recorder.SamplingRate = samplingRate;
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		private void InitFrameDuration()
		{
			int value = 0;
			switch (recorder.FrameDuration)
			{
			case OpusCodec.FrameDuration.Frame5ms:
				value = 1;
				break;
			case OpusCodec.FrameDuration.Frame10ms:
				value = 2;
				break;
			case OpusCodec.FrameDuration.Frame20ms:
				value = 3;
				break;
			case OpusCodec.FrameDuration.Frame40ms:
				value = 4;
				break;
			case OpusCodec.FrameDuration.Frame60ms:
				value = 5;
				break;
			}
			frameDurationDropdown.value = value;
		}

		private void InitSamplingRate()
		{
			int value = 0;
			switch (recorder.SamplingRate)
			{
			case SamplingRate.Sampling12000:
				value = 1;
				break;
			case SamplingRate.Sampling16000:
				value = 2;
				break;
			case SamplingRate.Sampling24000:
				value = 3;
				break;
			case SamplingRate.Sampling48000:
				value = 4;
				break;
			}
			samplingRateDropdown.value = value;
		}

		private void InitBitrate()
		{
			bitrateInputField.text = recorder.Bitrate.ToString();
		}
	}
	[RequireComponent(typeof(VoiceConnection), typeof(ConnectAndJoin))]
	public class DemoVoiceUI : MonoBehaviour, IInRoomCallbacks, IMatchmakingCallbacks
	{
		[SerializeField]
		private Text connectionStatusText;

		[SerializeField]
		private Text serverStatusText;

		[SerializeField]
		private Text roomStatusText;

		[SerializeField]
		private Text inputWarningText;

		[SerializeField]
		private Text rttText;

		[SerializeField]
		private Text rttVariationText;

		[SerializeField]
		private Text packetLossWarningText;

		[SerializeField]
		private InputField localNicknameText;

		[SerializeField]
		private Toggle debugEchoToggle;

		[SerializeField]
		private Toggle reliableTransmissionToggle;

		[SerializeField]
		private Toggle encryptionToggle;

		[SerializeField]
		private GameObject webRtcDspGameObject;

		[SerializeField]
		private Toggle aecToggle;

		[SerializeField]
		private Toggle aecHighPassToggle;

		[SerializeField]
		private InputField reverseStreamDelayInputField;

		[SerializeField]
		private Toggle noiseSuppressionToggle;

		[SerializeField]
		private Toggle agcToggle;

		[SerializeField]
		private Slider agcCompressionGainSlider;

		[SerializeField]
		private Toggle vadToggle;

		[SerializeField]
		private Toggle muteToggle;

		[SerializeField]
		private Toggle streamAudioClipToggle;

		[SerializeField]
		private Toggle audioToneToggle;

		[SerializeField]
		private Toggle dspToggle;

		[SerializeField]
		private Toggle highPassToggle;

		[SerializeField]
		private Toggle photonVadToggle;

		[SerializeField]
		private GameObject microphoneSetupGameObject;

		[SerializeField]
		private bool defaultTransmitEnabled;

		[SerializeField]
		private int screenWidth = 800;

		[SerializeField]
		private int screenHeight = 600;

		[SerializeField]
		private bool fullScreen;

		[SerializeField]
		private InputField roomNameInputField;

		[SerializeField]
		private InputField globalMinDelaySoftInputField;

		[SerializeField]
		private InputField globalMaxDelaySoftInputField;

		[SerializeField]
		private InputField globalMaxDelayHardInputField;

		[SerializeField]
		private int rttYellowThreshold = 100;

		[SerializeField]
		private int rttRedThreshold = 160;

		[SerializeField]
		private int rttVariationYellowThreshold = 25;

		[SerializeField]
		private int rttVariationRedThreshold = 50;

		private GameObject compressionGainGameObject;

		private Text compressionGainText;

		private GameObject aecOptionsGameObject;

		public Transform RemoteVoicesPanel;

		protected VoiceConnection voiceConnection;

		private WebRtcAudioDsp voiceAudioPreprocessor;

		private ConnectAndJoin connectAndJoin;

		private readonly Color warningColor = new Color(0.9f, 0.5f, 0f, 1f);

		private readonly Color okColor = new Color(0f, 0.6f, 0.2f, 1f);

		private readonly Color redColor = new Color(1f, 0f, 0f, 1f);

		private readonly Color defaultColor = new Color(0f, 0f, 0f, 1f);

		private void Awake()
		{
			Screen.SetResolution(screenWidth, screenHeight, fullScreen);
			connectAndJoin = GetComponent<ConnectAndJoin>();
			voiceConnection = GetComponent<VoiceConnection>();
			voiceAudioPreprocessor = voiceConnection.PrimaryRecorder.GetComponent<WebRtcAudioDsp>();
			compressionGainGameObject = agcCompressionGainSlider.transform.parent.gameObject;
			compressionGainText = compressionGainGameObject.GetComponentInChildren<Text>();
			aecOptionsGameObject = aecHighPassToggle.transform.parent.gameObject;
			SetDefaults();
			InitUiCallbacks();
			InitUiValues();
			GetSavedNickname();
		}

		protected virtual void SetDefaults()
		{
			muteToggle.isOn = !defaultTransmitEnabled;
		}

		private void OnEnable()
		{
			voiceConnection.SpeakerLinked += OnSpeakerCreated;
			voiceConnection.Client.AddCallbackTarget(this);
		}

		private void OnDisable()
		{
			voiceConnection.SpeakerLinked -= OnSpeakerCreated;
			voiceConnection.Client.RemoveCallbackTarget(this);
		}

		private void GetSavedNickname()
		{
			string @string = PlayerPrefs.GetString("vNick");
			if (!string.IsNullOrEmpty(@string))
			{
				localNicknameText.text = @string;
				voiceConnection.Client.NickName = @string;
			}
		}

		protected virtual void OnSpeakerCreated(Speaker speaker)
		{
			speaker.gameObject.transform.SetParent(RemoteVoicesPanel, worldPositionStays: false);
			speaker.GetComponent<RemoteSpeakerUI>().Init(voiceConnection);
			speaker.OnRemoteVoiceRemoveAction = (Action<Speaker>)Delegate.Combine(speaker.OnRemoteVoiceRemoveAction, new Action<Speaker>(OnRemoteVoiceRemove));
		}

		private void OnRemoteVoiceRemove(Speaker speaker)
		{
			if (speaker != null)
			{
				UnityEngine.Object.Destroy(speaker.gameObject);
			}
		}

		private void ToggleMute(bool isOn)
		{
			muteToggle.targetGraphic.enabled = !isOn;
			if (isOn)
			{
				voiceConnection.Client.LocalPlayer.Mute();
			}
			else
			{
				voiceConnection.Client.LocalPlayer.Unmute();
			}
		}

		protected virtual void ToggleIsRecording(bool isRecording)
		{
			voiceConnection.PrimaryRecorder.IsRecording = isRecording;
		}

		private void ToggleDebugEcho(bool isOn)
		{
			voiceConnection.PrimaryRecorder.DebugEchoMode = isOn;
		}

		private void ToggleReliable(bool isOn)
		{
			voiceConnection.PrimaryRecorder.ReliableMode = isOn;
		}

		private void ToggleEncryption(bool isOn)
		{
			voiceConnection.PrimaryRecorder.Encrypt = isOn;
		}

		private void ToggleAEC(bool isOn)
		{
			voiceAudioPreprocessor.AEC = isOn;
			aecOptionsGameObject.SetActive(isOn);
		}

		private void ToggleNoiseSuppression(bool isOn)
		{
			voiceAudioPreprocessor.NoiseSuppression = isOn;
		}

		private void ToggleAGC(bool isOn)
		{
			voiceAudioPreprocessor.AGC = isOn;
			compressionGainGameObject.SetActive(isOn);
		}

		private void ToggleVAD(bool isOn)
		{
			voiceAudioPreprocessor.VAD = isOn;
		}

		private void ToggleHighPass(bool isOn)
		{
			voiceAudioPreprocessor.HighPass = isOn;
		}

		private void ToggleDsp(bool isOn)
		{
			voiceAudioPreprocessor.Bypass = !isOn;
			voiceAudioPreprocessor.enabled = isOn;
			webRtcDspGameObject.SetActive(isOn);
		}

		private void ToggleAudioClipStreaming(bool isOn)
		{
			microphoneSetupGameObject.SetActive(!isOn && !audioToneToggle.isOn);
			if (isOn)
			{
				audioToneToggle.SetValue(isOn: false);
				voiceConnection.PrimaryRecorder.SourceType = Recorder.InputSourceType.AudioClip;
			}
			else if (!audioToneToggle.isOn)
			{
				voiceConnection.PrimaryRecorder.SourceType = Recorder.InputSourceType.Microphone;
			}
			if (voiceConnection.PrimaryRecorder.RequiresRestart)
			{
				voiceConnection.PrimaryRecorder.RestartRecording();
			}
		}

		private void ToggleAudioToneFactory(bool isOn)
		{
			microphoneSetupGameObject.SetActive(!isOn && !streamAudioClipToggle.isOn);
			if (isOn)
			{
				streamAudioClipToggle.SetValue(isOn: false);
				dspToggle.isOn = false;
				voiceConnection.PrimaryRecorder.InputFactory = () => new AudioUtil.ToneAudioReader<float>();
				voiceConnection.PrimaryRecorder.SourceType = Recorder.InputSourceType.Factory;
			}
			else if (!streamAudioClipToggle.isOn)
			{
				voiceConnection.PrimaryRecorder.SourceType = Recorder.InputSourceType.Microphone;
			}
			if (voiceConnection.PrimaryRecorder.RequiresRestart)
			{
				voiceConnection.PrimaryRecorder.RestartRecording();
			}
		}

		private void TogglePhotonVAD(bool isOn)
		{
			voiceConnection.PrimaryRecorder.VoiceDetection = isOn;
		}

		private void ToggleAecHighPass(bool isOn)
		{
			voiceAudioPreprocessor.AecHighPass = isOn;
		}

		private void OnAgcCompressionGainChanged(float agcCompressionGain)
		{
			voiceAudioPreprocessor.AgcCompressionGain = (int)agcCompressionGain;
			compressionGainText.text = "Compression Gain: " + agcCompressionGain;
		}

		private void OnGlobalPlaybackDelayMinSoftChanged(string newMinDelaySoftString)
		{
			int globalPlaybackDelayMaxSoft = voiceConnection.GlobalPlaybackDelayMaxSoft;
			int globalPlaybackDelayMaxHard = voiceConnection.GlobalPlaybackDelayMaxHard;
			if (int.TryParse(newMinDelaySoftString, out var result) && result >= 0 && result < globalPlaybackDelayMaxSoft)
			{
				voiceConnection.SetGlobalPlaybackDelaySettings(result, globalPlaybackDelayMaxSoft, globalPlaybackDelayMaxHard);
			}
			else
			{
				globalMinDelaySoftInputField.text = voiceConnection.GlobalPlaybackDelayMinSoft.ToString();
			}
		}

		private void OnGlobalPlaybackDelayMaxSoftChanged(string newMaxDelaySoftString)
		{
			int globalPlaybackDelayMinSoft = voiceConnection.GlobalPlaybackDelayMinSoft;
			int globalPlaybackDelayMaxHard = voiceConnection.GlobalPlaybackDelayMaxHard;
			if (int.TryParse(newMaxDelaySoftString, out var result) && result > globalPlaybackDelayMinSoft)
			{
				voiceConnection.SetGlobalPlaybackDelaySettings(globalPlaybackDelayMinSoft, result, globalPlaybackDelayMaxHard);
			}
			else
			{
				globalMaxDelaySoftInputField.text = voiceConnection.GlobalPlaybackDelayMaxSoft.ToString();
			}
		}

		private void OnGlobalPlaybackDelayMaxHardChanged(string newMaxDelayHardString)
		{
			int globalPlaybackDelayMinSoft = voiceConnection.GlobalPlaybackDelayMinSoft;
			int globalPlaybackDelayMaxSoft = voiceConnection.GlobalPlaybackDelayMaxSoft;
			if (int.TryParse(newMaxDelayHardString, out var result) && result >= globalPlaybackDelayMaxSoft)
			{
				voiceConnection.SetGlobalPlaybackDelaySettings(globalPlaybackDelayMinSoft, globalPlaybackDelayMaxSoft, result);
			}
			else
			{
				globalMaxDelayHardInputField.text = voiceConnection.GlobalPlaybackDelayMaxHard.ToString();
			}
		}

		private void OnReverseStreamDelayChanged(string newReverseStreamString)
		{
			if (int.TryParse(newReverseStreamString, out var result) && result > 0)
			{
				voiceAudioPreprocessor.ReverseStreamDelayMs = result;
			}
			else
			{
				reverseStreamDelayInputField.text = voiceAudioPreprocessor.ReverseStreamDelayMs.ToString();
			}
		}

		private void UpdateSyncedNickname(string nickname)
		{
			nickname = nickname.Trim();
			if (!string.IsNullOrEmpty(nickname))
			{
				voiceConnection.Client.LocalPlayer.NickName = nickname;
				PlayerPrefs.SetString("vNick", nickname);
			}
		}

		private void JoinOrCreateRoom(string roomName)
		{
			if (string.IsNullOrEmpty(roomName))
			{
				connectAndJoin.RoomName = string.Empty;
				connectAndJoin.RandomRoom = true;
			}
			else
			{
				connectAndJoin.RoomName = roomName.Trim();
				connectAndJoin.RandomRoom = false;
			}
			if (voiceConnection.Client.InRoom)
			{
				voiceConnection.Client.OpLeaveRoom(becomeInactive: false);
			}
			else if (!voiceConnection.Client.IsConnected)
			{
				voiceConnection.ConnectUsingSettings();
			}
		}

		protected virtual void Update()
		{
			connectionStatusText.text = voiceConnection.Client.State.ToString();
			serverStatusText.text = $"{voiceConnection.Client.CloudRegion}/{voiceConnection.Client.CurrentServerAddress}";
			if (voiceConnection.PrimaryRecorder.IsCurrentlyTransmitting)
			{
				float num = voiceConnection.PrimaryRecorder.LevelMeter.CurrentAvgAmp;
				if (num > 1f)
				{
					num /= 32768f;
				}
				if ((double)num > 0.1)
				{
					inputWarningText.text = "Input too loud!";
					inputWarningText.color = warningColor;
				}
				else
				{
					inputWarningText.text = string.Empty;
					ResetTextColor(inputWarningText);
				}
			}
			if (voiceConnection.FramesReceivedPerSecond > 0f)
			{
				packetLossWarningText.text = $"{voiceConnection.FramesLostPercent:0.##}% Packet Loss";
				packetLossWarningText.color = ((voiceConnection.FramesLostPercent > 1f) ? warningColor : okColor);
			}
			else
			{
				packetLossWarningText.text = string.Empty;
				ResetTextColor(packetLossWarningText);
			}
			rttText.text = "RTT:" + voiceConnection.Client.LoadBalancingPeer.RoundTripTime;
			SetTextColor(voiceConnection.Client.LoadBalancingPeer.RoundTripTime, rttText, rttYellowThreshold, rttRedThreshold);
			rttVariationText.text = "VAR:" + voiceConnection.Client.LoadBalancingPeer.RoundTripTimeVariance;
			SetTextColor(voiceConnection.Client.LoadBalancingPeer.RoundTripTimeVariance, rttVariationText, rttVariationYellowThreshold, rttVariationRedThreshold);
		}

		private void SetTextColor(int textValue, Text text, int yellowThreshold, int redThreshold)
		{
			if (textValue > redThreshold)
			{
				text.color = redColor;
			}
			else if (textValue > yellowThreshold)
			{
				text.color = warningColor;
			}
			else
			{
				text.color = okColor;
			}
		}

		private void ResetTextColor(Text text)
		{
			text.color = defaultColor;
		}

		private void InitUiCallbacks()
		{
			muteToggle.SetSingleOnValueChangedCallback(ToggleMute);
			debugEchoToggle.SetSingleOnValueChangedCallback(ToggleDebugEcho);
			vadToggle.SetSingleOnValueChangedCallback(ToggleVAD);
			aecToggle.SetSingleOnValueChangedCallback(ToggleAEC);
			agcToggle.SetSingleOnValueChangedCallback(ToggleAGC);
			debugEchoToggle.SetSingleOnValueChangedCallback(ToggleDebugEcho);
			dspToggle.SetSingleOnValueChangedCallback(ToggleDsp);
			highPassToggle.SetSingleOnValueChangedCallback(ToggleHighPass);
			encryptionToggle.SetSingleOnValueChangedCallback(ToggleEncryption);
			reliableTransmissionToggle.SetSingleOnValueChangedCallback(ToggleReliable);
			streamAudioClipToggle.SetSingleOnValueChangedCallback(ToggleAudioClipStreaming);
			photonVadToggle.SetSingleOnValueChangedCallback(TogglePhotonVAD);
			aecHighPassToggle.SetSingleOnValueChangedCallback(ToggleAecHighPass);
			noiseSuppressionToggle.SetSingleOnValueChangedCallback(ToggleNoiseSuppression);
			audioToneToggle.SetSingleOnValueChangedCallback(ToggleAudioToneFactory);
			agcCompressionGainSlider.SetSingleOnValueChangedCallback(OnAgcCompressionGainChanged);
			localNicknameText.SetSingleOnEndEditCallback(UpdateSyncedNickname);
			roomNameInputField.SetSingleOnEndEditCallback(JoinOrCreateRoom);
			globalMinDelaySoftInputField.SetSingleOnEndEditCallback(OnGlobalPlaybackDelayMinSoftChanged);
			globalMaxDelaySoftInputField.SetSingleOnEndEditCallback(OnGlobalPlaybackDelayMaxSoftChanged);
			globalMaxDelayHardInputField.SetSingleOnEndEditCallback(OnGlobalPlaybackDelayMaxHardChanged);
			reverseStreamDelayInputField.SetSingleOnEndEditCallback(OnReverseStreamDelayChanged);
		}

		private void InitUiValues()
		{
			muteToggle.SetValue(voiceConnection.Client.LocalPlayer.IsMuted());
			debugEchoToggle.SetValue(voiceConnection.PrimaryRecorder.DebugEchoMode);
			reliableTransmissionToggle.SetValue(voiceConnection.PrimaryRecorder.ReliableMode);
			encryptionToggle.SetValue(voiceConnection.PrimaryRecorder.Encrypt);
			streamAudioClipToggle.SetValue(voiceConnection.PrimaryRecorder.SourceType == Recorder.InputSourceType.AudioClip);
			audioToneToggle.SetValue(voiceConnection.PrimaryRecorder.SourceType == Recorder.InputSourceType.Factory);
			microphoneSetupGameObject.SetActive(!streamAudioClipToggle.isOn && !audioToneToggle.isOn);
			globalMinDelaySoftInputField.SetValue(voiceConnection.GlobalPlaybackDelayMinSoft.ToString());
			globalMaxDelaySoftInputField.SetValue(voiceConnection.GlobalPlaybackDelayMaxSoft.ToString());
			globalMaxDelayHardInputField.SetValue(voiceConnection.GlobalPlaybackDelayMaxHard.ToString());
			if (webRtcDspGameObject != null)
			{
				if (voiceAudioPreprocessor == null)
				{
					webRtcDspGameObject.SetActive(value: false);
					dspToggle.gameObject.SetActive(value: false);
					return;
				}
				dspToggle.gameObject.SetActive(value: true);
				dspToggle.SetValue(!voiceAudioPreprocessor.Bypass && voiceAudioPreprocessor.enabled);
				webRtcDspGameObject.SetActive(dspToggle.isOn);
				aecToggle.SetValue(voiceAudioPreprocessor.AEC);
				aecHighPassToggle.SetValue(voiceAudioPreprocessor.AecHighPass);
				reverseStreamDelayInputField.text = voiceAudioPreprocessor.ReverseStreamDelayMs.ToString();
				aecOptionsGameObject.SetActive(voiceAudioPreprocessor.AEC);
				noiseSuppressionToggle.isOn = voiceAudioPreprocessor.NoiseSuppression;
				agcToggle.SetValue(voiceAudioPreprocessor.AGC);
				agcCompressionGainSlider.SetValue(voiceAudioPreprocessor.AgcCompressionGain);
				compressionGainGameObject.SetActive(voiceAudioPreprocessor.AGC);
				vadToggle.SetValue(voiceAudioPreprocessor.VAD);
				highPassToggle.SetValue(voiceAudioPreprocessor.HighPass);
			}
			else
			{
				dspToggle.gameObject.SetActive(value: false);
			}
		}

		private void SetRoomDebugText()
		{
			string text = string.Empty;
			if (voiceConnection.Client.InRoom)
			{
				foreach (Player value in voiceConnection.Client.CurrentRoom.Players.Values)
				{
					text += value.ToStringFull();
				}
				roomStatusText.text = $"{voiceConnection.Client.CurrentRoom.Name} {text}";
			}
			else
			{
				roomStatusText.text = string.Empty;
			}
			roomStatusText.text = ((voiceConnection.Client.CurrentRoom == null) ? string.Empty : $"{voiceConnection.Client.CurrentRoom.Name} {text}");
		}

		protected virtual void OnActorPropertiesChanged(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (targetPlayer.IsLocal)
			{
				bool flag = targetPlayer.IsMuted();
				voiceConnection.PrimaryRecorder.TransmitEnabled = !flag;
				muteToggle.SetValue(flag);
			}
			SetRoomDebugText();
		}

		void IInRoomCallbacks.OnPlayerEnteredRoom(Player newPlayer)
		{
			SetRoomDebugText();
		}

		void IInRoomCallbacks.OnPlayerLeftRoom(Player otherPlayer)
		{
			SetRoomDebugText();
		}

		void IInRoomCallbacks.OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
		}

		void IInRoomCallbacks.OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			OnActorPropertiesChanged(targetPlayer, changedProps);
		}

		void IInRoomCallbacks.OnMasterClientSwitched(Player newMasterClient)
		{
		}

		void IMatchmakingCallbacks.OnFriendListUpdate(List<FriendInfo> friendList)
		{
		}

		void IMatchmakingCallbacks.OnCreatedRoom()
		{
		}

		void IMatchmakingCallbacks.OnCreateRoomFailed(short returnCode, string message)
		{
		}

		void IMatchmakingCallbacks.OnJoinedRoom()
		{
			SetRoomDebugText();
		}

		void IMatchmakingCallbacks.OnJoinRoomFailed(short returnCode, string message)
		{
		}

		void IMatchmakingCallbacks.OnJoinRandomFailed(short returnCode, string message)
		{
		}

		void IMatchmakingCallbacks.OnLeftRoom()
		{
			if (!ConnectionHandler.AppQuits)
			{
				SetRoomDebugText();
				SetDefaults();
			}
		}
	}
	public struct MicRef
	{
		public Recorder.MicType MicType;

		public string Name;

		public int PhotonId;

		public MicRef(string name, int id)
		{
			MicType = Recorder.MicType.Photon;
			Name = name;
			PhotonId = id;
		}

		public MicRef(string name)
		{
			MicType = Recorder.MicType.Unity;
			Name = name;
			PhotonId = -1;
		}

		public override string ToString()
		{
			return $"Mic reference: {Name}";
		}
	}
	public class MicrophoneDropdownFiller : MonoBehaviour
	{
		private List<MicRef> micOptions;

		[SerializeField]
		private Dropdown micDropdown;

		[SerializeField]
		private Recorder recorder;

		[SerializeField]
		[FormerlySerializedAs("RefreshButton")]
		private GameObject refreshButton;

		[SerializeField]
		[FormerlySerializedAs("ToggleButton")]
		private GameObject toggleButton;

		private Toggle photonToggle;

		private void Awake()
		{
			photonToggle = toggleButton.GetComponentInChildren<Toggle>();
			RefreshMicrophones();
		}

		private void SetupMicDropdown()
		{
			micDropdown.ClearOptions();
			micOptions = new List<MicRef>();
			List<string> list = new List<string>();
			for (int i = 0; i < Microphone.devices.Length; i++)
			{
				string arg = Microphone.devices[i];
				micOptions.Add(new MicRef(arg));
				list.Add($"[Unity] {arg}");
			}
			micDropdown.AddOptions(list);
			micDropdown.onValueChanged.RemoveAllListeners();
			micDropdown.onValueChanged.AddListener(delegate
			{
				MicDropdownValueChanged(micOptions[micDropdown.value]);
			});
		}

		private void MicDropdownValueChanged(MicRef mic)
		{
			recorder.MicrophoneType = mic.MicType;
			switch (mic.MicType)
			{
			case Recorder.MicType.Unity:
				recorder.UnityMicrophoneDevice = mic.Name;
				break;
			case Recorder.MicType.Photon:
				recorder.PhotonMicrophoneDeviceId = mic.PhotonId;
				break;
			}
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		private void SetCurrentValue()
		{
			if (micOptions == null)
			{
				UnityEngine.Debug.LogWarning("micOptions list is null");
				return;
			}
			bool flag = false;
			photonToggle.onValueChanged.RemoveAllListeners();
			photonToggle.isOn = recorder.MicrophoneType == Recorder.MicType.Photon;
			if (!flag)
			{
				photonToggle.onValueChanged.AddListener(PhotonMicToggled);
			}
			micDropdown.gameObject.SetActive(flag || recorder.MicrophoneType == Recorder.MicType.Unity);
			toggleButton.SetActive(!flag);
			refreshButton.SetActive(flag || recorder.MicrophoneType == Recorder.MicType.Unity);
			for (int i = 0; i < micOptions.Count; i++)
			{
				MicRef micRef = micOptions[i];
				if (recorder.MicrophoneType == micRef.MicType)
				{
					if (recorder.MicrophoneType == Recorder.MicType.Unity && Recorder.CompareUnityMicNames(micRef.Name, recorder.UnityMicrophoneDevice))
					{
						micDropdown.value = i;
						return;
					}
					if (recorder.MicrophoneType == Recorder.MicType.Photon && micRef.PhotonId == recorder.PhotonMicrophoneDeviceId)
					{
						micDropdown.value = i;
						return;
					}
				}
			}
			for (int j = 0; j < micOptions.Count; j++)
			{
				MicRef micRef2 = micOptions[j];
				if (recorder.MicrophoneType == micRef2.MicType)
				{
					if (recorder.MicrophoneType == Recorder.MicType.Unity)
					{
						micDropdown.value = j;
						recorder.UnityMicrophoneDevice = micRef2.Name;
						break;
					}
					if (recorder.MicrophoneType == Recorder.MicType.Photon)
					{
						micDropdown.value = j;
						recorder.PhotonMicrophoneDeviceId = micRef2.PhotonId;
						break;
					}
				}
			}
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		public void PhotonMicToggled(bool on)
		{
			micDropdown.gameObject.SetActive(!on);
			refreshButton.SetActive(!on);
			if (on)
			{
				recorder.MicrophoneType = Recorder.MicType.Photon;
			}
			else
			{
				recorder.MicrophoneType = Recorder.MicType.Unity;
			}
			if (recorder.RequiresRestart)
			{
				recorder.RestartRecording();
			}
		}

		public void RefreshMicrophones()
		{
			SetupMicDropdown();
			SetCurrentValue();
		}

		private void PhotonVoiceCreated()
		{
			RefreshMicrophones();
		}
	}
	public static class PhotonDemoExtensions
	{
		internal const string IS_MUTED_PROPERTY_KEY = "mute";

		public static bool Mute(this Player player)
		{
			return player.SetCustomProperties(new ExitGames.Client.Photon.Hashtable(1) { { "mute", true } });
		}

		public static bool Unmute(this Player player)
		{
			return player.SetCustomProperties(new ExitGames.Client.Photon.Hashtable(1) { { "mute", false } });
		}

		public static bool IsMuted(this Player player)
		{
			if (player.CustomProperties.TryGetValue("mute", out var value))
			{
				return (bool)value;
			}
			return false;
		}
	}
	[RequireComponent(typeof(Speaker))]
	public class RemoteSpeakerUI : MonoBehaviour, IInRoomCallbacks
	{
		[SerializeField]
		private Text nameText;

		[SerializeField]
		protected Image remoteIsMuting;

		[SerializeField]
		private Image remoteIsTalking;

		[SerializeField]
		private InputField minDelaySoftInputField;

		[SerializeField]
		private InputField maxDelaySoftInputField;

		[SerializeField]
		private InputField maxDelayHardInputField;

		[SerializeField]
		private Text bufferLagText;

		protected Speaker speaker;

		protected VoiceConnection voiceConnection;

		protected virtual void Start()
		{
			speaker = GetComponent<Speaker>();
			minDelaySoftInputField.text = speaker.PlaybackDelayMinSoft.ToString();
			minDelaySoftInputField.SetSingleOnEndEditCallback(OnMinDelaySoftChanged);
			maxDelaySoftInputField.text = speaker.PlaybackDelayMaxSoft.ToString();
			maxDelaySoftInputField.SetSingleOnEndEditCallback(OnMaxDelaySoftChanged);
			maxDelayHardInputField.text = speaker.PlaybackDelayMaxHard.ToString();
			maxDelayHardInputField.SetSingleOnEndEditCallback(OnMaxDelayHardChanged);
			SetNickname();
			SetMutedState();
		}

		private void OnMinDelaySoftChanged(string newMinDelaySoftString)
		{
			int playbackDelayMaxSoft = speaker.PlaybackDelayMaxSoft;
			int playbackDelayMaxHard = speaker.PlaybackDelayMaxHard;
			if (int.TryParse(newMinDelaySoftString, out var result) && result >= 0 && result < playbackDelayMaxSoft)
			{
				speaker.SetPlaybackDelaySettings(result, playbackDelayMaxSoft, playbackDelayMaxHard);
			}
			else
			{
				minDelaySoftInputField.text = speaker.PlaybackDelayMinSoft.ToString();
			}
		}

		private void OnMaxDelaySoftChanged(string newMaxDelaySoftString)
		{
			int playbackDelayMinSoft = speaker.PlaybackDelayMinSoft;
			int playbackDelayMaxHard = speaker.PlaybackDelayMaxHard;
			if (int.TryParse(newMaxDelaySoftString, out var result) && playbackDelayMinSoft < result)
			{
				speaker.SetPlaybackDelaySettings(playbackDelayMinSoft, result, playbackDelayMaxHard);
			}
			else
			{
				maxDelaySoftInputField.text = speaker.PlaybackDelayMaxSoft.ToString();
			}
		}

		private void OnMaxDelayHardChanged(string newMaxDelayHardString)
		{
			int playbackDelayMinSoft = speaker.PlaybackDelayMinSoft;
			int playbackDelayMaxSoft = speaker.PlaybackDelayMaxSoft;
			if (int.TryParse(newMaxDelayHardString, out var result) && result >= playbackDelayMaxSoft)
			{
				speaker.SetPlaybackDelaySettings(playbackDelayMinSoft, playbackDelayMaxSoft, result);
			}
			else
			{
				maxDelayHardInputField.text = speaker.PlaybackDelayMaxHard.ToString();
			}
		}

		private void Update()
		{
			remoteIsTalking.enabled = speaker.IsPlaying;
			bufferLagText.text = "Buffer Lag: " + speaker.Lag;
		}

		private void OnDestroy()
		{
			voiceConnection.Client.RemoveCallbackTarget(this);
		}

		private void SetNickname()
		{
			string text = speaker.name;
			if (speaker.Actor != null)
			{
				text = speaker.Actor.NickName;
				if (string.IsNullOrEmpty(text))
				{
					text = "user " + speaker.Actor.ActorNumber;
				}
			}
			nameText.text = text;
		}

		private void SetMutedState()
		{
			SetMutedState(speaker.Actor.IsMuted());
		}

		protected virtual void SetMutedState(bool isMuted)
		{
			remoteIsMuting.enabled = isMuted;
		}

		protected virtual void OnActorPropertiesChanged(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			if (targetPlayer.ActorNumber == speaker.Actor.ActorNumber)
			{
				SetMutedState();
				SetNickname();
			}
		}

		public virtual void Init(VoiceConnection vC)
		{
			voiceConnection = vC;
			voiceConnection.Client.AddCallbackTarget(this);
		}

		void IInRoomCallbacks.OnPlayerEnteredRoom(Player newPlayer)
		{
		}

		void IInRoomCallbacks.OnPlayerLeftRoom(Player otherPlayer)
		{
		}

		void IInRoomCallbacks.OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
		}

		void IInRoomCallbacks.OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			OnActorPropertiesChanged(targetPlayer, changedProps);
		}

		void IInRoomCallbacks.OnMasterClientSwitched(Player newMasterClient)
		{
		}
	}
}
namespace Photon.Realtime.Demo
{
	public class ConnectAndJoinRandomLb : MonoBehaviour, IConnectionCallbacks, IMatchmakingCallbacks, ILobbyCallbacks
	{
		[SerializeField]
		private AppSettings appSettings = new AppSettings();

		private LoadBalancingClient lbc;

		private ConnectionHandler ch;

		public Text StateUiText;

		public void Start()
		{
			lbc = new LoadBalancingClient();
			lbc.AddCallbackTarget(this);
			if (!lbc.ConnectUsingSettings(appSettings))
			{
				UnityEngine.Debug.LogError("Error while connecting");
			}
			ch = base.gameObject.GetComponent<ConnectionHandler>();
			if (ch != null)
			{
				ch.Client = lbc;
				ch.StartFallbackSendAckThread();
			}
		}

		public void Update()
		{
			LoadBalancingClient loadBalancingClient = lbc;
			if (loadBalancingClient != null)
			{
				loadBalancingClient.Service();
				Text stateUiText = StateUiText;
				string text = loadBalancingClient.State.ToString();
				if (stateUiText != null && !stateUiText.text.Equals(text))
				{
					stateUiText.text = "State: " + text;
				}
			}
		}

		public void OnConnected()
		{
		}

		public void OnConnectedToMaster()
		{
			UnityEngine.Debug.Log("OnConnectedToMaster");
			lbc.OpJoinRandomRoom();
		}

		public void OnDisconnected(DisconnectCause cause)
		{
			UnityEngine.Debug.Log(string.Concat("OnDisconnected(", cause, ")"));
		}

		public void OnCustomAuthenticationResponse(Dictionary<string, object> data)
		{
		}

		public void OnCustomAuthenticationFailed(string debugMessage)
		{
		}

		public void OnRegionListReceived(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionListReceived");
			regionHandler.PingMinimumOfRegions(OnRegionPingCompleted, null);
		}

		public void OnRoomListUpdate(List<RoomInfo> roomList)
		{
		}

		public void OnLobbyStatisticsUpdate(List<TypedLobbyInfo> lobbyStatistics)
		{
		}

		public void OnJoinedLobby()
		{
		}

		public void OnLeftLobby()
		{
		}

		public void OnFriendListUpdate(List<FriendInfo> friendList)
		{
		}

		public void OnCreatedRoom()
		{
		}

		public void OnCreateRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinedRoom()
		{
			UnityEngine.Debug.Log("OnJoinedRoom");
		}

		public void OnJoinRoomFailed(short returnCode, string message)
		{
		}

		public void OnJoinRandomFailed(short returnCode, string message)
		{
			UnityEngine.Debug.Log("OnJoinRandomFailed");
			lbc.OpCreateRoom(new EnterRoomParams());
		}

		public void OnLeftRoom()
		{
		}

		private void OnRegionPingCompleted(RegionHandler regionHandler)
		{
			UnityEngine.Debug.Log("OnRegionPingCompleted " + regionHandler.BestRegion);
			UnityEngine.Debug.Log("RegionPingSummary: " + regionHandler.SummaryToCache);
			lbc.ConnectToRegionMaster(regionHandler.BestRegion.Code);
		}
	}
}
namespace Photon.Chat.UtilityScripts
{
	public class EventSystemSpawner : MonoBehaviour
	{
		private void Start()
		{
			if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
			{
				GameObject obj = new GameObject("EventSystem");
				obj.AddComponent<EventSystem>();
				obj.AddComponent<StandaloneInputModule>();
			}
		}
	}
	public class OnStartDelete : MonoBehaviour
	{
		private void Start()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextButtonTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		private Text _text;

		public Selectable Selectable;

		public Color NormalColor = Color.white;

		public Color HoverColor = Color.black;

		public void Awake()
		{
			_text = GetComponent<Text>();
		}

		public void OnEnable()
		{
			_text.color = NormalColor;
		}

		public void OnDisable()
		{
			_text.color = NormalColor;
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = HoverColor;
			}
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			if (Selectable == null || Selectable.IsInteractable())
			{
				_text.color = NormalColor;
			}
		}
	}
	[RequireComponent(typeof(Text))]
	public class TextToggleIsOnTransition : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
	{
		public Toggle toggle;

		private Text _text;

		public Color NormalOnColor = Color.white;

		public Color NormalOffColor = Color.black;

		public Color HoverOnColor = Color.black;

		public Color HoverOffColor = Color.black;

		private bool isHover;

		public void OnEnable()
		{
			_text = GetComponent<Text>();
			OnValueChanged(toggle.isOn);
			toggle.onValueChanged.AddListener(OnValueChanged);
		}

		public void OnDisable()
		{
			toggle.onValueChanged.RemoveListener(OnValueChanged);
		}

		public void OnValueChanged(bool isOn)
		{
			_text.color = ((!isOn) ? (isHover ? NormalOffColor : NormalOffColor) : (isHover ? HoverOnColor : HoverOnColor));
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			isHover = true;
			_text.color = (toggle.isOn ? HoverOnColor : HoverOffColor);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			isHover = false;
			_text.color = (toggle.isOn ? NormalOnColor : NormalOffColor);
		}
	}
}
namespace OculusSampleFramework
{
	public class ColorGrabbable : OVRGrabbable
	{
		public static readonly Color COLOR_GRAB = new Color(1f, 0.5f, 0f, 1f);

		public static readonly Color COLOR_HIGHLIGHT = new Color(1f, 0f, 1f, 1f);

		private Color m_color = Color.black;

		private MeshRenderer[] m_meshRenderers;

		private bool m_highlight;

		public bool Highlight
		{
			get
			{
				return m_highlight;
			}
			set
			{
				m_highlight = value;
				UpdateColor();
			}
		}

		protected void UpdateColor()
		{
			if (base.isGrabbed)
			{
				SetColor(COLOR_GRAB);
			}
			else if (Highlight)
			{
				SetColor(COLOR_HIGHLIGHT);
			}
			else
			{
				SetColor(m_color);
			}
		}

		public override void GrabBegin(OVRGrabber hand, Collider grabPoint)
		{
			base.GrabBegin(hand, grabPoint);
			UpdateColor();
		}

		public override void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
		{
			base.GrabEnd(linearVelocity, angularVelocity);
			UpdateColor();
		}

		private void Awake()
		{
			if (m_grabPoints.Length == 0)
			{
				Collider component = GetComponent<Collider>();
				if (component == null)
				{
					throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
				}
				m_grabPoints = new Collider[1] { component };
				m_meshRenderers = new MeshRenderer[1];
				m_meshRenderers[0] = GetComponent<MeshRenderer>();
			}
			else
			{
				m_meshRenderers = GetComponentsInChildren<MeshRenderer>();
			}
			m_color = new Color(UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), 1f);
			SetColor(m_color);
		}

		private void SetColor(Color color)
		{
			for (int i = 0; i < m_meshRenderers.Length; i++)
			{
				MeshRenderer meshRenderer = m_meshRenderers[i];
				for (int j = 0; j < meshRenderer.materials.Length; j++)
				{
					meshRenderer.materials[j].color = color;
				}
			}
		}
	}
	public class DistanceGrabbable : OVRGrabbable
	{
		public string m_materialColorField;

		private GrabbableCrosshair m_crosshair;

		private GrabManager m_crosshairManager;

		private Renderer m_renderer;

		private MaterialPropertyBlock m_mpb;

		private bool m_inRange;

		private bool m_targeted;

		public bool InRange
		{
			get
			{
				return m_inRange;
			}
			set
			{
				m_inRange = value;
				RefreshCrosshair();
			}
		}

		public bool Targeted
		{
			get
			{
				return m_targeted;
			}
			set
			{
				m_targeted = value;
				RefreshCrosshair();
			}
		}

		protected override void Start()
		{
			base.Start();
			m_crosshair = base.gameObject.GetComponentInChildren<GrabbableCrosshair>();
			m_renderer = base.gameObject.GetComponent<Renderer>();
			m_crosshairManager = UnityEngine.Object.FindObjectOfType<GrabManager>();
			m_mpb = new MaterialPropertyBlock();
			RefreshCrosshair();
			m_renderer.SetPropertyBlock(m_mpb);
		}

		private void RefreshCrosshair()
		{
			if ((bool)m_crosshair)
			{
				if (base.isGrabbed)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else if (!InRange)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else
				{
					m_crosshair.SetState((!Targeted) ? GrabbableCrosshair.CrosshairState.Enabled : GrabbableCrosshair.CrosshairState.Targeted);
				}
			}
			if (m_materialColorField != null)
			{
				m_renderer.GetPropertyBlock(m_mpb);
				if (base.isGrabbed || !InRange)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorOutOfRange);
				}
				else if (Targeted)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorHighlighted);
				}
				else
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorInRange);
				}
				m_renderer.SetPropertyBlock(m_mpb);
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class DistanceGrabber : OVRGrabber
	{
		[SerializeField]
		private float m_spherecastRadius;

		[SerializeField]
		private float m_noSnapThreshhold = 0.05f;

		[SerializeField]
		private bool m_useSpherecast;

		[SerializeField]
		public bool m_preventGrabThroughWalls;

		[SerializeField]
		private float m_objectPullVelocity = 10f;

		private float m_objectPullMaxRotationRate = 360f;

		private bool m_movingObjectToHand;

		[SerializeField]
		private float m_maxGrabDistance;

		[SerializeField]
		private int m_grabObjectsInLayer;

		[SerializeField]
		private int m_obstructionLayer;

		private DistanceGrabber m_otherHand;

		protected DistanceGrabbable m_target;

		protected Collider m_targetCollider;

		public bool UseSpherecast
		{
			get
			{
				return m_useSpherecast;
			}
			set
			{
				m_useSpherecast = value;
				GrabVolumeEnable(!m_useSpherecast);
			}
		}

		protected override void Start()
		{
			base.Start();
			Collider componentInChildren = m_player.GetComponentInChildren<Collider>();
			if (componentInChildren != null)
			{
				m_maxGrabDistance = componentInChildren.bounds.size.z * 0.5f + 3f;
			}
			else
			{
				m_maxGrabDistance = 12f;
			}
			if (m_parentHeldObject)
			{
				UnityEngine.Debug.LogError("m_parentHeldObject incompatible with DistanceGrabber. Setting to false.");
				m_parentHeldObject = false;
			}
			DistanceGrabber[] array = UnityEngine.Object.FindObjectsOfType<DistanceGrabber>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != this)
				{
					m_otherHand = array[i];
				}
			}
		}

		public override void Update()
		{
			base.Update();
			UnityEngine.Debug.DrawRay(base.transform.position, base.transform.forward, Color.red, 0.1f);
			FindTarget(out var dgOut, out var collOut);
			if (dgOut != m_target)
			{
				if (m_target != null)
				{
					m_target.Targeted = m_otherHand.m_target == m_target;
				}
				m_target = dgOut;
				m_targetCollider = collOut;
				if (m_target != null)
				{
					m_target.Targeted = true;
				}
			}
		}

		protected override void GrabBegin()
		{
			DistanceGrabbable target = m_target;
			Collider targetCollider = m_targetCollider;
			GrabVolumeEnable(enabled: false);
			if (!(target != null))
			{
				return;
			}
			if (target.isGrabbed)
			{
				((DistanceGrabber)target.grabbedBy).OffhandGrabbed(target);
			}
			m_grabbedObj = target;
			m_grabbedObj.GrabBegin(this, targetCollider);
			SetPlayerIgnoreCollision(m_grabbedObj.gameObject, ignore: true);
			m_movingObjectToHand = true;
			m_lastPos = base.transform.position;
			m_lastRot = base.transform.rotation;
			Vector3 vector = targetCollider.ClosestPointOnBounds(m_gripTransform.position);
			if (!m_grabbedObj.snapPosition && !m_grabbedObj.snapOrientation && m_noSnapThreshhold > 0f && (vector - m_gripTransform.position).magnitude < m_noSnapThreshhold)
			{
				Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
				m_movingObjectToHand = false;
				vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
				m_grabbedObjectPosOff = vector2;
				Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
				m_grabbedObjectRotOff = grabbedObjectRotOff;
				return;
			}
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}

		protected override void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
		{
			if (m_grabbedObj == null)
			{
				return;
			}
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 vector = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (m_movingObjectToHand)
			{
				float num = m_objectPullVelocity * Time.deltaTime;
				Vector3 vector2 = vector - m_grabbedObj.transform.position;
				if (num * num * 1.1f > vector2.sqrMagnitude)
				{
					m_movingObjectToHand = false;
				}
				else
				{
					vector2.Normalize();
					vector = m_grabbedObj.transform.position + vector2 * num;
					quaternion = Quaternion.RotateTowards(m_grabbedObj.transform.rotation, quaternion, m_objectPullMaxRotationRate * Time.deltaTime);
				}
			}
			grabbedRigidbody.MovePosition(vector);
			grabbedRigidbody.MoveRotation(quaternion);
		}

		private static DistanceGrabbable HitInfoToGrabbable(RaycastHit hitInfo)
		{
			if (hitInfo.collider != null)
			{
				GameObject gameObject = hitInfo.collider.gameObject;
				return gameObject.GetComponent<DistanceGrabbable>() ?? gameObject.GetComponentInParent<DistanceGrabbable>();
			}
			return null;
		}

		protected bool FindTarget(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			float num = float.MaxValue;
			foreach (OVRGrabbable key in m_grabCandidates.Keys)
			{
				DistanceGrabbable distanceGrabbable = key as DistanceGrabbable;
				bool flag = distanceGrabbable != null && distanceGrabbable.InRange && (!distanceGrabbable.isGrabbed || distanceGrabbable.allowOffhandGrab);
				if (flag && m_grabObjectsInLayer >= 0)
				{
					flag = distanceGrabbable.gameObject.layer == m_grabObjectsInLayer;
				}
				if (!flag)
				{
					continue;
				}
				for (int i = 0; i < distanceGrabbable.grabPoints.Length; i++)
				{
					Collider collider = distanceGrabbable.grabPoints[i];
					Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
					float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
					if (!(sqrMagnitude < num))
					{
						continue;
					}
					bool flag2 = true;
					if (m_preventGrabThroughWalls)
					{
						Ray ray = default(Ray);
						ray.direction = distanceGrabbable.transform.position - m_gripTransform.position;
						ray.origin = m_gripTransform.position;
						UnityEngine.Debug.DrawRay(ray.origin, ray.direction, Color.red, 0.1f);
						if (Physics.Raycast(ray, out var hitInfo, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore) && (double)(collider.ClosestPointOnBounds(m_gripTransform.position) - m_gripTransform.position).magnitude > (double)hitInfo.distance * 1.1)
						{
							flag2 = false;
						}
					}
					if (flag2)
					{
						num = sqrMagnitude;
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
			}
			if (dgOut == null && m_useSpherecast)
			{
				return FindTargetWithSpherecast(out dgOut, out collOut);
			}
			return dgOut != null;
		}

		protected bool FindTargetWithSpherecast(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			Ray ray = new Ray(m_gripTransform.position, m_gripTransform.forward);
			int layerMask = ((m_grabObjectsInLayer == -1) ? (-1) : (1 << m_grabObjectsInLayer));
			if (Physics.SphereCast(ray, m_spherecastRadius, out var hitInfo, m_maxGrabDistance, layerMask))
			{
				DistanceGrabbable distanceGrabbable = null;
				Collider collider = null;
				if (hitInfo.collider != null)
				{
					distanceGrabbable = hitInfo.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
					collider = ((distanceGrabbable == null) ? null : hitInfo.collider);
					if ((bool)distanceGrabbable)
					{
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
				if (distanceGrabbable != null && m_preventGrabThroughWalls)
				{
					ray.direction = hitInfo.point - m_gripTransform.position;
					dgOut = distanceGrabbable;
					collOut = collider;
					if (Physics.Raycast(ray, out var hitInfo2, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore))
					{
						DistanceGrabbable distanceGrabbable2 = null;
						if (hitInfo.collider != null)
						{
							distanceGrabbable2 = hitInfo2.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
						}
						if (distanceGrabbable2 != distanceGrabbable && hitInfo2.distance < hitInfo.distance)
						{
							dgOut = null;
							collOut = null;
						}
					}
				}
			}
			return dgOut != null;
		}

		protected override void GrabVolumeEnable(bool enabled)
		{
			if (m_useSpherecast)
			{
				enabled = false;
			}
			base.GrabVolumeEnable(enabled);
		}

		protected override void OffhandGrabbed(OVRGrabbable grabbable)
		{
			base.OffhandGrabbed(grabbable);
		}
	}
	public class GrabManager : MonoBehaviour
	{
		private Collider m_grabVolume;

		public Color OutlineColorInRange;

		public Color OutlineColorHighlighted;

		public Color OutlineColorOutOfRange;

		private void OnTriggerEnter(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = true;
			}
		}

		private void OnTriggerExit(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = false;
			}
		}
	}
	public class GrabbableCrosshair : MonoBehaviour
	{
		public enum CrosshairState
		{
			Disabled,
			Enabled,
			Targeted
		}

		private CrosshairState m_state;

		private Transform m_centerEyeAnchor;

		[SerializeField]
		private GameObject m_targetedCrosshair;

		[SerializeField]
		private GameObject m_enabledCrosshair;

		private void Start()
		{
			m_centerEyeAnchor = GameObject.Find("CenterEyeAnchor").transform;
		}

		public void SetState(CrosshairState cs)
		{
			m_state = cs;
			switch (cs)
			{
			case CrosshairState.Disabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: false);
				break;
			case CrosshairState.Enabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: true);
				break;
			case CrosshairState.Targeted:
				m_targetedCrosshair.SetActive(value: true);
				m_enabledCrosshair.SetActive(value: false);
				break;
			}
		}

		private void Update()
		{
			if (m_state != 0)
			{
				base.transform.LookAt(m_centerEyeAnchor);
			}
		}
	}
	public class PauseOnInputLoss : MonoBehaviour
	{
		private void Start()
		{
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			Time.timeScale = 0f;
		}

		private void OnInputFocusAcquired()
		{
			Time.timeScale = 1f;
		}
	}
	public class BoneCapsuleTriggerLogic : MonoBehaviour
	{
		public InteractableToolTags ToolTags;

		public HashSet<ColliderZone> CollidersTouchingUs = new HashSet<ColliderZone>();

		private List<ColliderZone> _elementsToCleanUp = new List<ColliderZone>();

		private void OnDisable()
		{
			CollidersTouchingUs.Clear();
		}

		private void Update()
		{
			CleanUpDeadColliders();
		}

		private void OnTriggerEnter(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Add(component);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Remove(component);
			}
		}

		private void CleanUpDeadColliders()
		{
			_elementsToCleanUp.Clear();
			foreach (ColliderZone collidersTouchingU in CollidersTouchingUs)
			{
				if (!collidersTouchingU.Collider.gameObject.activeInHierarchy)
				{
					_elementsToCleanUp.Add(collidersTouchingU);
				}
			}
			foreach (ColliderZone item in _elementsToCleanUp)
			{
				CollidersTouchingUs.Remove(item);
			}
		}
	}
	public class ButtonController : Interactable
	{
		public enum ContactTest
		{
			PerpenTest,
			BackwardsPress
		}

		private const float ENTRY_DOT_THRESHOLD = 0.8f;

		private const float PERP_DOT_THRESHOLD = 0.5f;

		[SerializeField]
		private GameObject _proximityZone;

		[SerializeField]
		private GameObject _contactZone;

		[SerializeField]
		private GameObject _actionZone;

		[SerializeField]
		private ContactTest[] _contactTests;

		[SerializeField]
		private Transform _buttonPlaneCenter;

		[SerializeField]
		private bool _makeSureToolIsOnPositiveSide = true;

		[SerializeField]
		private Vector3 _localButtonDirection = Vector3.down;

		[SerializeField]
		private InteractableToolTags[] _allValidToolsTags = new InteractableToolTags[1] { InteractableToolTags.All };

		private int _toolTagsMask;

		private InteractableState _currentButtonState;

		private Dictionary<InteractableTool, InteractableState> _toolToState = new Dictionary<InteractableTool, InteractableState>();

		public override int ValidToolTagsMask => _toolTagsMask;

		public Vector3 LocalButtonDirection => _localButtonDirection;

		protected override void Awake()
		{
			base.Awake();
			InteractableToolTags[] allValidToolsTags = _allValidToolsTags;
			foreach (InteractableToolTags interactableToolTags in allValidToolsTags)
			{
				_toolTagsMask |= (int)interactableToolTags;
			}
			_proximityZoneCollider = _proximityZone.GetComponent<ColliderZone>();
			_contactZoneCollider = _contactZone.GetComponent<ColliderZone>();
			_actionZoneCollider = _actionZone.GetComponent<ColliderZone>();
		}

		private void FireInteractionEventsOnDepth(InteractableCollisionDepth oldDepth, InteractableTool collidingTool, InteractionType interactionType)
		{
			switch (oldDepth)
			{
			case InteractableCollisionDepth.Action:
				OnActionZoneEvent(new ColliderZoneArgs(base.ActionCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Contact:
				OnContactZoneEvent(new ColliderZoneArgs(base.ContactCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Proximity:
				OnProximityZoneEvent(new ColliderZoneArgs(base.ProximityCollider, Time.frameCount, collidingTool, interactionType));
				break;
			}
		}

		public override void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth)
		{
			bool isFarFieldTool = interactableTool.IsFarFieldTool;
			if (!isFarFieldTool && _toolToState.Keys.Count > 0 && !_toolToState.ContainsKey(interactableTool))
			{
				return;
			}
			InteractableState currentButtonState = _currentButtonState;
			Vector3 vector = base.transform.TransformDirection(_localButtonDirection);
			bool validContact = IsValidContact(interactableTool, vector) || interactableTool.IsFarFieldTool;
			bool toolIsInProximity = newCollisionDepth >= InteractableCollisionDepth.Proximity;
			bool flag = newCollisionDepth == InteractableCollisionDepth.Contact;
			bool flag2 = newCollisionDepth == InteractableCollisionDepth.Action;
			bool flag3 = oldCollisionDepth != newCollisionDepth;
			if (flag3)
			{
				FireInteractionEventsOnDepth(oldCollisionDepth, interactableTool, InteractionType.Exit);
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Enter);
			}
			else
			{
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Stay);
			}
			InteractableState interactableState = currentButtonState;
			if (interactableTool.IsFarFieldTool)
			{
				interactableState = (flag ? InteractableState.ContactState : (flag2 ? InteractableState.ActionState : InteractableState.Default));
			}
			else
			{
				Plane plane = new Plane(-vector, _buttonPlaneCenter.position);
				bool onPositiveSideOfInteractable = !_makeSureToolIsOnPositiveSide || plane.GetSide(interactableTool.InteractionPosition);
				interactableState = GetUpcomingStateNearField(currentButtonState, newCollisionDepth, flag2, flag, toolIsInProximity, validContact, onPositiveSideOfInteractable);
			}
			if (interactableState != 0)
			{
				_toolToState[interactableTool] = interactableState;
			}
			else
			{
				_toolToState.Remove(interactableTool);
			}
			if (isFarFieldTool)
			{
				foreach (InteractableState value in _toolToState.Values)
				{
					if (interactableState < value)
					{
						interactableState = value;
					}
				}
			}
			if (currentButtonState != interactableState)
			{
				_currentButtonState = interactableState;
				InteractionType interactionType = ((!flag3) ? InteractionType.Stay : ((newCollisionDepth == InteractableCollisionDepth.None) ? InteractionType.Exit : InteractionType.Enter));
				ColliderZone collider = ((_currentButtonState == InteractableState.ProximityState) ? base.ProximityCollider : ((_currentButtonState == InteractableState.ContactState) ? base.ContactCollider : ((_currentButtonState == InteractableState.ActionState) ? base.ActionCollider : null)));
				if (InteractableStateChanged != null)
				{
					InteractableStateChanged.Invoke(new InteractableStateArgs(this, interactableTool, _currentButtonState, currentButtonState, new ColliderZoneArgs(collider, Time.frameCount, interactableTool, interactionType)));
				}
			}
		}

		private InteractableState GetUpcomingStateNearField(InteractableState oldState, InteractableCollisionDepth newCollisionDepth, bool toolIsInActionZone, bool toolIsInContactZone, bool toolIsInProximity, bool validContact, bool onPositiveSideOfInteractable)
		{
			InteractableState result = oldState;
			switch (oldState)
			{
			case InteractableState.ActionState:
				if (!toolIsInActionZone)
				{
					result = ((!toolIsInContactZone) ? (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default) : InteractableState.ContactState);
				}
				break;
			case InteractableState.ContactState:
				if (newCollisionDepth < InteractableCollisionDepth.Contact)
				{
					result = (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default);
				}
				else if (toolIsInActionZone && validContact && onPositiveSideOfInteractable)
				{
					result = InteractableState.ActionState;
				}
				break;
			case InteractableState.ProximityState:
				if (newCollisionDepth < InteractableCollisionDepth.Proximity)
				{
					result = InteractableState.Default;
				}
				else if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				break;
			case InteractableState.Default:
				if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				else if (toolIsInProximity)
				{
					result = InteractableState.ProximityState;
				}
				break;
			}
			return result;
		}

		private bool IsValidContact(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (_contactTests == null || collidingTool.IsFarFieldTool)
			{
				return true;
			}
			ContactTest[] contactTests = _contactTests;
			foreach (ContactTest contactTest in contactTests)
			{
				if (contactTest == ContactTest.BackwardsPress)
				{
					if (!PassEntryTest(collidingTool, buttonDirection))
					{
						return false;
					}
				}
				else if (!PassPerpTest(collidingTool, buttonDirection))
				{
					return false;
				}
			}
			return true;
		}

		private bool PassEntryTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (Vector3.Dot(collidingTool.Velocity.normalized, buttonDirection) < 0.8f)
			{
				return false;
			}
			return true;
		}

		private bool PassPerpTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			Vector3 vector = collidingTool.ToolTransform.right;
			if (collidingTool.IsRightHandedTool)
			{
				vector = -vector;
			}
			if (Vector3.Dot(vector, buttonDirection) < 0.5f)
			{
				return false;
			}
			return true;
		}
	}
	public class ButtonTriggerZone : MonoBehaviour, ColliderZone
	{
		[SerializeField]
		private GameObject _parentInteractableObj;

		public Collider Collider { get; private set; }

		public Interactable ParentInteractable { get; private set; }

		public InteractableCollisionDepth CollisionDepth
		{
			get
			{
				if (ParentInteractable.ProximityCollider != this)
				{
					if (ParentInteractable.ContactCollider != this)
					{
						if (ParentInteractable.ActionCollider != this)
						{
							return InteractableCollisionDepth.None;
						}
						return InteractableCollisionDepth.Action;
					}
					return InteractableCollisionDepth.Contact;
				}
				return InteractableCollisionDepth.Proximity;
			}
		}

		private void Awake()
		{
			Collider = GetComponent<Collider>();
			ParentInteractable = _parentInteractableObj.GetComponent<Interactable>();
		}
	}
	public interface ColliderZone
	{
		Collider Collider { get; }

		Interactable ParentInteractable { get; }

		InteractableCollisionDepth CollisionDepth { get; }
	}
	public class ColliderZoneArgs : EventArgs
	{
		public readonly ColliderZone Collider;

		public readonly float FrameTime;

		public readonly InteractableTool CollidingTool;

		public readonly InteractionType InteractionT;

		public ColliderZoneArgs(ColliderZone collider, float frameTime, InteractableTool collidingTool, InteractionType interactionType)
		{
			Collider = collider;
			FrameTime = frameTime;
			CollidingTool = collidingTool;
			InteractionT = interactionType;
		}
	}
	public enum InteractionType
	{
		Enter,
		Stay,
		Exit
	}
	public class HandsManager : MonoBehaviour
	{
		public enum HandsVisualMode
		{
			Mesh,
			Skeleton,
			Both
		}

		private const string SKELETON_VISUALIZER_NAME = "SkeletonRenderer";

		[SerializeField]
		private GameObject _leftHand;

		[SerializeField]
		private GameObject _rightHand;

		public HandsVisualMode VisualMode;

		private OVRHand[] _hand = new OVRHand[2];

		private OVRSkeleton[] _handSkeleton = new OVRSkeleton[2];

		private OVRSkeletonRenderer[] _handSkeletonRenderer = new OVRSkeletonRenderer[2];

		private OVRMesh[] _handMesh = new OVRMesh[2];

		private OVRMeshRenderer[] _handMeshRenderer = new OVRMeshRenderer[2];

		private SkinnedMeshRenderer _leftMeshRenderer;

		private SkinnedMeshRenderer _rightMeshRenderer;

		private GameObject _leftSkeletonVisual;

		private GameObject _rightSkeletonVisual;

		private float _currentHandAlpha = 1f;

		private int HandAlphaId = Shader.PropertyToID("_HandAlpha");

		public OVRHand RightHand
		{
			get
			{
				return _hand[1];
			}
			private set
			{
				_hand[1] = value;
			}
		}

		public OVRSkeleton RightHandSkeleton
		{
			get
			{
				return _handSkeleton[1];
			}
			private set
			{
				_handSkeleton[1] = value;
			}
		}

		public OVRSkeletonRenderer RightHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[1];
			}
			private set
			{
				_handSkeletonRenderer[1] = value;
			}
		}

		public OVRMesh RightHandMesh
		{
			get
			{
				return _handMesh[1];
			}
			private set
			{
				_handMesh[1] = value;
			}
		}

		public OVRMeshRenderer RightHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[1];
			}
			private set
			{
				_handMeshRenderer[1] = value;
			}
		}

		public OVRHand LeftHand
		{
			get
			{
				return _hand[0];
			}
			private set
			{
				_hand[0] = value;
			}
		}

		public OVRSkeleton LeftHandSkeleton
		{
			get
			{
				return _handSkeleton[0];
			}
			private set
			{
				_handSkeleton[0] = value;
			}
		}

		public OVRSkeletonRenderer LeftHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[0];
			}
			private set
			{
				_handSkeletonRenderer[0] = value;
			}
		}

		public OVRMesh LeftHandMesh
		{
			get
			{
				return _handMesh[0];
			}
			private set
			{
				_handMesh[0] = value;
			}
		}

		public OVRMeshRenderer LeftHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[0];
			}
			private set
			{
				_handMeshRenderer[0] = value;
			}
		}

		public static HandsManager Instance { get; private set; }

		private void Awake()
		{
			if ((bool)Instance && Instance != this)
			{
				UnityEngine.Object.Destroy(this);
				return;
			}
			Instance = this;
			LeftHand = _leftHand.GetComponent<OVRHand>();
			LeftHandSkeleton = _leftHand.GetComponent<OVRSkeleton>();
			LeftHandSkeletonRenderer = _leftHand.GetComponent<OVRSkeletonRenderer>();
			LeftHandMesh = _leftHand.GetComponent<OVRMesh>();
			LeftHandMeshRenderer = _leftHand.GetComponent<OVRMeshRenderer>();
			RightHand = _rightHand.GetComponent<OVRHand>();
			RightHandSkeleton = _rightHand.GetComponent<OVRSkeleton>();
			RightHandSkeletonRenderer = _rightHand.GetComponent<OVRSkeletonRenderer>();
			RightHandMesh = _rightHand.GetComponent<OVRMesh>();
			RightHandMeshRenderer = _rightHand.GetComponent<OVRMeshRenderer>();
			_leftMeshRenderer = LeftHand.GetComponent<SkinnedMeshRenderer>();
			_rightMeshRenderer = RightHand.GetComponent<SkinnedMeshRenderer>();
			StartCoroutine(FindSkeletonVisualGameObjects());
		}

		private void Update()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
			case HandsVisualMode.Skeleton:
				_currentHandAlpha = 1f;
				break;
			case HandsVisualMode.Both:
				_currentHandAlpha = 0.6f;
				break;
			default:
				_currentHandAlpha = 1f;
				break;
			}
			_rightMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
			_leftMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
		}

		private IEnumerator FindSkeletonVisualGameObjects()
		{
			while (!_leftSkeletonVisual || !_rightSkeletonVisual)
			{
				if (!_leftSkeletonVisual)
				{
					Transform transform = LeftHand.transform.Find("SkeletonRenderer");
					if ((bool)transform)
					{
						_leftSkeletonVisual = transform.gameObject;
					}
				}
				if (!_rightSkeletonVisual)
				{
					Transform transform2 = RightHand.transform.Find("SkeletonRenderer");
					if ((bool)transform2)
					{
						_rightSkeletonVisual = transform2.gameObject;
					}
				}
				yield return null;
			}
			SetToCurrentVisualMode();
		}

		public void SwitchVisualization()
		{
			if ((bool)_leftSkeletonVisual && (bool)_rightSkeletonVisual)
			{
				VisualMode = (HandsVisualMode)((int)(VisualMode + 1) % 3);
				SetToCurrentVisualMode();
			}
		}

		private void SetToCurrentVisualMode()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: false);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: false);
				break;
			case HandsVisualMode.Skeleton:
				RightHandMeshRenderer.enabled = false;
				_rightMeshRenderer.enabled = false;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = false;
				_leftMeshRenderer.enabled = false;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			case HandsVisualMode.Both:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			}
		}

		public static List<OVRBoneCapsule> GetCapsulesPerBone(OVRSkeleton skeleton, OVRSkeleton.BoneId boneId)
		{
			List<OVRBoneCapsule> list = new List<OVRBoneCapsule>();
			IList<OVRBoneCapsule> capsules = skeleton.Capsules;
			for (int i = 0; i < capsules.Count; i++)
			{
				if (capsules[i].BoneIndex == (short)boneId)
				{
					list.Add(capsules[i]);
				}
			}
			return list;
		}

		public bool IsInitialized()
		{
			if ((bool)LeftHandSkeleton && LeftHandSkeleton.IsInitialized && (bool)RightHandSkeleton && RightHandSkeleton.IsInitialized && (bool)LeftHandMesh && LeftHandMesh.IsInitialized && (bool)RightHandMesh)
			{
				return RightHandMesh.IsInitialized;
			}
			return false;
		}
	}
	public abstract class Interactable : MonoBehaviour
	{
		[Serializable]
		public class InteractableStateArgsEvent : UnityEvent<InteractableStateArgs>
		{
		}

		protected ColliderZone _proximityZoneCollider;

		protected ColliderZone _contactZoneCollider;

		protected ColliderZone _actionZoneCollider;

		public InteractableStateArgsEvent InteractableStateChanged;

		public ColliderZone ProximityCollider => _proximityZoneCollider;

		public ColliderZone ContactCollider => _contactZoneCollider;

		public ColliderZone ActionCollider => _actionZoneCollider;

		public virtual int ValidToolTagsMask => -1;

		public event Action<ColliderZoneArgs> ProximityZoneEvent;

		public event Action<ColliderZoneArgs> ContactZoneEvent;

		public event Action<ColliderZoneArgs> ActionZoneEvent;

		protected virtual void OnProximityZoneEvent(ColliderZoneArgs args)
		{
			if (this.ProximityZoneEvent != null)
			{
				this.ProximityZoneEvent(args);
			}
		}

		protected virtual void OnContactZoneEvent(ColliderZoneArgs args)
		{
			if (this.ContactZoneEvent != null)
			{
				this.ContactZoneEvent(args);
			}
		}

		protected virtual void OnActionZoneEvent(ColliderZoneArgs args)
		{
			if (this.ActionZoneEvent != null)
			{
				this.ActionZoneEvent(args);
			}
		}

		public abstract void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth);

		protected virtual void Awake()
		{
			InteractableRegistry.RegisterInteractable(this);
		}

		protected virtual void OnDestroy()
		{
			InteractableRegistry.UnregisterInteractable(this);
		}
	}
	public enum InteractableCollisionDepth
	{
		None,
		Proximity,
		Contact,
		Action
	}
	public enum InteractableState
	{
		Default,
		ProximityState,
		ContactState,
		ActionState
	}
	public class InteractableStateArgs : EventArgs
	{
		public readonly Interactable Interactable;

		public readonly InteractableTool Tool;

		public readonly InteractableState OldInteractableState;

		public readonly InteractableState NewInteractableState;

		public readonly ColliderZoneArgs ColliderArgs;

		public InteractableStateArgs(Interactable interactable, InteractableTool tool, InteractableState newInteractableState, InteractableState oldState, ColliderZoneArgs colliderArgs)
		{
			Interactable = interactable;
			Tool = tool;
			NewInteractableState = newInteractableState;
			OldInteractableState = oldState;
			ColliderArgs = colliderArgs;
		}
	}
	public class InteractableRegistry : MonoBehaviour
	{
		public static HashSet<Interactable> _interactables = new HashSet<Interactable>();

		public static HashSet<Interactable> Interactables => _interactables;

		public static void RegisterInteractable(Interactable interactable)
		{
			Interactables.Add(interactable);
		}

		public static void UnregisterInteractable(Interactable interactable)
		{
			Interactables.Remove(interactable);
		}
	}
	public class InteractableToolsCreator : MonoBehaviour
	{
		[SerializeField]
		private Transform[] LeftHandTools;

		[SerializeField]
		private Transform[] RightHandTools;

		private void Awake()
		{
			if (LeftHandTools != null && LeftHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(LeftHandTools, isRightHand: false));
			}
			if (RightHandTools != null && RightHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(RightHandTools, isRightHand: true));
			}
		}

		private IEnumerator AttachToolsToHands(Transform[] toolObjects, bool isRightHand)
		{
			HandsManager handsManagerObj;
			while (true)
			{
				HandsManager instance;
				handsManagerObj = (instance = HandsManager.Instance);
				if (!(instance == null) && handsManagerObj.IsInitialized())
				{
					break;
				}
				yield return null;
			}
			HashSet<Transform> hashSet = new HashSet<Transform>();
			foreach (Transform transform in toolObjects)
			{
				hashSet.Add(transform.transform);
			}
			foreach (Transform toolObject in hashSet)
			{
				OVRSkeleton handSkeletonToAttachTo = (isRightHand ? handsManagerObj.RightHandSkeleton : handsManagerObj.LeftHandSkeleton);
				while (handSkeletonToAttachTo == null || handSkeletonToAttachTo.Bones == null)
				{
					yield return null;
				}
				AttachToolToHandTransform(toolObject, isRightHand);
			}
		}

		private void AttachToolToHandTransform(Transform tool, bool isRightHanded)
		{
			Transform obj = UnityEngine.Object.Instantiate(tool).transform;
			obj.localPosition = Vector3.zero;
			InteractableTool component = obj.GetComponent<InteractableTool>();
			component.IsRightHandedTool = isRightHanded;
			component.Initialize();
		}
	}
	public class InteractableToolsInputRouter : MonoBehaviour
	{
		private static InteractableToolsInputRouter _instance;

		private bool _leftPinch;

		private bool _rightPinch;

		private HashSet<InteractableTool> _leftHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _leftHandFarTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandFarTools = new HashSet<InteractableTool>();

		public static InteractableToolsInputRouter Instance
		{
			get
			{
				if (_instance == null)
				{
					InteractableToolsInputRouter[] array = UnityEngine.Object.FindObjectsOfType<InteractableToolsInputRouter>();
					if (array.Length != 0)
					{
						_instance = array[0];
						for (int i = 1; i < array.Length; i++)
						{
							UnityEngine.Object.Destroy(array[i].gameObject);
						}
					}
				}
				return _instance;
			}
		}

		public void RegisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Add(interactableTool);
				}
				else
				{
					_rightHandNearTools.Add(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Add(interactableTool);
			}
			else
			{
				_leftHandNearTools.Add(interactableTool);
			}
		}

		public void UnregisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Remove(interactableTool);
				}
				else
				{
					_rightHandNearTools.Remove(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Remove(interactableTool);
			}
			else
			{
				_leftHandNearTools.Remove(interactableTool);
			}
		}

		private void Update()
		{
			if (HandsManager.Instance.IsInitialized())
			{
				bool flag = HandsManager.Instance.LeftHand.IsTracked && HandsManager.Instance.LeftHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool flag2 = HandsManager.Instance.RightHand.IsTracked && HandsManager.Instance.RightHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool isPointerPoseValid = HandsManager.Instance.LeftHand.IsPointerPoseValid;
				bool isPointerPoseValid2 = HandsManager.Instance.RightHand.IsPointerPoseValid;
				bool flag3 = UpdateToolsAndEnableState(_leftHandNearTools, flag);
				UpdateToolsAndEnableState(_leftHandFarTools, !flag3 && flag && isPointerPoseValid);
				bool flag4 = UpdateToolsAndEnableState(_rightHandNearTools, flag2);
				UpdateToolsAndEnableState(_rightHandFarTools, !flag4 && flag2 && isPointerPoseValid2);
			}
		}

		private bool UpdateToolsAndEnableState(HashSet<InteractableTool> tools, bool toolsAreEnabledThisFrame)
		{
			bool result = UpdateTools(tools, !toolsAreEnabledThisFrame);
			ToggleToolsEnableState(tools, toolsAreEnabledThisFrame);
			return result;
		}

		private bool UpdateTools(HashSet<InteractableTool> tools, bool resetCollisionData = false)
		{
			bool flag = false;
			foreach (InteractableTool tool in tools)
			{
				List<InteractableCollisionInfo> nextIntersectingObjects = tool.GetNextIntersectingObjects();
				if (nextIntersectingObjects.Count > 0 && !resetCollisionData)
				{
					if (!flag)
					{
						flag = nextIntersectingObjects.Count > 0;
					}
					tool.UpdateCurrentCollisionsBasedOnDepth();
					if (tool.IsFarFieldTool)
					{
						KeyValuePair<Interactable, InteractableCollisionInfo> firstCurrentCollisionInfo = tool.GetFirstCurrentCollisionInfo();
						if (tool.ToolInputState == ToolInputState.PrimaryInputUp)
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ActionCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Action;
						}
						else
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ContactCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Contact;
						}
						tool.FocusOnInteractable(firstCurrentCollisionInfo.Key, firstCurrentCollisionInfo.Value.InteractableCollider);
					}
				}
				else
				{
					tool.DeFocus();
					tool.ClearAllCurrentCollisionInfos();
				}
				tool.UpdateLatestCollisionData();
			}
			return flag;
		}

		private void ToggleToolsEnableState(HashSet<InteractableTool> tools, bool enableState)
		{
			foreach (InteractableTool tool in tools)
			{
				if (tool.EnableState != enableState)
				{
					tool.EnableState = enableState;
				}
			}
		}
	}
	public class FingerTipPokeTool : InteractableTool
	{
		private const int NUM_VELOCITY_FRAMES = 10;

		[SerializeField]
		private FingerTipPokeToolView _fingerTipPokeToolView;

		[SerializeField]
		private OVRPlugin.HandFinger _fingerToFollow = OVRPlugin.HandFinger.Index;

		private Vector3[] _velocityFrames;

		private int _currVelocityFrame;

		private bool _sampledMaxFramesAlready;

		private Vector3 _position;

		private BoneCapsuleTriggerLogic[] _boneCapsuleTriggerLogic;

		private float _lastScale = 1f;

		private bool _isInitialized;

		private OVRBoneCapsule _capsuleToTrack;

		public override InteractableToolTags ToolTags => InteractableToolTags.Poke;

		public override ToolInputState ToolInputState => ToolInputState.Inactive;

		public override bool IsFarFieldTool => false;

		public override bool EnableState
		{
			get
			{
				return _fingerTipPokeToolView.gameObject.activeSelf;
			}
			set
			{
				_fingerTipPokeToolView.gameObject.SetActive(value);
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_fingerTipPokeToolView.InteractableTool = this;
			_velocityFrames = new Vector3[10];
			Array.Clear(_velocityFrames, 0, 10);
			StartCoroutine(AttachTriggerLogic());
		}

		private IEnumerator AttachTriggerLogic()
		{
			while (!HandsManager.Instance || !HandsManager.Instance.IsInitialized())
			{
				yield return null;
			}
			OVRSkeleton skeleton = (base.IsRightHandedTool ? HandsManager.Instance.RightHandSkeleton : HandsManager.Instance.LeftHandSkeleton);
			OVRSkeleton.BoneId boneId = _fingerToFollow switch
			{
				OVRPlugin.HandFinger.Thumb => OVRSkeleton.BoneId.Hand_Thumb3, 
				OVRPlugin.HandFinger.Index => OVRSkeleton.BoneId.Hand_Index3, 
				OVRPlugin.HandFinger.Middle => OVRSkeleton.BoneId.Hand_Middle3, 
				OVRPlugin.HandFinger.Ring => OVRSkeleton.BoneId.Hand_Ring3, 
				_ => OVRSkeleton.BoneId.Hand_Pinky3, 
			};
			List<BoneCapsuleTriggerLogic> list = new List<BoneCapsuleTriggerLogic>();
			List<OVRBoneCapsule> capsulesPerBone = HandsManager.GetCapsulesPerBone(skeleton, boneId);
			foreach (OVRBoneCapsule item in capsulesPerBone)
			{
				BoneCapsuleTriggerLogic boneCapsuleTriggerLogic = item.CapsuleRigidbody.gameObject.AddComponent<BoneCapsuleTriggerLogic>();
				item.CapsuleCollider.isTrigger = true;
				boneCapsuleTriggerLogic.ToolTags = ToolTags;
				list.Add(boneCapsuleTriggerLogic);
			}
			_boneCapsuleTriggerLogic = list.ToArray();
			if (capsulesPerBone.Count > 0)
			{
				_capsuleToTrack = capsulesPerBone[0];
			}
			_isInitialized = true;
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _isInitialized && _capsuleToTrack != null)
			{
				float handScale = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand).HandScale;
				Transform transform = _capsuleToTrack.CapsuleCollider.transform;
				Vector3 right = transform.right;
				Vector3 vector = transform.position + _capsuleToTrack.CapsuleCollider.height * 0.5f * right;
				Vector3 vector2 = handScale * _fingerTipPokeToolView.SphereRadius * right;
				Vector3 position = vector + vector2;
				base.transform.position = position;
				base.transform.rotation = transform.rotation;
				base.InteractionPosition = vector;
				UpdateAverageVelocity();
				CheckAndUpdateScale();
			}
		}

		private void UpdateAverageVelocity()
		{
			Vector3 position = _position;
			Vector3 position2 = base.transform.position;
			Vector3 vector = (position2 - position) / Time.deltaTime;
			_position = position2;
			_velocityFrames[_currVelocityFrame] = vector;
			_currVelocityFrame = (_currVelocityFrame + 1) % 10;
			base.Velocity = Vector3.zero;
			if (!_sampledMaxFramesAlready && _currVelocityFrame == 9)
			{
				_sampledMaxFramesAlready = true;
			}
			int num = (_sampledMaxFramesAlready ? 10 : (_currVelocityFrame + 1));
			for (int i = 0; i < num; i++)
			{
				base.Velocity += _velocityFrames[i];
			}
			base.Velocity /= (float)num;
		}

		private void CheckAndUpdateScale()
		{
			float num = (base.IsRightHandedTool ? HandsManager.Instance.RightHand.HandScale : HandsManager.Instance.LeftHand.HandScale);
			if (Mathf.Abs(num - _lastScale) > Mathf.Epsilon)
			{
				base.transform.localScale = new Vector3(num, num, num);
				_lastScale = num;
			}
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			_currentIntersectingObjects.Clear();
			BoneCapsuleTriggerLogic[] boneCapsuleTriggerLogic = _boneCapsuleTriggerLogic;
			for (int i = 0; i < boneCapsuleTriggerLogic.Length; i++)
			{
				foreach (ColliderZone collidersTouchingU in boneCapsuleTriggerLogic[i].CollidersTouchingUs)
				{
					_currentIntersectingObjects.Add(new InteractableCollisionInfo(collidersTouchingU, collidersTouchingU.CollisionDepth, this));
				}
			}
			return _currentIntersectingObjects;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
		}

		public override void DeFocus()
		{
		}
	}
	public class FingerTipPokeToolView : MonoBehaviour, InteractableToolView
	{
		[SerializeField]
		private MeshRenderer _sphereMeshRenderer;

		public InteractableTool InteractableTool { get; set; }

		public bool EnableState
		{
			get
			{
				return _sphereMeshRenderer.enabled;
			}
			set
			{
				_sphereMeshRenderer.enabled = value;
			}
		}

		public bool ToolActivateState { get; set; }

		public float SphereRadius { get; private set; }

		private void Awake()
		{
			SphereRadius = _sphereMeshRenderer.transform.localScale.z * 0.5f;
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
		}
	}
	[Flags]
	public enum InteractableToolTags
	{
		None = 0,
		Ray = 1,
		Poke = 4,
		All = -1
	}
	public enum ToolInputState
	{
		Inactive,
		PrimaryInputDown,
		PrimaryInputDownStay,
		PrimaryInputUp
	}
	public class InteractableCollisionInfo
	{
		public ColliderZone InteractableCollider;

		public InteractableCollisionDepth CollisionDepth;

		public InteractableTool CollidingTool;

		public InteractableCollisionInfo(ColliderZone collider, InteractableCollisionDepth collisionDepth, InteractableTool collidingTool)
		{
			InteractableCollider = collider;
			CollisionDepth = collisionDepth;
			CollidingTool = collidingTool;
		}
	}
	public abstract class InteractableTool : MonoBehaviour
	{
		protected List<InteractableCollisionInfo> _currentIntersectingObjects = new List<InteractableCollisionInfo>();

		private List<Interactable> _addedInteractables = new List<Interactable>();

		private List<Interactable> _removedInteractables = new List<Interactable>();

		private List<Interactable> _remainingInteractables = new List<Interactable>();

		private Dictionary<Interactable, InteractableCollisionInfo> _currInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		private Dictionary<Interactable, InteractableCollisionInfo> _prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		public Transform ToolTransform => base.transform;

		public bool IsRightHandedTool { get; set; }

		public abstract InteractableToolTags ToolTags { get; }

		public abstract ToolInputState ToolInputState { get; }

		public abstract bool IsFarFieldTool { get; }

		public Vector3 Velocity { get; protected set; }

		public Vector3 InteractionPosition { get; protected set; }

		public abstract bool EnableState { get; set; }

		public List<InteractableCollisionInfo> GetCurrentIntersectingObjects()
		{
			return _currentIntersectingObjects;
		}

		public abstract List<InteractableCollisionInfo> GetNextIntersectingObjects();

		public abstract void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone);

		public abstract void DeFocus();

		public abstract void Initialize();

		public KeyValuePair<Interactable, InteractableCollisionInfo> GetFirstCurrentCollisionInfo()
		{
			return _currInteractableToCollisionInfos.First();
		}

		public void ClearAllCurrentCollisionInfos()
		{
			_currInteractableToCollisionInfos.Clear();
		}

		public virtual void UpdateCurrentCollisionsBasedOnDepth()
		{
			_currInteractableToCollisionInfos.Clear();
			foreach (InteractableCollisionInfo currentIntersectingObject in _currentIntersectingObjects)
			{
				Interactable parentInteractable = currentIntersectingObject.InteractableCollider.ParentInteractable;
				InteractableCollisionDepth collisionDepth = currentIntersectingObject.CollisionDepth;
				InteractableCollisionInfo value = null;
				if (!_currInteractableToCollisionInfos.TryGetValue(parentInteractable, out value))
				{
					_currInteractableToCollisionInfos[parentInteractable] = currentIntersectingObject;
				}
				else if (value.CollisionDepth < collisionDepth)
				{
					value.InteractableCollider = currentIntersectingObject.InteractableCollider;
					value.CollisionDepth = collisionDepth;
				}
			}
		}

		public virtual void UpdateLatestCollisionData()
		{
			_addedInteractables.Clear();
			_removedInteractables.Clear();
			_remainingInteractables.Clear();
			foreach (Interactable key in _currInteractableToCollisionInfos.Keys)
			{
				if (!_prevInteractableToCollisionInfos.ContainsKey(key))
				{
					_addedInteractables.Add(key);
				}
				else
				{
					_remainingInteractables.Add(key);
				}
			}
			foreach (Interactable key2 in _prevInteractableToCollisionInfos.Keys)
			{
				if (!_currInteractableToCollisionInfos.ContainsKey(key2))
				{
					_removedInteractables.Add(key2);
				}
			}
			foreach (Interactable removedInteractable in _removedInteractables)
			{
				removedInteractable.UpdateCollisionDepth(this, _prevInteractableToCollisionInfos[removedInteractable].CollisionDepth, InteractableCollisionDepth.None);
			}
			foreach (Interactable addedInteractable in _addedInteractables)
			{
				InteractableCollisionDepth collisionDepth = _currInteractableToCollisionInfos[addedInteractable].CollisionDepth;
				addedInteractable.UpdateCollisionDepth(this, InteractableCollisionDepth.None, collisionDepth);
			}
			foreach (Interactable remainingInteractable in _remainingInteractables)
			{
				InteractableCollisionDepth collisionDepth2 = _currInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				InteractableCollisionDepth collisionDepth3 = _prevInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				remainingInteractable.UpdateCollisionDepth(this, collisionDepth3, collisionDepth2);
			}
			_prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>(_currInteractableToCollisionInfos);
		}
	}
	public interface InteractableToolView
	{
		InteractableTool InteractableTool { get; }

		bool EnableState { get; set; }

		bool ToolActivateState { get; set; }

		void SetFocusedInteractable(Interactable interactable);
	}
	public class PinchStateModule
	{
		private enum PinchState
		{
			None,
			PinchDown,
			PinchStay,
			PinchUp
		}

		private const float PINCH_STRENGTH_THRESHOLD = 1f;

		private PinchState _currPinchState;

		private Interactable _firstFocusedInteractable;

		public bool PinchUpAndDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchUp)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchSteadyOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchStay)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchDown)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public PinchStateModule()
		{
			_currPinchState = PinchState.None;
			_firstFocusedInteractable = null;
		}

		public void UpdateState(OVRHand hand, Interactable currFocusedInteractable)
		{
			float fingerPinchStrength = hand.GetFingerPinchStrength(OVRHand.HandFinger.Index);
			bool flag = Mathf.Abs(1f - fingerPinchStrength) < Mathf.Epsilon;
			switch (_currPinchState)
			{
			case PinchState.PinchUp:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					if (currFocusedInteractable != _firstFocusedInteractable)
					{
						_firstFocusedInteractable = null;
					}
				}
				else
				{
					_currPinchState = PinchState.None;
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchStay:
				if (!flag)
				{
					_currPinchState = PinchState.PinchUp;
				}
				if (currFocusedInteractable != _firstFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchDown:
				_currPinchState = (flag ? PinchState.PinchStay : PinchState.PinchUp);
				if (_firstFocusedInteractable != currFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			default:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					_firstFocusedInteractable = currFocusedInteractable;
				}
				break;
			}
		}
	}
	public class RayTool : InteractableTool
	{
		private const float MINIMUM_RAY_CAST_DISTANCE = 0.8f;

		private const float COLLIDER_RADIUS = 0.01f;

		private const int NUM_MAX_PRIMARY_HITS = 10;

		private const int NUM_MAX_SECONDARY_HITS = 25;

		private const int NUM_COLLIDERS_TO_TEST = 20;

		[SerializeField]
		private RayToolView _rayToolView;

		[Range(0f, 45f)]
		[SerializeField]
		private float _coneAngleDegrees = 20f;

		[SerializeField]
		private float _farFieldMaxDistance = 5f;

		private PinchStateModule _pinchStateModule = new PinchStateModule();

		private Interactable _focusedInteractable;

		private Collider[] _collidersOverlapped = new Collider[20];

		private Interactable _currInteractableCastedAgainst;

		private float _coneAngleReleaseDegrees;

		private RaycastHit[] _primaryHits = new RaycastHit[10];

		private Collider[] _secondaryOverlapResults = new Collider[25];

		private bool _initialized;

		public override InteractableToolTags ToolTags => InteractableToolTags.Ray;

		public override ToolInputState ToolInputState
		{
			get
			{
				if (_pinchStateModule.PinchDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDown;
				}
				if (_pinchStateModule.PinchSteadyOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDownStay;
				}
				if (_pinchStateModule.PinchUpAndDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputUp;
				}
				return ToolInputState.Inactive;
			}
		}

		public override bool IsFarFieldTool => true;

		public override bool EnableState
		{
			get
			{
				return _rayToolView.EnableState;
			}
			set
			{
				_rayToolView.EnableState = value;
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_rayToolView.InteractableTool = this;
			_coneAngleReleaseDegrees = _coneAngleDegrees * 1.2f;
			_initialized = true;
		}

		private void OnDestroy()
		{
			if (InteractableToolsInputRouter.Instance != null)
			{
				InteractableToolsInputRouter.Instance.UnregisterInteractableTool(this);
			}
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _initialized)
			{
				OVRHand oVRHand = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand);
				Transform pointerPose = oVRHand.PointerPose;
				base.transform.position = pointerPose.position;
				base.transform.rotation = pointerPose.rotation;
				Vector3 interactionPosition = base.InteractionPosition;
				Vector3 position = base.transform.position;
				base.Velocity = (position - interactionPosition) / Time.deltaTime;
				base.InteractionPosition = position;
				_pinchStateModule.UpdateState(oVRHand, _focusedInteractable);
				_rayToolView.ToolActivateState = _pinchStateModule.PinchSteadyOnFocusedObject || _pinchStateModule.PinchDownOnFocusedObject;
			}
		}

		private Vector3 GetRayCastOrigin()
		{
			return base.transform.position + 0.8f * base.transform.forward;
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			if (!_initialized)
			{
				return _currentIntersectingObjects;
			}
			if (_currInteractableCastedAgainst != null && HasRayReleasedInteractable(_currInteractableCastedAgainst))
			{
				_currInteractableCastedAgainst = null;
			}
			if (_currInteractableCastedAgainst == null)
			{
				_currentIntersectingObjects.Clear();
				_currInteractableCastedAgainst = FindTargetInteractable();
				if (_currInteractableCastedAgainst != null)
				{
					int num = Physics.OverlapSphereNonAlloc(_currInteractableCastedAgainst.transform.position, 0.01f, _collidersOverlapped);
					for (int i = 0; i < num; i++)
					{
						ColliderZone component = _collidersOverlapped[i].GetComponent<ColliderZone>();
						if (component != null)
						{
							Interactable parentInteractable = component.ParentInteractable;
							if (!(parentInteractable == null) && !(parentInteractable != _currInteractableCastedAgainst))
							{
								InteractableCollisionInfo item = new InteractableCollisionInfo(component, component.CollisionDepth, this);
								_currentIntersectingObjects.Add(item);
							}
						}
					}
					if (_currentIntersectingObjects.Count == 0)
					{
						_currInteractableCastedAgainst = null;
					}
				}
			}
			return _currentIntersectingObjects;
		}

		private bool HasRayReleasedInteractable(Interactable focusedInteractable)
		{
			Vector3 position = base.transform.position;
			Vector3 forward = base.transform.forward;
			float num = Mathf.Cos(_coneAngleReleaseDegrees * ((float)Math.PI / 180f));
			Vector3 lhs = focusedInteractable.transform.position - position;
			lhs.Normalize();
			return Vector3.Dot(lhs, forward) < num;
		}

		private Interactable FindTargetInteractable()
		{
			Vector3 rayCastOrigin = GetRayCastOrigin();
			Vector3 forward = base.transform.forward;
			Interactable interactable = null;
			interactable = FindPrimaryRaycastHit(rayCastOrigin, forward);
			if (interactable == null)
			{
				interactable = FindInteractableViaConeTest(rayCastOrigin, forward);
			}
			return interactable;
		}

		private Interactable FindPrimaryRaycastHit(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			int num = Physics.RaycastNonAlloc(new Ray(rayOrigin, rayDirection), _primaryHits, float.PositiveInfinity);
			float num2 = 0f;
			for (int i = 0; i < num; i++)
			{
				RaycastHit raycastHit = _primaryHits[i];
				ColliderZone component = raycastHit.transform.GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					float magnitude = (parentInteractable.transform.position - rayOrigin).magnitude;
					if (interactable == null || magnitude < num2)
					{
						interactable = parentInteractable;
						num2 = magnitude;
					}
				}
			}
			return interactable;
		}

		private Interactable FindInteractableViaConeTest(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			float num = 0f;
			float num2 = Mathf.Cos(_coneAngleDegrees * ((float)Math.PI / 180f));
			float num3 = Mathf.Tan((float)Math.PI / 180f * _coneAngleDegrees * 0.5f) * _farFieldMaxDistance;
			int num4 = Physics.OverlapBoxNonAlloc(rayOrigin + rayDirection * _farFieldMaxDistance * 0.5f, new Vector3(num3, num3, _farFieldMaxDistance * 0.5f), _secondaryOverlapResults, base.transform.rotation);
			for (int i = 0; i < num4; i++)
			{
				ColliderZone component = _secondaryOverlapResults[i].GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					Vector3 lhs = parentInteractable.transform.position - rayOrigin;
					float magnitude = lhs.magnitude;
					lhs /= magnitude;
					if (!(Vector3.Dot(lhs, rayDirection) < num2) && (interactable == null || magnitude < num))
					{
						interactable = parentInteractable;
						num = magnitude;
					}
				}
			}
			return interactable;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
			_rayToolView.SetFocusedInteractable(focusedInteractable);
			_focusedInteractable = focusedInteractable;
		}

		public override void DeFocus()
		{
			_rayToolView.SetFocusedInteractable(null);
			_focusedInteractable = null;
		}
	}
	public class RayToolView : MonoBehaviour, InteractableToolView
	{
		private const int NUM_RAY_LINE_POSITIONS = 25;

		private const float DEFAULT_RAY_CAST_DISTANCE = 3f;

		[SerializeField]
		private Transform _targetTransform;

		[SerializeField]
		private LineRenderer _lineRenderer;

		private bool _toolActivateState;

		private Transform _focusedTransform;

		private Vector3[] linePositions = new Vector3[25];

		private Gradient _oldColorGradient;

		private Gradient _highLightColorGradient;

		public bool EnableState
		{
			get
			{
				return _lineRenderer.enabled;
			}
			set
			{
				_targetTransform.gameObject.SetActive(value);
				_lineRenderer.enabled = value;
			}
		}

		public bool ToolActivateState
		{
			get
			{
				return _toolActivateState;
			}
			set
			{
				_toolActivateState = value;
				_lineRenderer.colorGradient = (_toolActivateState ? _highLightColorGradient : _oldColorGradient);
			}
		}

		public InteractableTool InteractableTool { get; set; }

		private void Awake()
		{
			_lineRenderer.positionCount = 25;
			_oldColorGradient = _lineRenderer.colorGradient;
			_highLightColorGradient = new Gradient();
			_highLightColorGradient.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 0f),
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(1f, 0f),
				new GradientAlphaKey(1f, 1f)
			});
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
			if (interactable == null)
			{
				_focusedTransform = null;
			}
			else
			{
				_focusedTransform = interactable.transform;
			}
		}

		private void Update()
		{
			Vector3 position = InteractableTool.ToolTransform.position;
			Vector3 forward = InteractableTool.ToolTransform.forward;
			Vector3 vector = ((_focusedTransform != null) ? _focusedTransform.position : (position + forward * 3f));
			float magnitude = (vector - position).magnitude;
			Vector3 p = position;
			Vector3 p2 = position + forward * magnitude * 0.3333333f;
			Vector3 p3 = position + forward * magnitude * (2f / 3f);
			Vector3 p4 = vector;
			for (int i = 0; i < 25; i++)
			{
				linePositions[i] = GetPointOnBezierCurve(p, p2, p3, p4, (float)i / 25f);
			}
			_lineRenderer.SetPositions(linePositions);
			_targetTransform.position = vector;
		}

		public static Vector3 GetPointOnBezierCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return num * num2 * p0 + 3f * num2 * t * p1 + 3f * num * num3 * p2 + t * num3 * p3;
		}
	}
	public class DistanceGrabberSample : MonoBehaviour
	{
		private bool useSpherecast;

		private bool allowGrabThroughWalls;

		[SerializeField]
		private DistanceGrabber[] m_grabbers;

		public bool UseSpherecast
		{
			get
			{
				return useSpherecast;
			}
			set
			{
				useSpherecast = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].UseSpherecast = useSpherecast;
				}
			}
		}

		public bool AllowGrabThroughWalls
		{
			get
			{
				return allowGrabThroughWalls;
			}
			set
			{
				allowGrabThroughWalls = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].m_preventGrabThroughWalls = !allowGrabThroughWalls;
				}
			}
		}

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("Distance Grab Sample");
			DebugUIBuilder.instance.AddToggle("Use Spherecasting", ToggleSphereCasting, useSpherecast);
			DebugUIBuilder.instance.AddToggle("Grab Through Walls", ToggleGrabThroughWalls, allowGrabThroughWalls);
			DebugUIBuilder.instance.Show();
			float displayFrequency = OVRManager.display.displayFrequency;
			if (displayFrequency > 0.1f)
			{
				UnityEngine.Debug.Log("Setting Time.fixedDeltaTime to: " + 1f / displayFrequency);
				Time.fixedDeltaTime = 1f / displayFrequency;
			}
		}

		public void ToggleSphereCasting(Toggle t)
		{
			UseSpherecast = !UseSpherecast;
		}

		public void ToggleGrabThroughWalls(Toggle t)
		{
			AllowGrabThroughWalls = !AllowGrabThroughWalls;
		}
	}
	public class ControllerBoxController : MonoBehaviour
	{
		[SerializeField]
		private TrainLocomotive _locomotive;

		[SerializeField]
		private CowController _cowController;

		private void Awake()
		{
		}

		public void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.StartStopStateChanged();
			}
		}

		public void DecreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.DecreaseSpeedStateChanged();
			}
		}

		public void IncreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.IncreaseSpeedStateChanged();
			}
		}

		public void SmokeButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.SmokeButtonStateChanged();
			}
		}

		public void WhistleButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.WhistleButtonStateChanged();
			}
		}

		public void ReverseButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.ReverseButtonStateChanged();
			}
		}

		public void SwitchVisualization(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				HandsManager.Instance.SwitchVisualization();
			}
		}

		public void GoMoo(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_cowController.GoMooCowGo();
			}
		}
	}
	public class CowController : MonoBehaviour
	{
		[SerializeField]
		private Animation _cowAnimation;

		[SerializeField]
		private AudioSource _mooCowAudioSource;

		private void Start()
		{
		}

		public void PlayMooSound()
		{
			_mooCowAudioSource.timeSamples = 0;
			_mooCowAudioSource.Play();
		}

		public void GoMooCowGo()
		{
			_cowAnimation.Rewind();
			_cowAnimation.Play();
		}
	}
	public class PanelHMDFollower : MonoBehaviour
	{
		private const float TOTAL_DURATION = 3f;

		private const float HMD_MOVEMENT_THRESHOLD = 0.3f;

		[SerializeField]
		private float _maxDistance = 0.3f;

		[SerializeField]
		private float _minDistance = 0.05f;

		[SerializeField]
		private float _minZDistance = 0.05f;

		private OVRCameraRig _cameraRig;

		private Vector3 _panelInitialPosition = Vector3.zero;

		private Coroutine _coroutine;

		private Vector3 _prevPos = Vector3.zero;

		private Vector3 _lastMovedToPos = Vector3.zero;

		private void Awake()
		{
			_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			_panelInitialPosition = base.transform.position;
		}

		private void Update()
		{
			Vector3 position = _cameraRig.centerEyeAnchor.position;
			_ = base.transform.position;
			float num = Vector3.Distance(position, _lastMovedToPos);
			float num2 = (_cameraRig.centerEyeAnchor.position - _prevPos).magnitude / Time.deltaTime;
			Vector3 vector = base.transform.position - position;
			float magnitude = vector.magnitude;
			if ((num > _maxDistance || _minZDistance > vector.z || _minDistance > magnitude) && num2 < 0.3f && _coroutine == null && _coroutine == null)
			{
				_coroutine = StartCoroutine(LerpToHMD());
			}
			_prevPos = _cameraRig.centerEyeAnchor.position;
		}

		private Vector3 CalculateIdealAnchorPosition()
		{
			return _cameraRig.centerEyeAnchor.position + _panelInitialPosition;
		}

		private IEnumerator LerpToHMD()
		{
			Vector3 newPanelPosition = CalculateIdealAnchorPosition();
			_lastMovedToPos = _cameraRig.centerEyeAnchor.position;
			float startTime = Time.time;
			float endTime = Time.time + 3f;
			while (Time.time < endTime)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, newPanelPosition, (Time.time - startTime) / 3f);
				yield return null;
			}
			base.transform.position = newPanelPosition;
			_coroutine = null;
		}
	}
	public class SelectionCylinder : MonoBehaviour
	{
		public enum SelectionState
		{
			Off,
			Selected,
			Highlighted
		}

		[SerializeField]
		private MeshRenderer _selectionMeshRenderer;

		private static int _colorId = Shader.PropertyToID("_Color");

		private Material[] _selectionMaterials;

		private Color[] _defaultSelectionColors;

		private Color[] _highlightColors;

		private SelectionState _currSelectionState;

		public SelectionState CurrSelectionState
		{
			get
			{
				return _currSelectionState;
			}
			set
			{
				SelectionState currSelectionState = _currSelectionState;
				_currSelectionState = value;
				if (currSelectionState != _currSelectionState)
				{
					if (_currSelectionState > SelectionState.Off)
					{
						_selectionMeshRenderer.enabled = true;
						AffectSelectionColor((_currSelectionState == SelectionState.Selected) ? _defaultSelectionColors : _highlightColors);
					}
					else
					{
						_selectionMeshRenderer.enabled = false;
					}
				}
			}
		}

		private void Awake()
		{
			_selectionMaterials = _selectionMeshRenderer.materials;
			int num = _selectionMaterials.Length;
			_defaultSelectionColors = new Color[num];
			_highlightColors = new Color[num];
			for (int i = 0; i < num; i++)
			{
				_defaultSelectionColors[i] = _selectionMaterials[i].GetColor(_colorId);
				_highlightColors[i] = new Color(1f, 1f, 1f, _defaultSelectionColors[i].a);
			}
			CurrSelectionState = SelectionState.Off;
		}

		private void OnDestroy()
		{
			if (_selectionMaterials == null)
			{
				return;
			}
			Material[] selectionMaterials = _selectionMaterials;
			foreach (Material material in selectionMaterials)
			{
				if (material != null)
				{
					UnityEngine.Object.Destroy(material);
				}
			}
		}

		private void AffectSelectionColor(Color[] newColors)
		{
			int num = newColors.Length;
			for (int i = 0; i < num; i++)
			{
				_selectionMaterials[i].SetColor(_colorId, newColors[i]);
			}
		}
	}
	public class TrackSegment : MonoBehaviour
	{
		public enum SegmentType
		{
			Straight,
			LeftTurn,
			RightTurn,
			Switch
		}

		[SerializeField]
		private SegmentType _segmentType;

		[SerializeField]
		private MeshFilter _straight;

		[SerializeField]
		private MeshFilter _leftTurn;

		[SerializeField]
		private MeshFilter _rightTurn;

		private float _gridSize = 0.8f;

		private int _subDivCount = 20;

		private const float _originalGridSize = 0.8f;

		private const float _trackWidth = 0.15f;

		private GameObject _mesh;

		private Pose _p1 = new Pose();

		private Pose _p2 = new Pose();

		private Pose _endPose = new Pose();

		public float StartDistance { get; set; }

		public float GridSize
		{
			get
			{
				return _gridSize;
			}
			private set
			{
				_gridSize = value;
			}
		}

		public int SubDivCount
		{
			get
			{
				return _subDivCount;
			}
			set
			{
				_subDivCount = value;
			}
		}

		public SegmentType Type => _segmentType;

		public Pose EndPose
		{
			get
			{
				UpdatePose(SegmentLength, _endPose);
				return _endPose;
			}
		}

		public float Radius => 0.5f * GridSize;

		public float SegmentLength
		{
			get
			{
				switch (Type)
				{
				case SegmentType.Straight:
					return GridSize;
				case SegmentType.LeftTurn:
				case SegmentType.RightTurn:
					return (float)Math.PI / 2f * Radius;
				default:
					return 1f;
				}
			}
		}

		public float setGridSize(float size)
		{
			GridSize = size;
			return GridSize / 0.8f;
		}

		private void Awake()
		{
		}

		public void UpdatePose(float distanceIntoSegment, Pose pose)
		{
			if (Type == SegmentType.Straight)
			{
				pose.Position = base.transform.position + distanceIntoSegment * base.transform.forward;
				pose.Rotation = base.transform.rotation;
			}
			else if (Type == SegmentType.LeftTurn)
			{
				float num = distanceIntoSegment / SegmentLength;
				float num2 = (float)Math.PI / 2f * num;
				Vector3 position = new Vector3(Radius * Mathf.Cos(num2) - Radius, 0f, Radius * Mathf.Sin(num2));
				Quaternion quaternion = Quaternion.Euler(0f, (0f - num2) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position);
				pose.Rotation = base.transform.rotation * quaternion;
			}
			else if (Type == SegmentType.RightTurn)
			{
				float num3 = (float)Math.PI - (float)Math.PI / 2f * distanceIntoSegment / SegmentLength;
				Vector3 position2 = new Vector3(Radius * Mathf.Cos(num3) + Radius, 0f, Radius * Mathf.Sin(num3));
				Quaternion quaternion2 = Quaternion.Euler(0f, ((float)Math.PI - num3) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position2);
				pose.Rotation = base.transform.rotation * quaternion2;
			}
			else
			{
				pose.Position = Vector3.zero;
				pose.Rotation = Quaternion.identity;
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			UnityEngine.Object.Destroy(_mesh);
		}

		private void DrawDebugLines()
		{
			for (int i = 1; i < SubDivCount + 1; i++)
			{
				float num = SegmentLength / (float)SubDivCount;
				UpdatePose((float)(i - 1) * num, _p1);
				UpdatePose((float)i * num, _p2);
				float num2 = 0.075f;
				UnityEngine.Debug.DrawLine(_p1.Position + num2 * (_p1.Rotation * Vector3.right), _p2.Position + num2 * (_p2.Rotation * Vector3.right));
				UnityEngine.Debug.DrawLine(_p1.Position - num2 * (_p1.Rotation * Vector3.right), _p2.Position - num2 * (_p2.Rotation * Vector3.right));
			}
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position + 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
		}

		public void RegenerateTrackAndMesh()
		{
			if (base.transform.childCount > 0 && !_mesh)
			{
				_mesh = base.transform.GetChild(0).gameObject;
			}
			if ((bool)_mesh)
			{
				UnityEngine.Object.DestroyImmediate(_mesh);
			}
			if (_segmentType == SegmentType.LeftTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_leftTurn.gameObject);
			}
			else if (_segmentType == SegmentType.RightTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_rightTurn.gameObject);
			}
			else
			{
				_mesh = UnityEngine.Object.Instantiate(_straight.gameObject);
			}
			_mesh.transform.SetParent(base.transform, worldPositionStays: false);
			_mesh.transform.position += GridSize / 2f * base.transform.forward;
			_mesh.transform.localScale = new Vector3(GridSize / 0.8f, GridSize / 0.8f, GridSize / 0.8f);
		}
	}
	public class TrainButtonVisualController : MonoBehaviour
	{
		private const float LERP_TO_OLD_POS_DURATION = 1f;

		private const float LOCAL_SIZE_HALVED = 0.5f;

		[SerializeField]
		private MeshRenderer _meshRenderer;

		[SerializeField]
		private MeshRenderer _glowRenderer;

		[SerializeField]
		private ButtonController _buttonController;

		[SerializeField]
		private Color _buttonContactColor = new Color(0.51f, 0.78f, 0.92f, 1f);

		[SerializeField]
		private Color _buttonActionColor = new Color(0.24f, 0.72f, 0.98f, 1f);

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _actionSoundEffect;

		[SerializeField]
		private Transform _buttonContactTransform;

		[SerializeField]
		private float _contactMaxDisplacementDistance = 0.0141f;

		private Material _buttonMaterial;

		private Color _buttonDefaultColor;

		private int _materialColorId;

		private bool _buttonInContactOrActionStates;

		private Coroutine _lerpToOldPositionCr;

		private Vector3 _oldPosition;

		private void Awake()
		{
			_materialColorId = Shader.PropertyToID("_Color");
			_buttonMaterial = _meshRenderer.material;
			_buttonDefaultColor = _buttonMaterial.GetColor(_materialColorId);
			_oldPosition = base.transform.localPosition;
		}

		private void OnDestroy()
		{
			if (_buttonMaterial != null)
			{
				UnityEngine.Object.Destroy(_buttonMaterial);
			}
		}

		private void OnEnable()
		{
			_buttonController.InteractableStateChanged.AddListener(InteractableStateChanged);
			_buttonController.ContactZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonController.ActionZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonInContactOrActionStates = false;
		}

		private void OnDisable()
		{
			if (_buttonController != null)
			{
				_buttonController.InteractableStateChanged.RemoveListener(InteractableStateChanged);
				_buttonController.ContactZoneEvent -= ActionOrInContactZoneStayEvent;
				_buttonController.ActionZoneEvent -= ActionOrInContactZoneStayEvent;
			}
		}

		private void ActionOrInContactZoneStayEvent(ColliderZoneArgs collisionArgs)
		{
			if (_buttonInContactOrActionStates && !collisionArgs.CollidingTool.IsFarFieldTool)
			{
				Vector3 localScale = _buttonContactTransform.localScale;
				Vector3 interactionPosition = collisionArgs.CollidingTool.InteractionPosition;
				float num = (_buttonContactTransform.InverseTransformPoint(interactionPosition) - 0.5f * Vector3.one).y * localScale.y;
				if (num > 0f - _contactMaxDisplacementDistance && num <= 0f)
				{
					base.transform.localPosition = new Vector3(_oldPosition.x, _oldPosition.y + num, _oldPosition.z);
				}
			}
		}

		private void InteractableStateChanged(InteractableStateArgs obj)
		{
			_buttonInContactOrActionStates = false;
			_glowRenderer.gameObject.SetActive(obj.NewInteractableState > InteractableState.Default);
			switch (obj.NewInteractableState)
			{
			case InteractableState.ContactState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonContactColor);
				_buttonInContactOrActionStates = true;
				break;
			case InteractableState.ProximityState:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			case InteractableState.ActionState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonActionColor);
				PlaySound(_actionSoundEffect);
				_buttonInContactOrActionStates = true;
				break;
			default:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			}
		}

		private void PlaySound(AudioClip clip)
		{
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}

		private void StopResetLerping()
		{
			if (_lerpToOldPositionCr != null)
			{
				StopCoroutine(_lerpToOldPositionCr);
			}
		}

		private void LerpToOldPosition()
		{
			if (!((base.transform.localPosition - _oldPosition).sqrMagnitude < Mathf.Epsilon))
			{
				StopResetLerping();
				_lerpToOldPositionCr = StartCoroutine(ResetPosition());
			}
		}

		private IEnumerator ResetPosition()
		{
			float startTime = Time.time;
			float endTime = Time.time + 1f;
			while (Time.time < endTime)
			{
				base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, _oldPosition, (Time.time - startTime) / 1f);
				yield return null;
			}
			base.transform.localPosition = _oldPosition;
			_lerpToOldPositionCr = null;
		}
	}
	public class TrainCar : TrainCarBase
	{
		[SerializeField]
		private TrainCarBase _parentLocomotive;

		[SerializeField]
		protected float _distanceBehindParent = 0.1f;

		public float DistanceBehindParentScaled => scale * _distanceBehindParent;

		protected override void Awake()
		{
			base.Awake();
		}

		public override void UpdatePosition()
		{
			base.Distance = _parentLocomotive.Distance - DistanceBehindParentScaled;
			UpdateCarPosition();
			RotateCarWheels();
		}
	}
	public abstract class TrainCarBase : MonoBehaviour
	{
		private static Vector3 OFFSET = new Vector3(0f, 0.0195f, 0f);

		private const float WHEEL_RADIUS = 0.027f;

		private const float TWO_PI = (float)Math.PI * 2f;

		[SerializeField]
		protected Transform _frontWheels;

		[SerializeField]
		protected Transform _rearWheels;

		[SerializeField]
		protected TrainTrack _trainTrack;

		[SerializeField]
		protected Transform[] _individualWheels;

		protected float scale = 1f;

		private Pose _frontPose = new Pose();

		private Pose _rearPose = new Pose();

		public float Distance { get; protected set; }

		public float Scale
		{
			get
			{
				return scale;
			}
			set
			{
				scale = value;
			}
		}

		protected virtual void Awake()
		{
		}

		public void UpdatePose(float distance, TrainCarBase train, Pose pose)
		{
			distance = (train._trainTrack.TrackLength + distance) % train._trainTrack.TrackLength;
			if (distance < 0f)
			{
				distance += train._trainTrack.TrackLength;
			}
			TrackSegment segment = train._trainTrack.GetSegment(distance);
			float distanceIntoSegment = distance - segment.StartDistance;
			segment.UpdatePose(distanceIntoSegment, pose);
		}

		protected void UpdateCarPosition()
		{
			UpdatePose(Distance + _frontWheels.transform.localPosition.z * scale, this, _frontPose);
			UpdatePose(Distance + _rearWheels.transform.localPosition.z * scale, this, _rearPose);
			Vector3 vector = 0.5f * (_frontPose.Position + _rearPose.Position);
			Vector3 forward = _frontPose.Position - _rearPose.Position;
			base.transform.position = vector + OFFSET;
			base.transform.rotation = Quaternion.LookRotation(forward, base.transform.up);
			_frontWheels.transform.rotation = _frontPose.Rotation;
			_rearWheels.transform.rotation = _rearPose.Rotation;
		}

		protected void RotateCarWheels()
		{
			float num = Distance / 0.027f % ((float)Math.PI * 2f);
			Transform[] individualWheels = _individualWheels;
			for (int i = 0; i < individualWheels.Length; i++)
			{
				individualWheels[i].localRotation = Quaternion.AngleAxis(57.29578f * num, Vector3.right);
			}
		}

		public abstract void UpdatePosition();
	}
	public class TrainCrossingController : MonoBehaviour
	{
		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip[] _crossingSounds;

		[SerializeField]
		private MeshRenderer _lightSide1Renderer;

		[SerializeField]
		private MeshRenderer _lightSide2Renderer;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private Material _lightsSide1Mat;

		private Material _lightsSide2Mat;

		private int _colorId = Shader.PropertyToID("_Color");

		private Coroutine _xingAnimationCr;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_lightsSide1Mat = _lightSide1Renderer.material;
			_lightsSide2Mat = _lightSide2Renderer.material;
		}

		private void OnDestroy()
		{
			if (_lightsSide1Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide1Mat);
			}
			if (_lightsSide2Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide2Mat);
			}
		}

		public void CrossingButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				ActivateTrainCrossing();
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}

		private void ActivateTrainCrossing()
		{
			int num = _crossingSounds.Length - 1;
			AudioClip audioClip = _crossingSounds[(int)(UnityEngine.Random.value * (float)num)];
			_audioSource.clip = audioClip;
			_audioSource.timeSamples = 0;
			_audioSource.Play();
			if (_xingAnimationCr != null)
			{
				StopCoroutine(_xingAnimationCr);
			}
			_xingAnimationCr = StartCoroutine(AnimateCrossing(audioClip.length * 0.75f));
		}

		private IEnumerator AnimateCrossing(float animationLength)
		{
			ToggleLightObjects(enableState: true);
			float animationEndTime = Time.time + animationLength;
			float lightBlinkDuration = animationLength * 0.1f;
			float lightBlinkStartTime = Time.time;
			float lightBlinkEndTime = Time.time + lightBlinkDuration;
			Material lightToBlinkOn = _lightsSide1Mat;
			Material lightToBlinkOff = _lightsSide2Mat;
			Color onColor = new Color(1f, 1f, 1f, 1f);
			Color offColor = new Color(1f, 1f, 1f, 0f);
			while (Time.time < animationEndTime)
			{
				float t = (Time.time - lightBlinkStartTime) / lightBlinkDuration;
				lightToBlinkOn.SetColor(_colorId, Color.Lerp(offColor, onColor, t));
				lightToBlinkOff.SetColor(_colorId, Color.Lerp(onColor, offColor, t));
				if (Time.time > lightBlinkEndTime)
				{
					Material material = lightToBlinkOn;
					lightToBlinkOn = lightToBlinkOff;
					lightToBlinkOff = material;
					lightBlinkStartTime = Time.time;
					lightBlinkEndTime = Time.time + lightBlinkDuration;
				}
				yield return null;
			}
			ToggleLightObjects(enableState: false);
		}

		private void AffectMaterials(Material[] materials, Color newColor)
		{
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].SetColor(_colorId, newColor);
			}
		}

		private void ToggleLightObjects(bool enableState)
		{
			_lightSide1Renderer.gameObject.SetActive(enableState);
			_lightSide2Renderer.gameObject.SetActive(enableState);
		}
	}
	public class TrainLocomotive : TrainCarBase
	{
		private enum EngineSoundState
		{
			Start,
			AccelerateOrSetProperSpeed,
			Stop
		}

		private const float MIN_SPEED = 0.2f;

		private const float MAX_SPEED = 2.7f;

		private const float SMOKE_SPEED_MULTIPLIER = 8f;

		private const int MAX_PARTICLES_MULTIPLIER = 3;

		[SerializeField]
		[Range(0.2f, 2.7f)]
		protected float _initialSpeed;

		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private GameObject _decreaseSpeedButton;

		[SerializeField]
		private GameObject _increaseSpeedButton;

		[SerializeField]
		private GameObject _smokeButton;

		[SerializeField]
		private GameObject _whistleButton;

		[SerializeField]
		private GameObject _reverseButton;

		[SerializeField]
		private AudioSource _whistleAudioSource;

		[SerializeField]
		private AudioClip _whistleSound;

		[SerializeField]
		private AudioSource _engineAudioSource;

		[SerializeField]
		private AudioClip[] _accelerationSounds;

		[SerializeField]
		private AudioClip[] _decelerationSounds;

		[SerializeField]
		private AudioClip _startUpSound;

		[SerializeField]
		private AudioSource _smokeStackAudioSource;

		[SerializeField]
		private AudioClip _smokeSound;

		[SerializeField]
		private ParticleSystem _smoke1;

		[SerializeField]
		private ParticleSystem _smoke2;

		[SerializeField]
		private TrainCarBase[] _childCars;

		private bool _isMoving = true;

		private bool _reverse;

		private float _currentSpeed;

		private float _speedDiv;

		private float _standardRateOverTimeMultiplier;

		private int _standardMaxParticles;

		private Coroutine _startStopTrainCr;

		private void Start()
		{
			_standardRateOverTimeMultiplier = _smoke1.emission.rateOverTimeMultiplier;
			_standardMaxParticles = _smoke1.main.maxParticles;
			base.Distance = 0f;
			_speedDiv = 2.5f / (float)_accelerationSounds.Length;
			_currentSpeed = _initialSpeed;
			UpdateCarPosition();
			_smoke1.Stop();
			_startStopTrainCr = StartCoroutine(StartStopTrain(startTrain: true));
		}

		private void Update()
		{
			UpdatePosition();
		}

		public override void UpdatePosition()
		{
			if (_isMoving)
			{
				if (_trainTrack != null)
				{
					UpdateDistance();
					UpdateCarPosition();
					RotateCarWheels();
				}
				TrainCarBase[] childCars = _childCars;
				for (int i = 0; i < childCars.Length; i++)
				{
					childCars[i].UpdatePosition();
				}
			}
		}

		public void StartStopStateChanged()
		{
			if (_startStopTrainCr == null)
			{
				_startStopTrainCr = StartCoroutine(StartStopTrain(!_isMoving));
			}
		}

		private IEnumerator StartStopTrain(bool startTrain)
		{
			float endSpeed = (startTrain ? _initialSpeed : 0f);
			float timePeriodForSpeedChange2;
			if (startTrain)
			{
				_smoke1.Play();
				_isMoving = true;
				ParticleSystem.EmissionModule emission = _smoke1.emission;
				ParticleSystem.MainModule main = _smoke1.main;
				emission.rateOverTimeMultiplier = _standardRateOverTimeMultiplier;
				main.maxParticles = _standardMaxParticles;
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Start);
			}
			else
			{
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Stop);
			}
			_engineAudioSource.loop = false;
			timePeriodForSpeedChange2 *= 0.9f;
			float startTime = Time.time;
			float endTime = Time.time + timePeriodForSpeedChange2;
			float startSpeed = _currentSpeed;
			while (Time.time < endTime)
			{
				float num = (Time.time - startTime) / timePeriodForSpeedChange2;
				_currentSpeed = startSpeed * (1f - num) + endSpeed * num;
				UpdateSmokeEmissionBasedOnSpeed();
				yield return null;
			}
			_currentSpeed = endSpeed;
			_startStopTrainCr = null;
			_isMoving = startTrain;
			if (!_isMoving)
			{
				_smoke1.Stop();
				yield break;
			}
			_engineAudioSource.loop = true;
			PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
		}

		private float PlayEngineSound(EngineSoundState engineSoundState)
		{
			AudioClip audioClip = null;
			if (engineSoundState == EngineSoundState.Start)
			{
				audioClip = _startUpSound;
			}
			else
			{
				AudioClip[] obj = ((engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed) ? _accelerationSounds : _decelerationSounds);
				int num = obj.Length;
				int value = (int)Mathf.Round((_currentSpeed - 0.2f) / _speedDiv);
				audioClip = obj[Mathf.Clamp(value, 0, num - 1)];
			}
			if (_engineAudioSource.clip == audioClip && _engineAudioSource.isPlaying && engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed)
			{
				return 0f;
			}
			_engineAudioSource.clip = audioClip;
			_engineAudioSource.timeSamples = 0;
			_engineAudioSource.Play();
			return audioClip.length;
		}

		private void UpdateDistance()
		{
			float num = (_reverse ? (0f - _currentSpeed) : _currentSpeed);
			base.Distance = (base.Distance + num * Time.deltaTime) % _trainTrack.TrackLength;
		}

		public void DecreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed - _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		public void IncreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed + _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		private void UpdateSmokeEmissionBasedOnSpeed()
		{
			ParticleSystem.EmissionModule emission = _smoke1.emission;
			emission.rateOverTimeMultiplier = GetCurrentSmokeEmission();
			ParticleSystem.MainModule main = _smoke1.main;
			main.maxParticles = (int)Mathf.Lerp(_standardMaxParticles, _standardMaxParticles * 3, _currentSpeed / 2.5f);
		}

		private float GetCurrentSmokeEmission()
		{
			return Mathf.Lerp(_standardRateOverTimeMultiplier, _standardRateOverTimeMultiplier * 8f, _currentSpeed / 2.5f);
		}

		public void SmokeButtonStateChanged()
		{
			if (_isMoving)
			{
				_smokeStackAudioSource.clip = _smokeSound;
				_smokeStackAudioSource.timeSamples = 0;
				_smokeStackAudioSource.Play();
				_smoke2.time = 0f;
				_smoke2.Play();
			}
		}

		public void WhistleButtonStateChanged()
		{
			if (_whistleSound != null)
			{
				_whistleAudioSource.clip = _whistleSound;
				_whistleAudioSource.timeSamples = 0;
				_whistleAudioSource.Play();
			}
		}

		public void ReverseButtonStateChanged()
		{
			_reverse = !_reverse;
		}
	}
	public class TrainTrack : MonoBehaviour
	{
		[SerializeField]
		private float _gridSize = 0.5f;

		[SerializeField]
		private int _subDivCount = 20;

		[SerializeField]
		private Transform _segmentParent;

		[SerializeField]
		private Transform _trainParent;

		[SerializeField]
		private bool _regnerateTrackMeshOnAwake;

		private float _trainLength = -1f;

		private TrackSegment[] _trackSegments;

		public float TrackLength
		{
			get
			{
				return _trainLength;
			}
			private set
			{
				_trainLength = value;
			}
		}

		private void Awake()
		{
			Regenerate();
		}

		public TrackSegment GetSegment(float distance)
		{
			int childCount = _segmentParent.childCount;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment = _trackSegments[i];
				TrackSegment trackSegment2 = _trackSegments[(i + 1) % childCount];
				if (distance >= trackSegment.StartDistance && (distance < trackSegment2.StartDistance || i == childCount - 1))
				{
					return trackSegment;
				}
			}
			return null;
		}

		public void Regenerate()
		{
			_trackSegments = _segmentParent.GetComponentsInChildren<TrackSegment>();
			TrackLength = 0f;
			int childCount = _segmentParent.childCount;
			TrackSegment trackSegment = null;
			float scale = 0f;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment2 = _trackSegments[i];
				trackSegment2.SubDivCount = _subDivCount;
				scale = trackSegment2.setGridSize(_gridSize);
				if (trackSegment != null)
				{
					Pose endPose = trackSegment.EndPose;
					trackSegment2.transform.position = endPose.Position;
					trackSegment2.transform.rotation = endPose.Rotation;
					trackSegment2.StartDistance = TrackLength;
				}
				if (_regnerateTrackMeshOnAwake)
				{
					trackSegment2.RegenerateTrackAndMesh();
				}
				TrackLength += trackSegment2.SegmentLength;
				trackSegment = trackSegment2;
			}
			SetScale(scale);
		}

		private void SetScale(float ratio)
		{
			_trainParent.localScale = new Vector3(ratio, ratio, ratio);
			TrainCar[] componentsInChildren = _trainParent.GetComponentsInChildren<TrainCar>();
			_trainParent.GetComponentInChildren<TrainLocomotive>().Scale = ratio;
			TrainCar[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Scale = ratio;
			}
		}
	}
	public class Pose
	{
		public Vector3 Position;

		public Quaternion Rotation;

		public Pose()
		{
			Position = Vector3.zero;
			Rotation = Quaternion.identity;
		}

		public Pose(Vector3 position, Quaternion rotation)
		{
			Position = position;
			Rotation = rotation;
		}
	}
	public class WindmillBladesController : MonoBehaviour
	{
		private const float MAX_TIME = 1f;

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _windMillRotationSound;

		[SerializeField]
		private AudioClip _windMillStartSound;

		[SerializeField]
		private AudioClip _windMillStopSound;

		private float _currentSpeed;

		private Coroutine _lerpSpeedCoroutine;

		private Coroutine _audioChangeCr;

		private Quaternion _originalRotation;

		private float _rotAngle;

		public bool IsMoving { get; private set; }

		private void Start()
		{
			_originalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			_rotAngle += _currentSpeed * Time.deltaTime;
			if (_rotAngle > 360f)
			{
				_rotAngle = 0f;
			}
			base.transform.localRotation = _originalRotation * Quaternion.AngleAxis(_rotAngle, Vector3.forward);
		}

		public void SetMoveState(bool newMoveState, float goalSpeed)
		{
			IsMoving = newMoveState;
			if (_lerpSpeedCoroutine != null)
			{
				StopCoroutine(_lerpSpeedCoroutine);
			}
			_lerpSpeedCoroutine = StartCoroutine(LerpToSpeed(goalSpeed));
		}

		private IEnumerator LerpToSpeed(float goalSpeed)
		{
			float totalTime = 0f;
			float startSpeed = _currentSpeed;
			if (_audioChangeCr != null)
			{
				StopCoroutine(_audioChangeCr);
			}
			if (IsMoving)
			{
				_audioChangeCr = StartCoroutine(PlaySoundDelayed(_windMillStartSound, _windMillRotationSound, _windMillStartSound.length * 0.95f));
			}
			else
			{
				PlaySound(_windMillStopSound);
			}
			for (float num = Mathf.Abs(_currentSpeed - goalSpeed); num > Mathf.Epsilon; num = Mathf.Abs(_currentSpeed - goalSpeed))
			{
				_currentSpeed = Mathf.Lerp(startSpeed, goalSpeed, totalTime / 1f);
				totalTime += Time.deltaTime;
				yield return null;
			}
			_lerpSpeedCoroutine = null;
		}

		private IEnumerator PlaySoundDelayed(AudioClip initial, AudioClip clip, float timeDelayAfterInitial)
		{
			PlaySound(initial);
			yield return new WaitForSeconds(timeDelayAfterInitial);
			PlaySound(clip, loop: true);
		}

		private void PlaySound(AudioClip clip, bool loop = false)
		{
			_audioSource.loop = loop;
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}
	}
	public class WindmillController : MonoBehaviour
	{
		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private float _maxSpeed = 10f;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private WindmillBladesController _bladesRotation;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_bladesRotation = GetComponentInChildren<WindmillBladesController>();
			_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
		}

		private void OnEnable()
		{
			_startStopButton.GetComponent<Interactable>().InteractableStateChanged.AddListener(StartStopStateChanged);
		}

		private void OnDisable()
		{
			if (_startStopButton != null)
			{
				_startStopButton.GetComponent<Interactable>().InteractableStateChanged.RemoveListener(StartStopStateChanged);
			}
		}

		private void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				if (_bladesRotation.IsMoving)
				{
					_bladesRotation.SetMoveState(newMoveState: false, 0f);
				}
				else
				{
					_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
				}
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}
	}
	public enum EUiDisplayType
	{
		EUDT_WorldGeoQuad,
		EUDT_OverlayQuad,
		EUDT_None,
		EUDT_MaxDislayTypes
	}
	public class OVROverlaySample : MonoBehaviour
	{
		private bool inMenu;

		private const string ovrOverlayID = "OVROverlayID";

		private const string applicationID = "ApplicationID";

		private const string noneID = "NoneID";

		private Toggle applicationRadioButton;

		private Toggle noneRadioButton;

		[Header("App vs Compositor Comparison Settings")]
		public GameObject mainCamera;

		public GameObject uiCamera;

		public GameObject uiGeoParent;

		public GameObject worldspaceGeoParent;

		public OVROverlay cameraRenderOverlay;

		public OVROverlay renderingLabelOverlay;

		public Texture applicationLabelTexture;

		public Texture compositorLabelTexture;

		[Header("Level Loading Sim Settings")]
		public GameObject prefabForLevelLoadSim;

		public OVROverlay cubemapOverlay;

		public OVROverlay loadingTextQuadOverlay;

		public float distanceFromCamToLoadText;

		public float cubeSpawnRadius;

		public float heightBetweenItems;

		public int numObjectsPerLevel;

		public int numLevels;

		public int numLoopsTrigger = 500000000;

		private List<GameObject> spawnedCubes = new List<GameObject>();

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("OVROverlay Sample");
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("Level Loading Example");
			DebugUIBuilder.instance.AddButton("Simulate Level Load", TriggerLoad);
			DebugUIBuilder.instance.AddButton("Destroy Cubes", TriggerUnload);
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("OVROverlay vs. Application Render Comparison");
			DebugUIBuilder.instance.AddRadio("OVROverlay", "group", delegate(Toggle t)
			{
				RadioPressed("OVROverlayID", "group", t);
			}).GetComponentInChildren<Toggle>();
			applicationRadioButton = DebugUIBuilder.instance.AddRadio("Application", "group", delegate(Toggle t)
			{
				RadioPressed("ApplicationID", "group", t);
			}).GetComponentInChildren<Toggle>();
			noneRadioButton = DebugUIBuilder.instance.AddRadio("None", "group", delegate(Toggle t)
			{
				RadioPressed("NoneID", "group", t);
			}).GetComponentInChildren<Toggle>();
			DebugUIBuilder.instance.Show();
			CameraAndRenderTargetSetup();
			cameraRenderOverlay.enabled = true;
			cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
			spawnedCubes.Capacity = numObjectsPerLevel * numLevels;
		}

		private void Update()
		{
			if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
			{
				if (inMenu)
				{
					DebugUIBuilder.instance.Hide();
				}
				else
				{
					DebugUIBuilder.instance.Show();
				}
				inMenu = !inMenu;
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				TriggerLoad();
			}
		}

		private void ActivateWorldGeo()
		{
			worldspaceGeoParent.SetActive(value: true);
			uiGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = applicationLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateWorldGeo");
		}

		private void ActivateOVROverlay()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: true);
			cameraRenderOverlay.enabled = true;
			uiGeoParent.SetActive(value: true);
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = compositorLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateOVROVerlay");
		}

		private void ActivateNone()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			uiGeoParent.SetActive(value: false);
			renderingLabelOverlay.enabled = false;
			UnityEngine.Debug.Log("Switched to ActivateNone");
		}

		private void TriggerLoad()
		{
			StartCoroutine(WaitforOVROverlay());
		}

		private IEnumerator WaitforOVROverlay()
		{
			Transform transform = mainCamera.transform;
			Transform obj = loadingTextQuadOverlay.transform;
			Vector3 position = transform.position + transform.forward * distanceFromCamToLoadText;
			position.y = transform.position.y;
			obj.position = position;
			cubemapOverlay.enabled = true;
			loadingTextQuadOverlay.enabled = true;
			noneRadioButton.isOn = true;
			yield return new WaitForSeconds(0.1f);
			ClearObjects();
			SimulateLevelLoad();
			cubemapOverlay.enabled = false;
			loadingTextQuadOverlay.enabled = false;
			yield return null;
		}

		private void TriggerUnload()
		{
			ClearObjects();
			applicationRadioButton.isOn = true;
		}

		private void CameraAndRenderTargetSetup()
		{
			float x = cameraRenderOverlay.transform.localScale.x;
			float y = cameraRenderOverlay.transform.localScale.y;
			float z = cameraRenderOverlay.transform.localScale.z;
			float num = 1440f;
			float num2 = 2560f * 0.5f;
			float num3 = mainCamera.GetComponent<Camera>().fieldOfView / 2f;
			float num4 = 2f * z * Mathf.Tan((float)Math.PI / 180f * num3);
			float num5 = num / num4 * x;
			float num6 = 0f;
			float num7 = num4 * mainCamera.GetComponent<Camera>().aspect;
			num6 = num2 / num7 * x;
			float orthographicSize = y / 2f;
			float aspect = x / y;
			uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;
			uiCamera.GetComponent<Camera>().aspect = aspect;
			if (uiCamera.GetComponent<Camera>().targetTexture != null)
			{
				uiCamera.GetComponent<Camera>().targetTexture.Release();
			}
			RenderTexture renderTexture = new RenderTexture((int)num6 * 2, (int)num5 * 2, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
			UnityEngine.Debug.Log("Created RT of resolution w: " + num6 + " and h: " + num5);
			renderTexture.hideFlags = HideFlags.DontSave;
			renderTexture.useMipMap = true;
			renderTexture.filterMode = FilterMode.Trilinear;
			renderTexture.anisoLevel = 4;
			renderTexture.autoGenerateMips = true;
			uiCamera.GetComponent<Camera>().targetTexture = renderTexture;
			cameraRenderOverlay.textures[0] = renderTexture;
		}

		private void SimulateLevelLoad()
		{
			int num = 0;
			for (int i = 0; i < numLoopsTrigger; i++)
			{
				num++;
			}
			UnityEngine.Debug.Log("Finished " + num + " Loops");
			Vector3 position = mainCamera.transform.position;
			position.y = 0.5f;
			for (int j = 0; j < numLevels; j++)
			{
				for (int k = 0; k < numObjectsPerLevel; k++)
				{
					float f = (float)k * (float)Math.PI * 2f / (float)numObjectsPerLevel;
					float num2 = ((k % 2 == 0) ? 1.5f : 1f);
					Vector3 vector = new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * cubeSpawnRadius * num2;
					vector.y = (float)j * heightBetweenItems;
					GameObject gameObject = UnityEngine.Object.Instantiate(prefabForLevelLoadSim, vector + position, Quaternion.identity);
					Transform obj = gameObject.transform;
					obj.LookAt(position);
					Vector3 eulerAngles = obj.rotation.eulerAngles;
					eulerAngles.x = 0f;
					obj.rotation = Quaternion.Euler(eulerAngles);
					spawnedCubes.Add(gameObject);
				}
			}
		}

		private void ClearObjects()
		{
			for (int i = 0; i < spawnedCubes.Count; i++)
			{
				UnityEngine.Object.DestroyImmediate(spawnedCubes[i]);
			}
			spawnedCubes.Clear();
			GC.Collect();
		}

		public void RadioPressed(string radioLabel, string group, Toggle t)
		{
			if (string.Compare(radioLabel, "OVROverlayID") == 0)
			{
				ActivateOVROverlay();
			}
			else if (string.Compare(radioLabel, "ApplicationID") == 0)
			{
				ActivateWorldGeo();
			}
			else if (string.Compare(radioLabel, "NoneID") == 0)
			{
				ActivateNone();
			}
		}
	}
}
namespace OVRTouchSample
{
	[RequireComponent(typeof(OVRGrabber))]
	public class Hand : MonoBehaviour
	{
		public const string ANIM_LAYER_NAME_POINT = "Point Layer";

		public const string ANIM_LAYER_NAME_THUMB = "Thumb Layer";

		public const string ANIM_PARAM_NAME_FLEX = "Flex";

		public const string ANIM_PARAM_NAME_POSE = "Pose";

		public const float THRESH_COLLISION_FLEX = 0.9f;

		public const float INPUT_RATE_CHANGE = 20f;

		public const float COLLIDER_SCALE_MIN = 0.01f;

		public const float COLLIDER_SCALE_MAX = 1f;

		public const float COLLIDER_SCALE_PER_SECOND = 1f;

		public const float TRIGGER_DEBOUNCE_TIME = 0.05f;

		public const float THUMB_DEBOUNCE_TIME = 0.15f;

		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		[SerializeField]
		private HandPose m_defaultGrabPose;

		private Collider[] m_colliders;

		private bool m_collisionEnabled = true;

		private OVRGrabber m_grabber;

		private List<Renderer> m_showAfterInputFocusAcquired;

		private int m_animLayerIndexThumb = -1;

		private int m_animLayerIndexPoint = -1;

		private int m_animParamIndexFlex = -1;

		private int m_animParamIndexPose = -1;

		private bool m_isPointing;

		private bool m_isGivingThumbsUp;

		private float m_pointBlend;

		private float m_thumbsUpBlend;

		private bool m_restoreOnInputAcquired;

		private float m_collisionScaleCurrent;

		private void Awake()
		{
			m_grabber = GetComponent<OVRGrabber>();
		}

		private void Start()
		{
			m_showAfterInputFocusAcquired = new List<Renderer>();
			m_colliders = (from childCollider in GetComponentsInChildren<Collider>()
				where !childCollider.isTrigger
				select childCollider).ToArray();
			CollisionEnable(enabled: false);
			m_animLayerIndexPoint = m_animator.GetLayerIndex("Point Layer");
			m_animLayerIndexThumb = m_animator.GetLayerIndex("Thumb Layer");
			m_animParamIndexFlex = Animator.StringToHash("Flex");
			m_animParamIndexPose = Animator.StringToHash("Pose");
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnDestroy()
		{
			OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
			OVRManager.InputFocusLost -= OnInputFocusLost;
		}

		private void Update()
		{
			UpdateCapTouchStates();
			m_pointBlend = InputValueRateChange(m_isPointing, m_pointBlend);
			m_thumbsUpBlend = InputValueRateChange(m_isGivingThumbsUp, m_thumbsUpBlend);
			float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			bool flag = m_grabber.grabbedObject == null && num >= 0.9f;
			CollisionEnable(flag);
			UpdateAnimStates();
		}

		private void UpdateCapTouchStates()
		{
			m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);
			m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);
		}

		private void LateUpdate()
		{
			if (m_collisionEnabled && m_collisionScaleCurrent + Mathf.Epsilon < 1f)
			{
				m_collisionScaleCurrent = Mathf.Min(1f, m_collisionScaleCurrent + Time.deltaTime * 1f);
				for (int i = 0; i < m_colliders.Length; i++)
				{
					m_colliders[i].transform.localScale = new Vector3(m_collisionScaleCurrent, m_collisionScaleCurrent, m_collisionScaleCurrent);
				}
			}
		}

		private void OnInputFocusLost()
		{
			if (!base.gameObject.activeInHierarchy)
			{
				return;
			}
			m_showAfterInputFocusAcquired.Clear();
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].enabled)
				{
					componentsInChildren[i].enabled = false;
					m_showAfterInputFocusAcquired.Add(componentsInChildren[i]);
				}
			}
			CollisionEnable(enabled: false);
			m_restoreOnInputAcquired = true;
		}

		private void OnInputFocusAcquired()
		{
			if (!m_restoreOnInputAcquired)
			{
				return;
			}
			for (int i = 0; i < m_showAfterInputFocusAcquired.Count; i++)
			{
				if ((bool)m_showAfterInputFocusAcquired[i])
				{
					m_showAfterInputFocusAcquired[i].enabled = true;
				}
			}
			m_showAfterInputFocusAcquired.Clear();
			m_restoreOnInputAcquired = false;
		}

		private float InputValueRateChange(bool isDown, float value)
		{
			float num = Time.deltaTime * 20f;
			float num2 = (isDown ? 1f : (-1f));
			return Mathf.Clamp01(value + num * num2);
		}

		private void UpdateAnimStates()
		{
			bool num = m_grabber.grabbedObject != null;
			HandPose handPose = m_defaultGrabPose;
			if (num)
			{
				HandPose component = m_grabber.grabbedObject.GetComponent<HandPose>();
				if (component != null)
				{
					handPose = component;
				}
			}
			HandPoseId poseId = handPose.PoseId;
			m_animator.SetInteger(m_animParamIndexPose, (int)poseId);
			float value = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			m_animator.SetFloat(m_animParamIndexFlex, value);
			float weight = ((!num || handPose.AllowPointing) ? m_pointBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexPoint, weight);
			float weight2 = ((!num || handPose.AllowThumbsUp) ? m_thumbsUpBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexThumb, weight2);
			float value2 = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller);
			m_animator.SetFloat("Pinch", value2);
		}

		private void CollisionEnable(bool enabled)
		{
			if (m_collisionEnabled == enabled)
			{
				return;
			}
			m_collisionEnabled = enabled;
			if (enabled)
			{
				m_collisionScaleCurrent = 0.01f;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider obj = m_colliders[i];
					obj.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
					obj.enabled = true;
				}
			}
			else
			{
				m_collisionScaleCurrent = 1f;
				for (int j = 0; j < m_colliders.Length; j++)
				{
					Collider obj2 = m_colliders[j];
					obj2.enabled = false;
					obj2.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
				}
			}
		}
	}
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall,
		Controller
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;
	}
	public class TouchController : MonoBehaviour
	{
		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		private bool m_restoreOnInputAcquired;

		private void Update()
		{
			m_animator.SetFloat("Button 1", OVRInput.Get(OVRInput.Button.One, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Button 2", OVRInput.Get(OVRInput.Button.Two, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Joy X", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).x);
			m_animator.SetFloat("Joy Y", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).y);
			m_animator.SetFloat("Grip", OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller));
			m_animator.SetFloat("Trigger", OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller));
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			if (base.gameObject.activeInHierarchy)
			{
				base.gameObject.SetActive(value: false);
				m_restoreOnInputAcquired = true;
			}
		}

		private void OnInputFocusAcquired()
		{
			if (m_restoreOnInputAcquired)
			{
				base.gameObject.SetActive(value: true);
				m_restoreOnInputAcquired = false;
			}
		}
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(0, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
namespace Oculus.Avatar
{
	public static class AvatarLogger
	{
		public const string LogAvatar = "[Avatars] - ";

		public const string Tab = "    ";

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg, context);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_WARNING")]
		public static void LogWarning(string logMsg)
		{
			UnityEngine.Debug.LogWarning("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg, context);
		}
	}
	public class CAPI
	{
		public delegate void LoggingDelegate(IntPtr str);

		public enum Result
		{
			Success = 0,
			Failure = -1000,
			Failure_InvalidParameter = -1001,
			Failure_NotInitialized = -1002,
			Failure_InvalidOperation = -1003,
			Failure_Unsupported = -1004,
			Failure_NotYetImplemented = -1005,
			Failure_OperationFailed = -1006,
			Failure_InsufficientSize = -1007
		}

		private static class OVRP_1_30_0
		{
			public static readonly Version version = new Version(1, 30, 0);

			[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
			public static extern Result ovrp_SendEvent2(string name, string param, string source);
		}

		private const string LibFile = "ovravatarloader";

		private static IntPtr nativeVisemeData = IntPtr.Zero;

		private static IntPtr nativeGazeTargetsData = IntPtr.Zero;

		private static IntPtr nativeAvatarLightsData = IntPtr.Zero;

		private static IntPtr DebugLineCountData = IntPtr.Zero;

		private static float[] scratchBufferFloat = new float[16];

		private static GameObject debugLineGo;

		private static string SDKRuntimePrefix = "[RUNTIME] - ";

		private const string ovrPluginDLL = "OVRPlugin";

		private static Version ovrPluginVersion;

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_InitializeAndroidUnity(string appID);

		public static void Initialize()
		{
			nativeVisemeData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarVisemes)));
			nativeGazeTargetsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarGazeTargets)));
			nativeAvatarLightsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarLights)));
			DebugLineCountData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			debugLineGo = new GameObject();
			debugLineGo.name = "AvatarSDKDebugDrawHelper";
		}

		public static void Shutdown()
		{
			Marshal.FreeHGlobal(nativeVisemeData);
			Marshal.FreeHGlobal(nativeGazeTargetsData);
			Marshal.FreeHGlobal(nativeAvatarLightsData);
			Marshal.FreeHGlobal(DebugLineCountData);
			debugLineGo = null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Shutdown();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarMessage_Pop();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMessageType ovrAvatarMessage_GetType(IntPtr msg);

		public static ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_GetAvatarSpecification(IntPtr msg)
		{
			return (ovrAvatarMessage_AvatarSpecification)Marshal.PtrToStructure(ovrAvatarMessage_GetAvatarSpecification_Native(msg), typeof(ovrAvatarMessage_AvatarSpecification));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAvatarSpecification")]
		private static extern IntPtr ovrAvatarMessage_GetAvatarSpecification_Native(IntPtr msg);

		public static ovrAvatarMessage_AssetLoaded ovrAvatarMessage_GetAssetLoaded(IntPtr msg)
		{
			return (ovrAvatarMessage_AssetLoaded)Marshal.PtrToStructure(ovrAvatarMessage_GetAssetLoaded_Native(msg), typeof(ovrAvatarMessage_AssetLoaded));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAssetLoaded")]
		private static extern IntPtr ovrAvatarMessage_GetAssetLoaded_Native(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarMessage_Free(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarSpecificationRequest_Create(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_Destroy(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetCombineMeshes(IntPtr specificationRequest, bool useCombinedMesh);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLevelOfDetail(IntPtr specificationRequest, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecification(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecificationFromSpecRequest(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetExpressiveFlag(IntPtr specificationRequest, bool enable);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatar_Create(IntPtr avatarSpecification, ovrAvatarCapabilities capabilities);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Destroy(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateBody(IntPtr avatar, ovrAvatarTransform headPose);

		public static void ovrAvatarPose_UpdateVoiceVisualization(IntPtr avatar, float[] pcmData)
		{
			ovrAvatarPose_UpdateVoiceVisualization_Native(avatar, (uint)pcmData.Length, pcmData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_UpdateVoiceVisualization")]
		private static extern void ovrAvatarPose_UpdateVoiceVisualization_Native(IntPtr avatar, uint pcmDataSize, [In] float[] pcmData);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHandsWithType(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight, ovrAvatarControllerType type);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Finalize(IntPtr avatar, float elapsedSeconds);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarComponent_Count(IntPtr avatar);

		public static void ovrAvatarComponent_Get(IntPtr avatar, uint index, bool includeName, ref ovrAvatarComponent component)
		{
			ovrAvatarComponent_Get(ovrAvatarComponent_Get_Native(avatar, index), includeName, ref component);
		}

		public static void ovrAvatarComponent_Get(IntPtr componentPtr, bool includeName, ref ovrAvatarComponent component)
		{
			Marshal.Copy(new IntPtr(componentPtr.ToInt64() + ovrAvatarComponent_Offsets.transform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.transform);
			component.renderPartCount = (uint)Marshal.ReadInt32(componentPtr, ovrAvatarComponent_Offsets.renderPartCount);
			component.renderParts = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.renderParts);
			if (includeName)
			{
				IntPtr ptr = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.name);
				component.name = Marshal.PtrToStringAnsi(ptr);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarComponent_Get")]
		public static extern IntPtr ovrAvatarComponent_Get_Native(IntPtr avatar, uint index);

		public static bool ovrAvatarPose_GetBaseComponent(IntPtr avatar, ref ovrAvatarBaseComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBaseComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarBaseComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBaseComponent")]
		private static extern IntPtr ovrAvatarPose_GetBaseComponent_Native(IntPtr avatar);

		public static IntPtr MarshalRenderComponent<T>(IntPtr ptr) where T : struct
		{
			return Marshal.ReadIntPtr(new IntPtr(ptr.ToInt64() + Marshal.OffsetOf(typeof(T), "renderComponent").ToInt64()));
		}

		public static bool ovrAvatarPose_GetBodyComponent(IntPtr avatar, ref ovrAvatarBodyComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBodyComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.leftEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.leftEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.rightEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.rightEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.centerEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.centerEyeTransform);
			component.renderComponent = MarshalRenderComponent<ovrAvatarBodyComponent>(intPtr);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBodyComponent")]
		private static extern IntPtr ovrAvatarPose_GetBodyComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftHandComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightHandComponent_Native(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarAsset_BeginLoading(ulong assetID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarAsset_BeginLoadingLOD(ulong assetId, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarAssetType ovrAvatarAsset_GetType(IntPtr assetHandle);

		public static ovrAvatarMeshAssetData ovrAvatarAsset_GetMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetData));
		}

		public static ovrAvatarMeshAssetDataV2 ovrAvatarAsset_GetCombinedMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetDataV2)Marshal.PtrToStructure(ovrAvatarAsset_GetCombinedMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetDataV2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetCombinedMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetMeshBlendShapeCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeName(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshLastIndex(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeVertices(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetAvatar(IntPtr assetHandle);

		public static ulong[] ovrAvatarAsset_GetCombinedMeshIDs(IntPtr assetHandle)
		{
			uint structure = 0u;
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshIDs_Native(assetHandle, intPtr);
			structure = (uint)Marshal.PtrToStructure(intPtr, typeof(uint));
			ulong[] array = new ulong[structure];
			for (int i = 0; i < structure; i++)
			{
				array[i] = (ulong)Marshal.ReadInt64(ptr, i * Marshal.SizeOf(typeof(ulong)));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshIDs")]
		public static extern IntPtr ovrAvatarAsset_GetCombinedMeshIDs_Native(IntPtr assetHandle, IntPtr count);

		public static void ovrAvatar_GetCombinedMeshAlphaData(IntPtr avatar, ref ulong textureID, ref Vector4 offset)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ulong)));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Vector4)));
			ovrAvatar_GetCombinedMeshAlphaData_Native(avatar, intPtr, intPtr2);
			textureID = (ulong)Marshal.PtrToStructure(intPtr, typeof(ulong));
			offset = (Vector4)Marshal.PtrToStructure(intPtr2, typeof(Vector4));
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetCombinedMeshAlphaData")]
		public static extern IntPtr ovrAvatar_GetCombinedMeshAlphaData_Native(IntPtr avatar, IntPtr textureIDPtr, IntPtr offsetPtr);

		public static ovrAvatarTextureAssetData ovrAvatarAsset_GetTextureData(IntPtr assetPtr)
		{
			return (ovrAvatarTextureAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetTextureData_Native(assetPtr), typeof(ovrAvatarTextureAssetData));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetTextureData")]
		private static extern IntPtr ovrAvatarAsset_GetTextureData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMaterialData")]
		private static extern IntPtr ovrAvatarAsset_GetMaterialData_Native(IntPtr assetPtr);

		public static ovrAvatarMaterialState ovrAvatarAsset_GetMaterialState(IntPtr assetPtr)
		{
			return (ovrAvatarMaterialState)Marshal.PtrToStructure(ovrAvatarAsset_GetMaterialData_Native(assetPtr), typeof(ovrAvatarMaterialState));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarRenderPartType ovrAvatarRenderPart_GetType(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRender ovrAvatarRenderPart_GetSkinnedMeshRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRender_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRender));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRender_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRender_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRenderPBSV2_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMaterialState ovrAvatarSkinnedMeshRender_GetMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarPBSMaterialState ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarExpressiveParameters ovrAvatar_GetExpressiveParameters(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRender_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitOnsetSpeed(IntPtr avatar, float onsetSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitFalloffSpeed(IntPtr avatar, float falloffSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetVisemeMultiplier(IntPtr avatar, float visemeMultiplier);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBS")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(IntPtr renderPart);

		public static void ovrAvatarSkinnedMeshRender_GetBlendShapeParams(IntPtr renderPart, ref ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr ptr = ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(renderPart);
			blendParams.blendShapeParamCount = (uint)Marshal.ReadInt32(ptr);
			Marshal.Copy(new IntPtr(ptr.ToInt64() + ovrAvatarBlendShapeParams_Offsets.blendShapeParams), blendParams.blendShapeParams, 0, (int)blendParams.blendShapeParamCount);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarSkinnedMeshRender_GetBlendShapeParams")]
		private static extern IntPtr ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_ProjectorRender ovrAvatarRenderPart_GetProjectorRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_ProjectorRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetProjectorRender_Native(renderPart), typeof(ovrAvatarRenderPart_ProjectorRender));
		}

		public static ovrAvatarPBSMaterialState[] ovrAvatar_GetBodyPBSMaterialStates(IntPtr renderPart)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			IntPtr intPtr2 = ovrAvatar_GetBodyPBSMaterialStates_Native(renderPart, intPtr);
			ovrAvatarPBSMaterialState[] array = new ovrAvatarPBSMaterialState[Marshal.ReadInt32(intPtr)];
			for (int i = 0; i < array.Length; i++)
			{
				IntPtr ptr = new IntPtr(intPtr2.ToInt64() + i * Marshal.SizeOf(typeof(ovrAvatarPBSMaterialState)));
				array[i] = (ovrAvatarPBSMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarPBSMaterialState));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetBodyPBSMaterialStates")]
		private static extern IntPtr ovrAvatar_GetBodyPBSMaterialStates_Native(IntPtr avatar, IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetProjectorRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetProjectorRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatar_GetReferencedAssetCount(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatar_GetReferencedAsset(IntPtr avatar, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdatePoseFromPacket(IntPtr avatar, IntPtr packet, float secondsFromStart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_BeginRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_EndRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarPacket_GetSize(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrAvatarPacket_GetDurationSeconds(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_Free(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarPacket_Write(IntPtr packet, uint bufferSize, [Out] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_Read(uint bufferSize, [In] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ovrAvatar_SetInternalForceASTCTextures(bool value);

		public static void ovrAvatar_SetForceASTCTextures(bool value)
		{
			ovrAvatar_SetInternalForceASTCTextures(value);
		}

		public static void ovrAvatar_OverrideExpressiveLogic(IntPtr avatar, ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarBlendShapeParams)));
			Marshal.StructureToPtr(blendParams, intPtr, fDeleteOld: false);
			ovrAvatar_OverrideExpressiveLogic_Native(avatar, intPtr);
			Marshal.FreeHGlobal(intPtr);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_OverrideExpressiveLogic")]
		private static extern void ovrAvatar_OverrideExpressiveLogic_Native(IntPtr avatar, IntPtr state);

		public static void ovrAvatar_SetVisemes(IntPtr avatar, ovrAvatarVisemes visemes)
		{
			Marshal.WriteInt32(nativeVisemeData, (int)visemes.visemeParamCount);
			Marshal.Copy(visemes.visemeParams, 0, new IntPtr(nativeVisemeData.ToInt64() + ovrAvatarVisemes_Offsets.visemeParams), (int)visemes.visemeParamCount);
			ovrAvatar_SetVisemes_Native(avatar, nativeVisemeData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_SetVisemes")]
		private static extern void ovrAvatar_SetVisemes_Native(IntPtr avatar, IntPtr visemes);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdateWorldTransform(IntPtr avatar, ovrAvatarTransform transform);

		public static void ovrAvatar_UpdateGazeTargets(ovrAvatarGazeTargets targets)
		{
			Marshal.WriteInt32(nativeGazeTargetsData, (int)targets.targetCount);
			long targets2 = ovrAvatarGazeTargets_Offsets.targets;
			for (uint num = 0u; num < targets.targetCount; num++)
			{
				long num2 = targets2 + num * Marshal.SizeOf(typeof(ovrAvatarGazeTarget));
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.id), (int)targets.targets[num].id);
				scratchBufferFloat[0] = targets.targets[num].worldPosition.x;
				scratchBufferFloat[1] = targets.targets[num].worldPosition.y;
				scratchBufferFloat[2] = targets.targets[num].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.worldPosition), 3);
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.type), (int)targets.targets[num].type);
			}
			ovrAvatar_UpdateGazeTargets_Native(nativeGazeTargetsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateGazeTargets")]
		private static extern void ovrAvatar_UpdateGazeTargets_Native(IntPtr targets);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveGazeTargets(uint targetCount, uint[] ids);

		public static void ovrAvatar_UpdateLights(ovrAvatarLights lights)
		{
			scratchBufferFloat[0] = lights.ambientIntensity;
			Marshal.Copy(scratchBufferFloat, 0, nativeAvatarLightsData, 1);
			Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64()), (int)lights.lightCount);
			long num = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
			for (uint num2 = 0u; num2 < lights.lightCount; num2++)
			{
				long num3 = num + num2 * Marshal.SizeOf(typeof(ovrAvatarLight));
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64()), (int)lights.lights[num2].id);
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64()), (int)lights.lights[num2].type);
				scratchBufferFloat[0] = lights.lights[num2].intensity;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].worldDirection.x;
				scratchBufferFloat[1] = lights.lights[num2].worldDirection.y;
				scratchBufferFloat[2] = lights.lights[num2].worldDirection.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].worldPosition.x;
				scratchBufferFloat[1] = lights.lights[num2].worldPosition.y;
				scratchBufferFloat[2] = lights.lights[num2].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].range;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].spotAngleDeg;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64()), 1);
			}
			ovrAvatar_UpdateLights_Native(nativeAvatarLightsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateLights")]
		private static extern void ovrAvatar_UpdateLights_Native(IntPtr lights);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveLights(uint lightCount, uint[] ids);

		[MonoPInvokeCallback(typeof(LoggingDelegate))]
		public static void LoggingCallback(IntPtr str)
		{
			Marshal.PtrToStringAnsi(str);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RegisterLoggingCallback(LoggingDelegate callback);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLoggingLevel(ovrAvatarLogLevel level);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugTransforms")]
		public static extern IntPtr ovrAvatar_GetDebugTransforms_Native(IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugLines")]
		public static extern IntPtr ovrAvatar_GetDebugLines_Native(IntPtr count);

		public static void ovrAvatar_DrawDebugLines()
		{
			IntPtr intPtr = ovrAvatar_GetDebugLines_Native(DebugLineCountData);
			int num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugLine ovrAvatarDebugLine = default(ovrAvatarDebugLine);
			for (int i = 0; i < num; i++)
			{
				int num2 = i * Marshal.SizeOf(typeof(ovrAvatarDebugLine));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num2), scratchBufferFloat, 0, 9);
				ovrAvatarDebugLine.startPoint.x = scratchBufferFloat[0];
				ovrAvatarDebugLine.startPoint.y = scratchBufferFloat[1];
				ovrAvatarDebugLine.startPoint.z = 0f - scratchBufferFloat[2];
				ovrAvatarDebugLine.endPoint.x = scratchBufferFloat[3];
				ovrAvatarDebugLine.endPoint.y = scratchBufferFloat[4];
				ovrAvatarDebugLine.endPoint.z = 0f - scratchBufferFloat[5];
				ovrAvatarDebugLine.color.x = scratchBufferFloat[6];
				ovrAvatarDebugLine.color.y = scratchBufferFloat[7];
				ovrAvatarDebugLine.color.z = scratchBufferFloat[8];
				ovrAvatarDebugLine.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "context").ToInt64()));
				ovrAvatarDebugLine.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "text").ToInt64()));
				UnityEngine.Debug.DrawLine(ovrAvatarDebugLine.startPoint, ovrAvatarDebugLine.endPoint, new Color(ovrAvatarDebugLine.color.x, ovrAvatarDebugLine.color.y, ovrAvatarDebugLine.color.z));
			}
			intPtr = ovrAvatar_GetDebugTransforms_Native(DebugLineCountData);
			num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugTransform ovrAvatarDebugTransform = default(ovrAvatarDebugTransform);
			for (int j = 0; j < num; j++)
			{
				int num3 = j * Marshal.SizeOf(typeof(ovrAvatarDebugTransform));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num3), scratchBufferFloat, 0, 10);
				OvrAvatar.ConvertTransform(scratchBufferFloat, ref ovrAvatarDebugTransform.transform);
				OvrAvatar.ConvertTransform(ovrAvatarDebugTransform.transform, debugLineGo.transform);
				ovrAvatarDebugTransform.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "context").ToInt64()));
				ovrAvatarDebugTransform.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "text").ToInt64()));
				Vector3 vector = 0.1f * debugLineGo.transform.TransformVector(Vector3.up);
				Vector3 vector2 = 0.1f * debugLineGo.transform.TransformVector(Vector3.right);
				Vector3 vector3 = 0.1f * debugLineGo.transform.TransformVector(Vector3.forward);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector, Color.green);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector2, Color.red);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector3, Color.blue);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetDebugDrawContext(uint context);

		public static bool SendEvent(string name, string param = "", string source = "")
		{
			try
			{
				if (ovrPluginVersion == null)
				{
					string text = ovrp_GetVersion();
					if (!string.IsNullOrEmpty(text))
					{
						ovrPluginVersion = new Version(text.Split('-')[0]);
					}
					else
					{
						ovrPluginVersion = new Version(0, 0, 0);
					}
				}
				if (ovrPluginVersion >= OVRP_1_30_0.version)
				{
					return OVRP_1_30_0.ovrp_SendEvent2(name, param, (source.Length == 0) ? "avatar_sdk" : source) == Result.Success;
				}
				return false;
			}
			catch (Exception)
			{
				return false;
			}
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}
	}
}
namespace OVR
{
	public class TestScript : MonoBehaviour
	{
		[InspectorNote("Sound Setup", "Press '1' to play testSound1 and '2' to play testSound2")]
		public SoundFXRef testSound1;

		public SoundFXRef testSound2;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				testSound1.PlaySoundAt(base.transform.position);
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				testSound2.PlaySoundAt(new Vector3(5f, 0f, 0f));
			}
		}
	}
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					UnityEngine.Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = UnityEngine.Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[UnityEngine.Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			if (maxPlayingSounds != 0)
			{
				return playingSoundCount < maxPlayingSounds;
			}
			return true;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization
		{
			get
			{
				if (!(theAudioManager != null))
				{
					return false;
				}
				return theAudioManager.enableSpatializedAudio;
			}
		}

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						UnityEngine.Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					UnityEngine.Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private static int CalculateMaxEmittersSize()
		{
			return theAudioManager.maxSoundEmitters + 1;
		}

		private static bool ValidateEmitterIndex(int index)
		{
			if (index > -1)
			{
				return index < CalculateMaxEmittersSize();
			}
			return false;
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				UnityEngine.Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				UnityEngine.Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[CalculateMaxEmittersSize()];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < CalculateMaxEmittersSize(); i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					UnityEngine.Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						UnityEngine.Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				UnityEngine.Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			UnityEngine.Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			return theAudioManager.soundEmitters[idx].time = time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								UnityEngine.Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							UnityEngine.Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				UnityEngine.Debug.LogError(string.Concat("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = ", priority, " TOO MANY PlaySound* calls!"));
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = (soundFX.ospProps.enableSpatialization ? 1f : 0.8f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = UnityEngine.Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, Action onFinished)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				UnityEngine.Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			if (!(theAudioManager != null))
			{
				return null;
			}
			return theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				UnityEngine.Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length
		{
			get
			{
				if (!(audioSource.clip != null))
				{
					return 0f;
				}
				return audioSource.clip.length;
			}
		}

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				UnityEngine.Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType == Fade.In) ? 0f : defaultVolume);
			float end = ((fadeType == Fade.In) ? defaultVolume : 0f);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid
		{
			get
			{
				if (soundClips.Length != 0)
				{
					return soundClips[0] != null;
				}
				return false;
			}
		}

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride
		{
			get
			{
				if (soundGroup == null)
				{
					return 1f;
				}
				return soundGroup.volumeOverride;
			}
		}

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = UnityEngine.Random.Range(0, soundClips.Length); num == lastIdx; num = UnityEngine.Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				if (!(soundGroup.mixerGroup != null))
				{
					return defaultMixerGroup;
				}
				return soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return UnityEngine.Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
namespace BOWLING
{
	public class AIPlayer_CTRL : MonoBehaviour
	{
		[SerializeField]
		[Range(-52f, 18f)]
		private float range = -17f;

		public Transform ThrowPos;

		public Vector3 BL_BALL_ArrivalPos;

		public float delayTime;

		public float BL_BALL_ThrowTime;

		private GameObject BL_BALL;

		private Animator anim;

		public bool isAutoThrow { get; set; }

		public Coroutine autoThrow { get; set; }

		private void Awake()
		{
			anim = GetComponent<Animator>();
			GetComponent<CustomModelSettingCtrl>().InitCPU(CustomModelViewState.Normal, null, 0.1f);
		}

		public void CreateBall()
		{
			if (BL_BALL != null)
			{
				Rigidbody component = BL_BALL.GetComponent<Rigidbody>();
				component.transform.SetParent(null);
				component.isKinematic = false;
				component.useGravity = true;
				BL_BALL = null;
			}
			BL_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_BALL"), ThrowPos);
			BL_BALL.transform.GetComponent<Rigidbody>().useGravity = false;
			UnityEngine.Object.Destroy(BL_BALL.GetComponent<Grab_CTRL>());
		}

		public void ThrowBall()
		{
			if (BL_BALL == null)
			{
				return;
			}
			if (!SingletonPunBase.Singleton<Setter_SGT>.GetInstance.isAISpare)
			{
				float num = 27f - (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 5f;
				range = -17f + UnityEngine.Random.Range(0f - num, num);
			}
			else
			{
				List<int> list = new List<int>();
				for (int i = 0; i < SingletonPunBase.Singleton<Setter_SGT>.GetInstance.pins_P2.Length; i++)
				{
					if (SingletonPunBase.Singleton<Setter_SGT>.GetInstance.pins_P2[i].gameObject.activeSelf)
					{
						list.Add(i);
					}
				}
				int num2 = list[UnityEngine.Random.Range(0, list.Count)];
				float num3 = 25f - (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 5f;
				switch (num2)
				{
				case 3:
				case 6:
					range = -32f + UnityEngine.Random.Range(0f - num3, num3);
					break;
				case 5:
				case 9:
					range = -6f + UnityEngine.Random.Range(0f - num3, num3);
					break;
				case 1:
				case 7:
					range = -23f + UnityEngine.Random.Range(0f - num3, num3);
					break;
				default:
					range = -17f + UnityEngine.Random.Range(0f - num3, num3);
					break;
				}
			}
			Rigidbody component = BL_BALL.GetComponent<Rigidbody>();
			Ball_CTRL component2 = BL_BALL.GetComponent<Ball_CTRL>();
			component2.isMine = false;
			ParticleSystem.RotationBySpeedModule rotationBySpeed = component2.Spin.rotationBySpeed;
			rotationBySpeed.z = range / 2f;
			if (range < -10f)
			{
				component2.Spin.Play();
			}
			component.transform.SetParent(null);
			component.useGravity = true;
			component.isKinematic = false;
			new Vector3(UnityEngine.Random.Range(-0.1f, 0.1f), 0f, 0f);
			component.velocity = RootPhysics.GetVelocity(component.position, BL_BALL_ArrivalPos, BL_BALL_ThrowTime, isGravity: false);
			component.angularVelocity = new Vector3(0f, 1f, 1f) * 20f;
			component.drag = 0.05f;
			component2.SpinVelo = range;
			BL_BALL = null;
		}

		public void StartAutoThrow()
		{
			if (autoThrow != null)
			{
				StopAutoThrow();
			}
			isAutoThrow = true;
			autoThrow = StartCoroutine(AutoThrow(11f));
		}

		public void StopAutoThrow()
		{
			isAutoThrow = false;
			StopCoroutine(autoThrow);
			autoThrow = null;
		}

		private IEnumerator AutoThrow(float deleyTime)
		{
			if (!isAutoThrow)
			{
				yield break;
			}
			while (true)
			{
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone_Others)
				{
					yield return null;
					continue;
				}
				yield return YieldInstructionCache.WaitForSeconds(deleyTime);
				anim.SetTrigger("Throw");
			}
		}
	}
	public class Ball_CTRL : MonoBehaviour
	{
		private AudioSource audioSource;

		private Rigidbody rigid;

		private Color color;

		private float delayTimer;

		private bool isActive;

		private bool isOnceCheck;

		private bool isRespawn;

		private bool isSpinStep0;

		private bool isSpinStep1;

		private bool isSpinStep2;

		private bool isScoreCheck;

		public ParticleSystem selectParticle;

		private PhysicMaterial material_Physics;

		public Material material_Fade;

		public Material[] materials;

		public AudioClip[] clip_Pin;

		public AudioClip[] clip_Floor;

		public GameObject trail;

		public ParticleSystem particle;

		public ParticleSystem Spin;

		public bool isThrow { get; set; }

		public bool isMine { get; set; }

		public float SpinVelo { get; set; }

		public float AngularVelo { get; set; }

		private void Start()
		{
			audioSource = GetComponentInChildren<AudioSource>();
			rigid = GetComponent<Rigidbody>();
			material_Physics = GetComponent<SphereCollider>().material;
			color = Color.white;
			color.a = 1f;
			delayTimer = 0f;
			isSpinStep0 = false;
			isSpinStep1 = false;
			isSpinStep2 = false;
			isActive = true;
			isThrow = false;
			GetComponent<MeshRenderer>().material = materials[UnityEngine.Random.Range(0, materials.Length)];
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(Spin_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(Faul_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(Gutter_Multi);
		}

		private void Update()
		{
			if (isThrow)
			{
				StartCoroutine(DelayOffActive_C(7f));
				isThrow = false;
			}
			if (isRespawn)
			{
				if (GetComponent<Renderer>().material != material_Fade)
				{
					GetComponent<Renderer>().material = material_Fade;
				}
				base.gameObject.layer = LayerMask.NameToLayer("NoVisible");
				if (color.a > 0f)
				{
					color.a -= 0.011f;
					GetComponent<Renderer>().material.SetColor("_BaseColor", color);
				}
				else if (color.a < 0f)
				{
					color.a = 0f;
					GetComponent<MeshRenderer>().enabled = false;
					Spin.Stop();
					if (isMine)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow = false;
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.SpawnBall();
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 0.5f);
						StartCoroutine(DelayXRRay_C(2f));
					}
					else
					{
						StartCoroutine(DelayDestroy_C(2f));
					}
				}
			}
			if (isActive || isRespawn)
			{
				return;
			}
			if (GetComponent<Renderer>().material != material_Fade)
			{
				GetComponent<Renderer>().material = material_Fade;
			}
			base.gameObject.layer = LayerMask.NameToLayer("NoVisible");
			if (color.a > 0f)
			{
				color.a -= 0.011f;
				GetComponent<Renderer>().material.SetColor("_BaseColor", color);
			}
			else
			{
				if (!(color.a < 0f))
				{
					return;
				}
				color.a = 0f;
				GetComponent<MeshRenderer>().enabled = false;
				Spin.Stop();
				if (isMine)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.SpawnBall();
					StartCoroutine(DelayXRRay_C(2f));
					if (isScoreCheck)
					{
						return;
					}
					isScoreCheck = true;
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						if (PhotonNetwork.IsMasterClient)
						{
							SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(1);
						}
						else
						{
							SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(2);
						}
					}
					else
					{
						SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(1);
					}
				}
				else if (!isScoreCheck)
				{
					isScoreCheck = true;
					StartCoroutine(DelayDestroy_C(2f));
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						SingletonPunBase.Singleton<Setter_SGT>.GetInstance.AICheckScore();
					}
				}
			}
		}

		private void OnCollisionEnter(Collision other)
		{
			if (other.transform.tag == "Pin")
			{
				PlaySound(clip_Pin);
				particle.Play();
				if (isMine)
				{
					if (!isScoreCheck)
					{
						isScoreCheck = true;
						if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
						{
							if (PhotonNetwork.IsMasterClient)
							{
								SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(1);
							}
							else
							{
								SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(2);
							}
						}
						else
						{
							SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(1);
						}
					}
				}
				else if (!isScoreCheck)
				{
					isScoreCheck = true;
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						SingletonPunBase.Singleton<Setter_SGT>.GetInstance.AICheckScore();
					}
				}
			}
			if (isOnceCheck || !(other.transform.tag == "Floor"))
			{
				return;
			}
			isOnceCheck = true;
			PlaySound(clip_Floor);
			if (!isRespawn && rigid.velocity.z < 3f)
			{
				isRespawn = true;
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul_Cn);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul);
				}
			}
		}

		private void OnCollisionStay(Collision collision)
		{
			if (!isSpinStep0 && !isSpinStep1 && !isSpinStep2)
			{
				return;
			}
			string text = collision.transform.tag;
			if (text == "Floor")
			{
				float num = (AngularVelo + SpinVelo) / 1.5f;
				float num2 = rigid.velocity.magnitude / 60f;
				if (isSpinStep0)
				{
					rigid.AddForce(num * num2 / 3f, 0f, 0f);
				}
				if (isSpinStep1)
				{
					rigid.AddForce(num * num2 / 1.5f, 0f, 0f);
				}
				if (isSpinStep2)
				{
					rigid.AddForce(num * num2 * 1.5f, 0f, 0f);
				}
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!isActive || isRespawn)
			{
				return;
			}
			switch (other.transform.tag)
			{
			case "Destroy":
				PlaySound(clip_Floor);
				isActive = false;
				break;
			case "SpinStep0":
				isSpinStep0 = true;
				rigid.drag = 0.05f;
				rigid.angularDrag = 0f;
				break;
			case "SpinStep1":
				isSpinStep1 = true;
				break;
			case "SpinStep2":
				isSpinStep2 = true;
				break;
			case "OutSide":
				if (isMine)
				{
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Gutter_Cn);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Gutter);
					}
				}
				isActive = false;
				break;
			}
		}

		private void OnTriggerStay(Collider other)
		{
		}

		private void PlaySound(AudioClip[] clips)
		{
			float num = Mathf.Clamp(rigid.velocity.magnitude, 0f, 15f);
			float volumeScale = num / 2f;
			audioSource.pitch = 1.15f - num / 50f;
			audioSource.PlayOneShot(clips[UnityEngine.Random.Range(0, clips.Length)], volumeScale);
		}

		public void CalulateAngluer(UnityEngine.XR.Interaction.Toolkit.XRController controller)
		{
			StartCoroutine(CalulateAngluerVelo(controller));
		}

		private IEnumerator CalulateAngluerVelo(UnityEngine.XR.Interaction.Toolkit.XRController controller)
		{
			int count = 0;
			while (count < 5)
			{
				Quaternion StartVectorX = controller.transform.rotation;
				yield return new WaitForSecondsRealtime(0.1f);
				count++;
				(controller.transform.rotation * Quaternion.Inverse(StartVectorX)).ToAngleAxis(out var angle, out var axis);
				while (angle > 180f)
				{
					angle -= 360f;
				}
				_ = Vector3.zero;
				angle *= 0.17453292f;
				Vector3 rhs = axis * angle;
				AngularVelo += 0f - Vector3.Dot(controller.transform.forward, rhs);
			}
			SpinVelo = rigid.angularVelocity.y;
			float num = (AngularVelo + SpinVelo) / 1.5f;
			if (num < -21f)
			{
				num = -21f;
			}
			else if (num > 21f)
			{
				num = 21f;
			}
			if (Mathf.Abs(num) < 6f)
			{
				AngularVelo = 0f;
			}
			else
			{
				ParticleSystem.RotationBySpeedModule rotationBySpeed = Spin.rotationBySpeed;
				rotationBySpeed.z = num * 2f;
				Spin.Play();
			}
			rigid.angularVelocity = new Vector3(rigid.angularVelocity.x, 0f - num, 0f - num);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<float, float, Vector3, Vector3> data = new LumpsData<float, float, Vector3, Vector3>
				{
					lumps1 = AngularVelo,
					lumps2 = SpinVelo,
					lumps3 = base.transform.position,
					lumps4 = rigid.velocity
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(Spin_Multi, data, RpcTarget.Others);
			}
		}

		private IEnumerator DelayOffActive_C(float deleyTime)
		{
			yield return YieldInstructionCache.WaitForSeconds(deleyTime);
			isActive = false;
		}

		private IEnumerator DelayOffActive_C()
		{
			yield return YieldInstructionCache.WaitForSeconds(2f);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (isMine && !isSpinStep0)
				{
					isActive = false;
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul_Cn);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul);
					}
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = false
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(Faul_Multi, data, RpcTarget.Others);
				}
			}
			else if (!isSpinStep0)
			{
				isActive = false;
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul_Cn);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul);
				}
			}
		}

		private IEnumerator DelayXRRay_C(float delayTime)
		{
			yield return YieldInstructionCache.WaitForSeconds(delayTime);
			base.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		private IEnumerator DelayDestroy_C(float delayTime)
		{
			yield return YieldInstructionCache.WaitForSeconds(delayTime);
			base.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void Spin_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<float, float, Vector3, Vector3> && !(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall == null))
			{
				Ball_CTRL component = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Ball_CTRL>();
				component.AngularVelo = (packet as LumpsData<float, float, Vector3, Vector3>).lumps1;
				component.SpinVelo = (packet as LumpsData<float, float, Vector3, Vector3>).lumps2;
				component.rigid.velocity = (packet as LumpsData<float, float, Vector3, Vector3>).lumps4;
				float num = (component.AngularVelo + component.SpinVelo) / 1.5f;
				if (num < -21f)
				{
					num = -21f;
				}
				else if (num > 21f)
				{
					num = 21f;
				}
				if (Mathf.Abs(num) < 6f)
				{
					component.AngularVelo = 0f;
				}
				else
				{
					ParticleSystem.RotationBySpeedModule rotationBySpeed = component.Spin.rotationBySpeed;
					rotationBySpeed.z = num * 2f;
					component.Spin.Play();
				}
				component.rigid.angularVelocity = new Vector3(component.rigid.angularVelocity.x, 0f - num, 0f - num);
			}
		}

		public void Faul_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul_Cn);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Faul);
				}
			}
		}

		public void Gutter_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<Vector3> && !(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall == null))
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Ball_CTRL>().transform.position = (packet as LumpsData<Vector3>).lumps;
			}
		}
	}
	public class Catch_CTRL : XRBaseInteractable
	{
		private Rigidbody rigid;

		private Transform trans_Attach;

		private bool isCatch;

		private List<InputDevice> inputDevices = new List<InputDevice>();

		private bool triggerValueL;

		private bool triggerValueR;

		private void Start()
		{
			if (rigid == null)
			{
				rigid = GetComponent<Rigidbody>();
			}
		}

		private void FixedUpdate()
		{
			if (!isCatch)
			{
				return;
			}
			rigid.useGravity = true;
			rigid.velocity = Vector3.zero;
			rigid.transform.position = Vector3.Lerp(rigid.position, trans_Attach.position, 0.3f);
			rigid.angularVelocity = Vector3.zero;
			rigid.transform.rotation = trans_Attach.rotation;
			SingletonPunBase.Singleton<RootPhysics>.GetInstance.RecordLatestPosesForDrop(rigid.transform, Time.time, 0.1f);
			inputDevices.Clear();
			InputDevices.GetDevicesAtXRNode(XRNode.RightHand, inputDevices);
			foreach (InputDevice inputDevice in inputDevices)
			{
				bool value = false;
				if (inputDevice.TryGetFeatureValue(CommonUsages.triggerButton, out value) && value != triggerValueR)
				{
					triggerValueR = value;
					UnityEngine.Debug.Log("TriggerR - " + triggerValueR);
					if (!triggerValueR)
					{
						isCatch = false;
						trans_Attach = null;
						Detach();
					}
				}
			}
			inputDevices.Clear();
			InputDevices.GetDevicesAtXRNode(XRNode.LeftHand, inputDevices);
			foreach (InputDevice inputDevice2 in inputDevices)
			{
				bool value2 = false;
				if (inputDevice2.TryGetFeatureValue(CommonUsages.triggerButton, out value2) && value2 != triggerValueL)
				{
					triggerValueL = value2;
					UnityEngine.Debug.Log("TriggerL - " + triggerValueL);
					if (!triggerValueL)
					{
						isCatch = false;
						trans_Attach = null;
						Detach();
					}
				}
			}
		}

		protected override void OnSelectEnter(XRBaseInteractor interactor)
		{
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart)
			{
				isCatch = true;
				rigid.useGravity = false;
				rigid.drag = 0.05f;
				rigid.angularDrag = 0f;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
				trans_Attach = interactor.transform.Find("ThrowPos").transform;
			}
		}

		private void Detach()
		{
			RootPhysics.Pose poseQueue = SingletonPunBase.Singleton<RootPhysics>.GetInstance.GetPoseQueue();
			float duration = Time.time - poseQueue.time;
			RootPhysics.SetRigidbodyVelocity(rigid, poseQueue.pose.pos, rigid.position, duration);
			RootPhysics.SetRigidbodyAngularVelocity(rigid, poseQueue.pose.rot, rigid.rotation, duration);
			rigid.velocity *= 2f;
			rigid.isKinematic = false;
			rigid.GetComponent<Ball_CTRL>().isThrow = true;
			GetComponent<SphereCollider>().enabled = true;
			float magnitude = rigid.velocity.magnitude;
			Vector3 vector = new Vector3(rigid.position.x, 0f, 23.5f);
			Vector3 previewHitPos = RootPhysics.GetPreviewHitPos(rigid, null, "Revision");
			if (previewHitPos != Vector3.zero)
			{
				float num = Vector3.Dot(rigid.transform.forward, rigid.angularVelocity);
				if (num < 1f && num > -1f)
				{
					num = 0f;
				}
				UnityEngine.Debug.Log(num * 1.5f);
				rigid.velocity = RootPhysics.GetVelocity(rigid.position, vector + new Vector3(previewHitPos.x - rigid.position.x, 0f, 0f) * 3f, 3f, isGravity: false).normalized * magnitude;
				rigid.angularVelocity = new Vector3(rigid.velocity.magnitude, 0f, num * 1.5f);
			}
			else
			{
				rigid.drag = 1.1f;
				rigid.angularDrag = 1f;
			}
			if (rigid.velocity.magnitude > 6.5f)
			{
				rigid.velocity = rigid.velocity.normalized * 6.5f;
			}
			SingletonPunBase.Singleton<RootPhysics>.GetInstance.ClearPoseQueue();
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(Rigidbody))]
	[AddComponentMenu("XR/XR Grab Interactable")]
	public class Grab_CTRL : XRBaseInteractable
	{
		private const float k_DefaultTighteningAmount = 0.5f;

		private const float k_DefaultSmoothingAmount = 5f;

		private const float k_VelocityPredictionFactor = 0.6f;

		private const float k_AngularVelocityDamping = 0.95f;

		private const int k_ThrowSmoothingFrameCount = 20;

		private const float k_DefaultAttachEaseInTime = 0.15f;

		private const float k_DefaultThrowSmoothingDuration = 0.25f;

		private const float k_DefaultThrowVelocityScale = 1.5f;

		private const float k_DefaultThrowAngularVelocityScale = 0.25f;

		[SerializeField]
		private Transform m_AttachTransform;

		[SerializeField]
		private float m_AttachEaseInTime = 0.15f;

		[SerializeField]
		private MovementType m_MovementType = MovementType.Kinematic;

		[SerializeField]
		private bool m_TrackPosition = true;

		[SerializeField]
		private bool m_SmoothPosition;

		[SerializeField]
		[Range(0f, 20f)]
		private float m_SmoothPositionAmount = 5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_TightenPosition = 0.5f;

		[SerializeField]
		private bool m_TrackRotation = true;

		[SerializeField]
		private bool m_SmoothRotation;

		[SerializeField]
		[Range(0f, 20f)]
		private float m_SmoothRotationAmount = 5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_TightenRotation = 0.5f;

		[SerializeField]
		private bool m_ThrowOnDetach = true;

		[SerializeField]
		private float m_ThrowSmoothingDuration = 0.25f;

		[SerializeField]
		[Tooltip("The curve to use to weight velocity smoothing (most recent frames to the right.")]
		private AnimationCurve m_ThrowSmoothingCurve = AnimationCurve.Linear(1f, 1f, 1f, 0f);

		[SerializeField]
		private float m_ThrowVelocityScale = 1.5f;

		[SerializeField]
		private float m_ThrowAngularVelocityScale = 0.25f;

		[SerializeField]
		private bool m_GravityOnDetach;

		[SerializeField]
		private bool m_RetainTransformParent = true;

		private bool m_WasKinematic;

		private bool m_UsedGravity;

		private Transform m_OriginalSceneParent;

		private XRBaseInteractor m_SelectingInteractor;

		private Vector3 m_InteractorLocalPosition;

		private Quaternion m_InteractorLocalRotation;

		private Vector3 m_TargetWorldPosition;

		private Quaternion m_TargetWorldRotation;

		private float m_CurrentAttachEaseTime;

		private MovementType m_CurrentMovementType;

		private bool m_DetachInLateUpdate;

		private Vector3 m_DetachVelocity;

		private Vector3 m_DetachAngularVelocity;

		private int m_ThrowSmoothingCurrentFrame;

		private float[] m_ThrowSmoothingFrameTimes = new float[20];

		private Vector3[] m_ThrowSmoothingVelocityFrames = new Vector3[20];

		private Vector3[] m_ThrowSmoothingAngularVelocityFrames = new Vector3[20];

		private Rigidbody m_RigidBody;

		private Vector3 m_LastPosition;

		private Quaternion m_LastRotation;

		private Transform trans_Attach;

		private Ball_CTRL ball_Ctrl;

		private bool isOnceSelect;

		private bool isGrap;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		public Transform attachTransform
		{
			get
			{
				return m_AttachTransform;
			}
			set
			{
				m_AttachTransform = value;
			}
		}

		public float attachEaseInTime
		{
			get
			{
				return m_AttachEaseInTime;
			}
			set
			{
				m_AttachEaseInTime = value;
			}
		}

		public MovementType movementType
		{
			get
			{
				return m_MovementType;
			}
			set
			{
				m_MovementType = value;
			}
		}

		public bool trackPosition
		{
			get
			{
				return m_TrackPosition;
			}
			set
			{
				m_TrackPosition = value;
			}
		}

		public bool smoothPosition
		{
			get
			{
				return m_SmoothPosition;
			}
			set
			{
				m_SmoothPosition = value;
			}
		}

		public float smoothPositionAmount
		{
			get
			{
				return m_SmoothPositionAmount;
			}
			set
			{
				m_SmoothPositionAmount = value;
			}
		}

		public float tightenPosition
		{
			get
			{
				return m_TightenPosition;
			}
			set
			{
				m_TightenPosition = value;
			}
		}

		public bool trackRotation
		{
			get
			{
				return m_TrackRotation;
			}
			set
			{
				m_TrackRotation = value;
			}
		}

		public bool smoothRotation
		{
			get
			{
				return m_SmoothRotation;
			}
			set
			{
				m_SmoothRotation = value;
			}
		}

		public float smoothRotationAmount
		{
			get
			{
				return m_SmoothRotationAmount;
			}
			set
			{
				m_SmoothRotationAmount = value;
			}
		}

		public float tightenRotation
		{
			get
			{
				return m_TightenRotation;
			}
			set
			{
				m_TightenRotation = value;
			}
		}

		public bool throwOnDetach
		{
			get
			{
				return m_ThrowOnDetach;
			}
			set
			{
				m_ThrowOnDetach = value;
			}
		}

		public float throwSmoothingDuration
		{
			get
			{
				return m_ThrowSmoothingDuration;
			}
			set
			{
				m_ThrowSmoothingDuration = value;
			}
		}

		public float throwVelocityScale
		{
			get
			{
				return m_ThrowVelocityScale;
			}
			set
			{
				m_ThrowVelocityScale = value;
			}
		}

		public float throwAngularVelocityScale
		{
			get
			{
				return m_ThrowAngularVelocityScale;
			}
			set
			{
				m_ThrowAngularVelocityScale = value;
			}
		}

		public bool gravityOnDetach
		{
			get
			{
				return m_GravityOnDetach;
			}
			set
			{
				m_GravityOnDetach = value;
			}
		}

		public bool retainTransformParent
		{
			get
			{
				return m_RetainTransformParent;
			}
			set
			{
				m_RetainTransformParent = value;
			}
		}

		public XRBaseInteractor selectingInteractor => m_SelectingInteractor;

		protected override void Awake()
		{
			base.Awake();
			m_CurrentMovementType = m_MovementType;
			if (m_RigidBody == null)
			{
				m_RigidBody = GetComponent<Rigidbody>();
			}
			if (m_RigidBody == null)
			{
				UnityEngine.Debug.LogWarning("Grab Interactable does not have a required RigidBody.", this);
			}
			ball_Ctrl = GetComponent<Ball_CTRL>();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ThowBall_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(CreateBall_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(DestroyBall_Multi);
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
		}

		public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			switch (updatePhase)
			{
			case XRInteractionUpdateOrder.UpdatePhase.Fixed:
				if (base.isSelected)
				{
					if (m_CurrentMovementType == MovementType.Kinematic)
					{
						PerformKinematicUpdate(Time.unscaledDeltaTime, updatePhase);
					}
					else if (m_CurrentMovementType == MovementType.VelocityTracking)
					{
						PerformVelocityTrackingUpdate(Time.unscaledDeltaTime, updatePhase);
					}
				}
				break;
			case XRInteractionUpdateOrder.UpdatePhase.Dynamic:
				if (base.isSelected)
				{
					UpdateTarget(Time.unscaledDeltaTime);
					SmoothVelocityUpdate();
					if (m_CurrentMovementType == MovementType.Instantaneous)
					{
						PerformInstantaneousUpdate(Time.unscaledDeltaTime, updatePhase);
					}
				}
				break;
			case XRInteractionUpdateOrder.UpdatePhase.OnBeforeRender:
				if (base.isSelected && m_CurrentMovementType == MovementType.Instantaneous)
				{
					PerformInstantaneousUpdate(Time.unscaledDeltaTime, updatePhase);
				}
				break;
			case XRInteractionUpdateOrder.UpdatePhase.Late:
				break;
			}
		}

		private Quaternion GetWorldAttachRotation(XRBaseInteractor interactor)
		{
			return interactor.attachTransform.rotation * m_InteractorLocalRotation;
		}

		private void UpdateTarget(float timeDelta)
		{
			if (m_AttachEaseInTime > 0f && m_CurrentAttachEaseTime <= m_AttachEaseInTime)
			{
				float t = m_CurrentAttachEaseTime / m_AttachEaseInTime;
				m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), t);
				m_CurrentAttachEaseTime += Time.unscaledDeltaTime;
			}
			else if (!m_SmoothPosition)
			{
				if (m_SmoothRotation)
				{
					m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), m_SmoothRotationAmount * timeDelta);
					m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), m_TightenRotation);
				}
				else
				{
					m_TargetWorldRotation = GetWorldAttachRotation(m_SelectingInteractor);
				}
			}
		}

		private void PerformInstantaneousUpdate(float timeDelta, XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic || updatePhase == XRInteractionUpdateOrder.UpdatePhase.OnBeforeRender)
			{
				if (trackPosition)
				{
					base.transform.position = m_TargetWorldPosition;
				}
				if (trackRotation)
				{
					base.transform.rotation = m_TargetWorldRotation;
				}
			}
		}

		private void PerformKinematicUpdate(float timeDelta, XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Fixed)
			{
				if (trackPosition)
				{
					m_RigidBody.velocity = Vector3.zero;
					m_RigidBody.transform.position = Vector3.Lerp(m_RigidBody.position, trans_Attach.position, 0.3f);
					SingletonPunBase.Singleton<RootPhysics>.GetInstance.RecordLatestPosesForDrop(m_RigidBody.transform, Time.time, 0.1f);
				}
				if (trackRotation)
				{
					m_RigidBody.angularVelocity = Vector3.zero;
					m_RigidBody.transform.rotation = trans_Attach.rotation;
				}
			}
		}

		private void PerformVelocityTrackingUpdate(float timeDelta, XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			if (updatePhase != 0)
			{
				return;
			}
			if (trackPosition)
			{
				m_RigidBody.velocity *= 0.6f;
				Vector3 vector = (m_TargetWorldPosition - m_RigidBody.worldCenterOfMass) / timeDelta;
				if (!float.IsNaN(vector.x))
				{
					m_RigidBody.velocity += vector;
				}
			}
			if (!trackRotation)
			{
				return;
			}
			m_RigidBody.angularVelocity *= 0.6f;
			(m_TargetWorldRotation * Quaternion.Inverse(m_RigidBody.rotation)).ToAngleAxis(out var angle, out var axis);
			if (angle > 180f)
			{
				angle -= 360f;
			}
			if (Mathf.Abs(angle) > Mathf.Epsilon)
			{
				Vector3 vector2 = axis * angle * ((float)Math.PI / 180f) / timeDelta;
				if (!float.IsNaN(vector2.x))
				{
					m_RigidBody.angularVelocity += vector2 * 0.95f;
				}
			}
		}

		private void Teleport(Transform teleportTransform)
		{
			if (trackPosition)
			{
				Vector3 translation = teleportTransform.position - m_RigidBody.worldCenterOfMass;
				m_RigidBody.velocity = Vector3.zero;
				base.transform.Translate(translation, Space.World);
			}
			if (trackRotation)
			{
				m_RigidBody.angularVelocity = Vector3.zero;
				m_RigidBody.transform.rotation = teleportTransform.rotation;
			}
		}

		private void Detach()
		{
			if (!GetComponent<Ball_CTRL>().isMine || !m_ThrowOnDetach || trans_Attach == null)
			{
				return;
			}
			if (trans_Attach.parent.parent.name == "LeftHand")
			{
				ball_Ctrl.CalulateAngluer(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController);
			}
			else
			{
				ball_Ctrl.CalulateAngluer(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController);
			}
			RootPhysics.Pose poseQueue = SingletonPunBase.Singleton<RootPhysics>.GetInstance.GetPoseQueue();
			float duration = Time.time - poseQueue.time;
			RootPhysics.SetRigidbodyAngularVelocity(m_RigidBody, poseQueue.pose.rot, m_RigidBody.rotation, duration);
			m_RigidBody.velocity = m_DetachVelocity;
			Vector3 detachAngularVelocity = m_DetachAngularVelocity;
			detachAngularVelocity = new Vector3(0f - detachAngularVelocity.x, detachAngularVelocity.y, detachAngularVelocity.z);
			m_RigidBody.angularVelocity = detachAngularVelocity;
			m_RigidBody.isKinematic = false;
			m_RigidBody.GetComponent<Ball_CTRL>().isThrow = true;
			m_RigidBody.GetComponent<Ball_CTRL>().isMine = true;
			GetComponent<SphereCollider>().enabled = true;
			float magnitude = m_RigidBody.velocity.magnitude;
			Vector3 zero = Vector3.zero;
			zero = ((!(trans_Attach.parent.parent.name == "LeftHand")) ? new Vector3(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.transform.position.x, 0f, 23.5f) : new Vector3(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.transform.position.x, 0f, 23.5f));
			Vector3 zero2 = Vector3.zero;
			zero2 = ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi) ? RootPhysics.GetPreviewHitPos(m_RigidBody, null, "Revision1") : ((!PhotonNetwork.IsMasterClient) ? RootPhysics.GetPreviewHitPos(m_RigidBody, null, "Revision2") : RootPhysics.GetPreviewHitPos(m_RigidBody, null, "Revision1")));
			if (zero2 != Vector3.zero)
			{
				m_RigidBody.velocity = RootPhysics.GetVelocity(m_RigidBody.position, zero + new Vector3(zero2.x - m_RigidBody.position.x, 0f, 0f) * 3f, 3f, isGravity: false).normalized * magnitude;
				if (Mathf.Abs(m_RigidBody.angularVelocity.y) < 7f)
				{
					m_RigidBody.angularVelocity = new Vector3(m_RigidBody.angularVelocity.x, 0f, m_RigidBody.angularVelocity.z);
				}
			}
			if (m_RigidBody.velocity.magnitude > 7.7f)
			{
				m_RigidBody.velocity = m_RigidBody.velocity.normalized * 7.7f;
			}
			SingletonPunBase.Singleton<RootPhysics>.GetInstance.ClearPoseQueue();
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow = true;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				BallData data = new BallData
				{
					position = m_RigidBody.transform.position,
					velocity = m_RigidBody.velocity,
					angularVelocity = m_RigidBody.angularVelocity,
					photonTime = PhotonNetwork.Time
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ThowBall_Multi, data, RpcTarget.Others);
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.CheckTime(isFlow: false);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.CheckTime(isFlow: false);
			}
			UnityEngine.Object.Destroy(this);
		}

		private void UpdateInteractorLocalPose(XRBaseInteractor interactor)
		{
			Transform transform = (m_AttachTransform ? m_AttachTransform : base.transform);
			Vector3 vector = (m_AttachTransform ? m_AttachTransform.position : m_RigidBody.worldCenterOfMass);
			Vector3 direction = m_RigidBody.worldCenterOfMass - vector;
			Vector3 interactorLocalPosition = transform.InverseTransformDirection(direction);
			Vector3 lossyScale = interactor.attachTransform.lossyScale;
			lossyScale = new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z);
			interactorLocalPosition.Scale(lossyScale);
			m_InteractorLocalPosition = interactorLocalPosition;
			m_InteractorLocalRotation = Quaternion.Inverse(Quaternion.Inverse(m_RigidBody.rotation) * transform.rotation);
		}

		protected override void OnSelectEnter(XRBaseInteractor interactor)
		{
			if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow && GetComponent<Ball_CTRL>().isMine && (bool)interactor)
			{
				if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart && !SingletonPunBase.Singleton<Game_SGT>.GetInstance.isOnceStart)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.isOnceStart = true;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
				}
				if (SingletonPunBase.Singleton<UI_SGT>.GetInstance.anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
				{
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.ClickButton("Start");
				}
				base.OnSelectEnter(interactor);
				isGrap = true;
				trans_Attach = interactor.transform.Find("HandModel/ThrowPos").transform;
				if (ball_Ctrl.selectParticle.isPlaying)
				{
					ball_Ctrl.selectParticle.gameObject.SetActive(value: false);
				}
				if (trans_Attach.parent.parent.name == "LeftHand")
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.Haptic(0.5f, 0.1f);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.Haptic(0.5f, 0.1f, isLeft: false);
				}
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					LumpsData<string> data = new LumpsData<string>
					{
						lumps = trans_Attach.parent.parent.name
					};
					UnityEngine.Debug.Log(trans_Attach.parent.parent.name);
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(CreateBall_Multi, data, RpcTarget.Others);
				}
				if (m_SelectingInteractor == null)
				{
					m_OriginalSceneParent = base.transform.parent;
					base.transform.parent = null;
				}
				m_SelectingInteractor = interactor;
				m_CurrentMovementType = (interactor.selectedInteractableMovementTypeOverride.HasValue ? interactor.selectedInteractableMovementTypeOverride.Value : m_MovementType);
				m_WasKinematic = m_RigidBody.isKinematic;
				m_UsedGravity = m_RigidBody.useGravity;
				m_RigidBody.isKinematic = m_CurrentMovementType == MovementType.Kinematic;
				m_RigidBody.useGravity = false;
				m_RigidBody.drag = 0.05f;
				m_RigidBody.angularDrag = 0f;
				GetComponent<SphereCollider>().enabled = false;
				m_DetachVelocity = (m_DetachAngularVelocity = Vector3.zero);
				if (false)
				{
					Teleport(m_SelectingInteractor.attachTransform);
				}
				else if (m_AttachEaseInTime > 0f)
				{
					m_TargetWorldPosition = m_RigidBody.worldCenterOfMass;
					m_TargetWorldRotation = base.transform.rotation;
					m_CurrentAttachEaseTime = 0f;
				}
				SmoothVelocityStart();
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 0, 0f);
			}
		}

		protected override void OnSelectExit(XRBaseInteractor interactor)
		{
			base.OnSelectExit(interactor);
			GetComponent<Ball_CTRL>().isMine = true;
			m_RigidBody.isKinematic = m_WasKinematic;
			m_RigidBody.useGravity = true;
			m_CurrentMovementType = m_MovementType;
			m_SelectingInteractor = null;
			m_DetachInLateUpdate = true;
		}

		public override bool IsHoverableBy(XRBaseInteractor interactor)
		{
			if (!ball_Ctrl.selectParticle.isPlaying)
			{
				isOnceSelect = true;
				ball_Ctrl.selectParticle.Play();
			}
			return true;
		}

		private void SmoothVelocityStart()
		{
			if ((bool)m_SelectingInteractor)
			{
				m_LastPosition = m_SelectingInteractor.attachTransform.position;
				m_LastRotation = m_SelectingInteractor.attachTransform.rotation;
				Array.Clear(m_ThrowSmoothingFrameTimes, 0, m_ThrowSmoothingFrameTimes.Length);
				Array.Clear(m_ThrowSmoothingVelocityFrames, 0, m_ThrowSmoothingVelocityFrames.Length);
				Array.Clear(m_ThrowSmoothingAngularVelocityFrames, 0, m_ThrowSmoothingAngularVelocityFrames.Length);
				m_ThrowSmoothingCurrentFrame = 0;
			}
		}

		private void SmoothVelocityEnd()
		{
			if (m_ThrowOnDetach)
			{
				Vector3 smoothedVelocityValue = getSmoothedVelocityValue(m_ThrowSmoothingVelocityFrames);
				Vector3 smoothedVelocityValue2 = getSmoothedVelocityValue(m_ThrowSmoothingAngularVelocityFrames);
				m_DetachVelocity = smoothedVelocityValue * m_ThrowVelocityScale;
				m_DetachAngularVelocity = smoothedVelocityValue2 * m_ThrowAngularVelocityScale;
			}
		}

		private void SmoothVelocityUpdate()
		{
			if ((bool)m_SelectingInteractor)
			{
				m_ThrowSmoothingFrameTimes[m_ThrowSmoothingCurrentFrame] = Time.time;
				m_ThrowSmoothingVelocityFrames[m_ThrowSmoothingCurrentFrame] = (m_SelectingInteractor.attachTransform.position - m_LastPosition) / Time.deltaTime;
				Quaternion quaternion = m_SelectingInteractor.attachTransform.rotation * Quaternion.Inverse(m_LastRotation);
				m_ThrowSmoothingAngularVelocityFrames[m_ThrowSmoothingCurrentFrame] = new Vector3(Mathf.DeltaAngle(0f, quaternion.eulerAngles.x), Mathf.DeltaAngle(0f, quaternion.eulerAngles.y), Mathf.DeltaAngle(0f, quaternion.eulerAngles.z)) / Time.deltaTime * ((float)Math.PI / 180f);
				m_ThrowSmoothingCurrentFrame = (m_ThrowSmoothingCurrentFrame + 1) % 20;
				m_LastPosition = m_SelectingInteractor.attachTransform.position;
				m_LastRotation = m_SelectingInteractor.attachTransform.rotation;
			}
		}

		private Vector3 getSmoothedVelocityValue(Vector3[] velocityFrames)
		{
			Vector3 vector = default(Vector3);
			int i = 0;
			float num = 0f;
			for (; i < 20; i++)
			{
				int num2 = ((m_ThrowSmoothingCurrentFrame - i - 1) % 20 + 20) % 20;
				if (m_ThrowSmoothingFrameTimes[num2] == 0f)
				{
					break;
				}
				float num3 = (Time.time - m_ThrowSmoothingFrameTimes[num2]) / m_ThrowSmoothingDuration;
				float num4 = m_ThrowSmoothingCurve.Evaluate(Mathf.Clamp(1f - num3, 0f, 1f));
				vector += velocityFrames[num2] * num4;
				num += num4;
				if (Time.time - m_ThrowSmoothingFrameTimes[num2] > m_ThrowSmoothingDuration)
				{
					break;
				}
			}
			if (num > 0f)
			{
				return vector / num;
			}
			return Vector3.zero;
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (!obj && trans_Attach != null && trans_Attach.parent.parent.name == "LeftHand" && SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart && isGrap)
			{
				m_RigidBody.isKinematic = m_WasKinematic;
				m_RigidBody.useGravity = true;
				m_CurrentMovementType = m_MovementType;
				m_SelectingInteractor = null;
				m_DetachInLateUpdate = true;
				SmoothVelocityEnd();
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (!obj && trans_Attach != null && trans_Attach.parent.parent.name == "RightHand" && SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart && isGrap)
			{
				m_RigidBody.isKinematic = m_WasKinematic;
				m_RigidBody.useGravity = true;
				m_CurrentMovementType = m_MovementType;
				m_SelectingInteractor = null;
				m_DetachInLateUpdate = true;
				SmoothVelocityEnd();
			}
		}

		private void Update()
		{
			if (!base.isHovered && isOnceSelect)
			{
				if (ball_Ctrl.selectParticle.isPlaying)
				{
					isOnceSelect = false;
					ball_Ctrl.selectParticle.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
				}
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
				{
					OnTriggerL.CurrentData = isPressed;
				}
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
				{
					OnTriggerR.CurrentData = isPressed2;
				}
			}
			if (trans_Attach != null && SingletonPunBase.Singleton<Game_SGT>.GetInstance.time <= 0f)
			{
				TimeOverDetach();
			}
			if (m_DetachInLateUpdate)
			{
				Detach();
				m_DetachInLateUpdate = false;
			}
		}

		public void CreateBall_Multi(SerializableClass packet)
		{
			switch ((packet as LumpsData<string>).lumps)
			{
			case "Head":
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_BALL_Mul"), GameObject.Find("Others/Head").transform).transform;
				break;
			case "LeftHand":
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_BALL_Mul"), GameObject.Find("Others/LeftHand/HandModel/ThrowPos").transform).transform;
				break;
			case "RightHand":
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_BALL_Mul"), GameObject.Find("Others/RightHand/HandModel/ThrowPos").transform).transform;
				break;
			}
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Ball_CTRL>().isMine = false;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Rigidbody>().useGravity = false;
		}

		public void ThowBall_Multi(SerializableClass packet)
		{
			if (packet is BallData && !(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.gameObject == null))
			{
				Ball_CTRL component = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Ball_CTRL>();
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.SetParent(null);
				Rigidbody component2 = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Rigidbody>();
				component.isMine = false;
				component.isThrow = true;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.transform.position = (packet as BallData).position;
				component2.position = (packet as BallData).position;
				component2.transform.SetParent(null);
				component2.useGravity = true;
				component2.isKinematic = false;
				component2.angularVelocity = (packet as BallData).angularVelocity;
				component2.velocity = (packet as BallData).velocity;
				component2.drag = 0.05f;
				component2.angularDrag = 0f;
			}
		}

		public void DestroyBall_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool> && SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.gameObject != null)
			{
				UnityEngine.Object.Destroy(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.gameObject);
			}
		}

		private void TimeOverDetach()
		{
			if (ball_Ctrl.gameObject != null)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.SpawnBall();
				UnityEngine.Object.Destroy(ball_Ctrl.gameObject);
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = false
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(DestroyBall_Multi, data, RpcTarget.Others);
			}
		}
	}
	public class Player_CTRL : MonoBehaviour
	{
		private PhotonView pv;

		private Animator anim_LeftHand;

		private Animator anim_RightHand;

		public GameObject Revision;

		private bool isClickMouse0;

		public bool isClickMouse1;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		public Transform Head { get; set; }

		public Transform LeftHand { get; set; }

		public Transform RightHand { get; set; }

		public Transform othersBall { get; set; }

		public UnityEngine.XR.Interaction.Toolkit.XRController LeftController { get; set; }

		public UnityEngine.XR.Interaction.Toolkit.XRController RightController { get; set; }

		public bool isThrow { get; set; }

		private void Awake()
		{
			pv = GetComponent<PhotonView>();
			Head = base.transform.Find("Head");
			LeftHand = base.transform.Find("LeftHand");
			RightHand = base.transform.Find("RightHand");
			anim_LeftHand = LeftHand.GetComponentInChildren<Animator>();
			anim_RightHand = RightHand.GetComponentInChildren<Animator>();
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("FadeSphere"), Head);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
		}

		private void Start()
		{
			LeftController = LeftHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
		}

		private void Update()
		{
			if ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi || pv.IsMine) && !SingletonPunBase.Singleton<UI_SGT>.GetInstance.isPublicUI)
			{
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
				{
					OnTriggerL.CurrentData = isPressed;
				}
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
				{
					OnTriggerR.CurrentData = isPressed2;
				}
			}
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (obj)
			{
				anim_LeftHand.SetTrigger("GrabBall");
			}
			else
			{
				anim_LeftHand.SetTrigger("Idle");
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (obj)
			{
				anim_RightHand.SetTrigger("GrabBall");
			}
			else
			{
				anim_RightHand.SetTrigger("Idle");
			}
		}

		public void Haptic(float amplitude = 0.5f, float duration = 0.5f, bool isLeft = true)
		{
			if (!(LeftController == null) && !(RightController == null))
			{
				if (isLeft)
				{
					LeftController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
				else
				{
					RightController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
			}
		}
	}
	public class Effect_SGT : SingletonPunBase.Singleton<Effect_SGT>
	{
		public Sprite[] sprites;

		public Animator anim_P1;

		public Animator anim_P2;

		public Image[] image_P1;

		public Image[] image_P2;

		public void Play(bool isPlayer1, int num)
		{
			if (isPlayer1)
			{
				if (num == 0 || num == 10)
				{
					image_P1[0].sprite = sprites[num];
					anim_P1.SetTrigger("String");
				}
				else
				{
					image_P1[1].sprite = sprites[num];
					anim_P1.SetTrigger("Number");
				}
			}
			else if (num == 0 || num == 10)
			{
				image_P2[0].sprite = sprites[num];
				anim_P2.SetTrigger("String");
			}
			else
			{
				image_P2[1].sprite = sprites[num];
				anim_P2.SetTrigger("Number");
			}
		}
	}
	public class Game_SGT : SingletonPunBase.Singleton<Game_SGT>
	{
		private float playTimeScale = 1.2f;

		public Material rayMaterial;

		public Material handMaterial;

		public Text[] text_FrameScoreS;

		public Text[] text_TotalScoreS;

		public Text[] text_FrameScoreM_P1;

		public Text[] text_FrameScoreM_P2;

		public Text[] text_TotalScoreM_P1;

		public Text[] text_TotalScoreM_P2;

		private bool isMasterClient;

		public GameObject singleObject;

		public GameObject multiObject;

		private List<Transform> list_BallSpawnPos = new List<Transform>();

		private List<Transform> list_PlayerMovePos = new List<Transform>();

		private Transform Rack;

		private bool isRunningSpawnBall;

		public bool isGameStart { get; set; }

		public bool isOnceStart { get; set; }

		public float time { get; set; } = 20f;


		public int strike_Cache { get; set; }

		public int strike_Combo { get; set; }

		public int strike_Whole { get; set; }

		public int score { get; set; }

		public int aiscore { get; set; }

		public int[] frameScore { get; set; }

		public int[] frameAIScore { get; set; }

		public bool isDone { get; set; }

		public bool isDone_Others { get; set; }

		public Player_CTRL player { get; set; }

		public Player_CTRL others { get; set; }

		public AIPlayer_CTRL aiPlayer_Ctrl { get; set; }

		public Transform others_LeftThrowPos { get; set; }

		public Transform others_RightThrowPos { get; set; }

		private void Start()
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomHand();
			Time.timeScale = playTimeScale;
			frameScore = new int[26];
			frameAIScore = new int[26];
			for (int i = 0; i < frameScore.Length; i++)
			{
				frameScore[i] = -1;
				frameAIScore[i] = -1;
			}
			SetBallPosition();
			SpawnPlayer();
			SpawnBall();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				StartCoroutine(DelaySpawnOtherVRIK_C());
				multiObject.SetActive(value: true);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				singleObject.SetActive(value: true);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				multiObject.SetActive(value: true);
			}
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(LeftPlayer_Mul);
			DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 1f);
			PublicGameUIManager.gameSetting.AddHandChangedEvent(StartDelayController);
		}

		private void FixedUpdate()
		{
			TimeFlowGame();
		}

		public void Goal(string type)
		{
		}

		public void NoGoal()
		{
		}

		public void StartGame()
		{
			isGameStart = true;
			score = 0;
			strike_Cache = 0;
			strike_Whole = 0;
			strike_Combo = 0;
			SingletonPunBase.Singleton<Setter_SGT>.GetInstance.ResetSetter();
			for (int i = 0; i < frameScore.Length; i++)
			{
				frameScore[i] = -1;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				Text[] array = text_FrameScoreM_P1;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				array = text_FrameScoreM_P2;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				array = text_TotalScoreM_P1;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				array = text_TotalScoreM_P2;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				time = 20f;
				DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 0.5f);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				Text[] array = text_FrameScoreS;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				array = text_TotalScoreS;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				Text[] array = text_FrameScoreM_P1;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				array = text_FrameScoreM_P2;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				array = text_TotalScoreM_P1;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				array = text_TotalScoreM_P2;
				for (int j = 0; j < array.Length; j++)
				{
					array[j].text = "";
				}
				time = 20f;
				aiPlayer_Ctrl.StartAutoThrow();
			}
			Rack.gameObject.SetActive(value: true);
		}

		public void EndGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				StartCoroutine(DelayOpenEndM());
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.DelaySerialAnimation("EndSOpen", 1.5f);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				StartCoroutine(DelayOpenEndM());
			}
			Rack.gameObject.SetActive(value: false);
			isGameStart = false;
		}

		private void TimeFlowGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (!isGameStart || player.isThrow)
				{
					return;
				}
				time -= Time.deltaTime * 1f / playTimeScale;
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.CheckTime();
				if (time <= 0f)
				{
					if (!SingletonPunBase.Singleton<Setter_SGT>.GetInstance.isSpare)
					{
						StartCoroutine(TimeOut_C());
					}
					else if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut_Cn);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut);
					}
					player.isThrow = true;
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.CheckTime(isFlow: false);
					if (PhotonNetwork.IsMasterClient)
					{
						SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(1);
					}
					else
					{
						SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(2);
					}
				}
			}
			else
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode != 2 || !isGameStart || player.isThrow)
				{
					return;
				}
				time -= Time.deltaTime * 1f / playTimeScale;
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.CheckTime();
				if (time <= 0f)
				{
					if (!SingletonPunBase.Singleton<Setter_SGT>.GetInstance.isSpare)
					{
						StartCoroutine(TimeOut_C());
					}
					else if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut_Cn);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut);
					}
					player.isThrow = true;
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.CheckTime(isFlow: false);
					SingletonPunBase.Singleton<Setter_SGT>.GetInstance.CheckScore(1);
				}
			}
		}

		private IEnumerator TimeOut_C()
		{
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut_Cn);
			}
			else
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut);
			}
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("InfoSOpen");
			yield return new WaitForSecondsRealtime(2.5f);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("InfoSClose");
		}

		private void SetBallPosition()
		{
			Rack = GameObject.Find("SpawnPos").transform;
			list_BallSpawnPos.Add(Rack.transform);
		}

		private void SpawnPlayer()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance == null)
			{
				return;
			}
			SpawnUI();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.None || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				player = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_SinglePlayer")).GetComponent<Player_CTRL>();
				player.transform.position = new Vector3(-0.25f, 0f, 4f);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
				{
					aiPlayer_Ctrl = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_AIPlayer")).GetComponent<AIPlayer_CTRL>();
					aiPlayer_Ctrl.transform.position = new Vector3(1.86f, 0f, 4f);
				}
			}
			else
			{
				player = PhotonNetwork.Instantiate("BL_MultiPlayer", Vector3.zero, Quaternion.identity, 0).GetComponent<Player_CTRL>();
				player.gameObject.name = "Player";
				if (PhotonNetwork.IsMasterClient)
				{
					player.transform.position = new Vector3(-0.25f, 0f, 4f);
				}
				else
				{
					player.transform.position = new Vector3(1.86f, 0f, 4f);
				}
			}
			SetPlayerXR();
		}

		private void SpawnUI()
		{
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_InGameUI"));
		}

		private void CreateBall()
		{
			GameObject obj = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_BALL"), list_BallSpawnPos[list_BallSpawnPos.Count - 1].transform);
			int num = UnityEngine.Random.Range(0, 360);
			Quaternion localRotation = Quaternion.Euler(num, num, num);
			obj.GetComponent<Ball_CTRL>().isMine = true;
			obj.transform.localRotation = localRotation;
		}

		public void SpawnBall()
		{
			if (!isRunningSpawnBall)
			{
				StartCoroutine(DelaySpawnBall_C(2f));
			}
		}

		private IEnumerator DelayOpenEndM()
		{
			while (text_TotalScoreM_P1[9].text == "" || text_TotalScoreM_P2[9].text == "")
			{
				yield return null;
			}
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.DelaySerialAnimation("EndMOpen", 1.5f);
		}

		private IEnumerator DelaySpawnBall_C(float time)
		{
			isRunningSpawnBall = true;
			while (list_BallSpawnPos[list_BallSpawnPos.Count - 1].transform.childCount < 4)
			{
				yield return YieldInstructionCache.WaitForSeconds(time);
				CreateBall();
			}
			isRunningSpawnBall = false;
		}

		private IEnumerator DelaySpawnOtherVRIK_C()
		{
			while (GameObject.Find("BL_MultiPlayer(Clone)") == null)
			{
				yield return null;
			}
			others = GameObject.Find("BL_MultiPlayer(Clone)").GetComponent<Player_CTRL>();
			others.name = "Others";
			VRIK component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("VRIK"), others.transform.position, Quaternion.identity).GetComponent<VRIK>();
			SkinnedMeshRenderer component2 = others.LeftHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>();
			component2.material = handMaterial;
			others.RightHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>().material = handMaterial;
			others.LeftHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			others.RightHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			others_LeftThrowPos = component.transform.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Spine2/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/BALL").transform;
			others_RightThrowPos = component.transform.Find("Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Spine2/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/BALL").transform;
			component.solver.spine.headTarget = others.Head.Find("IK1");
			component.solver.spine.pelvisTarget = others.transform.Find("Pelvis");
			component.solver.leftArm.target = others.LeftHand.Find("IK");
			component.solver.rightArm.target = others.RightHand.Find("IK");
			CustomModelSettingCtrl component3 = component.GetComponent<CustomModelSettingCtrl>();
			component3.enabled = true;
			if (PhotonNetwork.IsMasterClient)
			{
				component3.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id, CustomModelViewState.HalfCut2, component2);
			}
			else
			{
				component3.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id, CustomModelViewState.HalfCut2, component2);
			}
			isMasterClient = PhotonNetwork.IsMasterClient;
		}

		private void SetPlayerXR()
		{
			player.Revision.SetActive(value: true);
			GameObject gameObject = player.transform.Find("Head").gameObject;
			GameObject gameObject2 = player.transform.Find("LeftHand").gameObject;
			GameObject gameObject3 = player.transform.Find("RightHand").gameObject;
			XRRig xRRig = player.gameObject.AddComponent<XRRig>();
			xRRig.cameraGameObject = gameObject;
			xRRig.TrackingOriginMode = TrackingOriginModeFlags.Floor;
			gameObject.transform.localPosition = new Vector3(0f, 1.1f, 0f);
			gameObject.AddComponent<Camera>().nearClipPlane = 0.01f;
			gameObject.AddComponent<AudioListener>();
			gameObject.AddComponent<UniversalAdditionalCameraData>();
			gameObject.AddComponent<UnityEngine.SpatialTracking.TrackedPoseDriver>();
			UnityEngine.XR.Interaction.Toolkit.XRController xRController = gameObject2.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController.controllerNode = XRNode.LeftHand;
			xRController.selectUsage = InputHelpers.Button.Trigger;
			gameObject2.AddComponent<XRRayInteractor>();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.controllerType == GameData_DDOL.ControllerType.Oculus)
			{
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(-0.04256378f, -0.007287227f, 0.04351463f);
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(10f, -1.929f, 0.406f));
			}
			else
			{
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(-0.04719797f, -0.03611124f, -0.03386807f);
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(41.459f, -14.14f, -16.107f));
			}
			gameObject2.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
			gameObject2.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual = gameObject2.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual.lineWidth = 0.015f;
			xRInteractorLineVisual.lineLength = 1.5f;
			xRInteractorLineVisual.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			UnityEngine.XR.Interaction.Toolkit.XRController xRController2 = gameObject3.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController2.controllerNode = XRNode.RightHand;
			xRController2.selectUsage = InputHelpers.Button.Trigger;
			gameObject3.AddComponent<XRRayInteractor>();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.controllerType == GameData_DDOL.ControllerType.Oculus)
			{
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(0.04256378f, -0.007287227f, 0.04351463f);
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(10f, 1.929f, -0.406f));
			}
			else
			{
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(0.04719797f, -0.03611124f, -0.03386807f);
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(41.459f, 14.14f, 16.107f));
			}
			gameObject3.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
			gameObject3.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual2 = gameObject3.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual2.lineWidth = 0.015f;
			xRInteractorLineVisual2.lineLength = 1.5f;
			xRInteractorLineVisual2.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual2.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position = player.transform.position + player.transform.forward * 2f;
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.LookAt(player.transform);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position += player.transform.up * 1.3f;
		}

		public void StartDelayController(bool isRight)
		{
			StartCoroutine(DelayControllerOn_C(isRight, 30, 1f));
		}

		public void DelayController(bool isRight, int value, float time)
		{
			StartCoroutine(DelayControllerOn_C(isRight, value, time));
		}

		private IEnumerator DelayControllerOn_C(bool isRight, int value, float time)
		{
			yield return YieldInstructionCache.WaitForSeconds(time);
			if (isRight)
			{
				player.LeftHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
				player.RightHand.GetComponent<XRRayInteractor>().maxRaycastDistance = value;
			}
			else
			{
				player.LeftHand.GetComponent<XRRayInteractor>().maxRaycastDistance = value;
				player.RightHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
			}
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			isGameStart = false;
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}

		public void LeftPlayer_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				isGameStart = false;
				string nickName = PhotonNetwork.LocalPlayer.NickName;
				int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
				PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
			}
		}
	}
	public class Physics_SGT : SingletonBase.Singleton<Physics_SGT>
	{
		private GameObject BL_BALL;

		public Vector3 BL_BALL_ArrivalPos;

		public float BL_BALL_ThrowTime;

		private GameObject ball;

		private void Start()
		{
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ThowBall_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(CreateBall_Multi);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					BL_BALL_ArrivalPos = new Vector3(0.9f, 0f, 23.5f);
				}
				else
				{
					BL_BALL_ArrivalPos = new Vector3(3f, 0f, 23.5f);
				}
			}
			else
			{
				BL_BALL_ArrivalPos = new Vector3(0.9f, 0f, 23.5f);
			}
			BL_BALL_ThrowTime = 3f;
		}

		private void Update()
		{
		}

		public void CreateBall(Transform parent)
		{
			BL_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_BALL"), parent);
			BL_BALL.transform.GetComponent<Rigidbody>().useGravity = false;
			if (SingletonPunBase.Singleton<UI_SGT>.GetInstance.anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
			{
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.ClickButton("Start");
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<string> data = new LumpsData<string>
				{
					lumps = parent.gameObject.name
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(CreateBall_Multi, data, RpcTarget.Others);
			}
		}

		public void ThrowBall()
		{
			if (!(BL_BALL == null))
			{
				Rigidbody component = BL_BALL.GetComponent<Rigidbody>();
				BL_BALL.GetComponent<Ball_CTRL>().isMine = true;
				component.transform.SetParent(null);
				component.useGravity = true;
				component.isKinematic = false;
				Vector3 vector = new Vector3(UnityEngine.Random.Range(-0.3f, 0.3f), 0f, 0f);
				component.velocity = RootPhysics.GetVelocity(component.position, BL_BALL_ArrivalPos + vector, BL_BALL_ThrowTime, isGravity: false);
				component.angularVelocity = new Vector3(0f, 10f, 10f);
				component.drag = 0.05f;
				BL_BALL = null;
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					BallData data = new BallData
					{
						position = component.transform.position,
						velocity = component.velocity,
						angularVelocity = component.angularVelocity,
						photonTime = PhotonNetwork.Time
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ThowBall_Multi, data, RpcTarget.Others);
				}
			}
		}

		public void CreateBall_Multi(SerializableClass packet)
		{
			string lumps = (packet as LumpsData<string>).lumps;
			if (lumps == "Head")
			{
				ball = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BL_BALL"), GameObject.Find("Others/Head").transform);
			}
			ball.GetComponent<Rigidbody>().useGravity = false;
		}

		public void ThowBall_Multi(SerializableClass packet)
		{
			if (packet is BallData && !(ball == null))
			{
				Rigidbody component = ball.GetComponent<Rigidbody>();
				ball.GetComponent<Ball_CTRL>().isMine = false;
				ball.GetComponent<Ball_CTRL>().isThrow = true;
				ball.transform.position = (packet as BallData).position;
				component.position = (packet as BallData).position;
				component.transform.SetParent(null);
				component.useGravity = true;
				component.isKinematic = false;
				component.angularVelocity = (packet as BallData).angularVelocity;
				component.velocity = (packet as BallData).velocity;
				component.drag = 0.05f;
				component.angularDrag = 0f;
				ball = null;
			}
		}
	}
	public class Setter_SGT : SingletonPunBase.Singleton<Setter_SGT>
	{
		public Transform[] pins_P1;

		public Transform[] pins_P2;

		public Animator anim_P1;

		public Animator anim_P2;

		private Vector3[] pins_BasePosition_P1;

		private Quaternion[] pins_BaseRotation_P1;

		private Vector3[] pins_BasePosition_P2;

		private Quaternion[] pins_BaseRotation_P2;

		private bool isCheckingScore;

		private bool isAICheckingScore;

		private bool isExplore;

		private bool isFrame10;

		private int frameCount;

		private int gameCount;

		private bool isAIFrame10;

		private int aiframeCount;

		private int aigameCount;

		public bool isSpare { get; set; }

		public bool isAISpare { get; set; }

		public int beforeScore { get; set; }

		public int score { get; set; }

		public int beforeAIScore { get; set; }

		public int aiscore { get; set; }

		private void Start()
		{
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(FrameScoreSerial_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(TotalScoreSerial_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(AnimSerial_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(PinSerial_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(RoundSerial_Multi);
			pins_BasePosition_P1 = new Vector3[pins_P1.Length];
			pins_BaseRotation_P1 = new Quaternion[pins_P1.Length];
			pins_BasePosition_P2 = new Vector3[pins_P2.Length];
			pins_BaseRotation_P2 = new Quaternion[pins_P2.Length];
			for (int i = 0; i < pins_P1.Length; i++)
			{
				pins_BasePosition_P1[i] = pins_P1[i].position;
				pins_BaseRotation_P1[i] = pins_P1[i].rotation;
			}
			for (int j = 0; j < pins_P2.Length; j++)
			{
				pins_BasePosition_P2[j] = pins_P2[j].position;
				pins_BaseRotation_P2[j] = pins_P2[j].rotation;
			}
		}

		public void PlayAnim(int Num, bool isSpare)
		{
			if (Num == 1)
			{
				anim_P1.SetTrigger("Play");
				StartCoroutine(ResetPins_C(pins_P1, pins_BasePosition_P1, pins_BaseRotation_P1, isSpare));
			}
			else
			{
				anim_P2.SetTrigger("Play");
				StartCoroutine(ResetPins_C(pins_P2, pins_BasePosition_P2, pins_BaseRotation_P2, isSpare));
			}
		}

		private IEnumerator ResetPins_C(Transform[] trans, Vector3[] pos, Quaternion[] rot, bool isSpare)
		{
			yield return new WaitForSecondsRealtime(Time.deltaTime);
			if (trans == pins_P1)
			{
				while (anim_P1.GetCurrentAnimatorStateInfo(0).IsName("Play"))
				{
					yield return null;
				}
			}
			else
			{
				while (anim_P2.GetCurrentAnimatorStateInfo(0).IsName("Play"))
				{
					yield return null;
				}
			}
			ResetPins(trans, pos, rot, isSpare);
		}

		public void ResetPins(Transform[] trans, Vector3[] pos, Quaternion[] rot, bool isSpare)
		{
			for (int i = 0; i < trans.Length; i++)
			{
				Rigidbody component = trans[i].GetComponent<Rigidbody>();
				component.velocity = Vector3.zero;
				component.angularVelocity = Vector3.zero;
				trans[i].position = pos[i];
				trans[i].rotation = rot[i];
				if (!isSpare)
				{
					trans[i].gameObject.SetActive(value: true);
				}
			}
			isExplore = false;
		}

		public void CheckScore(int playerNum)
		{
			if (!isCheckingScore)
			{
				switch (playerNum)
				{
				case 1:
					StartCoroutine(CheckScore_C(playerNum, pins_P1));
					break;
				case 2:
					StartCoroutine(CheckScore_C(playerNum, pins_P2));
					break;
				}
			}
		}

		private IEnumerator CheckScore_C(int playerNum, Transform[] pins)
		{
			yield return YieldInstructionCache.WaitForSeconds(1f);
			isCheckingScore = true;
			score = 0;
			for (int i = 0; i < pins.Length; i++)
			{
				Rigidbody rigid = pins[i].GetComponent<Rigidbody>();
				int count = 0;
				while (rigid.velocity.magnitude != 0f && pins[i].gameObject.activeSelf)
				{
					count++;
					if (count % 30 == 1)
					{
						PinSerial(playerNum, pins);
					}
					if (rigid.velocity.magnitude < 0.1f)
					{
						rigid.velocity = Vector3.zero;
						i = 0;
					}
					else
					{
						yield return null;
					}
				}
				if (pins[i].up.y < 0.98f && pins[i].gameObject.activeSelf)
				{
					pins[i].gameObject.SetActive(value: false);
					score++;
				}
			}
			PinSerial(playerNum, pins);
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.frameScore[gameCount] = score;
			if (score == 10)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Whole++;
			}
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			if (!isSpare)
			{
				int num = score;
				if (num == 10)
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						LumpsData<string, int, int> data = new LumpsData<string, int, int>
						{
							lumps1 = "X",
							lumps2 = gameCount,
							lumps3 = playerNum
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(FrameScoreSerial_Multi, data, RpcTarget.All);
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreS[gameCount].text = "X";
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P1[gameCount].text = "X";
					}
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Cache++;
					if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Combo < SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Cache)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Combo = SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Cache;
					}
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[score]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[score]);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
					{
						if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Cache == 3)
						{
							SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach13", 1);
						}
						if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Cache == 5)
						{
							SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach14", 1);
						}
					}
					if (gameCount < 18)
					{
						DelayScoreCheck(3, frameCount, gameCount, playerNum);
						gameCount += 2;
					}
					else if (gameCount == 18 && !isFrame10)
					{
						DelayScoreCheck(3, frameCount, gameCount, playerNum);
						gameCount++;
						isFrame10 = true;
					}
					else if (gameCount == 19 && !isFrame10)
					{
						DelayScoreCheck(2, frameCount, gameCount, playerNum);
						gameCount++;
						isFrame10 = true;
					}
					else
					{
						gameCount++;
					}
				}
				else
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						if (score != 0)
						{
							LumpsData<string, int, int> data2 = new LumpsData<string, int, int>
							{
								lumps1 = score.ToString(),
								lumps2 = gameCount,
								lumps3 = playerNum
							};
							SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(FrameScoreSerial_Multi, data2, RpcTarget.All);
						}
						else
						{
							LumpsData<string, int, int> data3 = new LumpsData<string, int, int>
							{
								lumps1 = "-",
								lumps2 = gameCount,
								lumps3 = playerNum
							};
							SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(FrameScoreSerial_Multi, data3, RpcTarget.All);
						}
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
					{
						if (score != 0)
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreS[gameCount].text = score.ToString();
						}
						else
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreS[gameCount].text = "-";
						}
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						if (score != 0)
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P1[gameCount].text = score.ToString();
						}
						else
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P1[gameCount].text = "-";
						}
					}
					isSpare = true;
					if (score == 0)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
					}
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[score]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[score]);
					}
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Cache = 0;
					gameCount++;
					beforeScore = score;
				}
			}
			else
			{
				if (score == 0)
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						LumpsData<string, int, int> data4 = new LumpsData<string, int, int>
						{
							lumps1 = "-",
							lumps2 = gameCount,
							lumps3 = playerNum
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(FrameScoreSerial_Multi, data4, RpcTarget.All);
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreS[gameCount].text = "-";
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P1[gameCount].text = "-";
					}
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[score]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[score]);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
					DelayScoreCheck(2, frameCount, gameCount - 1, playerNum);
				}
				else if (score + beforeScore == 10)
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						LumpsData<string, int, int> data5 = new LumpsData<string, int, int>
						{
							lumps1 = "/",
							lumps2 = gameCount,
							lumps3 = playerNum
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(FrameScoreSerial_Multi, data5, RpcTarget.All);
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreS[gameCount].text = "/";
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P1[gameCount].text = "/";
					}
					DelayScoreCheck(3, frameCount, gameCount - 1, playerNum);
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Spare_Cn);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Spare);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
				}
				else
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						LumpsData<string, int, int> data6 = new LumpsData<string, int, int>
						{
							lumps1 = score.ToString(),
							lumps2 = gameCount,
							lumps3 = playerNum
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(FrameScoreSerial_Multi, data6, RpcTarget.All);
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreS[gameCount].text = score.ToString();
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P1[gameCount].text = score.ToString();
					}
					DelayScoreCheck(2, frameCount, gameCount - 1, playerNum);
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[score]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[score]);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
				}
				gameCount++;
				isSpare = false;
			}
			frameCount = gameCount / 2;
			StartCoroutine(DelaySetterSound_C());
			isCheckingScore = false;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<int, int, bool> data7 = new LumpsData<int, int, bool>
				{
					lumps1 = playerNum,
					lumps2 = score,
					lumps3 = isSpare
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(AnimSerial_Multi, data7, RpcTarget.All);
				if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.time = 20f;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow = false;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 0.5f);
				}
			}
			else
			{
				PlayAnim(1, isSpare);
				SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(isPlayer1: true, score);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow = false;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 0.5f);
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2 && !SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.time = 20f;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow = false;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 0.5f);
				}
			}
		}

		private void DelayScoreCheck(int delayCount, int frameCount, int gameCount, int playerNum)
		{
			StartCoroutine(DelayScoreCheck_C(delayCount, frameCount, gameCount, playerNum));
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone = true;
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(RoundSerial_Multi, data, RpcTarget.Others);
				if (frameCount < 9)
				{
					StartCoroutine(DelaySerialRound_C(frameCount));
				}
				else
				{
					SerialRound(frameCount);
				}
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone = true;
				if (frameCount < 9)
				{
					StartCoroutine(DelaySerialRound_C(frameCount));
				}
				else
				{
					SerialRound(frameCount);
				}
			}
		}

		private IEnumerator DelayScoreCheck_C(int delayCount, int frameCount, int gameCount, int playerNum)
		{
			bool isCheck = false;
			while (!isCheck)
			{
				int score = 0;
				int num = 0;
				for (int i = 0; i < 5; i++)
				{
					if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.frameScore[gameCount + i] == -1)
					{
						continue;
					}
					score += SingletonPunBase.Singleton<Game_SGT>.GetInstance.frameScore[gameCount + i];
					num++;
					if (frameCount > 9)
					{
						frameCount = 9;
					}
					if (num >= delayCount)
					{
						yield return YieldInstructionCache.WaitForSeconds(Time.deltaTime * (float)gameCount);
						isCheck = true;
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.score += score;
						if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
						{
							LumpsData<string, int, int> data = new LumpsData<string, int, int>
							{
								lumps1 = SingletonPunBase.Singleton<Game_SGT>.GetInstance.score.ToString(),
								lumps2 = frameCount,
								lumps3 = playerNum
							};
							SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(TotalScoreSerial_Multi, data, RpcTarget.All);
						}
						else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreS[frameCount].text = SingletonPunBase.Singleton<Game_SGT>.GetInstance.score.ToString();
						}
						else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P1[frameCount].text = SingletonPunBase.Singleton<Game_SGT>.GetInstance.score.ToString();
						}
						if (frameCount == 9)
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.EndGame();
						}
						break;
					}
				}
				yield return null;
			}
		}

		public void AICheckScore()
		{
			if (!isAICheckingScore)
			{
				StartCoroutine(AICheckScore_C(2, pins_P2));
			}
		}

		private IEnumerator AICheckScore_C(int playerNum, Transform[] pins)
		{
			yield return YieldInstructionCache.WaitForSeconds(1f);
			isAICheckingScore = true;
			aiscore = 0;
			for (int i = 0; i < pins.Length; i++)
			{
				Rigidbody rigid = pins[i].GetComponent<Rigidbody>();
				int count = 0;
				while (rigid.velocity.magnitude != 0f && pins[i].gameObject.activeSelf)
				{
					count++;
					if (count % 30 == 1)
					{
						PinSerial(playerNum, pins);
					}
					if (rigid.velocity.magnitude < 0.1f)
					{
						rigid.velocity = Vector3.zero;
						i = 0;
					}
					else
					{
						yield return null;
					}
				}
				if (pins[i].up.y < 0.98f && pins[i].gameObject.activeSelf)
				{
					pins[i].gameObject.SetActive(value: false);
					aiscore++;
				}
			}
			PinSerial(playerNum, pins);
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.frameAIScore[aigameCount] = aiscore;
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			if (!isAISpare)
			{
				int num = aiscore;
				if (num == 10)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P2[aigameCount].text = "X";
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[aiscore]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[aiscore]);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
					if (aigameCount < 18)
					{
						DelayAIScoreCheck(3, aiframeCount, aigameCount, playerNum);
						aigameCount += 2;
					}
					else if (aigameCount == 18 && !isAIFrame10)
					{
						DelayAIScoreCheck(3, aiframeCount, aigameCount, playerNum);
						aigameCount++;
						isAIFrame10 = true;
					}
					else if (aigameCount == 19 && !isAIFrame10)
					{
						DelayAIScoreCheck(2, aiframeCount, aigameCount, playerNum);
						aigameCount++;
						isAIFrame10 = true;
					}
					else
					{
						aigameCount++;
					}
				}
				else
				{
					if (aiscore != 0)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P2[aigameCount].text = aiscore.ToString();
					}
					else
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P2[aigameCount].text = "-";
					}
					isAISpare = true;
					if (aiscore == 0)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
					}
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[aiscore]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[aiscore]);
					}
					aigameCount++;
					beforeAIScore = aiscore;
				}
			}
			else
			{
				if (aiscore == 0)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P2[aigameCount].text = "-";
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[aiscore]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[aiscore]);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
					DelayAIScoreCheck(2, aiframeCount, aigameCount - 1, playerNum);
				}
				else if (aiscore + beforeAIScore == 10)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P2[aigameCount].text = "/";
					DelayAIScoreCheck(3, aiframeCount, aigameCount - 1, playerNum);
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Spare_Cn);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Spare);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P2[aigameCount].text = aiscore.ToString();
					DelayAIScoreCheck(2, aiframeCount, aigameCount - 1, playerNum);
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[aiscore]);
					}
					else
					{
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[aiscore]);
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
				}
				aigameCount++;
				isAISpare = false;
			}
			aiframeCount = aigameCount / 2;
			StartCoroutine(DelaySetterSound_C());
			isAICheckingScore = false;
			PlayAnim(2, isAISpare);
			SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(isPlayer1: false, aiscore);
		}

		private void DelayAIScoreCheck(int delayCount, int frameCount, int gameCount, int playerNum)
		{
			StartCoroutine(DelayAIScoreCheck_C(delayCount, frameCount, gameCount, playerNum));
			if (frameCount < 9)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone_Others = true;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl.StopAutoThrow();
			}
		}

		private IEnumerator DelayAIScoreCheck_C(int delayCount, int frameCount, int gameCount, int playerNum)
		{
			bool isCheck = false;
			while (!isCheck)
			{
				int score = 0;
				int num = 0;
				for (int i = 0; i < 5; i++)
				{
					if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.frameAIScore[gameCount + i] == -1)
					{
						continue;
					}
					score += SingletonPunBase.Singleton<Game_SGT>.GetInstance.frameAIScore[gameCount + i];
					num++;
					if (frameCount > 9)
					{
						frameCount = 9;
					}
					if (num >= delayCount)
					{
						yield return YieldInstructionCache.WaitForSeconds(Time.deltaTime * (float)gameCount);
						isCheck = true;
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiscore += score;
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P2[frameCount].text = SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiscore.ToString();
						if (frameCount == 9)
						{
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl.StopAutoThrow();
						}
						break;
					}
				}
				yield return null;
			}
		}

		public void PinExplore()
		{
			if (!isExplore)
			{
				for (int i = 0; i < pins_P1.Length; i++)
				{
					pins_P1[i].GetComponent<Rigidbody>().AddExplosionForce(2f, new Vector3(-2.5f, 0f, 23.85f), 5f, 2f, ForceMode.Impulse);
				}
			}
		}

		public void ResetSetter()
		{
			isCheckingScore = false;
			isSpare = false;
			isExplore = false;
			isFrame10 = false;
			gameCount = 0;
			frameCount = gameCount / 2;
			beforeScore = 0;
			score = 0;
		}

		private IEnumerator DelaySerialRound_C(int frameCount)
		{
			while (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone || !SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone_Others)
			{
				yield return null;
			}
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.DelaySerialRound(frameCount + 2, isStart: false);
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone = false;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone_Others = false;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.time = 20f;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow = false;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 0.5f);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl.StartAutoThrow();
			}
		}

		private void SerialRound(int frameCount)
		{
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone = false;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone_Others = false;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.time = 20f;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isThrow = false;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 0.5f);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl.StartAutoThrow();
			}
		}

		private IEnumerator DelaySetterSound_C()
		{
			yield return YieldInstructionCache.WaitForSeconds(1.5f);
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Setter);
		}

		public void PinSerial(int playerNum, Transform[] pins)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				PinData pinData = new PinData();
				pinData.playerNum = playerNum;
				for (int i = 0; i < pins.Length; i++)
				{
					Rigidbody component = pins[i].GetComponent<Rigidbody>();
					pinData.pos[i] = pins[i].position;
					pinData.rot[i] = pins[i].rotation;
					pinData.velocity[i] = component.velocity;
					pinData.angularVelocity[i] = component.angularVelocity;
					pinData.active[i] = pins[i].gameObject.activeSelf;
				}
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(PinSerial_Multi, pinData, RpcTarget.Others);
			}
		}

		public void PinSerial_Multi(SerializableClass packet)
		{
			if (!(packet is PinData))
			{
				return;
			}
			if ((packet as PinData).playerNum == 1)
			{
				for (int i = 0; i < 10; i++)
				{
					Rigidbody component = pins_P1[i].GetComponent<Rigidbody>();
					pins_P1[i].position = (packet as PinData).pos[i];
					pins_P1[i].rotation = (packet as PinData).rot[i];
					component.velocity = (packet as PinData).velocity[i];
					component.angularVelocity = (packet as PinData).angularVelocity[i];
					pins_P1[i].gameObject.SetActive((packet as PinData).active[i]);
				}
			}
			else
			{
				for (int j = 0; j < 10; j++)
				{
					Rigidbody component2 = pins_P2[j].GetComponent<Rigidbody>();
					pins_P2[j].position = (packet as PinData).pos[j];
					pins_P2[j].rotation = (packet as PinData).rot[j];
					component2.velocity = (packet as PinData).velocity[j];
					component2.angularVelocity = (packet as PinData).angularVelocity[j];
					pins_P2[j].gameObject.SetActive((packet as PinData).active[j]);
				}
			}
		}

		public void AnimSerial_Multi(SerializableClass packet)
		{
			if (!(packet is LumpsData<int, int, bool>))
			{
				return;
			}
			if ((packet as LumpsData<int, int, bool>).lumps1 == 1)
			{
				PlayAnim(1, (packet as LumpsData<int, int, bool>).lumps3);
				SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(isPlayer1: true, (packet as LumpsData<int, int, bool>).lumps2);
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[(packet as LumpsData<int, int, bool>).lumps2]);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[(packet as LumpsData<int, int, bool>).lumps2]);
				}
			}
			else
			{
				PlayAnim(2, (packet as LumpsData<int, int, bool>).lumps3);
				SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(isPlayer1: false, (packet as LumpsData<int, int, bool>).lumps2);
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number_Cn[(packet as LumpsData<int, int, bool>).lumps2]);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Number[(packet as LumpsData<int, int, bool>).lumps2]);
				}
			}
		}

		public void FrameScoreSerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<string, int, int>)
			{
				if ((packet as LumpsData<string, int, int>).lumps3 == 1)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P1[(packet as LumpsData<string, int, int>).lumps2].text = (packet as LumpsData<string, int, int>).lumps1;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_FrameScoreM_P2[(packet as LumpsData<string, int, int>).lumps2].text = (packet as LumpsData<string, int, int>).lumps1;
				}
			}
		}

		public void TotalScoreSerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<string, int, int>)
			{
				if ((packet as LumpsData<string, int, int>).lumps3 == 1)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P1[(packet as LumpsData<string, int, int>).lumps2].text = (packet as LumpsData<string, int, int>).lumps1;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P2[(packet as LumpsData<string, int, int>).lumps2].text = (packet as LumpsData<string, int, int>).lumps1;
				}
			}
		}

		public void RoundSerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDone_Others = (packet as LumpsData<bool>).lumps;
			}
		}
	}
	public class Sound_SGT : SingletonPunBase.Singleton<Sound_SGT>
	{
		private AudioSource audioSource;

		private AudioSource audioSource2;

		public AudioClip clip_ButtonFocus;

		public AudioClip clip_ButtonPress;

		public AudioClip clip_StartBuzzer;

		public AudioClip clip_EndBuzzer;

		public AudioClip clip_TimeOut;

		public AudioClip clip_Setter;

		public AudioClip clip_Gutter;

		public AudioClip clip_Faul;

		public AudioClip clip_Spare;

		public AudioClip[] clip_Number;

		public AudioClip[] clip_Cheer;

		public AudioClip[] clip_Boos;

		public AudioClip clip_TimeOut_Cn;

		public AudioClip clip_Gutter_Cn;

		public AudioClip clip_Faul_Cn;

		public AudioClip clip_Spare_Cn;

		public AudioClip[] clip_Number_Cn;

		private void Start()
		{
			audioSource = GetComponentInChildren<AudioSource>();
			audioSource2 = GetComponent<AudioSource>();
		}

		public void PlaySound(AudioClip clip)
		{
			audioSource.pitch = 1f;
			audioSource.PlayOneShot(clip);
		}

		public void PlaySound(AudioClip[] clip)
		{
			audioSource2.PlayOneShot(clip[UnityEngine.Random.Range(0, clip.Length)]);
		}
	}
	public class UI_SGT : SingletonPunBase.Singleton<UI_SGT>
	{
		public enum UI_State
		{
			None,
			Start,
			EndS,
			EndM,
			Exit
		}

		private Canvas canvas;

		[Header("InfoS")]
		public Text text_InfoSTime;

		public Text text_InfoSScore;

		[Header("EndS")]
		public Text text_EndSScore;

		public Text text_EndSWholeStrike;

		public Text text_EndSComboStrike;

		public Text text_EndSMaxScore;

		[Header("EndM")]
		public Text text_EndMName_P1;

		public Text text_EndMName_P2;

		public Text text_EndMScore_P1;

		public Text text_EndMScore_P2;

		public Text text_Result;

		[Header("Button")]
		public GameObject RePlayButton;

		[Header("InfoM")]
		public GameObject info_M;

		public Text text_InfoMTime;

		[Header("InfoRound")]
		public GameObject info_Round;

		public Text text_Round;

		[SerializeField]
		public TMP_FontAsset font_Us;

		public TMP_FontAsset font_Cn;

		public TextMeshPro timeOut;

		public TextMesh howToPlay;

		public Text frame;

		private bool isReadyStart;

		private bool isReady;

		private bool isReady_Others;

		public bool isPublicUI;

		public UI_State ui_State { get; set; }

		public Animator anim { get; set; }

		protected override void Awake()
		{
			base.Awake();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ReadySerial_Multi);
		}

		private void Start()
		{
			ui_State = UI_State.None;
			canvas = GetComponent<Canvas>();
			anim = GetComponent<Animator>();
			StartGame();
			StartCoroutine(ConnectUICamera_C());
			PublicGameUIManager.GetInstance.AddMenuEvent(CheckPublicUI);
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0154", timeOut);
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0040", howToPlay);
			SingletonBase.Singleton<StaticLocalizationCtrl>.GetInstance.AddData("0171", frame);
			Custom(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
		}

		private void FixedUpdate()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && !isReadyStart && isReady && isReady_Others)
			{
				isReadyStart = true;
				info_M.SetActive(value: true);
				DelaySerialRound(1, isStart: true);
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
			}
		}

		private void CheckPublicUI(bool obj)
		{
			StartCoroutine(DelayCheckPublicUI_C(obj));
		}

		private IEnumerator DelayCheckPublicUI_C(bool obj)
		{
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			isPublicUI = obj;
		}

		public void AnimationPlay(string str)
		{
			switch (str)
			{
			case "StartOpen":
				ui_State = UI_State.Start;
				break;
			case "EndSOpen":
				ui_State = UI_State.EndS;
				EndSResult();
				return;
			case "EndMOpen":
				ui_State = UI_State.EndM;
				EndMResult();
				return;
			case "ExitOpen":
				ui_State = UI_State.Exit;
				break;
			default:
				ui_State = UI_State.None;
				break;
			}
			anim.SetTrigger(str);
		}

		public void ClickButton(string str)
		{
			switch (str)
			{
			case "Start":
				AnimationPlay("StartClose");
				break;
			case "RePlay":
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					isReady = true;
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = true
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
				}
				break;
			case "Play":
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isClickMouse1 = false;
				AnimationPlay("ExitClose");
				break;
			case "Exit":
				SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut(delegate
				{
					GotoLobby();
				});
				break;
			}
		}

		public void DelaySerialAnimation(string anim, float time)
		{
			StartCoroutine(DelaySerialAnimation_C(anim, time));
		}

		private IEnumerator DelaySerialAnimation_C(string anim, float time)
		{
			yield return YieldInstructionCache.WaitForSeconds(time);
			AnimationPlay(anim);
		}

		private IEnumerator ConnectUICamera_C()
		{
			while (canvas.worldCamera == null)
			{
				yield return YieldInstructionCache.WaitForSeconds(Time.deltaTime);
				canvas.worldCamera = Camera.main;
			}
		}

		public void CheckTime(bool isFlow = true)
		{
			if (isFlow)
			{
				int num = (int)Mathf.Floor(SingletonPunBase.Singleton<Game_SGT>.GetInstance.time);
				if (num < 0)
				{
					num = 0;
				}
				text_InfoMTime.text = num.ToString();
			}
			else
			{
				text_InfoMTime.text = "X";
			}
		}

		private void GotoLobby()
		{
			StartCoroutine(GotoLobby_C());
		}

		private IEnumerator GotoLobby_C()
		{
			yield return new WaitForSecondsRealtime(2f);
			SceneManager.LoadScene(0);
		}

		private void StartGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				isReady = true;
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = true
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
			}
			else
			{
				info_M.SetActive(value: true);
			}
			AnimationPlay("StartOpen");
		}

		private void EndSResult()
		{
			int num = int.Parse(SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreS[9].text);
			int clearLevelData = 1;
			if (num >= 150 && num < 200)
			{
				clearLevelData = 3;
			}
			else if (num >= 200 && num < 250)
			{
				clearLevelData = 4;
			}
			else if (num >= 250)
			{
				clearLevelData = 5;
			}
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData(clearLevelData);
			PublicGameUIManager.leaderBoard.MyScoreUpdate(num);
			PublicGameUIManager.GetInstance.OpenResultBoard(num.ToString(), new string[4]
			{
				GameSettingCtrl.GetLocalizationText("0043"),
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Whole + " " + GameSettingCtrl.GetLocalizationText("0045"),
				GameSettingCtrl.GetLocalizationText("0044"),
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.strike_Combo + " " + GameSettingCtrl.GetLocalizationText("0045")
			});
		}

		private void EndMResult()
		{
			isReadyStart = false;
			isReady = false;
			isReady_Others = false;
			info_M.SetActive(value: false);
			text_EndMScore_P1.text = SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P1[9].text;
			text_EndMScore_P2.text = SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P2[9].text;
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P1[9].text != "" && SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P2[9].text != "")
			{
				int num = int.Parse(SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P1[9].text);
				int num2 = int.Parse(SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P2[9].text);
				int num3 = 0;
				num3 = ((num <= num2) ? ((num < num2) ? 1 : 2) : 0);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2 && num3 == 0)
				{
					SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
				}
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P1[9].text.ToString(),
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.text_TotalScoreM_P2[9].text.ToString()
				}, num3);
			}
		}

		public void ReadySerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				isReady_Others = (packet as LumpsData<bool>).lumps;
			}
		}

		public void DelaySerialRound(int round, bool isStart)
		{
			text_Round.text = round.ToString();
			StartCoroutine(DelaySerialRound_C(isStart));
		}

		private IEnumerator DelaySerialRound_C(bool isStart)
		{
			if (isStart)
			{
				yield return YieldInstructionCache.WaitForSeconds(1.5f);
			}
			info_Round.SetActive(value: true);
			yield return YieldInstructionCache.WaitForSeconds(2.5f);
			info_Round.SetActive(value: false);
		}

		public void Custom(LanguageState language)
		{
			if (language == LanguageState.schinese)
			{
				timeOut.font = font_Cn;
			}
			else
			{
				timeOut.font = font_Us;
			}
		}
	}
}
namespace BASKETBALL
{
	public class AIPlayer_CTRL : MonoBehaviour
	{
		public Transform ThrowPos;

		public Vector3 BB_BALL_ArrivalPos;

		public float delayTime;

		public float BB_BALL_ThrowTime;

		private GameObject BB_BALL;

		private Animator anim;

		public int changePos { get; set; } = 2;


		public int changePositionCount { get; set; }

		public int comboCount { get; set; }

		public int wholeGoalCount { get; set; }

		public int wholeThrowCount { get; set; }

		public bool isAutoThrow { get; set; } = true;


		public Coroutine autoThrow { get; set; }

		private void Awake()
		{
			anim = GetComponent<Animator>();
			GetComponent<CustomModelSettingCtrl>().InitCPU(CustomModelViewState.Normal, null, 0.1f);
		}

		private void Start()
		{
		}

		private void Update()
		{
		}

		public void CreateBall()
		{
			if (BB_BALL != null)
			{
				Rigidbody component = BB_BALL.GetComponent<Rigidbody>();
				component.transform.SetParent(null);
				component.isKinematic = false;
				component.useGravity = true;
				BB_BALL = null;
			}
			BB_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_AI"), ThrowPos);
			BB_BALL.transform.localScale = Vector3.one * 0.8f;
		}

		public void ThrowBall()
		{
			if (BB_BALL == null)
			{
				return;
			}
			wholeThrowCount++;
			float num = 0f;
			switch (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level)
			{
			case 1:
				num = 0.35f;
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2 < 15)
				{
					if (wholeThrowCount % 2 == 0)
					{
						num = 0.3f;
						if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.time < 30f)
						{
							num = 0.05f;
						}
					}
				}
				else
				{
					num = 0.4f;
				}
				break;
			case 2:
				num = 0.3f;
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2 < 30)
				{
					if (wholeThrowCount % 2 == 0)
					{
						num = 0.28f;
						if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.time < 30f)
						{
							num = 0.05f;
						}
					}
				}
				else
				{
					num = 0.33f;
				}
				break;
			case 3:
				num = 0.25f;
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2 < 45)
				{
					if (wholeThrowCount % 2 == 0)
					{
						num = 0.22f;
						if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.time < 30f)
						{
							num = 0.05f;
						}
					}
				}
				else
				{
					num = 0.3f;
				}
				break;
			case 4:
				num = 0.2f;
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2 < 60)
				{
					if (wholeThrowCount % 2 == 0)
					{
						num = 0.15f;
						if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.time < 30f)
						{
							num = 0.05f;
						}
					}
				}
				else
				{
					num = 0.23f;
				}
				break;
			case 5:
				num = 0.15f;
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2 < 75)
				{
					if (wholeThrowCount % 2 == 0)
					{
						num = 0.1f;
						if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.time < 30f)
						{
							num = 0f;
						}
					}
				}
				else
				{
					num = 0.2f;
				}
				break;
			}
			Rigidbody component = BB_BALL.GetComponent<Rigidbody>();
			component.transform.SetParent(null);
			component.isKinematic = false;
			component.useGravity = true;
			component.velocity = RootPhysics.GetVelocity(component.position, BB_BALL_ArrivalPos + new Vector3(UnityEngine.Random.Range(0f - num, num), 0f, UnityEngine.Random.Range(0f - num, num)), BB_BALL_ThrowTime);
			component.angularVelocity = new Vector3(-5f, 0f, 0f);
			SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component.GetComponent<CapsuleCollider>());
			BB_BALL = null;
		}

		public void StartAutoThrow()
		{
			autoThrow = StartCoroutine(AutoThrow((float)(11 - SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level) / 2f));
		}

		public void StopAutoThrow()
		{
			StopCoroutine(autoThrow);
		}

		private IEnumerator AutoThrow(float deleyTime)
		{
			if (!isAutoThrow)
			{
				yield break;
			}
			while (true)
			{
				if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart)
				{
					yield return null;
					continue;
				}
				yield return YieldInstructionCache.WaitForSeconds(deleyTime);
				anim.SetTrigger("Throw");
			}
		}
	}
	public class Ball_CTRL : MonoBehaviour
	{
		private AudioSource audioSource;

		private Rigidbody rigid;

		private Color color;

		private float delayTimer;

		private bool isActive = true;

		private bool isBoard;

		private bool isRing;

		private bool isNet1;

		private bool isNet2;

		public ParticleSystem selectParticle;

		public Material material_Fade;

		public AudioClip[] clip_Ring;

		public AudioClip[] clip_Board;

		public AudioClip[] clip_Floor;

		public AudioClip[] clip_Net;

		public bool isMine { get; set; }

		private void Start()
		{
			audioSource = GetComponentInChildren<AudioSource>();
			rigid = GetComponent<Rigidbody>();
			color = Color.white;
			delayTimer = 0f;
		}

		private void OnEnable()
		{
			isActive = true;
			isBoard = false;
			isRing = false;
			isNet1 = false;
			isNet2 = false;
		}

		private void Update()
		{
			if (isActive)
			{
				return;
			}
			delayTimer += Time.deltaTime * 2f;
			if (delayTimer > 1f)
			{
				if (GetComponent<Renderer>().material != material_Fade)
				{
					GetComponent<Renderer>().material = material_Fade;
				}
				color.a -= 0.005f;
				GetComponent<Renderer>().material.color = color;
				if (color.a <= 0f)
				{
					base.gameObject.SetActive(value: false);
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		private void OnCollisionEnter(Collision other)
		{
			switch (other.transform.tag)
			{
			case "Ring":
				isRing = true;
				PlaySound(clip_Ring);
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.ShakeNet();
				break;
			case "Board":
				isBoard = true;
				PlaySound(clip_Board);
				break;
			case "Floor":
				PlaySound(clip_Floor);
				if (!isActive)
				{
					break;
				}
				isActive = false;
				if (!isNet1 || !isNet2)
				{
					if (isMine)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.NoGoal();
					}
					else
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.AINoGoal();
					}
				}
				break;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameEnd)
			{
				return;
			}
			string text = other.transform.tag;
			if (!(text == "Net1"))
			{
				if (!(text == "Net2"))
				{
					return;
				}
				PlaySound(clip_Net);
				isNet2 = true;
				if (!isNet1)
				{
					return;
				}
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Goal);
				if (isMine)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
					if (!isActive)
					{
						return;
					}
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						if (PhotonNetwork.IsMasterClient)
						{
							SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal_P1);
						}
						else
						{
							SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal_P2);
						}
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
					{
						SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal);
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal_P1);
					}
					if (!isRing && !isBoard)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.Goal("clear");
					}
					else if ((!isRing || isRing) && isBoard)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.Goal("bank");
					}
					else
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.Goal("nomal");
					}
					isActive = false;
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					if (PhotonNetwork.IsMasterClient)
					{
						SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal_P2);
					}
					else
					{
						SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal_P1);
					}
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
				{
					SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal_P2);
					if (!isRing && !isBoard)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.AIGoal("clear");
					}
					else if ((!isRing || isRing) && isBoard)
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.AIGoal("bank");
					}
					else
					{
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.AIGoal("nomal");
					}
					isActive = false;
				}
			}
			else if (!isNet2)
			{
				isNet1 = true;
			}
		}

		private void PlaySound(AudioClip[] clips)
		{
			if (!(rigid == null))
			{
				float num = Mathf.Clamp(rigid.velocity.magnitude, 0f, 15f);
				float volumeScale = num / 8f;
				audioSource.pitch = 1.15f - num / 50f;
				audioSource.PlayOneShot(clips[UnityEngine.Random.Range(0, clips.Length)], volumeScale);
			}
		}
	}
	public class Catch_CTRL : XRBaseInteractable
	{
		public float diffPower = 0.15f;

		private Rigidbody rigid;

		private Transform trans_Attach;

		private bool isCatch;

		private List<InputDevice> inputDevices = new List<InputDevice>();

		private bool triggerValueL;

		private bool triggerValueR;

		private void Start()
		{
			if (rigid == null)
			{
				rigid = GetComponent<Rigidbody>();
			}
		}

		private void FixedUpdate()
		{
			if (!isCatch)
			{
				return;
			}
			rigid.useGravity = true;
			rigid.velocity = Vector3.zero;
			rigid.transform.position = Vector3.Lerp(rigid.position, trans_Attach.position, 0.3f);
			rigid.angularVelocity = Vector3.zero;
			rigid.transform.rotation = trans_Attach.rotation;
			SingletonPunBase.Singleton<RootPhysics>.GetInstance.RecordLatestPosesForDrop(rigid.transform, Time.time, 0.1f);
			inputDevices.Clear();
			InputDevices.GetDevicesAtXRNode(XRNode.RightHand, inputDevices);
			foreach (InputDevice inputDevice in inputDevices)
			{
				bool value = false;
				if (inputDevice.TryGetFeatureValue(CommonUsages.triggerButton, out value) && value != triggerValueR)
				{
					triggerValueR = value;
					UnityEngine.Debug.Log("TriggerR - " + triggerValueR);
					if (!triggerValueR)
					{
						isCatch = false;
						trans_Attach = null;
						Detach();
					}
				}
			}
			inputDevices.Clear();
			InputDevices.GetDevicesAtXRNode(XRNode.LeftHand, inputDevices);
			foreach (InputDevice inputDevice2 in inputDevices)
			{
				bool value2 = false;
				if (inputDevice2.TryGetFeatureValue(CommonUsages.triggerButton, out value2) && value2 != triggerValueL)
				{
					triggerValueL = value2;
					UnityEngine.Debug.Log("TriggerL - " + triggerValueL);
					if (!triggerValueL)
					{
						isCatch = false;
						trans_Attach = null;
						Detach();
					}
				}
			}
		}

		protected override void OnSelectEnter(XRBaseInteractor interactor)
		{
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart)
			{
				isCatch = true;
				rigid.useGravity = false;
				rigid.drag = 0.05f;
				rigid.angularDrag = 0f;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
				trans_Attach = interactor.transform.Find("ThrowPos").transform;
			}
		}

		private void Detach()
		{
			RootPhysics.Pose poseQueue = SingletonPunBase.Singleton<RootPhysics>.GetInstance.GetPoseQueue();
			float duration = Time.time - poseQueue.time;
			float num = 2.3f;
			RootPhysics.SetRigidbodyVelocity(rigid, poseQueue.pose.pos, rigid.position, duration);
			RootPhysics.SetRigidbodyAngularVelocity(rigid, poseQueue.pose.rot, rigid.rotation, duration);
			rigid.velocity *= num;
			rigid.isKinematic = false;
			rigid.GetComponent<Ball_CTRL>().isMine = true;
			RootPhysics.PosTime previewHitPosTime = RootPhysics.GetPreviewHitPosTime(rigid, null, "Preview");
			if (previewHitPosTime.position != Vector3.zero)
			{
				Vector3 vector = new Vector3(0f, 3.3f, 12.15f);
				Vector3 vector2 = previewHitPosTime.position - vector;
				vector2 = new Vector3(vector2.x, 0f, vector2.z);
				vector += vector2 * diffPower;
				rigid.velocity = RootPhysics.GetVelocity(rigid.position, vector, previewHitPosTime.time + 0.1f);
			}
			CapsuleCollider component = GetComponent<CapsuleCollider>();
			SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component);
			component.enabled = true;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.wholeThrowCount++;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 1f);
			SingletonPunBase.Singleton<RootPhysics>.GetInstance.ClearPoseQueue();
			UnityEngine.Object.Destroy(this);
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[RequireComponent(typeof(Rigidbody))]
	[AddComponentMenu("XR/XR Grab Interactable")]
	public class Grab_CTRL : XRBaseInteractable
	{
		public float diffPower;

		private const float k_DefaultTighteningAmount = 0.5f;

		private const float k_DefaultSmoothingAmount = 5f;

		private const float k_VelocityPredictionFactor = 0.6f;

		private const float k_AngularVelocityDamping = 0.95f;

		private const int k_ThrowSmoothingFrameCount = 20;

		private const float k_DefaultAttachEaseInTime = 0.15f;

		private const float k_DefaultThrowSmoothingDuration = 0.25f;

		private const float k_DefaultThrowVelocityScale = 1.5f;

		private const float k_DefaultThrowAngularVelocityScale = 0.25f;

		[SerializeField]
		private Transform m_AttachTransform;

		[SerializeField]
		private float m_AttachEaseInTime = 0.15f;

		[SerializeField]
		private MovementType m_MovementType = MovementType.Kinematic;

		[SerializeField]
		private bool m_TrackPosition = true;

		[SerializeField]
		private bool m_SmoothPosition;

		[SerializeField]
		[Range(0f, 20f)]
		private float m_SmoothPositionAmount = 5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_TightenPosition = 0.5f;

		[SerializeField]
		private bool m_TrackRotation = true;

		[SerializeField]
		private bool m_SmoothRotation;

		[SerializeField]
		[Range(0f, 20f)]
		private float m_SmoothRotationAmount = 5f;

		[SerializeField]
		[Range(0f, 1f)]
		private float m_TightenRotation = 0.5f;

		[SerializeField]
		private bool m_ThrowOnDetach = true;

		[SerializeField]
		private float m_ThrowSmoothingDuration = 0.25f;

		[SerializeField]
		[Tooltip("The curve to use to weight velocity smoothing (most recent frames to the right.")]
		private AnimationCurve m_ThrowSmoothingCurve = AnimationCurve.Linear(1f, 1f, 1f, 0f);

		[SerializeField]
		private float m_ThrowVelocityScale = 1.5f;

		[SerializeField]
		private float m_ThrowAngularVelocityScale = 0.25f;

		[SerializeField]
		private bool m_GravityOnDetach;

		[SerializeField]
		private bool m_RetainTransformParent = true;

		private bool m_WasKinematic;

		private bool m_UsedGravity;

		private Transform m_OriginalSceneParent;

		private XRBaseInteractor m_SelectingInteractor;

		private Vector3 m_InteractorLocalPosition;

		private Quaternion m_InteractorLocalRotation;

		private Vector3 m_TargetWorldPosition;

		private Quaternion m_TargetWorldRotation;

		private float m_CurrentAttachEaseTime;

		private MovementType m_CurrentMovementType;

		private bool m_DetachInLateUpdate;

		private Vector3 m_DetachVelocity;

		private Vector3 m_DetachAngularVelocity;

		private int m_ThrowSmoothingCurrentFrame;

		private float[] m_ThrowSmoothingFrameTimes = new float[20];

		private Vector3[] m_ThrowSmoothingVelocityFrames = new Vector3[20];

		private Vector3[] m_ThrowSmoothingAngularVelocityFrames = new Vector3[20];

		private Rigidbody m_RigidBody;

		private Vector3 m_LastPosition;

		private Quaternion m_LastRotation;

		private Transform trans_Attach;

		private Ball_CTRL ball_Ctrl;

		private bool isOnceSelect;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		public Transform attachTransform
		{
			get
			{
				return m_AttachTransform;
			}
			set
			{
				m_AttachTransform = value;
			}
		}

		public float attachEaseInTime
		{
			get
			{
				return m_AttachEaseInTime;
			}
			set
			{
				m_AttachEaseInTime = value;
			}
		}

		public MovementType movementType
		{
			get
			{
				return m_MovementType;
			}
			set
			{
				m_MovementType = value;
			}
		}

		public bool trackPosition
		{
			get
			{
				return m_TrackPosition;
			}
			set
			{
				m_TrackPosition = value;
			}
		}

		public bool smoothPosition
		{
			get
			{
				return m_SmoothPosition;
			}
			set
			{
				m_SmoothPosition = value;
			}
		}

		public float smoothPositionAmount
		{
			get
			{
				return m_SmoothPositionAmount;
			}
			set
			{
				m_SmoothPositionAmount = value;
			}
		}

		public float tightenPosition
		{
			get
			{
				return m_TightenPosition;
			}
			set
			{
				m_TightenPosition = value;
			}
		}

		public bool trackRotation
		{
			get
			{
				return m_TrackRotation;
			}
			set
			{
				m_TrackRotation = value;
			}
		}

		public bool smoothRotation
		{
			get
			{
				return m_SmoothRotation;
			}
			set
			{
				m_SmoothRotation = value;
			}
		}

		public float smoothRotationAmount
		{
			get
			{
				return m_SmoothRotationAmount;
			}
			set
			{
				m_SmoothRotationAmount = value;
			}
		}

		public float tightenRotation
		{
			get
			{
				return m_TightenRotation;
			}
			set
			{
				m_TightenRotation = value;
			}
		}

		public bool throwOnDetach
		{
			get
			{
				return m_ThrowOnDetach;
			}
			set
			{
				m_ThrowOnDetach = value;
			}
		}

		public float throwSmoothingDuration
		{
			get
			{
				return m_ThrowSmoothingDuration;
			}
			set
			{
				m_ThrowSmoothingDuration = value;
			}
		}

		public float throwVelocityScale
		{
			get
			{
				return m_ThrowVelocityScale;
			}
			set
			{
				m_ThrowVelocityScale = value;
			}
		}

		public float throwAngularVelocityScale
		{
			get
			{
				return m_ThrowAngularVelocityScale;
			}
			set
			{
				m_ThrowAngularVelocityScale = value;
			}
		}

		public bool gravityOnDetach
		{
			get
			{
				return m_GravityOnDetach;
			}
			set
			{
				m_GravityOnDetach = value;
			}
		}

		public bool retainTransformParent
		{
			get
			{
				return m_RetainTransformParent;
			}
			set
			{
				m_RetainTransformParent = value;
			}
		}

		public XRBaseInteractor selectingInteractor => m_SelectingInteractor;

		protected override void Awake()
		{
			base.Awake();
			m_CurrentMovementType = m_MovementType;
			if (m_RigidBody == null)
			{
				m_RigidBody = GetComponent<Rigidbody>();
			}
			if (m_RigidBody == null)
			{
				UnityEngine.Debug.LogWarning("Grab Interactable does not have a required RigidBody.", this);
			}
			ball_Ctrl = GetComponent<Ball_CTRL>();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ThowBall_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(CreateBall_Multi);
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
		}

		public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			switch (updatePhase)
			{
			case XRInteractionUpdateOrder.UpdatePhase.Fixed:
				if (base.isSelected)
				{
					if (m_CurrentMovementType == MovementType.Kinematic)
					{
						PerformKinematicUpdate(Time.unscaledDeltaTime, updatePhase);
					}
					else if (m_CurrentMovementType == MovementType.VelocityTracking)
					{
						PerformVelocityTrackingUpdate(Time.unscaledDeltaTime, updatePhase);
					}
				}
				break;
			case XRInteractionUpdateOrder.UpdatePhase.Dynamic:
				if (base.isSelected)
				{
					UpdateTarget(Time.unscaledDeltaTime);
					SmoothVelocityUpdate();
					if (m_CurrentMovementType == MovementType.Instantaneous)
					{
						PerformInstantaneousUpdate(Time.unscaledDeltaTime, updatePhase);
					}
				}
				break;
			case XRInteractionUpdateOrder.UpdatePhase.OnBeforeRender:
				if (base.isSelected && m_CurrentMovementType == MovementType.Instantaneous)
				{
					PerformInstantaneousUpdate(Time.unscaledDeltaTime, updatePhase);
				}
				break;
			case XRInteractionUpdateOrder.UpdatePhase.Late:
				break;
			}
		}

		private Quaternion GetWorldAttachRotation(XRBaseInteractor interactor)
		{
			return interactor.attachTransform.rotation * m_InteractorLocalRotation;
		}

		private void UpdateTarget(float timeDelta)
		{
			if (m_AttachEaseInTime > 0f && m_CurrentAttachEaseTime <= m_AttachEaseInTime)
			{
				float t = m_CurrentAttachEaseTime / m_AttachEaseInTime;
				m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), t);
				m_CurrentAttachEaseTime += Time.unscaledDeltaTime;
			}
			else if (!m_SmoothPosition)
			{
				if (m_SmoothRotation)
				{
					m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), m_SmoothRotationAmount * timeDelta);
					m_TargetWorldRotation = Quaternion.Slerp(m_TargetWorldRotation, GetWorldAttachRotation(m_SelectingInteractor), m_TightenRotation);
				}
				else
				{
					m_TargetWorldRotation = GetWorldAttachRotation(m_SelectingInteractor);
				}
			}
		}

		private void PerformInstantaneousUpdate(float timeDelta, XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Dynamic || updatePhase == XRInteractionUpdateOrder.UpdatePhase.OnBeforeRender)
			{
				if (trackPosition)
				{
					base.transform.position = m_TargetWorldPosition;
				}
				if (trackRotation)
				{
					base.transform.rotation = m_TargetWorldRotation;
				}
			}
		}

		private void PerformKinematicUpdate(float timeDelta, XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			if (updatePhase == XRInteractionUpdateOrder.UpdatePhase.Fixed)
			{
				if (trackPosition)
				{
					m_RigidBody.velocity = Vector3.zero;
					m_RigidBody.transform.position = Vector3.Lerp(m_RigidBody.position, trans_Attach.position, 0.3f);
				}
				if (trackRotation)
				{
					m_RigidBody.angularVelocity = Vector3.zero;
					m_RigidBody.transform.rotation = trans_Attach.rotation;
				}
			}
		}

		private void PerformVelocityTrackingUpdate(float timeDelta, XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			if (updatePhase != 0)
			{
				return;
			}
			if (trackPosition)
			{
				m_RigidBody.velocity *= 0.6f;
				Vector3 vector = (m_TargetWorldPosition - m_RigidBody.worldCenterOfMass) / timeDelta;
				if (!float.IsNaN(vector.x))
				{
					m_RigidBody.velocity += vector;
				}
			}
			if (!trackRotation)
			{
				return;
			}
			m_RigidBody.angularVelocity *= 0.6f;
			(m_TargetWorldRotation * Quaternion.Inverse(m_RigidBody.rotation)).ToAngleAxis(out var angle, out var axis);
			if (angle > 180f)
			{
				angle -= 360f;
			}
			if (Mathf.Abs(angle) > Mathf.Epsilon)
			{
				Vector3 vector2 = axis * angle * ((float)Math.PI / 180f) / timeDelta;
				if (!float.IsNaN(vector2.x))
				{
					m_RigidBody.angularVelocity += vector2 * 0.95f;
				}
			}
		}

		private void Teleport(Transform teleportTransform)
		{
			if (trackPosition)
			{
				Vector3 translation = teleportTransform.position - m_RigidBody.worldCenterOfMass;
				m_RigidBody.velocity = Vector3.zero;
				base.transform.Translate(translation, Space.World);
			}
			if (trackRotation)
			{
				m_RigidBody.angularVelocity = Vector3.zero;
				m_RigidBody.transform.rotation = teleportTransform.rotation;
			}
		}

		private void Detach()
		{
			m_RigidBody.velocity = m_DetachVelocity;
			m_RigidBody.angularVelocity = m_DetachAngularVelocity;
			m_RigidBody.isKinematic = false;
			m_RigidBody.GetComponent<Ball_CTRL>().isMine = true;
			RootPhysics.PosTime previewHitPosTime = RootPhysics.GetPreviewHitPosTime(m_RigidBody, null, "Preview");
			if (previewHitPosTime.position != Vector3.zero)
			{
				Vector3 vector = new Vector3(0f, 3.3f, 12.15f);
				Vector3 vector2 = previewHitPosTime.position - vector;
				vector2 = new Vector3(vector2.x, 0f, vector2.z);
				vector += vector2 * diffPower;
				m_RigidBody.velocity = RootPhysics.GetVelocity(m_RigidBody.position, vector, previewHitPosTime.time + 0.1f);
			}
			CapsuleCollider component = GetComponent<CapsuleCollider>();
			SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component);
			component.enabled = true;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.wholeThrowCount++;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 1f);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				BallData data = new BallData
				{
					position = m_RigidBody.transform.position,
					velocity = m_RigidBody.velocity,
					angularVelocity = m_RigidBody.angularVelocity,
					photonTime = PhotonNetwork.Time
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ThowBall_Multi, data, RpcTarget.Others);
			}
			UnityEngine.Object.Destroy(this);
		}

		private void TimeOverDetach()
		{
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isGrap = false;
			trans_Attach = null;
			m_RigidBody.useGravity = true;
			m_RigidBody.velocity = Vector3.zero;
			m_RigidBody.angularVelocity = Vector3.zero;
			m_RigidBody.isKinematic = false;
			m_RigidBody.GetComponent<Ball_CTRL>().isMine = true;
			CapsuleCollider component = GetComponent<CapsuleCollider>();
			SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component);
			component.enabled = true;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.wholeThrowCount++;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 1f);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				BallData data = new BallData
				{
					position = m_RigidBody.transform.position,
					velocity = m_RigidBody.velocity,
					angularVelocity = m_RigidBody.angularVelocity,
					photonTime = PhotonNetwork.Time
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ThowBall_Multi, data, RpcTarget.Others);
			}
			UnityEngine.Object.Destroy(this);
		}

		private void UpdateInteractorLocalPose(XRBaseInteractor interactor)
		{
			Transform transform = (m_AttachTransform ? m_AttachTransform : base.transform);
			Vector3 vector = (m_AttachTransform ? m_AttachTransform.position : m_RigidBody.worldCenterOfMass);
			Vector3 direction = m_RigidBody.worldCenterOfMass - vector;
			Vector3 interactorLocalPosition = transform.InverseTransformDirection(direction);
			Vector3 lossyScale = interactor.attachTransform.lossyScale;
			lossyScale = new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z);
			interactorLocalPosition.Scale(lossyScale);
			m_InteractorLocalPosition = interactorLocalPosition;
			m_InteractorLocalRotation = Quaternion.Inverse(Quaternion.Inverse(m_RigidBody.rotation) * transform.rotation);
		}

		protected override void OnSelectEnter(XRBaseInteractor interactor)
		{
			if (!interactor)
			{
				return;
			}
			if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart && !SingletonPunBase.Singleton<Game_SGT>.GetInstance.isOnceStart)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.isOnceStart = true;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
			}
			if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.time <= 0f))
			{
				if (SingletonPunBase.Singleton<UI_SGT>.GetInstance.anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
				{
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.ClickButton("Start");
				}
				base.OnSelectEnter(interactor);
				trans_Attach = interactor.transform.Find("HandModel/ThrowPos").transform;
				if (ball_Ctrl.selectParticle.isPlaying)
				{
					ball_Ctrl.selectParticle.gameObject.SetActive(value: false);
				}
				if (trans_Attach.parent.parent.name == "LeftHand")
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetHandPos(isThrow: true, isRightHand: false);
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.Haptic(0.5f, 0.1f);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetHandPos(isThrow: true);
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.Haptic(0.5f, 0.1f, isLeft: false);
				}
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					LumpsData<string> data = new LumpsData<string>
					{
						lumps = trans_Attach.parent.parent.name
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(CreateBall_Multi, data, RpcTarget.Others);
				}
				if (m_SelectingInteractor == null)
				{
					m_OriginalSceneParent = base.transform.parent;
					base.transform.parent = null;
				}
				m_SelectingInteractor = interactor;
				m_CurrentMovementType = (interactor.selectedInteractableMovementTypeOverride.HasValue ? interactor.selectedInteractableMovementTypeOverride.Value : m_MovementType);
				m_WasKinematic = m_RigidBody.isKinematic;
				m_UsedGravity = m_RigidBody.useGravity;
				m_RigidBody.isKinematic = m_CurrentMovementType == MovementType.Kinematic;
				m_RigidBody.useGravity = false;
				m_RigidBody.drag = 0f;
				m_RigidBody.angularDrag = 0f;
				GetComponent<CapsuleCollider>().enabled = false;
				m_DetachVelocity = (m_DetachAngularVelocity = Vector3.zero);
				UpdateInteractorLocalPose(interactor);
				if (false)
				{
					Teleport(m_SelectingInteractor.attachTransform);
				}
				else if (m_AttachEaseInTime > 0f)
				{
					m_TargetWorldPosition = m_RigidBody.worldCenterOfMass;
					m_TargetWorldRotation = base.transform.rotation;
					m_CurrentAttachEaseTime = 0f;
				}
				SmoothVelocityStart();
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 0, 0f);
			}
		}

		protected override void OnSelectExit(XRBaseInteractor interactor)
		{
			base.OnSelectExit(interactor);
			if (trans_Attach != null)
			{
				if (trans_Attach.parent.parent.name == "LeftHand")
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetHandPos(isThrow: false, isRightHand: false);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetHandPos();
				}
			}
			m_RigidBody.isKinematic = m_WasKinematic;
			m_RigidBody.useGravity = true;
			m_CurrentMovementType = m_MovementType;
			m_SelectingInteractor = null;
			m_DetachInLateUpdate = true;
		}

		public override bool IsHoverableBy(XRBaseInteractor interactor)
		{
			if (!ball_Ctrl.selectParticle.isPlaying)
			{
				isOnceSelect = true;
				ball_Ctrl.selectParticle.Play();
			}
			return true;
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (!obj && trans_Attach != null && trans_Attach.parent.parent.name == "LeftHand")
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetHandPos(isThrow: false, isRightHand: false);
				m_RigidBody.isKinematic = m_WasKinematic;
				m_RigidBody.useGravity = true;
				m_CurrentMovementType = m_MovementType;
				m_SelectingInteractor = null;
				m_DetachInLateUpdate = true;
				SmoothVelocityEnd();
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (!obj && trans_Attach != null && trans_Attach.parent.parent.name == "RightHand")
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetHandPos();
				m_RigidBody.isKinematic = m_WasKinematic;
				m_RigidBody.useGravity = true;
				m_CurrentMovementType = m_MovementType;
				m_SelectingInteractor = null;
				m_DetachInLateUpdate = true;
				SmoothVelocityEnd();
			}
		}

		private void Update()
		{
			if (!base.isHovered && isOnceSelect && ball_Ctrl.selectParticle.isPlaying)
			{
				isOnceSelect = false;
				ball_Ctrl.selectParticle.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
			}
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController != null)
			{
				_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice;
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
				{
					OnTriggerL.CurrentData = isPressed;
				}
			}
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController != null)
			{
				_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice;
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
				{
					OnTriggerR.CurrentData = isPressed2;
				}
			}
			if (trans_Attach != null && SingletonPunBase.Singleton<Game_SGT>.GetInstance.time < 0.1f)
			{
				TimeOverDetach();
			}
			if (m_DetachInLateUpdate)
			{
				Detach();
				m_DetachInLateUpdate = false;
			}
		}

		private void SmoothVelocityStart()
		{
			if ((bool)m_SelectingInteractor)
			{
				m_LastPosition = m_SelectingInteractor.attachTransform.position;
				m_LastRotation = m_SelectingInteractor.attachTransform.rotation;
				Array.Clear(m_ThrowSmoothingFrameTimes, 0, m_ThrowSmoothingFrameTimes.Length);
				Array.Clear(m_ThrowSmoothingVelocityFrames, 0, m_ThrowSmoothingVelocityFrames.Length);
				Array.Clear(m_ThrowSmoothingAngularVelocityFrames, 0, m_ThrowSmoothingAngularVelocityFrames.Length);
				m_ThrowSmoothingCurrentFrame = 0;
			}
		}

		private void SmoothVelocityEnd()
		{
			if (m_ThrowOnDetach)
			{
				Vector3 smoothedVelocityValue = getSmoothedVelocityValue(m_ThrowSmoothingVelocityFrames);
				Vector3 smoothedVelocityValue2 = getSmoothedVelocityValue(m_ThrowSmoothingAngularVelocityFrames);
				m_DetachVelocity = smoothedVelocityValue * m_ThrowVelocityScale;
				m_DetachAngularVelocity = smoothedVelocityValue2 * m_ThrowAngularVelocityScale;
			}
		}

		private void SmoothVelocityUpdate()
		{
			if ((bool)m_SelectingInteractor)
			{
				m_ThrowSmoothingFrameTimes[m_ThrowSmoothingCurrentFrame] = Time.time;
				m_ThrowSmoothingVelocityFrames[m_ThrowSmoothingCurrentFrame] = (m_SelectingInteractor.attachTransform.position - m_LastPosition) / Time.deltaTime;
				Quaternion quaternion = m_SelectingInteractor.attachTransform.rotation * Quaternion.Inverse(m_LastRotation);
				m_ThrowSmoothingAngularVelocityFrames[m_ThrowSmoothingCurrentFrame] = new Vector3(Mathf.DeltaAngle(0f, quaternion.eulerAngles.x), Mathf.DeltaAngle(0f, quaternion.eulerAngles.y), Mathf.DeltaAngle(0f, quaternion.eulerAngles.z)) / Time.deltaTime * ((float)Math.PI / 180f);
				m_ThrowSmoothingCurrentFrame = (m_ThrowSmoothingCurrentFrame + 1) % 20;
				m_LastPosition = m_SelectingInteractor.attachTransform.position;
				m_LastRotation = m_SelectingInteractor.attachTransform.rotation;
			}
		}

		private Vector3 getSmoothedVelocityValue(Vector3[] velocityFrames)
		{
			Vector3 vector = default(Vector3);
			int i = 0;
			float num = 0f;
			for (; i < 20; i++)
			{
				int num2 = ((m_ThrowSmoothingCurrentFrame - i - 1) % 20 + 20) % 20;
				if (m_ThrowSmoothingFrameTimes[num2] == 0f)
				{
					break;
				}
				float num3 = (Time.time - m_ThrowSmoothingFrameTimes[num2]) / m_ThrowSmoothingDuration;
				float num4 = m_ThrowSmoothingCurve.Evaluate(Mathf.Clamp(1f - num3, 0f, 1f));
				vector += velocityFrames[num2] * num4;
				num += num4;
				if (Time.time - m_ThrowSmoothingFrameTimes[num2] > m_ThrowSmoothingDuration)
				{
					break;
				}
			}
			if (num > 0f)
			{
				return vector / num;
			}
			return Vector3.zero;
		}

		public void CreateBall_Multi(SerializableClass packet)
		{
			switch ((packet as LumpsData<string>).lumps)
			{
			case "Head":
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_R_Mul"), GameObject.Find("Others/Head").transform).transform;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_B_Mul"), GameObject.Find("Others/Head").transform).transform;
				}
				break;
			case "LeftHand":
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_R_Mul"), SingletonPunBase.Singleton<Game_SGT>.GetInstance.others_LeftThrowPos).transform;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_B_Mul"), SingletonPunBase.Singleton<Game_SGT>.GetInstance.others_LeftThrowPos).transform;
				}
				break;
			case "RightHand":
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_R_Mul"), SingletonPunBase.Singleton<Game_SGT>.GetInstance.others_RightThrowPos).transform;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_B_Mul"), SingletonPunBase.Singleton<Game_SGT>.GetInstance.others_RightThrowPos).transform;
				}
				break;
			}
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.localScale = 8f * Vector3.one;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Rigidbody>().useGravity = false;
		}

		public void ThowBall_Multi(SerializableClass packet)
		{
			if (packet is BallData && !(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.gameObject == null))
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.SetParent(null);
				Rigidbody component = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Rigidbody>();
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.GetComponent<Ball_CTRL>().isMine = false;
				Vector3 position = (packet as BallData).position;
				Vector3 velocity = (packet as BallData).velocity;
				double num = (double)(float)PhotonNetwork.Time - (packet as BallData).photonTime;
				float x = position.x + velocity.x * (float)num;
				float y = position.y + velocity.y * (float)num + 0.5f * Physics.gravity.y * (float)(num * num);
				float z = position.z + velocity.z * (float)num;
				float num2 = Physics.gravity.y * (float)num;
				velocity.y += num2;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.othersBall.position = new Vector3(x, y, z);
				component.position = new Vector3(x, y, z);
				component.transform.SetParent(null);
				component.useGravity = true;
				component.isKinematic = false;
				component.angularVelocity = (packet as BallData).angularVelocity;
				component.velocity = velocity;
				SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component.GetComponent<CapsuleCollider>());
			}
		}
	}
	public class Led_CTRL : MonoBehaviour
	{
		private Image[] images;

		public Sprite[] numbers;

		private int preNum;

		private void Start()
		{
			images = GetComponentsInChildren<Image>();
		}

		public void ShowNumber(int num)
		{
			if (preNum == num)
			{
				return;
			}
			if (num > 999)
			{
				num = 999;
			}
			preNum = num;
			int num2 = images.Length;
			ClearNumber();
			if (num < 10)
			{
				if (num2 > 0)
				{
					images[num2 - 1].sprite = numbers[num];
				}
			}
			else if (num >= 10 && num < 100)
			{
				if (num2 > 1)
				{
					images[num2 - 2].sprite = numbers[num / 10];
					images[num2 - 1].sprite = numbers[num % 10];
				}
			}
			else if (num >= 100 && num < 1000)
			{
				if (num2 > 2)
				{
					int num3 = num % 100;
					images[num2 - 3].sprite = numbers[num / 100];
					images[num2 - 2].sprite = numbers[num3 / 10];
					images[num2 - 1].sprite = numbers[num3 % 10];
				}
			}
			else if (num >= 1000 && num < 10000 && num2 > 3)
			{
				int num4 = num % 1000;
				int num5 = num4 % 100;
				images[num2 - 4].sprite = numbers[num / 1000];
				images[num2 - 3].sprite = numbers[num4 / 100];
				images[num2 - 2].sprite = numbers[num5 / 10];
				images[num2 - 1].sprite = numbers[num5 % 10];
			}
		}

		public void ShowNumber(float num)
		{
			int num2 = (int)Mathf.Floor(num);
			ShowNumber(num2);
		}

		public void ClearNumber()
		{
			Image[] array = images;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].sprite = numbers[0];
			}
		}
	}
	public class Player_CTRL : MonoBehaviour
	{
		public bool isTest;

		private PhotonView pv;

		private bool isClickMouse0;

		public bool isClickMouse1;

		private Transform LeftHandModel;

		private Transform RightHandModel;

		private Vector3 BasicPos_LeftHand;

		private Vector3 BasicPos_RightHand;

		private Quaternion BasicRot_LeftHand;

		private Quaternion BasicRot_RightHand;

		private Vector3 BasicSize_LeftHand = new Vector3(0.5f, 0.5f, 0.5f);

		private Vector3 BasicSize_RightHand = new Vector3(-0.5f, 0.5f, 0.5f);

		private Vector3 ThrowPos_LeftHand = new Vector3(0.031f, 0.047f, -0.057f);

		private Vector3 ThrowPos_RightHand = new Vector3(-0.031f, 0.047f, -0.057f);

		private Quaternion ThrowRot_LeftHand = Quaternion.Euler(new Vector3(-29.75f, -177.3f, -20f));

		private Quaternion ThrowRot_RightHand = Quaternion.Euler(new Vector3(-29.75f, 177.3f, 20f));

		private Vector3 ThrowSize_LeftHand = new Vector3(0.5f, 0.5f, 0.5f);

		private Vector3 ThrowSize_RightHand = new Vector3(-0.5f, 0.5f, 0.5f);

		public bool isGrap { get; set; }

		public Transform Head { get; set; }

		public Transform LeftHand { get; set; }

		public Transform RightHand { get; set; }

		public Transform othersBall { get; set; }

		public UnityEngine.XR.Interaction.Toolkit.XRController LeftController { get; set; }

		public UnityEngine.XR.Interaction.Toolkit.XRController RightController { get; set; }

		private void Awake()
		{
			pv = GetComponent<PhotonView>();
			Head = base.transform.Find("Head");
			LeftHand = base.transform.Find("LeftHand");
			RightHand = base.transform.Find("RightHand");
			LeftHandModel = LeftHand.Find("HandModel");
			RightHandModel = RightHand.Find("HandModel");
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("FadeSphere"), Head);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
		}

		private void Start()
		{
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(SetHandPos_Multi);
			LeftController = LeftHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			SetHand();
		}

		private void Update()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				_ = pv.IsMine;
			}
		}

		public void SetHandPos(bool isThrow = false, bool isRightHand = true)
		{
			if (!isThrow)
			{
				if (isRightHand)
				{
					RightHandModel.localPosition = BasicPos_RightHand;
					RightHandModel.localRotation = BasicRot_RightHand;
					RightHandModel.localScale = BasicSize_RightHand;
				}
				else
				{
					LeftHandModel.localPosition = BasicPos_LeftHand;
					LeftHandModel.localRotation = BasicRot_LeftHand;
					LeftHandModel.localScale = BasicSize_LeftHand;
				}
				Invoke("OffGrip", 1.5f);
			}
			else
			{
				if (isRightHand)
				{
					RightHandModel.localPosition = ThrowPos_RightHand;
					RightHandModel.localRotation = ThrowRot_RightHand;
					RightHandModel.localScale = ThrowSize_RightHand;
				}
				else
				{
					LeftHandModel.localPosition = ThrowPos_LeftHand;
					LeftHandModel.localRotation = ThrowRot_LeftHand;
					LeftHandModel.localScale = ThrowSize_LeftHand;
				}
				isGrap = true;
			}
		}

		public void Haptic(float amplitude = 0.5f, float duration = 0.5f, bool isLeft = true)
		{
			if (!(LeftController == null) && !(RightController == null))
			{
				if (isLeft)
				{
					LeftController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
				else
				{
					RightController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
			}
		}

		public void SetHandPos_Multi(SerializableClass packet)
		{
			Player_CTRL others = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others;
			if (!(packet as LumpsData<bool, bool>).lumps1)
			{
				if ((packet as LumpsData<bool, bool>).lumps2)
				{
					others.RightHandModel.localPosition = BasicPos_RightHand;
					others.RightHandModel.localRotation = BasicRot_RightHand;
					others.RightHandModel.localScale = BasicSize_RightHand;
				}
				else
				{
					others.LeftHandModel.localPosition = BasicPos_LeftHand;
					others.LeftHandModel.localRotation = BasicRot_LeftHand;
					others.LeftHandModel.localScale = BasicSize_LeftHand;
				}
			}
			else if ((packet as LumpsData<bool, bool>).lumps2)
			{
				others.RightHandModel.localPosition = ThrowPos_RightHand;
				others.RightHandModel.localRotation = ThrowRot_RightHand;
				others.RightHandModel.localScale = ThrowSize_RightHand;
			}
			else
			{
				others.LeftHandModel.localPosition = ThrowPos_LeftHand;
				others.LeftHandModel.localRotation = ThrowRot_LeftHand;
				others.LeftHandModel.localScale = ThrowSize_LeftHand;
			}
		}

		private void OffGrip()
		{
			isGrap = false;
		}

		private void SetHand()
		{
			if (!(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance == null))
			{
				BasicPos_LeftHand = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomLeftHand.pos;
				BasicPos_RightHand = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomRightHand.pos;
				BasicRot_LeftHand = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomLeftHand.rot;
				BasicRot_RightHand = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomRightHand.rot;
			}
		}
	}
	public class Rack_CTRL : MonoBehaviour
	{
		private bool isSpawn;

		private void Start()
		{
			CreateBall();
		}

		private void Update()
		{
			if (!isSpawn && base.transform.childCount == 0)
			{
				StartCoroutine(SpawnBall());
			}
		}

		private IEnumerator SpawnBall()
		{
			isSpawn = true;
			yield return new WaitForSeconds(8f);
			CreateBall();
			isSpawn = false;
		}

		private void CreateBall()
		{
			GameObject gameObject = null;
			gameObject = ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi) ? ((!PhotonNetwork.IsMasterClient) ? UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_R"), base.transform) : UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_B"), base.transform)) : ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode != 1) ? UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_B"), base.transform) : UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL"), base.transform)));
			int num = UnityEngine.Random.Range(0, 360);
			Quaternion localRotation = Quaternion.Euler(num, num, num);
			gameObject.transform.localScale = Vector3.one;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = localRotation;
		}
	}
	public class Score_CTRL : MonoBehaviour
	{
		public bool isP1;

		private Led_CTRL led_Ctrl;

		private void Start()
		{
			led_Ctrl = GetComponent<Led_CTRL>();
		}

		private void Update()
		{
			if (led_Ctrl == null)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (isP1)
				{
					led_Ctrl.ShowNumber(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P1);
				}
				else
				{
					led_Ctrl.ShowNumber(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2);
				}
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				led_Ctrl.ShowNumber(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score);
			}
			else if (isP1)
			{
				led_Ctrl.ShowNumber(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P1);
			}
			else
			{
				led_Ctrl.ShowNumber(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2);
			}
		}
	}
	public class Time_CTRL : MonoBehaviour
	{
		private Led_CTRL led_Ctrl;

		private void Start()
		{
			led_Ctrl = GetComponent<Led_CTRL>();
		}

		private void Update()
		{
			if (!(led_Ctrl == null))
			{
				led_Ctrl.ShowNumber(SingletonPunBase.Singleton<Game_SGT>.GetInstance.time);
			}
		}
	}
	public class AIPlayer_MovieCTRL : MonoBehaviour
	{
		public Transform lookAtPos;

		public Transform ThrowPos;

		public Vector3 BB_BALL_ArrivalPos;

		public float deleyFirstTime;

		public float delayTime;

		public float BB_BALL_ThrowTime;

		private GameObject BB_BALL;

		private Animator anim;

		public bool isAutoThrow { get; set; }

		private void Start()
		{
			Time.timeScale = 1.2f;
			anim = GetComponent<Animator>();
			isAutoThrow = true;
			GetComponent<CustomModelSettingCtrl>().InitCPU(CustomModelViewState.Normal, null, 0.1f);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.A))
			{
				anim.SetTrigger("WalkL");
			}
			if (Input.GetKeyDown(KeyCode.D))
			{
				anim.SetTrigger("WalkR");
			}
			if (Input.GetKeyDown(KeyCode.W))
			{
				anim.SetTrigger("WalkF");
			}
			if (Input.GetKeyDown(KeyCode.S))
			{
				anim.SetTrigger("WalkB");
			}
			if (Input.GetKeyUp(KeyCode.A) || Input.GetKeyUp(KeyCode.D) || Input.GetKeyUp(KeyCode.W) || Input.GetKeyUp(KeyCode.S))
			{
				anim.SetTrigger("Idle");
			}
			if (Input.GetKeyDown(KeyCode.Space))
			{
				base.transform.LookAt(lookAtPos);
				anim.SetTrigger("Throw");
			}
		}

		public void CreateBall()
		{
			if (BB_BALL != null)
			{
				Rigidbody component = BB_BALL.GetComponent<Rigidbody>();
				component.transform.SetParent(null);
				component.isKinematic = false;
				component.useGravity = true;
				BB_BALL = null;
			}
			BB_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_AI"), ThrowPos);
			BB_BALL.transform.localScale = Vector3.one * 0.666f;
		}

		public void ThrowBall()
		{
			if (!(BB_BALL == null))
			{
				Rigidbody component = BB_BALL.GetComponent<Rigidbody>();
				component.transform.SetParent(null);
				component.isKinematic = false;
				component.useGravity = true;
				component.velocity = RootPhysics.GetVelocity(component.position, BB_BALL_ArrivalPos + new Vector3(UnityEngine.Random.Range(-0.25f, 0.25f), 0f, 0f), BB_BALL_ThrowTime);
				component.angularVelocity = new Vector3(-5f, 0f, 0f);
				SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component.GetComponent<CapsuleCollider>());
				BB_BALL = null;
			}
		}

		private IEnumerator StartAutoThrow(float deleyTime)
		{
			if (isAutoThrow)
			{
				yield return YieldInstructionCache.WaitForSeconds(deleyFirstTime);
				while (true)
				{
					yield return YieldInstructionCache.WaitForSeconds(deleyTime);
					base.transform.LookAt(lookAtPos);
					anim.SetTrigger("Throw");
				}
			}
		}
	}
	public class Ball_MovieCTRL : MonoBehaviour
	{
		private AudioSource audioSource;

		private Rigidbody rigid;

		private Color color;

		private float delayTimer;

		private bool isActive;

		private bool isBoard;

		private bool isRing;

		private bool isNet1;

		private bool isNet2;

		public ParticleSystem selectParticle;

		public Material material_Fade;

		public AudioClip[] clip_Ring;

		public AudioClip[] clip_Board;

		public AudioClip[] clip_Floor;

		public AudioClip[] clip_Net;

		public bool isMine { get; set; }

		private void Start()
		{
			audioSource = GetComponentInChildren<AudioSource>();
			rigid = GetComponent<Rigidbody>();
			color = Color.white;
			delayTimer = 0f;
			isActive = true;
			isNet1 = (isNet2 = (isBoard = (isRing = false)));
		}

		private void Update()
		{
			if (isActive)
			{
				return;
			}
			delayTimer += Time.deltaTime * 2f;
			if (delayTimer > 1f)
			{
				if (GetComponent<Renderer>().material != material_Fade)
				{
					GetComponent<Renderer>().material = material_Fade;
				}
				color.a -= 0.002f;
				GetComponent<Renderer>().material.color = color;
				if (color.a <= 0f)
				{
					base.gameObject.SetActive(value: false);
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		private void OnCollisionEnter(Collision other)
		{
			switch (other.transform.tag)
			{
			case "Ring":
				isRing = true;
				PlaySound(clip_Ring);
				break;
			case "Board":
				isBoard = true;
				PlaySound(clip_Board);
				break;
			case "Floor":
				PlaySound(clip_Floor);
				if (isActive)
				{
					isActive = false;
				}
				break;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			string text = other.transform.tag;
			if (!(text == "Net1"))
			{
				if (text == "Net2")
				{
					PlaySound(clip_Net);
					isNet2 = true;
					if (isNet1 && isMine)
					{
						SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play(SingletonPunBase.Singleton<Effect_SGT>.GetInstance.goal);
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Goal);
					}
				}
			}
			else if (!isNet2)
			{
				isNet1 = true;
			}
		}

		private void PlaySound(AudioClip[] clips)
		{
			if (!(rigid == null))
			{
				float num = Mathf.Clamp(rigid.velocity.magnitude, 0f, 15f);
				float volumeScale = num / 8f;
				audioSource.pitch = 1.15f - num / 50f;
				audioSource.PlayOneShot(clips[UnityEngine.Random.Range(0, clips.Length)], volumeScale);
			}
		}
	}
	public class Crowd_MovieCTRL : MonoBehaviour
	{
		public RuntimeAnimatorController[] contoller;

		private Animator anim;

		private void Start()
		{
			anim = GetComponent<Animator>();
			anim.runtimeAnimatorController = contoller[UnityEngine.Random.Range(0, 4)];
			GetComponent<CustomModelSettingCtrl>().InitCPU(CustomModelViewState.Normal, null, 0.1f);
			Invoke("OnAnim", UnityEngine.Random.Range(0f, 5f));
		}

		private void Update()
		{
		}

		private void OnAnim()
		{
			anim.enabled = true;
		}
	}
	public class Effect_SGT : SingletonPunBase.Singleton<Effect_SGT>
	{
		public ParticleSystem goal;

		public ParticleSystem goal_P1;

		public ParticleSystem goal_P2;

		public Animator goalAnim;

		public Image[] imageNum;

		public Sprite[] spriteNum;

		[SerializeField]
		public TMP_FontAsset font_Us;

		public TMP_FontAsset font_Cn;

		public TextMeshPro bankShot;

		public TextMeshPro cleanShot;

		private void Start()
		{
			Custom(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
		}

		public void Play(ParticleSystem particle)
		{
			particle.Play();
		}

		public void Play(string str, int num)
		{
			switch (str)
			{
			case "BankShot":
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_BankShot_Cn);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_BankShot);
				}
				break;
			case "CleanShot":
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_CleanShot_Cn);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_CleanShot);
				}
				break;
			case "Combo":
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Combo);
				break;
			}
			goalAnim.transform.LookAt(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.transform);
			goalAnim.transform.Rotate(0f, 180f, 0f);
			Vector3 eulerAngles = goalAnim.transform.rotation.eulerAngles;
			goalAnim.transform.rotation = Quaternion.Euler(new Vector3(0f, eulerAngles.y, eulerAngles.z));
			goalAnim.SetTrigger(str);
			if (str == "Combo")
			{
				PlayCombo(num);
			}
		}

		public void DelayPlay(string str1, string str2, int num)
		{
			StartCoroutine(DelayPlay_C(str1, str2, num));
		}

		private IEnumerator DelayPlay_C(string str1, string str2, int num)
		{
			Play(str1, num);
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			Play(str2, num);
		}

		public void PlayCombo(int num)
		{
			if (num < 10)
			{
				imageNum[0].color = new Color(1f, 1f - (float)num / 10f, 0f);
				imageNum[0].sprite = spriteNum[num % 10];
				imageNum[1].sprite = spriteNum[10];
			}
			else
			{
				imageNum[0].color = new Color(1f, 0f, 0f);
				imageNum[1].color = new Color(1f, 0f, 0f);
				imageNum[0].sprite = spriteNum[num / 10];
				imageNum[1].sprite = spriteNum[num % 10];
			}
		}

		public void Custom(LanguageState language)
		{
			if (language == LanguageState.schinese)
			{
				bankShot.font = font_Cn;
				cleanShot.font = font_Cn;
			}
			else
			{
				bankShot.font = font_Us;
				cleanShot.font = font_Us;
			}
		}
	}
	public class Game_SGT : SingletonPunBase.Singleton<Game_SGT>
	{
		private PhotonView pv;

		private bool isOnceDirection;

		private bool isOnceChange;

		private float playTimeScale = 1.2f;

		private int cycle;

		private int changePos;

		private bool isMasterClient;

		private bool isTimeTick;

		private List<Transform> list_BallSpawnPos = new List<Transform>();

		private List<Transform> list_PlayerMovePos = new List<Transform>();

		public Material rayMaterial;

		public Material handMaterial;

		public Transform net;

		public Animation anim_Billboard;

		public GameObject ob_SBoard;

		public GameObject ob_MBoard;

		public Text text_Player1;

		public Text text_Player2;

		public BallCount_CTRL[] ballCount_Ctrl;

		public AudioSource audio_TimeTick;

		public bool isRightRack { get; set; }

		public bool isGameStart { get; set; }

		public bool isOnceStart { get; set; }

		public bool isGameEnd { get; set; }

		public float time { get; set; }

		public float recieveTime { get; set; }

		public Player_CTRL player { get; set; }

		public Player_CTRL others { get; set; }

		public AIPlayer_CTRL aiPlayer_Ctrl { get; set; }

		public Transform others_LeftThrowPos { get; set; }

		public Transform others_RightThrowPos { get; set; }

		public int changePositionCount { get; set; }

		public int comboCount { get; set; }

		public int wholeGoalCount { get; set; }

		public int wholeThrowCount { get; set; }

		public int maxComboCount { get; set; }

		public int score { get; set; }

		public int score_P1 { get; set; }

		public int score_P2 { get; set; }

		public Transform Rack { get; set; }

		private void Start()
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomHand();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ScoreSerial_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(TimeOutStop_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(LeftPlayer_Mul);
			pv = GetComponent<PhotonView>();
			Time.timeScale = playTimeScale;
			anim_Billboard["Billboard_move03"].speed = 0.35f;
			isGameStart = false;
			changePositionCount = 0;
			comboCount = 0;
			score = 0;
			time = 0f;
			recieveTime = 0f;
			isRightRack = PublicGameUIManager.gameSetting.IsRightHanded();
			PublicGameUIManager.gameSetting.AddHandChangedEvent(OnChangeRack);
			SetBallPosition();
			SpawnPlayer();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				StartCoroutine(DelaySpawnOtherVRIK_C());
				ob_MBoard.SetActive(value: true);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				ob_SBoard.SetActive(value: true);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				ob_MBoard.SetActive(value: true);
				text_Player1.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
				text_Player2.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			}
			DelayController(PublicGameUIManager.gameSetting.IsRightHanded(), 30, 1f);
			PublicGameUIManager.gameSetting.AddHandChangedEvent(StartDelayController);
		}

		private void FixedUpdate()
		{
			TimeFlowGame();
		}

		public void Goal(string type)
		{
			wholeGoalCount++;
			changePositionCount++;
			comboCount++;
			if (maxComboCount < comboCount)
			{
				maxComboCount = comboCount;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				if (comboCount == 10)
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach29", 1);
				}
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
				{
					for (int i = 0; i < 3; i++)
					{
						ballCount_Ctrl[i].RightOn(changePositionCount);
					}
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
				{
					ballCount_Ctrl[3].RightOn(changePositionCount);
				}
			}
			else
			{
				ballCount_Ctrl[3].RightOn(changePositionCount);
			}
			switch (type)
			{
			case "nomal":
				score++;
				break;
			case "bank":
				score += 2;
				SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play("BankShot", comboCount);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach30", 1);
				}
				break;
			case "clear":
				score += 3;
				SingletonPunBase.Singleton<Effect_SGT>.GetInstance.Play("CleanShot", comboCount);
				break;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					score_P1 = score;
				}
				else
				{
					score_P2 = score;
				}
				LumpsData<int> data = new LumpsData<int>
				{
					lumps = score
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ScoreSerial_Multi, data, RpcTarget.Others);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				score_P1 = score;
			}
		}

		public void AIGoal(string type)
		{
			aiPlayer_Ctrl.wholeGoalCount++;
			aiPlayer_Ctrl.changePositionCount++;
			aiPlayer_Ctrl.comboCount++;
			switch (type)
			{
			case "nomal":
				score_P2++;
				break;
			case "bank":
				score_P2 += 2;
				break;
			case "clear":
				score_P2 += 3;
				break;
			}
		}

		public void NoGoal()
		{
			comboCount = 0;
		}

		public void AINoGoal()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				aiPlayer_Ctrl.comboCount = 0;
			}
		}

		public void StartGame()
		{
			isGameStart = true;
			changePositionCount = 0;
			comboCount = 0;
			score = 0;
			cycle = 0;
			maxComboCount = 0;
			wholeGoalCount = 0;
			wholeThrowCount = 0;
			Rack.gameObject.SetActive(value: true);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				score = 0;
				score_P1 = 0;
				score_P2 = 0;
				time = 100f;
				recieveTime = 100f;
				isOnceDirection = true;
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				time = 31f;
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
			{
				score = 0;
				score_P1 = 0;
				score_P2 = 0;
				time = 100f;
				recieveTime = 100f;
				isOnceDirection = true;
				aiPlayer_Ctrl.StartAutoThrow();
			}
		}

		public void EndGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("EndMOpen");
				if (PhotonNetwork.IsMasterClient)
				{
					changePos = 1;
				}
				else
				{
					changePos = 2;
				}
				SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn(delegate
				{
					ChangePlayerPosition(changePos);
				});
			}
			else
			{
				if (isGameStart)
				{
					return;
				}
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
				{
					changePos = 0;
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("EndSOpen");
					SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn(delegate
					{
						ChangePlayerPosition(changePos);
					});
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
				{
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("EndMOpen");
					changePos = 1;
					aiPlayer_Ctrl.StopAutoThrow();
					SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn(delegate
					{
						ChangePlayerPosition(changePos);
					});
				}
			}
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_EndBuzzer_Cn);
			}
			else
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_EndBuzzer);
			}
			Rack.gameObject.SetActive(value: false);
			isGameEnd = true;
		}

		private void TimeFlowGame()
		{
			if (isGameStart)
			{
				time -= Time.deltaTime * 1f / playTimeScale;
				if (time <= 0f)
				{
					isTimeTick = false;
					audio_TimeTick.Stop();
					isGameStart = false;
					time = 0f;
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						EndGame();
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
					{
						if (!player.isGrap)
						{
							EndGame();
						}
						else
						{
							Invoke("EndGame", 2f);
						}
					}
					else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
					{
						EndGame();
					}
				}
				if (!isTimeTick && time <= 5f && time > 0f)
				{
					isTimeTick = true;
					audio_TimeTick.Play();
				}
			}
			if (!(time >= 0f))
			{
				return;
			}
			if (changePositionCount % 4 == 3)
			{
				if (!isOnceDirection)
				{
					isOnceDirection = true;
					changePos = UnityEngine.Random.Range(1, 3);
				}
				else
				{
					changePos += 2;
					if (changePos >= list_PlayerMovePos.Count)
					{
						if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
						{
							if (PhotonNetwork.IsMasterClient)
							{
								changePos = 1;
							}
							else
							{
								changePos = 2;
							}
						}
						else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
						{
							isOnceDirection = false;
							changePos = 0;
							cycle++;
						}
						else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
						{
							changePos = 1;
						}
					}
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi && (changePos == 7 || changePos == 8))
					{
						cycle++;
					}
				}
				SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn(delegate
				{
					ChangePlayerPosition(changePos);
				});
				changePositionCount = 0;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2 && aiPlayer_Ctrl.changePositionCount % 4 == 3)
			{
				aiPlayer_Ctrl.changePos += 2;
				if (aiPlayer_Ctrl.changePos >= list_PlayerMovePos.Count)
				{
					aiPlayer_Ctrl.changePos = 2;
				}
				ChangeAIPosition(aiPlayer_Ctrl.changePos);
				aiPlayer_Ctrl.changePositionCount = 0;
			}
		}

		private void SetBallPosition()
		{
			Rack = GameObject.Find("Stadium_HQ/Stadium/Rack").transform;
		}

		private void SetPlayerPosition()
		{
			Transform transform = GameObject.Find("PlayerPoint").transform;
			int childCount = transform.childCount;
			for (int i = 0; i < childCount; i++)
			{
				list_PlayerMovePos.Add(transform.GetChild(i).transform);
			}
		}

		private void ChangePlayerPosition(int position)
		{
			player.transform.SetParent(list_PlayerMovePos[position]);
			player.transform.localPosition = Vector3.zero;
			player.transform.localRotation = Quaternion.identity;
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position = player.transform.position + player.transform.forward * 1.5f;
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.LookAt(player.transform);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position += new Vector3(0f, 1.3f, 0f);
			OnChangeRack(isRightRack);
			SingletonBase.Singleton<Net_SGT>.GetInstance.ClearCloth();
		}

		private void ChangeAIPosition(int position)
		{
			aiPlayer_Ctrl.transform.SetParent(list_PlayerMovePos[position]);
			aiPlayer_Ctrl.transform.localPosition = Vector3.zero;
			aiPlayer_Ctrl.transform.localRotation = Quaternion.identity;
			switch (position)
			{
			case 2:
			case 8:
			case 10:
			case 12:
				aiPlayer_Ctrl.BB_BALL_ThrowTime = 1.5f;
				break;
			case 4:
				aiPlayer_Ctrl.BB_BALL_ThrowTime = 1.3f;
				break;
			case 6:
				aiPlayer_Ctrl.BB_BALL_ThrowTime = 1f;
				break;
			}
		}

		private void OnChangeRack(bool isRight)
		{
			isRightRack = isRight;
			if (isRightRack)
			{
				Rack.position = player.transform.position + player.transform.forward * 0.5f + player.transform.right * 0.5f;
				Rack.LookAt(player.transform);
				Rack.Rotate(new Vector3(0f, 120f, 0f));
			}
			else
			{
				Rack.position = player.transform.position + player.transform.forward * 0.5f - player.transform.right * 0.5f;
				Rack.LookAt(player.transform);
				Rack.Rotate(new Vector3(0f, -120f, 0f));
			}
		}

		private void SpawnPlayer()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance == null)
			{
				return;
			}
			SpawnUI();
			SetPlayerPosition();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				player = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_SinglePlayer")).GetComponent<Player_CTRL>();
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
				{
					changePos = 0;
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
				{
					aiPlayer_Ctrl = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_AIPlayer")).GetComponent<AIPlayer_CTRL>();
					ChangeAIPosition(2);
					changePos = 1;
				}
			}
			else
			{
				player = PhotonNetwork.Instantiate("BB_MultiPlayer", Vector3.zero, Quaternion.identity, 0).GetComponent<Player_CTRL>();
				player.gameObject.name = "Player";
				if (PhotonNetwork.IsMasterClient)
				{
					changePos = 1;
				}
				else
				{
					changePos = 2;
				}
			}
			ChangePlayerPosition(changePos);
			SetPlayerXR();
		}

		private void SpawnUI()
		{
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_InGameUI"));
		}

		private IEnumerator DelaySpawnOtherVRIK_C()
		{
			while (GameObject.Find("BB_MultiPlayer(Clone)") == null)
			{
				yield return null;
			}
			others = GameObject.Find("BB_MultiPlayer(Clone)").GetComponent<Player_CTRL>();
			others.name = "Others";
			VRIK component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("VRIK"), others.transform.position, Quaternion.identity).GetComponent<VRIK>();
			SkinnedMeshRenderer component2 = others.LeftHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>();
			component2.material = handMaterial;
			others.RightHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>().material = handMaterial;
			others.LeftHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			others.RightHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			others_LeftThrowPos = others.LeftHand.Find("HandModel/ThrowPos").transform;
			others_RightThrowPos = others.RightHand.Find("HandModel/ThrowPos").transform;
			component.solver.spine.headTarget = others.Head.Find("IK1");
			component.solver.spine.pelvisTarget = others.transform.Find("Pelvis");
			component.solver.leftArm.target = others.LeftHand.Find("IK");
			component.solver.rightArm.target = others.RightHand.Find("IK");
			CustomModelSettingCtrl component3 = component.GetComponent<CustomModelSettingCtrl>();
			component3.enabled = true;
			if (PhotonNetwork.IsMasterClient)
			{
				component3.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id, CustomModelViewState.HalfCut2, component2);
			}
			else
			{
				component3.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id, CustomModelViewState.HalfCut2, component2);
			}
			text_Player1.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			text_Player2.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			isMasterClient = PhotonNetwork.IsMasterClient;
		}

		private void SetPlayerXR()
		{
			GameObject gameObject = player.transform.Find("Head").gameObject;
			GameObject gameObject2 = player.transform.Find("LeftHand").gameObject;
			GameObject gameObject3 = player.transform.Find("RightHand").gameObject;
			player.SetHandPos(isThrow: false, isRightHand: false);
			player.SetHandPos();
			XRRig xRRig = player.gameObject.AddComponent<XRRig>();
			xRRig.cameraGameObject = gameObject;
			xRRig.TrackingOriginMode = TrackingOriginModeFlags.Floor;
			gameObject.AddComponent<Camera>().nearClipPlane = 0.01f;
			gameObject.AddComponent<AudioListener>();
			gameObject.AddComponent<UniversalAdditionalCameraData>();
			gameObject.AddComponent<UnityEngine.SpatialTracking.TrackedPoseDriver>();
			UnityEngine.XR.Interaction.Toolkit.XRController xRController = gameObject2.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController.controllerNode = XRNode.LeftHand;
			xRController.selectUsage = InputHelpers.Button.Trigger;
			gameObject2.AddComponent<XRRayInteractor>();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.controllerType == GameData_DDOL.ControllerType.Oculus)
			{
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(-0.04256378f, -0.007287227f, 0.04351463f);
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(10f, -1.929f, 0.406f));
			}
			else
			{
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(-0.04719797f, -0.03611124f, -0.03386807f);
				gameObject2.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(41.459f, -14.14f, -16.107f));
			}
			gameObject2.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
			gameObject2.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual = gameObject2.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual.lineWidth = 0.015f;
			xRInteractorLineVisual.lineLength = 1.5f;
			xRInteractorLineVisual.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			UnityEngine.XR.Interaction.Toolkit.XRController xRController2 = gameObject3.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController2.controllerNode = XRNode.RightHand;
			xRController2.selectUsage = InputHelpers.Button.Trigger;
			gameObject3.AddComponent<XRRayInteractor>();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.controllerType == GameData_DDOL.ControllerType.Oculus)
			{
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(0.04256378f, -0.007287227f, 0.04351463f);
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(10f, 1.929f, -0.406f));
			}
			else
			{
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localPosition = new Vector3(0.04719797f, -0.03611124f, -0.03386807f);
				gameObject3.GetComponent<XRRayInteractor>().attachTransform.localRotation = Quaternion.Euler(new Vector3(41.459f, 14.14f, 16.107f));
			}
			gameObject3.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
			gameObject3.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual2 = gameObject3.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual2.lineWidth = 0.015f;
			xRInteractorLineVisual2.lineLength = 1.5f;
			xRInteractorLineVisual2.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual2.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
		}

		public void StartDelayController(bool isRight)
		{
			StartCoroutine(DelayControllerOn_C(isRight, 30, 1f));
		}

		public void DelayController(bool isRight, int value, float time)
		{
			StartCoroutine(DelayControllerOn_C(isRight, value, time));
		}

		private IEnumerator DelayControllerOn_C(bool isRight, int value, float time)
		{
			yield return YieldInstructionCache.WaitForSeconds(time);
			if (isRight)
			{
				player.LeftHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
				player.RightHand.GetComponent<XRRayInteractor>().maxRaycastDistance = value;
			}
			else
			{
				player.LeftHand.GetComponent<XRRayInteractor>().maxRaycastDistance = value;
				player.RightHand.GetComponent<XRRayInteractor>().maxRaycastDistance = 0f;
			}
		}

		public void ShakeNet()
		{
			StartCoroutine(ShakeNet_C());
		}

		private IEnumerator ShakeNet_C()
		{
			net.position += new Vector3(0f, -0.05f, 0f);
			yield return YieldInstructionCache.WaitForSeconds(Time.fixedDeltaTime);
			net.position += new Vector3(0f, 0.05f, 0f);
		}

		public void ScoreSerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<int>)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					score_P2 = (packet as LumpsData<int>).lumps;
				}
				else
				{
					score_P1 = (packet as LumpsData<int>).lumps;
				}
			}
		}

		public void LeftPlayer_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				Rack.gameObject.SetActive(value: false);
				isGameStart = false;
				string nickName = PhotonNetwork.LocalPlayer.NickName;
				int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
				PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
			}
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			Rack.gameObject.SetActive(value: false);
			isGameStart = false;
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}

		public void TimeOutStop_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				if ((packet as LumpsData<bool>).lumps)
				{
					UnityEngine.Debug.LogError("멈춤");
					Time.timeScale = 0f;
				}
				else
				{
					UnityEngine.Debug.LogError("풀림");
					Time.timeScale = playTimeScale;
				}
			}
		}
	}
	public class Net_SGT : SingletonBase.Singleton<Net_SGT>
	{
		private Cloth cloth;

		private int ballCnt;

		private CapsuleCollider[] ballCollider = new CapsuleCollider[6];

		private void Start()
		{
			cloth = GetComponentInChildren<Cloth>();
			cloth.capsuleColliders = new CapsuleCollider[6];
		}

		public void AddCollider(CapsuleCollider collider)
		{
			ballCollider[ballCnt] = collider;
			cloth.capsuleColliders = ballCollider;
			ballCnt++;
			if (ballCnt == 5)
			{
				ballCnt = 0;
			}
		}

		public void ClearCloth()
		{
			if (!(cloth == null))
			{
				cloth.enabled = false;
				cloth.enabled = true;
			}
		}
	}
	public class Physics_SGT : SingletonBase.Singleton<Physics_SGT>
	{
		private GameObject BB_BALL;

		public Vector3 BB_BALL_ArrivalPos;

		public float BB_BALL_ThrowTime;

		private GameObject ball;

		private void Start()
		{
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ThowBall_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(CreateBall_Multi);
		}

		private void Update()
		{
		}

		public void CreateBall(Transform parent)
		{
			if (SingletonPunBase.Singleton<UI_SGT>.GetInstance.anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
			{
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.ClickButton("Start");
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					BB_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_B"), parent);
				}
				else
				{
					BB_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_R"), parent);
				}
				LumpsData<string> data = new LumpsData<string>
				{
					lumps = parent.gameObject.name
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(CreateBall_Multi, data, RpcTarget.Others);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
			{
				BB_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL"), parent);
			}
			else
			{
				BB_BALL = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL_B"), parent);
			}
		}

		public void ThrowBall()
		{
			if (!(BB_BALL == null))
			{
				Rigidbody component = BB_BALL.GetComponent<Rigidbody>();
				BB_BALL.GetComponent<Ball_CTRL>().isMine = true;
				component.transform.SetParent(null);
				component.isKinematic = false;
				component.velocity = RootPhysics.GetVelocity(component.position, BB_BALL_ArrivalPos, BB_BALL_ThrowTime);
				component.angularVelocity = new Vector3(-5f, 0f, 0f);
				SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component.GetComponent<CapsuleCollider>());
				BB_BALL = null;
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					BallData data = new BallData
					{
						position = component.transform.position,
						velocity = component.velocity,
						angularVelocity = component.angularVelocity,
						photonTime = PhotonNetwork.Time
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ThowBall_Multi, data, RpcTarget.Others);
				}
			}
		}

		public void CreateBall_Multi(SerializableClass packet)
		{
			string lumps = (packet as LumpsData<string>).lumps;
			if (lumps == "Head")
			{
				ball = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BB_BALL"), GameObject.Find("Others/Head").transform);
			}
			ball.GetComponent<Rigidbody>().useGravity = false;
		}

		public void ThowBall_Multi(SerializableClass packet)
		{
			if (packet is BallData && !(ball == null))
			{
				Rigidbody component = ball.GetComponent<Rigidbody>();
				ball.GetComponent<Ball_CTRL>().isMine = false;
				Vector3 position = (packet as BallData).position;
				Vector3 velocity = (packet as BallData).velocity;
				double num = (double)(float)PhotonNetwork.Time - (packet as BallData).photonTime;
				float x = position.x + velocity.x * (float)num;
				float y = position.y + velocity.y * (float)num + 0.5f * Physics.gravity.y * (float)(num * num);
				float z = position.z + velocity.z * (float)num;
				float num2 = Physics.gravity.y * (float)num;
				velocity.y += num2;
				ball.transform.position = new Vector3(x, y, z);
				component.position = new Vector3(x, y, z);
				component.transform.SetParent(null);
				component.useGravity = true;
				component.isKinematic = false;
				component.angularVelocity = (packet as BallData).angularVelocity;
				component.velocity = velocity;
				SingletonBase.Singleton<Net_SGT>.GetInstance.AddCollider(component.GetComponent<CapsuleCollider>());
				ball = null;
			}
		}
	}
	public class Sound_SGT : SingletonPunBase.Singleton<Sound_SGT>
	{
		private AudioSource audioSource;

		private AudioSource audioSource2;

		public AudioClip clip_ButtonFocus;

		public AudioClip clip_ButtonPress;

		public AudioClip clip_StartBuzzer;

		public AudioClip clip_EndBuzzer;

		public AudioClip clip_TimeFlow;

		public AudioClip clip_Goal;

		public AudioClip clip_EndBuzzer_Cn;

		public AudioClip clip_BankShot_Cn;

		public AudioClip clip_CleanShot_Cn;

		public AudioClip clip_BankShot;

		public AudioClip clip_CleanShot;

		public AudioClip clip_Combo;

		public AudioClip clip_NiceShot1;

		public AudioClip clip_NiceShot2;

		public AudioClip[] clip_Cheer;

		private void Start()
		{
			audioSource2 = GetComponent<AudioSource>();
			audioSource = GetComponentInChildren<AudioSource>();
		}

		public void PlaySound(AudioClip clip)
		{
			audioSource.pitch = 1f;
			audioSource.PlayOneShot(clip);
		}

		public void PlaySound(AudioClip[] clip)
		{
			audioSource2.PlayOneShot(clip[UnityEngine.Random.Range(0, clip.Length)]);
		}
	}
	public class UI_SGT : SingletonPunBase.Singleton<UI_SGT>
	{
		public enum UI_State
		{
			None,
			Start,
			EndS,
			EndM,
			Exit
		}

		private Canvas canvas;

		[Header("InfoS")]
		public Text text_InfoSTime;

		public Text text_InfoSScore;

		[Header("EndS")]
		public Text text_EndSScore;

		public Text text_EndSRate;

		public Text text_EndSCombo;

		public Text text_EndSMaxScore;

		[Header("EndM")]
		public Text text_EndMName_P1;

		public Text text_EndMName_P2;

		public Text text_EndMScore_P1;

		public Text text_EndMScore_P2;

		public Text text_Result;

		public TextMesh howToPlay;

		[Header("Button")]
		public GameObject RePlayButton;

		private bool isReadyStart;

		private bool isReady;

		private bool isReady_Others;

		private int preTime;

		private int preScore;

		public UI_State ui_State { get; set; }

		public Animator anim { get; set; }

		protected override void Awake()
		{
			base.Awake();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ReadySerial_Multi);
		}

		private void Start()
		{
			ui_State = UI_State.None;
			canvas = GetComponent<Canvas>();
			anim = GetComponent<Animator>();
			StartGame();
			StartCoroutine(ConnectUICamera_C());
			AnimationPlay("StartOpen");
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0040", howToPlay);
		}

		private void FixedUpdate()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && !isReadyStart && isReady && isReady_Others)
			{
				isReadyStart = true;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
			}
		}

		public void AnimationPlay(string str)
		{
			switch (str)
			{
			case "StartOpen":
				ui_State = UI_State.Start;
				break;
			case "EndSOpen":
				ui_State = UI_State.EndS;
				EndSResult();
				return;
			case "EndSClose":
				ui_State = UI_State.Start;
				return;
			case "EndMOpen":
				ui_State = UI_State.EndM;
				EndMResult();
				return;
			case "ExitOpen":
				ui_State = UI_State.Exit;
				break;
			default:
				ui_State = UI_State.None;
				break;
			}
			anim.SetTrigger(str);
		}

		public void ClickButton(string str)
		{
			switch (str)
			{
			case "Start":
				AnimationPlay("StartClose");
				break;
			case "RePlay":
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					isReady = true;
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = true
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
				}
				break;
			case "Play":
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isClickMouse1 = false;
				AnimationPlay("ExitClose");
				break;
			case "Exit":
				SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut(delegate
				{
					GotoLobby();
				});
				break;
			}
		}

		public void DelaySerialAnimation(string animFirst, string animSecond, float time)
		{
			StartCoroutine(DelaySerialAnimation_C(animFirst, animSecond, time));
		}

		private IEnumerator DelaySerialAnimation_C(string animFirst, string animSecond, float time)
		{
			AnimationPlay(animFirst);
			yield return YieldInstructionCache.WaitForSeconds(time);
			AnimationPlay(animSecond);
		}

		private IEnumerator DelayStart_C()
		{
			yield return YieldInstructionCache.WaitForSeconds(10f);
			if (anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
			{
				AnimationPlay("StartClose");
			}
		}

		private IEnumerator ConnectUICamera_C()
		{
			while (canvas.worldCamera == null)
			{
				yield return YieldInstructionCache.WaitForSeconds(Time.deltaTime);
				canvas.worldCamera = Camera.main;
			}
		}

		private void CheckTime()
		{
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart)
			{
				int num = (int)Mathf.Floor(SingletonPunBase.Singleton<Game_SGT>.GetInstance.time);
				if (preTime != num)
				{
					preTime = num;
					text_InfoSTime.text = num.ToString();
				}
			}
		}

		private void CheckScore()
		{
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart)
			{
				int changePositionCount = SingletonPunBase.Singleton<Game_SGT>.GetInstance.changePositionCount;
				if (preScore != changePositionCount)
				{
					preScore = changePositionCount;
					text_InfoSScore.text = changePositionCount.ToString();
				}
			}
		}

		private void GotoLobby()
		{
			StartCoroutine(GotoLobby_C());
		}

		private IEnumerator GotoLobby_C()
		{
			yield return new WaitForSecondsRealtime(2f);
			SceneManager.LoadScene(0);
		}

		private void StartGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				isReady = true;
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = true
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
			}
		}

		private void EndSResult()
		{
			float num = (float)SingletonPunBase.Singleton<Game_SGT>.GetInstance.wholeGoalCount / (float)SingletonPunBase.Singleton<Game_SGT>.GetInstance.wholeThrowCount;
			int clearLevelData = 1;
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score >= 150 && SingletonPunBase.Singleton<Game_SGT>.GetInstance.score < 200)
			{
				clearLevelData = 3;
			}
			else if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score >= 200 && SingletonPunBase.Singleton<Game_SGT>.GetInstance.score < 250)
			{
				clearLevelData = 4;
			}
			else if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.score >= 250)
			{
				clearLevelData = 5;
			}
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData(clearLevelData);
			PublicGameUIManager.leaderBoard.MyScoreUpdate(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score);
			PublicGameUIManager.GetInstance.OpenResultBoard(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score.ToString(), new string[4]
			{
				GameSettingCtrl.GetLocalizationText("0050"),
				Mathf.Round(num * 100f) + "  %",
				GameSettingCtrl.GetLocalizationText("0058"),
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.maxComboCount + " " + GameSettingCtrl.GetLocalizationText("0045")
			});
		}

		private void EndMResult()
		{
			StartCoroutine(EndMResult_C());
		}

		public void ReadySerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				isReady_Others = (packet as LumpsData<bool>).lumps;
				UnityEngine.Debug.Log("준비됨");
			}
		}

		private IEnumerator EndMResult_C()
		{
			yield return new WaitForSecondsRealtime(2f);
			text_EndMScore_P1.text = SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P1.ToString();
			text_EndMScore_P2.text = SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2.ToString();
			int num = int.Parse(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P1.ToString());
			int num2 = int.Parse(SingletonPunBase.Singleton<Game_SGT>.GetInstance.score_P2.ToString());
			int num3 = ((num <= num2) ? ((num < num2) ? 1 : 2) : 0);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2 && num3 == 0)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
			}
			PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
			{
				text_EndMScore_P1.text.ToString(),
				text_EndMScore_P2.text.ToString()
			}, num3);
		}
	}
}
namespace BADMINTON
{
	public class ScorePlaneCtrl : MonoBehaviour
	{
		public static ScorePlaneCtrl instance;

		private Animator anim;

		public Text[] playerName;

		public Image[] image;

		public Sprite[] numSprite;

		private int minPoint;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			anim = GetComponent<Animator>();
		}

		public void SetData(string p1, string p2, int m_minPoint)
		{
			playerName[0].text = p1;
			playerName[1].text = p2;
			minPoint = m_minPoint;
			SetScore(0, 0);
		}

		public void SetScore(int p01, int p02)
		{
			if (p01 >= minPoint - 1 && p02 >= minPoint - 1)
			{
				if (p01 == p02 + 1)
				{
					image[0].gameObject.SetActive(value: true);
					image[1].gameObject.SetActive(value: true);
					image[2].gameObject.SetActive(value: false);
					image[3].gameObject.SetActive(value: false);
					image[0].sprite = numSprite[10];
					image[1].sprite = numSprite[11];
					anim.SetTrigger("Start");
					return;
				}
				if (p01 + 1 == p02)
				{
					image[0].gameObject.SetActive(value: false);
					image[1].gameObject.SetActive(value: false);
					image[2].gameObject.SetActive(value: true);
					image[3].gameObject.SetActive(value: true);
					image[2].sprite = numSprite[10];
					image[3].sprite = numSprite[11];
					anim.SetTrigger("Start");
					return;
				}
			}
			if (p01 > 9)
			{
				image[0].gameObject.SetActive(value: true);
				image[1].gameObject.SetActive(value: true);
				image[0].sprite = numSprite[p01 / 10];
				image[1].sprite = numSprite[p01 % 10];
			}
			else
			{
				image[0].gameObject.SetActive(value: false);
				image[1].gameObject.SetActive(value: true);
				image[1].sprite = numSprite[p01];
			}
			if (p02 > 9)
			{
				image[2].gameObject.SetActive(value: true);
				image[3].gameObject.SetActive(value: true);
				image[2].sprite = numSprite[p02 / 10];
				image[3].sprite = numSprite[p02 % 10];
			}
			else
			{
				image[2].gameObject.SetActive(value: false);
				image[3].gameObject.SetActive(value: true);
				image[3].sprite = numSprite[p02];
			}
			anim.SetTrigger("Start");
		}

		public void CloseScoreBoard()
		{
			anim.SetTrigger("End");
		}
	}
	public class AIPlayer_CTRL : MonoBehaviour
	{
		private struct HitPosTime
		{
			public string name;

			public float time;

			public Vector3 position;
		}

		private HitPosTime[] posTime = new HitPosTime[13];

		private Animator anim;

		private LookAtIK lookAtIK;

		private int currentHitPos;

		private Vector3 pos_HitTarget;

		private Vector3 pos_Move;

		private Vector3 pos_Serve;

		private bool isStableShot;

		private bool isMove;

		private bool isHit;

		private bool isHitFail;

		private int rallyCount;

		private float traceTime;

		private float countShotTime;

		private float distSpeed;

		private float speed = 2f;

		private float[] aiSmashProbability = new float[5] { 0.3f, 0.5f, 0.3f, 0.5f, 0.95f };

		private float[,] aiPlusTimes = new float[5, 4]
		{
			{ 0.3f, 0.4f, 0.5f, 0.6f },
			{ 0.25f, 0.35f, 0.45f, 0.6f },
			{ 0.2f, 0.3f, 0.4f, 0.5f },
			{ 0.15f, 0.25f, 0.35f, 0.5f },
			{ 0.1f, 0.2f, 0.3f, 0.4f }
		};

		public Transform[] trans_HitPos;

		public Transform trans_Spawn;

		public AudioSource hitSource;

		public AudioSource squeakSource;

		public ParticleSystem hitEffect;

		private Animator anim_TurnArrow;

		public AudioClip[] hitClips;

		public TextMeshPro service;

		private Coroutine StartServeCoroutine;

		private Coroutine IdleCoroutine;

		public bool isTrace { get; set; }

		public bool isSmash { get; set; }

		private void Awake()
		{
			anim = GetComponent<Animator>();
			GetComponent<CustomModelSettingCtrl>().InitCPU(CustomModelViewState.Normal, null, 0.1f);
			anim_TurnArrow = base.transform.Find("TurnArrow").GetComponent<Animator>();
		}

		private void Start()
		{
			StartCoroutine(SetLookAtIK());
			SetHitState();
			speed += (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level / 2f;
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0153", service);
			Custom(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
		}

		private void FixedUpdate()
		{
			if (isTrace)
			{
				BallTrace();
			}
			else if (isMove)
			{
				Move();
			}
			else if (IdleCoroutine == null)
			{
				StartIdle();
			}
		}

		private void StartServe()
		{
			SingletonBase.Singleton<ScoreFloor_SGT>.GetInstance.CloseScoreBoard();
			StopIdle();
			rallyCount = 0;
			if (StartServeCoroutine != null)
			{
				StopCoroutine(StartServeCoroutine);
			}
			bool isFor = !(UnityEngine.Random.Range(0f, 1f) < 0.5f);
			StartServeCoroutine = StartCoroutine(StartServe(isFor));
		}

		public void DelayStartServe()
		{
			anim_TurnArrow.SetTrigger("Play");
			Invoke("StartServe", 1f);
		}

		private IEnumerator StartServe(bool isFor)
		{
			if (isFor)
			{
				anim.SetTrigger("IdleForServe");
				yield return new WaitForSeconds(2.5f);
				anim_TurnArrow.SetTrigger("Stop");
				yield return new WaitForSeconds(0.5f);
				anim.SetTrigger("ForServe");
				yield return new WaitForSeconds(0.05f);
				SingletonBase.Singleton<Physics_SGT>.GetInstance.CreateShuttlecock_AI(trans_Spawn);
				yield return new WaitForSeconds(0.5f);
			}
			else
			{
				anim.SetTrigger("IdleBackServe");
				yield return new WaitForSeconds(2.5f);
				anim_TurnArrow.SetTrigger("Stop");
				yield return new WaitForSeconds(0.5f);
				anim.SetTrigger("BackServe");
				yield return new WaitForSeconds(0.33f);
				SingletonBase.Singleton<Physics_SGT>.GetInstance.CreateShuttlecock_AI(trans_Spawn);
				yield return new WaitForSeconds(0.07f);
			}
			SingletonBase.Singleton<Physics_SGT>.GetInstance.HitShuttlecock_AI(99, isStableShot: true);
			hitEffect.Play();
			PlayHitSound();
		}

		public void SetMove(Vector3 pos)
		{
			StopIdle();
			isMove = true;
			pos_Move = pos;
			traceTime = 0f;
			rallyCount = 0;
			pos_Serve = base.transform.position;
			distSpeed = speed / Vector3.Distance(pos_Serve, pos_Move);
			Vector3 normalized = (pos_Serve - pos_Move).normalized;
			anim.SetFloat("MoveX", normalized.x);
			anim.SetFloat("MoveZ", normalized.z);
			anim.SetBool("isMove", value: true);
		}

		public void Move()
		{
			traceTime += Time.fixedDeltaTime * distSpeed;
			if (traceTime >= 1f)
			{
				traceTime = 1f;
				isMove = false;
				anim.SetBool("isStep", value: false);
				anim.SetBool("isMove", value: false);
			}
			base.transform.position = Vector3.Lerp(pos_Serve, pos_Move, traceTime);
		}

		public void SetTrace(bool isShotFail, RootPhysics.PosTime[] parabolaCheckP, Vector3 endPos)
		{
			StopIdle();
			anim.SetLayerWeight(1, 1f);
			isMove = false;
			isTrace = true;
			isHit = false;
			isHitFail = isShotFail;
			CheckDistance(parabolaCheckP, endPos);
		}

		private void BallTrace()
		{
			countShotTime -= Time.fixedDeltaTime;
			if (!isHit && countShotTime <= posTime[currentHitPos].time)
			{
				isHit = true;
				anim.SetBool("isStep", value: false);
				anim.SetBool("isMove", value: false);
				squeakSource.Play();
				anim.SetTrigger(posTime[currentHitPos].name);
			}
			else
			{
				if (countShotTime <= 0f)
				{
					anim.SetLayerWeight(1, 0f);
					isTrace = false;
					if (!isHitFail && SingletonBase.Singleton<Physics_SGT>.GetInstance.shuttlecock.trans.position.z <= -0.1f)
					{
						SingletonBase.Singleton<Physics_SGT>.GetInstance.HitShuttlecock_AI(currentHitPos, isStableShot);
						hitEffect.Play();
						PlayHitSound();
					}
					return;
				}
				if (countShotTime <= 0.2f)
				{
					anim.SetLayerWeight(1, Mathf.Clamp01(anim.GetLayerWeight(1) - Time.fixedDeltaTime * 1f));
				}
			}
			traceTime += Time.fixedDeltaTime * distSpeed;
			if (traceTime >= 1f)
			{
				traceTime = 1f;
				anim.SetBool("isStep", value: false);
				anim.SetBool("isMove", value: false);
			}
			Vector3 vector = pos_HitTarget + posTime[currentHitPos].position;
			vector = new Vector3(vector.x, 0f, vector.z);
			base.transform.position = Vector3.Lerp(pos_Serve, vector, traceTime);
		}

		public void CheckDistance(RootPhysics.PosTime[] parabolaCheckP, Vector3 endPos)
		{
			int num = 3;
			if (endPos.z >= -0.5f)
			{
				num = 0;
			}
			else if (endPos.z >= -1f)
			{
				num = 1;
			}
			else if (endPos.z >= -2.5f || endPos.z <= -3.5f)
			{
				num = 2;
			}
			int num2 = 0;
			for (int i = 0; i < parabolaCheckP.Length; i++)
			{
				if (parabolaCheckP[i].position != Vector3.zero && (i != 0 || (!(Camera.main.transform.position.z <= 3.5f) && !(aiSmashProbability[(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance != null) ? (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1) : 0] <= UnityEngine.Random.Range(0f, 1f)))))
				{
					num2 = i;
					break;
				}
			}
			Vector3 vector = base.transform.position - endPos;
			int num3 = 0;
			if (Mathf.Abs(vector.z) < Mathf.Abs(vector.x))
			{
				num3 = ((vector.x < 0f) ? 1 : 2);
			}
			bool flag = true;
			for (int j = num2; j < parabolaCheckP.Length; j++)
			{
				if (!(parabolaCheckP[j].position == Vector3.zero) && (num != 0 || j == 8) && (num != 1 || j == 5 || j == 8) && (num != 2 || j != 0 || j != 1) && (j < 2 || (j + 1) % 3 == num3) && Vector3.Distance(trans_HitPos[j].position, parabolaCheckP[j].position) / speed + ((j <= 1) ? posTime[j].time : 0f) <= parabolaCheckP[j].time - 0.05f && posTime[j].time <= parabolaCheckP[j].time)
				{
					num2 = j;
					flag = false;
					break;
				}
			}
			if (flag)
			{
				isHitFail = true;
				num2 = StateFailCheckDistance(parabolaCheckP);
			}
			pos_Serve = base.transform.position;
			float num4 = Vector3.Distance(pos_Serve, parabolaCheckP[num2].position + posTime[num2].position);
			distSpeed = speed / num4;
			if (num2 <= 1)
			{
				anim.SetLayerWeight(1, 0f);
			}
			currentHitPos = num2;
			countShotTime = parabolaCheckP[num2].time;
			pos_HitTarget = parabolaCheckP[num2].position;
			traceTime = 0f;
			Vector3 normalized = (pos_Serve - pos_HitTarget + posTime[currentHitPos].position).normalized;
			anim.SetFloat("MoveX", normalized.x);
			anim.SetFloat("MoveZ", normalized.z);
			if (normalized.z < 0f && countShotTime < 1f)
			{
				anim.SetBool("isStep", value: true);
			}
			else
			{
				anim.SetBool("isMove", value: true);
			}
			isStableShot = GetCalculate(countShotTime, num4, rallyCount);
			rallyCount++;
		}

		public bool GetCalculate(float ballEndTime, float npcTargetDist, int rallyCount)
		{
			float num = 12f / (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			int[] array = new int[4]
			{
				0,
				(int)Mathf.Ceil(100f - Mathf.Clamp(3f - ballEndTime, 0f, 3f) * num),
				(int)Mathf.Ceil(100f - npcTargetDist * num),
				(int)Mathf.Ceil(100f - (float)rallyCount * num)
			};
			for (int i = 1; i < array.Length; i++)
			{
				if (array[i] > 0)
				{
					array[0] += array[i];
				}
			}
			if (rallyCount <= 2 || array[0] >= UnityEngine.Random.Range(0, 280))
			{
				return true;
			}
			return false;
		}

		public int StateFailCheckDistance(RootPhysics.PosTime[] parabolaCheckP)
		{
			int num = 2;
			float num2 = (parabolaCheckP[num].position - trans_HitPos[num].position).sqrMagnitude;
			for (int i = 3; i < parabolaCheckP.Length; i++)
			{
				float sqrMagnitude = (parabolaCheckP[i].position - trans_HitPos[i].position).sqrMagnitude;
				if (num2 > sqrMagnitude)
				{
					num = i;
					num2 = sqrMagnitude;
				}
			}
			return num;
		}

		public void SetWinAnim(bool isWInAI)
		{
			isTrace = false;
			isMove = false;
			anim.SetBool("isStep", value: false);
			anim.SetBool("isMove", value: false);
			StopIdle();
			float num = ((!(UnityEngine.Random.Range(0f, 1f) <= 0.5f)) ? 1 : 0);
			if (isWInAI)
			{
				anim.SetFloat("ResultNum", num);
			}
			else
			{
				anim.SetFloat("ResultNum", num + 2f);
			}
			anim.SetTrigger("Result");
		}

		private void StartIdle()
		{
			if (IdleCoroutine != null)
			{
				StopCoroutine(IdleCoroutine);
			}
			IdleCoroutine = StartCoroutine(IdlePlay());
		}

		private void StopIdle()
		{
			if (IdleCoroutine != null)
			{
				StopCoroutine(IdleCoroutine);
			}
			IdleCoroutine = null;
			anim.SetBool("IdlePlay", value: false);
			anim.SetLayerWeight(1, 0f);
		}

		private IEnumerator IdlePlay()
		{
			while (true)
			{
				yield return new WaitForSeconds(UnityEngine.Random.Range(5f, 8f));
				int value = ((UnityEngine.Random.Range(0f, 1f) < 0.5f) ? 1 : 2);
				anim.SetInteger("IdleNum", value);
				anim.SetBool("IdlePlay", value: true);
				yield return new WaitForSeconds(0.5f);
				anim.SetBool("IdlePlay", value: false);
				yield return new WaitForSeconds(2f);
			}
		}

		private IEnumerator SetLookAtIK()
		{
			Physics_SGT physics_Sgt = SingletonBase.Singleton<Physics_SGT>.GetInstance;
			lookAtIK = GetComponent<LookAtIK>();
			while (physics_Sgt.shuttlecock == null)
			{
				yield return null;
			}
			lookAtIK.solver.target = physics_Sgt.shuttlecock.trans;
		}

		public void PlayLookAtIK(bool isOn)
		{
			if (!(lookAtIK == null))
			{
				lookAtIK.enabled = isOn;
			}
		}

		private void SetHitState()
		{
			InsertHitState(0, "JumpSmash", 0.69f, trans_HitPos[0].position);
			InsertHitState(1, "Smash", 0.9f, trans_HitPos[1].position);
			InsertHitState(2, "MidU", 0.2f, trans_HitPos[2].position);
			InsertHitState(3, "RightU", 0.333f, trans_HitPos[3].position);
			InsertHitState(4, "LeftU", 0.267f, trans_HitPos[4].position);
			InsertHitState(5, "MidM", 0.3f, trans_HitPos[5].position);
			InsertHitState(6, "RightM", 0.333f, trans_HitPos[6].position);
			InsertHitState(7, "LeftM", 0.267f, trans_HitPos[7].position);
			InsertHitState(8, "MidL", 0.267f, trans_HitPos[8].position);
			InsertHitState(9, "RightL", 0.267f, trans_HitPos[9].position);
			InsertHitState(10, "LeftL", 0.267f, trans_HitPos[10].position);
			InsertHitState(11, "ForServe", 0.533f, trans_HitPos[0].position);
			InsertHitState(12, "BackServe", 0.4f, trans_HitPos[0].position);
		}

		private void InsertHitState(int index, string str, float time, Vector3 pos)
		{
			posTime[index].name = str;
			posTime[index].time = time;
			if (index <= 10)
			{
				posTime[index].position = base.transform.position - pos;
			}
		}

		public void PlayHitSound()
		{
			hitSource.clip = hitClips[UnityEngine.Random.Range(0, hitClips.Length)];
			hitSource.Play();
		}

		public void Custom(LanguageState language)
		{
			if (language == LanguageState.schinese)
			{
				service.font = SingletonPunBase.Singleton<UI_SGT>.GetInstance.font_Cn;
			}
			else
			{
				service.font = SingletonPunBase.Singleton<UI_SGT>.GetInstance.font_Us;
			}
		}
	}
	public class CatchCock_CTRL : MonoBehaviour
	{
		private Transform trans_Cock;

		private void Start()
		{
			trans_Cock = base.transform.GetChild(0);
			base.gameObject.SetActive(value: false);
		}

		private void LateUpdate()
		{
			Show();
		}

		private void Show()
		{
			if (!(Camera.main == null))
			{
				Transform transform = Camera.main.transform;
				Vector3 position = transform.position;
				Vector3 normalized = new Vector3(transform.forward.x, 0f, transform.forward.z).normalized;
				Vector3 b = new Vector3(position.x, position.y * 0.9f, position.z) + normalized * 0.5f;
				base.transform.position = Vector3.Lerp(base.transform.position, b, Time.fixedDeltaTime * 5f);
				base.transform.rotation = Quaternion.LookRotation(base.transform.position - position);
				trans_Cock.Rotate(0f, Time.fixedDeltaTime * 30f, 0f);
			}
		}

		public void Play()
		{
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Service_Cn);
			}
			else
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Service);
			}
			base.gameObject.SetActive(value: true);
		}

		public void Stop()
		{
			base.gameObject.SetActive(value: false);
		}
	}
	public class LEDScoreBoard_CTRL : MonoBehaviour
	{
		[Serializable]
		public struct LEDScoreBoardInfo
		{
			public Image[] gameScoreImage;

			public Image[] pointScoreImage;

			public Text name;
		}

		public LEDScoreBoardInfo[] player;

		public void SetData(string name_P1, string name_P2, int minPoint)
		{
			player[0].name.text = name_P1.ToString();
			player[1].name.text = name_P2.ToString();
			SetPointScore(0, 0, minPoint);
			SetGameScore(0, 0);
		}

		public void SetPointScore(int score_P1, int score_P2, int minPoint)
		{
			LEDScoreBoard_SGT getInstance = SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance;
			if (score_P1 >= minPoint - 1 && score_P2 >= minPoint - 1)
			{
				if (score_P1 == score_P2 + 1)
				{
					player[0].pointScoreImage[0].sprite = getInstance.sprites[11];
					player[0].pointScoreImage[1].sprite = getInstance.sprites[12];
					player[1].pointScoreImage[0].sprite = getInstance.sprites[10];
					player[1].pointScoreImage[1].sprite = getInstance.sprites[10];
					return;
				}
				if (score_P1 + 1 == score_P2)
				{
					player[0].pointScoreImage[0].sprite = getInstance.sprites[10];
					player[0].pointScoreImage[1].sprite = getInstance.sprites[10];
					player[1].pointScoreImage[0].sprite = getInstance.sprites[11];
					player[1].pointScoreImage[1].sprite = getInstance.sprites[12];
					return;
				}
			}
			int[] array = new int[2] { score_P1, score_P2 };
			for (int i = 0; i < 2; i++)
			{
				if (array[i] > 9)
				{
					player[i].pointScoreImage[0].sprite = getInstance.sprites[array[i] / 10];
					player[i].pointScoreImage[1].sprite = getInstance.sprites[array[i] % 10];
				}
				else
				{
					player[i].pointScoreImage[0].sprite = getInstance.sprites[0];
					player[i].pointScoreImage[1].sprite = getInstance.sprites[array[i]];
				}
			}
		}

		public void SetGameScore(int score_P1, int score_P2)
		{
			LEDScoreBoard_SGT getInstance = SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance;
			int[] array = new int[2] { score_P1, score_P2 };
			for (int i = 0; i < 2; i++)
			{
				switch (array[i])
				{
				case 0:
					player[i].gameScoreImage[0].sprite = getInstance.sprites[13];
					player[i].gameScoreImage[1].sprite = getInstance.sprites[13];
					break;
				case 1:
					player[i].gameScoreImage[0].sprite = getInstance.sprites[14];
					player[i].gameScoreImage[1].sprite = getInstance.sprites[13];
					break;
				case 2:
					player[i].gameScoreImage[0].sprite = getInstance.sprites[14];
					player[i].gameScoreImage[1].sprite = getInstance.sprites[14];
					break;
				}
			}
		}
	}
	public class Player_CTRL : MonoBehaviour
	{
		private PhotonView pv;

		private UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

		private UnityEngine.XR.Interaction.Toolkit.XRController RightController;

		private GameObject racket;

		private Quaternion rot_Racket;

		private Vector3 pos_Racket;

		private Animator anim_LeftHand;

		private Animator anim_RightHand;

		private bool isBallCharge;

		private float saveTime;

		private float revisionX;

		private float revisionY;

		private float revisionZ;

		private Vector3 savePos01;

		private Vector3 savePos02;

		private Vector3 pos_Move;

		private bool isBallSpawnTime;

		private bool isAutoMoving = true;

		public CatchCock_CTRL catchCock_Ctrl;

		public Transform TimeUI;

		public TextMesh TimeText;

		public TextMeshPro service;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnGripL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnGripR = new Appnori.Util.Notifier<bool>();

		private bool menuPopup;

		public GameObject MenuOBJ;

		private bool isTimeoutCoroutine;

		public Transform trans_Spawn_L { get; set; }

		public Transform trans_Spawn_R { get; set; }

		public Racket_CTRL racket_Ctrl { get; set; }

		public Transform Head { get; set; }

		public Transform LeftHand { get; set; }

		public Transform RightHand { get; set; }

		public bool isRightHand { get; set; } = true;


		public bool isMove { get; set; }

		public bool isService { get; set; }

		public float movePlusX { get; set; }

		public Animator anim_TurnArrow { get; set; }

		private void Awake()
		{
			pv = GetComponent<PhotonView>();
			Head = base.transform.Find("Head").transform;
			LeftHand = base.transform.Find("LeftHand").transform;
			RightHand = base.transform.Find("RightHand").transform;
			anim_LeftHand = LeftHand.GetComponentInChildren<Animator>();
			anim_RightHand = RightHand.GetComponentInChildren<Animator>();
			trans_Spawn_L = LeftHand.Find("HandModel/Spawn");
			trans_Spawn_R = RightHand.Find("HandModel/Spawn");
			racket = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BadmintonRacket_Anchor"), RightHand, worldPositionStays: false);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (pv.IsMine)
				{
					racket.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.pos;
					racket.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.rot;
				}
				else
				{
					racket.transform.localPosition = new Vector3(0.005f, 0.095f, -0.068f);
					racket.transform.localRotation = Quaternion.Euler(new Vector3(-36.709f, -94.789f, 101.525f));
				}
			}
			else
			{
				racket.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.pos;
				racket.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.rot;
			}
			rot_Racket = racket.transform.localRotation;
			pos_Racket = racket.transform.localPosition;
			racket_Ctrl = GetComponentInChildren<Racket_CTRL>();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && !pv.IsMine)
			{
				anim_TurnArrow = base.transform.Find("TurnArrow").GetComponent<Animator>();
				racket_Ctrl.isActive = false;
				racket_Ctrl.swingSource.gameObject.SetActive(value: false);
			}
			catchCock_Ctrl = GetComponentInChildren<CatchCock_CTRL>();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ChangeHand_Mul);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(TimeOut_Mul);
		}

		private void Start()
		{
			LeftController = LeftHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				SetRay(isOn: false);
				OnChangeHand(PublicGameUIManager.gameSetting.IsRightHanded());
				PublicGameUIManager.gameSetting.AddHandChangedEvent(OnChangeHand);
			}
			else if (pv.IsMine)
			{
				SetRay(isOn: false);
				OnChangeHand(PublicGameUIManager.gameSetting.IsRightHanded());
				PublicGameUIManager.gameSetting.AddHandChangedEvent(OnChangeHand);
			}
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
			OnGripL.OnDataChanged += OnGripL_OnDataChanged;
			OnGripR.OnDataChanged += OnGripR_OnDataChanged;
			if (service != null)
			{
				SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0153", service);
			}
			Custom(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (!isRightHand)
			{
				return;
			}
			if (obj)
			{
				if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart && SingletonPunBase.Singleton<Game_SGT>.GetInstance.isUISet)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart = true;
				}
				if (isRightHand)
				{
					anim_LeftHand.SetTrigger("Catch");
				}
				else
				{
					anim_RightHand.SetTrigger("Catch");
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.time > 0.5f)
				{
					TriggerPressed();
				}
			}
			else
			{
				if (isRightHand)
				{
					anim_LeftHand.SetTrigger("Idle");
				}
				else
				{
					anim_RightHand.SetTrigger("Idle");
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.servicePlayer == 0 && isBallCharge)
				{
					SingletonBase.Singleton<Physics_SGT>.GetInstance.DropShuttlecock_Player((savePos01 - savePos02) / saveTime * 2f);
					isBallCharge = false;
				}
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (isRightHand)
			{
				return;
			}
			if (obj)
			{
				if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart && SingletonPunBase.Singleton<Game_SGT>.GetInstance.isUISet)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.isGameStart = true;
				}
				if (isRightHand)
				{
					anim_LeftHand.SetTrigger("Catch");
				}
				else
				{
					anim_RightHand.SetTrigger("Catch");
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.time > 0.5f)
				{
					TriggerPressed();
				}
			}
			else
			{
				if (isRightHand)
				{
					anim_LeftHand.SetTrigger("Idle");
				}
				else
				{
					anim_RightHand.SetTrigger("Idle");
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.servicePlayer == 0 && isBallCharge)
				{
					SingletonBase.Singleton<Physics_SGT>.GetInstance.DropShuttlecock_Player((savePos01 - savePos02) / saveTime * 2f);
					isBallCharge = false;
				}
			}
		}

		private void OnGripL_OnDataChanged(bool obj)
		{
			if (obj)
			{
				isRightHand = false;
				ChangeHand(LeftHand.Find("HandModel"), RightHand.Find("HandModel"), "Grab", "Idle");
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = isRightHand
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ChangeHand_Mul, data, RpcTarget.Others);
				}
			}
		}

		private void OnGripR_OnDataChanged(bool obj)
		{
			if (obj)
			{
				isRightHand = true;
				ChangeHand(RightHand.Find("HandModel"), LeftHand.Find("HandModel"), "Idle", "Grab");
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = isRightHand
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ChangeHand_Mul, data, RpcTarget.Others);
				}
			}
		}

		private void OnChangeHand(bool isRight)
		{
			isRightHand = isRight;
			if (isRightHand)
			{
				ChangeHand(RightHand.Find("HandModel"), LeftHand.Find("HandModel"), "Idle", "Grab");
			}
			else
			{
				ChangeHand(LeftHand.Find("HandModel"), RightHand.Find("HandModel"), "Grab", "Idle");
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = isRightHand
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ChangeHand_Mul, data, RpcTarget.Others);
			}
		}

		private void Update()
		{
			Move();
			if (isBallCharge)
			{
				savePos02 = savePos01;
				if (isRightHand)
				{
					savePos01 = trans_Spawn_L.position;
				}
				else
				{
					savePos01 = trans_Spawn_R.position;
				}
				saveTime = Time.deltaTime;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (pv == null || !pv.IsMine)
				{
					return;
				}
				Vector3 normalized = (Head.position - TimeUI.position).normalized;
				TimeUI.rotation = Quaternion.LookRotation(normalized);
			}
			if (!SingletonPunBase.Singleton<UI_SGT>.GetInstance.isPublicUI)
			{
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
				{
					OnTriggerL.CurrentData = isPressed;
				}
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
				{
					OnTriggerR.CurrentData = isPressed2;
				}
			}
		}

		public void SetTimeLimit(float timeValue)
		{
			float num = 20f;
			string text = "";
			text = ((num * 0.3f > timeValue) ? ("<color=red>" + timeValue.ToString("0") + "</color>") : ((!(num * 0.6f > timeValue)) ? ("<color=white>" + timeValue.ToString("0") + "</color>") : ("<color=yellow>" + timeValue.ToString("0") + "</color>")));
			if (TimeText != null)
			{
				TimeText.text = text;
			}
		}

		private void ChangeHand(Transform racket, Transform hand, string animL, string animR)
		{
			this.racket.transform.SetParent(racket);
			this.racket.transform.localRotation = rot_Racket;
			Vector3 vector = pos_Racket;
			new Vector3(0f - vector.x, vector.y, vector.z);
			if (animL == "Grab")
			{
				this.racket.transform.localPosition = pos_Racket;
			}
			else
			{
				this.racket.transform.localPosition = pos_Racket;
			}
			anim_LeftHand.SetTrigger(animL);
			anim_RightHand.SetTrigger(animR);
		}

		private void TriggerPressed()
		{
			if (isBallSpawnTime && SingletonPunBase.Singleton<Game_SGT>.GetInstance.servicePlayer == 0)
			{
				isBallSpawnTime = false;
				catchCock_Ctrl.Stop();
				SingletonBase.Singleton<Physics_SGT>.GetInstance.CreateShuttlecock_Player();
				if (isRightHand)
				{
					savePos02 = trans_Spawn_L.position;
				}
				else
				{
					savePos02 = trans_Spawn_R.position;
				}
				savePos01 = savePos02;
				saveTime = 0f;
				isBallCharge = true;
			}
		}

		public void StartAnim(bool onoff)
		{
			menuPopup = onoff;
		}

		private IEnumerator TimeInfo_C()
		{
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("InfoSOpen");
			yield return new WaitForSecondsRealtime(2.5f);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("InfoSClose");
		}

		public void SpawnShuttleCockTime()
		{
			isBallSpawnTime = true;
			catchCock_Ctrl.Play();
		}

		public void DelaySpwanShuttlecockTime()
		{
			Invoke("SpawnShuttleCockTime", 0.5f);
		}

		public void Move()
		{
			if (!isMove)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				revisionX = SingletonPunBase.Singleton<Game_SGT>.GetInstance.pos_Shot.x;
				revisionZ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.pos_Shot.z + 0.3f;
				revisionX += movePlusX;
				revisionZ -= 0.8f;
				if (revisionZ >= 6.2f)
				{
					revisionZ = 6.2f;
				}
				else if (revisionZ <= 0.8f)
				{
					revisionZ = 0.8f;
				}
				if (revisionX >= 2f)
				{
					revisionX = 2f;
				}
				else if (revisionX <= -2f)
				{
					revisionX = -2f;
				}
			}
			else
			{
				revisionX = SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview.x;
				if (PhotonNetwork.IsMasterClient)
				{
					revisionZ = SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview.z + 0.3f;
				}
				else
				{
					revisionZ = SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview.z - 0.3f;
				}
				revisionX += movePlusX;
				revisionZ -= 0.8f;
				if (revisionX >= 2f)
				{
					revisionX = 2f;
				}
				else if (revisionX <= -2f)
				{
					revisionX = -2f;
				}
				if (PhotonNetwork.IsMasterClient)
				{
					if (pv.IsMine)
					{
						if (revisionZ >= 6.2f)
						{
							revisionZ = 6.2f;
						}
						else if (revisionZ <= 1.4f)
						{
							revisionZ = 1.4f;
						}
					}
					else if (revisionZ <= -6.2f)
					{
						revisionZ = -6.2f;
					}
					else if (revisionZ >= -1.4f)
					{
						revisionZ = -1.4f;
					}
				}
				else if (pv.IsMine)
				{
					if (revisionZ <= -6.2f)
					{
						revisionZ = -6.2f;
					}
					else if (revisionZ >= -1.4f)
					{
						revisionZ = -1.4f;
					}
				}
				else if (revisionZ >= 6.2f)
				{
					revisionZ = 6.2f;
				}
				else if (revisionZ <= 1.4f)
				{
					revisionZ = 1.4f;
				}
			}
			pos_Move = new Vector3(revisionX, revisionY, revisionZ);
			base.transform.position = Vector3.LerpUnclamped(base.transform.position, pos_Move, Time.fixedDeltaTime * 3.5f);
			if ((base.transform.position - pos_Move).sqrMagnitude <= 0.01f)
			{
				isMove = false;
			}
		}

		public void Haptic(float amplitude = 0.5f, float duration = 0.5f, bool isLeft = true)
		{
			if (!(LeftController == null) && !(RightController == null))
			{
				if (isLeft)
				{
					LeftController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
				else
				{
					RightController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
			}
		}

		public void SetRay(bool isOn)
		{
			if (isOn)
			{
				LeftHand.GetComponent<XRRayInteractor>().enabled = true;
				RightHand.GetComponent<XRRayInteractor>().enabled = true;
			}
			else
			{
				LeftHand.GetComponent<XRRayInteractor>().enabled = false;
				RightHand.GetComponent<XRRayInteractor>().enabled = false;
			}
		}

		public void ChangeHand_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				StartCoroutine(ChangeHand_Mul_C((packet as LumpsData<bool>).lumps));
			}
		}

		private IEnumerator ChangeHand_Mul_C(bool isRight)
		{
			while (SingletonPunBase.Singleton<Game_SGT>.GetInstance.others == null)
			{
				yield return null;
			}
			Vector3 localPosition = pos_Racket;
			Vector3 localPosition2 = new Vector3(0f - localPosition.x, localPosition.y, localPosition.z);
			if (isRight)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.racket.transform.SetParent(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.RightHand.Find("HandModel"));
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.racket.transform.localPosition = localPosition;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.racket.transform.localRotation = rot_Racket;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.anim_LeftHand.SetTrigger("Idle");
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.anim_RightHand.SetTrigger("Grab");
			}
			else
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.racket.transform.SetParent(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.LeftHand.Find("HandModel"));
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.racket.transform.localPosition = localPosition2;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.racket.transform.localRotation = rot_Racket;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.anim_LeftHand.SetTrigger("Grab");
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.anim_RightHand.SetTrigger("Idle");
			}
		}

		public void TimeOut_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.anim_TurnArrow.SetTrigger("Stop");
			}
		}

		public void Custom(LanguageState language)
		{
			if (!(service == null))
			{
				if (language == LanguageState.schinese)
				{
					service.font = SingletonPunBase.Singleton<UI_SGT>.GetInstance.font_Cn;
				}
				else
				{
					service.font = SingletonPunBase.Singleton<UI_SGT>.GetInstance.font_Us;
				}
			}
		}
	}
	public class Racket_CTRL : MonoBehaviour
	{
		private Transform trans_MoveTarget;

		private Rigidbody rigid;

		private Vector3 savePos;

		private float sphereCollTime;

		public AudioSource hitSource;

		public AudioSource swingSource;

		public AudioClip[] hitClips;

		public ParticleSystem hitEffect;

		private Coroutine SetHideStateCoroutine;

		public Vector3 velo { get; set; } = Vector3.zero;


		public bool isPlay { get; set; }

		public bool isActive { get; set; } = true;


		private void Awake()
		{
			rigid = GetComponent<Rigidbody>();
			trans_MoveTarget = base.transform.parent;
			base.transform.SetParent(base.transform.root);
			rigid.MovePosition(trans_MoveTarget.position);
			savePos = trans_MoveTarget.position;
		}

		private void Update()
		{
			if (isActive)
			{
				PhysCalculate();
			}
		}

		private void PhysCalculate()
		{
			if (Time.fixedDeltaTime == 0f)
			{
				return;
			}
			velo = (trans_MoveTarget.position - savePos) / Time.deltaTime;
			savePos = trans_MoveTarget.position;
			if (isPlay && rigid.gameObject.layer != LayerMask.NameToLayer("CueBall"))
			{
				RaycastHit[] array = Physics.SphereCastAll(rigid.position, 0.4f, (trans_MoveTarget.position - rigid.position).normalized, (trans_MoveTarget.position - rigid.position).magnitude);
				for (int i = 0; i < array.Length; i++)
				{
					if (!array[i].transform.CompareTag("Ball"))
					{
						continue;
					}
					if (SingletonBase.Singleton<Physics_SGT>.GetInstance.shuttlecock == null || SingletonBase.Singleton<Physics_SGT>.GetInstance.shuttlecock.isNet)
					{
						return;
					}
					if (!SingletonBase.Singleton<Physics_SGT>.GetInstance.shuttlecock.isPlay)
					{
						continue;
					}
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						if (PhotonNetwork.IsMasterClient)
						{
							if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotPlayer != 0)
							{
								OnBallEnter();
							}
						}
						else if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotPlayer != 1)
						{
							OnBallEnter();
						}
					}
					else if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotPlayer != 0)
					{
						OnBallEnter();
					}
					return;
				}
			}
			rigid.MovePosition(trans_MoveTarget.position);
			rigid.MoveRotation(trans_MoveTarget.rotation);
			float num = velo.magnitude * 0.04f - 0.04f;
			if (swingSource.volume >= num)
			{
				num = swingSource.volume - Time.deltaTime * 5f;
			}
			if (num < 0f)
			{
				num = 0f;
			}
			else if (num > 1f)
			{
				num = 1f;
			}
			swingSource.volume = num;
			swingSource.pitch = swingSource.volume + 1f;
		}

		public void OnBallEnter()
		{
			PlayHitSound();
			hitEffect.Play();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (base.transform.root.name == "Player")
				{
					SetShotTime();
					SingletonBase.Singleton<Physics_SGT>.GetInstance.HitShuttlecock_Player();
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.isTimeFlow = false;
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.audio_TimeTick.Stop();
				}
			}
			else
			{
				SetShotTime();
				SingletonBase.Singleton<Physics_SGT>.GetInstance.HitShuttlecock_Player();
			}
		}

		public void OtherOnBallEnter()
		{
			OtherPlayHitSound();
			hitEffect.Play();
		}

		public void SetShotTime()
		{
			rigid.gameObject.layer = LayerMask.NameToLayer("CueBall");
			if (SetHideStateCoroutine != null)
			{
				StopCoroutine(SetHideStateCoroutine);
			}
			SetHideStateCoroutine = StartCoroutine(SetHideState());
		}

		private IEnumerator SetHideState()
		{
			yield return new WaitForSeconds(0.5f);
			rigid.gameObject.layer = LayerMask.NameToLayer("Ball");
		}

		public void PlayHitSound()
		{
			float num = velo.magnitude * 0.06f - 0.04f;
			if (num < 0f)
			{
				num = 0f;
			}
			else if (num > 1f)
			{
				num = 1f;
			}
			hitSource.clip = hitClips[UnityEngine.Random.Range(0, hitClips.Length)];
			hitSource.volume = num;
			hitSource.Play();
		}

		public void OtherPlayHitSound()
		{
			hitSource.clip = hitClips[UnityEngine.Random.Range(0, hitClips.Length)];
			hitSource.volume = 0.7f;
			hitSource.Play();
		}
	}
	public class ServiceEffect_CTRL : MonoBehaviour
	{
		private Animator anim;

		private void Awake()
		{
			anim = GetComponent<Animator>();
		}

		public void SetState(int num)
		{
			switch (num)
			{
			case 0:
				anim.SetTrigger("State00");
				break;
			case 1:
				anim.SetTrigger("State01");
				break;
			case 2:
				anim.SetTrigger("State02");
				break;
			}
		}
	}
	public class Shuttlecock_CTRL : MonoBehaviour
	{
		private Vector3 startVeloc;

		private Vector3 startPos;

		private Vector3 savePos;

		private float gravity = -5.81f;

		private float drag = 1.6f;

		private float time;

		private TrailRenderer trail;

		private GameObject effect_Smash;

		public AudioSource audioSource;

		public AudioClip[] audioSounds;

		public Transform trans { get; set; }

		public Rigidbody rigid { get; set; }

		public bool isPlay { get; set; }

		public bool isNet { get; set; }

		public Vector3 currentVelo { get; set; }

		private void Awake()
		{
			trans = base.transform;
			rigid = GetComponent<Rigidbody>();
			trail = trans.Find("Trail").GetComponent<TrailRenderer>();
			effect_Smash = trans.Find("SmashEffect").gameObject;
		}

		private void Start()
		{
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(CockSinc_Multi);
		}

		public void Grap()
		{
			isPlay = false;
			isNet = false;
			trail.enabled = false;
			rigid.useGravity = false;
			rigid.velocity = Vector3.zero;
			rigid.constraints = RigidbodyConstraints.FreezeAll;
			audioSource.clip = audioSounds[3];
			audioSource.Play();
		}

		public void SetStop()
		{
			isPlay = false;
			trail.Clear();
			trail.enabled = false;
			rigid.isKinematic = false;
			rigid.velocity = Vector3.zero;
			rigid.useGravity = true;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl != null)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl.PlayLookAtIK(isOn: false);
				}
			}
			else
			{
				LumpsData<Vector3> data = new LumpsData<Vector3>
				{
					lumps = trans.position
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(CockSinc_Multi, data, RpcTarget.Others);
			}
		}

		public void SetPlay(Vector3 m_veloc, bool isSmash = false)
		{
			isPlay = true;
			trail.enabled = true;
			rigid.useGravity = false;
			rigid.isKinematic = true;
			rigid.velocity = Vector3.zero;
			rigid.Sleep();
			rigid.constraints = RigidbodyConstraints.None;
			startVeloc = m_veloc;
			startPos = base.transform.position;
			savePos = startPos;
			time = 0f;
			effect_Smash.SetActive(isSmash);
			if (isSmash)
			{
				audioSource.clip = audioSounds[0];
				audioSource.Play();
				StartCoroutine(effectSmashReset());
			}
		}

		public void SetPosition(Vector3 pos, Quaternion rot)
		{
			base.transform.position = pos;
			base.transform.rotation = rot;
		}

		private void FixedUpdate()
		{
			if (isPlay)
			{
				PhysMove();
			}
		}

		private void PhysMove()
		{
			Vector3 vector = startVeloc;
			vector /= 1f + drag * time;
			float num = gravity * (0.5f * time);
			vector.y += num;
			vector *= time;
			rigid.MovePosition(startPos + vector);
			SingletonBase.Singleton<Physics_SGT>.GetInstance.ShuttleCockCollider.MovePosition(rigid.position);
			RaycastHit[] array = Physics.RaycastAll(savePos, base.transform.position - savePos, Vector3.Distance(base.transform.position, savePos));
			if (array.Length != 0)
			{
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i].transform.CompareTag("NetColl"))
					{
						StartCoroutine(NetCapculeScaleCoroutine());
						SetStop();
						int num2 = UnityEngine.Random.Range(1, audioSounds.Length);
						if (num2 > audioSounds.Length - 1)
						{
							num2 = audioSounds.Length - 1;
						}
						audioSource.clip = audioSounds[num2];
						audioSource.Play();
						if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
						{
							SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Net_Cn);
						}
						else
						{
							SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Net);
						}
						SingletonPunBase.Singleton<Game_SGT>.GetInstance.SetTurn(base.transform.position, isNet: true);
						return;
					}
					if (array[i].transform.CompareTag("NetDown"))
					{
						isNet = true;
					}
					else
					{
						if (!array[i].transform.CompareTag("Map"))
						{
							continue;
						}
						if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
						{
							trans.position = new Vector3(trans.position.x, 0.1f, trans.position.z);
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.SetTurn(base.transform.position, isNet);
							SetStop();
						}
						else if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotPlayer == 0)
						{
							if (!PhotonNetwork.IsMasterClient)
							{
								trans.position = new Vector3(trans.position.x, 0.1f, trans.position.z);
								SingletonPunBase.Singleton<Game_SGT>.GetInstance.SetTurn(base.transform.position, isNet);
								SetStop();
							}
							else
							{
								trans.position = new Vector3(trans.position.x, 0.1f, trans.position.z);
								isPlay = false;
								rigid.isKinematic = false;
								rigid.useGravity = true;
								rigid.velocity = Vector3.zero;
							}
						}
						else if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotPlayer == 1)
						{
							if (!PhotonNetwork.IsMasterClient)
							{
								trans.position = new Vector3(trans.position.x, 0.1f, trans.position.z);
								isPlay = false;
								rigid.isKinematic = false;
								rigid.useGravity = true;
								rigid.velocity = Vector3.zero;
							}
							else
							{
								trans.position = new Vector3(trans.position.x, 0.1f, trans.position.z);
								SingletonPunBase.Singleton<Game_SGT>.GetInstance.SetTurn(base.transform.position, isNet);
								SetStop();
							}
						}
						else
						{
							trans.position = new Vector3(trans.position.x, 0.1f, trans.position.z);
							SingletonPunBase.Singleton<Game_SGT>.GetInstance.SetTurn(base.transform.position, isNet);
							SetStop();
						}
					}
				}
			}
			currentVelo = (base.transform.position - savePos) / Time.fixedDeltaTime;
			Quaternion b = Quaternion.LookRotation(base.transform.position - savePos);
			rigid.MoveRotation(Quaternion.Lerp(base.transform.rotation, b, currentVelo.sqrMagnitude * 0.1f));
			savePos = base.transform.position;
			time += Time.fixedDeltaTime;
		}

		private void DelayNetColl()
		{
		}

		private IEnumerator NetCapculeScaleCoroutine()
		{
			SingletonBase.Singleton<Physics_SGT>.GetInstance.ShuttleCockCollider.transform.localScale = Vector3.one * 0.3f;
			yield return new WaitForSeconds(0.1f);
			SingletonBase.Singleton<Physics_SGT>.GetInstance.ShuttleCockCollider.transform.localScale = Vector3.one * 0.001f;
		}

		private IEnumerator effectSmashReset()
		{
			yield return new WaitForSeconds(4f);
			effect_Smash.SetActive(value: false);
		}

		public void CockSinc_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<Vector3>)
			{
				if (trail != null)
				{
					trail.Clear();
					trail.enabled = false;
				}
				if (rigid != null)
				{
					rigid.isKinematic = false;
					rigid.useGravity = true;
					rigid.velocity = Vector3.zero;
				}
			}
		}
	}
	public class Trail_CTRL : MonoBehaviour
	{
		private GameObject parent;

		private Transform trans;

		private Rigidbody rigid_parent;

		private void Start()
		{
			parent = base.transform.parent.gameObject;
			trans = GetComponent<Transform>();
			rigid_parent = parent.GetComponent<Rigidbody>();
		}

		private void FixedUpdate()
		{
			base.transform.LookAt(trans.position + rigid_parent.velocity);
		}

		public void DestroyParticle(float time)
		{
			UnityEngine.Object.Destroy(base.gameObject, time);
		}
	}
	public class Game_SGT : SingletonPunBase.Singleton<Game_SGT>
	{
		private PhotonView pv;

		public Transform[] checkLevels;

		private Vector3 setServePos0 = new Vector3(0f, 0f, 4.2f);

		private Vector3 setServePos1 = new Vector3(1.25f, 0f, 4.2f);

		private Vector3 setServePos2 = new Vector3(-1.25f, 0f, 4.2f);

		private string[] playerName = new string[2] { "Player", "CPU" };

		private bool isTimeTick;

		private float playTimeScale = 1f;

		private int gameEndMinPoint = 6;

		private int gameEndRound = 1;

		private int[] pointScore = new int[2];

		public Material rayMaterial;

		public Material handMaterial;

		private bool isMasterClient;

		public ServiceEffect_CTRL[] serviceEffect_Ctrl;

		public Animation anim_Billboard;

		public Text[] text_Player1;

		public Text[] text_Player2;

		public GameObject display_Us;

		public GameObject display_Cn;

		public bool isGameStart { get; set; }

		public bool isUISet { get; set; }

		public float courtX { get; set; } = 2.40224f;


		public float courtZ { get; set; } = 6.668443f;


		public float outX { get; set; } = 2.954995f;


		public float serviceInX { get; set; }

		public float serviceOutX { get; set; } = 2.40224f;


		public float serviceInZ { get; set; } = 2.053405f;


		public float serviceOutZ { get; set; } = 6.019182f;


		public Vector3 pos_Shot { get; set; } = new Vector3(-1f, -0.008f, 3f);


		public float time { get; set; } = 20f;


		public int timeOutCount { get; set; }

		public bool isTimeFlow { get; set; }

		public int servicePlayer { get; set; }

		public int shotPlayer { get; set; } = -2;


		public bool isDeuce { get; set; }

		public bool isSetTurn { get; set; }

		public Player_CTRL player { get; set; }

		public Player_CTRL others { get; set; }

		public AIPlayer_CTRL aiPlayer_Ctrl { get; set; }

		private void Start()
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomHand();
			Time.timeScale = playTimeScale;
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(SerialScore_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(LeftPlayer_Mul);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(TimeOut_Mul);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(GameEnd_Mul);
			pv = GetComponent<PhotonView>();
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.SetData(gameEndMinPoint);
			SpawnPlayer();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				StartCoroutine(DelaySpawnOtherVRIK_C());
				playerName[0] = "Player1";
				playerName[1] = "Player2";
				SingletonBase.Singleton<ScoreFloor_SGT>.GetInstance.SetData(playerName[0], playerName[1], gameEndMinPoint);
				SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetData(playerName[0], playerName[1], gameEndMinPoint);
				if (PhotonNetwork.IsMasterClient)
				{
					servicePlayer = 0;
				}
				else
				{
					servicePlayer = 1;
				}
			}
			else
			{
				SingletonBase.Singleton<ScoreFloor_SGT>.GetInstance.SetData(playerName[0], playerName[1], gameEndMinPoint);
				SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetData(playerName[0], playerName[1], gameEndMinPoint);
				Text[] array = text_Player1;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
				}
				array = text_Player2;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
				}
			}
			ScoreView();
			anim_Billboard["Billboard_move01"].speed = 0.35f;
			Custom(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
		}

		private void Update()
		{
			TimeFlowGame();
		}

		private void TimeFlowGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi || servicePlayer != 0 || !isTimeFlow)
			{
				return;
			}
			time -= Time.deltaTime * 1f / playTimeScale;
			if (time <= 0f)
			{
				isTimeFlow = false;
				timeOutCount++;
				if (PhotonNetwork.IsMasterClient)
				{
					shotPlayer = 0;
				}
				else
				{
					shotPlayer = 1;
				}
				player.catchCock_Ctrl.Stop();
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.audio_TimeTick.Stop();
				if (PhotonNetwork.IsMasterClient)
				{
					if (timeOutCount >= 2)
					{
						LumpsData<int> data = new LumpsData<int>
						{
							lumps = 1
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(GameEnd_Mul, data, RpcTarget.Others);
						isGameStart = false;
						PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
						{
							pointScore[0].ToString(),
							pointScore[1].ToString()
						}, 1);
						return;
					}
				}
				else if (timeOutCount >= 2)
				{
					LumpsData<int> data2 = new LumpsData<int>
					{
						lumps = 0
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(GameEnd_Mul, data2, RpcTarget.Others);
					isGameStart = false;
					PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
					{
						pointScore[0].ToString(),
						pointScore[1].ToString()
					}, 0);
					return;
				}
				isSetTurn = true;
				SetTurn(Vector3.zero, isNet: true, isTimeOut: true);
				LumpsData<bool> data3 = new LumpsData<bool>
				{
					lumps = false
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(TimeOut_Mul, data3, RpcTarget.All);
			}
			player.SetTimeLimit(time);
			if (!isTimeTick && time <= 5f && time > 0f)
			{
				isTimeTick = true;
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.audio_TimeTick.Play();
			}
		}

		public void SetAIShotPosition()
		{
			pos_Shot = new Vector3(UnityEngine.Random.Range(0f - courtX, courtX), pos_Shot.y, UnityEngine.Random.Range(3f, courtZ - 0.5f));
			if (SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview.z >= -1.5f)
			{
				pos_Shot = new Vector3(SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview.x, pos_Shot.y, pos_Shot.z * 0.5f);
			}
			else if (SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview.z >= -2.5f)
			{
				pos_Shot *= 0.8f;
			}
		}

		public void SetTurn(Vector3 ballPos, bool isNet = false, bool isTimeOut = false)
		{
			if (isSetTurn)
			{
				if (shotPlayer == -1)
				{
					player.DelaySpwanShuttlecockTime();
					return;
				}
				SingletonBase.Singleton<Referee_SGT>.GetInstance.IKSet(null);
				player.racket_Ctrl.isPlay = false;
				isSetTurn = false;
				StartCoroutine(DelaySetTurn_C(ballPos, isNet, isTimeOut));
			}
		}

		private IEnumerator DelaySetTurn_C(Vector3 ballPos, bool isNet, bool isTimeOut)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				yield return new WaitForSeconds(0.5f);
			}
			int num = -1;
			bool flag = false;
			if (ballPos.x < 0f - courtX || ballPos.x > courtX || ballPos.z < 0f - courtZ || ballPos.z > courtZ)
			{
				flag = true;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				if (aiPlayer_Ctrl.transform.position.x < 0f)
				{
					ballPos = new Vector3(0f - ballPos.x, ballPos.y, ballPos.z);
				}
				if (isNet)
				{
					if (shotPlayer == 0)
					{
						num = 1;
						servicePlayer = 1;
					}
					else
					{
						num = 0;
						servicePlayer = 0;
					}
				}
				else if (player.isService && shotPlayer == 0)
				{
					if (ballPos.x < serviceInX || ballPos.x > serviceOutX || ballPos.z > 0f - serviceInZ || ballPos.z < 0f - serviceOutZ)
					{
						num = 1;
						servicePlayer = 1;
					}
					else
					{
						num = 0;
						servicePlayer = 0;
					}
				}
				else if (shotPlayer == 0 && ballPos.x >= 0f - courtX && ballPos.x <= courtX && ballPos.z <= 0f && ballPos.z >= 0f - courtZ)
				{
					num = 0;
					servicePlayer = 0;
				}
				else if (shotPlayer == 1 && ballPos.x >= 0f - courtX && ballPos.x <= courtX && ballPos.z >= 0f && ballPos.z <= courtZ)
				{
					num = 1;
					servicePlayer = 1;
				}
				else if (shotPlayer == 0)
				{
					num = 1;
					servicePlayer = 1;
				}
				else if (shotPlayer == 1)
				{
					num = 0;
					servicePlayer = 0;
				}
				if (num >= 0)
				{
					switch (num)
					{
					case 0:
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
						break;
					case 1:
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
						break;
					}
					pointScore[num]++;
					aiPlayer_Ctrl.SetWinAnim(num == 1);
				}
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.StartScoreSound(pointScore[0], pointScore[1], flag ? 1 : 0);
				shotPlayer = -1;
				ScoreView();
			}
			else if (!isTimeOut)
			{
				if (shotPlayer == 0 && !PhotonNetwork.IsMasterClient)
				{
					if (isNet)
					{
						num = 1;
						servicePlayer = 0;
						LumpsData<int, int, bool> data = new LumpsData<int, int, bool>
						{
							lumps1 = 1,
							lumps2 = 1,
							lumps3 = flag
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data, RpcTarget.Others);
					}
					else if (ballPos.x >= 0f - courtX && ballPos.x <= courtX && ballPos.z <= 0f && ballPos.z >= 0f - courtZ)
					{
						num = 0;
						servicePlayer = 1;
						LumpsData<int, int, bool> data2 = new LumpsData<int, int, bool>
						{
							lumps1 = 0,
							lumps2 = 0,
							lumps3 = flag
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data2, RpcTarget.Others);
					}
					else
					{
						num = 1;
						servicePlayer = 0;
						LumpsData<int, int, bool> data3 = new LumpsData<int, int, bool>
						{
							lumps1 = 1,
							lumps2 = 1,
							lumps3 = flag
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data3, RpcTarget.Others);
					}
					if (num >= 0)
					{
						switch (num)
						{
						case 0:
							SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
							break;
						case 1:
							SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
							break;
						}
						pointScore[num]++;
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.StartScoreSound(pointScore[0], pointScore[1], flag ? 1 : 0);
					shotPlayer = -2;
					ScoreView();
				}
				else
				{
					if (shotPlayer != 1 || !PhotonNetwork.IsMasterClient)
					{
						yield break;
					}
					if (isNet)
					{
						num = 0;
						servicePlayer = 0;
						LumpsData<int, int, bool> data4 = new LumpsData<int, int, bool>
						{
							lumps1 = 0,
							lumps2 = 1,
							lumps3 = flag
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data4, RpcTarget.Others);
					}
					else if (ballPos.x >= 0f - courtX && ballPos.x <= courtX && ballPos.z >= 0f && ballPos.z <= courtZ)
					{
						num = 1;
						servicePlayer = 1;
						LumpsData<int, int, bool> data5 = new LumpsData<int, int, bool>
						{
							lumps1 = 1,
							lumps2 = 0,
							lumps3 = flag
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data5, RpcTarget.Others);
					}
					else
					{
						num = 0;
						servicePlayer = 0;
						LumpsData<int, int, bool> data6 = new LumpsData<int, int, bool>
						{
							lumps1 = 0,
							lumps2 = 1,
							lumps3 = flag
						};
						SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data6, RpcTarget.Others);
					}
					if (num >= 0)
					{
						switch (num)
						{
						case 0:
							SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
							break;
						case 1:
							SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
							break;
						}
						pointScore[num]++;
					}
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.StartScoreSound(pointScore[0], pointScore[1], flag ? 1 : 0);
					shotPlayer = -2;
					ScoreView();
				}
			}
			else if (shotPlayer == 0 && PhotonNetwork.IsMasterClient)
			{
				num = 1;
				servicePlayer = 1;
				LumpsData<int, int, bool> data7 = new LumpsData<int, int, bool>
				{
					lumps1 = 1,
					lumps2 = 0,
					lumps3 = flag
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data7, RpcTarget.Others);
				if (num >= 0)
				{
					switch (num)
					{
					case 0:
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
						break;
					case 1:
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
						break;
					}
					pointScore[num]++;
				}
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.StartScoreSound(pointScore[0], pointScore[1], flag ? 1 : 0);
				shotPlayer = -2;
				ScoreView();
			}
			else
			{
				if (shotPlayer != 1 || PhotonNetwork.IsMasterClient)
				{
					yield break;
				}
				num = 0;
				servicePlayer = 1;
				LumpsData<int, int, bool> data8 = new LumpsData<int, int, bool>
				{
					lumps1 = 0,
					lumps2 = 0,
					lumps3 = flag
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialScore_Multi, data8, RpcTarget.Others);
				if (num >= 0)
				{
					switch (num)
					{
					case 0:
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
						break;
					case 1:
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
						break;
					}
					pointScore[num]++;
				}
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.StartScoreSound(pointScore[0], pointScore[1], flag ? 1 : 0);
				shotPlayer = -2;
				ScoreView();
			}
		}

		private void ScoreView()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				aiPlayer_Ctrl.isSmash = false;
			}
			SingletonBase.Singleton<ScoreFloor_SGT>.GetInstance.SetScore(pointScore[0], pointScore[1]);
			SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetPointScore(pointScore[0], pointScore[1]);
			CancelInvoke("SetServePosition");
			if ((pointScore[0] >= 6 || pointScore[1] >= 6) && Mathf.Abs(pointScore[0] - pointScore[1]) >= 2)
			{
				Invoke("SetOver", 3f);
			}
			else
			{
				Invoke("SetServePosition", 3f);
			}
		}

		private void SetServePosition()
		{
			player.isMove = true;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				if (pointScore[servicePlayer] % 2 == 1)
				{
					pos_Shot = setServePos1;
					aiPlayer_Ctrl.SetMove(-setServePos1);
					if (servicePlayer == 0)
					{
						serviceEffect_Ctrl[0].SetState(2);
					}
				}
				else
				{
					pos_Shot = setServePos2;
					aiPlayer_Ctrl.SetMove(-setServePos2);
					if (servicePlayer == 0)
					{
						serviceEffect_Ctrl[0].SetState(1);
					}
				}
				if (servicePlayer == 0)
				{
					player.isService = true;
					player.movePlusX = 0f;
					player.DelaySpwanShuttlecockTime();
					return;
				}
				player.movePlusX = UnityEngine.Random.Range(0.8f, 1.2f);
				if (UnityEngine.Random.Range(0, 10) >= 7)
				{
					player.movePlusX *= -1f;
				}
				aiPlayer_Ctrl.DelayStartServe();
				return;
			}
			isTimeFlow = true;
			isTimeTick = false;
			time = 20f;
			if (servicePlayer == 0)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					if (pointScore[0] % 2 == 1)
					{
						SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = setServePos1;
					}
					else
					{
						SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = setServePos2;
					}
				}
				else if (pointScore[1] % 2 == 1)
				{
					SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = -setServePos1;
				}
				else
				{
					SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = -setServePos2;
				}
			}
			else if (PhotonNetwork.IsMasterClient)
			{
				if (pointScore[1] % 2 == 1)
				{
					SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = setServePos1;
				}
				else
				{
					SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = setServePos2;
				}
			}
			else if (pointScore[0] % 2 == 1)
			{
				SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = -setServePos1;
			}
			else
			{
				SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = -setServePos2;
			}
			if (servicePlayer == 0)
			{
				player.isService = true;
				player.movePlusX = 0f;
				player.DelaySpwanShuttlecockTime();
			}
			else
			{
				others.anim_TurnArrow.SetTrigger("Play");
			}
		}

		private void SetMiddlePosition()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				pos_Shot = setServePos0;
			}
			else if (PhotonNetwork.IsMasterClient)
			{
				SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = setServePos0;
			}
			else
			{
				SingletonBase.Singleton<Physics_SGT>.GetInstance.pos_Preview = -setServePos0;
			}
			player.movePlusX = 0f;
			player.isMove = true;
		}

		public void ResetGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					servicePlayer = 0;
				}
				else
				{
					servicePlayer = 1;
				}
			}
			else
			{
				servicePlayer = 0;
			}
			shotPlayer = -2;
			pointScore[0] = 0;
			pointScore[1] = 0;
			isGameStart = true;
			SingletonBase.Singleton<ScoreFloor_SGT>.GetInstance.SetScore(pointScore[0], pointScore[1]);
			SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetPointScore(pointScore[0], pointScore[1]);
			ScoreView();
		}

		private void SetOver()
		{
			isGameStart = false;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (pointScore[0] > pointScore[1])
				{
					PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
					{
						pointScore[0].ToString(),
						pointScore[1].ToString()
					}, 0);
				}
				else
				{
					PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
					{
						pointScore[0].ToString(),
						pointScore[1].ToString()
					}, 1);
				}
			}
			else if (pointScore[0] > pointScore[1])
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					pointScore[0].ToString(),
					pointScore[1].ToString()
				}, 0);
				if (isDeuce)
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach11", 1);
				}
				if (pointScore[0] == 6 && pointScore[1] == 0)
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach12", 1);
				}
			}
			else
			{
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					pointScore[0].ToString(),
					pointScore[1].ToString()
				}, 1);
			}
			SetMiddlePosition();
		}

		private void SpawnPlayer()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance == null)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.None || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				player = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BT_SinglePlayer"), new Vector3(0f, 0f, 3.71f), Quaternion.identity).GetComponent<Player_CTRL>();
				player.transform.Rotate(0f, 180f, 0f);
				aiPlayer_Ctrl = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BT_AIPlayer"), new Vector3(0f, 0.01f, -3.7f), Quaternion.identity).GetComponent<AIPlayer_CTRL>();
				for (int i = 1; i < checkLevels.Length; i++)
				{
					checkLevels[i].localScale = new Vector3(929.048f, 443.5f, checkLevels[0].localScale.z);
					checkLevels[i].position = new Vector3(0f, aiPlayer_Ctrl.trans_HitPos[i - 1].position.y, -221.75f);
				}
			}
			else if (PhotonNetwork.IsMasterClient)
			{
				player = PhotonNetwork.Instantiate("BT_MultiPlayer", new Vector3(0f, 0f, 3.71f), Quaternion.Euler(new Vector3(0f, 180f, 0f)), 0).GetComponent<Player_CTRL>();
				player.gameObject.name = "Player";
			}
			else
			{
				player = PhotonNetwork.Instantiate("BT_MultiPlayer", new Vector3(0f, 0f, -3.71f), Quaternion.Euler(new Vector3(0f, 0f, 0f)), 0).GetComponent<Player_CTRL>();
				player.gameObject.name = "Player";
			}
			SetPlayerXR();
			SpawnUI();
		}

		private IEnumerator DelaySpawnOtherVRIK_C()
		{
			while (GameObject.Find("BT_MultiPlayer(Clone)") == null)
			{
				yield return null;
			}
			others = GameObject.Find("BT_MultiPlayer(Clone)").GetComponent<Player_CTRL>();
			others.name = "Others";
			VRIK component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("VRIK"), others.transform.position, Quaternion.identity).GetComponent<VRIK>();
			SkinnedMeshRenderer component2 = others.LeftHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>();
			component2.material = handMaterial;
			others.RightHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>().material = handMaterial;
			others.LeftHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			others.RightHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			component.solver.spine.headTarget = others.Head.Find("IK1");
			component.solver.spine.pelvisTarget = others.transform.Find("Pelvis");
			component.solver.leftArm.target = others.LeftHand.Find("IK");
			component.solver.rightArm.target = others.RightHand.Find("IK");
			CustomModelSettingCtrl component3 = component.GetComponent<CustomModelSettingCtrl>();
			component3.enabled = true;
			if (PhotonNetwork.IsMasterClient)
			{
				component3.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id, CustomModelViewState.HalfCut2, component2);
			}
			else
			{
				component3.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id, CustomModelViewState.HalfCut2, component2);
			}
			Text[] array = text_Player1;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			}
			array = text_Player2;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			}
		}

		private void SpawnUI()
		{
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BT_InGameUI"));
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position = player.transform.position + player.transform.forward * 1.5f;
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.LookAt(player.transform);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position += new Vector3(0f, 1.3f, 0f);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.SetParent(player.transform);
		}

		private void SetPlayerXR()
		{
			GameObject gameObject = player.transform.Find("Head").gameObject;
			GameObject obj = player.transform.Find("LeftHand").gameObject;
			GameObject gameObject2 = player.transform.Find("RightHand").gameObject;
			XRRig xRRig = player.gameObject.AddComponent<XRRig>();
			xRRig.cameraGameObject = gameObject;
			xRRig.TrackingOriginMode = TrackingOriginModeFlags.Floor;
			gameObject.AddComponent<Camera>().nearClipPlane = 0.01f;
			gameObject.AddComponent<AudioListener>();
			gameObject.AddComponent<UniversalAdditionalCameraData>();
			gameObject.AddComponent<UnityEngine.SpatialTracking.TrackedPoseDriver>();
			UnityEngine.XR.Interaction.Toolkit.XRController xRController = obj.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController.controllerNode = XRNode.LeftHand;
			xRController.selectUsage = InputHelpers.Button.Trigger;
			obj.AddComponent<XRRayInteractor>();
			obj.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual = obj.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual.lineWidth = 0.015f;
			xRInteractorLineVisual.lineLength = 1.5f;
			xRInteractorLineVisual.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			UnityEngine.XR.Interaction.Toolkit.XRController xRController2 = gameObject2.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController2.controllerNode = XRNode.RightHand;
			xRController2.selectUsage = InputHelpers.Button.Trigger;
			gameObject2.AddComponent<XRRayInteractor>();
			gameObject2.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual2 = gameObject2.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual2.lineWidth = 0.015f;
			xRInteractorLineVisual2.lineLength = 1.5f;
			xRInteractorLineVisual2.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual2.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
		}

		public void SerialScore_Multi(SerializableClass packet)
		{
			if (!(packet is LumpsData<int, int, bool>))
			{
				return;
			}
			int lumps = (packet as LumpsData<int, int, bool>).lumps1;
			servicePlayer = (packet as LumpsData<int, int, bool>).lumps2;
			if (lumps >= 0)
			{
				switch (lumps)
				{
				case 0:
					SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
					break;
				case 1:
					SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
					break;
				}
				pointScore[lumps]++;
			}
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.StartScoreSound(pointScore[0], pointScore[1], (packet as LumpsData<int, int, bool>).lumps3 ? 1 : 0);
			ScoreView();
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			isGameStart = false;
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}

		public void LeftPlayer_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				isGameStart = false;
				string nickName = PhotonNetwork.LocalPlayer.NickName;
				int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
				PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
			}
		}

		public void TimeOut_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				if (SingletonBase.Singleton<Physics_SGT>.GetInstance.shuttlecock != null)
				{
					UnityEngine.Object.Destroy(SingletonBase.Singleton<Physics_SGT>.GetInstance.shuttlecock.gameObject);
				}
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut_Cn);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut);
				}
				others.anim_TurnArrow.SetTrigger("Stop");
			}
		}

		public void GameEnd_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<int>)
			{
				isGameStart = false;
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					pointScore[0].ToString(),
					pointScore[1].ToString()
				}, (packet as LumpsData<int>).lumps);
			}
		}

		public void Custom(LanguageState language)
		{
			if (language == LanguageState.schinese)
			{
				display_Cn.SetActive(value: true);
				display_Us.SetActive(value: false);
			}
			else
			{
				display_Cn.SetActive(value: false);
				display_Us.SetActive(value: true);
			}
		}
	}
	public class LEDScoreBoard_SGT : SingletonBase.Singleton<LEDScoreBoard_SGT>
	{
		public LEDScoreBoard_CTRL[] objects;

		public Sprite[] sprites;

		private int minPoint;

		public void SetData(string name01, string name02, int m_minPoint)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetData(name01, name02, m_minPoint);
			}
			minPoint = m_minPoint;
		}

		public void SetPointScore(int p01, int p02)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetPointScore(p01, p02, minPoint);
			}
		}

		public void SetGameScore(int p01, int p02)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetGameScore(p01, p02);
			}
		}
	}
	public class Physics_SGT : SingletonBase.Singleton<Physics_SGT>
	{
		private Vector3 correctionVelocity = new Vector3(0f, 0f, -3.2f);

		private Vector3 gravity = new Vector3(0f, -5.81f, 0f);

		private Vector3[] pos_Temp = new Vector3[100];

		private RootPhysics.PosTime[] posTime;

		private bool isShotFail;

		private bool isEnableSmash;

		public Cloth net;

		public Rigidbody ShuttleCockCollider;

		private CapsuleCollider[] ballCollider = new CapsuleCollider[1];

		public Shuttlecock_CTRL shuttlecock { get; set; }

		public Vector3 pos_Preview { get; set; }

		private void Start()
		{
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(CreateCock_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(DropCock_Multi);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(HitCock_Multi);
			posTime = new RootPhysics.PosTime[11];
			for (int i = 0; i < posTime.Length; i++)
			{
				posTime[i].position = Vector3.zero;
				posTime[i].time = 0f;
			}
			net.capsuleColliders = new CapsuleCollider[1];
		}

		private void Update()
		{
		}

		public void CreateShuttlecock_Player()
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			getInstance.player.racket_Ctrl.isPlay = false;
			if (shuttlecock == null)
			{
				if (getInstance.player.isRightHand)
				{
					shuttlecock = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Shuttlecock"), getInstance.player.trans_Spawn_L.position, getInstance.player.trans_Spawn_L.rotation).GetComponent<Shuttlecock_CTRL>();
				}
				else
				{
					shuttlecock = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Shuttlecock"), getInstance.player.trans_Spawn_R.position, getInstance.player.trans_Spawn_R.rotation).GetComponent<Shuttlecock_CTRL>();
				}
				ShuttleCockCollider = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ShuttlecockCollider"), getInstance.player.trans_Spawn_R.position, getInstance.player.trans_Spawn_R.rotation).GetComponent<Rigidbody>();
				ballCollider[0] = ShuttleCockCollider.GetComponent<CapsuleCollider>();
				net.capsuleColliders = ballCollider;
			}
			shuttlecock.Grap();
			if (getInstance.player.isRightHand)
			{
				shuttlecock.trans.SetParent(getInstance.player.trans_Spawn_L);
				shuttlecock.SetPosition(getInstance.player.trans_Spawn_L.position, getInstance.player.trans_Spawn_L.rotation);
			}
			else
			{
				shuttlecock.trans.SetParent(getInstance.player.trans_Spawn_R);
				shuttlecock.SetPosition(getInstance.player.trans_Spawn_R.position, getInstance.player.trans_Spawn_R.rotation);
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = getInstance.player.isRightHand
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(CreateCock_Multi, data, RpcTarget.Others);
			}
			SingletonBase.Singleton<Referee_SGT>.GetInstance.IKSet(shuttlecock.trans);
			getInstance.isSetTurn = true;
		}

		public void DropShuttlecock_Player(Vector3 handForce)
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			shuttlecock.trans.SetParent(null);
			getInstance.shotPlayer = -1;
			shuttlecock.SetPlay(handForce);
			getInstance.player.racket_Ctrl.isPlay = true;
			getInstance.serviceEffect_Ctrl[0].SetState(0);
			SingletonBase.Singleton<ScoreFloor_SGT>.GetInstance.CloseScoreBoard();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<Vector3> data = new LumpsData<Vector3>
				{
					lumps = handForce
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(DropCock_Multi, data, RpcTarget.Others);
			}
			else if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl != null)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl.PlayLookAtIK(isOn: true);
			}
		}

		public void CreateShuttlecock_AI(Transform parent)
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			if (shuttlecock == null)
			{
				shuttlecock = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Shuttlecock"), parent).GetComponent<Shuttlecock_CTRL>();
				ShuttleCockCollider = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ShuttlecockCollider"), getInstance.player.trans_Spawn_R.position, getInstance.player.trans_Spawn_R.rotation).GetComponent<Rigidbody>();
				ballCollider[0] = ShuttleCockCollider.GetComponent<CapsuleCollider>();
				net.capsuleColliders = ballCollider;
			}
			shuttlecock.transform.SetParent(parent);
			shuttlecock.transform.localPosition = Vector3.zero;
			shuttlecock.transform.localRotation = Quaternion.identity;
			shuttlecock.isNet = false;
			getInstance.isSetTurn = true;
			shuttlecock.transform.SetParent(null);
			getInstance.player.racket_Ctrl.isPlay = true;
			SingletonBase.Singleton<Referee_SGT>.GetInstance.IKSet(shuttlecock.trans);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi && SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl != null)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.aiPlayer_Ctrl.PlayLookAtIK(isOn: true);
			}
		}

		public void HitShuttlecock_Player()
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				getInstance.aiPlayer_Ctrl.isSmash = false;
			}
			if (SingletonPunBase.Singleton<UI_SGT>.GetInstance.anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
			{
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.ClickButton("Start");
			}
			_ = getInstance.shotPlayer;
			getInstance.player.isMove = false;
			Vector3 velo = getInstance.player.racket_Ctrl.velo * 3f;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				getInstance.shotPlayer = 0;
				Preview(velo);
			}
			else
			{
				if (PhotonNetwork.IsMasterClient)
				{
					getInstance.shotPlayer = 0;
				}
				else
				{
					getInstance.shotPlayer = 1;
				}
				Preview(velo);
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				getInstance.SetAIShotPosition();
			}
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.isRightHand)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.Haptic(0.5f, 0.1f, isLeft: false);
			}
			else
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.Haptic(0.5f, 0.1f);
			}
		}

		public void HitShuttlecock_AI(int grade, bool isStableShot)
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			getInstance.player.isService = false;
			getInstance.shotPlayer = 1;
			getInstance.aiPlayer_Ctrl.isSmash = false;
			float[,] array = new float[5, 4]
			{
				{ 0.3f, 0.4f, 0.5f, 0.6f },
				{ 0.25f, 0.35f, 0.45f, 0.6f },
				{ 0.2f, 0.3f, 0.4f, 0.5f },
				{ 0.15f, 0.25f, 0.35f, 0.5f },
				{ 0.1f, 0.2f, 0.3f, 0.4f }
			};
			float num;
			switch (grade)
			{
			case 99:
				num = UnityEngine.Random.Range(1f, 1f + array[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1, 2]);
				break;
			case 0:
				num = 0.35f;
				getInstance.aiPlayer_Ctrl.isSmash = true;
				break;
			case 1:
				num = UnityEngine.Random.Range(0.6f, 0.6f + array[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1, 0]);
				break;
			case 2:
			case 3:
			case 4:
				num = UnityEngine.Random.Range(0.9f, 0.9f + array[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1, 1]);
				break;
			case 5:
			case 6:
			case 7:
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level == 5 || !isStableShot || shuttlecock.trans.position.z >= -1.5f)
				{
					num = UnityEngine.Random.Range(1f, 1f + array[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1, 2]);
					break;
				}
				num = UnityEngine.Random.Range(1.2f, 1.3f);
				getInstance.pos_Shot = new Vector3(UnityEngine.Random.Range(-2.3f, 2.3f), 0f, 2f);
				getInstance.player.isMove = true;
				break;
			default:
				num = UnityEngine.Random.Range(1.3f, 1.3f + array[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1, 3]);
				break;
			}
			if (!isStableShot)
			{
				switch (UnityEngine.Random.Range(0, 8))
				{
				case 0:
				case 1:
					getInstance.pos_Shot = new Vector3(UnityEngine.Random.Range(2.5f, 5.5f), 0f, UnityEngine.Random.Range(2f, 6.6f));
					break;
				case 2:
				case 3:
					getInstance.pos_Shot = new Vector3(UnityEngine.Random.Range(-2.5f, -5.5f), 0f, UnityEngine.Random.Range(2f, 6.6f));
					break;
				case 4:
				case 5:
				case 6:
					getInstance.pos_Shot = new Vector3(UnityEngine.Random.Range(-2.3f, 2.3f), UnityEngine.Random.Range(0f, 1.3f), 0f);
					break;
				default:
					getInstance.pos_Shot = new Vector3(UnityEngine.Random.Range(-3.8f, 3.8f), 0f, UnityEngine.Random.Range(6.9f, 9.5f));
					break;
				}
				num -= UnityEngine.Random.Range(0.2f, 0.7f);
			}
			else if (grade == 0)
			{
				getInstance.pos_Shot = new Vector3(getInstance.player.transform.position.x + UnityEngine.Random.Range(-0.5f, 0.5f), 0f, 6.5f);
			}
			float time = Vector3.Distance(shuttlecock.trans.position, getInstance.pos_Shot) * 0.03f + num;
			Vector3 velocity = RootPhysics.GetVelocity(shuttlecock.transform.position, getInstance.pos_Shot, gravity, 1.6f, time);
			Preview(velocity, isDefinite: true, isAI: true);
			_ = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1;
			_ = 2;
			if ((getInstance.player.transform.position - pos_Preview).sqrMagnitude >= 2.5f)
			{
				getInstance.player.movePlusX = (getInstance.player.transform.position.x - pos_Preview.x) * 0.3f;
				getInstance.player.isMove = true;
			}
		}

		public void Preview(Vector3 velo, bool isDefinite = false, bool isAI = false)
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				getInstance.aiPlayer_Ctrl.isTrace = false;
			}
			pos_Preview = Vector3.zero;
			for (int i = 0; i < posTime.Length; i++)
			{
				posTime[i].position = Vector3.zero;
			}
			if (!isDefinite)
			{
				isShotFail = false;
			}
			isEnableSmash = false;
			Vector3 position = shuttlecock.trans.position;
			Vector3 vector = velo;
			float num = vector.magnitude;
			float num2 = 0f;
			if (num > 30f)
			{
				vector = vector.normalized * 30f;
				num = 30f;
			}
			for (int j = 0; j < pos_Temp.Length; j++)
			{
				if (!(pos_Preview == Vector3.zero))
				{
					break;
				}
				Vector3 vector2 = vector;
				vector2 /= 1f + 1.6f * num2;
				float num3 = gravity.y * (0.5f * num2);
				vector2.y += num3;
				vector2 *= num2;
				pos_Temp[j] = position + vector2;
				if (j == 0)
				{
					continue;
				}
				if (j == 2 && !isAI && pos_Temp[1].y > getInstance.player.Head.position.y + 0.55f && SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.racket_Ctrl.velo.magnitude > 18f && !getInstance.player.isService && !isDefinite)
				{
					isEnableSmash = true;
				}
				RaycastHit[] array = Physics.RaycastAll(pos_Temp[j - 1], pos_Temp[j] - pos_Temp[j - 1], Vector3.Distance(pos_Temp[j], pos_Temp[j - 1]));
				for (int k = 0; k < array.Length; k++)
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						if (PhotonNetwork.IsMasterClient)
						{
							if (array[k].collider.CompareTag("Court"))
							{
								if (isEnableSmash)
								{
									shuttlecock.trans.position += new Vector3(0f, 0.7f, 0f);
									Vector3 point = array[k].point;
									point *= 0.75f;
									float time = Vector2.Distance(new Vector2(shuttlecock.trans.position.x, shuttlecock.trans.position.z), new Vector2(point.x, point.z)) / (num - 16f);
									vector = RootPhysics.GetVelocity(shuttlecock.trans.position, point, gravity, 1.6f, time);
									pos_Preview = point;
									shuttlecock.SetPlay(vector, isSmash: true);
									BallData data = new BallData
									{
										position = shuttlecock.transform.position,
										velocity = vector,
										angularVelocity = pos_Preview,
										photonTime = 1.0
									};
									SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(HitCock_Multi, data, RpcTarget.Others);
									return;
								}
								if (!isDefinite && array[k].point.z <= 0f && (array[k].point.x > getInstance.courtX || array[k].point.x < 0f - getInstance.courtX || array[k].point.z < 0f - getInstance.courtZ))
								{
									Vector3 velocity = RootPhysics.GetVelocity(position, correctionVelocity, gravity, 1.6f, (position - correctionVelocity).magnitude * 0.01f + 0.5f);
									vector = Vector3.Lerp(vector, velocity, 0.5f);
									Preview(vector, isDefinite: true);
									return;
								}
								if (array[k].point.x <= getInstance.courtX && array[k].point.x >= 0f - getInstance.courtX && array[k].point.z <= -0.01f && array[k].point.z >= 0f - getInstance.courtZ && getInstance.player.isService)
								{
									velo = RootPhysics.GetVelocity(shuttlecock.transform.position, getInstance.others.transform.position, gravity, 1.6f, (shuttlecock.transform.position - getInstance.others.transform.position).magnitude * 0.01f + 1.1f);
									getInstance.player.isService = false;
									Preview(velo, isDefinite: true);
									return;
								}
								pos_Preview = array[k].point;
							}
						}
						else if (array[k].collider.CompareTag("Court"))
						{
							if (isEnableSmash)
							{
								shuttlecock.trans.position += new Vector3(0f, 0.7f, 0f);
								Vector3 point2 = array[k].point;
								point2 *= 0.75f;
								float time2 = Vector2.Distance(new Vector2(shuttlecock.trans.position.x, shuttlecock.trans.position.z), new Vector2(point2.x, point2.z)) / (num - 16f);
								vector = RootPhysics.GetVelocity(shuttlecock.trans.position, point2, gravity, 1.6f, time2);
								pos_Preview = point2;
								shuttlecock.SetPlay(vector, isSmash: true);
								BallData data2 = new BallData
								{
									position = shuttlecock.transform.position,
									velocity = vector,
									angularVelocity = pos_Preview,
									photonTime = 1.0
								};
								SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(HitCock_Multi, data2, RpcTarget.Others);
								return;
							}
							if (!isDefinite && array[k].point.z >= 0f && (array[k].point.x > getInstance.courtX || array[k].point.x < 0f - getInstance.courtX || array[k].point.z > getInstance.courtZ))
							{
								Vector3 velocity2 = RootPhysics.GetVelocity(position, -1f * correctionVelocity, gravity, 1.6f, (position - -1f * correctionVelocity).magnitude * 0.01f + 0.5f);
								vector = Vector3.Lerp(vector, velocity2, 0.5f);
								Preview(vector, isDefinite: true);
								return;
							}
							if (array[k].point.x <= getInstance.courtX && array[k].point.x >= 0f - getInstance.courtX && array[k].point.z >= 0.01f && array[k].point.z >= 0f - getInstance.courtZ && getInstance.player.isService)
							{
								velo = RootPhysics.GetVelocity(shuttlecock.transform.position, getInstance.others.transform.position, gravity, 1.6f, (shuttlecock.transform.position - getInstance.others.transform.position).magnitude * 0.01f + 1.1f);
								getInstance.player.isService = false;
								Preview(velo, isDefinite: true);
								return;
							}
							pos_Preview = array[k].point;
						}
						continue;
					}
					if (array[k].collider.CompareTag("Court"))
					{
						if (isEnableSmash)
						{
							shuttlecock.trans.position += new Vector3(0f, 0.7f, 0f);
							Vector3 point3 = array[k].point;
							point3 *= 0.75f;
							float time3 = Vector2.Distance(new Vector2(shuttlecock.trans.position.x, shuttlecock.trans.position.z), new Vector2(point3.x, point3.z)) / (num - 16f);
							vector = RootPhysics.GetVelocity(shuttlecock.trans.position, point3, gravity, 1.6f, time3);
							pos_Preview = point3;
							shuttlecock.SetPlay(vector, isSmash: true);
							getInstance.aiPlayer_Ctrl.SetTrace(isShotFail, posTime, pos_Preview);
							return;
						}
						if (getInstance.shotPlayer == 0 && !isDefinite && array[k].point.z <= 0f && (array[k].point.x > getInstance.courtX || array[k].point.x < 0f - getInstance.courtX || array[k].point.z < 0f - getInstance.courtZ))
						{
							Vector3 velocity3 = RootPhysics.GetVelocity(position, correctionVelocity, gravity, 1.6f, (position - correctionVelocity).magnitude * 0.01f + 0.5f);
							vector = Vector3.Lerp(vector, velocity3, 0.5f);
							Preview(vector, isDefinite: true);
							return;
						}
						if (getInstance.shotPlayer == 0 && array[k].point.x <= getInstance.courtX && array[k].point.x >= 0f - getInstance.courtX && array[k].point.z <= -0.01f && array[k].point.z >= 0f - getInstance.courtZ)
						{
							getInstance.aiPlayer_Ctrl.isTrace = true;
							if (getInstance.player.isService)
							{
								velo = RootPhysics.GetVelocity(shuttlecock.transform.position, getInstance.aiPlayer_Ctrl.transform.position, gravity, 1.6f, (shuttlecock.transform.position - getInstance.aiPlayer_Ctrl.transform.position).magnitude * 0.01f + 1.1f);
								getInstance.player.isService = false;
								Preview(velo, isDefinite: true);
								return;
							}
						}
						else if (getInstance.shotPlayer == 0 && array[k].point.x <= getInstance.outX && array[k].point.x >= 0f - getInstance.outX && array[k].point.z <= -0.01f && array[k].point.z >= 0f - getInstance.courtZ)
						{
							getInstance.aiPlayer_Ctrl.isTrace = true;
							if (UnityEngine.Random.Range(0, 10) >= 8)
							{
								isShotFail = true;
							}
						}
						pos_Preview = array[k].point;
					}
					if (array[k].collider.CompareTag("CheckP01"))
					{
						posTime[0].position = array[k].point;
						float num4 = 0.05f * ((array[k].point - pos_Temp[j - 1]).magnitude / (pos_Temp[j] - pos_Temp[j - 1]).magnitude);
						posTime[0].time = num2 - 0.05f + num4;
					}
					else if (array[k].collider.CompareTag("CheckP02"))
					{
						posTime[1].position = array[k].point;
						float num5 = 0.05f * ((array[k].point - pos_Temp[j - 1]).magnitude / (pos_Temp[j] - pos_Temp[j - 1]).magnitude);
						posTime[1].time = num2 - 0.05f + num5;
					}
					else if (array[k].collider.CompareTag("CheckP03"))
					{
						posTime[2].position = array[k].point;
						posTime[2].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP04"))
					{
						posTime[3].position = array[k].point;
						posTime[3].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP05"))
					{
						posTime[4].position = array[k].point;
						posTime[4].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP06"))
					{
						posTime[5].position = array[k].point;
						posTime[5].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP07"))
					{
						posTime[6].position = array[k].point;
						posTime[6].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP08"))
					{
						posTime[7].position = array[k].point;
						posTime[7].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP09"))
					{
						posTime[8].position = array[k].point;
						posTime[8].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP10"))
					{
						posTime[9].position = array[k].point;
						posTime[9].time = num2;
					}
					else if (array[k].collider.CompareTag("CheckP11"))
					{
						posTime[10].position = array[k].point;
						posTime[10].time = num2;
					}
				}
				num2 += 0.05f;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				if (isAI)
				{
					shuttlecock.SetPlay(vector, getInstance.aiPlayer_Ctrl.isSmash);
				}
				else
				{
					shuttlecock.SetPlay(vector);
				}
				if (getInstance.aiPlayer_Ctrl.isTrace)
				{
					getInstance.aiPlayer_Ctrl.SetTrace(isShotFail, posTime, pos_Preview);
				}
			}
			else
			{
				shuttlecock.SetPlay(vector);
				BallData data3 = new BallData
				{
					position = shuttlecock.transform.position,
					velocity = vector,
					angularVelocity = pos_Preview,
					photonTime = -1.0
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(HitCock_Multi, data3, RpcTarget.Others);
			}
		}

		private Vector3 ChangeNetEndPos(Vector3 hitPos)
		{
			return new Vector3(y: (!(hitPos.z <= hitPos.y)) ? (Mathf.Abs(2f - Mathf.Abs(hitPos.z)) * 0.75f) : (1.65f + hitPos.y * 0.05f), x: hitPos.x, z: 0f);
		}

		public void CreateCock_Multi(SerializableClass packet)
		{
			if (!(packet is LumpsData<bool>))
			{
				return;
			}
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			getInstance.others.anim_TurnArrow.SetTrigger("Stop");
			if (shuttlecock == null)
			{
				if ((packet as LumpsData<bool>).lumps)
				{
					shuttlecock = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Shuttlecock"), getInstance.others.trans_Spawn_L.position, getInstance.others.trans_Spawn_L.rotation).GetComponent<Shuttlecock_CTRL>();
				}
				else
				{
					shuttlecock = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Shuttlecock"), getInstance.others.trans_Spawn_R.position, getInstance.others.trans_Spawn_R.rotation).GetComponent<Shuttlecock_CTRL>();
				}
				ShuttleCockCollider = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ShuttlecockCollider"), getInstance.player.trans_Spawn_R.position, getInstance.player.trans_Spawn_R.rotation).GetComponent<Rigidbody>();
				ballCollider[0] = ShuttleCockCollider.GetComponent<CapsuleCollider>();
				net.capsuleColliders = ballCollider;
			}
			shuttlecock.Grap();
			if ((packet as LumpsData<bool>).lumps)
			{
				shuttlecock.trans.SetParent(getInstance.others.trans_Spawn_L);
				shuttlecock.SetPosition(getInstance.others.trans_Spawn_L.position, getInstance.others.trans_Spawn_L.rotation);
			}
			else
			{
				shuttlecock.trans.SetParent(getInstance.others.trans_Spawn_R);
				shuttlecock.SetPosition(getInstance.others.trans_Spawn_R.position, getInstance.others.trans_Spawn_R.rotation);
			}
			SingletonBase.Singleton<Referee_SGT>.GetInstance.IKSet(shuttlecock.trans);
			getInstance.isSetTurn = true;
		}

		public void DropCock_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<Vector3>)
			{
				Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
				if (!(shuttlecock == null))
				{
					shuttlecock.trans.SetParent(null);
					getInstance.player.racket_Ctrl.isPlay = true;
					shuttlecock.SetPlay((packet as LumpsData<Vector3>).lumps);
					getInstance.serviceEffect_Ctrl[0].SetState(0);
					SingletonBase.Singleton<ScoreFloor_SGT>.GetInstance.CloseScoreBoard();
				}
			}
		}

		public void HitCock_Multi(SerializableClass packet)
		{
			if (!(packet is BallData))
			{
				return;
			}
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			if (!(shuttlecock == null))
			{
				Rigidbody component = shuttlecock.transform.GetComponent<Rigidbody>();
				shuttlecock.transform.position = (packet as BallData).position;
				component.transform.SetParent(null);
				if ((packet as BallData).photonTime > 0.0)
				{
					shuttlecock.SetPlay((packet as BallData).velocity, isSmash: true);
				}
				else
				{
					shuttlecock.SetPlay((packet as BallData).velocity);
				}
				pos_Preview = (packet as BallData).angularVelocity;
				getInstance.player.isService = false;
				getInstance.others.racket_Ctrl.OtherOnBallEnter();
				if (PhotonNetwork.IsMasterClient)
				{
					getInstance.shotPlayer = 1;
				}
				else
				{
					getInstance.shotPlayer = 0;
				}
				if ((getInstance.player.transform.position - pos_Preview).sqrMagnitude >= 2.5f)
				{
					getInstance.player.movePlusX = (getInstance.player.transform.position.x - pos_Preview.x) * 0.3f;
					getInstance.player.isMove = true;
				}
			}
		}

		public void TEST_HitShuttlecock_Player()
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				getInstance.aiPlayer_Ctrl.isSmash = false;
			}
			getInstance.player.isMove = false;
			Vector3 vector = default(Vector3);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				getInstance.shotPlayer = 0;
				vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-15f, -12f));
				Preview(vector);
			}
			else
			{
				if (PhotonNetwork.IsMasterClient)
				{
					getInstance.shotPlayer = 0;
					vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), UnityEngine.Random.Range(10f, 12f), UnityEngine.Random.Range(-15f, -12f));
				}
				else
				{
					getInstance.shotPlayer = 1;
					vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), UnityEngine.Random.Range(10f, 12f), UnityEngine.Random.Range(12f, 15f));
				}
				UnityEngine.Debug.LogError("치는공:" + getInstance.shotPlayer);
				Preview(vector);
			}
			getInstance.SetAIShotPosition();
		}
	}
	public class ScoreFloor_SGT : SingletonBase.Singleton<ScoreFloor_SGT>
	{
		private Animator anim;

		private int minPoint;

		public Image[] image_Score;

		public Sprite[] sprite_Num;

		protected override void Awake()
		{
			base.Awake();
			anim = GetComponent<Animator>();
		}

		public void SetData(string name_P1, string name_P2, int m_minPoint)
		{
			minPoint = m_minPoint;
			SetScore(0, 0);
		}

		public void SetScore(int score_P1, int score_P2)
		{
			if (score_P1 >= minPoint - 1 && score_P2 >= minPoint - 1)
			{
				if (score_P1 == score_P2 + 1)
				{
					image_Score[0].gameObject.SetActive(value: true);
					image_Score[1].gameObject.SetActive(value: true);
					image_Score[2].gameObject.SetActive(value: false);
					image_Score[3].gameObject.SetActive(value: false);
					image_Score[0].sprite = sprite_Num[10];
					image_Score[1].sprite = sprite_Num[11];
					anim.SetTrigger("Start");
					return;
				}
				if (score_P1 + 1 == score_P2)
				{
					image_Score[0].gameObject.SetActive(value: false);
					image_Score[1].gameObject.SetActive(value: false);
					image_Score[2].gameObject.SetActive(value: true);
					image_Score[3].gameObject.SetActive(value: true);
					image_Score[2].sprite = sprite_Num[10];
					image_Score[3].sprite = sprite_Num[11];
					anim.SetTrigger("Start");
					return;
				}
			}
			if (score_P1 > 9)
			{
				image_Score[0].gameObject.SetActive(value: true);
				image_Score[1].gameObject.SetActive(value: true);
				image_Score[0].sprite = sprite_Num[score_P1 / 10];
				image_Score[1].sprite = sprite_Num[score_P1 % 10];
			}
			else
			{
				image_Score[0].gameObject.SetActive(value: false);
				image_Score[1].gameObject.SetActive(value: true);
				image_Score[1].sprite = sprite_Num[score_P1];
			}
			if (score_P2 > 9)
			{
				image_Score[2].gameObject.SetActive(value: true);
				image_Score[3].gameObject.SetActive(value: true);
				image_Score[2].sprite = sprite_Num[score_P2 / 10];
				image_Score[3].sprite = sprite_Num[score_P2 % 10];
			}
			else
			{
				image_Score[2].gameObject.SetActive(value: false);
				image_Score[3].gameObject.SetActive(value: true);
				image_Score[3].sprite = sprite_Num[score_P2];
			}
			anim.SetTrigger("Start");
		}

		public void CloseScoreBoard()
		{
			anim.SetTrigger("End");
		}
	}
	public class Sound_SGT : SingletonPunBase.Singleton<Sound_SGT>
	{
		public AudioClip[] clip_Num;

		public AudioClip clip_Deuce;

		public AudioClip clip_Advantage;

		public AudioClip clip_In;

		public AudioClip clip_Out;

		public AudioClip clip_Net;

		public AudioClip clip_Service;

		public AudioClip clip_Start;

		public AudioClip clip_TimeOut;

		public AudioClip[] clip_Cheer;

		public AudioClip[] clip_Boos;

		public AudioSource audio_TimeTick;

		private AudioSource audioSource;

		private AudioSource audioSource2;

		public AudioClip[] clip_Num_Cn;

		public AudioClip clip_Deuce_Cn;

		public AudioClip clip_Advantage_Cn;

		public AudioClip clip_In_Cn;

		public AudioClip clip_Out_Cn;

		public AudioClip clip_Net_Cn;

		public AudioClip clip_Service_Cn;

		public AudioClip clip_TimeOut_Cn;

		private int minPoint;

		private Coroutine Cor_ScoreSound;

		private void Start()
		{
			audioSource = GetComponent<AudioSource>();
			audioSource2 = GetComponentInChildren<AudioSource>();
		}

		public void SetData(int m_minPoint)
		{
			minPoint = m_minPoint;
		}

		public void PlaySound(AudioClip clip)
		{
			audioSource.pitch = 1f;
			audioSource.PlayOneShot(clip);
		}

		public void PlaySound(AudioClip[] clip)
		{
			audioSource2.PlayOneShot(clip[UnityEngine.Random.Range(0, clip.Length)]);
		}

		public void StartScoreSound(int p1, int p2, int stateNum)
		{
			if (Cor_ScoreSound != null)
			{
				StopCoroutine(Cor_ScoreSound);
			}
			Cor_ScoreSound = StartCoroutine(Cor_StartScoreSound(p1, p2, stateNum));
		}

		private IEnumerator Cor_StartScoreSound(int p1, int p2, int stateNum)
		{
			if (stateNum == 1)
			{
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					audioSource.clip = clip_Out_Cn;
				}
				else
				{
					audioSource.clip = clip_Out;
				}
				audioSource.Play();
				yield return new WaitForSeconds(0.8f);
			}
			else
			{
				yield return new WaitForSeconds(0.5f);
			}
			if (p1 >= minPoint - 1 && p2 >= minPoint - 1)
			{
				if (p1 == p2 + 1)
				{
					while (!audioSource.isPlaying)
					{
						yield return null;
					}
					yield return new WaitForSeconds(0.3f);
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						audioSource.clip = clip_Advantage_Cn;
					}
					else
					{
						audioSource.clip = clip_Advantage;
					}
					audioSource.Play();
				}
				else if (p1 + 1 == p2)
				{
					while (!audioSource.isPlaying)
					{
						yield return null;
					}
					yield return new WaitForSeconds(0.6f);
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						audioSource.clip = clip_Advantage_Cn;
					}
					else
					{
						audioSource.clip = clip_Advantage;
					}
					audioSource.Play();
				}
				else if (p1 == p2)
				{
					if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
					{
						audioSource.clip = clip_Deuce_Cn;
					}
					else
					{
						audioSource.clip = clip_Deuce;
					}
					audioSource.Play();
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.isDeuce = true;
				}
			}
			else
			{
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					audioSource.clip = clip_Num_Cn[p1];
				}
				else
				{
					audioSource.clip = clip_Num[p1];
				}
				audioSource.Play();
				yield return new WaitForSeconds(0.3f);
				while (!audioSource.isPlaying)
				{
					yield return null;
				}
				yield return new WaitForSeconds(0.7f);
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					audioSource.clip = clip_Num_Cn[p2];
				}
				else
				{
					audioSource.clip = clip_Num[p2];
				}
				audioSource.Play();
			}
		}
	}
	public class UI_SGT : SingletonPunBase.Singleton<UI_SGT>
	{
		public enum UI_State
		{
			None,
			Start,
			EndS,
			EndM,
			Exit
		}

		private Canvas canvas;

		[Header("InfoS")]
		public Text text_InfoSTime;

		public Text text_InfoSScore;

		[Header("EndS")]
		public Text text_Player1;

		public Text text_Player2;

		public Text text_EndSResult;

		public Text text_EndSSetScore_P1;

		public Text text_EndSSetScore_P2;

		public Text text_EndSEachScore_P1;

		public Text text_EndSEachScore_P2;

		public GameObject[] Buttons;

		[Header("EndM")]
		public Text text_EndMName_P1;

		public Text text_EndMName_P2;

		public Text text_EndMScore_P1;

		public Text text_EndMScore_P2;

		public Text text_Result;

		[SerializeField]
		public TMP_FontAsset font_Us;

		public TMP_FontAsset font_Cn;

		public TextMeshPro timeOut;

		public TextMesh howToPlay;

		public bool isPublicUI;

		private bool isReadyStart;

		private bool isReady;

		private bool isReady_Others;

		private int preTime;

		private int preScore;

		public UI_State ui_State { get; set; }

		public Animator anim { get; set; }

		protected override void Awake()
		{
			base.Awake();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ReadySerial_Multi);
		}

		private void Start()
		{
			ui_State = UI_State.None;
			canvas = GetComponent<Canvas>();
			anim = GetComponent<Animator>();
			StartGame();
			StartCoroutine(ConnectUICamera_C());
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				text_Player1.text = "Player1";
				text_Player2.text = "Player2";
			}
			PublicGameUIManager.GetInstance.AddMenuEvent(CheckPublicUI);
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0154", timeOut);
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0040", howToPlay);
			Custom(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
		}

		private void FixedUpdate()
		{
			if (!isReadyStart && isReady && isReady_Others)
			{
				isReadyStart = true;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.ResetGame();
			}
		}

		private void CheckPublicUI(bool obj)
		{
			StartCoroutine(DelayCheckPublicUI_C(obj));
		}

		private IEnumerator DelayCheckPublicUI_C(bool obj)
		{
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			isPublicUI = obj;
		}

		public void AnimationPlay(string str)
		{
			switch (str)
			{
			case "StartOpen":
				ui_State = UI_State.Start;
				break;
			case "EndSOpen":
				ui_State = UI_State.EndS;
				break;
			case "EndMOpen":
				ui_State = UI_State.EndM;
				break;
			case "ExitOpen":
				ui_State = UI_State.Exit;
				break;
			default:
				ui_State = UI_State.None;
				break;
			}
			anim.SetTrigger(str);
		}

		public void ClickButton(string str)
		{
			switch (str)
			{
			case "Start":
				AnimationPlay("StartClose");
				break;
			case "RePlay":
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetRay(isOn: false);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					isReady = true;
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = true
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.ResetGame();
				}
				break;
			case "Play":
				AnimationPlay("ExitClose");
				break;
			case "Exit":
				SceneManager.LoadScene(0);
				break;
			}
		}

		public void DelaySerialAnimation(string animFirst, string animSecond, float time)
		{
			StartCoroutine(DelaySerialAnimation_C(animFirst, animSecond, time));
		}

		private IEnumerator DelaySerialAnimation_C(string animFirst, string animSecond, float time)
		{
			AnimationPlay(animFirst);
			yield return YieldInstructionCache.WaitForSeconds(time);
			AnimationPlay(animSecond);
		}

		private IEnumerator DelayStart_C()
		{
			yield return YieldInstructionCache.WaitForSeconds(3.5f);
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.isUISet = true;
			AnimationPlay("StartOpen");
		}

		private IEnumerator ConnectUICamera_C()
		{
			while (canvas.worldCamera == null)
			{
				yield return YieldInstructionCache.WaitForSeconds(Time.deltaTime);
				canvas.worldCamera = Camera.main;
			}
		}

		private void CheckTime()
		{
		}

		private void CheckScore()
		{
		}

		private void StartGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				isReady = true;
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = true
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
				if (PhotonNetwork.IsMasterClient)
				{
					StartCoroutine(DelayStart_C());
				}
			}
			else
			{
				StartCoroutine(DelayStart_C());
			}
		}

		public void EndSResult()
		{
		}

		public void EndMResult()
		{
			isReadyStart = false;
			isReady = false;
			isReady_Others = false;
		}

		public void SetButtons(bool isOn)
		{
			GameObject[] buttons = Buttons;
			for (int i = 0; i < buttons.Length; i++)
			{
				buttons[i].SetActive(isOn);
			}
		}

		public void ReadySerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				isReady_Others = (packet as LumpsData<bool>).lumps;
				UnityEngine.Debug.Log("준비됨");
			}
		}

		public void Custom(LanguageState language)
		{
			if (language == LanguageState.schinese)
			{
				timeOut.font = font_Cn;
			}
			else
			{
				timeOut.font = font_Us;
			}
		}
	}
}
namespace ARCHERY
{
	public class AIPlayer_CTRL : MonoBehaviour
	{
		private Animator anim;

		private Animator anim_Bow;

		private float pullingForce;

		private bool isShot;

		private Coroutine shot_C;

		public Transform trans_ArrowStart;

		public UnityEngine.Avatar avatar;

		public bool isDone { get; set; }

		public int playerNum { get; set; }

		private void Awake()
		{
			anim = GetComponent<Animator>();
			GetComponent<CustomModelSettingCtrl>().InitCPU();
		}

		private void Start()
		{
			GetComponent<Animator>().avatar = avatar;
		}

		private void Update()
		{
		}

		public void Shot()
		{
			if (!isShot)
			{
				shot_C = StartCoroutine(DelayShot());
			}
		}

		private IEnumerator DelayShot()
		{
			trans_ArrowStart.gameObject.SetActive(value: true);
			isShot = true;
			yield return new WaitForSeconds(UnityEngine.Random.Range(1f, 2f));
			pullingForce = 0f;
			anim.SetTrigger("Charge");
			while (pullingForce < 1f)
			{
				pullingForce += Time.fixedDeltaTime;
				yield return new WaitForSeconds(Time.fixedDeltaTime * 3f);
			}
			yield return new WaitForSeconds(UnityEngine.Random.Range(1f, 2f));
			if (!isDone)
			{
				anim.SetTrigger("Shot");
				pullingForce = 0f;
				Vector3 position = trans_ArrowStart.position;
				int level = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
				Vector3 endPos = new Vector3(1.59f, 1.516f, 56.15f) + new Vector3(UnityEngine.Random.Range((float)(6 - level) * -0.12f, (float)(6 - level) * 0.12f), UnityEngine.Random.Range((float)(6 - level) * -0.12f, (float)(6 - level) * 0.12f), 0f);
				ArrowShot(position, endPos);
				trans_ArrowStart.gameObject.SetActive(value: false);
				isDone = true;
				isShot = false;
			}
		}

		public void ShotMiss()
		{
			if (shot_C != null)
			{
				StopCoroutine(shot_C);
			}
			if (!isDone)
			{
				isShot = false;
				isDone = true;
				pullingForce = 0f;
				trans_ArrowStart.gameObject.SetActive(value: false);
				anim.SetTrigger("Idle");
				if (playerNum == 1)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.scoreBoard_Ctrl[0].SetScore((SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1 - 1) / 3 + 1, SingletonPunBase.Singleton<Game_SGT>.GetInstance.eachScore_P1);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2++;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.scoreBoard_Ctrl[1].SetScore((SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2 - 1) / 3 + 1, SingletonPunBase.Singleton<Game_SGT>.GetInstance.eachScore_P2);
				}
			}
		}

		private void ArrowShot(Vector3 startPos, Vector3 endPos)
		{
			Wind_SGT getInstance = SingletonPunBase.Singleton<Wind_SGT>.GetInstance;
			Arrow_CTRL component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ArrowPref"), startPos, Quaternion.identity).GetComponent<Arrow_CTRL>();
			component.num_Arrow = playerNum;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.arrowList.Add(component.gameObject);
			if (playerNum == 1)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
			}
			else
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2++;
			}
			float drag = component.GetComponent<Rigidbody>().drag;
			Vector3 velocity = SingletonBase.Singleton<Physics_SGT>.GetInstance.GetVelocity(startPos, endPos, drag, 1f);
			Vector2 windDir = new Vector2(getInstance.windSin * getInstance.windForce, getInstance.windCos * getInstance.windForce);
			component.SetPlay(velocity, windDir, endPos);
		}
	}
	public class AimCamera_CTRL : MonoBehaviour
	{
		private Transform trans_AimCamera;

		private void Start()
		{
			trans_AimCamera = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Origin"), base.transform.position, base.transform.rotation, base.transform.parent).transform;
			trans_AimCamera.name = "Origin";
			base.transform.SetParent(null);
		}

		private void Update()
		{
			AimCameraPosRotChange();
		}

		private void AimCameraPosRotChange()
		{
			base.transform.position = trans_AimCamera.position;
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, trans_AimCamera.rotation, Time.deltaTime * 3f);
		}
	}
	public class Arrow_CTRL : MonoBehaviour
	{
		private Rigidbody rigid;

		private Vector2 wind;

		private Vector3 velo;

		private Vector3 hitPos;

		private Vector3 startPos;

		private Vector3 savePos;

		private Vector3 currentVelo;

		private float time;

		private bool isPlay;

		public AudioSource hitTarget;

		public int num_Arrow { get; set; }

		private void Awake()
		{
			rigid = GetComponent<Rigidbody>();
		}

		private void FixedUpdate()
		{
			if (isPlay)
			{
				Move();
			}
		}

		public void SetPlay(Vector3 startVelo, Vector2 windDir, Vector3 hitPoint)
		{
			isPlay = true;
			velo = startVelo;
			wind = windDir;
			hitPos = hitPoint;
			startPos = base.transform.position;
			savePos = startPos;
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Shot);
			rigid.velocity = Vector3.zero;
			rigid.Sleep();
			rigid.constraints = RigidbodyConstraints.None;
		}

		public void SetStop()
		{
			isPlay = false;
			rigid.velocity = Vector3.zero;
			rigid.constraints = RigidbodyConstraints.FreezeAll;
		}

		private void Move()
		{
			Vector3 vector = velo;
			vector /= 1f + rigid.drag * time;
			float num = (Physics.gravity.y + wind.y) * (0.5f * time);
			vector.y += num;
			float num2 = wind.x * (0.5f * time);
			vector.x -= num2;
			vector *= time;
			rigid.MovePosition(startPos + vector);
			currentVelo = (base.transform.position - savePos) / Time.fixedDeltaTime;
			Quaternion b = Quaternion.LookRotation(base.transform.position - savePos);
			rigid.MoveRotation(Quaternion.Lerp(base.transform.rotation, b, currentVelo.sqrMagnitude * 0.1f));
			savePos = base.transform.position;
			time += Time.fixedDeltaTime;
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (isPlay)
			{
				if (collision.transform.CompareTag("Target"))
				{
					SetStop();
					base.transform.position = hitPos - base.transform.forward * 0.7f;
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.HitTarget(num_Arrow, hitPos, isMiss: false);
					hitTarget.Play();
				}
				else if (collision.transform.CompareTag("Map"))
				{
					SetStop();
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.HitTarget(num_Arrow, hitPos, isMiss: true);
				}
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (isPlay && other.transform.CompareTag("Map"))
			{
				SetStop();
				SingletonPunBase.Singleton<Target_SGT>.GetInstance.HitTarget(num_Arrow, hitPos, isMiss: true);
			}
		}
	}
	public class Player_CTRL : MonoBehaviour
	{
		public bool isTest;

		private PhotonView pv;

		private UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

		private UnityEngine.XR.Interaction.Toolkit.XRController RightController;

		private Transform trans_Bow;

		private Transform trans_BowArrow;

		private Transform trans_BowAim;

		private Transform trans_Scope;

		private Transform trans_Arrow;

		private Transform trans_QuiverBelt;

		private Transform trans_Quiver;

		private Transform trans_Aim;

		private Animator anim_Bow;

		private Animator anim_Gauge;

		private MeshRenderer fade_Charge;

		private CanvasGroup canvas_Charge;

		private Image image_Gauge;

		private bool[] isCharge = new bool[2];

		private bool isClickMouse0;

		private bool isClickMouse1;

		private bool isTrace;

		private float pullingForce;

		private Quaternion idleQ = Quaternion.Euler(new Vector3(30f, 0f, 0f));

		private Quaternion lastQ = Quaternion.Euler(new Vector3(90f, 0f, 0f));

		private AudioSource audio_Charge;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnGripL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnGripR = new Appnori.Util.Notifier<bool>();

		private bool isTwinkle;

		private Vector3 pos_Trace_P1 = new Vector3(-1.6f, 0.5f, 45f);

		private Vector3 pos_Trace_P2 = new Vector3(1.6f, 0.5f, 45f);

		public Transform Head { get; set; }

		public Transform LeftHand { get; set; }

		public Transform RightHand { get; set; }

		public GameObject[] spareArrows { get; set; } = new GameObject[3];


		public bool isTrigger { get; set; }

		public bool isDone { get; set; }

		public bool isRightHand { get; set; }

		private void Awake()
		{
			pv = GetComponent<PhotonView>();
			Head = base.transform.Find("Head");
			LeftHand = base.transform.Find("LeftHand");
			RightHand = base.transform.Find("RightHand");
			trans_QuiverBelt = base.transform.Find("QuiverBelt");
			trans_Quiver = base.transform.Find("QuiverBelt/Quiver");
			trans_Aim = base.transform.Find("AimCanvas");
			anim_Gauge = trans_Aim.Find("GaugeBar").GetComponent<Animator>();
			image_Gauge = anim_Gauge.transform.Find("gaugeImage").GetComponent<Image>();
			canvas_Charge = trans_Aim.GetComponent<CanvasGroup>();
			fade_Charge = Head.transform.Find("ChargeFade").GetComponent<MeshRenderer>();
			audio_Charge = GetComponentInChildren<AudioSource>();
			SetChargeAudio(isOn: false, 0f);
			for (int i = 0; i < 3; i++)
			{
				spareArrows[i] = trans_Quiver.Find("ARROW" + i).gameObject;
			}
			CreateBow();
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("FadeSphere"), Head);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ChangeHand_Mul);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(SerialArrow_Mul);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(SetOtherIK_Mul);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(SerialPullingForce_Mull);
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ArrowShot_Multi);
		}

		private void Start()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (pv.IsMine)
				{
					SetRay(isOn: false);
					for (int i = 1; i < 3; i++)
					{
						spareArrows[i].SetActive(value: true);
					}
					OnChangeHand(PublicGameUIManager.gameSetting.IsRightHanded());
					PublicGameUIManager.gameSetting.AddHandChangedEvent(OnChangeHand);
				}
				else
				{
					trans_QuiverBelt.gameObject.SetActive(value: false);
				}
			}
			else
			{
				SetRay(isOn: false);
				for (int j = 1; j < 3; j++)
				{
					spareArrows[j].SetActive(value: true);
				}
				OnChangeHand(PublicGameUIManager.gameSetting.IsRightHanded());
				PublicGameUIManager.gameSetting.AddHandChangedEvent(OnChangeHand);
			}
			LeftController = LeftHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
			OnGripL.OnDataChanged += OnGripL_OnDataChanged;
			OnGripR.OnDataChanged += OnGripR_OnDataChanged;
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (!isRightHand)
			{
				return;
			}
			if (obj)
			{
				if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isSetStart)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
				}
				if (SingletonPunBase.Singleton<UI_SGT>.GetInstance.anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
				{
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.ClickButton("Start");
				}
				isTrigger = true;
				return;
			}
			if (isCharge[0] && isCharge[1])
			{
				ArrowShot();
			}
			isTrigger = false;
			trans_Bow.localRotation = Quaternion.identity;
			pullingForce = 0f;
			Color value = default(Color);
			value.a = pullingForce;
			fade_Charge.material.SetColor("_BaseColor", value);
			canvas_Charge.alpha = pullingForce;
			anim_Bow.SetFloat("Force", pullingForce);
			image_Gauge.fillAmount = pullingForce;
			anim_Gauge.SetTrigger("TwinkleNon");
			isTwinkle = false;
			OffChargeCheck();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<float> data = new LumpsData<float>
				{
					lumps = pullingForce
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialPullingForce_Mull, data, RpcTarget.Others);
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (isRightHand)
			{
				return;
			}
			if (obj)
			{
				if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isSetStart)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.StartGame();
				}
				if (SingletonPunBase.Singleton<UI_SGT>.GetInstance.anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
				{
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.ClickButton("Start");
				}
				isTrigger = true;
				return;
			}
			if (isCharge[0] && isCharge[1])
			{
				ArrowShot();
			}
			isTrigger = false;
			trans_Bow.localRotation = Quaternion.identity;
			pullingForce = 0f;
			Color value = default(Color);
			value.a = pullingForce;
			fade_Charge.material.SetColor("_BaseColor", value);
			canvas_Charge.alpha = pullingForce;
			anim_Bow.SetFloat("Force", pullingForce);
			image_Gauge.fillAmount = pullingForce;
			anim_Gauge.SetTrigger("TwinkleNon");
			isTwinkle = false;
			OffChargeCheck();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<float> data = new LumpsData<float>
				{
					lumps = pullingForce
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialPullingForce_Mull, data, RpcTarget.Others);
			}
		}

		private void OnGripL_OnDataChanged(bool obj)
		{
			if (obj)
			{
				isRightHand = false;
				ChangeHand(isRightHand);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = isRightHand
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ChangeHand_Mul, data, RpcTarget.Others);
				}
			}
		}

		private void OnGripR_OnDataChanged(bool obj)
		{
			if (obj)
			{
				isRightHand = true;
				ChangeHand(isRightHand);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = isRightHand
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ChangeHand_Mul, data, RpcTarget.Others);
				}
			}
		}

		private void OnChangeHand(bool isRight)
		{
			isRightHand = !isRight;
			ChangeHand(isRightHand);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = isRightHand
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ChangeHand_Mul, data, RpcTarget.Others);
			}
		}

		private void Update()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && !pv.IsMine)
			{
				return;
			}
			QuiverRotChange();
			AimRotChange();
			ArrowTriggerCheck();
			TraceArrow();
			if (!isDone && !SingletonPunBase.Singleton<UI_SGT>.GetInstance.isPublicUI)
			{
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
				{
					OnTriggerL.CurrentData = isPressed;
				}
				if (!(SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController != null))
				{
					_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice;
				}
				if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
				{
					OnTriggerR.CurrentData = isPressed2;
				}
			}
		}

		private void CreateBow()
		{
			trans_Bow = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BOW"), base.transform.Find("LeftHand/HandModel/BowPos")).transform;
			trans_BowArrow = trans_Bow.Find("Bone009/ARROW").transform;
			trans_Scope = trans_Bow.Find("AimingPoint/BowCam");
			trans_BowAim = trans_Bow.Find("AimingPoint");
			anim_Bow = trans_Bow.GetComponent<Animator>();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (pv.IsMine)
				{
					trans_Scope.SetParent(base.transform);
				}
				else
				{
					trans_Scope.gameObject.SetActive(value: false);
				}
			}
			else
			{
				trans_Scope.SetParent(base.transform);
			}
		}

		private void ChangeHand(bool isRight)
		{
			if (isRight)
			{
				LeftHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: true);
				RightHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: false);
				trans_Bow.SetParent(RightHand.transform.Find("HandModel/BowPos"));
				trans_Bow.localScale = new Vector3(-1f, 1f, 1f);
				trans_Arrow = LeftHand.transform.Find("HandModel/Arrow");
			}
			else
			{
				LeftHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: false);
				RightHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: true);
				trans_Bow.SetParent(LeftHand.transform.Find("HandModel/BowPos"));
				trans_Bow.localScale = Vector3.one;
				trans_Arrow = RightHand.transform.Find("HandModel/Arrow");
			}
			trans_Bow.localPosition = Vector3.zero;
			trans_Bow.localRotation = Quaternion.identity;
		}

		private void ArrowTriggerCheck()
		{
			if (isCharge[0] && isCharge[1] && isTrigger)
			{
				trans_Bow.rotation = Quaternion.LookRotation(trans_Bow.position - trans_Arrow.position);
				pullingForce = Vector3.Distance(trans_Bow.position, trans_Arrow.position) - 0.35f;
				pullingForce *= 2.3f;
				anim_Bow.SetFloat("Force", pullingForce);
				pullingForce *= 1.8f;
				if (pullingForce < 0f)
				{
					pullingForce = 0f;
				}
				else if (pullingForce > 1f)
				{
					pullingForce = 1f;
				}
				if (!isTwinkle && pullingForce == 1f)
				{
					anim_Gauge.SetTrigger("Twinkle");
					isTwinkle = true;
				}
				else if (isTwinkle && pullingForce < 1f)
				{
					anim_Gauge.SetTrigger("TwinkleNon");
					isTwinkle = false;
				}
				image_Gauge.fillAmount = pullingForce;
				Color value = default(Color);
				value.a = pullingForce * 0.95f;
				fade_Charge.material.SetColor("_BaseColor", value);
				canvas_Charge.alpha = pullingForce;
				SetChargeAudio(isOn: true, pullingForce);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					LumpsData<float> data = new LumpsData<float>
					{
						lumps = pullingForce
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialPullingForce_Mull, data, RpcTarget.Others);
				}
				Haptic(pullingForce / 4f, 0.5f, isRightHand);
			}
		}

		private void ArrowShot()
		{
			Wind_SGT getInstance = SingletonPunBase.Singleton<Wind_SGT>.GetInstance;
			Arrow_CTRL component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ArrowPref"), trans_BowArrow.position, trans_BowArrow.rotation).GetComponent<Arrow_CTRL>();
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.arrowList.Add(component.gameObject);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
					component.num_Arrow = 1;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2++;
					component.num_Arrow = 2;
				}
			}
			else
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
				component.num_Arrow = 1;
			}
			Vector3 vector = SingletonBase.Singleton<Physics_SGT>.GetInstance.TargetRay(trans_Scope);
			float drag = component.GetComponent<Rigidbody>().drag;
			float time = (trans_Scope.position - vector).magnitude / ((pullingForce + 0.1f) * 50f);
			Vector3 velocity = SingletonBase.Singleton<Physics_SGT>.GetInstance.GetVelocity(trans_BowArrow.position, vector, drag, time);
			velocity *= pullingForce;
			Vector2 windDir = new Vector2(getInstance.windSin * getInstance.windForce, getInstance.windCos * getInstance.windForce);
			BowArrowShow(isOn: false);
			isDone = true;
			component.SetPlay(velocity, windDir, vector);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					TraceTarget(vector, -2.7f, 0.5f);
				}
				else
				{
					TraceTarget(vector, -0.5f, 2.7f);
				}
				LumpsData<Vector3, Vector3, Quaternion> data = new LumpsData<Vector3, Vector3, Quaternion>
				{
					lumps1 = trans_BowArrow.position,
					lumps2 = vector,
					lumps3 = component.GetComponent<Rigidbody>().transform.rotation
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ArrowShot_Multi, data, RpcTarget.Others);
				LumpsData<bool> data2 = new LumpsData<bool>
				{
					lumps = false
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialArrow_Mul, data2, RpcTarget.Others);
			}
			else
			{
				TraceTarget(vector, -2.7f, 0.5f);
			}
		}

		private void ArrowShot(Vector3 startPos, Vector3 endPos)
		{
			Wind_SGT getInstance = SingletonPunBase.Singleton<Wind_SGT>.GetInstance;
			Arrow_CTRL component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ArrowPref"), startPos, Quaternion.identity).GetComponent<Arrow_CTRL>();
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.arrowList.Add(component.gameObject);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
					component.num_Arrow = 1;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2++;
					component.num_Arrow = 2;
				}
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = false
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialArrow_Mul, data, RpcTarget.Others);
			}
			else
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
				component.num_Arrow = 1;
			}
			BowArrowShow(isOn: false);
			isDone = true;
			float drag = component.GetComponent<Rigidbody>().drag;
			Vector3 velocity = SingletonBase.Singleton<Physics_SGT>.GetInstance.GetVelocity(startPos, endPos, drag, 1f);
			Vector2 windDir = new Vector2(getInstance.windSin * getInstance.windForce, getInstance.windCos * getInstance.windForce);
			component.SetPlay(velocity, windDir, endPos);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					TraceTarget(endPos, -2.7f, 0.5f);
				}
				else
				{
					TraceTarget(endPos, -0.5f, 2.7f);
				}
				LumpsData<Vector3, Vector3, Quaternion> data2 = new LumpsData<Vector3, Vector3, Quaternion>
				{
					lumps1 = startPos,
					lumps2 = endPos,
					lumps3 = component.GetComponent<Rigidbody>().transform.rotation
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ArrowShot_Multi, data2, RpcTarget.Others);
				LumpsData<bool> data3 = new LumpsData<bool>
				{
					lumps = false
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialArrow_Mul, data3, RpcTarget.Others);
			}
			else
			{
				TraceTarget(endPos, -2.7f, 0.5f);
			}
		}

		public void ArrowShot_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<Vector3, Vector3, Quaternion>)
			{
				Wind_SGT getInstance = SingletonPunBase.Singleton<Wind_SGT>.GetInstance;
				Arrow_CTRL component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ArrowPref"), (packet as LumpsData<Vector3, Vector3, Quaternion>).lumps1, Quaternion.identity).GetComponent<Arrow_CTRL>();
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.arrowList.Add(component.gameObject);
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2++;
					component.num_Arrow = 2;
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
					component.num_Arrow = 1;
				}
				isDone = true;
				float drag = component.GetComponent<Rigidbody>().drag;
				Vector3 velocity = SingletonBase.Singleton<Physics_SGT>.GetInstance.GetVelocity((packet as LumpsData<Vector3, Vector3, Quaternion>).lumps1, (packet as LumpsData<Vector3, Vector3, Quaternion>).lumps2, drag, 1f);
				Vector2 windDir = new Vector2(getInstance.windSin * getInstance.windForce, getInstance.windCos * getInstance.windForce);
				component.transform.rotation = (packet as LumpsData<Vector3, Vector3, Quaternion>).lumps3;
				component.SetPlay(velocity, windDir, (packet as LumpsData<Vector3, Vector3, Quaternion>).lumps2);
			}
		}

		public void ShotMiss(bool isMasterClient = true)
		{
			if (isDone)
			{
				return;
			}
			OffChargeCheck();
			trans_Bow.localRotation = Quaternion.identity;
			isTrigger = false;
			BowArrowShow(isOn: false);
			isDone = true;
			pullingForce = 0f;
			Color value = default(Color);
			value.a = pullingForce;
			fade_Charge.material.SetColor("_BaseColor", value);
			canvas_Charge.alpha = pullingForce;
			anim_Bow.SetFloat("Force", pullingForce);
			anim_Gauge.SetTrigger("TwinkleNon");
			isTwinkle = false;
			image_Gauge.fillAmount = pullingForce;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (isMasterClient)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.scoreBoard_Ctrl[0].SetScore((SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1 - 1) / 3 + 1, SingletonPunBase.Singleton<Game_SGT>.GetInstance.eachScore_P1);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2++;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.scoreBoard_Ctrl[1].SetScore((SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P2 - 1) / 3 + 1, SingletonPunBase.Singleton<Game_SGT>.GetInstance.eachScore_P2);
				}
				LumpsData<float> data = new LumpsData<float>
				{
					lumps = pullingForce
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialPullingForce_Mull, data, RpcTarget.Others);
				LumpsData<bool> data2 = new LumpsData<bool>
				{
					lumps = false
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(SerialArrow_Mul, data2, RpcTarget.Others);
			}
			else
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1++;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.scoreBoard_Ctrl[0].SetScore((SingletonPunBase.Singleton<Game_SGT>.GetInstance.shotCount_P1 - 1) / 3 + 1, SingletonPunBase.Singleton<Game_SGT>.GetInstance.eachScore_P1);
			}
		}

		private void TraceArrow()
		{
			if (!isTrace)
			{
				return;
			}
			float num = 0f;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					base.transform.position = Vector3.MoveTowards(base.transform.position, pos_Trace_P1, 35f * Time.deltaTime);
					num = Vector3.Distance(base.transform.position, pos_Trace_P1);
				}
				else
				{
					base.transform.position = Vector3.MoveTowards(base.transform.position, pos_Trace_P2, 35f * Time.deltaTime);
					num = Vector3.Distance(base.transform.position, pos_Trace_P2);
				}
			}
			else
			{
				base.transform.position = Vector3.MoveTowards(base.transform.position, pos_Trace_P1, 35f * Time.deltaTime);
				num = Vector3.Distance(base.transform.position, pos_Trace_P1);
			}
			if (num == 0f)
			{
				isTrace = false;
				Invoke("TraceReset", 1.5f);
			}
		}

		private void TraceTarget(Vector3 basePos, float minX, float maxX)
		{
			if (pullingForce == 1f && basePos.x > minX && basePos.x < maxX && basePos.y > 0.415f && basePos.y < 2.55f && basePos.z > 55f && basePos.z > 0.57f)
			{
				isTrace = true;
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					GetComponent<Interpolation>().enabled = false;
					Head.GetComponent<Interpolation>().enabled = false;
					RightHand.GetComponent<Interpolation>().enabled = false;
					LeftHand.GetComponent<Interpolation>().enabled = false;
				}
				LeftHand.gameObject.SetActive(value: false);
				RightHand.gameObject.SetActive(value: false);
				trans_Quiver.gameObject.SetActive(value: false);
			}
		}

		private void TraceReset()
		{
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn(delegate
			{
				ChracterPosReset();
			});
		}

		private void ChracterPosReset()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					base.transform.position = new Vector3(-1.6f, 0f, 0f);
				}
				else
				{
					base.transform.position = new Vector3(1.6f, 0f, 0f);
				}
				GetComponent<Interpolation>().enabled = true;
				Head.GetComponent<Interpolation>().enabled = true;
				RightHand.GetComponent<Interpolation>().enabled = true;
				LeftHand.GetComponent<Interpolation>().enabled = true;
			}
			else
			{
				base.transform.position = new Vector3(-1.6f, 0f, 0f);
			}
			LeftHand.gameObject.SetActive(value: true);
			RightHand.gameObject.SetActive(value: true);
			trans_Quiver.gameObject.SetActive(value: true);
		}

		public void OnChargeCheck(int num)
		{
			if (isTrigger)
			{
				isCharge[num] = true;
			}
		}

		public void OffChargeCheck()
		{
			isCharge[0] = false;
			isCharge[1] = false;
			SetChargeAudio(isOn: false, 0f);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(1, isOn: false);
				}
				else
				{
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(2, isOn: false);
				}
			}
			else
			{
				SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(1, isOn: false);
			}
		}

		public bool GetChargeCheck(int num)
		{
			return isCharge[num];
		}

		public void BowArrowShow(bool isOn)
		{
			trans_BowArrow.gameObject.SetActive(isOn);
		}

		public void Haptic(float amplitude = 0.5f, float duration = 0.5f, bool isLeft = true)
		{
			if (!(LeftController == null) && !(RightController == null))
			{
				if (isLeft)
				{
					LeftController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
				else
				{
					RightController.SendHapticImpulse(amplitude * PublicGameUIManager.gameSetting.GetHapticValue(), duration);
				}
			}
		}

		private void QuiverRotChange()
		{
			trans_QuiverBelt.localPosition = new Vector3(Head.transform.localPosition.x, Head.transform.localPosition.y * 0.5f + 0.2f, Head.transform.localPosition.z);
			trans_QuiverBelt.rotation = Quaternion.LookRotation(new Vector3(0f - Head.transform.right.z, 0f, Head.transform.right.x));
			trans_Quiver.localRotation = Quaternion.Lerp(lastQ, idleQ, (trans_QuiverBelt.position.y - 0.2f) * 2f);
		}

		private void AimRotChange()
		{
			trans_Aim.position = Vector3.Lerp(trans_Aim.position, trans_BowAim.position, Time.deltaTime * 5f);
			Quaternion b = Quaternion.LookRotation(Head.position - trans_BowAim.position);
			trans_Aim.rotation = Quaternion.Lerp(trans_Aim.rotation, b, Time.deltaTime * 5f);
			Quaternion b2 = Quaternion.LookRotation(trans_BowAim.position - Head.position);
			trans_Scope.position = Vector3.Lerp(trans_Scope.position, trans_Bow.position, Time.deltaTime * 5f);
			trans_Scope.rotation = Quaternion.Lerp(trans_Scope.rotation, b2, Time.deltaTime * 5f);
		}

		public void SetRay(bool isOn)
		{
			if (isOn)
			{
				LeftHand.GetComponent<XRRayInteractor>().enabled = true;
				RightHand.GetComponent<XRRayInteractor>().enabled = true;
			}
			else
			{
				LeftHand.GetComponent<XRRayInteractor>().enabled = false;
				RightHand.GetComponent<XRRayInteractor>().enabled = false;
			}
		}

		public void SetOtherIK_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				if (!(packet as LumpsData<bool>).lumps)
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.vrik.enabled = false;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.GetComponent<PhotonTransformView>().enabled = false;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.Head.GetComponent<PhotonTransformView>().enabled = false;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.RightHand.GetComponent<PhotonTransformView>().enabled = false;
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.LeftHand.GetComponent<PhotonTransformView>().enabled = false;
				}
				else
				{
					Invoke("DelayOtherIK", 1f);
				}
			}
		}

		public void DelayOtherIK()
		{
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.vrik.transform.position = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.transform.position;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.vrik.enabled = true;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.GetComponent<PhotonTransformView>().enabled = true;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.Head.GetComponent<PhotonTransformView>().enabled = true;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.RightHand.GetComponent<PhotonTransformView>().enabled = true;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.LeftHand.GetComponent<PhotonTransformView>().enabled = true;
		}

		public void SerialPullingForce_Mull(SerializableClass packet)
		{
			if (packet is LumpsData<float>)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.pullingForce = (packet as LumpsData<float>).lumps;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.anim_Bow.SetFloat("Force", SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.pullingForce);
			}
		}

		public void SerialArrow_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_BowArrow.gameObject.SetActive((packet as LumpsData<bool>).lumps);
			}
		}

		public void ChangeHand_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				StartCoroutine(ChangeHand_Mul_C((packet as LumpsData<bool>).lumps));
			}
		}

		private IEnumerator ChangeHand_Mul_C(bool isRight)
		{
			while (SingletonPunBase.Singleton<Game_SGT>.GetInstance.others == null)
			{
				yield return null;
			}
			if (isRight)
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.LeftHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: true);
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.RightHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: false);
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Bow.SetParent(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.RightHand.transform.Find("HandModel/BowPos"));
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Bow.localScale = new Vector3(-1f, 1f, 1f);
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Arrow = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.LeftHand.transform.Find("HandModel/Arrow");
			}
			else
			{
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.LeftHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: false);
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.RightHand.transform.Find("HandModel/Arrow").gameObject.SetActive(value: true);
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Bow.SetParent(SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.LeftHand.transform.Find("HandModel/BowPos"));
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Bow.localScale = Vector3.one;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Arrow = SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.RightHand.transform.Find("HandModel/Arrow");
			}
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Bow.localPosition = Vector3.zero;
			SingletonPunBase.Singleton<Game_SGT>.GetInstance.others.trans_Bow.localRotation = Quaternion.identity;
		}

		public void SetChargeAudio(bool isOn, float vol)
		{
			if (!isOn)
			{
				audio_Charge.volume = 0f;
				audio_Charge.pitch = 1f;
			}
			else
			{
				audio_Charge.volume = ((vol >= 0.1f) ? (vol * 0.4f) : 0f);
				audio_Charge.pitch = 1f + vol * 0.3f;
			}
		}
	}
	public class Quiver_CTRL : MonoBehaviour
	{
		public Transform headTr;

		private Quaternion idleQ;

		private Quaternion lastQ;

		public Transform childTr;

		private void Start()
		{
			idleQ = Quaternion.Euler(new Vector3(30f, 0f, 0f));
			lastQ = Quaternion.Euler(new Vector3(90f, 0f, 0f));
		}

		private void Update()
		{
			base.transform.localPosition = new Vector3(headTr.localPosition.x, headTr.localPosition.y * 0.5f + 0.2f, headTr.localPosition.z);
			base.transform.rotation = Quaternion.LookRotation(new Vector3(0f - headTr.right.z, 0f, headTr.right.x));
			childTr.localRotation = Quaternion.Lerp(lastQ, idleQ, (base.transform.position.y - 0.2f) * 2f);
		}
	}
	public class ScoreBoard_CTRL : MonoBehaviour
	{
		public Text nameText;

		public Text[] scoreText;

		public Text setText;

		public void SetPlayer(string playerName)
		{
			nameText.text = playerName;
		}

		public void SetScore(int count, int score)
		{
			if (!SingletonPunBase.Singleton<Game_SGT>.GetInstance.isShootOff)
			{
				scoreText[count - 1].text = score.ToString();
				scoreText[count - 1].enabled = true;
			}
		}

		public void ResetScore()
		{
			for (int i = 0; i < scoreText.Length; i++)
			{
				scoreText[i].text = "";
				scoreText[i].enabled = false;
			}
			setText.text = "";
			setText.enabled = false;
		}

		public void SetSetPts(int score)
		{
			setText.text = score.ToString();
			setText.enabled = true;
		}

		public void ClearScoreBoard(int pts = 0)
		{
			StartCoroutine("DelayClearScoreBoard", pts);
		}

		private IEnumerator DelayClearScoreBoard(int pts)
		{
			yield return new WaitForSeconds(5f);
			for (int i = 0; i < scoreText.Length; i++)
			{
				scoreText[i].enabled = false;
			}
			setText.enabled = false;
		}
	}
	public class Trigger_CTRL : MonoBehaviour
	{
		private Player_CTRL player;

		private void Awake()
		{
			player = GetComponentInParent<Player_CTRL>();
		}

		private void OnTriggerStay(Collider other)
		{
			if (player.isTrigger && other.CompareTag("Enter01"))
			{
				player.OnChargeCheck(0);
				player.OnChargeCheck(1);
			}
		}
	}
	public class WindTime_CTRL : MonoBehaviour
	{
		public bool isImageText;

		[Header("Time")]
		public Text text_Time;

		public Image[] image_Time;

		public RawImage[] image_Light;

		[Header("Wind")]
		public Text text_Wind;

		public Image[] image_Wind;

		public Transform trans_Windarrow;

		public Sprite[] sprite_Nums;

		private void Awake()
		{
			for (int i = 0; i < image_Light.Length; i++)
			{
				image_Light[i].enabled = false;
			}
		}

		public void StartCount()
		{
			if (!isImageText)
			{
				text_Time.enabled = true;
			}
			image_Light[0].enabled = true;
			image_Light[1].enabled = false;
			image_Light[2].enabled = false;
		}

		public void SetlightState(int state)
		{
			switch (state)
			{
			case 0:
				image_Light[0].enabled = false;
				image_Light[1].enabled = false;
				image_Light[2].enabled = true;
				break;
			case 1:
				image_Light[0].enabled = false;
				image_Light[1].enabled = true;
				image_Light[2].enabled = false;
				break;
			case 2:
				image_Light[0].enabled = true;
				image_Light[1].enabled = false;
				image_Light[2].enabled = false;
				break;
			}
		}

		public void SetText(float currentTime)
		{
			if (currentTime < 0f)
			{
				currentTime = 0f;
			}
			if (isImageText)
			{
				int num = (int)(Mathf.Floor(currentTime) / 10f);
				int num2 = (int)(currentTime % 10f);
				if (num != 0)
				{
					image_Time[0].gameObject.SetActive(value: true);
					image_Time[0].sprite = sprite_Nums[num];
				}
				else
				{
					image_Time[0].gameObject.SetActive(value: false);
				}
				image_Time[1].sprite = sprite_Nums[num2];
			}
			else
			{
				text_Time.text = Mathf.Floor(currentTime).ToString();
			}
		}

		public void SetWindState(Quaternion Q, float windForce)
		{
			trans_Windarrow.localRotation = Q;
			if (isImageText)
			{
				int num = (int)(windForce * 10f % 10f);
				image_Wind[0].sprite = sprite_Nums[(int)windForce];
				image_Wind[1].sprite = sprite_Nums[num];
			}
			else
			{
				text_Wind.text = windForce.ToString("N1");
			}
		}
	}
	public class Player_ARCADE : MonoBehaviour
	{
		private UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

		private UnityEngine.XR.Interaction.Toolkit.XRController RightController;

		private Transform trans_Bow;

		private Transform trans_BowArrow;

		private Transform trans_BowAim;

		private Transform trans_Scope;

		private Transform trans_Arrow;

		private Transform trans_QuiverBelt;

		private Transform trans_Quiver;

		private Transform trans_Aim;

		private Animator anim_Bow;

		private Animator anim_Gauge;

		private MeshRenderer fade_Charge;

		private CanvasGroup canvas_Charge;

		private Image image_Gauge;

		private bool[] isCharge = new bool[2];

		private bool isRightHand;

		private float pullingForce;

		private Quaternion idleQ = Quaternion.Euler(new Vector3(30f, 0f, 0f));

		private Quaternion lastQ = Quaternion.Euler(new Vector3(90f, 0f, 0f));

		private AudioSource audio_Charge;

		public Transform Head { get; set; }

		public Transform LeftHand { get; set; }

		public Transform RightHand { get; set; }

		public GameObject[] spareArrows { get; set; } = new GameObject[3];


		public bool isTrigger { get; set; }

		public bool isDone { get; set; }

		private void Awake()
		{
			Head = base.transform.Find("Head");
			LeftHand = base.transform.Find("LeftHand");
			RightHand = base.transform.Find("RightHand");
			trans_QuiverBelt = base.transform.Find("QuiverBelt");
			trans_Quiver = base.transform.Find("QuiverBelt/Quiver");
			trans_Aim = base.transform.Find("AimCanvas");
			anim_Gauge = trans_Aim.Find("GaugeBar").GetComponent<Animator>();
			image_Gauge = anim_Gauge.transform.Find("gaugeImage").GetComponent<Image>();
			canvas_Charge = trans_Aim.GetComponent<CanvasGroup>();
			fade_Charge = Head.transform.Find("ChargeFade").GetComponent<MeshRenderer>();
			audio_Charge = GetComponentInChildren<AudioSource>();
			SetChargeAudio(isOn: false, 0f);
			for (int i = 0; i < 3; i++)
			{
				spareArrows[i] = trans_Quiver.Find("ARROW" + i).gameObject;
			}
			CreateBow();
		}

		private void Start()
		{
			SetRay(isOn: false);
			for (int i = 1; i < 3; i++)
			{
				spareArrows[i].SetActive(value: true);
			}
			LeftController = LeftHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightHand.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
		}

		private void Update()
		{
			ArrowTriggerCheck();
			if (((Input.GetButtonDown("Right Trigger") && !isRightHand) || (Input.GetButtonDown("Left Trigger") && isRightHand)) && !isDone)
			{
				isTrigger = true;
			}
			else if (((Input.GetButtonUp("Right Trigger") && !isRightHand) || (Input.GetButtonUp("Left Trigger") && isRightHand)) && !isDone)
			{
				if (isCharge[0] && isCharge[1])
				{
					ArrowShot();
				}
				isTrigger = false;
				trans_Bow.localRotation = Quaternion.identity;
				pullingForce = 0f;
				anim_Bow.SetFloat("Force", pullingForce);
				OffChargeCheck();
			}
			if (Input.GetButtonUp("Left Grap"))
			{
				isRightHand = false;
				ChangeHand(isRightHand);
			}
			else if (Input.GetButtonUp("Right Grap"))
			{
				isRightHand = true;
				ChangeHand(isRightHand);
			}
		}

		private void CreateBow()
		{
			trans_Bow = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("BOW"), base.transform.Find("LeftHand/BowPos")).transform;
			trans_BowArrow = trans_Bow.Find("Bone009/ARROW").transform;
			trans_Scope = trans_Bow.Find("AimingPoint/BowCam");
			trans_BowAim = trans_Bow.Find("AimingPoint");
			anim_Bow = trans_Bow.GetComponent<Animator>();
			trans_Scope.SetParent(base.transform);
			ChangeHand(isRight: false);
		}

		private void ChangeHand(bool isRight)
		{
			if (isRight)
			{
				LeftHand.transform.Find("Arrow").gameObject.SetActive(value: true);
				RightHand.transform.Find("Arrow").gameObject.SetActive(value: false);
				trans_Bow.SetParent(RightHand.transform.Find("BowPos"));
				trans_Bow.localScale = new Vector3(-1f, 1f, 1f);
				trans_Arrow = LeftHand.transform.Find("Arrow");
			}
			else
			{
				LeftHand.transform.Find("Arrow").gameObject.SetActive(value: false);
				RightHand.transform.Find("Arrow").gameObject.SetActive(value: true);
				trans_Bow.SetParent(LeftHand.transform.Find("BowPos"));
				trans_Bow.localScale = Vector3.one;
				trans_Arrow = RightHand.transform.Find("Arrow");
			}
			trans_Bow.localPosition = Vector3.zero;
			trans_Bow.localRotation = Quaternion.identity;
		}

		private void ArrowTriggerCheck()
		{
			if (isCharge[0] && isCharge[1] && isTrigger)
			{
				trans_Bow.rotation = Quaternion.LookRotation(trans_Bow.position - trans_Arrow.position);
				pullingForce = Vector3.Distance(trans_Bow.position, trans_Arrow.position) - 0.35f;
				pullingForce *= 2.3f;
				anim_Bow.SetFloat("Force", pullingForce);
				pullingForce *= 1.8f;
				if (pullingForce < 0f)
				{
					pullingForce = 0f;
				}
				else if (pullingForce > 1f)
				{
					pullingForce = 1f;
				}
				SetChargeAudio(isOn: true, pullingForce);
				Haptic(pullingForce, 0.5f, isRightHand);
			}
		}

		private void ArrowShot()
		{
			Transform transform = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("ArrowPref_ARCADE"), trans_BowArrow.position, trans_BowArrow.rotation).transform;
			isDone = true;
			transform.GetComponent<Rigidbody>().AddForce(transform.forward * pullingForce * 10f);
		}

		public void OnChargeCheck(int num)
		{
			if (isTrigger)
			{
				isCharge[num] = true;
			}
		}

		public void OffChargeCheck()
		{
			isCharge[0] = false;
			isCharge[1] = false;
			SetChargeAudio(isOn: false, 0f);
		}

		public bool GetChargeCheck(int num)
		{
			return isCharge[num];
		}

		public void Haptic(float amplitude = 0.5f, float duration = 0.5f, bool isLeft = true)
		{
			if (isLeft)
			{
				LeftController.SendHapticImpulse(amplitude, duration);
			}
			else
			{
				RightController.SendHapticImpulse(amplitude, duration);
			}
		}

		public void SetRay(bool isOn)
		{
			if (isOn)
			{
				LeftHand.GetComponent<XRRayInteractor>().enabled = true;
				RightHand.GetComponent<XRRayInteractor>().enabled = true;
			}
			else
			{
				LeftHand.GetComponent<XRRayInteractor>().enabled = false;
				RightHand.GetComponent<XRRayInteractor>().enabled = false;
			}
		}

		public void SetChargeAudio(bool isOn, float vol)
		{
			if (!isOn)
			{
				audio_Charge.volume = 0f;
				audio_Charge.pitch = 1f;
			}
			else
			{
				audio_Charge.volume = ((vol >= 0.1f) ? (0.3f + vol * 0.5f) : 0f);
				audio_Charge.pitch = 1f + vol * 0.3f;
			}
		}
	}
	public class Game_SGT : SingletonPunBase.Singleton<Game_SGT>, IPunObservable
	{
		private PhotonView pv;

		private float playTimeScale = 1f;

		public Material rayMaterial;

		public Material handMaterial;

		private AIPlayer_CTRL ai_P2;

		private bool isMasterClient;

		public ScoreBoard_CTRL[] scoreBoard_Ctrl;

		public Text text_Player1;

		public Text text_Player2;

		public bool isGameStart { get; set; }

		public bool isSetStart { get; set; }

		public bool isShootOff { get; set; }

		public float time { get; set; } = 16f;


		public float recieveTime { get; set; } = 16f;


		public bool isDone { get; set; }

		public bool isDone_Others { get; set; }

		public Player_CTRL player { get; set; }

		public Player_CTRL others { get; set; }

		public List<GameObject> arrowList { get; set; } = new List<GameObject>();


		public int scoreCumulative { get; set; }

		public int eachScore_P1 { get; set; }

		public int eachScore_P2 { get; set; }

		public int setScore_P1 { get; set; }

		public int setScore_P2 { get; set; }

		public int shotCount_P1 { get; set; }

		public int shotCount_P2 { get; set; }

		public float shootOffScore_P1 { get; set; }

		public float shootOffScore_P2 { get; set; }

		public VRIK vrik { get; set; }

		private void Start()
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomHand();
			Time.timeScale = playTimeScale;
			pv = GetComponent<PhotonView>();
			pv.Synchronization = ViewSynchronization.UnreliableOnChange;
			pv.ObservedComponents[0] = this;
			SpawnPlayer();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				StartCoroutine(DelaySpawnOtherVRIK_C());
			}
			else
			{
				text_Player1.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
				text_Player2.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_Player1.text = text_Player1.text;
				SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_Player2.text = text_Player2.text;
			}
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(LeftPlayer_Mul);
		}

		void IPunObservable.OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (PhotonNetwork.IsConnected)
			{
				if (stream.IsWriting)
				{
					stream.SendNext(time);
				}
				else
				{
					recieveTime = (float)stream.ReceiveNext();
				}
			}
		}

		private void FixedUpdate()
		{
			TimeFlowGame();
		}

		public void ResetGame()
		{
			StartCoroutine(ResetGame_C());
		}

		private IEnumerator ResetGame_C()
		{
			isGameStart = true;
			isSetStart = true;
			time = 16f;
			recieveTime = 16f;
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.Reset();
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.SetLight(0);
			player.isDone = false;
			player.BowArrowShow(isOn: true);
			for (int i = 1; i < 3; i++)
			{
				player.spareArrows[i].SetActive(value: true);
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				while (others == null)
				{
					yield return null;
				}
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(1, isOn: true);
				}
				else
				{
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(2, isOn: true);
				}
				others.isDone = false;
				others.BowArrowShow(isOn: true);
			}
			else
			{
				while (ai_P2 == null)
				{
					yield return null;
				}
				SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(1, isOn: true);
				ai_P2.isDone = false;
				ai_P2.Shot();
			}
			eachScore_P1 = 0;
			eachScore_P2 = 0;
			setScore_P1 = 0;
			setScore_P2 = 0;
			shotCount_P1 = 0;
			shotCount_P2 = 0;
			scoreBoard_Ctrl[0].ResetScore();
			scoreBoard_Ctrl[1].ResetScore();
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_EndSResult.text = "";
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_EndSSetScore_P1.text = "";
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_EndSSetScore_P2.text = "";
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_EndSEachScore_P1.text = "";
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_EndSEachScore_P2.text = "";
			foreach (GameObject arrow in arrowList)
			{
				UnityEngine.Object.Destroy(arrow);
			}
			arrowList.Clear();
		}

		public void StartGame()
		{
			StartCoroutine(StartGame_C());
		}

		private IEnumerator StartGame_C()
		{
			time = 16f;
			recieveTime = 16f;
			isSetStart = true;
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.Reset();
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.SetLight(0);
			player.isDone = false;
			player.BowArrowShow(isOn: true);
			if (shotCount_P1 != 0 && shotCount_P2 != 0)
			{
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Ready_Cn);
				}
				else
				{
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Ready);
				}
			}
			if (player.isRightHand)
			{
				player.Haptic(0.5f, 0.1f, isLeft: false);
			}
			else
			{
				player.Haptic(0.5f, 0.1f);
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				while (others == null)
				{
					yield return null;
				}
				if (PhotonNetwork.IsMasterClient)
				{
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(1, isOn: true);
					player.spareArrows[shotCount_P1 % 3].SetActive(value: false);
				}
				else
				{
					SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(2, isOn: true);
					player.spareArrows[shotCount_P2 % 3].SetActive(value: false);
				}
				others.isDone = false;
				others.BowArrowShow(isOn: true);
			}
			else
			{
				while (ai_P2 == null)
				{
					yield return null;
				}
				SingletonPunBase.Singleton<Target_SGT>.GetInstance.SetTurnEffect(1, isOn: true);
				player.spareArrows[shotCount_P1 % 3].SetActive(value: false);
				ai_P2.isDone = false;
				ai_P2.Shot();
			}
		}

		private IEnumerator TimeOut_C()
		{
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut_Cn);
			}
			else
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_TimeOut);
			}
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("InfoSOpen");
			yield return new WaitForSecondsRealtime(2.5f);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("InfoSClose");
		}

		private IEnumerator ShootOff_C()
		{
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_UIOpen);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("WaitOpen");
			yield return new WaitForSecondsRealtime(2.5f);
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_UIClose);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.AnimationPlay("WaitClose");
		}

		public void EndGame()
		{
			if (isSetStart)
			{
				isSetStart = false;
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					player.ShotMiss(PhotonNetwork.IsMasterClient);
					others.ShotMiss(!PhotonNetwork.IsMasterClient);
				}
				else
				{
					player.ShotMiss();
					ai_P2.ShotMiss();
				}
				StartCoroutine(EndGame_C());
			}
		}

		private IEnumerator EndGame_C()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				while (!player.isDone || !others.isDone)
				{
					yield return null;
				}
			}
			else
			{
				while (!player.isDone || !ai_P2.isDone)
				{
					yield return null;
				}
			}
			yield return YieldInstructionCache.WaitForSeconds(4f);
			if (!isShootOff)
			{
				if (shotCount_P1 % 3 != 0 && shotCount_P2 % 3 != 0)
				{
					StartGame();
					yield break;
				}
				if (eachScore_P1 > eachScore_P2)
				{
					setScore_P1 += 2;
				}
				else if (eachScore_P1 < eachScore_P2)
				{
					setScore_P2 += 2;
				}
				else
				{
					setScore_P1++;
					setScore_P2++;
				}
				scoreBoard_Ctrl[0].SetSetPts(setScore_P1);
				scoreBoard_Ctrl[1].SetSetPts(setScore_P2);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
				{
					scoreCumulative += eachScore_P1;
					if (shotCount_P1 == 6 && scoreCumulative == 60)
					{
						SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach16", 1);
					}
				}
				UI_SGT ui_SGT = SingletonPunBase.Singleton<UI_SGT>.GetInstance;
				ui_SGT.text_EndSSetScore_P1.text = setScore_P1.ToString();
				ui_SGT.text_EndSSetScore_P2.text = setScore_P2.ToString();
				ui_SGT.text_EndSEachScore_P1.text = eachScore_P1.ToString();
				ui_SGT.text_EndSEachScore_P2.text = eachScore_P2.ToString();
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					if (Mathf.Abs(setScore_P1 - setScore_P2) < 4 && setScore_P1 != 4 && setScore_P2 != 4 && (setScore_P1 != 3 || setScore_P2 != 3))
					{
						if (eachScore_P1 > eachScore_P2)
						{
							if (PhotonNetwork.IsMasterClient)
							{
								ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0048");
								SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
							}
							else
							{
								ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0047");
								SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
							}
						}
						else if (eachScore_P1 < eachScore_P2)
						{
							if (PhotonNetwork.IsMasterClient)
							{
								ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0047");
								SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
							}
							else
							{
								ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0048");
								SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
							}
						}
						else
						{
							ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0049");
							SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(2);
						}
						ui_SGT.SetButtons(isOn: false);
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_UIOpen);
						ui_SGT.AnimationPlay("EndSOpen");
						yield return YieldInstructionCache.WaitForSeconds(3f);
						SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_UIClose);
						ui_SGT.AnimationPlay("EndSClose");
						Invoke("StartGame", 3f);
						for (int i = 0; i < 3; i++)
						{
							player.spareArrows[i].SetActive(value: true);
						}
					}
					else if (setScore_P1 > setScore_P2)
					{
						int winnerPlayer = 0;
						isGameStart = false;
						ui_SGT.EndMResult();
						PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
						{
							setScore_P1.ToString(),
							setScore_P2.ToString()
						}, winnerPlayer);
					}
					else if (setScore_P1 < setScore_P2)
					{
						int winnerPlayer = 1;
						isGameStart = false;
						ui_SGT.EndMResult();
						PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
						{
							setScore_P1.ToString(),
							setScore_P2.ToString()
						}, winnerPlayer);
					}
					else
					{
						StartCoroutine(ShootOff_C());
						isGameStart = false;
						isShootOff = true;
						yield return YieldInstructionCache.WaitForSeconds(3.5f);
						StartGame();
					}
				}
				else if (Mathf.Abs(setScore_P1 - setScore_P2) < 4 && setScore_P1 != 4 && setScore_P2 != 4 && (setScore_P1 != 3 || setScore_P2 != 3))
				{
					if (eachScore_P1 > eachScore_P2)
					{
						ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0048");
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(0);
					}
					else if (eachScore_P1 < eachScore_P2)
					{
						ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0047");
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(1);
					}
					else
					{
						ui_SGT.text_EndSResult.text = GameSettingCtrl.GetLocalizationText("0049");
						SingletonBase.Singleton<Referee_SGT>.GetInstance.Play(2);
					}
					ui_SGT.SetButtons(isOn: false);
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_UIOpen);
					ui_SGT.AnimationPlay("EndSOpen");
					yield return YieldInstructionCache.WaitForSeconds(3f);
					SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_UIClose);
					ui_SGT.AnimationPlay("EndSClose");
					Invoke("StartGame", 3f);
					for (int j = 0; j < 3; j++)
					{
						player.spareArrows[j].SetActive(value: true);
					}
				}
				else if (setScore_P1 > setScore_P2)
				{
					int winnerPlayer2 = 0;
					isGameStart = false;
					SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
					PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
					{
						setScore_P1.ToString(),
						setScore_P2.ToString()
					}, winnerPlayer2);
				}
				else if (setScore_P1 < setScore_P2)
				{
					int winnerPlayer2 = 1;
					isGameStart = false;
					SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
					PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
					{
						setScore_P1.ToString(),
						setScore_P2.ToString()
					}, winnerPlayer2);
				}
				else
				{
					StartCoroutine(ShootOff_C());
					isGameStart = false;
					isShootOff = true;
					yield return YieldInstructionCache.WaitForSeconds(3.5f);
					StartGame();
				}
				eachScore_P1 = 0;
				eachScore_P2 = 0;
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (shootOffScore_P1 == shootOffScore_P2)
				{
					StartCoroutine(ShootOff_C());
					yield return YieldInstructionCache.WaitForSeconds(3.5f);
					StartGame();
				}
				else if (shootOffScore_P1 > shootOffScore_P2)
				{
					int winnerPlayer3 = 0;
					isGameStart = false;
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.EndMResult();
					PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
					{
						(Math.Truncate(shootOffScore_P1 * 100f) / 100.0).ToString(),
						(Math.Truncate(shootOffScore_P2 * 100f) / 100.0).ToString()
					}, winnerPlayer3);
				}
				else
				{
					int winnerPlayer3 = 1;
					isGameStart = false;
					SingletonPunBase.Singleton<UI_SGT>.GetInstance.EndMResult();
					PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
					{
						(Math.Truncate(shootOffScore_P1 * 100f) / 100.0).ToString(),
						(Math.Truncate(shootOffScore_P2 * 100f) / 100.0).ToString()
					}, winnerPlayer3);
				}
			}
			else if (shootOffScore_P1 == shootOffScore_P2)
			{
				StartCoroutine(ShootOff_C());
				yield return YieldInstructionCache.WaitForSeconds(3.5f);
				StartGame();
			}
			else if (shootOffScore_P1 > shootOffScore_P2)
			{
				int winnerPlayer3 = 0;
				isGameStart = false;
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					(Math.Truncate(shootOffScore_P1 * 100f) / 100.0).ToString(),
					(Math.Truncate(shootOffScore_P2 * 100f) / 100.0).ToString()
				}, winnerPlayer3);
			}
			else
			{
				int winnerPlayer3 = 1;
				isGameStart = false;
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					(Math.Truncate(shootOffScore_P1 * 100f) / 100.0).ToString(),
					(Math.Truncate(shootOffScore_P2 * 100f) / 100.0).ToString()
				}, winnerPlayer3);
			}
		}

		private void TimeFlowGame()
		{
			if (!isSetStart)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					time -= Time.deltaTime * 1f / playTimeScale;
				}
				else
				{
					time = recieveTime;
				}
			}
			else
			{
				time -= Time.deltaTime * 1f / playTimeScale;
			}
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.SetTime(time);
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.WindChange();
			if (time <= 0f)
			{
				if (!isShootOff)
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
					{
						if (!player.isDone)
						{
							StartCoroutine(TimeOut_C());
						}
					}
					else
					{
						StartCoroutine(TimeOut_C());
					}
				}
				EndGame();
			}
			else
			{
				if (!(time > 0f) || !(time <= 21f))
				{
					return;
				}
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					if (player.isDone && others.isDone)
					{
						EndGame();
					}
				}
				else if (player.isDone && ai_P2.isDone)
				{
					EndGame();
				}
				if (time > 0f && time <= 5f)
				{
					SingletonPunBase.Singleton<Wind_SGT>.GetInstance.SetLight(2);
				}
				else if (time > 5f && time <= 10f)
				{
					SingletonPunBase.Singleton<Wind_SGT>.GetInstance.SetLight(1);
				}
				else
				{
					SingletonPunBase.Singleton<Wind_SGT>.GetInstance.SetLight(0);
				}
			}
		}

		private void SpawnPlayer()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance == null)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.None || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				player = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("AR_SinglePlayer")).GetComponent<Player_CTRL>();
				player.transform.position = new Vector3(-1.6f, 0f, 0f);
				ai_P2 = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("AR_AIPlayer")).GetComponent<AIPlayer_CTRL>();
				ai_P2.playerNum = 2;
				ai_P2.transform.position = new Vector3(1.6f, 0f, 0f);
			}
			else
			{
				player = PhotonNetwork.Instantiate("AR_MultiPlayer", Vector3.zero, Quaternion.identity, 0).GetComponent<Player_CTRL>();
				player.gameObject.name = "Player";
				if (PhotonNetwork.IsMasterClient)
				{
					player.transform.position = new Vector3(-1.6f, 0f, 0f);
				}
				else
				{
					player.transform.position = new Vector3(1.6f, 0f, 0f);
				}
			}
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.windTime_Ctrl[0] = player.transform.GetComponentInChildren<WindTime_CTRL>();
			SingletonPunBase.Singleton<Wind_SGT>.GetInstance.anim_Wind = SingletonPunBase.Singleton<Wind_SGT>.GetInstance.windTime_Ctrl[0].GetComponentInChildren<Animator>();
			SpawnUI();
			SetPlayerXR();
		}

		private void SpawnUI()
		{
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("AR_InGameUI"));
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position = player.transform.position + player.transform.forward * 1.5f;
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.LookAt(player.transform);
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.transform.position += new Vector3(0f, 1.3f, 0f);
		}

		private IEnumerator DelaySpawnOtherVRIK_C()
		{
			while (GameObject.Find("AR_MultiPlayer(Clone)") == null)
			{
				yield return null;
			}
			others = GameObject.Find("AR_MultiPlayer(Clone)").GetComponent<Player_CTRL>();
			others.name = "Others";
			vrik = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("VRIK"), others.transform.position, Quaternion.identity).GetComponent<VRIK>();
			SkinnedMeshRenderer component = others.LeftHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>();
			component.material = handMaterial;
			others.RightHand.Find("HandModel/HAND").GetComponent<SkinnedMeshRenderer>().material = handMaterial;
			others.LeftHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			others.RightHand.Find("HandModel/HAND").transform.localScale = Vector3.one * 1.4f;
			vrik.solver.spine.headTarget = others.Head.Find("IK1");
			vrik.solver.spine.pelvisTarget = others.transform.Find("Pelvis");
			vrik.solver.leftArm.target = others.LeftHand.Find("IK");
			vrik.solver.rightArm.target = others.RightHand.Find("IK");
			CustomModelSettingCtrl component2 = vrik.GetComponent<CustomModelSettingCtrl>();
			component2.enabled = true;
			if (PhotonNetwork.IsMasterClient)
			{
				component2.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id, CustomModelViewState.HalfCut2, component);
			}
			else
			{
				component2.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id, CustomModelViewState.HalfCut2, component);
			}
			text_Player1.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			text_Player2.text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_Player1.text = text_Player1.text;
			SingletonPunBase.Singleton<UI_SGT>.GetInstance.text_Player2.text = text_Player2.text;
			isMasterClient = PhotonNetwork.IsMasterClient;
		}

		private void SetPlayerXR()
		{
			GameObject gameObject = player.transform.Find("Head").gameObject;
			GameObject obj = player.transform.Find("LeftHand").gameObject;
			GameObject gameObject2 = player.transform.Find("RightHand").gameObject;
			XRRig xRRig = player.gameObject.AddComponent<XRRig>();
			xRRig.cameraGameObject = gameObject;
			xRRig.TrackingOriginMode = TrackingOriginModeFlags.Floor;
			Camera camera = gameObject.AddComponent<Camera>();
			camera.nearClipPlane = 0.01f;
			camera.cullingMask = 1 << LayerMask.NameToLayer("NoVisible");
			camera.cullingMask = ~camera.cullingMask;
			gameObject.AddComponent<AudioListener>();
			gameObject.AddComponent<UniversalAdditionalCameraData>();
			gameObject.AddComponent<UnityEngine.SpatialTracking.TrackedPoseDriver>();
			UnityEngine.XR.Interaction.Toolkit.XRController xRController = obj.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController.controllerNode = XRNode.LeftHand;
			xRController.selectUsage = InputHelpers.Button.Trigger;
			obj.AddComponent<XRRayInteractor>();
			obj.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual = obj.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual.lineWidth = 0.015f;
			xRInteractorLineVisual.lineLength = 1.5f;
			xRInteractorLineVisual.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			UnityEngine.XR.Interaction.Toolkit.XRController xRController2 = gameObject2.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			xRController2.controllerNode = XRNode.RightHand;
			xRController2.selectUsage = InputHelpers.Button.Trigger;
			gameObject2.AddComponent<XRRayInteractor>();
			gameObject2.AddComponent<LineRenderer>().material = rayMaterial;
			XRInteractorLineVisual xRInteractorLineVisual2 = gameObject2.AddComponent<XRInteractorLineVisual>();
			xRInteractorLineVisual2.lineWidth = 0.015f;
			xRInteractorLineVisual2.lineLength = 1.5f;
			xRInteractorLineVisual2.validColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(Color.green, 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
			xRInteractorLineVisual2.invalidColorGradient = new Gradient
			{
				colorKeys = new GradientColorKey[2]
				{
					new GradientColorKey(new Color(0f, 0.2f, 1f), 0f),
					new GradientColorKey(Color.white, 1f)
				},
				alphaKeys = new GradientAlphaKey[2]
				{
					new GradientAlphaKey(0.5f, 0f),
					new GradientAlphaKey(0f, 1f)
				}
			};
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			isSetStart = false;
			isGameStart = false;
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}

		public void LeftPlayer_Mul(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				isSetStart = false;
				isGameStart = false;
				string nickName = PhotonNetwork.LocalPlayer.NickName;
				int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
				PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
			}
		}
	}
	public class Physics_SGT : SingletonBase.Singleton<Physics_SGT>
	{
		private RaycastHit hit;

		public Vector3 previewPos { get; set; } = Vector3.zero;


		private void Start()
		{
		}

		private void Update()
		{
		}

		public Vector3 TargetRay(Transform origin)
		{
			Wind_SGT getInstance = SingletonPunBase.Singleton<Wind_SGT>.GetInstance;
			if (Physics.Raycast(origin.position, (origin.forward + origin.up * getInstance.windCos * getInstance.windForce * 0.002f + origin.right * getInstance.windSin * getInstance.windForce * -0.002f).normalized, out hit, 70f, -1 - ((1 << LayerMask.NameToLayer("UI")) | (1 << LayerMask.NameToLayer("Ball")) | (1 << LayerMask.NameToLayer("Pocket")))))
			{
				previewPos = hit.point;
				return previewPos;
			}
			previewPos = origin.position + origin.forward * 50f;
			return previewPos;
		}

		public Vector3 GetVelocity(Vector3 Departure, Vector3 Arrival, float drag, float time)
		{
			Wind_SGT getInstance = SingletonPunBase.Singleton<Wind_SGT>.GetInstance;
			Vector3 vector = (Arrival - Departure) / time;
			vector.y -= (Physics.gravity.y + getInstance.windCos * getInstance.windForce) * time * 0.5f;
			vector.x += getInstance.windSin * getInstance.windForce * time * 0.5f;
			return vector * (1f + drag * time);
		}
	}
	public class Sound_SGT : SingletonPunBase.Singleton<Sound_SGT>
	{
		public AudioSource audioSource_Num1;

		public AudioSource audioSource_Num2;

		private AudioSource audioSource;

		public AudioClip clip_ButtonFocus;

		public AudioClip clip_ButtonPress;

		public AudioClip clip_UIOpen;

		public AudioClip clip_UIClose;

		public AudioClip clip_Shot;

		public AudioClip clip_Start;

		public AudioClip clip_TimeOut;

		public AudioClip clip_Ready;

		public AudioClip[] clip_Count;

		public AudioClip clip_TimeOut_Cn;

		public AudioClip clip_Ready_Cn;

		public AudioClip[] clip_Count_Cn;

		public AudioClip clip_MaxCheer;

		public AudioClip[] clip_Cheer;

		public AudioClip[] clip_Boos;

		private void Start()
		{
			audioSource = GetComponent<AudioSource>();
		}

		public void PlaySound(AudioClip clip)
		{
			audioSource.pitch = 1f;
			audioSource.PlayOneShot(clip);
		}

		public void PlaySound(AudioClip[] clip)
		{
			audioSource.PlayOneShot(clip[UnityEngine.Random.Range(0, clip.Length)]);
		}

		public void PlaySoundNum(int num, AudioClip clip)
		{
			if (num == 1)
			{
				audioSource_Num1.pitch = 1f;
				audioSource_Num1.PlayOneShot(clip);
			}
			else
			{
				audioSource_Num2.pitch = 1f;
				audioSource_Num2.PlayOneShot(clip);
			}
		}
	}
	public class Target_SGT : SingletonPunBase.Singleton<Target_SGT>
	{
		public Transform trans_Target_P1;

		public Transform trans_Target_P2;

		private Transform[] trans_Points_P1;

		private Transform[] trans_Points_P2;

		private float[] PointsDistance_P1;

		private float[] PointsDistance_P2;

		private ParticleSystem hit_Effect_P1;

		private ParticleSystem hit_Effect_P2;

		private Animator anim_Effect_P1;

		private Animator anim_Effect_P2;

		private Animator anim_Turn_P1;

		private Animator anim_Turn_P2;

		private Image[] image_Num_P1 = new Image[3];

		private Image[] image_Num_P2 = new Image[3];

		private GameObject arrowPoint_P1;

		private GameObject arrowPoint_P2;

		public Sprite[] sprite_Nums;

		private void Start()
		{
			SetTarget(trans_Target_P1, ref trans_Points_P1, ref PointsDistance_P1);
			SetTarget(trans_Target_P2, ref trans_Points_P2, ref PointsDistance_P2);
			hit_Effect_P1 = base.transform.Find("TargetEffect/P1/Hit_Effect").GetComponent<ParticleSystem>();
			hit_Effect_P2 = base.transform.Find("TargetEffect/P2/Hit_Effect").GetComponent<ParticleSystem>();
			anim_Effect_P1 = base.transform.Find("TargetEffect/P1/Point_Effect").GetComponent<Animator>();
			anim_Effect_P2 = base.transform.Find("TargetEffect/P2/Point_Effect").GetComponent<Animator>();
			anim_Turn_P1 = base.transform.Find("TargetEffect/P1/TurnArrow").GetComponent<Animator>();
			anim_Turn_P2 = base.transform.Find("TargetEffect/P2/TurnArrow").GetComponent<Animator>();
			arrowPoint_P1 = base.transform.Find("TargetEffect/P1/Point").gameObject;
			arrowPoint_P2 = base.transform.Find("TargetEffect/P2/Point").gameObject;
			for (int i = 0; i < 3; i++)
			{
				image_Num_P1[i] = anim_Effect_P1.transform.GetChild(i).GetComponent<Image>();
				image_Num_P2[i] = anim_Effect_P2.transform.GetChild(i).GetComponent<Image>();
			}
		}

		private void Update()
		{
		}

		private void SetTarget(Transform target, ref Transform[] points, ref float[] distance)
		{
			distance = new float[target.childCount];
			points = new Transform[target.childCount];
			for (int i = 0; i < target.childCount; i++)
			{
				points[i] = target.GetChild(i);
				distance[i] = Vector3.Distance(target.position, points[i].position);
			}
		}

		public void HitTarget(int playerNum, Vector3 hitPoint, bool isMiss)
		{
			Game_SGT getInstance = SingletonPunBase.Singleton<Game_SGT>.GetInstance;
			if (!getInstance.isShootOff)
			{
				switch (playerNum)
				{
				case 1:
					if (!isMiss)
					{
						float num3 = Vector3.Distance(trans_Target_P1.position, hitPoint);
						StartCoroutine(DelayArrowPoint_C(arrowPoint_P1, hitPoint));
						for (int num4 = 10; num4 >= 1; num4--)
						{
							if (num3 <= PointsDistance_P1[num4])
							{
								hit_Effect_P1.Play();
								PointUp(anim_Effect_P1, image_Num_P1, num4, 1);
								getInstance.eachScore_P1 += num4;
								getInstance.scoreBoard_Ctrl[0].SetScore((getInstance.shotCount_P1 - 1) / 3 + 1, getInstance.eachScore_P1);
								switch (num4)
								{
								case 10:
									Invoke("DelayCheerSoundMax", 0.3f);
									if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
									{
										SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach15", 1);
									}
									break;
								case 9:
									Invoke("DelayCheerSound", 0.3f);
									break;
								default:
									Invoke("DelayOhhSound", 0.3f);
									break;
								}
								return;
							}
						}
					}
					PointUp(anim_Effect_P1, image_Num_P1, 0, 1);
					getInstance.eachScore_P1 = getInstance.eachScore_P1;
					getInstance.scoreBoard_Ctrl[0].SetScore((getInstance.shotCount_P1 - 1) / 3 + 1, getInstance.eachScore_P1);
					break;
				case 2:
					if (!isMiss)
					{
						float num = Vector3.Distance(trans_Target_P2.position, hitPoint);
						StartCoroutine(DelayArrowPoint_C(arrowPoint_P2, hitPoint));
						for (int num2 = 10; num2 >= 1; num2--)
						{
							if (num <= PointsDistance_P2[num2])
							{
								hit_Effect_P2.Play();
								PointUp(anim_Effect_P2, image_Num_P2, num2, 2);
								getInstance.eachScore_P2 += num2;
								getInstance.scoreBoard_Ctrl[1].SetScore((getInstance.shotCount_P2 - 1) / 3 + 1, getInstance.eachScore_P2);
								switch (num2)
								{
								case 10:
									Invoke("DelayCheerSoundMax", 0.3f);
									break;
								case 9:
									Invoke("DelayCheerSound", 0.3f);
									break;
								default:
									Invoke("DelayOhhSound", 0.3f);
									break;
								}
								return;
							}
						}
					}
					PointUp(anim_Effect_P2, image_Num_P2, 0, 2);
					getInstance.eachScore_P2 = getInstance.eachScore_P2;
					getInstance.scoreBoard_Ctrl[1].SetScore((getInstance.shotCount_P2 - 1) / 3 + 1, getInstance.eachScore_P2);
					break;
				}
				return;
			}
			switch (playerNum)
			{
			case 1:
				if (!isMiss)
				{
					float num7 = Vector3.Distance(trans_Target_P1.position, hitPoint);
					StartCoroutine(DelayArrowPoint_C(arrowPoint_P1, hitPoint));
					for (int num8 = 10; num8 >= 1; num8--)
					{
						if (num7 <= PointsDistance_P1[num8])
						{
							hit_Effect_P1.Play();
							PointUp(anim_Effect_P1, image_Num_P1, num8 - 1, 1);
							getInstance.shootOffScore_P1 = (float)(num8 - 1) + Mathf.Abs(PointsDistance_P1[num8] - num7) / Mathf.Abs(PointsDistance_P1[num8] - PointsDistance_P1[num8 - 1]);
							return;
						}
					}
				}
				getInstance.shootOffScore_P1 = 0f;
				break;
			case 2:
				if (!isMiss)
				{
					float num5 = Vector3.Distance(trans_Target_P2.position, hitPoint);
					StartCoroutine(DelayArrowPoint_C(arrowPoint_P2, hitPoint));
					for (int num6 = 10; num6 >= 1; num6--)
					{
						if (num5 <= PointsDistance_P2[num6])
						{
							hit_Effect_P2.Play();
							PointUp(anim_Effect_P2, image_Num_P2, num6 - 1, 2);
							getInstance.shootOffScore_P2 = (float)(num6 - 1) + Mathf.Abs(PointsDistance_P2[num6] - num5) / Mathf.Abs(PointsDistance_P2[num6] - PointsDistance_P2[num6 - 1]);
							return;
						}
					}
				}
				getInstance.shootOffScore_P2 = 0f;
				break;
			}
		}

		public void PointUp(Animator anim, Image[] image, int point, int num)
		{
			for (int i = 0; i < image.Length; i++)
			{
				image[i].gameObject.SetActive(value: false);
			}
			switch (point)
			{
			case 10:
				image[1].sprite = sprite_Nums[1];
				image[1].gameObject.SetActive(value: true);
				image[2].sprite = sprite_Nums[0];
				image[2].gameObject.SetActive(value: true);
				break;
			case 0:
				image[0].gameObject.SetActive(value: true);
				image[0].sprite = sprite_Nums[0];
				break;
			default:
				image[0].gameObject.SetActive(value: true);
				image[0].sprite = sprite_Nums[point];
				break;
			}
			anim.SetTrigger("Play");
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySoundNum(num, SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Count_Cn[point]);
			}
			else
			{
				SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySoundNum(num, SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Count[point]);
			}
		}

		public void SetTurnEffect(int playerNum, bool isOn)
		{
			switch (playerNum)
			{
			case 1:
				if (isOn)
				{
					anim_Turn_P1.SetTrigger("Play");
				}
				else
				{
					anim_Turn_P1.SetTrigger("Stop");
				}
				break;
			case 2:
				if (isOn)
				{
					anim_Turn_P2.SetTrigger("Play");
				}
				else
				{
					anim_Turn_P2.SetTrigger("Stop");
				}
				break;
			}
		}

		private IEnumerator DelayArrowPoint_C(GameObject go, Vector3 pos)
		{
			go.transform.position = pos + new Vector3(0f, 0f, -0.002f);
			go.SetActive(value: true);
			go.GetComponent<Animator>().SetTrigger("Play");
			yield return YieldInstructionCache.WaitForSeconds(3f);
			go.SetActive(value: false);
		}

		private void DelayCheerSound()
		{
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Cheer);
		}

		private void DelayOhhSound()
		{
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_Boos);
		}

		private void DelayCheerSoundMax()
		{
			SingletonPunBase.Singleton<Sound_SGT>.GetInstance.PlaySound(SingletonPunBase.Singleton<Sound_SGT>.GetInstance.clip_MaxCheer);
		}
	}
	public class UI_SGT : SingletonPunBase.Singleton<UI_SGT>
	{
		public enum UI_State
		{
			None,
			Start,
			EndS,
			EndM,
			Exit
		}

		private Canvas canvas;

		[Header("InfoS")]
		public Text text_InfoSTime;

		public Text text_InfoSScore;

		[Header("EndS")]
		public Text text_Player1;

		public Text text_Player2;

		public Text text_EndSResult;

		public Text text_EndSSetScore_P1;

		public Text text_EndSSetScore_P2;

		public Text text_EndSEachScore_P1;

		public Text text_EndSEachScore_P2;

		public GameObject[] Buttons;

		[Header("EndM")]
		public Text text_EndMName_P1;

		public Text text_EndMName_P2;

		public Text text_EndMScore_P1;

		public Text text_EndMScore_P2;

		public Text text_Result;

		[SerializeField]
		public TMP_FontAsset font_Us;

		public TMP_FontAsset font_Cn;

		public TextMeshPro timeOut;

		public TextMeshPro shootOff;

		public TextMesh howToPlay;

		public bool isPublicUI;

		private bool isReadyStart;

		private bool isReady;

		private bool isReady_Others;

		private int preTime;

		private int preScore;

		public UI_State ui_State { get; set; }

		public Animator anim { get; set; }

		protected override void Awake()
		{
			base.Awake();
			SingletonPunBase.Singleton<RPC_SGT>.GetInstance.PreRegisterTarget(ReadySerial_Multi);
		}

		private void Start()
		{
			ui_State = UI_State.None;
			canvas = GetComponent<Canvas>();
			anim = GetComponent<Animator>();
			StartGame();
			StartCoroutine(ConnectUICamera_C());
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				text_Player1.text = "Player1";
				text_Player2.text = "Player2";
			}
			PublicGameUIManager.GetInstance.AddMenuEvent(CheckPublicUI);
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0154", timeOut);
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0157", shootOff);
			SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.AddData("0040", howToPlay);
			Custom(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Custom);
		}

		private void FixedUpdate()
		{
			if (!isReadyStart && isReady && isReady_Others)
			{
				isReadyStart = true;
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.ResetGame();
			}
		}

		private void CheckPublicUI(bool obj)
		{
			StartCoroutine(DelayCheckPublicUI_C(obj));
		}

		private IEnumerator DelayCheckPublicUI_C(bool obj)
		{
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			isPublicUI = obj;
		}

		public void AnimationPlay(string str)
		{
			switch (str)
			{
			case "StartOpen":
				ui_State = UI_State.Start;
				break;
			case "EndSOpen":
				ui_State = UI_State.EndS;
				break;
			case "EndMOpen":
				ui_State = UI_State.EndM;
				break;
			case "ExitOpen":
				ui_State = UI_State.Exit;
				break;
			default:
				ui_State = UI_State.None;
				break;
			}
			anim.SetTrigger(str);
		}

		public void ClickButton(string str)
		{
			switch (str)
			{
			case "Start":
				AnimationPlay("StartClose");
				break;
			case "RePlay":
				SingletonPunBase.Singleton<Game_SGT>.GetInstance.player.SetRay(isOn: false);
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					isReady = true;
					if (!isReady_Others)
					{
						AnimationPlay("WaitOpen");
					}
					LumpsData<bool> data = new LumpsData<bool>
					{
						lumps = true
					};
					SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
				}
				else
				{
					SingletonPunBase.Singleton<Game_SGT>.GetInstance.ResetGame();
				}
				break;
			case "Play":
				AnimationPlay("ExitClose");
				break;
			case "Exit":
				SceneManager.LoadScene(0);
				break;
			}
		}

		public void DelaySerialAnimation(string animFirst, string animSecond, float time)
		{
			StartCoroutine(DelaySerialAnimation_C(animFirst, animSecond, time));
		}

		private IEnumerator DelaySerialAnimation_C(string animFirst, string animSecond, float time)
		{
			AnimationPlay(animFirst);
			yield return YieldInstructionCache.WaitForSeconds(time);
			AnimationPlay(animSecond);
		}

		private IEnumerator DelayStart_C()
		{
			AnimationPlay("StartOpen");
			yield return YieldInstructionCache.WaitForSeconds(10f);
			if (anim.GetCurrentAnimatorStateInfo(0).IsName("StartOpen"))
			{
				AnimationPlay("StartClose");
			}
		}

		private IEnumerator ConnectUICamera_C()
		{
			while (canvas.worldCamera == null)
			{
				yield return YieldInstructionCache.WaitForSeconds(Time.deltaTime);
				canvas.worldCamera = Camera.main;
			}
		}

		private void CheckTime()
		{
			if (SingletonPunBase.Singleton<Game_SGT>.GetInstance.isSetStart)
			{
				int num = (int)Mathf.Floor(SingletonPunBase.Singleton<Game_SGT>.GetInstance.time);
				if (preTime != num)
				{
					preTime = num;
					text_InfoSTime.text = num.ToString();
				}
			}
		}

		private void CheckScore()
		{
			_ = SingletonPunBase.Singleton<Game_SGT>.GetInstance.isSetStart;
		}

		private void StartGame()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				isReady = true;
				LumpsData<bool> data = new LumpsData<bool>
				{
					lumps = true
				};
				SingletonPunBase.Singleton<RPC_SGT>.GetInstance.TrySend(ReadySerial_Multi, data, RpcTarget.OthersBuffered);
			}
			AnimationPlay("StartOpen");
		}

		public void EndSResult()
		{
		}

		public void EndMResult()
		{
			isReadyStart = false;
			isReady = false;
			isReady_Others = false;
		}

		public void SetButtons(bool isOn)
		{
			GameObject[] buttons = Buttons;
			for (int i = 0; i < buttons.Length; i++)
			{
				buttons[i].SetActive(isOn);
			}
		}

		public void ReadySerial_Multi(SerializableClass packet)
		{
			if (packet is LumpsData<bool>)
			{
				isReady_Others = (packet as LumpsData<bool>).lumps;
				UnityEngine.Debug.Log("준비됨");
			}
		}

		public void Custom(LanguageState language)
		{
			if (language == LanguageState.schinese)
			{
				timeOut.font = font_Cn;
				shootOff.font = font_Cn;
			}
			else
			{
				timeOut.font = font_Us;
				shootOff.font = font_Us;
			}
		}
	}
	public class Wind_SGT : SingletonPunBase.Singleton<Wind_SGT>, IPunObservable
	{
		private PhotonView pv;

		private float recieve_WindDir;

		private float recieve_WindForce;

		public WindTime_CTRL[] windTime_Ctrl;

		private int count;

		private float changeForce;

		private float changeDirection;

		private int lightState = -1;

		public float windDir { get; set; }

		public float windForce { get; set; }

		public float windCos { get; set; }

		public float windSin { get; set; }

		public Animator anim_Wind { get; set; }

		protected override void Awake()
		{
			base.Awake();
			pv = GetComponent<PhotonView>();
			pv.Synchronization = ViewSynchronization.UnreliableOnChange;
			pv.ObservedComponents[0] = this;
		}

		void IPunObservable.OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (PhotonNetwork.IsConnected)
			{
				if (stream.IsWriting)
				{
					stream.SendNext(windDir);
					stream.SendNext(windForce);
				}
				else
				{
					recieve_WindDir = (float)stream.ReceiveNext();
					recieve_WindForce = (float)stream.ReceiveNext();
				}
			}
		}

		public void WindChange()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					count++;
					if (count % 75 == 1)
					{
						changeForce = windForce + UnityEngine.Random.Range(-1.2f, 1.2f);
						changeDirection = windDir + UnityEngine.Random.Range(-30f, 30f);
						count = 1;
					}
					windForce = Mathf.MoveTowards(windForce, changeForce, 0.003f);
					windDir = Mathf.MoveTowards(windDir, changeDirection, 0.3f);
					if (windForce <= 0f)
					{
						windForce = 0f;
					}
					else if (windForce >= 5.5f)
					{
						windForce = 5.5f;
					}
				}
				else
				{
					windForce = recieve_WindForce;
					windDir = recieve_WindDir;
				}
			}
			else
			{
				count++;
				if (count % (120 - SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 15) == 1)
				{
					changeForce = windForce + UnityEngine.Random.Range((float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * -0.4f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.4f);
					changeDirection = windDir + UnityEngine.Random.Range((float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * -10f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 10f);
					count = 1;
				}
				windForce = Mathf.MoveTowards(windForce, changeForce, 0.001f * (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level);
				windDir = Mathf.MoveTowards(windDir, changeDirection, 0.1f * (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level);
				if (windForce <= 0f)
				{
					windForce = 0f;
				}
				else if (windForce >= 5.5f)
				{
					windForce = 5.5f;
				}
			}
			windCos = Mathf.Cos((float)Math.PI / 180f * windDir);
			windSin = Mathf.Sin((float)Math.PI / 180f * (0f - windDir));
			Quaternion windRots = Quaternion.Euler(0f, 0f, windDir);
			SingletonBase.Singleton<Flag_SGT>.GetInstance.SetWindRots(windRots);
			windRots = Quaternion.Euler(0f, 0f, 0f - windDir);
			WindTime_CTRL[] array = windTime_Ctrl;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetWindState(windRots, windForce);
			}
			anim_Wind.SetFloat("windStateB", (windForce < 6f) ? windForce : 6f);
		}

		public void Reset()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					windForce = UnityEngine.Random.Range(0f, 5f);
					windDir = UnityEngine.Random.Range(0f, 360f);
				}
				else
				{
					windForce = recieve_WindForce;
					windDir = recieve_WindDir;
				}
			}
			else
			{
				windForce = UnityEngine.Random.Range((float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level / 2f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level + 1f);
				windDir = UnityEngine.Random.Range(0f, 360f);
			}
			lightState = -1;
		}

		public void SetTime(float time)
		{
			WindTime_CTRL[] array = windTime_Ctrl;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetText(time);
			}
		}

		public void SetLight(int state)
		{
			if (lightState != state)
			{
				WindTime_CTRL[] array = windTime_Ctrl;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].SetlightState(state);
				}
				lightState = state;
			}
		}
	}
}
namespace KTSuperVRGame
{
	public enum SystemMessageBoxState
	{
		Custom,
		Authenticate,
		Disconnect,
		Error,
		Exit,
		Update,
		UpdateForce,
		SuperVRServiceNotFound,
		SuperVRServiceInvalidSubScription,
		Reconnect,
		LeaveRoom
	}
	public enum MessageBoxIcon
	{
		Null,
		Disconnect,
		Warning,
		Exit,
		Update,
		SuperVRService
	}
	public class VRMessageBox : MonoBehaviour
	{
		public delegate void CollBack();

		private Image image_fade;

		private readonly Color in_color = new Color(0f, 0f, 0f, 0f);

		private readonly Color out_color = new Color(0f, 0f, 0f, 1f);

		private Animation anim;

		private CanvasGroup canvasGroup;

		private float fadeSpeed = 2f;

		private Transform camTr;

		public Button yesButton;

		public Button noButton;

		public Button cancelButton;

		public string title;

		public string info;

		public MessageBoxIcon icon;

		public SystemMessageBoxState state;

		private Coroutine animCoroutine;

		private event Action yesListener;

		private event Action noListener;

		private event Action cancelListener;

		public static VRMessageBox Create(SystemMessageBoxState state = SystemMessageBoxState.Custom)
		{
			VRMessageBox component = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/MessageBoxCtrl")).GetComponent<VRMessageBox>();
			component.state = state;
			component.InitializedMessageBox();
			return component;
		}

		private void Awake()
		{
			image_fade = base.transform.Find("Image_Fade").GetComponent<Image>();
			image_fade.color = in_color;
			UnityEngine.Debug.Log("MesseageBoxAwake");
			canvasGroup = base.transform.GetComponent<CanvasGroup>();
			canvasGroup.blocksRaycasts = false;
			Canvas component = base.transform.GetComponent<Canvas>();
			Camera component2 = camTr.GetComponent<Camera>();
			component.worldCamera = component2;
			anim = GetComponent<Animation>();
		}

		private void InitializedMessageBox()
		{
			switch (state)
			{
			case SystemMessageBoxState.Authenticate:
				title = "인증 오류";
				info = "Super VR 메인화면에서 로그인 정보를\n확인 후 재 실행해 주시기 바랍니다.";
				icon = MessageBoxIcon.Null;
				yesButton.gameObject.SetActive(value: false);
				yesButton.GetComponentInChildren<Text>().text = "";
				noButton.GetComponentInChildren<Text>().text = "종료";
				break;
			case SystemMessageBoxState.Disconnect:
				title = "접속 끊김";
				info = "네트워크 접속이 끊겼습니다.\n네트워크 확인 후 다시시도 해주세요.";
				icon = MessageBoxIcon.Disconnect;
				yesButton.GetComponentInChildren<Text>().text = "WIFI 설정";
				noButton.GetComponentInChildren<Text>().text = "종료";
				break;
			case SystemMessageBoxState.Error:
				title = "알수 없는 오류";
				info = "예상하지 못한 오류가 발생했습니다.";
				icon = MessageBoxIcon.Warning;
				yesButton.gameObject.SetActive(value: false);
				yesButton.GetComponentInChildren<Text>().text = "";
				noButton.GetComponentInChildren<Text>().text = "확인";
				break;
			case SystemMessageBoxState.Exit:
				title = "종료하기";
				info = "Super VR Game으로 돌아갑니다.";
				icon = MessageBoxIcon.Exit;
				yesButton.GetComponentInChildren<Text>().text = "처음으로";
				noButton.GetComponentInChildren<Text>().text = "종료";
				break;
			case SystemMessageBoxState.Update:
				title = "업데이트";
				info = "앱 업데이트 진행을 위해 마켓으로 이동하시겠습니까?";
				icon = MessageBoxIcon.Update;
				yesButton.GetComponentInChildren<Text>().text = "이동하기";
				noButton.GetComponentInChildren<Text>().text = "계속하기";
				break;
			case SystemMessageBoxState.UpdateForce:
				title = "업데이트";
				info = "앱 실행을 위해서 앱을 업데이트 해야합니다.\n마켓으로 이동하시겠습니까?";
				icon = MessageBoxIcon.Update;
				yesButton.GetComponentInChildren<Text>().text = "이동하기";
				noButton.GetComponentInChildren<Text>().text = "종료";
				break;
			case SystemMessageBoxState.SuperVRServiceNotFound:
				title = "오류";
				info = "Super VR Game를 먼저 설치하여 주시기 바랍니다.\n마켓으로 이동하시겠습니까?";
				icon = MessageBoxIcon.SuperVRService;
				yesButton.GetComponentInChildren<Text>().text = "이동하기";
				noButton.GetComponentInChildren<Text>().text = "종료";
				break;
			case SystemMessageBoxState.SuperVRServiceInvalidSubScription:
				title = "서비스 오류";
				info = "가입된 서비스를 확인해주세요.";
				icon = MessageBoxIcon.SuperVRService;
				yesButton.gameObject.SetActive(value: false);
				yesButton.GetComponentInChildren<Text>().text = "";
				noButton.GetComponentInChildren<Text>().text = "종료";
				break;
			case SystemMessageBoxState.Reconnect:
				title = "서버 재접속중";
				info = "서버에 연결중입니다. \n잠시만 기다려주세요.";
				icon = MessageBoxIcon.SuperVRService;
				yesButton.gameObject.SetActive(value: false);
				noButton.gameObject.SetActive(value: false);
				break;
			case SystemMessageBoxState.LeaveRoom:
				title = "연결 끊김";
				info = "상대방이 방에서 나갔습니다. \n로비로 돌아갑니다.";
				icon = MessageBoxIcon.Null;
				UnityEngine.Debug.Log("????");
				yesButton.gameObject.SetActive(value: false);
				noButton.gameObject.SetActive(value: false);
				cancelButton.gameObject.SetActive(value: false);
				break;
			}
		}

		private void LateUpdate()
		{
			image_fade.transform.SetPositionAndRotation(camTr.position + camTr.forward * 0.1f, camTr.rotation);
		}

		private void SetLayout(float iconY, float titleY, float infoY)
		{
			base.transform.Find("Image_Window/Image_Icon").GetComponent<RectTransform>().anchoredPosition = new Vector2(0f, iconY);
			base.transform.Find("Image_Window/Text_Title").GetComponent<RectTransform>().anchoredPosition = new Vector2(0f, titleY);
			base.transform.Find("Image_Window/Text_Info").GetComponent<RectTransform>().anchoredPosition = new Vector2(0f, infoY);
		}

		private void SetText()
		{
			base.transform.Find("Image_Window/Text_Title").GetComponent<Text>().text = title;
			base.transform.Find("Image_Window/Text_Info").GetComponent<Text>().text = info;
		}

		private void SetIconImage()
		{
			Image component = base.transform.Find("Image_Window/Image_Icon").GetComponent<Image>();
			switch (icon)
			{
			case MessageBoxIcon.Disconnect:
				component.sprite = Resources.Load<Sprite>("Images/icon-wifi");
				break;
			case MessageBoxIcon.Warning:
				component.sprite = Resources.Load<Sprite>("Images/icon-error");
				break;
			case MessageBoxIcon.Exit:
				component.sprite = Resources.Load<Sprite>("Images/icon-lou-out-2");
				break;
			case MessageBoxIcon.Null:
				component.sprite = null;
				break;
			case MessageBoxIcon.Update:
				component.sprite = Resources.Load<Sprite>("Images/icon-update");
				break;
			case MessageBoxIcon.SuperVRService:
				component.sprite = Resources.Load<Sprite>("Images/icon-error");
				break;
			}
		}

		private void SetButton()
		{
			bool activeSelf = yesButton.gameObject.activeSelf;
			bool activeSelf2 = noButton.gameObject.activeSelf;
			if (activeSelf && activeSelf2)
			{
				yesButton.transform.localPosition = new Vector3(-210f, -320f, 0f);
				noButton.transform.localPosition = new Vector3(210f, -320f, 0f);
			}
			else
			{
				yesButton.transform.localPosition = new Vector3(0f, -320f, 0f);
				noButton.transform.localPosition = new Vector3(0f, -320f, 0f);
			}
		}

		public void StartAnim(bool isFadeOut)
		{
			if (animCoroutine != null)
			{
				StopCoroutine(animCoroutine);
			}
			canvasGroup.blocksRaycasts = false;
			animCoroutine = StartCoroutine(AnimCoroutine(isFadeOut));
		}

		private IEnumerator AnimCoroutine(bool isFadeOut)
		{
			float weight = 0f;
			if (isFadeOut)
			{
				anim.clip = anim.GetClip("MessageBox_Start");
				anim.Play();
				while (true)
				{
					weight = Mathf.Clamp01(weight + Time.unscaledDeltaTime * fadeSpeed);
					anim["MessageBox_Start"].normalizedTime = weight;
					if (weight >= 1f)
					{
						break;
					}
					yield return null;
				}
				anim.Play();
				anim["MessageBox_Start"].normalizedTime = 1f;
				canvasGroup.blocksRaycasts = true;
				yield break;
			}
			anim.clip = anim.GetClip("MessageBox_End");
			anim.Play();
			while (true)
			{
				weight = Mathf.Clamp01(weight + Time.unscaledDeltaTime * fadeSpeed);
				anim["MessageBox_End"].normalizedTime = weight;
				if (weight >= 1f)
				{
					break;
				}
				yield return null;
			}
			anim.Play();
			anim["MessageBox_End"].normalizedTime = 1f;
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public VRMessageBox AddYesListener(Action yesListener)
		{
			this.yesListener += yesListener;
			return this;
		}

		public VRMessageBox AddNoListener(Action noListener)
		{
			this.noListener += noListener;
			return this;
		}

		public VRMessageBox AddCancelListener(Action cancelListener)
		{
			this.cancelListener += cancelListener;
			return this;
		}

		public VRMessageBox HideYesButton()
		{
			if (state == SystemMessageBoxState.Custom || state == SystemMessageBoxState.Exit)
			{
				yesButton.gameObject.SetActive(value: false);
			}
			return this;
		}

		public VRMessageBox HideNoButton()
		{
			if (state == SystemMessageBoxState.Custom)
			{
				noButton.gameObject.SetActive(value: false);
			}
			return this;
		}

		public VRMessageBox HideCancelButton()
		{
			if (state != SystemMessageBoxState.Exit)
			{
				cancelButton.gameObject.SetActive(value: false);
			}
			return this;
		}

		public VRMessageBox ShowYesButton()
		{
			if (state == SystemMessageBoxState.Custom)
			{
				yesButton.gameObject.SetActive(value: true);
			}
			return this;
		}

		public VRMessageBox ShowNoButton()
		{
			if (state == SystemMessageBoxState.Custom)
			{
				noButton.gameObject.SetActive(value: true);
			}
			return this;
		}

		public VRMessageBox ShowCancelButton()
		{
			if (state == SystemMessageBoxState.Custom)
			{
				cancelButton.gameObject.SetActive(value: true);
			}
			return this;
		}

		public VRMessageBox SetTitle(string title)
		{
			if (state == SystemMessageBoxState.Custom)
			{
				this.title = title;
			}
			return this;
		}

		public VRMessageBox SetInfo(string info)
		{
			if (state == SystemMessageBoxState.Custom)
			{
				this.info = info;
			}
			return this;
		}

		public VRMessageBox SetYesButtonText(string text)
		{
			if (state == SystemMessageBoxState.Custom)
			{
				yesButton.GetComponentInChildren<Text>().text = text;
			}
			return this;
		}

		public VRMessageBox SetNoButtonText(string text)
		{
			if (state == SystemMessageBoxState.Custom)
			{
				noButton.GetComponentInChildren<Text>().text = text;
			}
			return this;
		}

		public VRMessageBox SetIcon(MessageBoxIcon icon)
		{
			if (state == SystemMessageBoxState.Custom)
			{
				this.icon = icon;
			}
			return this;
		}

		public void Show()
		{
			UnityEngine.Debug.Log("3334455");
			if (icon != 0)
			{
				if (title != "" && info == "")
				{
					SetLayout(190f, -30f, 0f);
				}
				else if (title == "" && info != "")
				{
					SetLayout(190f, 0f, -30f);
				}
				else
				{
					SetLayout(230f, 37f, -167f);
				}
			}
			else if (title != "" && info == "")
			{
				SetLayout(0f, 37f, 0f);
			}
			else if (title == "" && info != "")
			{
				SetLayout(0f, 0f, 37f);
			}
			else
			{
				SetLayout(0f, 190f, -30f);
			}
			SetText();
			SetIconImage();
			SetButton();
			StartAnim(isFadeOut: true);
		}

		public static bool IsAppInstalled(string bundleID)
		{
			AndroidJavaObject androidJavaObject = new AndroidJavaClass("com.unity3d.player.UnityPlayer").GetStatic<AndroidJavaObject>("currentActivity").Call<AndroidJavaObject>("getPackageManager", Array.Empty<object>());
			AndroidJavaObject androidJavaObject2 = null;
			try
			{
				androidJavaObject2 = androidJavaObject.Call<AndroidJavaObject>("getLaunchIntentForPackage", new object[1] { bundleID });
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("exception" + ex.Message);
			}
			if (androidJavaObject2 != null)
			{
				return true;
			}
			return false;
		}

		public void ClickButton(int stateNum)
		{
			switch (stateNum)
			{
			case 0:
				if (this.yesListener != null)
				{
					this.yesListener();
				}
				switch (state)
				{
				}
				break;
			case 1:
				if (this.noListener != null)
				{
					this.noListener();
				}
				switch (state)
				{
				case SystemMessageBoxState.SuperVRServiceNotFound:
					UnityEngine.Application.Quit();
					break;
				}
				break;
			case 2:
				if (this.cancelListener != null)
				{
					this.cancelListener();
				}
				switch (state)
				{
				case SystemMessageBoxState.SuperVRServiceNotFound:
					UnityEngine.Application.Quit();
					break;
				}
				break;
			}
			StartAnim(isFadeOut: false);
		}

		public void FollowTarget(Transform TargetTrs)
		{
			StartCoroutine(FollowTargetCorou(TargetTrs));
		}

		private IEnumerator FollowTargetCorou(Transform TargetTrs)
		{
			yield return null;
			while (true)
			{
				yield return null;
				if (TargetTrs.position != base.transform.position)
				{
					base.transform.position = TargetTrs.position;
					base.transform.eulerAngles = TargetTrs.eulerAngles;
				}
			}
		}
	}
	public enum SystemToastState
	{
		Apply,
		Save,
		Cancel,
		ControllerDisconnect,
		NetDisconnect
	}
	public class VRToast : MonoBehaviour
	{
		private static VRToast _instance;

		private Animation anim;

		public float viewTime = 5f;

		private Text text_info;

		public string text;

		private Coroutine showCoroutine;

		public static VRToast instance
		{
			get
			{
				if (_instance == null)
				{
					return UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Prefabs/ToastCtrl")).GetComponent<VRToast>();
				}
				return _instance;
			}
		}

		private void Awake()
		{
			if (_instance == null)
			{
				_instance = this;
			}
			if (_instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			anim = GetComponent<Animation>();
			text_info = base.transform.Find("Image_Window/Text_Info").GetComponent<Text>();
		}

		public void SystemShow(SystemToastState state)
		{
			if (showCoroutine != null)
			{
				StopCoroutine(showCoroutine);
			}
			switch (state)
			{
			case SystemToastState.Apply:
				text_info.text = "등록 되었습니다.";
				break;
			case SystemToastState.Save:
				text_info.text = "저장 되었습니다.";
				break;
			case SystemToastState.Cancel:
				text_info.text = "취소 되었습니다.";
				break;
			case SystemToastState.ControllerDisconnect:
				text_info.text = "컨트롤러 연결이 해제 되었습니다.";
				break;
			case SystemToastState.NetDisconnect:
				text_info.text = "네트워크 연결이 해제 되었습니다.";
				break;
			}
			viewTime = 3.5f;
			showCoroutine = StartCoroutine(ShowCoroutine());
		}

		public void Show()
		{
			if (showCoroutine != null)
			{
				StopCoroutine(showCoroutine);
			}
			text_info.text = text;
			showCoroutine = StartCoroutine(ShowCoroutine());
		}

		private IEnumerator ShowCoroutine()
		{
			anim.clip = anim.GetClip("Toast_Start");
			anim.Play();
			float weight2 = 0f;
			while (true)
			{
				weight2 = Mathf.Clamp01(weight2 + Time.unscaledDeltaTime * 3f);
				anim["Toast_Start"].normalizedTime = weight2;
				if (weight2 >= 1f)
				{
					break;
				}
				yield return null;
			}
			anim.Play();
			anim["Toast_Start"].normalizedTime = 1f;
			yield return new WaitForSecondsRealtime(Mathf.Clamp(viewTime - 1f, 0f, 9f));
			anim.clip = anim.GetClip("Toast_End");
			anim.Play();
			weight2 = 0f;
			while (true)
			{
				weight2 = Mathf.Clamp01(weight2 + Time.unscaledDeltaTime * 1f);
				anim["Toast_End"].normalizedTime = weight2;
				if (weight2 >= 1f)
				{
					break;
				}
				yield return null;
			}
			anim.Play();
			anim["Toast_End"].normalizedTime = 1f;
		}
	}
}
namespace Dart
{
	public class MultiDemoManager : MonoBehaviourPunCallbacks, ILobbyCallbacks, IInRoomCallbacks
	{
		public UIMainMenu MainUI;

		public GameObject lobbyPanel;

		public GameObject roomPanel;

		public GameObject roomPanelPrefab;

		public GameObject roomContent;

		public GameObject FriendObj;

		public GameObject friendContent;

		public GameObject friendPanel;

		public GameObject userlistContent;

		public GameObject userlistPanel;

		public GameObject onlineFriendsContent;

		public GameObject onlineFriendsPrefab;

		public GameObject connectButton;

		public GameObject disconnectButton;

		public GameObject createRoomInputPanel;

		public InputField createRoomInputfield;

		public GameObject createRoomButton;

		public GameObject updateVersion;

		public Text versionText;

		public GameObject inviteRoomPanel;

		public Text inviteRoomLabel;

		public bool exit;

		private bool acceptInvite;

		private string _invitationRoom = "";

		public CanvasGroup[] UICanvasBlock;

		private static MultiDemoManager instance;

		public RawImage[] Me_Image;

		public RawImage[] Other_Image;

		public Texture PlayerOne_Tex;

		public Texture PlayerTwo_Tex;

		public GameObject MenuUI;

		private Vector3 SetAngle = Vector3.zero;

		private Vector3 SetPos = Vector3.zero;

		public Transform ToastTrs;

		public Transform MessageBoxTrs;

		private VRMessageBox VRBoxTemp;

		private bool connect;

		public static MultiDemoManager GetInstance()
		{
			return instance;
		}

		private void Start()
		{
			instance = this;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single)
			{
				_ = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType;
				_ = 2;
			}
		}

		public void ConnectPhoton()
		{
			StartCoroutine(Corou_ConnectPhoton());
		}

		private IEnumerator Corou_ConnectPhoton()
		{
			UnityEngine.Debug.Log("wait");
			PhotonNetwork.ConnectUsingSettings();
			while (!PhotonNetwork.IsConnected)
			{
				yield return null;
			}
			UnityEngine.Debug.Log("ConnectNetwork " + PhotonNetwork.IsConnected);
			float dt = 0f;
			while (dt < 1.5f)
			{
				dt += Time.deltaTime;
				yield return null;
			}
			PhotonNetwork.JoinRandomRoom();
		}

		public void PrintToastMsg(string message)
		{
			VRToast.instance.viewTime = 3f;
			VRToast.instance.text = message;
			VRToast.instance.Show();
			VRToast.instance.transform.position = ToastTrs.position;
			VRToast.instance.transform.eulerAngles = ToastTrs.eulerAngles;
		}

		public void DisconnectPhoton()
		{
			PrintToastMsg("DisconnectPhotonServer.");
		}

		public override void OnJoinedRoom()
		{
			UnityEngine.Debug.Log("PlayerCount : " + PhotonNetwork.CurrentRoom.PlayerCount);
			CsMain.GetInstance().Call_MultiGame(PhotonNetwork.CurrentRoom.PlayerCount);
			for (int i = 0; i < Me_Image.Length; i++)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					Me_Image[i].texture = PlayerOne_Tex;
				}
				else
				{
					Me_Image[i].texture = PlayerTwo_Tex;
				}
			}
			if (PhotonNetwork.IsMasterClient || PhotonNetwork.CurrentRoom == null)
			{
				return;
			}
			foreach (int key in PhotonNetwork.CurrentRoom.Players.Keys)
			{
				_ = PhotonNetwork.CurrentRoom.Players[key];
			}
			for (int j = 0; j < Other_Image.Length; j++)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					Other_Image[j].texture = PlayerTwo_Tex;
				}
				else
				{
					Other_Image[j].texture = PlayerOne_Tex;
				}
			}
		}

		public override void OnLeftRoom()
		{
			UnityEngine.Debug.Log("OnLeftRoom");
			CsMain.GetInstance().Call_LeftRoom();
		}

		public override void OnJoinRoomFailed(short returnCode, string message)
		{
			UnityEngine.Debug.Log("JoinFailed CreateRoom???");
		}

		public override void OnJoinRandomFailed(short _sho, string _str)
		{
			UnityEngine.Debug.Log("Join RandomRoom Failed CreateRoom???");
			Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions();
			roomOptions.MaxPlayers = 2;
			roomOptions.CustomRoomProperties = new ExitGames.Client.Photon.Hashtable();
			PhotonNetwork.CreateRoom("", roomOptions);
		}

		public override void OnPlayerEnteredRoom(Player newPlayer)
		{
			UnityEngine.Debug.Log("Enter Player");
			CsMain.GetInstance().GetView().RPC("RPC_MultiGameStart", RpcTarget.All);
			for (int i = 0; i < Other_Image.Length; i++)
			{
				Other_Image[i].texture = PlayerTwo_Tex;
			}
			FriendObj.SetActive(value: false);
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			if (CsMain.GetInstance().GetState() == CsMain.State.Main)
			{
				PhotonNetwork.LeaveRoom();
				if (MainUI.transform.GetChild(5).gameObject.activeSelf)
				{
					MainUI.GetComponent<UIMainMenu>().GoTarget(MainUI.transform.GetChild(2).GetComponent<UIBaseLobbyMenu>());
				}
				else
				{
					MainUI.GetComponent<UIMainMenu>().GoTarget(MainUI.transform.GetChild(2).GetComponent<UIBaseLobbyMenu>());
				}
				CsMain.GetInstance().StopAllCoroutines();
			}
			else
			{
				CsMain.GetInstance().Call_GameWinLose(win: true);
			}
		}

		public void Call_Button_MultiGame()
		{
			for (int i = 0; i < Me_Image.Length; i++)
			{
				Me_Image[i].texture = null;
				Other_Image[i].texture = null;
			}
			PhotonNetwork.JoinRandomRoom();
		}

		public void Call_Button_LeaveRoom()
		{
			PhotonNetwork.LeaveRoom();
		}

		public void SetBlockRaycast(bool _bool)
		{
			for (int i = 0; i < UICanvasBlock.Length; i++)
			{
				UICanvasBlock[i].blocksRaycasts = _bool;
			}
		}

		private IEnumerator DelayAcceptSet()
		{
			if (_invitationRoom != "")
			{
				yield return YieldInstructionCache.WaitForSeconds(12f);
			}
			else
			{
				yield return YieldInstructionCache.WaitForSeconds(5f);
			}
			acceptInvite = false;
		}

		private IEnumerator LeaveAndJoin(string roomName)
		{
			PhotonNetwork.LeaveRoom();
			while (PhotonNetwork.InRoom)
			{
				yield return null;
			}
			float _delay = 0f;
			while (_delay < 1.2f)
			{
				_delay += Time.deltaTime;
				yield return null;
			}
			PhotonNetwork.JoinRoom(roomName);
			inviteRoomPanel.SetActive(value: false);
			for (int i = 0; i < roomContent.transform.childCount; i++)
			{
				roomContent.transform.GetChild(i).GetChild(2).GetComponent<Button>()
					.enabled = true;
			}
			yield return null;
		}

		private void CreateVRBox(SystemMessageBoxState state)
		{
			VRBoxTemp = VRMessageBox.Create(state);
			VRBoxTemp.Show();
			Vector3 position = VRBoxTemp.transform.position;
			position.z = 2f;
			VRBoxTemp.transform.position = position;
		}

		public void SetPosRot(Vector3 Pos, Vector3 Angle)
		{
			SetPos = Pos;
			SetAngle = Angle;
			if (VRBoxTemp != null)
			{
				VRBoxTemp.transform.position = Pos;
				VRBoxTemp.transform.eulerAngles = Angle;
			}
		}

		public void ExitBox(int _type = 0)
		{
			if (!connect || VRBoxTemp != null || exit)
			{
				return;
			}
			exit = true;
			VRBoxTemp = VRMessageBox.Create(SystemMessageBoxState.Exit);
			VRBoxTemp.AddYesListener(delegate
			{
				if (PhotonNetwork.InRoom)
				{
					SceneManager.LoadScene("Lobby");
				}
				exit = false;
			});
			VRBoxTemp.AddCancelListener(delegate
			{
				exit = false;
			});
			if (_type == 1)
			{
				VRBoxTemp.HideYesButton();
			}
			VRBoxTemp.Show();
			VRBoxTemp.transform.position = ToastTrs.position;
			VRBoxTemp.GetComponent<BoxCollider>().size = new Vector3(2f, 2f, 0.1f);
			if (CsMain.GetInstance().GetState() == CsMain.State.Main)
			{
				Vector3 position = ToastTrs.position;
				position.y += 1f;
				position.z += 0.5f;
				VRBoxTemp.transform.position = position;
				VRBoxTemp.GetComponent<BoxCollider>().size = new Vector3(2f, 2f, 0.1f);
			}
			else
			{
				Vector3 position2 = ToastTrs.position;
				position2.y += 1f;
				position2.z -= 1.8f;
				VRBoxTemp.transform.position = position2;
				VRBoxTemp.transform.localScale = new Vector3(0.7f, 0.7f, 0.7f);
				VRBoxTemp.GetComponent<BoxCollider>().size = new Vector3(2f, 2f, 0.1f);
			}
		}

		public void OffExitBox()
		{
			if (connect && exit)
			{
				VRBoxTemp.StartAnim(isFadeOut: false);
				exit = false;
			}
		}

		public VRMessageBox GetMessageBox()
		{
			return VRBoxTemp;
		}

		public void OnServerConnected()
		{
			connect = true;
		}
	}
	public class AudioMixerCtrl : MonoBehaviour
	{
		public AudioMixer gMixer;

		public AudioMixerGroup[] MixerGroup;

		public AudioSource BGMSource;

		public AudioSource EffectSource;
	}
	public class CharIK : MonoBehaviour
	{
		private Animator anim;

		private GameObject obj;

		private GameObject HandObj;

		public int charIndex;

		public int awaiterIndex;

		private GameObject DefaultHead;

		private GameObject DefaultRight;

		private void Start()
		{
			anim = GetComponent<Animator>();
		}

		public void OnAnimatorIK()
		{
			if (obj != null)
			{
				anim.SetLookAtWeight(0.8f);
				anim.SetLookAtPosition(obj.transform.position);
				anim.SetIKPositionWeight(AvatarIKGoal.RightHand, 0.8f);
				anim.SetIKPosition(AvatarIKGoal.RightHand, HandObj.transform.position);
			}
		}

		public void CreateTarget()
		{
			obj = new GameObject();
			obj.transform.SetParent(base.transform);
			obj.transform.localPosition = new Vector3(0f, 1.4f, 0.7f);
			HandObj = new GameObject();
			HandObj.transform.SetParent(base.transform);
			HandObj.transform.localPosition = new Vector3(0f, 1.1f, 0.5f);
			DefaultHead = new GameObject();
			DefaultHead.transform.SetParent(base.transform);
			DefaultHead.transform.localPosition = new Vector3(0f, 1.5f, 0.35f);
			DefaultRight = new GameObject();
			DefaultRight.transform.SetParent(base.transform);
			DefaultRight.transform.localPosition = new Vector3(0f, 1.1f, 0.5f);
		}

		public void SetPos(Vector3 HeadPos, Vector3 HandPos)
		{
			obj.transform.position = Vector3.Lerp(HeadPos + DefaultHead.transform.position, obj.transform.position, 0.65f);
			HandObj.transform.position = Vector3.Lerp(HandPos + DefaultRight.transform.position, HandObj.transform.position, 0.65f);
		}
	}
	public class CsDart : MonoBehaviour
	{
		private Vector3 PreAng;

		private int turn;

		public void SetTurn(int _turn)
		{
			turn = _turn;
		}

		public int GetTurn()
		{
			return turn;
		}

		private void Start()
		{
			StartCoroutine(Rotation_Corou());
			StartCoroutine(Delay_Trail());
		}

		private IEnumerator Delay_Trail()
		{
			yield return null;
			yield return null;
			yield return null;
			base.transform.GetChild(1).gameObject.SetActive(value: true);
		}

		private IEnumerator Rotation_Corou()
		{
			float _limit_Dt = 0f;
			yield return null;
			Rigidbody Rigid = GetComponent<Rigidbody>();
			while (Rigid != null || 5f < _limit_Dt)
			{
				base.transform.LookAt(base.transform.position + Rigid.velocity);
				_limit_Dt += Time.deltaTime;
				PreAng = base.transform.eulerAngles;
				GetComponent<Rigidbody>().AddForce(0f, 2.5f / Time.fixedDeltaTime * Time.deltaTime, 0f, ForceMode.Force);
				yield return null;
			}
		}

		private void OnCollisionEnter(Collision coll)
		{
			if (coll.gameObject.tag == "DartColl")
			{
				base.transform.position = coll.contacts[0].point;
				base.transform.eulerAngles = PreAng;
				UnityEngine.Object.Destroy(GetComponent<Rigidbody>());
				UnityEngine.Object.Destroy(GetComponent<BoxCollider>());
				CsMain.GetInstance().Call_HitDartEffect(coll.contacts[0].point, turn);
			}
			else
			{
				UnityEngine.Object.Destroy(GetComponent<Rigidbody>());
				UnityEngine.Object.Destroy(GetComponent<BoxCollider>());
				CsMain.GetInstance().Call_OutDart(turn);
			}
		}
	}
	public class CsMain : MonoBehaviourPunCallbacks
	{
		public enum State
		{
			Main,
			StopUI,
			Zerowon,
			CountUp,
			None,
			GameEnd
		}

		public enum PlayerMode
		{
			Single,
			Multi
		}

		private enum Data
		{
			First,
			Zerowon,
			CountUp
		}

		private enum Cont
		{
			Head,
			HeadChild,
			Right,
			RightChild,
			Left,
			LeftChild
		}

		private int[] DartScoreNum;

		private float[] DistanceValue;

		private State curState;

		private State tempState = State.None;

		private PlayerMode curMode;

		public GameObject PlayerObj;

		public GameObject CameraObj;

		public GameObject RightObj;

		public GameObject LeftObj;

		public Transform[] PartsTrs;

		public Transform[] OtherPartsTrs;

		private Transform[] GetOtherPartsData = new Transform[6];

		public Text[] NameText;

		public Transform PlayerDefalutTrs;

		public Transform[] PlayerPosTrs;

		public Transform[] PlayerDartTrs;

		public GameObject MoveObj;

		public GameObject MoveObjLeft;

		public GameObject DartDataParent;

		public GameObject DartImage;

		public Transform DartImage_RightTrs;

		public Transform DartImage_LeftTrs;

		public GameObject DartPF;

		public GameObject DartImagePF;

		public GameObject ScorePF;

		public Animator ReadyAni;

		public TextMeshPro RoundText;

		public Animator[] BustAni;

		private List<GameObject> DartList;

		public Transform[] DartCenterTrs;

		public Transform AutoThrow_StartTrs;

		public Transform AutoThrow_EndTrs;

		public Transform AutoThrow_EndTrs__Dummy;

		public GameObject OtherDartImage;

		public GameObject OtherDart_Left;

		public GameObject OtherDart_Right;

		public GameObject OtherChar;

		public Animator HandCont_Right;

		public Animator HandCont_Left;

		private Animator HandCont_Main;

		private Vector3 GrapAngle_R = Vector3.zero;

		private Vector3 DefaultAngle_R = Vector3.zero;

		private Vector3 GrapAngle_L = Vector3.zero;

		private Vector3 DefaultAngle_L = Vector3.zero;

		public Animator OtherHandCont_R;

		public Animator OtherHandCont_L;

		public Animator OtherHandCont_Main;

		public GameObject GameHelpObj;

		public MeshRenderer[] DartScreens;

		public Material Mat_Countup;

		public Material Mat_Zerowon;

		private CsSound gSound;

		public AudioSource gEffectAudio;

		public AudioSource gClockAudio;

		private UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

		private UnityEngine.XR.Interaction.Toolkit.XRController RightController;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		private static CsMain _instance;

		private PhotonView pView;

		public Transform[] TestTrs;

		public Transform TestTarget;

		public Transform ClickRed;

		public Rigidbody CheckRigid;

		private bool _startDelay;

		private int[] ThreeDart = new int[3] { 0, 3, 3 };

		private int gameRound;

		private int playerUseTrun = 1;

		private bool throwCheck;

		public float addPower;

		public float sqrPower;

		private bool firstShot;

		private bool trigger;

		private bool outLine;

		private IEnumerator AI_Shot;

		public GameObject ParticlePF;

		public GameObject CharPF;

		public GameObject MultiCharPF;

		public RuntimeAnimatorController Char_Ani;

		public Text[] TimeTexts;

		private float _limitTime;

		private int _curLevel;

		private IEnumerator TimeCorou;

		private float HapTicValue = 0.5f;

		private float HapTicDuration = 0.1f;

		public static CsMain GetInstance()
		{
			return _instance;
		}

		public PhotonView GetView()
		{
			return pView;
		}

		public int GetPlayerUseTurn()
		{
			return playerUseTrun;
		}

		private void TestValue()
		{
			Vector3 zero = Vector3.zero;
			Vector3 normalized = (RightObj.transform.position - TestTarget.position).normalized;
			float num = RightObj.transform.position.z - -1.9f;
			zero = RightObj.transform.position + normalized * num;
			zero.z = -1.9f;
			ClickRed.transform.position = zero;
			for (int i = 0; i < TestTrs.Length; i++)
			{
				if (!((ClickRed.position - TestTrs[i].position).magnitude < 0.2f))
				{
					continue;
				}
				switch (i)
				{
				case 0:
					CsPower.GetInstance().maxdis -= 0.1f;
					break;
				case 1:
					CsPower.GetInstance().maxdis += 0.1f;
					break;
				case 2:
					CsPower.GetInstance().mindis -= 0.02f;
					break;
				case 3:
					CsPower.GetInstance().mindis += 0.02f;
					break;
				case 4:
					CsPower.GetInstance().totalValue -= 0.01f;
					break;
				case 5:
					CsPower.GetInstance().totalValue += 0.01f;
					break;
				case 6:
					CsPower.GetInstance().yvalue -= 0.01f;
					break;
				case 7:
					CsPower.GetInstance().yvalue += 0.01f;
					break;
				case 8:
					if (2 < CsPower.GetInstance().useIndex)
					{
						CsPower.GetInstance().useIndex--;
					}
					CsPower.GetInstance().curindexChe();
					break;
				case 9:
					if (CsPower.GetInstance().useIndex < 20)
					{
						CsPower.GetInstance().useIndex++;
					}
					CsPower.GetInstance().curindexChe();
					break;
				}
			}
		}

		private void Start()
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomHand();
			_instance = this;
			pView = GetComponent<PhotonView>();
			gSound = GetComponent<CsSound>();
			DartList = new List<GameObject>();
			if (PlayerPrefs.HasKey(Data.First.ToString()))
			{
				PlayerPrefs.SetString(Data.First.ToString(), "1");
				PlayerPrefs.SetInt(Data.Zerowon.ToString(), 0);
				PlayerPrefs.SetInt(Data.CountUp.ToString(), 0);
				PlayerPrefs.Save();
			}
			DartScoreNum = new int[21]
			{
				0, 5, 18, 16, 3, 7, 1, 14, 12, 9,
				20, 11, 8, 2, 10, 19, 13, 17, 4, 15,
				6
			};
			DistanceValue = new float[3] { 0.10505f, 0.144f, 0.1813f };
			StartCoroutine(DelayFrame());
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("FadeSphere"), CameraObj.transform);
			PublicGameUIManager.GetInstance.AddReplayEvent(delegate
			{
				Restart();
			});
			PublicGameUIManager.GetInstance.AddLoadLobbyEvent(delegate
			{
				Return();
			});
			PublicGameUIManager.GetInstance.SetGridSize(0.8f);
			PublicGameUIManager.gameSetting.AddHandChangedEvent(ChangeHand);
			SetPlayerHand(PublicGameUIManager.gameSetting.IsRightHanded());
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
			LeftController = LeftObj.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightObj.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			DefaultAngle_L = HandCont_Left.transform.localEulerAngles;
			GrapAngle_L = HandCont_Left.transform.localEulerAngles;
			GrapAngle_L.z = -70f;
			DefaultAngle_R = HandCont_Right.transform.localEulerAngles;
			GrapAngle_R = HandCont_Right.transform.localEulerAngles;
			GrapAngle_R.z = 70f;
			for (int i = 0; i < GetOtherPartsData.Length; i++)
			{
				GetOtherPartsData[i] = UnityEngine.Object.Instantiate(new GameObject()).transform;
			}
			StartCoroutine(StartDelay());
		}

		private IEnumerator StartDelay()
		{
			yield return YieldInstructionCache.WaitForSeconds(1f);
			_startDelay = true;
		}

		public void ChangeHand(bool isRight)
		{
			SetPlayerHand(isRight);
		}

		private void SetPlayerHand(bool isRight)
		{
			if (isRight)
			{
				DartDataParent.transform.SetParent(HandCont_Right.transform);
				DartDataParent.transform.localPosition = Vector3.zero;
				DartDataParent.transform.localEulerAngles = Vector3.zero;
				DartDataParent.transform.localScale = new Vector3(1f, 1f, 1f);
				HandCont_Main = HandCont_Right;
			}
			else
			{
				DartDataParent.transform.SetParent(HandCont_Left.transform);
				DartDataParent.transform.localPosition = Vector3.zero;
				DartDataParent.transform.localEulerAngles = Vector3.zero;
				DartDataParent.transform.localScale = new Vector3(1f, 1f, 1f);
				HandCont_Main = HandCont_Left;
			}
		}

		private void Restart()
		{
			SceneManager.LoadScene("Scene_Game_Darts");
		}

		private void Return()
		{
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (_startDelay && !outLine && ThreeDart[playerUseTrun] > 0 && !PublicGameUIManager.gameSetting.IsRightHanded())
			{
				if (obj)
				{
					InputTrigger();
				}
				else
				{
					OutputTrigger();
				}
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (_startDelay && !outLine && ThreeDart[playerUseTrun] > 0 && PublicGameUIManager.gameSetting.IsRightHanded())
			{
				if (obj)
				{
					InputTrigger();
				}
				else
				{
					OutputTrigger();
				}
			}
		}

		private void InputTrigger()
		{
			if (!throwCheck && PublicGameUIManager.GetInstance.GetCurrentState() == PublicGameUIManager.ViewState.None)
			{
				DartImage.SetActive(value: true);
				HandCont_Main.SetTrigger("Grap");
				if (PublicGameUIManager.gameSetting.IsRightHanded())
				{
					HapticPulse(RightController);
				}
				else
				{
					HapticPulse(LeftController);
				}
				if (curMode == PlayerMode.Multi)
				{
					pView.RPC("RPC_ReadyDart", RpcTarget.Others, PublicGameUIManager.gameSetting.IsRightHanded());
				}
			}
		}

		private void OutputTrigger()
		{
			if (!DartImage.activeSelf)
			{
				return;
			}
			throwCheck = false;
			DartImage.SetActive(value: false);
			HandCont_Main.SetTrigger("Throw");
			if (!(CsPower.GetInstance().GetVel().magnitude < 0.5f))
			{
				UnityEngine.Debug.Log("Vel : " + (CsPower.GetInstance().GetVel().normalized * (addPower + CsPower.GetInstance().GetVel().magnitude * sqrPower)).magnitude);
				UnityEngine.Debug.Log("CsPower.GetInstance().GetVel().magnitude : " + CsPower.GetInstance().GetVel().magnitude);
				if (curMode == PlayerMode.Single && !firstShot)
				{
					firstShot = true;
					StartShot();
				}
				GameHelpObj.SetActive(value: false);
				throwCheck = true;
				Quaternion rotation = DartImage.transform.rotation;
				GameObject gameObject = UnityEngine.Object.Instantiate(DartPF, DartImage.transform.position, rotation);
				gameObject.GetComponent<CsDart>().SetTurn(playerUseTrun);
				DartList.Add(gameObject);
				Vector3 zero = Vector3.zero;
				Vector3 vel = CsPower.GetInstance().GetVel();
				gameObject.GetComponent<Rigidbody>().velocity = vel;
				zero = vel;
				ThrowAfter();
				Call_PlaySound(CsSound.Sound.Throw_01);
				if (curMode == PlayerMode.Multi)
				{
					Vector3[] array = new Vector3[2]
					{
						gameObject.transform.position,
						zero
					};
					pView.RPC("RPC_Throw_Dart", RpcTarget.Others, array);
				}
			}
		}

		private IEnumerator DelayFrame()
		{
			yield return null;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				UnityEngine.Debug.Log("GameData_DDOL.GetInstance.Level : " + SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level);
				_curLevel = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
				Call_Button_SingleType("Zerowon");
				Call_Button_SingleLevel(_curLevel);
				curMode = PlayerMode.Single;
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				ThreeDart[1] = 0;
				ThreeDart[2] = 0;
				if (PhotonNetwork.IsMasterClient)
				{
					playerUseTrun = 1;
				}
				else
				{
					playerUseTrun = 2;
				}
				curMode = PlayerMode.Multi;
				RPC_MultiGameStart();
			}
			else
			{
				int level = 1;
				Call_Button_SingleType("Zerowon");
				Call_Button_SingleLevel(level);
			}
		}

		private void Update()
		{
			if (curMode == PlayerMode.Multi && OtherChar != null)
			{
				Vector3[] array = new Vector3[6]
				{
					PartsTrs[0].position,
					PartsTrs[0].eulerAngles,
					PartsTrs[2].position,
					PartsTrs[2].eulerAngles,
					PartsTrs[4].position,
					PartsTrs[4].eulerAngles
				};
				pView.RPC("RPC_StreamPos", RpcTarget.Others, array);
				OtherPartsTrs[0].position = Vector3.Lerp(OtherPartsTrs[0].position, GetOtherPartsData[0].position, 0.1f);
				OtherPartsTrs[0].rotation = Quaternion.Lerp(OtherPartsTrs[0].rotation, GetOtherPartsData[1].rotation, 0.1f);
				OtherPartsTrs[2].position = Vector3.Lerp(OtherPartsTrs[2].position, GetOtherPartsData[2].position, 0.1f);
				OtherPartsTrs[2].rotation = Quaternion.Lerp(OtherPartsTrs[2].rotation, GetOtherPartsData[3].rotation, 0.1f);
				OtherPartsTrs[4].position = Vector3.Lerp(OtherPartsTrs[4].position, GetOtherPartsData[4].position, 0.1f);
				OtherPartsTrs[4].rotation = Quaternion.Lerp(OtherPartsTrs[4].rotation, GetOtherPartsData[5].rotation, 0.1f);
			}
			Vector3 vector = PlayerObj.transform.position - CameraObj.transform.position;
			vector.y = 0f;
			if (0.4f < vector.magnitude)
			{
				outLine = true;
			}
			else
			{
				outLine = false;
			}
			if (LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
			{
				OnTriggerL.CurrentData = isPressed;
			}
			if (RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
			{
				OnTriggerR.CurrentData = isPressed2;
			}
		}

		private void FF()
		{
			string[] arr_subScore = new string[8] { "Level", "1", "미션", "1000m", null, null, null, null };
			PublicGameUIManager.GetInstance.OpenResultBoard("100", arr_subScore);
			arr_subScore = new string[2] { "1번 점수", "2번 점수" };
			PublicGameUIManager.GetInstance.OpenResultBoard(arr_subScore, 0);
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
		}

		private void ThrowAfter()
		{
			ThreeDart[playerUseTrun]--;
			if (curMode == PlayerMode.Single)
			{
				if (ThreeDart[playerUseTrun] == 0)
				{
					StartCoroutine(Corou_StartShot());
				}
			}
			else if (curMode == PlayerMode.Multi && ThreeDart[playerUseTrun] == 0 && PhotonNetwork.IsMasterClient)
			{
				pView.RPC("RPC_Corou_StartShot", RpcTarget.All);
			}
		}

		private IEnumerator Corou_StartShot()
		{
			gClockAudio.Stop();
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			if (ThreeDart[1] == 0 && ThreeDart[2] == 0)
			{
				yield return YieldInstructionCache.WaitForSeconds(1.5f);
				if ((curState == State.CountUp && gameRound < 3) || (curState == State.Zerowon && gameRound < 8))
				{
					ReadyAni.SetTrigger("Ready");
					RoundText.text = (gameRound + 1).ToString();
					Call_PlaySound(CsSound.Sound.CenterHit_05);
					CsScore.GetInstance().Call_ResetHitLight();
				}
				yield return YieldInstructionCache.WaitForSeconds(1.5f);
				StartShot();
			}
			else
			{
				StartCoroutine(Corou_StartShot());
			}
		}

		[PunRPC]
		private void RPC_Corou_StartShot()
		{
			StartCoroutine(Corou_StartShot());
		}

		private void StartShot()
		{
			for (int i = 0; i < DartList.Count; i++)
			{
				UnityEngine.Object.Destroy(DartList[i]);
			}
			DartList.Clear();
			ThreeDart[1] = 3;
			ThreeDart[2] = 3;
			CsScore.GetInstance().DeleteCurScore(1);
			CsScore.GetInstance().DeleteCurScore(2);
			gameRound++;
			if (curState == State.Zerowon)
			{
				if (gameRound == 9)
				{
					if (CsScore.GetInstance().GetWinZerowonPlayer() == playerUseTrun)
					{
						Call_GameWinLose(win: true);
					}
					else
					{
						Call_GameWinLose(win: false);
					}
					return;
				}
				CsScore.GetInstance().Set_CheckScore(1);
				CsScore.GetInstance().Set_CheckScore(2);
				CsScore.GetInstance().SetRound(gameRound);
				TimeFunc();
				if (curMode == PlayerMode.Single)
				{
					AI_Shot = Corou_AI_Shot();
					StartCoroutine(AI_Shot);
				}
			}
			else
			{
				if (curState != State.CountUp)
				{
					return;
				}
				if (gameRound == 4)
				{
					if (CsScore.GetInstance().GetWinPlayer() == playerUseTrun)
					{
						Call_GameWinLose(win: true);
					}
					else
					{
						Call_GameWinLose(win: false);
					}
					return;
				}
				CsScore.GetInstance().SetRound(gameRound);
				TimeFunc();
				if (curMode == PlayerMode.Single)
				{
					AI_Shot = Corou_AI_Shot();
					StartCoroutine(AI_Shot);
				}
			}
		}

		private IEnumerator Corou_AI_Shot()
		{
			if (ThreeDart[2] != 0)
			{
				yield return YieldInstructionCache.WaitForSeconds(1.5f);
				ThreeDart[2]--;
				OtherDartImage.SetActive(value: true);
				OtherChar.GetComponent<Animator>().SetTrigger("Ready");
				yield return YieldInstructionCache.WaitForSeconds(0.3f);
				OtherChar.GetComponent<Animator>().SetTrigger("Shot");
				yield return YieldInstructionCache.WaitForSeconds(0.4f);
				AutoThrow();
				if (0 < ThreeDart[2])
				{
					AI_Shot = Corou_AI_Shot();
					StartCoroutine(AI_Shot);
				}
			}
		}

		private void AutoThrow()
		{
			Vector2 zero = Vector2.zero;
			Vector3 b = Vector3.zero;
			int num = 0;
			float num2 = 0f;
			if (curState == State.Zerowon)
			{
				if (CsScore.GetInstance().GetScore(2) <= 20)
				{
					num = CsScore.GetInstance().GetScore(2);
					num2 = DistanceValue[1];
				}
				else if (CsScore.GetInstance().GetScore(2) <= 60)
				{
					if (CsScore.GetInstance().GetScore(2) <= 40)
					{
						if (CsScore.GetInstance().GetScore(2) % 2 == 0)
						{
							num = CsScore.GetInstance().GetScore(2) / 2;
							num2 = DistanceValue[0];
						}
						else if (CsScore.GetInstance().GetScore(2) % 3 == 0)
						{
							num = CsScore.GetInstance().GetScore(2) / 3;
							num2 = DistanceValue[2];
						}
						else
						{
							num = 20;
							num2 = DistanceValue[1];
						}
					}
					else if (CsScore.GetInstance().GetScore(2) <= 60)
					{
						if (CsScore.GetInstance().GetScore(2) == 50)
						{
							num2 = 0f;
						}
						else if (CsScore.GetInstance().GetScore(2) % 3 == 0)
						{
							num = CsScore.GetInstance().GetScore(2) / 3;
							num2 = DistanceValue[2];
						}
						else
						{
							num = 20;
							num2 = DistanceValue[1];
						}
					}
				}
				else
				{
					num = 20;
					num2 = DistanceValue[0];
				}
				Vector3 position = AutoThrow_EndTrs.position;
				if (num2 != 0f)
				{
					float num3 = (float)Math.PI / 180f;
					float num4 = DartScoreNum[num] * 18 - 18;
					float num5 = Mathf.Cos(num4 * num3) * num2;
					float num6 = Mathf.Sin(num4 * num3) * num2;
					position.x += num5;
					position.y += num6;
				}
				float num7 = 0f;
				if (_curLevel == 1)
				{
					num7 = 0.22f;
				}
				else if (_curLevel == 2)
				{
					num7 = 0.2f;
				}
				else if (_curLevel == 3)
				{
					num7 = 0.1f;
				}
				else if (_curLevel == 4)
				{
					num7 = 0.075f;
				}
				else if (_curLevel == 5)
				{
					num7 = 0.035f;
				}
				zero.x += UnityEngine.Random.Range(0f - num7, num7);
				zero.y += UnityEngine.Random.Range(0f - num7, num7);
				if (2 < _curLevel)
				{
					b = position;
				}
				else
				{
					UnityEngine.Debug.Log("이건데");
					b = AutoThrow_EndTrs.position;
				}
				b.x += zero.x;
				b.y += zero.y;
			}
			else if (curState == State.CountUp)
			{
				float num8 = 0f;
				if (_curLevel == 0)
				{
					num8 = 0.075f;
				}
				else if (_curLevel == 1)
				{
					num8 = 0.06f;
				}
				else if (_curLevel == 2)
				{
					num8 = 0.045f;
				}
				else if (_curLevel == 3)
				{
					num8 = 0.04f;
				}
				else if (_curLevel == 4)
				{
					num8 = 0.035f;
				}
				zero.x += UnityEngine.Random.Range(0f - num8, num8);
				zero.y += UnityEngine.Random.Range(0f - num8, num8);
				b = AutoThrow_EndTrs.position;
				b.x += zero.x;
				b.y += zero.y;
			}
			float t = UnityEngine.Random.Range(0.3f, 0.4f);
			Vector3 shotVelocityAtoB = getShotVelocityAtoB(OtherDartImage.transform.position, b, t);
			GameObject gameObject = UnityEngine.Object.Instantiate(DartPF, OtherDartImage.transform.position, Quaternion.identity);
			gameObject.GetComponent<Rigidbody>().velocity = shotVelocityAtoB;
			gameObject.GetComponent<CsDart>().SetTurn(2);
			OtherDartImage.SetActive(value: false);
			DartList.Add(gameObject);
			Call_PlaySound(CsSound.Sound.Throw_01);
		}

		public void Call_HitDartEffect(Vector3 Pos, int turn)
		{
			if (turn == playerUseTrun)
			{
				throwCheck = false;
			}
			Call_PlaySound(CsSound.Sound.Hit_01);
			Pos.z -= 0.1f;
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(ParticlePF, Pos, Quaternion.identity), 2f);
			if (curMode == PlayerMode.Single)
			{
				int score = CsScore.GetInstance().Call_HitDart(Pos, turn, (int)curState);
				Pos.y += 0.2f;
				GameObject obj = UnityEngine.Object.Instantiate(ScorePF, Pos, Quaternion.identity);
				obj.GetComponent<CsScoreAni>().SetAni(Pos, score, turn);
				obj.transform.localScale = Vector2.zero;
			}
			else if (curMode == PlayerMode.Multi && turn == playerUseTrun)
			{
				Vector3[] array = new Vector3[1] { Pos };
				pView.RPC("RPC_Throw_Dart_Result", RpcTarget.Others, array);
				int score2 = CsScore.GetInstance().Call_HitDart(Pos, turn, (int)curState);
				Pos.y += 0.2f;
				GameObject obj2 = UnityEngine.Object.Instantiate(ScorePF, Pos, Quaternion.identity);
				obj2.GetComponent<CsScoreAni>().SetAni(Pos, score2, turn);
				obj2.transform.localScale = Vector2.zero;
			}
		}

		public void Call_OutDart(int turn)
		{
			throwCheck = false;
			CsScore.GetInstance().Call_OutDart(turn, (int)curState);
			Call_PlaySound(CsSound.Sound.Hit_01);
		}

		public void Call_Bust(int turn)
		{
			BustAni[turn].SetTrigger("Start");
			Call_PlaySound(CsSound.Sound.Out_01);
			if (ThreeDart[turn] == 0)
			{
				return;
			}
			ThreeDart[turn] = 0;
			if (turn == playerUseTrun)
			{
				if (curMode == PlayerMode.Single)
				{
					StartCoroutine(Corou_StartShot());
				}
				else if (curMode == PlayerMode.Multi && PhotonNetwork.IsMasterClient)
				{
					pView.RPC("RPC_Corou_StartShot", RpcTarget.All);
				}
			}
			else if (curMode == PlayerMode.Single)
			{
				StopCoroutine(AI_Shot);
			}
		}

		public void Call_GameWinLose(bool win)
		{
			tempState = curState;
			curState = State.GameEnd;
			StopAllCoroutines();
			MoveObj.SetActive(value: false);
			string[] arr_score = new string[2]
			{
				CsScore.GetInstance().GetScore(1).ToString(),
				CsScore.GetInstance().GetScore(2).ToString()
			};
			int winnerPlayer = 2;
			if (CsScore.GetInstance().GetScore(1) < CsScore.GetInstance().GetScore(2))
			{
				winnerPlayer = 0;
			}
			else if (CsScore.GetInstance().GetScore(1) > CsScore.GetInstance().GetScore(2))
			{
				winnerPlayer = 1;
			}
			PublicGameUIManager.GetInstance.OpenResultBoard(arr_score, winnerPlayer);
			if (win && PlayerPrefs.GetInt(Data.Zerowon.ToString()) != 4 && PlayerPrefs.GetInt(Data.Zerowon.ToString()) == _curLevel)
			{
				PlayerPrefs.SetInt(Data.Zerowon.ToString(), _curLevel);
			}
			if (win)
			{
				if (!PhotonNetwork.InRoom)
				{
					SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
				}
				Call_PlaySound(CsSound.Sound.Win);
				Call_PlaySound(CsSound.Sound.WinCrowd);
				OtherChar.GetComponent<Animator>().SetTrigger("Lose");
			}
			else
			{
				Call_PlaySound(CsSound.Sound.Lose);
				Call_PlaySound(CsSound.Sound.LoseCrowd);
				OtherChar.GetComponent<Animator>().SetTrigger("Win");
			}
			CsScore.GetInstance().Reset();
		}

		public int GetDartThree(int turn)
		{
			return ThreeDart[turn];
		}

		private Vector3 getShotVelocityAtoB(Vector3 A, Vector3 B, float t)
		{
			Vector3 vector = A;
			Vector3 vector2 = B;
			float num = vector2.x - vector.x;
			float num2 = vector2.z - vector.z;
			float x = num / t;
			float z = num2 / t;
			float num3 = -9.81f + 2.5f;
			float y = vector.y;
			float y2 = (vector2.y - y - num3 * Mathf.Pow(t, 2f) / 2f) / t;
			return new Vector3(x, y2, z);
		}

		public void Call_Button_SingleType(string str)
		{
			if (str == "Zerowon")
			{
				tempState = State.Zerowon;
				curMode = PlayerMode.Single;
				gameRound = 0;
				CsScore.GetInstance().Set_Zerowon();
			}
			else if (str == "CountUp")
			{
				tempState = State.CountUp;
				curMode = PlayerMode.Single;
				gameRound = 0;
				CsScore.GetInstance().Set_CountUp();
			}
		}

		public void Call_Button_SingleLevel(int level)
		{
			playerUseTrun = 1;
			ThreeDart[1] = 0;
			ThreeDart[2] = 0;
			_curLevel = level;
			StartCoroutine(Corou_Call_Button_SingleLevel());
		}

		private IEnumerator Corou_Call_Button_SingleLevel()
		{
			curState = State.None;
			NameText[1].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			NameText[2].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			yield return YieldInstructionCache.WaitForSeconds(0.3f);
			for (int i = 0; i < DartScreens.Length; i++)
			{
				if (curState == State.CountUp)
				{
					DartScreens[i].material = Mat_Countup;
				}
				else if (curState == State.Zerowon)
				{
					DartScreens[i].material = Mat_Zerowon;
				}
			}
			CsScore.GetInstance().SetRound(1);
			CsScore.GetInstance().DeleteCurScore(1);
			PlayerObj.transform.position = PlayerPosTrs[playerUseTrun].position;
			OtherChar = UnityEngine.Object.Instantiate(CharPF);
			OtherChar.GetComponent<Animator>().runtimeAnimatorController = Char_Ani;
			OtherChar.transform.position = new Vector3(0.063f, 2.5f, -4.35f);
			OtherChar.GetComponent<CustomModelSettingCtrl>().InitCPU();
			OtherDartImage = UnityEngine.Object.Instantiate(DartImagePF);
			OtherDartImage.transform.SetParent(OtherChar.transform.GetChild(0).GetChild(1).GetChild(2)
				.GetChild(0)
				.GetChild(0)
				.GetChild(2)
				.GetChild(0)
				.GetChild(0)
				.GetChild(1));
			OtherDartImage.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
			OtherDartImage.transform.localPosition = new Vector3(-0.14f, 0.055f, -0.044f);
			OtherDartImage.SetActive(value: false);
			yield return YieldInstructionCache.WaitForSeconds(1f);
			curState = tempState;
			GameHelpObj.SetActive(value: true);
			firstShot = false;
			MoveObj.SetActive(value: true);
			ThreeDart[1] = 3;
			ThreeDart[2] = 3;
			CsScore.GetInstance().DeleteCurScore(1);
			CsScore.GetInstance().DeleteCurScore(2);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
		}

		public int GetPlayerLevel(string type)
		{
			if (type == "Zerowon")
			{
				return PlayerPrefs.GetInt(Data.Zerowon.ToString());
			}
			if (type == "CountUp")
			{
				return PlayerPrefs.GetInt(Data.CountUp.ToString());
			}
			UnityEngine.Debug.Log("No");
			return 0;
		}

		public void Call_Button_Ani_ResultUI(string str)
		{
		}

		public void Call_Button_Replay()
		{
			curState = tempState;
			gameRound = 0;
			playerUseTrun = 1;
			if (curState == State.Zerowon)
			{
				CsScore.GetInstance().Set_Zerowon();
			}
			else if (curState == State.CountUp)
			{
				CsScore.GetInstance().Set_CountUp();
			}
			UnityEngine.Object.Destroy(OtherChar);
			Call_Button_SingleLevel(_curLevel);
		}

		public void Call_Button_NextGame()
		{
			curState = tempState;
			gameRound = 0;
			playerUseTrun = 1;
			if (curState == State.Zerowon)
			{
				CsScore.GetInstance().Set_Zerowon();
			}
			else if (curState == State.CountUp)
			{
				CsScore.GetInstance().Set_CountUp();
			}
			CsScore.GetInstance().SetRound(1);
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level++;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level == 5)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level = 4;
			}
			_curLevel = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			UnityEngine.Object.Destroy(OtherChar);
			Call_Button_SingleLevel(_curLevel);
		}

		public void Call_Button_MainMenu()
		{
			SceneManager.LoadScene("Scene_Lobby");
			if (PhotonNetwork.IsConnected)
			{
				PhotonNetwork.Disconnect();
			}
		}

		public void Call_Button_CloseStopUI()
		{
			SetStopUIActive(_bool: false);
		}

		public void Call_Button_Playing()
		{
		}

		public void Call_Button_Exit()
		{
			MultiDemoManager.GetInstance().ExitBox(1);
		}

		public void Call_PlaySound(CsSound.Sound _sound)
		{
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese)
			{
				gEffectAudio.PlayOneShot(gSound.AudioChina[(int)_sound]);
			}
			else
			{
				gEffectAudio.PlayOneShot(gSound.Audio[(int)_sound]);
			}
		}

		public void Call_Button_Focus()
		{
			gEffectAudio.PlayOneShot(gSound.Audio[7]);
		}

		public void Call_Button_Click()
		{
			gEffectAudio.PlayOneShot(gSound.Audio[6]);
		}

		private void SetStopUIActive(bool _bool)
		{
			if (_bool)
			{
				tempState = curState;
			}
			else
			{
				curState = tempState;
			}
		}

		private void TimeFunc()
		{
			gClockAudio.Stop();
			_limitTime = 30f;
			if (TimeCorou != null)
			{
				StopCoroutine(TimeCorou);
			}
			TimeCorou = Corou_LimitTime();
			StartCoroutine(TimeCorou);
		}

		private IEnumerator Corou_LimitTime()
		{
			while (5f < _limitTime)
			{
				yield return null;
				_limitTime -= Time.deltaTime;
				TimeTexts[0].text = ((int)_limitTime).ToString();
				TimeTexts[1].text = ((int)_limitTime).ToString();
			}
			gClockAudio.PlayOneShot(gSound.Audio[8]);
			while (0f < _limitTime)
			{
				yield return null;
				_limitTime -= Time.deltaTime;
				TimeTexts[0].text = ((int)_limitTime).ToString();
				TimeTexts[1].text = ((int)_limitTime).ToString();
			}
			TimeTexts[0].text = "0";
			TimeTexts[1].text = "0";
			if (ThreeDart[1] == 0 && ThreeDart[2] == 0)
			{
				UnityEngine.Debug.Log("Nope");
			}
			else if (curMode == PlayerMode.Single)
			{
				TimeOver();
			}
			else if (curMode == PlayerMode.Multi && PhotonNetwork.IsMasterClient)
			{
				pView.RPC("RPC_LimitTime", RpcTarget.All);
			}
		}

		[PunRPC]
		private void RPC_LimitTime()
		{
			TimeOver();
		}

		private void TimeOver()
		{
			ThreeDart[1] = 0;
			ThreeDart[2] = 0;
			gClockAudio.Stop();
			Call_PlaySound(CsSound.Sound.Out_07);
			if ((curState == State.CountUp && gameRound < 3) || (curState == State.Zerowon && gameRound < 8))
			{
				ReadyAni.SetTrigger("Ready");
				RoundText.text = (gameRound + 1).ToString();
				CsScore.GetInstance().Call_ResetHitLight();
			}
			StartShot();
			throwCheck = false;
		}

		public void Call_MultiGame(int SetTurn)
		{
			playerUseTrun = SetTurn;
			ThreeDart[1] = 0;
			ThreeDart[2] = 0;
			curMode = PlayerMode.Multi;
		}

		public void Call_LeftRoom()
		{
			curMode = PlayerMode.Single;
		}

		public State GetState()
		{
			return curState;
		}

		public PlayerMode GetPlayerMode()
		{
			return curMode;
		}

		[PunRPC]
		public void RPC_MultiGameStart()
		{
			StartCoroutine(Corou_RPC_MultiGameStart());
		}

		private IEnumerator Corou_RPC_MultiGameStart()
		{
			yield return null;
			yield return null;
			yield return null;
			gameRound = 0;
			curState = State.Zerowon;
			if (curState == State.CountUp)
			{
				CsScore.GetInstance().Set_CountUp();
			}
			else if (curState == State.Zerowon)
			{
				CsScore.GetInstance().Set_Zerowon();
			}
			for (int i = 0; i < DartScreens.Length; i++)
			{
				if (curState == State.CountUp)
				{
					DartScreens[i].material = Mat_Countup;
				}
				else if (curState == State.Zerowon)
				{
					DartScreens[i].material = Mat_Zerowon;
				}
			}
			CsScore.GetInstance().SetRound(1);
			CsScore.GetInstance().DeleteCurScore(1);
			PlayerObj.transform.position = PlayerPosTrs[playerUseTrun].position;
			string user_id = ((!PhotonNetwork.IsMasterClient) ? SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id : SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id);
			PlayerObj.GetComponent<CsAutoMove>().enabled = true;
			OtherChar = UnityEngine.Object.Instantiate(MultiCharPF);
			OtherChar.GetComponent<CustomModelSettingCtrl>().Init(user_id, CustomModelViewState.HalfCut2);
			if (playerUseTrun == 1)
			{
				OtherChar.transform.position = new Vector3(0.063f, 2.5f, -4.35f);
				NameText[1].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
				NameText[2].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			}
			else if (playerUseTrun == 2)
			{
				OtherChar.transform.position = new Vector3(-1.45f, 2.5f, -4.35f);
				NameText[1].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
				NameText[2].text = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			}
			OtherChar.GetComponent<VRIK>().enabled = true;
			OtherChar.GetComponent<VRIK>().solver.spine.headTarget = OtherPartsTrs[1];
			OtherChar.GetComponent<VRIK>().solver.rightArm.target = OtherPartsTrs[3];
			OtherChar.GetComponent<VRIK>().solver.leftArm.target = OtherPartsTrs[5];
			yield return YieldInstructionCache.WaitForSeconds(1f);
			MoveObj.SetActive(value: true);
			StartShot();
			GameHelpObj.SetActive(value: false);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
		}

		[PunRPC]
		private void RPC_ReadyDart(bool right)
		{
			if (right)
			{
				OtherDartImage = OtherDart_Right;
				OtherHandCont_Main = OtherHandCont_R;
			}
			else
			{
				OtherDartImage = OtherDart_Left;
				OtherHandCont_Main = OtherHandCont_L;
			}
			OtherDartImage.SetActive(value: true);
			OtherHandCont_Main.SetTrigger("Grap");
		}

		[PunRPC]
		private void RPC_Throw_Dart(Vector3[] RecieveData)
		{
			Vector3 position = RecieveData[0];
			Vector3 velocity = RecieveData[1];
			int num = ((playerUseTrun != 1) ? 1 : 2);
			ThreeDart[num]--;
			GameObject gameObject = UnityEngine.Object.Instantiate(DartPF);
			gameObject.transform.position = position;
			gameObject.GetComponent<Rigidbody>().velocity = velocity;
			gameObject.GetComponent<CsDart>().SetTurn(num);
			Call_PlaySound(CsSound.Sound.Throw_01);
			DartList.Add(gameObject);
			OtherDart_Right.SetActive(value: false);
			OtherDart_Left.SetActive(value: false);
			OtherHandCont_R.SetTrigger("Throw");
			OtherHandCont_L.SetTrigger("Throw");
		}

		[PunRPC]
		private void RPC_Throw_Dart_Result(Vector3[] RecieveData)
		{
			Vector3 vector = RecieveData[0];
			int turn = 1;
			if (playerUseTrun == 1)
			{
				turn = 2;
			}
			int score = CsScore.GetInstance().Call_HitDart(vector, turn, (int)curState);
			vector.y += 0.2f;
			GameObject obj = UnityEngine.Object.Instantiate(ScorePF, vector, Quaternion.identity);
			obj.GetComponent<CsScoreAni>().SetAni(vector, score, turn);
			obj.transform.localScale = Vector2.zero;
		}

		[PunRPC]
		private void RPC_StreamPos(Vector3[] RecieveData)
		{
			for (int i = 0; i < 6; i += 2)
			{
				GetOtherPartsData[i].position = RecieveData[i];
			}
			for (int j = 1; j < 6; j += 2)
			{
				GetOtherPartsData[j].eulerAngles = RecieveData[j];
			}
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}

		public void HapticPulse(UnityEngine.XR.Interaction.Toolkit.XRController controller)
		{
			if (controller.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				controller.inputDevice.SendHapticImpulse(0u, HapTicValue * PublicGameUIManager.gameSetting.GetHapticValue(), HapTicDuration);
			}
		}
	}
	public class CsPower : MonoBehaviour
	{
		public Transform RightMoveTrs;

		public Transform RightTargetTrs;

		public Transform LeftMoveTrs;

		public Transform LeftTargetTrs;

		private Vector3 PrePos;

		private Vector3 CurPos;

		private Vector3 CurVel;

		private Vector3[] ArrVel = new Vector3[20];

		public int useIndex = 10;

		private int curIndex;

		private float _powerValue;

		private static CsPower _instance;

		public float maxdis = 10f;

		public float mindis = 0.5f;

		public float totalValue = 3f;

		public float yvalue = 0.5f;

		public static CsPower GetInstance()
		{
			return _instance;
		}

		private void Start()
		{
			_instance = this;
			base.transform.position = Vector3.zero;
			PrePos = Vector3.zero;
			CurPos = Vector3.zero;
		}

		private void FixedUpdate()
		{
			RightMoveTrs.position = RightTargetTrs.position;
			RightMoveTrs.rotation = RightTargetTrs.rotation;
			LeftMoveTrs.position = LeftTargetTrs.position;
			LeftMoveTrs.rotation = LeftTargetTrs.rotation;
			if (PublicGameUIManager.gameSetting.IsRightHanded())
			{
				CurPos = RightMoveTrs.position;
			}
			else
			{
				CurPos = LeftMoveTrs.position;
			}
			if (PrePos != CurPos)
			{
				Vector3 vector = (CurPos - PrePos) / Time.fixedDeltaTime;
				GetComponent<Rigidbody>().velocity = vector;
				_powerValue = vector.magnitude;
				CurVel = vector;
				ArrVel[curIndex] = CurVel;
				curIndex++;
				if (useIndex <= curIndex)
				{
					curIndex = 0;
				}
			}
			else
			{
				GetComponent<Rigidbody>().velocity = Vector3.zero;
				ArrVel[curIndex] = Vector3.zero;
				curIndex++;
				if (useIndex <= curIndex)
				{
					curIndex = 0;
				}
			}
			PrePos = CurPos;
		}

		public Vector3 GetVel()
		{
			Vector3 result = default(Vector3);
			for (int i = 0; i < useIndex; i++)
			{
				if (ArrVel[i].magnitude < mindis)
				{
					result += ArrVel[i].normalized * mindis;
				}
				else if (maxdis < ArrVel[i].magnitude)
				{
					result += ArrVel[i].normalized * maxdis;
				}
				else
				{
					result += ArrVel[i];
				}
			}
			result *= totalValue / (float)useIndex;
			result.y *= yvalue;
			return result;
		}

		public void curindexChe()
		{
			curIndex = 0;
		}
	}
	public class CsScore : MonoBehaviour
	{
		private static CsScore instance;

		private int[] Score = new int[3];

		private int[] CheckScore = new int[3];

		public GameObject[] DartGameColl;

		public GameObject[] HitLight_Parent;

		public GameObject[] HitLight;

		public GameObject[] DartImageParent_One;

		public GameObject[] DartImageParent_Two;

		public Texture[] Image_One;

		public Texture[] Image_Two;

		public Texture[] Image_Triple;

		public Texture[] Image_Double;

		public Text OneTotalScore;

		public Text[] OneCurScore;

		public Text TwoTotalScore;

		public Text[] TwoCurScore;

		public GameObject[] OneRoundObjs_CountUp;

		public GameObject[] TwoRoundObjs_CountUp;

		public GameObject[] OneRoundObjs_Zerowon;

		public GameObject[] TwoRoundObjs_Zerowon;

		private Vector2 CenterPos_One;

		private Vector2 CenterPos_Two;

		public static CsScore GetInstance()
		{
			return instance;
		}

		private void Start()
		{
			instance = this;
			CenterPos_One = DartGameColl[1].transform.position;
			CenterPos_Two = DartGameColl[2].transform.position;
			SetSprite();
		}

		private void SetSprite()
		{
			for (int i = 0; i < 21; i++)
			{
				DartImageParent_One[1].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_One[i]);
				DartImageParent_One[2].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_Two[i]);
				DartImageParent_One[3].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_Triple[i]);
				DartImageParent_One[4].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_Double[i]);
				DartImageParent_Two[1].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_One[i]);
				DartImageParent_Two[2].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_Two[i]);
				DartImageParent_Two[3].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_Triple[i]);
				DartImageParent_Two[4].transform.GetChild(i).GetComponent<MeshRenderer>().material.SetTexture("_BaseMap", Image_Double[i]);
			}
		}

		public int Call_HitDart(Vector2 HitPos, int turn, int state)
		{
			Vector2 vector = default(Vector2);
			vector = ((turn != 1) ? (HitPos - CenterPos_Two) : (HitPos - CenterPos_One));
			float magnitude = vector.magnitude;
			int produ = GetProdu(magnitude, turn);
			if (produ == -1)
			{
				Call_OutDart(turn, state);
				return 0;
			}
			int num = 0;
			num = ((produ != 50 && produ != 25) ? (produ * GetNumber(vector, turn)) : produ);
			if (turn == 1)
			{
				switch (state)
				{
				case 2:
					Score[1] -= num;
					OneTotalScore.text = Score[1].ToString();
					OneCurScore[CsMain.GetInstance().GetDartThree(1)].text = num.ToString();
					if (Score[1] == 0)
					{
						if (CsMain.GetInstance().GetPlayerUseTurn() == 1)
						{
							CsMain.GetInstance().Call_GameWinLose(win: true);
							SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach28", 1);
						}
						else
						{
							CsMain.GetInstance().Call_GameWinLose(win: false);
						}
					}
					else if (Score[1] < 0)
					{
						Bust(1);
					}
					break;
				case 3:
					Score[1] += num;
					OneTotalScore.text = Score[1].ToString();
					OneCurScore[CsMain.GetInstance().GetDartThree(1)].text = num.ToString();
					break;
				}
			}
			else
			{
				switch (state)
				{
				case 2:
					Score[2] -= num;
					TwoTotalScore.text = Score[2].ToString();
					TwoCurScore[CsMain.GetInstance().GetDartThree(2)].text = num.ToString();
					if (Score[2] == 0)
					{
						if (CsMain.GetInstance().GetPlayerUseTurn() == 2)
						{
							CsMain.GetInstance().Call_GameWinLose(win: true);
							SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach28", 1);
						}
						else
						{
							CsMain.GetInstance().Call_GameWinLose(win: false);
						}
					}
					else if (Score[2] < 0)
					{
						Bust(2);
					}
					break;
				case 3:
					Score[2] += num;
					TwoTotalScore.text = Score[2].ToString();
					TwoCurScore[CsMain.GetInstance().GetDartThree(2)].text = num.ToString();
					break;
				}
			}
			return num;
		}

		public void Call_OutDart(int turn, int state)
		{
			if (turn == 1)
			{
				OneCurScore[CsMain.GetInstance().GetDartThree(1)].text = "0";
			}
			else
			{
				TwoCurScore[CsMain.GetInstance().GetDartThree(2)].text = "0";
			}
		}

		private int GetProdu(float dis, int turn)
		{
			int num = -1;
			if (dis < 0.0129f)
			{
				num = 50;
				SetHitLight(5, turn);
				SpriteAct(1, turn);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.CenterHit_01);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.DoubleBull);
				SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach27", 1);
			}
			else if (dis < 0.0367f)
			{
				num = 25;
				SetHitLight(4, turn);
				SpriteAct(2, turn);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.CenterHit_01);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.SingleBull);
			}
			else if (dis < 0.1315f)
			{
				num = 1;
				SetHitLight(0, turn);
			}
			else if (dis < 0.1532f)
			{
				num = 3;
				SetHitLight(1, turn);
				SpriteAct(3, turn);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.CenterHit_02);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.Triple);
			}
			else if (dis < 0.237f)
			{
				num = 1;
				SetHitLight(2, turn);
			}
			else if (dis < 0.257f)
			{
				num = 2;
				SetHitLight(3, turn);
				SpriteAct(4, turn);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.CenterHit_04);
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.Double);
			}
			else
			{
				num = -1;
				CsMain.GetInstance().Call_PlaySound(CsSound.Sound.Out_01);
			}
			return num;
		}

		private int GetNumber(Vector2 Pos, int turn)
		{
			UnityEngine.Debug.Log(" Angle : " + Vector2.Angle(Pos, Vector2.up));
			float num = Vector2.Angle(Pos, Vector2.up);
			num /= 9f;
			int num2 = 0;
			Vector3 eulerAngles = new Vector3(0f, 180f, 0f);
			if (num < 1f)
			{
				num2 = 20;
				eulerAngles.z = 0f;
			}
			else if (num < 3f)
			{
				if (0f < Pos.x)
				{
					num2 = 1;
					eulerAngles.z = 18f;
				}
				else
				{
					num2 = 5;
					eulerAngles.z = -18f;
				}
			}
			else if (num < 5f)
			{
				if (0f < Pos.x)
				{
					num2 = 18;
					eulerAngles.z = 36f;
				}
				else
				{
					num2 = 12;
					eulerAngles.z = -36f;
				}
			}
			else if (num < 7f)
			{
				if (0f < Pos.x)
				{
					num2 = 4;
					eulerAngles.z = 54f;
				}
				else
				{
					num2 = 9;
					eulerAngles.z = -54f;
				}
			}
			else if (num < 9f)
			{
				if (0f < Pos.x)
				{
					num2 = 13;
					eulerAngles.z = 72f;
				}
				else
				{
					num2 = 14;
					eulerAngles.z = -72f;
				}
			}
			else if (num < 11f)
			{
				if (0f < Pos.x)
				{
					num2 = 6;
					eulerAngles.z = 90f;
				}
				else
				{
					num2 = 11;
					eulerAngles.z = -90f;
				}
			}
			else if (num < 13f)
			{
				if (0f < Pos.x)
				{
					num2 = 10;
					eulerAngles.z = 108f;
				}
				else
				{
					num2 = 8;
					eulerAngles.z = -108f;
				}
			}
			else if (num < 15f)
			{
				if (0f < Pos.x)
				{
					num2 = 15;
					eulerAngles.z = 126f;
				}
				else
				{
					num2 = 16;
					eulerAngles.z = -126f;
				}
			}
			else if (num < 17f)
			{
				if (0f < Pos.x)
				{
					num2 = 2;
					eulerAngles.z = 144f;
				}
				else
				{
					num2 = 7;
					eulerAngles.z = -144f;
				}
			}
			else if (num < 19f)
			{
				if (0f < Pos.x)
				{
					num2 = 17;
					eulerAngles.z = 162f;
				}
				else
				{
					num2 = 19;
					eulerAngles.z = -162f;
				}
			}
			else
			{
				num2 = 3;
				eulerAngles.z = 180f;
			}
			HitLight_Parent[turn].transform.eulerAngles = eulerAngles;
			return num2;
		}

		public int GetScore(int player)
		{
			return Score[player];
		}

		public void Set_CountUp()
		{
			for (int i = 0; i < Score.Length; i++)
			{
				Score[i] = 0;
			}
			Set_Default();
		}

		public void Set_Zerowon()
		{
			Score[1] = 301;
			Score[2] = 301;
			Set_Default();
		}

		public void Set_Default()
		{
			OneTotalScore.text = Score[1].ToString();
			for (int i = 0; i < OneCurScore.Length; i++)
			{
				OneCurScore[i].text = "0";
			}
			TwoTotalScore.text = Score[2].ToString();
			for (int j = 0; j < TwoCurScore.Length; j++)
			{
				TwoCurScore[j].text = "0";
			}
			for (int k = 1; k < OneRoundObjs_CountUp.Length; k++)
			{
				OneRoundObjs_CountUp[k].SetActive(value: false);
				TwoRoundObjs_CountUp[k].SetActive(value: false);
			}
			for (int l = 1; l < OneRoundObjs_Zerowon.Length; l++)
			{
				OneRoundObjs_Zerowon[l].SetActive(value: false);
				TwoRoundObjs_Zerowon[l].SetActive(value: false);
			}
		}

		public void Set_CheckScore(int turn)
		{
			CheckScore[turn] = Score[turn];
		}

		public void Bust(int turn)
		{
			Score[turn] = CheckScore[turn];
			if (turn == 1)
			{
				OneTotalScore.text = Score[1].ToString();
			}
			else
			{
				TwoTotalScore.text = Score[2].ToString();
			}
			CsMain.GetInstance().Call_Bust(turn);
			CsMain.GetInstance().Call_PlaySound(CsSound.Sound.Bust);
		}

		public void Reset()
		{
			for (int i = 0; i < Score.Length; i++)
			{
				Score[i] = 0;
				CheckScore[i] = 0;
			}
		}

		private void SetHitLight(int num, int turn)
		{
			int i = 0;
			if (turn == 2)
			{
				i = 5;
			}
			for (; i < turn * 5; i++)
			{
				HitLight[i].SetActive(value: false);
			}
			switch (num)
			{
			case 4:
				UnityEngine.Debug.Log("");
				break;
			case 5:
				UnityEngine.Debug.Log("");
				break;
			default:
				HitLight[num + (turn * 5 - 5)].SetActive(value: true);
				break;
			}
		}

		public void Call_ResetHitLight()
		{
			for (int i = 0; i < HitLight.Length; i++)
			{
				HitLight[i].SetActive(value: false);
			}
		}

		public void DeleteCurScore(int turn)
		{
			if (turn == 1)
			{
				for (int i = 0; i < OneCurScore.Length; i++)
				{
					OneCurScore[i].text = "";
				}
			}
			if (turn == 2)
			{
				for (int j = 0; j < TwoCurScore.Length; j++)
				{
					TwoCurScore[j].text = "";
				}
			}
		}

		public void SpriteAct(int type, int turn)
		{
			StartCoroutine(Corou_Sprite(0, type, turn));
		}

		private IEnumerator Corou_Sprite(int num, int type, int turn)
		{
			switch (turn)
			{
			case 1:
				DartImageParent_One[type].transform.GetChild(num).gameObject.SetActive(value: true);
				break;
			case 2:
				DartImageParent_Two[type].transform.GetChild(num).gameObject.SetActive(value: true);
				break;
			}
			for (float dt = 0f; dt < 0.025f; dt += Time.deltaTime)
			{
				yield return null;
			}
			switch (turn)
			{
			case 1:
				DartImageParent_One[type].transform.GetChild(num).gameObject.SetActive(value: false);
				break;
			case 2:
				DartImageParent_Two[type].transform.GetChild(num).gameObject.SetActive(value: false);
				break;
			}
			num++;
			if (num < 21)
			{
				StartCoroutine(Corou_Sprite(num, type, turn));
			}
		}

		public void SetRound(int round)
		{
			if (CsMain.GetInstance().GetState() == CsMain.State.CountUp)
			{
				if (OneRoundObjs_CountUp.Length > round)
				{
					OneRoundObjs_CountUp[round].SetActive(value: true);
					TwoRoundObjs_CountUp[round].SetActive(value: true);
				}
			}
			else if (CsMain.GetInstance().GetState() == CsMain.State.Zerowon && OneRoundObjs_Zerowon.Length > round)
			{
				OneRoundObjs_Zerowon[round].SetActive(value: true);
				TwoRoundObjs_Zerowon[round].SetActive(value: true);
			}
		}

		public int GetWinPlayer()
		{
			if (Score[2] < Score[1])
			{
				return 1;
			}
			return 2;
		}

		public int GetWinZerowonPlayer()
		{
			if (Score[1] < Score[2])
			{
				return 1;
			}
			return 2;
		}
	}
	public class CsScoreAni : MonoBehaviour
	{
		public void SetAni(Vector3 Pos, int score, int turn)
		{
			Pos.y -= 0.09f;
			base.transform.position = Pos;
			GetComponent<TextMesh>().text = score.ToString();
			GetComponent<Animation>().Play();
			StartCoroutine(Corou_ScoreAni());
		}

		private IEnumerator Corou_ScoreAni()
		{
			for (float dt = 0f; dt < 0.5f; dt += Time.deltaTime)
			{
				yield return null;
			}
			float alpha = 1f;
			Color col = Color.white;
			while (0f < alpha)
			{
				yield return null;
				alpha = (col.a = alpha - Time.deltaTime * 2f);
				GetComponent<TextMesh>().color = col;
				Vector3 position = base.transform.position;
				position.y += Time.deltaTime * 0.2f;
				base.transform.position = position;
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public class CsSound : MonoBehaviour
	{
		public enum Sound
		{
			CenterHit_01,
			CenterHit_05,
			Hit_01,
			Out_01,
			Out_07,
			Throw_01,
			Button_Click,
			Button_Focus,
			ClockTicking,
			Win,
			Lose,
			WinCrowd,
			LoseCrowd,
			CenterHit_02,
			CenterHit_04,
			Bust,
			Double,
			DoubleBull,
			SingleBull,
			Triple
		}

		public AudioClip[] Audio;

		public AudioClip[] AudioChina;
	}
	public class RandAnimation : MonoBehaviour
	{
		private Animator anim;

		public int MaxRandValue;

		public float randTime;

		private float currentTime;

		private void Start()
		{
			anim = GetComponent<Animator>();
		}

		private void Update()
		{
			RandAnim();
		}

		private void RandAnim()
		{
			currentTime += Time.deltaTime;
			if (currentTime >= randTime)
			{
				currentTime = 0f;
				int value = UnityEngine.Random.Range(0, MaxRandValue);
				anim.SetInteger("rand", value);
			}
		}
	}
}
namespace CueSports
{
	public class UIBaseLobbyMenu : MonoBehaviour
	{
		[SerializeField]
		protected CanvasGroup canvasGroup;

		[SerializeField]
		protected UIBaseLobbyMenu prevMenu;

		protected bool _allowBack = true;

		public bool AllowBack
		{
			get
			{
				return _allowBack;
			}
			protected set
			{
				_allowBack = value;
			}
		}

		public UIBaseLobbyMenu PrevMenu => prevMenu;

		public float alpha
		{
			get
			{
				return canvasGroup.alpha;
			}
			set
			{
				canvasGroup.alpha = value;
			}
		}

		public bool isInitialized { get; private set; }

		public virtual void Initialize()
		{
			_ = isInitialized;
		}

		public virtual void OnEnter()
		{
		}

		public void SetOpacity(float value)
		{
			canvasGroup.alpha = Mathf.Clamp01(value);
		}

		public virtual void OnExit()
		{
		}
	}
	public class UIFriendLobbyItem : MonoBehaviour
	{
		[SerializeField]
		private Button InviteButton;

		[SerializeField]
		private Text Name;

		[SerializeField]
		private Text SendButtonDescription;

		public string UserID { get; private set; }

		public string NickName { get; private set; }

		public bool Invitable { get; private set; }

		private event Action<string, string> OnInvite;

		public void Initialize(string id, string nickName, bool invitable, Action<string, string> onInvite)
		{
			UserID = id;
			NickName = nickName;
			Invitable = invitable;
			InviteButton.interactable = Invitable;
			Name.text = NickName;
			this.OnInvite = onInvite;
			SendButtonDescription.text = (Invitable ? "초대가능" : "초대불가");
		}

		public void OnClickInvite()
		{
			this.OnInvite?.Invoke(UserID, NickName);
			InviteButton.interactable = false;
			SendButtonDescription.text = "초대중..";
		}

		public void ResetInvite()
		{
			SendButtonDescription.text = (Invitable ? "초대가능" : "초대불가");
			InviteButton.interactable = Invitable;
		}

		private Color rebuildColor(Color rgb)
		{
			Color.RGBToHSV(rgb, out var H, out var S, out var V);
			S = 1f;
			return Color.HSVToRGB(H, S, V);
		}
	}
	public class UIMainMenu : MonoBehaviour
	{
		[SerializeField]
		private UIBaseLobbyMenu FirstMenu;

		private Coroutine runRoutine;

		private UIBaseLobbyMenu lastMenu;

		private Queue<UIBaseLobbyMenu> cachedTarget = new Queue<UIBaseLobbyMenu>();

		private bool IsConverted;

		private void Awake()
		{
			lastMenu = FirstMenu;
		}

		private void ControllerBackButton_OnDataChanged(bool isDown)
		{
			if (isDown && !(lastMenu.PrevMenu == null) && lastMenu.AllowBack)
			{
				GoTarget(lastMenu.PrevMenu);
			}
		}

		public void GoTarget(UIBaseLobbyMenu currentMenu)
		{
			if (lastMenu == currentMenu)
			{
				return;
			}
			if (runRoutine != null)
			{
				if (IsConverted)
				{
					cachedTarget.Enqueue(currentMenu);
				}
			}
			else
			{
				runRoutine = StartCoroutine(RunAndFade(lastMenu, currentMenu, 1f));
				lastMenu = currentMenu;
			}
		}

		private void OnDestroy()
		{
		}

		private IEnumerator RunAndFade(UIBaseLobbyMenu from, UIBaseLobbyMenu to, float runtime)
		{
			IsConverted = false;
			to.Initialize();
			float t = 0f;
			while (t < runtime)
			{
				t += Time.deltaTime;
				from.alpha = 1f - Mathf.Clamp01(t / runtime);
				yield return null;
			}
			from.alpha = 0f;
			from.gameObject.SetActive(value: false);
			from.OnExit();
			IsConverted = true;
			to.alpha = 0f;
			to.gameObject.SetActive(value: true);
			to.OnEnter();
			while (t > 0f)
			{
				t -= Time.deltaTime;
				to.alpha = 1f - Mathf.Clamp01(t / runtime);
				yield return null;
			}
			to.alpha = 1f;
			runRoutine = null;
			if (cachedTarget.Count > 0)
			{
				GoTarget(cachedTarget.Dequeue());
				cachedTarget.Clear();
			}
		}
	}
	public class UISingleLobbyMenu : UIBaseLobbyMenu
	{
		[SerializeField]
		private List<GameObject> Covers = new List<GameObject>(5);

		[SerializeField]
		private List<Button> Levels = new List<Button>();

		private int CachedAccessableData;

		public override void Initialize()
		{
			base.Initialize();
		}

		public override void OnEnter()
		{
			base.OnEnter();
		}

		public override void OnExit()
		{
			base.OnExit();
		}

		public void CheckSingle(string str)
		{
			CachedAccessableData = CsMain.GetInstance().GetPlayerLevel(str);
			for (int i = 0; i < 5; i++)
			{
				bool flag = i <= CachedAccessableData;
				Covers[i].SetActive(!flag);
				Levels[i].interactable = flag;
			}
		}
	}
	public class UITitleLobbyMenu : UIBaseLobbyMenu
	{
		[SerializeField]
		private Animator TitleAnimator;

		[SerializeField]
		private CanvasGroup[] ButtonGroup;

		[SerializeField]
		private Image LogoImage;

		[SerializeField]
		private Sprite startLogoSprite;

		private void Start()
		{
			canvasGroup.alpha = 0f;
			for (int i = 0; i < ButtonGroup.Length; i++)
			{
				ButtonGroup[i].alpha = 0f;
			}
			StartCoroutine(Run(isFirst: true));
		}

		public override void OnEnter()
		{
			base.OnEnter();
			LogoImage.sprite = startLogoSprite;
			for (int i = 0; i < ButtonGroup.Length; i++)
			{
				ButtonGroup[i].alpha = 0f;
			}
			StartCoroutine(Run());
		}

		private IEnumerator CanvasAlpha()
		{
			canvasGroup.alpha = 0f;
			while (canvasGroup.alpha < 1f)
			{
				canvasGroup.alpha += Time.deltaTime * 4f;
				yield return null;
			}
			canvasGroup.alpha = 1f;
		}

		private IEnumerator Run(bool isFirst = false)
		{
			if (isFirst)
			{
				yield return new WaitForSeconds(2f);
				StartCoroutine(CanvasAlpha());
			}
			TitleAnimator.enabled = true;
			TitleAnimator.Play("TitleAnimation");
			yield return new WaitForSeconds(1f);
			for (int i = 0; i < ButtonGroup.Length; i++)
			{
				ButtonGroup[i].alpha = 0f;
				ButtonGroup[i].gameObject.SetActive(value: true);
			}
			while (ButtonGroup[0].alpha < 1f)
			{
				for (int j = 0; j < ButtonGroup.Length; j++)
				{
					ButtonGroup[j].alpha += Time.deltaTime * 2f;
				}
				yield return null;
			}
			for (int k = 0; k < ButtonGroup.Length; k++)
			{
				ButtonGroup[k].alpha = 1f;
			}
		}

		public override void OnExit()
		{
			base.OnExit();
			for (int i = 0; i < ButtonGroup.Length; i++)
			{
				ButtonGroup[i].gameObject.SetActive(value: false);
			}
			TitleAnimator.enabled = false;
		}
	}
	public class TransportTest : MonoBehaviour
	{
		[Serializable]
		public class TestData : SerializableClass
		{
			public float time;

			public override void DeSerialize(string data)
			{
				TestData testData = JsonUtility.FromJson<TestData>(data);
				time = testData.time;
			}

			public override string Serialize()
			{
				return JsonUtility.ToJson(this);
			}
		}

		private int idx;

		private void Awake()
		{
			SingletonPunBase.Singleton<Transporter>.GetInstance.RegisterTarget(Call);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				TestData data = new TestData
				{
					time = Time.time
				};
				SingletonPunBase.Singleton<Transporter>.GetInstance.Send(Call, data);
			}
			if (Input.GetKeyDown(KeyCode.LeftShift))
			{
				Data data2 = new Data
				{
					value = idx++,
					value2 = "current idx is {0}"
				};
				SingletonPunBase.Singleton<Transporter>.GetInstance.Send(Call, data2);
			}
		}

		public void Call(SerializableClass packet)
		{
			if (packet != null)
			{
				if (packet is TestData testData)
				{
					TestData testData2 = testData;
					UnityEngine.Debug.Log("current Time : " + testData2.time);
					return;
				}
				if (packet is Data data)
				{
					Data data2 = data;
					UnityEngine.Debug.Log(string.Format(data2.value2, data2.value));
					return;
				}
			}
			UnityEngine.Debug.Log("packet Type is NOT supported");
		}
	}
	[Serializable]
	public abstract class SerializableClass
	{
		public abstract string Serialize();

		public abstract void DeSerialize(string data);
	}
	[Serializable]
	public class Data : SerializableClass
	{
		public int value;

		public string value2;

		public Data SetValue(int v)
		{
			value = v;
			return this;
		}

		public Data SetValue2(string v)
		{
			value2 = v;
			return this;
		}

		public override void DeSerialize(string data)
		{
			Data data2 = JsonUtility.FromJson<Data>(data);
			value = data2.value;
			value2 = data2.value2;
		}

		public override string Serialize()
		{
			return JsonUtility.ToJson(this);
		}
	}
	public class Transporter : SingletonPunBase.Singleton<Transporter>
	{
		private Dictionary<string, object> registeredInstanceDict = new Dictionary<string, object>();

		private PhotonView view;

		public PhotonView View
		{
			get
			{
				if ((object)view == null)
				{
					view = UnityEngine.Object.FindObjectOfType<PhotonView>().GetComponent<PhotonView>();
				}
				return view;
			}
		}

		public bool Send(Action<SerializableClass> invocationTarget, SerializableClass data)
		{
			PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = CreatePacket(invocationTarget, data);
			if (packetInfo == null)
			{
				return false;
			}
			SendTo(packetInfo.Serialize());
			return true;
		}

		public void RegisterTarget(Action<SerializableClass> invocationTarget)
		{
			string key = invocationTarget.GetMethodInfo().ReflectedType.ToString();
			object target = invocationTarget.Target;
			registeredInstanceDict[key] = target;
		}

		private PacketInfo<Action<SerializableClass>, SerializableClass> CreatePacket(Action<SerializableClass> invocationTarget, SerializableClass data)
		{
			if (!registeredInstanceDict.ContainsKey(invocationTarget.GetMethodInfo().ReflectedType.ToString()))
			{
				UnityEngine.Debug.LogError("invocationTarget is NOT Registered.");
				return null;
			}
			PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = new PacketInfo<Action<SerializableClass>, SerializableClass>();
			packetInfo.Set(invocationTarget, data);
			return packetInfo;
		}

		private void SendTo(string data)
		{
			View.RPC("ReceiveFrom", RpcTarget.Others, data);
			ReceiveFrom(data);
		}

		private void ReceiveFrom(string data)
		{
			PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = PacketInfo<Action<SerializableClass>, SerializableClass>.ToInfo(data);
			packetInfo.Get((string name) => registeredInstanceDict[name])(packetInfo.argsData);
		}
	}
	[Serializable]
	public class PacketInfo<T, Args> where T : Delegate where Args : SerializableClass
	{
		public string typeName;

		public string assem;

		public string functionName;

		public string ArgsType;

		public string ArgsAssem;

		public string serializedArgs;

		[NonSerialized]
		public Args argsData;

		public void Set(T caller, Args data)
		{
			functionName = caller.GetMethodInfo().Name;
			assem = caller.GetMethodInfo().ReflectedType.Assembly.ToString();
			typeName = caller.GetMethodInfo().ReflectedType.ToString();
			ArgsAssem = data.GetType().Assembly.ToString();
			ArgsType = data.GetType().FullName;
			argsData = data;
		}

		public string Serialize()
		{
			serializedArgs = argsData.Serialize();
			return JsonUtility.ToJson(this);
		}

		public static PacketInfo<T, Args> ToInfo(string json)
		{
			PacketInfo<T, Args> packetInfo = JsonUtility.FromJson<PacketInfo<T, Args>>(json);
			Type type = Type.GetType(packetInfo.ArgsType + ", " + packetInfo.ArgsAssem);
			packetInfo.argsData = Activator.CreateInstance(type) as Args;
			packetInfo.argsData.DeSerialize(packetInfo.serializedArgs);
			return packetInfo;
		}

		public T Get(Func<string, object> predicate)
		{
			MethodInfo method = Type.GetType(typeName + ", " + assem).GetMethod(functionName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			return (T)Delegate.CreateDelegate(typeof(T), predicate(typeName), method);
		}
	}
}
namespace Baseball
{
	public class AIPitcher : MonoBehaviour
	{
		private Animator gAnimator;

		private static AIPitcher instance;

		public GameObject BallPF;

		private Transform StartTrs;

		private Transform EndTrs;

		private Transform RHandTrs;

		private int throwCount;

		public static AIPitcher GetInstance()
		{
			return instance;
		}

		private void Start()
		{
			instance = this;
			gAnimator = GetComponent<Animator>();
			RHandTrs = base.transform.GetChild(0).GetChild(1).GetChild(0)
				.GetChild(0)
				.GetChild(0)
				.GetChild(2)
				.GetChild(0)
				.GetChild(0)
				.GetChild(0)
				.GetChild(2);
		}

		public void SetDataPitcher(GameObject BallPrefab)
		{
			BallPF = BallPrefab;
		}

		public void ThrowBall()
		{
			StartCoroutine(Throw());
		}

		public void GameEnd()
		{
			StopAllCoroutines();
		}

		private IEnumerator Throw()
		{
			yield return YieldInstructionCache.WaitForSeconds(1f);
			gAnimator.SetTrigger("Ready");
			FirePowerCheck();
			yield return YieldInstructionCache.WaitForSeconds(2f);
			gAnimator.SetTrigger("Throw");
			yield return YieldInstructionCache.WaitForSeconds(2.25f);
			BallSpeedSet();
		}

		private void BallSpeedSet()
		{
			Vector3 revisePos = new Vector3(0f, 1.2f, 52.43f);
			Vector3 BallVel = Vector3.zero;
			float num = RHandTrs.position.z - 52.43f;
			float hitDtValue = (RHandTrs.position.z - 50.7f) / num;
			float num2 = 0f;
			GameObject gameObject = UnityEngine.Object.Instantiate(BallPF, RHandTrs.position, Quaternion.identity);
			Vector2 HitPos;
			if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				throwCount++;
				int num3 = 0;
				num2 = UnityEngine.Random.Range(7f, 10f + (float)throwCount * 0.3f);
				revisePos.x += UnityEngine.Random.Range(-0.2f, 0.2f);
				revisePos.y += UnityEngine.Random.Range(-0.2f, 0.15f);
				num3 = ((throwCount % 4 == 0 && throwCount != 4) ? 4 : ((5 < throwCount) ? ((UnityEngine.Random.Range(0f, 1f) < 0.3f) ? UnityEngine.Random.Range(1, 4) : 0) : 0));
				gameObject.GetComponent<BallMove>().ThrowBallType(num3, RHandTrs.position, revisePos, out BallVel, num2, hitDtValue, out HitPos);
				if (num3 == 4)
				{
					BaseballManager.GetInstance().Call_PlaySound(SoundTrack.FireBall);
				}
				else
				{
					BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Throw);
				}
			}
			else if (CsGameData.Instance.curMode == GameMode.SBOMode)
			{
				int num4 = 0;
				num2 = 7f;
				throwCount++;
				if (throwCount == 7 || throwCount == 10)
				{
					num4 = 4;
				}
				else if (10 < throwCount && (throwCount - 2) % 4 == 0)
				{
					num4 = 4;
				}
				if (num4 == 4)
				{
					BaseballManager.GetInstance().Call_PlaySound(SoundTrack.FireBall);
				}
				else
				{
					BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Throw);
				}
				if (UnityEngine.Random.Range(0f, 1f) < 0.8f - (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f || num4 == 4)
				{
					revisePos.x += UnityEngine.Random.Range((float)(-SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level) * 0.12f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.12f);
					revisePos.y += UnityEngine.Random.Range((float)(-SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level) * 0.12f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.12f);
				}
				else
				{
					revisePos.x += UnityEngine.Random.Range(1.9f, 2f) - UnityEngine.Random.Range(0f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f);
					revisePos.y += UnityEngine.Random.Range((float)(-SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level) * 0.12f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.12f);
					if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
					{
						revisePos.x = 0f - revisePos.x;
					}
				}
				if (num4 != 4)
				{
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level < 3)
					{
						num4 = UnityEngine.Random.Range(0, 2);
						num2 = UnityEngine.Random.Range(6f, 6f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 2f);
					}
					else
					{
						num4 = UnityEngine.Random.Range(0, 4);
						num2 = ((!(UnityEngine.Random.Range(0f, 1f) < 0.8f)) ? UnityEngine.Random.Range(4f, 6f) : UnityEngine.Random.Range(6f, 6f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 2f));
					}
				}
				gameObject.GetComponent<BallMove>().ThrowBallType(num4, RHandTrs.position, revisePos, out BallVel, num2, hitDtValue, out HitPos);
			}
			gameObject.GetComponent<Rigidbody>().velocity = BallVel;
			gameObject.GetComponent<SphereCollider>().enabled = true;
			gameObject.GetComponent<BallMove>().Call_CatcherHandCorou();
			CbatFollower.GetInstance().swing = false;
		}

		private void FirePowerCheck()
		{
			if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				if ((throwCount + 1) % 4 == 0 && throwCount + 1 != 4)
				{
					BaseballManager.GetInstance().Call_FirePower();
				}
			}
			else if (CsGameData.Instance.curMode == GameMode.SBOMode)
			{
				if (throwCount + 1 == 7 || throwCount + 1 == 10)
				{
					BaseballManager.GetInstance().Call_FirePower();
				}
				else if (10 < throwCount + 1 && (throwCount + 1 - 2) % 4 == 0)
				{
					BaseballManager.GetInstance().Call_FirePower();
				}
			}
		}

		public int GetThrowCount()
		{
			return throwCount;
		}
	}
	public class AutoHandCont : MonoBehaviour
	{
		public Transform HeadTrs;

		public Transform RightTrs;

		public Transform HeadChildTrs;

		public float angle;

		public Text AngleText;

		public Text BallText;

		private void Update()
		{
			Vector3 forward = HeadTrs.forward;
			forward.Normalize();
			Vector3 to = RightTrs.position - HeadTrs.position;
			angle = Vector3.Angle(forward, to);
			if (95f < angle)
			{
				if (BallMove.GetInstance() != null)
				{
					float num = HeadTrs.position.y * 0.5f;
					float num2 = num;
					num2 += (BallMove.GetInstance().checkY - num) * 0.8f;
					Vector3 vector = HeadChildTrs.position - HeadTrs.position;
					vector.y = 0f;
					Vector3 position = HeadTrs.position + vector.normalized * 2.6f;
					position.y = num2;
					RightTrs.position = position;
					AngleText.text = angle.ToString();
					Text angleText = AngleText;
					angleText.text = angleText.text + "\n" + RightTrs.localPosition.ToString();
				}
				else
				{
					UnityEngine.Debug.Log("is NULL");
				}
			}
			if (BallMove.GetInstance() != null && BallMove.GetInstance().GetComponent<Rigidbody>().velocity != Vector3.zero)
			{
				BallText.text = BallMove.GetInstance().GetComponent<Rigidbody>().velocity.ToString();
				BallText.text = "\n" + BallMove.GetInstance().GetComponent<Rigidbody>().velocity.magnitude;
			}
		}
	}
	public enum Throw
	{
		None,
		Strike,
		Ball
	}
	public enum BallCatchType
	{
		None,
		Fly,
		NoBound,
		Bound,
		Foul
	}
	public class BallMove : MonoBehaviour
	{
		private static BallMove instance;

		public Throw curThrow;

		public BallCatchType curType;

		public GameObject[] projectileParticle;

		public Material[] Mat;

		public GameObject ParticleTrail;

		public bool reckoning = true;

		public bool hitDecide;

		public bool hit;

		public bool hitGroundCheck;

		public bool foul;

		public bool bound;

		public bool homerun;

		public bool multiHomerunCheck;

		public bool fence;

		public bool deadball;

		public bool curFenceHit;

		public bool homerun_BoundOut;

		public bool homerun_FlyOut;

		public bool flyOutPlay;

		public float flyOutPlayTime;

		public Vector3 FencePos = Vector3.zero;

		public int balltype;

		public float xReviseValue;

		private IEnumerator Corou_IEnumCatcher;

		private bool destroy;

		private Vector2 AddForceVec = Vector2.zero;

		public float checkX;

		public float checkY;

		public string Tempstr = "";

		private IEnumerator Corou_AddForce;

		public Vector3 OnePreVel = Vector3.zero;

		public static BallMove GetInstance()
		{
			return instance;
		}

		private void Awake()
		{
			instance = this;
		}

		public void CreateParticleTrail(int _paricle = 0)
		{
			ParticleTrail = UnityEngine.Object.Instantiate(projectileParticle[_paricle], base.transform.position, base.transform.rotation);
			ParticleTrail.transform.parent = base.transform;
			if (_paricle == 1)
			{
				base.transform.Find("newBall").GetComponent<MeshRenderer>().material = Mat[1];
			}
		}

		public void RemoveParticleTrail()
		{
			if ((bool)ParticleTrail)
			{
				UnityEngine.Object.Destroy(ParticleTrail);
			}
		}

		public void Call_CatcherHandCorou()
		{
			Corou_IEnumCatcher = IEnumCatcher();
			StartCoroutine(Corou_IEnumCatcher);
		}

		public void Call_StopCatcher()
		{
			if (Corou_IEnumCatcher != null)
			{
				StopCoroutine(Corou_IEnumCatcher);
			}
		}

		private IEnumerator IEnumCatcher()
		{
			yield return YieldInstructionCache.WaitForSeconds(0.05f);
			while (!hit && GetComponent<Rigidbody>().velocity.z != 0f)
			{
				BaseballManager.GetInstance().Call_CatcherMovement(GetComponent<Rigidbody>().velocity, base.transform.position, AddForceVec);
				yield return YieldInstructionCache.WaitForSeconds(0.05f);
			}
		}

		private void OnCollisionEnter(Collision coll)
		{
			if (coll.gameObject.tag != "Bat")
			{
				BaseballManager.GetInstance().Call_ThrowBallDecide(coll.gameObject.tag);
			}
		}

		private void OnTriggerEnter(Collider coll)
		{
			if (coll.gameObject.tag != "Bat")
			{
				BaseballManager.GetInstance().Call_ThrowBallDecide(coll.gameObject.tag);
			}
		}

		public void BallDestroy(float dt)
		{
			if (!destroy)
			{
				destroy = true;
				StartCoroutine(CorouDestroy(dt));
			}
		}

		public void HomerunBallDestroy(float dt)
		{
			destroy = true;
			StopAllCoroutines();
			StartCoroutine(CorouDestroy(dt));
		}

		private IEnumerator CorouDestroy(float dt)
		{
			yield return YieldInstructionCache.WaitForSeconds(dt);
			BaseballManager.GetInstance().ThrowReset();
			yield return null;
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void BallStop()
		{
			GetComponent<Rigidbody>().useGravity = false;
			GetComponent<Rigidbody>().velocity = Vector3.zero;
		}

		public bool GetHitDecide()
		{
			if (foul || bound || homerun)
			{
				return true;
			}
			return false;
		}

		public Vector2 GetVecAddForce()
		{
			return AddForceVec;
		}

		public void ThrowBallType(int _select, Vector3 BallStartPos, Vector3 RevisePos, out Vector3 BallVel, float _zPower, float _hitDtValue, out Vector2 HitPos)
		{
			HitPos = default(Vector2);
			if (BallStartPos == new Vector3(0f, 3f, 0f))
			{
				curThrow = Throw.Strike;
				CreateParticleTrail();
				RevisePos = new Vector3(0f, 1.6f, 52f);
				Vector3 shotVelocityAtoB = CsPhysics.getShotVelocityAtoB(BallStartPos, RevisePos, 1f);
				GetComponent<Rigidbody>().velocity = shotVelocityAtoB;
				BallVel = shotVelocityAtoB;
				return;
			}
			Vector3 zero = Vector3.zero;
			Vector3 angularVelocity = Vector3.zero;
			float num = 0f;
			float num2 = 0.04f;
			if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				_zPower = CsHandRigid.GetInstance().GetVel().magnitude - 24f;
				if (_zPower < 1f)
				{
					_zPower = 1f;
				}
				num2 = 0.029f;
			}
			_ = CsGameData.Instance.curMode;
			if (4f < RevisePos.x)
			{
				RevisePos.x = 4f;
			}
			else if (RevisePos.x < -4f)
			{
				RevisePos.x = -4f;
			}
			curThrow = Throw.Strike;
			if (RevisePos.y < 0.5f)
			{
				RevisePos.y = 0.5f;
			}
			else if (3.65f < RevisePos.y)
			{
				RevisePos.y = 3.65f;
			}
			float num3 = 8f;
			float num4 = 9f;
			if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				if (AIPitcher.GetInstance().GetThrowCount() < 7)
				{
					num4 += 3f;
				}
				else if (AIPitcher.GetInstance().GetThrowCount() < 10)
				{
					num3 += 5f;
					num4 += 5f;
				}
				else if (10f < _zPower)
				{
					num3 += 7f;
					num4 += 7f;
				}
				else
				{
					num3 += 3f;
					num4 += 5f;
				}
			}
			switch (_select)
			{
			case 0:
				num = 1.32f - _zPower * num2;
				if (num < 0.6f)
				{
					num = 0.6f;
				}
				AddForceVec = Vector2.zero;
				angularVelocity = new Vector3(3f, 0f, 0f);
				break;
			case 1:
				num = 1.44f - _zPower * num2;
				if (num < 0.6f)
				{
					num = 0.6f;
				}
				AddForceVec.x = 0f;
				AddForceVec.y = (0f - num4) / (num * num);
				angularVelocity = new Vector3(6f, 0f, 0f);
				break;
			case 2:
				num = 1.44f - _zPower * num2;
				if (num < 0.6f)
				{
					num = 0.6f;
				}
				AddForceVec.x = (0f - num3) / (num * num);
				AddForceVec.y = 0f;
				angularVelocity = new Vector3(0f, -6f, 0f);
				break;
			case 3:
				num = 1.44f - _zPower * num2;
				if (num < 0.6f)
				{
					num = 0.6f;
				}
				AddForceVec.x = num3 / (num * num);
				AddForceVec.y = 0f;
				angularVelocity = new Vector3(0f, 6f, 0f);
				break;
			case 4:
				if (CsGameData.Instance.curTeam == TeamPosition.Defense)
				{
					num = 0.5f;
				}
				else if (CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					num = 0.5f;
				}
				AddForceVec = Vector2.zero;
				break;
			}
			UnityEngine.Debug.Log("dt : " + num);
			UnityEngine.Debug.Log("ballEndPos.x : " + RevisePos.x);
			UnityEngine.Debug.Log("_zPower * powerValue : " + _zPower * num2);
			Tempstr = num + " " + _zPower * num2;
			if (_select == 4)
			{
				CreateParticleTrail(1);
			}
			else
			{
				CreateParticleTrail();
			}
			Corou_AddForce = AddForce(AddForceVec.x, AddForceVec.y);
			StartCoroutine(Corou_AddForce);
			zero = CsPhysics.getShotVelocityAtoB(BallStartPos, RevisePos, num, AddForceVec.x, AddForceVec.y);
			float num5 = num * _hitDtValue;
			float num6 = BallStartPos.x + zero.x * num5 + 0.5f * AddForceVec.x * (num5 * num5);
			float num7 = BallStartPos.y + zero.y * num5 + 0.5f * (CsGameData.Instance._gravity + AddForceVec.y) * (num5 * num5);
			float num8 = BallStartPos.y + zero.y * num + 0.5f * (CsGameData.Instance._gravity + AddForceVec.y) * (num * num);
			checkX = num6;
			checkY = num7;
			if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				StartCoroutine(SeeBallPos(Pos: new Vector3(num6, num7, 50f), dt: num));
			}
			if (1f < Mathf.Abs(num6))
			{
				curThrow = Throw.Ball;
			}
			else if (num7 < 1.1f || 2.7f < num7)
			{
				curThrow = Throw.Ball;
			}
			HitPos = new Vector2(num6, num7);
			UnityEngine.Debug.Log("hitDT" + num5 + "      AddForceVec.y" + AddForceVec.y);
			UnityEngine.Debug.Log(string.Concat("Ballmove ... ", RevisePos, "      ", num6, " ", num7, "    y2 : ", num8));
			GetComponent<Rigidbody>().velocity = zero;
			GetComponent<Rigidbody>().angularVelocity = angularVelocity;
			BallVel = zero;
			balltype = _select;
			xReviseValue = Mathf.Abs(Mathf.Abs(num6) / 3f * 0.3f - 1f);
			if (xReviseValue < 0.7f)
			{
				xReviseValue = 0.7f;
			}
		}

		private IEnumerator SeeBallPos(float dt, Vector3 Pos)
		{
			yield return YieldInstructionCache.WaitForSeconds(dt);
			BaseballManager.GetInstance().SeeBall.gameObject.SetActive(value: true);
			BaseballManager.GetInstance().SeeBall.position = Pos;
		}

		private IEnumerator AddForce(float x_pow, float y_pow)
		{
			float X = x_pow / Time.fixedDeltaTime;
			float Y = y_pow / Time.fixedDeltaTime;
			_ = Vector3.zero;
			if (X == 0f && Y == 0f)
			{
				yield return null;
				yield break;
			}
			if (Y != 0f)
			{
				while (true)
				{
					Vector3 force = new Vector3(0f, Y * Time.deltaTime, 0f);
					GetComponent<Rigidbody>().AddForce(force);
					yield return null;
				}
			}
			if (X != 0f)
			{
				while (true)
				{
					Vector3 force = new Vector3(X * Time.deltaTime, 0f, 0f);
					GetComponent<Rigidbody>().AddForce(force);
					yield return null;
				}
			}
		}

		public void MultiBallAddForce(Vector2 Force)
		{
			if (!(Force == Vector2.zero))
			{
				AddForceVec = Force;
				Corou_AddForce = AddForce(AddForceVec.x, AddForceVec.y);
				StartCoroutine(Corou_AddForce);
			}
		}

		public void AddForceCorouStop()
		{
			if (Corou_AddForce != null)
			{
				StopCoroutine(Corou_AddForce);
			}
			AddForceVec = Vector2.zero;
			GetComponent<Rigidbody>().angularVelocity = Vector3.zero;
		}

		private void Update()
		{
			OnePreVel = GetComponent<Rigidbody>().velocity;
		}
	}
	public class BaseballManager : MonoBehaviour
	{
		private enum Cont
		{
			Head,
			HeadChild,
			Right,
			RightChild,
			Left,
			LeftChild
		}

		private static BaseballManager instance;

		[Header("[스크립트들]")]
		public GameObject SideScript;

		private CsSound gSound;

		private CsParticle gParticle;

		private AudioSource Sound;

		private PhotonView pView;

		[Header("[플레이어]")]
		public GameObject PlayerObj;

		public GameObject CameraObj;

		public GameObject RightCont;

		public GameObject LeftCont;

		public Transform RightHandTrs;

		public Transform LeftHandTrs;

		[Header("[게임 내부들]")]
		public GameObject FollowParent;

		private GameObject[] FollowBallFt;

		public Transform BaseParent;

		private Transform[] Base;

		public GameObject FoulLineParent;

		private GameObject[] FoulLine;

		public bool readyCheck;

		public int homerunCount;

		public int currentFeet;

		public int totalFeet;

		public int maxFeet;

		public GameObject FenceCheck_PF;

		private GameObject[] CommercialScreen;

		[Header("[게임 관련]")]
		public Transform PlayerPitcherTrs;

		public Transform PlayerHitterTrs;

		public Transform PlayerHitterTrsLeft;

		public CsHomerun gHomerun;

		public GameObject PlayerCircle;

		public GameObject Help_Pitcher;

		public GameObject Help_Hitter;

		public GameObject Help_Hitter_Fire;

		public Transform[] Help_Hitter_Fire_UI_Trs;

		public GameObject GameContParent;

		public GameObject BetParent;

		public GameObject BetPhysics;

		public GameObject BallImageParent;

		public GameObject cHandThrow;

		public GameObject FirePower;

		[Header("[홈런더비 관련]")]
		public GameObject FeetUI;

		public Text HomerunCountText;

		public Text TotalFeetText;

		public Transform mTrs;

		public Transform[] mPosTrs;

		public GameObject[] OutCountOff;

		public GameObject[] OutCountOn;

		[Header("[SBO 관련]")]
		public CsReferee RefereeAni;

		public bool throwOK;

		public GameObject CatcherCollObj;

		public GameObject FenceColl;

		public GameObject BallPF;

		public Transform BallHitTrs;

		public Transform BallCatchTrs;

		public GameObject SelectParent;

		public GameObject Hitter;

		public GameObject Hitter_R;

		public GameObject Hitter_L;

		public GameObject Hitter_WalkMan;

		private bool AiHitterSwing;

		public int strikeCount;

		public int ballCount;

		public int outCount;

		public int score;

		private int maxInning = 6;

		public GameObject ScorePanel;

		public Text InningText;

		public Text FirstScoreText;

		public Text SecondScoreText;

		public Text StrikeText;

		public Text BallText;

		public Text[] ResultName;

		public GameObject First_TH;

		public GameObject Second_TH;

		public GameObject[] OutObj;

		public GameObject[] BaseObj;

		public Transform ChangeInningTrs;

		public Transform[] UIPosTrs;

		public Transform[] TextUITrs;

		public GameObject TextUIParent;

		public GameObject[] TextUIObjs;

		public GameObject FireBet_UI_Parent;

		public GameObject SeeBallParent;

		public Transform SeeBall;

		[Header("[멀티 관련]")]
		public Transform PlayerPartsParent;

		public Transform OtherPartsParent;

		public Transform[] PartsTrs;

		public Transform[] OtherPartsTrs;

		public GameObject TimeTextBack;

		public Text TimeText;

		public AudioSource gClockAudio;

		public GameObject MultiCharPF;

		public GameObject OtherChar;

		private Transform[] GetOtherPartsData = new Transform[6];

		public GameObject BallImageParent_Other;

		public GameObject BetImage_Other;

		public GameObject BetImage_Normal;

		public GameObject BetImage_Fire;

		[HideInInspector]
		public bool _NorunNohit = true;

		private bool _onlyOneGameEndCall;

		private IEnumerator TimeCorou;

		public Transform TestCube;

		public Text TestText;

		public bool AI_Test_Mode;

		public float AI_Temp_goodWidth;

		public float AI_Temp_badWidth;

		public float AI_Temp_yValue = 0.08f;

		private const float strikeRadius = 1.28f;

		public static BaseballManager GetInstance()
		{
			return instance;
		}

		private void Start()
		{
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomHand();
			instance = this;
			gSound = GetComponent<CsSound>();
			gParticle = GetComponent<CsParticle>();
			Sound = GetComponent<AudioSource>();
			pView = GetComponent<PhotonView>();
			Start_ParentSet();
			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("FadeSphere"), CameraObj.transform);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				CsGameData.Instance.curState = State.Multi;
			}
			else
			{
				CsGameData.Instance.curState = State.Single;
			}
			if (CsGameData.Instance.newGame)
			{
				CsGameData.Instance.SetInit();
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
				{
					CsGameData.Instance.fireBetCount = 3;
				}
				SelectParent.transform.GetChild(1).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.curveCount;
				SelectParent.transform.GetChild(2).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.leftSlideCount;
				SelectParent.transform.GetChild(3).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.rightSlideCount;
				SelectParent.transform.GetChild(4).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.specialCount;
			}
			else
			{
				FirstScoreText.text = CsGameData.Instance.firstScore.ToString();
				SecondScoreText.text = CsGameData.Instance.secondScore.ToString();
				SelectParent.transform.GetChild(1).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.curveCount;
				SelectParent.transform.GetChild(2).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.leftSlideCount;
				SelectParent.transform.GetChild(3).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.rightSlideCount;
				SelectParent.transform.GetChild(4).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.specialCount;
				if (CsGameData.Instance.curveCount == 0)
				{
					SelectParent.transform.GetChild(1).gameObject.SetActive(value: false);
				}
				if (CsGameData.Instance.leftSlideCount == 0)
				{
					SelectParent.transform.GetChild(2).gameObject.SetActive(value: false);
				}
				if (CsGameData.Instance.rightSlideCount == 0)
				{
					SelectParent.transform.GetChild(3).gameObject.SetActive(value: false);
				}
				if (CsGameData.Instance.specialCount == 0)
				{
					SelectParent.transform.GetChild(4).gameObject.SetActive(value: false);
				}
			}
			if (CsGameData.Instance.curState == State.Single)
			{
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 1)
				{
					CsGameData.Instance.curMode = GameMode.HomerunMode;
					CsGameData.Instance.curTeam = TeamPosition.Offense;
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Mode == 2)
				{
					CsGameData.Instance.curMode = GameMode.SBOMode;
				}
				OtherPartsParent.gameObject.SetActive(value: false);
			}
			else if (CsGameData.Instance.curState == State.Multi)
			{
				if (CsGameData.Instance.newGame)
				{
					if (PhotonNetwork.IsMasterClient)
					{
						CsGameData.Instance.curTeam = TeamPosition.Defense;
					}
					else
					{
						CsGameData.Instance.curTeam = TeamPosition.Offense;
					}
					CsGameData.Instance.curMode = GameMode.SBOMode;
				}
				SideScript.GetComponent<CsExit>().enabled = true;
				OtherChar = UnityEngine.Object.Instantiate(MultiCharPF);
				OtherChar.GetComponent<CustomModelSettingCtrl>().Init(GetOtherId(), CustomModelViewState.HalfCut2);
				OtherChar.transform.localScale = new Vector3(2.7f, 2.7f, 2.7f);
				if (CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					OtherChar.transform.position = PlayerPitcherTrs.position;
					OtherChar.transform.eulerAngles = PlayerPitcherTrs.eulerAngles;
					SideScript.GetComponent<CsFollow>().enabled = true;
					SideScript.GetComponent<CsFollow>().SetActiveObj(_bool: true);
				}
				else if (CsGameData.Instance.curTeam == TeamPosition.Defense)
				{
					OtherChar.transform.position = PlayerHitterTrs.position;
					OtherChar.transform.eulerAngles = PlayerHitterTrs.eulerAngles;
					BetImage_Other.SetActive(value: true);
					TimeTextBack.SetActive(value: true);
					CsGameData.Instance.ballCheck = true;
					CsGameData.Instance.TimeTictok = false;
				}
				OtherChar.GetComponent<VRIK>().enabled = true;
				OtherChar.GetComponent<VRIK>().solver.spine.headTarget = OtherPartsTrs[1];
				OtherChar.GetComponent<VRIK>().solver.rightArm.target = OtherPartsTrs[3];
				OtherChar.GetComponent<VRIK>().solver.leftArm.target = OtherPartsTrs[5];
				for (int i = 0; i < GetOtherPartsData.Length; i++)
				{
					GetOtherPartsData[i] = UnityEngine.Object.Instantiate(new GameObject()).transform;
				}
			}
			if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				BetParent.SetActive(value: true);
				BetPhysics.SetActive(value: true);
				SetPlayerHand(PublicGameUIManager.gameSetting.IsRightHanded());
				SelectParent.SetActive(value: false);
				ScorePanel.SetActive(value: false);
				Help_Hitter.SetActive(value: true);
				FireBet_UI_Parent.SetActive(value: false);
			}
			else if (CsGameData.Instance.curMode == GameMode.SBOMode)
			{
				FeetUI.SetActive(value: false);
				InningText.text = (CsGameData.Instance.inning - 1) / 2 + 7 + "th";
				SideScript.GetComponent<CsScoreBoardUI>().ActiveDepth(1);
				SideScript.GetComponent<CsScoreBoardUI>().PlayerNameSet();
				SideScript.GetComponent<CsScoreBoardUI>().InningSet();
				SideScript.GetComponent<CsScoreBoardUI>().UIPosAndAngle(change: false);
				CsBonus.GetInstance().gameObject.SetActive(value: false);
				if (CsGameData.Instance.curTeam == TeamPosition.Defense)
				{
					cHandThrow.SetActive(value: true);
					SetPlayerHand(PublicGameUIManager.gameSetting.IsRightHanded());
					PlayerObj.transform.position = new Vector3(0f, -3f, 0f);
					PlayerObj.transform.eulerAngles = PlayerPitcherTrs.eulerAngles;
					ScorePanel.transform.position = UIPosTrs[0].position;
					ScorePanel.transform.eulerAngles = UIPosTrs[0].eulerAngles;
					ScorePanel.transform.localScale = UIPosTrs[0].localScale;
					TextUIParent.transform.SetPositionAndRotation(TextUITrs[0].position, TextUITrs[0].rotation);
					ScorePanel.SetActive(value: true);
					if (CsGameData.Instance.curState == State.Single)
					{
						First_TH.SetActive(value: true);
					}
					else if (CsGameData.Instance.curState == State.Multi)
					{
						if (PhotonNetwork.IsMasterClient)
						{
							First_TH.SetActive(value: true);
						}
						else
						{
							Second_TH.SetActive(value: true);
						}
						OtherPartsParent.gameObject.SetActive(value: true);
					}
					SelectParent.SetActive(value: true);
					Help_Pitcher.SetActive(value: true);
					PlayerCircle.transform.localPosition = new Vector3(0f, 0.234f, 0f);
					OtherPartsParent.transform.position = new Vector3(0f, 0f, 48f);
					FireBet_UI_Parent.SetActive(value: false);
					if (CsGameData.Instance.curState == State.Single)
					{
						SideScript.GetComponent<CsOutAniOnOff>().Call_StartGameAni();
					}
				}
				else if (CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					BetParent.SetActive(value: true);
					BetPhysics.SetActive(value: true);
					SetPlayerHand(PublicGameUIManager.gameSetting.IsRightHanded());
					TextUIParent.transform.SetPositionAndRotation(TextUITrs[1].position, TextUITrs[1].rotation);
					if (CsGameData.Instance.curState == State.Single)
					{
						Second_TH.SetActive(value: true);
					}
					else if (CsGameData.Instance.curState == State.Multi)
					{
						if (PhotonNetwork.IsMasterClient)
						{
							Second_TH.SetActive(value: true);
						}
						else
						{
							First_TH.SetActive(value: true);
						}
					}
					SelectParent.SetActive(value: false);
					ScorePanel.SetActive(value: true);
					FireBet_UI_Parent.SetActive(value: true);
					Help_Hitter_Fire.SetActive(value: true);
				}
				ResultName[0].text = GetFirstNick();
				ResultName[1].text = GetSecondNick();
			}
			StartCoroutine(StartDelay());
			PublicGameUIManager.GetInstance.AddReplayEvent(delegate
			{
				Restart();
			});
			PublicGameUIManager.GetInstance.AddLoadLobbyEvent(delegate
			{
				Return();
			});
			PublicGameUIManager.gameSetting.AddHandChangedEvent(ChangeHand);
		}

		public void ChangeHand(bool isRight)
		{
			SetPlayerHand(isRight);
		}

		private void SetPlayerHand(bool isRight)
		{
			if (isRight)
			{
				CsHandRigid.GetInstance().Call_ChangeHand_Right();
			}
			else
			{
				CsHandRigid.GetInstance().Call_ChangeHand_Left();
			}
			if (CsGameData.Instance.curTeam == TeamPosition.Offense)
			{
				CbatFollower.GetInstance().CallIsRightSet(isRight);
				if (isRight)
				{
					PlayerObj.transform.position = PlayerHitterTrs.position;
					PlayerObj.transform.eulerAngles = PlayerHitterTrs.eulerAngles;
					GameContParent.transform.SetParent(RightHandTrs.transform);
					GameContParent.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.pos;
					GameContParent.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.rot;
					Help_Hitter_Fire.transform.position = Help_Hitter_Fire_UI_Trs[0].transform.position;
					Help_Hitter_Fire.transform.rotation = Help_Hitter_Fire_UI_Trs[0].transform.rotation;
					RightHandTrs.GetComponent<Animator>().SetTrigger("Grab");
					LeftHandTrs.GetComponent<Animator>().SetTrigger("Idle");
					if (CsGameData.Instance.curMode == GameMode.SBOMode)
					{
						ScorePanel.transform.position = UIPosTrs[1].position;
						ScorePanel.transform.eulerAngles = UIPosTrs[1].eulerAngles;
						ScorePanel.transform.localScale = UIPosTrs[1].localScale;
					}
					UnityEngine.Debug.Log("");
				}
				else
				{
					PlayerObj.transform.position = PlayerHitterTrsLeft.position;
					PlayerObj.transform.eulerAngles = PlayerHitterTrsLeft.eulerAngles;
					GameContParent.transform.SetParent(LeftHandTrs.transform);
					GameContParent.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.pos;
					GameContParent.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.rot;
					RightHandTrs.GetComponent<Animator>().SetTrigger("Idle");
					LeftHandTrs.GetComponent<Animator>().SetTrigger("Grab");
					Help_Hitter_Fire.transform.position = Help_Hitter_Fire_UI_Trs[1].transform.position;
					Help_Hitter_Fire.transform.rotation = Help_Hitter_Fire_UI_Trs[1].transform.rotation;
					Help_Hitter.transform.localPosition = new Vector3(-2.104f, 1.703f, 0f);
					Help_Hitter.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
					if (CsGameData.Instance.curMode == GameMode.SBOMode)
					{
						ScorePanel.transform.position = UIPosTrs[2].position;
						ScorePanel.transform.eulerAngles = UIPosTrs[2].eulerAngles;
						ScorePanel.transform.localScale = UIPosTrs[2].localScale;
					}
				}
			}
			else if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				if (isRight)
				{
					Vector3 localPosition = BallImageParent.transform.localPosition;
					localPosition.x = 0f - Mathf.Abs(localPosition.x);
					BallImageParent.transform.localPosition = localPosition;
					GameContParent.transform.SetParent(RightHandTrs.transform);
				}
				else
				{
					Vector3 localPosition2 = BallImageParent.transform.localPosition;
					localPosition2.x = Mathf.Abs(localPosition2.x);
					BallImageParent.transform.localPosition = localPosition2;
					GameContParent.transform.SetParent(LeftHandTrs.transform);
				}
				GameContParent.transform.localPosition = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.pos;
				GameContParent.transform.localRotation = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomGrabAnything.rot;
			}
			if (CsGameData.Instance.curState == State.Multi)
			{
				Vector3[] array = new Vector3[1];
				if (isRight)
				{
					array[0].x = 13f;
				}
				else
				{
					array[0].x = 14f;
				}
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
			}
		}

		private void Start_ParentSet()
		{
			FollowBallFt = new GameObject[6];
			for (int i = 0; i < 6; i++)
			{
				FollowBallFt[i] = FollowParent.transform.GetChild(i).gameObject;
			}
			Base = new Transform[7];
			for (int j = 0; j < 7; j++)
			{
				Base[j] = BaseParent.GetChild(j);
			}
			FoulLine = new GameObject[3];
			for (int k = 0; k < 3; k++)
			{
				FoulLine[k] = FoulLineParent.transform.GetChild(k).gameObject;
			}
		}

		private IEnumerator StartDelay()
		{
			yield return null;
			Physics.gravity = new Vector3(0f, CsGameData.Instance._gravity, 0f);
			if (CsGameData.Instance.curState == State.Multi || CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				DefenderManager.GetInstance().Defender[8].SetActive(value: false);
			}
			if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				PlayerObj.transform.position = PlayerPitcherTrs.position;
			}
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			if (CsGameData.Instance.curState == State.Multi)
			{
				while (OtherPartsTrs[0].transform.position == Vector3.zero)
				{
					yield return YieldInstructionCache.WaitForSeconds(0.1f);
				}
				Vector3[] array = new Vector3[1];
				if (PublicGameUIManager.gameSetting.IsRightHanded())
				{
					array[0].x = 13f;
				}
				else
				{
					array[0].x = 14f;
				}
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
			}
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
			if (CsGameData.Instance.curState == State.Single)
			{
				readyCheck = true;
				throwOK = true;
			}
		}

		private void Restart()
		{
			CsGameData.Instance.newGame = true;
			SceneManager.LoadScene("Scene_Game_BaseBall");
		}

		private void Return()
		{
			CsGameData.Instance.newGame = true;
			Physics.gravity = new Vector3(0f, -9.81f, 0f);
		}

		private void FF()
		{
			string[] arr_subScore = new string[8] { "Level", "1", "미션", "1000m", null, null, null, null };
			PublicGameUIManager.GetInstance.OpenResultBoard("100", arr_subScore);
			arr_subScore = new string[2] { "1번 점수", "2번 점수" };
			PublicGameUIManager.GetInstance.OpenResultBoard(arr_subScore, 0);
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
		}

		private void Update()
		{
			if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				if (CsGameData.Instance.curTeam == TeamPosition.Offense && readyCheck)
				{
					readyCheck = false;
					if (outCount < 3)
					{
						AIPitcher.GetInstance().ThrowBall();
					}
				}
			}
			else
			{
				if (CsGameData.Instance.curMode != GameMode.SBOMode)
				{
					return;
				}
				if (CsGameData.Instance.curState == State.Single && CsGameData.Instance.curTeam == TeamPosition.Offense && readyCheck)
				{
					readyCheck = false;
					if (outCount < 3)
					{
						AIPitcher.GetInstance().ThrowBall();
					}
				}
				else
				{
					if (CsGameData.Instance.curState != State.Multi)
					{
						return;
					}
					if (OtherChar != null)
					{
						Vector3[] array = new Vector3[6]
						{
							CameraObj.transform.position,
							CameraObj.transform.eulerAngles,
							RightCont.transform.position,
							RightCont.transform.eulerAngles,
							LeftCont.transform.position,
							LeftCont.transform.eulerAngles
						};
						pView.RPC("RPC_StreamPos_Baseball", RpcTarget.Others, array);
						OtherPartsTrs[0].position = Vector3.Lerp(OtherPartsTrs[0].position, GetOtherPartsData[0].position, 0.1f);
						OtherPartsTrs[0].rotation = Quaternion.Lerp(OtherPartsTrs[0].rotation, GetOtherPartsData[1].rotation, 0.1f);
						OtherPartsTrs[2].position = Vector3.Lerp(OtherPartsTrs[2].position, GetOtherPartsData[2].position, 0.1f);
						OtherPartsTrs[2].rotation = Quaternion.Lerp(OtherPartsTrs[2].rotation, GetOtherPartsData[3].rotation, 0.1f);
						OtherPartsTrs[4].position = Vector3.Lerp(OtherPartsTrs[4].position, GetOtherPartsData[4].position, 0.1f);
						OtherPartsTrs[4].rotation = Quaternion.Lerp(OtherPartsTrs[4].rotation, GetOtherPartsData[5].rotation, 0.1f);
					}
					if (CsGameData.Instance.curTeam != TeamPosition.Defense || !CsGameData.Instance.ballCheck)
					{
						return;
					}
					CsGameData.Instance.timeStack += Time.deltaTime;
					TimeText.text = ((int)(20f - CsGameData.Instance.timeStack)).ToString();
					if (14f < CsGameData.Instance.timeStack && !CsGameData.Instance.TimeTictok)
					{
						CsGameData.Instance.TimeTictok = true;
						gClockAudio.PlayOneShot(gSound.SoundVarious[52]);
					}
					if (20f < CsGameData.Instance.timeStack)
					{
						CsGameData.Instance.timeStack = 0f;
						CsGameData.Instance.gameFoulCount++;
						CsGameData.Instance.TimeTictok = false;
						gClockAudio.Stop();
						if (CsGameData.Instance.gameFoulCount == 2)
						{
							Vector3[] array2 = new Vector3[1];
							array2[0].x = 15f;
							pView.RPC("RPC_AllData", RpcTarget.All, array2);
							CsGameData.Instance.ballCheck = false;
						}
						else
						{
							Vector3[] array3 = new Vector3[1];
							array3[0].x = 16f;
							pView.RPC("RPC_AllData", RpcTarget.All, array3);
						}
					}
				}
			}
		}

		public void Call_CatcherMovement(Vector3 ThrowBallVelocity, Vector3 ThrowBallPosition, Vector2 BallForce)
		{
			Vector3 position = AICatcher.GetInstance().pTargetAimCircle.transform.position;
			Vector3 position2 = AICatcher.GetInstance().pCatcherPoint.transform.position;
			float num = (position.z - ThrowBallPosition.z) / ThrowBallVelocity.z;
			float x = ThrowBallPosition.x + ThrowBallVelocity.x * num + 0.5f * BallForce.x * (num * num);
			float y = ThrowBallPosition.y + ThrowBallVelocity.y * num + 0.5f * (CsGameData.Instance._gravity + BallForce.y) * (num * num);
			AICatcher.GetInstance().CatcherMovement(new Vector3(x, y, position2.z));
		}

		public void Call_FirePower()
		{
			StartCoroutine(Corou_FirePower());
		}

		private IEnumerator Corou_FirePower()
		{
			FirePower.SetActive(value: true);
			Call_PlaySound(SoundTrack.FirePower);
			yield return YieldInstructionCache.WaitForSeconds(2f);
			FirePower.SetActive(value: false);
		}

		public void ThrowReset()
		{
			StartCoroutine(DelayReset());
		}

		private IEnumerator DelayReset()
		{
			readyCheck = true;
			throwOK = true;
			DefenderManager.GetInstance().Reset();
			if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				if (2 < outCount)
				{
					GameEnd();
				}
				else
				{
					currentFeet = 0;
					CsGameData.Instance.numMultiple = 1;
					for (int i = 0; i < 4; i++)
					{
						FollowBallFt[i].SetActive(value: false);
					}
					FollowParent.SetActive(value: false);
					TotalFeetText.text = totalFeet.ToString();
					HomerunCountText.text = homerunCount.ToString();
					if (totalFeet < 10)
					{
						mTrs.position = mPosTrs[0].position;
					}
					else if (totalFeet < 100)
					{
						mTrs.position = mPosTrs[1].position;
					}
					else if (totalFeet < 1000)
					{
						mTrs.position = mPosTrs[2].position;
					}
					else if (totalFeet < 10000)
					{
						mTrs.position = mPosTrs[3].position;
					}
					FenceColl.SetActive(value: true);
					CbatFollower.GetInstance().SetSphereCollEnabled(_bool: true);
					HomerunGameSetOutCount();
					if (CsGameData.Instance.curBonus == Bonus.FireBat)
					{
						CbatFollower.GetInstance().ItemFireBat();
					}
					CsGameData.Instance.curBonus = Bonus.None;
					CsBonus.GetInstance().SetRandomBonus();
					CsBonus.GetInstance().SetRandomPos();
				}
			}
			else if (CsGameData.Instance.curMode == GameMode.SBOMode)
			{
				if (BallMove.GetInstance().hit)
				{
					if (!BallMove.GetInstance().foul)
					{
						Call_SBOReset();
					}
					DefenderManager.GetInstance().ResultScoreCheck();
				}
				if (2 < outCount)
				{
					GameEnd();
				}
				else if (CsGameData.Instance.curTeam == TeamPosition.Offense && CsGameData.Instance.inning == maxInning && CsGameData.Instance.firstScore < CsGameData.Instance.secondScore)
				{
					GameEnd();
					readyCheck = false;
				}
				else if (6 < Mathf.Abs(CsGameData.Instance.firstScore - CsGameData.Instance.secondScore))
				{
					GameEnd();
					readyCheck = false;
				}
				else
				{
					DefenderManager.GetInstance().SBOReset();
					FenceColl.SetActive(value: true);
					if (CsGameData.Instance.curTeam == TeamPosition.Defense)
					{
						if (CsGameData.Instance.curState == State.Single)
						{
							Hitter.GetComponent<CapsuleCollider>().enabled = true;
							Hitter.GetComponent<Animator>().SetTrigger("Idle");
							if (!SideScript.GetComponent<CsOutAniOnOff>().GetBoolAni())
							{
								Hitter.SetActive(value: true);
								Hitter.GetComponent<CustomModelSettingCtrl>().enabled = true;
								Hitter.GetComponent<CustomModelSettingCtrl>().Init(DefenderManager.GetInstance().customModelData);
							}
							AiHitterSwing = false;
							CatcherCollObj.SetActive(value: true);
						}
						DefenderManager.GetInstance().Defender[8].SetActive(value: false);
						SelectParent.SetActive(value: true);
						SeeBallParent.SetActive(value: false);
						SeeBall.gameObject.SetActive(value: false);
						CsGameData.Instance.ballCheck = true;
						if (0 < DefenderManager.GetInstance().ListOffense.Count)
						{
							_NorunNohit = false;
						}
					}
					else if (CsGameData.Instance.curTeam == TeamPosition.Offense)
					{
						CbatFollower.GetInstance().SetSphereCollEnabled(_bool: true);
						if (CsGameData.Instance.curState == State.Multi)
						{
							DefenderManager.GetInstance().Defender[8].SetActive(value: false);
						}
					}
					if (CsGameData.Instance.curState == State.Multi)
					{
						MultiCharActive(_bool: true);
						BetImage_Normal.SetActive(value: true);
						BetImage_Fire.SetActive(value: false);
					}
					StrikeText.text = strikeCount.ToString();
					BallText.text = ballCount.ToString();
					for (int j = 0; j < outCount; j++)
					{
						if (j < 3)
						{
							OutObj[j].SetActive(value: true);
						}
					}
					for (int k = 1; k < BaseObj.Length; k++)
					{
						BaseObj[k].SetActive(value: false);
					}
					for (int l = 0; l < DefenderManager.GetInstance().ListOffense.Count; l++)
					{
						BaseObj[DefenderManager.GetInstance().ListOffense[l].GetComponent<CsOffense>().curBase].SetActive(value: true);
					}
					FirstScoreText.text = CsGameData.Instance.firstScore.ToString();
					SecondScoreText.text = CsGameData.Instance.secondScore.ToString();
				}
			}
			AICatcher.GetInstance().StopAllCoroutines();
			AICatcher.GetInstance().CatcherIdle();
			yield return null;
			if (outCount < 3)
			{
				StopAllCoroutines();
			}
		}

		public void ScoreUIAction(int depth)
		{
		}

		private void GameEnd()
		{
			if (_onlyOneGameEndCall)
			{
				return;
			}
			_onlyOneGameEndCall = true;
			if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				HomerunGameSetOutCount();
				string[] array = new string[6]
				{
					GameSettingCtrl.GetLocalizationText("0080"),
					homerunCount.ToString(),
					GameSettingCtrl.GetLocalizationText("0081"),
					AIPitcher.GetInstance().GetThrowCount().ToString(),
					GameSettingCtrl.GetLocalizationText("0082"),
					null
				};
				string localizationText = GameSettingCtrl.GetLocalizationText("0177");
				array[5] = maxFeet + localizationText;
				PublicGameUIManager.GetInstance.OpenResultBoard(totalFeet + localizationText, array);
				PublicGameUIManager.leaderBoard.MyScoreUpdate(totalFeet);
			}
			else
			{
				if (CsGameData.Instance.curMode != GameMode.SBOMode)
				{
					return;
				}
				for (int i = 0; i < OutObj.Length; i++)
				{
					OutObj[i].SetActive(value: true);
				}
				if (CsGameData.Instance.curState == State.Multi)
				{
					Vector3[] array2 = new Vector3[1];
					array2[0].x = 10f;
					pView.RPC("RPC_AllData", RpcTarget.Others, array2);
				}
				if (6 < Mathf.Abs(CsGameData.Instance.firstScore - CsGameData.Instance.secondScore))
				{
					SBOGameEndUI();
				}
				else if (CsGameData.Instance.inning == maxInning - 1 && CsGameData.Instance.firstScore < CsGameData.Instance.secondScore)
				{
					SBOGameEndUI();
				}
				else if (CsGameData.Instance.inning < maxInning)
				{
					StartCoroutine(ChangeInning());
					if (_NorunNohit)
					{
						SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach26", 1);
					}
				}
				else if (CsGameData.Instance.inning == maxInning)
				{
					SBOGameEndUI();
				}
			}
		}

		private void TimeFunc()
		{
			gClockAudio.Stop();
		}

		private void RPC_GameEndTimeOut()
		{
			if (!_onlyOneGameEndCall)
			{
				_onlyOneGameEndCall = true;
				for (int i = 0; i < OutObj.Length; i++)
				{
					OutObj[i].SetActive(value: true);
				}
				if (CsGameData.Instance.curState == State.Multi)
				{
					Vector3[] array = new Vector3[1];
					array[0].x = 15f;
					pView.RPC("RPC_AllData", RpcTarget.Others, array);
				}
				CsGameData.Instance.newGame = true;
				string[] arr_score = new string[2]
				{
					CsGameData.Instance.secondScore.ToString(),
					CsGameData.Instance.firstScore.ToString()
				};
				int num = 2;
				num = ((CsGameData.Instance.gameFoulCount == 2) ? (PhotonNetwork.IsMasterClient ? 1 : 0) : ((!PhotonNetwork.IsMasterClient) ? 1 : 0));
				PublicGameUIManager.GetInstance.OpenResultBoard(arr_score, num);
			}
		}

		private void RPC_AllSound()
		{
			Call_PlaySound(SoundTrack.Timeout);
		}

		public void SBOGameEndUI()
		{
			CsGameData.Instance.newGame = true;
			string[] arr_score = new string[2]
			{
				CsGameData.Instance.secondScore.ToString(),
				CsGameData.Instance.firstScore.ToString()
			};
			int num = 2;
			if (CsGameData.Instance.secondScore < CsGameData.Instance.firstScore)
			{
				num = 1;
			}
			else if (CsGameData.Instance.secondScore > CsGameData.Instance.firstScore)
			{
				num = 0;
			}
			PublicGameUIManager.GetInstance.OpenResultBoard(arr_score, num);
			if (num == 0)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
			}
		}

		private IEnumerator ChangeInning()
		{
			if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				DefenderManager.GetInstance().Defender[8].SetActive(value: false);
			}
			if (CsGameData.Instance.curState == State.Multi)
			{
				MultiCharActive(_bool: false);
			}
			SideScript.GetComponent<CsScoreBoardUI>().Func_ActiveOn();
			SideScript.GetComponent<CsScoreBoardUI>().InningScore();
			SideScript.GetComponent<CsScoreBoardUI>().ActiveDepth(2);
			SideScript.GetComponent<CsScoreBoardUI>().UIPosAndAngle(change: true);
			CsGameData.Instance.inning++;
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			yield return YieldInstructionCache.WaitForSeconds(1.2f);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
			PlayerObj.transform.position = ChangeInningTrs.position;
			PlayerObj.transform.eulerAngles = ChangeInningTrs.eulerAngles;
			Call_PlaySound(SoundTrack.ChangeInning);
			DefenderManager.GetInstance().Call_ChangeInningMove();
			ScoreUIAction(2);
			ScorePanel.SetActive(value: false);
			Help_Hitter_Fire.SetActive(value: false);
			yield return YieldInstructionCache.WaitForSeconds(5f);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			yield return YieldInstructionCache.WaitForSeconds(1f);
			CsGameData.Instance.newGame = false;
			int num = CsGameData.Instance.inning % 2;
			if (CsGameData.Instance.curState == State.Multi && !PhotonNetwork.IsMasterClient)
			{
				num = (CsGameData.Instance.inning + 1) % 2;
			}
			if (num == 1)
			{
				CsGameData.Instance.curTeam = TeamPosition.Defense;
			}
			else
			{
				CsGameData.Instance.curTeam = TeamPosition.Offense;
			}
			if (CsGameData.Instance.curState == State.Multi && PhotonNetwork.CurrentRoom.PlayerCount == 1)
			{
				UnityEngine.Debug.Log("Other Player Left");
			}
			else
			{
				SceneManager.LoadScene("Scene_Game_BaseBall");
			}
		}

		public void Call_PlaySound(SoundTrack track, float _time = 0f)
		{
			switch (track)
			{
			case SoundTrack.Strike_1:
				switch (UnityEngine.Random.Range(1, 5))
				{
				case 1:
					track = SoundTrack.Strike_1;
					break;
				case 2:
					track = SoundTrack.Strike_2;
					break;
				case 3:
					track = SoundTrack.Strike_3;
					break;
				case 4:
					track = SoundTrack.Strike_4;
					break;
				}
				break;
			case SoundTrack.Ball_1:
				switch (UnityEngine.Random.Range(1, 3))
				{
				case 1:
					track = SoundTrack.Ball_1;
					break;
				case 2:
					track = SoundTrack.Ball_2;
					break;
				}
				break;
			case SoundTrack.FourBall_1:
				switch (UnityEngine.Random.Range(1, 3))
				{
				case 1:
					track = SoundTrack.FourBall_1;
					break;
				case 2:
					track = SoundTrack.FourBall_2;
					break;
				}
				break;
			case SoundTrack.Foul_1:
				switch (UnityEngine.Random.Range(1, 3))
				{
				case 1:
					track = SoundTrack.Foul_1;
					break;
				case 2:
					track = SoundTrack.Foul_2;
					break;
				}
				break;
			case SoundTrack.StrikeOut_1:
				switch (UnityEngine.Random.Range(1, 4))
				{
				case 1:
					track = SoundTrack.StrikeOut_1;
					break;
				case 2:
					track = SoundTrack.StrikeOut_2;
					break;
				case 3:
					track = SoundTrack.StrikeOut_3;
					break;
				}
				break;
			case SoundTrack.Safe_1:
				switch (UnityEngine.Random.Range(1, 4))
				{
				case 1:
					track = SoundTrack.Safe_1;
					break;
				case 2:
					track = SoundTrack.Safe_2;
					break;
				case 3:
					track = SoundTrack.Safe_3;
					break;
				}
				break;
			case SoundTrack.Homerun_1:
				switch (UnityEngine.Random.Range(1, 5))
				{
				case 1:
					track = SoundTrack.Homerun_1;
					break;
				case 2:
					track = SoundTrack.Homerun_2;
					break;
				case 3:
					track = SoundTrack.Homerun_3;
					break;
				case 4:
					track = SoundTrack.Homerun_4;
					break;
				}
				break;
			case SoundTrack.Going_1:
				switch (UnityEngine.Random.Range(1, 5))
				{
				case 1:
					track = SoundTrack.Going_1;
					break;
				case 2:
					track = SoundTrack.Going_2;
					break;
				case 3:
					track = SoundTrack.Going_3;
					break;
				case 4:
					track = SoundTrack.Going_4;
					break;
				}
				break;
			}
			if (_time == 0f)
			{
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese)
				{
					Sound.PlayOneShot(gSound.SoundVariousChina[(int)track]);
				}
				else
				{
					Sound.PlayOneShot(gSound.SoundVarious[(int)track]);
				}
			}
			else
			{
				StartCoroutine(SoundCoroutine(track, _time));
			}
		}

		private IEnumerator SoundCoroutine(SoundTrack track, float _time)
		{
			yield return YieldInstructionCache.WaitForSeconds(_time);
			if ((track != SoundTrack.Single_Hit && track != SoundTrack.Double_Hit) || !BallMove.GetInstance().homerun)
			{
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese)
				{
					Sound.PlayOneShot(gSound.SoundVariousChina[(int)track]);
				}
				else
				{
					Sound.PlayOneShot(gSound.SoundVarious[(int)track]);
				}
			}
		}

		public void Call_PlaySoundScore()
		{
			StartCoroutine(SoundScoreCoroutine(CsGameData.Instance.firstScore, 0.1f));
			StartCoroutine(SoundCoroutine(SoundTrack.to, 1.1f));
			StartCoroutine(SoundScoreCoroutine(CsGameData.Instance.secondScore, 2.1f));
		}

		private IEnumerator SoundScoreCoroutine(int number, float _time)
		{
			yield return YieldInstructionCache.WaitForSeconds(_time);
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese)
			{
				Sound.PlayOneShot(gSound.NumberVariousChina[number]);
			}
			else
			{
				Sound.PlayOneShot(gSound.NumberVarious[number]);
			}
		}

		public void Call_FenceCheck(Vector3 FencePos, Vector3 EndPos, float fenceDt, float endDt)
		{
			if (-135f < EndPos.z)
			{
				return;
			}
			FencePos.y = 12f;
			Vector3 velocity = BallMove.GetInstance().GetComponent<Rigidbody>().velocity;
			velocity.y += CsGameData.Instance._gravity * fenceDt;
			List<GameObject> list = new List<GameObject>();
			Vector3 position = FencePos;
			float num = 0f;
			while (0f < position.y)
			{
				float x = velocity.x * num;
				float z = velocity.z * num;
				float y = velocity.y * num + 0.5f * CsGameData.Instance._gravity * num * num;
				position = FencePos + new Vector3(x, y, z);
				GameObject gameObject = UnityEngine.Object.Instantiate(FenceCheck_PF, position, Quaternion.identity);
				gameObject.name = "Create";
				num += 0.05f;
				list.Add(gameObject);
			}
			for (int i = 0; i < list.Count - 1; i++)
			{
				Vector3 position2 = list[i].transform.position;
				Vector3 position3 = list[i + 1].transform.position;
				RaycastHit hitInfo = default(RaycastHit);
				if (Physics.Raycast(position2, position3 - position2, out hitInfo, (position3 - position2).magnitude) && hitInfo.transform.tag == "Fence")
				{
					UnityEngine.Debug.Log("펜스 충돌 예상.");
					Vector3 point = hitInfo.point;
					point.y = 0f;
					BallMove.GetInstance().FencePos = point;
					BallMove.GetInstance().fence = true;
				}
			}
			if (!BallMove.GetInstance().fence && CsGameData.Instance.curMode == GameMode.SBOMode)
			{
				FenceColl.SetActive(value: false);
			}
			for (int j = 0; j < list.Count; j++)
			{
				UnityEngine.Object.Destroy(list[j].gameObject);
			}
			list.Clear();
		}

		public void Call_HitBall(Vector3 BallStartPos, Vector3 BallVel)
		{
			if (BallMove.GetInstance().deadball)
			{
				return;
			}
			BallMove.GetInstance().hitGroundCheck = true;
			Help_Hitter.SetActive(value: false);
			float num = Mathf.Abs(BallVel.x);
			float num2 = Mathf.Abs(BallVel.z);
			if (num < num2)
			{
				Vector3 vector = BallBoundPoint(BallStartPos, BallVel);
				float num3 = 0f;
				if (vector.z < 0f)
				{
					num3 = Mathf.Sqrt(vector.x * vector.x + vector.z * vector.z);
				}
				if (50f < num3)
				{
					Call_PlaySound(SoundTrack.Audience_1);
				}
				if (BallVel.z < 0f)
				{
					if (num3 <= 105f)
					{
						HitPartcileAndSound(BallStartPos);
						BallMove.GetInstance().CreateParticleTrail();
					}
					else if (105f < num3 && num3 <= 290f)
					{
						HitPartcileAndSound(BallStartPos, 1);
						BallMove.GetInstance().CreateParticleTrail();
					}
					else if (290f < num3)
					{
						HitPartcileAndSound(BallStartPos, 2);
						Call_PlaySound(SoundTrack.Going_1, 1f);
						BallMove.GetInstance().CreateParticleTrail(3);
						DefenderManager.GetInstance().Call_HomerunDefenderStop();
					}
				}
				else
				{
					HitPartcileAndSound(BallStartPos);
					BallMove.GetInstance().CreateParticleTrail();
				}
			}
			else
			{
				HitPartcileAndSound(BallStartPos);
				BallMove.GetInstance().CreateParticleTrail();
			}
			HomerunGameHitAndPlay(BallStartPos, BallVel);
			if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
			{
				Vector3[] array = new Vector3[3];
				array[0].x = 8f;
				array[1] = BallStartPos;
				array[2] = BallVel;
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
			}
		}

		private IEnumerator CatcherDelayDecide()
		{
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			if (CsGameData.Instance.curTeam == TeamPosition.Offense)
			{
				if (BallMove.GetInstance().deadball)
				{
					UnityEngine.Debug.Log("DeadBall");
				}
				else if (CbatFollower.GetInstance().swing || BallMove.GetInstance().curThrow == Throw.Strike)
				{
					CatchStrike();
				}
				else if (BallMove.GetInstance().curThrow == Throw.Ball)
				{
					CatchBall();
				}
			}
			else if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				if (BallMove.GetInstance().deadball)
				{
					UnityEngine.Debug.Log("DeadBall");
				}
				else if (AiHitterSwing || BallMove.GetInstance().curThrow == Throw.Strike)
				{
					CatchStrike();
				}
				else if (BallMove.GetInstance().curThrow == Throw.Ball)
				{
					CatchBall();
				}
			}
		}

		public void Call_ThrowBallDecide(string tag)
		{
			switch (tag)
			{
			case "Catcher":
				if (BallMove.GetInstance().hit)
				{
					break;
				}
				BallMove.GetInstance().BallStop();
				BallMove.GetInstance().AddForceCorouStop();
				Call_PlaySound(SoundTrack.Tack);
				BallMove.GetInstance().BallDestroy(1.3f);
				if (CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					CbatFollower.GetInstance().SetSphereCollEnabled(_bool: false);
				}
				if (CsGameData.Instance.curMode == GameMode.HomerunMode)
				{
					UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[4], BallMove.GetInstance().transform.position, Quaternion.identity), 0.75f);
					Call_PlaySound(SoundTrack.Strike_1);
					outCount++;
				}
				else if (CsGameData.Instance.curMode == GameMode.SBOMode)
				{
					StartCoroutine(CatcherDelayDecide());
					BallMove.GetInstance().Call_StopCatcher();
					if (BallMove.GetInstance().curThrow == Throw.Strike)
					{
						UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[4], BallMove.GetInstance().transform.position, Quaternion.identity), 0.75f);
					}
					else if (BallMove.GetInstance().curThrow == Throw.Ball)
					{
						UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[5], BallMove.GetInstance().transform.position, Quaternion.identity), 0.75f);
					}
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
					{
						Vector3[] array3 = new Vector3[3];
						array3[0].x = 5f;
						array3[1].x = (float)BallMove.GetInstance().curThrow;
						array3[2] = BallMove.GetInstance().transform.position;
						pView.RPC("RPC_AllData", RpcTarget.Others, array3);
					}
				}
				break;
			case "Hitter":
				if (CsGameData.Instance.curMode != GameMode.SBOMode || BallMove.GetInstance().deadball)
				{
					break;
				}
				BallMove.GetInstance().deadball = true;
				if (CsGameData.Instance.curTeam == TeamPosition.Defense && CsGameData.Instance.curState == State.Single)
				{
					if (BallMove.GetInstance().transform.position.y < 1.8f)
					{
						Hitter.GetComponent<Animator>().SetTrigger("DeadBall");
						Hitter.GetComponent<Animator>().SetFloat("DeadBallValue", 2f);
					}
					else if (BallMove.GetInstance().transform.position.y < 3f)
					{
						Hitter.GetComponent<Animator>().SetTrigger("DeadBall");
						Hitter.GetComponent<Animator>().SetFloat("DeadBallValue", 1f);
					}
					else
					{
						Hitter.GetComponent<Animator>().SetTrigger("DeadBall");
						Hitter.GetComponent<Animator>().SetFloat("DeadBallValue", 0f);
					}
				}
				if (CsGameData.Instance.curTeam == TeamPosition.Offense && CsGameData.Instance.curState == State.Multi)
				{
					Vector3[] array2 = new Vector3[4];
					array2[0].x = 7f;
					array2[1] = BallMove.GetInstance().transform.position;
					array2[2] = BallMove.GetInstance().GetComponent<Rigidbody>().velocity * 0.2f;
					if (Mathf.Abs(CameraObj.transform.position.x) < 2.1f)
					{
						array2[3].x = 1f;
					}
					pView.RPC("RPC_AllData", RpcTarget.Others, array2);
				}
				Call_PlaySound(SoundTrack.WildThrow);
				Call_PlaySound(SoundTrack.Tack);
				BallMove.GetInstance().AddForceCorouStop();
				BallMove.GetInstance().Call_StopCatcher();
				BallMove.GetInstance().BallDestroy(2.5f);
				BallMove.GetInstance().GetComponent<Rigidbody>().velocity *= 0.2f;
				if (CsGameData.Instance.curState == State.Single && CsGameData.Instance.curTeam == TeamPosition.Defense)
				{
					Call_PlaySound(SoundTrack.DeadBall, 1f);
					ActiveTextUI(SoundTrack.DeadBall);
					Call_SBOReset(1.51f);
					DefenderManager.GetInstance().BallAdvantage();
				}
				else if (Mathf.Abs(CameraObj.transform.position.x) < 2.1f)
				{
					CatchStrike();
				}
				else
				{
					Call_PlaySound(SoundTrack.DeadBall, 1f);
					ActiveTextUI(SoundTrack.DeadBall);
					Call_SBOReset(1.51f);
					DefenderManager.GetInstance().BallAdvantage();
				}
				break;
			case "Ground":
				if (!BallMove.GetInstance().GetHitDecide())
				{
					if (BallMove.GetInstance().hit)
					{
						if (BallMove.GetInstance().hitGroundCheck)
						{
							BallMove.GetInstance().bound = true;
							BallMove.GetInstance().reckoning = false;
							Call_PlaySound(SoundTrack.Bound);
							EffectBoundIndicate(BallMove.GetInstance().transform.position);
							Vector3 velocity = BallMove.GetInstance().GetComponent<Rigidbody>().velocity;
							velocity.y = 0f;
							Vector3 vector = Vector3.Cross(velocity, Vector3.up);
							BallMove.GetInstance().GetComponent<Rigidbody>().angularVelocity = vector * -3f;
							if (CsGameData.Instance.curMode == GameMode.HomerunMode)
							{
								BallMove.GetInstance().reckoning = false;
								BallMove.GetInstance().BallDestroy(2.5f);
							}
							else if (CsGameData.Instance.curMode == GameMode.SBOMode)
							{
								FenceColl.SetActive(value: true);
							}
						}
						else
						{
							UnityEngine.Debug.Log("asdfklnasdilfhnadslfhnjasdlfhjalshsdl");
						}
					}
					else
					{
						Call_PlaySound(SoundTrack.Bound);
						BallMove.GetInstance().BallDestroy(1f);
					}
					break;
				}
				goto default;
			default:
				switch (tag)
				{
				case "Fence":
				{
					BallMove.GetInstance().curFenceHit = true;
					Vector3 velocity2 = BallMove.GetInstance().GetComponent<Rigidbody>().velocity;
					velocity2 = new Vector3(velocity2.x * 0.01f, velocity2.y, velocity2.z * 0.01f);
					BallMove.GetInstance().GetComponent<Rigidbody>().velocity = velocity2;
					break;
				}
				case "Homerun":
				case "OutHomerun":
					if (!BallMove.GetInstance().foul && !BallMove.GetInstance().homerun && !BallMove.GetInstance().curFenceHit && !BallMove.GetInstance().bound)
					{
						BallMove.GetInstance().homerun = true;
						BallMove.GetInstance().reckoning = false;
						UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[3], new Vector3(0f, 100f, -550f), Quaternion.identity), 10f);
						gHomerun.Call_Homerun();
						Call_PlaySound(SoundTrack.Homerun_1);
						Call_PlaySound(SoundTrack.Audience_2);
						BallMove.GetInstance().HomerunBallDestroy(3f);
						FenceColl.SetActive(value: true);
						if (tag == "Homerun")
						{
							BallMove.GetInstance().GetComponent<Rigidbody>().velocity *= 0.1f;
							Call_PlaySound(SoundTrack.HomeRunBound);
							UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(BallMove.GetInstance().projectileParticle[5], BallMove.GetInstance().transform.position, Quaternion.identity), 3f);
						}
						if (CsGameData.Instance.curState == State.Multi)
						{
							Vector3[] array = new Vector3[1];
							array[0].x = 9f;
							pView.RPC("RPC_AllData", RpcTarget.Others, array);
						}
						homerunCount++;
					}
					break;
				case "Bonus":
					CsBonus.GetInstance().HitBonus();
					break;
				}
				break;
			}
		}

		private void HitPartcileAndSound(Vector3 Pos, int step = 0)
		{
			GameObject obj = new GameObject();
			UnityEngine.Object.Destroy(obj, 1f);
			if (0 == 0)
			{
				switch (step)
				{
				case 0:
					Sound.volume = 0.8f;
					obj = UnityEngine.Object.Instantiate(gParticle.ParticleArray[8], Pos, Quaternion.identity);
					Call_PlaySound(SoundTrack.BatHit_Two);
					break;
				case 1:
					Sound.volume = 1f;
					obj = UnityEngine.Object.Instantiate(gParticle.ParticleArray[14], Pos, Quaternion.identity);
					Call_PlaySound(SoundTrack.BatHit_Two);
					break;
				case 2:
					Sound.volume = 1f;
					obj = UnityEngine.Object.Instantiate(gParticle.ParticleArray[14], Pos, Quaternion.identity);
					Call_PlaySound(SoundTrack.BatHit_Three);
					break;
				}
			}
			UnityEngine.Object.Destroy(obj, 3f);
		}

		private Vector3 BallBoundPoint(Vector3 BallStartPos, Vector3 BallVel)
		{
			if (0f < BallVel.y)
			{
				float num = (0f - BallVel.y) / CsGameData.Instance._gravity;
				float num2 = BallVel.y * num + 0.5f * CsGameData.Instance._gravity * num * num;
				float num3 = BallStartPos.y + num2;
				float num4 = Mathf.Sqrt(Mathf.Abs(2f * num3 / CsGameData.Instance._gravity));
				float num5 = num + num4;
				float x = BallStartPos.x + BallVel.x * num5;
				float z = BallStartPos.z + BallVel.z * num5;
				return new Vector3(x, 0f, z);
			}
			float y = BallStartPos.y;
			float num6 = Mathf.Sqrt(Mathf.Abs(2f * y / CsGameData.Instance._gravity));
			float x2 = BallStartPos.x + BallVel.x * num6;
			float z2 = BallStartPos.z + BallVel.z * num6;
			return new Vector3(x2, 0f, z2);
		}

		private void HomerunGameHitAndPlay(Vector3 BallStartPos, Vector3 BallVel)
		{
			ReturnDataClass returnDataClass = DefenderManager.GetInstance().StartDefence(BallStartPos, BallVel);
			if (CsPhysics.FoulDecide(returnDataClass.BallDownPos, FoulLine[0], FoulLine[1], FoulLine[2]) || FoulLine[0].transform.position.z - 2.5f < returnDataClass.BallDownPos.z || Mathf.Abs(BallVel.z) < Mathf.Abs(BallVel.x))
			{
				if (BallMove.GetInstance().homerun_FlyOut && Mathf.Abs(BallMove.GetInstance().GetComponent<Rigidbody>().velocity.x) < Mathf.Abs(BallMove.GetInstance().GetComponent<Rigidbody>().velocity.z) * 1.3f)
				{
					outCount++;
					BallMove.GetInstance().BallDestroy(returnDataClass._firstCatchTime + 2f);
					return;
				}
				Call_PlaySound(SoundTrack.Foul_1, 0.75f);
				BallMove.GetInstance().foul = true;
				BallMove.GetInstance().curType = BallCatchType.Foul;
				BallMove.GetInstance().GetComponent<BallMove>().BallDestroy(1.5f);
				if (CsGameData.Instance.curMode == GameMode.SBOMode && strikeCount < 2)
				{
					strikeCount++;
				}
			}
			else if (45f < returnDataClass.BallDownPos.z && BallVel.y < 3f)
			{
				Call_PlaySound(SoundTrack.Foul_1, 0.75f);
				BallMove.GetInstance().foul = true;
				BallMove.GetInstance().curType = BallCatchType.Foul;
				BallMove.GetInstance().GetComponent<BallMove>().BallDestroy(1.5f);
			}
			else if (CsGameData.Instance.curMode == GameMode.HomerunMode)
			{
				DefenderManager.GetInstance().MoveToMyBasePos();
				FollowParent.SetActive(value: true);
				FollowBallFt[0].SetActive(value: true);
				FollowBallFt[5].SetActive(value: true);
				StartCoroutine(Follow());
				StartCoroutine(DistanceReckoning());
				if (BallMove.GetInstance().homerun_FlyOut)
				{
					outCount++;
					BallMove.GetInstance().BallDestroy(returnDataClass._firstCatchTime + 2f);
				}
				else if (BallMove.GetInstance().homerun_BoundOut)
				{
					outCount++;
					Call_PlaySound(SoundTrack.Out_1, returnDataClass._firstCatchTime);
				}
			}
			else
			{
				if (CsGameData.Instance.curMode != GameMode.SBOMode)
				{
					return;
				}
				DefenderManager.GetInstance().StartDefenceAfter(returnDataClass);
				if (BallMove.GetInstance().homerun_FlyOut)
				{
					outCount++;
					UnityEngine.Debug.Log("BallMove.GetInstance().flyOutPlay : " + BallMove.GetInstance().flyOutPlay);
					if (BallMove.GetInstance().flyOutPlay)
					{
						BallMove.GetInstance().BallDestroy(BallMove.GetInstance().flyOutPlayTime);
					}
					else
					{
						BallMove.GetInstance().BallDestroy(returnDataClass._firstCatchTime + 2f);
					}
				}
			}
		}

		private IEnumerator Follow()
		{
			yield return null;
			if ((bool)BallMove.GetInstance())
			{
				Quaternion rotation = CameraObj.transform.rotation;
				rotation.eulerAngles = new Vector3(rotation.eulerAngles.x, rotation.eulerAngles.y, 0f);
				FollowParent.transform.rotation = rotation;
				StartCoroutine(Follow());
			}
			else
			{
				for (int i = 0; i < 6; i++)
				{
					FollowBallFt[i].SetActive(value: false);
				}
			}
		}

		private IEnumerator DistanceReckoning()
		{
			yield return null;
			if ((bool)BallMove.GetInstance() && BallMove.GetInstance().reckoning)
			{
				Vector3 position = Base[4].transform.position;
				position.y = 0f;
				Vector3 position2 = BallMove.GetInstance().transform.position;
				position2.y = 0f;
				currentFeet = (int)(Vector3.Distance(position, position2) * 0.4f * (float)CsGameData.Instance.numMultiple);
				int num = currentFeet / 1000;
				int num2 = (currentFeet - num * 1000) / 100;
				int num3 = (currentFeet - num * 1000 - num2 * 100) / 10;
				int num4 = currentFeet - num * 1000 - num2 * 100 - num3 * 10;
				FollowBallFt[0].GetComponent<Text>().text = num4.ToString();
				FollowBallFt[1].GetComponent<Text>().text = num3.ToString();
				FollowBallFt[2].GetComponent<Text>().text = num2.ToString();
				FollowBallFt[3].GetComponent<Text>().text = num.ToString();
				if (!FollowBallFt[1].activeSelf && currentFeet > 9)
				{
					FollowBallFt[1].SetActive(value: true);
				}
				if (!FollowBallFt[2].activeSelf && currentFeet > 99)
				{
					FollowBallFt[2].SetActive(value: true);
				}
				if (!FollowBallFt[3].activeSelf && currentFeet > 999)
				{
					FollowBallFt[3].SetActive(value: true);
				}
				StartCoroutine(DistanceReckoning());
			}
			else
			{
				HomerunGameReckoning();
			}
		}

		public void HomerunGameReckoning()
		{
			if (BallMove.GetInstance().bound || BallMove.GetInstance().homerun)
			{
				totalFeet += currentFeet;
				if (maxFeet < currentFeet)
				{
					maxFeet = currentFeet;
				}
			}
			else if (2 < outCount)
			{
				AIPitcher.GetInstance().GameEnd();
				GameEnd();
			}
		}

		private void HomerunGameSetOutCount()
		{
			for (int i = 0; i < 3; i++)
			{
				OutCountOff[i].SetActive(value: true);
				OutCountOn[i].SetActive(value: false);
			}
			for (int j = 0; j < outCount; j++)
			{
				OutCountOff[j].SetActive(value: false);
				OutCountOn[j].SetActive(value: true);
			}
		}

		public void Call_CatchBall(float dt, BallCatchType Type)
		{
			StartCoroutine(CatchBallCorou(dt, Type));
		}

		private IEnumerator CatchBallCorou(float dt, BallCatchType Type)
		{
			yield return YieldInstructionCache.WaitForSeconds(dt);
			BallMove.GetInstance().BallStop();
			BallCatch(Type);
		}

		private void BallCatch(BallCatchType Type)
		{
			BallMove.GetInstance().transform.GetChild(0).gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[5], BallMove.GetInstance().transform.position, Quaternion.identity), 0.75f);
			Call_PlaySound(SoundTrack.Tack);
			if (Type == BallCatchType.NoBound || Type == BallCatchType.Fly)
			{
				Call_PlaySound(SoundTrack.Out_1);
			}
		}

		public void Call_OffenseOut(int _outCount)
		{
			outCount += _outCount;
			if (2 < outCount)
			{
				ThreeOut();
			}
		}

		private void CatchStrike()
		{
			strikeCount++;
			if (strikeCount == 3)
			{
				StrikeOut();
				Call_SBOReset();
				if (CsGameData.Instance.curTeam == TeamPosition.Defense)
				{
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach25", 1);
				}
			}
			else
			{
				float time = 0.2f;
				if (BallMove.GetInstance().deadball)
				{
					time = 0.6f;
				}
				Call_PlaySound(SoundTrack.Strike_1, time);
				RefereeAni.Call_Ani("Strike");
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
			{
				Vector3[] array = new Vector3[2];
				array[0].x = 6f;
				array[1].x = 1f;
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
			}
		}

		private void CatchBall()
		{
			ballCount++;
			if (ballCount == 4)
			{
				DefenderManager.GetInstance().BallAdvantage();
				Call_SBOReset();
				Call_PlaySound(SoundTrack.FourBall_1, 0.2f);
				ActiveTextUI(SoundTrack.FourBall_1);
			}
			else
			{
				Call_PlaySound(SoundTrack.Ball_1, 0.2f);
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
			{
				Vector3[] array = new Vector3[2];
				array[0].x = 6f;
				array[1].x = 2f;
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
			}
		}

		private void StrikeOut()
		{
			Call_PlaySound(SoundTrack.StrikeOut_1, 0.2f);
			ActiveTextUI(SoundTrack.StrikeOut_1);
			RefereeAni.Call_Ani("Out");
			outCount++;
			if (2 < outCount)
			{
				ThreeOut();
			}
		}

		private void ThreeOut()
		{
		}

		private void ActiveTextUI(SoundTrack type)
		{
			for (int i = 0; i < TextUIObjs.Length; i++)
			{
				TextUIObjs[i].SetActive(value: false);
			}
			switch (type)
			{
			case SoundTrack.DeadBall:
				TextUIObjs[0].SetActive(value: true);
				TextUIParent.GetComponent<Animator>().SetTrigger("Trigger");
				break;
			case SoundTrack.FourBall_1:
				TextUIObjs[1].SetActive(value: true);
				TextUIParent.GetComponent<Animator>().SetTrigger("Trigger");
				break;
			case SoundTrack.StrikeOut_1:
				TextUIObjs[2].SetActive(value: true);
				TextUIParent.GetComponent<Animator>().SetTrigger("Trigger");
				break;
			}
		}

		public void Call_SBOReset(float dt = 0f)
		{
			strikeCount = 0;
			ballCount = 0;
			if (CsGameData.Instance.curTeam == TeamPosition.Defense && CsGameData.Instance.curState == State.Single && outCount < 3)
			{
				DefenderManager.GetInstance().customModelData = CustomModelSettingCtrl.GetRandomModelData();
				Hitter_WalkMan.GetComponent<CustomModelSettingCtrl>().Init(DefenderManager.GetInstance().customModelData);
				SideScript.GetComponent<CsOutAniOnOff>().Call_OutAni(dt);
				AIHitterIsRightSet();
			}
		}

		private void AIHitterIsRightSet()
		{
			if (UnityEngine.Random.Range(0f, 1f) < 0.7f)
			{
				CsGameData.Instance.AI_Right = true;
				Hitter = Hitter_R;
			}
			else
			{
				CsGameData.Instance.AI_Right = false;
				Hitter = Hitter_L;
			}
			SideScript.GetComponent<CsOutAniOnOff>().HitterSet(CsGameData.Instance.AI_Right);
		}

		private void EffectBoundIndicate(Vector3 DownPos)
		{
			Vector3 position = DownPos;
			position.y = 0f;
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[5], DownPos, Quaternion.identity), 0.75f);
			Quaternion rotation = default(Quaternion);
			rotation.eulerAngles = new Vector3(90f, 0f, 0f);
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[7], position, rotation), 5f);
		}

		public void Call_PlayerThrowBall_Fail(Vector3 BallStartPos, Quaternion BallRot)
		{
			throwOK = false;
			SelectParent.SetActive(value: false);
			_ = Vector3.zero;
			GameObject gameObject = UnityEngine.Object.Instantiate(BallPF, BallStartPos, BallRot);
			gameObject.GetComponent<SphereCollider>().enabled = true;
			gameObject.GetComponent<Rigidbody>().velocity = CsHandRigid.GetInstance().GetVel();
			Vector3 normalized = CsHandRigid.GetInstance().GetVel().normalized;
			normalized.y = 0f;
			normalized.Normalize();
			Vector3 zero = Vector3.zero;
			zero.x = normalized.z * CsHandRigid.GetInstance().GetVel().magnitude * 3f;
			zero.z = (0f - normalized.x) * CsHandRigid.GetInstance().GetVel().magnitude * 3f;
			gameObject.GetComponent<Rigidbody>().angularVelocity = zero;
			gameObject.GetComponent<BallMove>().CreateParticleTrail();
			Call_PlaySound(SoundTrack.Throw);
			StartCoroutine(FailBallCorou(gameObject));
			if (CsGameData.Instance.curState == State.Multi)
			{
				Vector3[] array = new Vector3[4];
				array[0].x = 1f;
				array[1] = BallStartPos;
				array[2] = CsHandRigid.GetInstance().GetVel();
				array[3] = zero;
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
			}
		}

		private IEnumerator FailBallCorou(GameObject Ball)
		{
			yield return YieldInstructionCache.WaitForSeconds(2f);
			UnityEngine.Object.Destroy(Ball);
			if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				throwOK = true;
				SelectParent.SetActive(value: true);
			}
		}

		public bool Call_CheckSuccessBall(Vector3 Pos)
		{
			bool result = false;
			Vector3 vel = CsHandRigid.GetInstance().GetVel();
			float num = (new Vector3(0f, 2.5f, 53f) - Pos).z / vel.z;
			if (num < 0f)
			{
				return false;
			}
			float num2 = Pos.x + vel.x * num;
			float num3 = Pos.y + vel.y * num + 0.5f * CsGameData.Instance._gravity * num * num;
			float num4 = Mathf.Sqrt(num2 * num2 + num3 * num3);
			if (num3 < 0f)
			{
				num3 = 0f;
			}
			TestCube.position = new Vector3(num2, num3, 50f);
			if (num4 < 25f)
			{
				result = true;
			}
			return result;
		}

		public void Call_PlayerThrowBall(int _select, Vector3 BallStartPos, bool TestBool = false)
		{
			throwOK = false;
			SelectParent.SetActive(value: false);
			Help_Pitcher.SetActive(value: false);
			switch (_select)
			{
			case 1:
				CsGameData.Instance.curveCount--;
				SelectParent.transform.GetChild(1).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.curveCount;
				if (CsGameData.Instance.curveCount == 0)
				{
					SelectParent.transform.GetChild(1).gameObject.SetActive(value: false);
				}
				break;
			case 2:
				CsGameData.Instance.leftSlideCount--;
				SelectParent.transform.GetChild(2).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.leftSlideCount;
				if (CsGameData.Instance.leftSlideCount == 0)
				{
					SelectParent.transform.GetChild(2).gameObject.SetActive(value: false);
				}
				break;
			case 3:
				CsGameData.Instance.rightSlideCount--;
				SelectParent.transform.GetChild(3).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.rightSlideCount;
				if (CsGameData.Instance.rightSlideCount == 0)
				{
					SelectParent.transform.GetChild(3).gameObject.SetActive(value: false);
				}
				break;
			case 4:
				CsGameData.Instance.specialCount--;
				SelectParent.transform.GetChild(4).GetChild(3).GetComponent<TextMesh>()
					.text = "x " + CsGameData.Instance.specialCount;
				if (CsGameData.Instance.specialCount == 0)
				{
					SelectParent.transform.GetChild(4).gameObject.SetActive(value: false);
				}
				break;
			}
			Vector3 BallVel = Vector3.zero;
			GameObject gameObject = UnityEngine.Object.Instantiate(BallPF, BallStartPos, Quaternion.identity);
			gameObject.GetComponent<SphereCollider>().enabled = true;
			Vector3 vector = CsHandRigid.GetInstance().GetVel();
			if (TestBool)
			{
				vector = new Vector3(0.1f, 13f, 2.5f);
			}
			float num = 50f / vector.z;
			float num2 = 0.25f;
			float num3 = 0.15f;
			float num4 = 1.85f;
			Vector3 zero = Vector3.zero;
			zero.x = BallStartPos.x + vector.x * num * num2;
			zero.y = (BallStartPos.y + (vector.y * num + 0.5f * CsGameData.Instance._gravity * (num * num))) * num3 + num4;
			zero.z = CatcherCollObj.transform.position.z;
			UnityEngine.Debug.Log(string.Concat("Vel  : ", vector, "     RevisePos : ", zero));
			float num5 = BallStartPos.z - CatcherCollObj.transform.position.z;
			float num6 = BallStartPos.z - BallHitTrs.position.z;
			float num7 = num6 / num5;
			UnityEngine.Debug.Log("_dis_1 : " + num5 + "     _dis_2 : " + num6 + "     _hitDtValue : " + num7);
			Vector2 HitPos = Vector3.zero;
			gameObject.GetComponent<BallMove>().ThrowBallType(_select, BallStartPos, zero, out BallVel, vector.z, num7, out HitPos);
			gameObject.GetComponent<BallMove>().Call_CatcherHandCorou();
			Text testText = TestText;
			testText.text = testText.text + "\n" + BallVel.ToString() + "\n" + BallMove.GetInstance().Tempstr;
			if (_select == 4)
			{
				Call_PlaySound(SoundTrack.FireBall);
			}
			else
			{
				Call_PlaySound(SoundTrack.Throw);
			}
			if (CsGameData.Instance.curState == State.Single)
			{
				float num8 = 0f;
				num8 = (gameObject.transform.position.z - BallHitTrs.position.z) / gameObject.GetComponent<Rigidbody>().velocity.z;
				num8 = Mathf.Abs(num8);
				Vector3 HitVel = Vector3.zero;
				New_AiHitterFunc(out HitVel, HitPos);
				StartCoroutine(New_AIHitter_BatSwing(HitVel, num8));
			}
			else if (CsGameData.Instance.curState == State.Multi)
			{
				Vector3[] array = new Vector3[5];
				array[0].x = 0f;
				array[1] = BallStartPos;
				array[2] = BallVel;
				array[3].x = _select;
				array[3].y = (float)BallMove.GetInstance().curThrow;
				array[4] = BallMove.GetInstance().GetVecAddForce();
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
				gameObject.GetComponent<SphereCollider>().enabled = false;
				CsGameData.Instance.timeStack = 0f;
				CsGameData.Instance.ballCheck = false;
				CsGameData.Instance.TimeTictok = false;
				gClockAudio.Stop();
			}
		}

		private Vector3 getShotVelocityAtoB(Vector3 A, Vector3 B, float t)
		{
			Vector3 vector = A;
			Vector3 vector2 = B;
			float num = vector2.x - vector.x;
			float num2 = vector2.z - vector.z;
			float x = num / t;
			float z = num2 / t;
			float num3 = CsGameData.Instance._gravity + 2.5f;
			float y = vector.y;
			float y2 = (vector2.y - y - num3 * Mathf.Pow(t, 2f) / 2f) / t;
			return new Vector3(x, y2, z);
		}

		private void New_AiHitterFunc(out Vector3 HitVel, Vector2 HitPos)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			if (-1f < HitPos.x && HitPos.x < 1f && 1.1f < HitPos.y && HitPos.y < 2.7f)
			{
				flag3 = true;
			}
			UnityEngine.Debug.Log("HitPos : " + HitPos);
			Vector3 vector = Vector3.zero;
			if (BallMove.GetInstance().balltype == 4)
			{
				AiHitterSwing = true;
			}
			else if (flag3)
			{
				float magnitude = (new Vector2(0f, 1.9f) - HitPos).magnitude;
				UnityEngine.Debug.Log("0 ~ 0.05  = " + magnitude / 1.28f * 0.05f);
				float num = 0.22f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.08f - magnitude / 1.28f * 0.05f;
				if (BallMove.GetInstance().balltype != 0)
				{
					num -= 0.1f;
				}
				if (UnityEngine.Random.Range(0f, 1f) < num)
				{
					flag = true;
					AiHitterSwing = true;
				}
				else
				{
					float num2 = UnityEngine.Random.Range(0f, 1f);
					if (num2 < 0.33f)
					{
						flag2 = true;
						AiHitterSwing = true;
					}
					else if (num2 < 0.66f)
					{
						AiHitterSwing = true;
					}
					else
					{
						UnityEngine.Debug.Log("Nope");
					}
				}
				if (flag)
				{
					float num3 = 40f;
					float num4 = 40f + (55f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 10f) * (1f - magnitude / 1.28f);
					float num5 = UnityEngine.Random.Range(num3, num4);
					vector.x = UnityEngine.Random.Range(0f, 0.9f) - 0.45f;
					vector.z = -0.5f;
					vector.y = UnityEngine.Random.Range(0f, 0.4f);
					vector = vector.normalized * num5;
					UnityEngine.Debug.Log("min : " + num3 + "   max : " + num4 + "   hitDistance : " + num5);
				}
				else if (flag2)
				{
					float num6 = 0f - UnityEngine.Random.Range(10f, 40f);
					float y = UnityEngine.Random.Range(7f, 60f);
					float num7 = 0f - UnityEngine.Random.Range(10f, 50f) + num6;
					if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
					{
						num7 = 0f - num7;
					}
					vector = new Vector3(num7, y, num6).normalized * UnityEngine.Random.Range(15f, 70f);
					UnityEngine.Debug.Log("Foul");
				}
				else if (AiHitterSwing)
				{
					UnityEngine.Debug.Log("NoHit Swing");
				}
				else
				{
					UnityEngine.Debug.Log("Look NoSwing");
				}
			}
			else
			{
				Vector2 vector2 = new Vector2(0f, 1.9f);
				float num8 = Mathf.Abs(vector2.x - HitPos.x);
				float num9 = Mathf.Abs(vector2.y - HitPos.y);
				bool flag4 = !(num8 < num9);
				float num10 = 0f;
				if (flag4)
				{
					num8 -= 1f;
					if (num8 < 1f)
					{
						num10 = 0.8f - (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.1f - num8;
					}
				}
				else
				{
					num9 -= 0.8f;
					if (num9 < 1f)
					{
						num10 = 0.8f - (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.1f - num9;
					}
				}
				if (BallMove.GetInstance().balltype != 0)
				{
					num10 += 0.1f;
				}
				UnityEngine.Debug.Log("Check_X : " + flag4.ToString() + "   DisY : " + num9);
				UnityEngine.Debug.Log("Ball Swing Value : " + num10);
				if (UnityEngine.Random.Range(0f, 1f) < num10)
				{
					AiHitterSwing = true;
				}
				else if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
				{
					flag2 = true;
				}
				if (AiHitterSwing)
				{
					if (flag2)
					{
						float num11 = 0f - UnityEngine.Random.Range(10f, 40f);
						float y2 = UnityEngine.Random.Range(7f, 60f);
						float num12 = 0f - UnityEngine.Random.Range(10f, 50f) + num11;
						if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
						{
							num12 = 0f - num12;
						}
						vector = new Vector3(num12, y2, num11).normalized * UnityEngine.Random.Range(15f, 70f);
						UnityEngine.Debug.Log("Foul");
					}
					else
					{
						UnityEngine.Debug.Log("NoHit Swing");
					}
				}
				else
				{
					UnityEngine.Debug.Log("NoSwing");
				}
			}
			HitVel = vector;
		}

		private IEnumerator New_AIHitter_BatSwing(Vector3 HitVel, float _dt)
		{
			yield return YieldInstructionCache.WaitForSeconds(_dt - 0.1f);
			if (Vector3.zero != HitVel)
			{
				CatcherCollObj.SetActive(value: false);
			}
			if (AiHitterSwing && !BallMove.GetInstance().deadball)
			{
				Hitter.GetComponent<Animator>().SetTrigger("Swing");
			}
			else if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
			{
				Hitter.GetComponent<Animator>().SetTrigger("StopSwing");
			}
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			if (!BallMove.GetInstance().deadball)
			{
				if (HitVel != Vector3.zero)
				{
					Hitter.GetComponent<CapsuleCollider>().enabled = false;
					BallMove.GetInstance().GetComponent<Rigidbody>().velocity = HitVel;
					BallMove.GetInstance().AddForceCorouStop();
					BallMove.GetInstance().RemoveParticleTrail();
					BallMove.GetInstance().hit = true;
					Call_HitBall(BallMove.GetInstance().transform.position, HitVel);
					AICatcher.GetInstance().StopAllCoroutines();
					AICatcher.GetInstance().CatcherIdle();
				}
				else
				{
					UnityEngine.Debug.Log("Nope");
				}
			}
		}

		private void HitterSwing(out bool swing, out bool foulHit, out float hitValue, int ballType, Vector2 HitPos, float dt)
		{
			swing = false;
			foulHit = false;
			hitValue = 0f;
			_ = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			_ = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			switch (ballType)
			{
			case 0:
				_ = 0.1f;
				break;
			default:
				_ = 0.2f;
				break;
			case 4:
				break;
			}
			float num4 = Mathf.Abs(HitPos.x);
			float num5 = Mathf.Abs(HitPos.y - 1.9f) * 1.25f;
			if (ballType == 4)
			{
				if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
				{
					swing = true;
				}
				else
				{
					swing = false;
				}
			}
			else if (num4 < 1f && 0f < num5 && num5 < 1f)
			{
				if (num4 < 0.2f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f && num5 < 0.2f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f)
				{
					num2 = 1f;
				}
				else
				{
					float num6 = 1f - (0.2f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f);
					float num7 = 1f - num4;
					float num8 = 1f - num5;
					num7 /= num6;
					num8 /= num6;
					num2 = ((num7 < num8) ? num8 : num7);
				}
				num = 0.2f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.1f;
				num3 = 0.5f;
			}
			else
			{
				float num9 = 1.4f - (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f - num4;
				float num10 = 1.3f - (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f - num5;
				num = ((num9 < num10) ? num10 : num9);
				num2 = 0f;
				num3 = 0.3f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.04f;
			}
			UnityEngine.Debug.Log("HitPos : " + HitPos);
			UnityEngine.Debug.Log("HitValue : " + num2);
			UnityEngine.Debug.Log("Value : " + num4 + " " + num5);
			float num11 = UnityEngine.Random.Range(0f, 1f);
			if (num11 < num)
			{
				swing = true;
			}
			if (swing)
			{
				num11 = UnityEngine.Random.Range(0f, 1f);
				if (num2 != 0f)
				{
					UnityEngine.Debug.Log("서세스히트");
				}
				else if (num11 < num3)
				{
					foulHit = true;
				}
				else
				{
					UnityEngine.Debug.Log("헛스윙");
				}
				hitValue = num2;
			}
		}

		private IEnumerator AIHitter_BatSwing(bool _foulHit, float _hitValue, float _dt)
		{
			yield return YieldInstructionCache.WaitForSeconds(_dt - 0.1f);
			if (_foulHit || 0f < _hitValue)
			{
				CatcherCollObj.SetActive(value: false);
			}
			if (AiHitterSwing && !BallMove.GetInstance().deadball)
			{
				Hitter.GetComponent<Animator>().SetTrigger("Swing");
			}
			else if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
			{
				Hitter.GetComponent<Animator>().SetTrigger("StopSwing");
			}
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			Vector3 vector = Vector3.zero;
			bool flag = false;
			if (!BallMove.GetInstance().deadball)
			{
				if (_foulHit)
				{
					Hitter.GetComponent<CapsuleCollider>().enabled = false;
					float num = 0f - UnityEngine.Random.Range(10f, 40f);
					float y = UnityEngine.Random.Range(7f, 60f);
					float num2 = 0f - UnityEngine.Random.Range(10f, 50f) + num;
					if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
					{
						num2 = 0f - num2;
					}
					vector = new Vector3(num2, y, num).normalized * UnityEngine.Random.Range(15f, 70f);
					flag = true;
				}
				else if (0f < _hitValue)
				{
					Hitter.GetComponent<CapsuleCollider>().enabled = false;
					float num3 = UnityEngine.Random.Range(0f, 1f);
					vector = Vector3.zero;
					if (_hitValue == 1f)
					{
						if (num3 < 0.5f)
						{
							vector.x = UnityEngine.Random.Range(0f, 0.9f) - 0.45f;
							vector.z = -0.5f;
							vector.Normalize();
							vector *= UnityEngine.Random.Range(100f, 115f);
							vector.y = UnityEngine.Random.Range(40f, 60f);
							UnityEngine.Debug.Log("홈런");
						}
						else
						{
							vector.x = UnityEngine.Random.Range(0f, 0.9f) - 0.45f;
							vector.z = -0.5f;
							vector.Normalize();
							vector *= UnityEngine.Random.Range(45f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 2f, 70f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 2f);
							vector.y = UnityEngine.Random.Range(5f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level, 25f);
							vector *= BallMove.GetInstance().xReviseValue + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f;
							UnityEngine.Debug.Log("장타");
						}
					}
					else if (0.6f < _hitValue)
					{
						vector.x = UnityEngine.Random.Range(0f, 0.9f) - 0.45f;
						vector.z = -0.5f;
						vector.Normalize();
						vector *= UnityEngine.Random.Range(45f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 2f, 70f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 2f);
						vector.y = UnityEngine.Random.Range(5f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level, 25f);
						vector *= BallMove.GetInstance().xReviseValue + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f;
						UnityEngine.Debug.Log("장타");
					}
					else if (0.3f < _hitValue)
					{
						vector.x = UnityEngine.Random.Range(0f, 0.9f) - 0.45f;
						vector.z = -0.5f;
						vector.Normalize();
						vector *= UnityEngine.Random.Range(20f, 50f);
						vector.y = UnityEngine.Random.Range(0f, 20f);
						vector *= BallMove.GetInstance().xReviseValue + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f;
						UnityEngine.Debug.Log("1루타정도");
					}
					else if (num3 < 0.5f)
					{
						vector.x = UnityEngine.Random.Range(0f, 0.9f) - 0.45f;
						vector.z = -0.5f;
						vector.Normalize();
						vector *= UnityEngine.Random.Range(20f, 50f);
						vector.y = UnityEngine.Random.Range(0f, 20f);
						vector *= BallMove.GetInstance().xReviseValue + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.05f;
						UnityEngine.Debug.Log("1루타정도");
					}
					else
					{
						float num4 = 0f - UnityEngine.Random.Range(10f, 40f);
						float y2 = UnityEngine.Random.Range(7f, 60f);
						float num5 = 0f - UnityEngine.Random.Range(10f, 50f) + num4;
						if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
						{
							num5 = 0f - num5;
						}
						vector = new Vector3(num5, y2, num4).normalized * UnityEngine.Random.Range(15f, 70f);
						UnityEngine.Debug.Log("파울");
					}
					flag = true;
				}
				else
				{
					UnityEngine.Debug.Log("Nope");
				}
			}
			if (flag)
			{
				BallMove.GetInstance().GetComponent<Rigidbody>().velocity = vector;
				BallMove.GetInstance().AddForceCorouStop();
				BallMove.GetInstance().RemoveParticleTrail();
				BallMove.GetInstance().hit = true;
				Call_HitBall(BallMove.GetInstance().transform.position, vector);
				AICatcher.GetInstance().StopAllCoroutines();
				AICatcher.GetInstance().CatcherIdle();
			}
		}

		[PunRPC]
		private void RPC_StreamPos_Baseball(Vector3[] RecieveData)
		{
			for (int i = 0; i < 6; i += 2)
			{
				GetOtherPartsData[i].position = RecieveData[i];
			}
			for (int j = 1; j < 6; j += 2)
			{
				GetOtherPartsData[j].eulerAngles = RecieveData[j];
			}
		}

		[PunRPC]
		private void RPC_AllData(Vector3[] RecieveData)
		{
			switch ((int)RecieveData[0].x)
			{
			case 0:
				RPC_Baseball_ThrowBall(RecieveData);
				break;
			case 1:
				RPC_Baseball_ThrowFailBall(RecieveData);
				break;
			case 2:
				RPC_GrapBall(RecieveData);
				break;
			case 3:
				RPC_CancleBall(RecieveData);
				break;
			case 4:
				RPC_FireBet();
				break;
			case 5:
				RPC_CatchBall_Catcher(RecieveData);
				break;
			case 6:
				RPC_CatchBall_Catcher_Decide(RecieveData);
				break;
			case 7:
				RPC_DeadBall(RecieveData);
				break;
			case 8:
				RPC_Baseball_HitBall(RecieveData);
				break;
			case 9:
				RPC_HomerunRecheck(RecieveData);
				break;
			case 10:
				RPC_EndGameCall(RecieveData);
				break;
			case 11:
				RPC_ScoreData(RecieveData);
				break;
			case 12:
				RPC_PlayerWaiting(RecieveData);
				break;
			case 13:
				RPC_RightPlayer(RecieveData);
				break;
			case 14:
				RPC_LeftPlayer(RecieveData);
				break;
			case 15:
				RPC_GameEndTimeOut();
				break;
			case 16:
				RPC_AllSound();
				break;
			}
		}

		public void RPC_AllData_Public(Vector3[] SendData)
		{
			pView.RPC("RPC_AllData", RpcTarget.Others, SendData);
		}

		private void RPC_Baseball_ThrowBall(Vector3[] RecieveData)
		{
			CbatFollower.GetInstance().failBall = false;
			Vector3 position = RecieveData[1];
			Vector3 velocity = RecieveData[2];
			int num = (int)RecieveData[3].x;
			int curThrow = (int)RecieveData[3].y;
			Vector2 force = RecieveData[4];
			GameObject gameObject = UnityEngine.Object.Instantiate(BallPF, position, Quaternion.identity);
			gameObject.GetComponent<Rigidbody>().velocity = velocity;
			gameObject.GetComponent<SphereCollider>().enabled = true;
			gameObject.GetComponent<BallMove>().Call_CatcherHandCorou();
			gameObject.GetComponent<BallMove>().MultiBallAddForce(force);
			gameObject.GetComponent<BallMove>().curThrow = (Throw)curThrow;
			if (num == 4)
			{
				Call_PlaySound(SoundTrack.FireBall);
			}
			else
			{
				Call_PlaySound(SoundTrack.Throw);
			}
			if (num != 4)
			{
				gameObject.GetComponent<BallMove>().CreateParticleTrail();
			}
			else
			{
				gameObject.GetComponent<BallMove>().CreateParticleTrail(1);
			}
			CbatFollower.GetInstance().swing = false;
			if (CbatFollower.GetInstance().FireBat.activeSelf)
			{
				Vector3[] array = new Vector3[1];
				array[0].x = 4f;
				pView.RPC("RPC_AllData", RpcTarget.Others, array);
			}
		}

		private void RPC_Baseball_ThrowFailBall(Vector3[] RecieveData)
		{
			CbatFollower.GetInstance().failBall = true;
			Vector3 position = RecieveData[1];
			Vector3 velocity = RecieveData[2];
			Vector3 angularVelocity = RecieveData[3];
			GameObject gameObject = UnityEngine.Object.Instantiate(BallPF, position, Quaternion.identity);
			gameObject.GetComponent<SphereCollider>().enabled = true;
			gameObject.GetComponent<Rigidbody>().velocity = velocity;
			gameObject.GetComponent<Rigidbody>().angularVelocity = angularVelocity;
			gameObject.GetComponent<BallMove>().CreateParticleTrail();
			Call_PlaySound(SoundTrack.Throw);
			StartCoroutine(FailBallCorou(gameObject));
		}

		private void RPC_GrapBall(Vector3[] RecieveData)
		{
			BallImageParent_Other.transform.GetChild(0).gameObject.SetActive(value: true);
		}

		private void RPC_CancleBall(Vector3[] RecieveData)
		{
			BallImageParent_Other.transform.GetChild(0).gameObject.SetActive(value: false);
			BallImageParent_Other.transform.GetChild(1).gameObject.SetActive(value: false);
		}

		private void RPC_FireBet()
		{
			BetImage_Normal.SetActive(value: false);
			BetImage_Fire.SetActive(value: true);
		}

		private void RPC_CatchBall_Catcher(Vector3[] RecieveData)
		{
			int num = (int)RecieveData[1].x;
			Vector3 position = RecieveData[2];
			BallMove.GetInstance().transform.position = position;
			BallMove.GetInstance().BallStop();
			BallMove.GetInstance().AddForceCorouStop();
			Call_PlaySound(SoundTrack.Tack);
			BallMove.GetInstance().BallDestroy(1.3f);
			switch (num)
			{
			case 1:
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[4], BallMove.GetInstance().transform.position, Quaternion.identity), 0.75f);
				break;
			case 2:
				UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[5], BallMove.GetInstance().transform.position, Quaternion.identity), 0.75f);
				break;
			}
			BallMove.GetInstance().Call_StopCatcher();
		}

		private void RPC_CatchBall_Catcher_Decide(Vector3[] RecieveData)
		{
			switch ((int)RecieveData[1].x)
			{
			case 1:
				CatchStrike();
				break;
			case 2:
				CatchBall();
				break;
			}
		}

		private void RPC_DeadBall(Vector3[] RecieveData)
		{
			Vector3 position = RecieveData[1];
			Vector3 velocity = RecieveData[2];
			float x = RecieveData[3].x;
			Call_PlaySound(SoundTrack.WildThrow);
			Call_PlaySound(SoundTrack.Tack);
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(gParticle.ParticleArray[5], position, Quaternion.identity), 0.75f);
			BallMove.GetInstance().deadball = true;
			BallMove.GetInstance().AddForceCorouStop();
			BallMove.GetInstance().Call_StopCatcher();
			BallMove.GetInstance().BallDestroy(3f);
			BallMove.GetInstance().transform.position = position;
			BallMove.GetInstance().GetComponent<Rigidbody>().velocity = velocity;
			BallMove.GetInstance().GetComponent<SphereCollider>().enabled = true;
			if (x != 1f)
			{
				Call_PlaySound(SoundTrack.DeadBall);
				ActiveTextUI(SoundTrack.DeadBall);
				Call_SBOReset(2f);
				DefenderManager.GetInstance().BallAdvantage();
			}
		}

		private void RPC_Baseball_HitBall(Vector3[] RecieveData)
		{
			Vector3 vector = RecieveData[1];
			Vector3 vector2 = RecieveData[2];
			BallMove.GetInstance().AddForceCorouStop();
			BallMove.GetInstance().RemoveParticleTrail();
			BallMove.GetInstance().transform.position = vector;
			BallMove.GetInstance().GetComponent<Rigidbody>().velocity = vector2;
			BallMove.GetInstance().GetComponent<SphereCollider>().enabled = true;
			BallMove.GetInstance().hit = true;
			BallMove.GetInstance().foul = false;
			BallMove.GetInstance().homerun = false;
			BallMove.GetInstance().curFenceHit = false;
			Call_HitBall(vector, vector2);
		}

		private void RPC_HomerunRecheck(Vector3[] RecieveData)
		{
			BallMove.GetInstance().multiHomerunCheck = true;
		}

		private void RPC_EndGameCall(Vector3[] RecieveData)
		{
			GameEnd();
		}

		private void RPC_EndGameTimeOut(Vector3[] RecieveData)
		{
			GameEnd();
		}

		private void RPC_ScoreData(Vector3[] RecieveData)
		{
			CsGameData.Instance.firstScore = (int)RecieveData[1].x;
			CsGameData.Instance.secondScore = (int)RecieveData[1].y;
			CsGameData.Instance.InningScore_1[0] = (int)RecieveData[2].x;
			CsGameData.Instance.InningScore_1[1] = (int)RecieveData[2].y;
			CsGameData.Instance.InningScore_1[2] = (int)RecieveData[2].z;
			CsGameData.Instance.InningScore_2[0] = (int)RecieveData[3].x;
			CsGameData.Instance.InningScore_2[1] = (int)RecieveData[3].y;
			CsGameData.Instance.InningScore_2[2] = (int)RecieveData[3].z;
			FirstScoreText.text = CsGameData.Instance.firstScore.ToString();
			SecondScoreText.text = CsGameData.Instance.secondScore.ToString();
			SideScript.GetComponent<CsScoreBoardUI>().Func_ActiveOnOff();
		}

		private void RPC_PlayerWaiting(Vector3[] RecieveData)
		{
		}

		private void RPC_RightPlayer(Vector3[] RecieveData)
		{
			BallImageParent_Other.transform.SetParent(OtherPartsTrs[3]);
			BallImageParent_Other.transform.localPosition = new Vector3(-0.307f, 0.171f, 0f);
			BallImageParent_Other.transform.localEulerAngles = new Vector3(90f, 0f, 90f);
			BetImage_Other.transform.SetParent(OtherPartsTrs[3]);
			BetImage_Other.transform.localPosition = new Vector3(0f, 0f, 0f);
			BetImage_Other.transform.localEulerAngles = new Vector3(60f, 130f, 90f);
			if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				OtherPartsTrs[3].localEulerAngles = new Vector3(0f, 0f, 90f);
			}
		}

		private void RPC_LeftPlayer(Vector3[] RecieveData)
		{
			BallImageParent_Other.transform.SetParent(OtherPartsTrs[5]);
			BallImageParent_Other.transform.localPosition = new Vector3(-0.307f, 0.19f, 0f);
			BallImageParent_Other.transform.localEulerAngles = new Vector3(90f, 0f, 90f);
			BetImage_Other.transform.SetParent(OtherPartsTrs[5]);
			BetImage_Other.transform.localPosition = new Vector3(0f, 0f, 0f);
			BetImage_Other.transform.localEulerAngles = new Vector3(60f, 130f, 90f);
			if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				OtherPartsTrs[5].localEulerAngles = new Vector3(0f, 0f, 90f);
			}
		}

		public string GetOtherNick()
		{
			string text = "";
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
				}
				return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			}
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
		}

		public string GetOtherId()
		{
			string text = "";
			if (PhotonNetwork.IsMasterClient)
			{
				return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id;
			}
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id;
		}

		public string GetMyNick()
		{
			string text = "";
			if (PhotonNetwork.IsMasterClient)
			{
				return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			}
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
		}

		public string GetMyId()
		{
			string text = "";
			if (PhotonNetwork.IsMasterClient)
			{
				return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id;
			}
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id;
		}

		public string GetFirstNick()
		{
			string text = "";
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			}
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
		}

		public string GetFirstId()
		{
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id;
		}

		public string GetSecondNick()
		{
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
		}

		public string GetSecondId()
		{
			return SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id;
		}

		public void MultiCharActive(bool _bool)
		{
			OtherChar.SetActive(_bool);
			for (int i = 0; i < OtherPartsTrs.Length; i++)
			{
				OtherPartsTrs[i].gameObject.SetActive(_bool);
			}
		}
	}
	public enum RPC_Type
	{
		ThrowBall,
		ThrowFailBall,
		GrapBall,
		CancleBall,
		FireBet,
		CatchBall_Catcher,
		CatchBall_Catcher_Decide,
		DeadBall,
		HitBall,
		HomerunRecheck,
		EndGameCall,
		ScoreData,
		PlayerWaiting,
		RightPlayer,
		LeftPlayer,
		EndGameTimeOut,
		AllSound
	}
	public class CbatFollower : MonoBehaviour
	{
		private static CbatFollower instance;

		public bool swing;

		public GameObject HitterColl;

		public Transform SphereColl;

		public Transform dumm;

		public Transform CollPoint;

		public GameObject HitBallTrs;

		private GameObject[] dumies = new GameObject[15];

		private Vector3[,] mVelsOldPos;

		public int _MaxCount;

		private int _CurCount;

		private Vector3[] oldPos;

		private Vector3[] mVels;

		public bool _testVel;

		public Vector3 TestVel;

		public Transform[] ArrColl;

		public const float CutSpeed = 110f;

		public const float MissCutSpeed = 70f;

		public const float WeakAngle = 10f;

		public Transform RightCont;

		public Transform LeftCont;

		private UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

		private UnityEngine.XR.Interaction.Toolkit.XRController RightController;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		public GameObject NormalBat;

		public GameObject FireBat;

		public Text FireBatText;

		public Text TESTTEST;

		private float[] angle = new float[5];

		private int angleStack;

		private Vector3 CurPos;

		private Vector3 PrePos;

		private Vector3[] TEMPVEC = new Vector3[5];

		private int stack;

		public Transform HeadTrs;

		public Transform CurTrs;

		public Transform RightTrs;

		public Transform LeftTrs;

		public Transform HeadChildTrs;

		public Transform HeadChildTrs_Right;

		public Transform HeadChildTrs_Left;

		private bool isRight = true;

		private float contAngle;

		private int contCheck;

		private bool inAngle;

		private Vector3 CheckVel = Vector3.zero;

		public bool failBall;

		private bool hitCheck;

		private Vector3 ResultVel = Vector3.zero;

		private float _debugTime = 8f;

		private float inangleDt;

		private float HapTicValue = 0.5f;

		private float HapTicDuration = 0.5f;

		public static CbatFollower GetInstance()
		{
			return instance;
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (!PublicGameUIManager.gameSetting.IsRightHanded() && obj)
			{
				FireBatActive();
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (PublicGameUIManager.gameSetting.IsRightHanded() && obj)
			{
				FireBatActive();
			}
		}

		private void FireBatActive()
		{
			if (!(BallMove.GetInstance() != null) && CsGameData.Instance.fireBetCount > 0 && CsGameData.Instance.curTeam != TeamPosition.Defense && CsGameData.Instance.curMode != 0)
			{
				NormalBat.SetActive(FireBat.activeSelf);
				FireBat.SetActive(!FireBat.activeSelf);
			}
		}

		public void ItemFireBat()
		{
			NormalBat.SetActive(value: false);
			FireBat.SetActive(value: true);
		}

		private void UseFireBat()
		{
			if (FireBat.activeSelf && !failBall)
			{
				CsGameData.Instance.fireBetCount--;
				FireBatText.text = "x " + CsGameData.Instance.fireBetCount;
				NormalBat.SetActive(value: true);
				FireBat.SetActive(value: false);
			}
		}

		private void Awake()
		{
			instance = this;
			initDumy(_MaxCount);
			failBall = false;
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
			LeftController = LeftCont.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightCont.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
		}

		private void Start()
		{
			FireBatText.text = "x " + CsGameData.Instance.fireBetCount;
		}

		private void FixedUpdate()
		{
			PrePos = CurPos;
			CurPos = dumies[7].transform.position;
			Vector3 vector = (CurPos - PrePos) / Time.fixedDeltaTime;
			if (vector != Vector3.zero)
			{
				TEMPVEC[stack] = vector;
				stack++;
				if (stack == 5)
				{
					stack = 0;
				}
			}
			if (!swing && ArrColl[14].transform.position.x < 2f && ArrColl[14].transform.position.z < ArrColl[0].transform.position.z)
			{
				swing = true;
			}
			Vector3 forward = HeadTrs.forward;
			forward.Normalize();
			Vector3 to = CurTrs.position - HeadTrs.position;
			contAngle = Vector3.Angle(forward, to);
			if (ArrColl[5].GetComponent<Rigidbody>().velocity != Vector3.zero)
			{
				CheckVel = ArrColl[5].GetComponent<Rigidbody>().velocity;
			}
			Vector3 vector2 = Vector3.zero;
			Vector3 zero = Vector3.zero;
			if (100f < contAngle)
			{
				inAngle = true;
				inangleDt = 0f;
			}
			else
			{
				ResetInangle();
			}
			if (inAngle)
			{
				float y = HeadTrs.position.y * 0.6f;
				Vector3 vector3 = HeadChildTrs.position - HeadTrs.position;
				vector3.y = 0f;
				vector2 = HeadTrs.position + vector3.normalized;
				vector2.y = y;
				for (int i = 0; i < ArrColl.Length; i++)
				{
					ArrColl[i].localScale = new Vector3(2.1f, 2.1f, 2.1f);
				}
				for (int j = 0; j < dumies.Length; j++)
				{
					Vector3 velocity = (dumies[j].transform.position - ArrColl[j].position) / Time.fixedDeltaTime;
					ArrColl[j].GetComponent<Rigidbody>().velocity = velocity;
				}
			}
			zero = ((!inAngle) ? CollPoint.position : vector2);
			base.transform.position = zero;
			base.transform.rotation = CollPoint.rotation;
			if (inAngle)
			{
				return;
			}
			bool flag = false;
			if (15f < ((dumies[dumies.Length - 1].transform.position - ArrColl[dumies.Length - 1].position) / Time.fixedDeltaTime).magnitude)
			{
				flag = true;
			}
			for (int k = 0; k < dumies.Length; k++)
			{
				Vector3 velocity2 = (dumies[k].transform.position - ArrColl[k].position) / Time.fixedDeltaTime;
				if (flag)
				{
					velocity2 *= 0.5f;
				}
				ArrColl[k].GetComponent<Rigidbody>().velocity = velocity2;
			}
		}

		private void Update()
		{
			if (LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
			{
				OnTriggerL.CurrentData = isPressed;
			}
			if (RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
			{
				OnTriggerR.CurrentData = isPressed2;
			}
		}

		public void initDumy(int dumyCnt)
		{
			Vector3 position = base.transform.position;
			float num = 0.2f;
			ArrColl = new Transform[dumyCnt];
			for (int i = 0; i < dumyCnt; i++)
			{
				GameObject gameObject = new GameObject("Follow");
				gameObject.transform.position = position;
				gameObject.transform.parent = base.transform.GetChild(2);
				dumies[i] = gameObject.gameObject;
				position.z -= num;
				ArrColl[i] = UnityEngine.Object.Instantiate(SphereColl, new Vector3(0f, 3f, 50f), Quaternion.identity);
				ArrColl[i].GetComponent<VelocityColl>().gBat = GetComponent<CbatFollower>();
				ArrColl[i].GetComponent<VelocityColl>().id = i;
			}
			mVelsOldPos = new Vector3[dumies.Length, _MaxCount];
			oldPos = new Vector3[dumies.Length];
			mVels = new Vector3[dumies.Length];
			for (int j = 0; j < dumies.Length; j++)
			{
				oldPos[j] = dumies[j].transform.position;
			}
			base.transform.GetChild(2).localEulerAngles = new Vector3(315f, 0f, 0f);
		}

		public void EnterFunc(Vector3 CollCenter, Vector3 cPoint, int i)
		{
			if (!hitCheck && !failBall)
			{
				hitCheck = true;
				int num = stack - 1;
				if (num == -1)
				{
					num = 4;
				}
				Vector3 onePreVel = BallMove.GetInstance().OnePreVel;
				if (FireBat.activeSelf)
				{
					ResultVel = GetResultVel(cPoint, ArrColl[0].position, ArrColl[14].position, BallMove.GetInstance().transform.position, TEMPVEC[num], onePreVel, CsGameData.Instance.bBounce, "Pocket", 0.55f, fireBat: true);
				}
				else
				{
					ResultVel = GetResultVel(cPoint, ArrColl[0].position, ArrColl[14].position, BallMove.GetInstance().transform.position, TEMPVEC[num], onePreVel, CsGameData.Instance.bBounce, "Pocket", 0.55f, fireBat: false);
				}
				if (PublicGameUIManager.gameSetting.IsRightHanded())
				{
					HapticPulse(RightController);
				}
				else
				{
					HapticPulse(LeftController);
				}
				SetSphereCollEnabled(_bool: false);
				HitterColl.SetActive(value: false);
				BallMove.GetInstance().hit = true;
				BallMove.GetInstance().AddForceCorouStop();
				BallMove.GetInstance().transform.GetChild(0).gameObject.SetActive(value: false);
				BallMove.GetInstance().RemoveParticleTrail();
				BallMove.GetInstance().GetComponent<Rigidbody>().velocity = ResultVel;
				StartCoroutine(Corou_NextConfirm());
			}
		}

		private IEnumerator Corou_NextConfirm()
		{
			yield return null;
			BallMove.GetInstance().transform.GetChild(0).gameObject.SetActive(value: true);
			BaseballManager.GetInstance().Call_HitBall(BallMove.GetInstance().transform.position, BallMove.GetInstance().GetComponent<Rigidbody>().velocity);
		}

		public void SetSphereCollEnabled(bool _bool)
		{
			for (int i = 0; i < ArrColl.Length; i++)
			{
				ArrColl[i].GetComponent<SphereCollider>().enabled = _bool;
			}
			if (_bool)
			{
				hitCheck = false;
				HitterColl.SetActive(value: true);
				UseFireBat();
			}
		}

		public void CallIsRightSet(bool _bool)
		{
			if (_bool)
			{
				CurTrs = RightTrs;
				HeadChildTrs = HeadChildTrs_Right;
			}
			else
			{
				CurTrs = LeftTrs;
				HeadChildTrs = HeadChildTrs_Left;
			}
			isRight = _bool;
		}

		public bool GetInAngle()
		{
			return inAngle;
		}

		public Vector3 GetAngleVelocity()
		{
			Vector3 result = Vector3.zero;
			Vector3 value2;
			if (isRight && RightController.inputDevice.TryGetFeatureValue(CommonUsages.deviceAngularVelocity, out var value))
			{
				result = value;
			}
			else if (!isRight && LeftController.inputDevice.TryGetFeatureValue(CommonUsages.deviceAngularVelocity, out value2))
			{
				result = value2;
			}
			return result;
		}

		public Vector3 GetResultVel(Vector3 CollPoint, Vector3 BatPos, Vector3 BatHeadPos, Vector3 BallPos, Vector3 BatVel, Vector3 BallVel, float bonuce, string CollName, float ballScale, bool fireBat)
		{
			Vector3 normalized = (BatHeadPos - BatPos).normalized;
			Vector3 rhs = BallPos - BatPos;
			float num = Vector3.Dot(normalized, rhs);
			Vector3 vector = BatPos + normalized * num;
			Vector3 to = BallPos - CollPoint;
			Vector3.Angle(BatVel.normalized, BallPos - vector);
			Vector3.Angle(BatVel.normalized, to);
			Ray ray = new Ray(CollPoint - BallMove.GetInstance().OnePreVel.normalized * 5f, BallMove.GetInstance().OnePreVel);
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray, out hitInfo, 7f, 1 << LayerMask.NameToLayer(CollName)))
			{
				CollPoint = hitInfo.point;
				BallPos = CollPoint - BallVel.normalized * ballScale;
				rhs = BallPos - BatPos;
				num = Vector3.Dot(normalized, rhs);
				vector = BatPos + normalized * num;
			}
			Vector3 to2 = BallPos - CollPoint;
			Vector3 to3 = CollPoint - BallPos;
			float num2 = Vector3.Angle(BatVel.normalized, to2);
			float num3 = Vector3.Angle(BallVel.normalized, to3);
			float num4 = 0f;
			Vector3 normalized2 = (BallPos - vector).normalized;
			float num5 = Mathf.Cos((float)Math.PI / 180f * num2);
			num4 = Mathf.Cos((float)Math.PI / 180f * num3);
			float magnitude = (BatVel * num5).magnitude;
			float magnitude2 = (BallVel * num4).magnitude;
			Vector3 result = (magnitude + magnitude2) * normalized2 * (bonuce + 1f) + BallVel;
			if (fireBat)
			{
				Vector3 vector2 = new Vector3(0f, 0.5f, -1f);
				float magnitude3 = result.magnitude;
				magnitude3 *= 3.5f;
				Vector3 normalized3 = (result.normalized * 0.3f + vector2.normalized * 0.7f).normalized;
				result = normalized3 * magnitude3;
				if (110f < result.magnitude + 10f)
				{
					result = normalized3 * 120f;
				}
			}
			else
			{
				Vector3 vector3 = BatVel;
				vector3.x = 0f;
				if (0f < vector3.z)
				{
					vector3.z *= -1f;
				}
				if (!inAngle)
				{
					float magnitude4 = result.magnitude;
					Vector3 normalized4 = result.normalized;
					normalized4.x *= CsGameData.Instance.bAngle;
					result = normalized4.normalized * magnitude4;
					result *= 0.75f;
					if (15f <= BatVel.magnitude && BatVel.magnitude <= 35f)
					{
						result *= 1.35f;
					}
					else if (35f <= BatVel.magnitude && BatVel.magnitude <= 60f)
					{
						result *= 1.2f;
					}
					else if (60f <= BatVel.magnitude)
					{
						result *= 1.1f;
					}
					Vector3 normalized5 = result.normalized;
					if (25f < result.magnitude && 0.5f < normalized5.y)
					{
						normalized5.y = 0.5f + (normalized5.y - 0.5f) * 0.5f;
						normalized5.Normalize();
					}
					if (30f < result.magnitude)
					{
						float num6 = UnityEngine.Random.Range(0.05f, 0.15f);
						if (result.y < result.magnitude * (num6 + BatVel.normalized.y))
						{
							Vector3 vector4 = result;
							vector4.y = result.magnitude * (num6 + BatVel.normalized.y);
							normalized5 = vector4.normalized;
						}
					}
					Vector3 vector5 = new Vector3(normalized5.x, 0f, normalized5.z);
					vector5.Normalize();
					if (Mathf.Abs(vector5.z) - Mathf.Abs(vector5.x) < 0.2f)
					{
						normalized5.z -= Mathf.Abs(normalized5.x) * 0.5f;
						normalized5.Normalize();
					}
					result = normalized5 * result.magnitude;
					if (result.y < 1f && 55f < result.magnitude)
					{
						result = normalized5 * 55f;
					}
					if (110f < result.magnitude)
					{
						result = normalized5 * 110f;
					}
				}
				else
				{
					Vector3 position = ArrColl[0].position;
					Vector3 position2 = ArrColl[10].position;
					Vector3 normalized6 = (CollPoint - vector).normalized;
					Vector3 to4 = position2 - position;
					to4.y = 0f;
					float num7 = Vector3.Angle(Vector3.forward, to4) - 90f;
					normalized6 = Vector3.zero;
					float num8 = num7 * 0.01f;
					float z = -1f + Mathf.Abs(num8);
					if (1f < Mathf.Abs(num8))
					{
						z = 0f;
					}
					normalized6 = new Vector3(num8, 0f, z);
					normalized6.y = UnityEngine.Random.Range(0.2f, 0.3f) + BatVel.normalized.y;
					normalized6.Normalize();
					if (25f < result.magnitude && 0.5f < normalized6.y)
					{
						normalized6.y = 0.5f + (normalized6.y - 0.5f) * 0.5f;
						normalized6.Normalize();
					}
					Vector3 vector6 = new Vector3(normalized6.x, 0f, normalized6.z);
					vector6.Normalize();
					if (Mathf.Abs(vector6.z) - Mathf.Abs(vector6.x) < 0.2f)
					{
						normalized6.z -= Mathf.Abs(normalized6.x) * 0.5f;
						normalized6.Normalize();
					}
					if (10f <= BatVel.magnitude && BatVel.magnitude <= 20f)
					{
						result = normalized6 * (result.magnitude * 1.6f);
					}
					else if (20f <= BatVel.magnitude && BatVel.magnitude <= 30f)
					{
						result = normalized6 * (result.magnitude * 1.4f);
					}
					else if (30f <= BatVel.magnitude && BatVel.magnitude <= 45f)
					{
						result = normalized6 * (result.magnitude * 1.25f);
					}
					else if (45f <= BatVel.magnitude)
					{
						result = normalized6 * (result.magnitude * 1.1f);
					}
					if (result.y < 1f && 55f < result.magnitude)
					{
						result = normalized6 * 55f;
					}
					if (10f < Mathf.Abs(num7) && 70f < result.magnitude)
					{
						result = normalized6 * 70f;
					}
					else if (Mathf.Abs(num7) < 10f && 110f < result.magnitude)
					{
						num8 = num7 * 0.045f;
						z = -1f + Mathf.Abs(num8);
						normalized6 = new Vector3(num8, 0.4f, z);
						normalized6.Normalize();
						result = normalized6 * 110f;
					}
				}
			}
			return result;
		}

		private void ResetInangle()
		{
			inangleDt += Time.deltaTime;
			if (0.1f < inangleDt && inAngle)
			{
				inangleDt = 0f;
				inAngle = false;
				for (int i = 0; i < ArrColl.Length; i++)
				{
					ArrColl[i].localScale = new Vector3(0.9f, 0.9f, 0.9f);
				}
			}
		}

		public void HapticPulse(UnityEngine.XR.Interaction.Toolkit.XRController controller)
		{
			if (controller.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				controller.inputDevice.SendHapticImpulse(0u, HapTicValue * PublicGameUIManager.gameSetting.GetHapticValue(), HapTicDuration);
			}
		}
	}
	public class ChandThrow : MonoBehaviour
	{
		private static ChandThrow instance;

		private bool outLine;

		public Transform PlayerTrs;

		public Transform CameraTrs;

		public Transform RightCont;

		public Transform LeftCont;

		public GameObject BallImage;

		public GameObject BallImage_FireBall;

		public Transform SelectParent;

		private Transform[] SelectBall;

		private GameObject[] SelectObj;

		private GameObject[] NoSelectObj;

		public Animator gAnimator;

		private int select;

		private bool check;

		private int curSelect;

		private UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

		private UnityEngine.XR.Interaction.Toolkit.XRController RightController;

		private Appnori.Util.Notifier<bool> OnTriggerL = new Appnori.Util.Notifier<bool>();

		private Appnori.Util.Notifier<bool> OnTriggerR = new Appnori.Util.Notifier<bool>();

		private float HapTicValue = 0.5f;

		private float HapTicDuration = 0.1f;

		public static ChandThrow GetInstance()
		{
			return instance;
		}

		private void Start()
		{
			instance = this;
			SelectBall = new Transform[5];
			SelectObj = new GameObject[5];
			NoSelectObj = new GameObject[5];
			for (int i = 0; i < 5; i++)
			{
				SelectBall[i] = SelectParent.GetChild(i);
				SelectObj[i] = SelectParent.GetChild(i).GetChild(1).gameObject;
				NoSelectObj[i] = SelectParent.GetChild(i).GetChild(2).gameObject;
			}
			OnTriggerL.OnDataChanged += OnTriggerL_OnDataChanged;
			OnTriggerR.OnDataChanged += OnTriggerR_OnDataChanged;
			LeftController = LeftCont.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			RightController = RightCont.GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.A))
			{
				StartCoroutine(TestThrow());
			}
			bool flag = false;
			if (SelectParent.gameObject.activeSelf)
			{
				for (int i = 0; i < 5; i++)
				{
					if ((BallImage.transform.position - SelectBall[i].position).magnitude < 0.4f && SelectBall[i].gameObject.activeSelf)
					{
						select = i;
						flag = true;
						if (!SelectObj[i].activeSelf)
						{
							SelectObj[i].SetActive(value: true);
							NoSelectObj[i].SetActive(value: false);
						}
						break;
					}
				}
				if (!flag)
				{
					for (int j = 0; j < 5; j++)
					{
						if (SelectObj[j].activeSelf)
						{
							SelectObj[j].SetActive(value: false);
							NoSelectObj[j].SetActive(value: true);
						}
					}
				}
			}
			check = flag;
			Vector3 vector = PlayerTrs.transform.position - CameraTrs.transform.position;
			vector.y = 0f;
			if (3f < vector.magnitude)
			{
				outLine = true;
			}
			else
			{
				outLine = false;
			}
			if (outLine)
			{
				if (BallImage.activeSelf || BallImage_FireBall.activeSelf)
				{
					BallImage.SetActive(value: false);
					BallImage_FireBall.SetActive(value: false);
					SelectParent.gameObject.SetActive(value: true);
				}
				return;
			}
			if (LeftController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, 0.5f))
			{
				OnTriggerL.CurrentData = isPressed;
			}
			if (RightController.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed2, 0.5f))
			{
				OnTriggerR.CurrentData = isPressed2;
			}
		}

		private IEnumerator TestThrow()
		{
			select = 0;
			BallImage.SetActive(value: true);
			SelectParent.gameObject.SetActive(value: false);
			curSelect = select;
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			BallImage.SetActive(value: false);
			BallImage_FireBall.SetActive(value: false);
			SelectParent.gameObject.SetActive(value: true);
			UnityEngine.Debug.Log("Throw Ball");
			BaseballManager.GetInstance().Call_PlayerThrowBall(0, new Vector3(-0.1f, 6f, 10f), TestBool: true);
		}

		private void ThrowFunc(bool obj)
		{
			if (obj)
			{
				if (check)
				{
					if (select == 4)
					{
						BallImage_FireBall.SetActive(value: true);
					}
					else
					{
						BallImage.SetActive(value: true);
					}
					SelectParent.gameObject.SetActive(value: false);
					curSelect = select;
					BaseballManager.GetInstance().SeeBallParent.SetActive(value: true);
					if (PublicGameUIManager.gameSetting.IsRightHanded())
					{
						HapticPulse(RightController);
					}
					else
					{
						HapticPulse(LeftController);
					}
					if (CsGameData.Instance.curState == State.Multi)
					{
						Vector3[] array = new Vector3[2];
						array[0].x = 2f;
						array[1].x = select;
						BaseballManager.GetInstance().RPC_AllData_Public(array);
					}
				}
			}
			else
			{
				if (!BallImage.activeSelf && !BallImage_FireBall.activeSelf)
				{
					return;
				}
				BallImage.SetActive(value: false);
				BallImage_FireBall.SetActive(value: false);
				SelectParent.gameObject.SetActive(value: true);
				if (CsGameData.Instance.curState == State.Multi)
				{
					Vector3[] array2 = new Vector3[1];
					array2[0].x = 3f;
					BaseballManager.GetInstance().RPC_AllData_Public(array2);
				}
				if (2.7f < CsHandRigid.GetInstance().GetVel().magnitude)
				{
					if (!BaseballManager.GetInstance().Call_CheckSuccessBall(BallImage.transform.position))
					{
						BaseballManager.GetInstance().Call_PlayerThrowBall_Fail(BallImage.transform.position, BallImage.transform.rotation);
					}
					else
					{
						BaseballManager.GetInstance().Call_PlayerThrowBall(curSelect, BallImage.transform.position);
					}
				}
				else
				{
					BaseballManager.GetInstance().SeeBallParent.SetActive(value: false);
				}
			}
		}

		private void OnTriggerL_OnDataChanged(bool obj)
		{
			if (!PublicGameUIManager.gameSetting.IsRightHanded())
			{
				ThrowFunc(obj);
			}
		}

		private void OnTriggerR_OnDataChanged(bool obj)
		{
			if (PublicGameUIManager.gameSetting.IsRightHanded())
			{
				ThrowFunc(obj);
			}
		}

		public void HapticPulse(UnityEngine.XR.Interaction.Toolkit.XRController controller)
		{
			if (controller.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				controller.inputDevice.SendHapticImpulse(0u, HapTicValue * PublicGameUIManager.gameSetting.GetHapticValue(), HapTicDuration);
			}
		}
	}
	public enum Bonus
	{
		None = -1,
		x2,
		x3,
		FireBat,
		Life
	}
	public class CsBonus : MonoBehaviour
	{
		private static CsBonus instance;

		private Bonus BonusType = Bonus.FireBat;

		public GameObject[] BonusObj;

		private GameObject EffIdle;

		private GameObject EffHit;

		private Animator gAni;

		public static CsBonus GetInstance()
		{
			return instance;
		}

		private void Awake()
		{
			instance = this;
			gAni = GetComponent<Animator>();
			EffIdle = BonusObj[(int)BonusType].transform.GetChild(0).gameObject;
			EffHit = BonusObj[(int)BonusType].transform.GetChild(1).gameObject;
			EffIdle.SetActive(value: true);
			EffHit.SetActive(value: false);
		}

		public void HitBonus()
		{
			switch (BonusType)
			{
			case Bonus.x2:
				CsGameData.Instance.numMultiple = 2;
				break;
			case Bonus.x3:
				CsGameData.Instance.numMultiple = 3;
				break;
			case Bonus.Life:
				if (0 < BaseballManager.GetInstance().outCount)
				{
					BaseballManager.GetInstance().outCount--;
				}
				break;
			}
			BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Bonus_Hit);
			GetComponent<BoxCollider>().enabled = false;
			CsGameData.Instance.curBonus = BonusType;
			StartCoroutine(Delay_Eff());
		}

		private IEnumerator Delay_Eff()
		{
			EffIdle.SetActive(value: false);
			EffHit.SetActive(value: true);
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			EffHit.SetActive(value: false);
		}

		public void SetRandomBonus()
		{
			int max = 3;
			if (0 < BaseballManager.GetInstance().outCount)
			{
				max = 4;
			}
			BonusType = (Bonus)UnityEngine.Random.Range(0, max);
			for (int i = 0; i < BonusObj.Length; i++)
			{
				BonusObj[i].SetActive(value: false);
			}
			BonusObj[(int)BonusType].SetActive(value: true);
		}

		public void SetRandomPos()
		{
			gAni.SetTrigger("RePos");
			GetComponent<BoxCollider>().enabled = true;
			Vector3 zero = Vector3.zero;
			zero.x = UnityEngine.Random.Range(-130f, 130f);
			zero.y = UnityEngine.Random.Range(30f, 40f);
			zero.z = UnityEngine.Random.Range(-80f, -100f);
			base.transform.position = zero;
			Vector3 zero2 = Vector3.zero;
			zero2.y = base.transform.position.y;
			base.transform.LookAt(zero2);
			Vector3 eulerAngles = base.transform.eulerAngles;
			eulerAngles.y += 180f;
			base.transform.eulerAngles = eulerAngles;
			EffIdle = BonusObj[(int)BonusType].transform.GetChild(0).gameObject;
			EffHit = BonusObj[(int)BonusType].transform.GetChild(1).gameObject;
			EffIdle.SetActive(value: true);
			EffHit.SetActive(value: false);
			BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Bonus_Open);
		}
	}
	public enum DefenderState
	{
		None,
		Catch,
		OnlyRun,
		HitBall,
		BallFowrd
	}
	public class CsDefender : MonoBehaviour
	{
		private Animator gAnimator;

		private DefenderState curState;

		private float catchDis = 0.75f;

		private int id;

		private float speed;

		private Transform MyBaseTrs;

		private Transform[] Base;

		public int curBase;

		public Transform RHandTrs;

		public Transform LHandTrs;

		public GameObject PaticlePF;

		private IEnumerator Moving_Ienum;

		private void Start()
		{
			gAnimator = GetComponent<Animator>();
			RHandTrs = base.transform.GetChild(0).GetChild(1).GetChild(0)
				.GetChild(0)
				.GetChild(0)
				.GetChild(2)
				.GetChild(0)
				.GetChild(0)
				.GetChild(0)
				.GetChild(2);
			LHandTrs = base.transform.GetChild(0).GetChild(1).GetChild(0)
				.GetChild(0)
				.GetChild(0)
				.GetChild(1)
				.GetChild(0)
				.GetChild(0)
				.GetChild(0)
				.GetChild(2);
		}

		public void SetDataDef(int _i, float _speed, Transform _MyBasePos, Transform[] _GetBase)
		{
			id = _i;
			speed = _speed;
			MyBaseTrs = _MyBasePos;
			Base = new Transform[_GetBase.Length];
			Base = _GetBase;
			if (id == 0)
			{
				curBase = 4;
			}
			else if (id == 4)
			{
				curBase = 2;
			}
			else if (id < 4)
			{
				curBase = id;
			}
		}

		public int GetID()
		{
			return id;
		}

		public float GetSpeed()
		{
			return speed;
		}

		public Vector3 GetMyBasePos()
		{
			return MyBaseTrs.position;
		}

		public void ResetAnimator()
		{
			if (id != 0 && id == 8)
			{
				gAnimator.SetBool("HIT", value: false);
				gAnimator.SetInteger("Throw_", 0);
			}
			if (id != 8)
			{
				gAnimator.SetBool("BaseCatch", value: false);
			}
			gAnimator.SetBool("FlyBall", value: false);
			gAnimator.SetBool("CatchFlyBall", value: false);
			gAnimator.SetFloat("Catch_Value", 0f);
			gAnimator.SetInteger("Idle_Second", 0);
			gAnimator.SetTrigger("Reset");
		}

		public void MoveToMyBasePos(float dt)
		{
			if (dt != 0f)
			{
				StartCoroutine(BallCatchMovingMyBasePosWait(dt + 0.75f));
			}
			else
			{
				StartCoroutine(MovingMyBasePosWait(dt));
			}
		}

		private IEnumerator BallCatchMovingMyBasePosWait(float dt)
		{
			yield return new WaitForSeconds(dt);
			gAnimator.SetFloat("Catch_Value", 0f);
			gAnimator.SetTrigger("Running");
			StartCoroutine(MovingMyBasePos());
		}

		private IEnumerator MovingMyBasePosWait(float dt)
		{
			yield return new WaitForSeconds(dt);
			gAnimator.SetFloat("Catch_Value", 0f);
			gAnimator.SetTrigger("Running");
			StartCoroutine(MovingMyBasePos());
		}

		private IEnumerator MovingMyBasePos()
		{
			Vector3 dirV = MyBaseTrs.position - base.transform.position;
			dirV.y = 0f;
			base.transform.LookAt(MyBaseTrs);
			while (0.3f < dirV.magnitude)
			{
				yield return null;
				base.transform.position += dirV.normalized * speed * Time.deltaTime;
				dirV = MyBaseTrs.position - base.transform.position;
				dirV.y = 0f;
			}
			base.transform.position = MyBaseTrs.position;
			if ((bool)BallMove.GetInstance())
			{
				Vector3 worldPosition = new Vector3(BallMove.GetInstance().transform.position.x, 0f, BallMove.GetInstance().transform.position.z);
				base.transform.LookAt(worldPosition);
			}
			else
			{
				Transform target = Base[0];
				base.transform.LookAt(target);
			}
			if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
			{
				gAnimator.SetInteger("Idle_Second", 1);
			}
			else
			{
				gAnimator.SetInteger("Idle_Second", 2);
			}
		}

		public void MoveToPos(Vector3 TargetPos, DefenderState State, BallCatchType BallType, float dt = 0f)
		{
			StartCoroutine(MovingWait(TargetPos, State, BallType, dt));
		}

		private IEnumerator MovingWait(Vector3 TargetPos, DefenderState State, BallCatchType BallType, float dt)
		{
			yield return YieldInstructionCache.WaitForSeconds(dt);
			Vector3 targetPos = new Vector3(TargetPos.x, 0f, TargetPos.z);
			curState = State;
			if (Moving_Ienum != null)
			{
				StopCoroutine(Moving_Ienum);
			}
			Moving_Ienum = Moving(targetPos, State, BallType);
			StartCoroutine(Moving_Ienum);
			gAnimator.SetFloat("Catch_Value", 0f);
			gAnimator.SetTrigger("Running");
			if (id == 8)
			{
				gAnimator.SetBool("HIT", value: true);
			}
		}

		private IEnumerator Moving(Vector3 TargetPos, DefenderState State, BallCatchType BallType)
		{
			yield return null;
			switch (State)
			{
			case DefenderState.HitBall:
			{
				Vector3 dirV = TargetPos - base.transform.position;
				while (catchDis < dirV.magnitude)
				{
					dirV = TargetPos - base.transform.position;
					dirV.y = 0f;
					base.transform.position += dirV.normalized * speed * Time.deltaTime;
					Vector3 worldPosition = TargetPos;
					worldPosition.y = base.transform.position.y;
					base.transform.LookAt(worldPosition);
					yield return null;
				}
				base.transform.position = TargetPos;
				base.transform.LookAt(Base[4]);
				yield break;
			}
			case DefenderState.Catch:
			{
				Vector3 dirV = TargetPos - base.transform.position;
				while (catchDis < dirV.magnitude)
				{
					dirV = TargetPos - base.transform.position;
					dirV.y = 0f;
					base.transform.position += dirV.normalized * speed * Time.deltaTime;
					Vector3 worldPosition2 = TargetPos;
					worldPosition2.y = base.transform.position.y;
					base.transform.LookAt(worldPosition2);
					yield return null;
				}
				base.transform.position = TargetPos;
				if (BallType == BallCatchType.Fly)
				{
					gAnimator.SetBool("FlyBall", value: true);
					base.transform.LookAt(Base[4]);
				}
				yield break;
			}
			}
			if (curState == DefenderState.OnlyRun)
			{
				Vector3 position = base.transform.position;
				position.y = 3f;
				Ray ray = new Ray(position, base.transform.forward);
				float maxDistance = 5f;
				RaycastHit hitInfo = default(RaycastHit);
				Physics.Raycast(ray, out hitInfo, maxDistance);
				Vector3 dirV = TargetPos - base.transform.position;
				while (catchDis < dirV.magnitude)
				{
					dirV = TargetPos - base.transform.position;
					dirV.y = 0f;
					base.transform.position += dirV.normalized * speed * Time.deltaTime;
					base.transform.LookAt(TargetPos);
					_ = base.transform.position;
					_ = TargetPos;
					yield return null;
				}
				if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
				{
					gAnimator.SetInteger("Idle_Second", 1);
				}
				else
				{
					gAnimator.SetInteger("Idle_Second", 2);
				}
			}
		}

		public void CatchBall(float waitTime, BallCatchType BallType)
		{
			StartCoroutine(DoCatch(waitTime, BallType));
		}

		private IEnumerator DoCatch(float waitTime, BallCatchType BallType)
		{
			yield return YieldInstructionCache.WaitForSeconds(waitTime);
			if (BallType == BallCatchType.Fly)
			{
				if (id != 0)
				{
					base.transform.LookAt(Base[4]);
				}
				gAnimator.SetBool("CatchFlyBall", value: true);
				gAnimator.SetBool("FlyBall", value: false);
			}
			else if (!BallMove.GetInstance().bound)
			{
				if (id != 0)
				{
					base.transform.LookAt(Base[4]);
				}
				if (BallMove.GetInstance().transform.position.y < 1.5f)
				{
					gAnimator.SetFloat("Catch_Value", 4f);
				}
				else if (BallMove.GetInstance().transform.position.y < 3f)
				{
					gAnimator.SetFloat("Catch_Value", 1f);
				}
				else
				{
					gAnimator.SetFloat("Catch_Value", 6f);
				}
			}
			else
			{
				UnityEngine.Debug.Log("UnderBall Catch!");
				if (id != 0)
				{
					base.transform.LookAt(Base[4]);
				}
				gAnimator.SetFloat("Catch_Value", 4f);
			}
		}

		public void Call_ThrowBall()
		{
			gAnimator.SetTrigger("BaseThrow");
		}

		public void Call_ThrowCatchBall()
		{
			gAnimator.SetBool("BaseCatch", value: true);
		}

		public void Call_CatchParticle()
		{
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(PaticlePF, LHandTrs.position, Quaternion.identity), 2f);
		}

		public void InningMove(Vector3 TargetPos)
		{
			StartCoroutine(corou_InningMove(TargetPos));
		}

		private IEnumerator corou_InningMove(Vector3 TargetPos)
		{
			yield return null;
			gAnimator.SetFloat("Catch_Value", 0f);
			gAnimator.SetTrigger("Running");
			Vector3 dirV = TargetPos - base.transform.position;
			while (18f < dirV.magnitude)
			{
				dirV = TargetPos - base.transform.position;
				dirV.y = 0f;
				base.transform.position += dirV.normalized * speed * Time.deltaTime;
				base.transform.LookAt(TargetPos);
				yield return null;
			}
			base.transform.position = new Vector3(0f, -7f, 0f);
		}
	}
	public enum State
	{
		None,
		Single,
		Multi
	}
	public enum GameMode
	{
		HomerunMode,
		SBOMode
	}
	public enum TeamPosition
	{
		Offense,
		Defense
	}
	public class CsGameData
	{
		private static CsGameData s_instance;

		public State curState = State.Single;

		public GameMode curMode = GameMode.SBOMode;

		public TeamPosition curTeam = TeamPosition.Defense;

		public Bonus curBonus = Bonus.None;

		public int inning = 1;

		public int firstScore;

		public int secondScore;

		public int specialCount = 3;

		public int leftSlideCount = 9;

		public int rightSlideCount = 9;

		public int curveCount = 9;

		public int fireBetCount = 1;

		public int numMultiple = 1;

		public bool AI_Right = true;

		public bool newGame = true;

		public int[] InningScore_1 = new int[3];

		public int[] InningScore_2 = new int[3];

		public float bBounce = 0.2f;

		public float bAngle = 0.85f;

		public bool PXR_Test;

		public int gameFoulCount;

		public float timeStack;

		public const float timeLimit = 20f;

		public bool ballCheck;

		public bool TimeTictok;

		public static CsGameData Instance
		{
			get
			{
				if (s_instance == null)
				{
					s_instance = new CsGameData();
					s_instance.SetInit();
				}
				return s_instance;
			}
		}

		public float _gravity => -16f;

		public void SetInit()
		{
			inning = 1;
			firstScore = 0;
			secondScore = 0;
			gameFoulCount = 0;
			timeStack = 0f;
			ballCheck = false;
			TimeTictok = false;
			specialCount = 3;
			leftSlideCount = 9;
			rightSlideCount = 9;
			curveCount = 9;
			fireBetCount = 1;
			numMultiple = 1;
			for (int i = 0; i < 3; i++)
			{
				InningScore_1[i] = 0;
				InningScore_2[i] = 0;
			}
			curTeam = TeamPosition.Defense;
			curBonus = Bonus.None;
		}
	}
	public class CsHandRigid : MonoBehaviour
	{
		private static CsHandRigid instance;

		public Rigidbody HandRig;

		public Transform NewRightCenter;

		public Transform NewLeftCenter;

		public Transform CurCenter;

		public Transform LimitFollow;

		private Vector3 PrePos;

		private Vector3 CurPos;

		private Vector3[] ArrVel = new Vector3[5];

		private int curIndex;

		private float maxdis = 8f;

		private float mindis = 1f;

		private float totalValue = 1.25f;

		private float yvalue = 0.8f;

		public Text TestText;

		public static CsHandRigid GetInstance()
		{
			return instance;
		}

		private void Awake()
		{
			instance = this;
		}

		private void Start()
		{
			CurCenter = NewRightCenter;
			LimitFollow.position = CurCenter.position;
		}

		private void FixedUpdate()
		{
			if (LimitFollow.position.z < CurCenter.position.z)
			{
				LimitFollow.position = CurCenter.position;
			}
			else if (0.5f < (CurCenter.position - LimitFollow.position).magnitude)
			{
				LimitFollow.position += (CurCenter.position - LimitFollow.position).normalized * 0.5f;
			}
			else
			{
				LimitFollow.position = CurCenter.position;
			}
			CurPos = LimitFollow.position;
			if (CurPos != PrePos)
			{
				Vector3 vector = (CurPos - PrePos) / Time.fixedDeltaTime;
				HandRig.velocity = vector;
				ArrVel[curIndex] = vector;
				if (PrePos.z < CurPos.z && CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					ArrVel[curIndex] = CbatFollower.GetInstance().GetAngleVelocity() * 0.4f;
				}
				curIndex++;
				if (curIndex == ArrVel.Length)
				{
					curIndex = 0;
				}
			}
			else
			{
				HandRig.velocity = Vector3.zero;
				if (CsGameData.Instance.curTeam == TeamPosition.Offense && CbatFollower.GetInstance().GetInAngle())
				{
					ArrVel[curIndex] = CbatFollower.GetInstance().GetAngleVelocity() * 0.4f;
				}
				else
				{
					ArrVel[curIndex] = Vector3.zero;
				}
				curIndex++;
				if (curIndex == ArrVel.Length)
				{
					curIndex = 0;
				}
			}
			PrePos = CurPos;
		}

		public void Call_ChangeHand_Left()
		{
			CurCenter = NewLeftCenter;
			LimitFollow.position = CurCenter.position;
			CurPos = CurCenter.position;
			PrePos = CurCenter.position;
		}

		public void Call_ChangeHand_Right()
		{
			CurCenter = NewRightCenter;
			LimitFollow.position = CurCenter.position;
			CurPos = CurCenter.position;
			PrePos = CurCenter.position;
		}

		public Vector3 GetVel()
		{
			Vector3 result = default(Vector3);
			TestText.text = "";
			int num = 0;
			for (int i = 0; i < ArrVel.Length; i++)
			{
				if (ArrVel[i] == Vector3.zero)
				{
					num++;
				}
				else if (ArrVel[i].magnitude < mindis)
				{
					result += ArrVel[i].normalized * mindis;
				}
				else if (maxdis < ArrVel[i].magnitude)
				{
					result += ArrVel[i].normalized * maxdis;
				}
				else
				{
					result += ArrVel[i];
				}
			}
			if (num != 0)
			{
				result *= 5f / (float)(5 - num);
			}
			result *= totalValue;
			result.y *= yvalue;
			return result;
		}

		public Vector3[] GetVecArr()
		{
			Vector3[] array = new Vector3[ArrVel.Length];
			for (int i = 0; i < ArrVel.Length; i++)
			{
				array[i] = ArrVel[i];
			}
			return array;
		}
	}
	public class CsHomerun : MonoBehaviour
	{
		public GameObject NormalScreen;

		public GameObject HomerunScreenParent;

		public void Call_Homerun()
		{
			StopAllCoroutines();
			StartCoroutine(BackScreenCorou());
		}

		private IEnumerator BackScreenCorou()
		{
			int statck = 0;
			NormalScreen.transform.position = new Vector3(0f, -10000f, 0f);
			HomerunScreenParent.SetActive(value: true);
			for (; statck < 10; statck++)
			{
				yield return YieldInstructionCache.WaitForSeconds(0.7f);
				if (HomerunScreenParent.transform.GetChild(0).gameObject.activeSelf)
				{
					HomerunScreenParent.transform.GetChild(0).gameObject.SetActive(value: false);
					HomerunScreenParent.transform.GetChild(1).gameObject.SetActive(value: true);
				}
				else
				{
					HomerunScreenParent.transform.GetChild(0).gameObject.SetActive(value: true);
					HomerunScreenParent.transform.GetChild(1).gameObject.SetActive(value: false);
				}
			}
			NormalScreen.transform.localPosition = new Vector3(0f, 0f, 0f);
			HomerunScreenParent.SetActive(value: false);
		}
	}
	public class CsMoveTexture : MonoBehaviour
	{
		public Material[] Commercial;

		public int exint;

		public int state;

		public float scroolSpeedX = 0.03f;

		public float scroolSpeedY = 0.4f;

		private float offsetX;

		private float offsetY;

		private float changeTime;

		private float changeCycle = 20f;

		private float stopTime = 3f;

		private float stopDt;

		private float changeHomerunTime;

		private float HomerunOffsetX;

		private int num = 1;

		private Renderer rend;

		public float nextOffset;

		public float curOffset;

		public float OffsetSize;

		private void Start()
		{
			rend = GetComponent<Renderer>();
		}

		private void FixedUpdate()
		{
			changeTime += Time.fixedDeltaTime;
			if (changeTime > changeCycle)
			{
				float num = nextOffset - curOffset;
				num = OffsetSize;
				nextOffset = curOffset + OffsetSize;
				offsetY = Time.fixedDeltaTime * num * scroolSpeedY;
				rend.materials[1].mainTextureOffset = new Vector2(rend.materials[1].mainTextureOffset.x, rend.materials[1].mainTextureOffset.y + offsetY);
				if (rend.materials[1].mainTextureOffset.y >= nextOffset)
				{
					rend.materials[1].mainTextureOffset = new Vector2(rend.materials[1].mainTextureOffset.x, nextOffset);
					curOffset = rend.materials[1].mainTextureOffset.y;
					stopDt = 0f;
					changeTime = 0f;
				}
			}
			else if (stopDt < stopTime)
			{
				stopDt += Time.fixedDeltaTime;
			}
			else
			{
				Vector2 mainTextureOffset = rend.materials[1].mainTextureOffset;
				mainTextureOffset.x += Time.fixedDeltaTime * scroolSpeedX;
				rend.materials[1].mainTextureOffset = mainTextureOffset;
			}
		}
	}
	public class CsOffense : MonoBehaviour
	{
		private Animator gAnimator;

		private Vector3[] TargetPos = new Vector3[4];

		public int curBase;

		public int targetBase = 1;

		public int mayBase;

		public bool noRunning;

		public bool moveAni;

		private float Speed;

		public Vector3 HomeBasePos = Vector3.zero;

		private IEnumerator Moving_Ienum;

		private void Awake()
		{
			gAnimator = GetComponent<Animator>();
		}

		public void SetData(float _speed)
		{
			Speed = _speed;
		}

		public float GetSpeed()
		{
			return Speed;
		}

		public void SetSpeed_OutPlay(float newSpeed)
		{
			Speed = newSpeed;
		}

		public void Ready(Transform[] Base)
		{
			mayBase = curBase;
			targetBase = curBase + 1;
			for (int i = 0; i < TargetPos.Length; i++)
			{
				TargetPos[i] = Vector3.zero;
			}
			for (int j = 0; j < TargetPos.Length - curBase; j++)
			{
				TargetPos[j] = Base[targetBase + j].transform.position;
			}
			HomeBasePos = Base[4].position;
		}

		public Vector3 GetTargetPos(int num)
		{
			return TargetPos[num];
		}

		public void SetResultBase()
		{
			curBase = mayBase;
			targetBase = curBase + 1;
		}

		public void SetResultPos(Vector3 Pos)
		{
			base.transform.position = Pos;
			base.transform.LookAt(Vector3.zero);
		}

		public void ResetAnimator()
		{
			moveAni = false;
			gAnimator.SetTrigger("Idle");
			UnityEngine.Debug.Log("This Problem??");
		}

		public void MovingStart(Vector3 TargetPos, float dt = 0f)
		{
			StartCoroutine(MovingWait(TargetPos, dt));
		}

		private IEnumerator MovingWait(Vector3 TargetPos, float dt)
		{
			yield return new WaitForSeconds(dt);
			if (Moving_Ienum != null)
			{
				StopCoroutine(Moving_Ienum);
			}
			Moving_Ienum = Moving(TargetPos);
			StartCoroutine(Moving_Ienum);
		}

		private IEnumerator Moving(Vector3 TargetPos)
		{
			yield return null;
			gAnimator.SetTrigger("Running");
			Vector3 dirV = TargetPos;
			while (1f < dirV.magnitude)
			{
				moveAni = true;
				dirV = TargetPos - base.transform.position;
				dirV.y = 0f;
				base.transform.position += dirV.normalized * Speed * Time.deltaTime;
				base.transform.LookAt(TargetPos);
				yield return null;
			}
			if (3 < targetBase || (HomeBasePos - TargetPos).magnitude < 2f)
			{
				float dt = 0f;
				while (dt < 1.5f)
				{
					moveAni = true;
					dt += Time.deltaTime;
					base.transform.position += dirV.normalized * Speed * Time.deltaTime;
					yield return null;
				}
				base.transform.position = new Vector3(0f, -5f, 0f);
			}
			moveAni = false;
			StartCoroutine(StopCorouCheck());
		}

		private IEnumerator StopCorouCheck()
		{
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			while (moveAni)
			{
				yield return YieldInstructionCache.WaitForSeconds(0.1f);
			}
			base.transform.LookAt(Vector3.zero);
			gAnimator.SetTrigger("Idle");
		}

		public void HitterRunAni()
		{
			StartCoroutine(HitterRunAniCheck());
		}

		private IEnumerator HitterRunAniCheck()
		{
			yield return null;
			gAnimator.SetTrigger("Running");
			yield return null;
			gAnimator.SetTrigger("Running");
		}
	}
	public class CsOutAniOnOff : MonoBehaviour
	{
		public bool ani;

		public GameObject OutAniOnOff;

		public GameObject Hitter;

		public GameObject Hitter_R;

		public GameObject Hitter_L;

		public GameObject Hitter_WalkMan;

		public Transform GameFirstHitterTrs;

		private Vector3 WalkMan_StartPos;

		private float Speed = 3f;

		private Vector3 OutAniOnOff_Pos;

		private void Start()
		{
			WalkMan_StartPos = Hitter_WalkMan.transform.position;
			OutAniOnOff_Pos = OutAniOnOff.transform.position;
		}

		public void Call_OutAni(float dt)
		{
			StartCoroutine(Corou_OutAni(dt));
		}

		private IEnumerator Corou_OutAni(float dt)
		{
			if (CsGameData.Instance.curState == State.Single)
			{
				ani = true;
				OutAniOnOff.SetActive(value: false);
				OutAniOnOff.transform.position = new Vector3(0f, -100f, 0f);
				yield return YieldInstructionCache.WaitForSeconds(1f + dt);
				if (2 < BaseballManager.GetInstance().outCount)
				{
					StopAllCoroutines();
					yield return null;
				}
				BaseballManager.GetInstance().Call_PlaySound(SoundTrack.ChangeOffence);
				Hitter_WalkMan.transform.position = WalkMan_StartPos;
				Hitter_WalkMan.SetActive(value: true);
				Hitter_R.SetActive(value: false);
				Hitter_L.SetActive(value: false);
				Vector3 dirV = Hitter.transform.position;
				while (1f < dirV.magnitude)
				{
					dirV = Hitter.transform.position - Hitter_WalkMan.transform.position;
					dirV.y = 0f;
					Hitter_WalkMan.transform.position += dirV.normalized * Speed * Time.deltaTime;
					Hitter_WalkMan.transform.LookAt(Hitter.transform.position);
					yield return null;
				}
				Hitter_WalkMan.SetActive(value: false);
				Hitter.SetActive(value: true);
				Hitter.GetComponent<CustomModelSettingCtrl>().enabled = true;
				Hitter.GetComponent<CustomModelSettingCtrl>().Init(DefenderManager.GetInstance().customModelData);
				OutAniOnOff.SetActive(value: true);
				OutAniOnOff.transform.position = OutAniOnOff_Pos;
				ani = false;
			}
			else if (CsGameData.Instance.curState == State.Multi)
			{
				yield return YieldInstructionCache.WaitForSeconds(1f + dt);
				if (2 < BaseballManager.GetInstance().outCount)
				{
					StopAllCoroutines();
					yield return null;
				}
				yield return YieldInstructionCache.WaitForSeconds(1f);
				BaseballManager.GetInstance().Call_PlaySound(SoundTrack.ChangeOffence);
				OutAniOnOff.SetActive(value: true);
				OutAniOnOff.transform.position = OutAniOnOff_Pos;
			}
			yield return null;
		}

		public bool GetBoolAni()
		{
			return ani;
		}

		public void Call_StartGameAni()
		{
			StartCoroutine(Corou_StartGameAni());
		}

		private IEnumerator Corou_StartGameAni()
		{
			yield return null;
			ani = true;
			OutAniOnOff.SetActive(value: false);
			OutAniOnOff.transform.position = new Vector3(0f, -100f, 0f);
			Hitter_WalkMan.transform.position = GameFirstHitterTrs.position;
			Hitter_WalkMan.SetActive(value: true);
			Hitter_WalkMan.GetComponent<CustomModelSettingCtrl>().Init(DefenderManager.GetInstance().customModelData);
			Hitter_R.SetActive(value: false);
			Hitter_L.SetActive(value: false);
			Vector3 dirV = Hitter.transform.position;
			while (1f < dirV.magnitude)
			{
				dirV = Hitter.transform.position - Hitter_WalkMan.transform.position;
				dirV.y = 0f;
				Hitter_WalkMan.transform.position += dirV.normalized * 2.5f * Time.deltaTime;
				Hitter_WalkMan.transform.LookAt(Hitter.transform.position);
				yield return null;
			}
			Hitter_WalkMan.SetActive(value: false);
			Hitter.SetActive(value: true);
			Hitter.GetComponent<CustomModelSettingCtrl>().enabled = true;
			Hitter.GetComponent<CustomModelSettingCtrl>().Init(DefenderManager.GetInstance().customModelData);
			OutAniOnOff.SetActive(value: true);
			OutAniOnOff.transform.position = OutAniOnOff_Pos;
			ani = false;
		}

		public void HitterSet(bool isRight)
		{
			if (isRight)
			{
				Hitter = Hitter_R;
				Speed = 3f;
			}
			else
			{
				Hitter = Hitter_L;
				Speed = 3.5f;
			}
		}
	}
	public class CsParticle : MonoBehaviour
	{
		public enum particleTrack
		{
			ForecastBound,
			StorngHit,
			WeakHit,
			FireCracker,
			Catch,
			Bound,
			BonusEffect,
			BoundIndicate,
			WoodEffect,
			StoneEffect,
			MetalEffect,
			ToyHammerEffect,
			BigExplosionEffect,
			SmallExplosionEffect,
			WoodEffect_2,
			StoneEffect_2,
			MetalEffect_2
		}

		public GameObject[] ParticleArray;
	}
	public class VectorTime
	{
		public Vector3 mVec;

		public Vector3 mOutVec;

		public float mTime;

		public float mOutTime;

		public bool mFlyBall;

		public Vector3 mFenceVec;

		public float mfenceTime;

		public VectorTime(Vector3 _mVec, Vector3 _mOutVec, float _mTime, float _mOutTime, bool _ball)
		{
			mVec = _mVec;
			mOutVec = _mOutVec;
			mTime = _mTime;
			mOutTime = _mOutTime;
			mFlyBall = _ball;
			mFenceVec = Vector3.zero;
			mfenceTime = 0f;
		}

		public VectorTime(Vector3 _mVec, Vector3 _mOutVec, Vector3 _mFenceVec, float _mTime, float _mOutTime, float _mfenceTime, bool _ball)
		{
			mVec = _mVec;
			mOutVec = _mOutVec;
			mTime = _mTime;
			mOutTime = _mOutTime;
			mFlyBall = _ball;
			mFenceVec = _mFenceVec;
			mfenceTime = _mfenceTime;
		}
	}
	public class CsPhysics
	{
		public static Vector3 getShotVelocityAtoB(Vector3 A, Vector3 B, float t, float x_Pow = 0f, float y_Pow = 0f)
		{
			if (x_Pow == 0f && y_Pow == 0f)
			{
				Vector3 vector = A;
				Vector3 vector2 = B;
				float num = vector2.x - vector.x;
				float num2 = vector2.z - vector.z;
				float x = num / t;
				float z = num2 / t;
				float gravity = CsGameData.Instance._gravity;
				float y = vector.y;
				float y2 = (vector2.y - y - gravity * Mathf.Pow(t, 2f) / 2f) / t;
				return new Vector3(x, y2, z);
			}
			Vector3 vector3 = A;
			Vector3 vector4 = B;
			float z2 = (vector4.z - vector3.z) / t;
			float x2 = vector3.x;
			float x3 = (vector4.x - x2 - 0.5f * x_Pow * t * t) / t;
			float num3 = CsGameData.Instance._gravity + y_Pow;
			float y3 = vector3.y;
			float y4 = (vector4.y - y3 - 0.5f * num3 * t * t) / t;
			return new Vector3(x3, y4, z2);
		}

		public static float getDistanceXZ(Vector3 A, Vector3 B)
		{
			float num = A.x - B.x;
			float num2 = A.z - B.z;
			return Mathf.Sqrt(num * num + num2 * num2);
		}

		public static float getDistanceXY(Vector3 A, Vector3 B)
		{
			float num = A.x - B.x;
			float num2 = A.y - B.y;
			return Mathf.Sqrt(num * num + num2 * num2);
		}

		public Vector3 getTrackPos(Vector3 _Velocty, Vector3 _Start, float _time, float _slow)
		{
			Vector3 vector = new Vector3(0f, -15f, 0f);
			float num = _time * _slow;
			return _Velocty * num + 0.5f * vector * num * num;
		}

		public static float getHeightPredict(Rigidbody ballRigid, float arriveTime)
		{
			float gravity = CsGameData.Instance._gravity;
			float y = ballRigid.transform.position.y;
			float y2 = ballRigid.velocity.y;
			return y + y2 * arriveTime + 0.5f * gravity * arriveTime * arriveTime;
		}

		public static Vector3 getShortPos(Vector3 startPos, Vector3 _ballVelocity, Vector3 defenderPos, float defenderSpeed)
		{
			Vector3 vector = _ballVelocity;
			vector.y = 0f;
			Vector3 vector2 = startPos;
			vector2 += _ballVelocity.normalized;
			vector2.y = 0f;
			float magnitude = vector.magnitude;
			vector.Normalize();
			Vector3 b = vector2 + Vector3.Dot(defenderPos - vector2, vector) * vector;
			float f = chkDistance(vector, vector2, defenderPos);
			float num = Vector3.Distance(vector2, b);
			float num2 = Mathf.Pow(defenderSpeed, 2f) / Mathf.Pow(magnitude, 2f) - 1f;
			float num3 = 2f * num;
			float num4 = -1f * (Mathf.Pow(f, 2f) + Mathf.Pow(num, 2f));
			float num5 = (-1f * num3 + Mathf.Sqrt(Mathf.Pow(num3, 2f) - 4f * num2 * num4)) / (2f * num2);
			if (num5 > 0f)
			{
				return vector2 + vector * num5;
			}
			return Vector3.zero;
		}

		public Vector3 getShortPos(Vector3 startPos, Vector3 _ballVelocity, Vector3 defenderPos, float defenderSpeed, float boundTime, out float ballCatchTime)
		{
			Vector3 vector = _ballVelocity;
			Vector3 vector2 = _ballVelocity * 0.5f;
			vector.y = 0f;
			vector2.y = 0f;
			Vector3 vector3 = startPos;
			vector3 += _ballVelocity.normalized;
			vector3.y = 0f;
			float magnitude = vector.magnitude;
			_ = vector2.magnitude;
			vector.Normalize();
			Vector3 vector4 = vector3 + Vector3.Dot(defenderPos - vector3, vector) * vector;
			float f = chkDistance(vector, vector3, defenderPos);
			float num = Vector3.Distance(vector3, vector4);
			float num2 = Mathf.Pow(defenderSpeed, 2f) / Mathf.Pow(magnitude, 2f) - 1f;
			float num3 = 2f * num;
			float num4 = -1f * (Mathf.Pow(f, 2f) + Mathf.Pow(num, 2f));
			float num5 = (-1f * num3 + Mathf.Sqrt(Mathf.Pow(num3, 2f) - 4f * num2 * num4)) / (2f * num2);
			float num6 = Vector3.Distance(vector4, defenderPos) / defenderSpeed;
			float num7 = Vector3.Distance(vector4, startPos) / magnitude;
			float num8 = (num7 - boundTime) * 2f + boundTime;
			if (num7 < boundTime)
			{
				num8 = num7;
			}
			if (num5 > 0f)
			{
				num7 = Vector3.Distance(vector3 + vector * num5, startPos) / magnitude;
				num8 = (num7 - boundTime) * 2f + boundTime;
				ballCatchTime = num8;
				return vector3 + vector * num5;
			}
			if (num6 < num8)
			{
				ballCatchTime = num8;
				return vector4;
			}
			ballCatchTime = 0f;
			return Vector3.zero;
		}

		public static Vector3 getLongPos(Vector3 startPos, Vector3 _ballVelocity, Vector3 defenderPos, float defenderSpeed)
		{
			Vector3 vector = _ballVelocity;
			vector.y = 0f;
			Vector3 vector2 = startPos;
			vector2 += _ballVelocity.normalized;
			vector2.y = 0f;
			float magnitude = vector.magnitude;
			vector.Normalize();
			Vector3 b = vector2 + Vector3.Dot(defenderPos - vector2, vector) * vector;
			float f = chkDistance(vector, vector2, defenderPos);
			float num = Vector3.Distance(vector2, b);
			float num2 = Mathf.Pow(defenderSpeed, 2f) / Mathf.Pow(magnitude, 2f) - 1f;
			float num3 = 2f * num;
			float num4 = -1f * (Mathf.Pow(f, 2f) + Mathf.Pow(num, 2f));
			float num5 = (-1f * num3 - Mathf.Sqrt(Mathf.Pow(num3, 2f) - 4f * num2 * num4)) / (2f * num2);
			if (num5 > 0f)
			{
				return vector2 + vector * num5;
			}
			return Vector3.zero;
		}

		public static float chkDistance(Vector3 direction, Vector3 startingPoint, Vector3 point)
		{
			Ray ray = new Ray(startingPoint, direction);
			return Vector3.Cross(ray.direction, point - ray.origin).magnitude;
		}

		public static VectorTime getArrivePos(Vector3 ballPos, Vector3 velocity, float FlyBallCatchHeight, float FenceHeight = 0f)
		{
			float y = ballPos.y;
			float num = 0f - CsGameData.Instance._gravity;
			float num2 = 0f;
			float num3 = 0f;
			float num4 = 0f;
			float num5 = 0f;
			bool ball = true;
			if (velocity.y < 0f)
			{
				float num6 = y;
				float num7 = 0.5f * num;
				float num8 = velocity.y * -1f;
				float num9 = -1f * num6;
				num3 = (-1f * num8 + Mathf.Sqrt(Mathf.Pow(num8, 2f) - 4f * num7 * num9)) / (2f * num7);
			}
			else
			{
				num2 = velocity.y / num;
				float num11;
				float num10;
				float num12 = (num11 = (num10 = y + velocity.y * num2 - 0.5f * num * Mathf.Pow(num2, 2f)));
				if (num11 > FlyBallCatchHeight)
				{
					num11 -= FlyBallCatchHeight + 0.1f;
				}
				else
				{
					ball = false;
				}
				num3 = Mathf.Sqrt(2f * num10 / num);
				num4 = Mathf.Sqrt(2f * num11 / num);
				float num13 = num12 - FenceHeight;
				if (num13 < 0f)
				{
					num13 = 0f;
				}
				num5 = Mathf.Sqrt(2f * num13 / num);
			}
			float num14 = num2 + num3;
			float num15 = num2 + num4;
			float num16 = num2 + num5;
			Vector3 vector = velocity;
			vector.y = 0f;
			float magnitude = vector.magnitude;
			vector.Normalize();
			float num17 = magnitude * num14;
			float num18 = magnitude * num15;
			float num19 = magnitude * num16;
			ballPos.y = 0f;
			Vector3 vector2 = ballPos;
			if (FenceHeight == 0f)
			{
				return new VectorTime(vector2 + vector * num17, vector2 + vector * num18, num14, num15, ball);
			}
			return new VectorTime(vector2 + vector * num17, vector2 + vector * num18, vector2 + vector * num19, num14, num15, num16, ball);
		}

		public static Vector3 GetDownPos(Vector3 ballPos, Vector3 velocity, float FlyBallCatchHeight = 0f)
		{
			float y = ballPos.y;
			float gravity = CsGameData.Instance._gravity;
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			if (velocity.y < 0f)
			{
				float num4 = y;
				float num5 = 0.5f * gravity;
				float num6 = velocity.y * -1f;
				float num7 = -1f * num4;
				num2 = (-1f * num6 + Mathf.Sqrt(Mathf.Pow(num6, 2f) - 4f * num5 * num7)) / (2f * num5);
			}
			else
			{
				num = velocity.y / gravity;
				float num8;
				float num9 = (num8 = y + velocity.y * num - 0.5f * gravity * Mathf.Pow(num, 2f));
				if (num9 > FlyBallCatchHeight)
				{
					num9 -= FlyBallCatchHeight + 0.1f;
				}
				num2 = Mathf.Sqrt(2f * num8 / gravity);
				num3 = Mathf.Sqrt(2f * num9 / gravity);
			}
			float num10 = num + num2;
			float num11 = num + num3;
			Vector3 vector = velocity;
			vector.y = 0f;
			float magnitude = vector.magnitude;
			vector.Normalize();
			float num12 = magnitude * num10;
			ballPos.y = 0f;
			ballPos += vector * num12;
			return ballPos;
		}

		public static Color hexToColor(string hex)
		{
			hex = hex.Replace("0x", "");
			hex = hex.Replace("#", "");
			float r = (float)int.Parse(hex.Substring(0, 2), NumberStyles.HexNumber) / 255f;
			float g = (float)int.Parse(hex.Substring(2, 2), NumberStyles.HexNumber) / 255f;
			float b = (float)int.Parse(hex.Substring(4, 2), NumberStyles.HexNumber) / 255f;
			if (hex.Length == 8)
			{
				int.Parse(hex.Substring(4, 2), NumberStyles.HexNumber);
			}
			return new Color(r, g, b, 1f);
		}

		public static bool FoulDecide(Vector3 mVec, GameObject FoulLine_0, GameObject FoulLine_1, GameObject FoulLine_2)
		{
			Vector3 vector = mVec;
			if (vector.x < 0.1f)
			{
				Vector3 position = FoulLine_0.transform.position;
				Vector3 position2 = FoulLine_2.transform.position;
				float x = vector.x;
				if ((position2.z - position.z) / (position2.x - position.x) * (x - position.x) + position.z < vector.z)
				{
					return true;
				}
			}
			else if (0f < vector.x)
			{
				Vector3 position3 = FoulLine_0.transform.position;
				Vector3 position4 = FoulLine_1.transform.position;
				float x2 = vector.x;
				if ((position4.z - position3.z) / (position4.x - position3.x) * x2 + position3.z < vector.z)
				{
					return true;
				}
			}
			return false;
		}
	}
	public class CsReferee : MonoBehaviour
	{
		private Animator gAni;

		private float idleDelay;

		private void Awake()
		{
			gAni = GetComponent<Animator>();
			GetComponent<CustomModelSettingCtrl>().InitRandom();
		}

		public void Call_Ani(string str)
		{
			if (str == "Out")
			{
				gAni.SetFloat("OutValue", UnityEngine.Random.Range(0, 2));
			}
			gAni.SetTrigger(str);
		}
	}
	public class CsRotate : MonoBehaviour
	{
		public Transform[] BallTrs;

		private float rotateValue;

		private float Speed = 50f;

		private Vector3 CurAng;

		private void Update()
		{
			rotateValue += Time.deltaTime * Speed;
			CurAng.Set(rotateValue, 0f, 0f);
			BallTrs[0].eulerAngles = CurAng;
			CurAng.Set(rotateValue * 0.5f, 0f, 0f);
			BallTrs[1].eulerAngles = CurAng;
			CurAng.Set(0f, 0f - rotateValue, 0f);
			BallTrs[2].eulerAngles = CurAng;
			CurAng.Set(0f, rotateValue, 0f);
			BallTrs[3].eulerAngles = CurAng;
			CurAng.Set(rotateValue * 2f, 0f, 0f);
			BallTrs[4].eulerAngles = CurAng;
		}
	}
	public class CsScoreBoardUI : MonoBehaviour
	{
		public Animator ScorUIAnimator;

		public GameObject ScoreUI;

		public GameObject[] ScoreDepth;

		public Text[] PlayerName_1;

		public Text[] PlayerName_2;

		public RawImage CharImage_1;

		public RawImage CharImage_2;

		public Text PlayerTotalScore_1;

		public Text PlayerTotalScore_2;

		public Text InningText;

		public GameObject[] InningImageObj;

		public Text[] InningScore_1;

		public Text[] InningScore_2;

		public Transform DefPosTrs;

		public Transform OffPosTrs;

		public Transform ChangePosTrs;

		public void UIPosAndAngle(bool change)
		{
			if (change)
			{
				ScoreUI.transform.position = ChangePosTrs.position;
				ScoreUI.transform.eulerAngles = ChangePosTrs.eulerAngles;
			}
			else if (CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				ScoreUI.transform.position = DefPosTrs.position;
				ScoreUI.transform.eulerAngles = DefPosTrs.eulerAngles;
			}
			else if (CsGameData.Instance.curTeam == TeamPosition.Offense)
			{
				ScoreUI.transform.position = OffPosTrs.position;
				ScoreUI.transform.eulerAngles = OffPosTrs.eulerAngles;
			}
		}

		public void ActiveDepth(int depth)
		{
			switch (depth)
			{
			case 1:
				ScoreDepth[0].SetActive(value: true);
				ScoreDepth[1].SetActive(value: false);
				break;
			case 2:
				ScoreDepth[0].SetActive(value: true);
				ScoreDepth[1].SetActive(value: true);
				break;
			}
		}

		public void ImageSet()
		{
		}

		public void PlayerNameSet()
		{
			for (int i = 0; i < PlayerName_1.Length; i++)
			{
				PlayerName_1[i].text = BaseballManager.GetInstance().GetFirstNick();
			}
			for (int j = 0; j < PlayerName_2.Length; j++)
			{
				PlayerName_2[j].text = BaseballManager.GetInstance().GetSecondNick();
			}
		}

		public void InningSet()
		{
			InningText.text = (CsGameData.Instance.inning - 1) / 2 + 7 + "th";
			if ((CsGameData.Instance.inning + 1) % 2 == 0)
			{
				InningImageObj[0].SetActive(value: true);
				InningImageObj[1].SetActive(value: false);
			}
			else
			{
				InningImageObj[0].SetActive(value: false);
				InningImageObj[1].SetActive(value: true);
			}
		}

		public void ScoreSet(int score_1, int score_2)
		{
			PlayerTotalScore_1.text = score_1.ToString();
			PlayerTotalScore_2.text = score_2.ToString();
		}

		public void InningScore()
		{
			int num = (CsGameData.Instance.inning + 1) / 2;
			int num2 = (CsGameData.Instance.inning + 1) % 2;
			for (int i = 0; i < num && i != 3; i++)
			{
				InningScore_1[i].text = CsGameData.Instance.InningScore_1[i].ToString();
				InningScore_2[i].text = CsGameData.Instance.InningScore_2[i].ToString();
			}
			if (num2 == 0)
			{
				InningScore_2[num - 1].text = "-";
			}
		}

		public void Func_ActiveOn()
		{
			PlayerTotalScore_1.text = CsGameData.Instance.firstScore.ToString();
			PlayerTotalScore_2.text = CsGameData.Instance.secondScore.ToString();
			ScoreUI.SetActive(value: true);
		}

		public void Func_ActiveOnOff()
		{
			PlayerTotalScore_1.text = CsGameData.Instance.firstScore.ToString();
			PlayerTotalScore_2.text = CsGameData.Instance.secondScore.ToString();
			StopAllCoroutines();
			StartCoroutine(ActiveCorou());
		}

		private IEnumerator ActiveCorou()
		{
			ScoreUI.SetActive(value: true);
			yield return YieldInstructionCache.WaitForSeconds(5f);
			ScoreUI.SetActive(value: false);
		}
	}
	public enum SoundTrack
	{
		BatHit_Two,
		BatHit_Three,
		Tack,
		Throw,
		ChangeInning,
		ChangeOffence,
		WildThrow,
		FireBall,
		Bound,
		HomeRunBound,
		Gone,
		Audience_1,
		Audience_2,
		Strike_1,
		Strike_2,
		Strike_3,
		Strike_4,
		Ball_1,
		Ball_2,
		Ball_3,
		Ball_4,
		FourBall_1,
		FourBall_2,
		Foul_1,
		Foul_2,
		StrikeOut_1,
		StrikeOut_2,
		StrikeOut_3,
		StrikeOut_4,
		Safe_1,
		Safe_2,
		Safe_3,
		Homerun_1,
		Homerun_2,
		Homerun_3,
		Homerun_4,
		Out_1,
		Out_2,
		Out_3,
		Out_4,
		Single_Hit,
		Double_Hit,
		Triple_Hit,
		FirePower,
		Going_1,
		Going_2,
		Going_3,
		Going_4,
		DeadBall,
		to,
		Bonus_Hit,
		Bonus_Open,
		ClockTicking,
		Timeout
	}
	public enum NumTrack
	{
		zero,
		one,
		two,
		three,
		four,
		five,
		six,
		seven,
		eight,
		nine,
		ten
	}
	public class CsSound : MonoBehaviour
	{
		public AudioClip[] SoundVarious;

		public AudioClip[] NumberVarious;

		public AudioClip[] SoundVariousChina;

		public AudioClip[] NumberVariousChina;
	}
	public class DefenderManager : MonoBehaviour
	{
		private enum ContEnum
		{
			Defender,
			Pitcher,
			Offenser,
			Catcher
		}

		private static DefenderManager instance;

		[Header("[공용]")]
		public GameObject[] CharPF;

		public Transform DefPosPar;

		public Transform[] StartPosTrs;

		public Transform[] DefPosTrs;

		public GameObject[] Defender;

		public RuntimeAnimatorController[] AniCont;

		public Transform BaseParent;

		private Transform[] Base;

		public Transform BaseOffParent;

		private Transform[] BaseOff;

		public int CatchID;

		public const float defenderSpeed = 9.5f;

		public const int DefenderMax = 9;

		public const float FlyBallCatchHeight = 4.7f;

		[Header("[SBO 추가 부분]")]
		public CsReferee[] RefereeAni;

		public List<GameObject> ListOffense = new List<GameObject>();

		public GameObject OffensePF;

		public Transform HitterStartTrs;

		public Transform ChangeInning_Defender;

		public const float offenseSpeed = 12f;

		public const float throwSpeed = 40f;

		public const float catchAndThrowDt = 1.25f;

		public const float catchAndThrowAniDt = 0.75f;

		public const float defArmDis = 3.15f;

		private int outCount;

		private int[] OutNum = new int[2];

		public CustomModelData customModelData;

		public static DefenderManager GetInstance()
		{
			return instance;
		}

		private void Start()
		{
			instance = this;
			StartSet();
			CreateDefender();
			if (CsGameData.Instance.curState == State.Single)
			{
				if (CsGameData.Instance.curTeam == TeamPosition.Defense)
				{
					customModelData = CustomModelSettingCtrl.GetRandomModelData();
				}
				else if (CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					customModelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(0);
				}
			}
			else
			{
				_ = CsGameData.Instance.curState;
				_ = 2;
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Z))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(OffensePF, new Vector3(0f, -5f, 0f), Quaternion.identity);
				gameObject.GetComponent<CsOffense>().curBase = 3;
				gameObject.GetComponent<CsOffense>().targetBase = 4;
				gameObject.GetComponent<CsOffense>().mayBase = 3;
				gameObject.GetComponent<CsOffense>().SetData(12f);
				gameObject.GetComponent<CsOffense>().Ready(Base);
				for (int i = 0; i < gameObject.transform.childCount; i++)
				{
					gameObject.transform.GetChild(i).gameObject.SetActive(value: true);
				}
				Func_OffenceCustom(gameObject);
				ListOffense.Add(gameObject);
				gameObject.GetComponent<CsOffense>().SetResultPos(BaseOff[3].position);
			}
		}

		private void StartSet()
		{
			StartPosTrs = new Transform[9];
			DefPosTrs = new Transform[9];
			for (int i = 0; i < 9; i++)
			{
				StartPosTrs[i] = DefPosPar.GetChild(i);
				DefPosTrs[i] = DefPosPar.GetChild(i).GetChild(0);
			}
			Defender = new GameObject[9];
			Base = new Transform[7];
			for (int j = 0; j < 7; j++)
			{
				Base[j] = BaseParent.GetChild(j);
			}
			BaseOff = new Transform[4];
			for (int k = 0; k < 4; k++)
			{
				BaseOff[k] = BaseOffParent.GetChild(k);
			}
		}

		public void CreateDefender()
		{
			for (int i = 0; i < 9; i++)
			{
				if (i == 0)
				{
					Defender[i] = UnityEngine.Object.Instantiate(CharPF[3], StartPosTrs[i].position, StartPosTrs[i].rotation);
				}
				else
				{
					Defender[i] = UnityEngine.Object.Instantiate(CharPF[0], StartPosTrs[i].position, StartPosTrs[i].rotation);
				}
				Defender[i].transform.LookAt(Base[4]);
				Defender[i].AddComponent<CsDefender>();
				Defender[i].GetComponent<CsDefender>().SetDataDef(i, 9.5f, DefPosTrs[i], Base);
				Defender[i].GetComponent<CsDefender>().PaticlePF = GetComponent<CsParticle>().ParticleArray[5];
				if (i != 0 && i != 8)
				{
					Defender[i].GetComponent<Animator>().runtimeAnimatorController = AniCont[0];
				}
				if (i == 8)
				{
					if (CsGameData.Instance.curTeam == TeamPosition.Defense)
					{
						Defender[i].GetComponent<CustomModelSettingCtrl>().Init(BaseballManager.GetInstance().GetMyId());
					}
					else
					{
						if (CsGameData.Instance.curTeam != 0)
						{
							continue;
						}
						if (CsGameData.Instance.curState == State.Single)
						{
							if (CsGameData.Instance.curMode == GameMode.HomerunMode)
							{
								Defender[i].GetComponent<CustomModelSettingCtrl>().InitRandom();
							}
							else if (CsGameData.Instance.curMode == GameMode.SBOMode)
							{
								Defender[i].GetComponent<CustomModelSettingCtrl>().InitCPU();
							}
						}
						else if (CsGameData.Instance.curState == State.Multi)
						{
							Defender[i].GetComponent<CustomModelSettingCtrl>().Init(BaseballManager.GetInstance().GetOtherId());
						}
					}
				}
				else
				{
					Defender[i].GetComponent<CustomModelSettingCtrl>().InitRandom();
				}
			}
			Defender[8].AddComponent<AIPitcher>();
			Defender[8].GetComponent<AIPitcher>().SetDataPitcher(BaseballManager.GetInstance().BallPF);
			Defender[8].GetComponent<Animator>().runtimeAnimatorController = AniCont[1];
		}

		public void Reset()
		{
			CatchID = 0;
			if (CsGameData.Instance.curMode == GameMode.SBOMode)
			{
				Defender[0].GetComponent<LookAtIK>().enabled = true;
				Defender[0].GetComponent<FullBodyBipedIK>().enabled = true;
			}
			for (int i = 0; i < 9; i++)
			{
				Defender[i].transform.position = StartPosTrs[i].position;
				Defender[i].transform.rotation = StartPosTrs[i].rotation;
				Defender[i].transform.LookAt(Base[4]);
				Defender[i].GetComponent<CsDefender>().StopAllCoroutines();
				Defender[i].GetComponent<CsDefender>().ResetAnimator();
			}
			StopAllCoroutines();
		}

		public void SBOReset()
		{
			outCount = 0;
			for (int i = 0; i < ListOffense.Count; i++)
			{
				CsOffense component = ListOffense[i].GetComponent<CsOffense>();
				component.StopAllCoroutines();
				component.SetResultPos(BaseOff[component.mayBase].position);
				component.ResetAnimator();
				StartCoroutine(ExceptAniReset());
			}
		}

		private IEnumerator ExceptAniReset()
		{
			yield return YieldInstructionCache.WaitForSeconds(0.1f);
			for (int i = 0; i < ListOffense.Count; i++)
			{
				ListOffense[i].GetComponent<CsOffense>().ResetAnimator();
			}
		}

		public ReturnDataClass StartDefence(Vector3 BallSratPos, Vector3 BallVel)
		{
			VectorTime arrivePos = CsPhysics.getArrivePos(BallSratPos, BallVel, 4.7f, 12f);
			ReturnDataClass returnDataClass = new ReturnDataClass();
			returnDataClass.BallDownPos = arrivePos.mVec;
			BaseballManager.GetInstance().Call_FenceCheck(arrivePos.mFenceVec, arrivePos.mVec, arrivePos.mfenceTime, arrivePos.mTime);
			CatchID = 0;
			float num = 99f;
			bool flag = false;
			Vector3 vector = Vector3.zero;
			float num2 = 0f;
			if (arrivePos.mFlyBall)
			{
				for (int i = 0; i < 9; i++)
				{
					if (i == 0)
					{
						continue;
					}
					CsDefender component = Defender[i].GetComponent<CsDefender>();
					float num3 = Vector3.Distance(arrivePos.mOutVec, Defender[i].transform.position);
					float mOutTime = arrivePos.mOutTime;
					if (num3 / component.GetSpeed() < mOutTime)
					{
						flag = true;
						if (num3 < num)
						{
							CatchID = i;
							num = num3;
						}
					}
					if (!(i == 8 && flag))
					{
						continue;
					}
					if (CatchID == 8)
					{
						Defender[8].SetActive(value: true);
						if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
						{
							BaseballManager.GetInstance().MultiCharActive(_bool: false);
						}
					}
					Defender[CatchID].GetComponent<CsDefender>().MoveToPos(arrivePos.mOutVec, DefenderState.Catch, BallCatchType.Fly);
					Defender[CatchID].GetComponent<CsDefender>().CatchBall(mOutTime, BallCatchType.Fly);
					BaseballManager.GetInstance().Call_CatchBall(mOutTime, BallCatchType.Fly);
					BallMove.GetInstance().curType = BallCatchType.Fly;
					UnityEngine.Debug.Log("Flying ball catch");
					returnDataClass._firstCatchTime = mOutTime;
					returnDataClass._flyBallOut = true;
					returnDataClass._catchID = CatchID;
					if (CsGameData.Instance.curMode == GameMode.HomerunMode)
					{
						BallMove.GetInstance().homerun_FlyOut = true;
					}
					return returnDataClass;
				}
			}
			bool flag2 = false;
			for (int j = 0; j < 9; j++)
			{
				if (j == 0)
				{
					continue;
				}
				CsDefender component2 = Defender[j].GetComponent<CsDefender>();
				float num4 = Vector3.Distance(arrivePos.mVec, Defender[j].transform.position);
				_ = arrivePos.mTime;
				float num5 = num4 / component2.GetSpeed();
				if (!(BallVel.z < 0f))
				{
					continue;
				}
				Vector3 zero = Vector3.zero;
				zero = (flag2 ? CsPhysics.getLongPos(BallSratPos, BallVel, component2.transform.position, component2.GetSpeed()) : CsPhysics.getShortPos(BallSratPos, BallVel, component2.transform.position, component2.GetSpeed()));
				if (zero.magnitude > 0f)
				{
					num4 = Vector3.Distance(zero, component2.transform.position);
					num5 = num4 / component2.GetSpeed();
					if (CsPhysics.getHeightPredict(BallMove.GetInstance().GetComponent<Rigidbody>(), num5) < 4.7f)
					{
						flag = true;
						if (num == 0f)
						{
							CatchID = j;
							num = num4;
							vector = zero;
							num2 = num5;
						}
						else if (num4 < num)
						{
							CatchID = j;
							num = num4;
							vector = zero;
							num2 = num5;
						}
					}
				}
				if (j == 8 && flag)
				{
					if (arrivePos.mVec.z < vector.z)
					{
						returnDataClass._firstCatchTime = num2;
						returnDataClass.FirstCatchPos = vector;
						returnDataClass._flyBallOut = true;
						returnDataClass._catchID = CatchID;
						if (CatchID == 8)
						{
							Defender[8].SetActive(value: true);
							if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
							{
								BaseballManager.GetInstance().MultiCharActive(_bool: false);
							}
						}
						Defender[CatchID].GetComponent<CsDefender>().MoveToPos(vector, DefenderState.Catch, BallCatchType.NoBound);
						Defender[CatchID].GetComponent<CsDefender>().CatchBall(num2, BallCatchType.NoBound);
						BaseballManager.GetInstance().Call_CatchBall(num2, BallCatchType.NoBound);
						BallMove.GetInstance().curType = BallCatchType.NoBound;
						if (CsGameData.Instance.curMode == GameMode.HomerunMode)
						{
							BallMove.GetInstance().homerun_FlyOut = true;
						}
						UnityEngine.Debug.Log("아웃");
					}
					else
					{
						returnDataClass._firstCatchTime = num2;
						returnDataClass.FirstCatchPos = vector;
						returnDataClass._catchID = CatchID;
						if (CatchID == 8)
						{
							Defender[8].SetActive(value: true);
							if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
							{
								BaseballManager.GetInstance().MultiCharActive(_bool: false);
							}
						}
						Defender[CatchID].GetComponent<CsDefender>().MoveToPos(vector, DefenderState.Catch, BallCatchType.Bound);
						Defender[CatchID].GetComponent<CsDefender>().CatchBall(num2, BallCatchType.Bound);
						BaseballManager.GetInstance().Call_CatchBall(num2, BallCatchType.Bound);
						BallMove.GetInstance().curType = BallCatchType.Bound;
						if (CsGameData.Instance.curMode == GameMode.HomerunMode && (CatchID == 8 || CatchID <= 4))
						{
							BallMove.GetInstance().homerun_BoundOut = true;
						}
						UnityEngine.Debug.Log("바운드");
						if (5 <= CatchID && CatchID <= 7)
						{
							returnDataClass.cancle = 50f;
						}
					}
					return returnDataClass;
				}
				if (j == 8 && !flag2)
				{
					flag2 = true;
					j = 0;
				}
			}
			num = 0f;
			flag = false;
			vector = Vector3.zero;
			num2 = 0f;
			Vector3 a = arrivePos.mVec;
			if (BallMove.GetInstance().fence)
			{
				a = BallMove.GetInstance().FencePos;
			}
			for (int k = 5; k < 8; k++)
			{
				CsDefender component3 = Defender[k].GetComponent<CsDefender>();
				float num6 = Vector3.Distance(a, component3.transform.position);
				if (BallVel.z < 0f)
				{
					if (k == 5)
					{
						num = num6;
						CatchID = k;
					}
					else if (num6 < num)
					{
						num = num6;
						CatchID = k;
					}
					if (k == 7)
					{
						Vector3 vector2 = BallVel;
						vector2.y = 0f;
						vector2.Normalize();
						Vector3 vector3 = new Vector3(vector2.x * 2f, 0f, vector2.z);
						vector3.Normalize();
						vector3 *= 198f;
						vector3.z -= 89f;
						_ = BallSratPos + Vector3.Dot(Defender[CatchID].transform.position - BallSratPos, vector2) * vector2;
						Defender[CatchID].GetComponent<CsDefender>().MoveToPos(vector3, DefenderState.OnlyRun, BallCatchType.Bound);
						int num7 = 0;
						num7 = ((!(0f < BallVel.x)) ? ((CatchID == 6) ? 7 : 6) : ((CatchID == 6) ? 5 : 6));
						Defender[num7].GetComponent<CsDefender>().MoveToPos(vector3, DefenderState.OnlyRun, BallCatchType.Bound);
						float num8 = 5f;
						returnDataClass._firstCatchTime = (Defender[CatchID].transform.position - vector3).magnitude / Defender[CatchID].GetComponent<CsDefender>().GetSpeed() + num8;
					}
				}
			}
			if (BallMove.GetInstance().fence)
			{
				returnDataClass._ballDownTime = arrivePos.mfenceTime;
			}
			else
			{
				returnDataClass._ballDownTime = arrivePos.mTime;
			}
			returnDataClass._catchID = CatchID;
			returnDataClass._defFail = true;
			return returnDataClass;
		}

		public void MoveToMyBasePos()
		{
			for (int i = 1; i < 4; i++)
			{
				if (i != CatchID)
				{
					Defender[i].GetComponent<CsDefender>().MoveToMyBasePos(0f);
				}
			}
			if (4 != CatchID)
			{
				if (CatchID == 2)
				{
					Defender[4].GetComponent<CsDefender>().MoveToMyBasePos(0f);
				}
				else if (5 <= CatchID)
				{
					_ = CatchID;
					_ = 7;
				}
			}
			if (CsGameData.Instance.curMode == GameMode.SBOMode)
			{
				Defender[0].GetComponent<LookAtIK>().enabled = false;
				Defender[0].GetComponent<FullBodyBipedIK>().enabled = false;
				Defender[0].GetComponent<CsDefender>().MoveToMyBasePos(1f);
			}
		}

		public void StartDefenceAfter(ReturnDataClass Data)
		{
			float[] array = new float[4];
			float[] array2 = new float[4];
			float[] array3 = new float[4];
			float[] array4 = new float[4];
			float num = 0f;
			float[] array5 = new float[4];
			_ = new bool[4];
			if (Data._flyBallOut)
			{
				MoveToMyBasePos();
				BallMove.GetInstance().homerun_FlyOut = true;
				StartCoroutine(FlyOutPlay(Data));
				StartCoroutine(Corou_OutButRun(Data._firstCatchTime + 1.9f));
				return;
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(OffensePF, Base[4].transform.position, Quaternion.identity);
			gameObject.GetComponent<CsOffense>().SetData(12f);
			ListOffense.Add(gameObject);
			for (int i = 0; i < ListOffense.Count; i++)
			{
				ListOffense[i].GetComponent<CsOffense>().Ready(Base);
			}
			for (int j = 0; j < ListOffense.Count; j++)
			{
				CsOffense component = ListOffense[j].GetComponent<CsOffense>();
				array[j] = (component.GetTargetPos(0) - component.transform.position).magnitude / component.GetSpeed();
				if (j == ListOffense.Count - 1)
				{
					array[j] += 1f;
				}
				if (component.GetTargetPos(1) != Vector3.zero)
				{
					array2[j] = (component.GetTargetPos(1) - component.GetTargetPos(0)).magnitude / component.GetSpeed();
				}
				if (component.GetTargetPos(2) != Vector3.zero)
				{
					array3[j] = (component.GetTargetPos(2) - component.GetTargetPos(1)).magnitude / component.GetSpeed();
				}
				if (Data._catchID == component.targetBase)
				{
					array4[j] = ((Data.FirstCatchPos - Base[component.targetBase].position).magnitude - 3.15f) / 9.5f + 1.25f;
				}
				else
				{
					array4[j] = ((Data.FirstCatchPos - Base[component.targetBase].position).magnitude - 3.15f) / 40f + 1.25f;
				}
				array5[j] = Data._firstCatchTime + array4[j];
			}
			for (int k = 0; k < ListOffense.Count - 1 && k + 1 != ListOffense.Count; k++)
			{
				if (ListOffense[k].GetComponent<CsOffense>().curBase == ListOffense[k + 1].GetComponent<CsOffense>().curBase + 1)
				{
					ListOffense[k].GetComponent<CsOffense>().noRunning = false;
				}
				else
				{
					ListOffense[k].GetComponent<CsOffense>().noRunning = true;
				}
			}
			for (int l = 0; l < ListOffense.Count; l++)
			{
				if (ListOffense[l].GetComponent<CsOffense>().noRunning && array5[l] < array[l])
				{
					array[l] = 0f;
					ListOffense[l].GetComponent<CsOffense>().targetBase = ListOffense[l].GetComponent<CsOffense>().curBase;
					ListOffense[l].GetComponent<CsOffense>().mayBase = ListOffense[l].GetComponent<CsOffense>().curBase;
				}
			}
			int num2 = 0;
			int num3 = 0;
			for (int m = 0; m < ListOffense.Count; m++)
			{
				if (outCount == 2)
				{
					break;
				}
				if (!(array5[m] < array[m]))
				{
					continue;
				}
				if (num2 == 0)
				{
					num2 = m;
				}
				outCount = 1;
				if (BaseballManager.GetInstance().outCount == 2)
				{
					continue;
				}
				for (int n = 0; n < ListOffense.Count; n++)
				{
					if (m != n)
					{
						int targetBase = ListOffense[m].GetComponent<CsOffense>().targetBase;
						int targetBase2 = ListOffense[n].GetComponent<CsOffense>().targetBase;
						num = ((Base[targetBase].position - Base[targetBase2].position).magnitude - 3.15f) / 40f + 1.25f;
						if (array5[m] + num < array[n])
						{
							num2 = m;
							num3 = n;
							outCount = 2;
							break;
						}
					}
				}
			}
			if (outCount == 1)
			{
				int num4 = ListOffense.Count - 1;
				while (0 <= num4)
				{
					if (array5[num4] < array[num4])
					{
						num2 = num4;
					}
					num4--;
				}
			}
			if (outCount != 0)
			{
				for (int num5 = 0; num5 < ListOffense.Count; num5++)
				{
					CsOffense component2 = ListOffense[num5].GetComponent<CsOffense>();
					component2.mayBase = component2.curBase + 1;
					if (num5 == ListOffense.Count - 1)
					{
						component2.MovingStart(component2.GetTargetPos(0), 1f);
					}
					else
					{
						component2.MovingStart(component2.GetTargetPos(0));
					}
				}
				StartCoroutine(HitterCorou());
				int num6 = 0;
				int num7 = 0;
				num6 = Data._catchID;
				for (int num8 = 0; num8 < 5; num8++)
				{
					if (Defender[num8].GetComponent<CsDefender>().curBase == ListOffense[num2].GetComponent<CsOffense>().targetBase)
					{
						num7 = num8;
						break;
					}
				}
				float num9 = Data._firstCatchTime + 1.25f;
				Vector3 firstCatchPos = Data.FirstCatchPos;
				firstCatchPos.y = 2.3f;
				Vector3 position = Base[ListOffense[num2].GetComponent<CsOffense>().targetBase].position;
				position.y = 2.3f;
				float num10 = (firstCatchPos - position).magnitude / 40f;
				float num11 = num9 + num10;
				if (num6 == num7 && (num6 == 1 || num6 == 3))
				{
					num11 = array5[num2];
					num10 = array5[num2] - num9;
				}
				MoveToMyBasePos();
				StartCoroutine(ThrowBallAndCatchCorou(num6, num7, num9, num10, position, _boolOut: true));
				OutNum[0] = num2;
				OutNum[1] = num3;
				if (outCount == 2)
				{
					num6 = num7;
					for (int num12 = 0; num12 < 5; num12++)
					{
						if (Defender[num12].GetComponent<CsDefender>().curBase == ListOffense[num3].GetComponent<CsOffense>().targetBase)
						{
							num7 = num12;
							break;
						}
					}
					num9 = num9 + num10 + 1.25f;
					firstCatchPos = Base[ListOffense[num2].GetComponent<CsOffense>().targetBase].position;
					firstCatchPos.y = 2.3f;
					position = Base[ListOffense[num3].GetComponent<CsOffense>().targetBase].position;
					position.y = 2.3f;
					num10 = (firstCatchPos - position).magnitude / 40f;
					StartCoroutine(ThrowBallAndCatchCorou(num6, num7, num9, num10, position, _boolOut: true));
					num11 = num9 + num10;
				}
				BallMove.GetInstance().BallDestroy(num11 + 1.9f);
				return;
			}
			bool[] array6 = new bool[ListOffense.Count];
			for (int num13 = 0; num13 < ListOffense.Count; num13++)
			{
				CsOffense component3 = ListOffense[num13].GetComponent<CsOffense>();
				if (component3.curBase != 3)
				{
					float num14 = array[num13] + array2[num13];
					array4[num13] = ((Data.FirstCatchPos - Base[component3.targetBase + 1].position).magnitude - 3.15f) / 40f + 1.25f;
					array5[num13] = Data._firstCatchTime + array4[num13];
					if (array2[num13] != 0f && num14 < array5[num13])
					{
						array6[num13] = true;
					}
					else
					{
						array6[num13] = false;
					}
				}
			}
			for (int num15 = 0; num15 < ListOffense.Count; num15++)
			{
				CsOffense component4 = ListOffense[num15].GetComponent<CsOffense>();
				component4.mayBase = component4.curBase + 1;
				if (num15 == ListOffense.Count - 1)
				{
					component4.MovingStart(component4.GetTargetPos(0), 1f);
				}
				else
				{
					component4.MovingStart(component4.GetTargetPos(0));
				}
				bool flag = true;
				if (num15 != 0 && component4.mayBase != 4 && component4.mayBase == ListOffense[num15 - 1].GetComponent<CsOffense>().mayBase)
				{
					flag = false;
				}
				if (array6[num15] && flag)
				{
					component4.mayBase++;
					component4.MovingStart(component4.GetTargetPos(1), array[num15]);
				}
			}
			StartCoroutine(HitterCorou());
			int num16 = 0;
			int catchId = 0;
			num16 = Data._catchID;
			for (int num17 = 0; num17 < 5; num17++)
			{
				if (Defender[num17].GetComponent<CsDefender>().curBase == ListOffense[0].GetComponent<CsOffense>().mayBase)
				{
					catchId = num17;
					break;
				}
			}
			float num18 = Data._firstCatchTime + 1.25f;
			Vector3 firstCatchPos2 = Data.FirstCatchPos;
			firstCatchPos2.y = 2.3f;
			Vector3 position2 = Base[2].position;
			position2.y = 2.3f;
			float num19 = (firstCatchPos2 - position2).magnitude / 40f;
			MoveToMyBasePos();
			if (4 < num16)
			{
				catchId = 2;
			}
			float num20 = num18 + num19;
			if (!Data._defFail)
			{
				StartCoroutine(ThrowBallAndCatchCorou(num16, catchId, num18, num19, position2, _boolOut: false));
			}
			else
			{
				num20 = Data._ballDownTime;
				if (ListOffense[ListOffense.Count - 1].GetComponent<CsOffense>().mayBase == 1)
				{
					BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Single_Hit, num20 + 1.8f);
				}
				else if (ListOffense[ListOffense.Count - 1].GetComponent<CsOffense>().mayBase == 2)
				{
					BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Double_Hit, num20 + 1.8f);
				}
			}
			BallMove.GetInstance().BallDestroy(num20 + 1.9f);
		}

		private IEnumerator FlyOutPlay(ReturnDataClass Data)
		{
			if (ListOffense.Count != 0 && ListOffense[0].GetComponent<CsOffense>().curBase == 3 && BaseballManager.GetInstance().outCount < 2)
			{
				CsOffense component = ListOffense[0].GetComponent<CsOffense>();
				float speed = component.GetSpeed();
				component.SetSpeed_OutPlay(component.GetSpeed() * 1.2f);
				float num = (component.GetTargetPos(0) - component.transform.position).magnitude / component.GetSpeed();
				float num2 = ((Data.BallDownPos - Base[4].position).magnitude - 3.15f) / 40f + 1.25f;
				UnityEngine.Debug.Log("_runnerTime : " + num);
				UnityEngine.Debug.Log("_throwTime : " + num2);
				UnityEngine.Debug.Log("CsOff.GetTargetPos(0) : " + component.GetTargetPos(0));
				UnityEngine.Debug.Log("(Data.FirstCatchPos : " + Data.FirstCatchPos);
				UnityEngine.Debug.Log("(CsOff.GetTargetPos(0) - CsOff.transform.position).magnitude : " + (component.GetTargetPos(0) - component.transform.position).magnitude);
				UnityEngine.Debug.Log("(Data.FirstCatchPos - CsOff.GetTargetPos(0)).magnitude : " + (Data.FirstCatchPos - component.GetTargetPos(0)).magnitude);
				if (5 <= CatchID && CatchID <= 7 && num < num2 + 2f)
				{
					BallMove.GetInstance().flyOutPlay = true;
					BallMove.GetInstance().flyOutPlayTime = Data._firstCatchTime + 1.25f + num2 + 2f;
					Vector3 ballDownPos = Data.BallDownPos;
					ballDownPos.y = 2.3f;
					Vector3 position = Base[4].position;
					position.y = 2.3f;
					float twoDt = (ballDownPos - position).magnitude / 40f;
					StartCoroutine(ThrowBallAndCatchCorou(CatchID, 0, Data._firstCatchTime + 1.25f, twoDt, position, _boolOut: false));
					component.MovingStart(component.HomeBasePos, Data._firstCatchTime);
					component.mayBase = 4;
					component.curBase = 4;
				}
				else
				{
					component.SetSpeed_OutPlay(speed);
				}
			}
			yield return null;
		}

		private void Func_OffenceCustom(GameObject Obj)
		{
			if (CsGameData.Instance.curState == State.Single)
			{
				Obj.GetComponent<CustomModelSettingCtrl>().Init(customModelData);
			}
			else if (CsGameData.Instance.curState == State.Multi)
			{
				if (CsGameData.Instance.curTeam == TeamPosition.Defense)
				{
					Obj.GetComponent<CustomModelSettingCtrl>().Init(BaseballManager.GetInstance().GetOtherId());
				}
				else if (CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					Obj.GetComponent<CustomModelSettingCtrl>().Init(BaseballManager.GetInstance().GetMyId());
				}
			}
		}

		private IEnumerator Corou_OutButRun(float dt)
		{
			yield return YieldInstructionCache.WaitForSeconds(1f);
			GameObject gameObject = UnityEngine.Object.Instantiate(OffensePF, BaseballManager.GetInstance().Hitter.transform.position, Quaternion.identity);
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				gameObject.transform.GetChild(i).gameObject.SetActive(value: true);
			}
			Func_OffenceCustom(gameObject);
			gameObject.GetComponent<CsOffense>().HitterRunAni();
			gameObject.GetComponent<CsOffense>().SetData(12f);
			gameObject.GetComponent<CsOffense>().Ready(Base);
			gameObject.GetComponent<CsOffense>().MovingStart(gameObject.GetComponent<CsOffense>().GetTargetPos(0));
			if (CsGameData.Instance.curState == State.Single)
			{
				BaseballManager.GetInstance().Hitter.SetActive(value: false);
			}
			else if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				BaseballManager.GetInstance().MultiCharActive(_bool: false);
			}
			UnityEngine.Object.Destroy(gameObject, dt - 1.1f);
		}

		private IEnumerator HitterCorou()
		{
			yield return YieldInstructionCache.WaitForSeconds(1f);
			ListOffense[ListOffense.Count - 1].transform.position = HitterStartTrs.transform.position;
			if (CsGameData.Instance.curState == State.Single)
			{
				BaseballManager.GetInstance().Hitter.SetActive(value: false);
			}
			else if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				BaseballManager.GetInstance().MultiCharActive(_bool: false);
			}
			if (CsGameData.Instance.curState == State.Multi)
			{
				_ = CsGameData.Instance.curTeam;
			}
			for (int i = 0; i < ListOffense[ListOffense.Count - 1].transform.childCount; i++)
			{
				ListOffense[ListOffense.Count - 1].transform.GetChild(i).gameObject.SetActive(value: true);
			}
			Func_OffenceCustom(ListOffense[ListOffense.Count - 1]);
			ListOffense[ListOffense.Count - 1].GetComponent<CsOffense>().HitterRunAni();
		}

		private IEnumerator ThrowBallAndCatchCorou(int _throwId, int _catchId, float _oneDt, float _twoDt, Vector3 EndPos, bool _boolOut)
		{
			if (_throwId == _catchId && (_throwId == 1 || _throwId == 3))
			{
				yield return YieldInstructionCache.WaitForSeconds(_oneDt - 0.5f);
				Defender[_throwId].GetComponent<CsDefender>().MoveToPos(Defender[_throwId].GetComponent<CsDefender>().GetMyBasePos(), DefenderState.OnlyRun, BallCatchType.None);
				yield return YieldInstructionCache.WaitForSeconds(_twoDt);
				Func_Referee(_throwId, _boolOut);
				yield break;
			}
			yield return YieldInstructionCache.WaitForSeconds(_oneDt - 0.75f);
			if (_throwId == 1 || _throwId == 3)
			{
				Defender[_throwId].GetComponent<CsDefender>().MoveToMyBasePos(1f);
			}
			if (_catchId == 4)
			{
				_catchId = 0;
			}
			else if (_throwId == 2 && _catchId == 2)
			{
				_catchId = 4;
			}
			Vector3 worldPosition = EndPos;
			worldPosition.y = 0f;
			Defender[_throwId].transform.LookAt(worldPosition);
			Defender[_throwId].GetComponent<CsDefender>().Call_ThrowBall();
			Defender[_catchId].transform.LookAt(Defender[_throwId].transform);
			Defender[_catchId].GetComponent<CsDefender>().Call_ThrowCatchBall();
			yield return YieldInstructionCache.WaitForSeconds(0.75f);
			BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Throw);
			Vector3 position = Defender[_throwId].GetComponent<CsDefender>().RHandTrs.position;
			Vector3 vector = (position - EndPos).normalized * 3f;
			Vector3 shotVelocityAtoB = CsPhysics.getShotVelocityAtoB(position, EndPos + vector, _twoDt);
			BallMove.GetInstance().transform.position = position;
			BallMove.GetInstance().transform.GetChild(0).gameObject.SetActive(value: true);
			BallMove.GetInstance().GetComponent<Rigidbody>().useGravity = true;
			BallMove.GetInstance().GetComponent<Rigidbody>().velocity = shotVelocityAtoB;
			BallMove.GetInstance().RemoveParticleTrail();
			BallMove.GetInstance().CreateParticleTrail();
			yield return YieldInstructionCache.WaitForSeconds(_twoDt - 0.01f);
			BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Tack);
			Func_Referee(_catchId, _boolOut);
			BallMove.GetInstance().BallStop();
			BallMove.GetInstance().transform.GetChild(0).gameObject.SetActive(value: false);
			Defender[_catchId].GetComponent<CsDefender>().Call_CatchParticle();
			if (outCount == 0)
			{
				BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Safe_1);
			}
		}

		private void Func_Referee(int _catchId, bool _boolOut)
		{
			if (_boolOut)
			{
				BaseballManager.GetInstance().Call_PlaySound(SoundTrack.Out_1);
				if (_catchId != 2)
				{
					RefereeAni[_catchId].Call_Ani("Out");
				}
			}
		}

		public void ResultScoreCheck()
		{
			if (outCount != 0)
			{
				if (outCount == 2)
				{
					UnityEngine.Object.Destroy(ListOffense[OutNum[1]]);
					ListOffense[OutNum[1]] = null;
				}
				UnityEngine.Object.Destroy(ListOffense[OutNum[0]]);
				ListOffense[OutNum[0]] = null;
				for (int i = 0; i < ListOffense.Count; i++)
				{
					if (ListOffense[i] == null)
					{
						ListOffense.RemoveAt(i--);
					}
				}
				BaseballManager.GetInstance().Call_OffenseOut(outCount);
			}
			if (2 < BaseballManager.GetInstance().outCount)
			{
				return;
			}
			bool flag = false;
			for (int j = 0; j < ListOffense.Count; j++)
			{
				CsOffense component = ListOffense[j].GetComponent<CsOffense>();
				component.SetResultBase();
				if (BallMove.GetInstance().homerun || BallMove.GetInstance().multiHomerunCheck)
				{
					component.curBase = 4;
				}
				if (component.curBase < 4)
				{
					continue;
				}
				UnityEngine.Object.Destroy(component.gameObject);
				ListOffense.RemoveAt(j--);
				flag = true;
				if (CsGameData.Instance.curState == State.Single || (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense))
				{
					if (CsGameData.Instance.inning % 2 == 1)
					{
						CsGameData.Instance.firstScore++;
						int num = (CsGameData.Instance.inning - 1) / 2;
						CsGameData.Instance.InningScore_1[num]++;
					}
					else
					{
						CsGameData.Instance.secondScore++;
						int num2 = (CsGameData.Instance.inning - 1) / 2;
						CsGameData.Instance.InningScore_2[num2]++;
					}
					BaseballManager.GetInstance().SideScript.GetComponent<CsScoreBoardUI>().Func_ActiveOnOff();
					BaseballManager.GetInstance().Call_PlaySoundScore();
				}
				if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					Vector3[] array = new Vector3[4];
					array[0].x = 11f;
					array[1].x = CsGameData.Instance.firstScore;
					array[1].y = CsGameData.Instance.secondScore;
					array[2] = new Vector3(CsGameData.Instance.InningScore_1[0], CsGameData.Instance.InningScore_1[1], CsGameData.Instance.InningScore_1[2]);
					array[3] = new Vector3(CsGameData.Instance.InningScore_2[0], CsGameData.Instance.InningScore_2[1], CsGameData.Instance.InningScore_2[2]);
					BaseballManager.GetInstance().RPC_AllData_Public(array);
				}
			}
			if (flag)
			{
				BaseballManager.GetInstance().ScoreUIAction(1);
			}
			if (6 < Mathf.Abs(CsGameData.Instance.firstScore - CsGameData.Instance.secondScore) && CsGameData.Instance.inning % 2 == 1)
			{
				BaseballManager.GetInstance().SBOGameEndUI();
			}
		}

		public void BallAdvantage()
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(OffensePF, new Vector3(0f, -5f, 0f), Quaternion.identity);
			gameObject.GetComponent<CsOffense>().curBase = 1;
			gameObject.GetComponent<CsOffense>().targetBase = 2;
			gameObject.GetComponent<CsOffense>().mayBase = 1;
			gameObject.GetComponent<CsOffense>().SetData(12f);
			for (int i = 0; i < gameObject.transform.childCount; i++)
			{
				gameObject.transform.GetChild(i).gameObject.SetActive(value: true);
			}
			Func_OffenceCustom(gameObject);
			ListOffense.Add(gameObject);
			int num = ListOffense.Count - 2;
			while (0 <= num)
			{
				if (ListOffense[num].GetComponent<CsOffense>().curBase == ListOffense[num + 1].GetComponent<CsOffense>().curBase)
				{
					ListOffense[num].GetComponent<CsOffense>().curBase++;
					ListOffense[num].GetComponent<CsOffense>().targetBase++;
					ListOffense[num].GetComponent<CsOffense>().mayBase++;
				}
				num--;
			}
			bool flag = false;
			if (ListOffense[0].GetComponent<CsOffense>().curBase == 4)
			{
				UnityEngine.Object.Destroy(ListOffense[0]);
				ListOffense.RemoveAt(0);
				flag = true;
				if (CsGameData.Instance.curState == State.Single || (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense))
				{
					if (CsGameData.Instance.inning % 2 == 1)
					{
						CsGameData.Instance.firstScore++;
						int num2 = (CsGameData.Instance.inning - 1) / 2;
						CsGameData.Instance.InningScore_1[num2]++;
					}
					else
					{
						CsGameData.Instance.secondScore++;
						int num3 = (CsGameData.Instance.inning - 1) / 2;
						CsGameData.Instance.InningScore_2[num3]++;
					}
					BaseballManager.GetInstance().SideScript.GetComponent<CsScoreBoardUI>().Func_ActiveOnOff();
				}
				if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Offense)
				{
					Vector3[] array = new Vector3[2];
					array[0].x = 11f;
					array[1].x = CsGameData.Instance.firstScore;
					array[1].y = CsGameData.Instance.secondScore;
					BaseballManager.GetInstance().RPC_AllData_Public(array);
				}
			}
			if (flag)
			{
				BaseballManager.GetInstance().ScoreUIAction(1);
			}
			if (6 < Mathf.Abs(CsGameData.Instance.firstScore - CsGameData.Instance.secondScore) && CsGameData.Instance.inning % 2 == 1)
			{
				BaseballManager.GetInstance().SBOGameEndUI();
			}
		}

		public void Call_ChangeInningMove()
		{
			Defender[0].GetComponent<FullBodyBipedIK>().enabled = false;
			Defender[0].GetComponent<LookAtIK>().enabled = false;
			Defender[8].SetActive(value: true);
			for (int i = 0; i < 9; i++)
			{
				Defender[i].GetComponent<CsDefender>().InningMove(ChangeInning_Defender.position);
			}
			for (int j = 0; j < ListOffense.Count; j++)
			{
				ListOffense[j].SetActive(value: false);
			}
			if (CsGameData.Instance.curState == State.Single)
			{
				BaseballManager.GetInstance().Hitter.SetActive(value: false);
			}
			else if (CsGameData.Instance.curState == State.Multi && CsGameData.Instance.curTeam == TeamPosition.Defense)
			{
				BaseballManager.GetInstance().MultiCharActive(_bool: false);
			}
		}

		public void Call_HomerunDefenderStop(float dt = 3.5f)
		{
			StartCoroutine(Corou_HomerunDefenderStop(dt));
		}

		private IEnumerator Corou_HomerunDefenderStop(float dt)
		{
			yield return YieldInstructionCache.WaitForSeconds(dt);
			for (int i = 5; i < 8; i++)
			{
				Defender[i].GetComponent<CsDefender>().StopAllCoroutines();
				Defender[i].GetComponent<CsDefender>().ResetAnimator();
			}
		}
	}
	public class LocalizingBaseball : MonoBehaviour
	{
		public GameObject MovieAd;

		public GameObject[] Banner;

		public GameObject[] BaseballAd;

		public GameObject[] HomerunBanner;

		public VideoClip Movie_global;

		public VideoClip Movie_chinese;

		public Material BannerMat_global;

		public Material BannerMat_chinese;

		public Material BaseballAdMat_global;

		public Material BaseballAdMat_chinese;

		public Material[] HomerunBannerMat_global;

		public Material[] HomerunBannerMat_chinese;

		public GameObject[] SprotVR_Fbx_global;

		public GameObject[] SprotVR_Fbx_chinese;

		public TextMeshPro[] TextPro;

		public TMP_FontAsset TMP_Font_global;

		public TMP_FontAsset TMP_Font_chinese;

		public GameObject inning_th;

		public GameObject inning_th2;

		private void Start()
		{
			Localizing(PublicGameUIManager.gameSetting.GetLanguageState());
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(Localizing);
		}

		private void Localizing(LanguageState languageState)
		{
			StartCoroutine(DelayCorou(languageState));
		}

		private IEnumerator DelayCorou(LanguageState languageState)
		{
			yield return null;
			Material[] array = new Material[2];
			Material material;
			Material material2;
			TMP_FontAsset font;
			if (languageState == LanguageState.schinese || languageState == LanguageState.tchinese)
			{
				material = BannerMat_chinese;
				material2 = BaseballAdMat_chinese;
				array[0] = HomerunBannerMat_chinese[0];
				array[1] = HomerunBannerMat_chinese[1];
				font = TMP_Font_chinese;
				MovieAd.GetComponent<VideoPlayer>().clip = Movie_chinese;
				for (int i = 0; i < SprotVR_Fbx_global.Length; i++)
				{
					SprotVR_Fbx_global[i].SetActive(value: false);
					SprotVR_Fbx_chinese[i].SetActive(value: true);
				}
				inning_th.GetComponent<Text>().text = ((CsGameData.Instance.inning - 1) / 2 + 7).ToString();
				inning_th2.GetComponent<Text>().text = ((CsGameData.Instance.inning - 1) / 2 + 7).ToString();
			}
			else
			{
				material = BannerMat_global;
				material2 = BaseballAdMat_global;
				array[0] = HomerunBannerMat_global[0];
				array[1] = HomerunBannerMat_global[1];
				font = TMP_Font_global;
				MovieAd.GetComponent<VideoPlayer>().clip = Movie_global;
				for (int j = 0; j < SprotVR_Fbx_global.Length; j++)
				{
					SprotVR_Fbx_global[j].SetActive(value: true);
					SprotVR_Fbx_chinese[j].SetActive(value: false);
				}
				inning_th.GetComponent<Text>().text = (CsGameData.Instance.inning - 1) / 2 + 7 + "th";
				inning_th2.GetComponent<Text>().text = (CsGameData.Instance.inning - 1) / 2 + 7 + "th";
			}
			MovieAd.GetComponent<VideoPlayer>().Play();
			Material[] materials = Banner[0].GetComponent<MeshRenderer>().materials;
			materials[1] = material;
			Banner[0].GetComponent<MeshRenderer>().materials = materials;
			materials = Banner[1].GetComponent<MeshRenderer>().materials;
			materials[1] = material;
			Banner[1].GetComponent<MeshRenderer>().materials = materials;
			materials = BaseballAd[0].GetComponent<MeshRenderer>().materials;
			materials[1] = material2;
			BaseballAd[0].GetComponent<MeshRenderer>().materials = materials;
			BaseballAd[1].GetComponent<MeshRenderer>().materials = materials;
			materials = BaseballAd[2].GetComponent<MeshRenderer>().materials;
			materials[2] = material2;
			BaseballAd[2].GetComponent<MeshRenderer>().materials = materials;
			BaseballAd[3].GetComponent<MeshRenderer>().materials = materials;
			materials = HomerunBanner[0].GetComponent<MeshRenderer>().materials;
			materials[0] = array[0];
			HomerunBanner[0].GetComponent<MeshRenderer>().materials = materials;
			materials = HomerunBanner[1].GetComponent<MeshRenderer>().materials;
			materials[0] = array[1];
			HomerunBanner[1].GetComponent<MeshRenderer>().materials = materials;
			for (int k = 0; k < TextPro.Length; k++)
			{
				TextPro[k].font = font;
			}
			if (languageState != LanguageState.schinese && languageState != LanguageState.tchinese)
			{
				TextPro[0].text = "Base On Balls";
				TextPro[1].text = "Strike Out";
				TextPro[2].text = "Hit By Pitch";
			}
		}
	}
	public class ReturnDataClass
	{
		public int _catchID;

		public bool _flyBallOut;

		public bool _underBallOut;

		public float _firstCatchTime;

		public Vector3 FirstCatchPos;

		public float _ballDownTime;

		public float _firstRunnerTime;

		public Vector3 BallDownPos;

		public float cancle;

		public bool pong;

		public bool foul;

		public bool _defFail;
	}
	public class VelocityColl : MonoBehaviour
	{
		public CbatFollower gBat;

		public int id;

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.tag == "Ball")
			{
				gBat.EnterFunc(base.transform.position, collision.GetContact(0).point, id);
			}
		}
	}
}
namespace UnityTemplateProjects
{
	public class SimpleCameraController : MonoBehaviour
	{
		private class CameraState
		{
			public float yaw;

			public float pitch;

			public float roll;

			public float x;

			public float y;

			public float z;

			public void SetFromTransform(Transform t)
			{
				pitch = t.eulerAngles.x;
				yaw = t.eulerAngles.y;
				roll = t.eulerAngles.z;
				x = t.position.x;
				y = t.position.y;
				z = t.position.z;
			}

			public void Translate(Vector3 translation)
			{
				Vector3 vector = Quaternion.Euler(pitch, yaw, roll) * translation;
				x += vector.x;
				y += vector.y;
				z += vector.z;
			}

			public void LerpTowards(CameraState target, float positionLerpPct, float rotationLerpPct)
			{
				yaw = Mathf.Lerp(yaw, target.yaw, rotationLerpPct);
				pitch = Mathf.Lerp(pitch, target.pitch, rotationLerpPct);
				roll = Mathf.Lerp(roll, target.roll, rotationLerpPct);
				x = Mathf.Lerp(x, target.x, positionLerpPct);
				y = Mathf.Lerp(y, target.y, positionLerpPct);
				z = Mathf.Lerp(z, target.z, positionLerpPct);
			}

			public void UpdateTransform(Transform t)
			{
				t.eulerAngles = new Vector3(pitch, yaw, roll);
				t.position = new Vector3(x, y, z);
			}
		}

		private CameraState m_TargetCameraState = new CameraState();

		private CameraState m_InterpolatingCameraState = new CameraState();

		[Header("Movement Settings")]
		[Tooltip("Exponential boost factor on translation, controllable by mouse wheel.")]
		public float boost = 3.5f;

		[Tooltip("Time it takes to interpolate camera position 99% of the way to the target.")]
		[Range(0.001f, 1f)]
		public float positionLerpTime = 0.2f;

		[Header("Rotation Settings")]
		[Tooltip("X = Change in mouse position.\nY = Multiplicative factor for camera rotation.")]
		public AnimationCurve mouseSensitivityCurve = new AnimationCurve(new Keyframe(0f, 0.5f, 0f, 5f), new Keyframe(1f, 2.5f, 0f, 0f));

		[Tooltip("Time it takes to interpolate camera rotation 99% of the way to the target.")]
		[Range(0.001f, 1f)]
		public float rotationLerpTime = 0.01f;

		[Tooltip("Whether or not to invert our Y axis for mouse input to rotation.")]
		public bool invertY;

		private void OnEnable()
		{
			m_TargetCameraState.SetFromTransform(base.transform);
			m_InterpolatingCameraState.SetFromTransform(base.transform);
		}

		private Vector3 GetInputTranslationDirection()
		{
			Vector3 result = default(Vector3);
			if (Input.GetKey(KeyCode.W))
			{
				result += Vector3.forward;
			}
			if (Input.GetKey(KeyCode.S))
			{
				result += Vector3.back;
			}
			if (Input.GetKey(KeyCode.A))
			{
				result += Vector3.left;
			}
			if (Input.GetKey(KeyCode.D))
			{
				result += Vector3.right;
			}
			if (Input.GetKey(KeyCode.Q))
			{
				result += Vector3.down;
			}
			if (Input.GetKey(KeyCode.E))
			{
				result += Vector3.up;
			}
			return result;
		}

		private void Update()
		{
			Vector3 zero = Vector3.zero;
			if (Input.GetKey(KeyCode.Escape))
			{
				UnityEngine.Application.Quit();
			}
			if (Input.GetMouseButtonDown(1))
			{
				Cursor.lockState = CursorLockMode.Locked;
			}
			if (Input.GetMouseButtonUp(1))
			{
				Cursor.visible = true;
				Cursor.lockState = CursorLockMode.None;
			}
			if (Input.GetMouseButton(1))
			{
				Vector2 vector = new Vector2(Input.GetAxis("Mouse X"), Input.GetAxis("Mouse Y") * (float)(invertY ? 1 : (-1)));
				float num = mouseSensitivityCurve.Evaluate(vector.magnitude);
				m_TargetCameraState.yaw += vector.x * num;
				m_TargetCameraState.pitch += vector.y * num;
			}
			zero = GetInputTranslationDirection() * Time.deltaTime;
			if (Input.GetKey(KeyCode.LeftShift))
			{
				zero *= 10f;
			}
			boost += Input.mouseScrollDelta.y * 0.2f;
			zero *= Mathf.Pow(2f, boost);
			m_TargetCameraState.Translate(zero);
			float positionLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / positionLerpTime * Time.deltaTime);
			float rotationLerpPct = 1f - Mathf.Exp(Mathf.Log(0.00999999f) / rotationLerpTime * Time.deltaTime);
			m_InterpolatingCameraState.LerpTowards(m_TargetCameraState, positionLerpPct, rotationLerpPct);
			m_InterpolatingCameraState.UpdateTransform(base.transform);
		}
	}
}
namespace TENNIS
{
	[Serializable]
	public class SwingMotionInfo
	{
		public string motionName;

		public float impactTime;

		public bool isFront;

		public bool isForhand;

		public float posX;

		public float posZ;
	}
	public struct BestPointAndTime
	{
		public Vector3 point;

		public float time;

		public bool frontHit;

		public HitMotion hitMotion;

		public float waitTime;
	}
	[Serializable]
	public class ServeAnimInfo
	{
		public float getBallFrame;

		public float raiseBallFrame;

		public float hitBallFrame;

		public float raiseBallvelocityY;

		public Vector3 serveVelocity;

		public Vector3 AIServePos;

		public string animName;
	}
	public enum HitMotion
	{
		Smash,
		Vollry,
		BestHit,
		NearestHit
	}
	public class AIBehaviour : MonoBehaviour
	{
		public delegate void HitBall(bool isServe, bool isSmash);

		public static BestPointAndTime bestPointAndTime;

		public static AIBehaviour instance;

		private Animator anim;

		private bool MoveStop;

		private bool isMoving;

		private Vector3 destination = Vector3.zero;

		private Vector2 smoothDeltaPosition = Vector2.zero;

		private Vector2 velocity = Vector2.zero;

		public List<SwingMotionInfo> ListSwingMotionInfo = new List<SwingMotionInfo>();

		private SwingMotionInfo currentSwingMotionInfo;

		public List<ServeAnimInfo> serveInfoList;

		private ServeAnimInfo currentServeAnimInfo;

		private float animDelay;

		private bool isPlayerSmash;

		private float moveSpeed;

		private LookAtIK lookAtIK;

		public Transform LeftHandTR;

		public Vector3 testPos;

		private float currentMoveTime;

		private Coroutine lookAtIKCoroutine;

		public static event HitBall HitBallEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			Cfollower.HitBallEvent += PlayerHitBall;
			GameManager.GameResumeEvent += GameResume;
			GameManager.GameStartEvent += GameResume;
			GameManager.PanjungEvent += ReAction;
		}

		private void OnDisable()
		{
			Cfollower.HitBallEvent -= PlayerHitBall;
			GameManager.GameResumeEvent -= GameResume;
			GameManager.GameStartEvent -= GameResume;
			GameManager.PanjungEvent -= ReAction;
		}

		private void Start()
		{
			InitData();
		}

		private void InitData()
		{
			moveSpeed = 3f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level / 2.5f;
			anim = GetComponent<Animator>();
			lookAtIK = GetComponent<LookAtIK>();
			lookAtIK.solver.target = BallBehaviour.instance.transform;
		}

		private void PlayerHitBall(bool isSmash, Vector3 cPoint)
		{
			MoveStop = false;
			getBestPoint bestPoint = BallBehaviour.instance.getBestPoint(base.transform.position);
			isPlayerSmash = isSmash;
			if (!bestPoint.isSafe)
			{
				UnityEngine.Debug.Log("gbp isSafe false");
				Vector3 bestPoint2 = bestPoint.bestPoint;
				bestPoint2.y = 0f;
				destination = bestPoint2;
				bestPointAndTime.time = moveSpeed * 10f;
				UnityEngine.Debug.DrawRay(bestPoint2, Vector3.up, Color.cyan, 5f);
				return;
			}
			bestPointAndTime = GetStateHitMotion(bestPoint);
			switch (bestPointAndTime.hitMotion)
			{
			case HitMotion.Vollry:
				UnityEngine.Debug.Log("<color=red> Vollry!! </color>");
				break;
			case HitMotion.Smash:
				UnityEngine.Debug.Log("<color=red> Samsh!! </color>");
				break;
			case HitMotion.BestHit:
				UnityEngine.Debug.Log("<color=red> BestHit!! </color>");
				break;
			case HitMotion.NearestHit:
				UnityEngine.Debug.Log("<color=red> NearestHit!! </color>");
				break;
			}
			int num = 0;
			Vector3 point = bestPointAndTime.point;
			point.y = 0f;
			Vector3.Distance(bestPointAndTime.point, base.transform.position);
			float num2 = 100000f;
			for (int i = 0; i < ListSwingMotionInfo.Count; i++)
			{
				if (!(bestPointAndTime.waitTime >= 0.15f) || !ListSwingMotionInfo[i].motionName.Contains("run"))
				{
					Vector3 point2 = bestPointAndTime.point;
					point2.x += ListSwingMotionInfo[i].posZ * -1f;
					point2.z += ListSwingMotionInfo[i].posX;
					point2.y = 0f;
					float num3 = Vector3.Distance(point2, base.transform.position);
					if (num3 < num2)
					{
						num2 = num3;
						num = i;
					}
				}
			}
			if (bestPointAndTime.waitTime < 0.15f)
			{
				num = (ListSwingMotionInfo[num].isForhand ? ListSwingMotionInfo.FindIndex((SwingMotionInfo x) => x.motionName.Contains("runFore")) : ListSwingMotionInfo.FindIndex((SwingMotionInfo x) => x.motionName.Contains("runBack")));
			}
			if (bestPointAndTime.hitMotion == HitMotion.Smash)
			{
				num = ListSwingMotionInfo.FindIndex((SwingMotionInfo x) => x.motionName.Contains("smash"));
			}
			else if (bestPointAndTime.hitMotion != 0 && ListSwingMotionInfo[num].motionName == "smash")
			{
				num--;
			}
			else if (ListSwingMotionInfo[num].motionName == "backHand")
			{
				int num4 = UnityEngine.Random.Range(0, 2);
				num += ((num4 != 0) ? 1 : 0);
			}
			UnityEngine.Debug.Log(num);
			try
			{
				bestPointAndTime.point.x += ListSwingMotionInfo[num].posZ * -1f;
				bestPointAndTime.point.z += ListSwingMotionInfo[num].posX;
				bestPointAndTime.point.y = 0f;
			}
			catch (ArgumentOutOfRangeException)
			{
				bestPointAndTime.point.x += ListSwingMotionInfo[0].posZ * -1f;
				bestPointAndTime.point.z += ListSwingMotionInfo[0].posX;
				bestPointAndTime.point.y = 0f;
			}
			destination = bestPointAndTime.point;
			currentSwingMotionInfo = ListSwingMotionInfo[num];
			StartCoroutine(IEnum_HitBall());
		}

		private IEnumerator IEnum_HitBall()
		{
			float impactTime = bestPointAndTime.time - currentSwingMotionInfo.impactTime;
			float timeChecker2 = 0f;
			while (impactTime >= timeChecker2)
			{
				timeChecker2 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			if (GameManager.instance.isOnPanjung || GameManager.instance.isFault)
			{
				yield break;
			}
			PlayAnim(currentSwingMotionInfo.motionName);
			if (impactTime < 0f)
			{
				UnityEngine.Debug.Log("impackTime over");
				yield break;
			}
			timeChecker2 = 0f;
			while (currentSwingMotionInfo.impactTime >= timeChecker2)
			{
				timeChecker2 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			if (!GameManager.instance.isOnPanjung && !GameManager.instance.isFault)
			{
				if (Math.Truncate(Vector3.Distance(destination, base.transform.position) * 100f) / 100.0 > 0.10000000149011612)
				{
					UnityEngine.Debug.Log("목표지점에 도달하지못함");
				}
				else
				{
					SetHitBallVelocity();
				}
			}
		}

		private BestPointAndTime GetStateHitMotion(getBestPoint gbp)
		{
			Vector3 b = new Vector3(gbp.vollryPoint.x, 0f, gbp.vollryPoint.z);
			Vector3 b2 = new Vector3(gbp.smashPoint.x, 0f, gbp.smashPoint.z);
			Vector3 b3 = new Vector3(gbp.nearestPoint.x, 0f, gbp.nearestPoint.z);
			Vector3 b4 = new Vector3(gbp.bestPoint.x, 0f, gbp.bestPoint.z);
			float num = Vector3.Distance(base.transform.position, b);
			float num2 = Vector3.Distance(base.transform.position, b2);
			float num3 = Vector3.Distance(base.transform.position, b3);
			float num4 = Vector3.Distance(base.transform.position, b4);
			float vpTime = gbp.vpTime;
			float spTime = gbp.spTime;
			float npTime = gbp.npTime;
			float bpTime = gbp.bpTime;
			float num5 = num / moveSpeed;
			float num6 = num2 / moveSpeed;
			float num7 = num3 / moveSpeed;
			float num8 = num4 / moveSpeed;
			if (num6 < spTime && gbp.smashPoint.z < -3f && spTime - num6 > 0.4f)
			{
				bestPointAndTime.point = gbp.smashPoint;
				bestPointAndTime.time = gbp.spTime;
				bestPointAndTime.hitMotion = HitMotion.Smash;
				bestPointAndTime.waitTime = spTime - num6;
			}
			else if (num5 < vpTime)
			{
				bestPointAndTime.point = gbp.vollryPoint;
				bestPointAndTime.time = gbp.vpTime;
				bestPointAndTime.hitMotion = HitMotion.Vollry;
				bestPointAndTime.waitTime = vpTime - num5;
			}
			else if (num8 < bpTime)
			{
				bestPointAndTime.point = gbp.bestPoint;
				bestPointAndTime.time = gbp.bpTime;
				bestPointAndTime.hitMotion = HitMotion.BestHit;
				bestPointAndTime.waitTime = bpTime - num8;
			}
			else
			{
				bestPointAndTime.point = gbp.nearestPoint;
				bestPointAndTime.time = gbp.npTime;
				bestPointAndTime.hitMotion = HitMotion.NearestHit;
				bestPointAndTime.waitTime = npTime - num7;
			}
			UnityEngine.Debug.Log("<color=green> waitTime : " + bestPointAndTime.waitTime + "  " + bestPointAndTime.time + "</color>");
			return bestPointAndTime;
		}

		private void PlayAnim(string animName)
		{
			anim.SetTrigger(animName);
			animDelay = 0f;
		}

		private void AnimTimeCheck()
		{
			animDelay += Time.deltaTime;
		}

		private void SetHitBallVelocity()
		{
			float x = UnityEngine.Random.Range(-1.3f, 1.3f);
			float z = UnityEngine.Random.Range(1f, 7f);
			Vector3 b = new Vector3(x, 0f, z);
			float aISwingPower = GetAISwingPower(bestPointAndTime.waitTime);
			float value = UnityEngine.Random.Range((float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * -0.5f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.5f);
			float f = UnityEngine.Random.Range((float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * -0.5f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.5f);
			f = (currentSwingMotionInfo.isForhand ? (Mathf.Abs(f) * -1f) : Mathf.Abs(f));
			f = Mathf.Clamp(f, -3f, 3f);
			value = Mathf.Clamp(value, -4f, 4f);
			Vector3 vector = new Vector3(value, f, 0f);
			Vector3 velocityAtoBSpin = BallPhysics.getVelocityAtoBSpin(BallBehaviour.instance.transform.position, b, aISwingPower, vector);
			float num = UnityEngine.Random.Range(0f, 5f);
			float targetDis = Vector3.Distance(destination, base.transform.position);
			float scaler = (currentSwingMotionInfo.isForhand ? (0f - num) : num);
			velocityAtoBSpin = BallPhysics.instance.getReviseAxisY(velocityAtoBSpin, scaler, BallBehaviour.instance.transform.position);
			bool flag = isOutBall(targetDis, bestPointAndTime.time, isPlayerSmash, bestPointAndTime.waitTime, GameManager.instance.RallyCount);
			bool flag2 = currentSwingMotionInfo.motionName.Equals("smash");
			if (flag2)
			{
				flag = false;
			}
			UnityEngine.Debug.Log(string.Concat("AI Velocity : ", velocityAtoBSpin, "   ", velocityAtoBSpin.magnitude, "  ", aISwingPower));
			if (flag)
			{
				float num2 = UnityEngine.Random.Range(0, 3);
				if (isPlayerSmash)
				{
					num2 = 0f;
				}
				if (num2 == 0f)
				{
					float num3 = UnityEngine.Random.Range(-20f, -15f);
					UnityEngine.Debug.Log("나가는 공 : " + num3);
					velocityAtoBSpin = BallPhysics.instance.getReviseAxisX(velocityAtoBSpin, num3, BallBehaviour.instance.transform.position);
					float scaler2 = UnityEngine.Random.Range(-25f, 25f);
					velocityAtoBSpin = BallPhysics.instance.getReviseAxisY(velocityAtoBSpin, scaler2, BallBehaviour.instance.transform.position);
				}
				else if (num2 == 1f)
				{
					UnityEngine.Debug.Log("뜬공");
					float z2 = UnityEngine.Random.Range(2.5f, 4f);
					float num4 = UnityEngine.Random.Range(0.15f, 0.2f);
					b = new Vector3(b.x, 0f, z2);
					aISwingPower += num4;
					velocityAtoBSpin = BallPhysics.getVelocityAtoBSpin(BallBehaviour.instance.transform.position, b, aISwingPower, vector);
				}
				else if (num2 == 2f)
				{
					UnityEngine.Debug.Log("높은공");
					float z3 = UnityEngine.Random.Range(2.5f, 4f);
					float num5 = UnityEngine.Random.Range(0.25f, 0.3f);
					b = new Vector3(b.x, 0f, z3);
					aISwingPower += num5;
					velocityAtoBSpin = BallPhysics.getVelocityAtoBSpin(BallBehaviour.instance.transform.position, b, aISwingPower, vector);
				}
				BallBehaviour.instance.SetParticle(BallBehaviour.instance.transform.position);
				BallBehaviour.instance.SetSmashParticle(flag2);
				BallBehaviour.instance.SetAllStop();
				BallPhysics.instance.SetPreview(velocityAtoBSpin, vector, BallBehaviour.instance.transform.position, Vector3.zero, useAI: true);
				GameManager.instance.SetOtherPlayerBallTarget();
				AIBehaviour.HitBallEvent?.Invoke(isServe: false, flag2);
				return;
			}
			if (flag2)
			{
				float num6 = UnityEngine.Random.Range(0f, 100f);
				float num7 = 60f - (float)(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 10);
				if (num6 < num7)
				{
					flag2 = false;
					return;
				}
			}
			BallBehaviour.instance.SetSmashParticle(flag2);
			BallBehaviour.instance.SetAllStop();
			BallBehaviour.instance.SetParticle(BallBehaviour.instance.transform.position);
			Vector3 zero = Vector3.zero;
			BallPhysics.instance.PhysicsSimulator(velocityAtoBSpin, BallBehaviour.instance.transform.position, vector, zero, flag2, useAI: true);
			GameManager.instance.SetOtherPlayerBallTarget();
			AIBehaviour.HitBallEvent?.Invoke(isServe: false, flag2);
		}

		private float GetAISwingPower(float waitTime)
		{
			return UnityEngine.Random.Range(1.25f, 1.35f) - waitTime * 0.2f - UnityEngine.Random.Range(0f, (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.065f);
		}

		private Vector3 GetSmashVelocity(Vector3 velo)
		{
			velo *= 1.65f;
			return velo;
		}

		private void AIServe()
		{
			StartCoroutine(IEnum_AIServe());
		}

		private IEnumerator IEnum_AIServe()
		{
			BallBehaviour.instance.SetTrigger(useTrigger: true);
			BallBehaviour.instance.gameObject.SetActive(value: false);
			while (isMoving)
			{
				yield return null;
			}
			yield return new WaitForSeconds(1.5f);
			BallBehaviour.instance.SetTrigger(useTrigger: false);
			PlayAnim(serveInfoList[0].animName);
			float timeChecher3 = 0f;
			float GetBallFrame = serveInfoList[0].getBallFrame;
			float raiseBallFrame = serveInfoList[0].raiseBallFrame - GetBallFrame;
			float HitBallFrame = serveInfoList[0].hitBallFrame - raiseBallFrame - GetBallFrame;
			while (GetBallFrame > timeChecher3)
			{
				timeChecher3 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			GetBall();
			timeChecher3 = 0f;
			while (raiseBallFrame > timeChecher3)
			{
				timeChecher3 += Time.fixedDeltaTime;
				BallBehaviour.instance.transform.localPosition = Vector3.zero;
				yield return new WaitForFixedUpdate();
			}
			BallBehaviour.instance.gameObject.SetActive(value: true);
			SetlookAtIK(isAdd: true);
			RaiseBall(currentServeAnimInfo.raiseBallvelocityY);
			timeChecher3 = 0f;
			while (HitBallFrame > timeChecher3)
			{
				timeChecher3 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			Vector3 serveVelocity = currentServeAnimInfo.serveVelocity;
			HitServeBall(serveVelocity);
		}

		public void GetBall()
		{
			BallBehaviour.instance.SetSmashParticle(isUse: false);
			BallBehaviour.instance.ResetBall(LeftHandTR.position);
			BallBehaviour.instance.transform.parent = LeftHandTR;
			BallBehaviour.instance.transform.localPosition = Vector3.zero;
			BallBehaviour.instance.SetViewBall(onoff: true);
		}

		public void RaiseBall(float veloY)
		{
			Vector3 play = new Vector3(0f, veloY, 0f);
			BallBehaviour.instance.SetPlay(play);
			BallBehaviour.instance.transform.parent = null;
		}

		public void HitServeBall(Vector3 velo)
		{
			velo.x += UnityEngine.Random.Range(-0.3f, 0.3f);
			velo *= 1f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.13f;
			velo = BallPhysics.instance.getReviseAxisX(velo, (float)(-SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level) * 2.2f, BallBehaviour.instance.transform.position);
			BallPhysics.instance.SetPreview(velo, Vector3.zero, BallBehaviour.instance.transform.position, Vector3.zero, useAI: true);
			BallBehaviour.instance.SetParticle(BallBehaviour.instance.transform.position);
			GameManager.instance.SetOtherPlayerBallTarget();
			BallBehaviour.instance.SetColEnable(onoff: true);
			AIBehaviour.HitBallEvent?.Invoke(isServe: true, isSmash: false);
		}

		private void GameResume()
		{
			Vector3 zero = Vector3.zero;
			if (GameManager.instance.serveTurn == ServeTurn.other)
			{
				currentServeAnimInfo = serveInfoList[GameManager.instance.serveCount];
				destination = currentServeAnimInfo.AIServePos;
				zero = destination;
			}
			else
			{
				zero = base.transform.root.GetChild(GameManager.instance.serveCount).position;
				SetlookAtIK(isAdd: true);
			}
			if (Vector3.Distance(base.transform.position, zero) > 3f)
			{
				MoveStop = true;
				base.transform.position = zero;
			}
			else
			{
				MoveStop = false;
				destination = zero;
			}
			if (GameManager.instance.serveTurn == ServeTurn.other)
			{
				AIServe();
			}
		}

		private void Move()
		{
			if (MoveStop)
			{
				anim.SetBool("Move", value: false);
				isMoving = false;
				currentMoveTime = 0f;
			}
			else
			{
				if (destination == Vector3.zero)
				{
					return;
				}
				if (Vector3.Distance(base.transform.position, destination) < 0.025f)
				{
					anim.SetBool("Move", value: false);
					isMoving = false;
					currentMoveTime = 0f;
					return;
				}
				if (base.transform.position.z > -1.5f || Mathf.Abs(base.transform.position.x) > 6f || base.transform.position.z < -17f)
				{
					anim.SetBool("Move", value: false);
					isMoving = false;
					currentMoveTime = 0f;
					return;
				}
				isMoving = true;
				Vector3 rhs = destination - base.transform.position;
				float x = Vector3.Dot(base.transform.right, rhs);
				float y = Vector3.Dot(base.transform.forward, rhs);
				Vector2 b = new Vector2(x, y);
				float t = Mathf.Min(1f, Time.deltaTime / 0.15f);
				smoothDeltaPosition = Vector2.Lerp(smoothDeltaPosition, b, t);
				if (Time.deltaTime > 1E-05f)
				{
					velocity = smoothDeltaPosition / Time.deltaTime;
				}
				bool value = velocity.magnitude > 0.01f;
				anim.SetBool("Move", value);
				anim.SetFloat("veloX", velocity.x);
				anim.SetFloat("veloY", velocity.y);
				anim.SetFloat("velo", velocity.magnitude);
				currentMoveTime += Time.deltaTime;
				_ = currentMoveTime * (moveSpeed * 0.1f) / bestPointAndTime.time;
				Vector3 position = Vector3.MoveTowards(base.transform.position, destination, moveSpeed * Time.fixedDeltaTime);
				base.transform.position = position;
			}
		}

		public bool isOutBall(float targetDis, float totalTime, bool isSpecial, float waitTime, int rallyCount)
		{
			float[] array = new float[5];
			int num = 15 - SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			array[0] = 0f;
			array[1] = 60f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 4f - targetDis * 1000f;
			array[2] = totalTime * 40f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			array[3] = waitTime * 40f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			UnityEngine.Debug.Log("<color=green> point[1] : " + array[1] + "</color>");
			UnityEngine.Debug.Log("<color=green> point[2] : " + array[2] + "</color>");
			UnityEngine.Debug.Log("<color=green> point[3] : " + array[3] + "</color>");
			for (int i = 1; i < array.Length; i++)
			{
				array[0] += array[i];
			}
			if (isSpecial)
			{
				array[0] -= 40f;
			}
			array[0] -= rallyCount * num;
			array[0] -= BallBehaviour.instance.SpinForce.magnitude * 0.15f * (float)num;
			int num2 = UnityEngine.Random.Range(0, 150);
			UnityEngine.Debug.Log("<color=yellow> point : " + array[0] + " rand : " + num2 + "</color>");
			return array[0] <= (float)num2;
		}

		private void LoolAt()
		{
			if (GameManager.instance.isOtherServeBall)
			{
				Vector3 forward = PlayerBehaviour.instance.HeadTR.position - base.transform.position;
				forward.y = 0f;
				base.transform.rotation = Quaternion.LookRotation(forward);
				return;
			}
			Vector3 normalized = (BallBehaviour.instance.transform.position - base.transform.position).normalized;
			normalized.y = 0f;
			Vector3 forward2 = base.transform.forward;
			float num = Vector3.Dot(normalized, forward2);
			float num2 = Mathf.Cos((float)Math.PI / 6f);
			if (num < num2)
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.identity, Time.deltaTime * 3f);
				SetlookAtIK(isAdd: false);
			}
			else
			{
				SetlookAtIK(isAdd: true);
				Quaternion b = Quaternion.LookRotation(normalized);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, Time.deltaTime * 3f);
			}
		}

		private void SetlookAtIK(bool isAdd, float speed = 0.01f)
		{
			if (lookAtIKCoroutine != null)
			{
				StopCoroutine(lookAtIKCoroutine);
			}
			lookAtIKCoroutine = (isAdd ? StartCoroutine(IEnum_lookAtIkAddWeight(speed)) : StartCoroutine(IEnum_lookAtIkRevertWeight(speed)));
		}

		private IEnumerator IEnum_lookAtIkRevertWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight -= fadeSpeed;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					lookAtIK.solver.headWeight = 0f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}

		private IEnumerator IEnum_lookAtIkAddWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight += fadeSpeed;
				if ((double)lookAtIK.solver.headWeight >= 0.7)
				{
					lookAtIK.solver.headWeight = 0.7f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight >= 0.7f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}

		private void ReAction(int myScore, int otherScore, bool isfault, int winIndex)
		{
			if (!isfault)
			{
				MoveStop = true;
				StartCoroutine(IEnum_ReAction(winIndex));
			}
		}

		private IEnumerator IEnum_ReAction(int num)
		{
			if (UnityEngine.Random.Range(0, 10) >= 3)
			{
				while (animDelay < 1.2f)
				{
					yield return null;
				}
				SetlookAtIK(isAdd: false);
				int num2 = UnityEngine.Random.Range(1, 3);
				string text = ((num == 1) ? "win" : "lose");
				text += num2;
				int num3 = 1;
				int num4 = UnityEngine.Random.Range(2, 4);
				int setState = ((num == 1) ? num3 : num4);
				float setTime = UnityEngine.Random.Range(1f, 3f);
				EyeAnimationCtrl.GetInstance.SetExpression(setState, setTime);
				anim.SetTrigger(text);
			}
		}

		private void FixedUpdate()
		{
			Move();
			LoolAt();
			AnimTimeCheck();
		}
	}
	public class AISpawner : MonoBehaviour
	{
		public Transform CharacterTR;

		[HideInInspector]
		public GameObject CharacterGO;

		private void Awake()
		{
			base.enabled = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single;
		}

		private void Start()
		{
			SpawnCharacter();
		}

		private void SpawnCharacter()
		{
			CharacterGO = UnityEngine.Object.Instantiate(CharacterTR, base.transform).gameObject;
			CustomModelData modelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1];
			CharacterGO.GetComponent<CustomModelSettingCtrl>().Init(modelData);
		}
	}
	public class AITest : MonoBehaviour
	{
		public Transform followTarget;

		private Rigidbody rigid;

		public Vector3 velo;

		private void Start()
		{
			rigid = GetComponent<Rigidbody>();
		}

		private void FixedUpdate()
		{
			rigid.velocity = (followTarget.position - rigid.position) / Time.fixedDeltaTime;
			velo = rigid.velocity;
		}
	}
	public class getBestPoint
	{
		public Vector3 ballVelo;

		public Vector3 nearestPoint;

		public Vector3 bestPoint;

		public Vector3 vollryPoint;

		public Vector3 smashPoint;

		public float npTime;

		public float bpTime;

		public float vpTime;

		public float spTime;

		public bool isSafe;

		public getBestPoint()
		{
			nearestPoint = Vector3.zero;
			bestPoint = Vector3.zero;
			vollryPoint = Vector3.zero;
			npTime = 0f;
			bpTime = 0f;
			vpTime = 0f;
			spTime = 0f;
			isSafe = false;
		}
	}
	public class BallBehaviour : MonoBehaviour
	{
		public delegate void BallCollision(string colString);

		public static BallBehaviour instance;

		public Rigidbody rigid;

		public string colGroundTag;

		private SphereCollider thisCol;

		private MeshRenderer thisMesh;

		private AudioSource Audio;

		private TrailRenderer Trail;

		private bool isPlay;

		private int PhysicsMoveIndex;

		private Vector3 lastVelo = Vector3.zero;

		public ParticleSystem hitParticle;

		public ParticleSystem smashParticle;

		public ParticleSystem tableMaker;

		public Transform NetTR;

		private CustomFixedUpdate customFixedUpdate;

		public Transform spinDummy;

		private SpinParticle spinParticle;

		public Vector3 SpinForce;

		private Collider[] m_colliders = new Collider[2];

		public static event BallCollision BallCollisionEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			AIBehaviour.HitBallEvent += HitBall;
			Cfollower.HitBallEvent += HitBall;
			PlayerBehaviour.ResetBallEvent += ResetBall;
		}

		private void OnDisable()
		{
			AIBehaviour.HitBallEvent -= HitBall;
			Cfollower.HitBallEvent -= HitBall;
			PlayerBehaviour.ResetBallEvent -= ResetBall;
		}

		private void Start()
		{
			initData();
		}

		private void initData()
		{
			rigid = GetComponent<Rigidbody>();
			thisCol = GetComponent<SphereCollider>();
			Audio = GetComponent<AudioSource>();
			Trail = base.transform.Find("Trail").GetComponent<TrailRenderer>();
			thisMesh = GetComponent<MeshRenderer>();
			spinParticle = base.transform.Find("SpinRoot/Spin").GetComponent<SpinParticle>();
		}

		public void ResetBall(Vector3 pos)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				thisMesh.enabled = GameManager.instance.serveTurn == ServeTurn.my;
				thisCol.enabled = GameManager.instance.serveTurn == ServeTurn.my;
			}
			else
			{
				thisMesh.enabled = true;
				thisCol.enabled = true;
				if (GameManager.instance.serveTurn == ServeTurn.other)
				{
					return;
				}
			}
			base.transform.position = pos;
			rigid.velocity = Vector3.zero;
			rigid.angularVelocity = Vector3.zero;
			rigid.isKinematic = true;
		}

		public void ReceiveResetball(Vector3 pos)
		{
			base.transform.position = pos;
			rigid.velocity = Vector3.zero;
			rigid.angularVelocity = Vector3.zero;
			rigid.isKinematic = true;
		}

		private IEnumerator NetChecker(Transform netCheckerTR)
		{
			netCheckerTR.localScale = new Vector3(0.15f, 0.15f, 0.15f);
			yield return new WaitForSeconds(0.5f);
			netCheckerTR.localScale = Vector3.zero;
		}

		private IEnumerator NetChecker(float time)
		{
			yield return new WaitForSeconds(time);
			Transform NetCheckerTR = NetTR.transform.Find("NetChecker");
			Vector3 position = base.transform.position;
			position.x = 0f;
			NetCheckerTR.position = position;
			NetCheckerTR.localScale = new Vector3(0.15f, 0.15f, 0.15f);
			yield return new WaitForSeconds(0.1f);
			NetCheckerTR.localScale = Vector3.zero;
		}

		public void SetViewBall(bool onoff)
		{
			thisMesh.enabled = onoff;
		}

		public void SetColEnable(bool onoff)
		{
			thisCol.enabled = onoff;
		}

		public void SetAllStop()
		{
			rigid.isKinematic = false;
			isPlay = false;
			BallPhysics.instance.listBallInfo.Clear();
			spinParticle.StopParticle();
			PhysicsMoveIndex = 0;
			if (lastVelo != Vector3.zero)
			{
				rigid.velocity = lastVelo;
			}
			lastVelo = Vector3.zero;
			if (customFixedUpdate != null)
			{
				customFixedUpdate = null;
			}
		}

		private void FixedUpdate()
		{
			SetSpin();
			SetTrail();
			if (isPlay)
			{
				PhysMove();
			}
		}

		private void SetTrail()
		{
			Trail.enabled = lastVelo.magnitude > 6f || rigid.velocity.magnitude > 6f;
		}

		public Vector3 GetCurrentVelo()
		{
			return lastVelo;
		}

		public void SetPlay(Vector3 velo)
		{
			rigid.velocity = velo;
			rigid.isKinematic = false;
		}

		private void SetSpin()
		{
			Vector3 euler = new Vector3(-90f * rigid.velocity.x * 0.25f, 90f, 0f);
			spinDummy.rotation = Quaternion.Euler(euler);
		}

		public getBestPoint getBestPoint(Vector3 myPosition)
		{
			int num = 0;
			int num2 = 1;
			List<BallPhyscisInfo> listBallInfo = BallPhysics.instance.listBallInfo;
			List<BallPhyscisInfo> list = new List<BallPhyscisInfo>();
			List<BallPhyscisInfo> list2 = new List<BallPhyscisInfo>();
			getBestPoint getBestPoint2 = new getBestPoint();
			float num3 = myPosition.z / Mathf.Abs(myPosition.z);
			for (int i = 0; i < listBallInfo.Count; i++)
			{
				if (!(listBallInfo[i].position == Vector3.zero) && listBallInfo[i].position.z / Mathf.Abs(listBallInfo[i].position.z) == num3 && listBallInfo[i].bounceCount == num && listBallInfo[i].position.y > 0.9f)
				{
					list.Add(listBallInfo[i]);
				}
			}
			for (int j = 0; j < listBallInfo.Count; j++)
			{
				if (!(listBallInfo[j].position == Vector3.zero) && listBallInfo[j].position.z / Mathf.Abs(listBallInfo[j].position.z) == num3 && listBallInfo[j].bounceCount == num2 && Mathf.Abs(listBallInfo[j].position.z) < 17.5f && Mathf.Abs(listBallInfo[j].position.x) < 7f)
				{
					list2.Add(listBallInfo[j]);
				}
			}
			float num4 = 0f;
			float num5 = 100f;
			float num6 = 2.2f;
			Vector3 targetPos = Vector3.zero;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				targetPos = ((GameManager.instance.gameTurn == GameTurn.my) ? AIBehaviour.instance.transform.position : PlayerBehaviour.instance.transform.position);
				if (GameManager.instance.gameTurn != 0)
				{
					_ = PlayerBehaviour.instance.HeadTR.position;
				}
			}
			else
			{
				targetPos = myPosition;
				_ = PlayerBehaviour.instance.HeadTR.position;
			}
			getBestPoint2.isSafe = true;
			if (list.Count != 0)
			{
				float num7 = 100f;
				for (int k = 0; k < list.Count; k++)
				{
					num4 = Vector3.Distance(targetPos, list[k].position);
					if (num4 < num5)
					{
						num5 = num4;
						getBestPoint2.vollryPoint = list[k].position;
						getBestPoint2.vpTime = list[k].totalTime;
					}
					float num8 = ((list[k].position.y - num6 < 0f) ? (0f - (list[k].position.y - num6)) : (list[k].position.y - num6));
					if (num8 < num7)
					{
						getBestPoint2.smashPoint = list[k].position;
						getBestPoint2.spTime = list[k].totalTime;
						num7 = num8;
					}
				}
			}
			if (list2.Count != 0)
			{
				Vector3 firstPos = list2[0].position;
				list2 = (from x in list2
					orderby Vector3.Distance(x.position, firstPos) descending, x.position.y descending
					select x).ToList();
				int index = (int)Mathf.Ceil((float)list2.Count * 0.3f);
				try
				{
					getBestPoint2.bestPoint = list2[index].position;
					getBestPoint2.bpTime = list2[index].totalTime;
				}
				catch (ArgumentOutOfRangeException)
				{
					UnityEngine.Debug.LogError("ArgumentOutOfRangeException !!!!   " + list2.Count);
					getBestPoint2.bestPoint = list2[list2.Count - 1].position;
					getBestPoint2.bpTime = list2[list2.Count - 1].totalTime;
				}
				list2 = list2.OrderBy((BallPhyscisInfo x) => Vector3.Distance(targetPos, x.position)).ToList();
				int index2 = (int)Mathf.Ceil((float)list2.Count * 0.25f);
				try
				{
					getBestPoint2.nearestPoint = list2[index2].position;
					getBestPoint2.npTime = list2[index2].totalTime;
				}
				catch (ArgumentOutOfRangeException)
				{
					UnityEngine.Debug.LogError("ArgumentOutOfRangeException !!!!   " + list2.Count);
					getBestPoint2.nearestPoint = list2[list2.Count - 1].position;
					getBestPoint2.npTime = list2[list2.Count - 1].totalTime;
				}
			}
			if (list.Count == 0 && list2.Count == 0)
			{
				getBestPoint2.isSafe = false;
				try
				{
					getBestPoint2.bestPoint = listBallInfo[listBallInfo.Count - 1].position;
				}
				catch (ArgumentOutOfRangeException)
				{
					UnityEngine.Debug.LogError("ArgumentOutOfRangeException !!!!");
				}
				return getBestPoint2;
			}
			UnityEngine.Debug.DrawRay(getBestPoint2.nearestPoint, Vector3.up, Color.green, 3f);
			UnityEngine.Debug.DrawRay(getBestPoint2.bestPoint, Vector3.up, Color.yellow, 3f);
			UnityEngine.Debug.DrawRay(getBestPoint2.smashPoint, Vector3.up, Color.red, 3f);
			UnityEngine.Debug.DrawRay(getBestPoint2.vollryPoint, Vector3.up, Color.blue, 3f);
			UnityEngine.Debug.Log("gbp.bestPoint : " + getBestPoint2.bestPoint);
			UnityEngine.Debug.Log("gbp.nearestPoint : " + getBestPoint2.nearestPoint);
			UnityEngine.Debug.Log("gbp.vollryPoint : " + getBestPoint2.vollryPoint);
			UnityEngine.Debug.Log("gbp.smashPoint : " + getBestPoint2.smashPoint);
			return getBestPoint2;
		}

		private int getClosePointIndex(float _bestPoint, List<BallPhyscisInfo> ballInfo, int state)
		{
			int result = 0;
			float num = 100f;
			if (state == 0)
			{
				for (int i = 0; i < ballInfo.Count; i++)
				{
					float num2 = ((ballInfo[i].position.z - _bestPoint < 0f) ? (0f - (ballInfo[i].position.z - _bestPoint)) : (ballInfo[i].position.z - _bestPoint));
					if (num2 < num)
					{
						num = num2;
						result = i;
					}
				}
			}
			if (state == 1)
			{
				for (int j = 0; j < ballInfo.Count; j++)
				{
					float num3 = ((ballInfo[j].position.y - _bestPoint < 0f) ? (0f - (ballInfo[j].position.y - _bestPoint)) : (ballInfo[j].position.y - _bestPoint));
					if (num3 < num)
					{
						num = num3;
						result = j;
					}
				}
			}
			else
			{
				for (int k = 0; k < ballInfo.Count; k++)
				{
					float num4 = ((ballInfo[k].position.x - _bestPoint < 0f) ? (0f - (ballInfo[k].position.x - _bestPoint)) : (ballInfo[k].position.x - _bestPoint));
					if (num4 < num)
					{
						num = num4;
						result = k;
					}
				}
			}
			return result;
		}

		public void SetPlay(Vector3 velo, Vector3 spinForce, bool useAI = false)
		{
			rigid.isKinematic = false;
			rigid.velocity = Vector3.zero;
			rigid.Sleep();
			rigid.isKinematic = true;
			SpinForce = spinForce;
			isPlay = true;
			spinParticle.SetParticle(SpinForce.magnitude * 0.2f, SpinForce.x > 0f);
		}

		public void MultiBallSetPlay()
		{
			rigid.isKinematic = true;
			rigid.velocity = Vector3.zero;
			rigid.Sleep();
			rigid.constraints = RigidbodyConstraints.None;
			SetCustomFixedUpdate();
		}

		private void SetCustomFixedUpdate()
		{
			float num = (float)PhotonNetwork.GetPing() * 0.001f;
			float aTimeStep = Time.fixedDeltaTime + num * Time.fixedDeltaTime;
			customFixedUpdate = new CustomFixedUpdate(aTimeStep, OnFixedUpdate);
		}

		private void Update()
		{
			if (customFixedUpdate != null)
			{
				customFixedUpdate.Update();
			}
		}

		private void OnFixedUpdate(float dt)
		{
			List<BallPhyscisInfo> listBallInfo = BallPhysics.instance.listBallInfo;
			if (PhysicsMoveIndex >= listBallInfo.Count)
			{
				SetAllStop();
				return;
			}
			rigid.MovePosition(listBallInfo[PhysicsMoveIndex].position);
			if (listBallInfo[PhysicsMoveIndex].isCol)
			{
				OnCollider(listBallInfo[PhysicsMoveIndex].collider, listBallInfo[PhysicsMoveIndex].position);
			}
			if (PhysicsMoveIndex > 2)
			{
				lastVelo = listBallInfo[PhysicsMoveIndex].velocity;
			}
			PhysicsMoveIndex++;
		}

		public void PhysMove()
		{
			List<BallPhyscisInfo> listBallInfo = BallPhysics.instance.listBallInfo;
			if (PhysicsMoveIndex >= listBallInfo.Count)
			{
				SetAllStop();
				return;
			}
			rigid.MovePosition(listBallInfo[PhysicsMoveIndex].position);
			if (listBallInfo[PhysicsMoveIndex].isCol)
			{
				OnCollider(listBallInfo[PhysicsMoveIndex].collider, listBallInfo[PhysicsMoveIndex].position);
			}
			if (PhysicsMoveIndex > 2)
			{
				lastVelo = listBallInfo[PhysicsMoveIndex].velocity;
			}
			PhysicsMoveIndex++;
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.layer == 9 || collision.gameObject.layer == 11)
			{
				collision.transform.name.Equals("wall");
				BallBehaviour.BallCollisionEvent(collision.transform.name);
				if (collision.collider.name.Equals("0") || collision.collider.name.Equals("1"))
				{
					PlaySound("hitPlane");
				}
				if (!GameManager.instance.isOnPanjung && (collision.collider.name.Equals("0") || collision.collider.name.Equals("1")))
				{
					SetTableMarker(collision.contacts[0].point);
				}
				if (collision.collider.name.Equals("Net"))
				{
					UnityEngine.Debug.Log("<color=red>  Net Hit!!!!!!!!!!!!!! </color>");
					NetHelper(collision.contacts[0].point);
				}
			}
		}

		private void OnCollider(Collider collider, Vector3 cPoint)
		{
			if (collider.gameObject.layer == 9 || collider.gameObject.layer == 11)
			{
				collider.name.Equals("wall");
				BallBehaviour.BallCollisionEvent(collider.name);
				if (!GameManager.instance.isOnPanjung && (collider.name.Equals("0") || collider.name.Equals("1")))
				{
					SetTableMarker(cPoint);
				}
				if (collider.name.Equals("0") || collider.name.Equals("1"))
				{
					PlaySound("hitPlane");
				}
				if (collider.name.Equals("Net"))
				{
					UnityEngine.Debug.Log("<color=red>  Net Hit!!!!!!!!!!!!!! </color>");
					ColNetHelper(cPoint);
				}
			}
		}

		private void SetTableMarker(Vector3 point)
		{
			point.y = 0.01f;
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(tableMaker, point, Quaternion.identity).gameObject, hitParticle.main.duration);
		}

		private void ColNetHelper(Vector3 cPoint)
		{
			Transform transform = NetTR.Find("NetChecker");
			cPoint.z = 0f;
			transform.position = cPoint;
			StartCoroutine(NetChecker(transform));
		}

		private void NetHelper(Vector3 cPoint)
		{
			rigid.velocity *= 0.4f;
			Transform transform = NetTR.Find("NetChecker");
			cPoint.z = 0f;
			transform.position = cPoint;
			StartCoroutine(NetChecker(transform));
		}

		private string GetGroundName()
		{
			Ray ray = new Ray(rigid.position, Vector3.down);
			int layerMask = 1 << LayerMask.NameToLayer("Default");
			float maxDistance = thisCol.radius * base.transform.lossyScale.y;
			if (Physics.Raycast(ray, out var hitInfo, maxDistance, layerMask))
			{
				return hitInfo.transform.name;
			}
			return null;
		}

		private void HitBall(bool isServe, bool isSmash)
		{
			string clipName = (isSmash ? "smash" : "hitRacket");
			PlaySound(clipName);
		}

		public void HitBallSound(bool isSmash)
		{
			string clipName = (isSmash ? "smash" : "hitRacket");
			PlaySound(clipName);
		}

		private void HitBall(bool isSmash, Vector3 cPoint)
		{
			HitBall(isServe: false, isSmash);
		}

		private void PlaySound(string clipName)
		{
			AudioClip soundClip = SoundManager.instance.GetSoundClip(clipName);
			Audio.PlayOneShot(soundClip);
		}

		public void SetParticle(Vector3 point)
		{
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(hitParticle, point, Quaternion.identity).gameObject, hitParticle.main.duration);
		}

		public void SetSmashParticle(bool isUse)
		{
			if (isUse)
			{
				smashParticle.Play();
				return;
			}
			smashParticle.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
			smashParticle.Clear(withChildren: true);
		}

		public void SetTrigger(bool useTrigger)
		{
			thisCol.isTrigger = useTrigger;
		}

		private void LateUpdate()
		{
			if (rigid.isKinematic)
			{
				return;
			}
			float radius = base.transform.localScale.x * thisCol.radius;
			int num = Physics.OverlapSphereNonAlloc(base.transform.position, radius, m_colliders, 512, QueryTriggerInteraction.UseGlobal);
			for (int i = 0; i < num; i++)
			{
				if (num < 2)
				{
					return;
				}
				if (Physics.ComputePenetration(thisCol, base.transform.position, base.transform.rotation, m_colliders[i], m_colliders[i].transform.position, m_colliders[i].transform.rotation, out var direction, out var distance))
				{
					UnityEngine.Debug.Log("OnCollisionEnter with " + m_colliders[i].gameObject.name + "  " + num + " " + distance);
					UnityEngine.Debug.DrawRay(base.transform.position, direction, Color.red, 3f);
					Vector3 velocity = Vector3.Reflect(rigid.velocity, m_colliders[i].transform.up);
					velocity.y *= 0.85f;
					rigid.velocity = velocity;
				}
			}
			for (int j = 0; j < m_colliders.Length; j++)
			{
				m_colliders[j] = null;
			}
		}
	}
	[Serializable]
	public class BallPhyscisInfo
	{
		public Vector3 spinForce;

		public Vector3 velocity;

		public Vector3 position;

		public float totalTime;

		public int bounceCount;

		public bool isCol;

		public Collider collider;

		public BallPhyscisInfo()
		{
			spinForce = Vector3.zero;
			velocity = Vector3.zero;
			position = Vector3.zero;
			totalTime = 0f;
			bounceCount = 0;
			isCol = false;
			collider = null;
		}
	}
	public class BallPhysics : MonoBehaviour
	{
		public List<BallPhyscisInfo> listBallInfo = new List<BallPhyscisInfo>();

		public Collider[] cols;

		public Collider[] FaultZoneCols;

		public float radiusScaler;

		public bool isDebugDraw;

		public float reduceAngularVelocityValue;

		private float radius;

		public float ReviseValue;

		public bool isCloseOut;

		public int reviseCount;

		private Vector3 firstVelo = Vector3.zero;

		public static BallPhysics instance { get; set; }

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			Time.fixedDeltaTime = 0.01f;
			Physics.defaultContactOffset = 0.001f;
			Physics.bounceThreshold = 2f;
		}

		private void Start()
		{
			radius = radiusScaler * BallBehaviour.instance.transform.localScale.x;
		}

		public void SetPreview(Vector3 velocity, Vector3 spinforce, Vector3 startPos, Vector3 angularVelo, bool useAI = false, bool isMine = true)
		{
			if (isMine && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single && !GameManager.instance.isMyServeBall)
			{
				velocity = ReviseVelo(velocity, GameObject.Find("Me").transform);
			}
			if (float.IsNaN(velocity.x))
			{
				velocity.x = 0f;
			}
			if (float.IsNaN(velocity.y))
			{
				velocity.y = 0f;
			}
			if (float.IsNaN(velocity.z))
			{
				velocity.z = 0f;
			}
			if (float.IsNaN(spinforce.x) || float.IsNaN(spinforce.y) || float.IsNaN(spinforce.z))
			{
				UnityEngine.Debug.Log("spinforce NaN!!!!!!!!!!!!!!!!!!!");
				spinforce = Vector3.zero;
			}
			if (float.IsNaN(angularVelo.x) || float.IsNaN(angularVelo.y) || float.IsNaN(angularVelo.z))
			{
				UnityEngine.Debug.Log("angularVelo NaN!!!!!!!!!!!!!!!!!!!");
				angularVelo = Vector3.zero;
			}
			float num = 0f;
			bool flag = true;
			Vector3 vector = startPos;
			float fixedDeltaTime = Time.fixedDeltaTime;
			Vector3 vector2 = Physics.gravity * fixedDeltaTime * fixedDeltaTime;
			float num2 = 1f - fixedDeltaTime * BallBehaviour.instance.rigid.drag;
			Vector3 vector3 = spinforce * fixedDeltaTime * fixedDeltaTime;
			Vector3 vector4 = velocity * fixedDeltaTime;
			Vector3 angular = angularVelo;
			int num3 = 0;
			List<Vector3> list = new List<Vector3>();
			listBallInfo.Clear();
			Vector3 vector5 = velocity;
			while (flag)
			{
				num += Time.fixedDeltaTime;
				vector4 += vector3;
				vector4 += vector2;
				vector4 *= num2;
				vector += vector4;
				list.Add(vector);
				if (list.Count < 2)
				{
					continue;
				}
				BallPhyscisInfo ballPhyscisInfo = new BallPhyscisInfo();
				Vector3 vector6 = list[list.Count - 2];
				Vector3 vector7 = list[list.Count - 1] - vector6;
				int layerMask = 512;
				if (isDebugDraw)
				{
					UnityEngine.Debug.DrawRay(vector6, vector7, Color.cyan, 5f);
				}
				bool flag2 = GameManager.instance.isMyServeBall || GameManager.instance.isOtherServeBall;
				if (Physics.SphereCast(vector6, radius, vector7, out var hitInfo, vector7.magnitude, layerMask))
				{
					Vector3 vector8 = Vector3.Reflect(vector5, hitInfo.normal);
					vector8.y *= 0.85f;
					vector4 = vector8 * fixedDeltaTime;
					vector4.x += angular.z * reduceAngularVelocityValue * fixedDeltaTime;
					vector4.z += angular.x * reduceAngularVelocityValue * fixedDeltaTime;
					angular = GetAngularVelocity(angular, vector7, Vector3.up);
					num3++;
					if (num3 == 1)
					{
						Collider collider = hitInfo.collider;
						isCloseOut = false;
						if (collider == cols[3] && !flag2)
						{
							for (int i = 0; i < 2; i++)
							{
								float num4 = Vector3.Distance(hitInfo.point, cols[i].bounds.ClosestPoint(hitInfo.point));
								if (num4 < 2f)
								{
									isCloseOut = true;
								}
								UnityEngine.Debug.Log("아깝게 나갔는지 체크 : " + num4 + " " + isCloseOut.ToString());
							}
						}
					}
					if (hitInfo.collider == cols[2])
					{
						if (vector5.magnitude > 2f)
						{
							vector4 *= 0.1f;
						}
						Vector3 vector9 = vector4 / fixedDeltaTime;
						UnityEngine.Debug.Log("NetHit SetPreview : " + vector9);
					}
					if (hitInfo.collider.name.Equals("wall"))
					{
						vector4 *= 0.1f;
					}
					if (flag2 && num3 == 1)
					{
						Collider collider2 = ((GameManager.instance.serveCount == 0) ? FaultZoneCols[0] : FaultZoneCols[1]);
						float num5 = Vector3.Distance(hitInfo.point, collider2.bounds.ClosestPoint(hitInfo.point));
						GameManager.instance.isFault = num5 > 0.05f;
					}
					ballPhyscisInfo.isCol = true;
					ballPhyscisInfo.collider = hitInfo.collider;
					if (hitInfo.collider == cols[2])
					{
						break;
					}
				}
				vector5 = ((listBallInfo.Count == 0) ? velocity : (vector4 / fixedDeltaTime));
				ballPhyscisInfo.bounceCount = num3;
				ballPhyscisInfo.position = vector;
				ballPhyscisInfo.totalTime = num;
				ballPhyscisInfo.velocity = vector5;
				ballPhyscisInfo.spinForce = spinforce;
				listBallInfo.Add(ballPhyscisInfo);
				if (num3 > 1 || list.Count > 300)
				{
					break;
				}
			}
			BallBehaviour.instance.SetPlay(velocity, spinforce, useAI);
		}

		private Vector3 GetAngularVelocity(Vector3 angular, Vector3 ballDir, Vector3 ballUpDir)
		{
			Vector3 vector = Vector3.Cross(ballUpDir, ballDir) * 1.49f;
			angular -= angular * 0.01f;
			return angular + vector;
		}

		public void PhysicsSimulator(Vector3 velocity, Vector3 startPos, Vector3 spinforce, Vector3 angularVelo, bool isSmash, bool useAI = false)
		{
			if (reviseCount == 0)
			{
				firstVelo = velocity;
			}
			float num = 0f;
			bool flag = true;
			Vector3 item = startPos;
			float fixedDeltaTime = Time.fixedDeltaTime;
			Vector3 vector = Physics.gravity * fixedDeltaTime * fixedDeltaTime;
			float num2 = 1f - fixedDeltaTime * BallBehaviour.instance.rigid.drag;
			Vector3 vector2 = spinforce * fixedDeltaTime * fixedDeltaTime;
			Vector3 vector3 = velocity * fixedDeltaTime;
			Vector3 angular = angularVelo;
			int num3 = 0;
			bool flag2 = false;
			bool flag3 = false;
			bool isMyServeBall = GameManager.instance.isMyServeBall;
			Vector3 inDirection = velocity;
			List<Vector3> list = new List<Vector3>();
			Vector3 vector4 = Vector3.zero;
			Collider collider = null;
			reviseCount++;
			while (flag)
			{
				num += Time.fixedDeltaTime;
				vector3 += vector2;
				vector3 += vector;
				vector3 *= num2;
				item += vector3;
				list.Add(item);
				if (list.Count < 2)
				{
					continue;
				}
				Vector3 vector5 = list[list.Count - 2];
				Vector3 vector6 = list[list.Count - 1] - vector5;
				int layerMask = 512;
				if (isDebugDraw && reviseCount <= 15)
				{
					switch (reviseCount % 5)
					{
					case 0:
						UnityEngine.Debug.DrawRay(vector5, vector6, Color.gray, 3f);
						break;
					case 1:
						UnityEngine.Debug.DrawRay(vector5, vector6, Color.red, 3f);
						break;
					case 2:
						UnityEngine.Debug.DrawRay(vector5, vector6, Color.yellow, 3f);
						break;
					case 3:
						UnityEngine.Debug.DrawRay(vector5, vector6, Color.green, 3f);
						break;
					case 4:
						UnityEngine.Debug.DrawRay(vector5, vector6, Color.blue, 3f);
						break;
					case 5:
						UnityEngine.Debug.DrawRay(vector5, vector6, Color.white, 3f);
						break;
					}
				}
				if (Physics.SphereCast(vector5, radius, vector6, out var hitInfo, vector6.magnitude, layerMask))
				{
					Vector3 vector7 = Vector3.Reflect(inDirection, hitInfo.normal);
					vector7.y *= 0.85f;
					vector3 = vector7 * fixedDeltaTime;
					vector3.x += angular.z * reduceAngularVelocityValue * fixedDeltaTime;
					vector3.z += angular.x * reduceAngularVelocityValue * fixedDeltaTime;
					angular = GetAngularVelocity(angular, vector6, Vector3.up);
					num3++;
					if (num3 == 1)
					{
						vector4 = hitInfo.point;
						collider = hitInfo.collider;
					}
					if (!useAI)
					{
						if (collider == cols[1])
						{
							if (isMyServeBall)
							{
								Collider collider2 = ((GameManager.instance.serveCount == 0) ? FaultZoneCols[0] : FaultZoneCols[1]);
								flag2 = Vector3.Distance(hitInfo.point, collider2.bounds.ClosestPoint(hitInfo.point)) > 0.05f;
								if (flag2)
								{
									break;
								}
								continue;
							}
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("보정 필요 없음");
							}
							SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
							reviseCount = 0;
							return;
						}
						if (isDebugDraw)
						{
							UnityEngine.Debug.Log("밖으로 나가는 공 : " + hitInfo.collider.name);
						}
						if (isMyServeBall)
						{
							flag2 = true;
						}
						else
						{
							flag3 = true;
						}
						break;
					}
					if (!(collider == cols[0]))
					{
						if (isDebugDraw)
						{
							UnityEngine.Debug.Log("AI 밖으로 나가는 공 : " + hitInfo.collider.name);
						}
						if (isMyServeBall)
						{
							flag2 = true;
						}
						else
						{
							flag3 = true;
						}
						break;
					}
					if (!isSmash)
					{
						SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
						reviseCount = 0;
						return;
					}
					flag3 = true;
				}
				inDirection = vector3 / fixedDeltaTime;
				if (list.Count > 500)
				{
					break;
				}
			}
			if (isSmash)
			{
				UnityEngine.Debug.Log("스매시 쳤따");
				flag3 = true;
			}
			if (flag2 && isMyServeBall)
			{
				if (collider == cols[1])
				{
					if (Mathf.Abs(vector4.z) > 6.3f)
					{
						velocity = getReviseAxisX(velocity, 3f, startPos);
					}
					if (GameManager.instance.serveCount == 0)
					{
						if (vector4.x > 0f && vector4.x < 3.8f)
						{
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("보정 필요없음");
							}
						}
						else
						{
							velocity = ServeReviseVelo(velocity, GameObject.Find("Me").transform, FaultZoneCols[0].transform);
						}
					}
					else if (GameManager.instance.serveCount == 1)
					{
						if (vector4.x > -3.9f && vector4.x < 0f)
						{
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("보정 필요없음");
							}
						}
						else
						{
							velocity = ServeReviseVelo(velocity, GameObject.Find("Me").transform, FaultZoneCols[1].transform);
						}
					}
				}
				else if (collider.name == "2" && vector4.x > 3.8f)
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("서브 오른쪽으로 나가는 공");
					}
					velocity = getReviseAxisY(velocity, -5f, startPos);
				}
				else if (collider.name == "2" && vector4.x < -3.9f)
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("서브 왼쪽으로 나가는 공");
					}
					velocity = getReviseAxisY(velocity, 5f, startPos);
				}
				else if (collider == cols[0] || collider == cols[2])
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("네트 보정 시작");
					}
					float value = Mathf.Abs(startPos.z / velocity.z);
					value = Mathf.Clamp(value, 0.48f, 0.8f);
					float num4 = 0f;
					int index = 0;
					float num5 = 0f;
					float num6 = 100f;
					for (int i = 0; i < list.Count; i++)
					{
						num5 = ((list[i].z - num4 < 0f) ? (0f - (list[i].z - num4)) : (list[i].z - num4));
						if (num5 < num6)
						{
							num6 = num5;
							index = i;
						}
					}
					float value2 = list[index].y * 1.5f;
					value2 = Mathf.Clamp(value2, 0.9f, 1.2f);
					velocity = getVelocityAtoBSpin(B: new Vector3(list[index].x, value2, 0f), A: startPos, t: value, spin: spinforce);
				}
				if (reviseCount > 3)
				{
					reviseCount = 0;
					SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("보정 끝");
					}
				}
				else
				{
					PhysicsSimulator(velocity, startPos, spinforce, angularVelo, isSmash, useAI);
				}
			}
			else if (!flag2 && isMyServeBall)
			{
				reviseCount = 0;
				SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
			}
			else if (flag3 && !isMyServeBall)
			{
				float num7 = Mathf.Abs(startPos.x / velocity.z);
				if (isSmash)
				{
					float value3 = num7 * 0.4f;
					value3 = Mathf.Clamp(value3, 0.25f, 0.4f);
					float num8 = 0.8f * (velocity.z / Mathf.Abs(velocity.z));
					int index2 = 0;
					float num9 = 0f;
					float num10 = 100f;
					for (int j = 0; j < list.Count; j++)
					{
						num9 = ((list[j].z - num8 < 0f) ? (0f - (list[j].z - num8)) : (list[j].z - num8));
						if (num9 < num10)
						{
							num10 = num9;
							index2 = j;
						}
					}
					float y = list[index2].y;
					y = Mathf.Clamp(y, 1.3f, 1.4f);
					velocity = getVelocityAtoBSpin(B: new Vector3(list[index2].x * 0.7f, y, 0f), A: startPos, t: value3, spin: spinforce);
					if (velocity.magnitude < 28f)
					{
						velocity = velocity.normalized * 28f;
					}
					else if (velocity.magnitude > 32f)
					{
						velocity = velocity.normalized * 32f;
					}
					UnityEngine.Debug.Log(string.Concat("smash  : ", velocity, " ", velocity.magnitude));
					SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
					reviseCount = 0;
					return;
				}
				UnityEngine.Debug.Log(string.Concat("hitPos : ", vector4, " hitCol : ", collider));
				if (collider == cols[0] || collider == cols[2])
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("네트 보정 시작");
					}
					velocity *= 0.8f;
					float num11 = Mathf.Abs(startPos.z / velocity.z);
					if (num11 > 0.9f)
					{
						num11 = 0.9f;
					}
					float num12 = 0f;
					int index3 = 0;
					float num13 = 0f;
					float num14 = 100f;
					float num15 = 0f;
					for (int k = 0; k < list.Count; k++)
					{
						num13 = ((list[k].z - num12 < 0f) ? (0f - (list[k].z - num12)) : (list[k].z - num12));
						if (num13 < num14)
						{
							num14 = num13;
							index3 = k;
						}
						if (list[k].y > num15)
						{
							num15 = list[k].y;
						}
					}
					if (velocity.magnitude > 8f)
					{
						Vector3 zero = Vector3.zero;
						float num16 = num15 * 0.5f;
						if (num16 < 0.9f)
						{
							num16 = 0.9f;
						}
						velocity = getVelocityAtoBSpin(B: new Vector3(list[index3].x, num16, 0f), A: startPos, t: num11, spin: spinforce);
						UnityEngine.Debug.Log("네트보정 y 높이 : " + num16 + "   " + velocity.magnitude + "  " + num11 + " " + velocity);
					}
					else
					{
						velocity = velocity.normalized * 8f;
					}
					SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
					reviseCount = 0;
					return;
				}
				if (Mathf.Abs(vector4.x) > 3.9f)
				{
					UnityEngine.Debug.Log("좌우 보정!");
					if (vector4.x > 3.9f)
					{
						UnityEngine.Debug.Log("왼쪽으로 빠지는 공 보정");
						velocity = getReviseAxisY(velocity, -10f, startPos);
					}
					else if (vector4.x < -3.8f)
					{
						UnityEngine.Debug.Log("오른쪽으로 빠지는 공 보정");
						velocity = getReviseAxisY(velocity, 10f, startPos);
					}
				}
				else if (Mathf.Abs(vector4.z) > 11.5f)
				{
					UnityEngine.Debug.Log("코트 밖으로 나가는 공 보정");
					velocity = getReviseAxisX(velocity, -10f, startPos);
				}
				else if (collider == cols[1])
				{
					UnityEngine.Debug.Log("보정 OK");
					reviseCount = 0;
					SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
					return;
				}
				if (reviseCount > 10)
				{
					reviseCount = 0;
					SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
				}
				else
				{
					PhysicsSimulator(velocity, startPos, spinforce, angularVelo, isSmash, useAI);
				}
			}
			else if (!flag3 && !isMyServeBall)
			{
				reviseCount = 0;
				SetPreview(velocity, spinforce, startPos, angularVelo, useAI);
			}
		}

		public static Vector3 getVelocityAtoBSpin(Vector3 A, Vector3 B, float t, Vector3 spin)
		{
			Vector3 vector = A;
			Vector3 vector2 = B;
			float num = 0.3f;
			float num2 = vector2.x - vector.x;
			float num3 = vector2.z - vector.z;
			float x = num2 / t;
			_ = num3 / t;
			float z = vector.z;
			float z2 = (vector2.z - z + spin.z * Mathf.Pow(t, 2f) / 2f) / t;
			float num4 = 9.81f - spin.y;
			float y = vector.y;
			float y2 = (vector2.y - y + num4 * Mathf.Pow(t, 2f) / 2f) / t;
			return new Vector3(x, y2, z2) * (1f + num * (t * (1.1f + Mathf.Pow(num, 2f))));
		}

		public Vector3 getReviseAxisY(Vector3 velo, float scaler, Vector3 startPos)
		{
			Vector3 normalized = ((velo - startPos).z * Vector3.forward).normalized;
			Vector3 normalized2 = velo.normalized;
			normalized2.y = 0f;
			Vector3 result = Quaternion.AngleAxis(scaler * Vector3.Cross(normalized, Vector3.up).normalized.x * -1f, Vector3.up) * normalized2 * velo.magnitude;
			result.y = velo.y;
			if (float.IsNaN(result.x) || float.IsNaN(result.y) || float.IsNaN(result.z))
			{
				result = velo;
			}
			return result;
		}

		public Vector3 getReviseAxisX(Vector3 velo, float scaler, Vector3 startPos)
		{
			Vector3 normalized = ((velo - startPos).z * Vector3.forward).normalized;
			Vector3 normalized2 = velo.normalized;
			normalized2.x = 0f;
			Vector3 normalized3 = Vector3.Cross(normalized, Vector3.up).normalized;
			Vector3 result = Quaternion.AngleAxis(scaler, normalized3) * normalized2 * velo.magnitude;
			result.x = velo.x;
			if (float.IsNaN(result.x) || float.IsNaN(result.y) || float.IsNaN(result.z))
			{
				result = velo;
			}
			return result;
		}

		public Vector3 ReviseVelo(Vector3 velo, Transform tr)
		{
			Vector3 forward = tr.forward;
			Vector3 normalized = velo.normalized;
			normalized.y = 0f;
			float num = Vector3.Angle(forward, normalized);
			if (num == 0f)
			{
				return velo;
			}
			num *= ReviseValue;
			float num2 = Vector3.Dot(tr.right, normalized);
			num2 /= Mathf.Abs(num2) * -1f;
			num *= num2;
			Vector3 result = Quaternion.AngleAxis(num, tr.up) * normalized * velo.magnitude;
			result.y = velo.y;
			return result;
		}

		public Vector3 ServeReviseVelo(Vector3 velo, Transform tr, Transform serveTargetTR)
		{
			Vector3 normalized = (serveTargetTR.position - tr.position).normalized;
			normalized.y = 0f;
			Vector3 normalized2 = velo.normalized;
			normalized2.y = 0f;
			float num = Vector3.Angle(normalized, normalized2);
			if (num == 0f)
			{
				return velo;
			}
			num *= 0.25f;
			float num2 = Vector3.Dot(tr.right, normalized);
			num2 /= Mathf.Abs(num2) * 1f;
			UnityEngine.Debug.Log(num2);
			num *= num2;
			Vector3 vector = Quaternion.AngleAxis(num, tr.up) * normalized2 * velo.magnitude;
			vector.y = velo.y;
			UnityEngine.Debug.Log(vector);
			UnityEngine.Debug.DrawRay(tr.position, normalized * 10f, Color.white, 30f);
			UnityEngine.Debug.DrawRay(tr.position, vector * 10f, Color.red, 30f);
			UnityEngine.Debug.DrawRay(tr.position, velo * 10f, Color.blue, 30f);
			return vector;
		}
	}
	public class Cfollower : MonoBehaviour
	{
		public delegate void HitBall(bool isSmash, Vector3 cPoint);

		private Cplane plane;

		private Rigidbody tRig;

		private Vector3 swingVelo;

		public bool isTest;

		private bool isHit;

		private InputDeviceState inputDeviceState;

		public InputDeviceState[] inputDeviceStates;

		public List<Vector3> ListVelo = new List<Vector3>();

		public List<Vector3> ListAngularVelo = new List<Vector3>();

		public TextMesh debugText;

		public AITest at;

		public float swingPowerScaler;

		public float boundPowerScaler;

		public float racketPlatPowerScaler;

		public float calculPowerScaler;

		public Vector3 TestServeVelo;

		public Vector3 TestVelo;

		public static event HitBall HitBallEvent;

		private void Start()
		{
			plane = base.transform.GetComponentInChildren<Cplane>();
		}

		private void OnEnable()
		{
			PlayerBehaviour.ChangeHandEvent += PlayerBehaviour_ChangeHandEvent;
			if (isTest)
			{
				PlayerBehaviour.testEvent += Test;
			}
		}

		private void OnDisable()
		{
			PlayerBehaviour.ChangeHandEvent -= PlayerBehaviour_ChangeHandEvent;
			PlayerBehaviour.testEvent -= Test;
		}

		private void PlayerBehaviour_ChangeHandEvent(bool isRight)
		{
			inputDeviceState = (isRight ? inputDeviceStates[1] : inputDeviceStates[0]);
		}

		public void ColliderEvent(Collision collision, Vector3 center)
		{
			if (!isHit)
			{
				UnityEngine.Debug.Log("Player hit!!!");
				isHit = true;
				Vector3 currentVelo = BallBehaviour.instance.GetCurrentVelo();
				Vector3 point = collision.contacts[0].point;
				float magnitude = new Vector3(ListVelo.Average((Vector3 a) => a.x), ListVelo.Average((Vector3 a) => a.y), ListVelo.Average((Vector3 a) => a.z)).magnitude;
				Vector3 vector = plane.getPointVellocity(point).normalized * magnitude;
				vector *= swingPowerScaler;
				Vector3 cDir = point - center;
				Vector3[] inversPoss = plane.GetInversPoss(cDir);
				Vector3 lhs = inversPoss[1] - inversPoss[0];
				Vector3 rhs = inversPoss[inversPoss.Length - 1] - inversPoss[0];
				Vector3 vector2 = Vector3.Cross(lhs, rhs);
				Vector3 normalized = ((Vector3.Dot(cDir.normalized, vector2) < 0f) ? (vector2 * -1f) : vector2).normalized;
				Vector3 vector3 = Vector3.Reflect(currentVelo, base.transform.forward);
				vector3 *= boundPowerScaler;
				float num = Vector3.Dot(vector, normalized);
				normalized *= num;
				Vector3 vector4 = Vector3.ProjectOnPlane(vector, normalized);
				normalized *= racketPlatPowerScaler;
				Vector3 vector5 = (normalized + vector3 + vector) * calculPowerScaler;
				Vector3 dir = Vector3.Cross(vector4, vector);
				Vector3 vector6 = new Vector3(dir.y, dir.x, dir.z) * 0.08f;
				if (base.transform.position.z < 0f)
				{
					vector6.y *= -1f;
				}
				vector6.x *= -1f;
				vector6.x = Mathf.Clamp(vector6.x, -2f, 2f);
				vector6.y = Mathf.Clamp(vector6.y, -3f, 3f);
				vector6.z = Mathf.Clamp(vector6.z, -3.5f, 3.5f);
				UnityEngine.Debug.DrawRay(point, normalized, Color.cyan, 20f);
				UnityEngine.Debug.DrawRay(point, vector, Color.yellow, 20f);
				UnityEngine.Debug.DrawRay(point, vector4, Color.red, 20f);
				UnityEngine.Debug.DrawRay(point, dir, Color.blue, 20f);
				debugText.text = string.Concat("calculPower : ", vector5, " ", vector5.magnitude, "\nswingPower : ", vector, " ", vector.magnitude, "\nspinForce : ", vector6, " ", vector6.magnitude, "\nboundPower : ", vector3, " ", vector3.magnitude, "\nswingVeloDot : ", num);
				float num2 = PlayerBehaviour.instance.HeadTR.position.y + 0.1f;
				bool flag = BallBehaviour.instance.transform.position.y > num2 && vector.magnitude > 9f && !GameManager.instance.isMyServeBall;
				if (BallBehaviour.instance.transform.position.y < 1.5f)
				{
					flag = false;
				}
				if (vector5.magnitude > 25f)
				{
					vector5 = vector5.normalized * 25f;
				}
				if (vector5.y > 10f)
				{
					vector5.y = 10f;
				}
				BallBehaviour.instance.SetSmashParticle(flag);
				Invoke("InvokeHit", 0.5f);
				if (!GameManager.instance.isOnPanjung)
				{
					BallBehaviour.instance.SetAllStop();
					BallPhysics.instance.PhysicsSimulator(vector5, point, vector6, vector6, flag);
					Cfollower.HitBallEvent?.Invoke(flag, point);
					inputDeviceState.HapticPulse();
				}
			}
		}

		private bool IsHitFront(Vector3 velo)
		{
			float num = velo.z / PlayerBehaviour.instance.HeadTR.forward.z;
			Transform headTR = PlayerBehaviour.instance.HeadTR;
			Vector3 forward = headTR.forward;
			Vector3 normalized = (BallBehaviour.instance.transform.position - headTR.position).normalized;
			float num2 = Vector3.Dot(forward, normalized);
			if (num < 0f)
			{
				return false;
			}
			if (Mathf.Abs(velo.z) < Mathf.Abs(velo.x))
			{
				return false;
			}
			if (velo.magnitude < 2f)
			{
				return false;
			}
			if (num2 < 0.7f)
			{
				return false;
			}
			return true;
		}

		private float getSwingAnglePower(Vector3 swingPower, Vector3 racketDir)
		{
			float f = Vector3.Dot(swingPower.normalized, racketDir);
			f = Mathf.Abs(f);
			return 0.4f + f * 0.6f;
		}

		public void InvokeHit()
		{
			isHit = false;
		}

		public void Test()
		{
			Vector3 testVelo = TestVelo;
			if (PlayerBehaviour.instance.transform.position.z > 0f)
			{
				testVelo = TestVelo;
			}
			else
			{
				testVelo = TestVelo;
				testVelo.z *= -1f;
			}
			testVelo.x = UnityEngine.Random.Range(-3f, 3f);
			if (!GameManager.instance.isOnPanjung)
			{
				BallBehaviour.instance.SetAllStop();
				BallPhysics.instance.PhysicsSimulator(testVelo, BallBehaviour.instance.transform.position, Vector3.zero, Vector3.zero, isSmash: false);
				Cfollower.HitBallEvent(isSmash: false, BallBehaviour.instance.transform.position);
			}
		}

		public void ServeTest()
		{
			Vector3 testServeVelo = TestServeVelo;
			if (base.transform.position.z > 0f)
			{
				testServeVelo = TestServeVelo;
				testServeVelo.x = ((GameManager.instance.serveCount == 0) ? testServeVelo.x : (testServeVelo.x * -1f));
			}
			else
			{
				testServeVelo = TestServeVelo;
				testServeVelo.z *= -1f;
				testServeVelo.x = ((GameManager.instance.serveCount == 0) ? (testServeVelo.x * -1f) : testServeVelo.x);
			}
			BallBehaviour.instance.SetAllStop();
			BallPhysics.instance.PhysicsSimulator(testServeVelo, BallBehaviour.instance.transform.position, Vector3.zero, Vector3.zero, isSmash: false);
			Cfollower.HitBallEvent(isSmash: false, BallBehaviour.instance.transform.position);
		}

		private void FixedUpdate()
		{
			if (Time.fixedDeltaTime != 0f)
			{
				ListVelo.Add(inputDeviceState.deviceVelo * 7f);
				if (ListVelo.Count > 5)
				{
					ListVelo.RemoveAt(0);
				}
				ListAngularVelo.Add(inputDeviceState.deviceAngularVelo * 6f);
				if (ListAngularVelo.Count > 5)
				{
					ListAngularVelo.RemoveAt(0);
				}
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space) && BallBehaviour.instance.gameObject.activeInHierarchy)
			{
				ServeTest();
			}
		}

		public Vector3 getBoundVector(Vector3 _contactPoint, Vector3 _boundForward, Vector3 _ipSa)
		{
			Vector3 vector = -1f * _ipSa;
			float num = Vector3.Angle(vector, _boundForward);
			Vector3 axis = Vector3.Cross(_boundForward, vector);
			return Quaternion.AngleAxis(-2f * num, axis) * vector;
		}
	}
	public class ColliderEventChcker : MonoBehaviour
	{
		private Cfollower cfollower;

		[HideInInspector]
		public Rigidbody rigid;

		private SphereCollider thisCol;

		private void Start()
		{
			initData();
			cfollower = UnityEngine.Object.FindObjectOfType<Cfollower>();
		}

		private void initData()
		{
			thisCol = base.gameObject.AddComponent<SphereCollider>();
			rigid = base.gameObject.AddComponent<Rigidbody>();
			thisCol.radius = 0.06f;
			rigid.useGravity = false;
			rigid.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.layer == 10)
			{
				Vector3 position = base.transform.position;
				cfollower.ColliderEvent(collision, position);
			}
		}

		private void FixedUpdate()
		{
			rigid.angularVelocity = Vector3.zero;
		}
	}
	public class Cplane : MonoBehaviour
	{
		private ArrayList dumies;

		private Vector3[] oldPos;

		private Vector3[] mVels;

		private Vector3[] oldVels;

		private GameObject[] colGOs;

		private List<Vector3[]> mVelsList = new List<Vector3[]>();

		private Vector3[] AverageVelos;

		private void Start()
		{
			Vector3[] vertices = GetComponent<MeshFilter>().mesh.vertices;
			colGOs = new GameObject[vertices.Length];
			Transform parent = GameObject.Find("FollowTracer").transform;
			dumies = new ArrayList();
			for (int i = 0; i < vertices.Length; i++)
			{
				Vector3 position = new Vector3(vertices[i].x, vertices[i].y, vertices[i].z);
				Vector3 position2 = base.transform.TransformPoint(position);
				Transform transform = new GameObject().transform;
				transform.name = i.ToString();
				transform.position = position2;
				transform.parent = base.transform;
				transform.localRotation = Quaternion.identity;
				colGOs[i] = new GameObject("tracer" + i);
				colGOs[i].transform.parent = parent;
				colGOs[i].AddComponent<ColliderEventChcker>();
				dumies.Add(transform);
			}
			oldPos = new Vector3[dumies.Count];
			mVels = new Vector3[dumies.Count];
			oldVels = new Vector3[dumies.Count];
			AverageVelos = new Vector3[mVels.Length];
			for (int j = 0; j < dumies.Count; j++)
			{
				oldPos[j] = (dumies[j] as Transform).position;
			}
			GetComponent<MeshRenderer>().enabled = false;
		}

		public Vector3 getPointVellocity(Vector3 _pos)
		{
			int i;
			for (i = 0; i < AverageVelos.Length; i++)
			{
				AverageVelos[i] = new Vector3(mVelsList.Average((Vector3[] x) => x[i].x), mVelsList.Average((Vector3[] x) => x[i].y), mVelsList.Max((Vector3[] x) => x[i].z));
			}
			_ = mVelsList[mVelsList.Count - 1];
			float num = 10000f;
			Vector3 result = Vector3.zero;
			for (int j = 0; j < dumies.Count; j++)
			{
				Transform transform = dumies[j] as Transform;
				float num2 = Vector3.Distance(_pos, transform.position);
				if (num2 < num)
				{
					num = num2;
					result = AverageVelos[j];
					if (result.magnitude < 0.01f)
					{
						result = oldVels[j];
					}
				}
			}
			return result;
		}

		public Vector3[] GetInversPoss(Vector3 cDir)
		{
			Vector3[] array = new Vector3[colGOs.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = cDir + colGOs[i].transform.position;
			}
			return array;
		}

		private void FixedUpdate()
		{
			for (int i = 0; i < dumies.Count; i++)
			{
				oldVels[i] = mVels[i];
				Vector3 position = (dumies[i] as Transform).position;
				mVels[i] = (position - oldPos[i]) / Time.fixedDeltaTime;
				oldPos[i] = position;
			}
			mVelsList.Add(mVels);
			if (mVelsList.Count > 5)
			{
				mVelsList.RemoveAt(0);
			}
			for (int j = 0; j < colGOs.Length; j++)
			{
				if (!(colGOs[j].GetComponent<ColliderEventChcker>().rigid == null))
				{
					colGOs[j].GetComponent<ColliderEventChcker>().rigid.velocity = ((dumies[j] as Transform).position - colGOs[j].transform.position) / Time.fixedDeltaTime;
				}
			}
		}
	}
	public class CrowdManager : MonoBehaviour
	{
		private AudioSource Audio;

		private void OnEnable()
		{
			GameManager.PanjungEvent += Reaction;
		}

		private void OnDisable()
		{
			GameManager.PanjungEvent -= Reaction;
		}

		private void Start()
		{
			Audio = GetComponent<AudioSource>();
		}

		private void Reaction(int myScore, int otherScore, bool isFault, int winNum)
		{
			string clipName = ((winNum == 0) ? "cheer" : "ohh");
			StartCoroutine(PlaySound(clipName));
		}

		private IEnumerator PlaySound(string clipName)
		{
			AudioClip soundClip = SoundManager.instance.GetSoundClip(clipName);
			if (!(Audio.clip != null))
			{
				Audio.clip = soundClip;
				Audio.Play();
				while (Audio.isPlaying)
				{
					yield return null;
				}
				Audio.clip = null;
			}
		}
	}
	public class FaultSafeZone : MonoBehaviour
	{
		private Animator anim;

		private void Awake()
		{
			anim = GetComponentInChildren<Animator>();
		}

		private void OnEnable()
		{
			PlayerBehaviour.ResetBallEvent += SetViewFaultSafe;
			Cfollower.HitBallEvent += OffFaultSafe;
		}

		private void OnDisable()
		{
			PlayerBehaviour.ResetBallEvent -= SetViewFaultSafe;
			Cfollower.HitBallEvent -= OffFaultSafe;
		}

		private void SetViewFaultSafe(Vector3 pos)
		{
			UnityEngine.Debug.Log("폴트 이벤트!! " + GameManager.instance.serveTurn);
			if (GameManager.instance.serveTurn != 0)
			{
				base.transform.GetChild(0).gameObject.SetActive(value: false);
				return;
			}
			base.transform.GetChild(0).gameObject.SetActive(value: true);
			int serveCount = GameManager.instance.serveCount;
			anim.SetTrigger(serveCount.ToString());
		}

		private void OffFaultSafe(bool isSmash, Vector3 cPoint)
		{
			base.transform.GetChild(0).gameObject.SetActive(value: false);
		}
	}
	public enum GameTurn
	{
		my,
		other,
		none
	}
	public enum ServeTurn
	{
		my,
		other
	}
	public class GameManager : MonoBehaviour
	{
		public delegate void gameStart();

		public delegate void MultiGameStart();

		public delegate void PanJung(int myScore, int otherScore, bool isFault, int winNum);

		public delegate void PlayOver(int num);

		public delegate void GameResume();

		public static GameManager instance;

		public ServeTurn serveTurn;

		public GameTurn gameTurn;

		public int MyScore;

		public int OtherScore;

		public int MySetScore;

		public int OtherSetScore;

		[HideInInspector]
		public int lastTableID;

		[HideInInspector]
		public int ballTarget;

		public bool isMyServeBall;

		public bool isOtherServeBall;

		public bool isFault;

		public int serveCount;

		[HideInInspector]
		public bool isOnPanjung;

		[HideInInspector]
		public int RallyCount;

		public int MaxPoint;

		public int faultCount;

		public Transform FaultCheckerTR;

		public float ShootTimeLimit;

		public int JansuCount;

		private Coroutine ShootTimeCheckRoutine;

		private bool isPowerWin = true;

		public static event gameStart GameStartEvent;

		public static event MultiGameStart MultiGameStartEvent;

		public static event PanJung PanjungEvent;

		public static event PlayOver PlayOverEvent;

		public static event GameResume GameResumeEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			BallBehaviour.BallCollisionEvent += BallCollisionEvent;
			Cfollower.HitBallEvent += StopShootTimeCheckRoutine;
			GameResumeEvent += Resume;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				PlayOverEvent += Panjung;
			}
			else
			{
				GameManager.PlayOverEvent = null;
			}
		}

		private void OnDisable()
		{
			BallBehaviour.BallCollisionEvent -= BallCollisionEvent;
			Cfollower.HitBallEvent -= StopShootTimeCheckRoutine;
			GameResumeEvent -= Resume;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				PlayOverEvent -= Panjung;
			}
			else
			{
				GameManager.PlayOverEvent = null;
			}
		}

		private void Start()
		{
			initData();
			Invoke("GameStart", 3f);
		}

		private void GameStart()
		{
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			GameManager.GameStartEvent?.Invoke();
			WorldUICtrl.instance.SetServeAudioClip(serveTurn);
			ShootTimeCheck(serveTurn);
		}

		public void ShootTimeCheck(ServeTurn _serveTurn)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				WorldUICtrl.instance.serveBallViewer.TimeUI.gameObject.SetActive(value: false);
				return;
			}
			WorldUICtrl.instance.serveBallViewer.TimeUI.gameObject.SetActive(_serveTurn == ServeTurn.my);
			if (_serveTurn == ServeTurn.my && ShootTimeCheckRoutine == null)
			{
				ShootTimeCheckRoutine = StartCoroutine(IEnum_ShootTimeLimit());
			}
		}

		private IEnumerator IEnum_ShootTimeLimit()
		{
			UnityEngine.Debug.Log("ShootTimeCheck");
			float currentTime = ShootTimeLimit;
			while (currentTime > 0f)
			{
				WorldUICtrl.instance.SetTimeLimit(currentTime);
				currentTime -= 1f;
				yield return new WaitForSeconds(1f);
			}
			isOnPanjung = false;
			WorldUICtrl.instance.CloseServeTurn(isSmash: false, Vector3.zero);
			WorldUICtrl.instance.OffHowToPlay();
			BallBehaviour.instance.gameObject.SetActive(value: false);
			JansuCount++;
			if (JansuCount >= 2)
			{
				Panjung(4);
			}
			else
			{
				Panjung(3);
			}
			ShootTimeCheckRoutine = null;
		}

		private void StopShootTimeCheckRoutine(bool isSmash, Vector3 cPoint)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (ShootTimeCheckRoutine != null)
				{
					StopCoroutine(ShootTimeCheckRoutine);
				}
				ShootTimeCheckRoutine = null;
			}
		}

		private void initData()
		{
			string nick = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			string nick2 = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			ScorePlaneCtrl.instance.SetData(nick, nick2, MaxPoint);
			SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetData(nick, nick2, MaxPoint);
		}

		public void SetPlayerBallTarget()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (GameManager.PlayOverEvent != null)
				{
					PlayOverEvent -= Panjung;
					UnityEngine.Debug.Log("<color=red> 내가 침!! </color>");
				}
				else
				{
					UnityEngine.Debug.Log("<color=blue> 이벤트 없는데 해제하려함 버그!!!!!!!!! </color>");
				}
			}
			if (gameTurn == GameTurn.my)
			{
				GameManager.PlayOverEvent?.Invoke(1);
				return;
			}
			ballTarget = 1;
			lastTableID = -1;
			gameTurn = GameTurn.my;
			isMyServeBall = false;
		}

		public void SetOtherPlayerBallTarget()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (GameManager.PlayOverEvent == null)
				{
					PlayOverEvent += Panjung;
					UnityEngine.Debug.Log("<color=green> 상대가 침!! </color>");
				}
				else
				{
					UnityEngine.Debug.Log("<color=blue> 이벤트 있는데 등록하려함 버그!!!!!!!!! </color>");
				}
			}
			if (gameTurn == GameTurn.other)
			{
				GameManager.PlayOverEvent?.Invoke(0);
				return;
			}
			ballTarget = 0;
			lastTableID = -1;
			gameTurn = GameTurn.other;
			isOtherServeBall = false;
		}

		private void BallCollisionEvent(string colString)
		{
			if (isOnPanjung || IsFault(colString))
			{
				return;
			}
			switch (colString)
			{
			case "0":
				if (lastTableID == -1 && gameTurn == GameTurn.none)
				{
					GameManager.GameResumeEvent();
					break;
				}
				if (ballTarget != 0)
				{
					if (lastTableID == 0)
					{
						GameManager.PlayOverEvent?.Invoke(1);
					}
					else
					{
						int num = (int)(gameTurn + 1) % 2;
						GameManager.PlayOverEvent?.Invoke(num);
					}
				}
				else
				{
					ballTarget = 1;
				}
				lastTableID = 0;
				break;
			case "1":
				if (ballTarget != 1)
				{
					if (lastTableID == 1)
					{
						GameManager.PlayOverEvent?.Invoke(0);
					}
					else
					{
						int num3 = (int)(gameTurn + 1) % 2;
						GameManager.PlayOverEvent?.Invoke(num3);
					}
				}
				else
				{
					ballTarget = 0;
				}
				lastTableID = 1;
				break;
			case "2":
				if (lastTableID == 0)
				{
					GameManager.PlayOverEvent?.Invoke(1);
				}
				else if (lastTableID == 1)
				{
					GameManager.PlayOverEvent?.Invoke(0);
				}
				else if (lastTableID == -1)
				{
					int num2 = (int)(gameTurn + 1) % 2;
					GameManager.PlayOverEvent?.Invoke(num2);
				}
				break;
			case "Net":
				if (isMyServeBall)
				{
					isFault = true;
					UnityEngine.Debug.Log("Fault : " + instance.isFault);
				}
				break;
			}
		}

		private bool IsFault(string colString)
		{
			if (isFault)
			{
				GameManager.PlayOverEvent?.Invoke(2);
				return true;
			}
			return false;
		}

		private void Panjung(int num)
		{
			UnityEngine.Debug.Log(num);
			if (isOnPanjung)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (num == 2)
				{
					faultCount++;
				}
				if (faultCount >= 2)
				{
					num = (int)(gameTurn + 1) % 2;
				}
				UnityEngine.Debug.Log(num);
				GameManager.PanjungEvent?.Invoke(MyScore, OtherScore, isFault: false, num);
				return;
			}
			ADBanner.instance.ChangeAD();
			RefreeManager.instance.Play(num);
			UnityEngine.Debug.Log("판정 : " + num);
			isOnPanjung = true;
			bool flag = false;
			if (num == 2)
			{
				faultCount++;
				if (faultCount >= 2)
				{
					num = (int)(gameTurn + 1) % 2;
				}
			}
			switch (num)
			{
			case 0:
				MyScore++;
				break;
			case 1:
				OtherScore++;
				break;
			}
			RallyCount = 0;
			lastTableID = -1;
			ballTarget = -1;
			if (MyScore != 0 && OtherScore != 0)
			{
				isPowerWin = false;
			}
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			gameTurn = GameTurn.none;
			if (num != 2)
			{
				WorldUICtrl.instance.CallScore(MyScore, OtherScore);
				faultCount = 0;
				serveCount++;
				serveCount %= 2;
			}
			else
			{
				WorldUICtrl.instance.PanjungSound("fault");
				flag = true;
			}
			GameManager.PanjungEvent?.Invoke(MyScore, OtherScore, flag, num);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				ScorePlaneCtrl.instance.SetScore(MyScore, OtherScore);
				SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetPointScore(MyScore, OtherScore);
			}
			if ((MyScore >= MaxPoint || OtherScore >= MaxPoint) && Mathf.Abs(MyScore - OtherScore) >= 2)
			{
				WorldUICtrl.instance.PanjungSound("game");
			}
			Invoke("CallGameResumeEvent", 3f);
		}

		public void ReceivePanjung(bool isfault)
		{
			UnityEngine.Debug.Log("판정 이벤트 받음");
			if (isOnPanjung)
			{
				UnityEngine.Debug.Log("판정 이벤트를 받았는데 판정 중임");
				return;
			}
			isOnPanjung = true;
			RallyCount = 0;
			lastTableID = -1;
			ballTarget = -1;
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			gameTurn = GameTurn.none;
			isFault = false;
			if (MyScore != 0 && OtherScore != 0)
			{
				isPowerWin = false;
			}
			if (!isfault)
			{
				faultCount = 0;
				serveCount++;
				serveCount %= 2;
			}
		}

		private void CallGameResumeEvent()
		{
			if (MyScore >= MaxPoint || OtherScore >= MaxPoint)
			{
				if (Mathf.Abs(MyScore - OtherScore) >= 2)
				{
					SetEnd();
					return;
				}
				GameManager.GameResumeEvent?.Invoke();
				gameTurn = GameTurn.none;
				WorldUICtrl.instance.SetServeAudioClip(serveTurn);
			}
			else
			{
				GameManager.GameResumeEvent?.Invoke();
				gameTurn = GameTurn.none;
				WorldUICtrl.instance.SetServeAudioClip(serveTurn);
			}
		}

		public void ReceiveGameResume(int ResumeIndex)
		{
			switch (ResumeIndex)
			{
			case 0:
				MultiPlayOver();
				break;
			case 1:
				MultiSetEnd();
				break;
			}
		}

		private void MultiSetEnd()
		{
			serveCount = 0;
			MyScore = 0;
			OtherScore = 0;
			faultCount = 0;
			isFault = false;
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			GameManager.GameResumeEvent?.Invoke();
			WorldUICtrl.instance.SetServeAudioClip(serveTurn);
		}

		private void MultiPlayOver()
		{
			GameManager.GameResumeEvent?.Invoke();
			gameTurn = GameTurn.none;
			WorldUICtrl.instance.SetServeAudioClip(serveTurn);
		}

		private void SetEnd()
		{
			if (MyScore > OtherScore)
			{
				MySetScore++;
			}
			else
			{
				OtherSetScore++;
			}
			serveCount = 0;
			MyScore = 0;
			OtherScore = 0;
			faultCount = 0;
			isFault = false;
			serveTurn = ((serveTurn == ServeTurn.my) ? ServeTurn.other : ServeTurn.my);
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			if (serveTurn == ServeTurn.my)
			{
				FaultCheckerTR.position = Vector3.zero;
				FaultCheckerTR.eulerAngles = new Vector3(0f, 180f, 0f);
			}
			else
			{
				FaultCheckerTR.position = new Vector3(-0.08f, 0f, 0f);
				FaultCheckerTR.eulerAngles = Vector3.zero;
			}
			if (MySetScore >= 2 || OtherSetScore >= 2)
			{
				GameEnd();
			}
			else
			{
				GameManager.GameResumeEvent?.Invoke();
				WorldUICtrl.instance.SetServeAudioClip(serveTurn);
			}
			ScorePlaneCtrl.instance.SetScore(MyScore, OtherScore);
			SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetPointScore(MyScore, OtherScore);
			SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetGameScore(MySetScore, OtherSetScore);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				GameManager.PlayOverEvent = null;
			}
		}

		private void Resume()
		{
			StartCoroutine(DelayResnume());
		}

		private IEnumerator DelayResnume()
		{
			yield return new WaitForSeconds(1f);
			isOnPanjung = false;
			ShootTimeCheck(serveTurn);
		}

		private void GameEnd()
		{
			int num = -1;
			num = ((MySetScore <= OtherSetScore) ? 1 : 0);
			PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
			{
				MySetScore.ToString(),
				OtherSetScore.ToString()
			}, num);
			if (WorldUICtrl.instance.isDeuce && num == 0 && (MySetScore >= 2 || OtherSetScore >= 2))
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach31", 1);
				UnityEngine.Debug.Log("<color=red> 듀스로 이기기 업적 달성!!!</color>");
			}
			if (num == 0 && isPowerWin && (MySetScore >= 2 || OtherSetScore >= 2))
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach32", 1);
				UnityEngine.Debug.Log("<color=red> 완벽한 승리 업적 달성!!!</color>");
			}
			if (num == 0)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
			}
		}

		private void Update()
		{
		}
	}
	public class HandModelAnimation : MonoBehaviour
	{
		private InputDeviceState inputDeviceState;

		private Animator anim;

		public Transform RacketHolderTR;

		public Transform RacketTR;

		public bool isRacketGrab;

		private bool isChange;

		private void Awake()
		{
			inputDeviceState = base.transform.parent.GetComponent<InputDeviceState>();
			anim = GetComponent<Animator>();
		}

		private void Start()
		{
			InitAnim();
		}

		private void PlayAnim(bool isGrab)
		{
			string trigger = (isGrab ? "Catch" : "Idle");
			anim.SetTrigger(trigger);
		}

		public void isGrab(bool _isGab)
		{
			isRacketGrab = _isGab;
			InitAnim();
		}

		private void InitAnim()
		{
			if (isRacketGrab)
			{
				RacketTR.parent = RacketHolderTR;
				RacketTR.localPosition = new Vector3(0.0178f, -0.006f, 0.093f);
				RacketTR.localRotation = Quaternion.Euler(new Vector3(-89.47701f, 166.493f, -164.878f));
				RacketTR.localScale = Vector3.one * 0.85f;
				anim.SetTrigger("Grab");
			}
			else
			{
				anim.SetTrigger("Idle");
			}
		}

		private void FixedUpdate()
		{
			if (!isRacketGrab && inputDeviceState.trigger != isChange)
			{
				UnityEngine.Debug.Log("change");
				PlayAnim(inputDeviceState.trigger);
				isChange = inputDeviceState.trigger;
			}
		}
	}
	public class LEDScoreBoard_CTRL : MonoBehaviour
	{
		[Serializable]
		public struct LEDScoreBoardInfo
		{
			public Image[] gameScoreImage;

			public Image[] pointScoreImage;

			public Text name;
		}

		public LEDScoreBoardInfo[] player;

		public void SetData(string name_P1, string name_P2, int minPoint)
		{
			player[0].name.text = name_P1.ToString();
			player[1].name.text = name_P2.ToString();
			SetPointScore(0, 0, minPoint);
			SetGameScore(0, 0);
		}

		public void SetPointScore(int score_P1, int score_P2, int minPoint)
		{
			LEDScoreBoard_SGT getInstance = SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance;
			if (score_P1 >= minPoint - 1 && score_P2 >= minPoint - 1)
			{
				if (score_P1 == score_P2 + 1)
				{
					player[0].pointScoreImage[0].sprite = getInstance.sprites[11];
					player[0].pointScoreImage[1].sprite = getInstance.sprites[12];
					player[1].pointScoreImage[0].sprite = getInstance.sprites[10];
					player[1].pointScoreImage[1].sprite = getInstance.sprites[10];
					return;
				}
				if (score_P1 + 1 == score_P2)
				{
					player[0].pointScoreImage[0].sprite = getInstance.sprites[10];
					player[0].pointScoreImage[1].sprite = getInstance.sprites[10];
					player[1].pointScoreImage[0].sprite = getInstance.sprites[11];
					player[1].pointScoreImage[1].sprite = getInstance.sprites[12];
					return;
				}
			}
			score_P1 = score_P1 switch
			{
				0 => 0, 
				1 => 15, 
				2 => 30, 
				3 => 40, 
				_ => 40, 
			};
			score_P2 = score_P2 switch
			{
				0 => 0, 
				1 => 15, 
				2 => 30, 
				3 => 40, 
				_ => 40, 
			};
			int[] array = new int[2] { score_P1, score_P2 };
			for (int i = 0; i < 2; i++)
			{
				if (array[i] > 9)
				{
					player[i].pointScoreImage[0].sprite = getInstance.sprites[array[i] / 10];
					player[i].pointScoreImage[1].sprite = getInstance.sprites[array[i] % 10];
				}
				else
				{
					player[i].pointScoreImage[0].sprite = getInstance.sprites[0];
					player[i].pointScoreImage[1].sprite = getInstance.sprites[array[i]];
				}
			}
		}

		public void SetGameScore(int score_P1, int score_P2)
		{
			LEDScoreBoard_SGT getInstance = SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance;
			int[] array = new int[2] { score_P1, score_P2 };
			for (int i = 0; i < 2; i++)
			{
				switch (array[i])
				{
				case 0:
					player[i].gameScoreImage[0].sprite = getInstance.sprites[13];
					player[i].gameScoreImage[1].sprite = getInstance.sprites[13];
					break;
				case 1:
					player[i].gameScoreImage[0].sprite = getInstance.sprites[14];
					player[i].gameScoreImage[1].sprite = getInstance.sprites[13];
					break;
				case 2:
					player[i].gameScoreImage[0].sprite = getInstance.sprites[14];
					player[i].gameScoreImage[1].sprite = getInstance.sprites[14];
					break;
				}
			}
		}
	}
	public class LEDScoreBoard_SGT : SingletonBase.Singleton<LEDScoreBoard_SGT>
	{
		public LEDScoreBoard_CTRL[] objects;

		public Sprite[] sprites;

		private int minPoint;

		public void SetData(string name01, string name02, int m_minPoint)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetData(name01, name02, m_minPoint);
			}
			minPoint = m_minPoint;
		}

		public void SetPointScore(int p01, int p02)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetPointScore(p01, p02, minPoint);
			}
		}

		public void SetGameScore(int p01, int p02)
		{
			for (int i = 0; i < objects.Length; i++)
			{
				objects[i].SetGameScore(p01, p02);
			}
		}
	}
	public class MultiPlayerBehaviour : MonoBehaviour
	{
		private PhotonView pview;

		private Transform Player;

		private Transform[] rigs = new Transform[3];

		public Transform[] rigTrackers;

		public GameObject[] Hands;

		private string rigPath = "Me/XR Rig/Camera Offset/";

		private VRIK vrik;

		public Transform RacketTR;

		public Transform[] RacketHolderTRs;

		public Transform NickNameTextTR;

		public TextMesh NickNameText;

		private void OnEnable()
		{
			RPCManager.OtherPlayerChangeHandEvent += OtherPlayerChangeHandEvent;
		}

		private void OnDisable()
		{
			RPCManager.OtherPlayerChangeHandEvent -= OtherPlayerChangeHandEvent;
		}

		private void Start()
		{
			pview = GetComponent<PhotonView>();
			CreateOtherCharacter();
		}

		private void CreateOtherCharacter()
		{
			if (pview.IsMine)
			{
				rigTrackers[1].Find("LeftHand").gameObject.SetActive(value: false);
				rigTrackers[2].Find("RightHand").gameObject.SetActive(value: false);
				NickNameText.gameObject.SetActive(value: false);
				return;
			}
			vrik = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("VRIK"), base.transform).GetComponent<VRIK>();
			MultiPlayerManager.instance.OtherPlayerCharacter = vrik.gameObject;
			vrik.solver.spine.headTarget = rigTrackers[0].Find("IK");
			vrik.solver.spine.pelvisTarget = rigTrackers[3];
			CustomModelSettingCtrl component = vrik.GetComponent<CustomModelSettingCtrl>();
			component.enabled = true;
			int num = (PhotonNetwork.IsMasterClient ? 1 : 0);
			CustomModelData modelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[num];
			component.Init(modelData, CustomModelViewState.HalfCut2);
			NickNameText.text = pview.Owner.NickName;
			StartCoroutine(vrIk());
		}

		private IEnumerator vrIk()
		{
			while (true)
			{
				Vector3 forward = vrik.transform.position - PlayerBehaviour.instance.HeadTR.position;
				forward.y = 0f;
				Vector3 position = rigTrackers[0].position;
				position.y += 0.5f;
				NickNameTextTR.position = position;
				NickNameText.transform.rotation = Quaternion.LookRotation(forward);
				yield return null;
			}
		}

		private void OtherPlayerChangeHandEvent(bool isRight)
		{
			if (!isRight)
			{
				RacketTR.parent = RacketHolderTRs[0];
				RacketTR.localPosition = new Vector3(0f, -0.2f, 0f);
				RacketTR.localRotation = Quaternion.identity;
			}
			else
			{
				RacketTR.parent = RacketHolderTRs[1];
				RacketTR.localPosition = new Vector3(0f, -0.2f, 0f);
				RacketTR.localRotation = Quaternion.identity;
			}
		}

		private void Update()
		{
			if (pview.IsMine)
			{
				if (rigs[0] == null)
				{
					rigs[0] = GameObject.Find(rigPath + "Head").transform;
				}
				if (rigs[1] == null)
				{
					rigs[1] = GameObject.Find(rigPath + "LeftHand Controller").transform;
				}
				if (rigs[2] == null)
				{
					rigs[2] = GameObject.Find(rigPath + "RightHand Controller").transform;
				}
				for (int i = 0; i < rigs.Length; i++)
				{
					rigTrackers[i].position = rigs[i].position;
					rigTrackers[i].rotation = rigs[i].rotation;
				}
			}
		}
	}
	public class MultiPlayerManager : MonoBehaviour
	{
		public static MultiPlayerManager instance;

		public GameObject LocalPlayer;

		public GameObject OtherPlayerCharacter;

		public List<GameObject> OtherPlayerCharacters;

		private void Awake()
		{
			base.enabled = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi;
			if (base.enabled)
			{
				if (instance == null)
				{
					instance = this;
				}
				else
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		public void create()
		{
			UnityEngine.Debug.Log("123123123123");
			LocalPlayer = PhotonNetwork.Instantiate("TENNIS_MultiPlayer", Vector3.zero, Quaternion.identity, 0);
			LocalPlayer.name = PhotonNetwork.LocalPlayer.NickName;
		}
	}
	[Serializable]
	public class HandInfo
	{
		public bool isUse;

		public Transform HandTR;

		public Vector3 IdlePos;

		public Vector3 IdleRot;

		public Vector3 GrabPos;

		public Vector3 GrabRot;
	}
	public class PlayerBehaviour : MonoBehaviour
	{
		public delegate void resetBall(Vector3 pos);

		public delegate void Test();

		public delegate void ChangeHand(bool isRight);

		private enum HitState
		{
			normal,
			smash,
			vollry
		}

		public static PlayerBehaviour instance;

		public Transform[] PlayerServeTRs;

		private Transform PlayerServeTR;

		private Coroutine playerMoveCor;

		public Transform HeadTR;

		public List<HandInfo> ListHandPosInfo = new List<HandInfo>();

		private HitState hitState;

		public static event resetBall ResetBallEvent;

		public static event Test testEvent;

		public static event ChangeHand ChangeHandEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			Cfollower.HitBallEvent += HitBall;
			AIBehaviour.HitBallEvent += OtherPlayerHitBall;
			GameManager.GameStartEvent += GameResumeEvent;
			GameManager.GameResumeEvent += GameResumeEvent;
			RPCManager.OtherPlayerHitBallEvent += OtherPlayerHitball;
		}

		private void OnDisable()
		{
			Cfollower.HitBallEvent -= HitBall;
			AIBehaviour.HitBallEvent -= OtherPlayerHitBall;
			GameManager.GameStartEvent -= GameResumeEvent;
			GameManager.GameResumeEvent -= GameResumeEvent;
			RPCManager.OtherPlayerHitBallEvent -= OtherPlayerHitball;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				ResetBallEvent -= BallBehaviour.instance.ResetBall;
			}
			else
			{
				PlayerBehaviour.ResetBallEvent = null;
			}
		}

		private void Start()
		{
			SetStartHandler(PublicGameUIManager.gameSetting.IsRightHanded());
			PublicGameUIManager.gameSetting.AddHandChangedEvent(ChangeHandler);
		}

		private void SetStartHandler(bool isRight)
		{
			ListHandPosInfo[0].isUse = !isRight;
			ListHandPosInfo[0].HandTR.GetComponent<HandModelAnimation>().isGrab(ListHandPosInfo[0].isUse);
			ListHandPosInfo[1].isUse = isRight;
			ListHandPosInfo[1].HandTR.GetComponent<HandModelAnimation>().isGrab(ListHandPosInfo[1].isUse);
			PlayerBehaviour.ChangeHandEvent?.Invoke(isRight);
		}

		private void GameResumeEvent()
		{
			int serveCount = GameManager.instance.serveCount;
			base.transform.position = PlayerServeTRs[serveCount].position;
			Vector3 pos = (ListHandPosInfo[0].isUse ? PlayerServeTRs[serveCount].Find("Left").position : PlayerServeTRs[serveCount].Find("Right").position);
			pos.y = HeadTR.position.y + 0.8f;
			PlayerBehaviour.ResetBallEvent?.Invoke(pos);
			if (playerMoveCor != null)
			{
				StopCoroutine(playerMoveCor);
			}
		}

		private void HitBall(bool isSmash, Vector3 cPoint)
		{
			GameManager.instance.RallyCount++;
			GameManager.instance.SetPlayerBallTarget();
		}

		private void OtherPlayerHitball(bool isServe)
		{
			OtherPlayerHitBall(isServe, isSmash: false);
		}

		private void OtherPlayerHitBall(bool isServe, bool isSmash)
		{
			getBestPoint bestPoint = BallBehaviour.instance.getBestPoint(base.transform.position);
			if (playerMoveCor != null)
			{
				StopCoroutine(playerMoveCor);
				playerMoveCor = StartCoroutine(playerCameraMove(bestPoint, isServe));
			}
			else
			{
				playerMoveCor = StartCoroutine(playerCameraMove(bestPoint, isServe));
			}
		}

		private void TestShoot()
		{
			if (!GameManager.instance.isOnPanjung)
			{
				PlayerBehaviour.testEvent?.Invoke();
			}
		}

		private IEnumerator playerCameraMove(getBestPoint gbp, bool isServe)
		{
			float num = Mathf.Abs(gbp.smashPoint.z);
			_ = Vector3.zero;
			Vector3 cameraPos;
			float t;
			if (gbp.bestPoint == Vector3.zero || gbp.nearestPoint == Vector3.zero)
			{
				float num2 = Vector3.Distance(base.transform.position, gbp.smashPoint);
				float num3 = Vector3.Distance(base.transform.position, gbp.vollryPoint);
				if (num2 > num3)
				{
					cameraPos = gbp.vollryPoint;
					t = gbp.vpTime;
				}
				else
				{
					cameraPos = gbp.smashPoint;
					t = gbp.spTime;
				}
			}
			else if (isServe)
			{
				hitState = HitState.normal;
				cameraPos = gbp.bestPoint;
				t = gbp.bpTime;
			}
			else if (gbp.spTime > 1.5f && num > 4f)
			{
				hitState = HitState.smash;
				cameraPos = gbp.smashPoint;
				t = gbp.spTime;
			}
			else if (gbp.spTime > 1.3f && num > 1.5f)
			{
				hitState = HitState.vollry;
				cameraPos = gbp.vollryPoint;
				t = gbp.vpTime;
			}
			else
			{
				hitState = HitState.normal;
				cameraPos = gbp.bestPoint;
				t = gbp.bpTime;
			}
			if (!gbp.isSafe)
			{
				cameraPos = gbp.bestPoint;
				t = 0f;
			}
			UnityEngine.Debug.Log(string.Concat("cameraPos : ", cameraPos, " ", hitState, " t : ", t));
			cameraPos.y = 0f;
			Invoke("TestShoot", t);
			float dis = 100f;
			cameraPos.x = Mathf.Clamp(cameraPos.x, -7f, 7f);
			if (base.transform.position.z > 0f)
			{
				cameraPos.z = Mathf.Clamp(cameraPos.z, 2f, 17.5f);
			}
			else
			{
				cameraPos.z = Mathf.Clamp(cameraPos.z, -17.5f, -2f);
			}
			Vector3 right = base.transform.right;
			Vector3 normalized = (cameraPos - base.transform.position).normalized;
			bool flag = Vector3.Dot(right, normalized) > 0f;
			if (hitState == HitState.smash)
			{
				if (PublicGameUIManager.gameSetting.IsRightHanded())
				{
					cameraPos.x += 0.3f;
				}
				else
				{
					cameraPos.x -= 0.3f;
				}
			}
			else if (hitState == HitState.vollry)
			{
				if (base.transform.position.z > 0f)
				{
					cameraPos.x = (flag ? (cameraPos.x += 1.1f) : (cameraPos.x -= 1.1f));
				}
				else
				{
					cameraPos.x = (flag ? (cameraPos.x -= 1.1f) : (cameraPos.x += 1.1f));
				}
			}
			else
			{
				float num4 = Mathf.Abs(gbp.bestPoint.z);
				if (gbp.bpTime > 1.2f && num4 < 5f)
				{
					flag = true;
				}
				if (base.transform.position.z > 0f)
				{
					cameraPos.x = (flag ? (cameraPos.x += 1f) : (cameraPos.x -= 1f));
				}
				else
				{
					cameraPos.x = (flag ? (cameraPos.x -= 1f) : (cameraPos.x += 1f));
				}
			}
			Vector3 vector = new Vector3(HeadTR.localPosition.x, 0f, HeadTR.localPosition.z);
			if (base.transform.position.z > 0f)
			{
				cameraPos += vector;
			}
			else
			{
				cameraPos -= vector;
			}
			float T = 0f;
			while (dis > 0.05f && !GameManager.instance.isOnPanjung)
			{
				dis = Vector3.Distance(base.transform.position, cameraPos);
				T = ((t == 0f) ? (Time.deltaTime * 0.5f) : (T + Time.deltaTime * 0.1f / t));
				base.transform.position = Vector3.Lerp(base.transform.position, cameraPos, T);
				yield return null;
			}
			playerMoveCor = null;
		}

		private void ChangeHandler(bool isRight)
		{
			ListHandPosInfo[0].isUse = !isRight;
			ListHandPosInfo[0].HandTR.GetComponent<HandModelAnimation>().isGrab(ListHandPosInfo[0].isUse);
			ListHandPosInfo[1].isUse = isRight;
			ListHandPosInfo[1].HandTR.GetComponent<HandModelAnimation>().isGrab(ListHandPosInfo[1].isUse);
			PlayerBehaviour.ChangeHandEvent?.Invoke(isRight);
			if (BallPhysics.instance.listBallInfo.Count == 0)
			{
				int serveCount = GameManager.instance.serveCount;
				Vector3 pos = ((!isRight) ? PlayerServeTRs[serveCount].Find("Left").position : PlayerServeTRs[serveCount].Find("Right").position);
				pos.y = HeadTR.position.y + 0.8f;
				PlayerBehaviour.ResetBallEvent?.Invoke(pos);
				UnityEngine.Debug.Log("changeHandler");
			}
		}
	}
	public class RPCManager : MonoBehaviourPunCallbacks
	{
		public delegate void OtherPlayerHitBall(bool isServe);

		public delegate void OtherPlayerChangeHand(bool isRight);

		private PhotonView pView;

		public Transform cols;

		public Transform servePosTR;

		public ExitGames.Client.Photon.Hashtable roomCustomProperty = new ExitGames.Client.Photon.Hashtable();

		public static RPCManager instance;

		public static event OtherPlayerHitBall OtherPlayerHitBallEvent;

		public static event OtherPlayerChangeHand OtherPlayerChangeHandEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			base.enabled = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi;
			if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(MapSelect());
			}
		}

		public override void OnEnable()
		{
			base.OnEnable();
			GameManager.MultiGameStartEvent += SetStart;
			GameManager.PanjungEvent += Panjung;
			GameManager.GameResumeEvent += RotateFaultCheker;
			Cfollower.HitBallEvent += MultiHitBall;
			PlayerBehaviour.ResetBallEvent += ResetBall;
			PlayerBehaviour.ChangeHandEvent += ChangeHand;
			GOLF.PhotonManager.OtherPlayerLeftEvent += OtherPlayerLeft;
		}

		public override void OnDisable()
		{
			base.OnDisable();
			GameManager.MultiGameStartEvent -= SetStart;
			GameManager.PanjungEvent -= Panjung;
			GameManager.GameResumeEvent -= RotateFaultCheker;
			Cfollower.HitBallEvent -= MultiHitBall;
			PlayerBehaviour.ResetBallEvent -= ResetBall;
			PlayerBehaviour.ChangeHandEvent -= ChangeHand;
			GOLF.PhotonManager.OtherPlayerLeftEvent -= OtherPlayerLeft;
		}

		private void Start()
		{
			Initialized();
			SetRoomCustomProperty();
			StartCoroutine(IEnum_waitingPlayer());
		}

		private IEnumerator MapSelect()
		{
			while (SetFloorColor.instance == null)
			{
				yield return null;
			}
			int num = UnityEngine.Random.Range(0, SetFloorColor.instance.Out.Length);
			SetFloorColor.instance.MapIndex = num;
			SetFloorColor.instance.ReceiveFloorColor();
			base.photonView.RPC("RPC_MapSelect", RpcTarget.Others, num);
		}

		[PunRPC]
		private void RPC_MapSelect(int _mapIndex)
		{
			UnityEngine.Debug.Log("Get Map Index!! : " + _mapIndex);
			SetFloorColor.instance.MapIndex = _mapIndex;
			SetFloorColor.instance.ReceiveFloorColor();
		}

		private void RotateFaultCheker()
		{
			if (PhotonNetwork.IsMasterClient)
			{
				if (GameManager.instance.serveTurn == ServeTurn.my)
				{
					GameManager.instance.FaultCheckerTR.eulerAngles = new Vector3(0f, 180f, 0f);
				}
				else
				{
					GameManager.instance.FaultCheckerTR.eulerAngles = Vector3.zero;
				}
			}
			else if (GameManager.instance.serveTurn == ServeTurn.my)
			{
				GameManager.instance.FaultCheckerTR.eulerAngles = Vector3.zero;
			}
			else
			{
				GameManager.instance.FaultCheckerTR.eulerAngles = new Vector3(0f, 180f, 0f);
			}
		}

		private void Initialized()
		{
			pView = GetComponent<PhotonView>();
			GameManager.instance.serveTurn = ((!PhotonNetwork.IsMasterClient) ? ServeTurn.other : ServeTurn.my);
			if (!PhotonNetwork.IsMasterClient)
			{
				Vector3 eulers = new Vector3(0f, 180f, 0f);
				cols.Rotate(eulers);
				servePosTR.Rotate(eulers);
				Transform obj = GameObject.Find("Me").transform;
				obj.Rotate(eulers);
				obj.position = servePosTR.GetChild(0).position;
			}
		}

		private void SetRoomCustomProperty()
		{
			roomCustomProperty.Add("1st Player Score", 0);
			roomCustomProperty.Add("2nd Player Score", 0);
			roomCustomProperty.Add("1st Player SetScore", 0);
			roomCustomProperty.Add("2nd Player SetScore", 0);
			roomCustomProperty.Add("serveTurn", (!PhotonNetwork.IsMasterClient) ? 1 : 0);
			roomCustomProperty.Add("winNum", -1);
			if (PhotonNetwork.IsMasterClient)
			{
				PhotonNetwork.CurrentRoom.SetCustomProperties(roomCustomProperty);
			}
		}

		private void SetStart()
		{
		}

		private IEnumerator IEnum_waitingPlayer()
		{
			yield return new WaitForSeconds(3f);
			MultiPlayerManager.instance.create();
			while (MultiPlayerManager.instance.OtherPlayerCharacter == null)
			{
				yield return null;
			}
			ChangeHandStart(PublicGameUIManager.gameSetting.IsRightHanded());
		}

		private void MultiHitBall(bool isSmash, Vector3 cPoint)
		{
			List<BallPhyscisInfo> listBallInfo = BallPhysics.instance.listBallInfo;
			Vector3 velocity = listBallInfo[0].velocity;
			Vector3 spinForce = listBallInfo[0].spinForce;
			Vector3 zero = Vector3.zero;
			bool isMyServeBall = GameManager.instance.isMyServeBall;
			pView.RPC("RPC_MultiHitball", RpcTarget.Others, velocity, cPoint, spinForce, zero, isSmash, isMyServeBall);
		}

		[PunRPC]
		private void RPC_MultiHitball(Vector3 swingPower, Vector3 startPos, Vector3 spinForce, Vector3 angularVelo, bool isSmash, bool isServe)
		{
			if (!BallBehaviour.instance.gameObject.activeSelf)
			{
				BallBehaviour.instance.gameObject.SetActive(value: true);
			}
			BallBehaviour.instance.SetAllStop();
			BallPhysics.instance.SetPreview(swingPower, spinForce, startPos, angularVelo, useAI: false, isMine: false);
			BallBehaviour.instance.SetParticle(startPos);
			BallBehaviour.instance.SetSmashParticle(isSmash);
			BallBehaviour.instance.HitBallSound(isSmash);
			BallBehaviour.instance.SetColEnable(onoff: true);
			BallBehaviour.instance.SetViewBall(onoff: true);
			GameManager.instance.SetOtherPlayerBallTarget();
			if (GameManager.instance.serveTurn == ServeTurn.other)
			{
				WorldUICtrl.instance.CloseServeTurn(isSmash: false, startPos);
			}
			RPCManager.OtherPlayerHitBallEvent?.Invoke(isServe);
		}

		private void Panjung(int myScore, int otherScore, bool isfault, int winNum)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				switch (winNum)
				{
				case 0:
					roomCustomProperty["1st Player Score"] = (int)roomCustomProperty["1st Player Score"] + 1;
					break;
				case 1:
				case 3:
				case 4:
					roomCustomProperty["2nd Player Score"] = (int)roomCustomProperty["2nd Player Score"] + 1;
					break;
				}
			}
			else
			{
				switch (winNum)
				{
				case 1:
				case 3:
				case 4:
					roomCustomProperty["1st Player Score"] = (int)roomCustomProperty["1st Player Score"] + 1;
					break;
				case 0:
					roomCustomProperty["2nd Player Score"] = (int)roomCustomProperty["2nd Player Score"] + 1;
					break;
				}
			}
			int num = 0;
			if ((int)roomCustomProperty["1st Player Score"] >= GameManager.instance.MaxPoint || (int)roomCustomProperty["2nd Player Score"] >= GameManager.instance.MaxPoint)
			{
				if (Mathf.Abs((int)roomCustomProperty["1st Player Score"] - (int)roomCustomProperty["2nd Player Score"]) >= 2)
				{
					num = 1;
					roomCustomProperty["serveTurn"] = ((int)roomCustomProperty["serveTurn"] + 1) % 2;
					if ((int)roomCustomProperty["1st Player Score"] > (int)roomCustomProperty["2nd Player Score"])
					{
						roomCustomProperty["1st Player SetScore"] = (int)roomCustomProperty["1st Player SetScore"] + 1;
						roomCustomProperty["1st Player Score"] = 0;
						roomCustomProperty["2nd Player Score"] = 0;
						UnityEngine.Debug.Log("방장이 이김");
					}
					else
					{
						roomCustomProperty["2nd Player SetScore"] = (int)roomCustomProperty["2nd Player SetScore"] + 1;
						roomCustomProperty["1st Player Score"] = 0;
						roomCustomProperty["2nd Player Score"] = 0;
						UnityEngine.Debug.Log("클라이언트가 이김");
					}
					if ((int)roomCustomProperty["1st Player SetScore"] >= 2 || (int)roomCustomProperty["2nd Player SetScore"] >= 2)
					{
						roomCustomProperty["1st Player Score"] = 0;
						roomCustomProperty["2nd Player Score"] = 0;
						num = 2;
					}
				}
				else
				{
					num = 0;
				}
			}
			else
			{
				num = 0;
			}
			roomCustomProperty["winNum"] = winNum;
			if (winNum == 4)
			{
				num = 3;
			}
			UnityEngine.Debug.Log("p1Score : " + (int)roomCustomProperty["1st Player Score"] + "  p2Score : " + (int)roomCustomProperty["2nd Player Score"] + "  winNum" + winNum + " p1SetScore : " + (int)roomCustomProperty["1st Player SetScore"] + "  p2SetScore : " + (int)roomCustomProperty["2nd Player SetScore"]);
			UnityEngine.Debug.Log("p1Score : " + (int)PhotonNetwork.CurrentRoom.CustomProperties["1st Player Score"] + "  p2Score : " + (int)PhotonNetwork.CurrentRoom.CustomProperties["2nd Player Score"] + "  winNum" + winNum + " p1SetScore : " + (int)PhotonNetwork.CurrentRoom.CustomProperties["1st Player SetScore"] + "  p2SetScore : " + (int)PhotonNetwork.CurrentRoom.CustomProperties["2nd Player SetScore"]);
			PhotonNetwork.CurrentRoom.SetCustomProperties(roomCustomProperty);
			pView.RPC("RPC_PanjungEvent", RpcTarget.All, winNum, num);
		}

		public override void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
			if (!propertiesThatChanged.ContainsKey("1st Player Score") || !propertiesThatChanged.ContainsKey("2nd Player Score") || !propertiesThatChanged.ContainsKey("1st Player SetScore") || !propertiesThatChanged.ContainsKey("2nd Player SetScore") || !propertiesThatChanged.ContainsKey("winNum"))
			{
				return;
			}
			int num = (int)propertiesThatChanged["1st Player Score"];
			int num2 = (int)propertiesThatChanged["2nd Player Score"];
			int num3 = (int)propertiesThatChanged["1st Player SetScore"];
			int num4 = (int)propertiesThatChanged["2nd Player SetScore"];
			int num5 = (int)propertiesThatChanged["winNum"];
			roomCustomProperty["1st Player Score"] = num;
			roomCustomProperty["2nd Player Score"] = num2;
			roomCustomProperty["1st Player SetScore"] = num3;
			roomCustomProperty["2nd Player SetScore"] = num4;
			switch (num5)
			{
			case 2:
				WorldUICtrl.instance.PanjungSound("fault");
				ScorePlaneCtrl.instance.SetScore(num, num2);
				SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetPointScore(num, num2);
				break;
			default:
				ScorePlaneCtrl.instance.SetScore(num, num2);
				SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetPointScore(num, num2);
				if (GameManager.instance.serveTurn == ServeTurn.my && PhotonNetwork.IsMasterClient)
				{
					WorldUICtrl.instance.CallScore(num, num2, num5 == 3 || num5 == 4);
				}
				else if (GameManager.instance.serveTurn == ServeTurn.other && !PhotonNetwork.IsMasterClient)
				{
					WorldUICtrl.instance.CallScore(num, num2, num5 == 3 || num5 == 4);
				}
				else if (GameManager.instance.serveTurn == ServeTurn.my && !PhotonNetwork.IsMasterClient)
				{
					WorldUICtrl.instance.CallScore(num2, num, num5 == 3 || num5 == 4);
				}
				else if (GameManager.instance.serveTurn == ServeTurn.other && PhotonNetwork.IsMasterClient)
				{
					WorldUICtrl.instance.CallScore(num2, num, num5 == 3 || num5 == 4);
				}
				UnityEngine.Debug.Log("winNum : " + num5);
				break;
			case -1:
				break;
			}
			SingletonBase.Singleton<LEDScoreBoard_SGT>.GetInstance.SetGameScore(num3, num4);
			GameManager.instance.MyScore = num;
			GameManager.instance.OtherScore = num2;
			GameManager.instance.MySetScore = num3;
			GameManager.instance.OtherSetScore = num4;
			ADBanner.instance.ChangeAD();
		}

		[PunRPC]
		private void RPC_PanjungEvent(int winNum, int resumeIndex, PhotonMessageInfo info)
		{
			GameManager.instance.ReceivePanjung(winNum == 2);
			StartCoroutine(GameResume(resumeIndex));
			if (info.Sender.IsMasterClient)
			{
				RefreeManager.instance.Play(winNum);
			}
			else
			{
				RefreeManager.instance.Play((winNum + 1) % 2);
			}
		}

		private IEnumerator GameResume(int _resumeIndex)
		{
			if (_resumeIndex != 0 && _resumeIndex != 3)
			{
				WorldUICtrl.instance.PanjungSound("game");
			}
			yield return new WaitForSeconds(3f);
			BallPhysics.instance.isCloseOut = false;
			if (_resumeIndex == 3)
			{
				int winnerPlayer = ((GameManager.instance.JansuCount != 2) ? ((!PhotonNetwork.IsMasterClient) ? 1 : 0) : (PhotonNetwork.IsMasterClient ? 1 : 0));
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					roomCustomProperty["1st Player SetScore"].ToString(),
					roomCustomProperty["2nd Player SetScore"].ToString()
				}, winnerPlayer);
			}
			else if (_resumeIndex != 2)
			{
				if (_resumeIndex == 1)
				{
					GameManager.instance.serveTurn = ((GameManager.instance.serveTurn == ServeTurn.my) ? ServeTurn.other : ServeTurn.my);
					GameManager.instance.isMyServeBall = GameManager.instance.serveTurn == ServeTurn.my;
					GameManager.instance.isOtherServeBall = GameManager.instance.serveTurn == ServeTurn.other;
				}
				GameManager.instance.ReceiveGameResume(_resumeIndex);
			}
			else
			{
				int winnerPlayer2 = (((int)roomCustomProperty["1st Player SetScore"] <= (int)roomCustomProperty["2nd Player SetScore"]) ? 1 : 0);
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					roomCustomProperty["1st Player SetScore"].ToString(),
					roomCustomProperty["2nd Player SetScore"].ToString()
				}, winnerPlayer2);
			}
		}

		private void ChangeHandStart(bool isRight)
		{
			pView.RPC("RPC_ChangeHand", RpcTarget.Others, isRight);
		}

		private void ChangeHand(bool isRight)
		{
			if (pView == null)
			{
				pView = GetComponent<PhotonView>();
			}
			pView.RPC("RPC_ChangeHand", RpcTarget.Others, isRight);
		}

		[PunRPC]
		private void RPC_ChangeHand(bool isRight)
		{
			RPCManager.OtherPlayerChangeHandEvent?.Invoke(isRight);
		}

		private void OtherPlayerLeft(Player player)
		{
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}

		private void ResetBall(Vector3 ballPos)
		{
			if (GameManager.instance.serveTurn == ServeTurn.my)
			{
				pView.RPC("RPC_ResetBall", RpcTarget.Others, ballPos);
			}
		}

		[PunRPC]
		private void RPC_ResetBall(Vector3 ballPos)
		{
			UnityEngine.Debug.Log("RPCResetBall : " + ballPos);
			BallBehaviour.instance.ReceiveResetball(ballPos);
			WorldUICtrl.instance.SetPositionBallViewer(ballPos);
		}
	}
	public class RefreeManager : MonoBehaviour
	{
		public static RefreeManager instance;

		private Animator anim;

		private LookAtIK lookAtIK;

		private Coroutine lookAtIKCoroutine;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
			anim = GetComponent<Animator>();
			GetComponent<CustomModelSettingCtrl>().InitRandom(CustomModelViewState.Normal, null, 0.1f);
			lookAtIK = GetComponent<LookAtIK>();
			SetlookAtIK(isAdd: true);
		}

		public void Play(int state)
		{
			switch (state)
			{
			case 0:
				anim.SetTrigger("Let_R");
				break;
			case 1:
				anim.SetTrigger("Let_L");
				break;
			}
		}

		private void SetlookAtIK(bool isAdd, float speed = 0.01f)
		{
			if (lookAtIKCoroutine != null)
			{
				StopCoroutine(lookAtIKCoroutine);
			}
			lookAtIKCoroutine = (isAdd ? StartCoroutine(IEnum_lookAtIkAddWeight(speed)) : StartCoroutine(IEnum_lookAtIkRevertWeight(speed)));
		}

		private IEnumerator IEnum_lookAtIkRevertWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight -= fadeSpeed;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					lookAtIK.solver.headWeight = 0f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}

		private IEnumerator IEnum_lookAtIkAddWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight += fadeSpeed;
				if ((double)lookAtIK.solver.headWeight >= 0.7)
				{
					lookAtIK.solver.headWeight = 0.7f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight >= 0.7f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}
	}
	public class ScorePlaneCtrl : MonoBehaviour
	{
		public static ScorePlaneCtrl instance;

		private Animator anim;

		public Text[] playerName;

		public Image[] image;

		public Sprite[] numSprite;

		private int minPoint;

		public GameObject DeuceText;

		public bool isDeuce = true;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			anim = GetComponent<Animator>();
		}

		public void ShowDeuceText(bool onoff)
		{
			DeuceText.SetActive(onoff);
		}

		public void SetData(string p1, string p2, int m_minPoint)
		{
			if (p1 == null)
			{
				p1 = "Player";
			}
			playerName[0].text = p1;
			playerName[1].text = p2;
			minPoint = m_minPoint;
			SetScore(0, 0);
		}

		public void SetScore(int p01, int p02)
		{
			isDeuce = false;
			if (p01 >= minPoint - 1 && p02 >= minPoint - 1)
			{
				isDeuce = true;
				if (p01 == p02 + 1)
				{
					image[0].gameObject.SetActive(value: true);
					image[1].gameObject.SetActive(value: true);
					image[2].gameObject.SetActive(value: false);
					image[3].gameObject.SetActive(value: false);
					image[0].sprite = numSprite[10];
					image[1].sprite = numSprite[11];
					anim.SetTrigger("Start");
					ShowDeuceText(onoff: false);
					return;
				}
				if (p01 + 1 == p02)
				{
					image[0].gameObject.SetActive(value: false);
					image[1].gameObject.SetActive(value: false);
					image[2].gameObject.SetActive(value: true);
					image[3].gameObject.SetActive(value: true);
					image[2].sprite = numSprite[10];
					image[3].sprite = numSprite[11];
					anim.SetTrigger("Start");
					ShowDeuceText(onoff: false);
					return;
				}
				if (p01 == p02)
				{
					ShowDeuceText(onoff: true);
				}
			}
			p01 = p01 switch
			{
				0 => 0, 
				1 => 15, 
				2 => 30, 
				3 => 40, 
				_ => 40, 
			};
			p02 = p02 switch
			{
				0 => 0, 
				1 => 15, 
				2 => 30, 
				3 => 40, 
				_ => 40, 
			};
			if (p01 > 9)
			{
				image[0].gameObject.SetActive(value: true);
				image[1].gameObject.SetActive(value: true);
				image[0].sprite = numSprite[p01 / 10];
				image[1].sprite = numSprite[p01 % 10];
			}
			else
			{
				image[0].gameObject.SetActive(value: false);
				image[1].gameObject.SetActive(value: true);
				image[1].sprite = numSprite[p01];
			}
			if (p02 > 9)
			{
				image[2].gameObject.SetActive(value: true);
				image[3].gameObject.SetActive(value: true);
				image[2].sprite = numSprite[p02 / 10];
				image[3].sprite = numSprite[p02 % 10];
			}
			else
			{
				image[2].gameObject.SetActive(value: false);
				image[3].gameObject.SetActive(value: true);
				image[3].sprite = numSprite[p02];
			}
			anim.SetTrigger("Start");
		}

		public void CloseScoreBoard()
		{
			anim.SetTrigger("End");
		}
	}
	public class ServeBallViewer : MonoBehaviour
	{
		private Vector3 destination;

		public Transform DummyBall;

		private Coroutine coroutine;

		private bool isMoving;

		public Transform TimeUI;

		public TextMesh TimeText;

		private void OnEnable()
		{
			PlayerBehaviour.ChangeHandEvent += PlayerBehaviour_ChangeHandEvent;
			if (GameManager.instance != null)
			{
				TimeText.text = GameManager.instance.ShootTimeLimit.ToString();
			}
		}

		private void OnDisable()
		{
			PlayerBehaviour.ChangeHandEvent -= PlayerBehaviour_ChangeHandEvent;
		}

		private void PlayerBehaviour_ChangeHandEvent(bool isRight)
		{
			if (base.gameObject.activeSelf && !isMoving && GameManager.instance.serveTurn == ServeTurn.my)
			{
				base.transform.position = destination;
			}
		}

		public void ViewOnOff(bool isOn, Vector3 pos)
		{
			base.gameObject.SetActive(isOn);
			if (isOn)
			{
				if (coroutine == null)
				{
					coroutine = StartCoroutine(IEnum_SetBallPos());
				}
				else
				{
					StopCoroutine(coroutine);
					coroutine = StartCoroutine(IEnum_SetBallPos());
				}
			}
			destination = pos;
		}

		private IEnumerator IEnum_SetBallPos()
		{
			isMoving = true;
			UnityEngine.Debug.Log("11");
			BallBehaviour.instance.gameObject.SetActive(value: false);
			DummyBall.gameObject.SetActive(value: true);
			Vector3 vector = PlayerBehaviour.instance.HeadTR.root.position + PlayerBehaviour.instance.HeadTR.root.forward * 3f;
			Vector3 raisePos = vector;
			raisePos.y = 1.5f;
			base.transform.position = vector;
			float dis2 = 1000f;
			while (dis2 > 0.05f)
			{
				dis2 = Vector3.Distance(base.transform.position, raisePos);
				base.transform.position = Vector3.Lerp(base.transform.position, raisePos, Time.deltaTime * 3f);
				yield return null;
			}
			float dot = 0f;
			DummyBall.gameObject.SetActive(value: false);
			BallBehaviour.instance.transform.parent = base.transform;
			BallBehaviour.instance.transform.localPosition = Vector3.zero;
			BallBehaviour.instance.gameObject.SetActive(value: true);
			BallBehaviour.instance.transform.GetComponent<SphereCollider>().enabled = false;
			while (dot < 0.9f)
			{
				Vector3 forward = PlayerBehaviour.instance.HeadTR.forward;
				Vector3 normalized = (base.transform.position - PlayerBehaviour.instance.HeadTR.position).normalized;
				dot = Vector3.Dot(forward, normalized);
				yield return null;
			}
			dis2 = 100f;
			while (dis2 > 0.01f)
			{
				dis2 = Vector3.Distance(base.transform.position, destination);
				base.transform.position = Vector3.Lerp(base.transform.position, destination, Time.deltaTime * 6f);
				yield return null;
			}
			BallBehaviour.instance.transform.parent = null;
			BallBehaviour.instance.transform.GetComponent<SphereCollider>().enabled = true;
			isMoving = false;
			coroutine = null;
		}

		private void Update()
		{
			Vector3 normalized = (PlayerBehaviour.instance.HeadTR.position - TimeUI.position).normalized;
			TimeUI.rotation = Quaternion.LookRotation(normalized);
		}
	}
	[Serializable]
	public class VoiceClip
	{
		public string kategorie;

		public AudioClip[] english;

		public AudioClip[] chinese;
	}
	[Serializable]
	public class SoundClip
	{
		public string kategorie;

		public AudioClip[] clips;
	}
	public class SoundManager : MonoBehaviour
	{
		public static SoundManager instance;

		public List<VoiceClip> VoiceList = new List<VoiceClip>();

		public List<SoundClip> SoundList = new List<SoundClip>();

		private LanguageState languageState;

		private void Awake()
		{
			UnityEngine.Debug.Log("instance");
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public AudioClip GetSoundClip(string name)
		{
			int num = SoundList.FindIndex((SoundClip x) => x.kategorie == name);
			if (num == -1)
			{
				UnityEngine.Debug.LogError("찾는 사운드 클립이 없습니다!");
				return null;
			}
			AudioClip[] clips = SoundList[num].clips;
			int num2 = UnityEngine.Random.Range(0, clips.Length);
			return clips[num2];
		}

		public AudioClip GetSoundClip(string name, int index)
		{
			return SoundList.Find((SoundClip x) => x.kategorie == name).clips[index];
		}

		public AudioClip GetVoiceClip(string name)
		{
			languageState = PublicGameUIManager.gameSetting.GetLanguageState();
			AudioClip[] array = ((languageState == LanguageState.schinese) ? VoiceList.Find((VoiceClip x) => x.kategorie == name).chinese : VoiceList.Find((VoiceClip x) => x.kategorie == name).english);
			if (array == null)
			{
				UnityEngine.Debug.LogError("찾는 사운드 클립이 없습니다!");
				return null;
			}
			int num = UnityEngine.Random.Range(0, array.Length);
			return array[num];
		}

		public AudioClip GetVoiceClip(string name, int index)
		{
			languageState = PublicGameUIManager.gameSetting.GetLanguageState();
			AudioClip[] obj = ((languageState == LanguageState.schinese) ? VoiceList.Find((VoiceClip x) => x.kategorie == name).chinese : VoiceList.Find((VoiceClip x) => x.kategorie == name).english);
			UnityEngine.Debug.Log(obj[index]);
			return obj[index];
		}

		public AudioClip GetVoiceClip(string name, string clipName)
		{
			languageState = PublicGameUIManager.gameSetting.GetLanguageState();
			AudioClip[] array = ((languageState == LanguageState.schinese) ? VoiceList.Find((VoiceClip x) => x.kategorie.Contains(name)).chinese : VoiceList.Find((VoiceClip x) => x.kategorie.Contains(name)).english);
			AudioClip result = null;
			for (int i = 0; i < array.Length; i++)
			{
				if (clipName == array[i].name)
				{
					result = array[i];
				}
			}
			return result;
		}
	}
	public class SpinParticle : MonoBehaviour
	{
		private ParticleSystem ps;

		private ParticleSystem.MainModule psMM;

		private Material psMat;

		public Color topSpinColor;

		public Color backSpinColor;

		private RotationConstraint rotationConstraint;

		private void Start()
		{
			ps = GetComponent<ParticleSystem>();
			psMM = ps.main;
			psMat = GetComponent<ParticleSystemRenderer>().material;
			rotationConstraint = GetComponent<RotationConstraint>();
		}

		public void StopParticle()
		{
			ps.Stop();
			psMM.startSize = new ParticleSystem.MinMaxCurve(0f, 0f);
		}

		public void SetParticle(float size, bool isTopSpin)
		{
			if (size > 1.5f)
			{
				size = 1.5f;
			}
			psMM.startSize = new ParticleSystem.MinMaxCurve(0f, size);
			psMat.SetColor("_TintColor", isTopSpin ? topSpinColor : backSpinColor);
			if (GameManager.instance.isOnPanjung)
			{
				psMM.startSize = new ParticleSystem.MinMaxCurve(0f, 0f);
				ps.Stop();
			}
			else
			{
				ps.Play();
			}
		}

		public void SetRotation(Vector3 Euler)
		{
			rotationConstraint.rotationOffset = Euler;
		}
	}
	public class WorldUICtrl : MonoBehaviour
	{
		public static WorldUICtrl instance;

		private CanvasGroup HowToPlayCG;

		private Animator otherAnim;

		private AudioSource Audio;

		[HideInInspector]
		public ServeBallViewer serveBallViewer;

		private Vector3 startPos;

		[HideInInspector]
		public bool isDeuce;

		private Coroutine AIUICoroutine;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			Audio = GetComponent<AudioSource>();
			HowToPlayCG = base.transform.Find("HowToPlay").GetComponent<CanvasGroup>();
			otherAnim = base.transform.Find("TurnArrowRoot/TurnArrow").GetComponent<Animator>();
			serveBallViewer = base.transform.Find("CatchBallCtrl").GetComponent<ServeBallViewer>();
		}

		private void OnEnable()
		{
			GameManager.GameStartEvent += OnHowToPlay;
			Cfollower.HitBallEvent += OffHowToPlay;
			Cfollower.HitBallEvent += CloseServeTurn;
			PlayerBehaviour.ResetBallEvent += OpenServeTurn;
		}

		private void OnDisable()
		{
			GameManager.GameStartEvent -= OnHowToPlay;
			Cfollower.HitBallEvent -= OffHowToPlay;
			Cfollower.HitBallEvent -= CloseServeTurn;
			PlayerBehaviour.ResetBallEvent -= OpenServeTurn;
		}

		private void Start()
		{
			startPos = base.transform.position;
		}

		private void OnHowToPlay()
		{
			if (GameManager.instance.serveTurn == ServeTurn.my)
			{
				StartCoroutine(IEnum_FadeCG());
			}
		}

		private void OffHowToPlay(bool isSmash, Vector3 cPoint)
		{
			HowToPlayCG.gameObject.SetActive(value: false);
		}

		public void OffHowToPlay()
		{
			HowToPlayCG.gameObject.SetActive(value: false);
		}

		private IEnumerator IEnum_FadeCG(float fadeSpeed = 0.02f)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				HowToPlayCG.alpha += fadeSpeed;
				yield return null;
				if (HowToPlayCG.alpha >= 1f)
				{
					HowToPlayCG.gameObject.SetActive(value: true);
					break;
				}
			}
		}

		public void SetServeAudioClip(ServeTurn serveTurn)
		{
			AudioClip audioClip = null;
			if (serveTurn == ServeTurn.my)
			{
				int num = 0;
				num = ((GameManager.instance.faultCount != 1) ? UnityEngine.Random.Range(0, 2) : UnityEngine.Random.Range(2, 4));
				audioClip = SoundManager.instance.GetVoiceClip("serve", num);
				Audio.PlayOneShot(audioClip);
			}
			UnityEngine.Debug.Log("1");
		}

		public void OpenServeTurn(Vector3 pos)
		{
			if (GameManager.instance.serveTurn == ServeTurn.my)
			{
				if (AIUICoroutine != null)
				{
					StopCoroutine(AIUICoroutine);
					AIUICoroutine = null;
				}
				serveBallViewer.ViewOnOff(isOn: true, pos);
				otherAnim.gameObject.SetActive(value: false);
				otherAnim.SetTrigger("Stop");
				base.transform.localPosition = Vector3.zero;
			}
			else
			{
				otherAnim.gameObject.SetActive(value: true);
				otherAnim.SetTrigger("Play");
				if (AIUICoroutine != null)
				{
					StopCoroutine(AIUICoroutine);
					AIUICoroutine = StartCoroutine(IEnum_SetAIServeUIPos());
				}
				else
				{
					AIUICoroutine = StartCoroutine(IEnum_SetAIServeUIPos());
				}
			}
		}

		public void CloseServeTurn(bool isSmash, Vector3 cPoint)
		{
			if (GameManager.instance.serveTurn == ServeTurn.other)
			{
				otherAnim.SetTrigger("Stop");
				if (AIUICoroutine != null)
				{
					StopCoroutine(AIUICoroutine);
					AIUICoroutine = null;
				}
				base.transform.localPosition = Vector3.zero;
			}
			serveBallViewer.ViewOnOff(isOn: false, Vector3.zero);
		}

		public void SetTimeLimit(float timeValue)
		{
			float shootTimeLimit = GameManager.instance.ShootTimeLimit;
			string text = "";
			if (!(shootTimeLimit * 0.3f > timeValue))
			{
				text = ((!(shootTimeLimit * 0.6f > timeValue)) ? ("<color=white>" + timeValue.ToString("0") + "</color>") : ("<color=yellow>" + timeValue.ToString("0") + "</color>"));
			}
			else
			{
				text = "<color=red>" + timeValue.ToString("0") + "</color>";
				PlayTimeTick();
			}
			serveBallViewer.TimeText.text = text;
		}

		private void PlayTimeTick()
		{
			AudioSource component = serveBallViewer.TimeUI.GetComponent<AudioSource>();
			if (!component.isPlaying)
			{
				component.Play();
			}
		}

		public void StopClockTick()
		{
			serveBallViewer.TimeUI.GetComponent<AudioSource>().Stop();
		}

		private IEnumerator IEnum_SetAIServeUIPos()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				Transform targetTR = UnityEngine.Object.FindObjectOfType<AIBehaviour>().transform;
				while (GameManager.instance.serveTurn == ServeTurn.other)
				{
					Vector3 position = base.transform.position;
					position.z = targetTR.position.z;
					position.x = targetTR.position.x;
					base.transform.position = position;
					yield return null;
				}
			}
			else
			{
				Transform transform = GameObject.Find("PlayerServePos").transform;
				Transform targetTR = ((GameManager.instance.serveCount == 0) ? transform.GetChild(0) : transform.GetChild(1));
				Vector3 position2 = targetTR.position;
				position2.x *= -1f;
				position2.z *= -1f;
				base.transform.position = position2;
				serveBallViewer.gameObject.SetActive(value: true);
				serveBallViewer.DummyBall.gameObject.SetActive(value: true);
				serveBallViewer.transform.position = BallBehaviour.instance.transform.position;
			}
		}

		public void SetPositionBallViewer(Vector3 pos)
		{
			serveBallViewer.gameObject.SetActive(value: true);
			serveBallViewer.transform.position = pos;
		}

		private string GetScoreToString(int score)
		{
			string text = null;
			return score switch
			{
				0 => "love", 
				1 => "fifteen", 
				2 => "thirty", 
				3 => "forty", 
				_ => "forty", 
			};
		}

		public void CallScore(int score1, int score2, bool isJamsu = false)
		{
			if (score1 == 0 && score2 == 0)
			{
				return;
			}
			List<AudioClip> list = new List<AudioClip>();
			AudioClip audioClip = null;
			string scoreToString = GetScoreToString(score1);
			string scoreToString2 = GetScoreToString(score2);
			if (BallPhysics.instance.isCloseOut)
			{
				audioClip = SoundManager.instance.GetVoiceClip("out");
				list.Add(audioClip);
			}
			if (isJamsu)
			{
				audioClip = SoundManager.instance.GetVoiceClip("timeOut");
				list.Add(audioClip);
			}
			if (score1 >= GameManager.instance.MaxPoint - 1 && score2 >= GameManager.instance.MaxPoint - 1)
			{
				isDeuce = true;
				if (score1 == score2 + 1)
				{
					audioClip = SoundManager.instance.GetVoiceClip("adventage");
					list.Add(audioClip);
				}
				else if (score1 + 1 == score2)
				{
					audioClip = SoundManager.instance.GetVoiceClip("adventage");
					list.Add(audioClip);
				}
				else if (score1 == score2)
				{
					audioClip = SoundManager.instance.GetVoiceClip("deuce");
					list.Add(audioClip);
				}
			}
			else
			{
				if (score1 > 3 || score2 > 3)
				{
					return;
				}
				if (score1 == score2)
				{
					audioClip = SoundManager.instance.GetVoiceClip(scoreToString);
					list.Add(audioClip);
					audioClip = SoundManager.instance.GetVoiceClip("all");
					list.Add(audioClip);
				}
				else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
				{
					if (GameManager.instance.serveTurn == ServeTurn.my)
					{
						audioClip = SoundManager.instance.GetVoiceClip(scoreToString);
						list.Add(audioClip);
						audioClip = SoundManager.instance.GetVoiceClip(scoreToString2);
						list.Add(audioClip);
					}
					else if (GameManager.instance.serveTurn == ServeTurn.other)
					{
						audioClip = SoundManager.instance.GetVoiceClip(scoreToString2);
						list.Add(audioClip);
						audioClip = SoundManager.instance.GetVoiceClip(scoreToString);
						list.Add(audioClip);
					}
				}
				else
				{
					audioClip = SoundManager.instance.GetVoiceClip(scoreToString);
					list.Add(audioClip);
					audioClip = SoundManager.instance.GetVoiceClip(scoreToString2);
					list.Add(audioClip);
				}
			}
			StartCoroutine(IEnum_CallScore(list));
		}

		public void PanjungSound(string keyword)
		{
			AudioClip voiceClip = SoundManager.instance.GetVoiceClip(keyword);
			Audio.PlayOneShot(voiceClip);
		}

		private IEnumerator IEnum_CallScore(List<AudioClip> clips)
		{
			while (Audio.isPlaying)
			{
				yield return null;
			}
			for (int i = 0; i < clips.Count; i++)
			{
				if (clips.Count == 2)
				{
					Audio.PlayOneShot(clips[i]);
					yield return new WaitForSeconds(1.05f);
					continue;
				}
				Audio.PlayOneShot(clips[i]);
				if (i == 0)
				{
					yield return new WaitForSeconds(1.2f);
				}
				else
				{
					yield return new WaitForSeconds(1.05f);
				}
			}
		}
	}
}
namespace PINGPONG
{
	public class WorldUICtrl : MonoBehaviour
	{
		public static WorldUICtrl instance;

		private CanvasGroup HowToPlayCG;

		private Animator otherAnim;

		private AudioSource Audio;

		[HideInInspector]
		public ServeBallViewer serveBallViewer;

		private Vector3 startPos;

		[HideInInspector]
		public bool isDeuce;

		private Coroutine AIUICoroutine;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			GameManager.GameStartEvent += OnHowToPlay;
			cFollower.hitBallEvent += OffHowToPlay;
		}

		private void OnDisable()
		{
			GameManager.GameStartEvent -= OnHowToPlay;
			cFollower.hitBallEvent -= OffHowToPlay;
		}

		private void Start()
		{
			Audio = GetComponent<AudioSource>();
			HowToPlayCG = base.transform.Find("HowToPlay").GetComponent<CanvasGroup>();
			otherAnim = base.transform.Find("TurnArrow").GetComponent<Animator>();
			serveBallViewer = base.transform.Find("CatchBallCtrl").GetComponent<ServeBallViewer>();
			startPos = base.transform.position;
		}

		private void OnHowToPlay()
		{
			StartCoroutine(IEnum_FadeCG());
		}

		private void OffHowToPlay(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 angularVelocity)
		{
			HowToPlayCG.gameObject.SetActive(value: false);
		}

		public void OffHowToPlay()
		{
			HowToPlayCG.gameObject.SetActive(value: false);
		}

		private IEnumerator IEnum_FadeCG(float fadeSpeed = 0.02f)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				HowToPlayCG.alpha += fadeSpeed;
				yield return null;
				if (HowToPlayCG.alpha >= 1f)
				{
					HowToPlayCG.gameObject.SetActive(value: true);
					break;
				}
			}
		}

		public void SetServeAudioClip(ServeTurn serveTurn)
		{
			AudioClip audioClip = null;
			if (serveTurn == ServeTurn.my)
			{
				UnityEngine.Debug.Log(TENNIS.SoundManager.instance);
				UnityEngine.Debug.Log(TENNIS.SoundManager.instance.gameObject.name);
				audioClip = TENNIS.SoundManager.instance.GetVoiceClip("serve", 0);
				Audio.PlayOneShot(audioClip);
			}
		}

		public void OpenServeTurn(ServeTurn serve)
		{
			if (serve == ServeTurn.my)
			{
				serveBallViewer.ViewOnOff(isOn: true);
				if (AIUICoroutine != null)
				{
					StopCoroutine(AIUICoroutine);
					AIUICoroutine = null;
				}
			}
			else
			{
				otherAnim.SetTrigger("Play");
				if (AIUICoroutine != null)
				{
					StopCoroutine(AIUICoroutine);
					AIUICoroutine = StartCoroutine(IEnum_SetAIServeUIPos());
				}
				else
				{
					AIUICoroutine = StartCoroutine(IEnum_SetAIServeUIPos());
				}
			}
		}

		public void CloseServeTurn(ServeTurn serve)
		{
			if (serve == ServeTurn.my)
			{
				serveBallViewer.ViewOnOff(isOn: false);
				return;
			}
			otherAnim.SetTrigger("Stop");
			if (AIUICoroutine != null)
			{
				StopCoroutine(AIUICoroutine);
				AIUICoroutine = null;
			}
			base.transform.position = startPos;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				serveBallViewer.gameObject.SetActive(value: false);
			}
		}

		public void SetTimeLimit(float timeValue)
		{
			float shootTimeLimit = GameManager.instance.ShootTimeLimit;
			string text = "";
			if (!(shootTimeLimit * 0.3f > timeValue))
			{
				text = ((!(shootTimeLimit * 0.6f > timeValue)) ? ("<color=white>" + timeValue.ToString("0") + "</color>") : ("<color=yellow>" + timeValue.ToString("0") + "</color>"));
			}
			else
			{
				text = "<color=red>" + timeValue.ToString("0") + "</color>";
				PlayTimeTick();
			}
			serveBallViewer.TimeText.text = text;
		}

		private void PlayTimeTick()
		{
			AudioSource component = serveBallViewer.TimeUI.GetComponent<AudioSource>();
			if (!component.isPlaying)
			{
				component.Play();
			}
		}

		public void StopClockTick()
		{
			serveBallViewer.TimeUI.GetComponent<AudioSource>().Stop();
		}

		private IEnumerator IEnum_SetAIServeUIPos()
		{
			UnityEngine.Debug.Log("ServeUiPois");
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				AIBehaviour ai = UnityEngine.Object.FindObjectOfType<AIBehaviour>();
				while (true)
				{
					Vector3 position = base.transform.position;
					position.x = ai.transform.position.x;
					base.transform.position = position;
					yield return null;
				}
			}
			serveBallViewer.gameObject.SetActive(value: true);
			serveBallViewer.DummyBall.gameObject.SetActive(value: true);
			BallBehaviour.instance.thisMesh.enabled = false;
			serveBallViewer.TimeUI.gameObject.SetActive(value: false);
			while (true)
			{
				serveBallViewer.transform.position = Vector3.Lerp(serveBallViewer.transform.position, BallBehaviour.instance.transform.position, Time.deltaTime * 6f);
				yield return null;
			}
		}

		public void CallScore(int score1, int score2, bool isJamsu = false)
		{
			List<AudioClip> list = new List<AudioClip>();
			AudioClip audioClip = null;
			if (isJamsu)
			{
				audioClip = TENNIS.SoundManager.instance.GetVoiceClip("score", "time_out_01");
				list.Add(audioClip);
			}
			if (score1 >= GameManager.instance.MaxPoint - 1 && score2 >= GameManager.instance.MaxPoint - 1)
			{
				isDeuce = true;
				if (score1 == score2 + 1)
				{
					audioClip = TENNIS.SoundManager.instance.GetVoiceClip("score", "Advantage");
					list.Add(audioClip);
				}
				else if (score1 + 1 == score2)
				{
					audioClip = TENNIS.SoundManager.instance.GetVoiceClip("score", "Advantage");
					list.Add(audioClip);
				}
				else if (score1 == score2)
				{
					audioClip = TENNIS.SoundManager.instance.GetVoiceClip("score", "Deuce");
					list.Add(audioClip);
				}
			}
			else
			{
				if (score1 > 10 || score2 > 10)
				{
					return;
				}
				audioClip = TENNIS.SoundManager.instance.GetVoiceClip("score", score1);
				list.Add(audioClip);
				audioClip = TENNIS.SoundManager.instance.GetVoiceClip("score", score2);
				list.Add(audioClip);
			}
			StartCoroutine(IEnum_CallScore(list));
		}

		public void LetSound()
		{
			AudioClip voiceClip = TENNIS.SoundManager.instance.GetVoiceClip("score", "Let");
			Audio.PlayOneShot(voiceClip);
		}

		private IEnumerator IEnum_CallScore(List<AudioClip> clips)
		{
			for (int i = 0; i < clips.Count; i++)
			{
				Audio.PlayOneShot(clips[i]);
				yield return new WaitForSeconds(1f);
			}
		}
	}
	public class ScorePlaneCtrl : MonoBehaviour
	{
		public static ScorePlaneCtrl instance;

		private Animator anim;

		public Text[] playerName;

		public Image[] image;

		public Sprite[] numSprite;

		private int minPoint;

		public GameObject DeuceText;

		public bool isDeuce = true;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			anim = GetComponent<Animator>();
		}

		public void ShowDeuceText(bool onoff)
		{
			DeuceText.SetActive(onoff);
		}

		public void SetData(string p1, string p2, int m_minPoint)
		{
			if (p1 == null)
			{
				p1 = "Player";
			}
			playerName[0].text = p1;
			playerName[1].text = p2;
			minPoint = m_minPoint;
			SetScore(0, 0);
		}

		public void SetScore(int p01, int p02)
		{
			isDeuce = false;
			if (p01 >= minPoint - 1 && p02 >= minPoint - 1)
			{
				isDeuce = true;
				if (p01 == p02 + 1)
				{
					image[0].gameObject.SetActive(value: true);
					image[1].gameObject.SetActive(value: true);
					image[2].gameObject.SetActive(value: false);
					image[3].gameObject.SetActive(value: false);
					image[0].sprite = numSprite[10];
					image[1].sprite = numSprite[11];
					anim.SetTrigger("Start");
					ShowDeuceText(onoff: false);
					return;
				}
				if (p01 + 1 == p02)
				{
					image[0].gameObject.SetActive(value: false);
					image[1].gameObject.SetActive(value: false);
					image[2].gameObject.SetActive(value: true);
					image[3].gameObject.SetActive(value: true);
					image[2].sprite = numSprite[10];
					image[3].sprite = numSprite[11];
					anim.SetTrigger("Start");
					ShowDeuceText(onoff: false);
					return;
				}
				if (p01 == p02)
				{
					ShowDeuceText(onoff: true);
				}
			}
			if (p01 > 9)
			{
				image[0].gameObject.SetActive(value: true);
				image[1].gameObject.SetActive(value: true);
				image[0].sprite = numSprite[p01 / 10];
				image[1].sprite = numSprite[p01 % 10];
			}
			else
			{
				image[0].gameObject.SetActive(value: false);
				image[1].gameObject.SetActive(value: true);
				image[1].sprite = numSprite[p01];
			}
			if (p02 > 9)
			{
				image[2].gameObject.SetActive(value: true);
				image[3].gameObject.SetActive(value: true);
				image[2].sprite = numSprite[p02 / 10];
				image[3].sprite = numSprite[p02 % 10];
			}
			else
			{
				image[2].gameObject.SetActive(value: false);
				image[3].gameObject.SetActive(value: true);
				image[3].sprite = numSprite[p02];
			}
			anim.SetTrigger("Start");
		}

		public void CloseScoreBoard()
		{
			anim.SetTrigger("End");
		}
	}
	public class ADBanner : MonoBehaviour
	{
		public static ADBanner instance;

		private MeshRenderer meshRenderer;

		private Coroutine c;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnDisable()
		{
			meshRenderer.sharedMaterials[1].SetTextureOffset("_BaseMap", Vector2.zero);
		}

		private void Start()
		{
			meshRenderer = GetComponent<MeshRenderer>();
		}

		public void ChangeAD()
		{
			if (c == null)
			{
				c = StartCoroutine(IEnum_ChangeAD());
			}
		}

		private IEnumerator IEnum_ChangeAD()
		{
			Vector2 OffSet2 = meshRenderer.sharedMaterials[1].GetTextureOffset("_BaseMap");
			float startY = OffSet2.y;
			float gole = OffSet2.y + 0.125f;
			_ = gole;
			while (OffSet2.y < gole)
			{
				OffSet2.y += Time.deltaTime * 0.05f;
				meshRenderer.sharedMaterials[1].SetTextureOffset("_BaseMap", OffSet2);
				yield return null;
			}
			OffSet2 = new Vector2(0f, startY + 0.125f);
			meshRenderer.sharedMaterials[1].SetTextureOffset("_BaseMap", OffSet2);
			c = null;
		}
	}
	[Serializable]
	public class SwingMotionInfo
	{
		public string motionName;

		public float impactTime;

		public bool isFront;

		public bool isForhand;

		public float posX;

		public float posZ;
	}
	public struct BestPointAndTime
	{
		public Vector3 point;

		public float time;

		public bool isSafe;

		public bool frontHit;

		public bool isEdge;
	}
	[Serializable]
	public class ServeAnimInfo
	{
		public float getBallFrame;

		public float raiseBallFrame;

		public float hitBallFrame;

		public float raiseBallvelocityY;

		public Vector3 serveVelocity;

		public Vector3 AIServePos;

		public string animName;
	}
	public class AIBehaviour : MonoBehaviour
	{
		public delegate void test();

		public delegate void HitBall(bool isServe, bool isSmash);

		public static BestPointAndTime bestPointAndTime;

		private Vector3 destination = Vector3.zero;

		private Vector2 smoothDeltaPosition = Vector2.zero;

		private Vector2 velocity = Vector2.zero;

		private Animator anim;

		private bool MoveStop;

		private bool isMoving;

		private LookAtIK lookAtIK;

		public Transform LeftHandTR;

		public Transform RightHandTR;

		public List<SwingMotionInfo> ListSwingMotionInfo = new List<SwingMotionInfo>();

		private SwingMotionInfo currentSwingMotionInfo;

		private ServeAnimInfo serveAnimInfo;

		public List<ServeAnimInfo> serveInfoList;

		private bool isPlayerSmash;

		private bool isSmashMove;

		private float animDelay;

		private Coroutine lookAtIKCoroutine;

		public static event test testEvent;

		public static event HitBall HitBallEvent;

		private void OnEnable()
		{
			cFollower.hitBallEvent += PlayerHitBall;
			GameManager.GameResumeEvent += GameResume;
			GameManager.GameStartEvent += GameResume;
			GameManager.ReactionEvent += ReAction;
		}

		private void OnDisable()
		{
			cFollower.hitBallEvent -= PlayerHitBall;
			GameManager.GameResumeEvent -= GameResume;
			GameManager.GameStartEvent -= GameResume;
			GameManager.ReactionEvent -= ReAction;
		}

		private void Awake()
		{
			initData();
		}

		private void initData()
		{
			anim = GetComponent<Animator>();
			lookAtIK = GetComponent<LookAtIK>();
			lookAtIK.solver.target = BallBehaviour.instance.transform;
		}

		private void PlayerHitBall(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 angularVelocity)
		{
			MoveStop = false;
			if (!GameManager.instance.isOnPanjung)
			{
				getBestPoint(isServe);
				isPlayerSmash = isSmash;
			}
		}

		private void GameResume()
		{
			if (GameManager.instance.serveTurn == ServeTurn.other)
			{
				AIServe();
				return;
			}
			if (Vector3.Distance(base.transform.position, base.transform.root.position) > 3f)
			{
				MoveStop = true;
				base.transform.position = base.transform.root.position;
			}
			else
			{
				MoveStop = false;
				destination = base.transform.root.position;
			}
			SetlookAtIK(isAdd: true);
		}

		private void AIServe()
		{
			StartCoroutine(IEnum_AIServe());
		}

		private IEnumerator IEnum_AIServe()
		{
			int index = UnityEngine.Random.Range(0, 2);
			serveAnimInfo = serveInfoList[index];
			if (Vector3.Distance(base.transform.position, serveAnimInfo.AIServePos) > 3f)
			{
				MoveStop = true;
				base.transform.position = serveAnimInfo.AIServePos;
			}
			else
			{
				MoveStop = false;
				destination = serveAnimInfo.AIServePos;
			}
			SetlookAtIK(isAdd: false);
			while (isMoving)
			{
				yield return null;
			}
			yield return new WaitForSeconds(1.5f);
			BallBehaviour.instance.SetTrigger(useTrigger: true);
			PlayAnim(serveAnimInfo.animName);
			GetBall();
			float timeChecher3 = 0f;
			float GetBallFrame = UnityEngine.Random.Range(2f, 3f);
			float raiseBallFrame = serveAnimInfo.raiseBallFrame;
			float HitBallFrame = serveAnimInfo.hitBallFrame - raiseBallFrame;
			while (GetBallFrame > timeChecher3)
			{
				BallBehaviour.instance.transform.localPosition = Vector3.zero;
				timeChecher3 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			PlayAnim(serveAnimInfo.animName + " Start");
			timeChecher3 = 0f;
			while (raiseBallFrame > timeChecher3)
			{
				timeChecher3 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			SetlookAtIK(isAdd: true);
			RaiseBall(serveAnimInfo.raiseBallvelocityY);
			timeChecher3 = 0f;
			while (HitBallFrame > timeChecher3)
			{
				timeChecher3 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			Vector3 serveVelocity = serveAnimInfo.serveVelocity;
			float scaler = (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 3.5f;
			serveVelocity = Preview_Ctrl.instance.getReviseAxisX(serveVelocity, scaler, BallBehaviour.instance.transform);
			HitServeBall(serveVelocity);
		}

		public void GetBall()
		{
			UnityEngine.Debug.Log("GetBall");
			BallBehaviour.instance.rigid.velocity = Vector3.zero;
			BallBehaviour.instance.ResetBall(LeftHandTR.position);
			BallBehaviour.instance.transform.parent = LeftHandTR;
		}

		public void RaiseBall(float veloY)
		{
			UnityEngine.Debug.Log("RaiseBall");
			BallBehaviour.instance.rigid.velocity = Vector3.zero;
			Vector3 play = new Vector3(0f, veloY, 0f);
			BallBehaviour.instance.SetPlay(play);
			BallBehaviour.instance.transform.parent = null;
		}

		public void HitServeBall(Vector3 velo)
		{
			BallBehaviour.instance.rigid.velocity = Vector3.zero;
			BallBehaviour.instance.SetAllStop();
			Preview_Ctrl.instance.PhysicsSimulator(BallBehaviour.instance.transform.position, velo, Vector3.zero, Vector3.zero, BallBehaviour.instance.transform, useAI: true);
			BallBehaviour.instance.SetParticle(BallBehaviour.instance.transform.position);
			GameManager.instance.SetOtherPlayerBallTarget();
			WorldUICtrl.instance.CloseServeTurn(GameManager.instance.serveTurn);
			AIBehaviour.HitBallEvent?.Invoke(isServe: true, isSmash: false);
			AIBehaviour.testEvent?.Invoke();
			GameManager.instance.isOnPanjung = false;
		}

		public void getBestPoint(bool isServe)
		{
			int num = ((!isServe) ? 1 : 2);
			List<BallPhyscisInfo> list = Preview_Ctrl.instance.listBallInfo.ToList();
			bestPointAndTime.isEdge = false;
			for (int num2 = list.Count - 1; num2 >= 0; num2--)
			{
				if (list[num2].bounceCount != num)
				{
					list.RemoveAt(num2);
				}
			}
			if (list.Count == 0)
			{
				return;
			}
			list.Sort(delegate(BallPhyscisInfo x, BallPhyscisInfo y)
			{
				int num4 = 0;
				if (x.position.y > y.position.y)
				{
					num4 = -1;
				}
				else if (x.position.y < y.position.y)
				{
					num4 = 1;
				}
				else if (x.position.y == y.position.y)
				{
					num4 = 0;
				}
				return (num4 != 0) ? num4 : Vector3.Distance(base.transform.position, x.position).CompareTo(Vector3.Distance(base.transform.position, y.position));
			});
			bestPointAndTime.point = list[0].position;
			bestPointAndTime.time = list[0].totalTime;
			if (!(bestPointAndTime.point.z > -0.3f))
			{
				int num3 = 0;
				if (bestPointAndTime.point.z < -2.5f)
				{
					num3 = getClosePointIndex(-3f, list, 1);
					bestPointAndTime.point = list[num3].position;
					bestPointAndTime.time = list[num3].totalTime;
				}
				if (bestPointAndTime.point.x > 1.5f)
				{
					num3 = getClosePointIndex(1.5f, list, 0);
					bestPointAndTime.point = list[num3].position;
					bestPointAndTime.time = list[num3].totalTime;
				}
				if (bestPointAndTime.point.x < -1.5f)
				{
					num3 = getClosePointIndex(-1.5f, list, 0);
					bestPointAndTime.point = list[num3].position;
					bestPointAndTime.time = list[num3].totalTime;
				}
				bestPointAndTime.frontHit = bestPointAndTime.point.z > -1f;
				UnityEngine.Debug.DrawRay(bestPointAndTime.point, Vector3.up, Color.red, 2f);
				StartCoroutine(IEnum_HitBall());
			}
		}

		private int getClosePointIndex(float _bestPoint, List<BallPhyscisInfo> info, int state)
		{
			int result = 0;
			float num = 100f;
			if (state == 0)
			{
				for (int i = 0; i < info.Count; i++)
				{
					float num2 = ((info[i].position.x - _bestPoint < 0f) ? (0f - (info[i].position.x - _bestPoint)) : (info[i].position.x - _bestPoint));
					if (num2 < num)
					{
						num = num2;
						result = i;
					}
				}
			}
			else
			{
				for (int j = 0; j < info.Count; j++)
				{
					float num3 = ((info[j].position.z - _bestPoint < 0f) ? (0f - (info[j].position.z - _bestPoint)) : (info[j].position.z - _bestPoint));
					if (num3 < num)
					{
						num = num3;
						result = j;
					}
				}
			}
			return result;
		}

		private IEnumerator IEnum_HitBall()
		{
			Vector3 point = bestPointAndTime.point;
			point.y = 0f;
			GetHitBallPos(bestPointAndTime);
			float impactTime = bestPointAndTime.time - currentSwingMotionInfo.impactTime;
			float timeChecker2 = 0f;
			while (impactTime >= timeChecker2)
			{
				timeChecker2 += Time.fixedDeltaTime;
				yield return new WaitForFixedUpdate();
			}
			if (isSmashMove)
			{
				isSmashMove = false;
				anim.SetBool("smash Move", value: false);
			}
			PlayAnim(currentSwingMotionInfo.motionName);
			if (!(impactTime < 0f))
			{
				timeChecker2 = 0f;
				while (currentSwingMotionInfo.impactTime >= timeChecker2)
				{
					timeChecker2 += Time.fixedDeltaTime;
					yield return new WaitForFixedUpdate();
				}
				if (GameManager.instance.isOnPanjung)
				{
					UnityEngine.Debug.Log("파라볼라 뷰 버그");
					yield break;
				}
				if (bestPointAndTime.isEdge)
				{
					UnityEngine.Debug.Log("첫번쨰 공에 엣지난공!");
					yield break;
				}
				if (GameManager.instance.lastTableID != 1)
				{
					UnityEngine.Debug.Log("내 테이블에 맞은 공이 아니면 안침");
					yield break;
				}
				SetHitBallVelocity();
				AIBehaviour.testEvent?.Invoke();
				GameManager.instance.SetOtherPlayerBallTarget();
				AIBehaviour.HitBallEvent?.Invoke(isServe: false, currentSwingMotionInfo.motionName.Equals("smash"));
			}
		}

		private void SetHitBallVelocity()
		{
			UnityEngine.Random.Range(0.8f, 1.3f);
			Vector3 b = new Vector3(0f, 0.8f, 0.7f);
			Vector3 position = base.transform.position;
			position.y = 0.5f;
			float num = bestPointAndTime.time - currentSwingMotionInfo.impactTime;
			float aISwingPower = GetAISwingPower(num);
			float num2 = UnityEngine.Random.Range(0f, 2f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.5f);
			num2 = (currentSwingMotionInfo.isForhand ? (num2 * -1f) : num2);
			num2 = Mathf.Clamp(num2, -3f, 3f);
			UnityEngine.Debug.Log("waitTime : " + num + " spinForce : " + num2);
			Vector3 vector = new Vector3(0f, num2, 0f);
			Vector3 velo = Preview_Ctrl.getVelocityAtoBSpin(BallBehaviour.instance.transform.position, b, aISwingPower, vector) * 0.75f;
			float num3 = UnityEngine.Random.Range(0f, 4f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 1.1f);
			float targetDis = Vector3.Distance(destination, base.transform.position);
			float scaler = (currentSwingMotionInfo.isForhand ? (0f - num3) : num3);
			velo = Preview_Ctrl.instance.getReviseAxisY(velo, scaler, BallBehaviour.instance.transform);
			bool flag = isOutBall(targetDis, bestPointAndTime.time, isPlayerSmash, num, GameManager.instance.RallyCount);
			bool flag2 = currentSwingMotionInfo.motionName.Equals("smash");
			BallBehaviour.instance.SetSmashParticle(flag2);
			if (flag2)
			{
				flag = false;
			}
			UnityEngine.Debug.Log("isOut : " + flag);
			if (flag)
			{
				float scaler2 = ((UnityEngine.Random.Range(0, 2) == 0) ? (-14f) : 15f);
				float num4 = UnityEngine.Random.Range(1.1f, 1.4f);
				velo = Preview_Ctrl.instance.getReviseAxisX(velo, scaler2, BallBehaviour.instance.transform) * num4;
				float scaler3 = UnityEngine.Random.Range(-20f, 20f);
				velo = Preview_Ctrl.instance.getReviseAxisY(velo, scaler3, BallBehaviour.instance.transform);
				BallBehaviour.instance.SetAllStop();
				Preview_Ctrl.instance.GetPreviewHitPos(BallBehaviour.instance.transform.position, velo, vector, Vector3.zero, useAI: true);
				BallBehaviour.instance.SetParticle(bestPointAndTime.point + velo.normalized * 0.5f);
			}
			else
			{
				BallBehaviour.instance.SetAllStop();
				BallBehaviour.instance.SetParticle(bestPointAndTime.point + velo.normalized * 0.5f);
				Preview_Ctrl.instance.PhysicsSimulator(BallBehaviour.instance.transform.position, velo, vector, vector, BallBehaviour.instance.transform, useAI: true, flag2);
			}
		}

		private float GetAISwingPower(float waitTime)
		{
			float num = UnityEngine.Random.Range(0.5f, 0.7f);
			num -= waitTime * 0.2f;
			num -= (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.025f;
			if (currentSwingMotionInfo.isForhand)
			{
				num -= num * 0.1f;
			}
			return num;
		}

		private Vector3 GetSmashVelocity(Vector3 velo)
		{
			velo *= 1.7f;
			return velo;
		}

		private Vector3 GetHitBallPos(BestPointAndTime bestPointAndTime)
		{
			Vector3 right = base.transform.right;
			Vector3 normalized = (bestPointAndTime.point - base.transform.position).normalized;
			Vector3 point = bestPointAndTime.point;
			point.y = 0f;
			float num = Vector3.Dot(right, normalized);
			int num2 = 0;
			float num3 = point.x - base.transform.position.x;
			float num4 = 100000f;
			for (int i = 0; i < ListSwingMotionInfo.Count; i++)
			{
				if (bestPointAndTime.frontHit)
				{
					break;
				}
				if (bestPointAndTime.time < ListSwingMotionInfo[i].impactTime)
				{
					UnityEngine.Debug.Log("준비동작이 더길다!! " + ListSwingMotionInfo[i].motionName);
					continue;
				}
				float num5 = ListSwingMotionInfo[i].posX * -1f;
				float num6 = ((num5 - num3 < 0f) ? (0f - (num5 - num3)) : (num5 - num3));
				if (num6 < num4)
				{
					num4 = num6;
					num2 = i;
				}
			}
			if (ListSwingMotionInfo[num2].motionName.Contains("Defence"))
			{
				if (bestPointAndTime.time - ListSwingMotionInfo[num2].impactTime > 0.4f)
				{
					num2 -= 3;
				}
			}
			else if (ListSwingMotionInfo[num2].motionName.Equals("smash"))
			{
				if (bestPointAndTime.point.y < 1.2f)
				{
					num2 -= 2;
				}
			}
			else if (bestPointAndTime.time > 0.75f && bestPointAndTime.point.y > 1.15f)
			{
				num2 = ListSwingMotionInfo.FindIndex((SwingMotionInfo x) => x.motionName == "smash");
			}
			else if (bestPointAndTime.frontHit)
			{
				num2 = ((num > 0.1f) ? ListSwingMotionInfo.FindIndex((SwingMotionInfo x) => x.motionName == "front forhand") : ((!(num < -0.5f)) ? ListSwingMotionInfo.FindIndex((SwingMotionInfo x) => x.motionName == "front Center") : ListSwingMotionInfo.FindIndex((SwingMotionInfo x) => x.motionName == "front backhand")));
			}
			Vector3 result = point;
			result.x += ListSwingMotionInfo[num2].posX;
			result.z += -1f * ListSwingMotionInfo[num2].posZ;
			if (result.z > -2.3f)
			{
				result.z = -2.3f;
			}
			destination = result;
			currentSwingMotionInfo = ListSwingMotionInfo[num2];
			if (currentSwingMotionInfo.motionName.Equals("smash") || currentSwingMotionInfo.motionName.Equals("forehand Stroke") || currentSwingMotionInfo.motionName.Equals("long Forehand"))
			{
				isSmashMove = true;
			}
			return result;
		}

		private void PlayAnim(string animName)
		{
			anim.SetTrigger(animName);
			animDelay = 0f;
		}

		private void ReAction(int num)
		{
			MoveStop = true;
			StartCoroutine(IEnum_ReAction(num));
		}

		private IEnumerator IEnum_ReAction(int num)
		{
			if (num != 2 && UnityEngine.Random.Range(0, 10) >= 3)
			{
				while (animDelay < 1.2f)
				{
					yield return null;
				}
				SetlookAtIK(isAdd: false);
				int num2 = UnityEngine.Random.Range(1, 3);
				string text = ((num == 1) ? "win" : "lose");
				text += num2;
				int num3 = 1;
				int num4 = UnityEngine.Random.Range(2, 4);
				int setState = ((num == 1) ? num3 : num4);
				float setTime = UnityEngine.Random.Range(1f, 3f);
				EyeAnimationCtrl.GetInstance.SetExpression(setState, setTime);
				anim.SetTrigger(text);
			}
		}

		public bool isOutBall(float targetDis, float totalTime, bool isSpecial, float waitTime, int rallyCount)
		{
			float[] array = new float[5];
			int num = 10 - SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			array[0] = 0f;
			array[1] = 50f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 5f - targetDis * 150f;
			array[2] = totalTime * 40f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 1.2f;
			array[3] = waitTime * 40f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 1.2f;
			for (int i = 1; i < array.Length; i++)
			{
				array[0] += array[i];
			}
			if (isSpecial)
			{
				array[0] -= 40f;
			}
			array[0] -= rallyCount * num;
			int num2 = UnityEngine.Random.Range(0, 100);
			return array[0] <= (float)num2;
		}

		private void Move()
		{
			if (MoveStop)
			{
				anim.SetBool("Move", value: false);
				isMoving = false;
			}
			else
			{
				if (destination == Vector3.zero)
				{
					return;
				}
				if (Vector3.Distance(base.transform.position, destination) < 0.025f)
				{
					anim.SetBool("Move", value: false);
					isMoving = false;
					return;
				}
				isMoving = true;
				Vector3 rhs = destination - base.transform.position;
				float x = Vector3.Dot(base.transform.right, rhs);
				float y = Vector3.Dot(base.transform.forward, rhs);
				Vector2 b = new Vector2(x, y);
				float num = Mathf.Min(1f, Time.deltaTime / 0.15f);
				smoothDeltaPosition = Vector2.Lerp(smoothDeltaPosition, b, num);
				if (Time.deltaTime > 1E-05f)
				{
					velocity = smoothDeltaPosition / Time.deltaTime;
				}
				bool value = velocity.magnitude > 0.01f;
				if (isSmashMove)
				{
					anim.SetBool("smash Move", value);
				}
				else
				{
					anim.SetBool("Move", value);
				}
				anim.SetFloat("veloX", velocity.x);
				anim.SetFloat("veloY", velocity.y);
				Vector3 position = Vector3.MoveTowards(base.transform.position, destination, num * 0.2f);
				base.transform.position = position;
			}
		}

		private void LoolAt()
		{
			if (Camera.main == null)
			{
				return;
			}
			if (GameManager.instance.isOtherServeBall)
			{
				Vector3 forward = Camera.main.transform.root.position - base.transform.position;
				forward.y = 0f;
				base.transform.rotation = Quaternion.LookRotation(forward);
				return;
			}
			Vector3 normalized = (BallBehaviour.instance.transform.position - base.transform.position).normalized;
			normalized.y = 0f;
			Vector3 forward2 = base.transform.forward;
			float num = Vector3.Dot(normalized, forward2);
			float num2 = Mathf.Cos((float)Math.PI / 6f);
			if (num < num2)
			{
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.identity, Time.deltaTime * 2f);
				SetlookAtIK(isAdd: false);
			}
			else
			{
				SetlookAtIK(isAdd: true);
				Quaternion b = Quaternion.LookRotation(normalized);
				base.transform.rotation = Quaternion.Lerp(base.transform.rotation, b, Time.deltaTime * 2f);
			}
		}

		private void Update()
		{
			Move();
			LoolAt();
			AnimTimeCheck();
		}

		private void AnimTimeCheck()
		{
			animDelay += Time.deltaTime;
		}

		private void SetlookAtIK(bool isAdd, float speed = 0.01f)
		{
			if (lookAtIKCoroutine != null)
			{
				StopCoroutine(lookAtIKCoroutine);
			}
			lookAtIKCoroutine = (isAdd ? StartCoroutine(IEnum_lookAtIkAddWeight(speed)) : StartCoroutine(IEnum_lookAtIkRevertWeight(speed)));
		}

		private IEnumerator IEnum_lookAtIkRevertWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight -= fadeSpeed;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					lookAtIK.solver.headWeight = 0f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}

		private IEnumerator IEnum_lookAtIkAddWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight += fadeSpeed;
				if ((double)lookAtIK.solver.headWeight >= 0.7)
				{
					lookAtIK.solver.headWeight = 0.7f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight >= 0.7f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}
	}
	public class AISpawner : MonoBehaviour
	{
		public Transform CharacterTR;

		[HideInInspector]
		public GameObject CharacterGO;

		private void Awake()
		{
			base.enabled = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single;
		}

		private void Start()
		{
			SpawnCharacter();
		}

		private void SpawnCharacter()
		{
			CharacterGO = UnityEngine.Object.Instantiate(CharacterTR, base.transform).gameObject;
			CharacterGO.GetComponent<CustomModelSettingCtrl>().InitCPU(CustomModelViewState.Normal, null, 0f);
			CharacterGO.SetActive(value: true);
		}
	}
	public class BallBehaviour : MonoBehaviour
	{
		public enum BallState
		{
			serve,
			none
		}

		public delegate void BallCollision(string colString);

		public BallState ballState;

		public static BallBehaviour instance;

		[HideInInspector]
		public Rigidbody rigid;

		[HideInInspector]
		public float rigidDrag;

		private bool isPlay;

		[HideInInspector]
		public int PhysicsMoveIndex;

		private Vector3 lastVelo;

		public Vector3 SpinForce;

		public Vector3 AngularVelocity;

		public ParticleSystem hitParticle;

		public ParticleSystem tableMaker;

		public ParticleSystem smashParticle;

		private SpinParticle spinParticle;

		private TrailRenderer Trail;

		public MeshRenderer thisMesh;

		private AudioSource Audio;

		public SphereCollider thisCol;

		private CustomFixedUpdate customFixedUpdate;

		private List<Vector3> recordVelo = new List<Vector3>();

		public Transform spinDummy;

		public static event BallCollision BallCollisionEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			rigid = GetComponent<Rigidbody>();
			rigidDrag = rigid.drag;
			Audio = GetComponent<AudioSource>();
			thisCol = GetComponent<SphereCollider>();
			thisMesh = GetComponent<MeshRenderer>();
			spinParticle = base.transform.Find("SpinRoot/Spin").GetComponent<SpinParticle>();
			Trail = base.transform.Find("Trail").GetComponent<TrailRenderer>();
		}

		private void OnEnable()
		{
			cFollower.hitBallEvent += HitBall;
			PlayerBehaviour.ResetBallEvent += ResetBall;
			AIBehaviour.HitBallEvent += HitBall;
			GameManager.GameStartEvent += GameStart;
		}

		private void OnDisable()
		{
			cFollower.hitBallEvent -= HitBall;
			PlayerBehaviour.ResetBallEvent -= ResetBall;
			AIBehaviour.HitBallEvent -= HitBall;
			GameManager.GameStartEvent -= GameStart;
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.layer != 9 && collision.gameObject.layer != 11)
			{
				return;
			}
			if (Preview_Ctrl.instance.EdgeChecker(collision.contacts[0].point))
			{
				EdgeHepler(collision.transform, collision.contacts[0].point);
				return;
			}
			BallBehaviour.BallCollisionEvent(collision.collider.name);
			if (!GameManager.instance.isOnPanjung && (collision.collider.name.Equals("0") || collision.collider.name.Equals("1")))
			{
				SetTableMarker(collision.contacts[0].point);
			}
			if (!collision.collider.name.Equals("NetChker"))
			{
				PlaySound("hitPlane");
				return;
			}
			UnityEngine.Debug.Log("<color=red>  Net Hit!!!!!!!!!!!!!! </color>");
			NetHelper(collision.transform, collision.contacts[0].point);
		}

		private void OnCollider(Collider collider, Vector3 cPoint)
		{
			if (collider.gameObject.layer == 9 || collider.gameObject.layer == 11)
			{
				BallBehaviour.BallCollisionEvent(collider.name);
				EdgeHepler(collider.transform, cPoint);
				if (!GameManager.instance.isOnPanjung && (collider.name.Equals("0") || collider.name.Equals("1")))
				{
					Vector3 tableMarker = cPoint;
					tableMarker.y -= 0.02f;
					SetTableMarker(tableMarker);
				}
				if (!collider.name.Equals("NetChker"))
				{
					PlaySound("hitPlane");
				}
				else
				{
					ColNetHelper(collider.transform, cPoint);
				}
			}
		}

		private void GameStart()
		{
		}

		private void ColNetHelper(Transform netTR, Vector3 cPoint)
		{
			Transform transform = netTR.parent.Find("NET/NetChecker");
			if (cPoint.y > 0.9f)
			{
				cPoint.y = 0.9f;
			}
			cPoint.z = 0f;
			transform.position = cPoint;
			StartCoroutine(NetChecker(transform));
		}

		private void NetHelper(Transform netTR, Vector3 cPoint)
		{
			rigid.velocity *= 0.4f;
			Transform transform = netTR.parent.Find("NET/NetChecker");
			if (cPoint.y > 0.9f)
			{
				cPoint.y = 0.9f;
			}
			cPoint.z = 0f;
			transform.position = cPoint;
			StartCoroutine(NetChecker(transform));
		}

		private IEnumerator NetChecker(Transform netCheckerTR)
		{
			netCheckerTR.localScale = Vector3.one * 0.5f;
			yield return new WaitForSeconds(0.1f);
			netCheckerTR.localScale = Vector3.zero;
		}

		private void EdgeHepler(Transform EdgeTR, Vector3 cPoint)
		{
			if (EdgeTR.name.Equals("1") || EdgeTR.name.Equals("0"))
			{
				Preview_Ctrl.instance.EdgeHepler(cPoint);
			}
		}

		private void HitBall(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 angularVelocity)
		{
			ballState = ((!isServe) ? BallState.none : BallState.serve);
			string clipName = (isSmash ? "smash" : "hitRacket");
			PlaySound(clipName);
		}

		private void HitBall(bool isServe, bool isSmash)
		{
			ballState = ((!isServe) ? BallState.none : BallState.serve);
			string clipName = (isSmash ? "smash" : "hitRacket");
			PlaySound(clipName);
		}

		public void HitBallSound(bool isSmash)
		{
			string clipName = (isSmash ? "smash" : "hitRacket");
			PlaySound(clipName);
		}

		private void FixedUpdate()
		{
			SetSpin();
			SetTrail();
			if (isPlay)
			{
				PhysicsMove();
			}
		}

		private void PhysicsMove()
		{
			List<BallPhyscisInfo> list = Preview_Ctrl.instance.listBallInfo.ToList();
			if (PhysicsMoveIndex >= list.Count)
			{
				SetAllStop();
				return;
			}
			rigid.MovePosition(list[PhysicsMoveIndex].position);
			if (list[PhysicsMoveIndex].isCol)
			{
				OnCollider(list[PhysicsMoveIndex].collider, list[PhysicsMoveIndex].position);
			}
			if (PhysicsMoveIndex > 2)
			{
				lastVelo = list[PhysicsMoveIndex].velocity;
			}
			PhysicsMoveIndex++;
		}

		public void SetAllStop()
		{
			UnityEngine.Debug.Log(string.Concat("SetAllStop : ", lastVelo, " ", lastVelo.magnitude, " moveIndex : ", PhysicsMoveIndex));
			rigid.isKinematic = false;
			isPlay = false;
			Preview_Ctrl.instance.listBallInfo.Clear();
			spinParticle.StopParticle();
			PhysicsMoveIndex = 0;
			if (lastVelo != Vector3.zero)
			{
				rigid.velocity = lastVelo;
			}
			lastVelo = Vector3.zero;
			if (customFixedUpdate != null)
			{
				customFixedUpdate = null;
			}
		}

		private void RecordVelo()
		{
			recordVelo.Add(rigid.velocity);
			if (recordVelo.Count > 5)
			{
				recordVelo.RemoveAt(0);
			}
		}

		private void SetTrail()
		{
			Trail.enabled = lastVelo.magnitude > 3f || rigid.velocity.magnitude > 3f;
		}

		public Vector3 GetCurrentBallVelo()
		{
			return lastVelo;
		}

		private void SetSpin()
		{
			Vector3 euler = new Vector3(SpinForce.x * 35f, 90f, 0f);
			spinDummy.rotation = Quaternion.Euler(euler);
		}

		public void SetPlay(Vector3 velo, Vector3 spinForce, bool useAI)
		{
			UnityEngine.Debug.Log("SetPlay");
			rigid.isKinematic = false;
			SpinForce = spinForce;
			rigid.velocity = Vector3.zero;
			rigid.Sleep();
			rigid.isKinematic = true;
			isPlay = true;
			float size = SpinForce.magnitude * 0.25f;
			spinParticle.SetParticle(size, SpinForce.y > 0f);
		}

		private void SetCustomFixedUpdate()
		{
			float aTimeStep = TimeManager.PhotonPing * 0.02f + Time.fixedDeltaTime;
			customFixedUpdate = new CustomFixedUpdate(aTimeStep, OnFixedUpdate);
		}

		private void Update()
		{
			if (customFixedUpdate != null)
			{
				customFixedUpdate.Update();
			}
		}

		private void OnFixedUpdate(float dt)
		{
			List<BallPhyscisInfo> list = Preview_Ctrl.instance.listBallInfo.ToList();
			if (PhysicsMoveIndex >= list.Count)
			{
				SetAllStop();
				return;
			}
			rigid.MovePosition(list[PhysicsMoveIndex].position);
			if (list[PhysicsMoveIndex].isCol)
			{
				OnCollider(list[PhysicsMoveIndex].collider, list[PhysicsMoveIndex].position);
			}
			if (PhysicsMoveIndex > 2)
			{
				try
				{
					lastVelo = list[PhysicsMoveIndex].velocity;
				}
				catch (ArgumentException)
				{
					lastVelo = list[list.Count - 1].velocity;
				}
			}
			PhysicsMoveIndex++;
		}

		public void SetPlay(Vector3 velo)
		{
			rigid.isKinematic = false;
			SpinForce = Vector3.zero;
			rigid.velocity = velo;
		}

		public void ResetBall(Vector3 pos)
		{
			base.transform.position = pos;
			rigid.isKinematic = true;
			rigid.velocity = Vector3.zero;
			rigid.angularVelocity = Vector3.zero;
			SpinForce = Vector3.zero;
			SetSmashParticle(isUse: false);
		}

		public void SetTrigger(bool useTrigger)
		{
			rigid.isKinematic = useTrigger;
		}

		public void SetParticle(Vector3 point)
		{
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(hitParticle, point, Quaternion.identity).gameObject, hitParticle.main.duration);
		}

		private void SetTableMarker(Vector3 point)
		{
			point.y += 0.02f;
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(tableMaker, point, Quaternion.identity).gameObject, hitParticle.main.duration);
		}

		public void SetSmashParticle(bool isUse)
		{
			if (isUse)
			{
				smashParticle.Play();
				return;
			}
			smashParticle.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
			smashParticle.Clear(withChildren: true);
		}

		private void PlaySound(string clipName)
		{
			AudioClip soundClip = TENNIS.SoundManager.instance.GetSoundClip(clipName);
			Audio.PlayOneShot(soundClip);
		}

		public bool isUseSmashParcitle()
		{
			return smashParticle.isPlaying;
		}
	}
	public class ColliderEventChcker : MonoBehaviour
	{
		private cFollower cfollower;

		[HideInInspector]
		public Rigidbody rigid;

		private SphereCollider thisCol;

		private void Start()
		{
			initData();
			cfollower = UnityEngine.Object.FindObjectOfType<cFollower>();
		}

		private void initData()
		{
			thisCol = base.gameObject.AddComponent<SphereCollider>();
			rigid = base.gameObject.AddComponent<Rigidbody>();
			thisCol.radius = 0.04f;
			rigid.useGravity = false;
			rigid.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.layer == 10)
			{
				Vector3 point = collision.contacts[0].point;
				Vector3 position = base.transform.position;
				cfollower.ColliderEvent(point, position);
			}
		}

		private void FixedUpdate()
		{
			rigid.angularVelocity = Vector3.zero;
		}
	}
	public class Cplane : MonoBehaviour
	{
		private ArrayList dumies;

		private Vector3[] oldPos;

		private Vector3[] mVels;

		private Vector3[] oldVels;

		private GameObject[] colGOs;

		private List<Vector3[]> mVelsList = new List<Vector3[]>();

		private Vector3[] AverageVelos;

		private void Start()
		{
			Vector3[] vertices = GetComponent<MeshFilter>().mesh.vertices;
			colGOs = new GameObject[vertices.Length];
			Transform parent = GameObject.Find("FollowTracer").transform;
			dumies = new ArrayList();
			for (int i = 0; i < vertices.Length; i++)
			{
				Vector3 position = new Vector3(vertices[i].x, vertices[i].y, vertices[i].z);
				Vector3 position2 = base.transform.TransformPoint(position);
				Transform transform = new GameObject().transform;
				transform.name = i.ToString();
				transform.position = position2;
				transform.parent = base.transform;
				transform.localRotation = Quaternion.identity;
				colGOs[i] = new GameObject("tracer" + i);
				colGOs[i].transform.parent = parent;
				colGOs[i].AddComponent<ColliderEventChcker>();
				dumies.Add(transform);
			}
			oldPos = new Vector3[dumies.Count];
			mVels = new Vector3[dumies.Count];
			oldVels = new Vector3[dumies.Count];
			AverageVelos = new Vector3[mVels.Length];
			for (int j = 0; j < dumies.Count; j++)
			{
				oldPos[j] = (dumies[j] as Transform).position;
			}
			GetComponent<MeshRenderer>().enabled = false;
		}

		public Vector3 getPointVellocity(Vector3 _pos)
		{
			int i;
			for (i = 0; i < AverageVelos.Length; i++)
			{
				AverageVelos[i] = new Vector3(mVelsList.Average((Vector3[] x) => x[i].x), mVelsList.Average((Vector3[] x) => x[i].y), mVelsList.Average((Vector3[] x) => x[i].z));
			}
			Vector3[] array = mVelsList[mVelsList.Count - 1];
			float num = 10000f;
			Vector3 result = Vector3.zero;
			for (int j = 0; j < dumies.Count; j++)
			{
				Transform transform = dumies[j] as Transform;
				float num2 = Vector3.Distance(_pos, transform.position);
				if (num2 < num)
				{
					num = num2;
					result = array[j].normalized * AverageVelos[j].magnitude;
					if (result.magnitude < 0.01f)
					{
						result = oldVels[j];
					}
				}
			}
			return result;
		}

		public Vector3[] GetInversPoss(Vector3 cDir)
		{
			Vector3[] array = new Vector3[colGOs.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = cDir + colGOs[i].transform.position;
			}
			return array;
		}

		private void FixedUpdate()
		{
			for (int i = 0; i < dumies.Count; i++)
			{
				oldVels[i] = mVels[i];
				Vector3 position = (dumies[i] as Transform).position;
				mVels[i] = (position - oldPos[i]) / Time.fixedDeltaTime;
				oldPos[i] = position;
			}
			mVelsList.Add(mVels);
			if (mVelsList.Count > 5)
			{
				mVelsList.RemoveAt(0);
			}
			for (int j = 0; j < colGOs.Length; j++)
			{
				if (!(colGOs[j].GetComponent<ColliderEventChcker>().rigid == null))
				{
					colGOs[j].GetComponent<ColliderEventChcker>().rigid.velocity = ((dumies[j] as Transform).position - colGOs[j].transform.position) / Time.fixedDeltaTime;
				}
			}
		}
	}
	public class CrowdManager : MonoBehaviour
	{
		private AudioSource Audio;

		private void OnEnable()
		{
			GameManager.ReactionEvent += Reaction;
		}

		private void OnDisable()
		{
			GameManager.ReactionEvent -= Reaction;
		}

		private void Start()
		{
			Audio = GetComponent<AudioSource>();
		}

		private void Reaction(int num)
		{
			string clipName = ((num == 0) ? "cheer" : "ohh");
			StartCoroutine(PlaySound(clipName));
		}

		private IEnumerator PlaySound(string clipName)
		{
			AudioClip soundClip = TENNIS.SoundManager.instance.GetSoundClip(clipName);
			if (!(Audio.clip != null))
			{
				Audio.clip = soundClip;
				Audio.Play();
				while (Audio.isPlaying)
				{
					yield return null;
				}
				Audio.clip = null;
			}
		}
	}
	public enum GameTurn
	{
		my,
		other,
		none
	}
	public enum ServeTurn
	{
		my,
		other
	}
	public class GameManager : MonoBehaviour
	{
		public delegate void gameStart();

		public delegate void PanJung(int num);

		public delegate void MultiPanjung(int num);

		public delegate void Reaction(int num);

		public delegate void GameResume();

		public static GameManager instance;

		public ServeTurn serveTurn;

		public GameTurn gameTurn;

		[HideInInspector]
		public int RallyCount;

		public int lastTableID = -1;

		public int ballTarget;

		private int serveCount;

		private bool isHitServingNet;

		public bool isOnPanjung;

		[HideInInspector]
		public bool isMyServeBall;

		[HideInInspector]
		public bool isOtherServeBall;

		[HideInInspector]
		public int MyScore;

		[HideInInspector]
		public int OtherScore;

		public int MaxPoint;

		public float ShootTimeLimit;

		public int JansuCount;

		private Coroutine ShootTimeCheckRoutine;

		public static event gameStart GameStartEvent;

		public static event PanJung PanjungEvent;

		public static event MultiPanjung MultiPanjungEvent;

		public static event Reaction ReactionEvent;

		public static event GameResume GameResumeEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.CustomHand();
		}

		private void OnEnable()
		{
			BallBehaviour.BallCollisionEvent += colliderEvent;
			cFollower.hitBallEvent += StopShootTimeCheckRoutine;
			GameResumeEvent += Resume;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				PanjungEvent += Panjung;
			}
			else
			{
				GameManager.PanjungEvent = null;
			}
		}

		private void OnDisable()
		{
			BallBehaviour.BallCollisionEvent -= colliderEvent;
			cFollower.hitBallEvent -= StopShootTimeCheckRoutine;
			GameResumeEvent -= Resume;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				PanjungEvent -= Panjung;
			}
			else
			{
				GameManager.PanjungEvent = null;
			}
		}

		private void Start()
		{
			initData();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				Invoke("GameStart", 3f);
			}
		}

		private void initData()
		{
			string nick = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick;
			string nick2 = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick;
			ScorePlaneCtrl.instance.SetData(nick, nick2, MaxPoint);
			SingletonBase.Singleton<BADMINTON.LEDScoreBoard_SGT>.GetInstance.SetData(nick, nick2, MaxPoint);
		}

		public void SetPlayerBallTarget()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (GameManager.PanjungEvent != null)
				{
					PanjungEvent -= Panjung;
					UnityEngine.Debug.Log("<color=red> 내가 침!! </color>");
				}
				else
				{
					UnityEngine.Debug.Log("<color=blue> 이벤트 없는데 해제하려함 버그!!!!!!!!! </color>");
				}
			}
			if (isMyServeBall)
			{
				ballTarget = 0;
			}
			else
			{
				if (gameTurn == GameTurn.my)
				{
					UnityEngine.Debug.Log("Panjung");
					GameManager.PanjungEvent?.Invoke(1);
					return;
				}
				if (lastTableID != 0)
				{
					UnityEngine.Debug.Log("Panjung");
					gameTurn = GameTurn.my;
					GameManager.PanjungEvent?.Invoke(1);
					return;
				}
				ballTarget = 1;
			}
			lastTableID = -1;
			gameTurn = GameTurn.my;
			isMyServeBall = false;
		}

		public void SetOtherPlayerBallTarget()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (GameManager.PanjungEvent == null)
				{
					PanjungEvent += Panjung;
					UnityEngine.Debug.Log("<color=green> 상대가 침!! </color>");
				}
				else
				{
					UnityEngine.Debug.Log("<color=blue> 이벤트 있는데 등록하려함 버그!!!!!!!!! </color>");
				}
			}
			if (isOtherServeBall)
			{
				ballTarget = 1;
			}
			else
			{
				if (gameTurn == GameTurn.other)
				{
					UnityEngine.Debug.Log("Panjung");
					GameManager.PanjungEvent?.Invoke(0);
					return;
				}
				if (lastTableID != 1)
				{
					UnityEngine.Debug.Log("Panjung");
					gameTurn = GameTurn.other;
					GameManager.PanjungEvent?.Invoke(0);
					return;
				}
				ballTarget = 0;
			}
			lastTableID = -1;
			gameTurn = GameTurn.other;
			isOtherServeBall = false;
		}

		private void colliderEvent(string colString)
		{
			if (isOnPanjung)
			{
				return;
			}
			if (ballTarget == -1 && isMyServeBall)
			{
				GameManager.GameResumeEvent();
				return;
			}
			switch (colString)
			{
			case "Plane":
				if (lastTableID == 0)
				{
					UnityEngine.Debug.Log("Panjung");
					GameManager.PanjungEvent?.Invoke(1);
				}
				else if (lastTableID == 1)
				{
					UnityEngine.Debug.Log("Panjung");
					GameManager.PanjungEvent?.Invoke(0);
				}
				else if (lastTableID == -1)
				{
					UnityEngine.Debug.Log("Panjung");
					int num3 = (int)(gameTurn + 1) % 2;
					GameManager.PanjungEvent?.Invoke(num3);
				}
				break;
			case "0":
				if (isHitServingNet && gameTurn == GameTurn.other)
				{
					GameManager.PanjungEvent?.Invoke(2);
					break;
				}
				if (ballTarget != 0)
				{
					if (lastTableID == 0)
					{
						UnityEngine.Debug.Log("Panjung");
						GameManager.PanjungEvent?.Invoke(1);
					}
					else
					{
						UnityEngine.Debug.Log("Panjung");
						int num = (int)(gameTurn + 1) % 2;
						GameManager.PanjungEvent?.Invoke(num);
					}
				}
				else
				{
					ballTarget = 1;
				}
				lastTableID = 0;
				break;
			case "1":
				if (isHitServingNet && gameTurn == GameTurn.my)
				{
					GameManager.PanjungEvent?.Invoke(2);
					break;
				}
				if (ballTarget != 1)
				{
					if (lastTableID == 1)
					{
						UnityEngine.Debug.Log("Panjung");
						GameManager.PanjungEvent?.Invoke(0);
					}
					else
					{
						UnityEngine.Debug.Log("Panjung : " + lastTableID);
						int num2 = (int)(gameTurn + 1) % 2;
						GameManager.PanjungEvent?.Invoke(num2);
					}
				}
				else
				{
					ballTarget = 0;
				}
				lastTableID = 1;
				break;
			case "NET":
				if (BallBehaviour.instance.ballState == BallBehaviour.BallState.serve && lastTableID != -1)
				{
					isHitServingNet = true;
				}
				break;
			case "NetChker":
				if (BallBehaviour.instance.ballState == BallBehaviour.BallState.serve && lastTableID != -1)
				{
					isHitServingNet = true;
				}
				break;
			}
		}

		public void GameStart()
		{
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			GameManager.GameStartEvent();
			WorldUICtrl.instance.OpenServeTurn(serveTurn);
			WorldUICtrl.instance.SetServeAudioClip(serveTurn);
			ShootTimeCheck(serveTurn);
		}

		public void ShootTimeCheck(ServeTurn _serveTurn)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				WorldUICtrl.instance.serveBallViewer.TimeUI.gameObject.SetActive(value: false);
				return;
			}
			WorldUICtrl.instance.serveBallViewer.TimeUI.gameObject.SetActive(_serveTurn == ServeTurn.my);
			if (_serveTurn == ServeTurn.my && ShootTimeCheckRoutine == null)
			{
				ShootTimeCheckRoutine = StartCoroutine(IEnum_ShootTimeLimit());
			}
		}

		private IEnumerator IEnum_ShootTimeLimit()
		{
			UnityEngine.Debug.Log("ShootTimeCheck");
			float currentTime = ShootTimeLimit;
			while (currentTime > 0f)
			{
				WorldUICtrl.instance.SetTimeLimit(currentTime);
				currentTime -= 1f;
				yield return new WaitForSeconds(1f);
			}
			isOnPanjung = false;
			WorldUICtrl.instance.CloseServeTurn(serveTurn);
			WorldUICtrl.instance.OffHowToPlay();
			BallBehaviour.instance.gameObject.SetActive(value: false);
			JansuCount++;
			if (JansuCount >= 2)
			{
				Panjung(4);
			}
			else
			{
				Panjung(3);
			}
			ShootTimeCheckRoutine = null;
		}

		private void StopShootTimeCheckRoutine(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 angularVelocity)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (ShootTimeCheckRoutine != null)
				{
					StopCoroutine(ShootTimeCheckRoutine);
				}
				ShootTimeCheckRoutine = null;
			}
		}

		private IEnumerator LetServe()
		{
			WorldUICtrl.instance.LetSound();
			isOnPanjung = true;
			yield return new WaitForSeconds(3f);
			GameManager.GameResumeEvent();
			isMyServeBall = true;
			lastTableID = -1;
			ballTarget = -1;
			isOnPanjung = false;
			isHitServingNet = false;
		}

		private void Panjung(int num)
		{
			if (isOnPanjung)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				GameManager.MultiPanjungEvent?.Invoke(num);
				return;
			}
			ADBanner.instance.ChangeAD();
			isOnPanjung = true;
			switch (num)
			{
			case 0:
				MyScore++;
				break;
			case 1:
				OtherScore++;
				break;
			}
			if (num == 2)
			{
				WorldUICtrl.instance.LetSound();
			}
			else
			{
				if (ScorePlaneCtrl.instance.isDeuce)
				{
					serveCount += 2;
				}
				else
				{
					serveCount++;
				}
				if (serveCount > 1)
				{
					serveCount = 0;
					int num2 = (int)serveTurn;
					num2++;
					num2 %= 2;
					serveTurn = (ServeTurn)num2;
				}
				WorldUICtrl.instance.CallScore(MyScore, OtherScore);
				ScorePlaneCtrl.instance.SetScore(MyScore, OtherScore);
				SingletonBase.Singleton<BADMINTON.LEDScoreBoard_SGT>.GetInstance.SetPointScore(MyScore, OtherScore);
			}
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			RallyCount = 0;
			lastTableID = -1;
			ballTarget = -1;
			isHitServingNet = false;
			if (BallBehaviour.instance.isUseSmashParcitle())
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach20", 1);
				UnityEngine.Debug.Log("<color=red> 스매쉬로 점수내기 업적!!!</color>");
			}
			GameManager.ReactionEvent(num);
			Invoke("CallGameResumeEvent", 3f);
		}

		public void RevicePanjung(bool isLet)
		{
			UnityEngine.Debug.Log("판정 이벤트 받음");
			if (isOnPanjung)
			{
				UnityEngine.Debug.Log("판정 이벤트를 받았는데 판정 중임");
				return;
			}
			GameManager.PanjungEvent = null;
			isOnPanjung = true;
			if (!isLet)
			{
				if (ScorePlaneCtrl.instance.isDeuce)
				{
					serveCount += 2;
				}
				else
				{
					serveCount++;
				}
				if (serveCount > 1)
				{
					serveCount = 0;
					int num = (int)serveTurn;
					num++;
					num %= 2;
					serveTurn = (ServeTurn)num;
				}
			}
			isMyServeBall = serveTurn == ServeTurn.my;
			isOtherServeBall = serveTurn == ServeTurn.other;
			RallyCount = 0;
			lastTableID = -1;
			ballTarget = -1;
		}

		private void GameEnd(int myScore, int otherScroe)
		{
			int num = ((MyScore <= otherScroe) ? 1 : 0);
			PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
			{
				myScore.ToString(),
				otherScroe.ToString()
			}, num);
			if (WorldUICtrl.instance.isDeuce && num == 0)
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach19", 1);
				UnityEngine.Debug.Log("<color=red> 듀스로 이기기 업적 달성!!!</color>");
			}
			if (num == 0)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
			}
		}

		public void CallGameResumeEvent()
		{
			if (MyScore >= MaxPoint || OtherScore >= MaxPoint)
			{
				if (Mathf.Abs(MyScore - OtherScore) >= 2)
				{
					GameEnd(MyScore, OtherScore);
					return;
				}
				GameManager.GameResumeEvent?.Invoke();
				gameTurn = GameTurn.none;
				WorldUICtrl.instance.SetServeAudioClip(serveTurn);
			}
			else
			{
				GameManager.GameResumeEvent?.Invoke();
				gameTurn = GameTurn.none;
				WorldUICtrl.instance.SetServeAudioClip(serveTurn);
			}
		}

		public void ReceiveGameRecumeEvent()
		{
			GameManager.GameResumeEvent?.Invoke();
			gameTurn = GameTurn.none;
		}

		private void Resume()
		{
			WorldUICtrl.instance.OpenServeTurn(serveTurn);
			isHitServingNet = false;
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single)
			{
				isOnPanjung = false;
			}
			ShootTimeCheck(serveTurn);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.LeftShift))
			{
				GameEnd(0, 1);
			}
		}
	}
	public class HandModelAnimation : MonoBehaviour
	{
		private InputDeviceState inputDeviceState;

		private Animator anim;

		public Transform RacketHolderTR;

		public Transform RacketTR;

		public bool isRacketGrab;

		private bool isChange;

		private void Awake()
		{
			inputDeviceState = base.transform.parent.GetComponent<InputDeviceState>();
			anim = GetComponent<Animator>();
		}

		private void Start()
		{
			InitAnim();
		}

		private void PlayAnim(bool isGrab)
		{
			string trigger = (isGrab ? "Catch" : "Idle");
			anim.SetTrigger(trigger);
		}

		public void isGrab(bool _isGab)
		{
			isRacketGrab = _isGab;
			InitAnim();
		}

		private void InitAnim()
		{
			if (isRacketGrab)
			{
				RacketTR.parent = RacketHolderTR;
				RacketTR.localPosition = new Vector3(-0.002f, -0.008f, -0.078f);
				RacketTR.localRotation = Quaternion.Euler(new Vector3(-89.47701f, 166.493f, -164.878f));
				RacketTR.localScale = Vector3.one * 0.85f;
				anim.SetTrigger("Grab");
			}
			else
			{
				anim.SetTrigger("Idle");
			}
		}

		private void FixedUpdate()
		{
			if (!isRacketGrab && inputDeviceState.trigger != isChange)
			{
				UnityEngine.Debug.Log("change");
				PlayAnim(inputDeviceState.trigger);
				isChange = inputDeviceState.trigger;
			}
		}
	}
	public class MultiBallManager : MonoBehaviourPun, IPunObservable
	{
		public Rigidbody rigid;

		private double m_InterpolationBackTime;

		public double m_ExtrapolationLimit = 0.5;

		private PhotonView pview;

		private Vector3 pos;

		private Vector3 velo;

		private void Start()
		{
			pview = GetComponent<PhotonView>();
			PhotonNetwork.SendRate = 100;
			PhotonNetwork.SerializationRate = 100;
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
			if (stream.IsWriting)
			{
				stream.SendNext(rigid.position);
				stream.SendNext(rigid.velocity);
				return;
			}
			pos = (Vector3)stream.ReceiveNext();
			velo = (Vector3)stream.ReceiveNext();
			float num = Mathf.Abs((float)(PhotonNetwork.Time - info.SentServerTime));
			pos += rigid.velocity * num;
		}

		private void FixedUpdate()
		{
			if (!pview.IsMine)
			{
				rigid.position = pos;
				rigid.velocity = velo;
			}
		}
	}
	public class MultiPlayerBehaviour : MonoBehaviour
	{
		private PhotonView pview;

		private Transform Player;

		private Transform[] rigs = new Transform[3];

		public Transform[] rigTrackers;

		public GameObject[] Hands;

		private string rigPath = "Me/XR Rig/Camera Offset/";

		private VRIK vrik;

		public Transform RacketTR;

		public Transform[] RacketHolderTRs;

		private void OnEnable()
		{
			RPCManager.OtherPlayerChangeHandEvent += OtherPlayerChangeHandEvent;
		}

		private void OnDisable()
		{
			RPCManager.OtherPlayerChangeHandEvent -= OtherPlayerChangeHandEvent;
		}

		private void Start()
		{
			pview = GetComponent<PhotonView>();
			CreateOtherCharacter();
		}

		private void CreateOtherCharacter()
		{
			if (pview.IsMine)
			{
				rigTrackers[1].Find("LeftHand").gameObject.SetActive(value: false);
				rigTrackers[2].Find("RightHand").gameObject.SetActive(value: false);
				return;
			}
			vrik = UnityEngine.Object.Instantiate(Resources.Load<GameObject>("VRIK"), base.transform).GetComponent<VRIK>();
			MultiPlayerManager.instance.OtherPlayerCharacter = vrik.gameObject;
			vrik.solver.spine.headTarget = rigTrackers[0].Find("IK");
			vrik.solver.spine.pelvisTarget = rigTrackers[3];
			CustomModelSettingCtrl component = vrik.GetComponent<CustomModelSettingCtrl>();
			component.enabled = true;
			int num = (PhotonNetwork.IsMasterClient ? 1 : 0);
			CustomModelData modelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_multi[num];
			component.Init(modelData, CustomModelViewState.HalfCut2);
		}

		private IEnumerator vrIk()
		{
			Transform[] handsTR = new Transform[Hands.Length];
			for (int i = 0; i < Hands.Length; i++)
			{
				handsTR[i] = UnityEngine.Object.Instantiate(Hands[i], vrik.transform).transform;
			}
			while (true)
			{
				handsTR[0].position = rigTrackers[1].position;
				handsTR[0].rotation = rigTrackers[1].rotation;
				handsTR[1].position = rigTrackers[2].position;
				handsTR[1].rotation = rigTrackers[2].rotation;
				yield return null;
			}
		}

		private void OtherPlayerChangeHandEvent(bool isRight)
		{
			if (!isRight)
			{
				RacketTR.parent = RacketHolderTRs[0];
				RacketTR.localPosition = Vector3.zero;
				RacketTR.localRotation = Quaternion.identity;
			}
			else
			{
				RacketTR.parent = RacketHolderTRs[1];
				RacketTR.localPosition = Vector3.zero;
				RacketTR.localRotation = Quaternion.identity;
			}
		}

		private void Update()
		{
			if (pview.IsMine)
			{
				if (rigs[0] == null)
				{
					rigs[0] = GameObject.Find(rigPath + "Head").transform;
				}
				if (rigs[1] == null)
				{
					rigs[1] = GameObject.Find(rigPath + "LeftHand Controller").transform;
				}
				if (rigs[2] == null)
				{
					rigs[2] = GameObject.Find(rigPath + "RightHand Controller").transform;
				}
				for (int i = 0; i < rigs.Length; i++)
				{
					rigTrackers[i].position = rigs[i].position;
					rigTrackers[i].rotation = rigs[i].rotation;
				}
			}
		}
	}
	public class MultiPlayerManager : MonoBehaviour
	{
		public static MultiPlayerManager instance;

		public GameObject LocalPlayer;

		public GameObject OtherPlayerCharacter;

		public Animator OtherPlayerCharacterAnimator;

		private void Awake()
		{
			base.enabled = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi;
			if (base.enabled)
			{
				if (instance == null)
				{
					instance = this;
				}
				else
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		public void create()
		{
			UnityEngine.Debug.Log("123123123123");
			LocalPlayer = PhotonNetwork.Instantiate("PINGPONG_MultiPlayer", Vector3.zero, Quaternion.identity, 0);
			LocalPlayer.name = PhotonNetwork.LocalPlayer.NickName;
		}

		private void Start()
		{
		}
	}
	public class NetMeshRenderer : MonoBehaviour
	{
		public BoxCollider NetCol;

		private Vector3 InitNetColSize;

		private void OnEnable()
		{
			cFollower.hitBallEvent += CFollower_hitBallEvent;
			AIBehaviour.HitBallEvent += AIBehaviour_HitBallEvent;
		}

		private void OnDisable()
		{
			cFollower.hitBallEvent -= CFollower_hitBallEvent;
			AIBehaviour.HitBallEvent -= AIBehaviour_HitBallEvent;
		}

		private void Start()
		{
			InitNetSetting();
		}

		private void InitNetSetting()
		{
			InitNetColSize = NetCol.size;
		}

		private void AIBehaviour_HitBallEvent(bool isServe, bool isSmash)
		{
			NetCol.size = InitNetColSize;
		}

		private void CFollower_hitBallEvent(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 angularVelocity)
		{
			Vector3 initNetColSize = InitNetColSize;
			initNetColSize.z = 0f;
			NetCol.size = initNetColSize;
		}
	}
	public class PhotonManager : MonoBehaviourPunCallbacks
	{
		public delegate void OtherPlayerEnter(Player player);

		public delegate void OtherPlayerLeft(Player player);

		public static PhotonManager instance;

		private ChatClient chatClient;

		public ExitGames.Client.Photon.Hashtable myCustomProperty = new ExitGames.Client.Photon.Hashtable();

		public static event OtherPlayerEnter OtherPlayerEnterEvent;

		public static event OtherPlayerLeft OtherPlayerLeftEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public void DisConnect()
		{
			PhotonNetwork.Disconnect();
		}

		public override void OnDisconnected(DisconnectCause cause)
		{
			UnityEngine.Debug.Log("Photon Disconnected " + cause);
		}

		public override void OnPlayerEnteredRoom(Player newPlayer)
		{
			base.OnPlayerEnteredRoom(newPlayer);
			UnityEngine.Debug.Log("=======Enter=======");
			UnityEngine.Debug.Log("current Player Count : " + PhotonNetwork.CurrentRoom.PlayerCount);
			UnityEngine.Debug.Log("ListCount : " + PhotonNetwork.CurrentRoom.Players.Count);
			PhotonManager.OtherPlayerEnterEvent?.Invoke(newPlayer);
			PhotonNetwork.CurrentRoom.IsVisible = false;
		}

		public void LeaveRoom()
		{
			PhotonNetwork.LeaveRoom();
		}

		public override void OnLeftRoom()
		{
			UnityEngine.Debug.Log("LeaveRoom!!");
			if (SceneManager.GetActiveScene() != SceneManager.GetSceneByName("Scene_Lobby"))
			{
				StartCoroutine(IEnum_GoTitle());
			}
		}

		private IEnumerator IEnum_GoTitle()
		{
			yield return new WaitForSeconds(1f);
			SceneManager.LoadScene("Scene_Lobby");
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			base.OnPlayerLeftRoom(otherPlayer);
			PhotonManager.OtherPlayerLeftEvent?.Invoke(otherPlayer);
			UnityEngine.Debug.Log("=======Left=======");
			UnityEngine.Debug.Log("current Player Count : " + PhotonNetwork.CurrentRoom.PlayerCount);
			UnityEngine.Debug.Log("ListCount : " + PhotonNetwork.CurrentRoom.Players.Count);
		}

		public override void OnMasterClientSwitched(Player newMasterClient)
		{
			UnityEngine.Debug.Log("new MasterClinet : " + newMasterClient.NickName);
		}

		public override void OnLeftLobby()
		{
			base.OnLeftLobby();
			UnityEngine.Debug.Log("LeftLobby!!");
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.F1))
			{
				DisConnect();
			}
		}
	}
	public class Ping_PongPlayer : MonoBehaviour
	{
	}
	[Serializable]
	public class HandInfo
	{
		public bool isUse;

		public Transform HandTR;

		public Vector3 IdlePos;

		public Vector3 IdleRot;

		public Vector3 GrabPos;

		public Vector3 GrabRot;
	}
	public class PlayerBehaviour : Ping_PongPlayer
	{
		public delegate void resetBall(Vector3 pos);

		public delegate void ChangeHand(bool isRight);

		private bool isPressTouchPad;

		private bool isPressSeconPad;

		private Transform PlayerServeTR;

		private Vector3[] PlayerServePos = new Vector3[2];

		public Transform ServeBallSpawnTR;

		public InputDeviceState leftInputDeviceState;

		public InputDeviceState rightInputDeviceState;

		private bool isGetBall;

		public List<HandInfo> ListHandPosInfo = new List<HandInfo>();

		public static event resetBall ResetBallEvent;

		public static event ChangeHand ChangeHandEvent;

		private void OnEnable()
		{
			cFollower.hitBallEvent += HitBall;
			GameManager.GameResumeEvent += GameResume;
		}

		private void OnDisable()
		{
			cFollower.hitBallEvent -= HitBall;
			GameManager.GameResumeEvent -= GameResume;
		}

		private void Start()
		{
			PlayerServeTR = base.transform.Find("PlayerServePos");
			PlayerServePos[0] = PlayerServeTR.localPosition;
			PlayerServePos[1] = PlayerServeTR.localPosition;
			PlayerServePos[1].x *= -1f;
			ChangeHandler(PublicGameUIManager.gameSetting.IsRightHanded());
			PublicGameUIManager.gameSetting.AddHandChangedEvent(ChangeHandler);
		}

		private void HitBall(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 AngularVelo)
		{
			if (isServe)
			{
				WorldUICtrl.instance.CloseServeTurn(GameManager.instance.serveTurn);
			}
			UnityEngine.Debug.Log("PlayerBehaviour HitBall");
			GameManager.instance.RallyCount++;
			GameManager.instance.SetPlayerBallTarget();
			if (PublicGameUIManager.gameSetting.IsRightHanded())
			{
				rightInputDeviceState.HapticPulse();
			}
			else
			{
				leftInputDeviceState.HapticPulse();
			}
		}

		public void GameResume()
		{
			if (GameManager.instance.serveTurn == ServeTurn.my)
			{
				PlayerBehaviour.ResetBallEvent?.Invoke(PlayerServeTR.position);
			}
		}

		private void ServeGetBall()
		{
			if (GameManager.instance.serveTurn == ServeTurn.my && GameManager.instance.RallyCount == 0 && !GameManager.instance.isOnPanjung && leftInputDeviceState.trigger)
			{
				isGetBall = true;
				BallBehaviour.instance.transform.parent = ServeBallSpawnTR;
				BallBehaviour.instance.transform.localPosition = Vector3.zero;
				WorldUICtrl.instance.CloseServeTurn(ServeTurn.my);
			}
		}

		private void ServeRaiseBall()
		{
		}

		private void ChangeHandler(bool isRight)
		{
			ListHandPosInfo[0].isUse = !isRight;
			ListHandPosInfo[0].HandTR.GetComponent<HandModelAnimation>().isGrab(ListHandPosInfo[0].isUse);
			ListHandPosInfo[1].isUse = isRight;
			ListHandPosInfo[1].HandTR.GetComponent<HandModelAnimation>().isGrab(ListHandPosInfo[1].isUse);
			PlayerServeTR.localPosition = ((!isRight) ? PlayerServePos[1] : PlayerServePos[0]);
			PlayerBehaviour.ChangeHandEvent?.Invoke(isRight);
		}

		private void Update()
		{
		}
	}
	public class PredictionManager : MonoBehaviour
	{
		public static PredictionManager instance;

		public GameObject[] obstacles;

		public int maxIterations;

		private Scene currentScene;

		private Scene predictionScene;

		private PhysicsScene currentPhysicsScene;

		private PhysicsScene predictionPhysicsScene;

		private List<GameObject> dummyObstacles = new List<GameObject>();

		public List<BallPhyscisInfo> listBallInfo = new List<BallPhyscisInfo>();

		private LineRenderer lineRenderer;

		private GameObject dummy;

		private Stopwatch stopwatch;

		public static bool isSimulate;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
			Physics.autoSimulation = false;
			currentScene = SceneManager.GetActiveScene();
			currentPhysicsScene = currentScene.GetPhysicsScene();
			CreateSceneParameters parameters = new CreateSceneParameters(LocalPhysicsMode.Physics3D);
			predictionScene = SceneManager.CreateScene("Prediction", parameters);
			SceneManager.SetActiveScene(predictionScene);
			Physics.bounceThreshold = 1f;
			Physics.defaultContactOffset = 1f;
			Physics.bounceThreshold = 0.05f;
			Physics.defaultContactOffset = 0.001f;
			predictionPhysicsScene = predictionScene.GetPhysicsScene();
			lineRenderer = GetComponent<LineRenderer>();
			copyAllObstacles();
			SceneManager.SetActiveScene(currentScene);
			stopwatch = new Stopwatch();
		}

		private void FixedUpdate()
		{
			if (currentPhysicsScene.IsValid())
			{
				currentPhysicsScene.Simulate(Time.fixedDeltaTime);
			}
		}

		private void copyAllObstacles()
		{
			GameObject[] array = obstacles;
			foreach (GameObject gameObject in array)
			{
				GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject.gameObject);
				gameObject2.transform.position = gameObject.transform.position;
				gameObject2.transform.rotation = gameObject.transform.rotation;
				gameObject2.transform.localScale = gameObject.transform.lossyScale;
				SceneManager.MoveGameObjectToScene(gameObject2, predictionScene);
				dummyObstacles.Add(gameObject2);
			}
		}

		private void DestroyAllObstacles()
		{
			foreach (GameObject dummyObstacle in dummyObstacles)
			{
				UnityEngine.Object.Destroy(dummyObstacle);
			}
			dummyObstacles.Clear();
		}

		public void predict(GameObject subject, Vector3 currentPosition, Vector3 force, Vector3 spinForce, Vector3 angularVelocity, bool useCustomFixedUpdate = false)
		{
			stopwatch.Restart();
			isSimulate = true;
			if (currentPhysicsScene.IsValid() && predictionPhysicsScene.IsValid())
			{
				if (dummy == null)
				{
					dummy = UnityEngine.Object.Instantiate(subject);
					SceneManager.MoveGameObjectToScene(dummy, predictionScene);
				}
				dummy.transform.position = currentPosition;
				dummy.GetComponent<Rigidbody>().collisionDetectionMode = CollisionDetectionMode.Discrete;
				dummy.GetComponent<Rigidbody>().AddForce(force, ForceMode.Impulse);
				dummy.GetComponent<Rigidbody>().angularVelocity = angularVelocity;
				listBallInfo.Clear();
				for (int i = 0; i < maxIterations; i++)
				{
					BallPhyscisInfo ballPhyscisInfo = new BallPhyscisInfo();
					if (spinForce != Vector3.zero)
					{
						dummy.GetComponent<Rigidbody>().AddForce(spinForce, ForceMode.Force);
					}
					predictionPhysicsScene.Simulate(Time.fixedDeltaTime);
					ballPhyscisInfo.position = dummy.transform.position;
					ballPhyscisInfo.velocity = dummy.GetComponent<Rigidbody>().velocity;
					ballPhyscisInfo.spinForce = spinForce;
					listBallInfo.Add(ballPhyscisInfo);
				}
				UnityEngine.Object.Destroy(dummy);
			}
			isSimulate = false;
			stopwatch.Stop();
			TimeManager.PhysicsSimulatorWorkTime = (float)stopwatch.ElapsedMilliseconds * 0.001f;
		}

		private void OnDestroy()
		{
			DestroyAllObstacles();
		}
	}
	[Serializable]
	public class BallPhyscisInfo
	{
		public Vector3 spinForce;

		public Vector3 velocity;

		public Vector3 position;

		public float totalTime;

		public int bounceCount;

		public bool isCol;

		public Collider collider;

		public BallPhyscisInfo()
		{
			bounceCount = 0;
			spinForce = Vector3.zero;
			velocity = Vector3.zero;
			position = Vector3.zero;
			totalTime = 0f;
			isCol = false;
			collider = null;
		}
	}
	public class Preview_Ctrl : MonoBehaviour
	{
		public List<BallPhyscisInfo> listBallInfo = new List<BallPhyscisInfo>();

		public Collider[] cols;

		public Transform[] EdgeDetectors;

		public float radiusScaler;

		public bool isDebugDraw;

		public float ReviseValue;

		public float reduceAngularVelocityValue;

		private int reviseCount;

		private Vector3 firstVelo = Vector3.zero;

		public static Preview_Ctrl instance { get; set; }

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			if (instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			Time.fixedDeltaTime = 0.01f;
			Physics.defaultContactOffset = 0.001f;
		}

		public void GetPreviewHitPos(Vector3 startPos, Vector3 velocity, Vector3 spinForce, Vector3 angularVelo, bool useAI, bool isMine = true)
		{
			if (isMine && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single)
			{
				velocity = ReviseVelo(velocity, GameObject.Find("Me").transform);
			}
			if (float.IsNaN(velocity.x))
			{
				velocity.x = 0f;
			}
			if (float.IsNaN(velocity.y))
			{
				velocity.y = 0f;
			}
			if (float.IsNaN(velocity.z))
			{
				velocity.z = 0f;
			}
			if (float.IsNaN(spinForce.x) || float.IsNaN(spinForce.y) || float.IsNaN(spinForce.z))
			{
				UnityEngine.Debug.Log("spinforce NaN!!!!!!!!!!!!!!!!!!!");
				spinForce = Vector3.zero;
			}
			if (float.IsNaN(angularVelo.x) || float.IsNaN(angularVelo.y) || float.IsNaN(angularVelo.z))
			{
				UnityEngine.Debug.Log("angularVelo NaN!!!!!!!!!!!!!!!!!!!");
				angularVelo = Vector3.zero;
			}
			float num = 0f;
			bool flag = true;
			Vector3 vector = startPos;
			float fixedDeltaTime = Time.fixedDeltaTime;
			Vector3 vector2 = Physics.gravity * fixedDeltaTime * fixedDeltaTime;
			float num2 = 1f - fixedDeltaTime * BallBehaviour.instance.rigidDrag;
			Vector3 vector3 = spinForce * fixedDeltaTime * fixedDeltaTime;
			Vector3 vector4 = velocity * fixedDeltaTime;
			Vector3 angularVelo2 = angularVelo;
			int num3 = 0;
			List<Vector3> list = new List<Vector3>();
			listBallInfo.Clear();
			Vector3 vector5 = velocity;
			bool flag2 = false;
			while (flag)
			{
				num += Time.fixedDeltaTime;
				vector4 += vector3;
				vector4 += vector2;
				vector4 *= num2;
				vector += vector4;
				list.Add(vector);
				if (list.Count < 2)
				{
					continue;
				}
				BallPhyscisInfo ballPhyscisInfo = new BallPhyscisInfo();
				float radius = radiusScaler * BallBehaviour.instance.transform.localScale.x;
				Vector3 vector6 = list[list.Count - 2];
				Vector3 vector7 = list[list.Count - 1] - vector6;
				int layerMask = 512;
				if (isDebugDraw)
				{
					UnityEngine.Debug.DrawRay(vector6, vector7, Color.cyan, 3f);
				}
				if (Physics.SphereCast(vector6, radius, vector7, out var hitInfo, vector7.magnitude, layerMask))
				{
					if (flag2 && hitInfo.collider == cols[2])
					{
						UnityEngine.Debug.Log("네트 중복 충돌");
						flag2 = false;
						continue;
					}
					num3++;
					Vector3 vector8 = Vector3.Reflect(vector5, hitInfo.normal);
					vector8.y *= 0.87f;
					vector4 = vector8 * fixedDeltaTime;
					vector4.x += angularVelo2.z * reduceAngularVelocityValue * fixedDeltaTime;
					vector4.z += angularVelo2.x * reduceAngularVelocityValue * fixedDeltaTime;
					angularVelo2 = GetAngularVelocity(angularVelo2, vector7, Vector3.up);
					if (hitInfo.collider == cols[2])
					{
						if (vector5.magnitude > 1f)
						{
							vector4 *= 0.4f;
						}
						UnityEngine.Debug.Log("Preview NetHit veloPower : " + (vector4 / fixedDeltaTime).magnitude);
						flag2 = true;
					}
					ballPhyscisInfo.isCol = true;
					ballPhyscisInfo.collider = hitInfo.collider;
				}
				vector5 = ((listBallInfo.Count == 0) ? velocity : (vector4 / fixedDeltaTime));
				ballPhyscisInfo.bounceCount = num3;
				ballPhyscisInfo.position = vector;
				ballPhyscisInfo.totalTime = num;
				ballPhyscisInfo.velocity = vector5;
				ballPhyscisInfo.spinForce = spinForce;
				listBallInfo.Add(ballPhyscisInfo);
				if (num3 > 2 || list.Count > 300)
				{
					break;
				}
			}
			BallBehaviour.instance.SetPlay(velocity, spinForce, useAI);
		}

		public void PhysicsSimulator(Vector3 startPos, Vector3 velocity, Vector3 spinForce, Vector3 angularVelo, Transform ballTR, bool useAI = false, bool isSmash = false)
		{
			float num = 0f;
			bool flag = true;
			Vector3 item = startPos;
			float fixedDeltaTime = Time.fixedDeltaTime;
			Vector3 vector = Physics.gravity * fixedDeltaTime * fixedDeltaTime;
			float num2 = 1f - fixedDeltaTime * BallBehaviour.instance.rigidDrag;
			Vector3 vector2 = spinForce * fixedDeltaTime * fixedDeltaTime;
			Vector3 vector3 = velocity * fixedDeltaTime;
			Vector3 angularVelo2 = angularVelo;
			int num3 = 0;
			bool flag2 = false;
			bool flag3 = false;
			Collider[] array = new Collider[2];
			Vector3[] array2 = new Vector3[2];
			bool isMyServeBall = GameManager.instance.isMyServeBall;
			Vector3 inDirection = velocity;
			if (reviseCount == 0)
			{
				firstVelo = velocity;
			}
			reviseCount++;
			List<Vector3> list = new List<Vector3>();
			while (flag)
			{
				num += Time.fixedDeltaTime;
				vector3 += vector2;
				vector3 += vector;
				vector3 *= num2;
				item += vector3;
				list.Add(item);
				if (list.Count < 2)
				{
					continue;
				}
				Vector3 vector4 = list[list.Count - 2];
				Vector3 vector5 = list[list.Count - 1] - vector4;
				int layerMask = 512;
				if (isDebugDraw && reviseCount <= 15)
				{
					switch (reviseCount % 5)
					{
					case 0:
						UnityEngine.Debug.DrawRay(vector4, vector5, Color.gray, 3f);
						break;
					case 1:
						UnityEngine.Debug.DrawRay(vector4, vector5, Color.red, 3f);
						break;
					case 2:
						UnityEngine.Debug.DrawRay(vector4, vector5, Color.yellow, 3f);
						break;
					case 3:
						UnityEngine.Debug.DrawRay(vector4, vector5, Color.green, 3f);
						break;
					case 4:
						UnityEngine.Debug.DrawRay(vector4, vector5, Color.blue, 3f);
						break;
					case 5:
						UnityEngine.Debug.DrawRay(vector4, vector5, Color.white, 3f);
						break;
					}
				}
				float radius = radiusScaler * BallBehaviour.instance.transform.localScale.x;
				if (Physics.SphereCast(vector4, radius, vector5, out var hitInfo, vector5.magnitude, layerMask))
				{
					Vector3 vector6 = Vector3.Reflect(inDirection, hitInfo.normal);
					vector6.y *= 0.87f;
					vector3 = vector6 * fixedDeltaTime;
					vector3.x += angularVelo2.z * reduceAngularVelocityValue * fixedDeltaTime;
					vector3.z += angularVelo2.x * reduceAngularVelocityValue * fixedDeltaTime;
					angularVelo2 = GetAngularVelocity(angularVelo2, vector5, Vector3.up);
					num3++;
					switch (num3)
					{
					case 1:
						array2[0] = hitInfo.point;
						array[0] = hitInfo.collider;
						break;
					case 2:
						array2[1] = hitInfo.point;
						array[1] = hitInfo.collider;
						break;
					}
					if (hitInfo.collider == cols[0] || hitInfo.collider == cols[1] || hitInfo.collider.name == "NetChker")
					{
						if (isMyServeBall)
						{
							switch (num3)
							{
							case 1:
								if (array[0] == cols[0])
								{
									if (isDebugDraw)
									{
										UnityEngine.Debug.Log("첫번째 바운드 보정 안해도됨 : " + list.Count);
									}
									if (Vector3.Distance(array2[0], cols[2].transform.position) < 0.3f)
									{
										array[0] = cols[2];
										flag2 = true;
									}
									continue;
								}
								if (isDebugDraw)
								{
									UnityEngine.Debug.Log("첫번째 바운드 보정 시작");
								}
								flag2 = true;
								break;
							case 2:
								if (isDebugDraw)
								{
									UnityEngine.Debug.Log("두번째 바운드 보정 시작" + array[1].name + " " + cols[1].name);
								}
								if (array[1] == cols[1])
								{
									if (Vector3.Distance(array2[1], cols[2].transform.position) < 0.3f)
									{
										if (isDebugDraw)
										{
											UnityEngine.Debug.Log("두번째 바운드 네트근처에 맞음");
										}
										array[1] = cols[2];
										flag2 = true;
									}
									if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single && Mathf.Abs(array2[1].z) < 0.7f)
									{
										if (isDebugDraw)
										{
											UnityEngine.Debug.Log("두번째 바운드 너무 앞에 떨어짐");
										}
										flag2 = true;
									}
									continue;
								}
								if (isDebugDraw)
								{
									UnityEngine.Debug.Log("두번째 바운드 보정 시작");
								}
								flag2 = true;
								break;
							}
						}
						else if (num3 == 1)
						{
							if (useAI)
							{
								if (array[0] == cols[0])
								{
									flag3 = false;
									continue;
								}
								flag3 = true;
							}
							else
							{
								if (array[0] == cols[1])
								{
									if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single && Mathf.Abs(array2[0].z) < 0.7f)
									{
										if (isDebugDraw)
										{
											UnityEngine.Debug.Log("너무 앞에 떨어지는 공 보정 시작");
										}
										flag3 = true;
									}
									continue;
								}
								flag3 = true;
							}
						}
					}
					if (hitInfo.collider == cols[3] && num3 < 3)
					{
						if (isMyServeBall)
						{
							flag2 = true;
						}
						else if (num3 < 2)
						{
							flag3 = true;
						}
					}
				}
				inDirection = vector3 / fixedDeltaTime;
				if (list.Count > 300)
				{
					break;
				}
			}
			if (isSmash)
			{
				flag3 = true;
			}
			if (flag2 && isMyServeBall)
			{
				if (isDebugDraw)
				{
					UnityEngine.Debug.Log("보정횟수 :  " + reviseCount);
				}
				if (!(array2[0] != Vector3.zero) || !(Mathf.Abs(array2[0].x) < 1.5f))
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("완전나감");
					}
					velocity = firstVelo;
					reviseCount = 0;
					GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
					return;
				}
				if (array[0] == cols[0])
				{
					if (array2[1] != Vector3.zero)
					{
						if (array[1] == cols[0])
						{
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("두번째 공 우리테이블에 두번맞음");
							}
							velocity = getReviseAxisX(velocity, 5f, ballTR);
						}
						else if (array[1] == cols[2])
						{
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("두번째 공 네트에 맞음");
							}
							velocity = getReviseAxisX(velocity, -3f, ballTR);
						}
						else if (array[1] == cols[1])
						{
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("두번째 공 OK!!  " + array2[1]);
							}
							if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
							{
								reviseCount = 0;
								GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
								return;
							}
							if (!(Mathf.Abs(array2[1].z) < 0.7f))
							{
								reviseCount = 0;
								GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
								return;
							}
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("서브 짧게 오는공 보정");
							}
							velocity = GetAddVelocityZ(velocity, 4f);
						}
						else if (array[1] == cols[3] && array2[1].x > 0.6f)
						{
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("왼쪽으로 밖에 나가는 공");
							}
							velocity = getReviseAxisY(velocity, -5f, ballTR);
						}
						else if (array[1] == cols[3] && array2[1].x < -0.6f)
						{
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("오른쪽 밖에 나가는 공");
							}
							velocity = getReviseAxisY(velocity, 5f, ballTR);
						}
						else
						{
							if (!(array[1] == cols[3]) || !(Mathf.Abs(array2[1].z) > 1.35f))
							{
								if (isDebugDraw)
								{
									UnityEngine.Debug.Log("한번맞고 나감");
								}
								reviseCount = 0;
								GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
								return;
							}
							if (isDebugDraw)
							{
								UnityEngine.Debug.Log("x축은 맞는데 밖으로 나가는공 ");
							}
							velocity = getReviseAxisX(velocity, -5f, ballTR);
						}
					}
				}
				else if (array[0] == cols[1])
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("첫번째 공 적테이블 맞음");
					}
					velocity = getReviseAxisX(velocity, -6f, ballTR);
				}
				else if (array[0] == cols[2])
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("첫번째 공 네트 맞음");
					}
					velocity = getReviseAxisX(velocity, -5f, ballTR);
				}
				else if (array[0] == cols[3] && array2[0].x > 0.6f)
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("왼쪽으로 밖에 나가는 공");
					}
					velocity = getReviseAxisY(velocity, -5f, ballTR);
				}
				else
				{
					if (!(array[0] == cols[3]) || !(array2[0].x < -0.6f))
					{
						if (isDebugDraw)
						{
							UnityEngine.Debug.Log("뒤로침");
						}
						velocity = firstVelo;
						GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
						reviseCount = 0;
						return;
					}
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("오른쪽 밖에 나가는 공");
					}
					velocity = getReviseAxisY(velocity, 5f, ballTR);
				}
				if (array[0] == cols[2])
				{
					velocity = GetAddVelocity(velocity, -10f);
				}
				else if (array[0] == cols[1])
				{
					velocity = GetAddVelocity(velocity, -15f);
				}
				if (array[1] == cols[2])
				{
					velocity = GetAddVelocity(velocity, 15f);
					velocity.y = Mathf.Abs(velocity.y) * -1f;
				}
				else if (array[1] == cols[0])
				{
					velocity = GetAddVelocityZ(velocity, 100f);
				}
				else if (array[1] == cols[3] && Mathf.Abs(array2[1].z) > 1.35f)
				{
					velocity = GetAddVelocity(velocity, -15f);
				}
				if (reviseCount > 30)
				{
					velocity = firstVelo;
					GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
					reviseCount = 0;
					return;
				}
				PhysicsSimulator(startPos, velocity, spinForce, angularVelo, ballTR, useAI);
			}
			else if (!flag2 && isMyServeBall)
			{
				GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
				reviseCount = 0;
				return;
			}
			if (flag3 && !isMyServeBall)
			{
				if (isSmash)
				{
					float t = 0.2f;
					float num4 = 0f;
					int index = 0;
					float num5 = 0f;
					float num6 = 100f;
					for (int i = 0; i < list.Count; i++)
					{
						num5 = ((list[i].z - num4 < 0f) ? (0f - (list[i].z - num4)) : (list[i].z - num4));
						if (num5 < num6)
						{
							num6 = num5;
							index = i;
						}
					}
					float num7 = ((startPos.z > 0f) ? 1f : (-1f));
					float z = ((spinForce.y < -2f) ? (-0.3f * num7) : 0f);
					velocity = getVelocityAtoBSpin(B: new Vector3(list[index].x * 0.5f, 1.05f, z), A: startPos, t: t, spin: spinForce) * 0.8f;
					UnityEngine.Debug.Log("smash 보정 : " + velocity.magnitude);
					if (velocity.magnitude > 11f)
					{
						velocity = velocity.normalized * 11f;
					}
					if (velocity.magnitude < 9.5f)
					{
						velocity = velocity.normalized * 9.5f;
					}
					GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
					return;
				}
				if (array[0] == cols[0] || array[0] == cols[2])
				{
					float num8 = Mathf.Abs(startPos.z / velocity.z);
					num8 = ((num8 > 0.5f) ? 0.5f : num8);
					float num9 = 0f;
					int index2 = 0;
					float num10 = 0f;
					float num11 = 100f;
					float num12 = 0f;
					for (int j = 0; j < list.Count; j++)
					{
						num10 = ((list[j].z - num9 < 0f) ? (0f - (list[j].z - num9)) : (list[j].z - num9));
						if (num10 < num11)
						{
							num11 = num10;
							index2 = j;
						}
						if (list[j].y > num12)
						{
							num12 = list[j].y;
						}
					}
					if (velocity.magnitude > 2.5f)
					{
						float num13 = ((startPos.z > 0f) ? 1f : (-1f));
						float z2 = ((spinForce.y > 1f) ? (0.3f * num13) : 0f);
						float num14 = num12 * 0.5f;
						if (num14 < 1.1f)
						{
							num14 = 1.1f;
						}
						velocity = getVelocityAtoBSpin(B: new Vector3(list[index2].x * 0.5f, num14, z2), A: startPos, t: num8, spin: spinForce) * 0.8f;
						UnityEngine.Debug.Log("네트보정 시작!! : " + num8 + " " + num14);
						if (velocity.magnitude > 10.5f)
						{
							velocity = velocity.normalized * 10.5f;
						}
					}
					else
					{
						velocity *= 7f;
						if (velocity.magnitude >= 5f)
						{
							velocity = velocity.normalized * 5f;
						}
					}
					GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
					return;
				}
				if (array[0] == cols[3] && array2[0].x > 0.6f && array2[0].x < 1.5f)
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("왼쪽으로 밖에 나가는 공");
					}
					velocity = getReviseAxisY(velocity, -10f, ballTR);
				}
				else if (array[0] == cols[3] && array2[0].x < -0.6f && array2[0].x > -1.5f)
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("오른쪽 밖에 나가는 공");
					}
					velocity = getReviseAxisY(velocity, 10f, ballTR);
				}
				else if (array[0] == cols[3] && Mathf.Abs(array2[0].z) > 1.3f)
				{
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("x축은 맞는데 밖으로 나가는공 ");
					}
					velocity = getReviseAxisX(velocity, -7f, ballTR);
				}
				else
				{
					if (!(array[0] == cols[1]))
					{
						if (isDebugDraw)
						{
							UnityEngine.Debug.Log("완전 잘못친 공");
						}
						velocity = firstVelo;
						reviseCount = 0;
						GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
						return;
					}
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("보정 OK");
					}
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
					{
						reviseCount = 0;
						GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
						return;
					}
					if (!(Mathf.Abs(array2[0].z) < 0.7f))
					{
						reviseCount = 0;
						GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
						return;
					}
					if (isDebugDraw)
					{
						UnityEngine.Debug.Log("짧게 오는공 보정");
					}
					velocity = getReviseAxisX(velocity, -8f, ballTR);
					velocity = GetAddVelocityZ(velocity, 2f);
				}
				if (array[0] == cols[2])
				{
					velocity = GetAddVelocity(velocity, 2f);
				}
				else if (array[0] == cols[0])
				{
					velocity = GetAddVelocity(velocity, 4f);
				}
				else if (array[0] == cols[3] && Mathf.Abs(array2[1].z) > 1.35f)
				{
					velocity = GetAddVelocity(velocity, -3f);
				}
				if (reviseCount > 7)
				{
					velocity = firstVelo;
					reviseCount = 0;
					GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
				}
				else
				{
					PhysicsSimulator(startPos, velocity, spinForce, angularVelo, ballTR, useAI);
				}
			}
			else if (!flag3 && !isMyServeBall)
			{
				reviseCount = 0;
				GetPreviewHitPos(startPos, velocity, spinForce, angularVelo, useAI);
			}
		}

		public Vector3 getReviseAxisY(Vector3 velo, float scaler, Transform TR)
		{
			Vector3 normalized = ((velo - TR.position).z * Vector3.forward).normalized;
			Vector3 normalized2 = velo.normalized;
			normalized2.y = 0f;
			Vector3 result = Quaternion.AngleAxis(scaler * Vector3.Cross(normalized, Vector3.up).normalized.x * -1f, Vector3.up) * normalized2 * velo.magnitude;
			result.y = velo.y;
			if (float.IsNaN(result.x) || float.IsNaN(result.y) || float.IsNaN(result.z))
			{
				result = velo;
			}
			return result;
		}

		public Vector3 getReviseAxisX(Vector3 velo, float scaler, Transform TR)
		{
			Vector3 normalized = ((velo - TR.position).z * Vector3.forward).normalized;
			Vector3 normalized2 = velo.normalized;
			normalized2.x = 0f;
			Vector3 normalized3 = Vector3.Cross(normalized, Vector3.up).normalized;
			Vector3 result = Quaternion.AngleAxis(scaler, normalized3) * normalized2 * velo.magnitude;
			result.x = velo.x;
			if (float.IsNaN(result.x) || float.IsNaN(result.y) || float.IsNaN(result.z))
			{
				result = velo;
			}
			return result;
		}

		private Vector3 GetAddVelocity(Vector3 velo, float scaler)
		{
			velo = velo.normalized * (velo.magnitude * (1f + scaler * 0.01f));
			return velo;
		}

		private Vector3 GetAddVelocityZ(Vector3 velo, float scaler)
		{
			velo.z = (velo.normalized * (velo.magnitude * (1f + scaler * 0.01f))).z;
			return velo;
		}

		private Vector3 GetAddVelocityY(Vector3 velo, float scaler)
		{
			velo.y = (velo.normalized * (velo.magnitude * (1f + scaler * 0.01f))).y;
			return velo;
		}

		public static Vector3 getVelocityAtoBSpin(Vector3 A, Vector3 B, float t, Vector3 spin)
		{
			Vector3 vector = A;
			Vector3 vector2 = B;
			float rigidDrag = BallBehaviour.instance.rigidDrag;
			float num = vector2.x - vector.x;
			float num2 = vector2.z - vector.z;
			float x = num / t;
			_ = num2 / t;
			float z = vector.z;
			float z2 = (vector2.z - z + spin.z * Mathf.Pow(t, 2f) / 2f) / t;
			float num3 = 9.81f - spin.y;
			float y = vector.y;
			float y2 = (vector2.y - y + num3 * Mathf.Pow(t, 2f) / 2f) / t;
			return new Vector3(x, y2, z2) * (1f + rigidDrag * (t * (1.1f + Mathf.Pow(rigidDrag, 2f))));
		}

		public bool EdgeChecker(Vector3 colPoint)
		{
			float num = 1000f;
			int num2 = -1;
			for (int i = 0; i < EdgeDetectors.Length; i++)
			{
				float num3 = Vector3.Distance(colPoint, EdgeDetectors[i].position);
				if (num > num3)
				{
					num = num3;
					num2 = i;
				}
			}
			Vector3 b = colPoint;
			if (num2 == 2 || num2 == 5)
			{
				b.x = EdgeDetectors[num2].position.x;
			}
			else
			{
				b.z = EdgeDetectors[num2].position.z;
			}
			return Vector3.Distance(EdgeDetectors[num2].position, b) < 0.02f;
		}

		public void EdgeHepler(Vector3 colPoint)
		{
			float num = 1000f;
			int num2 = -1;
			for (int i = 0; i < EdgeDetectors.Length; i++)
			{
				float num3 = Vector3.Distance(colPoint, EdgeDetectors[i].position);
				if (num > num3)
				{
					num = num3;
					num2 = i;
				}
			}
			Vector3 b = colPoint;
			if (num2 == 2 || num2 == 5)
			{
				b.x = EdgeDetectors[num2].position.x;
			}
			else
			{
				b.z = EdgeDetectors[num2].position.z;
			}
			if (!(AIBehaviour.bestPointAndTime.isEdge = Vector3.Distance(EdgeDetectors[num2].position, b) < 0.02f))
			{
				return;
			}
			if (cFollower.isHit)
			{
				UnityEngine.Debug.Log("HitLogic Working....................");
				return;
			}
			if (listBallInfo.Count == 0 || BallBehaviour.instance.PhysicsMoveIndex == 0)
			{
				UnityEngine.Debug.Log("listBallInfo.Count == 0 || BallBehaviour.instance.PhysicsMoveIndex == 0!!!!!!!");
				return;
			}
			Vector3 zero = Vector3.zero;
			try
			{
				int physicsMoveIndex = BallBehaviour.instance.PhysicsMoveIndex;
				if (physicsMoveIndex >= listBallInfo.Count)
				{
					throw new ArgumentOutOfRangeException();
				}
				zero = listBallInfo[physicsMoveIndex].velocity;
			}
			catch (ArgumentOutOfRangeException)
			{
				zero = listBallInfo[listBallInfo.Count - 1].velocity;
			}
			if (zero.magnitude < 2f)
			{
				UnityEngine.Debug.Log("velocity So weak!!!");
				return;
			}
			float num4 = 60f;
			float num5 = 1.1f;
			switch (num2)
			{
			case 0:
			case 3:
				zero = getReviseAxisY(zero, num4, BallBehaviour.instance.transform);
				break;
			case 1:
			case 4:
				zero = getReviseAxisY(zero, num4 * -1f, BallBehaviour.instance.transform);
				break;
			default:
				UnityEngine.Debug.Log("randScaler : " + num4);
				zero = getReviseAxisX(zero, 5f, BallBehaviour.instance.transform);
				break;
			}
			BallBehaviour.instance.SetAllStop();
			BallBehaviour.instance.rigid.velocity = zero * num5;
		}

		public Vector3 ReviseVelo(Vector3 velo, Transform tr)
		{
			Vector3 forward = tr.forward;
			Vector3 normalized = velo.normalized;
			normalized.y = 0f;
			float num = Vector3.Angle(forward, normalized);
			if (num == 0f)
			{
				return velo;
			}
			num *= ReviseValue;
			float num2 = Vector3.Dot(tr.right, normalized);
			num2 /= Mathf.Abs(num2) * -1f;
			num *= num2;
			Vector3 vector = Quaternion.AngleAxis(num, tr.up) * normalized * velo.magnitude;
			vector.y = velo.y;
			UnityEngine.Debug.DrawRay(base.transform.position, forward * 10f, Color.white, 30f);
			UnityEngine.Debug.DrawRay(base.transform.position, vector * 10f, Color.red, 30f);
			return vector;
		}

		private Vector3 GetAngularVelocity(Vector3 angularVelo, Vector3 inDir, Vector3 upDir)
		{
			Vector3 normalized = inDir.normalized;
			Vector3 vector = Vector3.Cross(upDir, normalized) * 1.49f;
			angularVelo -= angularVelo * 0.01f;
			return angularVelo + vector;
		}
	}
	public class RPCManager : MonoBehaviourPunCallbacks
	{
		public delegate void TestMulti();

		public delegate void WaitingPlayer();

		public delegate void OtherPlayerChangeHand(bool isRight);

		private PhotonView pview;

		public ExitGames.Client.Photon.Hashtable roomCustomProperty = new ExitGames.Client.Photon.Hashtable();

		public static event TestMulti testMultiEvent;

		public static event WaitingPlayer WaitingPlayerEvent;

		public static event OtherPlayerChangeHand OtherPlayerChangeHandEvent;

		private void Awake()
		{
			base.enabled = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi;
			if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(MapSelect());
			}
		}

		public override void OnEnable()
		{
			base.OnEnable();
			GameManager.GameStartEvent += SetStart;
			GameManager.MultiPanjungEvent += Panjung;
			cFollower.hitBallEvent += HitBall;
			PlayerBehaviour.ResetBallEvent += ResetBall;
			PlayerBehaviour.ChangeHandEvent += ChangeHand;
			GOLF.PhotonManager.OtherPlayerLeftEvent += OtherPlayerLeft;
		}

		public override void OnDisable()
		{
			base.OnDisable();
			GameManager.GameStartEvent -= SetStart;
			GameManager.MultiPanjungEvent -= Panjung;
			cFollower.hitBallEvent -= HitBall;
			PlayerBehaviour.ResetBallEvent -= ResetBall;
			PlayerBehaviour.ChangeHandEvent -= ChangeHand;
			GOLF.PhotonManager.OtherPlayerLeftEvent -= OtherPlayerLeft;
		}

		private void Start()
		{
			Initialized();
			SetRoomCustomProperty();
			StartCoroutine(IEnum_WaitingPlayer());
		}

		private IEnumerator MapSelect()
		{
			while (SetTableColor.instance == null)
			{
				yield return null;
			}
			int num = UnityEngine.Random.Range(0, SetTableColor.instance.tableColors.Length);
			SetTableColor.instance.MapIndex = num;
			SetTableColor.instance.ReceiveTableColor();
			base.photonView.RPC("RPC_MapSelect", RpcTarget.Others, num);
		}

		[PunRPC]
		private void RPC_MapSelect(int _mapIndex)
		{
			UnityEngine.Debug.Log("Get Map Index!! : " + _mapIndex);
			SetTableColor.instance.MapIndex = _mapIndex;
			SetTableColor.instance.ReceiveTableColor();
		}

		private IEnumerator IEnum_WaitingPlayer()
		{
			yield return new WaitForSeconds(3f);
			MultiPlayerManager.instance.create();
			while (MultiPlayerManager.instance.OtherPlayerCharacter == null)
			{
				yield return null;
			}
			GameManager.instance.GameStart();
			ChangeHandStart(PublicGameUIManager.gameSetting.IsRightHanded());
		}

		private void Initialized()
		{
			pview = GetComponent<PhotonView>();
			GameManager.instance.serveTurn = ((!PhotonNetwork.IsMasterClient) ? ServeTurn.other : ServeTurn.my);
			if (!PhotonNetwork.IsMasterClient)
			{
				Vector3 eulers = new Vector3(0f, 180f, 0f);
				GameObject.Find("UI").transform.Rotate(eulers);
				Transform obj = GameObject.Find("Me").transform;
				obj.Rotate(eulers);
				Vector3 position = obj.position;
				position.z *= -1f;
				obj.position = position;
			}
		}

		private void SetRoomCustomProperty()
		{
			roomCustomProperty.Add("1st Player Score", 0);
			roomCustomProperty.Add("2nd Player Score", 0);
			roomCustomProperty.Add("serveTurn", 0);
			roomCustomProperty.Add("winNum", -1);
		}

		private void SetStart()
		{
		}

		private void HitBall(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 angularVelocity)
		{
			Vector3 velocity = Preview_Ctrl.instance.listBallInfo.ToList()[0].velocity;
			pview.RPC("RPC_HitBall", RpcTarget.Others, pos, velocity, spinForce, angularVelocity, isServe, isSmash);
		}

		[PunRPC]
		private void RPC_HitBall(Vector3 cPoint, Vector3 velocity, Vector3 spinForce, Vector3 angularVelocity, bool isServe, bool isSmash)
		{
			UnityEngine.Debug.Log(string.Concat("RPC HitBall!!  ", cPoint, " ", velocity, " ", spinForce, " ", angularVelocity));
			GameManager.instance.SetOtherPlayerBallTarget();
			if (!BallBehaviour.instance.gameObject.activeSelf)
			{
				BallBehaviour.instance.gameObject.SetActive(value: true);
			}
			BallBehaviour.instance.SetAllStop();
			BallBehaviour.instance.ballState = ((!isServe) ? BallBehaviour.BallState.none : BallBehaviour.BallState.serve);
			Preview_Ctrl.instance.GetPreviewHitPos(cPoint, velocity, spinForce, angularVelocity, useAI: false, isMine: false);
			BallBehaviour.instance.SetParticle(cPoint);
			BallBehaviour.instance.SetSmashParticle(isSmash);
			BallBehaviour.instance.HitBallSound(isSmash);
			if (!BallBehaviour.instance.thisMesh.enabled)
			{
				BallBehaviour.instance.thisMesh.enabled = true;
			}
			if (!BallBehaviour.instance.thisCol.enabled)
			{
				BallBehaviour.instance.thisCol.enabled = true;
			}
			if (isServe)
			{
				WorldUICtrl.instance.CloseServeTurn(GameManager.instance.serveTurn);
			}
			RPCManager.testMultiEvent?.Invoke();
		}

		private void ResetBall(Vector3 ballPos)
		{
			pview.RPC("RPC_ResetBall", RpcTarget.Others, ballPos);
		}

		[PunRPC]
		private void RPC_ResetBall(Vector3 ballPos)
		{
			BallBehaviour.instance.ResetBall(ballPos);
		}

		private void Panjung(int winNum)
		{
			if (PhotonNetwork.IsMasterClient)
			{
				switch (winNum)
				{
				case 0:
					roomCustomProperty["1st Player Score"] = (int)roomCustomProperty["1st Player Score"] + 1;
					break;
				case 1:
				case 3:
				case 4:
					roomCustomProperty["2nd Player Score"] = (int)roomCustomProperty["2nd Player Score"] + 1;
					break;
				}
			}
			else
			{
				switch (winNum)
				{
				case 1:
				case 3:
				case 4:
					roomCustomProperty["1st Player Score"] = (int)roomCustomProperty["1st Player Score"] + 1;
					break;
				case 0:
					roomCustomProperty["2nd Player Score"] = (int)roomCustomProperty["2nd Player Score"] + 1;
					break;
				}
			}
			bool flag = false;
			flag = ((int)roomCustomProperty["1st Player Score"] >= GameManager.instance.MaxPoint || (int)roomCustomProperty["2nd Player Score"] >= GameManager.instance.MaxPoint) && Mathf.Abs((int)roomCustomProperty["1st Player Score"] - (int)roomCustomProperty["2nd Player Score"]) >= 2;
			roomCustomProperty["winNum"] = winNum;
			bool flag2 = winNum == 2;
			bool flag3 = winNum == 4;
			PhotonNetwork.CurrentRoom.SetCustomProperties(roomCustomProperty);
			pview.RPC("RPC_PanjungEvent", RpcTarget.All, flag, flag2, flag3);
		}

		public override void OnRoomPropertiesUpdate(ExitGames.Client.Photon.Hashtable propertiesThatChanged)
		{
			if (propertiesThatChanged.ContainsKey("1st Player Score") && propertiesThatChanged.ContainsKey("2nd Player Score") && propertiesThatChanged.ContainsKey("winNum"))
			{
				int num = (int)propertiesThatChanged["1st Player Score"];
				int num2 = (int)propertiesThatChanged["2nd Player Score"];
				int num3 = (int)propertiesThatChanged["winNum"];
				roomCustomProperty["1st Player Score"] = num;
				roomCustomProperty["2nd Player Score"] = num2;
				if (num3 != -1 && num3 != 2)
				{
					WorldUICtrl.instance.CallScore(num, num2, num3 == 3 || num3 == 4);
					ScorePlaneCtrl.instance.SetScore(num, num2);
					SingletonBase.Singleton<BADMINTON.LEDScoreBoard_SGT>.GetInstance.SetPointScore(num, num2);
				}
				else if (num3 != -1 && num3 == 2)
				{
					WorldUICtrl.instance.LetSound();
				}
				ADBanner.instance.ChangeAD();
			}
		}

		[PunRPC]
		private void RPC_PanjungEvent(bool isGameEnd, bool isLet, bool isJamsu)
		{
			GameManager.instance.RevicePanjung(isLet);
			StartCoroutine(GameResume(isGameEnd, isJamsu));
		}

		private IEnumerator GameResume(bool isGameEnd, bool isJamsu)
		{
			yield return new WaitForSeconds(3f);
			if (isGameEnd)
			{
				int winnerPlayer = (((int)roomCustomProperty["1st Player Score"] <= (int)roomCustomProperty["2nd Player Score"]) ? 1 : 0);
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					roomCustomProperty["1st Player Score"].ToString(),
					roomCustomProperty["2nd Player Score"].ToString()
				}, winnerPlayer);
				yield return new WaitForSeconds(1.5f);
				roomCustomProperty["1st Player Score"] = 0;
				roomCustomProperty["2nd Player Score"] = 0;
				roomCustomProperty["serveTurn"] = 0;
				roomCustomProperty["winNum"] = -1;
				PhotonNetwork.CurrentRoom.SetCustomProperties(roomCustomProperty);
			}
			else if (isJamsu)
			{
				int winnerPlayer2 = ((GameManager.instance.JansuCount != 2) ? ((!PhotonNetwork.IsMasterClient) ? 1 : 0) : (PhotonNetwork.IsMasterClient ? 1 : 0));
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					roomCustomProperty["1st Player Score"].ToString(),
					roomCustomProperty["2nd Player Score"].ToString()
				}, winnerPlayer2);
				yield return new WaitForSeconds(1.5f);
				roomCustomProperty["1st Player Score"] = 0;
				roomCustomProperty["2nd Player Score"] = 0;
				roomCustomProperty["serveTurn"] = 0;
				roomCustomProperty["winNum"] = -1;
				PhotonNetwork.CurrentRoom.SetCustomProperties(roomCustomProperty);
			}
			else
			{
				GameManager.instance.ReceiveGameRecumeEvent();
			}
		}

		private void ChangeHandStart(bool isRight)
		{
			pview.RPC("RPC_ChangeHand", RpcTarget.Others, isRight);
		}

		private void ChangeHand(bool isRight)
		{
			if (pview == null)
			{
				pview = GetComponent<PhotonView>();
			}
			pview.RPC("RPC_ChangeHand", RpcTarget.Others, isRight);
			if (Preview_Ctrl.instance.listBallInfo.Count == 0 && !GameManager.instance.isOnPanjung && GameManager.instance.serveTurn == ServeTurn.my)
			{
				Vector3 position = GameObject.Find("Me/PlayerServePos").transform.position;
				ResetBall(position);
			}
		}

		[PunRPC]
		private void RPC_ChangeHand(bool isRight)
		{
			RPCManager.OtherPlayerChangeHandEvent?.Invoke(isRight);
		}

		private void OtherPlayerLeft(Player player)
		{
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}
	}
	public class RandomIdle : StateMachineBehaviour
	{
		private float randTime = 5f;

		private float currentTime;

		private float blend;

		private float value = 0.02f;

		public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
		{
			currentTime += Time.deltaTime;
			if (currentTime > randTime)
			{
				currentTime = 0f;
				randTime = UnityEngine.Random.Range(2f, 5f);
				value = UnityEngine.Random.Range(Time.deltaTime * -2f, Time.deltaTime * 2f);
			}
			blend += value;
			blend = Mathf.Clamp(blend, 0f, 1f);
			animator.SetFloat("RandomIdle", blend);
		}
	}
	public class RefreeManager : MonoBehaviour
	{
		public static RefreeManager instance;

		private Animator anim;

		private LookAtIK lookAtIK;

		private Coroutine lookAtIKCoroutine;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
			anim = GetComponent<Animator>();
			GetComponent<CustomModelSettingCtrl>().InitRandom(CustomModelViewState.Normal, null, 0.1f);
			lookAtIK = GetComponent<LookAtIK>();
			lookAtIK.solver.target = BallBehaviour.instance.transform;
			SetlookAtIK(isAdd: true);
		}

		public void Play(int state)
		{
			switch (state)
			{
			case 0:
				anim.SetTrigger("Let_R");
				break;
			case 1:
				anim.SetTrigger("Let_L");
				break;
			}
		}

		private void SetlookAtIK(bool isAdd, float speed = 0.01f)
		{
			if (lookAtIKCoroutine != null)
			{
				StopCoroutine(lookAtIKCoroutine);
			}
			lookAtIKCoroutine = (isAdd ? StartCoroutine(IEnum_lookAtIkAddWeight(speed)) : StartCoroutine(IEnum_lookAtIkRevertWeight(speed)));
		}

		private IEnumerator IEnum_lookAtIkRevertWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight -= fadeSpeed;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					lookAtIK.solver.headWeight = 0f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight <= 0f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}

		private IEnumerator IEnum_lookAtIkAddWeight(float fadeSpeed)
		{
			bool isFadeIn = true;
			while (isFadeIn)
			{
				lookAtIK.solver.headWeight += fadeSpeed;
				if ((double)lookAtIK.solver.headWeight >= 0.7)
				{
					lookAtIK.solver.headWeight = 0.7f;
				}
				yield return null;
				if (lookAtIK.solver.headWeight >= 0.7f)
				{
					break;
				}
			}
			lookAtIKCoroutine = null;
		}
	}
	public class ServeBallViewer : MonoBehaviour
	{
		private Transform parentTR;

		public Transform StartPosTR;

		public Transform RaisePosTR;

		public Transform DummyBall;

		public Coroutine coroutine;

		private bool isMoving;

		public Transform CameraTR;

		public Transform TimeUI;

		public TextMesh TimeText;

		public void ViewOnOff(bool isOn)
		{
			base.gameObject.SetActive(isOn);
			if (isOn)
			{
				coroutine = StartCoroutine(IEnum_SetBallPos());
			}
		}

		private void OnEnable()
		{
			PlayerBehaviour.ChangeHandEvent += PlayerBehaviour_ChangeHandEvent;
			if (GameManager.instance != null)
			{
				TimeText.text = GameManager.instance.ShootTimeLimit.ToString();
			}
		}

		private void OnDisable()
		{
			PlayerBehaviour.ChangeHandEvent -= PlayerBehaviour_ChangeHandEvent;
		}

		private void PlayerBehaviour_ChangeHandEvent(bool isRight)
		{
			if (base.gameObject.activeSelf && !isMoving && GameManager.instance.serveTurn == ServeTurn.my)
			{
				base.transform.position = parentTR.position;
				if (BallBehaviour.instance.transform.parent == null && Preview_Ctrl.instance.listBallInfo.Count == 0)
				{
					BallBehaviour.instance.transform.position = parentTR.position;
				}
			}
		}

		private void Awake()
		{
			parentTR = GameObject.Find("Me/PlayerServePos").transform;
		}

		private IEnumerator IEnum_SetBallPos()
		{
			isMoving = true;
			BallBehaviour.instance.gameObject.SetActive(value: false);
			DummyBall.gameObject.SetActive(value: true);
			base.transform.position = StartPosTR.position;
			float dis2 = 1000f;
			while (dis2 > 0.05f)
			{
				dis2 = Vector3.Distance(base.transform.position, RaisePosTR.position);
				base.transform.position = Vector3.Lerp(base.transform.position, RaisePosTR.position, Time.deltaTime * 3f);
				yield return null;
			}
			float dot = 0f;
			BallBehaviour.instance.transform.parent = base.transform;
			BallBehaviour.instance.transform.localPosition = Vector3.zero;
			while (dot < 0.9f)
			{
				Vector3 forward = CameraTR.forward;
				Vector3 normalized = (base.transform.position - CameraTR.position).normalized;
				dot = Vector3.Dot(forward, normalized);
				yield return null;
			}
			dis2 = 100f;
			while (dis2 > 0.03f)
			{
				dis2 = Vector3.Distance(base.transform.position, parentTR.position);
				base.transform.position = Vector3.Lerp(base.transform.position, parentTR.position, Time.deltaTime * 6f);
				yield return null;
			}
			BallBehaviour.instance.transform.parent = null;
			BallBehaviour.instance.gameObject.SetActive(value: true);
			BallBehaviour.instance.thisCol.enabled = true;
			BallBehaviour.instance.thisMesh.enabled = true;
			DummyBall.gameObject.SetActive(value: false);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				GameManager.instance.isOnPanjung = false;
			}
			isMoving = false;
			coroutine = null;
		}

		private void LookAtCam()
		{
			if (coroutine == null)
			{
				Vector3 forward = CameraTR.forward;
				Vector3 normalized = (base.transform.position - CameraTR.position).normalized;
				float num = Vector3.Dot(forward, normalized);
				UnityEngine.Debug.Log("dot : " + num);
				if (num > 0.7f)
				{
					base.transform.position = Vector3.Lerp(base.transform.position, parentTR.position, Time.deltaTime * 5f);
				}
				else
				{
					base.transform.position = RaisePosTR.position;
				}
			}
		}

		private void Update()
		{
			Vector3 normalized = (CameraTR.position - TimeUI.position).normalized;
			TimeUI.rotation = Quaternion.LookRotation(normalized);
		}
	}
	public class SetTableColor : MonoBehaviour
	{
		public Color[] tableColors;

		public MeshRenderer renderer;

		public int MapIndex;

		public static SetTableColor instance;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				setTalbleColor();
			}
		}

		public void setTalbleColor()
		{
			MapIndex = UnityEngine.Random.Range(0, tableColors.Length);
			renderer.sharedMaterials[2].SetColor("_BaseColor", tableColors[MapIndex]);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
		}

		public void ReceiveTableColor()
		{
			renderer.sharedMaterials[2].SetColor("_BaseColor", tableColors[MapIndex]);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.S))
			{
				setTalbleColor();
			}
		}
	}
	[Serializable]
	public class BallSoundClip
	{
		public AudioClip[] hitPlane;

		public AudioClip[] hitRacket;

		public AudioClip[] smash;
	}
	[Serializable]
	public class CrowdSoundClip
	{
		public AudioClip[] cheer;

		public AudioClip[] ohh;
	}
	[Serializable]
	public class ScoreSoundClip
	{
		public AudioClip[] score;

		public AudioClip[] serve;
	}
	[Serializable]
	public class SoundClip
	{
		public string kategorie;

		public AudioClip[] english;

		public AudioClip[] chinese;
	}
	public class SoundManager : MonoBehaviour
	{
		public static SoundManager instance;

		public BallSoundClip ballSoundClip;

		public CrowdSoundClip crowdSoundClip;

		public ScoreSoundClip scoreSoundClip;

		private Dictionary<string, AudioClip[]> soundDictionary = new Dictionary<string, AudioClip[]>();

		public List<SoundClip> soundList = new List<SoundClip>();

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			SetSoundClips();
		}

		private void SetSoundClips()
		{
			soundDictionary.Clear();
			soundDictionary.Add("hitPlane", ballSoundClip.hitPlane);
			soundDictionary.Add("hitRacket", ballSoundClip.hitRacket);
			soundDictionary.Add("smash", ballSoundClip.smash);
			soundDictionary.Add("cheer", crowdSoundClip.cheer);
			soundDictionary.Add("ohh", crowdSoundClip.ohh);
			soundDictionary.Add("score", scoreSoundClip.score);
			soundDictionary.Add("serve", scoreSoundClip.serve);
		}

		public AudioClip GetSoundClip(string name)
		{
			if (!soundDictionary.ContainsKey(name))
			{
				return null;
			}
			int num = UnityEngine.Random.Range(0, soundDictionary[name].Length);
			return soundDictionary[name][num];
		}

		public AudioClip GetSoundClip(string name, int index)
		{
			return soundDictionary[name][index];
		}

		public AudioClip GetSoundClip(string name, string clipName)
		{
			AudioClip[] array = soundDictionary[name];
			AudioClip result = null;
			for (int i = 0; i < array.Length; i++)
			{
				if (clipName == array[i].name)
				{
					result = array[i];
				}
			}
			return result;
		}
	}
	public class SpinParticle : MonoBehaviour
	{
		private ParticleSystem ps;

		private ParticleSystem.MainModule psMM;

		private Material psMat;

		public Color topSpinColor;

		public Color backSpinColor;

		private RotationConstraint rotationConstraint;

		private void Start()
		{
			ps = GetComponent<ParticleSystem>();
			psMM = ps.main;
			psMat = GetComponent<ParticleSystemRenderer>().material;
			rotationConstraint = GetComponent<RotationConstraint>();
		}

		public void StopParticle()
		{
			ps.Stop();
			psMM.startSize = new ParticleSystem.MinMaxCurve(0f, 0f);
		}

		public void SetParticle(float size, bool isTopSpin)
		{
			psMM.startSize = new ParticleSystem.MinMaxCurve(0f, size);
			psMat.SetColor("_TintColor", isTopSpin ? topSpinColor : backSpinColor);
			if (GameManager.instance.isOnPanjung)
			{
				psMM.startSize = new ParticleSystem.MinMaxCurve(0f, 0f);
				ps.Stop();
			}
			else
			{
				ps.Play();
			}
		}
	}
	public class billboardAnimation : MonoBehaviour
	{
		private Animation anim;

		public float speed;

		private void Start()
		{
			anim = GetComponent<Animation>();
			anim["Billboard_move01"].speed = speed;
		}
	}
	public class cFollower : MonoBehaviour
	{
		public delegate void HitBallEvent(bool isServe, bool isSmash, Vector3 pos, Vector3 spinForce, Vector3 angularVelocity);

		public Transform follwerTarget;

		private Cplane plane;

		public static bool isHit;

		public ServeBallViewer serveBallViewer;

		private Transform myRigTR;

		public bool isTest;

		private InputDeviceState inputDeviceState;

		public InputDeviceState[] inputDeviceStates;

		public List<Vector3> ListVelo = new List<Vector3>();

		public List<Vector3> ListAngularVelo = new List<Vector3>();

		public float swingPowerScaler;

		public float boundPowerScaler;

		public float racketPlatPowerScaler;

		public float calculPowerScaler;

		public float tourquePowerScaler;

		public Vector3 testVelo;

		public Vector3 testSpin;

		public Vector3 testPos;

		public Vector3 testAngularVelo;

		public float testTime;

		public static event HitBallEvent hitBallEvent;

		private void OnEnable()
		{
			AIBehaviour.testEvent += Test;
			RPCManager.testMultiEvent += Test;
			PlayerBehaviour.ChangeHandEvent += PlayerBehaviour_ChangeHandEvent;
		}

		private void PlayerBehaviour_ChangeHandEvent(bool isRight)
		{
			inputDeviceState = (isRight ? inputDeviceStates[1] : inputDeviceStates[0]);
		}

		private void OnDisable()
		{
			AIBehaviour.testEvent -= Test;
			RPCManager.testMultiEvent -= Test;
			PlayerBehaviour.ChangeHandEvent -= PlayerBehaviour_ChangeHandEvent;
		}

		private void Start()
		{
			plane = base.transform.GetComponentInChildren<Cplane>();
			myRigTR = GameObject.Find("Me").transform;
		}

		public void ColliderEvent(Vector3 cPoint, Vector3 center)
		{
			if (isHit || serveBallViewer.coroutine != null)
			{
				return;
			}
			isHit = true;
			Vector3 currentBallVelo = BallBehaviour.instance.GetCurrentBallVelo();
			float magnitude = new Vector3(ListVelo.Max((Vector3 a) => a.x), ListVelo.Max((Vector3 a) => a.y), ListVelo.Max((Vector3 a) => a.z)).magnitude;
			Vector3 vector = plane.getPointVellocity(cPoint) * magnitude;
			vector *= swingPowerScaler;
			Vector3 cDir = cPoint - center;
			Vector3[] inversPoss = plane.GetInversPoss(cDir);
			Vector3 lhs = inversPoss[1] - inversPoss[0];
			Vector3 rhs = inversPoss[inversPoss.Length - 1] - inversPoss[0];
			Vector3 vector2 = Vector3.Cross(lhs, rhs);
			Vector3 normalized = ((Vector3.Dot(cDir.normalized, vector2) < 0f) ? (vector2 * -1f) : vector2).normalized;
			Vector3 vector3 = Vector3.Reflect(currentBallVelo, base.transform.forward);
			vector3 *= boundPowerScaler;
			float num = Vector3.Dot(vector, normalized);
			normalized *= num;
			Vector3 lhs2 = Vector3.ProjectOnPlane(vector, normalized);
			normalized *= racketPlatPowerScaler;
			Vector3 vector4 = Vector3.Cross(lhs2, normalized.normalized);
			float magnitude2 = vector.magnitude;
			if (vector.magnitude > 6f)
			{
				vector = vector.normalized * 6f;
			}
			Vector3 vector5 = (normalized + vector3 + vector) * calculPowerScaler;
			Vector3 vector6 = new Vector3(vector4.y, vector4.x, vector4.z) * tourquePowerScaler;
			if (base.transform.position.z < 0f)
			{
				vector6.y *= -1f;
			}
			vector6.x *= -1f;
			if (vector6.magnitude > 4f)
			{
				vector6 = vector6.normalized * 4f;
			}
			bool flag = false;
			if (vector3.magnitude < 3f && magnitude2 > 18f && !GameManager.instance.isMyServeBall && vector6.magnitude > 3.6f && vector6.y < 0f)
			{
				flag = true;
			}
			if (vector3.magnitude < 3f && magnitude2 > 9f && !GameManager.instance.isMyServeBall && BallBehaviour.instance.transform.position.y > 1.2f)
			{
				flag = true;
			}
			if (GameManager.instance.isMyServeBall)
			{
				if (!IsHitFront(vector5))
				{
					Invoke("InvokeHit", 0.5f);
					return;
				}
				if (vector5.magnitude < 4f)
				{
					vector5 = vector5.normalized * 4f;
				}
			}
			if (vector5.magnitude > 9f)
			{
				vector5 = vector5.normalized * 9f;
			}
			if (vector5.y > 11f)
			{
				vector5.y = 11f;
			}
			BallBehaviour.instance.SetSmashParticle(flag);
			Invoke("InvokeHit", 0.5f);
			if (!GameManager.instance.isOnPanjung)
			{
				BallBehaviour.instance.SetAllStop();
				Preview_Ctrl.instance.PhysicsSimulator(cPoint, vector5, vector6, vector6, BallBehaviour.instance.transform, useAI: false, flag);
				cFollower.hitBallEvent?.Invoke(GameManager.instance.isMyServeBall, flag, cPoint, vector6, vector6);
			}
		}

		private bool IsHitFront(Vector3 velo)
		{
			float num = velo.z / myRigTR.forward.z;
			Transform transform = myRigTR.GetComponentInChildren<Camera>().transform;
			Vector3 forward = transform.forward;
			Vector3 normalized = (BallBehaviour.instance.transform.position - transform.position).normalized;
			float num2 = Vector3.Dot(forward, normalized);
			if (num < 0f)
			{
				return false;
			}
			if (Mathf.Abs(velo.z) < Mathf.Abs(velo.x))
			{
				return false;
			}
			if (velo.magnitude < 1.5f)
			{
				return false;
			}
			if (num2 < 0.7f)
			{
				return false;
			}
			return true;
		}

		private void InvokeHit()
		{
			isHit = false;
		}

		private void TestServe()
		{
			if (base.transform.position.z < 0f)
			{
				testVelo.z *= -1f;
			}
			WorldUICtrl.instance.CloseServeTurn(GameManager.instance.serveTurn);
			_ = Preview_Ctrl.getVelocityAtoBSpin(BallBehaviour.instance.transform.position, testPos, testTime, testSpin) * 0.7f;
			Preview_Ctrl.instance.PhysicsSimulator(BallBehaviour.instance.transform.position, testVelo, testSpin, Vector3.zero, BallBehaviour.instance.transform);
			cFollower.hitBallEvent?.Invoke(GameManager.instance.isMyServeBall, isSmash: false, BallBehaviour.instance.transform.position, testSpin, testAngularVelo);
		}

		private void Test()
		{
			if (isTest)
			{
				StartCoroutine(IEnum_Test());
			}
		}

		private IEnumerator IEnum_Test()
		{
			yield return new WaitForSeconds(0.8f);
			if (GameManager.instance.lastTableID == 0 && !GameManager.instance.isOnPanjung)
			{
				Vector3 b = testPos;
				if (base.transform.position.z < 0f)
				{
					b.z *= -1f;
				}
				float t = testTime;
				float y = UnityEngine.Random.Range(-2f, 2f);
				float x = UnityEngine.Random.Range(-1f, 1f);
				Vector3 vector = new Vector3(x, y, 0f);
				Vector3 velocity = Preview_Ctrl.getVelocityAtoBSpin(BallBehaviour.instance.transform.position, b, t, vector) * 0.7f;
				_ = testAngularVelo;
				bool flag = false;
				BallBehaviour.instance.SetAllStop();
				Preview_Ctrl.instance.GetPreviewHitPos(BallBehaviour.instance.transform.position, velocity, vector, Vector3.zero, useAI: false);
				if (!GameManager.instance.isOnPanjung)
				{
					cFollower.hitBallEvent?.Invoke(GameManager.instance.isMyServeBall, flag, BallBehaviour.instance.transform.position, vector, vector);
					BallBehaviour.instance.SetSmashParticle(flag);
				}
			}
		}

		public Vector3 getBoundVector(Vector3 _contactPoint, Vector3 _boundForward, Vector3 _ipSa)
		{
			Vector3 vector = -1f * _ipSa;
			float num = Vector3.Angle(vector, _boundForward);
			Vector3 axis = Vector3.Cross(_boundForward, vector);
			return Quaternion.AngleAxis(-2f * num, axis) * vector;
		}

		private void FixedUpdate()
		{
			if (Time.fixedDeltaTime != 0f)
			{
				ListVelo.Add(inputDeviceState.deviceVelo * 0.6f);
				if (ListVelo.Count > 3)
				{
					ListVelo.RemoveAt(0);
				}
				ListAngularVelo.Add(inputDeviceState.deviceAngularVelo * 0.01f);
				if (ListAngularVelo.Count > 3)
				{
					ListAngularVelo.RemoveAt(0);
				}
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				TestServe();
			}
		}
	}
	public class signAnimation : MonoBehaviour
	{
		private Animation anim;

		public float playTime;

		private void Start()
		{
			anim = GetComponent<Animation>();
			anim["Billboard_move02"].speed = 0f;
		}

		private void OnEnable()
		{
		}

		private void OnDisable()
		{
		}

		private void GameManager_PanjungEvent(int num)
		{
			StartCoroutine(IEnum_signAnimation());
		}

		private IEnumerator IEnum_signAnimation()
		{
			anim["Billboard_move02"].speed = 1f;
			yield return new WaitForSeconds(playTime * 0.5f);
			anim["Billboard_move02"].speed = 0f;
		}
	}
}
namespace FXV
{
	public enum FXVRenderSidesOptions
	{
		OUTSIDE_ONLY,
		OUTSIDE_AND_INSIDE,
		INSIDE_ONLY
	}
	public class FXVShield : MonoBehaviour
	{
		public bool shieldActive = true;

		public float shieldActivationSpeed = 1f;

		private float shieldActivationRim = 0.2f;

		public float hitEffectDuration = 0.5f;

		public Light shieldLight;

		public Material hitMaterial;

		public Color hitColor;

		public bool autoHitPatternScale = true;

		public FXVRenderSidesOptions renderSides;

		private Color lightColor;

		private GameObject inside;

		private Renderer insideRenderer;

		private Material baseMaterial;

		private Material activationMaterial;

		private Material postprocessMaterial;

		private Material postprocessActivationMaterial;

		private Collider myCollider;

		private CommandBuffer cmdBuffer;

		private Renderer myRenderer;

		private float shieldActivationTime;

		private float shieldActivationDir;

		private int activationTimeProperty;

		private int shieldDirectionProperty;

		private int currentHitIndex = 1;

		private static Dictionary<string, Mesh> insideMeshes = new Dictionary<string, Mesh>();

		private void Awake()
		{
			myRenderer = GetComponent<Renderer>();
			activationTimeProperty = Shader.PropertyToID("_ActivationTime");
			shieldDirectionProperty = Shader.PropertyToID("_ShieldDirection");
			if ((bool)Camera.main)
			{
				FXVShieldPostprocess component = Camera.main.GetComponent<FXVShieldPostprocess>();
				if ((bool)component)
				{
					component.AddShield(this);
				}
			}
			shieldActivationDir = 0f;
			if ((bool)shieldLight)
			{
				lightColor = shieldLight.color;
			}
			myCollider = base.transform.GetComponent<Collider>();
			if (shieldActive)
			{
				shieldActivationTime = 1f;
				myCollider.enabled = true;
			}
			else
			{
				shieldActivationTime = 0f;
				myCollider.enabled = false;
			}
			if ((bool)shieldLight)
			{
				shieldLight.color = Color.Lerp(Color.black, lightColor, shieldActivationTime);
			}
			if (renderSides == FXVRenderSidesOptions.OUTSIDE_AND_INSIDE || renderSides == FXVRenderSidesOptions.INSIDE_ONLY)
			{
				inside = new GameObject("inside");
				inside.transform.parent = base.transform;
				inside.transform.localPosition = Vector3.zero;
				inside.transform.localScale = Vector3.one;
				inside.transform.localRotation = Quaternion.identity;
				inside.layer = base.gameObject.layer;
				inside.AddComponent<MeshRenderer>();
				MeshFilter meshFilter = inside.AddComponent<MeshFilter>();
				Mesh mesh = base.gameObject.GetComponent<MeshFilter>().mesh;
				string key = mesh.name + "_inside";
				Mesh mesh2 = null;
				if (insideMeshes.ContainsKey(key))
				{
					mesh2 = insideMeshes[key];
				}
				else
				{
					mesh2 = UnityEngine.Object.Instantiate(mesh);
					Vector3[] normals = mesh2.normals;
					for (int i = 0; i < normals.Length; i++)
					{
						normals[i] = -normals[i];
					}
					mesh2.normals = normals;
					for (int j = 0; j < mesh2.subMeshCount; j++)
					{
						int[] triangles = mesh2.GetTriangles(j);
						for (int k = 0; k < triangles.Length; k += 3)
						{
							int num = triangles[k];
							triangles[k] = triangles[k + 1];
							triangles[k + 1] = num;
						}
						mesh2.SetTriangles(triangles, j);
					}
					insideMeshes.Add(key, mesh2);
				}
				meshFilter.mesh = mesh2;
				insideRenderer = inside.GetComponent<Renderer>();
				insideRenderer.sortingOrder -= 1;
				inside.AddComponent<MeshCollider>().sharedMesh = mesh2;
			}
			if (renderSides == FXVRenderSidesOptions.INSIDE_ONLY)
			{
				myRenderer.enabled = false;
			}
			SetMaterial(myRenderer.material);
			SetHitMaterial(hitMaterial);
		}

		private void OnDestroy()
		{
			if ((bool)Camera.main)
			{
				FXVShieldPostprocess component = Camera.main.GetComponent<FXVShieldPostprocess>();
				if ((bool)component)
				{
					component.RemoveShield(this);
				}
			}
			if ((bool)inside)
			{
				UnityEngine.Object.Destroy(inside.GetComponent<MeshFilter>().mesh);
			}
			if ((bool)baseMaterial)
			{
				UnityEngine.Object.Destroy(baseMaterial);
			}
			if ((bool)postprocessMaterial)
			{
				UnityEngine.Object.Destroy(postprocessMaterial);
			}
			if ((bool)postprocessActivationMaterial)
			{
				UnityEngine.Object.Destroy(postprocessActivationMaterial);
			}
			if ((bool)activationMaterial)
			{
				UnityEngine.Object.Destroy(activationMaterial);
			}
		}

		public void SetHitMaterial(Material newMat)
		{
			hitMaterial = newMat;
		}

		public void SetMaterial(Material newMat)
		{
			if ((bool)baseMaterial)
			{
				UnityEngine.Object.Destroy(baseMaterial);
			}
			if ((bool)postprocessMaterial)
			{
				UnityEngine.Object.Destroy(postprocessMaterial);
			}
			if ((bool)postprocessActivationMaterial)
			{
				UnityEngine.Object.Destroy(postprocessActivationMaterial);
			}
			if ((bool)activationMaterial)
			{
				UnityEngine.Object.Destroy(activationMaterial);
			}
			baseMaterial = new Material(newMat);
			baseMaterial.SetFloat(activationTimeProperty, 1f);
			postprocessMaterial = new Material(baseMaterial);
			List<string> list = new List<string>(postprocessMaterial.shaderKeywords);
			if (list.Contains("USE_REFRACTION"))
			{
				list.Remove("USE_REFRACTION");
			}
			if (list.Contains("ACTIVATION_EFFECT_ON"))
			{
				list.Remove("ACTIVATION_EFFECT_ON");
			}
			postprocessMaterial.shaderKeywords = list.ToArray();
			postprocessMaterial.SetVector(shieldDirectionProperty, new Vector4(1f, 0f, 0f, 0f));
			postprocessActivationMaterial = new Material(baseMaterial);
			list = new List<string>(postprocessActivationMaterial.shaderKeywords);
			if (list.Contains("USE_REFRACTION"))
			{
				list.Remove("USE_REFRACTION");
			}
			postprocessActivationMaterial.shaderKeywords = list.ToArray();
			postprocessActivationMaterial.SetVector(shieldDirectionProperty, new Vector4(1f, 0f, 0f, 0f));
			activationMaterial = new Material(baseMaterial);
			shieldActivationRim = activationMaterial.GetFloat("_ActivationRim");
			list = new List<string>(baseMaterial.shaderKeywords);
			if (list.Contains("ACTIVATION_EFFECT_ON"))
			{
				list.Remove("ACTIVATION_EFFECT_ON");
			}
			baseMaterial.shaderKeywords = list.ToArray();
			myRenderer.sharedMaterial = baseMaterial;
			if ((bool)insideRenderer)
			{
				insideRenderer.sharedMaterial = baseMaterial;
			}
			SetShieldEffectDirection(new Vector3(1f, 0f, 0f));
		}

		private void Update()
		{
			if (shieldActivationDir > 0f)
			{
				shieldActivationTime += shieldActivationSpeed * Time.deltaTime;
				if (shieldActivationTime >= 1f)
				{
					shieldActivationTime = 1f;
					shieldActivationDir = 0f;
					myRenderer.sharedMaterial = baseMaterial;
					if ((bool)insideRenderer)
					{
						insideRenderer.sharedMaterial = baseMaterial;
					}
				}
				if ((bool)shieldLight)
				{
					shieldLight.color = Color.Lerp(Color.black, lightColor, shieldActivationTime);
				}
			}
			else if (shieldActivationDir < 0f)
			{
				shieldActivationTime -= shieldActivationSpeed * Time.deltaTime;
				if (shieldActivationTime <= 0f - shieldActivationRim)
				{
					shieldActivationTime = 0f - shieldActivationRim;
					shieldActivationDir = 0f;
					myRenderer.enabled = false;
					myRenderer.sharedMaterial = baseMaterial;
					if ((bool)insideRenderer)
					{
						insideRenderer.enabled = false;
						insideRenderer.sharedMaterial = baseMaterial;
					}
				}
				if ((bool)shieldLight)
				{
					shieldLight.color = Color.Lerp(Color.black, lightColor, shieldActivationTime);
				}
			}
			myRenderer.sharedMaterial.SetFloat(activationTimeProperty, shieldActivationTime);
			postprocessActivationMaterial.SetFloat(activationTimeProperty, shieldActivationTime);
		}

		public bool GetIsShieldActive()
		{
			if (shieldActivationTime != 1f)
			{
				return shieldActivationDir == 1f;
			}
			return true;
		}

		public bool GetIsDuringActivationAnim()
		{
			return shieldActivationDir != 0f;
		}

		public void SetShieldActive(bool active, bool animated = true)
		{
			if (animated)
			{
				shieldActivationDir = (active ? 1f : (-1f));
				if ((bool)activationMaterial)
				{
					activationMaterial.SetFloat("_ActivationRim", shieldActivationRim);
					activationMaterial.SetFloat(activationTimeProperty, shieldActivationTime);
					postprocessActivationMaterial.SetFloat("_ActivationRim", shieldActivationRim);
					postprocessActivationMaterial.SetFloat(activationTimeProperty, shieldActivationTime);
					myRenderer.sharedMaterial = activationMaterial;
					if ((bool)insideRenderer)
					{
						insideRenderer.sharedMaterial = activationMaterial;
					}
				}
				if (active)
				{
					myRenderer.enabled = renderSides != FXVRenderSidesOptions.INSIDE_ONLY;
					if ((bool)insideRenderer)
					{
						insideRenderer.enabled = true;
					}
				}
			}
			else
			{
				shieldActivationTime = (active ? 1f : 0f);
				shieldActivationDir = 0f;
				myRenderer.enabled = active;
				if ((bool)insideRenderer)
				{
					insideRenderer.enabled = active;
				}
			}
			myCollider.enabled = active;
		}

		public void SetShieldEffectDirection(Vector3 dir)
		{
			Vector4 value = new Vector4(dir.x, dir.y, dir.z, 0f);
			myRenderer.material.SetVector(shieldDirectionProperty, value);
			baseMaterial.SetVector(shieldDirectionProperty, value);
			activationMaterial.SetVector(shieldDirectionProperty, value);
			postprocessMaterial.SetVector(shieldDirectionProperty, value);
			postprocessActivationMaterial.SetVector(shieldDirectionProperty, value);
		}

		public void OnHit(Vector3 hitPos, float hitScale)
		{
			AddHitMeshAtPos(base.gameObject.GetComponent<MeshFilter>().mesh, hitPos, hitScale);
			if (renderSides == FXVRenderSidesOptions.OUTSIDE_AND_INSIDE || renderSides == FXVRenderSidesOptions.INSIDE_ONLY)
			{
				AddHitMeshAtPos(insideRenderer.GetComponent<MeshFilter>().mesh, hitPos, hitScale);
			}
		}

		private void AddHitMeshAtPos(Mesh mesh, Vector3 hitPos, float hitScale)
		{
			GameObject obj = new GameObject("hitFX");
			obj.transform.parent = base.transform;
			obj.transform.position = base.transform.position;
			obj.transform.localScale = Vector3.one;
			obj.transform.rotation = base.transform.rotation;
			Vector3 vector = base.transform.InverseTransformPoint(hitPos);
			Vector3 normalized = vector.normalized;
			Vector3 vector2 = Vector3.up - normalized * Vector3.Dot(normalized, Vector3.up);
			vector2.Normalize();
			Vector3 vector3 = Vector3.Cross(normalized, vector2);
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			obj.AddComponent<MeshFilter>().mesh = mesh;
			meshRenderer.material = new Material(hitMaterial);
			meshRenderer.material.SetVector("_HitPos", vector);
			meshRenderer.material.SetVector("_HitTan1", vector2);
			meshRenderer.material.SetVector("_HitTan2", vector3);
			meshRenderer.material.SetFloat("_HitRadius", hitScale);
			meshRenderer.material.SetVector("_WorldScale", base.transform.lossyScale);
			meshRenderer.material.SetFloat("_HitShieldCovering", 1f);
			meshRenderer.material.renderQueue = meshRenderer.material.renderQueue + currentHitIndex;
			if (autoHitPatternScale)
			{
				if (myRenderer.material.HasProperty("_PatternScale"))
				{
					meshRenderer.material.SetFloat("_PatternScale", myRenderer.material.GetFloat("_PatternScale"));
				}
				else
				{
					autoHitPatternScale = false;
				}
			}
			meshRenderer.material.color = hitColor;
			obj.AddComponent<FXVShieldHit>().StartHitFX(hitEffectDuration);
			currentHitIndex++;
			if (currentHitIndex > 100)
			{
				currentHitIndex = 1;
			}
		}

		public void RenderPostprocess(CommandBuffer cmd)
		{
			if ((bool)myRenderer && base.gameObject.activeSelf && base.gameObject.activeInHierarchy)
			{
				if (myRenderer.enabled)
				{
					cmd.DrawRenderer(myRenderer, GetPostprocessMaterial());
				}
				if ((bool)insideRenderer && insideRenderer.enabled)
				{
					cmd.DrawRenderer(insideRenderer, GetPostprocessMaterial());
				}
			}
		}

		public Material GetPostprocessMaterial()
		{
			if (GetIsDuringActivationAnim())
			{
				return postprocessActivationMaterial;
			}
			return postprocessMaterial;
		}

		public Renderer GetRenderer()
		{
			return myRenderer;
		}
	}
	public class FXVShieldHit : MonoBehaviour
	{
		private float lifeTime = 0.5f;

		private float lifeStart = 0.5f;

		private float coveringTime = 0.3f;

		private MeshRenderer myRenderer;

		private void Start()
		{
		}

		private void Update()
		{
			lifeTime -= Time.deltaTime;
			Color color = myRenderer.material.color;
			color.a = Mathf.Max(0f, (lifeTime - coveringTime) / lifeStart);
			myRenderer.material.color = color;
			if (lifeTime < coveringTime)
			{
				myRenderer.material.SetFloat("_HitShieldCovering", lifeTime / coveringTime);
			}
			if (lifeTime <= 0f)
			{
				UnityEngine.Object.DestroyObject(base.gameObject);
			}
		}

		public void StartHitFX(float time)
		{
			lifeTime = (lifeStart = time);
			lifeTime += coveringTime;
			myRenderer = GetComponent<MeshRenderer>();
			Color color = myRenderer.material.color;
			color.a = 1f;
			myRenderer.material.color = color;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	public class FXVShieldPostprocess : MonoBehaviour
	{
		public float postprocessPower = 3.2f;

		private RenderTexture screenTex;

		private Material blendAddMaterial;

		private Material blurHorizontalMaterial;

		private Material blurVerticalMaterial;

		private List<FXVShield> shieldObjects = new List<FXVShield>();

		private Color clearToTransparentColor;

		private CommandBuffer cmdBuffer;

		private void Awake()
		{
			blendAddMaterial = new Material(Shader.Find("FXV/FXVPostprocessAdd"));
			blendAddMaterial.SetFloat("_ColorMultiplier", postprocessPower);
			blurHorizontalMaterial = new Material(Shader.Find("FXV/FXVPostprocessBlurH"));
			blurVerticalMaterial = new Material(Shader.Find("FXV/FXVPostprocessBlurV"));
			clearToTransparentColor = new Color(0f, 0f, 0f, 0f);
			if (Screen.width > 0)
			{
				screenTex = new RenderTexture(Screen.width, Screen.height, 24);
				screenTex.wrapMode = TextureWrapMode.Clamp;
				screenTex.Create();
				RenderTexture active = RenderTexture.active;
				RenderTexture.active = screenTex;
				GL.Clear(clearDepth: true, clearColor: true, clearToTransparentColor);
				RenderTexture.active = active;
			}
			cmdBuffer = new CommandBuffer();
			cmdBuffer.name = "FXVShieldBlur";
		}

		private void Start()
		{
		}

		private void OnDestroy()
		{
			screenTex = null;
		}

		public void AddShield(FXVShield s)
		{
			if (!shieldObjects.Contains(s))
			{
				shieldObjects.Add(s);
			}
		}

		public void RemoveShield(FXVShield s)
		{
			if (shieldObjects.Contains(s))
			{
				shieldObjects.Remove(s);
			}
		}

		private void OnEnable()
		{
			GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			FXVShield[] array = UnityEngine.Object.FindObjectsOfType<FXVShield>();
			foreach (FXVShield s in array)
			{
				AddShield(s);
			}
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (screenTex == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			if (cmdBuffer == null)
			{
				Graphics.Blit(source, destination);
				return;
			}
			_ = screenTex.width;
			_ = screenTex.height;
			int width = screenTex.width / 2;
			int height = screenTex.height / 2;
			cmdBuffer.Clear();
			cmdBuffer.SetRenderTarget(new RenderTargetIdentifier(screenTex), BuiltinRenderTextureType.CurrentActive);
			cmdBuffer.ClearRenderTarget(clearDepth: false, clearColor: true, clearToTransparentColor);
			foreach (FXVShield shieldObject in shieldObjects)
			{
				shieldObject.RenderPostprocess(cmdBuffer);
			}
			RenderTexture active = RenderTexture.active;
			RenderTexture.active = screenTex;
			Graphics.ExecuteCommandBuffer(cmdBuffer);
			RenderTexture.active = active;
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.Default);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, RenderTextureFormat.Default);
			Graphics.Blit(screenTex, temporary, blurHorizontalMaterial);
			Graphics.Blit(temporary, temporary2, blurVerticalMaterial);
			Graphics.Blit(temporary2, temporary, blurHorizontalMaterial);
			Graphics.Blit(temporary, temporary2, blurVerticalMaterial);
			Graphics.Blit(temporary2, temporary, blurHorizontalMaterial);
			Graphics.Blit(temporary, temporary2, blurVerticalMaterial);
			Graphics.Blit(temporary2, temporary, blurHorizontalMaterial);
			Graphics.Blit(temporary, temporary2, blurVerticalMaterial);
			temporary.DiscardContents();
			RenderTexture.ReleaseTemporary(temporary);
			blendAddMaterial.SetTexture("_BlurTex", temporary2);
			blendAddMaterial.SetTexture("_MainTex", source);
			Graphics.Blit(source, destination, blendAddMaterial);
			temporary2.DiscardContents();
			RenderTexture.ReleaseTemporary(temporary2);
		}
	}
}
namespace GOLF
{
	public class BallBehaviour : MonoBehaviour
	{
		public delegate void HoleIn();

		public delegate void BallDropSound(string str);

		private enum Result
		{
			HoleIn,
			Concede,
			result
		}

		public Rigidbody rigid;

		public bool isFlying;

		private bool isHoleIn;

		private ClubInfo clubInfo;

		private SphereCollider thisCol;

		public PhysicMaterial colGounrdPM;

		public string colGroundTag;

		public bool isGround;

		private IEnumerator m_CheckRunDistance;

		private IEnumerator m_CheckGroundTag;

		[HideInInspector]
		public GameObject ArrowGO;

		private Rigidbody TeeRig;

		private TrailRenderer trailRenderer;

		private Transform BallSpawnTR;

		public static float SlopeAngle;

		public ParticleSystem[] HitPS;

		private AudioSource Audio;

		private Result shootResult;

		[HideInInspector]
		public Vector3 SpinForce;

		public float putterDragValue;

		public float putterLimitVelo;

		public float wedgeLimitVelo;

		public float putterLimitDis;

		public float wedgeLimitDis;

		public float scaler;

		public float scalerApplyVeloMagnitute;

		public static event HoleIn HoleInEvent;

		public static event BallDropSound BallDropSoundEvent;

		private void Awake()
		{
			rigid = GetComponent<Rigidbody>();
			thisCol = GetComponent<SphereCollider>();
			Audio = GetComponent<AudioSource>();
			rigid.maxAngularVelocity = 30f;
			trailRenderer = base.transform.Find("Trail").GetComponent<TrailRenderer>();
			ArrowGO = base.transform.Find("Arrow").gameObject;
			TeeRig = base.transform.Find("Tee").GetComponent<Rigidbody>();
			BallSpawnTR = GameObject.Find("BallSpawnPos").transform;
		}

		private void OnEnable()
		{
			AddEvent();
		}

		private void OnDisable()
		{
			RemoveEvent();
		}

		public void AddEvent()
		{
			cFollower.hitBallEvent += Shoot;
			PlayerBehaviour.ResetBallEvent += ResetBall;
			PlayerBehaviour.ResetBallEvent += ResetBallPos;
			PlayerBehaviour.ChangeStanceEvent += ChangeStance;
			PlayerBehaviour.ChangeStanceEvent += SetPreview;
			PlayerBehaviour.ChangeClubEvent += ChangeClub;
			GameManager.panjungEvent += GameManager_panjungEvent;
			HoleInEvent += holeIn;
		}

		private void GameManager_panjungEvent(PlayerGameInfo _playerGameInfo)
		{
			HitPS[3].Stop();
		}

		public void RemoveEvent()
		{
			cFollower.hitBallEvent -= Shoot;
			PlayerBehaviour.ResetBallEvent -= ResetBall;
			PlayerBehaviour.ResetBallEvent -= ResetBallPos;
			PlayerBehaviour.ChangeStanceEvent -= ChangeStance;
			PlayerBehaviour.ChangeStanceEvent -= SetPreview;
			PlayerBehaviour.ChangeClubEvent -= ChangeClub;
			GameManager.panjungEvent -= GameManager_panjungEvent;
			HoleInEvent -= holeIn;
		}

		private void ChangeStance(Vector3 dir)
		{
			rigid.transform.rotation = Quaternion.LookRotation(dir);
			GetSlopeAngle();
		}

		private void GetSlopeAngle()
		{
			float num = 10f;
			float num2 = 3f;
			Vector3 origin = base.transform.position + base.transform.forward * num2;
			origin.y += num;
			Ray ray = new Ray(origin, Vector3.down);
			int layerMask = 1;
			float maxDistance = 100000f;
			Vector3 vector = Vector3.zero;
			if (Physics.Raycast(ray, out var hitInfo, maxDistance, layerMask) && hitInfo.transform.tag == "land")
			{
				vector = hitInfo.point;
				vector.y += thisCol.radius;
			}
			Vector3 normalized = (vector - base.transform.position).normalized;
			Vector3 forward = base.transform.forward;
			float num3 = Vector3.Dot(normalized, base.transform.up);
			float num4 = Vector3.Angle(normalized, forward);
			if (vector == Vector3.zero)
			{
				num4 = 0f;
			}
			num4 = ((num3 > 0f) ? num4 : (num4 * -1f));
			SlopeAngle = num4;
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other.transform.tag == "HoleIn" && !isHoleIn)
			{
				BallBehaviour.HoleInEvent();
				ballDropSound("hole");
			}
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.transform.tag == "Hazard" || collision.transform.tag == "OB")
			{
				ResetTrail();
				trailRenderer.enabled = false;
			}
		}

		private void holeIn()
		{
			GameManager.instance.currentMap.HoleIePS.Play();
			isHoleIn = true;
			StopAllCoroutines();
			m_CheckGroundTag = null;
			m_CheckRunDistance = null;
			rigid.isKinematic = true;
			ShootResult(Result.HoleIn);
		}

		private void HitParticle(float hitAngle, float accel)
		{
			ParticleSystem particleSystem = null;
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.driver)
			{
				particleSystem = HitPS[0];
			}
			else if (clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.putter)
			{
				particleSystem = ((!(accel > 70f)) ? HitPS[1] : HitPS[4]);
			}
			if (GameManager.instance.playerGameInfo.ColGroundTag == "Bunker")
			{
				particleSystem = ((!(accel > 70f)) ? HitPS[2] : HitPS[5]);
			}
			if (!(particleSystem == null))
			{
				ParticleSystem particleSystem2 = UnityEngine.Object.Instantiate(particleSystem, rigid.position, Quaternion.LookRotation(rigid.transform.forward));
				particleSystem2.gameObject.SetActive(value: true);
				particleSystem2.Play();
				UnityEngine.Object.Destroy(particleSystem2.gameObject, 10f);
			}
		}

		public void NiceShoot()
		{
			HitPS[3].Play();
			int index = UnityEngine.Random.Range(0, 2);
			VoiceManager.instance.PlayVoice("shootResult", index, 1f);
		}

		public void HitParticle(GolfPlayer.EquipmentClubState equipmentClubState, string _colGoundTag, float accel)
		{
			ParticleSystem particleSystem = null;
			switch (equipmentClubState)
			{
			case GolfPlayer.EquipmentClubState.driver:
				particleSystem = HitPS[0];
				break;
			default:
				particleSystem = ((!(accel > 70f)) ? HitPS[1] : HitPS[4]);
				break;
			case GolfPlayer.EquipmentClubState.putter:
				break;
			}
			if (_colGoundTag == "Bunker")
			{
				particleSystem = ((!(accel > 70f)) ? HitPS[2] : HitPS[5]);
			}
			if (!(particleSystem == null))
			{
				ParticleSystem particleSystem2 = UnityEngine.Object.Instantiate(particleSystem, rigid.position, Quaternion.LookRotation(rigid.transform.forward));
				particleSystem2.gameObject.SetActive(value: true);
				particleSystem2.Play();
				UnityEngine.Object.Destroy(particleSystem2.gameObject, 10f);
			}
		}

		public void Shoot(Vector3 velocity, BallQuality ballQuality, float swingAngle, float hitAngle, float accel)
		{
			HitParticle(hitAngle, accel);
			ResetTrail();
			BallPhysics.instance.ClearBallPreView();
			trailRenderer.enabled = true;
			ArrowGO.SetActive(value: false);
			rigid.velocity = velocity;
			TeeRig.isKinematic = false;
			new Vector3(rigid.velocity.x, 10f, rigid.velocity.z);
			Vector3 angularVelocity = Vector3.Cross(velocity.normalized, Vector3.down) * velocity.magnitude;
			rigid.angularVelocity = angularVelocity;
			TeeRig.velocity = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), velocity.y * 0.1f, velocity.z * 0.05f);
			TeeRig.angularVelocity = new Vector3(UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f), UnityEngine.Random.Range(0f, 360f));
			isFlying = true;
			switch (ballQuality)
			{
			case BallQuality.Fade:
				SpinForce = rigid.transform.right * velocity.magnitude * 0.035f;
				break;
			case BallQuality.Draw:
				SpinForce = rigid.transform.right * velocity.magnitude * -0.035f;
				break;
			case BallQuality.Hook:
			case BallQuality.Slice:
				SpinForce = rigid.transform.right * swingAngle * 15f;
				SpinForce *= 0.5f;
				break;
			default:
				SpinForce = Vector3.zero;
				break;
			}
			SpinForce += GameManager.instance.currentMap.windVelocity;
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter || clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.sw)
			{
				SpinForce = Vector3.zero;
				if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter)
				{
					trailRenderer.enabled = false;
				}
			}
			else if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.pw)
			{
				SpinForce *= 0.5f;
			}
			FlyBallInfo previewHitPos = BallPhysics.instance.GetPreviewHitPos(rigid.position, velocity, rigid.drag, SpinForce);
			if (m_CheckRunDistance == null)
			{
				m_CheckRunDistance = IEnum_CheckRunDistance(previewHitPos);
				StartCoroutine(m_CheckRunDistance);
			}
			if (m_CheckGroundTag == null)
			{
				m_CheckGroundTag = IEnum_CheckGroundTag(previewHitPos.hitPointObjTag);
				StartCoroutine(m_CheckGroundTag);
			}
			ballHitSound(clubInfo.equipmentClubState);
		}

		private void FixedUpdate()
		{
			if ((bool)GameManager.instance.currentMap)
			{
				SetSpinForce();
				CheckGroundPhysicsMatrial();
				SetTrailWidth();
			}
		}

		private void SetTrailWidth()
		{
			float num = Vector3.Distance(GameManager.instance.golfPlayers[0].transform.position, rigid.position);
			trailRenderer.startWidth += (float)((double)num * 2.5E-05);
			trailRenderer.endWidth += num * 1E-05f;
		}

		private string GetGroundTag()
		{
			Ray ray = new Ray(rigid.position, Vector3.down * 1000f);
			int layerMask = 2048;
			if (Physics.Raycast(ray, out var hitInfo, 100f, layerMask))
			{
				return hitInfo.transform.tag;
			}
			return null;
		}

		private void CheckGroundPhysicsMatrial()
		{
			Ray ray = new Ray(rigid.position, Vector3.down);
			int layerMask = 1;
			isGround = false;
			float num = thisCol.bounds.extents.y + 0.01f;
			UnityEngine.Debug.DrawRay(ray.origin, ray.direction * num, Color.red, 0.05f);
			if (Physics.Raycast(ray, out var _, num, layerMask))
			{
				isGround = true;
			}
			int layerMask2 = 2048;
			if (Physics.Raycast(ray, out var hitInfo2, 100f, layerMask2) && hitInfo2.collider.material != null)
			{
				colGounrdPM = hitInfo2.collider.material;
				GameManager.instance.currentMap.mapPhysicsMat.dynamicFriction = colGounrdPM.dynamicFriction;
				GameManager.instance.currentMap.mapPhysicsMat.staticFriction = colGounrdPM.staticFriction;
				GameManager.instance.currentMap.mapPhysicsMat.bounciness = colGounrdPM.bounciness;
			}
		}

		private void SetSpinForce()
		{
			if (isFlying)
			{
				rigid.AddForce(SpinForce, ForceMode.Force);
			}
		}

		private IEnumerator IEnum_CheckRunDistance(FlyBallInfo flyBallInfo)
		{
			float time = 0f;
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter)
			{
				time = 100f;
				flyBallInfo.carryPoint = rigid.position;
			}
			Vector3 startPos = rigid.position;
			startPos.y = 0f;
			float carryDis = 0f;
			float radius1 = 0f;
			if (clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.putter && clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.sw)
			{
				thisCol.radius = 0.15f;
			}
			else if (clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.sw)
			{
				thisCol.radius = 0.06f;
			}
			while (time <= flyBallInfo.flyTime)
			{
				time += Time.fixedDeltaTime;
				carryDis = Vector3.Distance(rigid.position, startPos);
				GameInfoUIManager.instance.GetDistanceInfo(carryDis, 0f, rigid.position);
				radius1 = thisCol.bounds.extents.y;
				yield return new WaitForFixedUpdate();
			}
			ballDropSound(colGroundTag);
			isFlying = false;
			if (clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.putter)
			{
				while (rigid.velocity.magnitude > 0.8f)
				{
					float runDis = Vector3.Distance(flyBallInfo.carryPoint, rigid.position);
					GameInfoUIManager.instance.GetDistanceInfo(carryDis, runDis, rigid.position);
					if (BallCaught())
					{
						break;
					}
					if (isGround)
					{
						rigid.drag += clubInfo.runConst * colGounrdPM.dynamicFriction * 0.001f;
						rigid.angularDrag += clubInfo.runConst * colGounrdPM.dynamicFriction * 0.001f;
					}
					yield return new WaitForFixedUpdate();
				}
			}
			else
			{
				while (rigid.velocity.magnitude > 0.1f)
				{
					float runDis2 = Vector3.Distance(flyBallInfo.carryPoint, rigid.position);
					GameInfoUIManager.instance.GetDistanceInfo(carryDis, runDis2, rigid.position);
					if (BallCaught())
					{
						break;
					}
					rigid.drag += colGounrdPM.dynamicFriction * putterDragValue;
					rigid.angularDrag += colGounrdPM.dynamicFriction * putterDragValue;
					yield return new WaitForFixedUpdate();
				}
			}
			if (BallCaught())
			{
				while (rigid.velocity.magnitude > 0.1f && !isHoleIn)
				{
					float runDis3 = Vector3.Distance(flyBallInfo.carryPoint, rigid.position);
					GameInfoUIManager.instance.GetDistanceInfo(carryDis, runDis3, rigid.position);
					rigid.drag += colGounrdPM.dynamicFriction * putterDragValue;
					rigid.angularDrag += colGounrdPM.dynamicFriction * putterDragValue;
					yield return new WaitForFixedUpdate();
				}
			}
			rigid.velocity = Vector3.zero;
			rigid.angularVelocity = Vector3.zero;
			thisCol.radius = 0.043f;
			float y = thisCol.bounds.extents.y;
			if (clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.putter && clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.sw)
			{
				rigid.position += Vector3.down * Mathf.Abs(radius1 - y);
			}
			while (!isGround)
			{
				rigid.drag = 0f;
				rigid.angularDrag = 0f;
				yield return new WaitForFixedUpdate();
			}
			rigid.isKinematic = true;
			m_CheckRunDistance = null;
		}

		private bool IsConcede()
		{
			if (isHoleIn)
			{
				return false;
			}
			float distanceHole = GameManager.instance.GetDistanceHole(rigid.position);
			float concedeRange = GameManager.instance.ConcedeRange;
			if (!(distanceHole < concedeRange))
			{
				return false;
			}
			return true;
		}

		private bool BallCaught()
		{
			float num = ((clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter) ? putterLimitVelo : wedgeLimitVelo);
			if (rigid.velocity.magnitude > num)
			{
				return false;
			}
			Vector3 normalized = (GameManager.instance.currentMap.holePosition - rigid.position).normalized;
			normalized.y = 0f;
			Vector3 normalized2 = rigid.velocity.normalized;
			normalized2.y = 0f;
			if (Vector3.Dot(normalized, normalized2) < 0.95f)
			{
				return false;
			}
			float num2 = Vector3.Distance(rigid.position, GameManager.instance.currentMap.holePosition);
			float num3 = ((clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter) ? putterLimitDis : wedgeLimitDis);
			UnityEngine.Debug.DrawRay(rigid.position, rigid.velocity, Color.red, 0.05f);
			UnityEngine.Debug.DrawRay(rigid.position, normalized * num2, Color.yellow, 0.05f);
			if (num2 < num3)
			{
				float num4 = ((rigid.velocity.magnitude > scalerApplyVeloMagnitute) ? scaler : 1f);
				Vector3 velocity = Vector3.Lerp(rigid.velocity, normalized * rigid.velocity.magnitude * num4, Time.fixedTime * 2f);
				rigid.velocity = velocity;
				if (isGround)
				{
					thisCol.radius = 0.03f;
				}
				return true;
			}
			return false;
		}

		private IEnumerator IEnum_CheckGroundTag(string hitObjTag)
		{
			while (!rigid.isKinematic)
			{
				colGroundTag = GetGroundTag();
				yield return new WaitForFixedUpdate();
			}
			yield return new WaitForSeconds(3f);
			if (IsConcede())
			{
				ShootResult(Result.Concede);
			}
			else
			{
				ShootResult(Result.result);
			}
			m_CheckGroundTag = null;
		}

		private void ShootResult(Result result)
		{
			if (result == Result.result)
			{
				GameManager.instance.Panjung(colGroundTag, rigid.position);
			}
			else
			{
				GameManager.instance.Panjung(result.ToString(), rigid.position);
			}
		}

		private void ChangeClub(ClubInfo _clubInfo)
		{
			clubInfo = _clubInfo;
			if (Vector3.Distance(rigid.position, BallSpawnTR.position) < 0.1f)
			{
				if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.driver)
				{
					TeeRig.gameObject.SetActive(value: true);
					Vector3 position = BallSpawnTR.position;
					position.y += 0.04f;
					base.transform.position = position;
				}
				else
				{
					TeeRig.gameObject.SetActive(value: false);
					rigid.position = BallSpawnTR.position;
				}
				rigid.collisionDetectionMode = ((clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.putter) ? CollisionDetectionMode.ContinuousSpeculative : CollisionDetectionMode.Discrete);
			}
		}

		private void SetPreview(Vector3 stanceDir)
		{
			if (GameManager.instance.gameTurn == GameTurn.my)
			{
				BallPhysics.instance.ClearBallPreView();
				float num = 120f;
				Vector3 vector = stanceDir.normalized * num * clubInfo.power;
				float angle = (clubInfo.lanchAngle + 1f) * (num * 0.01f) + SlopeAngle;
				if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter)
				{
					angle = 10f;
				}
				Vector3 axis = Vector3.Cross(rhs: new Vector3(vector.x, 10f, vector.z), lhs: vector);
				Vector3 velocity = Quaternion.AngleAxis(angle, axis) * vector;
				if (GameManager.instance.playerGameInfo.ColGroundTag == "Rough")
				{
					velocity *= 0.85f;
				}
				else if (GameManager.instance.playerGameInfo.ColGroundTag == "Bunker")
				{
					velocity *= 0.7f;
				}
				bool isDraw = true;
				FlyBallInfo previewHitPos = BallPhysics.instance.GetPreviewHitPos(base.transform.position, velocity, rigid.drag, Vector3.zero, isDraw);
				GameInfoUIManager.instance.GetDistanceInfo(previewHitPos, base.transform.position, clubInfo);
			}
		}

		public void ResetBallPos()
		{
			base.transform.position = BallSpawnTR.position;
			base.transform.rotation = Quaternion.LookRotation(PlayerBehaviour.stanceDirection);
		}

		private void ResetBall()
		{
			if (m_CheckRunDistance != null)
			{
				StopCoroutine(m_CheckRunDistance);
				m_CheckRunDistance = null;
			}
			if (m_CheckGroundTag != null)
			{
				StopCoroutine(m_CheckGroundTag);
				m_CheckGroundTag = null;
			}
			rigid.isKinematic = true;
			rigid.velocity = Vector3.zero;
			rigid.angularVelocity = Vector3.zero;
			rigid.angularDrag = 0.05f;
			rigid.drag = 0.4f;
			rigid.Sleep();
			isHoleIn = false;
			isFlying = false;
			trailRenderer.enabled = false;
			trailRenderer.Clear();
			trailRenderer.startWidth = 0.1f;
			trailRenderer.endWidth = 0f;
			TeeRig.velocity = Vector3.zero;
			TeeRig.isKinematic = true;
			TeeRig.transform.localEulerAngles = new Vector3(-90f, 0f, 0f);
			TeeRig.transform.localPosition = new Vector3(0f, -0.09f, 0f);
			ArrowGO.SetActive(GameManager.instance.gameTurn == GameTurn.my);
		}

		public void ResetTrail()
		{
			trailRenderer.Clear();
			trailRenderer.startWidth = 0.1f;
			trailRenderer.endWidth = 0f;
		}

		public void SetTrailAndArrow(bool isPutter)
		{
			ResetTrail();
			trailRenderer.enabled = !isPutter;
			ArrowGO.SetActive(value: false);
		}

		public void ballHitSound(GolfPlayer.EquipmentClubState equipmentClubState)
		{
			string text = null;
			switch (equipmentClubState)
			{
			case GolfPlayer.EquipmentClubState.driver:
				text = "drive";
				break;
			case GolfPlayer.EquipmentClubState.wood3:
			case GolfPlayer.EquipmentClubState.wood5:
				text = "wood";
				break;
			case GolfPlayer.EquipmentClubState.iron4:
			case GolfPlayer.EquipmentClubState.iron5:
			case GolfPlayer.EquipmentClubState.iron6:
			case GolfPlayer.EquipmentClubState.iron7:
			case GolfPlayer.EquipmentClubState.iron8:
			case GolfPlayer.EquipmentClubState.iron9:
				text = "iron";
				break;
			case GolfPlayer.EquipmentClubState.pw:
			case GolfPlayer.EquipmentClubState.sw:
				text = "wedge";
				break;
			case GolfPlayer.EquipmentClubState.putter:
				text = "putter";
				break;
			}
			Audio.spatialBlend = 0f;
			Audio.PlayOneShot(TENNIS.SoundManager.instance.GetSoundClip(text));
		}

		private void ballDropSound(string str)
		{
			Audio.spatialBlend = 0.5f;
			if (TENNIS.SoundManager.instance.GetSoundClip(str) != null)
			{
				Audio.PlayOneShot(TENNIS.SoundManager.instance.GetSoundClip(str));
			}
			BallBehaviour.BallDropSoundEvent?.Invoke(str);
		}

		public void ReceiveBallDropSound(string str)
		{
			if (str == "hole")
			{
				GameManager.instance.currentMap.HoleIePS.Play();
			}
			Audio.spatialBlend = 0.5f;
			if (TENNIS.SoundManager.instance.GetSoundClip(str) != null)
			{
				Audio.PlayOneShot(TENNIS.SoundManager.instance.GetSoundClip(str));
			}
		}
	}
	public struct FlyBallInfo
	{
		public Vector3 carryPoint;

		public string hitPointObjTag;

		public float carryRange;

		public float flyTime;

		public float carryPointHeightToStance;
	}
	public class BallPhysics : MonoBehaviour
	{
		private LineRenderer lineRenderer;

		public static BallPhysics instance;

		public float PuttingRevieseScaler;

		public float SadnWedgeRevieseScaler;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
			lineRenderer = GetComponent<LineRenderer>();
		}

		public static Vector3 getVelocityAtoBSpin(Vector3 A, Vector3 B, float t, Vector3 spin)
		{
			Vector3 vector = A;
			Vector3 vector2 = B;
			float num = 0f;
			float num2 = vector2.x - vector.x;
			float num3 = vector2.z - vector.z;
			float x = num2 / t;
			_ = num3 / t;
			float z = vector.z;
			float z2 = (vector2.z - z + spin.z * Mathf.Pow(t, 2f) / 2f) / t;
			float num4 = 9.81f - spin.y;
			float y = vector.y;
			float y2 = (vector2.y - y + num4 * Mathf.Pow(t, 2f) / 2f) / t;
			return new Vector3(x, y2, z2) * (1f + num * (t * (1.1f + Mathf.Pow(num, 2f))));
		}

		public static Vector3 GetVelocity(Vector3 Departure, Vector3 Arrival, float time, bool isGravity = true)
		{
			Vector3 result = (Arrival - Departure) / time;
			if (isGravity)
			{
				result.y -= Physics.gravity.y * time * 0.5f;
			}
			return result;
		}

		public FlyBallInfo GetPreviewHitPos(Vector3 startPos, Vector3 velocity, float _drag, Vector3 spinForce, bool isDraw = false)
		{
			FlyBallInfo result = default(FlyBallInfo);
			List<Vector3> list = new List<Vector3>();
			float num = 0f;
			bool flag = true;
			Vector3 vector = startPos;
			float fixedDeltaTime = Time.fixedDeltaTime;
			Vector3 vector2 = Physics.gravity * fixedDeltaTime * fixedDeltaTime;
			float num2 = 1f - fixedDeltaTime * _drag;
			Vector3 vector3 = spinForce * fixedDeltaTime * fixedDeltaTime;
			Vector3 vector4 = velocity * fixedDeltaTime;
			while (flag)
			{
				if (isDraw)
				{
					lineRenderer.positionCount = list.Count + 1;
					lineRenderer.SetPosition(list.Count, vector);
				}
				num += Time.fixedDeltaTime;
				vector4 += vector3;
				vector4 += vector2;
				vector4 *= num2;
				vector += vector4;
				list.Add(vector);
				if (list.Count >= 2)
				{
					Vector3 vector5 = list[list.Count - 2];
					Vector3 vector6 = list[list.Count - 1] - vector5;
					if (!isDraw)
					{
						UnityEngine.Debug.DrawRay(vector5, vector6, Color.red, 10f);
						lineRenderer.positionCount = 0;
					}
					if (Physics.Raycast(vector5, vector6, out var hitInfo, vector6.magnitude))
					{
						result.carryPoint = hitInfo.point;
						result.flyTime = num;
						result.hitPointObjTag = hitInfo.transform.tag;
						float carryRange = Vector3.Distance(startPos, hitInfo.point);
						result.carryRange = carryRange;
						float carryPointHeightToStance = hitInfo.point.y - startPos.y;
						result.carryPointHeightToStance = carryPointHeightToStance;
						return result;
					}
					if (list.Count > 500)
					{
						break;
					}
				}
			}
			return result;
		}

		public void ClearBallPreView()
		{
			lineRenderer.positionCount = 0;
		}

		public Vector3 PuttingReviseVelo(Vector3 velo, Vector3 right, Vector3 up)
		{
			Vector3 stanceDirection = PlayerBehaviour.stanceDirection;
			Vector3 normalized = velo.normalized;
			normalized.y = 0f;
			float num = Vector3.Angle(stanceDirection, normalized) * PuttingRevieseScaler;
			float num2 = Vector3.Dot(right, normalized);
			if (num2 != 0f)
			{
				num2 /= Mathf.Abs(num2) * -1f;
			}
			return Quaternion.AngleAxis(num * num2, up) * normalized * velo.magnitude;
		}

		public Vector3 SandWedgeReviseVelo(Vector3 velo, Vector3 right, Vector3 up)
		{
			Vector3 stanceDirection = PlayerBehaviour.stanceDirection;
			Vector3 normalized = velo.normalized;
			normalized.y = 0f;
			float num = Vector3.Angle(stanceDirection, normalized) * SadnWedgeRevieseScaler;
			float num2 = Vector3.Dot(right, normalized);
			if (num2 != 0f)
			{
				num2 /= Mathf.Abs(num2) * -1f;
			}
			Vector3 result = Quaternion.AngleAxis(num * num2, up) * normalized * velo.magnitude;
			result.y = velo.y;
			return result;
		}

		public Vector3 ReviseVelo(Vector3 velo, Vector3 right, Vector3 up, float ReviseValue)
		{
			Vector3 stanceDirection = PlayerBehaviour.stanceDirection;
			Vector3 normalized = velo.normalized;
			normalized.y = 0f;
			float num = Vector3.Angle(stanceDirection, normalized);
			if (num == 0f)
			{
				return velo;
			}
			num *= ReviseValue;
			float num2 = Vector3.Dot(right, normalized);
			if (num2 != 0f)
			{
				num2 /= Mathf.Abs(num2) * -1f;
			}
			num *= num2;
			Vector3 vector = Quaternion.AngleAxis(num, up) * normalized * velo.magnitude;
			vector.y = velo.y;
			UnityEngine.Debug.DrawRay(base.transform.position, stanceDirection * 10f, Color.white, 30f);
			UnityEngine.Debug.DrawRay(base.transform.position, vector * 10f, Color.red, 30f);
			return vector;
		}
	}
	public class Caddybag : MonoBehaviour
	{
		private Animator anim;

		private Rigidbody rigid;

		private Vector3 localPos;

		private Vector3 localEuler;

		private void OnEnable()
		{
			PlayerBehaviour.ChangeClubEvent += ChangeClub;
			PlayerBehaviour.ResetBallEvent += ResetPosition;
		}

		private void OnDisable()
		{
			PlayerBehaviour.ChangeClubEvent -= ChangeClub;
			PlayerBehaviour.ResetBallEvent -= ResetPosition;
		}

		private void Start()
		{
			anim = GetComponent<Animator>();
			rigid = GetComponent<Rigidbody>();
			StartCoroutine(IEnum_useGravity());
			localPos = base.transform.localPosition;
			localEuler = base.transform.localEulerAngles;
		}

		private IEnumerator IEnum_useGravity()
		{
			while (!GameManager.instance.isMapLoaded)
			{
				yield return null;
			}
			rigid.isKinematic = false;
			rigid.useGravity = true;
		}

		private void Update()
		{
			if (rigid.velocity.magnitude > 1.5f)
			{
				rigid.velocity = rigid.velocity.normalized * 1.5f;
			}
		}

		private void ChangeClub(ClubInfo clubInfo)
		{
			int equipmentClubState = (int)clubInfo.equipmentClubState;
			anim.SetInteger("clubIndex", equipmentClubState);
		}

		private void ResetPosition()
		{
			base.transform.localPosition = localPos;
			base.transform.localEulerAngles = localEuler;
		}
	}
	public class ClubInfo : MonoBehaviour
	{
		public GolfPlayer.EquipmentClubState equipmentClubState;

		public float power;

		public float lanchAngle;

		public Vector2 stancePos;

		public Vector3 followerPos;

		public Vector3 followerEuler;

		public Vector3 ColSize;

		public float runConst;

		public float runRange;

		public int Range;

		private CapsuleCollider thisCol;

		private Vector3 originPos;

		private bool isPress;

		private bool isChange = true;

		private Material thisMat;

		public Material aphaMat;

		private void Start()
		{
			thisCol = base.transform.Find("Col").GetComponent<CapsuleCollider>();
			originPos = base.transform.localPosition;
			thisMat = GetComponent<MeshRenderer>().material;
		}

		private void DrawRay()
		{
			Vector3 position = base.transform.parent.position;
			Ray ray = new Ray(position, base.transform.forward);
			UnityEngine.Debug.DrawRay(ray.origin, ray.direction * thisCol.height, Color.white, 0.05f);
			int layerMask = 1;
			float num = 0f;
			if (Physics.Raycast(ray, out var hitInfo, thisCol.height, layerMask))
			{
				_ = hitInfo.distance;
				num = thisCol.height - hitInfo.distance;
				Vector3 vector = base.transform.InverseTransformDirection(base.transform.forward);
				base.transform.localPosition = originPos + vector * num * -1f;
			}
			else
			{
				base.transform.localPosition = originPos;
			}
		}

		private void ChangeShader()
		{
			isPress = PlayerBehaviour.isPressTrigger;
			if (isPress != isChange)
			{
				isChange = isPress;
				GetComponent<MeshRenderer>().material = (isPress ? thisMat : aphaMat);
			}
		}

		private void Update()
		{
			DrawRay();
			ChangeShader();
		}
	}
	public class FlagLookAt : MonoBehaviour
	{
		public GameObject FlagGO;

		private bool isChange;

		private void Update()
		{
			if (!(Camera.main == null))
			{
				Vector3 normalized = (Camera.main.transform.position - base.transform.position).normalized;
				normalized.y = 0f;
				Quaternion rotation = Quaternion.LookRotation(normalized);
				base.transform.rotation = rotation;
			}
		}
	}
	public class GameInfoUIManager : MonoBehaviour
	{
		public delegate void Panjung(string str);

		public delegate void Concede(bool isConcede);

		public delegate void DistanceInfo(string[] Infos);

		public delegate void CarryInfo(string[] Infos);

		public delegate void GoToTitle();

		public delegate void TimeInfo(string TimeString);

		public static GameInfoUIManager instance;

		private MapInfomation mapInfo;

		public Image greenImage;

		public Image minimapImage;

		public TextMesh mapInfoText;

		public PlayerGameInfo playerGameInfo;

		public TextMesh[] player1GameinfoTexts;

		public TextMesh[] player2GameinfoTexts;

		public TextMesh[] MinimapInfoText;

		public TextMeshPro MinimapHallInfoText;

		public GameObject MinimapInfoGO;

		public Transform UIRoot;

		public Transform DistanceInfoUI;

		public Transform CarryRunInfoUI;

		public TextMesh[] previewDisInfoText;

		public TextMesh[] previewCarryInfoText;

		public SpriteRenderer ShootPlace;

		public Sprite[] ShootPlaceSprites;

		public TextMeshPro[] ShootPlaceTexts;

		public SpriteRenderer Club;

		public Sprite[] Clubs;

		public TextMeshPro[] ClubsTexts;

		public Transform windArrowTR;

		public TextMesh windText;

		public TextMeshPro[] PanjungTexts;

		public TextMeshPro ConcedeText;

		public TextMeshPro MulliganText;

		private string strformat = "0.#";

		private AudioSource Audio;

		public Sprite[] highlights;

		public GameObject HelpGO;

		public CanvasGroup MulliganCG;

		public InputDeviceState RightInputDeviceState;

		public InputDeviceState LeftInputDeviceState;

		private InputDeviceState inputDeviceState;

		public TMP_Asset[] TMP_assets;

		public RPCManager rpcM;

		public SpriteRenderer Player1Pannel;

		public SpriteRenderer Player2Pannel;

		private string oldPanjung;

		public static event Panjung PanjungEvent;

		public static event Concede ConcedeEvent;

		public static event DistanceInfo DistanceInfoEvent;

		public static event CarryInfo CarryInfoEvent;

		public static event GoToTitle GoTitleEvent;

		public static event TimeInfo TimeInfoEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			cFollower.hitBallEvent += CFollower_hitBallEvent;
			PlayerBehaviour.ChangeHandlderEvent += PlayerBehaviour_ChangeHandlderEvent;
		}

		private void OnDisable()
		{
			cFollower.hitBallEvent -= CFollower_hitBallEvent;
			PlayerBehaviour.ChangeHandlderEvent -= PlayerBehaviour_ChangeHandlderEvent;
		}

		private void CFollower_hitBallEvent(Vector3 velocity, BallQuality ballQuality, float swingAngle, float hitAngle, float accel)
		{
			if (HelpGO.activeInHierarchy)
			{
				HelpGO.SetActive(value: false);
			}
		}

		private void PlayerBehaviour_ChangeHandlderEvent(bool isLeftHand, InputDeviceState _inputDeviceState)
		{
			if (isLeftHand)
			{
				minimapImage.transform.parent.localPosition = new Vector3(-0.715f, 0f, 0f);
				minimapImage.transform.parent.localEulerAngles = new Vector3(0f, 90f, 0f);
				minimapImage.transform.localPosition = new Vector3(-1.575f, 1.33f, -1.894f);
				minimapImage.transform.localEulerAngles = new Vector3(0f, -144f, 0f);
				HelpGO.transform.localPosition = new Vector3(1.119f, 2.246f, -2.094f);
				HelpGO.transform.localEulerAngles = new Vector3(0f, -193.259f, 0f);
				UIRoot.transform.localPosition = new Vector3(-1.2f, 1.35f, 1.73f);
				UIRoot.transform.localEulerAngles = new Vector3(0f, -25f, 0f);
			}
			else
			{
				minimapImage.transform.parent.localPosition = new Vector3(0.715f, 0f, 0f);
				minimapImage.transform.parent.localEulerAngles = new Vector3(0f, -90f, 0f);
				minimapImage.transform.localPosition = new Vector3(1.139f, 1.33f, -1.894f);
				minimapImage.transform.localEulerAngles = new Vector3(0f, 144f, 0f);
				HelpGO.transform.localPosition = new Vector3(-1.52f, 2.246f, -1.98f);
				HelpGO.transform.localEulerAngles = new Vector3(0f, 193.259f, 0f);
				UIRoot.transform.localPosition = new Vector3(1.2f, 1.35f, 1.73f);
				UIRoot.transform.localEulerAngles = new Vector3(0f, 25f, 0f);
			}
			inputDeviceState = _inputDeviceState;
		}

		private void Start()
		{
			Audio = GetComponent<AudioSource>();
			if (PublicGameUIManager.gameSetting.IsRightHanded())
			{
				inputDeviceState = RightInputDeviceState;
			}
			else
			{
				inputDeviceState = LeftInputDeviceState;
			}
		}

		private void SetTextMeshProFont(LanguageState languageState)
		{
			UnityEngine.Debug.Log("123123" + languageState);
			StaticLocalizationCtrl_TextMesh.DataSlot_Pro[] dataSlots_pro = SingletonBase.Singleton<StaticLocalizationCtrl_TextMesh>.GetInstance.dataSlots_pro;
			TextMeshPro[] array = new TextMeshPro[dataSlots_pro.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = dataSlots_pro[i].ui;
			}
			if (languageState == LanguageState.schinese)
			{
				for (int j = 0; j < array.Length; j++)
				{
					array[j].font = (TMP_FontAsset)TMP_assets[0];
				}
				MinimapHallInfoText.font = (TMP_FontAsset)TMP_assets[0];
				MinimapHallInfoText.text = "H" + mapInfo.hallNumber + " " + GameSettingCtrl.GetLocalizationText("0150") + mapInfo.parScore;
				if (player1GameinfoTexts[2].text.Contains("yd"))
				{
					player1GameinfoTexts[2].text = player1GameinfoTexts[2].text.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (player2GameinfoTexts[2].text.Contains("yd"))
				{
					player2GameinfoTexts[2].text = player2GameinfoTexts[2].text.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
				}
				for (int k = 0; k < previewCarryInfoText.Length; k++)
				{
					if (previewCarryInfoText[k].text.Contains("yd"))
					{
						previewCarryInfoText[k].text = previewCarryInfoText[k].text.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
					}
				}
				for (int l = 0; l < previewDisInfoText.Length; l++)
				{
					if (previewDisInfoText[l].text.Contains("yd"))
					{
						previewDisInfoText[l].text = previewDisInfoText[l].text.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
					}
				}
				for (int m = 0; m < MinimapInfoText.Length; m++)
				{
					if (MinimapInfoText[m].text.Contains("yd"))
					{
						MinimapInfoText[m].text = MinimapInfoText[m].text.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
					}
					if (MinimapInfoText[m].text.Contains("over"))
					{
						MinimapInfoText[m].text = MinimapInfoText[m].text.Replace("over", GameSettingCtrl.GetLocalizationText("0140"));
					}
				}
			}
			else
			{
				for (int n = 0; n < array.Length; n++)
				{
					array[n].font = (TMP_FontAsset)TMP_assets[1];
				}
				MinimapHallInfoText.font = (TMP_FontAsset)TMP_assets[1];
				MinimapHallInfoText.text = "H" + mapInfo.hallNumber + " " + GameSettingCtrl.GetLocalizationText("0150") + mapInfo.parScore;
				if (player1GameinfoTexts[2].text.Contains("码"))
				{
					player1GameinfoTexts[2].text = player1GameinfoTexts[2].text.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (player2GameinfoTexts[2].text.Contains("码"))
				{
					player2GameinfoTexts[2].text = player2GameinfoTexts[2].text.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
				}
				for (int num = 0; num < previewCarryInfoText.Length; num++)
				{
					if (previewCarryInfoText[num].text.Contains("码"))
					{
						previewCarryInfoText[num].text = previewCarryInfoText[num].text.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
					}
				}
				for (int num2 = 0; num2 < previewDisInfoText.Length; num2++)
				{
					if (previewDisInfoText[num2].text.Contains("码"))
					{
						previewDisInfoText[num2].text = previewDisInfoText[num2].text.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
					}
				}
				for (int num3 = 0; num3 < MinimapInfoText.Length; num3++)
				{
					if (MinimapInfoText[num3].text.Contains("码"))
					{
						MinimapInfoText[num3].text = MinimapInfoText[num3].text.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
					}
					if (MinimapInfoText[num3].text.Contains("超过"))
					{
						MinimapInfoText[num3].text = MinimapInfoText[num3].text.Replace("超过", GameSettingCtrl.GetLocalizationText("0140"));
					}
				}
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				GetPlayer1GameInfo(GameManager.instance.playerGameInfo);
			}
			else
			{
				rpcM.ChangeLange();
			}
		}

		public void GetMapInfo(MapInfomation _mapInfo)
		{
			mapInfo = _mapInfo;
			minimapImage.sprite = mapInfo.minimapImage;
			greenImage.sprite = mapInfo.greenImage;
			mapInfoText.text = GameSettingCtrl.GetLocalizationText("0062") + _mapInfo.hallNumber + " " + GameSettingCtrl.GetLocalizationText("0063") + _mapInfo.parScore + " " + translateYD(_mapInfo.HoleDistance.ToString(strformat) + "m");
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent((Action)delegate
			{
				mapInfoText.text = GameSettingCtrl.GetLocalizationText("0062") + _mapInfo.hallNumber + " " + GameSettingCtrl.GetLocalizationText("0063") + _mapInfo.parScore + " " + translateYD(_mapInfo.HoleDistance.ToString(strformat) + "m");
			});
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				player2GameinfoTexts[0].transform.parent.gameObject.SetActive(value: true);
			}
			else
			{
				previewDisInfoText[3].gameObject.SetActive(value: false);
			}
			MinimapHallInfoText.text = "H" + mapInfo.hallNumber + " " + GameSettingCtrl.GetLocalizationText("0150") + mapInfo.parScore;
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetTextMeshProFont);
		}

		public void GetPlayer1GameInfo(PlayerGameInfo _playerGameInfo)
		{
			player1GameinfoTexts[0].text = _playerGameInfo.number.ToString();
			player1GameinfoTexts[1].text = _playerGameInfo.name.ToString();
			player1GameinfoTexts[2].text = translateYD(_playerGameInfo.reMainDistance.ToString(strformat) + "m");
			string text;
			if (_playerGameInfo.gameTurn == GameTurn.end)
			{
				UnityEngine.Debug.Log("GameTurn : " + _playerGameInfo.gameTurn);
				text = _playerGameInfo.Score.ToString();
				if (_playerGameInfo.Score > 0)
				{
					text = "+" + text;
				}
			}
			else
			{
				UnityEngine.Debug.Log("GameTurn : " + _playerGameInfo.gameTurn);
				text = GameSettingCtrl.GetLocalizationText("0" + (_playerGameInfo.StrokeCount + 127));
			}
			player1GameinfoTexts[3].text = text;
		}

		public void GetPlayer2GameInfo(PlayerGameInfo _playerGameInfo)
		{
			player2GameinfoTexts[0].text = _playerGameInfo.number.ToString();
			player2GameinfoTexts[1].text = _playerGameInfo.name.ToString();
			player2GameinfoTexts[2].text = translateYD(_playerGameInfo.reMainDistance.ToString(strformat) + "m");
			string text;
			if (_playerGameInfo.gameTurn == GameTurn.end)
			{
				text = _playerGameInfo.Score.ToString();
				if (_playerGameInfo.Score > 0)
				{
					text = "+" + text;
				}
			}
			else
			{
				UnityEngine.Debug.Log("GameTurn : " + _playerGameInfo.gameTurn);
				text = GameSettingCtrl.GetLocalizationText("0" + (_playerGameInfo.StrokeCount + 127));
			}
			player2GameinfoTexts[3].text = text;
			if (GameManager.instance.gameTurn == GameTurn.my)
			{
				Player1Pannel.sprite = ((playerGameInfo.number == 1) ? highlights[0] : highlights[1]);
				Player2Pannel.sprite = ((playerGameInfo.number == 1) ? highlights[1] : highlights[0]);
			}
			else
			{
				Player1Pannel.sprite = ((playerGameInfo.number == 1) ? highlights[1] : highlights[0]);
				Player2Pannel.sprite = ((playerGameInfo.number == 1) ? highlights[0] : highlights[1]);
			}
		}

		public void SetTimeLimit(float timeValue)
		{
			float shootTimeLimit = GameManager.instance.ShootTimeLimit;
			string text = "";
			text = ((shootTimeLimit * 0.3f > timeValue) ? ("<color=red>" + timeValue.ToString("0") + "</color>") : ((!(shootTimeLimit * 0.6f > timeValue)) ? ("<color=white>" + timeValue.ToString("0") + "</color>") : ("<color=yellow>" + timeValue.ToString("0") + "</color>")));
			previewDisInfoText[3].text = text;
			GameInfoUIManager.TimeInfoEvent?.Invoke(text);
		}

		public void ReceiveTimeLimit(string TimeString)
		{
			previewDisInfoText[3].text = TimeString;
		}

		public void GetDistanceInfo(FlyBallInfo flyinfo, Vector3 ballPos, ClubInfo clubInfo)
		{
			float num = (float)clubInfo.Range + clubInfo.runRange + flyinfo.carryPointHeightToStance * -1f;
			float num2 = ((playerGameInfo.StrokeCount == 0) ? GameManager.instance.currentMap.HoleDistance : GameManager.instance.GetDistanceHole(ballPos));
			float num3 = num2 - num;
			MinimapInfoGO.SetActive(!(num2 < 80f));
			previewDisInfoText[0].text = translateYD(num2.ToString(strformat) + "m");
			previewDisInfoText[1].text = ((clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.putter) ? translateYD(num.ToString(strformat) + "m") : "-");
			float num4 = ((clubInfo.equipmentClubState != GolfPlayer.EquipmentClubState.putter) ? flyinfo.carryPointHeightToStance : (GameManager.instance.currentMap.holePosition.y - ballPos.y));
			float num5 = Mathf.Abs(num4);
			string text = ((num4 > 0f) ? ("<color=red>" + translateYD($"+{num5:0.00}m ") + "</color>") : ("<color=blue>" + translateYD($"-{num5:0.00}m ") + "</color>"));
			Vector3.Distance(ballPos, flyinfo.carryPoint);
			previewDisInfoText[2].text = text;
			Vector3 normalized = (flyinfo.carryPoint - base.transform.position).normalized;
			_ = base.transform.position + normalized * 2f;
			CarryRunInfoUI.gameObject.SetActive(value: false);
			DistanceInfoUI.gameObject.SetActive(value: true);
			string text2 = translateYD(num3.ToString(strformat) + "m");
			if (num3 < 0f)
			{
				MinimapInfoText[0].fontSize = 70;
				num3 = Mathf.Abs(num3);
				text2 = GameSettingCtrl.GetLocalizationText("0140") + " " + translateYD(num3.ToString(strformat) + "m");
			}
			else
			{
				MinimapInfoText[0].fontSize = 90;
			}
			MinimapInfoText[0].text = text2;
			MinimapInfoText[1].text = translateYD(num.ToString(strformat) + "m");
			MinimapInfoText[2].text = text;
			string[] infos = new string[6]
			{
				previewDisInfoText[0].text,
				previewDisInfoText[1].text,
				previewDisInfoText[2].text,
				MinimapInfoText[0].text,
				MinimapInfoText[1].text,
				MinimapInfoText[2].text
			};
			GameInfoUIManager.DistanceInfoEvent?.Invoke(infos);
		}

		public void ReceiveDistanceInfo(string[] Infos)
		{
			CarryRunInfoUI.gameObject.SetActive(value: false);
			DistanceInfoUI.gameObject.SetActive(value: true);
			for (int i = 0; i < Infos.Length; i++)
			{
				if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
				{
					if (Infos[i].Contains("yd"))
					{
						Infos[i] = Infos[i].Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
					}
					if (Infos[i].Contains("over"))
					{
						Infos[i] = Infos[i].Replace("over", GameSettingCtrl.GetLocalizationText("0140"));
					}
				}
				else
				{
					if (Infos[i].Contains("码"))
					{
						Infos[i] = Infos[i].Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
					}
					if (Infos[i].Contains("超过"))
					{
						Infos[i] = Infos[i].Replace("超过", GameSettingCtrl.GetLocalizationText("0140"));
					}
				}
			}
			previewDisInfoText[0].text = Infos[0];
			previewDisInfoText[1].text = Infos[1];
			previewDisInfoText[2].text = Infos[2];
			MinimapInfoText[0].text = Infos[3];
			MinimapInfoText[0].fontSize = ((MinimapInfoText[0].text.Length >= 8) ? 70 : 90);
			MinimapInfoText[1].text = Infos[4];
			MinimapInfoText[2].text = Infos[5];
		}

		public void GetDistanceInfo(float _carryDis, float _runDis, Vector3 ballPos)
		{
			CarryRunInfoUI.gameObject.SetActive(value: true);
			DistanceInfoUI.gameObject.SetActive(value: false);
			previewCarryInfoText[0].text = translateYD(_carryDis.ToString(strformat) + "m");
			previewCarryInfoText[1].text = translateYD(_runDis.ToString(strformat) + "m");
			previewCarryInfoText[2].text = translateYD((_carryDis + _runDis).ToString(strformat) + "m");
			previewCarryInfoText[3].text = translateYD(GameManager.instance.GetDistanceHole(ballPos).ToString(strformat) + "m");
			if (playerGameInfo.StrokeCount == 0)
			{
				playerGameInfo.Longist = _carryDis + _runDis;
			}
			string[] infos = new string[4]
			{
				previewCarryInfoText[0].text,
				previewCarryInfoText[1].text,
				previewCarryInfoText[2].text,
				previewCarryInfoText[3].text
			};
			GameInfoUIManager.CarryInfoEvent?.Invoke(infos);
		}

		public void ReceiveCarryInfo(string carry, string run, string total, string remainDis)
		{
			CarryRunInfoUI.gameObject.SetActive(value: true);
			DistanceInfoUI.gameObject.SetActive(value: false);
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				if (carry.Contains("yd"))
				{
					carry = carry.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (run.Contains("yd"))
				{
					run = run.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (total.Contains("yd"))
				{
					total = total.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (remainDis.Contains("yd"))
				{
					remainDis = remainDis.Replace("yd", GameSettingCtrl.GetLocalizationText("0126"));
				}
			}
			else
			{
				if (carry.Contains("码"))
				{
					carry = carry.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (run.Contains("码"))
				{
					run = run.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (total.Contains("码"))
				{
					total = total.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
				}
				if (remainDis.Contains("码"))
				{
					remainDis = remainDis.Replace("码", GameSettingCtrl.GetLocalizationText("0126"));
				}
			}
			previewCarryInfoText[0].text = carry;
			previewCarryInfoText[1].text = run;
			previewCarryInfoText[2].text = total;
			previewCarryInfoText[3].text = remainDis;
		}

		public void ShootPlaceUI(string colBallTag)
		{
			switch (colBallTag)
			{
			case "Green":
				if (playerGameInfo.StrokeCount == 0)
				{
					for (int l = 0; l < ShootPlaceTexts.Length; l++)
					{
						ShootPlaceTexts[l].gameObject.SetActive(l == 0);
					}
					ShootPlace.sprite = ShootPlaceSprites[0];
				}
				else
				{
					for (int m = 0; m < ShootPlaceTexts.Length; m++)
					{
						ShootPlaceTexts[m].gameObject.SetActive(m == 1);
					}
					ShootPlace.sprite = ShootPlaceSprites[1];
				}
				break;
			case "Fairway":
			{
				ShootPlace.sprite = ShootPlaceSprites[2];
				for (int j = 0; j < ShootPlaceTexts.Length; j++)
				{
					ShootPlaceTexts[j].gameObject.SetActive(j == 2);
				}
				break;
			}
			case "Rough":
			{
				ShootPlace.sprite = ShootPlaceSprites[3];
				for (int k = 0; k < ShootPlaceTexts.Length; k++)
				{
					ShootPlaceTexts[k].gameObject.SetActive(k == 3);
				}
				break;
			}
			case "Bunker":
			{
				ShootPlace.sprite = ShootPlaceSprites[4];
				for (int i = 0; i < ShootPlaceTexts.Length; i++)
				{
					ShootPlaceTexts[i].gameObject.SetActive(i == 4);
				}
				break;
			}
			}
		}

		public void ClubUI(int clubIndex)
		{
			Club.sprite = Clubs[clubIndex];
			for (int i = 0; i < Clubs.Length; i++)
			{
				ClubsTexts[i].gameObject.SetActive(i == clubIndex);
			}
			ChangeClubSound();
		}

		public void SetResultInfo(bool isSuc)
		{
			StartCoroutine(IEnum_Fade(isSuc));
		}

		public string GetScoreLocalizationText(Score score)
		{
			return score switch
			{
				Score.HoleInOne => GameSettingCtrl.GetLocalizationText("0071"), 
				Score.Albatross => GameSettingCtrl.GetLocalizationText("0072"), 
				Score.Eagle => GameSettingCtrl.GetLocalizationText("0073"), 
				Score.Birdie => GameSettingCtrl.GetLocalizationText("0074"), 
				Score.Par => GameSettingCtrl.GetLocalizationText("0063"), 
				Score.Bogey => GameSettingCtrl.GetLocalizationText("0075"), 
				Score.DoubleBogey => GameSettingCtrl.GetLocalizationText("0076"), 
				Score.TripleBogey => GameSettingCtrl.GetLocalizationText("0077"), 
				Score.QuadruleBogey => GameSettingCtrl.GetLocalizationText("0078"), 
				Score.DoublePar => GameSettingCtrl.GetLocalizationText("0079"), 
				_ => "noting", 
			};
		}

		private IEnumerator IEnum_Fade(bool isSuc)
		{
			PublicGameUIManager.GetInstance.OpenResultBoard(GetScoreLocalizationText(GameManager.instance.score), new string[8]
			{
				GameSettingCtrl.GetLocalizationText("0039"),
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level.ToString(),
				GameSettingCtrl.GetLocalizationText("0068"),
				playerGameInfo.StrokeCount.ToString(strformat),
				GameSettingCtrl.GetLocalizationText("0069"),
				translateYD(playerGameInfo.Longist.ToString(strformat)),
				GameSettingCtrl.GetLocalizationText("0070"),
				playerGameInfo.PuttingCount.ToString(strformat)
			}, isSuc);
			if (isSuc)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
			}
			yield return null;
		}

		public void SetResultInfo(PlayerGameInfo otherGameInfo)
		{
			StartCoroutine(IEnum_Fade(otherGameInfo));
		}

		private IEnumerator IEnum_Fade(PlayerGameInfo otherGameInfo)
		{
			int winnerPlayer = ((playerGameInfo.Score < otherGameInfo.Score) ? ((!PhotonNetwork.IsMasterClient) ? 1 : 0) : ((playerGameInfo.Score <= otherGameInfo.Score) ? 2 : (PhotonNetwork.IsMasterClient ? 1 : 0)));
			Score score = (Score)playerGameInfo.Score;
			Score score2 = (Score)otherGameInfo.Score;
			if (PhotonNetwork.IsMasterClient)
			{
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					GetScoreLocalizationText(score),
					GetScoreLocalizationText(score2)
				}, winnerPlayer);
			}
			else
			{
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2]
				{
					GetScoreLocalizationText(score2),
					GetScoreLocalizationText(score)
				}, winnerPlayer);
			}
			yield return null;
		}

		public void GameExit()
		{
			UnityEngine.Application.Quit();
		}

		public void GoTitle()
		{
			UnityEngine.Debug.Log("Gotitle");
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			GameInfoUIManager.GoTitleEvent?.Invoke();
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Multi)
			{
				SceneManager.LoadScene("Scene_Lobby");
			}
		}

		public void NextHall()
		{
			UnityEngine.Debug.Log("NextHall");
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			SceneManager.LoadScene("Scene_Game_Golf");
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level++;
		}

		public void ReTry()
		{
			UnityEngine.Debug.Log("NextHall");
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			SceneManager.LoadScene("Scene_Game_Golf");
		}

		private void Update()
		{
			UIWindDirection();
			if (Input.GetKeyDown(KeyCode.F2))
			{
				GoTitle();
			}
		}

		private void UIWindDirection()
		{
			if (!(GameManager.instance.currentMap == null))
			{
				Vector3 windVelocity = GameManager.instance.currentMap.windVelocity;
				Vector3 eulerAngles = Quaternion.LookRotation(windVelocity).eulerAngles;
				windArrowTR.localEulerAngles = new Vector3(0f, 0f, eulerAngles.y);
				windText.text = windVelocity.magnitude.ToString(strformat) + " " + GameSettingCtrl.GetLocalizationText("0138");
			}
		}

		public void UIConcede(bool isConcede)
		{
			ConcedeText.gameObject.SetActive(isConcede);
			if (isConcede && GameManager.instance.score != Score.DoublePar)
			{
				GameInfoUIManager.ConcedeEvent?.Invoke(isConcede);
			}
		}

		public void UIPanjung(string str)
		{
			UnityEngine.Debug.Log(str + " " + oldPanjung);
			if (!(oldPanjung == "Green") || !(str == "Green"))
			{
				if (str != "")
				{
					oldPanjung = str;
				}
				GameInfoUIManager.PanjungEvent?.Invoke(str);
				if (str == "DoublePar")
				{
					ConcedeText.gameObject.SetActive(value: false);
				}
				for (int i = 0; i < PanjungTexts.Length; i++)
				{
					PanjungTexts[i].gameObject.SetActive(PanjungTexts[i].transform.name == str);
				}
			}
		}

		public void Mulligan(bool isOn)
		{
			if (isOn)
			{
				MulliganCG.alpha = 1f;
				MulliganCG.blocksRaycasts = true;
			}
			else
			{
				MulliganCG.alpha = 0.2f;
				MulliganCG.blocksRaycasts = false;
			}
			inputDeviceState.UseXRInteractorLineVisual(isOn);
		}

		public void ShowMulligan(bool isOn)
		{
			MulliganText.gameObject.SetActive(isOn);
			if (isOn)
			{
				VoiceManager.instance.UseMulligan();
			}
		}

		public void SendPanjungUI(string str)
		{
			if (str == "DoublePar")
			{
				ConcedeText.gameObject.SetActive(value: false);
			}
			for (int i = 0; i < PanjungTexts.Length; i++)
			{
				PanjungTexts[i].gameObject.SetActive(PanjungTexts[i].name == str);
			}
		}

		public void SendConcedeUI(bool isConcede)
		{
			ConcedeText.gameObject.SetActive(isConcede);
		}

		public void ChangeClubSound()
		{
			Audio.PlayOneShot(TENNIS.SoundManager.instance.GetSoundClip("button"));
		}

		private string translateYD(string m)
		{
			float num = float.Parse(Regex.Replace(m, "m", ""));
			return (num * 1.0936f).ToString("0.#") + GameSettingCtrl.GetLocalizationText("0126");
		}
	}
	public enum Panjung
	{
		In,
		OB,
		Hazard,
		HoleIn
	}
	public enum Score
	{
		HoleInOne = -4,
		Albatross,
		Eagle,
		Birdie,
		Par,
		Bogey,
		DoubleBogey,
		TripleBogey,
		QuadruleBogey,
		DoublePar,
		noting
	}
	public enum GameTurn
	{
		my,
		other,
		end
	}
	public class GameManager : MonoBehaviour
	{
		public delegate MapInfomation GetMapData();

		public delegate void MoveToStroke(Vector3 nextPosition);

		public delegate void PanjungEvent(PlayerGameInfo _playerGameInfo);

		public delegate void MulliganEvent(PlayerGameInfo _playerGameInfo);

		public delegate void ChangeView();

		public delegate void MultiStart(Vector3 pos);

		public delegate void MultReSult();

		public static GameManager instance;

		public bool isMapLoaded;

		public Score score;

		public Panjung panjung;

		public GameTurn gameTurn;

		public float ConcedeRange;

		public static MoveToStroke moveToStroke;

		public MapInfomation currentMap;

		public List<GolfPlayer> golfPlayers = new List<GolfPlayer>();

		public PlayerGameInfo playerGameInfo;

		private PlayerGameInfo mulliganInfo;

		private AudioSource Audio;

		public float ShootTimeLimit = 5f;

		public bool isPassibleMulligan;

		public int maxUsebleMulligan;

		public int useMulliganCount;

		private Coroutine ShootTimeCheckRoutine;

		public static event GetMapData GetMapDataEvent;

		public static event PanjungEvent panjungEvent;

		public static event MulliganEvent mulliganEvent;

		public static event ChangeView changeViewEvent;

		public static event MultiStart MultiStartEvent;

		public static event MultReSult MultiResultEvent;

		protected void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			cFollower.hitBallEvent += StopShootTimeCheckRoutine;
			PlayerBehaviour.ChangeClubEvent += PlayerBehaviour_ChangeClubEvent;
		}

		private void PlayerBehaviour_ChangeClubEvent(ClubInfo clubInfo)
		{
			if (playerGameInfo != null)
			{
				playerGameInfo.equiClub = clubInfo.equipmentClubState;
			}
		}

		private void OnDisable()
		{
			cFollower.hitBallEvent -= StopShootTimeCheckRoutine;
			PlayerBehaviour.ChangeClubEvent -= PlayerBehaviour_ChangeClubEvent;
		}

		private void Start()
		{
			Audio = GetComponent<AudioSource>();
			StartCoroutine(IEnum_start());
			PublicGameUIManager.GetInstance.AddReplayEvent(delegate
			{
				SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			});
			VoiceManager.instance.Audio.clip = null;
		}

		private IEnumerator IEnum_start()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				MapLoader.instance.index = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1;
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				while (!MapLoader.instance.isGetMapIndex)
				{
					yield return null;
				}
			}
			MapLoader.instance.LoadMap();
			while (!isMapLoaded)
			{
				yield return null;
			}
			currentMap = GameManager.GetMapDataEvent();
			GameInfoUIManager.instance.GetMapInfo(currentMap);
			MinimapController.instance.SetCamTransform();
			AttachPlayer(golfPlayers[0], currentMap.TShootZonePosition);
		}

		public void AttachPlayer(GolfPlayer golfer, Vector3 position)
		{
			golfer.Attach_MoveToStrokeEvent();
			CallMoveToStrokeEvent(position);
		}

		public float GetDistanceHole(Vector3 currentBallPos)
		{
			float num = Vector3.Distance(currentBallPos, currentMap.holePosition);
			float num2 = 0.01f;
			if (num < 50f)
			{
				num2 = 0f;
			}
			currentMap.lightColumn.localScale = Vector3.one * (num * num2);
			return num;
		}

		public void CallMoveToStrokeEvent(Vector3 position)
		{
			GameManager.MultiStartEvent?.Invoke(position);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				playerGameInfo = new PlayerGameInfo(1, SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].nick, 0, 0, currentMap.HoleDistance, 0f, 0);
				golfPlayers[0].SetPlayerGameInfo(playerGameInfo);
				GameInfoUIManager.instance.playerGameInfo = playerGameInfo;
				GameInfoUIManager.instance.GetPlayer1GameInfo(playerGameInfo);
				moveToStroke(position);
				SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
			}
			mulliganInfo = new PlayerGameInfo(playerGameInfo.number, playerGameInfo.name, playerGameInfo.StrokeCount, playerGameInfo.PuttingCount, playerGameInfo.reMainDistance, playerGameInfo.Longist, playerGameInfo.Score);
			mulliganInfo.NextPos = position;
			mulliganInfo.reMainDistance = currentMap.HoleDistance;
		}

		public void ShootTimeCheck(Vector3 ballPos)
		{
			ShootTimeCheckRoutine = StartCoroutine(IEnum_ShootTimeLimit(ballPos));
		}

		private void StopShootTimeCheckRoutine(Vector3 velocity, BallQuality ballQuality, float swingAngle, float hitAngle, float accel)
		{
			if (playerGameInfo.equiClub == GolfPlayer.EquipmentClubState.putter)
			{
				currentMap.flagGO.SetActive(value: false);
			}
			isPassibleMulligan = true;
			GameInfoUIManager.instance.Mulligan(isPassibleMulligan && maxUsebleMulligan > useMulliganCount);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single)
			{
				if (ShootTimeCheckRoutine != null)
				{
					StopCoroutine(ShootTimeCheckRoutine);
				}
				ShootTimeCheckRoutine = null;
			}
		}

		private IEnumerator IEnum_ShootTimeLimit(Vector3 ballPos)
		{
			float currentTime = ShootTimeLimit;
			while (currentTime >= 0f)
			{
				GameInfoUIManager.instance.SetTimeLimit(currentTime);
				currentTime -= 1f;
				yield return new WaitForSeconds(1f);
			}
			golfPlayers[0].ballBehaviour.colGroundTag = "OB";
			Panjung("TimeOver", ballPos);
			ShootTimeCheckRoutine = null;
		}

		public void Panjung(string colGoundTag, Vector3 ballpos)
		{
			switch (colGoundTag)
			{
			case "OB":
				panjung = GOLF.Panjung.OB;
				playerGameInfo.reMainDistance = GetDistanceHole(golfPlayers[0].BallSpawnTR.position);
				playerGameInfo.StrokeCount++;
				ballpos = golfPlayers[0].BallSpawnTR.position;
				break;
			case "Hazerd":
				panjung = GOLF.Panjung.Hazard;
				playerGameInfo.reMainDistance = GetDistanceHole(currentMap.hazerdTPosition);
				playerGameInfo.StrokeCount++;
				ballpos = currentMap.hazerdTPosition;
				break;
			case "HoleIn":
				panjung = GOLF.Panjung.HoleIn;
				break;
			case "Concede":
				GameInfoUIManager.instance.UIConcede(isConcede: true);
				panjung = GOLF.Panjung.HoleIn;
				playerGameInfo.StrokeCount++;
				break;
			case "Road":
				UnityEngine.Debug.Log("Road");
				panjung = GOLF.Panjung.In;
				ballpos = GetClosestLoadBallPos(ballpos);
				playerGameInfo.reMainDistance = GetDistanceHole(ballpos);
				break;
			default:
				panjung = GOLF.Panjung.In;
				playerGameInfo.reMainDistance = GetDistanceHole(ballpos);
				break;
			}
			int num = currentMap.parScore * -1 + playerGameInfo.StrokeCount + 1;
			if (panjung != GOLF.Panjung.HoleIn)
			{
				if (num > currentMap.parScore - 2)
				{
					score = Score.DoublePar;
					score.ToString();
					GameInfoUIManager.instance.UIPanjung(score.ToString());
					gameTurn = GameTurn.end;
					if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
					{
						Result();
					}
					else
					{
						StartCoroutine(IEnum_CallMoveToStrokeEvent());
					}
				}
				else
				{
					StartCoroutine(IEnum_CallMoveToStrokeEvent());
					GameInfoUIManager.instance.UIPanjung(colGoundTag);
				}
			}
			else
			{
				if (num > currentMap.parScore - 1)
				{
					score = Score.DoublePar;
					GameInfoUIManager.instance.UIConcede(isConcede: false);
				}
				else
				{
					score = (Score)num;
					if (playerGameInfo.StrokeCount == 0)
					{
						score = Score.HoleInOne;
						SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach18", 1);
						UnityEngine.Debug.Log("<color=red> 홀인원 업적 달성!!!</color>");
					}
					if (score == Score.Birdie)
					{
						SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach17", 1);
						UnityEngine.Debug.Log("<color=red> 버디 업적 달성!!!</color>");
					}
				}
				score.ToString();
				GameInfoUIManager.instance.UIPanjung(score.ToString());
				if (score <= Score.Par)
				{
					Audio.PlayOneShot(TENNIS.SoundManager.instance.GetSoundClip("cheer"));
				}
				gameTurn = GameTurn.end;
				if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
				{
					Result();
				}
				else
				{
					StartCoroutine(IEnum_CallMoveToStrokeEvent());
				}
			}
			playerGameInfo.StrokeCount++;
			playerGameInfo.ColGroundTag = colGoundTag;
			playerGameInfo.Score = (int)score;
			playerGameInfo.NextPos = ballpos;
			playerGameInfo.gameTurn = gameTurn;
			int equipmentClubState = (int)golfPlayers[0].equipmentClubState;
			VoiceManager.instance.panjung(playerGameInfo, equipmentClubState, colGoundTag == "Concede");
			GameManager.panjungEvent?.Invoke(playerGameInfo);
		}

		private Vector3 GetClosestLoadBallPos(Vector3 ballPos)
		{
			float num = 100000f;
			int num2 = 0;
			for (int i = 0; i < currentMap.roadPositions.Length; i++)
			{
				float num3 = Vector3.Distance(ballPos, currentMap.roadPositions[i].position);
				if (num > num3)
				{
					num = num3;
					num2 = i;
				}
			}
			UnityEngine.Debug.Log("index : " + num2);
			UnityEngine.Debug.Log("currentMap.roadPositions[index].position : " + currentMap.roadPositions[num2].position);
			return currentMap.roadPositions[num2].position;
		}

		public void Result()
		{
			StartCoroutine(IEnum_Result());
		}

		private IEnumerator IEnum_Result()
		{
			yield return new WaitForSeconds(3f);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				GameInfoUIManager.instance.SetResultInfo(score <= Score.Par);
			}
			else
			{
				GameManager.MultiResultEvent?.Invoke();
			}
		}

		private void UseMulligan()
		{
			if (gameTurn == GameTurn.end)
			{
				UnityEngine.Debug.Log("결과가 나서 멀리건 못씀!!");
				return;
			}
			useMulliganCount++;
			playerGameInfo = mulliganInfo;
			playerGameInfo.isUseMulligan = true;
			GameManager.mulliganEvent?.Invoke(playerGameInfo);
		}

		private IEnumerator IEnum_CallMoveToStrokeEvent()
		{
			yield return new WaitForSeconds(2f);
			isPassibleMulligan = false;
			GameInfoUIManager.instance.Mulligan(isOn: false);
			if (golfPlayers[0].isUseMulligan)
			{
				UseMulligan();
			}
			yield return new WaitForSeconds(1f);
			mulliganInfo = new PlayerGameInfo(playerGameInfo.number, playerGameInfo.name, playerGameInfo.StrokeCount, playerGameInfo.PuttingCount, playerGameInfo.reMainDistance, playerGameInfo.Longist, playerGameInfo.Score);
			mulliganInfo.NextPos = playerGameInfo.NextPos;
			mulliganInfo.ColGroundTag = playerGameInfo.ColGroundTag;
			GameManager.changeViewEvent?.Invoke();
			if (GameManager.changeViewEvent == null)
			{
				golfPlayers[0].SetPlayerGameInfo(playerGameInfo);
				GameInfoUIManager.instance.playerGameInfo = playerGameInfo;
				GameInfoUIManager.instance.GetPlayer1GameInfo(playerGameInfo);
				moveToStroke(playerGameInfo.NextPos);
				GameInfoUIManager.instance.UIPanjung("");
			}
			currentMap.flagGO.SetActive(value: true);
			playerGameInfo.isUseMulligan = false;
		}

		public void LookRotateArrow(float distanceHole)
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi && gameTurn != 0)
			{
				currentMap.HoleSlopeArrowTR.gameObject.SetActive(value: false);
				return;
			}
			bool flag = playerGameInfo.ColGroundTag == "Green";
			currentMap.HoleSlopeArrowTR.gameObject.SetActive(flag);
			if (flag)
			{
				currentMap.HoleSlopeArrowTR.gameObject.SetActive(value: true);
				Vector3 forward = golfPlayers[0].BallSpawnTR.position - currentMap.HoleSlopeArrowTR.position;
				forward.y = 0f;
				currentMap.HoleSlopeArrowTR.rotation = Quaternion.LookRotation(forward);
				SlopeIndicator component = currentMap.HoleSlopeArrowTR.GetComponent<SlopeIndicator>();
				component.Setting(distanceHole);
				component.Calculate(in currentMap.holePosition);
			}
		}

		public float GetHoleSlopeAngle()
		{
			Vector3 holePosition = currentMap.holePosition;
			float num = 3f;
			Vector3 vector = golfPlayers[0].transform.right * -1f;
			Vector3 right = golfPlayers[0].transform.right;
			Vector3 origin = holePosition + vector * num;
			Vector3 vector2 = holePosition + right * num;
			origin.y += num;
			vector2.y += num;
			UnityEngine.Debug.DrawRay(vector2, Vector3.up * 1f, Color.blue, 3f);
			Ray ray = new Ray(origin, Vector3.down);
			Ray ray2 = new Ray(vector2, Vector3.down);
			Vector3 vector3 = Vector3.zero;
			Vector3 vector4 = Vector3.zero;
			int layerMask = 1;
			if (Physics.Raycast(ray, out var hitInfo, 15f, layerMask))
			{
				vector3 = hitInfo.point;
			}
			if (Physics.Raycast(ray2, out var hitInfo2, 15f, layerMask))
			{
				vector4 = hitInfo2.point;
			}
			Vector3 vector5 = vector4;
			vector5.y = vector3.y;
			Vector3 normalized = (vector5 - vector3).normalized;
			Vector3 normalized2 = (vector4 - vector3).normalized;
			float num2 = Vector3.Distance(vector3, vector5);
			float num3 = Vector3.Distance(vector3, vector4);
			UnityEngine.Debug.DrawRay(vector3, Vector3.up * 2f, Color.green, 3f);
			UnityEngine.Debug.DrawRay(vector2, Vector3.up * 2f, Color.green, 3f);
			UnityEngine.Debug.DrawRay(vector5, Vector3.up * 2f, Color.red, 3f);
			UnityEngine.Debug.DrawRay(vector3, normalized * num2, Color.gray, 3f);
			UnityEngine.Debug.DrawRay(vector3, normalized2 * num3, Color.white, 3f);
			float num4 = Vector3.Angle(normalized, normalized2);
			return (Vector3.Dot(normalized2, base.transform.up) > 0f) ? num4 : (num4 * -1f);
		}
	}
	public class GolfPlayer : MonoBehaviour
	{
		public enum EquipmentClubState
		{
			driver,
			wood3,
			wood5,
			iron4,
			iron5,
			iron6,
			iron7,
			iron8,
			iron9,
			pw,
			sw,
			putter
		}

		public PlayerGameInfo playerGameInfo;

		public Transform ClubParentTR;

		public Transform BallSpawnTR;

		public BallBehaviour ballBehaviour;

		protected ClubInfo clubInfo;

		public bool isUseMulligan;

		public EquipmentClubState equipmentClubState;

		private void OnDisable()
		{
			GameManager.instance.golfPlayers.Remove(this);
			GameManager.moveToStroke = (GameManager.MoveToStroke)Delegate.Remove(GameManager.moveToStroke, new GameManager.MoveToStroke(StrokeReady));
		}

		private void OnDestroy()
		{
			GameManager.instance.golfPlayers.Remove(this);
			GameManager.moveToStroke = (GameManager.MoveToStroke)Delegate.Remove(GameManager.moveToStroke, new GameManager.MoveToStroke(StrokeReady));
		}

		protected virtual void Start()
		{
			GameManager.instance.golfPlayers.Add(this);
			BallSpawnTR = GameObject.Find("BallSpawnPos").transform;
		}

		public void Attach_MoveToStrokeEvent()
		{
			GameManager.moveToStroke = (GameManager.MoveToStroke)Delegate.Combine(GameManager.moveToStroke, new GameManager.MoveToStroke(StrokeReady));
		}

		public void SetPlayerGameInfo(PlayerGameInfo _playerGameinfo)
		{
			playerGameInfo = _playerGameinfo;
		}

		protected virtual void StrokeReady(Vector3 nextPosition)
		{
			isUseMulligan = false;
			GameInfoUIManager.instance.ShowMulligan(isOn: false);
		}
	}
	public class LoadScene : MonoBehaviour
	{
		private void Start()
		{
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
		}

		public void GameStart(int mapIndex)
		{
			StartCoroutine(IEnum_Start(mapIndex));
		}

		private IEnumerator IEnum_Start(int mapIndex)
		{
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			yield return new WaitForSeconds(2f);
			SceneManager.LoadScene("Game");
			MapLoader.instance.index = mapIndex;
		}
	}
	public class LogoScene : MonoBehaviour
	{
		private void Start()
		{
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
			StartCoroutine(IEnum_SceneChanger());
		}

		private IEnumerator IEnum_SceneChanger()
		{
			yield return new WaitForSeconds(3f);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			yield return new WaitForSeconds(3f);
			SceneManager.LoadScene(1);
		}
	}
	public class MapInfomation : MonoBehaviour
	{
		public int hallNumber;

		public int parScore;

		public Vector3 TShootZonePosition;

		public Vector3 holePosition;

		public Vector3 hazerdTPosition;

		public Vector3 windVelocity;

		public Vector3 middleArrive;

		public PhysicMaterial mapPhysicsMat;

		public Sprite minimapImage;

		public Sprite greenImage;

		public float HoleDistance;

		public Vector3 mapCamPos;

		public Vector3 mapCamRot;

		public float camSize;

		public Transform lightColumn;

		public Transform[] roadPositions;

		public Transform HoleSlopeArrowTR;

		public ParticleSystem HoleIePS;

		private GameObject checkHoleGO;

		public GameObject flagGO;

		private float windChangeTime;

		private float currentTime;

		private float value;

		private void OnEnable()
		{
			GameManager.GetMapDataEvent += GetMapInfo;
		}

		private void OnDisable()
		{
			GameManager.GetMapDataEvent -= GetMapInfo;
		}

		public MapInfomation GetMapInfo()
		{
			return this;
		}

		private void Awake()
		{
			holePosition = base.transform.Find("Hole").position;
			TShootZonePosition = base.transform.Find("T-ShootZone").position;
			hazerdTPosition = base.transform.Find("T-hazerd").position;
			checkHoleGO = base.transform.Find("Hole/CheckHole").gameObject;
			if ((bool)base.transform.Find("MiddleArrive"))
			{
				middleArrive = base.transform.Find("MiddleArrive").position;
			}
			if ((bool)base.transform.Find("RoadPositions"))
			{
				roadPositions = new Transform[base.transform.Find("RoadPositions").childCount];
				for (int i = 0; i < roadPositions.Length; i++)
				{
					roadPositions[i] = base.transform.Find("RoadPositions").GetChild(i);
				}
			}
			HoleDistance = Vector3.Distance(holePosition, TShootZonePosition);
			flagGO = UnityEngine.Object.FindObjectOfType<FlagLookAt>().gameObject;
		}

		private void Update()
		{
			ChangeWindVelocity();
			RotateSky();
		}

		private void RotateSky()
		{
			if (!(RenderSettings.skybox == null))
			{
				value += UnityEngine.Random.Range(0.005f, Time.deltaTime * 0.5f);
				RenderSettings.skybox.SetFloat("_Rotation", value);
			}
		}

		public void EnableCheckHole(bool isUse)
		{
			checkHoleGO.SetActive(isUse);
		}

		private void ChangeWindVelocity()
		{
			if (currentTime > windChangeTime)
			{
				currentTime = 0f;
				windChangeTime = UnityEngine.Random.Range(5f, 30f);
				float x = UnityEngine.Random.Range(-1f, 1f);
				float z = UnityEngine.Random.Range(-1f, 1f);
				windVelocity = new Vector3(x, 0f, z);
			}
			currentTime += Time.deltaTime;
		}
	}
	public class MapLoader : MonoBehaviour
	{
		public static MapLoader instance;

		public string[] SceneName;

		public int index;

		public bool isGetMapIndex;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public void GoTitle(float delayTime)
		{
			StartCoroutine(IEnum_GoTitle(delayTime));
		}

		private IEnumerator IEnum_GoTitle(float delayTime)
		{
			yield return new WaitForSeconds(delayTime * 0.5f);
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			yield return new WaitForSeconds(delayTime * 0.5f);
			SceneManager.LoadScene("Title");
		}

		public void LoadMap()
		{
			if (!RenderSettings.fog)
			{
				RenderSettings.fog = true;
			}
			if (GameManager.instance != null)
			{
				GameManager.instance.isMapLoaded = false;
				StartCoroutine(IEnum_LoadScene());
			}
		}

		private IEnumerator IEnum_LoadScene()
		{
			AsyncOperation async = SceneManager.LoadSceneAsync(SceneName[index], LoadSceneMode.Additive);
			while (!async.isDone)
			{
				yield return new WaitForEndOfFrame();
			}
			SceneManager.SetActiveScene(SceneManager.GetSceneByName(SceneName[index]));
			GameManager.instance.isMapLoaded = true;
		}
	}
	public class MinimapController : MonoBehaviour
	{
		public Transform ball;

		public LineRenderer ballPreView;

		private Transform mapBall;

		private LineRenderer mapBallPreView;

		private Transform endViewPosTR;

		private Camera cam;

		private ClubInfo cluInfo;

		public static MinimapController instance;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnEnable()
		{
			PlayerBehaviour.ChangeClubEvent += GetClubInfo;
		}

		private void OnDisable()
		{
			PlayerBehaviour.ChangeClubEvent -= GetClubInfo;
		}

		private void Start()
		{
			initData();
		}

		private void initData()
		{
			mapBall = base.transform.Find("mp_Ball");
			mapBallPreView = base.transform.Find("mp_BallPreview").GetComponent<LineRenderer>();
			endViewPosTR = mapBallPreView.transform.GetChild(0);
			mapBallPreView.positionCount = 2;
			cam = base.transform.GetChild(0).GetComponent<Camera>();
		}

		private void GetClubInfo(ClubInfo _cluInfo)
		{
			cluInfo = _cluInfo;
		}

		public void SetCamTransform()
		{
			cam.transform.localPosition = GameManager.instance.currentMap.mapCamPos;
			cam.transform.localEulerAngles = GameManager.instance.currentMap.mapCamRot;
			cam.orthographicSize = GameManager.instance.currentMap.camSize;
		}

		private void DrawBall()
		{
			Vector3 position = new Vector3(ball.position.x, mapBall.position.y, ball.position.z);
			mapBall.position = position;
		}

		public Vector3[] DrawPreview()
		{
			if (cluInfo == null)
			{
				return null;
			}
			if (ballPreView.positionCount == 0)
			{
				return null;
			}
			ballPreView.startWidth = ((cluInfo.equipmentClubState == GolfPlayer.EquipmentClubState.sw || cluInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter) ? 0f : 0.03f);
			ballPreView.endWidth = ((cluInfo.equipmentClubState == GolfPlayer.EquipmentClubState.sw || cluInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter) ? 0f : 0.65f);
			Vector3[] array = new Vector3[10];
			int num = ballPreView.positionCount / 10;
			for (int i = 0; i < array.Length; i++)
			{
				if (i == 0)
				{
					array[i] = ballPreView.GetPosition(0);
				}
				else
				{
					array[i] = ballPreView.GetPosition(i * num);
				}
				array[i].y = mapBall.position.y + 100f;
			}
			Vector3 normalized = (array[array.Length - 1] - array[0]).normalized;
			array[array.Length - 1] += normalized * cluInfo.runRange;
			return array;
		}

		private void Update()
		{
			DrawBall();
		}
	}
	public class MultPlayerBehaaviour : MonoBehaviour
	{
		private PhotonView pview;

		private Transform Player;

		public GameObject characterGO;

		private void Start()
		{
			pview = GetComponent<PhotonView>();
			if (pview.IsMine)
			{
				Player = GameObject.Find("Me").transform;
			}
			else
			{
				StartCoroutine(IEnum_waitGameManagerInstance());
			}
		}

		private IEnumerator IEnum_waitGameManagerInstance()
		{
			while (GameManager.instance == null)
			{
				yield return null;
			}
			MultiPlayerManager.instance.OtherPlayerCharacter = UnityEngine.Object.Instantiate(characterGO, base.transform);
			MultiPlayerManager.instance.OtherPlayerCharacterAnimator = MultiPlayerManager.instance.OtherPlayerCharacter.GetComponent<Animator>();
			int num = (PhotonNetwork.IsMasterClient ? 1 : 0);
			MultiPlayerManager.instance.OtherPlayerCharacter.GetComponent<CustomModelSettingCtrl>().Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[num].id);
		}

		private void Update()
		{
			if (pview.IsMine)
			{
				base.transform.position = Player.position;
				base.transform.rotation = Player.rotation;
			}
		}
	}
	public class MultiLoadScene : MonoBehaviourPunCallbacks
	{
		public static MultiLoadScene instance;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public void GameStart()
		{
			StartCoroutine(IEnum_GameStart());
		}

		private IEnumerator IEnum_GameStart()
		{
			yield return new WaitForSeconds(3f);
			MapSelect();
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
			yield return new WaitForSeconds(3f);
			PhotonNetwork.LoadLevel("Game");
		}

		private void MapSelect()
		{
			int num = UnityEngine.Random.Range(0, MapLoader.instance.SceneName.Length);
			MapLoader.instance.index = num;
			base.photonView.RPC("RPC_MapSelect", RpcTarget.Others, num);
		}

		[PunRPC]
		private void RPC_MapSelect(int _mapIndex)
		{
			MapLoader.instance.index = _mapIndex;
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeOut();
		}
	}
	public class MultiPlayerManager : MonoBehaviour
	{
		public static MultiPlayerManager instance;

		public GameObject LocalPlayer;

		public GameObject OtherPlayerCharacter;

		public Animator OtherPlayerCharacterAnimator;

		private string equiClubName;

		public GameObject OtherPlayerCharacters;

		public float animHitTime;

		private float frameLate = 0.033f;

		private LookAtIK lookAtIK;

		private bool isWaiting;

		private Transform ClubParent;

		private bool isRightHand;

		private string LeftHandPath = "Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Spine2/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/";

		private string RightHandPath = "Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Spine2/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/";

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			base.enabled = (PhotonNetwork.InRoom ? true : false);
			if (PhotonNetwork.InRoom)
			{
				LocalPlayer = PhotonNetwork.Instantiate("GOLF_MultiPlayer", Vector3.zero, Quaternion.identity, 0);
				LocalPlayer.name = PhotonNetwork.LocalPlayer.NickName;
			}
		}

		public void SetActive(bool isOn)
		{
			if (OtherPlayerCharacter != null)
			{
				OtherPlayerCharacter.SetActive(isOn);
			}
			if (isOn)
			{
				bool isMan = OtherPlayerCharacter.GetComponent<CheckGenderCtrl>().isMan;
				OtherPlayerCharacterAnimator.SetBool("isMan", isMan);
			}
		}

		public void WaitAndWatchingMe(Vector3 myPos, Vector3 otherPos)
		{
			isWaiting = true;
			OtherPlayerCharacter.SetActive(value: false);
			StartCoroutine(IEnum_WaitAndWatchingMe(myPos, otherPos));
		}

		private IEnumerator IEnum_WaitAndWatchingMe(Vector3 myPos, Vector3 otherPos)
		{
			yield return new WaitForSeconds(0.5f);
			OtherPlayerCharacter.SetActive(value: true);
			OtherPlayerCharacter.transform.position = otherPos;
			OtherPlayerCharacterAnimator.speed = 1f;
			UnityEngine.Debug.Log(string.Concat("Other position : ", OtherPlayerCharacter.transform.position, " ", otherPos));
			Vector3 normalized = (myPos - otherPos).normalized;
			normalized.y = 0f;
			Quaternion rotation = Quaternion.LookRotation(normalized);
			OtherPlayerCharacter.transform.rotation = rotation;
			Vector3 normalized2 = (GameManager.instance.currentMap.holePosition - myPos).normalized;
			Vector3 normalized3 = (otherPos - myPos).normalized;
			float num = Vector3.Dot(normalized2, normalized3);
			float num2 = Vector3.Distance(GameManager.instance.currentMap.holePosition, myPos);
			float num3 = Vector3.Distance(myPos, otherPos);
			UnityEngine.Debug.Log("dot : " + num);
			UnityEngine.Debug.Log("dis : " + num2);
			UnityEngine.Debug.DrawRay(myPos, normalized2 * Vector3.Distance(myPos, GameManager.instance.currentMap.holePosition), Color.red, 30f);
			UnityEngine.Debug.DrawRay(myPos, normalized3 * Vector3.Distance(myPos, otherPos), Color.blue, 30f);
			if (num2 < 40f && Mathf.Abs(num) > 0.8f)
			{
				OtherPlayerCharacter.SetActive(value: false);
				if (Vector3.Distance(otherPos, GameManager.instance.currentMap.holePosition) > 2f && Mathf.Abs(num) < 0.7f)
				{
					OtherPlayerCharacter.SetActive(value: true);
				}
			}
			else if (num3 < 3f)
			{
				OtherPlayerCharacter.SetActive(value: false);
			}
			else
			{
				OtherPlayerCharacter.SetActive(value: true);
			}
			if (OtherPlayerCharacter.activeSelf)
			{
				SetWaiting();
			}
		}

		public void ChangeHand(bool isRight)
		{
			if (!(OtherPlayerCharacterAnimator == null))
			{
				isRightHand = isRight;
				OtherPlayerCharacterAnimator.SetBool("isLeftHand", !isRight);
				Vector3 localPosition = OtherPlayerCharacter.transform.localPosition;
				localPosition.x = Mathf.Abs(localPosition.x);
				OtherCharacterData component = OtherPlayerCharacter.GetComponent<OtherCharacterData>();
				bool isMan = OtherPlayerCharacter.GetComponent<CheckGenderCtrl>().isMan;
				ClubParent = (isMan ? component.Clubs[0] : component.Clubs[1]);
				if (isRight)
				{
					ClubParent.parent = OtherPlayerCharacter.transform.Find(LeftHandPath);
					ClubParent.localScale = new Vector3(1f, 1f, 1f);
					OtherPlayerCharacter.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
					localPosition.x *= -1f;
				}
				else
				{
					ClubParent.parent = OtherPlayerCharacter.transform.Find(RightHandPath);
					ClubParent.localScale = new Vector3(1f, 1f, -1f);
					OtherPlayerCharacter.transform.localEulerAngles = new Vector3(0f, -90f, 0f);
				}
				ClubParent.localPosition = Vector3.zero;
				ClubParent.localRotation = Quaternion.identity;
				OtherPlayerCharacter.transform.localPosition = localPosition;
			}
		}

		public void ChangeClub(GolfPlayer.EquipmentClubState equipmentClubState)
		{
			if (isWaiting)
			{
				return;
			}
			OtherCharacterData component = OtherPlayerCharacter.GetComponent<OtherCharacterData>();
			bool isMan = OtherPlayerCharacter.GetComponent<CheckGenderCtrl>().isMan;
			ClubParent = (isMan ? component.Clubs[0] : component.Clubs[1]);
			ClubParent.gameObject.SetActive(value: true);
			switch (equipmentClubState)
			{
			case GolfPlayer.EquipmentClubState.driver:
			{
				for (int m = 0; m < ClubParent.childCount; m++)
				{
					ClubParent.GetChild(m).gameObject.SetActive(value: false);
					if (ClubParent.GetChild(m).name == "Driver")
					{
						ClubParent.GetChild(m).gameObject.SetActive(value: true);
					}
				}
				OtherPlayerCharacter.transform.localPosition = (isMan ? new Vector3(-0.05f, 0f, 0f) : new Vector3(0.05f, 0f, 0f));
				equiClubName = "driver";
				animHitTime = 30f * frameLate;
				break;
			}
			case GolfPlayer.EquipmentClubState.wood3:
			case GolfPlayer.EquipmentClubState.wood5:
			{
				for (int k = 0; k < ClubParent.childCount; k++)
				{
					ClubParent.GetChild(k).gameObject.SetActive(value: false);
					if (ClubParent.GetChild(k).name == "Wood")
					{
						ClubParent.GetChild(k).gameObject.SetActive(value: true);
					}
				}
				OtherPlayerCharacter.transform.localPosition = (isMan ? new Vector3(-0.1f, 0f, 0f) : Vector3.zero);
				equiClubName = "wood";
				animHitTime = 30f * frameLate;
				break;
			}
			case GolfPlayer.EquipmentClubState.iron4:
			case GolfPlayer.EquipmentClubState.iron5:
			case GolfPlayer.EquipmentClubState.iron6:
			case GolfPlayer.EquipmentClubState.iron7:
			case GolfPlayer.EquipmentClubState.iron8:
			case GolfPlayer.EquipmentClubState.iron9:
			{
				for (int j = 0; j < ClubParent.childCount; j++)
				{
					ClubParent.GetChild(j).gameObject.SetActive(value: false);
					if (ClubParent.GetChild(j).name == "Iron")
					{
						ClubParent.GetChild(j).gameObject.SetActive(value: true);
					}
				}
				OtherPlayerCharacter.transform.localPosition = (isMan ? new Vector3(-0.45f, 0f, 0f) : new Vector3(-0.35f, 0f, 0f));
				equiClubName = "iron";
				animHitTime = 30f * frameLate;
				break;
			}
			case GolfPlayer.EquipmentClubState.pw:
			case GolfPlayer.EquipmentClubState.sw:
			{
				for (int l = 0; l < ClubParent.childCount; l++)
				{
					ClubParent.GetChild(l).gameObject.SetActive(value: false);
					if (ClubParent.GetChild(l).name == "Wedge")
					{
						ClubParent.GetChild(l).gameObject.SetActive(value: true);
					}
				}
				OtherPlayerCharacter.transform.localPosition = (isMan ? new Vector3(-0.5f, 0f, -0.05f) : new Vector3(-0.4f, 0f, -0.05f));
				equiClubName = "wedge";
				animHitTime = 30f * frameLate;
				break;
			}
			case GolfPlayer.EquipmentClubState.putter:
			{
				for (int i = 0; i < ClubParent.childCount; i++)
				{
					ClubParent.GetChild(i).gameObject.SetActive(value: false);
					if (ClubParent.GetChild(i).name == "Putter")
					{
						ClubParent.GetChild(i).gameObject.SetActive(value: true);
					}
				}
				OtherPlayerCharacter.transform.localPosition = new Vector3(-0.05f, 0f, -0.05f);
				equiClubName = "putter";
				animHitTime = 30f * frameLate;
				break;
			}
			}
			OtherPlayerCharacter.transform.localEulerAngles = (isRightHand ? new Vector3(0f, 90f, 0f) : new Vector3(0f, -90f, 0f));
			Vector3 localPosition = OtherPlayerCharacter.transform.localPosition;
			localPosition.x = Mathf.Abs(localPosition.x);
			localPosition.x *= (isRightHand ? (-1f) : 1f);
			OtherPlayerCharacter.transform.localPosition = localPosition;
		}

		private void SetWaiting()
		{
			OtherPlayerCharacterAnimator.SetTrigger("waiting");
			ClubParent.gameObject.SetActive(value: false);
		}

		public void SetAnim(float accel)
		{
			string text = equiClubName;
			if (text == "wedge" && accel < 75f)
			{
				text += "Half";
			}
			UnityEngine.Debug.Log("AnimName : " + text);
			OtherPlayerCharacterAnimator.SetTrigger(text);
		}

		public void Idle(string colTag)
		{
			if (colTag == "Green")
			{
				OtherPlayerCharacterAnimator.SetTrigger("putterIdle");
			}
			else
			{
				OtherPlayerCharacterAnimator.SetTrigger("Idle");
			}
			isWaiting = false;
		}

		private void Update()
		{
			if (!(OtherPlayerCharacter == null))
			{
				if (OtherPlayerCharacter.activeInHierarchy && isWaiting)
				{
					Vector3 normalized = (GameObject.Find("Ball").transform.position - OtherPlayerCharacter.transform.position).normalized;
					normalized.y = 0f;
					Quaternion b = Quaternion.LookRotation(normalized);
					OtherPlayerCharacter.transform.rotation = Quaternion.Lerp(OtherPlayerCharacter.transform.rotation, b, Time.deltaTime);
				}
				if (lookAtIK == null)
				{
					lookAtIK = OtherPlayerCharacter.GetComponent<LookAtIK>();
				}
				if (lookAtIK.solver.target == null)
				{
					lookAtIK.solver.target = GameObject.Find("Ball").transform;
				}
			}
		}
	}
	public class Nickname : MonoBehaviour
	{
		private TextMesh text;

		private void Start()
		{
			text = GetComponent<TextMesh>();
			SetNickName();
		}

		private void SetNickName()
		{
			foreach (KeyValuePair<int, Player> player in PhotonNetwork.CurrentRoom.Players)
			{
				if (player.Value != PhotonNetwork.LocalPlayer)
				{
					text.text = player.Value.NickName;
				}
			}
		}

		private void Update()
		{
			if (!(MultiPlayerManager.instance == null) && !(MultiPlayerManager.instance.LocalPlayer == null))
			{
				Vector3 normalized = (base.transform.position - MultiPlayerManager.instance.LocalPlayer.transform.position).normalized;
				normalized.y = 0f;
				text.transform.rotation = Quaternion.LookRotation(normalized);
			}
		}
	}
	public class OtherCharacterData : MonoBehaviour
	{
		public Transform[] Clubs;
	}
	public class PanjungSpriteManager : MonoBehaviour
	{
		private Vector3 startScle;

		public float setAnimFrame;

		public float speed;

		private void Awake()
		{
			startScle = base.transform.localScale;
		}

		private void OnEnable()
		{
			StartCoroutine(startAnim());
		}

		private IEnumerator startAnim()
		{
			Vector3 localScale = startScle;
			localScale.x += 0.03f;
			base.transform.localScale = localScale;
			float time = setAnimFrame * 0.033f;
			float currentTime = 0f;
			while (currentTime < time)
			{
				currentTime += Time.deltaTime;
				base.transform.localScale = Vector3.Lerp(base.transform.localScale, startScle, speed);
				yield return null;
			}
			base.transform.localScale = startScle;
		}
	}
	public class PhotonManager : MonoBehaviourPunCallbacks
	{
		public delegate void OtherPlayerEnter(Player player);

		public delegate void OtherPlayerLeft(Player player);

		public static PhotonManager instance;

		private ChatClient chatClient;

		public ExitGames.Client.Photon.Hashtable myCustomProperty = new ExitGames.Client.Photon.Hashtable();

		public static event OtherPlayerEnter OtherPlayerEnterEvent;

		public static event OtherPlayerLeft OtherPlayerLeftEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public void DisConnect()
		{
			PhotonNetwork.Disconnect();
		}

		public override void OnDisconnected(DisconnectCause cause)
		{
			UnityEngine.Debug.Log("Photon Disconnected " + cause);
		}

		public override void OnPlayerEnteredRoom(Player newPlayer)
		{
			base.OnPlayerEnteredRoom(newPlayer);
			UnityEngine.Debug.Log("=======Enter=======");
			UnityEngine.Debug.Log("current Player Count : " + PhotonNetwork.CurrentRoom.PlayerCount);
			UnityEngine.Debug.Log("ListCount : " + PhotonNetwork.CurrentRoom.Players.Count);
			PhotonManager.OtherPlayerEnterEvent?.Invoke(newPlayer);
			if (PhotonNetwork.IsMasterClient && SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType == GameData_DDOL.GameType.Golf)
			{
				MultiLoadScene.instance.GameStart();
			}
		}

		public void LeaveRoom()
		{
			PhotonNetwork.LeaveRoom();
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			base.OnPlayerLeftRoom(otherPlayer);
			PhotonManager.OtherPlayerLeftEvent?.Invoke(otherPlayer);
			UnityEngine.Debug.Log("=======Left=======");
			UnityEngine.Debug.Log("current Player Count : " + PhotonNetwork.CurrentRoom.PlayerCount);
			UnityEngine.Debug.Log("ListCount : " + PhotonNetwork.CurrentRoom.Players.Count);
		}

		public override void OnMasterClientSwitched(Player newMasterClient)
		{
			UnityEngine.Debug.Log("new MasterClinet : " + newMasterClient.NickName);
		}

		public override void OnLeftLobby()
		{
			base.OnLeftLobby();
			UnityEngine.Debug.Log("LeftLobby!!");
		}
	}
	public class PlayerBehaviour : GolfPlayer
	{
		public delegate void ResetBall();

		public delegate void changeStance(Vector3 stanceDir);

		public delegate void changeClub(ClubInfo clubInfo);

		public delegate void MulliganEvent();

		public delegate void ChangeHandlder(bool isLeftHand, InputDeviceState _inputDeviceState);

		private bool isPressTouchPad;

		private bool isPressSeconPad;

		public Transform StanceDirTR;

		public static Vector3 stanceDirection;

		public int ClubIndex;

		public int MaxClubIndex;

		public static bool isPressTrigger;

		public InputDeviceState RightInputDeviceState;

		public InputDeviceState LeftInputDeviceState;

		private InputDeviceState inputDeviceState;

		private float distance;

		private float angleInDegrees = -90f;

		public static event ResetBall ResetBallEvent;

		public static event changeStance ChangeStanceEvent;

		public static event changeClub ChangeClubEvent;

		public static event MulliganEvent mulliganEvent;

		public static event ChangeHandlder ChangeHandlderEvent;

		protected override void Start()
		{
			base.Start();
			stanceDirection = StanceDirTR.forward;
			if (PublicGameUIManager.gameSetting.IsRightHanded())
			{
				inputDeviceState = RightInputDeviceState;
			}
			else
			{
				inputDeviceState = LeftInputDeviceState;
			}
			PublicGameUIManager.gameSetting.AddHandChangedEvent(ChangeHandler);
		}

		private void OnEnable()
		{
			cFollower.hitBallEvent += CFollower_hitBallEvent;
		}

		private void OnDisable()
		{
			cFollower.hitBallEvent -= CFollower_hitBallEvent;
		}

		private void CFollower_hitBallEvent(Vector3 velocity, BallQuality ballQuality, float swingAngle, float hitAngle, float accel)
		{
			inputDeviceState.HapticPulse();
		}

		protected override void StrokeReady(Vector3 nextPosition)
		{
			base.StrokeReady(nextPosition);
			if (BallSpawnTR == null)
			{
				BallSpawnTR = GameObject.Find("BallSpawnPos").transform;
			}
			BallSpawnTR.position = nextPosition;
			CallResetBallEvent();
			distance = 0.6369811f;
			ClubIndex = GetClubIndex();
			ChangeClub();
			Quaternion rot = Quaternion.LookRotation(GetToHoleDirection(nextPosition));
			ChangeStance(rot);
			ChangeHandler(PublicGameUIManager.gameSetting.IsRightHanded());
			GameInfoUIManager.instance.ShootPlaceUI(playerGameInfo.ColGroundTag);
		}

		private Vector3 GetToHoleDirection(Vector3 nextPos)
		{
			GameManager.instance.GetDistanceHole(nextPos);
			Vector3 zero = Vector3.zero;
			_ = 250f;
			if (GameManager.instance.currentMap.middleArrive != Vector3.zero)
			{
				float num = Vector3.Distance(GameManager.instance.currentMap.middleArrive, GameManager.instance.currentMap.holePosition);
				if (Vector3.Distance(nextPos, GameManager.instance.currentMap.holePosition) - num > 50f)
				{
					zero = (GameManager.instance.currentMap.middleArrive - nextPos).normalized;
					zero.y = 0f;
				}
				else
				{
					zero = (GameManager.instance.currentMap.holePosition - nextPos).normalized;
					zero.y = 0f;
				}
			}
			else
			{
				zero = (GameManager.instance.currentMap.holePosition - nextPos).normalized;
				zero.y = 0f;
			}
			return zero;
		}

		private int GetClubIndex()
		{
			if (GameManager.instance.panjung == Panjung.OB)
			{
				return ClubIndex;
			}
			if (playerGameInfo.ColGroundTag == "TimeOver")
			{
				UnityEngine.Debug.Log("TimeOver Club");
				return ClubIndex;
			}
			if (playerGameInfo.StrokeCount == 0)
			{
				for (int i = 0; i < MaxClubIndex; i++)
				{
					ClubInfo component = ClubParentTR.GetChild(i).GetComponent<ClubInfo>();
					if (!((float)component.Range + component.runRange > playerGameInfo.reMainDistance))
					{
						if (i == 0)
						{
							return i;
						}
						return i - 1;
					}
				}
			}
			else
			{
				if (playerGameInfo.ColGroundTag == "Green")
				{
					return 11;
				}
				for (int j = 1; j < MaxClubIndex - 1; j++)
				{
					ClubInfo component2 = ClubParentTR.GetChild(j).GetComponent<ClubInfo>();
					if (!((float)component2.Range + component2.runRange > playerGameInfo.reMainDistance))
					{
						if (j == 1)
						{
							return j;
						}
						return j - 1;
					}
				}
			}
			return MaxClubIndex - 2;
		}

		private void ChangeStanceDirection(float value)
		{
			StanceDirTR.Rotate(0f, value, 0f);
		}

		private void ChangeStance(float value)
		{
			StanceDirTR.Rotate(0f, value, 0f);
			float y = base.transform.eulerAngles.y;
			float y2 = StanceDirTR.eulerAngles.y;
			angleInDegrees -= (y2 - y) * 0.5f;
			float f = angleInDegrees * (float)Math.PI / 90f;
			float num = ((!PublicGameUIManager.gameSetting.IsRightHanded()) ? (-1f) : 1f);
			Vector3 vector = new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * distance * num + BallSpawnTR.position;
			vector += base.transform.forward * clubInfo.stancePos.x + base.transform.right * clubInfo.stancePos.y * num;
			UnityEngine.Debug.DrawRay(vector, Vector3.up * 2f, Color.red, 30f);
			base.transform.position = vector;
			Vector3 forward = StanceDirTR.forward;
			base.transform.rotation = Quaternion.LookRotation(forward);
			StanceDirTR.localRotation = Quaternion.identity;
			stanceDirection = StanceDirTR.forward;
			PlayerBehaviour.ChangeStanceEvent(forward);
			GameManager.instance.LookRotateArrow(GameManager.instance.GetDistanceHole(BallSpawnTR.position));
		}

		private void ChangeStance(Quaternion rot)
		{
			StanceDirTR.rotation = rot;
			float y = base.transform.eulerAngles.y;
			float y2 = StanceDirTR.eulerAngles.y;
			Vector3 forward = StanceDirTR.forward;
			angleInDegrees -= (y2 - y) * 0.5f;
			float f = angleInDegrees * (float)Math.PI / 90f;
			float num = ((!PublicGameUIManager.gameSetting.IsRightHanded()) ? (-1f) : 1f);
			Vector3 position = new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * distance * num + BallSpawnTR.position;
			position += base.transform.forward * clubInfo.stancePos.x + base.transform.right * clubInfo.stancePos.y * num;
			base.transform.position = position;
			base.transform.rotation = Quaternion.LookRotation(forward);
			StanceDirTR.localRotation = Quaternion.identity;
			stanceDirection = StanceDirTR.forward;
			ChangeStance(0f);
		}

		private Vector3 ChangeAxisVelocity(Vector3 velo, float lanchAngle)
		{
			Vector3 axis = Vector3.Cross(rhs: new Vector3(velo.x, 10f, velo.z), lhs: velo);
			return Quaternion.AngleAxis(lanchAngle, axis) * velo;
		}

		private void CallResetBallEvent()
		{
			PlayerBehaviour.ResetBallEvent();
		}

		private void ChangeClubIndex(int value)
		{
			if (ballBehaviour.colGroundTag == "Green" && playerGameInfo.StrokeCount != 0)
			{
				return;
			}
			ClubIndex += value;
			int num = MaxClubIndex;
			int num2 = 0;
			if (playerGameInfo.StrokeCount == 0)
			{
				num = MaxClubIndex - 1;
			}
			else if (playerGameInfo.ColGroundTag != "Green" && playerGameInfo.ColGroundTag != "OB" && playerGameInfo.ColGroundTag != "TimeOver")
			{
				num2 = 1;
				num = MaxClubIndex - 1;
			}
			else
			{
				float num3 = Mathf.Abs(Vector3.Distance(GameManager.instance.currentMap.TShootZonePosition, GameManager.instance.currentMap.holePosition) - playerGameInfo.reMainDistance);
				num2 = ((!(num3 < 10f) || !(playerGameInfo.ColGroundTag == "OB")) ? ((!(num3 < 10f) || !(playerGameInfo.ColGroundTag == "TimeOver")) ? 1 : 0) : 0);
				if (ballBehaviour.colGroundTag != "Green")
				{
					num = MaxClubIndex - 1;
				}
			}
			if (ClubIndex >= num)
			{
				ClubIndex = num2;
			}
			if (ClubIndex < num2)
			{
				ClubIndex = num - 1;
			}
		}

		private void ChangeClub()
		{
			for (int i = 0; i < ClubParentTR.childCount; i++)
			{
				ClubParentTR.GetChild(i).gameObject.SetActive(value: false);
			}
			ClubParentTR.GetChild(ClubIndex).gameObject.SetActive(value: true);
			clubInfo = ClubParentTR.GetChild(ClubIndex).GetComponent<ClubInfo>();
			equipmentClubState = clubInfo.equipmentClubState;
			PlayerBehaviour.ChangeClubEvent(clubInfo);
			ChangeStance(0f);
			GameInfoUIManager.instance.ClubUI(ClubIndex);
		}

		public void UseMulligan()
		{
			if (GameManager.instance.isPassibleMulligan && GameManager.instance.maxUsebleMulligan > GameManager.instance.useMulliganCount)
			{
				isUseMulligan = true;
				GameInfoUIManager.instance.Mulligan(isOn: false);
				GameInfoUIManager.instance.ShowMulligan(isUseMulligan);
				PlayerBehaviour.mulliganEvent?.Invoke();
			}
		}

		private void ChangeHandler(bool isRight)
		{
			Transform transform = base.transform.Find("XR Rig");
			if (!isRight)
			{
				inputDeviceState = LeftInputDeviceState;
				ClubParentTR.parent.localScale = new Vector3(-1f, 1f, 1f);
				transform.localEulerAngles = new Vector3(0f, -90f, 0f);
			}
			else
			{
				ClubParentTR.parent.localScale = new Vector3(1f, 1f, 1f);
				inputDeviceState = RightInputDeviceState;
				transform.localEulerAngles = new Vector3(0f, 90f, 0f);
			}
			ClubParentTR.parent.parent = inputDeviceState.transform;
			ChangeStance(0f);
			PlayerBehaviour.ChangeHandlderEvent?.Invoke(!isRight, inputDeviceState);
		}

		private void FixedUpdate()
		{
			if (GameManager.instance.gameTurn != 0)
			{
				return;
			}
			float num = ((equipmentClubState == EquipmentClubState.putter) ? 1f : 5f);
			isPressTouchPad = inputDeviceState.primaryClickDown;
			isPressSeconPad = inputDeviceState.secondClickDown;
			if (isPressTouchPad)
			{
				switch (inputDeviceState.axisPadState)
				{
				case InputDeviceState.AxisPad.Up:
					ChangeClubIndex(-1);
					ChangeClub();
					break;
				case InputDeviceState.AxisPad.Down:
					ChangeClubIndex(1);
					ChangeClub();
					break;
				case InputDeviceState.AxisPad.Left:
					ChangeStance(0f - num);
					break;
				case InputDeviceState.AxisPad.Right:
					ChangeStance(num);
					break;
				}
			}
			if (isPressSeconPad)
			{
				switch (inputDeviceState.axisPadState)
				{
				case InputDeviceState.AxisPad.Up:
					ChangeClubIndex(-1);
					ChangeClub();
					break;
				case InputDeviceState.AxisPad.Down:
					ChangeClubIndex(1);
					ChangeClub();
					break;
				case InputDeviceState.AxisPad.Left:
					ChangeStance(0f - num);
					break;
				case InputDeviceState.AxisPad.Right:
					ChangeStance(num);
					break;
				}
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				ChangeStance(0f - num);
			}
			else if (Input.GetKeyDown(KeyCode.D))
			{
				ChangeStance(num);
			}
			else if (Input.GetKeyDown(KeyCode.S))
			{
				ChangeClubIndex(1);
				ChangeClub();
			}
			else if (Input.GetKeyDown(KeyCode.W))
			{
				ChangeClubIndex(-1);
				ChangeClub();
			}
			else if (Input.GetKeyDown(KeyCode.Z))
			{
				CallResetBallEvent();
			}
			else if (Input.GetKeyDown(KeyCode.X))
			{
				UseMulligan();
			}
			isPressTrigger = inputDeviceState.trigger;
		}
	}
	[Serializable]
	public class PlayerGameInfo
	{
		public int number;

		public string name;

		public int StrokeCount;

		public float reMainDistance;

		public float Longist;

		public int PuttingCount;

		public int Score;

		public string ColGroundTag;

		public Vector3 NextPos;

		public GameTurn gameTurn;

		public GolfPlayer.EquipmentClubState equiClub;

		public bool isUseMulligan;

		public PlayerGameInfo(int _number, string _name, int _strokeCount, int _puttingCount, float _reMainDistance, float _longist, int _score)
		{
			number = _number;
			name = _name;
			StrokeCount = _strokeCount;
			reMainDistance = _reMainDistance;
			Longist = _longist;
			PuttingCount = _puttingCount;
			Score = _score;
			ColGroundTag = "";
			NextPos = Vector3.zero;
			isUseMulligan = false;
		}
	}
	[Serializable]
	public class PlayerGameInfoCustomProperties
	{
		public Player player;

		public PlayerGameInfo playerGameInfo;

		public PlayerGameInfoCustomProperties(Player _player, PlayerGameInfo _playerGameInfo)
		{
			player = _player;
			playerGameInfo = _playerGameInfo;
		}
	}
	public class PositionObjectOnWorldImage : MonoBehaviour
	{
		public Camera worldCamera;

		public RectTransform worldImage;

		public Transform endPreViewPosTR;

		public Transform distanceInfoPannelTR;

		public Transform[] PlayerBallViewPosTRs;

		private RectTransform helper;

		private LineRenderer line;

		public static PositionObjectOnWorldImage instance;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
			helper = new GameObject("helper", typeof(RectTransform)).GetComponent<RectTransform>();
			helper.SetParent(worldImage, worldPositionStays: false);
			helper.anchorMin = Vector2.zero;
			helper.anchorMax = Vector2.zero;
			line = base.transform.Find("RangeLine").GetComponent<LineRenderer>();
		}

		public Vector3 GetPositionOnUI(Vector3 worldPosition)
		{
			Vector2 vector = RectTransformUtility.WorldToScreenPoint(worldCamera, worldPosition);
			Vector2 anchoredPosition = new Vector2(vector.x * worldImage.rect.width / (float)worldCamera.pixelWidth, vector.y * worldImage.rect.height / (float)worldCamera.pixelHeight);
			helper.anchoredPosition = anchoredPosition;
			return helper.position;
		}

		public void SetPositionOnUI(Vector3 _pos, Transform _TR)
		{
			Vector3 positionOnUI = GetPositionOnUI(_pos);
			positionOnUI.y -= 1.4f;
			_TR.position = new Vector3(_TR.position.x, positionOnUI.y, _TR.position.z);
			float x = helper.anchoredPosition.x;
			x -= 0.525f;
			_TR.localPosition = new Vector3(x, _TR.localPosition.y, _TR.localPosition.z);
		}

		public void SetPositionOnUI(Vector3 _otherPos, bool is1P)
		{
			Vector3 positionOnUI = GetPositionOnUI(_otherPos);
			positionOnUI.y -= 1.4f;
			Transform transform = (is1P ? PlayerBallViewPosTRs[1] : PlayerBallViewPosTRs[0]);
			transform.gameObject.SetActive(value: true);
			transform.position = new Vector3(transform.position.x, positionOnUI.y, transform.position.z);
			float x = helper.anchoredPosition.x;
			x -= 0.525f;
			transform.localPosition = new Vector3(x, transform.localPosition.y, transform.localPosition.z);
		}

		private void DrawShootRange()
		{
			if (MinimapController.instance.DrawPreview() == null)
			{
				line.positionCount = 0;
				return;
			}
			Vector3[] array = MinimapController.instance.DrawPreview();
			Transform[] array2 = new Transform[array.Length];
			line.positionCount = array.Length;
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = GetPositionOnUI(array[i]);
				array[i].y -= 1.4f;
				array2[i] = line.transform.GetChild(i);
				float x = helper.anchoredPosition.x;
				x -= 0.525f;
				array2[i].position = new Vector3(array2[i].position.x, array[i].y, array2[i].position.z);
				array2[i].localPosition = new Vector3(x, array2[i].localPosition.y, array2[i].localPosition.z);
				line.SetPosition(i, array2[i].position);
			}
		}

		private void Update()
		{
			SetPositionOnUI(endPreViewPosTR.position, distanceInfoPannelTR);
			DrawShootRange();
		}
	}
	public class RPCManager : MonoBehaviourPunCallbacks
	{
		private delegate void Func<T>(T value);

		public BallBehaviour ballBehaviour;

		private PhotonView pview;

		public List<PlayerGameInfoCustomProperties> playerGameInfos = new List<PlayerGameInfoCustomProperties>();

		public ExitGames.Client.Photon.Hashtable myCustomProperty = new ExitGames.Client.Photon.Hashtable();

		public ExitGames.Client.Photon.Hashtable roomCustomProperty = new ExitGames.Client.Photon.Hashtable();

		private PlayerGameInfo myGameInfo;

		private PlayerGameInfo otherPlayerGameInfo;

		private List<Vector3> ballPosList = new List<Vector3>();

		private List<string> carryList = new List<string>();

		private List<string> runList = new List<string>();

		private List<string> totalList = new List<string>();

		private List<string> remainDis = new List<string>();

		private bool isDone;

		public float shootSyncDelayTime;

		public float TimeLimitValue;

		private Coroutine TimeLimitCoroutine;

		public Transform XRRigTR;

		private IEnumerator m_drawShoot;

		private bool DoDraw;

		public override void OnEnable()
		{
			base.OnEnable();
			GameManager.MultiStartEvent += SetStart;
			GameManager.panjungEvent += Panjung;
			GameManager.changeViewEvent += ChangeView;
			GameManager.MultiResultEvent += MultiResult;
			GameManager.mulliganEvent += Panjung;
			cFollower.hitBallEvent += Shoot;
			GameInfoUIManager.PanjungEvent += PanjungUI;
			GameInfoUIManager.ConcedeEvent += ConcedeUI;
			GameInfoUIManager.DistanceInfoEvent += DistanceInfo;
			GameInfoUIManager.CarryInfoEvent += CarryInfo;
			GameInfoUIManager.GoTitleEvent += LeaveRoom;
			GameInfoUIManager.TimeInfoEvent += TimeInfo;
			PlayerBehaviour.mulliganEvent += ShowMulligan;
			PlayerBehaviour.ChangeClubEvent += ChangeClub;
			BallBehaviour.BallDropSoundEvent += BallDropSound;
			VoiceManager.PanjungVoiceEvent += PanjungVoice;
			PhotonManager.OtherPlayerLeftEvent += OtherPlayerLeft;
			PlayerBehaviour.ChangeHandlderEvent += ChangeHandlderEvent;
		}

		public override void OnDisable()
		{
			base.OnDisable();
			GameManager.MultiStartEvent -= SetStart;
			GameManager.panjungEvent -= Panjung;
			GameManager.changeViewEvent -= ChangeView;
			GameManager.MultiResultEvent -= MultiResult;
			GameManager.mulliganEvent -= Panjung;
			cFollower.hitBallEvent -= Shoot;
			GameInfoUIManager.PanjungEvent -= PanjungUI;
			GameInfoUIManager.ConcedeEvent -= ConcedeUI;
			GameInfoUIManager.DistanceInfoEvent -= DistanceInfo;
			GameInfoUIManager.CarryInfoEvent -= CarryInfo;
			GameInfoUIManager.GoTitleEvent -= LeaveRoom;
			GameInfoUIManager.TimeInfoEvent -= TimeInfo;
			PlayerBehaviour.mulliganEvent -= ShowMulligan;
			PlayerBehaviour.ChangeClubEvent -= ChangeClub;
			BallBehaviour.BallDropSoundEvent -= BallDropSound;
			VoiceManager.PanjungVoiceEvent -= PanjungVoice;
			PhotonManager.OtherPlayerLeftEvent -= OtherPlayerLeft;
			PlayerBehaviour.ChangeHandlderEvent -= ChangeHandlderEvent;
			playerGameInfos.Clear();
		}

		private void OnDestroy()
		{
			playerGameInfos.Clear();
		}

		private void Awake()
		{
			SetMyCustomProperties();
			if (PhotonNetwork.IsMasterClient)
			{
				StartCoroutine(MapSelect());
			}
		}

		private IEnumerator MapSelect()
		{
			while (MapLoader.instance == null)
			{
				yield return null;
			}
			int num = ((SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GolfMapIndex != -1) ? (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GolfMapIndex + 1) : UnityEngine.Random.Range(0, MapLoader.instance.SceneName.Length));
			if (num > 8)
			{
				num = 0;
			}
			SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GolfMapIndex = num;
			MapLoader.instance.index = num;
			MapLoader.instance.isGetMapIndex = true;
			base.photonView.RPC("RPC_MapSelect", RpcTarget.Others, num);
		}

		[PunRPC]
		private void RPC_MapSelect(int _mapIndex)
		{
			UnityEngine.Debug.Log("Get Map Index!! : " + _mapIndex);
			MapLoader.instance.index = _mapIndex;
			MapLoader.instance.isGetMapIndex = true;
		}

		private void SetMyCustomProperties()
		{
			myCustomProperty["number"] = (PhotonNetwork.IsMasterClient ? 1 : 2);
			myCustomProperty["name"] = PhotonNetwork.LocalPlayer.NickName;
			myCustomProperty["strokeCount"] = 0;
			myCustomProperty["puttingCount"] = 0;
			myCustomProperty["remainDistance"] = 0f;
			myCustomProperty["longist"] = 0f;
			myCustomProperty["score"] = 0;
			myCustomProperty["colGroundTag"] = "";
			myCustomProperty["isRightHand"] = PublicGameUIManager.gameSetting.IsRightHanded();
			if (PhotonNetwork.LocalPlayer.CustomProperties.ContainsKey("gameTurn"))
			{
				myCustomProperty["gameTurn"] = GameTurn.other;
			}
			PhotonNetwork.SetPlayerCustomProperties(myCustomProperty);
		}

		private void Start()
		{
			base.enabled = (PhotonNetwork.InRoom ? true : false);
			if (PhotonNetwork.InRoom)
			{
				Initialized();
			}
		}

		private void Initialized()
		{
			pview = GetComponent<PhotonView>();
			GetCurrentRoomPlayers();
			GameManager.instance.gameTurn = ((!PhotonNetwork.IsMasterClient) ? GameTurn.other : GameTurn.my);
		}

		private void GetCurrentRoomPlayers()
		{
			if (!PhotonNetwork.IsConnected || PhotonNetwork.CurrentRoom == null || PhotonNetwork.CurrentRoom.Players == null)
			{
				return;
			}
			foreach (KeyValuePair<int, Player> player in PhotonNetwork.CurrentRoom.Players)
			{
				AddPlayerGameInfo(player.Value);
			}
		}

		private void AddPlayerGameInfo(Player player)
		{
			if (playerGameInfos.FindIndex((PlayerGameInfoCustomProperties x) => x.player == player) == -1)
			{
				StartCoroutine(IEnum_WaitGetCustomProperties(player));
			}
		}

		private IEnumerator IEnum_WaitGetCustomProperties(Player player)
		{
			while (!player.CustomProperties.ContainsKey("number"))
			{
				yield return null;
			}
			while (!player.CustomProperties.ContainsKey("name"))
			{
				yield return null;
			}
			ExitGames.Client.Photon.Hashtable customProperties = player.CustomProperties;
			PlayerGameInfo playerGameInfo = new PlayerGameInfo((int)customProperties["number"], (string)customProperties["name"], (int)customProperties["strokeCount"], (int)customProperties["puttingCount"], (float)customProperties["remainDistance"], (float)customProperties["longist"], (int)customProperties["score"]);
			playerGameInfos.Add(new PlayerGameInfoCustomProperties(player, playerGameInfo));
			if (player == PhotonNetwork.LocalPlayer)
			{
				GameManager.instance.playerGameInfo = playerGameInfo;
			}
		}

		public override void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			SetPlayergameInfo(targetPlayer);
		}

		private void SetPlayergameInfo(Player player)
		{
			int num = playerGameInfos.FindIndex((PlayerGameInfoCustomProperties x) => x.player == player);
			if (num == -1)
			{
				return;
			}
			if (player.CustomProperties.ContainsKey("name"))
			{
				playerGameInfos[num].playerGameInfo.name = (string)player.CustomProperties["name"];
			}
			if (player.CustomProperties.ContainsKey("number"))
			{
				playerGameInfos[num].playerGameInfo.number = (int)player.CustomProperties["number"];
			}
			if (player.CustomProperties.ContainsKey("strokeCount"))
			{
				playerGameInfos[num].playerGameInfo.StrokeCount = (int)player.CustomProperties["strokeCount"];
			}
			if (player.CustomProperties.ContainsKey("puttingCount"))
			{
				playerGameInfos[num].playerGameInfo.PuttingCount = (int)player.CustomProperties["puttingCount"];
			}
			if (player.CustomProperties.ContainsKey("remainDistance"))
			{
				playerGameInfos[num].playerGameInfo.reMainDistance = (float)player.CustomProperties["remainDistance"];
			}
			if (player.CustomProperties.ContainsKey("longist"))
			{
				playerGameInfos[num].playerGameInfo.Longist = (float)player.CustomProperties["longist"];
			}
			if (player.CustomProperties.ContainsKey("score"))
			{
				playerGameInfos[num].playerGameInfo.Score = (int)player.CustomProperties["score"];
			}
			if (player.CustomProperties.ContainsKey("colGroundTag"))
			{
				playerGameInfos[num].playerGameInfo.ColGroundTag = (string)player.CustomProperties["colGroundTag"];
			}
			if (player.CustomProperties.ContainsKey("nextPos"))
			{
				playerGameInfos[num].playerGameInfo.NextPos = (Vector3)player.CustomProperties["nextPos"];
			}
			if (player.CustomProperties.ContainsKey("gameTurn"))
			{
				playerGameInfos[num].playerGameInfo.gameTurn = (GameTurn)player.CustomProperties["gameTurn"];
			}
			if (player.CustomProperties.ContainsKey("equiClub"))
			{
				playerGameInfos[num].playerGameInfo.equiClub = (GolfPlayer.EquipmentClubState)player.CustomProperties["equiClub"];
			}
			if (player.CustomProperties.ContainsKey("isUseMulligan"))
			{
				playerGameInfos[num].playerGameInfo.isUseMulligan = (bool)player.CustomProperties["isUseMulligan"];
			}
			if (playerGameInfos[num].player != PhotonNetwork.LocalPlayer)
			{
				otherPlayerGameInfo = playerGameInfos[num].playerGameInfo;
				if (player.CustomProperties.ContainsKey("isRightHand"))
				{
					bool isRight = (bool)player.CustomProperties["isRightHand"];
					MultiPlayerManager.instance.ChangeHand(isRight);
				}
			}
			else
			{
				myGameInfo = playerGameInfos[num].playerGameInfo;
			}
		}

		private void SetStart(Vector3 pos)
		{
			StartCoroutine(IEnum_waitingPlayer(pos));
		}

		private IEnumerator IEnum_waitingPlayer(Vector3 pos)
		{
			myCustomProperty["nextPos"] = pos;
			myCustomProperty["remainDistance"] = GameManager.instance.currentMap.HoleDistance;
			myCustomProperty["gameTurn"] = GameManager.instance.gameTurn;
			PhotonNetwork.SetPlayerCustomProperties(myCustomProperty);
			while (myGameInfo == null || otherPlayerGameInfo == null)
			{
				yield return null;
			}
			GameManager.instance.playerGameInfo = playerGameInfos.Find((PlayerGameInfoCustomProperties x) => x.player == PhotonNetwork.LocalPlayer).playerGameInfo;
			GameManager.instance.playerGameInfo.reMainDistance = GameManager.instance.currentMap.HoleDistance;
			SingletonBase.Singleton<CameraFade_SGT>.GetInstance.StartFadeIn();
			otherPlayerGameInfo.number = ((!PhotonNetwork.IsMasterClient) ? 1 : 2);
			otherPlayerGameInfo.reMainDistance = GameManager.instance.currentMap.HoleDistance;
			GameManager.instance.golfPlayers[0].SetPlayerGameInfo(myGameInfo);
			GameInfoUIManager.instance.playerGameInfo = myGameInfo;
			GameInfoUIManager.instance.HelpGO.SetActive(value: false);
			if (PhotonNetwork.IsMasterClient)
			{
				GameInfoUIManager.instance.GetPlayer1GameInfo(myGameInfo);
				GameInfoUIManager.instance.GetPlayer2GameInfo(otherPlayerGameInfo);
			}
			else
			{
				GameInfoUIManager.instance.GetPlayer1GameInfo(otherPlayerGameInfo);
				GameInfoUIManager.instance.GetPlayer2GameInfo(myGameInfo);
			}
			StartCoroutine(IEnum_SetStart(pos));
		}

		private IEnumerator IEnum_SetStart(Vector3 pos)
		{
			while (MultiPlayerManager.instance.OtherPlayerCharacter == null)
			{
				yield return null;
			}
			if (GameManager.instance.gameTurn == GameTurn.my)
			{
				GameManager.instance.currentMap.EnableCheckHole(isUse: true);
				MultiPlayerManager.instance.LocalPlayer.transform.position = pos;
				GameManager.moveToStroke(MultiPlayerManager.instance.LocalPlayer.transform.position);
				MultiPlayerManager.instance.SetActive(isOn: false);
				GameManager.instance.ShootTimeCheck(pos);
				if (PublicGameUIManager.gameSetting.IsRightHanded())
				{
					XRRigTR.localEulerAngles = new Vector3(0f, 90f, 0f);
				}
				else
				{
					XRRigTR.localEulerAngles = new Vector3(0f, -90f, 0f);
				}
			}
			else
			{
				BallPhysics.instance.ClearBallPreView();
				GameManager.instance.currentMap.EnableCheckHole(isUse: false);
				GameManager.instance.golfPlayers[0].ClubParentTR.gameObject.SetActive(value: false);
				SetViewPosition(pos);
				GameManager.moveToStroke(MultiPlayerManager.instance.LocalPlayer.transform.position);
				ballBehaviour.transform.position = pos;
				MultiPlayerManager.instance.SetActive(isOn: true);
				MultiPlayerManager.instance.Idle(otherPlayerGameInfo.ColGroundTag);
				XRRigTR.localEulerAngles = Vector3.zero;
			}
		}

		private void ChangeHandlderEvent(bool isLeftHand, InputDeviceState _inputDeviceState)
		{
			myCustomProperty["isRightHand"] = !isLeftHand;
			PhotonNetwork.SetPlayerCustomProperties(myCustomProperty);
			if (GameManager.instance.gameTurn == GameTurn.my)
			{
				if (PublicGameUIManager.gameSetting.IsRightHanded())
				{
					XRRigTR.localEulerAngles = new Vector3(0f, 90f, 0f);
				}
				else
				{
					XRRigTR.localEulerAngles = new Vector3(0f, -90f, 0f);
				}
			}
			else
			{
				XRRigTR.localEulerAngles = Vector3.zero;
			}
		}

		private void OtherPlayerChangeHand(bool isRight)
		{
			MultiPlayerManager.instance.ChangeHand(isRight);
		}

		private void ChangeClub(ClubInfo clubInfo)
		{
			UnityEngine.Debug.Log("ChangeClub RPC Send!!");
			myCustomProperty["equiClub"] = clubInfo.equipmentClubState;
			PhotonNetwork.SetPlayerCustomProperties(myCustomProperty);
			pview.RPC("RPC_equiClub", RpcTarget.Others);
		}

		private void BallDropSound(string str)
		{
			StartCoroutine(IEnum_BallDropSound(str));
		}

		private IEnumerator IEnum_BallDropSound(string str)
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			pview.RPC("RPC_ballDropSound", RpcTarget.Others, str);
		}

		private void Panjung(PlayerGameInfo _playerGameInfo)
		{
			myCustomProperty["strokeCount"] = _playerGameInfo.StrokeCount;
			myCustomProperty["puttingCount"] = _playerGameInfo.PuttingCount;
			_playerGameInfo.reMainDistance = (float)Math.Truncate(_playerGameInfo.reMainDistance * 10f) / 10f;
			myCustomProperty["remainDistance"] = _playerGameInfo.reMainDistance;
			myCustomProperty["longist"] = _playerGameInfo.Longist;
			myCustomProperty["score"] = _playerGameInfo.Score;
			myCustomProperty["colGroundTag"] = _playerGameInfo.ColGroundTag;
			myCustomProperty["nextPos"] = _playerGameInfo.NextPos;
			myCustomProperty["gameTurn"] = _playerGameInfo.gameTurn;
			myCustomProperty["isUseMulligan"] = _playerGameInfo.isUseMulligan;
			PhotonNetwork.SetPlayerCustomProperties(myCustomProperty);
			myGameInfo = _playerGameInfo;
			StartCoroutine(IEnum_panjung());
		}

		private IEnumerator IEnum_cour<T>(Func<T> func, T arg) where T : class
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			func(arg);
		}

		private IEnumerator IEnum_panjung()
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			pview.RPC("RPC_Panjung", RpcTarget.All);
		}

		private void Shoot(Vector3 velocity, BallQuality ballQuality, float swingAngle, float hitAngle, float accel)
		{
			StartCoroutine(IEnum_Shoot(swingAngle, hitAngle, accel));
		}

		private void SetBallDraw(float swingAngle, float hitAngle, float accel)
		{
			float num = Mathf.Abs(swingAngle);
			bool flag = Mathf.Abs(hitAngle) < 0.3f && num < 0.2f && accel > 110f;
			pview.RPC("RPC_SetBallDraw", RpcTarget.Others, accel, flag);
		}

		private IEnumerator IEnum_Shoot(float swingAngle, float hitAngle, float accel)
		{
			SetBallDraw(swingAngle, hitAngle, accel);
			GameManager.instance.currentMap.EnableCheckHole(isUse: true);
			while (!ballBehaviour.rigid.isKinematic)
			{
				pview.RPC("RPC_Shoot", RpcTarget.Others, ballBehaviour.transform.position);
				yield return new WaitForFixedUpdate();
			}
			StopBallDraw();
		}

		private IEnumerator testShoot(bool isNiceShoot, float accel)
		{
			ballPosList.Clear();
			carryList.Clear();
			runList.Clear();
			totalList.Clear();
			remainDis.Clear();
			yield return new WaitForSeconds(shootSyncDelayTime);
			if (isNiceShoot)
			{
				ballBehaviour.NiceShoot();
			}
			ballBehaviour.SetTrailAndArrow(otherPlayerGameInfo.equiClub == GolfPlayer.EquipmentClubState.putter);
			ballBehaviour.HitParticle(otherPlayerGameInfo.equiClub, otherPlayerGameInfo.ColGroundTag, accel);
			ballBehaviour.ballHitSound(otherPlayerGameInfo.equiClub);
			DoDraw = true;
			UnityEngine.Debug.Log("DODraw : " + DoDraw);
			DrawShoot();
		}

		private void ChangeView()
		{
			StartCoroutine(IEnum_ChangeView());
		}

		private IEnumerator IEnum_ChangeView()
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			pview.RPC("RPC_ChangeView", RpcTarget.All);
		}

		private void PanjungUI(string str)
		{
			StartCoroutine(IEnum_panjungUi(str));
		}

		private IEnumerator IEnum_panjungUi(string str)
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			pview.RPC("RPC_PanjungUI", RpcTarget.Others, str);
		}

		private void ConcedeUI(bool isConcede)
		{
			StartCoroutine(IEnum_ConcedeUI(isConcede));
		}

		private IEnumerator IEnum_ConcedeUI(bool isConcede)
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			pview.RPC("RPC_ConcedeUI", RpcTarget.Others, isConcede);
		}

		private void PanjungVoice(string[] clipNames)
		{
			StartCoroutine(IEnum_PanjungVoice(clipNames));
		}

		private IEnumerator IEnum_PanjungVoice(string[] clipNames)
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			pview.RPC("RPC_PanjungVoice", RpcTarget.Others, new object[1] { clipNames });
		}

		private void DistanceInfo(string[] Infos)
		{
			pview.RPC("RPC_DistanceInfo", RpcTarget.Others, new object[1] { Infos });
		}

		private void CarryInfo(string[] Infos)
		{
			pview.RPC("RPC_CarryInfo", RpcTarget.Others, new object[1] { Infos });
		}

		private void TimeInfo(string TimeString)
		{
			pview.RPC("RPC_TimeInfo", RpcTarget.Others, TimeString);
		}

		public void DrawShoot()
		{
			m_drawShoot = IEnum_drawShoot();
			StartCoroutine(m_drawShoot);
		}

		private IEnumerator IEnum_drawShoot()
		{
			int index = 0;
			while (DoDraw)
			{
				if (index >= ballPosList.Count)
				{
					UnityEngine.Debug.Log("RPC 로스!!!!!!");
					yield return new WaitForFixedUpdate();
					continue;
				}
				ballBehaviour.transform.position = ballPosList[index];
				index++;
				yield return new WaitForFixedUpdate();
				if (index < carryList.Count)
				{
					GameInfoUIManager.instance.ReceiveCarryInfo(carryList[index], runList[index], totalList[index], remainDis[index]);
				}
			}
			m_drawShoot = null;
		}

		private void MultiResult()
		{
			GameInfoUIManager.instance.SetResultInfo(otherPlayerGameInfo);
		}

		private void OtherPlayerLeft(Player player)
		{
			string nickName = PhotonNetwork.LocalPlayer.NickName;
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
			PublicGameUIManager.GetInstance.OpenResultBoard("상대방이 나갔습니다.", winnerPlayer);
		}

		[PunRPC]
		private void RPC_ChangeView(PhotonMessageInfo info)
		{
			GameManager.instance.currentMap.EnableCheckHole(isUse: false);
			GameInfoUIManager.instance.UIPanjung("");
			GameInfoUIManager.instance.UIConcede(isConcede: false);
			if (m_drawShoot != null)
			{
				StopCoroutine(m_drawShoot);
				m_drawShoot = null;
			}
			if (GameManager.instance.gameTurn == GameTurn.my)
			{
				GameManager.instance.golfPlayers[0].ClubParentTR.gameObject.SetActive(value: true);
				MultiPlayerManager.instance.LocalPlayer.transform.position = (Vector3)myCustomProperty["nextPos"];
				GameManager.moveToStroke(MultiPlayerManager.instance.LocalPlayer.transform.position);
				UnityEngine.Debug.Log(otherPlayerGameInfo.number);
				UnityEngine.Debug.Log(myGameInfo.number);
				MultiPlayerManager.instance.WaitAndWatchingMe(myGameInfo.NextPos, otherPlayerGameInfo.NextPos);
				GameManager.instance.ShootTimeCheck(MultiPlayerManager.instance.LocalPlayer.transform.position);
				if (PublicGameUIManager.gameSetting.IsRightHanded())
				{
					XRRigTR.localEulerAngles = new Vector3(0f, 90f, 0f);
				}
				else
				{
					XRRigTR.localEulerAngles = new Vector3(0f, -90f, 0f);
				}
			}
			else if (GameManager.instance.gameTurn == GameTurn.end && otherPlayerGameInfo.gameTurn == GameTurn.end)
			{
				UnityEngine.Debug.Log("GameEnd!!!!!!!!!!");
			}
			else
			{
				GameManager.instance.golfPlayers[0].ClubParentTR.gameObject.SetActive(value: false);
				ballBehaviour.SetTrailAndArrow(otherPlayerGameInfo.equiClub == GolfPlayer.EquipmentClubState.putter);
				SetViewPosition(otherPlayerGameInfo.NextPos);
				GameManager.moveToStroke(MultiPlayerManager.instance.LocalPlayer.transform.position);
				BallPhysics.instance.ClearBallPreView();
				MultiPlayerManager.instance.SetActive(isOn: true);
				MultiPlayerManager.instance.Idle(otherPlayerGameInfo.ColGroundTag);
				ballBehaviour.transform.position = otherPlayerGameInfo.NextPos;
				XRRigTR.localEulerAngles = Vector3.zero;
			}
			PositionObjectOnWorldImage.instance.SetPositionOnUI(otherPlayerGameInfo.NextPos, PhotonNetwork.IsMasterClient);
			GameManager.instance.golfPlayers[0].SetPlayerGameInfo(myGameInfo);
			GameInfoUIManager.instance.playerGameInfo = myGameInfo;
			if (PhotonNetwork.IsMasterClient)
			{
				GameInfoUIManager.instance.GetPlayer1GameInfo(myGameInfo);
				GameInfoUIManager.instance.GetPlayer2GameInfo(otherPlayerGameInfo);
			}
			else
			{
				GameInfoUIManager.instance.GetPlayer1GameInfo(otherPlayerGameInfo);
				GameInfoUIManager.instance.GetPlayer2GameInfo(myGameInfo);
			}
		}

		public void ChangeLange()
		{
			if (myGameInfo != null && otherPlayerGameInfo != null)
			{
				if (PhotonNetwork.IsMasterClient)
				{
					GameInfoUIManager.instance.GetPlayer1GameInfo(myGameInfo);
					GameInfoUIManager.instance.GetPlayer2GameInfo(otherPlayerGameInfo);
				}
				else
				{
					GameInfoUIManager.instance.GetPlayer1GameInfo(otherPlayerGameInfo);
					GameInfoUIManager.instance.GetPlayer2GameInfo(myGameInfo);
				}
			}
		}

		private void SetViewPosition(Vector3 OtherPos)
		{
			float num = 3.2f;
			Vector3 normalized = (OtherPos - GameManager.instance.currentMap.holePosition).normalized;
			normalized.y = 0f;
			Quaternion rotation = Quaternion.LookRotation(normalized);
			MultiPlayerManager.instance.LocalPlayer.transform.position = OtherPos + normalized * num;
			MultiPlayerManager.instance.LocalPlayer.transform.rotation = rotation;
			if (otherPlayerGameInfo.ColGroundTag == "Green")
			{
				MultiPlayerManager.instance.LocalPlayer.transform.position -= MultiPlayerManager.instance.LocalPlayer.transform.right * 2.5f;
			}
		}

		private void StopBallDraw()
		{
			pview.RPC("RPC_StopBallDraw", RpcTarget.Others);
		}

		[PunRPC]
		private void RPC_equiClub(PhotonMessageInfo info)
		{
			if (MultiPlayerManager.instance.OtherPlayerCharacter != null)
			{
				MultiPlayerManager.instance.ChangeClub((GolfPlayer.EquipmentClubState)info.Sender.CustomProperties["equiClub"]);
			}
			shootSyncDelayTime = MultiPlayerManager.instance.animHitTime;
		}

		[PunRPC]
		private void RPC_SetBallDraw(float accel, bool isNiceShoot)
		{
			MultiPlayerManager.instance.SetAnim(accel);
			StartCoroutine(testShoot(isNiceShoot, accel));
		}

		[PunRPC]
		private void RPC_StopBallDraw()
		{
			StartCoroutine(IEnum_StopBallDraw());
		}

		private IEnumerator IEnum_StopBallDraw()
		{
			yield return new WaitForSeconds(shootSyncDelayTime);
			DoDraw = false;
		}

		[PunRPC]
		private void RPC_Shoot(Vector3 ballPos)
		{
			ballPosList.Add(ballPos);
		}

		[PunRPC]
		private void RPC_Panjung(PhotonMessageInfo info)
		{
			if (GameManager.instance.gameTurn == GameTurn.end && otherPlayerGameInfo.gameTurn == GameTurn.end)
			{
				GameManager.instance.Result();
			}
			else if (GameManager.instance.gameTurn != GameTurn.end && otherPlayerGameInfo.gameTurn == GameTurn.end)
			{
				GameManager.instance.gameTurn = GameTurn.my;
			}
			else if (GameManager.instance.gameTurn == GameTurn.end && otherPlayerGameInfo.gameTurn != GameTurn.end)
			{
				GameManager.instance.gameTurn = GameTurn.end;
			}
			else if (myGameInfo.isUseMulligan || otherPlayerGameInfo.isUseMulligan)
			{
				if (myGameInfo.isUseMulligan)
				{
					GameManager.instance.gameTurn = GameTurn.my;
				}
				else if (otherPlayerGameInfo.isUseMulligan)
				{
					GameManager.instance.gameTurn = GameTurn.other;
				}
			}
			else if (myGameInfo.reMainDistance == otherPlayerGameInfo.reMainDistance)
			{
				if (otherPlayerGameInfo.gameTurn == GameTurn.other)
				{
					GameManager.instance.gameTurn = GameTurn.other;
				}
				else
				{
					GameManager.instance.gameTurn = GameTurn.my;
				}
			}
			else if (myGameInfo.ColGroundTag == "TimeOver")
			{
				GameManager.instance.gameTurn = GameTurn.other;
				myCustomProperty["colGroundTag"] = ballBehaviour.colGroundTag;
			}
			else if (otherPlayerGameInfo.ColGroundTag == "TimeOver")
			{
				GameManager.instance.gameTurn = GameTurn.my;
			}
			else
			{
				GameManager.instance.gameTurn = ((!(myGameInfo.reMainDistance > otherPlayerGameInfo.reMainDistance)) ? GameTurn.other : GameTurn.my);
			}
			myCustomProperty["gameTurn"] = GameManager.instance.gameTurn;
			PhotonNetwork.SetPlayerCustomProperties(myCustomProperty);
		}

		[PunRPC]
		private void RPC_PanjungUI(string str)
		{
			UnityEngine.Debug.Log("receive str : " + str);
			GameInfoUIManager.instance.SendPanjungUI(str);
		}

		[PunRPC]
		private void RPC_ConcedeUI(bool isConcede)
		{
			GameInfoUIManager.instance.SendConcedeUI(isConcede);
		}

		[PunRPC]
		private void RPC_PanjungVoice(object _clipNames)
		{
			string[] clipNames = (string[])_clipNames;
			VoiceManager.instance.SendPanjung(clipNames);
		}

		[PunRPC]
		private void RPC_DistanceInfo(object _Infos)
		{
			string[] infos = (string[])_Infos;
			GameInfoUIManager.instance.ReceiveDistanceInfo(infos);
		}

		[PunRPC]
		private void RPC_CarryInfo(object _Infos)
		{
			string[] array = (string[])_Infos;
			carryList.Add(array[0]);
			runList.Add(array[1]);
			totalList.Add(array[2]);
			remainDis.Add(array[3]);
		}

		[PunRPC]
		private void RPC_TimeInfo(string str)
		{
			GameInfoUIManager.instance.ReceiveTimeLimit(str);
		}

		[PunRPC]
		private void RPC_ballDropSound(string str)
		{
			ballBehaviour.ReceiveBallDropSound(str);
		}

		private void ShowMulligan()
		{
			pview.RPC("RPC_ShowMulligan", RpcTarget.Others);
		}

		[PunRPC]
		private void RPC_ShowMulligan()
		{
			GameInfoUIManager.instance.ShowMulligan(isOn: true);
		}

		private void LeaveRoom()
		{
			PhotonManager.instance.LeaveRoom();
		}
	}
	[Serializable]
	public class BallDropSoundClips
	{
		public AudioClip[] bunker;

		public AudioClip[] hazard;

		public AudioClip[] hole;
	}
	[Serializable]
	public class BallHitSoundClips
	{
		public AudioClip[] drive;

		public AudioClip[] wood;

		public AudioClip[] iron;

		public AudioClip[] wedge;

		public AudioClip[] putter;
	}
	[Serializable]
	public class CrowdsSoundClips
	{
		public AudioClip[] cheer;

		public AudioClip[] ohh;
	}
	[Serializable]
	public class UISoundClips
	{
		public AudioClip[] Button;
	}
	[Serializable]
	public class UIMultiResultSoundClips
	{
		public AudioClip[] Result;
	}
	public class SoundManager : MonoBehaviour
	{
		public static SoundManager instance;

		public BallHitSoundClips ballHitSoundClips;

		public BallDropSoundClips ballDropSoundClips;

		public CrowdsSoundClips crowdsSoundClips;

		public UISoundClips uiSoundClips;

		public UIMultiResultSoundClips iIMultiResultSoundClips;

		private Dictionary<string, AudioClip[]> soundDictionary = new Dictionary<string, AudioClip[]>();

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Start()
		{
			SetSoundClips();
		}

		private void SetSoundClips()
		{
			soundDictionary.Clear();
			soundDictionary.Add("drive", ballHitSoundClips.drive);
			soundDictionary.Add("wood", ballHitSoundClips.wood);
			soundDictionary.Add("iron", ballHitSoundClips.iron);
			soundDictionary.Add("wedge", ballHitSoundClips.wedge);
			soundDictionary.Add("putter", ballHitSoundClips.putter);
			soundDictionary.Add("Bunker", ballDropSoundClips.bunker);
			soundDictionary.Add("Hazerd", ballDropSoundClips.hazard);
			soundDictionary.Add("hole", ballDropSoundClips.hole);
			soundDictionary.Add("cheer", crowdsSoundClips.cheer);
			soundDictionary.Add("ohh", crowdsSoundClips.ohh);
			soundDictionary.Add("button", uiSoundClips.Button);
			soundDictionary.Add("result", iIMultiResultSoundClips.Result);
		}

		public AudioClip GetSoundClip(string name)
		{
			if (!soundDictionary.ContainsKey(name))
			{
				return null;
			}
			int num = UnityEngine.Random.Range(0, soundDictionary[name].Length);
			return soundDictionary[name][num];
		}

		public AudioClip GetSoundClip(string name, int index)
		{
			return soundDictionary[name][index];
		}
	}
	[ExecuteInEditMode]
	public class SpriteText : MonoBehaviour
	{
		[SerializeField]
		private int sortingOrder;

		[SerializeField]
		private int sortingLayerID;

		private Renderer rend;

		public int SortingLayerID
		{
			get
			{
				return sortingLayerID;
			}
			set
			{
				SortingLayer[] layers = SortingLayer.layers;
				if (!SortingLayer.IsValid(value))
				{
					sortingLayerID = layers[0].id;
				}
				sortingLayerID = value;
				RefreshSort();
			}
		}

		private int SortingOrder
		{
			get
			{
				return sortingOrder;
			}
			set
			{
				sortingOrder = Mathf.Max(0, value);
				RefreshSort();
			}
		}

		private void Start()
		{
			SortingLayer[] layers = SortingLayer.layers;
			if (!SortingLayer.IsValid(sortingLayerID))
			{
				sortingLayerID = layers[0].id;
			}
			RefreshSort();
		}

		private void OnValidate()
		{
			sortingOrder = Mathf.Max(0, sortingOrder);
		}

		public void RefreshSort()
		{
			if (!rend)
			{
				rend = GetComponent<Renderer>();
			}
			if ((bool)rend)
			{
				rend.sortingLayerID = SortingLayerID;
				rend.sortingOrder = SortingOrder;
			}
		}
	}
	public class UIPause : MonoBehaviour
	{
		public Transform HeadCamTR;

		private Vector3 originPos;

		private void Start()
		{
			originPos = base.transform.position;
		}

		private void Update()
		{
			Vector3 eulerAngles = new Vector3(0f, HeadCamTR.eulerAngles.y, 0f);
			base.transform.eulerAngles = eulerAngles;
		}
	}
	public class VoiceManager : MonoBehaviour
	{
		public delegate void PanjungVoice(string[] strs);

		public static VoiceManager instance;

		[HideInInspector]
		public AudioSource Audio;

		public static event PanjungVoice PanjungVoiceEvent;

		private void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			Audio = GetComponent<AudioSource>();
		}

		public void PlayVoice(string name, int index, float delay = 0f)
		{
			AudioClip voiceClip = TENNIS.SoundManager.instance.GetVoiceClip(name, index);
			Audio.clip = voiceClip;
			Audio.PlayDelayed(delay);
		}

		private int choose(Dictionary<string, float> _probs)
		{
			float num = 0f;
			foreach (float value in _probs.Values)
			{
				num += value;
			}
			float num2 = UnityEngine.Random.value * num;
			for (int i = 0; i < _probs.Count; i++)
			{
				if (num2 < _probs.ElementAt(i).Value)
				{
					return i;
				}
				num2 -= _probs.ElementAt(i).Value;
			}
			return _probs.Count - 1;
		}

		public static void ShuffleList<T>(List<T> list)
		{
			for (int i = 0; i < list.Count; i++)
			{
				int index = UnityEngine.Random.Range(0, list.Count);
				int index2 = UnityEngine.Random.Range(0, list.Count);
				T value = list[index];
				list[index] = list[index2];
				list[index2] = value;
			}
		}

		public void panjung(PlayerGameInfo playerGameInfo, int ClubIndex, bool isConcede)
		{
			List<AudioClip> list = new List<AudioClip>();
			AudioClip audioClip = null;
			if (TENNIS.SoundManager.instance.GetVoiceClip("panjung", playerGameInfo.ColGroundTag) != null)
			{
				list.Add(TENNIS.SoundManager.instance.GetVoiceClip("panjung", playerGameInfo.ColGroundTag));
			}
			if (playerGameInfo.ColGroundTag == "Green")
			{
				bool flag = true;
				flag = Audio.clip == null || !Audio.clip.name.Contains("nice_");
				float num = 0f;
				switch (ClubIndex)
				{
				case 11:
					num = 3f;
					break;
				case 9:
				case 10:
					num = 6f;
					break;
				default:
					num = 100f;
					break;
				}
				if (flag)
				{
					switch (ClubIndex)
					{
					case 9:
					case 10:
						list.Add((playerGameInfo.reMainDistance < num) ? TENNIS.SoundManager.instance.GetVoiceClip("dropResult", 0) : TENNIS.SoundManager.instance.GetVoiceClip("dropResult", 1));
						audioClip = TENNIS.SoundManager.instance.GetVoiceClip("dropResult", 0);
						Audio.clip = audioClip;
						break;
					default:
						list.Add(TENNIS.SoundManager.instance.GetVoiceClip("dropResult", 1));
						audioClip = TENNIS.SoundManager.instance.GetVoiceClip("dropResult", 1);
						Audio.clip = audioClip;
						break;
					case 11:
						break;
					}
				}
			}
			if (GameManager.instance.score != Score.noting)
			{
				string text = GameManager.instance.score.ToString();
				UnityEngine.Debug.Log(text);
				UnityEngine.Debug.Log(playerGameInfo.equiClub);
				UnityEngine.Debug.Log(playerGameInfo.ColGroundTag);
				if (playerGameInfo.equiClub != GolfPlayer.EquipmentClubState.putter && playerGameInfo.ColGroundTag != "Concede" && (playerGameInfo.Score == -1 || playerGameInfo.Score == 0))
				{
					text = "nice_" + text;
				}
				UnityEngine.Debug.Log(text);
				list.Add(TENNIS.SoundManager.instance.GetVoiceClip("panjung", text));
			}
			StartCoroutine(IEnum_panjung(list));
		}

		public IEnumerator IEnum_panjung(List<AudioClip> _clipList)
		{
			if (_clipList.Count == 2 && _clipList[1].name == "DoublePar")
			{
				UnityEngine.Debug.Log("더블파 삭제");
				_clipList.RemoveAt(0);
			}
			string[] array = new string[_clipList.Count];
			for (int j = 0; j < array.Length; j++)
			{
				array[j] = _clipList[j].name;
			}
			VoiceManager.PanjungVoiceEvent?.Invoke(array);
			for (int i = 0; i < _clipList.Count; i++)
			{
				Audio.PlayOneShot(_clipList[i]);
				yield return new WaitForSeconds(_clipList[i].length);
			}
		}

		public void SendPanjung(string[] clipNames)
		{
			StartCoroutine(IEnum_SendPanjung(clipNames));
		}

		public IEnumerator IEnum_SendPanjung(string[] clipNames)
		{
			List<AudioClip> playClips = new List<AudioClip>();
			for (int j = 0; j < clipNames.Length; j++)
			{
				playClips.Add(TENNIS.SoundManager.instance.GetVoiceClip("panjung", clipNames[j]));
			}
			int num = playClips.FindIndex((AudioClip x) => x.name == "Concede");
			if (num != -1 && num != 0)
			{
				AudioClip item = playClips[num];
				playClips.RemoveAt(num);
				playClips.Insert(0, item);
			}
			for (int i = 0; i < playClips.Count; i++)
			{
				Audio.PlayOneShot(playClips[i]);
				yield return new WaitForSeconds(playClips[i].length);
			}
		}

		public void UseMulligan()
		{
			AudioClip voiceClip = TENNIS.SoundManager.instance.GetVoiceClip("mulligan");
			Audio.PlayOneShot(voiceClip);
		}
	}
	public enum BallQuality
	{
		Fall,
		Hook,
		Fade,
		Draw,
		Slice,
		Push,
		Straight
	}
	public class cFollower : MonoBehaviour
	{
		public delegate void HitBall(Vector3 velocity, BallQuality ballQuality, float swingAngle, float hitAngle, float accel);

		public Transform followTarget;

		public Transform HandTR;

		private Rigidbody rigid;

		public Transform ClupTR;

		public Transform LeftControllerTR;

		public Transform RightControllerTR;

		private Transform ControllerTR;

		private BoxCollider thisCol;

		private Vector3 swingVelocity;

		private ClubInfo clubInfo;

		private bool isHit = true;

		public bool isTest;

		public float accelScaler;

		private float controlloerAccel;

		private InputDeviceState inputDeviceState;

		public Transform rayDummyTR;

		public List<float> ListVeloLength = new List<float>();

		public List<float> ListAngularVeloLength = new List<float>();

		public static event HitBall hitBallEvent;

		private void OnEnable()
		{
			PlayerBehaviour.ChangeClubEvent += ChangeClub;
			PlayerBehaviour.ResetBallEvent += ResetBall;
			PlayerBehaviour.ChangeHandlderEvent += PlayerBehaviour_ChangeHandlderEvent;
		}

		private void PlayerBehaviour_ChangeHandlderEvent(bool isLeftHand, InputDeviceState _inputDeviceState)
		{
			ControllerTR = (isLeftHand ? LeftControllerTR : RightControllerTR);
			inputDeviceState = _inputDeviceState;
		}

		private void OnDisable()
		{
			PlayerBehaviour.ChangeClubEvent -= ChangeClub;
			PlayerBehaviour.ResetBallEvent -= ResetBall;
			PlayerBehaviour.ChangeHandlderEvent -= PlayerBehaviour_ChangeHandlderEvent;
		}

		private void Start()
		{
			rigid = GetComponent<Rigidbody>();
			thisCol = GetComponent<BoxCollider>();
		}

		private void ResetBall()
		{
			Invoke("ResetIsHit", 1f);
		}

		private void ResetIsHit()
		{
			isHit = false;
			thisCol.isTrigger = false;
		}

		private void ChangeClub(ClubInfo _clubInfo)
		{
			clubInfo = _clubInfo;
			followTarget.parent = clubInfo.transform;
			HandTR.parent = clubInfo.transform;
			HandTR.localPosition = Vector3.zero;
			followTarget.localPosition = clubInfo.followerPos;
			followTarget.localEulerAngles = clubInfo.followerEuler;
			thisCol.size = clubInfo.ColSize;
			thisCol.isTrigger = true;
			Invoke("ResetIsHit", 1f);
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (collision.gameObject.layer != 9 || isHit)
			{
				return;
			}
			isHit = true;
			thisCol.isTrigger = true;
			float swingAngle = GetSwingAngle(collision);
			BallQuality ballQuality = GetBallQuality(swingAngle);
			float num = ListVeloLength.Max();
			float num2 = ListAngularVeloLength.Max();
			controlloerAccel = ((num > num2) ? num : num2);
			if (isTest)
			{
				controlloerAccel = accelScaler;
			}
			if (controlloerAccel > 125f)
			{
				controlloerAccel = 125f;
			}
			if (controlloerAccel < 2f)
			{
				controlloerAccel = 2f;
			}
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter && controlloerAccel > 50f)
			{
				controlloerAccel = 50f;
			}
			float hitAngle = GetHitAngle(collision);
			float num3 = clubInfo.power - Mathf.Abs(hitAngle) * 0.15f;
			float num4 = controlloerAccel * num3;
			Vector3 velo = GetVelocity(ballQuality) * num4;
			float num5 = (clubInfo.lanchAngle + 1f + hitAngle * 2f) * (controlloerAccel * 0.01f);
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter && num5 < 20f)
			{
				num5 = 20f;
			}
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.sw)
			{
				if (num5 < 25f)
				{
					num5 = 25f;
				}
				if (velo.magnitude < 4.5f)
				{
					velo = velo.normalized * 4.5f;
				}
			}
			num5 += BallBehaviour.SlopeAngle;
			Vector3 vector = ChangeAxisVelocity(velo, num5);
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter)
			{
				vector = BallPhysics.instance.PuttingReviseVelo(vector, collision.transform.right, collision.transform.up);
				GameManager.instance.playerGameInfo.PuttingCount++;
			}
			else if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.sw)
			{
				vector = BallPhysics.instance.SandWedgeReviseVelo(vector, collision.transform.right, collision.transform.up);
			}
			else
			{
				float num6 = Mathf.Abs(hitAngle);
				float num7 = Mathf.Abs(swingAngle);
				if (num6 < 0.3f && num7 < 0.2f && controlloerAccel > 110f)
				{
					collision.transform.GetComponent<BallBehaviour>().NiceShoot();
				}
				UnityEngine.Debug.DrawRay(collision.contacts[0].point, vector * 10f, Color.yellow, 30f);
				vector = BallPhysics.instance.ReviseVelo(vector, collision.transform.right, collision.transform.up, 0.3f);
			}
			if (collision.transform.GetComponent<BallBehaviour>().colGroundTag == "Rough")
			{
				UnityEngine.Debug.Log("Rough!!");
				vector *= 0.85f;
			}
			else if (collision.transform.GetComponent<BallBehaviour>().colGroundTag == "Bunker")
			{
				UnityEngine.Debug.Log("bunker!!");
				vector *= 0.7f;
			}
			collision.transform.GetComponent<Rigidbody>().isKinematic = false;
			cFollower.hitBallEvent(vector, ballQuality, swingAngle, hitAngle, controlloerAccel);
			float num8 = Vector3.Dot(swingVelocity.normalized, PlayerBehaviour.stanceDirection);
			UnityEngine.Debug.Log("<color=green> dot : " + num8 + " ============================</color>");
		}

		private void TestShoot()
		{
			float num = accelScaler;
			Vector3 vector = PlayerBehaviour.stanceDirection.normalized * num * clubInfo.power;
			float angle = (clubInfo.lanchAngle + 1f) * (num * 0.01f) + BallBehaviour.SlopeAngle;
			if (clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter)
			{
				angle = 0f;
			}
			Vector3 axis = Vector3.Cross(rhs: new Vector3(vector.x, 10f, vector.z), lhs: vector);
			Vector3 vector2 = Quaternion.AngleAxis(angle, axis) * vector;
			UnityEngine.Debug.Log("testVelo : " + vector2);
			if (GameManager.instance.golfPlayers[0].ballBehaviour.GetComponent<BallBehaviour>().colGroundTag == "Rough")
			{
				UnityEngine.Debug.Log("Rough!!");
				vector2 *= 0.85f;
			}
			else if (GameManager.instance.golfPlayers[0].ballBehaviour.GetComponent<BallBehaviour>().colGroundTag == "Bunker")
			{
				UnityEngine.Debug.Log("bunker!!");
				vector2 *= 0.7f;
			}
			if (accelScaler > 110f)
			{
				GameManager.instance.golfPlayers[0].ballBehaviour.GetComponent<BallBehaviour>().NiceShoot();
			}
			GameManager.instance.golfPlayers[0].ballBehaviour.GetComponent<Rigidbody>().isKinematic = false;
			cFollower.hitBallEvent(vector2, BallQuality.Straight, 0f, 0f, accelScaler);
		}

		private float GetSwingAngle(Collision col)
		{
			Vector3 normalized = swingVelocity.normalized;
			return Vector3.Dot(col.transform.right, normalized);
		}

		private BallQuality GetBallQuality(float dot)
		{
			if (dot > 0.5f)
			{
				return BallQuality.Push;
			}
			if (dot <= 0.5f && dot > 0.3f)
			{
				return BallQuality.Slice;
			}
			if (dot <= 0.3f && dot > 0.15f)
			{
				return BallQuality.Draw;
			}
			if (dot <= 0.15f && dot > -0.15f)
			{
				return BallQuality.Straight;
			}
			if (dot <= -0.15f && dot > -0.3f)
			{
				return BallQuality.Fade;
			}
			if (dot <= -0.3f && dot > -0.5f)
			{
				return BallQuality.Hook;
			}
			return BallQuality.Fall;
		}

		private float GetHitAngle(Collision col)
		{
			Vector3 normalized = (thisCol.bounds.center - col.collider.bounds.center).normalized;
			return Vector3.Dot(col.transform.up, normalized) * -1f;
		}

		private Vector3 GetVelocity(BallQuality ballQuality)
		{
			Vector3 result = Vector3.zero;
			Vector3 normalized = new Vector3(swingVelocity.x, 0f, swingVelocity.z).normalized;
			Vector3 axis = Vector3.Cross(PlayerBehaviour.stanceDirection, normalized);
			switch (ballQuality)
			{
			case BallQuality.Fall:
			case BallQuality.Fade:
			case BallQuality.Draw:
			case BallQuality.Push:
				result = normalized;
				break;
			case BallQuality.Straight:
				result = PlayerBehaviour.stanceDirection;
				break;
			case BallQuality.Hook:
			case BallQuality.Slice:
				result = (Quaternion.AngleAxis(10f, axis) * PlayerBehaviour.stanceDirection).normalized;
				break;
			}
			return result;
		}

		private Vector3 ChangeAxisVelocity(Vector3 velo, float lanchAngle)
		{
			Vector3 axis = Vector3.Cross(rhs: new Vector3(velo.x, 10f, velo.z), lhs: velo);
			return Quaternion.AngleAxis(lanchAngle, axis) * velo;
		}

		private void FixedUpdate()
		{
			if (!(ControllerTR == null))
			{
				ClupTR.position = ControllerTR.position;
				ClupTR.rotation = ControllerTR.rotation;
				rayDummyTR.rotation = ClupTR.rotation;
				rigid.velocity = (followTarget.position - rigid.position) / Time.deltaTime;
				rigid.rotation = followTarget.rotation;
				swingVelocity = rigid.velocity;
				ListVeloLength.Add(inputDeviceState.deviceVelo.magnitude * 17f);
				if (ListVeloLength.Count > 5)
				{
					ListVeloLength.RemoveAt(0);
				}
				ListAngularVeloLength.Add(inputDeviceState.deviceAngularVelo.magnitude * 6f);
				if (ListAngularVeloLength.Count > 5)
				{
					ListAngularVeloLength.RemoveAt(0);
				}
				if (Input.GetKeyDown(KeyCode.Space))
				{
					TestShoot();
				}
				EnableThisCol();
				EnableTrigger();
			}
		}

		private void EnableThisCol()
		{
			if (!isHit)
			{
				thisCol.enabled = PlayerBehaviour.isPressTrigger;
			}
		}

		private void EnableTrigger()
		{
			if (!isHit)
			{
				bool flag = Vector3.Dot(swingVelocity.normalized, PlayerBehaviour.stanceDirection) > 0f;
				float num = 0f;
				num = ((clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.driver || clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.wood3 || clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.wood5) ? 10f : ((clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.putter || clubInfo.equipmentClubState == GolfPlayer.EquipmentClubState.sw) ? 1f : 7f));
				thisCol.isTrigger = ((swingVelocity.magnitude < num || !flag) ? true : false);
			}
		}
	}
}
namespace RhythmBox
{
	public class Archievement : MonoBehaviour
	{
		private void Awake()
		{
			Billiards.Singleton<ScoreAndComboManager>.Instance.ComboCount.OnDataChanged += ComboCount_OnDataChanged;
		}

		private void ComboCount_OnDataChanged(int obj)
		{
			_ = 20;
		}

		private void OnDestroy()
		{
			Billiards.Singleton<ScoreAndComboManager>.Instance.ComboCount.OnDataChanged -= ComboCount_OnDataChanged;
		}
	}
	public class CameraShaking : MonoBehaviour
	{
		private static List<CameraShaking> instances = new List<CameraShaking>();

		[SerializeField]
		private ParticleSystem.MinMaxCurve shakeCurve;

		[SerializeField]
		private float ScaleFactor;

		private CoroutineWrapper ShakingRoutine;

		public static void Shake()
		{
			foreach (CameraShaking instance in instances)
			{
				instance.ShakeInternal();
			}
		}

		private void Awake()
		{
			instances.Add(this);
			ShakingRoutine = CoroutineWrapper.Generate(this);
		}

		private void ShakeInternal()
		{
			ShakingRoutine.StartSingleton(shake(0.25f));
			IEnumerator shake(float runtime)
			{
				float t = 0f;
				Vector3 axisFactor = new Vector3(UnityEngine.Random.Range(0, 1), UnityEngine.Random.Range(0, 1), UnityEngine.Random.Range(0, 1));
				Vector3 defaultPosition = base.transform.position;
				while (t < runtime)
				{
					base.transform.position = defaultPosition + ScaleFactor * new Vector3(shakeCurve.Evaluate(t / runtime, axisFactor.x), shakeCurve.Evaluate(t / runtime, axisFactor.y), shakeCurve.Evaluate(t / runtime, axisFactor.z));
					t += Time.deltaTime;
					yield return null;
				}
			}
		}

		private void OnDestroy()
		{
			instances.Remove(this);
		}
	}
	public class EffectManager : LocalSingleton<EffectManager>
	{
		[SerializeField]
		private ParticleSystem RedOrigin;

		[SerializeField]
		private ParticleSystem BlueOrigin;

		[SerializeField]
		private ParticleSystem GuardOrigin;

		private List<ParticleSystem> RedPool = new List<ParticleSystem>();

		private List<ParticleSystem> BluePool = new List<ParticleSystem>();

		private List<ParticleSystem> GuardPool = new List<ParticleSystem>();

		protected override void Awake()
		{
			base.Awake();
			for (int i = 0; i < 20; i++)
			{
				ParticleSystem particleSystem = UnityEngine.Object.Instantiate(RedOrigin);
				particleSystem.transform.SetParent(base.transform);
				RedPool.Add(particleSystem);
			}
			for (int j = 0; j < 20; j++)
			{
				ParticleSystem particleSystem2 = UnityEngine.Object.Instantiate(BlueOrigin);
				particleSystem2.transform.SetParent(base.transform);
				BluePool.Add(particleSystem2);
			}
			for (int k = 0; k < 20; k++)
			{
				ParticleSystem particleSystem3 = UnityEngine.Object.Instantiate(GuardOrigin);
				particleSystem3.transform.SetParent(base.transform);
				GuardPool.Add(particleSystem3);
			}
		}

		public void Run(in Vector3 pos, in Vector3 lookDir, in Color startColor)
		{
			if (startColor == Color.red)
			{
				Run(in pos, in lookDir, RedPool);
			}
			else if (startColor == Color.blue)
			{
				Run(in pos, in lookDir, BluePool);
			}
			else
			{
				Run(in pos, in lookDir, GuardPool);
			}
		}

		private void Run(in Vector3 pos, in Vector3 lookDir, List<ParticleSystem> targetPool)
		{
			ParticleSystem particleSystem = targetPool.First((ParticleSystem system) => !system.isPlaying);
			particleSystem.transform.position = pos;
			particleSystem.transform.LookAt(particleSystem.transform.position + lookDir);
			particleSystem.Play();
		}
	}
	public interface IInitializableListener
	{
		void Initialize();
	}
	public class BeatListener : MonoBehaviour, IInitializableListener
	{
		public enum Type
		{
			Scale,
			Alpha,
			Rotation
		}

		[SerializeField]
		private Type myType;

		[Header("Scale Field")]
		[SerializeField]
		private Vector3 Axis;

		[Header("AlphaField")]
		[SerializeField]
		private Image image;

		[SerializeField]
		private float Speed;

		[Header("RotateField")]
		[SerializeField]
		private Vector3 RotateAxis;

		[SerializeField]
		private float AngleAmount;

		[SerializeField]
		private float RunRate = 1f;

		[SerializeField]
		private float RunStartOffset;

		private float RunRateValue;

		[SerializeField]
		private AnimationCurve RunCurve;

		private void Awake()
		{
			Loader.OnBeat += Loader_OnBeat;
			Loader.OnInitialized += Initialize;
			RunRateValue = RunStartOffset;
		}

		public void Initialize()
		{
			RunRateValue = RunStartOffset;
		}

		protected virtual void Loader_OnBeat(float time)
		{
			RunRateValue += RunRate;
			Quaternion defaultLocalRotation;
			if (!(RunRateValue < 1f))
			{
				RunRateValue = 0f;
				defaultLocalRotation = base.transform.localRotation;
				StartCoroutine(Easy(time, onUpdate));
			}
			void onUpdate(float t)
			{
				switch (myType)
				{
				case Type.Scale:
					base.transform.localScale = Axis * RunCurve.Evaluate(t) + Vector3.one;
					break;
				case Type.Alpha:
				{
					Color color = image.color;
					color.a = RunCurve.Evaluate(t);
					image.color = color;
					break;
				}
				case Type.Rotation:
					base.transform.localRotation = Quaternion.Lerp(defaultLocalRotation, defaultLocalRotation * Quaternion.Euler(RotateAxis * AngleAmount), RunCurve.Evaluate(t));
					break;
				}
			}
		}

		protected IEnumerator Easy(float runtime, Action<float> OnUpdate)
		{
			float t = 0f;
			while (t < runtime)
			{
				OnUpdate?.Invoke(t / runtime);
				t += Time.deltaTime;
				yield return null;
			}
			OnUpdate?.Invoke(1f);
		}

		private void OnDestroy()
		{
			Loader.OnBeat -= Loader_OnBeat;
			Loader.OnInitialized -= Initialize;
		}
	}
	public class ComboIndicator : MonoBehaviour
	{
		[SerializeField]
		private Text text;

		[SerializeField]
		private Vector3 Axis;

		[SerializeField]
		private AnimationCurve curve;

		[SerializeField]
		private GameObject FullComboIndicator;

		private CoroutineWrapper wrapper;

		private Vector3 defaultScale;

		private int BPM => Billiards.Singleton<BoxDataContainer>.Instance.BPM.CurrentData;

		private void Awake()
		{
			PublicGameUIManager.GetInstance.AddReplayEvent(OnReplay);
			wrapper = CoroutineWrapper.Generate(this);
			defaultScale = base.transform.localScale;
			Billiards.Singleton<ScoreAndComboManager>.Instance.ComboCount.OnDataChanged += ComboCount_OnDataChanged;
			Billiards.Singleton<ScoreAndComboManager>.Instance.CurrentNoteCount.OnDataChanged += CurrentNoteCount_OnDataChanged;
		}

		private void CurrentNoteCount_OnDataChanged(int obj)
		{
			FullComboIndicator.SetActive(Billiards.Singleton<ScoreAndComboManager>.Instance.ComboCount.CurrentData == Billiards.Singleton<ScoreAndComboManager>.Instance.CurrentNoteCount.CurrentData);
			if (Billiards.Singleton<ScoreAndComboManager>.Instance.CurrentNoteCount.CurrentData == Billiards.Singleton<ScoreAndComboManager>.Instance.MaxNoteCount.CurrentData)
			{
				JudgeEffectManager.Instance.PlayEndSound();
			}
		}

		private void OnReplay()
		{
			text.text = "0";
			FullComboIndicator.SetActive(value: true);
		}

		private void ComboCount_OnDataChanged(int obj)
		{
			FullComboIndicator.SetActive(Billiards.Singleton<ScoreAndComboManager>.Instance.ComboCount.CurrentData == Billiards.Singleton<ScoreAndComboManager>.Instance.CurrentNoteCount.CurrentData);
			text.text = obj.ToString();
			wrapper.StartSingleton(Easy(60f / (float)BPM, onUpdate));
			void onUpdate(float t)
			{
				base.transform.localScale = defaultScale + Axis * curve.Evaluate(t);
			}
		}

		protected IEnumerator Easy(float runtime, Action<float> OnUpdate)
		{
			float t = 0f;
			while (t < runtime)
			{
				OnUpdate?.Invoke(t / runtime);
				t += Time.deltaTime;
				yield return null;
			}
			OnUpdate?.Invoke(1f);
		}

		private void OnDestroy()
		{
			Billiards.Singleton<ScoreAndComboManager>.Instance.CurrentNoteCount.OnDataChanged -= CurrentNoteCount_OnDataChanged;
			Billiards.Singleton<ScoreAndComboManager>.Instance.ComboCount.OnDataChanged -= ComboCount_OnDataChanged;
		}
	}
	public class ScoreIndicator : MonoBehaviour
	{
		[SerializeField]
		private Text text;

		[SerializeField]
		private Vector3 Axis;

		[SerializeField]
		private AnimationCurve curve;

		[SerializeField]
		private GameObject MaxScoreIndicator;

		private CoroutineWrapper wrapper;

		private Vector3 defaultScale;

		private int BPM => Billiards.Singleton<BoxDataContainer>.Instance.BPM.CurrentData;

		private void Awake()
		{
			PublicGameUIManager.GetInstance.AddReplayEvent(OnReplay);
			wrapper = CoroutineWrapper.Generate(this);
			defaultScale = base.transform.localScale;
			Billiards.Singleton<ScoreAndComboManager>.Instance.TotalScore.OnDataChanged += TotalScore_OnDataChanged;
			Billiards.Singleton<ScoreAndComboManager>.Instance.IsPerfect.OnDataChanged += IsPerfect_OnDataChanged;
		}

		private void IsPerfect_OnDataChanged(bool isPerfect)
		{
			MaxScoreIndicator.SetActive(isPerfect);
		}

		private void OnReplay()
		{
			text.text = "0";
			MaxScoreIndicator.SetActive(value: true);
		}

		private void TotalScore_OnDataChanged(float obj)
		{
			_ = Billiards.Singleton<ScoreAndComboManager>.Instance.JudgeScore.CurrentData;
			_ = 800000f / (float)Billiards.Singleton<ScoreAndComboManager>.Instance.MaxNoteCount.CurrentData;
			_ = Billiards.Singleton<ScoreAndComboManager>.Instance.CurrentNoteCount.CurrentData;
			text.text = Mathf.Clamp(obj, 0f, 1000000f).ToString("N0");
			wrapper.StartSingleton(Easy(60f / (float)BPM, onUpdate));
			void onUpdate(float t)
			{
				base.transform.localScale = defaultScale + Axis * curve.Evaluate(t);
			}
		}

		protected IEnumerator Easy(float runtime, Action<float> OnUpdate)
		{
			float t = 0f;
			while (t < runtime)
			{
				OnUpdate?.Invoke(t / runtime);
				t += Time.deltaTime;
				yield return null;
			}
			OnUpdate?.Invoke(1f);
		}

		private void OnDestroy()
		{
			Billiards.Singleton<ScoreAndComboManager>.Instance.IsPerfect.OnDataChanged -= IsPerfect_OnDataChanged;
			Billiards.Singleton<ScoreAndComboManager>.Instance.TotalScore.OnDataChanged -= TotalScore_OnDataChanged;
		}
	}
	public class SpectrumListener : MonoBehaviour
	{
		[SerializeField]
		private List<Transform> LeftTargets;

		[SerializeField]
		private List<Transform> RightTargets;

		[SerializeField]
		private Vector3 defaultScale;

		[SerializeField]
		private Vector3 Axis;

		[SerializeField]
		private AnimationCurve curve;

		[SerializeField]
		private float RunRate = 1f;

		private float RunRateValue;

		[SerializeField]
		private float maxValue;

		private void Awake()
		{
			Loader.OnSpectrum += Loader_OnSpectrum;
		}

		private void Loader_OnSpectrum(float runtime, float[] obj)
		{
			RunRateValue += RunRate;
			if (RunRateValue < 1f)
			{
				return;
			}
			RunRateValue = 0f;
			List<Vector3> MaxScale = new List<Vector3>();
			int num = obj.Length;
			int count = LeftTargets.Count;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (i * count / num != (i + 1) * count / num)
				{
					float t = 1f - ((float)(i + 1) - (float)num / (float)count * (float)num2);
					float num3 = 0f;
					num3 = ((obj.Length != i + 1) ? Mathf.Lerp(obj[i], obj[i + 1], t) : obj[i]);
					float value = num3;
					(float, float) input = (0f, 0.023f);
					(float, float) output = (0f, 1f);
					num3 = Billiards.VectorExtension.Remap(value, in input, in output);
					MaxScale.Add(Axis * num3 + defaultScale);
					maxValue = Mathf.Max(num3, maxValue);
					LeftTargets[num2].transform.localScale = Axis * num3 + defaultScale;
					RightTargets[num2].transform.localScale = Axis * num3 + defaultScale;
					num2++;
				}
			}
			StartCoroutine(Run(runtime, OnUpdate));
			void OnUpdate(float _t)
			{
				int count2 = LeftTargets.Count;
				for (int j = 0; j < count2; j++)
				{
					LeftTargets[j].transform.localScale = Vector3.Lerp(MaxScale[j], defaultScale, _t);
					RightTargets[j].transform.localScale = Vector3.Lerp(MaxScale[j], defaultScale, _t);
				}
			}
			static IEnumerator Run(float _runtime, Action<float> _onUpdate)
			{
				float _t2 = 0f;
				while (_t2 < _runtime)
				{
					_onUpdate?.Invoke(_t2 / _runtime);
					_t2 += Time.deltaTime;
					yield return null;
				}
				_onUpdate?.Invoke(1f);
			}
		}

		private void OnDestroy()
		{
			Loader.OnSpectrum -= Loader_OnSpectrum;
		}
	}
	public class SpectrumShaderListener : MonoBehaviour, IInitializableListener
	{
		[SerializeField]
		private List<Material> materials;

		[SerializeField]
		private Material EnvironmentMaterial;

		[SerializeField]
		private float minOpacity;

		[SerializeField]
		private float defaultScale;

		[SerializeField]
		private float ScaleFactor;

		[SerializeField]
		private AnimationCurve curve;

		[Header("Main Event")]
		[SerializeField]
		private float RunStartOffset;

		private float RunRateValue;

		[Header("Additional Event")]
		[SerializeField]
		private float AdditionalRunRate = 1f;

		[SerializeField]
		private float AdditionalRunStartOffset;

		private float AdditionalRunRateValue;

		[Header("Test view")]
		[SerializeField]
		private float maxValue;

		private const string MainColorProperty = "_MainColor";

		private const string VisualizerColorProperty = "_VisualizerColor";

		private const string OpacityProperty = "_Opacity";

		private const string OffsetProperty = "_Offset";

		private float RunRate => Loader.EnvironmentRunRate;

		private void Awake()
		{
			Loader.OnSpectrum += Loader_OnSpectrum;
			Loader.OnSpectrum += Loader_OnSpectrum_EnvironmentColor;
			Loader.OnInitialized += Initialize;
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
			RunRateValue = RunStartOffset;
			AdditionalRunRateValue = AdditionalRunStartOffset;
		}

		public void Initialize()
		{
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
			RunRateValue = RunStartOffset;
			AdditionalRunRateValue = AdditionalRunStartOffset;
		}

		private void Loader_OnSpectrum_EnvironmentColor(float runtime, float[] obj)
		{
			AdditionalRunRateValue += AdditionalRunRate;
			if (AdditionalRunRateValue < 1f)
			{
				return;
			}
			AdditionalRunRateValue = 0f;
			int num = UnityEngine.Random.Range(0, 30) * 12;
			Color value = ColorExtension.ConvertHsvToRgb(num % 360, 1.0, 1.0, 1f);
			Color value2 = ColorExtension.ConvertHsvToRgb((num + 150) % 360, 1.0, 1.0, 1f);
			foreach (Material material in materials)
			{
				material.SetColor("_MainColor", value);
				material.SetColor("_VisualizerColor", value2);
			}
			EnvironmentMaterial.SetColor("_EmissionColor", value);
		}

		private void Loader_OnSpectrum(float runtime, float[] obj)
		{
			RunRateValue += RunRate;
			if (RunRateValue < 1f)
			{
				return;
			}
			RunRateValue = 0f;
			List<float> MaxScale = new List<float>();
			float beatMaxScale = 0f;
			int num = obj.Length;
			int count = materials.Count;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (i * count / num != (i + 1) * count / num)
				{
					float t = 1f - ((float)(i + 1) - (float)num / (float)count * (float)num2);
					float num3 = 0f;
					num3 = ((obj.Length != i + 1) ? Mathf.Lerp(obj[i], obj[i + 1], t) : obj[i]);
					float value = num3;
					(float, float) input = (0f, 0.023f);
					(float, float) output = (0f, 1f);
					num3 = Billiards.VectorExtension.Remap(value, in input, in output);
					MaxScale.Add(ScaleFactor * num3 + defaultScale);
					maxValue = Mathf.Max(num3, maxValue);
					beatMaxScale = Mathf.Max(num3, beatMaxScale);
					materials[num2].SetFloat("_Opacity", ScaleFactor * num3 + defaultScale + minOpacity);
					materials[num2].SetFloat("_Offset", ScaleFactor * num3 + defaultScale);
					num2++;
				}
			}
			StartCoroutine(Run(runtime, OnUpdate));
			void OnUpdate(float _t)
			{
				int count2 = materials.Count;
				for (int j = 0; j < count2; j++)
				{
					materials[j].SetFloat("_Opacity", Mathf.Clamp01(Mathf.Lerp(beatMaxScale, defaultScale, _t) + minOpacity));
					materials[j].SetFloat("_Offset", Mathf.Clamp01(Mathf.Lerp(MaxScale[j], defaultScale, _t)));
				}
			}
			static IEnumerator Run(float _runtime, Action<float> _onUpdate)
			{
				float _t2 = 0f;
				while (_t2 < _runtime)
				{
					_onUpdate?.Invoke(_t2 / _runtime);
					_t2 += Time.deltaTime;
					yield return null;
				}
				_onUpdate?.Invoke(1f);
			}
		}

		private void OnDestroy()
		{
			Loader.OnInitialized -= Initialize;
			Loader.OnSpectrum -= Loader_OnSpectrum_EnvironmentColor;
			Loader.OnSpectrum -= Loader_OnSpectrum;
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
		}
	}
	public class JudgeEffectManager : MonoBehaviour
	{
		private class UpdateInfo
		{
			public Transform target;

			public Vector3 TargetPosition;

			public float StartTime;
		}

		private static JudgeEffectManager instance;

		[SerializeField]
		private GameObject Origin;

		[SerializeField]
		private Sprite[] perfect;

		[SerializeField]
		private Sprite[] great;

		[SerializeField]
		private Sprite[] good;

		[SerializeField]
		private float Runtime;

		[SerializeField]
		private float Distance;

		[SerializeField]
		private List<AudioClip> clips;

		[SerializeField]
		private List<AudioClip> ObstacleClips;

		[SerializeField]
		private List<AudioClip> GuardSounds;

		[SerializeField]
		private List<AudioClip> StartClips;

		[SerializeField]
		private AudioClip EndClip;

		[SerializeField]
		private AudioClip ComboClip;

		[SerializeField]
		private AudioSource originSource;

		[SerializeField]
		private AudioMixerGroup targetGroup;

		private List<GameObject> Pool = new List<GameObject>();

		private List<UpdateInfo> UpdateTargets = new List<UpdateInfo>();

		private List<UpdateInfo> RemoveTargets = new List<UpdateInfo>();

		private List<AudioSource> audioSources = new List<AudioSource>();

		private bool isLanguageChn;

		public static JudgeEffectManager Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<JudgeEffectManager>();
				}
				return instance;
			}
		}

		protected void Awake()
		{
			if (instance == null)
			{
				instance = this;
			}
			else if (instance != this)
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
				return;
			}
			for (int i = 0; i < 10; i++)
			{
				GameObject target = new GameObject();
				target.name = "source";
				target.transform.SetParent(base.transform, worldPositionStays: false);
				target.transform.localPosition = Vector3.zero;
				Component origin = originSource;
				AudioSource audioSource = CopyComponent(in target, in origin) as AudioSource;
				audioSource.playOnAwake = false;
				audioSource.spatialize = false;
				audioSource.spatialBlend = 1f;
				audioSource.spread = 0f;
				audioSource.rolloffMode = AudioRolloffMode.Linear;
				audioSource.minDistance = 0f;
				audioSource.maxDistance = 20f;
				audioSource.reverbZoneMix = 0.3f;
				audioSource.outputAudioMixerGroup = targetGroup;
				audioSources.Add(audioSource);
			}
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
			for (int j = 0; j < 20; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(Origin);
				gameObject.transform.SetParent(base.transform);
				gameObject.transform.GetChild(0).GetComponent<SpriteRenderer>().sprite = (isLanguageChn ? perfect[1] : perfect[0]);
				gameObject.transform.GetChild(1).GetComponent<SpriteRenderer>().sprite = (isLanguageChn ? great[1] : great[0]);
				gameObject.transform.GetChild(2).GetComponent<SpriteRenderer>().sprite = (isLanguageChn ? good[1] : good[0]);
				Pool.Add(gameObject);
			}
		}

		private void SetLocalization()
		{
			isLanguageChn = PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese;
			for (int i = 0; i < Pool.Count; i++)
			{
				Pool[i].transform.GetChild(0).GetComponent<SpriteRenderer>().sprite = (isLanguageChn ? perfect[1] : perfect[0]);
				Pool[i].transform.GetChild(1).GetComponent<SpriteRenderer>().sprite = (isLanguageChn ? great[1] : great[0]);
				Pool[i].transform.GetChild(2).GetComponent<SpriteRenderer>().sprite = (isLanguageChn ? good[1] : good[0]);
			}
		}

		private Component CopyComponent(in GameObject target, in Component origin)
		{
			Type type = origin.GetType();
			Component component = target.AddComponent(type);
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				fieldInfo.SetValue(component, fieldInfo.GetValue(origin));
			}
			return component;
		}

		public void Initialize()
		{
			UpdateTargets.Clear();
			RemoveTargets.Clear();
		}

		private void Update()
		{
			foreach (UpdateInfo updateTarget in UpdateTargets)
			{
				updateTarget.target.position = Vector3.Lerp(updateTarget.target.position, updateTarget.TargetPosition, 0.05f);
				if (Mathf.Abs(Time.time - updateTarget.StartTime) > Runtime)
				{
					RemoveTargets.Add(updateTarget);
				}
			}
			foreach (UpdateInfo removeTarget in RemoveTargets)
			{
				removeTarget.target.gameObject.SetActive(value: false);
				UpdateTargets.Remove(removeTarget);
			}
			RemoveTargets.Clear();
		}

		public void Run(in Vector3 pos, in Vector3 lookDir, in ScoreAndComboManager.ScoreInfo scoreInfo)
		{
			GameObject gameObject = Pool.First((GameObject system) => !system.activeInHierarchy);
			gameObject.transform.position = pos;
			for (int i = 0; i < 4; i++)
			{
				gameObject.transform.GetChild(i).gameObject.SetActive(value: false);
			}
			float judgeScore = ScoreAndComboManager.RemapToJudgeScore(in scoreInfo);
			ScoreAndComboManager.JudgeType judgeType = ScoreAndComboManager.JudgeScoreToType(in judgeScore);
			switch (judgeType)
			{
			case ScoreAndComboManager.JudgeType.Perfect:
				gameObject.transform.GetChild(0).gameObject.SetActive(value: true);
				break;
			case ScoreAndComboManager.JudgeType.Excellent:
				gameObject.transform.GetChild(1).gameObject.SetActive(value: true);
				break;
			case ScoreAndComboManager.JudgeType.Good:
				gameObject.transform.GetChild(2).gameObject.SetActive(value: true);
				break;
			case ScoreAndComboManager.JudgeType.Bad:
				gameObject.transform.GetChild(3).gameObject.SetActive(value: true);
				break;
			}
			if (scoreInfo.isGuard && !scoreInfo.isMiss)
			{
				PlayGuardSound();
			}
			else
			{
				PlaySound(in pos, judgeType);
			}
			gameObject.gameObject.SetActive(value: true);
			UpdateInfo updateInfo = new UpdateInfo();
			updateInfo.target = gameObject.transform;
			updateInfo.TargetPosition = gameObject.transform.position + gameObject.transform.forward * 0.5f + (Vector3.forward + Vector3.up * 0.3f) * Distance;
			updateInfo.StartTime = Time.time;
			UpdateTargets.Add(updateInfo);
		}

		public void PlayObstacleSound(in Vector3 pos)
		{
			AudioSource audioSource = audioSources.First((AudioSource source) => !source.isPlaying);
			audioSource.clip = Billiards.CollectionExtension.GetRandom(ObstacleClips);
			audioSource.transform.position = pos;
			audioSource.Play();
		}

		public void PlayGuardSound()
		{
			AudioSource audioSource = audioSources.First((AudioSource source) => !source.isPlaying);
			audioSource.clip = Billiards.CollectionExtension.GetRandom(GuardSounds);
			audioSource.Play();
		}

		public void PlayHitSound(in int idx)
		{
			AudioSource audioSource = audioSources.First((AudioSource source) => !source.isPlaying);
			audioSource.clip = clips[idx];
			audioSource.Play();
		}

		public void PlayStartSound(in int idx)
		{
			AudioSource audioSource = audioSources.First((AudioSource source) => !source.isPlaying);
			if (idx == 0)
			{
				audioSource.clip = (isLanguageChn ? StartClips[1] : StartClips[0]);
			}
			else
			{
				audioSource.clip = StartClips[2];
			}
			audioSource.Play();
		}

		public void PlayEndSound()
		{
			AudioSource audioSource = audioSources.First((AudioSource source) => !source.isPlaying);
			audioSource.clip = EndClip;
			audioSource.Play();
		}

		[Obsolete]
		public void PlayComboSound()
		{
			AudioSource audioSource = audioSources.First((AudioSource source) => !source.isPlaying);
			audioSource.clip = ComboClip;
			audioSource.Play();
		}

		private void PlaySound(in Vector3 pos, ScoreAndComboManager.JudgeType type)
		{
			AudioSource audioSource = audioSources.First((AudioSource source) => !source.isPlaying);
			audioSource.transform.position = pos;
			switch (type)
			{
			default:
				return;
			case ScoreAndComboManager.JudgeType.Bad:
				audioSource.clip = clips[3];
				break;
			case ScoreAndComboManager.JudgeType.Good:
				audioSource.clip = clips[2];
				break;
			case ScoreAndComboManager.JudgeType.Excellent:
				audioSource.clip = clips[1];
				break;
			case ScoreAndComboManager.JudgeType.Perfect:
				audioSource.clip = clips[0];
				break;
			}
			audioSource.Play();
		}

		private void OnDestroy()
		{
			if (instance == this)
			{
				instance = null;
			}
		}
	}
	[Serializable]
	public class NotePair
	{
		public GameObject Left;

		public GameObject Right;

		public void SetActive(bool value)
		{
			Left.SetActive(value);
			Right.SetActive(value);
		}
	}
	public class Note : MonoBehaviour
	{
		[Header("pre-initialize")]
		[SerializeField]
		private GameObject Root;

		[SerializeField]
		private GameObject Left;

		[SerializeField]
		private GameObject Right;

		[SerializeField]
		private GameObject Guard;

		[Header("Animation")]
		[SerializeField]
		private float Rate;

		[SerializeField]
		private AnimationCurve MoveAnimation;

		[SerializeField]
		private Vector2 StartOffset;

		[SerializeField]
		private Vector2 Interval;

		[Header("Reflection")]
		[SerializeField]
		private List<Transform> ReflectionObjects;

		[Header("Lights")]
		[SerializeField]
		private List<GameObject> LightObjects;

		private Vector2 TargetPosition;

		private Transform cachedTransform;

		private DataNote currentData;

		private float Speed;

		public bool isReleased { get; private set; }

		public event Action<Note> OnRelease;

		private void Awake()
		{
			OnRelease += Note_OnRelease;
		}

		private void Note_OnRelease(Note obj)
		{
			isReleased = true;
		}

		public void Initialize(in DataNote data, in float speed, in float currentRuntime, in float BPM, in Vector2 offset)
		{
			cachedTransform = base.transform;
			currentData = data;
			Speed = speed;
			isReleased = false;
			Left.SetActive(data._type == 0);
			Right.SetActive(data._type == 1);
			Guard.SetActive(value: false);
			if (data._type == 0)
			{
				StartOffset = new Vector2(Mathf.Abs(StartOffset.x) * -1f, StartOffset.y);
			}
			else
			{
				StartOffset = new Vector2(Mathf.Abs(StartOffset.x), StartOffset.y);
			}
			TargetPosition = new Vector2(((float)data._lineIndex - 1.5f) * Interval.x, ((float)data._lineLayer - 1f) * Interval.y + offset.y);
			base.transform.position = new Vector3(((float)data._lineIndex - 1.5f) * 0.5f, ((float)data._lineLayer - 1f) * 0.15f + offset.y, (data._time * 60f / BPM - currentRuntime) * Speed);
			switch (data._cutDirection)
			{
			case 1:
				base.transform.position = new Vector3(0f, offset.y, (data._time * 60f / BPM - currentRuntime) * Speed);
				base.transform.localRotation = Quaternion.identity;
				Guard.SetActive(value: true);
				Left.SetActive(value: false);
				Right.SetActive(value: false);
				break;
			case 0:
				base.transform.localRotation = Quaternion.Euler(-45f, 0f, 0f);
				foreach (GameObject lightObject in LightObjects)
				{
					lightObject.SetActive(value: true);
				}
				break;
			case 2:
				base.transform.localRotation = Quaternion.Euler(0f, -45f, 0f);
				foreach (GameObject lightObject2 in LightObjects)
				{
					lightObject2.SetActive(value: true);
				}
				break;
			case 3:
				base.transform.localRotation = Quaternion.Euler(0f, 45f, 0f);
				foreach (GameObject lightObject3 in LightObjects)
				{
					lightObject3.SetActive(value: true);
				}
				break;
			default:
				base.transform.localRotation = Quaternion.identity;
				foreach (GameObject lightObject4 in LightObjects)
				{
					lightObject4.SetActive(value: false);
				}
				break;
			}
			base.transform.localScale = new Vector3(0.4f, 0.4f, 0.4f);
			foreach (Transform reflectionObject in ReflectionObjects)
			{
				Transform obj = reflectionObject.transform;
				Vector3 vector = base.transform.position;
				Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
				obj.position = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, 0f - base.transform.position.y);
				reflectionObject.transform.rotation = Quaternion.Euler(new Vector3(-90f + (0f - base.transform.eulerAngles.x), base.transform.eulerAngles.y, 0f - base.transform.eulerAngles.z));
			}
			base.gameObject.SetActive(value: true);
		}

		public void Simulate(float time)
		{
			if (isReleased)
			{
				return;
			}
			Root.SetActive(cachedTransform.position.z * Rate <= 1f);
			cachedTransform.position += Vector3.back * time * Speed;
			if (currentData._cutDirection != 1)
			{
				Transform obj = cachedTransform;
				Vector2 vector = Vector2.Lerp(StartOffset + TargetPosition, TargetPosition, MoveAnimation.Evaluate(cachedTransform.position.z * Rate));
				obj.position = Billiards.VectorExtension.ToVector3(in vector, cachedTransform.position.z);
			}
			if (cachedTransform.position.z < -0.6f)
			{
				base.gameObject.SetActive(value: false);
				ScoreAndComboManager.ScoreInfo info = new ScoreAndComboManager.ScoreInfo();
				info.isMiss = true;
				info.note = this;
				Billiards.Singleton<ScoreAndComboManager>.Instance.Commit(in info);
				this.OnRelease?.Invoke(this);
			}
			foreach (Transform reflectionObject in ReflectionObjects)
			{
				reflectionObject.position = new Vector3(cachedTransform.position.x, 0f - cachedTransform.position.y, cachedTransform.position.z);
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			if (isReleased)
			{
				return;
			}
			if (currentData._cutDirection == 1)
			{
				if (other == Billiards.Singleton<BoxDataContainer>.Instance.LeftHandCollider.CurrentData || other == Billiards.Singleton<BoxDataContainer>.Instance.RightHandCollider.CurrentData)
				{
					float num = Vector3.Distance(Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.Position.CurrentData, Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.Position.CurrentData);
					Vector3 vector = 0.5f * (Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.VelocityNotifier.CurrentData + Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.VelocityNotifier.CurrentData);
					ScoreAndComboManager.ScoreInfo info = new ScoreAndComboManager.ScoreInfo();
					info.isMiss = num > 0.5f || vector.z > 0.5f;
					info.isGuard = true;
					info.hitAngle = -1f;
					info.hitVelocity = Vector3.zero;
					info.note = this;
					UnityEngine.XR.Interaction.Toolkit.XRController device = Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.Controller;
					TrySendHaptic(in device);
					device = Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.Controller;
					TrySendHaptic(in device);
					Vector3 pos;
					Vector3 lookDir;
					if (!info.isMiss)
					{
						EffectManager instance = LocalSingleton<EffectManager>.Instance;
						pos = base.transform.position;
						lookDir = base.transform.forward.normalized;
						Color startColor = Color.green * 0.5f + Color.red;
						instance.Run(in pos, in lookDir, in startColor);
					}
					base.gameObject.SetActive(value: false);
					Billiards.Singleton<ScoreAndComboManager>.Instance.Commit(in info);
					JudgeEffectManager instance2 = JudgeEffectManager.Instance;
					pos = base.transform.position;
					lookDir = base.transform.forward;
					instance2.Run(in pos, in lookDir, in info);
					this.OnRelease?.Invoke(this);
				}
			}
			else if (other == Billiards.Singleton<BoxDataContainer>.Instance.LeftHandCollider.CurrentData && currentData._type == 0)
			{
				ref XRControllerState xRLeftControllerState = ref Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState;
				Vector3 pos = other.transform.position;
				SendNoteInfo(isCurrentHand: true, in xRLeftControllerState, in pos);
			}
			else if (other == Billiards.Singleton<BoxDataContainer>.Instance.RightHandCollider.CurrentData && currentData._type == 1)
			{
				ref XRControllerState xRRightControllerState = ref Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState;
				Vector3 pos = other.transform.position;
				SendNoteInfo(isCurrentHand: true, in xRRightControllerState, in pos);
			}
			else if (other == Billiards.Singleton<BoxDataContainer>.Instance.LeftHandCollider.CurrentData || other == Billiards.Singleton<BoxDataContainer>.Instance.RightHandCollider.CurrentData)
			{
				XRControllerState targetHand = ((other == Billiards.Singleton<BoxDataContainer>.Instance.LeftHandCollider.CurrentData) ? Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState : Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState);
				Vector3 pos = other.transform.position;
				SendNoteInfo(isCurrentHand: false, in targetHand, in pos);
			}
		}

		private void SendNoteInfo(bool isCurrentHand, in XRControllerState targetHand, in Vector3 otherPosition)
		{
			ScoreAndComboManager.ScoreInfo info = new ScoreAndComboManager.ScoreInfo();
			Vector3 hitVelocity = targetHand.VelocityNotifier.CurrentData;
			UnityEngine.XR.Interaction.Toolkit.XRController device = targetHand.Controller;
			TrySendHaptic(in device);
			base.gameObject.SetActive(value: false);
			info.hitAngle = Vector3.Dot(hitVelocity.normalized, base.transform.forward);
			info.hitVelocity = hitVelocity;
			info.hitMagnitude = hitVelocity.magnitude;
			ScoreAndComboManager.ScoreInfo scoreInfo = info;
			Vector3 vector = base.transform.InverseTransformPoint(otherPosition);
			scoreInfo.hitDistance = Mathf.Abs(Billiards.VectorExtension.ToXZ(in vector).x);
			info.note = this;
			info.isBad = ScoreAndComboManager.IsBad(in info, currentData._cutDirection != 8) || !isCurrentHand;
			Vector3 lookDir;
			if (!info.isBad)
			{
				Color startColor = ((currentData._type == 0) ? Color.red : Color.blue);
				EffectManager instance = LocalSingleton<EffectManager>.Instance;
				vector = base.transform.position;
				lookDir = base.transform.forward.normalized;
				instance.Run(in vector, in lookDir, in startColor);
			}
			Billiards.Singleton<ScoreAndComboManager>.Instance.Commit(in info);
			JudgeEffectManager instance2 = JudgeEffectManager.Instance;
			vector = base.transform.position;
			lookDir = base.transform.forward;
			instance2.Run(in vector, in lookDir, in info);
			this.OnRelease?.Invoke(this);
		}

		private void TrySendHaptic(in UnityEngine.XR.Interaction.Toolkit.XRController device)
		{
			if (device.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				device.inputDevice.SendHapticImpulse(0u, Mathf.Clamp01(1f * PublicGameUIManager.gameSetting.GetHapticValue()), 0.2f);
			}
		}

		private float GetDegreeFormCutDirection(in int cutDir, out bool isAny)
		{
			isAny = false;
			switch (cutDir)
			{
			case 0:
				return 0f;
			case 1:
				return 180f;
			case 2:
				return 90f;
			case 3:
				return 270f;
			case 4:
				return 45f;
			case 5:
				return 315f;
			case 6:
				return 135f;
			case 7:
				return 225f;
			default:
				isAny = true;
				return 0f;
			}
		}
	}
	public class NoteCollider : MonoBehaviour
	{
		[SerializeField]
		private int NoteType;

		private Collider Left => Billiards.Singleton<BoxDataContainer>.Instance.LeftHandCollider.CurrentData;

		private Collider Right => Billiards.Singleton<BoxDataContainer>.Instance.RightHandCollider.CurrentData;

		private void OnTriggerEnter(Collider other)
		{
			if (other == Left && NoteType == 0)
			{
				Vector3 currentData = Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.VelocityNotifier.CurrentData;
				if (!(currentData.magnitude < 0.25f) && !(Vector3.Dot(currentData.normalized, Vector3.forward) < 0.4f))
				{
					EffectManager instance = LocalSingleton<EffectManager>.Instance;
					Vector3 pos = base.transform.position;
					Vector3 vector = base.transform.position - other.transform.position;
					Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
					Vector3 lookDir = Billiards.VectorExtension.ToVector3FromXZ(in xzVector).normalized;
					Color startColor = Color.red;
					instance.Run(in pos, in lookDir, in startColor);
					base.gameObject.SetActive(value: false);
				}
			}
			else if (other == Right && NoteType == 1)
			{
				Vector3 currentData2 = Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.VelocityNotifier.CurrentData;
				if (!(currentData2.magnitude < 0.25f) && !(Vector3.Dot(currentData2.normalized, Vector3.forward) < 0.4f))
				{
					EffectManager instance2 = LocalSingleton<EffectManager>.Instance;
					Vector3 pos = base.transform.position;
					Vector3 vector = base.transform.position - other.transform.position;
					Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
					Vector3 lookDir = Billiards.VectorExtension.ToVector3FromXZ(in xzVector).normalized;
					Color startColor = Color.blue;
					instance2.Run(in pos, in lookDir, in startColor);
					base.gameObject.SetActive(value: false);
				}
			}
		}
	}
	public class Obstacle : MonoBehaviour
	{
		[SerializeField]
		private GameObject Root;

		[SerializeField]
		private GameObject ObstacleTypeL;

		[SerializeField]
		private GameObject ObstacleTypeR;

		[SerializeField]
		private GameObject ObstacleType1;

		[SerializeField]
		private Vector2 Offset;

		[SerializeField]
		private float Rate;

		private DataObstacle currentData;

		private float Speed;

		public event Action<Obstacle> OnRelease;

		public void Initialize(in DataObstacle data, in float speed, in float currentRuntime, in float BPM, in Vector2 offset)
		{
			currentData = data;
			Speed = speed;
			ObstacleType1.SetActive(data._type == 1);
			ObstacleTypeL.SetActive(data._type == 0 && data._lineIndex < 2);
			ObstacleTypeR.SetActive(data._type == 0 && data._lineIndex > 1);
			base.transform.position = new Vector3((float)data._lineIndex - 1.5f + (float)(data._width - 1) * 0.5f + offset.x, offset.y - 0.3f, (data._time * 60f / BPM - currentRuntime) * Speed + data._duration * Speed * 60f / BPM * 0.5f);
			base.transform.localScale = new Vector3(1f, 1f, data._duration * Speed * 60f / BPM);
			base.gameObject.SetActive(value: true);
		}

		public void Simulate(float time)
		{
			Root.SetActive(base.transform.position.z * Rate <= 1f);
			base.transform.Translate(Vector3.back * time * Speed);
			if (base.transform.position.z + base.transform.localScale.z * 0.5f < 0f)
			{
				base.gameObject.SetActive(value: false);
				this.OnRelease?.Invoke(this);
			}
		}
	}
	public class ObstacleDetector : MonoBehaviour
	{
		[SerializeField]
		private AudioMixer targetMixer;

		[SerializeField]
		private Material VignetteMateiral;

		[SerializeField]
		private AnimationCurve VignetteCurve;

		[SerializeField]
		private AudioSource obstacleSource;

		private float removeTime;

		private float RemoveInverval = 2f;

		private List<(Collider, float)> IgnoreList = new List<(Collider, float)>();

		private CoroutineWrapper ObstacleSoundRoutine;

		private CoroutineWrapper ObstacleVignetteRoutine;

		private const string CutoffName = "Cutoff";

		private const string VignettePropertyName = "_Opacity";

		private const string SafeTag = "Safe";

		private Collider TargetObstacle;

		private void Awake()
		{
			VignetteMateiral.SetFloat("_Opacity", 0f);
			ObstacleSoundRoutine = CoroutineWrapper.Generate(this);
			ObstacleVignetteRoutine = CoroutineWrapper.Generate(this);
			targetMixer.SetFloat("Cutoff", 22000f);
			Billiards.Singleton<BoxDataContainer>.Instance.HeadCollider.CurrentData = GetComponent<BoxCollider>();
			Billiards.Singleton<BoxDataContainer>.Instance.OnObstacle.OnDataChanged += OnObstacle_OnDataChanged;
			obstacleSource.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("Effect");
		}

		private void OnObstacle_OnDataChanged(bool isExist)
		{
			if (isExist)
			{
				ObstacleSoundRoutine.StartSingleton(SFx((22000f, 550f), 0.1f));
				ObstacleVignetteRoutine.StartSingleton(Vignette((0f, 1f), 0.4f));
				CameraShaking.Shake();
				obstacleSource.Play();
			}
			else
			{
				ObstacleSoundRoutine.StartSingleton(SFx((550f, 22000f), 0.1f, 0.5f));
				ObstacleVignetteRoutine.StartSingleton(Vignette((1f, 0f), 0.4f));
				obstacleSource.Stop();
			}
		}

		private void FixedUpdate()
		{
			if (!(TargetObstacle == null) && !TargetObstacle.gameObject.activeInHierarchy)
			{
				TargetObstacle = null;
			}
			removeTime += Time.fixedDeltaTime;
			if (removeTime > RemoveInverval)
			{
				removeTime = 0f;
				RemoveIgnoreItem();
			}
			Billiards.Singleton<BoxDataContainer>.Instance.OnObstacle.CurrentData = TargetObstacle != null;
		}

		private void RemoveIgnoreItem()
		{
			if (IgnoreList.Count <= 0)
			{
				return;
			}
			List<(Collider, float)> list = new List<(Collider, float)>();
			foreach (var ignore in IgnoreList)
			{
				if (Mathf.Abs(ignore.Item2 - Time.time) > 0.5f)
				{
					list.Add(ignore);
				}
			}
			if (list.Count <= 0)
			{
				return;
			}
			foreach (var target in list)
			{
				IgnoreList.RemoveAll(((Collider, float) item) => target.Item1 == item.Item1);
			}
		}

		private IEnumerator Vignette((float, float) Atob, float runtime, float delay = 0f)
		{
			if (delay != 0f)
			{
				yield return YieldInstructionCache.WaitForSeconds(delay);
			}
			float t = 0f;
			while (t <= runtime)
			{
				if (Atob.Item2 == 0f)
				{
					VignetteMateiral.SetFloat("_Opacity", Mathf.Lerp(Atob.Item1, Atob.Item2, t / runtime));
				}
				else
				{
					VignetteMateiral.SetFloat("_Opacity", VignetteCurve.Evaluate(Mathf.Lerp(Atob.Item1, Atob.Item2, t / runtime)));
				}
				t += Time.deltaTime;
				yield return null;
			}
			VignetteMateiral.SetFloat("_Opacity", Atob.Item2);
		}

		private IEnumerator SFx((float, float) Atob, float runtime, float delay = 0f)
		{
			if (delay != 0f)
			{
				yield return YieldInstructionCache.WaitForSeconds(delay);
			}
			float t = 0f;
			while (t <= runtime)
			{
				targetMixer.SetFloat("Cutoff", Mathf.Lerp(Atob.Item1, Atob.Item2, t / runtime));
				t += Time.deltaTime;
				yield return null;
			}
			targetMixer.SetFloat("Cutoff", Atob.Item2);
		}

		private void OnDestroy()
		{
			Billiards.Singleton<BoxDataContainer>.Instance.OnObstacle.OnDataChanged -= OnObstacle_OnDataChanged;
			VignetteMateiral.SetFloat("_Opacity", 0f);
		}

		private void OnTriggerEnter(Collider other)
		{
			foreach (var ignore in IgnoreList)
			{
				if (ignore.Item1 == other)
				{
					return;
				}
			}
			IgnoreList.Add((other, Time.time));
			Vector3 pos;
			if (other.gameObject.name.Contains("Safe"))
			{
				JudgeEffectManager instance = JudgeEffectManager.Instance;
				pos = base.transform.position;
				instance.PlayObstacleSound(in pos);
				return;
			}
			TargetObstacle = other;
			ScoreAndComboManager.ScoreInfo scoreInfo = new ScoreAndComboManager.ScoreInfo();
			scoreInfo.isBad = true;
			Billiards.Singleton<ScoreAndComboManager>.Instance.CommitObstacle();
			JudgeEffectManager instance2 = JudgeEffectManager.Instance;
			pos = base.transform.position + base.transform.forward * 0.2f;
			Vector3 lookDir = base.transform.forward;
			instance2.Run(in pos, in lookDir, in scoreInfo);
		}

		private void OnTriggerExit(Collider other)
		{
			if (!other.gameObject.name.Contains("Safe"))
			{
				TargetObstacle = null;
			}
		}
	}
	public class ResultUI : MonoBehaviour
	{
		private float Score;

		private float Combo;

		private float MaxCombo;

		private float NoteCount;

		private bool FullScore;

		private bool FullCombo;

		private void Awake()
		{
			Loader.OnComplete += Loader_OnComplete;
		}

		private void Loader_OnComplete()
		{
			Score = Mathf.Clamp(Billiards.Singleton<ScoreAndComboManager>.Instance.TotalScore.CurrentData, 0f, 1000000f);
			Combo = Billiards.Singleton<ScoreAndComboManager>.Instance.ComboCount.CurrentData;
			MaxCombo = Billiards.Singleton<ScoreAndComboManager>.Instance.MaxComboCount.CurrentData;
			FullCombo = (float)Billiards.Singleton<ScoreAndComboManager>.Instance.MaxNoteCount.CurrentData == MaxCombo;
			FullScore = Score == 1000000f;
			List<string> list = new List<string>
			{
				GameSettingCtrl.GetLocalizationText("0042"),
				SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick,
				GameSettingCtrl.GetLocalizationText("0059"),
				Billiards.Singleton<ScoreAndComboManager>.Instance.PassCount.CurrentData.ToString() + "/" + Billiards.Singleton<ScoreAndComboManager>.Instance.MaxNoteCount.CurrentData,
				GameSettingCtrl.GetLocalizationText("0058"),
				MaxCombo.ToString() + "/" + Billiards.Singleton<ScoreAndComboManager>.Instance.MaxNoteCount.CurrentData,
				GameSettingCtrl.GetLocalizationText("0060"),
				BuildRank(in Score)
			};
			if (Score > 600000f)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
			}
			PublicGameUIManager.GetInstance.OpenResultBoard(Score.ToString("F0"), list.ToArray(), Score > 600000f);
			if (FullCombo)
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach21", 1);
			}
			if (FullScore)
			{
				SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach22", 1);
			}
		}

		private string BuildRank(in float score)
		{
			if (score == 1000000f)
			{
				return "S";
			}
			if (score >= 900000f)
			{
				return "A";
			}
			if (score >= 800000f)
			{
				return "B";
			}
			if (score >= 700000f)
			{
				return "C";
			}
			if (score >= 600000f)
			{
				return "D";
			}
			return "F";
		}

		private void OnDestroy()
		{
			Loader.OnComplete -= Loader_OnComplete;
		}
	}
	public class ScoreAndComboManager : Billiards.Singleton<ScoreAndComboManager>
	{
		public enum JudgeType
		{
			None,
			Miss,
			Bad,
			Good,
			Excellent,
			Perfect
		}

		[Serializable]
		public class ScoreInfo
		{
			public bool isBad;

			public bool isMiss;

			public bool isGuard;

			public Vector3 position;

			public Vector3 hitVelocity;

			public float hitAngle;

			public float hitDistance;

			public float hitMagnitude;

			public Note note;

			public Obstacle obstacle;
		}

		public const float MaxPerfectScore = 900000f;

		public Appnori.Util.Notifier<int> CurrentNoteCount { get; private set; }

		public Appnori.Util.Notifier<int> MaxNoteCount { get; private set; }

		public Appnori.Util.Notifier<int> MaxComboCount { get; private set; }

		public Appnori.Util.Notifier<int> ComboCount { get; private set; }

		public Appnori.Util.Notifier<int> PassCount { get; private set; }

		public Appnori.Util.Notifier<float> ComboScore { get; private set; }

		public Appnori.Util.Notifier<float> JudgeScore { get; private set; }

		public Appnori.Util.Notifier<float> TotalScore { get; private set; }

		public Appnori.Util.Notifier<bool> IsPerfect { get; private set; }

		public ScoreAndComboManager()
		{
			CurrentNoteCount = new Appnori.Util.Notifier<int>();
			MaxComboCount = new Appnori.Util.Notifier<int>();
			MaxNoteCount = new Appnori.Util.Notifier<int>();
			ComboCount = new Appnori.Util.Notifier<int>();
			PassCount = new Appnori.Util.Notifier<int>();
			ComboScore = new Appnori.Util.Notifier<float>();
			JudgeScore = new Appnori.Util.Notifier<float>();
			TotalScore = new Appnori.Util.Notifier<float>();
			IsPerfect = new Appnori.Util.Notifier<bool>();
		}

		private void CalculateForTest()
		{
			int num = 2000;
			float num2 = 400000f / (float)num / (float)(num - 1);
			float num3 = 0f;
			float num4 = 0f;
			for (int i = 1; i <= 2000; i++)
			{
				num3 += num2 * (float)(i - 1);
				num4 += 800000f / (float)num * 1f;
			}
			UnityEngine.Debug.Log("sum : " + num3);
			UnityEngine.Debug.Log("judgeSum : " + num4);
			UnityEngine.Debug.Log("Total : " + Mathf.RoundToInt(num3 + num4));
		}

		public void Initialize(in int noteCount)
		{
			MaxNoteCount.CurrentData = noteCount;
			CurrentNoteCount.CurrentData = 0;
			MaxComboCount.CurrentData = 0;
			ComboCount.CurrentData = 0;
			JudgeScore.CurrentData = 0f;
			ComboScore.CurrentData = 0f;
			TotalScore.CurrentData = 0f;
			PassCount.CurrentData = 0;
			IsPerfect.CurrentData = true;
		}

		public void CommitObstacle()
		{
			ComboCount.CurrentData = 0;
			IsPerfect.CurrentData = false;
		}

		public void Commit(in ScoreInfo info)
		{
			CurrentNoteCount.CurrentData++;
			if (info.isMiss || info.isBad)
			{
				ComboCount.CurrentData = 0;
				IsPerfect.CurrentData = false;
				return;
			}
			PassCount.CurrentData++;
			ComboCount.CurrentData++;
			MaxComboCount.CurrentData = Mathf.Max(MaxComboCount.CurrentData, ComboCount.CurrentData);
			float judgeScore = RemapToJudgeScore(in info);
			if (JudgeScoreToType(in judgeScore) != JudgeType.Perfect)
			{
				IsPerfect.CurrentData = false;
			}
			JudgeScore.CurrentData += 800000f / (float)MaxNoteCount.CurrentData * RemapToJudgeScore(in info);
			ComboScore.CurrentData += 400000f / (float)MaxNoteCount.CurrentData / (float)(MaxNoteCount.CurrentData - 1) * (float)(ComboCount.CurrentData - 1);
			TotalScore.CurrentData = ComboScore.CurrentData + JudgeScore.CurrentData;
		}

		public static bool IsBad(in ScoreInfo info, bool useHitangle = false)
		{
			if (info.hitMagnitude < 0.05f)
			{
				return true;
			}
			if (useHitangle && info.hitAngle < 0.707f)
			{
				return true;
			}
			if (!useHitangle && info.hitAngle < 0.6f)
			{
				return true;
			}
			return false;
		}

		public static float RemapToJudgeScore(in ScoreInfo info)
		{
			if (info.isMiss || info.isBad)
			{
				return 0f;
			}
			if (info.isGuard)
			{
				return 1f;
			}
			if (IsBad(in info))
			{
				return 0f;
			}
			float num = 0.1f;
			float num2 = 0.4f;
			float num3 = 1f;
			if (info.hitAngle < 0.90631f)
			{
				return num2 + num;
			}
			float num4;
			if (info.hitMagnitude > 2.5f)
			{
				num4 = 0.3f;
			}
			else if (info.hitMagnitude > 1f)
			{
				num4 = 0.2f;
			}
			else
			{
				if (!(info.hitMagnitude > 0.25f))
				{
					return num2 + num;
				}
				num4 = 0.1f;
			}
			float num5;
			if (info.hitDistance < 0.2f)
			{
				num5 = 0.3f;
			}
			else if (info.hitDistance < 0.4f)
			{
				num5 = 0.2f;
			}
			else
			{
				if (!(info.hitDistance < 0.5f))
				{
					return num2 + num;
				}
				num5 = 0.1f;
			}
			return Mathf.Clamp01(num2 + num + num4 + num5) * num3;
		}

		public static JudgeType JudgeScoreToType(in float judgeScore)
		{
			if (judgeScore >= 1f)
			{
				return JudgeType.Perfect;
			}
			if (judgeScore > 0.701f)
			{
				return JudgeType.Excellent;
			}
			if (judgeScore >= 0.401f)
			{
				return JudgeType.Good;
			}
			if (judgeScore < 0f)
			{
				return JudgeType.Miss;
			}
			return JudgeType.Bad;
		}
	}
	public class Selector : MonoBehaviour
	{
		[SerializeField]
		private Transform Head;

		[SerializeField]
		private int _type;

		[SerializeField]
		private float JudgeAmount;

		[SerializeField]
		private Loader loader;

		[SerializeField]
		private CanvasGroup Help;

		[SerializeField]
		private List<GameObject> selectors;

		[SerializeField]
		private MonoBehaviour Runner;

		private CoroutineWrapper HelpActiveWrapper;

		private void Awake()
		{
			HelpActiveWrapper = CoroutineWrapper.Generate(Runner);
			PublicGameUIManager.GetInstance.AddReplayEvent(OnSongComplete);
			Loader.OnInitialized += Loader_OnInitialized;
		}

		private void Loader_OnInitialized()
		{
			loader.Run();
		}

		private IEnumerator SetHelp(float target, float runtime)
		{
			float t = 0f;
			float defaultAlpha = Help.alpha;
			while (t < runtime)
			{
				Help.alpha = Mathf.Lerp(defaultAlpha, target, t / runtime);
				t += Time.deltaTime;
				yield return null;
			}
			Help.alpha = target;
		}

		private void OnSongComplete()
		{
			foreach (GameObject selector in selectors)
			{
				selector.SetActive(value: true);
			}
			HelpActiveWrapper.Start(SetHelp(1f, 0.5f));
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.L))
			{
				InitializeAndRun(isRight: false);
			}
			if (Input.GetKeyDown(KeyCode.R))
			{
				InitializeAndRun(isRight: true);
			}
		}

		private void InitializeAndRun(bool isRight)
		{
			Loader obj = loader;
			float height = Head.position.y - 0.25f;
			obj.Initialize(isRight, in height);
			JudgeEffectManager.Instance.Initialize();
			JudgeEffectManager instance = JudgeEffectManager.Instance;
			int idx = 0;
			instance.PlayHitSound(in idx);
			JudgeEffectManager instance2 = JudgeEffectManager.Instance;
			idx = 0;
			instance2.PlayStartSound(in idx);
			JudgeEffectManager instance3 = JudgeEffectManager.Instance;
			idx = 1;
			instance3.PlayStartSound(in idx);
			foreach (GameObject selector in selectors)
			{
				selector.SetActive(value: false);
			}
			HelpActiveWrapper.Start(SetHelp(0f, 0.5f));
		}

		private void OnTriggerEnter(Collider other)
		{
			if (other == Billiards.Singleton<BoxDataContainer>.Instance.LeftHandCollider.CurrentData && _type == 0)
			{
				Vector3 currentData = Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.VelocityNotifier.CurrentData;
				if (!(currentData.magnitude < 0.25f) && !(Vector3.Dot(currentData.normalized, base.transform.forward) < JudgeAmount))
				{
					EffectManager instance = LocalSingleton<EffectManager>.Instance;
					Vector3 pos = base.transform.position;
					Vector3 vector = base.transform.position - other.transform.position;
					Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
					Vector3 lookDir = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, 0.1f).normalized;
					Color startColor = Color.red;
					instance.Run(in pos, in lookDir, in startColor);
					base.gameObject.SetActive(value: false);
					InitializeAndRun(isRight: true);
				}
			}
			else if (other == Billiards.Singleton<BoxDataContainer>.Instance.RightHandCollider.CurrentData && _type == 1)
			{
				Vector3 currentData2 = Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.VelocityNotifier.CurrentData;
				if (!(currentData2.magnitude < 0.25f) && !(Vector3.Dot(currentData2.normalized, base.transform.forward) < JudgeAmount))
				{
					EffectManager instance2 = LocalSingleton<EffectManager>.Instance;
					Vector3 pos = base.transform.position;
					Vector3 vector = base.transform.position - other.transform.position;
					Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
					Vector3 lookDir = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, 0.1f).normalized;
					Color startColor = Color.blue;
					instance2.Run(in pos, in lookDir, in startColor);
					base.gameObject.SetActive(value: false);
					InitializeAndRun(isRight: false);
				}
			}
		}

		private void OnDestroy()
		{
			Loader.OnInitialized -= Loader_OnInitialized;
		}
	}
	public class SkyboxModifier : MonoBehaviour
	{
		[SerializeField]
		private Loader loader;

		[SerializeField]
		private ReflectionProbe probe;

		private int Index;

		private void Awake()
		{
			BoxLevelData currentLevelData = loader.CurrentLevelData;
			RenderSettings.fogColor = currentLevelData.FogColor;
			RenderSettings.skybox = currentLevelData.SkyboxMaterial;
			probe.customBakedTexture = currentLevelData.cubemap;
			probe.intensity = currentLevelData.ReflectionProbeIntensity;
			DynamicGI.UpdateEnvironment();
			Index = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1;
		}

		private void Update()
		{
		}

		private void LoadForTest()
		{
			BoxLevelData currentLevelData = loader.GetCurrentLevelData(Index);
			RenderSettings.fogColor = currentLevelData.FogColor;
			RenderSettings.skybox = currentLevelData.SkyboxMaterial;
			probe.customBakedTexture = currentLevelData.cubemap;
			probe.intensity = currentLevelData.ReflectionProbeIntensity;
			DynamicGI.UpdateEnvironment();
			Index = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1;
		}
	}
	public class StartSong : MonoBehaviour
	{
		[SerializeField]
		private Loader levelLoader;

		[SerializeField]
		private AudioClip song;

		[SerializeField]
		private TextAsset level;

		[SerializeField]
		private int BPM;
	}
	public class TestControllerPause : MonoBehaviour
	{
		private void Awake()
		{
			PublicGameUIManager.GetInstance.AddMenuEvent(TestControllerPause_OnDataChanged);
		}

		private void TestControllerPause_OnDataChanged(bool obj)
		{
			Billiards.Singleton<BoxDataContainer>.Instance.IsPause.CurrentData = obj;
		}
	}
	public class BoxDataContainer : Billiards.Singleton<BoxDataContainer>
	{
		public Appnori.Util.NotifierClass<Collider> LeftHandCollider = new Appnori.Util.NotifierClass<Collider>();

		public Appnori.Util.NotifierClass<Collider> RightHandCollider = new Appnori.Util.NotifierClass<Collider>();

		public Appnori.Util.Notifier<bool> OnObstacle = new Appnori.Util.Notifier<bool>();

		public Appnori.Util.NotifierClass<Collider> HeadCollider = new Appnori.Util.NotifierClass<Collider>();

		public Appnori.Util.Notifier<int> BPM = new Appnori.Util.Notifier<int>();

		public Appnori.Util.Notifier<bool> IsPause = new Appnori.Util.Notifier<bool>();
	}
	public class TestHandRegister : MonoBehaviour
	{
		[SerializeField]
		private Collider Left;

		[SerializeField]
		private Collider Right;

		private void Awake()
		{
			Billiards.Singleton<BoxDataContainer>.Instance.LeftHandCollider.CurrentData = Left;
			Billiards.Singleton<BoxDataContainer>.Instance.RightHandCollider.CurrentData = Right;
		}
	}
	public class Loader : MonoBehaviour
	{
		[SerializeField]
		private List<BoxLevelData> Levels;

		[SerializeField]
		private AudioSource TargetSource;

		[SerializeField]
		private float Speed;

		[SerializeField]
		private float Runtime;

		[SerializeField]
		private float SongTime;

		[SerializeField]
		private DataFormat targetData;

		[SerializeField]
		private Note NoteOrigin;

		[SerializeField]
		private Obstacle ObstacleOrigin;

		[SerializeField]
		private AnimationCurve SpeedCurve;

		private bool isInitialized;

		private CoroutineWrapper RunRoutineWrapper;

		private List<Note> NotePool = new List<Note>();

		private List<Note> RunningNotes = new List<Note>();

		private List<Note> RemoveTargetNotes = new List<Note>();

		private List<Obstacle> ObstaclePool = new List<Obstacle>();

		private List<Obstacle> RunningObstacles = new List<Obstacle>();

		private List<Obstacle> RemoveTargetObstacles = new List<Obstacle>();

		private float Height;

		private float[] SpectrumSampleData = new float[256];

		public static float EnvironmentRunRate;

		private float checkTime = 2f;

		private int BPM => Billiards.Singleton<BoxDataContainer>.Instance.BPM.CurrentData;

		public BoxLevelData CurrentLevelData => Levels[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1];

		public static event Action OnInitialized;

		public static event Action<float> OnBeat;

		public static event Action<float, float[]> OnSpectrum;

		public static event Action OnComplete;

		public BoxLevelData GetCurrentLevelData(int idx)
		{
			return Levels[idx];
		}

		private void Awake()
		{
			RunRoutineWrapper = CoroutineWrapper.Generate(this);
			Billiards.Singleton<BoxDataContainer>.Instance.IsPause.OnDataChanged += IsPause_OnDataChanged;
			for (int i = 0; i < 50; i++)
			{
				Note note = UnityEngine.Object.Instantiate(NoteOrigin);
				note.gameObject.SetActive(value: false);
				note.OnRelease += OnNoteReleased;
				NotePool.Add(note);
			}
			for (int j = 0; j < 5; j++)
			{
				Obstacle obstacle = UnityEngine.Object.Instantiate(ObstacleOrigin);
				obstacle.gameObject.SetActive(value: false);
				obstacle.OnRelease += OnObstacleReleased;
				ObstaclePool.Add(obstacle);
			}
		}

		private void IsPause_OnDataChanged(bool obj)
		{
			if (obj)
			{
				TargetSource.Pause();
			}
			else
			{
				TargetSource.UnPause();
			}
		}

		private void OnDestroy()
		{
			Billiards.Singleton<BoxDataContainer>.Instance.IsPause.OnDataChanged -= IsPause_OnDataChanged;
		}

		private void OnObstacleReleased(Obstacle releasedObstacle)
		{
			RemoveTargetObstacles.Add(releasedObstacle);
		}

		private void OnNoteReleased(Note releasedNote)
		{
			RemoveTargetNotes.Add(releasedNote);
		}

		private void ClearData()
		{
			TargetSource.Stop();
			StopAllCoroutines();
			foreach (Obstacle runningObstacle in RunningObstacles)
			{
				runningObstacle.gameObject.SetActive(value: false);
				ObstaclePool.Add(runningObstacle);
			}
			RunningObstacles.Clear();
			foreach (Note runningNote in RunningNotes)
			{
				runningNote.gameObject.SetActive(value: false);
				NotePool.Add(runningNote);
			}
			RunningNotes.Clear();
			foreach (Note removeTargetNote in RemoveTargetNotes)
			{
				NotePool.Add(removeTargetNote);
			}
			RemoveTargetNotes.Clear();
			foreach (Obstacle removeTargetObstacle in RemoveTargetObstacles)
			{
				ObstaclePool.Add(removeTargetObstacle);
			}
			RemoveTargetObstacles.Clear();
		}

		public void Initialize(bool isLeftHandPlayer, in float height)
		{
			Height = height;
			ClearData();
			DataFormat data = JsonUtility.FromJson<DataFormat>(CurrentLevelData.SongData.text);
			TargetSource.clip = CurrentLevelData.Song;
			if (isLeftHandPlayer)
			{
				targetData = FilterDataForLeftHand(data);
			}
			else
			{
				targetData = FilterData(data);
			}
			Billiards.Singleton<BoxDataContainer>.Instance.BPM.CurrentData = CurrentLevelData.BPM;
			ScoreAndComboManager instance = Billiards.Singleton<ScoreAndComboManager>.Instance;
			int noteCount = targetData._notes.Count;
			instance.Initialize(in noteCount);
			EnvironmentRunRate = CurrentLevelData.RunRate;
			isInitialized = true;
			Loader.OnInitialized?.Invoke();
		}

		public void Run()
		{
			if (isInitialized && !RunRoutineWrapper.IsPlaying)
			{
				RunRoutineWrapper.Start(UpdateTarget());
			}
		}

		public IEnumerator UpdateTarget()
		{
			int loadedNoteIndex = 0;
			int loadedObstacleIndex = 0;
			TargetSource.Play();
			SongTime = TargetSource.time;
			Runtime = 0f;
			Vector2 heightOffset = new Vector2(0f, Height);
			while (base.enabled)
			{
				if (Billiards.Singleton<BoxDataContainer>.Instance.IsPause.CurrentData)
				{
					yield return new WaitWhile(() => Billiards.Singleton<BoxDataContainer>.Instance.IsPause.CurrentData);
				}
				if (!TargetSource.isPlaying && Mathf.Abs(TargetSource.clip.length - SongTime) < Time.deltaTime * 2f)
				{
					Loader.OnComplete?.Invoke();
					break;
				}
				while (NotePool.Count > 0 && targetData._notes.Count > loadedNoteIndex)
				{
					Note note = NotePool.First();
					DataNote data = targetData._notes[loadedNoteIndex++];
					ref float speed = ref Speed;
					ref float runtime = ref Runtime;
					float BPM = this.BPM;
					note.Initialize(in data, in speed, in runtime, in BPM, in heightOffset);
					RunningNotes.Add(note);
					NotePool.Remove(note);
				}
				while (ObstaclePool.Count > 0 && targetData._obstacles.Count > loadedObstacleIndex)
				{
					Obstacle obstacle = ObstaclePool.First();
					DataObstacle data2 = targetData._obstacles[loadedObstacleIndex++];
					ref float speed2 = ref Speed;
					ref float runtime2 = ref Runtime;
					float BPM = this.BPM;
					obstacle.Initialize(in data2, in speed2, in runtime2, in BPM, in heightOffset);
					RunningObstacles.Add(obstacle);
					ObstaclePool.Remove(obstacle);
				}
				float num = 60f / (float)this.BPM;
				if (Mathf.FloorToInt(SongTime / num) != Mathf.FloorToInt(TargetSource.time / num))
				{
					Loader.OnBeat?.Invoke(num);
					TargetSource.GetSpectrumData(SpectrumSampleData, 0, FFTWindow.Blackman);
					Loader.OnSpectrum?.Invoke(num, SpectrumSampleData);
				}
				if (TargetSource.time == SongTime)
				{
					yield return null;
					continue;
				}
				SongTime = TargetSource.time;
				if (Mathf.Abs(SongTime - Runtime) > Time.deltaTime)
				{
					foreach (Note runningNote in RunningNotes)
					{
						runningNote.Simulate(SongTime - Runtime);
					}
					foreach (Obstacle runningObstacle in RunningObstacles)
					{
						runningObstacle.Simulate(SongTime - Runtime);
					}
					Runtime = SongTime;
				}
				else
				{
					foreach (Note runningNote2 in RunningNotes)
					{
						float deltaTime = Time.deltaTime;
						AnimationCurve speedCurve = SpeedCurve;
						float value = Mathf.Repeat(SongTime, num);
						(float, float) input = (0f, num);
						(float, float) output = (0f, 1f);
						runningNote2.Simulate(deltaTime * speedCurve.Evaluate(Billiards.VectorExtension.Remap(value, in input, in output)));
					}
					foreach (Obstacle runningObstacle2 in RunningObstacles)
					{
						float deltaTime2 = Time.deltaTime;
						AnimationCurve speedCurve2 = SpeedCurve;
						float value2 = Mathf.Repeat(SongTime, num);
						(float, float) input = (0f, num);
						(float, float) output = (0f, 1f);
						runningObstacle2.Simulate(deltaTime2 * speedCurve2.Evaluate(Billiards.VectorExtension.Remap(value2, in input, in output)));
					}
					Runtime += Time.deltaTime;
				}
				if (RemoveTargetNotes.Count > 0)
				{
					foreach (Note removeTargetNote in RemoveTargetNotes)
					{
						if (RunningNotes.Remove(removeTargetNote))
						{
							NotePool.Add(removeTargetNote);
						}
					}
					RemoveTargetNotes.Clear();
				}
				if (RemoveTargetObstacles.Count > 0)
				{
					foreach (Obstacle removeTargetObstacle in RemoveTargetObstacles)
					{
						if (RunningObstacles.Remove(removeTargetObstacle))
						{
							ObstaclePool.Add(removeTargetObstacle);
						}
					}
					RemoveTargetObstacles.Clear();
				}
				yield return null;
			}
		}

		private DataFormat FilterData(DataFormat data)
		{
			data._notes = (from n in data._notes.Where(delegate(DataNote note)
				{
					if (note._type == 3)
					{
						return false;
					}
					if (note._lineIndex != 1 && note._lineIndex != 2)
					{
						return false;
					}
					if (note._lineLayer == 2)
					{
						return false;
					}
					int cutDirection = note._cutDirection;
					return (uint)(cutDirection - 4) > 3u;
				})
				orderby n._time
				select n).ToList();
			return data;
		}

		private DataFormat FilterDataForLeftHand(DataFormat data)
		{
			data._notes = (from n in data._notes.Where(delegate(DataNote note)
				{
					if (note._type == 3)
					{
						return false;
					}
					if (note._lineIndex != 1 && note._lineIndex != 2)
					{
						return false;
					}
					if (note._lineLayer == 2)
					{
						return false;
					}
					int cutDirection = note._cutDirection;
					return (uint)(cutDirection - 4) > 3u;
				}).Select(delegate(DataNote note)
				{
					DataNote dataNote = new DataNote
					{
						_time = note._time,
						_type = ((note._type != 1) ? 1 : 0),
						_lineLayer = note._lineLayer,
						_lineIndex = ((note._lineIndex != 1) ? 1 : 2)
					};
					switch (note._cutDirection)
					{
					case 2:
						dataNote._cutDirection = 3;
						break;
					case 3:
						dataNote._cutDirection = 2;
						break;
					default:
						dataNote._cutDirection = note._cutDirection;
						break;
					}
					return dataNote;
				})
				orderby n._time
				select n).ToList();
			data._obstacles = (from o in data._obstacles.Select(delegate(DataObstacle obstacle)
				{
					DataObstacle dataObstacle = new DataObstacle
					{
						_width = obstacle._width,
						_duration = obstacle._duration,
						_type = obstacle._type,
						_time = obstacle._time
					};
					if (obstacle._type == 0)
					{
						dataObstacle._lineIndex = 4 - (obstacle._lineIndex + obstacle._width);
					}
					return dataObstacle;
				})
				orderby o._time
				select o).ToList();
			return data;
		}
	}
}
namespace Mechanics
{
	public class BezierCurve
	{
		public static float CalculateLength(int smoothDivisions, Vector3[] nodes)
		{
			if (nodes == null || nodes.Length < 2)
			{
				return 0f;
			}
			float num = 0.5f / ((float)(nodes.Length - 1) * (float)Mathf.Clamp(smoothDivisions, 1, 100));
			float num2 = 0f;
			for (float num3 = 0f; num3 < 1f; num3 += num)
			{
				Vector3 a = CalculateValue(num3, nodes);
				Vector3 b = CalculateValue(num3 + num, nodes);
				num2 += Vector3.Distance(a, b);
			}
			return num2;
		}

		public static Vector3 CalculateValue(float time01, Vector3[] nodes)
		{
			if (nodes == null || nodes.Length == 0)
			{
				return Vector3.zero;
			}
			if (nodes.Length == 1)
			{
				return nodes[0];
			}
			Vector3[] array = new Vector3[nodes.Length];
			for (int i = 0; i < nodes.Length; i++)
			{
				array[i] = nodes[i];
			}
			for (int num = nodes.Length - 1; num > 0; num--)
			{
				for (int j = 0; j < num; j++)
				{
					array[j] = Vector3.Lerp(array[j], array[j + 1], time01);
				}
			}
			return array[0];
		}

		public static Vector3 CalculateTangent(float time01, Vector3[] nodes)
		{
			return (10000f * (CalculateValue(time01 + 0.0001f, nodes) - CalculateValue(time01, nodes))).normalized;
		}

		public static Vector3 CalculateNormal(float time01, Vector3[] nodes)
		{
			Vector3 vector = CalculateTangent(time01, nodes);
			Vector3 vector2 = CalculateTangent(time01 + 0.0001f, nodes);
			return (10000f * (vector2 - vector)).normalized;
		}

		public static Vector3 CalculateBinormal(float time01, Vector3[] nodes)
		{
			return (-Vector3.Cross(CalculateTangent(time01, nodes), CalculateNormal(time01, nodes))).normalized;
		}
	}
	public class BezierCurve2
	{
		private static Vector3[] GetNewNodes(float magnit, Vector3[] nodes)
		{
			magnit = Mathf.Lerp(-3f, 1f, magnit);
			if (nodes == null || nodes.Length < 2)
			{
				return nodes;
			}
			if (nodes.Length == 2)
			{
				return new Vector3[2]
				{
					nodes[0],
					nodes[1]
				};
			}
			Vector3[] array = new Vector3[nodes.Length];
			for (int i = 0; i < nodes.Length; i++)
			{
				if (i == 0 || i == nodes.Length - 1)
				{
					array[i] = nodes[i];
					continue;
				}
				Vector3 vector = 0.5f * (nodes[i] + 0.5f * Vector3.Distance(nodes[i - 1], nodes[i]) * (nodes[i] - nodes[i + 1]).normalized + nodes[i] + 0.5f * Vector3.Distance(nodes[i], nodes[i + 1]) * (nodes[i] - nodes[i - 1]).normalized);
				array[i] = nodes[i] + (1f + magnit) * (vector - nodes[i]);
			}
			return array;
		}

		public static Vector3 CalculateValue(float magnit, float time01, Vector3[] nodes)
		{
			return BezierCurve.CalculateValue(time01, GetNewNodes(magnit, nodes));
		}

		public static float CalculateLength(float magnit, int smoothDivisions, Vector3[] nodes)
		{
			return BezierCurve.CalculateLength(smoothDivisions, GetNewNodes(magnit, nodes));
		}
	}
	public class QuadraticCurve
	{
		public static float CalculateLength(int smoothDivisions, Vector3[] nodes)
		{
			if (nodes == null || nodes.Length < 2)
			{
				return 0f;
			}
			float num = 0.5f / ((float)(nodes.Length - 1) * (float)Mathf.Clamp(smoothDivisions, 1, 100));
			float num2 = 0f;
			for (float num3 = 0f; num3 < 1f - num; num3 += num)
			{
				Vector3 a = CalculateValue(num3, nodes);
				Vector3 b = CalculateValue(num3 + num, nodes);
				num2 += Vector3.Distance(a, b);
			}
			return num2;
		}

		public static float CalculateLength(Vector3[] nodes)
		{
			float num = 0f;
			for (int i = 0; i < nodes.Length - 1; i++)
			{
				num += Vector3.Distance(nodes[i], nodes[i + 1]);
			}
			return num;
		}

		public static Vector3 CalculateValue(float time01, Vector3[] nodes)
		{
			if (nodes == null || nodes.Length == 0)
			{
				return Vector3.zero;
			}
			if (nodes.Length == 1)
			{
				return nodes[0];
			}
			if (nodes.Length == 2)
			{
				return Vector3.Lerp(nodes[0], nodes[1], time01);
			}
			float num = 0f;
			for (int i = 0; i < nodes.Length - 1; i++)
			{
				num += Vector3.Distance(nodes[i], nodes[i + 1]);
			}
			float num2 = time01 * num;
			if (nodes.Length == 3)
			{
				return CalculateValue(0f, num2, nodes[0], nodes[1], nodes[2]);
			}
			if (num2 <= Vector3.Distance(nodes[0], nodes[1]))
			{
				return CalculateValue(0f, num2, nodes[0], nodes[1], nodes[2]);
			}
			if (num2 >= num - Vector3.Distance(nodes[nodes.Length - 2], nodes[nodes.Length - 1]))
			{
				return CalculateValue(num - Vector3.Distance(nodes[nodes.Length - 2], nodes[nodes.Length - 1]) - Vector3.Distance(nodes[nodes.Length - 3], nodes[nodes.Length - 2]), num2, nodes[nodes.Length - 3], nodes[nodes.Length - 2], nodes[nodes.Length - 1]);
			}
			float num3 = 0f;
			Vector3 zero = Vector3.zero;
			for (int j = 0; j < nodes.Length - 2; j++)
			{
				zero += CalculateValue(num3, num2, nodes[j], nodes[j + 1], nodes[j + 2]);
				num3 += Vector3.Distance(nodes[j], nodes[j + 1]);
			}
			return 0.5f * zero;
		}

		private static Vector3 CalculateValue(float time0, float time, Vector3 node1, Vector3 node2, Vector3 node3)
		{
			float num = time0 + Vector3.Distance(node1, node2) + Vector3.Distance(node2, node3);
			if (time < time0 || time > num)
			{
				return Vector3.zero;
			}
			GetABC(time0, node1, node2, node3, out var a, out var b, out var c);
			return a * time * time + b * time + c;
		}

		private static void GetABC(float time0, Vector3 node1, Vector3 node2, Vector3 node3, out Vector3 a, out Vector3 b, out Vector3 c)
		{
			float num = time0 + Vector3.Distance(node1, node2);
			float num2 = num + Vector3.Distance(node2, node3);
			a = (node3 - (num2 * (node2 - node1) + num * node1 - time0 * node2) / (num - time0)) / (num2 * (num2 - time0 - num) + time0 * num);
			b = (node2 - node1) / (num - time0) - a * (time0 + num);
			c = (num * node1 - time0 * node2) / (num - time0) + a * time0 * num;
		}
	}
}
namespace NetworkManagement
{
	public interface AightBallPoolMessenger
	{
		void OnSendCueControl(Vector3 cuePivotPosition, float cuePivotLocalRotationY, float cueVerticalLocalRotationX, Vector2 cueDisplacementLocalPositionXY, float cueSliderLocalPositionZ, float force);
	}
	public class AightBallPoolNetworkMessenger : NetworkMessenger, AightBallPoolMessenger
	{
		private ShotController _shotController;

		private BallPool.GameManager _gameManager;

		private ShotController shotController
		{
			get
			{
				if (!_shotController)
				{
					_shotController = UnityEngine.Object.FindObjectOfType<ShotController>();
				}
				return _shotController;
			}
		}

		private BallPool.GameManager gameManager
		{
			get
			{
				if (!_gameManager)
				{
					_gameManager = UnityEngine.Object.FindObjectOfType<BallPool.GameManager>();
				}
				return _gameManager;
			}
		}

		public void SetTime(float time01)
		{
			if (BallPoolGameLogic.controlFromNetwork)
			{
				BallPoolGameManager.instance.SetPlayTime(time01);
			}
		}

		public void SetOpponentCueURL(string url)
		{
			shotController.SetOpponentCueURL(url);
		}

		public void SetOpponentTableURLs(string boardURL, string clothURL, string clothColor)
		{
			shotController.SetOpponentTableURLs(boardURL, clothURL, clothColor);
		}

		public IEnumerator OnOpponenInGameScene()
		{
			while (!shotController)
			{
				yield return null;
			}
			shotController.OpponenIsReadToPlay();
		}

		public void OnOpponentForceGoHome()
		{
			UnityEngine.Debug.LogWarning("OnOpponentForceGoHome");
			BallPoolGameManager.instance.OnForceGoHome(AightBallPoolPlayer.mainPlayer.playerId);
		}

		public void OnSendGameState(int gameState)
		{
			if ((bool)shotController)
			{
				shotController.OpponentStateFormNetwork(gameState);
			}
		}

		public void OnSendMainHanded(bool isRightHanded)
		{
			if ((bool)shotController)
			{
				shotController.OpponentMainHandFormNetwork(isRightHanded);
			}
		}

		public void OnSendCueControl(Vector3 cuePivotPosition, float cuePivotLocalRotationY, float cueVerticalLocalRotationX, Vector2 cueDisplacementLocalPositionXY, float cueSliderLocalPositionZ, float force)
		{
			if ((bool)shotController)
			{
				shotController.CueControlFromNetwork(cuePivotPosition, cuePivotLocalRotationY, cueVerticalLocalRotationX, cueDisplacementLocalPositionXY, cueSliderLocalPositionZ, force);
			}
		}

		public void OnForceSendCueControl(Vector3 cuePivotPosition, float cuePivotLocalRotationY, float cueVerticalLocalRotationX, Vector2 cueDisplacementLocalPositionXY, float cueSliderLocalPositionZ, float force)
		{
			if ((bool)shotController)
			{
				shotController.ForceCueControlFromNetwork(cuePivotPosition, cuePivotLocalRotationY, cueVerticalLocalRotationX, cueDisplacementLocalPositionXY, cueSliderLocalPositionZ, force);
			}
		}

		public void OnMoveBall(Vector3 ballPosition)
		{
			if ((bool)shotController)
			{
				shotController.MoveBallFromNetwork(ballPosition);
			}
		}

		public void SelectBallPosition(Vector3 ballPosition)
		{
			shotController.SelectBallPositionFromNetwork(ballPosition);
		}

		public void SetBallPosition(Vector3 ballPosition)
		{
			shotController.SetBallPositionFromNetwork(ballPosition);
		}

		public void SetMechanicalStatesFromNetwork(int ballId, string mechanicalStateData)
		{
			StartCoroutine(gameManager.balls[ballId].SetMechanicalStatesFromNetwork(mechanicalStateData));
		}

		public void WaitAndStopMoveFromNetwork(float time)
		{
			StartCoroutine(shotController.physicsManager.WaitAndStopMoveFromNetwork(time));
		}

		public void StartSimulate(string impulse)
		{
			shotController.physicsManager.StarShotFromNetwork(impulse);
		}

		public void EndSimulate(string data)
		{
			shotController.physicsManager.CheckEndShot(data);
		}

		public void SetPlayerTransform(string uuid, Vector3 worldPosition, Quaternion rotation, Vector3 worldPosition2, Quaternion rotation2, Vector3 worldPosition3, Quaternion rotation3)
		{
			gameManager.playerManager.SetPlayerTransform(uuid, new List<Vector3> { worldPosition, worldPosition2, worldPosition3 }, new List<Quaternion> { rotation, rotation2, rotation3 });
		}

		public void SetFoul(int FoulType, int ballId, int pocketId)
		{
			AightBallPoolGameLogic.SetFoulFormNetwork(FoulType, ballId, pocketId);
		}

		public void SetRequestRematch(bool isRequested)
		{
			if (gameManager != null)
			{
				gameManager.RequestRematch = isRequested;
			}
		}
	}
	public delegate void ButtonDownHandler(DownButton button);
	[Serializable]
	public class Sender
	{
		public string message;

		public Component sender;

		public void SendMessage()
		{
			sender.SendMessage(message);
		}
	}
	public class DownButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
	{
		public List<Sender> senders;

		public event ButtonDownHandler OnDown;

		public void OnPointerDown(PointerEventData eventData)
		{
			foreach (Sender sender in senders)
			{
				sender.SendMessage();
			}
			if (this.OnDown != null)
			{
				this.OnDown(this);
			}
		}
	}
	public delegate void DownloadHaldler(DownloadManager.DownloadParameters parameters);
	public class DownloadManager : MonoBehaviour
	{
		public enum DownloadType
		{
			AlwaysDownload,
			Update,
			DownloadOrLoadFromDisc
		}

		public class DownloadParameters
		{
			public string URL { get; private set; }

			public string name { get; private set; }

			public string localURL { get; set; }

			public DownloadType downloadType { get; private set; }

			public bool isNull { get; set; }

			public string error { get; set; }

			public bool downloading { get; set; }

			public float progress { get; set; }

			public byte[] bytes { get; private set; }

			public string text { get; private set; }

			public Texture2D texture { get; private set; }

			public AssetBundle assetBundle { get; private set; }

			public DownloadParameters(string URL, string name, DownloadType downloadType = DownloadType.DownloadOrLoadFromDisc)
			{
				isNull = false;
				error = "";
				this.URL = URL;
				this.name = name;
				this.downloadType = downloadType;
			}

			public void SetData(byte[] bytes, string text, Texture2D texture, AssetBundle assetBundle)
			{
				this.bytes = bytes;
				this.text = text;
				this.texture = texture;
				this.assetBundle = assetBundle;
			}
		}

		public static event DownloadHaldler OnStartDownload;

		public static event DownloadHaldler OnEndDownload;

		public static event DownloadHaldler OnDownloading;

		public static void DeleteDocumendsFromPersistentStorage()
		{
			string path = UnityEngine.Application.persistentDataPath + "/SavedData/Documends";
			if (Directory.Exists(path))
			{
				Directory.Delete(path, recursive: true);
			}
		}

		public static void DeleteKeyValuFromPersistentStorage()
		{
			string path = UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage";
			if (Directory.Exists(path))
			{
				Directory.Delete(path, recursive: true);
			}
		}

		public static void SaveGameDataToDocumends(Dictionary<string, DataManager.Data> gameDataDictionary)
		{
			if (gameDataDictionary == null)
			{
				return;
			}
			DeleteKeyValuFromPersistentStorage();
			CheckKeyValueStorageDirectory();
			foreach (KeyValuePair<string, DataManager.Data> item in gameDataDictionary)
			{
				SaveString(item.Value.typeId, item.Key, item.Value.value);
			}
		}

		public static Dictionary<string, DataManager.Data> LoadGameDataFromDocumends()
		{
			CheckKeyValueStorageDirectory();
			Dictionary<string, DataManager.Data> dictionary = new Dictionary<string, DataManager.Data>();
			string text = UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/Int/";
			FileInfo[] files = new DirectoryInfo(text).GetFiles();
			foreach (FileInfo fileInfo in files)
			{
				dictionary.Add(fileInfo.Name.Replace(".dat", ""), new DataManager.Data(1, File.ReadAllText(text + fileInfo.Name, Encoding.UTF8)));
			}
			string text2 = UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/Float/";
			files = new DirectoryInfo(text2).GetFiles();
			foreach (FileInfo fileInfo2 in files)
			{
				dictionary.Add(fileInfo2.Name.Replace(".dat", ""), new DataManager.Data(2, File.ReadAllText(text2 + fileInfo2.Name, Encoding.UTF8)));
			}
			string text3 = UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/String/";
			files = new DirectoryInfo(text3).GetFiles();
			foreach (FileInfo fileInfo3 in files)
			{
				dictionary.Add(fileInfo3.Name.Replace(".dat", ""), new DataManager.Data(3, File.ReadAllText(text3 + fileInfo3.Name, Encoding.UTF8)));
			}
			return dictionary;
		}

		private static void CheckDirectory()
		{
			if (!Directory.Exists(UnityEngine.Application.persistentDataPath + "/SavedData"))
			{
				Directory.CreateDirectory(UnityEngine.Application.persistentDataPath + "/SavedData");
			}
		}

		private static void CheckDocumendsDirectory()
		{
			CheckDirectory();
			if (!Directory.Exists(UnityEngine.Application.persistentDataPath + "/SavedData/Documends"))
			{
				Directory.CreateDirectory(UnityEngine.Application.persistentDataPath + "/SavedData/Documends");
			}
		}

		private static void CheckKeyValueStorageDirectory()
		{
			CheckDirectory();
			if (!Directory.Exists(UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/Int"))
			{
				Directory.CreateDirectory(UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/Int");
			}
			if (!Directory.Exists(UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/Float"))
			{
				Directory.CreateDirectory(UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/Float");
			}
			if (!Directory.Exists(UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/String"))
			{
				Directory.CreateDirectory(UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/String");
			}
		}

		private static string GetKeyValueStoragePath(int typeId, string key)
		{
			CheckKeyValueStorageDirectory();
			return UnityEngine.Application.persistentDataPath + "/SavedData/KeyValueStorage/" + (typeId switch
			{
				2 => "Float", 
				1 => "Int", 
				_ => "String", 
			}).ToString() + "/" + key + ".dat";
		}

		public static string LoadString(int typeId, string key)
		{
			byte[] bytes = File.ReadAllBytes(GetKeyValueStoragePath(typeId, key));
			return Encoding.UTF8.GetString(bytes);
		}

		public static void SaveString(int typeId, string key, string value)
		{
			string keyValueStoragePath = GetKeyValueStoragePath(typeId, key);
			byte[] bytes = Encoding.UTF8.GetBytes(value);
			File.WriteAllBytes(keyValueStoragePath, bytes);
		}

		public static IEnumerator Download(DownloadParameters parameters)
		{
			if (parameters.downloadType == DownloadType.AlwaysDownload)
			{
				if (DownloadManager.OnStartDownload != null)
				{
					DownloadManager.OnStartDownload(parameters);
				}
				yield return null;
				WWW downloadData = new WWW(parameters.URL);
				while (!downloadData.isDone)
				{
					if (DownloadManager.OnDownloading != null)
					{
						parameters.downloading = true;
						parameters.progress = downloadData.progress;
						DownloadManager.OnDownloading(parameters);
					}
					yield return null;
				}
				yield return downloadData;
				if (string.IsNullOrEmpty(downloadData.error))
				{
					parameters.SetData(downloadData.bytes, downloadData.text, downloadData.texture, downloadData.assetBundle);
				}
				else
				{
					parameters.isNull = true;
					parameters.error = downloadData.error;
				}
				if (DownloadManager.OnEndDownload != null)
				{
					DownloadManager.OnEndDownload(parameters);
				}
				yield break;
			}
			CheckDocumendsDirectory();
			string path = UnityEngine.Application.persistentDataPath + "/SavedData/Documends/" + parameters.URL.Replace("https://www.", "").Replace(".com", "").Replace("/", "")
				.Replace("?dl=0", "")
				.Replace("https:", "")
				.Replace("-", "")
				.Replace("_", "")
				.Replace("?", "")
				.Replace(".", "")
				.Replace("=", "")
				.Replace("&", "")
				.Replace("%20", "")
				.Replace(" ", "") + ".dat";
			if (UnityEngine.Application.internetReachability != 0 && (!File.Exists(path) || parameters.downloadType == DownloadType.Update))
			{
				if (DownloadManager.OnStartDownload != null)
				{
					DownloadManager.OnStartDownload(parameters);
				}
				yield return null;
				WWW downloadData = new WWW(parameters.URL);
				while (!downloadData.isDone)
				{
					if (DownloadManager.OnDownloading != null)
					{
						parameters.downloading = true;
						parameters.progress = downloadData.progress;
						DownloadManager.OnDownloading(parameters);
					}
					yield return null;
				}
				yield return downloadData;
				if (string.IsNullOrEmpty(downloadData.error))
				{
					parameters.SetData(downloadData.bytes, downloadData.text, downloadData.texture, downloadData.assetBundle);
					File.WriteAllBytes(path, downloadData.bytes);
				}
				else
				{
					parameters.error = downloadData.error;
					parameters.isNull = true;
				}
				if (DownloadManager.OnEndDownload != null)
				{
					DownloadManager.OnEndDownload(parameters);
				}
			}
			else if (File.Exists(path))
			{
				if (DownloadManager.OnStartDownload != null)
				{
					DownloadManager.OnStartDownload(parameters);
				}
				parameters.localURL = "file://" + path;
				UnityWebRequest www = UnityWebRequest.Get(parameters.localURL);
				while (!www.isDone)
				{
					if (DownloadManager.OnDownloading != null)
					{
						parameters.downloading = false;
						parameters.progress = www.downloadProgress;
						DownloadManager.OnDownloading(parameters);
					}
					yield return null;
				}
				yield return www;
				if (string.IsNullOrEmpty(www.error))
				{
					parameters.SetData(www.downloadHandler.data, www.downloadHandler.text, (www.downloadHandler as DownloadHandlerTexture).texture, (www.downloadHandler as DownloadHandlerAssetBundle).assetBundle);
				}
				else
				{
					parameters.isNull = true;
					parameters.error = www.error;
				}
				if (DownloadManager.OnEndDownload != null)
				{
					DownloadManager.OnEndDownload(parameters);
				}
			}
			else
			{
				parameters.isNull = true;
				parameters.error = "Some error";
			}
		}
	}
	public class LoginManager
	{
		private static bool _isLogined;

		public static bool logined
		{
			get
			{
				if (!_isLogined)
				{
					_isLogined = DataManager.GetIntData("IsLogined") == 1;
				}
				return _isLogined;
			}
			set
			{
				_isLogined = value;
				DataManager.SetIntData("IsLogined", _isLogined ? 1 : 0);
			}
		}

		public static bool loginedFacebook => FacebookManager.instance.IsLoggedIn;

		public static bool TotalLogined
		{
			get
			{
				UnityEngine.Debug.Log($"accesse in Development code : {typeof(LoginManager)} , TotalLogined");
				return true;
			}
		}
	}
	public delegate void NetworkHandler(NetworkState state);
	public enum NetworkState
	{
		Disconnected,
		Connected,
		FiledToConnect,
		LostConnection,
		CreatedRoom,
		JoinedToRoom,
		LeftRoom,
		RoomCreateFailed,
		JoinRoomFailed,
		OpponentReadToPlay
	}
	public abstract class NetworkEngine : MonoBehaviour
	{
		protected const float BackgroundTimeout = 10f;

		private float reachableTimer;

		protected bool oldReachable;

		public NetworkGameAdapter adapter { get; private set; }

		public int sendRate { get; protected set; }

		public bool opponenWaitingForYourTurn { get; protected set; }

		protected bool reachable => UnityEngine.Application.internetReachability != NetworkReachability.NotReachable;

		public NetworkState state { get; private set; }

		public event NetworkHandler OnNetwork;

		public abstract void SendRemoteMessage(string message, params object[] args);

		public abstract void OnGoToPLayWithPlayer(PlayerProfile player);

		public void SetAdapter(NetworkGameAdapter adapter)
		{
			this.adapter = adapter;
		}

		protected void CallNetworkState(NetworkState state)
		{
			this.state = state;
			if (this.OnNetwork != null)
			{
				this.OnNetwork(state);
			}
		}

		public virtual void Initialize()
		{
			opponenWaitingForYourTurn = false;
		}

		protected virtual void Awake()
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			state = NetworkState.Disconnected;
		}

		protected virtual void Update()
		{
			if (oldReachable != reachable)
			{
				if (!reachable)
				{
					if (oldReachable != reachable)
					{
						if (reachableTimer > 10f)
						{
							reachableTimer = 0f;
							oldReachable = reachable;
						}
						else
						{
							reachableTimer += Time.deltaTime;
						}
					}
				}
				else
				{
					oldReachable = reachable;
					reachableTimer = 0f;
				}
				if (!oldReachable)
				{
					CallNetworkState(NetworkState.LostConnection);
				}
			}
			else
			{
				reachableTimer = 0f;
			}
		}

		private IEnumerator Start()
		{
			yield break;
		}

		public virtual void Disable()
		{
			this.OnNetwork = null;
		}

		public abstract void Reset();

		public abstract void Disconnect();

		public abstract bool ChackIsFriend(string id);

		public abstract void CreateRoom();

		public abstract void LeftRoom();

		public abstract void Connect();

		public abstract void OnOpponenReadToPlay(string playerData, bool is3DGraphicMode);

		public abstract void OnOpponenStartToPlay(int turnId);

		public abstract void OnSendTime(float time01);

		public void OnMadeTurn()
		{
			opponenWaitingForYourTurn = false;
		}

		public abstract void StartSimulate(string ballsState);

		public abstract void EndSimulate(string ballsState);

		public virtual void OnOpponenWaitingForYourTurn()
		{
			opponenWaitingForYourTurn = true;
		}

		public abstract void OnOpponenInGameScene();

		public abstract void OnOpponentForceGoHome();

		public abstract void StartUpdatePlayers();

		public abstract void LoadPlayers(ref PlayerProfile[] players);
	}
	public delegate void UpdateCoinsHandler(int coins);
	public delegate void LoginHandler(LoginedState state);
	public delegate void LoadPlayersHandler(PlayerProfile[] players);
	public delegate void LoadPlayerHandler(PlayerProfile player);
	public delegate void SetPlayerHandler(PlayerProfile player);
	public delegate bool ChackIsFriend(string id);
	public enum LoginedState
	{
		Successful,
		Unsuccessful
	}
	public enum PurchasedState
	{
		Successful,
		Unsuccessful
	}
	public enum PlayerState
	{
		Online,
		Away,
		Busy,
		Offline,
		Playing
	}
	public class Room
	{
		public int id { get; private set; }

		public int prize { get; set; }

		public PlayerProfile mainPlayer { get; private set; }

		public List<PlayerProfile> players { get; private set; }

		public Room(int id, int prize, List<PlayerProfile> players)
		{
			this.id = id;
			this.prize = prize;
			this.players = players;
			mainPlayer = ((players == null || players.Count == 0) ? null : players[0]);
			foreach (PlayerProfile player in players)
			{
				player.roomId = id;
			}
		}
	}
	[Serializable]
	public class DefaultProductProfile
	{
		public string name;

		public int price;

		public Texture2D icon;

		public UnityEngine.Object[] sources;
	}
	public class PlayerProfile
	{
		public string id { get; private set; }

		public bool canPlayOffline => true;

		public bool canPlayOnLine => true;

		public int roomId { get; set; }

		public bool isMain { get; private set; }

		public Texture2D image { get; private set; }

		public string imageURL { get; private set; }

		public string imageName { get; private set; }

		public bool isFriend { get; private set; }

		public string userName { get; private set; }

		public int coins { get; private set; }

		public int prize { get; set; }

		public PlayerState state { get; set; }

		public void UpdateCoinsWithoutSave(int coins)
		{
			this.coins = Mathf.Clamp(coins, NetworkManager.social.minCoinsCount, coins);
		}

		public void UpdateCoins(int coins)
		{
			this.coins = Mathf.Clamp(coins, NetworkManager.social.minCoinsCount, coins);
			NetworkManager.social.SaveMainPlayerCoins(this.coins);
		}

		public PlayerProfile(string id, bool isMain, Texture2D image, string imageURL, string imageName, bool isFriend, string userName, PlayerState state, int coins, int prize)
		{
			this.id = id;
			this.isMain = isMain;
			this.image = image;
			this.imageURL = imageURL;
			this.imageName = imageName;
			this.isFriend = isFriend;
			this.userName = userName;
			this.state = state;
			this.coins = coins;
			this.prize = prize;
		}

		public void SetImage(Texture2D image)
		{
			if ((bool)image)
			{
				this.image = image;
			}
		}

		public void UpdateName(string userName)
		{
			if (!string.IsNullOrEmpty(userName))
			{
				this.userName = userName;
				NetworkManager.social.SaveMainPlayerName(userName);
			}
		}
	}
	public class NetworkManager
	{
		public static bool initialized;

		private static bool mainPlayerLoadedInProgress;

		private static NetworkEngine _network;

		private static SocialEngine _social;

		private static PlayerProfile[] _players;

		private static PlayerProfile[] _friends;

		private static PlayerProfile[] _notFriends;

		private static PlayerProfile[] detectedPlayers;

		public static string absoluteURL => UnityEngine.Application.absoluteURL.Replace("%20", "").Replace(" ", "");

		public static NetworkEngine network
		{
			get
			{
				if (!_network)
				{
					_network = new GameObject("Network").AddComponent<PunNetwork>();
					_network.Initialize();
				}
				return _network;
			}
		}

		public static SocialEngine social
		{
			get
			{
				if (_social == null)
				{
					_social = new SocialExample();
				}
				return _social;
			}
		}

		public static PlayerProfile mainPlayer { get; private set; }

		public static PlayerProfile opponentPlayer { get; set; }

		public static PlayerProfile[] players
		{
			get
			{
				if (_players == null)
				{
					LoadPlayers();
				}
				return _players;
			}
		}

		public static PlayerProfile[] friends
		{
			get
			{
				if (LoginManager.logined || LoginManager.loginedFacebook)
				{
					if (_friends == null)
					{
						LoadPlayers();
					}
					return _friends;
				}
				return null;
			}
		}

		public static PlayerProfile[] notFriends
		{
			get
			{
				if (_notFriends == null)
				{
					LoadPlayers();
				}
				return _notFriends;
			}
		}

		public static string mainPlayerEmail => social.GetMainPlayerEmail();

		public static string privacyPolicyURL => social.GetPrivacyPolicyURL();

		public static event UpdateCoinsHandler OnCoinsUpdated;

		public static event LoadPlayersHandler OnPlayersLoaded;

		public static event LoadPlayerHandler OnRandomPlayerLoaded;

		public static event LoadPlayersHandler OnFriendsAndRandomPlayersLoaded;

		public static event LoadPlayerHandler OnMainPlayerLoaded;

		public static event LoadPlayerHandler OnFriendLoaded;

		public static event SetPlayerHandler OnPlayerSet;

		public static void CallUpdatedCoins()
		{
			if (NetworkManager.OnCoinsUpdated != null)
			{
				NetworkManager.OnCoinsUpdated(mainPlayer.coins);
			}
		}

		public static void Disable()
		{
			NetworkManager.OnPlayersLoaded = null;
			NetworkManager.OnRandomPlayerLoaded = null;
			NetworkManager.OnFriendsAndRandomPlayersLoaded = null;
			NetworkManager.OnMainPlayerLoaded = null;
			NetworkManager.OnFriendLoaded = null;
			NetworkManager.OnPlayerSet = null;
			if ((bool)_network)
			{
				_network.Disable();
			}
			if (_social != null)
			{
				_social.Disable();
			}
		}

		public static void SignUp(string email, string password)
		{
			social.SignUp(email, password);
		}

		public static void Login(string email, string password)
		{
			social.Login(email, password);
		}

		public static void LoginWithFacebook()
		{
			social.LoginWithFacebok();
		}

		public static void InitializeMainPlayer()
		{
			if (mainPlayer == null)
			{
				mainPlayer = new PlayerProfile(social.mainPlayerId, isMain: true, null, string.Empty, string.Empty, isFriend: false, social.GetMainPlayerName(), PlayerState.Online, social.GetMainPlayerCoins(), social.GetMainPlayerPrize());
			}
		}

		public static IEnumerator LoadFriendsAndRandomPlayers(int maxCount)
		{
			List<PlayerProfile> _detectedPlayers = new List<PlayerProfile>(0);
			yield return null;
			if (friends != null && friends.Length != 0)
			{
				for (int j = 0; j < friends.Length && j < maxCount; j++)
				{
					PlayerProfile friend2 = friends[j];
					_detectedPlayers.Add(friend2);
					Texture2D image = friend2.image;
					if ((bool)image)
					{
						continue;
					}
					WWW imageData2 = new WWW(friend2.imageURL);
					yield return imageData2;
					if (string.IsNullOrEmpty(imageData2.error))
					{
						image = imageData2.texture;
						friend2.SetImage(image);
						if (NetworkManager.OnPlayerSet != null)
						{
							NetworkManager.OnPlayerSet(friend2);
						}
					}
				}
			}
			yield return null;
			if (notFriends != null && notFriends.Length != 0)
			{
				for (int j = 0; j < notFriends.Length && (friends == null || j < maxCount - friends.Length); j++)
				{
					PlayerProfile friend2 = notFriends[j];
					_detectedPlayers.Add(friend2);
					Texture2D image2 = friend2.image;
					if ((bool)image2)
					{
						continue;
					}
					WWW imageData2 = new WWW(friend2.imageURL);
					yield return imageData2;
					if (string.IsNullOrEmpty(imageData2.error))
					{
						image2 = imageData2.texture;
						friend2.SetImage(image2);
						if (NetworkManager.OnPlayerSet != null)
						{
							NetworkManager.OnPlayerSet(friend2);
						}
					}
				}
			}
			detectedPlayers = _detectedPlayers.ToArray();
			if (NetworkManager.OnFriendsAndRandomPlayersLoaded != null)
			{
				NetworkManager.OnFriendsAndRandomPlayersLoaded(players);
			}
		}

		public static IEnumerator LoadFriend(string id)
		{
			yield return null;
			PlayerProfile friend = null;
			PlayerProfile[] array = friends;
			foreach (PlayerProfile playerProfile in array)
			{
				if (!(playerProfile.id == id))
				{
					continue;
				}
				friend = playerProfile;
				Texture2D image = friend.image;
				if ((bool)image)
				{
					break;
				}
				WWW imageData = new WWW(friend.imageURL);
				yield return imageData;
				if (string.IsNullOrEmpty(imageData.error))
				{
					image = imageData.texture;
					friend.SetImage(image);
					if (NetworkManager.OnPlayerSet != null)
					{
						NetworkManager.OnPlayerSet(friend);
					}
				}
				break;
			}
			if (friend != null && NetworkManager.OnFriendLoaded != null)
			{
				NetworkManager.OnFriendLoaded(friend);
			}
		}

		public static IEnumerator SetMainPlayerImage(Texture2D image)
		{
			while (mainPlayerLoadedInProgress)
			{
				yield return null;
			}
			mainPlayerLoadedInProgress = true;
			mainPlayer = new PlayerProfile(social.mainPlayerId, isMain: true, image, "", image.name, isFriend: false, social.GetMainPlayerName(), PlayerState.Online, social.GetMainPlayerCoins(), social.GetMainPlayerPrize());
			if (NetworkManager.OnMainPlayerLoaded != null)
			{
				NetworkManager.OnMainPlayerLoaded(mainPlayer);
			}
			mainPlayerLoadedInProgress = false;
		}

		[Obsolete]
		public static IEnumerator SetMainPlayerImage(string imageURL)
		{
			while (mainPlayerLoadedInProgress)
			{
				yield return null;
			}
			mainPlayerLoadedInProgress = true;
			Texture2D image = null;
			if (!string.IsNullOrEmpty(imageURL))
			{
				DownloadManager.DownloadParameters parameters = new DownloadManager.DownloadParameters(imageURL, "Main player");
				yield return DownloadManager.Download(parameters);
				if ((bool)parameters.texture)
				{
					image = parameters.texture;
				}
			}
			mainPlayer = new PlayerProfile(social.mainPlayerId, isMain: true, image, imageURL, "", isFriend: false, social.GetMainPlayerName(), PlayerState.Online, social.GetMainPlayerCoins(), social.GetMainPlayerPrize());
			if (NetworkManager.OnMainPlayerLoaded != null)
			{
				NetworkManager.OnMainPlayerLoaded(mainPlayer);
			}
			mainPlayerLoadedInProgress = false;
		}

		public static IEnumerator LoadMainPlayer(Texture2D image)
		{
			if (social.AvatarDataIsLocal())
			{
				yield break;
			}
			while (mainPlayerLoadedInProgress)
			{
				yield return null;
			}
			mainPlayerLoadedInProgress = true;
			yield return null;
			string mainURL = social.GetAvatarURL();
			if (!string.IsNullOrEmpty(mainURL))
			{
				DownloadManager.DownloadParameters parameters = new DownloadManager.DownloadParameters(mainURL, "Main player", DownloadManager.DownloadType.Update);
				yield return DownloadManager.Download(parameters);
				if ((bool)parameters.texture)
				{
					image = parameters.texture;
				}
			}
			mainPlayer = new PlayerProfile(social.mainPlayerId, isMain: true, image, mainURL, "", isFriend: false, social.GetMainPlayerName(), PlayerState.Online, social.GetMainPlayerCoins(), social.GetMainPlayerPrize());
			if (NetworkManager.OnMainPlayerLoaded != null)
			{
				NetworkManager.OnMainPlayerLoaded(mainPlayer);
			}
			mainPlayerLoadedInProgress = false;
		}

		public static IEnumerator LoadRandomPlayer()
		{
			yield return null;
			opponentPlayer = null;
			if (players != null && players.Length != 0)
			{
				PlayerProfile[] array = players.Where((PlayerProfile player) => player.prize <= mainPlayer.coins && player.state == PlayerState.Online).ToArray();
				if (array != null && array.Length != 0)
				{
					int num = UnityEngine.Random.Range(0, array.Length);
					opponentPlayer = array[num];
					Texture2D image = opponentPlayer.image;
					if (!image && !string.IsNullOrEmpty(opponentPlayer.imageURL))
					{
						WWW imageData = new WWW(opponentPlayer.imageURL);
						yield return imageData;
						if (string.IsNullOrEmpty(imageData.error))
						{
							image = imageData.texture;
							opponentPlayer.SetImage(image);
						}
						if (NetworkManager.OnPlayerSet != null)
						{
							NetworkManager.OnPlayerSet(opponentPlayer);
						}
					}
				}
			}
			if (NetworkManager.OnRandomPlayerLoaded != null)
			{
				NetworkManager.OnRandomPlayerLoaded(opponentPlayer);
			}
		}

		public static PlayerProfile FindPlayer(string playerId)
		{
			return players.Where((PlayerProfile player) => player.id == playerId).ToArray()[0];
		}

		public static PlayerProfile[] FindPlayers(string userName, int prize, bool isOnline, bool onlyFriends)
		{
			if (string.IsNullOrEmpty(userName) && prize == 0 && !isOnline && !onlyFriends)
			{
				return detectedPlayers;
			}
			return detectedPlayers.Where((PlayerProfile player) => (string.IsNullOrEmpty(userName) || player.userName.Contains(userName)) && (prize == 0 || player.prize <= prize) && (!isOnline || player.state == PlayerState.Online) && (!onlyFriends || player.isFriend)).ToArray();
		}

		public static void UpdatePlayers()
		{
			_players = null;
			LoadPlayers();
		}

		private static void LoadPlayers()
		{
			network.LoadPlayers(ref _players);
			if (_players != null)
			{
				if (LoginManager.logined || LoginManager.loginedFacebook)
				{
					_friends = _players.Where((PlayerProfile player) => player.isFriend).ToArray();
				}
				else
				{
					_friends = null;
				}
				_notFriends = _players.Where((PlayerProfile player) => !player.isFriend).ToArray();
			}
			if (NetworkManager.OnPlayersLoaded != null)
			{
				NetworkManager.OnPlayersLoaded(_players);
			}
		}

		public static PlayerProfile PlayerFromString(string playerData, ChackIsFriend friendChecker)
		{
			string text = "";
			int num = 0;
			string id = "-1";
			string imageURL = "";
			string imageName = "";
			bool isFriend = false;
			string userName = "";
			PlayerState state = PlayerState.Offline;
			int coins = 0;
			int prize = 0;
			for (int i = 0; i < playerData.Length; i++)
			{
				char c = playerData[i];
				if (c != ';')
				{
					text += c;
					continue;
				}
				num++;
				switch (num)
				{
				case 1:
					id = text;
					isFriend = friendChecker(id);
					break;
				case 2:
					imageURL = text;
					break;
				case 3:
					imageName = text;
					break;
				case 4:
					userName = text;
					break;
				case 5:
					state = (PlayerState)int.Parse(text);
					break;
				case 6:
					coins = int.Parse(text);
					break;
				case 7:
					prize = int.Parse(text);
					break;
				}
				text = "";
			}
			return new PlayerProfile(id, isMain: false, null, imageURL, imageName, isFriend, userName, state, coins, prize);
		}

		public static string PlayerToString(PlayerProfile playerProfile)
		{
			if (playerProfile == null)
			{
				return "";
			}
			return playerProfile.id + ";" + playerProfile.imageURL + ";" + playerProfile.imageName + ";" + playerProfile.userName + ";" + (int)playerProfile.state + ";" + playerProfile.coins + ";" + playerProfile.prize + ";";
		}
	}
	public abstract class NetworkMessenger : MonoBehaviour
	{
	}
	public delegate void gameStateChangedHandle(string game_state);
	public static class DataExtansion
	{
		public static string ToString4(this float value)
		{
			return ((int)(value * 10000f)).ToString();
		}

		public static float ToFloat4(this string value)
		{
			return (float)int.Parse(value) / 10000f;
		}
	}
	public class DataManager : MonoBehaviour
	{
		public class Data
		{
			public int typeId { get; private set; }

			public string value { get; private set; }

			public Data(int typeId, string value)
			{
				this.typeId = typeId;
				this.value = value;
			}
		}

		private static DataManager instance;

		private static bool gameDataSaved;

		private static Dictionary<string, Data> gameStateDictionary;

		private static Dictionary<string, Data> gameDataDictionary;

		public static string gameState;

		private static string _gameState;

		public static event gameStateChangedHandle OngameStateChanged;

		private void Awake()
		{
			if ((bool)instance)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			instance = this;
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		}

		private void OnDisable()
		{
			if (!gameDataSaved && instance == this)
			{
				SaveGameData();
			}
		}

		private void OnDestroy()
		{
			if (!gameDataSaved && instance == this)
			{
				SaveGameData();
			}
		}

		private void OnApplicationQuit()
		{
			if (!gameDataSaved)
			{
				SaveGameData();
			}
		}

		private static void SavegameState()
		{
			if (DataManager.OngameStateChanged != null)
			{
				DataManager.OngameStateChanged(gameState);
			}
			PlayerPrefs.Save();
		}

		public static void SaveGameData()
		{
			gameDataSaved = true;
			DownloadManager.SaveGameDataToDocumends(gameDataDictionary);
		}

		private static void LoadGameData()
		{
			gameDataDictionary = DownloadManager.LoadGameDataFromDocumends();
		}

		private static string GetFromGameData(int typeId, string key)
		{
			if (gameDataDictionary == null)
			{
				LoadGameData();
			}
			if (gameDataDictionary == null)
			{
				return "";
			}
			foreach (KeyValuePair<string, Data> item in gameDataDictionary)
			{
				if (item.Key == key && item.Value.typeId == typeId)
				{
					return gameDataDictionary[key].value;
				}
			}
			return "";
		}

		private static void AddToGameData(int typeId, string key, string value)
		{
			if (gameDataDictionary == null)
			{
				gameDataDictionary = new Dictionary<string, Data>();
			}
			if (gameDataDictionary.ContainsKey(key))
			{
				gameDataDictionary[key] = new Data(typeId, value);
			}
			else
			{
				gameDataDictionary.Add(key, new Data(typeId, value));
			}
		}

		private static bool AddToGameState(int typeId, string key, string value)
		{
			if (value.Contains("[") || value.Contains("]") || value.Contains(";") || value.Contains("{") || value.Contains("}"))
			{
				UnityEngine.Debug.LogError(value + ": the value can not have characters such as [ ; { ");
				return false;
			}
			if (gameStateDictionary == null)
			{
				gameStateDictionary = new Dictionary<string, Data>();
			}
			if (gameStateDictionary.ContainsKey(key))
			{
				gameStateDictionary[key] = new Data(typeId, value);
			}
			else
			{
				gameStateDictionary.Add(key, new Data(typeId, value));
			}
			_gameState = "";
			foreach (KeyValuePair<string, Data> item in gameStateDictionary)
			{
				_gameState = _gameState + "[" + item.Value.typeId + ";" + item.Key + ";" + item.Value.value + "]";
			}
			if (gameState != _gameState)
			{
				gameState = _gameState;
				SavegameState();
			}
			return true;
		}

		public static void SetInt(string key, int value)
		{
			if (AddToGameState(1, key, value.ToString()))
			{
				PlayerPrefs.SetInt(key, value);
			}
		}

		public static int GetInt(string key)
		{
			return PlayerPrefs.GetInt(key);
		}

		public static void SetFloat(string key, float value)
		{
			if (AddToGameState(2, key, value.ToString()))
			{
				PlayerPrefs.SetFloat(key, value);
			}
		}

		public static float GetFloat(string key, float defaultValue)
		{
			return PlayerPrefs.GetFloat(key, defaultValue);
		}

		public static float GetFloat(string key)
		{
			return PlayerPrefs.GetFloat(key);
		}

		public static void SetString(string key, string value)
		{
			if (AddToGameState(3, key, value))
			{
				PlayerPrefs.SetString(key, value);
			}
		}

		public static string GetString(string key)
		{
			return PlayerPrefs.GetString(key);
		}

		public static void DeleteKey(string key)
		{
			if (gameStateDictionary.ContainsKey(key))
			{
				gameStateDictionary.Remove(key);
			}
			PlayerPrefs.DeleteKey(key);
		}

		public static void SetIntData(string key, int value)
		{
			AddToGameData(1, key, value.ToString());
		}

		public static int GetIntData(string key)
		{
			int result = 0;
			int.TryParse(GetFromGameData(1, key), out result);
			return result;
		}

		public static void SetFloatData(string key, float value)
		{
			AddToGameData(2, key, value.ToString());
		}

		public static float GetFloatData(string key)
		{
			float result = 0f;
			float.TryParse(GetFromGameData(2, key), out result);
			return result;
		}

		public static void SetStringData(string key, string value)
		{
			AddToGameData(3, key, value.ToString());
		}

		public static string GetStringData(string key)
		{
			return GetFromGameData(3, key);
		}

		public static void SetColorData(string key, Color value)
		{
			SetStringData(key, ColorToString(value));
		}

		public static bool GetColorData(string key, out Color value)
		{
			string stringData = GetStringData(key);
			if (!string.IsNullOrEmpty(stringData))
			{
				value = ColorFromString(stringData);
				return true;
			}
			value = default(Color);
			return false;
		}

		public static void DeleteKeyData(string key)
		{
			if (gameDataDictionary.ContainsKey(key))
			{
				gameDataDictionary.Remove(key);
			}
		}

		public static float CutValue(float value, int count = 3)
		{
			return value;
		}

		public static string Vector3ToString(Vector3 v)
		{
			float num = CutValue(v.x);
			float num2 = CutValue(v.y);
			float num3 = CutValue(v.z);
			if (num == 0f && num2 == 0f && num3 == 0f)
			{
				return "z";
			}
			if (num == 1f && num2 == 0f && num3 == 0f)
			{
				return "r";
			}
			if (num == 0f && num2 == 1f && num3 == 0f)
			{
				return "u";
			}
			if (num == 0f && num2 == 0f && num3 == 1f)
			{
				return "f";
			}
			if (num == -1f && num2 == 0f && num3 == 0f)
			{
				return "l";
			}
			if (num == 0f && num2 == -1f && num3 == 0f)
			{
				return "d";
			}
			if (num == 0f && num2 == 0f && num3 == -1f)
			{
				return "b";
			}
			if (num == 1f && num2 == 1f && num3 == 1f)
			{
				return "o";
			}
			return "(" + num.ToString4() + ", " + num2.ToString4() + ", " + num3.ToString4() + ")";
		}

		public static Vector3 Vector3FromString(string s)
		{
			switch (s)
			{
			case "":
			case "z":
				return Vector3.zero;
			case "r":
				return Vector3.right;
			case "u":
				return Vector3.up;
			case "f":
				return Vector3.forward;
			case "l":
				return Vector3.left;
			case "d":
				return Vector3.down;
			case "b":
				return Vector3.back;
			case "o":
				return Vector3.one;
			default:
			{
				string text = "";
				string text2 = "";
				string text3 = "";
				int num = 1;
				for (int i = 0; i < s.Length; i++)
				{
					char c = s[i];
					switch (c)
					{
					case ',':
						num++;
						continue;
					case ' ':
					case '(':
					case ')':
						continue;
					}
					switch (num)
					{
					case 1:
						text += c;
						break;
					case 2:
						text2 += c;
						break;
					case 3:
						text3 += c;
						break;
					}
				}
				float x = text.ToFloat4();
				float y = text2.ToFloat4();
				float z = text3.ToFloat4();
				return new Vector3(x, y, z);
			}
			}
		}

		public static Color ColorFromString(string data)
		{
			string[] array = ConvertDataToStringArray(data);
			float r = array[0].ToFloat4();
			float g = array[1].ToFloat4();
			float b = array[2].ToFloat4();
			float a = array[3].ToFloat4();
			return new Color(r, g, b, a);
		}

		public static string ColorToString(Color value)
		{
			return "[" + value.r.ToString4() + ";" + value.g.ToString4() + ";" + value.b.ToString4() + ";" + value.a.ToString4() + "]";
		}

		public static string ImpulseToString(Impulse impulse)
		{
			return "[" + Vector3ToString(impulse.point) + ";" + Vector3ToString(impulse.impulse) + "]";
		}

		public static Impulse ImpulseFromString(string data)
		{
			string[] array = ConvertDataToStringArray(data);
			Vector3 point = Vector3FromString(array[0]);
			Vector3 impulse = Vector3FromString(array[1]);
			return new Impulse(point, impulse);
		}

		public static string[] ConvertDataToStringArray(string data)
		{
			List<string> list = new List<string>(0);
			string text = "";
			for (int i = 0; i < data.Length; i++)
			{
				char c = data[i];
				switch (c)
				{
				case ']':
					break;
				case ';':
					list.Add(text);
					text = "";
					continue;
				default:
					text += c;
					continue;
				case ' ':
				case '[':
					continue;
				}
				list.Add(text);
				break;
			}
			return list.ToArray();
		}

		public static string[] ConvertArrayDataToStringArray(string data)
		{
			List<string> list = new List<string>(0);
			string text = "";
			for (int i = 0; i < data.Length; i++)
			{
				char c = data[i];
				switch (c)
				{
				case ']':
					text += c;
					list.Add(text);
					text = "";
					break;
				default:
					text += c;
					break;
				case ' ':
					break;
				}
			}
			return list.ToArray();
		}
	}
	public class DebugManager : MonoBehaviour
	{
		[SerializeField]
		private Text text;

		private static DebugManager instance;

		[SerializeField]
		private int linesMaxCount;

		private int linesCount;

		public static void DebugLog(string value)
		{
			if ((bool)instance)
			{
				instance.DebugValue(value);
			}
		}

		private void DebugValue(string value)
		{
			linesCount++;
			if (linesCount > linesMaxCount)
			{
				linesCount = 0;
				text.text = "";
			}
			Text obj = text;
			obj.text = obj.text + value + "\n";
		}

		private void Awake()
		{
			if ((bool)instance)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			instance = this;
		}
	}
	public delegate void ShareWithFriendHandler(int newFriends, int allFriends);
	public class FacebookManager
	{
		private static FacebookManager _instance;

		private bool forLoginWithPublishPermissions;

		public static FacebookManager instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = new FacebookManager();
				}
				return _instance;
			}
		}

		public string mainUserId { get; private set; }

		public string[] friendsId { get; private set; }

		public bool IsInitialized => true;

		public bool IsLoggedIn => DataManager.GetIntData("LogInImitate") == 1;

		public bool IsLoggedInWithPublishPermissions => false;

		public event Action OnInitialized;

		public event Action<LoginedState> OnLoggedIn;

		public event Action OnUpdatedFriendsList;

		public static event ShareWithFriendHandler OnShareWithFriend;

		public void Init()
		{
			this.OnInitialized();
		}

		public void LoginWithPublishPermissions()
		{
		}

		public void Login()
		{
			this.OnLoggedIn(LoginedState.Successful);
			DataManager.SetIntData("LogInImitate", 1);
		}

		public void ShareLink()
		{
			AppRequest();
		}

		private void AppRequest()
		{
			int num = UnityEngine.Random.Range(0, 10);
			FacebookManager.OnShareWithFriend(UnityEngine.Random.Range(0, num), num);
		}

		public void Activate()
		{
		}

		public void UpdateFriendsList()
		{
			if (this.OnUpdatedFriendsList != null)
			{
				this.OnUpdatedFriendsList();
			}
		}
	}
	public abstract class SocialEngine
	{
		public bool friendsListIsUpdated { get; protected set; }

		public string mainPlayerId { get; protected set; }

		public int minCoinsCount => 0;

		public int minOnLinePrize => 0;

		public event LoginHandler OnSignUp;

		public event LoginHandler OnLogin;

		public event LoginHandler OnLoginWithFacebok;

		public event Action OnFacebokInitialized;

		public SocialEngine()
		{
			mainPlayerId = "0";
		}

		public abstract void ShareOnFacebook();

		public abstract void ShareOnTwitter();

		public abstract void ShareOnGoogle();

		public abstract void ShareByEmail();

		public virtual void Disable()
		{
			this.OnSignUp = null;
			this.OnLogin = null;
			this.OnLoginWithFacebok = null;
		}

		protected void CallSignUpEvent(LoginedState state)
		{
			LoginManager.logined = state == LoginedState.Successful;
			if (this.OnSignUp != null)
			{
				this.OnSignUp(state);
			}
		}

		protected void CallLoginEvent(LoginedState state)
		{
			LoginManager.logined = state == LoginedState.Successful;
			if (this.OnLogin != null)
			{
				this.OnLogin(state);
			}
		}

		protected void CallLoginWithFacebokEvent(LoginedState state)
		{
			if (this.OnLoginWithFacebok != null)
			{
				this.OnLoginWithFacebok(state);
			}
		}

		protected void CallFacebokInitialized()
		{
			if (this.OnFacebokInitialized != null)
			{
				this.OnFacebokInitialized();
			}
		}

		public abstract void SignUp(string email, string password);

		public abstract void Login(string email, string password);

		public abstract void LoginWithFacebok();

		public abstract void SaveMainPlayerName(string playerName);

		public abstract string GetMainPlayerName();

		public abstract void SaveMainPlayerCoins(int playerCoins);

		public abstract int GetMainPlayerCoins();

		public abstract void SaveMainPlayerPrize(int prize);

		public abstract int GetMainPlayerPrize();

		public abstract void SaveAvatarURL(string url);

		public abstract string GetAvatarURL();

		public abstract string GetMainPlayerEmail();

		public abstract string GetPrivacyPolicyURL();

		public abstract string[] GetFriendsId();

		public abstract void UpdateFriendsList();

		public abstract bool AvatarDataIsLocal();

		public abstract void SetAvatarDataIsLocal(bool isLocal);

		public abstract void CallOnApplicationPause(bool pauseStatus);

		public abstract bool IsLoggedIn();

		public abstract bool IsLoggedInWithPublishPermissions();
	}
	public abstract class ContentListManager : MonoBehaviour
	{
		[SerializeField]
		protected Button contentButton;

		[SerializeField]
		protected float buttonsVerticalDistance = 20f;

		[SerializeField]
		protected float buttonsHorizontalDistance = 30f;

		private List<Button> buttons;

		public Button GetCurrentButton(int number)
		{
			Button button = UnityEngine.Object.Instantiate(contentButton);
			RectTransform component = contentButton.GetComponent<RectTransform>();
			RectTransform component2 = button.GetComponent<RectTransform>();
			component2.SetParent(contentButton.transform.parent);
			component2.localPosition = component.localPosition - (float)number * (component.sizeDelta.y + buttonsVerticalDistance) * Vector3.up;
			component2.localScale = Vector3.one;
			button.gameObject.SetActive(value: true);
			return button;
		}

		public void ResetOldButtons(bool hideContentButton = true)
		{
			if (hideContentButton)
			{
				contentButton.gameObject.SetActive(value: false);
			}
			if (buttons != null)
			{
				foreach (Button button in buttons)
				{
					UnityEngine.Object.Destroy(button.gameObject);
				}
			}
			buttons = new List<Button>(0);
		}

		public void AddButton(Button button)
		{
			buttons.Add(button);
		}
	}
	public class LoginMenuManager : MonoBehaviour
	{
		[SerializeField]
		private RectTransform loginPanel;

		[SerializeField]
		private InputField email;

		[SerializeField]
		private InputField password;

		[SerializeField]
		private Toggle saveEmail;

		private void OnEnable()
		{
			NetworkManager.social.OnSignUp += NetworkManage_OnLogin;
			NetworkManager.social.OnLogin += NetworkManage_OnLogin;
			NetworkManager.social.OnLoginWithFacebok += NetworkManager_OnLoginWithFacebok;
			CloseLoginWindow();
			saveEmail.isOn = DataManager.GetIntData("SaveEmail") == 1;
			if (saveEmail.isOn && LoginManager.logined)
			{
				email.text = DataManager.GetString("PlayerEmail");
				password.text = DataManager.GetString("PlayerPassword");
				password.text = string.Format("Password", DataManager.GetString("PlayerPassword"));
				Login();
			}
			saveEmail.isOn = true;
		}

		private void NetworkManager_OnLoginWithFacebok(LoginedState state)
		{
			if (state == LoginedState.Successful)
			{
				CloseLoginWindow();
				StartCoroutine(NetworkManager.LoadMainPlayer(null));
			}
		}

		private void NetworkManage_OnLogin(LoginedState state)
		{
			if (state == LoginedState.Successful)
			{
				if (saveEmail.isOn)
				{
					SaveLogin();
				}
				CloseLoginWindow();
				StartCoroutine(NetworkManager.LoadMainPlayer(null));
			}
		}

		private void SaveLogin()
		{
			DataManager.SetIntData("SaveEmail", 1);
			DataManager.SetString("PlayerEmail", email.text);
			DataManager.SetString("PlayerPassword", password.text);
		}

		public void OpenLoginWindow()
		{
			loginPanel.gameObject.SetActive(value: true);
		}

		public void CloseLoginWindow()
		{
			loginPanel.gameObject.SetActive(value: false);
		}

		public void SignUp()
		{
			NetworkManager.SignUp(email.text, password.text);
		}

		public void Login()
		{
			NetworkManager.Login(email.text, password.text);
		}

		public void LoginWithFacebook()
		{
			NetworkManager.LoginWithFacebook();
		}

		public void OpenPrivacyPolicyURL()
		{
			UnityEngine.Application.OpenURL(NetworkManager.privacyPolicyURL);
		}
	}
	public class Pointer : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
	{
		private float downTime;

		private bool down;

		public event SelecButtonHandler OnSelecButton;

		private void Awake()
		{
			if (!UnityEngine.Application.isMobilePlatform)
			{
				UnityEngine.Object.Destroy(this);
				return;
			}
			down = false;
			downTime = 0f;
		}

		private void Update()
		{
			if (down && Input.GetMouseButton(0))
			{
				downTime += Time.deltaTime;
				if (downTime > 0.2f)
				{
					down = false;
				}
			}
			if (Input.GetMouseButtonUp(0) && down)
			{
				if (this.OnSelecButton != null)
				{
					this.OnSelecButton(this);
				}
				down = false;
			}
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			down = true;
			downTime = 0f;
		}
	}
	public delegate void SelecRoomHandler(Room room);
	public delegate void SelecPlayerHandler(PlayerProfile player);
	public class RoomsListManager : ContentListManager
	{
		public static event SelecPlayerHandler OnSelecPlayerProfile;

		public static event SelecRoomHandler OnSelecRoom;

		public void UpdateRooms(Room[] rooms)
		{
			ResetOldButtons();
			if (rooms == null || rooms.Length == 0)
			{
				return;
			}
			for (int i = 0; i < rooms.Length; i++)
			{
				Button currentButton = GetCurrentButton(i);
				PlayerProfileUI componentInChildren = currentButton.GetComponentInChildren<PlayerProfileUI>();
				RectTransform component = componentInChildren.GetComponent<RectTransform>();
				componentInChildren.gameObject.SetActive(value: false);
				Room currentRoom = rooms[i];
				for (int j = 0; j < rooms[i].players.Count; j++)
				{
					PlayerProfileUI playerProfileUI = UnityEngine.Object.Instantiate(componentInChildren);
					RectTransform component2 = playerProfileUI.GetComponent<RectTransform>();
					component2.SetParent(componentInChildren.transform.parent);
					component2.localPosition = component.localPosition + (float)j * (component.sizeDelta.x + buttonsHorizontalDistance) * Vector3.right;
					component2.localScale = Vector3.one;
					PlayerProfile player = currentRoom.players[j];
					playerProfileUI.SetPlayer(player);
					playerProfileUI.gameObject.SetActive(value: true);
				}
				Pointer component3 = currentButton.GetComponent<Pointer>();
				if ((bool)component3 && UnityEngine.Application.isMobilePlatform)
				{
					component3.OnSelecButton += delegate
					{
						if (RoomsListManager.OnSelecRoom != null)
						{
							RoomsListManager.OnSelecRoom(currentRoom);
						}
					};
				}
				else
				{
					currentButton.onClick.AddListener(delegate
					{
						if (RoomsListManager.OnSelecRoom != null)
						{
							RoomsListManager.OnSelecRoom(currentRoom);
						}
					});
				}
				AddButton(currentButton);
				currentButton.transform.localEulerAngles = Vector3.zero;
			}
		}

		public void UpdatePlayers(PlayerProfile[] players)
		{
			ResetOldButtons();
			if (players == null || players.Length == 0)
			{
				return;
			}
			for (int i = 0; i < players.Length; i++)
			{
				Button currentButton = GetCurrentButton(i);
				PlayerProfileUI component = currentButton.GetComponent<PlayerProfileUI>();
				PlayerProfile currentPlayer = players[i];
				component.SetPlayer(currentPlayer);
				currentButton.onClick.AddListener(delegate
				{
					if (RoomsListManager.OnSelecPlayerProfile != null)
					{
						RoomsListManager.OnSelecPlayerProfile(currentPlayer);
					}
				});
				AddButton(currentButton);
			}
		}
	}
	public class ScrollRectMobileSetter : MonoBehaviour
	{
		private void Start()
		{
			if (UnityEngine.Application.isMobilePlatform)
			{
				GetComponent<ScrollRect>().inertia = false;
			}
		}
	}
}
namespace BallPool
{
	public class AightBallPoolBallsSortingManager : MonoBehaviour, BallPoolBallsSortingManager
	{
		[SerializeField]
		private Transform balls;

		[SerializeField]
		private Transform BallsListener;

		[SerializeField]
		private PhysicsManager physicsManager;

		[SerializeField]
		private float ballsDistance;

		[SerializeField]
		private Transform cueBallPosition;

		[SerializeField]
		private Transform pyramidFirstBallPosition;

		[SerializeField]
		private GameManager gameManager;

		public void SortBalls()
		{
			UnityEngine.Debug.Log("Balls sorted by AightBallPoolBallsSortingManager");
			Vector2[] array = new Vector2[16]
			{
				new Vector2(0f, 0f),
				new Vector2(4f, 4f),
				new Vector2(1f, -1f),
				new Vector2(2f, 2f),
				new Vector2(3f, -3f),
				new Vector2(3f, 1f),
				new Vector2(4f, -4f),
				new Vector2(4f, 0f),
				new Vector2(2f, 0f),
				new Vector2(1f, 1f),
				new Vector2(2f, -2f),
				new Vector2(3f, -1f),
				new Vector2(3f, 3f),
				new Vector2(4f, -2f),
				new Vector2(4f, 2f),
				new Vector2(0f, 0f)
			};
			gameManager.balls = new Ball[balls.childCount];
			physicsManager.ballsListener = new BallListener[balls.childCount];
			for (int i = 0; i < balls.childCount; i++)
			{
				Ball component = balls.GetChild(i).GetComponent<Ball>();
				BallListener component2 = BallsListener.GetChild(i).GetComponent<BallListener>();
				component2.body = component2.GetComponent<Rigidbody>();
				component.listener = component2;
				float num = component2.GetComponent<SphereCollider>().radius + ballsDistance;
				Vector3 position = cueBallPosition.position;
				if (i != 0)
				{
					position = pyramidFirstBallPosition.position + new Vector3(array[i].x * Mathf.Sqrt(Mathf.Pow(2f * num, 2f) - Mathf.Pow(num, 2f)), 0f, array[i].y * num);
				}
				component.id = i;
				component.transform.position = position;
				component2.transform.position = position;
				component2.id = component.id;
				component2.physicsManager = physicsManager;
				string text2 = (component2.name = "Ball_" + i);
				component.name = text2;
				gameManager.balls[i] = component;
				physicsManager.ballsListener[i] = component2;
			}
		}
	}
	public class AightBallPoolGameState : GameState
	{
		public bool tableIsOpened = true;

		public bool playersHasBallType;

		public int ballsHitBoardCount;

		public bool cueBallHasHitRightBall;

		public bool cueBallHasHitSomeBall;

		public bool hasRightBallInPocket;

		public bool cueBallInHand = true;

		public bool cueBallInPocket;

		public bool cueBallMoved;

		public int BankShotStack;

		public bool HatTrickReported;

		public int HatTrickStack;

		public List<int> BankShotContactBallIds;

		public List<int> PocketedBallIds;

		public AightBallPoolGameState()
		{
			tableIsOpened = true;
			playersHasBallType = false;
			ballsHitBoardCount = 0;
			cueBallHasHitRightBall = false;
			cueBallHasHitSomeBall = false;
			hasRightBallInPocket = false;
			cueBallInHand = false;
			cueBallInPocket = false;
			cueBallMoved = false;
			BankShotStack = 0;
			BankShotContactBallIds = new List<int>();
			PocketedBallIds = new List<int>();
			HatTrickReported = false;
			HatTrickStack = 0;
		}
	}
	public class AightBallPoolGameLogic : BallPoolGameLogic
	{
		public enum FoulType
		{
			None = 0,
			Scratch = 1,
			BadHit = 2,
			NoHit = 3,
			WeakBreak = 4,
			NoRail = 4,
			OutOfTable = 5
		}

		private static AightBallPoolGameState _gameState;

		public static AightBallPoolGameState gameState
		{
			get
			{
				if (_gameState == null)
				{
					_gameState = new AightBallPoolGameState();
				}
				return _gameState;
			}
		}

		public static bool isFoulCalled { get; private set; }

		public static event Action<FoulType, (BallListener, PocketListener), float> OnFoulWithDelay;

		public static event Action<FoulType, (BallListener, PocketListener)> OnFoul;

		public AightBallPoolGameLogic()
		{
			OnFoul += SetFoulCalled;
			static void SetFoulCalled(FoulType type, (BallListener, PocketListener) info)
			{
				if (BallPoolGameLogic.playMode == PlayMode.OnLine && !isFoulCalled && BallPoolPlayer.mainPlayer.myTurn)
				{
					int num = ((info.Item1 == null) ? (-1) : info.Item1.id);
					int num2 = ((info.Item2 == null) ? (-1) : info.Item2.id);
					NetworkManager.network.SendRemoteMessage("SendFoulInfo", (int)type, num, num2);
				}
				isFoulCalled = true;
			}
		}

		public static void SetFoulFormNetwork(int foulType, int ballId, int pocketId)
		{
			BallListener item = null;
			PocketListener item2 = null;
			if (ballId != -1)
			{
				item = BallPoolGameManager.instance.balls[ballId].listener;
			}
			if (pocketId != -1)
			{
				item2 = BallPoolGameManager.instance.physicsManager.pocketListeners[pocketId];
			}
			if ((uint)(foulType - 1) <= 1u)
			{
				AightBallPoolGameLogic.OnFoulWithDelay?.Invoke((FoulType)foulType, (item, item2), 1f);
			}
			else
			{
				AightBallPoolGameLogic.OnFoul?.Invoke((FoulType)foulType, (item, item2));
			}
		}

		public void ResetState()
		{
			gameState.gameIsComplete = false;
			gameState.needToChangeTurn = false;
			gameState.cueBallHasHitRightBall = false;
			gameState.cueBallHasHitSomeBall = false;
			gameState.hasRightBallInPocket = false;
			gameState.ballsHitBoardCount = 0;
			gameState.cueBallInHand = false;
			gameState.cueBallInPocket = false;
			gameState.cueBallMoved = false;
			AightBallPoolPlayer.mainPlayer.isCueBall = false;
			AightBallPoolPlayer.otherPlayer.isCueBall = false;
			isFoulCalled = false;
			gameState.BankShotStack = 0;
			gameState.PocketedBallIds.Clear();
			gameState.BankShotContactBallIds.Clear();
		}

		public void CheckAchievement(int state, int ballId = -1)
		{
			if ((AightBallPoolPlayer)BallPoolPlayer.currentPlayer == AightBallPoolPlayer.otherPlayer)
			{
				return;
			}
			switch (state)
			{
			case -1:
				gameState.HatTrickReported = false;
				gameState.HatTrickStack = 0;
				break;
			case 0:
				if (!gameState.cueBallHasHitSomeBall)
				{
					gameState.BankShotStack = 1;
				}
				break;
			case 1:
				if (gameState.BankShotStack != 0)
				{
					gameState.BankShotContactBallIds.Add(ballId);
				}
				break;
			case 2:
				gameState.HatTrickStack++;
				if (gameState.HatTrickStack >= 3 && !gameState.HatTrickReported)
				{
					gameState.HatTrickReported = true;
					SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach23", 1);
				}
				if (gameState.BankShotStack != 0 && gameState.hasRightBallInPocket)
				{
					gameState.BankShotContactBallIds.Contains(ballId);
				}
				break;
			}
		}

		public void OnBallHitBoard(int ballId)
		{
			if (gameState.tableIsOpened)
			{
				gameState.ballsHitBoardCount++;
			}
			else if (isCueBall(ballId))
			{
				CheckAchievement(0);
			}
		}

		public void OnCueBallHitBall(int cueBallId, int ballId)
		{
			if (gameState.cueBallHasHitSomeBall)
			{
				return;
			}
			gameState.cueBallHasHitSomeBall = true;
			if (isBlackBall(ballId))
			{
				if (((AightBallPoolPlayer)BallPoolPlayer.currentPlayer).isBlack)
				{
					gameState.cueBallHasHitRightBall = true;
				}
			}
			else if (gameState.tableIsOpened)
			{
				gameState.cueBallHasHitRightBall = true;
			}
			else if (!gameState.playersHasBallType)
			{
				gameState.cueBallHasHitRightBall = true;
			}
			else if (AightBallPoolPlayer.PlayerHasSomeBallType((AightBallPoolPlayer)BallPoolPlayer.currentPlayer, ballId))
			{
				gameState.cueBallHasHitRightBall = true;
			}
			if (!gameState.cueBallHasHitRightBall)
			{
				gameState.cueBallInHand = true;
				gameState.needToChangeTurn = true;
				if (!isFoulCalled)
				{
					AightBallPoolGameLogic.OnFoul?.Invoke(FoulType.BadHit, (BallPoolGameManager.instance.balls[ballId].listener, null));
				}
			}
			if (gameState.cueBallHasHitRightBall && !gameState.tableIsOpened)
			{
				CheckAchievement(1, ballId);
			}
		}

		public void OnBallInPocket(int ballId, ref bool cueBallInPocket, PocketListener pocket)
		{
			if (isCueBall(ballId))
			{
				if (AightBallPoolPlayer.mainPlayer.myTurn)
				{
					AightBallPoolPlayer.mainPlayer.isCueBall = true;
				}
				else if (AightBallPoolPlayer.otherPlayer.myTurn)
				{
					AightBallPoolPlayer.otherPlayer.isCueBall = true;
				}
				gameState.needToChangeTurn = true;
				gameState.cueBallInHand = true;
				cueBallInPocket = true;
				gameState.cueBallInPocket = true;
				if (!isFoulCalled)
				{
					AightBallPoolGameLogic.OnFoul?.Invoke(FoulType.Scratch, (null, pocket));
				}
			}
			else if (gameState.tableIsOpened)
			{
				if (!isBlackBall(ballId))
				{
					gameState.hasRightBallInPocket = true;
				}
				gameState.PocketedBallIds.Add(ballId);
			}
			else if (!gameState.playersHasBallType)
			{
				gameState.playersHasBallType = true;
				if (!isBlackBall(ballId))
				{
					gameState.hasRightBallInPocket = true;
				}
				if (AightBallPoolPlayer.mainPlayer.myTurn)
				{
					if (isStripesBall(ballId))
					{
						AightBallPoolPlayer.mainPlayer.isStripes = true;
						AightBallPoolPlayer.otherPlayer.isSolids = true;
					}
					else if (isSolidsBall(ballId))
					{
						AightBallPoolPlayer.mainPlayer.isSolids = true;
						AightBallPoolPlayer.otherPlayer.isStripes = true;
					}
				}
				else if (AightBallPoolPlayer.otherPlayer.myTurn)
				{
					if (isStripesBall(ballId))
					{
						AightBallPoolPlayer.otherPlayer.isStripes = true;
						AightBallPoolPlayer.mainPlayer.isSolids = true;
					}
					else if (isSolidsBall(ballId))
					{
						AightBallPoolPlayer.otherPlayer.isSolids = true;
						AightBallPoolPlayer.mainPlayer.isStripes = true;
					}
				}
			}
			else if (AightBallPoolPlayer.PlayerHasSomeBallType((AightBallPoolPlayer)BallPoolPlayer.currentPlayer, ballId))
			{
				gameState.hasRightBallInPocket = true;
				Billiards.SoundManager.PlayCheerSound();
				CheckAchievement(2, ballId);
			}
		}

		public void OnEndShot(bool blackBallInPocket, out bool gameIsEnd)
		{
			gameIsEnd = false;
			if (BallPoolGameManager.instance == null)
			{
				return;
			}
			string text = "";
			bool flag = true;
			if (gameState.cueBallInPocket && !blackBallInPocket)
			{
				text = ((!BallPoolPlayer.mainPlayer.myTurn) ? (AightBallPoolPlayer.otherPlayer.name + " pocket the cue ball, \n You have cue ball in hand") : ("You pocket the cue ball, \n" + AightBallPoolPlayer.otherPlayer.name + " has cue ball in hand"));
				BallPoolGameManager.instance.SetGameInfo(text);
				flag = false;
			}
			if (gameState.tableIsOpened)
			{
				text = " ";
				if (gameState.cueBallHasHitRightBall && gameState.hasRightBallInPocket)
				{
					gameState.playersHasBallType = true;
					int num = 0;
					int num2 = 0;
					Ball[] balls = BallPoolGameManager.instance.balls;
					foreach (Ball ball in balls)
					{
						if (!ball.inPocket)
						{
							if (isStripesBall(ball.id))
							{
								num++;
							}
							else if (isSolidsBall(ball.id))
							{
								num2++;
							}
						}
					}
					if (AightBallPoolPlayer.mainPlayer.myTurn)
					{
						if (num < num2)
						{
							AightBallPoolPlayer.mainPlayer.isStripes = true;
							AightBallPoolPlayer.otherPlayer.isSolids = true;
						}
						else if (num > num2)
						{
							AightBallPoolPlayer.mainPlayer.isSolids = true;
							AightBallPoolPlayer.otherPlayer.isStripes = true;
						}
						else if (num == num2 && gameState.PocketedBallIds.Count > 0)
						{
							int id = gameState.PocketedBallIds[0];
							if (isSolidsBall(id))
							{
								AightBallPoolPlayer.mainPlayer.isSolids = true;
								AightBallPoolPlayer.otherPlayer.isStripes = true;
							}
							else if (isStripesBall(id))
							{
								AightBallPoolPlayer.mainPlayer.isStripes = true;
								AightBallPoolPlayer.otherPlayer.isSolids = true;
							}
						}
					}
					else if (AightBallPoolPlayer.otherPlayer.myTurn)
					{
						if (num < num2)
						{
							AightBallPoolPlayer.otherPlayer.isStripes = true;
							AightBallPoolPlayer.mainPlayer.isSolids = true;
						}
						else if (num > num2)
						{
							AightBallPoolPlayer.otherPlayer.isSolids = true;
							AightBallPoolPlayer.mainPlayer.isStripes = true;
						}
						else if (num == num2 && gameState.PocketedBallIds.Count > 0)
						{
							int id2 = gameState.PocketedBallIds[0];
							if (isSolidsBall(id2))
							{
								AightBallPoolPlayer.otherPlayer.isSolids = true;
								AightBallPoolPlayer.mainPlayer.isStripes = true;
							}
							else if (isStripesBall(id2))
							{
								AightBallPoolPlayer.otherPlayer.isStripes = true;
								AightBallPoolPlayer.mainPlayer.isSolids = true;
							}
						}
					}
					(BallPoolGameManager.instance as AightBallPoolGameManager).UpdateActiveBalls();
				}
				else
				{
					gameState.needToChangeTurn = true;
					if (gameState.ballsHitBoardCount < 4)
					{
						gameState.cueBallInHand = true;
						if (!isFoulCalled)
						{
							AightBallPoolGameLogic.OnFoul?.Invoke(FoulType.WeakBreak, (BallPoolGameManager.instance.balls[8].listener, null));
						}
						text = "Break up of balls was weak, \n" + (BallPoolPlayer.mainPlayer.myTurn ? (AightBallPoolPlayer.otherPlayer.name + " has cue ball in hand") : "You have cue ball in hand");
					}
				}
			}
			gameState.tableIsOpened = false;
			if (blackBallInPocket)
			{
				if (AightBallPoolPlayer.mainPlayer.myTurn)
				{
					AightBallPoolPlayer.mainPlayer.isWinner = AightBallPoolPlayer.mainPlayer.isBlack && !AightBallPoolPlayer.mainPlayer.isCueBall;
					AightBallPoolPlayer.otherPlayer.isWinner = !AightBallPoolPlayer.mainPlayer.isWinner;
					text = (AightBallPoolPlayer.otherPlayer.isWinner ? ("You poked the black ball " + (AightBallPoolPlayer.mainPlayer.isCueBall ? "with cue ball" : "")) : "");
				}
				else if (AightBallPoolPlayer.otherPlayer.myTurn)
				{
					AightBallPoolPlayer.otherPlayer.isWinner = AightBallPoolPlayer.otherPlayer.isBlack && !AightBallPoolPlayer.otherPlayer.isCueBall;
					AightBallPoolPlayer.mainPlayer.isWinner = !AightBallPoolPlayer.otherPlayer.isWinner;
					text = (AightBallPoolPlayer.mainPlayer.isWinner ? (AightBallPoolPlayer.otherPlayer.name + " pocket the black ball " + (AightBallPoolPlayer.otherPlayer.isCueBall ? "with cue ball" : "")) : "");
				}
				gameState.needToChangeTurn = false;
				gameIsEnd = true;
				BallPoolGameManager.instance.SetGameInfo(text);
				return;
			}
			if (AightBallPoolPlayer.mainPlayer.checkIsBlackInEnd)
			{
				AightBallPoolPlayer.mainPlayer.isBlack = true;
			}
			if (AightBallPoolPlayer.otherPlayer.checkIsBlackInEnd)
			{
				AightBallPoolPlayer.otherPlayer.isBlack = true;
			}
			if (!gameState.cueBallHasHitRightBall)
			{
				gameState.cueBallInHand = true;
				gameState.needToChangeTurn = true;
				if (!isFoulCalled)
				{
					AightBallPoolGameLogic.OnFoul?.Invoke(FoulType.NoHit, (BallPoolGameManager.instance.balls[0].listener, null));
				}
				if (AightBallPoolPlayer.mainPlayer.myTurn)
				{
					if (text == "")
					{
						text = (AightBallPoolPlayer.mainPlayer.isBlack ? "You need to hit black ball" : ((AightBallPoolPlayer.mainPlayer.isSolids ? "You need to hit solids ball" : (AightBallPoolPlayer.mainPlayer.isStripes ? "You need to hit stripes ball" : "You need to hit solids or stripes ball")) + "\n" + AightBallPoolPlayer.otherPlayer.name + " has cue ball in hand"));
					}
				}
				else if (text == "")
				{
					text = AightBallPoolPlayer.otherPlayer.name + (AightBallPoolPlayer.otherPlayer.isBlack ? " need to hit black ball" : (AightBallPoolPlayer.otherPlayer.isSolids ? " need to hit solids ball" : (AightBallPoolPlayer.otherPlayer.isStripes ? " need to hit stripes ball" : " need to hit solids or stripes ball"))) + ", \nYou have cue ball in hand";
				}
			}
			else if (!gameState.hasRightBallInPocket)
			{
				gameState.needToChangeTurn = true;
				if (AightBallPoolPlayer.mainPlayer.myTurn)
				{
					if (text == "")
					{
						text = (AightBallPoolPlayer.mainPlayer.isBlack ? "You need to pocket solids ball" : (AightBallPoolPlayer.mainPlayer.isSolids ? "You need to pocket solids ball" : (AightBallPoolPlayer.mainPlayer.isStripes ? "You need to pocket stripes ball" : "You need to pocket solids or stripes ball")));
					}
				}
				else if (text == "")
				{
					text = AightBallPoolPlayer.otherPlayer.name + (AightBallPoolPlayer.otherPlayer.isBlack ? " need to pocket black ball" : (AightBallPoolPlayer.otherPlayer.isSolids ? " need to pocket solids ball" : (AightBallPoolPlayer.otherPlayer.isStripes ? " need to pocket stripes ball" : " need to pocket solids or stripes ball")));
				}
			}
			if (flag)
			{
				BallPoolGameManager.instance.SetGameInfo(text);
			}
		}

		public override void OnEndTime()
		{
			UnityEngine.Debug.Log("OnEndPlayTime");
			gameState.cueBallInHand = true;
			string gameInfo = (AightBallPoolPlayer.mainPlayer.myTurn ? ("You run out of time\n" + AightBallPoolPlayer.otherPlayer.name + " has cue ball in hand") : (AightBallPoolPlayer.otherPlayer.name + " run out of time, \nYou have cue ball in hand "));
			BallPoolGameManager.instance.SetGameInfo(gameInfo);
		}

		public override void Deactivate()
		{
			base.Deactivate();
			AightBallPoolGameLogic.OnFoul = null;
			_gameState = null;
		}

		public static Ball GetCueBall(Ball[] balls)
		{
			foreach (Ball ball in balls)
			{
				if (isCueBall(ball.id))
				{
					return ball;
				}
			}
			return null;
		}

		public static bool ballInPocket(Ball ball)
		{
			return ball.inPocket;
		}

		public static Ball GetBlackBall(Ball[] balls)
		{
			foreach (Ball ball in balls)
			{
				if (isBlackBall(ball.id))
				{
					return ball;
				}
			}
			return null;
		}

		public static bool isCueBall(int id)
		{
			return id == 0;
		}

		public static bool isBlackBall(int id)
		{
			return id == 8;
		}

		public static bool isStripesBall(int id)
		{
			if (id > 8)
			{
				return id < 16;
			}
			return false;
		}

		public static bool isSolidsBall(int id)
		{
			if (id > 0)
			{
				return id < 8;
			}
			return false;
		}
	}
	public class AightBallPoolGameManager : BallPoolGameManager
	{
		private bool onBallHitPocket;

		private bool playAgainMenuIsActive;

		private ShotController _shotController;

		public AightBallPoolGameLogic gameLogic { get; set; }

		public ShotController shotController
		{
			get
			{
				if (_shotController == null)
				{
					_shotController = UnityEngine.Object.FindObjectOfType<ShotController>();
				}
				return _shotController;
			}
		}

		public void Start()
		{
			playAgainMenuIsActive = false;
			base.physicsManager.OnBallHitBall += PhysicsManager_OnBallHitBall;
			base.physicsManager.OnBallHitBoard += PhysicsManager_OnBallHitBoard;
			base.physicsManager.OnBallHitPocket += PhysicsManager_OnBallHitPocket;
			BallPoolPlayer.OnTurnChanged += Player_OnTurnChanged;
			if (!BallPoolGameLogic.isOnLine)
			{
				if (BallPoolGameLogic.playMode == PlayMode.Solo)
				{
					BallPoolPlayer.turnId = 0;
				}
				else
				{
					BallPoolPlayer.turnId = 0;
				}
			}
			BallPoolPlayer.SetTurn(BallPoolPlayer.turnId);
			UpdateActiveBalls();
			CallOnSetPlayer(AightBallPoolPlayer.mainPlayer);
			CallOnSetPlayer(AightBallPoolPlayer.otherPlayer);
			CallOnSetAvatar(AightBallPoolPlayer.mainPlayer);
			CallOnSetAvatar(AightBallPoolPlayer.otherPlayer);
		}

		public void Update(float deltaTime)
		{
			if (onBallHitPocket)
			{
				onBallHitPocket = false;
				UpdateActiveBalls();
			}
			CallOnUpdateTime(deltaTime);
		}

		public override void OnDisable()
		{
			base.OnDisable();
			BallPoolPlayer.Deactivate();
			BallPoolGameLogic.instance.Deactivate();
		}

		private void OpenPlayAgainMenu()
		{
			AightBallPoolGameLogic.gameState.gameIsComplete = true;
			playAgainMenuIsActive = true;
			CallOnGameComplite();
			if (!NetworkManager.mainPlayer.canPlayOffline || (BallPoolGameLogic.isOnLine && !NetworkManager.mainPlayer.canPlayOnLine))
			{
				base.playAgainMenu.HidePlayAgainButton();
			}
		}

		public void UpdateActiveBalls()
		{
			AightBallPoolPlayer.mainPlayer.SetActiveBalls(base.balls);
			AightBallPoolPlayer.otherPlayer.SetActiveBalls(base.balls);
			CallOnSetActiveBallsIds(AightBallPoolPlayer.mainPlayer);
			CallOnSetActiveBallsIds(AightBallPoolPlayer.otherPlayer);
		}

		public override void OnStartShot(string data)
		{
			base.OnStartShot(data);
			gameLogic.ResetState();
		}

		public override void OnEndShot(string data)
		{
			base.OnEndShot(data);
			gameLogic.OnEndShot(AightBallPoolGameLogic.GetBlackBall(base.balls).inPocket, out var gameIsEnd);
			if (gameIsEnd)
			{
				OpenPlayAgainMenu();
			}
			else if (!playAgainMenuIsActive)
			{
				CallOnEndShot();
				if (AightBallPoolGameLogic.gameState.needToChangeTurn)
				{
					BallPoolPlayer.ChangeTurn();
					gameLogic.CheckAchievement(-1);
				}
				if (BallPoolGameLogic.playMode == PlayMode.PlayerAI && AightBallPoolPlayer.otherPlayer.myTurn)
				{
					CallOnCalculateAI();
				}
			}
		}

		private void PhysicsManager_OnBallHitBall(BallListener ball, BallListener hitBall, bool inMove)
		{
			if (inMove)
			{
				if (shotController.tragetBallListener == hitBall)
				{
					hitBall.body.velocity = hitBall.body.velocity.magnitude * shotController.targetBallSavedDirection;
					shotController.tragetBallListener = null;
				}
				base.balls[ball.id].OnState(BallState.HitBall);
				if (AightBallPoolGameLogic.isCueBall(ball.id))
				{
					gameLogic.OnCueBallHitBall(ball.id, hitBall.id);
				}
			}
		}

		private void PhysicsManager_OnBallHitBoard(BallListener ball, bool inMove)
		{
			if (inMove)
			{
				base.balls[ball.id].OnState(BallState.HitBoard);
				gameLogic.OnBallHitBoard(ball.id);
			}
		}

		private void PhysicsManager_OnBallHitPocket(BallListener ball, PocketListener pocket, bool inMove)
		{
			if (inMove)
			{
				base.balls[ball.id].OnState(BallState.EnterInPocket);
				bool cueBallInPocket = false;
				gameLogic.OnBallInPocket(ball.id, ref cueBallInPocket, pocket);
				if (!cueBallInPocket)
				{
					onBallHitPocket = true;
				}
			}
		}

		public override void OnForceGoHome(int winnerId)
		{
		}

		private void Player_OnTurnChanged()
		{
			UnityEngine.Debug.Log("Player_OnTurnChanged - Opponent State : " + Billiards.Singleton<BilliardsDataContainer>.Instance.OpponentGameState.CurrentData);
			if (!playAgainMenuIsActive)
			{
				CallOnEnableControl(BallPoolPlayer.mainPlayer.myTurn || BallPoolGameLogic.playMode == PlayMode.HotSeat);
				CallOnSetActivePlayer(AightBallPoolPlayer.mainPlayer, BallPoolPlayer.turnId == AightBallPoolPlayer.mainPlayer.playerId);
				CallOnSetActivePlayer(AightBallPoolPlayer.otherPlayer, BallPoolPlayer.turnId == AightBallPoolPlayer.otherPlayer.playerId);
				if (BallPoolGameLogic.playMode == PlayMode.PlayerAI && AightBallPoolPlayer.otherPlayer.myTurn)
				{
					CallOnCalculateAI();
				}
			}
		}
	}
	public class AightBallPoolPlayer : BallPoolPlayer
	{
		private bool _isStripes;

		private bool _isSolids;

		public new static AightBallPoolPlayer mainPlayer
		{
			get
			{
				if (BallPoolPlayer.players != null && BallPoolPlayer.players.Length >= 1)
				{
					return (AightBallPoolPlayer)BallPoolPlayer.players[0];
				}
				return null;
			}
		}

		public static AightBallPoolPlayer otherPlayer
		{
			get
			{
				if (BallPoolPlayer.players != null && BallPoolPlayer.players.Length >= 2)
				{
					return (AightBallPoolPlayer)BallPoolPlayer.players[1];
				}
				return null;
			}
		}

		public bool checkIsBlackInEnd { get; private set; }

		public bool isBlack { get; set; }

		public bool isCueBall { get; set; }

		public bool isStripes
		{
			get
			{
				return _isStripes;
			}
			set
			{
				_isStripes = value;
				_isSolids = !_isStripes;
			}
		}

		public bool isSolids
		{
			get
			{
				return _isSolids;
			}
			set
			{
				_isSolids = value;
				_isStripes = !_isSolids;
			}
		}

		public override void OnDeactivate()
		{
			checkIsBlackInEnd = false;
			isBlack = false;
			isCueBall = false;
			_isSolids = false;
			_isStripes = false;
		}

		public override void SetActiveBalls(Ball[] balls)
		{
			if (balls == null || balls.Length == 0)
			{
				return;
			}
			base.balls = new List<Ball>(0);
			foreach (Ball ball in balls)
			{
				if (!ball.inPocket)
				{
					if (isStripes && AightBallPoolGameLogic.isStripesBall(ball.id))
					{
						base.balls.Add(ball);
					}
					else if (isSolids && AightBallPoolGameLogic.isSolidsBall(ball.id))
					{
						base.balls.Add(ball);
					}
				}
			}
			if (AightBallPoolGameLogic.gameState.playersHasBallType && base.balls.Count == 0)
			{
				Ball blackBall = AightBallPoolGameLogic.GetBlackBall(BallPoolGameManager.instance.balls);
				if (!blackBall.inPocket)
				{
					checkIsBlackInEnd = true;
					base.balls.Add(blackBall);
				}
			}
		}

		public static bool PlayerHasSomeBallType(AightBallPoolPlayer player, int ballId)
		{
			if (!player.isSolids || !AightBallPoolGameLogic.isSolidsBall(ballId))
			{
				if (player.isStripes)
				{
					return AightBallPoolGameLogic.isStripesBall(ballId);
				}
				return false;
			}
			return true;
		}

		public AightBallPoolPlayer(int playerId, string name, int coins, string uuid = "")
			: base(playerId, name, coins, uuid)
		{
			_isStripes = false;
			_isSolids = false;
			isBlack = false;
			isCueBall = false;
			checkIsBlackInEnd = false;
		}
	}
	public interface BallPoolBallsSortingManager
	{
		void SortBalls();
	}
	public enum PlayMode
	{
		PlayerAI,
		HotSeat,
		OnLine,
		Replay,
		Solo
	}
	public abstract class GameState
	{
		public bool gameIsComplete;

		public Appnori.Util.Notifier<bool> NeedToChangeTurn;

		public bool needToChangeTurn
		{
			get
			{
				return NeedToChangeTurn.CurrentData;
			}
			set
			{
				NeedToChangeTurn.CurrentData = value;
			}
		}

		public GameState()
		{
			gameIsComplete = false;
			NeedToChangeTurn = new Appnori.Util.Notifier<bool>();
			needToChangeTurn = false;
			NeedToChangeTurn.OnDataChanged += NeedToChangeTurn_OnDataChanged;
		}

		private void NeedToChangeTurn_OnDataChanged(bool obj)
		{
			UnityEngine.Debug.Log("NeedToChangeTurn modified : " + obj);
		}
	}
	public class BallPoolGameLogic
	{
		public static PlayMode playMode;

		public static BallPoolGameLogic instance { get; private set; }

		public static bool isOnLine
		{
			get
			{
				if (playMode == PlayMode.OnLine)
				{
					return instance != null;
				}
				return false;
			}
		}

		public static bool controlFromNetwork
		{
			get
			{
				if (playMode == PlayMode.OnLine && !BallPoolPlayer.mainPlayer.myTurn)
				{
					return instance != null;
				}
				return false;
			}
		}

		public static bool controlInNetwork
		{
			get
			{
				if (playMode == PlayMode.OnLine && BallPoolPlayer.mainPlayer.myTurn)
				{
					return instance != null;
				}
				return false;
			}
		}

		public BallPoolGameLogic()
		{
			instance = this;
		}

		public virtual void OnEndTime()
		{
		}

		public virtual void Deactivate()
		{
			instance = null;
		}
	}
	public class BallPoolGameManager
	{
		public PlayAgainMenu _playAgainMenu;

		public PlayAgainMenu playAgainMenu
		{
			get
			{
				if (!_playAgainMenu)
				{
					_playAgainMenu = UnityEngine.Object.FindObjectOfType<PlayAgainMenu>();
				}
				return _playAgainMenu;
			}
		}

		public Ball[] balls { get; private set; }

		public static BallPoolGameManager instance { get; private set; }

		public PhysicsManager physicsManager { get; private set; }

		public BallPoolAIManager aiManager { get; private set; }

		public float maxPlayTime { get; set; }

		public float playTime { get; set; }

		public bool calculateTime { get; private set; }

		public bool gameIsComplite { get; private set; }

		public string gameInfoText { get; private set; }

		public event Action<bool> OnEnableControl;

		public event Action OnGameComplite;

		public event Action OnShotEnded;

		public event Action OnCalculateAI;

		public event Action OnShotAI;

		public event Action<BallPoolPlayer> OnSetPlayer;

		public event Action<BallPoolPlayer, bool> OnSetActivePlayer;

		public event Action<BallPoolPlayer> OnSetAvatar;

		public event Action<BallPoolPlayer> OnSetActiveBallsIds;

		public event Action<float> OnUpdateTime;

		public event Action OnStartTime;

		public event Action OnStopTime;

		public event Action OnEndTime;

		public event Action<string> OnSetGameInfo;

		public void Initialize(PhysicsManager physicsManager, BallPoolAIManager aiManager, Ball[] balls)
		{
			instance = this;
			this.balls = balls;
			this.physicsManager = physicsManager;
			this.aiManager = aiManager;
			physicsManager.OnStartShot += delegate(string data)
			{
				OnStartShot(data);
			};
			physicsManager.OnEndShot += delegate(string data)
			{
				OnEndShot(data);
			};
			physicsManager.OnBallMove += delegate(int ballId, Vector3 position, Vector3 velocity, Vector3 angularVelocity)
			{
				if (balls[ballId].inPocket)
				{
					balls[ballId].OnState(BallState.MoveInPocket);
				}
				else
				{
					balls[ballId].OnState(BallState.Move);
				}
			};
			physicsManager.OnBallSleep += delegate(int ballId, Vector3 position)
			{
				balls[ballId].OnState(BallState.EndMove);
			};
		}

		public virtual void OnStartShot(string data)
		{
			for (int i = 0; i < balls.Length; i++)
			{
				balls[i].OnState(BallState.SetState);
			}
			balls[0].OnState(BallState.StartMove);
			calculateTime = false;
			if (this.OnStopTime != null)
			{
				this.OnStopTime();
			}
		}

		public virtual void OnEndShot(string data)
		{
			calculateTime = true;
			playTime = 0f;
			if (this.OnStartTime != null)
			{
				this.OnStartTime();
			}
		}

		public virtual void OnShowHelp()
		{
			calculateTime = false;
		}

		public virtual void OnHideHelp()
		{
			calculateTime = true;
		}

		private string GetBallsMechanicalsState()
		{
			return "";
		}

		public void SetGameInfo(string info)
		{
			gameInfoText = info;
			if (this.OnSetGameInfo != null)
			{
				this.OnSetGameInfo(info);
			}
		}

		protected void CallOnEnableControl(bool value)
		{
			calculateTime = !BallPoolGameLogic.controlFromNetwork;
			playTime = 0f;
			if (this.OnStartTime != null)
			{
				this.OnStartTime();
			}
			if (this.OnEnableControl != null)
			{
				this.OnEnableControl(value && calculateTime);
			}
		}

		protected void CallOnShotAI()
		{
			if (this.OnShotAI != null)
			{
				this.OnShotAI();
			}
		}

		protected void CallOnCalculateAI()
		{
			if (!aiManager.calculateAI && this.OnCalculateAI != null)
			{
				this.OnCalculateAI();
			}
		}

		protected void CallOnEndShot()
		{
			if (this.OnShotEnded != null)
			{
				this.OnShotEnded();
			}
		}

		protected void CallOnGameComplite()
		{
			gameIsComplite = true;
			if (this.OnGameComplite != null)
			{
				this.OnGameComplite();
			}
		}

		protected void CallOnSetActivePlayer(BallPoolPlayer player, bool value)
		{
			if (this.OnSetActivePlayer != null)
			{
				this.OnSetActivePlayer(player, value);
			}
		}

		protected void CallOnSetPlayer(BallPoolPlayer player)
		{
			if (this.OnSetPlayer != null)
			{
				this.OnSetPlayer(player);
			}
		}

		protected void CallOnSetAvatar(BallPoolPlayer player)
		{
			if (this.OnSetAvatar != null)
			{
				this.OnSetAvatar(player);
			}
		}

		protected void CallOnSetActiveBallsIds(BallPoolPlayer player)
		{
			if (this.OnSetActiveBallsIds != null)
			{
				this.OnSetActiveBallsIds(player);
			}
		}

		protected void CallOnUpdateTime(float deltaTime)
		{
			if (gameIsComplite || !calculateTime)
			{
				return;
			}
			if (playTime < 1f)
			{
				playTime += deltaTime / maxPlayTime;
				if (this.OnUpdateTime != null)
				{
					this.OnUpdateTime(playTime);
				}
			}
			else
			{
				EndTime();
			}
		}

		public void SetPlayTime(float time01)
		{
			if (time01 < 1f)
			{
				playTime = time01;
				if (this.OnUpdateTime != null)
				{
					this.OnUpdateTime(playTime);
				}
			}
			else
			{
				EndTime();
			}
		}

		private void EndTime()
		{
			playTime = 1f;
			BallPoolGameLogic.instance.OnEndTime();
			if (this.OnEndTime != null)
			{
				this.OnEndTime();
			}
			if (BallPoolGameLogic.instance is AightBallPoolGameLogic)
			{
				(BallPoolGameLogic.instance as AightBallPoolGameLogic).CheckAchievement(-1);
			}
			BallPoolPlayer.ChangeTurn(isEndTime: true);
		}

		public virtual void OnForceGoHome(int winnerId)
		{
		}

		public virtual void OnDisable()
		{
			this.OnGameComplite = null;
			this.OnShotEnded = null;
			this.OnCalculateAI = null;
			this.OnShotAI = null;
			this.OnSetPlayer = null;
			this.OnSetAvatar = null;
			this.OnSetActiveBallsIds = null;
			this.OnUpdateTime = null;
			this.OnStartTime = null;
			this.OnStopTime = null;
			this.OnEndTime = null;
			this.OnSetGameInfo = null;
			physicsManager = null;
			aiManager = null;
			instance = null;
		}
	}
	public delegate void TurnChangedHandler();
	public delegate void PlayerActionHandler(BallPoolPlayer player);
	public abstract class BallPoolPlayer
	{
		public static BallPoolPlayer mainPlayer
		{
			get
			{
				if (players != null && players.Length >= 1)
				{
					return players[0];
				}
				return null;
			}
		}

		public int playerId { get; private set; }

		public string uuid { get; private set; }

		public string name { get; set; }

		public static BallPoolPlayer currentPlayer
		{
			get
			{
				BallPoolPlayer[] array = players;
				foreach (BallPoolPlayer ballPoolPlayer in array)
				{
					if (ballPoolPlayer.playerId == turnId)
					{
						return ballPoolPlayer;
					}
				}
				return null;
			}
		}

		public List<Ball> balls { get; protected set; }

		public static int playersCount { get; set; }

		public static BallPoolPlayer[] players { get; set; }

		public static int turnId { get; set; }

		public bool isWinner { get; set; }

		public bool myTurn { get; private set; }

		public static bool initialized => players != null;

		public static event TurnChangedHandler OnTurnChanged;

		public static event PlayerActionHandler OnPlayerInitialized;

		public static BallPoolPlayer GetWinner()
		{
			BallPoolPlayer[] array = players;
			foreach (BallPoolPlayer ballPoolPlayer in array)
			{
				if (ballPoolPlayer.isWinner)
				{
					return ballPoolPlayer;
				}
			}
			return null;
		}

		public static void SetWinner(int playerId)
		{
			BallPoolPlayer[] array = players;
			foreach (BallPoolPlayer obj in array)
			{
				obj.isWinner = obj.playerId == playerId;
			}
		}

		public static void Deactivate()
		{
			BallPoolPlayer.OnPlayerInitialized = null;
			BallPoolPlayer.OnTurnChanged = null;
			if (players != null)
			{
				BallPoolPlayer[] array = players;
				foreach (BallPoolPlayer obj in array)
				{
					obj.OnDeactivate();
					obj.isWinner = false;
					obj.myTurn = false;
					obj.balls = null;
				}
			}
		}

		public static void ChangeTurn(bool isEndTime = false)
		{
			UnityEngine.Debug.Log("ChangeTurn " + turnId);
			if (BallPoolGameLogic.playMode == PlayMode.OnLine && !mainPlayer.myTurn && Billiards.Singleton<BilliardsDataContainer>.Instance.OpponentGameState.CurrentData != ShotController.GameStateType.MoveAroundTable)
			{
				if (isEndTime)
				{
					UnityEngine.Debug.Log($"Player's turn is unclear. opponent gamestate is {Billiards.Singleton<BilliardsDataContainer>.Instance.OpponentGameState.CurrentData}, endTime is {isEndTime}");
				}
				else
				{
					UnityEngine.Debug.LogError($"Player's turn is unclear. opponent gamestate is {Billiards.Singleton<BilliardsDataContainer>.Instance.OpponentGameState.CurrentData}, endTime is {isEndTime}");
				}
				if (!isEndTime)
				{
					return;
				}
			}
			if (BallPoolGameLogic.playMode == PlayMode.Solo)
			{
				turnId = 0;
			}
			else if (turnId < players.Length - 1)
			{
				turnId++;
			}
			else
			{
				turnId = 0;
			}
			for (int i = 0; i < players.Length; i++)
			{
				players[i].myTurn = turnId == i;
			}
			if (BallPoolPlayer.OnTurnChanged != null)
			{
				BallPoolPlayer.OnTurnChanged();
			}
		}

		public static void SetTurn(int turnId)
		{
			BallPoolPlayer.turnId = turnId;
			for (int i = 0; i < players.Length; i++)
			{
				players[i].myTurn = turnId == i;
			}
			if (BallPoolPlayer.OnTurnChanged != null)
			{
				BallPoolPlayer.OnTurnChanged();
			}
		}

		public string[] GetActiveBallsIds()
		{
			if (balls == null)
			{
				return null;
			}
			string[] array = new string[balls.Count];
			for (int i = 0; i < balls.Count; i++)
			{
				array[i] = string.Concat(balls[i].id);
			}
			return array;
		}

		public BallPoolPlayer(int playerId, string name, int coins, string uuid)
		{
			this.playerId = playerId;
			this.name = name;
			this.uuid = uuid;
			if (BallPoolPlayer.OnPlayerInitialized != null)
			{
				BallPoolPlayer.OnPlayerInitialized(this);
			}
		}

		public abstract void OnDeactivate();

		public virtual void SetActiveBalls(Ball[] balls)
		{
			this.balls = new List<Ball>(0);
			foreach (Ball ball in balls)
			{
				if (!ball.inPocket)
				{
					this.balls.Add(ball);
				}
			}
		}
	}
	public class Pocket : MonoBehaviour
	{
		public class BallRoll
		{
			public BallListener ball { get; private set; }

			public float maxLength { get; private set; }

			public BallRoll(BallListener ball, float maxLength)
			{
				this.ball = ball;
				this.maxLength = maxLength;
			}
		}

		private PhysicsManager physicsManager;

		public int id;

		private Vector3[] nodes;

		private float length;

		private float currentLength;

		private void Start()
		{
			physicsManager = UnityEngine.Object.FindObjectOfType<PhysicsManager>();
			if (!physicsManager)
			{
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			physicsManager.OnBallHitPocket += PhysicsManager_OnBallHitPocket;
			physicsManager.OnBallExitFromPocket += PhysicsManager_OnBallExitFromPocket;
			nodes = new Vector3[base.transform.childCount];
			for (int i = 0; i < nodes.Length; i++)
			{
				nodes[i] = base.transform.GetChild(i).position;
			}
			length = QuadraticCurve.CalculateLength(nodes);
			currentLength = length;
		}

		private void OnDisable()
		{
			if ((bool)physicsManager)
			{
				physicsManager.OnBallHitPocket -= PhysicsManager_OnBallHitPocket;
				physicsManager.OnBallExitFromPocket -= PhysicsManager_OnBallExitFromPocket;
			}
		}

		private void OnDestroy()
		{
			if ((bool)physicsManager)
			{
				physicsManager.OnBallHitPocket -= PhysicsManager_OnBallHitPocket;
				physicsManager.OnBallExitFromPocket -= PhysicsManager_OnBallExitFromPocket;
			}
		}

		private void PhysicsManager_OnBallExitFromPocket(BallListener ball, PocketListener pocket, BallExitType exitType, bool inMove)
		{
			if (pocket.id == id)
			{
				currentLength += 2f * ball.radius;
			}
		}

		private void PhysicsManager_OnBallHitPocket(BallListener ball, PocketListener pocket, bool inMove)
		{
			if (pocket.id == id)
			{
				ball.pocket = pocket;
				OnBallHit(ball, inMove);
			}
		}

		private void OnBallHit(BallListener ball, bool inMove)
		{
			BallRoll roll = new BallRoll(ball, currentLength);
			ball.body.isKinematic = true;
			StartCoroutine(RollTheBall(roll));
			currentLength -= 2f * ball.radius;
		}

		private IEnumerator RollTheBall(BallRoll roll)
		{
			yield return new WaitForFixedUpdate();
			yield return new WaitForEndOfFrame();
			float time = 0f;
			Vector3 ballOldPosition = roll.ball.body.position;
			while (time < roll.maxLength && (bool)roll.ball.pocket && roll.ball.body.isKinematic)
			{
				roll.ball.transform.position = QuadraticCurve.CalculateValue(time / length, nodes);
				Vector3 lhs = (roll.ball.body.position - ballOldPosition) / Time.fixedDeltaTime;
				ballOldPosition = roll.ball.body.position;
				roll.ball.transform.Rotate(Vector3.Cross(lhs, Vector3.up) / roll.ball.radius);
				time += 0.5f * Time.fixedDeltaTime;
				physicsManager.CallBallMove(roll.ball.id, roll.ball.body.position, Vector3.zero, Vector3.zero);
				yield return new WaitForFixedUpdate();
			}
			if ((bool)roll.ball.pocket && roll.ball.body.isKinematic)
			{
				roll.ball.transform.position = QuadraticCurve.CalculateValue(0.99f * roll.maxLength / length, nodes);
				physicsManager.CallBallMove(roll.ball.id, roll.ball.body.position, Vector3.zero, Vector3.zero);
			}
			yield return new WaitForFixedUpdate();
		}
	}
	public class ShotController : MonoBehaviour
	{
		public enum CueControlType
		{
			FirstPerson,
			ThirdPerson
		}

		public enum CueStateType
		{
			Non,
			TargetingAtCueBall,
			TargetingAtTargetBall,
			TargetingFromTop,
			StretchCue
		}

		public enum GameStateType
		{
			WaitingForOpponent,
			MoveAroundTable,
			SetBallPosition,
			SelectShotDirection,
			CameraFixAndWaitShot,
			Shot
		}

		public static bool canControl = true;

		public CueControlType cueControlType;

		[SerializeField]
		private LayerMask cueThirdPersonControlMask;

		[SerializeField]
		private float cueBallMaxVelocity;

		[SerializeField]
		private float cueBallJumpVelocity;

		[SerializeField]
		private float mouseRotationSpeed3D;

		[SerializeField]
		private float rotationSpeed3D;

		[SerializeField]
		private float rotationSpeed2D;

		[SerializeField]
		private float minVertical;

		[SerializeField]
		private float maxVertical;

		[SerializeField]
		private AnimationCurve rotationSpeedCurve;

		[SerializeField]
		private float targetingDisplacementSpeed;

		[SerializeField]
		private float cueSlideSpeed;

		[SerializeField]
		private float cueSlidingMaxDisplacement;

		private float cueBallRadius;

		public PhysicsManager physicsManager;

		[SerializeField]
		private GameManager gameManager;

		[SerializeField]
		private AightBallPoolAIManager aiManager;

		[SerializeField]
		private GameUIController uiController;

		private AudioSource cueHitBall;

		[SerializeField]
		private AudioClip hitBallClip;

		private float jumpFactor;

		public Transform cuePivot;

		[SerializeField]
		private Transform cuePivotAfterShotPosition;

		[SerializeField]
		private Transform tableCameraCenter;

		[SerializeField]
		private Transform cameraThirdPersonPosition;

		private Quaternion cueVerticalStartRotation;

		public Transform cueVertical;

		public Transform cueDisplacement;

		public Transform cueSlider;

		public Transform firstMoveSpace;

		[SerializeField]
		private Transform clothSpace;

		[SerializeField]
		private Transform cameraStandartPosition;

		[SerializeField]
		private Transform cueTargetingIn3DModePosition;

		[SerializeField]
		private Transform cameraAimingPosition;

		[SerializeField]
		private Transform cueCamera;

		private float cameraPivotRotationY;

		private float cameraRotationZ;

		private Vector3 cueDisplacementOnBall;

		public Ball cueBall;

		[SerializeField]
		private PlayerHand playerHand;

		[SerializeField]
		private Transform hand;

		[SerializeField]
		private LineRenderer cueBallSimpleLine;

		[SerializeField]
		private LineRenderer targetBallSimpleLine;

		private Vector3 savedCueSliderLocalPosition;

		[SerializeField]
		private Transform ballChecker;

		[SerializeField]
		private Transform freeBallChecker;

		[SerializeField]
		private UIFreeBallCheck freeBallCheckerUI;

		[SerializeField]
		private MeshRenderer ballCheckerRenderer;

		[SerializeField]
		private GameObject HeadLine;

		[NonSerialized]
		public Vector3 shotPoint;

		private Vector3 cueForwardInScreen;

		private Vector3 oldShotPoint;

		private Vector3 oldCueBallPosition;

		private float oldForce;

		private Vector3 oldForward;

		private bool from2D;

		private bool isSimpleControl = true;

		private bool stretchCue;

		[SerializeField]
		private Slider forceSlider;

		[SerializeField]
		private Text haveReplayText;

		[SerializeField]
		private Text waitingOpponent;

		private bool shotFromAI;

		public Image shotBack;

		private MouseState mouseState;

		private bool useAI;

		private Vector3 cuePivotPosition;

		private float cuePivotLocalRotationYAdd;

		private float cuePivotLocalRotationY;

		private float cueVerticalLocalRotationXAdd;

		private float cueVerticalLocalRotationX;

		private Vector2 cueDisplacementLocalPositionXY;

		private float cueSliderLocalPositionZ;

		private Vector3 ballPosition;

		private Vector3 chackPosition;

		private Vector3 smoothBallPosition;

		private Impulse impulseFromNetwork;

		private bool _opponenIsReadToPlay;

		private int shotNumber;

		private float cueBallCheckBallDistance;

		private float TouchInputTime;

		[SerializeField]
		private AnimationCurve CameraMovementCurve;

		[SerializeField]
		private AnimationCurve CueSliderAnimationCurve;

		private const float CUE_LENGTH = 1.375f;

		[SerializeField]
		private Transform LeftHandAnchor;

		[SerializeField]
		private Transform TableSpace;

		[SerializeField]
		private PermittedSpaceController SpaceController;

		[SerializeField]
		private AnimationCurve ForceMultipler;

		private float ShotDeltaForce;

		private CoroutineWrapper PermittedSpaceMoveRoutine;

		private CoroutineWrapper WaitAndStartShotRoutine;

		private Vector3 FixedRightHandPosition;

		private Vector3 MainControllerTracker;

		private Coroutine AIAnimationRoutine;

		private float maxVelocity
		{
			get
			{
				float num = ((cueVertical.localRotation.eulerAngles.x / (maxVertical - minVertical) > 0.7f) ? 1f : 0f);
				return Mathf.Lerp(cueBallMaxVelocity, cueBallJumpVelocity, jumpFactor * num);
			}
		}

		private float lineLength
		{
			get
			{
				if (BallPoolGameLogic.playMode == PlayMode.PlayerAI)
				{
					return (float)Mathf.Max(0, BallPoolAIExtension.DumbLevel - 2) * 0.07f;
				}
				if (BallPoolGameLogic.playMode == PlayMode.OnLine)
				{
					return 0.075f;
				}
				return 0.25f;
			}
		}

		public int clothLayer { get; set; }

		public int boardLayer { get; set; }

		public int ballLayer { get; set; }

		public int cueBallLayer { get; set; }

		public new bool enabled { get; set; }

		public Transform ClothSpace => clothSpace;

		public float cueSliderDisplacementZ { get; private set; }

		private CueStateType cueStateType
		{
			get
			{
				return Billiards.Singleton<BilliardsDataContainer>.Instance.CueState.CurrentData;
			}
			set
			{
				Billiards.Singleton<BilliardsDataContainer>.Instance.CueState.CurrentData = value;
			}
		}

		private GameStateType currentGameState
		{
			get
			{
				return Billiards.Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData;
			}
			set
			{
				Billiards.Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData = value;
			}
		}

		public Vector3 targetBallSavedDirection { get; private set; }

		public BallListener tragetBallListener { get; set; }

		public float force { get; private set; }

		public float MaxCueSlideZDisplacement { get; private set; }

		public bool inShot { get; private set; }

		public bool inMove { get; private set; }

		public bool activateAfterCalculateAI { get; private set; }

		public bool ballInHand { get; private set; }

		public bool canUpdateBallFromNetwork { get; set; }

		public bool cueChanged
		{
			get
			{
				if (cuePivotLocalRotationY != cuePivot.localRotation.eulerAngles.y || cueVerticalLocalRotationX != cueVertical.localRotation.eulerAngles.x || cueDisplacementLocalPositionXY != new Vector2(cueDisplacement.localPosition.x, cueDisplacement.localPosition.y) || cueSliderLocalPositionZ != cueSlider.localPosition.z)
				{
					cuePivotLocalRotationY = cuePivot.localRotation.eulerAngles.y;
					cueVerticalLocalRotationX = cueVertical.localRotation.eulerAngles.x;
					cueDisplacementLocalPositionXY = new Vector2(cueDisplacement.localPosition.x, cueDisplacement.localPosition.y);
					cueSliderLocalPositionZ = cueSlider.localPosition.z;
					return true;
				}
				return false;
			}
		}

		public bool ballChanged
		{
			get
			{
				if (Vector3.Distance(chackPosition, cueBall.position) > 0.1f * cueBall.radius)
				{
					chackPosition = cueBall.position;
					return true;
				}
				return false;
			}
		}

		public bool changed
		{
			get
			{
				if (!enabled)
				{
					return false;
				}
				if (oldShotPoint != shotPoint || oldForce != force || oldForward != cueSlider.forward || oldCueBallPosition != cueBall.position)
				{
					oldShotPoint = shotPoint;
					oldForce = force;
					oldForward = cueSlider.forward;
					oldCueBallPosition = cueBall.position;
					return true;
				}
				return false;
			}
		}

		public bool opponenIsReadToPlay => _opponenIsReadToPlay;

		private bool AllowedSetCuePosition
		{
			get
			{
				return Billiards.Singleton<BilliardsDataContainer>.Instance.AllowedSetCuePositionState.CurrentData;
			}
			set
			{
				Billiards.Singleton<BilliardsDataContainer>.Instance.AllowedSetCuePositionState.CurrentData = value;
			}
		}

		public static bool IsRightHanded { get; private set; } = true;


		public static XRControllerState MainHandController
		{
			get
			{
				if (!IsRightHanded)
				{
					return Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState;
				}
				return Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState;
			}
		}

		public static XRControllerState SubHandController
		{
			get
			{
				if (!IsRightHanded)
				{
					return Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightControllerState;
				}
				return Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState;
			}
		}

		public event Action OnEndCalculateAI;

		public event Action OnSelectBall;

		public event Action OnUnselectBall;

		private void Awake()
		{
			if (!NetworkManager.initialized)
			{
				enabled = false;
				return;
			}
			targetBallSavedDirection = Vector3.zero;
			useAI = false;
			activateAfterCalculateAI = false;
			cueBallRadius = 0.5f * cueBall.transform.lossyScale.x;
			clothLayer = 1 << Layer.NameToLayer(Layer.GameType.Billiards, "Cloth");
			boardLayer = 1 << Layer.NameToLayer(Layer.GameType.Billiards, "Board");
			ballLayer = 1 << Layer.NameToLayer(Layer.GameType.Billiards, "Ball");
			cueBallLayer = 1 << Layer.NameToLayer(Layer.GameType.Billiards, "CueBall");
			cueVerticalStartRotation = cueVertical.localRotation;
			waitingOpponent.enabled = false;
			canUpdateBallFromNetwork = false;
			ballPosition = cueBall.position;
			smoothBallPosition = cueBall.position;
			cuePivotLocalRotationY = cuePivot.localRotation.eulerAngles.y;
			cueVerticalLocalRotationX = cueVertical.localRotation.eulerAngles.x;
			cueDisplacementLocalPositionXY = new Vector2(cueDisplacement.localPosition.x, cueDisplacement.localPosition.y);
			cueSliderLocalPositionZ = cueSlider.localPosition.z;
			SpaceController.enabled = false;
			PermittedSpaceMoveRoutine = CoroutineWrapper.Generate(this);
			WaitAndStartShotRoutine = CoroutineWrapper.Generate(this);
			inShot = false;
			inMove = false;
			mouseState = MouseState.Down;
			if (cueControlType == CueControlType.FirstPerson)
			{
				cueCamera.transform.position = cameraStandartPosition.position;
				cueCamera.transform.rotation = cameraStandartPosition.rotation;
			}
			else if (cueControlType == CueControlType.ThirdPerson)
			{
				cueCamera.transform.SetParent(Billiards.Singleton<BilliardsDataContainer>.Instance.TableCameraSlot.CurrentData, worldPositionStays: false);
				cueCamera.transform.position = cameraThirdPersonPosition.position;
				cueCamera.transform.localRotation = Quaternion.identity;
			}
			uiController.OnShot += delegate(bool follow)
			{
				activateAfterCalculateAI = false;
				if (follow)
				{
					inShot = true;
					inMove = true;
					shotFromAI = false;
					WaitAndStartShotRoutine.StartSingleton(WaitAndStartShot());
				}
				else if ((enabled || BallPoolGameLogic.playMode == PlayMode.PlayerAI) && !physicsManager.inMove)
				{
					force = Mathf.Clamp01((0f - cueSliderDisplacementZ) / cueSlidingMaxDisplacement);
					cueStateType = CueStateType.Non;
					if (!inShot && force > 0.03f && (!uiController.shotOnUp || shotFromAI))
					{
						inShot = true;
						inMove = true;
						shotFromAI = false;
						WaitAndStartShotRoutine.StartSingleton(WaitAndStartShot());
					}
				}
			};
			if (BallPoolGameLogic.playMode == PlayMode.Replay)
			{
				physicsManager.OnStartShot += Replay_PhysicsManager_OnStartShot;
				physicsManager.OnEndShot += Replay_PhysicsManager_OnEndShot;
				hand.gameObject.SetActive(value: false);
				enabled = false;
				if (physicsManager.replayManager.GetReplayDataCount() == 0)
				{
					shotBack.enabled = true;
					haveReplayText.enabled = true;
				}
				else
				{
					shotBack.enabled = false;
				}
				ballChecker.gameObject.SetActive(value: false);
				if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
				{
					cuePivot.GetComponentInChildren<MeshRenderer>().enabled = false;
				}
				return;
			}
			ballInHand = false;
			ResetChanged();
			from2D = false;
			savedCueSliderLocalPosition = cueSlider.localPosition;
			physicsManager.OnSetState += PhysicsManager_OnSetState;
			physicsManager.OnStartShot += PhysicsManager_OnStartShot;
			physicsManager.OnBallExitFromPocket += PhysicsManager_OnBallExitFromPocket;
			aiManager.OnStartCalculateAI += AIManager_OnStartCalculateAI;
			aiManager.OnEndCalculateAI += AIManager_OnEndCalculateAI;
			cueHitBall = base.gameObject.AddComponent<AudioSource>();
			cueHitBall.playOnAwake = false;
			cueHitBall.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("Effect");
			BallPoolGameManager.instance.OnShotEnded += BallPoolGameManager_instance_OnShotEnded;
			if (BallPoolGameLogic.isOnLine)
			{
				physicsManager.OnSaveEndStartReplay += PhysicsManager_OnSaveEndStartReplay;
			}
			freeBallChecker.gameObject.SetActive(value: false);
			hand.gameObject.SetActive(value: false);
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType != GameData_DDOL.PlayType.Single || SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level == 5)
			{
				ballCheckerRenderer.renderingLayerMask = 0u;
			}
			IsRightHanded = PublicGameUIManager.gameSetting.IsRightHanded();
			PublicGameUIManager.gameSetting.AddHandChangedEvent(OnMainHandChanged);
		}

		private void PhysicsManager_OnSaveEndStartReplay(string impulse)
		{
			if (BallPoolGameLogic.controlFromNetwork)
			{
				impulseFromNetwork = DataManager.ImpulseFromString(impulse);
				UnityEngine.Debug.Log("Impulse Form Network : " + impulseFromNetwork);
				UnityEngine.Debug.Log("PhysicsManager_OnSaveEndStartReplay");
				if (WaitAndStartShotRoutine.Routine == null)
				{
					WaitAndStartShotRoutine.StartSingleton(WaitAndStartShot());
				}
			}
		}

		private void Replay_PhysicsManager_OnStartSave()
		{
			shotBack.enabled = true;
		}

		private void Replay_PhysicsManager_OnStartShot(string data)
		{
			shotBack.enabled = true;
		}

		private void Replay_PhysicsManager_OnEndShot(string data)
		{
			int replayNumberValue = uiController.replayNumberValue;
			int replayDataCount = physicsManager.replayManager.GetReplayDataCount();
			replayNumberValue = ((replayDataCount != 1 && replayNumberValue < replayDataCount - 1) ? (replayNumberValue + 1) : 0);
			UnityEngine.Debug.LogWarning("replayNumber " + replayNumberValue + "  " + replayDataCount);
			uiController.SetReplayNumber(replayNumberValue, replayDataCount == 1);
			shotBack.enabled = false;
		}

		private void Start()
		{
			StartCoroutine(SetControl());
		}

		private void OnEnable()
		{
			MainHandController[InputHelpers.Button.Primary2DAxisClick].OnDataChanged += ControllerTrackButton_OnDataChanged;
			Billiards.Singleton<InputDeviceInfo>.Instance.Primary2DAxisInput.OnDataChanged += ControllerTrackButton_OnDataChanged;
			MainHandController[InputHelpers.Button.Trigger].OnDataChanged += ControllerTrigger_OnDataChanged;
			SubHandController[InputHelpers.Button.Trigger].OnDataChanged += SubControllerTrigger_OnDataChanged;
		}

		public void OnJumpToggle(Toggle value)
		{
			jumpFactor = (value.isOn ? 1f : 0f);
		}

		public void OnEnableControl(bool value)
		{
			forceSlider.value = 0f;
			force = 0f;
			forceSlider.enabled = value;
			if (!value)
			{
				hand.gameObject.SetActive(value: false);
			}
			enabled = value;
			if (ballInHand)
			{
				UnselectBall();
			}
			if (cueStateType == CueStateType.TargetingAtCueBall)
			{
				ResetFromTargetingAtCueBall();
			}
			StartCoroutine(SetControl());
			if (BallPoolGameLogic.isOnLine)
			{
				_ = AightBallPoolNetworkGameAdapter.isSameGraphicsMode;
			}
		}

		public void OpponenIsReadToPlay()
		{
			_opponenIsReadToPlay = true;
			_ = AightBallPoolNetworkGameAdapter.isSameGraphicsMode;
		}

		public void SetOpponentCueURL(string url)
		{
		}

		public void SetOpponentTableURLs(string boardURL, string clothURL, string clothColor)
		{
		}

		private IEnumerator SetControl()
		{
			yield return new WaitForEndOfFrame();
			yield return new WaitForEndOfFrame();
			yield return new WaitForFixedUpdate();
			yield return new WaitForFixedUpdate();
			if (BallPoolGameLogic.isOnLine)
			{
				float waitingTime = 0f;
				while (!NetworkManager.network.opponenWaitingForYourTurn)
				{
					yield return new WaitForEndOfFrame();
					waitingTime += Time.deltaTime;
					if (waitingTime > 2f)
					{
						waitingOpponent.enabled = true;
					}
				}
				waitingOpponent.enabled = false;
			}
			if (!enabled && !BallPoolPlayer.mainPlayer.myTurn && BallPoolGameLogic.playMode != PlayMode.HotSeat && BallPoolGameLogic.playMode != PlayMode.Replay)
			{
				shotBack.enabled = true;
			}
			else
			{
				shotBack.enabled = false;
			}
		}

		private void OnDisable()
		{
			SubHandController[InputHelpers.Button.Trigger].OnDataChanged -= SubControllerTrigger_OnDataChanged;
			MainHandController[InputHelpers.Button.Trigger].OnDataChanged -= ControllerTrigger_OnDataChanged;
			Billiards.Singleton<InputDeviceInfo>.Instance.Primary2DAxisInput.OnDataChanged -= ControllerTrackButton_OnDataChanged;
			MainHandController[InputHelpers.Button.Primary2DAxisClick].OnDataChanged -= ControllerTrackButton_OnDataChanged;
		}

		private void OnDestroy()
		{
			Billiards.Singleton<HandLineManager>.Instance.MainHand.RequestShow(enable: false, this);
			Billiards.Singleton<HandLineManager>.Instance.SubHand.RequestShow(enable: false, this);
			physicsManager.OnStartShot -= PhysicsManager_OnStartShot;
			physicsManager.OnBallExitFromPocket -= PhysicsManager_OnBallExitFromPocket;
			physicsManager.OnStartShot -= Replay_PhysicsManager_OnStartShot;
			physicsManager.OnEndShot -= Replay_PhysicsManager_OnEndShot;
			aiManager.OnStartCalculateAI -= AIManager_OnStartCalculateAI;
			aiManager.OnEndCalculateAI -= AIManager_OnEndCalculateAI;
		}

		public void OnEndTime()
		{
			UnityEngine.Debug.Log("OnEndTime");
			activateAfterCalculateAI = false;
			cueVertical.parent = cuePivot;
			cueVertical.localPosition = Vector3.zero;
			cueVertical.localRotation = cueVerticalStartRotation;
			cueDisplacement.localPosition = Vector3.zero;
			ballChecker.gameObject.SetActive(value: true);
		}

		public void UndoShot()
		{
			UnityEngine.Debug.Log("UndoShot");
			WaitAndStartShotRoutine.Stop();
			cueSliderDisplacementZ = 0f;
			cueSlider.localPosition = new Vector3(0f, 0f, cueSliderDisplacementZ);
			savedCueSliderLocalPosition = cueSlider.localPosition;
			force = Mathf.Clamp01((0f - cueSliderDisplacementZ) / cueSlidingMaxDisplacement);
			physicsManager.HideBallsLine();
			aiManager.CancelCalculateAI();
		}

		private void ResetChanged()
		{
			oldShotPoint = shotPoint;
			oldForce = force;
			oldForward = cueSlider.forward;
			oldCueBallPosition = cueBall.position;
		}

		[Obsolete]
		public void DecreaseAICount()
		{
		}

		public IEnumerator WaitAndStartShot()
		{
			physicsManager.moveTime = 0f;
			physicsManager.endFromNetwork = false;
			shotNumber++;
			hand.gameObject.SetActive(value: false);
			inShot = true;
			inMove = true;
			shotBack.enabled = true;
			float checkTime = 0f;
			if (!BallPoolGameLogic.controlFromNetwork)
			{
				while (checkTime < 1f && cueSlider.localPosition.z < 0f)
				{
					checkTime += Time.fixedDeltaTime;
					cueSlider.localPosition += Vector3.forward * force * Time.fixedDeltaTime * 10f;
					if (cueSlider.localPosition.z > 0f)
					{
						cueSlider.localPosition = new Vector3(0f, 0f, 0f);
					}
					yield return new WaitForFixedUpdate();
				}
				cueSlider.localPosition = new Vector3(0f, 0f, 0f);
			}
			yield return new WaitForSeconds(3f * Time.fixedDeltaTime);
			Impulse impulse;
			if (BallPoolGameLogic.playMode == PlayMode.Replay)
			{
				impulse = physicsManager.replayManager.GetImpulse(uiController.replayNumberValue);
				UnityEngine.Debug.Log("set impulse " + impulse.impulse);
				physicsManager.SetImpulse(impulse);
			}
			else
			{
				if (BallPoolGameLogic.controlFromNetwork)
				{
					impulse = impulseFromNetwork;
					yield return new WaitForSeconds(1f);
					while (checkTime < 1f && cueSlider.localPosition.z < 0f)
					{
						checkTime += Time.fixedDeltaTime;
						cueSlider.localPosition += Vector3.forward * force * Time.fixedDeltaTime * 10f;
						if (cueSlider.localPosition.z > 0f)
						{
							cueSlider.localPosition = new Vector3(0f, 0f, 0f);
						}
						yield return YieldInstructionCache.WaitForFixedUpdate;
					}
					cueSlider.localPosition = new Vector3(0f, 0f, 0f);
				}
				else
				{
					Vector3 impulse2 = force * (maxVelocity * physicsManager.ballMass) * (Vector3.ProjectOnPlane(cueSlider.forward, Vector3.up) + 0.5f * Vector3.Project(cueSlider.forward, Vector3.up)).normalized;
					impulse = new Impulse(shotPoint, impulse2);
				}
				physicsManager.SetImpulse(impulse);
				UnityEngine.Debug.Log("in Waitandstartshot : impulse : " + impulse);
				physicsManager.replayManager.SaveImpulse(impulse);
			}
			if (BallPoolGameLogic.controlInNetwork)
			{
				yield return null;
				physicsManager.StartRaplayShot(DataManager.ImpulseToString(impulse));
			}
			HideAllLines();
			physicsManager.StartShot(cueBall.listener);
			if (BallPoolGameLogic.playMode == PlayMode.Replay)
			{
				Ball[] balls = gameManager.balls;
				for (int i = 0; i < balls.Length; i++)
				{
					balls[i].SrartFollow();
				}
			}
			forceSlider.value = 0f;
			hand.gameObject.SetActive(value: false);
			inShot = false;
			yield return new WaitForSeconds(0.7f);
			if (physicsManager.inMove)
			{
				cueVertical.parent = cuePivotAfterShotPosition;
				cueVertical.localPosition = Vector3.zero;
				cueVertical.localRotation = Quaternion.identity;
				cueDisplacement.localPosition = Vector3.zero;
				playerHand.UpdateHandActive(cueActive: false);
				LeftHandAnchor.localPosition = GameConfig.PlayerLeftHandDefaultLocalPosition;
				LeftHandAnchor.localEulerAngles = GameConfig.PlayerLeftHandDefaultLocalEuler;
			}
		}

		private void PhysicsManager_OnBallExitFromPocket(BallListener listener, PocketListener pocket, BallExitType exitType, bool inSimulate)
		{
			if (listener == cueBall.listener)
			{
				cueBall.isActive = false;
			}
		}

		private void AIManager_OnEndCalculateAI(BallPoolAIManager aiManager)
		{
			if (aiManager.haveExaption)
			{
				UnityEngine.Debug.LogWarning("haveExaption");
			}
			if (AIAnimationRoutine != null)
			{
				return;
			}
			AIAnimationRoutine = StartCoroutine(AIStartAnimation(delegate
			{
				Impulse impulse = new Impulse(shotPoint, force * (maxVelocity * cueBall.listener.body.mass) * cueSlider.forward);
				physicsManager.SetImpulse(impulse);
				if (BallPoolGameLogic.controlInNetwork)
				{
					NetworkManager.network.SendRemoteMessage("SetBallPosition", cueBall.position);
					NetworkManager.network.SendRemoteMessage("OnForceSendCueControl", cuePivot.localPosition, cuePivot.localRotation.eulerAngles.y, cueVertical.localRotation.eulerAngles.x, new Vector2(cueDisplacement.localPosition.x, cueDisplacement.localPosition.y), cueSlider.localPosition.z, force);
				}
				if (this.OnEndCalculateAI != null)
				{
					this.OnEndCalculateAI();
				}
				if (BallPoolGameLogic.playMode != 0 || BallPoolPlayer.mainPlayer.myTurn)
				{
					if (uiController.shotOnUp)
					{
						UnityEngine.Debug.Log("StartShot ");
						inMove = true;
						enabled = false;
						shotBack.enabled = true;
						inShot = true;
						shotFromAI = false;
						WaitAndStartShotRoutine.StartSingleton(WaitAndStartShot());
					}
					else
					{
						UnityEngine.Debug.Log("Activate ");
						enabled = true;
						shotBack.enabled = false;
						activateAfterCalculateAI = true;
					}
				}
				AIAnimationRoutine = null;
			}));
		}

		private void AIManager_OnStartCalculateAI(BallPoolAIManager AIManager)
		{
			useAI = true;
			shotFromAI = true;
			enabled = false;
			activateAfterCalculateAI = false;
			cueVertical.localPosition = Vector3.zero;
			cueVertical.localRotation = Quaternion.identity;
			ballChecker.gameObject.SetActive(value: false);
			playerHand.UpdateHandActive(cueActive: true);
			LeftHandAnchor.GetChild(0).gameObject.SetActive(value: true);
			LeftHandAnchor.GetChild(1).gameObject.SetActive(value: false);
		}

		private void PhysicsManager_OnSetState()
		{
			cuePivot.position = cueBall.position;
			Vector3 normalized = cueBall.impulse.impulse.normalized;
			cuePivot.LookAt(cuePivot.position + Vector3.ProjectOnPlane(normalized, Vector3.up));
			cueSlider.forward = cueBall.impulse.impulse.normalized;
			cueDisplacement.position = cueBall.impulse.point;
			TryCalculateShot(forceCalculate: true);
		}

		private void PhysicsManager_OnStartShot(string data)
		{
			cueHitBall.volume = force;
			cueHitBall.PlayOneShot(hitBallClip);
			enabled = false;
			ballChecker.gameObject.SetActive(value: false);
			HideAllLines();
		}

		private void BallPoolGameManager_instance_OnShotEnded()
		{
			inMove = false;
			activateAfterCalculateAI = false;
			ballPosition = cueBall.position;
			smoothBallPosition = ballPosition;
			if (HeadLine.activeInHierarchy)
			{
				HeadLine.SetActive(value: false);
			}
			enabled = BallPoolPlayer.mainPlayer.myTurn || BallPoolGameLogic.playMode == PlayMode.HotSeat;
			if (cueBall.firstHitInfo.shapeType != 0)
			{
				ballChecker.position = cueBall.firstHitInfo.positionInHit;
			}
			ballChecker.gameObject.SetActive(value: true);
			StartCoroutine(SetControl());
			Ball[] balls = BallPoolGameManager.instance.balls;
			foreach (Ball ball in balls)
			{
				if (!ball.inSpace && !ball.inPocket)
				{
					bool canReactivate = false;
					Vector3 ballNewPosition = Vector3.zero;
					physicsManager.ReactivateBallInCube(ball.radius, clothSpace, clothLayer, ballLayer | cueBallLayer, ref canReactivate, ref ballNewPosition);
					if (canReactivate)
					{
						ball.position = ballNewPosition;
						ball.isActive = false;
						ball.inPocket = false;
						ball.pocketId = -1;
						ball.hitShapeId = -2;
						ball.OnState(BallState.ExitFromPocket);
					}
				}
			}
			if (AightBallPoolGameLogic.gameState.cueBallInPocket)
			{
				bool canReactivate2 = false;
				Vector3 ballNewPosition2 = Vector3.zero;
				physicsManager.ReactivateBallInCube(cueBall.radius, clothSpace, clothLayer, ballLayer | cueBallLayer, ref canReactivate2, ref ballNewPosition2);
				if (canReactivate2)
				{
					physicsManager.CallOnBallExitFromPocket(cueBall.listener, cueBall.listener.pocket, inReplay: true);
					UnityEngine.Debug.LogWarning("Nuul");
					cueBall.listener.pocket = null;
					cueBall.position = ballNewPosition2;
					cueBall.isActive = false;
					cueBall.inPocket = false;
					cueBall.pocketId = -1;
					cueBall.hitShapeId = -2;
					cueBall.OnState(BallState.ExitFromPocket);
				}
			}
			cuePivot.position = cueBall.position;
			cueDisplacement.localPosition = Vector3.zero;
			cueSlider.localPosition = Vector3.zero;
			cueSliderDisplacementZ = 0f;
			forceSlider.value = 0f;
			cueVertical.parent = cuePivot;
			cueVertical.localPosition = Vector3.zero;
			cueVertical.localRotation = cueVerticalStartRotation;
			TryCalculateShot(forceCalculate: true);
			if (BallPoolGameLogic.isOnLine)
			{
				NetworkManager.network.SendRemoteMessage("OnOpponenWaitingForYourTurn");
			}
			if (BallPoolPlayer.mainPlayer.myTurn)
			{
				SetState(GameStateType.MoveAroundTable);
			}
			else
			{
				SetState(GameStateType.WaitingForOpponent);
			}
		}

		private void HideAllLines()
		{
			cueBallSimpleLine.positionCount = 0;
			targetBallSimpleLine.positionCount = 0;
			physicsManager.HideBallsLine();
		}

		[Obsolete]
		private void InputOutput_OnMouseState(MouseState mouseState)
		{
		}

		public void UpdateFromNetwork()
		{
			cuePivot.localPosition = Vector3.Lerp(cuePivot.localPosition, cuePivotPosition, 5f * Time.deltaTime);
			cuePivot.localRotation = Quaternion.Lerp(cuePivot.localRotation, Quaternion.Euler(0f, cuePivotLocalRotationY, 0f), 5f * Time.deltaTime);
			cueVertical.localRotation = Quaternion.Lerp(cueVertical.localRotation, Quaternion.Euler(cueVerticalLocalRotationX, 0f, 0f), 5f * Time.deltaTime);
			cueDisplacement.localPosition = Vector3.Lerp(cueDisplacement.localPosition, new Vector3(cueDisplacementLocalPositionXY.x, cueDisplacementLocalPositionXY.y, 0f), 5f * Time.deltaTime);
			cueSlider.localPosition = Vector3.Lerp(cueSlider.localPosition, new Vector3(0f, 0f, cueSliderLocalPositionZ), 5f * Time.deltaTime);
			if (canUpdateBallFromNetwork)
			{
				smoothBallPosition = Vector3.Lerp(smoothBallPosition, ballPosition, 5f * Time.deltaTime);
				cueBall.position = smoothBallPosition;
				cueBall.OnState(BallState.SetState);
			}
			if (Mathf.Abs(cuePivot.localRotation.eulerAngles.y - cuePivotLocalRotationY) > 0.1f)
			{
				TryCalculateShot(forceCalculate: true);
			}
			if (Mathf.Abs(cuePivot.localRotation.eulerAngles.y - cuePivotLocalRotationY) < 0.1f && cuePivot.localRotation.eulerAngles.y != cuePivotLocalRotationY)
			{
				cuePivot.localRotation = Quaternion.Euler(0f, cuePivotLocalRotationY, 0f);
				TryCalculateShot(forceCalculate: true);
			}
		}

		public void SelectBallPositionFromNetwork(Vector3 ballSelectPosition)
		{
			canUpdateBallFromNetwork = true;
			ballPosition = ballSelectPosition;
			smoothBallPosition = ballSelectPosition;
			cueBall.position = ballSelectPosition;
			cueBall.OnState(BallState.SetState);
		}

		public void SetBallPositionFromNetwork(Vector3 ballNewPosition)
		{
			UnityEngine.Debug.LogWarning("SetBallPositionFromNetwork");
			canUpdateBallFromNetwork = false;
			smoothBallPosition = ballNewPosition;
			ballPosition = ballNewPosition;
			cuePivot.position = ballNewPosition;
			cueBall.position = ballNewPosition;
			cueBall.OnState(BallState.SetState);
			TryCalculateShot(forceCalculate: true);
		}

		public void MoveBallFromNetwork(Vector3 ballPosition)
		{
			UnityEngine.Debug.LogWarning("MoveBallFromNetwork " + DataManager.Vector3ToString(ballPosition));
			this.ballPosition = ballPosition;
		}

		public void CueControlFromNetwork(Vector3 cuePivotPosition, float cuePivotLocalRotationY, float cueVerticalLocalRotationX, Vector2 cueDisplacementLocalPositionXY, float cueSliderLocalPositionZ, float force)
		{
			this.cuePivotPosition = cuePivotPosition;
			this.cuePivotLocalRotationY = cuePivotLocalRotationY;
			this.cueVerticalLocalRotationX = cueVerticalLocalRotationX;
			this.cueDisplacementLocalPositionXY = cueDisplacementLocalPositionXY;
			this.cueSliderLocalPositionZ = cueSliderLocalPositionZ;
			this.force = force;
			cueSliderDisplacementZ = Mathf.Lerp(0f, 0f - cueSlidingMaxDisplacement, force);
		}

		public void ForceCueControlFromNetwork(Vector3 cuePivotPosition, float cuePivotLocalRotationY, float cueVerticalLocalRotationX, Vector2 cueDisplacementLocalPositionXY, float cueSliderLocalPositionZ, float force)
		{
			CueControlFromNetwork(cuePivotPosition, cuePivotLocalRotationY, cueVerticalLocalRotationX, cueDisplacementLocalPositionXY, cueSliderLocalPositionZ, force);
			cuePivot.localPosition = cuePivotPosition;
			cuePivot.localRotation = Quaternion.Euler(0f, cuePivotLocalRotationY, 0f);
			cueVertical.localRotation = Quaternion.Euler(cueVerticalLocalRotationX, 0f, 0f);
			cueDisplacement.localPosition = new Vector3(cueDisplacementLocalPositionXY.x, cueDisplacementLocalPositionXY.y, 0f);
			cueSlider.localPosition = new Vector3(0f, 0f, cueSliderLocalPositionZ);
			smoothBallPosition = Vector3.Lerp(smoothBallPosition, ballPosition, 5f * Time.deltaTime);
			cueBall.position = smoothBallPosition;
			cueBall.OnState(BallState.SetState);
			if (Mathf.Abs(cuePivot.localRotation.eulerAngles.y - cuePivotLocalRotationY) > 0.1f)
			{
				TryCalculateShot(forceCalculate: true);
			}
			if (Mathf.Abs(cuePivot.localRotation.eulerAngles.y - cuePivotLocalRotationY) < 0.1f && cuePivot.localRotation.eulerAngles.y != cuePivotLocalRotationY)
			{
				cuePivot.localRotation = Quaternion.Euler(0f, cuePivotLocalRotationY, 0f);
				TryCalculateShot(forceCalculate: true);
			}
		}

		private void TryCalculateShot(bool forceCalculate)
		{
			if (currentGameState != GameStateType.CameraFixAndWaitShot)
			{
				if (!Physics.Raycast(cueDisplacement.position, cueDisplacement.forward, out var _, 1.2f * clothSpace.lossyScale.x, cueBallLayer))
				{
					ReleaseCalculateShot();
				}
				else
				{
					ReleaseCalculateShot(isInverse: true);
				}
			}
			Vector3 position = cueBall.position;
			shotPoint = cueDisplacement.position;
			force = Mathf.Clamp01((0f - cueSliderDisplacementZ) / cueSlidingMaxDisplacement);
			if (!forceCalculate && !changed)
			{
				return;
			}
			if (force > 0.03f)
			{
				physicsManager.SetImpulse(new Impulse(shotPoint, force * (maxVelocity * physicsManager.ballMass) * cueSlider.forward));
			}
			physicsManager.HideBallsLine();
			Vector3 normalized = Vector3.ProjectOnPlane(cuePivot.forward, Vector3.up).normalized;
			Color color = new Color(0.2313726f, 0.4980392f, 1f, 1f);
			targetBallSavedDirection = Vector3.zero;
			tragetBallListener = null;
			if (Physics.SphereCast(position, cueBallRadius, normalized, out var hitInfo2, 1.2f * clothSpace.lossyScale.x, ballLayer | boardLayer))
			{
				BallListener component = hitInfo2.collider.gameObject.GetComponent<BallListener>();
				if ((bool)component)
				{
					Vector3 vector = hitInfo2.point + cueBallRadius * hitInfo2.normal;
					ballChecker.position = vector;
					if (aiManager.FindException(component.id))
					{
						color = Color.red;
					}
					cueBallSimpleLine.positionCount = 3;
					cueBallSimpleLine.SetPosition(0, position);
					cueBallSimpleLine.SetPosition(1, ballChecker.position);
					Vector3 vector2 = Vector3.Cross(Vector3.up, Vector3.ProjectOnPlane(hitInfo2.normal, Vector3.up).normalized);
					float num = Vector3.Dot(Vector3.ProjectOnPlane(cuePivot.forward, Vector3.up), vector2);
					if (num < 0f)
					{
						vector2 = -vector2;
					}
					cueBallSimpleLine.SetPosition(2, vector + Mathf.Clamp(Mathf.Abs(num), 0.2f, 1f) * lineLength * vector2);
					Vector3 vector3 = Mathf.Clamp(1f - Mathf.Abs(num), 0.2f, 1f) * (component.body.position - vector).normalized;
					targetBallSimpleLine.positionCount = 2;
					targetBallSimpleLine.SetPosition(0, component.body.position);
					targetBallSimpleLine.SetPosition(1, component.body.position + vector3 * lineLength);
					targetBallSavedDirection = (vector3 * 0.25f).normalized;
					tragetBallListener = component;
				}
				else
				{
					Vector3 vector4 = hitInfo2.point + cueBallRadius * hitInfo2.normal;
					ballChecker.position = vector4;
					cueBallSimpleLine.positionCount = 3;
					cueBallSimpleLine.SetPosition(0, position);
					cueBallSimpleLine.SetPosition(1, ballChecker.position);
					Vector3 vector5 = Vector3.Project(Vector3.ProjectOnPlane(cuePivot.forward, Vector3.up), Vector3.ProjectOnPlane(hitInfo2.normal, Vector3.up).normalized);
					Vector3 vector6 = Vector3.ProjectOnPlane(cuePivot.forward, Vector3.up) - 2f * vector5;
					cueBallSimpleLine.SetPosition(2, vector4 + lineLength * vector6);
					targetBallSimpleLine.positionCount = 0;
				}
				cueBallCheckBallDistance = Vector3.Distance(position, ballChecker.position);
			}
			else
			{
				ballChecker.position = position + cueBallCheckBallDistance * Vector3.ProjectOnPlane(cuePivot.forward, Vector3.up);
				cueBallSimpleLine.positionCount = 3;
				cueBallSimpleLine.SetPosition(0, position);
				cueBallSimpleLine.SetPosition(1, ballChecker.position);
				targetBallSimpleLine.positionCount = 0;
				color = Color.red;
			}
			color.a = 0.3f;
			ballCheckerRenderer.sharedMaterial.color = color;
			physicsManager.SetImpulse(new Impulse(shotPoint, force * (maxVelocity * physicsManager.ballMass) * cueSlider.forward));
		}

		private void ReleaseCalculateShot(bool isInverse = false)
		{
			ballCheckerRenderer.enabled = isInverse;
			targetBallSimpleLine.enabled = isInverse;
		}

		private void UnselectBall()
		{
			ballInHand = false;
			ballPosition = Geometry.ClampPositionInCube(ballPosition, cueBallRadius, AightBallPoolGameLogic.gameState.tableIsOpened ? firstMoveSpace : clothSpace);
			if (ballPosition.y < 0f || ballPosition.y > cueBallRadius)
			{
				Vector2 xzVector = Billiards.VectorExtension.ToXZ(in ballPosition);
				ballPosition = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, cueBallRadius);
			}
			cueBall.position = ballPosition;
			cueBall.OnState(BallState.SetState);
			cuePivot.position = cueBall.position;
			AightBallPoolGameLogic.gameState.cueBallMoved = true;
			TryCalculateShot(forceCalculate: true);
			if (this.OnUnselectBall != null)
			{
				this.OnUnselectBall();
			}
		}

		[Obsolete]
		private void TryingToSelectBall()
		{
		}

		[Obsolete]
		private void CheckActivateHand()
		{
		}

		private void TryingToMoveBall()
		{
			Vector3 currentData = MainHandController.ControllerRayOrigin.CurrentData;
			Vector3 direction = MainHandController.ControllerRayTarget.CurrentData - currentData;
			if (!Physics.Raycast(currentData, direction, out var hitInfo, 3f, clothLayer))
			{
				return;
			}
			Vector3 vector = hitInfo.point;
			Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
			Vector3 position = Geometry.ClampPositionInCube(Billiards.VectorExtension.ToVector3FromXZ(in xzVector, cueBallRadius), cueBallRadius, AightBallPoolGameLogic.gameState.tableIsOpened ? firstMoveSpace : clothSpace);
			if (!Physics.SphereCast(currentData, cueBallRadius, direction, out var hitInfo2, 3f, ballLayer))
			{
				cueBall.position = position;
				ballPosition = position;
				smoothBallPosition = ballPosition;
				cueBall.OnState(BallState.SetState);
				freeBallChecker.gameObject.SetActive(value: false);
				return;
			}
			BallListener ballListener = CacheManager.Get<BallListener>(hitInfo2.transform);
			if (ballListener != null && !ballListener.isInPocket)
			{
				freeBallChecker.position = position;
				freeBallChecker.gameObject.SetActive(value: true);
				freeBallCheckerUI.SetInvalid();
			}
			else
			{
				freeBallChecker.gameObject.SetActive(value: false);
			}
		}

		[Obsolete]
		private void ShowFreeballChecker()
		{
		}

		[Obsolete]
		public void StretchCue()
		{
		}

		private void ResetFromTargetingAtCueBall()
		{
			if (cueStateType == CueStateType.TargetingAtCueBall)
			{
				if (cueControlType == CueControlType.FirstPerson)
				{
					cueCamera.transform.position = cameraStandartPosition.position;
					cueCamera.transform.rotation = cameraStandartPosition.rotation;
				}
				cueSlider.localPosition = savedCueSliderLocalPosition;
				if (from2D)
				{
					uiController.is3D = false;
					uiController.CameraToggle();
					from2D = false;
				}
				cueStateType = CueStateType.TargetingAtTargetBall;
			}
		}

		public void ResetCueAfterTargeting()
		{
			cueSlider.localPosition = savedCueSliderLocalPosition;
		}

		public void ResetCueForTargeting()
		{
			cueDisplacement.localPosition = new Vector3(cueDisplacement.localPosition.x, cueDisplacement.localPosition.y, 0f);
			savedCueSliderLocalPosition = cueSlider.localPosition;
			cueSlider.localPosition = Vector3.zero;
		}

		public void SetCueTargetingPosition(Vector2 normalizedPosition)
		{
			cueDisplacement.localPosition = (cueDisplacementOnBall = normalizedPosition * cueBallRadius * 0.825f);
		}

		public void SetCueTargetingRotation(Vector2 position)
		{
		}

		[Obsolete]
		private void ControlIn2D(MouseState mouseState)
		{
		}

		[Obsolete]
		private IEnumerator MoveCameraToStandartPosition()
		{
			while (Vector3.Distance(cueCamera.transform.position, cameraStandartPosition.position) > 0.1f)
			{
				cueCamera.transform.position = Vector3.Lerp(cueCamera.transform.position, cameraStandartPosition.position, 10f * Time.deltaTime);
				cueCamera.transform.rotation = Quaternion.Lerp(cueCamera.transform.rotation, cameraStandartPosition.rotation, 10f * Time.deltaTime);
				yield return new WaitForEndOfFrame();
			}
			cueCamera.transform.position = cameraStandartPosition.position;
			cueCamera.transform.rotation = cameraStandartPosition.rotation;
		}

		[Obsolete]
		private void TargetingAtTargetBallInThirdPerson()
		{
		}

		[Obsolete]
		private void ControlIn3D(MouseState mouseState)
		{
		}

		public void OpponentStateFormNetwork(int gameState)
		{
			Billiards.Singleton<BilliardsDataContainer>.Instance.OpponentGameState.CurrentData = (GameStateType)gameState;
		}

		public void OpponentMainHandFormNetwork(bool isRightHanded)
		{
			Billiards.Singleton<BilliardsDataContainer>.Instance.OpponentMainHanded.CurrentData = isRightHanded;
		}

		private void OnMainHandChanged(bool isRightHanded)
		{
			OnDisable();
			IsRightHanded = isRightHanded;
			OnEnable();
		}

		public void SetState(GameStateType nextState)
		{
			UnityEngine.Debug.Log($"[input] '{currentGameState}' -> '{nextState}' ");
			switch (currentGameState)
			{
			case GameStateType.WaitingForOpponent:
				Billiards.Singleton<HandLineManager>.Instance.MainHand.RequestShow(enable: false, this);
				break;
			case GameStateType.SetBallPosition:
				freeBallChecker.gameObject.SetActive(value: false);
				Billiards.Singleton<HandLineManager>.Instance.MainHand.RequestShow(enable: false, this);
				TryCalculateShot(forceCalculate: true);
				if (hand.gameObject.activeInHierarchy)
				{
					hand.gameObject.SetActive(value: false);
				}
				ballInHand = false;
				break;
			case GameStateType.Shot:
				cuePivotLocalRotationYAdd = 0f;
				break;
			}
			switch (nextState)
			{
			case GameStateType.WaitingForOpponent:
				Billiards.Singleton<BilliardsDataContainer>.Instance.OpponentGameState.CurrentData = GameStateType.MoveAroundTable;
				MoveOutOfTable(delegate
				{
					SpaceController.enabled = true;
				});
				Billiards.Singleton<HandLineManager>.Instance.MainHand.RequestShow(enable: true, this);
				break;
			case GameStateType.MoveAroundTable:
				cuePivot.localEulerAngles = new Vector3(0f, cuePivot.localEulerAngles.y, cuePivot.localEulerAngles.z);
				cueVertical.localRotation = cueVerticalStartRotation;
				cueSliderDisplacementZ = 0f;
				cueSlider.localPosition = new Vector3(0f, 0f, cueSliderDisplacementZ);
				cueSlider.localEulerAngles = Vector3.zero;
				PermittedSpaceMoveRoutine.Stop();
				SpaceController.enabled = false;
				if (currentGameState == GameStateType.WaitingForOpponent)
				{
					Billiards.Singleton<BilliardsDataContainer>.Instance.TurnCount.CurrentData++;
					UnityEngine.Debug.Log("BilliardsDataContainer.Instance.TurnCount.CurrentData added : " + Billiards.Singleton<BilliardsDataContainer>.Instance.TurnCount.CurrentData);
				}
				break;
			case GameStateType.SetBallPosition:
				Billiards.Singleton<HandLineManager>.Instance.MainHand.RequestShow(enable: true, this);
				ReleaseCalculateShot();
				hand.gameObject.SetActive(value: true);
				ballInHand = true;
				this.OnSelectBall?.Invoke();
				break;
			case GameStateType.SelectShotDirection:
			{
				bool currentData = Billiards.Singleton<BilliardsDataContainer>.Instance.CueSnapState.CurrentData;
				LeftHandAnchor.GetChild(0).gameObject.SetActive(currentData);
				LeftHandAnchor.GetChild(1).gameObject.SetActive(!currentData);
				if (currentGameState != GameStateType.CameraFixAndWaitShot && SetToBestTarget((Billiards.Singleton<BilliardsDataContainer>.Instance.StandardCueBallCameraSlot.CurrentData.position - cuePivot.position).magnitude, out var position))
				{
					Vector3 lookPosition = cueBall.position;
					MoveToPosition(in position, in lookPosition);
				}
				AllowedSetCuePosition = true;
				cueSliderDisplacementZ = 0f;
				cueSlider.localPosition = new Vector3(0f, 0f, cueSliderDisplacementZ);
				cueSlider.localEulerAngles = Vector3.zero;
				cueVerticalLocalRotationXAdd = 0f;
				cuePivotLocalRotationYAdd = 0f;
				force = Mathf.Clamp01((0f - cueSliderDisplacementZ) / cueSlidingMaxDisplacement);
				SetCueTargetingPosition(Vector3.zero);
				break;
			}
			case GameStateType.CameraFixAndWaitShot:
				AllowedSetCuePosition = false;
				FixedRightHandPosition = MainHandController.Position.CurrentData;
				MaxCueSlideZDisplacement = 0f;
				break;
			case GameStateType.Shot:
				if (!inShot && force > 0.03f)
				{
					force -= 0.2f;
					force *= 1.25f;
					force = ForceMultipler.Evaluate(force);
					Billiards.Singleton<BilliardsDataContainer>.Instance.CueSnapState.CurrentData = false;
					inShot = true;
					inMove = true;
					Impulse impulse = new Impulse(shotPoint, force * (maxVelocity * physicsManager.ballMass) * cueSlider.forward);
					physicsManager.SetImpulse(impulse);
					UnityEngine.Debug.Log("in shot : impulse : " + impulse);
					WaitAndStartShotRoutine.StartSingleton(WaitAndStartShot());
					UnityEngine.Debug.Log("Force : " + force);
					InputDevice device2 = MainHandController.Controller.inputDevice;
					TrySendHaptic(in device2, force, 0.1f);
				}
				break;
			}
			currentGameState = nextState;
			static bool TrySendHaptic(in InputDevice device, float amplitude, float duration)
			{
				if (!device.TryGetHapticCapabilities(out var capabilities))
				{
					return false;
				}
				if (!capabilities.supportsImpulse)
				{
					return false;
				}
				device.SendHapticImpulse(0u, Mathf.Clamp01(amplitude * PublicGameUIManager.gameSetting.GetHapticValue()), duration);
				return true;
			}
		}

		private void SubControllerTrigger_OnDataChanged(bool isDown)
		{
			GameStateType gameStateType = currentGameState;
			if ((uint)(gameStateType - 3) <= 1u)
			{
				AllowedSetCuePosition = true;
				FixedRightHandPosition = MainHandController.Position.CurrentData;
			}
		}

		private void ControllerTrigger_OnDataChanged(bool isDown)
		{
			UnityEngine.Debug.Log("[input]Trigger Changed : " + isDown);
			if (!BallPoolPlayer.mainPlayer.myTurn)
			{
				return;
			}
			switch (currentGameState)
			{
			case GameStateType.SetBallPosition:
				if (isDown)
				{
					UnselectBall();
					SetState(GameStateType.SelectShotDirection);
				}
				break;
			case GameStateType.SelectShotDirection:
				if (isDown)
				{
					SetState(GameStateType.CameraFixAndWaitShot);
				}
				break;
			case GameStateType.CameraFixAndWaitShot:
				if (!isDown)
				{
					SetState(GameStateType.SelectShotDirection);
				}
				break;
			}
		}

		private void ControllerTrackButton_OnDataChanged(bool isDown)
		{
			UnityEngine.Debug.Log("[input]Track Changed : " + isDown);
			GameStateType gameStateType = currentGameState;
			if (gameStateType == GameStateType.SelectShotDirection)
			{
				if (isDown)
				{
					TouchInputTime = Time.time;
					Billiards.Singleton<BilliardsDataContainer>.Instance.TableBackgroundHider.CurrentData.ShowBlack();
					cueSlider.localPosition = new Vector3(0f, 0f, cueSliderDisplacementZ);
				}
				else
				{
					TouchInputTime = -1f;
					Billiards.Singleton<BilliardsDataContainer>.Instance.TableBackgroundHider.CurrentData.HideBlack();
				}
			}
			else if (!isDown)
			{
				TouchInputTime = -1f;
				Billiards.Singleton<BilliardsDataContainer>.Instance.TableBackgroundHider.CurrentData.HideBlack();
			}
		}

		private void Update()
		{
			if (Billiards.Singleton<InputDeviceInfo>.Instance.Allow2DAxisWithoutClick)
			{
				Billiards.Singleton<InputDeviceInfo>.Instance.Primary2DAxisInput.CurrentData = MainHandController.Primary2DAxisNotifier.CurrentData.magnitude > 0.01f;
			}
			switch (currentGameState)
			{
			case GameStateType.WaitingForOpponent:
				if (BallPoolPlayer.mainPlayer.myTurn)
				{
					SetState(GameStateType.MoveAroundTable);
				}
				break;
			case GameStateType.MoveAroundTable:
				if (!inMove)
				{
					if (!BallPoolPlayer.mainPlayer.myTurn)
					{
						UnityEngine.Debug.LogError("Player's turn is unclear. MyTurn is false but state is MoveAroundTable");
						SetState(GameStateType.WaitingForOpponent);
					}
					else if (AightBallPoolGameLogic.gameState.cueBallInHand && !AightBallPoolGameLogic.gameState.cueBallMoved)
					{
						SetState(GameStateType.SetBallPosition);
					}
					else
					{
						SetState(GameStateType.SelectShotDirection);
					}
				}
				break;
			case GameStateType.SetBallPosition:
				if (ballInHand)
				{
					TryingToMoveBall();
				}
				break;
			case GameStateType.SelectShotDirection:
				RotateAroundCueball();
				TryCalculateShot(forceCalculate: false);
				SetCuePosition();
				if (Billiards.Singleton<BilliardsDataContainer>.Instance.CueSnapState.CurrentData)
				{
					float num = Mathf.Clamp(Mathf.Abs(LeftHandAnchor.localPosition.z), 0.5f, 1f);
					LeftHandAnchor.localEulerAngles = new Vector3(Mathf.Lerp(-0.168f, 20f, (num - 0.5f) * 2f), 0f, 0f);
				}
				break;
			case GameStateType.CameraFixAndWaitShot:
			{
				bool useFixedPosition = true;
				SetCueHitPosition(in useFixedPosition);
				float num2 = Mathf.Clamp(Mathf.Abs(LeftHandAnchor.localPosition.z), 0.5f, 1f);
				LeftHandAnchor.localEulerAngles = new Vector3(Mathf.Lerp(-0.168f, 20f, (num2 - 0.5f) * 2f), 0f, 0f);
				Vector3 currentData = MainHandController.VelocityNotifier.CurrentData;
				float magnitude = (cueBall.position - cuePivot.position).magnitude;
				ShotDeltaForce = cueSlider.InverseTransformVector(Vector3.Project(currentData, cueSlider.forward)).z * Time.deltaTime;
				cueSliderDisplacementZ += ShotDeltaForce;
				cueSliderDisplacementZ = Mathf.Clamp(cueSliderDisplacementZ, 0f - cueSlidingMaxDisplacement, magnitude);
				cueSlider.localPosition = new Vector3(0f, 0f, cueSliderDisplacementZ);
				if (MaxCueSlideZDisplacement <= Mathf.Abs(cueSliderDisplacementZ))
				{
					MaxCueSlideZDisplacement = Mathf.Abs(cueSliderDisplacementZ) + magnitude;
				}
				TryCalculateShot(forceCalculate: false);
				if (!(cueSliderDisplacementZ > magnitude - 0.05f) || !(MaxCueSlideZDisplacement / cueSlidingMaxDisplacement > 0.1f))
				{
					break;
				}
				float shotDeltaForce = ShotDeltaForce;
				float start = 0f;
				float stop = 0.06f;
				float start2 = 0.1f;
				float stop2 = 1f;
				force = Billiards.VectorExtension.Remap(shotDeltaForce, in start, in stop, in start2, in stop2);
				if (force > 0.03f)
				{
					if (!Physics.Raycast(cueDisplacement.position, cueDisplacement.forward, out var hitInfo, 1.2f * clothSpace.lossyScale.x, cueBallLayer))
					{
						UnityEngine.Debug.Log("Break");
						break;
					}
					shotPoint = hitInfo.point;
					SetState(GameStateType.Shot);
				}
				break;
			}
			case GameStateType.Shot:
				if (AightBallPoolGameLogic.gameState.hasRightBallInPocket || !inMove)
				{
					SetState(GameStateType.MoveAroundTable);
				}
				break;
			}
		}

		[Obsolete("양손 모두 락이 있을 때 사용하던 코드")]
		private void RotateAroundPivot(LockMarker Target, float projectedLocalHorizontal, float projectedLocalVertical)
		{
			Target.InitializeAxis(cuePivot.position);
			Vector3 eulerAngles = cuePivot.eulerAngles;
			cuePivot.SetParent(Target.SimulationRoot, worldPositionStays: true);
			float xAmount = projectedLocalVertical * 0.5f * 0.55f;
			float yAmount = (0f - projectedLocalHorizontal) * 0.5f * 0.55f;
			Target.UpdateSimulationOffset(xAmount, yAmount);
			cuePivot.SetParent(null, worldPositionStays: true);
			Vector3 vector = cuePivot.eulerAngles - eulerAngles;
			cuePivot.localEulerAngles = new Vector3(0f, eulerAngles.y + vector.y, eulerAngles.z + vector.z);
			cueVertical.localEulerAngles = new Vector3(cueVertical.localEulerAngles.x + vector.x, cueVertical.localEulerAngles.y, cueVertical.localEulerAngles.z);
		}

		private void RotateAroundCueball()
		{
			if (!Billiards.Singleton<InputDeviceInfo>.Instance.isInitialized)
			{
				Billiards.Singleton<InputDeviceInfo>.Instance.Initialize();
			}
			if (!MainHandController[InputHelpers.Button.Primary2DAxisClick].CurrentData && !Billiards.Singleton<InputDeviceInfo>.Instance.Allow2DAxisWithoutClick)
			{
				return;
			}
			XRRig currentData = Billiards.Singleton<BilliardsDataContainer>.Instance.XRRigid.CurrentData;
			if (!(currentData == null))
			{
				Transform transform = Billiards.Singleton<BilliardsDataContainer>.Instance.MainCamera.CurrentData.transform;
				Vector2 vector = MainHandController.Primary2DAxisNotifier.CurrentData;
				float num = Mathf.Abs(Vector2.SignedAngle(Vector2.up, vector.normalized));
				Vector2 vector2 = ((num < 45f || num > 135f) ? Vector2.up : Vector2.right);
				if (vector.magnitude < 0.25f)
				{
					vector2 = Vector2.zero;
				}
				float amount = 0.25f;
				vector = Billiards.VectorExtension.Decrease(in vector, in amount) * 1f / 0.75f;
				float num2 = 2f;
				float num3 = Mathf.Pow(Mathf.Clamp01((Time.time - TouchInputTime) / num2), 2f);
				float num4 = (0f - vector.x) * 2f * num3 * vector2.x;
				float num5 = vector.y * 0.05f * num3 * 0.5f * vector2.y;
				float magnitude = (cueBall.position - transform.position).magnitude;
				if (magnitude < 0.8f && Mathf.Sign(num5) > 0f)
				{
					num5 = 0f;
				}
				if (magnitude > 1.3f && Mathf.Sign(num5) < 0f)
				{
					num5 = 0f;
				}
				Vector3 eulerAngles = Quaternion.LookRotation(cueBall.position - transform.position).eulerAngles;
				Vector3 vector3 = currentData.cameraGameObject.transform.eulerAngles - eulerAngles;
				Vector3 vector4 = cueBall.position + Quaternion.Euler(eulerAngles + Vector3.up * num4) * Vector3.back * (magnitude - num5);
				currentData.RotateAroundCameraUsingRigUp(Quaternion.LookRotation(cueBall.position - vector4).eulerAngles.y - currentData.cameraGameObject.transform.eulerAngles.y + vector3.y);
				Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector4);
				currentData.MoveCameraToWorldLocation(Billiards.VectorExtension.ToVector3FromXZ(in xzVector, currentData.cameraGameObject.transform.position.y));
			}
		}

		private void SetCuePosition()
		{
			MainControllerTracker = Vector3.Lerp(MainControllerTracker, MainHandController.Position.CurrentData, 0.075f);
			Billiards.Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChangedOnce += onCueSnapStateChanged;
			Appnori.Util.Notifier<bool> cueSnapState = Billiards.Singleton<BilliardsDataContainer>.Instance.CueSnapState;
			Vector3 overridiedRightPosition = default(Vector3);
			cueSnapState.CurrentData = GetControllerDirectionsAreSnap(out var _, out var _, in overridiedRightPosition);
			Billiards.Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChangedOnce -= onCueSnapStateChanged;
			bool isSnap2 = Billiards.Singleton<BilliardsDataContainer>.Instance.CueSnapState.CurrentData;
			SetCuePivotPosition(in isSnap2, out var dir);
			SetLeftHandPosition();
			SetCueRotation(in isSnap2);
			void SetCuePivotPosition(in bool isSnap, out Vector3 lookDir)
			{
				if (isSnap)
				{
					lookDir = cueBall.position - MainControllerTracker;
					cuePivot.position = cueBall.position - (lookDir * 100f).normalized * 0.1f;
					if (cuePivot.position.y < cueBallRadius + 0.008715574f)
					{
						Transform obj = cuePivot;
						Vector3 vector = cuePivot.position;
						Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
						obj.position = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, cueBallRadius + 0.008715574f);
					}
					ShotController shotController = this;
					bool useFixedPosition = true;
					shotController.SetCueHitPosition(in useFixedPosition);
				}
				else
				{
					lookDir = SubHandController.Position.CurrentData - MainHandController.Position.CurrentData;
					cuePivot.position = MainHandController.Position.CurrentData + lookDir.normalized * 0.9625f;
					FixedRightHandPosition = MainHandController.Position.CurrentData;
				}
			}
			void SetCueRotation(in bool isSnap)
			{
				if (isSnap)
				{
					Quaternion quaternion = Quaternion.LookRotation(dir, Vector3.up);
					float x = ((quaternion.eulerAngles.x > 90f) ? 5f : Mathf.Clamp(quaternion.eulerAngles.x, 5f, 90f));
					cueVertical.localRotation = Quaternion.Euler(x, 0f, 0f);
					cuePivot.localRotation = Quaternion.Euler(0f, quaternion.eulerAngles.y, 0f);
				}
				else
				{
					Quaternion quaternion2 = Quaternion.LookRotation(dir, Vector3.up);
					cueVertical.localRotation = Quaternion.Euler(quaternion2.eulerAngles.x, 0f, 0f);
					cuePivot.localRotation = Quaternion.Euler(0f, quaternion2.eulerAngles.y, 0f);
				}
			}
			void SetLeftHandPosition()
			{
				LeftHandAnchor.position = SubHandController.Position.CurrentData;
				LeftHandAnchor.localPosition = new Vector3(GameConfig.PlayerLeftHandDefaultLocalPosition.x, GameConfig.PlayerLeftHandDefaultLocalPosition.y, Mathf.Clamp(LeftHandAnchor.localPosition.z, -0.75f, -0.2f));
			}
			void onCueSnapStateChanged(bool isSnap)
			{
				if (isSnap)
				{
					SetCueTargetingPosition(Vector2.zero);
				}
				LeftHandAnchor.GetChild(0).gameObject.SetActive(isSnap);
				LeftHandAnchor.GetChild(1).gameObject.SetActive(!isSnap);
			}
		}

		private bool GetControllerDirectionsAreSnap(out Vector3 d1, out Vector3 d2, in Vector3 overridiedRightPosition = default(Vector3))
		{
			if (overridiedRightPosition != default(Vector3))
			{
				d1 = SubHandController.Position.CurrentData - overridiedRightPosition;
				d2 = cueBall.position - overridiedRightPosition;
				return Vector3.Angle(d1, d2) < 10f;
			}
			d1 = SubHandController.Position.CurrentData - MainHandController.Position.CurrentData;
			d2 = cueBall.position - MainHandController.Position.CurrentData;
			return Vector3.Angle(d1, d2) < 10f;
		}

		private void SetCueHitPosition(in bool useFixedPosition = false)
		{
			if ((!useFixedPosition || AllowedSetCuePosition) && SubHandController[InputHelpers.Button.Trigger].CurrentData)
			{
				Vector3 overridiedRightPosition = (useFixedPosition ? FixedRightHandPosition : default(Vector3));
				GetControllerDirectionsAreSnap(out var d, out var d2, in overridiedRightPosition);
				Vector3 normalized = cueSlider.InverseTransformVector(d).normalized;
				Vector3 normalized2 = cueSlider.InverseTransformVector(d2).normalized;
				overridiedRightPosition = normalized - normalized2;
				SetCueTargetingPosition(Billiards.VectorExtension.ToVector2(in overridiedRightPosition) * 4.8f);
			}
		}

		private void MoveOutOfTable(Action onComplete)
		{
			Vector3 playerPosition = Billiards.Singleton<BilliardsDataContainer>.Instance.XRRigid.CurrentData.cameraGameObject.transform.position;
			if (!Geometry.SphereInCube(playerPosition, -0.15f, TableSpace))
			{
				onComplete?.Invoke();
			}
			else
			{
				PermittedSpaceMoveRoutine.StartSingleton(DelayMove()).SetOnComplete(onComplete);
			}
			IEnumerator DelayMove()
			{
				yield return new WaitWhile(isInMove);
				Vector3 vector = cueBall.position;
				Vector2 direction = (Billiards.VectorExtension.ToXZ(in playerPosition) - Billiards.VectorExtension.ToXZ(in vector)) * 100f;
				Vector3 vector2 = Vector3.Lerp(playerPosition, vector, 0.5f);
				Vector2 xzVector = Geometry.EdgeProjectionXZ(direction, Billiards.VectorExtension.ToXZ(in vector2), TableSpace);
				ShotController shotController = this;
				vector2 = Billiards.VectorExtension.ToVector3FromXZ(in xzVector) * 1.25f;
				Vector3 lookPosition = cueBall.position;
				shotController.MoveToPosition(in vector2, in lookPosition);
			}
			bool isInMove()
			{
				return inMove;
			}
		}

		private void MoveToPosition(in Vector3 position, in Vector3 lookPosition)
		{
			XRRig currentData = Billiards.Singleton<BilliardsDataContainer>.Instance.XRRigid.CurrentData;
			Vector2 xzVector = Billiards.VectorExtension.ToXZ(in position);
			currentData.MoveCameraToWorldLocation(Billiards.VectorExtension.ToVector3FromXZ(in xzVector, currentData.cameraGameObject.transform.position.y));
			currentData.RotateAroundCameraUsingRigUp(Quaternion.LookRotation(lookPosition - currentData.cameraGameObject.transform.position).eulerAngles.y - currentData.cameraGameObject.transform.eulerAngles.y);
		}

		private bool SetToBestTarget(float distance, out Vector3 position)
		{
			position = Vector3.zero;
			BestTargetBallInfo calculateInfo = aiManager.GetCalculateInfo(cueBall, physicsManager.ballMaxVelocity);
			if (calculateInfo.targetBall == null)
			{
				return false;
			}
			Vector3 vector = calculateInfo.impulse * (calculateInfo.targetBall.position - calculateInfo.shotBallPosition).normalized;
			Vector2 xzVector = Billiards.VectorExtension.ToXZ(in calculateInfo.shotBallPosition);
			Vector3 vector2 = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, cueBall.position.y);
			Vector3 vector3 = Vector3.ProjectOnPlane(vector.normalized, Vector3.up);
			position = vector2 + -vector3 * distance;
			return true;
		}

		private IEnumerator AIStartAnimation(Action onComplete)
		{
			yield return StartCoroutine(AICueBallAnimation());
			yield return StartCoroutine(AICueRotateAnimation(0.8f));
			yield return StartCoroutine(AICueSliderAnimation(2.2f));
			onComplete();
		}

		private IEnumerator AICueBallAnimation(float runtime = 1f)
		{
			Vector3 defaultPosition = cueBall.position;
			Vector3 targetPosition = aiManager.info.shotBallPosition;
			if (defaultPosition != targetPosition)
			{
				float t = 0f;
				while (t < runtime)
				{
					cueBall.position = Vector3.Lerp(defaultPosition, targetPosition, t / runtime);
					t += Time.deltaTime;
					cueBall.OnState(BallState.SetState);
					yield return null;
				}
			}
			cueBall.position = aiManager.info.shotBallPosition;
			cueBall.OnState(BallState.SetState);
		}

		private IEnumerator AICueRotateAnimation(float runtime = 1f)
		{
			ballChecker.position = aiManager.info.aimpoint;
			ballChecker.gameObject.SetActive(value: true);
			shotPoint = aiManager.info.shotPoint;
			cuePivot.position = aiManager.info.shotBallPosition;
			cueDisplacement.position = shotPoint;
			cueDisplacement.localPosition += new Vector3(0f, 0f, -0.09f);
			Vector3 impulseVectorCustom = Vector3.ProjectOnPlane((aiManager.info.impulse * (aiManager.info.aimpoint - aiManager.info.shotBallPosition).normalized).normalized, Vector3.up) + new Vector3(0f, -0.0875f, 0f);
			Quaternion defaultPivotRotation = cuePivot.rotation;
			Quaternion targetPivotRotation = Quaternion.LookRotation(impulseVectorCustom);
			float t = 0f;
			while (t < runtime)
			{
				cuePivot.rotation = Quaternion.Lerp(defaultPivotRotation, targetPivotRotation, t / runtime);
				TryCalculateShot(forceCalculate: true);
				t += Time.deltaTime;
				yield return null;
			}
			cuePivot.LookAt(cuePivot.position + impulseVectorCustom);
			cueSlider.forward = impulseVectorCustom;
			TryCalculateShot(forceCalculate: true);
		}

		private IEnumerator AICueSliderAnimation(float runtime = 3f)
		{
			float displacement = aiManager.info.impulse / physicsManager.ballMaxVelocity * cueSlidingMaxDisplacement;
			float defaultSliderDisZ = cueSliderDisplacementZ;
			float targetSliderDisZ = 0f - displacement;
			Vector3 defaultSliderLocalPosition = cueSlider.localPosition;
			Vector3 targetSliderLocalPosition = new Vector3(0f, 0f, 0f - displacement);
			float t = 0f;
			while (t < runtime)
			{
				cueSliderDisplacementZ = Mathf.Lerp(defaultSliderDisZ, targetSliderDisZ, CueSliderAnimationCurve.Evaluate(t / runtime));
				cueSlider.localPosition = Vector3.Lerp(defaultSliderLocalPosition, targetSliderLocalPosition, CueSliderAnimationCurve.Evaluate(t / runtime));
				t += Time.deltaTime;
				yield return null;
			}
			cueSliderDisplacementZ = 0f - displacement;
			cueSlider.localPosition = new Vector3(0f, 0f, 0f - displacement);
			ResetChanged();
			TryCalculateShot(forceCalculate: true);
		}
	}
	public class ThreDTwoDManager : MonoBehaviour
	{
		[SerializeField]
		private ShotController shotController;

		[SerializeField]
		private RectTransform cueBallTargetngImage;

		[SerializeField]
		private GameObject threDTable;

		[SerializeField]
		private GameObject twoDTable;

		[SerializeField]
		private Transform ballsConteyner;

		private Transform[] balls;

		private Transform[] ballsShadow;

		private Transform[] ballsBlick;

		[SerializeField]
		private Transform ballShadow;

		[SerializeField]
		private Transform ballBlick;

		[SerializeField]
		private Material balls3DMaterial;

		[SerializeField]
		private Material balls2DMaterial;

		[SerializeField]
		private MeshRenderer ballChecker;

		[SerializeField]
		private Material ballChecker3DMaterial;

		[SerializeField]
		private Material ballChecker2DMaterial;

		[SerializeField]
		private MeshRenderer hand;

		[SerializeField]
		private Material[] hand3DMaterial;

		[SerializeField]
		private Material[] hand2DMaterial;

		[SerializeField]
		private GameObject cue3D;

		[SerializeField]
		private GameObject cue2D;

		[SerializeField]
		private RectTransform[] hideOn2D;

		[SerializeField]
		private RectTransform[] hideOn3D;

		private void Awake()
		{
			if (!NetworkManager.initialized)
			{
				return;
			}
			threDTable.SetActive(AightBallPoolNetworkGameAdapter.is3DGraphics);
			twoDTable.SetActive(!AightBallPoolNetworkGameAdapter.is3DGraphics);
			balls = new Transform[ballsConteyner.childCount];
			ballsShadow = new Transform[balls.Length];
			ballsBlick = new Transform[balls.Length];
			ballChecker.sharedMaterial = (AightBallPoolNetworkGameAdapter.is3DGraphics ? ballChecker3DMaterial : ballChecker2DMaterial);
			hand.sharedMaterials = (AightBallPoolNetworkGameAdapter.is3DGraphics ? hand3DMaterial : hand2DMaterial);
			cue3D.SetActive(AightBallPoolNetworkGameAdapter.is3DGraphics);
			cue2D.SetActive(!AightBallPoolNetworkGameAdapter.is3DGraphics);
			for (int i = 0; i < ballsConteyner.childCount; i++)
			{
				balls[i] = ballsConteyner.GetChild(i);
				balls[i].GetComponent<MeshRenderer>().sharedMaterial = (AightBallPoolNetworkGameAdapter.is3DGraphics ? balls3DMaterial : balls2DMaterial);
				ballsShadow[i] = UnityEngine.Object.Instantiate(ballShadow);
				ballsShadow[i].transform.parent = base.transform;
				ballsShadow[i].transform.position = balls[i].position;
				Ball component = balls[i].GetComponent<Ball>();
				component.lightCentre = base.transform;
				component.ballShadow = ballsShadow[i];
				if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
				{
					ballsBlick[i] = UnityEngine.Object.Instantiate(ballBlick);
					ballsBlick[i].transform.parent = base.transform;
					ballsBlick[i].transform.position = balls[i].position;
					component.ballBlick = ballsBlick[i];
				}
			}
			RectTransform[] array = hideOn3D;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].gameObject.SetActive(!AightBallPoolNetworkGameAdapter.is3DGraphics);
			}
			array = hideOn2D;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].gameObject.SetActive(AightBallPoolNetworkGameAdapter.is3DGraphics);
			}
			if (shotController.cueControlType == ShotController.CueControlType.ThirdPerson)
			{
				cueBallTargetngImage.gameObject.SetActive(value: true);
			}
			UnityEngine.Object.Destroy(ballShadow.gameObject);
			UnityEngine.Object.Destroy(ballBlick.gameObject);
			base.enabled = false;
		}
	}
	public class GameManager : MonoBehaviour
	{
		[SerializeField]
		private UIIngameDisplay IngameDisplay;

		[SerializeField]
		private Text prize;

		[SerializeField]
		private Text gameInfo;

		[SerializeField]
		private Text aiCountText;

		public PlayAgainMenu playAgainMenu;

		[SerializeField]
		private GameUIController gameUIController;

		public ShotController shotController;

		[SerializeField]
		private PhysicsManager physicsManager;

		[SerializeField]
		private BallPoolAIManager aiManager;

		public PlayerManager playerManager;

		public Ball[] balls;

		private bool playAgainMenuIsActive;

		private AightBallPoolGameManager aightBallPoolGameManager;

		private bool applicationIsPaused;

		private int applicationPauseSeconds;

		private bool gameInfoInProgress;

		public bool RequestRematch
		{
			get
			{
				return gameUIController.RequestRematch;
			}
			set
			{
				gameUIController.RequestRematch = value;
			}
		}

		private void Awake()
		{
			UnityEngine.Application.targetFrameRate = 120;
			if (!NetworkManager.initialized)
			{
				UnityEngine.Debug.LogWarning("not initialized");
				gameUIController.GoHome();
				base.enabled = false;
				return;
			}
			UIIngameDisplay.OnInitializedEvent += delegate(UIIngameDisplay instance)
			{
				IngameDisplay = instance;
			};
			DataManager.SaveGameData();
			UpdateAICount();
			if (BallPoolGameLogic.playMode == PlayMode.Replay)
			{
				base.enabled = false;
				shotController.enabled = false;
				TriggerPlayAgainMenu(isOn: false);
				physicsManager.OnBallMove += delegate(int ballId, Vector3 position, Vector3 velocity, Vector3 angularVelocity)
				{
					if (balls[ballId].inPocket)
					{
						balls[ballId].OnState(BallState.MoveInPocket);
					}
					else
					{
						balls[ballId].OnState(BallState.Move);
					}
				};
			}
			else
			{
				NetworkManager.network.OnNetwork += NetworkManager_network_OnNetwork;
				aightBallPoolGameManager = new AightBallPoolGameManager();
				aightBallPoolGameManager.Initialize(physicsManager, aiManager, balls);
				aightBallPoolGameManager.maxPlayTime = 50f;
				aightBallPoolGameManager.OnEndTime += AightBallPoolGameManager_OnEndTime;
				aightBallPoolGameManager.OnSetGameInfo += AightBallPoolGameManager_OnSetGameInfo;
				gameUIController.OnForceGoHome += GameUIController_OnForceGoHome;
				gameUIController.OnRequestRematch += GameUIController_OnRequestRematch;
				aightBallPoolGameManager.gameLogic = new AightBallPoolGameLogic();
				PublicGameUIManager.GetInstance.AddLoadLobbyEvent(gameUIController.OnPauseGoHome);
			}
		}

		private void Start()
		{
			TriggerPlayAgainMenu(isOn: false);
			aightBallPoolGameManager.OnCalculateAI += AightBallPoolGameManager_OnCalculateAI;
			aightBallPoolGameManager.OnSetPlayer += AightBallPoolGameManager_OnSetPlayer;
			aightBallPoolGameManager.OnSetActivePlayer += AightBallPoolGameManager_OnSetActivePlayer;
			aightBallPoolGameManager.OnGameComplite += AightBallPoolGameManager_OnGameComplite;
			aightBallPoolGameManager.OnSetActiveBallsIds += AightBallPoolGameManager_OnSetActiveBallsIds;
			aightBallPoolGameManager.OnEnableControl += shotController.OnEnableControl;
			shotController.OnEndCalculateAI += ShotController_OnEndCalculateAI;
			shotController.OnSelectBall += ShotController_OnSelectBall;
			shotController.OnUnselectBall += ShotController_OnUnselectBall;
			physicsManager.OnSaveEndStartReplay += PhysicsManager_OnSaveEndStartReplay;
			aightBallPoolGameManager.Start();
			if (BallPoolGameLogic.isOnLine)
			{
				NetworkManager.network.SendRemoteMessage("OnOpponenWaitingForYourTurn");
				NetworkManager.network.SendRemoteMessage("OnOpponenInGameScene");
				StartCoroutine(UpdateNetworkTime());
				StartCoroutine(UpdateNetworkEnvironment());
			}
			gameInfo.text = (BallPoolPlayer.mainPlayer.myTurn ? "Your turn" : "Your opponent turn") + "\nGood lack!";
			StartCoroutine(HideGameInfoText(gameInfo.text));
			Resources.UnloadUnusedAssets();
		}

		private void Update()
		{
			aightBallPoolGameManager.Update(Time.deltaTime);
			IngameDisplay.SetTime(aightBallPoolGameManager.playTime);
			if (BallPoolGameLogic.controlFromNetwork && !shotController.inMove && !physicsManager.inMove)
			{
				shotController.UpdateFromNetwork();
			}
		}

		public void SetBallsState(int number)
		{
			for (int i = 0; i < balls.Length; i++)
			{
				balls[i].SetMechanicalState(number);
			}
		}

		private IEnumerator UpdateNetworkTime()
		{
			while (NetworkManager.network != null)
			{
				if (BallPoolGameLogic.controlInNetwork && !shotController.inMove)
				{
					yield return new WaitForSeconds(0.1f);
					SendToNetwork();
				}
				else
				{
					yield return null;
				}
			}
		}

		private IEnumerator UpdateNetworkEnvironment()
		{
			while (NetworkManager.network != null)
			{
				if (BallPoolGameLogic.controlInNetwork || BallPoolGameLogic.controlFromNetwork)
				{
					yield return new WaitForSeconds(0.075f);
					SendToNetworkEnvironment();
				}
				else
				{
					yield return null;
				}
			}
		}

		private void PhysicsManager_OnSaveEndStartReplay(string impulse)
		{
			NetworkManager.network.OnMadeTurn();
			if (BallPoolGameLogic.controlInNetwork)
			{
				NetworkManager.network.SendRemoteMessage("StartSimulate", impulse);
				NetworkManager.network.SendRemoteMessage("StartSimulate", impulse);
				NetworkManager.network.SendRemoteMessage("StartSimulate", impulse);
			}
		}

		private void SendToNetwork()
		{
			if ((bool)NetworkManager.network && aightBallPoolGameManager != null)
			{
				NetworkManager.network.SendRemoteMessage("OnSendTime", aightBallPoolGameManager.playTime);
				if (shotController.cueChanged)
				{
					NetworkManager.network.SendRemoteMessage("OnSendCueControl", shotController.cuePivot.localPosition, shotController.cuePivot.localRotation.eulerAngles.y, shotController.cueVertical.localRotation.eulerAngles.x, new Vector2(shotController.cueDisplacement.localPosition.x, shotController.cueDisplacement.localPosition.y), shotController.cueSlider.localPosition.z, shotController.force);
				}
				if (shotController.ballChanged)
				{
					UnityEngine.Debug.LogWarning("ballChanged");
					NetworkManager.network.SendRemoteMessage("OnMoveBall", shotController.cueBall.position);
				}
			}
		}

		private void SendToNetworkEnvironment()
		{
			if (playerManager.Mine.isDirty)
			{
				NetworkManager.network.SendRemoteMessage("SendPlayerTransform", AightBallPoolPlayer.mainPlayer.uuid, playerManager.Mine.worldPosition, playerManager.Mine.worldRotation, playerManager.Mine.LHandPosition, playerManager.Mine.LHandRotation, playerManager.Mine.RHandPosition, playerManager.Mine.RHandRotation);
			}
			NetworkManager.network.SendRemoteMessage("OnSendGameState", (int)Billiards.Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
			NetworkManager.network.SendRemoteMessage("OnSendMainHanded", ShotController.IsRightHanded ? 1 : 0);
		}

		private void SendToNetworkOnEnd()
		{
			UnityEngine.Debug.LogWarning("SendToNetworkOnEnd");
			NetworkManager.network.SendRemoteMessage("OnSendTime", aightBallPoolGameManager.playTime);
			NetworkManager.network.SendRemoteMessage("OnSendTime", aightBallPoolGameManager.playTime);
			NetworkManager.network.SendRemoteMessage("OnSendTime", aightBallPoolGameManager.playTime);
		}

		private void ShotController_OnSelectBall()
		{
			if (BallPoolGameLogic.controlInNetwork)
			{
				NetworkManager.network.SendRemoteMessage("SelectBallPosition", shotController.cueBall.position);
			}
		}

		private void ShotController_OnUnselectBall()
		{
			if (BallPoolGameLogic.isOnLine)
			{
				UnityEngine.Debug.LogWarning("ShotController_OnUnselectBall" + BallPoolGameLogic.controlInNetwork);
				NetworkManager.network.SendRemoteMessage("SetBallPosition", shotController.cueBall.position);
			}
		}

		private void OnDisable()
		{
			if (aightBallPoolGameManager != null)
			{
				aightBallPoolGameManager.OnDisable();
				aightBallPoolGameManager = null;
			}
			NetworkManager.Disable();
		}

		private void NetworkManager_network_OnNetwork(NetworkState state)
		{
			UnityEngine.Debug.Log("NetworkManager_network_OnNetwork " + state);
			if (BallPoolGameLogic.playMode == PlayMode.OnLine && state != NetworkState.Connected)
			{
				shotController.enabled = false;
				StartCoroutine(WaitAndGoToHome(state));
			}
		}

		private IEnumerator WaitAndGoToHome(NetworkState state)
		{
			yield return new WaitForEndOfFrame();
			yield return new WaitForEndOfFrame();
			base.enabled = false;
			if (!playAgainMenu.wasOpened && state == NetworkState.LeftRoom)
			{
				OpenPlayAgainMenuForMainPlayer();
			}
			else if (playAgainMenu.wasOpened || state == NetworkState.LostConnection)
			{
				gameUIController.GoHome();
			}
		}

		public void UpdateAICount()
		{
		}

		private void OpenPlayAgainMenuForMainPlayer()
		{
			shotController.shotBack.enabled = false;
			BallPoolPlayer.SetWinner(BallPoolPlayer.mainPlayer.playerId);
			int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(BallPoolPlayer.mainPlayer.name);
			PublicGameUIManager.GetInstance.OpenResultBoard(GameSettingCtrl.GetLocalizationText("0034"), winnerPlayer);
			IngameDisplay.SetPlayer(AightBallPoolPlayer.mainPlayer);
			IngameDisplay.SetPlayer(AightBallPoolPlayer.otherPlayer);
		}

		private void GameUIController_OnForceGoHome()
		{
			if (BallPoolGameLogic.isOnLine)
			{
				NetworkManager.network.SendRemoteMessage("OnOpponentForceGoHome");
			}
			if (BallPoolGameManager.instance != null)
			{
				BallPoolGameManager.instance.OnForceGoHome(AightBallPoolPlayer.otherPlayer.playerId);
			}
		}

		private void GameUIController_OnRequestRematch(bool isRequested)
		{
			NetworkManager.network.SendRemoteMessage("SendRequestRematch", isRequested);
		}

		private void TriggerPlayAgainMenu(bool isOn)
		{
			if (isOn)
			{
				shotController.shotBack.enabled = false;
				BallPoolPlayer winner = BallPoolPlayer.GetWinner();
				IngameDisplay.SetPlayer(AightBallPoolPlayer.mainPlayer);
				IngameDisplay.SetPlayer(AightBallPoolPlayer.otherPlayer);
				int winnerPlayer = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(BallPoolPlayer.GetWinner().name);
				if (AightBallPoolPlayer.mainPlayer.uuid.Equals(AightBallPoolPlayer.otherPlayer.uuid))
				{
					winnerPlayer = winner.playerId;
					if (!PhotonNetwork.IsMasterClient)
					{
						winnerPlayer = ((winner.playerId == 0) ? 1 : 0);
					}
				}
				PublicGameUIManager.GetInstance.OpenResultBoard(new string[2] { "", "" }, winnerPlayer);
				if (winner == AightBallPoolPlayer.mainPlayer)
				{
					UnityEngine.Debug.Log("BilliardsDataContainer.Instance.TurnCount.CurrentData : " + Billiards.Singleton<BilliardsDataContainer>.Instance.TurnCount.CurrentData);
					if (Billiards.Singleton<BilliardsDataContainer>.Instance.TurnCount.CurrentData == 1)
					{
						SingletonBase.Singleton<UserInfoManager>.GetInstance.UnlockAchieve("Ach24", 1);
					}
					if (BallPoolGameLogic.playMode != PlayMode.Solo)
					{
						EyeAnimationCtrl.GetInstance.SetExpression(2, 3f);
					}
					if (BallPoolGameLogic.playMode == PlayMode.PlayerAI || BallPoolGameLogic.playMode == PlayMode.Solo)
					{
						SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
					}
				}
				else
				{
					EyeAnimationCtrl.GetInstance.SetExpression(1, 3f);
				}
			}
			else
			{
				playAgainMenu.Hide();
			}
		}

		private void AightBallPoolGameManager_OnEndTime()
		{
			if (BallPoolGameLogic.controlInNetwork)
			{
				SendToNetworkOnEnd();
			}
			shotController.OnEndTime();
			shotController.UndoShot();
		}

		private void AightBallPoolGameManager_OnSetGameInfo(string info)
		{
			StartCoroutine(HideGameInfoText(info));
		}

		private IEnumerator HideGameInfoText(string info)
		{
			while (gameInfoInProgress)
			{
				yield return null;
			}
			gameInfoInProgress = true;
			gameInfo.text = info;
			yield return new WaitForSeconds(5f);
			gameInfo.text = "";
			gameInfoInProgress = false;
		}

		private void AightBallPoolGameManager_OnSetPlayer(BallPoolPlayer player)
		{
			IngameDisplay.SetPlayer(player);
		}

		[Obsolete]
		private IEnumerator DownloadAndSetAvatar(BallPoolPlayer player)
		{
			yield break;
		}

		private IEnumerator WaitAndShotAI()
		{
			yield return new WaitForSeconds(0.3f);
			if (!shotController.inMove && !shotController.activateAfterCalculateAI)
			{
				gameUIController.Shot(follow: false);
			}
		}

		private void AightBallPoolGameManager_OnSetActiveBallsIds(BallPoolPlayer player)
		{
			IngameDisplay.SetActiveBallsIds(player);
		}

		private void AightBallPoolGameManager_OnGameComplite()
		{
			shotController.enabled = false;
			TriggerPlayAgainMenu(isOn: true);
		}

		private void AightBallPoolGameManager_OnSetActivePlayer(BallPoolPlayer player, bool value)
		{
			IngameDisplay.SetTurn(player.playerId, value);
			if (player.playerId == 0)
			{
				if (value)
				{
					shotController.SetState(ShotController.GameStateType.MoveAroundTable);
				}
				else
				{
					shotController.SetState(ShotController.GameStateType.WaitingForOpponent);
				}
			}
		}

		private void AightBallPoolGameManager_OnCalculateAI()
		{
			shotController.enabled = false;
			StopCoroutine("WaitAndCalculateAI");
			StartCoroutine("WaitAndCalculateAI");
		}

		private IEnumerator WaitAndCalculateAI()
		{
			yield return new WaitForSeconds(0.3f);
			aiManager.CalculateAI();
		}

		private void ShotController_OnEndCalculateAI()
		{
			StartCoroutine(WaitAndShotAI());
		}
	}
	public class GameUIController : MonoBehaviour
	{
		[SerializeField]
		private PhysicsManager physicsManager;

		[SerializeField]
		private GameManager gameManager;

		[SerializeField]
		private RectTransform replayUI;

		[SerializeField]
		private RectTransform gameUI;

		[SerializeField]
		private Text cameraToggleText;

		[SerializeField]
		private Toggle shotOnUpToggle;

		[SerializeField]
		private Button shotButton;

		[SerializeField]
		private Dropdown replayNumber;

		[SerializeField]
		private RectTransform camera3DTargetngImage;

		[SerializeField]
		private Camera cueCamera;

		[NonSerialized]
		public bool shotOnUp;

		[SerializeField]
		private Slider forceSlider;

		[SerializeField]
		private string homeScene;

		[SerializeField]
		private string playScene;

		public int replayNumberValue { get; private set; }

		public bool is3D
		{
			get
			{
				return true;
			}
			set
			{
			}
		}

		public bool RequestRematch { get; set; }

		public event Action<bool> OnShot;

		public event Action OnForceGoHome;

		public event Action<bool> OnRequestRematch;

		private void Awake()
		{
			if (!NetworkManager.initialized)
			{
				base.enabled = false;
				return;
			}
			if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
			{
				is3D = false;
			}
			else
			{
				is3D = DataManager.GetIntData("Is3D") == 1;
			}
			camera3DTargetngImage.gameObject.SetActive(is3D && gameManager.shotController.cueControlType == ShotController.CueControlType.ThirdPerson);
			shotOnUp = DataManager.GetIntData("ShotOnUp") == 0;
			shotButton.image.enabled = !shotOnUp;
			shotButton.enabled = !shotOnUp;
			shotButton.GetComponentInChildren<Text>().text = (shotOnUp ? "Auto shot" : "");
			shotOnUpToggle.isOn = shotOnUp;
			CameraToggle();
			ControlChanged();
			OnTriggerAutoShot();
		}

		private void Start()
		{
			if (BallPoolGameLogic.playMode == PlayMode.Replay)
			{
				replayNumber.options = new List<Dropdown.OptionData>(0);
				replayNumberValue = 0;
				int replayDataCount = physicsManager.replayManager.GetReplayDataCount();
				UnityEngine.Debug.Log("replayCount " + replayDataCount);
				for (int i = 0; i < replayDataCount; i++)
				{
					replayNumber.options.Add(new Dropdown.OptionData("Replay " + i));
				}
				replayNumber.value = 1;
				replayNumber.value = 0;
			}
		}

		public void OnReplayNumberChanged()
		{
			if (BallPoolGameLogic.playMode == PlayMode.Replay)
			{
				replayNumberValue = replayNumber.value;
				UnityEngine.Debug.Log("replayNumber " + replayNumberValue);
				gameManager.SetBallsState(replayNumber.value);
			}
		}

		public void SetReplayNumber(int replayNumberValue, bool setReplay)
		{
			this.replayNumberValue = replayNumberValue;
			replayNumber.value = replayNumberValue;
			if (setReplay)
			{
				gameManager.SetBallsState(replayNumber.value);
			}
		}

		public void OnControlChanged()
		{
			ControlChanged();
		}

		public void ControlChanged()
		{
			replayUI.gameObject.SetActive(BallPoolGameLogic.playMode == PlayMode.Replay);
			gameUI.gameObject.SetActive(!replayUI.gameObject.activeSelf);
			OnReplayNumberChanged();
		}

		[Obsolete]
		public void OnCameraToggle()
		{
			is3D = !is3D;
			camera3DTargetngImage.gameObject.SetActive(is3D && gameManager.shotController.cueControlType == ShotController.CueControlType.ThirdPerson);
			DataManager.SetIntData("Is3D", is3D ? 1 : 0);
			CameraToggle();
		}

		public void OnTriggerAutoShot()
		{
			shotOnUp = shotOnUpToggle.isOn;
			shotButton.GetComponent<Image>().enabled = !shotOnUp;
			shotButton.image.enabled = !shotOnUp;
			shotButton.enabled = !shotOnUp;
			shotButton.GetComponentInChildren<Text>().text = (shotOnUp ? "Auto shot" : "");
			DataManager.SetIntData("ShotOnUp", (!shotOnUp) ? 1 : 0);
			forceSlider.gameObject.SetActive(!shotOnUp || InputOutput.isMobilePlatform);
		}

		public void Shot(bool follow)
		{
			if (this.OnShot != null)
			{
				this.OnShot(follow);
			}
		}

		public void Play()
		{
			physicsManager.Disable();
			SceneManager.LoadScene(playScene);
			SceneManager.LoadScene("Home_map", LoadSceneMode.Additive);
		}

		public void Rematch(bool nextStage)
		{
			if (BallPoolGameLogic.playMode == PlayMode.OnLine)
			{
				this.OnRequestRematch?.Invoke(obj: true);
				StartCoroutine(WaitUntilRematch(Play));
				return;
			}
			if (nextStage)
			{
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level++;
				Initializer.SinglePlayInitializer(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level);
			}
			Play();
		}

		public void OnPauseGoHome()
		{
			UnityEngine.Debug.LogWarning("opponenIsReadToPlay " + gameManager.shotController.opponenIsReadToPlay);
			if (gameManager.shotController.opponenIsReadToPlay && BallPoolGameLogic.playMode == PlayMode.OnLine && this.OnForceGoHome != null)
			{
				this.OnForceGoHome();
			}
			physicsManager.Disable();
			if (NetworkManager.mainPlayer != null)
			{
				NetworkManager.mainPlayer.state = PlayerState.Online;
			}
		}

		public void GoHome()
		{
			physicsManager.Disable();
			if (NetworkManager.mainPlayer != null)
			{
				NetworkManager.mainPlayer.state = PlayerState.Online;
			}
			SceneManager.LoadScene(homeScene);
		}

		public void ForceGoHome()
		{
			UnityEngine.Debug.LogWarning("opponenIsReadToPlay " + gameManager.shotController.opponenIsReadToPlay);
			if (gameManager.shotController.opponenIsReadToPlay && BallPoolGameLogic.playMode == PlayMode.OnLine && this.OnForceGoHome != null)
			{
				this.OnForceGoHome();
			}
			GoHome();
		}

		public void CameraToggle()
		{
			cameraToggleText.text = (is3D ? "2D" : "3D");
			InputOutput.usedCamera = cueCamera;
		}

		public IEnumerator WaitUntilRematch(Action onComplete)
		{
			yield return new WaitUntil(() => RequestRematch);
			onComplete?.Invoke();
		}
	}
	public class BallListener : MonoBehaviour
	{
		public int id;

		public Rigidbody body;

		public PhysicsManager physicsManager;

		private bool firstHit;

		private bool inMove;

		public PocketListener pocket { get; set; }

		public float radius { get; private set; }

		public int pocketId { get; set; }

		public int hitShapeId { get; set; }

		public bool isInPocket => body.isKinematic;

		public Vector3 normalizedVelocity => body.velocity / physicsManager.ballMaxVelocity;

		private void OnCollisionEnter(Collision other)
		{
			if (physicsManager.inMove)
			{
				firstHit = true;
			}
			if (!firstHit && other.gameObject.layer == Layer.NameToLayer(Layer.GameType.Billiards, "Cloth"))
			{
				firstHit = true;
				if (id != 0)
				{
					body.Sleep();
				}
			}
		}

		public void OnTriggerEnter(Collider other)
		{
			if (BallPoolGameLogic.playMode != PlayMode.Replay && !BallPoolGameLogic.controlFromNetwork)
			{
				PocketListener component = other.GetComponent<PocketListener>();
				if ((bool)component)
				{
					OnEnterPocket(component);
				}
			}
		}

		public void OnEnterPocket(PocketListener pocket)
		{
			if (!isInPocket)
			{
				body.isKinematic = true;
				pocketId = pocket.id;
				hitShapeId = -2;
				UnityEngine.Debug.Log(id + " OnEnterPocket");
				physicsManager.CallOnBallHitPocket(this, pocket, inReplay: true);
			}
		}

		public void OnCollisionExit(Collision other)
		{
			if (BallPoolGameLogic.playMode == PlayMode.Replay || BallPoolGameLogic.controlFromNetwork)
			{
				return;
			}
			BallListener component = other.collider.GetComponent<BallListener>();
			if ((bool)component)
			{
				if (AightBallPoolGameLogic.isCueBall(id))
				{
					if (Mathf.Abs(component.normalizedVelocity.x) + Mathf.Abs(component.normalizedVelocity.z) > 1E-05f)
					{
						OnHitBall(component);
					}
				}
				else
				{
					OnHitBall(component);
				}
			}
			else if (other.gameObject.layer == Layer.NameToLayer(Layer.GameType.Billiards, "Board"))
			{
				OnHitBoard();
			}
		}

		public void OnHitBall(BallListener ball)
		{
			pocketId = -1;
			hitShapeId = ball.id;
			physicsManager.CallBallHitBall(this, ball, inReplay: true);
		}

		public void OnHitBoard()
		{
			pocketId = -1;
			hitShapeId = -1;
			physicsManager.CallBallHitBoard(this, inReplay: true);
		}

		private void Awake()
		{
			radius = body.GetComponent<SphereCollider>().radius;
			pocketId = -1;
			hitShapeId = -2;
			inMove = physicsManager.inMove;
		}

		private void FixedUpdate()
		{
			if (!body.isKinematic && !body.IsSleeping() && physicsManager.inMove)
			{
				physicsManager.CallBallMove(id, body.position, body.velocity, body.angularVelocity);
			}
			if (inMove != physicsManager.inMove)
			{
				inMove = physicsManager.inMove;
				if (!inMove && !body.isKinematic)
				{
					body.Sleep();
				}
			}
		}
	}
	internal class SocialEngineFactory
	{
		internal static SocialEngine GetPlatformSocialEngine()
		{
			_ = UnityEngine.Application.isEditor;
			return new SocialExample();
		}
	}
	public class LocalizationCtrl : MonoBehaviour
	{
		public GameObject go_Neon_chinese;

		public GameObject go_Neon_english;

		public Material mat_Poster;

		private void Start()
		{
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			LanguageState languageState = PublicGameUIManager.gameSetting.GetLanguageState();
			if ((uint)(languageState - 10) <= 1u)
			{
				go_Neon_chinese.SetActive(value: true);
				go_Neon_english.SetActive(value: false);
				mat_Poster.SetTexture("_BaseMap", Resources.Load<Texture2D>("Billiard/Texture/poster_chinese"));
			}
			else
			{
				go_Neon_chinese.SetActive(value: false);
				go_Neon_english.SetActive(value: true);
				mat_Poster.SetTexture("_BaseMap", Resources.Load<Texture2D>("Billiard/Texture/poster_english"));
			}
		}
	}
}
namespace BallPool.Mechanics
{
	public class Ball : MonoBehaviour
	{
		public struct MechanicalState
		{
			public readonly float time;

			public readonly int pocketId;

			public readonly int hitShapeId;

			public readonly Vector3 position;

			public readonly Vector3 velocity;

			public readonly Vector3 angularVelocity;

			public MechanicalState(float time, int pocketId, int hitShapeId, Vector3 position, Vector3 velocity, Vector3 angularVelocity)
			{
				this.time = time;
				this.pocketId = pocketId;
				this.hitShapeId = hitShapeId;
				this.position = position;
				this.velocity = velocity;
				this.angularVelocity = angularVelocity;
			}

			public static string StateToString(MechanicalState state)
			{
				return "[" + state.time.ToString4() + ";" + state.pocketId + ";" + state.hitShapeId + ";" + DataManager.Vector3ToString(state.position) + "; " + DataManager.Vector3ToString(state.velocity) + "; " + DataManager.Vector3ToString(state.angularVelocity) + "]";
			}

			public static MechanicalState StateFromString(string state)
			{
				if (state == "")
				{
					return default(MechanicalState);
				}
				string[] array = DataManager.ConvertDataToStringArray(state);
				float num = array[0].ToFloat4();
				int num2 = int.Parse(array[1], NumberStyles.Integer);
				int num3 = int.Parse(array[2], NumberStyles.Integer);
				Vector3 vector = DataManager.Vector3FromString(array[3]);
				Vector3 vector2 = DataManager.Vector3FromString(array[4]);
				Vector3 vector3 = DataManager.Vector3FromString(array[5]);
				return new MechanicalState(num, num2, num3, vector, vector2, vector3);
			}
		}

		[NonSerialized]
		public Transform lightCentre;

		[NonSerialized]
		public Transform ballShadow;

		[NonSerialized]
		public Transform ballBlick;

		[SerializeField]
		private AudioClip ballHitBallClip;

		[SerializeField]
		private AudioClip ballHitPocketClip;

		[SerializeField]
		private AudioClip ballHitBoardClip;

		public BallListener listener;

		private AudioSource ballHitBall;

		private AudioSource ballHitBoard;

		private AudioSource ballHitPocket;

		private static int hitBallClipPlayingCount;

		private static int hitBoardClipPlayingCount;

		public int id;

		private float savedTime = -1f;

		private Vector3 savedPosition;

		private Vector3 savedVelocity;

		private Vector3 savedlarAnguVelocity;

		public string moveData;

		private string[] mechanicalStates;

		private float currentTime;

		private float deltaTime;

		private bool isFollow;

		private int mechanicalStateId;

		private int oldMechanicalStateId = -1;

		private MechanicalState currentState;

		public float radius { get; private set; }

		public bool isActive { get; set; }

		public bool inPocket
		{
			get
			{
				return listener.body.isKinematic;
			}
			set
			{
				listener.body.isKinematic = value;
			}
		}

		public int pocketId
		{
			get
			{
				return listener.pocketId;
			}
			set
			{
				listener.pocketId = value;
			}
		}

		public int hitShapeId
		{
			get
			{
				return listener.hitShapeId;
			}
			set
			{
				listener.hitShapeId = value;
			}
		}

		public bool inSpace => Geometry.SphereInCube(position, radius, listener.physicsManager.clothSpace);

		public Impulse impulse { get; set; }

		public bool isCast
		{
			get
			{
				return listener.GetComponent<SphereCollider>().enabled;
			}
			set
			{
				listener.GetComponent<SphereCollider>().enabled = value;
			}
		}

		public Vector3 position
		{
			get
			{
				return listener.body.position;
			}
			set
			{
				base.transform.position = value;
				listener.body.position = value;
			}
		}

		public HitInfo firstHitInfo { get; internal set; }

		public Vector3 savedSleepPosition { get; set; }

		public string mechanicalStateData
		{
			get
			{
				return MechanicalState.StateToString(new MechanicalState(DataManager.CutValue(listener.physicsManager.moveTime), pocketId, hitShapeId, position, listener.body.velocity, listener.body.angularVelocity));
			}
			set
			{
				MechanicalState mechanicalState = MechanicalState.StateFromString(value);
				inPocket = mechanicalState.pocketId != -1;
				pocketId = mechanicalState.pocketId;
				position = mechanicalState.position;
				if (!inPocket)
				{
					listener.body.velocity = mechanicalState.velocity;
					listener.body.angularVelocity = mechanicalState.angularVelocity;
				}
				if (BallPoolGameLogic.playMode == PlayMode.Replay)
				{
					OnState(BallState.SetState);
				}
			}
		}

		private bool NeedToSave()
		{
			return false;
		}

		public IEnumerator WaitAndStopBall(float moveTime)
		{
			while (listener.physicsManager.moveTime < moveTime)
			{
				yield return null;
			}
			if (!listener.body.isKinematic)
			{
				position = savedSleepPosition;
				listener.body.velocity = Vector3.zero;
				listener.body.angularVelocity = Vector3.zero;
				listener.body.Sleep();
			}
		}

		private void Awake()
		{
			if (!NetworkManager.initialized)
			{
				base.enabled = false;
				return;
			}
			hitBallClipPlayingCount = 0;
			hitBoardClipPlayingCount = 0;
			ballHitBall = base.gameObject.AddComponent<AudioSource>();
			ballHitBall.playOnAwake = false;
			ballHitBall.clip = ballHitBallClip;
			initializeAudio(in ballHitBall);
			ballHitBoard = base.gameObject.AddComponent<AudioSource>();
			ballHitBoard.playOnAwake = false;
			ballHitBoard.clip = ballHitBoardClip;
			initializeAudio(in ballHitBoard);
			ballHitPocket = base.gameObject.AddComponent<AudioSource>();
			ballHitPocket.playOnAwake = false;
			ballHitPocket.clip = ballHitPocketClip;
			initializeAudio(in ballHitPocket);
			radius = listener.body.GetComponent<SphereCollider>().radius;
			listener.body.position = base.transform.position;
		}

		private void initializeAudio(in AudioSource source)
		{
			source.playOnAwake = false;
			source.spatialize = false;
			source.spatialBlend = 1f;
			source.spread = 0f;
			source.rolloffMode = AudioRolloffMode.Linear;
			source.minDistance = 0f;
			source.maxDistance = 20f;
			source.reverbZoneMix = 0.3f;
			source.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("Effect");
		}

		private void Start()
		{
			if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
			{
				ballBlick.position = CalculateBallBlickPosition();
			}
			ballShadow.position = CalculateBallShadowPosition();
		}

		private void Update()
		{
			if (listener.physicsManager.inMove && !inPocket && !listener.body.isKinematic)
			{
				SetBallShadowAndBlickBlick();
			}
		}

		public void SetBallShadowAndBlickBlick()
		{
			if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
			{
				ballBlick.position = CalculateBallBlickPosition();
			}
			ballShadow.position = CalculateBallShadowPosition();
		}

		public void SetMechanicalState(int number)
		{
			listener.pocket = null;
			moveData = listener.physicsManager.replayManager.GetReplay(id, number);
			UnityEngine.Debug.Log(moveData);
			string[] array = DataManager.ConvertArrayDataToStringArray(moveData);
			if (array != null && array.Length != 0)
			{
				mechanicalStateData = array[0];
			}
		}

		private Vector3 CalculateBallShadowPosition()
		{
			if (inSpace)
			{
				return new Vector3(position.x, 0.1f * radius, position.z) + 0.5f * radius * (position - lightCentre.position);
			}
			return new Vector3(position.x, position.y - 0.5f * radius, position.z) + 0.5f * radius * (position - lightCentre.position);
		}

		private Vector3 CalculateBallBlickPosition()
		{
			return position + 1.1f * radius * Vector3.up;
		}

		public void SrartFollow()
		{
			if (!string.IsNullOrEmpty(moveData))
			{
				mechanicalStates = DataManager.ConvertArrayDataToStringArray(moveData);
				currentTime = 0f;
				oldMechanicalStateId = -1;
				mechanicalStateId = 0;
				deltaTime = 0f;
				currentState = MechanicalState.StateFromString(mechanicalStates[mechanicalStateId]);
				if (currentState.pocketId == -1)
				{
					isFollow = true;
				}
			}
		}

		public IEnumerator SetMechanicalStatesFromNetwork(string state)
		{
			MechanicalState mState = MechanicalState.StateFromString(state);
			while (!listener.physicsManager.endFromNetwork && listener.physicsManager.moveTime < mState.time)
			{
				yield return new WaitForFixedUpdate();
			}
			if (!listener.physicsManager.endFromNetwork)
			{
				FollowMoveFromNetwork(mState);
				mechanicalStateData = state;
			}
		}

		private void FollowMoveFromNetwork(MechanicalState mState)
		{
			if (mState.hitShapeId >= 0)
			{
				listener.OnHitBall(listener.physicsManager.ballsListener[mState.hitShapeId]);
			}
			else if (mState.hitShapeId == -1)
			{
				listener.OnHitBoard();
			}
			else if (mState.pocketId != -1)
			{
				listener.OnEnterPocket(listener.physicsManager.pocketListeners[mState.pocketId]);
			}
		}

		private void FollowMoveInReplay()
		{
			if (currentState.hitShapeId >= 0)
			{
				OnState(BallState.HitBall);
			}
			else if (currentState.hitShapeId == -1)
			{
				OnState(BallState.HitBoard);
			}
			else if (currentState.pocketId != -1)
			{
				listener.physicsManager.CallOnBallHitPocket(listener, listener.physicsManager.pocketListeners[currentState.pocketId], inReplay: true);
				OnState(BallState.EnterInPocket);
			}
		}

		private void FixedUpdate()
		{
			if (!isFollow)
			{
				return;
			}
			if (oldMechanicalStateId != mechanicalStateId)
			{
				oldMechanicalStateId = mechanicalStateId;
				currentTime = currentState.time;
				deltaTime = 0f;
				if (listener.physicsManager.inMove)
				{
					FollowMoveInReplay();
					mechanicalStateData = MechanicalState.StateToString(currentState);
				}
				if (mechanicalStateId + 1 < mechanicalStates.Length)
				{
					currentState = MechanicalState.StateFromString(mechanicalStates[mechanicalStateId + 1]);
				}
				else
				{
					isFollow = false;
				}
			}
			else if (isFollow)
			{
				deltaTime += Time.fixedDeltaTime;
				if (deltaTime >= currentState.time - currentTime)
				{
					mechanicalStateId++;
				}
			}
		}

		public void OnState(BallState state)
		{
			switch (state)
			{
			case BallState.SetState:
				if (BallPoolGameLogic.playMode != PlayMode.Replay)
				{
					hitShapeId = -2;
					moveData = mechanicalStateData;
				}
				if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
				{
					ballBlick.position = CalculateBallBlickPosition();
				}
				ballShadow.position = CalculateBallShadowPosition();
				if (inPocket)
				{
					ballShadow.gameObject.SetActive(value: false);
				}
				break;
			case BallState.Move:
				position = listener.body.position;
				base.transform.rotation = listener.body.rotation;
				if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
				{
					ballBlick.position = CalculateBallBlickPosition();
				}
				ballShadow.position = CalculateBallShadowPosition();
				if (NeedToSave() && BallPoolGameLogic.playMode != PlayMode.Replay && !inPocket)
				{
					moveData += mechanicalStateData;
					if (BallPoolGameLogic.controlInNetwork)
					{
						NetworkManager.network.SendRemoteMessage("SetMechanicalStatesFromNetwork", id, mechanicalStateData);
					}
				}
				break;
			case BallState.EndMove:
				if (BallPoolGameLogic.playMode == PlayMode.Replay)
				{
					break;
				}
				if (!inPocket)
				{
					moveData += mechanicalStateData;
					if (BallPoolGameLogic.controlInNetwork)
					{
						NetworkManager.network.SendRemoteMessage("SetMechanicalStatesFromNetwork", id, mechanicalStateData);
					}
				}
				listener.physicsManager.replayManager.SaveReplay(id, moveData);
				SetBallShadowAndBlickBlick();
				break;
			case BallState.EnterInPocket:
				if (BallPoolGameLogic.playMode != PlayMode.Replay)
				{
					if (!BallPoolGameLogic.controlFromNetwork)
					{
						inPocket = true;
					}
					moveData += mechanicalStateData;
					if (BallPoolGameLogic.controlInNetwork)
					{
						NetworkManager.network.SendRemoteMessage("SetMechanicalStatesFromNetwork", id, mechanicalStateData);
					}
				}
				ballShadow.gameObject.SetActive(value: false);
				if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
				{
					ballBlick.gameObject.SetActive(value: false);
				}
				if (listener.physicsManager.inMove)
				{
					StartCoroutine(WaitAndPlayBallInPocket());
				}
				break;
			case BallState.MoveInPocket:
				position = listener.body.position;
				base.transform.rotation = listener.body.rotation;
				break;
			case BallState.ExitFromPocket:
				if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
				{
					ballBlick.gameObject.SetActive(value: true);
				}
				if (!AightBallPoolNetworkGameAdapter.is3DGraphics)
				{
					ballBlick.position = CalculateBallBlickPosition();
				}
				ballShadow.position = CalculateBallShadowPosition();
				ballShadow.gameObject.SetActive(!inPocket);
				break;
			case BallState.HitBall:
				if (BallPoolGameLogic.playMode != PlayMode.Replay && savedTime != listener.physicsManager.moveTime)
				{
					savedTime = listener.physicsManager.moveTime;
					if (!inPocket)
					{
						moveData += mechanicalStateData;
						if (BallPoolGameLogic.controlInNetwork)
						{
							NetworkManager.network.SendRemoteMessage("SetMechanicalStatesFromNetwork", id, mechanicalStateData);
						}
					}
				}
				if (!ballHitBall.isPlaying && hitBallClipPlayingCount < 3 && listener.physicsManager.inMove)
				{
					hitBallClipPlayingCount++;
					ballHitBall.volume = Mathf.Clamp01(10f * listener.normalizedVelocity.magnitude);
					ballHitBall.Play();
					StartCoroutine(WaitWhenHitBallClipIsPlaying());
				}
				break;
			case BallState.HitBoard:
				if (BallPoolGameLogic.playMode != PlayMode.Replay && savedTime != listener.physicsManager.moveTime)
				{
					savedTime = listener.physicsManager.moveTime;
					if (!inPocket)
					{
						moveData += mechanicalStateData;
						if (BallPoolGameLogic.controlInNetwork)
						{
							NetworkManager.network.SendRemoteMessage("SetMechanicalStatesFromNetwork", id, mechanicalStateData);
						}
					}
				}
				if (!ballHitBoard.isPlaying && hitBoardClipPlayingCount < 3 && listener.physicsManager.inMove)
				{
					hitBoardClipPlayingCount++;
					ballHitBoard.volume = Mathf.Clamp01(10f * listener.normalizedVelocity.magnitude);
					ballHitBoard.Play();
					StartCoroutine(WaitWhenHitBoardClipIsPlaying());
				}
				break;
			case BallState.StartMove:
				break;
			}
		}

		private IEnumerator WaitWhenHitBoardClipIsPlaying()
		{
			while (ballHitBoard.isPlaying)
			{
				yield return null;
			}
			hitBoardClipPlayingCount--;
		}

		private IEnumerator WaitWhenHitBallClipIsPlaying()
		{
			while (ballHitBall.isPlaying)
			{
				yield return null;
			}
			hitBallClipPlayingCount--;
		}

		private IEnumerator WaitAndPlayBallInPocket()
		{
			yield return new WaitForSeconds(0.2f);
			ballHitPocket.volume = Mathf.Clamp(10f * listener.normalizedVelocity.magnitude, 0.3f, 1f);
			ballHitPocket.Play();
		}
	}
	public class Geometry
	{
		public static Vector3 ClampPositionInCube(Vector3 position, float radius, Transform cube)
		{
			if (SphereInCube(position, radius, cube))
			{
				return position;
			}
			Vector3 localPosition = GetLocalPosition(position, cube);
			float x = Mathf.Clamp(localPosition.x, -0.5f * cube.lossyScale.x + radius, 0.5f * cube.lossyScale.x - radius);
			float y = Mathf.Clamp(localPosition.y, -0.5f * cube.lossyScale.y + radius, 0.5f * cube.lossyScale.y - radius);
			float z = Mathf.Clamp(localPosition.z, -0.5f * cube.lossyScale.z + radius, 0.5f * cube.lossyScale.z - radius);
			return GetWorldPosition(new Vector3(x, y, z), cube);
		}

		public static Vector2 EdgeProjectionXZ(Vector2 direction, Vector2 pivot, Transform cube)
		{
			Vector3 vector = cube.lossyScale;
			Vector2 vector2 = Billiards.VectorExtension.ToXZ(in vector);
			Vector2 result = direction * 100f;
			vector = GetLocalPosition(Billiards.VectorExtension.ToVector3FromXZ(in pivot), cube);
			Vector2 vector3 = Billiards.VectorExtension.ToXZ(in vector);
			float num = direction.y / direction.x;
			result.y = Mathf.Clamp(result.y + vector3.y, vector2.y * -0.5f, vector2.y * 0.5f);
			result.x = ((Mathf.Abs(num) <= 0.001f) ? result.x : ((result.y - vector3.y) / num)) + vector3.x;
			if (Mathf.Abs(result.x) > vector2.x * 0.5f)
			{
				result.x = Mathf.Clamp(result.x, vector2.x * -0.5f, vector2.x * 0.5f);
				result.y = (result.x - vector3.x) * num + vector3.y;
			}
			return result;
		}

		public static bool SphereInCube(Vector3 position, float radius, Transform cube)
		{
			Vector3 localPosition = GetLocalPosition(position, cube);
			Vector3 lossyScale = cube.lossyScale;
			if (Mathf.Abs(localPosition.x) + radius - 0.5f * lossyScale.x <= 0f && Mathf.Abs(localPosition.y) + radius - 0.5f * lossyScale.y <= 0f)
			{
				return Mathf.Abs(localPosition.z) + radius - 0.5f * lossyScale.z <= 0f;
			}
			return false;
		}

		public static Vector3 GetLocalPosition(Vector3 worldPosition, Transform shape)
		{
			Vector3 lhs = worldPosition - shape.position;
			return new Vector3(Vector3.Dot(lhs, shape.right), Vector3.Dot(lhs, shape.up), Vector3.Dot(lhs, shape.forward));
		}

		public static Vector3 GetWorldPosition(Vector3 localPosition, Transform shape)
		{
			return shape.position + localPosition.x * shape.right + localPosition.y * shape.up + localPosition.z * shape.forward;
		}

		public static Vector3 getPerpendicularToVector(Vector3 vector, Vector3 origin)
		{
			return origin - Vector3.Project(origin, vector);
		}
	}
	public enum ShapeType
	{
		Non,
		Ball,
		Board,
		Cloth
	}
	public enum BallExitType
	{
		Sleep,
		Reactivate
	}
	public enum BallState
	{
		Non,
		SetState,
		StartMove,
		Move,
		HitBall,
		HitBoard,
		EnterInPocket,
		MoveInPocket,
		ExitFromPocket,
		EndMove
	}
	public delegate void BallShotHandler<String>(string impulse);
	public delegate void BallMoveHandler<Int, Vector3>(int ballId, Vector3 position, Vector3 velocity, Vector3 angularVelocity);
	public delegate void BallSleepHandler<Int, Vector3>(int ballId, Vector3 position);
	public delegate void SetStateHandler();
	public delegate void BallHitBallHandler<Ball, Boolean>(Ball ball, Ball hitBall, bool inMove);
	public delegate void BallHitBoardHandler<Ball, Boolean>(Ball ball, bool inMove);
	public delegate void BallHitPocketHandler<Ball, Pocket, Boolean>(Ball ball, Pocket pocket, bool inMove);
	public delegate void BallExitFromPocketHandler<Ball, Pocket, BallExitType, Boolean>(Ball ball, Pocket pocket, BallExitType exitType, bool inMove);
	public struct Impulse
	{
		public readonly Vector3 point;

		public readonly Vector3 impulse;

		public Impulse(Vector3 point, Vector3 impulse)
		{
			this.point = point;
			this.impulse = impulse;
		}

		public override string ToString()
		{
			return "[" + point.ToString() + " , " + impulse.ToString() + "]";
		}
	}
	public struct HitInfo
	{
		public Vector3 point { get; private set; }

		public Vector3 normal { get; private set; }

		public Vector3 positionInHit { get; private set; }

		public ShapeType shapeType { get; private set; }

		public HitInfo(Vector3 point, Vector3 normal, Vector3 positionInHit, ShapeType shapeType)
		{
			this.point = point;
			this.normal = normal;
			this.positionInHit = positionInHit;
			this.shapeType = shapeType;
		}
	}
	public class PhysicsManager : MonoBehaviour
	{
		[SerializeField]
		private float _ballMass;

		[SerializeField]
		private float _ballMaxVelocity;

		[SerializeField]
		private float _ballMaxAngularVelocity;

		public Transform clothSpace;

		public BallListener[] ballsListener;

		public PocketListener[] pocketListeners;

		public ReplayManager replayManager;

		private Impulse impulse;

		private bool checkInProgress;

		public float moveTime { get; set; }

		public float ballMass => _ballMass;

		public float ballMaxVelocity => _ballMaxVelocity;

		public float ballMaxAngularVelocity => _ballMaxAngularVelocity;

		public bool inMove { get; private set; }

		public bool endFromNetwork { get; set; }

		public event BallMoveHandler<int, Vector3> OnBallMove;

		public event BallSleepHandler<int, Vector3> OnBallSleep;

		public event BallShotHandler<string> OnStartShot;

		public event BallShotHandler<string> OnSaveEndStartReplay;

		public event BallShotHandler<string> OnEndShot;

		public event SetStateHandler OnSetState;

		public event BallHitBallHandler<BallListener, bool> OnBallHitBall;

		public event BallHitBoardHandler<BallListener, bool> OnBallHitBoard;

		public event BallHitPocketHandler<BallListener, PocketListener, bool> OnBallHitPocket;

		public event BallExitFromPocketHandler<BallListener, PocketListener, BallExitType, bool> OnBallExitFromPocket;

		private void Awake()
		{
			if (!NetworkManager.initialized)
			{
				base.enabled = false;
				return;
			}
			Physics.autoSimulation = false;
			Physics.autoSyncTransforms = true;
			UnityEngine.Debug.Log("autoSyncTransforms " + Physics.autoSyncTransforms);
			inMove = false;
			Time.fixedDeltaTime = 0.005f;
			Physics.bounceThreshold = 0.01f;
			Physics.sleepThreshold = 0.01f;
			Physics.defaultContactOffset = 0.0005f;
			Physics.defaultSolverIterations = 1;
			Physics.defaultSolverVelocityIterations = 1;
			BallListener[] array = ballsListener;
			foreach (BallListener obj in array)
			{
				obj.body.drag = 0.5f;
				obj.body.angularDrag = 0.7f;
				obj.body.mass = _ballMass;
				obj.body.maxDepenetrationVelocity = _ballMaxVelocity;
				obj.body.maxAngularVelocity = _ballMaxAngularVelocity;
				obj.body.Sleep();
			}
			replayManager = new ReplayManager();
			if (BallPoolGameLogic.playMode != PlayMode.Replay)
			{
				replayManager.DeleteReplayData();
			}
		}

		private void FixedUpdate()
		{
			if (inMove)
			{
				Physics.Simulate(Time.fixedDeltaTime);
			}
		}

		private IEnumerator Start()
		{
			while (true)
			{
				yield return new WaitForFixedUpdate();
				if (!inMove)
				{
					continue;
				}
				moveTime += Time.fixedDeltaTime;
				if (!BallPoolGameLogic.controlFromNetwork && CheckIsSleeping(forceSleep: false))
				{
					yield return new WaitForSeconds(0.1f);
					if (CheckIsSleeping(forceSleep: true))
					{
						yield return StartCoroutine("StopMove");
					}
					else
					{
						StopCoroutine("StopMove");
					}
					checkInProgress = false;
				}
			}
		}

		public IEnumerator WaitAndStopMoveFromNetwork(float time)
		{
			while (moveTime < time)
			{
				yield return new WaitForFixedUpdate();
			}
			yield return StartCoroutine(StopMove());
			endFromNetwork = true;
		}

		private IEnumerator StopMove()
		{
			inMove = false;
			BallListener[] array = ballsListener;
			foreach (BallListener ballListener in array)
			{
				if (!ballListener.body.isKinematic)
				{
					ballListener.body.velocity = Vector3.zero;
					ballListener.body.angularVelocity = Vector3.zero;
					ballListener.body.Sleep();
				}
				CallBallSleep(ballListener.id, ballListener.body.position);
			}
			if (BallPoolGameLogic.controlInNetwork)
			{
				yield return new WaitForSeconds(0.2f);
				NetworkManager.network.SendRemoteMessage("WaitAndStopMoveFromNetwork", moveTime);
			}
			if (BallPoolGameLogic.playMode != PlayMode.Replay)
			{
				replayManager.AddReplayDataCount();
			}
			yield return new WaitForSeconds(1.2f);
			if (this.OnEndShot != null)
			{
				this.OnEndShot("");
			}
			moveTime = 0f;
		}

		private bool CheckIsSleeping(bool forceSleep)
		{
			float num = 0.09f;
			bool result = true;
			BallListener[] array = ballsListener;
			foreach (BallListener ballListener in array)
			{
				if (Geometry.SphereInCube(ballListener.body.position, ballListener.radius, clothSpace) && !ballListener.body.isKinematic && (!(ballListener.body.velocity.magnitude < num) || !(ballListener.radius * ballListener.body.angularVelocity.magnitude < num)))
				{
					result = false;
				}
			}
			return result;
		}

		public void CallBallSleep(int ballId, Vector3 position)
		{
			if (this.OnBallSleep != null)
			{
				this.OnBallSleep(ballId, position);
			}
		}

		public void CallBallMove(int ballId, Vector3 position, Vector3 velocity, Vector3 angularVelocity)
		{
			if (this.OnBallMove != null)
			{
				this.OnBallMove(ballId, position, velocity, angularVelocity);
			}
		}

		public void CallBallHitBall(BallListener ball, BallListener hitBall, bool inReplay)
		{
			if (this.OnBallHitBall != null)
			{
				this.OnBallHitBall(ball, hitBall, inReplay);
			}
		}

		public void CallBallHitBoard(BallListener ball, bool inReplay)
		{
			if (this.OnBallHitBoard != null)
			{
				this.OnBallHitBoard(ball, inReplay);
			}
		}

		public void CallOnBallHitPocket(BallListener ball, PocketListener pocket, bool inReplay)
		{
			if (this.OnBallHitPocket != null)
			{
				this.OnBallHitPocket(ball, pocket, inReplay);
			}
		}

		public void CallOnBallExitFromPocket(BallListener ball, PocketListener pocket, bool inReplay)
		{
			if (this.OnBallExitFromPocket != null)
			{
				this.OnBallExitFromPocket(ball, pocket, BallExitType.Reactivate, inReplay);
			}
		}

		public void ReactivateBallInCube(float ballRadius, Transform cube, int clothMask, int ballsMask, ref bool canReactivate, ref Vector3 ballNewPosition)
		{
			Vector3 vector = cube.position + 0.5f * cube.lossyScale.y * cube.up;
			Vector3 direction = -cube.up;
			canReactivate = false;
			ballNewPosition = cube.position;
			for (float num = 0f; num < 0.5f * cube.lossyScale.x - 3f * ballRadius; num += 3f * ballRadius)
			{
				for (float num2 = 0f; num2 < 0.5f * cube.lossyScale.z - 3f * ballRadius; num2 += 3f * ballRadius)
				{
					vector = cube.position + 0.5f * cube.lossyScale.y * cube.up + num * cube.right + num2 * cube.forward;
					if (Physics.Raycast(vector, direction, out var hitInfo, cube.lossyScale.y, clothMask) && !Physics.SphereCast(vector, ballRadius, direction, out var _, cube.lossyScale.y, ballsMask))
					{
						canReactivate = true;
						ballNewPosition = hitInfo.point + ballRadius * hitInfo.normal;
						break;
					}
				}
				if (canReactivate)
				{
					break;
				}
			}
		}

		public void HideBallsLine()
		{
		}

		public void SetImpulse(Impulse impulse)
		{
			this.impulse = impulse;
		}

		public void StarShotFromNetwork(string impulse)
		{
			StartRaplayShot(impulse);
		}

		public void StartRaplayShot(string impulse)
		{
			UnityEngine.Debug.Log("StartRaplayShot");
			if (this.OnSaveEndStartReplay != null)
			{
				this.OnSaveEndStartReplay(impulse);
			}
		}

		public void StartShot(BallListener ball)
		{
			inMove = true;
			moveTime = 0f;
			ball.body.AddForceAtPosition(impulse.impulse, impulse.point, ForceMode.Impulse);
			if (this.OnStartShot != null)
			{
				this.OnStartShot("");
			}
		}

		public void CheckEndShot(string data)
		{
		}

		public void SetState(int state)
		{
		}

		public void Disable()
		{
		}
	}
	public class PocketListener : MonoBehaviour
	{
		public int id;

		[SerializeField]
		private Transform pocketTarget;

		public Vector3 target => pocketTarget.position;
	}
	public class ReplayManager
	{
		private int GetBallsDataCount()
		{
			return DataManager.GetIntData("BallsDataCount");
		}

		public Impulse GetImpulse(int number)
		{
			return DataManager.ImpulseFromString(DataManager.GetStringData("Impulse_" + number));
		}

		public void SaveImpulse(Impulse impulse)
		{
			int replayDataCount = GetReplayDataCount();
			DataManager.SetStringData("Impulse_" + replayDataCount, DataManager.ImpulseToString(impulse));
		}

		public void AddReplayDataCount()
		{
			int replayDataCount = GetReplayDataCount();
			DataManager.SetIntData("ReplayDataCount", replayDataCount + 1);
		}

		public int GetReplayDataCount()
		{
			return DataManager.GetIntData("ReplayDataCount");
		}

		public void SaveReplay(int ballId, string date)
		{
			int replayDataCount = GetReplayDataCount();
			int intData = DataManager.GetIntData("BallsDataCount");
			if (ballId > intData)
			{
				DataManager.SetIntData("BallsDataCount", ballId);
			}
			DataManager.SetStringData("ReplayData_" + ballId + "_" + replayDataCount, date);
		}

		public string GetReplay(int ballId, int number)
		{
			return DataManager.GetStringData("ReplayData_" + ballId + "_" + number);
		}

		public void DeleteReplayData()
		{
			int replayDataCount = GetReplayDataCount();
			for (int i = 0; i < replayDataCount; i++)
			{
				for (int j = 0; j < 16; j++)
				{
					DataManager.DeleteKeyData("ReplayData_" + j + "_" + i);
				}
				DataManager.DeleteKeyData("Impulse_" + i);
			}
			DataManager.DeleteKeyData("ReplayDataCount");
		}
	}
}
namespace BallPool.AI
{
	[StructLayout(0, Size = 1)]
	public struct BallAICalculator
	{
		public static Ball FindSecondWorstTargetBall(Ball cueBall, PocketListener[] targets, Ball[] balls, out int pocketId, out Vector3 cueBallPosition, out Vector3 shotPoint, out Vector3 aimpoint, ref float impulse, FindBestTargetBallException<int> FindException, bool changePosition, int ballsLayer, int boardLayer)
		{
			Ball ball = null;
			pocketId = 0;
			cueBallPosition = cueBall.position;
			shotPoint = Vector3.zero;
			Vector3 zero = Vector3.zero;
			aimpoint = Vector3.zero;
			float num = 0f;
			foreach (Ball ball2 in balls)
			{
				if (!(ball2 == cueBall) && !ball2.inPocket && !FindException(ball2.id))
				{
					zero = ball2.position;
					Vector3 normalized = Vector3.ProjectOnPlane(zero - cueBallPosition, Vector3.up).normalized;
					if (!ball)
					{
						aimpoint = zero;
						shotPoint = cueBallPosition - cueBall.radius * normalized;
					}
					float num2 = Vector3.Distance(zero, cueBallPosition);
					if (!(num > num2))
					{
						num = num2;
						Vector3.Dot(normalized, (ball2.position - zero).normalized);
						normalized = Vector3.ProjectOnPlane(zero - cueBallPosition, Vector3.up).normalized;
						shotPoint = cueBallPosition - cueBall.radius * normalized;
						aimpoint = zero;
						ball = ball2;
						break;
					}
				}
			}
			if ((bool)ball)
			{
				float num3 = 0.5f * UnityEngine.Random.Range(0f - cueBall.radius, 0f);
				shotPoint += num3 * Vector3.up;
			}
			return ball;
		}

		public static Ball FindSuboptimalTargetBall(Ball cueBall, PocketListener[] targets, Ball[] balls, out int pocketId, out Vector3 cueBallPosition, out Vector3 shotPoint, out Vector3 aimpoint, ref float impulse, FindBestTargetBallException<int> FindException, bool changePosition, int ballsLayer, int boardLayer)
		{
			Ball ball = null;
			bool flag = false;
			pocketId = 0;
			float hitAngleCosine = 0f;
			float targetBallToTargetDistance = 100000f;
			cueBallPosition = cueBall.position;
			shotPoint = Vector3.zero;
			Vector3 zero = Vector3.zero;
			aimpoint = Vector3.zero;
			foreach (Ball ball2 in balls)
			{
				if (ball2 == cueBall || ball2.inPocket || FindException(ball2.id))
				{
					continue;
				}
				zero = ball2.position;
				Vector3 normalized = Vector3.ProjectOnPlane(zero - cueBallPosition, Vector3.up).normalized;
				if (!ball)
				{
					aimpoint = zero;
					shotPoint = cueBallPosition - cueBall.radius * normalized;
				}
				bool flag2 = false;
				float num = Vector3.Dot(normalized, (ball2.position - zero).normalized);
				if (!(hitAngleCosine <= num) && !(num > 0.5f))
				{
					continue;
				}
				ball2.isCast = false;
				flag2 = Physics.SphereCast(cueBallPosition, cueBall.radius, normalized, out var hitInfo, Vector3.Distance(cueBallPosition, zero), ballsLayer);
				ball2.isCast = true;
				if (flag2 && ball2.listener.transform == hitInfo.transform)
				{
					flag2 = false;
				}
				if (flag2)
				{
					if ((!flag || hitAngleCosine < 0.1f) && CheckBoardls(cueBall.radius, cueBallPosition, zero, ball2.listener, ref aimpoint, ref hitAngleCosine, ref targetBallToTargetDistance, ballsLayer, boardLayer))
					{
						hitAngleCosine = num;
						normalized = Vector3.ProjectOnPlane(aimpoint - cueBallPosition, Vector3.up).normalized;
						shotPoint = cueBallPosition - cueBall.radius * normalized;
						flag = true;
						ball = ball2;
					}
				}
				else
				{
					hitAngleCosine = num;
					normalized = Vector3.ProjectOnPlane(zero - cueBallPosition, Vector3.up).normalized;
					shotPoint = cueBallPosition - cueBall.radius * normalized;
					aimpoint = zero;
					flag = true;
					ball = ball2;
				}
			}
			if ((bool)ball)
			{
				float num2 = 0.5f * UnityEngine.Random.Range(0f - cueBall.radius, 0f);
				shotPoint += num2 * Vector3.up;
			}
			return ball;
		}

		public static Ball FindBestTargetBall(Ball cueBall, PocketListener[] targets, Ball[] balls, out int pocketId, out Vector3 cueBallPosition, out Vector3 shotPoint, out Vector3 aimpoint, ref float impulse, FindBestTargetBallException<int> FindException, bool changePosition, int ballsLayer, int boardLayer, Transform clothSpace)
		{
			Ball ball = null;
			bool flag = false;
			pocketId = 0;
			float hitAngleCosine = 0f;
			float targetBallToTargetDistance = 100000f;
			cueBallPosition = cueBall.position;
			shotPoint = Vector3.zero;
			Vector3 zero = Vector3.zero;
			aimpoint = Vector3.zero;
			foreach (PocketListener pocketListener in targets)
			{
				foreach (Ball ball2 in balls)
				{
					if (ball2 == cueBall || ball2.inPocket || FindException(ball2.id))
					{
						continue;
					}
					Vector3 normalized = (pocketListener.target - ball2.position).normalized;
					zero = ball2.position - (cueBall.radius + ball2.radius) * normalized;
					Vector3 normalized2 = Vector3.ProjectOnPlane(zero - cueBallPosition, Vector3.up).normalized;
					if (Vector3.Dot(normalized, normalized2) <= 0f || Physics.SphereCast(ball2.position, ball2.radius, normalized, out var hitInfo, Vector3.Distance(ball2.position, pocketListener.target), ballsLayer))
					{
						continue;
					}
					if (!ball)
					{
						aimpoint = zero;
						shotPoint = cueBallPosition - cueBall.radius * normalized2;
					}
					float num = Vector3.Dot(normalized2, (ball2.position - zero).normalized);
					float num2 = Vector3.Distance(pocketListener.target, ball2.position);
					if (!(hitAngleCosine < num) && (!(num > 0.5f) || !(targetBallToTargetDistance > num2)))
					{
						continue;
					}
					ball2.isCast = false;
					bool flag2 = Physics.SphereCast(cueBallPosition, cueBall.radius, normalized2, out hitInfo, Vector3.Distance(cueBallPosition, zero), ballsLayer);
					ball2.isCast = true;
					if (flag2 && ball2.listener.transform == hitInfo.transform)
					{
						flag2 = false;
					}
					if (flag2)
					{
						if (!changePosition)
						{
							if ((!flag || hitAngleCosine < 0.1f) && CheckBoardls(cueBall.radius, cueBallPosition, zero, ball2.listener, ref aimpoint, ref hitAngleCosine, ref targetBallToTargetDistance, ballsLayer, boardLayer))
							{
								hitAngleCosine = num;
								targetBallToTargetDistance = num2;
								normalized2 = Vector3.ProjectOnPlane(aimpoint - cueBallPosition, Vector3.up).normalized;
								shotPoint = cueBallPosition - cueBall.radius * normalized2;
								flag = true;
								ball = ball2;
								pocketId = pocketListener.id;
							}
							continue;
						}
						float num3 = 20f;
						Vector3 vector = zero - num3 * cueBall.radius * normalized;
						flag2 = true;
						while (flag2 && num3 >= 4f)
						{
							num3 -= 2f;
							vector = Geometry.ClampPositionInCube(zero - num3 * cueBall.radius * normalized, cueBall.radius, clothSpace);
							ball2.isCast = false;
							flag2 = Physics.SphereCast(vector, cueBall.radius, normalized, out hitInfo, Vector3.Distance(vector, zero), ballsLayer) || Physics.SphereCast(vector + 4f * cueBall.radius * Vector3.up, 1.5f * cueBall.radius, -Vector3.up, out hitInfo, Vector3.Distance(vector, zero), ballsLayer) || Physics.SphereCast(vector + 4f * cueBall.radius * Vector3.up, 1.5f * cueBall.radius, -Vector3.up, out hitInfo, (6f * cueBall.radius * Vector3.up).magnitude, ballsLayer);
							ball2.isCast = true;
							if (!flag2)
							{
								hitAngleCosine = num;
								Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector);
								cueBallPosition = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, cueBallPosition.y);
								zero = ball2.position - (cueBall.radius + ball2.radius) * normalized;
								normalized2 = Vector3.ProjectOnPlane(zero - cueBallPosition, Vector3.up).normalized;
								shotPoint = cueBallPosition - cueBall.radius * normalized2;
								aimpoint = zero;
								flag = true;
								ball = ball2;
								cueBall.position = cueBallPosition;
								cueBall.OnState(BallState.SetState);
								pocketId = pocketListener.id;
							}
						}
					}
					else
					{
						hitAngleCosine = num;
						targetBallToTargetDistance = num2;
						normalized2 = Vector3.ProjectOnPlane(zero - cueBallPosition, Vector3.up).normalized;
						shotPoint = cueBallPosition - cueBall.radius * normalized2;
						aimpoint = zero;
						flag = true;
						ball = ball2;
						pocketId = pocketListener.id;
					}
				}
			}
			if ((bool)ball)
			{
				float num4 = 0.5f * UnityEngine.Random.Range(0f - cueBall.radius, 0f);
				shotPoint += num4 * Vector3.up;
			}
			return ball;
		}

		private static bool CheckBoardls(float cueBallRadius, Vector3 cueBallPosition, Vector3 targetPoint, BallListener targetBall, ref Vector3 aimpoint, ref float hitAngleCosine, ref float targetBallToTargetDistance, int ballsLayer, int boardLayer)
		{
			return CheckBoardl(Vector3.right, cueBallRadius, cueBallPosition, targetPoint, targetBall, ref aimpoint, ref hitAngleCosine, ref targetBallToTargetDistance, ballsLayer, boardLayer) | CheckBoardl(Vector3.left, cueBallRadius, cueBallPosition, targetPoint, targetBall, ref aimpoint, ref hitAngleCosine, ref targetBallToTargetDistance, ballsLayer, boardLayer) | CheckBoardl(Vector3.forward, cueBallRadius, cueBallPosition, targetPoint, targetBall, ref aimpoint, ref hitAngleCosine, ref targetBallToTargetDistance, ballsLayer, boardLayer) | CheckBoardl(Vector3.back, cueBallRadius, cueBallPosition, targetPoint, targetBall, ref aimpoint, ref hitAngleCosine, ref targetBallToTargetDistance, ballsLayer, boardLayer);
		}

		private static bool CheckBoardl(Vector3 direction, float cueBallRadius, Vector3 cueBallPosition, Vector3 targetPoint, BallListener targetBall, ref Vector3 aimpoint, ref float hitAngleCosine, ref float targetBallToTargetDistance, int ballsLayer, int boardLayer)
		{
			if (Physics.SphereCast(new Ray(cueBallPosition, direction), cueBallRadius, out var hitInfo, 5f, boardLayer))
			{
				float num = Vector3.Distance(hitInfo.point + hitInfo.normal * cueBallRadius, cueBallPosition) - cueBallRadius;
				float num2 = Vector3.Dot(targetPoint - cueBallPosition, direction);
				Vector3 normalized = Geometry.getPerpendicularToVector(direction, targetPoint - cueBallPosition).normalized;
				float magnitude = Vector3.Project(targetPoint - cueBallPosition, normalized).magnitude;
				Vector3 vector = cueBallPosition + num * direction + magnitude * num / (2f * num - num2) * normalized;
				Vector3 normalized2 = (vector - cueBallPosition).normalized;
				Vector3 normalized3 = (targetPoint - vector).normalized;
				if (Physics.SphereCast(new Ray(cueBallPosition, normalized2), cueBallRadius, out var hitInfo2, 5f, ballsLayer | boardLayer) && hitInfo2.collider.gameObject.layer == Layer.NameToLayer(Layer.GameType.Billiards, "Board") && Vector3.Dot(hitInfo2.normal, -direction) > 0.9f && Physics.SphereCast(new Ray(vector, normalized3), cueBallRadius, out var hitInfo3, 5f, ballsLayer))
				{
					BallListener component = hitInfo3.collider.GetComponent<BallListener>();
					if ((bool)component && component == targetBall)
					{
						float num3 = Vector3.Dot(normalized3, (targetBall.transform.position - targetPoint).normalized);
						float num4 = Vector3.Distance(cueBallPosition, vector) + Vector3.Distance(vector, targetPoint);
						if (hitAngleCosine < num3 || (num3 > 0.5f && targetBallToTargetDistance > num4))
						{
							aimpoint = vector;
							hitAngleCosine = num3;
							targetBallToTargetDistance = num4;
							return true;
						}
					}
				}
			}
			return false;
		}
	}
	public delegate bool FindBestTargetBallException<Int>(int ballId);
	public delegate void CalculateAIHandler<BallPoolAIManager>(BallPoolAIManager aiManager);
	public struct BestTargetBallInfo
	{
		internal readonly Ball targetBall;

		internal readonly int pocketId;

		internal readonly Vector3 shotBallPosition;

		internal readonly Vector3 shotPoint;

		internal readonly Vector3 aimpoint;

		internal readonly float impulse;

		public BestTargetBallInfo(Ball targetBall, int pocketId, Vector3 shotBallPosition, Vector3 shotPoint, Vector3 aimpoint, float impulse)
		{
			this.targetBall = targetBall;
			this.pocketId = pocketId;
			this.shotBallPosition = shotBallPosition;
			this.shotPoint = shotPoint;
			this.aimpoint = aimpoint;
			this.impulse = impulse;
		}

		public override string ToString()
		{
			return string.Concat("Target ball id: ", (targetBall ? targetBall.id.ToString() : "null").ToString(), ", pocket id: ", pocketId, ", Shot ball position: ", shotBallPosition, ", Shot point: ", shotPoint, ", Aimpoint: ", aimpoint, ", Impulse: ", impulse);
		}
	}
	public abstract class BallPoolAIManager : MonoBehaviour
	{
		[SerializeField]
		private ShotController shotController;

		[SerializeField]
		private GameManager gameManager;

		[SerializeField]
		private Transform pockets;

		private PocketListener[] targets;

		public BestTargetBallInfo info { get; set; }

		public bool haveExaption { get; set; }

		public bool cancelCalculateAI { get; set; }

		public bool calculateAI { get; set; }

		public event CalculateAIHandler<BallPoolAIManager> OnStartCalculateAI;

		public event CalculateAIHandler<BallPoolAIManager> OnEndCalculateAI;

		private void Awake()
		{
			targets = pockets.GetComponentsInChildren<PocketListener>();
		}

		public void CancelCalculateAI()
		{
			cancelCalculateAI = true;
			calculateAI = false;
		}

		public void CalculateAI()
		{
			if (!calculateAI && !shotController.physicsManager.inMove)
			{
				UnityEngine.Debug.Log("CalculateAI");
				calculateAI = true;
				haveExaption = false;
				cancelCalculateAI = false;
				if (this.OnStartCalculateAI != null)
				{
					this.OnStartCalculateAI(this);
				}
				CalculateAI(3, shotController.cueBall, shotController.physicsManager.ballMaxVelocity, FindException, AightBallPoolGameLogic.gameState.cueBallInHand && !AightBallPoolGameLogic.gameState.tableIsOpened);
			}
		}

		private void CallEndCalculateAI(bool haveExaption)
		{
			this.haveExaption = haveExaption;
			calculateAI = false;
			if (this.OnEndCalculateAI != null)
			{
				this.OnEndCalculateAI(this);
			}
		}

		public abstract bool FindException(int ballId);

		private void CalculateAI(int calculateMaxCount, Ball cueBall, float impulse, FindBestTargetBallException<int> FindException, bool changePosition)
		{
			if (AightBallPoolGameLogic.gameState.tableIsOpened)
			{
				Vector3 vector = shotController.firstMoveSpace.position + UnityEngine.Random.Range(-0.5f * shotController.firstMoveSpace.lossyScale.x, 0.5f * shotController.firstMoveSpace.lossyScale.y) * Vector3.right + UnityEngine.Random.Range(-0.5f * shotController.firstMoveSpace.lossyScale.z, 0.5f * shotController.firstMoveSpace.lossyScale.z) * Vector3.forward;
				vector = new Vector3(vector.x, cueBall.position.y, vector.z);
				cueBall.position = Geometry.ClampPositionInCube(vector, cueBall.radius, shotController.firstMoveSpace);
			}
			if (cueBall.position.y < 0f)
			{
				Vector3 vector2 = cueBall.position;
				Vector2 xzVector = Billiards.VectorExtension.ToXZ(in vector2);
				cueBall.position = Billiards.VectorExtension.ToVector3FromXZ(in xzVector, cueBall.radius);
			}
			float impulse2 = impulse;
			if (!AightBallPoolGameLogic.gameState.tableIsOpened)
			{
				float b = UnityEngine.Random.Range(0.5f, 1.2f) * impulse;
				float value = BallPoolAIExtension.DumbLevel;
				(float, float) input = (1f, 5f);
				(float, float) output = (0f, 1f);
				impulse2 = Mathf.Lerp(impulse, b, value.RemapClamped(in input, in output));
			}
			info = FindBestTargetBall(cueBall, impulse2, FindException, changePosition);
			haveExaption = !info.targetBall || FindException(info.targetBall.id);
			if (haveExaption)
			{
				info = FindSuboptimalTargetBall(cueBall, impulse2, FindException, changePosition);
				haveExaption = !info.targetBall || FindException(info.targetBall.id);
			}
			CallEndCalculateAI(haveExaption);
		}

		private BestTargetBallInfo FindBestTargetBall(Ball cueBall, float impulse, FindBestTargetBallException<int> FindException, bool changePosition)
		{
			int pocketId = 0;
			Vector3 cueBallPosition = cueBall.position;
			Vector3 shotPoint = Vector3.zero;
			Vector3 aimpoint = Vector3.zero;
			return new BestTargetBallInfo(BallAICalculator.FindBestTargetBall(cueBall, targets, gameManager.balls, out pocketId, out cueBallPosition, out shotPoint, out aimpoint, ref impulse, FindException, changePosition, shotController.ballLayer, shotController.boardLayer, shotController.ClothSpace), pocketId, cueBallPosition, shotPoint, aimpoint, impulse).ToDumb();
		}

		private BestTargetBallInfo FindSuboptimalTargetBall(Ball cueBall, float impulse, FindBestTargetBallException<int> FindException, bool changePosition)
		{
			int pocketId = 0;
			Vector3 cueBallPosition = cueBall.position;
			Vector3 shotPoint = Vector3.zero;
			Vector3 aimpoint = Vector3.zero;
			return new BestTargetBallInfo(BallAICalculator.FindSuboptimalTargetBall(cueBall, targets, gameManager.balls, out pocketId, out cueBallPosition, out shotPoint, out aimpoint, ref impulse, FindException, changePosition, shotController.ballLayer, shotController.boardLayer), pocketId, cueBallPosition, shotPoint, aimpoint, impulse);
		}

		private BestTargetBallInfo FindSecondWorstTargetBall(Ball cueBall, float impulse, FindBestTargetBallException<int> FindException, bool changePosition)
		{
			int pocketId = 0;
			Vector3 cueBallPosition = cueBall.position;
			Vector3 shotPoint = Vector3.zero;
			Vector3 aimpoint = Vector3.zero;
			return new BestTargetBallInfo(BallAICalculator.FindSecondWorstTargetBall(cueBall, targets, gameManager.balls, out pocketId, out cueBallPosition, out shotPoint, out aimpoint, ref impulse, FindException, changePosition, shotController.ballLayer, shotController.boardLayer), pocketId, cueBallPosition, shotPoint, aimpoint, impulse);
		}

		public BestTargetBallInfo GetCalculateInfo(Ball cueBall, float impulse, FindBestTargetBallException<int> exception = null)
		{
			if (exception == null)
			{
				exception = this.BuildPlayerException();
			}
			BestTargetBallInfo result = FindBestTargetBall(cueBall, impulse, exception, changePosition: false);
			bool flag = !result.targetBall || exception(result.targetBall.id);
			if (flag)
			{
				result = FindSuboptimalTargetBall(cueBall, impulse, exception, changePosition: false);
				flag = !result.targetBall || exception(result.targetBall.id);
			}
			if (flag)
			{
				result = FindSecondWorstTargetBall(cueBall, impulse, exception, changePosition: false);
				flag = !result.targetBall || exception(result.targetBall.id);
			}
			if (flag)
			{
				UnityEngine.Debug.Log("[BPAM] CANNOT found target ball.");
			}
			return result;
		}
	}
	public class AightBallPoolAIManager : BallPoolAIManager
	{
		public override bool FindException(int ballId)
		{
			if (AightBallPoolGameLogic.isCueBall(ballId))
			{
				return true;
			}
			bool flag = AightBallPoolGameLogic.isBlackBall(ballId);
			if (!AightBallPoolGameLogic.gameState.playersHasBallType && flag)
			{
				return true;
			}
			if (!AightBallPoolGameLogic.gameState.playersHasBallType && !flag)
			{
				return false;
			}
			bool isBlack = AightBallPoolPlayer.mainPlayer.isBlack;
			bool isBlack2 = AightBallPoolPlayer.otherPlayer.isBlack;
			bool flag2 = AightBallPoolGameLogic.isStripesBall(ballId);
			bool flag3 = AightBallPoolGameLogic.isSolidsBall(ballId);
			if (AightBallPoolPlayer.mainPlayer.myTurn)
			{
				if (isBlack)
				{
					return !flag;
				}
				if (flag)
				{
					return true;
				}
				bool isStripes = AightBallPoolPlayer.mainPlayer.isStripes;
				bool isSolids = AightBallPoolPlayer.mainPlayer.isSolids;
				if (flag2)
				{
					return !isStripes;
				}
				if (flag3)
				{
					return !isSolids;
				}
			}
			else if (AightBallPoolPlayer.otherPlayer.myTurn)
			{
				if (isBlack2)
				{
					return !flag;
				}
				if (flag)
				{
					return true;
				}
				bool isStripes2 = AightBallPoolPlayer.otherPlayer.isStripes;
				bool isSolids2 = AightBallPoolPlayer.otherPlayer.isSolids;
				if (flag2)
				{
					return !isStripes2;
				}
				if (flag3)
				{
					return !isSolids2;
				}
			}
			return false;
		}
	}
}
namespace Billiards
{
	public class BilliardsXRTestInteractor : XRBaseInteractable
	{
		private XRInteractionManager manager;

		[SerializeField]
		private Text text;

		[SerializeField]
		private XRRayInteractor interactor;

		[SerializeField]
		private XRInteractorLineVisual xrilv;

		[SerializeField]
		private XRRig xrRig;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController controller;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController subController;

		private bool allowMovement;

		private Vector3 defaultPosition;

		protected override void Awake()
		{
			base.Awake();
			interactor.onSelectEnter.AddListener(delegate
			{
				text.text = "onSelectEnter : ";
			});
			Singleton<BilliardsDataContainer>.Instance.ControllerBackButton.OnDataChanged += WorldRotate;
		}

		private void WorldRotate(bool isOn)
		{
			allowMovement = isOn;
			if (allowMovement)
			{
				defaultPosition = controller.transform.position;
			}
		}

		private void Update()
		{
			text.text = string.Empty;
			controller.inputDevice.IsPressed(InputHelpers.Button.Trigger, out var isPressed, controller.axisToPressThreshold);
			if (isPressed)
			{
				text.text += "Trigger Pressed";
			}
			controller.inputDevice.IsPressed(InputHelpers.Button.Grip, out var isPressed2, controller.axisToPressThreshold);
			if (isPressed2)
			{
				text.text += "Grip Pressed";
			}
			controller.inputDevice.IsPressed(InputHelpers.Button.Primary2DAxisClick, out var isPressed3, controller.axisToPressThreshold);
			if (isPressed3)
			{
				text.text += "isp2acPressed Pressed";
			}
			if (controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value))
			{
				Vector3 vector = xrRig.transform.InverseTransformVector(value);
				Text obj = text;
				obj.text = string.Concat(obj.text, value, "\n");
				text.text += vector;
			}
			controller.inputDevice.IsPressed(InputHelpers.Button.PrimaryAxis2DRight, out var isPressed4, controller.axisToPressThreshold);
			Singleton<BilliardsDataContainer>.Instance.ControllerTrigger.CurrentData = isPressed4;
			UnityEngine.Debug.DrawRay(interactor.attachTransform.position, interactor.attachTransform.forward, Color.magenta, Time.deltaTime);
		}

		public void OnReticlePositionUpdate(XRNode node, Vector3 position)
		{
			UnityEngine.Debug.Log($"{node}'s reticle update position at {position} ");
		}

		public override void AttachCustomReticle(XRBaseInteractor interactor)
		{
			base.AttachCustomReticle(interactor);
			text.text = "AttachCustomReticle";
		}

		public override bool IsHoverableBy(XRBaseInteractor interactor)
		{
			return base.IsHoverableBy(interactor);
		}

		public override bool IsSelectableBy(XRBaseInteractor interactor)
		{
			return base.IsSelectableBy(interactor);
		}

		public override void ProcessInteractable(XRInteractionUpdateOrder.UpdatePhase updatePhase)
		{
			base.ProcessInteractable(updatePhase);
		}

		public override void RemoveCustomReticle(XRBaseInteractor interactor)
		{
			base.RemoveCustomReticle(interactor);
		}

		protected override void OnActivate(XRBaseInteractor interactor)
		{
			text.text = "OnActivate";
			base.OnActivate(interactor);
		}

		protected override void OnDeactivate(XRBaseInteractor interactor)
		{
			text.text = "OnDeactivate";
			base.OnDeactivate(interactor);
		}

		protected override void OnHoverEnter(XRBaseInteractor interactor)
		{
			base.OnHoverEnter(interactor);
		}

		protected override void OnHoverExit(XRBaseInteractor interactor)
		{
			base.OnHoverExit(interactor);
		}

		protected override void OnSelectEnter(XRBaseInteractor interactor)
		{
			base.OnSelectEnter(interactor);
		}

		protected override void OnSelectExit(XRBaseInteractor interactor)
		{
			text.text = "OnSelectExit";
			base.OnSelectExit(interactor);
		}

		protected override void Reset()
		{
			base.Reset();
		}
	}
	public static class GameConfig
	{
		public const string TableSceneName = "Home_map";

		public const float MaxTurnTime = 50f;

		public const float TurnEndDelay = 1.2f;

		public const float MinBallMoveEnergy = 0.09f;

		public const float MinContactThresholdVelocity = 1E-05f;

		public const float CueSliderRadius = 0.02829273f;

		public const float CuePivotRotateSpeed = 1.45f;

		public const float CuePivotRotateSpeedDecreaseTime = 2f;

		public const float TableCenterRotateSpeed = 2f;

		public const float CueDistanceMoveSpeed = 0.05f;

		public const float CueMoveThreshold = 0.25f;

		public const float CueDistanceMin = 0.8f;

		public const float CueDistanceMax = 1.3f;

		public const float LineLengthPerLevel = 0.07f;

		public const float DefaultLineLength = 0.25f;

		public const float MultiplayerLineLength = 0.075f;

		public const float SpinBallRadiusRate = 0.825f;

		public const float SpinSliderPositionZ = -0.02f;

		public const float TableSurfaceOffset = 0.91607f;

		public const float SubControllerSnapAngle = 10f;

		public const float MainControllerTrackingRate = 0.075f;

		public const float MaxControllerXAxisAngularVelocity = 7f;

		public const float ControllerXAxisAngularVelocityRate = 0.35f;

		public const float ControllerVelocityRate = 0.55f;

		public static readonly Vector2 TouchRectMin = new Vector2(50f, 50f);

		public static readonly Vector2 TouchRectMax = new Vector2(200f, 160f);

		public const float AIMinimumImpulseRate = 0.5f;

		public const float AIMaximumImpulseRate = 0.7f;

		public const float AIDumbPerLevel = 0.1225f;

		public const float AIMinimumDumb = 0.2f;

		public const float SubScreenViewSize = 1.6f;

		public const float SubScreenViewAdditionalRange = 0.2f;

		public const float SubScreenViewAdditionalScale = 2f;

		public const float HitPositionMarkerRadius = 0.008f;

		public const float TutorialExposeTime = 5f;

		public const float SendGameInterval = 0.1f;

		public const float SendEnvironmentInterval = 0.075f;

		public const float PlayerSnapAngle = 22.5f;

		public const int PlayerHandUpdateThreshold = 5;

		public const float PlayerCharacterToneValue = 0.18f;

		public static readonly Vector3 PlayerLeftHandDefaultLocalPosition = new Vector3(-0.0031f, -0.0004f, -0.5079f);

		public static readonly Vector3 PlayerLeftHandDefaultLocalEuler = new Vector3(-0.168f, 0f, 0f);

		public const float MinimumCuePositionHeight = 0.008715574f;

		public const float MinimumCueAngle = 5f;

		public const string FxSoundGroupName = "Fx";
	}
	public class HandLineManager : Singleton<HandLineManager>
	{
		public class Container
		{
			private List<MonoBehaviour> Requesters = new List<MonoBehaviour>();

			public event Action<bool> onEnableEvent;

			public void RequestShow(bool enable, MonoBehaviour requester)
			{
				if (enable)
				{
					if (!Requesters.Contains(requester))
					{
						Requesters.Add(requester);
					}
				}
				else if (Requesters.Contains(requester))
				{
					Requesters.Remove(requester);
				}
				SetEnable(CheckEnable());
			}

			private bool CheckEnable()
			{
				Requesters.RemoveAll((MonoBehaviour target) => target == null);
				if (Requesters.Count > 0)
				{
					return true;
				}
				return false;
			}

			private void SetEnable(bool value)
			{
				this.onEnableEvent?.Invoke(value);
			}
		}

		public Container SubHand { get; private set; }

		public Container MainHand { get; private set; }

		public HandLineManager()
		{
			SubHand = new Container();
			SubHand.onEnableEvent += SubHandLineActive;
			MainHand = new Container();
			MainHand.onEnableEvent += MainHandLineActive;
			static void MainHandLineActive(bool value)
			{
				Singleton<BilliardsDataContainer>.Instance.MainHandLineActivation.CurrentData = value;
			}
			static void SubHandLineActive(bool value)
			{
				Singleton<BilliardsDataContainer>.Instance.SubHandLineActivation.CurrentData = value;
			}
		}
	}
	public class HandLineControl : MonoBehaviour
	{
		[SerializeField]
		private bool isMain;

		[SerializeField]
		private XRInteractorLineVisual mainHandLineVisual;

		[SerializeField]
		private Gradient DefaultValidColor;

		[SerializeField]
		private Gradient DefaultInvalidColor;

		[SerializeField]
		private Gradient ActiveValidColor;

		[SerializeField]
		private Gradient ActiveInvalidColor;

		private void SetMainHandEvent()
		{
			Singleton<BilliardsDataContainer>.Instance.MainHandLineActivation.OnDataChanged += HandLineActivation_OnDataChanged;
			HandLineActivation_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.MainHandLineActivation.CurrentData);
		}

		private void SetSubHandEvent()
		{
			Singleton<BilliardsDataContainer>.Instance.SubHandLineActivation.OnDataChanged += HandLineActivation_OnDataChanged;
			HandLineActivation_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.SubHandLineActivation.CurrentData);
		}

		private void Awake()
		{
			SetHandEvent(PublicGameUIManager.gameSetting.IsRightHanded());
			PublicGameUIManager.gameSetting.AddHandChangedEvent(SetHandEvent);
		}

		private void SetHandEvent(bool isRightHanded)
		{
			Singleton<BilliardsDataContainer>.Instance.MainHandLineActivation.OnDataChanged -= HandLineActivation_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.SubHandLineActivation.OnDataChanged -= HandLineActivation_OnDataChanged;
			if (isMain)
			{
				if (isRightHanded)
				{
					SetMainHandEvent();
				}
				else
				{
					SetSubHandEvent();
				}
			}
			else if (isRightHanded)
			{
				SetSubHandEvent();
			}
			else
			{
				SetMainHandEvent();
			}
		}

		private void HandLineActivation_OnDataChanged(bool isActive)
		{
			if (isActive)
			{
				mainHandLineVisual.validColorGradient = ActiveValidColor;
				mainHandLineVisual.invalidColorGradient = ActiveInvalidColor;
			}
			else
			{
				mainHandLineVisual.validColorGradient = DefaultValidColor;
				mainHandLineVisual.invalidColorGradient = DefaultInvalidColor;
			}
		}

		private void OnDestroy()
		{
			Singleton<BilliardsDataContainer>.Instance.MainHandLineActivation.OnDataChanged -= HandLineActivation_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.SubHandLineActivation.OnDataChanged -= HandLineActivation_OnDataChanged;
		}
	}
	[Serializable]
	public class ControllerObject
	{
		public GameObject controller;

		public Transform dot;

		public Transform start;

		public Transform ray_alpha;

		public Transform CursorDot;

		public void SetActive(bool value)
		{
			controller.SetActive(value);
		}
	}
	[Obsolete("Use ViveControll instead", true)]
	public class PicoControll : MonoBehaviour
	{
		[SerializeField]
		private GameObject HeadSetController;

		[SerializeField]
		private ControllerObject controller0;

		[SerializeField]
		private ControllerObject controller1;

		private Ray ray;

		private int CachedMainHandNess = -1;

		private Transform lastHit;

		private Transform currentHit;

		public float rayDefaultLength = 4f;

		private bool isHasController;

		private bool headcontrolmode;

		private ControllerObject currentController
		{
			get
			{
				if (CachedMainHandNess == -1)
				{
					CachedMainHandNess = 0;
				}
				if (CachedMainHandNess == 0)
				{
					return controller0;
				}
				if (CachedMainHandNess == 1)
				{
					return controller1;
				}
				return null;
			}
		}

		public static bool GetTotalTriggerUp => Input.GetMouseButtonUp(0);

		public static bool GetTotalTriggerDown => Input.GetMouseButtonDown(0);

		public static bool GetTotalTrigger => Input.GetMouseButton(0);

		public static bool GetTotalTouched => Input.GetMouseButton(1);

		public static bool GetTotalTouchButton
		{
			get
			{
				if (!Input.GetKeyDown(KeyCode.JoystickButton0))
				{
					return Input.GetMouseButton(1);
				}
				return true;
			}
		}

		public static Vector2 GetTotalTouchPad => new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical"));

		public static Vector3 GetAngularVelocity => new Vector3(Mathf.Clamp(Input.GetAxis("Mouse Y") * 0.35f, -7f, 7f), 0f, 0f);

		public static bool GetTotalBackButton => Input.GetKeyDown(KeyCode.Escape);

		private bool TryGetController(int idx, out ControllerObject obj)
		{
			switch (idx)
			{
			case 0:
				obj = controller0;
				return true;
			case 1:
				obj = controller1;
				return true;
			default:
				obj = null;
				return false;
			}
		}

		private void Start()
		{
			ray = default(Ray);
		}

		private void OnDestroy()
		{
			_ = isHasController;
		}

		private bool TrySetRay()
		{
			if (HeadSetController.activeSelf)
			{
				Vector3 euler = new Vector3(0f, 0f, 0f);
				HeadSetController.transform.parent.localRotation = Quaternion.Euler(euler);
				ray.direction = HeadSetController.transform.position - HeadSetController.transform.parent.parent.Find("Head").position;
				ray.origin = HeadSetController.transform.parent.parent.Find("Head").position;
				return true;
			}
			if (currentController != null)
			{
				ray.direction = currentController.CursorDot.position - currentController.start.position;
				ray.origin = currentController.start.position;
				return true;
			}
			return false;
		}

		private void Raycast(out RaycastHit hit)
		{
			if (Physics.Raycast(ray, out hit, 10f, 1 << Layer.NameToLayer(Layer.GameType.Billiards, "RayReactor")))
			{
				currentHit = hit.transform;
				if (currentHit != lastHit && lastHit != null)
				{
					BaseRaycastReactor baseRaycastReactor = CacheManager.Get<BaseRaycastReactor>(lastHit);
					if (baseRaycastReactor != null)
					{
						baseRaycastReactor.OnRayEnd(hit);
					}
				}
				lastHit = hit.transform;
				return;
			}
			currentHit = null;
			if (currentHit != lastHit && lastHit != null)
			{
				BaseRaycastReactor baseRaycastReactor2 = CacheManager.Get<BaseRaycastReactor>(lastHit);
				if (baseRaycastReactor2 != null)
				{
					baseRaycastReactor2.OnRayEnd(hit);
				}
			}
			if (HeadSetController.activeSelf && HeadSetController.name == "SightPointer")
			{
				HeadSetController.transform.localScale = Vector3.zero;
			}
		}

		private void Update()
		{
			if (!TrySetRay())
			{
				return;
			}
			Raycast(out var hit);
			BaseRaycastReactor baseRaycastReactor = CacheManager.Get<BaseRaycastReactor>(hit.transform);
			if (baseRaycastReactor != null)
			{
				BaseRaycastReactor baseRaycastReactor2 = baseRaycastReactor;
				if ((object)baseRaycastReactor2 != null)
				{
					baseRaycastReactor2 = baseRaycastReactor2;
					baseRaycastReactor2.OnRay(hit);
				}
				else
				{
					baseRaycastReactor.OnRay(hit);
				}
			}
			if (GetTotalTriggerDown && baseRaycastReactor != null)
			{
				BaseRaycastReactor baseRaycastReactor2 = baseRaycastReactor;
				if ((object)baseRaycastReactor2 != null)
				{
					baseRaycastReactor2 = baseRaycastReactor2;
					baseRaycastReactor2.RaycastReact(hit);
				}
				else
				{
					baseRaycastReactor.RaycastReact(hit);
				}
			}
		}

		public void SwitchControlMode()
		{
		}
	}
	public class ViveControll : MonoBehaviour
	{
		[SerializeField]
		private XRRig xrRig;

		[SerializeField]
		private XRRayInteractor interactor;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController RightController;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController LeftController;

		private Transform lastHit;

		private Transform currentHit;

		private void Awake()
		{
			XRControllerState.Button target = XRControllerState.Button.MenuButton | XRControllerState.Button.Trigger | XRControllerState.Button.Grip | XRControllerState.Button.Primary2DAxisTouch | XRControllerState.Button.Primary2DAxisClick | XRControllerState.Button.PrimaryAxis2DUp | XRControllerState.Button.PrimaryAxis2DDown | XRControllerState.Button.PrimaryAxis2DLeft | XRControllerState.Button.PrimaryAxis2DRight;
			Singleton<BilliardsDataContainer>.Instance.XRRigid.CurrentData = xrRig;
			Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.Initialize(xrRig, LeftController, target);
			Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.Initialize(xrRig, RightController, target);
		}

		private void Raycast(out RaycastHit hit)
		{
			if (interactor.GetCurrentRaycastHit(out hit))
			{
				currentHit = hit.transform;
				if (currentHit != lastHit && lastHit != null)
				{
					BaseRaycastReactor baseRaycastReactor = CacheManager.Get<BaseRaycastReactor>(lastHit);
					if (baseRaycastReactor != null)
					{
						baseRaycastReactor.OnRayEnd(hit);
					}
				}
				lastHit = hit.transform;
				return;
			}
			currentHit = null;
			if (currentHit != lastHit && lastHit != null)
			{
				BaseRaycastReactor baseRaycastReactor2 = CacheManager.Get<BaseRaycastReactor>(lastHit);
				if (baseRaycastReactor2 != null)
				{
					baseRaycastReactor2.OnRayEnd(hit);
				}
			}
		}

		private void Update()
		{
			Raycast(out var hit);
			BaseRaycastReactor baseRaycastReactor = CacheManager.Get<BaseRaycastReactor>(hit.transform);
			if (baseRaycastReactor != null)
			{
				BaseRaycastReactor baseRaycastReactor2 = baseRaycastReactor;
				if ((object)baseRaycastReactor2 != null)
				{
					baseRaycastReactor2 = baseRaycastReactor2;
					baseRaycastReactor2.OnRay(hit);
				}
				else
				{
					baseRaycastReactor.OnRay(hit);
				}
			}
			if (Singleton<BilliardsDataContainer>.Instance.XRRightControllerState[InputHelpers.Button.Trigger].CurrentData && baseRaycastReactor != null)
			{
				BaseRaycastReactor baseRaycastReactor2 = baseRaycastReactor;
				if ((object)baseRaycastReactor2 != null)
				{
					baseRaycastReactor2 = baseRaycastReactor2;
					baseRaycastReactor2.RaycastReact(hit);
				}
				else
				{
					baseRaycastReactor.RaycastReact(hit);
				}
			}
			XRControllerState xRLeftControllerState = Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState;
			InputDevice inputDevice = Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.Controller.inputDevice;
			xRLeftControllerState.ForceUpdate(in inputDevice);
			XRControllerState xRRightControllerState = Singleton<BilliardsDataContainer>.Instance.XRRightControllerState;
			inputDevice = Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.Controller.inputDevice;
			xRRightControllerState.ForceUpdate(in inputDevice);
		}
	}
	public static class BallPoolAIExtension
	{
		public static int DumbLevel = 5;

		public static int AILevel
		{
			get
			{
				if (BallPoolGameLogic.playMode != 0)
				{
					return -1;
				}
				return 5 - Mathf.Clamp(DumbLevel, 0, 4);
			}
		}

		public static BestTargetBallInfo ToDumb(this BestTargetBallInfo bestInfo)
		{
			Matrix4x4 identity = Matrix4x4.identity;
			float num = (float)Mathf.Clamp(DumbLevel - 1, 0, 5) * 0.1225f + 0.2f;
			float num2 = UnityEngine.Random.Range(0f - num, num);
			identity.SetTRS(Vector3.zero, Quaternion.Euler(Vector3.up * num2), Vector3.one);
			Vector3 shotPoint = identity.MultiplyPoint(bestInfo.shotPoint);
			Vector3 aimpoint = identity.MultiplyPoint(bestInfo.aimpoint);
			return new BestTargetBallInfo(bestInfo.targetBall, bestInfo.pocketId, bestInfo.shotBallPosition, shotPoint, aimpoint, bestInfo.impulse);
		}

		public static FindBestTargetBallException<int> BuildPlayerException(this BallPoolAIManager instance)
		{
			return ((Func<int, bool>)delegate(int ballId)
			{
				if (AightBallPoolGameLogic.isCueBall(ballId))
				{
					return true;
				}
				bool flag = AightBallPoolGameLogic.isBlackBall(ballId);
				if (!AightBallPoolGameLogic.gameState.playersHasBallType)
				{
					return flag;
				}
				bool isBlack = AightBallPoolPlayer.mainPlayer.isBlack;
				bool isBlack2 = AightBallPoolPlayer.otherPlayer.isBlack;
				bool flag2 = AightBallPoolGameLogic.isStripesBall(ballId);
				bool flag3 = AightBallPoolGameLogic.isSolidsBall(ballId);
				if (AightBallPoolPlayer.mainPlayer.myTurn)
				{
					if (isBlack)
					{
						return !flag;
					}
					if (flag)
					{
						return true;
					}
					bool isStripes = AightBallPoolPlayer.mainPlayer.isStripes;
					bool isSolids = AightBallPoolPlayer.mainPlayer.isSolids;
					if (flag2)
					{
						return !isStripes;
					}
					if (flag3)
					{
						return !isSolids;
					}
				}
				else if (AightBallPoolPlayer.otherPlayer.myTurn)
				{
					if (isBlack2)
					{
						return !flag;
					}
					if (flag)
					{
						return true;
					}
					bool isStripes2 = AightBallPoolPlayer.otherPlayer.isStripes;
					bool isSolids2 = AightBallPoolPlayer.otherPlayer.isSolids;
					if (flag2)
					{
						return !isStripes2;
					}
					if (flag3)
					{
						return !isSolids2;
					}
				}
				return false;
			}).Invoke;
		}
	}
	public class CacheManager
	{
		private static class Instance
		{
			internal static readonly CacheManager value;

			static Instance()
			{
				value = new CacheManager();
			}
		}

		private class Pair
		{
			public float time;

			public object obj;

			public Pair(float time, object obj)
			{
				this.time = time;
				this.obj = obj;
			}
		}

		private Dictionary<object, Pair> cached = new Dictionary<object, Pair>();

		private int count;

		private int missCount;

		private int catchCount;

		public static CacheManager instance => Instance.value;

		private CacheManager()
		{
		}

		public static T Get<T>(string resourcePath) where T : class
		{
			if (instance.cached.TryGetValue(resourcePath, out var value))
			{
				instance.catchCount++;
				value.time = Time.time;
				return value.obj as T;
			}
			instance.missCount++;
			instance.cached.Add(resourcePath, new Pair(0f, Resources.Load(resourcePath)));
			return Get<T>(resourcePath);
		}

		public static T Get<T>(Component type) where T : Component
		{
			if (type == null || type.gameObject == null)
			{
				return null;
			}
			return Get<T>(type.gameObject);
		}

		public static T Get<T>(GameObject gameObject) where T : Component
		{
			if (instance.cached.TryGetValue(gameObject, out var value))
			{
				instance.catchCount++;
				Dictionary<Type, object> dictionary = value.obj as Dictionary<Type, object>;
				if (dictionary.TryGetValue(typeof(T), out var value2))
				{
					value.time = Time.time;
					return value2 as T;
				}
				dictionary.Add(typeof(T), gameObject.GetComponent<T>());
				return Get<T>(gameObject);
			}
			instance.missCount++;
			instance.cached.Add(gameObject, new Pair(0f, new Dictionary<Type, object>()));
			return Get<T>(gameObject);
		}

		public static T[] Gets<T>(GameObject gameObject) where T : Component
		{
			if (instance.cached.TryGetValue(gameObject, out var value))
			{
				instance.catchCount++;
				Dictionary<Type, object> dictionary = value.obj as Dictionary<Type, object>;
				if (dictionary.TryGetValue(typeof(T[]), out var value2))
				{
					value.time = Time.time;
					return value2 as T[];
				}
				dictionary.Add(typeof(T[]), gameObject.GetComponents<T>());
				return Gets<T>(gameObject);
			}
			instance.missCount++;
			instance.cached.Add(gameObject, new Pair(0f, new Dictionary<Type, object>()));
			return Gets<T>(gameObject);
		}

		public static bool Remove<T>(Component type) where T : Component
		{
			if (type == null || type.gameObject == null)
			{
				return false;
			}
			return Remove<T>(type.gameObject);
		}

		public static bool Remove<T>(GameObject gameObject) where T : Component
		{
			if (instance.cached.TryGetValue(gameObject, out var value))
			{
				return (value.obj as Dictionary<Type, object>).Remove(typeof(T));
			}
			return false;
		}

		public static void UnLoadCacheData(float time)
		{
			int num = instance.cached.Count;
			List<object> list = new List<object>();
			foreach (KeyValuePair<object, Pair> item in instance.cached)
			{
				if (Time.time - item.Value.time >= time)
				{
					list.Add(item.Key);
				}
			}
			foreach (object item2 in list)
			{
				instance.cached.Remove(item2);
			}
			int num2 = instance.cached.Count;
			GC.Collect();
			UnityEngine.Debug.LogFormat("Cache Cleared : {0} -> {1} ,Total {2} is Removed.", num, num2, num - num2);
			UnityEngine.Debug.LogFormat("Cache accuracy: {0} / {1} ", instance.missCount, instance.catchCount);
			instance.missCount = 0;
			instance.catchCount = 0;
		}
	}
	public static class CollectionExtension
	{
		public static T GetRandom<T>(this List<T> list)
		{
			return list[UnityEngine.Random.Range(0, list.Count)];
		}

		public static T GetRandom<T>(this List<T> list, Predicate<T> pred)
		{
			return list.Where(pred.Invoke).ToList()[UnityEngine.Random.Range(0, list.Count)];
		}
	}
	public class NotifiableVariable<T> where T : struct
	{
		private T value;

		public T Value
		{
			get
			{
				return value;
			}
			set
			{
				Set(value);
			}
		}

		public event Action<T> OnNext;

		public event Action<T> OnComplete;

		public NotifiableVariable()
		{
			value = default(T);
		}

		public NotifiableVariable(T value)
		{
			this.value = value;
		}

		public void Set(T value, bool withNoti = true)
		{
			if (withNoti)
			{
				this.OnNext?.Invoke(value);
			}
			this.value = value;
			if (withNoti)
			{
				this.OnComplete?.Invoke(this.value);
			}
		}
	}
	public abstract class Singleton<T> where T : class, new()
	{
		private static readonly Lazy<T> instance = new Lazy<T>(() => new T());

		public static T Instance => instance.Value;
	}
	public class MonoSingleton<T> : MonoBehaviour where T : MonoBehaviour
	{
		protected static T _instance;

		private static object _lock = new object();

		private static bool applicationIsQuitting = false;

		public static T Instance
		{
			get
			{
				if (applicationIsQuitting)
				{
					UnityEngine.Debug.LogWarning(string.Concat("[Singleton] Instance '", typeof(T), "' already destroyed on application quit. Won't create again - returning null."));
					return null;
				}
				lock (_lock)
				{
					if (_instance == null)
					{
						_instance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
						if (UnityEngine.Object.FindObjectsOfType(typeof(T)).Length > 1)
						{
							UnityEngine.Debug.LogError("[Singleton] Something went really wrong  - there should never be more than 1 singleton! Reopening the scene might fix it.");
							return _instance;
						}
						if (_instance == null)
						{
							GameObject gameObject = new GameObject();
							_instance = gameObject.AddComponent<T>();
							gameObject.name = "(singleton) " + typeof(T).ToString();
							UnityEngine.Object.DontDestroyOnLoad(gameObject);
							UnityEngine.Debug.Log(string.Concat("[Singleton] An instance of ", typeof(T), " is needed in the scene, so '", gameObject, "' was created with DontDestroyOnLoad."));
						}
						else
						{
							UnityEngine.Debug.Log("[Singleton] Using instance already created: " + _instance.gameObject.name);
						}
					}
					return _instance;
				}
			}
		}

		private static event Action<T> onInitialized;

		public static event Action<T> OnInitialized
		{
			add
			{
				if (_instance != null)
				{
					value?.Invoke(_instance);
				}
				else
				{
					onInitialized += value;
				}
			}
			remove
			{
				onInitialized -= value;
			}
		}

		public virtual void OnDestroy()
		{
			if (_instance == this)
			{
				applicationIsQuitting = true;
			}
		}

		public virtual void OnApplicationQuit()
		{
			applicationIsQuitting = true;
		}

		protected virtual void Awake()
		{
			if (_instance == null)
			{
				_instance = this as T;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				MonoSingleton<T>.onInitialized?.Invoke(_instance);
				MonoSingleton<T>.onInitialized = null;
			}
		}
	}
	public static class UIExtension
	{
		public static PointerEventData Clone(this PointerEventData ped)
		{
			return new PointerEventData(EventSystem.current)
			{
				position = ped.position,
				delta = ped.delta,
				clickTime = ped.clickTime,
				clickCount = ped.clickCount
			};
		}

		public static Vector2 WorldToScreen(this Vector3 position)
		{
			return Camera.main.WorldToScreenPoint(position);
		}

		public static Vector2 WorldToCanvas(this Vector3 position, RectTransform canvasTransform)
		{
			Vector3 vector = Camera.main.WorldToScreenPoint(position);
			return vector.ToVector2().ScreenToCanvas(canvasTransform);
		}

		public static Vector2 ScreenToCanvas(this Vector2 position, RectTransform canvasTransform)
		{
			return (position - new Vector2(Screen.width, Screen.height) * 0.5f) * new Vector2(canvasTransform.rect.width / (float)Screen.width, canvasTransform.rect.height / (float)Screen.height);
		}

		public static Vector3 ScreenToWorld(this Vector2 pos, Vector3 targetPosition, RectTransform canvasTransform)
		{
			Vector3 position = Camera.main.transform.position;
			Vector3 vector = canvasTransform.TransformPoint(pos);
			return new Vector3((vector.x - position.x) * (targetPosition.z - position.z) / (vector.z - position.z) + position.x, (vector.y - position.y) * (targetPosition.z - position.z) / (vector.z - position.z) + position.y, targetPosition.z);
		}

		public static Vector2 CanvasToScreen(this Vector2 position, RectTransform canvasTransform)
		{
			position /= new Vector2(canvasTransform.rect.width / (float)Screen.width, canvasTransform.rect.height / (float)Screen.height);
			position += new Vector2(Screen.width, Screen.height) * 0.5f;
			return position;
		}
	}
	public static class VectorExtension
	{
		public static float Remap(this float value, in float start1, in float stop1, in float start2, in float stop2)
		{
			return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
		}

		public static float Remap(this float value, in (float, float) input, in (float, float) output)
		{
			return output.Item1 + (output.Item2 - output.Item1) * ((value - input.Item1) / (input.Item2 - input.Item1));
		}

		public static float RemapClamped(this float value, in (float, float) input, in (float, float) output)
		{
			return output.Item1 + (output.Item2 - output.Item1) * ((Mathf.Clamp(value, input.Item1, input.Item2) - input.Item1) / (input.Item2 - input.Item1));
		}

		public static Vector2 ToXZ(this in Vector3 vector)
		{
			return new Vector2(vector.x, vector.z);
		}

		public static Vector2 ToVector2(this in Vector3 vector)
		{
			return vector;
		}

		public static Vector3 ToVector3(this in Vector2 vector)
		{
			return vector;
		}

		public static Vector3 ToVector3(this in Vector2 vector, float z)
		{
			return new Vector3(vector.x, vector.y, z);
		}

		public static Vector3 ToVector3FromXZ(this in Vector2 xzVector)
		{
			return new Vector3(xzVector.x, 0f, xzVector.y);
		}

		public static Vector3 ToVector3FromXZ(this in Vector2 xzVector, float y)
		{
			return new Vector3(xzVector.x, y, xzVector.y);
		}

		public static Vector3 AdaptY(this in Vector3 xzVector, in float y)
		{
			return new Vector3(xzVector.x, y, xzVector.z);
		}

		public static Vector3 Round(this in Vector3 vector, in float scale)
		{
			return new Vector3(Mathf.Round(vector.x / scale) * scale, Mathf.Round(vector.y / scale) * scale, Mathf.Round(vector.z / scale) * scale);
		}

		public static Vector2 Decrease(this in Vector2 vector, in float amount)
		{
			return new Vector2(Mathf.Sign(vector.x) * Mathf.Max(Mathf.Abs(vector.x) - amount, 0f), Mathf.Sign(vector.y) * Mathf.Max(Mathf.Abs(vector.y) - amount, 0f));
		}

		public static Vector3 Decrease(this in Vector3 vector, in float amount)
		{
			return new Vector3(Mathf.Sign(vector.x) * Mathf.Max(Mathf.Abs(vector.x) - amount, 0f), Mathf.Sign(vector.y) * Mathf.Max(Mathf.Abs(vector.y) - amount, 0f), Mathf.Sign(vector.z) * Mathf.Max(Mathf.Abs(vector.z) - amount, 0f));
		}

		public static Vector2 ProjectionToXAxis(this in Vector2 vector, in Vector2 start, in float xAxisValue)
		{
			return new Vector2(xAxisValue, (vector.y - start.y) * (xAxisValue - start.x) / (vector.x - start.x) + start.y);
		}

		public static Vector2 ProjectionToYAxis(this in Vector2 vector, in Vector2 start, in float yAxisValue)
		{
			return new Vector2((vector.x - start.x) * (yAxisValue - start.y) / (vector.y - start.y) + start.x, yAxisValue);
		}

		public static Vector3 ProjectionToZAxis(this in Vector3 vector, in Vector3 start, in float zAxisValue)
		{
			return new Vector3((vector.x - start.x) * (zAxisValue - start.z) / (vector.z - start.z) + start.x, (vector.y - start.y) * (zAxisValue - start.z) / (vector.z - start.z) + start.y, zAxisValue);
		}

		public static Vector3 ProjectionToXAxis(this in Vector3 vector, in Vector3 start, in float xAxisValue)
		{
			return new Vector3(xAxisValue, (vector.y - start.y) * (xAxisValue - start.x) / (vector.x - start.x) + start.y, (vector.z - start.z) * (xAxisValue - start.x) / (vector.x - start.x) + start.z);
		}

		public static Vector3 ProjectionToYAxis(this in Vector3 vector, in Vector3 start, in float yAxisValue)
		{
			return new Vector3((vector.x - start.x) * (yAxisValue - start.y) / (vector.y - start.y) + start.x, yAxisValue, (vector.z - start.z) * (yAxisValue - start.y) / (vector.y - start.y) + start.z);
		}

		public static Vector3 ToAbs(this in Vector3 vector)
		{
			return new Vector3(Mathf.Abs(vector.x), Mathf.Abs(vector.y), Mathf.Abs(vector.z));
		}

		public static Vector3 IntersectionPoint(in Vector3 origin, in Vector3 target, in Vector3 center, in float radius)
		{
			Vector3 vector = Vector3.Project(center - origin, (target - origin).normalized);
			float num = Vector3.Distance(origin + vector, center);
			if (num > radius)
			{
				num = radius;
			}
			float num2 = Mathf.Sqrt(radius * radius - num * num);
			float num3 = vector.magnitude - num2;
			return origin + (target - origin).normalized * num3;
		}
	}
	public class BilliardsDataContainer : Singleton<BilliardsDataContainer>
	{
		public Appnori.Util.NotifierClass<XRRig> XRRigid = new Appnori.Util.NotifierClass<XRRig>();

		public Appnori.Util.NotifierClass<XRReticleProvider> XRLeftReticleProvider = new Appnori.Util.NotifierClass<XRReticleProvider>();

		public Appnori.Util.NotifierClass<XRReticleProvider> XRRightReticleProvider = new Appnori.Util.NotifierClass<XRReticleProvider>();

		public XRControllerState XRLeftControllerState = new XRControllerState();

		public XRControllerState XRRightControllerState = new XRControllerState();

		public Appnori.Util.NotifierClass<LockMarker> LeftLockMarker = new Appnori.Util.NotifierClass<LockMarker>();

		public Appnori.Util.NotifierClass<LockMarker> RightLockMarker = new Appnori.Util.NotifierClass<LockMarker>();

		public Appnori.Util.NotifierClass<Transform> TableCameraCenter = new Appnori.Util.NotifierClass<Transform>();

		public Appnori.Util.NotifierClass<Transform> TableCameraSlot = new Appnori.Util.NotifierClass<Transform>();

		public Appnori.Util.NotifierClass<Transform> CueBallCameraSlot = new Appnori.Util.NotifierClass<Transform>();

		public Appnori.Util.NotifierClass<Transform> StandardCameraSlot = new Appnori.Util.NotifierClass<Transform>();

		public Appnori.Util.NotifierClass<Transform> StandardCueBallCameraSlot = new Appnori.Util.NotifierClass<Transform>();

		public Appnori.Util.NotifierClass<Transform> WorldTempCameraSlot = new Appnori.Util.NotifierClass<Transform>();

		public Appnori.Util.NotifierClass<FollowPosition> CueBallCameraRootFollower = new Appnori.Util.NotifierClass<FollowPosition>();

		public Appnori.Util.Notifier<bool> CueSnapState = new Appnori.Util.Notifier<bool>();

		public Appnori.Util.Notifier<bool> AllowedSetCuePositionState = new Appnori.Util.Notifier<bool>();

		[Obsolete]
		public Appnori.Util.Notifier<bool> isFreeBallSubmited = new Appnori.Util.Notifier<bool>();

		public Appnori.Util.Notifier<bool> MainHandLineActivation = new Appnori.Util.Notifier<bool>();

		public Appnori.Util.Notifier<bool> SubHandLineActivation = new Appnori.Util.Notifier<bool>();

		public Appnori.Util.Notifier<bool> isFoulVoicePlaying = new Appnori.Util.Notifier<bool>();

		public Appnori.Util.Notifier<ShotController.CueStateType> CueState = new Appnori.Util.Notifier<ShotController.CueStateType>();

		public Appnori.Util.Notifier<ShotController.GameStateType> GameState = new Appnori.Util.Notifier<ShotController.GameStateType>();

		public Appnori.Util.Notifier<ShotController.GameStateType> OpponentGameState = new Appnori.Util.Notifier<ShotController.GameStateType>();

		public Appnori.Util.Notifier<bool> OpponentMainHanded = new Appnori.Util.Notifier<bool>();

		public Appnori.Util.NotifierClass<Camera> MainCamera = new Appnori.Util.NotifierClass<Camera>();

		public Appnori.Util.Notifier<int> TargetBallIds = new Appnori.Util.Notifier<int>();

		public Appnori.Util.Notifier<int> TurnCount = new Appnori.Util.Notifier<int>();

		[Obsolete]
		public Appnori.Util.Notifier<RaycastHit> TryCalculatedHit = new Appnori.Util.Notifier<RaycastHit>();

		public Appnori.Util.NotifierClass<BackgroundHider> TableBackgroundHider = new Appnori.Util.NotifierClass<BackgroundHider>();

		public Appnori.Util.Notifier<float> TableBackgroundHiderCutoffValue = new Appnori.Util.Notifier<float>();

		public Appnori.Util.Notifier<float> NormalizedFadeTime = new Appnori.Util.Notifier<float>();

		[Obsolete("use XR<Hand>ControllerState.ControllerRayOrigin instead")]
		public Appnori.Util.Notifier<Vector3> ControllerRayOrigin => XRRightControllerState.ControllerRayOrigin;

		[Obsolete("use XR<Hand>ControllerState.ControllerRayTarget instead")]
		public Appnori.Util.Notifier<Vector3> ControllerRayTarget => XRRightControllerState.ControllerRayTarget;

		[Obsolete("use XR<Hand>ControllerState.AngularVelocityNotifier instead")]
		public Appnori.Util.Notifier<Vector3> ControllerAngularVelocity => XRRightControllerState.AngularVelocityNotifier;

		[Obsolete("use XR<Hand>ControllerState.VelocityNotifier instead")]
		public Appnori.Util.Notifier<Vector3> ControllerVelocity => XRRightControllerState.VelocityNotifier;

		[Obsolete("use XR<Hand>ControllerState[InputHelpers.Button.Trigger] instead")]
		public Appnori.Util.Notifier<bool> ControllerTrigger => XRRightControllerState[InputHelpers.Button.Trigger];

		[Obsolete("use XR<Hand>ControllerState[InputHelpers.Button.Primary2DAxisClick] instead")]
		public Appnori.Util.Notifier<bool> ControllerTrackButton => XRRightControllerState[InputHelpers.Button.Primary2DAxisClick];

		[Obsolete("use XR<Hand>ControllerState[InputHelpers.Button.Primary2DAxisTouch] instead")]
		public Appnori.Util.Notifier<bool> ControllerTrackTouch => XRRightControllerState[InputHelpers.Button.Primary2DAxisTouch];

		[Obsolete("use XR<Hand>ControllerState[InputHelpers.Button.MenuButton] instead")]
		public Appnori.Util.Notifier<bool> ControllerBackButton => XRRightControllerState[InputHelpers.Button.MenuButton];

		[Obsolete("use XR<Hand>ControllerState.Primary2DAxisNotifier instead")]
		public Appnori.Util.Notifier<Vector2> ControllerTrackPosition => XRRightControllerState.Primary2DAxisNotifier;
	}
	public class DummyPlayerHead : MonoBehaviour
	{
		[SerializeField]
		private PlayerManager manager;

		[SerializeField]
		private GameObject Tracker;

		[SerializeField]
		private Transform LHandTracker;

		[SerializeField]
		private Transform RHandTracker;

		[SerializeField]
		private RotationConstraint HandRotationConstraint;

		private const string AI_UUID = "AI";

		private Vector3 LastWorldPosition;

		private Quaternion LastRotation;

		private Vector3 defaultLocalPosition;

		private void Awake()
		{
			defaultLocalPosition = new Vector3(-0.22f, -0.14f, -0.1f);
			if (BallPoolGameLogic.playMode != 0)
			{
				Tracker.SetActive(value: false);
				return;
			}
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
			PlayerManager.OnInitialized += PlayerManager_OnInitialized;
		}

		private void PlayerManager_OnInitialized(PlayerManager instance)
		{
			instance.OnPlayerInitialized += Instance_OnPlayerInitialized;
		}

		private void Instance_OnPlayerInitialized(PlayerInstance player)
		{
			if (!player.isMine && BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI)
			{
				HandRotationConstraint.SetSource(0, new ConstraintSource
				{
					weight = 1f,
					sourceTransform = player.BodyRoot
				});
				PlayerManager.OnInitialized += removeListener;
			}
			void removeListener(PlayerManager instance)
			{
				instance.OnPlayerInitialized -= Instance_OnPlayerInitialized;
			}
		}

		private void Start()
		{
			GameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			if (obj == ShotController.GameStateType.WaitingForOpponent)
			{
				Tracker.transform.SetParent(Singleton<BilliardsDataContainer>.Instance.StandardCueBallCameraSlot.CurrentData, worldPositionStays: false);
				Tracker.transform.localPosition = defaultLocalPosition;
				Tracker.transform.LookAt(Singleton<BilliardsDataContainer>.Instance.StandardCueBallCameraSlot.CurrentData.parent);
			}
			else if (Tracker.transform.parent != null)
			{
				Tracker.transform.SetParent(null, worldPositionStays: false);
				Tracker.transform.localPosition = GetRandomPosition();
				Tracker.transform.LookAt(Singleton<BilliardsDataContainer>.Instance.TableCameraCenter.CurrentData);
			}
		}

		private void Update()
		{
			if (!(LastWorldPosition != Tracker.transform.position))
			{
				_ = LastRotation != Tracker.transform.rotation;
			}
			manager.SetPlayerTransform("AI", new List<Vector3>
			{
				Tracker.transform.position,
				LHandTracker.position,
				RHandTracker.position
			}, new List<Quaternion>
			{
				Tracker.transform.rotation,
				LHandTracker.rotation,
				RHandTracker.rotation
			});
			LastWorldPosition = Tracker.transform.position;
			LastRotation = Tracker.transform.rotation;
			Vector3 vector = Singleton<BilliardsDataContainer>.Instance.CueBallCameraRootFollower.CurrentData.transform.position - Tracker.transform.position;
			if (Mathf.Abs(vector.x + vector.z) < Mathf.Abs(vector.y))
			{
				Vector2 xzVector = new Vector2(vector.x / Mathf.Abs(vector.x + vector.z) * Mathf.Abs(vector.y), vector.z / Mathf.Abs(vector.x + vector.z) * Mathf.Abs(vector.y));
				vector = xzVector.ToVector3FromXZ(vector.y);
			}
			Quaternion rotation = Quaternion.LookRotation(vector.normalized);
			Tracker.transform.rotation = rotation;
		}

		private void OnDestroy()
		{
			if (BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI)
			{
				Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
			}
		}

		private Vector3 GetRandomPosition()
		{
			Vector3 vector = Singleton<BilliardsDataContainer>.Instance.TableCameraSlot.CurrentData.position;
			Vector3 vector2 = Quaternion.AngleAxis(UnityEngine.Random.Range(0, 360), Vector3.up) * Vector3.right;
			Vector3 vector3 = vector.ToXZ().magnitude * vector2;
			Vector2 xzVector = vector3.ToXZ();
			return xzVector.ToVector3FromXZ(vector.y - 0.14f);
		}
	}
	public class LockMarker : MonoBehaviour
	{
		[SerializeField]
		private bool isLeft;

		[SerializeField]
		private GameObject MarkerObject;

		[SerializeField]
		private Transform VerticalRoot;

		[SerializeField]
		private Transform HorizontalRoot;

		[SerializeField]
		private Transform simulationRoot;

		[SerializeField]
		private Vector3 RotateAmount = new Vector3(0f, 1f, 0f);

		private float RotationXOffset;

		private float RotationYOffset;

		private bool isInitialized;

		public Transform SimulationRoot => simulationRoot;

		private XRControllerState currentController
		{
			get
			{
				if (!isLeft)
				{
					return Singleton<BilliardsDataContainer>.Instance.XRRightControllerState;
				}
				return Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState;
			}
		}

		private void Awake()
		{
			MarkerObject.SetActive(value: false);
			if (isLeft)
			{
				Singleton<BilliardsDataContainer>.Instance.LeftLockMarker.CurrentData = this;
			}
			else
			{
				Singleton<BilliardsDataContainer>.Instance.RightLockMarker.CurrentData = this;
			}
			currentController[InputHelpers.Button.Trigger].OnDataChanged += LockMarker_OnDataChanged;
		}

		private void LockMarker_OnDataChanged(bool isPressed)
		{
			MarkerObject.SetActive(isPressed);
			if (isPressed)
			{
				base.transform.position = currentController.Position.CurrentData;
			}
			else
			{
				isInitialized = false;
			}
		}

		public void InitializeAxis(Vector3 targetPosition)
		{
			if (!isInitialized)
			{
				isInitialized = true;
				RotationXOffset = 0f;
				RotationYOffset = 0f;
				VerticalRoot.localRotation = Quaternion.identity;
				HorizontalRoot.localRotation = Quaternion.identity;
				Vector2 vector = targetPosition.ToXZ();
				Vector3 vector2 = base.transform.position;
				Vector2 xzVector = vector - vector2.ToXZ();
				Quaternion rotation = Quaternion.LookRotation(xzVector.ToVector3FromXZ(), Vector3.up);
				base.transform.rotation = rotation;
			}
		}

		public void UpdateSimulationOffset(float xAmount, float yAmount)
		{
			RotationXOffset += xAmount;
			RotationYOffset += yAmount;
			VerticalRoot.localRotation = Quaternion.Euler(RotationXOffset, 0f, 0f);
			HorizontalRoot.localRotation = Quaternion.Euler(0f, RotationYOffset, 0f);
		}

		private void Update()
		{
			if (MarkerObject.activeInHierarchy)
			{
				MarkerObject.transform.Rotate(RotateAmount * Time.deltaTime, Space.World);
			}
		}

		private void OnDestroy()
		{
			currentController[InputHelpers.Button.Trigger].OnDataChanged -= LockMarker_OnDataChanged;
		}
	}
	public class PermittedSpaceController : MonoBehaviour
	{
		[Tooltip("if autoSimulate is false, use manual mode")]
		[SerializeField]
		private bool isManualMode;

		[SerializeField]
		private XRRig xrRig;

		[SerializeField]
		private Collider self;

		[SerializeField]
		private List<Collider> Targets;

		[SerializeField]
		private Material TargetMaterial;

		private Queue<Vector3> lastPositions = new Queue<Vector3>();

		private List<Collider> EnteredColliders = new List<Collider>();

		private CoroutineWrapper MoveCameraRoutine;

		private CoroutineWrapper MaterialAnimationRoutine;

		public bool isEnter { get; private set; }

		public event Action<(Collider, Vector3, float)> OnEnableCheckedCollider;

		private void Awake()
		{
			MoveCameraRoutine = CoroutineWrapper.Generate(this);
			MaterialAnimationRoutine = CoroutineWrapper.Generate(this);
			TargetMaterial.SetFloat("_Distance", 0f);
		}

		private void OnEnable()
		{
			List<(Collider, Vector3, float)> list = new List<(Collider, Vector3, float)>();
			foreach (Collider target in Targets)
			{
				if (Physics.ComputePenetration(self, self.transform.position, self.transform.rotation, target, target.transform.position, target.transform.rotation, out var direction, out var distance))
				{
					list.Add((target, direction, distance));
				}
			}
			foreach (var item in list)
			{
				this.OnEnableCheckedCollider?.Invoke(item);
			}
			lastPositions.Clear();
			lastPositions.Enqueue(xrRig.cameraGameObject.transform.position);
		}

		private void OnDisable()
		{
			TargetMaterial.SetFloat("_Distance", 0f);
		}

		private void OnTriggerEnter(Collider other)
		{
			if (base.enabled && Targets.Contains(other))
			{
				isEnter = true;
				MaterialAnimationRoutine.StartSingleton(FielActive(0.6f));
			}
			IEnumerator FielActive(float runtime)
			{
				float t = 0f;
				while (t < runtime)
				{
					t += Time.fixedDeltaTime;
					TargetMaterial.SetFloat("_Distance", 1f - t / runtime);
					yield return new WaitForFixedUpdate();
				}
				TargetMaterial.SetFloat("_Distance", 0f);
			}
		}

		private void OnTriggerStay(Collider other)
		{
			if (base.enabled && Targets.Contains(other))
			{
				Vector3 vector = lastPositions.Peek() - xrRig.cameraGameObject.transform.position;
				MoveCameraRoutine.StartSingleton(MoveCamera(xrRig.cameraGameObject.transform.position + vector * 1.16f, 0.2f));
			}
			IEnumerator MoveCamera(Vector3 target, float runtime)
			{
				float t = 0f;
				Vector3 defaultPosition = xrRig.cameraGameObject.transform.position;
				Vector3 vector2;
				Vector2 xzVector;
				while (t < runtime)
				{
					t += Time.fixedDeltaTime;
					XRRig xRRig = xrRig;
					vector2 = Vector3.Lerp(defaultPosition, target, t / runtime);
					xzVector = vector2.ToXZ();
					xRRig.MoveCameraToWorldLocation(xzVector.ToVector3FromXZ(xrRig.cameraGameObject.transform.position.y));
					yield return new WaitForFixedUpdate();
				}
				XRRig xRRig2 = xrRig;
				vector2 = Vector3.Lerp(defaultPosition, target, 1f);
				xzVector = vector2.ToXZ();
				xRRig2.MoveCameraToWorldLocation(xzVector.ToVector3FromXZ(xrRig.cameraGameObject.transform.position.y));
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (base.enabled && Targets.Contains(other))
			{
				isEnter = false;
			}
		}

		private void Update()
		{
			if (!isManualMode)
			{
				return;
			}
			foreach (Collider target in Targets)
			{
				if (Physics.ComputePenetration(self, self.transform.position, self.transform.rotation, target, target.transform.position, target.transform.rotation, out var _, out var _))
				{
					if (EnteredColliders.Contains(target))
					{
						OnTriggerStay(target);
						continue;
					}
					EnteredColliders.Add(target);
					OnTriggerEnter(target);
				}
				else if (EnteredColliders.Contains(target))
				{
					EnteredColliders.Remove(target);
					OnTriggerExit(target);
				}
			}
			if (!isEnter)
			{
				lastPositions.Enqueue(xrRig.cameraGameObject.transform.position);
				if (lastPositions.Count > 4)
				{
					lastPositions.Dequeue();
				}
			}
		}
	}
	public class PlayerHand : MonoBehaviour
	{
		[SerializeField]
		private Material OpaqueHandMaterial;

		[SerializeField]
		private Material TransparentHandMaterial;

		[SerializeField]
		private Material TransparentHandMaterial_left;

		[SerializeField]
		private Renderer leftCueBridgeHand;

		[SerializeField]
		private Renderer leftCueGripHand;

		[SerializeField]
		private GameObject leftHandRoot;

		[SerializeField]
		private GameObject rightHandRoot;

		[SerializeField]
		private Renderer rightCueHand;

		[SerializeField]
		private Renderer freeLeftHand;

		[SerializeField]
		private Renderer freeRightHand;

		private Color PlayerSkinColor;

		private Color TransparentBlueColor;

		public Renderer LeftCueBridgeHand => leftCueBridgeHand;

		public Renderer RightCueHand => rightCueHand;

		public Renderer LeftFreeHand => freeLeftHand;

		public Renderer RightFreeHand => freeRightHand;

		private bool isMyturn => AightBallPoolPlayer.mainPlayer.myTurn;

		private bool isNetworkControl
		{
			get
			{
				if (BallPoolGameLogic.playMode == BallPool.PlayMode.OnLine)
				{
					return !AightBallPoolPlayer.mainPlayer.myTurn;
				}
				return false;
			}
		}

		private void Awake()
		{
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.OpponentGameState.OnDataChanged += OpponentGameState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChanged += CueSnapState_OnDataChanged;
			PlayerSkinColor = GetSkinColor();
			SetOtherPlayerSkin();
			if (ColorUtility.TryParseHtmlString("#3B7FFF", out var color))
			{
				TransparentBlueColor = color;
			}
			bool isRightHanded = PublicGameUIManager.gameSetting.IsRightHanded();
			PublicGameUIManager.gameSetting.AddHandChangedEvent(OnMainHandChanged);
			if (isMyturn)
			{
				OnMainHandChanged(isRightHanded);
			}
			BallPoolPlayer.OnTurnChanged += BallPoolPlayer_OnTurnChanged;
		}

		private void BallPoolPlayer_OnTurnChanged()
		{
			if (BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI && !isMyturn)
			{
				OnMainHandChanged(isRightHanded: true);
			}
		}

		private void OnMainHandChanged(bool isRightHanded)
		{
			if (isRightHanded)
			{
				leftHandRoot.transform.localScale = Vector3.one;
				rightHandRoot.transform.localScale = Vector3.one;
			}
			else
			{
				leftHandRoot.transform.localScale = new Vector3(-1f, 1f, 1f);
				rightHandRoot.transform.localScale = new Vector3(-1f, 1f, 1f);
			}
		}

		private void SetOtherPlayerSkin()
		{
			int playerNum = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(BallPoolPlayer.players[1].name);
			if (BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI)
			{
				playerNum = 1;
			}
			CustomModelData customModelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(playerNum);
			if (ColorUtility.TryParseHtmlString("#" + customModelData.Hex_Skin_C, out var color))
			{
				OpaqueHandMaterial.SetColor("_BaseColor", color);
			}
		}

		private Color GetSkinColor()
		{
			int playerNum = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(BallPoolPlayer.mainPlayer.name);
			CustomModelData customModelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(playerNum);
			if (ColorUtility.TryParseHtmlString("#" + customModelData.Hex_Skin_C, out var color))
			{
				return color;
			}
			if (ColorUtility.TryParseHtmlString("#F3A39B", out color))
			{
				return color;
			}
			return Color.white;
		}

		private IEnumerator Start()
		{
			yield return new WaitForSeconds(1f);
			OpponentGameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.OpponentGameState.CurrentData);
			GameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
		}

		private void CueSnapState_OnDataChanged(bool isSnap)
		{
			SetColor();
		}

		private void OpponentGameState_OnDataChanged(ShotController.GameStateType obj)
		{
			if (isNetworkControl)
			{
				OnMainHandChanged(Singleton<BilliardsDataContainer>.Instance.OpponentMainHanded.CurrentData);
				switch (obj)
				{
				case ShotController.GameStateType.WaitingForOpponent:
				case ShotController.GameStateType.SetBallPosition:
					UpdateHandActive(cueActive: false);
					break;
				case ShotController.GameStateType.SelectShotDirection:
					leftHandRoot.transform.GetChild(0).gameObject.SetActive(value: false);
					leftHandRoot.transform.GetChild(1).gameObject.SetActive(value: true);
					UpdateHandActive(cueActive: true);
					break;
				case ShotController.GameStateType.CameraFixAndWaitShot:
					leftHandRoot.transform.GetChild(0).gameObject.SetActive(value: true);
					leftHandRoot.transform.GetChild(1).gameObject.SetActive(value: false);
					UpdateHandActive(cueActive: true);
					break;
				default:
					UpdateHandActive(cueActive: true);
					break;
				}
			}
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			if (!isNetworkControl && obj != 0)
			{
				OnMainHandChanged(ShotController.IsRightHanded);
				switch (obj)
				{
				case ShotController.GameStateType.SetBallPosition:
					UpdateHandActive(cueActive: false);
					break;
				case ShotController.GameStateType.SelectShotDirection:
					UpdateHandActive(cueActive: true);
					break;
				case ShotController.GameStateType.CameraFixAndWaitShot:
					UpdateHandActive(cueActive: true);
					break;
				}
			}
		}

		public void UpdateHandActive(bool cueActive)
		{
			SetMaterial();
			SetColor();
			leftHandRoot.SetActive(cueActive);
			LeftCueBridgeHand.gameObject.SetActive(cueActive);
			RightCueHand.gameObject.SetActive(cueActive);
			if (isMyturn)
			{
				LeftFreeHand.gameObject.SetActive(!cueActive);
				RightFreeHand.gameObject.SetActive(!cueActive);
			}
			PlayerManager.OnInitialized += delegate(PlayerManager instance)
			{
				instance.ForceSetOtherPlayerHand(!cueActive || isMyturn);
			};
		}

		public void SetColor()
		{
			if (!isMyturn)
			{
				return;
			}
			if (Singleton<BilliardsDataContainer>.Instance.CueSnapState.CurrentData)
			{
				LeftCueBridgeHand.sharedMaterial.color = PlayerSkinColor;
				if (Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData == ShotController.GameStateType.CameraFixAndWaitShot)
				{
					RightCueHand.sharedMaterial.color = PlayerSkinColor;
				}
				else
				{
					RightCueHand.sharedMaterial.color = TransparentBlueColor;
				}
			}
			else
			{
				LeftCueBridgeHand.sharedMaterial.color = TransparentBlueColor;
				RightCueHand.sharedMaterial.color = TransparentBlueColor;
			}
		}

		public void SetMaterial()
		{
			if (isMyturn)
			{
				LeftCueBridgeHand.sharedMaterial = TransparentHandMaterial_left;
				leftCueGripHand.sharedMaterial = TransparentHandMaterial;
				RightCueHand.sharedMaterial = TransparentHandMaterial;
			}
			else
			{
				LeftCueBridgeHand.sharedMaterial = OpaqueHandMaterial;
				leftCueGripHand.sharedMaterial = OpaqueHandMaterial;
				RightCueHand.sharedMaterial = OpaqueHandMaterial;
			}
		}

		private void OnDestroy()
		{
			BallPoolPlayer.OnTurnChanged -= BallPoolPlayer_OnTurnChanged;
			Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChanged -= CueSnapState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.OpponentGameState.OnDataChanged -= OpponentGameState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
		}
	}
	public class PlayerHandTracker : MonoBehaviour
	{
		public enum Type
		{
			Left,
			Right
		}

		[SerializeField]
		private Type HandType;

		[SerializeField]
		private Animator animator;

		private XRControllerState currentControllerState
		{
			get
			{
				if (HandType != 0)
				{
					return Singleton<BilliardsDataContainer>.Instance.XRRightControllerState;
				}
				return Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState;
			}
		}

		private void Awake()
		{
			currentControllerState.Position.OnDataChanged += Position_OnDataChanged;
			currentControllerState.Rotation.OnDataChanged += Rotation_OnDataChanged;
			currentControllerState.TriggerNotifier.OnDataChanged += PlayerHandTracker_OnDataChanged;
		}

		private void PlayerHandTracker_OnDataChanged(float triggerValue)
		{
			animator.SetFloat("Value", triggerValue);
		}

		private void Rotation_OnDataChanged(Quaternion obj)
		{
			base.transform.rotation = obj;
		}

		private void Position_OnDataChanged(Vector3 obj)
		{
			base.transform.position = obj;
		}

		private void OnDestroy()
		{
			currentControllerState.Position.OnDataChanged -= Position_OnDataChanged;
			currentControllerState.Rotation.OnDataChanged -= Rotation_OnDataChanged;
			currentControllerState.TriggerNotifier.OnDataChanged -= PlayerHandTracker_OnDataChanged;
		}
	}
	[Serializable]
	public class PlayerModel
	{
		public Transform Root;

		public Transform HeadRoot;

		public Transform LHandRoot;

		public Transform RHandRoot;

		public void SetActive(bool value)
		{
			Root.gameObject.SetActive(value);
			HeadRoot.gameObject.SetActive(value);
		}
	}
	public class PlayerInstance : MonoBehaviour
	{
		[SerializeField]
		private PlayerModel Model;

		[SerializeField]
		private AnimationCurve MoveCureve;

		[SerializeField]
		private AnimationCurve RotationCurve;

		[SerializeField]
		private Material HandMaterial;

		private int modelIdx = -1;

		private bool dirty;

		private int LHandPositionMissCount;

		private int LHandRotationMissCount;

		private int RHandPositionMissCount;

		private int RHandRotationMissCount;

		private List<Vector3> Positions = new List<Vector3>();

		private List<Quaternion> Rotations = new List<Quaternion>();

		private bool LHandPositionUpdated;

		private bool LHandRotationUpdated;

		private bool RHandPositionUpdated;

		private bool RHandRotationUpdated;

		private float MainOpacity;

		private float SubOpacity;

		private float ShotTime;

		private PlayerModel CurrentModel => Model;

		public bool isInitialized { get; private set; }

		public bool isLateInitialized { get; private set; }

		public bool isMine { get; private set; }

		public int currentIdx { get; private set; }

		public string playerUuid { get; private set; }

		public bool isDirty
		{
			get
			{
				if (Time.time - ShotTime < 2f)
				{
					return false;
				}
				if (!dirty)
				{
					return false;
				}
				dirty = false;
				return true;
			}
			private set
			{
				dirty = value;
			}
		}

		public Vector3 worldPosition { get; private set; }

		public Quaternion worldRotation { get; private set; }

		public Vector3 LHandPosition { get; private set; }

		public Quaternion LHandRotation { get; private set; }

		public Vector3 RHandPosition { get; private set; }

		public Quaternion RHandRotation { get; private set; }

		public Transform LHandRoot => CurrentModel.LHandRoot;

		public Transform RHandRoot => CurrentModel.RHandRoot;

		public Transform BodyRoot => CurrentModel.Root;

		public bool LHandActive { get; private set; }

		public bool RHandActive { get; private set; }

		public bool MasterHandActive
		{
			set
			{
				LHandActive = value;
				RHandActive = value;
				LHandRoot.gameObject.SetActive((LHandPositionUpdated || LHandRotationUpdated) && LHandActive);
				RHandRoot.gameObject.SetActive((RHandPositionUpdated || RHandRotationUpdated) && RHandActive);
			}
		}

		public void UpdateHandActivation()
		{
			LHandRoot.gameObject.SetActive((LHandPositionUpdated || LHandRotationUpdated) && LHandActive);
			RHandRoot.gameObject.SetActive((RHandPositionUpdated || RHandRotationUpdated) && RHandActive);
		}

		public void Initialize(bool mine, string uuid, bool force = false)
		{
			if (!isInitialized || force)
			{
				isMine = mine;
				currentIdx = ((!mine) ? 1 : 0);
				playerUuid = uuid;
				if (isMine)
				{
					base.transform.SetParent(Singleton<BilliardsDataContainer>.Instance.MainCamera.CurrentData.transform, worldPositionStays: false);
					base.transform.localPosition = Vector3.zero;
					base.transform.localEulerAngles = Vector3.zero;
					Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.Position.OnDataChanged += LHand_Position_OnDataChanged;
					Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.Rotation.OnDataChanged += LHand_Rotation_OnDataChanged;
					Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.Position.OnDataChanged += RHand_Position_OnDataChanged;
					Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.Rotation.OnDataChanged += RHand_Rotation_OnDataChanged;
				}
				else
				{
					SetPlayerHandColor();
				}
				LHandRoot.gameObject.SetActive(value: false);
				RHandRoot.gameObject.SetActive(value: false);
				worldPosition = base.transform.position;
				worldRotation = base.transform.rotation;
				LHandPosition = new Vector3(-1.7f, 0.109f, -1.718f);
				RHandPosition = new Vector3(-1.2489f, 0.069f, -1.718f);
				LHandRotation = Quaternion.identity;
				RHandRotation = Quaternion.identity;
				isDirty = true;
				isInitialized = true;
				MainOpacity = 1f;
				SubOpacity = 1f;
				Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
				Invoke("LateInitialize", Time.deltaTime);
			}
			void SetPlayerHandColor()
			{
				int playerNum = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(BallPoolPlayer.players[1].name);
				if (BallPoolGameLogic.playMode == BallPool.PlayMode.PlayerAI)
				{
					playerNum = 1;
				}
				CustomModelData customModelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.GetCustomModelData(playerNum);
				if (ColorUtility.TryParseHtmlString("#" + customModelData.Hex_Skin_C, out var color))
				{
					HandMaterial.SetColor("_BaseColor", color);
				}
			}
		}

		private void LHand_Position_OnDataChanged(Vector3 obj)
		{
			LHandPosition = obj;
			isDirty = true;
		}

		private void LHand_Rotation_OnDataChanged(Quaternion obj)
		{
			LHandRotation = obj;
			isDirty = true;
		}

		private void RHand_Position_OnDataChanged(Vector3 obj)
		{
			RHandPosition = obj;
			isDirty = true;
		}

		private void RHand_Rotation_OnDataChanged(Quaternion obj)
		{
			RHandRotation = obj;
			isDirty = true;
		}

		private void LateInitialize()
		{
			worldPosition = base.transform.position;
			worldRotation = base.transform.rotation;
			isDirty = true;
			if (!isMine)
			{
				CurrentModel.SetActive(value: true);
				bool myTurn = AightBallPoolPlayer.mainPlayer.myTurn;
				LHandRoot.gameObject.SetActive(myTurn);
				RHandRoot.gameObject.SetActive(myTurn);
			}
			isLateInitialized = true;
		}

		private void GameState_OnDataChanged(ShotController.GameStateType state)
		{
			if (state == ShotController.GameStateType.Shot)
			{
				ShotTime = Time.time;
			}
		}

		private void Update()
		{
			if (!isLateInitialized)
			{
				return;
			}
			if (isMine)
			{
				if (base.transform.position != worldPosition)
				{
					worldPosition = base.transform.position;
					isDirty = true;
				}
				if (base.transform.rotation != worldRotation)
				{
					worldRotation = base.transform.rotation;
					isDirty = true;
				}
				return;
			}
			worldPosition = base.transform.position;
			worldRotation = base.transform.rotation;
			if (Positions.Count == 3)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, Positions[0], 5f * Time.deltaTime);
				LHandRoot.position = Vector3.Lerp(LHandRoot.position, Positions[1], 5f * Time.deltaTime);
				RHandRoot.position = Vector3.Lerp(RHandRoot.position, Positions[2], 5f * Time.deltaTime);
			}
			if (Rotations.Count == 3)
			{
				float num = 0f;
				float num2 = Rotations[0].eulerAngles.y - CurrentModel.Root.rotation.eulerAngles.y;
				if (num2 < -180f)
				{
					num2 += 360f;
				}
				if (num2 > 180f)
				{
					num2 -= 360f;
				}
				if (Mathf.Abs(num2) > 22.5f)
				{
					num = Mathf.Sign(num2) * (Mathf.Abs(num2) - 22.5f);
				}
				Quaternion b = Quaternion.Euler(0f, CurrentModel.Root.rotation.eulerAngles.y + num, 0f);
				CurrentModel.Root.rotation = Quaternion.Lerp(CurrentModel.Root.rotation, b, 5f * Time.deltaTime);
				CurrentModel.HeadRoot.rotation = Quaternion.Lerp(CurrentModel.HeadRoot.rotation, Rotations[0], 5f * Time.deltaTime);
				LHandRoot.rotation = Quaternion.Lerp(LHandRoot.rotation, Rotations[1], 5f * Time.deltaTime);
				RHandRoot.rotation = Quaternion.Lerp(RHandRoot.rotation, Rotations[2], 5f * Time.deltaTime);
			}
		}

		public void SetMainOpacity(float opacity)
		{
			MainOpacity = opacity;
			SetOpacity();
		}

		private void SetOpacity()
		{
			if (MainOpacity * SubOpacity < 0.5f)
			{
				CurrentModel.SetActive(value: false);
			}
			else
			{
				CurrentModel.SetActive(isLateInitialized && !isMine);
			}
		}

		public PlayerInstance UpdatePositions(List<Vector3> worldPositions)
		{
			if (worldPositions.Count != 3)
			{
				return this;
			}
			if (Positions.Count == 3)
			{
				ref int lHandPositionMissCount = ref LHandPositionMissCount;
				ref bool lHandPositionUpdated = ref LHandPositionUpdated;
				Vector3 lastPosition2 = Positions[1];
				Vector3 currentPosition2 = worldPositions[1];
				CheckHandPositionUpdate(ref lHandPositionMissCount, ref lHandPositionUpdated, in lastPosition2, in currentPosition2);
				ref int rHandPositionMissCount = ref RHandPositionMissCount;
				ref bool rHandPositionUpdated = ref RHandPositionUpdated;
				lastPosition2 = Positions[2];
				currentPosition2 = worldPositions[2];
				CheckHandPositionUpdate(ref rHandPositionMissCount, ref rHandPositionUpdated, in lastPosition2, in currentPosition2);
			}
			else
			{
				LHandPositionMissCount = 0;
				RHandPositionMissCount = 0;
				LHandPositionUpdated = true;
				RHandPositionUpdated = true;
			}
			UpdateHandActivation();
			Positions = worldPositions;
			return this;
			static void CheckHandPositionUpdate(ref int count, ref bool updated, in Vector3 lastPosition, in Vector3 currentPosition)
			{
				count = ((lastPosition == currentPosition) ? (count + 1) : 0);
				updated = count < 5;
			}
		}

		public PlayerInstance UpdateRotations(List<Quaternion> rotations)
		{
			if (rotations.Count != 3)
			{
				return this;
			}
			if (Rotations.Count == 3)
			{
				ref int lHandRotationMissCount = ref LHandRotationMissCount;
				ref bool lHandRotationUpdated = ref LHandRotationUpdated;
				Quaternion lastPosition2 = Rotations[1];
				Quaternion currentPosition2 = rotations[1];
				CheckHandRotationUpdate(ref lHandRotationMissCount, ref lHandRotationUpdated, in lastPosition2, in currentPosition2);
				ref int rHandRotationMissCount = ref RHandRotationMissCount;
				ref bool rHandRotationUpdated = ref RHandRotationUpdated;
				lastPosition2 = Rotations[2];
				currentPosition2 = rotations[2];
				CheckHandRotationUpdate(ref rHandRotationMissCount, ref rHandRotationUpdated, in lastPosition2, in currentPosition2);
			}
			else
			{
				LHandRotationMissCount = 0;
				RHandRotationMissCount = 0;
				LHandRotationUpdated = true;
				RHandRotationUpdated = true;
			}
			UpdateHandActivation();
			Rotations = rotations;
			return this;
			static void CheckHandRotationUpdate(ref int count, ref bool updated, in Quaternion lastPosition, in Quaternion currentPosition)
			{
				float f = Quaternion.Dot(lastPosition, currentPosition);
				count = (Mathf.Approximately(Mathf.Abs(f), 1f) ? (count + 1) : 0);
				updated = count < 5;
			}
		}

		private void OnDestroy()
		{
			Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState.Position.OnDataChanged -= LHand_Position_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.Position.OnDataChanged -= RHand_Position_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
		}
	}
	public class PlayerManager : MonoBehaviour
	{
		[SerializeField]
		private PlayerInstance PlayerOrigin;

		[SerializeField]
		private PlayerHand playerHand;

		private Dictionary<string, PlayerInstance> PlayerDictionary = new Dictionary<string, PlayerInstance>();

		private PlayerInstance _mine;

		private static PlayerManager manager;

		public PlayerInstance Mine
		{
			get
			{
				if (_mine != null)
				{
					return _mine;
				}
				GameObject gameObject = UnityEngine.Object.Instantiate(PlayerOrigin.gameObject);
				_mine = gameObject.GetComponent<PlayerInstance>();
				_mine.Initialize(mine: true, AightBallPoolPlayer.mainPlayer.uuid);
				return _mine;
			}
		}

		public event Action<PlayerInstance> OnPlayerInitialized;

		private static event Action<PlayerManager> onInitialized;

		public static event Action<PlayerManager> OnInitialized
		{
			add
			{
				if (manager != null)
				{
					value?.Invoke(manager);
				}
				else
				{
					onInitialized += value;
				}
			}
			remove
			{
				onInitialized -= value;
			}
		}

		public void Awake()
		{
			manager = this;
			PlayerManager.onInitialized?.Invoke(this);
			PlayerManager.onInitialized = null;
		}

		public void ForceSetOtherPlayerHand(bool value)
		{
			using List<PlayerInstance>.Enumerator enumerator = PlayerDictionary.Values.ToList().GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (enumerator.Current != Mine)
				{
					enumerator.Current.MasterHandActive = value;
				}
			}
		}

		public void SetPlayerTransform(string uuid, List<Vector3> worldPosition, List<Quaternion> rotation)
		{
			if (!PlayerDictionary.TryGetValue(uuid, out var value))
			{
				value = UnityEngine.Object.Instantiate(PlayerOrigin.gameObject).GetComponent<PlayerInstance>();
				value.Initialize(mine: false, uuid);
				CustomModelSettingCtrl component = value.GetComponent<CustomModelSettingCtrl>();
				if (CheckPlayerNameIsAI(uuid))
				{
					component.InitCPU(CustomModelViewState.HalfCut, playerHand.LeftCueBridgeHand, 0.18f);
				}
				else
				{
					UserInfoManager.UserInfo userInfo = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Where((UserInfoManager.UserInfo info) => info.id == uuid).FirstOrDefault();
					if (string.IsNullOrEmpty(userInfo.nick))
					{
						string name = BallPoolPlayer.players.Where((BallPoolPlayer p) => p.uuid == uuid).FirstOrDefault().name;
						userInfo = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Where((UserInfoManager.UserInfo info) => info.nick == name).FirstOrDefault();
					}
					component.Init(userInfo.id, CustomModelViewState.HalfCut, playerHand.LeftCueBridgeHand, 0.18f);
				}
				PlayerDictionary[uuid] = value;
				this.OnPlayerInitialized?.Invoke(value);
			}
			value.UpdatePositions(worldPosition).UpdateRotations(rotation);
		}

		private bool CheckPlayerNameIsAI(string uuid)
		{
			if (uuid.Equals("AI"))
			{
				return true;
			}
			return false;
		}

		private void Update()
		{
			using List<PlayerInstance>.Enumerator enumerator = PlayerDictionary.Values.ToList().GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (!enumerator.Current.isMine)
				{
					float magnitude = (Mine.worldPosition - enumerator.Current.worldPosition).magnitude;
					enumerator.Current.SetMainOpacity(magnitude * 1.5f - 0.7f);
				}
			}
		}

		private void OnDestroy()
		{
			manager = null;
		}
	}
	public class Initializer : MonoBehaviour
	{
		private void Awake()
		{
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.gameType != GameData_DDOL.GameType.Billiards)
			{
				return;
			}
			if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Single)
			{
				SinglePlayInitializer(SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level);
			}
			else if (SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.playType == GameData_DDOL.PlayType.Multi)
			{
				if (!TryGetPlayerInfos(out var localPlayer, out var opponent))
				{
					SceneManager.LoadScene("Scene_Lobby");
					return;
				}
				MultiPlayerInitializer(localPlayer.NickName, opponent.NickName);
			}
			Singleton<BilliardsDataContainer>.Instance.TurnCount.CurrentData = 0;
			SceneManager.LoadScene("AightBallPool");
			SceneManager.LoadScene("Home_map", LoadSceneMode.Additive);
		}

		public static bool TryGetPlayerInfos(out Player localPlayer, out Player opponent)
		{
			IEnumerable<Player> enumerable = PhotonNetwork.CurrentRoom.Players.Values.Except(new List<Player> { PhotonNetwork.LocalPlayer });
			if (enumerable == null || enumerable.Count() < 1)
			{
				localPlayer = null;
				opponent = null;
				return false;
			}
			localPlayer = PhotonNetwork.LocalPlayer;
			opponent = enumerable.First();
			return true;
		}

		public static void TutorialInitializer()
		{
			BallPoolAIExtension.DumbLevel = 100;
			BallPoolGameLogic.playMode = BallPool.PlayMode.Solo;
			BallPoolPlayer.players = new BallPoolPlayer[2];
			BallPoolPlayer.players[0] = new AightBallPoolPlayer(0, SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick, 1);
			BallPoolPlayer.players[1] = new AightBallPoolPlayer(1, "", 1);
			BallPoolPlayer.playersCount = 2;
			NetworkManager.initialized = true;
			NetworkManager.InitializeMainPlayer();
		}

		public static void SinglePlayInitializer(int level)
		{
			BallPoolAIExtension.DumbLevel = 6 - Mathf.Clamp(level, 1, 5);
			BallPoolGameLogic.playMode = BallPool.PlayMode.PlayerAI;
			BallPoolPlayer.players = new BallPoolPlayer[2];
			BallPoolPlayer.players[0] = new AightBallPoolPlayer(0, SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick, 1, SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id);
			BallPoolPlayer.players[1] = new AightBallPoolPlayer(1, SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].nick, 1, SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1].id);
			BallPoolPlayer.playersCount = 2;
			NetworkManager.initialized = true;
			NetworkManager.InitializeMainPlayer();
		}

		public static void MultiPlayerInitializer(string userName, string otherName)
		{
			int num = -1;
			Func<UserInfoManager.UserInfo, bool> predicate;
			if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick.Equals(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id))
			{
				num = 0;
				predicate = (UserInfoManager.UserInfo info) => info.nick.Equals(otherName) || info.id.Equals(otherName);
			}
			else if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick.Equals(userName))
			{
				num = 1;
				predicate = (UserInfoManager.UserInfo info) => info.nick.Equals(otherName);
			}
			else if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id.Equals(userName))
			{
				num = 2;
				predicate = (UserInfoManager.UserInfo info) => info.id.Equals(otherName);
			}
			else
			{
				num = 3;
				predicate = (UserInfoManager.UserInfo info) => false;
				UnityEngine.Debug.LogError("UserInfo not matching. photon. username is " + userName + " but userinfo_mine is (nick : " + SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick + ") and (id : " + SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id + ")");
			}
			UserInfoManager.UserInfo userInfo = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.FirstOrDefault(predicate);
			if (userInfo.Equals(default(UserInfoManager.UserInfo)))
			{
				UnityEngine.Debug.LogError("PredicateType : " + num);
				UnityEngine.Debug.LogError("username : " + userName);
				UnityEngine.Debug.LogError("UserInfoManager.GetInstance.userInfo_mine.id(" + SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id + " , UserInfoManager.GetInstance.userInfo_mine.nick(" + SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick + "))");
				UnityEngine.Debug.LogError("other player UserInfo not matching. photon. username is " + otherName + " but userinfo.id is " + string.Join(",", SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.id).ToArray()));
				UnityEngine.Debug.LogError("other player UserInfo not matching. photon. username is " + otherName + " but userinfo.nick is " + string.Join(",", SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToArray()));
				SceneManager.LoadScene("Scene_Lobby");
			}
			else
			{
				string id = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.id;
				BallPoolGameLogic.playMode = BallPool.PlayMode.OnLine;
				BallPoolPlayer.players = new BallPoolPlayer[2];
				BallPoolPlayer.players[0] = new AightBallPoolPlayer(0, SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine.nick, 1, id);
				BallPoolPlayer.players[1] = new AightBallPoolPlayer(1, userInfo.nick, 1, userInfo.id);
				BallPoolPlayer.playersCount = 2;
				NetworkManager.initialized = true;
				NetworkManager.InitializeMainPlayer();
				NetworkManager.network.SetAdapter(new AightBallPoolNetworkGameAdapter());
				NetworkManager.network.adapter.SetTurn((NetworkManager.network as PunNetwork).isMasterClient() ? 1 : 0);
			}
		}
	}
	public class InteractableTable : XRBaseInteractable
	{
		[SerializeField]
		private XRRig xrRig;

		[SerializeField]
		private Transform TableSpace;

		[SerializeField]
		private Transform EdgePointerTransform;

		[SerializeField]
		private Transform RayHitPointerTransform;

		[SerializeField]
		private LineRenderer lineRenderer;

		[SerializeField]
		private XRNode ReactTarget = XRNode.RightHand;

		private Vector3 CurrentEdgePosition;

		private Vector3 LateEdgePosition;

		private Vector3 CurrentHitPosition;

		private Vector3 ReticlePosition;

		private const float TABLE_EDGE_DISTANCE = 0.09610341f;

		private bool isNowTracking;

		private List<XRBaseInteractor> cached = new List<XRBaseInteractor>();

		private XRControllerState currentControllerState => ReactTarget switch
		{
			XRNode.LeftHand => ShotController.SubHandController, 
			XRNode.RightHand => ShotController.MainHandController, 
			_ => null, 
		};

		private Appnori.Util.NotifierClass<XRReticleProvider> currentReticleProvider
		{
			get
			{
				switch (ReactTarget)
				{
				case XRNode.LeftHand:
					if (ShotController.SubHandController == Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState)
					{
						return Singleton<BilliardsDataContainer>.Instance.XRLeftReticleProvider;
					}
					return Singleton<BilliardsDataContainer>.Instance.XRRightReticleProvider;
				case XRNode.RightHand:
					if (ShotController.MainHandController == Singleton<BilliardsDataContainer>.Instance.XRRightControllerState)
					{
						return Singleton<BilliardsDataContainer>.Instance.XRLeftReticleProvider;
					}
					return Singleton<BilliardsDataContainer>.Instance.XRRightReticleProvider;
				default:
					return null;
				}
			}
		}

		protected override void Awake()
		{
			base.Awake();
			isNowTracking = false;
			SetActiveLine(isActive: false);
			if (xrRig == null)
			{
				if (Singleton<BilliardsDataContainer>.Instance.XRRigid.CurrentData == null)
				{
					Singleton<BilliardsDataContainer>.Instance.XRRigid.OnDataChangedOnce += delegate(XRRig xrRig)
					{
						this.xrRig = xrRig;
					};
				}
				else
				{
					xrRig = Singleton<BilliardsDataContainer>.Instance.XRRigid.CurrentData;
				}
			}
			if (currentReticleProvider.CurrentData == null)
			{
				currentReticleProvider.OnDataChangedOnce += delegate(XRReticleProvider provider)
				{
					provider.ReticleMovementevent.AddListener(OnReticlePositionUpdate);
				};
			}
			else
			{
				currentReticleProvider.CurrentData.ReticleMovementevent.AddListener(OnReticlePositionUpdate);
			}
		}

		public void OnReticlePositionUpdate(XRNode node, Vector3 position)
		{
			if (node == ReactTarget && Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData == ShotController.GameStateType.WaitingForOpponent)
			{
				ReticlePosition = position;
				if (isNowTracking)
				{
					Vector3 vector = currentControllerState.ControllerRayOrigin.CurrentData;
					Vector2 xzVector = Geometry.EdgeProjectionXZ((ReticlePosition.ToXZ() - vector.ToXZ()) * 100f, vector.ToXZ(), TableSpace);
					CurrentHitPosition = ReticlePosition;
					Vector3 vector2 = xzVector.ToVector3FromXZ(-0.00016f);
					float scale = 0.02f;
					CurrentEdgePosition = vector2.Round(in scale);
				}
			}
		}

		protected override void OnHoverEnter(XRBaseInteractor interactor)
		{
			base.OnHoverEnter(interactor);
			cached.Add(interactor);
			if (CacheManager.Get<UnityEngine.XR.Interaction.Toolkit.XRController>(interactor).controllerNode == ReactTarget)
			{
				isNowTracking = true;
				SetActiveLine(isActive: true);
			}
		}

		protected override void OnSelectEnter(XRBaseInteractor interactor)
		{
			base.OnSelectEnter(interactor);
			cached.Add(interactor);
			if (CacheManager.Get<UnityEngine.XR.Interaction.Toolkit.XRController>(interactor).controllerNode == ReactTarget && !(xrRig == null) && Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData == ShotController.GameStateType.WaitingForOpponent && !AightBallPoolPlayer.mainPlayer.myTurn)
			{
				XRRig xRRig = xrRig;
				Vector3 vector = CurrentEdgePosition * 1.3f;
				Vector2 xzVector = vector.ToXZ();
				xRRig.MoveCameraToWorldLocation(xzVector.ToVector3FromXZ(xrRig.cameraGameObject.transform.position.y));
				Vector3 eulerAngles = Quaternion.LookRotation(base.transform.position - xrRig.cameraGameObject.transform.position).eulerAngles;
				xrRig.RotateAroundCameraUsingRigUp(eulerAngles.y - xrRig.cameraGameObject.transform.eulerAngles.y);
			}
		}

		private void Update()
		{
			if (isNowTracking)
			{
				if (Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState[InputHelpers.Button.Trigger].CurrentData || Singleton<BilliardsDataContainer>.Instance.XRRightControllerState[InputHelpers.Button.Trigger].CurrentData || Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData != 0)
				{
					SetActiveLine(isActive: false);
					return;
				}
				SetActiveLine(isActive: true);
				RayHitPointerTransform.position = Vector3.Lerp(RayHitPointerTransform.position, CurrentHitPosition, 0.5f);
				LateEdgePosition = Vector3.Lerp(LateEdgePosition, CurrentEdgePosition, 0.5f);
				EdgePointerTransform.position = LateEdgePosition;
				lineRenderer.positionCount = 2;
				lineRenderer.SetPositions(ConvertToLinePosition(RayHitPointerTransform.localPosition, EdgePointerTransform.localPosition));
				SetEdgePointerLookDirection();
			}
		}

		protected override void OnSelectExit(XRBaseInteractor interactor)
		{
			if (CacheManager.Get<UnityEngine.XR.Interaction.Toolkit.XRController>(interactor).controllerNode == ReactTarget)
			{
				base.OnSelectExit(interactor);
				_ = base.gameObject == null;
			}
		}

		protected override void OnHoverExit(XRBaseInteractor interactor)
		{
			base.OnHoverExit(interactor);
			if (CacheManager.Get<UnityEngine.XR.Interaction.Toolkit.XRController>(interactor).controllerNode == ReactTarget && !(base.gameObject == null))
			{
				isNowTracking = false;
				SetActiveLine(isActive: false);
			}
		}

		private Vector3[] ConvertToLinePosition(Vector3 start, Vector3 end)
		{
			return new List<Vector3>
			{
				start.ToXZ(),
				end.ToXZ()
			}.ToArray();
		}

		private void SetEdgePointerLookDirection()
		{
			Vector2 vector = CurrentEdgePosition.ToXZ();
			if (Mathf.Approximately(vector.x, (0f - TableSpace.lossyScale.x) * 0.5f))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.right);
				return;
			}
			if (Mathf.Approximately(vector.x, TableSpace.lossyScale.x * 0.5f))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.left);
				return;
			}
			if (Mathf.Approximately(vector.y, TableSpace.lossyScale.y * 0.5f))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.forward);
				return;
			}
			if (Mathf.Approximately(vector.y, (0f - TableSpace.lossyScale.y) * 0.5f))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.back);
				return;
			}
			Transform edgePointerTransform = EdgePointerTransform;
			Vector3 vector2 = base.transform.TransformPoint(CurrentHitPosition);
			Vector2 xzVector = vector2.ToXZ();
			edgePointerTransform.LookAt(xzVector.ToVector3FromXZ(EdgePointerTransform.position.y));
		}

		private void SetActiveLine(bool isActive)
		{
			EdgePointerTransform.gameObject.SetActive(isActive);
			RayHitPointerTransform.gameObject.SetActive(isActive);
			lineRenderer.enabled = isActive;
		}

		private void OnDestroy()
		{
			foreach (XRBaseInteractor item in cached)
			{
				CacheManager.Remove<UnityEngine.XR.Interaction.Toolkit.XRController>(item);
			}
			cached.Clear();
		}
	}
	public interface IBaseRaycastReactor
	{
		void OnRay(RaycastHit hitInfo);

		void OnRayEnd(RaycastHit hitInfo);

		bool RaycastReact(RaycastHit hitInfo);
	}
	[Obsolete("Legacy. Make Interactable instead")]
	public abstract class BaseRaycastReactor : MonoBehaviour, IBaseRaycastReactor
	{
		public abstract void OnRay(RaycastHit hitInfo);

		public abstract void OnRayEnd(RaycastHit hitInfo);

		public abstract bool RaycastReact(RaycastHit hitInfo);

		protected IEnumerator Easy(float runtime, Action<float> onUpdate = null, Action onComplete = null)
		{
			WaitForSecondsRealtime waitRealTime = new WaitForSecondsRealtime(Time.fixedUnscaledDeltaTime);
			float t = 0f;
			while (t < runtime)
			{
				onUpdate?.Invoke(t / runtime);
				t += Time.fixedUnscaledDeltaTime;
				yield return waitRealTime;
			}
			onUpdate?.Invoke(1f);
			onComplete?.Invoke();
		}
	}
	[Obsolete]
	public class CancelButtonRaycastReactor : BaseRaycastReactor
	{
		[Serializable]
		public class ButtonClickedEvent : UnityEvent
		{
		}

		[SerializeField]
		protected ButtonClickedEvent onClick;

		[SerializeField]
		private Transform Root;

		[SerializeField]
		private Transform FirstPivotRootA;

		[SerializeField]
		private Transform SecondPivotRootA;

		[SerializeField]
		private Transform FirstPivotRootB;

		[SerializeField]
		private Transform SecondPivotRootB;

		[SerializeField]
		private AnimationCurve FirstCurve;

		[SerializeField]
		private AnimationCurve SecondCurve;

		[SerializeField]
		private float runtime;

		private Coroutine RayRoutine;

		private Coroutine RayEndRoutine;

		private Coroutine ReactRoutine;

		public override void OnRay(RaycastHit hitInfo)
		{
			if (RayRoutine == null && ReactRoutine == null && RayEndRoutine == null)
			{
				Vector3 defaultScale = Root.transform.localScale;
				RayRoutine = StartCoroutine(Easy(0.2f, delegate(float t)
				{
					Root.transform.localScale = Vector3.Lerp(defaultScale, Vector3.one * 1.2f, t);
				}, delegate
				{
					RayRoutine = null;
				}));
			}
		}

		public override void OnRayEnd(RaycastHit hitInfo)
		{
			if (RayEndRoutine == null)
			{
				if (RayRoutine != null)
				{
					StopCoroutine(RayRoutine);
					RayRoutine = null;
				}
				Vector3 defaultScale = Root.transform.localScale;
				RayEndRoutine = StartCoroutine(Easy(0.2f, delegate(float t)
				{
					Root.transform.localScale = Vector3.Lerp(defaultScale, Vector3.one, t);
				}, delegate
				{
					RayEndRoutine = null;
				}));
			}
		}

		public override bool RaycastReact(RaycastHit hitInfo)
		{
			if (ReactRoutine != null)
			{
				return false;
			}
			if (RayRoutine != null)
			{
				StopCoroutine(RayRoutine);
				RayRoutine = null;
			}
			_ = Root.transform.localScale;
			Transform secondPivotRootA = SecondPivotRootA;
			Vector3 vector = Vector3.one;
			Vector2 xzVector = vector.ToXZ();
			secondPivotRootA.localScale = xzVector.ToVector3FromXZ();
			Transform secondPivotRootB = SecondPivotRootB;
			vector = Vector3.one;
			xzVector = vector.ToXZ();
			secondPivotRootB.localScale = xzVector.ToVector3FromXZ();
			ReactRoutine = StartCoroutine(Easy(runtime, delegate(float t)
			{
				if (t < 0.5f)
				{
					float time = Mathf.Clamp(t - 0.1f, 0f, 0.4f) * 2.5f;
					float time2 = Mathf.Clamp(t + 0.1f, 0f, 0.6f) * 1.67f;
					Transform firstPivotRootA = FirstPivotRootA;
					Vector3 vector2 = FirstPivotRootA.localScale;
					Vector2 xzVector2 = vector2.ToXZ();
					firstPivotRootA.localScale = xzVector2.ToVector3FromXZ(Mathf.Lerp(1f, 0f, FirstCurve.Evaluate(time)));
					Transform firstPivotRootB = FirstPivotRootB;
					vector2 = FirstPivotRootB.localScale;
					xzVector2 = vector2.ToXZ();
					firstPivotRootB.localScale = xzVector2.ToVector3FromXZ(Mathf.Lerp(1f, 0f, FirstCurve.Evaluate(time2)));
				}
				else
				{
					float time3 = Mathf.Clamp(t - 0.6f, 0f, 0.4f) * 2.5f;
					float time4 = Mathf.Clamp(t - 0.5f, 0f, 0.5f) * 2f;
					Transform secondPivotRootA2 = SecondPivotRootA;
					Vector3 vector2 = SecondPivotRootA.localScale;
					Vector2 xzVector2 = vector2.ToXZ();
					secondPivotRootA2.localScale = xzVector2.ToVector3FromXZ(Mathf.Lerp(0f, 1f, SecondCurve.Evaluate(time3)));
					Transform secondPivotRootB2 = SecondPivotRootB;
					vector2 = SecondPivotRootB.localScale;
					xzVector2 = vector2.ToXZ();
					secondPivotRootB2.localScale = xzVector2.ToVector3FromXZ(Mathf.Lerp(0f, 1f, SecondCurve.Evaluate(time4)));
				}
			}, delegate
			{
				ReactRoutine = null;
				onClick.Invoke();
			}));
			return true;
		}
	}
	public class InteractableButton : XRBaseInteractable, IPointerClickHandler, IEventSystemHandler
	{
		[Serializable]
		public class ButtonClickedEvent : UnityEvent
		{
		}

		[SerializeField]
		protected Image TargetGraphic;

		protected Color defaultColor;

		[SerializeField]
		protected Color NormalColor = Color.white;

		[SerializeField]
		protected Color HighlightedColor;

		[SerializeField]
		protected Color PressedColor;

		[SerializeField]
		protected Color DisabledColor = Color.gray;

		[SerializeField]
		protected bool isMultipleColor = true;

		[Range(1f, 5f)]
		[SerializeField]
		protected float Multiplier = 1f;

		[SerializeField]
		protected float FadeDuration = 0.1f;

		[SerializeField]
		protected ButtonClickedEvent onClick;

		private bool _interactable = true;

		protected Color targetColor;

		public bool interactable
		{
			get
			{
				return _interactable;
			}
			set
			{
				if (_interactable != value)
				{
					_interactable = value;
					if (value)
					{
						StopAllCoroutines();
						targetColor = NormalColor;
						TargetGraphic.color = NormalColor * defaultColor;
					}
					else
					{
						targetColor = DisabledColor;
						TargetGraphic.color = DisabledColor * defaultColor;
					}
				}
			}
		}

		protected override void Awake()
		{
			base.Awake();
			defaultColor = TargetGraphic.color;
		}

		protected virtual void OnDisable()
		{
			targetColor = NormalColor;
			TargetGraphic.color = NormalColor * defaultColor;
		}

		protected override void OnHoverEnter(XRBaseInteractor interactor)
		{
			base.OnHoverEnter(interactor);
			if (interactable && targetColor != HighlightedColor)
			{
				targetColor = HighlightedColor;
				StartCoroutine(Fade());
			}
		}

		public void OnPointerClick(PointerEventData eventData)
		{
			OnClickButton();
		}

		protected override void OnSelectEnter(XRBaseInteractor interactor)
		{
			base.OnSelectEnter(interactor);
			OnClickButton();
		}

		private void OnClickButton()
		{
			if (interactable && targetColor != PressedColor)
			{
				targetColor = PressedColor;
				StartCoroutine(Fade(delegate
				{
					targetColor = NormalColor;
					StartCoroutine(Fade());
				}));
				onClick.Invoke();
			}
		}

		protected override void OnHoverExit(XRBaseInteractor interactor)
		{
			base.OnHoverExit(interactor);
			if (interactable && !(base.gameObject == null) && targetColor != NormalColor)
			{
				targetColor = NormalColor;
				StartCoroutine(Fade());
			}
		}

		protected IEnumerator Fade(Action OnComplete = null)
		{
			float t = 0f;
			Color firstColor = TargetGraphic.color;
			WaitForSecondsRealtime waitRealTime = new WaitForSecondsRealtime(Time.fixedUnscaledDeltaTime);
			while (t < FadeDuration)
			{
				TargetGraphic.color = Color.Lerp(firstColor * Multiplier * (defaultColor / Multiplier), targetColor * Multiplier * (defaultColor / Multiplier), t / FadeDuration);
				t += Time.fixedUnscaledDeltaTime;
				yield return waitRealTime;
			}
			TargetGraphic.color = Color.Lerp(firstColor * Multiplier * (defaultColor / Multiplier), targetColor * Multiplier * (defaultColor / Multiplier), 1f);
			OnComplete?.Invoke();
		}
	}
	public class RaycastReactRaiser : BaseRaycastReactor
	{
		[SerializeField]
		private BaseRaycastReactor Target;

		public override void OnRay(RaycastHit hitInfo)
		{
			Target?.OnRay(hitInfo);
		}

		public override void OnRayEnd(RaycastHit hitInfo)
		{
			Target?.OnRayEnd(hitInfo);
		}

		public override bool RaycastReact(RaycastHit hitInfo)
		{
			if (Target != null)
			{
				return Target.RaycastReact(hitInfo);
			}
			return false;
		}
	}
	public class TableRaycastReactor : BaseRaycastReactor
	{
		private enum ReactType
		{
			None,
			HitOnly,
			HitToEdge
		}

		[SerializeField]
		private BoxCollider collider;

		[SerializeField]
		private Transform cameraCenter;

		[SerializeField]
		private Transform EdgePointerTransform;

		[SerializeField]
		private Transform RayHitPointerTransform;

		[SerializeField]
		private LineRenderer lineRenderer;

		private ReactType currentReactionType = ReactType.HitToEdge;

		private Vector2 RectMax;

		private Vector2 RectMin;

		public Vector3 CurrentEdgeLocalPosition;

		public Vector3 LateEdgeLocalPosition;

		public Vector3 CurrentHitLocalPosition;

		private bool isNowTracking;

		private const float TABLE_EDGE_DISTANCE = 0.09610341f;

		private ReactType lastType;

		private void Awake()
		{
			currentReactionType = ReactType.None;
			RectMax = new Vector2(collider.center.x + (collider.size.x * 0.5f - 0.09610341f), collider.center.z + (collider.size.z * 0.5f - 0.09610341f));
			RectMin = new Vector2(collider.center.x - (collider.size.x * 0.5f - 0.09610341f), collider.center.z - (collider.size.z * 0.5f - 0.09610341f));
		}

		private void OnEnable()
		{
			cameraCenter = Singleton<BilliardsDataContainer>.Instance.TableCameraCenter.CurrentData;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.TableCameraCenter.OnDataChanged += TableCameraCenter_OnDataChanged;
		}

		private void TableCameraCenter_OnDataChanged(Transform obj)
		{
			cameraCenter = obj;
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			if ((uint)(obj - 2) <= 1u)
			{
				currentReactionType = ReactType.HitOnly;
			}
			else
			{
				currentReactionType = ReactType.None;
			}
		}

		private void OnDisable()
		{
			Singleton<BilliardsDataContainer>.Instance.TableCameraCenter.OnDataChanged -= TableCameraCenter_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
		}

		public override void OnRay(RaycastHit hitInfo)
		{
			if (!isNowTracking)
			{
				isNowTracking = true;
				SetPresetByCurrentType();
			}
			SetEdgePositionByTablePivot(hitInfo.point);
		}

		private void SetEdgePositionByTablePivot(Vector3 hitPos)
		{
			Vector3 vector = base.transform.InverseTransformPoint(hitPos);
			Vector2 vector2 = vector.ToXZ().normalized * 10f;
			float num = vector2.y / vector2.x;
			vector2.y = Mathf.Clamp(vector2.y, RectMin.y, RectMax.y);
			vector2.x = ((num == 0f) ? vector2.x : (vector2.y / num));
			if (Mathf.Abs(vector2.x) > RectMax.x)
			{
				vector2.x = Mathf.Clamp(vector2.x, RectMin.x, RectMax.x);
				vector2.y = num * vector2.x;
			}
			CurrentHitLocalPosition = base.transform.InverseTransformPoint(hitPos);
			CurrentEdgeLocalPosition = new Vector3(vector2.x, CurrentHitLocalPosition.y, vector2.y);
		}

		public override void OnRayEnd(RaycastHit hitInfo)
		{
			isNowTracking = false;
			SetPresetByCurrentType(ReactType.None);
		}

		private void Update()
		{
			if (isNowTracking && currentReactionType != 0)
			{
				SetPresetByCurrentType();
				RayHitPointerTransform.localPosition = Vector3.Lerp(RayHitPointerTransform.localPosition, CurrentHitLocalPosition, 0.5f);
				if (currentReactionType != ReactType.HitOnly)
				{
					LateEdgeLocalPosition = Vector3.Lerp(LateEdgeLocalPosition, CurrentEdgeLocalPosition, 0.5f);
					EdgePointerTransform.localPosition = LateEdgeLocalPosition;
					lineRenderer.SetPositions(ConvertToLinePosition(RayHitPointerTransform.localPosition, LateEdgeLocalPosition));
					SetEdgePointerLookDirection();
					Vector2 value = Vector2.left * Time.time * Mathf.Abs((RayHitPointerTransform.localPosition - LateEdgeLocalPosition).magnitude) * 0.2f;
					lineRenderer.sharedMaterial.SetTextureOffset("_MainTex", value);
				}
			}
		}

		private void SetPresetByCurrentType(ReactType? overridedType = null)
		{
			ReactType reactType = (overridedType.HasValue ? overridedType.Value : currentReactionType);
			if (lastType != reactType)
			{
				switch (reactType)
				{
				case ReactType.None:
					lineRenderer.enabled = false;
					lineRenderer.positionCount = 0;
					RayHitPointerTransform.gameObject.SetActive(value: false);
					EdgePointerTransform.gameObject.SetActive(value: false);
					break;
				case ReactType.HitOnly:
					lineRenderer.enabled = false;
					lineRenderer.positionCount = 0;
					RayHitPointerTransform.gameObject.SetActive(value: true);
					EdgePointerTransform.gameObject.SetActive(value: false);
					break;
				case ReactType.HitToEdge:
					lineRenderer.enabled = true;
					lineRenderer.positionCount = 2;
					RayHitPointerTransform.gameObject.SetActive(value: true);
					EdgePointerTransform.gameObject.SetActive(value: true);
					break;
				}
				lastType = reactType;
			}
		}

		public override bool RaycastReact(RaycastHit hitInfo)
		{
			if (currentReactionType == ReactType.HitToEdge)
			{
				Vector3 worldPosition = -base.transform.TransformPoint(CurrentEdgeLocalPosition);
				worldPosition.y = cameraCenter.position.y;
				cameraCenter.LookAt(worldPosition, Vector3.up);
				return true;
			}
			return false;
		}

		private Vector3[] ConvertToLinePosition(Vector3 start, Vector3 end)
		{
			return new List<Vector3>
			{
				start.ToXZ(),
				end.ToXZ()
			}.ToArray();
		}

		private void SetEdgePointerLookDirection()
		{
			Vector2 vector = CurrentEdgeLocalPosition.ToXZ();
			if (Mathf.Approximately(vector.x, RectMax.x))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.right);
				return;
			}
			if (Mathf.Approximately(vector.x, RectMin.x))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.left);
				return;
			}
			if (Mathf.Approximately(vector.y, RectMax.y))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.forward);
				return;
			}
			if (Mathf.Approximately(vector.y, RectMin.y))
			{
				EdgePointerTransform.LookAt(EdgePointerTransform.position + Vector3.back);
				return;
			}
			Transform edgePointerTransform = EdgePointerTransform;
			Vector3 vector2 = base.transform.TransformPoint(CurrentHitLocalPosition);
			Vector2 xzVector = vector2.ToXZ();
			edgePointerTransform.LookAt(xzVector.ToVector3FromXZ(EdgePointerTransform.position.y));
		}
	}
	public class SoundInvoker : MonoBehaviour
	{
		private AudioSource source;

		[SerializeField]
		private AudioClip freeballClip_eng;

		[SerializeField]
		private AudioClip freeballClip_chn;

		private void Start()
		{
			source = GetComponent<AudioSource>();
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				source.clip = freeballClip_chn;
			}
			else
			{
				source.clip = freeballClip_eng;
			}
		}

		public void OnClickButton()
		{
			SoundManager.PlaySound(SoundManager.AudioClipType.Button);
		}
	}
	public class SoundManager : MonoSingleton<SoundManager>
	{
		public enum AudioClipType
		{
			None,
			Button,
			Win,
			Lose,
			Popup,
			TimeLimit,
			LobbyBGM,
			GameBGM,
			Intro
		}

		[Serializable]
		private class AudioDatum
		{
			public AudioClipType type;

			public AudioClip clip;

			[Range(0f, 1f)]
			public float volume = 0.5f;
		}

		[SerializeField]
		private AudioDatum LobbyDatum;

		private AudioSource LobbySource;

		[SerializeField]
		private AudioDatum IngameDatum;

		private AudioSource IngameSource;

		[Space(15f)]
		[SerializeField]
		private AudioDatum[] AudioData;

		[Space(15f)]
		[SerializeField]
		private AnimationCurve FadeInCurve;

		[SerializeField]
		private AnimationCurve FadeOutCurve;

		[SerializeField]
		private List<AudioClip> CrowdCheerSounds;

		private Dictionary<AudioClipType, AudioDatum> AudioDictionary = new Dictionary<AudioClipType, AudioDatum>();

		private List<AudioSource> AudioSources = new List<AudioSource>();

		private List<AudioSource> CachedAudioSource = new List<AudioSource>();

		private float defaultBgmVolume;

		private float CachedFXVolume = float.MinValue;

		private float CachedBGMVolume = float.MinValue;

		private int SceneChangedCount;

		public bool isInitialized { get; private set; }

		private float SavedFXVolume
		{
			get
			{
				return DataManager.GetFloat("FXVolume", 1f);
			}
			set
			{
				DataManager.SetFloat("FXVolume", value);
			}
		}

		private float SavedBGMVolume
		{
			get
			{
				return DataManager.GetFloat("BGMVolume", 1f);
			}
			set
			{
				DataManager.SetFloat("BGMVolume", value);
			}
		}

		public float FXVolume
		{
			get
			{
				if (CachedFXVolume == float.MinValue)
				{
					CachedFXVolume = SavedFXVolume;
				}
				return CachedFXVolume;
			}
			set
			{
				if (SavedFXVolume != value)
				{
					SavedFXVolume = value;
					CachedFXVolume = value;
					UpdateVolume();
				}
			}
		}

		public float BGMVolume
		{
			get
			{
				if (CachedBGMVolume == float.MinValue)
				{
					CachedBGMVolume = SavedBGMVolume;
				}
				return CachedBGMVolume;
			}
			set
			{
				if (SavedBGMVolume != value)
				{
					SavedBGMVolume = value;
					CachedBGMVolume = value;
					UpdateVolume();
				}
			}
		}

		protected override void Awake()
		{
			if ((object)MonoSingleton<SoundManager>._instance != null)
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
				return;
			}
			Initialze();
			base.Awake();
		}

		private void Initialze()
		{
			for (int i = 0; i < 10; i++)
			{
				AudioSource audioSource = base.gameObject.AddComponent<AudioSource>();
				InitializeAudioSource(audioSource);
				AudioSources.Add(audioSource);
				audioSource.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("Effect");
			}
			LobbySource = base.gameObject.AddComponent<AudioSource>();
			LobbySource.clip = LobbyDatum.clip;
			LobbySource.volume = LobbyDatum.volume * BGMVolume;
			LobbySource.loop = true;
			LobbySource.playOnAwake = false;
			LobbySource.Stop();
			IngameSource = base.gameObject.AddComponent<AudioSource>();
			IngameSource.clip = IngameDatum.clip;
			IngameSource.volume = IngameDatum.volume * BGMVolume;
			IngameSource.loop = true;
			IngameSource.playOnAwake = false;
			IngameSource.Stop();
			for (int j = 0; j < AudioData.Length; j++)
			{
				AudioDictionary[AudioData[j].type] = AudioData[j];
			}
			isInitialized = true;
			defaultBgmVolume = LobbyDatum.volume;
			SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
		}

		private void SceneManager_activeSceneChanged(Scene prev, Scene next)
		{
			if (SceneChangedCount++ != 0)
			{
				StopAllCoroutines();
				if (next.buildIndex == 2)
				{
					StartCoroutine(FadeBGM(LobbySource, IngameSource, 2f));
				}
				else
				{
					StartCoroutine(FadeBGM(IngameSource, LobbySource, 2f));
				}
			}
		}

		private IEnumerator FadeBGM(AudioSource prev, AudioSource next, float runtime)
		{
			float t = 0f;
			next.volume = 0f;
			next.Play();
			while (t < runtime)
			{
				t += Time.deltaTime;
				prev.volume = defaultBgmVolume * FadeOutCurve.Evaluate(t / runtime) * BGMVolume;
				next.volume = defaultBgmVolume * FadeInCurve.Evaluate(t / runtime) * BGMVolume;
				yield return null;
			}
			prev.Stop();
			prev.volume = defaultBgmVolume * FadeOutCurve.Evaluate(1f) * BGMVolume;
			next.volume = defaultBgmVolume * FadeInCurve.Evaluate(1f) * BGMVolume;
		}

		private void InitializeAudioSource(AudioSource source)
		{
			source.playOnAwake = false;
		}

		private void UpdateVolume()
		{
			LobbySource.volume = LobbyDatum.volume * BGMVolume;
			IngameSource.volume = IngameDatum.volume * BGMVolume;
			int i = 0;
			while (i < AudioSources.Count)
			{
				if (AudioSources[i].isPlaying)
				{
					AudioDatum audioDatum = AudioDictionary.Values.First((AudioDatum datum) => datum.clip == AudioSources[i].clip);
					AudioSources[i].volume = audioDatum.volume * FXVolume;
				}
				int num = i + 1;
				i = num;
			}
		}

		private void PlayRandomCheerSound()
		{
			for (int i = 0; i < AudioSources.Count; i++)
			{
				if (!AudioSources[i].isPlaying)
				{
					AudioSources[i].clip = CrowdCheerSounds.GetRandom();
					AudioSources[i].volume = 0.5f * FXVolume;
					AudioSources[i].loop = false;
					AudioSources[i].Play();
					break;
				}
			}
		}

		private void PlaySoundInternal(AudioClipType type)
		{
			switch (type)
			{
			case AudioClipType.LobbyBGM:
				LobbySource.Play();
				return;
			case AudioClipType.GameBGM:
				IngameSource.Play();
				return;
			}
			for (int i = 0; i < AudioSources.Count; i++)
			{
				if (!AudioSources[i].isPlaying)
				{
					AudioSources[i].clip = AudioDictionary[type].clip;
					AudioSources[i].volume = AudioDictionary[type].volume * FXVolume;
					AudioSources[i].loop = false;
					AudioSources[i].Play();
					break;
				}
			}
		}

		private void StopSoundInternal(AudioClipType type)
		{
			switch (type)
			{
			case AudioClipType.LobbyBGM:
				LobbySource.Stop();
				return;
			case AudioClipType.GameBGM:
				IngameSource.Stop();
				return;
			}
			for (int i = 0; i < AudioSources.Count; i++)
			{
				if (AudioSources[i].isPlaying && AudioSources[i].clip == AudioDictionary[type].clip)
				{
					AudioSources[i].Stop();
				}
			}
		}

		private void PlayingSoundModifyInternal(AudioClipType type, Action<AudioSource> target)
		{
			switch (type)
			{
			case AudioClipType.LobbyBGM:
				target?.Invoke(LobbySource);
				return;
			case AudioClipType.GameBGM:
				target?.Invoke(IngameSource);
				return;
			}
			for (int i = 0; i < AudioSources.Count; i++)
			{
				if (AudioSources[i].isPlaying && AudioSources[i].clip == AudioDictionary[type].clip)
				{
					target?.Invoke(AudioSources[i]);
				}
			}
		}

		private bool isPlayingInternal(AudioClipType type)
		{
			switch (type)
			{
			case AudioClipType.LobbyBGM:
				return LobbySource.isPlaying;
			case AudioClipType.GameBGM:
				return IngameSource.isPlaying;
			default:
			{
				for (int i = 0; i < AudioSources.Count; i++)
				{
					if (AudioSources[i].isPlaying && AudioSources[i].clip == AudioDictionary[type].clip)
					{
						return AudioSources[i].isPlaying;
					}
				}
				return false;
			}
			}
		}

		private void PauseSoundInternal(bool isPause)
		{
			if (isPause)
			{
				for (int i = 0; i < AudioSources.Count; i++)
				{
					if (AudioSources[i].isPlaying)
					{
						CachedAudioSource.Add(AudioSources[i]);
						AudioSources[i].Pause();
					}
				}
			}
			else
			{
				List<AudioSource>.Enumerator enumerator = CachedAudioSource.GetEnumerator();
				while (enumerator.MoveNext())
				{
					enumerator.Current.Play();
				}
				CachedAudioSource.Clear();
			}
		}

		public static bool isPlaying(AudioClipType type)
		{
			if (!MonoSingleton<SoundManager>.Instance.isInitialized)
			{
				return false;
			}
			return MonoSingleton<SoundManager>.Instance.isPlayingInternal(type);
		}

		public static void PlaySound(AudioClipType type)
		{
			if (MonoSingleton<SoundManager>.Instance.isInitialized)
			{
				MonoSingleton<SoundManager>.Instance.PlaySoundInternal(type);
			}
		}

		public static void PlayCheerSound()
		{
			if (MonoSingleton<SoundManager>.Instance.isInitialized)
			{
				MonoSingleton<SoundManager>.Instance.PlayRandomCheerSound();
			}
		}

		public static void StopSound(AudioClipType type)
		{
			if (MonoSingleton<SoundManager>.Instance.isInitialized)
			{
				MonoSingleton<SoundManager>.Instance.StopSoundInternal(type);
			}
		}

		public static void PlayingSoundModify(AudioClipType type, Action<AudioSource> target)
		{
			MonoSingleton<SoundManager>.Instance.PlayingSoundModifyInternal(type, target);
		}

		public static float GetDefaultVolume(AudioClipType type)
		{
			return MonoSingleton<SoundManager>.Instance.AudioDictionary[type].volume;
		}

		public static void Pause(bool isPause)
		{
			if (MonoSingleton<SoundManager>.Instance.isInitialized)
			{
				MonoSingleton<SoundManager>.Instance.PauseSoundInternal(isPause);
			}
		}

		public override void OnDestroy()
		{
			if (MonoSingleton<SoundManager>._instance == this)
			{
				base.OnDestroy();
			}
		}
	}
	[RequireComponent(typeof(Text))]
	public class BuildTestText : MonoBehaviour
	{
		[SerializeField]
		private Text text;

		[SerializeField]
		private string desc;

		private void Awake()
		{
			text.text = desc + 10;
		}
	}
	public class CacheTest : MonoBehaviour
	{
		[SerializeField]
		private GameObject xrRig;

		private void Start()
		{
			CacheManager.Get<XRRig>(xrRig);
			CacheManager.Get<XRGripPosition>(xrRig);
			CacheManager.Get<XRGripRotation>(xrRig);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				CacheManager.Remove<XRRig>(xrRig);
			}
		}
	}
	public class CoroutineTest : MonoBehaviour
	{
		private CoroutineWrapper wrapper;

		private void Awake()
		{
			wrapper = CoroutineWrapper.Generate(this).StartSingleton(Test()).SetOnComplete(delegate
			{
				UnityEngine.Debug.Log("End");
			});
			static IEnumerator Test()
			{
				UnityEngine.Debug.Log("start");
				yield return new WaitForSeconds(1.5f);
				UnityEngine.Debug.Log("something");
			}
		}

		private IEnumerator Start()
		{
			StartCoroutine("Test");
			StartCoroutine("Test");
			yield return new WaitForSeconds(1f);
		}

		private IEnumerator Test()
		{
			UnityEngine.Debug.Log("Test 01");
			yield return new WaitForSeconds(2f);
			UnityEngine.Debug.Log("Test 02");
		}
	}
	public class GeometryTest : MonoBehaviour
	{
		[SerializeField]
		private Transform SimulateSpace;

		[SerializeField]
		private Transform Pivot;

		[SerializeField]
		private Transform Target;

		[SerializeField]
		private Transform CalculatedMarker;

		[SerializeField]
		private List<Transform> markers;

		private void Update()
		{
			UnityEngine.Debug.DrawRay(Pivot.position, (Target.position - Pivot.position) * 10f, Color.magenta, Time.deltaTime);
			Transform obj = CalculatedMarker.transform;
			Vector3 vector = Target.position - Pivot.position;
			Vector2 direction = vector.ToXZ();
			Vector3 vector2 = Pivot.position;
			Vector2 xzVector = Geometry.EdgeProjectionXZ(direction, vector2.ToXZ(), SimulateSpace);
			obj.position = xzVector.ToVector3FromXZ();
		}
	}
	public class LocalFunctionTest : MonoBehaviour
	{
		public void Awake()
		{
			float t = 0f;
			LocalFunction(ref t);
			UnityEngine.Debug.Log("T : " + t);
			StartCoroutine(RunRoutine());
			static void LocalFunction(ref float temp)
			{
				temp = 15f;
			}
			IEnumerator RunRoutine()
			{
				while (true)
				{
					yield return new WaitForSeconds(1f);
					t += 1f;
					UnityEngine.Debug.Log("In Loop : " + t);
				}
			}
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		public void Update()
		{
		}
	}
	[ExecuteInEditMode]
	public class MarkerGenerator : MonoBehaviour
	{
		[SerializeField]
		private GameObject Origin;

		[SerializeField]
		private Transform root;

		[SerializeField]
		private float distance;

		[SerializeField]
		private float interval;

		private void OnEnable()
		{
			for (float num = (0f - distance) * 0.5f; num < distance * 0.5f; num += interval)
			{
				for (float num2 = (0f - distance) * 0.5f; num2 < distance * 0.5f; num2 += interval)
				{
					GameObject obj = UnityEngine.Object.Instantiate(Origin);
					obj.transform.parent = root;
					obj.transform.localPosition = new Vector3(num, 0f, num2);
					obj.transform.localRotation = Quaternion.identity;
				}
			}
		}

		private void OnDisable()
		{
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < root.childCount; i++)
			{
				GameObject gameObject = root.GetChild(i).gameObject;
				if (gameObject.GetInstanceID() != Origin.GetInstanceID())
				{
					list.Add(gameObject);
				}
			}
			foreach (GameObject item in list.ToList())
			{
				UnityEngine.Object.DestroyImmediate(item);
			}
		}
	}
	public class NotifierTest : MonoBehaviour
	{
		[SerializeField]
		private List<GameObject> list;

		private Appnori.Util.NotifierClass<GameObject> target = new Appnori.Util.NotifierClass<GameObject>();

		private int idx;

		private void Start()
		{
			target.OnDataChanged += delegate(GameObject gameObject)
			{
				UnityEngine.Debug.Log("[OnDataChanged]object is " + gameObject.name);
			};
			target.OnDataChangedOnce += delegate(GameObject gameObject)
			{
				UnityEngine.Debug.Log("[OnDataChangedOnce]object is " + gameObject.name);
			};
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				target.CurrentData = list[++idx % list.Count];
			}
		}
	}
	public class PhotonRPCTest : MonoSingleton<PhotonRPCTest>
	{
	}
	[Obsolete("NotUse", true)]
	public class TrackingCueData : MonoBehaviour
	{
		public enum TrackingType
		{
			None,
			AngularVelocity,
			TrackPosition
		}

		[SerializeField]
		private TrackingType TargetTrackingType;

		[SerializeField]
		private Text text;

		private void Awake()
		{
			switch (TargetTrackingType)
			{
			case TrackingType.AngularVelocity:
				Singleton<BilliardsDataContainer>.Instance.ControllerAngularVelocity.OnDataChanged += ControllerAngularVelocity_OnDataChanged;
				break;
			case TrackingType.TrackPosition:
				Singleton<BilliardsDataContainer>.Instance.ControllerTrackPosition.OnDataChanged += ControllerTrackPosition_OnDataChanged;
				break;
			case TrackingType.None:
				break;
			}
		}

		private void OnDestroy()
		{
			switch (TargetTrackingType)
			{
			case TrackingType.AngularVelocity:
				Singleton<BilliardsDataContainer>.Instance.ControllerAngularVelocity.OnDataChanged -= ControllerAngularVelocity_OnDataChanged;
				break;
			case TrackingType.TrackPosition:
				Singleton<BilliardsDataContainer>.Instance.ControllerTrackPosition.OnDataChanged += ControllerTrackPosition_OnDataChanged;
				break;
			case TrackingType.None:
				break;
			}
		}

		private void ControllerAngularVelocity_OnDataChanged(Vector3 obj)
		{
			text.text = $"{obj.x:F2} , {obj.y:F2} , {obj.z:F2}";
		}

		private void ControllerTrackPosition_OnDataChanged(Vector2 obj)
		{
		}
	}
	public class TransportTest : MonoBehaviour
	{
		[Serializable]
		public class TestData : SerializableClass
		{
			public float time;

			public override void DeSerialize(string data)
			{
				TestData testData = JsonUtility.FromJson<TestData>(data);
				time = testData.time;
			}

			public override string Serialize()
			{
				return JsonUtility.ToJson(this);
			}
		}

		private int idx;

		private void Awake()
		{
			MonoSingleton<Transporter>.Instance.RegisterTarget(Call);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				TestData data = new TestData
				{
					time = Time.time
				};
				MonoSingleton<Transporter>.Instance.Send(Call, data);
			}
			if (Input.GetKeyDown(KeyCode.LeftShift))
			{
				Data data2 = new Data
				{
					value = idx++,
					value2 = "current idx is {0}"
				};
				MonoSingleton<Transporter>.Instance.Send(Call, data2);
			}
		}

		public void Call(SerializableClass packet)
		{
			if (packet != null)
			{
				if (packet is TestData testData)
				{
					TestData testData2 = testData;
					UnityEngine.Debug.Log("current Time : " + testData2.time);
					return;
				}
				if (packet is Data data)
				{
					Data data2 = data;
					UnityEngine.Debug.Log(string.Format(data2.value2, data2.value));
					return;
				}
			}
			UnityEngine.Debug.Log("packet Type is NOT supported");
		}
	}
	[Serializable]
	public abstract class SerializableClass
	{
		public abstract string Serialize();

		public abstract void DeSerialize(string data);
	}
	[Serializable]
	public class Data : SerializableClass
	{
		public int value;

		public string value2;

		public Data SetValue(int v)
		{
			value = v;
			return this;
		}

		public Data SetValue2(string v)
		{
			value2 = v;
			return this;
		}

		public override void DeSerialize(string data)
		{
			Data data2 = JsonUtility.FromJson<Data>(data);
			value = data2.value;
			value2 = data2.value2;
		}

		public override string Serialize()
		{
			return JsonUtility.ToJson(this);
		}
	}
	public class Transporter : MonoSingleton<Transporter>
	{
		private Dictionary<string, object> registeredInstanceDict = new Dictionary<string, object>();

		public bool Send(Action<SerializableClass> invocationTarget, SerializableClass data)
		{
			PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = CreatePacket(invocationTarget, data);
			if (packetInfo == null)
			{
				return false;
			}
			SendTo(packetInfo.Serialize());
			return true;
		}

		public void RegisterTarget(Action<SerializableClass> invocationTarget)
		{
			string key = invocationTarget.GetMethodInfo().ReflectedType.ToString();
			object target = invocationTarget.Target;
			registeredInstanceDict[key] = target;
		}

		private PacketInfo<Action<SerializableClass>, SerializableClass> CreatePacket(Action<SerializableClass> invocationTarget, SerializableClass data)
		{
			if (!registeredInstanceDict.ContainsKey(invocationTarget.GetMethodInfo().ReflectedType.ToString()))
			{
				UnityEngine.Debug.LogError("invocationTarget is NOT Registered.");
				return null;
			}
			PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = new PacketInfo<Action<SerializableClass>, SerializableClass>();
			packetInfo.Set(invocationTarget, data);
			return packetInfo;
		}

		private void SendTo(string data)
		{
			ReceiveFrom(data);
		}

		private void ReceiveFrom(string data)
		{
			PacketInfo<Action<SerializableClass>, SerializableClass> packetInfo = PacketInfo<Action<SerializableClass>, SerializableClass>.ToInfo(data);
			packetInfo.Get((string name) => registeredInstanceDict[name])(packetInfo.argsData);
		}
	}
	[Serializable]
	public class PacketInfo<T, Args> where T : Delegate where Args : SerializableClass
	{
		public string typeName;

		public string assem;

		public string functionName;

		public string ArgsType;

		public string ArgsAssem;

		public string serializedArgs;

		[NonSerialized]
		public Args argsData;

		public void Set(T caller, Args data)
		{
			functionName = caller.GetMethodInfo().Name;
			assem = caller.GetMethodInfo().ReflectedType.Assembly.ToString();
			typeName = caller.GetMethodInfo().ReflectedType.ToString();
			ArgsAssem = data.GetType().Assembly.ToString();
			ArgsType = data.GetType().FullName;
			argsData = data;
		}

		public string Serialize()
		{
			serializedArgs = argsData.Serialize();
			return JsonUtility.ToJson(this);
		}

		public static PacketInfo<T, Args> ToInfo(string json)
		{
			PacketInfo<T, Args> packetInfo = JsonUtility.FromJson<PacketInfo<T, Args>>(json);
			Type type = Type.GetType(packetInfo.ArgsType + ", " + packetInfo.ArgsAssem);
			packetInfo.argsData = Activator.CreateInstance(type) as Args;
			packetInfo.argsData.DeSerialize(packetInfo.serializedArgs);
			return packetInfo;
		}

		public T Get(Func<string, object> predicate)
		{
			MethodInfo method = Type.GetType(typeName + ", " + assem).GetMethod(functionName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			return (T)Delegate.CreateDelegate(typeof(T), predicate(typeName), method);
		}
	}
	public class VelocityTest : MonoBehaviour
	{
		[SerializeField]
		private Transform pivot;

		[SerializeField]
		private Transform slider;

		private float cueSliderDisplacementZ;

		private bool allow;

		private void Start()
		{
			Singleton<BilliardsDataContainer>.Instance.XRRightControllerState[InputHelpers.Button.Trigger].OnDataChanged += VelocityTest_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.XRRightControllerState[InputHelpers.Button.Trigger].OnDataChangedOnce += VelocityTest_OnDataChangedOnce;
		}

		private void VelocityTest_OnDataChanged(bool obj)
		{
			UnityEngine.Debug.Log("always : VelocityTest_OnDataChanged");
			allow = obj;
			if (!obj)
			{
				cueSliderDisplacementZ = 0f;
			}
		}

		private void VelocityTest_OnDataChangedOnce(bool obj)
		{
			UnityEngine.Debug.Log("CallOnce : VelocityTest_OnDataChangedOnce");
		}

		private void Update()
		{
			Vector3 vector = Singleton<BilliardsDataContainer>.Instance.MainCamera.CurrentData.transform.position;
			Vector2 vector2 = vector.ToXZ();
			vector = pivot.position;
			Vector2 xzVector = (vector.ToXZ() - vector2).normalized;
			pivot.rotation = Quaternion.LookRotation(xzVector.ToVector3FromXZ(), Vector3.up);
			UnityEngine.Debug.Log("Allow : " + allow);
			if (allow)
			{
				Vector3 vector3 = Vector3.Project(Singleton<BilliardsDataContainer>.Instance.XRRightControllerState.VelocityNotifier.CurrentData, slider.transform.forward);
				cueSliderDisplacementZ += slider.InverseTransformVector(vector3).z * Time.deltaTime;
				UnityEngine.Debug.Log("cueSliderDisplacementZ : " + cueSliderDisplacementZ);
				cueSliderDisplacementZ = Mathf.Clamp(cueSliderDisplacementZ, -1f, 0f);
				slider.position += vector3 * Time.deltaTime;
			}
		}
	}
	public class XRRigTest : MonoBehaviour
	{
		[SerializeField]
		private GameObject Marker1;

		[SerializeField]
		private GameObject Marker2;

		[SerializeField]
		private GameObject Marker3;

		[SerializeField]
		private GameObject Marker4;

		[SerializeField]
		private XRRig targetRig;

		[SerializeField]
		private ColliderEventRaiser HeadTracker;

		private Queue<Vector3> lastPositions = new Queue<Vector3>();

		private Vector3 lastPosition;

		private Vector3 currentPosition;

		private bool onTriggerEnter;

		private void Awake()
		{
			onTriggerEnter = false;
			HeadTracker.OnTriggerEnterEvent += HeadTracker_OnTriggerEnterEvent;
			HeadTracker.OnTriggerStayEvent += HeadTracker_OnTriggerStayEvent;
			HeadTracker.OnTriggerExitEvent += HeadTracker_OnTriggerExitEvent;
		}

		private void HeadTracker_OnTriggerEnterEvent(Collider obj)
		{
			onTriggerEnter = true;
		}

		private void HeadTracker_OnTriggerStayEvent(Collider obj)
		{
			Vector3 vector = lastPositions.Peek() - currentPosition;
			targetRig.MoveCameraToWorldLocation(targetRig.cameraGameObject.transform.position + vector * 1.1f);
		}

		private void HeadTracker_OnTriggerExitEvent(Collider obj)
		{
			onTriggerEnter = false;
		}

		private void Update()
		{
			Marker1.transform.position = targetRig.rigInCameraSpacePos;
			Marker2.transform.position = targetRig.cameraInRigSpacePos;
			Marker3.transform.position = targetRig.cameraGameObject.transform.position;
			Marker4.transform.position = targetRig.transform.position;
			if (!onTriggerEnter)
			{
				lastPosition = currentPosition;
				lastPositions.Enqueue(currentPosition);
				if (lastPositions.Count > 4)
				{
					lastPositions.Dequeue();
				}
			}
			currentPosition = targetRig.cameraGameObject.transform.position;
		}
	}
	public class AlwaysIdentity : MonoBehaviour
	{
		private void FixedUpdate()
		{
			base.transform.rotation = Quaternion.identity;
		}
	}
	public class BackgroundHider : MonoBehaviour
	{
		[SerializeField]
		private Material target;

		[SerializeField]
		private List<Renderer> renderers = new List<Renderer>();

		private WaitForSecondsRealtime waitUnscaledDelta;

		private Coroutine RunRoutine;

		private bool Active;

		public float CutoffValue
		{
			get
			{
				return Singleton<BilliardsDataContainer>.Instance.TableBackgroundHiderCutoffValue.CurrentData;
			}
			private set
			{
				Singleton<BilliardsDataContainer>.Instance.TableBackgroundHiderCutoffValue.CurrentData = value;
			}
		}

		private void Awake()
		{
			Singleton<BilliardsDataContainer>.Instance.TableBackgroundHider.CurrentData = this;
			foreach (Renderer renderer in renderers)
			{
				renderer.sharedMaterial = target;
			}
			target.SetFloat("_Cutoff", 1f);
			CutoffValue = 1f;
			waitUnscaledDelta = new WaitForSecondsRealtime(Time.fixedUnscaledDeltaTime);
		}

		public void HideBlack()
		{
			if (target.GetFloat("_Cutoff") != 1f)
			{
				if (RunRoutine != null)
				{
					StopCoroutine(RunRoutine);
					RunRoutine = null;
				}
				RunRoutine = StartCoroutine(Run(0.1f, 1f));
			}
		}

		public void ShowBlack()
		{
			if (target.GetFloat("_Cutoff") != 0f)
			{
				if (RunRoutine != null)
				{
					StopCoroutine(RunRoutine);
					RunRoutine = null;
				}
				RunRoutine = StartCoroutine(Run(0.1f, 0f));
			}
		}

		private IEnumerator Run(float time, float to)
		{
			float t = 0f;
			float current = target.GetFloat("_Cutoff");
			while (t < time)
			{
				CutoffValue = Mathf.Lerp(current, to, t / time);
				target.SetFloat("_Cutoff", CutoffValue);
				t += Time.fixedUnscaledDeltaTime;
				yield return waitUnscaledDelta;
			}
			CutoffValue = to;
			target.SetFloat("_Cutoff", CutoffValue);
			RunRoutine = null;
			Active = to == 0f;
		}
	}
	public class CameraLook : MonoBehaviour
	{
		[SerializeField]
		private Camera MainCamera;

		[SerializeField]
		private float delayMovementRatio;

		private void Awake()
		{
			MainCamera = Singleton<BilliardsDataContainer>.Instance.MainCamera.CurrentData;
			Singleton<BilliardsDataContainer>.Instance.MainCamera.OnDataChanged += LeftEyeCamera_OnDataChanged;
		}

		private void OnDestroy()
		{
			Singleton<BilliardsDataContainer>.Instance.MainCamera.OnDataChanged -= LeftEyeCamera_OnDataChanged;
		}

		private void LeftEyeCamera_OnDataChanged(Camera obj)
		{
			MainCamera = obj;
		}

		private void Update()
		{
			if ((object)MainCamera != null)
			{
				Vector3 position = MainCamera.transform.position;
				position.y = base.transform.position.y;
				Quaternion b = Quaternion.LookRotation(base.transform.position - position, Vector3.up);
				base.transform.localRotation = Quaternion.Lerp(base.transform.localRotation, b, 1f - delayMovementRatio);
			}
		}
	}
	public class CopyColor : MonoBehaviour
	{
		[SerializeField]
		private Graphic Origin;

		[SerializeField]
		private Graphic Destination;

		private void Update()
		{
			Destination.color = Origin.color;
		}
	}
	public class CueData : MonoBehaviour
	{
		public enum DataType
		{
			None,
			TableCenterTransform,
			TableCenterCameraSlot,
			StandardCameraSlot,
			LeftEye,
			CueBallCameraSlot,
			CueBallCameraRoot,
			StandardCueBallCameraSlot,
			WorldTempCameraSlot
		}

		[SerializeField]
		private DataType myType;

		private void OnEnable()
		{
			switch (myType)
			{
			case DataType.TableCenterTransform:
				Singleton<BilliardsDataContainer>.Instance.TableCameraCenter.CurrentData = base.transform;
				break;
			case DataType.TableCenterCameraSlot:
				Singleton<BilliardsDataContainer>.Instance.TableCameraSlot.CurrentData = base.transform;
				break;
			case DataType.StandardCameraSlot:
				Singleton<BilliardsDataContainer>.Instance.StandardCameraSlot.CurrentData = base.transform;
				break;
			case DataType.LeftEye:
				Singleton<BilliardsDataContainer>.Instance.MainCamera.CurrentData = GetComponent<Camera>();
				break;
			case DataType.CueBallCameraSlot:
				Singleton<BilliardsDataContainer>.Instance.CueBallCameraSlot.CurrentData = base.transform;
				break;
			case DataType.CueBallCameraRoot:
				Singleton<BilliardsDataContainer>.Instance.CueBallCameraRootFollower.CurrentData = GetComponent<FollowPosition>();
				break;
			case DataType.StandardCueBallCameraSlot:
				Singleton<BilliardsDataContainer>.Instance.StandardCueBallCameraSlot.CurrentData = base.transform;
				break;
			case DataType.WorldTempCameraSlot:
				Singleton<BilliardsDataContainer>.Instance.WorldTempCameraSlot.CurrentData = base.transform;
				break;
			case DataType.None:
				break;
			}
		}
	}
	public class CueMaterialSetter : MonoBehaviour
	{
		private enum MaterialType
		{
			WhiteTransparent,
			OriginalColor,
			OriginalTransparent,
			Transparent
		}

		[Serializable]
		public class CueMaterialPair
		{
			[SerializeField]
			public Material material_1;

			[SerializeField]
			public Material material_2;

			public Material[] ToArray()
			{
				return new Material[2] { material_1, material_2 };
			}
		}

		[SerializeField]
		private List<CueMaterialPair> cueMaterials = new List<CueMaterialPair>();

		[SerializeField]
		private Renderer CueRenderer;

		private ShotController.GameStateType currentState;

		private bool isNetworkControl
		{
			get
			{
				if (BallPoolGameLogic.playMode == BallPool.PlayMode.OnLine)
				{
					return !AightBallPoolPlayer.mainPlayer.myTurn;
				}
				return false;
			}
		}

		private void OnEnable()
		{
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.OpponentGameState.OnDataChangedDelta += OpponentGameState_OnDataChangedDelta;
			GameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
		}

		private void OpponentGameState_OnDataChangedDelta(ShotController.GameStateType prev, ShotController.GameStateType next)
		{
			if (isNetworkControl)
			{
				if (prev == ShotController.GameStateType.SetBallPosition)
				{
					CueRenderer.materials = cueMaterials[1].ToArray();
				}
				if (next == ShotController.GameStateType.SetBallPosition)
				{
					CueRenderer.materials = cueMaterials[3].ToArray();
				}
				else
				{
					CueRenderer.materials = cueMaterials[1].ToArray();
				}
			}
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			if (!isNetworkControl)
			{
				switch (obj)
				{
				case ShotController.GameStateType.SetBallPosition:
					CueRenderer.materials = cueMaterials[3].ToArray();
					break;
				case ShotController.GameStateType.WaitingForOpponent:
					CueRenderer.materials = cueMaterials[1].ToArray();
					break;
				case ShotController.GameStateType.Shot:
					CueRenderer.materials = cueMaterials[2].ToArray();
					break;
				default:
					CueRenderer.materials = cueMaterials[0].ToArray();
					break;
				case ShotController.GameStateType.SelectShotDirection:
				case ShotController.GameStateType.CameraFixAndWaitShot:
					break;
				}
				currentState = obj;
			}
		}

		private void Update()
		{
			switch (currentState)
			{
			case ShotController.GameStateType.SelectShotDirection:
				if (ShotController.SubHandController[InputHelpers.Button.Trigger].CurrentData)
				{
					CueRenderer.materials = cueMaterials[2].ToArray();
				}
				else
				{
					CueRenderer.materials = cueMaterials[0].ToArray();
				}
				break;
			case ShotController.GameStateType.CameraFixAndWaitShot:
				if (Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState[InputHelpers.Button.Trigger].CurrentData && Singleton<BilliardsDataContainer>.Instance.XRRightControllerState[InputHelpers.Button.Trigger].CurrentData && Singleton<BilliardsDataContainer>.Instance.AllowedSetCuePositionState.CurrentData)
				{
					CueRenderer.materials = cueMaterials[2].ToArray();
				}
				else
				{
					CueRenderer.materials = cueMaterials[1].ToArray();
				}
				break;
			}
		}

		private void OnDisable()
		{
			Singleton<BilliardsDataContainer>.Instance.OpponentGameState.OnDataChangedDelta -= OpponentGameState_OnDataChangedDelta;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
		}
	}
	public class FollowPosition : MonoBehaviour
	{
		[SerializeField]
		private Transform Target;

		public Vector3 TargetPosition => Target.position;

		private void FixedUpdate()
		{
			base.transform.position = Target.position;
		}

		public void ForceUpdate()
		{
			base.transform.position = Target.position;
		}
	}
	public class ScreenFadeInOut : MonoBehaviour
	{
		[SerializeField]
		private Image FadeImage;

		private void Awake()
		{
			Singleton<BilliardsDataContainer>.Instance.NormalizedFadeTime.OnDataChanged += NormalizedFadeValue_OnDataChanged;
		}

		private void NormalizedFadeValue_OnDataChanged(float obj)
		{
			Color color = FadeImage.color;
			color.a = obj;
			FadeImage.color = color;
		}

		private void OnDestroy()
		{
			Singleton<BilliardsDataContainer>.Instance.NormalizedFadeTime.OnDataChanged -= NormalizedFadeValue_OnDataChanged;
		}
	}
	public class SpotLightAngle : MonoBehaviour
	{
		[SerializeField]
		private Transform TargetPoint;

		[SerializeField]
		private Light SpotLight;

		private void Update()
		{
			float magnitude = (TargetPoint.position - SpotLight.transform.position).magnitude;
			SpotLight.range = magnitude + 0.02f;
			SpotLight.spotAngle = Mathf.Asin(0.008f / magnitude) * 57.29578f;
		}
	}
	public class UIBallInHand : InteractableButton
	{
		[SerializeField]
		private Transform Root;

		[SerializeField]
		private Transform DescriptionTransform;

		[SerializeField]
		private Text DescriptionText;

		[SerializeField]
		private Transform Cursor;

		[SerializeField]
		private AudioSource source;

		protected override void Awake()
		{
			base.Awake();
			onClick.AddListener(OnClick);
		}

		[Obsolete]
		private void OnClick()
		{
		}

		public void OnEnable()
		{
			Root.rotation = Quaternion.identity;
			StartCoroutine(WaitAndPlaySound());
		}

		private IEnumerator WaitAndPlaySound()
		{
			yield return new WaitForSeconds(0.1f);
			if (Singleton<BilliardsDataContainer>.Instance.isFoulVoicePlaying.CurrentData)
			{
				Singleton<BilliardsDataContainer>.Instance.isFoulVoicePlaying.OnDataChangedOnce += IsFoulVoicePlaying_OnDataChangedOnce;
			}
			else
			{
				source.Play();
			}
		}

		private void IsFoulVoicePlaying_OnDataChangedOnce(bool isPlaying)
		{
			if (!isPlaying)
			{
				source.Play();
			}
		}

		[Obsolete]
		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
		}

		protected override void OnDisable()
		{
			base.OnDisable();
		}

		public void Update()
		{
			Cursor.Rotate(Vector3.up, 3f, Space.Self);
			DescriptionTransform.localPosition = new Vector3(0f, Mathf.PingPong(Time.time * 100f, 200f) - 100f, 0f);
		}
	}
	[RequireComponent(typeof(Ball))]
	public class UIBallMarker : MonoBehaviour
	{
		[SerializeField]
		private Transform Root;

		[SerializeField]
		private Ball cachedBall;

		private bool isTarget;

		private int id => cachedBall.id;

		private void Awake()
		{
			if (cachedBall == null)
			{
				cachedBall = GetComponent<Ball>();
			}
			Root.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.TargetBallIds.OnDataChanged += TargetBallIds_OnDataChanged;
			if (AightBallPoolGameLogic.isCueBall(id))
			{
				Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChanged += CueSnapState_OnDataChanged;
			}
		}

		private void CueSnapState_OnDataChanged(bool isSnapped)
		{
			if (isSnapped)
			{
				Root.gameObject.SetActive(value: false);
			}
			else
			{
				GameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
			}
		}

		private void TargetBallIds_OnDataChanged(int totalData)
		{
			isTarget = Contains(totalData, id);
			GameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			switch (obj)
			{
			case ShotController.GameStateType.SetBallPosition:
				Root.gameObject.SetActive(isTarget);
				break;
			case ShotController.GameStateType.SelectShotDirection:
				if (AightBallPoolGameLogic.isCueBall(id))
				{
					Root.gameObject.SetActive(!Singleton<BilliardsDataContainer>.Instance.CueSnapState.CurrentData);
				}
				else
				{
					Root.gameObject.SetActive(isTarget);
				}
				break;
			case ShotController.GameStateType.CameraFixAndWaitShot:
				if (!AightBallPoolGameLogic.isCueBall(id))
				{
					Root.gameObject.SetActive(value: false);
				}
				break;
			}
		}

		private void OnDisable()
		{
			if (AightBallPoolGameLogic.isCueBall(id))
			{
				Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChanged -= CueSnapState_OnDataChanged;
			}
			Singleton<BilliardsDataContainer>.Instance.TargetBallIds.OnDataChanged -= TargetBallIds_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
		}

		private bool Contains(int value, int id)
		{
			return (value & (1 << id)) != 0;
		}
	}
	[Serializable]
	public class TutorialPair
	{
		public Transform TextAnchor;

		public List<Transform> ButtonAnchors;

		public List<LineRenderer> LineRenderers;

		public Text Desc;

		public void UpdateLineAlpha(float alpha)
		{
			using List<LineRenderer>.Enumerator enumerator = LineRenderers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Color startColor = enumerator.Current.startColor;
				startColor.a = alpha;
				enumerator.Current.startColor = startColor;
				startColor = enumerator.Current.endColor;
				startColor.a = alpha;
				enumerator.Current.endColor = startColor;
			}
		}

		public void UpdatePosition()
		{
			if (ButtonAnchors.Count != LineRenderers.Count)
			{
				UnityEngine.Debug.LogError("Count not matched");
				return;
			}
			for (int i = 0; i < ButtonAnchors.Count; i++)
			{
				LineRenderers[i].positionCount = 2;
				LineRenderers[i].SetPosition(0, TextAnchor.position);
				LineRenderers[i].SetPosition(1, ButtonAnchors[i].position);
			}
		}
	}
	public class UIControllerTutorial : MonoBehaviour
	{
		[SerializeField]
		private bool isLeft;

		[SerializeField]
		private bool isDummy;

		[Space]
		[SerializeField]
		private TutorialPair TriggerPair;

		[Space]
		[SerializeField]
		private TutorialPair TrackPadPair;

		[Space]
		[SerializeField]
		private TutorialPair GripPair;

		[Space]
		[SerializeField]
		private CanvasGroup canvasGroup;

		[SerializeField]
		private float OpenDelay = 5f;

		[SerializeField]
		private float OpenTime = 1f;

		private float uptime;

		private float lastUpdateTime;

		private float LastAlpha;

		private XRControllerState currentController
		{
			get
			{
				if (isLeft)
				{
					return Singleton<BilliardsDataContainer>.Instance.XRLeftControllerState;
				}
				return Singleton<BilliardsDataContainer>.Instance.XRRightControllerState;
			}
		}

		private void Awake()
		{
			if (!isDummy)
			{
				currentController.AngularVelocityNotifier.OnDataChanged += OnControllerMoved;
				currentController.VelocityNotifier.OnDataChanged += OnControllerMoved;
				Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
				currentController[InputHelpers.Button.Grip].OnDataChanged += UIControllerTutorial_OnDataChanged;
				currentController[InputHelpers.Button.Trigger].OnDataChanged += UIControllerTutorial_OnDataChanged;
				currentController[InputHelpers.Button.Primary2DAxisClick].OnDataChanged += UIControllerTutorial_OnDataChanged;
			}
			if (isLeft)
			{
				TrackPadPair.Desc.text = "Point and click on the table to <color=#F1964D>move to the end</color>";
			}
			else
			{
				TrackPadPair.Desc.text = "Click left and right to <color=#F1964D>rotate by ball</color>";
			}
		}

		private void UIControllerTutorial_OnDataChanged(bool obj)
		{
			lastUpdateTime = Time.time;
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			lastUpdateTime = Time.time;
		}

		private void OnControllerMoved(Vector3 obj)
		{
			if (obj.magnitude > 0.5f)
			{
				lastUpdateTime = Time.time;
			}
		}

		private void Update()
		{
			if (isDummy)
			{
				TriggerPair.UpdatePosition();
				TrackPadPair.UpdatePosition();
				GripPair.UpdatePosition();
				SetAlpha(1f);
				return;
			}
			if (Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData == ShotController.GameStateType.CameraFixAndWaitShot)
			{
				SetAlpha(0f);
				return;
			}
			float num = Time.time - lastUpdateTime;
			float num2 = 0f;
			num2 = ((!(num > OpenDelay)) ? (LastAlpha - Mathf.Clamp01(num / OpenTime)) : Mathf.Clamp01((num - OpenDelay) / OpenTime));
			SetAlpha(num2);
			if (num2 > 0f)
			{
				uptime += Time.deltaTime;
				TriggerPair.UpdatePosition();
				TrackPadPair.UpdatePosition();
				GripPair.UpdatePosition();
			}
			else if (uptime > 5f)
			{
				base.enabled = false;
			}
			LastAlpha = num2;
		}

		private void SetAlpha(float alpha)
		{
			canvasGroup.alpha = alpha;
			TriggerPair.UpdateLineAlpha(alpha);
			TrackPadPair.UpdateLineAlpha(alpha);
			GripPair.UpdateLineAlpha(alpha);
		}

		private void OnDestroy()
		{
			if (!isDummy)
			{
				currentController[InputHelpers.Button.Primary2DAxisClick].OnDataChanged -= UIControllerTutorial_OnDataChanged;
				currentController[InputHelpers.Button.Trigger].OnDataChanged -= UIControllerTutorial_OnDataChanged;
				currentController[InputHelpers.Button.Grip].OnDataChanged -= UIControllerTutorial_OnDataChanged;
				Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
				currentController.VelocityNotifier.OnDataChanged -= OnControllerMoved;
				currentController.AngularVelocityNotifier.OnDataChanged -= OnControllerMoved;
			}
		}
	}
	public class UIFoul : MonoBehaviour
	{
		[SerializeField]
		private GameObject root;

		[SerializeField]
		private PositionConstraint positionConstraint;

		[SerializeField]
		private AudioSource source;

		[SerializeField]
		private AudioClip foulClip_eng;

		[SerializeField]
		private AudioClip foulClip_chn;

		private CoroutineWrapper animationRoutine;

		private CoroutineWrapper waitRoutine;

		private void Awake()
		{
			AightBallPoolGameLogic.OnFoul += AightBallPoolGameLogic_OnFoul;
			AightBallPoolGameLogic.OnFoulWithDelay += AightBallPoolGameLogic_OnFoulWithDelay;
			animationRoutine = CoroutineWrapper.Generate(this);
			waitRoutine = CoroutineWrapper.Generate(this);
			root.SetActive(value: false);
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			if (PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese)
			{
				source.clip = foulClip_chn;
			}
			else
			{
				source.clip = foulClip_eng;
			}
		}

		private void AightBallPoolGameLogic_OnFoulWithDelay(AightBallPoolGameLogic.FoulType arg1, (BallListener, PocketListener) arg2, float arg3)
		{
			waitRoutine.Start(waitForDelay()).SetOnComplete(delegate
			{
				AightBallPoolGameLogic_OnFoul(arg1, arg2);
			});
			IEnumerator waitForDelay()
			{
				yield return new WaitForSeconds(arg3);
			}
		}

		private void AightBallPoolGameLogic_OnFoul(AightBallPoolGameLogic.FoulType type, (BallListener, PocketListener) info)
		{
			if (positionConstraint.sourceCount != 0)
			{
				while (positionConstraint.sourceCount > 0)
				{
					positionConstraint.RemoveSource(0);
				}
			}
			positionConstraint.AddSource(new ConstraintSource
			{
				sourceTransform = GetSourceTransform(),
				weight = 1f
			});
			source.Play();
			Singleton<BilliardsDataContainer>.Instance.isFoulVoicePlaying.CurrentData = true;
			StartCoroutine(WaitWhilePlay(source, delegate
			{
				Singleton<BilliardsDataContainer>.Instance.isFoulVoicePlaying.CurrentData = false;
			}));
			animationRoutine.StartSingleton(RunAnimation()).SetOnComplete(delegate
			{
				root.SetActive(value: false);
			});
			Transform GetSourceTransform()
			{
				return type switch
				{
					AightBallPoolGameLogic.FoulType.Scratch => info.Item2.transform, 
					AightBallPoolGameLogic.FoulType.BadHit => info.Item1.transform, 
					AightBallPoolGameLogic.FoulType.NoHit => info.Item1.transform, 
					AightBallPoolGameLogic.FoulType.WeakBreak => info.Item1.transform, 
					_ => null, 
				};
			}
			IEnumerator RunAnimation()
			{
				root.SetActive(value: true);
				yield return new WaitForSeconds(1.5f);
			}
		}

		private IEnumerator WaitWhilePlay(AudioSource target, Action onComplete)
		{
			yield return new WaitWhile(() => target.isPlaying);
			onComplete?.Invoke();
		}

		private void OnDestroy()
		{
			AightBallPoolGameLogic.OnFoulWithDelay -= AightBallPoolGameLogic_OnFoulWithDelay;
			AightBallPoolGameLogic.OnFoul -= AightBallPoolGameLogic_OnFoul;
		}
	}
	public class UIFreeBallCheck : MonoBehaviour
	{
		[SerializeField]
		private Transform Root;

		[SerializeField]
		private Transform DescriptionTransform;

		[SerializeField]
		private Text DescriptionText;

		[SerializeField]
		private Transform Cursor;

		[SerializeField]
		private MeshRenderer CheckerRenderer;

		public void OnEnable()
		{
			Root.rotation = Quaternion.identity;
			DescriptionText.text = GameSettingCtrl.GetLocalizationText("0087");
		}

		public void Update()
		{
			Cursor.Rotate(Vector3.up, 3f, Space.Self);
			DescriptionTransform.localPosition = new Vector3(0f, Mathf.PingPong(Time.time * 100f, 200f) - 100f, 0f);
		}

		public void SetInvalid()
		{
			DescriptionText.text = GameSettingCtrl.GetLocalizationText("0055");
			Color color = CheckerRenderer.material.color;
			color = Color.red * new Color(1f, 1f, 1f, color.a);
			CheckerRenderer.material.color = color;
		}

		public void SetValid()
		{
			DescriptionText.text = GameSettingCtrl.GetLocalizationText("0087");
			Color color = CheckerRenderer.material.color;
			color = Color.white * new Color(1f, 1f, 1f, color.a);
			CheckerRenderer.material.color = color;
		}
	}
	public class UIHelp : MonoBehaviour
	{
		[SerializeField]
		private Transform Root;

		[SerializeField]
		private RectTransform LayoutRoot;

		private void Awake()
		{
			if (BallPoolGameLogic.playMode != BallPool.PlayMode.OnLine)
			{
				Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
				Singleton<BilliardsDataContainer>.Instance.XRRightControllerState[InputHelpers.Button.MenuButton].OnDataChanged += ControllerBackButton_OnDataChanged;
			}
			Root.gameObject.SetActive(value: false);
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			switch (obj)
			{
			case ShotController.GameStateType.SelectShotDirection:
				Show();
				break;
			case ShotController.GameStateType.WaitingForOpponent:
				Close();
				break;
			case ShotController.GameStateType.CameraFixAndWaitShot:
				Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
				Close();
				break;
			case ShotController.GameStateType.MoveAroundTable:
			case ShotController.GameStateType.SetBallPosition:
				break;
			}
		}

		private void ControllerBackButton_OnDataChanged(bool isDown)
		{
			if (isDown && Root.gameObject.activeInHierarchy)
			{
				Close();
			}
		}

		public void Show()
		{
			Root.gameObject.SetActive(value: true);
			RebuildLayout();
			BallPoolGameManager.instance.OnShowHelp();
		}

		public void Close()
		{
			Root.gameObject.SetActive(value: false);
			BallPoolGameManager.instance.OnHideHelp();
		}

		private void OnDestroy()
		{
			Singleton<BilliardsDataContainer>.Instance.XRRightControllerState[InputHelpers.Button.MenuButton].OnDataChanged -= ControllerBackButton_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
		}

		private void RebuildLayout()
		{
			LayoutRebuilder.ForceRebuildLayoutImmediate(LayoutRoot);
			LayoutRebuilder.ForceRebuildLayoutImmediate(LayoutRoot);
			LayoutRebuilder.ForceRebuildLayoutImmediate(LayoutRoot);
		}
	}
	public class UIHitPoint : MonoBehaviour
	{
		[SerializeField]
		private SpriteRenderer spriteRenderer;

		[SerializeField]
		private Transform Cue;

		private float distance;

		private void Awake()
		{
			distance = Vector3.Distance(spriteRenderer.transform.position, base.transform.position);
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged += GameState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChanged += CueSnapState_OnDataChanged;
			GameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
		}

		private void CueSnapState_OnDataChanged(bool snap)
		{
			if (snap)
			{
				GameState_OnDataChanged(Singleton<BilliardsDataContainer>.Instance.GameState.CurrentData);
			}
			else
			{
				spriteRenderer.enabled = false;
			}
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			if ((uint)(obj - 3) <= 1u)
			{
				spriteRenderer.enabled = Singleton<BilliardsDataContainer>.Instance.CueSnapState.CurrentData;
			}
			else
			{
				spriteRenderer.enabled = false;
			}
		}

		private void Update()
		{
			distance = Vector3.Distance(spriteRenderer.transform.position, base.transform.position);
			Vector3 origin = Cue.position;
			Vector3 target = Cue.position - Cue.forward;
			Vector3 center = base.transform.position;
			Vector3 worldPosition = VectorExtension.IntersectionPoint(in origin, in target, in center, in distance);
			base.transform.LookAt(worldPosition);
		}

		private void OnDestroy()
		{
			Singleton<BilliardsDataContainer>.Instance.CueSnapState.OnDataChanged -= CueSnapState_OnDataChanged;
			Singleton<BilliardsDataContainer>.Instance.GameState.OnDataChanged -= GameState_OnDataChanged;
		}
	}
	[Serializable]
	public class DisplayPlayerInfo
	{
		private BallsUIManager ballsUIManager;

		public Text PlayerName;

		public List<Image> ballsImage;

		public List<Text> ballsText;

		public Image TurnImage;

		private BallPoolPlayer cachedData;

		public void Initialize(BallsUIManager manager)
		{
			ballsUIManager = manager;
			PlayerName.text = "NICKNAME";
			for (int i = 0; i < ballsImage.Count; i++)
			{
				ballsText[i].text = "";
				ballsImage[i].sprite = ballsUIManager.defaultBall;
				Color defaultColor = ballsUIManager.defaultColor;
				ballsImage[i].color = new Color(defaultColor.r, defaultColor.g, defaultColor.b);
			}
		}

		public void SetPlayer(BallPoolPlayer playerData)
		{
			cachedData = playerData;
			PlayerName.text = cachedData.name;
		}

		public void SetTurn(bool isOn)
		{
			Color color = TurnImage.color;
			color.a = (isOn ? 1f : 0.1f);
			TurnImage.color = color;
		}

		public void SetActiveBallsIds(BallPoolPlayer player)
		{
			string[] activeBallsIds = player.GetActiveBallsIds();
			if (activeBallsIds == null)
			{
				return;
			}
			for (int i = 0; i < ballsImage.Count; i++)
			{
				int num;
				if (i < activeBallsIds.Length)
				{
					ballsImage[i].transform.parent.gameObject.SetActive(value: true);
					num = int.Parse(activeBallsIds[i]);
					ballsText[i].text = string.Concat(num);
					if (player == null || !(player is AightBallPoolPlayer aightBallPoolPlayer))
					{
						goto IL_00c1;
					}
					if (aightBallPoolPlayer.isSolids)
					{
						ballsImage[i].sprite = ballsUIManager.solidsBall;
					}
					else
					{
						if (!AightBallPoolGameLogic.isBlackBall(num))
						{
							goto IL_00c1;
						}
						ballsImage[i].sprite = ballsUIManager.solidsBall;
					}
					goto IL_00dd;
				}
				ballsImage[i].transform.parent.gameObject.SetActive(value: false);
				continue;
				IL_00c1:
				ballsImage[i].sprite = ballsUIManager.stripesBall;
				goto IL_00dd;
				IL_00dd:
				Color color = ballsUIManager.ballsColors[num - 1];
				ballsImage[i].color = new Color(color.r, color.g, color.b);
			}
		}
	}
	public class UIIngameDisplay : MonoBehaviour
	{
		[SerializeField]
		private BallsUIManager ballsUIManager;

		[SerializeField]
		private RectTransform root;

		[SerializeField]
		private Text TitleText;

		[SerializeField]
		private DisplayPlayerInfo myInfo;

		[SerializeField]
		private DisplayPlayerInfo otherInfo;

		[SerializeField]
		private Text TurnTimeCounterText;

		[SerializeField]
		private PlayAgainMenu ResultMenu;

		public static UIIngameDisplay Instance;

		private static event Action<UIIngameDisplay> tempEvent;

		public static event Action<UIIngameDisplay> OnInitializedEvent
		{
			add
			{
				if (Instance != null)
				{
					value?.Invoke(Instance);
				}
				else
				{
					tempEvent += value;
				}
			}
			remove
			{
				tempEvent -= value;
			}
		}

		private void Awake()
		{
			if ((object)Instance != null)
			{
				UnityEngine.Debug.LogError($"Another instance is alreay exist. remove {typeof(UIIngameDisplay)} instance");
				UnityEngine.Object.Destroy(base.gameObject);
				return;
			}
			Instance = this;
			if (UIIngameDisplay.tempEvent != null)
			{
				UIIngameDisplay.tempEvent(this);
				UIIngameDisplay.tempEvent = null;
			}
			myInfo.Initialize(ballsUIManager);
			otherInfo.Initialize(ballsUIManager);
			RebuildLayout();
			ResultMenu.onActive += ResultMenu_onActive;
			ResultMenu.Hide();
			root.gameObject.SetActive(value: true);
		}

		private void ResultMenu_onActive(bool isActive)
		{
			root.gameObject.SetActive(!isActive);
			RebuildLayout();
		}

		private void RebuildLayout()
		{
			LayoutRebuilder.ForceRebuildLayoutImmediate(root);
			LayoutRebuilder.ForceRebuildLayoutImmediate(root);
			LayoutRebuilder.ForceRebuildLayoutImmediate(root);
		}

		public void SetAvatar(AightBallPoolPlayer player)
		{
		}

		public void SetPlayer(BallPoolPlayer player)
		{
			((player.playerId == 0) ? myInfo : otherInfo).SetPlayer(player);
			RebuildLayout();
		}

		public void SetActiveBallsIds(BallPoolPlayer player)
		{
			if (player.playerId == 0)
			{
				string[] activeBallsIds = player.GetActiveBallsIds();
				if (activeBallsIds == null)
				{
					return;
				}
				int num = 0;
				for (int i = 0; i < activeBallsIds.Length; i++)
				{
					int num2 = int.Parse(activeBallsIds[i]);
					num |= 1 << num2;
				}
				Singleton<BilliardsDataContainer>.Instance.TargetBallIds.CurrentData = num;
			}
			((player.playerId == 0) ? myInfo : otherInfo).SetActiveBallsIds(player);
			RebuildLayout();
		}

		public void SetTurn(int idx, bool value)
		{
			if (idx == 0)
			{
				myInfo.SetTurn(value);
			}
			else
			{
				otherInfo.SetTurn(value);
			}
			RebuildLayout();
		}

		public void SetTime(float timeRaio)
		{
			TurnTimeCounterText.text = Mathf.FloorToInt(Mathf.Lerp(50f, 0f, timeRaio)).ToString();
		}

		private void OnDestroy()
		{
			Instance = null;
		}
	}
	public class UIPause : MonoBehaviour
	{
		[SerializeField]
		private Transform Root;

		[SerializeField]
		private RectTransform LayoutRoot;

		[SerializeField]
		private GameUIController controller;

		private void Awake()
		{
			Root.gameObject.SetActive(value: false);
		}

		private void ControllerBackButton_OnDataChanged(bool isDown)
		{
			if (isDown && !Root.gameObject.activeInHierarchy)
			{
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Mouse1) || Input.GetButtonDown("Right Menu") || Input.GetButtonDown("Left Menu"))
			{
				ControllerBackButton_OnDataChanged(isDown: true);
			}
		}

		public void Show()
		{
			if (BallPoolGameLogic.playMode != BallPool.PlayMode.OnLine)
			{
				Time.timeScale = 0f;
				SoundManager.Pause(isPause: true);
			}
			Vector3 vector = Singleton<BilliardsDataContainer>.Instance.MainCamera.CurrentData.transform.position;
			Vector2 vector2 = vector.ToXZ();
			Vector3 vector3 = Singleton<BilliardsDataContainer>.Instance.CueBallCameraRootFollower.CurrentData.TargetPosition;
			Vector2 vector4 = (vector2 - vector3.ToXZ()).normalized * 0.2f;
			Transform obj = base.transform;
			vector = Singleton<BilliardsDataContainer>.Instance.CueBallCameraRootFollower.CurrentData.TargetPosition;
			Vector2 xzVector = vector.ToXZ() + vector4;
			obj.position = xzVector.ToVector3FromXZ(0.15f);
			Root.gameObject.SetActive(value: true);
			RebuildLayout();
		}

		public void OnClickGoHome()
		{
			controller.ForceGoHome();
			Close();
		}

		public void Close()
		{
			if (Time.timeScale != 1f)
			{
				Time.timeScale = 1f;
				SoundManager.Pause(isPause: true);
			}
			Root.gameObject.SetActive(value: false);
		}

		private void OnDestroy()
		{
		}

		private void RebuildLayout()
		{
			try
			{
				LayoutRebuilder.ForceRebuildLayoutImmediate(LayoutRoot);
				LayoutRebuilder.ForceRebuildLayoutImmediate(LayoutRoot);
				LayoutRebuilder.ForceRebuildLayoutImmediate(LayoutRoot);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("Exception in LayoutRebuilder.  " + ex.Message + ex.StackTrace);
				UnityEngine.Debug.Log("LayoutRoot is " + LayoutRoot);
			}
		}
	}
	[Obsolete]
	public class UISubCameraView : MonoBehaviour
	{
		public enum HitType
		{
			None,
			Ball,
			Table
		}

		[SerializeField]
		private RectTransform RenderTextureRoot;

		[SerializeField]
		private Canvas RenderCanvas;

		[SerializeField]
		private Camera RenderCamera;

		[SerializeField]
		private float openTime;

		private bool IsBallHit;

		private RaycastHit CurrentHitInfo;

		private bool AllowedShow;

		private Coroutine OpenRoutine;

		private Coroutine CloseRoutine;

		private float TargetRenderTextureRootScale;

		private static readonly string BALL = "Ball";

		private static readonly string LINE = "Line";

		private void Awake()
		{
			RenderCamera.orthographicSize = 1.6f;
			RenderCanvas.gameObject.SetActive(value: false);
		}

		private void GameState_OnDataChanged(ShotController.GameStateType obj)
		{
			switch (obj)
			{
			case ShotController.GameStateType.WaitingForOpponent:
			case ShotController.GameStateType.MoveAroundTable:
			case ShotController.GameStateType.SetBallPosition:
				AllowedShow = false;
				Close();
				break;
			case ShotController.GameStateType.SelectShotDirection:
				AllowedShow = true;
				Show();
				break;
			case ShotController.GameStateType.CameraFixAndWaitShot:
				AllowedShow = false;
				Close();
				break;
			case ShotController.GameStateType.Shot:
				AllowedShow = false;
				Close();
				break;
			}
		}

		public void OnHitChanged(RaycastHit current)
		{
			if (current.transform == null)
			{
				return;
			}
			if (!AllowedShow)
			{
				CurrentHitInfo = current;
				return;
			}
			if (current.transform.name.Contains(BALL))
			{
				IsBallHit = true;
			}
			else
			{
				if (!current.transform.name.Contains(LINE))
				{
					Close();
					return;
				}
				IsBallHit = false;
			}
			Transform transform = CurrentHitInfo.transform;
			CurrentHitInfo = current;
			if (current.transform != transform)
			{
				Show();
			}
		}

		public void Show()
		{
			if (!(CurrentHitInfo.transform == null))
			{
				if (CurrentHitInfo.transform.name.Contains(BALL))
				{
					IsBallHit = true;
				}
				else if (CurrentHitInfo.transform.name.Contains(LINE))
				{
					IsBallHit = false;
				}
				if (CloseRoutine != null)
				{
					StopCoroutine(CloseRoutine);
				}
				if (OpenRoutine != null)
				{
					StopCoroutine(OpenRoutine);
				}
				OpenRoutine = StartCoroutine(OpenInternal());
			}
		}

		private IEnumerator OpenInternal()
		{
			if (IsBallHit)
			{
				InitializeSubScreen(CurrentHitInfo.transform, Vector3.zero, 0.2f);
			}
			else
			{
				InitializeSubScreen(null, CurrentHitInfo.point, 0f);
			}
			float t = 0f;
			Vector3 startScale = new Vector3(0.04f, 0.04f, 1f);
			Vector3 middleScale = new Vector3(1f, 0.1f, 1f) * TargetRenderTextureRootScale;
			while (t < openTime * 0.5f)
			{
				RenderTextureRoot.transform.localScale = Vector3.Lerp(startScale, middleScale, t / (openTime * 0.5f));
				t += Time.deltaTime;
				yield return null;
			}
			while (t < openTime)
			{
				RenderTextureRoot.transform.localScale = Vector3.Lerp(middleScale, Vector3.one * TargetRenderTextureRootScale, (t - openTime * 0.5f) / (openTime * 0.5f));
				t += Time.deltaTime;
				yield return null;
			}
			RenderTextureRoot.transform.localScale = Vector3.one * TargetRenderTextureRootScale;
			OpenRoutine = null;
		}

		private void InitializeSubScreen(Transform parent, Vector3 canvasLocalPosition, float RenderCameraAdditionalPosition)
		{
			RenderCanvas.transform.SetParent(parent, worldPositionStays: false);
			RenderCanvas.transform.localPosition = canvasLocalPosition;
			Vector3 vector = CurrentHitInfo.transform.position - Singleton<BilliardsDataContainer>.Instance.MainCamera.CurrentData.transform.position;
			Vector2 xzVector = vector.ToXZ();
			RenderCanvas.gameObject.SetActive(value: true);
			RenderCamera.transform.localEulerAngles = new Vector3(RenderCamera.transform.localEulerAngles.x, 0f, Vector2.SignedAngle(Vector2.up, xzVector));
			RenderCamera.transform.position = RenderCanvas.transform.position + Vector3.up + xzVector.ToVector3FromXZ().normalized * RenderCameraAdditionalPosition;
			float num = (TargetRenderTextureRootScale = GetSizeFormMagnitude(xzVector.magnitude));
			RenderTextureRoot.localPosition = new Vector2(0f, 800f * (1f - (num - 1f) * 0.5f));
		}

		public void Close()
		{
			if (OpenRoutine != null)
			{
				StopCoroutine(OpenRoutine);
			}
			if (CloseRoutine != null)
			{
				StopCoroutine(CloseRoutine);
			}
			CloseRoutine = StartCoroutine(CloseInternal());
		}

		private IEnumerator CloseInternal()
		{
			float t = 0f;
			Vector3 defaultScale = RenderTextureRoot.transform.localScale;
			Vector3 startScale = new Vector3(0.04f, 0.04f, 1f);
			Vector3 middleScale = new Vector3(1f, 0.1f, 1f) * TargetRenderTextureRootScale;
			while (t < openTime * 0.5f)
			{
				RenderTextureRoot.transform.localScale = Vector3.Lerp(defaultScale, middleScale, t / (openTime * 0.5f));
				t += Time.deltaTime;
				yield return null;
			}
			while (t < openTime)
			{
				RenderTextureRoot.transform.localScale = Vector3.Lerp(middleScale, startScale, (t - openTime * 0.5f) / (openTime * 0.5f));
				t += Time.deltaTime;
				yield return null;
			}
			RenderCanvas.gameObject.SetActive(value: false);
			CloseRoutine = null;
		}

		private float GetSizeFormMagnitude(float directionMagnitude)
		{
			return 1f + Mathf.Clamp((directionMagnitude - 1f) * 0.33f, 0f, 1f);
		}

		private void OnDestroy()
		{
		}
	}
	[Serializable]
	[Obsolete]
	public class GraphicRaycasterDict
	{
		public List<Canvas> Keylist;

		public Dictionary<Canvas, GraphicRaycaster> Dict;

		public GraphicRaycaster this[int index]
		{
			get
			{
				return Dict[Keylist[index]];
			}
			set
			{
				Dict[Keylist[index]] = value;
			}
		}

		public GraphicRaycasterDict()
		{
			Keylist = new List<Canvas>();
			Dict = new Dictionary<Canvas, GraphicRaycaster>();
		}
	}
	[Obsolete("NotUse. use in PICO", true)]
	public class UI_PointerManager : MonoBehaviour
	{
		public enum PointerState
		{
			All,
			Swap,
			Hide
		}

		[Serializable]
		[SerializeField]
		private class PointerData
		{
			public GameObject pose;

			public GameObject pointer_ball;

			public GameObject pointer_line;

			public GameObject previousContact;

			public GameObject pushContact;

			public GameObject dragContact;

			public bool isPress;

			public bool isSelectOut;

			public bool isDrag;

			public int index_lastCanvas;

			public Vector3 pressStartDir = Vector3.forward;
		}

		public static UI_PointerManager instance;

		public PointerState state;

		private PointerState current_state;

		public GameObject[] poses = new GameObject[1];

		public Camera camera;

		public GraphicRaycasterDict grs;

		private PointerEventData ped;

		private PointerData[] pointerDatas;

		public Color color = Color.white;

		public float thickness = 0.002f;

		public Color clickColor = Color.green;

		public Shader shader_ball;

		public float dragThreshold = 0.001f;

		public bool isMainCollder;

		private int current_cotroller_num;

		public GameObject selectContact;

		public List<Canvas> ui_canvas
		{
			get
			{
				return grs.Keylist;
			}
			set
			{
				grs.Keylist = value;
			}
		}

		public Dictionary<Canvas, GraphicRaycaster> graphicRaycasterDict
		{
			get
			{
				return grs.Dict;
			}
			set
			{
				grs.Dict = value;
			}
		}

		private static event Action<UI_PointerManager> onInitialized;

		public static event Action<UI_PointerManager> OnInitialized
		{
			add
			{
				if (instance != null)
				{
					value?.Invoke(instance);
				}
				else
				{
					onInitialized += value;
				}
			}
			remove
			{
				onInitialized -= value;
			}
		}

		private void Awake()
		{
		}

		private void SetCamera(Camera cam)
		{
		}

		private void Start()
		{
		}

		public void AddCanvas(Canvas canvas)
		{
		}

		private void Update()
		{
		}

		private void CheckChangeState()
		{
		}

		private void CheckUIPointer()
		{
		}

		public void SetEvent(int index_canvas, int index_pointer, Vector3 endPos)
		{
		}

		public void PointerEnter(GameObject target)
		{
		}

		public void PointerExit(GameObject target)
		{
		}

		public void PointerDown(GameObject target, PointerEventData m_ped)
		{
		}

		public void PointerUp(GameObject target)
		{
		}

		public void PointerClick(GameObject target)
		{
		}

		public GameObject GetDrag(GameObject target, PointerEventData m_ped)
		{
			return null;
		}

		public void BeginDrag(GameObject target, PointerEventData m_ped)
		{
		}

		public void Drag(GameObject target, PointerEventData m_ped)
		{
		}

		public void EndDrag(GameObject target, PointerEventData m_ped)
		{
		}

		public void SetState(PointerState setState)
		{
		}

		public void SetSelectedGameObject(GameObject target)
		{
			ISelectHandler[] components = target.GetComponents<ISelectHandler>();
			if (selectContact != null)
			{
				IDeselectHandler[] components2 = selectContact.GetComponents<IDeselectHandler>();
				for (int i = 0; i < components2.Length; i++)
				{
					components2[i].OnDeselect(new PointerEventData(null));
				}
			}
			if (components.Length >= 1)
			{
				selectContact = target;
				for (int j = 0; j < components.Length; j++)
				{
					components[j].OnSelect(new PointerEventData(null));
				}
			}
		}

		public void DeselectButton()
		{
			StartCoroutine(initSelectContact());
		}

		private IEnumerator initSelectContact()
		{
			yield return new WaitForSeconds(0.5f);
			selectContact = null;
		}
	}
	[Obsolete("NotUse. use in PICO", true)]
	public class UI_RegisterCanvas : MonoBehaviour
	{
		[SerializeField]
		private Canvas canvas;
	}
}
namespace Jisu.Utils
{
	public static class EventExtension
	{
	}
	public static class CollectionExtension
	{
		public static T GetRandom<T>(this List<T> list)
		{
			return list[UnityEngine.Random.Range(0, list.Count)];
		}

		public static T GetRandom<T>(this List<T> list, Predicate<T> pred)
		{
			return list.Where(pred.Invoke).ToList()[UnityEngine.Random.Range(0, list.Count)];
		}
	}
	public static class ColliderExtension
	{
		public static bool ComputePenetration(this Collider staticCollider, Collider dynamicCollider, in Vector3 worldOffset, out Vector3 dir, out float dis)
		{
			return Physics.ComputePenetration(dynamicCollider, dynamicCollider.transform.position + worldOffset, dynamicCollider.transform.rotation, staticCollider, staticCollider.transform.position, staticCollider.transform.rotation, out dir, out dis);
		}

		public static bool ComputePenetration(this Collider staticCollider, Collider dynamicCollider, out Vector3 dir, out float dis)
		{
			return Physics.ComputePenetration(dynamicCollider, dynamicCollider.transform.position, dynamicCollider.transform.rotation, staticCollider, staticCollider.transform.position, staticCollider.transform.rotation, out dir, out dis);
		}
	}
	public static class ColorExtension
	{
		public static Vector3 ConvertRgbToHsv(double r, double b, double g)
		{
			double num = 0.0;
			double num2 = Math.Min(Math.Min(r, g), b);
			double num3 = Math.Max(Math.Max(r, g), b);
			double num4 = num3 - num2;
			double num5 = ((!num3.Equals(0.0)) ? (num4 / num3) : 0.0);
			if (num5.Equals(0.0))
			{
				num = 360.0;
			}
			else
			{
				if (r.Equals(num3))
				{
					num = (g - b) / num4;
				}
				else if (g.Equals(num3))
				{
					num = 2.0 + (b - r) / num4;
				}
				else if (b.Equals(num3))
				{
					num = 4.0 + (r - g) / num4;
				}
				num *= 60.0;
				if (num <= 0.0)
				{
					num += 360.0;
				}
			}
			Vector3 result = default(Vector3);
			result.x = (float)(360.0 - num);
			result.y = (float)num5;
			result.z = (float)(num3 / 255.0);
			return result;
		}

		public static Color ConvertHsvToRgb(double h, double s, double v, float alpha)
		{
			double num;
			double num2;
			double num3;
			if (s.Equals(0.0))
			{
				num = v;
				num2 = v;
				num3 = v;
			}
			else
			{
				h = ((!h.Equals(360.0)) ? (h / 60.0) : 0.0);
				int num4 = (int)h;
				double num5 = h - (double)num4;
				double num6 = v * (1.0 - s);
				double num7 = v * (1.0 - s * num5);
				double num8 = v * (1.0 - s * (1.0 - num5));
				switch (num4)
				{
				case 0:
					num = v;
					num2 = num8;
					num3 = num6;
					break;
				case 1:
					num = num7;
					num2 = v;
					num3 = num6;
					break;
				case 2:
					num = num6;
					num2 = v;
					num3 = num8;
					break;
				case 3:
					num = num6;
					num2 = num7;
					num3 = v;
					break;
				case 4:
					num = num8;
					num2 = num6;
					num3 = v;
					break;
				default:
					num = v;
					num2 = num6;
					num3 = num7;
					break;
				}
			}
			return new Color((float)num, (float)num2, (float)num3, alpha);
		}
	}
	internal static class YieldInstructionCache
	{
		private class FloatComparer : IEqualityComparer<float>
		{
			bool IEqualityComparer<float>.Equals(float x, float y)
			{
				return x == y;
			}

			int IEqualityComparer<float>.GetHashCode(float obj)
			{
				return obj.GetHashCode();
			}
		}

		public static readonly WaitForEndOfFrame WaitForEndOfFrame = new WaitForEndOfFrame();

		public static readonly WaitForFixedUpdate WaitForFixedUpdate = new WaitForFixedUpdate();

		private static readonly Dictionary<float, WaitForSeconds> _timeInterval = new Dictionary<float, WaitForSeconds>(new FloatComparer());

		private static readonly Dictionary<float, WaitForSecondsRealtime> _realtimeInterval = new Dictionary<float, WaitForSecondsRealtime>(new FloatComparer());

		public static WaitForSeconds WaitForSeconds(float seconds)
		{
			if (!_timeInterval.TryGetValue(seconds, out var value))
			{
				_timeInterval.Add(seconds, value = new WaitForSeconds(seconds));
			}
			return value;
		}

		public static WaitForSecondsRealtime WaitForSecondsRealtime(float seconds)
		{
			if (!_realtimeInterval.TryGetValue(seconds, out var value))
			{
				_realtimeInterval.Add(seconds, value = new WaitForSecondsRealtime(seconds));
			}
			return value;
		}
	}
	public static class CoroutineExtension
	{
		public static IEnumerator WaitforTimeWhileCondition(this MonoBehaviour runner, float time, Func<bool> condition, Action<bool> onComplete = null)
		{
			bool passed = false;
			bool timeOver = false;
			runner.StartCoroutine(WaitForTime(time, delegate
			{
				passed = true;
				timeOver = true;
			}));
			runner.StartCoroutine(WaitWhileCondition(condition, delegate
			{
				passed = true;
			}));
			yield return new WaitUntil(() => passed);
			onComplete?.Invoke(!timeOver);
		}

		private static IEnumerator WaitForTime(float time, Action onComplete)
		{
			yield return YieldInstructionCache.WaitForSeconds(time);
			onComplete?.Invoke();
		}

		private static IEnumerator WaitWhileCondition(Func<bool> condition, Action onComplete)
		{
			yield return new WaitWhile(condition);
			onComplete?.Invoke();
		}

		public static IEnumerator Easy(float runtime, Action<float> onUpdate)
		{
			float t = 0f;
			while (t < runtime)
			{
				onUpdate?.Invoke(t / runtime);
				t += Time.deltaTime;
				yield return null;
			}
			onUpdate?.Invoke(1f);
		}
	}
	public class CoroutineWrapper
	{
		private IEnumerator Target;

		public MonoBehaviour Runner { get; private set; }

		public Coroutine Routine { get; private set; }

		public bool IsPlaying => Routine != null;

		public event Action<bool> OnCompleteOnce;

		public static CoroutineWrapper Generate(MonoBehaviour runner)
		{
			return new CoroutineWrapper(runner);
		}

		public CoroutineWrapper(MonoBehaviour runner)
		{
			Runner = runner;
		}

		public CoroutineWrapper Start(IEnumerator target)
		{
			Target = target;
			Runner.StartCoroutine(RunTarget());
			return this;
		}

		public CoroutineWrapper StartSingleton(IEnumerator target)
		{
			if (Routine != null)
			{
				Stop();
			}
			return Start(target);
		}

		public CoroutineWrapper SetOnComplete(Action<bool> onComplete)
		{
			OnCompleteOnce += onComplete;
			return this;
		}

		private IEnumerator RunTarget()
		{
			Routine = Runner.StartCoroutine(Target);
			yield return Routine;
			Routine = null;
			this.OnCompleteOnce?.Invoke(obj: true);
			this.OnCompleteOnce = null;
		}

		public void Stop()
		{
			if (Routine != null)
			{
				Runner.StopCoroutine(Routine);
				Routine = null;
				this.OnCompleteOnce?.Invoke(obj: false);
				this.OnCompleteOnce = null;
			}
		}
	}
	public class InfiniteLoopDetector
	{
		private static string prevPoint = "";

		private static int detectionCount = 0;

		private const int DetectionThreshold = 100000;

		[Conditional("UNITY_EDITOR")]
		public static void Run([CallerMemberName] string mn = "", [CallerFilePath] string fp = "", [CallerLineNumber] int ln = 0)
		{
			string text = $"{fp}:{ln}, {mn}()";
			if (prevPoint == text)
			{
				detectionCount++;
			}
			else
			{
				detectionCount = 0;
			}
			if (detectionCount > 100000)
			{
				throw new Exception("Infinite Loop Detected: \n" + text + "\n\n");
			}
			prevPoint = text;
		}
	}
	public interface INotifiable<T>
	{
		T CurrentData { get; set; }

		event Action<T> OnDataChanged;

		event Action<T> OnDataChangedOnce;

		event Action<T, T> OnDataChangedDelta;
	}
	public static class NotifierExtension
	{
		public static void AddClampedValue(this Notifier<int> notifier, int value, int min, int max)
		{
			notifier.CurrentData = Mathf.Clamp(notifier.CurrentData + value, min, max);
		}

		public static void AddClampedValue(this Notifier<float> notifier, float value, float min, float max)
		{
			notifier.CurrentData = Mathf.Clamp(notifier.CurrentData + value, min, max);
		}
	}
	public class NotifierClass<T> : INotifiable<T> where T : class
	{
		public bool isEnabled;

		private T currentData;

		public T CurrentData
		{
			get
			{
				return currentData;
			}
			set
			{
				if (currentData == null || !currentData.Equals(value))
				{
					if (isEnabled)
					{
						T arg = currentData;
						currentData = value;
						this.OnDataChanged?.Invoke(currentData);
						this.OnDataChangedOnce?.Invoke(currentData);
						this.OnDataChangedDelta?.Invoke(arg, currentData);
						this.OnDataChangedOnce = null;
					}
					else
					{
						currentData = value;
					}
				}
			}
		}

		public bool IsSubscribed
		{
			get
			{
				if (this.OnDataChanged == null || this.OnDataChanged.GetInvocationList().Length == 0)
				{
					if (this.OnDataChangedOnce != null)
					{
						return this.OnDataChangedOnce.GetInvocationList().Length != 0;
					}
					return false;
				}
				return true;
			}
		}

		public event Action<T> OnDataChanged;

		public event Action<T> OnDataChangedOnce;

		public event Action<T, T> OnDataChangedDelta;

		public NotifierClass()
		{
			isEnabled = true;
		}
	}
	public class Notifier<T> : INotifiable<T> where T : struct
	{
		public bool isEnabled;

		private T currentData;

		public T CurrentData
		{
			get
			{
				return currentData;
			}
			set
			{
				if (!EqualityComparer<T>.Default.Equals(currentData, value))
				{
					if (isEnabled)
					{
						T arg = currentData;
						currentData = value;
						this.OnDataChanged?.Invoke(currentData);
						this.OnDataChangedOnce?.Invoke(currentData);
						this.OnDataChangedDelta?.Invoke(arg, currentData);
						this.OnDataChangedOnce = null;
					}
					else
					{
						currentData = value;
					}
				}
			}
		}

		public bool IsSubscribed
		{
			get
			{
				if (this.OnDataChanged == null || this.OnDataChanged.GetInvocationList().Length == 0)
				{
					if (this.OnDataChangedOnce != null)
					{
						return this.OnDataChangedOnce.GetInvocationList().Length != 0;
					}
					return false;
				}
				return true;
			}
		}

		public event Action<T> OnDataChanged;

		public event Action<T> OnDataChangedOnce;

		public event Action<T, T> OnDataChangedDelta;

		public Notifier()
		{
			isEnabled = true;
		}
	}
	public class RuntimeLogManager : LocalSingleton<RuntimeLogManager>
	{
		[Serializable]
		public class RuntimeLog
		{
			public TextMesh text;

			public float stringLength;

			public List<string> logs;

			public void Init()
			{
				logs = new List<string>();
			}

			public void SetLog(in string str)
			{
				UnityEngine.Debug.Log(str);
				if ((float)logs.Count >= stringLength)
				{
					logs.RemoveAt(0);
				}
				logs.Add(str + "\n");
				StringBuilder stringBuilder = new StringBuilder();
				foreach (string log in logs)
				{
					stringBuilder.Append(log);
				}
				text.text = stringBuilder.ToString();
			}
		}

		[SerializeField]
		private RuntimeLog[] runtimeLogs;

		protected override void Awake()
		{
			base.Awake();
			for (int i = 0; i < runtimeLogs.Length; i++)
			{
				runtimeLogs[i].Init();
			}
		}

		public static void Notify(in int index, in string str)
		{
			if (!(LocalSingleton<RuntimeLogManager>.Instance == null))
			{
				LocalSingleton<RuntimeLogManager>.Instance.runtimeLogs[index].SetLog(in str);
			}
		}
	}
	public class ShowFPS : MonoBehaviour
	{
		private TextMesh fpsText;

		private float deltaTime;

		private float FPS;

		private float minFPS;

		private float intvlMinFPS;

		private bool isMinFPS;

		private void Awake()
		{
			fpsText = GetComponent<TextMesh>();
			deltaTime = 0f;
			minFPS = 72.5f;
			intvlMinFPS = 0f;
			isMinFPS = false;
		}

		private void Update()
		{
			deltaTime += (Time.deltaTime - deltaTime) * 0.1f;
			FPS = 1f / deltaTime;
			if (FPS < minFPS)
			{
				isMinFPS = true;
				minFPS = FPS;
			}
			if (isMinFPS)
			{
				intvlMinFPS += Time.deltaTime;
				if (intvlMinFPS > 3f)
				{
					minFPS = 72.5f;
					intvlMinFPS = 0f;
					isMinFPS = false;
				}
			}
			fpsText.text = $"FPS : {Mathf.Ceil(FPS)}\nMin : {Mathf.Ceil(minFPS)}\n";
		}
	}
	public abstract class Singleton<T> where T : Singleton<T>, new()
	{
		private static readonly Lazy<T> instance = new Lazy<T>(() => new T());

		public static T Instance => instance.Value;
	}
	public class LocalSingleton<T> : MonoBehaviour where T : LocalSingleton<T>
	{
		protected static T _instance;

		public static T Instance => _instance;

		private static event Action<T> onInitialized;

		public static event Action<T> OnInitialized
		{
			add
			{
				if (_instance != null)
				{
					value?.Invoke(_instance);
				}
				else
				{
					onInitialized += value;
				}
			}
			remove
			{
				onInitialized -= value;
			}
		}

		protected virtual void Awake()
		{
			if (_instance == null)
			{
				_instance = this as T;
				LocalSingleton<T>.onInitialized?.Invoke(_instance);
				LocalSingleton<T>.onInitialized = null;
			}
			else if (_instance != this)
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
		}

		protected virtual void OnDestroy()
		{
			if (_instance == this)
			{
				_instance = null;
			}
		}

		public static bool TryGetInstance(out T instance)
		{
			instance = _instance;
			return instance != null;
		}
	}
	public class MonoSingleton<T> : MonoBehaviour where T : MonoSingleton<T>
	{
		protected static T _instance;

		private static object _lock = new object();

		private static bool applicationIsQuitting = false;

		public static T Instance
		{
			get
			{
				if (applicationIsQuitting)
				{
					UnityEngine.Debug.LogWarning(string.Concat("[Singleton] Instance '", typeof(T), "' already destroyed on application quit. Won't create again - returning null."));
					return null;
				}
				lock (_lock)
				{
					if (_instance == null)
					{
						_instance = (T)UnityEngine.Object.FindObjectOfType(typeof(T));
						if (UnityEngine.Object.FindObjectsOfType(typeof(T)).Length > 1)
						{
							UnityEngine.Debug.LogError("[Singleton] Something went really wrong  - there should never be more than 1 singleton! Reopening the scene might fix it.");
							return _instance;
						}
						if (_instance == null)
						{
							GameObject gameObject = new GameObject();
							_instance = gameObject.AddComponent<T>();
							gameObject.name = "(singleton) " + typeof(T).ToString();
							UnityEngine.Object.DontDestroyOnLoad(gameObject);
							UnityEngine.Debug.Log(string.Concat("[Singleton] An instance of ", typeof(T), " is needed in the scene, so '", gameObject, "' was created with DontDestroyOnLoad."));
						}
						else
						{
							UnityEngine.Debug.Log("[Singleton] Using instance already created: " + _instance.gameObject.name);
						}
					}
					return _instance;
				}
			}
		}

		private static event Action<T> onInitialized;

		public static event Action<T> OnInitialized
		{
			add
			{
				if (_instance != null)
				{
					value?.Invoke(_instance);
				}
				else
				{
					onInitialized += value;
				}
			}
			remove
			{
				onInitialized -= value;
			}
		}

		public virtual void OnDestroy()
		{
			if (_instance == this)
			{
				applicationIsQuitting = true;
			}
		}

		public virtual void OnApplicationQuit()
		{
			applicationIsQuitting = true;
		}

		protected virtual void Awake()
		{
			if (_instance == null)
			{
				_instance = this as T;
				UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				MonoSingleton<T>.onInitialized?.Invoke(_instance);
				MonoSingleton<T>.onInitialized = null;
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
		}
	}
	public static class UIExtension
	{
		public static PointerEventData Clone(this PointerEventData ped)
		{
			return new PointerEventData(EventSystem.current)
			{
				position = ped.position,
				delta = ped.delta,
				clickTime = ped.clickTime,
				clickCount = ped.clickCount
			};
		}

		public static Vector2 WorldToScreen(this Vector3 position)
		{
			return Camera.main.WorldToScreenPoint(position);
		}

		public static Vector2 WorldToCanvas(this Vector3 position, RectTransform canvasTransform)
		{
			Vector3 vector = Camera.main.WorldToScreenPoint(position);
			return vector.ToVector2().ScreenToCanvas(canvasTransform);
		}

		public static Vector2 ScreenToCanvas(this Vector2 position, RectTransform canvasTransform)
		{
			return (position - new Vector2(Screen.width, Screen.height) * 0.5f) * new Vector2(canvasTransform.rect.width / (float)Screen.width, canvasTransform.rect.height / (float)Screen.height);
		}

		public static Vector3 ScreenToWorld(this Vector2 pos, Vector3 targetPosition, RectTransform canvasTransform)
		{
			Vector3 position = Camera.main.transform.position;
			Vector3 vector = canvasTransform.TransformPoint(pos);
			return new Vector3((vector.x - position.x) * (targetPosition.z - position.z) / (vector.z - position.z) + position.x, (vector.y - position.y) * (targetPosition.z - position.z) / (vector.z - position.z) + position.y, targetPosition.z);
		}

		public static Vector2 CanvasToScreen(this Vector2 position, RectTransform canvasTransform)
		{
			position /= new Vector2(canvasTransform.rect.width / (float)Screen.width, canvasTransform.rect.height / (float)Screen.height);
			position += new Vector2(Screen.width, Screen.height) * 0.5f;
			return position;
		}
	}
	public class CatmulRom
	{
		public static float CatmullRomLerp(float pre, float start, float end, float post, float t)
		{
			while (t > 1f)
			{
				pre = start;
				start = end;
				end = post;
				post = end + (end - start);
				t -= 1f;
			}
			float num = 2f * start;
			float num2 = end - pre;
			float num3 = 2f * pre - 5f * start + 4f * end - post;
			float num4 = 0f - pre + 3f * (start - end) + post;
			float num5 = t * t;
			return (num + num2 * t + num3 * num5 + num4 * num5 * t) * 0.5f;
		}

		public static float CatmullRomLerp(float pre, float start, float end, float t)
		{
			float num = end + (end - start);
			while (t > 1f)
			{
				pre = start;
				start = end;
				end = num;
				num = end + (end - start);
				t -= 1f;
			}
			float num2 = 2f * start;
			float num3 = end - pre;
			float num4 = 2f * pre - 5f * start + 4f * end - num;
			float num5 = 0f - pre + 3f * (start - end) + num;
			float num6 = t * t;
			return (num2 + num3 * t + num4 * num6 + num5 * num6 * t) * 0.5f;
		}

		public static Vector3 CatmullRomLerp(Vector2 pre, Vector2 start, Vector2 end, Vector2 post, float t)
		{
			while (t > 1f)
			{
				pre = start;
				start = end;
				end = post;
				post = end + (end - start);
				t -= 1f;
			}
			Vector2 vector = 2f * start;
			Vector2 vector2 = end - pre;
			Vector2 vector3 = 2f * pre - 5f * start + 4f * end - post;
			Vector2 vector4 = -pre + 3f * (start - end) + post;
			float num = t * t;
			return (vector + vector2 * t + vector3 * num + vector4 * num * t) * 0.5f;
		}

		public static Vector3 CatmullRomLerp(Vector2 pre, Vector2 start, Vector2 end, float t)
		{
			Vector2 vector = end + (end - start);
			while (t > 1f)
			{
				pre = start;
				start = end;
				end = vector;
				vector = end + (end - start);
				t -= 1f;
			}
			Vector2 vector2 = 2f * start;
			Vector2 vector3 = end - pre;
			Vector2 vector4 = 2f * pre - 5f * start + 4f * end - vector;
			Vector2 vector5 = -pre + 3f * (start - end) + vector;
			float num = t * t;
			return (vector2 + vector3 * t + vector4 * num + vector5 * num * t) * 0.5f;
		}

		public static Vector3 CatmullRomLerp(Vector3 pre, Vector3 start, Vector3 end, Vector3 post, float t)
		{
			while (t > 1f)
			{
				pre = start;
				start = end;
				end = post;
				post = end + (end - start);
				t -= 1f;
			}
			Vector3 vector = 2f * start;
			Vector3 vector2 = end - pre;
			Vector3 vector3 = 2f * pre - 5f * start + 4f * end - post;
			Vector3 vector4 = -pre + 3f * (start - end) + post;
			float num = t * t;
			return (vector + vector2 * t + vector3 * num + vector4 * num * t) * 0.5f;
		}

		public static Vector3 CatmullRomLerp(Vector3 pre, Vector3 start, Vector3 end, float t)
		{
			Vector3 vector = end + (end - start);
			while (t > 1f)
			{
				pre = start;
				start = end;
				end = vector;
				vector = end + (end - start);
				t -= 1f;
			}
			Vector3 vector2 = 2f * start;
			Vector3 vector3 = end - pre;
			Vector3 vector4 = 2f * pre - 5f * start + 4f * end - vector;
			Vector3 vector5 = -pre + 3f * (start - end) + vector;
			float num = t * t;
			return (vector2 + vector3 * t + vector4 * num + vector5 * num * t) * 0.5f;
		}
	}
	public static class VectorExtension
	{
		public static float Remap(this float value, in float start1, in float stop1, in float start2, in float stop2)
		{
			return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
		}

		public static float Remap(this float value, in (float, float) input, in (float, float) output)
		{
			return output.Item1 + (output.Item2 - output.Item1) * ((value - input.Item1) / (input.Item2 - input.Item1));
		}

		public static Vector2 ToXZ(this in Vector3 vector)
		{
			return new Vector2(vector.x, vector.z);
		}

		public static Vector2 ToVector2(this in Vector3 vector)
		{
			return vector;
		}

		public static Vector3 ToVector3(this in Vector2 vector)
		{
			return vector;
		}

		public static Vector3 ToVector3(this in Vector2 vector, float z)
		{
			return new Vector3(vector.x, vector.y, z);
		}

		public static Vector3 ToVector3FromXZ(this in Vector2 xzVector)
		{
			return new Vector3(xzVector.x, 0f, xzVector.y);
		}

		public static Vector3 ToVector3FromXZ(this in Vector2 xzVector, float y)
		{
			return new Vector3(xzVector.x, y, xzVector.y);
		}

		public static Vector3 AdaptY(this in Vector3 xzVector, in float y)
		{
			return new Vector3(xzVector.x, y, xzVector.z);
		}

		public static Vector3 Round(this in Vector3 vector, in float scale)
		{
			return new Vector3(Mathf.Round(vector.x / scale) * scale, Mathf.Round(vector.y / scale) * scale, Mathf.Round(vector.z / scale) * scale);
		}

		public static Vector2 Decrease(this in Vector2 vector, in float amount)
		{
			return new Vector2(Mathf.Sign(vector.x) * Mathf.Max(Mathf.Abs(vector.x) - amount, 0f), Mathf.Sign(vector.y) * Mathf.Max(Mathf.Abs(vector.y) - amount, 0f));
		}

		public static Vector3 Decrease(this in Vector3 vector, in float amount)
		{
			return new Vector3(Mathf.Sign(vector.x) * Mathf.Max(Mathf.Abs(vector.x) - amount, 0f), Mathf.Sign(vector.y) * Mathf.Max(Mathf.Abs(vector.y) - amount, 0f), Mathf.Sign(vector.z) * Mathf.Max(Mathf.Abs(vector.z) - amount, 0f));
		}

		public static Vector2 ProjectionToXAxis(this in Vector2 vector, in Vector2 start, in float xAxisValue)
		{
			return new Vector2(xAxisValue, (vector.y - start.y) * (xAxisValue - start.x) / (vector.x - start.x) + start.y);
		}

		public static Vector2 ProjectionToYAxis(this in Vector2 vector, in Vector2 start, in float yAxisValue)
		{
			return new Vector2((vector.x - start.x) * (yAxisValue - start.y) / (vector.y - start.y) + start.x, yAxisValue);
		}

		public static Vector3 ProjectionToZAxis(this in Vector3 vector, in Vector3 start, in float zAxisValue)
		{
			return new Vector3((vector.x - start.x) * (zAxisValue - start.z) / (vector.z - start.z) + start.x, (vector.y - start.y) * (zAxisValue - start.z) / (vector.z - start.z) + start.y, zAxisValue);
		}

		public static Vector3 ProjectionToXAxis(this in Vector3 vector, in Vector3 start, in float xAxisValue)
		{
			return new Vector3(xAxisValue, (vector.y - start.y) * (xAxisValue - start.x) / (vector.x - start.x) + start.y, (vector.z - start.z) * (xAxisValue - start.x) / (vector.x - start.x) + start.z);
		}

		public static Vector3 ProjectionToYAxis(this in Vector3 vector, in Vector3 start, in float yAxisValue)
		{
			return new Vector3((vector.x - start.x) * (yAxisValue - start.y) / (vector.y - start.y) + start.x, yAxisValue, (vector.z - start.z) * (yAxisValue - start.y) / (vector.y - start.y) + start.z);
		}

		public static Vector3 ToAbs(this in Vector3 vector)
		{
			return new Vector3(Mathf.Abs(vector.x), Mathf.Abs(vector.y), Mathf.Abs(vector.z));
		}

		public static Vector3 IntersectionPoint(in Vector3 origin, in Vector3 target, in Vector3 center, in float radius)
		{
			Vector3 vector = Vector3.Project(center - origin, (target - origin).normalized);
			float num = Vector3.Distance(origin + vector, center);
			if (num > radius)
			{
				num = radius;
			}
			float num2 = Mathf.Sqrt(radius * radius - num * num);
			float num3 = vector.magnitude - num2;
			return origin + (target - origin).normalized * num3;
		}
	}
	public static class XRExtension
	{
		public static bool SetHapticImpulse(this UnityEngine.XR.Interaction.Toolkit.XRController controller, float amp, float duration)
		{
			if (controller.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				return controller.inputDevice.SendHapticImpulse(0u, amp, duration);
			}
			return false;
		}
	}
}
namespace Jisu.Boxing.SingleAI
{
	public class ActiveRagdollManager : MonoBehaviour
	{
		[Serializable]
		public struct Bone
		{
			public Transform origin;

			public ConfigurableJoint ragdoll_Joint;

			public Rigidbody ragdoll_RB;

			public int connect_Num;

			public Quaternion startQtn;
		}

		public enum RagdollState
		{
			Stand,
			Down
		}

		public enum AnimSyncState
		{
			Anim,
			Physics
		}

		public enum RagdollRecoveryState
		{
			Stop,
			Recovery
		}

		public enum DamagePosition
		{
			Head,
			Body,
			Guard_Head,
			Guard_Body
		}

		public Bone[] bones;

		public Transform spine0TF;

		public Transform spine1TF;

		public Transform neckTF;

		public Transform clavicleTF_L;

		public Transform clavicleTF_R;

		private Vector3 recoveryPos;

		private Quaternion[] recoveryQtn;

		public Animator anim;

		private Quaternion headForce;

		private Vector3 bodyForce;

		public AnimationCurve bodyDamageCurve;

		private float bodyDamageTime;

		public RagdollState ragdollState;

		public AnimSyncState animSyncState;

		private RagdollRecoveryState recoveryState;

		private float weight_physics = 1f;

		public SpineCtrl spineCtrl;

		private void Start()
		{
			recoveryState = RagdollRecoveryState.Recovery;
			anim = GetComponent<Animator>();
			if (spineCtrl != null)
			{
				spineCtrl.SetRagdoll();
			}
			JointDrive slerpDrive = default(JointDrive);
			slerpDrive.positionSpring = 1000f;
			slerpDrive.positionDamper = 30f;
			slerpDrive.maximumForce = 1000f;
			for (int i = 0; i < bones.Length; i++)
			{
				if (i == RagdollBones.LeftUpperArm || i == RagdollBones.RightUpperArm || i == RagdollBones.LeftLowerArm || i == RagdollBones.RightLowerArm || i == RagdollBones.LeftHand || i == RagdollBones.RightHand)
				{
					bones[i].ragdoll_Joint.massScale = 10f;
				}
				if (i == RagdollBones.Hips)
				{
					bones[i].ragdoll_Joint.massScale = 1f;
				}
				else
				{
					bones[i].ragdoll_Joint.massScale = 5f;
				}
				bones[i].ragdoll_Joint.slerpDrive = slerpDrive;
				bones[i].ragdoll_Joint.autoConfigureConnectedAnchor = false;
				if (bones[i].ragdoll_Joint.connectedBody == null)
				{
					bones[i].connect_Num = -1;
					continue;
				}
				for (int j = 0; j < i; j++)
				{
					if (bones[i].ragdoll_Joint.connectedBody.name == bones[j].origin.name)
					{
						bones[i].startQtn = bones[i].ragdoll_RB.transform.localRotation;
						break;
					}
				}
			}
			recoveryQtn = new Quaternion[bones.Length];
		}

		public void SetDamage(DamagePosition damagePos, Vector3 veloc)
		{
			if (ragdollState != 0)
			{
				return;
			}
			float num = Mathf.Clamp01(veloc.magnitude);
			num = Mathf.Sin(num * 90f * ((float)Math.PI / 180f));
			Vector3 vector = veloc.normalized * num;
			switch (damagePos)
			{
			case DamagePosition.Head:
			{
				animSyncState = AnimSyncState.Physics;
				JointDrive slerpDrive2 = default(JointDrive);
				slerpDrive2.positionSpring = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionSpring, 500f, num);
				slerpDrive2.positionDamper = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionDamper, 50f, num);
				slerpDrive2.maximumForce = bones[1].ragdoll_Joint.slerpDrive.maximumForce;
				for (int j = 1; j < bones.Length; j++)
				{
					bones[j].ragdoll_Joint.slerpDrive = slerpDrive2;
					bones[j].ragdoll_Joint.massScale = Mathf.Lerp(bones[j].ragdoll_Joint.massScale, 1f, num);
				}
				bones[RagdollBones.Head].ragdoll_RB.mass = 50f;
				Vector3 vector2 = base.transform.position - PlayerCtrl.Instance.transform.position;
				vector2.y = 0f;
				vector2 = vector2.normalized;
				bones[RagdollBones.Head].ragdoll_RB.velocity = vector * 20f + vector2 * num * 20f;
				vector = base.transform.InverseTransformDirection(-vector);
				vector.x *= 80f;
				vector.z += 0.0001f;
				if (Mathf.Abs(vector.y) > Mathf.Abs(vector.z))
				{
					vector.z = 0f - vector.y;
				}
				vector.z *= Mathf.Lerp(20f, 80f, Mathf.Abs(vector.y) / (Mathf.Abs(vector.y) + Mathf.Abs(vector.z)));
				vector.x = Mathf.Clamp(vector.x, -80f, 80f);
				vector.y = Mathf.Clamp(vector.y, -50f, 50f);
				vector.z = Mathf.Clamp(vector.z, -50f, 80f);
				headForce = Quaternion.Euler(vector);
				break;
			}
			case DamagePosition.Body:
			{
				animSyncState = AnimSyncState.Physics;
				JointDrive slerpDrive3 = default(JointDrive);
				slerpDrive3.positionSpring = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionSpring, 500f, num);
				slerpDrive3.positionDamper = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionDamper, 100f, num);
				slerpDrive3.maximumForce = bones[1].ragdoll_Joint.slerpDrive.maximumForce;
				for (int k = 1; k < bones.Length; k++)
				{
					bones[k].ragdoll_Joint.slerpDrive = slerpDrive3;
					bones[k].ragdoll_Joint.massScale = Mathf.Lerp(bones[k].ragdoll_Joint.massScale, 1f, num);
				}
				bones[RagdollBones.Head].ragdoll_RB.mass = 50f;
				bones[RagdollBones.UpperChest].ragdoll_RB.velocity = -vector * 0.2f;
				bones[RagdollBones.Head].ragdoll_RB.velocity = vector * 1f;
				bodyForce = vector * 0.2f;
				bodyDamageTime = 0f;
				break;
			}
			case DamagePosition.Guard_Head:
			{
				animSyncState = AnimSyncState.Physics;
				JointDrive slerpDrive4 = default(JointDrive);
				slerpDrive4.positionSpring = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionSpring, 700f, num);
				slerpDrive4.positionDamper = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionDamper, 30f, num);
				slerpDrive4.maximumForce = bones[1].ragdoll_Joint.slerpDrive.maximumForce;
				for (int l = 1; l < bones.Length; l++)
				{
					bones[l].ragdoll_Joint.slerpDrive = slerpDrive4;
					bones[l].ragdoll_Joint.massScale = Mathf.Lerp(bones[l].ragdoll_Joint.massScale, 3f, num);
				}
				bones[RagdollBones.Head].ragdoll_RB.mass = 50f;
				Vector3 vector3 = base.transform.position - PlayerCtrl.Instance.transform.position;
				vector3.y = 0f;
				vector3 = vector3.normalized;
				Vector3 vector4 = Vector3.Cross(vector3, Vector3.up);
				bones[RagdollBones.Head].ragdoll_RB.velocity = vector * 5f + vector3 * num * 5f;
				bones[RagdollBones.LeftUpperArm].ragdoll_RB.velocity = vector * 3f + vector4 * num * -3f;
				bones[RagdollBones.RightUpperArm].ragdoll_RB.velocity = vector * 3f + vector4 * num * 3f;
				bones[RagdollBones.LeftLowerArm].ragdoll_RB.velocity = vector * 10f + vector3 * num * 10f;
				bones[RagdollBones.RightLowerArm].ragdoll_RB.velocity = vector * 10f + vector3 * num * 10f;
				vector = base.transform.InverseTransformDirection(-vector);
				vector.x *= 30f;
				vector.z += 0.0001f;
				if (Mathf.Abs(vector.y) > Mathf.Abs(vector.z))
				{
					vector.z = 0f - vector.y;
				}
				vector.z *= Mathf.Lerp(20f, 30f, Mathf.Abs(vector.y) / (Mathf.Abs(vector.y) + Mathf.Abs(vector.z)));
				vector.x = Mathf.Clamp(vector.x, -30f, 30f);
				vector.y = Mathf.Clamp(vector.y, -50f, 50f);
				vector.z = Mathf.Clamp(vector.z, -20f, 30f);
				headForce = Quaternion.Euler(vector);
				break;
			}
			case DamagePosition.Guard_Body:
			{
				animSyncState = AnimSyncState.Physics;
				JointDrive slerpDrive = default(JointDrive);
				slerpDrive.positionSpring = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionSpring, 700f, num);
				slerpDrive.positionDamper = Mathf.Lerp(bones[1].ragdoll_Joint.slerpDrive.positionDamper, 30f, num);
				slerpDrive.maximumForce = bones[1].ragdoll_Joint.slerpDrive.maximumForce;
				for (int i = 1; i < bones.Length; i++)
				{
					bones[i].ragdoll_Joint.slerpDrive = slerpDrive;
					bones[i].ragdoll_Joint.massScale = Mathf.Lerp(bones[i].ragdoll_Joint.massScale, 3f, num);
				}
				bones[RagdollBones.Head].ragdoll_RB.mass = 50f;
				bones[RagdollBones.UpperChest].ragdoll_RB.velocity = -vector * 0.2f;
				bones[RagdollBones.Head].ragdoll_RB.velocity = vector * 1f;
				bodyForce = vector * 0.1f;
				bodyDamageTime = 0f;
				break;
			}
			}
		}

		private void FixedUpdate()
		{
			headForce = Quaternion.Lerp(headForce, Quaternion.identity, Time.fixedDeltaTime * 5f);
			bodyDamageTime = Mathf.Clamp01(bodyDamageTime + Time.fixedDeltaTime * 2f);
			Vector3 vector = Vector3.Lerp(Vector3.zero, bodyForce, bodyDamageCurve.Evaluate(bodyDamageTime));
			bones[RagdollBones.Hips].ragdoll_RB.MovePosition(recoveryPos + vector);
			bones[RagdollBones.Hips].ragdoll_RB.MoveRotation(recoveryQtn[0].normalized);
			for (int i = 1; i < bones.Length; i++)
			{
				if (i == RagdollBones.UpperChest)
				{
					bones[i].ragdoll_Joint.anchor = bones[i].origin.InverseTransformPoint(spine1TF.position);
					bones[i].ragdoll_Joint.connectedAnchor = bones[RagdollBones.Hips].origin.InverseTransformPoint(spine1TF.position);
				}
				else if (i == RagdollBones.Head)
				{
					bones[i].ragdoll_Joint.anchor = bones[i].origin.InverseTransformPoint(bones[i].origin.position);
					bones[i].ragdoll_Joint.connectedAnchor = bones[RagdollBones.UpperChest].origin.InverseTransformPoint(bones[i].origin.position);
				}
				else if (i == RagdollBones.LeftUpperArm)
				{
					bones[i].ragdoll_Joint.anchor = bones[i].origin.InverseTransformPoint(bones[i].origin.position);
					bones[i].ragdoll_Joint.connectedAnchor = bones[RagdollBones.UpperChest].origin.InverseTransformPoint(bones[i].origin.position);
				}
				else if (i == RagdollBones.RightUpperArm)
				{
					bones[i].ragdoll_Joint.anchor = bones[i].origin.InverseTransformPoint(bones[i].origin.position);
					bones[i].ragdoll_Joint.connectedAnchor = bones[RagdollBones.UpperChest].origin.InverseTransformPoint(bones[i].origin.position);
				}
				else
				{
					bones[i].ragdoll_Joint.connectedAnchor = bones[i].origin.parent.InverseTransformPoint(bones[i].origin.transform.position);
				}
				if (i == RagdollBones.Head)
				{
					bones[i].ragdoll_Joint.targetRotation = (Quaternion.Inverse(recoveryQtn[i] * headForce) * bones[i].startQtn).normalized;
				}
				else
				{
					bones[i].ragdoll_Joint.targetRotation = (Quaternion.Inverse(recoveryQtn[i]) * bones[i].startQtn).normalized;
				}
			}
		}

		private void LateUpdate()
		{
			if (spineCtrl != null)
			{
				spineCtrl.UpdateData();
			}
			Vector3 position = bones[RagdollBones.LeftUpperLeg].origin.position;
			Vector3 position2 = bones[RagdollBones.LeftLowerLeg].origin.position;
			Vector3 position3 = bones[RagdollBones.LeftFoot].origin.position;
			Vector3 vector = bones[RagdollBones.Hips].ragdoll_RB.transform.position + (position - bones[RagdollBones.Hips].origin.position);
			Vector3 vector2 = position3 - position;
			float num = (position2 - position).magnitude + (position3 - position2).magnitude;
			float num2 = (position2 - position).magnitude / num;
			Vector3 vector3 = position + vector2 * num2;
			Vector3 vector4 = vector3 - position;
			Vector3 vector5 = position2 - position;
			Mathf.Sqrt(vector5.sqrMagnitude - vector4.sqrMagnitude);
			Vector3 normalized = (position2 - vector3).normalized;
			Vector3 vector6 = position3 - vector;
			if (vector6.magnitude > num)
			{
				vector6 = vector6.normalized * num;
			}
			Vector3 vector7 = vector + vector6 * num2;
			Vector3 vector8 = vector3 - vector;
			float num3 = vector5.sqrMagnitude - vector8.sqrMagnitude + 0.01f;
			num3 = ((!(num3 > 0f)) ? 0f : Mathf.Sqrt(num3));
			Vector3 vector9 = vector7 + normalized * num3;
			Vector3 vector10 = position3;
			Quaternion rotation = bones[RagdollBones.LeftFoot].origin.rotation;
			position = bones[RagdollBones.RightUpperLeg].origin.position;
			position2 = bones[RagdollBones.RightLowerLeg].origin.position;
			position3 = bones[RagdollBones.RightFoot].origin.position;
			Vector3 vector11 = bones[RagdollBones.Hips].ragdoll_RB.transform.position + (position - bones[RagdollBones.Hips].origin.position);
			vector2 = position3 - position;
			num = (position2 - position).magnitude + (position3 - position2).magnitude;
			num2 = (position2 - position).magnitude / num;
			vector3 = position + vector2 * num2;
			vector4 = vector3 - position;
			vector5 = position2 - position;
			Mathf.Sqrt(vector5.sqrMagnitude - vector4.sqrMagnitude);
			Vector3 normalized2 = (position2 - vector3).normalized;
			Vector3 vector12 = position3 - vector11;
			if (vector12.magnitude > num)
			{
				vector12 = vector12.normalized * num;
			}
			Vector3 vector13 = vector11 + vector12 * num2;
			vector8 = vector3 - vector11;
			num3 = vector5.sqrMagnitude - vector8.sqrMagnitude + 0.01f;
			num3 = ((!(num3 > 0f)) ? 0f : Mathf.Sqrt(num3));
			Vector3 vector14 = vector13 + normalized2 * num3;
			Vector3 vector15 = position3;
			Quaternion rotation2 = bones[RagdollBones.RightFoot].origin.rotation;
			recoveryPos = bones[RagdollBones.Hips].origin.position;
			recoveryQtn[0] = bones[RagdollBones.Hips].origin.rotation;
			bones[RagdollBones.Hips].origin.position = bones[RagdollBones.Hips].ragdoll_RB.transform.position;
			bones[RagdollBones.Hips].origin.rotation = bones[RagdollBones.Hips].ragdoll_RB.transform.rotation;
			for (int i = 1; i < bones.Length; i++)
			{
				if (i == RagdollBones.UpperChest)
				{
					recoveryQtn[i] = Quaternion.Inverse(bones[RagdollBones.Hips].origin.rotation) * bones[i].origin.rotation;
					spine1TF.rotation = Quaternion.Lerp(spine1TF.rotation, bones[i].ragdoll_RB.transform.rotation, weight_physics);
				}
				else if (i == RagdollBones.Head)
				{
					recoveryQtn[i] = Quaternion.Inverse(bones[RagdollBones.UpperChest].origin.rotation) * bones[i].origin.rotation;
					bones[i].origin.rotation = Quaternion.Lerp(bones[i].origin.rotation, bones[i].ragdoll_RB.transform.rotation, weight_physics);
				}
				else if (i == RagdollBones.LeftUpperArm)
				{
					recoveryQtn[i] = Quaternion.Inverse(bones[RagdollBones.UpperChest].origin.rotation) * bones[i].origin.rotation;
					bones[i].origin.rotation = Quaternion.Lerp(bones[i].origin.rotation, bones[i].ragdoll_RB.transform.rotation, weight_physics);
				}
				else if (i == RagdollBones.RightUpperArm)
				{
					recoveryQtn[i] = Quaternion.Inverse(bones[RagdollBones.UpperChest].origin.rotation) * bones[i].origin.rotation;
					bones[i].origin.rotation = Quaternion.Lerp(bones[i].origin.rotation, bones[i].ragdoll_RB.transform.rotation, weight_physics);
				}
				else if (i >= 7)
				{
					recoveryQtn[i] = bones[i].origin.localRotation;
					bones[i].origin.rotation = Quaternion.Lerp(bones[i].origin.rotation, bones[i].ragdoll_RB.transform.rotation, weight_physics);
				}
			}
			if (ragdollState == RagdollState.Stand)
			{
				Vector3 vector16 = Vector3.Cross(-vector6.normalized, normalized);
				bones[RagdollBones.LeftUpperLeg].origin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector9 - vector).normalized));
				bones[RagdollBones.LeftLowerLeg].origin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector10 - vector9).normalized));
				bones[RagdollBones.LeftFoot].origin.rotation = rotation;
				vector16 = Vector3.Cross(-vector12.normalized, normalized2);
				bones[RagdollBones.RightUpperLeg].origin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector14 - vector11).normalized));
				bones[RagdollBones.RightLowerLeg].origin.rotation = Quaternion.LookRotation(vector16, Vector3.Cross(vector16, -(vector15 - vector14).normalized));
				bones[RagdollBones.RightFoot].origin.rotation = rotation2;
			}
			RecoveryRagdoll();
		}

		private void RecoveryRagdoll()
		{
			if (recoveryState == RagdollRecoveryState.Stop)
			{
				return;
			}
			if (animSyncState == AnimSyncState.Physics)
			{
				weight_physics = Mathf.Clamp(weight_physics + Time.deltaTime * 19f, 0.1f, 1f);
				if (weight_physics == 1f)
				{
					animSyncState = AnimSyncState.Anim;
				}
			}
			else
			{
				weight_physics = Mathf.Clamp(weight_physics - Time.deltaTime * 0.9f, 0.1f, 1f);
			}
			for (int i = 1; i < bones.Length; i++)
			{
				if (i == RagdollBones.LeftHand || i == RagdollBones.RightHand)
				{
					bones[i].ragdoll_RB.mass = Mathf.MoveTowards(bones[i].ragdoll_RB.mass, 2f, Time.deltaTime * 150f);
				}
				else if (i == RagdollBones.LeftLowerArm || i == RagdollBones.RightLowerArm)
				{
					bones[i].ragdoll_RB.mass = Mathf.MoveTowards(bones[i].ragdoll_RB.mass, 4f, Time.deltaTime * 150f);
				}
				else if (i == RagdollBones.LeftUpperArm || i == RagdollBones.LeftUpperArm)
				{
					bones[i].ragdoll_RB.mass = Mathf.MoveTowards(bones[i].ragdoll_RB.mass, 8f, Time.deltaTime * 150f);
				}
				else if (i == RagdollBones.Head)
				{
					bones[i].ragdoll_RB.mass = Mathf.MoveTowards(bones[i].ragdoll_RB.mass, 2f, Time.deltaTime * 100f);
				}
				if (i == RagdollBones.LeftHand || i == RagdollBones.RightHand)
				{
					bones[i].ragdoll_RB.drag = Mathf.MoveTowards(bones[i].ragdoll_RB.drag, 100f, Time.deltaTime * 10f);
					bones[i].ragdoll_RB.angularDrag = Mathf.MoveTowards(bones[i].ragdoll_RB.angularDrag, 100f, Time.deltaTime * 10f);
				}
				else
				{
					bones[i].ragdoll_RB.drag = Mathf.MoveTowards(bones[i].ragdoll_RB.drag, 20f, Time.deltaTime * 10f);
					bones[i].ragdoll_RB.angularDrag = Mathf.MoveTowards(bones[i].ragdoll_RB.angularDrag, 20f, Time.deltaTime * 10f);
				}
				JointDrive slerpDrive = bones[i].ragdoll_Joint.slerpDrive;
				slerpDrive.positionSpring = Mathf.MoveTowards(slerpDrive.positionSpring, 1000f, Time.deltaTime * 1000f);
				slerpDrive.positionDamper = Mathf.MoveTowards(slerpDrive.positionDamper, 0f, Time.deltaTime * 50f);
				bones[i].ragdoll_Joint.slerpDrive = slerpDrive;
				bones[i].ragdoll_Joint.massScale = Mathf.MoveTowards(bones[i].ragdoll_Joint.massScale, 7f, Time.deltaTime * 7f);
			}
		}

		public Quaternion GetParentBoneQuaternion(int boneNum)
		{
			switch (boneNum)
			{
			case 3:
				return anim.GetBoneTransform(HumanBodyBones.LeftUpperLeg).rotation;
			case 4:
				return anim.GetBoneTransform(HumanBodyBones.RightUpperLeg).rotation;
			case 5:
				return anim.GetBoneTransform(HumanBodyBones.LeftLowerLeg).rotation;
			case 6:
				return anim.GetBoneTransform(HumanBodyBones.RightLowerLeg).rotation;
			case 7:
				return anim.GetBoneTransform(HumanBodyBones.Chest).rotation;
			case 8:
			case 9:
			case 10:
				return anim.GetBoneTransform(HumanBodyBones.UpperChest).rotation;
			case 11:
				return anim.GetBoneTransform(HumanBodyBones.LeftUpperArm).rotation;
			case 12:
				return anim.GetBoneTransform(HumanBodyBones.RightUpperArm).rotation;
			case 13:
				return anim.GetBoneTransform(HumanBodyBones.LeftLowerArm).rotation;
			case 14:
				return anim.GetBoneTransform(HumanBodyBones.RightLowerArm).rotation;
			default:
				return anim.GetBoneTransform(HumanBodyBones.Hips).rotation;
			}
		}

		public void SetAnimSyncState(AnimSyncState _animSyncState, bool isSmooth = true)
		{
			animSyncState = _animSyncState;
			if (!isSmooth)
			{
				if (animSyncState == AnimSyncState.Anim)
				{
					weight_physics = 0f;
				}
				else
				{
					weight_physics = 1f;
				}
			}
		}

		public void RefrashRagdoll()
		{
			for (int i = 0; i < bones.Length; i++)
			{
				bones[i].ragdoll_RB.transform.SetPositionAndRotation(bones[i].origin.position, bones[i].origin.rotation);
			}
		}
	}
	public class AnnouncerCtrl : LocalSingleton<AnnouncerCtrl>
	{
		private Animator anim;

		private CustomModelSettingCtrl cmsCtrl;

		private float blinkDelayTime;

		private float shotTime = 1f;

		private AudioSource audioSource;

		public bool isEnd;

		public AnimationCurve animationCurve;

		private float blendP = 1f;

		private int currentBlendState = 1;

		private int previousBlendState = 1;

		private void Start()
		{
			anim = GetComponent<Animator>();
			cmsCtrl = GetComponent<CustomModelSettingCtrl>();
			audioSource = GetComponent<AudioSource>();
			shotTime = 27.5f;
			cmsCtrl.InitRandom(CustomModelViewState.Normal, null, 0.1f);
		}

		private void Update()
		{
			CheckDelayTime();
		}

		private void CheckDelayTime()
		{
			if (blinkDelayTime > 0f)
			{
				blinkDelayTime -= Time.deltaTime;
			}
		}

		public void Play()
		{
			audioSource.Play();
			StartCoroutine(IdleCoroutine());
		}

		private IEnumerator IdleCoroutine()
		{
			float time = UnityEngine.Random.Range(1f, 2f);
			while (isEnd || !(audioSource.time >= shotTime))
			{
				if (time > 0f)
				{
					time -= Time.deltaTime;
					if (blendP < 1f)
					{
						blendP = Mathf.Clamp01(blendP + Time.deltaTime);
						float num = animationCurve.Evaluate(blendP);
						anim.SetFloat("Blend0" + currentBlendState, num);
						anim.SetFloat("Blend0" + previousBlendState, 1f - num);
					}
					yield return null;
				}
				else if (audioSource.time >= shotTime * 0.75f && audioSource.time + 3f <= shotTime)
				{
					anim.SetInteger("ShotNum", (int)UnityEngine.Random.Range(1f, 3.9999f));
					anim.SetTrigger("OnShot");
					time = UnityEngine.Random.Range(3f, 5f);
				}
				else
				{
					previousBlendState = currentBlendState;
					currentBlendState = (int)UnityEngine.Random.Range(1f, 3.9999f);
					if (currentBlendState != previousBlendState)
					{
						blendP = 0f;
					}
					time = UnityEngine.Random.Range(2f, 3f);
				}
			}
			anim.SetTrigger("OnEnd");
			isEnd = true;
			yield return YieldInstructionCache.WaitForSeconds(1f);
			anim.SetFloat("Blend01", 0f);
			anim.SetFloat("Blend02", 0f);
			anim.SetFloat("Blend03", 1f);
		}
	}
	public abstract class BoxerClass : MonoBehaviour
	{
		public float curStamina;

		public float maxStamina;

		public float staminaSpeed;

		public float curHealth;

		public float maxHealth;

		public float healthSpeed;

		public float GetStaminaRatio()
		{
			return curStamina / maxStamina;
		}

		public float GetHealthRatio()
		{
			return curHealth / maxHealth;
		}

		public abstract void CheckAttack(Collision collision, bool isRight);

		public virtual void Recovery(bool isSTEnabled)
		{
			if (isSTEnabled && curStamina > 0f)
			{
				curStamina = Mathf.MoveTowards(curStamina, maxStamina, Time.deltaTime * staminaSpeed * (curHealth / maxHealth));
			}
			if (curHealth > 0f)
			{
				curHealth = Mathf.MoveTowards(curHealth, maxHealth, Time.deltaTime * healthSpeed);
			}
		}

		public virtual void SetHP(float delta)
		{
			curHealth = Mathf.Clamp(curHealth + delta, 0f, maxHealth);
		}

		public virtual void SetST(float delta)
		{
			curStamina = Mathf.Clamp(curStamina + delta, 0f, maxStamina);
		}
	}
	public class BoxerUICtrl : LocalSingleton<BoxerUICtrl>
	{
		private Animator anim;

		private AudioSource audioSource;

		private AudioSource audioSource_voice;

		private bool isLanguageChn;

		public AudioClip[] roundSounds_eng;

		public AudioClip[] roundSounds_chn;

		private MeshRenderer[] renderers_round;

		private void Start()
		{
			anim = GetComponent<Animator>();
			audioSource = GetComponent<AudioSource>();
			audioSource_voice = base.gameObject.AddComponent<AudioSource>();
			audioSource_voice.playOnAwake = false;
			audioSource_voice.loop = false;
			base.gameObject.SetActive(value: false);
			renderers_round = new MeshRenderer[3];
			Transform transform = base.transform.Find("RoundUI/Rounds");
			for (int i = 0; i < 3; i++)
			{
				renderers_round[i] = transform.GetChild(i).GetComponent<MeshRenderer>();
			}
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			isLanguageChn = PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese;
		}

		public void StartRoundUI(int round)
		{
			base.gameObject.SetActive(value: true);
			for (int i = 0; i < renderers_round.Length; i++)
			{
				if (round == i + 1)
				{
					renderers_round[i].enabled = true;
				}
				else
				{
					renderers_round[i].enabled = false;
				}
			}
			anim.SetTrigger("OnRound");
			OnRoundSound(round);
			Invoke("DelayOff", 2.5f);
		}

		private void DelayOff()
		{
			base.gameObject.SetActive(value: false);
		}

		private void OnRoundSound(int round)
		{
			if (isLanguageChn)
			{
				audioSource.clip = roundSounds_chn[round - 1];
			}
			else
			{
				audioSource.clip = roundSounds_eng[round - 1];
			}
			audioSource.Play();
		}
	}
	public class BrandoCtrl : LocalSingleton<BrandoCtrl>
	{
		private enum MoveState
		{
			Idle,
			MiddleTrace,
			StepBack,
			Arbitration,
			LookDownFighter,
			CountReady,
			Count,
			EndRound
		}

		private enum LookState
		{
			Player,
			Enemy,
			Middle
		}

		public enum DownState
		{
			KnockDown,
			KnockOut,
			KO3
		}

		private Animator anim;

		public Transform lookPoint;

		private Vector3 ranLookVec;

		private float ranLookDelayTime;

		private bool isLanguageChn;

		private AudioSource audioSource;

		public AudioClip[] countAudios_eng;

		public AudioClip[] countAudios_chn;

		public AudioClip[] koClips;

		private MoveState moveState;

		private float idleState;

		private float idleAnimState;

		private float idleStateDelayTime;

		private float moveSpeed;

		private Vector2 movePosVec2;

		private float moveAnimState;

		private Vector2 moveAnimVec2;

		private bool isPlay;

		private float lookTime;

		private LookState lookState;

		private int fighterNum_down;

		private int fighterNum_attack;

		private Vector3 arbitrationDir;

		private DownState downState;

		private float count_startNum;

		private float count_endNum;

		private Transform transform_keep;

		public Transform playerHeadTr;

		private Transform cpuHeadTr;

		public FaceCtrl faceCtrl;

		public CustomModelSettingCtrl cmsCtrl;

		public SpineCtrl spineCtrl;

		public EyeAnimationCtrl eyeAnimationCtrl;

		private float cachedFixedDeltaTime;

		protected override void Awake()
		{
			base.Awake();
			transform_keep = new GameObject().transform;
			playerHeadTr = Camera.main.transform;
			cpuHeadTr = CPUCtrl.Instance.ragdoll.bones[RagdollBones.Head].origin;
			anim = GetComponent<Animator>();
			audioSource = GetComponent<AudioSource>();
			moveSpeed = 2.2f;
			lookState = LookState.Player;
			isPlay = false;
			cachedFixedDeltaTime = Time.fixedDeltaTime;
			cmsCtrl.InitRandom(CustomModelViewState.Normal, null, 0f);
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			isLanguageChn = PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese;
		}

		private void Update()
		{
			CheckDelayTime();
			SetLookPoint();
			switch (moveState)
			{
			case MoveState.StepBack:
				StepBack();
				break;
			case MoveState.CountReady:
				CountReady();
				break;
			case MoveState.EndRound:
				EndRound();
				break;
			}
			if (isPlay)
			{
				Move();
				CheckLookTime();
			}
		}

		private void LateUpdate()
		{
			if (isPlay)
			{
				CheckRestrictedArea();
			}
		}

		private void CheckRestrictedArea()
		{
			Vector3 vector = base.transform.position;
			Vector3 position = LocalSingleton<GameManager>.Instance.bodyTFs[0].position;
			position.y = 0f;
			if ((vector - position).magnitude < 0.6f)
			{
				vector = (vector - position).normalized * 0.6f + position;
			}
			position = LocalSingleton<GameManager>.Instance.bodyTFs[1].position;
			position.y = 0f;
			if ((vector - position).magnitude < 0.6f)
			{
				vector = (vector - position).normalized * 0.6f + position;
			}
			if (vector.x > 2f)
			{
				vector.x = 2f;
			}
			else if (vector.x < -2f)
			{
				vector.x = -2f;
			}
			if (vector.z > 2f)
			{
				vector.z = 2f;
			}
			else if (vector.z < -2f)
			{
				vector.z = -2f;
			}
			base.transform.position = vector;
		}

		private void CheckDelayTime()
		{
			if (ranLookDelayTime > 0f)
			{
				ranLookDelayTime -= Time.deltaTime;
			}
		}

		private void Move()
		{
			if (idleStateDelayTime > 0f)
			{
				idleStateDelayTime -= Time.deltaTime;
			}
			else
			{
				idleStateDelayTime = UnityEngine.Random.Range(0.7f, 1.5f);
				idleState = UnityEngine.Random.Range(0f, 1f);
			}
			idleAnimState = Mathf.MoveTowards(idleAnimState, idleState, Time.deltaTime * 0.5f);
			Vector3 vector = (LocalSingleton<GameManager>.Instance.headTFs[0].position + LocalSingleton<GameManager>.Instance.headTFs[1].position) * 0.5f;
			vector.y = 0f;
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(vector - base.transform.position), cachedFixedDeltaTime * 10f);
			Vector3 normalized = (-vector).normalized;
			Vector3 vector2 = LocalSingleton<GameManager>.Instance.headTFs[1].position - LocalSingleton<GameManager>.Instance.headTFs[0].position;
			vector2.y = 0f;
			Vector3 vector3 = Vector3.Cross(vector2.normalized, Vector3.up);
			if (Vector3.Dot(vector3, normalized) <= 0f)
			{
				vector3 = -vector3;
			}
			normalized = Vector3.Slerp(normalized, vector3, 0.5f);
			float magnitude = vector2.magnitude;
			magnitude = Mathf.Clamp(magnitude, 1.5f, 10f);
			Vector3 vector4 = Vector3.Slerp((base.transform.position - vector).normalized, normalized, 0.2f);
			Vector3 direction = vector + (vector4.normalized * (magnitude * 0.5f) + vector4.normalized * 1f) - base.transform.position;
			direction.y = 0f;
			Vector3 vector5 = base.transform.InverseTransformDirection(direction);
			if (direction.sqrMagnitude >= 0.035f)
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 1f, Time.deltaTime * moveSpeed);
			}
			else
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 0f, Time.deltaTime * moveSpeed);
			}
			if (direction.sqrMagnitude >= 0.015f)
			{
				movePosVec2.x = vector5.x;
				movePosVec2.y = vector5.z;
			}
			else if (direction.sqrMagnitude <= 0.003f)
			{
				movePosVec2 = Vector2.zero;
			}
			moveAnimVec2 = Vector2.MoveTowards(moveAnimVec2, movePosVec2.normalized, Time.deltaTime * moveSpeed);
			anim.SetFloat("Idle", idleAnimState);
			anim.SetFloat("Speed", moveAnimState);
			anim.SetFloat("MoveX", moveAnimVec2.x);
			anim.SetFloat("MoveZ", moveAnimVec2.y);
		}

		public void SetLookState(int state)
		{
			switch (state)
			{
			case 0:
				lookState = LookState.Player;
				break;
			case 1:
				lookState = LookState.Enemy;
				break;
			case 2:
				lookState = LookState.Middle;
				break;
			}
		}

		private void SetLookPoint()
		{
			if (ranLookDelayTime <= 0f)
			{
				ranLookDelayTime = UnityEngine.Random.Range(0.2f, 0.8f);
				ranLookVec.x = UnityEngine.Random.Range(-0.01f, 0.01f);
				ranLookVec.y = UnityEngine.Random.Range(-0.01f, 0.01f);
				ranLookVec.z = UnityEngine.Random.Range(-0.01f, 0.01f);
			}
			switch (lookState)
			{
			case LookState.Player:
				lookPoint.position = Vector3.Lerp(lookPoint.position + ranLookVec, playerHeadTr.position, Time.deltaTime * 5f);
				break;
			case LookState.Enemy:
				lookPoint.position = Vector3.Lerp(lookPoint.position + ranLookVec, cpuHeadTr.position, Time.deltaTime * 5f);
				break;
			case LookState.Middle:
				lookPoint.position = Vector3.Lerp(lookPoint.position + ranLookVec, (playerHeadTr.position + cpuHeadTr.position) * 0.5f, Time.deltaTime * 5f);
				break;
			}
		}

		private void CheckLookTime()
		{
			if (lookTime > 0f)
			{
				lookTime -= Time.deltaTime;
				return;
			}
			lookTime = UnityEngine.Random.Range(0.5f, 2.5f);
			switch (lookState)
			{
			case LookState.Player:
				lookState = LookState.Enemy;
				break;
			case LookState.Enemy:
				lookState = LookState.Player;
				break;
			default:
				lookState = LookState.Player;
				break;
			}
		}

		public void GameReady()
		{
			moveState = MoveState.Idle;
			anim.SetTrigger("OnReady");
			eyeAnimationCtrl.SetExpression(15, 2f);
		}

		public void GameFight()
		{
			anim.speed = 1f;
			moveState = MoveState.MiddleTrace;
			anim.SetTrigger("OnFight");
			PlayAudio(0);
			eyeAnimationCtrl.SetExpression(15, 2f);
		}

		public void PlayAudio(int clip_index)
		{
			if (isLanguageChn)
			{
				audioSource.clip = countAudios_chn[clip_index];
			}
			else
			{
				audioSource.clip = countAudios_eng[clip_index];
			}
			audioSource.Play();
		}

		public void PlayKOSound()
		{
			if (isLanguageChn)
			{
				audioSource.clip = koClips[1];
			}
			else
			{
				audioSource.clip = koClips[0];
			}
			audioSource.Play();
		}

		public void SetPlay(bool m_isPlay)
		{
			isPlay = m_isPlay;
			lookTime = UnityEngine.Random.Range(0.5f, 1.5f);
		}

		public void StartCountAnim()
		{
			anim.speed = 1f;
			moveState = MoveState.Count;
			count_startNum = (int)UnityEngine.Random.Range(1f, 3.9999f);
			count_endNum = count_startNum + (float)((downState == DownState.KnockDown) ? 3 : 7);
			moveAnimVec2.x = 0f;
			moveAnimVec2.y = 0f;
			anim.SetFloat("MoveX", moveAnimVec2.x);
			anim.SetFloat("MoveZ", moveAnimVec2.y);
			anim.SetTrigger("OnCount");
		}

		public void SetCountSound(int num)
		{
			PlayAudio(num);
			eyeAnimationCtrl.SetExpression(15, 2f);
			if (num == 1)
			{
				CPUCtrl.Instance.SetDownLookPlayer();
			}
			if ((float)num == count_startNum)
			{
				if (downState == DownState.KnockOut)
				{
					if (fighterNum_down == 0)
					{
						PlayerCtrl.Instance.EndDownState();
					}
					else
					{
						CPUCtrl.Instance.EndDownState();
					}
				}
				else if (fighterNum_down == 0)
				{
					PlayerCtrl.Instance.WakeDownState();
				}
				else
				{
					CPUCtrl.Instance.WakeDownState();
				}
			}
			else if ((float)num == count_endNum || num == 10)
			{
				if (num != 10)
				{
					anim.SetTrigger("OnIdle");
				}
				if (downState == DownState.KnockOut)
				{
					LocalSingleton<GameManager>.Instance.GameEnd_KO(fighterNum_attack == 0);
				}
				else
				{
					LocalSingleton<GameManager>.Instance.GameContinue();
				}
			}
		}

		public void SetPosition(Transform setPosTr)
		{
			base.transform.position = new Vector3(setPosTr.position.x, base.transform.position.y, setPosTr.position.z);
			base.transform.rotation = setPosTr.rotation;
			moveState = MoveState.Idle;
			anim.Rebind();
		}

		public void SetMoveState(int state)
		{
			switch (state)
			{
			case 0:
				moveState = MoveState.Idle;
				break;
			case 1:
				moveState = MoveState.MiddleTrace;
				break;
			}
		}

		public void PlayAnim(int state)
		{
			switch (state)
			{
			case 0:
				anim.SetTrigger("OnWinL");
				break;
			case 1:
				anim.SetTrigger("OnWinR");
				break;
			case 2:
				anim.SetTrigger("OnStop");
				break;
			case 3:
				anim.SetTrigger("OnKO");
				break;
			}
		}

		public void SetLookAtIK(bool isEnabled)
		{
			faceCtrl.enabled = false;
			spineCtrl.enabled = false;
		}

		public void StartStepBack(int down_fighterNum, DownState state)
		{
			moveState = MoveState.StepBack;
			downState = state;
			fighterNum_down = down_fighterNum;
			SetPlay(m_isPlay: false);
			SetLookState(fighterNum_down);
			arbitrationDir = LocalSingleton<GameManager>.Instance.headTFs[0].position - LocalSingleton<GameManager>.Instance.bodyTFs[1].position;
			arbitrationDir.y = 0f;
			Vector3 position = LocalSingleton<GameManager>.Instance.headTFs[0].position;
			Vector3 vector = Vector3.Cross(arbitrationDir.normalized, Vector3.up);
			if (fighterNum_down == 0)
			{
				arbitrationDir = -arbitrationDir.normalized;
			}
			else
			{
				arbitrationDir = arbitrationDir.normalized;
			}
			fighterNum_attack = ((fighterNum_down == 0) ? 1 : 0);
			Vector3 vector2 = position + vector * 1.3f;
			vector2.y = 0f;
			Vector3 vector3 = position + vector * -1.3f;
			vector3.y = 0f;
			if ((vector2 - base.transform.position).sqrMagnitude > (vector3 - base.transform.position).sqrMagnitude)
			{
				transform_keep.position = vector3;
				transform_keep.rotation = Quaternion.LookRotation(-vector);
			}
			else
			{
				transform_keep.position = vector2;
				transform_keep.rotation = Quaternion.LookRotation(vector);
			}
		}

		public void StepBack()
		{
			idleState = 0.5f;
			idleAnimState = Mathf.MoveTowards(idleAnimState, idleState, Time.deltaTime * 0.5f);
			Vector3 vector = -transform_keep.forward;
			vector.y = 0f;
			vector = vector.normalized;
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(vector), cachedFixedDeltaTime * 10f);
			Vector3 position = transform_keep.position;
			position.y = 0f;
			Vector3 direction = position - base.transform.position;
			direction.y = 0f;
			Vector3 vector2 = base.transform.InverseTransformDirection(direction);
			if (direction.sqrMagnitude >= 0.02f)
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 1f, Time.deltaTime * moveSpeed);
			}
			else
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 0f, Time.deltaTime * moveSpeed);
			}
			if (direction.sqrMagnitude >= 0.005f)
			{
				movePosVec2.x = vector2.x;
				movePosVec2.y = vector2.z;
			}
			else if (direction.sqrMagnitude < 0.005f)
			{
				movePosVec2 = Vector2.zero;
			}
			moveAnimVec2 = Vector2.MoveTowards(moveAnimVec2, movePosVec2.normalized, Time.deltaTime * moveSpeed);
			anim.SetFloat("Idle", idleAnimState);
			anim.SetFloat("Speed", moveAnimState);
			anim.SetFloat("MoveX", moveAnimVec2.x);
			anim.SetFloat("MoveZ", moveAnimVec2.y);
			if (direction.sqrMagnitude <= 0.005f && Vector3.Dot(base.transform.forward, vector) >= 0.98f)
			{
				StartArbitration();
			}
		}

		public void StartArbitration()
		{
			moveState = MoveState.Arbitration;
			SetLookState(fighterNum_attack);
			anim.SetBool("IsRightStop", Vector3.Dot(arbitrationDir, base.transform.right) >= 0f);
			anim.SetTrigger("OnStop");
			moveAnimVec2.x = 0f;
			moveAnimVec2.y = 0f;
			anim.SetFloat("MoveX", moveAnimVec2.x);
			anim.SetFloat("MoveZ", moveAnimVec2.y);
			if (downState == DownState.KO3)
			{
				Invoke("StartGameEndAnim", 1f);
			}
			else
			{
				Invoke("StartLookDownFighter", 1f);
			}
			anim.speed = 1.5f;
		}

		public void StartLookDownFighter()
		{
			moveState = MoveState.LookDownFighter;
			SetLookState(fighterNum_down);
			anim.SetBool("IsRightTurn", Vector3.Dot(arbitrationDir, base.transform.right) < 0f);
			anim.SetTrigger("OnTurn");
			Invoke("StartCountReady", 0.6f);
		}

		public void StartCountReady()
		{
			moveState = MoveState.CountReady;
		}

		public void CountReady()
		{
			idleState = 0.5f;
			idleAnimState = Mathf.MoveTowards(idleAnimState, idleState, Time.deltaTime * 0.5f);
			Vector3 vector = ((fighterNum_attack == 0) ? LocalSingleton<GameManager>.Instance.bodyTFs[1].position : LocalSingleton<GameManager>.Instance.bodyTFs[0].position);
			vector.y = 0f;
			Vector3 vector2 = vector - base.transform.position;
			vector2.y = 0f;
			vector2 = vector2.normalized;
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(vector2), cachedFixedDeltaTime * 10f);
			Vector3 vector3 = LocalSingleton<GameManager>.Instance.bodyTFs[fighterNum_attack].position - LocalSingleton<GameManager>.Instance.bodyTFs[fighterNum_down].position;
			vector3.y = 0f;
			vector3 = vector3.normalized;
			Vector3 a = vector3 + vector;
			a.y = 0f;
			Vector3 b = vector.normalized * -1f + vector;
			b.y = 0f;
			Vector3 vector4 = Vector3.Lerp(a, b, 0.5f);
			vector4.y = 0f;
			vector4 = (vector4 - vector).normalized * 1.5f + vector;
			Vector3 direction = vector4 - base.transform.position;
			direction.y = 0f;
			Vector3 vector5 = base.transform.InverseTransformDirection(direction);
			if (direction.sqrMagnitude >= 0.03f)
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 0.5f, Time.deltaTime * moveSpeed);
			}
			else
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 0f, Time.deltaTime * moveSpeed);
			}
			if (direction.sqrMagnitude >= 0.001f)
			{
				movePosVec2.x = vector5.x;
				movePosVec2.y = vector5.z;
			}
			else if (direction.sqrMagnitude < 0.001f)
			{
				movePosVec2 = Vector2.zero;
				StartCountAnim();
				return;
			}
			moveAnimVec2 = Vector2.MoveTowards(moveAnimVec2, movePosVec2.normalized, Time.deltaTime * moveSpeed * 5f);
			anim.SetFloat("Idle", idleAnimState);
			anim.SetFloat("Speed", moveAnimState);
			anim.SetFloat("MoveX", moveAnimVec2.x);
			anim.SetFloat("MoveZ", moveAnimVec2.y);
		}

		public void StartGameEndAnim()
		{
			anim.SetTrigger("OnEnd");
			LocalSingleton<GameManager>.Instance.GameEnd_KO(fighterNum_attack == 0);
		}

		public void StartEndRound()
		{
			moveState = MoveState.EndRound;
			SetPlay(m_isPlay: false);
			fighterNum_down = ((!(UnityEngine.Random.Range(0f, 1f) >= 0.5f)) ? 1 : 0);
			arbitrationDir = LocalSingleton<GameManager>.Instance.bodyTFs[0].position - LocalSingleton<GameManager>.Instance.bodyTFs[1].position;
			arbitrationDir.y = 0f;
			Vector3 position = LocalSingleton<GameManager>.Instance.bodyTFs[0].position;
			Vector3 vector = Vector3.Cross(arbitrationDir.normalized, Vector3.up);
			if (fighterNum_down == 0)
			{
				arbitrationDir = -arbitrationDir.normalized;
			}
			else
			{
				arbitrationDir = arbitrationDir.normalized;
			}
			Vector3 vector2 = position + vector * 1.3f;
			vector2.y = 0f;
			Vector3 vector3 = position + vector * -1.3f;
			vector3.y = 0f;
			if ((vector2 - base.transform.position).sqrMagnitude > (vector3 - base.transform.position).sqrMagnitude)
			{
				transform_keep.position = vector3;
				transform_keep.rotation = Quaternion.LookRotation(-vector);
			}
			else
			{
				transform_keep.position = vector2;
				transform_keep.rotation = Quaternion.LookRotation(vector);
			}
		}

		private void EndRound()
		{
			idleState = 0.5f;
			idleAnimState = Mathf.MoveTowards(idleAnimState, idleState, Time.deltaTime * 0.5f);
			Vector3 vector = -transform_keep.forward;
			vector.y = 0f;
			vector = vector.normalized;
			base.transform.rotation = Quaternion.Lerp(base.transform.rotation, Quaternion.LookRotation(vector), cachedFixedDeltaTime * 10f);
			Vector3 position = transform_keep.position;
			position.y = 0f;
			Vector3 direction = position - base.transform.position;
			direction.y = 0f;
			Vector3 vector2 = base.transform.InverseTransformDirection(direction);
			if (direction.sqrMagnitude >= 0.02f)
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 1f, Time.deltaTime * moveSpeed);
			}
			else
			{
				moveAnimState = Mathf.MoveTowards(moveAnimState, 0f, Time.deltaTime * moveSpeed);
			}
			if (direction.sqrMagnitude >= 0.005f)
			{
				movePosVec2.x = vector2.x;
				movePosVec2.y = vector2.z;
			}
			else if (direction.sqrMagnitude < 0.005f)
			{
				movePosVec2 = Vector2.zero;
			}
			moveAnimVec2 = Vector2.MoveTowards(moveAnimVec2, movePosVec2.normalized, Time.deltaTime * moveSpeed);
			anim.SetFloat("Idle", idleAnimState);
			anim.SetFloat("Speed", moveAnimState);
			anim.SetFloat("MoveX", moveAnimVec2.x);
			anim.SetFloat("MoveZ", moveAnimVec2.y);
			if (direction.sqrMagnitude <= 0.005f && Vector3.Dot(base.transform.forward, vector) >= 0.98f)
			{
				moveState = MoveState.Idle;
				SetLookState(fighterNum_attack);
				anim.SetBool("IsRightStop", Vector3.Dot(arbitrationDir, base.transform.right) >= 0f);
				anim.SetTrigger("OnStop");
				moveAnimVec2.x = 0f;
				moveAnimVec2.y = 0f;
				anim.SetFloat("MoveX", moveAnimVec2.x);
				anim.SetFloat("MoveZ", moveAnimVec2.y);
			}
		}

		public void StartIdleAnim()
		{
			anim.SetTrigger("OnIdle");
		}
	}
	public class BreakTimeCtrl : MonoBehaviour
	{
		private bool isPlay;

		public Animator[] coachs;

		public GameObject stool;

		private Vector3[] lookPoss;

		private Vector3 lookTarget;

		public Animator girlAnim;

		public MeshRenderer renderer;

		public Texture[] roundBoards;

		public void Start()
		{
			lookPoss = new Vector3[2];
			lookPoss[0] = new Vector3(1.4f, 1.4f, -1.4f);
			lookPoss[1] = new Vector3(1.5f, 1.3f, -1.2f);
			lookTarget = lookPoss[0];
			coachs[0].GetComponent<CustomModelSettingCtrl>().InitRandom(CustomModelViewState.Normal, null, 0f);
			coachs[1].GetComponent<CustomModelSettingCtrl>().InitRandom(CustomModelViewState.Normal, null, 0f);
			girlAnim.gameObject.GetComponent<CustomModelSettingCtrl>().InitRandom(CustomModelViewState.Normal, null, 0f);
			StopCoachAnim();
		}

		public Vector3 GetLookPos()
		{
			return lookTarget;
		}

		public void ChangelookTarget(bool isWater)
		{
			lookTarget = (isWater ? lookPoss[0] : lookPoss[1]);
		}

		public void PlayCoachAnim(Transform lookTr, int nextRound)
		{
			isPlay = true;
			coachs[0].gameObject.SetActive(value: true);
			coachs[1].gameObject.SetActive(value: true);
			stool.SetActive(value: true);
			coachs[0].SetTrigger("Left");
			coachs[1].SetTrigger("Right");
			ChangelookTarget(isWater: false);
			lookTr.position = lookTarget;
			girlAnim.gameObject.SetActive(value: true);
			renderer.sharedMaterials[0].SetTexture("_BaseMap", (nextRound == 2) ? roundBoards[0] : roundBoards[1]);
		}

		public void StopCoachAnim()
		{
			isPlay = false;
			coachs[0].gameObject.SetActive(value: false);
			coachs[1].gameObject.SetActive(value: false);
			stool.SetActive(value: false);
			girlAnim.gameObject.SetActive(value: false);
		}
	}
	public class CPUCtrl : BoxerClass
	{
		public enum ActionState
		{
			Idle,
			Attack,
			Guard,
			KeepInCheckAttack,
			WeavingAttack,
			Groggy,
			Super,
			Down
		}

		public enum LookState
		{
			None,
			Player,
			Coach
		}

		public static CPUCtrl Instance;

		public ActiveRagdollManager ragdoll;

		private Animator anim;

		public GloveCollider[] gloveColliders;

		public Transform playerHeadTF;

		private Transform myTF;

		public CustomModelSettingCtrl cmsCtrl;

		public SpineCtrl spineCtrl;

		public FaceCtrl faceCtrl;

		public AudioSource voiceSource;

		public AudioClip[] voiceClips;

		private bool isStartPunchTime;

		private bool isPlay;

		public Transform limit_pos;

		private Vector3 playerDir;

		private float moveSpeed;

		private Vector2 moveStateVec2;

		private Vector2 moveAnimDir;

		public bool isGuardPerfect;

		private float guardSpeed;

		private Vector2 guardStateVec2;

		private Vector2 guardAnimDir;

		private float guardHoldTime;

		private float dashDelayTime;

		private float weavingTime;

		private float attackDelayTime;

		private int attackCount;

		private int attackSelectNum;

		private bool isAttackTime;

		private int attackSelectNum_keep;

		private float keepInCheckTime;

		private bool isWeavingAttack;

		private Vector2[] damageVec = new Vector2[14];

		private float stateChangeDelayTime;

		public HitEffectCtrl[] punchEffs;

		private float lookAtWeight;

		private float moveX_noise;

		private float randomDashTime;

		private LevelData levelData;

		private int[] attackGloveNums;

		private int aiLevel;

		public BreakTimeCtrl breakTimeCtrl;

		public EyeAnimationCtrl eyeAnimationCtrl;

		private LookState lookState;

		private bool[] isStep = new bool[2];

		private float stepChangeTime;

		private Vector2 stepWeight;

		private Transform playerInitTF;

		private float save_lookHeight = 1.7f;

		private float cachedFixedDeltaTime;

		private CoroutineWrapper attackWrapper;

		private CoroutineWrapper groggyWrapper;

		private CoroutineWrapper damageMoveWrapper;

		private CoroutineWrapper readyWrapper;

		public AnimationCurve damageMoveCurve;

		public GameObject[] gloveMesh;

		public Renderer gloveRenderer;

		private float readyStateBlendForce;

		private float readyStateBlendValue;

		private bool isFixedPos;

		private Vector3 fixedPos;

		public ActionState actionState { get; private set; }

		public bool IsStartPunchTime()
		{
			return isStartPunchTime;
		}

		public bool IsWeaving()
		{
			return weavingTime > 0f;
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			if (Instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			myTF = GetComponent<Transform>();
			anim = GetComponent<Animator>();
			attackWrapper = CoroutineWrapper.Generate(this);
			groggyWrapper = CoroutineWrapper.Generate(this);
			damageMoveWrapper = CoroutineWrapper.Generate(this);
			readyWrapper = CoroutineWrapper.Generate(this);
			cachedFixedDeltaTime = Time.fixedDeltaTime;
			CustomModelData customModelData = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.customModelDatas_single[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1];
			gloveMesh[(!customModelData.Gender.Equals("m")) ? 1u : 0u].SetActive(value: true);
			gloveMesh[customModelData.Gender.Equals("m") ? 1 : 0].SetActive(value: false);
			gloveRenderer = gloveMesh[(!customModelData.Gender.Equals("m")) ? 1u : 0u].GetComponent<SkinnedMeshRenderer>();
			spineCtrl.SetFingerRot((!customModelData.Gender.Equals("m")) ? 1 : 0);
			cmsCtrl.Init(customModelData, CustomModelViewState.Normal, null, 0f);
		}

		private void Start()
		{
			InitData();
		}

		private void InitData()
		{
			aiLevel = SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level;
			LevelData levelData = LocalSingleton<GameManager>.Instance.levelData[aiLevel - 1];
			this.levelData = ScriptableObject.CreateInstance<LevelData>();
			this.levelData.staminaMaxPoint = levelData.staminaMaxPoint;
			this.levelData.staminaSpeed = levelData.staminaSpeed;
			this.levelData.healthMaxPoint = levelData.healthMaxPoint;
			this.levelData.healthSpeed = levelData.healthSpeed;
			this.levelData.attackCount_min = levelData.attackCount_min;
			this.levelData.attackCount_max = levelData.attackCount_max;
			this.levelData.stateChangeTime_min = levelData.stateChangeTime_min;
			this.levelData.stateChangeTime_max = levelData.stateChangeTime_max;
			this.levelData.nextAttackTimes = new float[6];
			this.levelData.attackTimeMag = levelData.attackTimeMag;
			this.levelData.attackGuardDelayTime = levelData.attackGuardDelayTime;
			this.levelData.damageHoldTime = levelData.damageHoldTime;
			this.levelData.keepInCheckProbability = levelData.keepInCheckProbability;
			this.levelData.weavingAttackProbability = levelData.weavingAttackProbability;
			this.levelData.guardProbability = levelData.guardProbability;
			this.levelData.guardReactionProbability = levelData.guardReactionProbability;
			this.levelData.guardSpeed = levelData.guardSpeed;
			this.levelData.groggyTime = levelData.groggyTime;
			this.levelData.spearPoint = levelData.spearPoint;
			this.levelData.damageP = levelData.damageP;
			for (int i = 0; i < this.levelData.nextAttackTimes.Length; i++)
			{
				this.levelData.nextAttackTimes[i] = levelData.nextAttackTimes[i] * this.levelData.attackTimeMag;
			}
			playerHeadTF = Camera.main.transform;
			playerInitTF = LocalSingleton<GameManager>.Instance.setPosTF[0];
			attackGloveNums = new int[6] { 1, 0, 0, 1, 0, 1 };
			actionState = ActionState.Attack;
			attackCount = (int)UnityEngine.Random.Range(this.levelData.attackCount_min, this.levelData.attackCount_max + 0.9999f);
			moveSpeed = 3f;
			guardSpeed = this.levelData.guardSpeed;
			maxStamina = this.levelData.staminaMaxPoint;
			curStamina = maxStamina;
			staminaSpeed = this.levelData.staminaSpeed;
			maxHealth = this.levelData.healthMaxPoint;
			curHealth = maxHealth;
			healthSpeed = this.levelData.healthSpeed;
			damageVec[0] = new Vector2(-0.2f, 0.8f);
			damageVec[1] = new Vector2(0.2f, 0.8f);
			damageVec[2] = new Vector2(-0.6f, 0.6f);
			damageVec[3] = new Vector2(0.6f, 0.6f);
			damageVec[4] = new Vector2(-0.7f, -0.4f);
			damageVec[5] = new Vector2(0.7f, -0.4f);
			damageVec[6] = new Vector2(-1f, 0f);
			damageVec[7] = new Vector2(1f, 0f);
			damageVec[8] = new Vector2(-0.9f, 0.3f);
			damageVec[9] = new Vector2(0.9f, 0.3f);
			damageVec[10] = new Vector2(-0.1f, 0.9f);
			damageVec[11] = new Vector2(0.1f, 0.9f);
			lookAtWeight = 0.1f;
			SetLevelSpeed(isLevelSpeed: false);
			CheckLookPlayer();
		}

		private void SetLevelSpeed(bool isLevelSpeed)
		{
			if (!isLevelSpeed)
			{
				anim.speed = 1f;
				return;
			}
			switch (aiLevel)
			{
			case 0:
				anim.speed = 0.8f;
				break;
			case 1:
				anim.speed = 0.85f;
				break;
			case 2:
				anim.speed = 0.9f;
				break;
			case 3:
				anim.speed = 0.95f;
				break;
			case 4:
				anim.speed = 1f;
				break;
			}
		}

		private void CheckLookPlayer()
		{
			if (lookState != 0 && lookAtWeight != 1f)
			{
				lookAtWeight = Mathf.MoveTowards(lookAtWeight, 1f, Time.deltaTime * 3f);
				spineCtrl.weight_master = lookAtWeight;
			}
			else if (lookState == LookState.None && lookAtWeight != 0f)
			{
				lookAtWeight = Mathf.MoveTowards(lookAtWeight, 0f, Time.deltaTime * 3f);
				spineCtrl.weight_master = lookAtWeight;
			}
		}

		private void Update()
		{
			CheckPlayerDirection();
		}

		private void FixedUpdate()
		{
			CheckDelayTimes();
			if (isStartPunchTime || isPlay)
			{
				MoveCPU();
			}
			if (!isPlay || this.actionState == ActionState.Groggy || this.actionState == ActionState.Down)
			{
				return;
			}
			if (LocalSingleton<GameManager>.Instance.testMode == GameManager.TestMode.Stand && this.actionState == ActionState.Attack)
			{
				this.actionState = ActionState.Guard;
			}
			switch (this.actionState)
			{
			case ActionState.Attack:
				CheckAttackState();
				break;
			case ActionState.Guard:
				CheckGuardState();
				break;
			case ActionState.KeepInCheckAttack:
				attackCount++;
				attackSelectNum = (int)UnityEngine.Random.Range(0f, 1.9999f);
				SetAttackState();
				break;
			case ActionState.WeavingAttack:
				if (isWeavingAttack)
				{
					attackCount++;
					attackSelectNum = (int)UnityEngine.Random.Range(0f, 5.9999f);
					SetAttackState();
				}
				break;
			}
			if (!(stateChangeDelayTime > 0f) && !(guardHoldTime > 0f))
			{
				stateChangeDelayTime = UnityEngine.Random.Range(levelData.stateChangeTime_min, levelData.stateChangeTime_max);
				ActionState actionState = this.actionState;
				if (actionState == ActionState.Guard)
				{
					this.actionState = ActionState.Attack;
					attackCount = (int)UnityEngine.Random.Range(levelData.attackCount_min, levelData.attackCount_max + 0.9999f);
				}
			}
		}

		private void CheckPlayerDirection()
		{
			Vector3 position = playerHeadTF.position;
			Vector3 vector = myTF.position;
			vector.y = 0f;
			playerDir = position - vector;
			playerDir.y = 0f;
			float num = Mathf.Lerp(0.3f, 1.1f, position.y - 1f);
			float magnitude = playerDir.magnitude;
			if (actionState != ActionState.Groggy && magnitude < num)
			{
				vector = position + playerDir.normalized * (0f - num);
				vector.y = 0f;
			}
			Vector3 vector2 = vector - limit_pos.position;
			vector2.y = 0f;
			if (vector2.magnitude > 1.7f)
			{
				vector = limit_pos.position + vector2.normalized * 1.7f;
				vector.y = 0f;
			}
			float num2 = 3f;
			if (vector.x > num2)
			{
				vector.x = num2;
			}
			else if (vector.x < 0f - num2)
			{
				vector.x = 0f - num2;
			}
			if (vector.z > num2)
			{
				vector.z = num2;
			}
			else if (vector.z < 0f - num2)
			{
				vector.z = 0f - num2;
			}
			myTF.position = Vector3.Lerp(myTF.position, vector, Time.deltaTime * 5f);
			Vector3 position2 = ragdoll.bones[RagdollBones.Head].origin.position;
			playerDir = position - position2;
			playerDir.y = 0f;
		}

		private void LateUpdate()
		{
			readyStateBlendForce = Mathf.Clamp(readyStateBlendForce + UnityEngine.Random.Range(-5f, 5f) * Time.deltaTime, -0.5f, 0.5f);
			readyStateBlendValue = Mathf.Clamp(readyStateBlendValue + readyStateBlendForce * Time.deltaTime, 0f, 1f);
			anim.SetFloat("IdleState", readyStateBlendValue);
			SetLookPosition();
			CheckLookPlayer();
			CheckStepState();
			FixedPositionUpdate();
			if (isPlay)
			{
				Recovery(actionState != ActionState.Groggy);
			}
		}

		private void SetLookPosition()
		{
			switch (lookState)
			{
			case LookState.Player:
				faceCtrl.targetTF.position = Vector3.MoveTowards(faceCtrl.targetTF.position, playerHeadTF.position, Time.deltaTime * 2f);
				break;
			case LookState.Coach:
				faceCtrl.targetTF.position = Vector3.MoveTowards(faceCtrl.targetTF.position, breakTimeCtrl.GetLookPos() + Vector3.up * 0.1f, Time.deltaTime * 0.5f);
				break;
			case LookState.None:
				break;
			}
		}

		private void CheckStepState()
		{
			stepChangeTime -= Time.deltaTime;
			if (stepChangeTime <= 0f)
			{
				stepChangeTime = (isStep[0] ? UnityEngine.Random.Range(1f, 2f) : UnityEngine.Random.Range(0.5f, 1f));
				isStep[0] = !isStep[0];
				isStep[1] = UnityEngine.Random.Range(0f, 1f) >= 0.5f;
			}
			if (isStep[0])
			{
				stepWeight.x = Mathf.MoveTowards(stepWeight.x, 1f, Time.deltaTime * 5f);
			}
			else
			{
				stepWeight.x = Mathf.MoveTowards(stepWeight.x, 0f, Time.deltaTime * 5f);
			}
			if (isStep[1])
			{
				stepWeight.y = Mathf.MoveTowards(stepWeight.y, 1f, Time.deltaTime * 3.5f);
			}
			else
			{
				stepWeight.y = Mathf.MoveTowards(stepWeight.y, 0f, Time.deltaTime * 3.5f);
			}
			anim.SetFloat("MoveState", stepWeight.x);
		}

		public void SetFixedPosition(bool isFixed)
		{
			isFixedPos = isFixed;
			fixedPos = myTF.position;
		}

		public void FixedPositionUpdate()
		{
			if (isFixedPos)
			{
				myTF.position = fixedPos;
			}
		}

		public void SetLookPlayer(bool m_isLookPlayer)
		{
			lookState = (m_isLookPlayer ? LookState.Player : LookState.None);
			spineCtrl.weight_head = 0.35f;
			spineCtrl.weight_neck = 0.1f;
			spineCtrl.weight_spines = 1f;
		}

		public void SetDownLookPlayer()
		{
			lookState = LookState.Player;
			spineCtrl.weight_head = 0.2f;
			spineCtrl.weight_neck = 0f;
			spineCtrl.weight_spines = 0.1f;
		}

		private void StartEffect(Vector3 pos, int handNum, float force, bool isGuard)
		{
			punchEffs[handNum].StartEffect(pos, isGuard, force);
		}

		public override void CheckAttack(Collision collision, bool isRight)
		{
			int num = (isRight ? 1 : 0);
			if (!isAttackTime || attackGloveNums[attackSelectNum_keep] != num || !isPlay || actionState == ActionState.Super || actionState == ActionState.Down)
			{
				return;
			}
			Collider collider = collision.collider;
			if (!collider.CompareTag("MainCamera") && !collider.CompareTag("Player_Glove") && !collider.CompareTag("Player_Arm"))
			{
				return;
			}
			if (collider.CompareTag("Player_Glove") || collider.CompareTag("Player_Arm"))
			{
				gloveColliders[num].isCheckCollider.CurrentData = false;
				StartEffect(collider.transform.position - playerDir.normalized * 0.2f, num, 0.75f, isGuard: true);
				isAttackTime = false;
				LocalSingleton<GameManager>.Instance.guard_s++;
				ragdoll.SetAnimSyncState(ActiveRagdollManager.AnimSyncState.Physics);
				if (!(levelData.guardReactionProbability >= UnityEngine.Random.Range(0f, 1f)))
				{
					return;
				}
				switch ((int)UnityEngine.Random.Range(0f, 2.9999f))
				{
				case 0:
					attackDelayTime = 0f;
					stateChangeDelayTime = UnityEngine.Random.Range(levelData.stateChangeTime_min, levelData.stateChangeTime_max);
					actionState = ActionState.Guard;
					break;
				case 1:
					anim.SetTrigger("OnDash");
					switch ((int)UnityEngine.Random.Range(0f, 2.9999f))
					{
					case 0:
						anim.SetInteger("DashNum", 1);
						break;
					case 1:
						anim.SetInteger("DashNum", ((int)UnityEngine.Random.Range(0f, 1.9999f) == 1) ? 3 : 4);
						break;
					case 2:
						anim.SetInteger("DashNum", ((int)UnityEngine.Random.Range(0f, 1.9999f) == 1) ? 6 : 7);
						break;
					}
					dashDelayTime = 1.2f;
					attackDelayTime = 0.5f;
					break;
				case 2:
					attackDelayTime = 0.2f;
					break;
				}
			}
			else if (collider.CompareTag("MainCamera"))
			{
				gloveColliders[num].isCheckCollider.CurrentData = false;
				StartEffect(collider.transform.position - playerDir.normalized * 0.2f, num, 0.75f, isGuard: false);
				isAttackTime = false;
				PlayerCtrl.Instance.StartDamage(damageVec[attackSelectNum], levelData.damageP);
			}
			else if (collider.CompareTag("Player_Body"))
			{
				StartEffect(collider.transform.position, num, 0.75f, isGuard: false);
			}
		}

		public void SetHeadForce(Define.PlayerGloveState punchType, Vector3 veloc, float mag)
		{
			if (!isPlay || actionState == ActionState.Super || actionState == ActionState.Down)
			{
				LocalSingleton<GameManager>.Instance.attack_f++;
				return;
			}
			LocalSingleton<GameManager>.Instance.attack_s++;
			if (aiLevel == 0)
			{
				attackCount = 0;
			}
			float num;
			switch (punchType)
			{
			case Define.PlayerGloveState.Straight:
				num = -20f * mag;
				break;
			case Define.PlayerGloveState.HookL:
			case Define.PlayerGloveState.HookR:
				num = -30f * mag;
				break;
			default:
				num = -20f * mag;
				break;
			}
			SetHP(num);
			SetST(num * 4f);
			ragdoll.SetDamage(ActiveRagdollManager.DamagePosition.Head, veloc);
			attackDelayTime = levelData.damageHoldTime;
			dashDelayTime += 0.5f;
			eyeAnimationCtrl.SetExpression(4, 0.5f);
			DamageVoice();
			if (curStamina <= 0f)
			{
				actionState = ActionState.Down;
				LocalSingleton<GameManager>.Instance.CPUDown(curHealth / maxHealth);
			}
			else if (actionState != ActionState.Groggy && curStamina / maxStamina <= 0.5f)
			{
				StartGroggyState();
			}
			else if (actionState != ActionState.Groggy && actionState != ActionState.Down && levelData.guardProbability > UnityEngine.Random.Range(0f, 1f))
			{
				attackDelayTime = 0f;
				stateChangeDelayTime = UnityEngine.Random.Range(levelData.stateChangeTime_min, levelData.stateChangeTime_max);
				actionState = ActionState.Guard;
			}
		}

		public void SetBodyForce(Vector3 veloc, float mag)
		{
			if (!isPlay || actionState == ActionState.Super || actionState == ActionState.Down)
			{
				LocalSingleton<GameManager>.Instance.attack_f++;
				return;
			}
			LocalSingleton<GameManager>.Instance.attack_s++;
			float num = -20f * mag;
			SetHP(num);
			SetST(num * 4f);
			ragdoll.SetDamage(ActiveRagdollManager.DamagePosition.Head, veloc);
			attackCount = 0;
			attackDelayTime = levelData.damageHoldTime;
			dashDelayTime += 0.5f;
			eyeAnimationCtrl.SetExpression(4, 0.5f);
			DamageVoice();
			if (curStamina <= 0f)
			{
				actionState = ActionState.Down;
				LocalSingleton<GameManager>.Instance.CPUDown(curHealth / maxHealth);
			}
			else if (actionState != ActionState.Groggy && curStamina / maxStamina <= 0.5f)
			{
				StartGroggyState();
			}
			else if (actionState != ActionState.Groggy && actionState != ActionState.Down && levelData.guardProbability > UnityEngine.Random.Range(0f, 1f))
			{
				attackDelayTime = 0f;
				stateChangeDelayTime = UnityEngine.Random.Range(levelData.stateChangeTime_min, levelData.stateChangeTime_max);
				actionState = ActionState.Guard;
			}
		}

		public void SetGuardForce(Vector3 veloc, bool isHead)
		{
			if (isPlay && actionState != ActionState.Super && actionState != ActionState.Down)
			{
				if (isHead)
				{
					ragdoll.SetDamage(ActiveRagdollManager.DamagePosition.Guard_Head, veloc);
				}
				else
				{
					ragdoll.SetDamage(ActiveRagdollManager.DamagePosition.Guard_Body, veloc);
				}
			}
		}

		private void MoveCPU()
		{
			float num = Vector3.Dot(myTF.forward, Vector3.forward);
			float num2 = Vector3.Dot(myTF.forward, -Vector3.right);
			moveX_noise += UnityEngine.Random.Range(-0.02f, 0.02f);
			if (num > num2)
			{
				moveX_noise += (num - num2) * 0.1f;
			}
			else if (num < num2)
			{
				moveX_noise -= (num2 - num) * 0.1f;
			}
			else
			{
				moveX_noise = 0f;
			}
			moveX_noise = Mathf.Clamp(moveX_noise, -1f, 1f);
			Vector3 position = playerHeadTF.position;
			Vector3 worldCenterOfMass = ragdoll.bones[RagdollBones.Head].ragdoll_RB.worldCenterOfMass;
			Vector3 forward = position - myTF.position + myTF.forward * 3f;
			forward.y = 0f;
			myTF.rotation = Quaternion.Lerp(myTF.rotation, Quaternion.LookRotation(forward), cachedFixedDeltaTime * 10f);
			Vector3 direction = position - worldCenterOfMass;
			direction = myTF.InverseTransformDirection(direction);
			direction.y = 0f;
			if (isPlay)
			{
				if (direction.sqrMagnitude > 1f)
				{
					direction = direction.normalized;
					moveStateVec2.x = direction.x + moveX_noise;
					moveStateVec2.y = direction.z;
					moveStateVec2 = moveStateVec2.normalized;
				}
				else if (direction.sqrMagnitude < 0.9f)
				{
					direction = direction.normalized;
					moveStateVec2.x = 0f - direction.x + moveX_noise;
					moveStateVec2.y = 0f - direction.z;
					moveStateVec2 = moveStateVec2.normalized;
				}
				else if (direction.sqrMagnitude <= 1f && direction.sqrMagnitude >= 0.9f)
				{
					moveStateVec2 = Vector2.zero;
					moveStateVec2.x = moveX_noise;
					moveStateVec2.y = 0f;
					moveStateVec2 = moveStateVec2.normalized;
				}
			}
			else if (direction.sqrMagnitude >= 1.9f)
			{
				direction = direction.normalized;
				moveStateVec2.x = direction.x + moveX_noise;
				moveStateVec2.y = direction.z;
				moveStateVec2 = moveStateVec2.normalized;
			}
			else if (direction.sqrMagnitude <= 1.4f)
			{
				direction = direction.normalized;
				moveStateVec2.x = 0f - direction.x + moveX_noise;
				moveStateVec2.y = 0f - direction.z;
				moveStateVec2 = moveStateVec2.normalized;
			}
			else if (direction.sqrMagnitude <= 1.75f && direction.sqrMagnitude >= 1.5f)
			{
				moveStateVec2 = Vector2.zero;
				moveStateVec2.x = moveX_noise;
				moveStateVec2.y = 0f;
				moveStateVec2 = moveStateVec2.normalized;
			}
			moveAnimDir = Vector2.MoveTowards(moveAnimDir, moveStateVec2, cachedFixedDeltaTime * moveSpeed);
			anim.SetFloat("MoveX", moveAnimDir.x);
			anim.SetFloat("MoveZ", moveAnimDir.y);
		}

		private void CheckDelayTimes()
		{
			if (stateChangeDelayTime > 0f)
			{
				stateChangeDelayTime -= cachedFixedDeltaTime;
			}
			if (dashDelayTime > 0f)
			{
				dashDelayTime -= cachedFixedDeltaTime;
			}
			if (weavingTime > 0f)
			{
				weavingTime -= cachedFixedDeltaTime;
			}
			if (attackDelayTime > 0f)
			{
				attackDelayTime -= cachedFixedDeltaTime;
			}
			else
			{
				gloveColliders[0].isCheckCollider.CurrentData = false;
				gloveColliders[1].isCheckCollider.CurrentData = false;
			}
			if (randomDashTime > 0f)
			{
				randomDashTime -= cachedFixedDeltaTime;
			}
			if (guardHoldTime > 0f)
			{
				guardHoldTime -= cachedFixedDeltaTime;
			}
			if (keepInCheckTime > 0f)
			{
				keepInCheckTime -= cachedFixedDeltaTime;
			}
			if (actionState == ActionState.Guard)
			{
				if (guardAnimDir.y > 0.3f)
				{
					isGuardPerfect = true;
				}
			}
			else
			{
				isGuardPerfect = false;
			}
		}

		private void CheckGuardState()
		{
			Define.PlayerGloveState[] gloveState = PlayerCtrl.Instance.GetGloveState();
			if (gloveState[0] != 0 || gloveState[1] != 0)
			{
				guardStateVec2.x = 0f;
				guardStateVec2.y = 0.5f;
				guardHoldTime = UnityEngine.Random.Range(0.4f, 0.6f);
			}
			else if (gloveState[0] == Define.PlayerGloveState.Idle && gloveState[1] == Define.PlayerGloveState.Idle && guardAnimDir.x - guardStateVec2.x <= 0.01f && guardAnimDir.y - guardStateVec2.y <= 0.01f && guardHoldTime <= 0f)
			{
				guardStateVec2.x = 0f;
				guardStateVec2.y = 0f;
			}
			if (dashDelayTime <= 0f && randomDashTime <= 0f)
			{
				randomDashTime = UnityEngine.Random.Range(0.5f, 2f);
				CalcDotAndCross(out var dot, out var cross);
				if (dot <= 0.35f)
				{
					if (cross.y >= 0.35f)
					{
						anim.SetInteger("DashNum", (int)UnityEngine.Random.Range(2f, 4.9999f));
					}
					else if (cross.y < -0.35f)
					{
						anim.SetInteger("DashNum", (int)UnityEngine.Random.Range(5f, 7.9999f));
					}
					else
					{
						anim.SetInteger("DashNum", 1);
					}
				}
				else if (UnityEngine.Random.Range(0f, 1f) >= 0.5f)
				{
					anim.SetInteger("DashNum", (int)UnityEngine.Random.Range(8f, 10.9999f));
				}
				else if (Vector3.Dot(myTF.forward, Vector3.forward) >= Vector3.Dot(myTF.forward, -Vector3.right) && Vector3.Dot(myTF.forward, Vector3.forward) >= 0.3f)
				{
					anim.SetInteger("DashNum", ((int)UnityEngine.Random.Range(1.5f, 2.9999f) != 2) ? 1 : ((int)UnityEngine.Random.Range(5f, 7.9999f)));
				}
				else if (Vector3.Dot(myTF.forward, Vector3.forward) <= Vector3.Dot(myTF.forward, -Vector3.right) && Vector3.Dot(myTF.forward, -Vector3.right) >= 0.3f)
				{
					anim.SetInteger("DashNum", ((int)UnityEngine.Random.Range(1.5f, 2.9999f) != 2) ? 1 : ((int)UnityEngine.Random.Range(2f, 4.9999f)));
				}
				else
				{
					anim.SetInteger("DashNum", (int)UnityEngine.Random.Range(1.5f, 7.9999f));
				}
				anim.SetTrigger("OnDash");
				dashDelayTime = 1f;
				attackDelayTime = 0.3f;
				int integer = anim.GetInteger("DashNum");
				if (integer == 3 || integer == 6 || integer == 8 || integer == 9)
				{
					attackDelayTime = 0.3f;
					weavingTime = 0.3f;
					if (levelData.weavingAttackProbability > UnityEngine.Random.Range(0f, 1f))
					{
						isWeavingAttack = true;
						actionState = ActionState.WeavingAttack;
					}
				}
			}
			SetGuardState();
		}

		private void CalcDotAndCross(out float dot, out Vector3 cross)
		{
			Vector3 rhs = myTF.position - playerInitTF.position;
			dot = Vector3.Dot(playerInitTF.forward, rhs);
			rhs.y = 0f;
			cross = Vector3.Cross(playerInitTF.forward, rhs);
		}

		private void SetGuardState()
		{
			guardAnimDir.x = Mathf.MoveTowards(guardAnimDir.x, guardStateVec2.x, cachedFixedDeltaTime * guardSpeed);
			guardAnimDir.y = Mathf.MoveTowards(guardAnimDir.y, guardStateVec2.y, cachedFixedDeltaTime * guardSpeed);
			anim.SetFloat("GuardX", Mathf.Clamp(guardAnimDir.x, -1f, 1f));
			anim.SetFloat("GuardZ", Mathf.Clamp(guardAnimDir.y, -1f, 1f));
		}

		private void CheckAttackState()
		{
			guardAnimDir.x = Mathf.MoveTowards(guardAnimDir.x, 0f, cachedFixedDeltaTime * guardSpeed);
			guardAnimDir.y = Mathf.MoveTowards(guardAnimDir.y, 0f, cachedFixedDeltaTime * guardSpeed);
			anim.SetFloat("GuardX", guardAnimDir.x);
			anim.SetFloat("GuardZ", guardAnimDir.y);
			if (attackCount <= 0)
			{
				if (attackDelayTime <= 0f)
				{
					isAttackTime = false;
					stateChangeDelayTime = UnityEngine.Random.Range(levelData.stateChangeTime_min, levelData.stateChangeTime_max);
					actionState = ActionState.Guard;
				}
			}
			else if (playerDir.sqrMagnitude <= 2.2f)
			{
				if (dashDelayTime <= 0f && randomDashTime <= 0f)
				{
					randomDashTime = UnityEngine.Random.Range(1f, 2f);
					CalcDotAndCross(out var dot, out var cross);
					if (dot <= 0.35f)
					{
						if (cross.y >= 0.35f)
						{
							anim.SetInteger("DashNum", (int)UnityEngine.Random.Range(2f, 4.9999f));
						}
						else if (cross.y < -0.35f)
						{
							anim.SetInteger("DashNum", (int)UnityEngine.Random.Range(5f, 7.9999f));
						}
						else
						{
							anim.SetInteger("DashNum", 1);
						}
					}
					else if (Vector3.Dot(myTF.forward, Vector3.forward) >= Vector3.Dot(myTF.forward, -Vector3.right) && Vector3.Dot(myTF.forward, Vector3.forward) >= 0.3f)
					{
						anim.SetInteger("DashNum", 6);
					}
					else if (Vector3.Dot(myTF.forward, Vector3.forward) <= Vector3.Dot(myTF.forward, -Vector3.right) && Vector3.Dot(myTF.forward, -Vector3.right) >= 0.3f)
					{
						anim.SetInteger("DashNum", 3);
					}
					else
					{
						anim.SetInteger("DashNum", (int)UnityEngine.Random.Range(2.7f, 3.9999f));
					}
					anim.SetTrigger("OnDash");
					dashDelayTime = 1f;
					attackDelayTime = 0.2f;
					int integer = anim.GetInteger("DashNum");
					if ((integer == 3 || integer == 6) && levelData.weavingAttackProbability > UnityEngine.Random.Range(0f, 1f))
					{
						isWeavingAttack = true;
						weavingTime = 0.3f;
						actionState = ActionState.WeavingAttack;
					}
				}
				else if (dashDelayTime <= 0f && playerDir.sqrMagnitude <= 0.7f)
				{
					anim.SetInteger("DashNum", 1);
					anim.SetTrigger("OnDash");
					dashDelayTime = 1f;
					attackDelayTime = 0.2f;
				}
				else
				{
					if (!(attackDelayTime <= 0f))
					{
						return;
					}
					int num = attackSelectNum;
					int i = 0;
					if (playerDir.sqrMagnitude <= 0.8f)
					{
						for (; i <= 1; i++)
						{
							if (num != attackSelectNum)
							{
								break;
							}
							num = (int)Mathf.Abs(UnityEngine.Random.Range(-0.9999f, 5.9999f));
							if (playerHeadTF.position.y <= 1.3f && num == 3)
							{
								num = (int)UnityEngine.Random.Range(0f, 1.9999f);
							}
						}
						attackSelectNum = num;
						SetAttackState();
					}
					else if (playerDir.sqrMagnitude <= 1.5f)
					{
						for (; i <= 1; i++)
						{
							if (num != attackSelectNum)
							{
								break;
							}
							num = (int)UnityEngine.Random.Range(0f, 1.9999f);
						}
						attackSelectNum = num;
						SetAttackState();
					}
					else if (dashDelayTime <= 0f && playerDir.sqrMagnitude >= 1f)
					{
						anim.SetInteger("DashNum", 0);
						anim.SetTrigger("OnDash");
						dashDelayTime = 1f;
						attackDelayTime = 0.15f;
					}
				}
			}
			else
			{
				if (!(dashDelayTime <= 0f) || !(randomDashTime <= 0f) || !(playerDir.sqrMagnitude > 1f))
				{
					return;
				}
				if (keepInCheckTime <= 0f)
				{
					if (levelData.keepInCheckProbability > UnityEngine.Random.Range(0f, 1f))
					{
						keepInCheckTime = 1.5f;
						actionState = ActionState.KeepInCheckAttack;
					}
				}
				else
				{
					anim.SetTrigger("OnDash");
					anim.SetInteger("DashNum", 0);
					randomDashTime = UnityEngine.Random.Range(1f, 2f);
					dashDelayTime = 1f;
					attackDelayTime = 0.15f;
				}
			}
		}

		private void SetAttackState()
		{
			gloveColliders[0].isCheckCollider.CurrentData = true;
			gloveColliders[1].isCheckCollider.CurrentData = true;
			eyeAnimationCtrl.SetExpression(3, 0.5f);
			anim.SetInteger("AttackNum", attackSelectNum);
			anim.SetTrigger("OnAttack");
			attackDelayTime = levelData.nextAttackTimes[attackSelectNum] + ((attackCount != 1) ? 0f : 0.2f);
			dashDelayTime = attackDelayTime + 0.2f;
			attackCount--;
			if (actionState == ActionState.KeepInCheckAttack || actionState == ActionState.WeavingAttack)
			{
				if (attackCount > 0)
				{
					actionState = ActionState.Attack;
				}
				else
				{
					actionState = ActionState.Guard;
				}
			}
			if (attackWrapper.IsPlaying)
			{
				attackWrapper.Stop();
			}
			attackWrapper.Start(DelayAttackTimeCoroutine());
			IEnumerator DelayAttackTimeCoroutine()
			{
				yield return YieldInstructionCache.WaitForSeconds(levelData.nextAttackTimes[attackSelectNum] * 0.25f);
				isAttackTime = true;
				attackSelectNum_keep = attackSelectNum;
				yield return YieldInstructionCache.WaitForSeconds(levelData.nextAttackTimes[attackSelectNum] * 0.75f);
				isAttackTime = false;
			}
		}

		public void SetPlay(bool m_isPlay)
		{
			isPlay = m_isPlay;
			SetLevelSpeed(isPlay);
			if (isPlay)
			{
				dashDelayTime = 0f;
				randomDashTime = 0f;
			}
		}

		public void StartGroggyState()
		{
			actionState = ActionState.Groggy;
			isAttackTime = false;
			SetLevelSpeed(isLevelSpeed: false);
			anim.SetTrigger("OnGroggy");
			anim.SetBool("IsGroggy", value: true);
			Vector3 position = playerHeadTF.position;
			Vector3 vector = myTF.position - position;
			vector.y = 0f;
			Vector3 vector2 = position + vector.normalized * 0.8f;
			vector2.y = 0f;
			vector = vector2 - PlayerCtrl.Instance.transform.position;
			vector.y = 0f;
			if (vector.magnitude > 1.5f)
			{
				vector = vector.normalized * 1.5f;
			}
			vector2 = PlayerCtrl.Instance.transform.position + vector;
			vector2.y = 0f;
			myTF.position = vector2;
			groggyWrapper.Start(EndGroggyCoroutine());
			IEnumerator EndGroggyCoroutine()
			{
				float timeCount = 0.5f;
				while (timeCount <= 0f)
				{
					playerDir = playerHeadTF.position - myTF.position;
					playerDir.y = 0f;
					if (playerDir.magnitude > 0.6f)
					{
						myTF.parent.position += playerDir.normalized * (0.6f - playerDir.magnitude);
						playerDir = playerHeadTF.position - myTF.position;
						playerDir.y = 0f;
					}
					timeCount -= cachedFixedDeltaTime;
					yield return YieldInstructionCache.WaitForFixedUpdate;
				}
				yield return YieldInstructionCache.WaitForSeconds(levelData.groggyTime);
				actionState = ActionState.Super;
				anim.SetBool("IsGroggy", value: false);
				dashDelayTime = 0.7f;
				attackDelayTime = 0.5f;
				curStamina = maxStamina * 0.8f;
				yield return YieldInstructionCache.WaitForSeconds(1.5f);
				SetLevelSpeed(isLevelSpeed: true);
				actionState = ActionState.Guard;
				anim.SetBool("IsMove", value: true);
				CheckGuardState();
			}
		}

		public void StopGroggyCoroutine()
		{
			if (groggyWrapper.IsPlaying)
			{
				groggyWrapper.Stop();
			}
		}

		public int StartDownState()
		{
			StopGroggyCoroutine();
			isPlay = false;
			actionState = ActionState.Down;
			isAttackTime = false;
			anim.speed = 1f;
			int num = (int)UnityEngine.Random.Range(0f, 1.9999f);
			if (GetHealthRatio() <= 0.6f)
			{
				num = (int)UnityEngine.Random.Range(2f, 6.9999f);
			}
			anim.SetInteger("DownNum", num);
			anim.SetTrigger("OnDown");
			eyeAnimationCtrl.SetExpression(4, 3f);
			PlayerCtrl.Instance.StartBackMove();
			return num;
		}

		public void ResetState()
		{
			StartCoroutine(ResetStateCoroutine());
			IEnumerator ResetStateCoroutine()
			{
				float timeCount = 0f;
				while (timeCount <= 1f)
				{
					guardAnimDir.x = Mathf.MoveTowards(guardAnimDir.x, 0f, Time.deltaTime * 3f);
					guardAnimDir.y = Mathf.MoveTowards(guardAnimDir.y, 0f, Time.deltaTime * 3f);
					anim.SetFloat("GuardX", guardAnimDir.x);
					anim.SetFloat("GuardZ", guardAnimDir.y);
					timeCount += Time.deltaTime;
					yield return null;
				}
			}
		}

		public void EndDownState()
		{
			anim.SetTrigger("OnKO");
		}

		public void WakeDownState()
		{
			guardAnimDir.x = 0f;
			guardAnimDir.y = 0f;
			anim.SetFloat("GuardX", guardAnimDir.x);
			anim.SetFloat("GuardZ", guardAnimDir.y);
			anim.SetTrigger("OnWake");
			eyeAnimationCtrl.SetExpression(4, 3f);
			curStamina = maxStamina;
		}

		public void SetPosition(Transform setPosTr)
		{
			if (damageMoveWrapper.IsPlaying)
			{
				damageMoveWrapper.Stop();
			}
			myTF.position = new Vector3(setPosTr.position.x, 0f, setPosTr.position.z);
			myTF.rotation = setPosTr.rotation;
			anim.Rebind();
			ragdoll.SetAnimSyncState(ActiveRagdollManager.AnimSyncState.Anim, isSmooth: false);
			ragdoll.RefrashRagdoll();
			actionState = ActionState.Attack;
			isAttackTime = false;
			faceCtrl.targetTF.position = playerHeadTF.position;
		}

		private void DamageVoice()
		{
			voiceSource.clip = voiceClips[(int)UnityEngine.Random.Range(0f, (float)voiceClips.Length - 0.0001f)];
			voiceSource.Play();
		}

		public void SetAnim(int state)
		{
			switch (state)
			{
			case 1:
				anim.SetTrigger("OnTurn");
				ResetState();
				break;
			case 2:
				anim.SetTrigger("OnResult");
				break;
			case 3:
				anim.SetTrigger("OnWin");
				break;
			case 4:
				anim.SetTrigger("OnLose");
				break;
			case 5:
				spineCtrl.enabled = true;
				anim.enabled = true;
				anim.SetTrigger("OnStartIdle");
				break;
			case 6:
				anim.SetTrigger("OnAppear");
				break;
			}
		}

		public void PlayReadyAnim(int state)
		{
			switch (state)
			{
			case 0:
				if (readyWrapper.IsPlaying)
				{
					readyWrapper.Stop();
				}
				readyWrapper.Start(ReadyStateCoroutine());
				break;
			case 1:
				if (readyWrapper.IsPlaying)
				{
					readyWrapper.Stop();
				}
				anim.SetInteger("ReadyStateNum", 1);
				anim.SetTrigger("OnReady");
				Invoke("DelaySetStateAnim", 0.5f);
				break;
			case 2:
				anim.SetInteger("ReadyStateNum", 2);
				anim.SetTrigger("OnReady");
				break;
			case 3:
				anim.SetTrigger("OnIdle");
				break;
			case 4:
				anim.SetInteger("ReadyStateNum", 3);
				anim.SetTrigger("OnReady");
				isStartPunchTime = true;
				break;
			case 5:
				anim.SetInteger("ReadyStateNum", 5);
				anim.SetTrigger("OnReady");
				break;
			case 6:
				anim.SetInteger("ReadyStateNum", 6);
				anim.SetTrigger("OnReady");
				isStartPunchTime = true;
				break;
			}
			IEnumerator ReadyStateCoroutine()
			{
				while (true)
				{
					anim.SetInteger("ReadyStateNum", (int)UnityEngine.Random.Range(10f, 13.9999f));
					anim.SetTrigger("OnReady");
					yield return YieldInstructionCache.WaitForSeconds(UnityEngine.Random.Range(1.5f, 3f));
				}
			}
		}

		private void DelaySetStateAnim()
		{
			anim.SetInteger("ReadyStateNum", (int)UnityEngine.Random.Range(10f, 13.9999f));
		}

		public void StartPlay()
		{
			if (isStartPunchTime)
			{
				isStartPunchTime = false;
				PlayerCtrl.Instance.SetPlay();
				anim.SetTrigger("OnIdle");
				SetPlay(m_isPlay: true);
			}
		}

		public void StartBreakTime(Transform setPosTr, int nextRound)
		{
			breakTimeCtrl.PlayCoachAnim(myTF, nextRound);
			isPlay = false;
			SetPosition(setPosTr);
			lookState = LookState.Coach;
			spineCtrl.weight_head = 0.8f;
			spineCtrl.weight_neck = 0.2f;
			spineCtrl.weight_spines = 0.5f;
			save_lookHeight = spineCtrl.lookHeight;
			spineCtrl.lookHeight = save_lookHeight - 0.7f;
			curStamina = maxStamina;
			anim.SetTrigger("OnBreakTime");
		}

		public void StopBreakTime()
		{
			spineCtrl.lookHeight = save_lookHeight;
			breakTimeCtrl.StopCoachAnim();
		}

		public void StartCamWave()
		{
			PlayerCtrl.Instance.StartCamWave();
		}

		public void StartDamageMove(float backDist)
		{
			if (damageMoveWrapper.IsPlaying)
			{
				damageMoveWrapper.Stop();
			}
			Vector3 vector = playerHeadTF.position - myTF.position;
			vector.y = 0f;
			vector = vector.normalized * backDist;
			damageMoveWrapper.Start(DamageMoveCoroutine(vector));
		}

		private IEnumerator DamageMoveCoroutine(Vector3 damageMovePos)
		{
			float time = 0f;
			while (true)
			{
				myTF.parent.position += damageMovePos * (damageMoveCurve.Evaluate(time + Time.deltaTime * 3.5f) - damageMoveCurve.Evaluate(time));
				if (time >= 1f)
				{
					break;
				}
				yield return null;
				time += Time.deltaTime * 3.5f;
			}
		}

		public void ResetInfo()
		{
			maxStamina = levelData.staminaMaxPoint;
			curStamina = maxStamina;
			staminaSpeed = levelData.staminaSpeed;
			maxHealth = levelData.healthMaxPoint;
			curHealth = maxHealth;
			healthSpeed = levelData.healthSpeed;
			anim.SetTrigger("OnIdle");
		}

		public void ResetGroggy()
		{
			StopGroggyCoroutine();
			actionState = ActionState.Idle;
			anim.SetBool("IsMove", value: true);
		}

		public void StartBackMove()
		{
			SetPlay(m_isPlay: false);
			SetFixedPosition(isFixed: false);
			SetLookPlayer(m_isLookPlayer: false);
			SetAnim(1);
		}
	}
	public class CPUStatPannel : MonoBehaviour
	{
		public Image hp;

		public Image st;

		public Text hp_text;

		public Text st_text;

		private void Start()
		{
			base.gameObject.SetActive(value: false);
		}

		private void Update()
		{
			hp.fillAmount = CPUCtrl.Instance.GetHealthRatio();
			st.fillAmount = CPUCtrl.Instance.GetStaminaRatio();
			hp_text.text = $"{CPUCtrl.Instance.curHealth:N0} / {CPUCtrl.Instance.maxHealth:N0}";
			st_text.text = $"{CPUCtrl.Instance.curStamina:N0} / {CPUCtrl.Instance.maxStamina:N0}";
		}
	}
	public class CamEffectCtrl : LocalSingleton<CamEffectCtrl>
	{
		[SerializeField]
		private Transform playerHeadTF;

		[SerializeField]
		private Image img_DamageBlur;

		[SerializeField]
		private Image img_DownBlur;

		[SerializeField]
		private Image img_KO;

		private Transform canvasTF;

		private CoroutineWrapper mainWrapper;

		private CoroutineWrapper damageWrapper;

		protected override void Awake()
		{
			base.Awake();
			canvasTF = GetComponent<Transform>();
			mainWrapper = CoroutineWrapper.Generate(this);
			damageWrapper = CoroutineWrapper.Generate(this);
			img_DamageBlur.gameObject.SetActive(value: false);
			img_DownBlur.gameObject.SetActive(value: false);
			img_KO.gameObject.SetActive(value: true);
		}

		private void Update()
		{
			canvasTF.position = playerHeadTF.position + playerHeadTF.forward * 0.29f;
			canvasTF.LookAt(playerHeadTF);
		}

		public void StartReadyEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(ReadyEffectCoroutine());
			IEnumerator ReadyEffectCoroutine()
			{
				img_KO.gameObject.SetActive(value: true);
				Color color = img_KO.color;
				color.a = 1f;
				img_KO.color = color;
				float time = 0f;
				while (true)
				{
					time = Mathf.Clamp01(time + Time.deltaTime * 0.5f);
					Color color2 = img_KO.color;
					color2.a = Mathf.Lerp(color2.a, 0f, time);
					img_KO.color = color2;
					if (time >= 1f)
					{
						break;
					}
					yield return null;
				}
				Color color3 = img_KO.color;
				color3.a = 0f;
				img_KO.color = color3;
				img_KO.gameObject.SetActive(value: false);
			}
		}

		public void StartEndEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(EndEffectCoroutine());
			IEnumerator EndEffectCoroutine()
			{
				img_DamageBlur.gameObject.SetActive(value: false);
				img_DownBlur.gameObject.SetActive(value: false);
				img_KO.gameObject.SetActive(value: true);
				Color color = img_KO.color;
				color.a = 0f;
				img_KO.color = color;
				float time = 0f;
				while (true)
				{
					time = Mathf.Clamp01(time + Time.deltaTime * 0.5f);
					Color color2 = img_KO.color;
					color2.a = Mathf.Lerp(color2.a, 1f, time);
					img_KO.color = color2;
					if (time >= 1f)
					{
						break;
					}
					yield return null;
				}
				Color color3 = img_KO.color;
				color3.a = 1f;
				img_KO.color = color3;
			}
		}

		public void StartDamageEffect()
		{
			if (damageWrapper.IsPlaying)
			{
				damageWrapper.Stop();
			}
			damageWrapper.Start(DamageEffectCoroutine());
			IEnumerator DamageEffectCoroutine()
			{
				img_DamageBlur.gameObject.SetActive(value: true);
				Color color = img_DamageBlur.color;
				color.a = 0f;
				img_DamageBlur.color = color;
				float time = 0f;
				float maxTime = 0.2f;
				bool isCycleOnce = false;
				while (true)
				{
					time = Mathf.Clamp(time + Time.deltaTime * 0.6f, 0f, maxTime);
					Color color2 = img_DamageBlur.color;
					if (!isCycleOnce)
					{
						color2.a = Mathf.Lerp(color2.a, 1f, time);
					}
					else
					{
						color2.a = Mathf.Lerp(color2.a, 0f, time);
					}
					img_DamageBlur.color = color2;
					if (time >= maxTime)
					{
						if (isCycleOnce)
						{
							break;
						}
						isCycleOnce = true;
						time = 0f;
					}
					yield return null;
				}
				Color color3 = img_DamageBlur.color;
				color3.a = 0f;
				img_DamageBlur.color = color3;
				img_DamageBlur.gameObject.SetActive(value: false);
			}
		}

		public void StartDownEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(DownEffectCoroutine());
			IEnumerator DownEffectCoroutine()
			{
				img_DamageBlur.gameObject.SetActive(value: false);
				img_DownBlur.gameObject.SetActive(value: true);
				Color color = img_DownBlur.color;
				color.a = 0f;
				img_DownBlur.color = color;
				float time = 0f;
				while (true)
				{
					time = Mathf.Clamp01(time + Time.deltaTime * 0.1f);
					Color color2 = img_DownBlur.color;
					color2.a = Mathf.Lerp(color2.a, 1f, time);
					img_DownBlur.color = color2;
					if (time >= 1f)
					{
						break;
					}
					yield return null;
				}
				Color color3 = img_DownBlur.color;
				color3.a = 1f;
				img_DownBlur.color = color3;
			}
		}

		public void StartWakeUpEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(WakeUpEffectCoroutine());
			IEnumerator WakeUpEffectCoroutine()
			{
				Color color = img_DownBlur.color;
				color.a = 1f;
				img_DownBlur.color = color;
				float time = 0f;
				while (true)
				{
					time = Mathf.Clamp01(time + Time.deltaTime * 0.3f);
					Color color2 = img_DownBlur.color;
					color2.a = Mathf.Lerp(color2.a, 0f, time);
					img_DownBlur.color = color2;
					if (time >= 1f)
					{
						break;
					}
					yield return null;
				}
				Color color3 = img_DownBlur.color;
				color3.a = 0f;
				img_DownBlur.color = color3;
				img_DownBlur.gameObject.SetActive(value: false);
			}
		}

		public void StartKOEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(DownEffectCoroutine());
			IEnumerator DownEffectCoroutine()
			{
				img_KO.gameObject.SetActive(value: true);
				Color color = img_KO.color;
				color.a = 0f;
				img_KO.color = color;
				float time = 0f;
				while (true)
				{
					time = Mathf.Clamp01(time + Time.deltaTime * 0.5f);
					Color color2 = img_KO.color;
					color2.a = Mathf.Lerp(color2.a, 1f, time);
					img_KO.color = color2;
					if (time >= 1f)
					{
						break;
					}
					yield return null;
				}
				Color color3 = img_KO.color;
				color3.a = 1f;
				img_KO.color = color3;
			}
		}
	}
	public static class Define
	{
		public enum Tag
		{
			Player_Glove,
			Player_Arm,
			Enemy_Head,
			Enemy_Arm,
			Enemy_Body,
			Enemy_Glove,
			Enemy_Guard
		}

		public enum Layer
		{
			Player = 8,
			Enemy,
			Ring,
			Brando,
			Crowd
		}

		public enum GloveState
		{
			Idle,
			Attach,
			Returning
		}

		public enum PlayerState
		{
			Normal,
			Damage,
			Down,
			Stop
		}

		public enum PlayerGloveState
		{
			Idle,
			Straight,
			HookL,
			HookR,
			Body,
			BodyR,
			Work
		}

		public const int Left = 0;

		public const int Right = 1;

		public static Color Color_Perfect = new Color(1f, 0.1910364f, 0f);

		public static Color Color_Great = new Color(0.09905662f, 0.4622642f, 0f, 0.5882353f);

		public static Color Color_Good = new Color(0f, 0.1772749f, 1f);

		public static Color Color_Guard = new Color(0.15f, 0.15f, 0.15f);
	}
	public class FaceCtrl : MonoBehaviour
	{
		public Transform targetTF;

		public Transform faceTF;

		private void Update()
		{
			UpdateFace();
		}

		public void UpdateFace()
		{
			Vector3 normalized = (targetTF.position - faceTF.position).normalized;
			float t = Mathf.Clamp(Vector3.Dot(faceTF.up, normalized) + 1f, 0f, 2f) * 0.5f;
			normalized = faceTF.InverseTransformDirection(normalized);
			Vector2 normalized2 = new Vector2(normalized.z, normalized.y).normalized;
			Vector2 normalized3 = new Vector2(0f - normalized.x, normalized.y).normalized;
			Quaternion b = Quaternion.Euler(Mathf.Clamp(Mathf.Atan2(normalized2.x, normalized2.y) * 57.29578f, -20f, 20f), 0f, Mathf.Clamp(Mathf.Atan2(normalized3.x, normalized3.y) * 57.29578f, -10f, 10f) - 5f);
			faceTF.localRotation = Quaternion.Lerp(faceTF.localRotation, b, t);
		}
	}
	public class GameManager : LocalSingleton<GameManager>
	{
		[Serializable]
		public class Reg
		{
			public Transform TF;

			public List<Transform> boneTFs;

			public List<Rigidbody> boneRBs;

			public float off_time;
		}

		[Serializable]
		public struct Bone
		{
			public string bone_name;

			public Vector3 bone_pos;

			public Quaternion bone_rot;
		}

		public enum TestMode
		{
			Normal,
			Stand,
			breakTime,
			Infinite
		}

		public enum GameState
		{
			Idle,
			Work
		}

		public TestMode testMode;

		public AudioClip[] bgmSound;

		private AudioSource bgmSource;

		private AudioSource effectSource;

		public AudioClip[] playSounds;

		public AudioClip[] ringSounds;

		public AudioClip[] bellSounds;

		public Transform[] setPosTF;

		public GameObject ko_par;

		private int maxRoundCount;

		private int currentRoundCount;

		private float maxRoundTime;

		private float currentRoundTime;

		private bool isCheckRoundTime;

		private int maxRoundDownCount = 3;

		public int[] roundDownCount;

		[HideInInspector]
		public Transform[] headTFs;

		[HideInInspector]
		public Transform[] bodyTFs;

		public int attack_s;

		public int attack_f;

		public int guard_s;

		public int guard_f;

		private bool isBreakTime;

		private bool isEnd;

		public GameState gameState;

		public LevelData[] levelData;

		public bool IsBreakTime()
		{
			return isBreakTime;
		}

		private void Start()
		{
			InitData();
			StartCoroutine(StartSceneCoroutine());
			PublicGameUIManager.GetInstance.SetGridSize(1.5f);
		}

		private void InitData()
		{
			testMode = TestMode.Normal;
			bgmSource = base.gameObject.AddComponent<AudioSource>();
			bgmSource.playOnAwake = false;
			bgmSource.volume = 0.7f;
			bgmSource.loop = true;
			bgmSource.clip = bgmSound[SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level - 1];
			bgmSource.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("BGM");
			effectSource = base.gameObject.AddComponent<AudioSource>();
			effectSource.playOnAwake = false;
			effectSource.outputAudioMixerGroup = PublicGameUIManager.gameSetting.GetAudioMixerGroup("Effect");
			headTFs = new Transform[2];
			headTFs[0] = Camera.main.transform;
			headTFs[1] = CPUCtrl.Instance.ragdoll.bones[RagdollBones.Head].origin;
			bodyTFs = new Transform[2];
			bodyTFs[0] = Camera.main.transform;
			bodyTFs[1] = CPUCtrl.Instance.ragdoll.bones[RagdollBones.Hips].origin;
			maxRoundCount = 3;
			maxRoundTime = 60f;
			isCheckRoundTime = false;
			roundDownCount = new int[2];
			roundDownCount[0] = 0;
			roundDownCount[1] = 0;
			if ((int)UnityEngine.Random.Range(0f, 1.99999f) == 0)
			{
				LocalSingleton<GloveManager>.Instance.myRenderer.sharedMaterial.SetColor("_BaseColor", new Color(0.8f, 0f, 0f));
				LocalSingleton<GloveManager>.Instance.myRenderer.sharedMaterial.SetFloat("_Smoothness", 0.73f);
				CPUCtrl.Instance.gloveRenderer.sharedMaterial.SetColor("_BaseColor", new Color(0f, 0f, 0.85f));
				CPUCtrl.Instance.gloveRenderer.sharedMaterial.SetFloat("_Smoothness", 0.7f);
			}
			else
			{
				LocalSingleton<GloveManager>.Instance.myRenderer.sharedMaterial.SetColor("_BaseColor", new Color(0f, 0f, 0.85f));
				LocalSingleton<GloveManager>.Instance.myRenderer.sharedMaterial.SetFloat("_Smoothness", 0.7f);
				CPUCtrl.Instance.gloveRenderer.sharedMaterial.SetColor("_BaseColor", new Color(0.8f, 0f, 0f));
				CPUCtrl.Instance.gloveRenderer.sharedMaterial.SetFloat("_Smoothness", 0.73f);
			}
		}

		private void Update()
		{
			CheckRoundTime();
		}

		private void CheckRoundTime()
		{
			if (!isCheckRoundTime)
			{
				return;
			}
			currentRoundTime += Time.deltaTime;
			if (currentRoundTime >= maxRoundTime)
			{
				isCheckRoundTime = false;
				if (currentRoundCount < maxRoundCount)
				{
					NextRound();
				}
				else
				{
					GameEnd_Time();
				}
			}
		}

		private IEnumerator StartSceneCoroutine()
		{
			currentRoundCount = 1;
			CPUCtrl.Instance.SetLookPlayer(m_isLookPlayer: false);
			LocalSingleton<BrandoCtrl>.Instance.gameObject.SetActive(value: false);
			bgmSource.Play();
			LocalSingleton<PostProcessFadeCtrl>.Instance.StopFade();
			CPUCtrl.Instance.SetPosition(setPosTF[1]);
			CPUCtrl.Instance.PlayReadyAnim(5);
			LocalSingleton<BrandoCtrl>.Instance.gameObject.SetActive(value: true);
			LocalSingleton<BrandoCtrl>.Instance.SetPosition(setPosTF[3]);
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			PlayerCtrl.Instance.SetHeight();
			LocalSingleton<CamEffectCtrl>.Instance.StartReadyEffect();
			LocalSingleton<BrandoCtrl>.Instance.SetLookState(1);
			yield return YieldInstructionCache.WaitForSeconds(1f);
			LocalSingleton<BrandoCtrl>.Instance.SetLookState(0);
			CPUCtrl.Instance.SetLookPlayer(m_isLookPlayer: true);
			yield return YieldInstructionCache.WaitForSeconds(1f);
			LocalSingleton<BoxerUICtrl>.Instance.StartRoundUI(currentRoundCount);
			LocalSingleton<BrandoCtrl>.Instance.SetLookState(2);
			LocalSingleton<BrandoCtrl>.Instance.GameReady();
			yield return YieldInstructionCache.WaitForSeconds(1.5f);
			StartBellSound(0);
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			LocalSingleton<BrandoCtrl>.Instance.GameFight();
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			LocalSingleton<BrandoCtrl>.Instance.SetLookState(0);
			LocalSingleton<BrandoCtrl>.Instance.SetPlay(m_isPlay: true);
			CPUCtrl.Instance.PlayReadyAnim(6);
			isCheckRoundTime = true;
			gameState = GameState.Idle;
			yield return YieldInstructionCache.WaitForSeconds(2f);
		}

		private void StartBellSound(int num)
		{
			effectSource.clip = bellSounds[num];
			effectSource.Play();
		}

		public void PlayerDown(float percentage)
		{
			if (gameState == GameState.Idle)
			{
				gameState = GameState.Work;
				StartCoroutine(PlayerDownCoroutine(percentage));
			}
		}

		private IEnumerator PlayerDownCoroutine(float percentage)
		{
			isCheckRoundTime = false;
			Time.timeScale = 0.5f;
			PlayerCtrl.Instance.StartDownState();
			CPUCtrl.Instance.SetDownLookPlayer();
			CPUCtrl.Instance.StartBackMove();
			roundDownCount[0]++;
			if (roundDownCount[0] >= maxRoundDownCount)
			{
				LocalSingleton<BrandoCtrl>.Instance.StartStepBack(0, BrandoCtrl.DownState.KO3);
			}
			else if (percentage <= 0f)
			{
				LocalSingleton<BrandoCtrl>.Instance.StartStepBack(0, BrandoCtrl.DownState.KnockOut);
			}
			else
			{
				LocalSingleton<BrandoCtrl>.Instance.StartStepBack(0, BrandoCtrl.DownState.KnockDown);
			}
			yield return YieldInstructionCache.WaitForSeconds(1f);
			Time.timeScale = 1f;
			if (LocalSingleton<SpectatorSoundCtrl>.Instance != null)
			{
				SpectatorSoundCtrl.PlaySound(isCheer: true);
			}
		}

		public void CPUDown(float percentage = 0f)
		{
			if (gameState == GameState.Idle)
			{
				gameState = GameState.Work;
				CPUCtrl.Instance.StopGroggyCoroutine();
				StartCoroutine(CPUDownCoroutine(percentage));
			}
		}

		private IEnumerator CPUDownCoroutine(float percentage)
		{
			isCheckRoundTime = false;
			CPUCtrl.Instance.StartDownState();
			roundDownCount[1]++;
			if (roundDownCount[1] >= maxRoundDownCount)
			{
				LocalSingleton<BrandoCtrl>.Instance.StartStepBack(1, BrandoCtrl.DownState.KO3);
			}
			else if (percentage <= 0f)
			{
				LocalSingleton<BrandoCtrl>.Instance.StartStepBack(1, BrandoCtrl.DownState.KnockOut);
			}
			else
			{
				LocalSingleton<BrandoCtrl>.Instance.StartStepBack(1, BrandoCtrl.DownState.KnockDown);
			}
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			if (LocalSingleton<SpectatorSoundCtrl>.Instance != null)
			{
				SpectatorSoundCtrl.PlaySound(isCheer: true);
			}
		}

		public void GameContinue()
		{
			StartCoroutine(GameContinueCoroutine());
			IEnumerator GameContinueCoroutine()
			{
				LocalSingleton<CamEffectCtrl>.Instance.StartEndEffect();
				yield return YieldInstructionCache.WaitForSeconds(1f);
				PlayerCtrl.Instance.SetPosition(setPosTF[0]);
				CPUCtrl.Instance.SetPosition(setPosTF[2]);
				CPUCtrl.Instance.SetLookPlayer(m_isLookPlayer: true);
				LocalSingleton<BrandoCtrl>.Instance.SetPosition(setPosTF[3]);
				LocalSingleton<BrandoCtrl>.Instance.SetLookState(2);
				LocalSingleton<BrandoCtrl>.Instance.GameReady();
				LocalSingleton<CamEffectCtrl>.Instance.StartReadyEffect();
				yield return YieldInstructionCache.WaitForSeconds(1.5f);
				LocalSingleton<BrandoCtrl>.Instance.GameFight();
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				LocalSingleton<BrandoCtrl>.Instance.SetLookState(0);
				CPUCtrl.Instance.SetPlay(m_isPlay: true);
				LocalSingleton<BrandoCtrl>.Instance.SetPlay(m_isPlay: true);
				isCheckRoundTime = true;
				gameState = GameState.Idle;
			}
		}

		public void NextRound()
		{
			if (gameState == GameState.Idle)
			{
				gameState = GameState.Work;
				StartCoroutine(NextRoundCoroutine());
			}
			IEnumerator NextRoundCoroutine()
			{
				StartBellSound(1);
				isBreakTime = true;
				PlayerCtrl.Instance.StartBackMove();
				CPUCtrl.Instance.SetPlay(m_isPlay: false);
				CPUCtrl.Instance.ResetGroggy();
				LocalSingleton<BrandoCtrl>.Instance.SetPlay(m_isPlay: false);
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				CPUCtrl.Instance.SetAnim(1);
				CPUCtrl.Instance.SetLookPlayer(m_isLookPlayer: false);
				LocalSingleton<BrandoCtrl>.Instance.StartEndRound();
				yield return YieldInstructionCache.WaitForSeconds(0.6f);
				LocalSingleton<CamEffectCtrl>.Instance.StartEndEffect();
				currentRoundCount++;
				roundDownCount[0] = 0;
				roundDownCount[1] = 0;
				yield return YieldInstructionCache.WaitForSeconds(1f);
				PlayerCtrl.Instance.SetPosition(setPosTF[6]);
				CPUCtrl.Instance.StartBreakTime(setPosTF[7], currentRoundCount);
				LocalSingleton<BrandoCtrl>.Instance.gameObject.SetActive(value: false);
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				LocalSingleton<CamEffectCtrl>.Instance.StartReadyEffect();
				yield return YieldInstructionCache.WaitForSeconds(10f);
				LocalSingleton<CamEffectCtrl>.Instance.StartEndEffect();
				yield return YieldInstructionCache.WaitForSeconds(1f);
				PlayerCtrl.Instance.SetPosition(setPosTF[0]);
				PlayerCtrl.Instance.SetHP(PlayerCtrl.Instance.maxHealth * 0.05f);
				PlayerCtrl.Instance.SetST(PlayerCtrl.Instance.maxHealth * 0.05f);
				CPUCtrl.Instance.StopBreakTime();
				CPUCtrl.Instance.SetPosition(setPosTF[2]);
				CPUCtrl.Instance.SetLookPlayer(m_isLookPlayer: true);
				CPUCtrl.Instance.SetHP(CPUCtrl.Instance.maxHealth * 0.05f);
				CPUCtrl.Instance.SetST(CPUCtrl.Instance.maxHealth * 0.05f);
				LocalSingleton<BrandoCtrl>.Instance.gameObject.SetActive(value: true);
				LocalSingleton<BrandoCtrl>.Instance.SetPosition(setPosTF[3]);
				LocalSingleton<BrandoCtrl>.Instance.SetLookState(2);
				LocalSingleton<CamEffectCtrl>.Instance.StartReadyEffect();
				yield return YieldInstructionCache.WaitForSeconds(1f);
				LocalSingleton<BoxerUICtrl>.Instance.StartRoundUI(currentRoundCount);
				yield return YieldInstructionCache.WaitForSeconds(1f);
				LocalSingleton<BrandoCtrl>.Instance.GameReady();
				yield return YieldInstructionCache.WaitForSeconds(1f);
				isBreakTime = false;
				StartBellSound(0);
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				LocalSingleton<BrandoCtrl>.Instance.GameFight();
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				LocalSingleton<BrandoCtrl>.Instance.SetLookState(0);
				LocalSingleton<BrandoCtrl>.Instance.SetPlay(m_isPlay: true);
				CPUCtrl.Instance.SetPlay(m_isPlay: true);
				currentRoundTime = 0f;
				isCheckRoundTime = true;
				gameState = GameState.Idle;
			}
		}

		public void GameEnd_Time()
		{
			if (gameState == GameState.Idle)
			{
				gameState = GameState.Work;
				StartCoroutine(GameEndCoroutine_Time());
			}
			IEnumerator GameEndCoroutine_Time()
			{
				StartBellSound(1);
				CPUCtrl.Instance.SetPlay(m_isPlay: false);
				CPUCtrl.Instance.ResetGroggy();
				LocalSingleton<BrandoCtrl>.Instance.SetPlay(m_isPlay: false);
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				CPUCtrl.Instance.SetAnim(1);
				CPUCtrl.Instance.SetLookPlayer(m_isLookPlayer: false);
				LocalSingleton<BrandoCtrl>.Instance.StartEndRound();
				yield return YieldInstructionCache.WaitForSeconds(1f);
				LocalSingleton<CamEffectCtrl>.Instance.StartEndEffect();
				yield return YieldInstructionCache.WaitForSeconds(1f);
				PlayerCtrl.Instance.SetPosition(setPosTF[4]);
				CPUCtrl.Instance.SetPosition(setPosTF[5]);
				CPUCtrl.Instance.SetAnim(2);
				LocalSingleton<BrandoCtrl>.Instance.SetPosition(setPosTF[3]);
				LocalSingleton<BrandoCtrl>.Instance.SetLookAtIK(isEnabled: false);
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				LocalSingleton<CamEffectCtrl>.Instance.StartReadyEffect();
				float[] boxerScore = new float[2];
				float num = 1000f * (1f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.2f);
				boxerScore[0] = (float)attack_s * 500f + (float)roundDownCount[1] * 5000f;
				boxerScore[1] = (float)guard_f * num + (float)roundDownCount[0] * 10000f;
				int winNum = ((!(boxerScore[0] >= boxerScore[1])) ? 1 : 0);
				yield return YieldInstructionCache.WaitForSeconds(4f);
				LocalSingleton<BrandoCtrl>.Instance.PlayAnim(winNum);
				yield return YieldInstructionCache.WaitForSeconds(1f);
				CPUCtrl.Instance.SetAnim((winNum == 0) ? 4 : 3);
				SetGameResult(winNum == 0, boxerScore);
			}
		}

		public void GameEnd_KO(bool isWin)
		{
			if (!isEnd)
			{
				isEnd = true;
				StartCoroutine(GameEndCoroutine_KO(isWin));
			}
		}

		private IEnumerator GameEndCoroutine_KO(bool isWin)
		{
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			LocalSingleton<BrandoCtrl>.Instance.PlayAnim(3);
			LocalSingleton<BrandoCtrl>.Instance.PlayKOSound();
			yield return YieldInstructionCache.WaitForSeconds(1f);
			StartBellSound(2);
			LocalSingleton<CamEffectCtrl>.Instance.StartKOEffect();
			yield return YieldInstructionCache.WaitForSeconds(1f);
			float[] array = new float[2];
			float num = 1000f * (1f + (float)SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.Level * 0.2f);
			array[0] = (float)attack_s * 500f + (float)roundDownCount[1] * 5000f;
			array[1] = (float)guard_f * num + (float)roundDownCount[0] * 10000f;
			array[(!isWin) ? 1u : 0u] += 20000f;
			SetGameResult(isWin, array);
		}

		private void SetGameResult(bool isWin, float[] boxerScore)
		{
			if (isWin)
			{
				ko_par.SetActive(value: true);
				SpectatorSoundCtrl.PlaySound(isCheer: true);
				SingletonPunBase.Singleton<GameData_DDOL>.GetInstance.SetClearLevelData();
			}
			else
			{
				SpectatorSoundCtrl.PlaySound(isCheer: false);
			}
			List<string> list = new List<string>
			{
				boxerScore[0].ToString(),
				boxerScore[1].ToString()
			};
			PublicGameUIManager.GetInstance.OpenResultBoard(list.ToArray(), (!isWin) ? 1 : 0);
		}

		public void PlayRingSound()
		{
			effectSource.clip = ringSounds[0];
			effectSource.Play();
		}

		public void PlayGameStartSound()
		{
			effectSource.clip = playSounds[(int)UnityEngine.Random.Range(0f, 3.9999f)];
			effectSource.Play();
		}
	}
	public class GloveCollider : MonoBehaviour
	{
		[SerializeField]
		private BoxerClass boxer;

		[SerializeField]
		private bool isRight;

		public Jisu.Utils.Notifier<bool> isCheckCollider { get; set; } = new Jisu.Utils.Notifier<bool>();


		public Rigidbody myRB { get; private set; }

		private void Awake()
		{
			myRB = GetComponent<Rigidbody>();
			isCheckCollider.CurrentData = false;
		}

		private void OnCollisionEnter(Collision collision)
		{
			CheckCollision(ref collision);
		}

		public void CheckCollision(ref Collision collision)
		{
			if (isCheckCollider.CurrentData || (CPUCtrl.Instance.IsStartPunchTime() && !LocalSingleton<GameManager>.Instance.IsBreakTime()))
			{
				boxer.CheckAttack(collision, isRight);
			}
		}
	}
	public class GloveCollider_Sub : MonoBehaviour
	{
		private GloveCollider gloveCollider;

		private void Awake()
		{
			gloveCollider = GetComponentInChildren<GloveCollider>();
		}

		private void OnCollisionEnter(Collision collision)
		{
			gloveCollider.CheckCollision(ref collision);
		}
	}
	public class GloveManager : LocalSingleton<GloveManager>
	{
		[Serializable]
		public struct GloveDatum
		{
			public Vector3 pos;

			public Vector3 dir;

			public Vector3 veloc;

			public float mag;
		}

		private Transform[] gloveTF = new Transform[2];

		private Transform[] armTF = new Transform[2];

		private Transform playerTF;

		private UnityEngine.XR.Interaction.Toolkit.XRController[] xrCtrlr = new UnityEngine.XR.Interaction.Toolkit.XRController[2];

		public Transform[] ctrlrTF = new Transform[2];

		public GloveCollider[] gloveColliders = new GloveCollider[2];

		public Vector3 set_pos = new Vector3(0f, 0.03f, -0.15f);

		public Vector3 set_rot = new Vector3(-60f, 0f, 90f);

		public Vector3 set_pos_oculus = new Vector3(0f, 0.03f, -0.15f);

		public Vector3 set_rot_oculus = new Vector3(-60f, 0f, 90f);

		private Rigidbody[] gloveRB = new Rigidbody[2];

		private FixedJoint[] gloveJoint = new FixedJoint[2];

		private GloveDatum[,] gloveData;

		private int length_state = 2;

		private Animator anim;

		public GloveDatum[] gloveDatum = new GloveDatum[2];

		[SerializeField]
		private float shockCorrection;

		[SerializeField]
		private AnimationCurve shockCurve;

		public Renderer myRenderer;

		public bool[] isInHeadBoundary { get; private set; } = new bool[2];


		public Define.GloveState[] gloveState { get; private set; } = new Define.GloveState[2];


		public GloveDatum GetGloveDatum(int dir)
		{
			return gloveDatum[dir];
		}

		private void Start()
		{
			playerTF = Camera.main.transform;
			anim = GetComponent<Animator>();
			gloveDatum[0] = default(GloveDatum);
			gloveDatum[1] = default(GloveDatum);
			length_state = 5;
			length_state = Mathf.Clamp(length_state, 3, 60);
			gloveData = new GloveDatum[2, length_state];
			for (int i = 0; i < 2; i++)
			{
				xrCtrlr[i] = ctrlrTF[i].GetComponent<UnityEngine.XR.Interaction.Toolkit.XRController>();
				gloveRB[i] = gloveColliders[i].GetComponent<Rigidbody>();
				gloveJoint[i] = gloveColliders[i].GetComponent<FixedJoint>();
				gloveColliders[i].isCheckCollider.CurrentData = false;
				for (int j = 0; j < length_state; j++)
				{
					gloveData[i, j] = default(GloveDatum);
					gloveData[i, j].veloc = Vector3.up;
				}
			}
			gloveTF[0] = base.transform.Find("L_ROOT_HAND");
			gloveTF[1] = base.transform.Find("R_ROOT_HAND");
			armTF[0] = gloveTF[0].Find("L_BONE_FOREARM");
			armTF[1] = gloveTF[1].Find("R_BONE_FOREARM");
			InitializeJoint();
		}

		private void InitializeJoint()
		{
			Vector3 vector = set_pos_oculus;
			Vector3 euler = set_rot_oculus;
			for (int i = 0; i < 2; i++)
			{
				Rigidbody rigidbody = ctrlrTF[i].gameObject.AddComponent<Rigidbody>();
				rigidbody.mass = 1f;
				rigidbody.drag = 0f;
				rigidbody.angularDrag = 0f;
				rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
				rigidbody.constraints = RigidbodyConstraints.FreezeAll;
				rigidbody.useGravity = false;
				FixedJoint component = armTF[i].parent.GetComponent<FixedJoint>();
				component.connectedBody = rigidbody;
				component.gameObject.SetActive(value: false);
				component.transform.SetPositionAndRotation(component.connectedBody.position + ctrlrTF[i].right * ((i == 0) ? (0f - vector.x) : vector.x) + ctrlrTF[i].up * vector.y + ctrlrTF[i].forward * vector.z, component.connectedBody.rotation * Quaternion.Euler(euler));
				component.gameObject.SetActive(value: true);
				component.autoConfigureConnectedAnchor = false;
			}
		}

		private void Update()
		{
			CheckGrabValue();
			CheckVelocity();
			UpdateArmRotate();
			CheckPositionToCamera();
		}

		private void CheckGrabValue()
		{
			if (xrCtrlr[0].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out var value))
			{
				anim.SetFloat("BlendL", value);
			}
			if (xrCtrlr[1].inputDevice.TryGetFeatureValue(CommonUsages.trigger, out var value2))
			{
				anim.SetFloat("BlendR", value2);
			}
		}

		private void CheckVelocity()
		{
			for (int i = 0; i < 2; i++)
			{
				for (int num = length_state - 1; num >= 1; num--)
				{
					gloveData[i, num] = gloveData[i, num - 1];
				}
			}
			for (int j = 0; j < 2; j++)
			{
				gloveData[j, 0].pos = ctrlrTF[j].position;
				gloveData[j, 0].veloc = (gloveData[j, 0].pos - gloveData[j, 1].pos) / Time.unscaledDeltaTime * 0.1f;
				gloveData[j, 0].dir = gloveData[j, 0].veloc.normalized;
				gloveData[j, 0].veloc *= Mathf.Clamp01(Vector3.Dot(playerTF.forward, gloveData[j, 0].veloc.normalized) + 1f) * Mathf.Clamp01((Vector3.Dot((gloveData[j, 1].pos - gloveData[j, 2].pos).normalized, gloveData[j, 0].veloc.normalized) - 0.9f) * 10f);
				gloveData[j, 0].mag = gloveData[j, 0].veloc.magnitude;
				if (gloveData[j, 0].mag > 1f)
				{
					gloveData[j, 0].mag = 1f;
					gloveData[j, 0].veloc = gloveData[j, 0].dir;
				}
			}
			GetFindMagnitude(out var left, out var right);
			for (int k = 0; k < 2; k++)
			{
				float num2 = ((k == 0) ? left : right);
				gloveDatum[k].pos = gloveData[k, 0].pos;
				gloveDatum[k].dir = gloveData[k, 1].dir;
				gloveDatum[k].veloc = gloveDatum[k].dir * num2;
				gloveDatum[k].mag = num2;
			}
		}

		public void GetFindMagnitude(out float left, out float right)
		{
			left = 0f;
			right = 0f;
			for (int i = 0; i < length_state; i++)
			{
				if (left < gloveData[0, i].mag)
				{
					left = gloveData[0, i].mag;
				}
				if (right < gloveData[1, i].mag)
				{
					right = gloveData[1, i].mag;
				}
			}
		}

		private void UpdateArmRotate()
		{
			Vector3 vector = armTF[0].position - playerTF.position;
			vector.y = 0f;
			float num = Mathf.Lerp(-0.25f, -0.7f, 1f - Mathf.Clamp01((vector.sqrMagnitude - 0.03f) * 5f));
			Vector3 up = playerTF.up;
			up.y *= 2f;
			up = up.normalized * num;
			Vector3 right = playerTF.right;
			right.y = 0f;
			right = -right.normalized * 0.3f;
			Vector3 normalized = (playerTF.position + up + right - armTF[0].position).normalized;
			float num2 = Mathf.Abs(Vector3.Dot(armTF[0].parent.forward, normalized));
			float num3 = Mathf.Abs(Vector3.Dot(armTF[0].parent.up, normalized));
			Quaternion a = Quaternion.LookRotation(normalized, armTF[0].parent.up) * Quaternion.Euler(180f, 90f, 0f);
			Quaternion b = Quaternion.LookRotation(normalized, armTF[0].parent.forward) * Quaternion.Euler(-90f, 90f, 0f);
			Quaternion a2 = Quaternion.Lerp(a, b, num3 / (num2 + num3));
			float num4 = (Vector3.Dot(-armTF[0].parent.right, normalized) + 1f) * 0.5f;
			if (num4 > 0.5f)
			{
				num4 = 0.5f + (num4 - 0.5f) * 0.5f;
			}
			Quaternion b2 = armTF[0].parent.rotation * Quaternion.Euler(0f, 0f, -180f);
			armTF[0].rotation = Quaternion.Lerp(a2, b2, Mathf.Clamp(num4, 0.35f, 1f));
			vector = armTF[1].position - playerTF.position;
			vector.y = 0f;
			num = Mathf.Lerp(-0.25f, -0.7f, 1f - Mathf.Clamp01((vector.sqrMagnitude - 0.03f) * 5f));
			up = playerTF.up;
			up.y *= 2f;
			up = up.normalized * num;
			right = playerTF.right;
			right.y = 0f;
			right = right.normalized * 0.3f;
			normalized = (playerTF.position + up + right - armTF[1].position).normalized;
			num2 = Mathf.Abs(Vector3.Dot(armTF[1].parent.forward, normalized));
			num3 = Mathf.Abs(Vector3.Dot(armTF[1].parent.up, normalized));
			Quaternion a3 = Quaternion.LookRotation(normalized, armTF[1].parent.up) * Quaternion.Euler(180f, 90f, 0f);
			b = Quaternion.LookRotation(normalized, armTF[1].parent.forward) * Quaternion.Euler(-90f, 90f, 0f);
			a2 = Quaternion.Lerp(a3, b, num3 / (num2 + num3));
			num4 = (Vector3.Dot(-armTF[1].parent.right, normalized) + 1f) * 0.5f;
			if (num4 > 0.5f)
			{
				num4 = 0.5f + (num4 - 0.5f) * 0.5f;
			}
			b2 = armTF[1].parent.rotation * Quaternion.Euler(0f, 0f, -180f);
			armTF[1].rotation = Quaternion.Lerp(a2, b2, Mathf.Clamp(num4, 0.35f, 1f));
		}

		private void CheckPositionToCamera()
		{
			Vector3 position = playerTF.position;
			for (int i = 0; i < 2; i++)
			{
				position.y = gloveTF[i].position.y;
				bool flag = (position - gloveTF[i].position).sqrMagnitude < 0.09f;
				isInHeadBoundary[i] = flag;
				gloveRB[i].mass = (flag ? 25f : 1f);
				gloveJoint[i].massScale = (flag ? 25f : 5f);
			}
		}

		public void GloveHitEvent(int dir, bool isGuard)
		{
			gloveColliders[dir].isCheckCollider.CurrentData = false;
			if (isGuard)
			{
				SetHapticImpulse(dir, 0.7f * PublicGameUIManager.gameSetting.GetHapticValue(), 0.2f);
			}
			else
			{
				SetHapticImpulse(dir, 1f * PublicGameUIManager.gameSetting.GetHapticValue(), 0.2f);
			}
		}

		private void SetHapticImpulse(int dir, float amp, float duration)
		{
			if (xrCtrlr[dir].inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				xrCtrlr[dir].inputDevice.SendHapticImpulse(0u, amp, duration);
			}
		}
	}
	public class HitEffectCtrl : MonoBehaviour
	{
		private Transform myTF;

		private HitEffectManager effectManager;

		private ParticleSystem[] effects;

		private AudioSource audioSource;

		private void Start()
		{
			myTF = GetComponent<Transform>();
			effectManager = GetComponentInParent<HitEffectManager>();
			audioSource = GetComponent<AudioSource>();
			effects = new ParticleSystem[2];
			for (int i = 0; i < effects.Length; i++)
			{
				effects[i] = base.transform.GetChild(i).GetComponent<ParticleSystem>();
			}
		}

		public void StartEffect(Vector3 pos, bool isGuard, float force)
		{
			myTF.position = pos;
			audioSource.clip = effectManager.GetHitSound();
			if (isGuard)
			{
				audioSource.volume = 0.8f;
			}
			else
			{
				audioSource.volume = Mathf.Lerp(0.2f, 1f, force);
			}
			audioSource.pitch = Mathf.Lerp(1f, 1.2f, force);
			audioSource.Play();
			effects[isGuard ? 1 : 0].Play();
		}
	}
	public class HitEffectManager : MonoBehaviour
	{
		[SerializeField]
		private AudioClip[] audioClip_hit_normal;

		public AudioClip GetHitSound()
		{
			int num = audioClip_hit_normal.Length;
			return audioClip_hit_normal[(int)Mathf.Clamp(UnityEngine.Random.Range(0f, num), 0f, (float)num - 1f)];
		}
	}
	[Serializable]
	public class LevelData : ScriptableObject
	{
		public float staminaMaxPoint;

		public float staminaSpeed;

		public float healthMaxPoint;

		public float healthSpeed;

		public float attackCount_min;

		public float attackCount_max;

		public float stateChangeTime_min;

		public float stateChangeTime_max;

		public float[] nextAttackTimes;

		public float attackTimeMag;

		public float attackGuardDelayTime;

		public float damageHoldTime;

		public float keepInCheckProbability;

		public float weavingAttackProbability;

		public float guardProbability;

		public float guardSpeed;

		public float guardReactionProbability;

		public float groggyTime;

		public float spearPoint;

		public float damageP;
	}
	public class LocalizationCtrl : MonoBehaviour
	{
		public Material mat_Ring_Frame;

		public Material mat_Ring_LED;

		public Material mat_Display;

		public Material mat_LED;

		public MeshFilter[] meshFilter_round;

		private void Start()
		{
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			LanguageState languageState = PublicGameUIManager.gameSetting.GetLanguageState();
			if ((uint)(languageState - 10) <= 1u)
			{
				mat_Ring_Frame.SetTexture("_BaseMap", Resources.Load<Texture2D>("Boxing/Texture/ring_frame_chinese"));
				Texture2D value = Resources.Load<Texture2D>("Boxing/Texture/ring_LED_chinese");
				mat_Ring_LED.SetTexture("_Diffuse", value);
				mat_Ring_LED.SetTexture("_Emission", value);
				value = Resources.Load<Texture2D>("Boxing/Texture/display_chinese");
				mat_Display.SetTexture("_Diffuse", value);
				mat_Display.SetTexture("_Emission", value);
				value = Resources.Load<Texture2D>("Boxing/Texture/LED_advertise_chinese");
				mat_LED.SetTexture("_BaseMap", value);
				mat_LED.SetTexture("_EmissionMap", value);
				for (int i = 0; i < meshFilter_round.Length; i++)
				{
					meshFilter_round[i].mesh = Resources.Load<Mesh>("Boxing/Round/Round" + (i + 1) + "_chinese");
				}
			}
			else
			{
				mat_Ring_Frame.SetTexture("_BaseMap", Resources.Load<Texture2D>("Boxing/Texture/ring_frame_english"));
				Texture2D value2 = Resources.Load<Texture2D>("Boxing/Texture/ring_LED_english");
				mat_Ring_LED.SetTexture("_Diffuse", value2);
				mat_Ring_LED.SetTexture("_Emission", value2);
				value2 = Resources.Load<Texture2D>("Boxing/Texture/display_english");
				mat_Display.SetTexture("_Diffuse", value2);
				mat_Display.SetTexture("_Emission", value2);
				value2 = Resources.Load<Texture2D>("Boxing/Texture/LED_advertise_english");
				mat_LED.SetTexture("_BaseMap", value2);
				mat_LED.SetTexture("_EmissionMap", value2);
				for (int j = 0; j < meshFilter_round.Length; j++)
				{
					meshFilter_round[j].mesh = Resources.Load<Mesh>("Boxing/Round/Round" + (j + 1) + "_english");
				}
			}
		}
	}
	public class PlayerCamActionCtrl : LocalSingleton<PlayerCamActionCtrl>
	{
		public enum DownState
		{
			Start,
			End,
			Wake,
			Wave
		}

		public AnimationCurve animCurve_cam_shake;

		public float speed_shake = 3f;

		public AnimationCurve animCurve_cam_damage;

		public float speed_damage = 1.5f;

		public AnimationCurve animCurve_down_start;

		public float speed_down_start = 1f;

		public AnimationCurve animCurve_down_end;

		public float speed_down_end = 0.2f;

		public AnimationCurve animCurve_down_wake;

		public float speed_down_wake = 0.3f;

		public AnimationCurve animCurve_down_wave;

		public float speed_down_wave = 3f;

		public float rig_height;

		public Camera cam_main;

		private Transform camTF;

		private UnityEngine.SpatialTracking.TrackedPoseDriver trackedPoseDriver;

		private Transform rigChildTF;

		private CoroutineWrapper shakeWrapper;

		private CoroutineWrapper damageWrapper;

		private CoroutineWrapper downWrapper;

		protected override void Awake()
		{
			base.Awake();
			shakeWrapper = CoroutineWrapper.Generate(this);
			damageWrapper = CoroutineWrapper.Generate(this);
			downWrapper = CoroutineWrapper.Generate(this);
		}

		private void Start()
		{
			camTF = cam_main.transform;
			trackedPoseDriver = camTF.GetComponent<UnityEngine.SpatialTracking.TrackedPoseDriver>();
			rigChildTF = camTF.parent;
		}

		public void StartShakeCam()
		{
			if (!shakeWrapper.IsPlaying)
			{
				shakeWrapper.Start(ShakeCamCoroutine());
			}
			IEnumerator ShakeCamCoroutine()
			{
				float timeP = 0f;
				while (true)
				{
					cam_main.rect = new Rect(animCurve_cam_shake.Evaluate(timeP), 0f, 1f, 1f);
					if (timeP >= 1f)
					{
						break;
					}
					yield return null;
					timeP = Mathf.Clamp01(timeP + Time.deltaTime * speed_shake);
				}
			}
		}

		public void StartDamageCam(Vector2 damageVec)
		{
			if (!damageWrapper.IsPlaying)
			{
				damageWrapper.Start(DamageCamCoroutine(CPUCtrl.Instance.transform.position, damageVec));
			}
			IEnumerator DamageCamCoroutine(Vector3 pos, Vector2 vec)
			{
				trackedPoseDriver.updateType = UnityEngine.SpatialTracking.TrackedPoseDriver.UpdateType.Update;
				Vector3 vector = pos - camTF.position;
				vector.y = 0f;
				vector = vector.normalized;
				Vector3 vector2 = Vector3.Cross(vector, Vector3.up);
				vector2 *= vec.y;
				vector2.y = vec.y;
				float time = 0f;
				while (!(time >= 1f))
				{
					yield return null;
					time = Mathf.Clamp01(time + Time.deltaTime * speed_damage);
				}
				trackedPoseDriver.updateType = UnityEngine.SpatialTracking.TrackedPoseDriver.UpdateType.UpdateAndBeforeRender;
			}
		}

		public void StartDownCam(DownState state)
		{
			if (!downWrapper.IsPlaying)
			{
				downWrapper.Start(DownCamCoroutine(state));
			}
			IEnumerator DownCamCoroutine(DownState downState)
			{
				float time = 0f;
				switch (downState)
				{
				default:
					yield break;
				case DownState.Start:
					while (true)
					{
						Vector3 position3 = rigChildTF.position;
						position3.y = rig_height + animCurve_down_start.Evaluate(time);
						rigChildTF.position = position3;
						if (time >= 1f)
						{
							break;
						}
						yield return null;
						time = Mathf.Clamp01(time + Time.deltaTime * speed_down_start);
					}
					yield break;
				case DownState.End:
					while (true)
					{
						Vector3 position2 = rigChildTF.position;
						position2.y = rig_height + animCurve_down_end.Evaluate(time);
						rigChildTF.position = position2;
						if (time >= 1f)
						{
							break;
						}
						yield return null;
						time = Mathf.Clamp01(time + Time.deltaTime * speed_down_end);
					}
					yield break;
				case DownState.Wake:
					while (true)
					{
						Vector3 position = rigChildTF.position;
						position.y = rig_height + animCurve_down_wake.Evaluate(time);
						rigChildTF.position = position;
						if (time >= 1f)
						{
							break;
						}
						yield return null;
						time = Mathf.Clamp01(time + Time.deltaTime * speed_down_wake);
					}
					yield break;
				case DownState.Wave:
					break;
				}
				while (true)
				{
					Vector3 position4 = rigChildTF.position;
					position4.y = rig_height + animCurve_down_wave.Evaluate(time);
					rigChildTF.position = position4;
					if (time >= 1f)
					{
						break;
					}
					yield return null;
					time = Mathf.Clamp01(time + Time.deltaTime * speed_down_wave);
				}
			}
		}

		public void StopDownCam()
		{
			if (downWrapper.IsPlaying)
			{
				downWrapper.Stop();
			}
			Vector3 position = rigChildTF.position;
			position.y = rig_height;
			rigChildTF.position = position;
		}
	}
	public class PlayerCtrl : BoxerClass
	{
		public static PlayerCtrl Instance;

		private Transform myTF;

		private Transform camTF;

		private Rigidbody head_RB;

		private Define.PlayerState playerState;

		public Define.PlayerGloveState[] gloveStates = new Define.PlayerGloveState[2];

		public HitEffectCtrl[] punchEffs;

		public AnimationCurve damageMoveCurve;

		public LayerMask gloveTargetLayer;

		private CoroutineWrapper backMoveWrapper;

		private CoroutineWrapper damageMoveWrapper;

		[SerializeField]
		private AudioSource voiceSource;

		[SerializeField]
		private AudioClip[] voiceClips;

		public void SetPlay()
		{
			playerState = Define.PlayerState.Normal;
		}

		public Define.PlayerGloveState[] GetGloveState()
		{
			return gloveStates;
		}

		private void Awake()
		{
			if (Instance == null)
			{
				Instance = this;
			}
			else if (Instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			backMoveWrapper = CoroutineWrapper.Generate(this);
			damageMoveWrapper = CoroutineWrapper.Generate(this);
		}

		private void Start()
		{
			Initializing();
		}

		private void Initializing()
		{
			myTF = GetComponent<Transform>();
			camTF = Camera.main.transform;
			head_RB = camTF.GetComponent<Rigidbody>();
			playerState = Define.PlayerState.Stop;
			for (int i = 0; i < 2; i++)
			{
				gloveStates[i] = Define.PlayerGloveState.Idle;
			}
			maxStamina = 150f;
			curStamina = maxStamina;
			staminaSpeed = 5f;
			maxHealth = 500f;
			curHealth = maxHealth;
			healthSpeed = 1f;
		}

		private void Update()
		{
			if (playerState != Define.PlayerState.Stop)
			{
				Recovery(isSTEnabled: true);
			}
		}

		private void FixedUpdate()
		{
			if (playerState != Define.PlayerState.Stop)
			{
				CheckGloveActive();
				CheckPlayerGloveState();
			}
		}

		private void CheckGloveActive()
		{
			for (int i = 0; i < 2; i++)
			{
				if (!LocalSingleton<GloveManager>.Instance.gloveColliders[i].isCheckCollider.CurrentData && Physics.SphereCastAll(LocalSingleton<GloveManager>.Instance.gloveColliders[i].myRB.worldCenterOfMass, 0.3f, Vector3.up, 0f, gloveTargetLayer).Length == 0)
				{
					LocalSingleton<GloveManager>.Instance.gloveColliders[i].isCheckCollider.CurrentData = true;
				}
			}
		}

		public void CheckPlayerGloveState()
		{
			for (int i = 0; i < 2; i++)
			{
				Vector3 worldCenterOfMass = LocalSingleton<GloveManager>.Instance.gloveColliders[i].myRB.worldCenterOfMass;
				Vector3 vector = CPUCtrl.Instance.ragdoll.bones[RagdollBones.Head].ragdoll_RB.worldCenterOfMass - worldCenterOfMass;
				GloveManager.GloveDatum gloveDatum = LocalSingleton<GloveManager>.Instance.GetGloveDatum(i);
				if (vector.sqrMagnitude > 0.4f || gloveDatum.mag < 0.1f || Vector3.Dot(gloveDatum.dir, vector.normalized) <= 0.5f)
				{
					if (vector.sqrMagnitude <= 0.4f && gloveDatum.mag > 0.05f && Vector3.Dot(gloveDatum.dir, vector.normalized) > 0f)
					{
						gloveStates[i] = Define.PlayerGloveState.Work;
					}
					else
					{
						gloveStates[i] = Define.PlayerGloveState.Idle;
					}
					continue;
				}
				Vector3 worldCenterOfMass2 = CPUCtrl.Instance.ragdoll.bones[RagdollBones.Hips].ragdoll_RB.worldCenterOfMass;
				if ((worldCenterOfMass - worldCenterOfMass2).sqrMagnitude + 0.03f < (worldCenterOfMass - worldCenterOfMass2).sqrMagnitude)
				{
					gloveStates[i] = Define.PlayerGloveState.Body;
				}
				else if (Vector3.Dot(CPUCtrl.Instance.transform.right, vector.normalized) < 0.2f && Vector3.Dot(-CPUCtrl.Instance.transform.right, vector.normalized) < 0.2f)
				{
					gloveStates[i] = Define.PlayerGloveState.Straight;
				}
				else if (Vector3.Dot(CPUCtrl.Instance.transform.right, vector.normalized) > 0.3f)
				{
					gloveStates[i] = Define.PlayerGloveState.HookR;
				}
				else if (Vector3.Dot(-CPUCtrl.Instance.transform.right, vector.normalized) > 0.3f)
				{
					gloveStates[i] = Define.PlayerGloveState.HookL;
				}
			}
		}

		public override void CheckAttack(Collision collision, bool isRight)
		{
			int num = (isRight ? 1 : 0);
			Collider collider = collision.collider;
			if (collider.CompareTag("Enemy_Glove") && CPUCtrl.Instance.IsStartPunchTime())
			{
				SetPlay();
				CPUCtrl.Instance.StartPlay();
				StartEffect(collider.transform.position, num, 10f, isGuard: false);
			}
			else
			{
				if (!collider.CompareTag("Enemy_Glove") && !collider.CompareTag("Enemy_Head") && !collider.CompareTag("Enemy_Body") && !collider.CompareTag("Enemy_Arm"))
				{
					return;
				}
				GloveManager.GloveDatum gloveDatum = LocalSingleton<GloveManager>.Instance.GetGloveDatum(num);
				if (Vector3.Dot(gloveDatum.dir, -collision.contacts[0].normal) <= 0.3f)
				{
					return;
				}
				if (CPUCtrl.Instance.isGuardPerfect && !CPUCtrl.Instance.IsWeaving())
				{
					LocalSingleton<GameManager>.Instance.attack_f++;
					RaycastHit[] array = Physics.SphereCastAll(gloveDatum.pos, 0.3f, gloveDatum.dir, 0.3f, gloveTargetLayer);
					int num2 = 0;
					if (num2 < array.Length)
					{
						RaycastHit raycastHit = array[num2];
						if (raycastHit.collider.CompareTag("Enemy_Head"))
						{
							LocalSingleton<GloveManager>.Instance.GloveHitEvent(num, isGuard: true);
							CPUCtrl.Instance.SetGuardForce(gloveDatum.dir * 1f, isHead: true);
							StartEffect(collision.contacts[0].point, num, gloveDatum.mag, isGuard: true);
						}
						else
						{
							raycastHit.collider.CompareTag("Enemy_Body");
							LocalSingleton<GloveManager>.Instance.GloveHitEvent(num, isGuard: true);
							CPUCtrl.Instance.SetGuardForce(gloveDatum.dir * 1f, isHead: false);
							StartEffect(collision.contacts[0].point, num, gloveDatum.mag, isGuard: true);
						}
					}
				}
				else if (collider.CompareTag("Enemy_Head"))
				{
					LocalSingleton<GloveManager>.Instance.GloveHitEvent(num, isGuard: false);
					CPUCtrl.Instance.SetHeadForce(gloveStates[num], gloveDatum.dir * 1f, gloveDatum.mag);
					StartEffect(collider.transform.position + CPUCtrl.Instance.transform.up * 0.2f, num, gloveDatum.mag, isGuard: false);
				}
				else if (collider.CompareTag("Enemy_Body") && !(Vector3.Dot(gloveDatum.dir, Vector3.up) > 0.7f))
				{
					LocalSingleton<GloveManager>.Instance.GloveHitEvent(num, isGuard: false);
					CPUCtrl.Instance.SetBodyForce(gloveDatum.veloc, gloveDatum.mag);
					StartEffect(collider.transform.position + CPUCtrl.Instance.transform.forward * 0.1f, num, gloveDatum.mag, isGuard: false);
				}
			}
		}

		private void StartEffect(Vector3 pos, int handDir, float force, bool isGuard)
		{
			punchEffs[handDir].StartEffect(pos, isGuard, force);
		}

		public void SetHeight()
		{
			float num = 1.65f - (camTF.position - camTF.forward * 0.1f).y;
			base.transform.GetChild(0).position += Vector3.up * num;
			LocalSingleton<PlayerCamActionCtrl>.Instance.rig_height = num;
		}

		public void StartDamage(Vector3 damageVec, float damageP)
		{
			LocalSingleton<PlayerCamActionCtrl>.Instance.StartShakeCam();
			if (playerState == Define.PlayerState.Down)
			{
				return;
			}
			LocalSingleton<GameManager>.Instance.guard_f++;
			LocalSingleton<CamEffectCtrl>.Instance.StartDamageEffect();
			LocalSingleton<PlayerCamActionCtrl>.Instance.StartDamageCam(damageVec);
			if (LocalSingleton<GameManager>.Instance.testMode != GameManager.TestMode.Infinite)
			{
				DamageVoice();
				SetHP(damageP / 2f);
				SetST(damageP);
				if (curStamina <= 0f)
				{
					LocalSingleton<GameManager>.Instance.PlayerDown(curHealth / maxHealth);
				}
			}
		}

		private void DamageVoice()
		{
			voiceSource.clip = voiceClips[(int)UnityEngine.Random.Range(0f, (float)voiceClips.Length - 0.0001f)];
			voiceSource.Play();
		}

		public void StartBackMove()
		{
			if (!backMoveWrapper.IsPlaying)
			{
				backMoveWrapper.Start(BackMoveCoroutine());
			}
			IEnumerator BackMoveCoroutine()
			{
				if (damageMoveWrapper.IsPlaying)
				{
					damageMoveWrapper.Stop();
				}
				Vector3 movePos = head_RB.worldCenterOfMass - CPUCtrl.Instance.transform.position;
				movePos.y = 0f;
				movePos = myTF.position + movePos.normalized * 1.3f;
				while ((myTF.position - movePos).sqrMagnitude > 0.01f)
				{
					myTF.position = Vector3.MoveTowards(myTF.position, movePos, Time.deltaTime * 2f);
					Vector3 worldCenterOfMass = head_RB.worldCenterOfMass;
					Vector3 position = myTF.position;
					float num = 2f;
					if (worldCenterOfMass.x > num)
					{
						position.x -= worldCenterOfMass.x - num;
					}
					else if (worldCenterOfMass.x < 0f - num)
					{
						position.x -= worldCenterOfMass.x + num;
					}
					if (worldCenterOfMass.z > num)
					{
						position.z -= worldCenterOfMass.z - num;
					}
					else if (worldCenterOfMass.z < 0f - num)
					{
						position.z -= worldCenterOfMass.z + num;
					}
					myTF.position = position;
					yield return null;
					movePos.y = myTF.position.y;
				}
			}
		}

		public void SetPosition(Transform setPosTF)
		{
			if (backMoveWrapper.IsPlaying)
			{
				backMoveWrapper.Stop();
			}
			if (damageMoveWrapper.IsPlaying)
			{
				damageMoveWrapper.Stop();
			}
			myTF.position = new Vector3(setPosTF.position.x, myTF.position.y, setPosTF.position.z);
			myTF.rotation = setPosTF.rotation;
		}

		public void StartDownState()
		{
			playerState = Define.PlayerState.Down;
			LocalSingleton<PlayerCamActionCtrl>.Instance.StartDownCam(PlayerCamActionCtrl.DownState.Start);
			StartBackMove();
			StartBackMove();
			LocalSingleton<CamEffectCtrl>.Instance.StartDownEffect();
		}

		public void ResetState()
		{
			LocalSingleton<PlayerCamActionCtrl>.Instance.StopDownCam();
			LocalSingleton<CamEffectCtrl>.Instance.StartReadyEffect();
		}

		public void WakeDownState()
		{
			playerState = Define.PlayerState.Normal;
			LocalSingleton<PlayerCamActionCtrl>.Instance.StartDownCam(PlayerCamActionCtrl.DownState.Wake);
			LocalSingleton<CamEffectCtrl>.Instance.StartWakeUpEffect();
			curStamina = maxStamina;
		}

		public void EndDownState()
		{
			LocalSingleton<PlayerCamActionCtrl>.Instance.StartDownCam(PlayerCamActionCtrl.DownState.End);
			LocalSingleton<CamEffectCtrl>.Instance.StartKOEffect();
			Invoke("DelayPlayRingSound", 1.5f);
		}

		private void DelayPlayRingSound()
		{
			LocalSingleton<GameManager>.Instance.PlayRingSound();
		}

		public void StartCamWave()
		{
			LocalSingleton<PlayerCamActionCtrl>.Instance.StartDownCam(PlayerCamActionCtrl.DownState.Wave);
		}

		public void StartDamageMove(float dist)
		{
			if (damageMoveWrapper.IsPlaying)
			{
				damageMoveWrapper.Stop();
			}
			Vector3 vector = CPUCtrl.Instance.transform.position - head_RB.worldCenterOfMass;
			vector.y = 0f;
			vector = vector.normalized * dist;
			damageMoveWrapper.Start(DamageMoveCoroutine(vector, dist));
		}

		private IEnumerator DamageMoveCoroutine(Vector3 damageMovePos, float dist)
		{
			float time = 0f;
			while (true)
			{
				myTF.position += damageMovePos * (damageMoveCurve.Evaluate(time + Time.deltaTime * 3.5f) - damageMoveCurve.Evaluate(time));
				Vector3 worldCenterOfMass = head_RB.worldCenterOfMass;
				Vector3 position = myTF.position;
				float num = 1.3f;
				if (dist < 0f)
				{
					num = 1.7f;
				}
				if (worldCenterOfMass.x > num)
				{
					position.x -= worldCenterOfMass.x - num;
				}
				else if (worldCenterOfMass.x < 0f - num)
				{
					position.x -= worldCenterOfMass.x + num;
				}
				if (worldCenterOfMass.z > num)
				{
					position.z -= worldCenterOfMass.z - num;
				}
				else if (worldCenterOfMass.z < 0f - num)
				{
					position.z -= worldCenterOfMass.z + num;
				}
				myTF.position = position;
				if (time >= 1f)
				{
					break;
				}
				yield return null;
				time += Time.deltaTime * 3.5f;
			}
		}
	}
	public class PostProcessFadeCtrl : LocalSingleton<PostProcessFadeCtrl>
	{
		public enum FadeState
		{
			Normal,
			LoadScene
		}

		private ColorAdjustments color;

		private Vignette vignette;

		private FadeState fadeState;

		private bool isFadeIn;

		private float fadeSpeed;

		private int sceneIndex;

		private string sceneName;

		private CoroutineWrapper fadeWrapper;

		private void Start()
		{
			Volume component = base.transform.GetComponent<Volume>();
			component.sharedProfile.TryGet<ColorAdjustments>(out color);
			component.sharedProfile.TryGet<Vignette>(out vignette);
			color.colorFilter.value = Color.black;
			fadeWrapper = CoroutineWrapper.Generate(this);
		}

		public void StopFade()
		{
			if (fadeWrapper.IsPlaying)
			{
				fadeWrapper.Stop();
			}
			color.active = false;
			vignette.active = false;
		}

		public void StartFade(bool _isFadeIn, float _fadeSpeed = 0.75f)
		{
			if (fadeWrapper.IsPlaying)
			{
				fadeWrapper.Stop();
			}
			fadeState = FadeState.Normal;
			isFadeIn = _isFadeIn;
			fadeSpeed = _fadeSpeed;
			fadeWrapper.Start(FadeCoroutine());
		}

		private IEnumerator FadeCoroutine()
		{
			color.active = true;
			vignette.active = true;
			float velueP = 0f;
			if (isFadeIn)
			{
				color.colorFilter.value = Color.black;
				yield return new WaitForSeconds(0.3f);
				while (true)
				{
					velueP = Mathf.Clamp01(velueP + Time.deltaTime * fadeSpeed);
					color.colorFilter.value = Color.Lerp(Color.black, Color.white, velueP);
					if (velueP == 1f)
					{
						break;
					}
					yield return null;
				}
				color.active = false;
				vignette.active = false;
				yield break;
			}
			while (true)
			{
				velueP = Mathf.Clamp01(velueP + Time.deltaTime * fadeSpeed);
				color.colorFilter.value = Color.Lerp(Color.white, Color.black, velueP);
				if (velueP == 1f)
				{
					break;
				}
				yield return null;
			}
			if (fadeState == FadeState.LoadScene)
			{
				if (sceneIndex == -1)
				{
					SceneManager.LoadScene(sceneName);
				}
				else
				{
					SceneManager.LoadScene(sceneIndex);
				}
			}
		}
	}
	public class RagdollCreator : MonoBehaviour
	{
		public void CreateRagdoll()
		{
			Animator component = base.transform.GetComponent<Animator>();
			component.updateMode = AnimatorUpdateMode.Normal;
			component.cullingMode = AnimatorCullingMode.AlwaysAnimate;
			Transform transform = new GameObject(base.gameObject.name).transform;
			transform.SetPositionAndRotation(base.transform.position, base.transform.rotation);
			Transform transform2 = UnityEngine.Object.Instantiate(base.transform, base.transform.position, base.transform.rotation, transform);
			transform2.name = "Origin";
			UnityEngine.Object.DestroyImmediate(transform2.GetComponent<RagdollCreator>());
			Transform transform3 = UnityEngine.Object.Instantiate(base.transform, base.transform.position, base.transform.rotation, transform);
			transform3.name = "Ragdoll";
			UnityEngine.Debug.Log("오브젝트 복제");
			Transform[] componentsInChildren = transform3.GetComponentsInChildren<Transform>(includeInactive: true);
			List<GameObject> list = new List<GameObject>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].name.Contains("Footstep") || componentsInChildren[i].name.Contains("Twist") || componentsInChildren[i].name.Contains("Clavicle") || componentsInChildren[i].name.Contains("Neck") || componentsInChildren[i].name.Contains("Finger") || componentsInChildren[i].name.Contains("HeadNub") || (componentsInChildren[i].name.Contains("Spine") && !componentsInChildren[i].name.Contains("Spine2")) || componentsInChildren[i].name.Contains("Toe") || componentsInChildren[i].name.Contains("Eye") || componentsInChildren[i].name.Equals("Bip001") || (!componentsInChildren[i].name.Equals("Ragdoll") && !componentsInChildren[i].name.Contains("Bip001")))
				{
					list.Add(componentsInChildren[i].gameObject);
				}
			}
			for (int num = list.Count - 1; num >= 0; num--)
			{
				if (list[num].name.Equals("Bip001") || list[num].name.Contains("Clavicle") || list[num].name.Contains("Neck") || list[num].name.Contains("Spine"))
				{
					list[num].transform.GetChild(0).parent = list[num].transform.parent;
				}
				UnityEngine.Object.DestroyImmediate(list[num]);
			}
			Transform[] componentsInChildren2 = transform3.GetComponentsInChildren<Transform>();
			for (int j = 0; j < componentsInChildren2.Length; j++)
			{
				Transform transform4 = componentsInChildren2[j];
				componentsInChildren2[j] = new GameObject(transform4.name).transform;
				componentsInChildren2[j].parent = transform4.parent;
				componentsInChildren2[j].localPosition = transform4.localPosition;
				componentsInChildren2[j].localRotation = transform4.localRotation;
				componentsInChildren2[j].localScale = Vector3.one;
				while (transform4.childCount > 0)
				{
					transform4.GetChild(0).parent = componentsInChildren2[j];
				}
				UnityEngine.Object.DestroyImmediate(transform4.gameObject);
			}
			transform3 = componentsInChildren2[0];
			UnityEngine.Debug.Log("필요없는 Bone 제거.");
			for (int k = 0; k < componentsInChildren2.Length; k++)
			{
				if (!componentsInChildren2[k].name.Equals("Ragdoll"))
				{
					Rigidbody rigidbody = componentsInChildren2[k].gameObject.AddComponent<Rigidbody>();
					rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
					rigidbody.drag = 1f;
					rigidbody.angularDrag = 1f;
					if (componentsInChildren2[k].name.Contains("Pelvis"))
					{
						rigidbody.useGravity = false;
						rigidbody.isKinematic = true;
						rigidbody.mass = 10f;
					}
					else if (componentsInChildren2[k].name.Contains("Thigh"))
					{
						rigidbody.mass = 10f;
					}
					else if (componentsInChildren2[k].name.Contains("Calf"))
					{
						rigidbody.mass = 5f;
					}
					else if (componentsInChildren2[k].name.Contains("Foot"))
					{
						rigidbody.mass = 3f;
					}
					else if (componentsInChildren2[k].name.Contains("Spine"))
					{
						rigidbody.mass = 30f;
					}
					else if (componentsInChildren2[k].name.Contains("UpperArm"))
					{
						rigidbody.mass = 30f;
					}
					else if (componentsInChildren2[k].name.Contains("Forearm"))
					{
						rigidbody.mass = 30f;
					}
					else if (componentsInChildren2[k].name.Contains("Hand"))
					{
						rigidbody.mass = 30f;
					}
					else if (componentsInChildren2[k].name.Contains("Head"))
					{
						rigidbody.mass = 3f;
					}
				}
			}
			UnityEngine.Debug.Log("리지드바디/태그 추가.");
			for (int l = 0; l < componentsInChildren2.Length; l++)
			{
				if (!componentsInChildren2[l].name.Equals("Ragdoll"))
				{
					ConfigurableJoint configurableJoint = componentsInChildren2[l].gameObject.AddComponent<ConfigurableJoint>();
					configurableJoint.axis = Vector3.right;
					configurableJoint.secondaryAxis = Vector3.up;
					if (componentsInChildren2[l].name.Contains("Pelvis"))
					{
						configurableJoint.xMotion = ConfigurableJointMotion.Free;
						configurableJoint.yMotion = ConfigurableJointMotion.Free;
						configurableJoint.zMotion = ConfigurableJointMotion.Free;
					}
					else
					{
						configurableJoint.connectedBody = componentsInChildren2[l].parent.GetComponent<Rigidbody>();
						configurableJoint.xMotion = ConfigurableJointMotion.Locked;
						configurableJoint.yMotion = ConfigurableJointMotion.Locked;
						configurableJoint.zMotion = ConfigurableJointMotion.Locked;
					}
					configurableJoint.angularXMotion = ConfigurableJointMotion.Free;
					configurableJoint.angularYMotion = ConfigurableJointMotion.Free;
					configurableJoint.angularZMotion = ConfigurableJointMotion.Free;
					configurableJoint.rotationDriveMode = RotationDriveMode.Slerp;
					if (componentsInChildren2[l].name.Contains("Spine"))
					{
						configurableJoint.anchor = Vector3.right * 0.15f;
					}
					else if (componentsInChildren2[l].name.Contains("Bip001 Head"))
					{
						configurableJoint.anchor = Vector3.right * 0.15f;
					}
				}
			}
			UnityEngine.Debug.Log("조인트 추가.");
			for (int m = 0; m < componentsInChildren2.Length; m++)
			{
				if (componentsInChildren2[m].name.Contains("Pelvis"))
				{
					CapsuleCollider capsuleCollider = componentsInChildren2[m].gameObject.AddComponent<CapsuleCollider>();
					capsuleCollider.center = new Vector3(-0.2f, 0.01f, 0f);
					capsuleCollider.radius = 0.16f;
					capsuleCollider.height = 0.45f;
					capsuleCollider.direction = 0;
				}
				else if (componentsInChildren2[m].name.Contains("Thigh"))
				{
					CapsuleCollider capsuleCollider2 = componentsInChildren2[m].gameObject.AddComponent<CapsuleCollider>();
					capsuleCollider2.center = new Vector3(-0.35f, 0f, 0f);
					capsuleCollider2.radius = 0.1f;
					capsuleCollider2.height = 0.35f;
					capsuleCollider2.direction = 0;
				}
				else if (componentsInChildren2[m].name.Contains("Calf"))
				{
					CapsuleCollider capsuleCollider3 = componentsInChildren2[m].gameObject.AddComponent<CapsuleCollider>();
					capsuleCollider3.center = new Vector3(-0.2f, 0f, 0f);
					capsuleCollider3.radius = 0.08f;
					capsuleCollider3.height = 0.25f;
					capsuleCollider3.direction = 0;
				}
				else if (componentsInChildren2[m].name.Contains("Foot"))
				{
					BoxCollider boxCollider = componentsInChildren2[m].gameObject.AddComponent<BoxCollider>();
					boxCollider.center = new Vector3(-0.03f, 0.1f, 0f);
					boxCollider.size = new Vector3(0.1f, 0.3f, 0.1f);
				}
				else if (componentsInChildren2[m].name.Contains("Spine"))
				{
					CapsuleCollider capsuleCollider4 = componentsInChildren2[m].gameObject.AddComponent<CapsuleCollider>();
					capsuleCollider4.center = new Vector3(-0.06f, -0.035f, 0f);
					capsuleCollider4.radius = 0.12f;
					capsuleCollider4.height = 0.33f;
					capsuleCollider4.direction = 2;
				}
				else if (componentsInChildren2[m].name.Contains("UpperArm"))
				{
					CapsuleCollider capsuleCollider5 = componentsInChildren2[m].gameObject.AddComponent<CapsuleCollider>();
					capsuleCollider5.center = new Vector3(-0.2f, 0f, 0f);
					capsuleCollider5.radius = 0.05f;
					capsuleCollider5.height = 0.3f;
					capsuleCollider5.direction = 0;
				}
				else if (componentsInChildren2[m].name.Contains("Forearm"))
				{
					CapsuleCollider capsuleCollider6 = componentsInChildren2[m].gameObject.AddComponent<CapsuleCollider>();
					capsuleCollider6.center = new Vector3(-0.15f, 0f, 0f);
					capsuleCollider6.radius = 0.05f;
					capsuleCollider6.height = 0.2f;
					capsuleCollider6.direction = 0;
				}
				else if (componentsInChildren2[m].name.Contains("Hand"))
				{
					SphereCollider sphereCollider = componentsInChildren2[m].gameObject.AddComponent<SphereCollider>();
					sphereCollider.center = new Vector3(-0.07f, 0.035f, 0f);
					sphereCollider.radius = 0.1f;
				}
				else if (componentsInChildren2[m].name.Contains("Head"))
				{
					CapsuleCollider capsuleCollider7 = componentsInChildren2[m].gameObject.AddComponent<CapsuleCollider>();
					capsuleCollider7.center = new Vector3(-0.05f, 0.05f, 0f);
					capsuleCollider7.radius = 0.1f;
					capsuleCollider7.height = 0.3f;
					capsuleCollider7.direction = 0;
				}
			}
			UnityEngine.Debug.Log("콜라이더 추가.");
			Transform[] componentsInChildren3 = transform2.GetComponentsInChildren<Transform>(includeInactive: true);
			ActiveRagdollManager activeRagdollManager = transform3.gameObject.AddComponent<ActiveRagdollManager>();
			UnityEngine.Debug.Log("ActiveRagdollManager 스크립트 추가.");
			activeRagdollManager.bones = new ActiveRagdollManager.Bone[15];
			string text = "Pelvis";
			activeRagdollManager.bones[0].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[0].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[0].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "L Thigh";
			activeRagdollManager.bones[1].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[1].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[1].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "R Thigh";
			activeRagdollManager.bones[2].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[2].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[2].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "L Calf";
			activeRagdollManager.bones[3].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[3].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[3].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "R Calf";
			activeRagdollManager.bones[4].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[4].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[4].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "L Foot";
			activeRagdollManager.bones[5].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[5].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[5].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "R Foot";
			activeRagdollManager.bones[6].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[6].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[6].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "Spine2";
			activeRagdollManager.bones[7].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[7].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[7].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "Head";
			activeRagdollManager.bones[8].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[8].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[8].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "L UpperArm";
			activeRagdollManager.bones[9].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[9].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[9].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "R UpperArm";
			activeRagdollManager.bones[10].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[10].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[10].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "L Forearm";
			activeRagdollManager.bones[11].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[11].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[11].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "R Forearm";
			activeRagdollManager.bones[12].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[12].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[12].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "L Hand";
			activeRagdollManager.bones[13].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[13].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[13].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			text = "R Hand";
			activeRagdollManager.bones[14].origin = GetFindObject(text, componentsInChildren3);
			activeRagdollManager.bones[14].ragdoll_Joint = GetFindObject(text, componentsInChildren2).GetComponent<ConfigurableJoint>();
			activeRagdollManager.bones[14].ragdoll_RB = GetFindObject(text, componentsInChildren2).GetComponent<Rigidbody>();
			activeRagdollManager.spine0TF = GetFindObject("Spine", componentsInChildren3);
			activeRagdollManager.spine1TF = GetFindObject("Spine1", componentsInChildren3);
			activeRagdollManager.neckTF = GetFindObject("Neck", componentsInChildren3);
			activeRagdollManager.clavicleTF_L = GetFindObject("L Clavicle", componentsInChildren3);
			activeRagdollManager.clavicleTF_R = GetFindObject("R Clavicle", componentsInChildren3);
			activeRagdollManager.anim = transform2.GetComponent<Animator>();
			AnimationCurve animationCurve = new AnimationCurve();
			animationCurve.AddKey(new Keyframe(0f, 0f, 10f, 10f));
			animationCurve.AddKey(new Keyframe(0.06f, 0.55f, 7f, 7f));
			animationCurve.AddKey(new Keyframe(0.2f, 1f, 0f, 0f));
			animationCurve.AddKey(new Keyframe(0.85f, -0.06f, 1.2f, 1.2f));
			animationCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f));
			activeRagdollManager.bodyDamageCurve = animationCurve;
			UnityEngine.Debug.Log("ActiveRagdollManager Bone 등록");
			UnityEngine.Debug.Log("세팅 완료.");
		}

		private Transform GetFindObject(string name, Transform[] transforms)
		{
			for (int i = 0; i < transforms.Length; i++)
			{
				if (transforms[i].name.Contains(name) && (!(name == "Spine") || (!transforms[i].name.Contains("Spine1") && !transforms[i].name.Contains("Spine2"))))
				{
					return transforms[i];
				}
			}
			return null;
		}
	}
	public class SpectatorSoundCtrl : LocalSingleton<SpectatorSoundCtrl>
	{
		[Serializable]
		public struct SpectatorClip
		{
			public AudioClip cheer;

			public AudioClip ohh;
		}

		[SerializeField]
		private AudioSource[] spectatorSources;

		[SerializeField]
		private SpectatorClip[] spectatorClip;

		public void PlaySoundEternal(bool isCheer)
		{
			for (int i = 0; i < spectatorSources.Length; i++)
			{
				if (isCheer)
				{
					spectatorSources[i].clip = spectatorClip[i].cheer;
				}
				else
				{
					spectatorSources[i].clip = spectatorClip[i].ohh;
				}
				spectatorSources[i].Play();
			}
		}

		public static void PlaySound(bool isCheer)
		{
			if (!(LocalSingleton<SpectatorSoundCtrl>.Instance == null))
			{
				LocalSingleton<SpectatorSoundCtrl>.Instance.PlaySoundEternal(isCheer);
			}
		}
	}
	public class SpineCtrl : MonoBehaviour
	{
		public Transform[] spineTFs;

		[SerializeField]
		private Transform[] thumb_L;

		[SerializeField]
		private Transform[] index_L;

		[SerializeField]
		private Transform[] middle_L;

		[SerializeField]
		private Transform[] ring_L;

		[SerializeField]
		private Transform[] little_L;

		[SerializeField]
		private Transform[] thumb_R;

		[SerializeField]
		private Transform[] index_R;

		[SerializeField]
		private Transform[] middle_R;

		[SerializeField]
		private Transform[] ring_R;

		[SerializeField]
		private Transform[] little_R;

		public Transform neckTF;

		public Transform headTF;

		private Transform myTF;

		public Transform targetTF;

		private bool isRagdoll;

		public AnimationCurve spinesCurve = AnimationCurve.Linear(0f, 0.5f, 1f, 0.5f);

		private float[] spinesNormalP;

		[Range(0f, 1f)]
		public float weight_master = 1f;

		[Range(0f, 1f)]
		public float weight_spines = 1f;

		[Range(0f, 1f)]
		public float weight_neck = 1f;

		[Range(0f, 1f)]
		public float weight_head = 1f;

		public float lookHeight = 1.7f;

		public float lookRate = 0.65f;

		[SerializeField]
		private Vector3[] rot_thumb_L = new Vector3[3];

		private Vector3[] rot_index_L = new Vector3[3];

		private Vector3[] rot_middle_L = new Vector3[3];

		private Vector3[] rot_ring_L = new Vector3[3];

		[SerializeField]
		private Vector3[] rot_little_L = new Vector3[3];

		[SerializeField]
		private Vector3[] rot_thumb_R = new Vector3[3];

		private Vector3[] rot_index_R = new Vector3[3];

		private Vector3[] rot_middle_R = new Vector3[3];

		private Vector3[] rot_ring_R = new Vector3[3];

		[SerializeField]
		private Vector3[] rot_little_R = new Vector3[3];

		private void Start()
		{
			myTF = GetComponent<Transform>();
			spinesNormalP = new float[spineTFs.Length];
			SetSpineNormalize();
		}

		public void SetFingerRot(int gender)
		{
			if (gender == 0)
			{
				rot_thumb_L[0] = new Vector3(45f, -90f, -49f);
				rot_thumb_L[1] = new Vector3(0f, 0f, -17.564f);
				rot_thumb_L[2] = new Vector3(0f, 0f, -17.682f);
				rot_index_L[0] = new Vector3(6.78f, -0.697f, -67.34901f);
				rot_index_L[1] = new Vector3(0f, 0f, -52.403f);
				rot_index_L[2] = new Vector3(0f, 0f, -23.079f);
				rot_middle_L[0] = new Vector3(-4f, -15.5f, -75f);
				rot_middle_L[1] = new Vector3(0f, 0f, -55f);
				rot_middle_L[2] = new Vector3(0f, 0f, -25f);
				rot_ring_L[0] = new Vector3(-12f, -5f, -71f);
				rot_ring_L[1] = new Vector3(0f, 0f, -52.465f);
				rot_ring_L[2] = new Vector3(0f, 0f, -23.53201f);
				rot_little_L[0] = new Vector3(-17.223f, -2.385f, -57f);
				rot_little_L[1] = new Vector3(0f, 0f, -52f);
				rot_little_L[2] = new Vector3(0f, 0f, -23f);
				rot_thumb_R[0] = new Vector3(-45f, 90f, -49f);
				rot_thumb_R[1] = new Vector3(0f, 0f, -17.564f);
				rot_thumb_R[2] = new Vector3(0f, 0f, -17.682f);
				rot_index_R[0] = new Vector3(-6.78f, 0.697f, -67.34901f);
				rot_index_R[1] = new Vector3(0f, 0f, -52.403f);
				rot_index_R[2] = new Vector3(0f, 0f, -23.079f);
				rot_middle_R[0] = new Vector3(4f, 15.5f, -75f);
				rot_middle_R[1] = new Vector3(0f, 0f, -55f);
				rot_middle_R[2] = new Vector3(0f, 0f, -25f);
				rot_ring_R[0] = new Vector3(12f, 5f, -71f);
				rot_ring_R[1] = new Vector3(0f, 0f, -52.403f);
				rot_ring_R[2] = new Vector3(0f, 0f, -23.079f);
				rot_little_R[0] = new Vector3(17.223f, 2.385f, -57f);
				rot_little_R[1] = new Vector3(0f, 0f, -52f);
				rot_little_R[2] = new Vector3(0f, 0f, -23f);
			}
			else
			{
				rot_thumb_L[0] = new Vector3(49.4f, -88.5f, -49f);
				rot_thumb_L[1] = new Vector3(0f, 0f, -17.564f);
				rot_thumb_L[2] = new Vector3(0f, 0f, -17.682f);
				rot_index_L[0] = new Vector3(6.78f, -0.697f, -67.34901f);
				rot_index_L[1] = new Vector3(0f, 0f, -52.403f);
				rot_index_L[2] = new Vector3(0f, 0f, -23.079f);
				rot_middle_L[0] = new Vector3(-4f, -15.5f, -75f);
				rot_middle_L[1] = new Vector3(0f, 0f, -55f);
				rot_middle_L[2] = new Vector3(0f, 0f, -25f);
				rot_ring_L[0] = new Vector3(-12f, -5f, -71f);
				rot_ring_L[1] = new Vector3(0f, 0f, -52.465f);
				rot_ring_L[2] = new Vector3(0f, 0f, -23.53201f);
				rot_little_L[0] = new Vector3(-12.4f, -2.385f, -57f);
				rot_little_L[1] = new Vector3(0f, 0f, -52f);
				rot_little_L[2] = new Vector3(0f, 0f, -23f);
				rot_thumb_R[0] = new Vector3(-49.4f, 88.5f, -49f);
				rot_thumb_R[1] = new Vector3(0f, 0f, -17.564f);
				rot_thumb_R[2] = new Vector3(0f, 0f, -17.682f);
				rot_index_R[0] = new Vector3(-6.78f, 0.697f, -67.34901f);
				rot_index_R[1] = new Vector3(0f, 0f, -52.403f);
				rot_index_R[2] = new Vector3(0f, 0f, -23.079f);
				rot_middle_R[0] = new Vector3(4f, 15.5f, -75f);
				rot_middle_R[1] = new Vector3(0f, 0f, -55f);
				rot_middle_R[2] = new Vector3(0f, 0f, -25f);
				rot_ring_R[0] = new Vector3(12f, 5f, -71f);
				rot_ring_R[1] = new Vector3(0f, 0f, -52.403f);
				rot_ring_R[2] = new Vector3(0f, 0f, -23.079f);
				rot_little_R[0] = new Vector3(12.4f, 2.385f, -57f);
				rot_little_R[1] = new Vector3(0f, 0f, -52f);
				rot_little_R[2] = new Vector3(0f, 0f, -23f);
			}
		}

		public void SetRagdoll()
		{
			isRagdoll = true;
		}

		private void LateUpdate()
		{
			if (!isRagdoll)
			{
				UpdateData();
			}
		}

		public void UpdateData()
		{
			UpdateSpines();
			UpdateHead();
			UpdateFinger();
		}

		private void SetSpineNormalize()
		{
			float num = 0f;
			for (int i = 0; i < spinesNormalP.Length; i++)
			{
				spinesNormalP[i] = spinesCurve.Evaluate(i % (spinesNormalP.Length - 1));
				num += spinesNormalP[i];
			}
			for (int j = 0; j < spinesNormalP.Length; j++)
			{
				spinesNormalP[j] %= num;
			}
		}

		public void UpdateSpines()
		{
			Vector3 vector = targetTF.position - myTF.position;
			vector.y = 0f;
			vector = vector.normalized;
			Vector3 normalized = (targetTF.position - myTF.position + new Vector3(0f, 0f - lookHeight, 0f)).normalized;
			float num = Vector3.Angle(vector, normalized);
			num = ((vector.y >= normalized.y) ? num : (0f - num));
			num = Mathf.Clamp(num, -15f, 50f);
			num *= weight_spines * weight_master;
			for (int i = 0; i < spineTFs.Length; i++)
			{
				spineTFs[i].rotation *= Quaternion.AngleAxis(num * spinesNormalP[i] * lookRate, spineTFs[i].InverseTransformVector(myTF.right));
			}
		}

		public void UpdateHead()
		{
			Vector3 normalized = (targetTF.position - neckTF.position).normalized;
			Transform obj = spineTFs[spineTFs.Length - 1];
			Vector3 vector = Vector3.Cross(obj.right, normalized);
			Vector3 b = Vector3.Cross(normalized, vector);
			neckTF.rotation = Quaternion.Lerp(neckTF.rotation, Quaternion.LookRotation(vector, Vector3.Slerp(normalized, b, 0.5f)), weight_neck * weight_master);
			normalized = (targetTF.position - headTF.position - Vector3.up * 0.05f).normalized;
			vector = Vector3.Cross(Vector3.Slerp(obj.right, Vector3.down, 0.8f), normalized);
			headTF.rotation = Quaternion.Lerp(headTF.rotation, Quaternion.LookRotation(vector, normalized), weight_head * weight_master);
		}

		private void UpdateFinger()
		{
			if (thumb_L.Length != 0 && thumb_R.Length != 0)
			{
				for (int i = 0; i < 3; i++)
				{
					thumb_L[i].localRotation = Quaternion.Euler(rot_thumb_L[i]);
					index_L[i].localRotation = Quaternion.Euler(rot_index_L[i]);
					middle_L[i].localRotation = Quaternion.Euler(rot_middle_L[i]);
					ring_L[i].localRotation = Quaternion.Euler(rot_ring_L[i]);
					little_L[i].localRotation = Quaternion.Euler(rot_little_L[i]);
					thumb_R[i].localRotation = Quaternion.Euler(rot_thumb_R[i]);
					index_R[i].localRotation = Quaternion.Euler(rot_index_R[i]);
					middle_R[i].localRotation = Quaternion.Euler(rot_middle_R[i]);
					ring_R[i].localRotation = Quaternion.Euler(rot_ring_R[i]);
					little_R[i].localRotation = Quaternion.Euler(rot_little_R[i]);
				}
			}
		}
	}
}
namespace Jisu.Boxing.HeavyBag
{
	public interface IInitializableListener
	{
		void Initialize();
	}
	public class BeatListener : MonoBehaviour, IInitializableListener
	{
		public enum Type
		{
			Scale,
			Alpha,
			Rotation
		}

		[SerializeField]
		private Type myType;

		[Header("Scale Field")]
		[SerializeField]
		private Vector3 Axis;

		[SerializeField]
		private AnimationCurve scaleCurve;

		[Header("AlphaField")]
		[SerializeField]
		private Image image;

		[SerializeField]
		private float Speed;

		[Header("RotateField")]
		[SerializeField]
		private Vector3 RotateAxis;

		[SerializeField]
		private float AngleAmount;

		[Header("Run Field")]
		[SerializeField]
		private float RunRate = 1f;

		[SerializeField]
		private float RunStartOffset;

		private float RunRateValue;

		[SerializeField]
		private AnimationCurve RunCurve;

		private void Awake()
		{
			TargetManager.OnBeat += Loader_OnBeat;
			TargetManager.OnHit += Loader_OnHit;
			TargetManager.onInitialized += Initialize;
			RunRateValue = RunStartOffset;
		}

		public void Initialize()
		{
			RunRateValue = RunStartOffset;
		}

		protected virtual void Loader_OnBeat(float time)
		{
			RunRateValue += RunRate;
			Quaternion defaultLocalRotation;
			if (!(RunRateValue < 1f))
			{
				RunRateValue = 0f;
				defaultLocalRotation = base.transform.localRotation;
				StartCoroutine(Easy(time, onUpdate));
			}
			void onUpdate(float t)
			{
				switch (myType)
				{
				case Type.Scale:
					base.transform.localScale = Axis * scaleCurve.Evaluate(t) + Vector3.one;
					break;
				case Type.Alpha:
				{
					Color color = image.color;
					color.a = RunCurve.Evaluate(t);
					image.color = color;
					break;
				}
				case Type.Rotation:
					base.transform.localRotation = Quaternion.Lerp(defaultLocalRotation, defaultLocalRotation * Quaternion.Euler(RotateAxis * AngleAmount), RunCurve.Evaluate(t));
					break;
				}
			}
		}

		protected void Loader_OnHit()
		{
			StartCoroutine(Easy(scaleCurve.keys[scaleCurve.length - 1].time, onUpdate));
			void onUpdate(float t)
			{
				base.transform.localScale = Axis * scaleCurve.Evaluate(t) + Vector3.one;
			}
		}

		protected IEnumerator Easy(float runtime, Action<float> OnUpdate)
		{
			float t = 0f;
			while (t < runtime)
			{
				OnUpdate?.Invoke(t / runtime);
				t += Time.deltaTime;
				yield return null;
			}
			OnUpdate?.Invoke(1f);
		}

		private void OnDestroy()
		{
			TargetManager.OnBeat -= Loader_OnBeat;
			TargetManager.OnHit -= Loader_OnHit;
			TargetManager.onInitialized -= Initialize;
		}
	}
	public class ComboEffectCtrl : MonoBehaviour
	{
		private Animator anim;

		[SerializeField]
		private Sprite[] sprite_combo;

		[SerializeField]
		private Image[] image_combo;

		private void Awake()
		{
			anim = GetComponent<Animator>();
		}

		public void SetCombo(int combo)
		{
			if (combo < 2)
			{
				for (int i = 0; i < 4; i++)
				{
					image_combo[i].enabled = false;
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
					image_combo[j].enabled = true;
				}
				int[] array = new int[3]
				{
					(int)((float)(combo % 1000) * 0.01f),
					(int)((float)(combo % 100) * 0.1f),
					combo % 10
				};
				int num = 0;
				if (combo >= 100)
				{
					image_combo[num].sprite = sprite_combo[array[0]];
					num++;
				}
				if (combo >= 10)
				{
					image_combo[num].sprite = sprite_combo[array[1]];
					num++;
				}
				if (combo >= 0)
				{
					image_combo[num].sprite = sprite_combo[array[2]];
					num++;
				}
				for (int k = num; k < 3; k++)
				{
					image_combo[k].sprite = sprite_combo[10];
				}
			}
			anim.SetTrigger("OnUp");
		}
	}
	public class CountEffect : MonoBehaviour
	{
		[Header("Properties")]
		[SerializeField]
		private GameObject myGO;

		[SerializeField]
		private Image image_count;

		[Header("Sprites")]
		[SerializeField]
		private Sprite[] sprite_count;

		[Header("Fade Animation")]
		[SerializeField]
		private float fadeTime;

		[SerializeField]
		private float fadeSpeed;

		private Color originAlpha;

		private bool isStart;

		private void Awake()
		{
			originAlpha = image_count.color;
			isStart = false;
		}

		private void Start()
		{
			StartCoroutine(OnUpdate());
		}

		private IEnumerator OnUpdate()
		{
			while (base.enabled)
			{
				if (!isStart && GameManager.Instance.gameReady)
				{
					isStart = true;
					StartCoroutine("SetCount");
				}
				yield return null;
			}
		}

		private IEnumerator SetCount()
		{
			int num = 2;
			myGO.SetActive(value: true);
			WaitForSeconds wait = new WaitForSeconds(1f);
			while ((float)num >= 0f)
			{
				image_count.sprite = sprite_count[num--];
				SoundManager.PlaySound(Define.SoundType.Count, state: true);
				StartCoroutine(FadeNumber());
				yield return wait;
			}
			myGO.SetActive(value: false);
		}

		private IEnumerator FadeNumber()
		{
			float time = 0f;
			image_count.color = originAlpha;
			WaitForEndOfFrame wait = new WaitForEndOfFrame();
			while (time <= fadeTime)
			{
				time += Time.deltaTime;
				if (time >= fadeTime / 3f)
				{
					Color color = image_count.color;
					color.a = Mathf.Lerp(color.a, 0f, Time.deltaTime * fadeSpeed);
					image_count.color = color;
				}
				yield return wait;
			}
		}
	}
	public class CtrlrCollider : MonoBehaviour
	{
		public Jisu.Utils.Notifier<bool> isCollision { get; private set; } = new Jisu.Utils.Notifier<bool>();


		private void OnTriggerEnter(Collider other)
		{
			if (other.gameObject.CompareTag("SandBagBoundary"))
			{
				isCollision.CurrentData = true;
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.gameObject.CompareTag("SandBagBoundary"))
			{
				isCollision.CurrentData = false;
			}
		}
	}
	public class Define
	{
		public enum Tag
		{
			Glove,
			SandBag,
			SandBagBoundary
		}

		public enum Layer
		{
			Glove = 8,
			SandBag
		}

		public enum ControllerDirection
		{
			Left,
			Right
		}

		public enum ControllerEvent
		{
			Press,
			Down,
			Up,
			Click
		}

		public enum HandDirection
		{
			Left,
			Right,
			Both
		}

		public enum GloveState
		{
			Idle,
			Swing,
			Attach,
			Returning
		}

		public enum HitType
		{
			Perfect,
			Great,
			Good,
			Bad,
			Miss
		}

		public enum SoundType
		{
			BGM,
			GameStart,
			GameOver,
			GlovePunchStrong,
			GlovePunchWeak,
			GloveSwing,
			Count,
			Life,
			Target,
			Button,
			End
		}
	}
	public class DieEffectCtrl : MonoBehaviour
	{
		[SerializeField]
		private GameObject explosionEffect;

		public void SetExplosionActive(bool state)
		{
			explosionEffect.gameObject.SetActive(state);
		}
	}
	public class GameManager : MonoBehaviour
	{
		private static GameManager _instance;

		public static GameManager Instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = UnityEngine.Object.FindObjectOfType<GameManager>();
				}
				return _instance;
			}
		}

		public bool gameover { get; private set; }

		public bool gameReady { get; private set; }

		public float gameTime { get; private set; }

		private void Awake()
		{
			gameover = true;
			gameReady = false;
			gameTime = 0f;
		}

		private void Start()
		{
			SoundManager.PlaySound(Define.SoundType.BGM, state: true);
		}

		private void OnDestroy()
		{
			if (_instance != null)
			{
				_instance = null;
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Update()
		{
			if (!gameover)
			{
				gameTime += Time.deltaTime;
			}
		}

		public void GameReady(float intvl)
		{
			if (gameover)
			{
				gameReady = true;
				Invoke("GameStart", intvl);
			}
		}

		public void GameStart()
		{
			gameover = false;
			gameTime = 0f;
			TargetManager.Instance.Init();
			SoundManager.PlaySound(Define.SoundType.GameStart, state: true);
		}

		public void GameOver()
		{
			gameover = true;
			gameReady = false;
			StartCoroutine("DelayEndingSound");
		}

		private IEnumerator DelayEndingSound()
		{
			yield return new WaitForSeconds(1f);
			SoundManager.PlaySound(Define.SoundType.GameOver, state: true);
		}
	}
	public class Glove : MonoBehaviour
	{
		[Header("Properties")]
		[SerializeField]
		private Define.HandDirection handDir;

		[SerializeField]
		private Transform ctrlrTF;

		[SerializeField]
		private LayerMask targetLayer;

		[SerializeField]
		private float impulse;

		[Header("Vibration Anim")]
		[SerializeField]
		private float shockCorrection;

		[SerializeField]
		private AnimationCurve shockCurve;

		[Header("Swing")]
		[SerializeField]
		private float velocityStandardValue;

		[SerializeField]
		private float swingSoundIntvl;

		private UnityEngine.XR.Interaction.Toolkit.XRController xrCtrlr;

		private Transform myTF;

		private Rigidbody myRB;

		private CtrlrCollider ctrlrCollider;

		private bool isSwingSoundPlaying;

		private Vector3 distanceFromCtrlr;

		private Vector3 currentVelocity;

		private List<Vector3> previousVelocitys;

		private Define.GloveState _state;

		public Vector3 previousMaxVelocity
		{
			get
			{
				Vector3 result = Vector3.zero;
				for (int i = 0; i < previousVelocitys.Count; i++)
				{
					if (result.sqrMagnitude < previousVelocitys[i].sqrMagnitude)
					{
						result = previousVelocitys[i];
					}
				}
				return result;
			}
		}

		public Define.GloveState state
		{
			get
			{
				return _state;
			}
			set
			{
				_state = value;
				switch (_state)
				{
				case Define.GloveState.Idle:
					myRB.isKinematic = false;
					myRB.detectCollisions = true;
					myRB.velocity = Vector3.zero;
					break;
				case Define.GloveState.Swing:
					myRB.isKinematic = false;
					myRB.detectCollisions = true;
					if (!isSwingSoundPlaying)
					{
						StartCoroutine(Easy_SwingSound(swingSoundIntvl));
						SoundManager.PlaySound(Define.SoundType.GloveSwing, state: true);
					}
					break;
				case Define.GloveState.Attach:
					myRB.isKinematic = true;
					break;
				case Define.GloveState.Returning:
					myRB.isKinematic = false;
					myRB.detectCollisions = false;
					StopCoroutine("SetImpulseVibe");
					break;
				}
			}
		}

		private void Awake()
		{
			xrCtrlr = ctrlrTF.GetComponentInParent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			myTF = GetComponent<Transform>();
			myRB = GetComponent<Rigidbody>();
			ctrlrCollider = ctrlrTF.GetComponentInParent<CtrlrCollider>();
			myTF.position = ctrlrTF.position;
			isSwingSoundPlaying = false;
			previousVelocitys = new List<Vector3>();
			state = Define.GloveState.Idle;
		}

		private void FixedUpdate()
		{
			AddPreviousVelocity();
			switch (state)
			{
			case Define.GloveState.Idle:
				myTF.rotation = ctrlrTF.rotation;
				myRB.velocity = currentVelocity;
				if (!isSwingSoundPlaying && myRB.velocity.sqrMagnitude > 9f)
				{
					state = Define.GloveState.Swing;
				}
				break;
			case Define.GloveState.Swing:
				myTF.rotation = ctrlrTF.rotation;
				myRB.velocity = currentVelocity;
				if (currentVelocity.sqrMagnitude < 0.040000003f)
				{
					state = Define.GloveState.Idle;
				}
				break;
			case Define.GloveState.Attach:
				if (!ctrlrCollider.isCollision.CurrentData)
				{
					state = Define.GloveState.Returning;
				}
				break;
			case Define.GloveState.Returning:
				if (distanceFromCtrlr.magnitude <= 0.1f)
				{
					state = Define.GloveState.Idle;
				}
				myTF.rotation = ctrlrTF.rotation;
				myRB.velocity = currentVelocity * 0.25f;
				break;
			}
		}

		private void AddPreviousVelocity()
		{
			distanceFromCtrlr = ctrlrTF.position - myTF.position;
			currentVelocity = distanceFromCtrlr / Time.fixedDeltaTime;
			if (previousVelocitys.Count >= 3)
			{
				previousVelocitys.RemoveAt(0);
			}
			previousVelocitys.Add(currentVelocity);
		}

		private void HitStrongEvent(ref SandBag sandBag, Vector2 uv, Vector3 contactPnt)
		{
			Vector3 position = sandBag.myCenter.position;
			position.y = myTF.position.y;
			Vector3 vector = position - contactPnt;
			sandBag.AddForce(vector.normalized * impulse, contactPnt);
			sandBag.SetHitImg(uv, 1f);
			StartCoroutine(SetImpulseVibe());
			SetHapticImpulse(Mathf.Clamp01(1f * PublicGameUIManager.gameSetting.GetHapticValue()), 0.2f);
			if (ctrlrCollider.isCollision.CurrentData)
			{
				state = Define.GloveState.Attach;
			}
			else
			{
				state = Define.GloveState.Idle;
			}
			SoundManager.PlaySound(Define.SoundType.GlovePunchStrong, state: true);
		}

		private void HitWeakEvent(ref SandBag sandBag, Vector2 uv)
		{
			sandBag.SetHitImg(uv, myRB.velocity.magnitude / velocityStandardValue);
			SetHapticImpulse(Mathf.Clamp01(0.5f * PublicGameUIManager.gameSetting.GetHapticValue()), 0.2f);
			SoundManager.PlaySound(Define.SoundType.GlovePunchWeak, state: true);
		}

		private void OnCollisionEnter(Collision collision)
		{
			if ((!state.Equals(Define.GloveState.Idle) && !state.Equals(Define.GloveState.Swing)) || !collision.gameObject.CompareTag("SandBag"))
			{
				return;
			}
			SandBag sandBag = collision.gameObject.GetComponentInParent<SandBag>();
			Vector3 from = distanceFromCtrlr;
			Vector3 to = sandBag.myCenter.position - myTF.position;
			float num = Vector3.SignedAngle(from, to, Vector3.forward);
			if (!(num > 100f) && !(num < -100f))
			{
				Vector3 position = sandBag.myCenter.position;
				position.y = myTF.position.y;
				Vector3 contactPnt = Vector3.zero;
				Vector2 uv = Vector3.zero;
				if (Physics.Raycast(new Ray(myTF.position, position - myTF.position), out var hitInfo, 10f, targetLayer))
				{
					uv = hitInfo.textureCoord;
					contactPnt = hitInfo.point;
				}
				if (myRB.velocity.sqrMagnitude >= velocityStandardValue * velocityStandardValue)
				{
					HitStrongEvent(ref sandBag, uv, contactPnt);
				}
				else
				{
					HitWeakEvent(ref sandBag, uv);
				}
				if (TargetManager.Instance.isTargetExist)
				{
					TargetManager.Instance.curTarget.CheckHitting(handDir, previousMaxVelocity, myTF.position);
				}
			}
		}

		private IEnumerator SetImpulseVibe()
		{
			float time = 0f;
			Vector3 origin = myTF.position;
			WaitForFixedUpdate wait = new WaitForFixedUpdate();
			while (time <= shockCurve.keys[shockCurve.length - 1].time)
			{
				if (!ctrlrCollider.isCollision.CurrentData)
				{
					state = Define.GloveState.Returning;
					break;
				}
				time += Time.deltaTime;
				Vector3 vector = new Vector3(UnityEngine.Random.Range(0, 2), 0f, UnityEngine.Random.Range(0, 2)).normalized * shockCurve.Evaluate(time) * shockCorrection;
				myTF.position = origin + vector;
				yield return wait;
			}
		}

		private IEnumerator Easy_SwingSound(float runTime)
		{
			isSwingSoundPlaying = true;
			yield return new WaitForSeconds(runTime);
			isSwingSoundPlaying = false;
		}

		private void SetHapticImpulse(float amp, float duration)
		{
			if (xrCtrlr.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				xrCtrlr.inputDevice.SendHapticImpulse(0u, amp, duration);
			}
		}
	}
	public class HowToPlay : MonoBehaviour
	{
		private CanvasGroup helper;

		private bool isSet;

		private void Awake()
		{
			helper = GetComponent<CanvasGroup>();
			isSet = false;
		}

		private void Start()
		{
			StartCoroutine(CheckGameStart());
		}

		private void OnDestroy()
		{
			StopCoroutine(CheckGameStart());
		}

		private IEnumerator CheckGameStart()
		{
			while (isSet || !(GameManager.Instance != null) || !GameManager.Instance.gameReady)
			{
				yield return null;
			}
			isSet = true;
			StartCoroutine(SetWindow(0f, 0.5f));
		}

		private IEnumerator SetWindow(float targetAlpha, float runTime)
		{
			float time = 0f;
			float originAlpha = helper.alpha;
			while (time < runTime)
			{
				helper.alpha = Mathf.Lerp(originAlpha, targetAlpha, time / runTime);
				time += Time.deltaTime;
				yield return null;
			}
			helper.alpha = targetAlpha;
		}
	}
	public class LocalizationCtrl : MonoBehaviour
	{
		public Text howToPlay;

		public Renderer renderer_heavybag;

		private Material mat_heavybag;

		public Material mat_perfect;

		public Material mat_great;

		public Material mat_good;

		public Image[] images_combo;

		private void Start()
		{
			mat_heavybag = renderer_heavybag.sharedMaterials[0];
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			LanguageState languageState = PublicGameUIManager.gameSetting.GetLanguageState();
			if ((uint)(languageState - 10) <= 1u)
			{
				howToPlay.text = "如何操作";
				mat_heavybag.SetTexture("_Texture", Resources.Load<Texture2D>("Boxing/Texture/HeavyBag_chinese"));
				mat_perfect.SetTexture("_MainTex", Resources.Load<Texture2D>("Boxing/Effect/Perfect_chinese"));
				mat_great.SetTexture("_MainTex", Resources.Load<Texture2D>("Boxing/Effect/Great_schinese"));
				mat_good.SetTexture("_MainTex", Resources.Load<Texture2D>("Boxing/Effect/Good_chinese"));
				Sprite sprite = Resources.LoadAll<Sprite>("Boxing/Effect/Combo00_chinese")[11];
				for (int i = 0; i < images_combo.Length; i++)
				{
					images_combo[i].sprite = sprite;
				}
			}
			else
			{
				howToPlay.text = "How To Play";
				mat_heavybag.SetTexture("_Texture", Resources.Load<Texture2D>("Boxing/Texture/HeavyBag_english"));
				mat_perfect.SetTexture("_MainTex", Resources.Load<Texture2D>("Boxing/Effect/Perfect_english"));
				mat_great.SetTexture("_MainTex", Resources.Load<Texture2D>("Boxing/Effect/Great_english"));
				mat_good.SetTexture("_MainTex", Resources.Load<Texture2D>("Boxing/Effect/Good_english"));
				Sprite sprite2 = Resources.LoadAll<Sprite>("Boxing/Effect/Combo00_english")[10];
				for (int j = 0; j < images_combo.Length; j++)
				{
					images_combo[j].sprite = sprite2;
				}
			}
		}
	}
	public class SandBag : MonoBehaviour
	{
		public Transform myCenter;

		[Header("Properties")]
		[SerializeField]
		private Transform myTF;

		[SerializeField]
		private Rigidbody myRB;

		[SerializeField]
		private Renderer myRenderer;

		[Header("Vibration Anim")]
		[SerializeField]
		private float shockCorrection;

		[SerializeField]
		private AnimationCurve shockCurve;

		[Header("Hit Image Fade Anim")]
		[SerializeField]
		private float fadeInit;

		[SerializeField]
		private float fadeSpeed;

		private Vector3 offSet;

		private Material myMaterial;

		private float tilingX;

		private float tilingY;

		private bool isHitImgSetting;

		private bool isVibe;

		private void Awake()
		{
			offSet = Vector3.zero;
			myMaterial = myRenderer.material;
			myMaterial.SetFloat("_Delta", 0f);
			tilingX = myMaterial.GetVector("_Tiling").x;
			tilingY = myMaterial.GetVector("_Tiling").y;
			isHitImgSetting = false;
			isVibe = false;
			myRB.maxAngularVelocity = 0.6f;
		}

		private void Update()
		{
			if (!isVibe)
			{
				myTF.localPosition = Vector3.zero;
			}
			if (isHitImgSetting)
			{
				myMaterial.SetVector("_OffSet", offSet);
				float @float = myMaterial.GetFloat("_Delta");
				if (@float <= 0f)
				{
					isHitImgSetting = false;
					return;
				}
				@float -= Time.deltaTime * fadeSpeed;
				myMaterial.SetFloat("_Delta", @float);
			}
		}

		public void AddForce(Vector3 force, Vector3 pos)
		{
			float num = 10f * (1.4f - Mathf.Clamp(pos.y, 0.8f, 1.4f)) / 0.6f;
			myRB.AddForceAtPosition(force * num, pos, ForceMode.Impulse);
			myTF.localPosition = Vector3.zero;
			StopCoroutine("SetImpulseVibe");
			StartCoroutine("SetImpulseVibe");
		}

		public void SetHitImg(Vector2 pos, float power)
		{
			isHitImgSetting = true;
			offSet = default(Vector2);
			offSet.x = (0f - pos.x) * tilingX + 0.5f;
			offSet.y = (0f - pos.y) * tilingY + 0.5f;
			myMaterial.SetFloat("_Delta", fadeInit * power);
		}

		private IEnumerator SetImpulseVibe()
		{
			isVibe = true;
			float time = 0f;
			int keyIndex = 0;
			Vector3 origin = myTF.localPosition;
			Vector3 offSet = Vector3.zero;
			WaitForFixedUpdate wait = new WaitForFixedUpdate();
			while (time <= shockCurve.keys[shockCurve.length - 1].time)
			{
				time += Time.deltaTime;
				if (time >= shockCurve.keys[keyIndex].time)
				{
					if (shockCurve.keys[keyIndex].value.Equals(0f))
					{
						Vector3 vector = new Vector3(UnityEngine.Random.Range(0, 2), UnityEngine.Random.Range(0, 2), 0f);
						offSet = vector * shockCurve.Evaluate(time) * shockCorrection;
					}
					keyIndex++;
				}
				myTF.localPosition = origin + offSet;
				yield return wait;
			}
			isVibe = false;
		}
	}
	public class SandBagEffecter : MonoBehaviour
	{
		[Header("Life")]
		[SerializeField]
		private XXEffect[] effectLifeList;

		[Header("Die")]
		[SerializeField]
		private Transform effectDieTransform;

		[SerializeField]
		private DieEffectCtrl[] effectDiePerfectList;

		[SerializeField]
		private DieEffectCtrl[] effectDieGreatList;

		[SerializeField]
		private DieEffectCtrl[] effectDieGoodList;

		[Header("Combo")]
		[SerializeField]
		private ComboEffectCtrl[] effectComboList;

		[Header("Fail")]
		[SerializeField]
		private Transform effectFailTransform;

		[SerializeField]
		private GameObject[] effectFailList;

		[Header("Miss")]
		[SerializeField]
		private Transform effectMissTransform;

		[SerializeField]
		private GameObject[] effectMissLeftList;

		[SerializeField]
		private GameObject[] effectMissRightList;

		private Define.HandDirection previousDir;

		private int previousMissIdx;

		private void Awake()
		{
			previousMissIdx = -1;
		}

		public void SetLifeEffect(bool state)
		{
			if (state)
			{
				for (int i = 0; i < effectLifeList.Length; i++)
				{
					if (!effectLifeList[i].gameObject.activeSelf)
					{
						effectLifeList[i].SetEffect();
						break;
					}
				}
			}
			else
			{
				StartCoroutine("DisableLifeEffect");
			}
		}

		public void SetDieEffect(Define.HitType type, float height, float degree, bool state)
		{
			int i;
			switch (type)
			{
			case Define.HitType.Perfect:
				for (i = 0; i < effectDiePerfectList.Length; i++)
				{
					if (!effectDiePerfectList[i].gameObject.activeSelf)
					{
						effectDiePerfectList[i].gameObject.SetActive(value: true);
						effectDiePerfectList[i].SetExplosionActive(state);
						Vector3 localPosition2 = effectDiePerfectList[i].gameObject.transform.localPosition;
						localPosition2.z = height;
						effectDiePerfectList[i].gameObject.transform.localPosition = localPosition2;
						break;
					}
				}
				break;
			case Define.HitType.Great:
				for (i = 0; i < effectDieGreatList.Length; i++)
				{
					if (!effectDieGreatList[i].gameObject.activeSelf)
					{
						effectDieGreatList[i].gameObject.SetActive(value: true);
						effectDieGreatList[i].SetExplosionActive(state);
						Vector3 localPosition3 = effectDieGreatList[i].gameObject.transform.localPosition;
						localPosition3.z = height;
						effectDieGreatList[i].gameObject.transform.localPosition = localPosition3;
						break;
					}
				}
				break;
			default:
				for (i = 0; i < effectDieGoodList.Length; i++)
				{
					if (!effectDieGoodList[i].gameObject.activeSelf)
					{
						effectDieGoodList[i].gameObject.SetActive(value: true);
						effectDieGoodList[i].SetExplosionActive(state);
						Vector3 localPosition = effectDieGoodList[i].gameObject.transform.localPosition;
						localPosition.z = height;
						effectDieGoodList[i].gameObject.transform.localPosition = localPosition;
						break;
					}
				}
				break;
			}
			Vector3 euler = new Vector3(0f, 0f, degree);
			effectDieTransform.localRotation = Quaternion.Euler(euler);
			StartCoroutine(DisableDieEffect(type, i));
		}

		public void SetComboEffect()
		{
			for (int i = 0; i < effectComboList.Length; i++)
			{
				if (!effectComboList[i].gameObject.activeSelf)
				{
					effectComboList[i].gameObject.SetActive(value: true);
					effectComboList[i].SetCombo(TargetManager.Instance.gameScore.combo);
					StartCoroutine(DisableComboEffect(i));
					break;
				}
			}
		}

		public void SetFailEffect(float height, float degree)
		{
			for (int i = 0; i < effectFailList.Length; i++)
			{
				if (!effectFailList[i].gameObject.activeSelf)
				{
					effectFailList[i].gameObject.SetActive(value: true);
					Vector3 localPosition = effectFailList[i].gameObject.transform.localPosition;
					localPosition.z = height;
					effectFailList[i].gameObject.transform.localPosition = localPosition;
					Vector3 euler = new Vector3(0f, 0f, degree);
					effectFailTransform.localRotation = Quaternion.Euler(euler);
					break;
				}
			}
		}

		public void SetMissEffect(Define.HandDirection dir, float height, float degree)
		{
			previousDir = dir;
			switch (dir)
			{
			case Define.HandDirection.Left:
			{
				for (int j = 0; j < effectMissLeftList.Length; j++)
				{
					if (!effectMissLeftList[j].gameObject.activeSelf)
					{
						effectMissLeftList[j].gameObject.SetActive(value: true);
						Vector3 localPosition2 = effectMissLeftList[j].gameObject.transform.localPosition;
						localPosition2.z = height;
						effectMissLeftList[j].gameObject.transform.localPosition = localPosition2;
						previousMissIdx = j;
						break;
					}
				}
				break;
			}
			case Define.HandDirection.Right:
			{
				for (int i = 0; i < effectMissRightList.Length; i++)
				{
					if (!effectMissRightList[i].gameObject.activeSelf)
					{
						effectMissRightList[i].gameObject.SetActive(value: true);
						Vector3 localPosition = effectMissRightList[i].gameObject.transform.localPosition;
						localPosition.z = height;
						effectMissRightList[i].gameObject.transform.localPosition = localPosition;
						previousMissIdx = i;
						break;
					}
				}
				break;
			}
			}
			Vector3 euler = new Vector3(0f, 0f, degree);
			effectMissTransform.localRotation = Quaternion.Euler(euler);
		}

		public void DisableMissEffect()
		{
			if (previousMissIdx.Equals(-1))
			{
				return;
			}
			switch (previousDir)
			{
			case Define.HandDirection.Left:
				if (!effectMissLeftList[previousMissIdx].gameObject.activeSelf)
				{
					previousMissIdx = -1;
					return;
				}
				effectMissLeftList[previousMissIdx].gameObject.SetActive(value: false);
				break;
			case Define.HandDirection.Right:
				if (!effectMissRightList[previousMissIdx].gameObject.activeSelf)
				{
					previousMissIdx = -1;
					return;
				}
				effectMissRightList[previousMissIdx].gameObject.SetActive(value: false);
				break;
			}
			previousMissIdx = -1;
		}

		private IEnumerator DisableLifeEffect()
		{
			yield return new WaitForSeconds(2f);
			for (int i = 0; i < effectLifeList.Length; i++)
			{
				effectLifeList[i].gameObject.SetActive(value: false);
			}
		}

		private IEnumerator DisableDieEffect(Define.HitType type, int idx)
		{
			yield return new WaitForSeconds(0.7f);
			switch (type)
			{
			case Define.HitType.Perfect:
				effectDiePerfectList[idx].gameObject.SetActive(value: false);
				break;
			case Define.HitType.Great:
				effectDieGreatList[idx].gameObject.SetActive(value: false);
				break;
			case Define.HitType.Good:
				effectDieGoodList[idx].gameObject.SetActive(value: false);
				break;
			}
		}

		private IEnumerator DisableComboEffect(int idx)
		{
			yield return new WaitForSeconds(1f);
			effectComboList[idx].gameObject.SetActive(value: false);
		}
	}
	public class SoundManager : MonoBehaviour
	{
		[Serializable]
		private class AudioDatum
		{
			public Define.SoundType type;

			public AudioClip[] clip;

			[Range(0f, 1f)]
			public float volume;

			public bool isLoop;
		}

		private static SoundManager _instance;

		[Space(5f)]
		[Header("Sources")]
		[SerializeField]
		private AudioSource BGMSource;

		[SerializeField]
		private AudioSource gamePlaySource;

		[SerializeField]
		private AudioSource glovePunchSource;

		[SerializeField]
		private AudioSource gloveSwingSource;

		[SerializeField]
		private AudioSource countSource;

		[SerializeField]
		private AudioSource lifeSource;

		[SerializeField]
		private AudioSource targetSource;

		[SerializeField]
		private AudioSource buttonSource;

		[Space(5f)]
		[Header("Audio Data")]
		[SerializeField]
		private AudioDatum BGMDatum;

		[SerializeField]
		private AudioDatum gameStartDatum;

		[SerializeField]
		private AudioDatum gameOverDatum;

		[SerializeField]
		private AudioDatum gloveHitStrongDatum;

		[SerializeField]
		private AudioDatum gloveHitWeakDatum;

		[SerializeField]
		private AudioDatum gloveSwingDatum;

		[SerializeField]
		private AudioDatum countDatum;

		[SerializeField]
		private AudioDatum lifeLossDatum;

		[SerializeField]
		private AudioDatum targetHitDatum;

		[SerializeField]
		private AudioDatum buttonDatum;

		private Dictionary<Define.SoundType, AudioDatum> AudioDatumDic = new Dictionary<Define.SoundType, AudioDatum>();

		private float CachedBGMVolume = float.MinValue;

		private float CachedFXVolume = float.MinValue;

		private int countNum;

		public static SoundManager Instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = UnityEngine.Object.FindObjectOfType<SoundManager>();
				}
				return _instance;
			}
		}

		private float SavedBGMVolume
		{
			get
			{
				return DataManager.GetFloat("BGMVolume", 1f);
			}
			set
			{
				DataManager.SetFloat("BGMVolume", value);
			}
		}

		private float BGMVolume
		{
			get
			{
				if (CachedBGMVolume == float.MinValue)
				{
					CachedBGMVolume = SavedBGMVolume;
				}
				return CachedBGMVolume;
			}
			set
			{
				if (SavedBGMVolume != value)
				{
					SavedBGMVolume = value;
					CachedBGMVolume = value;
				}
			}
		}

		private float SavedFXVolume
		{
			get
			{
				return DataManager.GetFloat("FXVolume", 1f);
			}
			set
			{
				DataManager.SetFloat("FXVolume", value);
			}
		}

		private float FXVolume
		{
			get
			{
				if (CachedFXVolume == float.MinValue)
				{
					CachedFXVolume = SavedFXVolume;
				}
				return CachedFXVolume;
			}
			set
			{
				if (SavedFXVolume != value)
				{
					SavedFXVolume = value;
					CachedFXVolume = value;
				}
			}
		}

		public AudioSource GetBGMSource()
		{
			return BGMSource;
		}

		private void Awake()
		{
			AudioInitialize();
		}

		private void OnDestroy()
		{
			if (_instance != null)
			{
				_instance = null;
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void AudioInitialize()
		{
			AudioDatumDic.Add(BGMDatum.type, BGMDatum);
			AudioDatumDic.Add(gameStartDatum.type, gameStartDatum);
			AudioDatumDic.Add(gameOverDatum.type, gameOverDatum);
			AudioDatumDic.Add(gloveHitStrongDatum.type, gloveHitStrongDatum);
			AudioDatumDic.Add(gloveHitWeakDatum.type, gloveHitWeakDatum);
			AudioDatumDic.Add(gloveSwingDatum.type, gloveSwingDatum);
			AudioDatumDic.Add(countDatum.type, countDatum);
			AudioDatumDic.Add(lifeLossDatum.type, lifeLossDatum);
			AudioDatumDic.Add(targetHitDatum.type, targetHitDatum);
			AudioDatumDic.Add(buttonDatum.type, buttonDatum);
		}

		private void PlayOrStop(Define.SoundType type, bool state)
		{
			switch (type)
			{
			case Define.SoundType.BGM:
				PlayOrStopSource(type, state, ref BGMSource);
				break;
			case Define.SoundType.GameStart:
				PlayOrStopSource(type, state, ref gamePlaySource);
				break;
			case Define.SoundType.GameOver:
				PlayOrStopSource(type, state, ref gamePlaySource);
				break;
			case Define.SoundType.GlovePunchStrong:
				PlayOrStopSource(type, state, ref glovePunchSource);
				break;
			case Define.SoundType.GlovePunchWeak:
				PlayOrStopSource(type, state, ref glovePunchSource);
				break;
			case Define.SoundType.GloveSwing:
				PlayOrStopSource(type, state, ref gloveSwingSource);
				break;
			case Define.SoundType.Count:
				PlayOrStopSource(type, state, countNum++, ref countSource);
				break;
			case Define.SoundType.Life:
				PlayOrStopSource(type, state, ref lifeSource);
				break;
			case Define.SoundType.Target:
				PlayOrStopSource(Define.SoundType.GlovePunchStrong, state: true, ref glovePunchSource);
				PlayOrStopSource(type, state, ref targetSource);
				break;
			case Define.SoundType.Button:
				PlayOrStopSource(type, state, ref buttonSource);
				break;
			}
		}

		private void PlayOrStopSource(Define.SoundType type, bool state, ref AudioSource source)
		{
			if (state)
			{
				source.Stop();
				source.clip = AudioDatumDic[type].clip[UnityEngine.Random.Range(0, AudioDatumDic[type].clip.Length)];
				if (type == Define.SoundType.BGM)
				{
					source.volume = AudioDatumDic[type].volume * BGMVolume;
				}
				else
				{
					source.volume = AudioDatumDic[type].volume * FXVolume;
				}
				source.time = 0f;
				source.loop = AudioDatumDic[type].isLoop;
				source.Play();
			}
			else
			{
				source.Stop();
			}
		}

		private void PlayOrStopSource(Define.SoundType type, bool state, int idx, ref AudioSource source)
		{
			if (state)
			{
				source.Stop();
				source.clip = AudioDatumDic[type].clip[idx];
				if (type == Define.SoundType.BGM)
				{
					source.volume = AudioDatumDic[type].volume * BGMVolume;
				}
				else
				{
					source.volume = AudioDatumDic[type].volume * FXVolume;
				}
				source.time = 0f;
				source.loop = AudioDatumDic[type].isLoop;
				source.Play();
			}
			else
			{
				source.Stop();
			}
		}

		public static void PlaySound(Define.SoundType type, bool state)
		{
			if (!(Instance == null))
			{
				Instance.PlayOrStop(type, state);
			}
		}
	}
	public class SpectrumShaderListener : MonoBehaviour, IInitializableListener
	{
		[SerializeField]
		private List<Material> materials;

		[SerializeField]
		private Material EnvironmentMaterial;

		[SerializeField]
		private float minOpacity;

		[SerializeField]
		private float defaultScale;

		[SerializeField]
		private float ScaleFactor;

		[SerializeField]
		private AnimationCurve curve;

		[Header("Main Event")]
		[SerializeField]
		private float RunStartOffset;

		private float RunRateValue;

		[Header("Additional Event")]
		[SerializeField]
		private float AdditionalRunRate = 1f;

		[SerializeField]
		private float AdditionalRunStartOffset;

		private float AdditionalRunRateValue;

		[Header("Test view")]
		[SerializeField]
		private float maxValue;

		private const string MainColorProperty = "_MainColor";

		private const string VisualizerColorProperty = "_VisualizerColor";

		private const string OpacityProperty = "_Opacity";

		private const string OffsetProperty = "_Offset";

		private float RunRate => TargetManager.EnvironmentRunRate;

		private void Awake()
		{
			TargetManager.OnSpectrum += Loader_OnSpectrum;
			TargetManager.OnSpectrum += Loader_OnSpectrum_EnvironmentColor;
			TargetManager.onInitialized += Initialize;
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
			RunRateValue = RunStartOffset;
			AdditionalRunRateValue = AdditionalRunStartOffset;
		}

		public void Initialize()
		{
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
			RunRateValue = RunStartOffset;
			AdditionalRunRateValue = AdditionalRunStartOffset;
		}

		private void Loader_OnSpectrum_EnvironmentColor(float runtime, float[] obj)
		{
			AdditionalRunRateValue += AdditionalRunRate;
			if (AdditionalRunRateValue < 1f)
			{
				return;
			}
			AdditionalRunRateValue = 0f;
			int num = UnityEngine.Random.Range(0, 30) * 12;
			Color value = ColorExtension.ConvertHsvToRgb(num % 360, 1.0, 1.0, 1f);
			Color value2 = ColorExtension.ConvertHsvToRgb((num + 150) % 360, 1.0, 1.0, 1f);
			foreach (Material material in materials)
			{
				material.SetColor("_MainColor", value);
				material.SetColor("_VisualizerColor", value2);
			}
			EnvironmentMaterial.SetColor("_EmissionColor", value);
		}

		private void Loader_OnSpectrum(float runtime, float[] obj)
		{
			RunRateValue += RunRate;
			if (RunRateValue < 1f)
			{
				return;
			}
			RunRateValue = 0f;
			List<float> MaxScale = new List<float>();
			float beatMaxScale = 0f;
			int num = obj.Length;
			int count = materials.Count;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (i * count / num != (i + 1) * count / num)
				{
					float t = 1f - ((float)(i + 1) - (float)num / (float)count * (float)num2);
					float num3 = 0f;
					num3 = ((obj.Length != i + 1) ? Mathf.Lerp(obj[i], obj[i + 1], t) : obj[i]);
					float value = num3;
					(float, float) input = (0f, 0.023f);
					(float, float) output = (0f, 1f);
					num3 = Jisu.Utils.VectorExtension.Remap(value, in input, in output);
					MaxScale.Add(ScaleFactor * num3 + defaultScale);
					maxValue = Mathf.Max(num3, maxValue);
					beatMaxScale = Mathf.Max(num3, beatMaxScale);
					materials[num2].SetFloat("_Opacity", ScaleFactor * num3 + defaultScale + minOpacity);
					materials[num2].SetFloat("_Offset", ScaleFactor * num3 + defaultScale);
					num2++;
				}
			}
			StartCoroutine(Run(runtime, OnUpdate));
			void OnUpdate(float _t)
			{
				int count2 = materials.Count;
				for (int j = 0; j < count2; j++)
				{
					materials[j].SetFloat("_Opacity", Mathf.Clamp01(Mathf.Lerp(beatMaxScale, defaultScale, _t) + minOpacity));
					materials[j].SetFloat("_Offset", Mathf.Clamp01(Mathf.Lerp(MaxScale[j], defaultScale, _t)));
				}
			}
			static IEnumerator Run(float _runtime, Action<float> _onUpdate)
			{
				float _t2 = 0f;
				while (_t2 < _runtime)
				{
					_onUpdate?.Invoke(_t2 / _runtime);
					_t2 += Time.deltaTime;
					yield return null;
				}
				_onUpdate?.Invoke(1f);
			}
		}

		private void OnDestroy()
		{
			TargetManager.onInitialized -= Initialize;
			TargetManager.OnSpectrum -= Loader_OnSpectrum_EnvironmentColor;
			TargetManager.OnSpectrum -= Loader_OnSpectrum;
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
		}
	}
	public class StartTarget : MonoBehaviour
	{
		[Header("Effects")]
		[SerializeField]
		private GameObject targetEffect;

		[SerializeField]
		private GameObject hitEffect;

		[Header("Fade Animation")]
		[SerializeField]
		private GameObject FadeEffect;

		[SerializeField]
		private float fadeTime;

		[SerializeField]
		private float fadeSpeed;

		private Material[] materials;

		private bool isStarted;

		private void Awake()
		{
			materials = FadeEffect.GetComponent<Renderer>().materials;
		}

		private void OnEnable()
		{
			targetEffect.gameObject.SetActive(value: true);
			isStarted = false;
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!isStarted && other.gameObject.CompareTag("Glove") && GameManager.Instance.gameover)
			{
				isStarted = true;
				hitEffect.gameObject.SetActive(value: true);
				StartCoroutine("FadePlayEffect");
				GameManager.Instance.GameReady(3.3f);
				SoundManager.PlaySound(Define.SoundType.Button, state: true);
			}
		}

		private IEnumerator FadePlayEffect()
		{
			float time = 0f;
			targetEffect.gameObject.SetActive(value: false);
			FadeEffect.gameObject.SetActive(value: true);
			Transform myTF = FadeEffect.GetComponent<Transform>();
			Color originAlpha = materials[0].color;
			while (time <= fadeTime)
			{
				time += Time.deltaTime;
				Vector3 localScale = myTF.localScale;
				localScale.x = Mathf.Lerp(localScale.x, 2f, Time.deltaTime * 1.5f);
				localScale.y = Mathf.Lerp(localScale.y, 2f, Time.deltaTime * 1.5f);
				myTF.localScale = localScale;
				for (int i = 0; i < materials.Length; i++)
				{
					Color color = materials[i].color;
					color.a = Mathf.Lerp(color.a, 0f, Time.deltaTime * fadeSpeed);
					materials[i].color = color;
				}
				yield return null;
			}
			myTF.localScale = new Vector3(1.2f, 1.2f, 1.2f);
			for (int j = 0; j < materials.Length; j++)
			{
				materials[j].color = originAlpha;
			}
			FadeEffect.gameObject.SetActive(value: false);
			hitEffect.gameObject.SetActive(value: false);
			base.gameObject.SetActive(value: false);
		}
	}
	public class Target : MonoBehaviour
	{
		public Define.HandDirection handDir;

		[Header("Properties")]
		[SerializeField]
		private Transform myTF;

		[SerializeField]
		public Transform CenterPos;

		[SerializeField]
		private GameObject targetEffect;

		[SerializeField]
		private GameObject timeEffect;

		[Header("Ignoring Conditions")]
		[SerializeField]
		private float ignoredVelocity;

		[SerializeField]
		private float ignoredDistance;

		[Header("Judgment Conditions")]
		[SerializeField]
		private float angleLimit;

		[SerializeField]
		private float minVelocityValue;

		[SerializeField]
		private float maxVelocityValue;

		[SerializeField]
		private float minDistanceValue;

		[SerializeField]
		private float maxDistanceValue;

		[SerializeField]
		private float distanceScale;

		[Header("Score Magnifications")]
		[SerializeField]
		private float powerMagnification;

		[SerializeField]
		private float accuracyMagnification;

		private ParticleSystem targetParticle;

		private ParticleSystem.MainModule targetParticleMain;

		private ParticleSystem timeParticle;

		private ParticleSystem.MainModule timeParticleMain;

		private float duration;

		private bool isCollision;

		private void Awake()
		{
			targetParticle = targetEffect.GetComponent<ParticleSystem>();
			targetParticleMain = targetParticle.main;
			if (handDir.Equals(Define.HandDirection.Both))
			{
				timeParticle = timeEffect.GetComponent<ParticleSystem>();
				timeParticleMain = timeParticle.main;
			}
			duration = 0f;
			isCollision = false;
			base.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			StartCoroutine("OnUpdate");
		}

		private void OnDisable()
		{
			StopCoroutine("SetTimer");
			StopCoroutine("OnUpdate");
		}

		private IEnumerator OnUpdate()
		{
			WaitForSeconds wait = new WaitForSeconds(0.1f);
			while (true)
			{
				if (GameManager.Instance.gameover)
				{
					Die();
				}
				yield return wait;
			}
		}

		public void SetTarget(float localHeight, float degree, float time)
		{
			base.gameObject.SetActive(value: true);
			Vector3 localPosition = myTF.localPosition;
			localPosition.y = localHeight;
			myTF.localPosition = localPosition;
			Vector3 euler = new Vector3(0f, degree, 0f);
			myTF.localRotation = Quaternion.Euler(euler);
			duration = time;
			StartCoroutine(SetTimer());
			targetParticle.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
			targetParticleMain.duration = duration;
			targetParticleMain.startLifetime = duration;
			targetParticle.Play();
			if (handDir.Equals(Define.HandDirection.Both))
			{
				timeParticle.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
				timeParticleMain.duration = duration;
				timeParticleMain.startLifetime = duration;
				timeParticle.Play();
			}
		}

		private IEnumerator SetTimer()
		{
			bool miss = false;
			float deltaTime = 0f;
			while (deltaTime <= duration)
			{
				deltaTime += Time.deltaTime;
				if (deltaTime + 0.18f >= duration && !miss)
				{
					miss = true;
					TargetManager.Instance.effect.SetMissEffect(handDir, myTF.localPosition.y, myTF.localRotation.eulerAngles.y);
				}
				yield return new WaitForFixedUpdate();
			}
			if (handDir.Equals(Define.HandDirection.Both))
			{
				Die();
			}
			else
			{
				MissEvent(state: true);
			}
		}

		private void Die()
		{
			duration = 0f;
			isCollision = false;
			Vector3 euler = new Vector3(0f, 0f, 0f);
			myTF.localRotation = Quaternion.Euler(euler);
			base.gameObject.SetActive(value: false);
			TargetManager.Instance.SetTargetExist(state: false);
		}

		private float CalcScore(Vector3 velocity, Vector3 targetCenter)
		{
			float num = ((!(velocity.sqrMagnitude >= maxVelocityValue * maxVelocityValue)) ? (powerMagnification * (velocity.magnitude - minVelocityValue) / (maxVelocityValue - minVelocityValue)) : powerMagnification);
			float num2 = minDistanceValue * distanceScale;
			float num3 = maxDistanceValue * distanceScale;
			float num4 = Vector3.Distance(targetCenter, CenterPos.position);
			float num5 = ((num4 <= num2) ? accuracyMagnification : ((!(num4 >= num3)) ? (accuracyMagnification * (num3 - num4) / (num3 - num2)) : 0f));
			return num + num5;
		}

		public void MissEvent(bool state)
		{
			if (!state)
			{
				TargetManager.Instance.effect.SetFailEffect(myTF.localPosition.y, myTF.localRotation.eulerAngles.y);
			}
			TargetManager.Instance.LoseLife();
			Die();
		}

		private void HitEvent(Vector3 velocity, Vector3 targetCenter)
		{
			if (!isCollision || handDir.Equals(Define.HandDirection.Both))
			{
				isCollision = true;
				float num = CalcScore(velocity, targetCenter);
				Define.HitType type = ((!(num >= 65f)) ? ((num >= 30f) ? Define.HitType.Great : Define.HitType.Good) : Define.HitType.Perfect);
				TargetManager.Instance.HitBPMEvent();
				TargetManager.Instance.gameScore.AddScore(num, type);
				TargetManager.Instance.effect.DisableMissEffect();
				TargetManager.Instance.effect.SetComboEffect();
				SoundManager.PlaySound(Define.SoundType.Target, state: true);
				if (handDir.Equals(Define.HandDirection.Both))
				{
					TargetManager.Instance.effect.SetDieEffect(type, myTF.localPosition.y, myTF.localRotation.eulerAngles.y, state: false);
					return;
				}
				TargetManager.Instance.SetNumOfTarget(1);
				TargetManager.Instance.effect.SetDieEffect(type, myTF.localPosition.y, myTF.localRotation.eulerAngles.y, state: true);
				Die();
			}
		}

		public void CheckHitting(Define.HandDirection hand, Vector3 velocity, Vector3 pos)
		{
			if ((CenterPos.position - pos).sqrMagnitude >= ignoredDistance * distanceScale * (ignoredDistance * distanceScale))
			{
				return;
			}
			if (!handDir.Equals(hand) && !handDir.Equals(Define.HandDirection.Both))
			{
				MissEvent(state: false);
			}
			else if (!(velocity.sqrMagnitude < ignoredVelocity * ignoredVelocity))
			{
				Vector3 from = CenterPos.position - pos;
				Vector3 forward = CenterPos.forward;
				float num = Vector3.SignedAngle(from, forward, Vector3.forward);
				if (!(num > angleLimit) && !(num < 0f - angleLimit) && (handDir.Equals(hand) || handDir.Equals(Define.HandDirection.Both)))
				{
					HitEvent(velocity, pos);
				}
			}
		}
	}
	[Serializable]
	public class Score
	{
		public float score;

		public int perfect;

		public int great;

		public int good;

		public int combo;

		public int maxCombo;

		public void AddScore(float _score, Define.HitType type)
		{
			combo++;
			score += _score * (float)Mathf.Clamp(combo, 1, 8);
			switch (type)
			{
			case Define.HitType.Perfect:
				perfect++;
				break;
			case Define.HitType.Great:
				great++;
				break;
			case Define.HitType.Good:
				good++;
				break;
			}
		}

		public void ResetCombo()
		{
			if (maxCombo < combo)
			{
				maxCombo = combo;
			}
			combo = 0;
		}

		public void Reset()
		{
			score = 0f;
			perfect = 0;
			great = 0;
			good = 0;
			combo = 0;
			maxCombo = 0;
		}
	}
	public class TargetManager : MonoBehaviour
	{
		private static TargetManager _instance;

		[Header("Targets")]
		[SerializeField]
		private Target[] targetList;

		[SerializeField]
		private StartTarget startTarget;

		[Header("Spawn Condition")]
		[SerializeField]
		private float[] middleHeight;

		[SerializeField]
		private float[] sideHeight;

		[SerializeField]
		private float spawnDegree;

		[Header("Durations")]
		[SerializeField]
		private float oneHandDuration;

		[SerializeField]
		private float bothHandsDuration;

		[SerializeField]
		private float durationCorrectionValue;

		[SerializeField]
		private float durationCorrectionTime;

		[SerializeField]
		private float durationCorrectionMaxValue;

		[SerializeField]
		private float BothTargetConditionValue;

		[Header("Play Condition")]
		[SerializeField]
		private int lifeMax;

		[SerializeField]
		private float failIntvlTime;

		private CoroutineWrapper RunRoutineWrapper;

		private bool isBothHandsTargetReady;

		private bool isFailed;

		private int BPM = 115;

		private float SongTime;

		private float[] SpectrumSampleData = new float[256];

		public static float EnvironmentRunRate = 1f;

		private int _lifeCount;

		private int _NumOfTarget;

		public static TargetManager Instance
		{
			get
			{
				if (_instance == null)
				{
					_instance = UnityEngine.Object.FindObjectOfType<TargetManager>();
				}
				return _instance;
			}
		}

		private AudioSource targetSource => SoundManager.Instance.GetBGMSource();

		public Score gameScore { get; private set; } = new Score();


		public SandBagEffecter effect { get; private set; }

		public Target curTarget { get; private set; }

		public bool isTargetExist { get; private set; }

		public int lifeCount
		{
			get
			{
				return _lifeCount;
			}
			private set
			{
				if (value < _lifeCount)
				{
					isFailed = true;
					effect.SetLifeEffect(state: true);
					gameScore.ResetCombo();
					SoundManager.PlaySound(Define.SoundType.Life, state: true);
				}
				_lifeCount = value;
				if (_lifeCount <= 0)
				{
					effect.SetLifeEffect(state: false);
					StartCoroutine("SetResultUI");
					GameManager.Instance.GameOver();
				}
			}
		}

		public int NumOfTarget
		{
			get
			{
				return _NumOfTarget;
			}
			private set
			{
				_NumOfTarget = value;
				if (((float)_NumOfTarget % BothTargetConditionValue).Equals(0f))
				{
					isBothHandsTargetReady = true;
				}
			}
		}

		public static event Action onInitialized;

		public static event Action<float> OnBeat;

		public static event Action OnHit;

		public static event Action<float, float[]> OnSpectrum;

		public void SetTargetExist(bool state)
		{
			isTargetExist = state;
		}

		public void SetNumOfTarget(int num)
		{
			NumOfTarget += num;
		}

		public void SetLife()
		{
			lifeCount = lifeMax;
		}

		public void LoseLife()
		{
			lifeCount--;
		}

		public void HitBPMEvent()
		{
			TargetManager.OnHit?.Invoke();
		}

		private void Awake()
		{
			RunRoutineWrapper = CoroutineWrapper.Generate(this);
			effect = GetComponent<SandBagEffecter>();
			NumOfTarget = 0;
			isTargetExist = false;
			isBothHandsTargetReady = false;
			isFailed = false;
			TargetManager.onInitialized?.Invoke();
		}

		private void OnDestroy()
		{
			if (_instance != null)
			{
				_instance = null;
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public void Init()
		{
			gameScore.Reset();
			isFailed = false;
			NumOfTarget = 0;
			isBothHandsTargetReady = false;
			SetLife();
			RunRoutineWrapper.Start(OnTargetUpdate());
		}

		private void Update()
		{
			BPMEvent();
		}

		private IEnumerator OnTargetUpdate()
		{
			WaitForSeconds failTime = new WaitForSeconds(failIntvlTime);
			SongTime = SoundManager.Instance.GetBGMSource().time;
			while (base.enabled)
			{
				if (GameManager.Instance.gameover || lifeCount < 0)
				{
					RunRoutineWrapper.Stop();
					break;
				}
				if (isFailed)
				{
					isFailed = false;
					yield return failTime;
				}
				if (!isTargetExist)
				{
					isTargetExist = true;
					if (isBothHandsTargetReady)
					{
						isBothHandsTargetReady = false;
						SetBothHandsTargetToPos();
					}
					else
					{
						SetOneHandTargetToPos();
					}
				}
				yield return null;
			}
		}

		private void BPMEvent()
		{
			float num = 60f / (float)BPM;
			if (Mathf.FloorToInt(SongTime / num) != Mathf.FloorToInt(targetSource.time / num))
			{
				targetSource.GetSpectrumData(SpectrumSampleData, 0, FFTWindow.Blackman);
				TargetManager.OnBeat?.Invoke(num);
				TargetManager.OnSpectrum?.Invoke(num, SpectrumSampleData);
			}
			SongTime = targetSource.time;
		}

		private void SetBothHandsTargetToPos()
		{
			float localHeight = UnityEngine.Random.Range(middleHeight[2], middleHeight[0]);
			float degree = 0f;
			float time = bothHandsDuration - Mathf.Min(durationCorrectionMaxValue, (float)NumOfTarget / durationCorrectionValue * durationCorrectionTime);
			targetList[2].SetTarget(localHeight, degree, time);
			curTarget = targetList[2];
		}

		private void SetOneHandTargetToPos()
		{
			int num;
			float localHeight;
			float degree;
			switch (UnityEngine.Random.Range(0, 3))
			{
			case 0:
				num = 0;
				localHeight = sideHeight[UnityEngine.Random.Range(0, sideHeight.Length)];
				degree = spawnDegree;
				break;
			case 2:
				num = 1;
				localHeight = sideHeight[UnityEngine.Random.Range(0, sideHeight.Length)];
				degree = 0f - spawnDegree;
				break;
			default:
				num = UnityEngine.Random.Range(0, 2);
				localHeight = middleHeight[UnityEngine.Random.Range(0, middleHeight.Length)];
				degree = 0f;
				break;
			}
			float time = oneHandDuration - Mathf.Min(durationCorrectionMaxValue, (float)NumOfTarget / durationCorrectionValue * durationCorrectionTime);
			targetList[num].SetTarget(localHeight, degree, time);
			curTarget = targetList[num];
		}

		private IEnumerator SetResultUI()
		{
			yield return new WaitForSeconds(2f);
			List<string> list = new List<string>
			{
				GameSettingCtrl.GetLocalizationText("0174"),
				gameScore.perfect.ToString(),
				GameSettingCtrl.GetLocalizationText("0175"),
				gameScore.great.ToString(),
				GameSettingCtrl.GetLocalizationText("0176"),
				gameScore.good.ToString(),
				GameSettingCtrl.GetLocalizationText("0058"),
				gameScore.maxCombo.ToString()
			};
			PublicGameUIManager.leaderBoard.MyScoreUpdate((int)gameScore.score);
			PublicGameUIManager.GetInstance.OpenResultBoard(gameScore.score.ToString("N0"), list.ToArray());
		}
	}
	public class XXEffect : MonoBehaviour
	{
		[SerializeField]
		private ParticleSystem particle;

		public void SetEffect()
		{
			base.gameObject.SetActive(value: true);
			StartCoroutine("PauseEffect");
		}

		private IEnumerator PauseEffect()
		{
			yield return new WaitForSeconds(1.5f);
			particle.Pause();
		}
	}
}
namespace Jisu.Boxing.Dummy
{
	public interface IInitializableListener
	{
		void Initialize();
	}
	public class BeatListener : MonoBehaviour, IInitializableListener
	{
		public enum Type
		{
			Scale,
			Alpha,
			Rotation
		}

		[SerializeField]
		private Type myType;

		[Header("Scale Field")]
		[SerializeField]
		private Vector3 Axis;

		[SerializeField]
		private AnimationCurve scaleCurve;

		[Header("AlphaField")]
		[SerializeField]
		private Image image;

		[SerializeField]
		private float Speed;

		[Header("RotateField")]
		[SerializeField]
		private Vector3 RotateAxis;

		[SerializeField]
		private float AngleAmount;

		[Header("Run Field")]
		[SerializeField]
		private float RunRate = 1f;

		[SerializeField]
		private float RunStartOffset;

		private float RunRateValue;

		[SerializeField]
		private AnimationCurve RunCurve;

		private void Awake()
		{
			GameManager.OnBeat += Loader_OnBeat;
			GameManager.OnHit += Loader_OnHit;
			GameManager.OnInitialize += Initialize;
			RunRateValue = RunStartOffset;
		}

		public void Initialize()
		{
			RunRateValue = RunStartOffset;
		}

		protected virtual void Loader_OnBeat(float time)
		{
			RunRateValue += RunRate;
			Quaternion defaultLocalRotation;
			if (!(RunRateValue < 1f))
			{
				RunRateValue = 0f;
				defaultLocalRotation = base.transform.localRotation;
				StartCoroutine(Easy(time, onUpdate));
			}
			void onUpdate(float t)
			{
				switch (myType)
				{
				case Type.Scale:
					base.transform.localScale = Axis * scaleCurve.Evaluate(t) + Vector3.one;
					break;
				case Type.Alpha:
				{
					Color color = image.color;
					color.a = RunCurve.Evaluate(t);
					image.color = color;
					break;
				}
				case Type.Rotation:
					base.transform.localRotation = Quaternion.Lerp(defaultLocalRotation, defaultLocalRotation * Quaternion.Euler(RotateAxis * AngleAmount), RunCurve.Evaluate(t));
					break;
				}
			}
		}

		protected void Loader_OnHit()
		{
			StartCoroutine(Easy(scaleCurve.keys[scaleCurve.length - 1].time, onUpdate));
			void onUpdate(float t)
			{
				base.transform.localScale = Axis * scaleCurve.Evaluate(t) + Vector3.one;
			}
		}

		protected IEnumerator Easy(float runtime, Action<float> OnUpdate)
		{
			float t = 0f;
			while (t < runtime)
			{
				OnUpdate?.Invoke(t / runtime);
				t += Time.deltaTime;
				yield return null;
			}
			OnUpdate?.Invoke(1f);
		}

		private void OnDestroy()
		{
			GameManager.OnBeat -= Loader_OnBeat;
			GameManager.OnHit -= Loader_OnHit;
			GameManager.OnInitialize -= Initialize;
		}
	}
	public class CombinationManager : LocalSingleton<CombinationManager>
	{
		[Serializable]
		public class HitArea
		{
			public Define.Target key;

			public Define.HittingArea[] hittingAreas;

			private int curIndex;

			private int[] usedArea;

			public void Initialize()
			{
				curIndex = 0;
				usedArea = Enumerable.Repeat(-1, hittingAreas.Length).ToArray();
			}

			public void ClearUseArray()
			{
				curIndex = 0;
				for (int i = 0; i < usedArea.Length; i++)
				{
					usedArea[i] = -1;
				}
			}

			public Define.HittingArea GetHittingArea(int index)
			{
				return hittingAreas[index];
			}

			public Define.HittingArea GetHittingArea(Define.CombinationState state)
			{
				if (hittingAreas.Length == 1)
				{
					return hittingAreas[0];
				}
				int num;
				if (state == Define.CombinationState.JorC_One)
				{
					num = 0;
				}
				else if (state == Define.CombinationState.JorC_Two)
				{
					while (true)
					{
						num = UnityEngine.Random.Range(0, hittingAreas.Length);
						if (num == 0)
						{
							continue;
						}
						bool flag = true;
						for (int i = 0; i < curIndex; i++)
						{
							if (usedArea[i] == num)
							{
								flag = false;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					usedArea[curIndex++] = num;
				}
				else
				{
					bool flag2;
					do
					{
						num = UnityEngine.Random.Range(0, hittingAreas.Length);
						flag2 = true;
						for (int j = 0; j < curIndex; j++)
						{
							if (usedArea[j] == num)
							{
								flag2 = false;
								break;
							}
						}
					}
					while (!flag2);
					usedArea[curIndex++] = num;
				}
				return hittingAreas[num];
			}
		}

		[Serializable]
		public class HitType
		{
			public Define.HitType key;

			public Define.HandDirection handDirection;

			public Define.Target target;
		}

		[Serializable]
		public class Combination
		{
			public Define.Combination key;

			public Define.HitType[] hitTypes;

			private int _JCIndex1;

			private int _JCIndex2;

			public Define.CombinationState state { get; private set; }

			public int JCIndex1
			{
				get
				{
					return _JCIndex1;
				}
				set
				{
					_JCIndex1 = value;
				}
			}

			public int JCIndex2
			{
				get
				{
					return _JCIndex2;
				}
				set
				{
					_JCIndex2 = value;
				}
			}

			public int count => hitTypes.Length;

			public void Initialize()
			{
				JCIndex1 = -1;
				JCIndex2 = -1;
				int num = 0;
				bool flag = false;
				string[] array = key.ToString().Split('_');
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == "J" || array[i] == "C")
					{
						if (!flag)
						{
							flag = true;
							JCIndex1 = i;
						}
						else
						{
							JCIndex2 = i;
						}
						num++;
					}
				}
				if (flag && num <= 1)
				{
					state = Define.CombinationState.JorC_One;
				}
				else if (flag && num == 2)
				{
					state = Define.CombinationState.JorC_Two;
				}
				else
				{
					state = Define.CombinationState.None;
				}
			}
		}

		[SerializeField]
		private HitArea[] hitAreas;

		[SerializeField]
		private HitType[] hitTypes;

		[SerializeField]
		private Combination[] combinations_2;

		[SerializeField]
		private Combination[] combinations_3;

		[SerializeField]
		private Combination[] combinations_4;

		[SerializeField]
		private Combination[] combinations_5;

		private Dictionary<Define.Target, HitArea> hitAraeDict = new Dictionary<Define.Target, HitArea>();

		private Dictionary<Define.HitType, HitType> hitTypeDict = new Dictionary<Define.HitType, HitType>();

		private Dictionary<Define.CombinationType, Dictionary<Define.Combination, Combination>> combDicts = new Dictionary<Define.CombinationType, Dictionary<Define.Combination, Combination>>();

		private int curComboType;

		private int curComboIndex;

		public bool isTest;

		public Define.CombinationType testType;

		public Define.Combination testCombo;

		public Combination curComb
		{
			get
			{
				Define.Combination key = combDicts[(Define.CombinationType)curComboType].Keys.ToArray()[curComboIndex];
				return combDicts[(Define.CombinationType)curComboType][key];
			}
		}

		protected override void Awake()
		{
			base.Awake();
			curComboType = 0;
			curComboIndex = -1;
			DictInitializing();
			GameManager.OnReady += Init;
		}

		private void DictInitializing()
		{
			for (int i = 0; i < hitAreas.Length; i++)
			{
				hitAreas[i].Initialize();
				hitAraeDict.Add(hitAreas[i].key, hitAreas[i]);
			}
			for (int j = 0; j < hitTypes.Length; j++)
			{
				hitTypeDict.Add(hitTypes[j].key, hitTypes[j]);
			}
			Dictionary<Define.Combination, Combination> dictionary = new Dictionary<Define.Combination, Combination>();
			Dictionary<Define.Combination, Combination> dictionary2 = new Dictionary<Define.Combination, Combination>();
			Dictionary<Define.Combination, Combination> dictionary3 = new Dictionary<Define.Combination, Combination>();
			Dictionary<Define.Combination, Combination> dictionary4 = new Dictionary<Define.Combination, Combination>();
			for (int k = 0; k < combinations_2.Length; k++)
			{
				combinations_2[k].Initialize();
				dictionary.Add(combinations_2[k].key, combinations_2[k]);
			}
			for (int l = 0; l < combinations_3.Length; l++)
			{
				combinations_3[l].Initialize();
				dictionary2.Add(combinations_3[l].key, combinations_3[l]);
			}
			for (int m = 0; m < combinations_4.Length; m++)
			{
				combinations_4[m].Initialize();
				dictionary3.Add(combinations_4[m].key, combinations_4[m]);
			}
			for (int n = 0; n < combinations_5.Length; n++)
			{
				combinations_5[n].Initialize();
				dictionary4.Add(combinations_5[n].key, combinations_5[n]);
			}
			combDicts.Add(Define.CombinationType.Combination2, dictionary);
			combDicts.Add(Define.CombinationType.Combination3, dictionary2);
			combDicts.Add(Define.CombinationType.Combination4, dictionary3);
			combDicts.Add(Define.CombinationType.Combination5, dictionary4);
		}

		private void Init()
		{
			curComboType = 0;
			curComboIndex = -1;
			for (int i = 0; i < hitAraeDict.Count; i++)
			{
				hitAraeDict[(Define.Target)i].ClearUseArray();
			}
		}

		public int GenerateCombination()
		{
			if (isTest)
			{
				curComboType = (int)testType;
				curComboIndex = (int)testCombo;
			}
			else
			{
				int num = combDicts[(Define.CombinationType)curComboType].Count - 1;
				if (curComboIndex == num)
				{
					curComboType++;
					curComboIndex = 0;
					if (curComboType > combDicts.Count - 1)
					{
						curComboType--;
						return -1;
					}
				}
				else
				{
					curComboIndex++;
				}
			}
			return curComb.count;
		}

		public Define.HittingArea SearchHitArea(int target, int index)
		{
			if (curComb.state == Define.CombinationState.JorC_One)
			{
				if (curComb.JCIndex1 == index)
				{
					return hitAraeDict[(Define.Target)target].GetHittingArea(curComb.state);
				}
			}
			else if (curComb.state == Define.CombinationState.JorC_Two)
			{
				if (curComb.key == Define.Combination.J_C)
				{
					return hitAraeDict[(Define.Target)target].GetHittingArea(index + 1);
				}
				if (curComb.JCIndex1 == index || curComb.JCIndex2 == index)
				{
					return hitAraeDict[(Define.Target)target].GetHittingArea(curComb.state);
				}
			}
			return hitAraeDict[(Define.Target)target].GetHittingArea(Define.CombinationState.None);
		}

		public HitType SearchHitType(int index)
		{
			return hitTypeDict[curComb.hitTypes[index]];
		}

		public void ResetHittingArea()
		{
			for (int i = 0; i < curComb.hitTypes.Length; i++)
			{
				hitAraeDict[hitTypeDict[curComb.hitTypes[i]].target].ClearUseArray();
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			GameManager.OnReady -= Init;
		}
	}
	public class CountEffect : MonoBehaviour
	{
		[SerializeField]
		private Image img_count;

		[SerializeField]
		private Sprite[] sprite_Number;

		[SerializeField]
		private float fadeTime;

		[SerializeField]
		private float fadeSpeed;

		private CoroutineWrapper countWrapper;

		private CoroutineWrapper animWrapper;

		private Color originAlpha;

		private void Awake()
		{
			countWrapper = CoroutineWrapper.Generate(this);
			animWrapper = CoroutineWrapper.Generate(this);
			img_count.gameObject.SetActive(value: false);
			originAlpha = img_count.color;
			GameManager.OnReady += SetCount;
		}

		private void SetCount()
		{
			img_count.gameObject.SetActive(value: true);
			countWrapper.Start(SetCount());
			IEnumerator SetCount()
			{
				int num = 2;
				WaitForSeconds wait = new WaitForSeconds(1f);
				while ((float)num >= 0f)
				{
					img_count.sprite = sprite_Number[num--];
					animWrapper.Start(FadeAnim());
					SoundManager.PlaySound(Define.SoundType.Count, state: true);
					yield return wait;
				}
				img_count.gameObject.SetActive(value: false);
			}
		}

		private IEnumerator FadeAnim()
		{
			img_count.color = originAlpha;
			float time = 0f;
			while (time < 1f)
			{
				time += Time.deltaTime;
				if (time >= fadeTime / 3f)
				{
					Color color = img_count.color;
					color.a = Mathf.Lerp(color.a, 0f, Time.deltaTime * fadeSpeed);
					img_count.color = color;
				}
				yield return null;
			}
		}

		private void OnDestroy()
		{
			GameManager.OnReady -= SetCount;
		}
	}
	public class CtrlrCollider : MonoBehaviour
	{
		public Jisu.Utils.Notifier<bool> isCollision { get; private set; } = new Jisu.Utils.Notifier<bool>();


		private void OnTriggerEnter(Collider other)
		{
			if (other.gameObject.CompareTag("DummyBoundary"))
			{
				isCollision.CurrentData = true;
			}
		}

		private void OnTriggerExit(Collider other)
		{
			if (other.gameObject.CompareTag("DummyBoundary"))
			{
				isCollision.CurrentData = false;
			}
		}
	}
	public static class Define
	{
		public enum Tag
		{
			Glove,
			Dummy,
			DummyBoundary
		}

		public enum HandDirection
		{
			Left,
			Right,
			None
		}

		public enum GloveState
		{
			Idle,
			Swing,
			Attach,
			Returning
		}

		public enum GameOverType
		{
			TimeOver,
			CombinationClear
		}

		public enum Target
		{
			Body_C,
			Body_L,
			Body_R,
			Head_Down_L,
			Head_Down_R,
			Head_L,
			Head_R,
			Head_Up
		}

		public enum HittingArea
		{
			Body_C_01,
			Body_C_02,
			Body_L,
			Body_R,
			Head_Down_L,
			Head_Down_R,
			Head_L_01,
			Head_L_02,
			Head_R_01,
			Head_R_02,
			Head_Up_01,
			Head_Up_02,
			Head_Up_03
		}

		public enum HitType
		{
			Jab,
			Cross,
			Left_Hook,
			Right_Hook,
			Left_UpperCut,
			Right_UpperCut,
			Body_Jab,
			Body_Cross,
			Left_Body,
			Right_Body
		}

		public enum CombinationType
		{
			Combination2,
			Combination3,
			Combination4,
			Combination5
		}

		public enum CombinationState
		{
			None,
			JorC_One,
			JorC_Two
		}

		public enum Combination
		{
			J_C,
			J_BC,
			BJ_C,
			BJ_BC,
			J_LH,
			J_LU,
			C_J,
			C_LH,
			C_LB,
			LB_RH,
			LB_C,
			RB_RH,
			RU_LH,
			RU_C,
			RU_J,
			J_J_C,
			J_BJ_C,
			C_LH_C,
			LH_C_LH,
			J_BC_LH,
			J_C_J,
			J_C_C,
			J_RU_LH,
			J_LB_LH,
			J_LU_RH,
			J_C_LB_RU,
			J_C_LH_LU,
			J_C_LH_RU,
			C_LH_C_LB,
			C_LH_BC_LU,
			J_LH_C_LH,
			J_LB_LH_RU,
			J_BC_LH_RB,
			J_J_BJ_LH,
			LU_RH_LB_RB,
			J_C_LU_C_LH,
			LH_C_LU_RH_LB,
			J_C_LH_LH_C,
			J_J_C_LH_RH,
			J_C_LH_LH_RH
		}

		public enum JudgeType
		{
			Perfect,
			Great,
			Good
		}

		public enum SoundType
		{
			BGM,
			GameStart,
			GameOver,
			GlovePunch_Strong,
			GlovePunch_Weak,
			GloveSwing,
			Count,
			Life,
			Button
		}

		public static Color Color_Perfect = new Color(1f, 0.1910364f, 0f);

		public static Color Color_Great = new Color(0.09905662f, 0.4622642f, 0f, 0.5882353f);

		public static Color Color_Good = new Color(0f, 0.1772749f, 1f);
	}
	public class DieEffect : MonoBehaviour
	{
		[SerializeField]
		private GameObject[] colorPtcls;

		[SerializeField]
		private GameObject explosionObject;

		[SerializeField]
		private GameObject textObject;

		[SerializeField]
		private Material[] colorMtrls;

		[SerializeField]
		private Material[] textMtrls;

		private ParticleSystem.MainModule[] colorPtclsMain;

		private Renderer explosionRenderer;

		private Renderer textRenderer;

		private void Awake()
		{
			colorPtclsMain = new ParticleSystem.MainModule[colorPtcls.Length];
			for (int i = 0; i < colorPtcls.Length; i++)
			{
				colorPtclsMain[i] = colorPtcls[i].GetComponent<ParticleSystem>().main;
			}
			explosionRenderer = explosionObject.GetComponent<Renderer>();
			textRenderer = textObject.GetComponent<Renderer>();
		}

		public void SetExplosionEffect(Define.JudgeType type)
		{
			switch (type)
			{
			case Define.JudgeType.Perfect:
			{
				for (int j = 0; j < colorPtclsMain.Length; j++)
				{
					colorPtclsMain[j].startColor = Define.Color_Perfect;
				}
				break;
			}
			case Define.JudgeType.Great:
			{
				for (int k = 0; k < colorPtclsMain.Length; k++)
				{
					colorPtclsMain[k].startColor = Define.Color_Great;
				}
				break;
			}
			case Define.JudgeType.Good:
			{
				for (int i = 0; i < colorPtclsMain.Length; i++)
				{
					colorPtclsMain[i].startColor = Define.Color_Good;
				}
				break;
			}
			}
			explosionRenderer.material = colorMtrls[(int)type];
			textRenderer.material = textMtrls[(int)type];
		}
	}
	public class Dummy : MonoBehaviour
	{
		public Transform myCenter;

		[SerializeField]
		private GameObject[] scoreMeshes;

		[SerializeField]
		private Texture[] scoreTextures;

		private Renderer[] scoreRenderers;

		private bool isScoreSet;

		private void Awake()
		{
			scoreRenderers = new Renderer[scoreMeshes.Length];
			for (int i = 0; i < scoreMeshes.Length; i++)
			{
				scoreRenderers[i] = scoreMeshes[i].GetComponent<Renderer>();
			}
			isScoreSet = false;
			ResetScoreMesh();
			GameManager.OnOver += ResetScoreMesh;
		}

		private void Start()
		{
			StartCoroutine(UpdateScore());
			IEnumerator UpdateScore()
			{
				while (!LocalSingleton<GameManager>.Instance.gameover)
				{
					if (!isScoreSet)
					{
						SetScoreMesh();
					}
					UpdateScoreMesh();
					yield return YieldInstructionCache.WaitForSeconds(0.2f);
				}
			}
		}

		private void SetScoreMesh()
		{
			if (LocalSingleton<GameManager>.Instance.gameScore.isStart)
			{
				isScoreSet = true;
				for (int i = 0; i < scoreMeshes.Length; i++)
				{
					scoreMeshes[i].SetActive(value: true);
					scoreRenderers[i].material.mainTexture = scoreTextures[0];
				}
			}
		}

		private void ResetScoreMesh()
		{
			isScoreSet = false;
			for (int i = 0; i < scoreMeshes.Length; i++)
			{
				scoreMeshes[i].SetActive(value: false);
			}
		}

		private void UpdateScoreMesh()
		{
			float score = LocalSingleton<GameManager>.Instance.gameScore.score;
			int[] array = new int[5]
			{
				(int)(score % 100000f * 0.0001f),
				(int)(score % 10000f * 0.001f),
				(int)(score % 1000f * 0.01f),
				(int)(score % 100f * 0.1f),
				(int)(score % 10f)
			};
			for (int i = 0; i < 5; i++)
			{
				scoreRenderers[i].material.mainTexture = scoreTextures[array[i]];
			}
		}

		private void OnDestroy()
		{
			GameManager.OnOver -= ResetScoreMesh;
		}
	}
	public class GameManager : LocalSingleton<GameManager>
	{
		private float _curTime;

		private CoroutineWrapper updateWrapper;

		private int BPM = 115;

		private float SongTime;

		private float[] SpectrumSampleData = new float[256];

		public static float EnvironmentRunRate = 1f;

		public bool gameReady { get; private set; }

		public bool gamePreOver { get; private set; }

		public bool gameover { get; private set; }

		public float gameTime { get; private set; }

		public float curTime
		{
			get
			{
				return _curTime;
			}
			private set
			{
				_curTime = value;
				if (_curTime > gameTime)
				{
					_curTime = gameTime;
				}
			}
		}

		public float totalPlayTime { get; private set; }

		public Score gameScore { get; private set; }

		public Define.GameOverType gameOverType { get; set; }

		private AudioSource targetSource => LocalSingleton<SoundManager>.Instance.GetBGMSource();

		public static event Action OnReady;

		public static event Action OnStart;

		public static event Action OnPreOver;

		public static event Action OnOver;

		public static event Action OnInitialize;

		public static event Action<float> OnBeat;

		public static event Action OnHit;

		public static event Action<float, float[]> OnSpectrum;

		public void SetTime(float time)
		{
			curTime += time;
		}

		public void HitBPMEvent()
		{
			GameManager.OnHit?.Invoke();
		}

		protected override void Awake()
		{
			base.Awake();
			gameReady = false;
			gamePreOver = false;
			gameover = true;
			gameTime = 0f;
			totalPlayTime = 0f;
			gameScore = new Score();
			updateWrapper = CoroutineWrapper.Generate(this);
			GameManager.OnInitialize?.Invoke();
		}

		private void Start()
		{
			SoundManager.PlaySound(Define.SoundType.BGM, state: true);
		}

		private IEnumerator OnUpdate()
		{
			while (!gameover && !gamePreOver)
			{
				curTime -= Time.deltaTime * 1.6f;
				if (curTime < 0f)
				{
					gameOverType = Define.GameOverType.TimeOver;
					curTime = 0f;
					if (GameManager.OnPreOver != null)
					{
						GamePreOver(1.5f);
					}
					else
					{
						GameOver();
					}
					break;
				}
				totalPlayTime += Time.deltaTime;
				yield return null;
			}
		}

		private void Update()
		{
			BPMEvent();
		}

		public void GameReady(float delay)
		{
			if (!gameReady)
			{
				gameReady = true;
				gameTime = 20f;
				curTime = 0f;
				totalPlayTime = 0f;
				GameManager.OnReady?.Invoke();
				if (delay.Equals(0f))
				{
					GameStart();
				}
				else
				{
					Invoke("GameStart", delay);
				}
			}
		}

		private void GameStart()
		{
			gameover = false;
			gameScore.Reset();
			curTime = gameTime;
			GameManager.OnStart?.Invoke();
			updateWrapper.Start(OnUpdate());
			SoundManager.PlaySound(Define.SoundType.GameStart, state: true);
		}

		private void GamePreOver(float delay)
		{
			GameManager.OnPreOver?.Invoke();
			Invoke("GameOver", delay);
			updateWrapper.Stop();
			SoundManager.PlaySound(Define.SoundType.GameOver, state: true);
		}

		public void GameClear()
		{
			gameOverType = Define.GameOverType.CombinationClear;
			if (GameManager.OnPreOver != null)
			{
				GamePreOver(1.5f);
			}
			else
			{
				GameOver();
			}
		}

		private void GameOver()
		{
			gameReady = false;
			gamePreOver = false;
			gameover = true;
			GameManager.OnOver?.Invoke();
			updateWrapper.Stop();
			StartCoroutine(SetResultUI());
		}

		private void BPMEvent()
		{
			float num = 60f / (float)BPM;
			if (Mathf.FloorToInt(SongTime / num) != Mathf.FloorToInt(targetSource.time / num))
			{
				targetSource.GetSpectrumData(SpectrumSampleData, 0, FFTWindow.Blackman);
				GameManager.OnBeat?.Invoke(num);
				GameManager.OnSpectrum?.Invoke(num, SpectrumSampleData);
			}
			SongTime = targetSource.time;
		}

		private IEnumerator SetResultUI()
		{
			yield return YieldInstructionCache.WaitForSeconds(0.5f);
			List<string> list = new List<string>
			{
				"Round",
				gameScore.round.ToString(),
				"Perfect",
				gameScore.perfect.ToString(),
				"Great",
				gameScore.great.ToString(),
				"Good",
				gameScore.good.ToString()
			};
			PublicGameUIManager.leaderBoard.MyScoreUpdate((int)gameScore.score);
			PublicGameUIManager.GetInstance.OpenResultBoard(gameScore.score.ToString("N0"), list.ToArray(), gameOverType == Define.GameOverType.CombinationClear);
		}
	}
	public class Glove : MonoBehaviour
	{
		[Header("Properties")]
		[SerializeField]
		private Define.HandDirection handDir;

		[SerializeField]
		private Transform ctrlrTF;

		[Header("Conditions")]
		[SerializeField]
		private float impulse;

		[SerializeField]
		private float angleLimit;

		[SerializeField]
		private float velocityStandard;

		[Header("Vibration Anim")]
		[SerializeField]
		private float shockCorrection;

		[SerializeField]
		private AnimationCurve shockCurve;

		[Header("Swing")]
		[SerializeField]
		private float swingVelocityStandard;

		[SerializeField]
		private float swingSoundIntvl;

		private UnityEngine.XR.Interaction.Toolkit.XRController xrCtrlr;

		private CtrlrCollider ctrlrCollider;

		private Transform myTF;

		private Rigidbody myRB;

		private CoroutineWrapper vibeWrapper;

		private Vector3 distanceFromCtrlr;

		private Vector3 currentVelocity;

		private bool isSwingSoundPlaying;

		private List<Vector3> previousVelocitys;

		private Define.GloveState _state;

		public Define.HandDirection Hand => handDir;

		public Vector3 previousMaxVelocity
		{
			get
			{
				Vector3 result = Vector3.zero;
				for (int i = 0; i < previousVelocitys.Count; i++)
				{
					if (result.sqrMagnitude < previousVelocitys[i].sqrMagnitude)
					{
						result = previousVelocitys[i];
					}
				}
				return result;
			}
		}

		public Define.GloveState state
		{
			get
			{
				return _state;
			}
			set
			{
				_state = value;
				switch (_state)
				{
				case Define.GloveState.Idle:
					myRB.isKinematic = false;
					myRB.detectCollisions = true;
					break;
				case Define.GloveState.Swing:
					myRB.isKinematic = false;
					myRB.detectCollisions = true;
					if (!isSwingSoundPlaying)
					{
						StartCoroutine(Easy_SwingSound(swingSoundIntvl));
						SoundManager.PlaySound(Define.SoundType.GloveSwing, state: true);
					}
					break;
				case Define.GloveState.Attach:
					myRB.isKinematic = true;
					break;
				case Define.GloveState.Returning:
					myRB.isKinematic = false;
					myRB.detectCollisions = false;
					vibeWrapper.Stop();
					break;
				}
			}
		}

		private void Awake()
		{
			xrCtrlr = ctrlrTF.GetComponentInParent<UnityEngine.XR.Interaction.Toolkit.XRController>();
			ctrlrCollider = ctrlrTF.GetComponentInParent<CtrlrCollider>();
			myTF = GetComponent<Transform>();
			myRB = GetComponent<Rigidbody>();
			vibeWrapper = CoroutineWrapper.Generate(this);
			isSwingSoundPlaying = false;
			previousVelocitys = new List<Vector3>();
			state = Define.GloveState.Idle;
		}

		private void AddPreviousVelocitys()
		{
			distanceFromCtrlr = ctrlrTF.position - myTF.position;
			currentVelocity = distanceFromCtrlr / Time.fixedDeltaTime;
			if (previousVelocitys.Count >= 3)
			{
				previousVelocitys.RemoveAt(0);
			}
			previousVelocitys.Add(currentVelocity);
		}

		private void FixedUpdate()
		{
			AddPreviousVelocitys();
			switch (state)
			{
			case Define.GloveState.Idle:
				myTF.rotation = ctrlrTF.rotation;
				myRB.velocity = currentVelocity;
				if (!isSwingSoundPlaying && currentVelocity.sqrMagnitude > swingVelocityStandard * swingVelocityStandard)
				{
					state = Define.GloveState.Swing;
				}
				break;
			case Define.GloveState.Swing:
				myTF.rotation = ctrlrTF.rotation;
				myRB.velocity = currentVelocity;
				if (currentVelocity.sqrMagnitude < 0.040000003f)
				{
					state = Define.GloveState.Idle;
				}
				break;
			case Define.GloveState.Attach:
				if (!ctrlrCollider.isCollision.CurrentData)
				{
					state = Define.GloveState.Returning;
				}
				break;
			case Define.GloveState.Returning:
				if (distanceFromCtrlr.sqrMagnitude <= 0.010000001f)
				{
					state = Define.GloveState.Idle;
				}
				myTF.rotation = ctrlrTF.rotation;
				myRB.velocity = currentVelocity * 0.5f;
				break;
			}
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (state == Define.GloveState.Attach || !collision.gameObject.CompareTag("Dummy"))
			{
				return;
			}
			Dummy componentInParent = collision.gameObject.GetComponentInParent<Dummy>();
			Vector3 xzVector = componentInParent.myCenter.position;
			Vector3 position = myTF.position;
			if (!CalcAngle(Jisu.Utils.VectorExtension.AdaptY(in xzVector, in position.y)))
			{
				if (previousMaxVelocity.sqrMagnitude >= velocityStandard * velocityStandard)
				{
					HitStrongEvent(ref collision);
				}
				else
				{
					HitWeakEvent();
				}
			}
		}

		private bool CalcAngle(Vector3 center)
		{
			Vector3 from = distanceFromCtrlr;
			Vector3 to = center - myTF.position;
			float num = Vector3.SignedAngle(from, to, Vector3.forward);
			if (num > angleLimit || num < 0f - angleLimit)
			{
				return true;
			}
			return false;
		}

		private void HitStrongEvent(ref Collision collision)
		{
			collision.rigidbody.AddForceAtPosition(previousMaxVelocity * impulse, collision.contacts[0].point, ForceMode.Impulse);
			TargetAndScoreManager instance = LocalSingleton<TargetAndScoreManager>.Instance;
			ref Define.HandDirection dir = ref handDir;
			Vector3 vel = previousMaxVelocity;
			Vector3 contactPnt = collision.contacts[0].point;
			instance.CheckCurTargetHit(in dir, in vel, in contactPnt);
			vibeWrapper.Start(SetImpulseVibe());
			SetHapticImpulse(0.5f * PublicGameUIManager.gameSetting.GetHapticValue(), 0.1f);
			if (ctrlrCollider.isCollision.CurrentData)
			{
				state = Define.GloveState.Attach;
			}
			else
			{
				state = Define.GloveState.Idle;
			}
			SoundManager.PlaySound(Define.SoundType.GlovePunch_Strong, state: true);
		}

		private void HitWeakEvent()
		{
			SetHapticImpulse(0.2f * PublicGameUIManager.gameSetting.GetHapticValue(), 0.1f);
			SoundManager.PlaySound(Define.SoundType.GlovePunch_Weak, state: true);
		}

		private IEnumerator Easy_SwingSound(float runTime)
		{
			isSwingSoundPlaying = true;
			yield return new WaitForSeconds(runTime);
			isSwingSoundPlaying = false;
		}

		private IEnumerator SetImpulseVibe()
		{
			float time = 0f;
			Vector3 origin = myTF.position;
			while (time <= shockCurve.keys[shockCurve.length - 1].time)
			{
				if (!ctrlrCollider.isCollision.CurrentData)
				{
					state = Define.GloveState.Returning;
					break;
				}
				time += Time.deltaTime;
				Vector3 vector = new Vector3(UnityEngine.Random.Range(0, 2), 0f, UnityEngine.Random.Range(0, 2)).normalized * shockCurve.Evaluate(time) * shockCorrection;
				myTF.position = origin + vector;
				yield return YieldInstructionCache.WaitForFixedUpdate;
			}
		}

		private void SetHapticImpulse(float amp, float duration)
		{
			if (xrCtrlr.inputDevice.TryGetHapticCapabilities(out var capabilities) && capabilities.supportsImpulse)
			{
				xrCtrlr.inputDevice.SendHapticImpulse(0u, amp, duration);
			}
		}
	}
	public class HowToPlay : MonoBehaviour
	{
		private CoroutineWrapper updateWrapper;

		private CanvasGroup helper;

		private void Awake()
		{
			updateWrapper = CoroutineWrapper.Generate(this);
			helper = GetComponent<CanvasGroup>();
			GameManager.OnReady += FadeAnim;
		}

		private void OnDestroy()
		{
			updateWrapper.Stop();
			GameManager.OnReady -= FadeAnim;
		}

		private void FadeAnim()
		{
			updateWrapper.Start(SetWindow(0f, 0.5f));
		}

		private IEnumerator SetWindow(float targetAlpha, float runTime)
		{
			float time = 0f;
			float originAlpha = helper.alpha;
			while (time < runTime)
			{
				helper.alpha = Mathf.Lerp(originAlpha, targetAlpha, time / runTime);
				time += Time.deltaTime;
				yield return null;
			}
			helper.alpha = targetAlpha;
		}
	}
	public interface IEffectable
	{
		void Run(in Define.HandDirection dir, in float runtime);
	}
	public class InfoBoard : MonoBehaviour
	{
		[Header("Properties")]
		[SerializeField]
		private Text roundText;

		[SerializeField]
		private Image[] images_Target;

		[SerializeField]
		private Image[] images_Miss;

		[SerializeField]
		private Image image_Time_Origin;

		[SerializeField]
		private Image image_Time_Plus;

		[SerializeField]
		private Image image_Time_Minus;

		[SerializeField]
		private Image image_Time_Highlight;

		[SerializeField]
		private Text gameOverText;

		[Header("Sprites")]
		[SerializeField]
		private Sprite[] sprites_target;

		[SerializeField]
		private Sprite[] sprites_Miss;

		[Header("Animations")]
		[SerializeField]
		private float timeLerpSpeed;

		[SerializeField]
		private AnimationCurve missCurve;

		[SerializeField]
		private AnimationCurve openAnimCurve;

		[SerializeField]
		private AnimationCurve closeAnimCurve;

		private CoroutineWrapper animWrapper;

		private CoroutineWrapper missWrapper;

		private CoroutineWrapper timerWrapper;

		private CoroutineWrapper plusWrapper;

		private CoroutineWrapper minusWrapper;

		private Transform myTF;

		private Vector3 originScale;

		private bool isTimeUpdating;

		private float currentFill;

		private float curTime => LocalSingleton<GameManager>.Instance.curTime;

		private float gameTime => LocalSingleton<GameManager>.Instance.gameTime;

		private void Awake()
		{
			animWrapper = CoroutineWrapper.Generate(this);
			missWrapper = CoroutineWrapper.Generate(this);
			timerWrapper = CoroutineWrapper.Generate(this);
			plusWrapper = CoroutineWrapper.Generate(this);
			minusWrapper = CoroutineWrapper.Generate(this);
			myTF = GetComponent<Transform>();
			originScale = myTF.localScale;
			isTimeUpdating = false;
			currentFill = 0f;
			for (int i = 0; i < images_Target.Length; i++)
			{
				images_Target[i].gameObject.SetActive(value: false);
			}
			image_Time_Origin.gameObject.SetActive(value: false);
			image_Time_Plus.gameObject.SetActive(value: false);
			image_Time_Minus.gameObject.SetActive(value: false);
			GameManager.OnReady += OpenBoard;
			GameManager.OnReady += ResetBoard;
			GameManager.OnStart += StartTimer;
			GameManager.OnPreOver += SetGameOverText;
			GameManager.OnOver += CloseBoard;
			GameManager.OnOver += StopTimer;
		}

		private void Start()
		{
			Vector3 localScale = originScale;
			localScale.y = 0f;
			myTF.localScale = localScale;
		}

		private void OpenBoard()
		{
			animWrapper.Start(OpenAnim());
			IEnumerator OpenAnim()
			{
				float time = 0f;
				while (time <= openAnimCurve.keys[openAnimCurve.length - 1].time)
				{
					time += Time.deltaTime;
					Vector3 localScale = originScale;
					localScale.y = originScale.y * openAnimCurve.Evaluate(time);
					myTF.localScale = localScale;
					yield return null;
				}
			}
		}

		private void CloseBoard()
		{
			animWrapper.Start(CloseAnim());
			IEnumerator CloseAnim()
			{
				float time = 0f;
				while (time <= closeAnimCurve.keys[closeAnimCurve.length - 1].time)
				{
					time += Time.deltaTime;
					Vector3 localScale = originScale;
					localScale.y *= closeAnimCurve.Evaluate(time);
					myTF.localScale = localScale;
					yield return null;
				}
			}
		}

		private void ResetBoard()
		{
			roundText.text = "Round 0";
			for (int i = 0; i < images_Target.Length; i++)
			{
				images_Target[i].gameObject.SetActive(value: false);
			}
			gameOverText.gameObject.SetActive(value: false);
			image_Time_Origin.gameObject.SetActive(value: true);
			image_Time_Plus.gameObject.SetActive(value: false);
			image_Time_Minus.gameObject.SetActive(value: false);
			image_Time_Origin.color = Color.green;
			image_Time_Origin.fillAmount = 1f;
			timerWrapper.Stop();
			plusWrapper.Stop();
			minusWrapper.Stop();
		}

		public void InitBoard(in CombinationManager.Combination combi)
		{
			roundText.text = $"Round {LocalSingleton<GameManager>.Instance.gameScore.round}";
			for (int i = 0; i < images_Miss.Length; i++)
			{
				images_Miss[i].gameObject.SetActive(value: false);
			}
			for (int j = 0; j < images_Target.Length; j++)
			{
				if (j < combi.count)
				{
					CombinationManager.HitType hitType = LocalSingleton<CombinationManager>.Instance.SearchHitType(j);
					images_Target[j].gameObject.SetActive(value: true);
					images_Target[j].sprite = sprites_target[(int)hitType.handDirection];
					images_Target[j].color = Color.gray;
				}
				else
				{
					images_Target[j].gameObject.SetActive(value: false);
				}
			}
		}

		public void UpdateInfo(bool isCorrect, int number)
		{
			if (isCorrect)
			{
				images_Target[number].color = Color.white;
				return;
			}
			images_Miss[number].gameObject.SetActive(value: true);
			missWrapper.Start(MissAnim(number));
		}

		private IEnumerator MissAnim(int index)
		{
			float time = 0f;
			while (time < missCurve.keys[missCurve.keys.Length - 1].time)
			{
				time += Time.deltaTime;
				int num = (int)missCurve.Evaluate(time);
				images_Miss[index].sprite = sprites_Miss[num];
				yield return null;
			}
		}

		private void StopTimer()
		{
			timerWrapper.Stop();
		}

		private void StartTimer()
		{
			timerWrapper.Start(UpdateTime());
			IEnumerator UpdateTime()
			{
				while (!LocalSingleton<GameManager>.Instance.gameover)
				{
					currentFill = curTime / gameTime;
					if (isTimeUpdating)
					{
						if (image_Time_Plus.IsActive())
						{
							image_Time_Plus.fillAmount = Mathf.Lerp(image_Time_Plus.fillAmount, currentFill, Time.deltaTime * 1.5f);
							image_Time_Origin.fillAmount = Mathf.Lerp(image_Time_Origin.fillAmount, currentFill, Time.deltaTime * timeLerpSpeed);
							image_Time_Highlight.fillAmount = image_Time_Plus.fillAmount;
						}
						if (image_Time_Minus.IsActive())
						{
							image_Time_Minus.fillAmount = Mathf.Lerp(image_Time_Minus.fillAmount, currentFill, Time.deltaTime * timeLerpSpeed);
							image_Time_Origin.fillAmount = Mathf.Lerp(image_Time_Origin.fillAmount, image_Time_Minus.fillAmount, 0.1f);
						}
					}
					else
					{
						image_Time_Origin.fillAmount = Mathf.Lerp(image_Time_Origin.fillAmount, currentFill, 0.25f);
					}
					yield return null;
				}
			}
		}

		public void UpdateTimer(in float delatTime)
		{
			LocalSingleton<GameManager>.Instance.SetTime(delatTime);
			if (delatTime >= 0f)
			{
				plusWrapper.StartSingleton(UpdatePlus(delatTime));
			}
			else
			{
				minusWrapper.StartSingleton(UpdateMinus(delatTime));
			}
			IEnumerator UpdateMinus(float time)
			{
				isTimeUpdating = true;
				image_Time_Origin.color = Color.red;
				image_Time_Origin.fillAmount = (curTime + Mathf.Abs(time)) / gameTime;
				image_Time_Minus.gameObject.SetActive(value: true);
				image_Time_Minus.fillAmount = curTime / gameTime;
				float targetFill = curTime / gameTime;
				while (image_Time_Origin.fillAmount > targetFill)
				{
					yield return null;
				}
				isTimeUpdating = false;
				image_Time_Origin.color = Color.green;
				image_Time_Minus.gameObject.SetActive(value: false);
			}
			IEnumerator UpdatePlus(float time)
			{
				isTimeUpdating = true;
				image_Time_Origin.color = Color.yellow;
				image_Time_Plus.gameObject.SetActive(value: true);
				image_Time_Plus.fillAmount = (curTime - time) / gameTime;
				image_Time_Highlight.gameObject.SetActive(value: true);
				image_Time_Highlight.fillAmount = (curTime - time) / gameTime;
				while (image_Time_Plus.fillAmount < image_Time_Origin.fillAmount)
				{
					yield return null;
				}
				isTimeUpdating = false;
				image_Time_Highlight.gameObject.SetActive(value: false);
				image_Time_Origin.color = Color.green;
				image_Time_Plus.gameObject.SetActive(value: false);
			}
		}

		private void SetGameOverText()
		{
			for (int i = 0; i < images_Target.Length; i++)
			{
				images_Target[i].gameObject.SetActive(value: false);
			}
			gameOverText.gameObject.SetActive(value: true);
			if (LocalSingleton<GameManager>.Instance.gameOverType == Define.GameOverType.TimeOver)
			{
				gameOverText.text = "Time Over";
			}
			else
			{
				gameOverText.text = "Combinations Clear";
			}
		}

		private void OnDestroy()
		{
			GameManager.OnReady -= ResetBoard;
			GameManager.OnReady -= OpenBoard;
			GameManager.OnStart -= StartTimer;
			GameManager.OnPreOver -= SetGameOverText;
			GameManager.OnOver -= StopTimer;
			GameManager.OnOver -= CloseBoard;
		}
	}
	public class Score
	{
		public float score;

		public int round;

		public int perfect;

		public int great;

		public int good;

		public Define.JudgeType recentJudgeType;

		public bool isStart;

		public void AddTargetScore(in float _score, in Define.JudgeType type)
		{
			if (!isStart)
			{
				isStart = true;
			}
			score += _score;
			recentJudgeType = type;
			switch (recentJudgeType)
			{
			case Define.JudgeType.Perfect:
				perfect++;
				break;
			case Define.JudgeType.Great:
				great++;
				break;
			case Define.JudgeType.Good:
				good++;
				break;
			}
		}

		public void AddTimeScore(float _score)
		{
			round++;
			score += _score;
		}

		public void Reset()
		{
			score = 0f;
			round = 1;
			perfect = 0;
			great = 0;
			good = 0;
			isStart = false;
		}
	}
	public class ShowingEffect : MonoBehaviour, IEffectable
	{
		[Header("Properties")]
		[SerializeField]
		private GameObject circle;

		[SerializeField]
		private Texture[] colorTex;

		private Material myMtrl;

		private void Awake()
		{
			myMtrl = circle.GetComponent<Renderer>().material;
		}

		public virtual void Run(in Define.HandDirection dir, in float runtime)
		{
			base.gameObject.SetActive(value: false);
			base.gameObject.SetActive(value: true);
			myMtrl.mainTexture = ((dir == Define.HandDirection.Left) ? colorTex[0] : colorTex[1]);
		}
	}
	public class SoundManager : LocalSingleton<SoundManager>
	{
		[Serializable]
		private class AudioDatum
		{
			public Define.SoundType type;

			public AudioClip[] clip;

			[Range(0f, 1f)]
			public float volume;

			public bool isLoop;
		}

		[Space(5f)]
		[Header("Source")]
		[SerializeField]
		private AudioSource BGMSource;

		[SerializeField]
		private AudioSource gamePlaySource;

		[SerializeField]
		private AudioSource glovePunchSource;

		[SerializeField]
		private AudioSource gloveSwingSource;

		[SerializeField]
		private AudioSource countSource;

		[SerializeField]
		private AudioSource lifeSource;

		[SerializeField]
		private AudioSource buttonSource;

		[Space(5f)]
		[Header("Audio Data")]
		[SerializeField]
		private AudioDatum BGMDatum;

		[SerializeField]
		private AudioDatum gameStartDatum;

		[SerializeField]
		private AudioDatum gameOverDatum;

		[SerializeField]
		private AudioDatum gloveHitStrongDatum;

		[SerializeField]
		private AudioDatum gloveHitWeakDatum;

		[SerializeField]
		private AudioDatum gloveSwingDatum;

		[SerializeField]
		private AudioDatum countDatum;

		[SerializeField]
		private AudioDatum lifeLossDatum;

		[SerializeField]
		private AudioDatum buttonDatum;

		private Dictionary<Define.SoundType, AudioDatum> AudioDatumDic = new Dictionary<Define.SoundType, AudioDatum>();

		private int countNum;

		public AudioSource GetBGMSource()
		{
			return BGMSource;
		}

		protected override void Awake()
		{
			base.Awake();
			AudioInitialize();
		}

		private void AudioInitialize()
		{
			AudioDatumDic.Add(BGMDatum.type, BGMDatum);
			AudioDatumDic.Add(gameStartDatum.type, gameStartDatum);
			AudioDatumDic.Add(gameOverDatum.type, gameOverDatum);
			AudioDatumDic.Add(gloveHitStrongDatum.type, gloveHitStrongDatum);
			AudioDatumDic.Add(gloveHitWeakDatum.type, gloveHitWeakDatum);
			AudioDatumDic.Add(gloveSwingDatum.type, gloveSwingDatum);
			AudioDatumDic.Add(countDatum.type, countDatum);
			AudioDatumDic.Add(lifeLossDatum.type, lifeLossDatum);
			AudioDatumDic.Add(buttonDatum.type, buttonDatum);
		}

		private void PlayOrStop(Define.SoundType type, bool state)
		{
			switch (type)
			{
			case Define.SoundType.BGM:
				PlayOrStopSource(type, state, ref BGMSource);
				break;
			case Define.SoundType.GameStart:
				PlayOrStopSource(type, state, ref gamePlaySource);
				break;
			case Define.SoundType.GameOver:
				countNum = 0;
				PlayOrStopSource(type, state, ref gamePlaySource);
				break;
			case Define.SoundType.GlovePunch_Strong:
				PlayOrStopSource(type, state, ref glovePunchSource);
				break;
			case Define.SoundType.GlovePunch_Weak:
				PlayOrStopSource(type, state, ref glovePunchSource);
				break;
			case Define.SoundType.GloveSwing:
				PlayOrStopSource(type, state, ref gloveSwingSource);
				break;
			case Define.SoundType.Count:
				PlayOrStopSource(type, state, countNum++, ref countSource);
				break;
			case Define.SoundType.Life:
				PlayOrStopSource(type, state, ref lifeSource);
				break;
			case Define.SoundType.Button:
				PlayOrStopSource(type, state, ref buttonSource);
				break;
			}
		}

		private void PlayOrStopSource(Define.SoundType type, bool state, ref AudioSource source)
		{
			if (state)
			{
				source.Stop();
				source.clip = AudioDatumDic[type].clip[UnityEngine.Random.Range(0, AudioDatumDic[type].clip.Length)];
				if (type == Define.SoundType.BGM)
				{
					source.volume = AudioDatumDic[type].volume;
				}
				else
				{
					source.volume = AudioDatumDic[type].volume;
				}
				source.time = 0f;
				source.loop = AudioDatumDic[type].isLoop;
				source.Play();
			}
			else
			{
				source.Stop();
			}
		}

		private void PlayOrStopSource(Define.SoundType type, bool state, int idx, ref AudioSource source)
		{
			if (state)
			{
				source.Stop();
				source.clip = AudioDatumDic[type].clip[idx];
				if (type == Define.SoundType.BGM)
				{
					source.volume = AudioDatumDic[type].volume;
				}
				else
				{
					source.volume = AudioDatumDic[type].volume;
				}
				source.time = 0f;
				source.loop = AudioDatumDic[type].isLoop;
				source.Play();
			}
			else
			{
				source.Stop();
			}
		}

		public static void PlaySound(Define.SoundType type, bool state)
		{
			if (!(LocalSingleton<SoundManager>.Instance == null))
			{
				LocalSingleton<SoundManager>.Instance.PlayOrStop(type, state);
			}
		}
	}
	public class SpectrumShaderListener : MonoBehaviour, IInitializableListener
	{
		[SerializeField]
		private List<Material> materials;

		[SerializeField]
		private Material EnvironmentMaterial;

		[SerializeField]
		private float minOpacity;

		[SerializeField]
		private float defaultScale;

		[SerializeField]
		private float ScaleFactor;

		[SerializeField]
		private AnimationCurve curve;

		[Header("Main Event")]
		[SerializeField]
		private float RunStartOffset;

		private float RunRateValue;

		[Header("Additional Event")]
		[SerializeField]
		private float AdditionalRunRate = 1f;

		[SerializeField]
		private float AdditionalRunStartOffset;

		private float AdditionalRunRateValue;

		[Header("Test view")]
		[SerializeField]
		private float maxValue;

		private const string MainColorProperty = "_MainColor";

		private const string VisualizerColorProperty = "_VisualizerColor";

		private const string OpacityProperty = "_Opacity";

		private const string OffsetProperty = "_Offset";

		private float RunRate => GameManager.EnvironmentRunRate;

		private void Awake()
		{
			GameManager.OnSpectrum += Loader_OnSpectrum;
			GameManager.OnSpectrum += Loader_OnSpectrum_EnvironmentColor;
			GameManager.OnInitialize += Initialize;
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
			RunRateValue = RunStartOffset;
			AdditionalRunRateValue = AdditionalRunStartOffset;
		}

		public void Initialize()
		{
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
			RunRateValue = RunStartOffset;
			AdditionalRunRateValue = AdditionalRunStartOffset;
		}

		private void Loader_OnSpectrum_EnvironmentColor(float runtime, float[] obj)
		{
			AdditionalRunRateValue += AdditionalRunRate;
			if (AdditionalRunRateValue < 1f)
			{
				return;
			}
			AdditionalRunRateValue = 0f;
			int num = UnityEngine.Random.Range(0, 30) * 12;
			Color value = ColorExtension.ConvertHsvToRgb(num % 360, 1.0, 1.0, 1f);
			Color value2 = ColorExtension.ConvertHsvToRgb((num + 150) % 360, 1.0, 1.0, 1f);
			foreach (Material material in materials)
			{
				material.SetColor("_MainColor", value);
				material.SetColor("_VisualizerColor", value2);
			}
			EnvironmentMaterial.SetColor("_EmissionColor", value);
		}

		private void Loader_OnSpectrum(float runtime, float[] obj)
		{
			RunRateValue += RunRate;
			if (RunRateValue < 1f)
			{
				return;
			}
			RunRateValue = 0f;
			List<float> MaxScale = new List<float>();
			float beatMaxScale = 0f;
			int num = obj.Length;
			int count = materials.Count;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (i * count / num != (i + 1) * count / num)
				{
					float t = 1f - ((float)(i + 1) - (float)num / (float)count * (float)num2);
					float num3 = 0f;
					num3 = ((obj.Length != i + 1) ? Mathf.Lerp(obj[i], obj[i + 1], t) : obj[i]);
					float value = num3;
					(float, float) input = (0f, 0.023f);
					(float, float) output = (0f, 1f);
					num3 = Jisu.Utils.VectorExtension.Remap(value, in input, in output);
					MaxScale.Add(ScaleFactor * num3 + defaultScale);
					maxValue = Mathf.Max(num3, maxValue);
					beatMaxScale = Mathf.Max(num3, beatMaxScale);
					materials[num2].SetFloat("_Opacity", ScaleFactor * num3 + defaultScale + minOpacity);
					materials[num2].SetFloat("_Offset", ScaleFactor * num3 + defaultScale);
					num2++;
				}
			}
			StartCoroutine(Run(runtime, OnUpdate));
			void OnUpdate(float _t)
			{
				int count2 = materials.Count;
				for (int j = 0; j < count2; j++)
				{
					materials[j].SetFloat("_Opacity", Mathf.Clamp01(Mathf.Lerp(beatMaxScale, defaultScale, _t) + minOpacity));
					materials[j].SetFloat("_Offset", Mathf.Clamp01(Mathf.Lerp(MaxScale[j], defaultScale, _t)));
				}
			}
			static IEnumerator Run(float _runtime, Action<float> _onUpdate)
			{
				float _t2 = 0f;
				while (_t2 < _runtime)
				{
					_onUpdate?.Invoke(_t2 / _runtime);
					_t2 += Time.deltaTime;
					yield return null;
				}
				_onUpdate?.Invoke(1f);
			}
		}

		private void OnDestroy()
		{
			GameManager.OnInitialize -= Initialize;
			GameManager.OnSpectrum -= Loader_OnSpectrum_EnvironmentColor;
			GameManager.OnSpectrum -= Loader_OnSpectrum;
			foreach (Material material in materials)
			{
				material.SetFloat("_Opacity", minOpacity);
				material.SetFloat("_Offset", 0f);
			}
		}
	}
	public class StartTarget : MonoBehaviour
	{
		[Header("Effects")]
		[SerializeField]
		private GameObject targetEffect;

		[SerializeField]
		private GameObject hitEffect;

		[Header("Fade Animation")]
		[SerializeField]
		private GameObject FadeEffect;

		[SerializeField]
		private float fadeScale;

		[SerializeField]
		private float fadeTime;

		[SerializeField]
		private float fadeSpeed;

		private Transform myTF;

		private Material[] materials;

		private Vector3 originScale;

		private bool isStarted;

		private void Awake()
		{
			myTF = FadeEffect.GetComponent<Transform>();
			materials = FadeEffect.GetComponent<Renderer>().materials;
			originScale = myTF.localScale;
			GameManager.OnReady += PressStart;
		}

		private void OnEnable()
		{
			targetEffect.gameObject.SetActive(value: true);
			isStarted = false;
		}

		private void OnTriggerEnter(Collider other)
		{
			if (!isStarted && other.gameObject.CompareTag("Glove") && LocalSingleton<GameManager>.Instance.gameover)
			{
				LocalSingleton<GameManager>.Instance.GameReady(3.3f);
			}
		}

		private void PressStart()
		{
			isStarted = true;
			hitEffect.gameObject.SetActive(value: true);
			StartCoroutine("FadePlayEffect");
			SoundManager.PlaySound(Define.SoundType.Button, state: true);
		}

		private IEnumerator FadePlayEffect()
		{
			targetEffect.gameObject.SetActive(value: false);
			FadeEffect.gameObject.SetActive(value: true);
			myTF.localScale = originScale;
			Color originAlpha = materials[0].color;
			float time = 0f;
			while (time <= fadeTime)
			{
				time += Time.deltaTime;
				Vector3 localScale = myTF.localScale;
				localScale.x = Mathf.Lerp(localScale.x, fadeScale, Time.deltaTime * 1.5f);
				localScale.y = Mathf.Lerp(localScale.y, fadeScale, Time.deltaTime * 1.5f);
				myTF.localScale = localScale;
				for (int i = 0; i < materials.Length; i++)
				{
					Color color = materials[i].color;
					color.a = Mathf.Lerp(color.a, 0f, Time.deltaTime * fadeSpeed);
					materials[i].color = color;
				}
				yield return null;
			}
			myTF.localScale = new Vector3(fadeScale, fadeScale, fadeScale);
			for (int j = 0; j < materials.Length; j++)
			{
				materials[j].color = originAlpha;
			}
			FadeEffect.gameObject.SetActive(value: false);
			hitEffect.gameObject.SetActive(value: false);
			base.gameObject.SetActive(value: false);
		}

		private void OnDestroy()
		{
			GameManager.OnReady -= PressStart;
		}
	}
	public class Target : MonoBehaviour
	{
		[Header("Properties")]
		[SerializeField]
		private Transform root;

		[SerializeField]
		private GameObject animPtcl;

		[SerializeField]
		private GameObject showingPtcl;

		[SerializeField]
		private GameObject diePtcl;

		public bool isBodyLR;

		[Header("Animation")]
		[SerializeField]
		private Material originMtrl;

		[SerializeField]
		private Material missMtrl;

		private Renderer myRenderer;

		private GameObject animGO;

		private ParticleSystem animSystem;

		private ParticleSystem.MainModule animSystemMain;

		private CoroutineWrapper timerWrapper;

		private CoroutineWrapper dieWrapper;

		private ShowingEffect showingEffect;

		private DieEffect dieEffect;

		private Define.HandDirection handDir;

		private int targetNumber;

		private float runTime;

		private float currentTime;

		public Transform myTF { get; private set; }

		public Define.HandDirection dir => handDir;

		public float timeRatio => currentTime / runTime;

		private void Awake()
		{
			myTF = GetComponent<Transform>();
			myRenderer = animPtcl.GetComponent<Renderer>();
			animGO = animPtcl.transform.parent.gameObject;
			animSystem = animPtcl.GetComponent<ParticleSystem>();
			animSystemMain = animSystem.main;
			timerWrapper = CoroutineWrapper.Generate(this);
			dieWrapper = CoroutineWrapper.Generate(this);
			showingEffect = showingPtcl.GetComponent<ShowingEffect>();
			dieEffect = diePtcl.GetComponent<DieEffect>();
			animGO.SetActive(value: false);
			showingPtcl.SetActive(value: false);
			diePtcl.SetActive(value: false);
			myTF.SetParent(root);
			GameManager.OnReady += Init;
			GameManager.OnPreOver += Disable;
		}

		private void Init()
		{
			handDir = Define.HandDirection.None;
			targetNumber = -1;
			myRenderer.material.mainTexture = null;
			runTime = 0f;
			animGO.gameObject.SetActive(value: false);
			showingPtcl.gameObject.SetActive(value: false);
			diePtcl.gameObject.SetActive(value: false);
			timerWrapper.Stop();
			dieWrapper.Stop();
		}

		public void SetAndRun(in Define.HandDirection dir, in int numbering, in Texture tex, in float duration)
		{
			handDir = dir;
			targetNumber = numbering;
			myRenderer.material.mainTexture = tex;
			runTime = duration;
			animGO.SetActive(value: false);
			animGO.SetActive(value: true);
			animSystem.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
			animSystemMain.duration = runTime;
			animSystemMain.startLifetime = runTime;
			animSystem.Play();
			myRenderer.material = originMtrl;
			myRenderer.material.mainTexture = tex;
			showingEffect.Run(in dir, in runTime);
			timerWrapper.Start(SetTimer(runTime));
			IEnumerator SetTimer(float runtime)
			{
				currentTime = runtime;
				while (currentTime > 0f)
				{
					if (LocalSingleton<GameManager>.Instance.gameover)
					{
						yield break;
					}
					currentTime -= Time.deltaTime;
					yield return null;
				}
				currentTime = 0f;
				MissEvent();
				LocalSingleton<TargetAndScoreManager>.Instance.DequeueTarget(correct: false);
			}
		}

		private void Disable()
		{
			timerWrapper.Stop();
			animGO.gameObject.SetActive(value: false);
			diePtcl.gameObject.SetActive(value: false);
		}

		private void MissEvent()
		{
			timerWrapper.Stop();
			myRenderer.material = missMtrl;
			animSystem.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
			animSystemMain.duration = 1f;
			animSystemMain.startLifetime = 1f;
			animSystem.Play();
			SoundManager.PlaySound(Define.SoundType.Life, state: true);
		}

		private void HitEvent()
		{
			timerWrapper.Stop();
			animGO.SetActive(value: false);
			dieWrapper.StartSingleton(Easy_DieEffect(0.5f));
			IEnumerator Easy_DieEffect(float delay)
			{
				diePtcl.gameObject.SetActive(value: false);
				diePtcl.gameObject.SetActive(value: true);
				dieEffect.SetExplosionEffect(LocalSingleton<GameManager>.Instance.gameScore.recentJudgeType);
				yield return YieldInstructionCache.WaitForSeconds(delay);
				diePtcl.gameObject.SetActive(value: false);
			}
		}

		public bool CheckCorrect(in Define.HandDirection dir, in Vector3 contactPnt, in float distLimit, in int number)
		{
			if (!handDir.Equals(dir) || !targetNumber.Equals(number) || !CalcDist(in contactPnt, in distLimit))
			{
				MissEvent();
				return false;
			}
			HitEvent();
			return true;
		}

		private bool CalcDist(in Vector3 pos, in float limit)
		{
			if (Vector3.Distance(myTF.position, pos) >= limit)
			{
				return false;
			}
			return true;
		}

		private void OnDestroy()
		{
			GameManager.OnReady -= Init;
			GameManager.OnPreOver -= Disable;
		}
	}
	public class TargetAndScoreManager : LocalSingleton<TargetAndScoreManager>
	{
		[Serializable]
		public class TargetDatum
		{
			public CombinationManager.HitType hitType;

			public int targetNumber;

			public Target target;
		}

		[Header("Target")]
		[SerializeField]
		private GameObject[] targetPrefabs;

		[SerializeField]
		private StartTarget startTarget;

		[SerializeField]
		private Texture[] mumbers_L;

		[SerializeField]
		private Texture[] mumbers_R;

		[Header("Time")]
		[SerializeField]
		private float roundIntvlTime;

		[SerializeField]
		private float spawnIntvlTime;

		[SerializeField]
		private float TargetTime;

		[SerializeField]
		private float perfectTime;

		[SerializeField]
		private float greatTime;

		[SerializeField]
		private float goodTime;

		[SerializeField]
		private float minusTime;

		[Header("Score")]
		[SerializeField]
		private float minVelocityValue;

		[SerializeField]
		private float maxVelocityValue;

		[SerializeField]
		private float minDistanceValue;

		[SerializeField]
		private float maxDistanceValue;

		[SerializeField]
		private float bodyDistanceValue;

		[SerializeField]
		private float powerMagnification;

		[SerializeField]
		private float accuracyMagnification;

		[SerializeField]
		private float targetTimeMagnification;

		[SerializeField]
		private float roundTimeMagnification;

		private InfoBoard infoBoard;

		private CoroutineWrapper updateWrapper;

		private CoroutineWrapper spawnWrapper;

		private CoroutineWrapper timerWrapper;

		private Dictionary<Define.HittingArea, Target> targetDict = new Dictionary<Define.HittingArea, Target>();

		private Queue<TargetDatum> spawnQueue;

		private Queue<TargetDatum> targetQueue;

		private bool isRoundOver;

		private int maxTarget;

		private float curRoundTime;

		private float maxRoundTime;

		public bool isTargetExist => targetQueue.Count > 0;

		private int curSpawnCount => spawnQueue.Count;

		private int frontTargetNum => targetQueue.Peek().targetNumber;

		private Target frontTarget => targetQueue.Peek().target;

		protected override void Awake()
		{
			base.Awake();
			infoBoard = GetComponentInChildren<InfoBoard>();
			updateWrapper = CoroutineWrapper.Generate(this);
			spawnWrapper = CoroutineWrapper.Generate(this);
			timerWrapper = CoroutineWrapper.Generate(this);
			spawnQueue = new Queue<TargetDatum>();
			targetQueue = new Queue<TargetDatum>();
			for (int i = 0; i < targetPrefabs.Length; i++)
			{
				targetDict.Add((Define.HittingArea)i, targetPrefabs[i].GetComponent<Target>());
			}
			GameManager.OnStart += Init;
			GameManager.OnPreOver += SetStart;
		}

		private void Init()
		{
			maxTarget = 0;
			curRoundTime = 0f;
			maxRoundTime = 0f;
			isRoundOver = false;
			spawnQueue.Clear();
			targetQueue.Clear();
			updateWrapper.Start(OnTargetUpdate());
		}

		private IEnumerator OnTargetUpdate()
		{
			while (base.enabled)
			{
				if (!LocalSingleton<GameManager>.Instance.gameover)
				{
					if (isRoundOver)
					{
						isRoundOver = false;
						yield return YieldInstructionCache.WaitForSeconds(roundIntvlTime);
					}
					if (!isTargetExist)
					{
						SpawnCombination();
					}
				}
				yield return YieldInstructionCache.WaitForSeconds(0.1f);
			}
		}

		private void SpawnCombination()
		{
			maxTarget = LocalSingleton<CombinationManager>.Instance.GenerateCombination();
			if (maxTarget == -1)
			{
				LocalSingleton<GameManager>.Instance.GameClear();
				return;
			}
			while (curSpawnCount < maxTarget)
			{
				CombinationManager.HitType hitType = LocalSingleton<CombinationManager>.Instance.SearchHitType(curSpawnCount);
				Define.HittingArea key = LocalSingleton<CombinationManager>.Instance.SearchHitArea((int)hitType.target, curSpawnCount);
				TargetDatum item = new TargetDatum
				{
					hitType = hitType,
					targetNumber = curSpawnCount,
					target = targetDict[key]
				};
				spawnQueue.Enqueue(item);
			}
			InfoBoard obj = infoBoard;
			CombinationManager.Combination combi = LocalSingleton<CombinationManager>.Instance.curComb;
			obj.InitBoard(in combi);
			spawnWrapper.Start(SpawnTarget(spawnIntvlTime));
		}

		private IEnumerator SpawnTarget(float delay)
		{
			maxRoundTime = (float)LocalSingleton<CombinationManager>.Instance.curComb.count * TargetTime - (delay * (float)curSpawnCount - 0.1f);
			timerWrapper.Start(SetTimer(maxRoundTime));
			while (curSpawnCount > 0 && !LocalSingleton<GameManager>.Instance.gamePreOver)
			{
				TargetDatum targetDatum = spawnQueue.Dequeue();
				Texture tex = ((targetDatum.hitType.handDirection == Define.HandDirection.Left) ? mumbers_L[targetDatum.targetNumber] : mumbers_R[targetDatum.targetNumber]);
				float duration = TargetTime;
				targetDatum.target.SetAndRun(in targetDatum.hitType.handDirection, in targetDatum.targetNumber, in tex, in duration);
				targetQueue.Enqueue(targetDatum);
				yield return YieldInstructionCache.WaitForSeconds(delay);
			}
		}

		public void CheckCurTargetHit(in Define.HandDirection dir, in Vector3 vel, in Vector3 contactPnt)
		{
			if (!LocalSingleton<GameManager>.Instance.gamePreOver && !LocalSingleton<GameManager>.Instance.gameover && isTargetExist)
			{
				float distLimit = (frontTarget.isBodyLR ? bodyDistanceValue : maxDistanceValue);
				Target target = frontTarget;
				int number = frontTargetNum;
				if (target.CheckCorrect(in dir, in contactPnt, in distLimit, in number))
				{
					Vector3 to = frontTarget.myTF.position;
					float timeRatio = frontTarget.timeRatio;
					CalcScore(in vel, in contactPnt, in to, in timeRatio);
					DequeueTarget(correct: true);
					LocalSingleton<GameManager>.Instance.HitBPMEvent();
				}
				else
				{
					DequeueTarget(correct: false);
				}
			}
		}

		public void DequeueTarget(bool correct)
		{
			infoBoard.UpdateInfo(correct, frontTargetNum);
			targetQueue.Dequeue();
			if (!isTargetExist)
			{
				RoundOver();
			}
			float delatTime = ((!correct) ? minusTime : (LocalSingleton<GameManager>.Instance.gameScore.recentJudgeType switch
			{
				Define.JudgeType.Great => greatTime, 
				Define.JudgeType.Perfect => perfectTime, 
				_ => goodTime, 
			}));
			infoBoard.UpdateTimer(in delatTime);
		}

		private void RoundOver()
		{
			isRoundOver = true;
			timerWrapper.Stop();
			spawnQueue.Clear();
			targetQueue.Clear();
			LocalSingleton<CombinationManager>.Instance.ResetHittingArea();
			LocalSingleton<GameManager>.Instance.gameScore.AddTimeScore(curRoundTime / maxRoundTime * roundTimeMagnification);
		}

		public void CalcScore(in Vector3 velocity, in Vector3 from, in Vector3 to, in float timeRatio)
		{
			float num = Mathf.Clamp(velocity.magnitude, minVelocityValue, maxVelocityValue);
			float num2 = powerMagnification * (num - minVelocityValue) / (maxVelocityValue - minVelocityValue);
			float num3 = Mathf.Clamp(Vector3.Distance(from, to), minDistanceValue, maxDistanceValue);
			float num4 = accuracyMagnification * (maxDistanceValue - num3) / (maxDistanceValue - minDistanceValue);
			float num5 = targetTimeMagnification * timeRatio;
			float _score = num2 + num4 + num5;
			int num6 = ((!(_score >= 200f)) ? ((_score >= 170f) ? 1 : 2) : 0);
			Score gameScore = LocalSingleton<GameManager>.Instance.gameScore;
			Define.JudgeType type = (Define.JudgeType)num6;
			gameScore.AddTargetScore(in _score, in type);
		}

		private IEnumerator SetTimer(float runtime)
		{
			curRoundTime = runtime;
			while (curRoundTime > 0.1f)
			{
				if (LocalSingleton<GameManager>.Instance.gamePreOver)
				{
					yield break;
				}
				curRoundTime -= Time.deltaTime;
				yield return null;
			}
			curRoundTime = 0f;
		}

		private void SetStart()
		{
			updateWrapper.Stop();
			spawnWrapper.Stop();
			timerWrapper.Stop();
			StartCoroutine(Easy(2.5f));
			IEnumerator Easy(float delay)
			{
				yield return YieldInstructionCache.WaitForSeconds(delay);
				startTarget.gameObject.SetActive(value: true);
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			GameManager.OnStart -= Init;
			GameManager.OnPreOver -= SetStart;
		}
	}
}
namespace Jisu.Boxing.Multi
{
	public class ArmDistanceLogger : MonoBehaviour
	{
		[SerializeField]
		private Transform Head;

		[SerializeField]
		private Transform Hand;

		[SerializeField]
		private VRIK ik;

		[SerializeField]
		private bool isEnable;

		[Space(20f)]
		[SerializeField]
		private List<UnityEngine.XR.Interaction.Toolkit.XRController> controllers;

		private void Update()
		{
			if (isEnable)
			{
				Vector3 vector = Head.position - Hand.position;
				UnityEngine.Debug.Log("Distance : " + Jisu.Utils.VectorExtension.ToXZ(in vector).magnitude);
				isEnable = false;
			}
			bool flag = true;
			foreach (UnityEngine.XR.Interaction.Toolkit.XRController controller in controllers)
			{
				flag = controller.inputDevice.TryGetFeatureValue(CommonUsages.triggerButton, out var value) && flag && value;
			}
			if (flag)
			{
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.HeadOffset.CurrentData = 1.636f - Head.localPosition.y;
				Jisu.Utils.Notifier<float> armDistance = Jisu.Utils.Singleton<MultiplayerSetting>.Instance.ArmDistance;
				Vector3 vector = Head.position - Hand.position;
				armDistance.CurrentData = Jisu.Utils.VectorExtension.ToXZ(in vector).magnitude;
			}
		}
	}
	public class BreakTimeCtrl : MonoBehaviour
	{
		private bool isPlay;

		[Header("RoundGirl")]
		[SerializeField]
		private Animator girlAnim;

		[SerializeField]
		private Transform[] girlPosition;

		[SerializeField]
		private MeshRenderer boardRenderer;

		[SerializeField]
		private Texture[] roundBoards;

		public void Start()
		{
			girlAnim.GetComponent<CustomModelSettingCtrl>().InitRandom(CustomModelViewState.Normal, null, 0f);
			StopCoachAnim();
		}

		public void PlayCoachAnim(int nextRound)
		{
			isPlay = true;
			girlAnim.gameObject.SetActive(value: true);
			girlAnim.Play("OnRoundGirl");
			bool flag = nextRound == 2;
			Transform transform = ((!PhotonManager.isMasterClient) ? (flag ? girlPosition[1] : girlPosition[0]) : (flag ? girlPosition[0] : girlPosition[1]));
			girlAnim.transform.position = transform.position;
			girlAnim.transform.rotation = transform.rotation;
			boardRenderer.sharedMaterials[0].SetTexture("_BaseMap", flag ? roundBoards[0] : roundBoards[1]);
		}

		public void StopCoachAnim()
		{
			isPlay = false;
			girlAnim.gameObject.SetActive(value: false);
		}
	}
	public class CameraShake : MonoBehaviour
	{
		[SerializeField]
		private Transform CameraOffset;

		[SerializeField]
		private UnityEngine.InputSystem.XR.TrackedPoseDriver trackedPoseDriver;

		[Header("1 to 0")]
		[SerializeField]
		private AnimationCurve Curve;

		[SerializeField]
		private float damping;

		[SerializeField]
		private float dev_damage;

		[SerializeField]
		private bool TestRun;

		private CoroutineWrapper wrapper;

		private void Awake()
		{
			wrapper = new CoroutineWrapper(this);
		}

		private void OnEnable()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnDamageMessageReceive += Instance_OnDamageMessageReceive;
			};
		}

		private void Update()
		{
			if (TestRun)
			{
				Instance_OnDamageMessageReceive(new DamagePacket
				{
					damage = (int)dev_damage,
					velocity = Vector3.back
				});
				TestRun = false;
			}
		}

		private void Instance_OnDamageMessageReceive(DamagePacket packet)
		{
			if (!(Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvincibilityEndTime > Time.time))
			{
				float value = Mathf.Clamp(packet.damage, 40f, 160f);
				(float, float) input = (40f, 160f);
				(float, float) output = (0f, 1f);
				float magnitude2 = Jisu.Utils.VectorExtension.Remap(value, in input, in output);
				wrapper.StartSingleton(ShakeCamera(magnitude2));
			}
			IEnumerator ShakeCamera(float magnitude)
			{
				float t = 0f;
				float currentDelay = Mathf.Lerp(0.175f, 0.35f, magnitude);
				float invCurrentDelay = 1f / currentDelay;
				Vector3 up = Vector3.up;
				Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in packet.velocity);
				Vector3 dir = (up + Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector) * magnitude * damping).normalized;
				while (t < currentDelay)
				{
					CameraOffset.localRotation = Quaternion.Lerp(CameraOffset.localRotation, Quaternion.Lerp(Quaternion.identity, Quaternion.FromToRotation(Vector3.up, dir), Curve.Evaluate(t * invCurrentDelay)), 0.5f);
					t += Time.deltaTime;
					yield return null;
				}
				CameraOffset.localRotation = Quaternion.identity;
			}
		}

		private void OnDisable()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnDamageMessageReceive -= Instance_OnDamageMessageReceive;
			};
		}
	}
	public class ColliderEventRiser : MonoBehaviour
	{
		private Collider self;

		public Collider Self
		{
			get
			{
				if (self == null)
				{
					self = GetComponent<Collider>();
				}
				return self;
			}
		}

		public event Action<Collider, Collider> OnTriggerEnterEvent;

		public event Action<Collider, Collider> OnTriggerStayEvent;

		public event Action<Collider, Collider> OnTriggerEndEvent;

		private void Awake()
		{
			self = GetComponent<Collider>();
		}

		private void OnTriggerEnter(Collider other)
		{
			this.OnTriggerEnterEvent?.Invoke(Self, other);
		}

		private void OnTriggerStay(Collider other)
		{
			this.OnTriggerStayEvent?.Invoke(Self, other);
		}

		private void OnTriggerExit(Collider other)
		{
			this.OnTriggerEndEvent?.Invoke(Self, other);
		}
	}
	public class CollisionEventRiser : MonoBehaviour
	{
		private Collider self;

		public Collider Self
		{
			get
			{
				if (self == null)
				{
					self = GetComponent<Collider>();
				}
				return self;
			}
		}

		public event Action<Collider, Collision> OnCollisionEnterEvent;

		public event Action<Collider, Collision> OnCollisionStayEvent;

		public event Action<Collider, Collision> OnCollisionEndEvent;

		public event Action<Collider, Collider> OnTriggerEnterEvent;

		private void Awake()
		{
			self = GetComponent<Collider>();
		}

		private void OnCollisionEnter(Collision collision)
		{
			this.OnCollisionEnterEvent?.Invoke(Self, collision);
		}

		private void OnCollisionStay(Collision collision)
		{
			this.OnCollisionStayEvent?.Invoke(Self, collision);
		}

		private void OnCollisionExit(Collision collision)
		{
			this.OnCollisionEndEvent?.Invoke(Self, collision);
		}
	}
	public class ControllerData : MonoBehaviour
	{
		public enum ControllerType
		{
			None,
			Right,
			Left
		}

		public enum BlockType
		{
			None,
			Body,
			Arm,
			Glove
		}

		[SerializeField]
		private ControllerType type;

		[SerializeField]
		private GameObject GlovesRenderer;

		[SerializeField]
		private SkinnedMeshRenderer GlovesSkinRenderer;

		[SerializeField]
		private IK ik;

		[SerializeField]
		private Collider detector;

		[SerializeField]
		private CapsuleCollider tunnelingTester;

		[SerializeField]
		private ColliderEventRiser detectorEventRiser;

		[SerializeField]
		private Transform model;

		[SerializeField]
		private Transform modelRootBone;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController controller;

		[SerializeField]
		private GameObject InnerHand;

		[SerializeField]
		private MeshRenderer InnerHandRenderer;

		[SerializeField]
		private AnimationCurve InnerHandColorCurve;

		[SerializeField]
		private AnimationCurve HitMoveCurve;

		[SerializeField]
		private AnimationCurve HandReactionCurve;

		[SerializeField]
		private Animator GloveAnimator;

		[SerializeField]
		private MeshRenderer GloveVFX;

		public readonly Jisu.Utils.Notifier<bool> Enabled = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<BlockType> BlockedBy = new Jisu.Utils.Notifier<BlockType>();

		public ControllerType BlockedArmInfo;

		public readonly List<Collider> DectectedColliders = new List<Collider>();

		private float LastVelocity;

		private Vector3 LastTrackedPosition;

		private Vector3 defaultRootBoneScale;

		private CoroutineWrapper blockHandScaleAnimationRoutine;

		private bool ActiveGhost;

		private readonly Jisu.Utils.Notifier<bool> ActiveGhostOverrideValue = new Jisu.Utils.Notifier<bool>();

		private readonly Jisu.Utils.Notifier<bool> TriggerState = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> FireHandState = new Jisu.Utils.Notifier<bool>();

		private bool isMenuOpen;

		public Collider BlockedCollider { get; set; }

		public ControllerType Type => type;

		public Collider Detector => detector;

		public CapsuleCollider TunnelingTester => tunnelingTester;

		public Transform Model => model;

		public UnityEngine.XR.Interaction.Toolkit.XRController Controller => controller;

		public float GloveVfxAlpha { get; private set; }

		private void Awake()
		{
			defaultRootBoneScale = modelRootBone.transform.localScale;
			detectorEventRiser.OnTriggerEnterEvent += DetectorEventRiser_OnTriggerEnterEvent;
			detectorEventRiser.OnTriggerEndEvent += DetectorEventRiser_OnTriggerEndEvent;
			Enabled.CurrentData = true;
			blockHandScaleAnimationRoutine = new CoroutineWrapper(this);
			BlockedBy.OnDataChangedDelta += BlockedBy_OnDataChangedDelta;
			ActiveGhostOverrideValue.OnDataChanged += ActiveGhostOverrideValue_OnDataChanged;
			TriggerState.OnDataChanged += TriggerState_OnDataChanged;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged += IsDown_OnDataChanged;
		}

		private void Start()
		{
			PublicGameUIManager.GetInstance.AddMenuEvent(AddMenuEvent_OnDataChanged);
		}

		private void AddMenuEvent_OnDataChanged(bool obj)
		{
			isMenuOpen = obj;
		}

		private void TriggerState_OnDataChanged(bool isDown)
		{
			if (isDown)
			{
				SettingFireHand();
			}
		}

		private void SettingFireHand()
		{
			if (!LocalSingleton<MultiGameManager>.Instance.isEnd.CurrentData && !isMenuOpen && !LocalSingleton<MultiGameManager>.Instance.isPause.CurrentData && Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.CurrentData > 0 && !FireHandState.CurrentData)
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.CurrentData--;
				FireHandState.CurrentData = true;
			}
		}

		private void IsDown_OnDataChanged(bool isDown)
		{
			GlovesRenderer.SetActive(!isDown);
			if (isDown)
			{
				GloveVfxAlpha = 0f;
				GloveVFX.sharedMaterial.SetFloat("_Alpha", 0f);
				GloveVFX.sharedMaterial.SetFloat("_Speed", 0f);
			}
		}

		private void ActiveGhostOverrideValue_OnDataChanged(bool isOverrideActive)
		{
			BlockPacket data = new BlockPacket
			{
				hand = (int)type,
				destinationHand = 0,
				lastVelocity = LastVelocity,
				blockState = 0,
				overrideGhostState = (isOverrideActive ? 1 : 0),
				position = model.transform.position,
				runEffect = false
			};
			PhotonManager.SendBlockingData(in data);
		}

		private void BlockedBy_OnDataChangedDelta(BlockType prev, BlockType nextType)
		{
			Vector3 normalized = (BlockedCollider.transform.position - model.transform.position).normalized;
			Vector3 position = model.transform.position;
			if (BlockedCollider != null && BlockedCollider.Raycast(new Ray(model.transform.position - normalized, normalized), out var hitInfo, 3f))
			{
				position = hitInfo.point;
			}
			BlockPacket data = new BlockPacket
			{
				hand = (int)type,
				destinationHand = (int)BlockedArmInfo,
				lastVelocity = LastVelocity,
				blockState = (int)nextType,
				runEffect = true,
				position = position
			};
			if (nextType != 0 && prev == BlockType.None)
			{
				model.transform.position = Vector3.Lerp(model.transform.position, controller.transform.position, 1f);
				model.transform.rotation = Quaternion.Lerp(model.transform.rotation, controller.transform.rotation, 1f);
				LastTrackedPosition = model.transform.position;
				CancelFireHand();
				if (LastVelocity > 0.025f && nextType == BlockType.Glove)
				{
					EffectManager instance = LocalSingleton<EffectManager>.Instance;
					string key = "hit_guard";
					Vector3 lookDir = Camera.main.transform.forward;
					float magnitude = 1f;
					instance.RunOneShot(in key, in position, in lookDir, in magnitude);
					controller.SetHapticImpulse(LastVelocity, 0.1f);
					data.runEffect = true;
				}
				blockHandScaleAnimationRoutine.StartSingleton(BlockReaction(LastVelocity));
			}
			DIsplayGhostGlove(nextType != BlockType.None);
			PhotonManager.SendBlockingData(in data);
		}

		private void DIsplayGhostGlove(bool? activeGhost = null, bool? overrideValue = null)
		{
			if (activeGhost.HasValue)
			{
				ActiveGhost = activeGhost.Value;
			}
			if (overrideValue.HasValue)
			{
				ActiveGhostOverrideValue.CurrentData = overrideValue.Value;
			}
			switch (type)
			{
			case ControllerType.Left:
				GlovesSkinRenderer.sharedMaterial.SetFloat("_IsGhostL", (ActiveGhost || ActiveGhostOverrideValue.CurrentData) ? 1 : 0);
				break;
			case ControllerType.Right:
				GlovesSkinRenderer.sharedMaterial.SetFloat("_IsGhostR", (ActiveGhost || ActiveGhostOverrideValue.CurrentData) ? 1 : 0);
				break;
			}
		}

		private void Instance_OnBlockingMessageReceive(BlockPacket obj)
		{
			if (obj.destinationHand == (int)type)
			{
				if (obj.runEffect)
				{
					Vector3 vector = -obj.position;
					Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
					Vector3 position = Vector3.Lerp(Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector, obj.position.y), model.transform.position, 0.5f);
					EffectManager instance = LocalSingleton<EffectManager>.Instance;
					string key = "hit_guard";
					vector = Camera.main.transform.forward;
					float magnitude = 1f;
					instance.RunOneShot(in key, in position, in vector, in magnitude);
				}
				CancelFireHand();
				blockHandScaleAnimationRoutine.StartSingleton(BlockReaction(obj.lastVelocity));
				controller.SetHapticImpulse(LastVelocity, 0.1f);
			}
		}

		public void CancelFireHand()
		{
			FireHandState.CurrentData = false;
		}

		private IEnumerator BlockReaction(float lastVelocity)
		{
			float value = Mathf.Clamp01(lastVelocity);
			(float, float) input = (0f, 1f);
			(float, float) output = (0.3f, 1f);
			lastVelocity = Jisu.Utils.VectorExtension.Remap(value, in input, in output);
			float t = 0f;
			float runtime = 0.3f;
			while (t < runtime)
			{
				t += Time.deltaTime;
				modelRootBone.transform.localScale = defaultRootBoneScale + defaultRootBoneScale * HandReactionCurve.Evaluate(t / runtime) * lastVelocity;
				yield return null;
			}
			modelRootBone.transform.localScale = defaultRootBoneScale;
		}

		private void DetectorEventRiser_OnTriggerEnterEvent(Collider caller, Collider other)
		{
			DectectedColliders.Add(other);
		}

		private void DetectorEventRiser_OnTriggerEndEvent(Collider caller, Collider other)
		{
			DectectedColliders.Remove(other);
		}

		private void OnEnable()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnBlockingMessageReceive += Instance_OnBlockingMessageReceive;
			};
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager instance)
			{
				instance.RegistController(in this);
			};
			IKSolver iKSolver = ik.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(UpdateInternal));
		}

		private void OnDisable()
		{
			IKSolver iKSolver = ik.GetIKSolver();
			iKSolver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(iKSolver.OnPostUpdate, new IKSolver.UpdateDelegate(UpdateInternal));
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnBlockingMessageReceive -= Instance_OnBlockingMessageReceive;
			};
		}

		private void Update()
		{
			if (controller.inputDevice.TryGetFeatureValue(CommonUsages.trigger, out var value))
			{
				switch (type)
				{
				case ControllerType.Left:
					GloveAnimator.SetFloat("BlendL", value);
					break;
				case ControllerType.Right:
					GloveAnimator.SetFloat("BlendR", value);
					break;
				}
				TriggerState.CurrentData = value > 0.5f;
			}
			if (!ik.gameObject.activeInHierarchy)
			{
				UpdateInternal();
			}
		}

		private void UpdateInternal()
		{
			if (!Enabled.CurrentData)
			{
				GloveVfxAlpha = Mathf.Lerp(LastVelocity, 0f, 0.2f) * 0.3f;
				GloveVFX.sharedMaterial.SetFloat("_Alpha", Mathf.Lerp(LastVelocity, 0f, 0.2f) * 0.3f);
				GloveVFX.sharedMaterial.SetFloat("_Speed", Mathf.Lerp(LastVelocity, 0f, 0.2f));
				LastVelocity *= 0.2f;
				return;
			}
			float magnitude = (model.transform.position - detector.transform.position).magnitude;
			if (magnitude > 0.001f)
			{
				TunnelingTester.transform.position = Vector3.Lerp(model.transform.position, detector.transform.position, 0.5f);
				TunnelingTester.transform.rotation = Quaternion.Slerp(TunnelingTester.transform.rotation, Quaternion.LookRotation(detector.transform.position - TunnelingTester.transform.position), 0.5f);
				TunnelingTester.transform.localScale = detector.transform.localScale;
			}
			if (detector is CapsuleCollider)
			{
				TunnelingTester.height = Mathf.Lerp(TunnelingTester.height, magnitude / TunnelingTester.transform.localScale.x + (detector as CapsuleCollider).radius * 2f, 0.5f);
			}
			else if (detector is SphereCollider)
			{
				TunnelingTester.height = Mathf.Lerp(TunnelingTester.height, magnitude / TunnelingTester.transform.localScale.x + (detector as SphereCollider).radius * 2f, 0.5f);
			}
			if (Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvaildAttackTime > Time.time)
			{
				DIsplayGhostGlove(null, true);
			}
			else
			{
				DIsplayGhostGlove(null, false);
			}
			bool flag = BlockedBy.CurrentData == BlockType.None;
			if (Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData && LocalSingleton<MultiGameManager>.TryGetInstance(out var instance) && !instance.isEnd.CurrentData)
			{
				flag = false;
			}
			else if (Camera.main != null && Vector3.Dot((detector.transform.position - model.transform.position).normalized, Camera.main.transform.forward) < -0.7f && Vector3.Distance(Camera.main.transform.position, detector.transform.position) < 0.6f)
			{
				flag = true;
			}
			if (flag)
			{
				if (InnerHand.activeInHierarchy)
				{
					InnerHand.SetActive(value: false);
				}
				if (controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value))
				{
					float num = Mathf.Clamp01(value.magnitude - 1f);
					GloveVFX.transform.LookAt(controller.transform);
					GloveVfxAlpha = Mathf.Lerp(LastVelocity, num, 0.2f) * 0.3f;
					GloveVFX.sharedMaterial.SetFloat("_Alpha", Mathf.Lerp(LastVelocity, num, 0.2f) * 0.3f);
					GloveVFX.sharedMaterial.SetFloat("_Speed", Mathf.Lerp(LastVelocity, num, 0.2f));
					LastVelocity = num;
				}
				model.transform.position = Vector3.Lerp(model.transform.position, controller.transform.position, 0.5f);
				model.transform.rotation = Quaternion.Lerp(model.transform.rotation, controller.transform.rotation, 0.5f);
				LastTrackedPosition = model.transform.position;
				return;
			}
			if (!InnerHand.activeInHierarchy)
			{
				InnerHand.SetActive(value: true);
			}
			Color color = InnerHandRenderer.sharedMaterial.color;
			AnimationCurve innerHandColorCurve = InnerHandColorCurve;
			float value2 = Mathf.Clamp(magnitude, 0f, 0.3f);
			(float, float) input = (0f, 0.3f);
			(float, float) output = (0f, 1f);
			float value3 = innerHandColorCurve.Evaluate(Jisu.Utils.VectorExtension.Remap(value2, in input, in output));
			(float, float) input2 = (0f, 1f);
			(float, float) output2 = (0f, 0.2f);
			color.a = Jisu.Utils.VectorExtension.Remap(value3, in input2, in output2);
			InnerHandRenderer.sharedMaterial.color = color;
			GloveVfxAlpha = Mathf.Lerp(LastVelocity, 0f, 0.2f) * 0.3f;
			GloveVFX.sharedMaterial.SetFloat("_Alpha", Mathf.Lerp(LastVelocity, 0f, 0.2f) * 0.3f);
			GloveVFX.sharedMaterial.SetFloat("_Speed", Mathf.Lerp(LastVelocity, 0f, 0.2f));
			LastVelocity *= 0.2f;
			if (controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var _))
			{
				model.transform.position = Vector3.Lerp(LastTrackedPosition, controller.transform.position, 0.1f);
				model.transform.rotation = Quaternion.Lerp(model.transform.rotation, controller.transform.rotation, 0.015f);
			}
		}

		private void OnDestroy()
		{
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged -= IsDown_OnDataChanged;
		}
	}
	public class CountDownCaller : LocalSingleton<CountDownCaller>
	{
		private bool isLanguageChn;

		[SerializeField]
		private List<AudioClip> countDowns_eng;

		[SerializeField]
		private List<AudioClip> countDowns_chn;

		[SerializeField]
		private AudioSource source;

		private CoroutineWrapper wrapper;

		protected override void Awake()
		{
			base.Awake();
			wrapper = new CoroutineWrapper(this);
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			isLanguageChn = PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese;
		}

		public static void Call(int count, Action onComplete = null)
		{
			if (LocalSingleton<CountDownCaller>.TryGetInstance(out var instance))
			{
				instance.CallInternal(count, onComplete);
			}
		}

		public static void Cancel()
		{
			if (LocalSingleton<CountDownCaller>.TryGetInstance(out var instance))
			{
				instance.CancelInternal();
			}
		}

		private void CancelInternal()
		{
			wrapper.Stop();
		}

		private void CallInternal(int count, Action onComplete)
		{
			wrapper.StartSingleton(timer());
			IEnumerator timer()
			{
				yield return YieldInstructionCache.WaitForSeconds(1f);
				int i = 0;
				while (i < count)
				{
					if (isLanguageChn)
					{
						source.clip = countDowns_chn[i];
					}
					else
					{
						source.clip = countDowns_eng[i];
					}
					source.Play();
					yield return YieldInstructionCache.WaitForSeconds(1f + (float)(count - i) * 0.05f);
					yield return new WaitWhile(() => source.isPlaying);
					int num = i + 1;
					i = num;
				}
				onComplete?.Invoke();
			}
		}
	}
	public class EffectManager : LocalSingleton<EffectManager>
	{
		[Serializable]
		public class EffectPool
		{
			[SerializeField]
			private string key;

			[SerializeField]
			private ParticleSystem Origin;

			private Transform Root;

			private List<ParticleSystem> Pool = new List<ParticleSystem>();

			public string Key => key;

			public void WarmPool(in Transform root, in int count)
			{
				ParticleSystem.MainModule main = Origin.main;
				main.playOnAwake = false;
				Root = new GameObject(Key + "Pool").transform;
				Root.SetParent(root);
				for (int i = 0; i < count; i++)
				{
					ParticleSystem particleSystem = UnityEngine.Object.Instantiate(Origin);
					particleSystem.transform.SetParent(Root);
					Pool.Add(particleSystem);
				}
			}

			public ParticleSystem Get()
			{
				ParticleSystem particleSystem = Pool.FirstOrDefault((ParticleSystem system) => !system.isPlaying);
				if (particleSystem == null)
				{
					particleSystem = UnityEngine.Object.Instantiate(Origin);
					particleSystem.transform.SetParent(Root);
					Pool.Add(particleSystem);
				}
				return particleSystem;
			}
		}

		[Serializable]
		public class SoundPool
		{
			[SerializeField]
			private string key;

			[SerializeField]
			private List<AudioClip> variableClips;

			[SerializeField]
			private AudioSource Origin;

			[Range(0f, 2f)]
			[SerializeField]
			private float MasterVolume = 1f;

			private Transform Root;

			private float defaultVolume;

			private List<AudioSource> Pool = new List<AudioSource>();

			public string Key => key;

			public void WarmPool(in Transform root, in int count)
			{
				Origin.playOnAwake = false;
				defaultVolume = Origin.volume;
				Root = new GameObject(Key + "Pool").transform;
				Root.SetParent(root);
				for (int i = 0; i < count; i++)
				{
					AudioSource audioSource = UnityEngine.Object.Instantiate(Origin);
					audioSource.transform.SetParent(Root);
					Pool.Add(audioSource);
				}
			}

			public AudioSource Get(in float magnitude)
			{
				AudioSource audioSource = Pool.FirstOrDefault((AudioSource system) => !system.isPlaying);
				if (audioSource == null)
				{
					audioSource = UnityEngine.Object.Instantiate(Origin);
					audioSource.transform.SetParent(Root);
					Pool.Add(audioSource);
				}
				audioSource.clip = Jisu.Utils.CollectionExtension.GetRandom(variableClips);
				audioSource.volume = defaultVolume * MasterVolume * Mathf.Lerp(0.05f, 1f, magnitude) * 1.5f;
				audioSource.pitch = Mathf.Lerp(1f, 1.2f, magnitude);
				return audioSource;
			}

			public AudioSource GetWithRandomClip(out AudioClip clip, in float magnitude)
			{
				AudioSource audioSource = Pool.FirstOrDefault((AudioSource system) => !system.isPlaying);
				if (audioSource == null)
				{
					audioSource = UnityEngine.Object.Instantiate(Origin);
					audioSource.transform.SetParent(Root);
					Pool.Add(audioSource);
				}
				clip = Jisu.Utils.CollectionExtension.GetRandom(variableClips);
				audioSource.volume = defaultVolume * MasterVolume * Mathf.Lerp(0.05f, 1f, magnitude) * 1.5f;
				audioSource.pitch = Mathf.Lerp(1f, 1.2f, magnitude);
				return audioSource;
			}
		}

		[SerializeField]
		private List<EffectPool> Pool = new List<EffectPool>();

		[SerializeField]
		private List<SoundPool> SoundPools = new List<SoundPool>();

		private Dictionary<string, EffectPool> PoolDict = new Dictionary<string, EffectPool>();

		private Dictionary<string, SoundPool> SoundPoolDict = new Dictionary<string, SoundPool>();

		protected override void Awake()
		{
			base.Awake();
			foreach (EffectPool item in Pool)
			{
				Transform root = base.transform;
				int count = 5;
				item.WarmPool(in root, in count);
				PoolDict[item.Key] = item;
			}
			foreach (SoundPool soundPool in SoundPools)
			{
				Transform root = base.transform;
				int count = 5;
				soundPool.WarmPool(in root, in count);
				SoundPoolDict[soundPool.Key] = soundPool;
			}
		}

		public void Run(in string key, in Vector3 position, in Vector3 lookDir, in float magnitude = 1f)
		{
			ParticleSystem particleSystem = PoolDict[key].Get();
			particleSystem.transform.position = position;
			particleSystem.transform.localScale = Vector3.one;
			particleSystem.transform.LookAt(Camera.main.transform);
			particleSystem.Play();
			AudioSource audioSource = SoundPoolDict[key].Get(in magnitude);
			audioSource.transform.position = position;
			audioSource.Play();
		}

		public void RunOneShot(in string key, in Vector3 position, in Vector3 lookDir, in float magnitude = 1f)
		{
			ParticleSystem particleSystem = PoolDict[key].Get();
			particleSystem.transform.position = position;
			particleSystem.transform.localScale = Vector3.one;
			particleSystem.transform.LookAt(Camera.main.transform);
			particleSystem.Play();
			AudioClip clip;
			AudioSource withRandomClip = SoundPoolDict[key].GetWithRandomClip(out clip, in magnitude);
			withRandomClip.transform.position = position;
			withRandomClip.PlayOneShot(clip);
		}
	}
	public class FireHandControl : MonoBehaviour
	{
		[SerializeField]
		private bool isSender;

		[SerializeField]
		private Material GloveMaterial;

		[Header("if Sender")]
		[SerializeField]
		private ControllerData LeftController;

		[SerializeField]
		private ParticleSystem leftEffect;

		[SerializeField]
		private ParticleSystem leftChargeParticle;

		[SerializeField]
		private ControllerData RightController;

		[SerializeField]
		private ParticleSystem rightEffect;

		[SerializeField]
		private ParticleSystem rightChargeParticle;

		[Header("Sound")]
		[SerializeField]
		private AudioSource[] effectSources;

		[SerializeField]
		private AudioClip[] effectClips;

		private CoroutineWrapper leftIntensityWrapper;

		private CoroutineWrapper rightIntensityWrapper;

		private bool localLeftState;

		private bool localRightState;

		private readonly Jisu.Utils.Notifier<bool> remoteLeftFireHandState = new Jisu.Utils.Notifier<bool>();

		private readonly Jisu.Utils.Notifier<bool> remoteRightFireHandState = new Jisu.Utils.Notifier<bool>();

		private void Awake()
		{
			GloveMaterial.SetFloat("_IsRight", 0f);
			GloveMaterial.SetFloat("_IsLeft", 0f);
			leftIntensityWrapper = new CoroutineWrapper(this);
			rightIntensityWrapper = new CoroutineWrapper(this);
			if (isSender)
			{
				LeftController.FireHandState.OnDataChanged += LeftFireHandState_OnDataChanged;
				RightController.FireHandState.OnDataChanged += RightFireHandState_OnDataChanged;
			}
			else
			{
				remoteLeftFireHandState.OnDataChanged += LeftFireHandState_OnDataChanged;
				remoteRightFireHandState.OnDataChanged += RightFireHandState_OnDataChanged;
				PhotonSingleton<PhotonManager>.OnInitialized += PhotonManager_OnInitialized;
			}
		}

		private void PhotonManager_OnInitialized(PhotonManager photonManager)
		{
			photonManager.OnFireHandMessageReceive += PhotonManager_OnFireHandMessageReceive;
		}

		private void PhotonManager_OnFireHandMessageReceive(FireHandPacket obj)
		{
			remoteRightFireHandState.CurrentData = obj.rightState == 1;
			remoteLeftFireHandState.CurrentData = obj.leftState == 1;
		}

		private void RightFireHandState_OnDataChanged(bool isOn)
		{
			localRightState = isOn;
			GloveMaterial.SetFloat("_IsRight", isOn ? 1 : 0);
			if (isOn)
			{
				rightEffect.Play();
				rightIntensityWrapper.StartSingleton(IntensityControl("_RightHandIntensity"));
				rightChargeParticle.Play();
				effectSources[1].clip = effectClips[(int)UnityEngine.Random.Range(0f, 1.99999f)];
				effectSources[1].Play();
			}
			else
			{
				rightChargeParticle.Stop();
			}
			SendState();
		}

		private void LeftFireHandState_OnDataChanged(bool isOn)
		{
			localLeftState = isOn;
			GloveMaterial.SetFloat("_IsLeft", isOn ? 1 : 0);
			if (isOn)
			{
				leftEffect.Play();
				leftIntensityWrapper.StartSingleton(IntensityControl("_LeftHandIntensity"));
				leftChargeParticle.Play();
				effectSources[0].clip = effectClips[(int)UnityEngine.Random.Range(0f, 1.99999f)];
				effectSources[0].Play();
			}
			else
			{
				leftChargeParticle.Stop();
			}
			SendState();
		}

		private IEnumerator IntensityControl(string targetName, float runtime = 0.5f)
		{
			float t = 0f;
			while (t < runtime)
			{
				Material gloveMaterial = GloveMaterial;
				float value = t / runtime;
				(float, float) input = (0f, 1f);
				(float, float) output = (5f, 1f);
				gloveMaterial.SetFloat(targetName, Jisu.Utils.VectorExtension.Remap(value, in input, in output));
				t += Time.deltaTime;
				yield return null;
			}
			GloveMaterial.SetFloat(targetName, 1f);
		}

		private void SendState()
		{
			if (isSender)
			{
				FireHandPacket data = new FireHandPacket
				{
					leftState = (localLeftState ? 1 : 0),
					rightState = (localRightState ? 1 : 0)
				};
				PhotonManager.SendFireHandData(in data);
			}
		}

		private void OnDestroy()
		{
			GloveMaterial.SetFloat("_IsRight", 0f);
			GloveMaterial.SetFloat("_IsLeft", 0f);
			if (PhotonSingleton<PhotonManager>.TryGetInstance(out var instance))
			{
				instance.OnFireHandMessageReceive -= PhotonManager_OnFireHandMessageReceive;
			}
			PhotonSingleton<PhotonManager>.OnInitialized -= PhotonManager_OnInitialized;
		}
	}
	public class FootstepSoundControl : MonoBehaviour
	{
		[SerializeField]
		private VRIK ik;

		[SerializeField]
		private float threshold = 0.5f;

		[SerializeField]
		private float thresholdMax = 15f;

		private Vector3 lastComPosition;

		private Vector3 comVelocity;

		private void Awake()
		{
			IKSolverVR solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}

		private void OnUpdate()
		{
			Vector3 centerOfMass = ik.solver.locomotion.centerOfMass;
			comVelocity = ((Time.deltaTime > 0f) ? ((centerOfMass - lastComPosition) / Time.deltaTime) : Vector3.zero);
			lastComPosition = centerOfMass;
		}

		public void OnFootstep()
		{
			if (comVelocity.magnitude > threshold)
			{
				Vector3 vector = ik.solver.locomotion.centerOfMass;
				Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
				Vector3 position = Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector);
				float magnitude = comVelocity.magnitude;
				(float, float) input = (threshold, thresholdMax);
				(float, float) output = (0f, 1f);
				float value = Jisu.Utils.VectorExtension.Remap(magnitude, in input, in output);
				SoundManager.ClipType type = SoundManager.ClipType.Squeaks;
				float volume = Mathf.Clamp01(value);
				SoundManager.Run(in type, in position, in volume);
			}
		}

		private void OnDestroy()
		{
			IKSolverVR solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}
	}
	public class GloveHitReaction : MonoBehaviour
	{
		[SerializeField]
		private float runtime;

		[SerializeField]
		private float forceFactor;

		[SerializeField]
		private Collider detector;

		[SerializeField]
		private Transform Target;

		[SerializeField]
		private List<ControllerData> controllers;

		[SerializeField]
		private List<Collider> modelColliders;

		private readonly Jisu.Utils.Notifier<bool> IsContact = new Jisu.Utils.Notifier<bool>();

		private Vector3 ContactVelocity;

		private Vector3 ComputedPosition;

		private CoroutineWrapper translator;

		private void Awake()
		{
			IsContact.OnDataChanged += IsContact_OnDataChanged;
			translator = new CoroutineWrapper(this);
		}

		private void IsContact_OnDataChanged(bool isContact)
		{
			if (isContact)
			{
				translator.StartSingleton(MovePosition(ContactVelocity));
			}
		}

		private IEnumerator MovePosition(Vector3 velocity)
		{
			float t = 0f;
			Vector3 position = base.transform.position + velocity * forceFactor;
			Vector3 localPosition = base.transform.InverseTransformPoint(position);
			while (t < runtime)
			{
				t += Time.deltaTime;
				ComputedPosition = Vector3.Lerp(localPosition, Vector3.zero, t / runtime);
				yield return null;
			}
			ComputedPosition = Vector3.zero;
		}

		private void Update()
		{
			Target.transform.localPosition = Vector3.Lerp(Target.transform.localPosition, ComputedPosition, 0.3f);
			CheckContact();
		}

		public bool SimulatePenetrate(in Vector3 worldPosition, in float distanceRate, out Vector3 simulatedPosition)
		{
			Vector3 zero = Vector3.zero;
			bool flag = false;
			foreach (Collider modelCollider in modelColliders)
			{
				Collider dynamicCollider = detector;
				Vector3 worldOffset = worldPosition - detector.transform.position;
				if (modelCollider.ComputePenetration(dynamicCollider, in worldOffset, out var dir, out var dis))
				{
					zero += dir * dis * distanceRate;
					flag = true;
				}
			}
			if (flag)
			{
				simulatedPosition = worldPosition + zero;
			}
			else
			{
				simulatedPosition = worldPosition;
			}
			return flag;
		}

		private void CheckContact()
		{
			foreach (ControllerData controller in controllers)
			{
				if (controller.Detector.ComputePenetration(detector, out var dir, out var _))
				{
					if (controller.Controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value))
					{
						ContactVelocity = Vector3.Lerp(value.normalized, dir.normalized, 0.75f) * value.magnitude;
					}
					IsContact.CurrentData = true;
					return;
				}
			}
			IsContact.CurrentData = false;
		}
	}
	public class HitCollisionManager : MonoBehaviour
	{
		public class HitInfo
		{
			public bool isTunnelingBlocked;

			public ControllerData controller;

			public Vector3 position;

			public Vector3 velocity;

			public Vector3 penetrationOffset;

			public Collider bodyCollider;

			public Collider controllerCollider;
		}

		[Serializable]
		public class Detection
		{
			public ControllerData target;

			private Transform HeadTransform;

			private List<Collider> colliders;

			private bool isInitialized;

			private float lastHitTime;

			private bool lastContact;

			public Collider TargetColiider => target.Detector;

			public Collider TargetTester => target.TunnelingTester;

			public Transform Model => target.Model;

			public UnityEngine.XR.Interaction.Toolkit.XRController Controller => target.Controller;

			public event Action<HitInfo> OnHit;

			public event Predicate<Collider> BlockingColliderPredicate;

			public event Predicate<Collider> ColliderGhostState;

			public void Initialize(in List<Collider> colliders, in Transform head)
			{
				HeadTransform = head;
				this.colliders = colliders;
				isInitialized = true;
			}

			public Vector3 GetContactPosition(in Collider collider, Vector3 position)
			{
				if (!Controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value))
				{
					value = collider.transform.position - position;
				}
				value.Normalize();
				Vector3 vector = position;
				if (collider != null && collider.Raycast(new Ray(position - value, value), out var hitInfo, 3f))
				{
					vector = hitInfo.point;
				}
				return vector + value * 0.04f;
			}

			public void OnUpdate(in float inverseAttackDelay)
			{
				if (!isInitialized)
				{
					return;
				}
				bool flag = Mathf.Abs(Time.time - lastHitTime) * inverseAttackDelay > 1f;
				bool flag2 = false;
				foreach (Collider collider2 in colliders)
				{
					Collider collider = collider2;
					if (flag2)
					{
						break;
					}
					bool flag3 = false;
					bool flag4 = false;
					if (Physics.ComputePenetration(collider, collider.transform.position, collider.transform.rotation, TargetColiider, TargetColiider.transform.position, TargetColiider.transform.rotation, out var direction, out var distance))
					{
						bool flag5 = this.BlockingColliderPredicate(collider);
						if (flag5)
						{
							Vector3 vector = HeadTransform.position - collider.transform.position;
							if (Jisu.Utils.VectorExtension.ToXZ(in vector).magnitude > 0.4f)
							{
								flag3 = true;
								target.CancelFireHand();
								continue;
							}
							if (this.ColliderGhostState(collider))
							{
								flag4 = true;
								continue;
							}
							flag2 = true;
						}
						else
						{
							flag2 = true;
						}
						Vector3 velocity = (TargetColiider.transform.position - Model.transform.position) / Time.deltaTime;
						float num = Mathf.Abs(Vector3.Dot(velocity.normalized, direction.normalized));
						bool flag6 = velocity.magnitude > 0.05f;
						if (!lastContact && flag && num > 0.2f)
						{
							HitInfo obj = new HitInfo
							{
								controller = target,
								isTunnelingBlocked = (!flag6 || target.BlockedBy.CurrentData != ControllerData.BlockType.None),
								bodyCollider = collider,
								controllerCollider = TargetColiider,
								penetrationOffset = direction * distance,
								position = GetContactPosition(in collider, TargetColiider.transform.position),
								velocity = velocity
							};
							this.OnHit?.Invoke(obj);
							lastHitTime = Time.time;
						}
						if (flag5)
						{
							if (_instance.blockingColliderList.IndexOf(collider) == 0)
							{
								target.BlockedArmInfo = ControllerData.ControllerType.Left;
							}
							else
							{
								target.BlockedArmInfo = ControllerData.ControllerType.Right;
							}
						}
						else
						{
							target.BlockedArmInfo = ControllerData.ControllerType.None;
						}
						target.BlockedCollider = collider;
						target.BlockedBy.CurrentData = ((!flag5) ? ControllerData.BlockType.Body : ControllerData.BlockType.Glove);
					}
					bool flag7 = flag3 || flag4;
					if (target.BlockedBy.CurrentData != 0 && !flag7 && Physics.ComputePenetration(collider, collider.transform.position, collider.transform.rotation, TargetTester, TargetTester.transform.position, TargetTester.transform.rotation, out var _, out var _))
					{
						flag2 = true;
					}
				}
				if (!flag2 && lastContact)
				{
					target.BlockedArmInfo = ControllerData.ControllerType.None;
					target.BlockedBy.CurrentData = ControllerData.BlockType.None;
				}
				lastContact = flag2;
			}
		}

		private static HitCollisionManager _instance;

		[SerializeField]
		private Transform HeadTransform;

		[SerializeField]
		private HitReactionVRIK hitReaction;

		[SerializeField]
		private Animator animator;

		[SerializeField]
		private ParticleSystem fireDamageParticle;

		[SerializeField]
		private List<Collider> blockingColliderList;

		[SerializeField]
		private List<Detection> detectionTargets = new List<Detection>();

		private List<Collider> colliders = new List<Collider>();

		private EyeAnimationCtrl eyeAnimationCtrl;

		private int DownLayerIndex;

		private const string DownLayerDefaultName = "Idle";

		private Vector3 LastHitDirection;

		private bool isKO;

		private const float INVERSE_ATTACK_DELAY = 2.857143f;

		private bool isAnimatorIdle => animator.GetCurrentAnimatorStateInfo(DownLayerIndex).IsName("Idle");

		public Vector3 headPosition => HeadTransform.position;

		private float ReadyTime => Jisu.Utils.Singleton<MultiplayerSetting>.Instance.StartTime.CurrentData + 3f;

		public static bool TryGetInstance(out HitCollisionManager instance)
		{
			instance = _instance;
			return _instance != null;
		}

		private void Awake()
		{
			_instance = this;
			eyeAnimationCtrl = HeadTransform.GetComponentInChildren<EyeAnimationCtrl>();
			DownLayerIndex = animator.GetLayerIndex("DownLayer");
			colliders = hitReaction.positionOffsets.Select((HitReactionVRIK.PositionOffset offset) => offset.collider).ToList();
			foreach (Detection detectionTarget in detectionTargets)
			{
				detectionTarget.Initialize(in colliders, in HeadTransform);
				detectionTarget.OnHit += Detection_OnHit;
				detectionTarget.BlockingColliderPredicate += isBlockingCollider;
				detectionTarget.ColliderGhostState += Target_ColliderGhostState;
			}
			LocalSingleton<MultiGameManager>.OnInitialized += MultiGameManager_OnInitialized;
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.OnDataChanged += RemotePlayerDown_OnDataChanged;
		}

		private void MultiGameManager_OnInitialized(MultiGameManager multiGameManager)
		{
			multiGameManager.OnAwakeReceive += MultiGameManager_OnAwakeReceive;
		}

		private void MultiGameManager_OnAwakeReceive(AwakePacket obj)
		{
			eyeAnimationCtrl.SetExpression(0, 0f);
			animator.SetTrigger("WakeUp");
		}

		private bool Target_ColliderGhostState(Collider obj)
		{
			return blockingColliderList.IndexOf(obj) switch
			{
				0 => Jisu.Utils.Singleton<RemotePlayerData>.Instance.LeftHandGhostState.CurrentData, 
				1 => Jisu.Utils.Singleton<RemotePlayerData>.Instance.RightHandGhostState.CurrentData, 
				_ => false, 
			};
		}

		private bool isBlockingCollider(Collider obj)
		{
			return blockingColliderList.Contains(obj);
		}

		private void RemotePlayerDown_OnDataChanged(bool isDown)
		{
			if (!isDown)
			{
				return;
			}
			isKO = isKO || Jisu.Utils.Singleton<RemotePlayerData>.Instance.MainHP.CurrentData <= 0;
			if (!isAnimatorIdle)
			{
				if (isKO)
				{
					animator.SetTrigger("KO");
				}
				return;
			}
			Vector3 vector = animator.transform.InverseTransformDirection(LastHitDirection).normalized;
			Vector3 vector2 = animator.transform.right;
			float value = Vector2.Dot(Jisu.Utils.VectorExtension.ToXZ(in vector2), Jisu.Utils.VectorExtension.ToXZ(in vector));
			(float, float) input = (-1f, 1f);
			(float, float) output = (0f, 1f);
			float value2 = Mathf.Round(Jisu.Utils.VectorExtension.Remap(value, in input, in output) * 2f) * 0.5f;
			if (isKO)
			{
				value2 = 0.5f;
			}
			animator.SetBool("IsKO", isKO);
			animator.SetFloat("DownBlend", value2);
			animator.SetTrigger("PAQ_Down");
			eyeAnimationCtrl.SetExpression(4, 10f);
		}

		public void StopDownAnimation()
		{
			animator.SetTrigger("Interrupt");
		}

		private void Detection_OnHit(HitInfo info)
		{
			if (LocalSingleton<MultiGameManager>.Instance.isPause.CurrentData || Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData || info.controller.BlockedBy.CurrentData != 0 || ReadyTime > Time.time || !isAnimatorIdle || info.isTunnelingBlocked)
			{
				return;
			}
			if (blockingColliderList.Contains(info.bodyCollider))
			{
				EffectManager instance = LocalSingleton<EffectManager>.Instance;
				string key = "hit_guard";
				Vector3 position = info.controllerCollider.transform.position;
				ref Vector3 velocity = ref info.velocity;
				float magnitude = 1f;
				instance.RunOneShot(in key, in position, in velocity, in magnitude);
				hitReaction.Hit(info.bodyCollider, info.velocity * 4f, info.controllerCollider.transform.position - info.penetrationOffset);
				info.controller.Controller.SetHapticImpulse(info.velocity.magnitude * 0.3f, 0.1f);
				return;
			}
			Vector3 vector = info.bodyCollider.transform.position - info.controllerCollider.transform.position;
			int num = Mathf.CeilToInt(info.velocity.magnitude * 15f);
			float num2 = Mathf.Clamp(Vector3.Dot(vector.normalized, info.velocity.normalized), 0.5f, 1f) * 2f;
			Vector3.Dot(vector.normalized, info.velocity.normalized);
			bool currentData = info.controller.FireHandState.CurrentData;
			DamagePacket attack = new DamagePacket
			{
				position = info.position,
				direction = vector.normalized,
				velocity = info.velocity.normalized,
				magnitude = info.velocity.magnitude,
				hitFactor = num2,
				fireHand = (currentData ? 1 : 0),
				damage = Mathf.CeilToInt((float)num * num2) * ((!currentData) ? 1 : 5)
			};
			if (currentData || attack.damage <= 1000)
			{
				hitReaction.Hit(info.bodyCollider, info.velocity * 0.083f, info.controllerCollider.transform.position - info.penetrationOffset);
				string key2 = ((attack.fireHand == 1) ? "hit_fire" : "hit_attack");
				EffectManager instance2 = LocalSingleton<EffectManager>.Instance;
				Vector3 position = info.position - attack.direction * 0.1f;
				ref Vector3 velocity2 = ref info.velocity;
				float magnitude = Mathf.Clamp01(info.velocity.magnitude);
				instance2.RunOneShot(in key2, in position, in velocity2, in magnitude);
				if (attack.fireHand == 1)
				{
					fireDamageParticle.Play();
				}
				eyeAnimationCtrl.SetExpression(4, 0.5f);
				LocalSingleton<MultiGameManager>.Instance.UpdateAttackInfo(in attack);
				PhotonManager.SendDamageData(in attack);
				float num3 = 0f;
				if (MultiGameManager.TryGetRecoveryHP(out var value))
				{
					num3 = (float)value * (PhotonManager.RoundTripTime * 0.001f * 3f);
				}
				if (Jisu.Utils.Singleton<RemotePlayerData>.Instance.MainHP.CurrentData - attack.damage <= 0)
				{
					isKO = true;
					RemotePlayerDown_OnDataChanged(isDown: true);
					PlayerKOPacket data = new PlayerKOPacket
					{
						Local = false,
						Remote = true
					};
					PhotonManager.SendPlayerKOData(in data);
				}
				else if ((float)Jisu.Utils.Singleton<RemotePlayerData>.Instance.TempHP.CurrentData + num3 - (float)attack.damage <= 0f)
				{
					RemotePlayerDown_OnDataChanged(isDown: true);
					PlayerDownPacket data2 = new PlayerDownPacket
					{
						Local = false,
						Remote = true
					};
					PhotonManager.SendPlayerDownData(in data2);
				}
				else
				{
					XRRigControl instance3 = LocalSingleton<XRRigControl>.Instance;
					magnitude = (float)attack.damage * 0.0025f;
					instance3.TryAutoMoveRig(in magnitude, 0.5f);
				}
				info.controller.Controller.SetHapticImpulse(info.velocity.magnitude * 0.3f, 0.1f);
				LastHitDirection = info.bodyCollider.transform.position - info.controllerCollider.transform.position;
			}
		}

		private void OnEnable()
		{
			IKSolverVR solver = hitReaction.ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}

		private void OnUpdate()
		{
			foreach (Detection detectionTarget in detectionTargets)
			{
				float inverseAttackDelay = 2.857143f;
				detectionTarget.OnUpdate(in inverseAttackDelay);
			}
		}

		private void OnDisable()
		{
			IKSolverVR solver = hitReaction.ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnUpdate));
		}

		private void OnDestroy()
		{
			if (_instance == this)
			{
				_instance = null;
			}
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.OnDataChanged -= RemotePlayerDown_OnDataChanged;
		}
	}
	public class LocalizationCtrl : MonoBehaviour
	{
		public Text howToPlay;

		public Material mat_Ring_Frame;

		public Material mat_Ring_LED;

		public Material mat_Display;

		public Material mat_LED;

		public MeshFilter[] meshFilter_round;

		private void Start()
		{
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			LanguageState languageState = PublicGameUIManager.gameSetting.GetLanguageState();
			if ((uint)(languageState - 10) <= 1u)
			{
				howToPlay.text = "如何操作";
				mat_Ring_Frame.SetTexture("_BaseMap", Resources.Load<Texture2D>("Boxing/Texture/ring_frame_chinese"));
				Texture2D value = Resources.Load<Texture2D>("Boxing/Texture/ring_LED_chinese");
				mat_Ring_LED.SetTexture("_Diffuse", value);
				mat_Ring_LED.SetTexture("_Emission", value);
				value = Resources.Load<Texture2D>("Boxing/Texture/display_chinese");
				mat_Display.SetTexture("_Diffuse", value);
				mat_Display.SetTexture("_Emission", value);
				value = Resources.Load<Texture2D>("Boxing/Texture/LED_advertise_chinese");
				mat_LED.SetTexture("_BaseMap", value);
				mat_LED.SetTexture("_EmissionMap", value);
				for (int i = 0; i < meshFilter_round.Length; i++)
				{
					meshFilter_round[i].mesh = Resources.Load<Mesh>("Boxing/Round/Round" + (i + 1) + "_chinese");
				}
			}
			else
			{
				howToPlay.text = "How To Play";
				mat_Ring_Frame.SetTexture("_BaseMap", Resources.Load<Texture2D>("Boxing/Texture/ring_frame_english"));
				Texture2D value2 = Resources.Load<Texture2D>("Boxing/Texture/ring_LED_english");
				mat_Ring_LED.SetTexture("_Diffuse", value2);
				mat_Ring_LED.SetTexture("_Emission", value2);
				value2 = Resources.Load<Texture2D>("Boxing/Texture/display_english");
				mat_Display.SetTexture("_Diffuse", value2);
				mat_Display.SetTexture("_Emission", value2);
				value2 = Resources.Load<Texture2D>("Boxing/Texture/LED_advertise_english");
				mat_LED.SetTexture("_BaseMap", value2);
				mat_LED.SetTexture("_EmissionMap", value2);
				for (int j = 0; j < meshFilter_round.Length; j++)
				{
					meshFilter_round[j].mesh = Resources.Load<Mesh>("Boxing/Round/Round" + (j + 1) + "_english");
				}
			}
		}
	}
	public class MultiGameManager : LocalSingleton<MultiGameManager>
	{
		[SerializeField]
		private XRRig xrrig;

		[SerializeField]
		private Transform PlayXRRigMarker;

		[SerializeField]
		private Transform RestXRRigMarker;

		private Vector3 defaultXRRigPosition;

		[SerializeField]
		private MultiplayerCharacterSetter characterSetter;

		[SerializeField]
		private HitCollisionManager hitCollisionManager;

		[SerializeField]
		private HowToPlay helper;

		[SerializeField]
		private BreakTimeCtrl breakTimeCtrl;

		[SerializeField]
		private AnimationCurve HitFactorMultiplier;

		[SerializeField]
		private ParticleSystem fireDamageParticle;

		[Header("Recovery")]
		[SerializeField]
		private float staminaRecoveryPerSecond;

		[SerializeField]
		private float tempHPRecoveryPerSecond;

		[SerializeField]
		private float mainHPRecoveryPerRound;

		[Header("Round")]
		[SerializeField]
		private float RoundTime;

		private float currentRoundTime;

		[SerializeField]
		private TextMesh roundTimeText;

		public readonly Jisu.Utils.Notifier<bool> isLocalReady = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> isRemoteReady = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> isPause = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> isEnd = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> isKOEnding = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> isWinner = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> ConnectionNotifier = new Jisu.Utils.Notifier<bool>();

		[Header("Debug")]
		public float debug_UpdateTime = 0.5f;

		public float debug_Use_VelocityPerSecond;

		[Header("Debug - HP")]
		public int show_MainHP;

		public int show_TempHP;

		public bool SetHP;

		public int Set_MainHP;

		public int Set_TempHP;

		public int RoundCount;

		public int JudgeScore;

		public int LocalPlayerScore;

		public int RemotePlayerScore;

		private int DownCount;

		private float DownHPRate;

		private CoroutineWrapper DownCountWrapper;

		private CoroutineWrapper AwakeUpWrapper;

		private CoroutineWrapper BreakTimeWrapper;

		private float updateTime;

		public ControllerData LeftController { get; private set; }

		public ControllerData RightController { get; private set; }

		public event Action OnRoundChangeStarted;

		public event Action OnRoundChangeEnded;

		public event Action OnDisplaceRig;

		public event Action OnGameComplete;

		public event Action<float, Action> OnFadeInOut;

		public event Action<AwakePacket> OnAwakeReceive;

		protected override void Awake()
		{
			base.Awake();
			Initialize();
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.MainHP.OnDataChanged += RemotePlayer_MainHP_OnDataChanged;
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.OnDataChanged += RemotePlayer_IsDown_OnDataChanged;
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnReadyStateMessageReceive += Instance_OnReadyStateMessageReceive;
				instance.OnDamageMessageReceive += Instance_OnDamageMessageReceive;
				instance.OnIgnoreDamageMessageReceive += Instance_OnIgnoreDamageMessageReceive;
				instance.OnRoundChangeMessageReceive += Instance_OnRoundChangeMessageReceive;
				instance.OnPauseMessageReceive += Instance_OnPauseMessageReceive;
				instance.OnAwakeMessageReceive += Instance_OnAwakeMessageReceive;
				instance.OnDisplaceStartMessageReceive += Instance_OnDisplaceStartMessageReceive;
				instance.OnPlayerDownMessageRecieve += Instance_OnPlayerDownMessageReceive;
				instance.OnPlayerKOMessageRecieve += Instance_OnPlayerKOMessageReceive;
				SendStatusData();
			};
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged += LocalPlayer_IsDown_OnDataChanged;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.OnDataChangedDelta += LocalPlayer_HP_OnDataChangedDelta;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.OnDataChangedDelta += LocalPlayer_TempHP_OnDataChangedDelta;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.OnDataChanged += LocalPlayer_FireHandCount_OnDataChanged;
			ConnectionNotifier.OnDataChanged += ConnectionNotifier_OnDataChanged;
			isLocalReady.OnDataChanged += IsLocalReady_OnDataChange;
			OnGameComplete += MultiGameManager_OnGameComplete;
			roundTimeText.gameObject.SetActive(value: false);
		}

		private void Instance_OnAwakeMessageReceive(AwakePacket obj)
		{
			this.OnAwakeReceive?.Invoke(obj);
		}

		private void Instance_OnDisplaceStartMessageReceive(DisplaceStartPacket obj)
		{
			AwakeUpWrapper.StartSingleton(OnAwakeSequence_Coroutine());
			IEnumerator OnAwakeSequence_Coroutine()
			{
				LocalSingleton<CamEffectCtrl>.Instance.FadeOut();
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				xrrig.transform.position = PlayXRRigMarker.position;
				this.OnDisplaceRig?.Invoke();
				isLocalReady.CurrentData = true;
			}
		}

		private void MultiGameManager_OnGameComplete()
		{
			LocalSingleton<XRRigControl>.Instance.ForceMoveRig(RestXRRigMarker.transform.position);
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData = false;
			Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
			hitCollisionManager.StopDownAnimation();
		}

		public void Initialize()
		{
			isLocalReady.CurrentData = false;
			isRemoteReady.CurrentData = false;
			isEnd.CurrentData = false;
			isPause.CurrentData = true;
			currentRoundTime = 0f;
			JudgeScore = 0;
			LocalPlayerScore = 0;
			RemotePlayerScore = 0;
			DownCount = 0;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.Initialize();
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.Initialize();
			DownCountWrapper = new CoroutineWrapper(this);
			AwakeUpWrapper = new CoroutineWrapper(this);
			BreakTimeWrapper = new CoroutineWrapper(this);
			defaultXRRigPosition = xrrig.transform.position;
			StartCoroutine(CheckReady_Coroutine(isGameStart: true));
		}

		private IEnumerator CheckReady_Coroutine(bool isGameStart)
		{
			while (!isLocalReady.CurrentData || !isRemoteReady.CurrentData)
			{
				yield return YieldInstructionCache.WaitForSeconds(0.1f);
			}
			if (isGameStart)
			{
				StartCoroutine(StartGameSequence_Coroutine());
			}
			else
			{
				StartCoroutine(StartRoundSequence_Coroutine());
			}
			IEnumerator StartGameSequence_Coroutine()
			{
				yield return YieldInstructionCache.WaitForSeconds(1f);
				LocalSingleton<CamEffectCtrl>.Instance.FadeIn();
				yield return YieldInstructionCache.WaitForSeconds(5f);
				LocalSingleton<BoxerUICtrl>.Instance.StartRoundUI(RoundCount);
				yield return YieldInstructionCache.WaitForSeconds(2f);
				helper.SetWindow(isSet: false);
				SoundManager.ClipType type2 = SoundManager.ClipType.RoundStart;
				float volume3 = 1f;
				SoundManager.Run(in type2, in volume3);
				volume3 = 0.5f;
				type2 = SoundManager.ClipType.Fight;
				float volume4 = 1f;
				SoundManager.Run(in volume3, in type2, in volume4);
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = true;
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.StartTime.CurrentData = Time.time;
				isPause.CurrentData = false;
			}
			IEnumerator StartRoundSequence_Coroutine()
			{
				yield return YieldInstructionCache.WaitForSeconds(1f);
				LocalSingleton<CamEffectCtrl>.Instance.FadeIn();
				yield return YieldInstructionCache.WaitForSeconds(1.5f);
				SoundManager.ClipType type = SoundManager.ClipType.RoundStart;
				float volume = 1f;
				SoundManager.Run(in type, in volume);
				volume = 0.5f;
				type = SoundManager.ClipType.Fight;
				float volume2 = 1f;
				SoundManager.Run(in volume, in type, in volume2);
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = true;
				isPause.CurrentData = false;
			}
		}

		public void RegistController(in ControllerData controller)
		{
			switch (controller.Type)
			{
			case ControllerData.ControllerType.Left:
				LeftController = controller;
				break;
			case ControllerData.ControllerType.Right:
				RightController = controller;
				break;
			}
		}

		private void IsLocalReady_OnDataChange(bool isReady)
		{
			if (isReady)
			{
				StartCoroutine(SendReady_Coroutine());
			}
			static IEnumerator SendReady_Coroutine()
			{
				int count = 0;
				while (count <= 100)
				{
					count++;
					ReadyStatePacket data = new ReadyStatePacket();
					PhotonManager.SendReadyStateData(in data);
					yield return YieldInstructionCache.WaitForSeconds(0.1f);
				}
			}
		}

		private void Instance_OnReadyStateMessageReceive(ReadyStatePacket obj)
		{
			isRemoteReady.CurrentData = true;
		}

		private void ConnectionNotifier_OnDataChanged(bool isValid)
		{
			if (isValid)
			{
				RoundCount = 1;
				characterSetter.Initialize(PhotonManager.isMasterClient);
				MoveWithFade(0.25f, RestXRRigMarker.position);
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
				isLocalReady.CurrentData = true;
			}
			else
			{
				FinishGame(PhotonManager.isConnected && PhotonNetwork.InRoom, isKO: false);
			}
		}

		private void LocalPlayer_IsDown_OnDataChanged(bool isDown)
		{
			if (isDown)
			{
				isPause.CurrentData = true;
				isLocalReady.CurrentData = false;
				isRemoteReady.CurrentData = false;
				if (LeftController.FireHandState.CurrentData)
				{
					Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.CurrentData++;
					LeftController.CancelFireHand();
				}
				if (RightController.FireHandState.CurrentData)
				{
					Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.CurrentData++;
					RightController.CancelFireHand();
				}
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
				if (LocalSingleton<SpectatorSoundCtrl>.Instance != null)
				{
					SpectatorSoundCtrl.PlaySound(isCheer: false);
				}
				LocalSingleton<CamEffectCtrl>.Instance.StartDownEffect();
				CountDownCaller.Call(10);
				if (Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData > 0)
				{
					DownCountWrapper.StartSingleton(waitAndReset());
					StartCoroutine(CheckReady_Coroutine(isGameStart: false));
				}
			}
			else
			{
				CountDownCaller.Cancel();
			}
			SendStatusData();
			IEnumerator waitAndReset()
			{
				float time = Mathf.Lerp(3f, 10f, DownHPRate = 1f - (float)Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData / 3000f) * UnityEngine.Random.Range(0.9f, 1.1f);
				float preTime = Mathf.Max(time - 3f, 0.5f);
				yield return YieldInstructionCache.WaitForSeconds(preTime);
				AwakePacket data = new AwakePacket();
				PhotonManager.SendAwakeData(in data);
				LocalSingleton<CamEffectCtrl>.Instance.StartWakeUpEffect();
				yield return YieldInstructionCache.WaitForSeconds(time - preTime);
				LocalSingleton<CamEffectCtrl>.Instance.FadeOut();
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData = false;
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
				DisplaceStartPacket data2 = new DisplaceStartPacket();
				PhotonManager.SendDisplaceStartData(in data2);
				yield return YieldInstructionCache.WaitForSeconds(1f);
				xrrig.transform.position = PlayXRRigMarker.position;
				this.OnDisplaceRig?.Invoke();
				isLocalReady.CurrentData = true;
			}
		}

		private void LocalPlayer_TempHP_OnDataChangedDelta(int prev, int next)
		{
			if (next - prev < 0 && next <= 0 && prev > 0)
			{
				DownCount++;
				if (DownCount > 2)
				{
					Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData = 0;
				}
				else
				{
					Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData = true;
				}
			}
			SendStatusData();
		}

		private void LocalPlayer_HP_OnDataChangedDelta(int prev, int next)
		{
			if (next - prev < 0 && next <= 0 && prev > 0)
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData = true;
			}
			if (next <= 0)
			{
				LocalSingleton<CamEffectCtrl>.Instance.StartKOEffect();
				FinishGame(isWin: false);
			}
			SendStatusData();
		}

		private void Instance_OnPauseMessageReceive(PausePacket obj)
		{
			isPause.CurrentData = obj.isPaused;
		}

		private void Instance_OnDamageMessageReceive(DamagePacket obj)
		{
			if (Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvincibilityEndTime > Time.time)
			{
				PhotonManager.SendIgnoreDamageData(in obj);
				return;
			}
			bool num = obj.fireHand == 1;
			if (num)
			{
				LocalSingleton<CamEffectCtrl>.Instance.StartFireDamageEffect();
			}
			else
			{
				LocalSingleton<CamEffectCtrl>.Instance.StartDamageEffect();
			}
			JudgeScore--;
			RemotePlayerScore++;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.AddClampedValue(-obj.damage, 0, 3000);
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.AddClampedValue(-obj.damage, 0, 1000);
			Vector3 vector = -obj.position;
			Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
			Vector3 position = Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector, obj.position.y) + xrrig.cameraGameObject.transform.forward * 0.1f;
			string key = (num ? "hit_fire" : "hit_attack");
			EffectManager instance = LocalSingleton<EffectManager>.Instance;
			vector = -obj.direction;
			instance.RunOneShot(in key, in position, in vector, in obj.magnitude);
			if (num)
			{
				fireDamageParticle.Play();
			}
			if (Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvaildAttackTime > Time.time)
			{
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.ContinuousHitCount += 1f;
			}
			else
			{
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.ContinuousHitCount = 0f;
			}
			AnimationCurve hitFactorMultiplier = HitFactorMultiplier;
			float hitFactor = obj.hitFactor;
			(float, float) input = (1f, 2f);
			(float, float) output = (0f, 1f);
			float num2 = hitFactorMultiplier.Evaluate(Jisu.Utils.VectorExtension.Remap(hitFactor, in input, in output));
			float value = Mathf.Clamp((float)obj.damage / obj.hitFactor, 40f, 160f);
			input = (40f, 160f);
			output = (0.5f, 1f);
			float num3 = (float)Mathf.CeilToInt(Jisu.Utils.VectorExtension.Remap(value, in input, in output) * 10f) * 0.1f;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvaildAttackTime = Time.time + Jisu.Utils.Singleton<MultiplayerSetting>.Instance.CurrentHitDelay * num2 * num3;
			XRRigControl instance2 = LocalSingleton<XRRigControl>.Instance;
			float magnitude = (float)(-obj.damage) * 0.0025f;
			instance2.TryMoveRig(in magnitude);
		}

		private void Instance_OnIgnoreDamageMessageReceive(DamagePacket obj)
		{
			JudgeScore--;
			LocalPlayerScore--;
			hitCollisionManager.StopDownAnimation();
		}

		private void RemotePlayer_IsDown_OnDataChanged(bool isDown)
		{
			if (!isEnd.CurrentData)
			{
				if (LocalSingleton<SpectatorSoundCtrl>.Instance != null)
				{
					SpectatorSoundCtrl.PlaySound(isCheer: true);
				}
				if (isDown)
				{
					isPause.CurrentData = true;
					isLocalReady.CurrentData = false;
					isRemoteReady.CurrentData = false;
					CountDownCaller.Call(10);
					XRRigControl instance = LocalSingleton<XRRigControl>.Instance;
					float magnitude = -1.5f;
					instance.TryMoveRig(in magnitude);
					Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
					StartCoroutine(CheckReady_Coroutine(isGameStart: false));
				}
				else
				{
					CountDownCaller.Cancel();
					Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = true;
				}
			}
		}

		private void RemotePlayer_MainHP_OnDataChanged(int currentHP)
		{
			if (currentHP <= 0)
			{
				FinishGame(isWin: true);
			}
		}

		private void LocalPlayer_FireHandCount_OnDataChanged(int count)
		{
			SendStatusData();
		}

		private void FinishGame(bool isWin, bool isKO = true)
		{
			if (!isEnd.CurrentData)
			{
				CountDownCaller.Cancel();
				DownCountWrapper.Stop();
				BreakTimeWrapper.Stop();
				isKOEnding.CurrentData = isKO;
				isWinner.CurrentData = isWin;
				isEnd.CurrentData = true;
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
				StartCoroutine(FinishGame_Coroutine());
			}
			IEnumerator FinishGame_Coroutine()
			{
				if (!isKOEnding.CurrentData)
				{
					float delay = 0.5f;
					SoundManager.ClipType type = SoundManager.ClipType.KO_Bell;
					float volume = 1f;
					SoundManager.Run(in delay, in type, in volume);
					this.OnGameComplete?.Invoke();
					yield return YieldInstructionCache.WaitForSeconds(1f);
				}
				else
				{
					int num = UnityEngine.Random.Range(5, 7);
					CountDownCaller.Call(num, delegate
					{
						float delay2 = 0.2f;
						SoundManager.ClipType type2 = SoundManager.ClipType.KO_Voice;
						float volume2 = 1f;
						SoundManager.Run(in delay2, in type2, in volume2);
						delay2 = 1f;
						type2 = SoundManager.ClipType.KO_Bell;
						volume2 = 1f;
						SoundManager.Run(in delay2, in type2, in volume2);
						this.OnGameComplete?.Invoke();
					});
					yield return YieldInstructionCache.WaitForSeconds((float)num + 1f);
				}
				LocalSingleton<CamEffectCtrl>.Instance.FadeOut();
				yield return YieldInstructionCache.WaitForSeconds(1f);
				Vector3 vector = RestXRRigMarker.transform.position - xrrig.transform.position;
				float magnitude = Vector3.Dot(xrrig.transform.forward, vector.normalized) * vector.magnitude;
				LocalSingleton<XRRigControl>.Instance.TryMoveRig(in magnitude);
				yield return YieldInstructionCache.WaitForSeconds(2f);
				LocalSingleton<CamEffectCtrl>.Instance.FadeIn();
				yield return YieldInstructionCache.WaitForSeconds(0.25f);
				string nickName = PhotonNetwork.LocalPlayer.NickName;
				int num2 = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Select((UserInfoManager.UserInfo info) => info.nick).ToList().IndexOf(nickName);
				if (!ConnectionNotifier.CurrentData)
				{
					PublicGameUIManager.GetInstance.OpenResultBoard("", num2);
				}
				else
				{
					string[] array = new string[2];
					array[num2] = LocalPlayerScore.ToString();
					array[(num2 == 0) ? 1u : 0u] = RemotePlayerScore.ToString();
					PublicGameUIManager.GetInstance.OpenResultBoard(array.ToArray(), isWin ? num2 : ((num2 == 0) ? 1 : 0));
				}
			}
		}

		public void UpdateAttackInfo(in DamagePacket attack)
		{
			JudgeScore++;
			LocalPlayerScore++;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvincibilityEndTime = Time.time + 0.1f;
		}

		private void SendStatusData()
		{
			StatusPacket data = new StatusPacket
			{
				CurrentHP = Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData,
				CurrentTempHP = Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.CurrentData,
				isDown = (Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData ? 1 : 0),
				ItemCount = Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.CurrentData
			};
			PhotonManager.SendStatusData(in data);
		}

		private void MoveWithFade(float delay, Vector3 position)
		{
			Guid.NewGuid();
			this.OnFadeInOut?.Invoke(delay, OnHide);
			void OnHide()
			{
				xrrig.transform.position = position;
			}
		}

		private void Update()
		{
			if (isEnd.CurrentData)
			{
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
			}
			ConnectionNotifier.CurrentData = PhotonManager.isValid;
			if (PhotonManager.isMasterClient && PhotonManager.isValid)
			{
				UpdateRound();
			}
			show_MainHP = Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData;
			show_TempHP = Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.CurrentData;
			if (SetHP)
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData = Set_MainHP;
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.CurrentData = Set_TempHP;
				SetHP = false;
			}
			int num = 0;
			if (LeftController != null && LeftController.Controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value))
			{
				num += -Mathf.RoundToInt(value.magnitude * 10f);
				debug_Use_VelocityPerSecond += value.magnitude;
			}
			if (RightController != null && RightController.Controller.inputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value2))
			{
				num += -Mathf.RoundToInt(value2.magnitude * 10f);
				debug_Use_VelocityPerSecond += value2.magnitude;
			}
			updateTime += Time.deltaTime;
			if (updateTime > 0.25f)
			{
				updateTime -= 0.25f;
				float num2 = Mathf.Lerp(3f, 10f, DownHPRate);
				float num3 = 1f;
				if (Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData)
				{
					num3 = 10f / num2 * 3f;
				}
				else if (Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.CurrentData)
				{
					num3 = 10f;
				}
				if (Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData > 0)
				{
					Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.AddClampedValue(Mathf.CeilToInt(tempHPRecoveryPerSecond * 0.25f * num3), 0, 1000);
				}
			}
		}

		private void UpdateRound()
		{
			if (!isPause.CurrentData && !isEnd.CurrentData && !Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData && !Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.CurrentData)
			{
				currentRoundTime += Time.deltaTime;
				if (currentRoundTime > RoundTime)
				{
					RoundChangePacket data = new RoundChangePacket();
					PhotonManager.SendRoundChangeData(in data);
				}
			}
		}

		private void Instance_OnRoundChangeMessageReceive(RoundChangePacket obj)
		{
			if (isEnd.CurrentData)
			{
				return;
			}
			currentRoundTime = 0f;
			DownCount = 0;
			if (LeftController.FireHandState.CurrentData)
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.CurrentData++;
				LeftController.CancelFireHand();
			}
			if (RightController.FireHandState.CurrentData)
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.CurrentData++;
				RightController.CancelFireHand();
			}
			CountDownCaller.Cancel();
			RoundCount++;
			if (RoundCount > 3)
			{
				bool isWin = JudgeScore > 0;
				if (JudgeScore == 0)
				{
					isWin = PhotonManager.isMasterClient;
				}
				FinishGame(isWin, isKO: false);
			}
			else
			{
				StartCoroutine(BreakTimeSequence_Coroutine());
			}
			IEnumerator BreakTimeSequence_Coroutine()
			{
				isPause.CurrentData = true;
				SoundManager.ClipType type = SoundManager.ClipType.RoundEnd;
				float volume = 1f;
				SoundManager.Run(in type, in volume);
				LocalSingleton<CamEffectCtrl>.Instance.FadeOut();
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = false;
				yield return YieldInstructionCache.WaitForSeconds(0.5f);
				this.OnRoundChangeStarted?.Invoke();
				LocalSingleton<CamEffectCtrl>.Instance.FadeIn();
				xrrig.transform.position = RestXRRigMarker.position;
				breakTimeCtrl.PlayCoachAnim(RoundCount);
				yield return YieldInstructionCache.WaitForSeconds(10f);
				LocalSingleton<CamEffectCtrl>.Instance.FadeOut();
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.AddClampedValue(Mathf.CeilToInt(mainHPRecoveryPerRound), 0, 3000);
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.AddClampedValue(1000, 0, 1000);
				yield return YieldInstructionCache.WaitForSeconds(0.75f);
				breakTimeCtrl.StopCoachAnim();
				xrrig.transform.position = PlayXRRigMarker.position;
				yield return YieldInstructionCache.WaitForSeconds(0.75f);
				LocalSingleton<CamEffectCtrl>.Instance.FadeIn();
				this.OnRoundChangeEnded?.Invoke();
				LocalSingleton<BoxerUICtrl>.Instance.StartRoundUI(RoundCount);
				yield return YieldInstructionCache.WaitForSeconds(2f);
				type = SoundManager.ClipType.RoundStart;
				volume = 1f;
				SoundManager.Run(in type, in volume);
				volume = 0.5f;
				type = SoundManager.ClipType.Fight;
				float volume2 = 1f;
				SoundManager.Run(in volume, in type, in volume2);
				Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData = true;
				isPause.CurrentData = false;
			}
		}

		private void Instance_OnPlayerDownMessageReceive(PlayerDownPacket obj)
		{
			if (obj.Remote != Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData)
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.CurrentData = 0;
			}
		}

		private void Instance_OnPlayerKOMessageReceive(PlayerKOPacket obj)
		{
			if (obj.Remote != isKOEnding.CurrentData)
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.CurrentData = 0;
			}
		}

		protected override void OnDestroy()
		{
			base.OnDestroy();
			ConnectionNotifier.OnDataChanged -= ConnectionNotifier_OnDataChanged;
			isLocalReady.OnDataChanged -= IsLocalReady_OnDataChange;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.FireHandCount.OnDataChanged -= LocalPlayer_FireHandCount_OnDataChanged;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.TempHP.OnDataChangedDelta -= LocalPlayer_TempHP_OnDataChangedDelta;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.MainHP.OnDataChangedDelta -= LocalPlayer_HP_OnDataChangedDelta;
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged -= LocalPlayer_IsDown_OnDataChanged;
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnReadyStateMessageReceive -= Instance_OnReadyStateMessageReceive;
				instance.OnAwakeMessageReceive -= Instance_OnAwakeMessageReceive;
				instance.OnPauseMessageReceive -= Instance_OnPauseMessageReceive;
				instance.OnRoundChangeMessageReceive -= Instance_OnRoundChangeMessageReceive;
				instance.OnIgnoreDamageMessageReceive -= Instance_OnIgnoreDamageMessageReceive;
				instance.OnDamageMessageReceive -= Instance_OnDamageMessageReceive;
				instance.OnDisplaceStartMessageReceive -= Instance_OnDisplaceStartMessageReceive;
				instance.OnPlayerDownMessageRecieve -= Instance_OnPlayerDownMessageReceive;
				instance.OnPlayerKOMessageRecieve -= Instance_OnPlayerKOMessageReceive;
			};
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.OnDataChanged -= RemotePlayer_IsDown_OnDataChanged;
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.MainHP.OnDataChanged -= RemotePlayer_MainHP_OnDataChanged;
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.Dispose();
		}

		public static bool TryGetRecoveryHP(out int value)
		{
			if (!LocalSingleton<MultiGameManager>.TryGetInstance(out var instance))
			{
				value = 0;
				return false;
			}
			value = Mathf.CeilToInt(instance.tempHPRecoveryPerSecond);
			return true;
		}
	}
	public class MultiplayerCharacterSetter : MonoBehaviour
	{
		[SerializeField]
		private bool IsMobile;

		[SerializeField]
		private Color redColor;

		[SerializeField]
		private Color blueColor;

		[Header("CustomModelSetting")]
		[SerializeField]
		private CustomModelSettingCtrl RemotePlayerCustomModel;

		[Header("Mobile Only - SkinnedMesh")]
		[SerializeField]
		private SkinnedMeshRenderer LocalPlayerGlove;

		[SerializeField]
		private SkinnedMeshRenderer RemotePlayerGlove;

		[SerializeField]
		private SkinnedMeshRenderer RemotePlayerGlove_Animation;

		[SerializeField]
		private Material RedGlovemat;

		[SerializeField]
		private Material BlueGlovemat;

		[Header("Materials")]
		[SerializeField]
		private Material localPlayerGloveMaterial;

		[SerializeField]
		private Material remotePlayerGloveMaterial;

		[SerializeField]
		private Material PantsMaterial;

		[Header("UI")]
		[SerializeField]
		private Shadow localPlayerNameShadow;

		[SerializeField]
		private Shadow remotePlayerNameShadow;

		[SerializeField]
		private GameObject localPlayerCover;

		[SerializeField]
		private GameObject remotePlayerCover;

		private static readonly string BASE_COLOR_PROPERTY = "_BaseColor";

		private static readonly string COLOR_LR_PROPERTY = "_Color_LR";

		public void Initialize(bool isMasterClient)
		{
			RemotePlayerCustomModel.Init(SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[PhotonManager.isMasterClient ? 1 : 0].id, CustomModelViewState.HalfCut2, null, 0f);
			if (IsMobile)
			{
				MobileOverrideInitialize(in isMasterClient);
			}
			else if (isMasterClient)
			{
				localPlayerGloveMaterial.SetColor(BASE_COLOR_PROPERTY, redColor);
				localPlayerGloveMaterial.SetColor(COLOR_LR_PROPERTY, redColor);
				localPlayerNameShadow.effectColor = redColor;
				localPlayerCover.SetActive(value: false);
				remotePlayerGloveMaterial.SetColor(BASE_COLOR_PROPERTY, blueColor);
				remotePlayerGloveMaterial.SetColor(COLOR_LR_PROPERTY, blueColor);
				PantsMaterial.SetColor(BASE_COLOR_PROPERTY, blueColor);
				remotePlayerNameShadow.effectColor = blueColor;
				remotePlayerCover.SetActive(value: true);
			}
			else
			{
				localPlayerGloveMaterial.SetColor(BASE_COLOR_PROPERTY, blueColor);
				localPlayerGloveMaterial.SetColor(COLOR_LR_PROPERTY, blueColor);
				localPlayerNameShadow.effectColor = blueColor;
				localPlayerCover.SetActive(value: true);
				remotePlayerGloveMaterial.SetColor(BASE_COLOR_PROPERTY, redColor);
				remotePlayerGloveMaterial.SetColor(COLOR_LR_PROPERTY, redColor);
				PantsMaterial.SetColor(BASE_COLOR_PROPERTY, redColor);
				remotePlayerNameShadow.effectColor = redColor;
				remotePlayerCover.SetActive(value: false);
			}
		}

		private void MobileOverrideInitialize(in bool isMasterClient)
		{
			if (isMasterClient)
			{
				LocalPlayerGlove.sharedMaterial = RedGlovemat;
				localPlayerNameShadow.effectColor = redColor;
				localPlayerCover.SetActive(value: false);
				RemotePlayerGlove.sharedMaterial = BlueGlovemat;
				RemotePlayerGlove_Animation.sharedMaterial = BlueGlovemat;
				PantsMaterial.SetColor(BASE_COLOR_PROPERTY, blueColor);
				remotePlayerNameShadow.effectColor = blueColor;
				remotePlayerCover.SetActive(value: true);
			}
			else
			{
				LocalPlayerGlove.sharedMaterial = BlueGlovemat;
				localPlayerNameShadow.effectColor = blueColor;
				localPlayerCover.SetActive(value: true);
				RemotePlayerGlove.sharedMaterial = RedGlovemat;
				RemotePlayerGlove_Animation.sharedMaterial = RedGlovemat;
				PantsMaterial.SetColor(BASE_COLOR_PROPERTY, redColor);
				remotePlayerNameShadow.effectColor = redColor;
				remotePlayerCover.SetActive(value: false);
			}
		}
	}
	public class MultiplayerSetting : Jisu.Utils.Singleton<MultiplayerSetting>
	{
		public readonly Jisu.Utils.Notifier<float> HeadOffset = new Jisu.Utils.Notifier<float>();

		public readonly Jisu.Utils.Notifier<float> ArmDistance = new Jisu.Utils.Notifier<float>();

		public const float ReferenceArmDistance = 0.5707f;

		public const float ReferenceHeight = 1.636f;

		public const float ReferenceIKHeightOffset = -0.122f;

		public const float ReferenceHitMoveRate = 0.0025f;

		public const float ReferenceAttackMoveRate = 0.0025f;

		public readonly Jisu.Utils.Notifier<bool> IsOculusController = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<float> CurrentHitStunTime = new Jisu.Utils.Notifier<float>();

		public const float HitDetectionDirectionThreshold = 0.2f;

		public const float TunnelingDistanceThreshold = 0.1f;

		public const float AttackDelay = 0.35f;

		public const float HitDelay = 0.35f;

		public const float RoundChangeTime = 10f;

		public const int MaxRoundCount = 3;

		public readonly Jisu.Utils.Notifier<bool> AllowMovement = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<float> StartTime = new Jisu.Utils.Notifier<float>();

		public float ContinuousHitCount;

		public float GetContinuousHitRatio => 1f - 1f / (1f + ContinuousHitCount * 0.4f);

		public float CurrentHitDelay => 0.35f / (1f + ContinuousHitCount * 0.4f);
	}
	public class PlatformIKOffsetSetting : MonoBehaviour
	{
		[Serializable]
		public class Pair
		{
			public string Platform;

			public Transform OffsetTarget;
		}

		[SerializeField]
		private Transform Root;

		[SerializeField]
		private List<Pair> pairs;

		[SerializeField]
		private Dictionary<string, Transform> unpackedPairs = new Dictionary<string, Transform>();

		[SerializeField]
		private string currentTarget;

		private readonly Jisu.Utils.Notifier<int> RemotePlayerType = new Jisu.Utils.Notifier<int>();

		private void Awake()
		{
			RemotePlayerType.CurrentData = -1;
			foreach (Pair pair in pairs)
			{
				unpackedPairs[pair.Platform.ToLower()] = pair.OffsetTarget;
			}
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnTrackedPoseMessageReceive += Instance_OnTrackedPoseMessageReceive;
			};
			RemotePlayerType.OnDataChanged += RemotePlayerIsOculusController_OnDataChanged;
			RemotePlayerIsOculusController_OnDataChanged(RemotePlayerType.CurrentData);
		}

		private void Instance_OnTrackedPoseMessageReceive(TrackedPosePacket obj)
		{
			RemotePlayerType.CurrentData = obj.t;
		}

		private void RemotePlayerIsOculusController_OnDataChanged(int type)
		{
			currentTarget = "oculus";
			UnityEngine.Debug.Log("Root Hand Position is Setted Oculus");
			Root.transform.position = unpackedPairs[currentTarget].position;
		}

		private void OnDestroy()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnTrackedPoseMessageReceive -= Instance_OnTrackedPoseMessageReceive;
			};
		}
	}
	public class PlatformLocalOffsetSetting : MonoBehaviour
	{
		[Serializable]
		public class Pair
		{
			public string Platform;

			public Transform OffsetTarget;
		}

		[SerializeField]
		private Transform Root;

		[SerializeField]
		private List<Pair> pairs;

		[SerializeField]
		private Dictionary<string, Transform> unpackedPairs = new Dictionary<string, Transform>();

		[SerializeField]
		private string currentTarget;

		private void Awake()
		{
			foreach (Pair pair in pairs)
			{
				unpackedPairs[pair.Platform.ToLower()] = pair.OffsetTarget;
			}
			Jisu.Utils.Singleton<MultiplayerSetting>.Instance.IsOculusController.OnDataChanged += IsOculusController_OnDataChanged;
			IsOculusController_OnDataChanged(Jisu.Utils.Singleton<MultiplayerSetting>.Instance.IsOculusController.CurrentData);
		}

		private void IsOculusController_OnDataChanged(bool isOculus)
		{
			RemotePlayerIsOculusController_OnDataChanged(isOculus ? 1 : 0);
		}

		private void RemotePlayerIsOculusController_OnDataChanged(int type)
		{
			currentTarget = "pico";
			Root.transform.position = unpackedPairs[currentTarget].position;
			Root.transform.localRotation = unpackedPairs[currentTarget].localRotation;
		}

		private void OnDestroy()
		{
			Jisu.Utils.Singleton<MultiplayerSetting>.Instance.IsOculusController.OnDataChanged -= IsOculusController_OnDataChanged;
		}
	}
	public class HeadOffsetListener : MonoBehaviour
	{
		[SerializeField]
		private Transform Root;

		[SerializeField]
		private Transform MainCamera;

		private Jisu.Utils.Notifier<bool> OnOutOfHeight = new Jisu.Utils.Notifier<bool>();

		private CoroutineWrapper heightWrapper;

		private CoroutineWrapper timerWrapper;

		private readonly float originHeight = 1.65f;

		private readonly float minDecreaseHeight = 0.8f;

		private readonly float maxIncreaseHeight = 0.1f;

		private bool SetRigOffset;

		private float currentOffset;

		private void Awake()
		{
			heightWrapper = CoroutineWrapper.Generate(this);
			timerWrapper = CoroutineWrapper.Generate(this);
			OnOutOfHeight.OnDataChanged += OnOutOfHeight_OnDataChanged;
			heightWrapper.Start(CheckMainCameraHeigh_Coroutinet());
		}

		private IEnumerator CheckMainCameraHeigh_Coroutinet()
		{
			while (base.enabled)
			{
				if (!Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData)
				{
					if (SetRigOffset)
					{
						if (!OnOutOfHeight.CurrentData)
						{
							if (currentOffset < 0f)
							{
								if (MainCamera.position.y <= originHeight + currentOffset)
								{
									OnOutOfHeight.CurrentData = true;
								}
							}
							else if (MainCamera.position.y >= originHeight + currentOffset)
							{
								OnOutOfHeight.CurrentData = true;
							}
							if (MainCamera.position.y <= originHeight - minDecreaseHeight || MainCamera.position.y >= originHeight + maxIncreaseHeight)
							{
								SetRigOffset = false;
								OnOutOfHeight.CurrentData = true;
							}
						}
						else if (MainCamera.position.y > originHeight - currentOffset && MainCamera.position.y < originHeight + currentOffset)
						{
							OnOutOfHeight.CurrentData = false;
						}
					}
					else if (!OnOutOfHeight.CurrentData)
					{
						if (MainCamera.position.y <= originHeight - minDecreaseHeight || MainCamera.position.y >= originHeight + maxIncreaseHeight)
						{
							OnOutOfHeight.CurrentData = true;
						}
					}
					else if (MainCamera.position.y > originHeight - minDecreaseHeight && MainCamera.position.y < originHeight + maxIncreaseHeight)
					{
						OnOutOfHeight.CurrentData = false;
					}
				}
				yield return YieldInstructionCache.WaitForSeconds(0.1f);
			}
		}

		private IEnumerator OutOfHeightTimer_Coroutine()
		{
			yield return YieldInstructionCache.WaitForSeconds(2f);
			if (SetRigOffset)
			{
				SetRigOffset = false;
				currentOffset = 0f - currentOffset;
				Root.transform.position = new Vector3(Root.transform.position.x, Root.transform.position.y + currentOffset, Root.transform.position.z);
				currentOffset = 0f;
			}
			else
			{
				SetRigOffset = true;
				currentOffset = originHeight - MainCamera.position.y;
				Root.transform.position = new Vector3(Root.transform.position.x, Root.transform.position.y + currentOffset, Root.transform.position.z);
			}
			OnOutOfHeight.CurrentData = false;
		}

		private void OnOutOfHeight_OnDataChanged(bool obj)
		{
			if (obj)
			{
				timerWrapper.Start(OutOfHeightTimer_Coroutine());
			}
			else if (timerWrapper.IsPlaying)
			{
				timerWrapper.Stop();
			}
		}

		private void OnDestroy()
		{
			OnOutOfHeight.OnDataChanged -= OnOutOfHeight_OnDataChanged;
		}
	}
	public class HeadPositionChecker : MonoBehaviour
	{
		[SerializeField]
		private float Distance;

		[SerializeField]
		private Transform HeadTransform;

		private readonly Jisu.Utils.Notifier<bool> isOutOfRange = new Jisu.Utils.Notifier<bool>();

		public static event Action<bool> OnOutOfRange;

		private void Awake()
		{
			isOutOfRange.OnDataChanged += IsOutOfRange_OnDataChanged;
		}

		private void IsOutOfRange_OnDataChanged(bool obj)
		{
			HeadPositionChecker.OnOutOfRange?.Invoke(obj);
		}

		private void Update()
		{
			Jisu.Utils.Notifier<bool> notifier = isOutOfRange;
			Vector3 vector = HeadTransform.localPosition;
			notifier.CurrentData = Jisu.Utils.VectorExtension.ToXZ(in vector).magnitude > Distance;
		}
	}
	public class LineObjectControl : MonoBehaviour
	{
		[SerializeField]
		private Transform Root;

		[SerializeField]
		private BoxCollider Ring;

		[SerializeField]
		private float GroundHeight;

		[SerializeField]
		private List<LineRenderer> lines;

		private void Awake()
		{
			Root.gameObject.SetActive(value: false);
		}

		private void OnEnable()
		{
			HeadPositionChecker.OnOutOfRange += HeadPositionChecker_OnOutOfRange;
		}

		private void HeadPositionChecker_OnOutOfRange(bool isOutOfRanged)
		{
			Root.gameObject.SetActive(isOutOfRanged);
		}

		private void OnDisable()
		{
			HeadPositionChecker.OnOutOfRange -= HeadPositionChecker_OnOutOfRange;
		}
	}
	public class RenderObjectControl : MonoBehaviour
	{
		[SerializeField]
		private ForwardRendererData data;

		private ScriptableRendererFeature OverrideFeature;

		private ScriptableRendererFeature BaseFeature;

		private void Awake()
		{
			ScriptableRendererFeature scriptableRendererFeature = data.rendererFeatures.Find((ScriptableRendererFeature feature) => feature.name.ToLower().Contains("override"));
			if (scriptableRendererFeature != null)
			{
				OverrideFeature = scriptableRendererFeature;
			}
			ScriptableRendererFeature scriptableRendererFeature2 = data.rendererFeatures.Find((ScriptableRendererFeature feature) => feature.name.ToLower().Contains("base"));
			if (scriptableRendererFeature2 != null)
			{
				BaseFeature = scriptableRendererFeature2;
			}
		}

		private void OnEnable()
		{
			HeadPositionChecker.OnOutOfRange += HeadPositionChecker_OnOutOfRange;
		}

		private void HeadPositionChecker_OnOutOfRange(bool isOutOfRanged)
		{
			BaseFeature.SetActive(!isOutOfRanged);
			OverrideFeature.SetActive(isOutOfRanged);
		}

		private void OnDisable()
		{
			HeadPositionChecker.OnOutOfRange -= HeadPositionChecker_OnOutOfRange;
		}

		private void OnDestroy()
		{
			BaseFeature.SetActive(active: true);
			OverrideFeature.SetActive(active: false);
		}
	}
	public class RestrictedArea : MonoBehaviour
	{
		[SerializeField]
		private XRRig rig;

		[SerializeField]
		private Collider headCollider;

		[SerializeField]
		private List<Collider> RestrictedColliders;

		public readonly Jisu.Utils.Notifier<bool> Penetration = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<Vector3> DecompositionVector = new Jisu.Utils.Notifier<Vector3>();

		private CoroutineWrapper wrapper;

		private void Awake()
		{
			wrapper = new CoroutineWrapper(this);
			DecompositionVector.OnDataChanged += DecompositionVector_OnDataChanged;
		}

		private void DecompositionVector_OnDataChanged(Vector3 displacement)
		{
			rig.transform.Translate(displacement, Space.World);
		}

		private void OnEnable()
		{
			wrapper.StartSingleton(CheckPosition());
		}

		private IEnumerator CheckPosition()
		{
			WaitForFixedUpdate waitForFixed = YieldInstructionCache.WaitForFixedUpdate;
			MultiGameManager instance;
			yield return new WaitUntil(() => LocalSingleton<MultiGameManager>.TryGetInstance(out instance) && instance.ConnectionNotifier.CurrentData);
			yield return YieldInstructionCache.WaitForSeconds(2f);
			while (base.enabled)
			{
				yield return waitForFixed;
				if (ComputePenetration(out var dir, out var dis))
				{
					Penetration.CurrentData = true;
					DecompositionVector.CurrentData = dir * dis;
				}
				else
				{
					Penetration.CurrentData = false;
					DecompositionVector.CurrentData = Vector3.zero;
				}
			}
		}

		private bool ComputePenetration(out Vector3 dir, out float dis)
		{
			Vector3 zero = Vector3.zero;
			bool flag = false;
			dir = Vector3.zero;
			dis = 0f;
			foreach (Collider restrictedCollider in RestrictedColliders)
			{
				if (restrictedCollider.ComputePenetration(headCollider, out var dir2, out var dis2))
				{
					zero += dir2 * dis2;
					flag = true;
				}
			}
			if (flag)
			{
				dir = zero.normalized;
				dis = zero.magnitude;
			}
			return flag;
		}

		public bool ComputePenetration(in Vector3 offset, out Vector3 dir, out float dis)
		{
			Vector3 zero = Vector3.zero;
			bool flag = false;
			dir = Vector3.zero;
			dis = 0f;
			foreach (Collider restrictedCollider in RestrictedColliders)
			{
				if (restrictedCollider.ComputePenetration(headCollider, in offset, out var dir2, out var dis2))
				{
					zero += dir2 * dis2;
					flag = true;
				}
			}
			if (flag)
			{
				dir = zero.normalized;
				dis = zero.magnitude * 1.2f;
			}
			return flag;
		}

		private void OnDisable()
		{
		}
	}
	public class XRRigControl : LocalSingleton<XRRigControl>
	{
		public class MoveItem
		{
			public float magnitude;

			public float avilableTime;
		}

		[SerializeField]
		private Transform anchor;

		[SerializeField]
		private RestrictedArea restrictedArea;

		[SerializeField]
		private XRRig rig;

		[SerializeField]
		private Transform head;

		[SerializeField]
		private Transform remotePlayerHead;

		private CoroutineWrapper waitMovementWrapper;

		private CoroutineWrapper systmeMoveWrapper;

		private CoroutineWrapper forceMoveWrapper;

		private CoroutineWrapper rotationWrapper;

		[SerializeField]
		private float LeftDistance;

		private Queue<MoveItem> moveQueue = new Queue<MoveItem>();

		public Vector3 XRRigWorldPosition => rig.rig.transform.position;

		public Vector3 CameraWorldPosition => rig.cameraGameObject.transform.position;

		public bool isMoving => systmeMoveWrapper.IsPlaying;

		protected override void Awake()
		{
			base.Awake();
			if (!(LocalSingleton<XRRigControl>._instance != this))
			{
				waitMovementWrapper = new CoroutineWrapper(this);
				systmeMoveWrapper = new CoroutineWrapper(this);
				forceMoveWrapper = new CoroutineWrapper(this);
				rotationWrapper = new CoroutineWrapper(this);
				restrictedArea.Penetration.OnDataChanged += Penetration_OnDataChanged;
			}
		}

		private void Penetration_OnDataChanged(bool obj)
		{
			systmeMoveWrapper.Stop();
		}

		public void ResetRigDirection()
		{
			Vector3 dir = Vector3.forward;
			Vector3 towardToWorldDirection = GetTowardToWorldDirection(in dir);
			dir = head.forward;
			Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in dir);
			Vector3 to = Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector);
			float num = Vector3.SignedAngle(towardToWorldDirection, to, Vector3.up);
			rotationWrapper.StartSingleton(ResetRigDirectionInternal(0f - num));
		}

		private IEnumerator ResetRigDirectionInternal(float angle)
		{
			float t = 0f;
			float runtime = 0.1f;
			while (t < runtime)
			{
				float num = angle * 0.8f;
				angle -= num;
				rig.RotateAroundCameraUsingRigUp(num);
				t += Time.fixedDeltaTime;
				yield return YieldInstructionCache.WaitForFixedUpdate;
			}
			rig.RotateAroundCameraUsingRigUp(angle);
		}

		private Vector3 GetCameraToWorldDirection(in Vector3 dir)
		{
			Vector3 vector = head.forward;
			Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
			return Quaternion.LookRotation(Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector).normalized) * dir;
		}

		private Vector3 GetTowardToWorldDirection(in Vector3 dir)
		{
			Vector3 vector = remotePlayerHead.position - head.position;
			Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
			return Quaternion.LookRotation(Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector).normalized) * dir;
		}

		private Vector3 ComputeSlidingVector(in Vector3 worldDisplacement)
		{
			if (restrictedArea.ComputePenetration(in worldDisplacement, out var dir, out var dis))
			{
				return worldDisplacement + dir * dis;
			}
			return worldDisplacement;
		}

		public bool ForceMoveRig(Vector3 targetPosition, float delay = 0f)
		{
			Vector3 vector = targetPosition - rig.transform.position;
			systmeMoveWrapper.Stop();
			waitMovementWrapper.Stop();
			forceMoveWrapper.StartSingleton(Move(vector, delay));
			return true;
		}

		public void AddMoveQueue(in float magnitude, float delay)
		{
			moveQueue.Enqueue(new MoveItem
			{
				magnitude = magnitude,
				avilableTime = Time.time + delay
			});
		}

		public bool TryMoveByQueue()
		{
			while (moveQueue.Count > 0)
			{
				MoveItem moveItem = moveQueue.Dequeue();
				if (moveItem.avilableTime > Time.time)
				{
					TryMoveRig(in moveItem.magnitude);
					return true;
				}
			}
			return false;
		}

		public bool TryAutoMoveRig(in float magnitude, float waitTime = 0f)
		{
			Vector3 vector = Vector3.forward * magnitude;
			return TryAutoMoveRig(in vector, waitTime);
		}

		public bool TryAutoMoveRig(in Vector3 vector, float waitTime = 0f)
		{
			if (!Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData)
			{
				return false;
			}
			waitMovementWrapper.StartSingleton(WaitAndMove(GetTowardToWorldDirection(in vector), waitTime));
			return true;
		}

		public bool TryMoveRig(in float magnitude, float delay = 0f)
		{
			Vector3 vector = Vector3.forward * magnitude;
			return TryMoveRig(in vector, delay);
		}

		public bool TryMoveRigToWorldPosition(in Vector3 vector, float delay = 0f)
		{
			if (!Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData)
			{
				return false;
			}
			systmeMoveWrapper.Stop();
			waitMovementWrapper.Stop();
			ResetRigDirection();
			Vector3 vector2 = vector - rig.transform.position;
			forceMoveWrapper.StartSingleton(Move(vector2, delay));
			return true;
		}

		public bool TryMoveRig(in Vector3 vector, float delay = 0f)
		{
			if (restrictedArea.Penetration.CurrentData)
			{
				return false;
			}
			if (!Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData)
			{
				return false;
			}
			systmeMoveWrapper.StartSingleton(Move(GetTowardToWorldDirection(in vector), delay));
			return true;
		}

		public bool TryTranslateRig(in Vector3 vector)
		{
			if (restrictedArea.Penetration.CurrentData)
			{
				return false;
			}
			if (!Jisu.Utils.Singleton<MultiplayerSetting>.Instance.AllowMovement.CurrentData)
			{
				return false;
			}
			if (Vector3.Dot(Vector3.forward, vector.normalized) > 0.5f)
			{
				if (TryMoveByQueue())
				{
					return true;
				}
				if (systmeMoveWrapper.IsPlaying)
				{
					return false;
				}
			}
			systmeMoveWrapper.Stop();
			waitMovementWrapper.Stop();
			Vector3 vector2 = remotePlayerHead.position - head.position;
			Vector2 normalized = Jisu.Utils.VectorExtension.ToXZ(in vector2).normalized;
			vector2 = head.transform.forward;
			Vector2 rhs = Jisu.Utils.VectorExtension.ToXZ(in vector2);
			if (Vector2.Dot(normalized, rhs) > 0.9f)
			{
				Vector3 worldDisplacement = GetTowardToWorldDirection(in vector);
				Vector3 translation = ComputeSlidingVector(in worldDisplacement);
				rig.transform.Translate(translation, Space.World);
			}
			else
			{
				Vector3 worldDisplacement2 = GetCameraToWorldDirection(in vector);
				Vector3 translation2 = ComputeSlidingVector(in worldDisplacement2);
				rig.transform.Translate(translation2, Space.World);
			}
			return true;
		}

		private IEnumerator Move(Vector3 vector, float delay = 0f, float runtime = 0.25f)
		{
			float t = 0f;
			LeftDistance = vector.magnitude;
			float delta = LeftDistance / runtime;
			if (delay != 0f)
			{
				yield return YieldInstructionCache.WaitForSeconds(delay);
			}
			Vector3 dir = vector.normalized;
			while (t < runtime)
			{
				t += Time.fixedDeltaTime;
				float num = delta * Time.fixedDeltaTime;
				rig.transform.Translate(dir * num, Space.World);
				LeftDistance -= num;
				yield return YieldInstructionCache.WaitForFixedUpdate;
			}
			rig.transform.Translate(dir * LeftDistance, Space.World);
			LeftDistance = 0f;
		}

		private IEnumerator WaitAndMove(Vector3 vector, float waitTime = 0f, float runtime = 0.25f)
		{
			float t = 0f;
			float blockedTime = 0f;
			LeftDistance = vector.magnitude;
			float distancePerSecond = LeftDistance / runtime;
			Vector3 dir = vector.normalized;
			while (t < runtime)
			{
				float num = distancePerSecond * Time.fixedDeltaTime;
				if (restrictedArea.Penetration.CurrentData)
				{
					blockedTime += Time.fixedDeltaTime;
					if (!(blockedTime + t < waitTime))
					{
						LeftDistance = 0f;
						yield break;
					}
					yield return YieldInstructionCache.WaitForFixedUpdate;
				}
				else
				{
					rig.transform.Translate(dir * num, Space.World);
					LeftDistance -= num;
					t += Time.fixedDeltaTime;
					yield return YieldInstructionCache.WaitForFixedUpdate;
				}
			}
			rig.transform.Translate(dir * LeftDistance, Space.World);
			LeftDistance = 0f;
		}
	}
	public interface IPlayerData
	{
		Jisu.Utils.Notifier<int> MainHPNotifier { get; }

		Jisu.Utils.Notifier<int> TempHPNotifier { get; }

		Jisu.Utils.Notifier<int> FireHandCountNotifier { get; }
	}
	public class RemotePlayerData : Jisu.Utils.Singleton<RemotePlayerData>, IPlayerData
	{
		public readonly Jisu.Utils.Notifier<int> MainHP = new Jisu.Utils.Notifier<int>();

		public readonly Jisu.Utils.Notifier<int> TempHP = new Jisu.Utils.Notifier<int>();

		public readonly Jisu.Utils.Notifier<bool> IsDown = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<int> FireHandCount = new Jisu.Utils.Notifier<int>();

		public readonly Jisu.Utils.Notifier<bool> LeftHandGhostState = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<bool> RightHandGhostState = new Jisu.Utils.Notifier<bool>();

		public Jisu.Utils.Notifier<int> MainHPNotifier => MainHP;

		public Jisu.Utils.Notifier<int> TempHPNotifier => TempHP;

		public Jisu.Utils.Notifier<int> FireHandCountNotifier => FireHandCount;

		public void Initialize()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnOpponentStatusUpdateMessageReceive += Instance_OnOpponentStatusUpdateMessageReceive;
				instance.OnBlockingMessageReceive += Instance_OnBlockingMessageReceive;
			};
			LeftHandGhostState.CurrentData = false;
			RightHandGhostState.CurrentData = false;
			MainHP.CurrentData = 3000;
			TempHP.CurrentData = 1000;
			IsDown.CurrentData = false;
			FireHandCount.CurrentData = 3;
		}

		private void Instance_OnBlockingMessageReceive(BlockPacket obj)
		{
			switch ((ControllerData.ControllerType)obj.hand)
			{
			case ControllerData.ControllerType.Left:
				LeftHandGhostState.CurrentData = obj.overrideGhostState == 1;
				break;
			case ControllerData.ControllerType.Right:
				RightHandGhostState.CurrentData = obj.overrideGhostState == 1;
				break;
			}
		}

		private void Instance_OnOpponentStatusUpdateMessageReceive(StatusPacket obj)
		{
			MainHP.CurrentData = obj.CurrentHP;
			TempHP.CurrentData = obj.CurrentTempHP;
			IsDown.CurrentData = obj.isDown == 1;
			FireHandCount.CurrentData = obj.ItemCount;
		}

		public void Dispose()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnBlockingMessageReceive -= Instance_OnBlockingMessageReceive;
				instance.OnOpponentStatusUpdateMessageReceive -= Instance_OnOpponentStatusUpdateMessageReceive;
			};
		}
	}
	public class LocalPlayerData : Jisu.Utils.Singleton<LocalPlayerData>, IPlayerData
	{
		public const int DefaultMainHP = 3000;

		public const int DefaultTempHP = 1000;

		public readonly Jisu.Utils.Notifier<int> MainHP = new Jisu.Utils.Notifier<int>();

		public readonly Jisu.Utils.Notifier<int> TempHP = new Jisu.Utils.Notifier<int>();

		public float InvincibilityEndTime;

		public float InvaildAttackTime;

		public readonly Jisu.Utils.Notifier<bool> IsDown = new Jisu.Utils.Notifier<bool>();

		public readonly Jisu.Utils.Notifier<int> FireHandCount = new Jisu.Utils.Notifier<int>();

		public Jisu.Utils.Notifier<int> MainHPNotifier => MainHP;

		public Jisu.Utils.Notifier<int> TempHPNotifier => TempHP;

		public Jisu.Utils.Notifier<int> FireHandCountNotifier => FireHandCount;

		public void Initialize()
		{
			MainHP.CurrentData = 3000;
			TempHP.CurrentData = 1000;
			IsDown.CurrentData = false;
			FireHandCount.CurrentData = 3;
		}
	}
	public class PlayerMovement : MonoBehaviour
	{
		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController controller;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController subController;

		[SerializeField]
		private Transform Anchor;

		[SerializeField]
		private Transform XRRig;

		[SerializeField]
		private Transform LocalPlayerHead;

		[SerializeField]
		private Transform RemotePlayerHead;

		[SerializeField]
		private float movementSpeed = 0.75f;

		[SerializeField]
		private AnimationCurve speedRemapCurve;

		[SerializeField]
		private XRRigControl rigControl;

		[SerializeField]
		private float DashAmount;

		private readonly Jisu.Utils.Notifier<bool> ButtonNotifier = new Jisu.Utils.Notifier<bool>();

		private readonly Jisu.Utils.Notifier<bool> mainControllerDown = new Jisu.Utils.Notifier<bool>();

		private readonly Jisu.Utils.Notifier<bool> subControllerDown = new Jisu.Utils.Notifier<bool>();

		private float lastMainControllerDownTime;

		private float lastSubControllerDownTime;

		private float dashAvilableTime;

		private float moveAvilableTime;

		private bool useMainControllerDash;

		private bool useSubControllerDash;

		private const float DoubleClickThreshold = 0.3f;

		private void Awake()
		{
			ButtonNotifier.OnDataChanged += ButtonNotifier_OnDataChanged;
			mainControllerDown.OnDataChanged += MainControllerDown_OnDataChanged;
			subControllerDown.OnDataChanged += SubControllerDown_OnDataChanged;
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager instance)
			{
				instance.OnRoundChangeStarted += Instance_OnRoundChangeStarted;
				instance.OnDisplaceRig += Instance_OnRoundChangeStarted;
			};
		}

		private void OnDestroy()
		{
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager instance)
			{
				instance.OnRoundChangeStarted -= Instance_OnRoundChangeStarted;
				instance.OnDisplaceRig -= Instance_OnRoundChangeStarted;
			};
		}

		private void MainControllerDown_OnDataChanged(bool isDown)
		{
			if (isDown)
			{
				if (Time.time - lastMainControllerDownTime < 0.3f)
				{
					useMainControllerDash = true;
				}
				lastMainControllerDownTime = Time.time;
			}
		}

		private void SubControllerDown_OnDataChanged(bool isDown)
		{
			if (isDown)
			{
				if (Time.time - lastSubControllerDownTime < 0.3f)
				{
					useSubControllerDash = true;
				}
				lastSubControllerDownTime = Time.time;
			}
		}

		private void ButtonNotifier_OnDataChanged(bool isDown)
		{
			if (isDown)
			{
				rigControl.ResetRigDirection();
			}
		}

		private void Update()
		{
			UpdateMovement();
		}

		private bool TryDash(in Vector3 inputDir, ref bool controllerDash)
		{
			if (inputDir.magnitude < 0.4f)
			{
				return false;
			}
			if (!controllerDash)
			{
				return false;
			}
			if (dashAvilableTime > Time.time)
			{
				return false;
			}
			XRRigControl xRRigControl = rigControl;
			float magnitude = Mathf.Sign(inputDir.y) * DashAmount;
			if (!xRRigControl.TryMoveRig(in magnitude))
			{
				return false;
			}
			controllerDash = false;
			dashAvilableTime = Time.time + 1f;
			moveAvilableTime = Time.time + 0.3f;
			return true;
		}

		private void UpdateMovement()
		{
			bool currentData = Jisu.Utils.Singleton<MultiplayerSetting>.Instance.IsOculusController.CurrentData;
			Vector2 zero = Vector2.zero;
			if (currentData)
			{
				if (!controller.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxis, out var value))
				{
					value = Vector2.zero;
				}
				if (!controller.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxisClick, out useMainControllerDash))
				{
					useMainControllerDash = false;
				}
				Vector3 inputDir = value;
				if (TryDash(in inputDir, ref useMainControllerDash))
				{
					return;
				}
				if (!subController.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxis, out var value2))
				{
					value2 = Vector2.zero;
				}
				if (!subController.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxisClick, out useSubControllerDash))
				{
					useSubControllerDash = false;
				}
				inputDir = value2;
				if (TryDash(in inputDir, ref useSubControllerDash))
				{
					return;
				}
				zero = value + value2;
			}
			else
			{
				if (!controller.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxis, out var value3))
				{
					value3 = Vector2.zero;
				}
				if (!controller.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxisClick, out var value4))
				{
					value4 = false;
				}
				mainControllerDown.CurrentData = value4;
				if (!value4)
				{
					value3 = Vector2.zero;
				}
				Vector3 inputDir = value3;
				if (TryDash(in inputDir, ref useMainControllerDash))
				{
					return;
				}
				if (!subController.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxis, out var value5))
				{
					value5 = Vector2.zero;
				}
				if (!subController.inputDevice.TryGetFeatureValue(CommonUsages.primary2DAxisClick, out var value6))
				{
					value6 = false;
				}
				subControllerDown.CurrentData = value6;
				if (!value6)
				{
					value5 = Vector2.zero;
				}
				inputDir = value5;
				if (TryDash(in inputDir, ref useSubControllerDash))
				{
					return;
				}
				zero = value3 + value5;
			}
			if (zero != Vector2.zero && moveAvilableTime < Time.time)
			{
				Move(Vector3.ClampMagnitude(zero, 1f));
			}
		}

		private void Instance_OnRoundChangeStarted()
		{
			XRRig.localRotation = Quaternion.Euler(Vector3.zero);
			float angle = Vector3.SignedAngle(LocalPlayerHead.forward, XRRig.forward, Vector3.up);
			XRRig.Rotate(XRRig.up, angle);
		}

		private void UpdateRecenter()
		{
			if (!subController.inputDevice.TryGetFeatureValue(CommonUsages.triggerButton, out var value))
			{
				value = false;
			}
			if (!controller.inputDevice.TryGetFeatureValue(CommonUsages.triggerButton, out var value2))
			{
				value2 = false;
			}
			ButtonNotifier.CurrentData = value2 || value;
		}

		private void Move(Vector2 inputVector)
		{
			float magnitude = (LocalPlayerHead.position - RemotePlayerHead.position).magnitude;
			XRRigControl xRRigControl = rigControl;
			Vector3 vector = Jisu.Utils.VectorExtension.ToVector3FromXZ(in inputVector) * Time.deltaTime * movementSpeed * speedRemapCurve.Evaluate(magnitude);
			xRRigControl.TryTranslateRig(in vector);
		}
	}
	public class PostProcessControl : MonoBehaviour
	{
		[SerializeField]
		private Volume volume;

		private static PostProcessControl _instance;

		private CoroutineWrapper vignetteControl;

		private CoroutineWrapper colorAdjustmentControl;

		private Color defaultColorAdjustmentFilterValue;

		private CoroutineWrapper colorAdjustmentSaturationControl;

		private CoroutineWrapper motionBlurControl;

		private float defaultVignetteValue;

		private float defaultSaturationValue;

		private float defaultMotionBlurIntensity;

		private void Awake()
		{
			_instance = this;
			vignetteControl = new CoroutineWrapper(this);
			colorAdjustmentControl = new CoroutineWrapper(this);
			motionBlurControl = new CoroutineWrapper(this);
			if (volume.profile.TryGet<ColorAdjustments>(out var component))
			{
				defaultColorAdjustmentFilterValue = component.colorFilter.value;
				defaultSaturationValue = component.saturation.value;
			}
			colorAdjustmentSaturationControl = new CoroutineWrapper(this);
			if (volume.profile.TryGet<Vignette>(out var component2))
			{
				defaultVignetteValue = component2.intensity.value;
			}
		}

		private void OnEnable()
		{
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged += IsDown_OnDataChanged;
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager multiGameManager)
			{
				multiGameManager.OnFadeInOut += MultiGameManager_OnFadeInOut;
			};
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnDamageMessageReceive += Instance_OnDamageMessageReceive;
			};
		}

		private void StartFade(float runtime)
		{
			if (volume.profile.TryGet<ColorAdjustments>(out var adjustments) && !colorAdjustmentControl.IsPlaying)
			{
				colorAdjustmentControl.StartSingleton(InnerAnimation(runtime));
			}
			IEnumerator InnerAnimation(float _runtime)
			{
				Color defaultColorFilterValue = adjustments.colorFilter.value;
				Color startValue2 = adjustments.colorFilter.value;
				Color black = Color.black;
				adjustments.colorFilter.value = Color.Lerp(startValue2, black, 1f);
				float t = 0f;
				startValue2 = adjustments.colorFilter.value;
				while (t < _runtime)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue2, defaultColorFilterValue, t / _runtime);
					t += Time.deltaTime;
					yield return null;
				}
				adjustments.colorFilter.value = defaultColorFilterValue;
			}
		}

		private void MultiGameManager_OnFadeInOut(float runtime, Action OnHide)
		{
			if (volume.profile.TryGet<ColorAdjustments>(out var adjustments) && !colorAdjustmentControl.IsPlaying)
			{
				colorAdjustmentControl.StartSingleton(InnerAnimation(runtime));
			}
			IEnumerator InnerAnimation(float _runtime)
			{
				float t = 0f;
				Color defaultColorFilterValue = adjustments.colorFilter.value;
				Color startValue2 = adjustments.colorFilter.value;
				Color endValue = Color.black;
				while (t < _runtime)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue2, endValue, t / _runtime);
					t += Time.deltaTime;
					yield return null;
				}
				OnHide?.Invoke();
				yield return YieldInstructionCache.WaitForSeconds(_runtime);
				t = 0f;
				startValue2 = adjustments.colorFilter.value;
				while (t < _runtime)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue2, defaultColorFilterValue, t / _runtime);
					t += Time.deltaTime;
					yield return null;
				}
				adjustments.colorFilter.value = defaultColorFilterValue;
			}
		}

		public void FadeOut()
		{
			if (volume.profile.TryGet<ColorAdjustments>(out var adjustments))
			{
				colorAdjustmentControl.StartSingleton(FadeOut(0.25f));
			}
			IEnumerator FadeOut(float runtime)
			{
				float t = 0f;
				Color startValue = adjustments.colorFilter.value;
				Color endValue = Color.black;
				while (t < runtime)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue, endValue, t / runtime);
					t += Time.deltaTime;
					yield return null;
				}
				adjustments.colorFilter.value = endValue;
			}
		}

		public void FadeIn()
		{
			if (volume.profile.TryGet<ColorAdjustments>(out var adjustments))
			{
				colorAdjustmentControl.StartSingleton(FadeIn(0.25f));
			}
			IEnumerator FadeIn(float runtime)
			{
				float t = 0f;
				Color startValue = adjustments.colorFilter.value;
				while (t < runtime)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue, defaultColorAdjustmentFilterValue, t / runtime);
					t += Time.deltaTime;
					yield return null;
				}
				adjustments.colorFilter.value = defaultColorAdjustmentFilterValue;
			}
		}

		private void IsDown_OnDataChanged(bool isDown)
		{
			Vignette vignette;
			ColorAdjustments adjustments;
			ColorAdjustments adjustments2;
			if (isDown)
			{
				if (volume.profile.TryGet<Vignette>(out vignette))
				{
					vignette.intensity.value = 1f;
					vignetteControl.StartSingleton(InnerAnimation(10f));
				}
				if (volume.profile.TryGet<ColorAdjustments>(out adjustments))
				{
					if (colorAdjustmentSaturationControl.IsPlaying)
					{
						adjustments.saturation.value = defaultSaturationValue;
						adjustments.colorFilter.value = defaultColorAdjustmentFilterValue;
					}
					colorAdjustmentSaturationControl.StartSingleton(InnerAnimation(0.35f));
				}
			}
			else if (volume.profile.TryGet<ColorAdjustments>(out adjustments2))
			{
				if (colorAdjustmentSaturationControl.IsPlaying)
				{
					adjustments2.saturation.value = defaultSaturationValue;
					adjustments2.colorFilter.value = defaultColorAdjustmentFilterValue;
				}
				colorAdjustmentSaturationControl.StartSingleton(InnerAnimation(0.35f));
			}
			IEnumerator InnerAnimation(float runtime)
			{
				float t3 = 0f;
				float startValue3 = vignette.intensity.value;
				while (t3 < runtime)
				{
					vignette.intensity.value = Mathf.Lerp(startValue3, defaultVignetteValue, t3 / runtime);
					t3 += Time.deltaTime;
					yield return null;
				}
				vignette.intensity.value = defaultVignetteValue;
			}
			IEnumerator InnerAnimation(float on)
			{
				float t2 = 0f;
				float startValue2 = adjustments.saturation.value;
				int endValue2 = -100;
				while (t2 < on)
				{
					adjustments.saturation.value = Mathf.Lerp(startValue2, endValue2, t2 / on);
					t2 += Time.deltaTime;
					yield return null;
				}
			}
			IEnumerator InnerAnimation(float on)
			{
				float t = 0f;
				float startValue = adjustments2.saturation.value;
				float endValue = defaultSaturationValue;
				while (t < on)
				{
					adjustments2.saturation.value = Mathf.Lerp(startValue, endValue, t / on);
					t += Time.deltaTime;
					yield return null;
				}
			}
		}

		private void IsEnd_OnDataChanged(bool obj)
		{
			if (volume.profile.TryGet<ColorAdjustments>(out var adjustments))
			{
				colorAdjustmentControl.StartSingleton(InnerAnimation(0.25f, 0.5f));
			}
			IEnumerator InnerAnimation(float runtime, float delay)
			{
				yield return YieldInstructionCache.WaitForSeconds(9f);
				float t = 0f;
				Color startValue2 = adjustments.colorFilter.value;
				Color endValue = Color.black;
				while (t < runtime)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue2, endValue, t / runtime);
					t += Time.deltaTime;
					yield return null;
				}
				yield return YieldInstructionCache.WaitForSeconds(delay);
				t = 0f;
				startValue2 = adjustments.colorFilter.value;
				while (t < runtime)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue2, defaultColorAdjustmentFilterValue, t / runtime);
					t += Time.deltaTime;
					yield return null;
				}
				adjustments.colorFilter.value = defaultColorAdjustmentFilterValue;
			}
		}

		private void Instance_OnDamageMessageReceive(DamagePacket packet)
		{
			Vignette vignette;
			ColorAdjustments adjustments;
			MotionBlur motionBlur;
			if (!(Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvincibilityEndTime > Time.time) && !Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData)
			{
				if (volume.profile.TryGet<Vignette>(out vignette))
				{
					vignette.intensity.value = (float)packet.damage * 0.02f;
					vignetteControl.StartSingleton(InnerAnimation(1.05f));
				}
				if (volume.profile.TryGet<ColorAdjustments>(out adjustments))
				{
					colorAdjustmentSaturationControl.StartSingleton(InnerAnimation(1.05f));
				}
				if (volume.profile.TryGet<MotionBlur>(out motionBlur))
				{
					motionBlurControl.StartSingleton(InnerAnimation(1.05f));
				}
			}
			IEnumerator InnerAnimation(float runtime)
			{
				float t3 = 0f;
				float startValue3 = vignette.intensity.value;
				while (t3 < runtime)
				{
					vignette.intensity.value = Mathf.Lerp(startValue3, defaultVignetteValue, t3 / runtime);
					t3 += Time.deltaTime;
					yield return null;
				}
				vignette.intensity.value = defaultVignetteValue;
			}
			IEnumerator InnerAnimation(float off)
			{
				float t2 = 0f;
				Color white = Color.white;
				Color red = Color.red;
				float value = Mathf.Clamp(packet.damage, 40f, 160f);
				(float, float) input = (40f, 160f);
				(float, float) output = (0f, 1f);
				Color startValue2 = Color.Lerp(white, red, Jisu.Utils.VectorExtension.Remap(value, in input, in output));
				while (t2 < off)
				{
					adjustments.colorFilter.value = Color.Lerp(startValue2, defaultColorAdjustmentFilterValue, t2 / off);
					t2 += Time.deltaTime;
					yield return null;
				}
				adjustments.colorFilter.value = defaultColorAdjustmentFilterValue;
			}
			IEnumerator InnerAnimation(float off)
			{
				float t = 0f;
				float startValue = 0.8f;
				while (t < off)
				{
					motionBlur.intensity.value = Mathf.Lerp(startValue, defaultMotionBlurIntensity, t / off);
					t += Time.deltaTime;
					yield return null;
				}
				motionBlur.intensity.value = defaultSaturationValue;
			}
		}

		private void OnDisable()
		{
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged -= IsDown_OnDataChanged;
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnDamageMessageReceive -= Instance_OnDamageMessageReceive;
			};
			if (LocalSingleton<MultiGameManager>.TryGetInstance(out var instance2))
			{
				instance2.OnFadeInOut -= MultiGameManager_OnFadeInOut;
			}
		}

		private void OnDestroy()
		{
			if (_instance == this)
			{
				_instance = null;
			}
		}
	}
	public class RemotePlayerGloveReaction : MonoBehaviour
	{
		[SerializeField]
		private Transform LeftHandRootBone;

		[SerializeField]
		private Transform RightHandRootBone;

		[SerializeField]
		private SkinnedMeshRenderer GloveRenderer;

		[SerializeField]
		private GameObject Glove_Animation;

		private void Awake()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnBlockingMessageReceive += Instance_OnGuardMessageReceive;
				instance.OnDisplaceStartMessageReceive += Instance_OnDisplaceStartMessageReceive;
			};
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager instance)
			{
				instance.OnGameComplete += Instance_OnGameComplete;
			};
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.OnDataChanged += IsDown_OnDataChanged;
			Glove_Animation.SetActive(value: false);
		}

		private void Instance_OnGuardMessageReceive(BlockPacket packet)
		{
			ControllerData.ControllerType hand = (ControllerData.ControllerType)packet.hand;
			ControllerData.BlockType blockState = (ControllerData.BlockType)packet.blockState;
			switch (hand)
			{
			case ControllerData.ControllerType.Left:
				GloveRenderer.sharedMaterial.SetFloat("_IsGhostL", (blockState != 0 || packet.overrideGhostState == 1) ? 1 : 0);
				break;
			case ControllerData.ControllerType.Right:
				GloveRenderer.sharedMaterial.SetFloat("_IsGhostR", (blockState != 0 || packet.overrideGhostState == 1) ? 1 : 0);
				break;
			}
		}

		private void Instance_OnDisplaceStartMessageReceive(DisplaceStartPacket packet)
		{
			GloveRenderer.enabled = true;
			Glove_Animation.SetActive(value: false);
		}

		private void Instance_OnGameComplete()
		{
			GloveRenderer.enabled = true;
			Glove_Animation.SetActive(value: false);
		}

		private void IsDown_OnDataChanged(bool isDown)
		{
			if (isDown)
			{
				GloveRenderer.enabled = false;
				Glove_Animation.SetActive(value: true);
			}
		}

		private void OnDestroy()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnBlockingMessageReceive -= Instance_OnGuardMessageReceive;
				instance.OnDisplaceStartMessageReceive -= Instance_OnDisplaceStartMessageReceive;
			};
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager instance)
			{
				instance.OnGameComplete -= Instance_OnGameComplete;
			};
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.OnDataChanged -= IsDown_OnDataChanged;
		}
	}
	public class SoundManager : LocalSingleton<SoundManager>
	{
		[Serializable]
		public class Pair
		{
			public ClipType type;

			public List<AudioClip> clips;

			public AudioClip clip => Jisu.Utils.CollectionExtension.GetRandom(clips);
		}

		public class ClipTypeComparerer : IEqualityComparer<ClipType>
		{
			public bool Equals(ClipType x, ClipType y)
			{
				return x == y;
			}

			public int GetHashCode(ClipType obj)
			{
				int num = (int)obj;
				return num.GetHashCode();
			}
		}

		public enum ClipType
		{
			None = 0,
			RoundStart = 100,
			RoundEnd = 101,
			KO_Bell = 102,
			KO_Voice = 103,
			Squeaks = 104,
			Fight = 105
		}

		[SerializeField]
		private AudioSource origin;

		[SerializeField]
		private List<Pair> pairs;

		private Dictionary<ClipType, List<AudioSource>> pool = new Dictionary<ClipType, List<AudioSource>>(new ClipTypeComparerer());

		protected override void Awake()
		{
			base.Awake();
			foreach (Pair pair in pairs)
			{
				AudioSource audioSource = UnityEngine.Object.Instantiate(origin);
				audioSource.transform.SetParent(origin.transform.parent);
				audioSource.clip = pair.clip;
				if (!pool.TryGetValue(pair.type, out var value))
				{
					value = new List<AudioSource>();
					pool[pair.type] = value;
				}
				value.Add(audioSource);
			}
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			bool flag = PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese;
			foreach (AudioSource item in pool[ClipType.Fight])
			{
				item.clip = (flag ? pairs[4].clips[1] : pairs[4].clips[0]);
			}
			foreach (AudioSource item2 in pool[ClipType.KO_Voice])
			{
				item2.clip = (flag ? pairs[5].clips[1] : pairs[5].clips[0]);
			}
		}

		private AudioSource AddPool(ClipType type)
		{
			Pair pair = pairs.Find((Pair e) => e.type == type);
			if (pair == null)
			{
				return null;
			}
			AudioSource audioSource = UnityEngine.Object.Instantiate(origin);
			audioSource.transform.SetParent(origin.transform.parent);
			audioSource.clip = pair.clip;
			if (!pool.TryGetValue(pair.type, out var value))
			{
				value = new List<AudioSource>();
				pool[pair.type] = value;
			}
			value.Add(audioSource);
			return audioSource;
		}

		public static AudioSource Run(in ClipType type, in float volume = 1f)
		{
			AudioSource audioSource = LocalSingleton<SoundManager>.Instance.pool[type].FirstOrDefault((AudioSource _source) => !_source.isPlaying);
			if (audioSource == null)
			{
				audioSource = LocalSingleton<SoundManager>.Instance.AddPool(type);
			}
			audioSource.volume = volume;
			audioSource.transform.localPosition = Vector3.zero;
			audioSource.Play();
			return audioSource;
		}

		public static AudioSource Run(in ClipType type, in Vector3 position, in float volume = 1f)
		{
			AudioSource audioSource = LocalSingleton<SoundManager>.Instance.pool[type].FirstOrDefault((AudioSource _source) => !_source.isPlaying);
			if (audioSource == null)
			{
				audioSource = LocalSingleton<SoundManager>.Instance.AddPool(type);
			}
			audioSource.volume = volume;
			audioSource.transform.position = position;
			audioSource.Play();
			return audioSource;
		}

		public static AudioSource Run(in float delay, in ClipType type, in float volume = 1f)
		{
			AudioSource audioSource = LocalSingleton<SoundManager>.Instance.pool[type].FirstOrDefault((AudioSource _source) => !_source.isPlaying);
			if (audioSource == null)
			{
				audioSource = LocalSingleton<SoundManager>.Instance.AddPool(type);
			}
			audioSource.volume = volume;
			audioSource.transform.localPosition = Vector3.zero;
			audioSource.PlayDelayed(delay);
			return audioSource;
		}
	}
	public class TrackedPoseDriverExt : UnityEngine.SpatialTracking.TrackedPoseDriver
	{
		[Header("Extended offset parameters")]
		[SerializeField]
		private float downOffsetHeight;

		[SerializeField]
		private AnimationCurve PositionCurve;

		[SerializeField]
		private AnimationCurve RotationCurve;

		private CoroutineWrapper rotationWrapper;

		private CoroutineWrapper positionWrapper;

		private Vector3 positionOffset = Vector3.zero;

		private Quaternion rotationOffset = Quaternion.identity;

		private Quaternion bakedReverseQuat;

		protected override void Awake()
		{
			base.Awake();
			rotationWrapper = new CoroutineWrapper(this);
			positionWrapper = new CoroutineWrapper(this);
			bakedReverseQuat = Quaternion.AngleAxis(180f, Vector3.up);
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged += IsDown_OnDataChanged;
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnDamageMessageReceive += Instance_OnDamageMessageReceive;
			};
			StartCoroutine(Test());
		}

		private IEnumerator Test()
		{
			while (base.enabled)
			{
				TestUpdate();
				yield return null;
			}
		}

		private void TestUpdate()
		{
			if (Input.GetKeyDown(KeyCode.B))
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData = true;
			}
			else if (Input.GetKeyDown(KeyCode.V))
			{
				Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.CurrentData = false;
			}
		}

		private void IsDown_OnDataChanged(bool isDown)
		{
			if (isDown)
			{
				positionWrapper.StartSingleton(ApplyPositionOffset(downOffsetHeight));
			}
			else
			{
				positionWrapper.StartSingleton(ApplyPositionOffset(0f));
			}
			IEnumerator ApplyPositionOffset(float target)
			{
				float t = 0f;
				Vector3 defaultpositionOffset = positionOffset;
				Vector2 targetOffset = Vector2.up * target;
				while (t < 0.35f)
				{
					positionOffset = Vector3.LerpUnclamped(defaultpositionOffset, targetOffset, PositionCurve.Evaluate(t / 0.35f));
					t += Time.deltaTime;
					yield return null;
				}
			}
		}

		private void Instance_OnDamageMessageReceive(DamagePacket packet)
		{
			float remappedRange;
			Vector3 position;
			Vector3 force;
			if (!(Jisu.Utils.Singleton<LocalPlayerData>.Instance.InvincibilityEndTime > Time.time))
			{
				float value = Mathf.Clamp(packet.damage, 40f, 160f);
				(float, float) input = (40f, 160f);
				(float, float) output = (0f, 1f);
				remappedRange = Jisu.Utils.VectorExtension.Remap(value, in input, in output);
				position = packet.position;
				force = packet.velocity;
				rotationWrapper.StartSingleton(RotateCamera());
			}
			IEnumerator RotateCamera()
			{
				float t = 0f;
				float currentDelay = Mathf.Lerp(0.35f, 1.05f, remappedRange);
				float invCurrentDelay = 1f / currentDelay;
				while (t < currentDelay)
				{
					rotationOffset = GetQuaternionOffset(force, position, base.transform.position, t * invCurrentDelay, remappedRange * 0.5f);
					t += Time.deltaTime;
					yield return null;
				}
				rotationOffset = Quaternion.identity;
			}
		}

		private Quaternion GetQuaternionOffset(Vector3 force, Vector3 point, Vector3 center, float t, float weight)
		{
			Vector3 lhs = bakedReverseQuat * force;
			Vector3 vector = bakedReverseQuat * point;
			Vector3 axis = Vector3.Cross(lhs, vector - center);
			return Quaternion.AngleAxis(RotationCurve.Evaluate(t) * weight, axis);
		}

		protected override void SetLocalTransform(Vector3 newPosition, Quaternion newRotation, PoseDataFlags poseFlags)
		{
			if ((base.trackingType == TrackingType.RotationAndPosition || base.trackingType == TrackingType.RotationOnly) && (poseFlags & PoseDataFlags.Rotation) > PoseDataFlags.NoData)
			{
				base.transform.localRotation = newRotation * rotationOffset;
			}
			if ((base.trackingType == TrackingType.RotationAndPosition || base.trackingType == TrackingType.PositionOnly) && (poseFlags & PoseDataFlags.Position) > PoseDataFlags.NoData)
			{
				base.transform.localPosition = newPosition + positionOffset;
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			Jisu.Utils.Singleton<LocalPlayerData>.Instance.IsDown.OnDataChanged -= IsDown_OnDataChanged;
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnDamageMessageReceive -= Instance_OnDamageMessageReceive;
			};
		}
	}
	public class TrailTracker : MonoBehaviour
	{
		[SerializeField]
		private ControllerData data;

		[SerializeField]
		private Material trailMaterial;

		private const float lerpFactor = 0.4f;

		private void Update()
		{
			base.transform.position = Vector3.Lerp(base.transform.position, data.Model.position, 0.4f);
		}
	}
	public class IKChestControl : MonoBehaviour
	{
		[SerializeField]
		private Transform LeftHandTransform;

		[SerializeField]
		private Transform RightHandTransform;

		[SerializeField]
		private Transform HeadTransform;

		[SerializeField]
		private Transform ChestGoalTransform;

		[SerializeField]
		private VRIK ik;

		[Header("settings")]
		[SerializeField]
		private Vector3 offset;

		[SerializeField]
		private float LerpFactor = 0.4f;

		[SerializeField]
		private float pelvisFolllowFactor = 0.75f;

		private void Update()
		{
			Vector3 vector = LeftHandTransform.position - RightHandTransform.position;
			Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
			Vector3 rhs = Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector);
			vector = HeadTransform.position - LeftHandTransform.position;
			float a = Jisu.Utils.VectorExtension.ToXZ(in vector).magnitude / 0.5707f;
			vector = HeadTransform.position - RightHandTransform.position;
			float b = Jisu.Utils.VectorExtension.ToXZ(in vector).magnitude / 0.5707f;
			float value = Mathf.Max(a, b);
			(float, float) input = (0f, 1f);
			(float, float) output = (0f, 0.3f);
			float b2 = Jisu.Utils.VectorExtension.Remap(value, in input, in output);
			Vector3 vector2 = Vector3.Cross(Vector3.up, rhs);
			ChestGoalTransform.position = Vector3.Lerp(ChestGoalTransform.position, HeadTransform.position + vector2.normalized + offset, LerpFactor);
			ChestGoalTransform.forward = vector2;
			Vector3 lhs = vector2;
			vector = HeadTransform.forward;
			xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
			if (Vector3.Dot(lhs, Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector)) < 0f)
			{
				ik.solver.spine.chestGoalWeight = Mathf.Lerp(ik.solver.spine.chestGoalWeight, 0f, LerpFactor);
				ik.solver.spine.pelvisRotationWeight = ik.solver.spine.chestGoalWeight * pelvisFolllowFactor;
			}
			else
			{
				ik.solver.spine.chestGoalWeight = Mathf.Lerp(ik.solver.spine.chestGoalWeight, b2, LerpFactor);
				ik.solver.spine.pelvisRotationWeight = ik.solver.spine.chestGoalWeight * pelvisFolllowFactor;
			}
		}
	}
	public class OppositeCornerCalculator : LocalSingleton<OppositeCornerCalculator>
	{
		[Serializable]
		public class Corner
		{
			public Transform Pivot;

			public Transform Opposite;
		}

		[SerializeField]
		private List<Corner> Corners;

		protected override void Awake()
		{
			base.Awake();
		}

		public Transform GetOpposite(Vector3 worldPosition)
		{
			return Corners.Aggregate(Corners.First(), GetClosest, GetOpposite);
			Corner GetClosest(Corner closest, Corner next)
			{
				if (!((closest.Pivot.position - worldPosition).sqrMagnitude < (next.Pivot.position - worldPosition).sqrMagnitude))
				{
					return next;
				}
				return closest;
			}
		}

		private Transform GetOpposite(Corner closest)
		{
			return closest.Opposite;
		}
	}
	public static class ActionExtension
	{
		public class FOO : Jisu.Utils.MonoSingleton<FOO>
		{
			public static Action<FOO> oninit;

			public void call()
			{
			}
		}

		public static T OnInitialize<T>(this Action<T> action) where T : Jisu.Utils.MonoSingleton<T>
		{
			T value = null;
			action = (Action<T>)Delegate.Combine(action, (Action<T>)delegate(T instance)
			{
				value = instance;
			});
			return value;
		}

		public static void something()
		{
			FOO.oninit.OnInitialize().call();
		}
	}
	public class NetworkPoseData : MonoBehaviour
	{
		public enum DeviceType
		{
			None,
			Head,
			LeftController,
			RightController,
			XRRig
		}

		[Serializable]
		public class TrackedPoseTransform
		{
			[SerializeField]
			private bool useCatmulRomDeadReckoning;

			[SerializeField]
			private bool useCustomLerping;

			public DeviceType TrackedPoseType;

			[SerializeField]
			private Transform headTransform;

			public Transform transform;

			public IKPostTransform AnimationTarget;

			public GloveHitReaction reactor;

			private Vector3 LastLastPosition;

			private Vector3 LastPosition;

			private Vector3 TargetPosition;

			private Vector3 PredictionPosition;

			private Quaternion TargetRotation;

			private Quaternion PredictionRotation;

			private bool isReceived;

			private float lerpFactor;

			private float PacketSendInterval;

			private float TotalPacketSendInterval;

			private uint PacketReceiveCount;

			private int LastTimeStamp;

			private float UpdateTime;

			private const float ExtrapolationFactor = 7f;

			private const float InterpolationFactor = 1f / 7f;

			[Tooltip("서버 전송시간차로 인한 보상 시간최대값")]
			[SerializeField]
			private float maxClampDiff = 0.065f;

			[Tooltip("패킷 누락 및 지연에 대한 최대 외삽 비율. 1.5 = 평균패킷도착시간의 1.5배까지만")]
			[SerializeField]
			private float maxUpdateRate = 1.2f;

			[Tooltip("예측시 사용되는 가속(속력의 미분) 배율값. 높으면 튈 수 있음, 낮으면 느리게 따라옴")]
			[SerializeField]
			private float accelerationFactor = 1f;

			[Tooltip("예측시 속력(이동의 미분) 배율값. 높으면 튈 수 있음, 낮으면 느리게 따라옴")]
			[SerializeField]
			private float velocityFactor = 1f;

			public float updateRate;

			public void UpdateTransform(in float dt)
			{
				if (!isReceived)
				{
					return;
				}
				float num = 1f;
				UpdateTime += dt;
				updateRate = UpdateTime / (TotalPacketSendInterval / (float)PacketReceiveCount);
				if (TotalPacketSendInterval == 0f || PacketReceiveCount == 0 || float.IsNaN(updateRate))
				{
					updateRate = 0f;
				}
				if (Jisu.Utils.Singleton<RemotePlayerData>.Instance.IsDown.CurrentData && AnimationTarget != null)
				{
					transform.position = AnimationTarget.Transform.position;
					transform.rotation = AnimationTarget.Transform.rotation;
					return;
				}
				if (useCatmulRomDeadReckoning)
				{
					Vector3 vector = CatmulRom.CatmullRomLerp(LastLastPosition, LastPosition, TargetPosition, PredictionPosition, updateRate);
					float distanceRate = (headTransform.position - transform.position).magnitude;
					if (reactor != null)
					{
						GloveHitReaction gloveHitReaction = reactor;
						Vector3 worldPosition = transform.parent.TransformPoint(vector);
						if (gloveHitReaction.SimulatePenetrate(in worldPosition, in distanceRate, out var simulatedPosition))
						{
							vector = transform.parent.InverseTransformPoint(simulatedPosition);
						}
					}
					transform.localPosition = Vector3.Lerp(transform.localPosition, Vector3.ClampMagnitude(vector, 5f), lerpFactor);
					transform.localRotation = Quaternion.Slerp(transform.localRotation, TargetRotation, 1f / 7f);
					return;
				}
				if (useCustomLerping)
				{
					Vector3 vector2 = Vector3.Lerp(transform.localPosition, Vector3.LerpUnclamped(TargetPosition, PredictionPosition, 7f * num), 1f / 7f);
					float distanceRate2 = (headTransform.position - transform.position).magnitude;
					if (reactor != null)
					{
						GloveHitReaction gloveHitReaction2 = reactor;
						Vector3 worldPosition = transform.parent.TransformPoint(vector2);
						if (gloveHitReaction2.SimulatePenetrate(in worldPosition, in distanceRate2, out var simulatedPosition2))
						{
							vector2 = transform.parent.InverseTransformPoint(simulatedPosition2);
						}
					}
					transform.localPosition = Vector3.Lerp(transform.localPosition, Vector3.ClampMagnitude(vector2, 5f), 1f / 7f);
					transform.localRotation = Quaternion.Slerp(transform.localRotation, TargetRotation, 1f / 7f);
					return;
				}
				Vector3 vector3 = Vector3.LerpUnclamped(TargetPosition, PredictionPosition, Mathf.Clamp(updateRate, 0f, maxUpdateRate));
				float distanceRate3 = (headTransform.position - transform.position).magnitude;
				if (reactor != null)
				{
					GloveHitReaction gloveHitReaction3 = reactor;
					Vector3 worldPosition = transform.parent.TransformPoint(vector3);
					if (gloveHitReaction3.SimulatePenetrate(in worldPosition, in distanceRate3, out var simulatedPosition3))
					{
						vector3 = transform.parent.InverseTransformPoint(simulatedPosition3);
					}
				}
				if (IsNaN(in vector3))
				{
					UnityEngine.Debug.LogError($"lerpPosition is NaN. transform.parent is {transform.parent.position}, {transform.parent.lossyScale} and reactor is {reactor}  ");
					return;
				}
				transform.localPosition = Vector3.Lerp(transform.localPosition, Vector3.ClampMagnitude(vector3, 5f), 1f / 7f);
				transform.localRotation = Quaternion.Slerp(transform.localRotation, TargetRotation, 1f / 7f);
			}

			private bool IsNaN(in Vector3 vector)
			{
				if (!float.IsNaN(vector.x) && !float.IsNaN(vector.y))
				{
					return float.IsNaN(vector.z);
				}
				return true;
			}

			public void UpdateTarget(in int timeStamp, in Vector3 nextPosition, in Quaternion nextRotation, in Vector3 velocity, in Vector3 acceleration)
			{
				if (!isReceived)
				{
					transform.localPosition = (TargetPosition = nextPosition);
					transform.localRotation = (TargetRotation = nextRotation);
					isReceived = true;
					LastTimeStamp = timeStamp;
					return;
				}
				PacketSendInterval = (float)(timeStamp - LastTimeStamp) * 0.001f;
				TotalPacketSendInterval += PacketSendInterval;
				PacketReceiveCount++;
				if (PacketReceiveCount > 100)
				{
					float num = TotalPacketSendInterval / (float)PacketReceiveCount;
					TotalPacketSendInterval -= num;
					PacketReceiveCount--;
				}
				float num2 = Mathf.Clamp((float)(PhotonNetwork.ServerTimestamp - timeStamp) * 0.001f, 0f, maxClampDiff);
				UpdateTime = 0f;
				LastTimeStamp = timeStamp;
				lerpFactor = Mathf.Lerp(lerpFactor, (velocity * velocityFactor + acceleration * accelerationFactor * (num2 + PacketSendInterval)).magnitude, 0.4f);
				if (TrackedPoseType == DeviceType.Head)
				{
					PredictionPosition = nextPosition + (velocity * velocityFactor + acceleration * accelerationFactor * (num2 + PacketSendInterval)) * (num2 + PacketSendInterval);
					PredictionRotation = nextRotation * (nextRotation * Quaternion.Inverse(TargetRotation));
				}
				else
				{
					Vector3 position = nextPosition + (velocity * velocityFactor + acceleration * accelerationFactor * (num2 + PacketSendInterval)) * (num2 + PacketSendInterval);
					Vector3 vector = Vector3.ClampMagnitude(transform.parent.InverseTransformPoint(position) - headTransform.position, 1.2f);
					PredictionPosition = transform.parent.TransformPoint(vector + headTransform.position);
					PredictionRotation = nextRotation * (nextRotation * Quaternion.Inverse(TargetRotation));
				}
				LastLastPosition = LastPosition;
				LastPosition = TargetPosition;
				TargetPosition = nextPosition;
				TargetRotation = nextRotation;
			}
		}

		public class DeviceTypeComparer : IEqualityComparer<DeviceType>
		{
			public bool Equals(DeviceType x, DeviceType y)
			{
				return x == y;
			}

			public int GetHashCode(DeviceType obj)
			{
				return (int)obj;
			}
		}

		[SerializeField]
		private bool isReflector;

		[SerializeField]
		private List<TrackedPoseTransform> trackedPoseTransforms;

		[SerializeField]
		private GameObject ModelRoot;

		private readonly Dictionary<DeviceType, TrackedPoseTransform> trackedPoseTransformsDict = new Dictionary<DeviceType, TrackedPoseTransform>(new DeviceTypeComparer());

		private void Awake()
		{
			foreach (TrackedPoseTransform trackedPoseTransform in trackedPoseTransforms)
			{
				trackedPoseTransformsDict[trackedPoseTransform.TrackedPoseType] = trackedPoseTransform;
			}
		}

		private void OnEnable()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnTrackedPoseMessageReceive += TestReceivedMessate_OnDataChanged;
				instance.OnDamageMessageReceive += Instance_OnDamageMessageReceive;
			};
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager multiGameManager)
			{
				multiGameManager.ConnectionNotifier.OnDataChanged += ConnectionNotifier_OnDataChanged;
				ConnectionNotifier_OnDataChanged(multiGameManager.ConnectionNotifier.CurrentData);
			};
		}

		private void ConnectionNotifier_OnDataChanged(bool isConnected)
		{
			if (isConnected)
			{
				ModelRoot.SetActive(value: true);
			}
			else
			{
				ModelRoot.SetActive(value: false);
			}
		}

		private void Instance_OnDamageMessageReceive(DamagePacket obj)
		{
			if (isReflector)
			{
				PhotonManager.SendDamageData(in obj);
			}
		}

		private void FixedUpdate()
		{
			if (!PhotonManager.isValid)
			{
				return;
			}
			foreach (TrackedPoseTransform trackedPoseTransform in trackedPoseTransforms)
			{
				float dt = Time.fixedDeltaTime;
				trackedPoseTransform.UpdateTransform(in dt);
			}
		}

		private void Update()
		{
		}

		private void TestReceivedMessate_OnDataChanged(TrackedPosePacket packet)
		{
			if (trackedPoseTransformsDict.TryGetValue(DeviceType.Head, out var value))
			{
				TrackedPoseTransform trackedPoseTransform = value;
				ref int timeStamp = ref packet.timeStamp;
				Vector3 nextPosition = packet.p_h - Vector3.up * -0.122f;
				trackedPoseTransform.UpdateTarget(in timeStamp, in nextPosition, in packet.r_h, in packet.v_h, in packet.a_h);
			}
			if (trackedPoseTransformsDict.TryGetValue(DeviceType.LeftController, out var value2))
			{
				value2.UpdateTarget(in packet.timeStamp, in packet.p_lc, in packet.r_lc, in packet.v_lc, in packet.a_lc);
			}
			if (trackedPoseTransformsDict.TryGetValue(DeviceType.RightController, out var value3))
			{
				value3.UpdateTarget(in packet.timeStamp, in packet.p_rc, in packet.r_rc, in packet.v_rc, in packet.a_rc);
			}
		}

		private void OnDisable()
		{
			if (LocalSingleton<MultiGameManager>.TryGetInstance(out var instance2))
			{
				instance2.ConnectionNotifier.OnDataChanged -= ConnectionNotifier_OnDataChanged;
			}
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.OnTrackedPoseMessageReceive -= TestReceivedMessate_OnDataChanged;
				instance.OnDamageMessageReceive -= Instance_OnDamageMessageReceive;
			};
		}
	}
	public class NetworkPoseSender : MonoBehaviour
	{
		[Serializable]
		public class TrackedPoseTransform
		{
			public NetworkPoseData.DeviceType TrackedPoseType;

			public Space space;

			public Transform transform;

			public Transform Root;

			private Vector3 lastVelocity;

			private Vector3 currentVelocity;

			private bool isCached;

			private InputDevice cachedInputDevice;

			public InputDevice CachedInputDevice
			{
				get
				{
					if (isCached)
					{
						return cachedInputDevice;
					}
					List<InputDevice> list = new List<InputDevice>();
					XRNode xRNode = ConvertToXRNode(TrackedPoseType);
					if (xRNode != (XRNode)(-1))
					{
						InputDevices.GetDevicesAtXRNode(xRNode, list);
						if (list != null && list.Count > 0)
						{
							cachedInputDevice = list.First();
							isCached = true;
							return cachedInputDevice;
						}
					}
					return default(InputDevice);
				}
			}

			private XRNode ConvertToXRNode(NetworkPoseData.DeviceType type)
			{
				return type switch
				{
					NetworkPoseData.DeviceType.Head => XRNode.Head, 
					NetworkPoseData.DeviceType.LeftController => XRNode.LeftHand, 
					NetworkPoseData.DeviceType.RightController => XRNode.RightHand, 
					_ => (XRNode)(-1), 
				};
			}

			public void Update(out Vector3 position, out Quaternion rotation, out Vector3 velocity, out Vector3 acceleration)
			{
				velocity = Vector3.zero;
				acceleration = Vector3.zero;
				if (CachedInputDevice != default(InputDevice))
				{
					if (!CachedInputDevice.TryGetFeatureValue(CommonUsages.deviceVelocity, out velocity))
					{
						velocity = Vector3.zero;
					}
					velocity = Root.TransformDirection(velocity);
					lastVelocity = currentVelocity;
					currentVelocity = velocity;
					if (!CachedInputDevice.TryGetFeatureValue(CommonUsages.deviceAcceleration, out acceleration))
					{
						acceleration = currentVelocity - lastVelocity;
					}
					acceleration = Root.TransformDirection(acceleration);
				}
				switch (space)
				{
				case Space.Self:
					position = transform.localPosition;
					rotation = transform.localRotation;
					break;
				case Space.World:
					position = transform.position;
					rotation = transform.rotation;
					break;
				default:
					position = Vector3.zero;
					rotation = Quaternion.identity;
					break;
				}
			}
		}

		[SerializeField]
		private bool isOculus;

		[SerializeField]
		private Vector3 OculusEulerOffset;

		[Space(20f)]
		[SerializeField]
		private bool useArmDistance;

		[SerializeField]
		private float DefaultArmDistance = 0.5707f;

		[SerializeField]
		private float ArmDistanceFactorOffset = 0.15f;

		[Space(20f)]
		[SerializeField]
		private List<TrackedPoseTransform> trackedPoseTransforms;

		private bool isInitialized;

		private Dictionary<NetworkPoseData.DeviceType, TrackedPoseTransform> trackedPoseTransformsDict = new Dictionary<NetworkPoseData.DeviceType, TrackedPoseTransform>(new NetworkPoseData.DeviceTypeComparer());

		private float ArmDistance => Jisu.Utils.Singleton<MultiplayerSetting>.Instance.ArmDistance.CurrentData;

		private void Awake()
		{
			PhotonSingleton<PhotonManager>.OnInitialized += delegate
			{
				isInitialized = true;
			};
			Jisu.Utils.Singleton<MultiplayerSetting>.Instance.ArmDistance.CurrentData = DefaultArmDistance;
			foreach (TrackedPoseTransform trackedPoseTransform in trackedPoseTransforms)
			{
				trackedPoseTransformsDict[trackedPoseTransform.TrackedPoseType] = trackedPoseTransform;
			}
		}

		private void OnEnable()
		{
			StartCoroutine(SendPosition());
		}

		private IEnumerator SendPosition()
		{
			WaitUntil waitUntilInitialize = new WaitUntil(() => isInitialized);
			WaitUntil waitUntilValid = new WaitUntil(() => PhotonManager.isValid);
			WaitForSecondsRealtime waitPacketSendRate = new WaitForSecondsRealtime(1f / (float)PhotonNetwork.SendRate * 1f);
			while (base.enabled)
			{
				yield return waitUntilInitialize;
				yield return waitUntilValid;
				TrackedPosePacket data = new TrackedPosePacket();
				data.t = (Jisu.Utils.Singleton<MultiplayerSetting>.Instance.IsOculusController.CurrentData ? 1 : 0);
				if (trackedPoseTransformsDict.TryGetValue(NetworkPoseData.DeviceType.Head, out var value))
				{
					value.Update(out data.p_h, out data.r_h, out data.v_h, out data.a_h);
				}
				if (trackedPoseTransformsDict.TryGetValue(NetworkPoseData.DeviceType.LeftController, out var value2))
				{
					value2.Update(out data.p_lc, out data.r_lc, out data.v_lc, out data.a_lc);
				}
				if (trackedPoseTransformsDict.TryGetValue(NetworkPoseData.DeviceType.RightController, out var value3))
				{
					value3.Update(out data.p_rc, out data.r_rc, out data.v_rc, out data.a_rc);
				}
				if (Jisu.Utils.Singleton<MultiplayerSetting>.Instance.IsOculusController.CurrentData)
				{
					data.r_lc *= Quaternion.Euler(OculusEulerOffset);
					data.r_rc *= Quaternion.Euler(OculusEulerOffset);
				}
				if (useArmDistance)
				{
					float num = 0.5707f / ArmDistance + ArmDistanceFactorOffset;
					Vector3 vector = data.p_lc - data.p_h;
					Vector3 vector2 = data.p_rc - data.p_h;
					data.p_lc = data.p_h + new Vector3(vector.x * num, vector.y, vector.z * num);
					data.p_rc = data.p_h + new Vector3(vector2.x * num, vector2.y, vector2.z * num);
				}
				PhotonManager.SendTrackedPoseData(in data);
				yield return waitPacketSendRate;
			}
		}

		private void OnDisable()
		{
		}
	}
	public class PhotonSingleton<T> : MonoBehaviourPunCallbacks, IPunObservable where T : PhotonSingleton<T>
	{
		protected static T _instance;

		public static T Instance => _instance;

		public static bool isInitialized { get; protected set; }

		private static event Action<T> onInitialized;

		public static event Action<T> OnInitialized
		{
			add
			{
				if (_instance != null)
				{
					value?.Invoke(_instance);
				}
				else
				{
					onInitialized += value;
				}
			}
			remove
			{
				onInitialized -= value;
			}
		}

		protected virtual void Awake()
		{
			if (_instance == null)
			{
				_instance = this as T;
				isInitialized = true;
				PhotonSingleton<T>.onInitialized?.Invoke(_instance);
				PhotonSingleton<T>.onInitialized = null;
			}
			else if (_instance != this)
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
		}

		public static bool TryGetInstance(out T instance)
		{
			instance = _instance;
			return instance != null;
		}

		private void OnDestroy()
		{
			if (_instance == this)
			{
				_instance = null;
			}
		}

		public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
		{
		}
	}
	public class PhotonManager : PhotonSingleton<PhotonManager>
	{
		private const RpcTarget SendTarget = RpcTarget.Others;

		public Jisu.Utils.Notifier<int> ConnectedPlayerCount { get; private set; } = new Jisu.Utils.Notifier<int>();


		public Jisu.Utils.NotifierClass<string> ConnectionState { get; private set; } = new Jisu.Utils.NotifierClass<string>();


		public static float RoundTripTime => PhotonNetwork.NetworkingClient.LoadBalancingPeer.RoundTripTime;

		public static bool isConnected
		{
			get
			{
				if (PhotonSingleton<PhotonManager>.isInitialized)
				{
					return PhotonNetwork.IsConnected;
				}
				return false;
			}
		}

		public static bool isValid
		{
			get
			{
				if (PhotonSingleton<PhotonManager>.isInitialized && PhotonNetwork.IsConnected && PhotonSingleton<PhotonManager>.Instance.photonView != null && PhotonSingleton<PhotonManager>.Instance.photonView.isActiveAndEnabled && PhotonNetwork.InRoom)
				{
					return PhotonNetwork.CurrentRoom.PlayerCount > 1;
				}
				return false;
			}
		}

		public static bool isMasterClient
		{
			get
			{
				if (isValid)
				{
					return PhotonNetwork.IsMasterClient;
				}
				return false;
			}
		}

		public event Action<ReadyStatePacket> OnReadyStateMessageReceive;

		public event Action<TrackedPosePacket> OnTrackedPoseMessageReceive;

		public event Action<DamagePacket> OnDamageMessageReceive;

		public event Action<DamagePacket> OnIgnoreDamageMessageReceive;

		public event Action<BlockPacket> OnBlockingMessageReceive;

		public event Action<StatusPacket> OnOpponentStatusUpdateMessageReceive;

		public event Action<RoundChangePacket> OnRoundChangeMessageReceive;

		public event Action<PausePacket> OnPauseMessageReceive;

		public event Action<RematchPacket> OnRematchMessageReceive;

		public event Action<AwakePacket> OnAwakeMessageReceive;

		public event Action<DisplaceStartPacket> OnDisplaceStartMessageReceive;

		public event Action<PlayerDownPacket> OnPlayerDownMessageRecieve;

		public event Action<PlayerKOPacket> OnPlayerKOMessageRecieve;

		public event Action<FireHandPacket> OnFireHandMessageReceive;

		private void Start()
		{
			PhotonNetwork.SerializationRate = 10;
			PhotonNetwork.SendRate = 20;
			PhotonView.Get(this);
			PhotonView obj = base.gameObject.AddComponent<PhotonView>();
			obj.ObservedComponents = new List<Component>(0);
			obj.ObservedComponents.Add(this);
			obj.ViewID = 500;
			PhotonNetwork.MinimalTimeScaleToDispatchInFixedUpdate = 1f;
			ConnectionState.OnDataChanged += ConnectionState_OnDataChanged;
		}

		private void ConnectionState_OnDataChanged(string obj)
		{
			UnityEngine.Debug.Log("ConnectionState : " + obj);
		}

		public void StartConnect()
		{
			PhotonNetwork.ConnectUsingSettings();
		}

		public override void OnRoomListUpdate(List<RoomInfo> roomList)
		{
			foreach (RoomInfo room in roomList)
			{
				if (room.PlayerCount != room.MaxPlayers)
				{
					PhotonNetwork.JoinRoom(room.Name);
					return;
				}
			}
			CreateRoom();
		}

		private void CreateRoom()
		{
			Photon.Realtime.RoomOptions roomOptions = new Photon.Realtime.RoomOptions
			{
				PublishUserId = true,
				MaxPlayers = 2
			};
			PhotonNetwork.CreateRoom("Lobby" + Time.time, roomOptions);
		}

		public void StartDisconnect()
		{
			if (PhotonNetwork.IsConnected)
			{
				PhotonNetwork.Disconnect();
			}
		}

		private void CheckMatchableCondition()
		{
			int count = PhotonNetwork.CurrentRoom.Players.Count;
			foreach (KeyValuePair<int, Player> item in PhotonNetwork.CurrentRoom.Players.OrderBy((KeyValuePair<int, Player> i) => i.Value.ActorNumber))
			{
				_ = item;
			}
			if (count != 1)
			{
				_ = 2;
			}
		}

		public override void OnConnectedToMaster()
		{
			PhotonNetwork.JoinLobby();
			ConnectionState.CurrentData = "StartConnect";
		}

		public override void OnJoinedLobby()
		{
			ConnectionState.CurrentData = "StartConnect";
		}

		public override void OnJoinedRoom()
		{
			ConnectionState.CurrentData = "JoinedRoom";
			CheckMatchableCondition();
		}

		public override void OnPlayerEnteredRoom(Player newPlayer)
		{
			CheckMatchableCondition();
		}

		public override void OnPlayerLeftRoom(Player otherPlayer)
		{
			CheckMatchableCondition();
		}

		public override void OnPlayerPropertiesUpdate(Player targetPlayer, ExitGames.Client.Photon.Hashtable changedProps)
		{
			CheckMatchableCondition();
		}

		public override void OnJoinRoomFailed(short returnCode, string message)
		{
			PhotonNetwork.JoinLobby();
		}

		public override void OnDisconnected(DisconnectCause cause)
		{
			base.OnDisconnected(cause);
			ConnectionState.CurrentData = "Disconnected : " + cause;
		}

		private static string SerializeData<T>(in T packet) where T : class
		{
			return JsonUtility.ToJson(packet);
		}

		private static T DeserializeData<T>(in string data) where T : class
		{
			return JsonUtility.FromJson<T>(data);
		}

		public static void SendReadyStateData(in ReadyStatePacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveReadyStateData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveReadyStateData(string data)
		{
			ReadyStatePacket obj = DeserializeData<ReadyStatePacket>(in data);
			this.OnReadyStateMessageReceive?.Invoke(obj);
		}

		public static void SendTrackedPoseData(in TrackedPosePacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveTrackedPoseData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveTrackedPoseData(string data)
		{
			TrackedPosePacket obj = DeserializeData<TrackedPosePacket>(in data);
			this.OnTrackedPoseMessageReceive?.Invoke(obj);
		}

		public static void SendDamageData(in DamagePacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveDamageData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveDamageData(string data)
		{
			DamagePacket obj = DeserializeData<DamagePacket>(in data);
			this.OnDamageMessageReceive?.Invoke(obj);
		}

		public static void SendIgnoreDamageData(in DamagePacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveIgnoreDamageData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveIgnoreDamageData(string data)
		{
			DamagePacket obj = DeserializeData<DamagePacket>(in data);
			this.OnIgnoreDamageMessageReceive?.Invoke(obj);
		}

		public static void SendBlockingData(in BlockPacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveBlockingData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveBlockingData(string data)
		{
			BlockPacket obj = DeserializeData<BlockPacket>(in data);
			this.OnBlockingMessageReceive?.Invoke(obj);
		}

		public static void SendStatusData(in StatusPacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveStatusData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveStatusData(string data)
		{
			StatusPacket obj = DeserializeData<StatusPacket>(in data);
			this.OnOpponentStatusUpdateMessageReceive?.Invoke(obj);
		}

		public static void SendRoundChangeData(in RoundChangePacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveRoundChangeData", RpcTarget.All, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveRoundChangeData(string data)
		{
			RoundChangePacket obj = DeserializeData<RoundChangePacket>(in data);
			this.OnRoundChangeMessageReceive?.Invoke(obj);
		}

		public static void SendPauseData(in PausePacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceivePauseData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceivePauseData(string data)
		{
			PausePacket obj = DeserializeData<PausePacket>(in data);
			this.OnPauseMessageReceive?.Invoke(obj);
		}

		public static void SendRematchData(in RematchPacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveRematchData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveRematchData(string data)
		{
			RematchPacket obj = DeserializeData<RematchPacket>(in data);
			this.OnRematchMessageReceive?.Invoke(obj);
		}

		public static void SendAwakeData(in AwakePacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveAwakeData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveAwakeData(string data)
		{
			AwakePacket obj = DeserializeData<AwakePacket>(in data);
			this.OnAwakeMessageReceive?.Invoke(obj);
		}

		public static void SendDisplaceStartData(in DisplaceStartPacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveDisplaceStartData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveDisplaceStartData(string data)
		{
			DisplaceStartPacket obj = DeserializeData<DisplaceStartPacket>(in data);
			this.OnDisplaceStartMessageReceive?.Invoke(obj);
		}

		public static void SendPlayerDownData(in PlayerDownPacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceivePlayerDownData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceivePlayerDownData(string data)
		{
			PlayerDownPacket obj = DeserializeData<PlayerDownPacket>(in data);
			this.OnPlayerDownMessageRecieve?.Invoke(obj);
		}

		public static void SendPlayerKOData(in PlayerKOPacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceivePlayerKOData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceivePlayerKOData(string data)
		{
			PlayerKOPacket obj = DeserializeData<PlayerKOPacket>(in data);
			this.OnPlayerKOMessageRecieve?.Invoke(obj);
		}

		public static void SendFireHandData(in FireHandPacket data)
		{
			if (isValid)
			{
				PhotonSingleton<PhotonManager>.Instance.photonView.RPC("ReceiveFireHandData", RpcTarget.Others, SerializeData(in data));
			}
		}

		[PunRPC]
		public void ReceiveFireHandData(string data)
		{
			FireHandPacket obj = DeserializeData<FireHandPacket>(in data);
			this.OnFireHandMessageReceive?.Invoke(obj);
		}
	}
	[Serializable]
	public class Packet
	{
		public int timeStamp;

		public Packet()
		{
			timeStamp = PhotonNetwork.ServerTimestamp;
		}
	}
	[Serializable]
	public class TrackedPosePacket : Packet
	{
		public Vector3 p_h;

		public Quaternion r_h;

		public Vector3 v_h;

		public Vector3 a_h;

		public Vector3 p_lc;

		public Quaternion r_lc;

		public Vector3 v_lc;

		public Vector3 a_lc;

		public Vector3 p_rc;

		public Quaternion r_rc;

		public Vector3 v_rc;

		public Vector3 a_rc;

		public int t;
	}
	[Serializable]
	public class StatusPacket : Packet
	{
		public int isDown;

		public int CurrentHP;

		public int CurrentTempHP;

		public int ItemCount;

		public int ItemMask;
	}
	[Serializable]
	public class DamagePacket : Packet
	{
		public Vector3 position;

		public Vector3 direction;

		public Vector3 velocity;

		public float magnitude;

		public float hitFactor;

		public int damage;

		public int fireHand;
	}
	[Serializable]
	public class BlockPacket : Packet
	{
		public int hand;

		public int destinationHand;

		public int blockState;

		public int overrideGhostState;

		public float lastVelocity;

		public bool runEffect;

		public Vector3 position;

		public Vector3 direction;
	}
	[Serializable]
	public class ReadyStatePacket : Packet
	{
	}
	[Serializable]
	public class RoundChangePacket : Packet
	{
	}
	[Serializable]
	public class PausePacket : Packet
	{
		public bool isPaused;
	}
	[Serializable]
	public class RematchPacket : Packet
	{
		public bool Request;
	}
	[Serializable]
	public class AwakePacket : Packet
	{
	}
	[Serializable]
	public class DisplaceStartPacket : Packet
	{
	}
	[Serializable]
	public class PlayerDownPacket : Packet
	{
		public bool Local;

		public bool Remote;
	}
	[Serializable]
	public class PlayerKOPacket : Packet
	{
		public bool Local;

		public bool Remote;
	}
	[Serializable]
	public class FireHandPacket : Packet
	{
		public int leftState;

		public int rightState;
	}
	public class DeviceTypeChecker : MonoBehaviour
	{
		[SerializeField]
		private bool logging;

		[SerializeField]
		private List<UnityEngine.XR.Interaction.Toolkit.XRController> controllers;

		private List<string> data = new List<string>();

		private const string OCULUS = "oculus";

		private const string INDEX = "index";

		private const string PICO = "pico";

		private void OnEnable()
		{
			StartCoroutine(CheckRoutine());
		}

		private IEnumerator CheckRoutine()
		{
			yield return YieldInstructionCache.WaitForSeconds(1f);
			Check();
		}

		private void Check()
		{
			data.Add(SystemInfo.deviceName);
			data.Add(SystemInfo.deviceModel);
			new StringBuilder();
			if (logging)
			{
				string log = "Device info : SystemInfo.deviceName(" + SystemInfo.deviceName + "),SystemInfo.deviceModel(" + SystemInfo.deviceModel + ")";
				Log(in log);
			}
			foreach (UnityEngine.XR.Interaction.Toolkit.XRController controller in controllers)
			{
				if (controller == null)
				{
					continue;
				}
				_ = controller.inputDevice;
				if (string.IsNullOrEmpty(controller.inputDevice.name))
				{
					continue;
				}
				if (logging)
				{
					string log = "  controller.inputDevice.name(" + controller.inputDevice.name + ")";
					Log(in log);
				}
				data.Add(controller.inputDevice.name.ToLower());
				if (logging)
				{
					string log = "  controller.inputDevice.manufacturer(" + controller.inputDevice.manufacturer + ")";
					Log(in log);
				}
				data.Add(controller.inputDevice.manufacturer.ToLower());
				if (controller.inputDevice.subsystem != null)
				{
					if (logging)
					{
						string log = $"  controller.inputDevice.subsystem({controller.inputDevice.subsystem})" ?? "";
						Log(in log);
					}
					data.Add(controller.inputDevice.subsystem.ToString().ToLower());
					if (logging)
					{
						string log = ("  controller.inputDevice.subsystem.SubsystemDescriptor.id(" + controller.inputDevice.subsystem.SubsystemDescriptor.id + ")") ?? "";
						Log(in log);
					}
					data.Add(controller.inputDevice.subsystem.SubsystemDescriptor.id.ToLower());
				}
			}
			bool currentData = false;
			int num = 0;
			foreach (string datum in data)
			{
				if (!string.IsNullOrEmpty(datum))
				{
					if (datum.Contains("oculus"))
					{
						currentData = true;
						break;
					}
					if (datum.Contains("index"))
					{
						currentData = true;
						break;
					}
					if (datum.Contains("pico"))
					{
						currentData = true;
						break;
					}
					num += datum.Length;
				}
			}
			_ = 50;
			Jisu.Utils.Singleton<MultiplayerSetting>.Instance.IsOculusController.CurrentData = currentData;
		}

		private void Log(in string log)
		{
			UnityEngine.Debug.Log(log);
		}
	}
	public class TestFireHand : MonoBehaviour
	{
		[SerializeField]
		private List<ControllerData> controllers;
	}
	public class BoxerUICtrl : LocalSingleton<BoxerUICtrl>
	{
		private Transform myTF;

		public Transform targetTF;

		private Animator anim;

		private AudioSource audioSource;

		private AudioSource audioSource_voice;

		private bool isLanguageChn;

		public AudioClip[] roundSounds_eng;

		public AudioClip[] roundSounds_chn;

		private MeshRenderer[] renderers_round;

		private MeshFilter[] meshFilter_round;

		private bool isRunning;

		private void Start()
		{
			myTF = GetComponent<Transform>();
			anim = GetComponent<Animator>();
			audioSource = GetComponent<AudioSource>();
			audioSource_voice = base.gameObject.AddComponent<AudioSource>();
			audioSource_voice.playOnAwake = false;
			audioSource_voice.loop = false;
			isRunning = false;
			base.gameObject.SetActive(value: false);
			renderers_round = new MeshRenderer[3];
			meshFilter_round = new MeshFilter[3];
			Transform transform = base.transform.Find("RoundUI/Rounds");
			for (int i = 0; i < 3; i++)
			{
				renderers_round[i] = transform.GetChild(i).GetComponent<MeshRenderer>();
				meshFilter_round[i] = transform.GetChild(i).GetComponent<MeshFilter>();
			}
			SetLocalization();
			PublicGameUIManager.gameSetting.AddLocalizationChangedEvent(SetLocalization);
		}

		private void SetLocalization()
		{
			isLanguageChn = PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.tchinese || PublicGameUIManager.gameSetting.GetLanguageState() == LanguageState.schinese;
		}

		public void Update()
		{
			if (isRunning)
			{
				myTF.LookAt(targetTF);
			}
		}

		public void StartRoundUI(int round)
		{
			isRunning = true;
			base.gameObject.SetActive(value: true);
			for (int i = 0; i < renderers_round.Length; i++)
			{
				if (round == i + 1)
				{
					renderers_round[i].enabled = true;
				}
				else
				{
					renderers_round[i].enabled = false;
				}
			}
			anim.SetTrigger("OnRound");
			OnRoundSound(round);
			Invoke("DelayOff", 3f);
		}

		private void DelayOff()
		{
			isRunning = false;
			base.gameObject.SetActive(value: false);
		}

		private void OnRoundSound(int round)
		{
			if (isLanguageChn)
			{
				audioSource.clip = roundSounds_chn[round - 1];
			}
			else
			{
				audioSource.clip = roundSounds_eng[round - 1];
			}
			audioSource.Play();
		}
	}
	public class CamEffectCtrl : LocalSingleton<CamEffectCtrl>
	{
		[SerializeField]
		private Transform CamTF;

		[SerializeField]
		private Image img_DamageBlur;

		[SerializeField]
		private Image img_FireDamageBlur;

		[SerializeField]
		private Image img_DownBlur;

		[SerializeField]
		private Image img_KO;

		private Transform canvasTF;

		private CoroutineWrapper mainWrapper;

		private CoroutineWrapper damageWrapper;

		protected override void Awake()
		{
			base.Awake();
			canvasTF = GetComponent<Transform>();
			mainWrapper = CoroutineWrapper.Generate(this);
			damageWrapper = CoroutineWrapper.Generate(this);
			img_DamageBlur.gameObject.SetActive(value: false);
			img_DownBlur.gameObject.SetActive(value: false);
			img_KO.gameObject.SetActive(value: true);
		}

		private void LateUpdate()
		{
			canvasTF.position = CamTF.position + CamTF.forward * 0.29f;
			canvasTF.LookAt(CamTF);
		}

		public void FadeIn()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(FadeIn_Coroutine(1.5f));
			IEnumerator FadeIn_Coroutine(float runtime)
			{
				img_KO.gameObject.SetActive(value: true);
				Color color = img_KO.color;
				color.a = 1f;
				img_KO.color = color;
				float time = 0f;
				while (time < runtime)
				{
					Color color2 = img_KO.color;
					color2.a = Mathf.Lerp(color2.a, 0f, time / runtime);
					img_KO.color = color2;
					time = Mathf.Clamp(time + Time.deltaTime * 0.5f, 0f, runtime);
					yield return null;
				}
				Color color3 = img_KO.color;
				color3.a = 0f;
				img_KO.color = color3;
				img_KO.gameObject.SetActive(value: false);
			}
		}

		public void FadeOut()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(FadeOut_Coroutine(1.5f));
			IEnumerator FadeOut_Coroutine(float runtime)
			{
				img_DamageBlur.gameObject.SetActive(value: false);
				img_DownBlur.gameObject.SetActive(value: false);
				img_KO.gameObject.SetActive(value: true);
				Color color = img_KO.color;
				color.a = 0f;
				img_KO.color = color;
				float time = 0f;
				while (time < runtime)
				{
					Color color2 = img_KO.color;
					color2.a = Mathf.Lerp(color2.a, 1f, time / runtime);
					img_KO.color = color2;
					time = Mathf.Clamp(time + Time.deltaTime * 0.5f, 0f, runtime);
					yield return null;
				}
				Color color3 = img_KO.color;
				color3.a = 1f;
				img_KO.color = color3;
			}
		}

		public void StartDamageEffect()
		{
			if (damageWrapper.IsPlaying)
			{
				img_FireDamageBlur.gameObject.SetActive(value: false);
				damageWrapper.Stop();
			}
			damageWrapper.Start(DamageEffectCoroutine(0.35f));
			IEnumerator DamageEffectCoroutine(float runtime)
			{
				img_DamageBlur.gameObject.SetActive(value: true);
				Color color = img_DamageBlur.color;
				color.a = 0f;
				img_DamageBlur.color = color;
				float time = 0f;
				bool isCycleOnce = false;
				while (time < runtime)
				{
					Color color2 = img_DamageBlur.color;
					if (!isCycleOnce)
					{
						color2.a = Mathf.Lerp(color2.a, 1f, time);
					}
					else
					{
						color2.a = Mathf.Lerp(color2.a, 0f, time);
					}
					img_DamageBlur.color = color2;
					time = Mathf.Clamp(time + Time.deltaTime * 0.6f, 0f, runtime);
					if (time >= runtime && !isCycleOnce)
					{
						isCycleOnce = true;
						time = 0f;
					}
					yield return null;
				}
				Color color3 = img_DamageBlur.color;
				color3.a = 0f;
				img_DamageBlur.color = color3;
				img_DamageBlur.gameObject.SetActive(value: false);
			}
		}

		public void StartFireDamageEffect()
		{
			if (damageWrapper.IsPlaying)
			{
				img_DamageBlur.gameObject.SetActive(value: false);
				damageWrapper.Stop();
			}
			damageWrapper.Start(DamageEffectCoroutine(0.75f));
			IEnumerator DamageEffectCoroutine(float runtime)
			{
				img_FireDamageBlur.gameObject.SetActive(value: true);
				Color color = img_DamageBlur.color;
				color.a = 0f;
				img_FireDamageBlur.color = color;
				float time = 0f;
				bool isCycleOnce = false;
				while (time < runtime)
				{
					Color color2 = img_FireDamageBlur.color;
					if (!isCycleOnce)
					{
						color2.a = Mathf.Lerp(color2.a, 1f, time);
					}
					else
					{
						color2.a = Mathf.Lerp(color2.a, 0f, time);
					}
					img_FireDamageBlur.color = color2;
					time = Mathf.Clamp(time + Time.deltaTime * 0.6f, 0f, runtime);
					if (time >= runtime && !isCycleOnce)
					{
						isCycleOnce = true;
						time = 0f;
					}
					yield return null;
				}
				Color color3 = img_DamageBlur.color;
				color3.a = 0f;
				img_FireDamageBlur.color = color3;
				img_FireDamageBlur.gameObject.SetActive(value: false);
			}
		}

		public void StartDownEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(DownEffectCoroutine(3f));
			IEnumerator DownEffectCoroutine(float runtime)
			{
				img_DamageBlur.gameObject.SetActive(value: false);
				img_DownBlur.gameObject.SetActive(value: true);
				Color color = img_DownBlur.color;
				color.a = 0f;
				img_DownBlur.color = color;
				float time = 0f;
				while (time < runtime)
				{
					Color color2 = img_DownBlur.color;
					color2.a = Mathf.Lerp(color2.a, 1f, time / runtime);
					img_DownBlur.color = color2;
					time = Mathf.Clamp(time + Time.deltaTime, 0f, runtime);
					yield return null;
				}
				Color color3 = img_DownBlur.color;
				color3.a = 1f;
				img_DownBlur.color = color3;
			}
		}

		public void StartWakeUpEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(WakeUpEffectCoroutine(3f));
			IEnumerator WakeUpEffectCoroutine(float runtime)
			{
				Color color = img_DownBlur.color;
				color.a = 1f;
				img_DownBlur.color = color;
				float time = 0f;
				while (time < runtime)
				{
					Color color2 = img_DownBlur.color;
					color2.a = Mathf.Lerp(color2.a, 0f, time / runtime);
					img_DownBlur.color = color2;
					time = Mathf.Clamp(time + Time.deltaTime * 0.3f, 0f, runtime);
					yield return null;
				}
				Color color3 = img_DownBlur.color;
				color3.a = 0f;
				img_DownBlur.color = color3;
				img_DownBlur.gameObject.SetActive(value: false);
			}
		}

		public void StartKOEffect()
		{
			if (mainWrapper.IsPlaying)
			{
				mainWrapper.Stop();
			}
			mainWrapper.Start(DownEffectCoroutine(1.5f));
			IEnumerator DownEffectCoroutine(float runtime)
			{
				img_KO.gameObject.SetActive(value: true);
				Color color = img_KO.color;
				color.a = 0f;
				img_KO.color = color;
				float time = 0f;
				while (time < runtime)
				{
					Color color2 = img_KO.color;
					color2.a = Mathf.Lerp(color2.a, 1f, time / runtime);
					img_KO.color = color2;
					time = Mathf.Clamp(time + Time.deltaTime * 0.5f, 0f, runtime);
					yield return null;
				}
				Color color3 = img_KO.color;
				color3.a = 1f;
				img_KO.color = color3;
			}
		}
	}
	public class HowToPlay : MonoBehaviour
	{
		private CanvasGroup helper;

		private void Awake()
		{
			helper = GetComponent<CanvasGroup>();
		}

		public void SetWindow(bool isSet)
		{
			if (isSet)
			{
				StartCoroutine(SetWindow_Coroutine(1f, 0.5f));
			}
			else
			{
				StartCoroutine(SetWindow_Coroutine(0f, 0.5f));
			}
		}

		private IEnumerator SetWindow_Coroutine(float targetAlpha, float runTime)
		{
			float time = 0f;
			float originAlpha = helper.alpha;
			while (time < runTime)
			{
				helper.alpha = Mathf.Lerp(originAlpha, targetAlpha, time / runTime);
				time += Time.deltaTime;
				yield return null;
			}
			helper.alpha = targetAlpha;
		}
	}
	public class UIPlayerHPGauge : MonoBehaviour
	{
		public enum PlayerType
		{
			None,
			LocalPlayer,
			RemotePlayer
		}

		public enum HPType
		{
			None,
			MainHP,
			TempHP
		}

		[SerializeField]
		private PlayerType playerType;

		[SerializeField]
		private HPType hpType;

		[SerializeField]
		private Image preGauge;

		[SerializeField]
		private Image postGauge;

		[SerializeField]
		private Text PlayerName;

		[SerializeField]
		private List<Image> FireHandActiveCover;

		[SerializeField]
		private AnimationCurve curve;

		[SerializeField]
		private float decreaseTime;

		private bool isInitialized;

		private CoroutineWrapper wrapper;

		private int MaxValue;

		private IPlayerData target;

		private Jisu.Utils.INotifiable<int> targetHP;

		protected virtual void Awake()
		{
			wrapper = new CoroutineWrapper(this);
			preGauge.fillAmount = 1f;
			postGauge.fillAmount = 1f;
			Initialize();
		}

		private void Initialize()
		{
			switch (playerType)
			{
			default:
				return;
			case PlayerType.LocalPlayer:
				target = Jisu.Utils.Singleton<LocalPlayerData>.Instance;
				break;
			case PlayerType.RemotePlayer:
				target = Jisu.Utils.Singleton<RemotePlayerData>.Instance;
				break;
			}
			switch (hpType)
			{
			case HPType.MainHP:
				targetHP = target.MainHPNotifier;
				MaxValue = 3000;
				break;
			case HPType.TempHP:
				targetHP = target.TempHPNotifier;
				MaxValue = 1000;
				break;
			}
			targetHP.OnDataChanged += TargetHP_OnDataChanged;
			SetName();
			if (FireHandActiveCover != null && FireHandActiveCover.Count > 0)
			{
				target.FireHandCountNotifier.OnDataChanged += FireHandCountNotifier_OnDataChanged;
				for (int i = 0; i < 3; i++)
				{
					FireHandActiveCover[i].gameObject.SetActive(value: true);
				}
			}
			isInitialized = true;
		}

		private void SetName()
		{
			if (SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos != null && SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos.Length >= 2 && !(PlayerName == null))
			{
				UserInfoManager.UserInfo userInfo_mine = SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfo_mine;
				UserInfoManager.UserInfo userInfo = ((SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0].id == userInfo_mine.id) ? SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[1] : SingletonBase.Singleton<UserInfoManager>.GetInstance.userInfos[0]);
				switch (playerType)
				{
				case PlayerType.LocalPlayer:
					PlayerName.text = userInfo_mine.nick;
					break;
				case PlayerType.RemotePlayer:
					PlayerName.text = userInfo.nick;
					break;
				}
			}
		}

		private void FireHandCountNotifier_OnDataChanged(int count)
		{
			for (int i = 0; i < 3; i++)
			{
				FireHandActiveCover[i].gameObject.SetActive(i < count);
			}
		}

		private void TargetHP_OnDataChanged(int targetHP)
		{
			float end = (float)targetHP / (float)MaxValue;
			UpdateGauge(in end);
		}

		public void UpdateGauge(in float end)
		{
			switch (hpType)
			{
			case HPType.MainHP:
				wrapper.StartSingleton(runHPDecrease(end, decreaseTime * 0.5f));
				break;
			case HPType.TempHP:
				wrapper.StartSingleton(runTempHPDecrease(end, decreaseTime * 0.5f));
				break;
			}
		}

		private IEnumerator runTempHPDecrease(float end, float runtime = 1f)
		{
			float t = 0f;
			float preStart = preGauge.fillAmount;
			while (t < runtime)
			{
				preGauge.fillAmount = Mathf.Lerp(preStart, end, curve.Evaluate(t / runtime));
				postGauge.fillAmount = Mathf.Lerp(postGauge.fillAmount, preGauge.fillAmount, 0.25f);
				t += Time.unscaledDeltaTime;
				yield return null;
			}
		}

		private IEnumerator runHPDecrease(float end, float runtime = 1f)
		{
			float t2 = 0f;
			float preStart = preGauge.fillAmount;
			while (t2 < runtime)
			{
				preGauge.fillAmount = Mathf.Lerp(preStart, end, curve.Evaluate(t2 / runtime));
				t2 += Time.unscaledDeltaTime;
				yield return null;
			}
			preGauge.fillAmount = end;
			t2 = 0f;
			float postStart = postGauge.fillAmount;
			while (t2 < runtime)
			{
				postGauge.fillAmount = Mathf.Lerp(postStart, end, curve.Evaluate(t2 / runtime));
				t2 += Time.unscaledDeltaTime * 2f;
				yield return null;
			}
			postGauge.fillAmount = end;
		}

		private void OnDestroy()
		{
			Release();
		}

		private void Release()
		{
			if (isInitialized)
			{
				target.FireHandCountNotifier.OnDataChanged -= FireHandCountNotifier_OnDataChanged;
				targetHP.OnDataChanged -= TargetHP_OnDataChanged;
			}
		}
	}
	public class UIStart : MonoBehaviour
	{
		[SerializeField]
		private CanvasGroup group;

		[SerializeField]
		private AnimationCurve curve;

		private CoroutineWrapper wrapper;

		private void Awake()
		{
			wrapper = new CoroutineWrapper(this);
			LocalSingleton<MultiGameManager>.OnInitialized += delegate(MultiGameManager multiGameManager)
			{
				multiGameManager.OnRoundChangeStarted += MultiGameManager_OnRoundChangeStarted;
				multiGameManager.isEnd.OnDataChanged += IsEnd_OnDataChanged;
			};
		}

		private void MultiGameManager_OnRoundChangeStarted()
		{
			wrapper.StartSingleton(RunAnimation(10f));
		}

		private void IsEnd_OnDataChanged(bool isEnd)
		{
			if (isEnd)
			{
				group.alpha = curve.Evaluate(0.5f);
			}
		}

		private IEnumerator RunAnimation(float runtime)
		{
			float t = 0f;
			while (t < runtime)
			{
				t += Time.deltaTime;
				yield return null;
				group.alpha = curve.Evaluate(t / runtime);
			}
			group.alpha = curve.Evaluate(1f);
		}

		private void OnDestroy()
		{
			if (LocalSingleton<MultiGameManager>.TryGetInstance(out var instance))
			{
				instance.OnRoundChangeStarted -= MultiGameManager_OnRoundChangeStarted;
				instance.isEnd.OnDataChanged -= IsEnd_OnDataChanged;
			}
		}
	}
	public class PlanarShadow : MonoBehaviour
	{
		public float planeHeight;

		private void Start()
		{
			if ((bool)GetComponent<Renderer>())
			{
				GetComponent<Renderer>().material.SetFloat("planeHeight", planeHeight);
			}
		}
	}
	public class DebugHPBar : MonoBehaviour
	{
		[SerializeField]
		private Image tempGauge;

		private float targetFirstAmount;

		[SerializeField]
		private Image mainGauge;

		private float targetSecondAmount;

		[SerializeField]
		private Text tempAmount;

		[SerializeField]
		private Text mainAmount;

		private void OnEnable()
		{
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.MainHP.OnDataChanged += MainHP_OnDataChanged;
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.TempHP.OnDataChanged += TempHP_OnDataChanged;
		}

		private void TempHP_OnDataChanged(int tempHP)
		{
			targetFirstAmount = (float)tempHP / 1000f;
			tempAmount.text = tempHP.ToString();
		}

		private void MainHP_OnDataChanged(int mainHP)
		{
			targetSecondAmount = (float)mainHP / 3000f;
			mainAmount.text = mainHP.ToString();
		}

		private void Update()
		{
			tempGauge.fillAmount = Mathf.Lerp(tempGauge.fillAmount, targetFirstAmount, 0.12f);
			mainGauge.fillAmount = Mathf.Lerp(mainGauge.fillAmount, targetSecondAmount, 0.12f);
		}

		private void OnDisable()
		{
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.TempHP.OnDataChanged -= TempHP_OnDataChanged;
			Jisu.Utils.Singleton<RemotePlayerData>.Instance.MainHP.OnDataChanged -= MainHP_OnDataChanged;
		}
	}
	[Obsolete]
	public class HitReactionVRIKTriggerTest : MonoBehaviour
	{
		public HitReactionVRIK hitReaction;

		public float hitForce = 1f;

		private string colliderName;

		private void Update()
		{
			Input.GetMouseButtonDown(0);
		}

		private void OnGUI()
		{
			GUILayout.Label("LMB to shoot the Dummy, RMB to rotate the camera.");
			if (colliderName != string.Empty)
			{
				GUILayout.Label("Last Bone Hit: " + colliderName);
			}
		}
	}
	public class LightMovement : MonoBehaviour
	{
		[Serializable]
		public class RotationTransform
		{
			[SerializeField]
			private Transform target;

			[SerializeField]
			private Vector3 axis;

			[SerializeField]
			private Vector3 offset;

			[SerializeField]
			private AnimationCurve curve;

			[SerializeField]
			private float speed;

			public void Update(in float timeOffset)
			{
				target.transform.localEulerAngles = offset + axis * curve.Evaluate(Mathf.Repeat(timeOffset + Time.time * speed, 1f));
			}
		}

		[SerializeField]
		private bool isRandomizeTimeOffset;

		[SerializeField]
		[Range(0f, 1f)]
		private float TimeOffset;

		[SerializeField]
		private List<RotationTransform> transforms = new List<RotationTransform>();

		private void Awake()
		{
			if (isRandomizeTimeOffset)
			{
				TimeOffset = UnityEngine.Random.Range(0f, 1f);
			}
		}

		private void Update()
		{
			foreach (RotationTransform transform in transforms)
			{
				transform.Update(in TimeOffset);
			}
		}
	}
	public class LocalEulerRotationDebugger : MonoBehaviour
	{
		[SerializeField]
		private VRIK root;

		[SerializeField]
		private Vector3 LocalEuler;

		[SerializeField]
		private Vector3 WorldEuler;

		[SerializeField]
		private Vector4 LocalRotation;

		[SerializeField]
		private float Test;

		private void OnEnable()
		{
			IKSolverVR solver = root.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
		}

		private void OnPostUpdate()
		{
			LocalEuler = base.transform.localEulerAngles;
			WorldEuler = base.transform.eulerAngles;
			LocalRotation = new Vector4(base.transform.localRotation.x, base.transform.localRotation.y, base.transform.localRotation.z, base.transform.localRotation.w);
		}

		private void OnDisable()
		{
			IKSolverVR solver = root.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(OnPostUpdate));
		}
	}
	public class PhotonTest : MonoBehaviour
	{
		private void Start()
		{
			UnityEngine.Debug.Log(PhotonSingleton<PhotonManager>.Instance.photonView);
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.StartConnect();
			};
			PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
			{
				instance.ConnectionState.OnDataChanged += ConnectionState_OnDataChanged;
			};
		}

		private void ConnectionState_OnDataChanged(string obj)
		{
			UnityEngine.Debug.Log("ConnectionState_OnDataChanged : " + obj);
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Escape))
			{
				PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
				{
					instance.StartDisconnect();
				};
			}
			if (Input.GetKeyDown(KeyCode.C))
			{
				PhotonSingleton<PhotonManager>.OnInitialized += delegate(PhotonManager instance)
				{
					instance.StartConnect();
				};
			}
		}
	}
	public class GrabScreenFeature : ScriptableRendererFeature
	{
		[Serializable]
		public class Settings
		{
			public string TextureName = "_GrabPassOpaque";

			public string PrevTextureName = "_PrevGrabPassOpaque";

			public LayerMask LayerMask;

			public RenderPassEvent grabPassEvent;

			public RenderPassEvent renderPassEvent;
		}

		private class GrabPass : ScriptableRenderPass
		{
			private RenderTargetHandle tempColorTarget;

			private RenderTargetHandle prevTempColorTarget;

			private Settings settings;

			private RenderTargetIdentifier cameraTarget;

			public GrabPass(Settings s)
			{
				settings = s;
				base.renderPassEvent = s.grabPassEvent;
				tempColorTarget.Init(settings.TextureName);
				prevTempColorTarget.Init(settings.PrevTextureName);
			}

			public void Setup(RenderTargetIdentifier cameraTarget)
			{
				this.cameraTarget = cameraTarget;
			}

			public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
			{
				cmd.GetTemporaryRT(tempColorTarget.id, cameraTextureDescriptor);
				cmd.GetTemporaryRT(prevTempColorTarget.id, cameraTextureDescriptor);
				cmd.SetGlobalTexture(settings.TextureName, tempColorTarget.Identifier());
				cmd.SetGlobalTexture(settings.PrevTextureName, prevTempColorTarget.Identifier());
			}

			public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
			{
				CommandBuffer commandBuffer = CommandBufferPool.Get();
				context.ExecuteCommandBuffer(commandBuffer);
				commandBuffer.Clear();
				Blit(commandBuffer, tempColorTarget.Identifier(), prevTempColorTarget.Identifier());
				Blit(commandBuffer, cameraTarget, tempColorTarget.Identifier());
				context.ExecuteCommandBuffer(commandBuffer);
				CommandBufferPool.Release(commandBuffer);
			}

			public override void FrameCleanup(CommandBuffer cmd)
			{
				cmd.ReleaseTemporaryRT(tempColorTarget.id);
				cmd.ReleaseTemporaryRT(prevTempColorTarget.id);
			}
		}

		private class RenderPass : ScriptableRenderPass
		{
			private Settings settings;

			private List<ShaderTagId> m_ShaderTagIdList = new List<ShaderTagId>();

			private FilteringSettings m_FilteringSettings;

			private RenderStateBlock m_RenderStateBlock;

			public RenderPass(Settings settings)
			{
				this.settings = settings;
				base.renderPassEvent = settings.renderPassEvent + 1;
				m_ShaderTagIdList.Add(new ShaderTagId("SRPDefaultUnlit"));
				m_ShaderTagIdList.Add(new ShaderTagId("UniversalForward"));
				m_ShaderTagIdList.Add(new ShaderTagId("LightweightForward"));
				m_FilteringSettings = new FilteringSettings(RenderQueueRange.opaque, settings.LayerMask);
				m_RenderStateBlock = new RenderStateBlock(RenderStateMask.Nothing);
			}

			public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
			{
				CommandBuffer commandBuffer = CommandBufferPool.Get();
				context.ExecuteCommandBuffer(commandBuffer);
				commandBuffer.Clear();
				DrawingSettings drawingSettings = CreateDrawingSettings(m_ShaderTagIdList, ref renderingData, SortingCriteria.CommonOpaque);
				context.DrawRenderers(renderingData.cullResults, ref drawingSettings, ref m_FilteringSettings, ref m_RenderStateBlock);
				context.ExecuteCommandBuffer(commandBuffer);
				CommandBufferPool.Release(commandBuffer);
			}
		}

		private GrabPass grabPass;

		private RenderPass renderPass;

		[SerializeField]
		private Settings settings = new Settings();

		public override void Create()
		{
			grabPass = new GrabPass(settings);
			renderPass = new RenderPass(settings);
		}

		public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
		{
			grabPass.Setup(renderer.cameraColorTarget);
			renderer.EnqueuePass(grabPass);
			renderer.EnqueuePass(renderPass);
		}
	}
	public class RenderScreenFeature : ScriptableRendererFeature
	{
		[Serializable]
		public class Settings
		{
			public string PrevTextureName = "_PrevGrabPassOpaque";

			public LayerMask LayerMask;
		}

		private class GrabPass : ScriptableRenderPass
		{
			private RenderTargetHandle prevTempColorTarget;

			private Settings settings;

			private RenderTargetIdentifier cameraTarget;

			public GrabPass(Settings s)
			{
				settings = s;
				base.renderPassEvent = RenderPassEvent.AfterRenderingOpaques;
				prevTempColorTarget.Init(settings.PrevTextureName);
			}

			public void Setup(RenderTargetIdentifier cameraTarget)
			{
				this.cameraTarget = cameraTarget;
			}

			public override void Configure(CommandBuffer cmd, RenderTextureDescriptor cameraTextureDescriptor)
			{
				cmd.GetTemporaryRT(prevTempColorTarget.id, cameraTextureDescriptor);
				cmd.SetGlobalTexture(settings.PrevTextureName, prevTempColorTarget.Identifier());
			}

			public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
			{
				CommandBuffer commandBuffer = CommandBufferPool.Get();
				context.ExecuteCommandBuffer(commandBuffer);
				commandBuffer.Clear();
				Blit(commandBuffer, cameraTarget, prevTempColorTarget.Identifier());
				context.ExecuteCommandBuffer(commandBuffer);
				CommandBufferPool.Release(commandBuffer);
			}

			public override void FrameCleanup(CommandBuffer cmd)
			{
				cmd.ReleaseTemporaryRT(prevTempColorTarget.id);
			}
		}

		private class RenderPass : ScriptableRenderPass
		{
			private Settings settings;

			private List<ShaderTagId> m_ShaderTagIdList = new List<ShaderTagId>();

			private FilteringSettings m_FilteringSettings;

			private RenderStateBlock m_RenderStateBlock;

			public RenderPass(Settings settings)
			{
				this.settings = settings;
				base.renderPassEvent = (RenderPassEvent)301;
				m_ShaderTagIdList.Add(new ShaderTagId("SRPDefaultUnlit"));
				m_ShaderTagIdList.Add(new ShaderTagId("UniversalForward"));
				m_ShaderTagIdList.Add(new ShaderTagId("LightweightForward"));
				m_FilteringSettings = new FilteringSettings(RenderQueueRange.all, settings.LayerMask);
				m_RenderStateBlock = new RenderStateBlock(RenderStateMask.Nothing);
			}

			public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)
			{
				CommandBuffer commandBuffer = CommandBufferPool.Get();
				context.ExecuteCommandBuffer(commandBuffer);
				commandBuffer.Clear();
				DrawingSettings drawingSettings = CreateDrawingSettings(m_ShaderTagIdList, ref renderingData, SortingCriteria.CommonOpaque);
				context.DrawRenderers(renderingData.cullResults, ref drawingSettings, ref m_FilteringSettings, ref m_RenderStateBlock);
				context.ExecuteCommandBuffer(commandBuffer);
				CommandBufferPool.Release(commandBuffer);
			}
		}

		private GrabPass grabPass;

		[SerializeField]
		private Settings settings = new Settings();

		public override void Create()
		{
			grabPass = new GrabPass(settings);
		}

		public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)
		{
			grabPass.Setup(renderer.cameraColorTarget);
			renderer.EnqueuePass(grabPass);
		}
	}
	public class RingRopeControl : MonoBehaviour
	{
		[Serializable]
		public class Line
		{
			public List<Transform> positions;

			public List<Vector3> defaultPositions;

			public List<Vector3> offset;

			public int Count;

			public Collider collider;

			private CoroutineWrapper wrapper;

			private AnimationCurve curve;

			private float UpdateSpeed;

			private float StartTime;

			private Vector3 LastImpactVector;

			public Transform this[int index] => positions[index];

			public int this[Transform target] => positions.IndexOf(target);

			public void Initialize(in MonoBehaviour runner, in AnimationCurve curve)
			{
				UpdateSpeed = 1f;
				Count = positions.Count;
				wrapper = new CoroutineWrapper(runner);
				this.curve = curve;
				offset = new List<Vector3>();
				defaultPositions = new List<Vector3>();
				foreach (Transform position in positions)
				{
					offset.Add(Vector3.zero);
					defaultPositions.Add(position.position);
				}
			}

			public void ImpactEnvironment(Vector3 vector)
			{
				Impact(Count / 2, vector);
			}

			public void Impact(int index, Vector3 vector)
			{
				float num = LastImpactVector.magnitude * curve.Evaluate(Mathf.Repeat((Time.time - StartTime) * UpdateSpeed, 1f));
				if (vector.magnitude < num)
				{
					return;
				}
				for (int i = 0; i < Count; i++)
				{
					int num2 = Mathf.Abs(i - index) + 1;
					float num3 = 1f / (float)num2;
					if (i == 0 || i == Count - 1)
					{
						num3 *= 0.25f;
					}
					offset[i] = Vector3.ClampMagnitude(vector, 0.5f) * num3;
				}
				LastImpactVector = vector;
				UpdateSpeed = 4f;
				StartTime = Time.time;
				wrapper.StartSingleton(Update());
			}

			private IEnumerator Update()
			{
				float lerpFactor = UnityEngine.Random.Range(0.2f, 0.4f);
				while (wrapper.Runner.enabled)
				{
					for (int i = 0; i < Count; i++)
					{
						float num = curve.Evaluate(Mathf.Repeat((Time.time - StartTime) * UpdateSpeed, 1f));
						positions[i].position = Vector3.Lerp(positions[i].position, defaultPositions[i] + offset[i] * num, lerpFactor);
						float num2 = UnityEngine.Random.Range(0.99f, 0.9975f) * 0.99f;
						float num3 = UnityEngine.Random.Range(0.98f, 0.995f) * 0.99f;
						offset[i] *= num2;
						offset[i].Set(offset[i].x * num2, offset[i].y * num3, offset[i].z * num2);
					}
					UpdateSpeed = Mathf.Lerp(UpdateSpeed, 2f, lerpFactor);
					yield return null;
				}
			}

			public Transform GetClosestTransform(Vector3 position)
			{
				return positions.Aggregate(this[0], (Transform min, Transform target) => (!((min.position - position).magnitude > (target.position - position).magnitude)) ? min : target, (Transform pos) => pos);
			}
		}

		[SerializeField]
		private AnimationCurve curve;

		[SerializeField]
		private List<Collider> Detectors;

		private Dictionary<Line, int> LastHitIndexDict = new Dictionary<Line, int>();

		public List<Line> lines = new List<Line>();

		private void Awake()
		{
			foreach (Line line in lines)
			{
				MonoBehaviour runner = this;
				line.Initialize(in runner, in curve);
			}
		}

		private void Update()
		{
			foreach (Line line2 in lines)
			{
				Line line = line2;
				foreach (Collider detector in Detectors)
				{
					if (detector.gameObject.activeInHierarchy && detector.ComputePenetration(line.collider, out var dir, out var dis))
					{
						line.collider.ComputePenetration(detector, out var dir2, out var dis2);
						Vector3 origin = detector.transform.position + dir2 * dis2;
						if (line.collider.Raycast(new Ray(origin, -(dir2 * dis2)), out var hitInfo, 2f))
						{
							Vector3 decomposition = dir * dis;
							SendImpact(in line, in hitInfo, in decomposition);
						}
						else
						{
							Vector3 decomposition = dir * dis;
							SendSavedImpact(in line, in decomposition);
						}
					}
				}
			}
		}

		public void OnFootstep()
		{
			foreach (Line line in lines)
			{
				line.ImpactEnvironment(Vector3.down * UnityEngine.Random.Range(0.05f, 0.1f) * 0.15f);
			}
		}

		private void SendSavedImpact(in Line line, in Vector3 decomposition)
		{
			if (LastHitIndexDict.TryGetValue(line, out var value))
			{
				line.Impact(value, decomposition);
			}
		}

		private void SendImpact(in Line line, in RaycastHit hitInfo, in Vector3 decomposition)
		{
			Transform closestTransform = line.GetClosestTransform(hitInfo.point);
			int num = line[closestTransform];
			LastHitIndexDict[line] = num;
			line.Impact(num, decomposition);
		}
	}
	public class TestFootAnimation : MonoBehaviour
	{
		[Serializable]
		public class Foot
		{
			public Transform target;

			public AnimationCurve heightCurve;

			public Vector3 axis;

			public AnimationCurve moveCurve;

			public float timeOffset;

			public float speed;

			public Vector3 positionOffset;

			private Vector3 targetPosition;

			public void UpdateTarget(in Vector3 position)
			{
				targetPosition = position;
			}

			public void UpdatePosition()
			{
				float time = Mathf.Repeat(timeOffset + Time.time * speed, 1f);
				float y = heightCurve.Evaluate(time);
				Vector3 vector = target.rotation * axis * moveCurve.Evaluate(time);
				Vector2 xzVector = Jisu.Utils.VectorExtension.ToXZ(in vector);
				Vector3 vector2 = Jisu.Utils.VectorExtension.ToVector3FromXZ(in xzVector, y);
				target.TransformPoint(vector2 + positionOffset);
				target.position = targetPosition + (vector2 + target.rotation * positionOffset);
			}
		}

		[SerializeField]
		private VRIK root;

		[SerializeField]
		private Foot Left = new Foot();

		[SerializeField]
		private Foot Right = new Foot();

		private void OnEnable()
		{
			root.solver.locomotion.onLeftFootstep.AddListener(OnLeftFootStep);
			root.solver.locomotion.onRightFootstep.AddListener(OnRightFootStep);
		}

		private void OnLeftFootStep()
		{
			Foot left = Left;
			Vector3 position = root.solver.locomotion.leftFootstepPosition;
			left.UpdateTarget(in position);
		}

		private void OnRightFootStep()
		{
			Foot right = Right;
			Vector3 position = root.solver.locomotion.rightFootstepPosition;
			right.UpdateTarget(in position);
		}

		private void Update()
		{
			Left.UpdatePosition();
			Right.UpdatePosition();
		}

		private void OnDisable()
		{
			root.solver.locomotion.onLeftFootstep.RemoveListener(OnLeftFootStep);
			root.solver.locomotion.onRightFootstep.RemoveListener(OnRightFootStep);
		}
	}
	[Obsolete]
	public class TestMovement : MonoBehaviour
	{
		[SerializeField]
		private VRIK root;

		[SerializeField]
		private List<Transform> TargetPositions;

		[SerializeField]
		private Transform Probe;

		[SerializeField]
		private List<Transform> FootstepObjects;

		[SerializeField]
		private AnimationCurve curve;

		[SerializeField]
		private float Speed;

		[SerializeField]
		private float VelocityFactor;

		private Jisu.Utils.Notifier<Vector3> LeftFootStepPosition = new Jisu.Utils.Notifier<Vector3>();

		private Jisu.Utils.Notifier<Vector3> RightFootStepPosition = new Jisu.Utils.Notifier<Vector3>();

		private int idx;

		private Transform LastTarget;

		private Transform CurrentTarget => TargetPositions[idx];

		private IEnumerator Start()
		{
			idx = 0;
			LastTarget = TargetPositions.Last();
			float t = 0f;
			LeftFootStepPosition.OnDataChangedDelta += LeftFootStepPosition_OnDataChangedDelta;
			RightFootStepPosition.OnDataChangedDelta += RightFootStepPosition_OnDataChangedDelta;
			while (base.enabled)
			{
				if ((Probe.position - CurrentTarget.position).magnitude < 0.1f)
				{
					LastTarget = CurrentTarget;
					idx = (idx + 1) % TargetPositions.Count;
					t = 0f;
				}
				Vector3 position = Probe.transform.position;
				Probe.transform.position = Vector3.Lerp(Probe.transform.position, Vector3.Lerp(LastTarget.position, CurrentTarget.position, curve.Evaluate(t)), 0.5f);
				Vector3 position2 = Probe.transform.position;
				root.solver.locomotion.velocityFactor = (position2 - position).magnitude * VelocityFactor;
				t += Time.deltaTime * Speed;
				yield return null;
			}
		}

		private void RightFootStepPosition_OnDataChangedDelta(Vector3 prev, Vector3 next)
		{
			FootstepObjects[0].position = prev;
			FootstepObjects[1].position = next;
		}

		private void LeftFootStepPosition_OnDataChangedDelta(Vector3 prev, Vector3 next)
		{
			FootstepObjects[2].position = prev;
			FootstepObjects[3].position = next;
		}

		private void OnLeftFootStep()
		{
			LeftFootStepPosition.CurrentData = root.solver.locomotion.leftFootstepPosition;
		}

		private void OnRightFootStep()
		{
			RightFootStepPosition.CurrentData = root.solver.locomotion.rightFootstepPosition;
		}
	}
	public class TestPenetration : MonoBehaviour
	{
		[SerializeField]
		private Collider colliderA;

		[SerializeField]
		private Collider colliderB;

		[SerializeField]
		private bool Enabled;

		private GameObject CachedObject;

		private GameObject CachedObject2;

		private void Update()
		{
			if (Enabled)
			{
				if (CachedObject != null)
				{
					UnityEngine.Object.Destroy(CachedObject);
				}
				Vector3 center = colliderA.bounds.center;
				UnityEngine.Debug.Log("colliderA.position " + center);
				CachedObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
				CachedObject.transform.position = center;
				CachedObject.transform.localScale = colliderA.bounds.size;
				Enabled = false;
			}
			if (Physics.ComputePenetration(colliderA, colliderA.transform.position, colliderA.transform.rotation, colliderB, colliderB.transform.position, colliderB.transform.rotation, out var direction, out var distance))
			{
				if (CachedObject2 != null)
				{
					UnityEngine.Object.Destroy(CachedObject2);
				}
				CachedObject2 = UnityEngine.Object.Instantiate(colliderB.gameObject);
				CachedObject2.transform.position = colliderB.transform.position;
				CachedObject2.transform.rotation = colliderB.transform.rotation;
				CachedObject2.transform.localScale = colliderB.transform.localScale;
				CachedObject2.transform.position -= direction * distance;
			}
		}
	}
	public class TestVectorDot : MonoBehaviour
	{
		[SerializeField]
		private Transform Center;

		[SerializeField]
		private Transform reference;

		[SerializeField]
		private Transform other;

		[SerializeField]
		private Transform result;

		private void Update()
		{
			Vector3 vector = reference.position - Center.position;
			Vector3 vector2 = other.position - Center.position;
			result.localPosition = Vector3.LerpUnclamped(vector, vector2, Vector3.Dot(vector, vector2) * 0.5f + 0.5f);
		}
	}
}
namespace SingletonPunBase
{
	public abstract class Singleton<T> : MonoBehaviourPunCallbacks where T : MonoBehaviourPunCallbacks
	{
		protected static T Instance;

		public static T GetInstance
		{
			get
			{
				if (Instance == null)
				{
					return new GameObject(typeof(T).Name).AddComponent<T>();
				}
				return Instance;
			}
		}

		protected virtual void Awake()
		{
			if (Instance == null)
			{
				Instance = this as T;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
namespace SingletonBase
{
	public abstract class Singleton<T> : MonoBehaviour where T : MonoBehaviour
	{
		protected static T Instance;

		public static bool IsInstance
		{
			get
			{
				if (Instance == null)
				{
					return false;
				}
				return true;
			}
		}

		public static T GetInstance
		{
			get
			{
				if (Instance == null)
				{
					return new GameObject(typeof(T).Name).AddComponent<T>();
				}
				return Instance;
			}
		}

		protected virtual void Awake()
		{
			if (Instance == null)
			{
				Instance = this as T;
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
}
namespace Appnori
{
	public static class Layer
	{
		public enum GameType
		{
			None,
			Billiards,
			Archery,
			Basketball,
			Bowling,
			Badminton,
			Golf,
			PingPong,
			Lobby,
			Test,
			Dart,
			Baseball,
			Boxing,
			Boxing_HB,
			Boxing_DM,
			Boxing_AI,
			Tennis,
			Boxing_MT
		}

		private const string billiardsMatrix = "c90480ffc80080ffc84480ffffffffffc80080ffc80081ffffffffffffffffffc806a0ffc85d80ffcd5fb8ffc80680ffc80680ffc80080ffcc0680ffc80080ffe80081ffc80080ffc80084ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string ArMatrix = "c802feffc804feffc840feffffffffffc808feffc800ffffffffffffffffffffc806feffc95dfeffca5ffeffd806feffc806feffc800feffcc06feffc800feffe800ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string ArhceryMatrix = "c80000fac80000fac80000faffffffffc80000fac80000faffffffffffffffffc81420fec80000fac80536f9c80010fac81100fac80000fac80000fac80000fac80000fac80400fac8041cfac80004fac80c34fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";

		private const string BasketballMatrix = "c80000fac80000fac80000faffffffffc80000fac80000faffffffffffffffffc80420fec80000fac80536f9c80010fac80000fac80000fac80000fac80000fac80000fac80400fac8041cfac80004fac80c34fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";

		private const string BowlingMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc824a0ffc80080ffc805beffc80080ffc80080ffc80180ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string BadmintonMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc824a0ffc80080ffc805beffc80080ffc80080ffc80180ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string LobbyMatrix = "c90400fac80000fac80000faffffffffc80000fac80000faffffffffffffffffc81420fec80000fac90536f9c80010fac81100fac80000fac80000fac80000fac80000fac80400fac8041cfac80004fac80c34fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";

		private const string TestMatrix = "c9001cfac80000fae80000faffffffffc80000facc0001faffffffffffffffffc80420fec80000fac87d3ef9c80400fac80400fac80400fac84400fac80000fae80001fac80402fac90404fac90408fac90420fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";

		private const string GolfMatrix = "ffc3ffffff83ffffff83ffffffffffffff83ffffff83ffffffffffffffffffffff83ffffff85ffffc882ffffc890ffffc888ffffc880ffffc980ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string PingPongMatrix = "c80480ffc80080ffc80080ffffffffffc80080ffe80080ffffffffffffffffffc800a0ffc80480ffc902beffc80080ffc80080ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string DartMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc800a0ffc80080ffc818beffc80480ffc80480ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string BaseballMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc800a0ffc80080ffc818beffc80480ffc80480ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string BoxMatrix = "c90180ffc80080ffc84080ffffffffffc80080ffc80081ffffffffffffffffffc906a0ffc85980ffc859beffc80680ffc80680ffc80080ffcc0680ffc80080ffe80081ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string BoxingHBMatrix = "7ffdffff7ffdffff7ffdffffffffffff7ffdffff7ffdffffbfffffff48feffff7ffeffffc8fdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string BoxingDMMatrix = "ffffffffffffffffffffffffb7ffffffffffffffffffffffb7fffffffffffffffffffffffffdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string BoxingAIMatrix = "ff0080ffff0080ffff4080ffffffffffff0080ffff0081ffffffffffffffffffc803a0ffc84580ffc842beffc80080ffc80080ffc80080ffcc0680ffc80080ffe80081ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string BoxingMTMatrix = "ff0080ffff0080ffff4080ffffffffffff0080ffff0081ffffffffffffffffffc803a0ffc84580ffc842beffc80080ffc80080ffc80080ffcc0680ffc80080ffe80081ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private const string TennisMatrix = "c80480ffc80080ffc80080ffffffffffc80080ffe80080ffffffffffffffffffc800a0ffc80480ffc902beffc80080ffc80080ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

		private static ReadOnlyCollection<string> BoxingHBMatrixLayers { get; } = new ReadOnlyCollection<string>(new string[2] { "Glove", "SandBag" });


		private static ReadOnlyCollection<string> BoxingDMMatrixLayers { get; } = new ReadOnlyCollection<string>(new string[3] { "Glove", "Dummy", "DummyBoundary" });


		private static ReadOnlyCollection<string> BoxingAIMatrixLayers { get; } = new ReadOnlyCollection<string>(new string[5] { "Player", "Enemy", "Ring", "Brando", "Crowd" });


		private static ReadOnlyCollection<string> BoxingMTMatrixLayers { get; } = new ReadOnlyCollection<string>(new string[0]);


		private static ReadOnlyCollection<string> billiardsMatrixLayers { get; } = new ReadOnlyCollection<string>(new string[11]
		{
			"Cloth", "CueBall", "Ball", "Board", "Pocket", "NoVisible", "Ceiling", "CueControl", "RayReactor", "Character",
			"Permit"
		});


		private static ReadOnlyCollection<string> basketballMatrixLayers { get; } = new ReadOnlyCollection<string>(new string[2] { "Cloth", "Ball" });


		private static ReadOnlyCollection<string> BoxingMatrixLayers { get; } = new ReadOnlyCollection<string>(new string[4] { "Obstacle", "ObstacleDetect", "stencilRoot", "stencilReflection" });


		private static string LittleEndian(string num)
		{
			byte[] bytes = BitConverter.GetBytes(Convert.ToInt32(num, 16));
			string text = "";
			byte[] array = bytes;
			foreach (byte b in array)
			{
				text += b.ToString("X2");
			}
			return text;
		}

		private static bool GetDataFromMatrix(string targetMatrix, int layer1, int layer2)
		{
			return (Convert.ToInt32(LittleEndian(targetMatrix.Substring(layer1 * 8, 8)), 16) & (1 << layer2)) == 0;
		}

		public static void SetIgnoreLayer(GameType type)
		{
			UnityEngine.Debug.Log(type);
			string targetMatrix = string.Empty;
			switch (type)
			{
			case GameType.Billiards:
				targetMatrix = "c90480ffc80080ffc84480ffffffffffc80080ffc80081ffffffffffffffffffc806a0ffc85d80ffcd5fb8ffc80680ffc80680ffc80080ffcc0680ffc80080ffe80081ffc80080ffc80084ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Archery:
				targetMatrix = "c80000fac80000fac80000faffffffffc80000fac80000faffffffffffffffffc81420fec80000fac80536f9c80010fac81100fac80000fac80000fac80000fac80000fac80400fac8041cfac80004fac80c34fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Basketball:
				targetMatrix = "c80000fac80000fac80000faffffffffc80000fac80000faffffffffffffffffc80420fec80000fac80536f9c80010fac80000fac80000fac80000fac80000fac80000fac80400fac8041cfac80004fac80c34fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Bowling:
				targetMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc824a0ffc80080ffc805beffc80080ffc80080ffc80180ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Badminton:
				targetMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc824a0ffc80080ffc805beffc80080ffc80080ffc80180ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Lobby:
				targetMatrix = "c90400fac80000fac80000faffffffffc80000fac80000faffffffffffffffffc81420fec80000fac90536f9c80010fac81100fac80000fac80000fac80000fac80000fac80400fac8041cfac80004fac80c34fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Test:
				targetMatrix = "c9001cfac80000fae80000faffffffffc80000facc0001faffffffffffffffffc80420fec80000fac87d3ef9c80400fac80400fac80400fac84400fac80000fae80001fac80402fac90404fac90408fac90420fac80530fac80000fac80000f8c80400f8fffb7ffac80100f8ffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Golf:
				targetMatrix = "ffc3ffffff83ffffff83ffffffffffffff83ffffff83ffffffffffffffffffffff83ffffff85ffffc882ffffc890ffffc888ffffc880ffffc980ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.PingPong:
				targetMatrix = "c80480ffc80080ffc80080ffffffffffc80080ffe80080ffffffffffffffffffc800a0ffc80480ffc902beffc80080ffc80080ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Dart:
				targetMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc800a0ffc80080ffc818beffc80480ffc80480ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Baseball:
				targetMatrix = "c80080ffc80080ffc80080ffffffffffc80080ffc80080ffffffffffffffffffc800a0ffc80080ffc818beffc80480ffc80480ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Boxing:
				targetMatrix = "c90180ffc80080ffc84080ffffffffffc80080ffc80081ffffffffffffffffffc906a0ffc85980ffc859beffc80680ffc80680ffc80080ffcc0680ffc80080ffe80081ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Boxing_HB:
				targetMatrix = "7ffdffff7ffdffff7ffdffffffffffff7ffdffff7ffdffffbfffffff48feffff7ffeffffc8fdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Boxing_DM:
				targetMatrix = "ffffffffffffffffffffffffb7ffffffffffffffffffffffb7fffffffffffffffffffffffffdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Boxing_AI:
				targetMatrix = "ff0080ffff0080ffff4080ffffffffffff0080ffff0081ffffffffffffffffffc803a0ffc84580ffc842beffc80080ffc80080ffc80080ffcc0680ffc80080ffe80081ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Boxing_MT:
				targetMatrix = "ff0080ffff0080ffff4080ffffffffffff0080ffff0081ffffffffffffffffffc803a0ffc84580ffc842beffc80080ffc80080ffc80080ffcc0680ffc80080ffe80081ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			case GameType.Tennis:
				targetMatrix = "c80480ffc80080ffc80080ffffffffffc80080ffe80080ffffffffffffffffffc800a0ffc80480ffc902beffc80080ffc80080ffc80080ffc80080ffc80080ffc80080ffc80480ffc80480ffc80480ffc804a0ffc805b0ffc80080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
				break;
			}
			for (int i = 0; i < 31; i++)
			{
				for (int j = 0; j < 31; j++)
				{
					bool dataFromMatrix = GetDataFromMatrix(targetMatrix, i, j);
					Physics.IgnoreLayerCollision(i, j, dataFromMatrix);
				}
			}
		}

		public static int NameToLayer(GameType type, string name)
		{
			ReadOnlyCollection<string> readOnlyCollection = null;
			switch (type)
			{
			case GameType.Billiards:
				readOnlyCollection = billiardsMatrixLayers;
				break;
			case GameType.Basketball:
				readOnlyCollection = basketballMatrixLayers;
				break;
			case GameType.Boxing:
				readOnlyCollection = BoxingMatrixLayers;
				break;
			case GameType.Boxing_HB:
				readOnlyCollection = BoxingHBMatrixLayers;
				break;
			case GameType.Boxing_DM:
				readOnlyCollection = BoxingDMMatrixLayers;
				break;
			case GameType.Boxing_AI:
				readOnlyCollection = BoxingAIMatrixLayers;
				break;
			case GameType.Boxing_MT:
				readOnlyCollection = BoxingMTMatrixLayers;
				break;
			}
			if (!readOnlyCollection.Contains(name))
			{
				return LayerMask.NameToLayer(name);
			}
			return readOnlyCollection.IndexOf(name) + 8;
		}

		public static string LayerToName(GameType type, int layer)
		{
			if (layer < 8)
			{
				return LayerMask.LayerToName(layer);
			}
			ReadOnlyCollection<string> readOnlyCollection = null;
			switch (type)
			{
			case GameType.Billiards:
				readOnlyCollection = billiardsMatrixLayers;
				break;
			case GameType.Basketball:
				readOnlyCollection = basketballMatrixLayers;
				break;
			case GameType.Boxing:
				readOnlyCollection = BoxingMatrixLayers;
				break;
			case GameType.Boxing_HB:
				readOnlyCollection = BoxingHBMatrixLayers;
				break;
			case GameType.Boxing_DM:
				readOnlyCollection = BoxingDMMatrixLayers;
				break;
			case GameType.Boxing_AI:
				readOnlyCollection = BoxingAIMatrixLayers;
				break;
			case GameType.Boxing_MT:
				readOnlyCollection = BoxingMTMatrixLayers;
				break;
			}
			return readOnlyCollection[layer - 8];
		}
	}
	public class SceneManagement : Billiards.MonoSingleton<SceneManagement>
	{
		protected override void Awake()
		{
			base.Awake();
			SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
		}

		private void SceneManager_activeSceneChanged(Scene prev, Scene next)
		{
			UnityEngine.Debug.Log($"Scene changed : {prev} -> {next}");
		}

		private void Update()
		{
			for (int i = 0; i < 10; i++)
			{
				if (Input.GetKeyDown((KeyCode)(48 + i)))
				{
					SceneManager.LoadScene(i);
				}
			}
		}

		public override void OnDestroy()
		{
			base.OnDestroy();
			SceneManager.activeSceneChanged -= SceneManager_activeSceneChanged;
		}
	}
	public class SetLayerCollisionMatrix : MonoBehaviour
	{
		[SerializeField]
		private Layer.GameType type;

		private void Awake()
		{
			Layer.SetIgnoreLayer(type);
		}
	}
	public class TagsAndLayers : MonoBehaviour
	{
		public List<string> tags = new List<string>();

		public List<string> layers = new List<string>();

		private static int maxTags = 10000;

		private static int maxLayers = 31;

		[SerializeField]
		private Layer.GameType type;
	}
}
namespace Appnori.Boxing
{
	public class IKPostTransform : MonoBehaviour
	{
		[SerializeField]
		private VRIK ik;

		private Transform CopiedTransform;

		public Transform Transform => CopiedTransform;

		private void Awake()
		{
			CopiedTransform = new GameObject().transform;
			CopiedTransform.name = base.transform.name + " (Clone)";
		}

		private void OnEnable()
		{
			IKSolverVR solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Combine(solver.OnPostUpdate, new IKSolver.UpdateDelegate(PostUpdate));
		}

		private void PostUpdate()
		{
			Transform.position = base.transform.position;
			Transform.rotation = base.transform.rotation;
		}

		private void OnDisable()
		{
			IKSolverVR solver = ik.solver;
			solver.OnPostUpdate = (IKSolver.UpdateDelegate)Delegate.Remove(solver.OnPostUpdate, new IKSolver.UpdateDelegate(PostUpdate));
		}
	}
	public class TestLogger : MonoBehaviour
	{
		[SerializeField]
		private GameObject origin;

		[SerializeField]
		private Transform Root;

		[SerializeField]
		private int MaxCount;

		[SerializeField]
		private Text maxText;

		private readonly List<Transform> floatObject = new List<Transform>();

		private readonly List<float> floatData = new List<float>();

		public void OnFloatUpdate(float data)
		{
			floatData.Add(data);
			if (floatData.Count > MaxCount)
			{
				floatData.RemoveAt(0);
				Transform transform = floatObject.First();
				floatObject.Remove(transform);
				UnityEngine.Object.DestroyImmediate(transform.gameObject);
			}
			Render();
		}

		private void Render()
		{
			float num = floatData.Average();
			float num2 = Mathf.Max(floatData.Max(), 0.01f);
			maxText.text = $"Max : {num2:F4}, avg : {num:F4}";
			int count = floatData.Count;
			for (int i = 0; i < count - 1; i++)
			{
				float b = floatData[i] / num2;
				floatObject[i].localScale = new Vector3(1f, Mathf.Max(0.001f, b), 1f);
			}
			float b2 = floatData[count - 1] / num2;
			GameObject gameObject = UnityEngine.Object.Instantiate(origin, Root);
			gameObject.transform.localScale = new Vector3(1f, Mathf.Max(0.001f, b2), 1f);
			gameObject.transform.SetAsLastSibling();
			floatObject.Add(gameObject.transform);
		}
	}
}
namespace Appnori.XR
{
	public class InputDeviceInfo : Billiards.Singleton<InputDeviceInfo>
	{
		public bool isInitialized { get; private set; }

		public bool Allow2DAxisWithoutClick { get; private set; }

		public Appnori.Util.Notifier<bool> Primary2DAxisInput { get; private set; } = new Appnori.Util.Notifier<bool>();


		public void Initialize()
		{
			isInitialized = true;
			List<string> list = new List<string>();
			list.Add(SystemInfo.deviceName);
			list.Add(SystemInfo.deviceModel);
			UnityEngine.Debug.Log("Device info : SystemInfo.deviceName(" + SystemInfo.deviceName + "),SystemInfo.deviceModel(" + SystemInfo.deviceModel + ")");
			UnityEngine.XR.Interaction.Toolkit.XRController xRController = UnityEngine.Object.FindObjectOfType<UnityEngine.XR.Interaction.Toolkit.XRController>();
			try
			{
				list.Add(xRController.inputDevice.name);
				list.Add(xRController.inputDevice.subsystem.SubsystemDescriptor.id);
				list.Add(xRController.inputDevice.manufacturer);
				UnityEngine.Debug.Log("  controller.inputDevice.name(" + xRController.inputDevice.name + ")  controller.inputDevice.serialNumber(" + xRController.inputDevice.serialNumber + ")" + $"  controller.inputDevice.subsystem({xRController.inputDevice.subsystem})" + "  controller.inputDevice.subsystem.SubsystemDescriptor.id(" + xRController.inputDevice.subsystem.SubsystemDescriptor.id + ")  controller.inputDevice.manufacturer(" + xRController.inputDevice.manufacturer + ")");
			}
			catch (Exception)
			{
			}
			foreach (string item in list.Where((string s) => s != null && s != string.Empty))
			{
				Allow2DAxisWithoutClick = Allow2DAxisWithoutClick || item.ToLower().Contains("oculus");
			}
		}
	}
	public class XRContainer : Billiards.Singleton<XRContainer>
	{
		public Appnori.Util.NotifierClass<XRRig> CurrentRig = new Appnori.Util.NotifierClass<XRRig>();
	}
	public class XRControllerState
	{
		[Flags]
		public enum Button
		{
			None = 0,
			MenuButton = 1,
			Trigger = 2,
			Grip = 4,
			TriggerPressed = 8,
			GripPressed = 0x10,
			PrimaryButton = 0x20,
			PrimaryTouch = 0x40,
			SecondaryButton = 0x80,
			SecondaryTouch = 0x100,
			Primary2DAxisTouch = 0x200,
			Primary2DAxisClick = 0x400,
			Secondary2DAxisTouch = 0x800,
			Secondary2DAxisClick = 0x1000,
			PrimaryAxis2DUp = 0x2000,
			PrimaryAxis2DDown = 0x4000,
			PrimaryAxis2DLeft = 0x8000,
			PrimaryAxis2DRight = 0x10000,
			SecondaryAxis2DUp = 0x20000,
			SecondaryAxis2DDown = 0x40000,
			SecondaryAxis2DLeft = 0x80000,
			SecondaryAxis2DRight = 0x100000
		}

		private class InputButtonComparer : IEqualityComparer<InputHelpers.Button>
		{
			public bool Equals(InputHelpers.Button x, InputHelpers.Button y)
			{
				return x == y;
			}

			public int GetHashCode(InputHelpers.Button obj)
			{
				return (int)obj;
			}
		}

		private Dictionary<InputHelpers.Button, Appnori.Util.Notifier<bool>> ButtonStateDict = new Dictionary<InputHelpers.Button, Appnori.Util.Notifier<bool>>(new InputButtonComparer());

		private List<InputHelpers.Button> UpdateTargets = new List<InputHelpers.Button>();

		private XRRayInteractor interactor;

		private XRRig XRRigid;

		private int LastState;

		public UnityEngine.XR.Interaction.Toolkit.XRController Controller { get; private set; }

		public Appnori.Util.Notifier<bool> this[InputHelpers.Button type]
		{
			get
			{
				if (!ButtonStateDict.TryGetValue(type, out var value))
				{
					value = new Appnori.Util.Notifier<bool>();
					ButtonStateDict.Add(type, value);
				}
				return value;
			}
		}

		public Appnori.Util.Notifier<float> TriggerNotifier { get; private set; }

		public Appnori.Util.Notifier<Vector3> VelocityNotifier { get; private set; }

		public Appnori.Util.Notifier<Vector3> AngularVelocityNotifier { get; private set; }

		public Appnori.Util.Notifier<Vector2> Primary2DAxisNotifier { get; private set; }

		public Appnori.Util.Notifier<Vector3> Position { get; private set; }

		public Appnori.Util.Notifier<Quaternion> Rotation { get; private set; }

		public Appnori.Util.Notifier<Vector3> ControllerRayOrigin { get; private set; }

		public Appnori.Util.Notifier<Vector3> ControllerRayTarget { get; private set; }

		public bool IsInitialized { get; private set; }

		public XRControllerState()
		{
			TriggerNotifier = new Appnori.Util.Notifier<float>();
			VelocityNotifier = new Appnori.Util.Notifier<Vector3>();
			AngularVelocityNotifier = new Appnori.Util.Notifier<Vector3>();
			Primary2DAxisNotifier = new Appnori.Util.Notifier<Vector2>();
			Position = new Appnori.Util.Notifier<Vector3>();
			Rotation = new Appnori.Util.Notifier<Quaternion>();
			ControllerRayOrigin = new Appnori.Util.Notifier<Vector3>();
			ControllerRayTarget = new Appnori.Util.Notifier<Vector3>();
		}

		public bool Exists(InputHelpers.Button type)
		{
			return ButtonStateDict.ContainsKey(type);
		}

		public void Initialize(XRRig xrRig, UnityEngine.XR.Interaction.Toolkit.XRController controller, Button target)
		{
			LastState = 0;
			Controller = controller;
			for (int i = 1; i <= 17; i++)
			{
				int num = 1 << i - 1;
				if (target.HasFlag((Button)num))
				{
					UpdateTargets.Add((InputHelpers.Button)i);
				}
			}
			IsInitialized = true;
			interactor = controller.GetComponent<XRRayInteractor>();
			XRRigid = xrRig;
		}

		public void ForceUpdate(in InputDevice inputDevice)
		{
			if (IsInitialized)
			{
				localFunc_1(in inputDevice);
				localFunc_2(in inputDevice);
				localFunc_3(in inputDevice);
			}
			void localFunc_1(in InputDevice id)
			{
				using List<InputHelpers.Button>.Enumerator enumerator = UpdateTargets.GetEnumerator();
				while (enumerator.MoveNext())
				{
					id.IsPressed(enumerator.Current, out var isPressed, Controller.axisToPressThreshold);
					this[enumerator.Current].CurrentData = isPressed;
				}
			}
			void localFunc_2(in InputDevice id)
			{
				if (id.TryGetFeatureValue(CommonUsages.trigger, out var value))
				{
					TriggerNotifier.CurrentData = value;
				}
				if (id.TryGetFeatureValue(CommonUsages.primary2DAxis, out var value2))
				{
					Primary2DAxisNotifier.CurrentData = Vector2.ClampMagnitude(value2, 0.8f);
				}
				if (id.TryGetFeatureValue(CommonUsages.deviceVelocity, out var value3))
				{
					VelocityNotifier.CurrentData = XRRigid.transform.TransformVector(value3);
				}
				if (id.TryGetFeatureValue(CommonUsages.deviceAngularVelocity, out var value4))
				{
					AngularVelocityNotifier.CurrentData = Controller.transform.InverseTransformVector(value4);
				}
			}
			void localFunc_3(in InputDevice id)
			{
				Position.CurrentData = Controller.transform.position;
				Rotation.CurrentData = Controller.transform.rotation;
				ControllerRayOrigin.CurrentData = interactor.attachTransform.position;
				ControllerRayTarget.CurrentData = interactor.attachTransform.position + interactor.attachTransform.forward;
			}
		}
	}
	public class XRGripPosition : MonoBehaviour
	{
		[SerializeField]
		private XRRig xrRig;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController mainController;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController subController;

		[SerializeField]
		private InputHelpers.Button buttonType;

		public Appnori.Util.Notifier<bool> IsAllowed = new Appnori.Util.Notifier<bool>();

		private Vector2 defaultPosition;

		private Appnori.Util.Notifier<bool> isTotalPressed = new Appnori.Util.Notifier<bool>();

		public bool IsAllowedMove { get; set; }

		private void Awake()
		{
			IsAllowedMove = true;
			isTotalPressed.OnDataChanged += SetAllowPosition;
		}

		private void SetAllowPosition(bool isPressed)
		{
			IsAllowed.CurrentData = isPressed && IsAllowedMove;
			if (isPressed)
			{
				defaultPosition = GetPosition();
			}
		}

		private void FixedUpdate()
		{
			mainController.inputDevice.IsPressed(buttonType, out var isPressed, mainController.axisToPressThreshold);
			subController.inputDevice.IsPressed(buttonType, out var isPressed2, subController.axisToPressThreshold);
			isTotalPressed.CurrentData = isPressed && isPressed2;
			if (IsAllowed.CurrentData)
			{
				Vector2 position = GetPosition();
				Vector2 xzVector = defaultPosition - position;
				xrRig.MoveCameraToWorldLocation(xrRig.cameraGameObject.transform.position + xrRig.rig.transform.rotation * Billiards.VectorExtension.ToVector3FromXZ(in xzVector));
				defaultPosition = position;
			}
		}

		private Vector2 GetPosition()
		{
			Vector3 vector = subController.transform.localPosition;
			Vector2 a = Billiards.VectorExtension.ToXZ(in vector);
			Vector3 vector2 = mainController.transform.localPosition;
			return Vector2.Lerp(a, Billiards.VectorExtension.ToXZ(in vector2), 0.5f);
		}

		private void OnDestroy()
		{
			isTotalPressed.OnDataChanged -= SetAllowPosition;
		}
	}
	public class XRGripRotation : MonoBehaviour
	{
		[SerializeField]
		private XRRig xrRig;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController mainController;

		[SerializeField]
		private UnityEngine.XR.Interaction.Toolkit.XRController subController;

		[SerializeField]
		private InputHelpers.Button buttonType;

		public Appnori.Util.Notifier<bool> IsAllowed = new Appnori.Util.Notifier<bool>();

		private float defaultAngle;

		private Appnori.Util.Notifier<bool> isTotalPressed = new Appnori.Util.Notifier<bool>();

		public bool IsCanRotate { get; set; }

		private void Awake()
		{
			IsCanRotate = true;
			isTotalPressed.OnDataChanged += SetAllowRotate;
		}

		private void SetAllowRotate(bool isPressed)
		{
			IsAllowed.CurrentData = isPressed && IsCanRotate;
			if (isPressed)
			{
				defaultAngle = GetAngle();
			}
		}

		private void Update()
		{
			mainController.inputDevice.IsPressed(buttonType, out var isPressed, mainController.axisToPressThreshold);
			subController.inputDevice.IsPressed(buttonType, out var isPressed2, subController.axisToPressThreshold);
			isTotalPressed.CurrentData = isPressed && isPressed2;
			if (IsAllowed.CurrentData)
			{
				float angle = GetAngle();
				xrRig.RotateAroundCameraUsingRigUp(angle - defaultAngle);
				defaultAngle = angle;
			}
		}

		private float GetAngle()
		{
			Vector2 up = Vector2.up;
			Vector3 vector = subController.transform.localPosition;
			Vector2 vector2 = Billiards.VectorExtension.ToXZ(in vector);
			Vector3 vector3 = mainController.transform.localPosition;
			return Vector2.SignedAngle(up, vector2 - Billiards.VectorExtension.ToXZ(in vector3));
		}

		private void OnDestroy()
		{
			isTotalPressed.OnDataChanged -= SetAllowRotate;
		}
	}
	public class XRReticleProvider : MonoBehaviour
	{
		[Serializable]
		public class ReticlePositionEvent : UnityEvent<XRNode, Vector3>
		{
		}

		[SerializeField]
		private XRNode ControllerNode;

		public ReticlePositionEvent ReticleMovementevent;

		private void Awake()
		{
			switch (ControllerNode)
			{
			case XRNode.LeftHand:
				Billiards.Singleton<BilliardsDataContainer>.Instance.XRLeftReticleProvider.CurrentData = this;
				break;
			case XRNode.RightHand:
				Billiards.Singleton<BilliardsDataContainer>.Instance.XRRightReticleProvider.CurrentData = this;
				break;
			}
		}

		private void Update()
		{
			if (ReticleMovementevent.GetPersistentEventCount() != 0)
			{
				ReticleMovementevent.Invoke(ControllerNode, base.transform.position);
			}
		}
	}
	public class XRWorldMarker : MonoBehaviour
	{
		[SerializeField]
		private XRGripPosition position;

		[SerializeField]
		private XRGripRotation rotation;

		[SerializeField]
		private GameObject Root;

		private void Awake()
		{
			Root.SetActive(value: false);
			position.IsAllowed.OnDataChanged += IsAllowed_OnDataChanged;
			rotation.IsAllowed.OnDataChanged += IsAllowed_OnDataChanged;
		}

		private void IsAllowed_OnDataChanged(bool isOn)
		{
			Root.SetActive(isOn);
		}

		private void OnDestroy()
		{
			position.IsAllowed.OnDataChanged -= IsAllowed_OnDataChanged;
			rotation.IsAllowed.OnDataChanged -= IsAllowed_OnDataChanged;
		}
	}
}
namespace Appnori.Util
{
	public class AudioMixerControl : MonoBehaviour
	{
		[Serializable]
		public class Pair
		{
			public string originFieldName;

			public AudioMixerGroup origin;

			public string destFieldName;

			public AudioMixerGroup destination;
		}

		[SerializeField]
		private List<Pair> list;

		[SerializeField]
		private List<AudioMixerGroup> DestinationGroups;

		public static AudioMixerControl Instance { get; private set; }

		public Notifier<float> Voulume { get; private set; } = new Notifier<float>();


		private static event Action<AudioMixerControl> onInitialized;

		public static event Action<AudioMixerControl> OnInitialized
		{
			add
			{
				if (Instance != null)
				{
					value?.Invoke(Instance);
				}
				else
				{
					onInitialized += value;
				}
			}
			remove
			{
				onInitialized -= value;
			}
		}

		public AudioMixerGroup GetGroup(Predicate<AudioMixerGroup> pred)
		{
			return DestinationGroups.Find(pred);
		}

		private void Awake()
		{
			Instance = this;
			AudioMixerControl.onInitialized?.Invoke(this);
			AudioMixerControl.onInitialized = null;
		}

		private void Update()
		{
			foreach (Pair item in list)
			{
				if (item.origin.audioMixer.GetFloat(item.originFieldName, out var value))
				{
					item.destination.audioMixer.SetFloat(item.destFieldName, value);
					Voulume.CurrentData = value;
				}
			}
		}

		public static float DecibelToLinear(float dB)
		{
			return Mathf.Pow(10f, dB / 20f);
		}
	}
	public class ColliderEventRaiser : MonoBehaviour
	{
		public event Action<Collider> OnTriggerEnterEvent;

		public event Action<Collider> OnTriggerStayEvent;

		public event Action<Collider> OnTriggerExitEvent;

		public event Action<Collision> OnCollisionEnterEvent;

		public event Action<Collision> OnCollisionStayEvent;

		public event Action<Collision> OnCollisionExitEvent;

		private void OnTriggerEnter(Collider other)
		{
			this.OnTriggerEnterEvent?.Invoke(other);
		}

		private void OnTriggerStay(Collider other)
		{
			this.OnTriggerStayEvent?.Invoke(other);
		}

		private void OnTriggerExit(Collider other)
		{
			this.OnTriggerExitEvent?.Invoke(other);
		}

		private void OnCollisionEnter(Collision collision)
		{
			this.OnCollisionEnterEvent?.Invoke(collision);
		}

		private void OnCollisionStay(Collision collision)
		{
			this.OnCollisionStayEvent?.Invoke(collision);
		}

		private void OnCollisionExit(Collision collision)
		{
			this.OnCollisionExitEvent?.Invoke(collision);
		}
	}
	public interface INotifiable<T>
	{
		T CurrentData { get; set; }

		event Action<T> OnDataChanged;

		event Action<T> OnDataChangedOnce;

		event Action<T, T> OnDataChangedDelta;
	}
	public class NotifierClass<T> : INotifiable<T> where T : class
	{
		public bool isEnabled;

		private T currentData;

		public T CurrentData
		{
			get
			{
				return currentData;
			}
			set
			{
				if (currentData == null || !currentData.Equals(value))
				{
					if (isEnabled)
					{
						T arg = currentData;
						currentData = value;
						this.OnDataChanged?.Invoke(currentData);
						this.OnDataChangedOnce?.Invoke(currentData);
						this.OnDataChangedDelta?.Invoke(arg, currentData);
						this.OnDataChangedOnce = null;
					}
					else
					{
						currentData = value;
					}
				}
			}
		}

		public bool IsSubscribed
		{
			get
			{
				if (this.OnDataChanged == null || this.OnDataChanged.GetInvocationList().Length == 0)
				{
					if (this.OnDataChangedOnce != null)
					{
						return this.OnDataChangedOnce.GetInvocationList().Length != 0;
					}
					return false;
				}
				return true;
			}
		}

		public event Action<T> OnDataChanged;

		public event Action<T> OnDataChangedOnce;

		public event Action<T, T> OnDataChangedDelta;

		public NotifierClass()
		{
			isEnabled = true;
		}
	}
	public class Notifier<T> : INotifiable<T> where T : struct
	{
		public bool isEnabled;

		private T currentData;

		public T CurrentData
		{
			get
			{
				return currentData;
			}
			set
			{
				if (!EqualityComparer<T>.Default.Equals(currentData, value))
				{
					if (isEnabled)
					{
						T arg = currentData;
						currentData = value;
						this.OnDataChanged?.Invoke(currentData);
						this.OnDataChangedOnce?.Invoke(currentData);
						this.OnDataChangedDelta?.Invoke(arg, currentData);
						this.OnDataChangedOnce = null;
					}
					else
					{
						currentData = value;
					}
				}
			}
		}

		public bool IsSubscribed
		{
			get
			{
				if (this.OnDataChanged == null || this.OnDataChanged.GetInvocationList().Length == 0)
				{
					if (this.OnDataChangedOnce != null)
					{
						return this.OnDataChangedOnce.GetInvocationList().Length != 0;
					}
					return false;
				}
				return true;
			}
		}

		public event Action<T> OnDataChanged;

		public event Action<T> OnDataChangedOnce;

		public event Action<T, T> OnDataChangedDelta;

		public Notifier()
		{
			isEnabled = true;
		}
	}
	public class TestMixerControl : Billiards.MonoSingleton<TestMixerControl>
	{
		[SerializeField]
		private List<AudioMixerGroup> targetGroup;

		protected override void Awake()
		{
			base.Awake();
			if (Billiards.MonoSingleton<TestMixerControl>._instance != this)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.K))
			{
				foreach (AudioMixerGroup item in targetGroup)
				{
					if (item.audioMixer.GetFloat("BGMVolume", out var value))
					{
						item.audioMixer.SetFloat("BGMVolume", value + 1f);
					}
					if (item.audioMixer.GetFloat("FXVolume", out var value2))
					{
						item.audioMixer.SetFloat("FXVolume", value2 + 1f);
					}
				}
			}
			if (!Input.GetKeyDown(KeyCode.J))
			{
				return;
			}
			foreach (AudioMixerGroup item2 in targetGroup)
			{
				if (item2.audioMixer.GetFloat("BGMVolume", out var value3))
				{
					item2.audioMixer.SetFloat("BGMVolume", value3 - 1f);
				}
				if (item2.audioMixer.GetFloat("FXVolume", out var value4))
				{
					item2.audioMixer.SetFloat("FXVolume", value4 - 1f);
				}
			}
		}
	}
	public class SlopeIndicator : MonoBehaviour
	{
		[Header("Samples")]
		[SerializeField]
		private float SampleDepth = 5f;

		[SerializeField]
		private int InternalSampleCount = 10;

		[SerializeField]
		private Vector2Int SampleRange;

		private Vector2Int defaultSampleRange;

		[SerializeField]
		private Vector2Int SampleOffset;

		[SerializeField]
		private float SampleDistance;

		[Header("Original")]
		[SerializeField]
		private GameObject ProbeOrigin;

		[SerializeField]
		private LineRenderer LineOrigin;

		[Header("Pre-load Data")]
		[SerializeField]
		private MapInfomation mapinfo;

		[Tooltip("Mesh must have write/read enabled.")]
		[SerializeField]
		private Mesh MapMesh;

		[Header("ETC")]
		[SerializeField]
		private Gradient HeightColor;

		[SerializeField]
		private Gradient HorizontalAlphaGradient;

		[SerializeField]
		private Transform ProbeRoot;

		[SerializeField]
		private Transform LineRoot;

		public const float GridOffset = 0.015f;

		private Vector3[] vertices;

		private int[] triangles;

		private Vector3[] normals;

		private float MaxHeight;

		private float MinHeight;

		private int cachedObjectCount;

		private List<LineRenderer> VerticalLines = new List<LineRenderer>();

		private List<LineRenderer> HorizontalLines = new List<LineRenderer>();

		private List<GameObject> cachedObjects = new List<GameObject>();

		private List<Transform> cachedObjectTransforms = new List<Transform>();

		private List<SlopeProbe> cachedProbes = new List<SlopeProbe>();

		private bool isInitialized;

		private void Start()
		{
			defaultSampleRange = SampleRange;
			Initialize();
		}

		private void Update()
		{
			Input.GetKeyDown(KeyCode.I);
		}

		public void Setting(float distance)
		{
			if (distance > (float)(defaultSampleRange.y / 2 - 1))
			{
				distance = defaultSampleRange.y / 2 - 1;
			}
			int y = Mathf.Clamp(Mathf.CeilToInt(distance) * 2 + 2, 0, 14);
			SampleRange = new Vector2Int(6, y);
			SampleOffset = new Vector2Int(0, 0);
			SampleDistance = 1f;
		}

		public void Setting(Vector2Int sampleRange, Vector2Int sampleOffset, float sampleDistance)
		{
			SampleRange = sampleRange;
			SampleOffset = sampleOffset;
			SampleDistance = sampleDistance;
		}

		public void Initialize()
		{
			if (!isInitialized)
			{
				Gradient gradient = new Gradient();
				List<GradientColorKey> list = new List<GradientColorKey>();
				for (int i = 0; i < 8; i++)
				{
					list.Add(new GradientColorKey(Color.white, i / 8));
				}
				gradient.SetKeys(list.ToArray(), new GradientAlphaKey[2]
				{
					new GradientAlphaKey
					{
						alpha = 0.5f,
						time = 0f
					},
					new GradientAlphaKey
					{
						alpha = 0.5f,
						time = 1f
					}
				});
				LineOrigin.colorGradient = gradient;
				for (int j = 0; j < SampleRange.x; j++)
				{
					LineRenderer lineRenderer = UnityEngine.Object.Instantiate(LineOrigin, LineRoot);
					lineRenderer.name = $"vertical({j})";
					VerticalLines.Add(lineRenderer);
				}
				for (int k = 0; k < SampleRange.y; k++)
				{
					LineRenderer lineRenderer2 = UnityEngine.Object.Instantiate(LineOrigin, LineRoot);
					lineRenderer2.name = $"horizontal({k})";
					HorizontalLines.Add(lineRenderer2);
				}
				for (int l = 0; l <= SampleRange.x * SampleRange.y; l++)
				{
					GameObject gameObject = new GameObject("Point");
					gameObject.transform.parent = ProbeRoot;
					gameObject.SetActive(value: false);
					cachedObjects.Add(gameObject);
					cachedObjectTransforms.Add(gameObject.transform);
				}
				cachedObjectCount = cachedObjectTransforms.Count;
				for (int m = 0; m <= SampleRange.x * SampleRange.y * 4; m++)
				{
					GameObject gameObject2 = UnityEngine.Object.Instantiate(ProbeOrigin, ProbeRoot);
					gameObject2.SetActive(value: false);
					cachedProbes.Add(gameObject2.GetComponent<SlopeProbe>());
				}
				vertices = MapMesh.vertices;
				triangles = MapMesh.triangles;
				normals = MapMesh.normals;
				ProbeOrigin.SetActive(value: false);
				LineOrigin.gameObject.SetActive(value: false);
				isInitialized = true;
			}
		}

		public void Calculate(in Vector3 holePosition)
		{
			foreach (SlopeProbe cachedProbe in cachedProbes)
			{
				cachedProbe.gameObject.SetActive(value: false);
			}
			foreach (LineRenderer verticalLine in VerticalLines)
			{
				verticalLine.gameObject.SetActive(value: false);
			}
			foreach (LineRenderer horizontalLine in HorizontalLines)
			{
				horizontalLine.gameObject.SetActive(value: false);
			}
			int layerMask = 1;
			MaxHeight = float.MinValue;
			MinHeight = float.MaxValue;
			List<GameObject> list = new List<GameObject>();
			Vector2Int vector2Int = Vector2Int.zero;
			for (int i = 0; i < SampleRange.x; i++)
			{
				for (int j = 0; j < SampleRange.y; j++)
				{
					float num = (float)i * SampleDistance - (float)SampleRange.x * 0.5f * SampleDistance + 0.5f * SampleDistance + (float)SampleOffset.x * SampleDistance;
					float num2 = (float)j * SampleDistance - (float)SampleRange.y * 0.5f * SampleDistance + 0.5f * SampleDistance + (float)SampleOffset.y * SampleDistance;
					Vector3 vector = holePosition;
					Transform obj = base.transform;
					Vector2 xzVector = new Vector2(num, num2);
					Vector3 vector2 = vector + obj.TransformVector(Billiards.VectorExtension.ToVector3FromXZ(in xzVector, 1f));
					if (Physics.Raycast(vector2, Vector3.down, out var hitInfo, SampleDepth, layerMask))
					{
						if (!(hitInfo.collider is MeshCollider))
						{
							float a = HorizontalAlphaGradient.Evaluate((float)i / (float)SampleRange.x).a;
							GameObject gameObject = cachedObjects[i * SampleRange.y + j];
							gameObject.transform.localPosition = base.transform.InverseTransformPoint(vector2) + Vector3.up * 0.015f;
							gameObject.transform.localScale = new Vector3(i, j, a);
							gameObject.transform.LookAt(gameObject.transform.position + Vector3.up);
							list.Add(gameObject);
							continue;
						}
						if ((hitInfo.collider as MeshCollider).sharedMesh != MapMesh)
						{
							float a2 = HorizontalAlphaGradient.Evaluate((float)i / (float)SampleRange.x).a;
							GameObject gameObject2 = cachedObjects[i * SampleRange.y + j];
							gameObject2.transform.localPosition = base.transform.InverseTransformPoint(vector2) + Vector3.up * 0.015f;
							gameObject2.transform.localScale = new Vector3(i, j, a2);
							gameObject2.transform.LookAt(gameObject2.transform.position + Vector3.up);
							list.Add(gameObject2);
							continue;
						}
						Vector3 vector3 = normals[triangles[hitInfo.triangleIndex * 3]];
						Vector3 vector4 = normals[triangles[hitInfo.triangleIndex * 3 + 1]];
						Vector3 vector5 = normals[triangles[hitInfo.triangleIndex * 3 + 2]];
						if (num == 0f && num2 == 0f)
						{
							vector2Int = new Vector2Int(i, j);
							continue;
						}
						MaxHeight = Mathf.Max(MaxHeight, hitInfo.point.y + 0.015f);
						MinHeight = Mathf.Min(MinHeight, hitInfo.point.y + 0.015f);
						float a3 = HorizontalAlphaGradient.Evaluate((float)i / (float)SampleRange.x).a;
						GameObject gameObject3 = cachedObjects[i * SampleRange.y + j];
						gameObject3.transform.localPosition = base.transform.InverseTransformPoint(hitInfo.point) + Vector3.up * 0.015f;
						gameObject3.transform.localScale = new Vector3(i, j, a3);
						gameObject3.transform.LookAt(gameObject3.transform.position + (vector3 + vector4 + vector5) / 3f);
					}
					else
					{
						float a4 = HorizontalAlphaGradient.Evaluate((float)i / (float)SampleRange.x).a;
						GameObject gameObject4 = cachedObjects[i * SampleRange.y + j];
						gameObject4.transform.localPosition = base.transform.InverseTransformPoint(vector2) + Vector3.up * 0.015f;
						gameObject4.transform.localScale = new Vector3(i, j, a4);
						gameObject4.transform.LookAt(gameObject4.transform.position + Vector3.up);
						list.Add(gameObject4);
					}
				}
			}
			foreach (GameObject item3 in list)
			{
				Vector3 vector6 = item3.transform.localScale;
				Vector2 vector7 = Billiards.VectorExtension.ToVector2(in vector6);
				Vector3 zero = Vector3.zero;
				int num3 = 0;
				if (TryGetObject(in cachedObjects, (int)vector7.x, (int)vector7.y + 1, out var target))
				{
					zero += target.transform.position;
					num3++;
				}
				if (TryGetObject(in cachedObjects, (int)vector7.x, (int)vector7.y - 1, out var target2))
				{
					zero += target2.transform.position;
					num3++;
				}
				if (TryGetObject(in cachedObjects, (int)vector7.x + 1, (int)vector7.y, out var target3))
				{
					zero += target3.transform.position;
					num3++;
				}
				if (TryGetObject(in cachedObjects, (int)vector7.x - 1, (int)vector7.y, out var target4))
				{
					zero += target4.transform.position;
					num3++;
				}
				zero /= (float)num3;
				item3.transform.position = zero;
			}
			if (vector2Int != Vector2Int.zero)
			{
				GameObject obj2 = cachedObjects[vector2Int.x * SampleRange.y + vector2Int.y];
				Vector3 vector6 = cachedObjects[(vector2Int.x + 1) * SampleRange.y + vector2Int.y].transform.position;
				Vector3 b = cachedObjects[(vector2Int.x - 1) * SampleRange.y + vector2Int.y].transform.position;
				Vector3 a5 = GetCenter(in vector6, in b);
				vector6 = cachedObjects[vector2Int.x * SampleRange.y + (vector2Int.y + 1)].transform.position;
				b = cachedObjects[vector2Int.x * SampleRange.y + (vector2Int.y - 1)].transform.position;
				Vector3 b2 = GetCenter(in vector6, in b);
				float a6 = HorizontalAlphaGradient.Evaluate(vector2Int.x / (SampleRange.x - 1)).a;
				obj2.transform.position = GetCenter(in a5, in b2);
				obj2.transform.localScale = new Vector3(vector2Int.x, vector2Int.y, a6);
				obj2.transform.LookAt(Vector3.up);
			}
			List<float> height = new List<float>();
			for (int k = 0; k < SampleRange.x; k++)
			{
				height.Clear();
				VerticalLines[k].positionCount = (SampleRange.y - 1) * (InternalSampleCount + 1) + 1;
				VerticalLines[k].gameObject.SetActive(value: true);
				for (int l = 0; l < SampleRange.y; l++)
				{
					GameObject gameObject5 = cachedObjects[k * SampleRange.y + l];
					VerticalLines[k].SetPosition(l * (InternalSampleCount + 1), gameObject5.transform.localPosition);
					if (TryGetObject(in cachedObjects, k, l + 1, out var target5))
					{
						for (int m = 1; m < InternalSampleCount + 1; m++)
						{
							Vector3 vector8 = Vector3.Lerp(gameObject5.transform.position, target5.transform.position, (float)m / (float)(InternalSampleCount + 1));
							if (Physics.Raycast(vector8 + Vector3.up, Vector3.down, out var hitInfo2, SampleDepth, layerMask))
							{
								Vector3 vector6 = hitInfo2.point;
								if ((Billiards.VectorExtension.ToXZ(in vector6) - Billiards.VectorExtension.ToXZ(in holePosition)).magnitude < SampleDistance * 0.5f)
								{
									VerticalLines[k].SetPosition(l * (InternalSampleCount + 1) + m, gameObject5.transform.localPosition);
								}
								else
								{
									VerticalLines[k].SetPosition(l * (InternalSampleCount + 1) + m, base.transform.InverseTransformPoint(hitInfo2.point) + Vector3.up * 0.015f);
								}
							}
							else
							{
								VerticalLines[k].SetPosition(l * (InternalSampleCount + 1) + m, base.transform.InverseTransformPoint(vector8));
							}
						}
					}
					float y2 = gameObject5.transform.position.y;
					ref float minHeight = ref MinHeight;
					ref float maxHeight = ref MaxHeight;
					float start = 0f;
					float stop = 1f;
					float item = Billiards.VectorExtension.Remap(y2, in minHeight, in maxHeight, in start, in stop);
					height.Add(item);
				}
				AssignColor(VerticalLines[k], in height, isVertical: true, k);
			}
			List<float> height2 = new List<float>();
			for (int n = 0; n < SampleRange.y; n++)
			{
				height2.Clear();
				HorizontalLines[n].positionCount = (SampleRange.x - 1) * (InternalSampleCount + 1) + 1;
				HorizontalLines[n].gameObject.SetActive(value: true);
				for (int num4 = 0; num4 < SampleRange.x; num4++)
				{
					GameObject gameObject6 = cachedObjects[num4 * SampleRange.y + n];
					HorizontalLines[n].SetPosition(num4 * (InternalSampleCount + 1), gameObject6.transform.localPosition);
					if (TryGetObject(in cachedObjects, num4 + 1, n, out var target6))
					{
						for (int num5 = 1; num5 < InternalSampleCount + 1; num5++)
						{
							Vector3 vector9 = Vector3.Lerp(gameObject6.transform.position, target6.transform.position, (float)num5 / (float)(InternalSampleCount + 1));
							if (Physics.Raycast(vector9 + Vector3.up, Vector3.down, out var hitInfo3, SampleDepth, layerMask))
							{
								Vector3 vector6 = hitInfo3.point;
								if ((Billiards.VectorExtension.ToXZ(in vector6) - Billiards.VectorExtension.ToXZ(in holePosition)).magnitude < SampleDistance * 0.5f)
								{
									HorizontalLines[n].SetPosition(num4 * (InternalSampleCount + 1) + num5, gameObject6.transform.localPosition);
								}
								else
								{
									HorizontalLines[n].SetPosition(num4 * (InternalSampleCount + 1) + num5, base.transform.InverseTransformPoint(hitInfo3.point) + Vector3.up * 0.015f);
								}
							}
							else
							{
								HorizontalLines[n].SetPosition(num4 * (InternalSampleCount + 1) + num5, base.transform.InverseTransformPoint(vector9));
							}
						}
					}
					float y3 = gameObject6.transform.position.y;
					ref float minHeight2 = ref MinHeight;
					ref float maxHeight2 = ref MaxHeight;
					float start = 0f;
					float stop = 1f;
					float item2 = Billiards.VectorExtension.Remap(y3, in minHeight2, in maxHeight2, in start, in stop);
					height2.Add(item2);
				}
				AssignColor(HorizontalLines[n], in height2, isVertical: false, n);
			}
			for (int num6 = 0; num6 < SampleRange.x; num6++)
			{
				for (int num7 = 0; num7 < SampleRange.y; num7++)
				{
					int num8 = num6 * SampleRange.y + num7;
					Vector3 currentPosition2 = cachedObjectTransforms[num8].position;
					int x2 = num6 - 1;
					int y4 = num7;
					Vector3 vector6 = cachedObjectTransforms[num8].localScale;
					initProbe(x2, y4, num8, 0, in currentPosition2, in vector6);
					int x3 = num6 + 1;
					int y5 = num7;
					vector6 = cachedObjectTransforms[num8].localScale;
					initProbe(x3, y5, num8, 1, in currentPosition2, in vector6);
					int x4 = num6;
					int y6 = num7 - 1;
					vector6 = cachedObjectTransforms[num8].localScale;
					initProbe(x4, y6, num8, 2, in currentPosition2, in vector6);
					int x5 = num6;
					int y7 = num7 + 1;
					vector6 = cachedObjectTransforms[num8].localScale;
					initProbe(x5, y7, num8, 3, in currentPosition2, in vector6);
				}
			}
			void initProbe(int x, int y, int idx, int proIdx, in Vector3 currentPosition, in Vector3 currentData)
			{
				if (TryGetObject(in cachedObjectTransforms, x, y, out var target7) && target7.position.y < currentPosition.y)
				{
					float value = Mathf.Abs(target7.position.y - currentPosition.y);
					float start2 = 0f;
					float stop2 = MaxHeight - MinHeight;
					float start3 = 0f;
					float stop3 = 1f;
					float speed = Billiards.VectorExtension.Remap(value, in start2, in stop2, in start3, in stop3);
					Vector3 endpos = target7.position;
					SlopeProbe slopeProbe = cachedProbes[idx * 4 + proIdx];
					Vector3 endData = target7.localScale;
					slopeProbe.Initialize(in currentPosition, in currentData, in endpos, in endData, in speed);
				}
			}
		}

		private void AssignColor(LineRenderer line, in List<float> height, bool isVertical, int index)
		{
			Gradient colorGradient = line.colorGradient;
			int count = height.Count;
			List<GradientColorKey> list = new List<GradientColorKey>();
			if (count > 8)
			{
				list.Add(new GradientColorKey(HeightColor.Evaluate(height[0]), 0f));
				float num = 1f;
				for (int i = 1; i < count - 1; i++)
				{
					if (i * 8 / count != (i + 1) * 8 / count)
					{
						float t = 1f - ((float)(i + 1) - (float)count / 8f * num);
						float time = Mathf.Lerp(height[i], height[i + 1], t);
						list.Add(new GradientColorKey(HeightColor.Evaluate(time), num++ / 8f));
					}
				}
			}
			else
			{
				for (int j = 0; j < count; j++)
				{
					list.Add(new GradientColorKey(HeightColor.Evaluate(height[j]), (float)j / (float)count));
				}
			}
			if (isVertical)
			{
				float a = HorizontalAlphaGradient.Evaluate((float)index / (float)(SampleRange.x - 1)).a;
				colorGradient.SetKeys(list.ToArray(), new GradientAlphaKey[2]
				{
					new GradientAlphaKey(a, 0f),
					new GradientAlphaKey(a, 1f)
				});
			}
			else
			{
				colorGradient.SetKeys(list.ToArray(), HorizontalAlphaGradient.alphaKeys);
			}
			line.colorGradient = colorGradient;
		}

		private Vector3 GetCenter(in Vector3 a, in Vector3 b)
		{
			return b + (a - b) * 0.5f;
		}

		private bool TryGetObject<T>(in List<T> list, int x, int y, out T target) where T : class
		{
			if (x < 0 || x >= SampleRange.x || y < 0 || y >= SampleRange.y)
			{
				target = null;
				return false;
			}
			int num = x * SampleRange.y + y;
			if (list == null || cachedObjectCount <= num || num < 0)
			{
				target = null;
				return false;
			}
			target = list[num];
			return true;
		}
	}
	public class SlopeProbe : MonoBehaviour
	{
		[SerializeField]
		private Gradient LifeTimeColor;

		[SerializeField]
		private MeshRenderer renderer;

		[SerializeField]
		private AnimationCurve sizeCurve;

		[SerializeField]
		private float TimeScale = 1f;

		[SerializeField]
		private float defaultScale = 0.05f;

		private Vector3 StartPosition;

		private Vector3 StartData;

		private float Speed;

		private Vector3 EndPosition;

		private Vector3 EndData;

		private Transform myTransform;

		private const string MaterialLifeTimeColorProperty = "_LifeTimeColor";

		private bool isInitialized;

		public void Initialize(in Vector3 startPos, in Vector3 startData, in Vector3 endpos, in Vector3 endData, in float speed)
		{
			myTransform = base.transform;
			StartPosition = startPos;
			StartData = startData;
			EndPosition = endpos;
			EndData = endData;
			Speed = speed;
			base.gameObject.SetActive(value: true);
			isInitialized = true;
		}

		private void Update()
		{
			if (isInitialized)
			{
				myTransform.position = Vector3.Lerp(StartPosition, EndPosition, Mathf.Repeat(Time.time * Speed * TimeScale, 1f));
				renderer.material.SetColor("_LifeTimeColor", LifeTimeColor.Evaluate(Mathf.Repeat(Time.time * Speed * TimeScale, 1f)));
				myTransform.localScale = Vector3.one * defaultScale * sizeCurve.Evaluate(Mathf.Repeat(Time.time * Speed * TimeScale, 1f));
				Color color = renderer.material.color;
				color.a = Mathf.Lerp(StartData.z, EndData.z, Mathf.Repeat(Time.time * Speed * TimeScale, 1f));
				renderer.material.color = color;
			}
		}
	}
}
