#define DEBUG_LOCOMOTION_PANEL
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using AOT;
using CrazyMinnow.SALSA;
using DigitalOpus.MB.Core;
using FluffyUnderware.Curvy;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools.Extensions;
using HutongGames.PlayMaker;
using HutongGames.PlayMaker.Actions;
using HutongGames.PlayMaker.AnimationEnums;
using MEC;
using Malimbe.BehaviourStateRequirementMethod;
using Malimbe.MemberChangeMethod;
using Malimbe.PropertySerializationAttribute;
using Malimbe.XmlDocumentationAttribute;
using Oculus.Avatar;
using Oculus.Platform;
using Oculus.Platform.Models;
using Oculus.Spatializer.Propagation;
using Pathfinding;
using PlayMaker.ConditionalExpression;
using RayFire;
using RayFire.DotNet;
using TMPro;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Audio;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Scripting;
using UnityEngine.Serialization;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;
using VRTK.Prefabs.Locomotion.Teleporters;
using Zinnia.Action;
using Zinnia.Data.Type;
using Zinnia.Extension;
using Zinnia.Rule;
using Zinnia.Visual;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
public class BottleSmash : MonoBehaviour
{
	[ColorUsage(true, true, 0f, 8f, 0.125f, 3f)]
	public Color color;

	[SerializeField]
	[HideInInspector]
	private Color cachedColor;

	[SerializeField]
	[HideInInspector]
	private List<ColorBase> registeredComponents;

	public GameObject Cork;

	public GameObject Liquid;

	public GameObject Glass;

	public GameObject Glass_Shattered;

	public GameObject Label;

	public float DespawnTime = 5f;

	public ParticleSystem Effect;

	public GameObject Splat;

	public LayerMask SplatMask;

	public float maxSplatDistance = 5f;

	public float shatterAtSpeed = 2f;

	public bool allowShattering = true;

	public bool onlyAllowShatterOnCollision = true;

	[SerializeField]
	[HideInInspector]
	private Vector3 previousPos;

	[SerializeField]
	[HideInInspector]
	private Vector3 previousVelocity;

	[SerializeField]
	[HideInInspector]
	private Vector3 randomRot;

	[SerializeField]
	[HideInInspector]
	private float _lastHitSpeed;

	private bool broken;

	private float collidedRecently = -1f;

	private void Start()
	{
		previousPos = base.transform.position;
	}

	public void RandomizeColor()
	{
		color = new Color(UnityEngine.Random.Range(0, 1), UnityEngine.Random.Range(0, 1), UnityEngine.Random.Range(0, 1), 1f);
	}

	private void OnCollisionEnter(Collision collision)
	{
		_lastHitSpeed = collision.impulse.magnitude;
		if (collision.transform.tag != "Liquid")
		{
			collidedRecently = 0.2f;
		}
	}

	public void AttemptCollision(Collision col)
	{
		OnCollisionEnter(col);
	}

	public void RegisterColorBase(ColorBase cb)
	{
		registeredComponents.Add(cb);
	}

	public void ChangedColor()
	{
		if (!(cachedColor != color))
		{
			return;
		}
		cachedColor = color;
		foreach (ColorBase registeredComponent in registeredComponents)
		{
			registeredComponent.Unify();
		}
	}

	public Vector3 GetRandomRotation()
	{
		return randomRot;
	}

	public void RandomRotation()
	{
		randomRot = (UnityEngine.Random.insideUnitSphere + Vector3.forward).normalized;
	}

	public void Smash()
	{
		broken = true;
		if (Cork != null)
		{
			Cork.transform.parent = null;
			Cork.GetComponent<Collider>().enabled = true;
			Cork.GetComponent<Rigidbody>().isKinematic = false;
			UnityEngine.Object.Destroy(Cork.gameObject, DespawnTime);
		}
		if (Liquid != null)
		{
			float t = 0f;
			UnityEngine.Object.Destroy(Liquid.gameObject, t);
		}
		if (Effect != null)
		{
			Effect.Play();
			UnityEngine.Object.Destroy(Effect.gameObject, Effect.main.startLifetime.constantMax);
		}
		if (Label != null)
		{
			UnityEngine.Object.Destroy(Label.gameObject);
		}
		if (Glass != null)
		{
			UnityEngine.Object.Destroy(Glass.gameObject);
		}
		if (Glass_Shattered != null)
		{
			Glass_Shattered.SetActive(value: true);
			Glass_Shattered.transform.parent = null;
			UnityEngine.Object.Destroy(Glass_Shattered, DespawnTime);
		}
		RaycastHit hitInfo = default(RaycastHit);
		if (Splat != null && Physics.Raycast(base.transform.position, Vector3.down, out hitInfo, maxSplatDistance, SplatMask))
		{
			UnityEngine.Object.Instantiate(Splat).transform.position = hitInfo.point;
		}
		UnityEngine.Object.Destroy(base.transform.gameObject, DespawnTime);
	}

	private void FixedUpdate()
	{
		ChangedColor();
		collidedRecently -= Time.deltaTime;
		Vector3 a = (base.transform.position - previousPos) / Time.fixedDeltaTime;
		if (((onlyAllowShatterOnCollision && collidedRecently >= 0f) | !onlyAllowShatterOnCollision) && allowShattering && (Vector3.Distance(a, previousVelocity) > shatterAtSpeed || _lastHitSpeed > shatterAtSpeed) && !broken)
		{
			Smash();
		}
		_lastHitSpeed = 0f;
		previousVelocity = a;
		previousPos = base.transform.position;
	}
}
public class ColorBase : MonoBehaviour
{
	protected virtual void RegisterWithController()
	{
	}

	public virtual void Unify()
	{
	}
}
public class LiquidColor : ColorBase
{
	public BottleSmash bottleSmash;

	private LiquidVolumeAnimator lva;

	public bool UpdateSurfaceColor = true;

	public bool UpdateColor = true;

	public bool UpdateSurfaceEmission = true;

	public bool UpdateEmission = true;

	private void Start()
	{
		lva = GetComponent<LiquidVolumeAnimator>();
		if (bottleSmash == null)
		{
			bottleSmash = GetComponentInParent<BottleSmash>();
		}
		RegisterWithController();
	}

	protected override void RegisterWithController()
	{
		bottleSmash.RegisterColorBase(this);
	}

	public override void Unify()
	{
		if (UpdateColor)
		{
			lva.mats[0].SetColor("_Color", bottleSmash.color);
		}
		if (UpdateEmission)
		{
			lva.mats[0].SetColor("_EmissionColor", bottleSmash.color);
		}
		if (UpdateSurfaceColor)
		{
			lva.mats[0].SetColor("_SColor", bottleSmash.color);
		}
		if (UpdateSurfaceEmission)
		{
			lva.mats[0].SetColor("_SEmissionColor", bottleSmash.color);
		}
	}
}
public class PS_Color : ColorBase
{
	public BottleSmash bottleSmash;

	private ParticleSystem ps;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		if (bottleSmash == null)
		{
			bottleSmash = GetComponentInParent<BottleSmash>();
		}
		RegisterWithController();
	}

	protected override void RegisterWithController()
	{
		bottleSmash.RegisterColorBase(this);
	}

	public override void Unify()
	{
		UpdateValues();
	}

	public void UpdateValues()
	{
		ParticleSystem.MainModule main = ps.main;
		main.startColor = new ParticleSystem.MinMaxGradient(bottleSmash.color);
	}
}
public class ParticleColor : ColorBase
{
	public enum ColorID
	{
		_TintColor,
		_Color
	}

	public BottleSmash bottleSmash;

	private ParticleSystemRenderer ps;

	public ColorID colorType;

	private void Start()
	{
		ps = GetComponent<ParticleSystemRenderer>();
		if (bottleSmash == null)
		{
			bottleSmash = GetComponentInParent<BottleSmash>();
		}
		RegisterWithController();
	}

	protected override void RegisterWithController()
	{
		bottleSmash.RegisterColorBase(this);
	}

	public override void Unify()
	{
		switch (colorType)
		{
		case ColorID._TintColor:
			ps.material.SetColor("_TintColor", bottleSmash.color);
			break;
		case ColorID._Color:
			ps.material.SetColor("_Color", bottleSmash.color);
			break;
		}
	}
}
public class ResetColors : MonoBehaviour
{
	public LiquidVolumeAnimator LVA;

	public float timeout = 5f;

	private float tReset;

	public BottleSmash BS;

	public Color Color1;

	public Color Color2;

	private void Start()
	{
		tReset = timeout;
	}

	private void Update()
	{
		timeout -= Time.deltaTime;
		if (timeout <= 0f)
		{
			if (BS.color == Color1)
			{
				BS.color = Color2;
			}
			else
			{
				BS.color = Color1;
			}
			LVA.level = 1f;
			timeout = tReset;
		}
	}
}
public class DemoRotation : MonoBehaviour
{
	private BottleSmash BS;

	public float rotSpeed = 30f;

	private void Start()
	{
		BS = GetComponent<BottleSmash>();
	}

	private void Update()
	{
		if (BS.GetRandomRotation().normalized != Vector3.zero && Vector3.Dot(BS.GetRandomRotation().normalized, (BS.transform.up + Vector3.up).normalized) < 0.98f)
		{
			BS.transform.rotation = Quaternion.RotateTowards(BS.transform.rotation, Quaternion.LookRotation(BS.GetRandomRotation(), (BS.transform.up + Vector3.up).normalized), rotSpeed * Time.deltaTime);
		}
	}
}
public class ForceTest : MonoBehaviour
{
	public bool AddForce;

	public Vector3 force;

	private LiquidVolumeAnimator lva;

	private void Start()
	{
		lva = GetComponent<LiquidVolumeAnimator>();
	}

	private void Update()
	{
		if (AddForce)
		{
			lva.AddForce(force);
			AddForce = false;
		}
	}
}
public class LiquidAbsorption : MonoBehaviour
{
	public Color currentColor;

	public BottleSmash smashScript;

	public float particleValue = 0.02f;

	public LiquidVolumeAnimator LVA;

	private void Start()
	{
		if (LVA == null)
		{
			LVA = GetComponent<LiquidVolumeAnimator>();
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (other.transform.parent == base.transform.parent)
		{
			return;
		}
		bool flag = false;
		if (smashScript.Cork == null)
		{
			flag = true;
		}
		else if (!smashScript.Cork.activeSelf)
		{
			flag = true;
		}
		else if (!smashScript.Cork.GetComponent<Rigidbody>().isKinematic)
		{
			flag = true;
		}
		if (!flag)
		{
			return;
		}
		currentColor = smashScript.color;
		if (LVA.level < 1f - particleValue)
		{
			Color color = other.GetComponentInParent<BottleSmash>().color;
			if (LVA.level <= 1.4E-44f)
			{
				currentColor = color;
			}
			else
			{
				currentColor = Color.Lerp(currentColor, color, particleValue / LVA.level);
			}
			LVA.level += particleValue;
			smashScript.color = currentColor;
		}
	}

	private void Update()
	{
		currentColor = smashScript.color;
	}
}
public class LiquidAbsorptionV2 : MonoBehaviour
{
	public Color currentColor;

	public BottleSmash smashScript;

	public MeshLiquidEmission LiquidEmission;

	public LiquidVolumeAnimator LVA;

	private float particleValue = 1f;

	private void Start()
	{
		if (LVA == null)
		{
			LVA = GetComponent<LiquidVolumeAnimator>();
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (other.transform.parent == base.transform.parent)
		{
			return;
		}
		bool flag = false;
		if (smashScript.Cork == null)
		{
			flag = true;
		}
		else if (!smashScript.Cork.activeSelf)
		{
			flag = true;
		}
		else if (!smashScript.Cork.GetComponent<Rigidbody>().isKinematic)
		{
			flag = true;
		}
		float num = particleValue * (1f / LiquidEmission.volumeOfParticles);
		if (!flag)
		{
			return;
		}
		currentColor = smashScript.color;
		if (LVA.level < 1f - num)
		{
			Color color = other.GetComponentInParent<BottleSmash>().color;
			if (LVA.level <= 1.4E-44f)
			{
				currentColor = color;
			}
			else
			{
				currentColor = Color.Lerp(currentColor, color, num / LVA.level);
			}
			LVA.level += num;
			smashScript.color = currentColor;
		}
	}

	private void Update()
	{
		currentColor = smashScript.color;
	}
}
public class LiquidPool : MonoBehaviour
{
	public float minSize = 0.5f;

	public float maxSize = 1f;

	public float timeToComplete = 0.5f;

	private float randomSize;

	private float currentTime;

	private bool fadingOut;

	private MeshRenderer mr;

	private Material mat;

	private void Start()
	{
		base.transform.localScale = Vector3.zero;
		randomSize = UnityEngine.Random.Range(minSize, maxSize);
		mr = GetComponent<MeshRenderer>();
		mat = mr.material;
		mat = UnityEngine.Object.Instantiate(mat);
		mr.material = mat;
	}

	private void Update()
	{
		currentTime += Time.deltaTime * (float)((!fadingOut) ? 1 : (-1));
		if (currentTime >= timeToComplete)
		{
			fadingOut = true;
		}
		if (fadingOut)
		{
			mat.color = new Color(mat.color.r, mat.color.g, mat.color.b, Mathf.Lerp(0f, 1f, currentTime / timeToComplete));
		}
		else
		{
			base.transform.localScale = Vector3.one * Mathf.Lerp(0f, randomSize, currentTime / timeToComplete);
		}
		if (fadingOut && currentTime <= 0f)
		{
			UnityEngine.Object.Destroy(base.transform.gameObject);
		}
	}
}
[Serializable]
public class LiquidVolumeAnimator : MonoBehaviour
{
	[HideInInspector]
	[SerializeField]
	public Material[] mats;

	[Range(0f, 1f)]
	[SerializeField]
	public float level = 0.5f;

	private float finalLevel;

	public Vector2 minMaxBounds;

	[HideInInspector]
	[SerializeField]
	private MeshFilter mf;

	[HideInInspector]
	[SerializeField]
	private MeshRenderer mr;

	[HideInInspector]
	[SerializeField]
	private Mesh m;

	public bool DebugAnchor;

	public float debugSize = 1f;

	public float _anchorLength = 0.5f;

	[Range(0f, 1f)]
	public float dampening;

	[HideInInspector]
	[SerializeField]
	private Vector3 anchor;

	[HideInInspector]
	[SerializeField]
	private Vector3 anchorVelocity;

	[HideInInspector]
	[SerializeField]
	private Vector3 transformedPoint;

	[HideInInspector]
	[SerializeField]
	private Vector3 prevTransformedPoint;

	public bool calculateTextureProjection = true;

	public float TextureSize = 1f;

	public float TextureSizeScalar = 1f;

	public AnimationCurve texCurveSize = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private Quaternion previous;

	private float totalRotation;

	[HideInInspector]
	[SerializeField]
	private Vector3 TopLeft;

	[HideInInspector]
	[SerializeField]
	private Vector3 TopRight;

	[HideInInspector]
	[SerializeField]
	private Vector3 BottomLeft;

	[HideInInspector]
	[SerializeField]
	private Vector3 BottomRight;

	public Transform ExposedLiquidT;

	public Vector3 GravityDirection = Vector3.down;

	public bool normalizeGravityDirection = true;

	[HideInInspector]
	[SerializeField]
	private Vector3[] verts;

	private int shader_Key_localHeight;

	private int shader_Key_anchor;

	private int shader_Key_point;

	private int shader_Key_level;

	private float prvLevel = -1f;

	private Quaternion prevQ = Quaternion.identity;

	[HideInInspector]
	[SerializeField]
	private Vector3 cPos = Vector3.zero;

	public Vector3 finalAnchor;

	public Vector3 finalPoint;

	[HideInInspector]
	[SerializeField]
	private string[] shaderNames;

	private void OnDrawGizmosSelected()
	{
		float num = _anchorLength * Mathf.Max(base.transform.lossyScale.x, base.transform.lossyScale.y, base.transform.lossyScale.z);
		if (DebugAnchor)
		{
			cPos = base.transform.position;
			Vector3 vector = cPos - base.transform.TransformDirection(Vector3.up) * num;
			if (anchor == Vector3.zero)
			{
				anchor = vector;
			}
			CalculateSquare(anchor);
			Gizmos.DrawSphere(vector, 0.25f * base.transform.lossyScale.magnitude * 0.1f * debugSize);
			Gizmos.DrawLine(cPos, vector);
			Gizmos.color = Color.blue;
			Gizmos.DrawSphere(anchor, 0.25f * base.transform.lossyScale.magnitude * 0.1f * debugSize);
			Gizmos.color = Color.red;
			Gizmos.DrawSphere(cPos - (vector - cPos).normalized * finalLevel, 0.1f * base.transform.lossyScale.magnitude * 0.01f * debugSize);
			Gizmos.color = Color.yellow;
			Gizmos.DrawSphere(TopLeft, 0.25f * base.transform.lossyScale.magnitude * 0.01f * debugSize);
			Gizmos.DrawSphere(TopRight, 0.25f * base.transform.lossyScale.magnitude * 0.01f * debugSize);
			Gizmos.DrawSphere(BottomLeft, 0.25f * base.transform.lossyScale.magnitude * 0.01f * debugSize);
			Gizmos.DrawSphere(BottomRight, 0.25f * base.transform.lossyScale.magnitude * 0.01f * debugSize);
			Gizmos.color = Color.white;
			CalculateSquare(anchor);
		}
	}

	private void CalculateSquare(Vector3 anch)
	{
		if (calculateTextureProjection)
		{
			Vector3 vector = cPos - (anch - cPos).normalized * finalLevel;
			Vector3 normalized = (cPos - (anch - cPos).normalized * finalLevel - anch).normalized;
			Vector3 normalized2 = Vector3.Cross(Quaternion.Euler(0f, totalRotation, 0f) * Vector3.right, normalized.normalized).normalized;
			Vector3 normalized3 = Vector3.Cross(normalized2, normalized).normalized;
			normalized2 = Vector3.Cross(normalized3, normalized).normalized;
			float num = TextureSize * texCurveSize.Evaluate(Mathf.Clamp01(level)) * base.transform.lossyScale.magnitude * 0.001f;
			TopLeft = normalized3 * num + normalized2 * num + vector;
			TopRight = normalized3 * num * -1f + normalized2 * num + vector;
			BottomLeft = normalized3 * num + normalized2 * num * -1f + vector;
			BottomRight = normalized3 * num * -1f - normalized2 * num + vector;
		}
	}

	private void Start()
	{
		cPos = base.transform.position;
		shader_Key_localHeight = Shader.PropertyToID("_localHeight");
		shader_Key_anchor = Shader.PropertyToID("_anchor");
		shader_Key_point = Shader.PropertyToID("_point");
		shader_Key_level = Shader.PropertyToID("_level");
		prevTransformedPoint = (transformedPoint = base.transform.TransformDirection(normalizeGravityDirection ? GravityDirection.normalized : GravityDirection));
		anchor -= (normalizeGravityDirection ? GravityDirection.normalized : GravityDirection) * -1f * Time.deltaTime * (1f - dampening);
		anchor.Normalize();
		mr = GetComponent<MeshRenderer>();
		mats = mr.materials;
		shaderNames = new string[mats.Length];
		for (int i = 0; i < mats.Length; i++)
		{
			mats[i] = UnityEngine.Object.Instantiate(mats[i]);
			shaderNames[i] = mats[i].shader.name;
		}
		mf = GetComponent<MeshFilter>();
		m = mf.sharedMesh;
		verts = new Vector3[m.vertices.Length];
		verts = m.vertices;
		minMaxBounds.x = (minMaxBounds.y = verts[0].y);
		for (int j = 0; j < verts.Length; j++)
		{
			Vector3 vector = base.transform.TransformDirection(verts[j]);
			if (vector.y > minMaxBounds.y)
			{
				minMaxBounds.y = vector.y;
			}
			if (vector.y < minMaxBounds.x)
			{
				minMaxBounds.x = vector.y;
			}
		}
		minMaxBounds.x -= cPos.y;
		minMaxBounds.y -= cPos.y;
		for (int k = 0; k < mats.Length; k++)
		{
			mats[k].SetFloat(shader_Key_localHeight, Mathf.Lerp(minMaxBounds.x, minMaxBounds.y, level));
		}
		mr.materials = mats;
	}

	public void AddForce(Vector3 force)
	{
		anchorVelocity += force;
	}

	private void FixedUpdate()
	{
		cPos = base.transform.position;
		float num = _anchorLength * Mathf.Max(base.transform.lossyScale.x, base.transform.lossyScale.y, base.transform.lossyScale.z);
		transformedPoint = base.transform.TransformDirection(normalizeGravityDirection ? GravityDirection.normalized : GravityDirection);
		anchor += anchorVelocity * (1f - dampening);
		Vector3 vector = anchor;
		anchor -= (normalizeGravityDirection ? GravityDirection.normalized : GravityDirection) * -1f * Time.deltaTime * (1f - dampening);
		if (Vector3.Distance(anchor, cPos) > num)
		{
			anchor = cPos + (anchor - cPos).normalized * num;
		}
		Vector3 vector2 = anchor - vector + (transformedPoint - prevTransformedPoint) * -1f * (1f / num) * Time.deltaTime;
		if (vector2 == Vector3.zero && prvLevel == level && prevQ == base.transform.rotation)
		{
			return;
		}
		anchorVelocity += vector2;
		Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
		minMaxBounds.x = (minMaxBounds.y = base.transform.TransformPoint(verts[0]).y);
		for (int i = 0; i < verts.Length; i++)
		{
			Vector3 vector3 = localToWorldMatrix.MultiplyPoint(verts[i]);
			if (vector3.y > minMaxBounds.y)
			{
				minMaxBounds.y = vector3.y;
			}
			if (vector3.y < minMaxBounds.x)
			{
				minMaxBounds.x = vector3.y;
			}
		}
		minMaxBounds.y -= cPos.y;
		minMaxBounds.x -= cPos.y;
		finalLevel = Mathf.Lerp(minMaxBounds.x, minMaxBounds.y, level);
		if (level <= 1.4E-44f)
		{
			anchor = Vector3.down * num + cPos;
		}
		finalPoint = cPos - (anchor - cPos).normalized * finalLevel;
		for (int j = 0; j < mats.Length; j++)
		{
			mats[j].SetFloat(shader_Key_localHeight, Mathf.Lerp(minMaxBounds.x - 1.4E-44f, minMaxBounds.y + 1.4E-44f, level));
			mats[j].SetVector(shader_Key_anchor, base.transform.InverseTransformPoint(anchor));
			mats[j].SetVector(shader_Key_point, base.transform.InverseTransformPoint(cPos - (anchor - cPos).normalized * finalLevel));
			mats[j].SetFloat(shader_Key_level, level - float.Epsilon);
		}
		finalAnchor = anchor;
		CalculateSquare(anchor);
		Quaternion quaternion = Quaternion.LookRotation(previous * Vector3.right, Vector3.up);
		Vector3 lhs = quaternion * Vector3.right;
		Quaternion quaternion2 = Quaternion.LookRotation(base.transform.rotation * Vector3.right, Vector3.up);
		float num2 = Quaternion.Angle(quaternion, quaternion2) * (float)((!(Vector3.Dot(lhs, quaternion2 * Vector3.forward) < 0f)) ? 1 : (-1));
		if (Mathf.Abs(num2) > 0.05f)
		{
			totalRotation += num2;
		}
		if (totalRotation > 360f)
		{
			totalRotation -= 360f;
		}
		else if (totalRotation < 0f)
		{
			totalRotation += 360f;
		}
		if (ExposedLiquidT != null)
		{
			ExposedLiquidT.position = cPos - (anchor - cPos).normalized * finalLevel;
			ExposedLiquidT.localScale = Vector3.one * texCurveSize.Evaluate(Mathf.Clamp01(level)) * base.transform.lossyScale.magnitude * 0.001f * TextureSize * TextureSizeScalar;
			ExposedLiquidT.up = (finalPoint - finalAnchor).normalized;
		}
		prevTransformedPoint = transformedPoint;
		previous = base.transform.rotation;
		Vector4 value = base.transform.InverseTransformPoint(TopLeft);
		Vector4 value2 = base.transform.InverseTransformPoint(TopRight);
		Vector4 value3 = base.transform.InverseTransformPoint(BottomLeft);
		Vector4 value4 = base.transform.InverseTransformPoint(BottomRight);
		Vector4 value5 = base.transform.InverseTransformPoint(cPos - (anchor - cPos).normalized * finalLevel);
		for (int k = 0; k < mats.Length; k++)
		{
			if (shaderNames[k].Contains("_Texture"))
			{
				mats[k].SetVector("_TL", value);
				mats[k].SetVector("_TR", value2);
				mats[k].SetVector("_BL", value3);
				mats[k].SetVector("_BR", value4);
				mats[k].SetVector("_CENTER", value5);
			}
		}
		prvLevel = level;
		prevQ = base.transform.rotation;
	}
}
public class MeshLiquidEmission : MonoBehaviour
{
	[Serializable]
	private class BVertex
	{
		public Vector3 p;

		public Vector3 n;

		public bool b;
	}

	[HideInInspector]
	[SerializeField]
	private MeshFilter r;

	public LiquidVolumeAnimator LVA;

	[HideInInspector]
	[SerializeField]
	private int[] calculatedTriangles;

	[HideInInspector]
	[SerializeField]
	private BVertex[] calculatedVerts;

	public ParticleSystem system;

	private float particlesToEmit;

	public float emissionSpeed;

	private Mesh m;

	[HideInInspector]
	[SerializeField]
	private int[] tris;

	[HideInInspector]
	[SerializeField]
	private Vector3[] verts;

	[HideInInspector]
	[SerializeField]
	private Vector3[] norms;

	public bool debug;

	public float debugScale = 1f;

	public bool CullNullNormals;

	public Rigidbody Cork;

	public float volumeOfParticles = 70f;

	public bool emitting = true;

	public BottleSmash bottleSmash;

	public float angleSpeedScalar = 1f;

	private int CVOB;

	private void Start()
	{
		r = GetComponent<MeshFilter>();
		m = r.mesh;
		calculatedVerts = new BVertex[m.vertexCount * 6];
		for (int i = 0; i < calculatedVerts.Length; i++)
		{
			calculatedVerts[i] = new BVertex();
		}
		verts = m.vertices;
		tris = m.triangles;
		norms = m.normals;
	}

	private bool LinePlaneIntersection(Vector3 p0, Vector3 p1, Vector3 planePoint, Vector3 planeNormal, out Vector3 coordinate)
	{
		Vector3 vector = p1 - p0;
		coordinate = Vector3.zero;
		float num = Vector3.Dot(planeNormal.normalized, vector);
		if (Mathf.Abs(num) > float.Epsilon)
		{
			Vector3 rhs = p0 - planePoint;
			float num2 = Vector3.Dot(planeNormal.normalized, rhs) * -1f / num;
			vector *= num2;
			coordinate = p0 + vector;
			return true;
		}
		return false;
	}

	private void OnDrawGizmos()
	{
		if (debug && calculatedVerts != null)
		{
			for (int i = 0; i < calculatedVerts.Length && calculatedVerts[i].b; i++)
			{
				Gizmos.DrawSphere(base.transform.TransformPoint(calculatedVerts[i].p), 0.01f * base.transform.lossyScale.magnitude * debugScale);
			}
		}
	}

	private void SetDual(int under1, int under2, int above, ref Vector3 dir, ref Vector3 lpos, ref int currentVOB, ref Vector3 tmpV)
	{
		calculatedVerts[currentVOB].p = verts[under1];
		calculatedVerts[currentVOB].n = norms[under1];
		calculatedVerts[currentVOB].b = true;
		LinePlaneIntersection(verts[under1], verts[above], lpos, dir * -1f, out tmpV);
		calculatedVerts[currentVOB + 1].p = tmpV;
		calculatedVerts[currentVOB + 1].n = Vector3.Lerp(norms[under1], norms[above], (tmpV - verts[under1]).magnitude / (verts[under1] - verts[above]).magnitude);
		calculatedVerts[currentVOB + 1].b = true;
		calculatedVerts[currentVOB + 2].p = verts[under2];
		calculatedVerts[currentVOB + 2].n = norms[under2];
		calculatedVerts[currentVOB + 2].b = true;
		calculatedVerts[currentVOB + 3].p = verts[under2];
		calculatedVerts[currentVOB + 3].n = norms[under2];
		calculatedVerts[currentVOB + 3].b = true;
		calculatedVerts[currentVOB + 4].p = tmpV;
		calculatedVerts[currentVOB + 4].n = calculatedVerts[currentVOB + 1].n;
		calculatedVerts[currentVOB + 4].b = true;
		LinePlaneIntersection(verts[under2], verts[above], lpos, dir * -1f, out tmpV);
		calculatedVerts[currentVOB + 5].p = tmpV;
		calculatedVerts[currentVOB + 5].n = Vector3.Lerp(norms[under2], norms[above], (tmpV - verts[under2]).magnitude / (verts[under2] - verts[above]).magnitude);
		calculatedVerts[currentVOB + 5].b = true;
	}

	private void SetDualInverted(int under1, int above1, int above2, ref Vector3 dir, ref Vector3 lpos, ref int currentVOB, ref Vector3 tmpV)
	{
		calculatedVerts[currentVOB].p = verts[under1];
		calculatedVerts[currentVOB].n = norms[under1];
		calculatedVerts[currentVOB].b = true;
		LinePlaneIntersection(verts[under1], verts[above1], lpos, dir * -1f, out tmpV);
		calculatedVerts[currentVOB + 1].p = tmpV;
		calculatedVerts[currentVOB + 1].n = Vector3.Lerp(norms[under1], norms[above1], (tmpV - verts[under1]).magnitude / (verts[under1] - verts[above1]).magnitude);
		calculatedVerts[currentVOB + 1].b = true;
		LinePlaneIntersection(verts[under1], verts[above2], lpos, dir * -1f, out tmpV);
		calculatedVerts[currentVOB + 2].p = tmpV;
		calculatedVerts[currentVOB + 2].n = Vector3.Lerp(norms[under1], norms[above2], (tmpV - verts[under1]).magnitude / (verts[under1] - verts[above2]).magnitude);
		calculatedVerts[currentVOB + 2].b = true;
	}

	private void CalculateTrianglesToEmitFrom(int[] tris, Vector3[] verts)
	{
		Vector3 normalized = (LVA.finalAnchor - LVA.finalPoint).normalized;
		Vector3 lpos = base.transform.InverseTransformPoint(LVA.finalPoint);
		normalized = base.transform.InverseTransformDirection(normalized).normalized;
		int currentVOB = 0;
		Vector3 tmpV = Vector3.zero;
		for (int i = 2; i < tris.Length; i += 3)
		{
			int num = tris[i - 2];
			int num2 = tris[i - 1];
			int num3 = tris[i];
			Vector3 vector = verts[num];
			Vector3 vector2 = verts[num2];
			Vector3 vector3 = verts[num3];
			Vector3 rhs = vector - lpos;
			bool flag = Vector3.Dot(normalized, rhs) >= 0f;
			Vector3 rhs2 = vector2 - lpos;
			bool flag2 = Vector3.Dot(normalized, rhs2) >= 0f;
			Vector3 rhs3 = vector3 - lpos;
			bool flag3 = Vector3.Dot(normalized, rhs3) >= 0f;
			if (flag3 && flag2 && flag)
			{
				calculatedVerts[currentVOB].p = vector;
				calculatedVerts[currentVOB].n = norms[num];
				calculatedVerts[currentVOB].b = true;
				calculatedVerts[currentVOB + 1].p = vector2;
				calculatedVerts[currentVOB + 1].n = norms[num2];
				calculatedVerts[currentVOB + 1].b = true;
				calculatedVerts[currentVOB + 2].p = vector3;
				calculatedVerts[currentVOB + 2].n = norms[num2];
				calculatedVerts[currentVOB + 2].b = true;
				currentVOB += 3;
			}
			else
			{
				if (!(flag3 || flag2 || flag))
				{
					continue;
				}
				bool flag4 = false;
				if (flag && flag2)
				{
					SetDual(num, num2, num3, ref normalized, ref lpos, ref currentVOB, ref tmpV);
					currentVOB += 6;
					flag4 = true;
				}
				if (flag && flag3)
				{
					SetDual(num, num3, num2, ref normalized, ref lpos, ref currentVOB, ref tmpV);
					currentVOB += 6;
					flag4 = true;
				}
				if (flag2 && flag3)
				{
					SetDual(num3, num2, num, ref normalized, ref lpos, ref currentVOB, ref tmpV);
					currentVOB += 6;
					flag4 = true;
				}
				if (!flag4)
				{
					if (flag)
					{
						SetDualInverted(num, num2, num3, ref normalized, ref lpos, ref currentVOB, ref tmpV);
						currentVOB += 3;
					}
					else if (flag2)
					{
						SetDualInverted(num2, num, num3, ref normalized, ref lpos, ref currentVOB, ref tmpV);
						currentVOB += 3;
					}
					else if (flag3)
					{
						SetDualInverted(num3, num2, num, ref normalized, ref lpos, ref currentVOB, ref tmpV);
						currentVOB += 3;
					}
				}
			}
		}
		if (currentVOB < calculatedVerts.Length)
		{
			calculatedVerts[currentVOB].b = false;
		}
		CVOB = currentVOB;
	}

	private float GetPS_StartSpeed()
	{
		return system.main.startSpeed.mode switch
		{
			ParticleSystemCurveMode.TwoConstants => UnityEngine.Random.Range(system.main.startSpeed.constantMin, system.main.startSpeed.constantMax), 
			ParticleSystemCurveMode.Constant => system.main.startSpeed.constant, 
			ParticleSystemCurveMode.Curve => system.main.startSpeed.Evaluate(UnityEngine.Random.value), 
			ParticleSystemCurveMode.TwoCurves => system.main.startSpeed.Evaluate(UnityEngine.Random.value), 
			_ => 0f, 
		};
	}

	private bool EmitFromSubmesh()
	{
		int num = UnityEngine.Random.Range(0, CVOB / 3 - 1);
		num *= 3;
		float value = UnityEngine.Random.value;
		float value2 = UnityEngine.Random.value;
		Vector3 a = Vector3.Lerp(calculatedVerts[num].p, calculatedVerts[num + 1].p, value);
		Vector3 normalized = Vector3.Lerp(calculatedVerts[num].n, calculatedVerts[num + 1].n, value).normalized;
		a = Vector3.Lerp(a, calculatedVerts[num + 2].p, value2);
		normalized = Vector3.Lerp(normalized, calculatedVerts[num + 2].n, value2).normalized;
		ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
		float num2 = 1f;
		if (bottleSmash != null)
		{
			Vector3 normalized2 = base.transform.TransformDirection(normalized).normalized;
			num2 = (1f + Vector3.Dot((LVA.finalAnchor - LVA.finalPoint).normalized, normalized2)) / 2f;
			emitParams.velocity = normalized2 * GetPS_StartSpeed() * num2 * angleSpeedScalar;
		}
		else
		{
			emitParams.velocity = base.transform.TransformDirection(normalized).normalized * GetPS_StartSpeed();
		}
		emitParams.position = base.transform.TransformPoint(a);
		if (emitParams.velocity == Vector3.zero && CullNullNormals)
		{
			return false;
		}
		particlesToEmit -= 1f;
		if (Cork != null)
		{
			if (Cork.isKinematic && volumeOfParticles > 0f)
			{
				LVA.level = Mathf.Clamp01((volumeOfParticles * LVA.level - 1f) / volumeOfParticles);
			}
		}
		else if (volumeOfParticles > 0f)
		{
			LVA.level = Mathf.Clamp01((volumeOfParticles * LVA.level - 1f) / volumeOfParticles);
		}
		system.Emit(emitParams, 1);
		return true;
	}

	private void Update()
	{
		if (!emitting || Cork != null || LVA.level <= 0f)
		{
			return;
		}
		CalculateTrianglesToEmitFrom(tris, verts);
		particlesToEmit += emissionSpeed * Time.deltaTime;
		if (calculatedVerts.Length == 0)
		{
			particlesToEmit = 0f;
		}
		else if (!calculatedVerts[0].b)
		{
			particlesToEmit = 0f;
		}
		int num = 10;
		int num2 = num;
		while (particlesToEmit > 0f && (GetPS_StartSpeed() > 0f || !CullNullNormals))
		{
			num2 = ((!EmitFromSubmesh()) ? (num2 - 1) : num);
			if (num2 <= 0)
			{
				break;
			}
		}
	}
}
public class ConveyImpacts : MonoBehaviour
{
	public GhostPhysics _physics;

	private void OnCollisionEnter(Collision collision)
	{
		_physics.SendCollision(collision);
	}
}
public class GhostPhysics : MonoBehaviour
{
	private BottleSmash _smash;

	private Transform _ghost;

	public GameObject _ghostObject;

	public bool _redirectSelection;

	[Header("Reference")]
	public Transform _externalTransform;

	private void Start()
	{
		_smash = GetComponent<BottleSmash>();
		_ghost = UnityEngine.Object.Instantiate(_ghostObject).transform;
		_ghost.position = base.transform.position;
		_ghost.rotation = base.transform.rotation;
		_ghost.localScale = _smash.Glass.transform.localScale;
		_externalTransform = _ghost;
		_ghost.gameObject.GetComponent<MeshCollider>().sharedMesh = _smash.Glass.GetComponent<MeshFilter>().sharedMesh;
		_ghost.GetComponent<ConveyImpacts>()._physics = this;
	}

	private void OnDestroy()
	{
		if (_ghost != null)
		{
			UnityEngine.Object.Destroy(_ghost.gameObject);
		}
	}

	public void SendCollision(Collision col)
	{
		if (_smash != null)
		{
			_smash.AttemptCollision(col);
		}
	}

	public Transform GetController()
	{
		return _ghost;
	}

	private void Update()
	{
		if (_ghost != null)
		{
			base.transform.position = _ghost.position;
			base.transform.rotation = _ghost.rotation;
		}
	}
}
public class PickUpPotion : MonoBehaviour
{
	private GameObject Obj;

	private Rigidbody rObj;

	private float dist;

	private float d;

	public float offsetValue = 1f;

	private Vector2 beginDist;

	private void Start()
	{
	}

	private void Update()
	{
		Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
		if (Input.GetMouseButtonDown(0) && Obj == null)
		{
			RaycastHit hitInfo = default(RaycastHit);
			if (Physics.Raycast(ray, out hitInfo) && hitInfo.transform.gameObject.tag == "Potion")
			{
				dist = hitInfo.distance;
				beginDist = Input.mousePosition;
				Obj = hitInfo.transform.gameObject;
				rObj = Obj.GetComponent<Rigidbody>();
			}
		}
		else if (Obj != null && Input.GetMouseButtonDown(0))
		{
			rObj.isKinematic = false;
			rObj.useGravity = true;
			rObj = null;
			Obj = null;
		}
		if (Obj != null)
		{
			Vector2 vector = beginDist - (Vector2)Input.mousePosition;
			d = new Vector2(vector.x / (beginDist.x / 2f), vector.y / (beginDist.y / 2f)).magnitude;
			Obj.transform.position = ray.origin + ray.direction.normalized * dist + ray.direction.normalized * d * -1f * offsetValue;
		}
	}
}
public class PourLiquid : MonoBehaviour
{
	public float rateOfFlow = 1f;

	public BottleSmash smashScript;

	public LiquidVolumeAnimator liquid;

	public Transform controllingTransform;

	public ParticleSystem pouringParticleSystem;

	public float volumeOfParticles = 70f;

	private Rigidbody corkRB;

	private void Start()
	{
		if (smashScript != null && smashScript.Cork != null)
		{
			corkRB = smashScript.Cork.GetComponent<Rigidbody>();
		}
	}

	private void Update()
	{
		if (corkRB != null && (corkRB.isKinematic || !corkRB.gameObject.activeInHierarchy))
		{
			return;
		}
		float num = Vector3.Dot(controllingTransform.up, (liquid.finalPoint - liquid.finalAnchor).normalized);
		float num2 = (num + 1f) / 2f;
		float num3 = 0f;
		if (num2 < liquid.level)
		{
			num3 = (liquid.level - num2) * rateOfFlow;
			liquid.level = Mathf.Lerp(liquid.level, num2, Time.deltaTime * rateOfFlow);
		}
		if (num <= 0f)
		{
			if (liquid.level > float.Epsilon)
			{
				num3 = liquid.level;
			}
			liquid.level = Mathf.Lerp(liquid.level, 0f, Time.deltaTime * rateOfFlow);
		}
		if (!(pouringParticleSystem != null))
		{
			return;
		}
		ParticleSystem.MinMaxCurve rateOverTime = pouringParticleSystem.emission.rateOverTime;
		rateOverTime.constant = volumeOfParticles * num3;
		ParticleSystem.EmissionModule emission = pouringParticleSystem.emission;
		emission.rateOverTime = rateOverTime;
		if (num3 > 0f)
		{
			if (!pouringParticleSystem.isEmitting)
			{
				pouringParticleSystem.Play();
			}
		}
		else
		{
			pouringParticleSystem.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmitting);
		}
	}
}
public class Reset : MonoBehaviour
{
	public void ResetScene()
	{
		SceneManager.LoadScene(0);
	}
}
public class Flicker : MonoBehaviour
{
	public float MaxReduction;

	public float MaxIncrease;

	public float RateDamping;

	public float Strength;

	public bool StopFlickering;

	private Light _lightSource;

	private float _baseIntensity;

	private bool _flickering;

	public void Reset()
	{
		MaxReduction = 0.2f;
		MaxIncrease = 0.2f;
		RateDamping = 0.1f;
		Strength = 300f;
	}

	public void Start()
	{
		_lightSource = GetComponent<Light>();
		if (_lightSource == null)
		{
			UnityEngine.Debug.LogError("Flicker script must have a Light Component on the same GameObject.");
			return;
		}
		_baseIntensity = _lightSource.intensity;
		StartCoroutine(DoFlicker());
	}

	private void Update()
	{
		if (!StopFlickering && !_flickering)
		{
			StartCoroutine(DoFlicker());
		}
	}

	private IEnumerator DoFlicker()
	{
		_flickering = true;
		while (!StopFlickering)
		{
			_lightSource.intensity = Mathf.Lerp(_lightSource.intensity, UnityEngine.Random.Range(_baseIntensity - MaxReduction, _baseIntensity + MaxIncrease), Strength * Time.deltaTime);
			yield return new WaitForSeconds(RateDamping);
		}
		_flickering = false;
	}
}
public class InstantiateSparkParticles : MonoBehaviour
{
	public GameObject SparkParticle;

	public Transform Sawblade;

	private GameObject SparkParticlesLocal;

	private void Start()
	{
	}

	private void Update()
	{
	}

	public void InstantiateParticles()
	{
		SparkParticlesLocal = UnityEngine.Object.Instantiate(SparkParticle, new Vector3(Sawblade.position.x, base.transform.position.y, Sawblade.position.z), Quaternion.identity, Sawblade);
	}

	public void DestroyParticles()
	{
		UnityEngine.Object.Destroy(SparkParticlesLocal);
	}
}
public class ParticleMovment : MonoBehaviour
{
	private Transform Sawblade;

	private void Start()
	{
		Sawblade = base.transform.parent;
	}

	private void Update()
	{
		base.transform.position = new Vector3(Sawblade.position.x, base.transform.position.y, Sawblade.position.z);
	}
}
public class Example : MonoBehaviour
{
	public Animator animator;

	private void OnGUI()
	{
		if (GUILayout.Button("Go to Relax"))
		{
			animator.SetBool("goToRelax", value: true);
		}
		AnimatorControllerParameter[] parameters = animator.parameters;
		foreach (AnimatorControllerParameter animatorControllerParameter in parameters)
		{
			string text = null;
			switch (animatorControllerParameter.type)
			{
			case AnimatorControllerParameterType.Bool:
			case AnimatorControllerParameterType.Trigger:
				text = animator.GetBool(animatorControllerParameter.name).ToString();
				break;
			case AnimatorControllerParameterType.Float:
				text = animator.GetFloat(animatorControllerParameter.name).ToString();
				break;
			case AnimatorControllerParameterType.Int:
				text = animator.GetInteger(animatorControllerParameter.name).ToString();
				break;
			}
			GUILayout.Label("Parameter " + animatorControllerParameter.name + ": " + text);
		}
	}

	public void DeliberatelyThrowException()
	{
		throw new Exception("Exception thrown from user code.");
	}
}
public class AnimationScript : MonoBehaviour
{
	public bool isAnimated;

	public bool isRotating;

	public bool isFloating;

	public bool isScaling;

	public Vector3 rotationAngle;

	public float rotationSpeed;

	public float floatSpeed;

	private bool goingUp = true;

	public float floatRate;

	private float floatTimer;

	public Vector3 startScale;

	public Vector3 endScale;

	private bool scalingUp = true;

	public float scaleSpeed;

	public float scaleRate;

	private float scaleTimer;

	private void Start()
	{
	}

	private void Update()
	{
		if (!isAnimated)
		{
			return;
		}
		if (isRotating)
		{
			base.transform.Rotate(rotationAngle * rotationSpeed * Time.deltaTime);
		}
		if (isFloating)
		{
			floatTimer += Time.deltaTime;
			Vector3 translation = new Vector3(0f, 0f, floatSpeed);
			base.transform.Translate(translation);
			if (goingUp && floatTimer >= floatRate)
			{
				goingUp = false;
				floatTimer = 0f;
				floatSpeed = 0f - floatSpeed;
			}
			else if (!goingUp && floatTimer >= floatRate)
			{
				goingUp = true;
				floatTimer = 0f;
				floatSpeed = floatSpeed;
			}
		}
		if (!isScaling)
		{
			return;
		}
		scaleTimer += Time.deltaTime;
		if (scalingUp)
		{
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, endScale, scaleSpeed * Time.deltaTime);
		}
		else if (!scalingUp)
		{
			base.transform.localScale = Vector3.Lerp(base.transform.localScale, startScale, scaleSpeed * Time.deltaTime);
		}
		if (scaleTimer >= scaleRate)
		{
			if (scalingUp)
			{
				scalingUp = false;
			}
			else if (!scalingUp)
			{
				scalingUp = true;
			}
			scaleTimer = 0f;
		}
	}
}
[HelpURL("https://docs.google.com/document/d/13vul0zDF478he8hhteKjnxoLYgfW47G0Z9TSox21_J0/edit#heading=h.rp8ji698m9wz")]
[DisallowMultipleComponent]
[ExecuteInEditMode]
[RequireComponent(typeof(MeshRenderer))]
public class ADSGlobals : MonoBehaviour
{
	public enum DebugEnum
	{
		off = -1,
		vertexColorR = 1,
		vertexColorG = 2,
		vertexColorB = 3,
		vertexAlpha = 4,
		motionMask = 11,
		motionNoise = 12,
		grassTint = 21,
		grassSize = 22
	}

	public enum GrassTintModeEnum
	{
		texture,
		colors
	}

	public static ADSGlobals Instance;

	public DebugEnum debug = DebugEnum.off;

	[Space(20f)]
	public float globalAmplitude = 0.5f;

	public float globalSpeed = 4f;

	public float globalScale = 0.5f;

	[Space(20f)]
	public Texture2D noiseTexture;

	public float noiseContrast = 1f;

	public float noiseSpeed = 1f;

	public float noiseScale = 1f;

	[Space(20f)]
	public GrassTintModeEnum grassTintMode = GrassTintModeEnum.colors;

	public Texture2D grassTintTexture;

	public float grassTintIntensity = 1f;

	public Color grassTintColorOne = Color.white;

	public Color grassTintColorTwo = Color.white;

	public Vector4 grassTintScaleOffset = new Vector4(1f, 1f, 0f, 0f);

	[Space(20f)]
	public Texture2D grassSizeTexture;

	public float grassSizeMin;

	public float grassSizeMax = 1f;

	public Vector4 grassSizeScaleOffset = new Vector4(1f, 1f, 0f, 0f);

	[Space(20f)]
	public List<Mesh> ADSObjects = new List<Mesh>();

	private bool somethingChanged;

	private float old_globalAmplitude;

	private float old_globalSpeed;

	private float old_globalScale;

	private Vector3 old_globalDirection;

	private Texture2D old_noiseTexture;

	private float old_noiseContrast;

	private float old_noiseSpeed;

	private float old_noiseScale;

	private GrassTintModeEnum old_grassTintMode;

	private Texture2D old_grassTintTexture;

	private float old_grassTintIntensity;

	private Color old_grassTintColorOne;

	private Color old_grassTintColorTwo;

	private Vector4 old_grassTintScaleOffset;

	private Texture2D old_grassSizeTexture;

	private float old_grassSizeMin;

	private float old_grassSizeMax;

	private Vector4 old_grassSizeScaleOffset;

	private Shader debugShader;

	private bool debugShader_ON;

	private void Awake()
	{
		if (Instance != null && Instance != this)
		{
			base.gameObject.SetActive(value: false);
			return;
		}
		Instance = this;
		base.gameObject.name = "ADS Globals";
		ADSObjects = new List<Mesh>();
		SetGlobalShaderProperties();
		if (UnityEngine.Application.isPlaying)
		{
			base.gameObject.GetComponent<MeshRenderer>().enabled = false;
		}
		else
		{
			base.gameObject.GetComponent<MeshRenderer>().enabled = true;
		}
	}

	private void SetGlobalShaderProperties()
	{
		Shader.SetGlobalVector("ADS_GlobalDirection", base.gameObject.transform.forward);
		Shader.SetGlobalFloat("ADS_GlobalAmplitude", globalAmplitude);
		Shader.SetGlobalFloat("ADS_GlobalSpeed", globalSpeed);
		Shader.SetGlobalFloat("ADS_GlobalScale", globalScale);
		if (noiseTexture == null || noiseContrast <= 0f)
		{
			Shader.SetGlobalFloat("ADS_NoiseTex_ON", 0f);
		}
		else
		{
			Shader.SetGlobalFloat("ADS_NoiseTex_ON", 1f);
			Shader.SetGlobalTexture("ADS_NoiseTex", noiseTexture);
			Shader.SetGlobalFloat("ADS_NoiseContrast", noiseContrast);
			Shader.SetGlobalFloat("ADS_NoiseSpeed", noiseSpeed * 0.1f);
			Shader.SetGlobalFloat("ADS_NoiseScale", noiseScale * 0.1f);
		}
		if (grassTintTexture == null || grassTintIntensity <= 0f || (grassTintColorOne == Color.white && grassTintColorTwo == Color.white))
		{
			Shader.SetGlobalFloat("ADS_GrassTintTex_ON", 0f);
		}
		else
		{
			if (grassTintMode == GrassTintModeEnum.texture)
			{
				Shader.SetGlobalFloat("ADS_GrassTintModeColors", 0f);
			}
			else
			{
				Shader.SetGlobalFloat("ADS_GrassTintModeColors", 1f);
			}
			Shader.SetGlobalFloat("ADS_GrassTintTex_ON", 1f);
			Shader.SetGlobalTexture("ADS_GrassTintTex", grassTintTexture);
			Shader.SetGlobalFloat("ADS_GrassTintIntensity", grassTintIntensity);
			Shader.SetGlobalColor("ADS_GrassTintColorOne", grassTintColorOne);
			Shader.SetGlobalColor("ADS_GrassTintColorTwo", grassTintColorTwo);
			Shader.SetGlobalVector("ADS_GrassTintScaleOffset", grassTintScaleOffset);
		}
		if (grassSizeTexture == null)
		{
			Shader.SetGlobalFloat("ADS_GrassSizeTex_ON", 0f);
			return;
		}
		Shader.SetGlobalFloat("ADS_GrassSizeTex_ON", 1f);
		Shader.SetGlobalTexture("ADS_GrassSizeTex", grassSizeTexture);
		Shader.SetGlobalFloat("ADS_GrassSizeMin", grassSizeMin - 1f);
		Shader.SetGlobalFloat("ADS_GrassSizeMax", grassSizeMax - 1f);
		Shader.SetGlobalVector("ADS_GrassSizeScaleOffset", grassSizeScaleOffset);
	}

	private void CheckSomethingChanged()
	{
		somethingChanged |= old_globalAmplitude != globalAmplitude;
		somethingChanged |= old_globalSpeed != globalSpeed;
		somethingChanged |= old_globalScale != globalScale;
		somethingChanged |= old_globalDirection != base.gameObject.transform.forward;
		somethingChanged |= old_noiseTexture != noiseTexture;
		somethingChanged |= old_noiseContrast != noiseContrast;
		somethingChanged |= old_noiseSpeed != noiseSpeed;
		somethingChanged |= old_noiseScale != noiseScale;
		somethingChanged |= old_grassTintMode != grassTintMode;
		somethingChanged |= old_grassTintTexture != grassTintTexture;
		somethingChanged |= old_grassTintIntensity != grassTintIntensity;
		somethingChanged |= old_grassTintColorOne != grassTintColorOne;
		somethingChanged |= old_grassTintColorTwo != grassTintColorTwo;
		somethingChanged |= old_grassTintScaleOffset != grassTintScaleOffset;
		somethingChanged |= old_grassSizeTexture != grassSizeTexture;
		somethingChanged |= old_grassSizeMin != grassSizeMin;
		somethingChanged |= old_grassSizeMax != grassSizeMax;
		somethingChanged |= old_grassSizeScaleOffset != grassSizeScaleOffset;
	}

	private void UpdateSomethingChanged()
	{
		somethingChanged = false;
		old_globalAmplitude = globalAmplitude;
		old_globalSpeed = globalSpeed;
		old_globalScale = globalScale;
		old_globalDirection = base.gameObject.transform.forward;
		old_noiseTexture = noiseTexture;
		old_noiseContrast = noiseContrast;
		old_noiseSpeed = noiseSpeed;
		old_noiseScale = noiseScale;
		old_grassTintMode = grassTintMode;
		old_grassTintTexture = grassTintTexture;
		old_grassTintIntensity = grassTintIntensity;
		old_grassTintColorOne = grassTintColorOne;
		old_grassTintColorTwo = grassTintColorTwo;
		old_grassTintScaleOffset = grassTintScaleOffset;
		old_grassSizeTexture = grassSizeTexture;
		old_grassSizeMin = grassSizeMin;
		old_grassSizeMax = grassSizeMax;
		old_grassSizeScaleOffset = grassSizeScaleOffset;
	}
}
[HelpURL("https://docs.google.com/document/d/13vul0zDF478he8hhteKjnxoLYgfW47G0Z9TSox21_J0/edit#heading=h.rp8ji698m9wz")]
[DisallowMultipleComponent]
[ExecuteInEditMode]
public class ADSObject : MonoBehaviour
{
	private Mesh sharedMesh;

	private void Awake()
	{
		if (base.gameObject.GetComponent<MeshFilter>() != null && base.gameObject.GetComponent<MeshFilter>().sharedMesh != null && ADSGlobals.Instance != null)
		{
			sharedMesh = base.gameObject.GetComponent<MeshFilter>().sharedMesh;
			if (!ADSGlobals.Instance.ADSObjects.Contains(sharedMesh))
			{
				ADSGlobals.Instance.ADSObjects.Add(sharedMesh);
				LocalPosToUV(sharedMesh);
			}
		}
	}

	private void LocalPosToUV(Mesh mesh)
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < mesh.vertices.Length; i++)
		{
			list.Add(new Vector3(mesh.vertices[i].x, mesh.vertices[i].y, mesh.vertices[i].z));
		}
		mesh.SetUVs(3, list);
		list.Clear();
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/Colors/RGB")]
public class CameraFilterPack_Color_RGB : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Vector4 ScreenResolution;

	private Material SCMaterial;

	public Color ColorRGB = new Color(1f, 1f, 1f);

	public static Color ChangeColorRGB;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		ChangeColorRGB = ColorRGB;
		SCShader = Shader.Find("CameraFilterPack/Color_RGB");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetColor("_ColorRGB", ColorRGB);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		if (UnityEngine.Application.isPlaying)
		{
			ColorRGB = ChangeColorRGB;
		}
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
[ExecuteInEditMode]
[AddComponentMenu("Camera Filter Pack/FX/Spot")]
public class CameraFilterPack_FX_Spot : MonoBehaviour
{
	public Shader SCShader;

	private float TimeX = 1f;

	private Vector4 ScreenResolution;

	private Material SCMaterial;

	public Vector2 center = new Vector2(0.5f, 0.5f);

	public float Radius = 0.2f;

	public static Vector2 Changecenter;

	public static float ChangeRadius;

	private Material material
	{
		get
		{
			if (SCMaterial == null)
			{
				SCMaterial = new Material(SCShader);
				SCMaterial.hideFlags = HideFlags.HideAndDontSave;
			}
			return SCMaterial;
		}
	}

	private void Start()
	{
		Changecenter = center;
		ChangeRadius = Radius;
		SCShader = Shader.Find("CameraFilterPack/FX_Spot");
		if (!SystemInfo.supportsImageEffects)
		{
			base.enabled = false;
		}
	}

	private void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
	{
		if (SCShader != null)
		{
			TimeX += Time.deltaTime;
			if (TimeX > 100f)
			{
				TimeX = 0f;
			}
			material.SetFloat("_TimeX", TimeX);
			material.SetFloat("_PositionX", center.x);
			material.SetFloat("_PositionY", center.y);
			material.SetFloat("_Radius", Radius);
			material.SetVector("_ScreenResolution", new Vector4(sourceTexture.width, sourceTexture.height, 0f, 0f));
			Graphics.Blit(sourceTexture, destTexture, material);
		}
		else
		{
			Graphics.Blit(sourceTexture, destTexture);
		}
	}

	private void Update()
	{
		if (UnityEngine.Application.isPlaying)
		{
			center = Changecenter;
			Radius = ChangeRadius;
		}
	}

	private void OnDisable()
	{
		if ((bool)SCMaterial)
		{
			UnityEngine.Object.DestroyImmediate(SCMaterial);
		}
	}
}
public class ChainMouseOrbit_C : MonoBehaviour
{
	public Transform target;

	public float distance = 10f;

	public Vector3 targetOffset;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
		_ = (bool)base.transform.GetComponent("Rigidbody");
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 b = quaternion * new Vector3(0f, 0f, 0f - distance) + target.position + targetOffset;
			base.transform.rotation = Quaternion.Slerp(base.transform.rotation, quaternion, Time.deltaTime * 2f);
			base.transform.position = Vector3.Slerp(base.transform.position, b, Time.deltaTime * 2f);
		}
	}

	public float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(50f, 30f, 100f, 30f), "Reset"))
		{
			SceneManager.LoadScene(UnityEngine.Application.loadedLevel);
		}
	}
}
public class ChainRelease_C : MonoBehaviour
{
	public string Keystroke = "";

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKeyUp(Keystroke))
		{
			if ((bool)base.gameObject.GetComponent("HingeJoint"))
			{
				UnityEngine.Object.Destroy(base.gameObject.GetComponent("HingeJoint"));
			}
			if ((bool)base.gameObject.GetComponent("CharacterJoint"))
			{
				UnityEngine.Object.Destroy(base.gameObject.GetComponent("CharacterJoint"));
			}
		}
	}
}
public class ChainRotate_C : MonoBehaviour
{
	public float speedx;

	public float speedy;

	public float speedz;

	private bool UseCenter;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.Rotate(speedx * Time.deltaTime, speedy * Time.deltaTime, speedz * Time.deltaTime);
	}
}
public class Beam : MonoBehaviour
{
	public AudioSource EffectSource;

	public AudioClip EffectSound;

	public Renderer SourceRenderer;

	private Material[] EffectMaterials;

	public float EffectLength;

	private void Start()
	{
		EffectMaterials = SourceRenderer.materials;
	}

	private void SetMaterialParms(float amount)
	{
		Material[] effectMaterials = EffectMaterials;
		for (int i = 0; i < effectMaterials.Length; i++)
		{
			effectMaterials[i].SetFloat("_DisintegrateAmount", amount);
		}
	}

	private IEnumerator doBeamOut(bool Destroy)
	{
		if (EffectSource != null && EffectSound != null)
		{
			EffectLength = EffectSound.length;
			EffectSource.PlayOneShot(EffectSound);
		}
		for (float LengthLeft = EffectLength; LengthLeft > 0f; LengthLeft -= Time.deltaTime)
		{
			float materialParms = 1f - LengthLeft / EffectLength;
			SetMaterialParms(materialParms);
			yield return null;
		}
		SetMaterialParms(1.01f);
		if (Destroy)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	private IEnumerator doBeamIn()
	{
		if (EffectSource != null && EffectSound != null)
		{
			EffectLength = EffectSound.length;
			EffectSource.PlayOneShot(EffectSound);
		}
		for (float LengthLeft = EffectLength; LengthLeft > 0f; LengthLeft -= Time.deltaTime)
		{
			float materialParms = LengthLeft / EffectLength;
			SetMaterialParms(materialParms);
			yield return null;
		}
		SetMaterialParms(0f);
	}

	public void BeamOut(bool doDestroy)
	{
		StartCoroutine(doBeamOut(doDestroy));
	}

	public void BeamIn()
	{
		StartCoroutine(doBeamIn());
	}

	public void BeamOut(float Length, bool doDestroy)
	{
		EffectLength = Length;
		BeamOut(doDestroy);
	}

	public void BeamIn(float Length)
	{
		EffectLength = Length;
		BeamIn();
	}

	public void OnDestroy()
	{
		Material[] effectMaterials = EffectMaterials;
		for (int i = 0; i < effectMaterials.Length; i++)
		{
			UnityEngine.Object.Destroy(effectMaterials[i]);
		}
	}
}
public class example : MonoBehaviour
{
	private void Awake()
	{
		GetComponent<Renderer>().material.color = Color.red;
	}
}
public class BeamController : MonoBehaviour
{
	public List<Beam> BeamObjects = new List<Beam>();

	public AudioSource EffectSource;

	public AudioClip EffectSound;

	public bool PlaySound;

	public float EffectLength = 3f;

	private void Start()
	{
		if (BeamObjects.Count == 0)
		{
			BeamObjects.AddRange(GetComponentsInChildren<Beam>());
		}
	}

	private float StartEffect()
	{
		if (PlaySound && EffectSource != null && EffectSound != null)
		{
			EffectSource.PlayOneShot(EffectSound);
			return EffectSound.length;
		}
		return EffectLength;
	}

	public void BeamOut(bool Destroy)
	{
		float length = StartEffect();
		foreach (Beam beamObject in BeamObjects)
		{
			beamObject.BeamOut(length, Destroy);
		}
	}

	public void BeamIn()
	{
		float length = StartEffect();
		foreach (Beam beamObject in BeamObjects)
		{
			beamObject.BeamIn(length);
		}
	}
}
public class CustomColors : MonoBehaviour
{
	public Renderer CustomRenderer;

	private Material[] CustomMaterials;

	private void Awake()
	{
		CustomMaterials = CustomRenderer.materials;
	}

	private void OnDestroy()
	{
		Material[] customMaterials = CustomMaterials;
		for (int i = 0; i < customMaterials.Length; i++)
		{
			UnityEngine.Object.Destroy(customMaterials[i]);
		}
	}

	public void SetEyeColor(float r, float g, float b)
	{
		Material[] customMaterials = CustomMaterials;
		for (int i = 0; i < customMaterials.Length; i++)
		{
			customMaterials[i].SetColor("_EyeColor", new Color(r, g, b, 1f));
		}
	}

	public void SetSkinColor(float r, float g, float b)
	{
		Material[] customMaterials = CustomMaterials;
		for (int i = 0; i < customMaterials.Length; i++)
		{
			customMaterials[i].SetColor("_SkinColor", new Color(r, g, b, 1f));
		}
	}

	public void SetHairColor(float r, float g, float b)
	{
		Material[] customMaterials = CustomMaterials;
		for (int i = 0; i < customMaterials.Length; i++)
		{
			customMaterials[i].SetColor("_HairColor", new Color(r, g, b, 1f));
		}
	}
}
public class CustomColorsController : MonoBehaviour
{
	public List<CustomColors> ColorizableObjects = new List<CustomColors>();

	private void Start()
	{
		if (ColorizableObjects.Count == 0)
		{
			ColorizableObjects.AddRange(GetComponentsInChildren<CustomColors>());
		}
	}

	public void SetEyeColor(float r, float g, float b)
	{
		foreach (CustomColors colorizableObject in ColorizableObjects)
		{
			colorizableObject.SetEyeColor(r, g, b);
		}
	}

	public void SetSkinColor(float r, float g, float b)
	{
		foreach (CustomColors colorizableObject in ColorizableObjects)
		{
			colorizableObject.SetSkinColor(r, g, b);
		}
	}

	public void SetHairColor(float r, float g, float b)
	{
		foreach (CustomColors colorizableObject in ColorizableObjects)
		{
			colorizableObject.SetHairColor(r, g, b);
		}
	}
}
public class Hologram : MonoBehaviour
{
	public float ClipVariance = 5f;

	public float RimVariance = 0.5f;

	public float lightflicker = 0.3f;

	public Renderer HoloRenderer;

	public Light FlickerLight;

	private float clippower;

	private float rimpower;

	private float intensity;

	private Material[] HoloMaterials;

	private void Start()
	{
	}

	private void Awake()
	{
		HoloMaterials = HoloRenderer.materials;
		clippower = HoloMaterials[0].GetFloat("_ClipPower");
		rimpower = HoloMaterials[0].GetFloat("_RimPower");
		if (FlickerLight != null)
		{
			intensity = FlickerLight.intensity;
		}
	}

	public void EnableScanlines(bool enabled)
	{
		clippower = 301f;
	}

	private void Update()
	{
		float num = clippower - ClipVariance / 2f + UnityEngine.Random.value * ClipVariance;
		float value = UnityEngine.Random.value;
		float num2 = value * RimVariance;
		float num3 = rimpower - RimVariance / 2f;
		if (num < 0f)
		{
			num = 0f;
		}
		if (num3 < 0f)
		{
			num3 = 0f;
		}
		Material[] holoMaterials = HoloMaterials;
		foreach (Material obj in holoMaterials)
		{
			obj.SetFloat("_RimPower", num3);
			obj.SetFloat("_ClipPower", num);
		}
		if (FlickerLight != null)
		{
			if (num2 < 0f)
			{
				FlickerLight.intensity = intensity - intensity * lightflicker * value;
			}
			else
			{
				FlickerLight.intensity = intensity + intensity * lightflicker * value;
			}
		}
	}

	private void OnDestroy()
	{
		Material[] holoMaterials = HoloMaterials;
		for (int i = 0; i < holoMaterials.Length; i++)
		{
			UnityEngine.Object.Destroy(holoMaterials[i]);
		}
	}
}
public class Stone : MonoBehaviour
{
	public AudioSource StoneSource;

	public AudioClip StoneSound;

	public Renderer SourceRenderer;

	public Animation SourceAnimation;

	private bool IsStone;

	private Material[] EffectMaterials;

	public float EffectLength;

	private void Start()
	{
		EffectMaterials = SourceRenderer.materials;
	}

	public void OnDestroy()
	{
		Material[] effectMaterials = EffectMaterials;
		for (int i = 0; i < effectMaterials.Length; i++)
		{
			UnityEngine.Object.Destroy(effectMaterials[i]);
		}
	}

	private void SetMaterialParms(float amount)
	{
		Material[] effectMaterials = EffectMaterials;
		foreach (Material material in effectMaterials)
		{
			if (material.shader.name.Contains("Character/Statue"))
			{
				material.SetFloat("_DiffuseAmount", amount);
			}
		}
	}

	private float StartEffect()
	{
		if (StoneSource != null && StoneSound != null)
		{
			EffectLength = StoneSound.length;
			StoneSource.PlayOneShot(StoneSound);
		}
		return EffectLength;
	}

	private IEnumerator doTurnToStone()
	{
		if (IsStone)
		{
			yield break;
		}
		IsStone = true;
		if (SourceAnimation != null)
		{
			foreach (AnimationState item in SourceAnimation.GetComponent<Animation>())
			{
				item.speed = 0f;
			}
		}
		for (float LengthLeft = StartEffect(); LengthLeft > 0f; LengthLeft -= Time.deltaTime)
		{
			float materialParms = LengthLeft / EffectLength;
			SetMaterialParms(materialParms);
			yield return null;
		}
		SetMaterialParms(0f);
	}

	private IEnumerator doStoneToFlesh()
	{
		if (!IsStone)
		{
			yield break;
		}
		for (float LengthLeft = StartEffect(); LengthLeft > 0f; LengthLeft -= Time.deltaTime)
		{
			float materialParms = 1f - LengthLeft / EffectLength;
			SetMaterialParms(materialParms);
			yield return null;
		}
		SetMaterialParms(1f);
		if (SourceAnimation != null)
		{
			foreach (AnimationState item in SourceAnimation.GetComponent<Animation>())
			{
				item.speed = 1f;
			}
		}
		IsStone = false;
	}

	public void TurnToStone()
	{
		StartCoroutine(doTurnToStone());
	}

	public void StoneToFlesh()
	{
		StartCoroutine(doStoneToFlesh());
	}

	public void TurnToStone(float length)
	{
		EffectLength = length;
		TurnToStone();
	}

	public void StoneToFlesh(float length)
	{
		EffectLength = length;
		StoneToFlesh();
	}
}
public class StoneController : MonoBehaviour
{
	public List<Stone> StoneableObjects = new List<Stone>();

	public AudioSource EffectSource;

	public AudioClip EffectSound;

	public bool PlaySound;

	public float EffectLength = 3f;

	public bool IsStone;

	private void Start()
	{
		if (StoneableObjects.Count == 0)
		{
			StoneableObjects.AddRange(GetComponentsInChildren<Stone>());
		}
	}

	private float StartEffect()
	{
		if (PlaySound && EffectSource != null && EffectSound != null)
		{
			EffectSource.PlayOneShot(EffectSound);
			return EffectSound.length;
		}
		return EffectLength;
	}

	public void TurnToStone()
	{
		if (IsStone)
		{
			return;
		}
		IsStone = true;
		float length = StartEffect();
		foreach (Stone stoneableObject in StoneableObjects)
		{
			stoneableObject.TurnToStone(length);
		}
	}

	public void StoneToFlesh()
	{
		if (!IsStone)
		{
			return;
		}
		IsStone = false;
		float length = StartEffect();
		foreach (Stone stoneableObject in StoneableObjects)
		{
			stoneableObject.StoneToFlesh(length);
		}
	}
}
public class SALSA_Template_EventControllerSubscriber : MonoBehaviour
{
	public string componentEventName;

	private void OnEnable()
	{
		EventController.AnimationStarting += OnAnimationStarting;
		EventController.AnimationON += OnAnimationON;
		EventController.AnimationEnding += OnAnimationEnding;
		EventController.AnimationOFF += OnAnimationOFF;
	}

	private void OnDisable()
	{
		EventController.AnimationStarting -= OnAnimationStarting;
		EventController.AnimationON -= OnAnimationON;
		EventController.AnimationEnding -= OnAnimationEnding;
		EventController.AnimationOFF -= OnAnimationOFF;
	}

	private void OnAnimationStarting(object sender, EventController.EventControllerNotificationArgs e)
	{
		if (e.eventName == componentEventName)
		{
			UnityEngine.Debug.Log("EventController fired OnAnimationStarting for: " + componentEventName);
		}
	}

	private void OnAnimationON(object sender, EventController.EventControllerNotificationArgs e)
	{
		if (e.eventName == componentEventName)
		{
			UnityEngine.Debug.Log("EventController fired OnAnimationON for: " + componentEventName);
		}
	}

	private void OnAnimationEnding(object sender, EventController.EventControllerNotificationArgs e)
	{
		if (e.eventName == componentEventName)
		{
			UnityEngine.Debug.Log("EventController fired OnAnimationEnding for: " + componentEventName);
		}
	}

	private void OnAnimationOFF(object sender, EventController.EventControllerNotificationArgs e)
	{
		if (e.eventName == componentEventName)
		{
			UnityEngine.Debug.Log("EventController fired OnAnimationOFF for: " + componentEventName);
		}
	}
}
public class SALSA_Template_SalsaEventSubscriber : MonoBehaviour
{
	public Salsa salsa;

	private void OnEnable()
	{
		Salsa.StartedSalsaing += OnStartedSalsaing;
		Salsa.StoppedSalsaing += OnStoppedSalsaing;
	}

	private void OnDisable()
	{
		Salsa.StartedSalsaing -= OnStartedSalsaing;
		Salsa.StoppedSalsaing -= OnStoppedSalsaing;
	}

	private void OnStoppedSalsaing(object sender, Salsa.SalsaNotificationArgs e)
	{
		if (e.salsaInstance == salsa)
		{
			UnityEngine.Debug.Log("SALSA fired OnStoppedSalsaing for: " + e.salsaInstance.name);
		}
	}

	private void OnStartedSalsaing(object sender, Salsa.SalsaNotificationArgs e)
	{
		if (e.salsaInstance == salsa)
		{
			UnityEngine.Debug.Log("SALSA fired OnStartedSalsaing for: " + e.salsaInstance.name);
		}
	}
}
public class SALSA_Template_SalsaVisemeTriggerEventSubscriber : MonoBehaviour
{
	public Salsa salsaInstance;

	private void OnEnable()
	{
		Salsa.VisemeTriggered += SalsaOnVisemeTriggered;
	}

	private void OnDisable()
	{
		Salsa.VisemeTriggered -= SalsaOnVisemeTriggered;
	}

	private void SalsaOnVisemeTriggered(object sender, Salsa.SalsaNotificationArgs e)
	{
		if (e.salsaInstance == salsaInstance)
		{
			UnityEngine.Debug.Log("Viseme triggered: " + e.visemeTrigger);
		}
	}
}
public class CheckIfSomethinkBelow : MonoBehaviour
{
	public GameObject Timber;

	public string timberTag;

	private void OnTriggerExit(Collider other)
	{
		if (other.CompareTag(timberTag))
		{
			Timber.GetComponent<Rigidbody>().isKinematic = false;
		}
	}
}
public class DestroyOnGround : MonoBehaviour
{
	private bool startCounting;

	private float countedTime;

	private float timeTillDestroy;

	private bool destroyOnGround;

	private void Start()
	{
		PhysicsMenu component = GetComponent<PhysicsMenu>();
		timeTillDestroy = component.timeTillDestroyOnGroundCollision;
		destroyOnGround = component.destroyOnGroundCollision;
	}

	private void Update()
	{
		if (startCounting && destroyOnGround)
		{
			countedTime += Time.deltaTime;
			if (countedTime >= timeTillDestroy)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.tag == "Ground_Checker" && (bool)GetComponent<Rigidbody>() && !GetComponent<Rigidbody>().isKinematic)
		{
			startCounting = true;
		}
	}
}
public class DetectCollision : MonoBehaviour
{
	private string[] tags;

	public GameObject timber;

	private bool calculatePhysicsAllTheTime;

	private bool destroyHittedObjects;

	private bool CalculatePhysicsOnce;

	private float calculatePhysicsFor;

	private bool objectIsHitted;

	private float timePhysicIsCalculated;

	private void Start()
	{
		PhysicsMenu component = timber.GetComponent<PhysicsMenu>();
		calculatePhysicsAllTheTime = component.calculatePhysicsAllTheTime;
		destroyHittedObjects = component.destroyHittedObjects;
		CalculatePhysicsOnce = component.CalculatePhysicsOnce;
		calculatePhysicsFor = component.calculatePhysicsFor;
		tags = component.tags;
	}

	private void Update()
	{
		if (!objectIsHitted)
		{
			return;
		}
		if (!calculatePhysicsAllTheTime)
		{
			timePhysicIsCalculated += Time.deltaTime;
		}
		if (timePhysicIsCalculated >= calculatePhysicsFor)
		{
			timber.GetComponent<Rigidbody>().isKinematic = true;
			objectIsHitted = false;
			if (!CalculatePhysicsOnce)
			{
				timePhysicIsCalculated = 0f;
			}
			if (destroyHittedObjects)
			{
				DestroyTimber();
			}
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		for (int i = 0; i < tags.Length; i++)
		{
			string text = tags[i];
			if (other.tag == text && text != null)
			{
				objectIsHitted = true;
				timber.GetComponent<Rigidbody>().isKinematic = false;
			}
		}
	}

	private void DestroyTimber()
	{
		UnityEngine.Object.Destroy(timber.gameObject);
	}
}
public class PhysicsMenu : MonoBehaviour
{
	public string[] tags;

	public bool calculatePhysicsAllTheTime;

	public bool destroyHittedObjects;

	public bool CalculatePhysicsOnce;

	public float calculatePhysicsFor;

	public bool destroyOnGroundCollision;

	public int timeTillDestroyOnGroundCollision;
}
public class NumpadLogic : MonoBehaviour
{
	public string winCode = "4236";

	protected string currentCode = "0000";

	public UnityEvent onWin;

	public TextMeshProUGUI display;

	private void Awake()
	{
		currentCode = display.text;
	}

	public void ButtonPressed(int val)
	{
		currentCode = currentCode.Substring(1) + val;
		display.text = currentCode;
		if (currentCode == winCode)
		{
			UnityEngine.Debug.Log("WINNER!");
			if (onWin != null)
			{
				onWin.Invoke();
			}
		}
	}
}
public class OVRInputAxis1DAction : FloatAction
{
	public OVRInput.Controller controller = OVRInput.Controller.Active;

	public OVRInput.Axis1D axis;

	private void Update()
	{
		Receive(OVRInput.Get(axis, controller));
	}
}
public class OVRInputAxis2DAction : Vector2Action
{
	public OVRInput.Controller controller = OVRInput.Controller.Active;

	public OVRInput.Axis2D axis;

	private void Update()
	{
		Receive(OVRInput.Get(axis, controller));
	}
}
public class OVRInputButtonAction : BooleanAction
{
	public OVRInput.Controller controller = OVRInput.Controller.Active;

	public OVRInput.Button button;

	private void Update()
	{
		Receive(OVRInput.Get(button, controller));
	}
}
public class OVRInputTouchAction : BooleanAction
{
	public OVRInput.Controller controller = OVRInput.Controller.Active;

	public OVRInput.Touch touch;

	private void Update()
	{
		Receive(OVRInput.Get(touch, controller));
	}
}
public class PauseMenuLogic : MonoBehaviour
{
	public GameEvent pauseEvent;

	public TeleporterFacade teleporter;

	public Transform playArea;

	public Transform headOrientation;

	public Transform pauseLocation;

	public Transform gameLocation;

	protected bool inPauseMenu;

	public List<GameObject> pauseItems;

	public List<GameObject> gameItems;

	public GameObject teleportationRelease;

	public GameObject teleportationPress;

	private void OnEnable()
	{
		GameEvent gameEvent = pauseEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Combine(gameEvent.OnTrue, new System.Action(OnEventRaised));
	}

	private void OnDisable()
	{
		GameEvent gameEvent = pauseEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(OnEventRaised));
	}

	public void OnEventRaised()
	{
		TransformData destination = new TransformData(gameLocation);
		if (!inPauseMenu)
		{
			gameLocation.position = new Vector3(headOrientation.position.x, playArea.position.y, headOrientation.position.z);
			Vector3 forward = Vector3.Cross(Vector3.Cross(playArea.up, headOrientation.forward), playArea.up);
			gameLocation.rotation = Quaternion.LookRotation(forward, playArea.up);
			destination = new TransformData(pauseLocation);
		}
		teleporter.Teleport(destination);
		inPauseMenu = !inPauseMenu;
		foreach (GameObject pauseItem in pauseItems)
		{
			pauseItem.SetActive(inPauseMenu);
		}
		foreach (GameObject gameItem in gameItems)
		{
			gameItem.SetActive(!inPauseMenu);
		}
	}

	public void ResetGame()
	{
		SceneManager.LoadScene("Final", LoadSceneMode.Single);
	}

	public void SwitchTeleportationToPress(bool value)
	{
		teleportationRelease.SetActive(!value);
		teleportationPress.SetActive(value);
	}

	public void SwitchTeleportationToRelease(bool value)
	{
		SwitchTeleportationToPress(!value);
	}
}
public class PhysicalButtonPressed : MonoBehaviour
{
	public UnityEvent onPressed;

	protected bool lastState;

	public void SetState(bool state)
	{
		if (state && !lastState && onPressed != null)
		{
			UnityEngine.Debug.Log("Button Pressed");
			onPressed.Invoke();
		}
		lastState = state;
	}
}
public class PointingGestureAction : MonoBehaviour
{
	public BoolVariable gripTrigger;

	public BoolVariable indexTrigger;

	public UnityEvent startPointing;

	public UnityEvent stopPointing;

	public BoolUnityEvent valueChanged;

	private bool _isPointing;

	private void Update()
	{
		bool flag = (bool)gripTrigger && !indexTrigger;
		if (_isPointing != flag)
		{
			valueChanged.Invoke(flag);
			if (flag)
			{
				startPointing.Invoke();
			}
			else
			{
				stopPointing.Invoke();
			}
			_isPointing = flag;
		}
	}
}
public class TeleporterActivation : BooleanAction
{
	public OVRInput.Controller controller = OVRInput.Controller.Active;

	protected OVRInput.Touch touch = OVRInput.Touch.PrimaryThumbstick;

	protected OVRInput.Axis2D axis = OVRInput.Axis2D.PrimaryThumbstick;

	protected float thumbstickDistanceSq = 0.5625f;

	protected bool validLastFrame;

	protected bool validTwoFramesAgo;

	private void Update()
	{
		bool flag = OVRInput.Get(touch, controller);
		Vector2 vector = OVRInput.Get(axis, controller);
		bool flag2 = !flag || vector.sqrMagnitude > thumbstickDistanceSq;
		bool flag3 = flag && flag2;
		if (validLastFrame && flag)
		{
			flag3 = true;
		}
		Receive(flag3 || validLastFrame || validTwoFramesAgo);
		validTwoFramesAgo = validLastFrame;
		validLastFrame = flag3;
	}
}
public class TeleporterSelection : BooleanAction
{
	public OVRInput.Controller controller = OVRInput.Controller.Active;

	public FloatAction extractX;

	public FloatAction extractY;

	protected OVRInput.Touch touch = OVRInput.Touch.PrimaryThumbstick;

	protected OVRInput.Axis2D axis = OVRInput.Axis2D.PrimaryThumbstick;

	protected bool wasThumbstickTouched;

	protected Vector2 lastThumbstickPos = new Vector2(0f, 1f);

	private void Update()
	{
		bool flag = OVRInput.Get(touch, controller);
		Vector2 normalized = OVRInput.Get(axis, controller).normalized;
		if (!flag || normalized.sqrMagnitude < 0.25f)
		{
			normalized = lastThumbstickPos;
		}
		Receive(!flag && wasThumbstickTouched);
		wasThumbstickTouched = flag;
		lastThumbstickPos = normalized;
		if (extractX != null)
		{
			extractX.Receive(normalized.x);
		}
		if (extractY != null)
		{
			extractY.Receive(normalized.y);
		}
	}
}
public class LightFlicker : MonoBehaviour
{
	private float initialValue;

	private Vector3 initialPosition;

	private Vector3 initialScale;

	private float initialTime;

	private Light lightRef;

	public float amount = 0.01f;

	public float speed = 8f;

	public bool adjustLocation;

	public float locationAdjustAmount = 1f;

	public bool adjustScale;

	public float scaleAdjustAmount = 1f;

	public Transform scaleObject;

	private void Start()
	{
		initialTime = UnityEngine.Random.value * 100f;
		lightRef = base.gameObject.GetComponent<Light>();
		if ((bool)lightRef)
		{
			initialValue = lightRef.intensity;
		}
		if (!scaleObject)
		{
			scaleObject = base.transform;
		}
		initialPosition = base.transform.position;
		initialScale = scaleObject.localScale;
	}

	private void Update()
	{
		float num = Mathf.PerlinNoise(Time.time * speed, initialTime);
		if ((bool)lightRef)
		{
			lightRef.intensity = initialValue + num * amount;
		}
		if (adjustLocation)
		{
			Vector3 vector = new Vector3(Mathf.PerlinNoise(Time.time * speed, initialTime + 5f) - 0.5f, num - 0.5f, Mathf.PerlinNoise(Time.time * speed, initialTime + 10f) - 0.5f);
			base.transform.position = initialPosition + vector * locationAdjustAmount * 2f;
		}
		if (adjustScale)
		{
			scaleObject.localScale = initialScale * ((num - 0.5f) * scaleAdjustAmount + 1f);
		}
	}
}
public class TileAnimation : MonoBehaviour
{
	public int xFrames = 4;

	public int yFrames = 4;

	public float speed;

	public bool billboard = true;

	public Camera mainCamera;

	private int frame;

	private Renderer rendererReference;

	private int randomStart;

	private void Awake()
	{
		rendererReference = base.gameObject.GetComponent<Renderer>();
		rendererReference.materials[0].mainTextureScale = new Vector2(1f / (float)xFrames, 1f / (float)yFrames);
		if (billboard && !mainCamera)
		{
			mainCamera = Camera.main;
		}
		randomStart = (int)(UnityEngine.Random.value * (float)xFrames * (float)yFrames);
	}

	private void Update()
	{
		frame = (int)Mathf.Repeat(Mathf.FloorToInt(Time.time * speed) + randomStart, xFrames * yFrames);
		int num = frame % xFrames;
		int num2 = frame / xFrames;
		rendererReference.materials[0].mainTextureOffset = new Vector2((float)num / ((float)xFrames * 1f), 1f - (float)(num2 + 1) / ((float)yFrames * 1f));
		if (billboard)
		{
			base.transform.LookAt(base.transform.position + mainCamera.transform.rotation * Vector3.forward, mainCamera.transform.rotation * Vector3.up);
		}
	}
}
public class INF_AnimSpeedRandomizer : MonoBehaviour
{
	public float speed = 1f;

	public float speed_rnd;

	private Animator myAnimator;

	private void Start()
	{
		myAnimator = base.gameObject.GetComponent<Animator>();
		myAnimator.speed = UnityEngine.Random.Range(speed - speed_rnd, speed + speed_rnd);
	}
}
public class INF_ContinuousRotation : MonoBehaviour
{
	public float X;

	public float Y;

	public float Z;

	public bool local;

	private void Update()
	{
		if (!local)
		{
			base.transform.Rotate(X * Time.deltaTime, Y * Time.deltaTime, Z * Time.deltaTime, Space.World);
		}
		else
		{
			base.transform.Rotate(X * Time.deltaTime, Y * Time.deltaTime, Z * Time.deltaTime);
		}
	}
}
public class INF_InitialPrefabGenerator : MonoBehaviour
{
	public GameObject[] createThese;

	private GameObject justCreated;

	public int createThisMany;

	public bool parentUnderCreator;

	public float x_rnd;

	public float y_rnd;

	public float z_rnd;

	public float x_rot_rnd;

	public float y_rot_rnd;

	public float z_rot_rnd;

	private void Start()
	{
		for (int i = 0; i < createThisMany; i++)
		{
			justCreated = UnityEngine.Object.Instantiate(createThese[UnityEngine.Random.Range(0, createThese.Length)], base.transform.position, base.transform.rotation);
			justCreated.transform.Translate(new Vector3(UnityEngine.Random.Range(0f - x_rnd, x_rnd), UnityEngine.Random.Range(0f - y_rnd, y_rnd), UnityEngine.Random.Range(0f - z_rnd, z_rnd)));
			justCreated.transform.Rotate(new Vector3(UnityEngine.Random.Range(0f - x_rot_rnd, x_rot_rnd), UnityEngine.Random.Range(0f - y_rot_rnd, y_rot_rnd), UnityEngine.Random.Range(0f - z_rot_rnd, z_rot_rnd)));
			if (parentUnderCreator)
			{
				justCreated.transform.parent = base.transform;
			}
		}
	}

	private void OnDrawGizmos()
	{
		Gizmos.matrix = base.transform.localToWorldMatrix;
		float x = 0.1f + x_rnd * 2f;
		float y = 0.1f + y_rnd * 2f;
		float z = 0.1f + z_rnd * 2f;
		Gizmos.DrawWireCube(Vector3.zero, new Vector3(x, y, z));
		Gizmos.DrawWireCube(new Vector3(0f, 0.25f + y_rnd, 0f), new Vector3(0.1f, 0.5f, 0.1f));
	}
}
public class INF_InitialRotation : MonoBehaviour
{
	public float X;

	public float Xrnd;

	public float Y;

	public float Yrnd;

	public float Z;

	public float Zrnd;

	public bool local;

	private float X_Actual;

	private float Y_Actual;

	private float Z_Actual;

	private void Start()
	{
		X_Actual = UnityEngine.Random.Range(X - Xrnd, X + Xrnd);
		Y_Actual = UnityEngine.Random.Range(Y - Yrnd, Y + Yrnd);
		Z_Actual = UnityEngine.Random.Range(Z - Zrnd, Z + Zrnd);
		if (!local)
		{
			base.transform.Rotate(X_Actual, Y_Actual, Z_Actual, Space.World);
		}
		else
		{
			base.transform.Rotate(X_Actual, Y_Actual, Z_Actual);
		}
	}
}
public class AE_MobileBloom : MonoBehaviour
{
	[Range(0.2f, 1f)]
	[UnityEngine.Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.5f;

	[Range(0.05f, 2f)]
	[UnityEngine.Tooltip("Blend factor of the result image.")]
	public float Intensity = 0.5f;

	private static float Threshold = 1.3f;

	private const string shaderName = "Hidden/KriptoFX/PostEffects/AE_Bloom";

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	private RenderTexture Source;

	private Material _bloomMaterial;

	private Material bloomMaterial
	{
		get
		{
			if (_bloomMaterial == null)
			{
				Shader shader = Shader.Find("Hidden/KriptoFX/PostEffects/AE_Bloom");
				if (shader == null)
				{
					UnityEngine.Debug.LogError("Can't find shader Hidden/KriptoFX/PostEffects/AE_Bloom");
				}
				_bloomMaterial = new Material(shader);
			}
			return _bloomMaterial;
		}
	}

	private void Start()
	{
	}

	private void OnPreRender()
	{
		Source = RenderTexture.GetTemporary(Screen.width, Screen.height, 24, SupportedHdrFormat());
		Camera.main.targetTexture = Source;
	}

	private void OnPostRender()
	{
		Camera.main.targetTexture = null;
		UpdateBloom(Source, null);
		RenderTexture.ReleaseTemporary(Source);
	}

	private RenderTextureFormat SupportedHdrFormat()
	{
		if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float))
		{
			return RenderTextureFormat.RGB111110Float;
		}
		return RenderTextureFormat.DefaultHDR;
	}

	private void UpdateBloom(RenderTexture source, RenderTexture dest)
	{
		int num = Screen.width / 2;
		int num2 = Screen.height / 2;
		RenderTextureFormat format = RenderTextureFormat.Default;
		int width = (int)((float)num * RenderTextureResolutoinFactor);
		num2 = (int)((float)num2 * RenderTextureResolutoinFactor);
		float num3 = Mathf.Log(num2, 2f) - 1f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float value = Mathf.GammaToLinearSpace(Threshold);
		bloomMaterial.SetFloat("_Threshold", value);
		float num6 = 0.5f + num3 - (float)num4;
		bloomMaterial.SetFloat("_SampleScale", num6 * 0.5f);
		bloomMaterial.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(width, num2, 0, format);
		Graphics.Blit(source, temporary, bloomMaterial, 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], bloomMaterial, 1);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num7 = num5 - 2; num7 >= 0; num7--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num7];
			bloomMaterial.SetTexture("_BaseTex", renderTexture2);
			m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num7], bloomMaterial, 2);
			renderTexture = m_blurBuffer2[num7];
		}
		RenderTexture temporary2 = RenderTexture.GetTemporary(renderTexture.width, renderTexture.height, 0, renderTexture.format);
		Graphics.Blit(renderTexture, temporary2, bloomMaterial, 3);
		bloomMaterial.SetTexture("_BaseTex", source);
		Graphics.Blit(temporary2, dest, bloomMaterial, 4);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary2);
		RenderTexture.ReleaseTemporary(temporary);
	}
}
public class AE_AttachEffectToArrow : MonoBehaviour
{
	public GameObject Arrow;

	private const string ArrowName = "Arrow";

	private bool isInitialized;

	private Transform child;

	private void OnEnable()
	{
		isInitialized = false;
		child = base.transform.GetChild(0);
		child.localPosition = Vector3.zero;
		child.localRotation = default(Quaternion);
	}

	private void LateUpdate()
	{
		if (!(Arrow == null))
		{
			child.position = Arrow.transform.position;
			child.rotation = Arrow.transform.rotation;
		}
	}

	private void Update()
	{
		if (Arrow == null || isInitialized)
		{
			return;
		}
		isInitialized = true;
		MeshRenderer component = Arrow.GetComponent<MeshRenderer>();
		if (component == null)
		{
			return;
		}
		Vector3 lossyScale = component.transform.lossyScale;
		float num = Mathf.Min(Mathf.Min(lossyScale.x, lossyScale.y), lossyScale.z);
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			if (particleSystem.name.Contains("Arrow"))
			{
				particleSystem.gameObject.SetActive(value: false);
				ParticleSystem.MainModule main = particleSystem.main;
				main.startSizeMultiplier /= num;
				ParticleSystem.ShapeModule shape = particleSystem.shape;
				shape.useMeshColors = false;
				shape.meshShapeType = ParticleSystemMeshShapeType.Triangle;
				shape.shapeType = ParticleSystemShapeType.MeshRenderer;
				shape.meshRenderer = component;
				particleSystem.gameObject.SetActive(value: true);
			}
		}
		MeshFilter[] componentsInChildren2 = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren2)
		{
			if (meshFilter.name.Contains("Arrow"))
			{
				meshFilter.sharedMesh = Arrow.GetComponent<MeshFilter>().sharedMesh;
				meshFilter.transform.rotation = Arrow.transform.rotation;
				meshFilter.transform.position = Arrow.transform.position;
				meshFilter.transform.localScale = lossyScale;
			}
		}
	}
}
public class AE_AttachEffectToBow : MonoBehaviour
{
	public GameObject Bow;

	private const string BowName = "Bow";

	private bool isInitialized;

	private Transform child;

	private void OnEnable()
	{
		isInitialized = false;
		child = base.transform.GetChild(0);
		child.localPosition = Vector3.zero;
		child.localRotation = default(Quaternion);
	}

	private void LateUpdate()
	{
		if (!(Bow == null))
		{
			child.position = Bow.transform.position;
			child.rotation = Bow.transform.rotation;
		}
	}

	private void Update()
	{
		if (Bow == null || isInitialized)
		{
			return;
		}
		isInitialized = true;
		MeshRenderer component = Bow.GetComponent<MeshRenderer>();
		if (component == null)
		{
			return;
		}
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			if (particleSystem.name.Contains("Bow"))
			{
				ParticleSystem.ShapeModule shape = particleSystem.shape;
				shape.useMeshColors = false;
				shape.meshShapeType = ParticleSystemMeshShapeType.Triangle;
				shape.shapeType = ParticleSystemShapeType.MeshRenderer;
				shape.meshRenderer = component;
			}
		}
		MeshFilter[] componentsInChildren2 = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren2)
		{
			if (meshFilter.name.Contains("Bow"))
			{
				meshFilter.sharedMesh = Bow.GetComponent<MeshFilter>().sharedMesh;
				meshFilter.transform.rotation = Bow.transform.rotation;
				meshFilter.transform.position = Bow.transform.position;
			}
		}
	}
}
public class AE_AttachToGround : MonoBehaviour
{
	public float Offset = 0.05f;

	private bool needUpdate;

	private void OnEnable()
	{
		needUpdate = true;
	}

	private void Update()
	{
		if (needUpdate)
		{
			needUpdate = false;
			Transform transform = base.transform;
			float num = transform.position.y;
			if (Physics.Raycast(transform.position + Vector3.up / 2f, Vector3.down, out var hitInfo))
			{
				num = Mathf.Min(num, hitInfo.point.y);
			}
			if (Physics.Raycast(transform.position + Vector3.up / 2f + new Vector3(1f, 0f, 0f), Vector3.down, out hitInfo))
			{
				num = Mathf.Min(num, hitInfo.point.y);
			}
			if (Physics.Raycast(transform.position + Vector3.up / 2f + new Vector3(-1f, 0f, 0f), Vector3.down, out hitInfo))
			{
				num = Mathf.Min(num, hitInfo.point.y);
			}
			if (Mathf.Abs(transform.position.y - num) > 0.001f)
			{
				base.transform.position = new Vector3(transform.position.x, num, transform.position.z);
				base.transform.rotation = Quaternion.LookRotation(Vector3.forward);
			}
		}
	}
}
public class AE_AudioEnableByRandom : MonoBehaviour
{
	public float EnableChance = 0.5f;

	private void OnEnable()
	{
		if (UnityEngine.Random.value < EnableChance)
		{
			GetComponent<AudioSource>().enabled = true;
		}
		else
		{
			GetComponent<AudioSource>().enabled = false;
		}
	}
}
public class AE_AudioPitchCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphPitchMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startPitch;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startPitch = audioSource.pitch;
		audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float pitch = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startPitch * GraphPitchMultiplier;
			audioSource.pitch = pitch;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(LineRenderer))]
public class AE_BowString : MonoBehaviour
{
	public float StringTint = 0.01f;

	public Transform Point1;

	public Transform Point2;

	public Transform HandBone;

	public bool InHand;

	private LineRenderer lineRenderer;

	private Vector3 prevHandPos;

	private const float tensionTime = 0.03f;

	private float currentTensionTime;

	private void OnEnable()
	{
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.widthMultiplier = StringTint;
		if (!(Point1 == null) && !(Point2 == null) && !(HandBone == null))
		{
			lineRenderer.positionCount = 3;
			prevHandPos = (Point1.position + Point2.position) / 2f;
			lineRenderer.SetPosition(0, Point1.position);
			lineRenderer.SetPosition(1, prevHandPos);
			lineRenderer.SetPosition(2, Point2.position);
		}
	}

	private void Update()
	{
		if (!(Point1 == null) && !(Point2 == null) && !(HandBone == null))
		{
			lineRenderer.widthMultiplier = StringTint;
			if (InHand)
			{
				lineRenderer.positionCount = 3;
				lineRenderer.SetPosition(0, Point1.position);
				lineRenderer.SetPosition(1, HandBone.position);
				lineRenderer.SetPosition(2, Point2.position);
				currentTensionTime = 0f;
				prevHandPos = HandBone.position;
			}
			else
			{
				currentTensionTime += Time.deltaTime;
				lineRenderer.positionCount = 3;
				Vector3 b = (Point1.position + Point2.position) / 2f;
				lineRenderer.SetPosition(0, Point1.position);
				lineRenderer.SetPosition(1, Vector3.Lerp(prevHandPos, b, Mathf.Clamp01(currentTensionTime / 0.03f)));
				lineRenderer.SetPosition(2, Point2.position);
			}
		}
	}
}
public class AE_CloneStartParams : MonoBehaviour
{
	[Serializable]
	public class CloneStartInfoProp
	{
		public Transform Transform;

		public float StartDelay;

		[HideInInspector]
		public float CurrentDelay;

		[HideInInspector]
		public GameObject Instance;
	}

	public AE_ClonesCreator clonesCreator;

	public RuntimeAnimatorController controller;

	public Material GhostMaterial;

	public AE_ShaderProperties ShaderFloatProperty = AE_ShaderProperties._Cutout;

	public AnimationCurve FadeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float FadeTime = 3.5f;

	public CloneStartInfoProp[] CloneStartInfo;

	private void OnEnable()
	{
		CloneStartInfoProp[] cloneStartInfo = CloneStartInfo;
		foreach (CloneStartInfoProp cloneStartInfoProp in cloneStartInfo)
		{
			cloneStartInfoProp.CurrentDelay = 0f;
			if (cloneStartInfoProp.Instance != null)
			{
				cloneStartInfoProp.Instance.SetActive(value: false);
			}
		}
	}

	private void Update()
	{
		CloneStartInfoProp[] cloneStartInfo = CloneStartInfo;
		foreach (CloneStartInfoProp cloneStartInfoProp in cloneStartInfo)
		{
			cloneStartInfoProp.CurrentDelay += Time.deltaTime;
			if (cloneStartInfoProp.CurrentDelay >= cloneStartInfoProp.StartDelay)
			{
				if (cloneStartInfoProp.Instance != null)
				{
					cloneStartInfoProp.Instance.SetActive(value: true);
				}
				else
				{
					cloneStartInfoProp.Instance = InstantiateClone(cloneStartInfoProp.Transform);
				}
			}
		}
	}

	private GameObject InstantiateClone(Transform parent)
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(clonesCreator.Character, parent);
		gameObject.SetActive(value: false);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = default(Quaternion);
		gameObject.GetComponent<Animator>().runtimeAnimatorController = controller;
		Renderer[] componentsInChildren = gameObject.GetComponentsInChildren<Renderer>();
		foreach (Renderer obj in componentsInChildren)
		{
			obj.material = GhostMaterial;
			AE_ShaderFloatCurve aE_ShaderFloatCurve = obj.transform.gameObject.AddComponent<AE_ShaderFloatCurve>();
			aE_ShaderFloatCurve.ShaderFloatProperty = ShaderFloatProperty;
			aE_ShaderFloatCurve.FloatCurve = FadeCurve;
			aE_ShaderFloatCurve.GraphTimeMultiplier = FadeTime;
		}
		gameObject.SetActive(value: true);
		return gameObject;
	}
}
public class AE_ClonesCreator : MonoBehaviour
{
	public GameObject Character;
}
public static class AE_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material material = renderer.material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
			UpdateShaderColor(renderer.transform, hue);
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
			UpdateShaderColor(particleSystemRenderer.transform, hue);
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren3)
		{
			Material material3 = skinnedMeshRenderer.material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					setMatHUEColor(material3, name3, hue);
				}
			}
			UpdateShaderColor(skinnedMeshRenderer.transform, hue);
		}
		Projector[] componentsInChildren4 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren4)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material4 = projector.material;
			if (material4 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name4 in array)
			{
				if (material4.HasProperty(name4))
				{
					projector.material = setMatHUEColor(material4, name4, hue);
				}
			}
			UpdateShaderColor(projector.transform, hue);
		}
		Light[] componentsInChildren5 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren5)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
			AE_LightCurves component = obj.GetComponent<AE_LightCurves>();
			if (component != null)
			{
				component.SetStartColor(HSVToColor(hsbColor));
			}
		}
		ParticleSystem[] componentsInChildren6 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem particleSystem in componentsInChildren6)
		{
			ParticleSystem.MainModule main = particleSystem.main;
			HSBColor hsbColor2 = ColorToHSV(particleSystem.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = particleSystem.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int k = 1; k < colorKeys.Length; k++)
			{
				hsbColor2 = ColorToHSV(colorKeys[k].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[k].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
			UpdateShaderColor(particleSystem.transform, hue);
		}
		AE_ShaderColorGradient[] componentsInChildren7 = go.GetComponentsInChildren<AE_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren7.Length; i++)
		{
			componentsInChildren7[i].HUE = hue;
		}
	}

	private static void UpdateShaderColor(Transform tr, float hue)
	{
		AE_ShaderColorGradient component = tr.GetComponent<AE_ShaderColorGradient>();
		if (component != null)
		{
			HSBColor hsbColor = ColorToHSV(Color.red);
			hsbColor.H = hue;
			component.SetStartColor(HSVToColor(hsbColor));
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
[ExecuteInEditMode]
public class AE_Decal : MonoBehaviour
{
	public bool UseWorldSpaceRotation;

	public bool UseRandomRotationAndScale = true;

	public float randomScalePercent = 20f;

	public bool IsScreenSpace = true;

	private ParticleSystem ps;

	private ParticleSystem.MainModule psMain;

	private MaterialPropertyBlock props;

	private MeshRenderer rend;

	private Vector3 startScale;

	private Vector3 worldRotation = new Vector3(0f, 0f, 0f);

	private void Awake()
	{
		startScale = base.transform.localScale;
	}

	private void OnEnable()
	{
		if (GetComponent<MeshRenderer>() == null)
		{
			return;
		}
		ps = GetComponent<ParticleSystem>();
		if (ps != null)
		{
			psMain = ps.main;
		}
		if (Camera.main.depthTextureMode != DepthTextureMode.Depth)
		{
			Camera.main.depthTextureMode = DepthTextureMode.Depth;
		}
		GetComponent<MeshRenderer>().reflectionProbeUsage = ReflectionProbeUsage.Off;
		if (!IsScreenSpace)
		{
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			sharedMaterial.EnableKeyword("USE_QUAD_DECAL");
			sharedMaterial.SetInt("_ZTest1", 4);
			if (UnityEngine.Application.isPlaying)
			{
				Vector3 localPosition = base.transform.localPosition;
				localPosition.z += 0.1f;
				base.transform.localPosition = localPosition;
				Vector3 localScale = base.transform.localScale;
				localScale.y = 0.001f;
				base.transform.localScale = localScale;
			}
		}
		else
		{
			Material sharedMaterial2 = GetComponent<Renderer>().sharedMaterial;
			sharedMaterial2.DisableKeyword("USE_QUAD_DECAL");
			sharedMaterial2.SetInt("_ZTest1", 5);
		}
		if (UnityEngine.Application.isPlaying && UseRandomRotationAndScale && !UseWorldSpaceRotation)
		{
			base.transform.localRotation = Quaternion.Euler(UnityEngine.Random.Range(0, 360), 90f, 90f);
			float num = UnityEngine.Random.Range(startScale.x - startScale.x * randomScalePercent * 0.01f, startScale.x + startScale.x * randomScalePercent * 0.01f);
			base.transform.localScale = new Vector3(num, IsScreenSpace ? startScale.y : 0.001f, num);
		}
	}

	private void LateUpdate()
	{
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<MeshRenderer>();
		}
		rend.GetPropertyBlock(props);
		props.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
		rend.SetPropertyBlock(props);
		if (ps != null)
		{
			psMain.scalingMode = ParticleSystemScalingMode.Hierarchy;
		}
		if (UseWorldSpaceRotation)
		{
			base.transform.rotation = Quaternion.Euler(worldRotation);
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.matrix = Matrix4x4.TRS(base.transform.TransformPoint(Vector3.zero), base.transform.rotation, base.transform.lossyScale);
		Gizmos.color = new Color(1f, 1f, 1f, 1f);
		Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
	}
}
public class AE_FreezeTransform : MonoBehaviour
{
	public bool FreezePosition = true;

	public bool FreezeRotation = true;

	public float TimeDelay;

	private Vector3 startPos;

	private Vector3 startRotation;

	private Vector3 lastPos;

	private Vector3 lastRotation;

	private float currentTime;

	private void Awake()
	{
		startPos = base.transform.localPosition;
		startRotation = base.transform.localRotation.eulerAngles;
	}

	private void OnEnable()
	{
		base.transform.localPosition = startPos;
		base.transform.localRotation = Quaternion.Euler(startRotation);
		currentTime = Time.time;
	}

	private void LateUpdate()
	{
		if (Mathf.Abs(Time.time - currentTime) > TimeDelay)
		{
			if (FreezePosition)
			{
				base.transform.position = lastPos;
			}
			if (FreezeRotation)
			{
				base.transform.rotation = Quaternion.Euler(lastRotation);
			}
		}
		else
		{
			lastPos = base.transform.position;
			lastRotation = base.transform.rotation.eulerAngles + startRotation;
		}
	}
}
[ExecuteInEditMode]
public class AE_ParticleGravityPoint : MonoBehaviour
{
	public Transform Target;

	public float Force = 1f;

	public float StopDistance;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void LateUpdate()
	{
		if (Target == null)
		{
			return;
		}
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(Target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = Target.position;
		}
		float num2 = Time.deltaTime * Force;
		for (int i = 0; i < num; i++)
		{
			Vector3 value = vector - particles[i].position;
			if (StopDistance > 0.001f && value.magnitude < StopDistance)
			{
				particles[i].velocity = Vector3.zero;
				continue;
			}
			Vector3 vector2 = Vector3.Normalize(value) * num2;
			particles[i].velocity += vector2;
		}
		ps.SetParticles(particles, num);
	}
}
public class AE_PhysicsMotion : MonoBehaviour
{
	public class AE_CollisionInfo : EventArgs
	{
		public ContactPoint ContactPoint;
	}

	public bool UseCollisionDetect = true;

	public float Mass = 1f;

	public float Speed = 10f;

	public float RandomSpeedOffset;

	public float AirDrag = 0.1f;

	public bool UseGravity = true;

	public ForceMode ForceMode = ForceMode.Impulse;

	public float ColliderRadius = 0.05f;

	public bool FreezeRotation;

	public bool UseTargetPositionAfterCollision;

	public GameObject EffectOnCollision;

	public bool CollisionEffectInWorldSpace = true;

	public bool LookAtNormal = true;

	public float CollisionEffectDestroyAfter = 5f;

	public GameObject[] DeactivateObjectsAfterCollision;

	[HideInInspector]
	public float HUE = -1f;

	private Rigidbody rigid;

	private SphereCollider collid;

	private ContactPoint lastContactPoint;

	private Collider lastCollider;

	private Vector3 offsetColliderPoint;

	private bool isCollided;

	private GameObject targetAnchor;

	private bool isInitializedForce;

	private float currentSpeedOffset;

	public event EventHandler<AE_CollisionInfo> CollisionEnter;

	private void OnEnable()
	{
		GameObject[] deactivateObjectsAfterCollision = DeactivateObjectsAfterCollision;
		foreach (GameObject gameObject in deactivateObjectsAfterCollision)
		{
			if (gameObject != null)
			{
				if (gameObject.GetComponent<ParticleSystem>() != null)
				{
					gameObject.SetActive(value: false);
				}
				gameObject.SetActive(value: true);
			}
		}
		currentSpeedOffset = UnityEngine.Random.Range((0f - RandomSpeedOffset) * 10000f, RandomSpeedOffset * 10000f) / 10000f;
		InitializeRigid();
	}

	private void InitializeRigid()
	{
		if (UseCollisionDetect)
		{
			collid = base.gameObject.AddComponent<SphereCollider>();
			collid.radius = ColliderRadius;
		}
		isInitializedForce = false;
	}

	private void InitializeForce()
	{
		rigid = base.gameObject.AddComponent<Rigidbody>();
		rigid.mass = Mass;
		rigid.drag = AirDrag;
		rigid.useGravity = UseGravity;
		if (FreezeRotation)
		{
			rigid.constraints = RigidbodyConstraints.FreezeRotation;
		}
		rigid.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		rigid.interpolation = RigidbodyInterpolation.Interpolate;
		rigid.AddForce(base.transform.forward * (Speed + currentSpeedOffset), ForceMode);
		isInitializedForce = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (isCollided && !UseCollisionDetect)
		{
			return;
		}
		ContactPoint[] contacts = collision.contacts;
		for (int i = 0; i < contacts.Length; i++)
		{
			ContactPoint contactPoint = contacts[i];
			if (!isCollided)
			{
				isCollided = true;
				if (UseTargetPositionAfterCollision)
				{
					if (targetAnchor != null)
					{
						UnityEngine.Object.Destroy(targetAnchor);
					}
					targetAnchor = new GameObject();
					targetAnchor.hideFlags = HideFlags.HideAndDontSave;
					targetAnchor.transform.parent = contactPoint.otherCollider.transform;
					targetAnchor.transform.position = contactPoint.point;
					targetAnchor.transform.rotation = base.transform.rotation;
				}
			}
			this.CollisionEnter?.Invoke(this, new AE_CollisionInfo
			{
				ContactPoint = contactPoint
			});
			if (EffectOnCollision != null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(EffectOnCollision, contactPoint.point, default(Quaternion));
				if (HUE > -0.9f)
				{
					AE_EffectSettingColor aE_EffectSettingColor = gameObject.AddComponent<AE_EffectSettingColor>();
					AE_ColorHelper.HSBColor hsbColor = AE_ColorHelper.ColorToHSV(aE_EffectSettingColor.Color);
					hsbColor.H = HUE;
					aE_EffectSettingColor.Color = AE_ColorHelper.HSVToColor(hsbColor);
				}
				if (LookAtNormal)
				{
					gameObject.transform.LookAt(contactPoint.point + contactPoint.normal);
				}
				else
				{
					gameObject.transform.rotation = base.transform.rotation;
				}
				if (!CollisionEffectInWorldSpace)
				{
					gameObject.transform.parent = contactPoint.otherCollider.transform.parent;
				}
				UnityEngine.Object.Destroy(gameObject, CollisionEffectDestroyAfter);
			}
		}
		GameObject[] deactivateObjectsAfterCollision = DeactivateObjectsAfterCollision;
		foreach (GameObject gameObject2 in deactivateObjectsAfterCollision)
		{
			if (gameObject2 != null)
			{
				ParticleSystem component = gameObject2.GetComponent<ParticleSystem>();
				if (component != null)
				{
					component.Stop();
				}
				else
				{
					gameObject2.SetActive(value: false);
				}
			}
		}
		if (rigid != null)
		{
			UnityEngine.Object.Destroy(rigid);
		}
		if (collid != null)
		{
			UnityEngine.Object.Destroy(collid);
		}
	}

	private void Update()
	{
		if (!isInitializedForce)
		{
			InitializeForce();
		}
		if (UseTargetPositionAfterCollision && isCollided && targetAnchor != null)
		{
			base.transform.position = targetAnchor.transform.position;
			base.transform.rotation = targetAnchor.transform.rotation;
		}
	}

	private void OnDisable()
	{
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = default(Quaternion);
		isCollided = false;
		if (rigid != null)
		{
			UnityEngine.Object.Destroy(rigid);
		}
		if (collid != null)
		{
			UnityEngine.Object.Destroy(collid);
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Transform transform = base.transform;
			Gizmos.color = Color.green;
			Gizmos.DrawWireSphere(transform.position, ColliderRadius);
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(transform.position, transform.position + transform.forward * 100f);
		}
	}
}
public class AE_RelativeTransform : MonoBehaviour
{
	public bool RelativePosition = true;

	public bool RelativeScale;

	private bool isInitialized;

	private void OnEnable()
	{
		isInitialized = false;
	}

	private void Update()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			Vector3 lossyScale = base.transform.lossyScale;
			if (RelativePosition)
			{
				Vector3 localPosition = base.transform.localPosition;
				base.transform.localPosition = new Vector3(localPosition.x / lossyScale.x, localPosition.y / lossyScale.y, localPosition.z / lossyScale.z);
			}
			if (RelativeScale)
			{
				base.transform.localScale = new Vector3(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z);
			}
		}
	}
}
public class AE_Rotator : MonoBehaviour
{
	public Vector3 Rotation = new Vector3(1f, 0f, 0f);

	private Vector3 currentRotation;

	private void Start()
	{
	}

	private void Update()
	{
		currentRotation += Rotation * Time.deltaTime;
		base.transform.rotation = Quaternion.Euler(currentRotation);
	}
}
public class AE_SetMeshToEffect : MonoBehaviour
{
	public enum EffectMeshType
	{
		Bow,
		Arrow
	}

	public EffectMeshType MeshType;

	public GameObject Mesh;

	public bool UseMeshPosition = true;

	private bool isInitialized;

	private List<ParticleSystem> particles = new List<ParticleSystem>();

	private List<MeshFilter> meshes = new List<MeshFilter>();

	private void InitializeEffect()
	{
		isInitialized = true;
		MeshRenderer component = Mesh.GetComponent<MeshRenderer>();
		if (component == null)
		{
			UnityEngine.Debug.Log("KriptoFX/ArcherEffects... Can't find a mesh with 'mesh renderer' for effect. You need set a bow/arrow mesh. Please read the readme");
			return;
		}
		string value = MeshType.ToString();
		float magnitude = Mesh.GetComponent<Renderer>().bounds.size.magnitude;
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			if (particleSystem.name.Contains(value))
			{
				particleSystem.gameObject.SetActive(value: false);
				ParticleSystem.MainModule main = particleSystem.main;
				main.startSizeMultiplier /= magnitude;
				ParticleSystem.ShapeModule shape = particleSystem.shape;
				shape.useMeshColors = false;
				shape.meshShapeType = ParticleSystemMeshShapeType.Triangle;
				shape.shapeType = ParticleSystemShapeType.MeshRenderer;
				shape.meshRenderer = component;
				particleSystem.gameObject.SetActive(value: true);
				particles.Add(particleSystem);
			}
		}
		MeshFilter[] componentsInChildren2 = GetComponentsInChildren<MeshFilter>();
		foreach (MeshFilter meshFilter in componentsInChildren2)
		{
			if (meshFilter.name.Contains(value))
			{
				meshFilter.sharedMesh = Mesh.GetComponent<MeshFilter>().sharedMesh;
				meshes.Add(meshFilter);
			}
		}
		if (!UseMeshPosition)
		{
			UpdateEffectsScaleOnStart();
		}
	}

	private void ResetEffects()
	{
		foreach (ParticleSystem particle in particles)
		{
			Transform parent = particle.transform.parent;
			parent.localPosition = Vector3.zero;
			parent.localRotation = default(Quaternion);
			parent.localScale = Vector3.one;
		}
		foreach (MeshFilter mesh in meshes)
		{
			Transform parent2 = mesh.transform.parent;
			parent2.localPosition = Vector3.zero;
			parent2.localRotation = default(Quaternion);
			parent2.localScale = Vector3.one;
		}
		particles.Clear();
		meshes.Clear();
		isInitialized = false;
	}

	private void UpdateEffects()
	{
		if (!UseMeshPosition)
		{
			return;
		}
		Transform transform = Mesh.transform;
		foreach (ParticleSystem particle in particles)
		{
			Transform parent = particle.transform.parent;
			parent.position = transform.position;
			parent.rotation = transform.rotation;
			parent.localScale = transform.lossyScale;
		}
		foreach (MeshFilter mesh in meshes)
		{
			Transform parent2 = mesh.transform.parent;
			parent2.position = transform.position;
			parent2.rotation = transform.rotation;
			parent2.localScale = transform.lossyScale;
		}
	}

	private void UpdateEffectsScaleOnStart()
	{
		Transform transform = Mesh.transform;
		foreach (ParticleSystem particle in particles)
		{
			particle.transform.parent.localScale = transform.lossyScale;
		}
		foreach (MeshFilter mesh in meshes)
		{
			mesh.transform.parent.localScale = transform.lossyScale;
		}
	}

	private void OnEnable()
	{
		ResetEffects();
	}

	private void LateUpdate()
	{
		if (!(Mesh == null))
		{
			if (!isInitialized)
			{
				InitializeEffect();
			}
			UpdateEffects();
		}
	}
}
public class AE_SimpleDecal : MonoBehaviour
{
	public float Offset = 0.05f;

	private Transform t;

	private bool canUpdate;

	public float Distance = 5f;

	private MeshRenderer meshRend;

	private RaycastHit hit;

	private float timer;

	private void Awake()
	{
		t = base.transform;
	}

	private void OnEnable()
	{
		canUpdate = true;
		meshRend = GetComponent<MeshRenderer>();
		if (meshRend != null)
		{
			meshRend.enabled = true;
		}
	}

	private void Update()
	{
		if (!canUpdate || !Physics.Raycast(t.parent.position - t.forward / 2f, t.forward, out hit, Distance))
		{
			return;
		}
		if (hit.transform.root.GetComponentInChildren<SkinnedMeshRenderer>() != null)
		{
			if (meshRend != null)
			{
				meshRend.enabled = false;
			}
		}
		else
		{
			base.transform.position = hit.point - base.transform.forward * Offset;
			base.transform.rotation = Quaternion.LookRotation(-hit.normal);
		}
	}

	private void OnDisable()
	{
		canUpdate = false;
	}
}
public class AE_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private float currentTime;

	private bool isEnabled;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		isEnabled = false;
		currentTime = Time.time;
	}

	private void Update()
	{
		if (Time.time - currentTime >= Delay && !isEnabled)
		{
			isEnabled = true;
			ActivatedGameObject.SetActive(value: true);
		}
	}
}
public class AE_TextureSheetAnimation : MonoBehaviour
{
	public enum AE_TextureShaderProperties
	{
		_MainTex,
		_DistortTex,
		_Mask,
		_Cutout,
		_CutoutTex,
		_Bump,
		_BumpTex,
		_EmissionTex
	}

	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 40;

	public float StartDelay;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsInterpolateFrames;

	public bool IsParticleSystemTrail;

	public AE_TextureShaderProperties[] TextureNames = new AE_TextureShaderProperties[1];

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private bool startDelayIsBroken;

	private ParticleSystemRenderer pr;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void OnDisable()
	{
		if (instanceMaterial != null)
		{
			instanceMaterial.DisableKeyword("USE_SCRIPT_FRAMEBLENDING");
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void Update()
	{
		if (startDelayIsBroken)
		{
			ManualUpdate();
		}
	}

	private void ManualUpdate()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void StartDelayFunc()
	{
		startDelayIsBroken = true;
		animationStartTime = Time.time;
	}

	private void InitDefaultVariables()
	{
		InitializeMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		Vector3 zero = Vector3.zero;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = Time.time;
		if (StartDelay > 1E-05f)
		{
			startDelayIsBroken = false;
			Invoke("StartDelayFunc", StartDelay);
		}
		else
		{
			startDelayIsBroken = true;
		}
		if (instanceMaterial != null)
		{
			AE_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				AE_TextureShaderProperties aE_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(aE_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(aE_TextureShaderProperties.ToString(), zero);
			}
			instanceMaterial.EnableKeyword("USE_SCRIPT_FRAMEBLENDING");
		}
	}

	private void InitializeMaterial()
	{
		if (IsParticleSystemTrail)
		{
			pr = GetComponent<ParticleSystem>().GetComponent<ParticleSystemRenderer>();
			currentRenderer = pr;
			instanceMaterial = pr.trailMaterial;
			if (!instanceMaterial.name.EndsWith("(Instance)"))
			{
				instanceMaterial = new Material(instanceMaterial)
				{
					name = instanceMaterial.name + " (Instance)"
				};
			}
			pr.trailMaterial = instanceMaterial;
			return;
		}
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			projector = GetComponent<Projector>();
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void UpdateMaterial()
	{
		if (currentRenderer == null)
		{
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else if (!IsParticleSystemTrail)
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)((Time.time - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			AE_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				AE_TextureShaderProperties aE_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(aE_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(aE_TextureShaderProperties.ToString(), value);
			}
		}
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += Time.deltaTime;
		int num = previousIndex + 1;
		if (IsReverse)
		{
			num = totalFrames - num + 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_MainTex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
[ExecuteInEditMode]
public class AE_UvScroll : MonoBehaviour
{
	public enum AE_UVTextureShaderProperties
	{
		_MainTex,
		_DistortTex,
		_Mask,
		_Cutout,
		_CutoutTex,
		_Bump,
		_BumpTex,
		_EmissionTex
	}

	public Vector2 uvAnimationRate = new Vector2(1f, 0f);

	public AE_UVTextureShaderProperties[] TextureNames = new AE_UVTextureShaderProperties[1];

	private Vector2 uvOffset = Vector2.zero;

	private Material mat;

	private void Start()
	{
		if (UnityEngine.Application.isPlaying)
		{
			mat = GetComponent<Renderer>().material;
		}
		else
		{
			mat = GetComponent<Renderer>().sharedMaterial;
		}
	}

	private void OnWillRenderObject()
	{
		uvOffset += uvAnimationRate * Time.deltaTime;
		AE_UVTextureShaderProperties[] textureNames = TextureNames;
		for (int i = 0; i < textureNames.Length; i++)
		{
			AE_UVTextureShaderProperties aE_UVTextureShaderProperties = textureNames[i];
			mat.SetTextureOffset(aE_UVTextureShaderProperties.ToString(), uvOffset);
		}
	}
}
public class AE_WorldSpaceRotationAtStart : MonoBehaviour
{
	private Vector3 startRotation;

	private void Awake()
	{
		startRotation = base.transform.localRotation.eulerAngles;
	}

	private void OnEnable()
	{
		base.transform.rotation = Quaternion.Euler(startRotation);
	}
}
public class AE_AnimatorSpeed : MonoBehaviour
{
	public AnimationCurve SpeedCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public bool IsLoop;

	private Animator anim;

	[HideInInspector]
	public bool canUpdate;

	private AnimatorStateInfo info;

	private void OnEnable()
	{
		anim = GetComponent<Animator>();
		info = anim.GetCurrentAnimatorStateInfo(0);
		canUpdate = true;
	}

	private void Update()
	{
		info = anim.GetCurrentAnimatorStateInfo(0);
		if (canUpdate)
		{
			float speed = SpeedCurve.Evaluate(Mathf.Clamp01(info.normalizedTime));
			anim.speed = speed;
		}
	}
}
public class AE_AudioVolumeCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.volume = AudioCurve.Evaluate(0f);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class AE_DistanceOffset : MonoBehaviour
{
	public AnimationCurve PositionX = AnimationCurve.EaseInOut(0f, 0.5f, 1f, 0.5f);

	public Vector2 DistanceScaleX = new Vector2(1f, 1f);

	public AnimationCurve PositionY = AnimationCurve.EaseInOut(0f, 0.5f, 1f, 0.5f);

	public Vector2 DistanceScaleY = new Vector2(1f, 1f);

	public AnimationCurve PositionZ = AnimationCurve.EaseInOut(0f, 0.5f, 1f, 0.5f);

	public Vector2 DistanceScaleZ = new Vector2(1f, 1f);

	public Transform Object;

	private float currentDistance;

	private Vector3 prevPos;

	private void OnEnable()
	{
	}

	private void Update()
	{
		currentDistance += Mathf.Abs((base.transform.position - prevPos).magnitude);
		prevPos = base.transform.position;
		float x = (PositionX.Evaluate(currentDistance % 1f) * 2f - 1f) * DistanceScaleX.y;
		float y = (PositionY.Evaluate(currentDistance % 1f) * 2f - 1f) * DistanceScaleY.y;
		float z = (PositionZ.Evaluate(currentDistance % 1f) * 2f - 1f) * DistanceScaleZ.y;
		Object.transform.localPosition = new Vector3(x, y, z);
	}
}
public class AE_FollowMotion : MonoBehaviour
{
	public AnimationCurve SlowCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float FollowTime = 1f;

	public Transform Target;

	public float currentVel;

	private bool canUpdate;

	private float startTime;

	private Vector3 startWorldPos;

	private void Awake()
	{
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		base.transform.localPosition = Vector3.zero;
		startWorldPos = base.transform.position;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float t = SlowCurve.Evaluate(num / FollowTime);
			base.transform.position = Vector3.Lerp(startWorldPos, Target.position, t);
		}
		if (num >= FollowTime)
		{
			canUpdate = false;
		}
	}
}
public class AE_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public Gradient LightColor = new Gradient();

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Color startColor;

	private Light lightSource;

	public void SetStartColor(Color color)
	{
		startColor = color;
	}

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		startColor = lightSource.color;
		lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
		lightSource.color = startColor * LightColor.Evaluate(0f);
		startTime = Time.time;
		canUpdate = true;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (lightSource != null)
		{
			lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
			lightSource.color = startColor * LightColor.Evaluate(0f);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
			lightSource.color = startColor * LightColor.Evaluate(num / GraphTimeMultiplier);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class AE_ProjectorSizeCurves : MonoBehaviour
{
	public AnimationCurve ProjectorSize = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Projector projector;

	private void Awake()
	{
		projector = GetComponent<Projector>();
		projector.orthographicSize = ProjectorSize.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float orthographicSize = ProjectorSize.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			projector.orthographicSize = orthographicSize;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class AE_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class AE_ShaderColorGradient : MonoBehaviour
{
	public AE_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	public int MaterialNumber;

	public bool UseSharedMaterial;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private Material mat;

	private int propertyID;

	private float startTime;

	private Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private MaterialPropertyBlock props;

	private Renderer rend;

	public void SetStartColor(Color color)
	{
		startColor = color;
	}

	private void Awake()
	{
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<Renderer>();
		}
		shaderProperty = ShaderColorProperty.ToString();
		propertyID = Shader.PropertyToID(shaderProperty);
		startColor = rend.sharedMaterial.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		rend.GetPropertyBlock(props);
		startColor = rend.sharedMaterial.GetColor(propertyID);
		props.SetColor(propertyID, startColor * Color.Evaluate(0f));
		rend.SetPropertyBlock(props);
	}

	private void Update()
	{
		rend.GetPropertyBlock(props);
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			if (HUE > -0.9f)
			{
				color = AE_ColorHelper.ConvertRGBColorByHUE(color, HUE);
				startColor = AE_ColorHelper.ConvertRGBColorByHUE(startColor, HUE);
			}
			props.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
		rend.SetPropertyBlock(props);
	}
}
public class AE_ShaderFloatCurve : MonoBehaviour
{
	public AE_ShaderProperties ShaderFloatProperty = AE_ShaderProperties._Cutoff;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public int MaterialNumber;

	public bool UseSharedMaterial;

	public Renderer[] UseSharedRenderers;

	private bool canUpdate;

	private float startTime;

	private Material mat;

	private float startFloat;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private MaterialPropertyBlock props;

	private Renderer rend;

	private void Awake()
	{
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<Renderer>();
		}
		shaderProperty = ShaderFloatProperty.ToString();
		propertyID = Shader.PropertyToID(shaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		rend.GetPropertyBlock(props);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		props.SetFloat(propertyID, value);
		rend.SetPropertyBlock(props);
	}

	private void Update()
	{
		rend.GetPropertyBlock(props);
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			props.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
		rend.SetPropertyBlock(props);
	}
}
public enum AE_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt,
	_AlphaPow,
	_Distortion,
	_MainColor,
	_FresnelColor
}
public class AE_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
		windZone.windMain = 0f - WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = 0f - num2;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class AE_EffectQuality : MonoBehaviour
{
	[Range(1f, 15000f)]
	public int MaxParticles = 15000;

	[Range(2000f, 20000f)]
	public int MaxParticlesForAllEffects = 20000;

	private Dictionary<ParticleSystem, int> starMaxParticles = new Dictionary<ParticleSystem, int>();

	private AE_SharedParticlesQualitySetting sharedSettings;

	private int currentMaxParticles;

	private void Awake()
	{
		sharedSettings = AE_SharedParticlesQualitySetting.getInstance();
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			starMaxParticles.Add(particleSystem, particleSystem.main.maxParticles);
			currentMaxParticles += particleSystem.main.maxParticles;
		}
	}

	private void OnEnable()
	{
		int num = 0;
		if (currentMaxParticles > MaxParticles)
		{
			foreach (KeyValuePair<ParticleSystem, int> starMaxParticle in starMaxParticles)
			{
				ParticleSystem.MainModule main = starMaxParticle.Key.main;
				float num2 = (float)starMaxParticle.Value * 1f / (float)MaxParticlesForAllEffects * 1f * (float)MaxParticles;
				if (starMaxParticle.Value > MaxParticles)
				{
					num2 *= Mathf.Clamp01(num2 * 1f / (float)currentMaxParticles * 1f);
				}
				main.maxParticles = (int)num2;
				num += main.maxParticles;
			}
		}
		else
		{
			num = currentMaxParticles;
		}
		sharedSettings.OptimizeParticlesCount(MaxParticlesForAllEffects, num);
		foreach (KeyValuePair<ParticleSystem, int> starMaxParticle2 in starMaxParticles)
		{
			sharedSettings.CurentParticleSystems.Add(starMaxParticle2.Key, starMaxParticle2.Value);
		}
	}

	private void OnDisable()
	{
		foreach (KeyValuePair<ParticleSystem, int> starMaxParticle in starMaxParticles)
		{
			sharedSettings.CurentParticleSystems.Remove(starMaxParticle.Key);
		}
		sharedSettings.OptimizeParticlesCount(MaxParticlesForAllEffects, 0);
	}
}
public class AE_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		UpdateColor();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		float h = AE_ColorHelper.ColorToHSV(Color).H;
		AE_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		AE_PhysicsMotion componentInChildren = GetComponentInChildren<AE_PhysicsMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		previousColor = Color;
	}
}
public class AE_EffectSettingProjectile : MonoBehaviour
{
	public float Mass = 1f;

	public float Speed = 10f;

	public float AirDrag = 0.1f;

	public bool UseGravity = true;

	private void OnEnable()
	{
		AE_PhysicsMotion componentInChildren = GetComponentInChildren<AE_PhysicsMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.Mass = Mass;
			componentInChildren.Speed = Speed;
			componentInChildren.AirDrag = AirDrag;
			componentInChildren.UseGravity = UseGravity;
		}
	}
}
public class AE_SharedParticlesQualitySetting
{
	public Dictionary<ParticleSystem, int> CurentParticleSystems = new Dictionary<ParticleSystem, int>();

	private static AE_SharedParticlesQualitySetting instance;

	public void OptimizeParticlesCount(int maxParticlesBudget, int currentParticles)
	{
		if (CurentParticleSystems.Count == 0)
		{
			return;
		}
		int num = maxParticlesBudget - currentParticles;
		int maxAllParticles = GetMaxAllParticles();
		foreach (KeyValuePair<ParticleSystem, int> curentParticleSystem in CurentParticleSystems)
		{
			ParticleSystem.MainModule main = curentParticleSystem.Key.main;
			float num2 = ((maxAllParticles >= num) ? ((float)curentParticleSystem.Value * 1f / (float)maxAllParticles * 1f * (float)num) : ((float)curentParticleSystem.Value));
			main.maxParticles = (int)num2;
		}
	}

	private int GetMaxAllParticles()
	{
		int num = 0;
		foreach (KeyValuePair<ParticleSystem, int> curentParticleSystem in CurentParticleSystems)
		{
			num += curentParticleSystem.Value;
		}
		return num;
	}

	public static AE_SharedParticlesQualitySetting getInstance()
	{
		if (instance == null)
		{
			instance = new AE_SharedParticlesQualitySetting();
		}
		return instance;
	}
}
[ExecuteInEditMode]
public class AE_ParticleCollisionDecal : MonoBehaviour
{
	public ParticleSystem DecalParticles;

	public float MaxGroundAngleDeviation = 30f;

	public Vector3 RandomizeRotation = new Vector3(0f, 0f, 360f);

	public bool LookAtForward;

	public bool InstantiateWhenZeroSpeed;

	public float MinDistanceBetweenDecals = 0.1f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem.Particle[] particles;

	private ParticleSystem initiatorPS;

	private List<GameObject> collidedGameObjects = new List<GameObject>();

	private bool canUpdateCollisionDetect;

	private float collisionDetectTime = 0.2f;

	private float currentCollisionTime;

	private Vector3 prevPos;

	private Vector3 currentDirection;

	private Vector3 prevForward = Vector3.forward;

	private void OnEnable()
	{
		collisionEvents.Clear();
		collidedGameObjects.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[DecalParticles.main.maxParticles];
		if (InstantiateWhenZeroSpeed)
		{
			canUpdateCollisionDetect = true;
		}
		prevPos = base.transform.position - base.transform.forward;
	}

	private void OnDisable()
	{
		if (InstantiateWhenZeroSpeed)
		{
			canUpdateCollisionDetect = false;
		}
	}

	private void CollisionDetect()
	{
		int aliveParticles = 0;
		if (InstantiateWhenZeroSpeed)
		{
			aliveParticles = DecalParticles.GetParticles(particles);
		}
		foreach (GameObject collidedGameObject in collidedGameObjects)
		{
			OnParticleCollisionManual(collidedGameObject, aliveParticles);
		}
	}

	private void Update()
	{
		if (LookAtForward)
		{
			Vector3 vector = base.transform.position - prevPos;
			if (vector.magnitude > 0.01f)
			{
				currentDirection = vector;
			}
			else
			{
				currentDirection = base.transform.forward;
			}
			prevPos = base.transform.position;
			currentDirection.y = 0f;
		}
		if (InstantiateWhenZeroSpeed && canUpdateCollisionDetect)
		{
			currentCollisionTime += Time.deltaTime;
			if (currentCollisionTime > collisionDetectTime)
			{
				currentCollisionTime = 0f;
				CollisionDetect();
			}
		}
	}

	private void OnParticleCollisionManual(GameObject other, int aliveParticles = -1)
	{
		collisionEvents.Clear();
		if (other == null)
		{
			return;
		}
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			if (Vector3.Angle(collisionEvents[i].normal, Vector3.up) > MaxGroundAngleDeviation)
			{
				continue;
			}
			if (InstantiateWhenZeroSpeed)
			{
				if (collisionEvents[i].velocity.magnitude > initiatorPS.main.gravityModifier.constantMax)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < aliveParticles; j++)
				{
					if (Vector3.Distance(collisionEvents[i].intersection, particles[j].position) < MinDistanceBetweenDecals)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
			emitParams.position = collisionEvents[i].intersection;
			Vector3 eulerAngles;
			if (LookAtForward)
			{
				if (currentDirection.magnitude < 0.01f)
				{
					currentDirection = prevForward;
				}
				else
				{
					prevForward = currentDirection;
				}
				eulerAngles = Quaternion.LookRotation(currentDirection.normalized).eulerAngles;
			}
			else
			{
				eulerAngles = Quaternion.LookRotation(-collisionEvents[i].normal).eulerAngles;
			}
			if (RandomizeRotation.x > 0.01f)
			{
				eulerAngles.x += UnityEngine.Random.Range(0f, RandomizeRotation.x * 2f) - RandomizeRotation.x;
			}
			if (RandomizeRotation.y > 0.01f)
			{
				eulerAngles.y += UnityEngine.Random.Range(0f, RandomizeRotation.y * 2f) - RandomizeRotation.y;
			}
			if (RandomizeRotation.z > 0.01f)
			{
				eulerAngles.z += UnityEngine.Random.Range(0f, RandomizeRotation.z * 2f) - RandomizeRotation.z;
			}
			emitParams.rotation3D = eulerAngles;
			DecalParticles.Emit(emitParams, 1);
			DecalParticles.Play();
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (InstantiateWhenZeroSpeed)
		{
			if (!collidedGameObjects.Contains(other))
			{
				collidedGameObjects.Add(other);
			}
		}
		else
		{
			OnParticleCollisionManual(other);
		}
	}
}
public class AE_ParticlesSizeOverTime : MonoBehaviour
{
	public AnimationCurve SizeCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float LifeTime = 1f;

	public Vector3 SizeMul = Vector3.one;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private ParticleSystem.MainModule mainPS;

	private void Awake()
	{
		ParticleSystem component = GetComponent<ParticleSystem>();
		mainPS = component.main;
	}

	private void OnEnable()
	{
		startTime = Time.time + mainPS.startDelay.constant;
		canUpdate = true;
		float num = SizeCurve.Evaluate(0f);
		if (mainPS.startSize3D)
		{
			mainPS.startSizeXMultiplier = num * SizeMul.x;
			mainPS.startSizeYMultiplier = num * SizeMul.y;
			mainPS.startSizeZMultiplier = num * SizeMul.z;
		}
		else
		{
			mainPS.startSizeMultiplier = num * SizeMul.x;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = SizeCurve.Evaluate(num / LifeTime);
			if (mainPS.startSize3D)
			{
				mainPS.startSizeXMultiplier = num2 * SizeMul.x;
				mainPS.startSizeYMultiplier = num2 * SizeMul.y;
				mainPS.startSizeZMultiplier = num2 * SizeMul.z;
			}
			else
			{
				mainPS.startSizeMultiplier = num2 * SizeMul.x;
			}
		}
		if (num >= LifeTime)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class AE_ParticlesWorldLookAt : MonoBehaviour
{
	private ParticleSystem.MainModule main;

	private Vector3 startRotation;

	private Vector3 prevPos;

	private const float rad = 57.29578f;

	public Vector3 test;

	private void Start()
	{
		prevPos = base.transform.position;
		main = GetComponent<ParticleSystem>().main;
		main.startRotation3D = true;
		startRotation.x = main.startRotationX.constant * 57.29578f;
		startRotation.y = main.startRotationY.constant * 57.29578f;
		startRotation.z = main.startRotationZ.constant * 57.29578f;
	}

	private void Update()
	{
		Vector3 forward = base.transform.position - prevPos;
		if (!(forward.magnitude < 0.0001f))
		{
			prevPos = base.transform.position;
			Vector3 eulerAngles = Quaternion.LookRotation(forward).eulerAngles;
			main.startRotationX = (eulerAngles.x + startRotation.x * 0f) / 57.29578f;
			main.startRotationY = (eulerAngles.y + startRotation.y * 0f) / 57.29578f;
			main.startRotationZ = (eulerAngles.z + startRotation.z * 0f) / 57.29578f;
		}
	}
}
public class RFX1_LegacyQueue : MonoBehaviour
{
	public int Queue = 3001;

	private void Awake()
	{
		GetComponent<Renderer>().material.renderQueue = Queue;
	}

	private void Update()
	{
	}
}
public class AE_LegacyRenderDistortion : MonoBehaviour
{
	public bool IsActive = true;

	private CommandBuffer buf;

	private Camera cam;

	private bool bufferIsAdded;

	private void Awake()
	{
		cam = GetComponent<Camera>();
		CreateBuffer();
	}

	private void CreateBuffer()
	{
		_ = Camera.main;
		buf = new CommandBuffer();
		buf.name = "_GrabOpaqueColor";
		int num = Shader.PropertyToID("_ScreenCopyOpaqueColor");
		int num2 = -1;
		RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB565) ? RenderTextureFormat.RGB565 : RenderTextureFormat.Default);
		buf.GetTemporaryRT(num, num2, num2, 0, FilterMode.Bilinear, format);
		buf.Blit(BuiltinRenderTextureType.CurrentActive, num);
		buf.SetGlobalTexture("_GrabTexture", num);
		buf.SetGlobalTexture("_GrabTextureMobile", num);
	}

	private void OnEnable()
	{
		AddBuffer();
	}

	private void OnDisable()
	{
		RemoveBuffer();
	}

	private void AddBuffer()
	{
		cam.AddCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = true;
	}

	private void RemoveBuffer()
	{
		cam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = false;
	}

	private void Update()
	{
		if (IsActive)
		{
			if (!bufferIsAdded)
			{
				AddBuffer();
			}
		}
		else if (bufferIsAdded)
		{
			RemoveBuffer();
		}
	}

	private bool IsSupportedHdr()
	{
		return Camera.main.allowHDR;
	}
}
public class AE_PerPlatformSettings : MonoBehaviour
{
	public bool DisableOnMobiles;

	public bool RenderMobileDistortion;

	[Range(0.1f, 1f)]
	public float ParticleBudgetForMobiles = 1f;

	private bool isMobile;

	private void Awake()
	{
		isMobile = IsMobilePlatform();
		if (isMobile)
		{
			if (DisableOnMobiles)
			{
				base.gameObject.SetActive(value: false);
			}
			else if (ParticleBudgetForMobiles < 0.99f)
			{
				ChangeParticlesBudget(ParticleBudgetForMobiles);
			}
		}
	}

	private void OnEnable()
	{
		Camera main = Camera.main;
		LWRP_Rendering_Check(main);
		Legacy_Rendering_Check(main);
	}

	private void Update()
	{
		Camera main = Camera.main;
		LWRP_Rendering_Check(main);
		Legacy_Rendering_Check(main);
	}

	private void LWRP_Rendering_Check(Camera cam)
	{
	}

	private void Legacy_Rendering_Check(Camera cam)
	{
		if (!(cam == null) && RenderMobileDistortion && !DisableOnMobiles && isMobile)
		{
			AE_LegacyRenderDistortion aE_LegacyRenderDistortion = cam.GetComponent<AE_LegacyRenderDistortion>();
			if (aE_LegacyRenderDistortion == null)
			{
				aE_LegacyRenderDistortion = cam.gameObject.AddComponent<AE_LegacyRenderDistortion>();
			}
			aE_LegacyRenderDistortion.IsActive = true;
		}
	}

	private void OnDisable()
	{
		Camera main = Camera.main;
		if (!(main == null) && RenderMobileDistortion && !DisableOnMobiles && isMobile)
		{
			AE_LegacyRenderDistortion component = main.GetComponent<AE_LegacyRenderDistortion>();
			if (component != null)
			{
				component.IsActive = false;
			}
		}
	}

	private bool IsMobilePlatform()
	{
		bool result = false;
		if (UnityEngine.Application.isMobilePlatform)
		{
			result = true;
		}
		return result;
	}

	private void ChangeParticlesBudget(float particlesMul)
	{
		ParticleSystem component = GetComponent<ParticleSystem>();
		if (component == null)
		{
			return;
		}
		ParticleSystem.MainModule main = component.main;
		main.maxParticles = Mathf.Max(1, (int)((float)main.maxParticles * particlesMul));
		ParticleSystem.EmissionModule emission = component.emission;
		if (!emission.enabled)
		{
			return;
		}
		ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
		if (rateOverTime.constantMin > 1f)
		{
			rateOverTime.constantMin *= particlesMul;
		}
		if (rateOverTime.constantMax > 1f)
		{
			rateOverTime.constantMax *= particlesMul;
		}
		emission.rateOverTime = rateOverTime;
		ParticleSystem.MinMaxCurve rateOverDistance = emission.rateOverDistance;
		if (rateOverDistance.constantMin > 1f)
		{
			if (rateOverDistance.constantMin > 1f)
			{
				rateOverDistance.constantMin *= particlesMul;
			}
			if (rateOverDistance.constantMax > 1f)
			{
				rateOverDistance.constantMax *= particlesMul;
			}
			emission.rateOverDistance = rateOverDistance;
		}
		ParticleSystem.Burst[] array = new ParticleSystem.Burst[emission.burstCount];
		emission.GetBursts(array);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].minCount > 1)
			{
				array[i].minCount = (short)((float)array[i].minCount * particlesMul);
			}
			if (array[i].maxCount > 1)
			{
				array[i].maxCount = (short)((float)array[i].maxCount * particlesMul);
			}
		}
		emission.SetBursts(array);
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/Explosion_Bloom")]
[ImageEffectAllowedInSceneView]
public class Explosion_Bloom : MonoBehaviour
{
	[Serializable]
	public struct Settings
	{
		[SerializeField]
		[UnityEngine.Tooltip("Filters out pixels under this level of brightness.")]
		public float threshold;

		[SerializeField]
		[Range(0f, 1f)]
		[UnityEngine.Tooltip("Makes transition between under/over-threshold gradual.")]
		public float softKnee;

		[SerializeField]
		[Range(1f, 7f)]
		[UnityEngine.Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
		public float radius;

		[SerializeField]
		[UnityEngine.Tooltip("Blend factor of the result image.")]
		public float intensity;

		[SerializeField]
		[UnityEngine.Tooltip("Controls filter quality and buffer resolution.")]
		public bool highQuality;

		[SerializeField]
		[UnityEngine.Tooltip("Reduces flashing noise with an additional filter.")]
		public bool antiFlicker;

		public float thresholdGamma
		{
			get
			{
				return Mathf.Max(0f, threshold);
			}
			set
			{
				threshold = value;
			}
		}

		public float thresholdLinear
		{
			get
			{
				return Mathf.GammaToLinearSpace(thresholdGamma);
			}
			set
			{
				threshold = Mathf.LinearToGammaSpace(value);
			}
		}

		public static Settings defaultSettings
		{
			get
			{
				Settings result = default(Settings);
				result.threshold = 2f;
				result.softKnee = 0f;
				result.radius = 7f;
				result.intensity = 0.7f;
				result.highQuality = true;
				result.antiFlicker = true;
				return result;
			}
		}
	}

	[SerializeField]
	public Settings settings = Settings.defaultSettings;

	[SerializeField]
	[HideInInspector]
	private Shader m_Shader;

	private Material m_Material;

	private const int kMaxIterations = 16;

	private RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	private int m_Threshold;

	private int m_Curve;

	private int m_PrefilterOffs;

	private int m_SampleScale;

	private int m_Intensity;

	private int m_BaseTex;

	public Shader shader
	{
		get
		{
			if (m_Shader == null)
			{
				m_Shader = Shader.Find("Hidden/KriptoFX/PostEffects/Explosion_Bloom");
			}
			return m_Shader;
		}
	}

	public Material material
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = CheckShaderAndCreateMaterial(shader);
			}
			return m_Material;
		}
	}

	public static bool supportsDX11
	{
		get
		{
			if (SystemInfo.graphicsShaderLevel >= 50)
			{
				return SystemInfo.supportsComputeShaders;
			}
			return false;
		}
	}

	public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
	{
		if (s == null || !s.isSupported)
		{
			UnityEngine.Debug.LogWarningFormat("Missing shader for image effect {0}", effect);
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
		{
			UnityEngine.Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", effect);
			return false;
		}
		if (needHdr && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
		{
			UnityEngine.Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", effect);
			return false;
		}
		return true;
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (s == null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	private void Awake()
	{
		m_Threshold = Shader.PropertyToID("_Threshold");
		m_Curve = Shader.PropertyToID("_Curve");
		m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
		m_SampleScale = Shader.PropertyToID("_SampleScale");
		m_Intensity = Shader.PropertyToID("_Intensity");
		m_BaseTex = Shader.PropertyToID("_BaseTex");
	}

	private void OnEnable()
	{
		if (!IsSupported(shader, needDepth: true, needHdr: false, this))
		{
			base.enabled = false;
		}
	}

	private void OnDisable()
	{
		if (m_Material != null)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
		m_Material = null;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
		int num = source.width;
		int num2 = source.height;
		if (!settings.highQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
		float num3 = Mathf.Log(num2, 2f) + settings.radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float thresholdLinear = settings.thresholdLinear;
		material.SetFloat(m_Threshold, thresholdLinear);
		float num6 = thresholdLinear * settings.softKnee + 1E-05f;
		Vector3 vector = new Vector3(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
		material.SetVector(m_Curve, vector);
		bool flag = !settings.highQuality && settings.antiFlicker;
		material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
		material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
		material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
		Graphics.Blit(source, temporary, material, settings.antiFlicker ? 1 : 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num7 = num5 - 2; num7 >= 0; num7--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num7];
			material.SetTexture(m_BaseTex, renderTexture2);
			m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
			renderTexture = m_blurBuffer2[num7];
		}
		int num8 = 7;
		num8 += (settings.highQuality ? 1 : 0);
		material.SetTexture(m_BaseTex, source);
		Graphics.Blit(renderTexture, destination, material, num8);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}
}
public class ExplosionDemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	public float reactivateTime = 4f;

	public Light Sun;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float sunIntensity;

	private float dpiScale;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(0.15f, 0.15f, 0.15f);
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber], base.transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
		sunIntensity = Sun.intensity;
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT"))
		{
			ChangeCurrent(1);
		}
		sunIntensity = GUI.HorizontalSlider(new Rect(10f * dpiScale, 70f * dpiScale, 285f * dpiScale, 15f * dpiScale), sunIntensity, 0f, 0.6f);
		Sun.intensity = sunIntensity;
		GUI.Label(new Rect(300f * dpiScale, 70f * dpiScale, 30f * dpiScale, 30f * dpiScale), "SUN INTENSITY", guiStyleHeader);
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + Prefabs[currentNomber].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber], base.transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
	}
}
public class ExplosionDemoReactivator : MonoBehaviour
{
	public float TimeDelayToReactivate = 3f;

	private void Start()
	{
		InvokeRepeating("Reactivate", 0f, TimeDelayToReactivate);
	}

	private void Reactivate()
	{
		Transform[] componentsInChildren = GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			obj.gameObject.SetActive(value: false);
			obj.gameObject.SetActive(value: true);
		}
	}
}
public class ExplosionPlatformActivator : MonoBehaviour
{
	public GameObject Effect;

	public float TimeDelay;

	public float DefaultRepeatTime = 5f;

	public float NearRepeatTime = 3f;

	private float currentTime;

	private float currentRepeatTime;

	private bool canUpdate;

	private void Start()
	{
		currentRepeatTime = DefaultRepeatTime;
		Invoke("Init", TimeDelay);
	}

	private void Init()
	{
		canUpdate = true;
		Effect.SetActive(value: true);
	}

	private void Update()
	{
		if (canUpdate && !(Effect == null))
		{
			currentTime += Time.deltaTime;
			if (currentTime > currentRepeatTime)
			{
				currentTime = 0f;
				Effect.SetActive(value: false);
				Effect.SetActive(value: true);
			}
		}
	}

	private void OnTriggerEnter(Collider coll)
	{
		currentRepeatTime = NearRepeatTime;
	}

	private void OnTriggerExit(Collider other)
	{
		currentRepeatTime = DefaultRepeatTime;
	}
}
public class ExplosionsFPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}
public class ExplosionsBillboard : MonoBehaviour
{
	public Camera Camera;

	public bool Active = true;

	public bool AutoInitCamera = true;

	private GameObject myContainer;

	private Transform t;

	private Transform camT;

	private Transform contT;

	private void Awake()
	{
		if (AutoInitCamera)
		{
			Camera = Camera.main;
			Active = true;
		}
		t = base.transform;
		Vector3 localScale = t.parent.transform.localScale;
		localScale.z = localScale.x;
		t.parent.transform.localScale = localScale;
		camT = Camera.transform;
		Transform parent = t.parent;
		myContainer = new GameObject
		{
			name = "Billboard_" + t.gameObject.name
		};
		contT = myContainer.transform;
		contT.position = t.position;
		t.parent = myContainer.transform;
		contT.parent = parent;
	}

	private void Update()
	{
		if (Active)
		{
			contT.LookAt(contT.position + camT.rotation * Vector3.back, camT.rotation * Vector3.up);
		}
	}
}
public class ExplosionsDeactivateRendererByTime : MonoBehaviour
{
	public float TimeDelay = 1f;

	private Renderer rend;

	private void Awake()
	{
		rend = GetComponent<Renderer>();
	}

	private void DeactivateRenderer()
	{
		rend.enabled = false;
	}

	private void OnEnable()
	{
		rend.enabled = true;
		Invoke("DeactivateRenderer", TimeDelay);
	}
}
public class ExplosionsLightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}
[ExecuteInEditMode]
public class ExplosionsParticleSystemScaler : MonoBehaviour
{
	public float particlesScale = 1f;

	private float oldScale;

	private void Start()
	{
		oldScale = particlesScale;
	}

	private void Update()
	{
	}
}
public class ExplosionsScaleCurves : MonoBehaviour
{
	public AnimationCurve ScaleCurveX = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveY = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveZ = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public Vector3 GraphTimeMultiplier = Vector3.one;

	public Vector3 GraphScaleMultiplier = Vector3.one;

	private float startTime;

	private Transform t;

	private float evalX;

	private float evalY;

	private float evalZ;

	private void Awake()
	{
		t = base.transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		evalX = 0f;
		evalY = 0f;
		evalZ = 0f;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (num <= GraphTimeMultiplier.x)
		{
			evalX = ScaleCurveX.Evaluate(num / GraphTimeMultiplier.x) * GraphScaleMultiplier.x;
		}
		if (num <= GraphTimeMultiplier.y)
		{
			evalY = ScaleCurveY.Evaluate(num / GraphTimeMultiplier.y) * GraphScaleMultiplier.y;
		}
		if (num <= GraphTimeMultiplier.z)
		{
			evalZ = ScaleCurveZ.Evaluate(num / GraphTimeMultiplier.z) * GraphScaleMultiplier.z;
		}
		t.localScale = new Vector3(evalX, evalY, evalZ);
	}
}
public class ExplosionsShaderColorGradient : MonoBehaviour
{
	public string ShaderProperty = "_TintColor";

	public int MaterialID;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private Color oldColor;

	private void Start()
	{
		Material[] materials = GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			UnityEngine.Debug.Log("ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			UnityEngine.Debug.Log("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property");
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
		oldColor = matInstance.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			matInstance.SetColor(propertyID, color * oldColor);
		}
		if (num >= TimeMultiplier)
		{
			canUpdate = false;
		}
	}
}
public class ExplosionsShaderFloatCurves : MonoBehaviour
{
	public string ShaderProperty = "_BumpAmt";

	public int MaterialID;

	public AnimationCurve FloatPropertyCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphScaleMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private void Start()
	{
		Material[] materials = GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			UnityEngine.Debug.Log("ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			UnityEngine.Debug.Log("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property");
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatPropertyCurve.Evaluate(num / GraphTimeMultiplier) * GraphScaleMultiplier;
			matInstance.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}
public class ExplosionsShaderQueue : MonoBehaviour
{
	public int AddQueue = 1;

	private Renderer rend;

	private void Start()
	{
		rend = GetComponent<Renderer>();
		if (rend != null)
		{
			rend.sharedMaterial.renderQueue += AddQueue;
		}
		else
		{
			Invoke("SetProjectorQueue", 0.1f);
		}
	}

	private void SetProjectorQueue()
	{
		GetComponent<Projector>().material.renderQueue += AddQueue;
	}

	private void OnDisable()
	{
		if (rend != null)
		{
			rend.sharedMaterial.renderQueue = -1;
		}
	}
}
internal class ExplosionsSpriteSheetAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public float AnimationFPS = 30f;

	public bool IsInterpolateFrames;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public float StartDelay;

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float animationLifeTime;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private float currentInterpolatedTime;

	private float animationStartTime;

	private bool animationStoped;

	private void Start()
	{
		currentRenderer = GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		animationStoped = false;
		animationLifeTime = (float)(TilesX * TilesY) / AnimationFPS;
		count = TilesY * TilesX;
		index = TilesX - 1;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		Vector2 value = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		if (currentRenderer != null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", value);
			instanceMaterial.SetTextureOffset("_MainTex", zero);
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				Invoke("PlayDelay", StartDelay);
			}
			else
			{
				StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		StopAllCoroutines();
		CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		animationStartTime = Time.time;
		while (isVisible && (IsLoop || !animationStoped))
		{
			UpdateFrame();
			if (!IsLoop && animationStoped)
			{
				break;
			}
			float value = (Time.time - animationStartTime) / animationLifeTime;
			float num = FrameOverTime.Evaluate(Mathf.Clamp01(value));
			yield return new WaitForSeconds(1f / (AnimationFPS * num));
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateFrame()
	{
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		if (count == allCount)
		{
			animationStartTime = Time.time;
			allCount = 0;
			animationStoped = true;
		}
		Vector2 value = new Vector2((float)index / (float)TilesX - (float)(index / TilesX), 1f - (float)(index / TilesX) / (float)TilesY);
		if (currentRenderer != null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", value);
		}
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime = 0f;
		}
	}

	private void Update()
	{
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime += Time.deltaTime;
			int num = index + 1;
			if (allCount == 0)
			{
				num = index;
			}
			Vector4 value = new Vector4(1f / (float)TilesX, 1f / (float)TilesY, (float)num / (float)TilesX - (float)(num / TilesX), 1f - (float)(num / TilesX) / (float)TilesY);
			if (currentRenderer != null)
			{
				instanceMaterial.SetVector("_MainTex_NextFrame", value);
				float value2 = (Time.time - animationStartTime) / animationLifeTime;
				float num2 = FrameOverTime.Evaluate(Mathf.Clamp01(value2));
				instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * AnimationFPS * num2));
			}
		}
	}

	private void OnDestroy()
	{
		if (instanceMaterial != null)
		{
			UnityEngine.Object.Destroy(instanceMaterial);
			instanceMaterial = null;
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/ME_BloomAndDistortion")]
public class ME_DistortionAndBloom : MonoBehaviour
{
	public LayerMask CullingMask = -1;

	[Range(0.05f, 1f)]
	[UnityEngine.Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.25f;

	public bool UseBloom = true;

	[Range(0.1f, 3f)]
	[UnityEngine.Tooltip("Filters out pixels under this level of brightness.")]
	public float Threshold = 1.2f;

	[SerializeField]
	[Range(0f, 1f)]
	[UnityEngine.Tooltip("Makes transition between under/over-threshold gradual.")]
	public float SoftKnee;

	[Range(1f, 7f)]
	[UnityEngine.Tooltip("Changes extent of veiling effects in A screen resolution-independent fashion.")]
	public float Radius = 7f;

	[UnityEngine.Tooltip("Blend factor of the result image.")]
	public float Intensity = 0.5f;

	[UnityEngine.Tooltip("Controls filter quality and buffer resolution.")]
	public bool HighQuality;

	[UnityEngine.Tooltip("Reduces flashing noise with an additional filter.")]
	public bool AntiFlicker;

	private const string shaderName = "Hidden/KriptoFX/PostEffects/ME_Bloom";

	private const string shaderAdditiveName = "Hidden/KriptoFX/PostEffects/ME_BloomAdditive";

	private const string cameraName = "MobileCamera(Distort_Bloom_Depth)";

	private RenderTexture source;

	private RenderTexture depth;

	private RenderTexture destination;

	private int previuosFrameWidth;

	private int previuosFrameHeight;

	private float previousScale;

	private Camera addCamera;

	private GameObject tempGO;

	private bool HDRSupported;

	private Material m_Material;

	private Material m_MaterialAdditive;

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	public Material mat
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/ME_Bloom"));
			}
			return m_Material;
		}
	}

	public Material matAdditive
	{
		get
		{
			if (m_MaterialAdditive == null)
			{
				m_MaterialAdditive = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/ME_BloomAdditive"));
				m_MaterialAdditive.renderQueue = 3900;
			}
			return m_MaterialAdditive;
		}
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (s == null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	private void OnDisable()
	{
		if (m_Material != null)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
		m_Material = null;
		if (m_MaterialAdditive != null)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialAdditive);
		}
		m_MaterialAdditive = null;
		if (tempGO != null)
		{
			UnityEngine.Object.DestroyImmediate(tempGO);
		}
		Shader.DisableKeyword("DISTORT_OFF");
		Shader.DisableKeyword("_MOBILEDEPTH_ON");
	}

	private void Start()
	{
		InitializeRenderTarget();
	}

	private void LateUpdate()
	{
		if (previuosFrameWidth != Screen.width || previuosFrameHeight != Screen.height || Mathf.Abs(previousScale - RenderTextureResolutoinFactor) > 0.01f)
		{
			InitializeRenderTarget();
			previuosFrameWidth = Screen.width;
			previuosFrameHeight = Screen.height;
			previousScale = RenderTextureResolutoinFactor;
		}
		Shader.EnableKeyword("DISTORT_OFF");
		Shader.EnableKeyword("_MOBILEDEPTH_ON");
		GrabImage();
		if (UseBloom && HDRSupported)
		{
			UpdateBloom();
		}
		Shader.SetGlobalTexture("_GrabTexture", source);
		Shader.SetGlobalTexture("_GrabTextureMobile", source);
		Shader.SetGlobalTexture("_CameraDepthTexture", depth);
		Shader.SetGlobalFloat("_GrabTextureScale", RenderTextureResolutoinFactor);
		Shader.SetGlobalFloat("_GrabTextureMobileScale", RenderTextureResolutoinFactor);
		Shader.DisableKeyword("DISTORT_OFF");
	}

	private void OnPostRender()
	{
		Graphics.Blit(destination, null, matAdditive);
	}

	private void InitializeRenderTarget()
	{
		int num = (int)((float)Screen.width * RenderTextureResolutoinFactor);
		int num2 = (int)((float)Screen.height * RenderTextureResolutoinFactor);
		RenderTextureFormat format = RenderTextureFormat.RGB111110Float;
		if (SystemInfo.SupportsRenderTextureFormat(format))
		{
			source = new RenderTexture(num, num2, 0, format);
			depth = new RenderTexture(num, num2, 8, RenderTextureFormat.Depth);
			HDRSupported = true;
			if (UseBloom)
			{
				destination = new RenderTexture(((double)RenderTextureResolutoinFactor > 0.99) ? num : (num / 2), ((double)RenderTextureResolutoinFactor > 0.99) ? num2 : (num2 / 2), 0, format);
			}
		}
		else
		{
			HDRSupported = false;
			source = new RenderTexture(num, num2, 0, RenderTextureFormat.RGB565);
			depth = new RenderTexture(num, num2, 8, RenderTextureFormat.Depth);
		}
	}

	private void UpdateBloom()
	{
		bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
		if (source == null)
		{
			return;
		}
		int num = source.width;
		int num2 = source.height;
		if (!HighQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
		float num3 = Mathf.Log(num2, 2f) + Radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float num6 = Mathf.GammaToLinearSpace(Threshold);
		mat.SetFloat("_Threshold", num6);
		float num7 = num6 * SoftKnee + 1E-05f;
		Vector3 vector = new Vector3(num6 - num7, num7 * 2f, 0.25f / num7);
		mat.SetVector("_Curve", vector);
		bool flag = !HighQuality && AntiFlicker;
		mat.SetFloat("_PrefilterOffs", flag ? (-0.5f) : 0f);
		mat.SetFloat("_SampleScale", 0.5f + num3 - (float)num4);
		mat.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
		Graphics.Blit(source, temporary, mat, AntiFlicker ? 1 : 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], mat, (i == 0) ? (AntiFlicker ? 3 : 2) : 4);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num8 = num5 - 2; num8 >= 0; num8--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num8];
			mat.SetTexture("_BaseTex", renderTexture2);
			m_blurBuffer2[num8] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num8], mat, HighQuality ? 6 : 5);
			renderTexture = m_blurBuffer2[num8];
		}
		destination.DiscardContents();
		Graphics.Blit(renderTexture, destination, mat, HighQuality ? 8 : 7);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}

	private void GrabImage()
	{
		Camera camera = Camera.current;
		if (camera == null)
		{
			camera = Camera.main;
		}
		if (tempGO == null)
		{
			tempGO = new GameObject();
			tempGO.hideFlags = HideFlags.HideAndDontSave;
			tempGO.name = "MobileCamera(Distort_Bloom_Depth)";
			addCamera = tempGO.AddComponent<Camera>();
			addCamera.enabled = false;
			addCamera.cullingMask = ~(1 << LayerMask.NameToLayer("CustomPostEffectIgnore")) & (int)CullingMask;
		}
		else
		{
			addCamera = tempGO.GetComponent<Camera>();
		}
		addCamera.CopyFrom(camera);
		addCamera.SetTargetBuffers(source.colorBuffer, depth.depthBuffer);
		addCamera.depth--;
		addCamera.cullingMask = ~(1 << LayerMask.NameToLayer("CustomPostEffectIgnore")) & (int)CullingMask;
		addCamera.Render();
	}
}
public class ME_AnimatorEvents : MonoBehaviour
{
	public GameObject EffectPrefab;

	public GameObject SwordPrefab;

	public Transform SwordPosition;

	public Transform StartSwordPosition;

	private GameObject EffectInstance;

	private GameObject SwordInstance;

	private void Start()
	{
		if (SwordInstance != null)
		{
			UnityEngine.Object.Destroy(SwordInstance);
		}
		SwordInstance = UnityEngine.Object.Instantiate(SwordPrefab, StartSwordPosition.position, StartSwordPosition.rotation);
		SwordInstance.transform.parent = StartSwordPosition.transform;
	}

	public void ActivateEffect()
	{
		if (!(EffectPrefab == null) && !(SwordInstance == null))
		{
			if (EffectInstance != null)
			{
				UnityEngine.Object.Destroy(EffectInstance);
			}
			EffectInstance = UnityEngine.Object.Instantiate(EffectPrefab);
			EffectInstance.transform.parent = SwordInstance.transform;
			EffectInstance.transform.localPosition = Vector3.zero;
			EffectInstance.transform.localRotation = default(Quaternion);
			EffectInstance.GetComponent<PSMeshRendererUpdater>().UpdateMeshEffect(SwordInstance);
		}
	}

	public void ActivateSword()
	{
		SwordInstance.transform.parent = SwordPosition.transform;
		SwordInstance.transform.position = SwordPosition.position;
		SwordInstance.transform.rotation = SwordPosition.rotation;
	}

	public void UpdateColor(float HUE)
	{
		if (!(EffectInstance == null))
		{
			ME_EffectSettingColor mE_EffectSettingColor = EffectInstance.GetComponent<ME_EffectSettingColor>();
			if (mE_EffectSettingColor == null)
			{
				mE_EffectSettingColor = EffectInstance.AddComponent<ME_EffectSettingColor>();
			}
			ME_ColorHelper.HSBColor hsbColor = ME_ColorHelper.ColorToHSV(mE_EffectSettingColor.Color);
			hsbColor.H = HUE;
			mE_EffectSettingColor.Color = ME_ColorHelper.HSVToColor(hsbColor);
		}
	}
}
public static class ME_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		foreach (Renderer renderer in componentsInChildren)
		{
			Material[] array = (UnityEngine.Application.isPlaying ? renderer.materials : renderer.sharedMaterials);
			if (array.Length == 0)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name in array2)
			{
				Material[] array3 = array;
				foreach (Material material in array3)
				{
					if (material != null && material.HasProperty(name))
					{
						setMatHUEColor(material, name, hue);
					}
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array2 = colorProperties;
			foreach (string name2 in array2)
			{
				if (trailMaterial != null && trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		foreach (SkinnedMeshRenderer skinnedMeshRenderer in componentsInChildren3)
		{
			Material[] array4 = (UnityEngine.Application.isPlaying ? skinnedMeshRenderer.materials : skinnedMeshRenderer.sharedMaterials);
			if (array4.Length == 0)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name3 in array2)
			{
				Material[] array3 = array4;
				foreach (Material material3 in array3)
				{
					if (material3 != null && material3.HasProperty(name3))
					{
						setMatHUEColor(material3, name3, hue);
					}
				}
			}
		}
		Projector[] componentsInChildren4 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren4)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material4 = projector.material;
			if (material4 == null)
			{
				continue;
			}
			string[] array2 = colorProperties;
			foreach (string name4 in array2)
			{
				if (material4 != null && material4.HasProperty(name4))
				{
					projector.material = setMatHUEColor(material4, name4, hue);
				}
			}
		}
		Light[] componentsInChildren5 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren5)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren6 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren6)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int l = 1; l < colorKeys.Length; l++)
			{
				hsbColor2 = ColorToHSV(colorKeys[l].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[l].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class ME_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		Update();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		float h = ME_ColorHelper.ColorToHSV(Color).H;
		ME_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		previousColor = Color;
	}
}
public class ME_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class ME_MeshMaterialEffect : MonoBehaviour
{
	public Material Material;

	public bool IsFirstMaterial;
}
[ExecuteInEditMode]
public class ME_ParticleCollisionDecal : MonoBehaviour
{
	public ParticleSystem DecalParticles;

	public bool IsBilboard;

	public bool InstantiateWhenZeroSpeed;

	public float MaxGroundAngleDeviation = 45f;

	public float MinDistanceBetweenDecals = 0.1f;

	public float MinDistanceBetweenSurface = 0.03f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem.Particle[] particles;

	private ParticleSystem initiatorPS;

	private List<GameObject> collidedGameObjects = new List<GameObject>();

	private void OnEnable()
	{
		collisionEvents.Clear();
		collidedGameObjects.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[DecalParticles.main.maxParticles];
		if (InstantiateWhenZeroSpeed)
		{
			InvokeRepeating("CollisionDetect", 0f, 0.1f);
		}
	}

	private void OnDisable()
	{
		if (InstantiateWhenZeroSpeed)
		{
			CancelInvoke("CollisionDetect");
		}
	}

	private void CollisionDetect()
	{
		int aliveParticles = 0;
		if (InstantiateWhenZeroSpeed)
		{
			aliveParticles = DecalParticles.GetParticles(particles);
		}
		foreach (GameObject collidedGameObject in collidedGameObjects)
		{
			OnParticleCollisionManual(collidedGameObject, aliveParticles);
		}
	}

	private void OnParticleCollisionManual(GameObject other, int aliveParticles = -1)
	{
		collisionEvents.Clear();
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			if (Vector3.Angle(collisionEvents[i].normal, Vector3.up) > MaxGroundAngleDeviation)
			{
				continue;
			}
			if (InstantiateWhenZeroSpeed)
			{
				if (collisionEvents[i].velocity.sqrMagnitude > 0.1f)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < aliveParticles; j++)
				{
					if (Vector3.Distance(collisionEvents[i].intersection, particles[j].position) < MinDistanceBetweenDecals)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
			emitParams.position = collisionEvents[i].intersection + collisionEvents[i].normal * MinDistanceBetweenSurface;
			Vector3 eulerAngles = Quaternion.LookRotation(-collisionEvents[i].normal).eulerAngles;
			eulerAngles.z = UnityEngine.Random.Range(0, 360);
			emitParams.rotation3D = eulerAngles;
			DecalParticles.Emit(emitParams, 1);
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (InstantiateWhenZeroSpeed)
		{
			if (!collidedGameObjects.Contains(other))
			{
				collidedGameObjects.Add(other);
			}
		}
		else
		{
			OnParticleCollisionManual(other);
		}
	}
}
[ExecuteInEditMode]
public class ME_ParticleGravityPoint : MonoBehaviour
{
	public Transform target;

	public float Force = 1f;

	public bool DistanceRelative;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private Vector3 prevPos;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void LateUpdate()
	{
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = target.position;
		}
		float num2 = Time.deltaTime * Force;
		if (DistanceRelative)
		{
			num2 *= Mathf.Abs((prevPos - vector).magnitude);
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position);
			if (DistanceRelative)
			{
				vector2 = Vector3.Normalize(vector - prevPos);
			}
			Vector3 vector3 = vector2 * num2;
			particles[i].velocity += vector3;
		}
		ps.SetParticles(particles, num);
		prevPos = vector;
	}
}
public class ME_ParticleTrails : MonoBehaviour
{
	public GameObject TrailPrefab;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private Dictionary<uint, GameObject> hashTrails = new Dictionary<uint, GameObject>();

	private Dictionary<uint, GameObject> newHashTrails = new Dictionary<uint, GameObject>();

	private List<GameObject> currentGO = new List<GameObject>();

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
	}

	private void OnEnable()
	{
		InvokeRepeating("ClearEmptyHashes", 1f, 1f);
	}

	private void OnDisable()
	{
		Clear();
		CancelInvoke("ClearEmptyHashes");
	}

	public void Clear()
	{
		foreach (GameObject item in currentGO)
		{
			UnityEngine.Object.Destroy(item);
		}
		currentGO.Clear();
	}

	private void Update()
	{
		UpdateTrail();
	}

	private void UpdateTrail()
	{
		newHashTrails.Clear();
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			if (!hashTrails.ContainsKey(particles[i].randomSeed))
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(TrailPrefab, base.transform.position, default(Quaternion));
				gameObject.transform.parent = base.transform;
				currentGO.Add(gameObject);
				newHashTrails.Add(particles[i].randomSeed, gameObject);
				gameObject.GetComponent<LineRenderer>().widthMultiplier *= particles[i].startSize;
				continue;
			}
			GameObject gameObject2 = hashTrails[particles[i].randomSeed];
			if (gameObject2 != null)
			{
				LineRenderer component = gameObject2.GetComponent<LineRenderer>();
				component.startColor *= (Color)particles[i].GetCurrentColor(ps);
				component.endColor *= (Color)particles[i].GetCurrentColor(ps);
				if (ps.main.simulationSpace == ParticleSystemSimulationSpace.World)
				{
					gameObject2.transform.position = particles[i].position;
				}
				if (ps.main.simulationSpace == ParticleSystemSimulationSpace.Local)
				{
					gameObject2.transform.position = ps.transform.TransformPoint(particles[i].position);
				}
				newHashTrails.Add(particles[i].randomSeed, gameObject2);
			}
			hashTrails.Remove(particles[i].randomSeed);
		}
		foreach (KeyValuePair<uint, GameObject> hashTrail in hashTrails)
		{
			if (hashTrail.Value != null)
			{
				hashTrail.Value.GetComponent<ME_TrailRendererNoise>().IsActive = false;
			}
		}
		AddRange(hashTrails, newHashTrails);
	}

	public void AddRange<T, S>(Dictionary<T, S> source, Dictionary<T, S> collection)
	{
		if (collection == null)
		{
			return;
		}
		foreach (KeyValuePair<T, S> item in collection)
		{
			if (!source.ContainsKey(item.Key))
			{
				source.Add(item.Key, item.Value);
			}
		}
	}

	private void ClearEmptyHashes()
	{
		hashTrails = hashTrails.Where((KeyValuePair<uint, GameObject> h) => h.Value != null).ToDictionary((KeyValuePair<uint, GameObject> h) => h.Key, (KeyValuePair<uint, GameObject> h) => h.Value);
	}
}
public class ME_TrailRendererNoise : MonoBehaviour
{
	[Range(0.01f, 10f)]
	public float MinVertexDistance = 0.1f;

	public float VertexTime = 1f;

	public float TotalLifeTime = 3f;

	public bool SmoothCurves;

	public bool IsRibbon;

	public bool IsActive = true;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float TimeScale = 0.1f;

	[Range(0.001f, 10f)]
	public float Amplitude = 1f;

	public float Gravity = 1f;

	public float TurbulenceStrength = 1f;

	public bool AutodestructWhenNotActive;

	private LineRenderer lineRenderer;

	private Transform t;

	private Vector3 prevPos;

	private List<Vector3> points = new List<Vector3>(500);

	private List<float> lifeTimes = new List<float>(500);

	private List<Vector3> velocities = new List<Vector3>(500);

	private float randomOffset;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private void Start()
	{
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.useWorldSpace = true;
		t = base.transform;
		prevPos = t.position;
		points.Insert(0, t.position);
		lifeTimes.Insert(0, VertexTime);
		velocities.Insert(0, Vector3.zero);
		randomOffset = (float)UnityEngine.Random.Range(0, 10000000) / 1000000f;
	}

	private void OnEnable()
	{
		points.Clear();
		lifeTimes.Clear();
		velocities.Clear();
	}

	private void Update()
	{
		if (IsActive)
		{
			AddNewPoints();
		}
		UpdatetPoints();
		if (SmoothCurves && points.Count > 2)
		{
			UpdateLineRendererBezier();
		}
		else
		{
			UpdateLineRenderer();
		}
		if (AutodestructWhenNotActive && !IsActive && points.Count <= 1)
		{
			UnityEngine.Object.Destroy(base.gameObject, TotalLifeTime);
		}
	}

	private void AddNewPoints()
	{
		if ((t.position - prevPos).magnitude > MinVertexDistance || (IsRibbon && points.Count == 0) || (IsRibbon && points.Count > 0 && (t.position - points[0]).magnitude > MinVertexDistance))
		{
			prevPos = t.position;
			points.Insert(0, t.position);
			lifeTimes.Insert(0, VertexTime);
			velocities.Insert(0, Vector3.zero);
		}
	}

	private void UpdatetPoints()
	{
		for (int i = 0; i < lifeTimes.Count; i++)
		{
			lifeTimes[i] -= Time.deltaTime;
			if (lifeTimes[i] <= 0f)
			{
				int count = lifeTimes.Count - i;
				lifeTimes.RemoveRange(i, count);
				points.RemoveRange(i, count);
				velocities.RemoveRange(i, count);
				break;
			}
			CalculateTurbuelence(points[i], TimeScale, Frequency, Amplitude, Gravity, i);
		}
	}

	private void UpdateLineRendererBezier()
	{
		if (SmoothCurves && points.Count > 2)
		{
			InterpolateBezier(points, 0.5f);
			List<Vector3> drawingPoints = GetDrawingPoints();
			lineRenderer.positionCount = drawingPoints.Count - 1;
			lineRenderer.SetPositions(drawingPoints.ToArray());
		}
	}

	private void UpdateLineRenderer()
	{
		lineRenderer.positionCount = Mathf.Clamp(points.Count - 1, 0, int.MaxValue);
		lineRenderer.SetPositions(points.ToArray());
	}

	private void CalculateTurbuelence(Vector3 position, float speed, float scale, float height, float gravity, int index)
	{
		float num = Time.timeSinceLevelLoad * speed + randomOffset;
		float x = position.x * scale + num;
		float num2 = position.y * scale + num + 10f;
		float y = position.z * scale + num + 25f;
		position.x = (Mathf.PerlinNoise(num2, y) - 0.5f) * height * Time.deltaTime;
		position.y = (Mathf.PerlinNoise(x, y) - 0.5f) * height * Time.deltaTime - gravity * Time.deltaTime;
		position.z = (Mathf.PerlinNoise(x, num2) - 0.5f) * height * Time.deltaTime;
		points[index] += position * TurbulenceStrength;
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1] - vector;
				Vector3 item = vector + scale * vector2;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector3 = segmentPoints[i - 1];
				Vector3 vector4 = segmentPoints[i];
				Vector3 vector5 = vector4 - vector3;
				Vector3 item2 = vector4 - scale * vector5;
				controlPoints.Add(item2);
				controlPoints.Add(vector4);
			}
			else
			{
				Vector3 vector6 = segmentPoints[i - 1];
				Vector3 vector7 = segmentPoints[i];
				Vector3 vector8 = segmentPoints[i + 1];
				Vector3 normalized = (vector8 - vector6).normalized;
				Vector3 item3 = vector7 - scale * normalized * (vector7 - vector6).magnitude;
				Vector3 item4 = vector7 + scale * normalized * (vector8 - vector7).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector7);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}
[ExecuteInEditMode]
public class PSMeshRendererUpdater : MonoBehaviour
{
	public GameObject MeshObject;

	public Color Color = Color.black;

	private const string materialName = "MeshEffect";

	private List<Material[]> rendererMaterials = new List<Material[]>();

	private List<Material[]> skinnedMaterials = new List<Material[]>();

	public bool IsActive = true;

	public float FadeTime = 1.5f;

	private bool currentActiveStatus;

	private bool needUpdateAlpha;

	private Color oldColor = Color.black;

	private float currentAlphaTime;

	private void Update()
	{
		if (UnityEngine.Application.isPlaying)
		{
			CheckFading();
		}
		if (Color != oldColor)
		{
			oldColor = Color;
			UpdateColor(Color);
		}
	}

	public void CheckFading()
	{
		if (currentActiveStatus != IsActive)
		{
			currentActiveStatus = IsActive;
			needUpdateAlpha = true;
			ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
			foreach (ParticleSystem particleSystem in componentsInChildren)
			{
				if (currentActiveStatus)
				{
					particleSystem.Clear();
					particleSystem.Play();
				}
				else
				{
					particleSystem.Stop();
				}
			}
			ME_TrailRendererNoise[] componentsInChildren2 = GetComponentsInChildren<ME_TrailRendererNoise>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				componentsInChildren2[i].IsActive = currentActiveStatus;
			}
		}
		if (needUpdateAlpha)
		{
			if (currentActiveStatus)
			{
				currentAlphaTime += Time.deltaTime;
			}
			else
			{
				currentAlphaTime -= Time.deltaTime;
			}
			if (currentAlphaTime < 0f || currentAlphaTime > FadeTime)
			{
				needUpdateAlpha = false;
			}
			SetAlpha(Mathf.Clamp01(currentAlphaTime / FadeTime));
		}
	}

	public void SetAlpha(float alpha)
	{
		if (MeshObject == null)
		{
			return;
		}
		Light componentInChildren = MeshObject.GetComponentInChildren<Light>();
		if (componentInChildren != null)
		{
			componentInChildren.intensity = alpha;
		}
		MeshRenderer componentInChildren2 = MeshObject.GetComponentInChildren<MeshRenderer>();
		Material[] materials;
		if (componentInChildren2 != null)
		{
			materials = componentInChildren2.materials;
			foreach (Material material in materials)
			{
				if (material.name.Contains("MeshEffect"))
				{
					UpdateAlphaByPropertyName(material, "_TintColor", alpha);
					UpdateAlphaByPropertyName(material, "_MainColor", alpha);
				}
			}
		}
		SkinnedMeshRenderer componentInChildren3 = MeshObject.GetComponentInChildren<SkinnedMeshRenderer>();
		if (!(componentInChildren3 != null))
		{
			return;
		}
		materials = componentInChildren3.materials;
		foreach (Material material2 in materials)
		{
			if (material2.name.Contains("MeshEffect"))
			{
				UpdateAlphaByPropertyName(material2, "_TintColor", alpha);
				UpdateAlphaByPropertyName(material2, "_MainColor", alpha);
			}
		}
	}

	private void UpdateAlphaByPropertyName(Material mat, string name, float alpha)
	{
		if (mat.HasProperty(name))
		{
			Color color = mat.GetColor(name);
			color.a = alpha;
			mat.SetColor(name, color);
		}
	}

	public void UpdateColor(Color color)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.HSBColor hSBColor = ME_ColorHelper.ColorToHSV(color);
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, hSBColor.H);
		}
	}

	public void UpdateColor(float HUE)
	{
		if (!(MeshObject == null))
		{
			ME_ColorHelper.ChangeObjectColorByHUE(MeshObject, HUE);
		}
	}

	public void UpdateMeshEffect()
	{
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = default(Quaternion);
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (!(MeshObject == null))
		{
			UpdatePSMesh(MeshObject);
			AddMaterialToMesh(MeshObject);
		}
	}

	private void CheckScaleIncludedParticles()
	{
	}

	public void UpdateMeshEffect(GameObject go)
	{
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
		if (go == null)
		{
			UnityEngine.Debug.Log("You need set a gameObject");
			return;
		}
		MeshObject = go;
		UpdatePSMesh(MeshObject);
		AddMaterialToMesh(MeshObject);
	}

	private void UpdatePSMesh(GameObject go)
	{
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		MeshRenderer componentInChildren = go.GetComponentInChildren<MeshRenderer>();
		SkinnedMeshRenderer componentInChildren2 = go.GetComponentInChildren<SkinnedMeshRenderer>();
		Light[] componentsInChildren2 = GetComponentsInChildren<Light>();
		float num = 1f;
		float num2 = 1f;
		if (componentInChildren != null)
		{
			num = componentInChildren.bounds.size.magnitude;
		}
		if (componentInChildren2 != null)
		{
			num = componentInChildren2.bounds.size.magnitude;
		}
		num2 = go.transform.lossyScale.magnitude;
		ParticleSystem[] array = componentsInChildren;
		foreach (ParticleSystem obj in array)
		{
			obj.transform.gameObject.SetActive(value: false);
			ParticleSystem.ShapeModule shape = obj.shape;
			if (shape.enabled)
			{
				if (componentInChildren != null)
				{
					shape.shapeType = ParticleSystemShapeType.MeshRenderer;
					shape.meshRenderer = componentInChildren;
				}
				if (componentInChildren2 != null)
				{
					shape.shapeType = ParticleSystemShapeType.SkinnedMeshRenderer;
					shape.skinnedMeshRenderer = componentInChildren2;
				}
			}
			ParticleSystem.MainModule main = obj.main;
			main.startSizeMultiplier *= num / num2;
			obj.transform.gameObject.SetActive(value: true);
		}
		if (componentInChildren != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren.bounds.center;
			}
		}
		if (componentInChildren2 != null)
		{
			Light[] array2 = componentsInChildren2;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].transform.position = componentInChildren2.bounds.center;
			}
		}
	}

	private void AddMaterialToMesh(GameObject go)
	{
		ME_MeshMaterialEffect componentInChildren = GetComponentInChildren<ME_MeshMaterialEffect>();
		if (!(componentInChildren == null))
		{
			MeshRenderer componentInChildren2 = go.GetComponentInChildren<MeshRenderer>();
			SkinnedMeshRenderer componentInChildren3 = go.GetComponentInChildren<SkinnedMeshRenderer>();
			if (componentInChildren2 != null)
			{
				rendererMaterials.Add(componentInChildren2.sharedMaterials);
				componentInChildren2.sharedMaterials = AddToSharedMaterial(componentInChildren2.sharedMaterials, componentInChildren);
			}
			if (componentInChildren3 != null)
			{
				skinnedMaterials.Add(componentInChildren3.sharedMaterials);
				componentInChildren3.sharedMaterials = AddToSharedMaterial(componentInChildren3.sharedMaterials, componentInChildren);
			}
		}
	}

	private Material[] AddToSharedMaterial(Material[] sharedMaterials, ME_MeshMaterialEffect meshMatEffect)
	{
		if (meshMatEffect.IsFirstMaterial)
		{
			return new Material[1] { meshMatEffect.Material };
		}
		List<Material> list = sharedMaterials.ToList();
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].name.Contains("MeshEffect"))
			{
				list.RemoveAt(i);
			}
		}
		list.Add(meshMatEffect.Material);
		return list.ToArray();
	}

	private void OnDestroy()
	{
		if (MeshObject == null)
		{
			return;
		}
		MeshRenderer[] componentsInChildren = MeshObject.GetComponentsInChildren<MeshRenderer>();
		SkinnedMeshRenderer[] componentsInChildren2 = MeshObject.GetComponentsInChildren<SkinnedMeshRenderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (rendererMaterials.Count == componentsInChildren.Length)
			{
				componentsInChildren[i].sharedMaterials = rendererMaterials[i];
			}
			List<Material> list = componentsInChildren[i].sharedMaterials.ToList();
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j].name.Contains("MeshEffect"))
				{
					list.RemoveAt(j);
				}
			}
			componentsInChildren[i].sharedMaterials = list.ToArray();
		}
		for (int k = 0; k < componentsInChildren2.Length; k++)
		{
			if (skinnedMaterials.Count == componentsInChildren2.Length)
			{
				componentsInChildren2[k].sharedMaterials = skinnedMaterials[k];
			}
			List<Material> list2 = componentsInChildren2[k].sharedMaterials.ToList();
			for (int l = 0; l < list2.Count; l++)
			{
				if (list2[l].name.Contains("MeshEffect"))
				{
					list2.RemoveAt(l);
				}
			}
			componentsInChildren2[k].sharedMaterials = list2.ToArray();
		}
		rendererMaterials.Clear();
		skinnedMaterials.Clear();
	}
}
public class FlyDemo : MonoBehaviour
{
	public float Speed = 1f;

	public float Height = 1f;

	private Transform t;

	private float time;

	private void Start()
	{
		t = base.transform;
	}

	private void Update()
	{
		time += Time.deltaTime;
		float num = Mathf.Cos(time / Speed);
		t.localPosition = new Vector3(0f, 0f, num * Height);
	}
}
public enum Position
{
	Middle,
	Bottom,
	Bottom02
}
public class DemoGUI : MonoBehaviour
{
	public Texture HUETexture;

	public Material mat;

	public Position[] Positions;

	public GameObject[] Prefabs;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float colorHUE;

	private float dpiScale;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber], base.transform.position, default(Quaternion));
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 105f * dpiScale, 30f * dpiScale), "Previous Effect"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(130f * dpiScale, 15f * dpiScale, 105f * dpiScale, 30f * dpiScale), "Next Effect"))
		{
			ChangeCurrent(1);
		}
		GUI.Label(new Rect(300f * dpiScale, 15f * dpiScale, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + Prefabs[currentNomber].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
		GUI.DrawTexture(new Rect(12f * dpiScale, 80f * dpiScale, 220f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 105f * dpiScale, 220f * dpiScale, 15f * dpiScale), colorHUE, 0f, 1530f);
		if ((double)Mathf.Abs(num - colorHUE) > 0.001)
		{
			ChangeColor();
		}
		GUI.Label(new Rect(240f * dpiScale, 105f * dpiScale, 30f * dpiScale, 30f * dpiScale), "Effect color", guiStyleHeader);
	}

	private void ChangeColor()
	{
		Color color = Hue(colorHUE / 255f);
		Renderer[] componentsInChildren = currentInstance.GetComponentsInChildren<Renderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (!(material == null) && material.HasProperty("_TintColor"))
			{
				color.a = material.GetColor("_TintColor").a;
				material.SetColor("_TintColor", color);
			}
		}
		Light componentInChildren = currentInstance.GetComponentInChildren<Light>();
		if (componentInChildren != null)
		{
			componentInChildren.color = color;
		}
	}

	private Color Hue(float H)
	{
		Color result = new Color(1f, 0f, 0f);
		if (H >= 0f && H < 1f)
		{
			result = new Color(1f, 0f, H);
		}
		if (H >= 1f && H < 2f)
		{
			result = new Color(2f - H, 0f, 1f);
		}
		if (H >= 2f && H < 3f)
		{
			result = new Color(0f, H - 2f, 1f);
		}
		if (H >= 3f && H < 4f)
		{
			result = new Color(0f, 1f, 4f - H);
		}
		if (H >= 4f && H < 5f)
		{
			result = new Color(H - 4f, 1f, 0f);
		}
		if (H >= 5f && H < 6f)
		{
			result = new Color(1f, 6f - H, 0f);
		}
		return result;
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
		}
		Vector3 position = base.transform.position;
		if (Positions[currentNomber] == Position.Bottom)
		{
			position.y -= 1f;
		}
		if (Positions[currentNomber] == Position.Bottom02)
		{
			position.y -= 0.8f;
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber], position, default(Quaternion));
	}
}
public class MyGUI3_1 : MonoBehaviour
{
	public enum GuiStat
	{
		Ball,
		BallRotate,
		BallRotatex4,
		Bottom,
		Middle,
		MiddleWithoutRobot,
		Top,
		TopTarget
	}

	public struct HSBColor
	{
		public float h;

		public float s;

		public float b;

		public float a;

		public HSBColor(float h, float s, float b, float a)
		{
			this.h = h;
			this.s = s;
			this.b = b;
			this.a = a;
		}
	}

	public Texture HUETexture;

	public int CurrentPrefabNomber;

	public float UpdateInterval = 0.5f;

	public Light DirLight;

	public GameObject Target;

	public GameObject TargetForRay;

	public GameObject TopPosition;

	public GameObject MiddlePosition;

	public Vector3 defaultRobotPos;

	public GameObject BottomPosition;

	public GameObject Plane1;

	public GameObject Plane2;

	public Material[] PlaneMaterials;

	public GuiStat[] GuiStats;

	public GameObject[] Prefabs;

	private float oldLightIntensity;

	private Color oldAmbientColor;

	private GameObject currentGo;

	private bool isDay;

	private bool isDefaultPlaneTexture;

	private int current;

	private EffectSettings effectSettings;

	private bool isReadyEffect;

	private Quaternion defaultRobotRotation;

	private float colorHUE;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float dpiScale;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		oldAmbientColor = RenderSettings.ambientLight;
		oldLightIntensity = DirLight.intensity;
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
		current = CurrentPrefabNomber;
		InstanceCurrent(GuiStats[CurrentPrefabNomber]);
	}

	private void InstanceEffect(Vector3 pos)
	{
		currentGo = UnityEngine.Object.Instantiate(Prefabs[current], pos, Prefabs[current].transform.rotation);
		effectSettings = currentGo.GetComponent<EffectSettings>();
		effectSettings.Target = GetTargetObject(GuiStats[current]);
		effectSettings.EffectDeactivated += effectSettings_EffectDeactivated;
		if (GuiStats[current] == GuiStat.Middle)
		{
			currentGo.transform.parent = GetTargetObject(GuiStat.Middle).transform;
			currentGo.transform.position = GetInstancePosition(GuiStat.Middle);
		}
		else
		{
			currentGo.transform.parent = base.transform;
		}
		effectSettings.CollisionEnter += delegate(object n, CollisionInfo e)
		{
			if (e.Hit.transform != null)
			{
				UnityEngine.Debug.Log(e.Hit.transform.name);
			}
		};
	}

	private GameObject GetTargetObject(GuiStat stat)
	{
		switch (stat)
		{
		case GuiStat.Ball:
			return Target;
		case GuiStat.BallRotate:
			return Target;
		case GuiStat.Bottom:
			return BottomPosition;
		case GuiStat.Top:
			return TopPosition;
		case GuiStat.TopTarget:
			return BottomPosition;
		case GuiStat.Middle:
			MiddlePosition.transform.localPosition = defaultRobotPos;
			MiddlePosition.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
			return MiddlePosition;
		case GuiStat.MiddleWithoutRobot:
			return MiddlePosition.transform.parent.gameObject;
		default:
			return base.gameObject;
		}
	}

	private void effectSettings_EffectDeactivated(object sender, EventArgs e)
	{
		if (GuiStats[current] != GuiStat.Middle)
		{
			currentGo.transform.position = GetInstancePosition(GuiStats[current]);
		}
		isReadyEffect = true;
	}

	private void OnGUI()
	{
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 105f * dpiScale, 30f * dpiScale), "Previous Effect"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(130f * dpiScale, 15f * dpiScale, 105f * dpiScale, 30f * dpiScale), "Next Effect"))
		{
			ChangeCurrent(1);
		}
		if (Prefabs[current] != null)
		{
			GUI.Label(new Rect(300f * dpiScale, 15f * dpiScale, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + Prefabs[current].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
		}
		if (GUI.Button(new Rect(10f * dpiScale, 60f * dpiScale, 225f * dpiScale, 30f * dpiScale), "Day/Night"))
		{
			DirLight.intensity = ((!isDay) ? 0f : oldLightIntensity);
			DirLight.transform.rotation = (isDay ? Quaternion.Euler(400f, 30f, 90f) : Quaternion.Euler(350f, 30f, 90f));
			RenderSettings.ambientLight = ((!isDay) ? new Color(0.1f, 0.1f, 0.1f) : oldAmbientColor);
			RenderSettings.ambientIntensity = (isDay ? 0.5f : 0.1f);
			RenderSettings.reflectionIntensity = (isDay ? 1f : 0.1f);
			isDay = !isDay;
		}
		GUI.DrawTexture(new Rect(12f * dpiScale, 110f * dpiScale, 220f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 135f * dpiScale, 220f * dpiScale, 15f * dpiScale), colorHUE, 0f, 360f);
		if ((double)Mathf.Abs(num - colorHUE) > 0.001)
		{
			ChangeColor();
		}
		GUI.Label(new Rect(240f * dpiScale, 105f * dpiScale, 30f * dpiScale, 30f * dpiScale), "Effect color", guiStyleHeader);
	}

	private void Update()
	{
		if (isReadyEffect)
		{
			isReadyEffect = false;
			currentGo.SetActive(value: true);
		}
		if (GuiStats[current] == GuiStat.BallRotate)
		{
			currentGo.transform.localRotation = Quaternion.Euler(0f, Mathf.PingPong(Time.time * 5f, 60f) - 50f, 0f);
		}
		if (GuiStats[current] == GuiStat.BallRotatex4)
		{
			currentGo.transform.localRotation = Quaternion.Euler(0f, Mathf.PingPong(Time.time * 30f, 100f) - 70f, 0f);
		}
	}

	private void InstanceCurrent(GuiStat stat)
	{
		switch (stat)
		{
		case GuiStat.Ball:
			MiddlePosition.SetActive(value: false);
			InstanceEffect(base.transform.position);
			break;
		case GuiStat.BallRotate:
			MiddlePosition.SetActive(value: false);
			InstanceEffect(base.transform.position);
			break;
		case GuiStat.BallRotatex4:
			MiddlePosition.SetActive(value: false);
			InstanceEffect(base.transform.position);
			break;
		case GuiStat.Bottom:
			MiddlePosition.SetActive(value: false);
			InstanceEffect(BottomPosition.transform.position);
			break;
		case GuiStat.Top:
			MiddlePosition.SetActive(value: false);
			InstanceEffect(TopPosition.transform.position);
			break;
		case GuiStat.TopTarget:
			MiddlePosition.SetActive(value: false);
			InstanceEffect(TopPosition.transform.position);
			break;
		case GuiStat.Middle:
			MiddlePosition.SetActive(value: true);
			InstanceEffect(MiddlePosition.transform.parent.transform.position);
			break;
		case GuiStat.MiddleWithoutRobot:
			MiddlePosition.SetActive(value: false);
			InstanceEffect(MiddlePosition.transform.position);
			break;
		}
	}

	private Vector3 GetInstancePosition(GuiStat stat)
	{
		return stat switch
		{
			GuiStat.Ball => base.transform.position, 
			GuiStat.BallRotate => base.transform.position, 
			GuiStat.BallRotatex4 => base.transform.position, 
			GuiStat.Bottom => BottomPosition.transform.position, 
			GuiStat.Top => TopPosition.transform.position, 
			GuiStat.TopTarget => TopPosition.transform.position, 
			GuiStat.MiddleWithoutRobot => MiddlePosition.transform.parent.transform.position, 
			GuiStat.Middle => MiddlePosition.transform.parent.transform.position, 
			_ => base.transform.position, 
		};
	}

	private void ChangeCurrent(int delta)
	{
		UnityEngine.Object.Destroy(currentGo);
		CancelInvoke("InstanceDefaulBall");
		current += delta;
		if (current > Prefabs.Length - 1)
		{
			current = 0;
		}
		else if (current < 0)
		{
			current = Prefabs.Length - 1;
		}
		if (effectSettings != null)
		{
			effectSettings.EffectDeactivated -= effectSettings_EffectDeactivated;
		}
		MiddlePosition.SetActive(GuiStats[current] == GuiStat.Middle);
		InstanceEffect(GetInstancePosition(GuiStats[current]));
		if (TargetForRay != null)
		{
			if (current == 14 || current == 22)
			{
				TargetForRay.SetActive(value: true);
			}
			else
			{
				TargetForRay.SetActive(value: false);
			}
		}
	}

	private Color Hue(float H)
	{
		Color result = new Color(1f, 0f, 0f);
		if (H >= 0f && H < 1f)
		{
			result = new Color(1f, 0f, H);
		}
		if (H >= 1f && H < 2f)
		{
			result = new Color(2f - H, 0f, 1f);
		}
		if (H >= 2f && H < 3f)
		{
			result = new Color(0f, H - 2f, 1f);
		}
		if (H >= 3f && H < 4f)
		{
			result = new Color(0f, 1f, 4f - H);
		}
		if (H >= 4f && H < 5f)
		{
			result = new Color(H - 4f, 1f, 0f);
		}
		if (H >= 5f && H < 6f)
		{
			result = new Color(1f, 6f - H, 0f);
		}
		return result;
	}

	public HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (g == num)
			{
				result.h = (b - r) / num3 * 60f + 120f;
			}
			else if (b == num)
			{
				result.h = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.h = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.h = (g - b) / num3 * 60f;
			}
			if (result.h < 0f)
			{
				result.h += 360f;
			}
		}
		else
		{
			result.h = 0f;
		}
		result.h *= 0.0027777778f;
		result.s = num3 / num * 1f;
		result.b = num;
		return result;
	}

	public Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.b;
		float value2 = hsbColor.b;
		float value3 = hsbColor.b;
		if (hsbColor.s != 0f)
		{
			float b = hsbColor.b;
			float num = hsbColor.b * hsbColor.s;
			float num2 = hsbColor.b - num;
			float num3 = hsbColor.h * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.a);
	}

	private void ChangeColor()
	{
		Color color = Hue(colorHUE / 255f);
		Renderer[] componentsInChildren = currentGo.GetComponentsInChildren<Renderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (!(material == null))
			{
				if (material.HasProperty("_TintColor"))
				{
					Color color2 = material.GetColor("_TintColor");
					HSBColor hsbColor = ColorToHSV(color2);
					hsbColor.h = colorHUE / 360f;
					color = HSVToColor(hsbColor);
					color.a = color2.a;
					material.SetColor("_TintColor", color);
				}
				if (material.HasProperty("_CoreColor"))
				{
					Color color3 = material.GetColor("_CoreColor");
					HSBColor hsbColor2 = ColorToHSV(color3);
					hsbColor2.h = colorHUE / 360f;
					color = HSVToColor(hsbColor2);
					color.a = color3.a;
					material.SetColor("_CoreColor", color);
				}
			}
		}
		Projector[] componentsInChildren2 = currentGo.GetComponentsInChildren<Projector>();
		foreach (Projector projector in componentsInChildren2)
		{
			Material material2 = projector.material;
			if (!(material2 == null) && material2.HasProperty("_TintColor"))
			{
				Color color4 = material2.GetColor("_TintColor");
				HSBColor hsbColor3 = ColorToHSV(color4);
				hsbColor3.h = colorHUE / 360f;
				color = HSVToColor(hsbColor3);
				color.a = color4.a;
				projector.material.SetColor("_TintColor", color);
			}
		}
		Light componentInChildren = currentGo.GetComponentInChildren<Light>();
		if (componentInChildren != null)
		{
			componentInChildren.color = color;
		}
	}
}
public class RealtimeReflection : MonoBehaviour
{
	private ReflectionProbe probe;

	private Transform camT;

	private void Awake()
	{
		probe = GetComponent<ReflectionProbe>();
		camT = Camera.main.transform;
	}

	private void Update()
	{
		Vector3 position = camT.position;
		probe.transform.position = new Vector3(position.x, position.y * -1f, position.z);
		probe.RenderProbe();
	}
}
public class AddMaterialOnHit : MonoBehaviour
{
	public float RemoveAfterTime = 5f;

	public bool RemoveWhenDisable;

	public EffectSettings EffectSettings;

	public Material Material;

	public bool UsePointMatrixTransform;

	public Vector3 TransformScale = Vector3.one;

	private FadeInOutShaderColor[] fadeInOutShaderColor;

	private FadeInOutShaderFloat[] fadeInOutShaderFloat;

	private UVTextureAnimator uvTextureAnimator;

	private Renderer renderParent;

	private Material instanceMat;

	private int materialQueue = -1;

	private bool waitRemove;

	private float timeToDelete;

	private void Update()
	{
		if (EffectSettings == null)
		{
			return;
		}
		if (EffectSettings.IsVisible)
		{
			timeToDelete = 0f;
			return;
		}
		timeToDelete += Time.deltaTime;
		if (timeToDelete > RemoveAfterTime)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}

	public void UpdateMaterial(RaycastHit hit)
	{
		if (!(hit.transform != null))
		{
			return;
		}
		if (!RemoveWhenDisable)
		{
			UnityEngine.Object.Destroy(base.gameObject, RemoveAfterTime);
		}
		fadeInOutShaderColor = GetComponents<FadeInOutShaderColor>();
		fadeInOutShaderFloat = GetComponents<FadeInOutShaderFloat>();
		uvTextureAnimator = GetComponent<UVTextureAnimator>();
		renderParent = base.transform.parent.GetComponent<Renderer>();
		Material[] sharedMaterials = renderParent.sharedMaterials;
		int num = sharedMaterials.Length + 1;
		Material[] array = new Material[num];
		sharedMaterials.CopyTo(array, 0);
		renderParent.material = Material;
		instanceMat = renderParent.material;
		array[num - 1] = instanceMat;
		renderParent.sharedMaterials = array;
		if (UsePointMatrixTransform)
		{
			Matrix4x4 value = Matrix4x4.TRS(hit.transform.InverseTransformPoint(hit.point), Quaternion.Euler(180f, 180f, 0f), TransformScale);
			instanceMat.SetMatrix("_DecalMatr", value);
		}
		if (materialQueue != -1)
		{
			instanceMat.renderQueue = materialQueue;
		}
		if (fadeInOutShaderColor != null)
		{
			FadeInOutShaderColor[] array2 = fadeInOutShaderColor;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].UpdateMaterial(instanceMat);
			}
		}
		if (fadeInOutShaderFloat != null)
		{
			FadeInOutShaderFloat[] array3 = fadeInOutShaderFloat;
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i].UpdateMaterial(instanceMat);
			}
		}
		if (uvTextureAnimator != null)
		{
			uvTextureAnimator.SetInstanceMaterial(instanceMat, hit.textureCoord);
		}
	}

	public void UpdateMaterial(Transform transformTarget)
	{
		if (!(transformTarget != null))
		{
			return;
		}
		if (!RemoveWhenDisable)
		{
			UnityEngine.Object.Destroy(base.gameObject, RemoveAfterTime);
		}
		fadeInOutShaderColor = GetComponents<FadeInOutShaderColor>();
		fadeInOutShaderFloat = GetComponents<FadeInOutShaderFloat>();
		uvTextureAnimator = GetComponent<UVTextureAnimator>();
		renderParent = base.transform.parent.GetComponent<Renderer>();
		Material[] sharedMaterials = renderParent.sharedMaterials;
		int num = sharedMaterials.Length + 1;
		Material[] array = new Material[num];
		sharedMaterials.CopyTo(array, 0);
		renderParent.material = Material;
		instanceMat = renderParent.material;
		array[num - 1] = instanceMat;
		renderParent.sharedMaterials = array;
		if (materialQueue != -1)
		{
			instanceMat.renderQueue = materialQueue;
		}
		if (fadeInOutShaderColor != null)
		{
			FadeInOutShaderColor[] array2 = fadeInOutShaderColor;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].UpdateMaterial(instanceMat);
			}
		}
		if (fadeInOutShaderFloat != null)
		{
			FadeInOutShaderFloat[] array3 = fadeInOutShaderFloat;
			for (int i = 0; i < array3.Length; i++)
			{
				array3[i].UpdateMaterial(instanceMat);
			}
		}
		if (uvTextureAnimator != null)
		{
			uvTextureAnimator.SetInstanceMaterial(instanceMat, Vector2.zero);
		}
	}

	public void SetMaterialQueue(int matlQueue)
	{
		materialQueue = matlQueue;
	}

	public int GetDefaultMaterialQueue()
	{
		return instanceMat.renderQueue;
	}

	private void OnDestroy()
	{
		if (!(renderParent == null))
		{
			List<Material> list = renderParent.sharedMaterials.ToList();
			list.Remove(instanceMat);
			renderParent.sharedMaterials = list.ToArray();
		}
	}
}
public class AnimatorBehaviour : MonoBehaviour
{
	public Animator anim;

	private EffectSettings effectSettings;

	private bool isInitialized;

	private float oldSpeed;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		oldSpeed = anim.speed;
		GetEffectSettingsComponent(base.transform);
		if (effectSettings != null)
		{
			effectSettings.CollisionEnter += prefabSettings_CollisionEnter;
		}
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			anim.speed = oldSpeed;
		}
	}

	private void prefabSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		anim.speed = 0f;
	}

	private void Update()
	{
	}
}
public class IceOffsetBehaviour : MonoBehaviour
{
	private void Start()
	{
		FadeInOutShaderFloat component = GetComponent<FadeInOutShaderFloat>();
		if (component == null)
		{
			return;
		}
		Transform parent = base.transform.parent;
		SkinnedMeshRenderer component2 = parent.GetComponent<SkinnedMeshRenderer>();
		Mesh sharedMesh;
		if (component2 != null)
		{
			sharedMesh = component2.sharedMesh;
		}
		else
		{
			MeshFilter component3 = parent.GetComponent<MeshFilter>();
			if (component3 == null)
			{
				return;
			}
			sharedMesh = component3.sharedMesh;
		}
		if (!sharedMesh.isReadable)
		{
			component.MaxFloat = 0f;
			return;
		}
		int num = sharedMesh.triangles.Length;
		if (num < 1000)
		{
			if (num > 500)
			{
				component.MaxFloat = (float)num / 1000f - 0.5f;
			}
			else
			{
				component.MaxFloat = 0f;
			}
		}
	}

	private void Update()
	{
	}
}
public class LazyLoad : MonoBehaviour
{
	public GameObject GO;

	public float TimeDelay = 0.3f;

	private void Awake()
	{
		GO.SetActive(value: false);
	}

	private void LazyEnable()
	{
		GO.SetActive(value: true);
	}

	private void OnEnable()
	{
		Invoke("LazyEnable", TimeDelay);
	}

	private void OnDisable()
	{
		CancelInvoke("LazyEnable");
		GO.SetActive(value: false);
	}
}
public class LineProjectileCollisionBehaviour : MonoBehaviour
{
	public GameObject EffectOnHit;

	public GameObject EffectOnHitObject;

	public GameObject ParticlesScale;

	public GameObject GoLight;

	public bool IsCenterLightPosition;

	public LineRenderer[] LineRenderers;

	private EffectSettings effectSettings;

	private Transform t;

	private Transform tLight;

	private Transform tEffectOnHit;

	private Transform tParticleScale;

	private RaycastHit hit;

	private RaycastHit oldRaycastHit;

	private bool isInitializedOnStart;

	private bool frameDroped;

	private ParticleSystem[] effectOnHitParticles;

	private EffectSettings effectSettingsInstance;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		t = base.transform;
		if (EffectOnHit != null)
		{
			tEffectOnHit = EffectOnHit.transform;
			effectOnHitParticles = EffectOnHit.GetComponentsInChildren<ParticleSystem>();
		}
		if (ParticlesScale != null)
		{
			tParticleScale = ParticlesScale.transform;
		}
		GetEffectSettingsComponent(t);
		if (effectSettings == null)
		{
			UnityEngine.Debug.Log("Prefab root or children have not script \"PrefabSettings\"");
		}
		if (GoLight != null)
		{
			tLight = GoLight.transform;
		}
		InitializeDefault();
		isInitializedOnStart = true;
	}

	private void OnEnable()
	{
		if (isInitializedOnStart)
		{
			InitializeDefault();
		}
	}

	private void OnDisable()
	{
		CollisionLeave();
	}

	private void InitializeDefault()
	{
		hit = default(RaycastHit);
		frameDroped = false;
	}

	private void Update()
	{
		if (!frameDroped)
		{
			frameDroped = true;
			return;
		}
		Vector3 vector = t.position + t.forward * effectSettings.MoveDistance;
		if (Physics.Raycast(t.position, t.forward, out var hitInfo, effectSettings.MoveDistance + 1f, effectSettings.LayerMask))
		{
			hit = hitInfo;
			vector = hitInfo.point;
			if (oldRaycastHit.collider != hit.collider)
			{
				CollisionLeave();
				oldRaycastHit = hit;
				CollisionEnter();
				if (EffectOnHit != null)
				{
					ParticleSystem[] array = effectOnHitParticles;
					for (int i = 0; i < array.Length; i++)
					{
						array[i].Play();
					}
				}
			}
			if (EffectOnHit != null)
			{
				tEffectOnHit.position = hit.point - t.forward * effectSettings.ColliderRadius;
			}
		}
		else if (EffectOnHit != null)
		{
			ParticleSystem[] array = effectOnHitParticles;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Stop();
			}
		}
		if (EffectOnHit != null)
		{
			tEffectOnHit.LookAt(hit.point + hit.normal);
		}
		if (IsCenterLightPosition && GoLight != null)
		{
			tLight.position = (t.position + vector) / 2f;
		}
		LineRenderer[] lineRenderers = LineRenderers;
		foreach (LineRenderer obj in lineRenderers)
		{
			obj.SetPosition(0, vector);
			obj.SetPosition(1, t.position);
		}
		if (ParticlesScale != null)
		{
			float x = Vector3.Distance(t.position, vector) / 2f;
			tParticleScale.localScale = new Vector3(x, 1f, 1f);
		}
	}

	private void CollisionEnter()
	{
		if (EffectOnHitObject != null && hit.transform != null)
		{
			AddMaterialOnHit componentInChildren = hit.transform.GetComponentInChildren<AddMaterialOnHit>();
			effectSettingsInstance = null;
			if (componentInChildren != null)
			{
				effectSettingsInstance = componentInChildren.gameObject.GetComponent<EffectSettings>();
			}
			if (effectSettingsInstance != null)
			{
				effectSettingsInstance.IsVisible = true;
			}
			else
			{
				Renderer componentInChildren2 = hit.transform.GetComponentInChildren<Renderer>();
				GameObject gameObject = UnityEngine.Object.Instantiate(EffectOnHitObject);
				gameObject.transform.parent = componentInChildren2.transform;
				gameObject.transform.localPosition = Vector3.zero;
				gameObject.GetComponent<AddMaterialOnHit>().UpdateMaterial(hit);
				effectSettingsInstance = gameObject.GetComponent<EffectSettings>();
			}
		}
		effectSettings.OnCollisionHandler(new CollisionInfo
		{
			Hit = hit
		});
	}

	private void CollisionLeave()
	{
		if (effectSettingsInstance != null)
		{
			effectSettingsInstance.IsVisible = false;
		}
	}
}
public enum RandomMoveCoordinates
{
	None,
	XY,
	XZ,
	YZ,
	XYZ
}
public class ProjectileCollisionBehaviour : MonoBehaviour
{
	public float RandomMoveRadius;

	public float RandomMoveSpeed;

	public float RandomRange;

	public RandomMoveCoordinates RandomMoveCoordinates;

	public GameObject EffectOnHitObject;

	public GameObject GoLight;

	public AnimationCurve Acceleration;

	public float AcceleraionTime = 1f;

	public bool IsCenterLightPosition;

	public bool IsLookAt;

	public bool AttachAfterCollision;

	public bool IsRootMove = true;

	public bool IsLocalSpaceRandomMove;

	public bool IsDeviation;

	public bool SendCollisionMessage = true;

	public bool ResetParentPositionOnDisable;

	private EffectSettings effectSettings;

	private Transform tRoot;

	private Transform tTarget;

	private Transform t;

	private Transform tLight;

	private Vector3 forwardDirection;

	private Vector3 startPosition;

	private Vector3 startParentPosition;

	private RaycastHit hit;

	private Vector3 smootRandomPos;

	private Vector3 oldSmootRandomPos;

	private float deltaSpeed;

	private float startTime;

	private float randomSpeed;

	private float randomRadiusX;

	private float randomRadiusY;

	private int randomDirection1;

	private int randomDirection2;

	private int randomDirection3;

	private bool onCollision;

	private bool isInitializedOnStart;

	private Vector3 randomTargetOffsetXZVector;

	private bool frameDroped;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		t = base.transform;
		GetEffectSettingsComponent(t);
		if (effectSettings == null)
		{
			UnityEngine.Debug.Log("Prefab root or children have not script \"PrefabSettings\"");
		}
		if (!IsRootMove)
		{
			startParentPosition = base.transform.parent.position;
		}
		if (GoLight != null)
		{
			tLight = GoLight.transform;
		}
		InitializeDefault();
		isInitializedOnStart = true;
	}

	private void OnEnable()
	{
		if (isInitializedOnStart)
		{
			InitializeDefault();
		}
	}

	private void OnDisable()
	{
		if (ResetParentPositionOnDisable && isInitializedOnStart && !IsRootMove)
		{
			base.transform.parent.position = startParentPosition;
		}
	}

	private void InitializeDefault()
	{
		hit = default(RaycastHit);
		onCollision = false;
		smootRandomPos = default(Vector3);
		oldSmootRandomPos = default(Vector3);
		deltaSpeed = 0f;
		startTime = 0f;
		randomSpeed = 0f;
		randomRadiusX = 0f;
		randomRadiusY = 0f;
		randomDirection1 = 0;
		randomDirection2 = 0;
		randomDirection3 = 0;
		frameDroped = false;
		tRoot = (IsRootMove ? effectSettings.transform : base.transform.parent);
		startPosition = tRoot.position;
		if (effectSettings.Target != null)
		{
			tTarget = effectSettings.Target.transform;
		}
		else if (!effectSettings.UseMoveVector)
		{
			UnityEngine.Debug.Log("You must setup the the target or the motion vector");
		}
		if ((double)effectSettings.EffectRadius > 0.001)
		{
			Vector2 vector = UnityEngine.Random.insideUnitCircle * effectSettings.EffectRadius;
			randomTargetOffsetXZVector = new Vector3(vector.x, 0f, vector.y);
		}
		else
		{
			randomTargetOffsetXZVector = Vector3.zero;
		}
		if (!effectSettings.UseMoveVector)
		{
			forwardDirection = tRoot.position + (tTarget.position + randomTargetOffsetXZVector - tRoot.position).normalized * effectSettings.MoveDistance;
			GetTargetHit();
		}
		else
		{
			forwardDirection = tRoot.position + effectSettings.MoveVector * effectSettings.MoveDistance;
		}
		if (IsLookAt)
		{
			if (!effectSettings.UseMoveVector)
			{
				tRoot.LookAt(tTarget);
			}
			else
			{
				tRoot.LookAt(forwardDirection);
			}
		}
		InitRandomVariables();
	}

	private void Update()
	{
		if (!frameDroped)
		{
			frameDroped = true;
		}
		else if (((effectSettings.UseMoveVector || !(tTarget == null)) && !onCollision) || !frameDroped)
		{
			Vector3 vector = (effectSettings.UseMoveVector ? forwardDirection : (effectSettings.IsHomingMove ? tTarget.position : forwardDirection));
			float num = Vector3.Distance(tRoot.position, vector);
			float num2 = effectSettings.MoveSpeed * Time.deltaTime;
			if (num2 > num)
			{
				num2 = num;
			}
			if (num <= effectSettings.ColliderRadius)
			{
				hit = default(RaycastHit);
				CollisionEnter();
			}
			Vector3 normalized = (vector - tRoot.position).normalized;
			if (Physics.Raycast(tRoot.position, normalized, out var hitInfo, num2 + effectSettings.ColliderRadius, effectSettings.LayerMask))
			{
				hit = hitInfo;
				vector = hitInfo.point - normalized * effectSettings.ColliderRadius;
				CollisionEnter();
			}
			if (IsCenterLightPosition && GoLight != null)
			{
				tLight.position = (startPosition + tRoot.position) / 2f;
			}
			Vector3 vector2 = default(Vector3);
			if (RandomMoveCoordinates != 0)
			{
				UpdateSmootRandomhPos();
				vector2 = smootRandomPos - oldSmootRandomPos;
			}
			float num3 = 1f;
			if (Acceleration.length > 0)
			{
				float time = (Time.time - startTime) / AcceleraionTime;
				num3 = Acceleration.Evaluate(time);
			}
			Vector3 vector3 = Vector3.MoveTowards(tRoot.position, vector, effectSettings.MoveSpeed * Time.deltaTime * num3);
			Vector3 vector4 = vector3 + vector2;
			if (IsLookAt && effectSettings.IsHomingMove)
			{
				tRoot.LookAt(vector4);
			}
			if (IsLocalSpaceRandomMove && IsRootMove)
			{
				tRoot.position = vector3;
				t.localPosition += vector2;
			}
			else
			{
				tRoot.position = vector4;
			}
			oldSmootRandomPos = smootRandomPos;
		}
	}

	private void CollisionEnter()
	{
		if (EffectOnHitObject != null && hit.transform != null)
		{
			Renderer componentInChildren = hit.transform.GetComponentInChildren<Renderer>();
			GameObject obj = UnityEngine.Object.Instantiate(EffectOnHitObject);
			obj.transform.parent = componentInChildren.transform;
			obj.transform.localPosition = Vector3.zero;
			obj.GetComponent<AddMaterialOnHit>().UpdateMaterial(hit);
		}
		if (AttachAfterCollision)
		{
			tRoot.parent = hit.transform;
		}
		if (SendCollisionMessage)
		{
			CollisionInfo e = new CollisionInfo
			{
				Hit = hit
			};
			effectSettings.OnCollisionHandler(e);
			if (hit.transform != null)
			{
				ShieldCollisionBehaviour component = hit.transform.GetComponent<ShieldCollisionBehaviour>();
				if (component != null)
				{
					component.ShieldCollisionEnter(e);
				}
			}
		}
		onCollision = true;
	}

	private void InitRandomVariables()
	{
		deltaSpeed = RandomMoveSpeed * UnityEngine.Random.Range(1f, 1000f * RandomRange + 1f) / 1000f - 1f;
		startTime = Time.time;
		randomRadiusX = UnityEngine.Random.Range(RandomMoveRadius / 20f, RandomMoveRadius * 100f) / 100f;
		randomRadiusY = UnityEngine.Random.Range(RandomMoveRadius / 20f, RandomMoveRadius * 100f) / 100f;
		randomSpeed = UnityEngine.Random.Range(RandomMoveSpeed / 20f, RandomMoveSpeed * 100f) / 100f;
		randomDirection1 = ((UnityEngine.Random.Range(0, 2) > 0) ? 1 : (-1));
		randomDirection2 = ((UnityEngine.Random.Range(0, 2) > 0) ? 1 : (-1));
		randomDirection3 = ((UnityEngine.Random.Range(0, 2) > 0) ? 1 : (-1));
	}

	private void GetTargetHit()
	{
		Ray ray = new Ray(tRoot.position, Vector3.Normalize(tTarget.position + randomTargetOffsetXZVector - tRoot.position));
		Collider componentInChildren = tTarget.GetComponentInChildren<Collider>();
		if (componentInChildren != null && componentInChildren.Raycast(ray, out var hitInfo, effectSettings.MoveDistance))
		{
			hit = hitInfo;
		}
	}

	private void UpdateSmootRandomhPos()
	{
		float num = Time.time - startTime;
		float num2 = num * randomSpeed;
		float f = num * deltaSpeed;
		float num4;
		float num5;
		if (IsDeviation)
		{
			float num3 = Vector3.Distance(tRoot.position, hit.point) / effectSettings.MoveDistance;
			num4 = (float)randomDirection2 * Mathf.Sin(num2) * randomRadiusX * num3;
			num5 = (float)randomDirection3 * Mathf.Sin(num2 + (float)randomDirection1 * (float)Math.PI / 2f * num + Mathf.Sin(f)) * randomRadiusY * num3;
		}
		else
		{
			num4 = (float)randomDirection2 * Mathf.Sin(num2) * randomRadiusX;
			num5 = (float)randomDirection3 * Mathf.Sin(num2 + (float)randomDirection1 * (float)Math.PI / 2f * num + Mathf.Sin(f)) * randomRadiusY;
		}
		if (RandomMoveCoordinates == RandomMoveCoordinates.XY)
		{
			smootRandomPos = new Vector3(num4, num5, 0f);
		}
		if (RandomMoveCoordinates == RandomMoveCoordinates.XZ)
		{
			smootRandomPos = new Vector3(num4, 0f, num5);
		}
		if (RandomMoveCoordinates == RandomMoveCoordinates.YZ)
		{
			smootRandomPos = new Vector3(0f, num4, num5);
		}
		if (RandomMoveCoordinates == RandomMoveCoordinates.XYZ)
		{
			smootRandomPos = new Vector3(num4, num5, (num4 + num5) / 2f * (float)randomDirection1);
		}
	}
}
public class ScaleParticlesFromBound : MonoBehaviour
{
	private Collider targetCollider;

	private void GetMeshFilterParent(Transform t)
	{
		Collider component = t.parent.GetComponent<Collider>();
		if (component == null)
		{
			GetMeshFilterParent(t.parent);
		}
		else
		{
			targetCollider = component;
		}
	}

	private void Start()
	{
		GetMeshFilterParent(base.transform);
		if (!(targetCollider == null))
		{
			Vector3 size = targetCollider.bounds.size;
			base.transform.localScale = size;
		}
	}

	private void Update()
	{
	}
}
public class AnimationSpeedDebuff : MonoBehaviour
{
	public AnimationCurve AnimationSpeenOnTime;

	public float MaxTime = 1f;

	private Animator myAnimator;

	private Transform root;

	private float oldSpeed;

	private float time;

	private void GetAnimatorOnParent(Transform t)
	{
		Animator component = t.parent.GetComponent<Animator>();
		if (component == null)
		{
			if (!(root == t.parent))
			{
				GetAnimatorOnParent(t.parent);
			}
		}
		else
		{
			myAnimator = component;
		}
	}

	private void Start()
	{
		root = base.transform.root;
		GetAnimatorOnParent(base.transform);
		if (!(myAnimator == null))
		{
			oldSpeed = myAnimator.speed;
		}
	}

	private void Update()
	{
		if (!(myAnimator == null) && AnimationSpeenOnTime.length != 0)
		{
			time += Time.deltaTime;
			myAnimator.speed = Mathf.Clamp01(AnimationSpeenOnTime.Evaluate(time / MaxTime) * oldSpeed);
		}
	}
}
public class DebuffOnEnemyFromCollision : MonoBehaviour
{
	public EffectSettings EffectSettings;

	public GameObject Effect;

	private void Start()
	{
		EffectSettings.CollisionEnter += EffectSettings_CollisionEnter;
	}

	private void EffectSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		if (!(Effect == null))
		{
			Collider[] array = Physics.OverlapSphere(base.transform.position, EffectSettings.EffectRadius, EffectSettings.LayerMask);
			foreach (Collider collider in array)
			{
				Renderer componentInChildren = collider.transform.GetComponentInChildren<Renderer>();
				GameObject obj = UnityEngine.Object.Instantiate(Effect);
				obj.transform.parent = componentInChildren.transform;
				obj.transform.localPosition = Vector3.zero;
				obj.GetComponent<AddMaterialOnHit>().UpdateMaterial(collider.transform);
			}
		}
	}

	private void Update()
	{
	}
}
public class ShieldCollisionBehaviour : MonoBehaviour
{
	public GameObject EffectOnHit;

	public GameObject ExplosionOnHit;

	public bool IsWaterInstance;

	public float ScaleWave = 0.89f;

	public bool CreateMechInstanceOnHit;

	public Vector3 AngleFix;

	public int currentQueue = 3001;

	public void ShieldCollisionEnter(CollisionInfo e)
	{
		if (!(e.Hit.transform != null))
		{
			return;
		}
		if (IsWaterInstance)
		{
			Transform obj = UnityEngine.Object.Instantiate(ExplosionOnHit).transform;
			obj.parent = base.transform;
			float num = base.transform.localScale.x * ScaleWave;
			obj.localScale = new Vector3(num, num, num);
			obj.localPosition = new Vector3(0f, 0.001f, 0f);
			obj.LookAt(e.Hit.point);
			return;
		}
		if (EffectOnHit != null)
		{
			if (!CreateMechInstanceOnHit)
			{
				Renderer componentInChildren = e.Hit.transform.GetComponentInChildren<Renderer>();
				GameObject obj2 = UnityEngine.Object.Instantiate(EffectOnHit);
				obj2.transform.parent = componentInChildren.transform;
				obj2.transform.localPosition = Vector3.zero;
				AddMaterialOnHit component = obj2.GetComponent<AddMaterialOnHit>();
				component.SetMaterialQueue(currentQueue);
				component.UpdateMaterial(e.Hit);
			}
			else
			{
				GameObject obj3 = UnityEngine.Object.Instantiate(EffectOnHit);
				Transform obj4 = obj3.transform;
				obj4.parent = GetComponent<Renderer>().transform;
				obj4.localPosition = Vector3.zero;
				obj4.localScale = base.transform.localScale * ScaleWave;
				obj4.LookAt(e.Hit.point);
				obj4.Rotate(AngleFix);
				obj3.GetComponent<Renderer>().material.renderQueue = currentQueue - 1000;
			}
		}
		if (currentQueue > 4000)
		{
			currentQueue = 3001;
		}
		else
		{
			currentQueue++;
		}
		if (ExplosionOnHit != null)
		{
			UnityEngine.Object.Instantiate(ExplosionOnHit, e.Hit.point, default(Quaternion)).transform.parent = base.transform;
		}
	}

	private void Update()
	{
	}
}
public class WaterUvAnimation : MonoBehaviour
{
	public bool IsReverse;

	public float Speed = 1f;

	public int MaterialNomber;

	private Material mat;

	private float deltaFps;

	private bool isVisible;

	private bool isCorutineStarted;

	private float offset;

	private float delta;

	private void Awake()
	{
		mat = GetComponent<Renderer>().materials[MaterialNomber];
	}

	private void Update()
	{
		if (IsReverse)
		{
			offset -= Time.deltaTime * Speed;
			if (offset < 0f)
			{
				offset = 1f;
			}
		}
		else
		{
			offset += Time.deltaTime * Speed;
			if (offset > 1f)
			{
				offset = 0f;
			}
		}
		Vector2 value = new Vector2(0f, offset);
		mat.SetTextureOffset("_BumpMap", value);
		mat.SetFloat("_OffsetYHeightMap", offset);
	}
}
public class MoveOnGround : MonoBehaviour
{
	public bool IsRootMove = true;

	private EffectSettings effectSettings;

	private Transform tRoot;

	private Transform tTarget;

	private Vector3 targetPos;

	private bool isInitialized;

	private bool isFinished;

	private ParticleSystem[] particles;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (effectSettings == null)
		{
			UnityEngine.Debug.Log("Prefab root have not script \"PrefabSettings\"");
		}
		particles = effectSettings.GetComponentsInChildren<ParticleSystem>();
		InitDefaultVariables();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void InitDefaultVariables()
	{
		ParticleSystem[] array = particles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Stop();
		}
		isFinished = false;
		tTarget = effectSettings.Target.transform;
		if (IsRootMove)
		{
			tRoot = effectSettings.transform;
		}
		else
		{
			tRoot = base.transform.parent;
			tRoot.localPosition = Vector3.zero;
		}
		targetPos = tRoot.position + Vector3.Normalize(tTarget.position - tRoot.position) * effectSettings.MoveDistance;
		Physics.Raycast(tRoot.position, Vector3.down, out var hitInfo);
		tRoot.position = hitInfo.point;
		array = particles;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Play();
		}
	}

	private void Update()
	{
		if (!(tTarget == null) && !isFinished)
		{
			Vector3 position = tRoot.position;
			Physics.Raycast(new Vector3(position.x, 0.5f, position.z), Vector3.down, out var hitInfo);
			tRoot.position = hitInfo.point;
			position = tRoot.position;
			Vector3 vector = (effectSettings.IsHomingMove ? tTarget.position : targetPos);
			Vector3 vector2 = new Vector3(vector.x, 0f, vector.z);
			if (Vector3.Distance(new Vector3(position.x, 0f, position.z), vector2) <= effectSettings.ColliderRadius)
			{
				effectSettings.OnCollisionHandler(new CollisionInfo());
				isFinished = true;
			}
			tRoot.position = Vector3.MoveTowards(position, vector2, effectSettings.MoveSpeed * Time.deltaTime);
		}
	}
}
public class OffsetOnNormal : MonoBehaviour
{
	public float offset = 1f;

	public GameObject offsetGameObject;

	private Vector3 startPosition;

	private void Awake()
	{
		startPosition = base.transform.position;
	}

	private void OnEnable()
	{
		Physics.Raycast(startPosition, Vector3.down, out var hitInfo);
		if (offsetGameObject != null)
		{
			base.transform.position = offsetGameObject.transform.position + hitInfo.normal * offset;
		}
		else
		{
			base.transform.position = hitInfo.point + hitInfo.normal * offset;
		}
	}

	private void Update()
	{
	}
}
public class OnRigidbodySendCollision : MonoBehaviour
{
	private EffectSettings effectSettings;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
	}

	private void OnCollisionEnter(Collision collision)
	{
		effectSettings.OnCollisionHandler(new CollisionInfo());
	}
}
public class ResetPositionOnDiactivated : MonoBehaviour
{
	public EffectSettings EffectSettings;

	private void Start()
	{
		EffectSettings.EffectDeactivated += EffectSettings_EffectDeactivated;
	}

	private void EffectSettings_EffectDeactivated(object sender, EventArgs e)
	{
		base.transform.localPosition = Vector3.zero;
	}
}
public class LineRendererBehaviour : MonoBehaviour
{
	public bool IsVertical;

	public float LightHeightOffset = 0.3f;

	public float ParticlesHeightOffset = 0.2f;

	public float TimeDestroyLightAfterCollision = 4f;

	public float TimeDestroyThisAfterCollision = 4f;

	public float TimeDestroyRootAfterCollision = 4f;

	public GameObject EffectOnHitObject;

	public GameObject Explosion;

	public GameObject StartGlow;

	public GameObject HitGlow;

	public GameObject Particles;

	public GameObject GoLight;

	private EffectSettings effectSettings;

	private Transform tRoot;

	private Transform tTarget;

	private bool isInitializedOnStart;

	private LineRenderer line;

	private int currentShaderIndex;

	private RaycastHit hit;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (effectSettings == null)
		{
			UnityEngine.Debug.Log("Prefab root have not script \"PrefabSettings\"");
		}
		tRoot = effectSettings.transform;
		line = GetComponent<LineRenderer>();
		InitializeDefault();
		isInitializedOnStart = true;
	}

	private void InitializeDefault()
	{
		GetComponent<Renderer>().material.SetFloat("_Chanel", currentShaderIndex);
		currentShaderIndex++;
		if (currentShaderIndex == 3)
		{
			currentShaderIndex = 0;
		}
		line.SetPosition(0, tRoot.position);
		if (IsVertical)
		{
			if (Physics.Raycast(tRoot.position, Vector3.down, out hit))
			{
				line.SetPosition(1, hit.point);
				if (StartGlow != null)
				{
					StartGlow.transform.position = tRoot.position;
				}
				if (HitGlow != null)
				{
					HitGlow.transform.position = hit.point;
				}
				if (GoLight != null)
				{
					GoLight.transform.position = hit.point + new Vector3(0f, LightHeightOffset, 0f);
				}
				if (Particles != null)
				{
					Particles.transform.position = hit.point + new Vector3(0f, ParticlesHeightOffset, 0f);
				}
				if (Explosion != null)
				{
					Explosion.transform.position = hit.point + new Vector3(0f, ParticlesHeightOffset, 0f);
				}
			}
		}
		else
		{
			if (effectSettings.Target != null)
			{
				tTarget = effectSettings.Target.transform;
			}
			else if (!effectSettings.UseMoveVector)
			{
				UnityEngine.Debug.Log("You must setup the the target or the motion vector");
			}
			Vector3 vector = (effectSettings.UseMoveVector ? (tRoot.position + effectSettings.MoveVector * effectSettings.MoveDistance) : (tTarget.position - tRoot.position).normalized);
			Vector3 vector2 = tRoot.position + vector * effectSettings.MoveDistance;
			if (Physics.Raycast(tRoot.position, vector, out hit, effectSettings.MoveDistance + 1f, effectSettings.LayerMask))
			{
				vector2 = (tRoot.position + Vector3.Normalize(hit.point - tRoot.position) * (effectSettings.MoveDistance + 1f)).normalized;
			}
			line.SetPosition(1, hit.point - effectSettings.ColliderRadius * vector2);
			Vector3 vector3 = hit.point - vector2 * ParticlesHeightOffset;
			if (StartGlow != null)
			{
				StartGlow.transform.position = tRoot.position;
			}
			if (HitGlow != null)
			{
				HitGlow.transform.position = vector3;
			}
			if (GoLight != null)
			{
				GoLight.transform.position = hit.point - vector2 * LightHeightOffset;
			}
			if (Particles != null)
			{
				Particles.transform.position = vector3;
			}
			if (Explosion != null)
			{
				Explosion.transform.position = vector3;
				Explosion.transform.LookAt(vector3 + hit.normal);
			}
		}
		CollisionInfo e = new CollisionInfo
		{
			Hit = hit
		};
		effectSettings.OnCollisionHandler(e);
		if (hit.transform != null)
		{
			ShieldCollisionBehaviour component = hit.transform.GetComponent<ShieldCollisionBehaviour>();
			if (component != null)
			{
				component.ShieldCollisionEnter(e);
			}
		}
	}

	private void OnEnable()
	{
		if (isInitializedOnStart)
		{
			InitializeDefault();
		}
	}
}
public class Billboard : MonoBehaviour
{
	public Camera Camera;

	public bool Active = true;

	public bool AutoInitCamera = true;

	private GameObject myContainer;

	private Transform t;

	private Transform camT;

	private Transform contT;

	private void Awake()
	{
		if (AutoInitCamera)
		{
			Camera = Camera.main;
			Active = true;
		}
		t = base.transform;
		camT = Camera.transform;
		Transform parent = t.parent;
		myContainer = new GameObject
		{
			name = "Billboard_" + t.gameObject.name
		};
		contT = myContainer.transform;
		contT.position = t.position;
		t.parent = myContainer.transform;
		contT.parent = parent;
	}

	private void Update()
	{
		if (Active)
		{
			contT.LookAt(contT.position + camT.rotation * Vector3.back, camT.rotation * Vector3.up);
		}
	}
}
public class CollisionActiveBehaviour : MonoBehaviour
{
	public bool IsReverse;

	public float TimeDelay;

	public bool IsLookAt;

	private EffectSettings effectSettings;

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (IsReverse)
		{
			effectSettings.RegistreInactiveElement(base.gameObject, TimeDelay);
			base.gameObject.SetActive(value: false);
		}
		else
		{
			effectSettings.RegistreActiveElement(base.gameObject, TimeDelay);
		}
		if (IsLookAt)
		{
			effectSettings.CollisionEnter += effectSettings_CollisionEnter;
		}
	}

	private void effectSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		base.transform.LookAt(effectSettings.transform.position + e.Hit.normal);
	}

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}
}
public class DeadTime : MonoBehaviour
{
	public float deadTime = 1.5f;

	public bool destroyRoot;

	private void Awake()
	{
		UnityEngine.Object.Destroy((!destroyRoot) ? base.gameObject : base.transform.root.gameObject, deadTime);
	}
}
public class DistortionMobileCamera : MonoBehaviour
{
	public float TextureScale = 1f;

	public RenderTextureFormat RenderTextureFormat;

	public FilterMode FilterMode;

	public LayerMask CullingMask = -17;

	public RenderingPath RenderingPath;

	public int FPSWhenMoveCamera = 40;

	public int FPSWhenStaticCamera = 20;

	public bool UseRealTime;

	private RenderTexture renderTexture;

	private Camera cameraInstance;

	private GameObject goCamera;

	private Vector3 oldPosition;

	private Quaternion oldRotation;

	private Transform instanceCameraTransform;

	private bool canUpdateCamera;

	private bool isStaticUpdate;

	private WaitForSeconds fpsMove;

	private WaitForSeconds fpsStatic;

	private const int DropedFrames = 50;

	private int frameCountWhenCameraIsStatic;

	private void Start()
	{
		if (UseRealTime)
		{
			Initialize();
			return;
		}
		fpsMove = new WaitForSeconds(1f / (float)FPSWhenMoveCamera);
		fpsStatic = new WaitForSeconds(1f / (float)FPSWhenStaticCamera);
		canUpdateCamera = true;
		if (FPSWhenMoveCamera > 0)
		{
			StartCoroutine(RepeatCameraMove());
		}
		if (FPSWhenStaticCamera > 0)
		{
			StartCoroutine(RepeatCameraStatic());
		}
		Initialize();
	}

	private void Update()
	{
		if (UseRealTime || cameraInstance == null)
		{
			return;
		}
		if (Vector3.SqrMagnitude(instanceCameraTransform.position - oldPosition) <= 1E-05f && instanceCameraTransform.rotation == oldRotation)
		{
			frameCountWhenCameraIsStatic++;
			if (frameCountWhenCameraIsStatic >= 50)
			{
				isStaticUpdate = true;
			}
		}
		else
		{
			frameCountWhenCameraIsStatic = 0;
			isStaticUpdate = false;
		}
		oldPosition = instanceCameraTransform.position;
		oldRotation = instanceCameraTransform.rotation;
		if (canUpdateCamera)
		{
			if (!cameraInstance.enabled)
			{
				cameraInstance.enabled = true;
			}
			if (FPSWhenMoveCamera > 0)
			{
				canUpdateCamera = false;
			}
		}
		else if (cameraInstance.enabled)
		{
			cameraInstance.enabled = false;
		}
	}

	private IEnumerator RepeatCameraMove()
	{
		while (true)
		{
			if (!isStaticUpdate)
			{
				canUpdateCamera = true;
			}
			yield return fpsMove;
		}
	}

	private IEnumerator RepeatCameraStatic()
	{
		while (true)
		{
			if (isStaticUpdate)
			{
				canUpdateCamera = true;
			}
			yield return fpsStatic;
		}
	}

	private void OnBecameVisible()
	{
		if (goCamera != null)
		{
			goCamera.SetActive(value: true);
		}
	}

	private void OnBecameInvisible()
	{
		if (goCamera != null)
		{
			goCamera.SetActive(value: false);
		}
	}

	private void Initialize()
	{
		goCamera = new GameObject("RenderTextureCamera");
		cameraInstance = goCamera.AddComponent<Camera>();
		Camera main = Camera.main;
		cameraInstance.CopyFrom(main);
		cameraInstance.depth++;
		cameraInstance.cullingMask = CullingMask;
		cameraInstance.renderingPath = RenderingPath;
		goCamera.transform.parent = main.transform;
		renderTexture = new RenderTexture(Mathf.RoundToInt((float)Screen.width * TextureScale), Mathf.RoundToInt((float)Screen.height * TextureScale), 16, RenderTextureFormat);
		renderTexture.DiscardContents();
		renderTexture.filterMode = FilterMode;
		cameraInstance.targetTexture = renderTexture;
		instanceCameraTransform = cameraInstance.transform;
		oldPosition = instanceCameraTransform.position;
		Shader.SetGlobalTexture("_GrabTextureMobile", renderTexture);
	}

	private void OnDisable()
	{
		if ((bool)goCamera)
		{
			UnityEngine.Object.DestroyImmediate(goCamera);
			goCamera = null;
		}
		if ((bool)renderTexture)
		{
			UnityEngine.Object.DestroyImmediate(renderTexture);
			renderTexture = null;
		}
	}
}
public class EffectSettings : MonoBehaviour
{
	public enum EffectTypeEnum
	{
		Projectile,
		AOE,
		Other
	}

	public enum DeactivationEnum
	{
		Deactivate,
		DestroyAfterCollision,
		DestroyAfterTime,
		Nothing
	}

	[UnityEngine.Tooltip("Type of the effect")]
	public EffectTypeEnum EffectType;

	[UnityEngine.Tooltip("The radius of the collider is required to correctly calculate the collision point. For example, if the radius 0.5m, then the position of the collision is shifted on 0.5m relative motion vector.")]
	public float ColliderRadius = 0.2f;

	[UnityEngine.Tooltip("The radius of the \"Area Of Damage (AOE)\"")]
	public float EffectRadius;

	[UnityEngine.Tooltip("Get the position of the movement of the motion vector, and not to follow to the target.")]
	public bool UseMoveVector;

	[UnityEngine.Tooltip("A projectile will be moved to the target (any object)")]
	public GameObject Target;

	[UnityEngine.Tooltip("Motion vector for the projectile (eg Vector3.Forward)")]
	public Vector3 MoveVector = Vector3.forward;

	[UnityEngine.Tooltip("The speed of the projectile")]
	public float MoveSpeed = 1f;

	[UnityEngine.Tooltip("Should the projectile have move to the target, until the target not reaches?")]
	public bool IsHomingMove;

	[UnityEngine.Tooltip("Distance flight of the projectile, after which the projectile is deactivated and call a collision event with a null value \"RaycastHit\"")]
	public float MoveDistance = 20f;

	[UnityEngine.Tooltip("Allows you to smoothly activate / deactivate effects which have an indefinite lifetime")]
	public bool IsVisible = true;

	[UnityEngine.Tooltip("Whether to deactivate or destroy the effect after a collision. Deactivation allows you to reuse the effect without instantiating, using \"effect.SetActive (true)\"")]
	public DeactivationEnum InstanceBehaviour = DeactivationEnum.Nothing;

	[UnityEngine.Tooltip("Delay before deactivating effect. (For example, after effect, some particles must have time to disappear).")]
	public float DeactivateTimeDelay = 4f;

	[UnityEngine.Tooltip("Delay before deleting effect. (For example, after effect, some particles must have time to disappear).")]
	public float DestroyTimeDelay = 10f;

	[UnityEngine.Tooltip("Allows you to adjust the layers, which can interact with the projectile.")]
	public LayerMask LayerMask = -1;

	private GameObject[] active_key = new GameObject[100];

	private float[] active_value = new float[100];

	private GameObject[] inactive_Key = new GameObject[100];

	private float[] inactive_value = new float[100];

	private int lastActiveIndex;

	private int lastInactiveIndex;

	private int currentActiveGo;

	private int currentInactiveGo;

	private bool deactivatedIsWait;

	public event EventHandler<CollisionInfo> CollisionEnter;

	public event EventHandler<EventArgs> EffectDeactivated;

	private void Start()
	{
		if (InstanceBehaviour == DeactivationEnum.DestroyAfterTime)
		{
			UnityEngine.Object.Destroy(base.gameObject, DestroyTimeDelay);
		}
	}

	public void OnCollisionHandler(CollisionInfo e)
	{
		for (int i = 0; i < lastActiveIndex; i++)
		{
			Invoke("SetGoActive", active_value[i]);
		}
		for (int j = 0; j < lastInactiveIndex; j++)
		{
			Invoke("SetGoInactive", inactive_value[j]);
		}
		this.CollisionEnter?.Invoke(this, e);
		if (InstanceBehaviour == DeactivationEnum.Deactivate && !deactivatedIsWait)
		{
			deactivatedIsWait = true;
			Invoke("Deactivate", DeactivateTimeDelay);
		}
		if (InstanceBehaviour == DeactivationEnum.DestroyAfterCollision)
		{
			UnityEngine.Object.Destroy(base.gameObject, DestroyTimeDelay);
		}
	}

	public void OnEffectDeactivatedHandler()
	{
		this.EffectDeactivated?.Invoke(this, EventArgs.Empty);
	}

	public void Deactivate()
	{
		OnEffectDeactivatedHandler();
		base.gameObject.SetActive(value: false);
	}

	private void SetGoActive()
	{
		active_key[currentActiveGo].SetActive(value: false);
		currentActiveGo++;
		if (currentActiveGo >= lastActiveIndex)
		{
			currentActiveGo = 0;
		}
	}

	private void SetGoInactive()
	{
		inactive_Key[currentInactiveGo].SetActive(value: true);
		currentInactiveGo++;
		if (currentInactiveGo >= lastInactiveIndex)
		{
			currentInactiveGo = 0;
		}
	}

	public void OnEnable()
	{
		for (int i = 0; i < lastActiveIndex; i++)
		{
			active_key[i].SetActive(value: true);
		}
		for (int j = 0; j < lastInactiveIndex; j++)
		{
			inactive_Key[j].SetActive(value: false);
		}
		deactivatedIsWait = false;
	}

	public void OnDisable()
	{
		CancelInvoke("SetGoActive");
		CancelInvoke("SetGoInactive");
		CancelInvoke("Deactivate");
		currentActiveGo = 0;
		currentInactiveGo = 0;
	}

	public void RegistreActiveElement(GameObject go, float time)
	{
		active_key[lastActiveIndex] = go;
		active_value[lastActiveIndex] = time;
		lastActiveIndex++;
	}

	public void RegistreInactiveElement(GameObject go, float time)
	{
		inactive_Key[lastInactiveIndex] = go;
		inactive_value[lastInactiveIndex] = time;
		lastInactiveIndex++;
	}
}
public class CollisionInfo : EventArgs
{
	public RaycastHit Hit;
}
public class EffectsColorizer : MonoBehaviour
{
	public struct HSBColor
	{
		public float h;

		public float s;

		public float b;

		public float a;

		public HSBColor(float h, float s, float b, float a)
		{
			this.h = h;
			this.s = s;
			this.b = b;
			this.a = a;
		}
	}

	public Color TintColor;

	public bool UseInstanceWhenNotEditorMode = true;

	private Color oldColor;

	private void Start()
	{
	}

	private void Update()
	{
		if (oldColor != TintColor)
		{
			ChangeColor(base.gameObject, TintColor);
		}
		oldColor = TintColor;
	}

	private void ChangeColor(GameObject effect, Color color)
	{
		Renderer[] componentsInChildren = effect.GetComponentsInChildren<Renderer>();
		foreach (Renderer renderer in componentsInChildren)
		{
			Material material = ((!UseInstanceWhenNotEditorMode) ? renderer.sharedMaterial : renderer.material);
			HSBColor hSBColor = ColorToHSV(TintColor);
			if (material == null)
			{
				continue;
			}
			if (material.HasProperty("_TintColor"))
			{
				Color color2 = material.GetColor("_TintColor");
				HSBColor hsbColor = ColorToHSV(color2);
				hsbColor.h = hSBColor.h / 360f;
				color = HSVToColor(hsbColor);
				material.SetColor("_TintColor", color);
			}
			if (material.HasProperty("_CoreColor"))
			{
				Color color3 = material.GetColor("_CoreColor");
				HSBColor hsbColor2 = ColorToHSV(color3);
				hsbColor2.h = hSBColor.h / 360f;
				color = HSVToColor(hsbColor2);
				material.SetColor("_CoreColor", color);
			}
			Projector[] componentsInChildren2 = effect.GetComponentsInChildren<Projector>();
			foreach (Projector projector in componentsInChildren2)
			{
				material = projector.material;
				if (!(material == null) && material.HasProperty("_TintColor"))
				{
					Color color4 = material.GetColor("_TintColor");
					HSBColor hsbColor3 = ColorToHSV(color4);
					hsbColor3.h = hSBColor.h / 360f;
					color = HSVToColor(hsbColor3);
					projector.material.SetColor("_TintColor", color);
				}
			}
		}
		Light componentInChildren = effect.GetComponentInChildren<Light>();
		if (componentInChildren != null)
		{
			componentInChildren.color = color;
		}
	}

	public HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (g == num)
			{
				result.h = (b - r) / num3 * 60f + 120f;
			}
			else if (b == num)
			{
				result.h = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.h = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.h = (g - b) / num3 * 60f;
			}
			if (result.h < 0f)
			{
				result.h += 360f;
			}
		}
		else
		{
			result.h = 0f;
		}
		result.h *= 0.0027777778f;
		result.s = num3 / num * 1f;
		result.b = num;
		return result;
	}

	public Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.b;
		float value2 = hsbColor.b;
		float value3 = hsbColor.b;
		if (hsbColor.s != 0f)
		{
			float b = hsbColor.b;
			float num = hsbColor.b * hsbColor.s;
			float num2 = hsbColor.b - num;
			float num3 = hsbColor.h * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.a);
	}
}
[ExecuteInEditMode]
public class EffectsParticleSystemScaler : MonoBehaviour
{
	public float particlesScale = 1f;

	private float oldScale;

	private void Start()
	{
		oldScale = particlesScale;
	}

	private void Update()
	{
	}
}
public class FadeInOutLight : MonoBehaviour
{
	public float StartDelay;

	public float FadeInSpeed;

	public float FadeOutDelay;

	public float FadeOutSpeed;

	public bool FadeOutAfterCollision;

	public bool UseHideStatus;

	private Light goLight;

	private float oldIntensity;

	private float currentIntensity;

	private float startIntensity;

	private bool canStart;

	private bool canStartFadeOut;

	private bool fadeInComplited;

	private bool fadeOutComplited;

	private bool isCollisionEnter;

	private bool allComplited;

	private bool isStartDelay;

	private bool isIn;

	private bool isOut;

	private EffectSettings effectSettings;

	private bool isInitialized;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (effectSettings != null)
		{
			effectSettings.CollisionEnter += prefabSettings_CollisionEnter;
		}
		goLight = GetComponent<Light>();
		startIntensity = goLight.intensity;
		isStartDelay = StartDelay > 0.001f;
		isIn = FadeInSpeed > 0.001f;
		isOut = FadeOutSpeed > 0.001f;
		InitDefaultVariables();
		isInitialized = true;
	}

	private void InitDefaultVariables()
	{
		fadeInComplited = false;
		fadeOutComplited = false;
		allComplited = false;
		canStartFadeOut = false;
		isCollisionEnter = false;
		oldIntensity = 0f;
		currentIntensity = 0f;
		canStart = false;
		goLight.intensity = (isIn ? 0f : startIntensity);
		if (isStartDelay)
		{
			Invoke("SetupStartDelay", StartDelay);
		}
		else
		{
			canStart = true;
		}
		if (!isIn)
		{
			if (!FadeOutAfterCollision)
			{
				Invoke("SetupFadeOutDelay", FadeOutDelay);
			}
			oldIntensity = startIntensity;
		}
	}

	private void prefabSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		isCollisionEnter = true;
		if (!isIn && FadeOutAfterCollision)
		{
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void SetupStartDelay()
	{
		canStart = true;
	}

	private void SetupFadeOutDelay()
	{
		canStartFadeOut = true;
	}

	private void Update()
	{
		if (!canStart)
		{
			return;
		}
		if (effectSettings != null && UseHideStatus && allComplited && effectSettings.IsVisible)
		{
			allComplited = false;
			fadeInComplited = false;
			fadeOutComplited = false;
			InitDefaultVariables();
		}
		if (isIn && !fadeInComplited)
		{
			if (effectSettings == null)
			{
				FadeIn();
			}
			else if ((UseHideStatus && effectSettings.IsVisible) || !UseHideStatus)
			{
				FadeIn();
			}
		}
		if (isOut && !fadeOutComplited && canStartFadeOut)
		{
			if (effectSettings == null || (!UseHideStatus && !FadeOutAfterCollision))
			{
				FadeOut();
			}
			else if ((UseHideStatus && !effectSettings.IsVisible) || (FadeOutAfterCollision && isCollisionEnter))
			{
				FadeOut();
			}
		}
	}

	private void FadeIn()
	{
		currentIntensity = oldIntensity + Time.deltaTime / FadeInSpeed * startIntensity;
		if (currentIntensity >= startIntensity)
		{
			fadeInComplited = true;
			if (!isOut)
			{
				allComplited = true;
			}
			currentIntensity = startIntensity;
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
		goLight.intensity = currentIntensity;
		oldIntensity = currentIntensity;
	}

	private void FadeOut()
	{
		currentIntensity = oldIntensity - Time.deltaTime / FadeOutSpeed * startIntensity;
		if (currentIntensity <= 0f)
		{
			currentIntensity = 0f;
			fadeOutComplited = true;
			allComplited = true;
		}
		goLight.intensity = currentIntensity;
		oldIntensity = currentIntensity;
	}
}
public class FadeInOutParticles : MonoBehaviour
{
	private EffectSettings effectSettings;

	private ParticleSystem[] particles;

	private bool oldVisibleStat;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		particles = effectSettings.GetComponentsInChildren<ParticleSystem>();
		oldVisibleStat = effectSettings.IsVisible;
	}

	private void Update()
	{
		if (effectSettings.IsVisible != oldVisibleStat)
		{
			if (effectSettings.IsVisible)
			{
				ParticleSystem[] array = particles;
				foreach (ParticleSystem particleSystem in array)
				{
					if (effectSettings.IsVisible)
					{
						particleSystem.Play();
						particleSystem.enableEmission = true;
					}
				}
			}
			else
			{
				ParticleSystem[] array = particles;
				foreach (ParticleSystem particleSystem2 in array)
				{
					if (!effectSettings.IsVisible)
					{
						particleSystem2.Stop();
						particleSystem2.enableEmission = false;
					}
				}
			}
		}
		oldVisibleStat = effectSettings.IsVisible;
	}
}
public class FadeInOutScale : MonoBehaviour
{
	public FadeInOutStatus FadeInOutStatus;

	public float Speed = 1f;

	public float MaxScale = 2f;

	private Vector3 oldScale;

	private float time;

	private float oldSin;

	private bool updateTime = true;

	private bool canUpdate = true;

	private Transform t;

	private EffectSettings effectSettings;

	private bool isInitialized;

	private bool isCollisionEnter;

	private void Start()
	{
		t = base.transform;
		oldScale = t.localScale;
		isInitialized = true;
		GetEffectSettingsComponent(base.transform);
		if (effectSettings != null)
		{
			effectSettings.CollisionEnter += prefabSettings_CollisionEnter;
		}
	}

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	public void InitDefaultVariables()
	{
		if (FadeInOutStatus == FadeInOutStatus.OutAfterCollision)
		{
			t.localScale = oldScale;
			canUpdate = false;
		}
		else
		{
			t.localScale = Vector3.zero;
			canUpdate = true;
		}
		updateTime = true;
		time = 0f;
		oldSin = 0f;
		isCollisionEnter = false;
	}

	private void prefabSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		isCollisionEnter = true;
		canUpdate = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Update()
	{
		if (!canUpdate)
		{
			return;
		}
		if (updateTime)
		{
			time = Time.time;
			updateTime = false;
		}
		float num = Mathf.Sin((Time.time - time) / Speed);
		float num2;
		if (oldSin > num)
		{
			canUpdate = false;
			num2 = MaxScale;
		}
		else
		{
			num2 = num * MaxScale;
		}
		if (FadeInOutStatus == FadeInOutStatus.In)
		{
			if (num2 < MaxScale)
			{
				t.localScale = new Vector3(oldScale.x * num2, oldScale.y * num2, oldScale.z * num2);
			}
			else
			{
				t.localScale = new Vector3(MaxScale, MaxScale, MaxScale);
			}
		}
		if (FadeInOutStatus == FadeInOutStatus.Out)
		{
			if (num2 > 0f)
			{
				t.localScale = new Vector3(MaxScale * oldScale.x - oldScale.x * num2, MaxScale * oldScale.y - oldScale.y * num2, MaxScale * oldScale.z - oldScale.z * num2);
			}
			else
			{
				t.localScale = Vector3.zero;
			}
		}
		if (FadeInOutStatus == FadeInOutStatus.OutAfterCollision && isCollisionEnter)
		{
			if (num2 > 0f)
			{
				t.localScale = new Vector3(MaxScale * oldScale.x - oldScale.x * num2, MaxScale * oldScale.y - oldScale.y * num2, MaxScale * oldScale.z - oldScale.z * num2);
			}
			else
			{
				t.localScale = Vector3.zero;
			}
		}
		oldSin = num;
	}
}
public class FadeInOutShaderColor : MonoBehaviour
{
	public string ShaderColorName = "_Color";

	public float StartDelay;

	public float FadeInSpeed;

	public float FadeOutDelay;

	public float FadeOutSpeed;

	public bool UseSharedMaterial;

	public bool FadeOutAfterCollision;

	public bool UseHideStatus;

	private Material mat;

	private Color oldColor;

	private Color currentColor;

	private float oldAlpha;

	private float alpha;

	private bool canStart;

	private bool canStartFadeOut;

	private bool fadeInComplited;

	private bool fadeOutComplited;

	private bool isCollisionEnter;

	private bool isStartDelay;

	private bool isIn;

	private bool isOut;

	private EffectSettings effectSettings;

	private bool isInitialized;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	public void UpdateMaterial(Material instanceMaterial)
	{
		mat = instanceMaterial;
		InitMaterial();
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (effectSettings != null)
		{
			effectSettings.CollisionEnter += prefabSettings_CollisionEnter;
		}
		InitMaterial();
	}

	private void InitMaterial()
	{
		if (isInitialized)
		{
			return;
		}
		if (GetComponent<Renderer>() != null)
		{
			mat = GetComponent<Renderer>().material;
		}
		else
		{
			LineRenderer component = GetComponent<LineRenderer>();
			if (component != null)
			{
				mat = component.material;
			}
			else
			{
				Projector component2 = GetComponent<Projector>();
				if (component2 != null)
				{
					if (!component2.material.name.EndsWith("(Instance)"))
					{
						component2.material = new Material(component2.material)
						{
							name = component2.material.name + " (Instance)"
						};
					}
					mat = component2.material;
				}
			}
		}
		if (!(mat == null))
		{
			oldColor = mat.GetColor(ShaderColorName);
			isStartDelay = StartDelay > 0.001f;
			isIn = FadeInSpeed > 0.001f;
			isOut = FadeOutSpeed > 0.001f;
			InitDefaultVariables();
			isInitialized = true;
		}
	}

	private void InitDefaultVariables()
	{
		fadeInComplited = false;
		fadeOutComplited = false;
		canStartFadeOut = false;
		isCollisionEnter = false;
		oldAlpha = 0f;
		alpha = 0f;
		canStart = false;
		currentColor = oldColor;
		if (isIn)
		{
			currentColor.a = 0f;
		}
		mat.SetColor(ShaderColorName, currentColor);
		if (isStartDelay)
		{
			Invoke("SetupStartDelay", StartDelay);
		}
		else
		{
			canStart = true;
		}
		if (!isIn)
		{
			if (!FadeOutAfterCollision)
			{
				Invoke("SetupFadeOutDelay", FadeOutDelay);
			}
			oldAlpha = oldColor.a;
		}
	}

	private void prefabSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		isCollisionEnter = true;
		if (!isIn && FadeOutAfterCollision)
		{
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void SetupStartDelay()
	{
		canStart = true;
	}

	private void SetupFadeOutDelay()
	{
		canStartFadeOut = true;
	}

	private void Update()
	{
		if (!canStart)
		{
			return;
		}
		if (effectSettings != null && UseHideStatus)
		{
			if (!effectSettings.IsVisible && fadeInComplited)
			{
				fadeInComplited = false;
			}
			if (effectSettings.IsVisible && fadeOutComplited)
			{
				fadeOutComplited = false;
			}
		}
		if (UseHideStatus)
		{
			if (isIn && effectSettings != null && effectSettings.IsVisible && !fadeInComplited)
			{
				FadeIn();
			}
			if (isOut && effectSettings != null && !effectSettings.IsVisible && !fadeOutComplited)
			{
				FadeOut();
			}
		}
		else if (!FadeOutAfterCollision)
		{
			if (isIn && !fadeInComplited)
			{
				FadeIn();
			}
			if (isOut && canStartFadeOut && !fadeOutComplited)
			{
				FadeOut();
			}
		}
		else
		{
			if (isIn && !fadeInComplited)
			{
				FadeIn();
			}
			if (isOut && isCollisionEnter && canStartFadeOut && !fadeOutComplited)
			{
				FadeOut();
			}
		}
	}

	private void FadeIn()
	{
		alpha = oldAlpha + Time.deltaTime / FadeInSpeed;
		if (alpha >= oldColor.a)
		{
			fadeInComplited = true;
			alpha = oldColor.a;
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
		currentColor.a = alpha;
		mat.SetColor(ShaderColorName, currentColor);
		oldAlpha = alpha;
	}

	private void FadeOut()
	{
		alpha = oldAlpha - Time.deltaTime / FadeOutSpeed;
		if (alpha <= 0f)
		{
			alpha = 0f;
			fadeOutComplited = true;
		}
		currentColor.a = alpha;
		mat.SetColor(ShaderColorName, currentColor);
		oldAlpha = alpha;
	}
}
public class FadeInOutShaderFloat : MonoBehaviour
{
	public string PropertyName = "_CutOut";

	public float MaxFloat = 1f;

	public float StartDelay;

	public float FadeInSpeed;

	public float FadeOutDelay;

	public float FadeOutSpeed;

	public bool FadeOutAfterCollision;

	public bool UseHideStatus;

	private Material OwnMaterial;

	private Material mat;

	private float oldFloat;

	private float currentFloat;

	private bool canStart;

	private bool canStartFadeOut;

	private bool fadeInComplited;

	private bool fadeOutComplited;

	private bool previousFrameVisibleStatus;

	private bool isCollisionEnter;

	private bool isStartDelay;

	private bool isIn;

	private bool isOut;

	private EffectSettings effectSettings;

	private bool isInitialized;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (effectSettings != null)
		{
			effectSettings.CollisionEnter += prefabSettings_CollisionEnter;
		}
		InitMaterial();
	}

	public void UpdateMaterial(Material instanceMaterial)
	{
		mat = instanceMaterial;
		InitMaterial();
	}

	private void InitMaterial()
	{
		if (isInitialized)
		{
			return;
		}
		if (GetComponent<Renderer>() != null)
		{
			mat = GetComponent<Renderer>().material;
		}
		else
		{
			LineRenderer component = GetComponent<LineRenderer>();
			if (component != null)
			{
				mat = component.material;
			}
			else
			{
				Projector component2 = GetComponent<Projector>();
				if (component2 != null)
				{
					if (!component2.material.name.EndsWith("(Instance)"))
					{
						component2.material = new Material(component2.material)
						{
							name = component2.material.name + " (Instance)"
						};
					}
					mat = component2.material;
				}
			}
		}
		if (!(mat == null))
		{
			isStartDelay = StartDelay > 0.001f;
			isIn = FadeInSpeed > 0.001f;
			isOut = FadeOutSpeed > 0.001f;
			InitDefaultVariables();
			isInitialized = true;
		}
	}

	private void InitDefaultVariables()
	{
		fadeInComplited = false;
		fadeOutComplited = false;
		canStartFadeOut = false;
		canStart = false;
		isCollisionEnter = false;
		oldFloat = 0f;
		currentFloat = MaxFloat;
		if (isIn)
		{
			currentFloat = 0f;
		}
		mat.SetFloat(PropertyName, currentFloat);
		if (isStartDelay)
		{
			Invoke("SetupStartDelay", StartDelay);
		}
		else
		{
			canStart = true;
		}
		if (!isIn)
		{
			if (!FadeOutAfterCollision)
			{
				Invoke("SetupFadeOutDelay", FadeOutDelay);
			}
			oldFloat = MaxFloat;
		}
	}

	private void prefabSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		isCollisionEnter = true;
		if (!isIn && FadeOutAfterCollision)
		{
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void SetupStartDelay()
	{
		canStart = true;
	}

	private void SetupFadeOutDelay()
	{
		canStartFadeOut = true;
	}

	private void Update()
	{
		if (!canStart)
		{
			return;
		}
		if (effectSettings != null && UseHideStatus)
		{
			if (!effectSettings.IsVisible && fadeInComplited)
			{
				fadeInComplited = false;
			}
			if (effectSettings.IsVisible && fadeOutComplited)
			{
				fadeOutComplited = false;
			}
		}
		if (UseHideStatus)
		{
			if (isIn && effectSettings != null && effectSettings.IsVisible && !fadeInComplited)
			{
				FadeIn();
			}
			if (isOut && effectSettings != null && !effectSettings.IsVisible && !fadeOutComplited)
			{
				FadeOut();
			}
		}
		else if (!FadeOutAfterCollision)
		{
			if (isIn && !fadeInComplited)
			{
				FadeIn();
			}
			if (isOut && canStartFadeOut && !fadeOutComplited)
			{
				FadeOut();
			}
		}
		else
		{
			if (isIn && !fadeInComplited)
			{
				FadeIn();
			}
			if (isOut && isCollisionEnter && canStartFadeOut && !fadeOutComplited)
			{
				FadeOut();
			}
		}
	}

	private void FadeIn()
	{
		currentFloat = oldFloat + Time.deltaTime / FadeInSpeed * MaxFloat;
		if (currentFloat >= MaxFloat)
		{
			fadeInComplited = true;
			currentFloat = MaxFloat;
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
		mat.SetFloat(PropertyName, currentFloat);
		oldFloat = currentFloat;
	}

	private void FadeOut()
	{
		currentFloat = oldFloat - Time.deltaTime / FadeOutSpeed * MaxFloat;
		if (currentFloat <= 0f)
		{
			currentFloat = 0f;
			fadeOutComplited = true;
		}
		mat.SetFloat(PropertyName, currentFloat);
		oldFloat = currentFloat;
	}
}
public class FadeInOutSound : MonoBehaviour
{
	public float MaxVolume = 1f;

	public float StartDelay;

	public float FadeInSpeed;

	public float FadeOutDelay;

	public float FadeOutSpeed;

	public bool FadeOutAfterCollision;

	public bool UseHideStatus;

	private AudioSource audioSource;

	private float oldVolume;

	private float currentVolume;

	private bool canStart;

	private bool canStartFadeOut;

	private bool fadeInComplited;

	private bool fadeOutComplited;

	private bool isCollisionEnter;

	private bool allComplited;

	private bool isStartDelay;

	private bool isIn;

	private bool isOut;

	private EffectSettings effectSettings;

	private bool isInitialized;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (effectSettings != null)
		{
			effectSettings.CollisionEnter += prefabSettings_CollisionEnter;
		}
		InitSource();
	}

	private void InitSource()
	{
		if (!isInitialized)
		{
			audioSource = GetComponent<AudioSource>();
			if (!(audioSource == null))
			{
				isStartDelay = StartDelay > 0.001f;
				isIn = FadeInSpeed > 0.001f;
				isOut = FadeOutSpeed > 0.001f;
				InitDefaultVariables();
				isInitialized = true;
			}
		}
	}

	private void InitDefaultVariables()
	{
		fadeInComplited = false;
		fadeOutComplited = false;
		allComplited = false;
		canStartFadeOut = false;
		isCollisionEnter = false;
		oldVolume = 0f;
		currentVolume = MaxVolume;
		if (isIn)
		{
			currentVolume = 0f;
		}
		audioSource.volume = currentVolume;
		if (isStartDelay)
		{
			Invoke("SetupStartDelay", StartDelay);
		}
		else
		{
			canStart = true;
		}
		if (!isIn)
		{
			if (!FadeOutAfterCollision)
			{
				Invoke("SetupFadeOutDelay", FadeOutDelay);
			}
			oldVolume = MaxVolume;
		}
	}

	private void prefabSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		isCollisionEnter = true;
		if (!isIn && FadeOutAfterCollision)
		{
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void SetupStartDelay()
	{
		canStart = true;
	}

	private void SetupFadeOutDelay()
	{
		canStartFadeOut = true;
	}

	private void Update()
	{
		if (!canStart || audioSource == null)
		{
			return;
		}
		if (effectSettings != null && UseHideStatus && allComplited && effectSettings.IsVisible)
		{
			allComplited = false;
			fadeInComplited = false;
			fadeOutComplited = false;
			InitDefaultVariables();
		}
		if (isIn && !fadeInComplited)
		{
			if (effectSettings == null)
			{
				FadeIn();
			}
			else if ((UseHideStatus && effectSettings.IsVisible) || !UseHideStatus)
			{
				FadeIn();
			}
		}
		if (isOut && !fadeOutComplited && canStartFadeOut)
		{
			if (effectSettings == null || (!UseHideStatus && !FadeOutAfterCollision))
			{
				FadeOut();
			}
			else if ((UseHideStatus && !effectSettings.IsVisible) || isCollisionEnter)
			{
				FadeOut();
			}
		}
	}

	private void FadeIn()
	{
		currentVolume = oldVolume + Time.deltaTime / FadeInSpeed * MaxVolume;
		if (currentVolume >= MaxVolume)
		{
			fadeInComplited = true;
			if (!isOut)
			{
				allComplited = true;
			}
			currentVolume = MaxVolume;
			Invoke("SetupFadeOutDelay", FadeOutDelay);
		}
		audioSource.volume = currentVolume;
		oldVolume = currentVolume;
	}

	private void FadeOut()
	{
		currentVolume = oldVolume - Time.deltaTime / FadeOutSpeed * MaxVolume;
		if (currentVolume <= 0f)
		{
			currentVolume = 0f;
			fadeOutComplited = true;
			allComplited = true;
		}
		audioSource.volume = currentVolume;
		oldVolume = currentVolume;
	}
}
public enum FadeInOutStatus
{
	In,
	Out,
	InOut,
	In_OutAfterCollision,
	InAfterCollision,
	OutAfterCollision,
	InOutAfterCollision
}
public class FixShaderQueue : MonoBehaviour
{
	public int AddQueue = 1;

	private Renderer rend;

	private void Start()
	{
		rend = GetComponent<Renderer>();
		if (rend != null)
		{
			rend.sharedMaterial.renderQueue += AddQueue;
		}
		else
		{
			Invoke("SetProjectorQueue", 0.1f);
		}
	}

	private void SetProjectorQueue()
	{
		GetComponent<Projector>().material.renderQueue += AddQueue;
	}

	private void OnDisable()
	{
		if (rend != null)
		{
			rend.sharedMaterial.renderQueue = -1;
		}
	}
}
public class OnStartSendCollision : MonoBehaviour
{
	private EffectSettings effectSettings;

	private bool isInitialized;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		effectSettings.OnCollisionHandler(new CollisionInfo());
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			effectSettings.OnCollisionHandler(new CollisionInfo());
		}
	}
}
public class RotateAround : MonoBehaviour
{
	public float Speed = 1f;

	public float LifeTime = 1f;

	public float TimeDelay;

	public float SpeedFadeInTime;

	public bool UseCollision;

	public EffectSettings EffectSettings;

	private bool canUpdate;

	private float currentSpeedFadeIn;

	private float allTime;

	private void Start()
	{
		if (UseCollision)
		{
			EffectSettings.CollisionEnter += EffectSettings_CollisionEnter;
		}
		if (TimeDelay > 0f)
		{
			Invoke("ChangeUpdate", TimeDelay);
		}
		else
		{
			canUpdate = true;
		}
	}

	private void OnEnable()
	{
		canUpdate = true;
		allTime = 0f;
	}

	private void EffectSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		canUpdate = false;
	}

	private void ChangeUpdate()
	{
		canUpdate = true;
	}

	private void Update()
	{
		if (!canUpdate)
		{
			return;
		}
		allTime += Time.deltaTime;
		if (allTime >= LifeTime && LifeTime > 0.0001f)
		{
			return;
		}
		if (SpeedFadeInTime > 0.001f)
		{
			if (currentSpeedFadeIn < Speed)
			{
				currentSpeedFadeIn += Time.deltaTime / SpeedFadeInTime * Speed;
			}
			else
			{
				currentSpeedFadeIn = Speed;
			}
		}
		else
		{
			currentSpeedFadeIn = Speed;
		}
		base.transform.Rotate(Vector3.forward * Time.deltaTime * currentSpeedFadeIn);
	}
}
public class SetPositionOnHit : MonoBehaviour
{
	public float OffsetPosition;

	private EffectSettings effectSettings;

	private Transform tRoot;

	private bool isInitialized;

	private void GetEffectSettingsComponent(Transform tr)
	{
		Transform parent = tr.parent;
		if (parent != null)
		{
			effectSettings = parent.GetComponentInChildren<EffectSettings>();
			if (effectSettings == null)
			{
				GetEffectSettingsComponent(parent.transform);
			}
		}
	}

	private void Start()
	{
		GetEffectSettingsComponent(base.transform);
		if (effectSettings == null)
		{
			UnityEngine.Debug.Log("Prefab root or children have not script \"PrefabSettings\"");
		}
		tRoot = effectSettings.transform;
	}

	private void effectSettings_CollisionEnter(object sender, CollisionInfo e)
	{
		Vector3 normalized = (tRoot.position + Vector3.Normalize(e.Hit.point - tRoot.position) * (effectSettings.MoveDistance + 1f)).normalized;
		base.transform.position = e.Hit.point - normalized * OffsetPosition;
	}

	private void Update()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			effectSettings.CollisionEnter += effectSettings_CollisionEnter;
		}
	}

	private void OnDisable()
	{
		base.transform.position = Vector3.zero;
	}
}
internal class UVTextureAnimator : MonoBehaviour
{
	public Material[] AnimatedMaterialsNotInstance;

	public int Rows = 4;

	public int Columns = 4;

	public float Fps = 20f;

	public int OffsetMat;

	public Vector2 SelfTiling;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsRandomOffsetForInctance;

	public bool IsBump;

	public bool IsHeight;

	public bool IsCutOut;

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float deltaFps;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private void Start()
	{
		InitMaterial();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		StartCoroutine(UpdateCorutine());
	}

	public void SetInstanceMaterial(Material mat, Vector2 offsetMat)
	{
		instanceMaterial = mat;
		InitDefaultVariables();
	}

	private void InitDefaultVariables()
	{
		allCount = 0;
		deltaFps = 1f / Fps;
		count = Rows * Columns;
		index = Columns - 1;
		Vector2 value = new Vector2((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		OffsetMat = ((!IsRandomOffsetForInctance) ? (OffsetMat - OffsetMat / count * count) : UnityEngine.Random.Range(0, count));
		Vector2 value2 = ((SelfTiling == Vector2.zero) ? new Vector2(1f / (float)Columns, 1f / (float)Rows) : SelfTiling);
		if (AnimatedMaterialsNotInstance.Length != 0)
		{
			Material[] animatedMaterialsNotInstance = AnimatedMaterialsNotInstance;
			foreach (Material material in animatedMaterialsNotInstance)
			{
				material.SetTextureScale("_MainTex", value2);
				material.SetTextureOffset("_MainTex", Vector2.zero);
				if (IsBump)
				{
					material.SetTextureScale("_BumpMap", value2);
					material.SetTextureOffset("_BumpMap", Vector2.zero);
				}
				if (IsHeight)
				{
					material.SetTextureScale("_HeightMap", value2);
					material.SetTextureOffset("_HeightMap", Vector2.zero);
				}
				if (IsCutOut)
				{
					material.SetTextureScale("_CutOut", value2);
					material.SetTextureOffset("_CutOut", Vector2.zero);
				}
			}
		}
		else if (instanceMaterial != null)
		{
			instanceMaterial.SetTextureScale("_MainTex", value2);
			instanceMaterial.SetTextureOffset("_MainTex", value);
			if (IsBump)
			{
				instanceMaterial.SetTextureScale("_BumpMap", value2);
				instanceMaterial.SetTextureOffset("_BumpMap", value);
			}
			if (IsBump)
			{
				instanceMaterial.SetTextureScale("_HeightMap", value2);
				instanceMaterial.SetTextureOffset("_HeightMap", value);
			}
			if (IsCutOut)
			{
				instanceMaterial.SetTextureScale("_CutOut", value2);
				instanceMaterial.SetTextureOffset("_CutOut", value);
			}
		}
		else if (currentRenderer != null)
		{
			currentRenderer.material.SetTextureScale("_MainTex", value2);
			currentRenderer.material.SetTextureOffset("_MainTex", value);
			if (IsBump)
			{
				currentRenderer.material.SetTextureScale("_BumpMap", value2);
				currentRenderer.material.SetTextureOffset("_BumpMap", value);
			}
			if (IsHeight)
			{
				currentRenderer.material.SetTextureScale("_HeightMap", value2);
				currentRenderer.material.SetTextureOffset("_HeightMap", value);
			}
			if (IsCutOut)
			{
				currentRenderer.material.SetTextureScale("_CutOut", value2);
				currentRenderer.material.SetTextureOffset("_CutOut", value);
			}
		}
	}

	private void InitMaterial()
	{
		if (GetComponent<Renderer>() != null)
		{
			currentRenderer = GetComponent<Renderer>();
			return;
		}
		Projector component = GetComponent<Projector>();
		if (component != null)
		{
			if (!component.material.name.EndsWith("(Instance)"))
			{
				component.material = new Material(component.material)
				{
					name = component.material.name + " (Instance)"
				};
			}
			instanceMaterial = component.material;
		}
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			if (!isCorutineStarted)
			{
				StartCoroutine(UpdateCorutine());
			}
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		StopAllCoroutines();
	}

	private void OnBecameVisible()
	{
		isVisible = true;
		if (!isCorutineStarted)
		{
			StartCoroutine(UpdateCorutine());
		}
	}

	private void OnBecameInvisible()
	{
		isVisible = false;
	}

	private IEnumerator UpdateCorutine()
	{
		isCorutineStarted = true;
		while (isVisible && (IsLoop || allCount != count))
		{
			UpdateCorutineFrame();
			if (!IsLoop && allCount == count)
			{
				break;
			}
			yield return new WaitForSeconds(deltaFps);
		}
		isCorutineStarted = false;
	}

	private void UpdateCorutineFrame()
	{
		if (currentRenderer == null && instanceMaterial == null && AnimatedMaterialsNotInstance.Length == 0)
		{
			return;
		}
		allCount++;
		if (IsReverse)
		{
			index--;
		}
		else
		{
			index++;
		}
		if (index >= count)
		{
			index = 0;
		}
		if (AnimatedMaterialsNotInstance.Length != 0)
		{
			for (int i = 0; i < AnimatedMaterialsNotInstance.Length; i++)
			{
				int num = i * OffsetMat + index + OffsetMat;
				num -= num / count * count;
				Vector2 value = new Vector2((float)num / (float)Columns - (float)(num / Columns), 1f - (float)(num / Columns) / (float)Rows);
				AnimatedMaterialsNotInstance[i].SetTextureOffset("_MainTex", value);
				if (IsBump)
				{
					AnimatedMaterialsNotInstance[i].SetTextureOffset("_BumpMap", value);
				}
				if (IsHeight)
				{
					AnimatedMaterialsNotInstance[i].SetTextureOffset("_HeightMap", value);
				}
				if (IsCutOut)
				{
					AnimatedMaterialsNotInstance[i].SetTextureOffset("_CutOut", value);
				}
			}
			return;
		}
		Vector2 value2;
		if (IsRandomOffsetForInctance)
		{
			int num2 = index + OffsetMat;
			value2 = new Vector2((float)num2 / (float)Columns - (float)(num2 / Columns), 1f - (float)(num2 / Columns) / (float)Rows);
		}
		else
		{
			value2 = new Vector2((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		}
		if (instanceMaterial != null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", value2);
			if (IsBump)
			{
				instanceMaterial.SetTextureOffset("_BumpMap", value2);
			}
			if (IsHeight)
			{
				instanceMaterial.SetTextureOffset("_HeightMap", value2);
			}
			if (IsCutOut)
			{
				instanceMaterial.SetTextureOffset("_CutOut", value2);
			}
		}
		else if (currentRenderer != null)
		{
			currentRenderer.material.SetTextureOffset("_MainTex", value2);
			if (IsBump)
			{
				currentRenderer.material.SetTextureOffset("_BumpMap", value2);
			}
			if (IsHeight)
			{
				currentRenderer.material.SetTextureOffset("_HeightMap", value2);
			}
			if (IsCutOut)
			{
				currentRenderer.material.SetTextureOffset("_CutOut", value2);
			}
		}
	}
}
public class AE_AnimatorEvents : MonoBehaviour
{
	[Serializable]
	public class AE_EffectAnimatorProperty
	{
		[HideInInspector]
		public RuntimeAnimatorController TargetAnimation;

		public GameObject Prefab;

		public Transform BonePosition;

		public Transform BoneRotation;

		public float DestroyTime = 10f;

		[HideInInspector]
		public GameObject CurrentInstance;
	}

	public AE_EffectAnimatorProperty Effect1;

	public AE_EffectAnimatorProperty Effect2;

	public AE_EffectAnimatorProperty Effect3;

	public AE_EffectAnimatorProperty Effect4;

	public GameObject Bow;

	public GameObject Arrow;

	[HideInInspector]
	public float HUE = -1f;

	private void InstantiateEffect(AE_EffectAnimatorProperty effect, bool returnIfCreatedInstance = false)
	{
		if (effect.Prefab == null)
		{
			return;
		}
		if (effect.BonePosition != null && effect.BoneRotation != null)
		{
			effect.CurrentInstance = UnityEngine.Object.Instantiate(effect.Prefab, effect.BonePosition.position, effect.BoneRotation.rotation);
		}
		else
		{
			effect.CurrentInstance = UnityEngine.Object.Instantiate(effect.Prefab);
		}
		if (effect.TargetAnimation != null)
		{
			effect.CurrentInstance.GetComponent<Animator>().runtimeAnimatorController = effect.TargetAnimation;
		}
		if (Bow != null)
		{
			AE_SetMeshToEffect component = effect.CurrentInstance.GetComponent<AE_SetMeshToEffect>();
			if (component != null && component.MeshType == AE_SetMeshToEffect.EffectMeshType.Bow)
			{
				component.Mesh = Bow;
			}
		}
		if (Arrow != null)
		{
			AE_SetMeshToEffect component2 = effect.CurrentInstance.GetComponent<AE_SetMeshToEffect>();
			if (component2 != null && component2.MeshType == AE_SetMeshToEffect.EffectMeshType.Arrow)
			{
				component2.Mesh = Arrow;
			}
		}
		if (HUE > -0.9f)
		{
			UpdateColor(effect);
		}
		if (effect.DestroyTime > 0.001f)
		{
			UnityEngine.Object.Destroy(effect.CurrentInstance, effect.DestroyTime);
		}
	}

	public void ActivateEffect1()
	{
		InstantiateEffect(Effect1);
	}

	public void ActivateEffect2()
	{
		InstantiateEffect(Effect2);
	}

	public void ActivateEffect3()
	{
		InstantiateEffect(Effect3, returnIfCreatedInstance: true);
	}

	public void ActivateEffect4()
	{
		InstantiateEffect(Effect4);
	}

	private void UpdateColor(AE_EffectAnimatorProperty effect)
	{
		AE_EffectSettingColor aE_EffectSettingColor = effect.CurrentInstance.GetComponent<AE_EffectSettingColor>();
		if (aE_EffectSettingColor == null)
		{
			aE_EffectSettingColor = effect.CurrentInstance.AddComponent<AE_EffectSettingColor>();
		}
		AE_ColorHelper.HSBColor hsbColor = AE_ColorHelper.ColorToHSV(aE_EffectSettingColor.Color);
		hsbColor.H = HUE;
		aE_EffectSettingColor.Color = AE_ColorHelper.HSVToColor(hsbColor);
	}
}
public class AE_RagdollCollisionEnter : MonoBehaviour
{
	public AE_RagdollPhysx AE_RagdollPhysx;

	private void OnCollisionEnter(Collision collision)
	{
		if (collision.transform.name.Contains("TransformMotion"))
		{
			AE_RagdollPhysx.OnCollisionEnterChild();
		}
	}
}
public class AE_RagdollPhysx : MonoBehaviour
{
	public Animator Animator;

	private void Start()
	{
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
		foreach (Rigidbody obj in componentsInChildren)
		{
			obj.interpolation = RigidbodyInterpolation.Interpolate;
			obj.mass = 1f;
			obj.gameObject.AddComponent<AE_RagdollCollisionEnter>().AE_RagdollPhysx = this;
		}
		SetKinematic(newValue: true);
	}

	public void OnCollisionEnterChild()
	{
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			UnityEngine.Object.Destroy(componentsInChildren[i].GetComponent<AE_RagdollCollisionEnter>());
		}
		Death();
	}

	private void Death()
	{
		SetKinematic(newValue: false);
		Animator.enabled = false;
		UnityEngine.Object.Destroy(base.gameObject, 5f);
	}

	private void SetKinematic(bool newValue)
	{
		Rigidbody[] componentsInChildren = GetComponentsInChildren<Rigidbody>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].isKinematic = newValue;
		}
	}
}
public class ME_DemoGUI : MonoBehaviour
{
	public GameObject Character;

	public GameObject Model;

	public int Current;

	public GameObject[] Prefabs;

	public Light Sun;

	public ReflectionProbe ReflectionProbe;

	public Light[] NightLights = new Light[0];

	public Texture HUETexture;

	public bool UseMobileVersion;

	public GameObject MobileCharacter;

	public GameObject Target;

	public Color guiColor = Color.red;

	private int currentNomber;

	private GameObject characterInstance;

	private GameObject modelInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private GUIStyle guiStyleHeaderMobile = new GUIStyle();

	private float dpiScale;

	private bool isDay;

	private float colorHUE;

	private float startSunIntensity;

	private Quaternion startSunRotation;

	private Color startAmbientLight;

	private float startAmbientIntencity;

	private float startReflectionIntencity;

	private LightShadows startLightShadows;

	private bool isButtonPressed;

	private GameObject instanceShieldProjectile;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = guiColor;
		guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
		ChangeCurrent(Current);
		startSunIntensity = Sun.intensity;
		startSunRotation = Sun.transform.rotation;
		startAmbientLight = RenderSettings.ambientLight;
		startAmbientIntencity = RenderSettings.ambientIntensity;
		startReflectionIntencity = RenderSettings.reflectionIntensity;
		startLightShadows = Sun.shadows;
	}

	private void OnGUI()
	{
		if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
		{
			isButtonPressed = false;
		}
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(1);
		}
		float num = 0f;
		if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
		{
			isButtonPressed = true;
			if (ReflectionProbe != null)
			{
				ReflectionProbe.RenderProbe();
			}
			Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
			Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
			Light[] nightLights = NightLights;
			for (int i = 0; i < nightLights.Length; i++)
			{
				nightLights[i].shadows = ((!isDay) ? startLightShadows : LightShadows.None);
			}
			Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
			RenderSettings.ambientLight = ((!isDay) ? new Color(0.2f, 0.2f, 0.2f) : startAmbientLight);
			float num2 = ((!UseMobileVersion) ? 1f : 0.3f);
			RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : num2);
			RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
			isDay = !isDay;
		}
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale + num / 2f, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + Prefabs[currentNomber].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
		GUI.DrawTexture(new Rect(12f * dpiScale, 140f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num3 = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 147f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), colorHUE, 0f, 360f);
		if ((double)Mathf.Abs(num3 - colorHUE) > 0.001)
		{
			PSMeshRendererUpdater componentInChildren = characterInstance.GetComponentInChildren<PSMeshRendererUpdater>();
			if (componentInChildren != null)
			{
				componentInChildren.UpdateColor(colorHUE / 360f);
			}
			componentInChildren = modelInstance.GetComponentInChildren<PSMeshRendererUpdater>();
			if (componentInChildren != null)
			{
				componentInChildren.UpdateColor(colorHUE / 360f);
			}
		}
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (characterInstance != null)
		{
			UnityEngine.Object.Destroy(characterInstance);
			RemoveClones();
		}
		if (modelInstance != null)
		{
			UnityEngine.Object.Destroy(modelInstance);
			RemoveClones();
		}
		characterInstance = UnityEngine.Object.Instantiate(Character);
		characterInstance.GetComponent<ME_AnimatorEvents>().EffectPrefab = Prefabs[currentNomber];
		modelInstance = UnityEngine.Object.Instantiate(Model);
		GameObject obj = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
		obj.transform.parent = modelInstance.transform;
		obj.transform.localPosition = Vector3.zero;
		obj.transform.localRotation = default(Quaternion);
		obj.GetComponent<PSMeshRendererUpdater>().UpdateMeshEffect(modelInstance);
		if (UseMobileVersion)
		{
			CancelInvoke("ReactivateEffect");
		}
	}

	private void RemoveClones()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Contains("(Clone)"))
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
	}

	private void ReactivateEffect()
	{
		characterInstance.SetActive(value: false);
		characterInstance.SetActive(value: true);
		modelInstance.SetActive(value: false);
		modelInstance.SetActive(value: true);
	}
}
public class ME_DemoGUI1 : MonoBehaviour
{
	[Serializable]
	public class AE_PrefabEffects
	{
		public GameObject ShotEffect;

		public GameObject BowEffect;

		public GameObject BuffEffect;

		public bool UseCharacterTarget = true;

		public RuntimeAnimatorController TargetAnimation;

		public RuntimeAnimatorController CustomAnimation;
	}

	public int Current;

	public AE_PrefabEffects[] Effects;

	public bool isMobile;

	public Light Sun;

	public ReflectionProbe ReflectionProbe;

	public Light[] NightLights = new Light[0];

	public Texture HUETexture;

	public bool UseMobileVersion;

	public GameObject Character;

	public GameObject Target;

	public Color guiColor = Color.red;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private GUIStyle guiStyleHeaderMobile = new GUIStyle();

	private float dpiScale;

	private bool isDay;

	private float colorHUE;

	private float startSunIntensity;

	private Quaternion startSunRotation;

	private Color startAmbientLight;

	private float startAmbientIntencity;

	private float startReflectionIntencity;

	private LightShadows startLightShadows;

	private bool isButtonPressed;

	private GameObject instanceShieldProjectile;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = guiColor;
		guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
		ChangeCurrent(Current);
		startSunIntensity = Sun.intensity;
		startSunRotation = Sun.transform.rotation;
		startAmbientLight = RenderSettings.ambientLight;
		startAmbientIntencity = RenderSettings.ambientIntensity;
		startReflectionIntencity = RenderSettings.reflectionIntensity;
		startLightShadows = Sun.shadows;
		if (isMobile)
		{
			ChangeLight();
		}
	}

	private void OnGUI()
	{
		if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
		{
			isButtonPressed = false;
		}
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(1);
		}
		float num = 0f;
		if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
		{
			ChangeLight();
		}
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale + num / 2f, 100f * dpiScale, 20f * dpiScale), "Effect " + currentNomber + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
		GUI.DrawTexture(new Rect(12f * dpiScale, 140f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num2 = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 147f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), colorHUE, 0f, 360f);
		if (!((double)Mathf.Abs(num2 - colorHUE) > 0.001))
		{
			return;
		}
		AE_ColorHelper.ChangeObjectColorByHUE(currentInstance, colorHUE / 360f);
		AE_AnimatorEvents component = currentInstance.GetComponent<AE_AnimatorEvents>();
		if (component != null)
		{
			component.HUE = colorHUE / 360f;
			if (component.Effect1.CurrentInstance != null)
			{
				AE_ColorHelper.ChangeObjectColorByHUE(component.Effect1.CurrentInstance, colorHUE / 360f);
			}
			if (component.Effect2.CurrentInstance != null)
			{
				AE_ColorHelper.ChangeObjectColorByHUE(component.Effect2.CurrentInstance, colorHUE / 360f);
			}
			if (component.Effect3.CurrentInstance != null)
			{
				AE_ColorHelper.ChangeObjectColorByHUE(component.Effect3.CurrentInstance, colorHUE / 360f);
			}
			if (component.Effect4.CurrentInstance != null)
			{
				AE_ColorHelper.ChangeObjectColorByHUE(component.Effect4.CurrentInstance, colorHUE / 360f);
			}
		}
		_ = UseMobileVersion;
	}

	private void ChangeLight()
	{
		isButtonPressed = true;
		if (ReflectionProbe != null)
		{
			ReflectionProbe.RenderProbe();
		}
		Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
		Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
		Light[] nightLights = NightLights;
		for (int i = 0; i < nightLights.Length; i++)
		{
			nightLights[i].shadows = ((!isDay) ? startLightShadows : LightShadows.None);
		}
		Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
		RenderSettings.ambientLight = ((!isDay) ? new Color(0.1f, 0.1f, 0.1f) : startAmbientLight);
		float num = ((!UseMobileVersion) ? 1f : 0.2f);
		RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : num);
		RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
		isDay = !isDay;
	}

	private void ChangeCurrent(int delta)
	{
		colorHUE = 0f;
		currentNomber += delta;
		if (currentNomber > Effects.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Effects.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
			RemoveClones();
		}
		currentInstance = UnityEngine.Object.Instantiate(Character);
		if (Effects[currentNomber].CustomAnimation != null)
		{
			currentInstance.GetComponent<Animator>().runtimeAnimatorController = Effects[currentNomber].CustomAnimation;
		}
		AE_AnimatorEvents component = currentInstance.GetComponent<AE_AnimatorEvents>();
		if (component != null)
		{
			if (Effects[currentNomber].ShotEffect != null)
			{
				component.Effect1.Prefab = Effects[currentNomber].ShotEffect;
			}
			if (Effects[currentNomber].BowEffect != null)
			{
				component.Effect2.Prefab = Effects[currentNomber].BowEffect;
			}
			if (Effects[currentNomber].BuffEffect != null)
			{
				component.Effect3.Prefab = Effects[currentNomber].BuffEffect;
			}
			if (Effects[currentNomber].UseCharacterTarget)
			{
				component.Effect4.Prefab = Target;
				component.Effect4.TargetAnimation = Effects[currentNomber].TargetAnimation;
			}
		}
		_ = UseMobileVersion;
	}

	private void RemoveClones()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Contains("(Clone)"))
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
	}
}
public class ME_FPS : MonoBehaviour
{
	public GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float timeleft2;

	private const float updateTime = 0.5f;

	private float fps;

	private int frames;

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (float)(int)fps / 0.5f, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 0.5f;
			frames = 0;
		}
	}
}
public class ME_MouseOrbit : MonoBehaviour
{
	public GameObject target;

	public GameObject cylinder;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private float prevDistance;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
	}

	private void LateUpdate()
	{
		if (distance < 2f)
		{
			distance = 2f;
		}
		distance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
		if ((bool)target && (Input.GetMouseButton(0) || Input.GetMouseButton(1) || Input.GetMouseButton(2)))
		{
			if (Input.GetMouseButton(0) || Input.GetMouseButton(1))
			{
				Vector3 mousePosition = Input.mousePosition;
				float num = 1f;
				if (Screen.dpi < 1f)
				{
					num = 1f;
				}
				num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
				if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
				{
					return;
				}
				Cursor.visible = false;
				Cursor.lockState = CursorLockMode.Locked;
				x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
				y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
				y = ClampAngle(y, yMinLimit, yMaxLimit);
				Quaternion quaternion = Quaternion.Euler(y, x, 0f);
				Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
				base.transform.rotation = quaternion;
				base.transform.position = position;
			}
			if (Input.GetMouseButton(2))
			{
				Cursor.visible = false;
				Cursor.lockState = CursorLockMode.Locked;
				base.transform.RotateAround(target.transform.position, Vector3.up, 15f * Time.deltaTime);
			}
		}
		else
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		if (Math.Abs(prevDistance - distance) > 0.001f)
		{
			prevDistance = distance;
			Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
			Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion2;
			base.transform.position = position2;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class ME_RealtimeReflection : MonoBehaviour
{
	private ReflectionProbe probe;

	private Transform camT;

	private void Awake()
	{
		probe = GetComponent<ReflectionProbe>();
		camT = Camera.main.transform;
	}

	private void Update()
	{
		Vector3 position = camT.position;
		probe.transform.position = new Vector3(position.x, position.y * -1f, position.z);
	}
}
public class RFX1_DemoGUI : MonoBehaviour
{
	public int Current;

	public GameObject[] Prefabs;

	public bool[] IsShield;

	public GameObject ShieldProjectile;

	public GameObject ShieldProjectile2;

	public float ShieldProjectileReactiovationTime = 7f;

	public Light Sun;

	public ReflectionProbe ReflectionProbe;

	public Light[] NightLights = new Light[0];

	public Texture HUETexture;

	public bool UseMobileVersion;

	public GameObject MobileCharacter;

	public GameObject Target;

	public Color guiColor = Color.red;

	public RFX1_DistortionAndBloom RFX1_DistortionAndBloom;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private GUIStyle guiStyleHeaderMobile = new GUIStyle();

	private float dpiScale;

	private bool isDay;

	private float colorHUE;

	private float startSunIntensity;

	private Quaternion startSunRotation;

	private Color startAmbientLight;

	private float startAmbientIntencity;

	private float startReflectionIntencity;

	private LightShadows startLightShadows;

	private float currentSpeed = 1f;

	private GameObject mobileCharacterInstance;

	private bool isButtonPressed;

	private GameObject instanceShieldProjectile;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = guiColor;
		guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
		ChangeCurrent(Current);
		startSunIntensity = Sun.intensity;
		startSunRotation = Sun.transform.rotation;
		startAmbientLight = RenderSettings.ambientLight;
		startAmbientIntencity = RenderSettings.ambientIntensity;
		startReflectionIntencity = RenderSettings.reflectionIntensity;
		startLightShadows = Sun.shadows;
		RFX1_DistortionAndBloom = Camera.main.GetComponent<RFX1_DistortionAndBloom>();
	}

	private void OnGUI()
	{
		if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
		{
			isButtonPressed = false;
		}
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(1);
		}
		float num = 0f;
		if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
		{
			isButtonPressed = true;
			if (ReflectionProbe != null)
			{
				ReflectionProbe.RenderProbe();
			}
			Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
			Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
			Light[] nightLights = NightLights;
			for (int i = 0; i < nightLights.Length; i++)
			{
				nightLights[i].shadows = ((!isDay) ? startLightShadows : LightShadows.None);
			}
			Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
			RenderSettings.ambientLight = ((!isDay) ? new Color(0.1f, 0.1f, 0.1f) : startAmbientLight);
			float num2 = ((!UseMobileVersion) ? 1f : 0.2f);
			RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : num2);
			RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
			isDay = !isDay;
		}
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale + num / 2f, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + Prefabs[currentNomber].name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
		if (!IsShield[currentNomber] && !UseMobileVersion)
		{
			GUI.Label(new Rect(12f * dpiScale, 110f * dpiScale + num, 50f * dpiScale, 20f * dpiScale), "Projectile Speed: " + Mathf.Round(currentSpeed * 10f) / 10f, guiStyleHeader);
			float num3 = currentSpeed;
			if (!UseMobileVersion)
			{
				currentSpeed = GUI.HorizontalSlider(new Rect(154f * dpiScale, 114f * dpiScale + num, 135f * dpiScale, 15f * dpiScale), currentSpeed, 0.1f, 10f);
			}
			if ((double)Math.Abs(num3 - currentSpeed) > 0.001)
			{
				RFX1_AnimatorEvents component = currentInstance.GetComponent<RFX1_AnimatorEvents>();
				if (component != null)
				{
					component.Speed = currentSpeed;
				}
			}
		}
		GUI.DrawTexture(new Rect(12f * dpiScale, 140f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), HUETexture, ScaleMode.StretchToFill, alphaBlend: false, 0f);
		float num4 = colorHUE;
		colorHUE = GUI.HorizontalSlider(new Rect(12f * dpiScale, 147f * dpiScale + num, 285f * dpiScale, 15f * dpiScale), colorHUE, 0f, 360f);
		if (!((double)Mathf.Abs(num4 - colorHUE) > 0.001))
		{
			return;
		}
		RFX1_AnimatorEvents component2 = currentInstance.GetComponent<RFX1_AnimatorEvents>();
		if (component2 != null)
		{
			component2.HUE = colorHUE / 360f;
		}
		if (UseMobileVersion)
		{
			RFX1_EffectSettingColor rFX1_EffectSettingColor = currentInstance.GetComponent<RFX1_EffectSettingColor>();
			if (rFX1_EffectSettingColor == null)
			{
				rFX1_EffectSettingColor = currentInstance.AddComponent<RFX1_EffectSettingColor>();
			}
			RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
			hsbColor.H = colorHUE / 360f;
			rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
		}
	}

	private void ChangeCurrent(int delta)
	{
		currentSpeed = 1f;
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
			RemoveClones();
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
		RFX1_AnimatorEvents component = currentInstance.GetComponent<RFX1_AnimatorEvents>();
		if (component != null)
		{
			component.Target = Target;
		}
		RFX1_Target component2 = currentInstance.GetComponent<RFX1_Target>();
		if (component2 != null)
		{
			component2.Target = Target;
		}
		CancelInvoke("ReactivateShieldProjectile");
		if (IsShield[currentNomber])
		{
			if (currentNomber != 23)
			{
				InvokeRepeating("ReactivateShieldProjectile", 5f, ShieldProjectileReactiovationTime);
			}
			else
			{
				InvokeRepeating("ReactivateShieldProjectile", 3f, 3f);
			}
		}
		RFX1_TransformMotion componentInChildren = currentInstance.GetComponentInChildren<RFX1_TransformMotion>();
		if (componentInChildren != null)
		{
			currentSpeed = componentInChildren.Speed;
		}
		if (UseMobileVersion)
		{
			CancelInvoke("ReactivateEffect");
			componentInChildren = currentInstance.GetComponentInChildren<RFX1_TransformMotion>();
			if (componentInChildren != null)
			{
				componentInChildren.CollisionEnter += delegate
				{
					Invoke("ReactivateEffect", 3f);
				};
			}
		}
		if (mobileCharacterInstance != null)
		{
			UnityEngine.Object.Destroy(mobileCharacterInstance);
		}
		if (IsShield[currentNomber] && UseMobileVersion)
		{
			mobileCharacterInstance = UnityEngine.Object.Instantiate(MobileCharacter);
		}
	}

	private void RemoveClones()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Contains("(Clone)"))
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
	}

	private void ReactivateShieldProjectile()
	{
		if (instanceShieldProjectile != null)
		{
			UnityEngine.Object.Destroy(instanceShieldProjectile);
		}
		instanceShieldProjectile = ((currentNomber != 23) ? UnityEngine.Object.Instantiate(ShieldProjectile) : UnityEngine.Object.Instantiate(ShieldProjectile2));
		instanceShieldProjectile.SetActive(value: false);
		instanceShieldProjectile.SetActive(value: true);
	}

	private void ReactivateEffect()
	{
		currentInstance.SetActive(value: false);
		currentInstance.SetActive(value: true);
	}
}
public class RFX1_FPS : MonoBehaviour
{
	public GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float timeleft2;

	private const float updateTime = 0.5f;

	private float fps;

	private int frames;

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (float)(int)fps / 0.5f, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 0.5f;
			frames = 0;
		}
	}
}
public class RFX1_MouseOrbit : MonoBehaviour
{
	public GameObject target;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private float prevDistance;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
	}

	private void LateUpdate()
	{
		if (distance < 2f)
		{
			distance = 2f;
		}
		distance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
		if ((bool)target && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			Vector3 mousePosition = Input.mousePosition;
			float num = 1f;
			if (Screen.dpi < 1f)
			{
				num = 1f;
			}
			num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
			if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
			{
				return;
			}
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
			x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
		else
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		if (Math.Abs(prevDistance - distance) > 0.001f)
		{
			prevDistance = distance;
			Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
			Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion2;
			base.transform.position = position2;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class RFX1_RealtimeReflection : MonoBehaviour
{
	private ReflectionProbe probe;

	private Transform camT;

	private void Awake()
	{
		probe = GetComponent<ReflectionProbe>();
		camT = Camera.main.transform;
	}

	private void Update()
	{
		Vector3 position = camT.position;
		probe.transform.position = new Vector3(position.x, position.y * -1f, position.z);
		probe.RenderProbe();
	}
}
public class RFX4_FPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
	}

	private void OnGUI()
	{
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/RFX1_BloomAndDistortion")]
public class RFX1_DistortionAndBloom : MonoBehaviour
{
	[Range(0.05f, 1f)]
	[UnityEngine.Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.25f;

	public bool UseBloom = true;

	[Range(0.1f, 3f)]
	[UnityEngine.Tooltip("Filters out pixels under this level of brightness.")]
	public float Threshold = 2f;

	[SerializeField]
	[Range(0f, 1f)]
	[UnityEngine.Tooltip("Makes transition between under/over-threshold gradual.")]
	public float SoftKnee;

	[Range(1f, 7f)]
	[UnityEngine.Tooltip("Changes extent of veiling effects in A screen resolution-independent fashion.")]
	public float Radius = 7f;

	[UnityEngine.Tooltip("Blend factor of the result image.")]
	public float Intensity = 1f;

	[UnityEngine.Tooltip("Controls filter quality and buffer resolution.")]
	public bool HighQuality;

	[UnityEngine.Tooltip("Reduces flashing noise with an additional filter.")]
	public bool AntiFlicker;

	private const string shaderName = "Hidden/KriptoFX/PostEffects/RFX1_Bloom";

	private const string shaderAdditiveName = "Hidden/KriptoFX/PostEffects/RFX1_BloomAdditive";

	private const string cameraName = "MobileCamera(Distort_Bloom_Depth)";

	private RenderTexture source;

	private RenderTexture depth;

	private RenderTexture destination;

	private int previuosFrameWidth;

	private int previuosFrameHeight;

	private float previousScale;

	private Camera addCamera;

	private GameObject tempGO;

	private bool HDRSupported;

	private Material m_Material;

	private Material m_MaterialAdditive;

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	public GUIStyle guiStyleHeader = new GUIStyle();

	public Material mat
	{
		get
		{
			if (m_Material == null)
			{
				m_Material = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX1_Bloom"));
			}
			return m_Material;
		}
	}

	public Material matAdditive
	{
		get
		{
			if (m_MaterialAdditive == null)
			{
				m_MaterialAdditive = CheckShaderAndCreateMaterial(Shader.Find("Hidden/KriptoFX/PostEffects/RFX1_BloomAdditive"));
				m_MaterialAdditive.renderQueue = 3900;
			}
			return m_MaterialAdditive;
		}
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		if (s == null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = HideFlags.DontSave
		};
	}

	private void OnDisable()
	{
		if (m_Material != null)
		{
			UnityEngine.Object.DestroyImmediate(m_Material);
		}
		m_Material = null;
		if (m_MaterialAdditive != null)
		{
			UnityEngine.Object.DestroyImmediate(m_MaterialAdditive);
		}
		m_MaterialAdditive = null;
		if (tempGO != null)
		{
			UnityEngine.Object.DestroyImmediate(tempGO);
		}
		Shader.DisableKeyword("DISTORT_OFF");
		Shader.DisableKeyword("_MOBILEDEPTH_ON");
	}

	private void Start()
	{
		InitializeRenderTarget();
	}

	private void LateUpdate()
	{
		if (previuosFrameWidth != Screen.width || previuosFrameHeight != Screen.height || Mathf.Abs(previousScale - RenderTextureResolutoinFactor) > 0.01f)
		{
			InitializeRenderTarget();
			previuosFrameWidth = Screen.width;
			previuosFrameHeight = Screen.height;
			previousScale = RenderTextureResolutoinFactor;
		}
		Shader.EnableKeyword("DISTORT_OFF");
		Shader.EnableKeyword("_MOBILEDEPTH_ON");
		GrabImage();
		if (UseBloom && HDRSupported)
		{
			UpdateBloom();
		}
		Shader.SetGlobalTexture("_GrabTexture", source);
		Shader.SetGlobalTexture("_CameraDepthTexture", depth);
		Shader.SetGlobalFloat("_GrabTextureScale", RenderTextureResolutoinFactor);
		Shader.DisableKeyword("DISTORT_OFF");
	}

	private void OnPostRender()
	{
		Graphics.Blit(destination, null, matAdditive);
	}

	private void InitializeRenderTarget()
	{
		int num = (int)((float)Screen.width * RenderTextureResolutoinFactor);
		int num2 = (int)((float)Screen.height * RenderTextureResolutoinFactor);
		if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float))
		{
			source = new RenderTexture(num, num2, 0, RenderTextureFormat.RGB111110Float);
			depth = new RenderTexture(num, num2, 8, RenderTextureFormat.Depth);
			HDRSupported = true;
			if (UseBloom)
			{
				destination = new RenderTexture(((double)RenderTextureResolutoinFactor > 0.99) ? num : (num / 2), ((double)RenderTextureResolutoinFactor > 0.99) ? num2 : (num2 / 2), 0, RenderTextureFormat.RGB111110Float);
			}
		}
		else
		{
			HDRSupported = false;
			source = new RenderTexture(num, num2, 0, RenderTextureFormat.RGB565);
			depth = new RenderTexture(num, num2, 8, RenderTextureFormat.Depth);
		}
	}

	private void UpdateBloom()
	{
		bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
		if (source == null)
		{
			return;
		}
		int num = source.width;
		int num2 = source.height;
		if (!HighQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
		float num3 = Mathf.Log(num2, 2f) + Radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float num6 = Mathf.GammaToLinearSpace(Threshold);
		mat.SetFloat("_Threshold", num6);
		float num7 = num6 * SoftKnee + 1E-05f;
		Vector3 vector = new Vector3(num6 - num7, num7 * 2f, 0.25f / num7);
		mat.SetVector("_Curve", vector);
		bool flag = !HighQuality && AntiFlicker;
		mat.SetFloat("_PrefilterOffs", flag ? (-0.5f) : 0f);
		mat.SetFloat("_SampleScale", 0.5f + num3 - (float)num4);
		mat.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
		Graphics.Blit(source, temporary, mat, AntiFlicker ? 1 : 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], mat, (i == 0) ? (AntiFlicker ? 3 : 2) : 4);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num8 = num5 - 2; num8 >= 0; num8--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num8];
			mat.SetTexture("_BaseTex", renderTexture2);
			m_blurBuffer2[num8] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num8], mat, HighQuality ? 6 : 5);
			renderTexture = m_blurBuffer2[num8];
		}
		destination.DiscardContents();
		Graphics.Blit(renderTexture, destination, mat, HighQuality ? 8 : 7);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}

	private void GrabImage()
	{
		Camera camera = Camera.current;
		if (camera == null)
		{
			camera = Camera.main;
		}
		if (tempGO == null)
		{
			tempGO = new GameObject();
			tempGO.hideFlags = HideFlags.HideAndDontSave;
			tempGO.name = "MobileCamera(Distort_Bloom_Depth)";
			addCamera = tempGO.AddComponent<Camera>();
			addCamera.enabled = false;
		}
		else
		{
			addCamera = tempGO.GetComponent<Camera>();
		}
		addCamera.CopyFrom(camera);
		addCamera.SetTargetBuffers(source.colorBuffer, depth.depthBuffer);
		addCamera.depth--;
		addCamera.Render();
	}
}
public class RFX1_AudioPitchCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphPitchMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startPitch;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startPitch = audioSource.pitch;
		audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.pitch = AudioCurve.Evaluate(0f) * GraphPitchMultiplier;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float pitch = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startPitch * GraphPitchMultiplier;
			audioSource.pitch = pitch;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_AudioVolumeCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (audioSource != null)
		{
			audioSource.volume = AudioCurve.Evaluate(0f);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (lightSource != null)
		{
			lightSource.intensity = LightCurve.Evaluate(0f) * GraphIntensityMultiplier;
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ProjectorSizeCurves : MonoBehaviour
{
	public AnimationCurve ProjectorSize = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Projector projector;

	private void Awake()
	{
		projector = GetComponent<Projector>();
		projector.orthographicSize = ProjectorSize.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float orthographicSize = ProjectorSize.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			projector.orthographicSize = orthographicSize;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_ShaderColorGradient : MonoBehaviour
{
	public RFX1_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private Material mat;

	private int propertyID;

	private float startTime;

	private Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private void Start()
	{
		Init();
	}

	private void Init()
	{
		shaderProperty = ShaderColorProperty.ToString();
		startTime = Time.time;
		canUpdate = true;
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		if (mat == null)
		{
			canUpdate = false;
			return;
		}
		if (!mat.HasProperty(shaderProperty))
		{
			canUpdate = false;
			return;
		}
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startColor = mat.GetColor(propertyID);
		Color color = Color.Evaluate(0f);
		mat.SetColor(propertyID, color * startColor);
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			startTime = Time.time;
			canUpdate = true;
		}
	}

	private void Update()
	{
		if (mat == null)
		{
			return;
		}
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			mat.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (!(mat == null))
		{
			if (UseSharedMaterial)
			{
				mat.SetColor(propertyID, startColor);
			}
			mat.SetColor(propertyID, startColor);
		}
	}
}
public class RFX1_ShaderFloatCurve : MonoBehaviour
{
	public RFX1_ShaderProperties ShaderFloatProperty = RFX1_ShaderProperties._Cutoff;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public bool UseSharedMaterial;

	private bool canUpdate;

	private float startTime;

	private Material mat;

	private float startFloat;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private void Awake()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!UseSharedMaterial)
				{
					if (!component2.material.name.EndsWith("(Instance)"))
					{
						component2.material = new Material(component2.material)
						{
							name = component2.material.name + " (Instance)"
						};
					}
					mat = component2.material;
				}
				else
				{
					mat = component2.material;
				}
			}
		}
		else if (!UseSharedMaterial)
		{
			mat = component.material;
		}
		else
		{
			mat = component.sharedMaterial;
		}
		shaderProperty = ShaderFloatProperty.ToString();
		if (mat.HasProperty(shaderProperty))
		{
			propertyID = Shader.PropertyToID(shaderProperty);
		}
		startFloat = mat.GetFloat(propertyID);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		mat.SetFloat(propertyID, value);
		isInitialized = true;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		if (isInitialized)
		{
			float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			mat.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDisable()
	{
		if (UseSharedMaterial)
		{
			mat.SetFloat(propertyID, startFloat);
		}
	}
}
public enum RFX1_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt,
	_AlphaPow,
	_Distortion,
	_MainColor
}
public class RFX1_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float windMain = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = windMain;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX1_EffectSettingColor : MonoBehaviour
{
	public Color Color = Color.red;

	private Color previousColor;

	private void OnEnable()
	{
		UpdateColor();
	}

	private void Update()
	{
		if (previousColor != Color)
		{
			UpdateColor();
		}
	}

	private void UpdateColor()
	{
		float h = RFX1_ColorHelper.ColorToHSV(Color).H;
		RFX1_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		previousColor = Color;
	}
}
public class RFX1_EffectSettingProjectile : MonoBehaviour
{
	public float FlyDistanceForProjectiles = 30f;

	public float SpeedMultiplier = 1f;

	public LayerMask CollidesWith = -1;

	private float startSpeed;

	private float oldSpeedMultiplier;

	private void Awake()
	{
		oldSpeedMultiplier = SpeedMultiplier;
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			startSpeed = componentInChildren.Speed;
		}
	}

	private void OnEnable()
	{
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.Distance = FlyDistanceForProjectiles;
			componentInChildren.CollidesWith = CollidesWith;
			componentInChildren.Speed = startSpeed * SpeedMultiplier;
		}
	}

	private void Update()
	{
		if (Mathf.Abs(oldSpeedMultiplier - SpeedMultiplier) > 0.001f)
		{
			OnEnable();
		}
	}
}
public class RFX1_ShieldInteraction : MonoBehaviour
{
	private RFX1_TransformMotion transformMotion;

	private SphereCollider coll;

	private void Start()
	{
		transformMotion = GetComponentInChildren<RFX1_TransformMotion>();
		if (transformMotion != null)
		{
			transformMotion.CollisionEnter += TransformMotion_CollisionEnter;
			coll = transformMotion.gameObject.AddComponent<SphereCollider>();
			coll.radius = 0.1f;
			coll.isTrigger = true;
		}
	}

	private void TransformMotion_CollisionEnter(object sender, RFX1_TransformMotion.RFX1_CollisionInfo e)
	{
		RFX1_ShieldCollisionTrigger componentInChildren = e.Hit.transform.GetComponentInChildren<RFX1_ShieldCollisionTrigger>();
		if (!(componentInChildren == null))
		{
			componentInChildren.OnCollision(e.Hit, base.gameObject);
			coll.enabled = false;
		}
	}

	private void OnEnable()
	{
		if (coll != null)
		{
			coll.enabled = true;
		}
	}

	private void Update()
	{
	}
}
public class RFX1_Target : MonoBehaviour
{
	public GameObject Target;

	private GameObject currentTarget;

	private RFX1_TransformMotion transformMotion;

	private void Start()
	{
		transformMotion = GetComponentInChildren<RFX1_TransformMotion>();
		UpdateTarget();
	}

	private void Update()
	{
		UpdateTarget();
	}

	private void UpdateTarget()
	{
		if (!(Target == null))
		{
			if (transformMotion == null)
			{
				UnityEngine.Debug.Log("You must attach the target script on projectile effect!");
			}
			else if (Target != currentTarget)
			{
				currentTarget = Target;
				transformMotion.Target = currentTarget;
			}
		}
	}
}
public class RFX1_ActivateGravityAfterCollision : MonoBehaviour
{
	public RFX1_TransformMotion TransformMotion;

	public Vector2 Gravity = new Vector2(1f, 1f);

	private ParticleSystem ps;

	private ParticleSystem.MinMaxCurve startGravity;

	private bool isInitialized;

	private void OnEnable()
	{
		TransformMotion.CollisionEnter += TransformMotion_CollisionEnter;
		ps = GetComponent<ParticleSystem>();
		ParticleSystem.MainModule main = ps.main;
		if (!isInitialized)
		{
			isInitialized = true;
			startGravity = main.gravityModifier;
		}
		else
		{
			main.gravityModifier = startGravity;
		}
	}

	private void OnDisable()
	{
		TransformMotion.CollisionEnter -= TransformMotion_CollisionEnter;
	}

	private void TransformMotion_CollisionEnter(object sender, RFX1_TransformMotion.RFX1_CollisionInfo e)
	{
		ParticleSystem.MainModule main = ps.main;
		main.gravityModifier = new ParticleSystem.MinMaxCurve(Gravity.x, Gravity.y);
	}
}
public class RFX1_AnimatorEvents : MonoBehaviour
{
	[Serializable]
	public class RFX1_EffectAnimatorProperty
	{
		public GameObject Prefab;

		public Transform BonePosition;

		public Transform BoneRotation;

		public float DestroyTime = 10f;

		[HideInInspector]
		public GameObject CurrentInstance;
	}

	public RFX1_EffectAnimatorProperty Effect1;

	public RFX1_EffectAnimatorProperty Effect2;

	public RFX1_EffectAnimatorProperty Effect3;

	public GameObject Target;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public float Speed = -1f;

	private float oldHUE;

	private float oldSpeed;

	private void InstantiateEffect(RFX1_EffectAnimatorProperty effect)
	{
		if (effect.Prefab == null)
		{
			return;
		}
		effect.CurrentInstance = UnityEngine.Object.Instantiate(effect.Prefab, effect.BonePosition.position, effect.BoneRotation.rotation);
		if (HUE > -0.9f)
		{
			UpdateColor(effect);
		}
		if (Speed > -0.9f)
		{
			UpdateSpeed(effect);
		}
		if (Target != null)
		{
			RFX1_Target component = effect.CurrentInstance.GetComponent<RFX1_Target>();
			if (component != null)
			{
				component.Target = Target;
			}
		}
		if (effect.DestroyTime > 0.001f)
		{
			UnityEngine.Object.Destroy(effect.CurrentInstance, effect.DestroyTime);
		}
	}

	public void ActivateEffect1()
	{
		InstantiateEffect(Effect1);
	}

	public void ActivateEffect2()
	{
		InstantiateEffect(Effect2);
	}

	public void ActivateEffect3()
	{
		InstantiateEffect(Effect3);
	}

	private void LateUpdate()
	{
		UpdateInstance(Effect1);
		UpdateInstance(Effect2);
		UpdateInstance(Effect3);
	}

	private void UpdateInstance(RFX1_EffectAnimatorProperty effect)
	{
		if (effect.CurrentInstance != null && effect.BonePosition != null)
		{
			effect.CurrentInstance.transform.position = effect.BonePosition.position;
			if (HUE > -0.9f && Mathf.Abs(oldHUE - HUE) > 0.001f)
			{
				UpdateColor(effect);
			}
			if (Speed > -0.9f && Mathf.Abs(oldSpeed - Speed) > 0.001f)
			{
				UpdateSpeed(effect);
			}
		}
	}

	private void UpdateSpeed(RFX1_EffectAnimatorProperty effect)
	{
		oldSpeed = Speed;
		RFX1_EffectSettingProjectile rFX1_EffectSettingProjectile = effect.CurrentInstance.GetComponent<RFX1_EffectSettingProjectile>();
		if (rFX1_EffectSettingProjectile == null)
		{
			rFX1_EffectSettingProjectile = effect.CurrentInstance.AddComponent<RFX1_EffectSettingProjectile>();
		}
		rFX1_EffectSettingProjectile.SpeedMultiplier *= Speed;
	}

	private void UpdateColor(RFX1_EffectAnimatorProperty effect)
	{
		oldHUE = HUE;
		RFX1_EffectSettingColor rFX1_EffectSettingColor = effect.CurrentInstance.GetComponent<RFX1_EffectSettingColor>();
		if (rFX1_EffectSettingColor == null)
		{
			rFX1_EffectSettingColor = effect.CurrentInstance.AddComponent<RFX1_EffectSettingColor>();
		}
		RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
		hsbColor.H = HUE;
		rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
	}
}
public static class RFX1_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[10] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor", "_FresnelColor", "_CutoutColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			Material material3 = componentsInChildren3[i].material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					setMatHUEColor(material3, name3, hue);
				}
			}
		}
		Projector[] componentsInChildren4 = go.GetComponentsInChildren<Projector>(includeInactive: true);
		foreach (Projector projector in componentsInChildren4)
		{
			if (!projector.material.name.EndsWith("(Instance)"))
			{
				projector.material = new Material(projector.material)
				{
					name = projector.material.name + " (Instance)"
				};
			}
			Material material4 = projector.material;
			if (material4 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name4 in array)
			{
				if (material4.HasProperty(name4))
				{
					projector.material = setMatHUEColor(material4, name4, hue);
				}
			}
		}
		Light[] componentsInChildren5 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren5)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren6 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren6)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int k = 1; k < colorKeys.Length; k++)
			{
				hsbColor2 = ColorToHSV(colorKeys[k].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[k].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
		RFX1_ShaderColorGradient[] componentsInChildren7 = go.GetComponentsInChildren<RFX1_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren7.Length; i++)
		{
			componentsInChildren7[i].HUE = hue;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class RFX1_DeactivateByTime : MonoBehaviour
{
	public float DeactivateTime = 3f;

	private void OnEnable()
	{
		Invoke("DeactivateThis", DeactivateTime);
	}

	private void OnDisable()
	{
		CancelInvoke("DeactivateThis");
	}

	private void DeactivateThis()
	{
		base.gameObject.SetActive(value: false);
	}
}
[ExecuteInEditMode]
public class RFX1_ParticleCollisionDecal : MonoBehaviour
{
	public ParticleSystem DecalParticles;

	public bool IsBilboard;

	public bool InstantiateWhenZeroSpeed;

	public float MaxGroundAngleDeviation = 45f;

	public float MinDistanceBetweenDecals = 0.1f;

	public float MinDistanceBetweenSurface = 0.03f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem.Particle[] particles;

	private ParticleSystem initiatorPS;

	private List<GameObject> collidedGameObjects = new List<GameObject>();

	private void OnEnable()
	{
		collisionEvents.Clear();
		collidedGameObjects.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
		particles = new ParticleSystem.Particle[DecalParticles.main.maxParticles];
		if (InstantiateWhenZeroSpeed)
		{
			InvokeRepeating("CollisionDetect", 0f, 0.1f);
		}
	}

	private void OnDisable()
	{
		if (InstantiateWhenZeroSpeed)
		{
			CancelInvoke("CollisionDetect");
		}
	}

	private void CollisionDetect()
	{
		int aliveParticles = 0;
		if (InstantiateWhenZeroSpeed)
		{
			aliveParticles = DecalParticles.GetParticles(particles);
		}
		foreach (GameObject collidedGameObject in collidedGameObjects)
		{
			OnParticleCollisionManual(collidedGameObject, aliveParticles);
		}
	}

	private void OnParticleCollisionManual(GameObject other, int aliveParticles = -1)
	{
		collisionEvents.Clear();
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			if (Vector3.Angle(collisionEvents[i].normal, Vector3.up) > MaxGroundAngleDeviation)
			{
				continue;
			}
			if (InstantiateWhenZeroSpeed)
			{
				if (collisionEvents[i].velocity.sqrMagnitude > 0.1f)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < aliveParticles; j++)
				{
					if (Vector3.Distance(collisionEvents[i].intersection, particles[j].position) < MinDistanceBetweenDecals)
					{
						flag = true;
					}
				}
				if (flag)
				{
					continue;
				}
			}
			ParticleSystem.EmitParams emitParams = default(ParticleSystem.EmitParams);
			emitParams.position = collisionEvents[i].intersection;
			Vector3 eulerAngles = Quaternion.LookRotation(-collisionEvents[i].normal).eulerAngles;
			eulerAngles.z = UnityEngine.Random.Range(0, 360);
			emitParams.rotation3D = eulerAngles;
			DecalParticles.Emit(emitParams, 1);
		}
	}

	private void OnParticleCollision(GameObject other)
	{
		if (InstantiateWhenZeroSpeed)
		{
			if (!collidedGameObjects.Contains(other))
			{
				collidedGameObjects.Add(other);
			}
		}
		else
		{
			OnParticleCollisionManual(other);
		}
	}
}
public class RFX1_ParticleCollisionGameObject : MonoBehaviour
{
	public GameObject InstancedGO;

	public float DestroyDelay = 5f;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem initiatorPS;

	private void OnEnable()
	{
		collisionEvents.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			UnityEngine.Object.Destroy(UnityEngine.Object.Instantiate(InstancedGO, collisionEvents[i].intersection, default(Quaternion)), DestroyDelay);
		}
	}
}
[ExecuteInEditMode]
public class RFX1_ParticleGravityPoint : MonoBehaviour
{
	public Transform target;

	public float Force = 1f;

	public AnimationCurve ForceByTime = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float ForceLifeTime = 1f;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private float startTime;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void OnEnable()
	{
		startTime = Time.time;
	}

	private void LateUpdate()
	{
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		float num2 = ForceByTime.Evaluate((Time.time - startTime) / ForceLifeTime) * Time.deltaTime * Force;
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = target.position;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num2;
			particles[i].velocity += vector2;
		}
		ps.SetParticles(particles, num);
	}
}
public class RFX1_ParticleInfinite : MonoBehaviour
{
	public float Delay = 3f;

	private ParticleSystem ps;

	private ParticleSystem.MainModule main;

	private float oldSimulation;

	private void OnEnable()
	{
		if (ps == null)
		{
			ps = GetComponent<ParticleSystem>();
			main = ps.main;
			oldSimulation = main.simulationSpeed;
		}
		else
		{
			main.simulationSpeed = oldSimulation;
		}
		CancelInvoke("UpdateParticles");
		Invoke("UpdateParticles", Delay);
	}

	private void UpdateParticles()
	{
		main.simulationSpeed = 0f;
	}
}
public class RFX1_ParticlePositionPoint : MonoBehaviour
{
	[HideInInspector]
	public Vector3 Position;

	public RFX1_ShieldCollisionTrigger ShieldCollisionTrigger;

	public float Force = 1f;

	public AnimationCurve ForceByTime = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float ForceLifeTime = 1f;

	private bool canUpdate;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private float startTime;

	private void Start()
	{
		ShieldCollisionTrigger.CollisionEnter += ShieldCollisionTrigger_CollisionEnter;
		ShieldCollisionTrigger.Detected += ShieldCollisionTrigger_Detected;
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
	}

	private void ShieldCollisionTrigger_Detected(object sender, RFX1_ShieldDetectInfo e)
	{
		if (Physics.Raycast(e.DetectedGameObject.transform.position, e.DetectedGameObject.transform.forward, out var hitInfo, 10f))
		{
			Position = hitInfo.point;
			ManualOnEnable();
		}
	}

	private void ShieldCollisionTrigger_CollisionEnter(object sender, RFX1_ShieldCollisionInfo e)
	{
		Position = e.Hit.point;
		ManualOnEnable();
	}

	public void ManualOnEnable()
	{
		CancelInvoke("ManualOnDisable");
		startTime = Time.time;
		canUpdate = true;
		Invoke("ManualOnDisable", ForceLifeTime);
	}

	private void ManualOnDisable()
	{
		canUpdate = false;
	}

	private void LateUpdate()
	{
		if (canUpdate)
		{
			int maxParticles = mainModule.maxParticles;
			if (particles == null || particles.Length < maxParticles)
			{
				particles = new ParticleSystem.Particle[maxParticles];
			}
			ps.GetParticles(particles);
			float num = ForceByTime.Evaluate((Time.time - startTime) / ForceLifeTime) * Time.deltaTime * Force;
			Vector3 vector = Vector3.zero;
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
			{
				vector = base.transform.InverseTransformPoint(Position);
			}
			if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
			{
				vector = Position;
			}
			int particleCount = ps.particleCount;
			for (int i = 0; i < particleCount; i++)
			{
				Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num;
				particles[i].position += vector2;
			}
			ps.SetParticles(particles, particleCount);
		}
	}
}
public class RFX1_RandomRotate : MonoBehaviour
{
	public int x = 300;

	public int y = 300;

	public int z = 300;

	private float rangeX;

	private float rangeY;

	private float rangeZ;

	private void Start()
	{
		rangeX = (float)UnityEngine.Random.Range(0, 10000) / 100f;
		rangeY = (float)UnityEngine.Random.Range(0, 10000) / 100f;
		rangeZ = (float)UnityEngine.Random.Range(0, 10000) / 100f;
	}

	private void Update()
	{
		base.transform.Rotate(Time.deltaTime * Mathf.Sin(Time.time + rangeX) * (float)x, Time.deltaTime * Mathf.Sin(Time.time + rangeY) * (float)y, Time.deltaTime * Mathf.Sin(Time.time + rangeZ) * (float)z);
	}
}
public class RFX1_RotationFreeze : MonoBehaviour
{
	public bool LockX = true;

	public bool LockY = true;

	public bool LockZ = true;

	private Vector3 startRotation;

	private void Start()
	{
		startRotation = base.transform.localRotation.eulerAngles;
	}

	private void Update()
	{
		float x = (LockX ? startRotation.x : base.transform.rotation.eulerAngles.x);
		float y = (LockY ? startRotation.y : base.transform.rotation.eulerAngles.y);
		float z = (LockZ ? startRotation.z : base.transform.rotation.eulerAngles.z);
		base.transform.rotation = Quaternion.Euler(x, y, z);
	}
}
public class RFX1_ShieldCollisionTrigger : MonoBehaviour
{
	public float DetectRange;

	public GameObject[] EffectOnCollision;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public float CollisionOffset;

	private const string layerName = "Collision";

	public event EventHandler<RFX1_ShieldCollisionInfo> CollisionEnter;

	public event EventHandler<RFX1_ShieldDetectInfo> Detected;

	private void Start()
	{
	}

	private void Update()
	{
		if (DetectRange < 0.001f)
		{
			return;
		}
		Collider[] array = Physics.OverlapSphere(base.transform.position, DetectRange);
		foreach (Collider collider in array)
		{
			if (collider.name.EndsWith("Collision"))
			{
				this.Detected?.Invoke(this, new RFX1_ShieldDetectInfo
				{
					DetectedGameObject = collider.gameObject
				});
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawWireSphere(base.transform.position, DetectRange);
		}
	}

	public void OnCollision(RaycastHit hit, GameObject sender = null)
	{
		this.CollisionEnter?.Invoke(this, new RFX1_ShieldCollisionInfo
		{
			Hit = hit
		});
		GameObject[] effectOnCollision = EffectOnCollision;
		for (int i = 0; i < effectOnCollision.Length; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(effectOnCollision[i], hit.point + hit.normal * CollisionOffset, default(Quaternion));
			gameObject.transform.LookAt(hit.point + hit.normal + hit.normal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			UnityEngine.Object.Destroy(gameObject, DestroyTimeDelay);
		}
	}
}
public class RFX1_ShieldCollisionInfo : EventArgs
{
	public RaycastHit Hit;
}
public class RFX1_ShieldDetectInfo : EventArgs
{
	public GameObject DetectedGameObject;
}
public class RFX1_SimpleDecal : MonoBehaviour
{
	public float Offset = 0.05f;

	private Transform t;

	private RaycastHit hit;

	private void Awake()
	{
		t = base.transform;
	}

	private void LateUpdate()
	{
		if (Physics.Raycast(t.parent.position + Vector3.up / 2f, Vector3.down, out hit))
		{
			base.transform.position = hit.point + Vector3.up * Offset;
			base.transform.rotation = Quaternion.LookRotation(-hit.normal);
		}
	}
}
public class RFX1_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		Invoke("ActivateGO", Delay);
	}

	private void ActivateGO()
	{
		ActivatedGameObject.SetActive(value: true);
	}

	private void OnDisable()
	{
		CancelInvoke("ActivateGO");
	}
}
public enum RFX1_TextureShaderProperties
{
	_MainTex,
	_DistortTex,
	_Mask,
	_Cutout,
	_CutoutTex,
	_Bump,
	_BumpTex,
	_EmissionTex
}
public class RFX1_TransformMotion : MonoBehaviour, IGameObjectPoolable
{
	public enum RFX4_SimulationSpace
	{
		Local,
		World
	}

	public class RFX1_CollisionInfo : EventArgs
	{
		public RaycastHit Hit;
	}

	public float Distance = 30f;

	public float Speed = 1f;

	public float TimeDelay;

	public float RandomMoveRadius;

	public float RandomMoveSpeedScale;

	public GameObject Target;

	public LayerMask CollidesWith = -1;

	public GameObject[] EffectsOnCollision;

	public GameObjectPool EffectsPoolOnCollision;

	public float CollisionOffset;

	public float LifespanAfterCollision = 5f;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public bool CollisionEffectInTargetSpace;

	public GameObject[] DeactivatedObjectsOnCollision;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances;

	private Vector3 startPosition;

	private Vector3 startPositionLocal;

	private Transform t;

	private Transform targetT;

	private Vector3 oldPos;

	private bool isCollided;

	private bool isOutDistance;

	private Quaternion startQuaternion;

	private float currentDelay;

	private const float RayCastTolerance = 0.15f;

	private bool isInitialized;

	private bool dropFirstFrameForFixUnityBugWithParticles;

	private Vector3 randomTimeOffset;

	public GameObjectRuntimePool Pool { get; set; }

	public event EventHandler<RFX1_CollisionInfo> CollisionEnter;

	private void Start()
	{
		t = base.transform;
		if (Target != null)
		{
			targetT = Target.transform;
		}
		startQuaternion = t.rotation;
		startPositionLocal = t.localPosition;
		startPosition = t.position;
		oldPos = t.TransformPoint(startPositionLocal);
		Initialize();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void OnDisable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		isCollided = false;
		isOutDistance = false;
		currentDelay = 0f;
		startQuaternion = t.rotation;
		if (Pool != null)
		{
			startPositionLocal = t.localPosition;
			startPosition = t.position;
			oldPos = startPosition;
		}
		else
		{
			t.localPosition = startPositionLocal;
			oldPos = t.TransformPoint(startPositionLocal);
		}
		OnCollisionDeactivateBehaviour(active: true);
		dropFirstFrameForFixUnityBugWithParticles = true;
		randomTimeOffset = UnityEngine.Random.insideUnitSphere * 10f;
	}

	private void Update()
	{
		if (!dropFirstFrameForFixUnityBugWithParticles)
		{
			UpdateWorldPosition();
		}
		else
		{
			dropFirstFrameForFixUnityBugWithParticles = false;
		}
	}

	private void UpdateWorldPosition()
	{
		currentDelay += Time.deltaTime;
		if (currentDelay < TimeDelay)
		{
			return;
		}
		Vector3 vector = Vector3.zero;
		if (RandomMoveRadius > 0f)
		{
			vector = GetRadiusRandomVector() * RandomMoveRadius;
			if (Target != null)
			{
				if (targetT == null || targetT != Target.transform)
				{
					targetT = Target.transform;
				}
				float num = Vector3.Distance(t.position, targetT.position) / Vector3.Distance(startPosition, targetT.position);
				vector *= num;
			}
		}
		Vector3 vector2 = Vector3.zero;
		Vector3 vector3 = Vector3.zero;
		if (!isCollided && !isOutDistance)
		{
			if (Target == null)
			{
				Vector3 vector4 = (Vector3.forward + vector) * Speed * Time.deltaTime;
				vector2 = t.localRotation * vector4;
				vector3 = startQuaternion * vector4;
			}
			else
			{
				if (targetT == null || targetT != Target.transform)
				{
					targetT = Target.transform;
				}
				vector3 = (vector2 = ((targetT.position - t.position).normalized + vector) * Speed * Time.deltaTime);
			}
		}
		float magnitude = (t.localPosition + vector2 - startPositionLocal).magnitude;
		UnityEngine.Debug.DrawRay(t.position, vector3.normalized * (Distance - magnitude));
		if (!isCollided && Physics.Raycast(t.position, vector3.normalized, out var hitInfo, Distance, CollidesWith, QueryTriggerInteraction.Ignore) && vector2.magnitude + 0.15f > hitInfo.distance)
		{
			ActivateCollision(hitInfo);
		}
		if (!isOutDistance && magnitude + 0.15f > Distance)
		{
			isOutDistance = true;
			OnCollisionDeactivateBehaviour(active: false);
			ReturnToPool(LifespanAfterCollision);
			if (Target == null)
			{
				t.localPosition = startPositionLocal + t.localRotation * (Vector3.forward + vector) * Distance;
			}
			else
			{
				Vector3 normalized = (targetT.position - t.position).normalized;
				t.position = startPosition + normalized * Distance;
			}
			oldPos = t.position;
		}
		else
		{
			t.position = oldPos + vector3;
			oldPos = t.position;
		}
	}

	private Vector3 GetRadiusRandomVector()
	{
		float num = Time.time * RandomMoveSpeedScale + randomTimeOffset.x;
		float x = Mathf.Sin(num / 7f + Mathf.Cos(num / 2f)) * Mathf.Cos(num / 5f + Mathf.Sin(num));
		num = Time.time * RandomMoveSpeedScale + randomTimeOffset.y;
		float y = Mathf.Cos(num / 8f + Mathf.Sin(num / 2f)) * Mathf.Sin(Mathf.Sin(num / 1.2f) + num * 1.2f);
		num = Time.time * RandomMoveSpeedScale + randomTimeOffset.z;
		float z = Mathf.Cos(num * 0.7f + Mathf.Cos(num * 0.5f)) * Mathf.Cos(Mathf.Sin(num * 0.8f) + num * 0.3f);
		return new Vector3(x, y, z);
	}

	private void OnCollisionBehaviour(RaycastHit hit, Transform hitTransform, Vector3 hitNormal)
	{
		this.CollisionEnter?.Invoke(this, new RFX1_CollisionInfo
		{
			Hit = hit
		});
		CollidedInstances.Clear();
		if (EffectsPoolOnCollision != null)
		{
			GameObject gameObject = EffectsPoolOnCollision.Get();
			CollidedInstances.Add(gameObject);
			if (HUE > -0.9f)
			{
				RFX1_EffectSettingColor rFX1_EffectSettingColor = gameObject.AddComponent<RFX1_EffectSettingColor>();
				RFX1_ColorHelper.HSBColor hsbColor = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor.Color);
				hsbColor.H = HUE;
				rFX1_EffectSettingColor.Color = RFX1_ColorHelper.HSVToColor(hsbColor);
			}
			gameObject.transform.position = hit.point + hitNormal * CollisionOffset;
			gameObject.transform.LookAt(hit.point + hitNormal + hitNormal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = (CollisionEffectInTargetSpace ? hitTransform : base.transform);
			}
			gameObject.SetActive(value: true);
			GameObjectPoolContainer.Instance.StartCoroutine(ReturnToPool(gameObject, DestroyTimeDelay));
		}
		GameObject[] effectsOnCollision = EffectsOnCollision;
		for (int i = 0; i < effectsOnCollision.Length; i++)
		{
			GameObject gameObject2 = UnityEngine.Object.Instantiate(effectsOnCollision[i], hit.point + hitNormal * CollisionOffset, default(Quaternion));
			CollidedInstances.Add(gameObject2);
			if (HUE > -0.9f)
			{
				RFX1_EffectSettingColor rFX1_EffectSettingColor2 = gameObject2.AddComponent<RFX1_EffectSettingColor>();
				RFX1_ColorHelper.HSBColor hsbColor2 = RFX1_ColorHelper.ColorToHSV(rFX1_EffectSettingColor2.Color);
				hsbColor2.H = HUE;
				rFX1_EffectSettingColor2.Color = RFX1_ColorHelper.HSVToColor(hsbColor2);
			}
			gameObject2.transform.LookAt(hit.point + hitNormal + hitNormal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject2.transform.parent = (CollisionEffectInTargetSpace ? hitTransform : base.transform);
			}
			UnityEngine.Object.Destroy(gameObject2, DestroyTimeDelay);
		}
		ReturnToPool(LifespanAfterCollision);
	}

	private void OnCollisionDeactivateBehaviour(bool active)
	{
		GameObject[] deactivatedObjectsOnCollision = DeactivatedObjectsOnCollision;
		foreach (GameObject gameObject in deactivatedObjectsOnCollision)
		{
			if (gameObject != null)
			{
				gameObject.SetActive(active);
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			t = base.transform;
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(t.position, t.position + t.forward * Distance);
		}
	}

	public void ReturnToPool(float delay)
	{
		StartCoroutine(ReturnToPoolRoutine(delay));
	}

	private IEnumerator ReturnToPoolRoutine(float delay)
	{
		if (Pool != null)
		{
			yield return new WaitForSeconds(delay);
			Target = null;
			Pool.ReturnToPool(base.gameObject);
		}
	}

	private IEnumerator ReturnToPool(GameObject obj, float delay)
	{
		IGameObjectPoolable iobj = obj.GetComponent<IGameObjectPoolable>();
		if (iobj.Pool != null)
		{
			yield return new WaitForSeconds(delay);
			iobj.Pool.ReturnToPool(obj);
		}
		else
		{
			UnityEngine.Object.Destroy(obj, delay);
		}
	}

	public void SetTarget(GameObject target)
	{
		Target = target;
	}

	public void ActivateCollision(RaycastHit hit, Transform hitTransform = null, Vector3? hitNormal = null)
	{
		isCollided = true;
		t.position = hit.point;
		oldPos = t.position;
		OnCollisionBehaviour(hit, hitTransform ?? hit.transform, hitNormal ?? hit.normal);
		OnCollisionDeactivateBehaviour(active: false);
	}
}
public class RFX1_UVAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public float StartDelay;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsInterpolateFrames;

	public bool IsParticleSystemTrail;

	public RFX1_TextureShaderProperties[] TextureNames = new RFX1_TextureShaderProperties[1];

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private bool startDelayIsBroken;

	private ParticleSystemRenderer pr;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void Update()
	{
		if (startDelayIsBroken)
		{
			ManualUpdate();
		}
	}

	private void ManualUpdate()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void StartDelayFunc()
	{
		startDelayIsBroken = true;
		animationStartTime = Time.time;
	}

	private void InitDefaultVariables()
	{
		InitializeMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		Vector3 zero = Vector3.zero;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = Time.time;
		if (StartDelay > 1E-05f)
		{
			startDelayIsBroken = false;
			Invoke("StartDelayFunc", StartDelay);
		}
		else
		{
			startDelayIsBroken = true;
		}
		if (instanceMaterial != null)
		{
			RFX1_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX1_TextureShaderProperties rFX1_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX1_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX1_TextureShaderProperties.ToString(), zero);
			}
		}
	}

	private void InitializeMaterial()
	{
		if (IsParticleSystemTrail)
		{
			pr = GetComponent<ParticleSystem>().GetComponent<ParticleSystemRenderer>();
			currentRenderer = pr;
			instanceMaterial = pr.trailMaterial;
			if (!instanceMaterial.name.EndsWith("(Instance)"))
			{
				instanceMaterial = new Material(instanceMaterial)
				{
					name = instanceMaterial.name + " (Instance)"
				};
			}
			pr.trailMaterial = instanceMaterial;
			return;
		}
		currentRenderer = GetComponent<Renderer>();
		if (currentRenderer == null)
		{
			projector = GetComponent<Projector>();
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void UpdateMaterial()
	{
		if (currentRenderer == null)
		{
			if (projector != null)
			{
				if (!projector.material.name.EndsWith("(Instance)"))
				{
					projector.material = new Material(projector.material)
					{
						name = projector.material.name + " (Instance)"
					};
				}
				instanceMaterial = projector.material;
			}
		}
		else if (!IsParticleSystemTrail)
		{
			instanceMaterial = currentRenderer.material;
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)((Time.time - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			RFX1_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX1_TextureShaderProperties rFX1_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX1_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX1_TextureShaderProperties.ToString(), value);
			}
		}
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += Time.deltaTime;
		int num = previousIndex + 1;
		if (num == totalFrames)
		{
			num = previousIndex;
		}
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_Tex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
[ExecuteInEditMode]
public class RFX4_LocalSpaceFix : MonoBehaviour
{
	private void Update()
	{
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		ParticleSystemRenderer component = GetComponent<ParticleSystemRenderer>();
		if (component != null)
		{
			if (UnityEngine.Application.isPlaying)
			{
				component.material.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
			}
			else
			{
				component.sharedMaterial.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
			}
		}
	}
}
public class RFX4_AudioCurves : MonoBehaviour
{
	public AnimationCurve AudioCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private AudioSource audioSource;

	private float startVolume;

	private void Awake()
	{
		audioSource = GetComponent<AudioSource>();
		startVolume = audioSource.volume;
		audioSource.volume = AudioCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float volume = AudioCurve.Evaluate(num / GraphTimeMultiplier) * startVolume;
			audioSource.volume = volume;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_LightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public bool UseShadowsIfPossible;

	[HideInInspector]
	public bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
			lightSource.shadows = (UseShadowsIfPossible ? LightShadows.Soft : LightShadows.None);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_PhysicsForceCurves : MonoBehaviour
{
	public float ForceRadius = 5f;

	public float ForceMultiplier = 1f;

	public AnimationCurve ForceCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public ForceMode ForceMode;

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	public float DestoryDistance = -1f;

	public bool UseDistanceScale;

	public AnimationCurve DistanceScaleCurve = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public bool UseUPVector;

	public AnimationCurve DragCurve = AnimationCurve.EaseInOut(0f, 0f, 0f, 1f);

	public float DragGraphTimeMultiplier = -1f;

	public float DragGraphIntensityMultiplier = -1f;

	public string AffectedName;

	[HideInInspector]
	public float forceAdditionalMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private void Awake()
	{
		t = base.transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		forceAdditionalMultiplier = 1f;
	}

	private void FixedUpdate()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = ForceCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			Collider[] array = Physics.OverlapSphere(t.position, ForceRadius);
			foreach (Collider collider in array)
			{
				Rigidbody component = collider.GetComponent<Rigidbody>();
				if (!(component == null) && (AffectedName.Length <= 0 || collider.name.Contains(AffectedName)))
				{
					Vector3 vector;
					float num3;
					if (UseUPVector)
					{
						vector = Vector3.up;
						num3 = 1f - Mathf.Clamp01(collider.transform.position.y - t.position.y);
						num3 *= 1f - (collider.transform.position - t.position).magnitude / ForceRadius;
					}
					else
					{
						vector = collider.transform.position - t.position;
						num3 = 1f - vector.magnitude / ForceRadius;
					}
					if (UseDistanceScale)
					{
						collider.transform.localScale = DistanceScaleCurve.Evaluate(num3) * collider.transform.localScale;
					}
					if (DestoryDistance > 0f && vector.magnitude < DestoryDistance)
					{
						UnityEngine.Object.Destroy(collider.gameObject);
					}
					component.AddForce(vector.normalized * num3 * ForceMultiplier * num2 * forceAdditionalMultiplier, ForceMode);
					if (DragGraphTimeMultiplier > 0f)
					{
						component.drag = DragCurve.Evaluate(num / DragGraphTimeMultiplier) * DragGraphIntensityMultiplier;
						component.angularDrag = component.drag / 10f;
					}
				}
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.yellow;
		Gizmos.DrawWireSphere(base.transform.position, ForceRadius);
	}
}
public class RFX4_ScaleCurves : MonoBehaviour
{
	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private Transform t;

	private int nameId;

	private Projector proj;

	private Vector3 startScale;

	private void Awake()
	{
		t = GetComponent<Transform>();
		startScale = t.localScale;
		t.localScale = Vector3.zero;
		proj = GetComponent<Projector>();
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		t.localScale = Vector3.zero;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			t.localScale = num2 * startScale;
			if (proj != null)
			{
				proj.orthographicSize = num2;
			}
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_ShaderColorGradient : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderColorProperty;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	public bool IsLoop;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public bool canUpdate;

	private int propertyID;

	private float startTime;

	private Color startColor;

	private bool isInitialized;

	private string shaderProperty;

	private MaterialPropertyBlock props;

	private Renderer rend;

	private void Awake()
	{
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<Renderer>();
		}
		shaderProperty = ShaderColorProperty.ToString();
		propertyID = Shader.PropertyToID(shaderProperty);
		startColor = rend.sharedMaterial.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		rend.GetPropertyBlock(props);
		startColor = rend.sharedMaterial.GetColor(propertyID);
		props.SetColor(propertyID, startColor * Color.Evaluate(0f));
		rend.SetPropertyBlock(props);
	}

	private void Update()
	{
		rend.GetPropertyBlock(props);
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color color = Color.Evaluate(num / TimeMultiplier);
			if (HUE > -0.9f)
			{
				color = RFX4_ColorHelper.ConvertRGBColorByHUE(color, HUE);
				startColor = RFX4_ColorHelper.ConvertRGBColorByHUE(startColor, HUE);
			}
			props.SetColor(propertyID, color * startColor);
		}
		if (num >= TimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
		rend.SetPropertyBlock(props);
	}
}
public class RFX4_ShaderFloatCurve : MonoBehaviour
{
	public RFX4_ShaderProperties ShaderFloatProperty = RFX4_ShaderProperties._Cutout;

	public AnimationCurve FloatCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private int propertyID;

	private string shaderProperty;

	private bool isInitialized;

	private MaterialPropertyBlock props;

	private Renderer rend;

	private void Awake()
	{
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<Renderer>();
		}
		shaderProperty = ShaderFloatProperty.ToString();
		propertyID = Shader.PropertyToID(shaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
		rend.GetPropertyBlock(props);
		float value = FloatCurve.Evaluate(0f) * GraphIntensityMultiplier;
		props.SetFloat(propertyID, value);
		rend.SetPropertyBlock(props);
	}

	private void Update()
	{
		rend.GetPropertyBlock(props);
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float value = FloatCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			props.SetFloat(propertyID, value);
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
		rend.SetPropertyBlock(props);
	}
}
public enum RFX4_ShaderProperties
{
	_TintColor,
	_Cutoff,
	_Color,
	_EmissionColor,
	_MaskPow,
	_Cutout,
	_Speed,
	_BumpAmt,
	_MainColor,
	_Distortion,
	_FresnelColor
}
public class RFX4_WindCurves : MonoBehaviour
{
	public AnimationCurve WindCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	public bool IsLoop;

	private bool canUpdate;

	private float startTime;

	private WindZone windZone;

	private void Awake()
	{
		windZone = GetComponent<WindZone>();
		windZone.windMain = WindCurve.Evaluate(0f);
		windZone.windMain = 0f - WindCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = WindCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			windZone.windMain = 0f - num2;
		}
		if (num >= GraphTimeMultiplier)
		{
			if (IsLoop)
			{
				startTime = Time.time;
			}
			else
			{
				canUpdate = false;
			}
		}
	}
}
public class RFX4_EffectSettings : MonoBehaviour
{
	[Range(0.1f, 1f)]
	public float ParticlesBudget = 1f;

	public bool UseLightShadows;

	public bool UseFastFlatDecalsForMobiles = true;

	public bool UseCustomColor;

	public Color EffectColor = Color.red;

	public bool IsVisible = true;

	public float FadeoutTime = 1.5f;

	public bool UseCollisionDetection = true;

	public bool LimitMaxDistance;

	public float MaxDistnace = -1f;

	public float Mass = 1f;

	public float Speed = 10f;

	public float AirDrag = 0.1f;

	public bool UseGravity = true;

	private const string distortionNamePC = "KriptoFX/RFX4/Distortion";

	private const string distortionNameMobile = "KriptoFX/RFX4/DistortionMobile";

	private bool isCheckedDistortion;

	private bool prevIsVisible;

	private float currentFadeoutTime;

	private Renderer[] renderers;

	private Renderer[] skinRenderers;

	private Light[] lights;

	private ParticleSystem[] particleSystems;

	private AudioSource[] audioSources;

	private string[] colorProperties = new string[3] { "_TintColor", "_Color", "_MainColor" };

	private void Awake()
	{
		prevIsVisible = IsVisible;
		CacheRenderers();
	}

	private void OnEnable()
	{
		if (ParticlesBudget < 0.99f)
		{
			ChangeParticlesBudget(ParticlesBudget);
		}
		if (UseCustomColor)
		{
			ChangeParticleColor();
		}
		if (UseFastFlatDecalsForMobiles)
		{
			SetFlatDecals();
		}
		if (!UseLightShadows || IsMobilePlatform())
		{
			DisableShadows();
		}
	}

	private void Update()
	{
		if (prevIsVisible != IsVisible)
		{
			prevIsVisible = IsVisible;
			if (!IsVisible)
			{
				StartCoroutine(Fadeout());
			}
			else
			{
				Fadein();
			}
		}
	}

	private void ChangeParticlesBudget(float particlesMul)
	{
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj in componentsInChildren)
		{
			ParticleSystem.MainModule main = obj.main;
			main.maxParticles = Mathf.Max(1, (int)((float)main.maxParticles * particlesMul));
			ParticleSystem.EmissionModule emission = obj.emission;
			if (!emission.enabled)
			{
				continue;
			}
			ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
			if (rateOverTime.constantMin > 1f)
			{
				rateOverTime.constantMin *= particlesMul;
			}
			if (rateOverTime.constantMax > 1f)
			{
				rateOverTime.constantMax *= particlesMul;
			}
			emission.rateOverTime = rateOverTime;
			ParticleSystem.MinMaxCurve rateOverDistance = emission.rateOverDistance;
			if (rateOverDistance.constantMin > 1f)
			{
				if (rateOverDistance.constantMin > 1f)
				{
					rateOverDistance.constantMin *= particlesMul;
				}
				if (rateOverDistance.constantMax > 1f)
				{
					rateOverDistance.constantMax *= particlesMul;
				}
				emission.rateOverDistance = rateOverDistance;
			}
		}
	}

	public void ChangeParticleColor()
	{
		UnityEngine.Debug.Log("ColorChanged");
		float h = RFX4_ColorHelper.ColorToHSV(EffectColor).H;
		RFX4_ColorHelper.ChangeObjectColorByHUE(base.gameObject, h);
		RFX4_PhysicsMotion componentInChildren = GetComponentInChildren<RFX4_PhysicsMotion>();
		if (componentInChildren != null)
		{
			componentInChildren.HUE = h;
		}
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>();
		if (componentInChildren2 != null)
		{
			componentInChildren2.HUE = h;
		}
	}

	public void SetFlatDecals()
	{
		RFX4_Decal[] componentsInChildren = GetComponentsInChildren<RFX4_Decal>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].IsScreenSpace = false;
		}
	}

	public void DisableShadows()
	{
		Light[] componentsInChildren = GetComponentsInChildren<Light>();
		foreach (Light obj in componentsInChildren)
		{
			RFX4_LightCurves component = obj.GetComponent<RFX4_LightCurves>();
			if (component != null && component.UseShadowsIfPossible)
			{
				component.UseShadowsIfPossible = false;
			}
			obj.shadows = LightShadows.None;
		}
		RFX4_ParticleLight[] componentsInChildren2 = GetComponentsInChildren<RFX4_ParticleLight>();
		for (int i = 0; i < componentsInChildren2.Length; i++)
		{
			componentsInChildren2[i].UseShadows = false;
		}
	}

	private bool IsMobilePlatform()
	{
		bool result = false;
		if (UnityEngine.Application.isMobilePlatform)
		{
			result = true;
		}
		return result;
	}

	private IEnumerator Fadeout()
	{
		currentFadeoutTime = Time.time;
		while (Time.time - currentFadeoutTime < FadeoutTime)
		{
			ChangeAlphaFade();
			yield return new WaitForSeconds(1f / 30f);
		}
	}

	private void UpdateAlphaByProperties(Material mat, float overrideAlpha = -1f)
	{
		string[] array = colorProperties;
		foreach (string text in array)
		{
			if (mat.HasProperty(text))
			{
				Color color = mat.GetColor(text);
				if (overrideAlpha > -0.5f)
				{
					color.a = overrideAlpha;
				}
				else
				{
					color.a -= 1f / 30f / FadeoutTime;
				}
				mat.SetColor(text, color);
			}
		}
	}

	private void ChangeAlphaFade()
	{
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			if (!(renderer.GetComponent<ParticleSystem>() != null))
			{
				Material[] materials = renderer.materials;
				for (int j = 0; j < materials.Length; j++)
				{
					UpdateAlphaByProperties(materials[j]);
				}
			}
		}
		array = skinRenderers;
		for (int i = 0; i < array.Length; i++)
		{
			Material[] materials2 = array[i].materials;
			for (int k = 0; k < materials2.Length; k++)
			{
				UpdateAlphaByProperties(materials2[k]);
			}
		}
		for (int l = 0; l < lights.Length; l++)
		{
			lights[l].intensity -= 1f / 30f / FadeoutTime;
		}
		ParticleSystem[] array2 = particleSystems;
		foreach (ParticleSystem particleSystem in array2)
		{
			if (!particleSystem.isStopped)
			{
				particleSystem.Stop();
			}
		}
		AudioSource[] array3 = audioSources;
		for (int i = 0; i < array3.Length; i++)
		{
			array3[i].volume -= 1f / 30f / FadeoutTime;
		}
	}

	private void CacheRenderers()
	{
		renderers = GetComponentsInChildren<Renderer>(includeInactive: true);
		Renderer[] componentsInChildren = GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		skinRenderers = componentsInChildren;
		lights = GetComponentsInChildren<Light>(includeInactive: true);
		particleSystems = GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		audioSources = GetComponentsInChildren<AudioSource>();
	}

	private void Fadein()
	{
		Transform[] componentsInChildren = base.gameObject.GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			obj.gameObject.SetActive(value: false);
			obj.gameObject.SetActive(value: true);
		}
		Renderer[] array = renderers;
		foreach (Renderer renderer in array)
		{
			if (!(renderer.GetComponent<ParticleSystem>() != null))
			{
				Material[] materials = renderer.materials;
				for (int j = 0; j < materials.Length; j++)
				{
					UpdateAlphaByProperties(materials[j], 1f);
				}
			}
		}
		AudioSource[] array2 = audioSources;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].volume = 1f;
		}
	}
}
public class RFX4_CollisionPropertyDeactiavtion : MonoBehaviour
{
	public float DeactivateTimeDelay = 1f;

	private float startTime;

	private WindZone windZone;

	private ParticleSystem ps;

	private ParticleSystem.CollisionModule collisionModule;

	private void Awake()
	{
		ps = GetComponent<ParticleSystem>();
		collisionModule = ps.collision;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		collisionModule.enabled = true;
	}

	private void Update()
	{
		if (Time.time - startTime >= DeactivateTimeDelay)
		{
			collisionModule.enabled = false;
		}
	}
}
public class RFX4_ParticleGravityDelay : MonoBehaviour
{
	public AnimationCurve GravityByTime = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float TimeMultiplier = 3f;

	[Space]
	public float GravityMultiplierMin = 1f;

	public float GravityMultiplierMax = 1f;

	private ParticleSystem.MainModule main;

	private float startTime;

	private float startMinGrav;

	private float startMaxGrav;

	private void Awake()
	{
		main = GetComponent<ParticleSystem>().main;
		startMinGrav = main.gravityModifier.constantMin;
		startMaxGrav = main.gravityModifier.constantMax;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		ParticleSystem.MinMaxCurve gravityModifier = main.gravityModifier;
		gravityModifier.constantMin = startMinGrav;
		gravityModifier.constantMax = startMaxGrav;
		main.gravityModifier = gravityModifier;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (num < TimeMultiplier)
		{
			ParticleSystem.MinMaxCurve gravityModifier = main.gravityModifier;
			float num2 = GravityByTime.Evaluate(num / TimeMultiplier);
			gravityModifier.constantMin = num2 * GravityMultiplierMin;
			gravityModifier.constantMax = num2 * GravityMultiplierMax;
			main.gravityModifier = gravityModifier;
		}
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleLight : MonoBehaviour
{
	public float LightIntencityMultiplayer = 1f;

	public bool UseShadows;

	public int LightsLimit = 10;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private Light[] lights;

	private bool isLocalSpace;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		ParticleSystem.MainModule main = ps.main;
		if (main.maxParticles > LightsLimit)
		{
			main.maxParticles = LightsLimit;
		}
		particles = new ParticleSystem.Particle[main.maxParticles];
		isLocalSpace = ps.main.simulationSpace == ParticleSystemSimulationSpace.Local;
		lights = new Light[main.maxParticles];
		for (int i = 0; i < lights.Length; i++)
		{
			GameObject gameObject = new GameObject("ParticleLight" + i);
			gameObject.hideFlags = HideFlags.DontSave;
			lights[i] = gameObject.AddComponent<Light>();
			lights[i].transform.parent = base.transform;
			lights[i].intensity = 0f;
			lights[i].shadows = (UseShadows ? LightShadows.Soft : LightShadows.None);
		}
	}

	private void Update()
	{
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			lights[i].gameObject.SetActive(value: true);
			lights[i].transform.position = (isLocalSpace ? ps.transform.TransformPoint(particles[i].position) : particles[i].position);
			lights[i].color = particles[i].GetCurrentColor(ps);
			lights[i].range = particles[i].GetCurrentSize(ps);
			lights[i].intensity = (float)(int)particles[i].GetCurrentColor(ps).a / 255f * LightIntencityMultiplayer;
			lights[i].shadows = (UseShadows ? LightShadows.Soft : LightShadows.None);
			if (lights[i].intensity < 0.01f)
			{
				lights[i].gameObject.SetActive(value: false);
			}
		}
		for (int j = num; j < particles.Length; j++)
		{
			lights[j].gameObject.SetActive(value: false);
		}
	}
}
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_ParticleTrail : MonoBehaviour
{
	public GameObject Target;

	public Vector2 DefaultSizeMultiplayer = Vector2.one;

	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	public bool UseShaderMaterial;

	public Material TrailMaterial;

	public bool UseColorOverLifeTime;

	public Gradient ColorOverLifeTime = new Gradient();

	public RFX4_ShaderProperties colorShaderProperty;

	public float ColorLifeTime = 1f;

	public bool UseUvAnimation;

	public int TilesX = 4;

	public int TilesY = 4;

	public int FPS = 30;

	public bool IsLoop = true;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public bool GetVelocityFromParticleSystem;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0.01f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves = true;

	private Dictionary<int, LineRenderer> dict = new Dictionary<int, LineRenderer>();

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private TrailRenderer[] trails;

	private Color psColor;

	private Transform targetT;

	private int layer;

	private bool isLocalSpace = true;

	private Transform t;

	private void OnEnable()
	{
		if (Target != null)
		{
			targetT = Target.transform;
		}
		ps = GetComponent<ParticleSystem>();
		t = base.transform;
		isLocalSpace = ps.main.simulationSpace == ParticleSystemSimulationSpace.Local;
		particles = new ParticleSystem.Particle[ps.main.maxParticles];
		if (TrailMaterial != null)
		{
			psColor = TrailMaterial.GetColor(TrailMaterial.HasProperty("_TintColor") ? "_TintColor" : "_Color");
		}
		layer = base.gameObject.layer;
		Update();
	}

	private void ClearTrails()
	{
		TrailRenderer[] array = trails;
		foreach (TrailRenderer trailRenderer in array)
		{
			if (trailRenderer != null)
			{
				UnityEngine.Object.Destroy(trailRenderer.gameObject);
			}
		}
		trails = null;
	}

	private void Update()
	{
		if (dict.Count > 10)
		{
			RemoveEmptyTrails();
		}
		int num = ps.GetParticles(particles);
		for (int i = 0; i < num; i++)
		{
			int hashCode = particles[i].rotation3D.GetHashCode();
			if (!dict.ContainsKey(hashCode))
			{
				GameObject gameObject = new GameObject(hashCode.ToString());
				gameObject.transform.parent = base.transform;
				gameObject.transform.position = ps.transform.position;
				if (TrailLifeTime > 1E-05f)
				{
					UnityEngine.Object.Destroy(gameObject, TrailLifeTime + VertexLifeTime);
				}
				gameObject.layer = layer;
				LineRenderer lineRenderer = gameObject.AddComponent<LineRenderer>();
				lineRenderer.startWidth = 0f;
				lineRenderer.endWidth = 0f;
				lineRenderer.sharedMaterial = TrailMaterial;
				lineRenderer.useWorldSpace = false;
				if (UseColorOverLifeTime)
				{
					RFX4_ShaderColorGradient rFX4_ShaderColorGradient = gameObject.AddComponent<RFX4_ShaderColorGradient>();
					rFX4_ShaderColorGradient.Color = ColorOverLifeTime;
					rFX4_ShaderColorGradient.TimeMultiplier = ColorLifeTime;
					rFX4_ShaderColorGradient.ShaderColorProperty = colorShaderProperty;
				}
				if (UseUvAnimation)
				{
					RFX4_UVAnimation rFX4_UVAnimation = gameObject.AddComponent<RFX4_UVAnimation>();
					rFX4_UVAnimation.TilesX = TilesX;
					rFX4_UVAnimation.TilesY = TilesY;
					rFX4_UVAnimation.FPS = FPS;
					rFX4_UVAnimation.IsLoop = IsLoop;
				}
				dict.Add(hashCode, lineRenderer);
				continue;
			}
			LineRenderer lineRenderer2 = dict[hashCode];
			if (!(lineRenderer2 == null))
			{
				if (!lineRenderer2.useWorldSpace)
				{
					lineRenderer2.useWorldSpace = true;
					InitTrailRenderer(lineRenderer2.gameObject);
				}
				Vector2 vector = DefaultSizeMultiplayer * particles[i].GetCurrentSize(ps);
				lineRenderer2.startWidth = vector.y;
				lineRenderer2.endWidth = vector.x;
				if (Target != null)
				{
					float num2 = 1f - particles[i].remainingLifetime / particles[i].startLifetime;
					Vector3 a = Vector3.Lerp(particles[i].position, targetT.position, num2);
					lineRenderer2.transform.position = Vector3.Lerp(a, targetT.position, Time.deltaTime * num2);
				}
				else
				{
					lineRenderer2.transform.position = (isLocalSpace ? ps.transform.TransformPoint(particles[i].position) : particles[i].position);
				}
				lineRenderer2.transform.rotation = t.rotation;
				Color32 currentColor = particles[i].GetCurrentColor(ps);
				Color endColor = (lineRenderer2.startColor = psColor * currentColor);
				lineRenderer2.endColor = endColor;
			}
		}
		ps.SetParticles(particles, num);
	}

	private void InitTrailRenderer(GameObject go)
	{
		RFX4_TrailRenderer rFX4_TrailRenderer = go.AddComponent<RFX4_TrailRenderer>();
		rFX4_TrailRenderer.Amplitude = Amplitude;
		rFX4_TrailRenderer.Drag = Drag;
		rFX4_TrailRenderer.Gravity = Gravity;
		rFX4_TrailRenderer.Force = Force;
		rFX4_TrailRenderer.Frequency = Frequency;
		rFX4_TrailRenderer.InheritVelocity = InheritVelocity;
		rFX4_TrailRenderer.VertexLifeTime = VertexLifeTime;
		rFX4_TrailRenderer.TrailLifeTime = TrailLifeTime;
		rFX4_TrailRenderer.MinVertexDistance = MinVertexDistance;
		rFX4_TrailRenderer.OffsetSpeed = OffsetSpeed;
		rFX4_TrailRenderer.SmoothCurves = SmoothCurves;
		rFX4_TrailRenderer.AproximatedFlyDistance = AproximatedFlyDistance;
		rFX4_TrailRenderer.VelocityByDistance = VelocityByDistance;
		rFX4_TrailRenderer.RandomTurbulenceOffset = RandomTurbulenceOffset;
		rFX4_TrailRenderer.TurbulenceStrength = TurbulenceStrength;
	}

	private void RemoveEmptyTrails()
	{
		for (int i = 0; i < dict.Count; i++)
		{
			KeyValuePair<int, LineRenderer> keyValuePair = dict.ElementAt(i);
			if (keyValuePair.Value == null)
			{
				dict.Remove(keyValuePair.Key);
			}
		}
	}

	private void OnDisable()
	{
		foreach (KeyValuePair<int, LineRenderer> item in dict)
		{
			if (item.Value != null)
			{
				UnityEngine.Object.Destroy(item.Value.gameObject);
			}
		}
		dict.Clear();
	}
}
[ExecuteInEditMode]
[RequireComponent(typeof(ParticleSystem))]
public class RFX4_Turbulence : MonoBehaviour
{
	public enum MoveMethodEnum
	{
		Position,
		Velocity,
		RelativePosition
	}

	public enum PerfomanceEnum
	{
		High,
		Low
	}

	public float TurbulenceStrenght = 1f;

	public bool TurbulenceByTime;

	public float TimeDelay;

	public AnimationCurve TurbulenceStrengthByTime = AnimationCurve.EaseInOut(1f, 1f, 1f, 1f);

	public Vector3 Frequency = new Vector3(1f, 1f, 1f);

	public Vector3 OffsetSpeed = new Vector3(0.5f, 0.5f, 0.5f);

	public Vector3 Amplitude = new Vector3(5f, 5f, 5f);

	public Vector3 GlobalForce;

	public bool UseGlobalOffset = true;

	public MoveMethodEnum MoveMethod;

	public PerfomanceEnum Perfomance;

	public float ThreshholdSpeed;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	private float lastStopTime;

	private Vector3 currentOffset;

	private float deltaTime;

	private float deltaTimeLastUpdateOffset;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private float time;

	private int currentSplit;

	private float fpsTime;

	private int FPS;

	private int splitUpdate = 2;

	private PerfomanceEnum perfomanceOldSettings;

	private bool skipFrame;

	private Transform t;

	private float currentDelay;

	private void Start()
	{
		t = base.transform;
		particleSys = GetComponent<ParticleSystem>();
		if (particleArray == null || particleArray.Length < particleSys.main.maxParticles)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		perfomanceOldSettings = Perfomance;
		UpdatePerfomanceSettings();
	}

	private void OnEnable()
	{
		currentDelay = 0f;
	}

	private void Update()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			deltaTime = Time.realtimeSinceStartup - lastStopTime;
			lastStopTime = Time.realtimeSinceStartup;
		}
		else
		{
			deltaTime = Time.deltaTime;
		}
		currentDelay += deltaTime;
		if (currentDelay < TimeDelay)
		{
			return;
		}
		if (!UseGlobalOffset)
		{
			currentOffset += OffsetSpeed * deltaTime;
		}
		else if (UnityEngine.Application.isPlaying)
		{
			currentOffset = OffsetSpeed * Time.time;
		}
		else
		{
			currentOffset = OffsetSpeed * Time.realtimeSinceStartup;
		}
		if (Perfomance != perfomanceOldSettings)
		{
			perfomanceOldSettings = Perfomance;
			UpdatePerfomanceSettings();
		}
		time += deltaTime;
		if (QualitySettings.vSyncCount == 2)
		{
			UpdateTurbulence();
		}
		else if (QualitySettings.vSyncCount == 1)
		{
			if (Perfomance == PerfomanceEnum.Low)
			{
				if (skipFrame)
				{
					UpdateTurbulence();
				}
				skipFrame = !skipFrame;
			}
			if (Perfomance == PerfomanceEnum.High)
			{
				UpdateTurbulence();
			}
		}
		else if (QualitySettings.vSyncCount == 0)
		{
			if (time >= fpsTime)
			{
				time = 0f;
				UpdateTurbulence();
				deltaTimeLastUpdateOffset = 0f;
			}
			else
			{
				deltaTimeLastUpdateOffset += deltaTime;
			}
		}
	}

	private void UpdatePerfomanceSettings()
	{
		if (Perfomance == PerfomanceEnum.High)
		{
			FPS = 80;
			splitUpdate = 2;
		}
		if (Perfomance == PerfomanceEnum.Low)
		{
			FPS = 40;
			splitUpdate = 2;
		}
		fpsTime = 1f / (float)FPS;
	}

	private void UpdateTurbulence()
	{
		int particles = particleSys.GetParticles(particleArray);
		int num = 1;
		int num2;
		int num3;
		if (splitUpdate > 1)
		{
			num2 = particles / splitUpdate * currentSplit;
			num3 = Mathf.CeilToInt((float)particles * 1f / (float)splitUpdate * ((float)currentSplit + 1f));
			num = splitUpdate;
		}
		else
		{
			num2 = 0;
			num3 = particles;
		}
		for (int i = num2; i < num3; i++)
		{
			ParticleSystem.Particle particle = particleArray[i];
			float num4 = 1f;
			if (TurbulenceByTime)
			{
				num4 = TurbulenceStrengthByTime.Evaluate(1f - particle.remainingLifetime / particle.startLifetime);
			}
			if (ThreshholdSpeed > 1E-07f && num4 < ThreshholdSpeed)
			{
				return;
			}
			Vector3 position = particle.position;
			position.x /= Frequency.x + 1E-07f;
			position.y /= Frequency.y + 1E-07f;
			position.z /= Frequency.z + 1E-07f;
			Vector3 vector = default(Vector3);
			float num5 = deltaTime + deltaTimeLastUpdateOffset;
			vector.x = (Mathf.PerlinNoise(position.z - currentOffset.z, position.y - currentOffset.y) * 2f - 1f) * Amplitude.x * num5;
			vector.y = (Mathf.PerlinNoise(position.x - currentOffset.x, position.z - currentOffset.z) * 2f - 1f) * Amplitude.y * num5;
			vector.z = (Mathf.PerlinNoise(position.y - currentOffset.y, position.x - currentOffset.x) * 2f - 1f) * Amplitude.z * num5;
			float num6 = TurbulenceStrenght * num4 * (float)num;
			float num7 = 1f;
			float num8 = Mathf.Abs((particle.position - t.position).magnitude);
			if (AproximatedFlyDistance > 0f)
			{
				num7 = VelocityByDistance.Evaluate(Mathf.Clamp01(num8 / AproximatedFlyDistance));
			}
			vector *= num6;
			if (MoveMethod == MoveMethodEnum.Position)
			{
				particleArray[i].position += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.Velocity)
			{
				particleArray[i].velocity += vector * num7;
			}
			if (MoveMethod == MoveMethodEnum.RelativePosition)
			{
				particleArray[i].position += vector * particleArray[i].velocity.magnitude;
				particleArray[i].velocity = particleArray[i].velocity * 0.85f + vector.normalized * 0.15f * num7 + GlobalForce * num7;
			}
		}
		particleSys.SetParticles(particleArray, particles);
		currentSplit++;
		if (currentSplit >= splitUpdate)
		{
			currentSplit = 0;
		}
	}
}
public class RFX4_CameraShake : MonoBehaviour
{
	public AnimationCurve ShakeCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

	public float Duration = 2f;

	public float Speed = 22f;

	public float Magnitude = 1f;

	public float DistanceForce = 100f;

	public float RotationDamper = 2f;

	public bool IsEnabled = true;

	private bool isPlaying;

	[HideInInspector]
	public bool canUpdate;

	private void PlayShake()
	{
		StopAllCoroutines();
		StartCoroutine(Shake());
	}

	private void Update()
	{
		if (isPlaying && IsEnabled)
		{
			isPlaying = false;
			PlayShake();
		}
	}

	private void OnEnable()
	{
		isPlaying = true;
		if (UnityEngine.Object.FindObjectsOfType(typeof(RFX4_CameraShake)) is RFX4_CameraShake[] array)
		{
			RFX4_CameraShake[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i].canUpdate = false;
			}
		}
		canUpdate = true;
	}

	private IEnumerator Shake()
	{
		float elapsed = 0f;
		Transform camT = Camera.main.transform;
		Vector3 originalCamRotation = camT.rotation.eulerAngles;
		Vector3 direction = (base.transform.position - camT.position).normalized;
		float time = 0f;
		float randomStart = UnityEngine.Random.Range(-1000f, 1000f);
		float distanceDamper = 1f - Mathf.Clamp01((camT.position - base.transform.position).magnitude / DistanceForce);
		Vector3 oldRotation = Vector3.zero;
		while (elapsed < Duration && canUpdate)
		{
			elapsed += Time.deltaTime;
			float num = elapsed / Duration;
			float num2 = ShakeCurve.Evaluate(num) * distanceDamper;
			time += Time.deltaTime * num2;
			camT.position -= direction * Time.deltaTime * Mathf.Sin(time * Speed) * num2 * Magnitude / 2f;
			float num3 = randomStart + Speed * num / 10f;
			float num4 = Mathf.PerlinNoise(num3, 0f) * 2f - 1f;
			float num5 = Mathf.PerlinNoise(1000f + num3, num3 + 1000f) * 2f - 1f;
			float num6 = Mathf.PerlinNoise(0f, num3) * 2f - 1f;
			if (Quaternion.Euler(originalCamRotation + oldRotation) != camT.rotation)
			{
				originalCamRotation = camT.rotation.eulerAngles;
			}
			oldRotation = Mathf.Sin(time * Speed) * num2 * Magnitude * new Vector3(0.5f + num5, 0.3f + num4, 0.3f + num6) * RotationDamper;
			camT.rotation = Quaternion.Euler(originalCamRotation + oldRotation);
			yield return null;
		}
	}
}
public static class RFX4_ColorHelper
{
	public struct HSBColor
	{
		public float H;

		public float S;

		public float B;

		public float A;

		public HSBColor(float h, float s, float b, float a)
		{
			H = h;
			S = s;
			B = b;
			A = a;
		}
	}

	private const float TOLERANCE = 0.0001f;

	private static string[] colorProperties = new string[8] { "_TintColor", "_Color", "_EmissionColor", "_BorderColor", "_ReflectColor", "_RimColor", "_MainColor", "_CoreColor" };

	public static HSBColor ColorToHSV(Color color)
	{
		HSBColor result = new HSBColor(0f, 0f, 0f, color.a);
		float r = color.r;
		float g = color.g;
		float b = color.b;
		float num = Mathf.Max(r, Mathf.Max(g, b));
		if (num <= 0f)
		{
			return result;
		}
		float num2 = Mathf.Min(r, Mathf.Min(g, b));
		float num3 = num - num2;
		if (num > num2)
		{
			if (Math.Abs(g - num) < 0.0001f)
			{
				result.H = (b - r) / num3 * 60f + 120f;
			}
			else if (Math.Abs(b - num) < 0.0001f)
			{
				result.H = (r - g) / num3 * 60f + 240f;
			}
			else if (b > g)
			{
				result.H = (g - b) / num3 * 60f + 360f;
			}
			else
			{
				result.H = (g - b) / num3 * 60f;
			}
			if (result.H < 0f)
			{
				result.H += 360f;
			}
		}
		else
		{
			result.H = 0f;
		}
		result.H *= 0.0027777778f;
		result.S = num3 / num * 1f;
		result.B = num;
		return result;
	}

	public static Color HSVToColor(HSBColor hsbColor)
	{
		float value = hsbColor.B;
		float value2 = hsbColor.B;
		float value3 = hsbColor.B;
		if (Math.Abs(hsbColor.S) > 0.0001f)
		{
			float b = hsbColor.B;
			float num = hsbColor.B * hsbColor.S;
			float num2 = hsbColor.B - num;
			float num3 = hsbColor.H * 360f;
			if (num3 < 60f)
			{
				value = b;
				value2 = num3 * num / 60f + num2;
				value3 = num2;
			}
			else if (num3 < 120f)
			{
				value = (0f - (num3 - 120f)) * num / 60f + num2;
				value2 = b;
				value3 = num2;
			}
			else if (num3 < 180f)
			{
				value = num2;
				value2 = b;
				value3 = (num3 - 120f) * num / 60f + num2;
			}
			else if (num3 < 240f)
			{
				value = num2;
				value2 = (0f - (num3 - 240f)) * num / 60f + num2;
				value3 = b;
			}
			else if (num3 < 300f)
			{
				value = (num3 - 240f) * num / 60f + num2;
				value2 = num2;
				value3 = b;
			}
			else if (num3 <= 360f)
			{
				value = b;
				value2 = num2;
				value3 = (0f - (num3 - 360f)) * num / 60f + num2;
			}
			else
			{
				value = 0f;
				value2 = 0f;
				value3 = 0f;
			}
		}
		return new Color(Mathf.Clamp01(value), Mathf.Clamp01(value2), Mathf.Clamp01(value3), hsbColor.A);
	}

	public static Color ConvertRGBColorByHUE(Color rgbColor, float hue)
	{
		float num = ColorToHSV(rgbColor).B;
		if (num < 0.0001f)
		{
			num = 0.0001f;
		}
		HSBColor hsbColor = ColorToHSV(rgbColor / num);
		hsbColor.H = hue;
		Color result = HSVToColor(hsbColor) * num;
		result.a = rgbColor.a;
		return result;
	}

	public static void ChangeObjectColorByHUE(GameObject go, float hue)
	{
		Renderer[] componentsInChildren = go.GetComponentsInChildren<Renderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			Material material = componentsInChildren[i].material;
			if (material == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name in array)
			{
				if (material.HasProperty(name))
				{
					setMatHUEColor(material, name, hue);
				}
			}
		}
		ParticleSystemRenderer[] componentsInChildren2 = go.GetComponentsInChildren<ParticleSystemRenderer>(includeInactive: true);
		foreach (ParticleSystemRenderer particleSystemRenderer in componentsInChildren2)
		{
			Material trailMaterial = particleSystemRenderer.trailMaterial;
			if (trailMaterial == null)
			{
				continue;
			}
			trailMaterial = (particleSystemRenderer.trailMaterial = new Material(trailMaterial)
			{
				name = trailMaterial.name + " (Instance)"
			});
			string[] array = colorProperties;
			foreach (string name2 in array)
			{
				if (trailMaterial.HasProperty(name2))
				{
					setMatHUEColor(trailMaterial, name2, hue);
				}
			}
		}
		SkinnedMeshRenderer[] componentsInChildren3 = go.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
		for (int i = 0; i < componentsInChildren3.Length; i++)
		{
			Material material3 = componentsInChildren3[i].material;
			if (material3 == null)
			{
				continue;
			}
			string[] array = colorProperties;
			foreach (string name3 in array)
			{
				if (material3.HasProperty(name3))
				{
					setMatHUEColor(material3, name3, hue);
				}
			}
		}
		Light[] componentsInChildren4 = go.GetComponentsInChildren<Light>(includeInactive: true);
		foreach (Light obj in componentsInChildren4)
		{
			HSBColor hsbColor = ColorToHSV(obj.color);
			hsbColor.H = hue;
			obj.color = HSVToColor(hsbColor);
		}
		ParticleSystem[] componentsInChildren5 = go.GetComponentsInChildren<ParticleSystem>(includeInactive: true);
		foreach (ParticleSystem obj2 in componentsInChildren5)
		{
			ParticleSystem.MainModule main = obj2.main;
			HSBColor hsbColor2 = ColorToHSV(obj2.main.startColor.color);
			hsbColor2.H = hue;
			main.startColor = HSVToColor(hsbColor2);
			ParticleSystem.ColorOverLifetimeModule colorOverLifetime = obj2.colorOverLifetime;
			ParticleSystem.MinMaxGradient color = colorOverLifetime.color;
			Gradient gradient = colorOverLifetime.color.gradient;
			GradientColorKey[] colorKeys = colorOverLifetime.color.gradient.colorKeys;
			float num = 0f;
			hsbColor2 = ColorToHSV(colorKeys[0].color);
			num = Math.Abs(ColorToHSV(colorKeys[1].color).H - hsbColor2.H);
			hsbColor2.H = hue;
			colorKeys[0].color = HSVToColor(hsbColor2);
			for (int k = 1; k < colorKeys.Length; k++)
			{
				hsbColor2 = ColorToHSV(colorKeys[k].color);
				hsbColor2.H = Mathf.Repeat(hsbColor2.H + num, 1f);
				colorKeys[k].color = HSVToColor(hsbColor2);
			}
			gradient.colorKeys = colorKeys;
			color.gradient = gradient;
			colorOverLifetime.color = color;
		}
		RFX4_ShaderColorGradient[] componentsInChildren6 = go.GetComponentsInChildren<RFX4_ShaderColorGradient>(includeInactive: true);
		for (int i = 0; i < componentsInChildren6.Length; i++)
		{
			componentsInChildren6[i].HUE = hue;
		}
	}

	private static Material setMatHUEColor(Material mat, string name, float hueColor)
	{
		Color value = ConvertRGBColorByHUE(mat.GetColor(name), hueColor);
		mat.SetColor(name, value);
		return mat;
	}

	private static Material setMatAlphaColor(Material mat, string name, float alpha)
	{
		Color color = mat.GetColor(name);
		color.a = alpha;
		mat.SetColor(name, color);
		return mat;
	}
}
public class RFX4_CopyPosition : MonoBehaviour
{
	public Transform CopiedTransform;

	private Transform t;

	private void Start()
	{
		t = base.transform;
	}

	private void Update()
	{
		t.position = CopiedTransform.position;
	}
}
[ExecuteInEditMode]
public class RFX4_CustomLight : MonoBehaviour
{
	private static int MaxLightsCount = 4;

	private Texture2D PointLightAttenuation;

	private List<Light> sceneLights;

	private void Awake()
	{
		sceneLights = UnityEngine.Object.FindObjectsOfType<Light>().ToList();
		PointLightAttenuation = GeneratePointAttenuationTexture();
		Shader.SetGlobalTexture("RFX4_PointLightAttenuation", PointLightAttenuation);
	}

	private void Update()
	{
		List<Light> allLights = GetAllLights();
		int num = 0;
		List<Vector4> list = new List<Vector4>();
		List<Vector4> list2 = new List<Vector4>();
		num += FillDirectionalLights(allLights, list, list2);
		allLights = SortPointLightsByDistance(allLights);
		num += FillPointLights(allLights, list, list2);
		Shader.SetGlobalInt("RFX4_LightCount", num);
		Shader.SetGlobalVectorArray("RFX4_LightPositions", ListToArrayWithMaxCount(list, MaxLightsCount));
		Shader.SetGlobalVectorArray("RFX4_LightColors", ListToArrayWithMaxCount(list2, MaxLightsCount));
		Color value = SampleLightProbesUp(base.transform.position, 0.5f);
		Shader.SetGlobalColor("RFX4_AmbientColor", value);
	}

	private void OnDisable()
	{
		Shader.SetGlobalInt("RFX4_LightCount", 0);
		Shader.SetGlobalVectorArray("RFX4_LightPositions", new Vector4[1] { Vector4.zero });
		Shader.SetGlobalVectorArray("RFX4_LightColors", new Vector4[1] { Vector4.zero });
		Shader.SetGlobalColor("RFX4_AmbientColor", Color.black);
	}

	private List<Light> GetAllLights()
	{
		List<Light> list = base.transform.root.GetComponentsInChildren<Light>().ToList();
		foreach (Light sceneLight in sceneLights)
		{
			if (sceneLight != null)
			{
				list.Add(sceneLight);
			}
		}
		return list;
	}

	private int FillDirectionalLights(List<Light> lights, List<Vector4> lightPositions, List<Vector4> lightColors)
	{
		int num = 0;
		for (int i = 0; i < lights.Count; i++)
		{
			if (lights[i].isActiveAndEnabled && lights[i].type == LightType.Directional)
			{
				Vector3 vector = -lights[i].transform.forward;
				lightPositions.Add(new Vector4(vector.x, vector.y, vector.z, 0f));
				Color color = lights[i].color * lights[i].intensity;
				lightColors.Add(new Vector4(color.r, color.g, color.b, 0f));
				num++;
			}
		}
		return num;
	}

	private int FillPointLights(List<Light> lights, List<Vector4> lightPositions, List<Vector4> lightColors)
	{
		int num = 0;
		for (int i = 0; i < lights.Count; i++)
		{
			if (lights[i].isActiveAndEnabled && lights[i].type == LightType.Point)
			{
				Vector3 position = lights[i].transform.position;
				lightPositions.Add(new Vector4(position.x, position.y, position.z, lights[i].range));
				Color color = lights[i].color * lights[i].intensity;
				lightColors.Add(new Vector4(color.r, color.g, color.b, 1f));
				num++;
			}
		}
		return num;
	}

	private Vector4[] ListToArrayWithMaxCount(List<Vector4> list, int count)
	{
		Vector4[] array = new Vector4[count];
		for (int i = 0; i < count; i++)
		{
			if (list.Count > i)
			{
				array[i] = list[i];
			}
			else
			{
				array[i] = Vector4.zero;
			}
		}
		return array;
	}

	private List<Light> SortPointLightsByDistance(List<Light> lights)
	{
		Vector3 position = base.transform.position;
		SortedDictionary<float, Light> sortedDictionary = new SortedDictionary<float, Light>();
		foreach (Light light in lights)
		{
			float key = (position - light.transform.position).magnitude + UnityEngine.Random.Range(-10000f, 10000f) / 1000000f;
			if (!sortedDictionary.ContainsKey(key))
			{
				sortedDictionary.Add(key, light);
			}
		}
		return sortedDictionary.Values.ToList();
	}

	public Color SampleLightProbesUp(Vector3 pos, float grayScaleFactor)
	{
		LightProbes.GetInterpolatedProbe(pos, null, out var probe);
		Vector4 a = new Vector4(probe[0, 3], probe[0, 1], probe[0, 2], probe[0, 0] - probe[0, 6]);
		Vector4 a2 = new Vector4(probe[1, 3], probe[1, 1], probe[1, 2], probe[1, 0] - probe[1, 6]);
		Vector4 a3 = new Vector4(probe[2, 3], probe[2, 1], probe[2, 2], probe[2, 0] - probe[2, 6]);
		Vector4 a4 = new Vector4(probe[0, 4], probe[0, 6], probe[0, 5] * 3f, probe[0, 7]);
		Vector4 a5 = new Vector4(probe[1, 4], probe[1, 6], probe[1, 5] * 3f, probe[1, 7]);
		Vector4 a6 = new Vector4(probe[2, 4], probe[2, 6], probe[2, 5] * 3f, probe[2, 7]);
		Vector3 vector = new Vector3(probe[0, 8], probe[2, 8], probe[1, 8]);
		Vector4 b = new Vector4(0f, 1f, 0f, 1f);
		Color black = Color.black;
		black.r = Vector4.Dot(a, b);
		black.g = Vector4.Dot(a2, b);
		black.b = Vector4.Dot(a3, b);
		Vector4 b2 = new Vector4(b.x * b.y, b.y * b.z, b.z * b.z, b.z * b.x);
		Color black2 = Color.black;
		black2.r = Vector4.Dot(a4, b2);
		black2.g = Vector4.Dot(a5, b2);
		black2.b = Vector4.Dot(a6, b2);
		float num = b.x * b.x - b.y * b.y;
		Vector3 vector2 = vector * num;
		Color color = new Color(vector2.x, vector2.y, vector2.z);
		Color a7 = black + black2 + color;
		float num2 = a7.r * 0.33f + a7.g * 0.33f + a7.b * 0.33f;
		a7 = Color.Lerp(a7, Color.white * num2, grayScaleFactor);
		if (QualitySettings.activeColorSpace == ColorSpace.Gamma)
		{
			return (black + black2 + color).gamma;
		}
		return a7;
	}

	private Texture2D GeneratePointAttenuationTexture()
	{
		Texture2D texture2D = new Texture2D(256, 1);
		texture2D.wrapMode = TextureWrapMode.Clamp;
		for (int i = 0; i < 256; i++)
		{
			float num = (float)i / 256f;
			float num2 = Mathf.Clamp01(1f / (1f + 25f * num * num) * Mathf.Clamp01((1f - num) * 5f));
			texture2D.SetPixel(i, 0, Color.white * num2);
		}
		texture2D.Apply();
		return texture2D;
	}
}
public class RFX4_DeactivateByTime : MonoBehaviour
{
	public GameObject DeactivatedGameObject;

	public float DeactivateTime = 3f;

	private bool isActiveState;

	private float currentTime;

	private void OnEnable()
	{
		currentTime = 0f;
		isActiveState = true;
	}

	private void Update()
	{
		currentTime += Time.deltaTime;
		if (isActiveState && currentTime >= DeactivateTime)
		{
			isActiveState = false;
			DeactivatedGameObject.SetActive(value: false);
		}
	}
}
public class RFX4_DeactivateRigidbodyByTime : MonoBehaviour
{
	public float TimeDelayToDeactivate = 6f;

	private void OnEnable()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = false;
		component.detectCollisions = true;
		Invoke("Deactivate", TimeDelayToDeactivate);
	}

	private void Deactivate()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		component.isKinematic = true;
		component.detectCollisions = false;
	}
}
[ExecuteInEditMode]
public class RFX4_Decal : MonoBehaviour
{
	public bool IsScreenSpace = true;

	private ParticleSystem ps;

	private ParticleSystem.MainModule psMain;

	private MaterialPropertyBlock props;

	private MeshRenderer rend;

	private void OnEnable()
	{
		ps = GetComponent<ParticleSystem>();
		if (ps != null)
		{
			psMain = ps.main;
		}
		if (Camera.main.depthTextureMode != DepthTextureMode.Depth)
		{
			Camera.main.depthTextureMode = DepthTextureMode.Depth;
		}
		if (!IsScreenSpace)
		{
			Material sharedMaterial = GetComponent<Renderer>().sharedMaterial;
			sharedMaterial.EnableKeyword("USE_QUAD_DECAL");
			sharedMaterial.SetInt("_ZTest1", 4);
			if (UnityEngine.Application.isPlaying)
			{
				Vector3 localPosition = base.transform.localPosition;
				localPosition.z += 0.1f;
				base.transform.localPosition = localPosition;
				Vector3 localScale = base.transform.localScale;
				localScale.y = 0.001f;
				base.transform.localScale = localScale;
			}
		}
		else
		{
			Material sharedMaterial2 = GetComponent<Renderer>().sharedMaterial;
			sharedMaterial2.DisableKeyword("USE_QUAD_DECAL");
			sharedMaterial2.SetInt("_ZTest1", 5);
		}
	}

	private void LateUpdate()
	{
		Matrix4x4 worldToLocalMatrix = base.transform.worldToLocalMatrix;
		if (props == null)
		{
			props = new MaterialPropertyBlock();
		}
		if (rend == null)
		{
			rend = GetComponent<MeshRenderer>();
		}
		rend.GetPropertyBlock(props);
		props.SetMatrix("_InverseTransformMatrix", worldToLocalMatrix);
		rend.SetPropertyBlock(props);
		if (ps != null)
		{
			psMain.scalingMode = ParticleSystemScalingMode.Hierarchy;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.matrix = Matrix4x4.TRS(base.transform.TransformPoint(Vector3.zero), base.transform.rotation, base.transform.lossyScale);
		Gizmos.color = new Color(1f, 1f, 1f, 1f);
		Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
	}
}
public class RFX4_DemoReactivation : MonoBehaviour
{
	public float ReactivationTime = 5f;

	public GameObject Effect;

	private void Start()
	{
		InvokeRepeating("Reactivate", 0f, ReactivationTime);
	}

	private void Reactivate()
	{
		Effect.SetActive(value: false);
		Effect.SetActive(value: true);
	}
}
public class RFX4_EffectEvent : MonoBehaviour
{
	public GameObject CharacterEffect;

	public Transform CharacterAttachPoint;

	public float CharacterEffect_DestroyTime = 10f;

	[Space]
	public GameObject CharacterEffect2;

	public Transform CharacterAttachPoint2;

	public float CharacterEffect2_DestroyTime = 10f;

	[Space]
	public GameObject MainEffect;

	public Transform AttachPoint;

	public float Effect_DestroyTime = 10f;

	[Space]
	public GameObject AdditionalEffect;

	public Transform AdditionalEffectAttachPoint;

	public float AdditionalEffect_DestroyTime = 10f;

	[HideInInspector]
	public bool IsMobile;

	public void ActivateEffect()
	{
		if (!(MainEffect == null))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(MainEffect, AttachPoint.transform.position, AttachPoint.transform.rotation);
			UpdateEffectForMobileIsNeed(gameObject);
			if (Effect_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, Effect_DestroyTime);
			}
		}
	}

	public void ActivateAdditionalEffect()
	{
		if (AdditionalEffect == null)
		{
			return;
		}
		if (AdditionalEffectAttachPoint != null)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(AdditionalEffect, AdditionalEffectAttachPoint.transform.position, AdditionalEffectAttachPoint.transform.rotation);
			UpdateEffectForMobileIsNeed(gameObject);
			if (AdditionalEffect_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, AdditionalEffect_DestroyTime);
			}
		}
		else
		{
			AdditionalEffect.SetActive(value: true);
		}
	}

	public void ActivateCharacterEffect()
	{
		if (!(CharacterEffect == null))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(CharacterEffect, CharacterAttachPoint.transform.position, CharacterAttachPoint.transform.rotation, CharacterAttachPoint.transform);
			UpdateEffectForMobileIsNeed(gameObject);
			if (CharacterEffect_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, CharacterEffect_DestroyTime);
			}
		}
	}

	public void ActivateCharacterEffect2()
	{
		if (!(CharacterEffect2 == null))
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(CharacterEffect2, CharacterAttachPoint2.transform.position, CharacterAttachPoint2.transform.rotation, CharacterAttachPoint2);
			UpdateEffectForMobileIsNeed(gameObject);
			if (CharacterEffect2_DestroyTime > 0.01f)
			{
				UnityEngine.Object.Destroy(gameObject, CharacterEffect2_DestroyTime);
			}
		}
	}

	private void UpdateEffectForMobileIsNeed(GameObject instance)
	{
		_ = instance.GetComponent<RFX4_EffectSettings>() != null;
	}
}
[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class RFX4_MaterialQueue : MonoBehaviour
{
	[UnityEngine.Tooltip("Background=1000, Geometry=2000, AlphaTest=2450, Transparent=3000, Overlay=4000")]
	public int queue = 2000;

	public int[] queues;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if ((bool)component && (bool)component.sharedMaterial && queues != null)
		{
			component.sharedMaterial.renderQueue = queue;
			for (int i = 0; i < queues.Length && i < component.sharedMaterials.Length; i++)
			{
				component.sharedMaterials[i].renderQueue = queues[i];
			}
		}
	}

	private void OnValidate()
	{
		Start();
	}

	private void Update()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Start();
		}
	}
}
public class RFX4_OnEnableResetTransform : MonoBehaviour
{
	private Transform t;

	private Vector3 startPosition;

	private Quaternion startRotation;

	private Vector3 startScale;

	private bool isInitialized;

	private void OnEnable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}

	private void OnDisable()
	{
		if (!isInitialized)
		{
			isInitialized = true;
			t = base.transform;
			startPosition = t.position;
			startRotation = t.rotation;
			startScale = t.localScale;
		}
		else
		{
			t.position = startPosition;
			t.rotation = startRotation;
			t.localScale = startScale;
		}
	}
}
public class RFX4_ParticleCollisionGameObject : MonoBehaviour
{
	public GameObject InstancedGO;

	public float DestroyDelay = 5f;

	public GameObject RotationParent;

	private List<ParticleCollisionEvent> collisionEvents = new List<ParticleCollisionEvent>();

	private ParticleSystem initiatorPS;

	private void OnEnable()
	{
		collisionEvents.Clear();
		initiatorPS = GetComponent<ParticleSystem>();
	}

	private void OnParticleCollision(GameObject other)
	{
		int num = initiatorPS.GetCollisionEvents(other, collisionEvents);
		for (int i = 0; i < num; i++)
		{
			GameObject obj = ((!(RotationParent != null)) ? UnityEngine.Object.Instantiate(InstancedGO, collisionEvents[i].intersection, default(Quaternion)) : UnityEngine.Object.Instantiate(InstancedGO, collisionEvents[i].intersection, RotationParent.transform.rotation));
			UnityEngine.Object.Destroy(obj, DestroyDelay);
		}
	}
}
[ExecuteInEditMode]
public class RFX4_ParticleGravityPoint : MonoBehaviour
{
	public string targetObjectID;

	public Transform target;

	public float Force = 1f;

	public float StopDistance = -1f;

	private ParticleSystem ps;

	private ParticleSystem.Particle[] particles;

	private ParticleSystem.MainModule mainModule;

	private void Start()
	{
		ps = GetComponent<ParticleSystem>();
		mainModule = ps.main;
		if (!string.IsNullOrEmpty(targetObjectID) && target == null)
		{
			target = ObjectID.Get<Transform>(targetObjectID);
		}
	}

	private void LateUpdate()
	{
		int maxParticles = mainModule.maxParticles;
		if (particles == null || particles.Length < maxParticles)
		{
			particles = new ParticleSystem.Particle[maxParticles];
		}
		int num = ps.GetParticles(particles);
		float num2 = Time.deltaTime * Force;
		Vector3 vector = Vector3.zero;
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.Local)
		{
			vector = base.transform.InverseTransformPoint(target.position);
		}
		if (mainModule.simulationSpace == ParticleSystemSimulationSpace.World)
		{
			vector = target.position;
		}
		for (int i = 0; i < num; i++)
		{
			Vector3 vector2 = Vector3.Normalize(vector - particles[i].position) * num2;
			if (StopDistance > 0f && (particles[i].position - target.position).magnitude < StopDistance)
			{
				particles[i].velocity = Vector3.zero;
			}
			else
			{
				particles[i].velocity += vector2;
			}
		}
		ps.SetParticles(particles, num);
	}
}
public class RFX4_PhysXSetImpulse : MonoBehaviour
{
	public float Force = 1f;

	public ForceMode ForceMode;

	private Rigidbody rig;

	private Transform t;

	private void Start()
	{
		rig = GetComponent<Rigidbody>();
		t = base.transform;
	}

	private void FixedUpdate()
	{
		if (rig != null)
		{
			rig.AddForce(t.forward * Force, ForceMode);
		}
	}

	private void OnDisable()
	{
		if (rig != null)
		{
			rig.velocity = Vector3.zero;
		}
	}
}
public class RFX4_PhysicsMotion : MonoBehaviour
{
	public class RFX4_CollisionInfo : EventArgs
	{
		public Vector3 HitPoint;

		public Collider HitCollider;

		public GameObject HitGameObject;
	}

	public bool UseCollisionDetect = true;

	public float MaxDistnace = -1f;

	public float Mass = 1f;

	public float Speed = 10f;

	public float RandomSpeedOffset;

	public float AirDrag = 0.1f;

	public bool UseGravity = true;

	public ForceMode ForceMode = ForceMode.Impulse;

	public Vector3 AddRealtimeForce = Vector3.zero;

	public float MinSpeed;

	public float ColliderRadius = 0.05f;

	public bool FreezeRotation;

	public bool UseTargetPositionAfterCollision;

	public GameObject EffectOnCollision;

	public bool CollisionEffectInWorldSpace = true;

	public bool LookAtNormal = true;

	public float CollisionEffectDestroyAfter = 5f;

	public GameObject[] DeactivateObjectsAfterCollision;

	[HideInInspector]
	public float HUE = -1f;

	private Rigidbody rigid;

	private SphereCollider collid;

	private ContactPoint lastContactPoint;

	private Collider lastCollider;

	private Vector3 offsetColliderPoint;

	private bool isCollided;

	private GameObject targetAnchor;

	private bool isInitializedForce;

	private float currentSpeedOffset;

	private RFX4_EffectSettings effectSettings;

	public event EventHandler<RFX4_CollisionInfo> CollisionEnter;

	private void OnEnable()
	{
		effectSettings = GetComponentInParent<RFX4_EffectSettings>();
		GameObject[] deactivateObjectsAfterCollision = DeactivateObjectsAfterCollision;
		foreach (GameObject gameObject in deactivateObjectsAfterCollision)
		{
			if (gameObject != null)
			{
				if (gameObject.GetComponent<ParticleSystem>() != null)
				{
					gameObject.SetActive(value: false);
				}
				gameObject.SetActive(value: true);
			}
		}
		currentSpeedOffset = UnityEngine.Random.Range((0f - RandomSpeedOffset) * 10000f, RandomSpeedOffset * 10000f) / 10000f;
		InitializeRigid();
	}

	private void InitializeRigid()
	{
		if (effectSettings.UseCollisionDetection)
		{
			collid = base.gameObject.AddComponent<SphereCollider>();
			collid.radius = ColliderRadius;
		}
		isInitializedForce = false;
	}

	private void InitializeForce()
	{
		rigid = base.gameObject.AddComponent<Rigidbody>();
		rigid.mass = effectSettings.Mass;
		rigid.drag = effectSettings.AirDrag;
		rigid.useGravity = effectSettings.UseGravity;
		if (FreezeRotation)
		{
			rigid.constraints = RigidbodyConstraints.FreezeRotation;
		}
		rigid.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		rigid.interpolation = RigidbodyInterpolation.Interpolate;
		rigid.AddForce(base.transform.forward * (effectSettings.Speed + currentSpeedOffset), ForceMode);
		isInitializedForce = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (isCollided && !effectSettings.UseCollisionDetection)
		{
			return;
		}
		ContactPoint[] contacts = collision.contacts;
		for (int i = 0; i < contacts.Length; i++)
		{
			ContactPoint contactPoint = contacts[i];
			if (!isCollided)
			{
				isCollided = true;
				if (UseTargetPositionAfterCollision)
				{
					if (targetAnchor != null)
					{
						UnityEngine.Object.Destroy(targetAnchor);
					}
					targetAnchor = new GameObject();
					targetAnchor.hideFlags = HideFlags.HideAndDontSave;
					targetAnchor.transform.parent = contactPoint.otherCollider.transform;
					targetAnchor.transform.position = contactPoint.point;
					targetAnchor.transform.rotation = base.transform.rotation;
				}
			}
			this.CollisionEnter?.Invoke(this, new RFX4_CollisionInfo
			{
				HitPoint = contactPoint.point,
				HitCollider = contactPoint.otherCollider,
				HitGameObject = contactPoint.otherCollider.gameObject
			});
			if (EffectOnCollision != null)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(EffectOnCollision, contactPoint.point, default(Quaternion));
				if (HUE > -0.9f)
				{
					RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject, HUE);
				}
				if (LookAtNormal)
				{
					gameObject.transform.LookAt(contactPoint.point + contactPoint.normal);
				}
				else
				{
					gameObject.transform.rotation = base.transform.rotation;
				}
				if (!CollisionEffectInWorldSpace)
				{
					gameObject.transform.parent = contactPoint.otherCollider.transform.parent;
				}
				UnityEngine.Object.Destroy(gameObject, CollisionEffectDestroyAfter);
			}
		}
		GameObject[] deactivateObjectsAfterCollision = DeactivateObjectsAfterCollision;
		foreach (GameObject gameObject2 in deactivateObjectsAfterCollision)
		{
			if (gameObject2 != null)
			{
				ParticleSystem component = gameObject2.GetComponent<ParticleSystem>();
				if (component != null)
				{
					component.Stop();
				}
				else
				{
					gameObject2.SetActive(value: false);
				}
			}
		}
		if (rigid != null)
		{
			UnityEngine.Object.Destroy(rigid);
		}
		if (collid != null)
		{
			UnityEngine.Object.Destroy(collid);
		}
	}

	private void FixedUpdate()
	{
		if (!isInitializedForce)
		{
			InitializeForce();
		}
		if (rigid != null && AddRealtimeForce.magnitude > 0.001f)
		{
			rigid.AddForce(AddRealtimeForce);
		}
		if (rigid != null && MinSpeed > 0.001f)
		{
			rigid.AddForce(base.transform.forward * MinSpeed);
		}
		if (rigid != null && effectSettings.MaxDistnace > 0f && base.transform.localPosition.magnitude > effectSettings.MaxDistnace)
		{
			RemoveRigidbody();
		}
		if (UseTargetPositionAfterCollision && isCollided && targetAnchor != null)
		{
			base.transform.position = targetAnchor.transform.position;
			base.transform.rotation = targetAnchor.transform.rotation;
		}
	}

	private void OnDisable()
	{
		base.transform.localPosition = Vector3.zero;
		base.transform.localRotation = default(Quaternion);
		RemoveRigidbody();
	}

	private void RemoveRigidbody()
	{
		isCollided = false;
		if (rigid != null)
		{
			UnityEngine.Object.Destroy(rigid);
		}
		if (collid != null)
		{
			UnityEngine.Object.Destroy(collid);
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Transform transform = base.transform;
			Gizmos.color = Color.green;
			Gizmos.DrawWireSphere(transform.position, ColliderRadius);
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(transform.position, transform.position + transform.forward * 100f);
		}
	}
}
public class RFX4_RaycastCollision : MonoBehaviour
{
	public float RaycastDistance = 100f;

	public GameObject[] Effects;

	public float Offset;

	public float EnableTimeDelay;

	public float DestroyTime = 3f;

	public bool UsePivotPosition;

	public bool UseNormalRotation = true;

	public bool IsWorldSpace = true;

	public bool RealTimeUpdateRaycast;

	public bool DestroyAfterDisabling;

	[HideInInspector]
	public float HUE = -1f;

	[HideInInspector]
	public List<GameObject> CollidedInstances = new List<GameObject>();

	private const string particlesAdditionalName = "Distance";

	private ParticleSystem[] distanceParticles;

	private bool canUpdate;

	public event EventHandler<RFX4_PhysicsMotion.RFX4_CollisionInfo> CollisionEnter;

	private void Awake()
	{
		distanceParticles = base.transform.root.GetComponentsInChildren<ParticleSystem>();
	}

	private void OnEnable()
	{
		CollidedInstances.Clear();
		if ((double)EnableTimeDelay > 0.001)
		{
			Invoke("UpdateRaycast", EnableTimeDelay);
		}
		else
		{
			UpdateRaycast();
		}
	}

	private void OnDisable()
	{
		if (!DestroyAfterDisabling)
		{
			return;
		}
		foreach (GameObject collidedInstance in CollidedInstances)
		{
			UnityEngine.Object.Destroy(collidedInstance);
		}
	}

	private void Update()
	{
		if (canUpdate)
		{
			UpdateRaycast();
		}
	}

	private void UpdateRaycast()
	{
		if (Physics.Raycast(base.transform.position, base.transform.forward, out var hitInfo, RaycastDistance))
		{
			Vector3 position = ((!UsePivotPosition) ? (hitInfo.point + hitInfo.normal * Offset) : hitInfo.transform.position);
			this.CollisionEnter?.Invoke(this, new RFX4_PhysicsMotion.RFX4_CollisionInfo
			{
				HitPoint = hitInfo.point,
				HitCollider = hitInfo.collider,
				HitGameObject = hitInfo.transform.gameObject
			});
			if (distanceParticles != null)
			{
				ParticleSystem[] array = distanceParticles;
				foreach (ParticleSystem particleSystem in array)
				{
					if (particleSystem != null && particleSystem.name.Contains("Distance"))
					{
						particleSystem.GetComponent<ParticleSystemRenderer>().lengthScale = (base.transform.position - hitInfo.point).magnitude / particleSystem.main.startSize.constantMax;
					}
				}
			}
			if (CollidedInstances.Count == 0)
			{
				GameObject[] effects = Effects;
				foreach (GameObject gameObject in effects)
				{
					if (gameObject != null)
					{
						GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, position, default(Quaternion));
						RFX4_EffectSettings component = gameObject2.GetComponent<RFX4_EffectSettings>();
						RFX4_EffectSettings componentInParent = GetComponentInParent<RFX4_EffectSettings>();
						if (component != null)
						{
							_ = componentInParent != null;
						}
						CollidedInstances.Add(gameObject2);
						if (HUE > -0.9f)
						{
							RFX4_ColorHelper.ChangeObjectColorByHUE(gameObject2, HUE);
						}
						if (!IsWorldSpace)
						{
							gameObject2.transform.parent = base.transform;
						}
						if (UseNormalRotation)
						{
							gameObject2.transform.LookAt(hitInfo.point + hitInfo.normal);
						}
						if (DestroyTime > 0.0001f)
						{
							UnityEngine.Object.Destroy(gameObject2, DestroyTime);
						}
					}
				}
			}
			else
			{
				foreach (GameObject collidedInstance in CollidedInstances)
				{
					if (!(collidedInstance == null))
					{
						collidedInstance.transform.position = position;
						if (UseNormalRotation)
						{
							collidedInstance.transform.LookAt(hitInfo.point + hitInfo.normal);
						}
					}
				}
			}
		}
		if (RealTimeUpdateRaycast)
		{
			canUpdate = true;
		}
	}

	private void OnDrawGizmosSelected()
	{
		Gizmos.color = Color.blue;
		Gizmos.DrawLine(base.transform.position, base.transform.position + base.transform.forward * RaycastDistance);
	}
}
public class RFX4_ReplaceModelOnCollision : MonoBehaviour
{
	public GameObject PhysicsObjects;

	private bool isCollided;

	private Transform t;

	private void OnCollisionEnter(Collision collision)
	{
		if (!isCollided)
		{
			isCollided = true;
			PhysicsObjects.SetActive(value: true);
			MeshRenderer component = GetComponent<MeshRenderer>();
			if (component != null)
			{
				component.enabled = false;
			}
			Rigidbody component2 = GetComponent<Rigidbody>();
			component2.isKinematic = true;
			component2.detectCollisions = false;
		}
	}

	private void OnEnable()
	{
		isCollided = false;
		PhysicsObjects.SetActive(value: false);
		MeshRenderer component = GetComponent<MeshRenderer>();
		if (component != null)
		{
			component.enabled = true;
		}
		Rigidbody component2 = GetComponent<Rigidbody>();
		component2.isKinematic = false;
		component2.detectCollisions = true;
	}
}
public class RFX4_RotateAround : MonoBehaviour
{
	public Vector3 Offset = Vector3.forward;

	public Vector3 RotateVector = Vector3.forward;

	public float LifeTime = 1f;

	private Transform t;

	private float currentTime;

	private Quaternion rotation;

	private void Start()
	{
		t = base.transform;
		rotation = t.rotation;
	}

	private void OnEnable()
	{
		currentTime = 0f;
		if (t != null)
		{
			t.rotation = rotation;
		}
	}

	private void Update()
	{
		if (!(currentTime >= LifeTime) || !(LifeTime > 0.0001f))
		{
			currentTime += Time.deltaTime;
			t.Rotate(RotateVector * Time.deltaTime);
		}
	}
}
public class RFX4_StartDelay : MonoBehaviour
{
	public GameObject ActivatedGameObject;

	public float Delay = 1f;

	private float currentTime;

	private bool isEnabled;

	private void OnEnable()
	{
		ActivatedGameObject.SetActive(value: false);
		isEnabled = false;
		currentTime = 0f;
	}

	private void Update()
	{
		currentTime += Time.deltaTime;
		if (!isEnabled && currentTime >= Delay)
		{
			isEnabled = true;
			ActivatedGameObject.SetActive(value: true);
		}
	}
}
public enum RFX4_TextureShaderProperties
{
	_MainTex,
	_DistortTex,
	_Mask,
	_Cutout,
	_CutoutTex,
	_Bump,
	_BumpTex,
	_EmissionTex
}
public class RFX4_TornadoParticles : MonoBehaviour
{
	public Material TornadoMaterial;

	private ParticleSystem.Particle[] particleArray;

	private ParticleSystem particleSys;

	private Light myLight;

	private Vector4 _twistScale;

	private int materialID = -1;

	private void Start()
	{
		particleSys = GetComponent<ParticleSystem>();
		myLight = GetComponent<Light>();
		if (particleSys != null)
		{
			particleArray = new ParticleSystem.Particle[particleSys.main.maxParticles];
		}
		if (TornadoMaterial.HasProperty("_TwistScale"))
		{
			materialID = Shader.PropertyToID("_TwistScale");
		}
		else
		{
			UnityEngine.Debug.Log(TornadoMaterial.name + " not have property twist");
		}
		if (materialID != -1)
		{
			_twistScale = TornadoMaterial.GetVector(materialID);
		}
	}

	private void Update()
	{
		if (materialID != -1)
		{
			_twistScale = TornadoMaterial.GetVector(materialID);
		}
		if (particleSys != null)
		{
			int particles = particleSys.GetParticles(particleArray);
			for (int i = 0; i < particles; i++)
			{
				Vector3 position = particleArray[i].position;
				float num = (position.y - base.transform.position.y) * _twistScale.y;
				position.x = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x) * num;
				position.z = Mathf.Sin(Time.time * _twistScale.z + position.y * _twistScale.x + 1.57075f) * num;
				particleArray[i].position = position;
				particleSys.SetParticles(particleArray, particles);
			}
		}
		if (myLight != null)
		{
			Vector3 localPosition = base.transform.localPosition;
			float num2 = localPosition.y * _twistScale.y;
			localPosition.x = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x) * num2;
			localPosition.z = Mathf.Sin(Time.time * _twistScale.z + localPosition.y * _twistScale.x + 1.57075f) * num2;
			base.transform.localPosition = localPosition;
		}
	}
}
[RequireComponent(typeof(LineRenderer))]
public class RFX4_TrailRenderer : MonoBehaviour
{
	public float VertexLifeTime = 2f;

	public float TrailLifeTime = 2f;

	[Range(0.001f, 1f)]
	public float MinVertexDistance = 0.01f;

	public float Gravity = 0.01f;

	public Vector3 Force = new Vector3(0f, 0f, 0f);

	public float InheritVelocity;

	public float Drag = 0.01f;

	[Range(0.001f, 10f)]
	public float Frequency = 1f;

	[Range(0.001f, 10f)]
	public float OffsetSpeed = 0.5f;

	public bool RandomTurbulenceOffset;

	[Range(0.001f, 10f)]
	public float Amplitude = 2f;

	public float TurbulenceStrength = 0.1f;

	public AnimationCurve VelocityByDistance = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	public float AproximatedFlyDistance = -1f;

	public bool SmoothCurves;

	private LineRenderer lineRenderer;

	private List<Vector3> positions;

	private List<float> currentTimes;

	private List<Vector3> velocities;

	[HideInInspector]
	public float currentLifeTime;

	private Transform t;

	private Vector3 prevPosition;

	private Vector3 startPosition;

	private List<Vector3> controlPoints = new List<Vector3>();

	private int curveCount;

	private const float MinimumSqrDistance = 0.01f;

	private const float DivisionThreshold = -0.99f;

	private const float SmoothCurvesScale = 0.5f;

	private float currentVelocity;

	private float turbulenceRandomOffset;

	private bool isInitialized;

	private void Start()
	{
		Init();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Init();
		}
	}

	private void Init()
	{
		positions = new List<Vector3>();
		currentTimes = new List<float>();
		velocities = new List<Vector3>();
		currentLifeTime = 0f;
		curveCount = 0;
		currentVelocity = 0f;
		t = base.transform;
		prevPosition = t.position;
		startPosition = t.position;
		lineRenderer = GetComponent<LineRenderer>();
		lineRenderer.positionCount = 0;
		positions.Add(t.position);
		currentTimes.Add(currentLifeTime);
		velocities.Add(Vector3.zero);
		turbulenceRandomOffset = (RandomTurbulenceOffset ? (UnityEngine.Random.Range(0f, 10000f) / 1000f) : 0f);
	}

	private void Update()
	{
		if (!((double)Time.timeScale < 0.001))
		{
			UpdatePositionsCount();
			UpdateForce();
			UpdateImpulse();
			UpdateVelocity();
			int lastDeletedIndex = GetLastDeletedIndex();
			RemovePositionsBeforeIndex(lastDeletedIndex);
			if (SmoothCurves && positions.Count > 2)
			{
				InterpolateBezier(positions, 0.5f);
				List<Vector3> drawingPoints = GetDrawingPoints();
				lineRenderer.positionCount = drawingPoints.Count;
				lineRenderer.SetPositions(drawingPoints.ToArray());
			}
			else
			{
				lineRenderer.positionCount = positions.Count;
				lineRenderer.SetPositions(positions.ToArray());
			}
		}
	}

	private int GetLastDeletedIndex()
	{
		int result = -1;
		int count = currentTimes.Count;
		for (int i = 1; i < count; i++)
		{
			currentTimes[i] -= Time.deltaTime;
			if (currentTimes[i] <= 0f)
			{
				result = i;
			}
		}
		return result;
	}

	private void UpdatePositionsCount()
	{
		if (!(TrailLifeTime > 0.0001f) || !(currentLifeTime > TrailLifeTime))
		{
			currentLifeTime += Time.deltaTime;
			Vector3 vector = ((positions.Count != 0) ? positions[positions.Count - 1] : Vector3.zero);
			if (Mathf.Abs((t.position - vector).magnitude) > MinVertexDistance && positions.Count > 0)
			{
				AddInterpolatedPositions(vector, t.position);
			}
		}
	}

	private void AddInterpolatedPositions(Vector3 start, Vector3 end)
	{
		int num = (int)((start - end).magnitude / MinVertexDistance);
		float num2 = currentTimes.LastOrDefault();
		Vector3 zero = Vector3.zero;
		for (int i = 1; i <= num - 1; i++)
		{
			Vector3 item = start + (end - start) * i * 1f / num;
			float item2 = num2 + (VertexLifeTime - num2) * (float)i * 1f / (float)num;
			positions.Add(item);
			currentTimes.Add(item2);
			velocities.Add(zero);
		}
	}

	private void RemovePositionsBeforeIndex(int lastDeletedIndex)
	{
		if (lastDeletedIndex != -1)
		{
			if (positions.Count - lastDeletedIndex == 1)
			{
				positions.Clear();
				currentTimes.Clear();
				velocities.Clear();
			}
			else
			{
				positions.RemoveRange(0, lastDeletedIndex);
				currentTimes.RemoveRange(0, lastDeletedIndex);
				velocities.RemoveRange(0, lastDeletedIndex);
			}
		}
	}

	private void UpdateForce()
	{
		if (positions.Count < 1)
		{
			return;
		}
		Vector3 vector = Gravity * Vector3.down * Time.deltaTime;
		Vector3 vector2 = t.rotation * Force * Time.deltaTime;
		for (int i = 0; i < positions.Count; i++)
		{
			Vector3 zero = Vector3.zero;
			if (TurbulenceStrength > 1E-06f)
			{
				Vector3 vector3 = positions[i] / Frequency;
				float num = (Time.time + turbulenceRandomOffset) * OffsetSpeed;
				vector3 -= num * Vector3.one;
				zero.x += (Mathf.PerlinNoise(vector3.z, vector3.y) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.y += (Mathf.PerlinNoise(vector3.x, vector3.z) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
				zero.z += (Mathf.PerlinNoise(vector3.y, vector3.x) * 2f - 1f) * Amplitude * Time.deltaTime * TurbulenceStrength / 10f;
			}
			Vector3 vector4 = vector + vector2 + zero;
			if (AproximatedFlyDistance > 0.01f)
			{
				float num2 = Mathf.Abs((positions[i] - startPosition).magnitude);
				vector4 *= VelocityByDistance.Evaluate(Mathf.Clamp01(num2 / AproximatedFlyDistance));
			}
			velocities[i] += vector4;
		}
	}

	private void UpdateImpulse()
	{
		if (velocities.Count != 0)
		{
			currentVelocity = (t.position - prevPosition).magnitude / Time.deltaTime;
			Vector3 normalized = (t.position - prevPosition).normalized;
			prevPosition = t.position;
			velocities[velocities.Count - 1] += currentVelocity * InheritVelocity * normalized * Time.deltaTime;
		}
	}

	private void UpdateVelocity()
	{
		if (velocities.Count == 0)
		{
			return;
		}
		int count = positions.Count;
		for (int i = 0; i < count; i++)
		{
			if (Drag > 1E-05f)
			{
				velocities[i] -= Drag * velocities[i] * Time.deltaTime;
			}
			if (velocities[i].magnitude < 1E-05f)
			{
				velocities[i] = Vector3.zero;
			}
			positions[i] += velocities[i] * Time.deltaTime;
		}
	}

	public void InterpolateBezier(List<Vector3> segmentPoints, float scale)
	{
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector3 vector = segmentPoints[i];
				Vector3 vector2 = segmentPoints[i + 1] - vector;
				Vector3 item = vector + scale * vector2;
				controlPoints.Add(vector);
				controlPoints.Add(item);
			}
			else if (i == segmentPoints.Count - 1)
			{
				Vector3 vector3 = segmentPoints[i - 1];
				Vector3 vector4 = segmentPoints[i];
				Vector3 vector5 = vector4 - vector3;
				Vector3 item2 = vector4 - scale * vector5;
				controlPoints.Add(item2);
				controlPoints.Add(vector4);
			}
			else
			{
				Vector3 vector6 = segmentPoints[i - 1];
				Vector3 vector7 = segmentPoints[i];
				Vector3 vector8 = segmentPoints[i + 1];
				Vector3 normalized = (vector8 - vector6).normalized;
				Vector3 item3 = vector7 - scale * normalized * (vector7 - vector6).magnitude;
				Vector3 item4 = vector7 + scale * normalized * (vector8 - vector7).magnitude;
				controlPoints.Add(item3);
				controlPoints.Add(vector7);
				controlPoints.Add(item4);
			}
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector3> GetDrawingPoints()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector3> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector3> FindDrawingPoints(int curveIndex)
	{
		List<Vector3> list = new List<Vector3>();
		Vector3 item = CalculateBezierPoint(curveIndex, 0f);
		Vector3 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector3> pointList, int insertionIndex)
	{
		Vector3 vector = CalculateBezierPoint(curveIndex, t0);
		Vector3 vector2 = CalculateBezierPoint(curveIndex, t1);
		if ((vector - vector2).sqrMagnitude < 0.01f)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector3 vector3 = CalculateBezierPoint(curveIndex, num);
		Vector3 normalized = (vector - vector3).normalized;
		Vector3 normalized2 = (vector2 - vector3).normalized;
		if (Vector3.Dot(normalized, normalized2) > -0.99f || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, vector3);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	public Vector3 CalculateBezierPoint(int curveIndex, float t)
	{
		int num = curveIndex * 3;
		Vector3 p = controlPoints[num];
		Vector3 p2 = controlPoints[num + 1];
		Vector3 p3 = controlPoints[num + 2];
		Vector3 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	private Vector3 CalculateBezierPoint(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
	{
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}
[ExecuteInEditMode]
public class RFX4_UVAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	[Range(1f, 360f)]
	public int FPS = 32;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public bool IsReverse;

	public bool IsInterpolateFrames = true;

	public RFX4_TextureShaderProperties[] TextureNames = new RFX4_TextureShaderProperties[1];

	private int count;

	private Renderer currentRenderer;

	private Projector projector;

	private Material instanceMaterial;

	private float animationStartTime;

	private bool canUpdate;

	private int previousIndex;

	private int totalFrames;

	private float currentInterpolatedTime;

	private int currentIndex;

	private Vector2 size;

	private bool isInitialized;

	private float prevRealTime;

	private void OnEnable()
	{
		if (isInitialized)
		{
			InitDefaultVariables();
		}
	}

	private void Start()
	{
		InitDefaultVariables();
		isInitialized = true;
	}

	private void OnWillRenderObject()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			ManualUpdate();
		}
	}

	private void Update()
	{
		if (UnityEngine.Application.isPlaying)
		{
			ManualUpdate();
		}
	}

	private void InitDefaultVariables()
	{
		currentRenderer = GetComponent<Renderer>();
		UpdateMaterial();
		totalFrames = TilesX * TilesY;
		previousIndex = 0;
		canUpdate = true;
		count = TilesY * TilesX;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		size = new Vector2(1f / (float)TilesX, 1f / (float)TilesY);
		animationStartTime = (UnityEngine.Application.isPlaying ? Time.time : Time.realtimeSinceStartup);
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), zero);
			}
		}
	}

	private void ManualUpdate()
	{
		if (canUpdate)
		{
			UpdateMaterial();
			SetSpriteAnimation();
			if (IsInterpolateFrames)
			{
				SetSpriteAnimationIterpolated();
			}
		}
	}

	private void UpdateMaterial()
	{
		if (!(currentRenderer == null))
		{
			if (UnityEngine.Application.isPlaying)
			{
				instanceMaterial = currentRenderer.material;
			}
			instanceMaterial = currentRenderer.sharedMaterial;
			if (IsInterpolateFrames)
			{
				instanceMaterial.EnableKeyword("USE_SCRIPT_FRAMEBLENDING");
			}
			else
			{
				instanceMaterial.DisableKeyword("USE_SCRIPT_FRAMEBLENDING");
			}
		}
	}

	private void SetSpriteAnimation()
	{
		int num = (int)(((UnityEngine.Application.isPlaying ? Time.time : Time.realtimeSinceStartup) - animationStartTime) * (float)FPS);
		num %= totalFrames;
		if (!IsLoop && num < previousIndex)
		{
			canUpdate = false;
			return;
		}
		if (IsInterpolateFrames && num != previousIndex)
		{
			currentInterpolatedTime = 0f;
		}
		previousIndex = num;
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 value = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			RFX4_TextureShaderProperties[] textureNames = TextureNames;
			for (int i = 0; i < textureNames.Length; i++)
			{
				RFX4_TextureShaderProperties rFX4_TextureShaderProperties = textureNames[i];
				instanceMaterial.SetTextureScale(rFX4_TextureShaderProperties.ToString(), size);
				instanceMaterial.SetTextureOffset(rFX4_TextureShaderProperties.ToString(), value);
			}
		}
	}

	public float DeltaTime()
	{
		if (UnityEngine.Application.isPlaying)
		{
			return Time.deltaTime;
		}
		float result = Time.realtimeSinceStartup - prevRealTime;
		prevRealTime = Time.realtimeSinceStartup;
		return result;
	}

	private void SetSpriteAnimationIterpolated()
	{
		currentInterpolatedTime += DeltaTime();
		int num = previousIndex + 1;
		if (num == totalFrames)
		{
			num = previousIndex;
		}
		if (IsReverse)
		{
			num = totalFrames - num - 1;
		}
		int num2 = num % TilesX;
		int num3 = num / TilesX;
		float x = (float)num2 * size.x;
		float y = 1f - size.y - (float)num3 * size.y;
		Vector2 vector = new Vector2(x, y);
		if (instanceMaterial != null)
		{
			instanceMaterial.SetVector("_MainTex_NextFrame", new Vector4(size.x, size.y, vector.x, vector.y));
			instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * (float)FPS));
		}
	}
}
public class RFX4_UVScroll : MonoBehaviour
{
	public Vector2 UvScrollMultiplier = new Vector2(1f, 0f);

	public RFX4_TextureShaderProperties TextureName;

	private Vector2 uvOffset = Vector2.zero;

	private Material mat;

	private void Start()
	{
		Renderer component = GetComponent<Renderer>();
		if (component == null)
		{
			Projector component2 = GetComponent<Projector>();
			if (component2 != null)
			{
				if (!component2.material.name.EndsWith("(Instance)"))
				{
					component2.material = new Material(component2.material)
					{
						name = component2.material.name + " (Instance)"
					};
				}
				mat = component2.material;
			}
		}
		else
		{
			mat = component.material;
		}
	}

	private void Update()
	{
		uvOffset += UvScrollMultiplier * Time.deltaTime;
		if (mat != null)
		{
			mat.SetTextureOffset(TextureName.ToString(), uvOffset);
		}
	}
}
public class RFX4_MobileDistortion : MonoBehaviour
{
	public bool IsActive = true;

	private CommandBuffer buf;

	private Camera cam;

	private bool bufferIsAdded;

	private void Awake()
	{
		cam = GetComponent<Camera>();
		CreateBuffer();
	}

	private void CreateBuffer()
	{
		_ = Camera.main;
		buf = new CommandBuffer();
		buf.name = "_GrabOpaqueColor";
		int num = Shader.PropertyToID("_ScreenCopyOpaqueColor");
		int num2 = -1;
		RenderTextureFormat format = (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB565) ? RenderTextureFormat.RGB565 : RenderTextureFormat.Default);
		buf.GetTemporaryRT(num, num2, num2, 0, FilterMode.Bilinear, format);
		buf.Blit(BuiltinRenderTextureType.CurrentActive, num);
		buf.SetGlobalTexture("_GrabTexture", num);
		buf.SetGlobalTexture("_GrabTextureMobile", num);
	}

	private void OnEnable()
	{
		AddBuffer();
	}

	private void OnDisable()
	{
		RemoveBuffer();
	}

	private void AddBuffer()
	{
		cam.AddCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = true;
	}

	private void RemoveBuffer()
	{
		cam.RemoveCommandBuffer(CameraEvent.BeforeForwardAlpha, buf);
		bufferIsAdded = false;
	}

	private void Update()
	{
		if (IsActive)
		{
			if (!bufferIsAdded)
			{
				AddBuffer();
			}
		}
		else if (bufferIsAdded)
		{
			RemoveBuffer();
		}
	}

	private bool IsSupportedHdr()
	{
		return Camera.main.allowHDR;
	}
}
public class RFX4_PerPlatformSettings : MonoBehaviour
{
	public bool DisableOnMobiles;

	public bool RenderMobileDistortion;

	[Range(0.1f, 1f)]
	public float ParticleBudgetForMobiles = 0.5f;

	private bool isMobile;

	private void Start()
	{
	}

	private void Awake()
	{
		isMobile = IsMobilePlatform();
		if (isMobile)
		{
			if (DisableOnMobiles)
			{
				base.gameObject.SetActive(value: false);
			}
			else
			{
				ChangeParticlesBudget(ParticleBudgetForMobiles);
			}
		}
	}

	private void OnEnable()
	{
		Camera main = Camera.main;
		if (!(main == null))
		{
			if (RenderMobileDistortion && !DisableOnMobiles && isMobile && main.GetComponent<RFX4_MobileDistortion>() == null)
			{
				main.gameObject.AddComponent<RFX4_MobileDistortion>();
			}
			LWRP_Rendering();
		}
	}

	private void Update()
	{
		LWRP_Rendering();
	}

	private void LWRP_Rendering()
	{
	}

	private void OnDisable()
	{
		Camera main = Camera.main;
		if (!(main == null) && RenderMobileDistortion && !DisableOnMobiles && isMobile)
		{
			RFX4_MobileDistortion component = main.GetComponent<RFX4_MobileDistortion>();
			if (component != null)
			{
				UnityEngine.Object.DestroyImmediate(component);
			}
		}
	}

	private bool IsMobilePlatform()
	{
		bool result = false;
		if (UnityEngine.Application.isMobilePlatform)
		{
			result = true;
		}
		return result;
	}

	private void ChangeParticlesBudget(float particlesMul)
	{
		ParticleSystem component = GetComponent<ParticleSystem>();
		if (component == null)
		{
			return;
		}
		ParticleSystem.MainModule main = component.main;
		main.maxParticles = Mathf.Max(1, (int)((float)main.maxParticles * particlesMul));
		ParticleSystem.EmissionModule emission = component.emission;
		if (!emission.enabled)
		{
			return;
		}
		ParticleSystem.MinMaxCurve rateOverTime = emission.rateOverTime;
		if (rateOverTime.constantMin > 1f)
		{
			rateOverTime.constantMin *= particlesMul;
		}
		if (rateOverTime.constantMax > 1f)
		{
			rateOverTime.constantMax *= particlesMul;
		}
		emission.rateOverTime = rateOverTime;
		ParticleSystem.MinMaxCurve rateOverDistance = emission.rateOverDistance;
		if (rateOverDistance.constantMin > 1f)
		{
			if (rateOverDistance.constantMin > 1f)
			{
				rateOverDistance.constantMin *= particlesMul;
			}
			if (rateOverDistance.constantMax > 1f)
			{
				rateOverDistance.constantMax *= particlesMul;
			}
			emission.rateOverDistance = rateOverDistance;
		}
		ParticleSystem.Burst[] array = new ParticleSystem.Burst[emission.burstCount];
		emission.GetBursts(array);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].minCount > 1)
			{
				array[i].minCount = (short)((float)array[i].minCount * particlesMul);
			}
			if (array[i].maxCount > 1)
			{
				array[i].maxCount = (short)((float)array[i].maxCount * particlesMul);
			}
		}
		emission.SetBursts(array);
	}
}
public class RFX4_MobileBloom : MonoBehaviour
{
	[Range(0.2f, 1f)]
	[UnityEngine.Tooltip("Camera render texture resolution")]
	public float RenderTextureResolutoinFactor = 0.5f;

	[Range(0.05f, 2f)]
	[UnityEngine.Tooltip("Blend factor of the result image.")]
	public float Intensity = 0.5f;

	private static float Threshold = 1.3f;

	private const string shaderName = "Hidden/KriptoFX/PostEffects/RFX4_Bloom";

	private const int kMaxIterations = 16;

	private readonly RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

	private readonly RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

	private RenderTexture Source;

	private Material _bloomMaterial;

	private Material bloomMaterial
	{
		get
		{
			if (_bloomMaterial == null)
			{
				Shader shader = Shader.Find("Hidden/KriptoFX/PostEffects/RFX4_Bloom");
				if (shader == null)
				{
					UnityEngine.Debug.LogError("Can't find shader Hidden/KriptoFX/PostEffects/RFX4_Bloom");
				}
				_bloomMaterial = new Material(shader);
			}
			return _bloomMaterial;
		}
	}

	private void Start()
	{
	}

	private void OnPreRender()
	{
		Source = RenderTexture.GetTemporary(Screen.width, Screen.height, 24, SupportedHdrFormat());
		Camera.main.targetTexture = Source;
	}

	private void OnPostRender()
	{
		Camera.main.targetTexture = null;
		UpdateBloom(Source, null);
		RenderTexture.ReleaseTemporary(Source);
	}

	private RenderTextureFormat SupportedHdrFormat()
	{
		if (SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.RGB111110Float))
		{
			return RenderTextureFormat.RGB111110Float;
		}
		return RenderTextureFormat.DefaultHDR;
	}

	private void UpdateBloom(RenderTexture source, RenderTexture dest)
	{
		int num = Screen.width / 2;
		int num2 = Screen.height / 2;
		RenderTextureFormat format = RenderTextureFormat.Default;
		int width = (int)((float)num * RenderTextureResolutoinFactor);
		num2 = (int)((float)num2 * RenderTextureResolutoinFactor);
		float num3 = Mathf.Log(num2, 2f) - 1f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float value = Mathf.GammaToLinearSpace(Threshold);
		bloomMaterial.SetFloat("_Threshold", value);
		float num6 = 0.5f + num3 - (float)num4;
		bloomMaterial.SetFloat("_SampleScale", num6 * 0.5f);
		bloomMaterial.SetFloat("_Intensity", Mathf.Max(0f, Intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(width, num2, 0, format);
		Graphics.Blit(source, temporary, bloomMaterial, 0);
		RenderTexture renderTexture = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer1[i], bloomMaterial, 1);
			renderTexture = m_blurBuffer1[i];
		}
		for (int num7 = num5 - 2; num7 >= 0; num7--)
		{
			RenderTexture renderTexture2 = m_blurBuffer1[num7];
			bloomMaterial.SetTexture("_BaseTex", renderTexture2);
			m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
			Graphics.Blit(renderTexture, m_blurBuffer2[num7], bloomMaterial, 2);
			renderTexture = m_blurBuffer2[num7];
		}
		RenderTexture temporary2 = RenderTexture.GetTemporary(renderTexture.width, renderTexture.height, 0, renderTexture.format);
		Graphics.Blit(renderTexture, temporary2, bloomMaterial, 3);
		bloomMaterial.SetTexture("_BaseTex", source);
		Graphics.Blit(temporary2, dest, bloomMaterial, 4);
		for (int j = 0; j < 16; j++)
		{
			if (m_blurBuffer1[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if (m_blurBuffer2[j] != null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary2);
		RenderTexture.ReleaseTemporary(temporary);
	}
}
public class FPS : MonoBehaviour
{
	public float UpdateInterval = 1f;

	private Text text;

	private int frames;

	private void Start()
	{
		UnityEngine.Application.targetFrameRate = 1000;
		text = GetComponent<Text>();
		InvokeRepeating("UpdateFPS", UpdateInterval, UpdateInterval);
	}

	private void UpdateFPS()
	{
		if (frames < 30)
		{
			text.color = Color.red;
		}
		if (frames >= 30 && frames <= 50)
		{
			text.color = Color.yellow;
		}
		else
		{
			text.color = Color.green;
		}
		text.text = "FPS: " + frames;
		frames = 0;
	}

	private void Update()
	{
		frames++;
	}
}
public class RFX4_Debug : MonoBehaviour
{
	private void Start()
	{
		RFX4_PhysicsMotion componentInChildren = GetComponentInChildren<RFX4_PhysicsMotion>(includeInactive: true);
		if (componentInChildren != null)
		{
			componentInChildren.CollisionEnter += CollisionEnter;
		}
		RFX4_RaycastCollision componentInChildren2 = GetComponentInChildren<RFX4_RaycastCollision>(includeInactive: true);
		if (componentInChildren2 != null)
		{
			componentInChildren2.CollisionEnter += CollisionEnter;
		}
	}

	private void CollisionEnter(object sender, RFX4_PhysicsMotion.RFX4_CollisionInfo e)
	{
		UnityEngine.Debug.Log(e.HitPoint);
		UnityEngine.Debug.Log(e.HitGameObject.name);
		UnityEngine.Debug.Log(e.HitCollider.name);
	}
}
public class RFX4_DemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	public float[] ReactivationTimes;

	public Light Sun;

	public ReflectionProbe ReflectionProbe;

	public Light[] NightLights = new Light[0];

	public Texture HUETexture;

	public bool isDay;

	private int currentNomber;

	private GameObject currentInstance;

	public GUIStyle guiStyleHeader = new GUIStyle();

	private GUIStyle guiStyleHeaderMobile = new GUIStyle();

	private float dpiScale;

	private float colorHUE;

	private float startSunIntensity;

	private Quaternion startSunRotation;

	private Color startAmbientLight;

	private float startAmbientIntencity;

	private float startReflectionIntencity;

	private LightShadows startLightShadows;

	private bool isButtonPressed;

	private void Start()
	{
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeaderMobile.fontSize = (int)(17f * dpiScale);
		ChangeCurrent(0);
		startSunIntensity = Sun.intensity;
		startSunRotation = Sun.transform.rotation;
		startAmbientLight = RenderSettings.ambientLight;
		startAmbientIntencity = RenderSettings.ambientIntensity;
		startReflectionIntencity = RenderSettings.reflectionIntensity;
		startLightShadows = Sun.shadows;
		ChangeDayNight();
	}

	private void OnGUI()
	{
		if (Input.GetKeyUp(KeyCode.LeftArrow) || Input.GetKeyUp(KeyCode.RightArrow) || Input.GetKeyUp(KeyCode.DownArrow))
		{
			isButtonPressed = false;
		}
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.LeftArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT") || (!isButtonPressed && Input.GetKeyDown(KeyCode.RightArrow)))
		{
			isButtonPressed = true;
			ChangeCurrent(1);
		}
		float num = 0f;
		if (GUI.Button(new Rect(10f * dpiScale, 63f * dpiScale + num, 285f * dpiScale, 37f * dpiScale), "Day / Night") || (!isButtonPressed && Input.GetKeyDown(KeyCode.DownArrow)))
		{
			ChangeDayNight();
		}
		GUI.Label(new Rect(350f * dpiScale, 15f * dpiScale + num / 2f, 500f * dpiScale, 20f * dpiScale), "press left mouse button for the camera rotating and scroll wheel for zooming", guiStyleHeader);
		GUI.Label(new Rect(350f * dpiScale, 35f * dpiScale + num / 2f, 160f * dpiScale, 20f * dpiScale), "prefab name is: " + Prefabs[currentNomber].name, guiStyleHeader);
	}

	private void ChangeDayNight()
	{
		isButtonPressed = true;
		if (ReflectionProbe != null)
		{
			ReflectionProbe.RenderProbe();
		}
		Sun.intensity = ((!isDay) ? 0.05f : startSunIntensity);
		Sun.shadows = (isDay ? startLightShadows : LightShadows.None);
		Light[] nightLights = NightLights;
		foreach (Light light in nightLights)
		{
			if (light != null)
			{
				light.shadows = ((!isDay) ? startLightShadows : LightShadows.None);
			}
		}
		Sun.transform.rotation = (isDay ? startSunRotation : Quaternion.Euler(350f, 30f, 90f));
		RenderSettings.ambientLight = ((!isDay) ? new Color(0.1f, 0.1f, 0.1f) : startAmbientLight);
		RenderSettings.ambientIntensity = (isDay ? startAmbientIntencity : 1f);
		RenderSettings.reflectionIntensity = (isDay ? startReflectionIntencity : 0.2f);
		isDay = !isDay;
	}

	private void ChangeCurrent(int delta)
	{
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if (currentInstance != null)
		{
			UnityEngine.Object.Destroy(currentInstance);
			RemoveClones();
		}
		currentInstance = UnityEngine.Object.Instantiate(Prefabs[currentNomber]);
		if (ReactivationTimes.Length == Prefabs.Length)
		{
			CancelInvoke();
			if (ReactivationTimes[currentNomber] > 0.1f)
			{
				InvokeRepeating("Reactivate", ReactivationTimes[currentNomber], ReactivationTimes[currentNomber]);
			}
		}
	}

	private void RemoveClones()
	{
		GameObject[] array = UnityEngine.Object.FindObjectsOfType<GameObject>();
		foreach (GameObject gameObject in array)
		{
			if (gameObject.name.Contains("(Clone)"))
			{
				UnityEngine.Object.Destroy(gameObject);
			}
		}
	}

	private void Reactivate()
	{
		currentInstance.SetActive(value: false);
		currentInstance.SetActive(value: true);
	}
}
public class RFX4_MouseOrbit : MonoBehaviour
{
	public GameObject target;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	private float x;

	private float y;

	private float prevDistance;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		x = eulerAngles.y;
		y = eulerAngles.x;
	}

	private void LateUpdate()
	{
		if (distance < 2f)
		{
			distance = 2f;
		}
		distance -= Input.GetAxis("Mouse ScrollWheel") * 2f;
		if ((bool)target && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			Vector3 mousePosition = Input.mousePosition;
			float num = 1f;
			if (Screen.dpi < 1f)
			{
				num = 1f;
			}
			num = ((!(Screen.dpi < 200f)) ? (Screen.dpi / 200f) : 1f);
			if (mousePosition.x < 380f * num && (float)Screen.height - mousePosition.y < 250f * num)
			{
				return;
			}
			Cursor.visible = false;
			Cursor.lockState = CursorLockMode.Locked;
			x += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			y -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
		else
		{
			Cursor.visible = true;
			Cursor.lockState = CursorLockMode.None;
		}
		if (Math.Abs(prevDistance - distance) > 0.001f)
		{
			prevDistance = distance;
			Quaternion quaternion2 = Quaternion.Euler(y, x, 0f);
			Vector3 position2 = quaternion2 * new Vector3(0f, 0f, 0f - distance) + target.transform.position;
			base.transform.rotation = quaternion2;
			base.transform.position = position2;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class RFX4_RealtimeReflection : MonoBehaviour
{
	private ReflectionProbe probe;

	private Transform camT;

	private void Awake()
	{
		probe = GetComponent<ReflectionProbe>();
		camT = Camera.main.transform;
	}

	private void Update()
	{
		Vector3 position = camT.position;
		probe.transform.position = new Vector3(position.x, position.y * -1f, position.z);
		probe.RenderProbe();
	}
}
public class BakeTexturesAtRuntime : MonoBehaviour
{
	public GameObject target;

	private float elapsedTime;

	private MB3_TextureCombiner.CreateAtlasesCoroutineResult result = new MB3_TextureCombiner.CreateAtlasesCoroutineResult();

	private void OnGUI()
	{
		GUILayout.Label("Time to bake textures: " + elapsedTime);
		if (GUILayout.Button("Combine textures & build combined mesh all at once"))
		{
			MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
			MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
			component.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component.resultMaterial = new Material(Shader.Find("Diffuse"));
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			component.CreateAtlases();
			elapsedTime = Time.realtimeSinceStartup - realtimeSinceStartup;
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		if (GUILayout.Button("Combine textures & build combined mesh using coroutine"))
		{
			UnityEngine.Debug.Log("Starting to bake textures on frame " + Time.frameCount);
			MB3_TextureBaker component2 = target.GetComponent<MB3_TextureBaker>();
			component2.textureBakeResults = ScriptableObject.CreateInstance<MB2_TextureBakeResults>();
			component2.resultMaterial = new Material(Shader.Find("Diffuse"));
			component2.onBuiltAtlasesSuccess = OnBuiltAtlasesSuccess;
			StartCoroutine(component2.CreateAtlasesCoroutine(null, result));
		}
	}

	private void OnBuiltAtlasesSuccess()
	{
		UnityEngine.Debug.Log("Calling success callback. baking meshes");
		MB3_MeshBaker componentInChildren = target.GetComponentInChildren<MB3_MeshBaker>();
		MB3_TextureBaker component = target.GetComponent<MB3_TextureBaker>();
		if (result.isFinished && result.success)
		{
			componentInChildren.ClearMesh();
			componentInChildren.textureBakeResults = component.textureBakeResults;
			componentInChildren.AddDeleteGameObjects(component.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
			componentInChildren.Apply();
		}
		UnityEngine.Debug.Log("Completed baking textures on frame " + Time.frameCount);
	}
}
public class MB_BatchPrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene is set up to create a combined material and meshes with adjusted UVs so \n objects can share a material and be batched by Unity's static/dynamic batching.\n This scene has added a BatchPrefabBaker component to a Mesh and Material Baker which \n  can bake many prefabs (each of which can have several renderers) in one click.\n The batching tool accepts prefab assets instead of scene objects. \n");
	}
}
public class MB_SwapShirts : MonoBehaviour
{
	public MB3_MeshBaker meshBaker;

	public Renderer[] clothingAndBodyPartsBareTorso;

	public Renderer[] clothingAndBodyPartsBareTorsoDamagedArm;

	public Renderer[] clothingAndBodyPartsHoodie;

	private void Start()
	{
		GameObject[] array = new GameObject[clothingAndBodyPartsBareTorso.Length];
		for (int i = 0; i < clothingAndBodyPartsBareTorso.Length; i++)
		{
			array[i] = clothingAndBodyPartsBareTorso[i].gameObject;
		}
		meshBaker.ClearMesh();
		meshBaker.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		meshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Wear Hoodie"))
		{
			ChangeOutfit(clothingAndBodyPartsHoodie);
		}
		if (GUILayout.Button("Bare Torso"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorso);
		}
		if (GUILayout.Button("Damaged Arm"))
		{
			ChangeOutfit(clothingAndBodyPartsBareTorsoDamagedArm);
		}
	}

	private void ChangeOutfit(Renderer[] outfit)
	{
		List<GameObject> list = new List<GameObject>();
		foreach (GameObject item in meshBaker.meshCombiner.GetObjectsInCombined())
		{
			Renderer component = item.GetComponent<Renderer>();
			bool flag = false;
			for (int i = 0; i < outfit.Length; i++)
			{
				if (component == outfit[i])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(component.gameObject);
				UnityEngine.Debug.Log("Removing " + component.gameObject);
			}
		}
		List<GameObject> list2 = new List<GameObject>();
		for (int j = 0; j < outfit.Length; j++)
		{
			if (!meshBaker.meshCombiner.GetObjectsInCombined().Contains(outfit[j].gameObject))
			{
				list2.Add(outfit[j].gameObject);
				UnityEngine.Debug.Log("Adding " + outfit[j].gameObject);
			}
		}
		meshBaker.AddDeleteGameObjects(list2.ToArray(), list.ToArray(), disableRendererInSource: true);
		meshBaker.Apply();
	}
}
public class MB_PrepareObjectsForDynamicBatchingDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("This scene creates a combined material and meshes with adjusted UVs so objects \n can share a material and be batched by Unity's static/dynamic batching.\n Output has been set to 'bakeMeshAssetsInPlace' on the Mesh Baker\n Position, Scale and Rotation will be baked into meshes so place them appropriately.\n Dynamic batching requires objects with uniform scale. You can fix non-uniform scale here\n After baking you need to duplicate your source prefab assets and replace the  \n meshes and materials with the generated ones.\n");
	}
}
public class MB_DynamicAddDeleteExample : MonoBehaviour
{
	public GameObject prefab;

	private List<GameObject> objsInCombined = new List<GameObject>();

	private MB3_MultiMeshBaker mbd;

	private GameObject[] objs;

	private float GaussianValue()
	{
		float num;
		float num3;
		do
		{
			num = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			float num2 = 2f * UnityEngine.Random.Range(0f, 1f) - 1f;
			num3 = num * num + num2 * num2;
		}
		while (num3 >= 1f);
		num3 = Mathf.Sqrt(-2f * Mathf.Log(num3) / num3);
		return num * num3;
	}

	private void Start()
	{
		mbd = GetComponentInChildren<MB3_MultiMeshBaker>();
		int num = 10;
		GameObject[] array = new GameObject[num * num];
		for (int i = 0; i < num; i++)
		{
			for (int j = 0; j < num; j++)
			{
				GameObject gameObject = UnityEngine.Object.Instantiate(prefab);
				array[i * num + j] = gameObject.GetComponentInChildren<MeshRenderer>().gameObject;
				float num2 = UnityEngine.Random.Range(-4f, 4f);
				float num3 = UnityEngine.Random.Range(-4f, 4f);
				gameObject.transform.position = new Vector3(3f * (float)i + num2, 0f, 3f * (float)j + num3);
				float y = UnityEngine.Random.Range(0, 360);
				gameObject.transform.rotation = Quaternion.Euler(0f, y, 0f);
				Vector3 localScale = Vector3.one + Vector3.one * GaussianValue() * 0.15f;
				gameObject.transform.localScale = localScale;
				if ((i * num + j) % 3 == 0)
				{
					objsInCombined.Add(array[i * num + j]);
				}
			}
		}
		mbd.AddDeleteGameObjects(array, null, disableRendererInSource: true);
		mbd.Apply();
		objs = objsInCombined.ToArray();
		StartCoroutine(largeNumber());
	}

	private IEnumerator largeNumber()
	{
		while (true)
		{
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(null, objs, disableRendererInSource: true);
			mbd.Apply();
			yield return new WaitForSeconds(1.5f);
			mbd.AddDeleteGameObjects(objs, null, disableRendererInSource: true);
			mbd.Apply();
		}
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically instantiates game objects. \nRepeatedly adds and removes some of them\n from the combined mesh.");
	}
}
public class MB_Example : MonoBehaviour
{
	public MB3_MeshBaker meshbaker;

	public GameObject[] objsToCombine;

	private void Start()
	{
		meshbaker.AddDeleteGameObjects(objsToCombine, null, disableRendererInSource: true);
		meshbaker.Apply();
	}

	private void LateUpdate()
	{
		meshbaker.UpdateGameObjects(objsToCombine);
		meshbaker.Apply(triangles: false, vertices: true, normals: true, tangents: true, uvs: false, uv2: false, uv3: false, uv4: false, colors: false);
	}

	private void OnGUI()
	{
		GUILayout.Label("Dynamically updates the vertices, normals and tangents in combined mesh every frame.\nThis is similar to dynamic batching. It is not recommended to do this every frame.\nAlso consider baking the mesh renderer objects into a skinned mesh renderer\nThe skinned mesh approach is faster for objects that need to move independently of each other every frame.");
	}
}
public class MB_ExampleMover : MonoBehaviour
{
	public int axis;

	private void Update()
	{
		Vector3 position = new Vector3(5f, 5f, 5f);
		position[axis] *= Mathf.Sin(Time.time);
		base.transform.position = position;
	}
}
public class MB_ExampleSkinnedMeshDescription : MonoBehaviour
{
	private void OnGUI()
	{
		GUILayout.Label("Mesh Renderer objects have been baked into a skinned mesh. Each source object\n is still in the scene (with renderer disabled) and becomes a bone. Any scripts, animations,\n or physics that affect the invisible source objects will be visible in the\nSkinned Mesh. This approach is more efficient than either dynamic batching or updating every frame \n for many small objects that constantly and independently move. \n With this approach pay attention to the SkinnedMeshRenderer Bounds and Animation Culling\nsettings. You may need to write your own script to manage/update these or your object may vanish or stop animating.\n You can update the combined mesh at runtime as objects are added and deleted from the scene.");
	}
}
public class MB_SkinnedMeshSceneController : MonoBehaviour
{
	public GameObject swordPrefab;

	public GameObject hatPrefab;

	public GameObject glassesPrefab;

	public GameObject workerPrefab;

	public GameObject targetCharacter;

	public MB3_MeshBaker skinnedMeshBaker;

	private GameObject swordInstance;

	private GameObject glassesInstance;

	private GameObject hatInstance;

	private void Start()
	{
		GameObject gameObject = UnityEngine.Object.Instantiate(workerPrefab);
		gameObject.transform.position = new Vector3(1.31f, 0.985f, -0.25f);
		Animation component = gameObject.GetComponent<Animation>();
		component.wrapMode = WrapMode.Loop;
		component.cullingType = AnimationCullingType.AlwaysAnimate;
		component.Play("run");
		GameObject[] gos = new GameObject[1] { gameObject.GetComponentInChildren<SkinnedMeshRenderer>().gameObject };
		skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
		skinnedMeshBaker.Apply();
	}

	private void OnGUI()
	{
		if (GUILayout.Button("Add/Remove Sword"))
		{
			if (swordInstance == null)
			{
				Transform parent = SearchHierarchyForBone(targetCharacter.transform, "RightHandAttachPoint");
				swordInstance = UnityEngine.Object.Instantiate(swordPrefab);
				swordInstance.transform.parent = parent;
				swordInstance.transform.localPosition = Vector3.zero;
				swordInstance.transform.localRotation = Quaternion.identity;
				swordInstance.transform.localScale = Vector3.one;
				GameObject[] gos = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(swordInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs = new GameObject[1] { swordInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(swordInstance);
				swordInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Hat"))
		{
			if (hatInstance == null)
			{
				Transform parent2 = SearchHierarchyForBone(targetCharacter.transform, "HeadAttachPoint");
				hatInstance = UnityEngine.Object.Instantiate(hatPrefab);
				hatInstance.transform.parent = parent2;
				hatInstance.transform.localPosition = Vector3.zero;
				hatInstance.transform.localRotation = Quaternion.identity;
				hatInstance.transform.localScale = Vector3.one;
				GameObject[] gos2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos2, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(hatInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs2 = new GameObject[1] { hatInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs2, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(hatInstance);
				hatInstance = null;
			}
		}
		if (GUILayout.Button("Add/Remove Glasses"))
		{
			if (glassesInstance == null)
			{
				Transform parent3 = SearchHierarchyForBone(targetCharacter.transform, "NoseAttachPoint");
				glassesInstance = UnityEngine.Object.Instantiate(glassesPrefab);
				glassesInstance.transform.parent = parent3;
				glassesInstance.transform.localPosition = Vector3.zero;
				glassesInstance.transform.localRotation = Quaternion.identity;
				glassesInstance.transform.localScale = Vector3.one;
				GameObject[] gos3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(gos3, null, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
			}
			else if (skinnedMeshBaker.CombinedMeshContains(glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject))
			{
				GameObject[] deleteGOs3 = new GameObject[1] { glassesInstance.GetComponentInChildren<MeshRenderer>().gameObject };
				skinnedMeshBaker.AddDeleteGameObjects(null, deleteGOs3, disableRendererInSource: true);
				skinnedMeshBaker.Apply();
				UnityEngine.Object.Destroy(glassesInstance);
				glassesInstance = null;
			}
		}
	}

	public Transform SearchHierarchyForBone(Transform current, string name)
	{
		if (current.name.Equals(name))
		{
			return current;
		}
		for (int i = 0; i < current.childCount; i++)
		{
			Transform transform = SearchHierarchyForBone(current.GetChild(i), name);
			if (transform != null)
			{
				return transform;
			}
		}
		return null;
	}
}
public class MB_SwitchBakedObjectsTexture : MonoBehaviour
{
	public MeshRenderer targetRenderer;

	public Material[] materials;

	public MB3_MeshBaker meshBaker;

	public void OnGUI()
	{
		GUILayout.Label("Press space to switch the material on one of the cubes. This scene reuses the Texture Bake Result from the SceneBasic example.");
	}

	public void Start()
	{
		meshBaker.AddDeleteGameObjects(meshBaker.GetObjectsToCombine().ToArray(), null, disableRendererInSource: true);
		meshBaker.Apply();
	}

	public void Update()
	{
		if (!Input.GetKeyDown(KeyCode.Space))
		{
			return;
		}
		Material sharedMaterial = targetRenderer.sharedMaterial;
		int num = -1;
		for (int i = 0; i < materials.Length; i++)
		{
			if (materials[i] == sharedMaterial)
			{
				num = i;
			}
		}
		num++;
		if (num >= materials.Length)
		{
			num = 0;
		}
		if (num != -1)
		{
			targetRenderer.sharedMaterial = materials[num];
			UnityEngine.Debug.Log("Updating Material to: " + targetRenderer.sharedMaterial);
			GameObject[] gos = new GameObject[1] { targetRenderer.gameObject };
			meshBaker.UpdateGameObjects(gos, recalcBounds: false, updateVertices: false, updateNormals: false, updateTangents: false, updateUV: true, updateUV1: false, updateUV2: false, updateColors: false, updateSkinningInfo: false);
			meshBaker.Apply();
		}
	}
}
public class FastList<T>
{
	public delegate int CompareFunc(T left, T right);

	public T[] array;

	public int size;

	public int Count
	{
		get
		{
			return size;
		}
		set
		{
		}
	}

	public T this[int i]
	{
		get
		{
			return array[i];
		}
		set
		{
			array[i] = value;
		}
	}

	public FastList()
	{
	}

	public FastList(int size)
	{
		if (size > 0)
		{
			this.size = 0;
			array = new T[size];
		}
		else
		{
			this.size = 0;
		}
	}

	public void Add(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		array[size] = item;
		size++;
	}

	public void AddUnique(T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (!Contains(item))
		{
			array[size] = item;
			size++;
		}
	}

	public void AddRange(IEnumerable<T> items)
	{
		foreach (T item in items)
		{
			Add(item);
		}
	}

	public void Insert(int index, T item)
	{
		if (array == null || size == array.Length)
		{
			Allocate();
		}
		if (index < size)
		{
			for (int num = size; num > index; num--)
			{
				array[num] = array[num - 1];
			}
			array[index] = item;
			size++;
		}
		else
		{
			Add(item);
		}
	}

	public bool Remove(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					size--;
					for (int j = i; j < size; j++)
					{
						array[j] = array[j + 1];
					}
					array[size] = default(T);
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAt(int index)
	{
		if (array != null && size > 0 && index < size)
		{
			size--;
			for (int i = index; i < size; i++)
			{
				array[i] = array[i + 1];
			}
			array[size] = default(T);
		}
	}

	public bool RemoveFast(T item)
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (item.Equals(array[i]))
				{
					if (i < size - 1)
					{
						T val = array[size - 1];
						array[size - 1] = default(T);
						array[i] = val;
					}
					else
					{
						array[i] = default(T);
					}
					size--;
					return true;
				}
			}
		}
		return false;
	}

	public void RemoveAtFast(int index)
	{
		if (array != null && index < size && index >= 0)
		{
			if (index == size - 1)
			{
				array[index] = default(T);
			}
			else
			{
				T val = array[size - 1];
				array[index] = val;
				array[size - 1] = default(T);
			}
			size--;
		}
	}

	public bool Contains(T item)
	{
		if (array == null || size <= 0)
		{
			return false;
		}
		for (int i = 0; i < size; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public int IndexOf(T item)
	{
		if (size <= 0 || array == null)
		{
			return -1;
		}
		for (int i = 0; i < size; i++)
		{
			if (item.Equals(array[i]))
			{
				return i;
			}
		}
		return -1;
	}

	public T Pop()
	{
		if (array != null && size > 0)
		{
			T result = array[size - 1];
			array[size - 1] = default(T);
			size--;
			return result;
		}
		return default(T);
	}

	public T[] ToArray()
	{
		Trim();
		return array;
	}

	public void Sort(CompareFunc comparer)
	{
		int num = 0;
		int num2 = size - 1;
		bool flag = true;
		while (flag)
		{
			flag = false;
			for (int i = num; i < num2; i++)
			{
				if (comparer(array[i], array[i + 1]) > 0)
				{
					T val = array[i];
					array[i] = array[i + 1];
					array[i + 1] = val;
					flag = true;
				}
				else if (!flag)
				{
					num = ((i != 0) ? (i - 1) : 0);
				}
			}
		}
	}

	public void InsertionSort(CompareFunc comparer)
	{
		for (int i = 1; i < size; i++)
		{
			T val = array[i];
			int num = i;
			while (num > 0 && comparer(array[num - 1], val) > 0)
			{
				array[num] = array[num - 1];
				num--;
			}
			array[num] = val;
		}
	}

	public IEnumerator<T> GetEnumerator()
	{
		if (array != null)
		{
			for (int i = 0; i < size; i++)
			{
				yield return array[i];
			}
		}
	}

	public T Find(Predicate<T> match)
	{
		if (match != null && array != null)
		{
			for (int i = 0; i < size; i++)
			{
				if (match(array[i]))
				{
					return array[i];
				}
			}
		}
		return default(T);
	}

	private void Allocate()
	{
		T[] array = ((this.array != null) ? new T[Mathf.Max(this.array.Length << 1, 32)] : new T[32]);
		if (this.array != null && size > 0)
		{
			this.array.CopyTo(array, 0);
		}
		this.array = array;
	}

	private void Trim()
	{
		if (size > 0)
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = this.array[i];
			}
			this.array = array;
		}
		else
		{
			this.array = null;
		}
	}

	public void Clear()
	{
		size = 0;
	}

	public void Release()
	{
		Clear();
		array = null;
	}
}
public class InspectorNoteAttribute : PropertyAttribute
{
	public readonly string header;

	public readonly string message;

	public InspectorNoteAttribute(string header, string message = "")
	{
		this.header = header;
		this.message = message;
	}
}
public class InspectorCommentAttribute : PropertyAttribute
{
	public readonly string message;

	public InspectorCommentAttribute(string message = "")
	{
		this.message = message;
	}
}
public class OvrAvatarTestDriver : OvrAvatarDriver
{
	private Vector3 headPos = new Vector3(0f, 1.6f, 0f);

	private Quaternion headRot = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = headPos,
			headRotation = headRot,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class PoseEditHelper : MonoBehaviour
{
	public Transform poseRoot;

	private void OnDrawGizmos()
	{
		if (poseRoot != null)
		{
			DrawJoints(poseRoot);
		}
	}

	private void DrawJoints(Transform joint)
	{
		Gizmos.DrawWireSphere(joint.position, 0.005f);
		for (int i = 0; i < joint.childCount; i++)
		{
			Transform child = joint.GetChild(i);
			if (!child.name.EndsWith("_grip") && !child.name.EndsWith("hand_ignore"))
			{
				Gizmos.DrawLine(joint.position, child.position);
				DrawJoints(child);
			}
		}
	}
}
public class GazeTargetSpawner : MonoBehaviour
{
	public GameObject GazeTargetPrefab;

	public int NumberOfDummyTargets = 100;

	public int RadiusMultiplier = 3;

	[SerializeField]
	private bool isVisible;

	public bool IsVisible
	{
		get
		{
			return isVisible;
		}
		set
		{
			isVisible = value;
			GazeTarget[] componentsInChildren = base.gameObject.GetComponentsInChildren<GazeTarget>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				MeshRenderer component = componentsInChildren[i].GetComponent<MeshRenderer>();
				if (component != null)
				{
					component.enabled = isVisible;
				}
			}
		}
	}

	private void Start()
	{
		for (int i = 0; i < NumberOfDummyTargets; i++)
		{
			GameObject obj = UnityEngine.Object.Instantiate(GazeTargetPrefab, base.transform);
			obj.name = obj.name + "_" + i;
			obj.transform.localPosition = UnityEngine.Random.insideUnitSphere * RadiusMultiplier;
			obj.transform.rotation = Quaternion.identity;
			obj.GetComponent<MeshRenderer>().enabled = IsVisible;
		}
	}

	private void OnValidate()
	{
		IsVisible = isVisible;
	}
}
public class RemoteLoopbackManager : MonoBehaviour
{
	private class PacketLatencyPair
	{
		public byte[] PacketData;

		public float FakeLatency;
	}

	[Serializable]
	public class SimulatedLatencySettings
	{
		[Range(0f, 0.5f)]
		public float FakeLatencyMax = 0.25f;

		[Range(0f, 0.5f)]
		public float FakeLatencyMin = 0.002f;

		[Range(0f, 1f)]
		public float LatencyWeight = 0.25f;

		[Range(0f, 10f)]
		public int MaxSamples = 4;

		internal float AverageWindow;

		internal float LatencySum;

		internal LinkedList<float> LatencyValues = new LinkedList<float>();

		public float NextValue()
		{
			AverageWindow = LatencySum / (float)LatencyValues.Count;
			float num = UnityEngine.Random.Range(FakeLatencyMin, FakeLatencyMax);
			float num2 = AverageWindow * (1f - LatencyWeight) + LatencyWeight * num;
			if (LatencyValues.Count >= MaxSamples)
			{
				LatencySum -= LatencyValues.First.Value;
				LatencyValues.RemoveFirst();
			}
			LatencySum += num2;
			LatencyValues.AddLast(num2);
			return num2;
		}
	}

	public OvrAvatar LocalAvatar;

	public OvrAvatar LoopbackAvatar;

	public SimulatedLatencySettings LatencySettings = new SimulatedLatencySettings();

	private int PacketSequence;

	private LinkedList<PacketLatencyPair> packetQueue = new LinkedList<PacketLatencyPair>();

	private void Start()
	{
		LocalAvatar.RecordPackets = true;
		OvrAvatar localAvatar = LocalAvatar;
		localAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(localAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		float num = UnityEngine.Random.Range(LatencySettings.FakeLatencyMin, LatencySettings.FakeLatencyMax);
		LatencySettings.LatencyValues.AddFirst(num);
		LatencySettings.LatencySum += num;
	}

	private void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (LocalAvatar.UseSDKPackets)
		{
			uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
			byte[] buffer = new byte[num];
			Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, buffer);
			binaryWriter.Write(PacketSequence++);
			binaryWriter.Write(num);
			binaryWriter.Write(buffer);
		}
		else
		{
			binaryWriter.Write(PacketSequence++);
			args.Packet.Write(memoryStream);
		}
		SendPacketData(memoryStream.ToArray());
	}

	private void Update()
	{
		if (packetQueue.Count <= 0)
		{
			return;
		}
		List<PacketLatencyPair> list = new List<PacketLatencyPair>();
		foreach (PacketLatencyPair item in packetQueue)
		{
			item.FakeLatency -= Time.deltaTime;
			if (item.FakeLatency < 0f)
			{
				ReceivePacketData(item.PacketData);
				list.Add(item);
			}
		}
		foreach (PacketLatencyPair item2 in list)
		{
			packetQueue.Remove(item2);
		}
	}

	private void SendPacketData(byte[] data)
	{
		PacketLatencyPair packetLatencyPair = new PacketLatencyPair();
		packetLatencyPair.PacketData = data;
		packetLatencyPair.FakeLatency = LatencySettings.NextValue();
		packetQueue.AddLast(packetLatencyPair);
	}

	private void ReceivePacketData(byte[] data)
	{
		using MemoryStream memoryStream = new MemoryStream(data);
		BinaryReader binaryReader = new BinaryReader(memoryStream);
		int sequence = binaryReader.ReadInt32();
		OvrAvatarPacket packet;
		if (LoopbackAvatar.UseSDKPackets)
		{
			int count = binaryReader.ReadInt32();
			byte[] buffer = binaryReader.ReadBytes(count);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)data.Length, buffer);
			packet = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
		}
		else
		{
			packet = OvrAvatarPacket.Read(memoryStream);
		}
		LoopbackAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet);
	}
}
public class P2PManager
{
	private enum MessageType : byte
	{
		Update = 1
	}

	public P2PManager()
	{
		Net.SetPeerConnectRequestCallback(PeerConnectRequestCallback);
		Net.SetConnectionStateChangedCallback(ConnectionStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Net.Connect(userID);
			SocialPlatformManager.LogOutput("P2P connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Net.Close(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void PeerConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("P2P request accepted from " + msg.Data.ID);
			Net.Accept(msg.Data.ID);
		}
	}

	private void ConnectionStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("P2P state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.p2pConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Net.Connect(msg.Data.ID);
				SocialPlatformManager.LogOutput("P2P re-connect to " + msg.Data.ID);
			}
		}
	}

	public void SendAvatarUpdate(ulong userID, Transform rootTransform, uint sequence, byte[] avatarPacket)
	{
		byte[] array = new byte[avatarPacket.Length + 41];
		int offset = 0;
		PackByte(1, array, ref offset);
		PackULong(SocialPlatformManager.MyID, array, ref offset);
		PackFloat(rootTransform.position.x, array, ref offset);
		PackFloat(0f, array, ref offset);
		PackFloat(rootTransform.position.z, array, ref offset);
		PackFloat(rootTransform.rotation.x, array, ref offset);
		PackFloat(rootTransform.rotation.y, array, ref offset);
		PackFloat(rootTransform.rotation.z, array, ref offset);
		PackFloat(rootTransform.rotation.w, array, ref offset);
		PackUInt32(sequence, array, ref offset);
		Buffer.BlockCopy(avatarPacket, 0, array, offset, avatarPacket.Length);
		Net.SendPacket(userID, array, SendPolicy.Unreliable);
	}

	public void GetRemotePackets()
	{
		Packet packet;
		while ((packet = Net.ReadPacket()) != null)
		{
			byte[] packet2 = new byte[packet.Size];
			packet.ReadBytes(packet2);
			int offset = 0;
			MessageType messageType = (MessageType)ReadByte(packet2, ref offset);
			ulong num = ReadULong(packet2, ref offset);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(num);
			if (remoteUser == null)
			{
				SocialPlatformManager.LogOutput("Unknown remote player: " + num);
			}
			else if (messageType == MessageType.Update)
			{
				processAvatarPacket(remoteUser, ref packet2, ref offset);
			}
			else
			{
				SocialPlatformManager.LogOutput("Invalid packet type: " + packet.Size);
			}
		}
	}

	public void processAvatarPacket(RemotePlayer remote, ref byte[] packet, ref int offset)
	{
		if (remote != null)
		{
			remote.receivedRootPositionPrior = remote.receivedRootPosition;
			remote.receivedRootPosition.x = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.y = ReadFloat(packet, ref offset);
			remote.receivedRootPosition.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotationPrior = remote.receivedRootRotation;
			remote.receivedRootRotation.x = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.y = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.z = ReadFloat(packet, ref offset);
			remote.receivedRootRotation.w = ReadFloat(packet, ref offset);
			remote.RemoteAvatar.transform.position = remote.receivedRootPosition;
			remote.RemoteAvatar.transform.rotation = remote.receivedRootRotation;
			int sequence = (int)ReadUInt32(packet, ref offset);
			byte[] array = new byte[packet.Length - offset];
			Buffer.BlockCopy(packet, offset, array, 0, array.Length);
			IntPtr ovrNativePacket = Oculus.Avatar.CAPI.ovrAvatarPacket_Read((uint)array.Length, array);
			OvrAvatarPacket packet2 = new OvrAvatarPacket
			{
				ovrNativePacket = ovrNativePacket
			};
			remote.RemoteAvatar.GetComponent<OvrAvatarRemoteDriver>().QueuePacket(sequence, packet2);
		}
	}

	private void PackByte(byte b, byte[] buf, ref int offset)
	{
		buf[offset] = b;
		offset++;
	}

	private byte ReadByte(byte[] buf, ref int offset)
	{
		byte result = buf[offset];
		offset++;
		return result;
	}

	private void PackFloat(float f, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(f), 0, buf, offset, 4);
		offset += 4;
	}

	private float ReadFloat(byte[] buf, ref int offset)
	{
		float result = BitConverter.ToSingle(buf, offset);
		offset += 4;
		return result;
	}

	private void PackULong(ulong u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 8);
		offset += 8;
	}

	private ulong ReadULong(byte[] buf, ref int offset)
	{
		ulong result = BitConverter.ToUInt64(buf, offset);
		offset += 8;
		return result;
	}

	private void PackUInt32(uint u, byte[] buf, ref int offset)
	{
		Buffer.BlockCopy(BitConverter.GetBytes(u), 0, buf, offset, 4);
		offset += 4;
	}

	private uint ReadUInt32(byte[] buf, ref int offset)
	{
		uint result = BitConverter.ToUInt32(buf, offset);
		offset += 4;
		return result;
	}
}
public class PlayerController : SocialPlatformManager
{
	public Camera spyCamera;

	private GameObject cameraRig;

	private bool showUI = true;

	public override void Awake()
	{
		base.Awake();
		cameraRig = localPlayerHead.gameObject;
	}

	public override void Start()
	{
		base.Start();
		spyCamera.enabled = false;
	}

	public override void Update()
	{
		base.Update();
		checkInput();
	}

	private void checkInput()
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			if (OVRInput.GetDown(OVRInput.Button.Back))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryTouchpad))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryIndexTrigger))
			{
				ToggleUI();
			}
		}
		else
		{
			if (OVRInput.GetDown(OVRInput.Button.Three))
			{
				Rooms.LaunchInvitableUserFlow(roomManager.roomID);
			}
			if (OVRInput.GetDown(OVRInput.Button.Four))
			{
				ToggleCamera();
			}
			if (OVRInput.GetDown(OVRInput.Button.PrimaryThumbstick))
			{
				ToggleUI();
			}
		}
	}

	private void ToggleCamera()
	{
		spyCamera.enabled = !spyCamera.enabled;
		localAvatar.ShowThirdPerson = !localAvatar.ShowThirdPerson;
		cameraRig.SetActive(!cameraRig.activeSelf);
	}

	private void ToggleUI()
	{
		showUI = !showUI;
		helpPanel.SetActive(showUI);
		localAvatar.ShowLeftController(showUI);
	}
}
public class RemotePlayer
{
	public ulong remoteUserID;

	public bool stillInRoom;

	public PeerConnectionState p2pConnectionState;

	public PeerConnectionState voipConnectionState;

	public OvrAvatar RemoteAvatar;

	public Vector3 receivedRootPosition;

	public Vector3 receivedRootPositionPrior;

	public Quaternion receivedRootRotation;

	public Quaternion receivedRootRotationPrior;

	public VoipAudioSourceHiLevel voipSource;
}
public class RoomManager
{
	public ulong roomID;

	private ulong invitedRoomID;

	private bool amIServer;

	private bool startupDone;

	public RoomManager()
	{
		amIServer = false;
		startupDone = false;
		Rooms.SetRoomInviteAcceptedNotificationCallback(AcceptingInviteCallback);
		Rooms.SetUpdateNotificationCallback(RoomUpdateCallback);
	}

	private void AcceptingInviteCallback(Message<string> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		SocialPlatformManager.LogOutput("Launched Invite to join Room: " + msg.Data);
		invitedRoomID = Convert.ToUInt64(msg.GetString());
		if (startupDone)
		{
			CheckForInvite();
		}
	}

	public bool CheckForInvite()
	{
		startupDone = true;
		if (invitedRoomID != 0L)
		{
			JoinExistingRoom(invitedRoomID);
			return true;
		}
		return false;
	}

	public void CreateRoom()
	{
		Rooms.CreateAndJoinPrivate(RoomJoinPolicy.FriendsOfOwner, 4u, subscribeToUpdates: true).OnComplete(CreateAndJoinPrivateRoomCallback);
	}

	private void CreateAndJoinPrivateRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		roomID = msg.Data.ID;
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}

	private void OnLaunchInviteWorkflowComplete(Message msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
		}
	}

	public void JoinExistingRoom(ulong roomID)
	{
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.JOINING_A_ROOM);
		Rooms.Join(roomID, subscribeToUpdates: true).OnComplete(JoinRoomCallback);
	}

	private void JoinRoomCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (!msg.IsError)
		{
			string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
			int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
			SocialPlatformManager.LogOutput("Joined Room " + msg.Data.ID + " owner: " + text + " count: " + num);
			roomID = msg.Data.ID;
			ProcessRoomData(msg);
		}
	}

	private void RoomUpdateCallback(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.IsError)
		{
			SocialPlatformManager.TerminateWithError(msg);
			return;
		}
		string text = ((msg.Data.OwnerOptional != null) ? msg.Data.OwnerOptional.OculusID : "null");
		int num = ((msg.Data.UsersOptional != null) ? msg.Data.UsersOptional.Count : 0);
		SocialPlatformManager.LogOutput("Room Update " + msg.Data.ID + " owner: " + text + " count: " + num);
		ProcessRoomData(msg);
	}

	public void LeaveCurrentRoom()
	{
		if (roomID != 0L)
		{
			Rooms.Leave(roomID);
			roomID = 0uL;
		}
		SocialPlatformManager.TransitionToState(SocialPlatformManager.State.LEAVING_A_ROOM);
	}

	private void ProcessRoomData(Message<Oculus.Platform.Models.Room> msg)
	{
		if (msg.Data.OwnerOptional != null && msg.Data.OwnerOptional.ID == SocialPlatformManager.MyID)
		{
			amIServer = true;
		}
		else
		{
			amIServer = false;
		}
		if (msg.Data.UsersOptional != null && msg.Data.UsersOptional.Count == 1)
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.WAITING_IN_A_ROOM);
		}
		else
		{
			SocialPlatformManager.TransitionToState(SocialPlatformManager.State.CONNECTED_IN_A_ROOM);
		}
		SocialPlatformManager.MarkAllRemoteUsersAsNotInRoom();
		if (msg.Data.UsersOptional != null)
		{
			foreach (User item in msg.Data.UsersOptional)
			{
				if (item.ID != SocialPlatformManager.MyID)
				{
					if (!SocialPlatformManager.IsUserInRoom(item.ID))
					{
						SocialPlatformManager.AddRemoteUser(item.ID);
					}
					else
					{
						SocialPlatformManager.MarkRemoteUserInRoom(item.ID);
					}
				}
			}
		}
		SocialPlatformManager.ForgetRemoteUsersNotInRoom();
		SocialPlatformManager.SetFloorColorForState(amIServer);
	}
}
public class SocialPlatformManager : MonoBehaviour
{
	public enum State
	{
		INITIALIZING,
		CHECKING_LAUNCH_STATE,
		CREATING_A_ROOM,
		WAITING_IN_A_ROOM,
		JOINING_A_ROOM,
		CONNECTED_IN_A_ROOM,
		LEAVING_A_ROOM,
		SHUTDOWN
	}

	private static readonly Vector3 START_ROTATION_ONE = new Vector3(0f, 180f, 0f);

	private static readonly Vector3 START_POSITION_ONE = new Vector3(0f, 4f, 5f);

	private static readonly Vector3 START_ROTATION_TWO = new Vector3(0f, 0f, 0f);

	private static readonly Vector3 START_POSITION_TWO = new Vector3(0f, 4f, -5f);

	private static readonly Vector3 START_ROTATION_THREE = new Vector3(0f, 270f, 0f);

	private static readonly Vector3 START_POSITION_THREE = new Vector3(5f, 4f, 0f);

	private static readonly Vector3 START_ROTATION_FOUR = new Vector3(0f, 90f, 0f);

	private static readonly Vector3 START_POSITION_FOUR = new Vector3(-5f, 4f, 0f);

	private static readonly Color BLACK = new Color(0f, 0f, 0f);

	private static readonly Color WHITE = new Color(1f, 1f, 1f);

	private static readonly Color CYAN = new Color(0f, 1f, 1f);

	private static readonly Color BLUE = new Color(0f, 0f, 1f);

	private static readonly Color GREEN = new Color(0f, 1f, 0f);

	private float voiceCurrent;

	private uint packetSequence;

	public OvrAvatar localAvatarPrefab;

	public OvrAvatar remoteAvatarPrefab;

	public GameObject helpPanel;

	protected MeshRenderer helpMesh;

	public Material riftMaterial;

	public Material gearMaterial;

	protected OvrAvatar localAvatar;

	protected GameObject localTrackingSpace;

	protected GameObject localPlayerHead;

	protected Dictionary<ulong, RemotePlayer> remoteUsers = new Dictionary<ulong, RemotePlayer>();

	public GameObject roomSphere;

	protected MeshRenderer sphereMesh;

	public GameObject roomFloor;

	protected MeshRenderer floorMesh;

	protected State currentState;

	protected static SocialPlatformManager s_instance = null;

	protected RoomManager roomManager;

	protected P2PManager p2pManager;

	protected VoipManager voipManager;

	protected ulong myID;

	protected string myOculusID;

	public static readonly float VOIP_SCALE = 2f;

	public static State CurrentState => s_instance.currentState;

	public static ulong MyID
	{
		get
		{
			if (s_instance != null)
			{
				return s_instance.myID;
			}
			return 0uL;
		}
	}

	public static string MyOculusID
	{
		get
		{
			if (s_instance != null && s_instance.myOculusID != null)
			{
				return s_instance.myOculusID;
			}
			return string.Empty;
		}
	}

	public virtual void Update()
	{
		p2pManager.GetRemotePackets();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			if (remoteUser.Value.voipSource == null && remoteUser.Value.RemoteAvatar.MouthAnchor != null)
			{
				remoteUser.Value.voipSource = remoteUser.Value.RemoteAvatar.MouthAnchor.AddComponent<VoipAudioSourceHiLevel>();
				remoteUser.Value.voipSource.senderID = remoteUser.Value.remoteUserID;
			}
			if (remoteUser.Value.voipSource != null)
			{
				float voiceAmplitude = Mathf.Clamp(remoteUser.Value.voipSource.peakAmplitude * VOIP_SCALE, 0f, 1f);
				remoteUser.Value.RemoteAvatar.VoiceAmplitude = voiceAmplitude;
			}
		}
		if (localAvatar != null)
		{
			localAvatar.VoiceAmplitude = Mathf.Clamp(voiceCurrent * VOIP_SCALE, 0f, 1f);
		}
		Request.RunCallbacks();
	}

	public virtual void Awake()
	{
		LogOutputLine("Start Log.");
		helpMesh = helpPanel.GetComponent<MeshRenderer>();
		sphereMesh = roomSphere.GetComponent<MeshRenderer>();
		floorMesh = roomFloor.GetComponent<MeshRenderer>();
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localPlayerHead = base.transform.Find("OVRCameraRig/TrackingSpace/CenterEyeAnchor").gameObject;
		if (s_instance != null)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		s_instance = this;
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
		TransitionToState(State.INITIALIZING);
		Core.AsyncInitialize().OnComplete(InitCallback);
		roomManager = new RoomManager();
		p2pManager = new P2PManager();
		voipManager = new VoipManager();
	}

	private void InitCallback(Message<PlatformInitialize> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		LaunchDetails launchDetails = ApplicationLifecycle.GetLaunchDetails();
		LogOutput("App launched with LaunchType " + launchDetails.LaunchType);
		Entitlements.IsUserEntitledToApplication().OnComplete(IsEntitledCallback);
	}

	public virtual void Start()
	{
	}

	private void IsEntitledCallback(Message msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
		}
		else
		{
			Users.GetLoggedInUser().OnComplete(GetLoggedInUserCallback);
		}
	}

	private void GetLoggedInUserCallback(Message<User> msg)
	{
		if (msg.IsError)
		{
			TerminateWithError(msg);
			return;
		}
		myID = msg.Data.ID;
		myOculusID = msg.Data.OculusID;
		localAvatar = UnityEngine.Object.Instantiate(localAvatarPrefab);
		localAvatar.CanOwnMicrophone = false;
		localTrackingSpace = base.transform.Find("OVRCameraRig/TrackingSpace").gameObject;
		localAvatar.transform.SetParent(localTrackingSpace.transform, worldPositionStays: false);
		localAvatar.transform.localPosition = new Vector3(0f, 0f, 0f);
		localAvatar.transform.localRotation = Quaternion.identity;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("body"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 1f, 1f);
			helpMesh.material = gearMaterial;
		}
		else
		{
			helpPanel.transform.SetParent(localAvatar.transform.Find("hand_left"), worldPositionStays: false);
			helpPanel.transform.localPosition = new Vector3(0f, 0.2f, 0.2f);
			helpMesh.material = riftMaterial;
		}
		localAvatar.oculusUserID = myID.ToString();
		localAvatar.RecordPackets = true;
		OvrAvatar ovrAvatar = localAvatar;
		ovrAvatar.PacketRecorded = (EventHandler<OvrAvatar.PacketEventArgs>)Delegate.Combine(ovrAvatar.PacketRecorded, new EventHandler<OvrAvatar.PacketEventArgs>(OnLocalAvatarPacketRecorded));
		localAvatar.EnableMouthVertexAnimation = true;
		Quaternion identity = Quaternion.identity;
		switch (UnityEngine.Random.Range(0, 4))
		{
		case 0:
			identity.eulerAngles = START_ROTATION_ONE;
			base.transform.localPosition = START_POSITION_ONE;
			base.transform.localRotation = identity;
			break;
		case 1:
			identity.eulerAngles = START_ROTATION_TWO;
			base.transform.localPosition = START_POSITION_TWO;
			base.transform.localRotation = identity;
			break;
		case 2:
			identity.eulerAngles = START_ROTATION_THREE;
			base.transform.localPosition = START_POSITION_THREE;
			base.transform.localRotation = identity;
			break;
		default:
			identity.eulerAngles = START_ROTATION_FOUR;
			base.transform.localPosition = START_POSITION_FOUR;
			base.transform.localRotation = identity;
			break;
		}
		TransitionToState(State.CHECKING_LAUNCH_STATE);
		if (!roomManager.CheckForInvite())
		{
			LogOutput("No invite on launch, looking for a friend to join.");
			Users.GetLoggedInUserFriendsAndRooms().OnComplete(GetLoggedInUserFriendsAndRoomsCallback);
		}
		Voip.SetMicrophoneFilterCallback(MicFilter);
	}

	private void GetLoggedInUserFriendsAndRoomsCallback(Message<UserAndRoomList> msg)
	{
		if (msg.IsError)
		{
			return;
		}
		foreach (UserAndRoom datum in msg.Data)
		{
			if (datum.User != null && datum.RoomOptional != null && !datum.RoomOptional.IsMembershipLocked && datum.RoomOptional.Joinability == RoomJoinability.CanJoin && datum.RoomOptional.JoinPolicy != 0)
			{
				LogOutput("Trying to join room " + datum.RoomOptional.ID + ", friend " + datum.User.OculusID);
				roomManager.JoinExistingRoom(datum.RoomOptional.ID);
				return;
			}
		}
		LogOutput("No friend to join. Creating my own room.");
		roomManager.CreateRoom();
		TransitionToState(State.CREATING_A_ROOM);
	}

	public void OnLocalAvatarPacketRecorded(object sender, OvrAvatar.PacketEventArgs args)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetSize(args.Packet.ovrNativePacket);
		byte[] array = new byte[num];
		Oculus.Avatar.CAPI.ovrAvatarPacket_Write(args.Packet.ovrNativePacket, num, array);
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.SendAvatarUpdate(remoteUser.Key, localTrackingSpace.transform, packetSequence, array);
		}
		packetSequence++;
	}

	public void OnApplicationQuit()
	{
		roomManager.LeaveCurrentRoom();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in remoteUsers)
		{
			p2pManager.Disconnect(remoteUser.Key);
			voipManager.Disconnect(remoteUser.Key);
		}
		LogOutputLine("End Log.");
	}

	public void AddUser(ulong userID, ref RemotePlayer remoteUser)
	{
		remoteUsers.Add(userID, remoteUser);
	}

	public void LogOutputLine(string line)
	{
		UnityEngine.Debug.Log(Time.time + ": " + line);
	}

	public static void TerminateWithError(Message msg)
	{
		s_instance.LogOutputLine("Error: " + msg.GetError().Message);
		UnityEngine.Application.Quit();
	}

	public static void TransitionToState(State newState)
	{
		if ((bool)s_instance)
		{
			s_instance.LogOutputLine(string.Concat("State ", s_instance.currentState, " -> ", newState));
		}
		if ((bool)s_instance && s_instance.currentState != newState)
		{
			s_instance.currentState = newState;
			if (newState == State.SHUTDOWN)
			{
				s_instance.OnApplicationQuit();
			}
		}
		SetSphereColorForState();
	}

	private static void SetSphereColorForState()
	{
		switch (s_instance.currentState)
		{
		case State.INITIALIZING:
		case State.SHUTDOWN:
			s_instance.sphereMesh.material.color = BLACK;
			break;
		case State.WAITING_IN_A_ROOM:
			s_instance.sphereMesh.material.color = WHITE;
			break;
		case State.CONNECTED_IN_A_ROOM:
			s_instance.sphereMesh.material.color = CYAN;
			break;
		}
	}

	public static void SetFloorColorForState(bool host)
	{
		if (host)
		{
			s_instance.floorMesh.material.color = BLUE;
		}
		else
		{
			s_instance.floorMesh.material.color = GREEN;
		}
	}

	public static void MarkAllRemoteUsersAsNotInRoom()
	{
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			remoteUser.Value.stillInRoom = false;
		}
	}

	public static void MarkRemoteUserInRoom(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			value.stillInRoom = true;
		}
	}

	public static void ForgetRemoteUsersNotInRoom()
	{
		List<ulong> list = new List<ulong>();
		foreach (KeyValuePair<ulong, RemotePlayer> remoteUser in s_instance.remoteUsers)
		{
			if (!remoteUser.Value.stillInRoom)
			{
				list.Add(remoteUser.Key);
			}
		}
		foreach (ulong item in list)
		{
			RemoveRemoteUser(item);
		}
	}

	public static void LogOutput(string line)
	{
		s_instance.LogOutputLine(Time.time + ": " + line);
	}

	public static bool IsUserInRoom(ulong userID)
	{
		return s_instance.remoteUsers.ContainsKey(userID);
	}

	public static void AddRemoteUser(ulong userID)
	{
		RemotePlayer remoteUser = new RemotePlayer();
		remoteUser.RemoteAvatar = UnityEngine.Object.Instantiate(s_instance.remoteAvatarPrefab);
		remoteUser.RemoteAvatar.oculusUserID = userID.ToString();
		remoteUser.RemoteAvatar.ShowThirdPerson = true;
		remoteUser.RemoteAvatar.EnableMouthVertexAnimation = true;
		remoteUser.p2pConnectionState = PeerConnectionState.Unknown;
		remoteUser.voipConnectionState = PeerConnectionState.Unknown;
		remoteUser.stillInRoom = true;
		remoteUser.remoteUserID = userID;
		s_instance.AddUser(userID, ref remoteUser);
		s_instance.p2pManager.ConnectTo(userID);
		s_instance.voipManager.ConnectTo(userID);
		s_instance.LogOutputLine("Adding User " + userID);
	}

	public static void RemoveRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			UnityEngine.Object.Destroy(value.RemoteAvatar.MouthAnchor.GetComponent<VoipAudioSourceHiLevel>(), 0f);
			UnityEngine.Object.Destroy(value.RemoteAvatar.gameObject, 0f);
			s_instance.remoteUsers.Remove(userID);
			s_instance.LogOutputLine("Removing User " + userID);
		}
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (localAvatar != null)
		{
			localAvatar.UpdateVoiceData(pcmData, numChannels);
		}
		float num = 0f;
		float[] array = new float[pcmData.Length];
		for (int i = 0; i < pcmData.Length; i++)
		{
			float num2 = (array[i] = (float)pcmData[i] / 32767f);
			if (num2 > num)
			{
				num = num2;
			}
		}
		voiceCurrent = num;
	}

	[MonoPInvokeCallback(typeof(Oculus.Platform.CAPI.FilterCallback))]
	public static void MicFilter(short[] pcmData, UIntPtr pcmDataLength, int frequency, int numChannels)
	{
		s_instance.UpdateVoiceData(pcmData, numChannels);
	}

	public static RemotePlayer GetRemoteUser(ulong userID)
	{
		RemotePlayer value = new RemotePlayer();
		if (s_instance.remoteUsers.TryGetValue(userID, out value))
		{
			return value;
		}
		return null;
	}
}
public class VoipManager
{
	public VoipManager()
	{
		Voip.SetVoipConnectRequestCallback(VoipConnectRequestCallback);
		Voip.SetVoipStateChangeCallback(VoipStateChangedCallback);
	}

	public void ConnectTo(ulong userID)
	{
		if (SocialPlatformManager.MyID < userID)
		{
			Voip.Start(userID);
			SocialPlatformManager.LogOutput("Voip connect to " + userID);
		}
	}

	public void Disconnect(ulong userID)
	{
		if (userID != 0L)
		{
			Voip.Stop(userID);
			RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(userID);
			if (remoteUser != null)
			{
				remoteUser.voipConnectionState = PeerConnectionState.Unknown;
			}
		}
	}

	private void VoipConnectRequestCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip request from " + msg.Data.ID);
		if (SocialPlatformManager.GetRemoteUser(msg.Data.ID) != null)
		{
			SocialPlatformManager.LogOutput("Voip request accepted from " + msg.Data.ID);
			Voip.Accept(msg.Data.ID);
		}
	}

	private void VoipStateChangedCallback(Message<NetworkingPeer> msg)
	{
		SocialPlatformManager.LogOutput("Voip state to " + msg.Data.ID + " changed to  " + msg.Data.State);
		RemotePlayer remoteUser = SocialPlatformManager.GetRemoteUser(msg.Data.ID);
		if (remoteUser != null)
		{
			remoteUser.voipConnectionState = msg.Data.State;
			if (msg.Data.State == PeerConnectionState.Timeout && SocialPlatformManager.MyID < msg.Data.ID)
			{
				Voip.Start(msg.Data.ID);
				SocialPlatformManager.LogOutput("Voip re-connect to " + msg.Data.ID);
			}
		}
	}
}
public class GazeTarget : MonoBehaviour
{
	public ovrAvatarGazeTargetType Type;

	private static ovrAvatarGazeTargets RuntimeTargetList;

	static GazeTarget()
	{
		RuntimeTargetList.targets = new ovrAvatarGazeTarget[128];
		RuntimeTargetList.targetCount = 1u;
	}

	private void Start()
	{
		UpdateGazeTarget();
		base.transform.hasChanged = false;
	}

	private void Update()
	{
		if (base.transform.hasChanged)
		{
			base.transform.hasChanged = false;
			UpdateGazeTarget();
		}
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.ovrAvatar_RemoveGazeTargets(1u, new uint[1] { (uint)base.transform.GetInstanceID() });
	}

	private void UpdateGazeTarget()
	{
		ovrAvatarGazeTarget ovrAvatarGazeTarget2 = CreateOvrGazeTarget((uint)base.transform.GetInstanceID(), base.transform.position, Type);
		RuntimeTargetList.targets[0] = ovrAvatarGazeTarget2;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateGazeTargets(RuntimeTargetList);
	}

	private ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}
}
[Serializable]
public class AvatarLayer
{
	public int layerIndex;
}
[Serializable]
public class PacketRecordSettings
{
	internal bool RecordingFrames;

	public float UpdateRate = 1f / 30f;

	internal float AccumulatedTime;
}
public class OvrAvatar : MonoBehaviour
{
	public class PacketEventArgs : EventArgs
	{
		public readonly OvrAvatarPacket Packet;

		public PacketEventArgs(OvrAvatarPacket packet)
		{
			Packet = packet;
		}
	}

	public enum HandType
	{
		Right,
		Left,
		Max
	}

	public enum HandJoint
	{
		HandBase,
		IndexBase,
		IndexTip,
		ThumbBase,
		ThumbTip,
		Max
	}

	[Header("Avatar")]
	public IntPtr sdkAvatar = IntPtr.Zero;

	public string oculusUserID;

	public OvrAvatarDriver Driver;

	[Header("Capabilities")]
	public bool EnableBody = true;

	public bool EnableHands = true;

	public bool EnableBase = true;

	public bool EnableExpressive;

	[Header("Network")]
	public bool RecordPackets;

	public bool UseSDKPackets = true;

	public PacketRecordSettings PacketSettings = new PacketRecordSettings();

	[Header("Visibility")]
	public bool StartWithControllers;

	public AvatarLayer FirstPersonLayer;

	public AvatarLayer ThirdPersonLayer;

	public bool ShowFirstPerson = true;

	public bool ShowThirdPerson;

	internal ovrAvatarCapabilities Capabilities = ovrAvatarCapabilities.Body;

	[Header("Performance")]
	[UnityEngine.Tooltip("LOD mesh complexity and texture resolution. Highest LOD recommended on PC and simple mobile apps. Medium LOD recommended on mobile devices or for background characters on PC. Lowest LOD recommended for background characters on mobile.")]
	[SerializeField]
	internal ovrAvatarAssetLevelOfDetail LevelOfDetail = ovrAvatarAssetLevelOfDetail.Medium;

	[UnityEngine.Tooltip("Enable to use combined meshes to reduce draw calls. Currently only available on mobile devices. Will be forced to false on PC.")]
	private bool CombineMeshes = true;

	[UnityEngine.Tooltip("Enable to use transparent queue, disable to use geometry queue. Requires restart to take effect.")]
	public bool UseTransparentRenderQueue = true;

	[Header("Shaders")]
	public Shader Monochrome_SurfaceShader;

	public Shader Monochrome_SurfaceShader_SelfOccluding;

	public Shader Monochrome_SurfaceShader_PBS;

	public Shader Skinshaded_SurfaceShader_SingleComponent;

	public Shader Skinshaded_VertFrag_SingleComponent;

	public Shader Skinshaded_VertFrag_CombinedMesh;

	public Shader Skinshaded_Expressive_SurfaceShader_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_SingleComponent;

	public Shader Skinshaded_Expressive_VertFrag_CombinedMesh;

	public Shader Loader_VertFrag_CombinedMesh;

	public Shader EyeLens;

	public Shader ControllerShader;

	[Header("Other")]
	public bool CanOwnMicrophone = true;

	[UnityEngine.Tooltip("Enable laughter detection and animation as part of OVRLipSync.")]
	public bool EnableLaughter = true;

	public GameObject MouthAnchor;

	public Transform LeftHandCustomPose;

	public Transform RightHandCustomPose;

	private HashSet<ulong> assetLoadingIds = new HashSet<ulong>();

	private bool assetsFinishedLoading;

	private OvrAvatarMaterialManager materialManager;

	private bool waitingForCombinedMesh;

	private static bool doneExpressiveGlobalInit;

	private Vector4 clothingAlphaOffset = new Vector4(0f, 0f, 0f, 1f);

	private ulong clothingAlphaTexture;

	private OVRLipSyncMicInput micInput;

	private OVRLipSyncContext lipsyncContext;

	private OVRLipSync.Frame currentFrame = new OVRLipSync.Frame();

	private float[] visemes = new float[16];

	private AudioSource audioSource;

	private ONSPAudioSource spatializedSource;

	private List<float[]> voiceUpdates = new List<float[]>();

	private static ovrAvatarVisemes RuntimeVisemes;

	private Transform cachedLeftHandCustomPose;

	private Transform[] cachedCustomLeftHandJoints;

	private ovrAvatarTransform[] cachedLeftHandTransforms;

	private Transform cachedRightHandCustomPose;

	private Transform[] cachedCustomRightHandJoints;

	private ovrAvatarTransform[] cachedRightHandTransforms;

	private bool showLeftController;

	private bool showRightController;

	private const bool USE_MOBILE_TEXTURE_FORMAT = true;

	private static readonly Vector3 MOUTH_HEAD_OFFSET;

	private const string MOUTH_HELPER_NAME = "MouthAnchor";

	private const int VISEME_COUNT = 16;

	private const float ACTION_UNIT_ONSET_SPEED = 30f;

	private const float ACTION_UNIT_FALLOFF_SPEED = 20f;

	private const float VISEME_LEVEL_MULTIPLIER = 1.5f;

	internal ulong oculusUserIDInternal;

	internal OvrAvatarBase Base;

	internal OvrAvatarTouchController ControllerLeft;

	internal OvrAvatarTouchController ControllerRight;

	internal OvrAvatarBody Body;

	internal OvrAvatarHand HandLeft;

	internal OvrAvatarHand HandRight;

	internal ovrAvatarLookAndFeelVersion LookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	internal ovrAvatarLookAndFeelVersion FallbackLookAndFeelVersion = ovrAvatarLookAndFeelVersion.Two;

	private OvrAvatarPacket CurrentUnityPacket;

	public EventHandler<PacketEventArgs> PacketRecorded;

	private static string[,] HandJoints;

	private static Vector3 MOUTH_POSITION_OFFSET;

	private static string VOICE_PROPERTY;

	private static string MOUTH_POSITION_PROPERTY;

	private static string MOUTH_DIRECTION_PROPERTY;

	private static string MOUTH_SCALE_PROPERTY;

	private static float MOUTH_SCALE_GLOBAL;

	private static float MOUTH_MAX_GLOBAL;

	private static string NECK_JONT;

	public float VoiceAmplitude;

	public bool EnableMouthVertexAnimation;

	private static ovrAvatarLights ovrLights;

	static OvrAvatar()
	{
		doneExpressiveGlobalInit = false;
		MOUTH_HEAD_OFFSET = new Vector3(0f, -0.085f, 0.09f);
		HandJoints = new string[2, 5]
		{
			{ "hands:r_hand_world", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1", "hands:r_hand_world/hands:b_r_hand/hands:b_r_index1/hands:b_r_index2/hands:b_r_index3/hands:b_r_index_ignore", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2", "hands:r_hand_world/hands:b_r_hand/hands:b_r_thumb1/hands:b_r_thumb2/hands:b_r_thumb3/hands:b_r_thumb_ignore" },
			{ "hands:l_hand_world", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1", "hands:l_hand_world/hands:b_l_hand/hands:b_l_index1/hands:b_l_index2/hands:b_l_index3/hands:b_l_index_ignore", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2", "hands:l_hand_world/hands:b_l_hand/hands:b_l_thumb1/hands:b_l_thumb2/hands:b_l_thumb3/hands:b_l_thumb_ignore" }
		};
		MOUTH_POSITION_OFFSET = new Vector3(0f, -0.018f, 0.1051f);
		VOICE_PROPERTY = "_Voice";
		MOUTH_POSITION_PROPERTY = "_MouthPosition";
		MOUTH_DIRECTION_PROPERTY = "_MouthDirection";
		MOUTH_SCALE_PROPERTY = "_MouthEffectScale";
		MOUTH_SCALE_GLOBAL = 0.007f;
		MOUTH_MAX_GLOBAL = 0.007f;
		NECK_JONT = "root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT";
		ovrLights = default(ovrAvatarLights);
		RuntimeVisemes.visemeParams = new float[32];
		RuntimeVisemes.visemeParamCount = 16u;
	}

	private void OnDestroy()
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_Destroy(sdkAvatar);
		}
	}

	public void AssetLoadedCallback(OvrAvatarAsset asset)
	{
		assetLoadingIds.Remove(asset.assetID);
	}

	public void CombinedMeshLoadedCallback(IntPtr assetPtr)
	{
		if (waitingForCombinedMesh)
		{
			ulong[] array = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshIDs(assetPtr);
			foreach (ulong item in array)
			{
				assetLoadingIds.Remove(item);
			}
			Oculus.Avatar.CAPI.ovrAvatar_GetCombinedMeshAlphaData(sdkAvatar, ref clothingAlphaTexture, ref clothingAlphaOffset);
			waitingForCombinedMesh = false;
		}
	}

	private OvrAvatarSkinnedMeshRenderComponent AddSkinnedMeshRenderComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender)
	{
		OvrAvatarSkinnedMeshRenderComponent ovrAvatarSkinnedMeshRenderComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderComponent>();
		ovrAvatarSkinnedMeshRenderComponent.Initialize(skinnedMeshRender, Monochrome_SurfaceShader, Monochrome_SurfaceShader_SelfOccluding, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderComponent;
	}

	private OvrAvatarSkinnedMeshRenderPBSComponent AddSkinnedMeshRenderPBSComponent(GameObject gameObject, ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS)
	{
		OvrAvatarSkinnedMeshRenderPBSComponent ovrAvatarSkinnedMeshRenderPBSComponent = gameObject.AddComponent<OvrAvatarSkinnedMeshRenderPBSComponent>();
		ovrAvatarSkinnedMeshRenderPBSComponent.Initialize(skinnedMeshRenderPBS, Monochrome_SurfaceShader_PBS, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex);
		return ovrAvatarSkinnedMeshRenderPBSComponent;
	}

	private OvrAvatarSkinnedMeshPBSV2RenderComponent AddSkinnedMeshRenderPBSV2Component(IntPtr renderPart, GameObject go, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRenderPBSV2, bool isBodyPartZero, bool isControllerModel)
	{
		OvrAvatarSkinnedMeshPBSV2RenderComponent ovrAvatarSkinnedMeshPBSV2RenderComponent = go.AddComponent<OvrAvatarSkinnedMeshPBSV2RenderComponent>();
		ovrAvatarSkinnedMeshPBSV2RenderComponent.Initialize(renderPart, skinnedMeshRenderPBSV2, materialManager, ThirdPersonLayer.layerIndex, FirstPersonLayer.layerIndex, isBodyPartZero && CombineMeshes, LevelOfDetail, isBodyPartZero && EnableExpressive, this, isControllerModel);
		return ovrAvatarSkinnedMeshPBSV2RenderComponent;
	}

	public static IntPtr GetRenderPart(ovrAvatarComponent component, uint renderPartIndex)
	{
		return Marshal.ReadIntPtr(component.renderParts, Marshal.SizeOf(typeof(IntPtr)) * (int)renderPartIndex);
	}

	private static string GetRenderPartName(ovrAvatarComponent component, uint renderPartIndex)
	{
		return component.name + "_renderPart_" + (int)renderPartIndex;
	}

	internal static void ConvertTransform(float[] transform, ref ovrAvatarTransform target)
	{
		target.position.x = transform[0];
		target.position.y = transform[1];
		target.position.z = transform[2];
		target.orientation.x = transform[3];
		target.orientation.y = transform[4];
		target.orientation.z = transform[5];
		target.orientation.w = transform[6];
		target.scale.x = transform[7];
		target.scale.y = transform[8];
		target.scale.z = transform[9];
	}

	internal static void ConvertTransform(ovrAvatarTransform transform, Transform target)
	{
		Vector3 position = transform.position;
		position.z = 0f - position.z;
		Quaternion orientation = transform.orientation;
		orientation.x = 0f - orientation.x;
		orientation.y = 0f - orientation.y;
		target.localPosition = position;
		target.localRotation = orientation;
		target.localScale = transform.scale;
	}

	public static ovrAvatarTransform CreateOvrAvatarTransform(Vector3 position, Quaternion orientation)
	{
		ovrAvatarTransform result = default(ovrAvatarTransform);
		result.position = new Vector3(position.x, position.y, 0f - position.z);
		result.orientation = new Quaternion(0f - orientation.x, 0f - orientation.y, orientation.z, orientation.w);
		result.scale = Vector3.one;
		return result;
	}

	private static ovrAvatarGazeTarget CreateOvrGazeTarget(uint targetId, Vector3 targetPosition, ovrAvatarGazeTargetType targetType)
	{
		ovrAvatarGazeTarget result = default(ovrAvatarGazeTarget);
		result.id = targetId;
		result.worldPosition = new Vector3(targetPosition.x, targetPosition.y, 0f - targetPosition.z);
		result.type = targetType;
		return result;
	}

	private void BuildRenderComponents()
	{
		ovrAvatarBaseComponent component = default(ovrAvatarBaseComponent);
		ovrAvatarHandComponent component2 = default(ovrAvatarHandComponent);
		ovrAvatarHandComponent component3 = default(ovrAvatarHandComponent);
		ovrAvatarControllerComponent component4 = default(ovrAvatarControllerComponent);
		ovrAvatarControllerComponent component5 = default(ovrAvatarControllerComponent);
		ovrAvatarBodyComponent component6 = default(ovrAvatarBodyComponent);
		ovrAvatarComponent component7 = default(ovrAvatarComponent);
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(sdkAvatar, ref component2))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component2.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandLeft, component7);
			HandLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(sdkAvatar, ref component3))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component3.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref HandRight, component7);
			HandRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref component6))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component6.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Body, component7);
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(sdkAvatar, ref component4))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component4.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerLeft, component7);
			ControllerLeft.isLeftHand = true;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(sdkAvatar, ref component5))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component5.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref ControllerRight, component7);
			ControllerRight.isLeftHand = false;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref component7);
			AddAvatarComponent(ref Base, component7);
		}
	}

	private void AddAvatarComponent<T>(ref T root, ovrAvatarComponent nativeComponent) where T : OvrAvatarComponent
	{
		GameObject gameObject = new GameObject();
		gameObject.name = nativeComponent.name;
		gameObject.transform.SetParent(base.transform);
		root = gameObject.AddComponent<T>();
		root.SetOvrAvatarOwner(this);
		AddRenderParts(root, nativeComponent, gameObject.transform);
	}

	private void UpdateCustomPoses()
	{
		if (UpdatePoseRoot(LeftHandCustomPose, ref cachedLeftHandCustomPose, ref cachedCustomLeftHandJoints, ref cachedLeftHandTransforms) && cachedLeftHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (UpdatePoseRoot(RightHandCustomPose, ref cachedRightHandCustomPose, ref cachedCustomRightHandJoints, ref cachedRightHandTransforms) && cachedRightHandCustomPose == null && sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightHandGesture(sdkAvatar, ovrAvatarHandGesture.Default);
		}
		if (sdkAvatar != IntPtr.Zero)
		{
			if (cachedLeftHandCustomPose != null && UpdateTransforms(cachedCustomLeftHandJoints, cachedLeftHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetLeftHandCustomGesture(sdkAvatar, (uint)cachedLeftHandTransforms.Length, cachedLeftHandTransforms);
			}
			if (cachedRightHandCustomPose != null && UpdateTransforms(cachedCustomRightHandJoints, cachedRightHandTransforms))
			{
				Oculus.Avatar.CAPI.ovrAvatar_SetRightHandCustomGesture(sdkAvatar, (uint)cachedRightHandTransforms.Length, cachedRightHandTransforms);
			}
		}
	}

	private static bool UpdatePoseRoot(Transform poseRoot, ref Transform cachedPoseRoot, ref Transform[] cachedPoseJoints, ref ovrAvatarTransform[] transforms)
	{
		if (poseRoot == cachedPoseRoot)
		{
			return false;
		}
		if (!poseRoot)
		{
			cachedPoseRoot = null;
			cachedPoseJoints = null;
			transforms = null;
		}
		else
		{
			List<Transform> list = new List<Transform>();
			OrderJoints(poseRoot, list);
			cachedPoseRoot = poseRoot;
			cachedPoseJoints = list.ToArray();
			transforms = new ovrAvatarTransform[list.Count];
		}
		return true;
	}

	private static bool UpdateTransforms(Transform[] joints, ovrAvatarTransform[] transforms)
	{
		bool result = false;
		for (int i = 0; i < joints.Length; i++)
		{
			Transform transform = joints[i];
			ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(transform.localPosition, transform.localRotation);
			if (ovrAvatarTransform2.position != transforms[i].position || ovrAvatarTransform2.orientation != transforms[i].orientation)
			{
				transforms[i] = ovrAvatarTransform2;
				result = true;
			}
		}
		return result;
	}

	private static void OrderJoints(Transform transform, List<Transform> joints)
	{
		joints.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			OrderJoints(transform.GetChild(i), joints);
		}
	}

	private void AvatarSpecificationCallback(IntPtr avatarSpecification)
	{
		sdkAvatar = Oculus.Avatar.CAPI.ovrAvatar_Create(avatarSpecification, Capabilities);
		ShowLeftController(showLeftController);
		ShowRightController(showRightController);
		if (Driver != null)
		{
			Driver.UpdateTransformsFromPose(sdkAvatar);
		}
		uint num = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAssetCount(sdkAvatar);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			ulong num3 = Oculus.Avatar.CAPI.ovrAvatar_GetReferencedAsset(sdkAvatar, num2);
			if (OvrAvatarSDKManager.Instance.GetAsset(num3) == null)
			{
				OvrAvatarSDKManager.Instance.BeginLoadingAsset(num3, LevelOfDetail, AssetLoadedCallback);
				assetLoadingIds.Add(num3);
			}
		}
		if (CombineMeshes)
		{
			OvrAvatarSDKManager.Instance.RegisterCombinedMeshCallback(sdkAvatar, CombinedMeshLoadedCallback);
		}
	}

	private void Start()
	{
		if (!(OvrAvatarSDKManager.Instance == null))
		{
			materialManager = base.gameObject.AddComponent<OvrAvatarMaterialManager>();
			try
			{
				oculusUserIDInternal = ulong.Parse(oculusUserID);
			}
			catch (Exception)
			{
				oculusUserIDInternal = 0uL;
			}
			if (oculusUserIDInternal == 0L)
			{
				CombineMeshes = false;
			}
			Capabilities = (ovrAvatarCapabilities)0;
			if (EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Body;
			}
			if (EnableHands)
			{
				Capabilities |= ovrAvatarCapabilities.Hands;
			}
			if (EnableBase && EnableBody)
			{
				Capabilities |= ovrAvatarCapabilities.Base;
			}
			if (EnableExpressive)
			{
				Capabilities |= ovrAvatarCapabilities.Expressive;
			}
			if (OVRPlugin.positionSupported)
			{
				Capabilities |= ovrAvatarCapabilities.BodyTilt;
			}
			ShowLeftController(StartWithControllers);
			ShowRightController(StartWithControllers);
			OvrAvatarSDKManager.AvatarSpecRequestParams avatarSpecRequest = new OvrAvatarSDKManager.AvatarSpecRequestParams(oculusUserIDInternal, AvatarSpecificationCallback, CombineMeshes, LevelOfDetail, forceMobileTextureFormat: true, LookAndFeelVersion, FallbackLookAndFeelVersion, EnableExpressive);
			OvrAvatarSDKManager.Instance.RequestAvatarSpecification(avatarSpecRequest);
			OvrAvatarSDKManager.Instance.AddLoadingAvatar(GetInstanceID());
			waitingForCombinedMesh = CombineMeshes;
			if (Driver != null)
			{
				Driver.Mode = ((!UseSDKPackets) ? OvrAvatarDriver.PacketMode.Unity : OvrAvatarDriver.PacketMode.SDK);
			}
		}
	}

	private void Update()
	{
		if (!OvrAvatarSDKManager.Instance || sdkAvatar == IntPtr.Zero || materialManager == null)
		{
			return;
		}
		if (Driver != null)
		{
			Driver.UpdateTransforms(sdkAvatar);
			foreach (float[] voiceUpdate in voiceUpdates)
			{
				Oculus.Avatar.CAPI.ovrAvatarPose_UpdateVoiceVisualization(sdkAvatar, voiceUpdate);
			}
			voiceUpdates.Clear();
			Oculus.Avatar.CAPI.ovrAvatarPose_Finalize(sdkAvatar, Time.deltaTime);
		}
		if (RecordPackets)
		{
			RecordFrame();
		}
		if (assetLoadingIds.Count != 0)
		{
			return;
		}
		if (!assetsFinishedLoading)
		{
			try
			{
				BuildRenderComponents();
			}
			catch (Exception ex)
			{
				assetsFinishedLoading = true;
				throw ex;
			}
			InitPostLoad();
			assetsFinishedLoading = true;
			OvrAvatarSDKManager.Instance.RemoveLoadingAvatar(GetInstanceID());
		}
		UpdateVoiceBehavior();
		UpdateCustomPoses();
		if (EnableExpressive)
		{
			UpdateExpressive();
		}
	}

	public static ovrAvatarHandInputState CreateInputState(ovrAvatarTransform transform, OvrAvatarDriver.ControllerPose pose)
	{
		ovrAvatarHandInputState result = default(ovrAvatarHandInputState);
		result.transform = transform;
		result.buttonMask = pose.buttons;
		result.touchMask = pose.touches;
		result.joystickX = pose.joystickPosition.x;
		result.joystickY = pose.joystickPosition.y;
		result.indexTrigger = pose.indexTrigger;
		result.handTrigger = pose.handTrigger;
		result.isActive = pose.isActive;
		return result;
	}

	public void ShowControllers(bool show)
	{
		ShowLeftController(show);
		ShowRightController(show);
	}

	public void ShowLeftController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetLeftControllerVisibility(sdkAvatar, show);
		}
		showLeftController = show;
	}

	public void ShowRightController(bool show)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			Oculus.Avatar.CAPI.ovrAvatar_SetRightControllerVisibility(sdkAvatar, show);
		}
		showRightController = show;
	}

	public void UpdateVoiceVisualization(float[] voiceSamples)
	{
		voiceUpdates.Add(voiceSamples);
	}

	private void RecordFrame()
	{
		if (UseSDKPackets)
		{
			RecordSDKFrame();
		}
		else
		{
			RecordUnityFrame();
		}
	}

	private void RecordUnityFrame()
	{
		float num = Time.deltaTime;
		OvrAvatarDriver.PoseFrame currentPose = Driver.GetCurrentPose();
		if (CurrentUnityPacket == null)
		{
			CurrentUnityPacket = new OvrAvatarPacket(currentPose);
			num = 0f;
		}
		float num2 = 0f;
		while (num2 < num)
		{
			float num3 = num - num2;
			float num4 = PacketSettings.UpdateRate - CurrentUnityPacket.Duration;
			if (num3 < num4)
			{
				CurrentUnityPacket.AddFrame(currentPose, num3);
				num2 += num3;
				continue;
			}
			OvrAvatarDriver.PoseFrame finalFrame = CurrentUnityPacket.FinalFrame;
			OvrAvatarDriver.PoseFrame b = currentPose;
			float t = num4 / num3;
			OvrAvatarDriver.PoseFrame poseFrame = OvrAvatarDriver.PoseFrame.Interpolate(finalFrame, b, t);
			CurrentUnityPacket.AddFrame(poseFrame, num4);
			num2 += num4;
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(CurrentUnityPacket));
			}
			CurrentUnityPacket = new OvrAvatarPacket(poseFrame);
		}
	}

	private void RecordSDKFrame()
	{
		if (sdkAvatar == IntPtr.Zero)
		{
			return;
		}
		if (!PacketSettings.RecordingFrames)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			PacketSettings.AccumulatedTime = 0f;
			PacketSettings.RecordingFrames = true;
		}
		PacketSettings.AccumulatedTime += Time.deltaTime;
		if (PacketSettings.AccumulatedTime >= PacketSettings.UpdateRate)
		{
			PacketSettings.AccumulatedTime = 0f;
			IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarPacket_EndRecording(sdkAvatar);
			Oculus.Avatar.CAPI.ovrAvatarPacket_BeginRecording(sdkAvatar);
			if (PacketRecorded != null)
			{
				PacketRecorded(this, new PacketEventArgs(new OvrAvatarPacket
				{
					ovrNativePacket = intPtr
				}));
			}
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(intPtr);
		}
	}

	private void AddRenderParts(OvrAvatarComponent ovrComponent, ovrAvatarComponent component, Transform parent)
	{
		bool flag = ovrComponent.name == "body";
		bool flag2 = ovrComponent.name == "controller_left";
		bool flag3 = ovrComponent.name == "controller_right";
		for (uint num = 0u; num < component.renderPartCount; num++)
		{
			GameObject gameObject = new GameObject();
			gameObject.name = GetRenderPartName(component, num);
			gameObject.transform.SetParent(parent);
			IntPtr renderPart = GetRenderPart(component, num);
			ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
			OvrAvatarRenderComponent ovrAvatarRenderComponent = null;
			switch (ovrAvatarRenderPartType2)
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRender(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSComponent(gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(renderPart));
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				ovrAvatarRenderComponent = AddSkinnedMeshRenderPBSV2Component(renderPart, gameObject, Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(renderPart), flag && num == 0, flag2 || flag3);
				break;
			}
			if (ovrAvatarRenderComponent != null)
			{
				ovrComponent.RenderParts.Add(ovrAvatarRenderComponent);
			}
		}
	}

	public void RefreshBodyParts()
	{
		if (!(Body != null))
		{
			return;
		}
		foreach (OvrAvatarRenderComponent renderPart in Body.RenderParts)
		{
			UnityEngine.Object.Destroy(renderPart.gameObject);
		}
		Body.RenderParts.Clear();
		ovrAvatarComponent? nativeAvatarComponent = Body.GetNativeAvatarComponent();
		if (nativeAvatarComponent.HasValue)
		{
			AddRenderParts(Body, nativeAvatarComponent.Value, Body.gameObject.transform);
		}
	}

	public ovrAvatarBodyComponent? GetBodyComponent()
	{
		if (Body != null)
		{
			Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(sdkAvatar, ref Body.component);
			return Body.component;
		}
		return null;
	}

	public Transform GetHandTransform(HandType hand, HandJoint joint)
	{
		if (hand >= HandType.Max || joint >= HandJoint.Max)
		{
			return null;
		}
		OvrAvatarHand ovrAvatarHand = ((hand == HandType.Left) ? HandLeft : HandRight);
		if (ovrAvatarHand != null)
		{
			OvrAvatarComponent component = ovrAvatarHand.GetComponent<OvrAvatarComponent>();
			if (component != null && component.RenderParts.Count > 0)
			{
				return component.RenderParts[0].transform.Find(HandJoints[(int)hand, (int)joint]);
			}
		}
		return null;
	}

	public void GetPointingDirection(HandType hand, ref Vector3 forward, ref Vector3 up)
	{
		Transform handTransform = GetHandTransform(hand, HandJoint.HandBase);
		if (handTransform != null)
		{
			forward = handTransform.forward;
			up = handTransform.up;
		}
	}

	private void UpdateVoiceBehavior()
	{
		if (EnableMouthVertexAnimation && Body != null)
		{
			OvrAvatarComponent component = Body.GetComponent<OvrAvatarComponent>();
			VoiceAmplitude = Mathf.Clamp(VoiceAmplitude, 0f, 1f);
			if (component.RenderParts.Count > 0)
			{
				Material sharedMaterial = component.RenderParts[0].mesh.sharedMaterial;
				Transform transform = component.RenderParts[0].mesh.transform.Find(NECK_JONT);
				Vector3 vector = transform.TransformPoint(Vector3.up) - transform.position;
				sharedMaterial.SetFloat(MOUTH_SCALE_PROPERTY, vector.magnitude);
				sharedMaterial.SetFloat(VOICE_PROPERTY, Mathf.Min(vector.magnitude * MOUTH_MAX_GLOBAL, vector.magnitude * VoiceAmplitude * MOUTH_SCALE_GLOBAL));
				sharedMaterial.SetVector(MOUTH_POSITION_PROPERTY, transform.TransformPoint(MOUTH_POSITION_OFFSET));
				sharedMaterial.SetVector(MOUTH_DIRECTION_PROPERTY, transform.up);
			}
		}
	}

	private bool IsValidMic()
	{
		string[] devices = Microphone.devices;
		if (devices.Length < 1)
		{
			return false;
		}
		int num = 0;
		string deviceName = devices[num];
		Microphone.GetDeviceCaps(deviceName, out var _, out var maxFreq);
		if (maxFreq == 0)
		{
			maxFreq = 44100;
		}
		if (Microphone.Start(deviceName, loop: true, 1, maxFreq) == null)
		{
			return false;
		}
		Microphone.End(deviceName);
		return true;
	}

	private void InitPostLoad()
	{
		ExpressiveGlobalInit();
		ConfigureHelpers();
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			lipsyncContext.audioLoopback = false;
			if (CanOwnMicrophone && IsValidMic())
			{
				micInput = MouthAnchor.gameObject.AddComponent<OVRLipSyncMicInput>();
				micInput.enableMicSelectionGUI = false;
				micInput.MicFrequency = 44100f;
				micInput.micControl = OVRLipSyncMicInput.micActivation.ConstantSpeak;
			}
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitOnsetSpeed(sdkAvatar, 30f);
			Oculus.Avatar.CAPI.ovrAvatar_SetActionUnitFalloffSpeed(sdkAvatar, 20f);
			Oculus.Avatar.CAPI.ovrAvatar_SetVisemeMultiplier(sdkAvatar, 1.5f);
		}
	}

	private static void ExpressiveGlobalInit()
	{
		if (!doneExpressiveGlobalInit)
		{
			doneExpressiveGlobalInit = true;
			ovrLights.lights = new ovrAvatarLight[16];
			InitializeLights();
		}
	}

	private static void InitializeLights()
	{
		ovrLights.ambientIntensity = RenderSettings.ambientLight.grayscale * 0.5f;
		Light[] array = UnityEngine.Object.FindObjectsOfType(typeof(Light)) as Light[];
		int num = 0;
		for (num = 0; num < array.Length && num < ovrLights.lights.Length; num++)
		{
			Light light = array[num];
			if ((bool)light && light.enabled)
			{
				uint instanceID = (uint)light.transform.GetInstanceID();
				switch (light.type)
				{
				case LightType.Directional:
					CreateLightDirectional(instanceID, light.transform.forward, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Point:
					CreateLightPoint(instanceID, light.transform.position, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				case LightType.Spot:
					CreateLightSpot(instanceID, light.transform.position, light.transform.forward, light.spotAngle, light.range, light.intensity, ref ovrLights.lights[num]);
					break;
				}
			}
		}
		ovrLights.lightCount = (uint)num;
		Oculus.Avatar.CAPI.ovrAvatar_UpdateLights(ovrLights);
	}

	private static ovrAvatarLight CreateLightDirectional(uint id, Vector3 direction, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Direction;
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightPoint(uint id, Vector3 position, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Point;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private static ovrAvatarLight CreateLightSpot(uint id, Vector3 position, Vector3 direction, float spotAngleDeg, float range, float intensity, ref ovrAvatarLight light)
	{
		light.id = id;
		light.type = ovrAvatarLightType.Spot;
		light.worldPosition = new Vector3(position.x, position.y, 0f - position.z);
		light.worldDirection = new Vector3(direction.x, direction.y, 0f - direction.z);
		light.spotAngleDeg = spotAngleDeg;
		light.range = range;
		light.intensity = intensity;
		return light;
	}

	private void UpdateExpressive()
	{
		ovrAvatarTransform ovrAvatarTransform2 = CreateOvrAvatarTransform(base.transform.position, base.transform.rotation);
		Oculus.Avatar.CAPI.ovrAvatar_UpdateWorldTransform(sdkAvatar, ovrAvatarTransform2);
		UpdateFacewave();
	}

	private void ConfigureHelpers()
	{
		Transform transform = base.transform.Find("body/body_renderPart_0/root_JNT/body_JNT/chest_JNT/neckBase_JNT/neck_JNT/head_JNT");
		if (transform == null)
		{
			transform = base.transform;
		}
		if (MouthAnchor == null)
		{
			MouthAnchor = CreateHelperObject(transform, MOUTH_HEAD_OFFSET, "MouthAnchor");
		}
		if (GetComponent<OvrAvatarLocalDriver>() != null)
		{
			if (audioSource == null)
			{
				audioSource = MouthAnchor.gameObject.AddComponent<AudioSource>();
			}
			spatializedSource = MouthAnchor.GetComponent<ONSPAudioSource>();
			if (spatializedSource == null)
			{
				spatializedSource = MouthAnchor.gameObject.AddComponent<ONSPAudioSource>();
			}
			spatializedSource.UseInvSqr = true;
			spatializedSource.EnableRfl = false;
			spatializedSource.EnableSpatialization = true;
			spatializedSource.Far = 100f;
			spatializedSource.Near = 0.1f;
			lipsyncContext = MouthAnchor.GetComponent<OVRLipSyncContext>();
			if (lipsyncContext == null)
			{
				lipsyncContext = MouthAnchor.gameObject.AddComponent<OVRLipSyncContext>();
			}
			lipsyncContext.provider = ((!EnableLaughter) ? OVRLipSync.ContextProviders.Enhanced : OVRLipSync.ContextProviders.Enhanced_with_Laughter);
			lipsyncContext.skipAudioSource = !CanOwnMicrophone;
			StartCoroutine(WaitForMouthAudioSource());
		}
		if (GetComponent<OvrAvatarRemoteDriver>() != null)
		{
			transform.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHead;
			Transform transform2 = base.transform.Find("hand_left");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
			transform2 = base.transform.Find("hand_right");
			if (!(transform2 == null))
			{
				transform2.gameObject.AddComponent<GazeTarget>().Type = ovrAvatarGazeTargetType.AvatarHand;
			}
		}
	}

	private IEnumerator WaitForMouthAudioSource()
	{
		while (MouthAnchor.GetComponent<AudioSource>() == null)
		{
			yield return new WaitForSeconds(0.1f);
		}
		AudioSource component = MouthAnchor.GetComponent<AudioSource>();
		component.minDistance = 0.3f;
		component.maxDistance = 4f;
		component.rolloffMode = AudioRolloffMode.Logarithmic;
		component.loop = true;
		component.playOnAwake = true;
		component.spatialBlend = 1f;
		component.spatialize = true;
		component.spatializePostEffects = true;
	}

	public void DestroyHelperObjects()
	{
		if ((bool)MouthAnchor)
		{
			UnityEngine.Object.DestroyImmediate(MouthAnchor.gameObject);
		}
	}

	public GameObject CreateHelperObject(Transform parent, Vector3 localPositionOffset, string helperName, string helperTag = "")
	{
		GameObject gameObject = new GameObject();
		gameObject.name = helperName;
		if (helperTag != "")
		{
			gameObject.tag = helperTag;
		}
		gameObject.transform.SetParent(parent);
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localPosition = localPositionOffset;
		return gameObject;
	}

	public void UpdateVoiceData(short[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	public void UpdateVoiceData(float[] pcmData, int numChannels)
	{
		if (lipsyncContext != null && micInput == null)
		{
			lipsyncContext.ProcessAudioSamplesRaw(pcmData, numChannels);
		}
	}

	private void UpdateFacewave()
	{
		if (!(lipsyncContext != null) || (!(micInput != null) && CanOwnMicrophone))
		{
			return;
		}
		currentFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentFrame.Visemes.Length != 15)
		{
			UnityEngine.Debug.LogError("Unexpected number of visemes " + currentFrame.Visemes);
			return;
		}
		currentFrame.Visemes.CopyTo(visemes, 0);
		visemes[15] = (EnableLaughter ? currentFrame.laughterScore : 0f);
		for (int i = 0; i < 16; i++)
		{
			RuntimeVisemes.visemeParams[i] = visemes[i];
		}
		Oculus.Avatar.CAPI.ovrAvatar_SetVisemes(sdkAvatar, RuntimeVisemes);
	}
}
public class OvrAvatarAsset
{
	public ulong assetID;
}
public class OvrAvatarAssetMesh : OvrAvatarAsset
{
	public Mesh mesh;

	private ovrAvatarSkinnedMeshPose skinnedBindPose;

	public string[] jointNames;

	public OvrAvatarAssetMesh(ulong _assetId, IntPtr asset, ovrAvatarAssetType meshType)
	{
		assetID = _assetId;
		mesh = new Mesh();
		mesh.name = "Procedural Geometry for asset " + _assetId;
		SetSkinnedBindPose(asset, meshType);
		long vertexCount = 0L;
		IntPtr vertexBuffer = IntPtr.Zero;
		uint indexCount = 0u;
		IntPtr indexBuffer = IntPtr.Zero;
		GetVertexAndIndexData(asset, meshType, out vertexCount, out vertexBuffer, out indexCount, out indexBuffer);
		Vector3[] array = new Vector3[vertexCount];
		Vector3[] array2 = new Vector3[vertexCount];
		Vector4[] array3 = new Vector4[vertexCount];
		Vector2[] array4 = new Vector2[vertexCount];
		Color[] array5 = new Color[vertexCount];
		BoneWeight[] array6 = new BoneWeight[vertexCount];
		long num = vertexBuffer.ToInt64();
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
		{
			long num5 = Marshal.SizeOf(typeof(ovrAvatarMeshVertex));
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				long num7 = num5 * num6;
				ovrAvatarMeshVertex ovrAvatarMeshVertex2 = (ovrAvatarMeshVertex)Marshal.PtrToStructure(new IntPtr(num + num7), typeof(ovrAvatarMeshVertex));
				array[num6] = new Vector3(ovrAvatarMeshVertex2.x, ovrAvatarMeshVertex2.y, 0f - ovrAvatarMeshVertex2.z);
				array2[num6] = new Vector3(ovrAvatarMeshVertex2.nx, ovrAvatarMeshVertex2.ny, 0f - ovrAvatarMeshVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarMeshVertex2.tx, ovrAvatarMeshVertex2.ty, 0f - ovrAvatarMeshVertex2.tz, ovrAvatarMeshVertex2.tw);
				array4[num6] = new Vector2(ovrAvatarMeshVertex2.u, ovrAvatarMeshVertex2.v);
				array5[num6] = new Color(0f, 0f, 0f, 1f);
				array6[num6].boneIndex0 = ovrAvatarMeshVertex2.blendIndices[0];
				array6[num6].boneIndex1 = ovrAvatarMeshVertex2.blendIndices[1];
				array6[num6].boneIndex2 = ovrAvatarMeshVertex2.blendIndices[2];
				array6[num6].boneIndex3 = ovrAvatarMeshVertex2.blendIndices[3];
				array6[num6].weight0 = ovrAvatarMeshVertex2.blendWeights[0];
				array6[num6].weight1 = ovrAvatarMeshVertex2.blendWeights[1];
				array6[num6].weight2 = ovrAvatarMeshVertex2.blendWeights[2];
				array6[num6].weight3 = ovrAvatarMeshVertex2.blendWeights[3];
			}
			break;
		}
		case ovrAvatarAssetType.CombinedMesh:
		{
			long num2 = Marshal.SizeOf(typeof(ovrAvatarMeshVertexV2));
			for (long num3 = 0L; num3 < vertexCount; num3++)
			{
				long num4 = num2 * num3;
				ovrAvatarMeshVertexV2 ovrAvatarMeshVertexV3 = (ovrAvatarMeshVertexV2)Marshal.PtrToStructure(new IntPtr(num + num4), typeof(ovrAvatarMeshVertexV2));
				array[num3] = new Vector3(ovrAvatarMeshVertexV3.x, ovrAvatarMeshVertexV3.y, 0f - ovrAvatarMeshVertexV3.z);
				array2[num3] = new Vector3(ovrAvatarMeshVertexV3.nx, ovrAvatarMeshVertexV3.ny, 0f - ovrAvatarMeshVertexV3.nz);
				array3[num3] = new Vector4(ovrAvatarMeshVertexV3.tx, ovrAvatarMeshVertexV3.ty, 0f - ovrAvatarMeshVertexV3.tz, ovrAvatarMeshVertexV3.tw);
				array4[num3] = new Vector2(ovrAvatarMeshVertexV3.u, ovrAvatarMeshVertexV3.v);
				array5[num3] = new Color(ovrAvatarMeshVertexV3.r, ovrAvatarMeshVertexV3.g, ovrAvatarMeshVertexV3.b, ovrAvatarMeshVertexV3.a);
				array6[num3].boneIndex0 = ovrAvatarMeshVertexV3.blendIndices[0];
				array6[num3].boneIndex1 = ovrAvatarMeshVertexV3.blendIndices[1];
				array6[num3].boneIndex2 = ovrAvatarMeshVertexV3.blendIndices[2];
				array6[num3].boneIndex3 = ovrAvatarMeshVertexV3.blendIndices[3];
				array6[num3].weight0 = ovrAvatarMeshVertexV3.blendWeights[0];
				array6[num3].weight1 = ovrAvatarMeshVertexV3.blendWeights[1];
				array6[num3].weight2 = ovrAvatarMeshVertexV3.blendWeights[2];
				array6[num3].weight3 = ovrAvatarMeshVertexV3.blendWeights[3];
			}
			break;
		}
		default:
			throw new Exception("Bad Mesh Asset Type");
		}
		mesh.vertices = array;
		mesh.normals = array2;
		mesh.uv = array4;
		mesh.tangents = array3;
		mesh.boneWeights = array6;
		mesh.colors = array5;
		LoadBlendShapes(asset, vertexCount);
		LoadSubmeshes(asset, indexBuffer, indexCount);
		uint jointCount = skinnedBindPose.jointCount;
		jointNames = new string[jointCount];
		for (uint num8 = 0u; num8 < jointCount; num8++)
		{
			jointNames[num8] = Marshal.PtrToStringAnsi(skinnedBindPose.jointNames[num8]);
		}
	}

	private void LoadSubmeshes(IntPtr asset, IntPtr indexBufferPtr, ulong indexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshCount(asset);
		short[] array = new short[indexCount];
		Marshal.Copy(indexBufferPtr, array, 0, (int)indexCount);
		mesh.subMeshCount = (int)num;
		uint num2 = 0u;
		for (uint num3 = 0u; num3 < num; num3++)
		{
			uint num4 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetSubmeshLastIndex(asset, num3);
			uint num5 = num4 - num2;
			int[] array2 = new int[num5];
			int num6 = 0;
			for (ulong num7 = num2; num7 < num4; num7 += 3)
			{
				array2[num6 + 2] = array[num7];
				array2[num6 + 1] = array[num7 + 1];
				array2[num6] = array[num7 + 2];
				num6 += 3;
			}
			num2 += num5;
			mesh.SetIndices(array2, MeshTopology.Triangles, (int)num3);
		}
	}

	private void LoadBlendShapes(IntPtr asset, long vertexCount)
	{
		uint num = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeCount(asset);
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeVertices(asset);
		if (!(intPtr != IntPtr.Zero))
		{
			return;
		}
		long num2 = 0L;
		long num3 = Marshal.SizeOf(typeof(ovrAvatarBlendVertex));
		long num4 = intPtr.ToInt64();
		for (uint num5 = 0u; num5 < num; num5++)
		{
			Vector3[] array = new Vector3[vertexCount];
			Vector3[] array2 = new Vector3[vertexCount];
			Vector3[] array3 = new Vector3[vertexCount];
			for (long num6 = 0L; num6 < vertexCount; num6++)
			{
				ovrAvatarBlendVertex ovrAvatarBlendVertex2 = (ovrAvatarBlendVertex)Marshal.PtrToStructure(new IntPtr(num4 + num2), typeof(ovrAvatarBlendVertex));
				array[num6] = new Vector3(ovrAvatarBlendVertex2.x, ovrAvatarBlendVertex2.y, 0f - ovrAvatarBlendVertex2.z);
				array2[num6] = new Vector3(ovrAvatarBlendVertex2.nx, ovrAvatarBlendVertex2.ny, 0f - ovrAvatarBlendVertex2.nz);
				array3[num6] = new Vector4(ovrAvatarBlendVertex2.tx, ovrAvatarBlendVertex2.ty, 0f - ovrAvatarBlendVertex2.tz);
				num2 += num3;
			}
			string shapeName = Marshal.PtrToStringAnsi(Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshBlendShapeName(asset, num5));
			mesh.AddBlendShapeFrame(shapeName, 100f, array, array2, array3);
		}
	}

	private void SetSkinnedBindPose(IntPtr asset, ovrAvatarAssetType meshType)
	{
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).skinnedBindPose;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			skinnedBindPose = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).skinnedBindPose;
			break;
		}
	}

	private void GetVertexAndIndexData(IntPtr asset, ovrAvatarAssetType meshType, out long vertexCount, out IntPtr vertexBuffer, out uint indexCount, out IntPtr indexBuffer)
	{
		vertexCount = 0L;
		vertexBuffer = IntPtr.Zero;
		indexCount = 0u;
		indexBuffer = IntPtr.Zero;
		switch (meshType)
		{
		case ovrAvatarAssetType.Mesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMeshData(asset).indexBuffer;
			break;
		case ovrAvatarAssetType.CombinedMesh:
			vertexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexCount;
			vertexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).vertexBuffer;
			indexCount = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexCount;
			indexBuffer = Oculus.Avatar.CAPI.ovrAvatarAsset_GetCombinedMeshData(asset).indexBuffer;
			break;
		}
	}

	public SkinnedMeshRenderer CreateSkinnedMeshRendererOnObject(GameObject target)
	{
		SkinnedMeshRenderer skinnedMeshRenderer = target.AddComponent<SkinnedMeshRenderer>();
		skinnedMeshRenderer.sharedMesh = mesh;
		mesh.name = "AvatarMesh_" + assetID;
		uint jointCount = skinnedBindPose.jointCount;
		GameObject[] array = new GameObject[jointCount];
		Transform[] array2 = new Transform[jointCount];
		Matrix4x4[] array3 = new Matrix4x4[jointCount];
		for (uint num = 0u; num < jointCount; num++)
		{
			array[num] = new GameObject();
			array2[num] = array[num].transform;
			array[num].name = jointNames[num];
			int num2 = skinnedBindPose.jointParents[num];
			if (num2 == -1)
			{
				array[num].transform.parent = skinnedMeshRenderer.transform;
				skinnedMeshRenderer.rootBone = array[num].transform;
			}
			else
			{
				array[num].transform.parent = array[num2].transform;
			}
			Vector3 position = skinnedBindPose.jointTransform[num].position;
			position.z = 0f - position.z;
			array[num].transform.localPosition = position;
			Quaternion orientation = skinnedBindPose.jointTransform[num].orientation;
			orientation.x = 0f - orientation.x;
			orientation.y = 0f - orientation.y;
			array[num].transform.localRotation = orientation;
			array[num].transform.localScale = skinnedBindPose.jointTransform[num].scale;
			array3[num] = array[num].transform.worldToLocalMatrix * skinnedMeshRenderer.transform.localToWorldMatrix;
		}
		skinnedMeshRenderer.bones = array2;
		mesh.bindposes = array3;
		return skinnedMeshRenderer;
	}
}
public class OvrAvatarAssetTexture : OvrAvatarAsset
{
	public Texture2D texture;

	private const int ASTCHeaderSize = 16;

	public OvrAvatarAssetTexture(ulong _assetId, IntPtr asset)
	{
		assetID = _assetId;
		ovrAvatarTextureAssetData ovrAvatarTextureAssetData2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetTextureData(asset);
		IntPtr data = ovrAvatarTextureAssetData2.textureData;
		int num = (int)ovrAvatarTextureAssetData2.textureDataSize;
		TextureFormat textureFormat;
		switch (ovrAvatarTextureAssetData2.format)
		{
		case ovrAvatarTextureFormat.RGB24:
			textureFormat = TextureFormat.RGB24;
			break;
		case ovrAvatarTextureFormat.DXT1:
			textureFormat = TextureFormat.DXT1;
			break;
		case ovrAvatarTextureFormat.DXT5:
			textureFormat = TextureFormat.DXT5;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6:
			textureFormat = TextureFormat.ASTC_6x6;
			data = new IntPtr(data.ToInt64() + 16);
			num -= 16;
			break;
		case ovrAvatarTextureFormat.ASTC_RGB_6x6_MIPMAPS:
			textureFormat = TextureFormat.ASTC_6x6;
			break;
		default:
			throw new NotImplementedException($"Unsupported texture format {ovrAvatarTextureAssetData2.format.ToString()}");
		}
		texture = new Texture2D((int)ovrAvatarTextureAssetData2.sizeX, (int)ovrAvatarTextureAssetData2.sizeY, textureFormat, ovrAvatarTextureAssetData2.mipCount > 1, (QualitySettings.activeColorSpace != 0) ? true : false)
		{
			filterMode = FilterMode.Trilinear,
			anisoLevel = 4
		};
		texture.LoadRawTextureData(data, num);
		texture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
	}
}
public class OvrAvatarBase : OvrAvatarComponent
{
	private ovrAvatarBaseComponent component;

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBaseComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Base = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarBody : OvrAvatarComponent
{
	public ovrAvatarBodyComponent component;

	public ovrAvatarComponent? GetNativeAvatarComponent()
	{
		if (owner == null)
		{
			return null;
		}
		if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
		{
			Oculus.Avatar.CAPI.ovrAvatarComponent_Get(component.renderComponent, includeName: true, ref nativeAvatarComponent);
			return nativeAvatarComponent;
		}
		return null;
	}

	private void Update()
	{
		if (!(owner == null))
		{
			if (Oculus.Avatar.CAPI.ovrAvatarPose_GetBodyComponent(owner.sdkAvatar, ref component))
			{
				UpdateAvatar(component.renderComponent);
				return;
			}
			owner.Body = null;
			UnityEngine.Object.Destroy(this);
		}
	}
}
public class OvrAvatarComponent : MonoBehaviour
{
	public static readonly string[] LayerKeywords = new string[9] { "LAYERS_0", "LAYERS_1", "LAYERS_2", "LAYERS_3", "LAYERS_4", "LAYERS_5", "LAYERS_6", "LAYERS_7", "LAYERS_8" };

	public static readonly string[] LayerSampleModeParameters = new string[8] { "_LayerSampleMode0", "_LayerSampleMode1", "_LayerSampleMode2", "_LayerSampleMode3", "_LayerSampleMode4", "_LayerSampleMode5", "_LayerSampleMode6", "_LayerSampleMode7" };

	public static readonly string[] LayerBlendModeParameters = new string[8] { "_LayerBlendMode0", "_LayerBlendMode1", "_LayerBlendMode2", "_LayerBlendMode3", "_LayerBlendMode4", "_LayerBlendMode5", "_LayerBlendMode6", "_LayerBlendMode7" };

	public static readonly string[] LayerMaskTypeParameters = new string[8] { "_LayerMaskType0", "_LayerMaskType1", "_LayerMaskType2", "_LayerMaskType3", "_LayerMaskType4", "_LayerMaskType5", "_LayerMaskType6", "_LayerMaskType7" };

	public static readonly string[] LayerColorParameters = new string[8] { "_LayerColor0", "_LayerColor1", "_LayerColor2", "_LayerColor3", "_LayerColor4", "_LayerColor5", "_LayerColor6", "_LayerColor7" };

	public static readonly string[] LayerSurfaceParameters = new string[8] { "_LayerSurface0", "_LayerSurface1", "_LayerSurface2", "_LayerSurface3", "_LayerSurface4", "_LayerSurface5", "_LayerSurface6", "_LayerSurface7" };

	public static readonly string[] LayerSampleParametersParameters = new string[8] { "_LayerSampleParameters0", "_LayerSampleParameters1", "_LayerSampleParameters2", "_LayerSampleParameters3", "_LayerSampleParameters4", "_LayerSampleParameters5", "_LayerSampleParameters6", "_LayerSampleParameters7" };

	public static readonly string[] LayerMaskParametersParameters = new string[8] { "_LayerMaskParameters0", "_LayerMaskParameters1", "_LayerMaskParameters2", "_LayerMaskParameters3", "_LayerMaskParameters4", "_LayerMaskParameters5", "_LayerMaskParameters6", "_LayerMaskParameters7" };

	public static readonly string[] LayerMaskAxisParameters = new string[8] { "_LayerMaskAxis0", "_LayerMaskAxis1", "_LayerMaskAxis2", "_LayerMaskAxis3", "_LayerMaskAxis4", "_LayerMaskAxis5", "_LayerMaskAxis6", "_LayerMaskAxis7" };

	private Dictionary<Material, ovrAvatarMaterialState> materialStates = new Dictionary<Material, ovrAvatarMaterialState>();

	public List<OvrAvatarRenderComponent> RenderParts = new List<OvrAvatarRenderComponent>();

	protected OvrAvatar owner;

	protected ovrAvatarComponent nativeAvatarComponent;

	public void SetOvrAvatarOwner(OvrAvatar ovrAvatarOwner)
	{
		owner = ovrAvatarOwner;
	}

	public void UpdateAvatar(IntPtr nativeComponent)
	{
		Oculus.Avatar.CAPI.ovrAvatarComponent_Get(nativeComponent, includeName: false, ref nativeAvatarComponent);
		OvrAvatar.ConvertTransform(nativeAvatarComponent.transform, base.transform);
		for (uint num = 0u; num < nativeAvatarComponent.renderPartCount && RenderParts.Count > num; num++)
		{
			OvrAvatarRenderComponent ovrAvatarRenderComponent = RenderParts[(int)num];
			IntPtr renderPart = OvrAvatar.GetRenderPart(nativeAvatarComponent, num);
			switch (Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart))
			{
			case ovrAvatarRenderPartType.SkinnedMeshRender:
				((OvrAvatarSkinnedMeshRenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS:
				((OvrAvatarSkinnedMeshRenderPBSComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRenderPBS(owner, renderPart, ovrAvatarRenderComponent.mesh.sharedMaterial);
				break;
			case ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2:
				((OvrAvatarSkinnedMeshPBSV2RenderComponent)ovrAvatarRenderComponent).UpdateSkinnedMeshRender(this, owner, renderPart);
				break;
			}
		}
	}

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		bool flag = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
		flag |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
		base.gameObject.SetActive(flag);
	}

	public void UpdateAvatarMaterial(Material mat, ovrAvatarMaterialState matState)
	{
		mat.SetColor("_BaseColor", matState.baseColor);
		mat.SetInt("_BaseMaskType", (int)matState.baseMaskType);
		mat.SetVector("_BaseMaskParameters", matState.baseMaskParameters);
		mat.SetVector("_BaseMaskAxis", matState.baseMaskAxis);
		if (matState.alphaMaskTextureID != 0L)
		{
			mat.SetTexture("_AlphaMask", GetLoadedTexture(matState.alphaMaskTextureID));
			mat.SetTextureScale("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.x, matState.alphaMaskScaleOffset.y));
			mat.SetTextureOffset("_AlphaMask", new Vector2(matState.alphaMaskScaleOffset.z, matState.alphaMaskScaleOffset.w));
		}
		if (matState.normalMapTextureID != 0L)
		{
			mat.EnableKeyword("NORMAL_MAP_ON");
			mat.SetTexture("_NormalMap", GetLoadedTexture(matState.normalMapTextureID));
			mat.SetTextureScale("_NormalMap", new Vector2(matState.normalMapScaleOffset.x, matState.normalMapScaleOffset.y));
			mat.SetTextureOffset("_NormalMap", new Vector2(matState.normalMapScaleOffset.z, matState.normalMapScaleOffset.w));
		}
		if (matState.parallaxMapTextureID != 0L)
		{
			mat.SetTexture("_ParallaxMap", GetLoadedTexture(matState.parallaxMapTextureID));
			mat.SetTextureScale("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.x, matState.parallaxMapScaleOffset.y));
			mat.SetTextureOffset("_ParallaxMap", new Vector2(matState.parallaxMapScaleOffset.z, matState.parallaxMapScaleOffset.w));
		}
		if (matState.roughnessMapTextureID != 0L)
		{
			mat.EnableKeyword("ROUGHNESS_ON");
			mat.SetTexture("_RoughnessMap", GetLoadedTexture(matState.roughnessMapTextureID));
			mat.SetTextureScale("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.x, matState.roughnessMapScaleOffset.y));
			mat.SetTextureOffset("_RoughnessMap", new Vector2(matState.roughnessMapScaleOffset.z, matState.roughnessMapScaleOffset.w));
		}
		mat.EnableKeyword(LayerKeywords[matState.layerCount]);
		for (ulong num = 0uL; num < matState.layerCount; num++)
		{
			ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2 = matState.layers[num];
			mat.SetInt(LayerSampleModeParameters[num], (int)ovrAvatarMaterialLayerState2.sampleMode);
			mat.SetInt(LayerBlendModeParameters[num], (int)ovrAvatarMaterialLayerState2.blendMode);
			mat.SetInt(LayerMaskTypeParameters[num], (int)ovrAvatarMaterialLayerState2.maskType);
			mat.SetColor(LayerColorParameters[num], ovrAvatarMaterialLayerState2.layerColor);
			if (ovrAvatarMaterialLayerState2.sampleMode != 0)
			{
				string text = LayerSurfaceParameters[num];
				mat.SetTexture(text, GetLoadedTexture(ovrAvatarMaterialLayerState2.sampleTexture));
				mat.SetTextureScale(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.x, ovrAvatarMaterialLayerState2.sampleScaleOffset.y));
				mat.SetTextureOffset(text, new Vector2(ovrAvatarMaterialLayerState2.sampleScaleOffset.z, ovrAvatarMaterialLayerState2.sampleScaleOffset.w));
			}
			if (ovrAvatarMaterialLayerState2.sampleMode == ovrAvatarMaterialLayerSampleMode.Parallax)
			{
				mat.EnableKeyword("PARALLAX_ON");
			}
			mat.SetColor(LayerSampleParametersParameters[num], ovrAvatarMaterialLayerState2.sampleParameters);
			mat.SetColor(LayerMaskParametersParameters[num], ovrAvatarMaterialLayerState2.maskParameters);
			mat.SetColor(LayerMaskAxisParameters[num], ovrAvatarMaterialLayerState2.maskAxis);
		}
		materialStates[mat] = matState;
	}

	public static Texture2D GetLoadedTexture(ulong assetId)
	{
		return ((OvrAvatarAssetTexture)OvrAvatarSDKManager.Instance.GetAsset(assetId))?.texture;
	}
}
public abstract class OvrAvatarDriver : MonoBehaviour
{
	public enum PacketMode
	{
		SDK,
		Unity
	}

	public struct ControllerPose
	{
		public ovrAvatarButton buttons;

		public ovrAvatarTouch touches;

		public Vector2 joystickPosition;

		public float indexTrigger;

		public float handTrigger;

		public bool isActive;

		public static ControllerPose Interpolate(ControllerPose a, ControllerPose b, float t)
		{
			ControllerPose result = default(ControllerPose);
			result.buttons = ((t < 0.5f) ? a.buttons : b.buttons);
			result.touches = ((t < 0.5f) ? a.touches : b.touches);
			result.joystickPosition = Vector2.Lerp(a.joystickPosition, b.joystickPosition, t);
			result.indexTrigger = Mathf.Lerp(a.indexTrigger, b.indexTrigger, t);
			result.handTrigger = Mathf.Lerp(a.handTrigger, b.handTrigger, t);
			result.isActive = ((t < 0.5f) ? a.isActive : b.isActive);
			return result;
		}
	}

	public struct PoseFrame
	{
		public Vector3 headPosition;

		public Quaternion headRotation;

		public Vector3 handLeftPosition;

		public Quaternion handLeftRotation;

		public Vector3 handRightPosition;

		public Quaternion handRightRotation;

		public float voiceAmplitude;

		public ControllerPose controllerLeftPose;

		public ControllerPose controllerRightPose;

		public static PoseFrame Interpolate(PoseFrame a, PoseFrame b, float t)
		{
			PoseFrame result = default(PoseFrame);
			result.headPosition = Vector3.Lerp(a.headPosition, b.headPosition, t);
			result.headRotation = Quaternion.Slerp(a.headRotation, b.headRotation, t);
			result.handLeftPosition = Vector3.Lerp(a.handLeftPosition, b.handLeftPosition, t);
			result.handLeftRotation = Quaternion.Slerp(a.handLeftRotation, b.handLeftRotation, t);
			result.handRightPosition = Vector3.Lerp(a.handRightPosition, b.handRightPosition, t);
			result.handRightRotation = Quaternion.Slerp(a.handRightRotation, b.handRightRotation, t);
			result.voiceAmplitude = Mathf.Lerp(a.voiceAmplitude, b.voiceAmplitude, t);
			result.controllerLeftPose = ControllerPose.Interpolate(a.controllerLeftPose, b.controllerLeftPose, t);
			result.controllerRightPose = ControllerPose.Interpolate(a.controllerRightPose, b.controllerRightPose, t);
			return result;
		}
	}

	public PacketMode Mode;

	protected PoseFrame CurrentPose;

	private ovrAvatarControllerType ControllerType = ovrAvatarControllerType.Quest;

	public PoseFrame GetCurrentPose()
	{
		return CurrentPose;
	}

	public abstract void UpdateTransforms(IntPtr sdkAvatar);

	private void Start()
	{
		switch (OVRPlugin.GetSystemHeadsetType())
		{
		case OVRPlugin.SystemHeadset.Oculus_Quest:
		case OVRPlugin.SystemHeadset.Rift_S:
			ControllerType = ovrAvatarControllerType.Quest;
			break;
		default:
			ControllerType = ovrAvatarControllerType.Touch;
			break;
		}
	}

	public void UpdateTransformsFromPose(IntPtr sdkAvatar)
	{
		if (sdkAvatar != IntPtr.Zero)
		{
			ovrAvatarTransform headPose = OvrAvatar.CreateOvrAvatarTransform(CurrentPose.headPosition, CurrentPose.headRotation);
			ovrAvatarHandInputState inputStateLeft = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handLeftPosition, CurrentPose.handLeftRotation), CurrentPose.controllerLeftPose);
			ovrAvatarHandInputState inputStateRight = OvrAvatar.CreateInputState(OvrAvatar.CreateOvrAvatarTransform(CurrentPose.handRightPosition, CurrentPose.handRightRotation), CurrentPose.controllerRightPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateBody(sdkAvatar, headPose);
			Oculus.Avatar.CAPI.ovrAvatarPose_UpdateHandsWithType(sdkAvatar, inputStateLeft, inputStateRight, ControllerType);
		}
	}

	public static bool GetIsTrackedRemote()
	{
		return false;
	}
}
public class OvrAvatarHand : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarHandComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightHandComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftHandComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.HandLeft = null;
		}
		else
		{
			owner.HandRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class OvrAvatarLocalDriver : OvrAvatarDriver
{
	private Vector3 centerEyePosition = Vector3.zero;

	private Quaternion centerEyeRotation = Quaternion.identity;

	private float voiceAmplitude;

	private ControllerPose GetMalibuControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = (OVRInput.Get(OVRInput.Touch.PrimaryTouchpad) ? ovrAvatarTouch.One : ((ovrAvatarTouch)0));
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad, controller);
		result.indexTrigger = 0f;
		result.handTrigger = 0f;
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private ControllerPose GetControllerPose(OVRInput.Controller controller)
	{
		ovrAvatarButton ovrAvatarButton2 = (ovrAvatarButton)0;
		if (OVRInput.Get(OVRInput.Button.One, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.One;
		}
		if (OVRInput.Get(OVRInput.Button.Two, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Two;
		}
		if (OVRInput.Get(OVRInput.Button.Start, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Three;
		}
		if (OVRInput.Get(OVRInput.Button.PrimaryThumbstick, controller))
		{
			ovrAvatarButton2 |= ovrAvatarButton.Joystick;
		}
		ovrAvatarTouch ovrAvatarTouch2 = (ovrAvatarTouch)0;
		if (OVRInput.Get(OVRInput.Touch.One, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.One;
		}
		if (OVRInput.Get(OVRInput.Touch.Two, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Two;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbstick, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Joystick;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryThumbRest, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbRest;
		}
		if (OVRInput.Get(OVRInput.Touch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Index;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.Pointing;
		}
		if (!OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, controller))
		{
			ovrAvatarTouch2 |= ovrAvatarTouch.ThumbUp;
		}
		ControllerPose result = default(ControllerPose);
		result.buttons = ovrAvatarButton2;
		result.touches = ovrAvatarTouch2;
		result.joystickPosition = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, controller);
		result.indexTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, controller);
		result.handTrigger = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, controller);
		result.isActive = (OVRInput.GetActiveController() & controller) != 0;
		return result;
	}

	private void CalculateCurrentPose()
	{
		OVRNodeStateProperties.GetNodeStatePropertyVector3(XRNode.CenterEye, NodeStatePropertyType.Position, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyePosition);
		OVRNodeStateProperties.GetNodeStatePropertyQuaternion(XRNode.CenterEye, NodeStatePropertyType.Orientation, OVRPlugin.Node.EyeCenter, OVRPlugin.Step.Render, out centerEyeRotation);
		CurrentPose = new PoseFrame
		{
			voiceAmplitude = voiceAmplitude,
			headPosition = centerEyePosition,
			headRotation = centerEyeRotation,
			handLeftPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.LTouch),
			handLeftRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.LTouch),
			handRightPosition = OVRInput.GetLocalControllerPosition(OVRInput.Controller.RTouch),
			handRightRotation = OVRInput.GetLocalControllerRotation(OVRInput.Controller.RTouch),
			controllerLeftPose = GetControllerPose(OVRInput.Controller.LTouch),
			controllerRightPose = GetControllerPose(OVRInput.Controller.RTouch)
		};
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		CalculateCurrentPose();
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarMaterialManager : MonoBehaviour
{
	public enum TextureType
	{
		DiffuseTextures,
		NormalMaps,
		RoughnessMaps,
		Count
	}

	public struct AvatarComponentMaterialProperties
	{
		public ovrAvatarBodyPartType TypeIndex;

		public Color Color;

		public Texture2D[] Textures;

		public float DiffuseIntensity;

		public float RimIntensity;

		public float ReflectionIntensity;
	}

	public struct AvatarTextureArrayProperties
	{
		public Texture2D[] Textures;

		public Texture2DArray TextureArray;
	}

	public struct AvatarMaterialPropertyBlock
	{
		public Vector4[] Colors;

		public float[] DiffuseIntensities;

		public float[] RimIntensities;

		public float[] ReflectionIntensities;
	}

	[Serializable]
	public class AvatarMaterialConfig
	{
		public AvatarComponentMaterialProperties[] ComponentMaterialProperties;

		public AvatarMaterialPropertyBlock MaterialPropertyBlock;
	}

	private Renderer TargetRenderer;

	private AvatarTextureArrayProperties[] TextureArrays;

	private readonly string[] TextureTypeToShaderProperties = new string[3] { "_MainTex", "_NormalMap", "_RoughnessMap" };

	public AvatarMaterialConfig LocalAvatarConfig = new AvatarMaterialConfig();

	public List<ReflectionProbeBlendInfo> ReflectionProbes = new List<ReflectionProbeBlendInfo>();

	private Shader CombinedShader;

	public static string AVATAR_SHADER_LOADER = "OvrAvatar/Avatar_Mobile_Loader";

	public static string AVATAR_SHADER_MAINTEX = "_MainTex";

	public static string AVATAR_SHADER_NORMALMAP = "_NormalMap";

	public static string AVATAR_SHADER_ROUGHNESSMAP = "_RoughnessMap";

	public static string AVATAR_SHADER_COLOR = "_BaseColor";

	public static string AVATAR_SHADER_DIFFUSEINTENSITY = "_DiffuseIntensity";

	public static string AVATAR_SHADER_RIMINTENSITY = "_RimIntensity";

	public static string AVATAR_SHADER_REFLECTIONINTENSITY = "_ReflectionIntensity";

	public static string AVATAR_SHADER_CUBEMAP = "_Cubemap";

	public static string AVATAR_SHADER_ALPHA = "_Alpha";

	public static string AVATAR_SHADER_LOADING_DIMMER = "_LoadingDimmer";

	public static string AVATAR_SHADER_IRIS_COLOR = "_MaskColorIris";

	public static string AVATAR_SHADER_LIP_COLOR = "_MaskColorLips";

	public static string AVATAR_SHADER_BROW_COLOR = "_MaskColorBrows";

	public static string AVATAR_SHADER_LASH_COLOR = "_MaskColorLashes";

	public static string AVATAR_SHADER_SCLERA_COLOR = "_MaskColorSclera";

	public static string AVATAR_SHADER_GUM_COLOR = "_MaskColorGums";

	public static string AVATAR_SHADER_TEETH_COLOR = "_MaskColorTeeth";

	public static string AVATAR_SHADER_LIP_SMOOTHNESS = "_LipSmoothness";

	public static float[] DiffuseIntensities = new float[5] { 0.3f, 0.1f, 0f, 0.15f, 0.15f };

	public static float[] RimIntensities = new float[5] { 5f, 2f, 2.84f, 4f, 4f };

	public static float[] ReflectionIntensities = new float[5] { 0f, 0.3f, 0.4f, 0f, 0f };

	private const float LOADING_ANIMATION_AMPLITUDE = 0.5f;

	private const float LOADING_ANIMATION_PERIOD = 0.35f;

	private const float LOADING_ANIMATION_CURVE_SCALE = 0.25f;

	private const float LOADING_ANIMATION_DIMMER_MIN = 0.3f;

	public void CreateTextureArrays()
	{
		LocalAvatarConfig.ComponentMaterialProperties = new AvatarComponentMaterialProperties[5];
		LocalAvatarConfig.MaterialPropertyBlock.Colors = new Vector4[5];
		LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.RimIntensities = new float[5];
		LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities = new float[5];
		for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
		{
			LocalAvatarConfig.ComponentMaterialProperties[i].Textures = new Texture2D[3];
		}
		TextureArrays = new AvatarTextureArrayProperties[3];
	}

	public void SetRenderer(Renderer renderer)
	{
		TargetRenderer = renderer;
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
	}

	public void OnCombinedMeshReady()
	{
		InitTextureArrays();
		SetMaterialPropertyBlock();
		StartCoroutine(RunLoadingAnimation(DeleteTextureSet));
	}

	public void AddTextureIDToTextureManager(ulong assetID, bool isSingleComponent)
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().AddTextureIDToTextureSet(GetInstanceID(), assetID, isSingleComponent);
	}

	private void DeleteTextureSet()
	{
		OvrAvatarSDKManager.Instance.GetTextureCopyManager().DeleteTextureSet(GetInstanceID());
	}

	public void InitTextureArrays()
	{
		AvatarComponentMaterialProperties avatarComponentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties[0];
		for (int i = 0; i < TextureArrays.Length && i < avatarComponentMaterialProperties.Textures.Length; i++)
		{
			TextureArrays[i].TextureArray = new Texture2DArray(avatarComponentMaterialProperties.Textures[0].height, avatarComponentMaterialProperties.Textures[0].width, LocalAvatarConfig.ComponentMaterialProperties.Length, avatarComponentMaterialProperties.Textures[0].format, mipChain: true, (QualitySettings.activeColorSpace != 0) ? true : false)
			{
				filterMode = FilterMode.Trilinear,
				anisoLevel = ((i == 2) ? 16 : 4)
			};
			TextureArrays[i].TextureArray.name = $"Texture Array Type: {(TextureType)i}";
			TextureArrays[i].Textures = new Texture2D[LocalAvatarConfig.ComponentMaterialProperties.Length];
			for (int j = 0; j < LocalAvatarConfig.ComponentMaterialProperties.Length; j++)
			{
				TextureArrays[i].Textures[j] = LocalAvatarConfig.ComponentMaterialProperties[j].Textures[i];
				TextureArrays[i].Textures[j].name = $"Texture Type: {(TextureType)i} Component: {j}";
			}
			ProcessTexturesWithMips(TextureArrays[i].Textures, avatarComponentMaterialProperties.Textures[i].height, TextureArrays[i].TextureArray);
		}
	}

	private void ProcessTexturesWithMips(Texture2D[] textures, int texArrayResolution, Texture2DArray texArray)
	{
		for (int i = 0; i < textures.Length; i++)
		{
			int num = texArrayResolution;
			for (int num2 = textures[i].mipmapCount - 1; num2 >= 0; num2--)
			{
				int mipSize = texArrayResolution / num;
				OvrAvatarSDKManager.Instance.GetTextureCopyManager().CopyTexture(textures[i], texArray, num2, mipSize, i, useQueue: false);
				num /= 2;
			}
		}
	}

	private void SetMaterialPropertyBlock()
	{
		if (TargetRenderer != null)
		{
			for (int i = 0; i < LocalAvatarConfig.ComponentMaterialProperties.Length; i++)
			{
				LocalAvatarConfig.MaterialPropertyBlock.Colors[i] = LocalAvatarConfig.ComponentMaterialProperties[i].Color;
				LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities[i] = DiffuseIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.RimIntensities[i] = RimIntensities[i];
				LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities[i] = ReflectionIntensities[i];
			}
		}
	}

	private void ApplyMaterialPropertyBlock()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.SetVectorArray(AVATAR_SHADER_COLOR, LocalAvatarConfig.MaterialPropertyBlock.Colors);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_DIFFUSEINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.DiffuseIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_RIMINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.RimIntensities);
		materialPropertyBlock.SetFloatArray(AVATAR_SHADER_REFLECTIONINTENSITY, LocalAvatarConfig.MaterialPropertyBlock.ReflectionIntensities);
		TargetRenderer.GetClosestReflectionProbes(ReflectionProbes);
		if (ReflectionProbes != null && ReflectionProbes.Count > 0 && ReflectionProbes[0].probe.texture != null)
		{
			materialPropertyBlock.SetTexture(AVATAR_SHADER_CUBEMAP, ReflectionProbes[0].probe.texture);
		}
		for (int i = 0; i < TextureArrays.Length; i++)
		{
			materialPropertyBlock.SetTexture(TextureTypeToShaderProperties[i], TextureArrays[i].TextureArray);
		}
		TargetRenderer.SetPropertyBlock(materialPropertyBlock);
	}

	public static ovrAvatarBodyPartType GetComponentType(string objectName)
	{
		if (objectName.Contains("0"))
		{
			return ovrAvatarBodyPartType.Body;
		}
		if (objectName.Contains("1"))
		{
			return ovrAvatarBodyPartType.Clothing;
		}
		if (objectName.Contains("2"))
		{
			return ovrAvatarBodyPartType.Eyewear;
		}
		if (objectName.Contains("3"))
		{
			return ovrAvatarBodyPartType.Hair;
		}
		if (objectName.Contains("4"))
		{
			return ovrAvatarBodyPartType.Beard;
		}
		return ovrAvatarBodyPartType.Count;
	}

	private ulong GetTextureIDForType(ovrAvatarPBSMaterialState materialState, TextureType type)
	{
		return type switch
		{
			TextureType.DiffuseTextures => materialState.albedoTextureID, 
			TextureType.NormalMaps => materialState.normalTextureID, 
			TextureType.RoughnessMaps => materialState.metallicnessTextureID, 
			_ => 0uL, 
		};
	}

	public void ValidateTextures(ovrAvatarPBSMaterialState[] materialStates)
	{
		AvatarComponentMaterialProperties[] componentMaterialProperties = LocalAvatarConfig.ComponentMaterialProperties;
		int[] array = new int[3];
		TextureFormat[] array2 = new TextureFormat[3];
		for (int i = 0; i < componentMaterialProperties.Length; i++)
		{
			for (int j = 0; j < componentMaterialProperties[i].Textures.Length; j++)
			{
				if (componentMaterialProperties[i].Textures[j] == null)
				{
					string text = componentMaterialProperties[i].TypeIndex.ToString();
					TextureType textureType = (TextureType)j;
					throw new Exception(text + "Invalid: " + textureType);
				}
				array[j] = componentMaterialProperties[i].Textures[j].height;
				array2[j] = componentMaterialProperties[i].Textures[j].format;
			}
		}
		for (int k = 0; k < 3; k++)
		{
			for (int l = 1; l < componentMaterialProperties.Length; l++)
			{
				if (componentMaterialProperties[l - 1].Textures[k].height != componentMaterialProperties[l].Textures[k].height)
				{
					object[] obj = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Resolutions: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj[2] = textureType.ToString();
					obj[3] = " ";
					obj[4] = componentMaterialProperties[l - 1].Textures[k].height;
					obj[5] = " (ID: ";
					obj[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj[7] = ") vs ";
					obj[8] = componentMaterialProperties[l].Textures[k].height;
					obj[9] = " (ID: ";
					obj[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj));
				}
				if (componentMaterialProperties[l - 1].Textures[k].format != componentMaterialProperties[l].Textures[k].format)
				{
					object[] obj2 = new object[12]
					{
						componentMaterialProperties[l].TypeIndex.ToString(),
						" Mismatching Formats: ",
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null,
						null
					};
					TextureType textureType = (TextureType)k;
					obj2[2] = textureType.ToString();
					obj2[3] = " ";
					obj2[4] = componentMaterialProperties[l - 1].Textures[k].format;
					obj2[5] = " (ID: ";
					obj2[6] = GetTextureIDForType(materialStates[l - 1], (TextureType)k);
					obj2[7] = ") vs ";
					obj2[8] = componentMaterialProperties[l].Textures[k].format;
					obj2[9] = " (ID: ";
					obj2[10] = GetTextureIDForType(materialStates[l], (TextureType)k);
					obj2[11] = ") Ensure you are using ASTC texture compression on Android or turn off CombineMeshes";
					throw new Exception(string.Concat(obj2));
				}
			}
		}
	}

	private IEnumerator RunLoadingAnimation(System.Action callBack)
	{
		CombinedShader = TargetRenderer.sharedMaterial.shader;
		int srcBlend = TargetRenderer.sharedMaterial.GetInt("_SrcBlend");
		int dstBlend = TargetRenderer.sharedMaterial.GetInt("_DstBlend");
		string lightModeTag = TargetRenderer.sharedMaterial.GetTag("LightMode", searchFallbacks: false);
		string renderTypeTag = TargetRenderer.sharedMaterial.GetTag("RenderType", searchFallbacks: false);
		string renderQueueTag = TargetRenderer.sharedMaterial.GetTag("Queue", searchFallbacks: false);
		string ignoreProjectorTag = TargetRenderer.sharedMaterial.GetTag("IgnoreProjector", searchFallbacks: false);
		int renderQueue = TargetRenderer.sharedMaterial.renderQueue;
		bool transparentQueue = TargetRenderer.sharedMaterial.IsKeywordEnabled("_ALPHATEST_ON");
		TargetRenderer.sharedMaterial.shader = Shader.Find(AVATAR_SHADER_LOADER);
		TargetRenderer.sharedMaterial.SetColor(AVATAR_SHADER_COLOR, Color.white);
		while (OvrAvatarSDKManager.Instance.GetTextureCopyManager().GetTextureCount() > 0)
		{
			float value = (0.5f * Mathf.Sin(Time.timeSinceLevelLoad / 0.35f) + 0.5f) * 0.25f + 0.3f;
			TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, value);
			yield return null;
		}
		TargetRenderer.sharedMaterial.SetFloat(AVATAR_SHADER_LOADING_DIMMER, 1f);
		TargetRenderer.sharedMaterial.shader = CombinedShader;
		TargetRenderer.sharedMaterial.SetInt("_SrcBlend", srcBlend);
		TargetRenderer.sharedMaterial.SetInt("_DstBlend", dstBlend);
		TargetRenderer.sharedMaterial.SetOverrideTag("LightMode", lightModeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("RenderType", renderTypeTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("Queue", renderQueueTag);
		TargetRenderer.sharedMaterial.SetOverrideTag("IgnoreProjector", ignoreProjectorTag);
		if (transparentQueue)
		{
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		else
		{
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHATEST_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHABLEND_ON");
			TargetRenderer.sharedMaterial.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		}
		TargetRenderer.sharedMaterial.renderQueue = renderQueue;
		ApplyMaterialPropertyBlock();
		callBack?.Invoke();
	}
}
public class OvrAvatarPacket
{
	public IntPtr ovrNativePacket = IntPtr.Zero;

	private List<float> frameTimes = new List<float>();

	private List<OvrAvatarDriver.PoseFrame> frames = new List<OvrAvatarDriver.PoseFrame>();

	private List<byte[]> encodedAudioPackets = new List<byte[]>();

	public float Duration => frameTimes[frameTimes.Count - 1];

	public OvrAvatarDriver.PoseFrame FinalFrame => frames[frames.Count - 1];

	public OvrAvatarPacket()
	{
	}

	public OvrAvatarPacket(OvrAvatarDriver.PoseFrame initialPose)
	{
		frameTimes.Add(0f);
		frames.Add(initialPose);
	}

	private OvrAvatarPacket(List<float> frameTimes, List<OvrAvatarDriver.PoseFrame> frames, List<byte[]> audioPackets)
	{
		this.frameTimes = frameTimes;
		this.frames = frames;
	}

	public void AddFrame(OvrAvatarDriver.PoseFrame frame, float deltaSeconds)
	{
		frameTimes.Add(Duration + deltaSeconds);
		frames.Add(frame);
	}

	public OvrAvatarDriver.PoseFrame GetPoseFrame(float seconds)
	{
		if (frames.Count == 1)
		{
			return frames[0];
		}
		int i;
		for (i = 1; i < frameTimes.Count && frameTimes[i] < seconds; i++)
		{
		}
		OvrAvatarDriver.PoseFrame a = frames[i - 1];
		OvrAvatarDriver.PoseFrame b = frames[i];
		float num = frameTimes[i - 1];
		float num2 = frameTimes[i];
		float t = (seconds - num) / (num2 - num);
		return OvrAvatarDriver.PoseFrame.Interpolate(a, b, t);
	}

	public static OvrAvatarPacket Read(Stream stream)
	{
		BinaryReader binaryReader = new BinaryReader(stream);
		int num = binaryReader.ReadInt32();
		List<float> list = new List<float>(num);
		for (int i = 0; i < num; i++)
		{
			list.Add(binaryReader.ReadSingle());
		}
		List<OvrAvatarDriver.PoseFrame> list2 = new List<OvrAvatarDriver.PoseFrame>(num);
		for (int j = 0; j < num; j++)
		{
			list2.Add(binaryReader.ReadPoseFrame());
		}
		int num2 = binaryReader.ReadInt32();
		List<byte[]> list3 = new List<byte[]>(num2);
		for (int k = 0; k < num2; k++)
		{
			int count = binaryReader.ReadInt32();
			byte[] item = binaryReader.ReadBytes(count);
			list3.Add(item);
		}
		return new OvrAvatarPacket(list, list2, list3);
	}

	public void Write(Stream stream)
	{
		BinaryWriter binaryWriter = new BinaryWriter(stream);
		int count = frameTimes.Count;
		binaryWriter.Write(count);
		for (int i = 0; i < count; i++)
		{
			binaryWriter.Write(frameTimes[i]);
		}
		for (int j = 0; j < count; j++)
		{
			OvrAvatarDriver.PoseFrame frame = frames[j];
			binaryWriter.Write(frame);
		}
		int count2 = encodedAudioPackets.Count;
		binaryWriter.Write(count2);
		for (int k = 0; k < count2; k++)
		{
			byte[] array = encodedAudioPackets[k];
			binaryWriter.Write(array.Length);
			binaryWriter.Write(array);
		}
	}
}
internal static class BinaryWriterExtensions
{
	public static void Write(this BinaryWriter writer, OvrAvatarDriver.PoseFrame frame)
	{
		writer.Write(frame.headPosition);
		writer.Write(frame.headRotation);
		writer.Write(frame.handLeftPosition);
		writer.Write(frame.handLeftRotation);
		writer.Write(frame.handRightPosition);
		writer.Write(frame.handRightRotation);
		writer.Write(frame.voiceAmplitude);
		writer.Write(frame.controllerLeftPose);
		writer.Write(frame.controllerRightPose);
	}

	public static void Write(this BinaryWriter writer, Vector3 vec3)
	{
		writer.Write(vec3.x);
		writer.Write(vec3.y);
		writer.Write(vec3.z);
	}

	public static void Write(this BinaryWriter writer, Vector2 vec2)
	{
		writer.Write(vec2.x);
		writer.Write(vec2.y);
	}

	public static void Write(this BinaryWriter writer, Quaternion quat)
	{
		writer.Write(quat.x);
		writer.Write(quat.y);
		writer.Write(quat.z);
		writer.Write(quat.w);
	}

	public static void Write(this BinaryWriter writer, OvrAvatarDriver.ControllerPose pose)
	{
		writer.Write((uint)pose.buttons);
		writer.Write((uint)pose.touches);
		writer.Write(pose.joystickPosition);
		writer.Write(pose.indexTrigger);
		writer.Write(pose.handTrigger);
		writer.Write(pose.isActive);
	}
}
internal static class BinaryReaderExtensions
{
	public static OvrAvatarDriver.PoseFrame ReadPoseFrame(this BinaryReader reader)
	{
		OvrAvatarDriver.PoseFrame result = default(OvrAvatarDriver.PoseFrame);
		result.headPosition = reader.ReadVector3();
		result.headRotation = reader.ReadQuaternion();
		result.handLeftPosition = reader.ReadVector3();
		result.handLeftRotation = reader.ReadQuaternion();
		result.handRightPosition = reader.ReadVector3();
		result.handRightRotation = reader.ReadQuaternion();
		result.voiceAmplitude = reader.ReadSingle();
		result.controllerLeftPose = reader.ReadControllerPose();
		result.controllerRightPose = reader.ReadControllerPose();
		return result;
	}

	public static Vector2 ReadVector2(this BinaryReader reader)
	{
		Vector2 result = default(Vector2);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		return result;
	}

	public static Vector3 ReadVector3(this BinaryReader reader)
	{
		Vector3 result = default(Vector3);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		return result;
	}

	public static Quaternion ReadQuaternion(this BinaryReader reader)
	{
		Quaternion result = default(Quaternion);
		result.x = reader.ReadSingle();
		result.y = reader.ReadSingle();
		result.z = reader.ReadSingle();
		result.w = reader.ReadSingle();
		return result;
	}

	public static OvrAvatarDriver.ControllerPose ReadControllerPose(this BinaryReader reader)
	{
		OvrAvatarDriver.ControllerPose result = default(OvrAvatarDriver.ControllerPose);
		result.buttons = (ovrAvatarButton)reader.ReadUInt32();
		result.touches = (ovrAvatarTouch)reader.ReadUInt32();
		result.joystickPosition = reader.ReadVector2();
		result.indexTrigger = reader.ReadSingle();
		result.handTrigger = reader.ReadSingle();
		result.isActive = reader.ReadBoolean();
		return result;
	}
}
public class OvrAvatarRemoteDriver : OvrAvatarDriver
{
	private Queue<OvrAvatarPacket> packetQueue = new Queue<OvrAvatarPacket>();

	private IntPtr CurrentSDKPacket = IntPtr.Zero;

	private float CurrentPacketTime;

	private const int MinPacketQueue = 1;

	private const int MaxPacketQueue = 4;

	private int CurrentSequence = -1;

	private bool isStreaming;

	private OvrAvatarPacket currentPacket;

	public void QueuePacket(int sequence, OvrAvatarPacket packet)
	{
		if (sequence > CurrentSequence)
		{
			CurrentSequence = sequence;
			packetQueue.Enqueue(packet);
		}
	}

	public override void UpdateTransforms(IntPtr sdkAvatar)
	{
		switch (Mode)
		{
		case PacketMode.SDK:
			UpdateFromSDKPacket(sdkAvatar);
			break;
		case PacketMode.Unity:
			UpdateFromUnityPacket(sdkAvatar);
			break;
		}
	}

	private void UpdateFromSDKPacket(IntPtr sdkAvatar)
	{
		if (CurrentSDKPacket == IntPtr.Zero && packetQueue.Count >= 1)
		{
			CurrentSDKPacket = packetQueue.Dequeue().ovrNativePacket;
		}
		if (!(CurrentSDKPacket != IntPtr.Zero))
		{
			return;
		}
		float num = Oculus.Avatar.CAPI.ovrAvatarPacket_GetDurationSeconds(CurrentSDKPacket);
		Oculus.Avatar.CAPI.ovrAvatar_UpdatePoseFromPacket(sdkAvatar, CurrentSDKPacket, Mathf.Min(num, CurrentPacketTime));
		CurrentPacketTime += Time.deltaTime;
		if (CurrentPacketTime > num)
		{
			Oculus.Avatar.CAPI.ovrAvatarPacket_Free(CurrentSDKPacket);
			CurrentSDKPacket = IntPtr.Zero;
			CurrentPacketTime -= num;
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
		}
	}

	private void UpdateFromUnityPacket(IntPtr sdkAvatar)
	{
		if (!isStreaming && packetQueue.Count > 1)
		{
			currentPacket = packetQueue.Dequeue();
			isStreaming = true;
		}
		if (!isStreaming)
		{
			return;
		}
		CurrentPacketTime += Time.deltaTime;
		while (CurrentPacketTime > currentPacket.Duration)
		{
			if (packetQueue.Count == 0)
			{
				CurrentPose = currentPacket.FinalFrame;
				CurrentPacketTime = 0f;
				currentPacket = null;
				isStreaming = false;
				return;
			}
			while (packetQueue.Count > 4)
			{
				packetQueue.Dequeue();
			}
			CurrentPacketTime -= currentPacket.Duration;
			currentPacket = packetQueue.Dequeue();
		}
		CurrentPose = currentPacket.GetPoseFrame(CurrentPacketTime);
		UpdateTransformsFromPose(sdkAvatar);
	}
}
public class OvrAvatarRenderComponent : MonoBehaviour
{
	private bool firstSkinnedUpdate = true;

	public SkinnedMeshRenderer mesh;

	public Transform[] bones;

	private bool isBodyComponent;

	protected void UpdateActive(OvrAvatar avatar, ovrAvatarVisibilityFlags mask)
	{
		if (isBodyComponent && avatar.EnableExpressive && avatar.ShowFirstPerson && !avatar.ShowThirdPerson)
		{
			bool num = (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			bool flag = (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag || flag);
			if (!num)
			{
				mesh.enabled = false;
			}
		}
		else
		{
			bool flag2 = avatar.ShowFirstPerson && (mask & ovrAvatarVisibilityFlags.FirstPerson) != 0;
			flag2 |= avatar.ShowThirdPerson && (mask & ovrAvatarVisibilityFlags.ThirdPerson) != 0;
			base.gameObject.SetActive(flag2);
			mesh.enabled = flag2;
		}
	}

	protected SkinnedMeshRenderer CreateSkinnedMesh(ulong assetID, ovrAvatarVisibilityFlags visibilityMask, int thirdPersonLayer, int firstPersonLayer)
	{
		isBodyComponent = base.name.Contains("body");
		OvrAvatarAssetMesh obj = ((OvrAvatarAssetMesh)OvrAvatarSDKManager.Instance.GetAsset(assetID)) ?? throw new Exception("Couldn't find mesh for asset " + assetID);
		if ((visibilityMask & ovrAvatarVisibilityFlags.ThirdPerson) != 0)
		{
			base.gameObject.layer = thirdPersonLayer;
		}
		else
		{
			base.gameObject.layer = firstPersonLayer;
		}
		SkinnedMeshRenderer skinnedMeshRenderer = obj.CreateSkinnedMeshRendererOnObject(base.gameObject);
		skinnedMeshRenderer.quality = SkinQuality.Bone2;
		skinnedMeshRenderer.updateWhenOffscreen = true;
		if ((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) == 0)
		{
			skinnedMeshRenderer.shadowCastingMode = ShadowCastingMode.Off;
		}
		base.gameObject.SetActive(value: false);
		return skinnedMeshRenderer;
	}

	protected void UpdateSkinnedMesh(OvrAvatar avatar, Transform[] bones, ovrAvatarTransform localTransform, ovrAvatarVisibilityFlags visibilityMask, IntPtr renderPart)
	{
		UpdateActive(avatar, visibilityMask);
		OvrAvatar.ConvertTransform(localTransform, base.transform);
		ovrAvatarRenderPartType ovrAvatarRenderPartType2 = Oculus.Avatar.CAPI.ovrAvatarRenderPart_GetType(renderPart);
		ulong num = ovrAvatarRenderPartType2 switch
		{
			ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(renderPart), 
			ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(renderPart), 
			_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
		};
		for (uint num2 = 0u; num2 < 64; num2++)
		{
			ulong num3 = (ulong)(1L << (int)num2);
			if ((firstSkinnedUpdate && num2 < bones.Length) || (num3 & num) != 0L)
			{
				Transform target = bones[num2];
				OvrAvatar.ConvertTransform(ovrAvatarRenderPartType2 switch
				{
					ovrAvatarRenderPartType.SkinnedMeshRender => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(renderPart, num2), 
					ovrAvatarRenderPartType.SkinnedMeshRenderPBS_V2 => Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(renderPart, num2), 
					_ => throw new Exception("Unhandled render part type: " + ovrAvatarRenderPartType2), 
				}, target);
			}
		}
		firstSkinnedUpdate = false;
	}

	protected Material CreateAvatarMaterial(string name, Shader shader)
	{
		if (shader == null)
		{
			throw new Exception("No shader provided for avatar material.");
		}
		return new Material(shader)
		{
			name = name
		};
	}
}
[Flags]
public enum ovrAvatarCapabilities
{
	Body = 1,
	Hands = 2,
	Base = 4,
	BodyTilt = 0x10,
	Expressive = 0x20,
	All = -1
}
public enum ovrAvatarMessageType
{
	AvatarSpecification,
	AssetLoaded,
	Count
}
public struct ovrAvatarMessage_AvatarSpecification
{
	public IntPtr avatarSpec;

	public ulong oculusUserID;
}
public struct ovrAvatarMessage_AssetLoaded
{
	public ulong assetID;

	public IntPtr asset;
}
public enum ovrAvatarAssetType
{
	Mesh,
	Texture,
	Pose,
	Material,
	CombinedMesh,
	PBSMaterial,
	FailedLoad,
	Count
}
public struct ovrAvatarMeshVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarMeshVertexV2
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;

	public float tw;

	public float u;

	public float v;

	public float r;

	public float g;

	public float b;

	public float a;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public byte[] blendIndices;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
	public float[] blendWeights;
}
public struct ovrAvatarBlendVertex
{
	public float x;

	public float y;

	public float z;

	public float nx;

	public float ny;

	public float nz;

	public float tx;

	public float ty;

	public float tz;
}
public struct ovrAvatarMeshAssetData
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public struct ovrAvatarMeshAssetDataV2
{
	public uint vertexCount;

	public IntPtr vertexBuffer;

	public uint indexCount;

	public IntPtr indexBuffer;

	public ovrAvatarSkinnedMeshPose skinnedBindPose;
}
public enum ovrAvatarTextureFormat
{
	RGB24,
	DXT1,
	DXT5,
	ASTC_RGB_6x6,
	ASTC_RGB_6x6_MIPMAPS,
	Count
}
public struct ovrAvatarTextureAssetData
{
	public ovrAvatarTextureFormat format;

	public uint sizeX;

	public uint sizeY;

	public uint mipCount;

	public ulong textureDataSize;

	public IntPtr textureData;
}
public enum ovrAvatarRenderPartType
{
	SkinnedMeshRender,
	SkinnedMeshRenderPBS,
	ProjectorRender,
	SkinnedMeshRenderPBS_V2,
	Count
}
public enum ovrAvatarLogLevel
{
	Unknown,
	Default,
	Verbose,
	Debug,
	Info,
	Warn,
	Error,
	Fatal,
	Silent
}
public struct ovrAvatarTransform
{
	public Vector3 position;

	public Quaternion orientation;

	public Vector3 scale;
}
[Flags]
public enum ovrAvatarButton
{
	One = 1,
	Two = 2,
	Three = 4,
	Joystick = 8
}
[Flags]
public enum ovrAvatarTouch
{
	One = 1,
	Two = 2,
	Joystick = 4,
	ThumbRest = 8,
	Index = 0x10,
	Pointing = 0x40,
	ThumbUp = 0x80
}
public struct ovrAvatarHandInputState
{
	public ovrAvatarTransform transform;

	public ovrAvatarButton buttonMask;

	public ovrAvatarTouch touchMask;

	public float joystickX;

	public float joystickY;

	public float indexTrigger;

	public float handTrigger;

	[MarshalAs(UnmanagedType.I1)]
	public bool isActive;
}
public struct ovrAvatarComponent
{
	public ovrAvatarTransform transform;

	public uint renderPartCount;

	public IntPtr renderParts;

	[MarshalAs(UnmanagedType.LPStr)]
	public string name;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarComponent_Offsets
{
	public static long transform = Marshal.OffsetOf(typeof(ovrAvatarComponent), "transform").ToInt64();

	public static int renderPartCount = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderPartCount").ToInt32();

	public static int renderParts = Marshal.OffsetOf(typeof(ovrAvatarComponent), "renderParts").ToInt32();

	public static int name = Marshal.OffsetOf(typeof(ovrAvatarComponent), "name").ToInt32();
}
public struct ovrAvatarBaseComponent
{
	public Vector3 basePosition;

	public IntPtr renderComponent;
}
public struct ovrAvatarBodyComponent
{
	public ovrAvatarTransform leftEyeTransform;

	public ovrAvatarTransform rightEyeTransform;

	public ovrAvatarTransform centerEyeTransform;

	public IntPtr renderComponent;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct ovrAvatarBodyComponent_Offsets
{
	public static long leftEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "leftEyeTransform").ToInt64();

	public static long rightEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "rightEyeTransform").ToInt64();

	public static long centerEyeTransform = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "centerEyeTransform").ToInt64();

	public static long renderComponent = Marshal.OffsetOf(typeof(ovrAvatarBodyComponent), "renderComponent").ToInt64();
}
public struct ovrAvatarControllerComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public struct ovrAvatarHandComponent
{
	public ovrAvatarHandInputState inputState;

	public IntPtr renderComponent;
}
public enum ovrAvatarMaterialLayerBlendMode
{
	Add,
	Multiply,
	Count
}
public enum ovrAvatarMaterialLayerSampleMode
{
	Color,
	Texture,
	TextureSingleChannel,
	Parallax,
	Count
}
public enum ovrAvatarMaterialMaskType
{
	None,
	Positional,
	ViewReflection,
	Fresnel,
	Pulse,
	Count
}
public enum ovrAvatarControllerType
{
	Touch,
	Malibu,
	Go,
	Quest,
	Count
}
public enum ovrAvatarAssetLevelOfDetail
{
	Lowest = 1,
	Medium = 3,
	Highest = 5
}
public enum ovrAvatarLookAndFeelVersion
{
	Unknown = -1,
	One,
	Two
}
public struct ovrAvatarMaterialLayerState
{
	public ovrAvatarMaterialLayerBlendMode blendMode;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ovrAvatarMaterialMaskType maskType;

	public Vector4 layerColor;

	public Vector4 sampleParameters;

	public ulong sampleTexture;

	public Vector4 sampleScaleOffset;

	public Vector4 maskParameters;

	public Vector4 maskAxis;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialLayerState ovrAvatarMaterialLayerState2))
		{
			return false;
		}
		if (blendMode != ovrAvatarMaterialLayerState2.blendMode)
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialLayerState2.sampleMode)
		{
			return false;
		}
		if (maskType != ovrAvatarMaterialLayerState2.maskType)
		{
			return false;
		}
		if (!VectorEquals(layerColor, ovrAvatarMaterialLayerState2.layerColor))
		{
			return false;
		}
		if (!VectorEquals(sampleParameters, ovrAvatarMaterialLayerState2.sampleParameters))
		{
			return false;
		}
		if (sampleTexture != ovrAvatarMaterialLayerState2.sampleTexture)
		{
			return false;
		}
		if (!VectorEquals(sampleScaleOffset, ovrAvatarMaterialLayerState2.sampleScaleOffset))
		{
			return false;
		}
		if (!VectorEquals(maskParameters, ovrAvatarMaterialLayerState2.maskParameters))
		{
			return false;
		}
		if (!VectorEquals(maskAxis, ovrAvatarMaterialLayerState2.maskAxis))
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return blendMode.GetHashCode() ^ sampleMode.GetHashCode() ^ maskType.GetHashCode() ^ layerColor.GetHashCode() ^ sampleParameters.GetHashCode() ^ sampleTexture.GetHashCode() ^ sampleScaleOffset.GetHashCode() ^ maskParameters.GetHashCode() ^ maskAxis.GetHashCode();
	}
}
public struct ovrAvatarMaterialState
{
	public Vector4 baseColor;

	public ovrAvatarMaterialMaskType baseMaskType;

	public Vector4 baseMaskParameters;

	public Vector4 baseMaskAxis;

	public ovrAvatarMaterialLayerSampleMode sampleMode;

	public ulong alphaMaskTextureID;

	public Vector4 alphaMaskScaleOffset;

	public ulong normalMapTextureID;

	public Vector4 normalMapScaleOffset;

	public ulong parallaxMapTextureID;

	public Vector4 parallaxMapScaleOffset;

	public ulong roughnessMapTextureID;

	public Vector4 roughnessMapScaleOffset;

	public uint layerCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
	public ovrAvatarMaterialLayerState[] layers;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarMaterialState ovrAvatarMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarMaterialState2.baseColor))
		{
			return false;
		}
		if (baseMaskType != ovrAvatarMaterialState2.baseMaskType)
		{
			return false;
		}
		if (!VectorEquals(baseMaskParameters, ovrAvatarMaterialState2.baseMaskParameters))
		{
			return false;
		}
		if (!VectorEquals(baseMaskAxis, ovrAvatarMaterialState2.baseMaskAxis))
		{
			return false;
		}
		if (sampleMode != ovrAvatarMaterialState2.sampleMode)
		{
			return false;
		}
		if (alphaMaskTextureID != ovrAvatarMaterialState2.alphaMaskTextureID)
		{
			return false;
		}
		if (!VectorEquals(alphaMaskScaleOffset, ovrAvatarMaterialState2.alphaMaskScaleOffset))
		{
			return false;
		}
		if (normalMapTextureID != ovrAvatarMaterialState2.normalMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(normalMapScaleOffset, ovrAvatarMaterialState2.normalMapScaleOffset))
		{
			return false;
		}
		if (parallaxMapTextureID != ovrAvatarMaterialState2.parallaxMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(parallaxMapScaleOffset, ovrAvatarMaterialState2.parallaxMapScaleOffset))
		{
			return false;
		}
		if (roughnessMapTextureID != ovrAvatarMaterialState2.roughnessMapTextureID)
		{
			return false;
		}
		if (!VectorEquals(roughnessMapScaleOffset, ovrAvatarMaterialState2.roughnessMapScaleOffset))
		{
			return false;
		}
		if (layerCount != ovrAvatarMaterialState2.layerCount)
		{
			return false;
		}
		for (int i = 0; i < layerCount; i++)
		{
			if (!layers[i].Equals(ovrAvatarMaterialState2.layers[i]))
			{
				return false;
			}
		}
		return true;
	}

	public override int GetHashCode()
	{
		int num = 0;
		num ^= baseColor.GetHashCode();
		num ^= baseMaskType.GetHashCode();
		num ^= baseMaskParameters.GetHashCode();
		num ^= baseMaskAxis.GetHashCode();
		num ^= sampleMode.GetHashCode();
		num ^= alphaMaskTextureID.GetHashCode();
		num ^= alphaMaskScaleOffset.GetHashCode();
		num ^= normalMapTextureID.GetHashCode();
		num ^= normalMapScaleOffset.GetHashCode();
		num ^= parallaxMapTextureID.GetHashCode();
		num ^= parallaxMapScaleOffset.GetHashCode();
		num ^= roughnessMapTextureID.GetHashCode();
		num ^= roughnessMapScaleOffset.GetHashCode();
		num ^= layerCount.GetHashCode();
		for (int i = 0; i < layerCount; i++)
		{
			num ^= layers[i].GetHashCode();
		}
		return num;
	}
}
public struct ovrAvatarExpressiveParameters
{
	public Vector4 irisColor;

	public Vector4 scleraColor;

	public Vector4 lashColor;

	public Vector4 browColor;

	public Vector4 lipColor;

	public Vector4 teethColor;

	public Vector4 gumColor;

	public float browLashIntensity;

	public float lipSmoothness;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarExpressiveParameters ovrAvatarExpressiveParameters2))
		{
			return false;
		}
		if (!VectorEquals(irisColor, ovrAvatarExpressiveParameters2.irisColor))
		{
			return false;
		}
		if (!VectorEquals(scleraColor, ovrAvatarExpressiveParameters2.scleraColor))
		{
			return false;
		}
		if (!VectorEquals(lashColor, ovrAvatarExpressiveParameters2.lashColor))
		{
			return false;
		}
		if (!VectorEquals(browColor, ovrAvatarExpressiveParameters2.browColor))
		{
			return false;
		}
		if (!VectorEquals(lipColor, ovrAvatarExpressiveParameters2.lipColor))
		{
			return false;
		}
		if (!VectorEquals(teethColor, ovrAvatarExpressiveParameters2.teethColor))
		{
			return false;
		}
		if (!VectorEquals(gumColor, ovrAvatarExpressiveParameters2.gumColor))
		{
			return false;
		}
		if (browLashIntensity != ovrAvatarExpressiveParameters2.browLashIntensity)
		{
			return false;
		}
		if (lipSmoothness != ovrAvatarExpressiveParameters2.lipSmoothness)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return irisColor.GetHashCode() ^ scleraColor.GetHashCode() ^ lashColor.GetHashCode() ^ browColor.GetHashCode() ^ lipColor.GetHashCode() ^ teethColor.GetHashCode() ^ gumColor.GetHashCode() ^ browLashIntensity.GetHashCode() ^ lipSmoothness.GetHashCode();
	}
}
public struct ovrAvatarPBSMaterialState
{
	public Vector4 baseColor;

	public ulong albedoTextureID;

	public Vector4 albedoMultiplier;

	public ulong metallicnessTextureID;

	public float glossinessScale;

	public ulong normalTextureID;

	public ulong heightTextureID;

	public ulong occlusionTextureID;

	public ulong emissionTextureID;

	public Vector4 emissionMultiplier;

	public ulong detailMaskTextureID;

	public ulong detailAlbedoTextureID;

	public ulong detailNormalTextureID;

	private static bool VectorEquals(Vector4 a, Vector4 b)
	{
		if (a.x == b.x && a.y == b.y && a.z == b.z)
		{
			return a.w == b.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2))
		{
			return false;
		}
		if (!VectorEquals(baseColor, ovrAvatarPBSMaterialState2.baseColor))
		{
			return false;
		}
		if (albedoTextureID != ovrAvatarPBSMaterialState2.albedoTextureID)
		{
			return false;
		}
		if (!VectorEquals(albedoMultiplier, ovrAvatarPBSMaterialState2.albedoMultiplier))
		{
			return false;
		}
		if (metallicnessTextureID != ovrAvatarPBSMaterialState2.metallicnessTextureID)
		{
			return false;
		}
		if (glossinessScale != ovrAvatarPBSMaterialState2.glossinessScale)
		{
			return false;
		}
		if (normalTextureID != ovrAvatarPBSMaterialState2.normalTextureID)
		{
			return false;
		}
		if (heightTextureID != ovrAvatarPBSMaterialState2.heightTextureID)
		{
			return false;
		}
		if (occlusionTextureID != ovrAvatarPBSMaterialState2.occlusionTextureID)
		{
			return false;
		}
		if (emissionTextureID != ovrAvatarPBSMaterialState2.emissionTextureID)
		{
			return false;
		}
		if (!VectorEquals(emissionMultiplier, ovrAvatarPBSMaterialState2.emissionMultiplier))
		{
			return false;
		}
		if (detailMaskTextureID != ovrAvatarPBSMaterialState2.detailMaskTextureID)
		{
			return false;
		}
		if (detailAlbedoTextureID != ovrAvatarPBSMaterialState2.detailAlbedoTextureID)
		{
			return false;
		}
		if (detailNormalTextureID != ovrAvatarPBSMaterialState2.detailNormalTextureID)
		{
			return false;
		}
		return true;
	}

	public override int GetHashCode()
	{
		return baseColor.GetHashCode() ^ albedoTextureID.GetHashCode() ^ albedoMultiplier.GetHashCode() ^ metallicnessTextureID.GetHashCode() ^ glossinessScale.GetHashCode() ^ normalTextureID.GetHashCode() ^ heightTextureID.GetHashCode() ^ occlusionTextureID.GetHashCode() ^ emissionTextureID.GetHashCode() ^ emissionMultiplier.GetHashCode() ^ detailMaskTextureID.GetHashCode() ^ detailAlbedoTextureID.GetHashCode() ^ detailNormalTextureID.GetHashCode();
	}
}
public class OvrAvatarAssetMaterial : OvrAvatarAsset
{
	public ovrAvatarMaterialState material;

	public OvrAvatarAssetMaterial(ulong id, IntPtr mat)
	{
		assetID = id;
		material = Oculus.Avatar.CAPI.ovrAvatarAsset_GetMaterialState(mat);
	}
}
public struct ovrAvatarSkinnedMeshPose
{
	public uint jointCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public ovrAvatarTransform[] jointTransform;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public int[] jointParents;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public IntPtr[] jointNames;
}
[Flags]
public enum ovrAvatarVisibilityFlags
{
	FirstPerson = 1,
	ThirdPerson = 2,
	SelfOccluding = 4
}
public struct ovrAvatarRenderPart_SkinnedMeshRender
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ulong albedoTextureAssetID;

	public ulong surfaceTextureAssetID;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public struct ovrAvatarRenderPart_ProjectorRender
{
	public ovrAvatarTransform localTransform;

	public uint componentIndex;

	public uint renderPartIndex;

	public ovrAvatarMaterialState materialState;
}
public struct ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2
{
	public ovrAvatarTransform localTransform;

	public ovrAvatarVisibilityFlags visibilityMask;

	public ulong meshAssetID;

	public ovrAvatarPBSMaterialState materialState;

	public ovrAvatarSkinnedMeshPose skinnedPose;
}
public enum ovrAvatarHandGesture
{
	Default,
	GripSphere,
	GripCube,
	Count
}
public enum ovrAvatarBodyPartType
{
	Body,
	Clothing,
	Eyewear,
	Hair,
	Beard,
	Count
}
public struct ovrAvatarBlendShapeParams
{
	public uint blendShapeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
	public float[] blendShapeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarBlendShapeParams_Offsets
{
	public static int blendShapeParamCount = Marshal.OffsetOf(typeof(ovrAvatarBlendShapeParams), "blendShapeParamCount").ToInt32();

	public static long blendShapeParams = Marshal.SizeOf(typeof(uint));
}
public struct ovrAvatarVisemes
{
	public uint visemeParamCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
	public float[] visemeParams;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarVisemes_Offsets
{
	public static int visemeParamCount = Marshal.OffsetOf(typeof(ovrAvatarVisemes), "visemeParamCount").ToInt32();

	public static long visemeParams = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarGazeTargetType
{
	AvatarHead,
	AvatarHand,
	Object,
	ObjectStatic,
	Count
}
public struct ovrAvatarGazeTarget
{
	public uint id;

	public Vector3 worldPosition;

	public ovrAvatarGazeTargetType type;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTarget_Offsets
{
	public static int id = 0;

	public static int worldPosition = Marshal.SizeOf(typeof(uint));

	public static int type = worldPosition + Marshal.SizeOf(typeof(Vector3));
}
public struct ovrAvatarGazeTargets
{
	public uint targetCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
	public ovrAvatarGazeTarget[] targets;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarGazeTargets_Offsets
{
	public static int targetCount = Marshal.OffsetOf(typeof(ovrAvatarGazeTargets), "targetCount").ToInt32();

	public static long targets = Marshal.SizeOf(typeof(uint));
}
public enum ovrAvatarLightType
{
	Point,
	Direction,
	Spot,
	Count
}
public struct ovrAvatarLight
{
	public uint id;

	public ovrAvatarLightType type;

	public float intensity;

	public Vector3 worldDirection;

	public Vector3 worldPosition;

	public float range;

	public float spotAngleDeg;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLight_Offsets
{
	public static long id = Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64();

	public static long type = Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64();

	public static long intensity = Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64();

	public static long worldDirection = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64();

	public static long worldPosition = Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64();

	public static long range = Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64();

	public static long spotAngleDeg = Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64();
}
public struct ovrAvatarLights
{
	public float ambientIntensity;

	public uint lightCount;

	[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
	public ovrAvatarLight[] lights;
}
[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct ovrAvatarLights_Offsets
{
	public static long ambientIntensity = Marshal.OffsetOf(typeof(ovrAvatarLights), "ambientIntensity").ToInt64();

	public static long lightCount = Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64();

	public static long lights = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
}
[Flags]
public enum ovrAvatarDebugContext : uint
{
	None = 0u,
	GazeTarget = 1u,
	Any = uint.MaxValue
}
public struct ovrAvatarDebugLine
{
	public Vector3 startPoint;

	public Vector3 endPoint;

	public Vector3 color;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public struct ovrAvatarDebugTransform
{
	public ovrAvatarTransform transform;

	public ovrAvatarDebugContext context;

	public IntPtr text;
}
public delegate void specificationCallback(IntPtr specification);
public delegate void assetLoadedCallback(OvrAvatarAsset asset);
public delegate void combinedMeshLoadedCallback(IntPtr asset);
public class OvrAvatarSDKManager : MonoBehaviour
{
	public struct AvatarSpecRequestParams
	{
		public ulong _userId;

		public specificationCallback _callback;

		public bool _useCombinedMesh;

		public ovrAvatarAssetLevelOfDetail _lod;

		public bool _forceMobileTextureFormat;

		public ovrAvatarLookAndFeelVersion _lookVersion;

		public ovrAvatarLookAndFeelVersion _fallbackVersion;

		public bool _enableExpressive;

		public AvatarSpecRequestParams(ulong userId, specificationCallback callback, bool useCombinedMesh, ovrAvatarAssetLevelOfDetail lod, bool forceMobileTextureFormat, ovrAvatarLookAndFeelVersion lookVersion, ovrAvatarLookAndFeelVersion fallbackVersion, bool enableExpressive)
		{
			_userId = userId;
			_callback = callback;
			_useCombinedMesh = useCombinedMesh;
			_lod = lod;
			_forceMobileTextureFormat = forceMobileTextureFormat;
			_lookVersion = lookVersion;
			_fallbackVersion = fallbackVersion;
			_enableExpressive = enableExpressive;
		}
	}

	private static OvrAvatarSDKManager _instance;

	private bool initialized;

	private Dictionary<ulong, HashSet<specificationCallback>> specificationCallbacks;

	private Dictionary<ulong, HashSet<assetLoadedCallback>> assetLoadedCallbacks;

	private Dictionary<IntPtr, combinedMeshLoadedCallback> combinedMeshLoadedCallbacks;

	private Dictionary<ulong, OvrAvatarAsset> assetCache;

	private OvrAvatarTextureCopyManager textureCopyManager;

	public ovrAvatarLogLevel LoggingLevel = ovrAvatarLogLevel.Info;

	private Queue<AvatarSpecRequestParams> avatarSpecificationQueue;

	private List<int> loadingAvatars;

	private bool avatarSpecRequestAvailable = true;

	private float lastDispatchedAvatarSpecRequestTime;

	private const float AVATAR_SPEC_REQUEST_TIMEOUT = 5f;

	public static OvrAvatarSDKManager Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = UnityEngine.Object.FindObjectOfType<OvrAvatarSDKManager>();
				if (_instance == null)
				{
					GameObject gameObject = new GameObject("OvrAvatarSDKManager");
					_instance = gameObject.AddComponent<OvrAvatarSDKManager>();
					_instance.textureCopyManager = gameObject.AddComponent<OvrAvatarTextureCopyManager>();
					_instance.initialized = _instance.Initialize();
				}
			}
			if (!_instance.initialized)
			{
				return null;
			}
			return _instance;
		}
	}

	private bool Initialize()
	{
		Oculus.Avatar.CAPI.Initialize();
		string text = GetAppId();
		if (text == "")
		{
			text = "0";
		}
		Oculus.Avatar.CAPI.ovrAvatar_InitializeAndroidUnity(text);
		specificationCallbacks = new Dictionary<ulong, HashSet<specificationCallback>>();
		assetLoadedCallbacks = new Dictionary<ulong, HashSet<assetLoadedCallback>>();
		combinedMeshLoadedCallbacks = new Dictionary<IntPtr, combinedMeshLoadedCallback>();
		assetCache = new Dictionary<ulong, OvrAvatarAsset>();
		avatarSpecificationQueue = new Queue<AvatarSpecRequestParams>();
		loadingAvatars = new List<int>();
		Oculus.Avatar.CAPI.ovrAvatar_SetLoggingLevel(LoggingLevel);
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(Oculus.Avatar.CAPI.LoggingCallback);
		return true;
	}

	private void OnDestroy()
	{
		Oculus.Avatar.CAPI.Shutdown();
		Oculus.Avatar.CAPI.ovrAvatar_RegisterLoggingCallback(null);
		Oculus.Avatar.CAPI.ovrAvatar_Shutdown();
	}

	private void Update()
	{
		if (Instance == null)
		{
			return;
		}
		if (avatarSpecificationQueue.Count > 0 && (avatarSpecRequestAvailable || Time.time - lastDispatchedAvatarSpecRequestTime >= 5f))
		{
			avatarSpecRequestAvailable = false;
			AvatarSpecRequestParams avatarSpecRequest = avatarSpecificationQueue.Dequeue();
			DispatchAvatarSpecificationRequest(avatarSpecRequest);
			lastDispatchedAvatarSpecRequestTime = Time.time;
		}
		IntPtr intPtr = Oculus.Avatar.CAPI.ovrAvatarMessage_Pop();
		if (intPtr == IntPtr.Zero)
		{
			return;
		}
		ovrAvatarMessageType ovrAvatarMessageType2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetType(intPtr);
		switch (ovrAvatarMessageType2)
		{
		case ovrAvatarMessageType.AssetLoaded:
		{
			ovrAvatarMessage_AssetLoaded ovrAvatarMessage_AssetLoaded2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAssetLoaded(intPtr);
			IntPtr asset = ovrAvatarMessage_AssetLoaded2.asset;
			ulong assetID = ovrAvatarMessage_AssetLoaded2.assetID;
			ovrAvatarAssetType ovrAvatarAssetType2 = Oculus.Avatar.CAPI.ovrAvatarAsset_GetType(asset);
			OvrAvatarAsset ovrAvatarAsset = null;
			IntPtr key = IntPtr.Zero;
			switch (ovrAvatarAssetType2)
			{
			case ovrAvatarAssetType.Mesh:
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.Mesh);
				break;
			case ovrAvatarAssetType.Texture:
				ovrAvatarAsset = new OvrAvatarAssetTexture(assetID, asset);
				break;
			case ovrAvatarAssetType.Material:
				ovrAvatarAsset = new OvrAvatarAssetMaterial(assetID, asset);
				break;
			case ovrAvatarAssetType.CombinedMesh:
				key = Oculus.Avatar.CAPI.ovrAvatarAsset_GetAvatar(asset);
				ovrAvatarAsset = new OvrAvatarAssetMesh(assetID, asset, ovrAvatarAssetType.CombinedMesh);
				break;
			default:
				throw new NotImplementedException($"Unsupported asset type format {ovrAvatarAssetType2.ToString()}");
			case ovrAvatarAssetType.FailedLoad:
				break;
			}
			if (ovrAvatarAssetType2 == ovrAvatarAssetType.CombinedMesh)
			{
				if (!assetCache.ContainsKey(assetID))
				{
					assetCache.Add(assetID, ovrAvatarAsset);
				}
				if (combinedMeshLoadedCallbacks.TryGetValue(key, out var value2))
				{
					value2(asset);
					combinedMeshLoadedCallbacks.Remove(key);
				}
			}
			else
			{
				if (ovrAvatarAsset == null || !assetLoadedCallbacks.TryGetValue(ovrAvatarMessage_AssetLoaded2.assetID, out var value3))
				{
					break;
				}
				assetCache.Add(assetID, ovrAvatarAsset);
				foreach (assetLoadedCallback item in value3)
				{
					item(ovrAvatarAsset);
				}
				assetLoadedCallbacks.Remove(ovrAvatarMessage_AssetLoaded2.assetID);
			}
			break;
		}
		case ovrAvatarMessageType.AvatarSpecification:
		{
			avatarSpecRequestAvailable = true;
			ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_AvatarSpecification2 = Oculus.Avatar.CAPI.ovrAvatarMessage_GetAvatarSpecification(intPtr);
			if (!specificationCallbacks.TryGetValue(ovrAvatarMessage_AvatarSpecification2.oculusUserID, out var value))
			{
				break;
			}
			foreach (specificationCallback item2 in value)
			{
				item2(ovrAvatarMessage_AvatarSpecification2.avatarSpec);
			}
			specificationCallbacks.Remove(ovrAvatarMessage_AvatarSpecification2.oculusUserID);
			break;
		}
		default:
			throw new NotImplementedException("Unhandled ovrAvatarMessageType: " + ovrAvatarMessageType2);
		}
		Oculus.Avatar.CAPI.ovrAvatarMessage_Free(intPtr);
	}

	public bool IsAvatarSpecWaiting()
	{
		return avatarSpecificationQueue.Count > 0;
	}

	public bool IsAvatarLoading()
	{
		return loadingAvatars.Count > 0;
	}

	public void AddLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Add(gameobjectID);
	}

	public void RemoveLoadingAvatar(int gameobjectID)
	{
		loadingAvatars.Remove(gameobjectID);
	}

	public void RequestAvatarSpecification(AvatarSpecRequestParams avatarSpecRequest)
	{
		avatarSpecificationQueue.Enqueue(avatarSpecRequest);
	}

	private void DispatchAvatarSpecificationRequest(AvatarSpecRequestParams avatarSpecRequest)
	{
		textureCopyManager.CheckFallbackTextureSet(avatarSpecRequest._lod);
		Oculus.Avatar.CAPI.ovrAvatar_SetForceASTCTextures(avatarSpecRequest._forceMobileTextureFormat);
		if (!specificationCallbacks.TryGetValue(avatarSpecRequest._userId, out var value))
		{
			value = new HashSet<specificationCallback>();
			specificationCallbacks.Add(avatarSpecRequest._userId, value);
			IntPtr specificationRequest = Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Create(avatarSpecRequest._userId);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLookAndFeelVersion(specificationRequest, avatarSpecRequest._lookVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(specificationRequest, avatarSpecRequest._fallbackVersion);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetLevelOfDetail(specificationRequest, avatarSpecRequest._lod);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetCombineMeshes(specificationRequest, avatarSpecRequest._useCombinedMesh);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_SetExpressiveFlag(specificationRequest, avatarSpecRequest._enableExpressive);
			Oculus.Avatar.CAPI.ovrAvatar_RequestAvatarSpecificationFromSpecRequest(specificationRequest);
			Oculus.Avatar.CAPI.ovrAvatarSpecificationRequest_Destroy(specificationRequest);
		}
		value.Add(avatarSpecRequest._callback);
	}

	public void BeginLoadingAsset(ulong assetId, ovrAvatarAssetLevelOfDetail lod, assetLoadedCallback callback)
	{
		if (!assetLoadedCallbacks.TryGetValue(assetId, out var value))
		{
			value = new HashSet<assetLoadedCallback>();
			assetLoadedCallbacks.Add(assetId, value);
		}
		Oculus.Avatar.CAPI.ovrAvatarAsset_BeginLoadingLOD(assetId, lod);
		value.Add(callback);
	}

	public void RegisterCombinedMeshCallback(IntPtr sdkAvatar, combinedMeshLoadedCallback callback)
	{
		if (!combinedMeshLoadedCallbacks.TryGetValue(sdkAvatar, out var _))
		{
			combinedMeshLoadedCallbacks.Add(sdkAvatar, callback);
			return;
		}
		throw new Exception("Adding second combind mesh callback for same avatar");
	}

	public OvrAvatarAsset GetAsset(ulong assetId)
	{
		if (assetCache.TryGetValue(assetId, out var value))
		{
			return value;
		}
		return null;
	}

	public void DeleteAssetFromCache(ulong assetId)
	{
		if (assetCache.ContainsKey(assetId))
		{
			assetCache.Remove(assetId);
		}
	}

	public string GetAppId()
	{
		if (UnityEngine.Application.platform != RuntimePlatform.Android)
		{
			return OvrAvatarSettings.AppID;
		}
		return OvrAvatarSettings.MobileAppID;
	}

	public OvrAvatarTextureCopyManager GetTextureCopyManager()
	{
		if (textureCopyManager != null)
		{
			return textureCopyManager;
		}
		return null;
	}
}
public sealed class OvrAvatarSettings : ScriptableObject
{
	private static OvrAvatarSettings instance;

	[SerializeField]
	private string ovrAppID = "";

	[SerializeField]
	private string ovrGearAppID = "";

	public static string AppID
	{
		get
		{
			return Instance.ovrAppID;
		}
		set
		{
			Instance.ovrAppID = value;
		}
	}

	public static string MobileAppID
	{
		get
		{
			return Instance.ovrGearAppID;
		}
		set
		{
			Instance.ovrGearAppID = value;
		}
	}

	public static OvrAvatarSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<OvrAvatarSettings>("OvrAvatarSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<OvrAvatarSettings>();
				}
			}
			return instance;
		}
		set
		{
			instance = value;
		}
	}
}
public class OvrAvatarSkinnedMeshRenderComponent : OvrAvatarRenderComponent
{
	private Shader surface;

	private Shader surfaceSelfOccluding;

	private bool previouslyActive;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRender skinnedMeshRender, Shader surface, Shader surfaceSelfOccluding, int thirdPersonLayer, int firstPersonLayer)
	{
		this.surfaceSelfOccluding = ((surfaceSelfOccluding != null) ? surfaceSelfOccluding : Shader.Find("OvrAvatar/AvatarSurfaceShaderSelfOccluding"));
		this.surface = ((surface != null) ? surface : Shader.Find("OvrAvatar/AvatarSurfaceShader"));
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		bones = mesh.bones;
		UpdateMeshMaterial(skinnedMeshRender.visibilityMask, mesh);
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		UpdateMeshMaterial(visibilityMask, mesh);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && (Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_MaterialStateChanged(renderPart) || (!previouslyActive && activeSelf)))
		{
			ovrAvatarMaterialState matState = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetMaterialState(renderPart);
			component.UpdateAvatarMaterial(mesh.sharedMaterial, matState);
		}
		previouslyActive = activeSelf;
	}

	private void UpdateMeshMaterial(ovrAvatarVisibilityFlags visibilityMask, SkinnedMeshRenderer rootMesh)
	{
		Shader shader = (((visibilityMask & ovrAvatarVisibilityFlags.SelfOccluding) != 0) ? surfaceSelfOccluding : surface);
		if (rootMesh.sharedMaterial == null || rootMesh.sharedMaterial.shader != shader)
		{
			rootMesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		}
	}
}
public class OvrAvatarSkinnedMeshRenderPBSComponent : OvrAvatarRenderComponent
{
	private bool isMaterialInitilized;

	internal void Initialize(ovrAvatarRenderPart_SkinnedMeshRenderPBS skinnedMeshRenderPBS, Shader shader, int thirdPersonLayer, int firstPersonLayer)
	{
		if (shader == null)
		{
			shader = Shader.Find("OvrAvatar/AvatarSurfaceShaderPBS");
		}
		mesh = CreateSkinnedMesh(skinnedMeshRenderPBS.meshAssetID, skinnedMeshRenderPBS.visibilityMask, thirdPersonLayer, firstPersonLayer);
		mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader);
		bones = mesh.bones;
	}

	internal void UpdateSkinnedMeshRenderPBS(OvrAvatar avatar, IntPtr renderPart, Material mat)
	{
		if (!isMaterialInitilized)
		{
			isMaterialInitilized = true;
			ulong assetId = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(renderPart);
			ulong assetId2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(renderPart);
			mat.SetTexture("_Albedo", OvrAvatarComponent.GetLoadedTexture(assetId));
			mat.SetTexture("_Surface", OvrAvatarComponent.GetLoadedTexture(assetId2));
		}
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBS_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
	}
}
public class OvrAvatarSkinnedMeshPBSV2RenderComponent : OvrAvatarRenderComponent
{
	private OvrAvatarMaterialManager avatarMaterialManager;

	private bool previouslyActive;

	private bool isCombinedMaterial;

	private ovrAvatarExpressiveParameters ExpressiveParameters;

	private bool EnableExpressive;

	private int blendShapeCount;

	private ovrAvatarBlendShapeParams blendShapeParams;

	private const string MAIN_MATERIAL_NAME = "main_material";

	private const string EYE_MATERIAL_NAME = "eye_material";

	private const string DEFAULT_MATERIAL_NAME = "_material";

	internal void Initialize(IntPtr renderPart, ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 skinnedMeshRender, OvrAvatarMaterialManager materialManager, int thirdPersonLayer, int firstPersonLayer, bool combinedMesh, ovrAvatarAssetLevelOfDetail lod, bool assignExpressiveParams, OvrAvatar avatar, bool isControllerModel)
	{
		avatarMaterialManager = materialManager;
		isCombinedMaterial = combinedMesh;
		mesh = CreateSkinnedMesh(skinnedMeshRender.meshAssetID, skinnedMeshRender.visibilityMask, thirdPersonLayer, firstPersonLayer);
		EnableExpressive = assignExpressiveParams;
		Shader shader = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_SingleComponent : avatar.Skinshaded_VertFrag_SingleComponent);
		Shader shader2 = (EnableExpressive ? avatar.Skinshaded_Expressive_VertFrag_CombinedMesh : avatar.Skinshaded_VertFrag_CombinedMesh);
		Shader shader3 = (isCombinedMaterial ? shader2 : shader);
		if (isControllerModel)
		{
			shader3 = avatar.ControllerShader;
		}
		if (EnableExpressive)
		{
			ExpressiveParameters = Oculus.Avatar.CAPI.ovrAvatar_GetExpressiveParameters(avatar.sdkAvatar);
			Shader eyeLens = avatar.EyeLens;
			Material[] array = new Material[2]
			{
				CreateAvatarMaterial(base.gameObject.name + "main_material", shader3),
				CreateAvatarMaterial(base.gameObject.name + "eye_material", eyeLens)
			};
			if (avatar.UseTransparentRenderQueue)
			{
				SetMaterialTransparent(array[0]);
			}
			else
			{
				SetMaterialOpaque(array[0]);
			}
			array[1].renderQueue = -1;
			mesh.materials = array;
		}
		else
		{
			mesh.sharedMaterial = CreateAvatarMaterial(base.gameObject.name + "_material", shader3);
			if (avatar.UseTransparentRenderQueue && !isControllerModel)
			{
				SetMaterialTransparent(mesh.sharedMaterial);
			}
			else
			{
				SetMaterialOpaque(mesh.sharedMaterial);
			}
		}
		bones = mesh.bones;
		if (isCombinedMaterial)
		{
			avatarMaterialManager.SetRenderer(mesh);
			InitializeCombinedMaterial(renderPart, (int)lod);
			avatarMaterialManager.OnCombinedMeshReady();
		}
		blendShapeParams = default(ovrAvatarBlendShapeParams);
		blendShapeParams.blendShapeParamCount = 0u;
		blendShapeParams.blendShapeParams = new float[64];
		blendShapeCount = mesh.sharedMesh.blendShapeCount;
	}

	public void UpdateSkinnedMeshRender(OvrAvatarComponent component, OvrAvatar avatar, IntPtr renderPart)
	{
		ovrAvatarVisibilityFlags visibilityMask = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(renderPart);
		ovrAvatarTransform localTransform = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(renderPart);
		UpdateSkinnedMesh(avatar, bones, localTransform, visibilityMask, renderPart);
		bool activeSelf = base.gameObject.activeSelf;
		if (mesh != null && !previouslyActive && activeSelf && !isCombinedMaterial)
		{
			InitializeSingleComponentMaterial(renderPart, (int)(avatar.LevelOfDetail - 1));
		}
		if (blendShapeCount > 0)
		{
			Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRender_GetBlendShapeParams(renderPart, ref blendShapeParams);
			for (uint num = 0u; num < blendShapeParams.blendShapeParamCount && num < blendShapeCount; num++)
			{
				float num2 = blendShapeParams.blendShapeParams[num];
				mesh.SetBlendShapeWeight((int)num, num2 * 100f);
			}
		}
		previouslyActive = activeSelf;
	}

	private void InitializeSingleComponentMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState ovrAvatarPBSMaterialState2 = Oculus.Avatar.CAPI.ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(renderPart);
		int componentType = (int)OvrAvatarMaterialManager.GetComponentType(base.gameObject.name);
		Texture2D texture2D = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.albedoTextureID);
		Texture2D texture2D2 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.normalTextureID);
		Texture2D texture2D3 = OvrAvatarComponent.GetLoadedTexture(ovrAvatarPBSMaterialState2.metallicnessTextureID);
		if (texture2D != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.albedoTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D.anisoLevel = 4;
		if (texture2D2 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.normalTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D2 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
		}
		texture2D2.anisoLevel = 4;
		if (texture2D3 != null)
		{
			avatarMaterialManager.AddTextureIDToTextureManager(ovrAvatarPBSMaterialState2.metallicnessTextureID, isSingleComponent: true);
		}
		else
		{
			texture2D3 = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
		}
		texture2D3.anisoLevel = 16;
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_MAINTEX, texture2D);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_NORMALMAP, texture2D2);
		mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_ROUGHNESSMAP, texture2D3);
		mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_COLOR, ovrAvatarPBSMaterialState2.albedoMultiplier);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_DIFFUSEINTENSITY, OvrAvatarMaterialManager.DiffuseIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_RIMINTENSITY, OvrAvatarMaterialManager.RimIntensities[componentType]);
		mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_REFLECTIONINTENSITY, OvrAvatarMaterialManager.ReflectionIntensities[componentType]);
		mesh.GetClosestReflectionProbes(avatarMaterialManager.ReflectionProbes);
		if (avatarMaterialManager.ReflectionProbes != null && avatarMaterialManager.ReflectionProbes.Count > 0)
		{
			mesh.materials[0].SetTexture(OvrAvatarMaterialManager.AVATAR_SHADER_CUBEMAP, avatarMaterialManager.ReflectionProbes[0].probe.texture);
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
	}

	private void InitializeCombinedMaterial(IntPtr renderPart, int lodIndex)
	{
		ovrAvatarPBSMaterialState[] array = Oculus.Avatar.CAPI.ovrAvatar_GetBodyPBSMaterialStates(renderPart);
		if (array.Length != 5)
		{
			return;
		}
		avatarMaterialManager.CreateTextureArrays();
		OvrAvatarMaterialManager.AvatarComponentMaterialProperties[] componentMaterialProperties = avatarMaterialManager.LocalAvatarConfig.ComponentMaterialProperties;
		for (int i = 0; i < array.Length; i++)
		{
			componentMaterialProperties[i].TypeIndex = (ovrAvatarBodyPartType)i;
			componentMaterialProperties[i].Color = array[i].albedoMultiplier;
			componentMaterialProperties[i].DiffuseIntensity = OvrAvatarMaterialManager.DiffuseIntensities[i];
			componentMaterialProperties[i].RimIntensity = OvrAvatarMaterialManager.RimIntensities[i];
			componentMaterialProperties[i].ReflectionIntensity = OvrAvatarMaterialManager.ReflectionIntensities[i];
			Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(array[i].albedoTextureID);
			Texture2D loadedTexture2 = OvrAvatarComponent.GetLoadedTexture(array[i].normalTextureID);
			Texture2D loadedTexture3 = OvrAvatarComponent.GetLoadedTexture(array[i].metallicnessTextureID);
			if (loadedTexture != null)
			{
				componentMaterialProperties[i].Textures[0] = loadedTexture;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].albedoTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[0] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[0].anisoLevel = 4;
			if (loadedTexture2 != null)
			{
				componentMaterialProperties[i].Textures[1] = loadedTexture2;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].normalTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[1] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].Normal;
			}
			componentMaterialProperties[i].Textures[1].anisoLevel = 4;
			if (loadedTexture3 != null)
			{
				componentMaterialProperties[i].Textures[2] = loadedTexture3;
				avatarMaterialManager.AddTextureIDToTextureManager(array[i].metallicnessTextureID, isSingleComponent: false);
			}
			else
			{
				componentMaterialProperties[i].Textures[2] = OvrAvatarSDKManager.Instance.GetTextureCopyManager().FallbackTextureSets[lodIndex].DiffuseRoughness;
			}
			componentMaterialProperties[i].Textures[2].anisoLevel = 16;
		}
		if (EnableExpressive)
		{
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_IRIS_COLOR, ExpressiveParameters.irisColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_COLOR, ExpressiveParameters.lipColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_BROW_COLOR, ExpressiveParameters.browColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_LASH_COLOR, ExpressiveParameters.lashColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_SCLERA_COLOR, ExpressiveParameters.scleraColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_GUM_COLOR, ExpressiveParameters.gumColor);
			mesh.materials[0].SetVector(OvrAvatarMaterialManager.AVATAR_SHADER_TEETH_COLOR, ExpressiveParameters.teethColor);
			mesh.materials[0].SetFloat(OvrAvatarMaterialManager.AVATAR_SHADER_LIP_SMOOTHNESS, ExpressiveParameters.lipSmoothness);
		}
		avatarMaterialManager.ValidateTextures(array);
	}

	private void SetMaterialTransparent(Material mat)
	{
		mat.SetOverrideTag("Queue", "Transparent");
		mat.SetOverrideTag("RenderType", "Transparent");
		mat.SetInt("_SrcBlend", 5);
		mat.SetInt("_DstBlend", 10);
		mat.EnableKeyword("_ALPHATEST_ON");
		mat.EnableKeyword("_ALPHABLEND_ON");
		mat.EnableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 3000;
	}

	private void SetMaterialOpaque(Material mat)
	{
		mat.SetOverrideTag("Queue", "Geometry");
		mat.SetOverrideTag("RenderType", "Opaque");
		mat.SetInt("_SrcBlend", 1);
		mat.SetInt("_DstBlend", 0);
		mat.DisableKeyword("_ALPHATEST_ON");
		mat.DisableKeyword("_ALPHABLEND_ON");
		mat.DisableKeyword("_ALPHAPREMULTIPLY_ON");
		mat.renderQueue = 2000;
	}
}
public class OvrAvatarTextureCopyManager : MonoBehaviour
{
	[Serializable]
	public struct FallbackTextureSet
	{
		public bool Initialized;

		public Texture2D DiffuseRoughness;

		public Texture2D Normal;
	}

	private struct CopyTextureParams
	{
		public Texture Src;

		public Texture Dst;

		public int Mip;

		public int SrcSize;

		public int DstElement;

		public CopyTextureParams(Texture src, Texture dst, int mip, int srcSize, int dstElement)
		{
			Src = src;
			Dst = dst;
			Mip = mip;
			SrcSize = srcSize;
			DstElement = dstElement;
		}
	}

	public struct TextureSet
	{
		public Dictionary<ulong, bool> TextureIDSingleMeshPair;

		public bool IsProcessed;

		public TextureSet(Dictionary<ulong, bool> textureIDSingleMeshPair, bool isProcessed)
		{
			TextureIDSingleMeshPair = textureIDSingleMeshPair;
			IsProcessed = isProcessed;
		}
	}

	public FallbackTextureSet[] FallbackTextureSets = new FallbackTextureSet[6];

	private Queue<CopyTextureParams> texturesToCopy;

	private Dictionary<int, TextureSet> textureSets;

	private const int TEXTURES_TO_COPY_QUEUE_CAPACITY = 256;

	private const int COPIES_PER_FRAME = 8;

	private readonly string[] FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS = new string[6] { "null", "FallbackTextures/fallback_diffuse_roughness_256", "null", "FallbackTextures/fallback_diffuse_roughness_1024", "null", "FallbackTextures/fallback_diffuse_roughness_2048" };

	private readonly string[] FALLBACK_TEXTURE_PATHS_NORMAL = new string[6] { "null", "FallbackTextures/fallback_normal_256", "null", "FallbackTextures/fallback_normal_1024", "null", "FallbackTextures/fallback_normal_2048" };

	private const string PATH_HIGHEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_2048";

	private const string PATH_MEDIUM_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_1024";

	private const string PATH_LOWEST_DIFFUSE_ROUGHNESS = "FallbackTextures/fallback_diffuse_roughness_256";

	private const string PATH_HIGHEST_NORMAL = "FallbackTextures/fallback_normal_2048";

	private const string PATH_MEDIUM_NORMAL = "FallbackTextures/fallback_normal_1024";

	private const string PATH_LOWEST_NORMAL = "FallbackTextures/fallback_normal_256";

	private const int GPU_TEXTURE_COPY_WAIT_TIME = 10;

	public OvrAvatarTextureCopyManager()
	{
		texturesToCopy = new Queue<CopyTextureParams>(256);
		textureSets = new Dictionary<int, TextureSet>();
	}

	public void Update()
	{
		if (texturesToCopy.Count == 0)
		{
			return;
		}
		lock (texturesToCopy)
		{
			for (int i = 0; i < Mathf.Min(8, texturesToCopy.Count); i++)
			{
				CopyTexture(texturesToCopy.Dequeue());
			}
		}
	}

	public int GetTextureCount()
	{
		return texturesToCopy.Count;
	}

	public void CopyTexture(Texture src, Texture dst, int mipLevel, int mipSize, int dstElement, bool useQueue = true)
	{
		CopyTextureParams copyTextureParams = new CopyTextureParams(src, dst, mipLevel, mipSize, dstElement);
		if (useQueue)
		{
			lock (texturesToCopy)
			{
				if (texturesToCopy.Count < 256)
				{
					texturesToCopy.Enqueue(copyTextureParams);
				}
				else
				{
					CopyTexture(copyTextureParams);
				}
				return;
			}
		}
		CopyTexture(copyTextureParams);
	}

	private void CopyTexture(CopyTextureParams copyTextureParams)
	{
		Graphics.CopyTexture(copyTextureParams.Src, 0, copyTextureParams.Mip, copyTextureParams.Dst, copyTextureParams.DstElement, copyTextureParams.Mip);
	}

	public void AddTextureIDToTextureSet(int gameobjectID, ulong textureID, bool isSingleMesh)
	{
		bool value2;
		if (!textureSets.ContainsKey(gameobjectID))
		{
			TextureSet value = new TextureSet(new Dictionary<ulong, bool>(), isProcessed: false);
			value.TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
			textureSets.Add(gameobjectID, value);
		}
		else if (textureSets[gameobjectID].TextureIDSingleMeshPair.TryGetValue(textureID, out value2))
		{
			if (!value2 && isSingleMesh)
			{
				textureSets[gameobjectID].TextureIDSingleMeshPair[textureID] = true;
			}
		}
		else
		{
			textureSets[gameobjectID].TextureIDSingleMeshPair.Add(textureID, isSingleMesh);
		}
	}

	public void DeleteTextureSet(int gameobjectID)
	{
		if (textureSets.TryGetValue(gameobjectID, out var value) && !value.IsProcessed)
		{
			StartCoroutine(DeleteTextureSetCoroutine(value, gameobjectID));
		}
	}

	private IEnumerator DeleteTextureSetCoroutine(TextureSet textureSetToDelete, int gameobjectID)
	{
		yield return new WaitForSeconds(10f);
		while (OvrAvatarSDKManager.Instance.IsAvatarLoading())
		{
			yield return null;
		}
		foreach (KeyValuePair<ulong, bool> item in textureSetToDelete.TextureIDSingleMeshPair)
		{
			bool flag = !item.Value;
			if (flag)
			{
				foreach (KeyValuePair<int, TextureSet> textureSet in textureSets)
				{
					if (textureSet.Key == gameobjectID)
					{
						continue;
					}
					foreach (KeyValuePair<ulong, bool> item2 in textureSet.Value.TextureIDSingleMeshPair)
					{
						if (item2.Key == item.Key && (!textureSet.Value.IsProcessed || item2.Value))
						{
							flag = false;
							break;
						}
					}
					if (!flag)
					{
						break;
					}
				}
			}
			if (flag)
			{
				Texture2D loadedTexture = OvrAvatarComponent.GetLoadedTexture(item.Key);
				if (loadedTexture != null)
				{
					OvrAvatarSDKManager.Instance.DeleteAssetFromCache(item.Key);
					UnityEngine.Object.Destroy(loadedTexture);
				}
			}
		}
		textureSetToDelete.IsProcessed = true;
		textureSets.Remove(gameobjectID);
	}

	public void CheckFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		if (!FallbackTextureSets[(int)lod].Initialized)
		{
			InitFallbackTextureSet(lod);
		}
	}

	private void InitFallbackTextureSet(ovrAvatarAssetLevelOfDetail lod)
	{
		FallbackTextureSets[(int)lod].DiffuseRoughness = (FallbackTextureSets[(int)lod].DiffuseRoughness = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_DIFFUSE_ROUGHNESS[(int)lod]));
		FallbackTextureSets[(int)lod].Normal = (FallbackTextureSets[(int)lod].Normal = Resources.Load<Texture2D>(FALLBACK_TEXTURE_PATHS_NORMAL[(int)lod]));
		FallbackTextureSets[(int)lod].Initialized = true;
	}
}
public class OvrAvatarTouchController : OvrAvatarComponent
{
	public bool isLeftHand = true;

	private ovrAvatarControllerComponent component;

	private void Update()
	{
		if (owner == null)
		{
			return;
		}
		bool flag = false;
		if ((!isLeftHand) ? Oculus.Avatar.CAPI.ovrAvatarPose_GetRightControllerComponent(owner.sdkAvatar, ref component) : Oculus.Avatar.CAPI.ovrAvatarPose_GetLeftControllerComponent(owner.sdkAvatar, ref component))
		{
			UpdateAvatar(component.renderComponent);
			return;
		}
		if (isLeftHand)
		{
			owner.ControllerLeft = null;
		}
		else
		{
			owner.ControllerRight = null;
		}
		UnityEngine.Object.Destroy(this);
	}
}
public class DebugUIBuilder : MonoBehaviour
{
	public delegate void OnClick();

	public delegate void OnToggleValueChange(Toggle t);

	public delegate void OnSlider(float f);

	public delegate bool ActiveUpdate();

	public const int DEBUG_PANE_CENTER = 0;

	public const int DEBUG_PANE_RIGHT = 1;

	public const int DEBUG_PANE_LEFT = 2;

	[SerializeField]
	private RectTransform buttonPrefab;

	[SerializeField]
	private RectTransform labelPrefab;

	[SerializeField]
	private RectTransform sliderPrefab;

	[SerializeField]
	private RectTransform dividerPrefab;

	[SerializeField]
	private RectTransform togglePrefab;

	[SerializeField]
	private RectTransform radioPrefab;

	[SerializeField]
	private RectTransform textPrefab;

	[SerializeField]
	private GameObject uiHelpersToInstantiate;

	[SerializeField]
	private Transform[] targetContentPanels;

	private bool[] reEnable;

	[SerializeField]
	private List<GameObject> toEnable;

	[SerializeField]
	private List<GameObject> toDisable;

	public static DebugUIBuilder instance;

	private const float elementSpacing = 16f;

	private const float marginH = 16f;

	private const float marginV = 16f;

	private Vector2[] insertPositions;

	private List<RectTransform>[] insertedElements;

	private Vector3 menuOffset;

	private OVRCameraRig rig;

	private Dictionary<string, ToggleGroup> radioGroups = new Dictionary<string, ToggleGroup>();

	private LaserPointer lp;

	private LineRenderer lr;

	public LaserPointer.LaserBeamBehavior laserBeamBehavior;

	public void Awake()
	{
		instance = this;
		menuOffset = base.transform.position;
		base.gameObject.SetActive(value: false);
		rig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		for (int i = 0; i < toEnable.Count; i++)
		{
			toEnable[i].SetActive(value: false);
		}
		insertPositions = new Vector2[targetContentPanels.Length];
		for (int j = 0; j < insertPositions.Length; j++)
		{
			insertPositions[j].x = 16f;
			insertPositions[j].y = -16f;
		}
		insertedElements = new List<RectTransform>[targetContentPanels.Length];
		for (int k = 0; k < insertedElements.Length; k++)
		{
			insertedElements[k] = new List<RectTransform>();
		}
		if ((bool)uiHelpersToInstantiate)
		{
			UnityEngine.Object.Instantiate(uiHelpersToInstantiate);
		}
		lp = UnityEngine.Object.FindObjectOfType<LaserPointer>();
		if (!lp)
		{
			UnityEngine.Debug.LogError("Debug UI requires use of a LaserPointer and will not function without it. Add one to your scene, or assign the UIHelpers prefab to the DebugUIBuilder in the inspector.");
			return;
		}
		lp.laserBeamBehavior = laserBeamBehavior;
		if (!toEnable.Contains(lp.gameObject))
		{
			toEnable.Add(lp.gameObject);
		}
		GetComponent<OVRRaycaster>().pointer = lp.gameObject;
		lp.gameObject.SetActive(value: false);
	}

	public void Show()
	{
		Relayout();
		base.gameObject.SetActive(value: true);
		base.transform.position = rig.transform.TransformPoint(menuOffset);
		Vector3 eulerAngles = rig.transform.rotation.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		base.transform.eulerAngles = eulerAngles;
		if (reEnable == null || reEnable.Length < toDisable.Count)
		{
			reEnable = new bool[toDisable.Count];
		}
		reEnable.Initialize();
		int count = toDisable.Count;
		for (int i = 0; i < count; i++)
		{
			if ((bool)toDisable[i])
			{
				reEnable[i] = toDisable[i].activeSelf;
				toDisable[i].SetActive(value: false);
			}
		}
		count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: true);
		}
		int num = targetContentPanels.Length;
		for (int k = 0; k < num; k++)
		{
			targetContentPanels[k].gameObject.SetActive(insertedElements[k].Count > 0);
		}
	}

	public void Hide()
	{
		base.gameObject.SetActive(value: false);
		for (int i = 0; i < reEnable.Length; i++)
		{
			if ((bool)toDisable[i] && reEnable[i])
			{
				toDisable[i].SetActive(value: true);
			}
		}
		int count = toEnable.Count;
		for (int j = 0; j < count; j++)
		{
			toEnable[j].SetActive(value: false);
		}
	}

	private void Relayout()
	{
		for (int i = 0; i < targetContentPanels.Length; i++)
		{
			RectTransform component = targetContentPanels[i].GetComponent<RectTransform>();
			List<RectTransform> list = insertedElements[i];
			int count = list.Count;
			float x = 16f;
			float num = -16f;
			float num2 = 0f;
			for (int j = 0; j < count; j++)
			{
				RectTransform rectTransform = list[j];
				rectTransform.anchoredPosition = new Vector2(x, num);
				num -= rectTransform.rect.height + 16f;
				num2 = Mathf.Max(rectTransform.rect.width + 32f, num2);
			}
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, num2);
			component.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 0f - num + 16f);
		}
	}

	private void AddRect(RectTransform r, int targetCanvas)
	{
		if (targetCanvas > targetContentPanels.Length)
		{
			UnityEngine.Debug.LogError("Attempted to add debug panel to canvas " + targetCanvas + ", but only " + targetContentPanels.Length + " panels were provided. Fix in the inspector or pass a lower value for target canvas.");
		}
		else
		{
			r.transform.SetParent(targetContentPanels[targetCanvas], worldPositionStays: false);
			insertedElements[targetCanvas].Add(r);
			if (base.gameObject.activeInHierarchy)
			{
				Relayout();
			}
		}
	}

	public RectTransform AddButton(string label, OnClick handler, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(buttonPrefab).GetComponent<RectTransform>();
		component.GetComponentInChildren<Button>().onClick.AddListener(delegate
		{
			handler();
		});
		((Text)component.GetComponentsInChildren(typeof(Text), includeInactive: true)[0]).text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddLabel(string label, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(labelPrefab).GetComponent<RectTransform>();
		component.GetComponent<Text>().text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public RectTransform AddSlider(string label, float min, float max, OnSlider onValueChanged, bool wholeNumbersOnly = false, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(sliderPrefab);
		Slider componentInChildren = rectTransform.GetComponentInChildren<Slider>();
		componentInChildren.minValue = min;
		componentInChildren.maxValue = max;
		componentInChildren.onValueChanged.AddListener(delegate(float f)
		{
			onValueChanged(f);
		});
		componentInChildren.wholeNumbers = wholeNumbersOnly;
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddDivider(int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(dividerPrefab);
		AddRect(rectTransform, targetCanvas);
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddToggle(string label, OnToggleValueChange onValueChanged, bool defaultValue, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(togglePrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle t = rectTransform.GetComponentInChildren<Toggle>();
		t.isOn = defaultValue;
		t.onValueChanged.AddListener(delegate
		{
			onValueChanged(t);
		});
		return rectTransform;
	}

	public RectTransform AddRadio(string label, string group, OnToggleValueChange handler, int targetCanvas = 0)
	{
		RectTransform rectTransform = UnityEngine.Object.Instantiate(radioPrefab);
		AddRect(rectTransform, targetCanvas);
		rectTransform.GetComponentInChildren<Text>().text = label;
		Toggle tb = rectTransform.GetComponentInChildren<Toggle>();
		if (group == null)
		{
			group = "default";
		}
		ToggleGroup toggleGroup = null;
		bool isOn = false;
		if (!radioGroups.ContainsKey(group))
		{
			toggleGroup = tb.gameObject.AddComponent<ToggleGroup>();
			radioGroups[group] = toggleGroup;
			isOn = true;
		}
		else
		{
			toggleGroup = radioGroups[group];
		}
		tb.group = toggleGroup;
		tb.isOn = isOn;
		tb.onValueChanged.AddListener(delegate
		{
			handler(tb);
		});
		return rectTransform;
	}

	public RectTransform AddTextField(string label, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(textPrefab).GetComponent<RectTransform>();
		component.GetComponentInChildren<InputField>().text = label;
		AddRect(component, targetCanvas);
		return component;
	}

	public void ToggleLaserPointer(bool isOn)
	{
		if ((bool)lp)
		{
			if (isOn)
			{
				lp.enabled = true;
			}
			else
			{
				lp.enabled = false;
			}
		}
	}
}
public class HandedInputSelector : MonoBehaviour
{
	private OVRCameraRig m_CameraRig;

	private OVRInputModule m_InputModule;

	private void Start()
	{
		m_CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		m_InputModule = UnityEngine.Object.FindObjectOfType<OVRInputModule>();
	}

	private void Update()
	{
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			SetActiveController(OVRInput.Controller.LTouch);
		}
		else
		{
			SetActiveController(OVRInput.Controller.RTouch);
		}
	}

	private void SetActiveController(OVRInput.Controller c)
	{
		Transform rayTransform = ((c != OVRInput.Controller.LTouch) ? m_CameraRig.rightHandAnchor : m_CameraRig.leftHandAnchor);
		m_InputModule.rayTransform = rayTransform;
	}
}
public class LaserPointer : OVRCursor
{
	public enum LaserBeamBehavior
	{
		On,
		Off,
		OnWhenHitTarget
	}

	public GameObject cursorVisual;

	public float maxLength = 10f;

	private LaserBeamBehavior _laserBeamBehavior;

	private bool m_restoreOnInputAcquired;

	private Vector3 _startPoint;

	private Vector3 _forward;

	private Vector3 _endPoint;

	private bool _hitTarget;

	private LineRenderer lineRenderer;

	public LaserBeamBehavior laserBeamBehavior
	{
		get
		{
			return _laserBeamBehavior;
		}
		set
		{
			_laserBeamBehavior = value;
			if (laserBeamBehavior == LaserBeamBehavior.Off || laserBeamBehavior == LaserBeamBehavior.OnWhenHitTarget)
			{
				lineRenderer.enabled = false;
			}
			else
			{
				lineRenderer.enabled = true;
			}
		}
	}

	private void Awake()
	{
		lineRenderer = GetComponent<LineRenderer>();
	}

	private void Start()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
		OVRManager.InputFocusAcquired += OnInputFocusAcquired;
		OVRManager.InputFocusLost += OnInputFocusLost;
	}

	public override void SetCursorStartDest(Vector3 start, Vector3 dest, Vector3 normal)
	{
		_startPoint = start;
		_endPoint = dest;
		_hitTarget = true;
	}

	public override void SetCursorRay(Transform t)
	{
		_startPoint = t.position;
		_forward = t.forward;
		_hitTarget = false;
	}

	private void LateUpdate()
	{
		lineRenderer.SetPosition(0, _startPoint);
		if (_hitTarget)
		{
			lineRenderer.SetPosition(1, _endPoint);
			UpdateLaserBeam(_startPoint, _endPoint);
			if ((bool)cursorVisual)
			{
				cursorVisual.transform.position = _endPoint;
				cursorVisual.SetActive(value: true);
			}
		}
		else
		{
			UpdateLaserBeam(_startPoint, _startPoint + maxLength * _forward);
			lineRenderer.SetPosition(1, _startPoint + maxLength * _forward);
			if ((bool)cursorVisual)
			{
				cursorVisual.SetActive(value: false);
			}
		}
	}

	private void UpdateLaserBeam(Vector3 start, Vector3 end)
	{
		if (laserBeamBehavior == LaserBeamBehavior.Off)
		{
			return;
		}
		if (laserBeamBehavior == LaserBeamBehavior.On)
		{
			lineRenderer.SetPosition(0, start);
			lineRenderer.SetPosition(1, end);
		}
		else
		{
			if (laserBeamBehavior != LaserBeamBehavior.OnWhenHitTarget)
			{
				return;
			}
			if (_hitTarget)
			{
				if (!lineRenderer.enabled)
				{
					lineRenderer.enabled = true;
					lineRenderer.SetPosition(0, start);
					lineRenderer.SetPosition(1, end);
				}
			}
			else if (lineRenderer.enabled)
			{
				lineRenderer.enabled = false;
			}
		}
	}

	private void OnDisable()
	{
		if ((bool)cursorVisual)
		{
			cursorVisual.SetActive(value: false);
		}
	}

	public void OnInputFocusLost()
	{
		if ((bool)base.gameObject && base.gameObject.activeInHierarchy)
		{
			m_restoreOnInputAcquired = true;
			base.gameObject.SetActive(value: false);
		}
	}

	public void OnInputFocusAcquired()
	{
		if (m_restoreOnInputAcquired && (bool)base.gameObject)
		{
			m_restoreOnInputAcquired = false;
			base.gameObject.SetActive(value: true);
		}
	}

	private void OnDestroy()
	{
		OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
		OVRManager.InputFocusLost -= OnInputFocusLost;
	}
}
public class CharacterCameraConstraint : MonoBehaviour
{
	private const float FADE_RAY_LENGTH = 0.25f;

	private const float FADE_OVERLAP_MAXIMUM = 0.1f;

	private const float FADE_AMOUNT_MAXIMUM = 1f;

	[UnityEngine.Tooltip("This should be a reference to the OVRCameraRig that is usually a child of the PlayerController.")]
	public OVRCameraRig CameraRig;

	[UnityEngine.Tooltip("Collision layers to be used for the purposes of fading out the screen when the HMD is inside world geometry and adjusting the capsule height.")]
	public LayerMask CollideLayers;

	[UnityEngine.Tooltip("Offset is added to camera's real world height, effectively treating it as though the player was taller/standing higher.")]
	public float HeightOffset;

	[UnityEngine.Tooltip("Minimum height that the character capsule can shrink to.  To disable, set to capsule's height.")]
	public float MinimumHeight;

	[UnityEngine.Tooltip("Maximum height that the character capsule can grow to.  To disable, set to capsule's height.")]
	public float MaximumHeight;

	private CapsuleCollider _character;

	private SimpleCapsuleWithStickMovement _simplePlayerController;

	private CharacterCameraConstraint()
	{
	}

	private void Awake()
	{
		_character = GetComponent<CapsuleCollider>();
		_simplePlayerController = GetComponent<SimpleCapsuleWithStickMovement>();
	}

	private void OnEnable()
	{
		_simplePlayerController.CameraUpdated += CameraUpdate;
	}

	private void OnDisable()
	{
		_simplePlayerController.CameraUpdated -= CameraUpdate;
	}

	private void CameraUpdate()
	{
		float result = 0f;
		if (CheckCameraOverlapped())
		{
			OVRScreenFade.instance.SetExplicitFade(1f);
		}
		else if (CheckCameraNearClipping(out result))
		{
			float t = Mathf.InverseLerp(0f, 0.1f, result);
			float explicitFade = Mathf.Lerp(0f, 1f, t);
			OVRScreenFade.instance.SetExplicitFade(explicitFade);
		}
		else
		{
			OVRScreenFade.instance.SetExplicitFade(0f);
		}
		float num = 0.25f;
		float value = CameraRig.centerEyeAnchor.localPosition.y + HeightOffset + num;
		float minimumHeight = MinimumHeight;
		minimumHeight = Mathf.Min(_character.height, minimumHeight);
		float b = MaximumHeight;
		if (Physics.SphereCast(_character.transform.position, _character.radius * 0.2f, Vector3.up, out var hitInfo, MaximumHeight - _character.transform.position.y, CollideLayers, QueryTriggerInteraction.Ignore))
		{
			b = hitInfo.point.y;
		}
		b = Mathf.Max(_character.height, b);
		_character.height = Mathf.Clamp(value, minimumHeight, b);
		float y = HeightOffset - _character.height * 0.5f - num;
		CameraRig.transform.localPosition = new Vector3(0f, y, 0f);
	}

	private bool CheckCameraOverlapped()
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3 position = _character.transform.position;
		float num = Mathf.Max(0f, _character.height * 0.5f - component.nearClipPlane - 0.01f);
		position.y = Mathf.Clamp(CameraRig.centerEyeAnchor.position.y, _character.transform.position.y - num, _character.transform.position.y + num);
		Vector3 vector = CameraRig.centerEyeAnchor.position - position;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		RaycastHit hitInfo;
		return Physics.SphereCast(position, component.nearClipPlane, direction, out hitInfo, magnitude, CollideLayers, QueryTriggerInteraction.Ignore);
	}

	private bool CheckCameraNearClipping(out float result)
	{
		Camera component = CameraRig.centerEyeAnchor.GetComponent<Camera>();
		Vector3[] array = new Vector3[4];
		component.CalculateFrustumCorners(new Rect(0f, 0f, 1f, 1f), component.nearClipPlane, Camera.MonoOrStereoscopicEye.Mono, array);
		Vector3 vector = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[0])) * 0.25f;
		Vector3 vector2 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[1])) * 0.25f;
		Vector3 vector3 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[2])) * 0.25f;
		Vector3 vector4 = CameraRig.centerEyeAnchor.position + Vector3.Normalize(CameraRig.centerEyeAnchor.TransformVector(array[3])) * 0.25f;
		Vector3 vector5 = (vector2 + vector4) / 2f;
		bool result2 = false;
		result = 0f;
		Vector3[] array2 = new Vector3[5] { vector, vector2, vector3, vector4, vector5 };
		foreach (Vector3 vector6 in array2)
		{
			if (Physics.Linecast(CameraRig.centerEyeAnchor.position, vector6, out var hitInfo, CollideLayers, QueryTriggerInteraction.Ignore))
			{
				result2 = true;
				result = Mathf.Max(result, Vector3.Distance(hitInfo.point, vector6));
			}
		}
		return result2;
	}
}
public class LocomotionController : MonoBehaviour
{
	public OVRCameraRig CameraRig;

	public CapsuleCollider CharacterController;

	public SimpleCapsuleWithStickMovement PlayerController;

	private void Start()
	{
		if (CameraRig == null)
		{
			CameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
		}
	}
}
public class LocomotionTeleport : MonoBehaviour
{
	public enum States
	{
		Ready,
		Aim,
		CancelAim,
		PreTeleport,
		CancelTeleport,
		Teleporting,
		PostTeleport
	}

	public enum TeleportIntentions
	{
		None,
		Aim,
		PreTeleport,
		Teleport
	}

	public enum AimCollisionTypes
	{
		Point,
		Sphere,
		Capsule
	}

	public class AimData
	{
		public RaycastHit TargetHitInfo;

		public bool TargetValid;

		public Vector3? Destination;

		public float Radius;

		public List<Vector3> Points { get; private set; }

		public AimData()
		{
			Points = new List<Vector3>();
		}

		public void Reset()
		{
			Points.Clear();
			TargetValid = false;
			Destination = null;
		}
	}

	[UnityEngine.Tooltip("Allow linear movement prior to the teleport system being activated.")]
	public bool EnableMovementDuringReady = true;

	[UnityEngine.Tooltip("Allow linear movement while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableMovementDuringAim = true;

	[UnityEngine.Tooltip("Allow linear movement while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableMovementDuringPreTeleport = true;

	[UnityEngine.Tooltip("Allow linear movement after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableMovementDuringPostTeleport = true;

	[UnityEngine.Tooltip("Allow rotation prior to the teleport system being activated.")]
	public bool EnableRotationDuringReady = true;

	[UnityEngine.Tooltip("Allow rotation while the teleport system is in the process of aiming for a teleport target.")]
	public bool EnableRotationDuringAim = true;

	[UnityEngine.Tooltip("Allow rotation while the teleport system is in the process of configuring the landing orientation.")]
	public bool EnableRotationDuringPreTeleport = true;

	[UnityEngine.Tooltip("Allow rotation after the teleport has occurred but before the system has returned to the ready state.")]
	public bool EnableRotationDuringPostTeleport = true;

	[NonSerialized]
	public TeleportAimHandler AimHandler;

	[UnityEngine.Tooltip("This prefab will be instantiated as needed and updated to match the current aim target.")]
	public TeleportDestination TeleportDestinationPrefab;

	[UnityEngine.Tooltip("TeleportDestinationPrefab will be instantiated into this layer.")]
	public int TeleportDestinationLayer;

	[NonSerialized]
	public TeleportInputHandler InputHandler;

	[NonSerialized]
	public TeleportIntentions CurrentIntention;

	[NonSerialized]
	public bool IsPreTeleportRequested;

	[NonSerialized]
	public bool IsTransitioning;

	[NonSerialized]
	public bool IsPostTeleportRequested;

	private TeleportDestination _teleportDestination;

	[UnityEngine.Tooltip("When aiming at possible destinations, the aim collision type determines which shape to use for collision tests.")]
	public AimCollisionTypes AimCollisionType;

	[UnityEngine.Tooltip("Use the character collision radius/height/skinwidth for sphere/capsule collision tests.")]
	public bool UseCharacterCollisionData;

	[UnityEngine.Tooltip("Radius of the sphere or capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionRadius;

	[UnityEngine.Tooltip("Height of the capsule used for collision testing when aiming to possible teleport destinations. Ignored if UseCharacterCollisionData is true.")]
	public float AimCollisionHeight;

	public States CurrentState { get; private set; }

	public Quaternion DestinationRotation => _teleportDestination.OrientationIndicator.rotation;

	public LocomotionController LocomotionController { get; private set; }

	public event Action<bool, Vector3?, Quaternion?, Quaternion?> UpdateTeleportDestination;

	public event System.Action EnterStateReady;

	public event System.Action EnterStateAim;

	public event Action<AimData> UpdateAimData;

	public event System.Action ExitStateAim;

	public event System.Action EnterStateCancelAim;

	public event System.Action EnterStatePreTeleport;

	public event System.Action EnterStateCancelTeleport;

	public event System.Action EnterStateTeleporting;

	public event System.Action EnterStatePostTeleport;

	public event System.Action<Transform, Vector3, Quaternion> Teleported;

	public void EnableMovement(bool ready, bool aim, bool pre, bool post)
	{
		EnableMovementDuringReady = ready;
		EnableMovementDuringAim = aim;
		EnableMovementDuringPreTeleport = pre;
		EnableMovementDuringPostTeleport = post;
	}

	public void EnableRotation(bool ready, bool aim, bool pre, bool post)
	{
		EnableRotationDuringReady = ready;
		EnableRotationDuringAim = aim;
		EnableRotationDuringPreTeleport = pre;
		EnableRotationDuringPostTeleport = post;
	}

	public void OnUpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		if (this.UpdateTeleportDestination != null)
		{
			this.UpdateTeleportDestination(isValidDestination, position, rotation, landingRotation);
		}
	}

	public bool AimCollisionTest(Vector3 start, Vector3 end, LayerMask aimCollisionLayerMask, out RaycastHit hitInfo)
	{
		Vector3 vector = end - start;
		float magnitude = vector.magnitude;
		Vector3 direction = vector / magnitude;
		switch (AimCollisionType)
		{
		case AimCollisionTypes.Capsule:
		{
			float num;
			float num2;
			if (UseCharacterCollisionData)
			{
				CapsuleCollider characterController = LocomotionController.CharacterController;
				num = characterController.height;
				num2 = characterController.radius;
			}
			else
			{
				num = AimCollisionHeight;
				num2 = AimCollisionRadius;
			}
			return Physics.CapsuleCast(start + new Vector3(0f, num2, 0f), start + new Vector3(0f, num + num2, 0f), num2, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		case AimCollisionTypes.Point:
			return Physics.Raycast(start, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		case AimCollisionTypes.Sphere:
		{
			float radius = ((!UseCharacterCollisionData) ? AimCollisionRadius : LocomotionController.CharacterController.radius);
			return Physics.SphereCast(start, radius, direction, out hitInfo, magnitude, aimCollisionLayerMask, QueryTriggerInteraction.Ignore);
		}
		default:
			throw new Exception();
		}
	}

	[Conditional("DEBUG_TELEPORT_STATES")]
	protected void LogState(string msg)
	{
		UnityEngine.Debug.Log(Time.frameCount + ": " + msg);
	}

	protected void CreateNewTeleportDestination()
	{
		TeleportDestinationPrefab.gameObject.SetActive(value: false);
		TeleportDestination teleportDestination = UnityEngine.Object.Instantiate(TeleportDestinationPrefab);
		teleportDestination.LocomotionTeleport = this;
		teleportDestination.gameObject.layer = TeleportDestinationLayer;
		_teleportDestination = teleportDestination;
		_teleportDestination.LocomotionTeleport = this;
	}

	private void DeactivateDestination()
	{
		_teleportDestination.OnDeactivated();
	}

	public void RecycleTeleportDestination(TeleportDestination oldDestination)
	{
		if (oldDestination == _teleportDestination)
		{
			CreateNewTeleportDestination();
		}
		UnityEngine.Object.Destroy(oldDestination.gameObject);
	}

	private void EnableMotion(bool enableLinear, bool enableRotation)
	{
		LocomotionController.PlayerController.EnableLinearMovement = enableLinear;
		LocomotionController.PlayerController.EnableRotation = enableRotation;
	}

	private void Awake()
	{
		LocomotionController = GetComponent<LocomotionController>();
		CreateNewTeleportDestination();
	}

	public virtual void OnEnable()
	{
		CurrentState = States.Ready;
		StartCoroutine(ReadyStateCoroutine());
	}

	public virtual void OnDisable()
	{
		StopAllCoroutines();
	}

	protected IEnumerator ReadyStateCoroutine()
	{
		yield return null;
		CurrentState = States.Ready;
		EnableMotion(EnableMovementDuringReady, EnableRotationDuringReady);
		if (this.EnterStateReady != null)
		{
			this.EnterStateReady();
		}
		while (CurrentIntention != TeleportIntentions.Aim)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(AimStateCoroutine());
	}

	public void OnUpdateAimData(AimData aimData)
	{
		if (this.UpdateAimData != null)
		{
			this.UpdateAimData(aimData);
		}
	}

	protected IEnumerator AimStateCoroutine()
	{
		CurrentState = States.Aim;
		EnableMotion(EnableMovementDuringAim, EnableRotationDuringAim);
		if (this.EnterStateAim != null)
		{
			this.EnterStateAim();
		}
		_teleportDestination.gameObject.SetActive(value: true);
		while (CurrentIntention == TeleportIntentions.Aim)
		{
			yield return null;
		}
		if (this.ExitStateAim != null)
		{
			this.ExitStateAim();
		}
		yield return null;
		if ((CurrentIntention == TeleportIntentions.PreTeleport || CurrentIntention == TeleportIntentions.Teleport) && _teleportDestination.IsValidDestination)
		{
			StartCoroutine(PreTeleportStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelAimStateCoroutine());
		}
	}

	protected IEnumerator CancelAimStateCoroutine()
	{
		CurrentState = States.CancelAim;
		if (this.EnterStateCancelAim != null)
		{
			this.EnterStateCancelAim();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator PreTeleportStateCoroutine()
	{
		CurrentState = States.PreTeleport;
		EnableMotion(EnableMovementDuringPreTeleport, EnableRotationDuringPreTeleport);
		if (this.EnterStatePreTeleport != null)
		{
			this.EnterStatePreTeleport();
		}
		while (CurrentIntention == TeleportIntentions.PreTeleport || IsPreTeleportRequested)
		{
			yield return null;
		}
		if (_teleportDestination.IsValidDestination)
		{
			StartCoroutine(TeleportingStateCoroutine());
		}
		else
		{
			StartCoroutine(CancelTeleportStateCoroutine());
		}
	}

	protected IEnumerator CancelTeleportStateCoroutine()
	{
		CurrentState = States.CancelTeleport;
		if (this.EnterStateCancelTeleport != null)
		{
			this.EnterStateCancelTeleport();
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	protected IEnumerator TeleportingStateCoroutine()
	{
		CurrentState = States.Teleporting;
		EnableMotion(enableLinear: false, enableRotation: false);
		if (this.EnterStateTeleporting != null)
		{
			this.EnterStateTeleporting();
		}
		while (IsTransitioning)
		{
			yield return null;
		}
		yield return null;
		StartCoroutine(PostTeleportStateCoroutine());
	}

	protected IEnumerator PostTeleportStateCoroutine()
	{
		CurrentState = States.PostTeleport;
		EnableMotion(EnableMovementDuringPostTeleport, EnableRotationDuringPostTeleport);
		if (this.EnterStatePostTeleport != null)
		{
			this.EnterStatePostTeleport();
		}
		while (IsPostTeleportRequested)
		{
			yield return null;
		}
		DeactivateDestination();
		yield return null;
		StartCoroutine(ReadyStateCoroutine());
	}

	public void DoTeleport()
	{
		CapsuleCollider characterController = LocomotionController.CharacterController;
		Transform transform = characterController.transform;
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += characterController.height * 0.5f;
		Quaternion landingRotation = _teleportDestination.LandingRotation;
		if (this.Teleported != null)
		{
			this.Teleported(transform, position, landingRotation);
		}
		transform.position = position;
		transform.rotation = landingRotation;
	}

	public Vector3 GetCharacterPosition()
	{
		return LocomotionController.CharacterController.transform.position;
	}

	public Quaternion GetHeadRotationY()
	{
		Quaternion value = Quaternion.identity;
		InputDevice deviceAtXRNode = InputDevices.GetDeviceAtXRNode(XRNode.Head);
		if (deviceAtXRNode.isValid)
		{
			deviceAtXRNode.TryGetFeatureValue(CommonUsages.deviceRotation, out value);
		}
		Vector3 eulerAngles = value.eulerAngles;
		eulerAngles.x = 0f;
		eulerAngles.z = 0f;
		return Quaternion.Euler(eulerAngles);
	}

	public void DoWarp(Vector3 startPos, float positionPercent)
	{
		Vector3 position = _teleportDestination.OrientationIndicator.position;
		position.y += LocomotionController.CharacterController.height / 2f;
		Transform obj = LocomotionController.CharacterController.transform;
		Vector3 position2 = Vector3.Lerp(startPos, position, positionPercent);
		obj.position = position2;
	}
}
public class SimpleCapsuleWithStickMovement : MonoBehaviour
{
	public bool EnableLinearMovement = true;

	public bool EnableRotation = true;

	public bool HMDRotatesPlayer = true;

	public bool RotationEitherThumbstick;

	public float RotationAngle = 45f;

	public float Speed;

	public OVRCameraRig CameraRig;

	private bool ReadyToSnapTurn;

	private Rigidbody _rigidbody;

	public event System.Action CameraUpdated;

	public event System.Action PreCharacterMove;

	private void Awake()
	{
		_rigidbody = GetComponent<Rigidbody>();
		if (CameraRig == null)
		{
			CameraRig = GetComponentInChildren<OVRCameraRig>();
		}
	}

	private void Start()
	{
	}

	private void FixedUpdate()
	{
		if (this.CameraUpdated != null)
		{
			this.CameraUpdated();
		}
		if (this.PreCharacterMove != null)
		{
			this.PreCharacterMove();
		}
		if (HMDRotatesPlayer)
		{
			RotatePlayerToHMD();
		}
		if (EnableLinearMovement)
		{
			StickMovement();
		}
		if (EnableRotation)
		{
			SnapTurn();
		}
	}

	private void RotatePlayerToHMD()
	{
		Transform trackingSpace = CameraRig.trackingSpace;
		Transform centerEyeAnchor = CameraRig.centerEyeAnchor;
		Vector3 position = trackingSpace.position;
		Quaternion rotation = trackingSpace.rotation;
		base.transform.rotation = Quaternion.Euler(0f, centerEyeAnchor.rotation.eulerAngles.y, 0f);
		trackingSpace.position = position;
		trackingSpace.rotation = rotation;
	}

	private void StickMovement()
	{
		Vector3 eulerAngles = CameraRig.centerEyeAnchor.rotation.eulerAngles;
		eulerAngles.z = (eulerAngles.x = 0f);
		Quaternion quaternion = Quaternion.Euler(eulerAngles);
		Vector3 zero = Vector3.zero;
		Vector2 vector = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
		zero += quaternion * (vector.x * Vector3.right);
		zero += quaternion * (vector.y * Vector3.forward);
		_rigidbody.MovePosition(_rigidbody.position + zero * Speed * Time.fixedDeltaTime);
	}

	private void SnapTurn()
	{
		if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickLeft) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickLeft)))
		{
			if (ReadyToSnapTurn)
			{
				ReadyToSnapTurn = false;
				base.transform.RotateAround(CameraRig.centerEyeAnchor.position, Vector3.up, 0f - RotationAngle);
			}
		}
		else if (OVRInput.Get(OVRInput.Button.SecondaryThumbstickRight) || (RotationEitherThumbstick && OVRInput.Get(OVRInput.Button.PrimaryThumbstickRight)))
		{
			if (ReadyToSnapTurn)
			{
				ReadyToSnapTurn = false;
				base.transform.RotateAround(CameraRig.centerEyeAnchor.position, Vector3.up, RotationAngle);
			}
		}
		else
		{
			ReadyToSnapTurn = true;
		}
	}
}
public abstract class TeleportAimHandler : TeleportSupport
{
	protected override void OnEnable()
	{
		base.OnEnable();
		base.LocomotionTeleport.AimHandler = this;
	}

	protected override void OnDisable()
	{
		if (base.LocomotionTeleport.AimHandler == this)
		{
			base.LocomotionTeleport.AimHandler = null;
		}
		base.OnDisable();
	}

	public abstract void GetPoints(List<Vector3> points);
}
public class TeleportAimHandlerLaser : TeleportAimHandler
{
	[UnityEngine.Tooltip("Maximum range for aiming.")]
	public float Range = 100f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		points.Add(aimRay.origin);
		points.Add(aimRay.origin + aimRay.direction * Range);
	}
}
public class TeleportAimHandlerParabolic : TeleportAimHandler
{
	[UnityEngine.Tooltip("Maximum range for aiming.")]
	public float Range;

	[UnityEngine.Tooltip("The MinimumElevation is relative to the AimPosition.")]
	public float MinimumElevation = -100f;

	[UnityEngine.Tooltip("The Gravity is used in conjunction with AimVelocity and the aim direction to simulate a projectile.")]
	public float Gravity = -9.8f;

	[UnityEngine.Tooltip("The AimVelocity is the initial speed of the faked projectile.")]
	[Range(0.001f, 50f)]
	public float AimVelocity = 1f;

	[UnityEngine.Tooltip("The AimStep is the how much to subdivide the iteration.")]
	[Range(0.001f, 1f)]
	public float AimStep = 1f;

	public override void GetPoints(List<Vector3> points)
	{
		base.LocomotionTeleport.InputHandler.GetAimData(out var aimRay);
		Vector3 origin = aimRay.origin;
		Vector3 vector = aimRay.direction * AimVelocity;
		float num = Range * Range;
		do
		{
			points.Add(origin);
			Vector3 vector2 = vector;
			vector2.y += Gravity * (1f / 90f) * AimStep;
			vector = vector2;
			origin += vector2 * AimStep;
		}
		while (origin.y - aimRay.origin.y > MinimumElevation && (aimRay.origin - origin).sqrMagnitude <= num);
	}
}
public class TeleportAimVisualLaser : TeleportSupport
{
	[UnityEngine.Tooltip("This prefab will be instantiated when the aim visual is awakened, and will be set active when the user is aiming, and deactivated when they are done aiming.")]
	public LineRenderer LaserPrefab;

	private readonly System.Action _enterAimStateAction;

	private readonly System.Action _exitAimStateAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	private LineRenderer _lineRenderer;

	private Vector3[] _linePoints;

	public TeleportAimVisualLaser()
	{
		_enterAimStateAction = EnterAimState;
		_exitAimStateAction = ExitAimState;
		_updateAimDataAction = UpdateAimData;
	}

	private void EnterAimState()
	{
		_lineRenderer.gameObject.SetActive(value: true);
	}

	private void ExitAimState()
	{
		_lineRenderer.gameObject.SetActive(value: false);
	}

	private void Awake()
	{
		LaserPrefab.gameObject.SetActive(value: false);
		_lineRenderer = UnityEngine.Object.Instantiate(LaserPrefab);
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim += _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateAim -= _enterAimStateAction;
		base.LocomotionTeleport.ExitStateAim -= _exitAimStateAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
		base.RemoveEventHandlers();
	}

	private void UpdateAimData(LocomotionTeleport.AimData obj)
	{
		_lineRenderer.sharedMaterial.color = (obj.TargetValid ? Color.green : Color.red);
		List<Vector3> points = obj.Points;
		_lineRenderer.positionCount = points.Count;
		for (int i = 0; i < points.Count; i++)
		{
			_lineRenderer.SetPosition(i, points[i]);
		}
	}
}
public class TeleportDestination : MonoBehaviour
{
	[UnityEngine.Tooltip("If the target handler provides a target position, this transform will be moved to that position and it's game object enabled. A target position being provided does not mean the position is valid, only that the aim handler found something to test as a destination.")]
	public Transform PositionIndicator;

	[UnityEngine.Tooltip("This transform will be rotated to match the rotation of the aiming target. Simple teleport destinations should assign this to the object containing this component. More complex teleport destinations might assign this to a sub-object that is used to indicate the landing orientation independently from the rest of the destination indicator, such as when world space effects are required. This will typically be a child of the PositionIndicator.")]
	public Transform OrientationIndicator;

	[UnityEngine.Tooltip("After the player teleports, the character controller will have it's rotation set to this value. It is different from the OrientationIndicator transform.rotation in order to support both head-relative and forward-facing teleport modes (See TeleportOrientationHandlerThumbstick.cs).")]
	public Quaternion LandingRotation;

	[NonSerialized]
	public LocomotionTeleport LocomotionTeleport;

	[NonSerialized]
	public LocomotionTeleport.States TeleportState;

	private readonly Action<bool, Vector3?, Quaternion?, Quaternion?> _updateTeleportDestinationAction;

	private bool _eventsActive;

	public bool IsValidDestination { get; private set; }

	public event Action<TeleportDestination> Deactivated;

	private TeleportDestination()
	{
		_updateTeleportDestinationAction = UpdateTeleportDestination;
	}

	public void OnEnable()
	{
		PositionIndicator.gameObject.SetActive(value: false);
		if (OrientationIndicator != null)
		{
			OrientationIndicator.gameObject.SetActive(value: false);
		}
		LocomotionTeleport.UpdateTeleportDestination += _updateTeleportDestinationAction;
		_eventsActive = true;
	}

	private void TryDisableEventHandlers()
	{
		if (_eventsActive)
		{
			LocomotionTeleport.UpdateTeleportDestination -= _updateTeleportDestinationAction;
			_eventsActive = false;
		}
	}

	public void OnDisable()
	{
		TryDisableEventHandlers();
	}

	public void OnDeactivated()
	{
		if (this.Deactivated != null)
		{
			this.Deactivated(this);
		}
		else
		{
			Recycle();
		}
	}

	public void Recycle()
	{
		LocomotionTeleport.RecycleTeleportDestination(this);
	}

	public virtual void UpdateTeleportDestination(bool isValidDestination, Vector3? position, Quaternion? rotation, Quaternion? landingRotation)
	{
		IsValidDestination = isValidDestination;
		LandingRotation = landingRotation.GetValueOrDefault();
		GameObject gameObject = PositionIndicator.gameObject;
		bool activeInHierarchy = gameObject.activeInHierarchy;
		if (!position.HasValue)
		{
			if (activeInHierarchy)
			{
				gameObject.SetActive(value: false);
			}
			return;
		}
		if (!activeInHierarchy)
		{
			gameObject.SetActive(value: true);
		}
		base.transform.position = position.GetValueOrDefault();
		if (OrientationIndicator == null)
		{
			if (rotation.HasValue)
			{
				base.transform.rotation = rotation.GetValueOrDefault();
			}
			return;
		}
		GameObject gameObject2 = OrientationIndicator.gameObject;
		bool activeInHierarchy2 = gameObject2.activeInHierarchy;
		if (!rotation.HasValue)
		{
			if (activeInHierarchy2)
			{
				gameObject2.SetActive(value: false);
			}
			return;
		}
		OrientationIndicator.rotation = rotation.GetValueOrDefault();
		if (!activeInHierarchy2)
		{
			gameObject2.SetActive(value: true);
		}
	}
}
public abstract class TeleportInputHandler : TeleportSupport
{
	private readonly System.Action _startReadyAction;

	private readonly System.Action _startAimAction;

	protected TeleportInputHandler()
	{
		_startReadyAction = delegate
		{
			StartCoroutine(TeleportReadyCoroutine());
		};
		_startAimAction = delegate
		{
			StartCoroutine(TeleportAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.InputHandler = this;
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateReady += _startReadyAction;
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		if (base.LocomotionTeleport.InputHandler == this)
		{
			base.LocomotionTeleport.InputHandler = null;
		}
		base.LocomotionTeleport.EnterStateReady -= _startReadyAction;
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
		base.RemoveEventHandlers();
	}

	private IEnumerator TeleportReadyCoroutine()
	{
		while (GetIntention() != LocomotionTeleport.TeleportIntentions.Aim)
		{
			yield return null;
		}
		base.LocomotionTeleport.CurrentIntention = LocomotionTeleport.TeleportIntentions.Aim;
	}

	private IEnumerator TeleportAimCoroutine()
	{
		LocomotionTeleport.TeleportIntentions intention = GetIntention();
		while (intention == LocomotionTeleport.TeleportIntentions.Aim || intention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			base.LocomotionTeleport.CurrentIntention = intention;
			yield return null;
			intention = GetIntention();
		}
		base.LocomotionTeleport.CurrentIntention = intention;
	}

	public abstract LocomotionTeleport.TeleportIntentions GetIntention();

	public abstract void GetAimData(out Ray aimRay);
}
public class TeleportInputHandlerHMD : TeleportInputHandler
{
	[UnityEngine.Tooltip("The button used to begin aiming for a teleport.")]
	public OVRInput.RawButton AimButton;

	[UnityEngine.Tooltip("The button used to trigger the teleport after aiming. It can be the same button as the AimButton, however you cannot abort a teleport if it is.")]
	public OVRInput.RawButton TeleportButton;

	[UnityEngine.Tooltip("When true, the system will not use the PreTeleport intention which will allow a teleport to occur on a button downpress. When false, the button downpress will trigger the PreTeleport intention and the Teleport intention when the button is released.")]
	public bool FastTeleport;

	public Transform Pointer { get; private set; }

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(TeleportButton))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (OVRInput.GetUp(TeleportButton))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.Get(AimButton))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (AimButton == TeleportButton)
		{
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
		aimRay = new Ray(centerEyeAnchor.position, centerEyeAnchor.forward);
	}
}
public class TeleportInputHandlerTouch : TeleportInputHandlerHMD
{
	public enum InputModes
	{
		CapacitiveButtonForAimAndTeleport,
		SeparateButtonsForAimAndTeleport,
		ThumbstickTeleport,
		ThumbstickTeleportForwardBackOnly
	}

	public enum AimCapTouchButtons
	{
		A,
		B,
		LeftTrigger,
		LeftThumbstick,
		RightTrigger,
		RightThumbstick,
		X,
		Y
	}

	public Transform LeftHand;

	public Transform RightHand;

	[UnityEngine.Tooltip("CapacitiveButtonForAimAndTeleport=Activate aiming via cap touch detection, press the same button to teleport.\nSeparateButtonsForAimAndTeleport=Use one button to begin aiming, and another to trigger the teleport.\nThumbstickTeleport=Push a thumbstick to begin aiming, release to teleport.")]
	public InputModes InputMode;

	private readonly OVRInput.RawButton[] _rawButtons = new OVRInput.RawButton[8]
	{
		OVRInput.RawButton.A,
		OVRInput.RawButton.B,
		OVRInput.RawButton.LIndexTrigger,
		OVRInput.RawButton.LThumbstick,
		OVRInput.RawButton.RIndexTrigger,
		OVRInput.RawButton.RThumbstick,
		OVRInput.RawButton.X,
		OVRInput.RawButton.Y
	};

	private readonly OVRInput.RawTouch[] _rawTouch = new OVRInput.RawTouch[8]
	{
		OVRInput.RawTouch.A,
		OVRInput.RawTouch.B,
		OVRInput.RawTouch.LIndexTrigger,
		OVRInput.RawTouch.LThumbstick,
		OVRInput.RawTouch.RIndexTrigger,
		OVRInput.RawTouch.RThumbstick,
		OVRInput.RawTouch.X,
		OVRInput.RawTouch.Y
	};

	[UnityEngine.Tooltip("Select the controller to be used for aiming. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller AimingController;

	private OVRInput.Controller InitiatingController;

	[UnityEngine.Tooltip("Select the button to use for triggering aim and teleport when InputMode==CapacitiveButtonForAimAndTeleport")]
	public AimCapTouchButtons CapacitiveAimAndTeleportButton;

	[UnityEngine.Tooltip("The thumbstick magnitude required to trigger aiming and teleports when InputMode==InputModes.ThumbstickTeleport")]
	public float ThumbstickTeleportThreshold = 0.5f;

	private void Start()
	{
	}

	public override LocomotionTeleport.TeleportIntentions GetIntention()
	{
		if (!base.isActiveAndEnabled)
		{
			return LocomotionTeleport.TeleportIntentions.None;
		}
		if (InputMode == InputModes.SeparateButtonsForAimAndTeleport)
		{
			return base.GetIntention();
		}
		if (InputMode == InputModes.ThumbstickTeleport || InputMode == InputModes.ThumbstickTeleportForwardBackOnly)
		{
			Vector2 lhs = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 lhs2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float num = 0f;
			float num2 = 0f;
			float num3 = 0f;
			OVRInput.Controller controller = OVRInput.Controller.Touch;
			bool flag = OVRInput.Get(OVRInput.RawTouch.LThumbstick);
			bool flag2 = OVRInput.Get(OVRInput.RawTouch.RThumbstick);
			if (InputMode == InputModes.ThumbstickTeleportForwardBackOnly && base.LocomotionTeleport.CurrentIntention != LocomotionTeleport.TeleportIntentions.Aim)
			{
				num = Mathf.Abs(Vector2.Dot(lhs, Vector2.up));
				num2 = Mathf.Abs(Vector2.Dot(lhs2, Vector2.up));
			}
			else
			{
				num = lhs.magnitude;
				num2 = lhs2.magnitude;
			}
			if (AimingController == OVRInput.Controller.LTouch)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else if (AimingController == OVRInput.Controller.RTouch)
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			else if (num > num2)
			{
				num3 = num;
				controller = OVRInput.Controller.LTouch;
			}
			else
			{
				num3 = num2;
				controller = OVRInput.Controller.RTouch;
			}
			if (!(num3 > ThumbstickTeleportThreshold) && (AimingController != OVRInput.Controller.Touch || !(flag || flag2)) && !(AimingController == OVRInput.Controller.LTouch && flag) && !(AimingController == OVRInput.Controller.RTouch && flag2))
			{
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
				{
					if (!FastTeleport)
					{
						return LocomotionTeleport.TeleportIntentions.PreTeleport;
					}
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
				if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
				{
					return LocomotionTeleport.TeleportIntentions.Teleport;
				}
			}
			else if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim)
			{
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			if (num3 > ThumbstickTeleportThreshold)
			{
				InitiatingController = controller;
				return LocomotionTeleport.TeleportIntentions.Aim;
			}
			return LocomotionTeleport.TeleportIntentions.None;
		}
		OVRInput.RawButton rawMask = _rawButtons[(int)CapacitiveAimAndTeleportButton];
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && OVRInput.GetDown(rawMask))
		{
			if (!FastTeleport)
			{
				return LocomotionTeleport.TeleportIntentions.PreTeleport;
			}
			return LocomotionTeleport.TeleportIntentions.Teleport;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.PreTeleport)
		{
			if (FastTeleport || OVRInput.GetUp(rawMask))
			{
				return LocomotionTeleport.TeleportIntentions.Teleport;
			}
			return LocomotionTeleport.TeleportIntentions.PreTeleport;
		}
		if (OVRInput.GetDown(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		if (base.LocomotionTeleport.CurrentIntention == LocomotionTeleport.TeleportIntentions.Aim && !OVRInput.GetUp(_rawTouch[(int)CapacitiveAimAndTeleportButton]))
		{
			return LocomotionTeleport.TeleportIntentions.Aim;
		}
		return LocomotionTeleport.TeleportIntentions.None;
	}

	public override void GetAimData(out Ray aimRay)
	{
		OVRInput.Controller controller = AimingController;
		if (controller == OVRInput.Controller.Touch)
		{
			controller = InitiatingController;
		}
		Transform transform = ((controller == OVRInput.Controller.LTouch) ? LeftHand : RightHand);
		aimRay = new Ray(transform.position, transform.forward);
	}
}
public abstract class TeleportOrientationHandler : TeleportSupport
{
	public enum OrientationModes
	{
		HeadRelative,
		ForwardFacing
	}

	private readonly System.Action _updateOrientationAction;

	private readonly Action<LocomotionTeleport.AimData> _updateAimDataAction;

	protected LocomotionTeleport.AimData AimData;

	protected TeleportOrientationHandler()
	{
		_updateOrientationAction = delegate
		{
			StartCoroutine(UpdateOrientationCoroutine());
		};
		_updateAimDataAction = UpdateAimData;
	}

	private void UpdateAimData(LocomotionTeleport.AimData aimData)
	{
		AimData = aimData;
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData += _updateAimDataAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _updateOrientationAction;
		base.LocomotionTeleport.UpdateAimData -= _updateAimDataAction;
	}

	private IEnumerator UpdateOrientationCoroutine()
	{
		InitializeTeleportDestination();
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport)
		{
			if (AimData != null)
			{
				UpdateTeleportDestination();
			}
			yield return null;
		}
	}

	protected abstract void InitializeTeleportDestination();

	protected abstract void UpdateTeleportDestination();

	protected Quaternion GetLandingOrientation(OrientationModes mode, Quaternion rotation)
	{
		if (mode != 0)
		{
			return rotation * Quaternion.Euler(0f, 0f - base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.localEulerAngles.y, 0f);
		}
		return rotation;
	}
}
public class TeleportOrientationHandler360 : TeleportOrientationHandler
{
	protected override void InitializeTeleportDestination()
	{
	}

	protected override void UpdateTeleportDestination()
	{
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, null, null);
	}
}
public class TeleportOrientationHandlerHMD : TeleportOrientationHandler
{
	[UnityEngine.Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[UnityEngine.Tooltip("Should the destination orientation be updated during the aim state in addition to the PreTeleport state?")]
	public bool UpdateOrientationDuringAim;

	[UnityEngine.Tooltip("How far from the destination must the HMD be pointing before using it for orientation")]
	public float AimDistanceThreshold;

	[UnityEngine.Tooltip("How far from the destination must the HMD be pointing before rejecting the teleport")]
	public float AimDistanceMaxRange;

	private Quaternion _initialRotation;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = Quaternion.identity;
	}

	protected override void UpdateTeleportDestination()
	{
		if (AimData.Destination.HasValue && (UpdateOrientationDuringAim || base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.PreTeleport))
		{
			Transform centerEyeAnchor = base.LocomotionTeleport.LocomotionController.CameraRig.centerEyeAnchor;
			Vector3 valueOrDefault = AimData.Destination.GetValueOrDefault();
			if (new Plane(Vector3.up, valueOrDefault).Raycast(new Ray(centerEyeAnchor.position, centerEyeAnchor.forward), out var enter))
			{
				Vector3 vector = centerEyeAnchor.position + centerEyeAnchor.forward * enter - valueOrDefault;
				vector.y = 0f;
				float magnitude = vector.magnitude;
				if (magnitude > AimDistanceThreshold)
				{
					vector.Normalize();
					Quaternion quaternion = (_initialRotation = Quaternion.LookRotation(new Vector3(vector.x, 0f, vector.z), Vector3.up));
					if (AimDistanceMaxRange > 0f && magnitude > AimDistanceMaxRange)
					{
						AimData.TargetValid = false;
					}
					base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, quaternion, GetLandingOrientation(OrientationMode, quaternion));
					return;
				}
			}
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _initialRotation, GetLandingOrientation(OrientationMode, _initialRotation));
	}
}
public class TeleportOrientationHandlerThumbstick : TeleportOrientationHandler
{
	[UnityEngine.Tooltip("HeadRelative=Character will orient to match the arrow. ForwardFacing=When user orients to match the arrow, they will be facing the sensors.")]
	public OrientationModes OrientationMode;

	[UnityEngine.Tooltip("Which thumbstick is to be used for adjusting the teleport orientation. Supports LTouch, RTouch, or Touch for either.")]
	public OVRInput.Controller Thumbstick;

	[UnityEngine.Tooltip("The orientation will only change if the thumbstick magnitude is above this value. This will usually be larger than the TeleportInputHandlerTouch.ThumbstickTeleportThreshold.")]
	public float RotateStickThreshold = 0.8f;

	private Quaternion _initialRotation;

	private Quaternion _currentRotation;

	private Vector2 _lastValidDirection;

	protected override void InitializeTeleportDestination()
	{
		_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
		_currentRotation = _initialRotation;
		_lastValidDirection = default(Vector2);
	}

	protected override void UpdateTeleportDestination()
	{
		float num;
		Vector2 lastValidDirection;
		if (Thumbstick == OVRInput.Controller.Touch)
		{
			Vector2 vector = OVRInput.Get(OVRInput.RawAxis2D.LThumbstick);
			Vector2 vector2 = OVRInput.Get(OVRInput.RawAxis2D.RThumbstick);
			float magnitude = vector.magnitude;
			float magnitude2 = vector2.magnitude;
			if (magnitude > magnitude2)
			{
				num = magnitude;
				lastValidDirection = vector;
			}
			else
			{
				num = magnitude2;
				lastValidDirection = vector2;
			}
		}
		else
		{
			lastValidDirection = ((Thumbstick != OVRInput.Controller.LTouch) ? OVRInput.Get(OVRInput.RawAxis2D.RThumbstick) : OVRInput.Get(OVRInput.RawAxis2D.LThumbstick));
			num = lastValidDirection.magnitude;
		}
		if (!AimData.TargetValid)
		{
			_lastValidDirection = default(Vector2);
		}
		if (num < RotateStickThreshold)
		{
			lastValidDirection = _lastValidDirection;
			num = lastValidDirection.magnitude;
			if (num < RotateStickThreshold)
			{
				_initialRotation = base.LocomotionTeleport.GetHeadRotationY();
				lastValidDirection.x = 0f;
				lastValidDirection.y = 1f;
			}
		}
		else
		{
			_lastValidDirection = lastValidDirection;
		}
		Quaternion rotation = base.LocomotionTeleport.LocomotionController.CameraRig.trackingSpace.rotation;
		if (num > RotateStickThreshold)
		{
			lastValidDirection /= num;
			Quaternion quaternion = _initialRotation * Quaternion.LookRotation(new Vector3(lastValidDirection.x, 0f, lastValidDirection.y), Vector3.up);
			_currentRotation = rotation * quaternion;
		}
		else
		{
			_currentRotation = rotation * base.LocomotionTeleport.GetHeadRotationY();
		}
		base.LocomotionTeleport.OnUpdateTeleportDestination(AimData.TargetValid, AimData.Destination, _currentRotation, GetLandingOrientation(OrientationMode, _currentRotation));
	}
}
public class TeleportPoint : MonoBehaviour
{
	public float dimmingSpeed = 1f;

	public float fullIntensity = 1f;

	public float lowIntensity = 0.5f;

	public Transform destTransform;

	private float lastLookAtTime;

	private void Start()
	{
	}

	public Transform GetDestTransform()
	{
		return destTransform;
	}

	private void Update()
	{
		float value = Mathf.SmoothStep(fullIntensity, lowIntensity, (Time.time - lastLookAtTime) * dimmingSpeed);
		GetComponent<MeshRenderer>().material.SetFloat("_Intensity", value);
	}

	public void OnLookAt()
	{
		lastLookAtTime = Time.time;
	}
}
public abstract class TeleportSupport : MonoBehaviour
{
	private bool _eventsActive;

	protected LocomotionTeleport LocomotionTeleport { get; private set; }

	protected virtual void OnEnable()
	{
		LocomotionTeleport = GetComponent<LocomotionTeleport>();
		AddEventHandlers();
	}

	protected virtual void OnDisable()
	{
		RemoveEventHandlers();
		LocomotionTeleport = null;
	}

	[Conditional("DEBUG_TELEPORT_EVENT_HANDLERS")]
	private void LogEventHandler(string msg)
	{
		UnityEngine.Debug.Log("EventHandler: " + GetType().Name + ": " + msg);
	}

	protected virtual void AddEventHandlers()
	{
		_eventsActive = true;
	}

	protected virtual void RemoveEventHandlers()
	{
		_eventsActive = false;
	}
}
public abstract class TeleportTargetHandler : TeleportSupport
{
	[UnityEngine.Tooltip("This bitmask controls which game object layers will be included in the targeting collision tests.")]
	public LayerMask AimCollisionLayerMask;

	protected readonly LocomotionTeleport.AimData AimData = new LocomotionTeleport.AimData();

	private readonly System.Action _startAimAction;

	private readonly List<Vector3> _aimPoints = new List<Vector3>();

	private const float ERROR_MARGIN = 0.1f;

	protected TeleportTargetHandler()
	{
		_startAimAction = delegate
		{
			StartCoroutine(TargetAimCoroutine());
		};
	}

	protected override void AddEventHandlers()
	{
		base.AddEventHandlers();
		base.LocomotionTeleport.EnterStateAim += _startAimAction;
	}

	protected override void RemoveEventHandlers()
	{
		base.RemoveEventHandlers();
		base.LocomotionTeleport.EnterStateAim -= _startAimAction;
	}

	private IEnumerator TargetAimCoroutine()
	{
		while (base.LocomotionTeleport.CurrentState == LocomotionTeleport.States.Aim)
		{
			ResetAimData();
			Vector3 start = base.LocomotionTeleport.transform.position;
			_aimPoints.Clear();
			base.LocomotionTeleport.AimHandler.GetPoints(_aimPoints);
			for (int i = 0; i < _aimPoints.Count; i++)
			{
				Vector3 end = _aimPoints[i];
				AimData.TargetValid = ConsiderTeleport(start, ref end);
				AimData.Points.Add(end);
				if (AimData.TargetValid)
				{
					AimData.Destination = ConsiderDestination(end);
					AimData.TargetValid = AimData.Destination.HasValue;
					break;
				}
				start = _aimPoints[i];
			}
			base.LocomotionTeleport.OnUpdateAimData(AimData);
			yield return null;
		}
	}

	protected virtual void ResetAimData()
	{
		AimData.Reset();
	}

	protected abstract bool ConsiderTeleport(Vector3 start, ref Vector3 end);

	public virtual Vector3? ConsiderDestination(Vector3 location)
	{
		CapsuleCollider characterController = base.LocomotionTeleport.LocomotionController.CharacterController;
		float num = characterController.radius - 0.1f;
		Vector3 vector = location;
		vector.y += num + 0.1f;
		Vector3 end = vector;
		end.y += characterController.height - 0.1f;
		if (Physics.CheckCapsule(vector, end, num, AimCollisionLayerMask, QueryTriggerInteraction.Ignore))
		{
			return null;
		}
		return location;
	}
}
public class TeleportTargetHandlerNavMesh : TeleportTargetHandler
{
	public int NavMeshAreaMask = -1;

	private NavMeshPath _path;

	private void Awake()
	{
		_path = new NavMeshPath();
	}

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}

	public override Vector3? ConsiderDestination(Vector3 location)
	{
		Vector3? result = base.ConsiderDestination(location);
		if (result.HasValue)
		{
			Vector3 characterPosition = base.LocomotionTeleport.GetCharacterPosition();
			Vector3 valueOrDefault = result.GetValueOrDefault();
			NavMesh.CalculatePath(characterPosition, valueOrDefault, NavMeshAreaMask, _path);
			if (_path.status == NavMeshPathStatus.PathComplete)
			{
				return result;
			}
		}
		return null;
	}

	[Conditional("SHOW_PATH_RESULT")]
	private void OnDrawGizmos()
	{
	}
}
public class TeleportTargetHandlerNode : TeleportTargetHandler
{
	[UnityEngine.Tooltip("When checking line of sight to the destination, add this value to the vertical offset for targeting collision checks.")]
	public float LOSOffset = 1f;

	[UnityEngine.Tooltip("Teleport logic will only work with TeleportPoint components that exist in the layers specified by this mask.")]
	public LayerMask TeleportLayerMask;

	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (!base.LocomotionTeleport.AimCollisionTest(start, end, (int)AimCollisionLayerMask | (int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		TeleportPoint component = AimData.TargetHitInfo.collider.gameObject.GetComponent<TeleportPoint>();
		if (component == null)
		{
			return false;
		}
		Vector3 position = component.destTransform.position;
		Vector3 end2 = new Vector3(position.x, position.y + LOSOffset, position.z);
		if (base.LocomotionTeleport.AimCollisionTest(start, end2, (int)AimCollisionLayerMask & ~(int)TeleportLayerMask, out AimData.TargetHitInfo))
		{
			return false;
		}
		end = position;
		return true;
	}
}
public class TeleportTargetHandlerPhysical : TeleportTargetHandler
{
	protected override bool ConsiderTeleport(Vector3 start, ref Vector3 end)
	{
		if (base.LocomotionTeleport.AimCollisionTest(start, end, AimCollisionLayerMask, out AimData.TargetHitInfo))
		{
			Vector3 normalized = (end - start).normalized;
			end = start + normalized * AimData.TargetHitInfo.distance;
			return true;
		}
		return false;
	}
}
public abstract class TeleportTransition : TeleportSupport
{
	protected override void AddEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting += LocomotionTeleportOnEnterStateTeleporting;
		base.AddEventHandlers();
	}

	protected override void RemoveEventHandlers()
	{
		base.LocomotionTeleport.EnterStateTeleporting -= LocomotionTeleportOnEnterStateTeleporting;
		base.RemoveEventHandlers();
	}

	protected abstract void LocomotionTeleportOnEnterStateTeleporting();
}
public class TeleportTransitionBlink : TeleportTransition
{
	[UnityEngine.Tooltip("How long the transition takes. Usually this is greater than Teleport Delay.")]
	[Range(0.01f, 2f)]
	public float TransitionDuration = 0.5f;

	[UnityEngine.Tooltip("At what percentage of the elapsed transition time does the teleport occur?")]
	[Range(0f, 1f)]
	public float TeleportDelay = 0.5f;

	[UnityEngine.Tooltip("Fade to black over the duration of the transition")]
	public AnimationCurve FadeLevels = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, 1f), new Keyframe(1f, 0f));

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(BlinkCoroutine());
	}

	protected IEnumerator BlinkCoroutine()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		float elapsedTime = 0f;
		float teleportTime = TransitionDuration * TeleportDelay;
		bool teleported = false;
		while (elapsedTime < TransitionDuration)
		{
			yield return null;
			elapsedTime += Time.deltaTime;
			if (!teleported && elapsedTime >= teleportTime)
			{
				teleported = true;
				base.LocomotionTeleport.DoTeleport();
			}
		}
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public class TeleportTransitionInstant : TeleportTransition
{
	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		base.LocomotionTeleport.DoTeleport();
	}
}
public class TeleportTransitionWarp : TeleportTransition
{
	[UnityEngine.Tooltip("How much time the warp transition takes to complete.")]
	[Range(0.01f, 1f)]
	public float TransitionDuration = 0.5f;

	[HideInInspector]
	public AnimationCurve PositionLerp = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	protected override void LocomotionTeleportOnEnterStateTeleporting()
	{
		StartCoroutine(DoWarp());
	}

	private IEnumerator DoWarp()
	{
		base.LocomotionTeleport.IsTransitioning = true;
		Vector3 startPosition = base.LocomotionTeleport.GetCharacterPosition();
		float elapsedTime = 0f;
		while (elapsedTime < TransitionDuration)
		{
			elapsedTime += Time.deltaTime;
			float time = elapsedTime / TransitionDuration;
			float positionPercent = PositionLerp.Evaluate(time);
			base.LocomotionTeleport.DoWarp(startPosition, positionPercent);
			yield return null;
		}
		base.LocomotionTeleport.DoWarp(startPosition, 1f);
		base.LocomotionTeleport.IsTransitioning = false;
	}
}
public static class NativeVideoPlayer
{
	public enum PlabackState
	{
		Idle = 1,
		Preparing,
		Buffering,
		Ready,
		Ended
	}

	public enum StereoMode
	{
		Unknown = -1,
		Mono,
		TopBottom,
		LeftRight,
		Mesh
	}

	private static IntPtr? _Activity;

	private static IntPtr? _VideoPlayerClass;

	private static readonly jvalue[] EmptyParams = new jvalue[0];

	private static IntPtr getIsPlayingMethodId;

	private static IntPtr getCurrentPlaybackStateMethodId;

	private static IntPtr getDurationMethodId;

	private static IntPtr getStereoModeMethodId;

	private static IntPtr getWidthMethodId;

	private static IntPtr getHeightMethodId;

	private static IntPtr getPlaybackPositionMethodId;

	private static IntPtr setPlaybackPositionMethodId;

	private static jvalue[] setPlaybackPositionParams;

	private static IntPtr playVideoMethodId;

	private static jvalue[] playVideoParams;

	private static IntPtr stopMethodId;

	private static IntPtr resumeMethodId;

	private static IntPtr pauseMethodId;

	private static IntPtr setPlaybackSpeedMethodId;

	private static jvalue[] setPlaybackSpeedParams;

	private static IntPtr setLoopingMethodId;

	private static jvalue[] setLoopingParams;

	private static IntPtr setListenerRotationQuaternionMethodId;

	private static jvalue[] setListenerRotationQuaternionParams;

	private static IntPtr VideoPlayerClass
	{
		get
		{
			if (!_VideoPlayerClass.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/oculus/videoplayer/NativeVideoPlayer");
					if (intPtr != IntPtr.Zero)
					{
						_VideoPlayerClass = AndroidJNI.NewGlobalRef(intPtr);
						AndroidJNI.DeleteLocalRef(intPtr);
					}
					else
					{
						UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
						_VideoPlayerClass = IntPtr.Zero;
					}
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogError("Failed to find NativeVideoPlayer class");
					UnityEngine.Debug.LogException(exception);
					_VideoPlayerClass = IntPtr.Zero;
				}
			}
			return _VideoPlayerClass.GetValueOrDefault();
		}
	}

	private static IntPtr Activity
	{
		get
		{
			if (!_Activity.HasValue)
			{
				try
				{
					IntPtr intPtr = AndroidJNI.FindClass("com/unity3d/player/UnityPlayer");
					IntPtr staticFieldID = AndroidJNI.GetStaticFieldID(intPtr, "currentActivity", "Landroid/app/Activity;");
					IntPtr staticObjectField = AndroidJNI.GetStaticObjectField(intPtr, staticFieldID);
					_Activity = AndroidJNI.NewGlobalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(staticObjectField);
					AndroidJNI.DeleteLocalRef(intPtr);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					_Activity = IntPtr.Zero;
				}
			}
			return _Activity.GetValueOrDefault();
		}
	}

	public static bool IsAvailable => VideoPlayerClass != IntPtr.Zero;

	public static bool IsPlaying
	{
		get
		{
			if (getIsPlayingMethodId == IntPtr.Zero)
			{
				getIsPlayingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getIsPlaying", "()Z");
			}
			return AndroidJNI.CallStaticBooleanMethod(VideoPlayerClass, getIsPlayingMethodId, EmptyParams);
		}
	}

	public static PlabackState CurrentPlaybackState
	{
		get
		{
			if (getCurrentPlaybackStateMethodId == IntPtr.Zero)
			{
				getCurrentPlaybackStateMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getCurrentPlaybackState", "()I");
			}
			return (PlabackState)AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getCurrentPlaybackStateMethodId, EmptyParams);
		}
	}

	public static long Duration
	{
		get
		{
			if (getDurationMethodId == IntPtr.Zero)
			{
				getDurationMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getDuration", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getDurationMethodId, EmptyParams);
		}
	}

	public static StereoMode VideoStereoMode
	{
		get
		{
			if (getStereoModeMethodId == IntPtr.Zero)
			{
				getStereoModeMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getStereoMode", "()I");
			}
			return (StereoMode)AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getStereoModeMethodId, EmptyParams);
		}
	}

	public static int VideoWidth
	{
		get
		{
			if (getWidthMethodId == IntPtr.Zero)
			{
				getWidthMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getWidth", "()I");
			}
			return AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getWidthMethodId, EmptyParams);
		}
	}

	public static int VideoHeight
	{
		get
		{
			if (getHeightMethodId == IntPtr.Zero)
			{
				getHeightMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getHeight", "()I");
			}
			return AndroidJNI.CallStaticIntMethod(VideoPlayerClass, getHeightMethodId, EmptyParams);
		}
	}

	public static long PlaybackPosition
	{
		get
		{
			if (getPlaybackPositionMethodId == IntPtr.Zero)
			{
				getPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "getPlaybackPosition", "()J");
			}
			return AndroidJNI.CallStaticLongMethod(VideoPlayerClass, getPlaybackPositionMethodId, EmptyParams);
		}
		set
		{
			if (setPlaybackPositionMethodId == IntPtr.Zero)
			{
				setPlaybackPositionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackPosition", "(J)V");
				setPlaybackPositionParams = new jvalue[1];
			}
			setPlaybackPositionParams[0].j = value;
			AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackPositionMethodId, setPlaybackPositionParams);
		}
	}

	public static void PlayVideo(string path, string drmLicenseUrl, IntPtr surfaceObj)
	{
		if (playVideoMethodId == IntPtr.Zero)
		{
			playVideoMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "playVideo", "(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;Landroid/view/Surface;)V");
			playVideoParams = new jvalue[4];
		}
		IntPtr intPtr = AndroidJNI.NewStringUTF(path);
		IntPtr intPtr2 = AndroidJNI.NewStringUTF(drmLicenseUrl);
		playVideoParams[0].l = Activity;
		playVideoParams[1].l = intPtr;
		playVideoParams[2].l = intPtr2;
		playVideoParams[3].l = surfaceObj;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, playVideoMethodId, playVideoParams);
		AndroidJNI.DeleteLocalRef(intPtr);
		AndroidJNI.DeleteLocalRef(intPtr2);
	}

	public static void Stop()
	{
		if (stopMethodId == IntPtr.Zero)
		{
			stopMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "stop", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, stopMethodId, EmptyParams);
	}

	public static void Play()
	{
		if (resumeMethodId == IntPtr.Zero)
		{
			resumeMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "resume", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, resumeMethodId, EmptyParams);
	}

	public static void Pause()
	{
		if (pauseMethodId == IntPtr.Zero)
		{
			pauseMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "pause", "()V");
		}
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, pauseMethodId, EmptyParams);
	}

	public static void SetPlaybackSpeed(float speed)
	{
		if (setPlaybackSpeedMethodId == IntPtr.Zero)
		{
			setPlaybackSpeedMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setPlaybackSpeed", "(F)V");
			setPlaybackSpeedParams = new jvalue[1];
		}
		setPlaybackSpeedParams[0].f = speed;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setPlaybackSpeedMethodId, setPlaybackSpeedParams);
	}

	public static void SetLooping(bool looping)
	{
		if (setLoopingMethodId == IntPtr.Zero)
		{
			setLoopingMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setLooping", "(Z)V");
			setLoopingParams = new jvalue[1];
		}
		setLoopingParams[0].z = looping;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setLoopingMethodId, setLoopingParams);
	}

	public static void SetListenerRotation(Quaternion rotation)
	{
		if (setListenerRotationQuaternionMethodId == IntPtr.Zero)
		{
			setListenerRotationQuaternionMethodId = AndroidJNI.GetStaticMethodID(VideoPlayerClass, "setListenerRotationQuaternion", "(FFFF)V");
			setListenerRotationQuaternionParams = new jvalue[4];
		}
		setListenerRotationQuaternionParams[0].f = rotation.x;
		setListenerRotationQuaternionParams[1].f = rotation.y;
		setListenerRotationQuaternionParams[2].f = rotation.z;
		setListenerRotationQuaternionParams[3].f = rotation.w;
		AndroidJNI.CallStaticVoidMethod(VideoPlayerClass, setListenerRotationQuaternionMethodId, setListenerRotationQuaternionParams);
	}
}
public class ButtonDownListener : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public event System.Action onButtonDown;

	public void OnPointerDown(PointerEventData eventData)
	{
		if (this.onButtonDown != null)
		{
			this.onButtonDown();
		}
	}
}
public class MediaPlayerImage : Image
{
	public enum ButtonType
	{
		Play,
		Pause,
		FastForward,
		Rewind,
		SkipForward,
		SkipBack,
		Stop
	}

	[SerializeField]
	private ButtonType m_ButtonType;

	public ButtonType buttonType
	{
		get
		{
			return m_ButtonType;
		}
		set
		{
			if (m_ButtonType != value)
			{
				m_ButtonType = value;
				SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper toFill)
	{
		Rect pixelAdjustedRect = GetPixelAdjustedRect();
		Vector4 vector = new Vector4(pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height);
		Color32 color = this.color;
		toFill.Clear();
		switch (m_ButtonType)
		{
		case ButtonType.Play:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			break;
		case ButtonType.Pause:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.w), color, new Vector2(0.35f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.35f), vector.y), color, new Vector2(0.35f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.y), color, new Vector2(0.65f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.65f), vector.w), color, new Vector2(0.65f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(6, 7, 4);
			break;
		case ButtonType.FastForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(vector.z, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(1f, 0.5f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.Rewind:
			toFill.AddVert(new Vector3(vector.x, Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.w), color, new Vector2(0.5f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), vector.y), color, new Vector2(0.5f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			break;
		case ButtonType.SkipForward:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.4375f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.y), color, new Vector2(0.4375f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.4375f), vector.w), color, new Vector2(0.4375f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.875f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.y), color, new Vector2(0.875f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.875f), vector.w), color, new Vector2(0.875f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(3, 4, 5);
			toFill.AddTriangle(6, 7, 8);
			toFill.AddTriangle(8, 9, 6);
			break;
		case ButtonType.SkipBack:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.w), color, new Vector2(0.125f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), vector.y), color, new Vector2(0.125f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.125f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.125f, 0.5f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.w), color, new Vector2(0.5625f, 1f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), vector.y), color, new Vector2(0.5625f, 0f));
			toFill.AddVert(new Vector3(Mathf.Lerp(vector.x, vector.z, 0.5625f), Mathf.Lerp(vector.y, vector.w, 0.5f)), color, new Vector2(0.5625f, 0.5f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			toFill.AddTriangle(4, 5, 6);
			toFill.AddTriangle(7, 8, 9);
			break;
		default:
			toFill.AddVert(new Vector3(vector.x, vector.y), color, new Vector2(0f, 0f));
			toFill.AddVert(new Vector3(vector.x, vector.w), color, new Vector2(0f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.w), color, new Vector2(1f, 1f));
			toFill.AddVert(new Vector3(vector.z, vector.y), color, new Vector2(1f, 0f));
			toFill.AddTriangle(0, 1, 2);
			toFill.AddTriangle(2, 3, 0);
			break;
		}
	}
}
public class MoviePlayerSample : MonoBehaviour
{
	public enum VideoShape
	{
		_360,
		_180,
		Quad
	}

	public enum VideoStereo
	{
		Mono,
		TopBottom,
		LeftRight,
		BottomTop
	}

	private bool videoPausedBeforeAppPause;

	private VideoPlayer videoPlayer;

	private OVROverlay overlay;

	private Renderer mediaRenderer;

	private RenderTexture copyTexture;

	private Material externalTex2DMaterial;

	public string MovieName;

	public string DrmLicenseUrl;

	public bool LoopVideo;

	public VideoShape Shape;

	public VideoStereo Stereo;

	public bool AutoDetectStereoLayout;

	public bool DisplayMono;

	private VideoShape _LastShape = (VideoShape)(-1);

	private VideoStereo _LastStereo = (VideoStereo)(-1);

	private bool _LastDisplayMono;

	public bool IsPlaying { get; private set; }

	public long Duration { get; private set; }

	public long PlaybackPosition { get; private set; }

	private void Awake()
	{
		UnityEngine.Debug.Log("MovieSample Awake");
		mediaRenderer = GetComponent<Renderer>();
		videoPlayer = GetComponent<VideoPlayer>();
		if (videoPlayer == null)
		{
			videoPlayer = base.gameObject.AddComponent<VideoPlayer>();
		}
		videoPlayer.isLooping = LoopVideo;
		overlay = GetComponent<OVROverlay>();
		if (overlay == null)
		{
			overlay = base.gameObject.AddComponent<OVROverlay>();
		}
		overlay.enabled = false;
		overlay.isExternalSurface = NativeVideoPlayer.IsAvailable;
		overlay.enabled = overlay.currentOverlayShape != OVROverlay.OverlayShape.Equirect || UnityEngine.Application.platform == RuntimePlatform.Android;
	}

	private bool IsLocalVideo(string movieName)
	{
		return !movieName.Contains("://");
	}

	private void UpdateShapeAndStereo()
	{
		if (AutoDetectStereoLayout && overlay.isExternalSurface)
		{
			int videoWidth = NativeVideoPlayer.VideoWidth;
			int videoHeight = NativeVideoPlayer.VideoHeight;
			switch (NativeVideoPlayer.VideoStereoMode)
			{
			case NativeVideoPlayer.StereoMode.Mono:
				Stereo = VideoStereo.Mono;
				break;
			case NativeVideoPlayer.StereoMode.LeftRight:
				Stereo = VideoStereo.LeftRight;
				break;
			case NativeVideoPlayer.StereoMode.TopBottom:
				Stereo = VideoStereo.TopBottom;
				break;
			case NativeVideoPlayer.StereoMode.Unknown:
				if (videoWidth > videoHeight)
				{
					Stereo = VideoStereo.LeftRight;
				}
				else
				{
					Stereo = VideoStereo.TopBottom;
				}
				break;
			}
		}
		if (Shape != _LastShape || Stereo != _LastStereo || DisplayMono != _LastDisplayMono)
		{
			Rect rect = new Rect(0f, 0f, 1f, 1f);
			switch (Shape)
			{
			case VideoShape._360:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				break;
			case VideoShape._180:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Equirect;
				rect = new Rect(0.25f, 0f, 0.5f, 1f);
				break;
			default:
				overlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
				break;
			}
			overlay.overrideTextureRectMatrix = true;
			overlay.invertTextureRects = false;
			Rect rect2 = new Rect(0f, 0f, 1f, 1f);
			Rect rect3 = new Rect(0f, 0f, 1f, 1f);
			switch (Stereo)
			{
			case VideoStereo.LeftRight:
				rect2 = new Rect(0f, 0f, 0.5f, 1f);
				rect3 = new Rect(0.5f, 0f, 0.5f, 1f);
				break;
			case VideoStereo.TopBottom:
				rect2 = new Rect(0f, 0.5f, 1f, 0.5f);
				rect3 = new Rect(0f, 0f, 1f, 0.5f);
				break;
			case VideoStereo.BottomTop:
				rect2 = new Rect(0f, 0f, 1f, 0.5f);
				rect3 = new Rect(0f, 0.5f, 1f, 0.5f);
				break;
			}
			overlay.SetSrcDestRects(rect2, DisplayMono ? rect2 : rect3, rect, rect);
			_LastDisplayMono = DisplayMono;
			_LastStereo = Stereo;
			_LastShape = Shape;
		}
	}

	private IEnumerator Start()
	{
		if (mediaRenderer.material == null)
		{
			UnityEngine.Debug.LogError("No material for movie surface");
			yield break;
		}
		yield return new WaitForSeconds(1f);
		if (!string.IsNullOrEmpty(MovieName))
		{
			if (IsLocalVideo(MovieName))
			{
				Play(UnityEngine.Application.streamingAssetsPath + "/" + MovieName, null);
			}
			else
			{
				Play(MovieName, DrmLicenseUrl);
			}
		}
	}

	public void Play(string moviePath, string drmLicencesUrl)
	{
		if (moviePath != string.Empty)
		{
			UnityEngine.Debug.Log("Playing Video: " + moviePath);
			if (overlay.isExternalSurface)
			{
				OVROverlay.ExternalSurfaceObjectCreated externalSurfaceObjectCreated = delegate
				{
					UnityEngine.Debug.Log("Playing ExoPlayer with SurfaceObject");
					NativeVideoPlayer.PlayVideo(moviePath, drmLicencesUrl, overlay.externalSurfaceObject);
					NativeVideoPlayer.SetLooping(LoopVideo);
				};
				if (overlay.externalSurfaceObject == IntPtr.Zero)
				{
					overlay.externalSurfaceObjectCreated = externalSurfaceObjectCreated;
				}
				else
				{
					externalSurfaceObjectCreated();
				}
			}
			else
			{
				UnityEngine.Debug.Log("Playing Unity VideoPlayer");
				videoPlayer.url = moviePath;
				videoPlayer.Prepare();
				videoPlayer.Play();
			}
			UnityEngine.Debug.Log("MovieSample Start");
			IsPlaying = true;
		}
		else
		{
			UnityEngine.Debug.LogError("No media file name provided");
		}
	}

	public void Play()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Play();
		}
		else
		{
			videoPlayer.Play();
		}
		IsPlaying = true;
	}

	public void Pause()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Pause();
		}
		else
		{
			videoPlayer.Pause();
		}
		IsPlaying = false;
	}

	public void SeekTo(long position)
	{
		long num = Math.Max(0L, Math.Min(Duration, position));
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.PlaybackPosition = num;
		}
		else
		{
			videoPlayer.time = (double)num / 1000.0;
		}
	}

	private void Update()
	{
		UpdateShapeAndStereo();
		if (!overlay.isExternalSurface)
		{
			Texture texture = ((videoPlayer.texture != null) ? videoPlayer.texture : Texture2D.blackTexture);
			if (overlay.enabled)
			{
				if (overlay.textures[0] != texture)
				{
					overlay.enabled = false;
					overlay.textures[0] = texture;
					overlay.enabled = true;
				}
			}
			else
			{
				mediaRenderer.material.mainTexture = texture;
				mediaRenderer.material.SetVector("_SrcRectLeft", overlay.srcRectLeft.ToVector());
				mediaRenderer.material.SetVector("_SrcRectRight", overlay.srcRectRight.ToVector());
			}
			IsPlaying = videoPlayer.isPlaying;
			PlaybackPosition = (long)(videoPlayer.time * 1000.0);
			Duration = (long)(videoPlayer.length * 1000.0);
		}
		else
		{
			NativeVideoPlayer.SetListenerRotation(Camera.main.transform.rotation);
			IsPlaying = NativeVideoPlayer.IsPlaying;
			PlaybackPosition = NativeVideoPlayer.PlaybackPosition;
			Duration = NativeVideoPlayer.Duration;
			if (IsPlaying && (int)OVRManager.display.displayFrequency != 60)
			{
				OVRManager.display.displayFrequency = 60f;
			}
			else if (!IsPlaying && (int)OVRManager.display.displayFrequency != 72)
			{
				OVRManager.display.displayFrequency = 72f;
			}
		}
	}

	public void SetPlaybackSpeed(float speed)
	{
		speed = Mathf.Max(0f, speed);
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.SetPlaybackSpeed(speed);
		}
		else
		{
			videoPlayer.playbackSpeed = speed;
		}
	}

	public void Stop()
	{
		if (overlay.isExternalSurface)
		{
			NativeVideoPlayer.Stop();
		}
		else
		{
			videoPlayer.Stop();
		}
		IsPlaying = false;
	}

	private void OnApplicationPause(bool appWasPaused)
	{
		UnityEngine.Debug.Log("OnApplicationPause: " + appWasPaused);
		if (appWasPaused)
		{
			videoPausedBeforeAppPause = !IsPlaying;
		}
		if (!videoPausedBeforeAppPause)
		{
			if (appWasPaused)
			{
				Pause();
			}
			else
			{
				Play();
			}
		}
	}
}
public class MoviePlayerSampleControls : MonoBehaviour
{
	private enum PlaybackState
	{
		Playing,
		Paused,
		Rewinding,
		FastForwarding
	}

	public MoviePlayerSample Player;

	public OVRInputModule InputModule;

	public OVRGazePointer GazePointer;

	public GameObject LeftHand;

	public GameObject RightHand;

	public Canvas Canvas;

	public ButtonDownListener PlayPause;

	public MediaPlayerImage PlayPauseImage;

	public Slider ProgressBar;

	public ButtonDownListener FastForward;

	public MediaPlayerImage FastForwardImage;

	public ButtonDownListener Rewind;

	public MediaPlayerImage RewindImage;

	public float TimeoutTime = 10f;

	private bool _isVisible;

	private float _lastButtonTime;

	private bool _didSeek;

	private long _seekPreviousPosition;

	private long _rewindStartPosition;

	private float _rewindStartTime;

	private PlaybackState _state;

	private void Start()
	{
		PlayPause.onButtonDown += OnPlayPauseClicked;
		FastForward.onButtonDown += OnFastForwardClicked;
		Rewind.onButtonDown += OnRewindClicked;
		ProgressBar.onValueChanged.AddListener(OnSeekBarMoved);
		PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
		FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
		RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
		SetVisible(visible: false);
	}

	private void OnPlayPauseClicked()
	{
		switch (_state)
		{
		case PlaybackState.Paused:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.FastForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.Rewind;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Playing:
			Player.Pause();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			FastForwardImage.buttonType = MediaPlayerImage.ButtonType.SkipForward;
			RewindImage.buttonType = MediaPlayerImage.ButtonType.SkipBack;
			_state = PlaybackState.Paused;
			break;
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		}
	}

	private void OnFastForwardClicked()
	{
		switch (_state)
		{
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			_state = PlaybackState.Playing;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			Player.SetPlaybackSpeed(2f);
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Playing:
			Player.SetPlaybackSpeed(2f);
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.FastForwarding;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition + 15000);
			break;
		}
	}

	private void OnRewindClicked()
	{
		switch (_state)
		{
		case PlaybackState.Playing:
		case PlaybackState.FastForwarding:
			Player.SetPlaybackSpeed(1f);
			Player.Pause();
			_rewindStartPosition = Player.PlaybackPosition;
			_rewindStartTime = Time.time;
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Play;
			_state = PlaybackState.Rewinding;
			break;
		case PlaybackState.Rewinding:
			Player.Play();
			PlayPauseImage.buttonType = MediaPlayerImage.ButtonType.Pause;
			_state = PlaybackState.Playing;
			break;
		case PlaybackState.Paused:
			Seek(Player.PlaybackPosition - 15000);
			break;
		}
	}

	private void OnSeekBarMoved(float value)
	{
		long num = (long)(value * (float)Player.Duration);
		if (Mathf.Abs(num - Player.PlaybackPosition) > 200f)
		{
			Seek(num);
		}
	}

	private void Seek(long pos)
	{
		_didSeek = true;
		_seekPreviousPosition = Player.PlaybackPosition;
		Player.SeekTo(pos);
	}

	private void Update()
	{
		if (OVRInput.Get(OVRInput.Button.One) || OVRInput.Get(OVRInput.Button.PrimaryIndexTrigger) || OVRInput.Get(OVRInput.Button.SecondaryIndexTrigger))
		{
			_lastButtonTime = Time.time;
			if (!_isVisible)
			{
				SetVisible(visible: true);
			}
		}
		if (OVRInput.GetActiveController() == OVRInput.Controller.LTouch)
		{
			InputModule.rayTransform = LeftHand.transform;
			GazePointer.rayTransform = LeftHand.transform;
		}
		else
		{
			InputModule.rayTransform = RightHand.transform;
			GazePointer.rayTransform = RightHand.transform;
		}
		if (OVRInput.Get(OVRInput.Button.Back) && _isVisible)
		{
			SetVisible(visible: false);
		}
		if (_state == PlaybackState.Rewinding)
		{
			ProgressBar.value = Mathf.Clamp01(((float)_rewindStartPosition - 1000f * (Time.time - _rewindStartTime)) / (float)Player.Duration);
		}
		if (_isVisible && _state == PlaybackState.Playing && Time.time - _lastButtonTime > TimeoutTime)
		{
			SetVisible(visible: false);
		}
		if (_isVisible && (!_didSeek || Mathf.Abs(_seekPreviousPosition - Player.PlaybackPosition) > 50f))
		{
			_didSeek = false;
			if (Player.Duration > 0)
			{
				ProgressBar.value = (float)((double)Player.PlaybackPosition / (double)Player.Duration);
			}
			else
			{
				ProgressBar.value = 0f;
			}
		}
	}

	private void SetVisible(bool visible)
	{
		Canvas.enabled = visible;
		_isVisible = visible;
		Player.DisplayMono = visible;
		LeftHand.SetActive(visible);
		RightHand.SetActive(visible);
		UnityEngine.Debug.Log("Controls Visible: " + visible);
	}
}
public static class VectorUtil
{
	public static Vector4 ToVector(this Rect rect)
	{
		return new Vector4(rect.x, rect.y, rect.width, rect.height);
	}
}
public class AppDeeplinkUI : MonoBehaviour
{
	private const ulong UNITY_COMPANION_APP_ID = 3535750239844224uL;

	private const ulong UNREAL_COMPANION_APP_ID = 4055411724486843uL;

	private RectTransform deeplinkAppId;

	private RectTransform deeplinkMessage;

	private RectTransform uiLaunchType;

	private RectTransform uiLaunchSource;

	private RectTransform uiDeepLinkMessage;

	private bool inMenu = true;

	private void Start()
	{
		DebugUIBuilder instance = DebugUIBuilder.instance;
		uiLaunchType = instance.AddLabel("UnityDeeplinkSample");
		instance.AddDivider();
		instance.AddButton("launch OtherApp", LaunchOtherApp);
		instance.AddButton("launch UnrealDeeplinkSample", LaunchUnrealDeeplinkSample);
		deeplinkAppId = CustomDebugUI.instance.AddTextField(3535750239844224uL.ToString());
		deeplinkMessage = CustomDebugUI.instance.AddTextField("MSG_UNITY_SAMPLE");
		instance.AddButton("LaunchSelf", LaunchSelf);
		if (UnityEngine.Application.platform == RuntimePlatform.Android && !Core.IsInitialized())
		{
			Core.Initialize();
		}
		uiLaunchType = instance.AddLabel("LaunchType: ");
		uiLaunchSource = instance.AddLabel("LaunchSource: ");
		uiDeepLinkMessage = instance.AddLabel("DeeplinkMessage: ");
		instance.ToggleLaserPointer(isOn: true);
		instance.Show();
	}

	private void Update()
	{
		_ = DebugUIBuilder.instance;
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			LaunchDetails launchDetails = ApplicationLifecycle.GetLaunchDetails();
			uiLaunchType.GetComponentInChildren<Text>().text = "LaunchType: " + launchDetails.LaunchType;
			uiLaunchSource.GetComponentInChildren<Text>().text = "LaunchSource: " + launchDetails.LaunchSource;
			uiDeepLinkMessage.GetComponentInChildren<Text>().text = "DeeplinkMessage: " + launchDetails.DeeplinkMessage;
		}
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	private void LaunchUnrealDeeplinkSample()
	{
		UnityEngine.Debug.Log($"LaunchOtherApp({4055411724486843uL})");
		ApplicationOptions applicationOptions = new ApplicationOptions();
		applicationOptions.SetDeeplinkMessage(deeplinkMessage.GetComponentInChildren<Text>().text);
		Oculus.Platform.Application.LaunchOtherApp(4055411724486843uL, applicationOptions);
	}

	private void LaunchSelf()
	{
		if (ulong.TryParse(PlatformSettings.MobileAppID, out var result))
		{
			UnityEngine.Debug.Log($"LaunchSelf({result})");
			ApplicationOptions applicationOptions = new ApplicationOptions();
			applicationOptions.SetDeeplinkMessage(deeplinkMessage.GetComponentInChildren<Text>().text);
			Oculus.Platform.Application.LaunchOtherApp(result, applicationOptions);
		}
	}

	private void LaunchOtherApp()
	{
		if (ulong.TryParse(deeplinkAppId.GetComponentInChildren<Text>().text, out var result))
		{
			UnityEngine.Debug.Log($"LaunchOtherApp({result})");
			ApplicationOptions applicationOptions = new ApplicationOptions();
			applicationOptions.SetDeeplinkMessage(deeplinkMessage.GetComponentInChildren<Text>().text);
			Oculus.Platform.Application.LaunchOtherApp(result, applicationOptions);
		}
	}
}
public class CustomDebugUI : MonoBehaviour
{
	[SerializeField]
	private RectTransform textPrefab;

	public static CustomDebugUI instance;

	private const BindingFlags privateFlags = BindingFlags.Instance | BindingFlags.NonPublic;

	private void Awake()
	{
		instance = this;
	}

	private void Start()
	{
	}

	private void Update()
	{
	}

	public RectTransform AddTextField(string label, int targetCanvas = 0)
	{
		RectTransform component = UnityEngine.Object.Instantiate(textPrefab).GetComponent<RectTransform>();
		component.GetComponentInChildren<InputField>().text = label;
		DebugUIBuilder obj = DebugUIBuilder.instance;
		typeof(DebugUIBuilder).GetMethod("AddRect", BindingFlags.Instance | BindingFlags.NonPublic).Invoke(obj, new object[2] { component, targetCanvas });
		return component;
	}

	public void RemoveFromCanvas(RectTransform element, int targetCanvas = 0)
	{
		DebugUIBuilder obj = DebugUIBuilder.instance;
		FieldInfo field = typeof(DebugUIBuilder).GetField("insertedElements", BindingFlags.Instance | BindingFlags.NonPublic);
		MethodInfo method = typeof(DebugUIBuilder).GetMethod("Relayout", BindingFlags.Instance | BindingFlags.NonPublic);
		List<RectTransform>[] array = (List<RectTransform>[])field.GetValue(obj);
		if (targetCanvas > -1 && targetCanvas < array.Length - 1)
		{
			array[targetCanvas].Remove(element);
			element.SetParent(null);
			method.Invoke(obj, new object[0]);
		}
	}
}
public class DebugUISample : MonoBehaviour
{
	private bool inMenu;

	private Text sliderText;

	private void Start()
	{
		DebugUIBuilder.instance.AddButton("Button Pressed", LogButtonPressed);
		DebugUIBuilder.instance.AddLabel("Label");
		RectTransform rectTransform = DebugUIBuilder.instance.AddSlider("Slider", 1f, 10f, SliderPressed, wholeNumbersOnly: true);
		Text[] componentsInChildren = rectTransform.GetComponentsInChildren<Text>();
		sliderText = componentsInChildren[1];
		sliderText.text = rectTransform.GetComponentInChildren<Slider>().value.ToString();
		DebugUIBuilder.instance.AddDivider();
		DebugUIBuilder.instance.AddToggle("Toggle", TogglePressed);
		DebugUIBuilder.instance.AddRadio("Radio1", "group", delegate(Toggle t)
		{
			RadioPressed("Radio1", "group", t);
		});
		DebugUIBuilder.instance.AddRadio("Radio2", "group", delegate(Toggle t)
		{
			RadioPressed("Radio2", "group", t);
		});
		DebugUIBuilder.instance.AddLabel("Secondary Tab", 1);
		DebugUIBuilder.instance.AddDivider(1);
		DebugUIBuilder.instance.AddRadio("Side Radio 1", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 1", "group2", t);
		}, 1);
		DebugUIBuilder.instance.AddRadio("Side Radio 2", "group2", delegate(Toggle t)
		{
			RadioPressed("Side Radio 2", "group2", t);
		}, 1);
		DebugUIBuilder.instance.Show();
		inMenu = true;
	}

	public void TogglePressed(Toggle t)
	{
		UnityEngine.Debug.Log("Toggle pressed. Is on? " + t.isOn);
	}

	public void RadioPressed(string radioLabel, string group, Toggle t)
	{
		UnityEngine.Debug.Log("Radio value changed: " + radioLabel + ", from group " + group + ". New value: " + t.isOn);
	}

	public void SliderPressed(float f)
	{
		UnityEngine.Debug.Log("Slider: " + f);
		sliderText.text = f.ToString();
	}

	private void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	private void LogButtonPressed()
	{
		UnityEngine.Debug.Log("Button pressed");
	}
}
public class HandsActiveChecker : MonoBehaviour
{
	[SerializeField]
	private GameObject _notificationPrefab;

	private GameObject _notification;

	private OVRCameraRig _cameraRig;

	private Transform _centerEye;

	private void Awake()
	{
		_notification = UnityEngine.Object.Instantiate(_notificationPrefab);
		StartCoroutine(GetCenterEye());
	}

	private void Update()
	{
		if (OVRPlugin.GetHandTrackingEnabled())
		{
			_notification.SetActive(value: false);
			return;
		}
		_notification.SetActive(value: true);
		if ((bool)_centerEye)
		{
			_notification.transform.position = _centerEye.position + _centerEye.forward * 0.5f;
			_notification.transform.rotation = _centerEye.rotation;
		}
	}

	private IEnumerator GetCenterEye()
	{
		if ((_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>()) != null)
		{
			while (!_centerEye)
			{
				_centerEye = _cameraRig.centerEyeAnchor;
				yield return null;
			}
		}
	}
}
[ExecuteInEditMode]
public class CharacterCapsule : MonoBehaviour
{
	private CharacterController _character;

	private MeshFilter _meshFilter;

	private float _height;

	private float _radius;

	[Range(4f, 32f)]
	public int SubdivisionsU;

	[Range(4f, 32f)]
	public int SubdivisionsV;

	private int _subdivisionU;

	private int _subdivisionV;

	private Vector3[] _vertices;

	private int[] _triangles;

	private void Update()
	{
		if (_character == null)
		{
			_character = GetComponentInParent<CharacterController>();
			if (_character == null)
			{
				return;
			}
		}
		if (_height == _character.height && _radius == _character.radius && _subdivisionU == SubdivisionsU && _subdivisionV == SubdivisionsV)
		{
			return;
		}
		_height = _character.height;
		_radius = _character.radius;
		_subdivisionU = SubdivisionsU;
		_subdivisionV = SubdivisionsV;
		List<Vector3> list = new List<Vector3>();
		Vector3 vector = new Vector3(1f, 0f, 0f);
		Vector3 vector2 = new Vector3(0f, _height / 2f - _radius, 0f);
		Vector3 vector3 = new Vector3(0f, _radius - _height / 2f, 0f);
		list.Add(new Vector3(0f, _height / 2f, 0f));
		for (int num = SubdivisionsU - 1; num >= 0; num--)
		{
			float num2 = (float)num / (float)SubdivisionsU;
			for (int i = 0; i < SubdivisionsV; i++)
			{
				float num3 = (float)i / (float)SubdivisionsV;
				Vector3 item = Quaternion.Euler(0f, num3 * 360f, num2 * 90f) * vector * _radius + vector2;
				list.Add(item);
			}
		}
		for (int j = 0; j < SubdivisionsU; j++)
		{
			float num4 = (float)j / (float)SubdivisionsU;
			for (int k = 0; k < SubdivisionsV; k++)
			{
				float num5 = (float)k / (float)SubdivisionsV;
				Vector3 vector4 = Quaternion.Euler(0f, num5 * 360f + 180f, num4 * 90f) * vector;
				vector4 *= _radius;
				Vector3 item2 = vector3 - vector4;
				list.Add(item2);
			}
		}
		list.Add(new Vector3(0f, (0f - _height) / 2f, 0f));
		List<int> list2 = new List<int>();
		int item3;
		for (int l = 0; l < SubdivisionsV; l++)
		{
			item3 = 0;
			list2.Add(item3);
			list2.Add(l);
			list2.Add(l + 1);
		}
		list2.Add(0);
		list2.Add(SubdivisionsV);
		list2.Add(1);
		int num6;
		for (int m = 0; m < SubdivisionsU - 1; m++)
		{
			num6 = m * SubdivisionsV + 1;
			for (int n = 0; n < SubdivisionsV - 1; n++)
			{
				item3 = num6 + n;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		num6 = (SubdivisionsU - 1) * SubdivisionsV + 1;
		for (int num7 = 0; num7 < SubdivisionsV - 1; num7++)
		{
			item3 = num6 + num7;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
			list2.Add(item3 + 1);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + SubdivisionsV + 1);
		}
		item3 = num6 + SubdivisionsV - 1;
		list2.Add(item3);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + 1 - SubdivisionsV);
		list2.Add(item3 + SubdivisionsV);
		list2.Add(item3 + 1);
		for (int num8 = 0; num8 < SubdivisionsU - 1; num8++)
		{
			num6 = num8 * SubdivisionsV + SubdivisionsU * SubdivisionsV + 1;
			for (int num9 = 0; num9 < SubdivisionsV - 1; num9++)
			{
				item3 = num6 + num9;
				list2.Add(item3);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + 1);
				list2.Add(item3 + 1);
				list2.Add(item3 + SubdivisionsV);
				list2.Add(item3 + SubdivisionsV + 1);
			}
			item3 = num6 + SubdivisionsV - 1;
			list2.Add(item3);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + 1 - SubdivisionsV);
			list2.Add(item3 + SubdivisionsV);
			list2.Add(item3 + 1);
		}
		int num10 = list.Count - 1;
		int num11 = num10 - SubdivisionsV;
		for (int num12 = 0; num12 < SubdivisionsV; num12++)
		{
			item3 = 0;
			list2.Add(num10);
			list2.Add(num11 + num12 + 1);
			list2.Add(num11 + num12);
		}
		list2.Add(num10);
		list2.Add(num11);
		list2.Add(num10 - 1);
		_vertices = list.ToArray();
		_triangles = list2.ToArray();
		_meshFilter = base.gameObject.GetComponent<MeshFilter>();
		_meshFilter.mesh = new Mesh();
		_meshFilter.sharedMesh.vertices = _vertices;
		_meshFilter.sharedMesh.triangles = _triangles;
		_meshFilter.sharedMesh.RecalculateNormals();
	}
}
public class LocomotionSampleSupport : MonoBehaviour
{
	private LocomotionController lc;

	private bool inMenu;

	private LocomotionTeleport TeleportController => lc.GetComponent<LocomotionTeleport>();

	public void Start()
	{
		lc = UnityEngine.Object.FindObjectOfType<LocomotionController>();
		DebugUIBuilder.instance.AddButton("Node Teleport w/ A", SetupNodeTeleport);
		DebugUIBuilder.instance.AddButton("Dual-stick teleport", SetupTwoStickTeleport);
		DebugUIBuilder.instance.AddButton("L Strafe R Teleport", SetupLeftStrafeRightTeleport);
		DebugUIBuilder.instance.AddButton("Walk Only", SetupWalkOnly);
		if (UnityEngine.Object.FindObjectOfType<EventSystem>() == null)
		{
			UnityEngine.Debug.LogError("Need EventSystem");
		}
		SetupTwoStickTeleport();
		Physics.IgnoreLayerCollision(0, 4);
	}

	public void Update()
	{
		if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
		{
			if (inMenu)
			{
				DebugUIBuilder.instance.Hide();
			}
			else
			{
				DebugUIBuilder.instance.Show();
			}
			inMenu = !inMenu;
		}
	}

	[Conditional("DEBUG_LOCOMOTION_PANEL")]
	private static void Log(string msg)
	{
		UnityEngine.Debug.Log(msg);
	}

	public static TActivate ActivateCategory<TCategory, TActivate>(GameObject target) where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		TCategory[] components = target.GetComponents<TCategory>();
		Log(string.Concat("Activate ", typeof(TActivate), " derived from ", typeof(TCategory), "[", components.Length, "]"));
		TActivate result = null;
		foreach (MonoBehaviour monoBehaviour in components)
		{
			bool flag = monoBehaviour.GetType() == typeof(TActivate);
			Log(string.Concat(monoBehaviour.GetType(), " is ", typeof(TActivate), " = ", flag.ToString()));
			if (flag)
			{
				result = (TActivate)monoBehaviour;
			}
			if (monoBehaviour.enabled != flag)
			{
				monoBehaviour.enabled = flag;
			}
		}
		return result;
	}

	protected void ActivateHandlers<TInput, TAim, TTarget, TOrientation, TTransition>() where TInput : TeleportInputHandler where TAim : TeleportAimHandler where TTarget : TeleportTargetHandler where TOrientation : TeleportOrientationHandler where TTransition : TeleportTransition
	{
		ActivateInput<TInput>();
		ActivateAim<TAim>();
		ActivateTarget<TTarget>();
		ActivateOrientation<TOrientation>();
		ActivateTransition<TTransition>();
	}

	protected void ActivateInput<TActivate>() where TActivate : TeleportInputHandler
	{
		ActivateCategory<TeleportInputHandler, TActivate>();
	}

	protected void ActivateAim<TActivate>() where TActivate : TeleportAimHandler
	{
		ActivateCategory<TeleportAimHandler, TActivate>();
	}

	protected void ActivateTarget<TActivate>() where TActivate : TeleportTargetHandler
	{
		ActivateCategory<TeleportTargetHandler, TActivate>();
	}

	protected void ActivateOrientation<TActivate>() where TActivate : TeleportOrientationHandler
	{
		ActivateCategory<TeleportOrientationHandler, TActivate>();
	}

	protected void ActivateTransition<TActivate>() where TActivate : TeleportTransition
	{
		ActivateCategory<TeleportTransition, TActivate>();
	}

	protected TActivate ActivateCategory<TCategory, TActivate>() where TCategory : MonoBehaviour where TActivate : MonoBehaviour
	{
		return ActivateCategory<TCategory, TActivate>(lc.gameObject);
	}

	protected void UpdateToggle(Toggle toggle, bool enabled)
	{
		if (enabled != toggle.isOn)
		{
			toggle.isOn = enabled;
		}
	}

	private void SetupNonCap()
	{
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.SeparateButtonsForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
	}

	private void SetupTeleportDefaults()
	{
		TeleportController.enabled = true;
		lc.PlayerController.RotationEitherThumbstick = false;
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		TeleportController.EnableRotation(ready: false, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.CapacitiveButtonForAimAndTeleport;
		component.AimButton = OVRInput.RawButton.A;
		component.TeleportButton = OVRInput.RawButton.A;
		component.CapacitiveAimAndTeleportButton = TeleportInputHandlerTouch.AimCapTouchButtons.A;
		component.FastTeleport = false;
		TeleportInputHandlerHMD component2 = TeleportController.GetComponent<TeleportInputHandlerHMD>();
		component2.AimButton = OVRInput.RawButton.A;
		component2.TeleportButton = OVRInput.RawButton.A;
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.LTouch;
	}

	protected GameObject AddInstance(GameObject template, string label)
	{
		GameObject obj = UnityEngine.Object.Instantiate(template);
		obj.transform.SetParent(base.transform, worldPositionStays: false);
		obj.name = label;
		return obj;
	}

	private void SetupNodeTeleport()
	{
		SetupTeleportDefaults();
		SetupNonCap();
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerLaser, TeleportTargetHandlerNode, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportInputHandlerTouch>().AimingController = OVRInput.Controller.RTouch;
	}

	private void SetupTwoStickTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: false, aim: false, pre: false, post: false);
		lc.PlayerController.RotationEitherThumbstick = true;
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.Touch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.Touch;
	}

	private void SetupWalkOnly()
	{
		SetupTeleportDefaults();
		TeleportController.enabled = false;
		lc.PlayerController.EnableLinearMovement = true;
		lc.PlayerController.RotationEitherThumbstick = false;
	}

	private void SetupLeftStrafeRightTeleport()
	{
		SetupTeleportDefaults();
		TeleportController.EnableRotation(ready: true, aim: false, pre: false, post: true);
		TeleportController.EnableMovement(ready: true, aim: false, pre: false, post: false);
		TeleportInputHandlerTouch component = TeleportController.GetComponent<TeleportInputHandlerTouch>();
		component.InputMode = TeleportInputHandlerTouch.InputModes.ThumbstickTeleportForwardBackOnly;
		component.AimingController = OVRInput.Controller.RTouch;
		ActivateHandlers<TeleportInputHandlerTouch, TeleportAimHandlerParabolic, TeleportTargetHandlerPhysical, TeleportOrientationHandlerThumbstick, TeleportTransitionBlink>();
		TeleportController.GetComponent<TeleportOrientationHandlerThumbstick>().Thumbstick = OVRInput.Controller.RTouch;
	}
}
[RequireComponent(typeof(Canvas))]
public class OVROverlayCanvas : MonoBehaviour
{
	public enum DrawMode
	{
		Opaque,
		OpaqueWithClip,
		TransparentDefaultAlpha,
		TransparentCorrectAlpha
	}

	[SerializeField]
	[HideInInspector]
	private Shader _transparentShader;

	[SerializeField]
	[HideInInspector]
	private Shader _opaqueShader;

	private RectTransform _rectTransform;

	private Canvas _canvas;

	private Camera _camera;

	private OVROverlay _overlay;

	private RenderTexture _renderTexture;

	private MeshRenderer _meshRenderer;

	private Mesh _quad;

	private Material _defaultMat;

	public int MaxTextureSize = 1600;

	public int MinTextureSize = 200;

	public float PixelsPerUnit = 1f;

	public int DrawRate = 1;

	public int DrawFrameOffset;

	public bool Expensive;

	public int Layer;

	public DrawMode Opacity = DrawMode.OpaqueWithClip;

	private bool ScaleViewport = UnityEngine.Application.isMobilePlatform;

	private static readonly Plane[] _FrustumPlanes = new Plane[6];

	public bool overlayEnabled
	{
		get
		{
			if ((bool)_overlay)
			{
				return _overlay.enabled;
			}
			return false;
		}
		set
		{
			if ((bool)_overlay)
			{
				_overlay.enabled = value;
				_defaultMat.color = (value ? Color.black : Color.white);
			}
		}
	}

	private void Start()
	{
		_canvas = GetComponent<Canvas>();
		_rectTransform = _canvas.GetComponent<RectTransform>();
		float width = _rectTransform.rect.width;
		float height = _rectTransform.rect.height;
		float num = ((width >= height) ? 1f : (width / height));
		float num2 = ((height >= width) ? 1f : (height / width));
		int num3 = ((!ScaleViewport) ? 8 : 0);
		int num4 = Mathf.CeilToInt(num * (float)(MaxTextureSize - num3 * 2));
		int num5 = Mathf.CeilToInt(num2 * (float)(MaxTextureSize - num3 * 2));
		int num6 = num4 + num3 * 2;
		int num7 = num5 + num3 * 2;
		float x = width * ((float)num6 / (float)num4);
		float num8 = height * ((float)num7 / (float)num5);
		float num9 = (float)num4 / (float)num6;
		float num10 = (float)num5 / (float)num7;
		Vector2 vector = ((Opacity == DrawMode.Opaque) ? new Vector2(0.005f / _rectTransform.lossyScale.x, 0.005f / _rectTransform.lossyScale.y) : Vector2.zero);
		_renderTexture = new RenderTexture(num6, num7, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
		_renderTexture.useMipMap = !ScaleViewport;
		GameObject gameObject = new GameObject(base.name + " Overlay Camera")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject.transform.SetParent(base.transform, worldPositionStays: false);
		_camera = gameObject.AddComponent<Camera>();
		_camera.stereoTargetEye = StereoTargetEyeMask.None;
		_camera.transform.position = base.transform.position - base.transform.forward;
		_camera.orthographic = true;
		_camera.enabled = false;
		_camera.targetTexture = _renderTexture;
		_camera.cullingMask = 1 << base.gameObject.layer;
		_camera.clearFlags = CameraClearFlags.Color;
		_camera.backgroundColor = Color.clear;
		_camera.orthographicSize = 0.5f * num8 * _rectTransform.localScale.y;
		_camera.nearClipPlane = 0.99f;
		_camera.farClipPlane = 1.01f;
		_quad = new Mesh
		{
			name = base.name + " Overlay Quad",
			hideFlags = HideFlags.HideAndDontSave
		};
		_quad.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f),
			new Vector3(-0.5f, 0.5f),
			new Vector3(0.5f, 0.5f),
			new Vector3(0.5f, -0.5f)
		};
		_quad.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		_quad.triangles = new int[6] { 0, 1, 2, 2, 3, 0 };
		_quad.bounds = new Bounds(Vector3.zero, Vector3.one);
		_quad.UploadMeshData(markNoLongerReadable: true);
		switch (Opacity)
		{
		case DrawMode.Opaque:
			_defaultMat = new Material(_opaqueShader);
			break;
		case DrawMode.OpaqueWithClip:
			_defaultMat = new Material(_opaqueShader);
			_defaultMat.EnableKeyword("WITH_CLIP");
			break;
		case DrawMode.TransparentDefaultAlpha:
			_defaultMat = new Material(_transparentShader);
			_defaultMat.EnableKeyword("ALPHA_SQUARED");
			break;
		case DrawMode.TransparentCorrectAlpha:
			_defaultMat = new Material(_transparentShader);
			break;
		}
		_defaultMat.mainTexture = _renderTexture;
		_defaultMat.color = Color.black;
		_defaultMat.mainTextureOffset = new Vector2(0.5f - 0.5f * num9, 0.5f - 0.5f * num10);
		_defaultMat.mainTextureScale = new Vector2(num9, num10);
		GameObject gameObject2 = new GameObject(base.name + " MeshRenderer")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject2.transform.SetParent(base.transform, worldPositionStays: false);
		gameObject2.AddComponent<MeshFilter>().sharedMesh = _quad;
		_meshRenderer = gameObject2.AddComponent<MeshRenderer>();
		_meshRenderer.sharedMaterial = _defaultMat;
		gameObject2.layer = Layer;
		gameObject2.transform.localScale = new Vector3(width - vector.x, height - vector.y, 1f);
		GameObject gameObject3 = new GameObject(base.name + " Overlay")
		{
			hideFlags = (HideFlags.HideInHierarchy | HideFlags.NotEditable)
		};
		gameObject3.transform.SetParent(base.transform, worldPositionStays: false);
		_overlay = gameObject3.AddComponent<OVROverlay>();
		_overlay.isDynamic = true;
		_overlay.noDepthBufferTesting = true;
		_overlay.isAlphaPremultiplied = !UnityEngine.Application.isMobilePlatform;
		_overlay.textures[0] = _renderTexture;
		_overlay.currentOverlayType = OVROverlay.OverlayType.Underlay;
		_overlay.transform.localScale = new Vector3(x, num8, 1f);
		_overlay.useExpensiveSuperSample = Expensive;
	}

	private void OnDestroy()
	{
		UnityEngine.Object.Destroy(_defaultMat);
		UnityEngine.Object.Destroy(_quad);
		UnityEngine.Object.Destroy(_renderTexture);
	}

	private void OnEnable()
	{
		if ((bool)_overlay)
		{
			_meshRenderer.enabled = true;
			_overlay.enabled = true;
		}
		if ((bool)_camera)
		{
			_camera.enabled = true;
		}
	}

	private void OnDisable()
	{
		if ((bool)_overlay)
		{
			_overlay.enabled = false;
			_meshRenderer.enabled = false;
		}
		if ((bool)_camera)
		{
			_camera.enabled = false;
		}
	}

	protected virtual bool ShouldRender()
	{
		if (DrawRate > 1 && Time.frameCount % DrawRate != DrawFrameOffset % DrawRate)
		{
			return false;
		}
		if (Camera.main != null)
		{
			for (int i = 0; i < 2; i++)
			{
				Camera.StereoscopicEye eye = (Camera.StereoscopicEye)i;
				GeometryUtility.CalculateFrustumPlanes(Camera.main.GetStereoProjectionMatrix(eye) * Camera.main.GetStereoViewMatrix(eye), _FrustumPlanes);
				if (GeometryUtility.TestPlanesAABB(_FrustumPlanes, _meshRenderer.bounds))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	private void Update()
	{
		if (ShouldRender())
		{
			if (ScaleViewport && Camera.main != null)
			{
				float magnitude = (Camera.main.transform.position - base.transform.position).magnitude;
				float value = Mathf.Ceil(PixelsPerUnit * Mathf.Max(_rectTransform.rect.width * base.transform.lossyScale.x, _rectTransform.rect.height * base.transform.lossyScale.y) / magnitude / 8f * (float)_renderTexture.height) * 8f;
				value = Mathf.Clamp(value, MinTextureSize, _renderTexture.height);
				float num = value - 2f;
				_camera.orthographicSize = 0.5f * _rectTransform.rect.height * _rectTransform.localScale.y * value / num;
				float num2 = _rectTransform.rect.width / _rectTransform.rect.height;
				float num3 = num * num2;
				float num4 = Mathf.Ceil((num3 + 2f) * 0.5f) * 2f / (float)_renderTexture.width;
				float num5 = value / (float)_renderTexture.height;
				float num6 = ((Opacity == DrawMode.Opaque) ? 1.001f : 0f);
				float num7 = (num3 - num6) / (float)_renderTexture.width;
				float num8 = (num - num6) / (float)_renderTexture.height;
				_camera.rect = new Rect((1f - num4) / 2f, (1f - num5) / 2f, num4, num5);
				Rect rect = new Rect(0.5f - 0.5f * num7, 0.5f - 0.5f * num8, num7, num8);
				_defaultMat.mainTextureOffset = rect.min;
				_defaultMat.mainTextureScale = rect.size;
				_overlay.overrideTextureRectMatrix = true;
				rect.y = 1f - rect.height - rect.y;
				Rect rect2 = new Rect(0f, 0f, 1f, 1f);
				_overlay.SetSrcDestRects(rect, rect, rect2, rect2);
			}
			_camera.Render();
		}
	}
}
public class StartMenu : MonoBehaviour
{
	public OVROverlay overlay;

	public OVROverlay text;

	public OVRCameraRig vrRig;

	private void Start()
	{
		DebugUIBuilder.instance.AddLabel("Select Sample Scene");
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			string scenePathByBuildIndex = SceneUtility.GetScenePathByBuildIndex(i);
			int sceneIndex = i;
			DebugUIBuilder.instance.AddButton(System.IO.Path.GetFileNameWithoutExtension(scenePathByBuildIndex), delegate
			{
				LoadScene(sceneIndex);
			});
		}
		DebugUIBuilder.instance.Show();
	}

	private void LoadScene(int idx)
	{
		DebugUIBuilder.instance.Hide();
		UnityEngine.Debug.Log("Load scene: " + idx);
		SceneManager.LoadScene(idx);
	}
}
[AddComponentMenu("Camera-Control/Mouse Look")]
public class MouseLook : MonoBehaviour
{
	public enum RotationAxes
	{
		MouseXAndY,
		MouseX,
		MouseY
	}

	public RotationAxes axes;

	public float sensitivityX = 15f;

	public float sensitivityY = 15f;

	public float minimumX = -360f;

	public float maximumX = 360f;

	public float minimumY = -60f;

	public float maximumY = 60f;

	private float rotationY;

	private void Update()
	{
		if (axes == RotationAxes.MouseXAndY)
		{
			float y = base.transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityX;
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, y, 0f);
		}
		else if (axes == RotationAxes.MouseX)
		{
			base.transform.Rotate(0f, Input.GetAxis("Mouse X") * sensitivityX, 0f);
		}
		else
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY;
			rotationY = Mathf.Clamp(rotationY, minimumY, maximumY);
			base.transform.localEulerAngles = new Vector3(0f - rotationY, base.transform.localEulerAngles.y, 0f);
		}
	}

	private void Start()
	{
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}
}
public class ONSPAmbisonicsNative : MonoBehaviour
{
	public enum ovrAmbisonicsNativeStatus
	{
		Uninitialized = -1,
		NotEnabled,
		Success,
		StreamError,
		ProcessError,
		MaxStatValue
	}

	private AudioSource source;

	private static int numFOAChannels = 4;

	private static int paramAmbiStat = 6;

	private ovrAmbisonicsNativeStatus currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;

	private void OnEnable()
	{
		source = GetComponent<AudioSource>();
		currentStatus = ovrAmbisonicsNativeStatus.Uninitialized;
		if (source == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not exist.");
			return;
		}
		if (source.spatialize)
		{
			UnityEngine.Debug.Log("Ambisonic WARNING: Turning spatialize field off for Ambisonic sources.");
			source.spatialize = false;
		}
		if (source.clip == null)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource does not contain an audio clip.");
		}
		else if (source.clip.channels != numFOAChannels)
		{
			UnityEngine.Debug.Log("Ambisonic ERROR: AudioSource clip does not have correct number of channels.");
		}
	}

	private void Update()
	{
		if (source == null)
		{
			return;
		}
		float value = 0f;
		source.GetAmbisonicDecoderFloat(paramAmbiStat, out value);
		ovrAmbisonicsNativeStatus ovrAmbisonicsNativeStatus = (ovrAmbisonicsNativeStatus)value;
		if (ovrAmbisonicsNativeStatus != currentStatus)
		{
			switch (ovrAmbisonicsNativeStatus)
			{
			case ovrAmbisonicsNativeStatus.NotEnabled:
				UnityEngine.Debug.Log("Ambisonic Native: Ambisonic not enabled on clip. Check clip field and turn it on");
				break;
			case ovrAmbisonicsNativeStatus.Uninitialized:
				UnityEngine.Debug.Log("Ambisonic Native: Stream uninitialized");
				break;
			case ovrAmbisonicsNativeStatus.Success:
				UnityEngine.Debug.Log("Ambisonic Native: Stream successfully initialized and playing/playable");
				break;
			case ovrAmbisonicsNativeStatus.StreamError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream error (bad input format?)");
				break;
			case ovrAmbisonicsNativeStatus.ProcessError:
				UnityEngine.Debug.Log("Ambisonic Native WARNING: Stream process error (check default speaker setup)");
				break;
			}
		}
		currentStatus = ovrAmbisonicsNativeStatus;
	}
}
public class ONSPAudioSource : MonoBehaviour
{
	private enum Parameters
	{
		P_GAIN,
		P_USEINVSQR,
		P_NEAR,
		P_FAR,
		P_RADIUS,
		P_DISABLE_RFL,
		P_AMBISTAT,
		P_READONLY_GLOBAL_RFL_ENABLED,
		P_READONLY_NUM_VOICES,
		P_SENDLEVEL,
		P_NUM
	}

	public const string strONSPS = "AudioPluginOculusSpatializer";

	[SerializeField]
	private bool enableSpatialization = true;

	[SerializeField]
	private float gain;

	[SerializeField]
	private bool useInvSqr;

	[SerializeField]
	private float near = 0.25f;

	[SerializeField]
	private float far = 250f;

	[SerializeField]
	private float volumetricRadius;

	[SerializeField]
	private float reverbSend;

	[SerializeField]
	private bool enableRfl;

	private static ONSPAudioSource RoomReflectionGizmoAS;

	public bool EnableSpatialization
	{
		get
		{
			return enableSpatialization;
		}
		set
		{
			enableSpatialization = value;
		}
	}

	public float Gain
	{
		get
		{
			return gain;
		}
		set
		{
			gain = Mathf.Clamp(value, 0f, 24f);
		}
	}

	public bool UseInvSqr
	{
		get
		{
			return useInvSqr;
		}
		set
		{
			useInvSqr = value;
		}
	}

	public float Near
	{
		get
		{
			return near;
		}
		set
		{
			near = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float Far
	{
		get
		{
			return far;
		}
		set
		{
			far = Mathf.Clamp(value, 0f, 1000000f);
		}
	}

	public float VolumetricRadius
	{
		get
		{
			return volumetricRadius;
		}
		set
		{
			volumetricRadius = Mathf.Clamp(value, 0f, 1000f);
		}
	}

	public float ReverbSend
	{
		get
		{
			return reverbSend;
		}
		set
		{
			reverbSend = Mathf.Clamp(value, -60f, 20f);
		}
	}

	public bool EnableRfl
	{
		get
		{
			return enableRfl;
		}
		set
		{
			enableRfl = value;
		}
	}

	[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
	private static void OnBeforeSceneLoadRuntimeMethod()
	{
		OSP_SetGlobalVoiceLimit(ONSPSettings.Instance.voiceLimit);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetGlobalRoomReflectionValues(ref bool reflOn, ref bool reverbOn, ref float width, ref float height, ref float length);

	private void Awake()
	{
		AudioSource source = GetComponent<AudioSource>();
		SetParameters(ref source);
	}

	private void Start()
	{
	}

	private void Update()
	{
		AudioSource source = GetComponent<AudioSource>();
		if (!UnityEngine.Application.isPlaying || AudioListener.pause || !source.isPlaying || !source.isActiveAndEnabled)
		{
			source.spatialize = false;
		}
		else
		{
			SetParameters(ref source);
		}
	}

	public void SetParameters(ref AudioSource source)
	{
		source.spatialize = enableSpatialization;
		source.SetSpatializerFloat(0, gain);
		if (useInvSqr)
		{
			source.SetSpatializerFloat(1, 1f);
		}
		else
		{
			source.SetSpatializerFloat(1, 0f);
		}
		source.SetSpatializerFloat(2, near);
		source.SetSpatializerFloat(3, far);
		source.SetSpatializerFloat(4, volumetricRadius);
		if (enableRfl)
		{
			source.SetSpatializerFloat(5, 0f);
		}
		else
		{
			source.SetSpatializerFloat(5, 1f);
		}
		source.SetSpatializerFloat(9, reverbSend);
	}

	private void OnDrawGizmos()
	{
		if (RoomReflectionGizmoAS == null)
		{
			RoomReflectionGizmoAS = this;
		}
		Color color = default(Color);
		color.r = 1f;
		color.g = 0.5f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, Near);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Near);
		color.r = 1f;
		color.g = 0f;
		color.b = 0f;
		color.a = 1f;
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(base.transform.position, Far);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, Far);
		color.r = 1f;
		color.g = 0f;
		color.b = 1f;
		color.a = 1f;
		Gizmos.color = color;
		Gizmos.DrawWireSphere(base.transform.position, VolumetricRadius);
		color.a = 0.1f;
		Gizmos.color = color;
		Gizmos.DrawSphere(base.transform.position, VolumetricRadius);
		if (RoomReflectionGizmoAS == this)
		{
			bool reflOn = false;
			bool reverbOn = false;
			float width = 1f;
			float height = 1f;
			float length = 1f;
			ONSP_GetGlobalRoomReflectionValues(ref reflOn, ref reverbOn, ref width, ref height, ref length);
			if (Camera.main != null && reflOn)
			{
				color = (Gizmos.color = ((!reverbOn) ? Color.cyan : Color.white));
				Gizmos.DrawWireCube(Camera.main.transform.position, new Vector3(width, height, length));
				color.a = 0.1f;
				Gizmos.color = color;
				Gizmos.DrawCube(Camera.main.transform.position, new Vector3(width, height, length));
			}
		}
	}

	private void OnDestroy()
	{
		if (RoomReflectionGizmoAS == this)
		{
			RoomReflectionGizmoAS = null;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_SetGlobalVoiceLimit(int VoiceLimit);
}
public class ONSPProfiler : MonoBehaviour
{
	public bool profilerEnabled;

	private const int DEFAULT_PORT = 2121;

	public int port = 2121;

	public const string strONSPS = "AudioPluginOculusSpatializer";

	private void Start()
	{
		UnityEngine.Application.runInBackground = true;
	}

	private void Update()
	{
		if (port < 0 || port > 65535)
		{
			port = 2121;
		}
		ONSP_SetProfilerPort(port);
		ONSP_SetProfilerEnabled(profilerEnabled);
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerEnabled(bool enabled);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int ONSP_SetProfilerPort(int port);
}
public class ONSPPropagationGeometry : MonoBehaviour
{
	private struct MeshMaterial
	{
		public MeshFilter meshFilter;

		public ONSPPropagationMaterial[] materials;
	}

	private struct TerrainMaterial
	{
		public Terrain terrain;

		public ONSPPropagationMaterial[] materials;

		public Mesh[] treePrototypeMeshes;
	}

	public static string GeometryAssetDirectory = "AudioGeometry";

	public string filePathRelative = "";

	public bool fileEnabled;

	public bool includeChildMeshes = true;

	private IntPtr geometryHandle = IntPtr.Zero;

	public static int OSPSuccess = 0;

	public const string GEOMETRY_FILE_EXTENSION = "ovramesh";

	private static int terrainDecimation = 4;

	public static string GeometryAssetPath => UnityEngine.Application.streamingAssetsPath + "/" + GeometryAssetDirectory;

	public string filePath => GeometryAssetPath + "/" + filePathRelative;

	private static string GetPath(Transform current)
	{
		if (current.parent == null)
		{
			return current.gameObject.scene.name + "/" + current.name;
		}
		return GetPath(current.parent) + "-" + current.name;
	}

	private void Awake()
	{
		CreatePropagationGeometry();
	}

	private void CreatePropagationGeometry()
	{
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to create geometry handle");
		}
		if (filePath != null && filePath.Length != 0 && fileEnabled && UnityEngine.Application.isPlaying)
		{
			if (!ReadFile())
			{
				UnityEngine.Debug.LogError("Failed to read file, attempting to regenerate audio geometry");
				UploadGeometry();
			}
		}
		else
		{
			UploadGeometry();
		}
	}

	private void Update()
	{
		if (!(geometryHandle == IntPtr.Zero))
		{
			Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
			float[] matrix4x = new float[16]
			{
				localToWorldMatrix[0, 0],
				localToWorldMatrix[1, 0],
				0f - localToWorldMatrix[2, 0],
				localToWorldMatrix[3, 0],
				localToWorldMatrix[0, 1],
				localToWorldMatrix[1, 1],
				0f - localToWorldMatrix[2, 1],
				localToWorldMatrix[3, 1],
				localToWorldMatrix[0, 2],
				localToWorldMatrix[1, 2],
				0f - localToWorldMatrix[2, 2],
				localToWorldMatrix[3, 2],
				localToWorldMatrix[0, 3],
				localToWorldMatrix[1, 3],
				0f - localToWorldMatrix[2, 3],
				localToWorldMatrix[3, 3]
			};
			ONSPPropagation.Interface.AudioGeometrySetTransform(geometryHandle, matrix4x);
		}
	}

	private void OnDestroy()
	{
		if (geometryHandle != IntPtr.Zero && ONSPPropagation.Interface.DestroyAudioGeometry(geometryHandle) != OSPSuccess)
		{
			throw new Exception("Unable to destroy geometry");
		}
		geometryHandle = IntPtr.Zero;
	}

	private static void traverseMeshHierarchy(GameObject obj, ONSPPropagationMaterial[] currentMaterials, bool includeChildren, List<MeshMaterial> meshMaterials, List<TerrainMaterial> terrainMaterials, bool ignoreStatic, ref int ignoredMeshCount)
	{
		if (!obj.activeInHierarchy)
		{
			return;
		}
		MeshFilter[] components = obj.GetComponents<MeshFilter>();
		Terrain[] components2 = obj.GetComponents<Terrain>();
		ONSPPropagationMaterial[] components3 = obj.GetComponents<ONSPPropagationMaterial>();
		if (components3 != null && components3.Length != 0)
		{
			int num = components3.Length;
			if (currentMaterials != null)
			{
				num = Math.Max(num, currentMaterials.Length);
			}
			ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[num];
			if (currentMaterials != null)
			{
				for (int i = components3.Length; i < num; i++)
				{
					array[i] = currentMaterials[i];
				}
			}
			currentMaterials = array;
			for (int j = 0; j < components3.Length; j++)
			{
				currentMaterials[j] = components3[j];
			}
		}
		MeshFilter[] array2 = components;
		foreach (MeshFilter meshFilter in array2)
		{
			Mesh sharedMesh = meshFilter.sharedMesh;
			if (!(sharedMesh == null))
			{
				if (ignoreStatic && !sharedMesh.isReadable)
				{
					UnityEngine.Debug.LogWarning("Mesh: " + meshFilter.gameObject.name + " not readable, cannot be static.", meshFilter.gameObject);
					ignoredMeshCount++;
					continue;
				}
				MeshMaterial item = default(MeshMaterial);
				item.meshFilter = meshFilter;
				item.materials = currentMaterials;
				meshMaterials.Add(item);
			}
		}
		Terrain[] array3 = components2;
		foreach (Terrain terrain in array3)
		{
			TerrainMaterial item2 = default(TerrainMaterial);
			item2.terrain = terrain;
			item2.materials = currentMaterials;
			terrainMaterials.Add(item2);
		}
		if (!includeChildren)
		{
			return;
		}
		foreach (Transform item3 in obj.transform)
		{
			if (item3.GetComponent<ONSPPropagationGeometry>() == null)
			{
				traverseMeshHierarchy(item3.gameObject, currentMaterials, includeChildren, meshMaterials, terrainMaterials, ignoreStatic, ref ignoredMeshCount);
			}
		}
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal)
	{
		int ignoredMeshCount = 0;
		return uploadMesh(geometryHandle, meshObject, worldToLocal, ignoreStatic: false, ref ignoredMeshCount);
	}

	private int uploadMesh(IntPtr geometryHandle, GameObject meshObject, Matrix4x4 worldToLocal, bool ignoreStatic, ref int ignoredMeshCount)
	{
		List<MeshMaterial> list = new List<MeshMaterial>();
		List<TerrainMaterial> list2 = new List<TerrainMaterial>();
		traverseMeshHierarchy(meshObject, null, includeChildMeshes, list, list2, ignoreStatic, ref ignoredMeshCount);
		int totalVertexCount = 0;
		uint totalIndexCount = 0u;
		int totalFaceCount = 0;
		int totalMaterialCount = 0;
		foreach (MeshMaterial item in list)
		{
			updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, item.meshFilter.sharedMesh);
		}
		ONSPPropagationMaterial[] array = new ONSPPropagationMaterial[1];
		for (int i = 0; i < list2.Count; i++)
		{
			TerrainMaterial value = list2[i];
			TerrainData terrainData = value.terrain.terrainData;
			int heightmapResolution = terrainData.heightmapResolution;
			int heightmapResolution2 = terrainData.heightmapResolution;
			int num = (heightmapResolution - 1) / terrainDecimation + 1;
			int num2 = (heightmapResolution2 - 1) / terrainDecimation + 1;
			int num3 = num * num2;
			int num4 = (num - 1) * (num2 - 1) * 6;
			totalMaterialCount++;
			totalVertexCount += num3;
			totalIndexCount += (uint)num4;
			totalFaceCount += num4 / 3;
			TreePrototype[] treePrototypes = terrainData.treePrototypes;
			if (treePrototypes.Length == 0)
			{
				continue;
			}
			if (array[0] == null)
			{
				array[0] = base.gameObject.AddComponent<ONSPPropagationMaterial>();
				array[0].SetPreset(ONSPPropagationMaterial.Preset.Foliage);
			}
			value.treePrototypeMeshes = new Mesh[treePrototypes.Length];
			for (int j = 0; j < treePrototypes.Length; j++)
			{
				MeshFilter[] componentsInChildren = treePrototypes[j].prefab.GetComponentsInChildren<MeshFilter>();
				int num5 = int.MaxValue;
				int num6 = -1;
				for (int k = 0; k < componentsInChildren.Length; k++)
				{
					int vertexCount = componentsInChildren[k].sharedMesh.vertexCount;
					if (vertexCount < num5)
					{
						num5 = vertexCount;
						num6 = k;
					}
				}
				value.treePrototypeMeshes[j] = componentsInChildren[num6].sharedMesh;
			}
			TreeInstance[] treeInstances = terrainData.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance = treeInstances[l];
				updateCountsForMesh(ref totalVertexCount, ref totalIndexCount, ref totalFaceCount, ref totalMaterialCount, value.treePrototypeMeshes[treeInstance.prototypeIndex]);
			}
			list2[i] = value;
		}
		List<Vector3> tempVertices = new List<Vector3>();
		List<int> tempIndices = new List<int>();
		MeshGroup[] array2 = new MeshGroup[totalMaterialCount];
		float[] array3 = new float[totalVertexCount * 3];
		int[] array4 = new int[totalIndexCount];
		int vertexOffset = 0;
		int indexOffset = 0;
		int groupOffset = 0;
		foreach (MeshMaterial item2 in list)
		{
			MeshFilter meshFilter = item2.meshFilter;
			Matrix4x4 matrix = worldToLocal * meshFilter.gameObject.transform.localToWorldMatrix;
			uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, meshFilter.sharedMesh, item2.materials, matrix);
		}
		foreach (TerrainMaterial item3 in list2)
		{
			TerrainData terrainData2 = item3.terrain.terrainData;
			Matrix4x4 matrix4x = worldToLocal * item3.terrain.gameObject.transform.localToWorldMatrix;
			int heightmapResolution3 = terrainData2.heightmapResolution;
			int heightmapResolution4 = terrainData2.heightmapResolution;
			float[,] heights = terrainData2.GetHeights(0, 0, heightmapResolution3, heightmapResolution4);
			Vector3 size = terrainData2.size;
			size = new Vector3(size.x / (float)(heightmapResolution3 - 1) * (float)terrainDecimation, size.y, size.z / (float)(heightmapResolution4 - 1) * (float)terrainDecimation);
			int num7 = (heightmapResolution3 - 1) / terrainDecimation + 1;
			int num8 = (heightmapResolution4 - 1) / terrainDecimation + 1;
			int num9 = num7 * num8;
			int num10 = (num7 - 1) * (num8 - 1) * 2;
			array2[groupOffset].faceType = FaceType.TRIANGLES;
			array2[groupOffset].faceCount = (UIntPtr)(ulong)num10;
			array2[groupOffset].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (item3.materials != null && item3.materials.Length != 0)
			{
				item3.materials[0].StartInternal();
				array2[groupOffset].material = item3.materials[0].materialHandle;
			}
			else
			{
				array2[groupOffset].material = IntPtr.Zero;
			}
			for (int m = 0; m < num8; m++)
			{
				for (int n = 0; n < num7; n++)
				{
					int num11 = (vertexOffset + m * num7 + n) * 3;
					Vector3 vector = matrix4x.MultiplyPoint3x4(Vector3.Scale(size, new Vector3(m, heights[n * terrainDecimation, m * terrainDecimation], n)));
					array3[num11] = vector.x;
					array3[num11 + 1] = vector.y;
					array3[num11 + 2] = vector.z;
				}
			}
			for (int num12 = 0; num12 < num8 - 1; num12++)
			{
				for (int num13 = 0; num13 < num7 - 1; num13++)
				{
					array4[indexOffset] = vertexOffset + num12 * num7 + num13;
					array4[indexOffset + 1] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 2] = vertexOffset + num12 * num7 + num13 + 1;
					array4[indexOffset + 3] = vertexOffset + (num12 + 1) * num7 + num13;
					array4[indexOffset + 4] = vertexOffset + (num12 + 1) * num7 + num13 + 1;
					array4[indexOffset + 5] = vertexOffset + num12 * num7 + num13 + 1;
					indexOffset += 6;
				}
			}
			vertexOffset += num9;
			groupOffset++;
			TreeInstance[] treeInstances = terrainData2.treeInstances;
			for (int l = 0; l < treeInstances.Length; l++)
			{
				TreeInstance treeInstance2 = treeInstances[l];
				Vector3 vector2 = Vector3.Scale(treeInstance2.position, terrainData2.size);
				Matrix4x4 localToWorldMatrix = item3.terrain.gameObject.transform.localToWorldMatrix;
				localToWorldMatrix.SetColumn(3, localToWorldMatrix.GetColumn(3) + new Vector4(vector2.x, vector2.y, vector2.z, 0f));
				Matrix4x4 matrix2 = worldToLocal * localToWorldMatrix;
				uploadMeshFilter(tempVertices, tempIndices, array2, array3, array4, ref vertexOffset, ref indexOffset, ref groupOffset, item3.treePrototypeMeshes[treeInstance2.prototypeIndex], array, matrix2);
			}
		}
		return ONSPPropagation.Interface.AudioGeometryUploadMeshArrays(geometryHandle, array3, totalVertexCount, array4, array4.Length, array2, array2.Length);
	}

	private static void uploadMeshFilter(List<Vector3> tempVertices, List<int> tempIndices, MeshGroup[] groups, float[] vertices, int[] indices, ref int vertexOffset, ref int indexOffset, ref int groupOffset, Mesh mesh, ONSPPropagationMaterial[] materials, Matrix4x4 matrix)
	{
		tempVertices.Clear();
		mesh.GetVertices(tempVertices);
		int count = tempVertices.Count;
		for (int i = 0; i < count; i++)
		{
			Vector3 vector = matrix.MultiplyPoint3x4(tempVertices[i]);
			int num = (vertexOffset + i) * 3;
			vertices[num] = vector.x;
			vertices[num + 1] = vector.y;
			vertices[num + 2] = vector.z;
		}
		for (int j = 0; j < mesh.subMeshCount; j++)
		{
			MeshTopology topology = mesh.GetTopology(j);
			if (topology != 0 && topology != MeshTopology.Quads)
			{
				continue;
			}
			tempIndices.Clear();
			mesh.GetIndices(tempIndices, j);
			int count2 = tempIndices.Count;
			for (int k = 0; k < count2; k++)
			{
				indices[indexOffset + k] = tempIndices[k] + vertexOffset;
			}
			switch (topology)
			{
			case MeshTopology.Triangles:
				groups[groupOffset + j].faceType = FaceType.TRIANGLES;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 3);
				break;
			case MeshTopology.Quads:
				groups[groupOffset + j].faceType = FaceType.QUADS;
				groups[groupOffset + j].faceCount = (UIntPtr)(ulong)(count2 / 4);
				break;
			}
			groups[groupOffset + j].indexOffset = (UIntPtr)(ulong)indexOffset;
			if (materials != null && materials.Length != 0)
			{
				int num2 = j;
				if (num2 >= materials.Length)
				{
					num2 = materials.Length - 1;
				}
				materials[num2].StartInternal();
				groups[groupOffset + j].material = materials[num2].materialHandle;
			}
			else
			{
				groups[groupOffset + j].material = IntPtr.Zero;
			}
			indexOffset += count2;
		}
		vertexOffset += count;
		groupOffset += mesh.subMeshCount;
	}

	private static void updateCountsForMesh(ref int totalVertexCount, ref uint totalIndexCount, ref int totalFaceCount, ref int totalMaterialCount, Mesh mesh)
	{
		totalMaterialCount += mesh.subMeshCount;
		totalVertexCount += mesh.vertexCount;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			MeshTopology topology = mesh.GetTopology(i);
			if (topology == MeshTopology.Triangles || topology == MeshTopology.Quads)
			{
				uint indexCount = mesh.GetIndexCount(i);
				totalIndexCount += indexCount;
				switch (topology)
				{
				case MeshTopology.Triangles:
					totalFaceCount += (int)indexCount / 3;
					break;
				case MeshTopology.Quads:
					totalFaceCount += (int)indexCount / 4;
					break;
				}
			}
		}
	}

	public void UploadGeometry()
	{
		int ignoredMeshCount = 0;
		if (uploadMesh(geometryHandle, base.gameObject, base.gameObject.transform.worldToLocalMatrix, ignoreStatic: true, ref ignoredMeshCount) != OSPSuccess)
		{
			throw new Exception("Unable to upload audio mesh geometry");
		}
		if (ignoredMeshCount != 0)
		{
			UnityEngine.Debug.LogError("Failed to upload meshes, " + ignoredMeshCount + " static meshes ignored. Turn on \"File Enabled\" to process static meshes offline", base.gameObject);
		}
	}

	public bool ReadFile()
	{
		if (filePath == null || filePath.Length == 0)
		{
			UnityEngine.Debug.LogError("Invalid mesh file path");
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryReadMeshFile(geometryHandle, filePath) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error reading mesh file " + filePath);
			return false;
		}
		return true;
	}

	public bool WriteToObj()
	{
		IntPtr geometry = IntPtr.Zero;
		if (ONSPPropagation.Interface.CreateAudioGeometry(out geometry) != OSPSuccess)
		{
			throw new Exception("Failed to create temp geometry handle");
		}
		if (uploadMesh(geometry, base.gameObject, base.gameObject.transform.worldToLocalMatrix) != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error uploading mesh " + base.gameObject.name);
			return false;
		}
		if (ONSPPropagation.Interface.AudioGeometryWriteMeshFileObj(geometry, filePath + ".obj") != OSPSuccess)
		{
			UnityEngine.Debug.LogError("Error writing .obj file " + filePath + ".obj");
			return false;
		}
		if (ONSPPropagation.Interface.DestroyAudioGeometry(geometry) != OSPSuccess)
		{
			throw new Exception("Failed to destroy temp geometry handle");
		}
		return true;
	}
}
internal class ONSPPropagation
{
	public enum ovrAudioScalarType : uint
	{
		Int8,
		UInt8,
		Int16,
		UInt16,
		Int32,
		UInt32,
		Int64,
		UInt64,
		Float16,
		Float32,
		Float64
	}

	public class ClientType
	{
		public const uint OVRA_CLIENT_TYPE_NATIVE = 0u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2016 = 1u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_1 = 2u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2017_2 = 3u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2018_1 = 4u;

		public const uint OVRA_CLIENT_TYPE_FMOD = 5u;

		public const uint OVRA_CLIENT_TYPE_UNITY = 6u;

		public const uint OVRA_CLIENT_TYPE_UE4 = 7u;

		public const uint OVRA_CLIENT_TYPE_VST = 8u;

		public const uint OVRA_CLIENT_TYPE_AAX = 9u;

		public const uint OVRA_CLIENT_TYPE_TEST = 10u;

		public const uint OVRA_CLIENT_TYPE_OTHER = 11u;

		public const uint OVRA_CLIENT_TYPE_WWISE_UNKNOWN = 12u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_1 = 13u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2019_2 = 14u;

		public const uint OVRA_CLIENT_TYPE_WWISE_2021_1 = 15u;
	}

	public interface PropagationInterface
	{
		int SetPropagationQuality(float quality);

		int SetPropagationThreadAffinity(ulong cpuMask);

		int CreateAudioGeometry(out IntPtr geometry);

		int DestroyAudioGeometry(IntPtr geometry);

		int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount);

		int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		int CreateAudioMaterial(out IntPtr material);

		int DestroyAudioMaterial(IntPtr material);

		int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		int AudioMaterialReset(IntPtr material, MaterialProperty property);
	}

	public class UnityNativeInterface : PropagationInterface
	{
		public const string strOSPS = "AudioPluginOculusSpatializer";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 6u);
				}
				return context_;
			}
		}

		[DllImport("AudioPluginOculusSpatializer")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("AudioPluginOculusSpatializer")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class WwisePluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerWwise";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 12u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerWwise")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerWwise")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	public class FMODPluginInterface : PropagationInterface
	{
		public const string strOSPS = "OculusSpatializerFMOD";

		private IntPtr context_ = IntPtr.Zero;

		private IntPtr context
		{
			get
			{
				if (context_ == IntPtr.Zero)
				{
					ovrAudio_GetPluginContext(out context_, 5u);
				}
				return context_;
			}
		}

		[DllImport("OculusSpatializerFMOD")]
		public static extern int ovrAudio_GetPluginContext(out IntPtr context, uint clientType);

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationQuality(IntPtr context, float quality);

		public int SetPropagationQuality(float quality)
		{
			return ovrAudio_SetPropagationQuality(context, quality);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_SetPropagationThreadAffinity(IntPtr context, ulong cpuMask);

		public int SetPropagationThreadAffinity(ulong cpuMask)
		{
			return ovrAudio_SetPropagationThreadAffinity(context, cpuMask);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioGeometry(IntPtr context, out IntPtr geometry);

		public int CreateAudioGeometry(out IntPtr geometry)
		{
			return ovrAudio_CreateAudioGeometry(context, out geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioGeometry(IntPtr geometry);

		public int DestroyAudioGeometry(IntPtr geometry)
		{
			return ovrAudio_DestroyAudioGeometry(geometry);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, UIntPtr verticesBytesOffset, UIntPtr vertexCount, UIntPtr vertexStride, ovrAudioScalarType vertexType, int[] indices, UIntPtr indicesByteOffset, UIntPtr indexCount, ovrAudioScalarType indexType, MeshGroup[] groups, UIntPtr groupCount);

		public int AudioGeometryUploadMeshArrays(IntPtr geometry, float[] vertices, int vertexCount, int[] indices, int indexCount, MeshGroup[] groups, int groupCount)
		{
			return ovrAudio_AudioGeometryUploadMeshArrays(geometry, vertices, UIntPtr.Zero, (UIntPtr)(ulong)vertexCount, UIntPtr.Zero, ovrAudioScalarType.Float32, indices, UIntPtr.Zero, (UIntPtr)(ulong)indexCount, ovrAudioScalarType.UInt32, groups, (UIntPtr)(ulong)groupCount);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4);

		public int AudioGeometrySetTransform(IntPtr geometry, float[] matrix4x4)
		{
			return ovrAudio_AudioGeometrySetTransform(geometry, matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4);

		public int AudioGeometryGetTransform(IntPtr geometry, out float[] matrix4x4)
		{
			return ovrAudio_AudioGeometryGetTransform(geometry, out matrix4x4);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryReadMeshFile(IntPtr geometry, string filePath);

		public int AudioGeometryReadMeshFile(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryReadMeshFile(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath);

		public int AudioGeometryWriteMeshFileObj(IntPtr geometry, string filePath)
		{
			return ovrAudio_AudioGeometryWriteMeshFileObj(geometry, filePath);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_CreateAudioMaterial(IntPtr context, out IntPtr material);

		public int CreateAudioMaterial(out IntPtr material)
		{
			return ovrAudio_CreateAudioMaterial(context, out material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_DestroyAudioMaterial(IntPtr material);

		public int DestroyAudioMaterial(IntPtr material)
		{
			return ovrAudio_DestroyAudioMaterial(material);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value);

		public int AudioMaterialSetFrequency(IntPtr material, MaterialProperty property, float frequency, float value)
		{
			return ovrAudio_AudioMaterialSetFrequency(material, property, frequency, value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value);

		public int AudioMaterialGetFrequency(IntPtr material, MaterialProperty property, float frequency, out float value)
		{
			return ovrAudio_AudioMaterialGetFrequency(material, property, frequency, out value);
		}

		[DllImport("OculusSpatializerFMOD")]
		private static extern int ovrAudio_AudioMaterialReset(IntPtr material, MaterialProperty property);

		public int AudioMaterialReset(IntPtr material, MaterialProperty property)
		{
			return ovrAudio_AudioMaterialReset(material, property);
		}
	}

	private static PropagationInterface CachedInterface;

	public static PropagationInterface Interface
	{
		get
		{
			if (CachedInterface == null)
			{
				CachedInterface = FindInterface();
			}
			return CachedInterface;
		}
	}

	private static PropagationInterface FindInterface()
	{
		IntPtr context;
		try
		{
			WwisePluginInterface.ovrAudio_GetPluginContext(out context, 12u);
			UnityEngine.Debug.Log("Propagation initialized with Wwise Oculus Spatializer plugin");
			return new WwisePluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		try
		{
			FMODPluginInterface.ovrAudio_GetPluginContext(out context, 5u);
			UnityEngine.Debug.Log("Propagation initialized with FMOD Oculus Spatializer plugin");
			return new FMODPluginInterface();
		}
		catch (DllNotFoundException)
		{
		}
		UnityEngine.Debug.Log("Propagation initialized with Unity Oculus Spatializer plugin");
		return new UnityNativeInterface();
	}
}
public sealed class ONSPPropagationMaterial : MonoBehaviour
{
	public enum Preset
	{
		Custom,
		AcousticTile,
		Brick,
		BrickPainted,
		Carpet,
		CarpetHeavy,
		CarpetHeavyPadded,
		CeramicTile,
		Concrete,
		ConcreteRough,
		ConcreteBlock,
		ConcreteBlockPainted,
		Curtain,
		Foliage,
		Glass,
		GlassHeavy,
		Grass,
		Gravel,
		GypsumBoard,
		PlasterOnBrick,
		PlasterOnConcreteBlock,
		Soil,
		SoundProof,
		Snow,
		Steel,
		Water,
		WoodThin,
		WoodThick,
		WoodFloor,
		WoodOnConcrete
	}

	[Serializable]
	public sealed class Point
	{
		public float frequency;

		public float data;

		public Point(float frequency = 0f, float data = 0f)
		{
			this.frequency = frequency;
			this.data = data;
		}

		public static implicit operator Point(Vector2 v)
		{
			return new Point(v.x, v.y);
		}

		public static implicit operator Vector2(Point point)
		{
			return new Vector2(point.frequency, point.data);
		}
	}

	[Serializable]
	public sealed class Spectrum
	{
		public int selection = int.MaxValue;

		public List<Point> points = new List<Point>();

		public float this[float f]
		{
			get
			{
				if (points.Count > 0)
				{
					Point point = new Point(float.MinValue);
					Point point2 = new Point(float.MaxValue);
					foreach (Point point3 in points)
					{
						if (point3.frequency < f)
						{
							if (point3.frequency > point.frequency)
							{
								point = point3;
							}
						}
						else if (point3.frequency < point2.frequency)
						{
							point2 = point3;
						}
					}
					if (point.frequency == float.MinValue)
					{
						point.data = points.OrderBy((Point p) => p.frequency).First().data;
					}
					if (point2.frequency == float.MaxValue)
					{
						point2.data = points.OrderBy((Point p) => p.frequency).Last().data;
					}
					return point.data + (f - point.frequency) * (point2.data - point.data) / (point2.frequency - point.frequency);
				}
				return 0f;
			}
		}
	}

	public IntPtr materialHandle = IntPtr.Zero;

	[UnityEngine.Tooltip("Absorption")]
	public Spectrum absorption = new Spectrum();

	[UnityEngine.Tooltip("Transmission")]
	public Spectrum transmission = new Spectrum();

	[UnityEngine.Tooltip("Scattering")]
	public Spectrum scattering = new Spectrum();

	[SerializeField]
	private Preset preset_;

	public Preset preset
	{
		get
		{
			return preset_;
		}
		set
		{
			SetPreset(value);
			preset_ = value;
		}
	}

	private void Start()
	{
		StartInternal();
	}

	public void StartInternal()
	{
		if (!(materialHandle != IntPtr.Zero))
		{
			if (ONSPPropagation.Interface.CreateAudioMaterial(out materialHandle) != ONSPPropagationGeometry.OSPSuccess)
			{
				throw new Exception("Unable to create internal audio material");
			}
			UploadMaterial();
		}
	}

	private void OnDestroy()
	{
		DestroyInternal();
	}

	public void DestroyInternal()
	{
		if (materialHandle != IntPtr.Zero)
		{
			ONSPPropagation.Interface.DestroyAudioMaterial(materialHandle);
			materialHandle = IntPtr.Zero;
		}
	}

	public void UploadMaterial()
	{
		if (materialHandle == IntPtr.Zero)
		{
			return;
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.ABSORPTION);
		foreach (Point point in absorption.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.ABSORPTION, point.frequency, point.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.TRANSMISSION);
		foreach (Point point2 in transmission.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.TRANSMISSION, point2.frequency, point2.data);
		}
		ONSPPropagation.Interface.AudioMaterialReset(materialHandle, MaterialProperty.SCATTERING);
		foreach (Point point3 in scattering.points)
		{
			ONSPPropagation.Interface.AudioMaterialSetFrequency(materialHandle, MaterialProperty.SCATTERING, point3.frequency, point3.data);
		}
	}

	public void SetPreset(Preset preset)
	{
		ONSPPropagationMaterial material = this;
		switch (preset)
		{
		case Preset.AcousticTile:
			AcousticTile(ref material);
			break;
		case Preset.Brick:
			Brick(ref material);
			break;
		case Preset.BrickPainted:
			BrickPainted(ref material);
			break;
		case Preset.Carpet:
			Carpet(ref material);
			break;
		case Preset.CarpetHeavy:
			CarpetHeavy(ref material);
			break;
		case Preset.CarpetHeavyPadded:
			CarpetHeavyPadded(ref material);
			break;
		case Preset.CeramicTile:
			CeramicTile(ref material);
			break;
		case Preset.Concrete:
			Concrete(ref material);
			break;
		case Preset.ConcreteRough:
			ConcreteRough(ref material);
			break;
		case Preset.ConcreteBlock:
			ConcreteBlock(ref material);
			break;
		case Preset.ConcreteBlockPainted:
			ConcreteBlockPainted(ref material);
			break;
		case Preset.Curtain:
			Curtain(ref material);
			break;
		case Preset.Foliage:
			Foliage(ref material);
			break;
		case Preset.Glass:
			Glass(ref material);
			break;
		case Preset.GlassHeavy:
			GlassHeavy(ref material);
			break;
		case Preset.Grass:
			Grass(ref material);
			break;
		case Preset.Gravel:
			Gravel(ref material);
			break;
		case Preset.GypsumBoard:
			GypsumBoard(ref material);
			break;
		case Preset.PlasterOnBrick:
			PlasterOnBrick(ref material);
			break;
		case Preset.PlasterOnConcreteBlock:
			PlasterOnConcreteBlock(ref material);
			break;
		case Preset.Soil:
			Soil(ref material);
			break;
		case Preset.SoundProof:
			SoundProof(ref material);
			break;
		case Preset.Snow:
			Snow(ref material);
			break;
		case Preset.Steel:
			Steel(ref material);
			break;
		case Preset.Water:
			Water(ref material);
			break;
		case Preset.WoodThin:
			WoodThin(ref material);
			break;
		case Preset.WoodThick:
			WoodThick(ref material);
			break;
		case Preset.WoodFloor:
			WoodFloor(ref material);
			break;
		case Preset.WoodOnConcrete:
			WoodOnConcrete(ref material);
			break;
		case Preset.Custom:
			break;
		}
	}

	private static void AcousticTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.5f),
			new Point(250f, 0.7f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.5f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.04f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.005f),
			new Point(4000f, 0.002f)
		};
	}

	private static void Brick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.02f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void BrickPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.2f),
			new Point(4000f, 0.25f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void Carpet(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.05f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.45f),
			new Point(4000f, 0.65f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.06f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.37f),
			new Point(2000f, 0.48f),
			new Point(4000f, 0.63f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CarpetHeavyPadded(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.08f),
			new Point(250f, 0.24f),
			new Point(500f, 0.57f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.71f),
			new Point(4000f, 0.73f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.25f),
			new Point(2000f, 0.35f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void CeramicTile(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.01f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.14f),
			new Point(1000f, 0.16f),
			new Point(2000f, 0.18f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void Concrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteRough(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.08f),
			new Point(4000f, 0.1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.25f),
			new Point(4000f, 0.3f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}

	private static void ConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.36f),
			new Point(250f, 0.44f),
			new Point(500f, 0.31f),
			new Point(1000f, 0.29f),
			new Point(2000f, 0.39f),
			new Point(4000f, 0.21f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.12f),
			new Point(500f, 0.15f),
			new Point(1000f, 0.2f),
			new Point(2000f, 0.3f),
			new Point(4000f, 0.4f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void ConcreteBlockPainted(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.05f),
			new Point(500f, 0.06f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.09f),
			new Point(4000f, 0.08f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.13f),
			new Point(1000f, 0.15f),
			new Point(2000f, 0.16f),
			new Point(4000f, 0.2f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Curtain(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.07f),
			new Point(250f, 0.31f),
			new Point(500f, 0.49f),
			new Point(1000f, 0.75f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.15f),
			new Point(500f, 0.2f),
			new Point(1000f, 0.3f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.5f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.39f),
			new Point(500f, 0.21f),
			new Point(1000f, 0.14f),
			new Point(2000f, 0.079f),
			new Point(4000f, 0.045f)
		};
	}

	private static void Foliage(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.06f),
			new Point(500f, 0.11f),
			new Point(1000f, 0.17f),
			new Point(2000f, 0.27f),
			new Point(4000f, 0.31f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.7f),
			new Point(4000f, 0.8f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.9f),
			new Point(250f, 0.9f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.8f),
			new Point(2000f, 0.5f),
			new Point(4000f, 0.3f)
		};
	}

	private static void Glass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.35f),
			new Point(250f, 0.25f),
			new Point(500f, 0.18f),
			new Point(1000f, 0.12f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.125f),
			new Point(250f, 0.089f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.022f),
			new Point(4000f, 0.079f)
		};
	}

	private static void GlassHeavy(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.18f),
			new Point(250f, 0.06f),
			new Point(500f, 0.04f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.05f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.056f),
			new Point(250f, 0.039f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.032f),
			new Point(4000f, 0.014f)
		};
	}

	private static void Grass(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.11f),
			new Point(250f, 0.26f),
			new Point(500f, 0.6f),
			new Point(1000f, 0.69f),
			new Point(2000f, 0.92f),
			new Point(4000f, 0.99f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.3f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Gravel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.6f),
			new Point(500f, 0.65f),
			new Point(1000f, 0.7f),
			new Point(2000f, 0.75f),
			new Point(4000f, 0.8f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void GypsumBoard(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.29f),
			new Point(250f, 0.1f),
			new Point(500f, 0.05f),
			new Point(1000f, 0.04f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.09f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.11f),
			new Point(500f, 0.12f),
			new Point(1000f, 0.13f),
			new Point(2000f, 0.14f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.0125f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0025f),
			new Point(2000f, 0.0013f),
			new Point(4000f, 0.0032f)
		};
	}

	private static void PlasterOnBrick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.02f),
			new Point(500f, 0.02f),
			new Point(1000f, 0.03f),
			new Point(2000f, 0.04f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.025f),
			new Point(250f, 0.019f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.0045f),
			new Point(2000f, 0.0018f),
			new Point(4000f, 0.00089f)
		};
	}

	private static void PlasterOnConcreteBlock(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.12f),
			new Point(250f, 0.09f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.05f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.04f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.25f),
			new Point(500f, 0.3f),
			new Point(1000f, 0.35f),
			new Point(2000f, 0.4f),
			new Point(4000f, 0.45f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.02f),
			new Point(250f, 0.01f),
			new Point(500f, 0.0063f),
			new Point(1000f, 0.0035f),
			new Point(2000f, 0.00011f),
			new Point(4000f, 0.00063f)
		};
	}

	private static void Soil(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.25f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.55f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.6f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.2f),
			new Point(500f, 0.25f),
			new Point(1000f, 0.4f),
			new Point(2000f, 0.55f),
			new Point(4000f, 0.7f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void SoundProof(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(1000f, 1f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(1000f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Snow(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.45f),
			new Point(250f, 0.75f),
			new Point(500f, 0.9f),
			new Point(1000f, 0.95f),
			new Point(2000f, 0.95f),
			new Point(4000f, 0.95f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.3f),
			new Point(500f, 0.4f),
			new Point(1000f, 0.5f),
			new Point(2000f, 0.6f),
			new Point(4000f, 0.75f)
		};
		material.transmission.points = new List<Point>();
	}

	private static void Steel(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.05f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.07f),
			new Point(4000f, 0.02f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.1f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.25f),
			new Point(250f, 0.2f),
			new Point(500f, 0.17f),
			new Point(1000f, 0.089f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.0056f)
		};
	}

	private static void Water(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.01f),
			new Point(250f, 0.01f),
			new Point(500f, 0.01f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.02f),
			new Point(4000f, 0.03f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.05f),
			new Point(4000f, 0.05f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.03f),
			new Point(250f, 0.03f),
			new Point(500f, 0.03f),
			new Point(1000f, 0.02f),
			new Point(2000f, 0.015f),
			new Point(4000f, 0.01f)
		};
	}

	private static void WoodThin(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.42f),
			new Point(250f, 0.21f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.08f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.06f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.2f),
			new Point(250f, 0.125f),
			new Point(500f, 0.079f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.089f),
			new Point(4000f, 0.05f)
		};
	}

	private static void WoodThick(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.19f),
			new Point(250f, 0.14f),
			new Point(500f, 0.09f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.05f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.035f),
			new Point(250f, 0.028f),
			new Point(500f, 0.028f),
			new Point(1000f, 0.028f),
			new Point(2000f, 0.011f),
			new Point(4000f, 0.0071f)
		};
	}

	private static void WoodFloor(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.15f),
			new Point(250f, 0.11f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.07f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.071f),
			new Point(250f, 0.025f),
			new Point(500f, 0.0158f),
			new Point(1000f, 0.0056f),
			new Point(2000f, 0.0035f),
			new Point(4000f, 0.0016f)
		};
	}

	private static void WoodOnConcrete(ref ONSPPropagationMaterial material)
	{
		material.absorption.points = new List<Point>
		{
			new Point(125f, 0.04f),
			new Point(250f, 0.04f),
			new Point(500f, 0.07f),
			new Point(1000f, 0.06f),
			new Point(2000f, 0.06f),
			new Point(4000f, 0.07f)
		};
		material.scattering.points = new List<Point>
		{
			new Point(125f, 0.1f),
			new Point(250f, 0.1f),
			new Point(500f, 0.1f),
			new Point(1000f, 0.1f),
			new Point(2000f, 0.1f),
			new Point(4000f, 0.15f)
		};
		material.transmission.points = new List<Point>
		{
			new Point(125f, 0.004f),
			new Point(250f, 0.0079f),
			new Point(500f, 0.0056f),
			new Point(1000f, 0.0016f),
			new Point(2000f, 0.0014f),
			new Point(4000f, 0.0005f)
		};
	}
}
public class ONSPPropagationSettings : MonoBehaviour
{
	public float quality = 100f;

	private void Update()
	{
		ONSPPropagation.Interface.SetPropagationQuality(quality / 100f);
	}
}
public sealed class ONSPSettings : ScriptableObject
{
	[SerializeField]
	public int voiceLimit = 64;

	private static ONSPSettings instance;

	public static ONSPSettings Instance
	{
		get
		{
			if (instance == null)
			{
				instance = Resources.Load<ONSPSettings>("ONSPSettings");
				if (instance == null)
				{
					instance = ScriptableObject.CreateInstance<ONSPSettings>();
				}
			}
			return instance;
		}
	}
}
public class ONSPVersion : MonoBehaviour
{
	public const string strONSPS = "AudioPluginOculusSpatializer";

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern void ONSP_GetVersion(ref int Major, ref int Minor, ref int Patch);

	private void Awake()
	{
		int Major = 0;
		int Minor = 0;
		int Patch = 0;
		ONSP_GetVersion(ref Major, ref Minor, ref Patch);
		UnityEngine.Debug.Log($"ONSP Version: {Major:F0}.{Minor:F0}.{Patch:F0}");
	}

	private void Start()
	{
	}

	private void Update()
	{
	}
}
public class OculusSpatializerUnity : MonoBehaviour
{
	public delegate void AudioRaycastCallback(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data);

	public LayerMask layerMask = -1;

	public bool visualizeRoom = true;

	private bool roomVisualizationInitialized;

	public int raysPerSecond = 256;

	public float roomInterpSpeed = 0.9f;

	public float maxWallDistance = 50f;

	public int rayCacheSize = 512;

	public bool dynamicReflectionsEnabled = true;

	private float particleSize = 0.2f;

	private float particleOffset = 0.1f;

	private GameObject room;

	private Renderer[] wallRenderer = new Renderer[6];

	private float[] dims = new float[3] { 1f, 1f, 1f };

	private float[] coefs = new float[6];

	private const int HIT_COUNT = 2048;

	private Vector3[] points = new Vector3[2048];

	private Vector3[] normals = new Vector3[2048];

	private ParticleSystem sys;

	private ParticleSystem.Particle[] particles = new ParticleSystem.Particle[2048];

	private static LayerMask gLayerMask = -1;

	private const string strOSP = "AudioPluginOculusSpatializer";

	private static Vector3 swapHandedness(Vector3 vec)
	{
		return new Vector3(vec.x, vec.y, 0f - vec.z);
	}

	[MonoPInvokeCallback(typeof(AudioRaycastCallback))]
	private static void AudioRaycast(Vector3 origin, Vector3 direction, out Vector3 point, out Vector3 normal, IntPtr data)
	{
		point = Vector3.zero;
		normal = Vector3.zero;
		if (Physics.Raycast(swapHandedness(origin), swapHandedness(direction), out var hitInfo, 1000f, gLayerMask.value))
		{
			point = swapHandedness(hitInfo.point);
			normal = swapHandedness(hitInfo.normal);
		}
	}

	private void Start()
	{
		OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
	}

	private void OnDestroy()
	{
		OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
	}

	private void Update()
	{
		if (dynamicReflectionsEnabled)
		{
			OSP_Unity_AssignRaycastCallback(AudioRaycast, IntPtr.Zero);
		}
		else
		{
			OSP_Unity_AssignRaycastCallback(IntPtr.Zero, IntPtr.Zero);
		}
		OSP_Unity_SetDynamicRoomRaysPerSecond(raysPerSecond);
		OSP_Unity_SetDynamicRoomInterpSpeed(roomInterpSpeed);
		OSP_Unity_SetDynamicRoomMaxWallDistance(maxWallDistance);
		OSP_Unity_SetDynamicRoomRaysRayCacheSize(rayCacheSize);
		gLayerMask = layerMask;
		OSP_Unity_UpdateRoomModel(1f);
		if (!visualizeRoom)
		{
			return;
		}
		if (!roomVisualizationInitialized)
		{
			inititalizeRoomVisualization();
			roomVisualizationInitialized = true;
		}
		OSP_Unity_GetRoomDimensions(dims, coefs, out var position);
		position.z *= -1f;
		Vector3 vector = new Vector3(dims[0], dims[1], dims[2]);
		float sqrMagnitude = vector.sqrMagnitude;
		if (!float.IsNaN(sqrMagnitude) && 0f < sqrMagnitude && sqrMagnitude < 1000000f)
		{
			base.transform.localScale = vector * 0.999f;
		}
		base.transform.position = position;
		OSP_Unity_GetRaycastHits(points, normals, 2048);
		for (int i = 0; i < 2048; i++)
		{
			if (points[i] == Vector3.zero)
			{
				points[i].y = -10000f;
			}
			points[i].z *= -1f;
			normals[i].z *= -1f;
			particles[i].position = points[i] + normals[i] * particleOffset;
			if (normals[i] != Vector3.zero)
			{
				particles[i].rotation3D = Quaternion.LookRotation(normals[i]).eulerAngles;
			}
			particles[i].startSize = particleSize;
			particles[i].startColor = new Color(0.8156863f, 0.14901961f, 58f / 85f, 1f);
		}
		for (int j = 0; j < 6; j++)
		{
			Color value = Color.Lerp(Color.red, Color.green, coefs[j]);
			wallRenderer[j].material.SetColor("_TintColor", value);
		}
		sys.SetParticles(particles, particles.Length);
	}

	private void inititalizeRoomVisualization()
	{
		UnityEngine.Debug.Log("Oculus Audio dynamic room estimation visualization enabled");
		base.transform.position = Vector3.zero;
		GameObject gameObject = new GameObject("DecalManager");
		gameObject.transform.parent = base.transform;
		sys = gameObject.AddComponent<ParticleSystem>();
		ParticleSystem.MainModule main = sys.main;
		main.simulationSpace = ParticleSystemSimulationSpace.World;
		main.loop = false;
		main.playOnAwake = false;
		ParticleSystem.EmissionModule emission = sys.emission;
		emission.enabled = false;
		ParticleSystem.ShapeModule shape = sys.shape;
		shape.enabled = false;
		ParticleSystemRenderer component = sys.GetComponent<ParticleSystemRenderer>();
		component.renderMode = ParticleSystemRenderMode.Mesh;
		component.material.shader = Shader.Find("Particles/Additive");
		Texture2D texture2D = new Texture2D(64, 64);
		for (int i = 0; i < 32; i++)
		{
			for (int j = 0; j < 32; j++)
			{
				float num = 32 - i;
				float num2 = 32 - j;
				float num3 = Mathf.Sqrt(num * num + num2 * num2);
				float num4 = 2f * num3 / 32f;
				float a = ((num3 < 32f) ? Mathf.Clamp01(Mathf.Sin((float)Math.PI * 2f * num4)) : 0f);
				Color color = new Color(1f, 1f, 1f, a);
				texture2D.SetPixel(i, j, color);
				texture2D.SetPixel(64 - i, j, color);
				texture2D.SetPixel(i, 64 - j, color);
				texture2D.SetPixel(64 - i, 64 - j, color);
			}
		}
		texture2D.Apply();
		component.material.mainTexture = texture2D;
		Mesh mesh = new Mesh();
		mesh.name = "ParticleQuad";
		mesh.vertices = new Vector3[4]
		{
			new Vector3(-0.5f, -0.5f, 0f),
			new Vector3(0.5f, -0.5f, 0f),
			new Vector3(0.5f, 0.5f, 0f),
			new Vector3(-0.5f, 0.5f, 0f)
		};
		mesh.uv = new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		mesh.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		mesh.RecalculateNormals();
		component.mesh = mesh;
		sys.Emit(2048);
		room = new GameObject("RoomVisualizer");
		room.transform.parent = base.transform;
		room.transform.localPosition = Vector3.zero;
		Texture2D texture2D2 = new Texture2D(32, 32);
		Color color2 = new Color(0f, 0f, 0f, 0f);
		for (int k = 0; k < 32; k++)
		{
			for (int l = 0; l < 32; l++)
			{
				texture2D2.SetPixel(k, l, color2);
			}
		}
		for (int m = 0; m < 32; m++)
		{
			Color color3 = Color.white * 0.125f;
			texture2D2.SetPixel(8, m, color3);
			texture2D2.SetPixel(m, 8, color3);
			texture2D2.SetPixel(24, m, color3);
			texture2D2.SetPixel(m, 24, color3);
			color3 *= 2f;
			texture2D2.SetPixel(16, m, color3);
			texture2D2.SetPixel(m, 16, color3);
			color3 *= 2f;
			texture2D2.SetPixel(0, m, color3);
			texture2D2.SetPixel(m, 0, color3);
		}
		texture2D2.Apply();
		for (int n = 0; n < 6; n++)
		{
			Mesh mesh2 = new Mesh();
			mesh2.name = "Plane" + n;
			Vector3[] array = new Vector3[4];
			int num5 = n / 2;
			int num6 = ((n % 2 == 0) ? 1 : (-1));
			for (int num7 = 0; num7 < 4; num7++)
			{
				array[num7][num5] = (float)num6 * 0.5f;
				array[num7][(num5 + 1) % 3] = 0.5f * (float)((num7 == 1 || num7 == 2) ? 1 : (-1));
				array[num7][(num5 + 2) % 3] = 0.5f * (float)((num7 == 2 || num7 == 3) ? 1 : (-1));
			}
			mesh2.vertices = array;
			mesh2.uv = new Vector2[4]
			{
				new Vector2(0f, 0f),
				new Vector2(0f, 1f),
				new Vector2(1f, 1f),
				new Vector2(1f, 0f)
			};
			mesh2.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
			mesh2.RecalculateNormals();
			GameObject obj = new GameObject("Wall_" + n);
			obj.AddComponent<MeshFilter>().mesh = mesh2;
			MeshRenderer meshRenderer = obj.AddComponent<MeshRenderer>();
			wallRenderer[n] = meshRenderer;
			meshRenderer.material.shader = Shader.Find("Particles/Additive");
			meshRenderer.material.mainTexture = texture2D2;
			meshRenderer.material.mainTextureScale = new Vector2(8f, 8f);
			obj.transform.parent = room.transform;
			room.transform.localPosition = Vector3.zero;
		}
	}

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(AudioRaycastCallback callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_AssignRaycastCallback(IntPtr callback, IntPtr data);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysPerSecond(int RaysPerSecond);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomInterpSpeed(float InterpSpeed);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomMaxWallDistance(float MaxWallDistance);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_SetDynamicRoomRaysRayCacheSize(int RayCacheSize);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_UpdateRoomModel(float wetLevel);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRoomDimensions(float[] roomDimensions, float[] reflectionsCoefs, out Vector3 position);

	[DllImport("AudioPluginOculusSpatializer")]
	private static extern int OSP_Unity_GetRaycastHits(Vector3[] points, Vector3[] normals, int length);
}
public struct ReflectionSnapshot
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;
}
public class ONSPReflectionZone : MonoBehaviour
{
	public AudioMixerSnapshot mixerSnapshot;

	public float fadeTime;

	private static Stack<ReflectionSnapshot> snapshotList = new Stack<ReflectionSnapshot>();

	private static ReflectionSnapshot currentSnapshot = default(ReflectionSnapshot);

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnTriggerEnter(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PushCurrentMixerShapshot();
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (CheckForAudioListener(other.gameObject))
		{
			PopCurrentMixerSnapshot();
		}
	}

	private bool CheckForAudioListener(GameObject gameObject)
	{
		if (gameObject.GetComponentInChildren<AudioListener>() != null)
		{
			return true;
		}
		return false;
	}

	private void PushCurrentMixerShapshot()
	{
		ReflectionSnapshot item = currentSnapshot;
		snapshotList.Push(item);
		SetReflectionValues();
	}

	private void PopCurrentMixerSnapshot()
	{
		ReflectionSnapshot mss = snapshotList.Pop();
		SetReflectionValues(ref mss);
	}

	private void SetReflectionValues()
	{
		if (mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mixerSnapshot.name);
			mixerSnapshot.TransitionTo(fadeTime);
			currentSnapshot.mixerSnapshot = mixerSnapshot;
			currentSnapshot.fadeTime = fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}

	private void SetReflectionValues(ref ReflectionSnapshot mss)
	{
		if (mss.mixerSnapshot != null)
		{
			UnityEngine.Debug.Log("Setting off snapshot " + mss.mixerSnapshot.name);
			mss.mixerSnapshot.TransitionTo(mss.fadeTime);
			currentSnapshot.mixerSnapshot = mss.mixerSnapshot;
			currentSnapshot.fadeTime = mss.fadeTime;
		}
		else
		{
			UnityEngine.Debug.Log("Mixer snapshot not set - Please ensure play area has at least one encompassing snapshot.");
		}
	}
}
public class NextPrefab : MonoBehaviour
{
	public GameObject[] m_PrefabList;

	private int m_CurrentElementIndex = -1;

	private int m_CurrentParticleIndex = -1;

	private GameObject[] m_CurrentElementList;

	private GameObject m_CurrentParticle;

	public Text m_ParticleName;

	private void Start()
	{
		if (m_PrefabList.Length != 0)
		{
			m_CurrentElementIndex = 0;
			m_CurrentParticleIndex = 0;
			ShowParticle();
		}
	}

	private void Update()
	{
		if (m_CurrentElementIndex != -1 && m_CurrentParticleIndex != -1)
		{
			if (Input.GetKeyUp(KeyCode.Z))
			{
				m_CurrentParticleIndex--;
				ShowParticle();
			}
			else if (Input.GetKeyUp(KeyCode.X))
			{
				m_CurrentParticleIndex++;
				ShowParticle();
			}
		}
	}

	private void ShowParticle()
	{
		if (m_CurrentElementIndex == 0)
		{
			m_CurrentElementList = m_PrefabList;
		}
		if (m_CurrentParticleIndex >= m_CurrentElementList.Length)
		{
			m_CurrentParticleIndex = 0;
		}
		else if (m_CurrentParticleIndex < 0)
		{
			m_CurrentParticleIndex = m_CurrentElementList.Length - 1;
		}
		m_ParticleName.text = m_CurrentElementList[m_CurrentParticleIndex].name;
		if (m_CurrentParticle != null)
		{
			UnityEngine.Object.Destroy(m_CurrentParticle);
		}
		m_CurrentParticle = UnityEngine.Object.Instantiate(m_CurrentElementList[m_CurrentParticleIndex]);
	}
}
public class Rotation : MonoBehaviour
{
	[Range(-1f, 1f)]
	public float xForceDirection;

	[Range(-1f, 1f)]
	public float yForceDirection;

	[Range(-1f, 1f)]
	public float zForceDirection;

	public float speedMultiplier = 1f;

	public bool worldPivote;

	private Space spacePivot = Space.Self;

	private void Start()
	{
		if (worldPivote)
		{
			spacePivot = Space.World;
		}
	}

	private void Update()
	{
		base.transform.Rotate(xForceDirection * speedMultiplier, yForceDirection * speedMultiplier, zForceDirection * speedMultiplier, spacePivot);
	}
}
public class UserCamera : MonoBehaviour
{
	public Transform target;

	public float targetHeight = 1.7f;

	public float distance = 12f;

	public float offsetFromWall = 0.1f;

	public float maxDistance = 20f;

	public float minDistance = 0.6f;

	public float xSpeed = 200f;

	public float ySpeed = 200f;

	public float yMinLimit = -80f;

	public float yMaxLimit = 80f;

	public float zoomRate = 40f;

	public float rotationDampening = 3f;

	public float zoomDampening = 5f;

	private LayerMask collisionLayers = -1;

	public bool lockToRearOfTarget;

	public bool allowMouseInputX = true;

	public bool allowMouseInputY = true;

	private float xDeg;

	private float yDeg;

	private float currentDistance;

	public float desiredDistance;

	private float correctedDistance;

	public GameObject userModel;

	public bool inFirstPerson;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.eulerAngles;
		xDeg = eulerAngles.x;
		yDeg = eulerAngles.y;
		currentDistance = distance;
		desiredDistance = distance;
		correctedDistance = distance;
		if ((bool)GetComponent<Rigidbody>())
		{
			GetComponent<Rigidbody>().freezeRotation = true;
		}
	}

	private void Update()
	{
		if (Input.GetAxis("Mouse ScrollWheel") < 0f && inFirstPerson)
		{
			minDistance = 10f;
			desiredDistance = 15f;
			userModel.SetActive(value: true);
			inFirstPerson = false;
		}
		if (desiredDistance == 10f)
		{
			minDistance = 0f;
			desiredDistance = 0f;
			userModel.SetActive(value: false);
			inFirstPerson = true;
		}
	}

	private void LateUpdate()
	{
		if (!target)
		{
			return;
		}
		if (GUIUtility.hotControl == 0 && !Input.GetKey(KeyCode.LeftControl) && (Input.GetMouseButton(0) || Input.GetMouseButton(1)))
		{
			if (allowMouseInputX)
			{
				xDeg += Input.GetAxis("Mouse X") * xSpeed * 0.02f;
			}
			if (allowMouseInputY)
			{
				yDeg -= Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			}
		}
		ClampAngle(yDeg);
		Quaternion quaternion = Quaternion.Euler(yDeg, xDeg, 0f);
		desiredDistance -= Input.GetAxis("Mouse ScrollWheel") * Time.deltaTime * zoomRate * Mathf.Abs(desiredDistance);
		desiredDistance = Mathf.Clamp(desiredDistance, minDistance, maxDistance);
		correctedDistance = desiredDistance;
		Vector3 vector = new Vector3(0f, 0f - targetHeight, 0f);
		Vector3 end = target.position - (quaternion * Vector3.forward * desiredDistance + vector);
		Vector3 vector2 = new Vector3(target.position.x, target.position.y + targetHeight, target.position.z);
		bool flag = false;
		if (Physics.Linecast(vector2, end, out var hitInfo, collisionLayers))
		{
			correctedDistance = Vector3.Distance(vector2, hitInfo.point) - offsetFromWall;
			flag = true;
		}
		currentDistance = ((!flag || correctedDistance > currentDistance) ? Mathf.Lerp(currentDistance, correctedDistance, Time.deltaTime * zoomDampening) : correctedDistance);
		currentDistance = Mathf.Clamp(currentDistance, minDistance, maxDistance);
		end = target.position - (quaternion * Vector3.forward * currentDistance + vector);
		base.transform.rotation = quaternion;
		base.transform.position = end;
	}

	private void ClampAngle(float angle)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		yDeg = Mathf.Clamp(angle, -60f, 80f);
	}
}
public class PlayMakerActionsUtils
{
	public enum EveryFrameUpdateSelector
	{
		OnUpdate,
		OnLateUpdate,
		OnFixedUpdate
	}
}
public class FsmNavMeshPath : MonoBehaviour
{
	public Vector3[] corners;

	private NavMeshPath _path;

	public NavMeshPathStatus status
	{
		get
		{
			if (path == null)
			{
				return NavMeshPathStatus.PathInvalid;
			}
			return path.status;
		}
	}

	public NavMeshPath path
	{
		get
		{
			return _path;
		}
		set
		{
			_path = value;
			corners = _path.corners;
		}
	}

	private void Start()
	{
	}

	private void ClearCorners()
	{
		path.ClearCorners();
	}

	public string GetStatusString()
	{
		if (path == null)
		{
			return "n/a";
		}
		return path.status.ToString();
	}
}
public static class PlayMakerUtils_Extensions
{
	public static int IndexOf(ArrayList target, object value)
	{
		return IndexOf(target, value, 0, target.Count);
	}

	public static int IndexOf(ArrayList target, object value, int startIndex)
	{
		if (startIndex > target.Count)
		{
			throw new ArgumentOutOfRangeException("startIndex", "ArgumentOutOfRange_Index");
		}
		return IndexOf(target, value, startIndex, target.Count - startIndex);
	}

	public static int IndexOf(ArrayList target, object value, int startIndex, int count)
	{
		if (startIndex < 0 || startIndex >= target.Count)
		{
			throw new ArgumentOutOfRangeException("startIndex", "ArgumentOutOfRange_Index");
		}
		if (count < 0 || startIndex > target.Count - count)
		{
			throw new ArgumentOutOfRangeException("count", "ArgumentOutOfRange_Count");
		}
		if (target.Count == 0)
		{
			return -1;
		}
		int num = startIndex + count;
		if (value == null)
		{
			for (int i = startIndex; i < num; i++)
			{
				if (target[i] == null)
				{
					return i;
				}
			}
			return -1;
		}
		for (int j = startIndex; j < num; j++)
		{
			if (target[j] != null && target[j].Equals(value))
			{
				return j;
			}
		}
		return -1;
	}

	public static int LastIndexOf(ArrayList target, object value)
	{
		return LastIndexOf(target, value, target.Count - 1, target.Count);
	}

	public static int LastIndexOf(ArrayList target, object value, int startIndex)
	{
		return LastIndexOf(target, value, startIndex, startIndex + 1);
	}

	public static int LastIndexOf(ArrayList target, object value, int startIndex, int count)
	{
		if (target.Count == 0)
		{
			return -1;
		}
		if (startIndex < 0 || startIndex >= target.Count)
		{
			throw new ArgumentOutOfRangeException("startIndex", "ArgumentOutOfRange_Index");
		}
		if (count < 0 || startIndex > target.Count - count)
		{
			throw new ArgumentOutOfRangeException("count", "ArgumentOutOfRange_Count");
		}
		int num = startIndex + count - 1;
		if (value == null)
		{
			for (int num2 = num; num2 >= startIndex; num2--)
			{
				if (target[num2] == null)
				{
					return num2;
				}
			}
			return -1;
		}
		for (int num3 = num; num3 >= startIndex; num3--)
		{
			if (target[num3] != null && target[num3].Equals(value))
			{
				return num3;
			}
		}
		return -1;
	}

	public static string GetPath(this Transform current)
	{
		if (current.parent == null)
		{
			return "/" + current.name;
		}
		return current.parent.GetPath() + "/" + current.name;
	}

	public static string GetPath(this Component component)
	{
		return component.transform.GetPath();
	}

	public static string GetActionPath(this FsmStateAction action)
	{
		return action.Fsm.GameObject.transform.GetPath() + "/" + action.Fsm.Name + ":" + action.State.Name + ":" + action.Name;
	}
}
public class EventDataSenderProxy : ScriptableObject
{
	public FsmEventTarget EventTarget = new FsmEventTarget();
}
public static class PlayMakerUtilsDotNetExtensions
{
	public static bool Contains(this VariableType[] target, VariableType vType)
	{
		if (target == null)
		{
			return false;
		}
		for (int i = 0; i < target.Length; i++)
		{
			if (target[i] == vType)
			{
				return true;
			}
		}
		return false;
	}
}
public class PlayMakerUtils
{
	public static PlayMakerFSM FsmEventSender;

	public static PlayMakerFSM GetFsmEventSender()
	{
		if (FsmEventSender == null)
		{
			FsmEventSender = new GameObject("PlayMaker Send Event Proxy").AddComponent<PlayMakerFSM>();
			FsmEventSender.FsmName = "Send Event Proxy";
			FsmEventSender.FsmDescription = "This Fsm was created at runtime, because a script or component is willing to send a PlayMaker event";
		}
		return FsmEventSender;
	}

	public static void SendEventToTarget(PlayMakerFSM fromFsm, FsmEventTarget target, string fsmEvent, FsmEventData eventData)
	{
		if (fromFsm == null)
		{
			fromFsm = GetFsmEventSender();
		}
		if (eventData != null)
		{
			Fsm.EventData = eventData;
		}
		if (!(fromFsm == null))
		{
			fromFsm.Fsm.Event(target, fsmEvent);
		}
	}

	public static void SendEventToGameObject(PlayMakerFSM fromFsm, GameObject target, string fsmEvent, bool includeChildren)
	{
		SendEventToGameObject(fromFsm, target, fsmEvent, includeChildren, null);
	}

	public static void SendEventToGameObject(PlayMakerFSM fromFsm, GameObject target, string fsmEvent)
	{
		SendEventToGameObject(fromFsm, target, fsmEvent, includeChildren: false, null);
	}

	public static void SendEventToGameObject(PlayMakerFSM fromFsm, GameObject target, string fsmEvent, FsmEventData eventData)
	{
		SendEventToGameObject(fromFsm, target, fsmEvent, includeChildren: false, eventData);
	}

	public static void SendEventToGameObject(PlayMakerFSM fromFsm, GameObject target, string fsmEvent, bool includeChildren, FsmEventData eventData)
	{
		if (fromFsm == null)
		{
			fromFsm = GetFsmEventSender();
		}
		if (eventData != null)
		{
			Fsm.EventData = eventData;
		}
		if (!(fromFsm == null))
		{
			FsmEventTarget fsmEventTarget = new FsmEventTarget();
			fsmEventTarget.excludeSelf = false;
			fsmEventTarget.sendToChildren = includeChildren;
			fsmEventTarget.target = FsmEventTarget.EventTarget.GameObject;
			FsmOwnerDefault fsmOwnerDefault = new FsmOwnerDefault();
			fsmOwnerDefault.OwnerOption = OwnerDefaultOption.SpecifyGameObject;
			fsmOwnerDefault.GameObject = new FsmGameObject();
			fsmOwnerDefault.GameObject.Value = target;
			fsmEventTarget.gameObject = fsmOwnerDefault;
			fromFsm.Fsm.Event(fsmEventTarget, fsmEvent);
		}
	}

	public static void SendEventToGameObjectFsmByName(PlayMakerFSM fromFsm, GameObject target, string fsmName, string fsmEvent, FsmEventData eventData)
	{
		FsmEventTarget fsmEventTarget = new FsmEventTarget();
		fsmEventTarget.target = FsmEventTarget.EventTarget.GameObjectFSM;
		fsmEventTarget.gameObject = new FsmOwnerDefault();
		fsmEventTarget.gameObject.OwnerOption = OwnerDefaultOption.SpecifyGameObject;
		fsmEventTarget.gameObject.GameObject = target;
		fsmEventTarget.fsmName = fsmName;
		SendEventToTarget(fromFsm, fsmEventTarget, fsmEvent, eventData);
	}

	public static bool DoesTargetImplementsEvent(FsmEventTarget target, string eventName)
	{
		if (target.target == FsmEventTarget.EventTarget.BroadcastAll)
		{
			return FsmEvent.IsEventGlobal(eventName);
		}
		if (target.target == FsmEventTarget.EventTarget.FSMComponent)
		{
			return DoesFsmImplementsEvent(target.fsmComponent, eventName);
		}
		if (target.target == FsmEventTarget.EventTarget.GameObject)
		{
			return DoesGameObjectImplementsEvent(target.gameObject.GameObject.Value, eventName);
		}
		if (target.target == FsmEventTarget.EventTarget.GameObjectFSM)
		{
			return DoesGameObjectImplementsEvent(target.gameObject.GameObject.Value, target.fsmName.Value, eventName);
		}
		if (target.target == FsmEventTarget.EventTarget.Self)
		{
			UnityEngine.Debug.LogError("Self target not supported yet");
		}
		if (target.target == FsmEventTarget.EventTarget.SubFSMs)
		{
			UnityEngine.Debug.LogError("subFsms target not supported yet");
		}
		if (target.target == FsmEventTarget.EventTarget.HostFSM)
		{
			UnityEngine.Debug.LogError("HostFSM target not supported yet");
		}
		return false;
	}

	public static bool DoesGameObjectImplementsEvent(GameObject go, string fsmEvent, bool includeChildren = false)
	{
		if (go == null || string.IsNullOrEmpty(fsmEvent))
		{
			return false;
		}
		if (includeChildren)
		{
			PlayMakerFSM[] componentsInChildren = go.GetComponentsInChildren<PlayMakerFSM>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (DoesFsmImplementsEvent(componentsInChildren[i], fsmEvent))
				{
					return true;
				}
			}
		}
		else
		{
			PlayMakerFSM[] componentsInChildren = go.GetComponents<PlayMakerFSM>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (DoesFsmImplementsEvent(componentsInChildren[i], fsmEvent))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool DoesGameObjectImplementsEvent(GameObject go, string fsmName, string fsmEvent)
	{
		if (go == null || string.IsNullOrEmpty(fsmEvent))
		{
			return false;
		}
		bool flag = !string.IsNullOrEmpty(fsmName);
		PlayMakerFSM[] components = go.GetComponents<PlayMakerFSM>();
		foreach (PlayMakerFSM playMakerFSM in components)
		{
			if (flag && object.Equals(playMakerFSM, fsmName) && DoesFsmImplementsEvent(playMakerFSM, fsmEvent))
			{
				return true;
			}
		}
		return false;
	}

	public static bool DoesFsmImplementsEvent(PlayMakerFSM fsm, string fsmEvent)
	{
		if (fsm == null || string.IsNullOrEmpty(fsmEvent))
		{
			return false;
		}
		FsmTransition[] fsmGlobalTransitions = fsm.FsmGlobalTransitions;
		for (int i = 0; i < fsmGlobalTransitions.Length; i++)
		{
			if (fsmGlobalTransitions[i].EventName.Equals(fsmEvent))
			{
				return true;
			}
		}
		FsmState[] fsmStates = fsm.FsmStates;
		for (int i = 0; i < fsmStates.Length; i++)
		{
			fsmGlobalTransitions = fsmStates[i].Transitions;
			for (int j = 0; j < fsmGlobalTransitions.Length; j++)
			{
				if (fsmGlobalTransitions[j].EventName.Equals(fsmEvent))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool CreateIfNeededGlobalEvent(string globalEventName)
	{
		FsmEvent fsmEvent = FsmEvent.GetFsmEvent(globalEventName);
		bool result = false;
		if (!FsmEvent.IsEventGlobal(globalEventName))
		{
			if (fsmEvent == null)
			{
				fsmEvent = new FsmEvent(globalEventName)
				{
					IsGlobal = true
				};
				FsmEvent.AddFsmEvent(fsmEvent);
				if (!FsmEvent.globalEvents.Contains(globalEventName))
				{
					FsmEvent.globalEvents.Add(globalEventName);
				}
			}
			result = true;
		}
		return result;
	}

	public static Fsm GetFsmOnGameObject(GameObject go, string fsmName)
	{
		if (go == null || string.IsNullOrEmpty(fsmName))
		{
			return null;
		}
		PlayMakerFSM[] components = go.GetComponents<PlayMakerFSM>();
		foreach (PlayMakerFSM playMakerFSM in components)
		{
			if (string.Equals(playMakerFSM.FsmName, fsmName))
			{
				return playMakerFSM.Fsm;
			}
		}
		return null;
	}

	public static PlayMakerFSM FindFsmOnGameObject(GameObject go, string fsmName)
	{
		if (go == null || string.IsNullOrEmpty(fsmName))
		{
			return null;
		}
		PlayMakerFSM[] components = go.GetComponents<PlayMakerFSM>();
		foreach (PlayMakerFSM playMakerFSM in components)
		{
			if (string.Equals(playMakerFSM.FsmName, fsmName))
			{
				return playMakerFSM;
			}
		}
		return null;
	}

	public static string LogFullPathToAction(FsmStateAction action)
	{
		return GetGameObjectPath(action.Fsm.GameObject) + ":Fsm(" + action.Fsm.Name + "):State(" + action.State.Name + "):Action(" + action.GetType().Name + ")";
	}

	public static string GetGameObjectPath(GameObject obj)
	{
		string text = "/" + obj.name;
		while (obj.transform.parent != null)
		{
			obj = obj.transform.parent.gameObject;
			text = "/" + obj.name + text;
		}
		return text;
	}

	public static void RefreshValueFromFsmVar(Fsm fromFsm, FsmVar fsmVar)
	{
		if (fromFsm != null && fsmVar != null && fsmVar.useVariable)
		{
			switch (fsmVar.Type)
			{
			case VariableType.Int:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmInt(fsmVar.variableName));
				break;
			case VariableType.Float:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmFloat(fsmVar.variableName));
				break;
			case VariableType.Bool:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmBool(fsmVar.variableName));
				break;
			case VariableType.Color:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmColor(fsmVar.variableName));
				break;
			case VariableType.Quaternion:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmQuaternion(fsmVar.variableName));
				break;
			case VariableType.Rect:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmRect(fsmVar.variableName));
				break;
			case VariableType.Vector2:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmVector2(fsmVar.variableName));
				break;
			case VariableType.Vector3:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmVector3(fsmVar.variableName));
				break;
			case VariableType.Texture:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmVector3(fsmVar.variableName));
				break;
			case VariableType.Material:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmMaterial(fsmVar.variableName));
				break;
			case VariableType.String:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmString(fsmVar.variableName));
				break;
			case VariableType.GameObject:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmGameObject(fsmVar.variableName));
				break;
			case VariableType.Enum:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmEnum(fsmVar.variableName));
				break;
			case VariableType.Array:
				fsmVar.GetValueFrom(fromFsm.Variables.GetFsmArray(fsmVar.variableName));
				break;
			case VariableType.Object:
				break;
			}
		}
	}

	public static object GetValueFromFsmVar(Fsm fromFsm, FsmVar fsmVar)
	{
		if (fromFsm == null)
		{
			return null;
		}
		if (fsmVar == null)
		{
			return null;
		}
		if (fsmVar.useVariable)
		{
			string variableName = fsmVar.variableName;
			switch (fsmVar.Type)
			{
			case VariableType.Int:
				return fromFsm.Variables.GetFsmInt(variableName).Value;
			case VariableType.Float:
				return fromFsm.Variables.GetFsmFloat(variableName).Value;
			case VariableType.Bool:
				return fromFsm.Variables.GetFsmBool(variableName).Value;
			case VariableType.Color:
				return fromFsm.Variables.GetFsmColor(variableName).Value;
			case VariableType.Quaternion:
				return fromFsm.Variables.GetFsmQuaternion(variableName).Value;
			case VariableType.Rect:
				return fromFsm.Variables.GetFsmRect(variableName).Value;
			case VariableType.Vector2:
				return fromFsm.Variables.GetFsmVector2(variableName).Value;
			case VariableType.Vector3:
				return fromFsm.Variables.GetFsmVector3(variableName).Value;
			case VariableType.Texture:
				return fromFsm.Variables.GetFsmTexture(variableName).Value;
			case VariableType.Material:
				return fromFsm.Variables.GetFsmMaterial(variableName).Value;
			case VariableType.String:
				return fromFsm.Variables.GetFsmString(variableName).Value;
			case VariableType.GameObject:
				return fromFsm.Variables.GetFsmGameObject(variableName).Value;
			case VariableType.Object:
				return fromFsm.Variables.GetFsmObject(variableName).Value;
			case VariableType.Enum:
				return fromFsm.Variables.GetFsmEnum(variableName).Value;
			case VariableType.Array:
				return fromFsm.Variables.GetFsmArray(variableName).Values;
			}
		}
		else
		{
			switch (fsmVar.Type)
			{
			case VariableType.Int:
				return fsmVar.intValue;
			case VariableType.Float:
				return fsmVar.floatValue;
			case VariableType.Bool:
				return fsmVar.boolValue;
			case VariableType.Color:
				return fsmVar.colorValue;
			case VariableType.Quaternion:
				return fsmVar.quaternionValue;
			case VariableType.Rect:
				return fsmVar.rectValue;
			case VariableType.Vector2:
				return fsmVar.vector2Value;
			case VariableType.Vector3:
				return fsmVar.vector3Value;
			case VariableType.Texture:
				return fsmVar.textureValue;
			case VariableType.Material:
				return fsmVar.materialValue;
			case VariableType.String:
				return fsmVar.stringValue;
			case VariableType.GameObject:
				return fsmVar.gameObjectValue;
			case VariableType.Object:
				return fsmVar.objectReference;
			case VariableType.Enum:
				return fsmVar.EnumValue;
			case VariableType.Array:
				return fsmVar.arrayValue;
			}
		}
		return null;
	}

	public static bool ApplyValueToFsmVar(Fsm fromFsm, FsmVar fsmVar, object[] value)
	{
		if (fromFsm == null)
		{
			return false;
		}
		if (fsmVar == null)
		{
			return false;
		}
		if (value == null || value.Length == 0)
		{
			if (fsmVar.Type == VariableType.Array)
			{
				fromFsm.Variables.GetFsmArray(fsmVar.variableName).Reset();
			}
			return true;
		}
		if (fsmVar.Type != VariableType.Array)
		{
			UnityEngine.Debug.LogError(string.Concat("The fsmVar value <", fsmVar.Type, "> doesn't match the value <FsmArray> on state", fromFsm.ActiveStateName, " on fsm:", fromFsm.Name, " on GameObject:", fromFsm.GameObjectName));
			return false;
		}
		fromFsm.Variables.GetFsmArray(fsmVar.variableName).Values = value;
		return true;
	}

	public static bool ApplyValueToFsmVar(Fsm fromFsm, FsmVar fsmVar, object value)
	{
		if (fromFsm == null)
		{
			return false;
		}
		if (fsmVar == null)
		{
			return false;
		}
		if (value == null)
		{
			if (fsmVar.Type == VariableType.Bool)
			{
				fromFsm.Variables.GetFsmBool(fsmVar.variableName).Value = false;
			}
			else if (fsmVar.Type == VariableType.Color)
			{
				fromFsm.Variables.GetFsmColor(fsmVar.variableName).Value = Color.black;
			}
			else if (fsmVar.Type == VariableType.Int)
			{
				fromFsm.Variables.GetFsmInt(fsmVar.variableName).Value = 0;
			}
			else if (fsmVar.Type == VariableType.Float)
			{
				fromFsm.Variables.GetFsmFloat(fsmVar.variableName).Value = 0f;
			}
			else if (fsmVar.Type == VariableType.GameObject)
			{
				fromFsm.Variables.GetFsmGameObject(fsmVar.variableName).Value = null;
			}
			else if (fsmVar.Type == VariableType.Material)
			{
				fromFsm.Variables.GetFsmMaterial(fsmVar.variableName).Value = null;
			}
			else if (fsmVar.Type == VariableType.Object)
			{
				fromFsm.Variables.GetFsmObject(fsmVar.variableName).Value = null;
			}
			else if (fsmVar.Type == VariableType.Quaternion)
			{
				fromFsm.Variables.GetFsmQuaternion(fsmVar.variableName).Value = Quaternion.identity;
			}
			else if (fsmVar.Type == VariableType.Rect)
			{
				fromFsm.Variables.GetFsmRect(fsmVar.variableName).Value = new Rect(0f, 0f, 0f, 0f);
			}
			else if (fsmVar.Type == VariableType.String)
			{
				fromFsm.Variables.GetFsmString(fsmVar.variableName).Value = "";
			}
			else if (fsmVar.Type == VariableType.String)
			{
				fromFsm.Variables.GetFsmTexture(fsmVar.variableName).Value = null;
			}
			else if (fsmVar.Type == VariableType.Vector2)
			{
				fromFsm.Variables.GetFsmVector2(fsmVar.variableName).Value = Vector2.zero;
			}
			else if (fsmVar.Type == VariableType.Vector3)
			{
				fromFsm.Variables.GetFsmVector3(fsmVar.variableName).Value = Vector3.zero;
			}
			else if (fsmVar.Type == VariableType.Enum)
			{
				fromFsm.Variables.GetFsmEnum(fsmVar.variableName).ResetValue();
			}
			else if (fsmVar.Type == VariableType.Array)
			{
				fromFsm.Variables.GetFsmArray(fsmVar.variableName).Reset();
			}
			return true;
		}
		Type type = value.GetType();
		Type type2 = null;
		switch (fsmVar.Type)
		{
		case VariableType.Int:
			type2 = typeof(int);
			break;
		case VariableType.Float:
			type2 = typeof(float);
			break;
		case VariableType.Bool:
			type2 = typeof(bool);
			break;
		case VariableType.Color:
			type2 = typeof(Color);
			break;
		case VariableType.GameObject:
			type2 = typeof(GameObject);
			break;
		case VariableType.Quaternion:
			type2 = typeof(Quaternion);
			break;
		case VariableType.Rect:
			type2 = typeof(Rect);
			break;
		case VariableType.String:
			type2 = typeof(string);
			break;
		case VariableType.Texture:
			type2 = typeof(Texture2D);
			break;
		case VariableType.Vector2:
			type2 = typeof(Vector2);
			break;
		case VariableType.Vector3:
			type2 = typeof(Vector3);
			break;
		case VariableType.Object:
			type2 = typeof(UnityEngine.Object);
			break;
		case VariableType.Material:
			type2 = typeof(Material);
			break;
		case VariableType.Enum:
			type2 = typeof(Enum);
			break;
		case VariableType.Array:
			type2 = typeof(Array);
			break;
		}
		bool flag = true;
		if (!type2.Equals(type))
		{
			flag = false;
			if (type2.Equals(typeof(UnityEngine.Object)))
			{
				flag = true;
			}
			if (type2.Equals(typeof(Enum)))
			{
				flag = true;
			}
			if (!flag)
			{
				if (type.Equals(typeof(double)))
				{
					flag = true;
				}
				if (type.Equals(typeof(long)))
				{
					flag = true;
				}
				if (type.Equals(typeof(byte)))
				{
					flag = true;
				}
			}
		}
		if (!flag)
		{
			UnityEngine.Debug.LogError(string.Concat("The fsmVar value <", type2, "> doesn't match the value <", type, "> on state", fromFsm.ActiveStateName, " on fsm:", fromFsm.Name, " on GameObject:", fromFsm.GameObjectName));
			return false;
		}
		if (type == typeof(bool))
		{
			fromFsm.Variables.GetFsmBool(fsmVar.variableName).Value = (bool)value;
		}
		else if (type == typeof(Color))
		{
			fromFsm.Variables.GetFsmColor(fsmVar.variableName).Value = (Color)value;
		}
		else if (type == typeof(int))
		{
			fromFsm.Variables.GetFsmInt(fsmVar.variableName).Value = Convert.ToInt32(value);
		}
		else if (type == typeof(byte))
		{
			fromFsm.Variables.GetFsmInt(fsmVar.variableName).Value = Convert.ToInt32(value);
		}
		else if (type == typeof(long))
		{
			if (fsmVar.Type == VariableType.Int)
			{
				fromFsm.Variables.GetFsmInt(fsmVar.variableName).Value = Convert.ToInt32(value);
			}
			else if (fsmVar.Type == VariableType.Float)
			{
				fromFsm.Variables.GetFsmFloat(fsmVar.variableName).Value = Convert.ToSingle(value);
			}
		}
		else if (type == typeof(float))
		{
			fromFsm.Variables.GetFsmFloat(fsmVar.variableName).Value = (float)value;
		}
		else if (type == typeof(double))
		{
			fromFsm.Variables.GetFsmFloat(fsmVar.variableName).Value = Convert.ToSingle(value);
		}
		else if (type == typeof(GameObject))
		{
			fromFsm.Variables.GetFsmGameObject(fsmVar.variableName).Value = (GameObject)value;
		}
		else if (type == typeof(Material))
		{
			fromFsm.Variables.GetFsmMaterial(fsmVar.variableName).Value = (Material)value;
		}
		else if (type == typeof(UnityEngine.Object) || type2 == typeof(UnityEngine.Object))
		{
			fromFsm.Variables.GetFsmObject(fsmVar.variableName).Value = (UnityEngine.Object)value;
		}
		else if (type == typeof(Quaternion))
		{
			fromFsm.Variables.GetFsmQuaternion(fsmVar.variableName).Value = (Quaternion)value;
		}
		else if (type == typeof(Rect))
		{
			fromFsm.Variables.GetFsmRect(fsmVar.variableName).Value = (Rect)value;
		}
		else if (type == typeof(string))
		{
			fromFsm.Variables.GetFsmString(fsmVar.variableName).Value = (string)value;
		}
		else if (type == typeof(Texture2D))
		{
			fromFsm.Variables.GetFsmTexture(fsmVar.variableName).Value = (Texture2D)value;
		}
		else if (type == typeof(Vector2))
		{
			fromFsm.Variables.GetFsmVector2(fsmVar.variableName).Value = (Vector2)value;
		}
		else if (type == typeof(Vector3))
		{
			fromFsm.Variables.GetFsmVector3(fsmVar.variableName).Value = (Vector3)value;
		}
		else if (value is Enum)
		{
			fromFsm.Variables.GetFsmEnum(fsmVar.variableName).Value = (Enum)value;
		}
		else
		{
			UnityEngine.Debug.LogWarning("?!?!" + type);
		}
		return true;
	}

	public static float GetFloatFromObject(object _obj, VariableType targetType, bool fastProcessingIfPossible)
	{
		switch (targetType)
		{
		case VariableType.Float:
		case VariableType.Int:
			return Convert.ToSingle(_obj);
		case VariableType.Vector2:
		{
			Vector2 vector = (Vector2)_obj;
			if (vector != Vector2.zero)
			{
				if (!fastProcessingIfPossible)
				{
					return vector.magnitude;
				}
				return vector.sqrMagnitude;
			}
			break;
		}
		}
		if (targetType == VariableType.Vector3)
		{
			Vector3 vector2 = (Vector3)_obj;
			if (vector2 != Vector3.zero)
			{
				if (!fastProcessingIfPossible)
				{
					return vector2.magnitude;
				}
				return vector2.sqrMagnitude;
			}
		}
		if (targetType == VariableType.GameObject)
		{
			GameObject gameObject = (GameObject)_obj;
			if (gameObject != null)
			{
				MeshRenderer component = gameObject.GetComponent<MeshRenderer>();
				if (component != null)
				{
					return component.bounds.size.x * component.bounds.size.y * component.bounds.size.z;
				}
			}
		}
		switch (targetType)
		{
		case VariableType.Rect:
		{
			Rect rect = (Rect)_obj;
			return rect.width * rect.height;
		}
		case VariableType.String:
		{
			string text = (string)_obj;
			if (text != null)
			{
				return float.Parse(text);
			}
			break;
		}
		}
		return 0f;
	}

	public static string ParseFsmVarToString(Fsm fsm, FsmVar fsmVar)
	{
		if (fsmVar == null)
		{
			return "";
		}
		object valueFromFsmVar = GetValueFromFsmVar(fsm, fsmVar);
		if (valueFromFsmVar == null)
		{
			return "";
		}
		if (fsmVar.Type == VariableType.String)
		{
			return (string)valueFromFsmVar;
		}
		if (fsmVar.Type == VariableType.Bool)
		{
			if (!(bool)valueFromFsmVar)
			{
				return "0";
			}
			return "1";
		}
		if (fsmVar.Type == VariableType.Float)
		{
			return float.Parse(valueFromFsmVar.ToString()).ToString();
		}
		if (fsmVar.Type == VariableType.Int)
		{
			return int.Parse(valueFromFsmVar.ToString()).ToString();
		}
		if (fsmVar.Type == VariableType.Vector2)
		{
			Vector2 vector = (Vector2)valueFromFsmVar;
			return vector.x + "," + vector.y;
		}
		if (fsmVar.Type == VariableType.Vector3)
		{
			Vector3 vector2 = (Vector3)valueFromFsmVar;
			return vector2.x + "," + vector2.y + "," + vector2.z;
		}
		if (fsmVar.Type == VariableType.Quaternion)
		{
			Quaternion quaternion = (Quaternion)valueFromFsmVar;
			return quaternion.x + "," + quaternion.y + "," + quaternion.z + "," + quaternion.w;
		}
		if (fsmVar.Type == VariableType.Rect)
		{
			Rect rect = (Rect)valueFromFsmVar;
			return rect.x + "," + rect.y + "," + rect.width + "," + rect.height;
		}
		if (fsmVar.Type == VariableType.Color)
		{
			Color color = (Color)valueFromFsmVar;
			return color.r + "," + color.g + "," + color.b + "," + color.a;
		}
		if (fsmVar.Type == VariableType.GameObject)
		{
			return ((GameObject)valueFromFsmVar).name;
		}
		if (fsmVar.Type == VariableType.Material)
		{
			return ((Material)valueFromFsmVar).name;
		}
		if (fsmVar.Type == VariableType.Texture)
		{
			return ((Texture2D)valueFromFsmVar).name;
		}
		UnityEngine.Debug.LogWarning("ParseValueToString type not supported " + valueFromFsmVar.GetType());
		return string.Concat("<", fsmVar.Type, "> not supported");
	}

	public static string ParseValueToString(object item, bool useBytes)
	{
		return "";
	}

	public static string ParseValueToString(object item)
	{
		if (item == null)
		{
			return "";
		}
		if (item.GetType() == typeof(string))
		{
			return "string(" + item.ToString() + ")";
		}
		if (item.GetType() == typeof(bool))
		{
			int num = (((bool)item) ? 1 : 0);
			return "bool(" + num + ")";
		}
		if (item.GetType() == typeof(float))
		{
			float num2 = float.Parse(item.ToString());
			return "float(" + num2 + ")";
		}
		if (item.GetType() == typeof(int))
		{
			int num3 = int.Parse(item.ToString());
			return "int(" + num3 + ")";
		}
		if (item.GetType() == typeof(Vector2))
		{
			Vector2 vector = (Vector2)item;
			return "vector2(" + vector.x + "," + vector.y + ")";
		}
		if (item.GetType() == typeof(Vector3))
		{
			Vector3 vector2 = (Vector3)item;
			return "vector3(" + vector2.x + "," + vector2.y + "," + vector2.z + ")";
		}
		if (item.GetType() == typeof(Vector4))
		{
			Vector4 vector3 = (Vector4)item;
			return "vector4(" + vector3.x + "," + vector3.y + "," + vector3.z + "," + vector3.w + ")";
		}
		if (item.GetType() == typeof(Quaternion))
		{
			Quaternion quaternion = (Quaternion)item;
			return "quaternion(" + quaternion.x + "," + quaternion.y + "," + quaternion.z + "," + quaternion.w + ")";
		}
		if (item.GetType() == typeof(Rect))
		{
			Rect rect = (Rect)item;
			return "rect(" + rect.x + "," + rect.y + "," + rect.width + "," + rect.height + ")";
		}
		if (item.GetType() == typeof(Color))
		{
			Color color = (Color)item;
			return "color(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
		}
		if (item.GetType() == typeof(Texture2D))
		{
			byte[] inArray = ((Texture2D)item).EncodeToPNG();
			return "texture(" + Convert.ToBase64String(inArray) + ")";
		}
		if (item.GetType() == typeof(GameObject))
		{
			GameObject gameObject = (GameObject)item;
			return "gameObject(" + gameObject.name + ")";
		}
		UnityEngine.Debug.LogWarning("ParseValueToString type not supported " + item.GetType());
		return string.Concat("<", item.GetType(), "> not supported");
	}

	public static object ParseValueFromString(string source, bool useBytes)
	{
		return null;
	}

	public static object ParseValueFromString(string source, VariableType type)
	{
		Type typeFromHandle = typeof(string);
		switch (type)
		{
		case VariableType.Bool:
			typeFromHandle = typeof(bool);
			break;
		case VariableType.Color:
			typeFromHandle = typeof(Color);
			break;
		case VariableType.Float:
			typeFromHandle = typeof(float);
			break;
		case VariableType.GameObject:
			typeFromHandle = typeof(GameObject);
			break;
		case VariableType.Int:
			typeFromHandle = typeof(int);
			break;
		case VariableType.Quaternion:
			typeFromHandle = typeof(Quaternion);
			break;
		case VariableType.Rect:
			typeFromHandle = typeof(Rect);
			break;
		case VariableType.Vector2:
			typeFromHandle = typeof(Vector2);
			break;
		case VariableType.Vector3:
			typeFromHandle = typeof(Vector3);
			break;
		case VariableType.Unknown:
			return ParseValueFromString(source);
		}
		return ParseValueFromString(source, typeFromHandle);
	}

	public static object ParseValueFromString(string source, Type type)
	{
		if (source == null)
		{
			return null;
		}
		if (type == typeof(string))
		{
			return source;
		}
		if (type == typeof(bool))
		{
			if (string.Equals(source, "true", StringComparison.OrdinalIgnoreCase))
			{
				return true;
			}
			if (string.Equals(source, "false", StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
			return (int.Parse(source) != 0) ? true : false;
		}
		if (type == typeof(int))
		{
			return int.Parse(source);
		}
		if (type == typeof(float))
		{
			return float.Parse(source);
		}
		if (type == typeof(Vector2))
		{
			string text = "vector2\\([x],[y]\\)";
			string text2 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text = text.Replace("[x]", "(?<x>" + text2 + ")");
			text = text.Replace("[y]", "(?<y>" + text2 + ")");
			text = "^\\s*" + text;
			Match match = new Regex(text).Match(source);
			if (match.Groups["x"].Value != "" && match.Groups["y"].Value != "")
			{
				return new Vector2(float.Parse(match.Groups["x"].Value), float.Parse(match.Groups["y"].Value));
			}
			return Vector2.zero;
		}
		if (type == typeof(Vector3))
		{
			string text3 = "vector3\\([x],[y],[z]\\)";
			string text4 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text3 = text3.Replace("[x]", "(?<x>" + text4 + ")");
			text3 = text3.Replace("[y]", "(?<y>" + text4 + ")");
			text3 = text3.Replace("[z]", "(?<z>" + text4 + ")");
			text3 = "^\\s*" + text3;
			Match match2 = new Regex(text3).Match(source);
			if (match2.Groups["x"].Value != "" && match2.Groups["y"].Value != "" && match2.Groups["z"].Value != "")
			{
				return new Vector3(float.Parse(match2.Groups["x"].Value), float.Parse(match2.Groups["y"].Value), float.Parse(match2.Groups["z"].Value));
			}
			return Vector3.zero;
		}
		if (type == typeof(Vector4))
		{
			string text5 = "vector4\\([x],[y],[z],[w]\\)";
			string text6 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text5 = text5.Replace("[x]", "(?<x>" + text6 + ")");
			text5 = text5.Replace("[y]", "(?<y>" + text6 + ")");
			text5 = text5.Replace("[z]", "(?<z>" + text6 + ")");
			text5 = text5.Replace("[w]", "(?<w>" + text6 + ")");
			text5 = "^\\s*" + text5;
			Match match3 = new Regex(text5).Match(source);
			if (match3.Groups["x"].Value != "" && match3.Groups["y"].Value != "" && match3.Groups["z"].Value != "" && match3.Groups["z"].Value != "")
			{
				return new Vector4(float.Parse(match3.Groups["x"].Value), float.Parse(match3.Groups["y"].Value), float.Parse(match3.Groups["z"].Value), float.Parse(match3.Groups["w"].Value));
			}
			return Vector4.zero;
		}
		if (type == typeof(Rect))
		{
			string text7 = "rect\\([x],[y],[w],[h]\\)";
			string text8 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text7 = text7.Replace("[x]", "(?<x>" + text8 + ")");
			text7 = text7.Replace("[y]", "(?<y>" + text8 + ")");
			text7 = text7.Replace("[w]", "(?<w>" + text8 + ")");
			text7 = text7.Replace("[h]", "(?<h>" + text8 + ")");
			text7 = "^\\s*" + text7;
			Match match4 = new Regex(text7).Match(source);
			if (match4.Groups["x"].Value != "" && match4.Groups["y"].Value != "" && match4.Groups["w"].Value != "" && match4.Groups["h"].Value != "")
			{
				return new Rect(float.Parse(match4.Groups["x"].Value), float.Parse(match4.Groups["y"].Value), float.Parse(match4.Groups["w"].Value), float.Parse(match4.Groups["h"].Value));
			}
			return new Rect(0f, 0f, 0f, 0f);
		}
		if (type == typeof(Quaternion))
		{
			string text9 = "quaternion\\([x],[y],[z],[w]\\)";
			string text10 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text9 = text9.Replace("[x]", "(?<x>" + text10 + ")");
			text9 = text9.Replace("[y]", "(?<y>" + text10 + ")");
			text9 = text9.Replace("[z]", "(?<z>" + text10 + ")");
			text9 = text9.Replace("[w]", "(?<w>" + text10 + ")");
			text9 = "^\\s*" + text9;
			Match match5 = new Regex(text9).Match(source);
			if (match5.Groups["x"].Value != "" && match5.Groups["y"].Value != "" && match5.Groups["z"].Value != "" && match5.Groups["z"].Value != "")
			{
				return new Quaternion(float.Parse(match5.Groups["x"].Value), float.Parse(match5.Groups["y"].Value), float.Parse(match5.Groups["z"].Value), float.Parse(match5.Groups["w"].Value));
			}
			return Quaternion.identity;
		}
		if (type == typeof(Color))
		{
			string text11 = "color\\([r],[g],[b],[a]\\)";
			string text12 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text11 = text11.Replace("[r]", "(?<r>" + text12 + ")");
			text11 = text11.Replace("[g]", "(?<g>" + text12 + ")");
			text11 = text11.Replace("[b]", "(?<b>" + text12 + ")");
			text11 = text11.Replace("[a]", "(?<a>" + text12 + ")");
			text11 = "^\\s*" + text11;
			Match match6 = new Regex(text11).Match(source);
			if (match6.Groups["r"].Value != "" && match6.Groups["g"].Value != "" && match6.Groups["b"].Value != "" && match6.Groups["a"].Value != "")
			{
				return new Color(float.Parse(match6.Groups["r"].Value), float.Parse(match6.Groups["g"].Value), float.Parse(match6.Groups["b"].Value), float.Parse(match6.Groups["a"].Value));
			}
			return Color.black;
		}
		if (type == typeof(GameObject))
		{
			source = source.Substring(11, source.Length - 12);
			return GameObject.Find(source);
		}
		UnityEngine.Debug.LogWarning("ParseValueFromString failed for " + source);
		return null;
	}

	public static object ParseValueFromString(string source)
	{
		if (source == null)
		{
			return null;
		}
		if (source.StartsWith("string("))
		{
			source = source.Substring(7, source.Length - 8);
			return source;
		}
		if (source.StartsWith("bool("))
		{
			source = source.Substring(5, source.Length - 6);
			return int.Parse(source) == 1;
		}
		if (source.StartsWith("int("))
		{
			source = source.Substring(4, source.Length - 5);
			return int.Parse(source);
		}
		if (source.StartsWith("float("))
		{
			source = source.Substring(6, source.Length - 7);
			return float.Parse(source);
		}
		if (source.StartsWith("vector2("))
		{
			string text = "vector2\\([x],[y]\\)";
			string text2 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text = text.Replace("[x]", "(?<x>" + text2 + ")");
			text = text.Replace("[y]", "(?<y>" + text2 + ")");
			text = "^\\s*" + text;
			Match match = new Regex(text).Match(source);
			if (match.Groups["x"].Value != "" && match.Groups["y"].Value != "")
			{
				return new Vector2(float.Parse(match.Groups["x"].Value), float.Parse(match.Groups["y"].Value));
			}
			return Vector2.zero;
		}
		if (source.StartsWith("vector3("))
		{
			string text3 = "vector3\\([x],[y],[z]\\)";
			string text4 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text3 = text3.Replace("[x]", "(?<x>" + text4 + ")");
			text3 = text3.Replace("[y]", "(?<y>" + text4 + ")");
			text3 = text3.Replace("[z]", "(?<z>" + text4 + ")");
			text3 = "^\\s*" + text3;
			Match match2 = new Regex(text3).Match(source);
			if (match2.Groups["x"].Value != "" && match2.Groups["y"].Value != "" && match2.Groups["z"].Value != "")
			{
				return new Vector3(float.Parse(match2.Groups["x"].Value), float.Parse(match2.Groups["y"].Value), float.Parse(match2.Groups["z"].Value));
			}
			return Vector3.zero;
		}
		if (source.StartsWith("vector4("))
		{
			string text5 = "vector4\\([x],[y],[z],[w]\\)";
			string text6 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text5 = text5.Replace("[x]", "(?<x>" + text6 + ")");
			text5 = text5.Replace("[y]", "(?<y>" + text6 + ")");
			text5 = text5.Replace("[z]", "(?<z>" + text6 + ")");
			text5 = text5.Replace("[w]", "(?<w>" + text6 + ")");
			text5 = "^\\s*" + text5;
			Match match3 = new Regex(text5).Match(source);
			if (match3.Groups["x"].Value != "" && match3.Groups["y"].Value != "" && match3.Groups["z"].Value != "" && match3.Groups["z"].Value != "")
			{
				return new Vector4(float.Parse(match3.Groups["x"].Value), float.Parse(match3.Groups["y"].Value), float.Parse(match3.Groups["z"].Value), float.Parse(match3.Groups["w"].Value));
			}
			return Vector4.zero;
		}
		if (source.StartsWith("rect("))
		{
			string text7 = "rect\\([x],[y],[w],[h]\\)";
			string text8 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text7 = text7.Replace("[x]", "(?<x>" + text8 + ")");
			text7 = text7.Replace("[y]", "(?<y>" + text8 + ")");
			text7 = text7.Replace("[w]", "(?<w>" + text8 + ")");
			text7 = text7.Replace("[h]", "(?<h>" + text8 + ")");
			text7 = "^\\s*" + text7;
			Match match4 = new Regex(text7).Match(source);
			if (match4.Groups["x"].Value != "" && match4.Groups["y"].Value != "" && match4.Groups["w"].Value != "" && match4.Groups["h"].Value != "")
			{
				return new Rect(float.Parse(match4.Groups["x"].Value), float.Parse(match4.Groups["y"].Value), float.Parse(match4.Groups["w"].Value), float.Parse(match4.Groups["h"].Value));
			}
			return new Rect(0f, 0f, 0f, 0f);
		}
		if (source.StartsWith("quaternion("))
		{
			string text9 = "quaternion\\([x],[y],[z],[w]\\)";
			string text10 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text9 = text9.Replace("[x]", "(?<x>" + text10 + ")");
			text9 = text9.Replace("[y]", "(?<y>" + text10 + ")");
			text9 = text9.Replace("[z]", "(?<z>" + text10 + ")");
			text9 = text9.Replace("[w]", "(?<w>" + text10 + ")");
			text9 = "^\\s*" + text9;
			Match match5 = new Regex(text9).Match(source);
			if (match5.Groups["x"].Value != "" && match5.Groups["y"].Value != "" && match5.Groups["z"].Value != "" && match5.Groups["z"].Value != "")
			{
				return new Quaternion(float.Parse(match5.Groups["x"].Value), float.Parse(match5.Groups["y"].Value), float.Parse(match5.Groups["z"].Value), float.Parse(match5.Groups["w"].Value));
			}
			return Quaternion.identity;
		}
		if (source.StartsWith("color("))
		{
			string text11 = "color\\([r],[g],[b],[a]\\)";
			string text12 = "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?";
			text11 = text11.Replace("[r]", "(?<r>" + text12 + ")");
			text11 = text11.Replace("[g]", "(?<g>" + text12 + ")");
			text11 = text11.Replace("[b]", "(?<b>" + text12 + ")");
			text11 = text11.Replace("[a]", "(?<a>" + text12 + ")");
			text11 = "^\\s*" + text11;
			Match match6 = new Regex(text11).Match(source);
			if (match6.Groups["r"].Value != "" && match6.Groups["g"].Value != "" && match6.Groups["b"].Value != "" && match6.Groups["a"].Value != "")
			{
				return new Color(float.Parse(match6.Groups["r"].Value), float.Parse(match6.Groups["g"].Value), float.Parse(match6.Groups["b"].Value), float.Parse(match6.Groups["a"].Value));
			}
			return Color.black;
		}
		if (source.StartsWith("texture("))
		{
			source = source.Substring(8, source.Length - 9);
			byte[] data = Convert.FromBase64String(source);
			Texture2D texture2D = new Texture2D(16, 16);
			texture2D.LoadImage(data);
			return texture2D;
		}
		if (source.StartsWith("gameObject("))
		{
			source = source.Substring(11, source.Length - 12);
			return GameObject.Find(source);
		}
		UnityEngine.Debug.LogWarning("ParseValueFromString failed for " + source);
		return null;
	}

	public static Quaternion ConvertToQuaternion(object value, Quaternion defaultValue = default(Quaternion))
	{
		if (value is Quaternion)
		{
			return (Quaternion)value;
		}
		return defaultValue;
	}

	public static Rect ConvertToRect(object value, Rect defaultValue = default(Rect))
	{
		if (value is Rect)
		{
			return (Rect)value;
		}
		return defaultValue;
	}

	public static Color ConvertToColor(object value, Color defaultValue = default(Color))
	{
		if (value is Color)
		{
			return (Color)value;
		}
		return defaultValue;
	}

	public static Vector3 ConvertToVector3(object value, Vector3 defaultValue = default(Vector3))
	{
		if (value is Vector3)
		{
			return (Vector3)value;
		}
		return defaultValue;
	}

	public static Vector2 ConvertToVector2(object value, Vector2 defaultValue = default(Vector2))
	{
		if (value is Vector2)
		{
			return (Vector2)value;
		}
		return defaultValue;
	}

	public static Vector4 ConvertToVector2(object value, Vector4 defaultValue = default(Vector4))
	{
		if (value is Vector4)
		{
			return (Vector4)value;
		}
		return defaultValue;
	}
}
public class ActivationEventScript : MonoBehaviour
{
	public bool globalSubscription;

	public bool localSubscription;

	public RayfireRigid localRigidComponent;

	private void OnEnable()
	{
		if (globalSubscription)
		{
			RFActivationEvent.GlobalEvent += GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.activationEvent.LocalEvent += LocalMethod;
		}
	}

	private void OnDisable()
	{
		if (globalSubscription)
		{
			RFActivationEvent.GlobalEvent -= GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.activationEvent.LocalEvent -= LocalMethod;
		}
	}

	private void LocalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Local activation: " + rigid.name + " was just activated");
	}

	private void GlobalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Global activation: " + rigid.name + " was just activated");
	}
}
public class AddRigidComponent : MonoBehaviour
{
	public GameObject targetObject;

	private void Update()
	{
		if (Input.GetKeyDown("space") && targetObject != null)
		{
			RayfireRigid rayfireRigid = targetObject.AddComponent<RayfireRigid>();
			rayfireRigid.simulationType = SimType.Dynamic;
			rayfireRigid.demolitionType = DemolitionType.Runtime;
			rayfireRigid.objectType = ObjectType.Mesh;
			rayfireRigid.Initialize();
		}
	}
}
public class ApplyDamageScript : MonoBehaviour
{
	public RayfireRigid rigid;

	public float damageValue = 50f;

	public Transform damagePoint;

	public float damageRadius = 2f;

	private void Update()
	{
		if (Input.GetKeyDown("space") && rigid != null)
		{
			Vector3 vector = Vector3.zero;
			if (damagePoint != null)
			{
				vector = damagePoint.position;
			}
			rigid.ApplyDamage(damageValue, vector, damageRadius);
		}
	}
}
public class DemolitionEventScript : MonoBehaviour
{
	public bool globalSubscription;

	public bool localSubscription;

	public RayfireRigid localRigidComponent;

	private void OnEnable()
	{
		if (globalSubscription)
		{
			RFDemolitionEvent.GlobalEvent += GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.demolitionEvent.LocalEvent += LocalMethod;
		}
	}

	private void OnDisable()
	{
		if (globalSubscription)
		{
			RFActivationEvent.GlobalEvent -= GlobalMethod;
		}
		if (localSubscription && localRigidComponent != null)
		{
			localRigidComponent.demolitionEvent.LocalEvent -= LocalMethod;
		}
	}

	private void LocalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Local demolition: " + rigid.name + " was just demolished and created " + rigid.fragments.Count + " fragments");
		UnityEngine.Debug.Log("Contact point: " + rigid.limitations.contactVector3.ToString());
		base.transform.position = rigid.limitations.contactVector3;
	}

	private void GlobalMethod(RayfireRigid rigid)
	{
		UnityEngine.Debug.Log("Global demolition: " + rigid.name + " was just demolished and created " + rigid.fragments.Count + " fragments");
		UnityEngine.Debug.Log("Contact point: " + rigid.limitations.contactVector3.ToString());
		base.transform.position = rigid.limitations.contactVector3;
	}
}
[CreateAssetMenu(menuName = "Custom/Achievement")]
public class Achievement : ScriptableObject
{
	public enum AchievementType
	{
		Single,
		Count,
		Flags
	}

	public AchievementType type;

	public int requiredCount;

	public int totalCount;

	public string APIName;

	public float GetPercentage(AchievementManager.AchievementStatus status)
	{
		switch (type)
		{
		case AchievementType.Flags:
		{
			char[] array = status.bitfield.ToCharArray();
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == '1')
				{
					num++;
				}
			}
			return Mathf.Min((float)num / (float)requiredCount * 100f, 100f);
		}
		case AchievementType.Count:
			return Mathf.Min((float)status.count / (float)requiredCount * 100f, 100f);
		default:
			return status.achieved ? 100 : 0;
		}
	}
}
public class AchievementDisplayManager : MonoBehaviour
{
	public TextMeshProUGUI[] achievementPercentages;

	public void OnEnable()
	{
		float[] percentages = References.AchievementManager.GetPercentages();
		for (int i = 0; i < percentages.Length; i++)
		{
			achievementPercentages[i].SetText(Mathf.RoundToInt(percentages[i]) + "%");
		}
	}
}
public class AchievementManager : MonoBehaviour
{
	[Serializable]
	public class AchievementStatus
	{
		public bool achieved;

		public ulong count;

		public string bitfield;
	}

	public List<Achievement> achievements;

	public Achievement hardModeAchievement;

	public Achievement allCompleteAchievement;

	private AchievementStatus[] _achievements;

	public void Start()
	{
		_achievements = new AchievementStatus[achievements.Count];
		for (int i = 0; i < _achievements.Length; i++)
		{
			string text = string.Empty;
			if (achievements[i].type == Achievement.AchievementType.Flags)
			{
				text = text.PadLeft(achievements[i].totalCount, '0');
			}
			_achievements[i] = new AchievementStatus
			{
				bitfield = text
			};
			AchievementStatus achievement = ProfileManager.GetAchievement(i);
			if (achievement != null)
			{
				_achievements[i].achieved = achievement.achieved;
				_achievements[i].count = achievement.count;
				_achievements[i].bitfield = achievement.bitfield;
			}
		}
		Message<AchievementProgressList>.Callback callback = OnProgressGet;
		Achievements.GetAllProgress().OnComplete(callback);
	}

	private void OnProgressGet(Message<AchievementProgressList> message)
	{
		if (message.IsError)
		{
			UnityEngine.Debug.LogError("Error: " + message.GetError().Message + " (" + message.GetError().Code + ")");
			return;
		}
		AchievementProgressList list = message.GetAchievementProgressList();
		bool flag = false;
		int i;
		for (i = 0; i < list.Count; i++)
		{
			int num = achievements.FindIndex((Achievement x) => x.APIName == list[i].Name);
			if (num != -1)
			{
				_achievements[num].achieved = list[i].IsUnlocked;
				_achievements[num].count = list[i].Count;
				_achievements[num].bitfield = list[i].Bitfield;
				flag = ProfileManager.UpdateAchievement(num, _achievements[num]) || flag;
			}
		}
		if (flag)
		{
			ProfileManager.SaveProfileIndex();
		}
	}

	public void SetAchievement(int id, AchievementStatus status)
	{
		Achievement achievement = achievements[id];
		try
		{
			if (status.achieved)
			{
				_achievements[id].achieved = true;
				Achievements.Unlock(achievement.APIName);
			}
			if (_achievements[id].count < status.count)
			{
				Achievements.AddCount(achievement.APIName, status.count - _achievements[id].count);
				_achievements[id].count = status.count;
			}
			if (_achievements[id].bitfield != status.bitfield)
			{
				Achievements.AddFields(achievement.APIName, status.bitfield);
				_achievements[id].bitfield = status.bitfield;
			}
			Achievement.AchievementType type = achievement.type;
			if (type == Achievement.AchievementType.Flags)
			{
				_achievements[id].achieved = true;
				Achievements.Unlock(achievement.APIName);
			}
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message + "\n" + ex.StackTrace);
		}
	}

	public void UpdateAchievement(Achievement achievement, int addValue)
	{
		try
		{
			int num = achievements.IndexOf(achievement);
			switch (achievement.type)
			{
			case Achievement.AchievementType.Single:
				_achievements[num].achieved = true;
				ProfileManager.UpdateAchievement(num, _achievements[num]);
				Achievements.Unlock(achievement.APIName);
				break;
			case Achievement.AchievementType.Count:
			{
				ulong num2 = (ulong)addValue;
				ulong count = _achievements[num].count;
				if (count < num2)
				{
					_achievements[num].count = num2;
					if (achievements[num].GetPercentage(_achievements[num]) == 100f)
					{
						_achievements[num].achieved = true;
					}
					ProfileManager.UpdateAchievement(num, _achievements[num]);
					Achievements.AddCount(achievement.APIName, num2 - count);
				}
				break;
			}
			case Achievement.AchievementType.Flags:
			{
				StringBuilder stringBuilder = new StringBuilder(_achievements[num].bitfield);
				if (stringBuilder.Length < achievements[num].totalCount)
				{
					stringBuilder.Append('0', achievements[num].totalCount - stringBuilder.Length);
				}
				stringBuilder[addValue] = '1';
				_achievements[num].bitfield = stringBuilder.ToString();
				if (achievements[num].GetPercentage(_achievements[num]) == 100f)
				{
					_achievements[num].achieved = true;
				}
				ProfileManager.UpdateAchievement(num, _achievements[num]);
				Achievements.AddFields(achievement.APIName, _achievements[num].bitfield);
				break;
			}
			}
			if (!(achievement != allCompleteAchievement))
			{
				return;
			}
			num = achievements.IndexOf(allCompleteAchievement);
			for (int i = 0; i < _achievements.Length; i++)
			{
				if (i != num && !_achievements[i].achieved)
				{
					return;
				}
			}
			UpdateAchievement(allCompleteAchievement, 1);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message + "\n" + ex.StackTrace);
		}
	}

	public void Win()
	{
		if (Player.Instance.lowestDifficulty == Difficulty.Hard)
		{
			UpdateAchievement(hardModeAchievement, 1);
		}
	}

	public float[] GetPercentages()
	{
		float[] array = new float[_achievements.Length];
		for (int i = 0; i < _achievements.Length; i++)
		{
			array[i] = achievements[i].GetPercentage(_achievements[i]);
		}
		return array;
	}
}
public class AchievementSetter : MonoBehaviour
{
	public Achievement achievement;

	[UnityEngine.Tooltip("This ID should be unique for this achievement and between 0 and 1 less than the total number of items of this type available to be picked up.")]
	public int id = -1;

	private Destroyable container;

	public void SetID(int id)
	{
		this.id = id;
	}

	public void SetContainer(Destroyable container)
	{
		this.container = container;
	}

	public void Collect()
	{
		if (achievement != null && id > -1)
		{
			References.AchievementManager.UpdateAchievement(achievement, id);
		}
		if (container != null)
		{
			container.Collect();
		}
	}
}
public class Burnable : TemperatureObjectAmbient
{
	private Material _material;

	public Color baseColor;

	public Color burnColor;

	public Color freezeColor;

	public void Start()
	{
		_material = GetComponent<Renderer>().material;
		_material.color = baseColor;
	}

	public void Update()
	{
		if (_currentTemp >= (float)maxTemp)
		{
			UnityEngine.Object.Destroy(base.gameObject);
			return;
		}
		float t = _currentTemp / ((float)maxTemp - (float)defaultTemp);
		if (_currentTemp >= (float)defaultTemp)
		{
			_material.color = new Color(Mathf.Lerp(baseColor.r, burnColor.r, t), Mathf.Lerp(baseColor.g, burnColor.g, t), Mathf.Lerp(baseColor.b, burnColor.b, t), Mathf.Lerp(baseColor.a, burnColor.a, t));
		}
		else
		{
			t = (0f - _currentTemp) / ((float)defaultTemp - (float)minTemp);
			_material.color = new Color(Mathf.Lerp(baseColor.r, freezeColor.r, t), Mathf.Lerp(baseColor.g, freezeColor.g, t), Mathf.Lerp(baseColor.b, freezeColor.b, t), Mathf.Lerp(baseColor.a, freezeColor.a, t));
		}
		base.enabled = ApplyAmbientTemp();
	}
}
public class CanvasGroupFade : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public float fadeTime = 0.1f;

	public float preDelay = 0.1f;

	private CoroutineHandle _handle;

	public void FadeOut()
	{
		_handle = Timing.RunCoroutineSingleton(FadeOutRoutine(), _handle, Segment.RealtimeUpdate, SingletonBehavior.Overwrite);
	}

	public void FadeIn()
	{
		_handle = Timing.RunCoroutineSingleton(FadeInRoutine(), _handle, Segment.RealtimeUpdate, SingletonBehavior.Overwrite);
	}

	public void Toggle()
	{
		if (canvasGroup.alpha > 0.5f)
		{
			_handle = Timing.RunCoroutineSingleton(FadeOutRoutine(), _handle, Segment.RealtimeUpdate, SingletonBehavior.Overwrite);
		}
		else
		{
			_handle = Timing.RunCoroutineSingleton(FadeInRoutine(), _handle, Segment.RealtimeUpdate, SingletonBehavior.Overwrite);
		}
	}

	private IEnumerator<float> FadeOutRoutine()
	{
		canvasGroup.alpha = 1f;
		canvasGroup.interactable = false;
		while (canvasGroup.alpha > 0f)
		{
			canvasGroup.alpha -= Timing.DeltaTime / fadeTime;
			yield return float.NegativeInfinity;
		}
		canvasGroup.alpha = 0f;
		base.gameObject.SetActive(value: false);
	}

	private IEnumerator<float> FadeInRoutine()
	{
		canvasGroup.interactable = false;
		canvasGroup.alpha = 0f;
		base.gameObject.SetActive(value: true);
		yield return Timing.WaitForSeconds(preDelay);
		while (canvasGroup.alpha < 1f)
		{
			canvasGroup.alpha += Timing.DeltaTime / fadeTime;
			yield return float.NegativeInfinity;
		}
		canvasGroup.alpha = 1f;
		canvasGroup.interactable = true;
	}
}
public class CombatTracker : Singleton<CombatTracker>
{
	private static readonly HashSet<Mob> _mobs = new HashSet<Mob>();

	public static bool IsInCombat => _mobs.Count > 0;

	public static void Engage(Mob mob)
	{
		if (!(mob == null))
		{
			if (_mobs.Count == 0)
			{
				References.Combat.RaiseTrue();
			}
			_mobs.Add(mob);
		}
	}

	public static void Disengage(Mob mob)
	{
		if (!(mob == null) && _mobs.Contains(mob))
		{
			_mobs.Remove(mob);
			if (_mobs.Count == 0)
			{
				References.Combat.RaiseFalse();
			}
		}
	}

	public static void DisengageAll()
	{
		_mobs.Clear();
		References.Combat.RaiseFalse();
	}
}
public class ControllerLayoutMenu : MonoBehaviour
{
	public LocalizeText rightStick;

	public LocalizeText leftStick;

	public GameObject buttonRightStick;

	public GameObject buttonLeftStick;

	public LocalizeText buttonA;

	public LocalizeText buttonB;

	public LocalizeText buttonX;

	public LocalizeText buttonY;

	private void OnEnable()
	{
		if (Settings.Current.dominantHand == HandMode.Right)
		{
			buttonA.SetText("Text_menu_controller_switch");
			buttonA.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_switch_help";
			buttonB.SetText("Text_menu_controller_inventory");
			buttonB.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_inventory_help";
			buttonX.SetText("Text_menu_controller_view");
			buttonX.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_view_help";
			buttonY.SetText("Text_menu_controller_hint");
			buttonY.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_hint_help";
			buttonRightStick.SetActive(value: false);
			buttonLeftStick.SetActive(value: true);
		}
		else
		{
			buttonX.SetText("Text_menu_controller_switch");
			buttonX.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_switch_help";
			buttonY.SetText("Text_menu_controller_inventory");
			buttonY.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_inventory_help";
			buttonA.SetText("Text_menu_controller_view");
			buttonA.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_view_help";
			buttonB.SetText("Text_menu_controller_hint");
			buttonB.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_hint_help";
			buttonRightStick.SetActive(value: true);
			buttonLeftStick.SetActive(value: false);
		}
		if (Settings.Current.teleportHand.HasFlag(HandMode.Right))
		{
			rightStick.SetText("Text_menu_controller_teleport");
			rightStick.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_teleport_help";
		}
		else
		{
			rightStick.SetText("Text_menu_controller_locomotion");
			rightStick.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_locomotion_help";
		}
		if (Settings.Current.teleportHand.HasFlag(HandMode.Left))
		{
			leftStick.SetText("Text_menu_controller_teleport");
			leftStick.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_teleport_help";
		}
		else
		{
			leftStick.SetText("Text_menu_controller_locomotion");
			leftStick.GetComponent<MenuTooltipHover>().textID = "Text_menu_controller_locomotion_help";
		}
	}
}
public class Credits : MonoBehaviour
{
	public float duration;

	public float scrollStart;

	public float scrollEnd;

	public GameObject next;

	public CanvasGroupFade fadeIn;

	public CanvasGroupFade fadeOut;

	private CoroutineHandle _handle;

	private float _height;

	private void OnEnable()
	{
		int childCount = base.transform.childCount;
		_height = 0f;
		for (int i = 0; i < childCount; i++)
		{
			RectTransform obj = (RectTransform)base.transform.GetChild(i);
			TextMeshProUGUI component = obj.GetComponent<TextMeshProUGUI>();
			obj.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, component.preferredHeight);
			obj.localPosition = new Vector2(0f, 0f - _height);
			_height += component.preferredHeight;
		}
		((RectTransform)base.transform).SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, _height);
		base.transform.localPosition = new Vector3(0f, scrollStart, base.transform.localPosition.z);
		_handle = Timing.RunCoroutine(Scroll(scrollStart, _height + scrollEnd), Segment.RealtimeUpdate);
	}

	private void OnDisable()
	{
		Timing.KillCoroutines(_handle);
	}

	private IEnumerator<float> Scroll(float start, float end)
	{
		bool hasNext = next != null;
		for (float t = 0f; t < duration; t += Time.unscaledDeltaTime)
		{
			yield return float.NegativeInfinity;
			float num = Mathf.Lerp(start, end, t / duration);
			base.transform.localPosition = new Vector3(0f, num, base.transform.localPosition.z);
			if (hasNext && num > _height + scrollStart)
			{
				next.SetActive(value: true);
				hasNext = false;
			}
		}
		base.transform.localPosition = new Vector3(0f, end, base.transform.localPosition.z);
		if (fadeIn != null)
		{
			fadeIn.FadeIn();
		}
		if (fadeOut != null)
		{
			fadeOut.FadeOut();
		}
	}
}
public class CubeLineRenderer : MonoBehaviour
{
	public Transform cube;

	public Transform target;

	public float width = 0.01f;

	private void Awake()
	{
		Vector3 position = cube.position;
		cube.position = (position + target.position) / 2f;
		cube.LookAt(target);
		cube.localScale = new Vector3(width / cube.lossyScale.x, width / cube.lossyScale.y, Vector3.Distance(position, target.position) / cube.lossyScale.z);
	}
}
public class DamageInstant : MonoBehaviour
{
	public bool damageOnEnabled;

	public bool disableGameobjectAfterEnabled = true;

	public DamageType damageType;

	public int damageAmount;

	public ColliderType colliderType;

	public Vector3 center;

	public Vector3 center2;

	public float radius;

	public DamageTargets validTargets = DamageTargets.Player | DamageTargets.Enemies | DamageTargets.Objects;

	[UnityEngine.Tooltip("The object entered here will be immune to damage from this attack - usually this will be the source of the attack")]
	public GameObject immune;

	private IDamageable _immune;

	private static readonly HashSet<IDamageable> _hit = new HashSet<IDamageable>();

	private void OnValidate()
	{
		if (immune != null)
		{
			_immune = immune.GetComponent<IDamageable>();
			if (_immune == null)
			{
				immune = null;
			}
		}
		else
		{
			_immune = null;
		}
	}

	private void OnEnable()
	{
		if (damageOnEnabled)
		{
			Damage();
			if (disableGameobjectAfterEnabled)
			{
				base.enabled = false;
			}
		}
	}

	public void Damage()
	{
		int num = 0;
		switch (colliderType)
		{
		case ColliderType.Box:
			num = Physics.OverlapBoxNonAlloc(halfExtents: new Vector3(center2.x * base.transform.lossyScale.x, center2.y * base.transform.lossyScale.y, center2.z * base.transform.lossyScale.z) / 2f, center: base.transform.TransformPoint(center), results: Utilities.colliderPool, orientation: base.transform.rotation);
			break;
		case ColliderType.Sphere:
			num = Physics.OverlapSphereNonAlloc(base.transform.TransformPoint(center), radius, Utilities.colliderPool);
			break;
		case ColliderType.Capsule:
		{
			Vector3 position = new Vector3(center.x * base.transform.lossyScale.x, center.y * base.transform.lossyScale.y, center.z * base.transform.lossyScale.z);
			Vector3 position2 = new Vector3(center2.x * base.transform.lossyScale.x, center2.y * base.transform.lossyScale.y, center2.z * base.transform.lossyScale.z);
			num = Physics.OverlapCapsuleNonAlloc(base.transform.TransformPoint(position), base.transform.TransformPoint(position2), radius, Utilities.colliderPool);
			break;
		}
		}
		for (int i = 0; i < num; i++)
		{
			IDamageable target = Utilities.colliderPool[i].GetComponentInParent<IDamageable>();
			if (validTargets.IsValidTarget(ref target) && _hit.Add(target))
			{
				target.ApplyDamage(damageAmount, "Damage Instant: " + base.name, damageType);
			}
		}
		_hit.Clear();
	}
}
public class DamageTrigger : MonoBehaviour
{
	public DamageType damageType;

	public int damageAmount;

	private void OnTriggerEnter(Collider other)
	{
		CarryableItem componentInParent = other.GetComponentInParent<CarryableItem>();
		if (!(componentInParent != null) || componentInParent.TryGetComponent<IDamageable>(out var _))
		{
			IDamageable componentInParent2 = other.GetComponentInParent<IDamageable>();
			if (componentInParent2 != null)
			{
				componentInParent2 = componentInParent2.GetTarget();
				componentInParent2.ApplyDamage(damageAmount, "Damage Trigger: " + base.name, damageType);
			}
		}
	}
}
public class DamageZone : MonoBehaviour
{
	public DamageType damageType;

	public int damageAmount;

	public float damageFrequency;

	public DamageTargets validTargets = DamageTargets.Player | DamageTargets.Enemies | DamageTargets.Objects;

	private readonly HashSet<Collider> _recentlyChecked = new HashSet<Collider>();

	private readonly HashSet<IDamageable> _recentlyDamaged = new HashSet<IDamageable>();

	private void OnEnable()
	{
		_recentlyChecked.Clear();
		_recentlyDamaged.Clear();
	}

	private void OnDisable()
	{
		_recentlyChecked.Clear();
		_recentlyDamaged.Clear();
	}

	private void OnTriggerEnter(Collider other)
	{
		DamageTarget(other);
	}

	private void OnTriggerStay(Collider other)
	{
		DamageTarget(other);
	}

	private void DamageTarget(Collider other)
	{
		if (_recentlyChecked.Add(other) && !(other.GetComponentInParent<CarryableItem>() != null))
		{
			IDamageable target = other.GetComponentInParent<IDamageable>();
			if (validTargets.IsValidTarget(ref target) && _recentlyDamaged.Add(target))
			{
				target.ApplyDamage(damageAmount, "Damage Zone: " + base.name, damageType);
				Timing.RunCoroutine(DamageTimer(other, target));
			}
		}
	}

	private IEnumerator<float> DamageTimer(Collider collider, IDamageable target)
	{
		yield return Timing.WaitForSeconds(damageFrequency);
		if (collider != null)
		{
			_recentlyChecked.Remove(collider);
		}
		if (target != null)
		{
			_recentlyDamaged.Remove(target);
		}
	}
}
public class Destroyable : MonoBehaviour, ISaveSerializable, IDamageable
{
	[Serializable]
	public class Data : ISaveData
	{
		[SerializeField]
		private bool _isDestroyed;

		[SerializeField]
		private bool _isCollected;

		[SerializeField]
		private string _destroyAnimation;

		public void Serialize(ISaveSerializable target)
		{
			Destroyable destroyable = (Destroyable)target;
			_isDestroyed = destroyable._isDestroyed;
			_isCollected = destroyable._isCollected;
			_destroyAnimation = destroyable._destroyAnimation;
		}

		public void Deserialize(ISaveSerializable target)
		{
			Destroyable destroyable = (Destroyable)target;
			destroyable._isDestroyed = _isDestroyed;
			destroyable.gameObject.SetActive(!_isDestroyed);
			if (destroyable._destroyedInstance != null)
			{
				UnityEngine.Object.Destroy(destroyable._destroyedInstance);
				destroyable._destroyedInstance = null;
			}
			if (_isDestroyed)
			{
				destroyable._destroyedInstance = UnityEngine.Object.Instantiate(destroyable.crushPrefab, destroyable.transform.position, destroyable.transform.rotation);
				destroyable._destroyedInstance.transform.parent = destroyable.transform.parent;
				destroyable._destroyedInstance.GetComponent<RandomAnimationPlayer>().SetToEndOfAnimation(_destroyAnimation);
				AchievementSetter componentInChildren = destroyable._destroyedInstance.GetComponentInChildren<AchievementSetter>();
				if (componentInChildren != null)
				{
					componentInChildren.SetID(destroyable.gatherableObjectID);
					componentInChildren.SetContainer(destroyable);
					if (_isCollected)
					{
						componentInChildren.gameObject.SetActive(value: false);
					}
				}
			}
			destroyable._isCollected = _isCollected;
			destroyable._destroyAnimation = _destroyAnimation;
		}
	}

	public GameObject crushPrefab;

	[UnityEngine.Tooltip("This ID will be applied to the coins or shield gem inside the container. It should be unique and no higher than the total number of items of this type available to be picked up.")]
	public int gatherableObjectID;

	private bool _isDestroyed;

	private bool _isCollected;

	private string _destroyAnimation;

	private GameObject _destroyedInstance;

	public IDamageable GetTarget()
	{
		return this;
	}

	public void ApplyDamage(int amount, string source, DamageType type = DamageType.None)
	{
		if (amount >= 0)
		{
			_destroyedInstance = UnityEngine.Object.Instantiate(crushPrefab, base.transform.position, base.transform.rotation);
			_destroyedInstance.transform.parent = base.transform.parent;
			if (_destroyedInstance.TryGetComponent<AudioSource>(out var component))
			{
				component.Play();
			}
			_destroyAnimation = _destroyedInstance.GetComponent<RandomAnimationPlayer>().PlayRandomAnimation();
			AchievementSetter componentInChildren = _destroyedInstance.GetComponentInChildren<AchievementSetter>();
			if (componentInChildren != null)
			{
				componentInChildren.SetID(gatherableObjectID);
				componentInChildren.SetContainer(this);
			}
			base.gameObject.SetActive(value: false);
			_isDestroyed = true;
		}
	}

	public bool IsDestroyed()
	{
		return _isDestroyed;
	}

	public void Collect()
	{
		_isCollected = true;
	}

	public ISaveData Serialize()
	{
		Data data = new Data();
		data.Serialize(this);
		return data;
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((Data)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<Data>(saveData).Deserialize(this);
	}
}
public class DisableOnMRC : MonoBehaviour
{
	public bool quest2Only;

	private void Start()
	{
		if (quest2Only && OVRPlugin.GetSystemHeadsetType() != OVRPlugin.SystemHeadset.Oculus_Quest_2)
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
		if (base.transform.parent.name.StartsWith("OculusMRC_"))
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class DisableOnPlayerInterfaceLock : MonoBehaviour
{
	public void Awake()
	{
		References.PlayerInterfaceLock.OnLock += Disable;
		References.PlayerInterfaceLock.OnUnlock += Enable;
	}

	public void OnDestroy()
	{
		References.PlayerInterfaceLock.OnLock -= Disable;
		References.PlayerInterfaceLock.OnUnlock -= Enable;
	}

	private void Enable()
	{
		base.gameObject.SetActive(value: true);
	}

	private void Disable()
	{
		base.gameObject.SetActive(value: false);
	}
}
public class DragonFire : MonoBehaviour
{
	public DamageType damageType;

	public FloatReference shieldDamage;

	public FloatReference stoneDamage;

	public float impactStrength;

	private List<ParticleCollisionEvent> _collisionEvents = new List<ParticleCollisionEvent>();

	private List<ParticleSystem.Particle> _particles = new List<ParticleSystem.Particle>();

	private ParticleSystem _system;

	private void Start()
	{
		_system = GetComponent<ParticleSystem>();
		_system.trigger.SetCollider(0, Player.Instance.collider);
	}

	private void OnParticleTrigger()
	{
		Player.Instance.ApplyDamage(_system.GetTriggerParticles(ParticleSystemTriggerEventType.Enter, _particles), "Dragon fire", damageType);
	}

	private void OnParticleCollision(GameObject other)
	{
		Shield componentInParent = other.GetComponentInParent<Shield>();
		if (componentInParent != null)
		{
			componentInParent.ConsumeDuration((float)_system.GetCollisionEvents(other, _collisionEvents) * (float)shieldDamage);
		}
		RayfireRigid component = other.GetComponent<RayfireRigid>();
		if (component != null)
		{
			Vector3 vector = Physics.ClosestPoint(base.transform.position, component.GetComponent<Collider>(), component.transform.position, component.transform.rotation);
			if (component.fading.state != 0)
			{
				component.GetComponent<Rigidbody>().AddExplosionForce((float)_system.GetCollisionEvents(other, _collisionEvents) * impactStrength, vector, 1f, 0f, ForceMode.Force);
			}
			else if (component.damage.currentDamage < component.damage.maxDamage)
			{
				component.ApplyDamage((float)_system.GetCollisionEvents(other, _collisionEvents) * (float)stoneDamage, vector, 1f);
			}
		}
	}
}
[CreateAssetMenu(menuName = "Custom/Game Event")]
public class GameEvent : ScriptableObject
{
	public System.Action OnTrue;

	public System.Action OnFalse;

	public Action<bool> OnRaise;

	public void Raise()
	{
		RaiseTrue();
	}

	public void Raise(bool val)
	{
		if (val)
		{
			RaiseTrue();
		}
		else
		{
			RaiseFalse();
		}
	}

	public void RaiseTrue()
	{
		if (OnTrue != null)
		{
			OnTrue();
		}
		if (OnRaise != null)
		{
			OnRaise(obj: true);
		}
	}

	public void RaiseFalse()
	{
		if (OnFalse != null)
		{
			OnFalse();
		}
		if (OnRaise != null)
		{
			OnRaise(obj: false);
		}
	}
}
public class GameEventListener : MonoBehaviour
{
	[UnityEngine.Tooltip("GameEvent to respond to.")]
	public GameEvents gameEvent;

	public bool registerOnAwake;

	public bool registerOnEnable;

	public bool unregisterOnDisable;

	public bool invertResponseValue;

	public BoolUnityEvent response;

	public BoolUnityEvent onTrue;

	public BoolUnityEvent onFalse;

	private bool _isRegistered;

	private GameEvent _gameEvent;

	private void Awake()
	{
		_gameEvent = References.GetGameEvent(gameEvent);
		if (registerOnAwake)
		{
			Register();
		}
	}

	private void OnEnable()
	{
		if (registerOnEnable)
		{
			Register();
		}
	}

	private void OnDisable()
	{
		if (unregisterOnDisable)
		{
			Unregister();
		}
	}

	private void OnDestroy()
	{
		Unregister();
	}

	public void Register()
	{
		if (!_isRegistered)
		{
			if (invertResponseValue)
			{
				GameEvent obj = _gameEvent;
				obj.OnTrue = (System.Action)Delegate.Combine(obj.OnTrue, new System.Action(OnFalse));
				GameEvent obj2 = _gameEvent;
				obj2.OnFalse = (System.Action)Delegate.Combine(obj2.OnFalse, new System.Action(OnTrue));
				GameEvent obj3 = _gameEvent;
				obj3.OnRaise = (Action<bool>)Delegate.Combine(obj3.OnRaise, new Action<bool>(OnRaiseInverse));
			}
			else
			{
				GameEvent obj4 = _gameEvent;
				obj4.OnTrue = (System.Action)Delegate.Combine(obj4.OnTrue, new System.Action(OnTrue));
				GameEvent obj5 = _gameEvent;
				obj5.OnFalse = (System.Action)Delegate.Combine(obj5.OnFalse, new System.Action(OnFalse));
				GameEvent obj6 = _gameEvent;
				obj6.OnRaise = (Action<bool>)Delegate.Combine(obj6.OnRaise, new Action<bool>(OnRaise));
			}
			_isRegistered = true;
		}
	}

	public void Unregister()
	{
		if (_isRegistered)
		{
			if (invertResponseValue)
			{
				GameEvent obj = _gameEvent;
				obj.OnTrue = (System.Action)Delegate.Remove(obj.OnTrue, new System.Action(OnFalse));
				GameEvent obj2 = _gameEvent;
				obj2.OnFalse = (System.Action)Delegate.Remove(obj2.OnFalse, new System.Action(OnTrue));
				GameEvent obj3 = _gameEvent;
				obj3.OnRaise = (Action<bool>)Delegate.Remove(obj3.OnRaise, new Action<bool>(OnRaiseInverse));
			}
			else
			{
				GameEvent obj4 = _gameEvent;
				obj4.OnTrue = (System.Action)Delegate.Remove(obj4.OnTrue, new System.Action(OnTrue));
				GameEvent obj5 = _gameEvent;
				obj5.OnFalse = (System.Action)Delegate.Remove(obj5.OnFalse, new System.Action(OnFalse));
				GameEvent obj6 = _gameEvent;
				obj6.OnRaise = (Action<bool>)Delegate.Remove(obj6.OnRaise, new Action<bool>(OnRaise));
			}
			_isRegistered = false;
		}
	}

	private void OnTrue()
	{
		onTrue.Invoke(arg0: true);
	}

	private void OnFalse()
	{
		onFalse.Invoke(arg0: false);
	}

	private void OnRaise(bool val)
	{
		response.Invoke(val);
	}

	private void OnRaiseInverse(bool val)
	{
		response.Invoke(!val);
	}
}
public class GameEventListenerBoolUnityEvent : MonoBehaviour
{
	[Serializable]
	public class BoolEventResponse
	{
		[UnityEngine.Tooltip("GameEvent to respond to.")]
		public GameEvent gameEvent;

		public BoolUnityEvent response;

		public BoolUnityEvent onTrue;

		public BoolUnityEvent onFalse;

		public void OnTrue()
		{
			onTrue.Invoke(arg0: true);
		}

		public void OnFalse()
		{
			onFalse.Invoke(arg0: false);
		}

		public void OnRaise(bool val)
		{
			response.Invoke(val);
		}

		public void OnRaiseInverse(bool val)
		{
			response.Invoke(!val);
		}
	}

	public bool registerOnAwake;

	public bool registerOnEnable;

	public bool unregisterOnDisable;

	public bool invertResponseValue;

	public BoolEventResponse[] eventResponses;

	private bool _isRegistered;

	private void Awake()
	{
		if (registerOnAwake)
		{
			Register();
		}
	}

	private void OnEnable()
	{
		if (registerOnEnable)
		{
			Register();
		}
	}

	private void OnDisable()
	{
		if (unregisterOnDisable)
		{
			Unregister();
		}
	}

	private void OnDestroy()
	{
		Unregister();
	}

	public void Register()
	{
		if (_isRegistered)
		{
			return;
		}
		for (int i = 0; i < eventResponses.Length; i++)
		{
			if (invertResponseValue)
			{
				GameEvent gameEvent = eventResponses[i].gameEvent;
				gameEvent.OnTrue = (System.Action)Delegate.Combine(gameEvent.OnTrue, new System.Action(eventResponses[i].OnFalse));
				GameEvent gameEvent2 = eventResponses[i].gameEvent;
				gameEvent2.OnFalse = (System.Action)Delegate.Combine(gameEvent2.OnFalse, new System.Action(eventResponses[i].OnTrue));
				GameEvent gameEvent3 = eventResponses[i].gameEvent;
				gameEvent3.OnRaise = (Action<bool>)Delegate.Combine(gameEvent3.OnRaise, new Action<bool>(eventResponses[i].OnRaiseInverse));
			}
			else
			{
				GameEvent gameEvent4 = eventResponses[i].gameEvent;
				gameEvent4.OnTrue = (System.Action)Delegate.Combine(gameEvent4.OnTrue, new System.Action(eventResponses[i].OnTrue));
				GameEvent gameEvent5 = eventResponses[i].gameEvent;
				gameEvent5.OnFalse = (System.Action)Delegate.Combine(gameEvent5.OnFalse, new System.Action(eventResponses[i].OnFalse));
				GameEvent gameEvent6 = eventResponses[i].gameEvent;
				gameEvent6.OnRaise = (Action<bool>)Delegate.Combine(gameEvent6.OnRaise, new Action<bool>(eventResponses[i].OnRaise));
			}
		}
		_isRegistered = true;
	}

	public void Unregister()
	{
		if (!_isRegistered)
		{
			return;
		}
		for (int i = 0; i < eventResponses.Length; i++)
		{
			if (invertResponseValue)
			{
				GameEvent gameEvent = eventResponses[i].gameEvent;
				gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(eventResponses[i].OnFalse));
				GameEvent gameEvent2 = eventResponses[i].gameEvent;
				gameEvent2.OnFalse = (System.Action)Delegate.Remove(gameEvent2.OnFalse, new System.Action(eventResponses[i].OnTrue));
				GameEvent gameEvent3 = eventResponses[i].gameEvent;
				gameEvent3.OnRaise = (Action<bool>)Delegate.Remove(gameEvent3.OnRaise, new Action<bool>(eventResponses[i].OnRaiseInverse));
			}
			else
			{
				GameEvent gameEvent4 = eventResponses[i].gameEvent;
				gameEvent4.OnTrue = (System.Action)Delegate.Remove(gameEvent4.OnTrue, new System.Action(eventResponses[i].OnTrue));
				GameEvent gameEvent5 = eventResponses[i].gameEvent;
				gameEvent5.OnFalse = (System.Action)Delegate.Remove(gameEvent5.OnFalse, new System.Action(eventResponses[i].OnFalse));
				GameEvent gameEvent6 = eventResponses[i].gameEvent;
				gameEvent6.OnRaise = (Action<bool>)Delegate.Remove(gameEvent6.OnRaise, new Action<bool>(eventResponses[i].OnRaise));
			}
		}
		_isRegistered = false;
	}
}
public class GameEventListenerUnityEvent : MonoBehaviour
{
	[Serializable]
	public class EventResponse
	{
		[UnityEngine.Tooltip("GameEvent to respond to.")]
		public GameEvent gameEvent;

		[UnityEngine.Tooltip("Response to invoke when GameEvent is raised.")]
		public UnityEvent response;
	}

	public bool registerOnAwake;

	public bool registerOnEnable;

	public bool unregisterOnDisable;

	public EventResponse[] eventResponses;

	private bool _isRegistered;

	private void Awake()
	{
		if (registerOnAwake)
		{
			Register();
		}
	}

	private void OnEnable()
	{
		if (registerOnEnable)
		{
			Register();
		}
	}

	private void OnDisable()
	{
		if (unregisterOnDisable)
		{
			Unregister();
		}
	}

	private void OnDestroy()
	{
		Unregister();
	}

	public void Register()
	{
		if (!_isRegistered)
		{
			for (int i = 0; i < eventResponses.Length; i++)
			{
				GameEvent gameEvent = eventResponses[i].gameEvent;
				gameEvent.OnTrue = (System.Action)Delegate.Combine(gameEvent.OnTrue, new System.Action(eventResponses[i].response.Invoke));
			}
			_isRegistered = true;
		}
	}

	public void Unregister()
	{
		if (_isRegistered)
		{
			for (int i = 0; i < eventResponses.Length; i++)
			{
				GameEvent gameEvent = eventResponses[i].gameEvent;
				gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(eventResponses[i].response.Invoke));
			}
			_isRegistered = false;
		}
	}
}
public class GameLockListenerBoolUnityEvent : MonoBehaviour
{
	public MultiLock multiLock;

	public bool registerOnAwake;

	public bool registerOnEnable;

	public bool unregisterOnDisable;

	[UnityEngine.Tooltip("If checked, the value sent to the Response function will be the opposite of the value of the lock")]
	public bool invertResponseValue;

	public BoolUnityEvent response;

	public BoolUnityEvent onTrue;

	public BoolUnityEvent onFalse;

	private bool _isRegistered;

	private void Awake()
	{
		if (registerOnAwake)
		{
			Register();
		}
	}

	private void OnEnable()
	{
		if (registerOnEnable)
		{
			Register();
		}
	}

	private void OnDisable()
	{
		if (unregisterOnDisable)
		{
			Unregister();
		}
	}

	public void Register()
	{
		if (!_isRegistered)
		{
			for (int i = 0; i < multiLock.locks.Length; i++)
			{
				multiLock.locks[i].OnChange += OnChange;
			}
			_isRegistered = true;
		}
	}

	public void Unregister()
	{
		for (int i = 0; i < multiLock.locks.Length; i++)
		{
			multiLock.locks[i].OnChange -= OnChange;
		}
		_isRegistered = false;
	}

	private void OnDestroy()
	{
		for (int i = 0; i < multiLock.locks.Length; i++)
		{
			multiLock.locks[i].OnChange -= OnChange;
		}
	}

	public void OnChange(bool val)
	{
		if (multiLock.locks.Length > 1)
		{
			int num = multiLock.NumLocked();
			if ((val && num > 1) || (!val && num > 0))
			{
				return;
			}
		}
		response.Invoke(invertResponseValue ? (!val) : val);
		if (val)
		{
			onTrue.Invoke(arg0: true);
		}
		else
		{
			onFalse.Invoke(arg0: false);
		}
	}
}
public class SendGameEventToPlaymaker : MonoBehaviour
{
	public GameEvent gameEvent;

	public PlayMakerFSM FSM;

	public string onTrue;

	public string onFalse;

	public bool registerOnAwake;

	public bool registerOnEnable;

	public bool unregisterOnDisable;

	private bool _isRegistered;

	private void Awake()
	{
		if (registerOnAwake)
		{
			Register();
		}
	}

	private void OnEnable()
	{
		if (registerOnEnable)
		{
			Register();
		}
	}

	private void OnDisable()
	{
		if (unregisterOnDisable)
		{
			Unregister();
		}
	}

	private void OnDestroy()
	{
		Unregister();
	}

	public void Register()
	{
		if (!_isRegistered && gameEvent != null && FSM != null)
		{
			if (!string.IsNullOrEmpty(onTrue))
			{
				GameEvent obj = gameEvent;
				obj.OnTrue = (System.Action)Delegate.Combine(obj.OnTrue, new System.Action(OnTrue));
			}
			if (!string.IsNullOrEmpty(onFalse))
			{
				GameEvent obj2 = gameEvent;
				obj2.OnFalse = (System.Action)Delegate.Combine(obj2.OnFalse, new System.Action(OnFalse));
			}
			_isRegistered = true;
		}
	}

	public void Unregister()
	{
		if (_isRegistered && gameEvent != null && FSM != null)
		{
			if (!string.IsNullOrEmpty(onTrue))
			{
				GameEvent obj = gameEvent;
				obj.OnTrue = (System.Action)Delegate.Remove(obj.OnTrue, new System.Action(OnTrue));
			}
			if (!string.IsNullOrEmpty(onFalse))
			{
				GameEvent obj2 = gameEvent;
				obj2.OnFalse = (System.Action)Delegate.Remove(obj2.OnFalse, new System.Action(OnFalse));
			}
		}
		_isRegistered = false;
	}

	public void OnTrue()
	{
		FSM.SendEvent(onTrue);
	}

	public void OnFalse()
	{
		FSM.SendEvent(onFalse);
	}
}
public class ForceHandPoint : MonoBehaviour
{
	private static Hand _hand;

	private void OnTriggerEnter(Collider other)
	{
		_hand = other.GetComponentInParent<Hand>();
		if (_hand != null)
		{
			_hand.ForcePointing(this);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		_hand = other.GetComponentInParent<Hand>();
		if (_hand != null)
		{
			_hand.StopForcePointing(this);
		}
	}

	private void OnDisable()
	{
		Player.Instance.leftHand.StopForcePointing(this);
		Player.Instance.rightHand.StopForcePointing(this);
	}

	private void OnDestroy()
	{
		Player.Instance.leftHand.StopForcePointing(this);
		Player.Instance.rightHand.StopForcePointing(this);
	}
}
public class HeadsetDetector : MonoBehaviour
{
	public bool generic;

	public bool quest1;

	public bool quest2;

	private void Start()
	{
		switch (OVRPlugin.GetSystemHeadsetType())
		{
		case OVRPlugin.SystemHeadset.Oculus_Quest_2:
			base.gameObject.SetActive(quest2);
			break;
		case OVRPlugin.SystemHeadset.Oculus_Quest:
			base.gameObject.SetActive(quest1);
			break;
		default:
			base.gameObject.SetActive(generic);
			break;
		}
	}
}
public interface IDamageable
{
	IDamageable GetTarget();

	void ApplyDamage(int amount, string source, DamageType type = DamageType.None);

	bool IsDestroyed();
}
public interface IHealable
{
	void ApplyHealing(int amount);
}
public class BeltItem : CarryableItem
{
	public ItemType itemType;

	protected override void PlayGrabHaptics()
	{
		Haptics.Play(itemType.grabHaptics, _hand);
	}

	public override HandPose GetGripPose()
	{
		return itemType.grabPose;
	}
}
public abstract class CarryableItem : MonoBehaviour, IGrabbableObject, IGrabTrigger
{
	public Transform gripSnapPoint;

	public Transform leftGripSnapPoint;

	protected System.Action onGrab;

	protected Action<Hand, bool> onRelease;

	protected Hand _hand;

	private int _initialLayer;

	public virtual void GrabWith(Hand hand)
	{
		if (_hand != null && _hand != hand)
		{
			_hand.StopGrabbing(this);
		}
		_hand = hand;
		_hand.SetGrabbing(this);
		PositionInHand();
		PlayGrabHaptics();
		onGrab?.Invoke();
	}

	public virtual void Release(Hand hand = null, bool playSound = true)
	{
		hand = _hand;
		_hand = null;
		hand.StopGrabbing(this);
		base.transform.parent = null;
		base.gameObject.layer = _initialLayer;
		onRelease?.Invoke(hand, playSound);
	}

	public Transform GetGripSnapPoint(Hand hand)
	{
		if (leftGripSnapPoint != null && !hand.IsRightHand())
		{
			return leftGripSnapPoint;
		}
		return gripSnapPoint;
	}

	protected void PositionInHand()
	{
		base.transform.localPosition = Vector3.zero;
		Transform transform = GetGripSnapPoint(_hand);
		Transform parent = transform.parent;
		transform.parent = _hand.gripPoint;
		base.transform.parent = transform;
		transform.SetPositionAndRotation(_hand.gripPoint.position, Quaternion.LookRotation(_hand.gripPoint.forward, _hand.gripPoint.up));
		base.transform.parent = _hand.gripPoint;
		transform.parent = parent;
		_initialLayer = base.gameObject.layer;
		base.gameObject.layer = 15;
	}

	protected abstract void PlayGrabHaptics();

	public abstract HandPose GetGripPose();

	public bool HandClingsToTarget()
	{
		return false;
	}

	public virtual bool ReleaseOnGrip()
	{
		return false;
	}

	public bool ClimbOnTarget()
	{
		return false;
	}

	public virtual bool CanGrab()
	{
		return true;
	}
}
public class Inventory : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	public class Data : ISaveData
	{
		[SerializeField]
		private List<InventorySlotItem.Data> _items = new List<InventorySlotItem.Data>();

		public void Serialize(ISaveSerializable target)
		{
			foreach (InventorySlotItem inventorySlotItem in ((Inventory)target)._inventorySlotItems)
			{
				_items.Add(new InventorySlotItem.Data
				{
					itemType = inventorySlotItem.itemType.name,
					totalCount = inventorySlotItem.totalCount
				});
			}
		}

		public void Deserialize(ISaveSerializable target)
		{
			((Inventory)target).ResetObject();
			foreach (InventorySlotItem.Data item in _items)
			{
				((Inventory)target).AddToInventory(References.InventoryManager.GetItem(item.itemType), item.totalCount);
			}
		}
	}

	public InventorySlotBag[] bagSlots;

	public InventorySlotBelt wandSlot;

	public InventorySlotBelt shieldSlot;

	public Transform rightPointer;

	public Transform leftPointer;

	public AudioClip addObjectToInventory;

	public AudioClip removeObjectFromInventory;

	public AudioClip openInventory;

	public AudioClip closeInventory;

	public GameEvent rightGripEvent;

	public GameEvent leftGripEvent;

	public AudioSource audioSource;

	public AudioSource grabAudioSource;

	public Material slotIconDefault;

	public Material slotIconSelected;

	private static InventorySlotBag _returnSlot;

	private static InventorySlotBag _currentSlot;

	private static Vector3 _rightSlotPosition;

	private static Vector3 _halfExtents = new Vector3(0.32f, 0.01f, 0.22f);

	protected readonly List<InventorySlotItem> _inventorySlotItems = new List<InventorySlotItem>();

	private readonly Dictionary<ItemType, InventorySlotItem> _items = new Dictionary<ItemType, InventorySlotItem>();

	public static bool IsOpen { get; private set; }

	public static InventorySlotBag LeftSlot { get; private set; }

	public static InventorySlotBag RightSlot { get; private set; }

	protected void Awake()
	{
		_rightSlotPosition = wandSlot.transform.localPosition;
	}

	private void Start()
	{
		base.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		if (IsOpen && (References.Headset.position - base.transform.position).sqrMagnitude > 3f)
		{
			CloseInventory();
		}
	}

	private void LateUpdate()
	{
		if (IsOpen)
		{
			base.transform.position += References.TrackingSpace.GetSurfaceVelocity() * Time.deltaTime;
		}
	}

	public void ToggleInventory()
	{
		if (References.PlayerInterfaceLock.IsLocked() || MenuManager.IsInMenu)
		{
			return;
		}
		IsOpen = !IsOpen;
		base.gameObject.SetActive(IsOpen);
		if (IsOpen)
		{
			Vector3 vector = References.Headset.position + References.Headset.forward / 2f;
			Vector3 vector2 = vector + References.Headset.up * 0.05f;
			Quaternion quaternion = Quaternion.Euler(-90f, 0f, References.Headset.eulerAngles.y);
			Vector3 normalized = (vector2 - References.Headset.position).normalized;
			int num = Physics.BoxCastNonAlloc(References.Headset.position, _halfExtents, normalized, Utilities.raycastHitPool, quaternion, 0.5f, References.SolidLayers);
			if (num == 0)
			{
				base.transform.position = vector;
			}
			else
			{
				Array.Sort(Utilities.raycastHitPool, 0, num, Utilities.RaycastHitDistanceComparer.Comparer);
				bool flag = false;
				for (int i = 0; i < num; i++)
				{
					Transform transform = Utilities.raycastHitPool[i].transform;
					if (!transform.IsChildOf(Singleton<VRSystem>.Instance.transform) && !Singleton<VRSystem>.Instance.transform.IsChildOf(transform))
					{
						base.transform.position = References.Headset.position + References.Headset.forward * Mathf.Max(0f, Utilities.raycastHitPool[i].distance - 0.01f);
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					base.transform.position = vector;
				}
			}
			base.transform.localRotation = quaternion;
			Timing.RunCoroutine(HighlightTargetSlot(), Segment.LateUpdate);
			for (int num2 = 9; num2 > 0; num2 -= 3)
			{
				if (_inventorySlotItems.Count < num2)
				{
					bagSlots[num2].gameObject.SetActive(value: false);
					bagSlots[num2 + 1].gameObject.SetActive(value: false);
					bagSlots[num2 + 2].gameObject.SetActive(value: false);
				}
				else
				{
					bagSlots[num2].gameObject.SetActive(value: true);
					bagSlots[num2 + 1].gameObject.SetActive(value: true);
					bagSlots[num2 + 2].gameObject.SetActive(value: true);
				}
			}
			RefreshIcons();
			GameEvent gameEvent = rightGripEvent;
			gameEvent.OnTrue = (System.Action)Delegate.Combine(gameEvent.OnTrue, new System.Action(TakeItemRight));
			GameEvent gameEvent2 = leftGripEvent;
			gameEvent2.OnTrue = (System.Action)Delegate.Combine(gameEvent2.OnTrue, new System.Action(TakeItemLeft));
			audioSource.PlayOneShot(openInventory);
		}
		else
		{
			InventorySlotBag.ResetTouch();
			audioSource.PlayOneShot(closeInventory);
		}
	}

	private void RefreshIcons()
	{
		for (int i = 0; i < bagSlots.Length; i++)
		{
			if (_inventorySlotItems.Count > i && _inventorySlotItems[i].currentCount > 0)
			{
				bagSlots[i].SetItem(_inventorySlotItems[i], _inventorySlotItems[i].currentCount);
			}
			else
			{
				bagSlots[i].UnsetItem();
			}
		}
	}

	public void AddToInventory(ItemType itemType, int count = 1)
	{
		if (_items.TryGetValue(itemType, out var value))
		{
			value.totalCount += count;
			value.currentCount += count;
			return;
		}
		InventorySlotItem inventorySlotItem = new InventorySlotItem
		{
			itemType = itemType,
			pool = new GameObjectRuntimePool(itemType.prefab),
			currentCount = count,
			totalCount = count
		};
		_inventorySlotItems.Add(inventorySlotItem);
		_items.Add(itemType, inventorySlotItem);
	}

	public CarryableItem GetItem(ItemType itemType)
	{
		string text = itemType.name;
		if (!(text == "Shield"))
		{
			if (text == "Wand")
			{
				if (References.Wand == null)
				{
					UnityEngine.Object.Instantiate(itemType.prefab);
				}
				return References.Wand;
			}
			_items[itemType].currentCount--;
			InventoryItem component = _items[itemType].pool.Get().GetComponent<InventoryItem>();
			component.gameObject.SetActive(value: true);
			return component;
		}
		if (References.Shield == null)
		{
			UnityEngine.Object.Instantiate(itemType.prefab);
		}
		return References.Shield;
	}

	public void ReturnItem(InventoryItem item, bool playSound = true)
	{
		InventorySlotItem inventorySlotItem = _items[item.itemType];
		inventorySlotItem.currentCount++;
		inventorySlotItem.pool.ReturnToPool(item.gameObject);
		item.gameObject.SetActive(value: false);
		if (playSound)
		{
			grabAudioSource.PlayOneShot((item.itemType.addToInventorySound != null) ? item.itemType.addToInventorySound : addObjectToInventory);
		}
		if (IsOpen)
		{
			RefreshIcons();
		}
	}

	public void RemoveItem(InventoryItem item)
	{
		InventorySlotItem inventorySlotItem = _items[item.itemType];
		inventorySlotItem.totalCount--;
		if (inventorySlotItem.totalCount == 0)
		{
			_items.Remove(item.itemType);
			_inventorySlotItems.Remove(inventorySlotItem);
			UnityEngine.Object.Destroy(item.gameObject);
			inventorySlotItem.pool.Destroy();
		}
		else
		{
			inventorySlotItem.pool.ReturnToPool(item.gameObject);
		}
	}

	private void TakeItemRight()
	{
		if (IsOpen)
		{
			TakeItem(RightSlot, Player.Instance.rightHand);
			return;
		}
		GameEvent gameEvent = rightGripEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(TakeItemRight));
		GameEvent gameEvent2 = leftGripEvent;
		gameEvent2.OnTrue = (System.Action)Delegate.Remove(gameEvent2.OnTrue, new System.Action(TakeItemLeft));
	}

	private void TakeItemLeft()
	{
		if (IsOpen)
		{
			TakeItem(LeftSlot, Player.Instance.leftHand);
			return;
		}
		GameEvent gameEvent = rightGripEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(TakeItemRight));
		GameEvent gameEvent2 = leftGripEvent;
		gameEvent2.OnTrue = (System.Action)Delegate.Remove(gameEvent2.OnTrue, new System.Action(TakeItemLeft));
	}

	private void TakeItem(InventorySlotBag slot, Hand hand)
	{
		if (slot != null && _inventorySlotItems.Count > slot.slotID && _inventorySlotItems[slot.slotID] != null && hand.GetGrabbedObject() == null)
		{
			InventorySlotItem inventorySlotItem = _inventorySlotItems[slot.slotID];
			if (inventorySlotItem.currentCount != 0)
			{
				grabAudioSource.PlayOneShot((inventorySlotItem.itemType.removeFromInventorySound != null) ? inventorySlotItem.itemType.removeFromInventorySound : removeObjectFromInventory);
				GetItem(inventorySlotItem.itemType).GrabWith(hand);
				CloseInventory();
			}
		}
	}

	public void CloseInventory()
	{
		if (IsOpen)
		{
			IsOpen = false;
			base.gameObject.SetActive(value: false);
			InventorySlotBag.ResetTouch();
			audioSource.PlayOneShot(closeInventory);
			GameEvent gameEvent = rightGripEvent;
			gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(TakeItemRight));
			GameEvent gameEvent2 = leftGripEvent;
			gameEvent2.OnTrue = (System.Action)Delegate.Remove(gameEvent2.OnTrue, new System.Action(TakeItemLeft));
		}
	}

	public void SetDominantHand(HandMode hand)
	{
		if (hand == HandMode.Right)
		{
			wandSlot.transform.localPosition = _rightSlotPosition;
			wandSlot.transform.localRotation = Quaternion.identity;
			shieldSlot.transform.localPosition = new Vector3(0f - _rightSlotPosition.x, _rightSlotPosition.y, _rightSlotPosition.z);
			shieldSlot.transform.rotation = Quaternion.Euler(0f, 180f, 0f);
		}
		else
		{
			wandSlot.transform.localPosition = new Vector3(0f - _rightSlotPosition.x, _rightSlotPosition.y, _rightSlotPosition.z);
			wandSlot.transform.localRotation = Quaternion.Euler(0f, 180f, 0f);
			shieldSlot.transform.localPosition = _rightSlotPosition;
			shieldSlot.transform.localRotation = Quaternion.identity;
		}
	}

	private IEnumerator<float> HighlightTargetSlot()
	{
		while (IsOpen)
		{
			float num = 1f;
			_currentSlot = (_returnSlot = null);
			for (int i = 0; i < InventorySlotBag.TouchingLeft.Count; i++)
			{
				_currentSlot = InventorySlotBag.TouchingLeft[i];
				float sqrMagnitude = (leftPointer.position - InventorySlotBag.TouchingLeft[i].transform.position).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					num = sqrMagnitude;
					_returnSlot = _currentSlot;
				}
			}
			if (_returnSlot != LeftSlot)
			{
				if (LeftSlot != null && RightSlot != LeftSlot)
				{
					LeftSlot.Unhighlight();
				}
				LeftSlot = _returnSlot;
				if (LeftSlot != null)
				{
					LeftSlot.Highlight();
					Haptics.Play(0.5f, 0.1f, 0.1f, rightHand: false);
				}
			}
			_currentSlot = (_returnSlot = null);
			for (int j = 0; j < InventorySlotBag.TouchingRight.Count; j++)
			{
				_currentSlot = InventorySlotBag.TouchingRight[j];
				float sqrMagnitude2 = (rightPointer.position - InventorySlotBag.TouchingRight[j].transform.position).sqrMagnitude;
				if (sqrMagnitude2 < num)
				{
					num = sqrMagnitude2;
					_returnSlot = _currentSlot;
				}
			}
			if (_returnSlot != RightSlot)
			{
				if (RightSlot != null && LeftSlot != RightSlot)
				{
					RightSlot.Unhighlight();
				}
				RightSlot = _returnSlot;
				if (RightSlot != null)
				{
					RightSlot.Highlight();
					Haptics.Play(0.5f, 0.1f, 0.1f, rightHand: true);
				}
			}
			yield return 0f;
		}
	}

	public ISaveData Serialize()
	{
		Data data = new Data();
		data.Serialize(this);
		return data;
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((Data)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<Data>(saveData).Deserialize(this);
	}

	public void ResetObject()
	{
		for (int num = _inventorySlotItems.Count - 1; num >= 0; num--)
		{
			InventorySlotItem inventorySlotItem = _inventorySlotItems[num];
			_items.Remove(inventorySlotItem.itemType);
			_inventorySlotItems.RemoveAt(num);
			inventorySlotItem.pool.Destroy();
		}
	}
}
public class InventorySlotItem
{
	[Serializable]
	public class Data
	{
		public string itemType;

		public int totalCount;
	}

	public ItemType itemType;

	public int currentCount;

	public int totalCount;

	public GameObjectRuntimePool pool;
}
public class InventoryBelt : MonoBehaviour
{
	[SerializeField]
	private float _lockAngle = 30f;

	private bool _isLocked;

	private Vector3 _sittingOffset;

	private const float TRACKING_DIST = 40f;

	private void Start()
	{
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnRaise = (Action<bool>)Delegate.Combine(comfortModeChanged.OnRaise, new Action<bool>(UpdateHeight));
		UpdateHeight(Settings.Current.comfortMode == ComfortMode.Sit);
		GameEvent onMenuOpened = References.OnMenuOpened;
		onMenuOpened.OnRaise = (Action<bool>)Delegate.Combine(onMenuOpened.OnRaise, new Action<bool>(OnMenu));
		base.gameObject.SetActive(value: false);
	}

	private void OnDestroy()
	{
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnRaise = (Action<bool>)Delegate.Remove(comfortModeChanged.OnRaise, new Action<bool>(UpdateHeight));
		GameEvent onMenuOpened = References.OnMenuOpened;
		onMenuOpened.OnRaise = (Action<bool>)Delegate.Remove(onMenuOpened.OnRaise, new Action<bool>(OnMenu));
	}

	private void UpdateHeight(bool sit)
	{
		_sittingOffset = (sit ? new Vector3(0f, 0.1f, 0.05f) : Vector3.zero);
	}

	private void OnMenu(bool paused)
	{
		base.gameObject.SetActive(!paused);
	}

	private void LateUpdate()
	{
		base.transform.localPosition = Player.Instance.headsetOffset + _sittingOffset;
		_isLocked = Vector3.SignedAngle(References.Headset.up, Vector3.up, base.transform.right) <= 0f - _lockAngle;
		if (!_isLocked)
		{
			base.transform.rotation = Quaternion.LookRotation(Vector3.ProjectOnPlane(References.Headset.forward, Vector3.up), Vector3.up);
			return;
		}
		Vector3 vector = Vector3.ProjectOnPlane(References.Headset.up, Vector3.up);
		float num = Vector3.Angle(vector, base.transform.forward);
		if (num > 40f)
		{
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(vector, Vector3.up), num - 40f);
		}
	}
}
public class InventoryItem : CarryableItem, IGameObjectPoolable
{
	public ItemType itemType;

	public PlayMakerFSMReference FSM;

	[UnityEngine.Tooltip("Playmaker event to trigger every time the item is grabbed")]
	public string grabPlaymakerEvent = "";

	public GameObject sittingCollider;

	public Action<InventoryItem> onUngrab;

	public GameObjectRuntimePool Pool { get; set; }

	private void Awake()
	{
		if (FSM.Value != null && !string.IsNullOrEmpty(grabPlaymakerEvent))
		{
			onGrab = (System.Action)Delegate.Combine(onGrab, (System.Action)delegate
			{
				FSM.Value.SendEvent(grabPlaymakerEvent);
			});
		}
		onRelease = (Action<Hand, bool>)Delegate.Combine(onRelease, new Action<Hand, bool>(OnRelease));
		if (sittingCollider != null)
		{
			onGrab = (System.Action)Delegate.Combine(onGrab, new System.Action(OnGrab));
		}
	}

	private void OnDestroy()
	{
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnRaise = (Action<bool>)Delegate.Remove(comfortModeChanged.OnRaise, new Action<bool>(UpdateSittingMode));
	}

	private void OnGrab()
	{
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnRaise = (Action<bool>)Delegate.Combine(comfortModeChanged.OnRaise, new Action<bool>(UpdateSittingMode));
		UpdateSittingMode(Settings.Current.comfortMode == ComfortMode.Sit);
	}

	private void OnRelease(Hand hand, bool playSound = true)
	{
		onUngrab?.Invoke(this);
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnRaise = (Action<bool>)Delegate.Remove(comfortModeChanged.OnRaise, new Action<bool>(UpdateSittingMode));
		if (base.gameObject.activeInHierarchy)
		{
			References.Inventory.ReturnItem(this, playSound);
		}
		else
		{
			References.Inventory.RemoveItem(this);
		}
	}

	private void UpdateSittingMode(bool sit)
	{
		if (sittingCollider != null)
		{
			sittingCollider.SetActive(sit);
		}
	}

	protected override void PlayGrabHaptics()
	{
		Haptics.Play(itemType.grabHaptics, _hand);
	}

	public override HandPose GetGripPose()
	{
		return itemType.grabPose;
	}
}
[CreateAssetMenu(menuName = "Custom/Inventory Manager")]
public class InventoryManager : ScriptableObject
{
	public List<ItemType> inventoryItems = new List<ItemType>();

	public ItemType GetItem(string name)
	{
		for (int i = 0; i < inventoryItems.Count; i++)
		{
			if (inventoryItems[i].name == name)
			{
				return inventoryItems[i];
			}
		}
		return null;
	}
}
public class InventorySlotBag : MonoBehaviour
{
	public int slotID;

	public MeshRenderer icon;

	public GameObject iconCanvas;

	public Image iconImage;

	public TextMeshProUGUI counter;

	protected ItemType _itemType;

	public static readonly List<InventorySlotBag> TouchingRight = new List<InventorySlotBag>();

	public static readonly List<InventorySlotBag> TouchingLeft = new List<InventorySlotBag>();

	public static void ResetTouch()
	{
		TouchingRight.Clear();
		TouchingLeft.Clear();
	}

	private void OnTriggerEnter(Collider other)
	{
		HandPoke componentInParent = other.GetComponentInParent<HandPoke>();
		if (!(componentInParent != null))
		{
			return;
		}
		if (componentInParent.hand.IsRightHand())
		{
			if (!TouchingRight.Contains(this))
			{
				TouchingRight.Add(this);
			}
		}
		else if (!TouchingLeft.Contains(this))
		{
			TouchingLeft.Add(this);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		Hand componentInParent = other.GetComponentInParent<Hand>();
		if (!(componentInParent != null) || !other.name.StartsWith("Poke"))
		{
			return;
		}
		if (componentInParent.IsRightHand())
		{
			if (TouchingRight.Contains(this))
			{
				TouchingRight.Remove(this);
			}
		}
		else if (TouchingLeft.Contains(this))
		{
			TouchingLeft.Remove(this);
		}
	}

	public void SetItem(InventorySlotItem item, int count)
	{
		if (item.itemType != null)
		{
			iconImage.sprite = item.itemType.sprite;
			if (count > 1)
			{
				counter.gameObject.SetActive(value: true);
				counter.text = count.ToString();
			}
			else
			{
				counter.gameObject.SetActive(value: false);
			}
		}
		iconCanvas.SetActive(value: true);
	}

	public void UnsetItem()
	{
		iconImage.sprite = null;
		iconCanvas.SetActive(value: false);
	}

	public void Highlight()
	{
		icon.material = References.Inventory.slotIconSelected;
	}

	public void Unhighlight()
	{
		icon.material = References.Inventory.slotIconDefault;
	}
}
public class InventorySlotBelt : MonoBehaviour, IGrabTrigger
{
	public Transform snapPosition;

	public Collider slotCollider;

	private Rigidbody _rigidbody;

	private BeltItem _itemInSlot;

	public void PlaceItem(BeltItem item, bool playSound = true)
	{
		_itemInSlot = item;
		item.transform.parent = snapPosition;
		item.transform.localPosition = Vector3.zero;
		item.transform.localRotation = Quaternion.identity;
		_rigidbody = item.GetComponent<Rigidbody>();
		if (_rigidbody != null)
		{
			_rigidbody.isKinematic = true;
		}
		if (playSound)
		{
			References.Inventory.grabAudioSource.PlayOneShot((item.itemType.addToInventorySound != null) ? item.itemType.addToInventorySound : References.Inventory.addObjectToInventory);
		}
	}

	public BeltItem RemoveItem(bool playSound = true)
	{
		_itemInSlot.transform.parent = null;
		BeltItem itemInSlot = _itemInSlot;
		_itemInSlot = null;
		References.Inventory.CloseInventory();
		if (playSound && itemInSlot.itemType.removeFromInventorySound != null)
		{
			References.Inventory.grabAudioSource.PlayOneShot((itemInSlot.itemType.removeFromInventorySound != null) ? itemInSlot.itemType.removeFromInventorySound : References.Inventory.removeObjectFromInventory);
		}
		return itemInSlot;
	}

	public void GrabWith(Hand hand)
	{
		if (_itemInSlot != null)
		{
			RemoveItem().GrabWith(hand);
		}
	}

	public Transform GetGripSnapPoint(Hand hand)
	{
		return base.transform;
	}

	public BeltItem ItemInSlot()
	{
		return _itemInSlot;
	}

	public bool CanGrab()
	{
		return true;
	}
}
public class ItemPickup : AchievementSetter, IGrabTrigger, ISaveSerializable
{
	[Serializable]
	public class Data : ISaveData
	{
		[SerializeField]
		private bool _isActive;

		[SerializeField]
		private TransformSaveData _transformData;

		[SerializeField]
		private FSMData _fsmData;

		public void Serialize(ISaveSerializable target)
		{
			ItemPickup itemPickup = (ItemPickup)target;
			_isActive = itemPickup.gameObject.activeSelf;
			_transformData = new TransformSaveData(itemPickup.transform);
			if (itemPickup.FSM.Value != null)
			{
				_fsmData = new FSMData(itemPickup.FSM.Value);
			}
		}

		public void Deserialize(ISaveSerializable target)
		{
			ItemPickup itemPickup = (ItemPickup)target;
			itemPickup.gameObject.SetActive(_isActive);
			_transformData.Deserialize(itemPickup.transform);
			if (itemPickup.FSM.Value != null)
			{
				_fsmData.Deserialize(itemPickup.FSM.Value);
			}
		}
	}

	public ItemType itemType;

	public PlayMakerFSMReference FSM;

	[UnityEngine.Tooltip("Playmaker event to trigger the first time this item is grabbed")]
	public string initialGrabPlaymakerEvent = "Trigger";

	[UnityEngine.Tooltip("Sound to play the first time the item is picked up")]
	public AudioSource initialGrabSound;

	public void GrabWith(Hand hand)
	{
		if (itemType.name != "Shield")
		{
			References.Inventory.AddToInventory(itemType);
		}
		CarryableItem item = References.Inventory.GetItem(itemType);
		if (FSM.Value != null && !string.IsNullOrEmpty(initialGrabPlaymakerEvent))
		{
			FSM.Value.SendEvent(initialGrabPlaymakerEvent);
		}
		if (initialGrabSound != null)
		{
			initialGrabSound.Play();
		}
		item.GrabWith(hand);
		Collect();
		base.gameObject.SetActive(value: false);
	}

	public Transform GetGripSnapPoint(Hand hand)
	{
		return base.transform;
	}

	public bool CanGrab()
	{
		return true;
	}

	public ISaveData Serialize()
	{
		Data data = new Data();
		data.Serialize(this);
		return data;
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((Data)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<Data>(saveData).Deserialize(this);
	}
}
public class ItemSnapPoint : MonoBehaviour, ISaveSerializable
{
	[UnityEngine.Tooltip("What item can be snapped to this point")]
	public List<InventoryItemReference> usableItems = new List<InventoryItemReference>(1);

	public List<ItemType> usableItemTypes = new List<ItemType>(1);

	[UnityEngine.Tooltip("GameObject to show as a placement hint when the correct item is hovering over the target")]
	public GameObject showOnHover;

	[UnityEngine.Tooltip("GameObjects to activate when the correct item is placed here")]
	public GameObject[] activateOnPlace;

	[UnityEngine.Tooltip("Deactivate the GameObject in the player's hand when it is placed here?")]
	public bool deactivateItemOnPlace = true;

	public PlayMakerFSM FSM;

	public string FSMEventOnPlace;

	private void OnTriggerEnter(Collider other)
	{
		InventoryItem correctItem = GetCorrectItem(other);
		if (correctItem != null)
		{
			showOnHover.SetActive(value: true);
			correctItem.onUngrab = (Action<InventoryItem>)Delegate.Combine(correctItem.onUngrab, new Action<InventoryItem>(PlaceItem));
		}
	}

	private void OnTriggerExit(Collider other)
	{
		InventoryItem correctItem = GetCorrectItem(other);
		if (correctItem != null)
		{
			showOnHover.SetActive(value: false);
			correctItem.onUngrab = (Action<InventoryItem>)Delegate.Remove(correctItem.onUngrab, new Action<InventoryItem>(PlaceItem));
		}
	}

	public void PlaceItem(InventoryItem item)
	{
		item.onUngrab = (Action<InventoryItem>)Delegate.Remove(item.onUngrab, new Action<InventoryItem>(PlaceItem));
		showOnHover.SetActive(value: false);
		if (deactivateItemOnPlace)
		{
			item.gameObject.SetActive(value: false);
			UnityEngine.Object.Destroy(item.gameObject);
		}
		else
		{
			item.transform.position = showOnHover.transform.position;
			item.transform.rotation = showOnHover.transform.rotation;
		}
		for (int i = 0; i < activateOnPlace.Length; i++)
		{
			activateOnPlace[i].SetActive(value: true);
		}
		if (FSM != null)
		{
			FSM.SendEvent(FSMEventOnPlace);
		}
	}

	private InventoryItem GetCorrectItem(Collider other)
	{
		InventoryItem componentInParent = other.GetComponentInParent<InventoryItem>();
		if (componentInParent != null)
		{
			for (int i = 0; i < usableItems.Count; i++)
			{
				if (componentInParent == (InventoryItem)usableItems[i])
				{
					return componentInParent;
				}
			}
			for (int j = 0; j < usableItemTypes.Count; j++)
			{
				if (componentInParent.itemType == usableItemTypes[j])
				{
					return componentInParent;
				}
			}
		}
		return null;
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		ActiveData activeData = new ActiveData();
		activeData.Serialize(this);
		return activeData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((ActiveData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<ActiveData>(saveData).Deserialize(this);
	}
}
[Serializable]
public class ItemType : ScriptableObject
{
	public Sprite sprite;

	public bool stackable;

	public HandPose grabPose = HandPose.Fist;

	[UnityEngine.Tooltip("Sound to play when the item is moved from your hand to your inventory")]
	public AudioClip addToInventorySound;

	[UnityEngine.Tooltip("Sound to play when the item is moved from your inventory to your hand")]
	public AudioClip removeFromInventorySound;

	public VibrationProperties grabHaptics = new VibrationProperties(0.4f, 0.2f, 0.1f);

	public GameObject prefab;
}
public class AimAssist : MonoBehaviour
{
	public LayerMask aimTargetLayers;

	public Vector3 easyScale;

	public Vector3 normalScale;

	public Vector3 hardScale;

	[SerializeField]
	private Transform _referenceTransform;

	private Collider _target;

	private Transform _targetTransform;

	private Vector3 _halfExtents;

	private MeshCollider _collider;

	private void Awake()
	{
		if (_collider == null)
		{
			_collider = GetComponent<MeshCollider>();
		}
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Combine(difficultyChanged.OnTrue, new System.Action(SetDifficulty));
		_halfExtents = base.transform.localScale / 2f;
	}

	private void OnDestroy()
	{
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Remove(difficultyChanged.OnTrue, new System.Action(SetDifficulty));
	}

	private void SetDifficulty()
	{
		switch (Settings.Current.difficulty)
		{
		case Difficulty.Easy:
			base.transform.localScale = easyScale;
			break;
		case Difficulty.Normal:
			base.transform.localScale = normalScale;
			break;
		case Difficulty.Hard:
			base.transform.localScale = hardScale;
			break;
		}
		_halfExtents = base.transform.localScale / 2f;
	}

	public Collider GetTarget()
	{
		int num = Physics.OverlapBoxNonAlloc(_referenceTransform.position + _referenceTransform.forward * _halfExtents.y, _halfExtents, Utilities.colliderPool, base.transform.rotation, aimTargetLayers, QueryTriggerInteraction.Collide);
		if (num == 0)
		{
			return null;
		}
		Vector3 forward = _referenceTransform.forward;
		Vector3 position = _referenceTransform.position;
		Vector3 position2 = base.transform.position;
		Quaternion rotation = base.transform.rotation;
		Utilities.colliderPool.SortByAngle(num, position, forward);
		for (int i = 0; i < num; i++)
		{
			_target = Utilities.colliderPool[i];
			_targetTransform = _target.transform;
			ITargetable componentInParent = _target.GetComponentInParent<ITargetable>();
			if (componentInParent == null || !componentInParent.IsTargetable() || !Physics.ComputePenetration(_target, _targetTransform.position, _targetTransform.rotation, _collider, position2, rotation, out var _, out var _))
			{
				continue;
			}
			Vector3 direction2 = _target.bounds.center - position;
			int num2 = Physics.RaycastNonAlloc(position, direction2, Utilities.raycastHitPool, direction2.magnitude, References.HardSolidLayers, QueryTriggerInteraction.Ignore);
			if (num2 > 0)
			{
				Utilities.raycastHitPool.SortByDist(num2);
				if (!Utilities.raycastHitPool[0].transform.IsChildOf(_targetTransform) && !_targetTransform.IsChildOf(Utilities.raycastHitPool[0].transform))
				{
					continue;
				}
			}
			return _target;
		}
		return null;
	}
}
public interface ITargetable
{
	bool IsTargetable();
}
public interface IWandTouchReceiver
{
	void OnTouch(Element element);
}
public class Potion : MonoBehaviour
{
	public float drinkingTime;

	public AudioSource drinkingSound;

	public AudioClip[] drinkingClips;

	[UnityEngine.Tooltip("The minimum angle offset from vertical required to count as drinking.")]
	public float drinkingMinAngle;

	public int healEasy;

	public int healNormal;

	public int healHard;

	private float _drinkStartTime;

	private bool _isDrinking;

	private void Update()
	{
		if (Vector3.SignedAngle(Vector3.ProjectOnPlane(base.transform.up, References.Mouth.right), Vector3.up, References.Mouth.right) >= drinkingMinAngle)
		{
			bool flag = false;
			int num = Physics.OverlapSphereNonAlloc(base.transform.position, 0.2f, Utilities.colliderPool, 4, QueryTriggerInteraction.Collide);
			for (int i = 0; i < num; i++)
			{
				if (!(Utilities.colliderPool[i].transform == References.Mouth))
				{
					continue;
				}
				flag = true;
				if (!_isDrinking)
				{
					_isDrinking = true;
					_drinkStartTime = Time.time;
					continue;
				}
				if (!drinkingSound.isPlaying)
				{
					drinkingSound.clip = drinkingClips[UnityEngine.Random.Range(0, drinkingClips.Length)];
					drinkingSound.Play();
				}
				if (Time.time > _drinkStartTime + drinkingTime)
				{
					Drink();
				}
			}
			if (!flag)
			{
				_isDrinking = false;
			}
		}
		else
		{
			_isDrinking = false;
		}
		if (!_isDrinking && drinkingSound.isPlaying)
		{
			drinkingSound.Stop();
		}
	}

	public void Drink()
	{
		switch (Settings.Current.difficulty)
		{
		case Difficulty.Easy:
			Player.Instance.ApplyHealing(healEasy);
			break;
		case Difficulty.Normal:
			Player.Instance.ApplyHealing(healNormal);
			break;
		case Difficulty.Hard:
			Player.Instance.ApplyHealing(healHard);
			break;
		}
		base.gameObject.SetActive(value: false);
		GetComponent<InventoryItem>().Release(null, playSound: false);
	}
}
public class Shield : BeltItem, IDamageable
{
	public Rigidbody shieldRigidbody;

	public PlayMakerFSMReference FSM;

	[UnityEngine.Tooltip("Playmaker event to trigger every time the item is grabbed")]
	public string grabPlaymakerEvent = "";

	[UnityEngine.Tooltip("Amount of time between pressing the trigger and the shield turning on")]
	public FloatReference activationTime;

	[UnityEngine.Tooltip("Rate of consumption of duration while active")]
	public FloatReference difficultyModifier;

	[UnityEngine.Tooltip("The total amount of time the shield can be active at once")]
	public float initialDuration = 20f;

	[UnityEngine.Tooltip("How much each gem adds to the shield's duration")]
	public float extraDurationMultiplier = 1f;

	[UnityEngine.Tooltip("Amount of shield charge time regained every second the shield is inactive")]
	public float rechargeSpeed = 1f;

	[UnityEngine.Tooltip("The minimum amount of time that must be available in order for the shield to activate")]
	public float minimumChargeToActivate = 5f;

	[UnityEngine.Tooltip("Vibration played while the shield is being charged before turning on")]
	public VibrationProperties chargingHaptics;

	[UnityEngine.Tooltip("Vibration played while the shield is on")]
	public VibrationProperties activeHaptics;

	[UnityEngine.Tooltip("Vibration played when the shield is deactivated")]
	public VibrationProperties deactivateHaptics;

	[UnityEngine.Tooltip("Vibration played when the shield takes a hit (amplitude will be multiplied by damage dealt)")]
	public VibrationProperties damagedHaptics;

	[UnityEngine.Tooltip("Vibration played when the shield recharges enough to be available for use")]
	public VibrationProperties rechargeHaptics;

	public Renderer q1Renderer;

	public Renderer q2Renderer;

	public AnimationCurve lowChargeAlpha;

	public Color enabledColor;

	public Color disabledColor;

	public GameObject[] durationObj;

	private Renderer _renderer;

	private float _remainingDuration = 10f;

	private float _difficultyModifier = 1f;

	private Haptics.Vibration _chargingVibration;

	private CoroutineHandle _activeRoutine;

	private bool _isCharged = true;

	private static int COLORID;

	public float MaxDuration => initialDuration + extraDurationMultiplier * (float)Player.Instance.shieldGems;

	private void OnValidate()
	{
		FSM.Value.FsmVariables.FindFsmFloat("ChargeTime").Value = activationTime;
	}

	private void Awake()
	{
		onRelease = (Action<Hand, bool>)Delegate.Combine(onRelease, new Action<Hand, bool>(OnRelease));
		References.Shield = this;
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Combine(difficultyChanged.OnTrue, new System.Action(SetDifficulty));
		_remainingDuration = MaxDuration;
		_renderer = GetComponent<Renderer>();
		COLORID = Shader.PropertyToID("_TintColor");
	}

	private void OnDestroy()
	{
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Remove(difficultyChanged.OnTrue, new System.Action(SetDifficulty));
		if (References.Shield == this)
		{
			References.Shield = null;
		}
	}

	private void SetDifficulty()
	{
		_difficultyModifier = difficultyModifier;
		FSM.Value.FsmVariables.FindFsmFloat("ChargeTime").Value = activationTime;
	}

	public override void GrabWith(Hand hand)
	{
		if (_hand != null)
		{
			GameEvent triggerPressEvent = _hand.triggerPressEvent;
			triggerPressEvent.OnRaise = (Action<bool>)Delegate.Remove(triggerPressEvent.OnRaise, new Action<bool>(TriggerPress));
		}
		base.GrabWith(hand);
		Timing.RunCoroutine(AfterGrab());
		GameEvent triggerPressEvent2 = hand.triggerPressEvent;
		triggerPressEvent2.OnRaise = (Action<bool>)Delegate.Combine(triggerPressEvent2.OnRaise, new Action<bool>(TriggerPress));
	}

	public void OnRelease(Hand hand, bool playSound = true)
	{
		Deactivate();
		References.Inventory.shieldSlot.PlaceItem(this, playSound);
		GameEvent triggerPressEvent = hand.triggerPressEvent;
		triggerPressEvent.OnRaise = (Action<bool>)Delegate.Remove(triggerPressEvent.OnRaise, new Action<bool>(TriggerPress));
	}

	public override bool ReleaseOnGrip()
	{
		return true;
	}

	private IEnumerator<float> AfterGrab()
	{
		yield return 0f;
		Deactivate();
	}

	public void TriggerPress(bool pressed)
	{
		if (pressed)
		{
			if (_isCharged)
			{
				_activeRoutine = Timing.RunCoroutine(Activate());
			}
		}
		else
		{
			Deactivate();
		}
	}

	private void UpdateDurationObjects()
	{
		float num = _remainingDuration / MaxDuration;
		Vector3 vector = new Vector3(12f, -30f, -50f) * Time.deltaTime;
		for (int i = 0; i < durationObj.Length; i++)
		{
			durationObj[i].SetActive(num >= (float)i / (float)durationObj.Length);
			if (durationObj[i].activeSelf)
			{
				durationObj[i].transform.localRotation = Quaternion.Euler(durationObj[i].transform.localRotation.eulerAngles + vector);
			}
		}
	}

	private IEnumerator<float> Activate()
	{
		if (!PositionIsValid())
		{
			yield break;
		}
		FSM.Value.SendEvent("Trigger");
		_chargingVibration = Haptics.Play(chargingHaptics.frequency, chargingHaptics.amplitude, activationTime, _hand.IsRightHand());
		yield return Timing.WaitForSeconds(activationTime);
		FSM.Value.SendEvent("Activate");
		Timing.RunCoroutine(HandleActiveHaptics());
		Color color = q1Renderer.material.GetColor(COLORID);
		color.a = 1f;
		q1Renderer.material.SetColor(COLORID, color);
		q2Renderer.material.SetColor(COLORID, color);
		while (_remainingDuration > 0f)
		{
			_remainingDuration -= Timing.DeltaTime * _difficultyModifier;
			UpdateDurationObjects();
			if (_remainingDuration < minimumChargeToActivate)
			{
				color.a = lowChargeAlpha.Evaluate((minimumChargeToActivate - _remainingDuration) / minimumChargeToActivate);
				if (UnityEngine.Random.Range(0f, minimumChargeToActivate) * UnityEngine.Random.Range(0f, minimumChargeToActivate) * UnityEngine.Random.Range(0f, minimumChargeToActivate) > _remainingDuration * _remainingDuration * _remainingDuration)
				{
					color.a *= UnityEngine.Random.Range(0.7f, 0.9f);
				}
				q1Renderer.material.SetColor(COLORID, color);
				q2Renderer.material.SetColor(COLORID, color);
			}
			yield return float.NegativeInfinity;
		}
		Deactivate();
	}

	private void Deactivate()
	{
		if (_activeRoutine.IsValid && _activeRoutine.IsRunning)
		{
			_activeRoutine.IsRunning = false;
			if (_chargingVibration != null)
			{
				_chargingVibration.Stop();
				_chargingVibration = null;
			}
			FSM.Value.SendEvent("Release");
			Timing.RunCoroutine(Recharge());
			if (_hand != null)
			{
				Haptics.Play(deactivateHaptics, _hand.IsRightHand());
			}
		}
	}

	private IEnumerator<float> HandleActiveHaptics()
	{
		Hand hand = _hand;
		Haptics.Vibration vibration = Haptics.Play(activeHaptics, _hand.IsRightHand());
		while (_hand != null && _hand == hand && _hand.GetGrabbedObject() == this && _activeRoutine.IsRunning)
		{
			vibration.SetAmplitude(activeHaptics.amplitude);
			yield return float.NegativeInfinity;
		}
		vibration.Stop();
	}

	private IEnumerator<float> Recharge()
	{
		if (_remainingDuration < minimumChargeToActivate)
		{
			_isCharged = false;
			_renderer.material.color = disabledColor;
		}
		while (true)
		{
			if (!_isCharged && _remainingDuration >= minimumChargeToActivate)
			{
				_isCharged = true;
				_renderer.material.color = enabledColor;
				if (_hand != null)
				{
					Haptics.Play(rechargeHaptics, _hand.IsRightHand());
				}
			}
			else
			{
				if (_remainingDuration >= MaxDuration)
				{
					_remainingDuration = MaxDuration;
					break;
				}
				if (_activeRoutine.IsRunning)
				{
					break;
				}
			}
			yield return float.NegativeInfinity;
			_remainingDuration += Time.deltaTime * rechargeSpeed;
		}
	}

	private bool PositionIsValid()
	{
		int num = Physics.OverlapSphereNonAlloc(base.transform.position, 0.01f, Utilities.colliderPool, References.HardSolidLayers, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < num; i++)
		{
			if (Utilities.colliderPool[i].transform.GetComponentInParent<VRSystem>() == null)
			{
				return false;
			}
		}
		float maxDistance = Vector3.Distance(References.Headset.position, base.transform.position);
		num = Physics.RaycastNonAlloc(base.transform.position, References.Headset.position - base.transform.position, Utilities.raycastHitPool, maxDistance, References.HardSolidLayers, QueryTriggerInteraction.Ignore);
		for (int j = 0; j < num; j++)
		{
			if (Utilities.raycastHitPool[j].transform.GetComponentInParent<VRSystem>() == null)
			{
				return false;
			}
		}
		return true;
	}

	public void ConsumeDuration(float amount)
	{
		_remainingDuration -= amount;
	}

	public IDamageable GetTarget()
	{
		return this;
	}

	public void ApplyDamage(int amount, string source, DamageType type = DamageType.None)
	{
		if (_activeRoutine.IsRunning)
		{
			Haptics.Play(damagedHaptics.frequency, damagedHaptics.amplitude * (float)amount, damagedHaptics.time, _hand.IsRightHand());
		}
	}

	public bool IsDestroyed()
	{
		return false;
	}

	public void ResetObject()
	{
		_remainingDuration = MaxDuration;
		_isCharged = true;
	}
}
public class ShieldInteractionEffect : MonoBehaviour
{
	private void Start()
	{
		RFX1_TransformMotion componentInChildren = GetComponentInChildren<RFX1_TransformMotion>();
		if (componentInChildren != null)
		{
			componentInChildren.CollisionEnter += TransformMotion_CollisionEnter;
		}
		Fireball componentInChildren2 = GetComponentInChildren<Fireball>();
		if (componentInChildren2 != null)
		{
			componentInChildren2.CollisionEnter += TransformMotion_CollisionEnter;
		}
	}

	private void TransformMotion_CollisionEnter(object sender, RFX1_TransformMotion.RFX1_CollisionInfo e)
	{
		RFX1_ShieldCollisionTrigger componentInChildren = e.Hit.transform.GetComponentInChildren<RFX1_ShieldCollisionTrigger>();
		if (!(componentInChildren == null))
		{
			componentInChildren.OnCollision(e.Hit, base.gameObject);
		}
	}
}
public class Targetable : MonoBehaviour, ITargetable
{
	public bool IsTargetable()
	{
		return base.gameObject.activeInHierarchy;
	}
}
public class Wand : BeltItem
{
	public Renderer crystalRenderer;

	public List<Element> elements;

	public Transform launchPoint;

	public AimAssist aimAssist;

	public AudioClip changeElementSound;

	public VibrationProperties chargingVibration;

	public VibrationProperties chargeCompleteVibration;

	public VibrationProperties firedVibration;

	private int activeElement = -1;

	private float _currentChargeTime;

	private bool _isCharging;

	private bool _isCharged;

	private Haptics.Vibration _vibration;

	private CoroutineHandle _chargingRoutine;

	protected override void PlayGrabHaptics()
	{
		Haptics.Play(itemType.grabHaptics, _hand);
	}

	public override HandPose GetGripPose()
	{
		return itemType.grabPose;
	}

	protected void Awake()
	{
		if (elements.Count > 0)
		{
			activeElement = 0;
			UpdateElement();
			for (int i = 0; i < elements.Count; i++)
			{
				elements[i].OnInitialize();
			}
		}
		onRelease = (Action<Hand, bool>)Delegate.Combine(onRelease, new Action<Hand, bool>(OnRelease));
		References.Wand = this;
	}

	private void Start()
	{
		References.Inventory.wandSlot.PlaceItem(this, playSound: false);
	}

	private void OnTriggerEnter(Collider other)
	{
		other.GetComponent<IWandTouchReceiver>()?.OnTouch((activeElement > -1) ? elements[activeElement] : null);
	}

	public override void GrabWith(Hand hand)
	{
		if (_hand != null)
		{
			GameEvent triggerPressEvent = _hand.triggerPressEvent;
			triggerPressEvent.OnRaise = (Action<bool>)Delegate.Remove(triggerPressEvent.OnRaise, new Action<bool>(TriggerPress));
			GameEvent triggerTouchEvent = _hand.triggerTouchEvent;
			triggerTouchEvent.OnRaise = (Action<bool>)Delegate.Remove(triggerTouchEvent.OnRaise, new Action<bool>(TriggerTouch));
		}
		base.GrabWith(hand);
		Timing.RunCoroutine(AfterGrab());
		GameEvent triggerPressEvent2 = hand.triggerPressEvent;
		triggerPressEvent2.OnRaise = (Action<bool>)Delegate.Combine(triggerPressEvent2.OnRaise, new Action<bool>(TriggerPress));
		GameEvent triggerTouchEvent2 = hand.triggerTouchEvent;
		triggerTouchEvent2.OnRaise = (Action<bool>)Delegate.Combine(triggerTouchEvent2.OnRaise, new Action<bool>(TriggerTouch));
	}

	public void OnRelease(Hand hand, bool playSound = true)
	{
		CancelCharging();
		References.Inventory.wandSlot.PlaceItem(this, playSound);
		GameEvent triggerPressEvent = hand.triggerPressEvent;
		triggerPressEvent.OnRaise = (Action<bool>)Delegate.Remove(triggerPressEvent.OnRaise, new Action<bool>(TriggerPress));
		GameEvent triggerTouchEvent = hand.triggerTouchEvent;
		triggerTouchEvent.OnRaise = (Action<bool>)Delegate.Remove(triggerTouchEvent.OnRaise, new Action<bool>(TriggerTouch));
	}

	public override bool ReleaseOnGrip()
	{
		return true;
	}

	public void AddElement(Element element)
	{
		if (element != null)
		{
			elements.Add(element);
			if (activeElement != -1)
			{
				elements[activeElement].OnDeselected();
				CancelCharging();
			}
			activeElement = elements.Count - 1;
			UpdateElement();
		}
	}

	private IEnumerator<float> AfterGrab()
	{
		yield return 0f;
		if (activeElement != -1 && !_isCharged && (!_chargingRoutine.IsValid || !_chargingRoutine.IsRunning))
		{
			_chargingRoutine = Timing.RunCoroutine(Charge(elements[activeElement].primaryChargeTime));
		}
	}

	public void TriggerPress(bool pressed)
	{
		if (activeElement == -1 || References.PlayerInterfaceLock.IsLocked() || Player.Instance.IsDestroyed() || !pressed || !_isCharged)
		{
			return;
		}
		Vector3 position = launchPoint.position;
		int num = Physics.OverlapSphereNonAlloc(position, 0.01f, Utilities.colliderPool, References.HardSolidLayers, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < num; i++)
		{
			if (Utilities.colliderPool[i].transform.GetComponentInParent<VRSystem>() == null)
			{
				return;
			}
		}
		Vector3 position2 = References.Headset.position;
		float maxDistance = Vector3.Distance(position2, position);
		num = Physics.RaycastNonAlloc(position2, position - position2, Utilities.raycastHitPool, maxDistance, References.HardSolidLayers, QueryTriggerInteraction.Ignore);
		for (int j = 0; j < num; j++)
		{
			if (Utilities.raycastHitPool[j].transform.GetComponentInParent<VRSystem>() == null)
			{
				return;
			}
		}
		elements[activeElement].OnFiredPrimary(launchPoint, aimAssist);
		Haptics.Play(firedVibration, _hand.IsRightHand());
		CancelCharging();
		_chargingRoutine = Timing.RunCoroutine(Charge(elements[activeElement].primaryChargeTime));
	}

	public void TriggerTouch(bool touching)
	{
		if (activeElement != -1 && !References.PlayerInterfaceLock.IsLocked())
		{
			if (touching)
			{
				elements[activeElement].OnTouchPrimary(launchPoint);
			}
			else
			{
				elements[activeElement].OnUntouchPrimary();
			}
		}
	}

	public void NextElement()
	{
		if (activeElement != -1 && elements.Count >= 2 && !(_hand == null) && !References.PlayerInterfaceLock.IsLocked())
		{
			if (elements[activeElement] != null)
			{
				elements[activeElement].OnDeselected();
			}
			CancelCharging();
			activeElement = (activeElement + 1) % elements.Count;
			UpdateElement();
		}
	}

	public void PrevElement()
	{
		if (activeElement != -1 && elements.Count >= 2 && !(_hand == null) && !References.PlayerInterfaceLock.IsLocked())
		{
			if (elements[activeElement] != null)
			{
				elements[activeElement].OnDeselected();
			}
			CancelCharging();
			activeElement = (activeElement - 1 + elements.Count) % elements.Count;
			UpdateElement();
		}
	}

	private void UpdateElement(bool playSound = true)
	{
		if (activeElement != -1)
		{
			crystalRenderer.material = elements[activeElement].crystalMaterial;
			elements[activeElement].OnSelected(base.transform);
			if (playSound)
			{
				launchPoint.GetComponent<AudioSource>().PlayOneShot(changeElementSound);
			}
			CancelCharging();
			if (_hand != null)
			{
				_chargingRoutine = Timing.RunCoroutine(Charge(elements[activeElement].primaryChargeTime));
			}
		}
	}

	private IEnumerator<float> Charge(float time)
	{
		elements[activeElement].OnChargingPrimary(base.transform);
		elements[activeElement].UpdateCharge(base.transform.position);
		_vibration = Haptics.Play(chargingVibration.frequency, chargingVibration.amplitude, time, _hand.IsRightHand());
		_isCharging = true;
		_currentChargeTime = 0f;
		while (_isCharging && _currentChargeTime < time)
		{
			yield return 0f;
			_currentChargeTime += Time.deltaTime;
			elements[activeElement].UpdateCharge(Vector3.Lerp(base.transform.position, launchPoint.position, _currentChargeTime / time));
		}
		if (!_isCharging)
		{
			_vibration.Stop();
			yield break;
		}
		_isCharged = true;
		_isCharging = false;
		Haptics.Play(chargeCompleteVibration, _hand.IsRightHand());
		elements[activeElement].OnChargedPrimary();
	}

	private void CancelCharging()
	{
		if (_chargingRoutine.IsValid)
		{
			_chargingRoutine.IsRunning = false;
		}
		if (activeElement != -1)
		{
			elements[activeElement].OnCancel();
			_isCharged = false;
			_isCharging = false;
		}
	}

	public void ResetObject()
	{
		if (activeElement != -1)
		{
			elements[activeElement].OnDeselected();
			CancelCharging();
		}
		activeElement = -1;
		elements.Clear();
	}

	public Element GetElement()
	{
		if (activeElement > -1)
		{
			return elements[activeElement];
		}
		return null;
	}

	public void LoadElements(bool fire, bool ice, string active)
	{
		References.Wand.ResetObject();
		if (fire)
		{
			elements.Add(References.Fire);
		}
		if (ice)
		{
			elements.Add(References.Ice);
		}
		for (int i = 0; i < elements.Count; i++)
		{
			if (elements[i].name == active)
			{
				activeElement = i;
			}
		}
		UpdateElement(playSound: false);
	}
}
[RequireComponent(typeof(PlayMakerFSM))]
public class WandTouchReceiver : MonoBehaviour, IWandTouchReceiver
{
	public PlayMakerFSM FSM;

	public List<Element> allowedElements;

	public string playmakerEvent;

	private void OnValidate()
	{
		FSM = GetComponent<PlayMakerFSM>();
	}

	public void OnTouch(Element element)
	{
		if (allowedElements == null || allowedElements.Count == 0 || allowedElements.Contains(element))
		{
			FSM.SendEvent(playmakerEvent);
		}
	}
}
public class Lever : MonoBehaviour, IGrabbableObject, IGrabTrigger, ISaveSerializable
{
	[Serializable]
	public class LeverData : ISaveData
	{
		[SerializeField]
		private bool _isOn;

		public void Serialize(ISaveSerializable target)
		{
			Lever lever = (Lever)target;
			_isOn = lever._isOn;
		}

		public void Deserialize(ISaveSerializable target)
		{
			((Lever)target)._isOn = _isOn;
		}
	}

	public Transform hinge;

	public Transform lever;

	public Transform gripSnapPoint;

	public PlayMakerFSM FSM;

	[UnityEngine.Tooltip("FSM event to send when the lever is moved towards the max angle")]
	public string eventOnActivate;

	[UnityEngine.Tooltip("FSM event to send when the lever is moved towards the min angle")]
	public string eventOnDeactivate;

	public Axis rotationAxis;

	public Axis gripAxis = Axis.Y;

	public HandPose grabPose = HandPose.GrabLever;

	public float minAngle;

	public float maxAngle;

	public float resetSpeed = 50f;

	public VibrationProperties grabHaptics;

	public VibrationProperties moveHaptics;

	public VibrationProperties toggleHaptics;

	public VibrationProperties limitHaptics;

	public AudioSource playOnMove;

	public float playOnMoveFadeDuration = 0.1f;

	private float _playOnMoveVolume;

	public AudioSource playOnMoveLocked;

	public bool isLocked;

	public UnityEvent onActivated;

	public UnityEvent onDeactivated;

	protected Hand _hand;

	protected Rigidbody _rigidbody;

	private float _lastAngle;

	private bool _isOn;

	private CoroutineHandle _handle;

	private float _trgtVol;

	private void Awake()
	{
		if (playOnMove != null)
		{
			_playOnMoveVolume = playOnMove.volume;
		}
		_isOn = Mathf.Clamp((GetAngle() % 360f - minAngle) / (maxAngle - minAngle), 0f, 1f) >= 0.5f;
	}

	public void GrabWith(Hand hand)
	{
		if (!isLocked)
		{
			if (_hand != null && _hand != hand)
			{
				_hand.StopGrabbing(this);
			}
			_hand = hand;
			_hand.SetGrabbing(this);
			Haptics.Play(grabHaptics, _hand);
			Timing.RunCoroutine(HandleHaptics());
			_handle = Timing.RunCoroutineSingleton(FollowHand(), _handle, SingletonBehavior.Abort);
		}
	}

	public void Release(Hand hand, bool playSound = true)
	{
		_hand = null;
		hand.StopGrabbing(this);
		_trgtVol = 0f;
		Timing.RunCoroutine(MoveToEnd());
	}

	private IEnumerator<float> FollowHand()
	{
		while (_hand != null)
		{
			if (isLocked)
			{
				if (playOnMoveLocked != null)
				{
					playOnMoveLocked.Play();
				}
				Release(_hand);
				break;
			}
			float value = Vector3.SignedAngle(GetAxis(gripAxis, hinge), hinge.TransformDirection(FlattenPosition(hinge.InverseTransformDirection(_hand.GetGripPositionFromTrackingTarget() - lever.position))), GetAxis(rotationAxis, hinge));
			value = Mathf.Clamp(value, minAngle, maxAngle);
			SetAngle(value);
			float num = Mathf.Abs(Mathf.DeltaAngle(value, _lastAngle));
			_trgtVol = 0.01f * num / Time.deltaTime;
			if (_trgtVol < 0.2f)
			{
				_trgtVol = 0f;
			}
			if (playOnMove != null)
			{
				playOnMove.volume = Mathf.Clamp01(Mathf.Lerp(playOnMove.volume, _trgtVol * _playOnMoveVolume, Time.deltaTime * 20f));
				if (!playOnMove.isPlaying)
				{
					if (playOnMove.volume > 0f)
					{
						playOnMove.Play();
					}
				}
				else if (playOnMove.volume == 0f)
				{
					playOnMove.Stop();
				}
			}
			if ((value == minAngle || value == maxAngle) && _lastAngle != value)
			{
				Haptics.Play(limitHaptics, _hand);
			}
			CheckState(value, inHand: true);
			_lastAngle = value;
			yield return float.NegativeInfinity;
		}
	}

	private IEnumerator<float> HandleHaptics()
	{
		Hand hand = _hand;
		Haptics.Vibration vibration = Haptics.Play(moveHaptics.frequency, 0f, 0f, _hand);
		while (_hand != null && _hand == hand && _hand.GetGrabbedObject() == this)
		{
			vibration.SetAmplitude(_trgtVol * moveHaptics.amplitude);
			yield return float.NegativeInfinity;
		}
		vibration.Stop();
	}

	private IEnumerator<float> MoveToEnd()
	{
		if (playOnMove != null)
		{
			float num = 0.01f * resetSpeed;
			playOnMove.volume = Mathf.Clamp01(Mathf.Lerp(playOnMove.volume, num * _playOnMoveVolume, Time.deltaTime * 20f));
			if (!playOnMove.isPlaying)
			{
				playOnMove.Play();
			}
		}
		float num2 = Vector3.SignedAngle(GetAxis(gripAxis, hinge), GetAxis(gripAxis, lever), GetAxis(rotationAxis, hinge));
		while (_hand == null && Mathf.Abs(_lastAngle - num2) < 0.001f && _lastAngle != minAngle && _lastAngle != maxAngle)
		{
			if (_lastAngle < minAngle + (maxAngle - minAngle) / 2f)
			{
				_lastAngle -= resetSpeed * Time.deltaTime;
			}
			else
			{
				_lastAngle += resetSpeed * Time.deltaTime;
			}
			_lastAngle = Mathf.Clamp(_lastAngle, minAngle, maxAngle);
			SetAngle(_lastAngle);
			CheckState(_lastAngle, inHand: false);
			yield return float.NegativeInfinity;
			num2 = Vector3.SignedAngle(GetAxis(gripAxis, hinge), GetAxis(gripAxis, lever), GetAxis(rotationAxis, hinge));
		}
		if (playOnMove != null)
		{
			playOnMove.Stop();
		}
	}

	private void CheckState(float angle, bool inHand)
	{
		float num = Mathf.Clamp((angle % 360f - minAngle) / (maxAngle - minAngle), 0f, 1f);
		if (num <= (inHand ? 0.48f : 0.5f) && _isOn)
		{
			if (FSM != null && !string.IsNullOrEmpty(eventOnDeactivate))
			{
				FSM.SendEvent(eventOnDeactivate);
			}
			onDeactivated.Invoke();
			_isOn = false;
			if (inHand)
			{
				Haptics.Play(toggleHaptics, _hand);
			}
		}
		else if (num >= (inHand ? 0.52f : 0.5f) && !_isOn)
		{
			if (FSM != null && !string.IsNullOrEmpty(eventOnActivate))
			{
				FSM.SendEvent(eventOnActivate);
			}
			onActivated.Invoke();
			_isOn = true;
			if (inHand)
			{
				Haptics.Play(toggleHaptics, _hand);
			}
		}
	}

	public float GetAngle()
	{
		return rotationAxis switch
		{
			Axis.X => lever.localRotation.eulerAngles.x, 
			Axis.Y => lever.localRotation.eulerAngles.y, 
			_ => lever.localRotation.eulerAngles.z, 
		};
	}

	public void SetAngle(float angle)
	{
		switch (rotationAxis)
		{
		case Axis.X:
			lever.localRotation = Quaternion.Euler(angle, 0f, 0f);
			break;
		case Axis.Y:
			lever.localRotation = Quaternion.Euler(0f, angle, 0f);
			break;
		default:
			lever.localRotation = Quaternion.Euler(0f, 0f, angle);
			break;
		}
	}

	private Vector3 FlattenPosition(Vector3 position)
	{
		return rotationAxis switch
		{
			Axis.X => new Vector3(0f, position.y, position.z), 
			Axis.Y => new Vector3(position.x, 0f, position.z), 
			_ => new Vector3(position.x, position.y, 0f), 
		};
	}

	private Vector3 GetAxis(Axis axis, Transform reference)
	{
		return axis switch
		{
			Axis.X => reference.right, 
			Axis.Y => reference.up, 
			_ => reference.forward, 
		};
	}

	private float GetRadius()
	{
		return gripAxis switch
		{
			Axis.X => gripSnapPoint.localPosition.x, 
			Axis.Y => gripSnapPoint.localPosition.y, 
			_ => gripSnapPoint.localPosition.z, 
		};
	}

	public bool ClimbOnTarget()
	{
		return false;
	}

	public HandPose GetGripPose()
	{
		return grabPose;
	}

	public Transform GetGripSnapPoint(Hand hand)
	{
		return gripSnapPoint;
	}

	public bool HandClingsToTarget()
	{
		return true;
	}

	public bool ReleaseOnGrip()
	{
		return false;
	}

	public bool CanGrab()
	{
		return !isLocked;
	}

	public ISaveData Serialize()
	{
		LeverData leverData = new LeverData();
		leverData.Serialize(this);
		return leverData;
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((LeverData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<LeverData>(saveData).Deserialize(this);
	}
}
public class MenuManager : MonoBehaviour
{
	public GameEvent pauseButtonEvent;

	public GameObject settingsRoom;

	public GameObject UIHelpers;

	public CanvasGroup settingsUI;

	public CanvasGroupFade mainMenu;

	public GameObject[] otherMenus;

	public CanvasGroupFade newGameMenu;

	public GameObject newGameButton;

	public GameObject continueButton;

	public GameObject resumeButton;

	public Transform moveToPosition;

	public Transform odinStartPosition;

	public Room room1;

	public GameObject portalWall;

	public GameObject portalWallOpaque;

	public AudioSource menuMusic;

	public ItemType potion1;

	public ItemType potion2;

	public ItemType potion3;

	public CameraColorOverlay[] screenOverlays;

	public GameObject[] screenEffects;

	private bool _menuButtonActive;

	private Vector3 _position;

	private Vector3 _rotationForward;

	private bool[] _activeEffects;

	public static bool IsInMenu { get; private set; }

	private void Start()
	{
		_activeEffects = new bool[screenEffects.Length];
		GameEvent gameEvent = pauseButtonEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Combine(gameEvent.OnTrue, new System.Action(Toggle));
		GameEvent onPlayerDeath = References.OnPlayerDeath;
		onPlayerDeath.OnTrue = (System.Action)Delegate.Combine(onPlayerDeath.OnTrue, new System.Action(DisableMenu));
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Combine(onPlayerRespawn.OnTrue, new System.Action(EnableMenu));
		OVRManager.display.RecenteredPose += OnRecenter;
		References.PlayerMoveTeleportLock.LockUsing(this);
		References.SaveGameLock.LockUsing(this);
		portalWall.GetComponent<Renderer>().material.color = Color.black;
		IsInMenu = true;
		Singleton<VRSystem>.Instance.SetTimeScale(0f);
	}

	private void OnDestroy()
	{
		GameEvent gameEvent = pauseButtonEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(Toggle));
		GameEvent onPlayerDeath = References.OnPlayerDeath;
		onPlayerDeath.OnTrue = (System.Action)Delegate.Remove(onPlayerDeath.OnTrue, new System.Action(DisableMenu));
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Remove(onPlayerRespawn.OnTrue, new System.Action(EnableMenu));
		if (OVRManager.display != null)
		{
			OVRManager.display.RecenteredPose -= OnRecenter;
		}
	}

	private void OnRecenter()
	{
		if (IsInMenu)
		{
			Timing.RunCoroutine(RecenterMenu());
		}
	}

	private void DisableMenu()
	{
		_menuButtonActive = false;
	}

	private void EnableMenu()
	{
		_menuButtonActive = true;
	}

	private IEnumerator<float> RecenterMenu()
	{
		yield return float.NegativeInfinity;
		References.TrackingSpaceTransform.localPosition = Vector3.zero;
		References.TrackingSpaceTransform.localRotation = Quaternion.identity;
	}

	private void OpenMenu()
	{
		References.OnMenuOpened.RaiseTrue();
		References.PlayerMoveTeleportLock.LockUsing(this);
		References.SaveGameLock.LockUsing(this);
		portalWall.GetComponent<Renderer>().material.color = Color.black;
		MovePlayerToMenu();
		Player.Instance.leftHand.RemoveObjectFromHand(ignoreEquipment: false);
		Player.Instance.rightHand.RemoveObjectFromHand(ignoreEquipment: false);
		for (int i = 0; i < screenOverlays.Length; i++)
		{
			screenOverlays[i].enabled = false;
		}
		for (int j = 0; j < screenEffects.Length; j++)
		{
			_activeEffects[j] = screenEffects[j].activeSelf;
			screenEffects[j].SetActive(value: false);
		}
		newGameButton.SetActive(value: false);
		continueButton.SetActive(value: false);
		resumeButton.SetActive(value: true);
		settingsRoom.SetActive(value: true);
		UIHelpers.SetActive(value: true);
		mainMenu.FadeIn();
		for (int k = 0; k < otherMenus.Length; k++)
		{
			otherMenus[k].SetActive(value: false);
		}
		settingsUI.alpha = 1f;
		IsInMenu = true;
		Singleton<VRSystem>.Instance.SetTimeScale(0f);
		AudioListener.pause = true;
	}

	public void CloseMenu()
	{
		if (_menuButtonActive)
		{
			for (int i = 0; i < screenOverlays.Length; i++)
			{
				screenOverlays[i].enabled = true;
				screenOverlays[i].RemoveColorOverlay();
			}
			for (int j = 0; j < screenEffects.Length; j++)
			{
				screenEffects[j].SetActive(_activeEffects[j]);
			}
		}
		References.PlayerMoveTeleportLock.Unlock(this);
		Player.Instance.leftHand.ReplaceObjectInHand();
		Player.Instance.rightHand.ReplaceObjectInHand();
		Player.Instance.SetPositionAndRotation(_position, _rotationForward, useHeadPosition: false, setValid: false);
		Player.Instance.lowestDifficulty = (Difficulty)Mathf.Min((int)Settings.Current.difficulty, (int)Player.Instance.lowestDifficulty);
		AudioListener.pause = false;
		IsInMenu = false;
		Timing.RunCoroutine(CloseMenuCoroutine(), Segment.EndOfFrame);
	}

	private IEnumerator<float> CloseMenuCoroutine()
	{
		UIHelpers.SetActive(value: false);
		Singleton<VRSystem>.Instance.SetTimeScale(1f);
		yield return float.NegativeInfinity;
		settingsRoom.SetActive(value: false);
		yield return Timing.WaitForSeconds(0.2f);
		References.SaveGameLock.Unlock(this);
		References.OnMenuOpened.RaiseFalse();
	}

	private void Toggle()
	{
		if (_menuButtonActive)
		{
			if (IsInMenu)
			{
				CloseMenu();
			}
			else if (!References.PlayerInterfaceLock.IsLocked())
			{
				OpenMenu();
			}
		}
	}

	public void NewGame(int difficulty)
	{
		switch (difficulty)
		{
		case 1:
			Settings.SetDifficulty(Difficulty.Easy);
			break;
		case 2:
			Settings.SetDifficulty(Difficulty.Normal);
			break;
		case 3:
			Settings.SetDifficulty(Difficulty.Hard);
			break;
		}
		References.SaveGameLock.Unlock(this);
		_menuButtonActive = false;
		ProfileManager.SetActiveProfile();
		AudioListener.pause = false;
		OdinHint.StopSound();
		Singleton<OdinMenu>.Instance.PlayClip(0);
		MusicManager.Stop(0.0001f);
		newGameMenu.FadeOut();
		Timing.RunCoroutine(NewGameRoutine());
	}

	private IEnumerator<float> NewGameRoutine()
	{
		yield return Timing.WaitUntilDone(SceneStateManager.UnloadRoom(room1, saveData: false));
		SceneStateManager.SetSceneData(null);
		SceneStateManager.PreloadRoom(room1);
		Player instance = Player.Instance;
		instance.leftHand.GetGrabbedObject()?.Release(instance.leftHand, playSound: false);
		instance.rightHand.GetGrabbedObject()?.Release(instance.rightHand, playSound: false);
		instance.HP = 10;
		instance.shieldGems = 0;
		instance.lowestDifficulty = Settings.Current.difficulty;
		instance.monsterKills = 0;
		instance.splineController = null;
		References.Wand.LoadElements(fire: false, ice: false, null);
		if (References.Shield != null)
		{
			UnityEngine.Object.Destroy(References.Shield.gameObject);
		}
		References.Inventory.ResetObject();
		Singleton<Odin>.Instance.Teleport(odinStartPosition);
		HintSystem.ResetAllPuzzles();
		Singleton<OdinQuip>.Instance.ResetAllQuips();
		References.OnLoadNewProfile.RaiseTrue();
		CoroutineHandle setRoomHandle = Timing.RunCoroutine(SceneStateManager.SetRooms(new List<Room> { room1 }, new List<Room>(), forceLoadData: true));
		yield return Timing.WaitUntilFalse(() => Singleton<OdinMenu>.Instance.audioSource.isPlaying || setRoomHandle.IsRunning);
		References.PlayerMoveTeleportLock.Unlock(this);
		UIHelpers.SetActive(value: false);
		portalWallOpaque.SetActive(value: false);
		for (int i = 0; i < screenOverlays.Length; i++)
		{
			screenOverlays[i].enabled = true;
			screenOverlays[i].RemoveColorOverlay();
		}
		Timing.CallDelayed(4f, delegate
		{
			IsInMenu = false;
		});
		Timing.WaitUntilFalse(() => VRSystem.IsPaused);
		Singleton<VRSystem>.Instance.SetTimeScale(1f);
		References.Subtitles.transform.parent = References.TrackingSpaceTransform;
		PlayMakerFSM portalFSM = ObjectID.Get<PlayMakerFSM>("PortalStart");
		portalFSM.SendEvent("Activate");
		Material wall = portalWall.GetComponent<Renderer>().material;
		Color color = wall.color;
		while (settingsUI.alpha > 0f)
		{
			settingsUI.alpha -= Time.deltaTime;
			color.a -= Time.deltaTime;
			wall.color = color;
			yield return float.NegativeInfinity;
		}
		References.HeadCollider.SetActive(value: true);
		yield return Timing.WaitForSeconds(5f);
		settingsRoom.SetActive(value: false);
		yield return Timing.WaitUntilTrue(() => portalFSM.ActiveStateName == "State 4");
		References.Subtitles.transform.parent = Singleton<VRSystem>.Instance.transform;
		wall.color = Color.black;
		Singleton<OdinQuip>.Instance.EnableQuips();
		Singleton<OdinQuip>.Instance.SetIndoors(indoors: false);
		_menuButtonActive = true;
		portalWallOpaque.SetActive(value: true);
	}

	public void ContinueGame()
	{
		ProfileManager.SetActiveProfile();
		AudioListener.pause = false;
		OdinHint.StopSound();
		References.OnLoadNewProfile.RaiseTrue();
		int iD = ProfileManager.GetActiveProfile().ID;
		string path = $"{UnityEngine.Application.persistentDataPath}/Profile{iD}.sav";
		if (File.Exists(path))
		{
			SaveFile file = JsonUtility.FromJson<SaveFile>(File.ReadAllText(path));
			Timing.RunCoroutine(ContinueGameRoutine(file), Segment.RealtimeUpdate);
		}
		else
		{
			UnityEngine.Debug.LogError("Save file not found");
		}
	}

	private IEnumerator<float> ContinueGameRoutine(SaveFile file)
	{
		IsInMenu = false;
		yield return Timing.WaitUntilDone(SaveSystem.Load(file), Segment.RealtimeUpdate);
		References.PlayerMoveTeleportLock.Unlock(this);
		References.HeadCollider.SetActive(value: true);
		Timing.RunCoroutine(CloseMenuCoroutine(), Segment.EndOfFrame);
		Timing.CallDelayed(0.2f, delegate
		{
			References.SaveGameLock.Unlock(this);
		});
		_menuButtonActive = true;
		menuMusic.FadeOut(0.2f);
		for (int i = 0; i < screenOverlays.Length; i++)
		{
			screenOverlays[i].enabled = true;
			screenOverlays[i].RemoveColorOverlay();
		}
	}

	public void LoadRoom(Room room)
	{
		ProfileManager.SetActiveProfile();
		AudioListener.pause = false;
		OdinHint.StopSound();
		References.SaveGameLock.LockUsing(this);
		References.PlayerFallLock.LockUsing(this);
		References.Wand.LoadElements(room.hasFire, room.hasIce, "Fire");
		if (room.hasShield)
		{
			Shield shield = ((References.Shield == null) ? ((Shield)References.Inventory.GetItem(References.ShieldItem)) : References.Shield);
			References.Inventory.shieldSlot.PlaceItem(shield, playSound: false);
			shield.ResetObject();
		}
		else if (References.Shield != null)
		{
			UnityEngine.Object.Destroy(References.Shield.gameObject);
		}
		References.Inventory.AddToInventory(potion1);
		References.Inventory.AddToInventory(potion2);
		References.Inventory.AddToInventory(potion3);
		MusicManager.Stop(0.0001f);
		Timing.RunCoroutine(LoadRoomRoutine(room), Segment.EndOfFrame);
	}

	private IEnumerator<float> LoadRoomRoutine(Room room)
	{
		yield return Timing.WaitUntilDone(SceneStateManager.SetRooms(new List<Room> { room }, new List<Room>()));
		bool[] array = new bool[HintSystem.PuzzleCount];
		for (int i = 0; i < room.completedPuzzles && i < array.Length; i++)
		{
			array[i] = true;
		}
		HintSystem.SetPuzzleStatus(array);
		Singleton<OdinQuip>.Instance.EnableQuips();
		Singleton<OdinQuip>.Instance.SetIndoors(indoors: true);
		menuMusic.FadeOut(0.2f);
		yield return float.NegativeInfinity;
		CloseMenu();
		Player.Instance.SetPositionAndRotation(ObjectID.Get<Transform>(room.startingLocationID), useHeadPosition: false);
		Singleton<Odin>.Instance.Teleport(ObjectID.Get<Transform>(room.perchID));
		_menuButtonActive = true;
		References.PlayerFallLock.Unlock(this);
		References.HeadCollider.SetActive(value: true);
	}

	public void EndGame()
	{
		References.OdinHintLock.UnlockAll();
		References.OdinVisionLock.UnlockAll();
		References.PlayerFallLock.UnlockAll();
		References.PlayerInterfaceLock.UnlockAll();
		References.PlayerMoveTeleportLock.UnlockAll();
		References.SaveGameLock.UnlockAll();
		_menuButtonActive = false;
		ProfileManager.Clear();
		Player instance = Player.Instance;
		instance.leftHand.GetGrabbedObject()?.Release(Player.Instance.leftHand, playSound: false);
		instance.rightHand.GetGrabbedObject()?.Release(Player.Instance.rightHand, playSound: false);
		SceneStateManager.SetSceneData(null);
		Timing.RunCoroutine(SceneStateManager.SetRooms(new List<Room>(), new List<Room>()));
		CombatTracker.DisengageAll();
		instance.HP = 10;
		instance.shieldGems = 0;
		instance.lowestDifficulty = Difficulty.Normal;
		instance.monsterKills = 0;
		instance.splineController = null;
		References.Wand.ResetObject();
		if (References.Shield != null)
		{
			UnityEngine.Object.Destroy(References.Shield.gameObject);
		}
		References.Inventory.ResetObject();
		HintSystem.ResetAllPuzzles();
		Singleton<OdinQuip>.Instance.ResetAllQuips();
		menuMusic.Play();
		References.OnMenuOpened.RaiseTrue();
		References.PlayerMoveTeleportLock.LockUsing(this);
		References.SaveGameLock.LockUsing(this);
		if (!instance.IsInValidLocation)
		{
			References.HeadCollider.GetComponent<CameraColorOverlay>().RemoveColorOverlay();
		}
		instance.SetPositionAndRotation(moveToPosition, useHeadPosition: false, setValid: false);
		Player.Instance.leftHand.GetGrabbedObject()?.Release(Player.Instance.leftHand, playSound: false);
		Player.Instance.rightHand.GetGrabbedObject()?.Release(Player.Instance.rightHand, playSound: false);
		for (int i = 0; i < screenOverlays.Length; i++)
		{
			screenOverlays[i].enabled = false;
		}
		for (int j = 0; j < screenEffects.Length; j++)
		{
			_activeEffects[j] = screenEffects[j].activeSelf;
			screenEffects[j].SetActive(value: false);
		}
		newGameButton.SetActive(value: false);
		continueButton.SetActive(value: false);
		resumeButton.SetActive(value: false);
		settingsRoom.SetActive(value: true);
		UIHelpers.SetActive(value: true);
		otherMenus[0].GetComponent<CanvasGroupFade>().FadeIn();
		mainMenu.gameObject.SetActive(value: false);
		for (int k = 1; k < otherMenus.Length; k++)
		{
			otherMenus[k].SetActive(value: false);
		}
		settingsUI.alpha = 1f;
		IsInMenu = true;
		Singleton<VRSystem>.Instance.SetTimeScale(0f);
		AudioListener.pause = true;
	}

	private void MovePlayerToMenu()
	{
		Player instance = Player.Instance;
		if (instance.IsInValidLocation && !IsInMenu && !OdinView.IsViewingOrTransitioning())
		{
			_position = instance.GetPosition();
			_rotationForward = References.Headset.forward;
		}
		else
		{
			References.HeadCollider.GetComponent<CameraColorOverlay>().RemoveColorOverlay();
			RelativeLocation recentValidLocation = References.HeadColliderScript.GetRecentValidLocation();
			_position = recentValidLocation.GetWorldPos();
			_rotationForward = recentValidLocation.GetForward();
		}
		instance.SetPositionAndRotation(moveToPosition, useHeadPosition: false, setValid: false);
	}
}
public class MenuTooltip : MonoBehaviour
{
	public GameObject canvas;

	public LocalizeText textbox;

	public Image textboxBackground;

	private MenuTooltipHover _target;

	private MenuTooltipHover _temp;

	private void OnDisable()
	{
		canvas.gameObject.SetActive(value: false);
	}

	private void Update()
	{
		int num = Physics.OverlapSphereNonAlloc(base.transform.position, 0.005f, Utilities.colliderPool);
		_target = null;
		_temp = null;
		if (num > 0)
		{
			float num2 = 10f;
			for (int i = 0; i < num; i++)
			{
				float num3 = Vector3.Distance(base.transform.position, Utilities.colliderPool[i].ClosestPoint(base.transform.position));
				if (num3 < num2 && Utilities.colliderPool[i].TryGetComponent<MenuTooltipHover>(out _temp))
				{
					num2 = num3;
					_target = _temp;
				}
			}
			if (_target != null)
			{
				canvas.SetActive(value: true);
				textbox.SetText(_target.textID);
				textboxBackground.rectTransform.sizeDelta = new Vector2(500f, textbox.textField.preferredHeight + 20f);
				base.transform.rotation = _target.transform.rotation;
				return;
			}
		}
		canvas.SetActive(value: false);
	}
}
public class MenuTooltipHover : MonoBehaviour
{
	public string textID;
}
public class MinecartReposition : MonoBehaviour
{
	public Collider collider;

	private void OnValidate()
	{
		if (collider == null)
		{
			collider = GetComponent<Collider>();
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.gameObject == References.HeadCollider)
		{
			Physics.ComputePenetration(References.HeadCollider.GetComponent<Collider>(), References.HeadCollider.transform.position, References.HeadCollider.transform.rotation, collider, base.transform.position, base.transform.rotation, out var direction, out var distance);
			References.TrackingSpaceTransform.position += Vector3.ProjectOnPlane(direction, base.transform.up) * (distance + 0.2f);
		}
	}
}
public class ArcShot : MonoBehaviour
{
	public float height;

	private Vector3 _startPos;

	private Vector3 _endPos;

	private Vector3 _targetPath;

	private Vector3 _targetPathNormalized;

	private float _targetDist;

	public void SetTarget(Vector3 target)
	{
		_startPos = base.transform.position;
		_endPos = target;
		_targetPath = _endPos - _startPos;
		_targetPathNormalized = _targetPath.normalized;
		_targetDist = _targetPath.magnitude;
	}

	private void LateUpdate()
	{
		float magnitude = Vector3.Project(base.transform.position - _startPos, _targetPath).magnitude;
		float num = (0f - height) * magnitude * magnitude + height * magnitude * _targetDist;
		base.transform.position = _startPos + _targetPathNormalized * magnitude + Vector3.up * num;
	}
}
public class CageSpider : NavMobAI
{
	public DamageInstant damageZone;

	public float backUpDistance;

	public float attackingDistance;

	public float attackingAngle;

	public FloatReference attackInterval;

	public float jumpDistance;

	public float chaseSpeed;

	public float chaseAccel;

	public float chaseTurn;

	private Transform _player;

	private float _nextAttack;

	private float _lastPathSet;

	private bool _hasJumped;

	private float _baseSpeed;

	private float _baseAccel;

	private float _baseTurn;

	private void Start()
	{
		_player = Player.Instance.transform;
	}

	private void OnEnable()
	{
		_baseSpeed = agent.speed;
		_baseAccel = agent.acceleration;
		_baseTurn = agent.angularSpeed;
		agent.speed = chaseSpeed;
		agent.acceleration = chaseAccel;
		agent.angularSpeed = chaseTurn;
	}

	private void OnDisable()
	{
		agent.speed = _baseSpeed;
		agent.acceleration = _baseAccel;
		agent.angularSpeed = _baseTurn;
		navMeshMob.setAnimationParams = true;
		_hasJumped = false;
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		if (fsm.ActiveStateName != "Attacking")
		{
			base.enabled = false;
			return;
		}
		Vector3 to = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
		float magnitude = to.magnitude;
		if ((!_hasJumped && magnitude > jumpDistance) || (_hasJumped && magnitude > attackingDistance) || (ViewIsBlocked() && magnitude > backUpDistance))
		{
			navMeshMob.setAnimationParams = true;
			if (!(Time.time < _lastPathSet + 0.25f))
			{
				agent.SetDestination(_player.position);
				_lastPathSet = Time.time;
			}
			return;
		}
		navMeshMob.setAnimationParams = false;
		if (!_hasJumped && magnitude > attackingDistance && magnitude <= jumpDistance)
		{
			animator.SetTrigger(MobAI.JUMP);
			_nextAttack = Time.time + (float)attackInterval;
			Timing.RunCoroutine(JumpDamage().CancelWith(navMeshMob));
			_hasJumped = true;
		}
		float num = Vector3.SignedAngle(base.transform.forward, to, base.transform.up);
		if (Mathf.Abs(num) > attackingAngle)
		{
			animator.SetFloat(MobAI.ROTATION, num);
			animator.SetFloat(MobAI.SPEED, 0f);
			return;
		}
		animator.SetFloat(MobAI.ROTATION, 0f);
		if (magnitude < backUpDistance)
		{
			agent.nextPosition = base.transform.position - base.transform.forward * agent.speed / 4f * Time.deltaTime;
			animator.SetFloat(MobAI.SPEED, 0f - (backUpDistance - magnitude));
		}
		else if (Time.time >= _nextAttack)
		{
			if (magnitude > attackingDistance)
			{
				animator.ResetTrigger(MobAI.BITE);
				return;
			}
			animator.SetTrigger(MobAI.BITE);
			_nextAttack = Time.time + (float)attackInterval;
		}
	}

	private bool ViewIsBlocked()
	{
		Vector3 vector = base.transform.position + base.transform.up * 0.2f;
		int num = Physics.RaycastNonAlloc(vector, _player.position - vector, Utilities.raycastHitPool, jumpDistance, References.SolidLayers);
		if (num > 0)
		{
			Array.Sort(Utilities.raycastHitPool, 0, num, Utilities.RaycastHitDistanceComparer.Comparer);
		}
		for (int i = 0; i < num; i++)
		{
			Transform transform = Utilities.raycastHitPool[i].transform;
			if (transform.IsChildOf(_player) || _player.IsChildOf(transform))
			{
				break;
			}
			if (!transform.IsChildOf(base.transform) && !base.transform.IsChildOf(transform))
			{
				return true;
			}
		}
		return false;
	}

	private IEnumerator<float> JumpDamage()
	{
		yield return Timing.WaitForSeconds(0.75f);
		if (base.enabled && !navMeshMob.IsDestroyed())
		{
			damageZone.Damage();
		}
	}
}
public class ChargingWorm : MobAI
{
	public NavMeshAgent agent;

	public Transform head;

	private Transform _player;

	private float _distToMove;

	private float _currentSpeed;

	private void Start()
	{
		_player = Player.Instance.transform;
	}

	public void Charge()
	{
		_distToMove = Vector3.Distance(_player.position, base.transform.position) + 3f;
		int num = Physics.RaycastNonAlloc(head.position, base.transform.forward, Utilities.raycastHitPool, _distToMove, References.SolidLayers);
		if (num > 0)
		{
			Array.Sort(Utilities.raycastHitPool, 0, num, Utilities.RaycastHitDistanceComparer.Comparer);
		}
		for (int i = 0; i < num; i++)
		{
			Transform transform = Utilities.raycastHitPool[i].transform;
			if (!transform.IsChildOf(_player) && !_player.IsChildOf(transform) && !(transform == base.transform))
			{
				_distToMove = Utilities.raycastHitPool[i].distance - 0.1f;
				break;
			}
		}
		animator.speed = 2f;
		_currentSpeed = 0f;
		animator.SetFloat(MobAI.ROTATION, 0f);
		base.enabled = true;
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		string activeStateName = fsm.ActiveStateName;
		if (!(activeStateName == "Attacking"))
		{
			if (activeStateName == "Face Player")
			{
				Vector3 vector = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
				float num = Vector3.SignedAngle(base.transform.forward, vector, base.transform.up);
				animator.SetFloat(MobAI.ROTATION, Mathf.Clamp(num, -1f, 1f), 0.1f, Time.deltaTime);
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(vector, Vector3.up), agent.angularSpeed * Time.deltaTime);
				if (Mathf.Abs(num) <= 1f)
				{
					fsm.SendEvent("Continue");
					base.enabled = false;
				}
			}
			else
			{
				animator.speed = 1f;
				animator.SetFloat(MobAI.SPEED, 0f);
				animator.SetFloat(MobAI.ROTATION, 0f);
				base.enabled = false;
			}
			return;
		}
		if (_distToMove > 1f)
		{
			_currentSpeed += Time.deltaTime * agent.acceleration;
			if (_currentSpeed > agent.speed)
			{
				_currentSpeed = agent.speed;
			}
		}
		else
		{
			_currentSpeed -= Time.deltaTime * agent.acceleration;
			if (_currentSpeed <= 0f)
			{
				_currentSpeed = 0f;
				_distToMove = 0f;
			}
		}
		animator.SetFloat(MobAI.SPEED, _currentSpeed / agent.speed);
		float num2 = _currentSpeed * Time.deltaTime;
		agent.nextPosition = base.transform.position + base.transform.forward * num2;
		_distToMove -= num2;
		if (_distToMove <= 0f)
		{
			base.enabled = false;
			fsm.SendEvent("Continue");
			animator.speed = 1f;
			animator.SetFloat(MobAI.SPEED, 0f);
		}
	}
}
public class CrawlingWorm : NavMobAI
{
	public float backUpDistance;

	public float attackingDistance;

	public float attackingAngle;

	public FloatReference attackInterval;

	[UnityEngine.Tooltip("When this mob enters the Call state, it will send the Activate event to these FSMs. On Easy difficulty, only the first one will be activated")]
	public PlayMakerFSM[] activateOnCall;

	private Transform _player;

	private float _nextAttack;

	private float _lastPathSet;

	private bool _hasRaged;

	private void Start()
	{
		_player = Player.Instance.transform;
	}

	private void OnEnable()
	{
		_hasRaged = false;
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		if (fsm.ActiveStateName != "Attacking")
		{
			agent.updateRotation = true;
			base.enabled = false;
			_hasRaged = false;
			return;
		}
		if (animator.GetCurrentAnimatorStateInfo(0).shortNameHash == MobAI.ATTACK || animator.GetCurrentAnimatorStateInfo(0).shortNameHash == MobAI.RAGE || animator.GetCurrentAnimatorStateInfo(0).shortNameHash == MobAI.DAMAGED)
		{
			animator.SetFloat(MobAI.SPEED, 0f, 0.1f, Time.deltaTime);
			animator.SetFloat(MobAI.ROTATION, 0f, 0.1f, Time.deltaTime);
			return;
		}
		Vector3 vector = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
		float magnitude = vector.magnitude;
		if (magnitude > attackingDistance)
		{
			navMeshMob.setAnimationParams = true;
			if (!(Time.time < _lastPathSet + 0.25f))
			{
				agent.SetDestination(_player.position);
				agent.updateRotation = true;
				_lastPathSet = Time.time;
			}
			return;
		}
		navMeshMob.setAnimationParams = false;
		agent.updateRotation = false;
		float num = Vector3.SignedAngle(base.transform.forward, vector, base.transform.up);
		if (Mathf.Abs(num) > attackingAngle)
		{
			animator.SetFloat(MobAI.ROTATION, num / 45f, 0.4f, Time.deltaTime);
			base.transform.rotation = Quaternion.LookRotation(Vector3.RotateTowards(base.transform.forward, vector, (float)Math.PI * agent.angularSpeed / 180f * Time.deltaTime, 0f), Vector3.up);
		}
		else
		{
			animator.SetFloat(MobAI.ROTATION, 0f, 0.2f, Time.deltaTime);
		}
		float value;
		if (Time.time >= _nextAttack)
		{
			animator.SetTrigger(MobAI.ATTACK);
			_nextAttack = Time.time + (float)attackInterval;
			value = 0f;
		}
		else if (magnitude < backUpDistance)
		{
			agent.nextPosition = base.transform.position - base.transform.forward * agent.speed / 2f * Time.deltaTime;
			value = -0.5f;
		}
		else
		{
			value = 1f;
		}
		animator.SetFloat(MobAI.SPEED, value, 0.2f, Time.deltaTime);
	}

	public void CheckCall()
	{
		if (!_hasRaged && activateOnCall.Length != 0)
		{
			animator.SetTrigger(MobAI.RAGE);
		}
		else
		{
			fsm.SendEvent("Attack");
		}
	}

	public void Call()
	{
		_hasRaged = true;
		if (activateOnCall.Length == 0)
		{
			return;
		}
		activateOnCall[0].SendEvent("Activate");
		if (Settings.Current.difficulty != Difficulty.Easy)
		{
			for (int i = 1; i < activateOnCall.Length; i++)
			{
				activateOnCall[i].SendEvent("Activate");
			}
		}
		else
		{
			for (int j = 1; j < activateOnCall.Length; j++)
			{
				activateOnCall[j].gameObject.SetActive(value: false);
			}
		}
	}
}
public class Dragon : MonoBehaviour
{
	public Animator animator;

	public PlayMakerFSM fsm;

	public ParticleSystem fireBreath;

	public AudioSource[] fireSounds;

	public Transform head;

	public Transform lClavicle;

	public bool clavicleHack;

	public Rect bounds;

	public float threshold;

	public float lerpRate;

	public float chanceOfAttackAnimation;

	public float headLerpTime;

	private bool _hasTarget;

	private Vector3 _target;

	private Vector3 _movement;

	private float _nextMove;

	private Transform _player;

	private float _attackTime;

	private void Start()
	{
		_player = Player.Instance.transform;
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Combine(onPlayerRespawn.OnTrue, new System.Action(OnPlayerRespawn));
	}

	private void OnDestroy()
	{
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Remove(onPlayerRespawn.OnTrue, new System.Action(OnPlayerRespawn));
	}

	private void OnPlayerRespawn()
	{
		if (fsm.ActiveStateName != "Finished")
		{
			base.gameObject.SetActive(value: false);
			fsm.SetState("Walking");
			base.gameObject.SetActive(value: true);
		}
	}

	private void Update()
	{
		if (fsm.ActiveStateName == "Walking" || fsm.ActiveStateName == "Walk To Center")
		{
			if (fireBreath.isPlaying)
			{
				_attackTime = headLerpTime;
				fireBreath.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmitting);
				for (int i = 0; i < fireSounds.Length; i++)
				{
					fireSounds[i].FadeOut(0.5f);
				}
			}
			if (fsm.ActiveStateName == "Walk To Center")
			{
				_hasTarget = true;
				_target = new Vector3(bounds.center.x, base.transform.position.y, bounds.center.y);
			}
			else if (!_hasTarget && _nextMove <= Time.time)
			{
				if (UnityEngine.Random.value <= chanceOfAttackAnimation)
				{
					_nextMove += UnityEngine.Random.Range(2f, 3f);
					switch (UnityEngine.Random.Range(0, 9))
					{
					case 0:
						animator.SetTrigger("SpinLeft");
						break;
					case 1:
						animator.SetTrigger("SpinRight");
						break;
					case 2:
						animator.SetTrigger("BiteLeft");
						break;
					case 3:
						animator.SetTrigger("BiteRight");
						break;
					case 4:
						animator.SetTrigger("BiteFront");
						break;
					case 5:
						animator.SetTrigger("PunchLeft");
						break;
					case 6:
						animator.SetTrigger("PunchRight");
						break;
					case 7:
						animator.SetTrigger("Roar1");
						break;
					case 8:
						animator.SetTrigger("Roar2");
						break;
					}
				}
				else
				{
					_hasTarget = true;
					_target = new Vector3(bounds.x + UnityEngine.Random.Range(0f, bounds.width), base.transform.position.y, bounds.y + UnityEngine.Random.Range(0f, bounds.height));
				}
			}
			Vector3 b = (_hasTarget ? base.transform.InverseTransformPoint(_target).normalized : Vector3.zero);
			_movement = Vector3.Lerp(_movement, b, lerpRate * Time.deltaTime);
			if (_hasTarget && Vector3.Distance(base.transform.position, _target) < threshold)
			{
				_hasTarget = false;
				_nextMove = Time.time + UnityEngine.Random.Range(0f, 1.5f);
			}
			animator.SetFloat("Turn", _movement.x);
			animator.SetFloat("Walk", _movement.z);
		}
		else
		{
			_hasTarget = false;
			_movement = Vector3.zero;
			if (fsm.ActiveStateName == "Attacking")
			{
				if (!fireBreath.isPlaying)
				{
					fireBreath.Play();
					for (int j = 0; j < fireSounds.Length; j++)
					{
						fireSounds[j].FadeIn(0.5f, 1f, 2.5f);
					}
				}
				_attackTime += Time.deltaTime;
				head.rotation = Quaternion.Lerp(head.rotation, Quaternion.LookRotation(_player.position - head.position, -head.right) * Quaternion.Euler(180f, 90f, 90f), _attackTime / headLerpTime);
			}
			if (clavicleHack)
			{
				AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(0);
				AnimatorTransitionInfo animatorTransitionInfo = animator.GetAnimatorTransitionInfo(0);
				if (currentAnimatorStateInfo.IsName("FireBreathloop") || currentAnimatorStateInfo.IsName("FireBreathEnd") || animatorTransitionInfo.IsName("FireBreathEnd"))
				{
					lClavicle.localPosition = new Vector3(0.15664311f, -0.012461395f, 0.13906328f);
					lClavicle.localRotation = Quaternion.Euler(-14.578f, -109.977f, 145.213f);
				}
			}
		}
		if (fsm.ActiveStateName != "Attacking" && _attackTime > 0f)
		{
			_attackTime -= Time.deltaTime;
			head.rotation = Quaternion.Lerp(head.rotation, Quaternion.LookRotation(_player.position - head.position, -head.right) * Quaternion.Euler(180f, 90f, 90f), _attackTime / headLerpTime);
		}
	}
}
public class DragonFootsteps : MonoBehaviour
{
	public AudioSource[] audioSources;

	public float resetHeight;

	public float playHeight;

	private int _nextSource;

	private bool _canPlay;

	private void Update()
	{
		float y = base.transform.position.y;
		if (_canPlay)
		{
			if (y <= playHeight && !audioSources[_nextSource].isPlaying)
			{
				audioSources[_nextSource].Play();
				_canPlay = false;
				_nextSource = (_nextSource + 1) % audioSources.Length;
			}
		}
		else if (y >= resetHeight)
		{
			_canPlay = true;
		}
	}
}
public class FlyingWorm : NavMobAI
{
	public float backUpDistance;

	public float attackingDistance;

	public float attackingAngle;

	public FloatReference attackInterval;

	private Transform _player;

	private float _nextAttack;

	private float _lastPathSet;

	private void Start()
	{
		_player = Player.Instance.transform;
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		switch (fsm.ActiveStateName)
		{
		case "Melee":
		{
			Vector3 to = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
			float magnitude = to.magnitude;
			if (magnitude > attackingDistance)
			{
				navMeshMob.setAnimationParams = true;
				if (!(Time.time < _lastPathSet + 0.25f))
				{
					agent.SetDestination(_player.position);
					_lastPathSet = Time.time;
				}
				break;
			}
			navMeshMob.setAnimationParams = false;
			if (Mathf.Abs(Vector3.SignedAngle(base.transform.forward, to, base.transform.up)) > attackingAngle)
			{
				animator.SetFloat(MobAI.SPEED, 0f, 0.1f, Time.deltaTime);
			}
			else if (magnitude < backUpDistance)
			{
				agent.nextPosition = base.transform.position - base.transform.forward * agent.speed / 4f * Time.deltaTime;
				animator.SetFloat(MobAI.SPEED, 0f - (backUpDistance - magnitude));
			}
			else if (Time.time >= _nextAttack)
			{
				animator.SetTrigger((UnityEngine.Random.Range(0, 2) == 0) ? MobAI.BITE : MobAI.TAILWHIP);
				_nextAttack = Time.time + (float)attackInterval;
			}
			break;
		}
		case "Searching":
			if (!agent.hasPath)
			{
				agent.SetDestination(_player.position);
				base.enabled = false;
			}
			break;
		default:
			base.enabled = false;
			break;
		case "Ranged":
			break;
		}
	}
}
public class HealthBar : MonoBehaviour
{
	public GameObject[] bars;

	private void Start()
	{
		GameEvent onLoadNewProfile = References.OnLoadNewProfile;
		onLoadNewProfile.OnTrue = (System.Action)Delegate.Combine(onLoadNewProfile.OnTrue, new System.Action(UpdateIcons));
		GameEvent onGameLoaded = References.OnGameLoaded;
		onGameLoaded.OnTrue = (System.Action)Delegate.Combine(onGameLoaded.OnTrue, new System.Action(UpdateIcons));
		GameEvent onPlayerHealed = References.OnPlayerHealed;
		onPlayerHealed.OnTrue = (System.Action)Delegate.Combine(onPlayerHealed.OnTrue, new System.Action(UpdateIcons));
		GameEvent onPlayerDamaged = References.OnPlayerDamaged;
		onPlayerDamaged.OnTrue = (System.Action)Delegate.Combine(onPlayerDamaged.OnTrue, new System.Action(UpdateIcons));
	}

	private void OnDestroy()
	{
		if (References.IsInitialized)
		{
			GameEvent onLoadNewProfile = References.OnLoadNewProfile;
			onLoadNewProfile.OnTrue = (System.Action)Delegate.Remove(onLoadNewProfile.OnTrue, new System.Action(UpdateIcons));
			GameEvent onGameLoaded = References.OnGameLoaded;
			onGameLoaded.OnTrue = (System.Action)Delegate.Remove(onGameLoaded.OnTrue, new System.Action(UpdateIcons));
			GameEvent onPlayerHealed = References.OnPlayerHealed;
			onPlayerHealed.OnTrue = (System.Action)Delegate.Remove(onPlayerHealed.OnTrue, new System.Action(UpdateIcons));
			GameEvent onPlayerDamaged = References.OnPlayerDamaged;
			onPlayerDamaged.OnTrue = (System.Action)Delegate.Remove(onPlayerDamaged.OnTrue, new System.Action(UpdateIcons));
		}
	}

	public void UpdateIcons()
	{
		for (int i = 0; i < 5; i++)
		{
			bars[i].SetActive(Player.Instance.HP > i * 2);
		}
	}
}
public class InvisibleMob : NavMobAI
{
	public float backUpDistance;

	public float attackingDistance;

	public float attackingAngle;

	public Renderer renderer;

	public GameObject meshObject;

	private CoroutineHandle _handle;

	private Transform _player;

	private float _lastPathSet;

	private FsmFloat _dissolveAmount;

	private void Start()
	{
		_player = Player.Instance.transform;
		_dissolveAmount = fsm.FsmVariables.FindFsmFloat("DissolveAmount");
	}

	private void OnEnable()
	{
		GameEvent odinView = References.OdinView;
		odinView.OnTrue = (System.Action)Delegate.Combine(odinView.OnTrue, new System.Action(ToHidden));
		GameEvent odinView2 = References.OdinView;
		odinView2.OnFalse = (System.Action)Delegate.Combine(odinView2.OnFalse, new System.Action(ToNormal));
	}

	private void OnDisable()
	{
		GameEvent odinView = References.OdinView;
		odinView.OnTrue = (System.Action)Delegate.Remove(odinView.OnTrue, new System.Action(ToHidden));
		GameEvent odinView2 = References.OdinView;
		odinView2.OnFalse = (System.Action)Delegate.Remove(odinView2.OnFalse, new System.Action(ToNormal));
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		renderer.material.SetFloat("_DisintegrateAmount", (meshObject.layer == 22) ? 0f : Mathf.Clamp01(_dissolveAmount.Value));
		switch (fsm.ActiveStateName)
		{
		case "Chasing":
		{
			Vector3 vector = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
			float magnitude = vector.magnitude;
			if (magnitude > attackingDistance)
			{
				navMeshMob.setAnimationParams = true;
				if (!(Time.time < _lastPathSet + 0.25f))
				{
					agent.SetDestination(_player.position);
					agent.updateRotation = true;
					_lastPathSet = Time.time;
				}
				break;
			}
			navMeshMob.setAnimationParams = false;
			agent.updateRotation = false;
			animator.SetFloat(MobAI.SPEED, 0f, 0.1f, Time.deltaTime);
			float num = Vector3.SignedAngle(base.transform.forward, vector, base.transform.up);
			if (Mathf.Abs(num) > attackingAngle)
			{
				animator.SetFloat(MobAI.ROTATION, num, 0.1f, Time.deltaTime);
				base.transform.rotation = Quaternion.LookRotation(Vector3.RotateTowards(base.transform.forward, vector, (float)Math.PI * agent.angularSpeed / 180f * Time.deltaTime, 0f), Vector3.up);
				break;
			}
			animator.SetFloat(MobAI.ROTATION, 0f, 0.1f, Time.deltaTime);
			if (magnitude < backUpDistance)
			{
				agent.nextPosition = base.transform.position - base.transform.forward * agent.speed / 2f * Time.deltaTime;
				animator.SetFloat(MobAI.SPEED, -0.5f, 0.1f, Time.deltaTime);
			}
			else
			{
				fsm.SendEvent("Attack");
				animator.SetTrigger(MobAI.ATTACK);
			}
			break;
		}
		default:
			base.enabled = false;
			break;
		case "Damaged":
			break;
		}
	}

	private void ToHidden()
	{
		meshObject.layer = 22;
	}

	private void ToNormal()
	{
		meshObject.layer = 20;
	}

	private IEnumerator<float> RemoveDissolve()
	{
		while (!navMeshMob.IsDestroyed())
		{
			renderer.material.SetFloat("_DisintegrateAmount", 0f);
			yield return float.NegativeInfinity;
		}
	}
}
[SelectionBase]
public class Mob : MonoBehaviour, IDamageable, IHealable, ISaveSerializable, IGameObjectPoolable, ITargetable
{
	public IntReference maxHP;

	public int HP;

	[EnumFlags]
	public DamageType resistances;

	[EnumFlags]
	public DamageType immunities;

	[EnumFlags]
	public DamageType weaknesses;

	[EnumFlags]
	public DamageType absorbs;

	public PlayMakerFSM FSM;

	public string damagePlaymakerEvent = "Damage";

	public string diePlaymakerEvent = "Die";

	public float despawnTime = 5f;

	public Action<Mob> OnDespawned;

	[HideInInspector]
	public bool isDespawning;

	private int _maxHP;

	private CoroutineHandle _despawnHandle;

	public GameObjectRuntimePool Pool { get; set; }

	public virtual void OnValidate()
	{
		if (FSM == null)
		{
			FSM = GetComponent<PlayMakerFSM>();
		}
	}

	public void Start()
	{
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Combine(difficultyChanged.OnTrue, new System.Action(DifficultyChanged));
		OnEnable();
		OnStart();
	}

	public virtual void OnEnable()
	{
		_maxHP = maxHP;
		if (HP <= 0)
		{
			HP = _maxHP;
		}
	}

	private void OnDestroy()
	{
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Remove(difficultyChanged.OnTrue, new System.Action(DifficultyChanged));
		CombatTracker.Disengage(this);
	}

	public virtual void OnStart()
	{
	}

	public virtual void DifficultyChanged()
	{
		SetPercentHP(GetPercentHP());
	}

	public IDamageable GetTarget()
	{
		return this;
	}

	public virtual void ApplyDamage(int amount, string source, DamageType type = DamageType.None)
	{
		if ((immunities & type) == 0 && HP > 0)
		{
			if ((resistances & type) != 0)
			{
				amount /= 2;
			}
			if ((weaknesses & type) != 0)
			{
				amount *= 2;
			}
			if ((absorbs & type) != 0)
			{
				amount = -amount;
			}
			HP -= amount;
			if (HP <= 0)
			{
				Die(type);
			}
			else if (amount > 0)
			{
				Damage();
				OnDamaged(amount, type);
			}
		}
	}

	public virtual void ApplyHealing(int amount)
	{
		HP += amount;
		if (HP > _maxHP)
		{
			HP = _maxHP;
		}
	}

	protected virtual void OnDamaged(int amount, DamageType type)
	{
	}

	public bool IsDestroyed()
	{
		return HP <= 0;
	}

	protected void Damage()
	{
		if (FSM != null && !string.IsNullOrEmpty(damagePlaymakerEvent))
		{
			FSM.SendEvent(damagePlaymakerEvent);
		}
	}

	public virtual void Die(DamageType type)
	{
		if (FSM != null && !string.IsNullOrEmpty(diePlaymakerEvent))
		{
			FSM.SendEvent(diePlaymakerEvent);
		}
		_despawnHandle = Timing.RunCoroutine(Despawn().CancelWith(base.gameObject));
		isDespawning = true;
		CombatTracker.Disengage(this);
		Player.Instance.AddKill();
	}

	public void CancelDespawn()
	{
		Timing.KillCoroutines(_despawnHandle);
	}

	public virtual IEnumerator<float> Despawn()
	{
		yield return Timing.WaitForSeconds(despawnTime);
		HP = _maxHP;
		if (Pool != null)
		{
			if (FSM != null)
			{
				FSM.Reset();
			}
			Pool.ReturnToPool(base.gameObject);
		}
		else
		{
			base.gameObject.SetActive(value: false);
		}
		if (OnDespawned != null)
		{
			OnDespawned(this);
		}
		isDespawning = false;
	}

	public virtual ISaveData Serialize()
	{
		return Serialize<MobData>();
	}

	protected T Serialize<T>() where T : ISaveData, new()
	{
		T result = new T();
		result.Serialize(this);
		return result;
	}

	public virtual void Deserialize(ISaveData mobData)
	{
		mobData.Deserialize(this);
	}

	public virtual string SerializeString()
	{
		return JsonUtility.ToJson((MobData)Serialize());
	}

	public virtual void Deserialize(string saveData)
	{
		JsonUtility.FromJson<MobData>(saveData).Deserialize(this);
	}

	public virtual bool IsTargetable()
	{
		if (base.gameObject.activeInHierarchy)
		{
			return !IsDestroyed();
		}
		return false;
	}

	public float GetPercentHP()
	{
		if (_maxHP == 0)
		{
			_maxHP = maxHP;
		}
		return (float)HP / (float)_maxHP;
	}

	public void SetPercentHP(float percent)
	{
		HP = Mathf.RoundToInt(percent * (float)_maxHP);
	}
}
[Serializable]
public class MobData : ISaveData
{
	[SerializeField]
	private bool _isActive;

	[SerializeField]
	private float _HP;

	[SerializeField]
	private FSMData _FSMdata;

	[SerializeField]
	private TransformSaveData _transformData;

	[SerializeField]
	private bool _isDespawning;

	public virtual void Serialize(ISaveSerializable target)
	{
		Mob mob = (Mob)target;
		_isActive = mob.gameObject.activeSelf;
		_transformData = new TransformSaveData(mob.transform);
		_HP = mob.GetPercentHP();
		if (mob.FSM != null)
		{
			_FSMdata = new FSMData(mob.FSM);
		}
		_isDespawning = mob.isDespawning;
	}

	public virtual void Deserialize(ISaveSerializable target)
	{
		Mob mob = (Mob)target;
		if (mob.isDespawning)
		{
			mob.CancelDespawn();
			mob.gameObject.SetActive(value: false);
		}
		_transformData.Deserialize(mob.transform);
		mob.SetPercentHP(_HP);
		mob.gameObject.SetActive(_isActive);
		if (mob.FSM != null && _FSMdata != null)
		{
			_FSMdata.Deserialize(mob.FSM);
		}
		mob.isDespawning = _isDespawning;
		if (_isDespawning)
		{
			Timing.RunCoroutine(mob.Despawn().CancelWith(mob.gameObject));
		}
	}
}
public abstract class MobAI : MonoBehaviour
{
	public Animator animator;

	public PlayMakerFSM fsm;

	private static int _ATTACK = -1;

	private static int _BITE = -1;

	private static int _DAMAGED = -1;

	private static int _JUMP = -1;

	private static int _RAGE = -1;

	private static int _ROTATION = -1;

	private static int _SPEED = -1;

	private static int _TAILWHIP = -1;

	private static int _WEB = -1;

	protected static int ATTACK
	{
		get
		{
			if (_ATTACK == -1)
			{
				_ATTACK = Animator.StringToHash("Attack");
			}
			return _ATTACK;
		}
	}

	protected static int BITE
	{
		get
		{
			if (_BITE == -1)
			{
				_BITE = Animator.StringToHash("Bite");
			}
			return _BITE;
		}
	}

	protected static int DAMAGED
	{
		get
		{
			if (_DAMAGED == -1)
			{
				_DAMAGED = Animator.StringToHash("Damaged");
			}
			return _DAMAGED;
		}
	}

	protected static int JUMP
	{
		get
		{
			if (_JUMP == -1)
			{
				_JUMP = Animator.StringToHash("Jump");
			}
			return _JUMP;
		}
	}

	protected static int RAGE
	{
		get
		{
			if (_RAGE == -1)
			{
				_RAGE = Animator.StringToHash("Rage");
			}
			return _RAGE;
		}
	}

	protected static int ROTATION
	{
		get
		{
			if (_ROTATION == -1)
			{
				_ROTATION = Animator.StringToHash("Rotation");
			}
			return _ROTATION;
		}
	}

	protected static int SPEED
	{
		get
		{
			if (_SPEED == -1)
			{
				_SPEED = Animator.StringToHash("Speed");
			}
			return _SPEED;
		}
	}

	protected static int TAILWHIP
	{
		get
		{
			if (_TAILWHIP == -1)
			{
				_TAILWHIP = Animator.StringToHash("Tailwhip");
			}
			return _TAILWHIP;
		}
	}

	protected static int WEB
	{
		get
		{
			if (_WEB == -1)
			{
				_WEB = Animator.StringToHash("Web");
			}
			return _WEB;
		}
	}
}
public abstract class NavMobAI : MobAI
{
	public NavMeshAgent agent;

	public NavMeshMob navMeshMob;
}
public class MobSpawner : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	public class MobSpawnerSaveData : ISaveData
	{
		[SerializeField]
		private bool _active;

		[SerializeField]
		private int _totalCount;

		[SerializeField]
		private int _currentCount;

		public void Serialize(ISaveSerializable target)
		{
			MobSpawner mobSpawner = (MobSpawner)target;
			_totalCount = mobSpawner._totalSpawned;
			_currentCount = mobSpawner._currentlySpawned;
			_active = mobSpawner.gameObject.activeSelf;
		}

		public void Deserialize(ISaveSerializable target)
		{
			MobSpawner mobSpawner = (MobSpawner)target;
			mobSpawner._totalSpawned = _totalCount;
			mobSpawner._currentlySpawned = _currentCount;
			Timing.KillCoroutines(mobSpawner._handle);
			if (mobSpawner.gameObject.activeInHierarchy && _active)
			{
				mobSpawner.OnEnable();
			}
			else
			{
				mobSpawner.gameObject.SetActive(_active);
			}
		}
	}

	[UnityEngine.Tooltip("The total number of mobs this spawner will generate throughout its lifetime. Set to -1 for unlimited.")]
	public IntReference spawnLimit;

	[UnityEngine.Tooltip("How long to wait after being enabled before spawning the first mob")]
	public FloatReference spawnDelayBeforeFirst;

	[UnityEngine.Tooltip("How long to wait after a mob despawns before spawning the next one. Mobs that are killed while one is waiting to spawn will not trigger a new spawn until after the earlier one completes.")]
	public FloatReference spawnDelay;

	[UnityEngine.Tooltip("How long to wait between spawns during the first wave (up until all mobs in the list have been activated once)")]
	public FloatReference spawnDelayDuringFirstWave;

	public List<NavMeshMob> mobs;

	public List<WaypointPath> paths;

	public List<GameObject> spawnLocations;

	public bool randomizeSpawnLocation = true;

	[UnityEngine.Tooltip("Sends the Activate event to the FSM on the mob when they are spawned")]
	public bool activateWhenLoaded;

	public PlayMakerFSM FSM;

	[UnityEngine.Tooltip("Sends this event to the linked FSM when all mobs have been despawned")]
	public string eventOnMobsCleared;

	private int _totalSpawned;

	private int _currentlySpawned;

	private CoroutineHandle _handle;

	private static NavMeshMob _mob;

	private int _nextSpawnLocation;

	public bool HasMobsRemaining
	{
		get
		{
			for (int i = 0; i < mobs.Count; i++)
			{
				if (mobs[i].isActiveAndEnabled && !mobs[i].IsDestroyed())
				{
					return true;
				}
			}
			if (_totalSpawned >= (int)spawnLimit)
			{
				return (int)spawnLimit == -1;
			}
			return true;
		}
	}

	public bool CanSpawnMore
	{
		get
		{
			if (_totalSpawned < (int)spawnLimit || (int)spawnLimit == -1)
			{
				return _currentlySpawned < mobs.Count;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		for (int i = 0; i < mobs.Count; i++)
		{
			NavMeshMob navMeshMob = mobs[i];
			navMeshMob.OnDespawned = (Action<Mob>)Delegate.Remove(navMeshMob.OnDespawned, new Action<Mob>(OnMobDespawned));
			NavMeshMob navMeshMob2 = mobs[i];
			navMeshMob2.OnDespawned = (Action<Mob>)Delegate.Combine(navMeshMob2.OnDespawned, new Action<Mob>(OnMobDespawned));
		}
		if ((float)spawnDelayBeforeFirst > 0f)
		{
			_handle = Timing.CallDelayed(spawnDelayBeforeFirst, SpawnNext);
		}
		else
		{
			SpawnNext();
		}
	}

	private void OnDestroy()
	{
		for (int i = 0; i < mobs.Count; i++)
		{
			if (mobs[i] != null)
			{
				NavMeshMob navMeshMob = mobs[i];
				navMeshMob.OnDespawned = (Action<Mob>)Delegate.Remove(navMeshMob.OnDespawned, new Action<Mob>(OnMobDespawned));
			}
		}
	}

	private void SpawnNext()
	{
		if (!CanSpawnMore)
		{
			return;
		}
		_mob = GetNextAvailableMob();
		if (_mob == null)
		{
			return;
		}
		Transform spawnLocation = GetSpawnLocation();
		_mob.transform.position = spawnLocation.position;
		_mob.transform.rotation = spawnLocation.rotation;
		_mob.gameObject.SetActive(value: true);
		if (paths.Count > 0)
		{
			_mob.FSM.FsmVariables.GetFsmObject("WaypointPath").Value = paths[_totalSpawned % paths.Count];
		}
		_mob.FSM.SetState("Spawn");
		if (activateWhenLoaded)
		{
			Timing.CallDelayed(float.NegativeInfinity, delegate
			{
				_mob.FSM.SendEvent("Activate");
			});
		}
		_totalSpawned++;
		_currentlySpawned++;
		if (CanSpawnMore)
		{
			_handle = Timing.CallDelayed((_totalSpawned >= mobs.Count) ? spawnDelay : spawnDelayDuringFirstWave, SpawnNext);
		}
	}

	private NavMeshMob GetNextAvailableMob()
	{
		for (int i = 0; i < mobs.Count; i++)
		{
			if (mobs[i] == null)
			{
				return null;
			}
			if (!mobs[i].gameObject.activeSelf)
			{
				return mobs[i];
			}
		}
		return null;
	}

	private Transform GetSpawnLocation()
	{
		if (spawnLocations.Count == 0)
		{
			return base.transform;
		}
		if (randomizeSpawnLocation)
		{
			return spawnLocations[UnityEngine.Random.Range(0, spawnLocations.Count)].transform;
		}
		Transform result = spawnLocations[_nextSpawnLocation].transform;
		_nextSpawnLocation = (_nextSpawnLocation + 1) % spawnLocations.Count;
		return result;
	}

	private void OnMobDespawned(Mob mob)
	{
		_currentlySpawned--;
		if (CanSpawnMore)
		{
			if (!_handle.IsRunning)
			{
				_handle = Timing.CallDelayed(spawnDelay, SpawnNext);
			}
		}
		else if (_currentlySpawned == 0 && FSM != null && !string.IsNullOrEmpty(eventOnMobsCleared))
		{
			FSM.SendEvent(eventOnMobsCleared);
		}
	}

	public ISaveData Serialize()
	{
		MobSpawnerSaveData mobSpawnerSaveData = new MobSpawnerSaveData();
		mobSpawnerSaveData.Serialize(this);
		return mobSpawnerSaveData;
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
		if (base.gameObject.activeInHierarchy)
		{
			OnEnable();
		}
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((MobSpawnerSaveData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<MobSpawnerSaveData>(saveData).Deserialize(this);
	}
}
[RequireComponent(typeof(NavMeshAgent))]
[RequireComponent(typeof(Animator))]
public class NavMeshMob : Mob
{
	public Animator anim;

	public NavMeshAgent agent;

	public bool matchSurfaceNormal;

	public bool setAnimationParams = true;

	public bool hasRotationAnimation = true;

	public float navMeshLinkSpeed;

	private Vector2 velocity = Vector2.zero;

	protected static int ROTATION;

	protected static int SPEED;

	private float _linkDistance;

	private float _linkProgress;

	public override void OnValidate()
	{
		base.OnValidate();
		if (agent == null)
		{
			agent = GetComponent<NavMeshAgent>();
		}
		if (anim == null)
		{
			anim = GetComponent<Animator>();
		}
	}

	public override void OnStart()
	{
		agent.updatePosition = false;
		if (ROTATION == 0)
		{
			ROTATION = Animator.StringToHash("Rotation");
		}
		if (SPEED == 0)
		{
			SPEED = Animator.StringToHash("Speed");
		}
	}

	public override void OnEnable()
	{
		base.OnEnable();
		agent.enabled = true;
	}

	public void OnDisable()
	{
		agent.enabled = false;
	}

	private void Update()
	{
		if (!agent.autoTraverseOffMeshLink && agent.isOnOffMeshLink)
		{
			if (_linkDistance == 0f)
			{
				_linkDistance = Vector3.Distance(agent.currentOffMeshLinkData.startPos, agent.currentOffMeshLinkData.endPos);
				agent.updateRotation = false;
			}
			_linkProgress += Time.deltaTime * navMeshLinkSpeed / _linkDistance;
			agent.nextPosition = Vector3.Lerp(agent.currentOffMeshLinkData.startPos, agent.currentOffMeshLinkData.endPos, _linkProgress);
			if (_linkProgress >= 1f)
			{
				agent.CompleteOffMeshLink();
				_linkDistance = 0f;
				_linkProgress = 0f;
				agent.updateRotation = true;
			}
		}
		if (setAnimationParams)
		{
			Vector3 rhs = agent.nextPosition - base.transform.position;
			float x = Vector3.Dot(base.transform.right, rhs);
			float y = Vector3.Dot(base.transform.forward, rhs);
			Vector2 vector = new Vector2(x, y);
			if (Time.deltaTime > 1E-05f)
			{
				velocity = vector / Time.deltaTime;
			}
			if (hasRotationAnimation)
			{
				anim.SetFloat(ROTATION, Mathf.Clamp(velocity.x * 8f, -45f, 45f));
			}
			anim.SetFloat(SPEED, Mathf.Clamp01(velocity.y), 0.1f, Time.deltaTime);
		}
	}

	private void LateUpdate()
	{
		base.transform.position = agent.nextPosition;
	}

	public override void Die(DamageType type)
	{
		base.Die(type);
		if (agent.hasPath)
		{
			agent.ResetPath();
		}
		agent.enabled = false;
	}

	public override ISaveData Serialize()
	{
		return Serialize<NavMeshMobData>();
	}

	public override string SerializeString()
	{
		return JsonUtility.ToJson((NavMeshMobData)Serialize());
	}

	public override void Deserialize(string saveData)
	{
		JsonUtility.FromJson<NavMeshMobData>(saveData).Deserialize(this);
	}
}
[Serializable]
public class NavMeshMobData : MobData
{
	[SerializeField]
	private Vector3? agentDestination;

	[SerializeField]
	private float _maxSpeed;

	[SerializeField]
	private float _maxAcceleration;

	[SerializeField]
	private bool _enabled;

	[SerializeField]
	private Vector3 _position;

	public override void Serialize(ISaveSerializable target)
	{
		base.Serialize(target);
		NavMeshAgent agent = ((NavMeshMob)target).agent;
		if (agent.hasPath)
		{
			agentDestination = agent.destination;
		}
		_maxSpeed = agent.speed;
		_maxAcceleration = agent.acceleration;
		_enabled = agent.enabled;
		_position = agent.transform.position;
	}

	public override void Deserialize(ISaveSerializable target)
	{
		NavMeshAgent agent = ((NavMeshMob)target).agent;
		agent.gameObject.SetActive(value: true);
		agent.Warp(_position);
		agent.enabled = false;
		base.Deserialize(target);
		agent.enabled = _enabled;
		if (agentDestination.HasValue)
		{
			agent.SetDestination(agentDestination.Value);
		}
		else if (agent.hasPath)
		{
			agent.ResetPath();
		}
		agent.speed = _maxSpeed;
		agent.acceleration = _maxAcceleration;
	}
}
public class Player : Mob
{
	public FloatReference maxTimeInWall;

	public FloatReference maxFallTime;

	public FloatReference minFallDistanceUntilDeath;

	public Transform playerFeet;

	public Transform playerSilhouette;

	public Transform headOffset;

	public Hand leftHand;

	public Hand rightHand;

	public CapsuleCollider collider;

	public CapsuleCollider hitCollider;

	public CameraColorOverlay damageOverlay;

	public CameraColorOverlay deathOverlay;

	public bool checkForFalling = true;

	public LayerMask fallColliderLayerMask;

	public float maxSpeed;

	public CharacterController characterController;

	public int shieldGems;

	public Difficulty lowestDifficulty = Difficulty.Normal;

	public Achievement creatureHunter;

	public int monsterKills;

	public SplineController splineController;

	public float splineAbsoluteSpeed;

	public float splineRelativeSpeed;

	public Vector3 headsetOffset;

	private bool _isDying;

	private bool _isGrounded = true;

	private bool _isFalling;

	private float _fallStart;

	private float _fallTime;

	private float _inWallTime;

	private Vector3 _moveInput;

	private CoroutineHandle _deathHandle;

	private bool _onSpline;

	private RaycastHit[] _raycastHitPool = new RaycastHit[20];

	public static Player Instance { get; private set; }

	public Transform Surface { get; private set; }

	public bool IsInValidLocation => !References.HeadColliderScript.IsInWall;

	private void Awake()
	{
		Instance = this;
		characterController.detectCollisions = false;
		characterController.enableOverlapRecovery = false;
		GameEvent odinViewTransition = References.OdinViewTransition;
		odinViewTransition.OnTrue = (System.Action)Delegate.Combine(odinViewTransition.OnTrue, new System.Action(OnOdinViewEnter));
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnTrue = (System.Action)Delegate.Combine(comfortModeChanged.OnTrue, new System.Action(OnSitMode));
		GameEvent comfortModeChanged2 = References.ComfortModeChanged;
		comfortModeChanged2.OnFalse = (System.Action)Delegate.Combine(comfortModeChanged2.OnFalse, new System.Action(OnStandMode));
		GameEvent onLoadNewProfile = References.OnLoadNewProfile;
		onLoadNewProfile.OnTrue = (System.Action)Delegate.Combine(onLoadNewProfile.OnTrue, new System.Action(OnLoad));
		_ = References.TrackingSpaceTransform.position;
	}

	private void OnDestroy()
	{
		if (References.IsInitialized)
		{
			GameEvent odinViewTransition = References.OdinViewTransition;
			odinViewTransition.OnTrue = (System.Action)Delegate.Remove(odinViewTransition.OnTrue, new System.Action(OnOdinViewEnter));
			GameEvent comfortModeChanged = References.ComfortModeChanged;
			comfortModeChanged.OnTrue = (System.Action)Delegate.Remove(comfortModeChanged.OnTrue, new System.Action(OnSitMode));
			GameEvent comfortModeChanged2 = References.ComfortModeChanged;
			comfortModeChanged2.OnFalse = (System.Action)Delegate.Remove(comfortModeChanged2.OnFalse, new System.Action(OnStandMode));
			GameEvent onLoadNewProfile = References.OnLoadNewProfile;
			onLoadNewProfile.OnTrue = (System.Action)Delegate.Remove(onLoadNewProfile.OnTrue, new System.Action(OnLoad));
		}
	}

	private void Update()
	{
		if (HP <= 0 || VRSystem.IsPaused || MenuManager.IsInMenu)
		{
			return;
		}
		Vector3 areaPos = References.TrackingSpaceTransform.position;
		if (splineController != null && !_onSpline)
		{
			_onSpline = true;
			Timing.RunCoroutine(SplineCalculator());
		}
		if (References.PlayerInterfaceLock.IsLocked())
		{
			return;
		}
		if (checkForFalling && !References.PlayerFallLock.IsLocked())
		{
			Vector3 vector = maxSpeed * _moveInput * (References.HeadColliderScript.IsInWall ? Time.unscaledDeltaTime : Time.deltaTime);
			if (!_isGrounded && !References.HeadColliderScript.IsInWall)
			{
				vector += Physics.gravity * _fallTime * Time.deltaTime;
			}
			float y = areaPos.y;
			characterController.enabled = true;
			characterController.Move(vector);
			characterController.enabled = false;
			if (References.TrackingSpaceTransform.position.y <= y + characterController.stepOffset)
			{
				areaPos = References.TrackingSpaceTransform.position;
			}
			else
			{
				if (vector != Vector3.zero)
				{
					CalculatePlayerMovement(ref areaPos, vector);
				}
				References.TrackingSpaceTransform.position = areaPos;
				_moveInput = Vector3.zero;
			}
			if (References.HeadColliderScript.IsInWall)
			{
				_inWallTime += Time.unscaledDeltaTime;
				if (_inWallTime >= 0.2f)
				{
					Singleton<VRSystem>.Instance.SetTimeScale(0f);
				}
				if (_inWallTime >= (float)maxTimeInWall)
				{
					SetPositionAndRotation(References.HeadColliderScript.ReturnLocation.GetWorldPos(), References.HeadColliderScript.ReturnLocation.GetForward(), useHeadPosition: true);
				}
			}
			else if (!_isGrounded)
			{
				if (!_isFalling)
				{
					_isFalling = true;
					_fallStart = areaPos.y;
					_fallTime = 0f;
				}
				if (_fallTime >= (float)maxFallTime)
				{
					UnityEngine.Debug.Log("Player killed by fall time.");
					Die(DamageType.None);
				}
				else
				{
					Vector3 vector2 = characterController.transform.TransformPoint(characterController.center);
					Vector3 vector3 = Vector3.up * (characterController.height / 2f - characterController.radius);
					int num = Physics.SphereCastNonAlloc(vector2 + vector3, characterController.radius, Vector3.down, Utilities.raycastHitPool, vector3.magnitude * 2f, References.SolidLayers, QueryTriggerInteraction.Ignore);
					if (num > 0)
					{
						Utilities.raycastHitPool.SortByDist(num);
						for (int i = 0; i < num; i++)
						{
							Transform transform = Utilities.raycastHitPool[i].transform;
							if (!transform.IsChildOf(Singleton<VRSystem>.Instance.transform) && !transform.gameObject.TryGetComponent<Climbable>(out var _))
							{
								SetPosition(Utilities.raycastHitPool[i].point, useHeadPosition: false, setValid: false);
								_isFalling = false;
								if (_fallStart - Utilities.raycastHitPool[i].point.y >= (float)minFallDistanceUntilDeath && _fallTime > 0.1f)
								{
									UnityEngine.Debug.Log("Player killed by fall distance.");
									Die(DamageType.None);
								}
								break;
							}
						}
					}
				}
				_fallTime += Time.deltaTime;
			}
			else if (_isFalling)
			{
				_isFalling = false;
				if (_fallStart - areaPos.y >= (float)minFallDistanceUntilDeath && _fallTime > 0.1f)
				{
					UnityEngine.Debug.Log("Player killed by fall distance.");
					Die(DamageType.None);
				}
			}
		}
		else
		{
			_isFalling = false;
		}
		if (!_isFalling || References.HeadColliderScript.IsInWall)
		{
			_moveInput = Vector3.zero;
		}
		if (OdinView.IsViewingOrTransitioning() || TeleportRotateManager.IsDashTeleporting)
		{
			return;
		}
		UpdatePosition();
		if (Singleton<TrackingSpace>.Instance.IsClimbing)
		{
			return;
		}
		if (!References.HeadColliderScript.IsInWall)
		{
			_inWallTime = 0f;
			int num2 = Physics.SphereCastNonAlloc(playerFeet.position + Vector3.up * (characterController.stepOffset + characterController.radius + characterController.skinWidth), characterController.radius, Vector3.down, Utilities.raycastHitPool, (characterController.stepOffset + characterController.skinWidth) * 2f, fallColliderLayerMask, QueryTriggerInteraction.Ignore);
			_isGrounded = false;
			Surface = null;
			if (num2 > 0)
			{
				float num3 = areaPos.y - (characterController.stepOffset + characterController.radius);
				for (int j = 0; j < num2; j++)
				{
					RaycastHit raycastHit = Utilities.raycastHitPool[j];
					if (raycastHit.point.y > num3 && raycastHit.point != Vector3.zero && Vector3.Angle(raycastHit.normal, Vector3.up) <= characterController.slopeLimit && raycastHit.transform.GetComponentInParent<VRSystem>() == null)
					{
						num3 = raycastHit.point.y;
						_isGrounded = true;
						Surface = raycastHit.collider.transform;
					}
				}
				if (_isGrounded)
				{
					areaPos.y = num3 + characterController.skinWidth;
					References.TrackingSpaceTransform.position = areaPos;
				}
			}
		}
		References.TrackingSpace.SetSurface(Surface);
	}

	private void LateUpdate()
	{
		if (!OdinView.IsViewingOrTransitioning() && !VRSystem.IsPaused && !TeleportRotateManager.IsDashTeleporting)
		{
			UpdatePosition();
		}
	}

	private void UpdatePosition()
	{
		Vector3 position = References.TrackingSpaceTransform.position;
		headsetOffset = Vector3.ProjectOnPlane(References.Headset.up, Vector3.up) * 0.16f;
		base.transform.position = new Vector3(References.Headset.position.x, Mathf.Max(References.Headset.position.y - position.y, collider.radius * 2f) / 2f + position.y + characterController.skinWidth / 2f, References.Headset.position.z) - headsetOffset;
		collider.height = Mathf.Max(References.Headset.position.y - position.y + characterController.skinWidth, collider.radius * 2f);
		hitCollider.height = collider.height;
		characterController.height = collider.height - characterController.skinWidth * 2f;
		Vector3 center = characterController.transform.InverseTransformPoint(References.Headset.position - headsetOffset);
		center.y = collider.height / 2f;
		characterController.center = center;
		playerFeet.position = new Vector3(References.Headset.position.x, position.y - characterController.skinWidth, References.Headset.position.z) - headsetOffset;
	}

	private IEnumerator<float> SplineCalculator()
	{
		CurvySpline spline = splineController.Spline;
		while (splineController != null)
		{
			float absPos = splineController.AbsolutePosition;
			float relPos = splineController.RelativePosition;
			float time = Time.time;
			yield return Timing.WaitForSeconds(0.1f);
			if (splineController != null)
			{
				if (splineController.Spline == spline)
				{
					splineAbsoluteSpeed = (splineController.AbsolutePosition - absPos) / (Time.time - time);
					splineRelativeSpeed = (splineController.RelativePosition - relPos) / (Time.time - time);
				}
				else
				{
					spline = splineController.Spline;
				}
			}
		}
		_onSpline = false;
	}

	private void CalculatePlayerMovement(ref Vector3 areaPos, Vector3 v)
	{
		if (OdinView.IsViewingOrTransitioning() || Singleton<TrackingSpace>.Instance.IsClimbing)
		{
			return;
		}
		float num = v.magnitude;
		Vector3 normalized = v.normalized;
		float radius = characterController.radius;
		float num2 = radius + characterController.skinWidth;
		Vector3 vector = characterController.transform.TransformPoint(characterController.center);
		Vector3 vector2 = Vector3.up * (characterController.height / 2f - num2);
		Vector3 vector3 = new Vector3(0f, characterController.stepOffset, 0f);
		int num3 = Physics.CapsuleCastNonAlloc(vector - vector2, vector + vector2, radius, normalized, Utilities.raycastHitPool, num + characterController.skinWidth, fallColliderLayerMask, QueryTriggerInteraction.Ignore);
		Utilities.raycastHitPool.SortByDist(num3);
		for (int i = 0; i < num3; i++)
		{
			RaycastHit raycastHit = Utilities.raycastHitPool[i];
			if (Vector3.Angle(raycastHit.normal, Vector3.up) > 90f - characterController.slopeLimit)
			{
				num = raycastHit.distance - characterController.skinWidth;
				break;
			}
			int num4 = Physics.SphereCastNonAlloc(vector - vector2 + vector3 + normalized * num, radius, Vector3.down, _raycastHitPool, characterController.stepOffset + characterController.skinWidth, fallColliderLayerMask, QueryTriggerInteraction.Ignore);
			_raycastHitPool.SortByDist(num4);
			if (num4 > 0)
			{
				if (_raycastHitPool[0].distance > characterController.stepOffset)
				{
					num = raycastHit.distance - characterController.skinWidth;
					break;
				}
				areaPos.y = _raycastHitPool[0].point.y + characterController.skinWidth;
			}
		}
		areaPos += normalized * num;
		_moveInput = Vector3.zero;
	}

	public void InputMovement(Vector3 velocity)
	{
		if (!References.PlayerInterfaceLock.IsLocked() && !_isFalling && !References.PlayerMoveTeleportLock.IsLocked())
		{
			_moveInput += velocity + Vector3.down * 0.1f;
		}
	}

	public bool IsFalling()
	{
		return _isFalling;
	}

	public override void ApplyDamage(int amount, string source, DamageType type = DamageType.None)
	{
		if ((immunities & type) == 0 && HP > 0 && !_isDying)
		{
			if (Settings.Current.difficulty == Difficulty.Normal)
			{
				amount *= 2;
			}
			if (Settings.Current.difficulty == Difficulty.Hard)
			{
				amount *= 4;
			}
			if (HP > 0)
			{
				HP -= amount;
			}
			UnityEngine.Debug.Log($"Player damaged by {source} dealing {amount} points of {type} damage. New HP {HP}.");
			if (HP <= 0)
			{
				Die(type);
			}
			else if (amount > 0)
			{
				OnDamaged(amount, type);
			}
		}
	}

	protected override void OnDamaged(int amount, DamageType type = DamageType.None)
	{
		if (amount > 0)
		{
			damageOverlay.Blink();
			Haptics.Play(0.2f, 0.8f, 0.25f, rightHand: true);
			Haptics.Play(0.2f, 0.8f, 0.25f, rightHand: false);
			References.OnPlayerDamaged.RaiseTrue();
		}
	}

	public override void ApplyHealing(int amount)
	{
		if (!_isDying)
		{
			base.ApplyHealing(amount);
			References.OnPlayerHealed.RaiseTrue();
		}
	}

	public override void Die(DamageType type = DamageType.None)
	{
		if (!_isDying)
		{
			_isGrounded = true;
			_isFalling = false;
			_isDying = true;
			_fallTime = 0f;
			Haptics.Play(0.2f, 0.8f, 0.25f, rightHand: true);
			Haptics.Play(0.2f, 0.8f, 0.25f, rightHand: false);
			UnityEngine.Debug.Log("Player Died");
			References.OnPlayerDamaged.RaiseTrue();
			References.OnPlayerDeath.RaiseTrue();
			References.PlayerMoveTeleportLock.LockUsing(base.gameObject);
			References.SaveGameLock.LockUsing(base.gameObject);
			References.PlayerFallLock.LockUsing(base.gameObject);
			_deathHandle = Timing.RunCoroutineSingleton(DeathCoroutine(), _deathHandle, SingletonBehavior.Wait);
		}
	}

	private IEnumerator<float> DeathCoroutine()
	{
		damageOverlay.Blink();
		yield return Timing.WaitForSeconds(damageOverlay.AddDuration + damageOverlay.AppliedDuration);
		deathOverlay.Blink();
		yield return Timing.WaitForSeconds(deathOverlay.AddDuration);
		yield return Timing.WaitUntilDone(SaveSystem.LoadCheckpoint(), Segment.RealtimeUpdate);
		yield return float.NegativeInfinity;
		UnityEngine.Debug.Log("Player Respawn");
		References.OnPlayerRespawn.RaiseTrue();
		yield return Timing.WaitForSeconds(deathOverlay.AppliedDuration);
		while (HP <= 0)
		{
			HP = 10;
			yield return Timing.WaitUntilDone(SaveSystem.LoadCheckpoint(), Segment.RealtimeUpdate);
			yield return float.NegativeInfinity;
		}
		if (Settings.Current.difficulty == Difficulty.Easy)
		{
			ApplyHealing(1000);
		}
		_isDying = false;
		References.PlayerMoveTeleportLock.Unlock(base.gameObject);
		References.PlayerFallLock.Unlock(base.gameObject);
		References.SaveGameLock.UnlockAll();
	}

	public void AddKill()
	{
		monsterKills++;
		References.AchievementManager.UpdateAchievement(creatureHunter, monsterKills);
	}

	public override ISaveData Serialize()
	{
		return Serialize<PlayerData>();
	}

	public override string SerializeString()
	{
		return JsonUtility.ToJson((PlayerData)Serialize());
	}

	public override void Deserialize(string saveData)
	{
		JsonUtility.FromJson<PlayerData>(saveData).Deserialize(this);
	}

	private void OnOdinViewEnter()
	{
		if (playerSilhouette != null)
		{
			if (Vector3.Distance(Singleton<OdinView>.Instance.viewPosition.position, collider.ClosestPoint(Singleton<OdinView>.Instance.viewPosition.position)) >= 0.5f)
			{
				playerSilhouette.LookAt(playerSilhouette.position + Vector3.ProjectOnPlane(References.Headset.forward, Vector3.up));
				playerSilhouette.gameObject.SetActive(value: true);
			}
			else
			{
				playerSilhouette.gameObject.SetActive(value: false);
			}
		}
	}

	private void OnSitMode()
	{
		headOffset.localPosition = new Vector3(0f, Settings.Current.sitHeight, 0f);
	}

	private void OnStandMode()
	{
		headOffset.localPosition = Vector3.zero;
	}

	private void OnLoad()
	{
		Timing.KillCoroutines(_deathHandle);
		_isDying = false;
		damageOverlay.RemoveColorOverlay();
		deathOverlay.RemoveColorOverlay();
		CombatTracker.DisengageAll();
		References.OdinHintLock.UnlockAll();
		References.OdinVisionLock.UnlockAll();
		References.PlayerFallLock.UnlockAll();
		References.PlayerInterfaceLock.UnlockAll();
		References.PlayerMoveTeleportLock.UnlockAll();
		References.SaveGameLock.UnlockAll();
	}

	public void SetCollidersActive(bool active)
	{
		playerFeet.gameObject.SetActive(active);
		collider.enabled = active;
	}

	public void SetPosition(Transform matchTransform, bool useHeadPosition, bool setValid = true)
	{
		Timing.RunCoroutine(SetPos(matchTransform.position, useHeadPosition, setValid), Segment.EndOfFrame);
	}

	public void SetPosition(Vector3 position, bool useHeadPosition, bool setValid = true)
	{
		Timing.RunCoroutine(SetPos(position, useHeadPosition, setValid), Segment.EndOfFrame);
	}

	public void SetPositionAndRotation(Transform matchTransform, bool useHeadPosition, bool setValid = true)
	{
		SetPositionAndRotation(matchTransform.position, matchTransform.forward, useHeadPosition, setValid);
	}

	public void SetPositionAndRotation(Vector3 position, Vector3 forward, bool useHeadPosition, bool setValid = true)
	{
		Timing.RunCoroutine(SetPosRot(position, forward, useHeadPosition, setValid), Segment.EndOfFrame);
	}

	private IEnumerator<float> SetPosRot(Vector3 position, Vector3 forward, bool useHeadPosition, bool setValid)
	{
		float num = Vector3.Angle(References.Headset.forward, Vector3.down);
		Vector3 fromDirection = ((num < 0.01f) ? Vector3.ProjectOnPlane(References.Headset.up, Vector3.up) : ((!(num > 179.99f)) ? Vector3.ProjectOnPlane(References.Headset.forward, Vector3.up) : Vector3.ProjectOnPlane(-References.Headset.up, Vector3.up)));
		Quaternion quaternion = Quaternion.FromToRotation(fromDirection, Vector3.ProjectOnPlane(forward, Vector3.up));
		References.TrackingSpaceTransform.rotation *= quaternion;
		if (References.TrackingSpaceTransform.up != Vector3.up)
		{
			References.TrackingSpaceTransform.rotation = Quaternion.identity;
		}
		Vector3 vector = (useHeadPosition ? References.Headset.position : References.TrackingSpaceTransform.TransformPoint(characterController.center)) - References.TrackingSpaceTransform.position;
		vector.y = 0f;
		References.TrackingSpaceTransform.position = position - vector;
		if (setValid)
		{
			References.HeadColliderScript.SetValidLocation();
		}
		yield break;
	}

	private IEnumerator<float> SetPos(Vector3 position, bool useHeadPosition, bool setValid)
	{
		Vector3 vector = (useHeadPosition ? References.Headset.position : References.TrackingSpaceTransform.TransformPoint(characterController.center)) - References.TrackingSpaceTransform.position;
		vector.y = 0f;
		References.TrackingSpaceTransform.position = position - vector;
		if (setValid)
		{
			References.HeadColliderScript.SetValidLocation();
		}
		yield break;
	}

	public bool IsPositionValid(Vector3 position)
	{
		if (!Physics.CheckCapsule(position + (characterController.radius + characterController.skinWidth) * Vector3.up, position + (characterController.height - (characterController.radius + characterController.skinWidth)) * Vector3.up, 0.1f, References.HardSolidLayers, QueryTriggerInteraction.Ignore))
		{
			return !Physics.CheckSphere(position + new Vector3(0f, collider.height, 0f), 0.23f, References.HeadColliderScript.playerCollisionLayers, QueryTriggerInteraction.Ignore);
		}
		return false;
	}

	public bool IsPositionValid()
	{
		return IsPositionValid(base.transform.position);
	}

	public Vector3 GetHeadPosition()
	{
		Vector3 position = References.Headset.position;
		position.y = References.TrackingSpaceTransform.position.y;
		return position;
	}

	public Vector3 GetPosition()
	{
		Vector3 position = base.transform.position;
		position.y = References.TrackingSpaceTransform.position.y;
		return position;
	}

	public override bool IsTargetable()
	{
		return false;
	}
}
[Serializable]
public class PlayerData : ISaveData
{
	public Vector3 position;

	public Vector3 forward;

	public int HP;

	public int shieldGems;

	public Difficulty lowestDifficulty;

	public bool hasFire;

	public bool hasIce;

	public string activeElement;

	public bool hasShield;

	public int monsterKills;

	public void Serialize(ISaveSerializable target)
	{
		Player player = (Player)target;
		position = player.GetPosition();
		forward = References.Headset.forward;
		HP = player.HP;
		shieldGems = player.shieldGems;
		lowestDifficulty = player.lowestDifficulty;
		monsterKills = player.monsterKills;
		for (int i = 0; i < References.Wand.elements.Count; i++)
		{
			if (References.Wand.elements[i] == References.Fire)
			{
				hasFire = true;
			}
			else if (References.Wand.elements[i] == References.Ice)
			{
				hasIce = true;
			}
		}
		if (References.Wand.GetElement() != null)
		{
			activeElement = References.Wand.GetElement().name;
		}
		hasShield = References.Shield != null;
	}

	public void Deserialize(ISaveSerializable target)
	{
		Player obj = (Player)target;
		obj.HP = HP;
		obj.shieldGems = shieldGems;
		obj.lowestDifficulty = lowestDifficulty;
		obj.monsterKills = monsterKills;
		obj.splineController = null;
		obj.SetPositionAndRotation(position, forward, useHeadPosition: false);
		References.Wand.LoadElements(hasFire, hasIce, activeElement);
		if (hasShield)
		{
			Shield shield = ((References.Shield == null) ? ((Shield)References.Inventory.GetItem(References.ShieldItem)) : References.Shield);
			References.Inventory.shieldSlot.PlaceItem(shield, playSound: false);
			shield.ResetObject();
		}
		else if (References.Shield != null)
		{
			UnityEngine.Object.Destroy(References.Shield.gameObject);
		}
	}
}
public class PoisonMob : NavMobAI
{
	public Transform head;

	public FloatReference movementSpeed;

	public FloatReference attackInterval;

	public bool isStationary;

	private Transform _player;

	private float _nextAttack;

	private float _nextSightCheck;

	private void Start()
	{
		_player = Player.Instance.transform;
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Combine(difficultyChanged.OnTrue, new System.Action(OnDifficultyChange));
		OnDifficultyChange();
	}

	protected void OnDestroy()
	{
		GameEvent difficultyChanged = References.DifficultyChanged;
		difficultyChanged.OnTrue = (System.Action)Delegate.Remove(difficultyChanged.OnTrue, new System.Action(OnDifficultyChange));
	}

	private void OnDifficultyChange()
	{
		agent.speed = movementSpeed;
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		switch (fsm.ActiveStateName)
		{
		case "Searching":
			if (_nextSightCheck <= Time.time)
			{
				agent.ResetPath();
				if (head.HasClearPathToTarget(new Ray(head.position, _player.position - head.position), _player, Vector3.Distance(_player.position, head.position)) && _nextAttack <= Time.time)
				{
					fsm.SendEvent("Continue");
				}
				else
				{
					_nextSightCheck = Time.time + 0.1f;
				}
			}
			break;
		case "Attacking":
			animator.SetFloat(MobAI.SPEED, 0f, 0.1f, Time.deltaTime);
			if (_nextAttack <= Time.time)
			{
				_nextAttack = Time.time + (float)attackInterval;
				animator.SetTrigger(MobAI.ATTACK);
				agent.ResetPath();
				_nextSightCheck = Time.time + 2f;
			}
			else if (_nextSightCheck <= Time.time)
			{
				if (!isStationary && Vector3.Distance(_player.position, base.transform.position) > agent.stoppingDistance)
				{
					agent.SetDestination(_player.position);
					_nextSightCheck = _nextAttack;
				}
				fsm.SendEvent("Continue");
			}
			break;
		case "Face Player":
		{
			Vector3 vector = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
			float f = Vector3.SignedAngle(base.transform.forward, vector, base.transform.up);
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(vector, Vector3.up), agent.angularSpeed * Time.deltaTime);
			if (Mathf.Abs(f) <= 1f)
			{
				fsm.SendEvent("Attack");
			}
			break;
		}
		default:
			base.enabled = false;
			break;
		}
	}
}
public class Projectile : MonoBehaviour, IGameObjectPoolable
{
	public Rigidbody rigidbody;

	public SphereCollider collider;

	public bool shootOnEnable;

	public float Distance = 30f;

	public float Speed = 1f;

	public float TimeDelay;

	public LayerMask CollidesWith = -1;

	public GameObjectPool EffectsPoolOnCollision;

	public float CollisionOffset;

	public float LifespanAfterCollision = 5f;

	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public bool CollisionEffectInTargetSpace;

	public GameObject[] DeactivatedObjectsOnCollision;

	public DamageType damageType;

	public int damageAmount;

	public DamageTargets validTargets = DamageTargets.Player | DamageTargets.Enemies | DamageTargets.Objects;

	public Action<Collider> onCollision;

	private bool _hasCollided;

	private readonly HashSet<IDamageable> _hitTargets = new HashSet<IDamageable>();

	private readonly HashSet<Collider> _ignoredColliders = new HashSet<Collider>();

	private CoroutineHandle _handle;

	private bool _hasShot;

	public GameObjectRuntimePool Pool { get; set; }

	private void OnEnable()
	{
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Combine(onPlayerRespawn.OnTrue, new System.Action(ReturnToPool));
		if (shootOnEnable)
		{
			Shoot(base.transform.forward);
		}
	}

	private void OnDisable()
	{
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Remove(onPlayerRespawn.OnTrue, new System.Action(ReturnToPool));
		_hasShot = false;
		_hasCollided = false;
		foreach (Collider ignoredCollider in _ignoredColliders)
		{
			if (ignoredCollider != null)
			{
				Physics.IgnoreCollision(collider, ignoredCollider, ignore: false);
			}
		}
		_ignoredColliders.Clear();
		_hitTargets.Clear();
		rigidbody.velocity = Vector3.zero;
		rigidbody.constraints = RigidbodyConstraints.None;
		Timing.KillCoroutines(_handle);
	}

	private void ReturnToPool()
	{
		Pool.ReturnToPool(base.gameObject);
	}

	public void Shoot(Vector3 direction, float delay, float speed)
	{
		rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
		base.enabled = true;
		_handle = Timing.RunCoroutineSingleton(ShootRoutine(direction, delay, speed), _handle, SingletonBehavior.Overwrite);
	}

	public void Shoot(Vector3 direction)
	{
		rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
		base.enabled = true;
		_handle = Timing.RunCoroutineSingleton(ShootRoutine(direction, TimeDelay, Speed), _handle, SingletonBehavior.Overwrite);
	}

	public void IgnoreCollision(Collider obj)
	{
		Physics.IgnoreCollision(collider, obj, ignore: true);
		_ignoredColliders.Add(obj);
	}

	private IEnumerator<float> ShootRoutine(Vector3 direction, float delay, float speed)
	{
		float maxTime = Distance / speed;
		OnCollisionDeactivateBehaviour(active: true);
		if (delay > 0f)
		{
			yield return Timing.WaitForSeconds(delay);
		}
		else
		{
			yield return float.NegativeInfinity;
		}
		int num = Physics.OverlapSphereNonAlloc(base.transform.position, collider.radius, Utilities.colliderPool, CollidesWith, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < num; i++)
		{
			Physics.IgnoreCollision(collider, Utilities.colliderPool[i], ignore: true);
			_ignoredColliders.Add(Utilities.colliderPool[i]);
		}
		rigidbody.velocity = direction * speed;
		_hasShot = true;
		yield return Timing.WaitForSeconds(maxTime);
		if (!_hasCollided)
		{
			OnCollisionDeactivateBehaviour(active: false);
			ReturnToPool(LifespanAfterCollision);
		}
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!_hasShot || _hasCollided)
		{
			return;
		}
		if (damageAmount > 0)
		{
			IDamageable target = collision.gameObject.GetComponentInParent<IDamageable>();
			if (validTargets.IsValidTarget(ref target) && _hitTargets.Add(target))
			{
				target.ApplyDamage(damageAmount, "Projectile: " + base.name, damageType);
			}
		}
		ActivateCollision(base.transform.position, collision.transform, base.transform.forward);
		rigidbody.velocity = Vector3.zero;
		onCollision?.Invoke(collision.collider);
	}

	public void ActivateCollision(Vector3 hitPosition, Transform hitTransform, Vector3 hitNormal)
	{
		_hasCollided = true;
		if (EffectsPoolOnCollision != null)
		{
			GameObject gameObject = EffectsPoolOnCollision.Get();
			gameObject.transform.position = hitPosition + hitNormal * CollisionOffset;
			gameObject.transform.LookAt(hitPosition + hitNormal + hitNormal * CollisionOffset);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = (CollisionEffectInTargetSpace ? hitTransform : base.transform);
			}
			gameObject.SetActive(value: true);
			Timing.RunCoroutine(ReturnToPool(gameObject, DestroyTimeDelay));
		}
		Timing.KillCoroutines(_handle);
		ReturnToPool(LifespanAfterCollision);
		OnCollisionDeactivateBehaviour(active: false);
	}

	private void OnCollisionDeactivateBehaviour(bool active)
	{
		for (int i = 0; i < DeactivatedObjectsOnCollision.Length; i++)
		{
			if (DeactivatedObjectsOnCollision[i] != null)
			{
				DeactivatedObjectsOnCollision[i].SetActive(active);
			}
		}
	}

	public void ReturnToPool(float delay)
	{
		_handle = Timing.RunCoroutine(ReturnToPoolRoutine(delay));
	}

	private IEnumerator<float> ReturnToPool(GameObject obj, float delay)
	{
		IGameObjectPoolable iobj = obj.GetComponent<IGameObjectPoolable>();
		yield return Timing.WaitForSeconds(delay);
		iobj.Pool.ReturnToPool(obj);
	}

	private IEnumerator<float> ReturnToPoolRoutine(float delay)
	{
		yield return Timing.WaitForSeconds(delay);
		Pool.ReturnToPool(base.gameObject);
	}
}
public class RelativeLocation
{
	public Vector3 position;

	public Transform relativeTo;

	public Vector3 forward;

	public RelativeLocation()
	{
	}

	public RelativeLocation(Transform relativeTo, Vector3 worldPos, Vector3 forward)
	{
		Set(relativeTo, worldPos, forward);
	}

	public RelativeLocation Set(Transform relativeTo, Vector3 worldPos, Vector3 forward)
	{
		this.relativeTo = relativeTo;
		if (relativeTo == null)
		{
			position = worldPos;
			this.forward = forward;
		}
		else
		{
			position = relativeTo.InverseTransformPoint(worldPos);
			this.forward = relativeTo.InverseTransformDirection(forward);
		}
		return this;
	}

	public Vector3 GetWorldPos()
	{
		if (relativeTo == null)
		{
			return position;
		}
		return relativeTo.TransformPoint(position);
	}

	public Vector3 GetForward()
	{
		if (relativeTo == null)
		{
			return forward;
		}
		return relativeTo.TransformDirection(forward);
	}
}
public class ShooterPatterns : MonoBehaviour
{
	public GameObjectPool shotPool;

	public Transform matchTransform;

	private ShootAtTarget _shootAtTarget;

	private GameObject _poolableObject;

	public void CenterShot()
	{
		_shootAtTarget = Get(shotPool).GetComponent<ShootAtTarget>();
		_shootAtTarget.FaceTarget();
	}

	public void SideShot(float xOffset)
	{
		_shootAtTarget = Get(shotPool).GetComponent<ShootAtTarget>();
		_shootAtTarget.FaceTarget(new Vector3(xOffset, 0f, 0f));
	}

	public GameObject Get(GameObjectPool pool)
	{
		_poolableObject = pool.Get();
		_poolableObject.transform.SetPositionAndRotation(matchTransform.position, matchTransform.rotation);
		_poolableObject.SetActive(value: true);
		return _poolableObject;
	}
}
public class ShootingSpider : NavMobAI
{
	public float backUpDistance;

	public float attackingDistance;

	public float attackingAngle;

	public FloatReference attackInterval;

	public float webDistance;

	public FloatReference webDelay;

	private Transform _player;

	private float _nextAttack;

	private float _lastPathSet;

	private bool _isShooting;

	private bool _hasWebbed;

	private void Start()
	{
		_player = Player.Instance.transform;
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		if (fsm.ActiveStateName != "Attacking")
		{
			base.enabled = false;
			_hasWebbed = false;
			return;
		}
		if (_isShooting)
		{
			if (agent.velocity.sqrMagnitude > 0.01f)
			{
				return;
			}
			animator.SetTrigger(MobAI.WEB);
			_nextAttack = Time.time + (float)webDelay;
			_hasWebbed = true;
			_isShooting = false;
			agent.isStopped = false;
		}
		if (animator.GetCurrentAnimatorStateInfo(0).IsName("web"))
		{
			return;
		}
		Vector3 to = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
		float magnitude = to.magnitude;
		if ((!_hasWebbed && magnitude > webDistance) || (_hasWebbed && magnitude > attackingDistance) || (ViewIsBlocked() && magnitude > backUpDistance))
		{
			navMeshMob.setAnimationParams = true;
			if (!(Time.time < _lastPathSet + 0.25f))
			{
				agent.SetDestination(_player.position);
				_lastPathSet = Time.time;
			}
			return;
		}
		navMeshMob.setAnimationParams = false;
		float num = Vector3.SignedAngle(base.transform.forward, to, base.transform.up);
		if (Mathf.Abs(num) > attackingAngle)
		{
			animator.SetFloat(MobAI.ROTATION, num);
			animator.SetFloat(MobAI.SPEED, 0f);
			return;
		}
		animator.SetFloat(MobAI.ROTATION, 0f);
		if (magnitude < backUpDistance)
		{
			agent.nextPosition = base.transform.position - base.transform.forward * agent.speed / 4f * Time.deltaTime;
			animator.SetFloat(MobAI.SPEED, 0f - (backUpDistance - magnitude));
		}
		else if (Time.time >= _nextAttack)
		{
			if (!_hasWebbed && magnitude > attackingDistance)
			{
				animator.SetFloat(MobAI.SPEED, 0f);
				_isShooting = true;
				agent.ResetPath();
				agent.isStopped = true;
			}
			else
			{
				animator.SetTrigger(MobAI.BITE);
				_nextAttack = Time.time + (float)attackInterval;
			}
		}
	}

	private bool ViewIsBlocked()
	{
		Vector3 vector = base.transform.position + base.transform.up * 0.2f;
		int num = Physics.RaycastNonAlloc(vector, _player.position - vector, Utilities.raycastHitPool, webDistance, References.SolidLayers);
		if (num > 0)
		{
			Array.Sort(Utilities.raycastHitPool, 0, num, Utilities.RaycastHitDistanceComparer.Comparer);
		}
		for (int i = 0; i < num; i++)
		{
			Transform transform = Utilities.raycastHitPool[i].transform;
			if (transform.IsChildOf(_player) || _player.IsChildOf(transform))
			{
				break;
			}
			if (!transform.IsChildOf(base.transform) && !base.transform.IsChildOf(transform))
			{
				return true;
			}
		}
		return false;
	}
}
public class SlowOnFreeze : MonoBehaviour
{
	public Animator animator;

	public FloatReference slowSpeed;

	public FloatReference slowDuration;

	public FloatReference transitionTime;

	private float _unfreezeTime;

	private CoroutineHandle _handle;

	private void OnValidate()
	{
		if (animator == null && TryGetComponent<Animator>(out var component))
		{
			animator = component;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Ice"))
		{
			_unfreezeTime = Time.time + (float)slowDuration + (float)transitionTime;
			_handle = Timing.RunCoroutineSingleton(Slow(), _handle, SingletonBehavior.Abort);
		}
	}

	private IEnumerator<float> Slow()
	{
		float t2 = Time.deltaTime;
		while (t2 < (float)transitionTime)
		{
			animator.speed = Mathf.Lerp(1f, slowSpeed, t2 / (float)transitionTime);
			t2 += Time.deltaTime;
			yield return float.NegativeInfinity;
		}
		animator.speed = slowSpeed;
		while (Time.time < _unfreezeTime)
		{
			yield return Timing.WaitForSeconds(_unfreezeTime - Time.time);
		}
		t2 = Time.deltaTime;
		while (t2 < (float)transitionTime)
		{
			animator.speed = Mathf.Lerp(slowSpeed, 1f, t2 / (float)transitionTime);
			t2 += Time.deltaTime;
			yield return float.NegativeInfinity;
		}
		animator.speed = 1f;
	}
}
public class SmallSpider : NavMobAI
{
	public float backUpDistance;

	public float attackingDistance;

	public float attackingAngle;

	public FloatReference attackInterval;

	private Transform _player;

	private float _nextAttack;

	private float _lastPathSet;

	private void Start()
	{
		_player = Player.Instance.transform;
	}

	private void Update()
	{
		if (VRSystem.IsPaused)
		{
			return;
		}
		if (fsm.ActiveStateName != "Attacking")
		{
			base.enabled = false;
			return;
		}
		Vector3 to = Vector3.ProjectOnPlane(_player.position - base.transform.position, _player.up);
		float magnitude = to.magnitude;
		if (magnitude > attackingDistance)
		{
			navMeshMob.setAnimationParams = true;
			if (!(Time.time < _lastPathSet + 0.25f))
			{
				agent.SetDestination(_player.position);
				_lastPathSet = Time.time;
			}
			return;
		}
		navMeshMob.setAnimationParams = false;
		float num = Vector3.SignedAngle(base.transform.forward, to, base.transform.up);
		if (Mathf.Abs(num) > attackingAngle)
		{
			animator.SetFloat(MobAI.ROTATION, num);
			animator.SetFloat(MobAI.SPEED, 0f);
			return;
		}
		animator.SetFloat(MobAI.ROTATION, 0f);
		animator.SetFloat(MobAI.SPEED, 0f, 0.1f, Time.deltaTime);
		if (magnitude < backUpDistance)
		{
			agent.nextPosition = base.transform.position - base.transform.forward * agent.speed / 4f * Time.deltaTime;
			animator.SetFloat(MobAI.SPEED, 0f - (backUpDistance - magnitude));
		}
		else if (Time.time >= _nextAttack)
		{
			animator.SetTrigger(MobAI.BITE);
			_nextAttack = Time.time + (float)attackInterval;
		}
	}
}
public class SpiderWeb : MonoBehaviour
{
	public float duration;

	private void Awake()
	{
		Projectile component = base.gameObject.GetComponent<Projectile>();
		component.onCollision = (Action<Collider>)Delegate.Combine(component.onCollision, new Action<Collider>(ApplyWeb));
	}

	public void ApplyWeb(Collider other)
	{
		Mob componentInParent = other.GetComponentInParent<Mob>();
		if (componentInParent != null)
		{
			if (componentInParent is Player)
			{
				Timing.RunCoroutine(WebPlayer());
			}
			else if (componentInParent is NavMeshMob)
			{
				Timing.RunCoroutine(Web((NavMeshMob)componentInParent));
			}
		}
	}

	private IEnumerator<float> WebPlayer()
	{
		References.PlayerMoveTeleportLock.LockUsing(this);
		References.WebEffect.SetActive(value: true);
		yield return Timing.WaitForSeconds(duration);
		References.PlayerMoveTeleportLock.Unlock(this);
		References.WebEffect.SetActive(value: false);
	}

	private IEnumerator<float> Web(NavMeshMob mob)
	{
		float spd = mob.agent.speed;
		mob.agent.speed = 0f;
		yield return Timing.WaitForSeconds(duration);
		mob.agent.speed = spd;
	}
}
public class Turret : MonoBehaviour
{
	public GameObjectPool shotPool;

	public float delay;

	public float speed;

	public Collider[] ignoreCollisions;

	public void Shoot()
	{
		GameObject gameObject = shotPool.Get();
		gameObject.transform.position = base.transform.position;
		gameObject.transform.rotation = base.transform.rotation;
		Projectile component = gameObject.GetComponent<Projectile>();
		for (int i = 0; i < ignoreCollisions.Length; i++)
		{
			component.IgnoreCollision(ignoreCollisions[i]);
		}
		gameObject.SetActive(value: true);
		component.Shoot(component.transform.forward, delay, speed);
	}
}
public class MoveTransformOnComfort : MonoBehaviour
{
	public Vector3 onTrue;

	public Vector3 onFalse;

	private void OnEnable()
	{
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnTrue = (System.Action)Delegate.Combine(comfortModeChanged.OnTrue, new System.Action(OnTrue));
		GameEvent comfortModeChanged2 = References.ComfortModeChanged;
		comfortModeChanged2.OnFalse = (System.Action)Delegate.Combine(comfortModeChanged2.OnFalse, new System.Action(OnFalse));
	}

	private void OnDisable()
	{
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnTrue = (System.Action)Delegate.Remove(comfortModeChanged.OnTrue, new System.Action(OnTrue));
		GameEvent comfortModeChanged2 = References.ComfortModeChanged;
		comfortModeChanged2.OnFalse = (System.Action)Delegate.Remove(comfortModeChanged2.OnFalse, new System.Action(OnFalse));
	}

	private void OnTrue()
	{
		base.transform.localPosition = onTrue;
	}

	private void OnFalse()
	{
		base.transform.localPosition = onFalse;
	}
}
public class MusicDatabase : ScriptableObject
{
	[SerializeField]
	private List<MusicTrack> _musicTracks;

	public int TrackCount => _musicTracks.Count;

	public int ClipMax => (from x in _musicTracks
		orderby x.clips.Length descending
		select x.clips.Length).First();

	public MusicTrack GetTrack(int id)
	{
		return _musicTracks.Where((MusicTrack t) => t.id == id).FirstOrDefault();
	}

	public MusicTrack GetTrack(string name)
	{
		return _musicTracks.Where((MusicTrack t) => t.name == name).FirstOrDefault();
	}

	public int GetID(string name)
	{
		return GetTrack(name)?.id ?? (-1);
	}

	public string[] GetNames()
	{
		return _musicTracks.Select((MusicTrack x) => x.name).ToArray();
	}
}
public class MusicManager : MonoBehaviour
{
	public enum FadeType
	{
		fadeOut,
		fadeIn
	}

	[SerializeField]
	public MusicDatabase musicDatabase;

	[SerializeField]
	public AudioMixerGroup audioMixerGroup;

	private static GameObject _musicPlayerA;

	private static GameObject _musicPlayerB;

	private static AudioSource[] _audioSourcesA;

	private static AudioSource[] _audioSourcesB;

	private static MusicTrack _previousTrack;

	private static List<AudioClip> _previousTracks;

	private static List<AudioClip> _activeTracks;

	private static bool _activePlayerB;

	private static bool _isPaused;

	private static MusicState _savedState;

	private static Dictionary<AudioSource, FadeType> _fadingAudioSources;

	public static MusicManager Instance { get; private set; }

	public static MusicTrack ActiveTrack { get; private set; }

	private void Awake()
	{
		if (Instance != null && Instance != this)
		{
			UnityEngine.Object.DestroyImmediate(this);
			return;
		}
		Instance = this;
		SceneManager.sceneLoaded += SceneLoaded;
		_musicPlayerA = new GameObject("Music Player A");
		_musicPlayerA.transform.parent = base.transform;
		_musicPlayerA.transform.localPosition = Vector3.zero;
		_musicPlayerB = new GameObject("Music Player B");
		_musicPlayerB.transform.parent = base.transform;
		_musicPlayerB.transform.localPosition = Vector3.zero;
		int clipMax = musicDatabase.ClipMax;
		_audioSourcesA = new AudioSource[clipMax];
		_audioSourcesB = new AudioSource[clipMax];
		_fadingAudioSources = new Dictionary<AudioSource, FadeType>();
		for (int i = 0; i < clipMax; i++)
		{
			_audioSourcesA[i] = _musicPlayerA.gameObject.AddComponent<AudioSource>();
			_audioSourcesA[i].loop = true;
			_audioSourcesA[i].ignoreListenerPause = true;
			_audioSourcesA[i].outputAudioMixerGroup = audioMixerGroup;
			_audioSourcesB[i] = _musicPlayerB.gameObject.AddComponent<AudioSource>();
			_audioSourcesB[i].loop = true;
			_audioSourcesB[i].ignoreListenerPause = true;
			_audioSourcesB[i].outputAudioMixerGroup = audioMixerGroup;
		}
	}

	private void OnDestroy()
	{
		if (Instance == this)
		{
			Instance = null;
			SceneManager.sceneLoaded -= SceneLoaded;
		}
	}

	private void SceneLoaded(Scene scene, LoadSceneMode mode)
	{
		if (mode != LoadSceneMode.Additive && musicDatabase.TrackCount != 0 && scene.name != "LoadingScene")
		{
			StopAllCoroutines();
		}
	}

	private static MusicTrack GetTrack(string name)
	{
		return Instance.musicDatabase.GetTrack(name);
	}

	public static void Play(MusicTrack musicTrack, float crossfade, bool isOneShot = false)
	{
		Play(musicTrack, crossfade, musicTrack.clips, isOneShot);
	}

	public static void Play(MusicTrack musicTrack, float crossfade, IEnumerable<AudioClip> enabledTracks, bool isOneShot)
	{
		if (musicTrack == null)
		{
			Stop(crossfade);
			return;
		}
		if (isOneShot)
		{
			Timing.RunCoroutine(Instance.Revert(musicTrack, musicTrack.clips[0].length, crossfade));
		}
		if (ActiveTrack != musicTrack)
		{
			InitializeTheme(musicTrack, crossfade);
		}
		if (_activePlayerB)
		{
			Timing.RunCoroutine(Instance.FadeIn(_audioSourcesB.Where((AudioSource x) => enabledTracks.Contains(x.clip)), crossfade));
		}
		else
		{
			Timing.RunCoroutine(Instance.FadeIn(_audioSourcesA.Where((AudioSource x) => enabledTracks.Contains(x.clip)), crossfade));
		}
		_activeTracks = enabledTracks.ToList();
	}

	public static void MuteTrack(int index, float crossfade)
	{
		AudioSource audioSource = (_activePlayerB ? _audioSourcesB[index] : _audioSourcesA[index]);
		if (_activeTracks.Contains(audioSource.clip))
		{
			Timing.RunCoroutine(Instance.FadeOut(new AudioSource[1] { audioSource }, crossfade, stopPlaying: false));
			_activeTracks.Remove(audioSource.clip);
		}
	}

	public static void UnMuteTrack(int index, float crossfade)
	{
		AudioSource audioSource = (_activePlayerB ? _audioSourcesB[index] : _audioSourcesA[index]);
		if (!_activeTracks.Contains(audioSource.clip))
		{
			Timing.RunCoroutine(Instance.FadeIn(new AudioSource[1] { audioSource }, crossfade));
			_activeTracks.Add(audioSource.clip);
		}
	}

	public static void Stop(float crossfade)
	{
		if (_activePlayerB)
		{
			Timing.RunCoroutine(Instance.FadeOut(_audioSourcesB, crossfade, stopPlaying: true));
		}
		else
		{
			Timing.RunCoroutine(Instance.FadeOut(_audioSourcesA, crossfade, stopPlaying: true));
		}
		_previousTrack = ActiveTrack;
		_previousTracks = _activeTracks;
		ActiveTrack = null;
	}

	private static void InitializeTheme(MusicTrack musicTrack, float crossfade)
	{
		ActiveTrack = musicTrack;
		for (int i = 0; i < ActiveTrack.clips.Length; i++)
		{
			if (_activePlayerB)
			{
				_audioSourcesA[i].clip = ActiveTrack.clips[i];
				_audioSourcesA[i].Play();
				_audioSourcesA[i].volume = 0f;
			}
			else
			{
				_audioSourcesB[i].clip = ActiveTrack.clips[i];
				_audioSourcesB[i].Play();
				_audioSourcesB[i].volume = 0f;
			}
		}
		Timing.RunCoroutine(Instance.FadeOut(_activePlayerB ? _audioSourcesB : _audioSourcesA, crossfade, stopPlaying: true));
		_activePlayerB = !_activePlayerB;
	}

	private IEnumerator<float> FadeIn(IEnumerable<AudioSource> sources, float duration)
	{
		foreach (AudioSource source in sources)
		{
			if (!_fadingAudioSources.ContainsKey(source))
			{
				_fadingAudioSources.Add(source, FadeType.fadeIn);
			}
			else if (_fadingAudioSources[source] == FadeType.fadeOut)
			{
				_fadingAudioSources[source] = FadeType.fadeIn;
			}
		}
		while (true)
		{
			if (_isPaused)
			{
				yield return 0f;
				continue;
			}
			int num = 0;
			foreach (AudioSource source2 in sources)
			{
				if (_fadingAudioSources.ContainsKey(source2) && _fadingAudioSources[source2] == FadeType.fadeOut)
				{
					num++;
					continue;
				}
				if (source2.volume < 1f)
				{
					source2.volume = Mathf.Min(1f, source2.volume + Time.deltaTime / duration * 1f);
				}
				if (source2.volume == 1f)
				{
					num++;
				}
			}
			if (num == sources.Count())
			{
				break;
			}
			yield return 0f;
		}
		foreach (AudioSource source3 in sources)
		{
			if (_fadingAudioSources.ContainsKey(source3) && _fadingAudioSources[source3] == FadeType.fadeIn)
			{
				_fadingAudioSources.Remove(source3);
			}
		}
	}

	private IEnumerator<float> FadeOut(IEnumerable<AudioSource> sources, float duration, bool stopPlaying)
	{
		foreach (AudioSource source in sources)
		{
			if (!_fadingAudioSources.ContainsKey(source))
			{
				_fadingAudioSources.Add(source, FadeType.fadeOut);
			}
			else if (_fadingAudioSources[source] == FadeType.fadeIn)
			{
				_fadingAudioSources[source] = FadeType.fadeOut;
			}
		}
		while (true)
		{
			if (_isPaused)
			{
				yield return 0f;
				continue;
			}
			int num = 0;
			foreach (AudioSource source2 in sources)
			{
				if (_fadingAudioSources.ContainsKey(source2) && _fadingAudioSources[source2] == FadeType.fadeIn)
				{
					num++;
					continue;
				}
				if (source2.volume > 0f)
				{
					source2.volume = Mathf.Max(0f, source2.volume - Time.deltaTime / duration * 1f);
				}
				if (source2.volume == 0f)
				{
					num++;
				}
			}
			if (num == sources.Count())
			{
				break;
			}
			yield return 0f;
		}
		if (stopPlaying)
		{
			foreach (AudioSource source3 in sources)
			{
				if (_fadingAudioSources.ContainsKey(source3) && _fadingAudioSources[source3] == FadeType.fadeOut)
				{
					source3.Stop();
					source3.clip = null;
				}
			}
		}
		foreach (AudioSource source4 in sources)
		{
			if (_fadingAudioSources.ContainsKey(source4) && _fadingAudioSources[source4] == FadeType.fadeOut)
			{
				_fadingAudioSources.Remove(source4);
			}
		}
	}

	private IEnumerator<float> Revert(MusicTrack newTrack, float delay, float crossfade)
	{
		float t = delay;
		while (t > 0f)
		{
			yield return 0f;
			if (!_isPaused)
			{
				t -= Time.deltaTime;
			}
		}
		if (ActiveTrack != newTrack)
		{
			yield break;
		}
		InitializeTheme(_previousTrack, 0f);
		if (_activePlayerB)
		{
			Timing.RunCoroutine(Instance.FadeIn(_audioSourcesB.Where((AudioSource x) => _previousTracks.Contains(x.clip)), crossfade));
		}
		else
		{
			Timing.RunCoroutine(Instance.FadeIn(_audioSourcesA.Where((AudioSource x) => _previousTracks.Contains(x.clip)), crossfade));
		}
	}

	public static void Pause(bool pause)
	{
		if (_isPaused == pause)
		{
			return;
		}
		_isPaused = pause;
		if (pause)
		{
			for (int i = 0; i < _audioSourcesB.Length; i++)
			{
				_audioSourcesB[i].Pause();
			}
			for (int j = 0; j < _audioSourcesA.Length; j++)
			{
				_audioSourcesA[j].Pause();
			}
		}
		else
		{
			for (int k = 0; k < _audioSourcesB.Length; k++)
			{
				_audioSourcesB[k].UnPause();
			}
			for (int l = 0; l < _audioSourcesA.Length; l++)
			{
				_audioSourcesA[l].UnPause();
			}
		}
	}

	public static void SaveState()
	{
		_savedState = new MusicState(ActiveTrack, _activePlayerB ? _audioSourcesB : _audioSourcesA, _activeTracks);
	}

	public static bool LoadState(float crossfade = 2f)
	{
		if (_savedState == null)
		{
			return false;
		}
		SetMusicState(_savedState, crossfade);
		return true;
	}

	public static MusicState GetMusicState()
	{
		return new MusicState(ActiveTrack, _activePlayerB ? _audioSourcesB : _audioSourcesA, _activeTracks);
	}

	public static void SetMusicState(MusicState state, float crossfade = 2f)
	{
		if (string.IsNullOrEmpty(state.activeTrack))
		{
			Stop(crossfade);
			return;
		}
		MusicTrack track = Instance.musicDatabase.GetTrack(state.activeTrack);
		List<AudioClip> list = new List<AudioClip>();
		for (int i = 0; i < state.activeClips.Length; i++)
		{
			if (state.activeClips[i])
			{
				list.Add(track.clips[i]);
			}
		}
		Play(track, crossfade, list, isOneShot: false);
	}
}
[Serializable]
public class MusicState
{
	public string activeTrack;

	public bool[] activeClips;

	public MusicState(MusicTrack activeTrack, AudioSource[] audioSources, List<AudioClip> activeClips)
	{
		if (activeTrack == null)
		{
			return;
		}
		this.activeTrack = activeTrack.name;
		this.activeClips = new bool[audioSources.Length];
		for (int i = 0; i < audioSources.Length; i++)
		{
			if (activeClips.Contains(audioSources[i].clip))
			{
				this.activeClips[i] = true;
			}
		}
	}
}
[Serializable]
public class MusicTrack
{
	[SerializeField]
	public string name;

	[SerializeField]
	public AudioClip[] clips = new AudioClip[1];

	[SerializeField]
	public string[] trackNames = new string[1];

	[SerializeField]
	public int id;

	public AudioClip GetTrack(string name)
	{
		int num = Array.IndexOf(trackNames, name);
		if (num == -1)
		{
			return null;
		}
		return clips[num];
	}

	public int IndexOf(string name)
	{
		return Array.IndexOf(trackNames, name);
	}

	public int IndexOf(AudioClip clip)
	{
		return Array.IndexOf(clips, clip);
	}
}
public class HintSystem : Singleton<HintSystem>
{
	public List<Puzzle> puzzles = new List<Puzzle>();

	private Puzzle _lastPlayed;

	public static int PuzzleCount => Singleton<HintSystem>.Instance.puzzles.Count;

	public static AudioClip GetNextHint()
	{
		for (int i = 0; i < Singleton<HintSystem>.Instance.puzzles.Count; i++)
		{
			if (!Singleton<HintSystem>.Instance.puzzles[i].complete)
			{
				Singleton<HintSystem>.Instance._lastPlayed = Singleton<HintSystem>.Instance.puzzles[i];
				return Singleton<HintSystem>.Instance.puzzles[i].GetHint();
			}
		}
		return null;
	}

	public static void AdvanceHint()
	{
		Singleton<HintSystem>.Instance._lastPlayed.AdvanceHint();
	}

	public static void CompletePuzzle(int id)
	{
		Singleton<HintSystem>.Instance.puzzles[id].complete = true;
		Singleton<OdinQuip>.Instance.PuzzleSolved();
	}

	public static void CompletePuzzle(string name)
	{
		for (int i = 0; i < Singleton<HintSystem>.Instance.puzzles.Count; i++)
		{
			if (name == Singleton<HintSystem>.Instance.puzzles[i].name)
			{
				Singleton<HintSystem>.Instance.puzzles[i].complete = true;
				break;
			}
		}
		Singleton<OdinQuip>.Instance.PuzzleSolved();
	}

	public static bool[] GetPuzzleStatus()
	{
		bool[] array = new bool[Singleton<HintSystem>.Instance.puzzles.Count];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Singleton<HintSystem>.Instance.puzzles[i].complete;
		}
		return array;
	}

	public static void SetPuzzleStatus(bool[] status)
	{
		for (int i = 0; i < status.Length; i++)
		{
			if (status[i])
			{
				Singleton<HintSystem>.Instance.puzzles[i].complete = true;
			}
			else
			{
				Singleton<HintSystem>.Instance.puzzles[i].Reset();
			}
		}
	}

	public static void ResetAllPuzzles()
	{
		for (int i = 0; i < Singleton<HintSystem>.Instance.puzzles.Count; i++)
		{
			Singleton<HintSystem>.Instance.puzzles[i].Reset();
		}
	}
}
[Serializable]
public class Puzzle
{
	public string name;

	[SerializeField]
	public List<AudioClip> hints = new List<AudioClip>();

	[SerializeField]
	[UnityEngine.Tooltip("These are used when the player's control scheme is swapped. Leave empty if there is no change.")]
	public List<AudioClip> altHints = new List<AudioClip>();

	[HideInInspector]
	public bool complete;

	private int _next = -1;

	public AudioClip GetHint()
	{
		int num = Mathf.Clamp(_next + 1, 0, hints.Count - 1);
		if (Settings.Current.dominantHand == HandMode.Left && altHints.Count > num)
		{
			return altHints[num];
		}
		return hints[num];
	}

	public AudioClip GetLastHint()
	{
		if (Settings.Current.dominantHand == HandMode.Left && altHints.Count > _next)
		{
			return altHints[_next];
		}
		return hints[_next];
	}

	public void AdvanceHint()
	{
		_next = Mathf.Clamp(_next + 1, 0, hints.Count - 1);
	}

	public void Reset()
	{
		complete = false;
		_next = -1;
	}
}
public class Odin : Singleton<Odin>, ISaveSerializable
{
	[Serializable]
	public class OdinData : ISaveData
	{
		[SerializeField]
		private string currentTransform;

		[SerializeField]
		private Vector3 position;

		[SerializeField]
		private Quaternion rotation;

		public void Serialize(ISaveSerializable target)
		{
			Odin odin = (Odin)target;
			if (odin._targetTransform != null)
			{
				if (odin._targetTransform.TryGetComponent<UniqueId>(out var component))
				{
					currentTransform = component.uniqueId;
				}
				position = odin._targetTransform.position;
				rotation = odin._targetTransform.rotation;
			}
			else
			{
				if (odin._currentTransform != null && odin._currentTransform.TryGetComponent<UniqueId>(out var component2))
				{
					currentTransform = component2.uniqueId;
				}
				position = odin.transform.position;
				rotation = odin.transform.rotation;
			}
		}

		public void Deserialize(ISaveSerializable target)
		{
			Odin obj = (Odin)target;
			obj.Teleport(position, rotation);
			obj._currentTransform = UniqueId.FindTransform(currentTransform);
		}
	}

	public OdinMovement ai;

	public Animator anim;

	public Transform model;

	private Transform _targetTransform;

	private Transform _currentTransform;

	private bool _isTurning;

	private bool _isFlying;

	private bool _isStopping;

	private float _lastAngle;

	private Vector3 _stopStartPos;

	private float _stopStartTime;

	private void OnValidate()
	{
		if (ai == null)
		{
			ai = GetComponent<OdinMovement>();
		}
		if (anim == null)
		{
			anim = GetComponent<Animator>();
		}
	}

	private void Start()
	{
		GameEvent odinSummonRequested = References.OdinSummonRequested;
		odinSummonRequested.OnTrue = (System.Action)Delegate.Combine(odinSummonRequested.OnTrue, new System.Action(Summon));
	}

	private void Summon()
	{
		Transform target = Perch.FindClosest(Player.Instance.transform.position);
		MoveToPoint(target);
	}

	public void MoveToPoint(Transform target)
	{
		if (!(_currentTransform == target) && !(target == null))
		{
			_targetTransform = target;
			_targetTransform.hasChanged = false;
			_currentTransform = null;
			ai.destination = target.position;
			ai.SearchPath();
		}
	}

	public void MoveToPoint(string ID)
	{
		MoveToPoint(ObjectID.Get<Transform>(ID));
	}

	private void Update()
	{
		if (!(_targetTransform != null))
		{
			return;
		}
		if (!ai.hasPath || ai.reachedDestination)
		{
			if (_isFlying)
			{
				_isTurning = true;
				_isFlying = false;
				_isStopping = false;
				anim.SetBool("IsFlying", value: false);
				base.transform.position = _targetTransform.position;
			}
			if (_isTurning)
			{
				float num = Vector3.SignedAngle(base.transform.forward, _targetTransform.forward, Vector3.up);
				if ((num > 0f && _lastAngle < 0f) || (num < 0f && _lastAngle > 0f))
				{
					num = 0f;
				}
				if (num == 0f)
				{
					_currentTransform = _targetTransform;
					_targetTransform = null;
					base.transform.position = _currentTransform.position;
					base.transform.rotation = _currentTransform.rotation;
					_isTurning = false;
				}
				_lastAngle = num;
				anim.SetFloat("Speed", 0f);
				anim.SetFloat("Rotation", Mathf.Clamp(num, -1f, 1f));
			}
			return;
		}
		if (_targetTransform.hasChanged && !ai.pathPending)
		{
			if (_isStopping)
			{
				ai.canMove = false;
				base.transform.position = Vector3.Lerp(_stopStartPos, _targetTransform.position, Time.time - _stopStartTime);
				if (Time.time >= _stopStartTime + 1f)
				{
					ai.SetPath(null);
					ai.canMove = true;
				}
			}
			else
			{
				_targetTransform.hasChanged = false;
				ai.destination = _targetTransform.position;
				ai.SearchPath();
			}
		}
		Vector3 vector = base.transform.InverseTransformDirection(((IAstarAI)ai).velocity);
		anim.SetFloat("Rotation", Mathf.Clamp(vector.x * 8f, -1f, 1f));
		anim.SetFloat("Speed", Mathf.Clamp01(vector.z));
		float remainingDistance = ai.remainingDistance;
		if (!_isFlying)
		{
			_isFlying = true;
			_isTurning = false;
			anim.SetBool("IsFlying", value: true);
			anim.SetTrigger("StartFlying");
		}
		else if (remainingDistance < 1f && !_isStopping)
		{
			_isStopping = true;
			_stopStartTime = Time.time;
			_stopStartPos = base.transform.position;
			anim.SetTrigger("StopFlying");
		}
	}

	private void LateUpdate()
	{
		if (_currentTransform != null && _currentTransform.hasChanged)
		{
			base.transform.position = _currentTransform.position;
			base.transform.rotation = _currentTransform.rotation;
			_currentTransform.hasChanged = false;
		}
	}

	public ISaveData Serialize()
	{
		OdinData odinData = new OdinData();
		odinData.Serialize(this);
		return odinData;
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((OdinData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<OdinData>(saveData).Deserialize(this);
	}

	public void Teleport(Transform target)
	{
		_currentTransform = target;
		Teleport(target.position, target.rotation);
	}

	public void Teleport(Vector3 position, Quaternion rotation)
	{
		ai.SetPath(null);
		base.transform.position = position;
		base.transform.rotation = rotation;
		_targetTransform = null;
		_isTurning = false;
		_isFlying = false;
		_isStopping = false;
		anim.SetFloat("Rotation", 0f);
		anim.SetFloat("Speed", 0f);
		anim.ResetTrigger("StartFlying");
		anim.SetBool("IsFlying", value: false);
		anim.ResetTrigger("StopFlying");
		anim.Play("Rav_Idle01 0");
	}
}
public class OdinHint : Singleton<OdinHint>
{
	public AudioSource audioSource;

	public float maxDistance = 10f;

	private bool _isGivingHint;

	private void OnEnable()
	{
		GameEvent hintRequested = References.HintRequested;
		hintRequested.OnTrue = (System.Action)Delegate.Combine(hintRequested.OnTrue, new System.Action(OnEventRaised));
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Combine(onPlayerRespawn.OnTrue, new System.Action(StopSound));
	}

	private void OnDisable()
	{
		if (References.IsInitialized)
		{
			GameEvent hintRequested = References.HintRequested;
			hintRequested.OnTrue = (System.Action)Delegate.Remove(hintRequested.OnTrue, new System.Action(OnEventRaised));
			GameEvent onPlayerRespawn = References.OnPlayerRespawn;
			onPlayerRespawn.OnTrue = (System.Action)Delegate.Remove(onPlayerRespawn.OnTrue, new System.Action(StopSound));
		}
	}

	public void OnEventRaised()
	{
		if (!Settings.Current.hints || _isGivingHint || References.OdinHintLock.IsLocked() || References.PlayerInterfaceLock.IsLocked() || !(Vector3.Distance(References.Headset.transform.position, base.transform.position) <= maxDistance))
		{
			return;
		}
		_isGivingHint = true;
		AudioClip hint = HintSystem.GetNextHint();
		if (!(hint != null))
		{
			return;
		}
		UnloadAudio();
		audioSource.clip = hint;
		audioSource.Play();
		References.Subtitles.DisplayText(audioSource.clip.name, audioSource.clip.length, audioSource);
		Timing.CallDelayed(hint.length, delegate
		{
			_isGivingHint = false;
			if (audioSource.clip == hint)
			{
				HintSystem.AdvanceHint();
			}
		});
		Singleton<OdinQuip>.Instance.HintRequested();
	}

	public static void StopSound()
	{
		Singleton<OdinHint>.Instance.audioSource.Stop();
		UnloadAudio();
		Singleton<OdinHint>.Instance.audioSource.clip = null;
	}

	private static void UnloadAudio()
	{
		if (Singleton<OdinHint>.Instance.audioSource.clip != null)
		{
			if (Singleton<OdinHint>.Instance.audioSource.isPlaying)
			{
				Singleton<OdinHint>.Instance.audioSource.Stop();
			}
			Singleton<OdinHint>.Instance.audioSource.clip.UnloadAudioData();
		}
	}
}
public class OdinMenu : Singleton<OdinMenu>
{
	public Animator animator;

	public AudioSource audioSource;

	public AudioClip[] audioClips;

	public static int playedClips;

	public float timeBeforeIntroduction;

	public QueueProcessor queueProcessor;

	private bool _isStopping;

	private void Start()
	{
		queueProcessor.ignoreScaledTime = true;
		GameEvent onGamePaused = References.OnGamePaused;
		onGamePaused.OnTrue = (System.Action)Delegate.Combine(onGamePaused.OnTrue, new System.Action(OnPause));
		GameEvent onGamePaused2 = References.OnGamePaused;
		onGamePaused2.OnFalse = (System.Action)Delegate.Combine(onGamePaused2.OnFalse, new System.Action(OnUnpause));
		audioSource.ignoreListenerPause = true;
		Timing.RunCoroutine(Startup(), Segment.RealtimeUpdate);
	}

	private void OnDestroy()
	{
		GameEvent onGamePaused = References.OnGamePaused;
		onGamePaused.OnTrue = (System.Action)Delegate.Remove(onGamePaused.OnTrue, new System.Action(OnPause));
		GameEvent onGamePaused2 = References.OnGamePaused;
		onGamePaused2.OnFalse = (System.Action)Delegate.Remove(onGamePaused2.OnFalse, new System.Action(OnUnpause));
	}

	private IEnumerator<float> Startup()
	{
		float t = timeBeforeIntroduction;
		while (true)
		{
			yield return float.NegativeInfinity;
			if (VRSystem.IsPaused)
			{
				continue;
			}
			t -= Time.unscaledDeltaTime;
			if (t <= 0f)
			{
				if (playedClips != 0)
				{
					break;
				}
				PlayClip(1);
				t = audioClips[1].length + 1.5f;
			}
		}
		if (playedClips == 2)
		{
			PlayClip(2);
		}
	}

	private void OnPause()
	{
		animator.updateMode = AnimatorUpdateMode.Normal;
		audioSource.ignoreListenerPause = false;
	}

	private void OnUnpause()
	{
		animator.updateMode = AnimatorUpdateMode.UnscaledTime;
		audioSource.ignoreListenerPause = true;
	}

	private void OnEnable()
	{
		_isStopping = false;
	}

	private void Update()
	{
		if (!MenuManager.IsInMenu && audioSource.isPlaying && !_isStopping)
		{
			_isStopping = true;
			audioSource.FadeOut(0.1f);
			References.MenuSubtitles.EndDisplay();
		}
	}

	public void ResetClips()
	{
		playedClips = 0;
	}

	public void PlayClip(int num)
	{
		if ((playedClips & (1 << num)) != 0)
		{
			return;
		}
		playedClips |= 1 << num;
		if (audioSource.clip != null)
		{
			if (audioSource.isPlaying)
			{
				audioSource.Stop();
			}
			audioSource.clip.UnloadAudioData();
		}
		audioSource.clip = audioClips[num];
		audioSource.Play();
		References.MenuSubtitles.DisplayText(audioSource.clip.name, audioSource.clip.length, audioSource);
	}
}
public class OdinMovement : AILerp
{
	public float acceleration;

	public float slowdownDistance;

	public float speedUpDist;

	public float speedUpMultiplier;

	private float currentSpeed;

	protected override void OnEnable()
	{
		Seeker obj = seeker;
		obj.pathCallback = (OnPathDelegate)Delegate.Remove(obj.pathCallback, new OnPathDelegate(OnPathComplete));
		base.OnEnable();
	}

	protected override void Update()
	{
		if (shouldRecalculatePath)
		{
			SearchPath();
		}
		if (path != null)
		{
			if (base.reachedEndOfPath)
			{
				SetPath(null);
				if (updatePosition)
				{
					simulatedPosition = tr.position;
				}
				if (updateRotation)
				{
					simulatedRotation = tr.rotation;
				}
			}
			else if (canMove)
			{
				MovementUpdate(Time.deltaTime, out var nextPosition, out var nextRotation);
				FinalizeMovement(nextPosition, nextRotation);
			}
		}
		else
		{
			if (updatePosition)
			{
				simulatedPosition = tr.position;
			}
			if (updateRotation)
			{
				simulatedRotation = tr.rotation;
			}
		}
	}

	protected override Vector3 CalculateNextPosition(out Vector3 direction, float deltaTime)
	{
		if (!interpolator.valid)
		{
			direction = Vector3.zero;
			return simulatedPosition;
		}
		float desiredSpeed = GetDesiredSpeed();
		interpolator.distance += Mathf.Min(deltaTime * desiredSpeed, interpolator.remainingDistance);
		if (interpolator.remainingDistance < 0.001f && !base.reachedEndOfPath)
		{
			interpolator.distance += interpolator.remainingDistance;
			base.reachedEndOfPath = true;
			direction = Vector3.ProjectOnPlane(interpolator.tangent, Vector3.up);
			OnTargetReached();
		}
		else
		{
			direction = interpolator.tangent;
			if (interpolator.remainingDistance < slowdownDistance)
			{
				Vector3 vector = Vector3.ProjectOnPlane(direction, Vector3.up);
				float num = Vector3.Angle(direction, vector);
				direction = Quaternion.RotateTowards(Quaternion.Euler(direction), Quaternion.Euler(vector), num * (1f - interpolator.remainingDistance / slowdownDistance)).eulerAngles;
			}
		}
		pathSwitchInterpolationTime += deltaTime;
		float num2 = switchPathInterpolationSpeed * pathSwitchInterpolationTime;
		if (interpolatePathSwitches && num2 < 1f)
		{
			return Vector3.Lerp(previousMovementOrigin + Vector3.ClampMagnitude(previousMovementDirection, desiredSpeed * pathSwitchInterpolationTime), interpolator.position, num2);
		}
		return interpolator.position;
	}

	private float GetDesiredSpeed()
	{
		if (interpolator.valid && !base.isStopped)
		{
			float num = interpolator.remainingDistance;
			float num2 = speed;
			if (currentSpeed < num2)
			{
				num2 = ((!(num < slowdownDistance)) ? Mathf.Min(currentSpeed + acceleration * Time.deltaTime, speed) : Mathf.Min(currentSpeed + acceleration * Time.deltaTime, Mathf.Sqrt(num / slowdownDistance) * speed));
			}
			else if (currentSpeed > num2)
			{
				num2 = ((!(num < slowdownDistance)) ? Mathf.Max(currentSpeed - acceleration * Time.deltaTime, speed) : Mathf.Min(currentSpeed - acceleration * Time.deltaTime, Mathf.Sqrt(num / slowdownDistance) * speed));
			}
			else if (num < slowdownDistance)
			{
				num2 = Mathf.Min(currentSpeed, Mathf.Sqrt(num / slowdownDistance) * speed);
			}
			currentSpeed = num2;
			return num2;
		}
		return 0f;
	}
}
public class OdinQuip : Singleton<OdinQuip>, IGrabTrigger
{
	[Serializable]
	public class QuipData
	{
		public bool enabled;

		public bool isIndoors;

		public int[] indoorUnplayed;

		public int[] outdoorUnplayed;

		public int[] shootUnplayed;

		public int[] petUnplayed;
	}

	[UnityEngine.Tooltip("Time to wait between hurry quips if no hints are given or puzzles solved.")]
	public float delayAfterLastQuip;

	[UnityEngine.Tooltip("Time to wait after a hint is given.")]
	public float delayAfterLastHint;

	[UnityEngine.Tooltip("Time to wait after a puzzle is solved.")]
	public float delayAfterLastProgress;

	[UnityEngine.Tooltip("Minimum time to wait after Odin's AudioSource has played other audio of any kind (for manually-triggered dialogue).")]
	public float delayAfterLastAudio;

	[UnityEngine.Tooltip("Random value from 0 to randomDelay is added to all other delays.")]
	public float randomDelay;

	public AudioClip[] indoorQuips;

	public AudioClip[] outdoorQuips;

	public AudioClip[] shootQuips;

	public AudioClip[] petQuips;

	public Transform centerTransform;

	private List<int> _indoorUnplayed;

	private List<int> _outdoorUnplayed;

	private List<int> _shootUnplayed;

	private List<int> _petUnplayed;

	private float _nextQuip;

	private OdinMovement _ai;

	private AudioSource _audioSource;

	private bool _isIndoors;

	private CoroutineHandle _checkHandle;

	private CoroutineHandle _quipHandle;

	private AudioClip _tempClip;

	public bool QuipsEnabled { get; private set; }

	protected override void Awake()
	{
		base.Awake();
		_audioSource = GetComponent<AudioSource>();
		_ai = GetComponent<OdinMovement>();
		ResetAllQuips();
		GameEvent onPlayerDeath = References.OnPlayerDeath;
		onPlayerDeath.OnTrue = (System.Action)Delegate.Combine(onPlayerDeath.OnTrue, new System.Action(OnDeath));
	}

	private void SetupIndoorList()
	{
		for (int i = 0; i < indoorQuips.Length; i++)
		{
			_indoorUnplayed.Add(i);
		}
	}

	private void SetupOutdoorList()
	{
		for (int i = 0; i < outdoorQuips.Length; i++)
		{
			_outdoorUnplayed.Add(i);
		}
	}

	private void SetupShootList()
	{
		for (int i = 0; i < shootQuips.Length; i++)
		{
			_shootUnplayed.Add(i);
		}
	}

	private void SetupPetList()
	{
		for (int i = 0; i < petQuips.Length; i++)
		{
			_petUnplayed.Add(i);
		}
	}

	private AudioClip GetIndoor()
	{
		int index = UnityEngine.Random.Range(0, _indoorUnplayed.Count);
		_tempClip = indoorQuips[_indoorUnplayed[index]];
		_indoorUnplayed.RemoveAt(index);
		if (_indoorUnplayed.Count == 0)
		{
			SetupIndoorList();
		}
		return _tempClip;
	}

	private AudioClip GetOutdoor()
	{
		int index = UnityEngine.Random.Range(0, _outdoorUnplayed.Count);
		_tempClip = outdoorQuips[_outdoorUnplayed[index]];
		_outdoorUnplayed.RemoveAt(index);
		if (_outdoorUnplayed.Count == 0)
		{
			SetupOutdoorList();
		}
		return _tempClip;
	}

	private AudioClip GetShoot()
	{
		int index = UnityEngine.Random.Range(0, _shootUnplayed.Count);
		_tempClip = shootQuips[_shootUnplayed[index]];
		_shootUnplayed.RemoveAt(index);
		if (_shootUnplayed.Count == 0)
		{
			SetupShootList();
		}
		return _tempClip;
	}

	private AudioClip GetPet()
	{
		int index = UnityEngine.Random.Range(0, _petUnplayed.Count);
		_tempClip = petQuips[_petUnplayed[index]];
		_petUnplayed.RemoveAt(index);
		if (_petUnplayed.Count == 0)
		{
			SetupPetList();
		}
		return _tempClip;
	}

	public void ResetTime()
	{
		_nextQuip = Time.time + Mathf.Max(delayAfterLastAudio, delayAfterLastHint, delayAfterLastProgress, delayAfterLastQuip) + UnityEngine.Random.Range(0f, randomDelay);
	}

	public void EnableQuips()
	{
		QuipsEnabled = true;
		if (Settings.Current.quips)
		{
			Unpause();
		}
	}

	public void DisableQuips()
	{
		QuipsEnabled = false;
		Timing.KillCoroutines(_checkHandle);
		Timing.KillCoroutines(_quipHandle);
		if (_audioSource.isPlaying && (indoorQuips.Contains(_audioSource.clip) || outdoorQuips.Contains(_audioSource.clip)))
		{
			_audioSource.Stop();
			References.Subtitles.EndDisplay();
		}
	}

	private void OnDeath()
	{
		Timing.KillCoroutines(_checkHandle);
		Timing.KillCoroutines(_quipHandle);
		if (_audioSource.isPlaying)
		{
			_audioSource.Stop();
			References.Subtitles.EndDisplay();
		}
	}

	public void SetIndoors(bool indoors)
	{
		_isIndoors = indoors;
	}

	public void PuzzleSolved()
	{
		_nextQuip = Mathf.Max(_nextQuip, Time.time + delayAfterLastProgress + UnityEngine.Random.Range(0f, randomDelay));
	}

	public void HintRequested()
	{
		_nextQuip = Mathf.Max(_nextQuip, Time.time + delayAfterLastHint + _audioSource.clip.length - _audioSource.time + UnityEngine.Random.Range(0f, randomDelay));
	}

	public void Unpause()
	{
		ResetTime();
		_checkHandle = Timing.RunCoroutine(CheckAudio());
		_quipHandle = Timing.RunCoroutine(PlayQuips());
	}

	private IEnumerator<float> CheckAudio()
	{
		AudioClip clip = _audioSource.clip;
		while (QuipsEnabled && Settings.Current.quips)
		{
			yield return Timing.WaitForSeconds(3f);
			if (_audioSource.isPlaying)
			{
				_nextQuip = Mathf.Max(_nextQuip, Time.time + delayAfterLastAudio + _audioSource.clip.length - _audioSource.time + UnityEngine.Random.Range(0f, randomDelay));
				clip = _audioSource.clip;
			}
			else if (_audioSource.clip != clip && _audioSource.clip != null)
			{
				_nextQuip = Mathf.Max(_nextQuip, Time.time + delayAfterLastAudio + UnityEngine.Random.Range(0f, randomDelay));
				clip = _audioSource.clip;
			}
		}
	}

	private IEnumerator<float> PlayQuips()
	{
		yield return Timing.WaitForSeconds(_nextQuip - Time.time);
		while (QuipsEnabled && Settings.Current.quips)
		{
			if (Time.time < _nextQuip)
			{
				yield return Timing.WaitForSeconds(_nextQuip - Time.time);
				continue;
			}
			if (_audioSource.isPlaying)
			{
				_nextQuip += _audioSource.clip.length - _audioSource.time + delayAfterLastAudio + UnityEngine.Random.Range(0f, randomDelay);
				continue;
			}
			UnloadAudio();
			_audioSource.clip = (_isIndoors ? GetIndoor() : GetOutdoor());
			_audioSource.Play();
			References.Subtitles.DisplayText(_audioSource.clip.name, _audioSource.clip.length, _audioSource);
			_nextQuip = Time.time + _audioSource.clip.length + delayAfterLastQuip + UnityEngine.Random.Range(0f, randomDelay);
			yield return Timing.WaitForSeconds(_nextQuip - Time.time);
		}
	}

	public static QuipData GetQuipData()
	{
		return new QuipData
		{
			enabled = Singleton<OdinQuip>.Instance.QuipsEnabled,
			indoorUnplayed = Singleton<OdinQuip>.Instance._indoorUnplayed.ToArray(),
			outdoorUnplayed = Singleton<OdinQuip>.Instance._outdoorUnplayed.ToArray(),
			shootUnplayed = Singleton<OdinQuip>.Instance._shootUnplayed.ToArray(),
			petUnplayed = Singleton<OdinQuip>.Instance._petUnplayed.ToArray(),
			isIndoors = Singleton<OdinQuip>.Instance._isIndoors
		};
	}

	public static void SetQuipData(QuipData data)
	{
		if (data != null)
		{
			if (data.enabled)
			{
				Singleton<OdinQuip>.Instance.EnableQuips();
			}
			else
			{
				Singleton<OdinQuip>.Instance.DisableQuips();
			}
			Singleton<OdinQuip>.Instance._isIndoors = data.isIndoors;
			Singleton<OdinQuip>.Instance._indoorUnplayed = new List<int>(data.indoorUnplayed);
			Singleton<OdinQuip>.Instance._outdoorUnplayed = new List<int>(data.outdoorUnplayed);
			Singleton<OdinQuip>.Instance._shootUnplayed = new List<int>(data.shootUnplayed);
			Singleton<OdinQuip>.Instance._petUnplayed = new List<int>(data.petUnplayed);
		}
	}

	public void ResetAllQuips()
	{
		_indoorUnplayed = new List<int>();
		_outdoorUnplayed = new List<int>();
		_shootUnplayed = new List<int>();
		_petUnplayed = new List<int>();
		SetupIndoorList();
		SetupOutdoorList();
		SetupShootList();
		SetupPetList();
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!_audioSource.isPlaying && QuipsEnabled && !_ai.hasPath)
		{
			if (other.CompareTag("crushObj") || other.CompareTag("Ice"))
			{
				UnloadAudio();
				_audioSource.clip = GetShoot();
				_audioSource.Play();
				References.Subtitles.DisplayText(_audioSource.clip.name, _audioSource.clip.length, _audioSource);
			}
			else if (other.CompareTag("Player Hand"))
			{
				UnloadAudio();
				_audioSource.clip = GetPet();
				_audioSource.Play();
				References.Subtitles.DisplayText(_audioSource.clip.name, _audioSource.clip.length, _audioSource);
			}
		}
	}

	private void UnloadAudio()
	{
		if (_audioSource.clip != null)
		{
			if (_audioSource.isPlaying)
			{
				_audioSource.Stop();
			}
			_audioSource.clip.UnloadAudioData();
		}
	}

	public void GrabWith(Hand hand)
	{
	}

	public Transform GetGripSnapPoint(Hand hand)
	{
		return centerTransform;
	}

	public bool CanGrab()
	{
		return true;
	}
}
public class OdinView : Singleton<OdinView>
{
	public Transform viewPosition;

	public GameObject meshes;

	public float viewTransitionSpeed;

	public LayerMask viewTransitionLayerMask;

	private bool _isSeeing;

	private bool _isTransitioning;

	private Player _player;

	private Transform _headset;

	private void Start()
	{
		_player = Player.Instance;
		_headset = References.Headset;
	}

	private void OnEnable()
	{
		GameEvent odinViewRequested = References.OdinViewRequested;
		odinViewRequested.OnTrue = (System.Action)Delegate.Combine(odinViewRequested.OnTrue, new System.Action(OnEventRaised));
		GameEvent onPlayerDamaged = References.OnPlayerDamaged;
		onPlayerDamaged.OnTrue = (System.Action)Delegate.Combine(onPlayerDamaged.OnTrue, new System.Action(OnPlayerDamaged));
	}

	private void OnDisable()
	{
		if (References.IsInitialized)
		{
			GameEvent odinViewRequested = References.OdinViewRequested;
			odinViewRequested.OnTrue = (System.Action)Delegate.Remove(odinViewRequested.OnTrue, new System.Action(OnEventRaised));
			GameEvent onPlayerDamaged = References.OnPlayerDamaged;
			onPlayerDamaged.OnTrue = (System.Action)Delegate.Remove(onPlayerDamaged.OnTrue, new System.Action(OnPlayerDamaged));
		}
	}

	public void OnEventRaised()
	{
		if (!_isTransitioning && !References.OdinVisionLock.IsLocked())
		{
			RaycastHit hitInfo;
			if (_isSeeing)
			{
				EndView();
			}
			else if (!Player.Instance.IsFalling() && !References.PlayerInterfaceLock.IsLocked() && !References.PlayerMoveTeleportLock.IsLocked() && Player.Instance.IsInValidLocation && Physics.Raycast(viewPosition.position, References.Headset.position - viewPosition.position, out hitInfo, 100f, viewTransitionLayerMask) && hitInfo.transform != null && hitInfo.transform.GetComponentInParent<VRSystem>() != null)
			{
				_isSeeing = true;
				References.OdinViewTransition.RaiseTrue();
				Timing.RunCoroutine(ControlCamera(), Segment.LateUpdate);
			}
		}
	}

	public void OnPlayerDamaged()
	{
		if (_isSeeing)
		{
			if (_isTransitioning)
			{
				GameEvent odinView = References.OdinView;
				odinView.OnTrue = (System.Action)Delegate.Combine(odinView.OnTrue, new System.Action(EndView));
				GameEvent odinView2 = References.OdinView;
				odinView2.OnTrue = (System.Action)Delegate.Combine(odinView2.OnTrue, new System.Action(UnsetEndView));
			}
			else
			{
				EndView();
			}
		}
	}

	public static bool IsViewingOrTransitioning()
	{
		if (!Singleton<OdinView>.Instance._isSeeing)
		{
			return Singleton<OdinView>.Instance._isTransitioning;
		}
		return true;
	}

	private void EndView()
	{
		_isSeeing = false;
	}

	private void UnsetEndView()
	{
		GameEvent odinView = References.OdinView;
		odinView.OnTrue = (System.Action)Delegate.Remove(odinView.OnTrue, new System.Action(EndView));
		GameEvent odinView2 = References.OdinView;
		odinView2.OnTrue = (System.Action)Delegate.Remove(odinView2.OnTrue, new System.Action(UnsetEndView));
	}

	private IEnumerator<float> ControlCamera()
	{
		References.PlayerMoveTeleportLock.LockUsing(base.gameObject);
		References.PlayerInterfaceLock.LockUsing(base.gameObject);
		Transform headCollider = References.HeadCollider.transform;
		Transform relativeTo = ((_player.splineController != null) ? _player.splineController.transform : _player.Surface);
		RelativeLocation returnPos = new RelativeLocation(relativeTo, _player.GetPosition(), _headset.forward);
		RelativeLocation returnHeadPos = new RelativeLocation(relativeTo, _player.GetHeadPosition(), _headset.forward);
		Vector3 lastPos = References.TrackingSpaceTransform.position;
		Vector3 lastHeadPos = headCollider.position;
		_isTransitioning = true;
		yield return float.NegativeInfinity;
		while (_isSeeing)
		{
			float num = viewTransitionSpeed * Time.deltaTime;
			Vector3 vector = viewPosition.position - (_headset.position - References.TrackingSpaceTransform.position);
			if (Vector3.Distance(lastPos, vector) > num)
			{
				lastPos = Vector3.MoveTowards(lastPos, vector, num);
			}
			else
			{
				lastPos = vector;
				if (_isTransitioning)
				{
					_isTransitioning = false;
					meshes.SetActive(value: false);
					References.OdinView.RaiseTrue();
					_headset.GetComponentInChildren<Camera>().cullingMask |= 4194304;
				}
			}
			References.TrackingSpaceTransform.position = lastPos;
			yield return float.NegativeInfinity;
		}
		_headset.GetComponentInChildren<Camera>().cullingMask &= -4194305;
		References.OdinView.RaiseFalse();
		meshes.SetActive(value: true);
		_isTransitioning = true;
		References.TrackingSpaceTransform.position = viewPosition.position - (_headset.position - References.TrackingSpaceTransform.position);
		Vector3 worldPos;
		while (true)
		{
			float num2 = viewTransitionSpeed * Time.deltaTime;
			worldPos = returnPos.GetWorldPos();
			if (!(Vector3.Distance(lastPos, worldPos) > num2))
			{
				break;
			}
			lastPos = Vector3.MoveTowards(lastPos, worldPos, num2);
			_player.SetPosition(lastPos, useHeadPosition: false, setValid: false);
			yield return float.NegativeInfinity;
		}
		_player.SetPosition(worldPos, useHeadPosition: false, setValid: false);
		yield return float.NegativeInfinity;
		yield return float.NegativeInfinity;
		int num3 = Physics.RaycastNonAlloc(lastHeadPos, headCollider.position - lastHeadPos, Utilities.raycastHitPool, Vector3.Distance(lastHeadPos, headCollider.position), References.HeadColliderScript.playerCollisionLayers, QueryTriggerInteraction.Ignore);
		for (int i = 0; i < num3; i++)
		{
			_player.SetPosition(returnHeadPos.GetWorldPos(), useHeadPosition: true, setValid: false);
		}
		References.PlayerMoveTeleportLock.Unlock(base.gameObject);
		References.PlayerInterfaceLock.Unlock(base.gameObject);
		_isTransitioning = false;
		References.OdinViewTransition.RaiseFalse();
	}
}
[RequireComponent(typeof(UniqueId))]
public class Perch : MonoBehaviour
{
	private static List<Perch> activePerches = new List<Perch>();

	private void OnEnable()
	{
		activePerches.Add(this);
	}

	private void OnDisable()
	{
		activePerches.Remove(this);
	}

	public static Transform FindClosest(Vector3 position)
	{
		float num = float.MaxValue;
		Perch perch = null;
		for (int i = 0; i < activePerches.Count; i++)
		{
			float num2 = Vector3.Distance(position, activePerches[i].transform.position);
			if (!(num2 < num))
			{
				continue;
			}
			int num3 = Physics.RaycastNonAlloc(activePerches[i].transform.position, References.Headset.position - activePerches[i].transform.position, Utilities.raycastHitPool, num2, References.SolidLayers);
			if (num3 > 0)
			{
				Array.Sort(Utilities.raycastHitPool, 0, num3, Utilities.RaycastHitDistanceComparer.Comparer);
			}
			bool flag = false;
			for (int j = 0; j < num3; j++)
			{
				Transform transform = Utilities.raycastHitPool[j].transform;
				if (transform.IsChildOf(activePerches[i].transform) || activePerches[i].transform.IsChildOf(transform))
				{
					break;
				}
				if (!transform.IsChildOf(Singleton<VRSystem>.Instance.transform))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				perch = activePerches[i];
				num = num2;
			}
		}
		if (perch != null)
		{
			return perch.transform;
		}
		return null;
	}
}
public class ParticleSpeechAnimator : MonoBehaviour
{
	public AudioSource audioSource;

	public List<ParticleSystem> particles = new List<ParticleSystem>();

	public Color baseColor = new Color(0.5f, 0f, 0f, 1f);

	public Color highlightColor = Color.white;

	public float baseSize = 1f;

	public float highlightSize = 2f;

	private float _voiceIntensity;

	private CoroutineHandle handle;

	public void OnEnable()
	{
		handle = Timing.RunCoroutine(TrackAudio());
	}

	public void OnDisable()
	{
		Timing.KillCoroutines(handle);
	}

	public IEnumerator<float> TrackAudio()
	{
		float[] spectrum = new float[64];
		List<float> recentIntensity = new List<float>();
		while (true)
		{
			if (audioSource.isPlaying)
			{
				float num = 0f;
				audioSource.GetSpectrumData(spectrum, 0, FFTWindow.BlackmanHarris);
				float[] array = spectrum;
				foreach (float num2 in array)
				{
					if (num2 > num)
					{
						num = num2;
					}
				}
				float item = Mathf.Sqrt(num) / 0.5f;
				recentIntensity.Add(item);
				if (recentIntensity.Count > 5)
				{
					recentIntensity.RemoveAt(0);
				}
				_voiceIntensity = recentIntensity.Average();
				foreach (ParticleSystem particle in particles)
				{
					ParticleSystem.MainModule main = particle.main;
					main.startColor = new ParticleSystem.MinMaxGradient(baseColor + _voiceIntensity * highlightColor);
					main.startSizeMultiplier = baseSize + _voiceIntensity * highlightSize;
				}
			}
			yield return 0f;
		}
	}
}
public class PauseParticles : MonoBehaviour
{
	private ParticleSystem.MainModule particleMain;

	private void Start()
	{
		particleMain = GetComponent<ParticleSystem>().main;
		GameEvent onGamePaused = References.OnGamePaused;
		onGamePaused.OnTrue = (System.Action)Delegate.Combine(onGamePaused.OnTrue, new System.Action(OnPause));
		GameEvent onGamePaused2 = References.OnGamePaused;
		onGamePaused2.OnFalse = (System.Action)Delegate.Combine(onGamePaused2.OnFalse, new System.Action(OnUnpause));
	}

	private void OnDestroy()
	{
		GameEvent onGamePaused = References.OnGamePaused;
		onGamePaused.OnTrue = (System.Action)Delegate.Remove(onGamePaused.OnTrue, new System.Action(OnPause));
		GameEvent onGamePaused2 = References.OnGamePaused;
		onGamePaused2.OnFalse = (System.Action)Delegate.Remove(onGamePaused2.OnFalse, new System.Action(OnUnpause));
	}

	private void OnPause()
	{
		particleMain.useUnscaledTime = false;
	}

	private void OnUnpause()
	{
		particleMain.useUnscaledTime = true;
	}
}
public class PoisonOrb : GameObjectPoolable, IDamageable, ITargetable
{
	public GameObject explosion;

	public GameObject core;

	public Collider coreCollider;

	public GameObject damageZone;

	public FloatReference speed;

	public float seekTime;

	public float turningSpeed;

	public float targetHeightOffset;

	public float explodeDistance;

	public float explodeCountdown;

	public float damageDuration;

	public float cloudDuration;

	private Transform _target;

	private float _currentSpeed;

	private bool _hasExploded;

	private CoroutineHandle _handle;

	private void OnEnable()
	{
		_hasExploded = false;
		_target = Player.Instance.transform;
		Timing.RunCoroutine(TrackPlayer());
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Combine(onPlayerRespawn.OnTrue, new System.Action(OnPlayerRespawn));
	}

	private void OnDisable()
	{
		GameEvent onPlayerRespawn = References.OnPlayerRespawn;
		onPlayerRespawn.OnTrue = (System.Action)Delegate.Remove(onPlayerRespawn.OnTrue, new System.Action(OnPlayerRespawn));
	}

	private void OnPlayerRespawn()
	{
		Timing.KillCoroutines(_handle);
		damageZone.SetActive(value: false);
		explosion.SetActive(value: false);
		core.SetActive(value: true);
		coreCollider.enabled = true;
		base.Pool.ReturnToPool(base.gameObject);
	}

	private IEnumerator<float> TrackPlayer()
	{
		float t = Time.time + seekTime;
		base.transform.rotation = Quaternion.LookRotation(_target.position + Vector3.up * targetHeightOffset - base.transform.position);
		while (Time.time < t)
		{
			if (_hasExploded)
			{
				yield break;
			}
			Vector3 vector = _target.position + Vector3.up * targetHeightOffset;
			if (base.transform.HasClearPathToTarget(new Ray(base.transform.position, vector - base.transform.position), _target, 30f))
			{
				base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, Quaternion.LookRotation(vector - base.transform.position), turningSpeed * Time.deltaTime);
			}
			base.transform.position += base.transform.forward * speed * Time.deltaTime;
			float num = Vector3.Distance(vector, base.transform.position);
			coreCollider.enabled = false;
			if (num <= explodeDistance || Physics.CheckSphere(base.transform.position, 0.11f, References.SolidLayers, QueryTriggerInteraction.Ignore))
			{
				coreCollider.enabled = true;
				Timing.RunCoroutine(Explode());
				yield break;
			}
			coreCollider.enabled = true;
			yield return float.NegativeInfinity;
		}
		_handle = Timing.RunCoroutine(ExplodeCountdown());
	}

	private IEnumerator<float> ExplodeCountdown()
	{
		float t = Time.time + explodeCountdown;
		_currentSpeed = speed;
		while (Time.time < t)
		{
			if (_hasExploded)
			{
				yield break;
			}
			_currentSpeed = Mathf.Lerp(_currentSpeed, 0f, Time.deltaTime);
			base.transform.position += base.transform.forward * _currentSpeed * Time.deltaTime;
			yield return float.NegativeInfinity;
		}
		_handle = Timing.RunCoroutine(Explode());
	}

	private IEnumerator<float> Explode()
	{
		explosion.SetActive(value: true);
		damageZone.SetActive(value: true);
		core.SetActive(value: false);
		_hasExploded = true;
		yield return Timing.WaitForSeconds(damageDuration);
		damageZone.SetActive(value: false);
		yield return Timing.WaitForSeconds(cloudDuration - damageDuration);
		explosion.SetActive(value: false);
		core.SetActive(value: true);
		coreCollider.enabled = true;
		base.Pool.ReturnToPool(base.gameObject);
	}

	public IDamageable GetTarget()
	{
		return this;
	}

	public void ApplyDamage(int amount, string source, DamageType type = DamageType.None)
	{
		if (!_hasExploded && type != DamageType.Poison)
		{
			_handle = Timing.RunCoroutine(Explode());
		}
	}

	public bool IsDestroyed()
	{
		return _hasExploded;
	}

	public bool IsTargetable()
	{
		return !_hasExploded;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!_hasExploded)
		{
			_handle = Timing.RunCoroutine(Explode());
		}
	}
}
[CreateAssetMenu(menuName = "Custom/GameObjectPool")]
public class GameObjectPool : ScriptableObject
{
	[SerializeField]
	private GameObject prefab;

	[SerializeField]
	private int initialCount;

	private GameObjectRuntimePool _pool;

	public void Initialize()
	{
		_pool = new GameObjectRuntimePool(prefab, initialCount);
	}

	public GameObject Get()
	{
		if (_pool == null)
		{
			Initialize();
		}
		return _pool.Get();
	}

	public void ReturnToPool(GameObject objectToReturn)
	{
		_pool.ReturnToPool(objectToReturn);
	}
}
public class GameObjectRuntimePool
{
	private GameObject _prefab;

	private readonly Queue<GameObject> _objects = new Queue<GameObject>();

	public GameObjectRuntimePool(GameObject prefab, int initialCount = 0)
	{
		_prefab = prefab;
		AddObjects(initialCount - _objects.Count);
	}

	public GameObject Get()
	{
		if (_objects.Count == 0)
		{
			AddObjects(1);
		}
		if (_objects.Peek() == null)
		{
			_objects.Dequeue();
			AddObjects(1);
		}
		return _objects.Dequeue();
	}

	public void ReturnToPool(GameObject objectToReturn)
	{
		objectToReturn.SetActive(value: false);
		objectToReturn.transform.parent = GameObjectPoolContainer.Instance.transform;
		objectToReturn.transform.localScale = _prefab.transform.localScale;
		_objects.Enqueue(objectToReturn);
	}

	public void Destroy()
	{
		while (_objects.Count > 0)
		{
			UnityEngine.Object.Destroy(_objects.Dequeue());
		}
	}

	private void AddObjects(int count)
	{
		for (int i = 0; i < count; i++)
		{
			GameObject gameObject = UnityEngine.Object.Instantiate(_prefab);
			gameObject.gameObject.SetActive(value: false);
			_objects.Enqueue(gameObject);
			gameObject.GetComponent<IGameObjectPoolable>().Pool = this;
			gameObject.transform.parent = GameObjectPoolContainer.Instance.transform;
		}
	}
}
public class GameObjectPoolContainer : MonoBehaviour
{
	public List<GameObjectPool> initializeOnAwake = new List<GameObjectPool>();

	private static GameObjectPoolContainer _instance;

	public static GameObjectPoolContainer Instance
	{
		get
		{
			if (_instance == null)
			{
				GameObject obj = new GameObject("GameObjectPool Container");
				UnityEngine.Object.DontDestroyOnLoad(obj);
				_instance = obj.AddComponent<GameObjectPoolContainer>();
			}
			return _instance;
		}
	}

	private void Awake()
	{
		if (_instance == null)
		{
			UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
			_instance = this;
			for (int i = 0; i < initializeOnAwake.Count; i++)
			{
				initializeOnAwake[i].Initialize();
			}
		}
		else
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
}
public class GameObjectPoolLoader : MonoBehaviour
{
	public GameObjectPool pool;

	public Transform matchTransform;

	public GameObject poolableObject;

	public bool enableOnGet;

	public void Run()
	{
		Get();
	}

	public GameObject Get()
	{
		poolableObject = pool.Get();
		poolableObject.transform.SetPositionAndRotation(matchTransform.position, matchTransform.rotation);
		if (enableOnGet)
		{
			poolableObject.SetActive(value: true);
		}
		return poolableObject;
	}
}
public class GameObjectPoolable : MonoBehaviour, IGameObjectPoolable
{
	public GameObjectRuntimePool Pool { get; set; }
}
public interface IGameObjectPoolable
{
	GameObjectRuntimePool Pool { get; set; }
}
public class Poolable<T> where T : new()
{
	private static readonly Queue<T> queue = new Queue<T>();

	public static T Get()
	{
		if (queue.Count > 0)
		{
			return queue.Dequeue();
		}
		return new T();
	}

	public static void Return(T obj)
	{
		queue.Enqueue(obj);
	}
}
public class RandomAnimationPlayer : MonoBehaviour
{
	public string PlayRandomAnimation()
	{
		Animation component = GetComponent<Animation>();
		int num = UnityEngine.Random.Range(0, component.GetClipCount());
		int num2 = 0;
		foreach (AnimationState item in component)
		{
			if (num2++ == num)
			{
				component.Play(item.name);
				return item.name;
			}
		}
		return null;
	}

	public void SetToEndOfAnimation(string animation)
	{
		Animation component = GetComponent<Animation>();
		component.clip = component.GetClip(animation);
		component.Play();
		component[animation].normalizedTime = 1f;
	}
}
public class RandomSound : MonoBehaviour
{
	public AudioSource audioSource;

	public AudioClip[] clips;

	public void SetRandomClip()
	{
		audioSource.clip = clips[UnityEngine.Random.Range(0, clips.Length)];
	}

	public void PlayRandom()
	{
		audioSource.PlayOneShot(clips[UnityEngine.Random.Range(0, clips.Length)]);
	}

	public void PlayCurrent()
	{
		audioSource.Play();
	}
}
[CreateAssetMenu(menuName = "Custom/Room")]
public class Room : ScriptableObject
{
	public string localizationID;

	public string startingLocationID;

	public string perchID;

	public List<string> scenes;

	public int completedPuzzles;

	public bool hasFire;

	public bool hasIce;

	public bool hasShield;
}
public class RotatingPuzzle : MonoBehaviour
{
	public Transform[] pieces;

	public PlayMakerFSM fsm;

	public string eventOnComplete;

	public string eventOnIncomplete;

	private bool _isListening;

	private bool _complete;

	private IEnumerator Start()
	{
		_isListening = false;
		yield return new WaitForSeconds(0.5f);
		_isListening = true;
	}

	private void Update()
	{
		if (!_isListening)
		{
			return;
		}
		for (int i = 0; i < pieces.Length; i++)
		{
			if (Mathf.Abs(Mathf.DeltaAngle(pieces[i].localRotation.eulerAngles.y, 0f)) > 0.1f)
			{
				if (_complete)
				{
					fsm.SendEvent(eventOnIncomplete);
					_complete = false;
				}
				return;
			}
		}
		if (!_complete)
		{
			fsm.SendEvent(eventOnComplete);
			_complete = true;
		}
	}
}
public class RotatingPuzzleForge : MonoBehaviour
{
	public Transform[] pieces;

	public float[] correctAngle;

	public Transform pipe2Marker;

	private void Update()
	{
		for (int i = 0; i < pieces.Length; i++)
		{
			if (Mathf.Abs(Mathf.DeltaAngle(pieces[i].localRotation.eulerAngles.y, correctAngle[i])) > 0.1f)
			{
				return;
			}
		}
		if (!(Vector3.Distance(pieces[1].position, pipe2Marker.position) > 0.1f))
		{
			HintSystem.CompletePuzzle("7B");
			base.gameObject.SetActive(value: false);
		}
	}
}
public static class SceneStateManager
{
	private class PreloadOperation
	{
		public string scene;

		public AsyncOperation async;
	}

	private class RoomState
	{
		public Room room;

		public LoadStatus status;
	}

	private enum LoadStatus
	{
		Unloaded,
		Preloaded,
		Loaded
	}

	private class SceneState
	{
		public string scene;

		public SaveSceneData data;

		public AsyncOperation async;

		public readonly HashSet<Room> usedByLoadedRooms = new HashSet<Room>();

		private static readonly Dictionary<string, SceneState> _sceneStates = new Dictionary<string, SceneState>();

		private LoadStatus _status;

		public void Preload(Room room)
		{
			if (_status == LoadStatus.Unloaded)
			{
				async = SceneManager.LoadSceneAsync(scene, LoadSceneMode.Additive);
				async.allowSceneActivation = false;
				_preloadOperations.Enqueue(new PreloadOperation
				{
					scene = scene,
					async = async
				});
				_status = LoadStatus.Preloaded;
			}
		}

		public IEnumerator<float> Load(Room room, bool forceLoadData = false)
		{
			if (room != null)
			{
				usedByLoadedRooms.Add(room);
			}
			if (_status == LoadStatus.Loaded)
			{
				if (forceLoadData)
				{
					yield return Timing.WaitUntilDone(Setup());
				}
				yield break;
			}
			if (_status == LoadStatus.Preloaded)
			{
				do
				{
					PreloadOperation operation = _preloadOperations.Dequeue();
					operation.async.allowSceneActivation = true;
					yield return Timing.WaitUntilTrue(() => operation.async.isDone);
					_sceneStates[operation.scene]._status = LoadStatus.Loaded;
				}
				while (_status == LoadStatus.Preloaded);
			}
			else
			{
				SceneManager.LoadScene(scene, LoadSceneMode.Additive);
				_status = LoadStatus.Loaded;
			}
			yield return Timing.WaitUntilDone(Setup());
		}

		public IEnumerator<float> Unload(Room room, bool saveData = true)
		{
			if (room != null && GetRoomStatus(room) == LoadStatus.Loaded)
			{
				usedByLoadedRooms.Remove(room);
			}
			if (usedByLoadedRooms.Count > 0)
			{
				yield break;
			}
			if (_status == LoadStatus.Preloaded)
			{
				yield return Timing.WaitUntilDone(Load(room));
			}
			if (_status == LoadStatus.Loaded)
			{
				if (saveData)
				{
					data = SaveSceneManager.SaveScene(scene);
				}
				SceneManager.UnloadSceneAsync(scene);
				_status = LoadStatus.Unloaded;
			}
		}

		public IEnumerator<float> Setup()
		{
			if (data != null)
			{
				yield return float.NegativeInfinity;
				SaveSceneManager.LoadScene(data);
			}
		}

		public static void ClearAllData()
		{
			foreach (SceneState value in _sceneStates.Values)
			{
				value.data = null;
			}
		}

		public static List<SaveSceneData> GetSceneData()
		{
			List<SaveSceneData> list = new List<SaveSceneData>();
			foreach (SceneState value in _sceneStates.Values)
			{
				if (value._status == LoadStatus.Loaded)
				{
					value.data = SaveSceneManager.SaveScene(value.scene);
				}
				if (value.data != null)
				{
					list.Add(value.data);
				}
			}
			return list;
		}

		public static SceneState Get(string scene)
		{
			if (!_sceneStates.ContainsKey(scene))
			{
				_sceneStates.Add(scene, new SceneState
				{
					scene = scene
				});
			}
			return _sceneStates[scene];
		}
	}

	private static readonly Dictionary<Room, RoomState> _roomStates = new Dictionary<Room, RoomState>();

	private static readonly Queue<PreloadOperation> _preloadOperations = new Queue<PreloadOperation>();

	private static Room _lastLoadedRoom;

	private static LoadStatus GetRoomStatus(Room room)
	{
		if (!_roomStates.ContainsKey(room))
		{
			_roomStates.Add(room, new RoomState
			{
				room = room,
				status = LoadStatus.Unloaded
			});
		}
		return _roomStates[room].status;
	}

	private static void SetRoomStatus(Room room, LoadStatus status)
	{
		if (!_roomStates.ContainsKey(room))
		{
			_roomStates.Add(room, new RoomState
			{
				room = room,
				status = status
			});
		}
		else
		{
			_roomStates[room].status = status;
		}
	}

	public static Room GetLastLoadedRoom()
	{
		return _lastLoadedRoom;
	}

	public static void PreloadRoom(Room room)
	{
		if (GetRoomStatus(room) == LoadStatus.Unloaded)
		{
			SetRoomStatus(room, LoadStatus.Preloaded);
			for (int i = 0; i < room.scenes.Count; i++)
			{
				SceneState.Get(room.scenes[i]).Preload(room);
			}
		}
	}

	public static IEnumerator<float> LoadRoom(Room room, bool forceLoadData = false)
	{
		if (forceLoadData || GetRoomStatus(room) != LoadStatus.Loaded)
		{
			SetRoomStatus(room, LoadStatus.Loaded);
			for (int i = 0; i < room.scenes.Count; i++)
			{
				yield return Timing.WaitUntilDone(SceneState.Get(room.scenes[i]).Load(room, forceLoadData));
			}
		}
		_lastLoadedRoom = room;
	}

	public static IEnumerator<float> UnloadRoom(Room room, bool saveData = true)
	{
		if (GetRoomStatus(room) != 0)
		{
			for (int i = 0; i < room.scenes.Count; i++)
			{
				yield return Timing.WaitUntilDone(SceneState.Get(room.scenes[i]).Unload(room, saveData));
			}
			SetRoomStatus(room, LoadStatus.Unloaded);
		}
	}

	public static IEnumerator<float> SetRooms(List<Room> loaded, List<Room> preloaded, bool forceLoadData = false)
	{
		foreach (Room key in _roomStates.Keys)
		{
			if (_roomStates[key].status != 0 && !loaded.Contains(key))
			{
				yield return Timing.WaitUntilDone(UnloadRoom(key, saveData: false));
			}
		}
		for (int i = 0; i < loaded.Count; i++)
		{
			yield return Timing.WaitUntilDone(LoadRoom(loaded[i], forceLoadData));
		}
		for (int j = 0; j < preloaded.Count; j++)
		{
			PreloadRoom(preloaded[j]);
		}
	}

	public static IEnumerator<float> SetRooms(List<string> loaded, List<string> preloaded, bool forceLoadData = false)
	{
		List<Room> list = new List<Room>();
		List<Room> list2 = new List<Room>();
		for (int i = 0; i < loaded.Count; i++)
		{
			list.Add(References.GetRoom(loaded[i]));
		}
		for (int j = 0; j < preloaded.Count; j++)
		{
			list2.Add(References.GetRoom(preloaded[j]));
		}
		yield return Timing.WaitUntilDone(SetRooms(list, list2, forceLoadData));
	}

	public static void SetSceneData(List<SaveSceneData> data)
	{
		SceneState.ClearAllData();
		if (data != null)
		{
			for (int i = 0; i < data.Count; i++)
			{
				SceneState.Get(data[i].sceneName).data = data[i];
			}
		}
	}

	public static List<SaveSceneData> GetSceneData()
	{
		return SceneState.GetSceneData();
	}

	public static List<string> GetPreloadedRooms()
	{
		List<string> list = new List<string>();
		foreach (Room key in _roomStates.Keys)
		{
			if (_roomStates[key].status == LoadStatus.Preloaded)
			{
				list.Add(key.name);
			}
		}
		return list;
	}

	public static List<string> GetLoadedRooms()
	{
		List<string> list = new List<string>();
		foreach (Room key in _roomStates.Keys)
		{
			if (_roomStates[key].status == LoadStatus.Loaded)
			{
				list.Add(key.name);
			}
		}
		return list;
	}
}
public class Checkpoint : MonoBehaviour
{
	public bool overridePlayerPosition;

	public GameObject[] serializableObjects;

	public PlayMakerFSM[] FSMs;

	public Transform[] transformHierarchies;

	public void SetCheckpoint()
	{
		SaveSystem.Save(overridePlayerPosition ? base.transform : null);
	}
}
public interface ISaveData
{
	void Serialize(ISaveSerializable target);

	void Deserialize(ISaveSerializable target);
}
public interface ISaveSerializable
{
	ISaveData Serialize();

	void Deserialize(ISaveData saveData);

	string SerializeString();

	void Deserialize(string saveData);
}
[Serializable]
public class FSMData
{
	[SerializeField]
	private string _state;

	[SerializeField]
	private bool _isEnabled;

	[SerializeField]
	private FsmVariables _variables;

	[SerializeField]
	private List<string> _gameObjectVarIds = new List<string>();

	[SerializeField]
	private List<string> _objectVarIds = new List<string>();

	public FSMData(PlayMakerFSM fsm)
	{
		_state = fsm.ActiveStateName;
		_isEnabled = fsm.enabled;
		_variables = new FsmVariables(fsm.FsmVariables);
		for (int i = 0; i < _variables.GameObjectVariables.Length; i++)
		{
			GameObject value = _variables.GameObjectVariables[i].Value;
			UniqueId component;
			if (value == null)
			{
				_gameObjectVarIds.Add("null");
			}
			else if (value.TryGetComponent<UniqueId>(out component))
			{
				_gameObjectVarIds.Add(component.uniqueId);
			}
			else
			{
				_gameObjectVarIds.Add(null);
			}
		}
		for (int j = 0; j < _variables.ObjectVariables.Length; j++)
		{
			UnityEngine.Object value2 = _variables.ObjectVariables[j].Value;
			UniqueId component2;
			if (value2 == null)
			{
				_objectVarIds.Add("null");
			}
			else if (((Component)value2).TryGetComponent<UniqueId>(out component2))
			{
				_objectVarIds.Add(component2.uniqueId);
			}
			else
			{
				_objectVarIds.Add(null);
			}
		}
	}

	public void Deserialize(PlayMakerFSM fsm)
	{
		fsm.enabled = _isEnabled;
		for (int i = 0; i < _variables.GameObjectVariables.Length; i++)
		{
			if (_gameObjectVarIds[i] == "null")
			{
				_variables.GameObjectVariables[i].Value = null;
			}
			else if (!string.IsNullOrEmpty(_gameObjectVarIds[i]))
			{
				GameObject gameObject = UniqueId.Find(_gameObjectVarIds[i]);
				if (gameObject != null)
				{
					_variables.GameObjectVariables[i].Value = gameObject;
				}
				else
				{
					_variables.GameObjectVariables[i].Value = fsm.FsmVariables.GameObjectVariables[i].Value;
				}
			}
			else
			{
				_variables.GameObjectVariables[i].Value = fsm.FsmVariables.GameObjectVariables[i].Value;
			}
		}
		for (int j = 0; j < _variables.ObjectVariables.Length; j++)
		{
			if (_objectVarIds[j] == "null")
			{
				_variables.ObjectVariables[j].Value = null;
			}
			else if (!string.IsNullOrEmpty(_objectVarIds[j]))
			{
				GameObject gameObject = UniqueId.Find(_objectVarIds[j]);
				if (gameObject != null)
				{
					Component component = gameObject.GetComponent(fsm.FsmVariables.ObjectVariables[j].ObjectType);
					if (component != null)
					{
						_variables.ObjectVariables[j].Value = component;
					}
					else
					{
						_variables.ObjectVariables[j].Value = fsm.FsmVariables.ObjectVariables[j].Value;
					}
				}
				else
				{
					_variables.ObjectVariables[j].Value = fsm.FsmVariables.ObjectVariables[j].Value;
				}
			}
			else
			{
				_variables.ObjectVariables[j].Value = fsm.FsmVariables.ObjectVariables[j].Value;
			}
		}
		try
		{
			fsm.FsmVariables.ApplyVariableValues(_variables);
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(fsm.name + ": " + ex.Message);
		}
		if (fsm.ActiveStateName != _state)
		{
			fsm.SetState(_state);
		}
	}
}
[Serializable]
public class AnimatorData
{
	[SerializeField]
	private bool _isEnabled;

	[SerializeField]
	private bool _applyRootMotion;

	public AnimatorData(Animator animator)
	{
		_isEnabled = animator.enabled;
		_applyRootMotion = animator.applyRootMotion;
	}

	public void Deserialize(Animator animator)
	{
		animator.enabled = _isEnabled;
		animator.applyRootMotion = _applyRootMotion;
	}
}
[Serializable]
public class MaterialData
{
	[SerializeField]
	private Color _color;

	[SerializeField]
	private Color? _emissionColor;

	[SerializeField]
	private Texture _texture;

	public MaterialData(Material material)
	{
		_color = material.color;
		try
		{
			_emissionColor = material.GetColor("_EmissionColor");
		}
		catch (Exception)
		{
			_emissionColor = null;
		}
		_texture = material.mainTexture;
	}

	public void Deserialize(Material material)
	{
		material.color = _color;
		if (_emissionColor.HasValue)
		{
			material.SetColor("_EmissionColor", _emissionColor.Value);
		}
		material.mainTexture = _texture;
	}
}
[Serializable]
public class TransformSaveData
{
	[SerializeField]
	private Vector3 _position;

	[SerializeField]
	private Vector3 _scale;

	[SerializeField]
	private Quaternion _rotation;

	[SerializeField]
	private string _parent;

	[SerializeField]
	private bool _active;

	public TransformSaveData(Transform transform)
	{
		if (transform.parent != null && transform.parent.TryGetComponent<UniqueId>(out var component))
		{
			_parent = component.uniqueId;
		}
		_position = transform.localPosition;
		_scale = transform.localScale;
		_rotation = transform.localRotation;
		_active = transform.gameObject.activeSelf;
	}

	public void Deserialize(Transform transform)
	{
		Transform transform2 = UniqueId.FindTransform(_parent);
		if (transform2 != null)
		{
			transform.SetParent(transform2);
		}
		transform.localPosition = _position;
		transform.localScale = _scale;
		transform.localRotation = _rotation;
		transform.gameObject.SetActive(_active);
	}
}
[Serializable]
public class ActiveData : ISaveData
{
	[SerializeField]
	private bool _isActive;

	public void Serialize(ISaveSerializable target)
	{
		Component component = (Component)target;
		_isActive = component.gameObject.activeSelf;
	}

	public void Deserialize(ISaveSerializable target)
	{
		((Component)target).gameObject.SetActive(_isActive);
	}
}
public class ProfileManager : MonoBehaviour
{
	[Serializable]
	public class Profile
	{
		public int ID;

		public string room;

		public bool hasData;

		public long dateTime;

		public Settings.PlayerSettings settings;

		public int menuquips;

		public Profile(int id)
		{
			ID = id;
			settings = new Settings.PlayerSettings();
		}
	}

	[Serializable]
	private class ProfileIndex
	{
		public Profile[] profiles = new Profile[5];

		public int lastProfile;

		public AchievementManager.AchievementStatus[] achievements = new AchievementManager.AchievementStatus[10];

		public int version = 1;
	}

	public GameObject selectProfileLabel;

	public TextMeshProUGUI profileLabel;

	public TextMeshProUGUI[] profileNames;

	public TextMeshProUGUI[] profileDates;

	public Toggle[] profileToggles;

	public GameObject[] deleteButtons;

	public GameObject continueButton;

	public GameObject resumeButton;

	public GameObject newGameButton;

	private static Profile _activeProfile;

	private static Profile _selectedProfile;

	private static ProfileIndex _index;

	private int _deleteProfile;

	private void Start()
	{
		if (_index.profiles[_index.lastProfile] != null)
		{
			OdinMenu.playedClips = _index.profiles[_index.lastProfile].menuquips;
			Settings.Current = _index.profiles[_index.lastProfile].settings.Copy();
			Settings.ApplySettings();
		}
	}

	private void OnEnable()
	{
		RefreshProfileIndex();
		selectProfileLabel.SetActive(value: true);
		profileLabel.gameObject.SetActive(value: false);
	}

	private void RefreshProfileIndex()
	{
		if (File.Exists(UnityEngine.Application.persistentDataPath + "/Profiles.sav"))
		{
			_index = JsonUtility.FromJson<ProfileIndex>(File.ReadAllText(UnityEngine.Application.persistentDataPath + "/Profiles.sav"));
		}
		else
		{
			_index = new ProfileIndex();
		}
		for (int i = 0; i < _index.profiles.Length; i++)
		{
			if (_index.profiles[i] == null)
			{
				_index.profiles[i] = new Profile(i + 1);
			}
			if (_index.profiles[i].hasData)
			{
				deleteButtons[i].SetActive(value: true);
				DateTime dateTime = new DateTime(_index.profiles[i].dateTime);
				Room room = References.GetRoom(_index.profiles[i].room);
				profileNames[i].GetComponent<LocalizeText>().UpdateText();
				if (room != null)
				{
					profileNames[i].SetText(profileNames[i].text + ": " + LocalizationManager.GetText(room.localizationID));
				}
				profileDates[i].SetText(dateTime.ToShortDateString() + " " + dateTime.ToShortTimeString());
			}
			else
			{
				profileNames[i].GetComponent<LocalizeText>().UpdateText();
				profileDates[i].SetText(string.Empty);
				deleteButtons[i].SetActive(value: false);
			}
		}
	}

	public static void UpdateActiveProfileData()
	{
		_index.lastProfile = _activeProfile.ID - 1;
		_activeProfile.room = SceneStateManager.GetLastLoadedRoom().name;
		_activeProfile.settings = Settings.Current.Copy();
		_activeProfile.dateTime = DateTime.Now.Ticks;
		_activeProfile.menuquips = OdinMenu.playedClips;
		_activeProfile.hasData = true;
	}

	public static void SaveProfileIndex()
	{
		File.WriteAllText(UnityEngine.Application.persistentDataPath + "/Profiles.sav", JsonUtility.ToJson(_index));
	}

	public static Profile GetActiveProfile()
	{
		return _activeProfile;
	}

	public static void SetActiveProfile()
	{
		_activeProfile = _selectedProfile;
	}

	public static Profile GetSelectedProfile()
	{
		return _selectedProfile;
	}

	public void SelectProfile(int id)
	{
		if (profileToggles[id].isOn)
		{
			_selectedProfile = _index.profiles[id];
			profileLabel.GetComponent<LocalizeText>().textID = profileNames[id].GetComponent<LocalizeText>().textID;
			continueButton.SetActive(_selectedProfile.hasData && _selectedProfile != _activeProfile);
			newGameButton.SetActive(!_selectedProfile.hasData);
			resumeButton.SetActive(_activeProfile != null && id + 1 == _activeProfile.ID);
			Settings.Current = _selectedProfile.settings.Copy();
			Settings.ApplySettings();
			selectProfileLabel.SetActive(value: false);
			profileLabel.gameObject.SetActive(value: true);
			OdinMenu.playedClips = _selectedProfile.menuquips;
			Singleton<OdinMenu>.Instance.PlayClip(3);
		}
	}

	public void DeleteProfile(int id)
	{
		_deleteProfile = id;
	}

	public void DeleteProfile()
	{
		File.Delete(UnityEngine.Application.persistentDataPath + $"/Profile{_deleteProfile + 1}.sav");
		_index.profiles[_deleteProfile] = new Profile(_deleteProfile + 1);
		SaveProfileIndex();
		if (_activeProfile != null && _activeProfile.ID == _deleteProfile + 1)
		{
			Clear();
		}
		RefreshProfileIndex();
	}

	public static void Clear()
	{
		_activeProfile = null;
		_selectedProfile = null;
	}

	public static bool UpdateAchievement(int id, AchievementManager.AchievementStatus status)
	{
		bool result = false;
		if (_index.achievements[id] == null)
		{
			_index.achievements[id] = status;
			result = true;
		}
		else
		{
			AchievementManager.AchievementStatus achievementStatus = _index.achievements[id];
			if (status.achieved && !achievementStatus.achieved)
			{
				achievementStatus.achieved = true;
				result = true;
			}
			else if (!status.achieved && achievementStatus.achieved)
			{
				References.AchievementManager.SetAchievement(id, achievementStatus);
			}
			if (status.count > achievementStatus.count)
			{
				achievementStatus.count = status.count;
				result = true;
			}
			else if (achievementStatus.count > status.count)
			{
				References.AchievementManager.SetAchievement(id, achievementStatus);
			}
			if (achievementStatus.bitfield.Length != status.bitfield.Length)
			{
				achievementStatus.bitfield = status.bitfield;
				result = true;
			}
			else
			{
				StringBuilder stringBuilder = new StringBuilder(achievementStatus.bitfield);
				for (int i = 0; i < stringBuilder.Length; i++)
				{
					if (achievementStatus.bitfield[i] == '0' && status.bitfield[i] == '1')
					{
						result = true;
					}
					stringBuilder[i] = ((achievementStatus.bitfield[i] == '1' || status.bitfield[i] == '1') ? '1' : '0');
				}
				achievementStatus.bitfield = stringBuilder.ToString();
				if (achievementStatus.bitfield != status.bitfield)
				{
					References.AchievementManager.SetAchievement(id, achievementStatus);
				}
			}
		}
		return result;
	}

	public static AchievementManager.AchievementStatus GetAchievement(int id)
	{
		return _index.achievements[id];
	}
}
public class SaveActive : MonoBehaviour, ISaveSerializable
{
	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		ActiveData activeData = new ActiveData();
		activeData.Serialize(this);
		return activeData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((ActiveData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<ActiveData>(saveData).Deserialize(this);
	}
}
public class SaveCollider : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	private class ColliderData : ISaveData
	{
		[SerializeField]
		private bool _colliderIsActive;

		public void Serialize(ISaveSerializable target)
		{
			if (((SaveCollider)target).TryGetComponent<Collider>(out var component))
			{
				_colliderIsActive = component.enabled;
			}
		}

		public void Deserialize(ISaveSerializable target)
		{
			if (((SaveCollider)target).TryGetComponent<Collider>(out var component))
			{
				component.enabled = _colliderIsActive;
			}
		}
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		ColliderData colliderData = new ColliderData();
		colliderData.Serialize(this);
		return colliderData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((ColliderData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<ColliderData>(saveData).Deserialize(this);
	}
}
public class SaveFSM : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	private class SaveFSMData : ISaveData
	{
		[SerializeField]
		private FSMData _FSMdata;

		public void Serialize(ISaveSerializable target)
		{
			if (((SaveFSM)target).TryGetComponent<PlayMakerFSM>(out var component))
			{
				_FSMdata = new FSMData(component);
			}
		}

		public void Deserialize(ISaveSerializable target)
		{
			SaveFSM saveFSM = (SaveFSM)target;
			if (_FSMdata != null && saveFSM.TryGetComponent<PlayMakerFSM>(out var component))
			{
				_FSMdata.Deserialize(component);
			}
		}
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		SaveFSMData saveFSMData = new SaveFSMData();
		saveFSMData.Serialize(this);
		return saveFSMData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((SaveFSMData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<SaveFSMData>(saveData).Deserialize(this);
	}
}
[Serializable]
public class SaveFile
{
	private const int SAVEVERSION = 1;

	[SerializeField]
	private List<string> _preloadedRooms = new List<string>();

	[SerializeField]
	private List<string> _loadedRooms = new List<string>();

	[SerializeField]
	private List<SaveSceneData> _sceneData = new List<SaveSceneData>();

	[SerializeField]
	private PlayerData _playerData;

	[SerializeField]
	private Inventory.Data _inventoryData;

	[SerializeField]
	private MusicState _musicState;

	[SerializeField]
	private Odin.OdinData _odinData;

	[SerializeField]
	private bool[] _puzzleStatus;

	[SerializeField]
	private OdinQuip.QuipData _quips;

	[SerializeField]
	private int _version;

	public SaveFile(Transform playerPosition)
	{
		_playerData = (PlayerData)Player.Instance.Serialize();
		_odinData = (Odin.OdinData)Singleton<Odin>.Instance.Serialize();
		if (playerPosition != null)
		{
			_playerData.position = playerPosition.position;
			_playerData.forward = playerPosition.forward;
		}
		_preloadedRooms = SceneStateManager.GetPreloadedRooms();
		_loadedRooms.AddRange(SceneStateManager.GetLoadedRooms());
		_sceneData.AddRange(SceneStateManager.GetSceneData());
		_inventoryData = (Inventory.Data)References.Inventory.Serialize();
		_musicState = MusicManager.GetMusicState();
		_puzzleStatus = HintSystem.GetPuzzleStatus();
		_quips = OdinQuip.GetQuipData();
		_version = 1;
	}

	public IEnumerator<float> Load()
	{
		Time.timeScale = 0f;
		References.SaveGameLock.LockUsing(this);
		Player.Instance.leftHand.GetGrabbedObject()?.Release(Player.Instance.leftHand, playSound: false);
		Player.Instance.rightHand.GetGrabbedObject()?.Release(Player.Instance.rightHand, playSound: false);
		if (Player.Instance.IsDestroyed())
		{
			Player.Instance.SetPosition(new Vector3(0f, -2000f, 0f), useHeadPosition: false);
			yield return float.NegativeInfinity;
			yield return float.NegativeInfinity;
		}
		SceneStateManager.SetSceneData(_sceneData);
		yield return Timing.WaitUntilDone(SceneStateManager.SetRooms(_loadedRooms, _preloadedRooms, forceLoadData: true));
		yield return float.NegativeInfinity;
		yield return float.NegativeInfinity;
		CombatTracker.DisengageAll();
		Player.Instance.Deserialize(_playerData);
		Singleton<Odin>.Instance.Deserialize(_odinData);
		_inventoryData.Deserialize(References.Inventory);
		MusicManager.SetMusicState(_musicState);
		HintSystem.SetPuzzleStatus(_puzzleStatus);
		OdinQuip.SetQuipData(_quips);
		References.OnGameLoaded.RaiseTrue();
		Time.timeScale = 1f;
		UnityEngine.Debug.Log("Loaded game");
		Timing.CallDelayed(3f, delegate
		{
			References.SaveGameLock.Unlock(this);
		});
	}
}
public class SaveMaterial : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	private class SaveMaterialData : ISaveData
	{
		[SerializeField]
		private MaterialData _materialData;

		public void Serialize(ISaveSerializable target)
		{
			if (((SaveMaterial)target).TryGetComponent<Renderer>(out var component))
			{
				_materialData = new MaterialData(component.material);
			}
		}

		public void Deserialize(ISaveSerializable target)
		{
			SaveMaterial saveMaterial = (SaveMaterial)target;
			if (_materialData != null && saveMaterial.TryGetComponent<Renderer>(out var component))
			{
				_materialData.Deserialize(component.material);
			}
		}
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		SaveMaterialData saveMaterialData = new SaveMaterialData();
		saveMaterialData.Serialize(this);
		return saveMaterialData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((SaveMaterialData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<SaveMaterialData>(saveData).Deserialize(this);
	}
}
[RequireComponent(typeof(RayfireRigid))]
[RequireComponent(typeof(Rigidbody))]
public class SaveRayfire : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	private class RayfireData : ISaveData
	{
		[SerializeField]
		private bool _isActive;

		[SerializeField]
		private float _damage;

		public void Serialize(ISaveSerializable target)
		{
			SaveRayfire saveRayfire = (SaveRayfire)target;
			_isActive = saveRayfire.gameObject.activeSelf;
			_damage = saveRayfire.GetComponent<RayfireRigid>().damage.currentDamage;
		}

		public void Deserialize(ISaveSerializable target)
		{
			SaveRayfire obj = (SaveRayfire)target;
			RayfireRigid component = obj.GetComponent<RayfireRigid>();
			if (!obj.gameObject.activeInHierarchy)
			{
				component.ResetRigid();
			}
			obj.GetComponent<Rigidbody>().isKinematic = true;
			obj.gameObject.SetActive(_isActive);
			component.damage.currentDamage = _damage;
		}
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		RayfireData rayfireData = new RayfireData();
		rayfireData.Serialize(this);
		return rayfireData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((RayfireData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<RayfireData>(saveData).Deserialize(this);
	}
}
[RequireComponent(typeof(Rigidbody))]
public class SaveRigidbody : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	private class RigidbodyData : ISaveData
	{
		[SerializeField]
		private bool _useGravity;

		[SerializeField]
		private bool _isKinematic;

		public void Serialize(ISaveSerializable target)
		{
			if (((SaveRigidbody)target).TryGetComponent<Rigidbody>(out var component))
			{
				_useGravity = component.useGravity;
				_isKinematic = component.isKinematic;
			}
		}

		public void Deserialize(ISaveSerializable target)
		{
			if (((SaveRigidbody)target).TryGetComponent<Rigidbody>(out var component))
			{
				component.useGravity = _useGravity;
				component.isKinematic = _isKinematic;
			}
		}
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		RigidbodyData rigidbodyData = new RigidbodyData();
		rigidbodyData.Serialize(this);
		return rigidbodyData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((RigidbodyData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<RigidbodyData>(saveData).Deserialize(this);
	}
}
[Serializable]
public class SaveSceneData
{
	[Serializable]
	private class GameObjectData
	{
		public string ID;

		public List<string> objTypes = new List<string>();

		public List<string> objData = new List<string>();

		public Type GetObjType(int index)
		{
			return Type.GetType(objTypes[index]);
		}
	}

	public string sceneName;

	[SerializeField]
	private List<GameObjectData> _saveData = new List<GameObjectData>();

	public SaveSceneData(string sceneName, Dictionary<string, UniqueId> ids)
	{
		this.sceneName = sceneName;
		foreach (string key in ids.Keys)
		{
			GameObjectData gameObjectData = new GameObjectData
			{
				ID = key
			};
			ISaveSerializable[] components = ids[key].GetComponents<ISaveSerializable>();
			foreach (ISaveSerializable saveSerializable in components)
			{
				gameObjectData.objTypes.Add(saveSerializable.GetType().AssemblyQualifiedName);
				gameObjectData.objData.Add(saveSerializable.SerializeString());
			}
			_saveData.Add(gameObjectData);
		}
	}

	public void Load(Dictionary<string, UniqueId> ids)
	{
		for (int i = 0; i < _saveData.Count; i++)
		{
			GameObjectData gameObjectData = _saveData[i];
			if (!ids.ContainsKey(gameObjectData.ID))
			{
				UnityEngine.Debug.LogError("Could not load object with ID: " + gameObjectData.ID);
				continue;
			}
			GameObject gameObject = ids[gameObjectData.ID].gameObject;
			for (int j = 0; j < gameObjectData.objTypes.Count; j++)
			{
				Component component = gameObject.GetComponent(gameObjectData.GetObjType(j));
				if (component != null)
				{
					((ISaveSerializable)component).Deserialize(gameObjectData.objData[j]);
					continue;
				}
				UnityEngine.Debug.LogError(string.Concat("Failed to deserialize component of type ", gameObjectData.GetObjType(j), " on object ", gameObject, ". Component could not be found."));
			}
		}
	}
}
[ExecuteInEditMode]
public class SaveSceneManager : MonoBehaviour
{
	private static readonly Dictionary<string, SaveSceneManager> _sceneManagers = new Dictionary<string, SaveSceneManager>();

	[SerializeField]
	private List<GameObject> _gameobjlist = new List<GameObject>();

	private readonly Dictionary<string, UniqueId> _idList = new Dictionary<string, UniqueId>();

	private void Awake()
	{
		if (!_sceneManagers.ContainsKey(base.gameObject.scene.name))
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		_sceneManagers.Add(base.gameObject.scene.name, this);
		for (int i = 0; i < _gameobjlist.Count; i++)
		{
			UniqueId component = _gameobjlist[i].GetComponent<UniqueId>();
			_idList.Add(component.uniqueId, component);
		}
	}

	private void OnDestroy()
	{
		_sceneManagers.Remove(base.gameObject.scene.name);
	}

	public static SaveSceneData SaveScene(string sceneName)
	{
		if (_sceneManagers.ContainsKey(sceneName))
		{
			return _sceneManagers[sceneName].SaveState();
		}
		UnityEngine.Debug.LogError("Attempted to save a scene that is not open or has no scene manager: " + sceneName);
		return null;
	}

	private SaveSceneData SaveState()
	{
		return new SaveSceneData(base.gameObject.scene.name, _idList);
	}

	public static void LoadScene(SaveSceneData sceneData)
	{
		if (sceneData == null)
		{
			UnityEngine.Debug.LogError("Attempted to load null scene data");
			return;
		}
		if (_sceneManagers.ContainsKey(sceneData.sceneName))
		{
			sceneData.Load(_sceneManagers[sceneData.sceneName]._idList);
			return;
		}
		SaveSceneManager[] array = UnityEngine.Object.FindObjectsOfType<SaveSceneManager>();
		for (int i = 0; i < array.Length; i++)
		{
			if (sceneData.sceneName == array[i].gameObject.scene.name)
			{
				array[i].Initialize();
				sceneData.Load(_sceneManagers[sceneData.sceneName]._idList);
				return;
			}
		}
		UnityEngine.Debug.LogError("Attempted to load data into a scene that is not open");
	}
}
public static class SaveSystem
{
	private static SaveFile _checkpoint;

	public static void Save(Transform playerPosition, bool hideText = false)
	{
		if (!References.SaveGameLock.IsLocked() && !CombatTracker.IsInCombat && (!hideText || !(SceneStateManager.GetLastLoadedRoom().name != "Room 1")) && !Player.Instance.IsDestroyed())
		{
			_checkpoint = new SaveFile(playerPosition);
			ProfileManager.Profile activeProfile = ProfileManager.GetActiveProfile();
			File.WriteAllText($"{UnityEngine.Application.persistentDataPath}/Profile{activeProfile.ID}.sav", JsonUtility.ToJson(_checkpoint, prettyPrint: true));
			ProfileManager.UpdateActiveProfileData();
			ProfileManager.SaveProfileIndex();
			if (!hideText)
			{
				References.SystemText.DisplayText("Text_game_progress", 5f, null, forceDisplay: true);
			}
		}
	}

	public static IEnumerator<float> Load(SaveFile file)
	{
		yield return Timing.WaitUntilDone(file.Load(), Segment.RealtimeUpdate);
		_checkpoint = file;
	}

	public static IEnumerator<float> LoadCheckpoint()
	{
		if (_checkpoint != null)
		{
			yield return Timing.WaitUntilDone(_checkpoint.Load(), Segment.RealtimeUpdate);
		}
		else
		{
			UnityEngine.Debug.LogError("No active checkpoint to load");
		}
	}
}
public class SaveTransform : MonoBehaviour, ISaveSerializable
{
	[Serializable]
	private class TransformData : ISaveData
	{
		[SerializeField]
		private TransformSaveData _transformData;

		public void Serialize(ISaveSerializable target)
		{
			SaveTransform saveTransform = (SaveTransform)target;
			_transformData = new TransformSaveData(saveTransform.transform);
		}

		public void Deserialize(ISaveSerializable target)
		{
			SaveTransform saveTransform = (SaveTransform)target;
			if (_transformData != null)
			{
				_transformData.Deserialize(saveTransform.transform);
			}
		}
	}

	public void Deserialize(ISaveData saveData)
	{
		saveData.Deserialize(this);
	}

	public ISaveData Serialize()
	{
		TransformData transformData = new TransformData();
		transformData.Serialize(this);
		return transformData;
	}

	public string SerializeString()
	{
		return JsonUtility.ToJson((TransformData)Serialize());
	}

	public void Deserialize(string saveData)
	{
		JsonUtility.FromJson<TransformData>(saveData).Deserialize(this);
	}
}
public class SetNavMeshLinksBidirectional : MonoBehaviour
{
	public NavMeshLink[] links;

	public void SetBidirectional(bool bidirectional)
	{
		for (int i = 0; i < links.Length; i++)
		{
			links[i].bidirectional = bidirectional;
		}
	}
}
[CreateAssetMenu(menuName = "Custom/Set/GameObject")]
public class GameObjectRuntimeSet : RuntimeSet<GameObject>
{
}
public abstract class RuntimeSet<T> : ScriptableObject
{
	public List<T> Items = new List<T>();

	public void Add(T obj)
	{
		if (!Items.Contains(obj))
		{
			Items.Add(obj);
		}
	}

	public void Remove(T obj)
	{
		if (Items.Contains(obj))
		{
			Items.Remove(obj);
		}
	}
}
public class SettingsMenuManager : Singleton<SettingsMenuManager>
{
	public GameEvent[] inputButtons;

	public Toggle male;

	public Toggle female;

	public Toggle dominantRight;

	public Toggle dominantLeft;

	public Toggle stand;

	public Toggle sit;

	public Toggle teleportRight;

	public Toggle teleportLeft;

	public Toggle teleportBoth;

	public Toggle blink;

	public Toggle dash;

	public Toggle snap;

	public Toggle smooth;

	public Slider snapSlider;

	public Slider smoothSlider;

	public Slider heightSlider;

	public Toggle subtitlesOn;

	public Toggle subtitlesOff;

	public Toggle hintsOn;

	public Toggle hintsOff;

	public Toggle quipsOn;

	public Toggle quipsOff;

	public Toggle tutorialOn;

	public Toggle tutorialOff;

	public Toggle easy;

	public Toggle normal;

	public Toggle hard;

	public Slider music;

	public Slider ambient;

	public Slider sfx;

	public Slider voice;

	public TextMeshProUGUI languageText;

	public TextMeshProUGUI[] languages;

	private bool _isSettingHeight;

	private void OnEnable()
	{
		Settings.PlayerSettings current = Settings.Current;
		male.group.SetAllTogglesOff(sendCallback: false);
		dominantRight.group.SetAllTogglesOff(sendCallback: false);
		stand.group.SetAllTogglesOff(sendCallback: false);
		teleportRight.group.SetAllTogglesOff(sendCallback: false);
		blink.group.SetAllTogglesOff(sendCallback: false);
		snap.group.SetAllTogglesOff(sendCallback: false);
		subtitlesOn.group.SetAllTogglesOff(sendCallback: false);
		hintsOn.group.SetAllTogglesOff(sendCallback: false);
		quipsOn.group.SetAllTogglesOff(sendCallback: false);
		tutorialOn.group.SetAllTogglesOff(sendCallback: false);
		easy.group.SetAllTogglesOff(sendCallback: false);
		male.isOn = current.gender == Gender.Male;
		female.isOn = current.gender == Gender.Female;
		dominantRight.isOn = current.dominantHand == HandMode.Right;
		dominantLeft.isOn = current.dominantHand == HandMode.Left;
		stand.isOn = current.comfortMode == ComfortMode.Stand;
		sit.isOn = current.comfortMode == ComfortMode.Sit;
		teleportRight.isOn = current.teleportHand == HandMode.Right;
		teleportLeft.isOn = current.teleportHand == HandMode.Left;
		teleportBoth.isOn = current.teleportHand == HandMode.Both;
		blink.isOn = current.teleportMode == TeleportMode.Blink;
		dash.isOn = current.teleportMode == TeleportMode.Dash;
		snap.isOn = current.turnMode == TurnMode.Snap;
		smooth.isOn = current.turnMode == TurnMode.Smooth;
		snapSlider.transform.parent.gameObject.SetActive(snap.isOn);
		snapSlider.value = ((current.turnDegrees != TurnDegrees.Thirty) ? ((current.turnDegrees == TurnDegrees.FortyFive) ? 1 : 2) : 0);
		smoothSlider.transform.parent.gameObject.SetActive(smooth.isOn);
		smoothSlider.value = current.turnSpeed;
		heightSlider.transform.parent.gameObject.SetActive(sit.isOn);
		heightSlider.value = current.sitHeight;
		languageText.text = languages[(int)current.language].text;
		languageText.font = languages[(int)current.language].font;
		subtitlesOn.isOn = current.subtitles;
		subtitlesOff.isOn = !current.subtitles;
		hintsOn.isOn = current.hints;
		hintsOff.isOn = !current.hints;
		quipsOn.isOn = current.quips;
		quipsOff.isOn = !current.quips;
		tutorialOn.isOn = current.toolTips;
		tutorialOff.isOn = !current.toolTips;
		easy.isOn = current.difficulty == Difficulty.Easy;
		normal.isOn = current.difficulty == Difficulty.Normal;
		hard.isOn = current.difficulty == Difficulty.Hard;
		music.value = current.music;
		ambient.value = current.ambient;
		sfx.value = current.sfx;
		voice.value = current.voice;
	}

	public void SetGender()
	{
		Settings.SetGender((!male.isOn) ? Gender.Female : Gender.Male);
	}

	public void SetDominantHand()
	{
		Settings.SetDominantHand(dominantRight.isOn ? HandMode.Right : HandMode.Left);
	}

	public void SetTeleportHand()
	{
		if (teleportRight.isOn)
		{
			Settings.SetTeleportHand(HandMode.Right);
		}
		if (teleportLeft.isOn)
		{
			Settings.SetTeleportHand(HandMode.Left);
		}
		if (teleportBoth.isOn)
		{
			Settings.SetTeleportHand(HandMode.Both);
		}
	}

	public void SetTeleportMode()
	{
		Settings.SetTeleportMode((!blink.isOn) ? TeleportMode.Dash : TeleportMode.Blink);
	}

	public void SetTurnMode()
	{
		Settings.SetTurnMode((!snap.isOn) ? TurnMode.Smooth : TurnMode.Snap);
	}

	public void SetTurnDegrees(float option)
	{
		if (!0f.Equals(option))
		{
			if (!1f.Equals(option))
			{
				if (2f.Equals(option))
				{
					Settings.SetTurnDegrees(TurnDegrees.Ninety);
				}
			}
			else
			{
				Settings.SetTurnDegrees(TurnDegrees.FortyFive);
			}
		}
		else
		{
			Settings.SetTurnDegrees(TurnDegrees.Thirty);
		}
	}

	public void SetTurnSpeed(float speed)
	{
		Settings.SetTurnSpeed(speed);
	}

	public void SetComfortMode()
	{
		Settings.SetComfortMode((!stand.isOn) ? ComfortMode.Sit : ComfortMode.Stand);
		heightSlider.transform.parent.gameObject.SetActive(sit.isOn);
	}

	public void SetSitHeight(float height)
	{
		if (!_isSettingHeight)
		{
			_isSettingHeight = true;
			for (int i = 0; i < inputButtons.Length; i++)
			{
				GameEvent obj = inputButtons[i];
				obj.OnFalse = (System.Action)Delegate.Combine(obj.OnFalse, new System.Action(UpdateHeight));
			}
		}
	}

	private void UpdateHeight()
	{
		Settings.SetSitHeight(heightSlider.value);
		for (int i = 0; i < inputButtons.Length; i++)
		{
			GameEvent obj = inputButtons[i];
			obj.OnFalse = (System.Action)Delegate.Remove(obj.OnFalse, new System.Action(UpdateHeight));
		}
		_isSettingHeight = false;
	}

	public void SetSubtitles()
	{
		Settings.SetSubtitles(subtitlesOn.isOn);
	}

	public void SetLanguage(int language)
	{
		Settings.SetLanguage((Language)language);
		languageText.text = languages[language].text;
		languageText.font = languages[language].font;
	}

	public void SetHints()
	{
		Settings.SetHints(hintsOn.isOn);
	}

	public void SetQuips()
	{
		Settings.SetQuips(quipsOn.isOn);
	}

	public void SetToolTips()
	{
		Settings.SetToolTips(tutorialOn.isOn);
	}

	public void SetDifficulty()
	{
		if (easy.isOn)
		{
			Settings.SetDifficulty(Difficulty.Easy);
		}
		else if (normal.isOn)
		{
			Settings.SetDifficulty(Difficulty.Normal);
		}
		else if (hard.isOn)
		{
			Settings.SetDifficulty(Difficulty.Hard);
		}
	}

	public void SetVolMusic(float value)
	{
		Settings.SetVolMusic(value);
	}

	public void SetVolAmbient(float value)
	{
		Settings.SetVolAmbient(value);
	}

	public void SetVolSFX(float value)
	{
		Settings.SetVolSFX(value);
	}

	public void SetVolVoice(float value)
	{
		Settings.SetVolVoice(value);
	}
}
public class ShieldGem : MonoBehaviour, IGrabbableObject, IGrabTrigger
{
	public int gemCount = 1;

	public void GrabWith(Hand hand)
	{
		Player.Instance.shieldGems += gemCount;
		base.gameObject.SetActive(value: false);
	}

	public void Release(Hand hand, bool playSound = true)
	{
	}

	public Transform GetGripSnapPoint(Hand grabbing)
	{
		return base.transform;
	}

	public HandPose GetGripPose()
	{
		return HandPose.Fist;
	}

	public bool HandClingsToTarget()
	{
		return false;
	}

	public bool ReleaseOnGrip()
	{
		return false;
	}

	public bool ClimbOnTarget()
	{
		return false;
	}

	public bool CanGrab()
	{
		return true;
	}
}
public class ShootAtTarget : MonoBehaviour
{
	public RFX1_TransformMotion shot;

	public Projectile projectile;

	public bool targetPlayer;

	public Transform target;

	public bool runOnEnable;

	[UnityEngine.Tooltip("Offset from the target transform relative to the shooting position when looking at the target.")]
	public Vector3 targetOffset;

	[UnityEngine.Tooltip("Actual shot will hit somewhere within Spread units of the target per 1 unit of distance to the target. Result is weighted towards the middle with a bell curve.")]
	public FloatReference spread;

	private SplineController _splineController;

	private void OnEnable()
	{
		if (targetPlayer)
		{
			target = Player.Instance.transform;
		}
		if (runOnEnable)
		{
			FaceTarget(targetOffset);
		}
	}

	public void FaceTarget()
	{
		FaceTarget(targetOffset);
	}

	public Vector3 FaceTarget(Vector3 offset)
	{
		float num = ((projectile != null) ? projectile.Speed : shot.Speed);
		Vector3 vector;
		if (targetPlayer && Player.Instance.splineController != null)
		{
			_splineController = Player.Instance.splineController;
			float num2 = Vector3.Distance(base.transform.position, Player.Instance.transform.position) / (Player.Instance.splineAbsoluteSpeed + num);
			_splineController.Spline.InterpolateAndGetTangent(_splineController.RelativePosition + Player.Instance.splineRelativeSpeed * num2, out var position, out var tangent, Space.World);
			num2 = Vector3.Distance(base.transform.position, position) / num;
			_splineController.Spline.InterpolateAndGetTangent(_splineController.RelativePosition + Player.Instance.splineRelativeSpeed * num2, out position, out tangent, Space.World);
			num2 = Vector3.Distance(base.transform.position, position) / num;
			_splineController.Spline.InterpolateAndGetTangent(_splineController.RelativePosition + Player.Instance.splineRelativeSpeed * num2, out position, out var tangent2, Space.World);
			GameObject gameObject = References.DummyObjectPool.Get();
			gameObject.transform.SetPositionAndRotation(position, Quaternion.LookRotation(tangent2, Vector3.ProjectOnPlane(Vector3.up, tangent2)));
			Vector3 position2 = _splineController.transform.InverseTransformPoint(target.position);
			vector = gameObject.transform.TransformPoint(position2) - base.transform.position + base.transform.TransformDirection(offset);
			References.DummyObjectPool.ReturnToPool(gameObject);
		}
		else
		{
			vector = target.position - base.transform.position + base.transform.TransformDirection(offset);
		}
		if ((float)spread > 0f)
		{
			float num3 = (float)spread * vector.magnitude;
			vector += UnityEngine.Random.onUnitSphere * (UnityEngine.Random.Range(0f - num3, num3) + UnityEngine.Random.Range(0f - num3, num3) + UnityEngine.Random.Range(0f - num3, num3)) / 3f;
		}
		base.transform.rotation = Quaternion.LookRotation(vector);
		if (shot != null)
		{
			shot.enabled = false;
			shot.enabled = true;
		}
		if (projectile != null)
		{
			projectile.Shoot(base.transform.forward);
		}
		return base.transform.position + vector;
	}
}
public class SkipSequence : MonoBehaviour
{
	public Transform teleportTarget;

	public Room roomToLoad;

	public SplineController cart;

	public CurvySpline endSpline;

	public float endSplinePosition;

	public AudioClip odinQuip;

	public PlayMakerFSM fsmToTrigger;

	public Transform odinPerch;

	private void OnTriggerEnter(Collider other)
	{
		if (other.CompareTag("Player Hand"))
		{
			Timing.RunCoroutine(Skip());
		}
	}

	private IEnumerator<float> Skip()
	{
		SceneStateManager.PreloadRoom(roomToLoad);
		Player.Instance.deathOverlay.Blink();
		yield return Timing.WaitForSeconds(Player.Instance.deathOverlay.AddDuration);
		yield return Timing.WaitUntilDone(SceneStateManager.LoadRoom(roomToLoad));
		Player.Instance.SetPositionAndRotation(teleportTarget, useHeadPosition: false);
		Player.Instance.splineController = null;
		cart.Spline = endSpline;
		cart.AbsolutePosition = endSplinePosition;
		yield return float.NegativeInfinity;
		Singleton<Odin>.Instance.Teleport(odinPerch);
		yield return Timing.WaitForSeconds(Player.Instance.deathOverlay.AppliedDuration + Player.Instance.deathOverlay.RemoveDuration);
		fsmToTrigger.SendEvent("Trigger");
		AudioSource component = Singleton<Odin>.Instance.GetComponent<AudioSource>();
		References.Subtitles.DisplayText(odinQuip.name, odinQuip.length, component);
		component.PlayOneShot(odinQuip);
	}
}
[CreateAssetMenu(menuName = "Custom/Element/Air")]
public class Air : Element
{
	private AirSpell _spell;

	private AirBeam _beam;

	public override void OnSelected(Transform idleAnimationPoint)
	{
		base.OnSelected(idleAnimationPoint);
		if (_spell == null)
		{
			_spell = _idleEffectPrefab.GetComponentInChildren<AirSpell>(includeInactive: true);
		}
	}

	public override void OnTouchPrimary(Transform launchPoint)
	{
		GameObject gameObject = primaryEffectSet.Get();
		_beam = gameObject.GetComponent<AirBeam>();
		_beam.source = launchPoint;
		_spell.SetBeam(_beam);
		_spell.gameObject.SetActive(value: true);
		gameObject.transform.position = launchPoint.position;
		gameObject.transform.rotation = launchPoint.rotation;
		gameObject.SetActive(value: true);
	}

	public override void OnUntouchPrimary()
	{
		_spell.gameObject.SetActive(value: false);
		if (_beam != null)
		{
			_beam.FadeOut();
		}
	}

	public override void OnChargingPrimary(Transform chargePos)
	{
		if (_spell.HasTarget)
		{
			_spell.LockTarget();
			base.OnChargingPrimary(chargePos);
		}
	}

	public override void OnCancel()
	{
		base.OnCancel();
		_spell.UnlockTarget();
	}

	public override void OnChargedPrimary()
	{
		_spell.Activate();
	}

	public override void OnFiredPrimary(Transform launchPoint, AimAssist aimAssist)
	{
		_spell.UnlockTarget();
	}
}
public class AirBeam : MonoBehaviour, IGameObjectPoolable
{
	public Transform source;

	public Renderer[] renderersTint;

	public Renderer[] renderersMain;

	public float fadeDuration;

	private int[] _idsTint;

	private int[] _idsMain;

	private Color[] _colorsTint;

	private Color[] _colorsMain;

	private bool _isFadingIn;

	private bool _isFadingOut;

	private Color _alphaMultiplier;

	public GameObjectRuntimePool Pool { get; set; }

	private void Awake()
	{
		_idsTint = new int[renderersTint.Length];
		_idsMain = new int[renderersMain.Length];
		_colorsTint = new Color[renderersTint.Length];
		_colorsMain = new Color[renderersMain.Length];
		_alphaMultiplier = Color.clear;
		for (int i = 0; i < renderersTint.Length; i++)
		{
			_idsTint[i] = Shader.PropertyToID("_TintColor");
			_colorsTint[i] = renderersTint[i].sharedMaterial.GetColor(_idsTint[i]);
			renderersTint[i].material.SetColor(_idsTint[i], Color.clear);
		}
		for (int j = 0; j < renderersMain.Length; j++)
		{
			_idsMain[j] = Shader.PropertyToID("_MainColor");
			_colorsMain[j] = renderersMain[j].sharedMaterial.GetColor(_idsMain[j]);
			renderersMain[j].material.SetColor(_idsMain[j], Color.clear);
		}
	}

	private void OnEnable()
	{
		base.transform.parent = source;
		base.transform.localRotation = Quaternion.identity;
		base.transform.localPosition = Vector3.zero;
		_isFadingIn = true;
	}

	private void Update()
	{
		if (_isFadingIn)
		{
			_alphaMultiplier = new Color(1f, 1f, 1f, _alphaMultiplier.a + Time.deltaTime / fadeDuration);
			for (int i = 0; i < renderersTint.Length; i++)
			{
				renderersTint[i].material.SetColor(_idsTint[i], _colorsTint[i] * _alphaMultiplier);
			}
			for (int j = 0; j < renderersMain.Length; j++)
			{
				renderersMain[j].material.SetColor(_idsMain[j], _colorsMain[j] * _alphaMultiplier);
			}
			if (_alphaMultiplier.a >= 1f)
			{
				_isFadingIn = false;
			}
		}
		else if (_isFadingOut)
		{
			_alphaMultiplier = new Color(1f, 1f, 1f, _alphaMultiplier.a - Time.deltaTime / fadeDuration);
			for (int k = 0; k < renderersTint.Length; k++)
			{
				renderersTint[k].material.SetColor(_idsTint[k], _colorsTint[k] * _alphaMultiplier);
			}
			for (int l = 0; l < renderersMain.Length; l++)
			{
				renderersMain[l].material.SetColor(_idsMain[l], _colorsMain[l] * _alphaMultiplier);
			}
			if (_alphaMultiplier.a <= 0f)
			{
				_isFadingOut = false;
				Pool.ReturnToPool(base.gameObject);
			}
		}
	}

	public void FadeOut()
	{
		_isFadingOut = true;
	}
}
public class AirHighlight : MonoBehaviour, IGameObjectPoolable
{
	public float fadeTime;

	public Light light;

	public GameObjectRuntimePool Pool { get; set; }

	public void End()
	{
		Timing.RunCoroutine(FadeOut());
	}

	private IEnumerator<float> FadeOut()
	{
		float elapsed = 0f;
		Vector3 startScale = base.transform.localScale;
		float startIntensity = light.intensity;
		while (elapsed < fadeTime)
		{
			elapsed += Time.deltaTime;
			base.transform.localScale = Vector3.Lerp(startScale, Vector3.zero, elapsed / fadeTime);
			light.intensity = Mathf.Lerp(startIntensity, 0f, elapsed / fadeTime);
			yield return 0f;
		}
		Pool.ReturnToPool(base.gameObject);
	}
}
public class AirSpell : MonoBehaviour
{
	public float maxDistance;

	public float pullSpeed;

	public LayerMask layers;

	public Transform pullTarget;

	public BoolVariable quickPullIsPressed;

	public BoolVariable pushIsPressed;

	public BoolVariable pullIsPressed;

	public GameEvent quickPullEvent;

	private RaycastHit _hit;

	private Collider _targetCollider;

	private AirSpellTarget _target;

	private bool _targetLocked;

	private bool _isActive;

	private float _targetDistance;

	private AirBeam _beam;

	public bool HasTarget => _target != null;

	private void OnDestroy()
	{
		if (quickPullEvent != null)
		{
			GameEvent gameEvent = quickPullEvent;
			gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(QuickPull));
		}
	}

	private void Update()
	{
		if (!_targetLocked)
		{
			if (Physics.Raycast(base.transform.position, base.transform.forward, out _hit, maxDistance, layers))
			{
				if (_targetCollider != _hit.collider)
				{
					_targetCollider = _hit.collider;
					SetTarget(_targetCollider.GetComponent<AirSpellTarget>());
				}
			}
			else
			{
				_targetCollider = null;
				SetTarget(null);
			}
		}
		else if (_target != null && _isActive)
		{
			if ((bool)pushIsPressed && !pullIsPressed)
			{
				_targetDistance += Time.deltaTime * pullSpeed / 2f;
			}
			else if ((bool)pullIsPressed && !pushIsPressed)
			{
				_targetDistance -= Time.deltaTime * pullSpeed / 2f;
			}
			_targetDistance = Mathf.Clamp(_targetDistance, _target.pullDistance, maxDistance);
			pullTarget.localPosition = new Vector3(0f, 0f, _targetDistance);
			_target.Move(pullTarget, pullSpeed / 2f);
		}
	}

	private void QuickPull()
	{
		pullTarget.localPosition = new Vector3(0f, 0f, _target.pullDistance);
		_target.QuickPull(pullTarget, pullSpeed);
		_isActive = false;
	}

	private void OnDisable()
	{
		if (_target != null)
		{
			UnlockTarget();
			SetTarget(null);
			_isActive = false;
		}
	}

	public void LockTarget()
	{
		_targetLocked = true;
	}

	public void UnlockTarget()
	{
		if (_target != null)
		{
			_target.Release();
		}
		_targetLocked = false;
		_isActive = false;
		SetTarget(null);
	}

	public void Activate()
	{
		_isActive = true;
		_target.Activate();
		GameEvent gameEvent = quickPullEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Combine(gameEvent.OnTrue, new System.Action(QuickPull));
		_targetDistance = Vector3.Distance(base.transform.position, _target.transform.position);
	}

	private void SetTarget(AirSpellTarget target)
	{
		if (!(_target == target))
		{
			GameEvent gameEvent = quickPullEvent;
			gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(QuickPull));
			_isActive = false;
			if (_target != null)
			{
				_target.Unhighlight();
			}
			_target = target;
			if (_target != null)
			{
				_target.Highlight(_beam);
			}
		}
	}

	public void SetBeam(AirBeam beam)
	{
		_beam = beam;
	}
}
[RequireComponent(typeof(PlayMakerFSM))]
public class AirSpellTarget : MonoBehaviour
{
	public PlayMakerFSM FSM;

	public bool canPullToCaster = true;

	public float pullInertia = 1f;

	public float pullDistance = 0.12f;

	public GameObjectPool highlightPool;

	public Vector3 highlightScale = Vector3.one;

	private Transform _moveTarget;

	private FsmGameObject _fsmMoveTarget;

	private FsmFloat _fsmSpeed;

	private float _fullSpeedDist;

	private Vector3 _startPos;

	private float _targetSpeed;

	private float _startTime;

	private AirBeam _beam;

	private bool _isBeingPulled;

	private GameObject _highlightEffect;

	private void Start()
	{
		FSM = GetComponent<PlayMakerFSM>();
		_fsmMoveTarget = FSM.FsmVariables.FindFsmGameObject("moveTarget");
		_fsmSpeed = FSM.FsmVariables.FindFsmFloat("moveSpeed");
	}

	private void Update()
	{
		if (_moveTarget == null)
		{
			base.enabled = false;
			return;
		}
		float sqrMagnitude = (_moveTarget.position - base.transform.position).sqrMagnitude;
		if (sqrMagnitude == 0f)
		{
			return;
		}
		if (_isBeingPulled && (base.transform.position - _beam.transform.position).sqrMagnitude < 0.1f)
		{
			_beam.FadeOut();
		}
		if (sqrMagnitude < _fullSpeedDist && (_startPos - base.transform.position).sqrMagnitude > sqrMagnitude)
		{
			_fsmSpeed.Value = Mathf.Sqrt(2f * Mathf.Sqrt(sqrMagnitude) * _targetSpeed / pullInertia);
			return;
		}
		float num = (Time.time - _startTime) / pullInertia;
		if (num >= 1f)
		{
			_fsmSpeed.Value = _targetSpeed;
		}
		else
		{
			_fsmSpeed.Value = _targetSpeed * num;
		}
	}

	public void Activate()
	{
		FSM.SendEvent("Activate");
	}

	public void Highlight(AirBeam beam)
	{
		_beam = beam;
		if (highlightPool != null)
		{
			_highlightEffect = highlightPool.Get();
			_highlightEffect.transform.position = base.transform.position;
			_highlightEffect.transform.localScale = highlightScale;
			_highlightEffect.transform.parent = base.transform;
			_highlightEffect.SetActive(value: true);
		}
		FSM.SendEvent("Highlight");
	}

	public void Unhighlight()
	{
		if (_highlightEffect != null)
		{
			_highlightEffect.GetComponent<AirHighlight>().End();
		}
		FSM.SendEvent("Unhighlight");
	}

	public void Release()
	{
		if (_highlightEffect != null)
		{
			highlightPool.ReturnToPool(_highlightEffect);
		}
		FSM.SendEvent("Release");
	}

	public void QuickPull(Transform target, float speed)
	{
		if (canPullToCaster)
		{
			_moveTarget = target;
			_fsmMoveTarget.Value = target.gameObject;
			_fsmSpeed.Value = 0f;
			_startPos = base.transform.position;
			_fullSpeedDist = speed / 2f * pullInertia;
			_fullSpeedDist *= _fullSpeedDist;
			_targetSpeed = speed;
			_startTime = Time.time;
			_isBeingPulled = true;
			base.enabled = true;
		}
		FSM.SendEvent("Pull");
	}

	public void Move(Transform target, float speed)
	{
		_moveTarget = target;
		_fsmMoveTarget.Value = target.gameObject;
		_targetSpeed = speed;
		base.enabled = true;
	}
}
[RequireComponent(typeof(PlayMakerFSM))]
public class Crystal : MonoBehaviour, IWandTouchReceiver
{
	public PlayMakerFSM FSM;

	private void OnValidate()
	{
		FSM = GetComponent<PlayMakerFSM>();
	}

	public void OnTouch(Element element)
	{
		FSM.SendEvent("Absorb");
	}
}
[CreateAssetMenu(menuName = "Custom/Element/Element")]
public class Element : ScriptableObject
{
	public Material crystalMaterial;

	public float primaryChargeTime;

	public bool active;

	public OVRHapticsClip chargedHapticsClip;

	[SerializeField]
	protected GameObject primaryEffectPrefab;

	[SerializeField]
	protected GameObject primaryChargingEffectPrefab;

	[SerializeField]
	private GameObject idleEffectPrefab;

	[SerializeField]
	protected GameObjectPool primaryEffectSet;

	protected GameObject _primaryChargingEffect;

	protected GameObject _idleEffectPrefab;

	public void OnInitialize()
	{
		if (primaryEffectSet != null)
		{
			primaryEffectSet.Initialize();
		}
	}

	public virtual void OnTouchPrimary(Transform launchPoint)
	{
	}

	public virtual void OnUntouchPrimary()
	{
	}

	public virtual void OnChargedPrimary()
	{
	}

	public virtual void OnChargingPrimary(Transform chargePos)
	{
		if (_primaryChargingEffect != null)
		{
			_primaryChargingEffect.SetActive(value: true);
		}
		else
		{
			_primaryChargingEffect = UnityEngine.Object.Instantiate(primaryChargingEffectPrefab, chargePos, worldPositionStays: false);
		}
	}

	public virtual void UpdateCharge(Vector3 position)
	{
		if (_primaryChargingEffect != null)
		{
			_primaryChargingEffect.transform.position = position;
		}
	}

	public virtual void OnFiredPrimary(Transform launchPoint, AimAssist aimAssist)
	{
		_primaryChargingEffect.SetActive(value: false);
		Timing.RunCoroutine(OnFiredDelay(launchPoint, aimAssist), Segment.EndOfFrame);
	}

	private IEnumerator<float> OnFiredDelay(Transform launchPoint, AimAssist aimAssist)
	{
		GameObject gameObject = primaryEffectSet.Get();
		gameObject.transform.SetPositionAndRotation(launchPoint.position + References.TrackingSpace.GetSurfaceVelocity() * Time.deltaTime, launchPoint.rotation);
		gameObject.SetActive(value: true);
		if (gameObject.TryGetComponent<Fireball>(out var component))
		{
			component.SetTargetCollider(aimAssist.GetTarget());
			component.SetVelocityOffset(References.TrackingSpace.GetSurfaceVelocity());
		}
		yield break;
	}

	public virtual void OnCancel()
	{
		if (_primaryChargingEffect != null)
		{
			_primaryChargingEffect.SetActive(value: false);
		}
	}

	public virtual void OnSelected(Transform idleAnimationPoint)
	{
		if (_idleEffectPrefab != null)
		{
			_idleEffectPrefab.SetActive(value: true);
		}
		else
		{
			_idleEffectPrefab = UnityEngine.Object.Instantiate(idleEffectPrefab, idleAnimationPoint, worldPositionStays: false);
		}
	}

	public void OnDeselected()
	{
		if (_idleEffectPrefab != null)
		{
			_idleEffectPrefab.SetActive(value: false);
		}
	}
}
public class Fireball : MonoBehaviour, IGameObjectPoolable
{
	[UnityEngine.Tooltip("The maximum distance the fireball will travel assuming the default speed")]
	public float Distance = 30f;

	public float Speed = 1f;

	public GameObject Target;

	public LayerMask CollidesWith = -1;

	public GameObjectPool EffectsPoolOnCollision;

	[UnityEngine.Tooltip("How long this gameobject remains active after colliding or reaching its maximum range")]
	public float LifespanAfterCollision = 5f;

	[UnityEngine.Tooltip("How long the collision effect remains active after being created")]
	public float DestroyTimeDelay = 5f;

	public bool CollisionEffectInWorldSpace = true;

	public GameObject[] DeactivatedObjectsOnCollision;

	public Light light;

	private Collider targetCollider;

	private bool isCollided;

	private bool isOutDistance;

	private Quaternion startQuaternion;

	private const float RayCastTolerance = 0.15f;

	private bool isInitialized;

	private bool dropFirstFrameForFixUnityBugWithParticles;

	private float tempSpeed;

	private float speedOffset;

	private float lifespan;

	private float lightIntensity;

	public GameObjectRuntimePool Pool { get; set; }

	public event EventHandler<RFX1_TransformMotion.RFX1_CollisionInfo> CollisionEnter;

	private void Awake()
	{
		lightIntensity = light.intensity;
		Initialize();
		isInitialized = true;
	}

	private void OnEnable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void OnDisable()
	{
		if (isInitialized)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		tempSpeed = Speed;
		light.intensity = lightIntensity;
		speedOffset = 0f;
		lifespan = Time.time + Distance / Speed;
		isCollided = false;
		isOutDistance = false;
		startQuaternion = base.transform.rotation;
		OnCollisionDeactivateBehaviour(active: true);
		dropFirstFrameForFixUnityBugWithParticles = true;
	}

	private void Update()
	{
		if (!dropFirstFrameForFixUnityBugWithParticles)
		{
			UpdateWorldPosition();
		}
		else
		{
			dropFirstFrameForFixUnityBugWithParticles = false;
		}
	}

	private void UpdateWorldPosition()
	{
		Vector3 vector = Vector3.zero;
		Vector3 vector2 = Vector3.zero;
		if (!isCollided && !isOutDistance)
		{
			if (Target != null)
			{
				vector2 = (vector = (Target.transform.position - base.transform.position).normalized * (tempSpeed + speedOffset) * Time.deltaTime);
			}
			else if (targetCollider != null)
			{
				vector2 = (vector = (targetCollider.bounds.center - base.transform.position).normalized * (tempSpeed + speedOffset) * Time.deltaTime);
			}
			else
			{
				Vector3 vector3 = Vector3.forward * (tempSpeed + speedOffset) * Time.deltaTime;
				vector = base.transform.localRotation * vector3;
				vector2 = startQuaternion * vector3;
			}
		}
		if (!isCollided && Physics.Raycast(base.transform.position, vector2.normalized, out var hitInfo, Distance, CollidesWith, QueryTriggerInteraction.Ignore) && vector.magnitude + 0.15f > hitInfo.distance)
		{
			isCollided = true;
			base.transform.position = hitInfo.point;
			OnCollisionBehaviour(hitInfo);
			OnCollisionDeactivateBehaviour(active: false);
		}
		else if (!isOutDistance && Time.time > lifespan)
		{
			isOutDistance = true;
			OnCollisionDeactivateBehaviour(active: false);
			ReturnToPool(LifespanAfterCollision);
		}
		else
		{
			base.transform.position += vector2;
		}
	}

	private void OnCollisionBehaviour(RaycastHit hit)
	{
		this.CollisionEnter?.Invoke(this, new RFX1_TransformMotion.RFX1_CollisionInfo
		{
			Hit = hit
		});
		if (EffectsPoolOnCollision != null)
		{
			GameObject gameObject = EffectsPoolOnCollision.Get();
			gameObject.transform.position = hit.point;
			gameObject.transform.LookAt(hit.point + hit.normal);
			if (!CollisionEffectInWorldSpace)
			{
				gameObject.transform.parent = base.transform;
			}
			gameObject.SetActive(value: true);
			Timing.RunCoroutine(ReturnToPool(gameObject, DestroyTimeDelay));
		}
		ReturnToPool(LifespanAfterCollision);
	}

	private void OnCollisionDeactivateBehaviour(bool active)
	{
		GameObject[] deactivatedObjectsOnCollision = DeactivatedObjectsOnCollision;
		foreach (GameObject gameObject in deactivatedObjectsOnCollision)
		{
			if (gameObject != null)
			{
				gameObject.SetActive(active);
			}
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!UnityEngine.Application.isPlaying)
		{
			Gizmos.color = Color.blue;
			Gizmos.DrawLine(base.transform.position, base.transform.position + base.transform.forward * Distance);
		}
	}

	public void SetVelocityOffset(Vector3 offset)
	{
		if (offset != Vector3.zero)
		{
			Vector3 vector = ((Target != null) ? (Target.transform.position - base.transform.position).normalized : ((!(targetCollider != null)) ? base.transform.forward : (targetCollider.bounds.center - base.transform.position).normalized));
			speedOffset = Mathf.Max(Vector3.Project(vector, offset).magnitude, 0f) * offset.magnitude;
		}
		else
		{
			speedOffset = 0f;
		}
	}

	public void SetPosition(GameObject matchObject)
	{
		SetPosition(matchObject.transform.position);
	}

	public void SetPosition(Vector3 position)
	{
		base.transform.position = position;
	}

	public void SetTarget(GameObject target)
	{
		Target = target;
		targetCollider = null;
	}

	public void EnableParticles(bool enable)
	{
		ParticleSystem[] componentsInChildren = GetComponentsInChildren<ParticleSystem>();
		foreach (ParticleSystem particleSystem in componentsInChildren)
		{
			if (enable)
			{
				particleSystem.Play(withChildren: false);
			}
			else
			{
				particleSystem.Stop(withChildren: false, ParticleSystemStopBehavior.StopEmitting);
			}
		}
	}

	public void FadeLight(float time)
	{
		Timing.RunCoroutine(FadeLightRoutine(time));
	}

	private IEnumerator<float> FadeLightRoutine(float time)
	{
		while (light.intensity > 0f)
		{
			yield return float.NegativeInfinity;
			light.intensity -= lightIntensity * (Time.deltaTime / time);
		}
		light.intensity = 0f;
	}

	public void SetSpeed(float speed)
	{
		tempSpeed = speed;
	}

	public void ResetSpeed()
	{
		tempSpeed = Speed;
	}

	public void SetTargetCollider(Collider target)
	{
		Target = null;
		targetCollider = target;
	}

	public void ReturnToPool(float delay)
	{
		Timing.RunCoroutine(ReturnToPoolRoutine(delay));
	}

	private IEnumerator<float> ReturnToPoolRoutine(float delay)
	{
		if (Pool != null)
		{
			yield return Timing.WaitForSeconds(delay);
			Target = null;
			targetCollider = null;
			EnableParticles(enable: true);
			Pool.ReturnToPool(base.gameObject);
		}
	}

	private IEnumerator<float> ReturnToPool(GameObject obj, float delay)
	{
		IGameObjectPoolable iobj = obj.GetComponent<IGameObjectPoolable>();
		if (iobj.Pool != null)
		{
			yield return Timing.WaitForSeconds(delay);
			iobj.Pool.ReturnToPool(obj);
		}
		else
		{
			UnityEngine.Object.Destroy(obj, delay);
		}
	}
}
public interface ITemperatureObject
{
	void ApplyHeat(float power);

	void ApplyCold(float power);
}
public abstract class TemperatureObjectAmbient : MonoBehaviour, ITemperatureObject
{
	public FloatReference defaultTemp;

	public FloatReference heatingRate;

	public FloatReference coolingRate;

	public FloatReference maxTemp;

	public FloatReference minTemp;

	[SerializeField]
	protected float _currentTemp;

	public virtual void ApplyHeat(float power)
	{
		_currentTemp += power * (float)heatingRate;
		base.enabled = true;
	}

	public virtual void ApplyCold(float power)
	{
		_currentTemp -= power * (float)coolingRate;
		base.enabled = true;
	}

	public bool ApplyAmbientTemp()
	{
		_currentTemp = Mathf.Clamp(_currentTemp, minTemp, maxTemp);
		if (_currentTemp > (float)defaultTemp)
		{
			ApplyCold(Time.deltaTime);
			if (_currentTemp < (float)defaultTemp)
			{
				_currentTemp = defaultTemp;
				return false;
			}
		}
		else
		{
			if (!(_currentTemp < (float)defaultTemp))
			{
				return false;
			}
			ApplyHeat(Time.deltaTime);
			if (_currentTemp > (float)defaultTemp)
			{
				_currentTemp = defaultTemp;
				return false;
			}
		}
		return true;
	}
}
[RequireComponent(typeof(PlayMakerFSM))]
public class TemperaturePlaymakerTrigger : MonoBehaviour, ITemperatureObject
{
	public PlayMakerFSM FSM;

	public FloatReference triggersAtValue;

	public bool triggerFromCold;

	public string playmakerEvent = "Trigger";

	private void OnValidate()
	{
		FSM = GetComponent<PlayMakerFSM>();
	}

	public virtual void ApplyHeat(float power)
	{
		if (!triggerFromCold && power >= (float)triggersAtValue)
		{
			FSM.SendEvent(playmakerEvent);
		}
	}

	public virtual void ApplyCold(float power)
	{
		if (triggerFromCold && power >= (float)triggersAtValue)
		{
			FSM.SendEvent(playmakerEvent);
		}
	}
}
[RequireComponent(typeof(PlayMakerFSM))]
public class TemperaturePlaymakerVariable : MonoBehaviour, ITemperatureObject
{
	public PlayMakerFSM FSM;

	[UnityEngine.Tooltip("Variable name on the Playmaker FSM to update when heat or cold is applied")]
	public string playmakerVariable = "temperature";

	public string playmakerEventHeat = "Apply Heat";

	public string playmakerEventCold = "Apply Cold";

	private FsmFloat _tempVar;

	private void Start()
	{
		FSM = GetComponent<PlayMakerFSM>();
		_tempVar = FSM.FsmVariables.FindFsmFloat(playmakerVariable);
	}

	public void ApplyCold(float power)
	{
		_tempVar.Value -= power;
		if (!string.IsNullOrEmpty(playmakerEventCold))
		{
			FSM.SendEvent(playmakerEventCold);
		}
	}

	public void ApplyHeat(float power)
	{
		_tempVar.Value += power;
		if (!string.IsNullOrEmpty(playmakerEventHeat))
		{
			FSM.SendEvent(playmakerEventHeat);
		}
	}
}
public class TemperatureSetter : MonoBehaviour
{
	public FloatReference power;

	public bool isCold;

	private readonly List<ITemperatureObject> _targetTemps = new List<ITemperatureObject>();

	private void OnTriggerEnter(Collider other)
	{
		ITemperatureObject componentInParent = other.GetComponentInParent<ITemperatureObject>();
		if (componentInParent != null)
		{
			_targetTemps.Add(componentInParent);
			base.enabled = true;
		}
	}

	private void OnTriggerExit(Collider other)
	{
		ITemperatureObject componentInParent = other.GetComponentInParent<ITemperatureObject>();
		if (componentInParent != null)
		{
			_targetTemps.Remove(componentInParent);
			if (_targetTemps.Count == 0)
			{
				base.enabled = false;
			}
		}
	}

	private void Update()
	{
		float num = (float)power * Time.deltaTime;
		if (isCold)
		{
			for (int num2 = _targetTemps.Count - 1; num2 >= 0; num2--)
			{
				if (_targetTemps[num2] == null)
				{
					_targetTemps.RemoveAt(num2);
					if (_targetTemps.Count == 0)
					{
						base.enabled = false;
					}
				}
				else
				{
					_targetTemps[num2].ApplyCold(num);
				}
			}
			return;
		}
		for (int num3 = _targetTemps.Count - 1; num3 >= 0; num3--)
		{
			if (_targetTemps[num3] == null)
			{
				_targetTemps.RemoveAt(num3);
				if (_targetTemps.Count == 0)
				{
					base.enabled = false;
				}
			}
			else
			{
				_targetTemps[num3].ApplyHeat(num);
			}
		}
	}
}
public class TemperatureSetterBurst : MonoBehaviour
{
	public FloatReference power;

	public bool isCold;

	public LayerMask layerMask;

	public bool affectPlayer = true;

	public float radius = 1f;

	public bool activateOnEnable = true;

	public float explosionForce;

	private readonly HashSet<IDamageable> damageables = new HashSet<IDamageable>();

	private readonly HashSet<ITemperatureObject> temperatureObjects = new HashSet<ITemperatureObject>();

	private void OnEnable()
	{
		if (activateOnEnable)
		{
			StartCoroutine(ActivateOnDelay());
		}
	}

	private IEnumerator ActivateOnDelay()
	{
		yield return new WaitForEndOfFrame();
		Activate();
	}

	public void Activate()
	{
		int num = Physics.OverlapSphereNonAlloc(base.transform.position, radius, Utilities.colliderPool, layerMask, QueryTriggerInteraction.Collide);
		for (int i = 0; i < num; i++)
		{
			DamageTarget(Utilities.colliderPool[i]);
		}
		damageables.Clear();
		temperatureObjects.Clear();
	}

	private void DamageTarget(Collider other)
	{
		Type type = other.GetType();
		Ray ray;
		if (type != typeof(BoxCollider) && type != typeof(SphereCollider) && type != typeof(CapsuleCollider) && (!(type == typeof(MeshCollider)) || !((MeshCollider)other).convex))
		{
			ray = new Ray(other.transform.position, base.transform.position - other.transform.position);
		}
		else
		{
			Vector3 vector = other.ClosestPoint(base.transform.position);
			ray = new Ray(vector, base.transform.position - vector);
		}
		if (Physics.Raycast(ray, out var hitInfo, radius, layerMask, QueryTriggerInteraction.Ignore) && hitInfo.collider != other)
		{
			return;
		}
		IDamageable componentInParent = other.GetComponentInParent<IDamageable>();
		if (componentInParent != null && (affectPlayer || !other.transform.IsChildOf(Singleton<VRSystem>.Instance.transform)) && damageables.Add(componentInParent))
		{
			componentInParent.ApplyDamage((int)(float)power, "TemperatureSetterBurst", (!isCold) ? DamageType.Fire : DamageType.Cold);
		}
		ITemperatureObject componentInParent2 = other.GetComponentInParent<ITemperatureObject>();
		if (componentInParent2 != null && temperatureObjects.Add(componentInParent2))
		{
			if (isCold)
			{
				componentInParent2.ApplyCold(power);
			}
			else
			{
				componentInParent2.ApplyHeat(power);
			}
		}
	}
}
public class TeleportArc : MonoBehaviour
{
	public MeshRenderer meshRenderer;

	public MeshFilter meshFilter;

	public Material validMaterial;

	public Material invalidMaterial;

	public Transform target;

	public GameObject validTarget;

	public GameObject invalidTarget;

	public Transform pointer;

	public Transform surfaceTracker;

	public float maxYDistance = 3.5f;

	public int maxPhysicsSegments = 40;

	public float physicsResolution = 0.05f;

	public float velocity = 5f;

	[UnityEngine.Tooltip("The destination must be on this layer for the player to teleport to it")]
	public LayerMask teleportableLayerMask;

	[UnityEngine.Tooltip("The arc stops when it hits this layer")]
	public LayerMask collisionLayerMask;

	[UnityEngine.Tooltip("If the arc passes through this layer, it is invalid")]
	public LayerMask blockTeleportLayerMask;

	public float meshWidth;

	public int arcSegments = 20;

	private Vector3 _hitNormal;

	private int _hitLayer;

	private static Vector3 gravity = new Vector3(0f, -9.8f, 0f);

	private Vector3[] _vertices;

	private int[] _triangles;

	private float _radianAngle;

	private LayerMask _allLayerMask;

	private bool _invalid;

	private Vector3[] _arcArray;

	private Transform _hitObject;

	private bool _targetLocked;

	private void OnValidate()
	{
		Awake();
	}

	private void Awake()
	{
		_allLayerMask = (int)collisionLayerMask | (int)blockTeleportLayerMask;
		_vertices = new Vector3[(arcSegments + 1) * 4];
		_triangles = new int[arcSegments * 24 + 12];
		_arcArray = new Vector3[arcSegments + 1];
		for (int i = 0; i < arcSegments; i++)
		{
			_triangles[i * 24] = i * 4;
			_triangles[i * 24 + 1] = (_triangles[i * 24 + 4] = i * 4 + 1);
			_triangles[i * 24 + 2] = (_triangles[i * 24 + 3] = (i + 1) * 4);
			_triangles[i * 24 + 5] = (i + 1) * 4 + 1;
			_triangles[i * 24 + 6] = i * 4 + 2;
			_triangles[i * 24 + 7] = (_triangles[i * 24 + 10] = (i + 1) * 4 + 2);
			_triangles[i * 24 + 8] = (_triangles[i * 24 + 9] = i * 4 + 3);
			_triangles[i * 24 + 11] = (i + 1) * 4 + 3;
			_triangles[i * 24 + 12] = i * 4 + 2;
			_triangles[i * 24 + 13] = (_triangles[i * 24 + 16] = i * 4);
			_triangles[i * 24 + 14] = (_triangles[i * 24 + 15] = (i + 1) * 4 + 2);
			_triangles[i * 24 + 17] = (i + 1) * 4;
			_triangles[i * 24 + 18] = i * 4 + 3;
			_triangles[i * 24 + 19] = (_triangles[i * 24 + 22] = (i + 1) * 4 + 3);
			_triangles[i * 24 + 20] = (_triangles[i * 24 + 21] = i * 4 + 1);
			_triangles[i * 24 + 23] = (i + 1) * 4 + 1;
		}
		_triangles[arcSegments * 24] = 0;
		_triangles[arcSegments * 24 + 1] = (_triangles[arcSegments * 24 + 5] = 2);
		_triangles[arcSegments * 24 + 2] = (_triangles[arcSegments * 24 + 4] = 1);
		_triangles[arcSegments * 24 + 3] = 3;
		_triangles[arcSegments * 24 + 6] = (arcSegments + 1) * 4 - 4;
		_triangles[arcSegments * 24 + 7] = (_triangles[arcSegments * 24 + 11] = (arcSegments + 1) * 4 - 3);
		_triangles[arcSegments * 24 + 8] = (_triangles[arcSegments * 24 + 10] = (arcSegments + 1) * 4 - 2);
		_triangles[arcSegments * 24 + 9] = (arcSegments + 1) * 4 - 1;
	}

	public void Deactivate(bool cancel = false)
	{
		_invalid = true;
		_targetLocked = false;
		base.gameObject.SetActive(value: false);
		target.gameObject.SetActive(value: false);
		meshRenderer.enabled = false;
		if (cancel)
		{
			surfaceTracker.parent = base.transform;
		}
		else
		{
			Timing.RunCoroutine(DeactivateRoutine());
		}
	}

	private IEnumerator<float> DeactivateRoutine()
	{
		yield return Timing.WaitForSeconds(0.1f);
		surfaceTracker.parent = base.transform;
	}

	private void LateUpdate()
	{
		Vector3 v = pointer.forward * velocity;
		Vector3 vector = Vector3.zero;
		Vector3 vector2 = pointer.position;
		bool flag = false;
		_invalid = false;
		for (int i = 1; i < maxPhysicsSegments; i++)
		{
			Vector3 position = GetPosition(v, physicsResolution * (float)i);
			Vector3 direction = position - vector;
			int num = Physics.RaycastNonAlloc(pointer.position + vector, direction, Utilities.raycastHitPool, direction.magnitude, _allLayerMask, QueryTriggerInteraction.Ignore);
			Array.Sort(Utilities.raycastHitPool, 0, num, Utilities.RaycastHitDistanceComparer.Comparer);
			for (int j = 0; j < num; j++)
			{
				RaycastHit raycastHit = Utilities.raycastHitPool[j];
				if (!raycastHit.collider.transform.GetComponentInParent<VRSystem>())
				{
					if (((1 << raycastHit.collider.gameObject.layer) & (int)blockTeleportLayerMask) <= 0)
					{
						vector2 = raycastHit.point;
						_hitLayer = raycastHit.collider.gameObject.layer;
						_hitNormal = raycastHit.normal;
						flag = true;
						_hitObject = raycastHit.transform;
						break;
					}
					_invalid = true;
				}
			}
			if (flag)
			{
				break;
			}
			vector = position;
		}
		if (flag)
		{
			target.position = vector2;
			target.gameObject.SetActive(value: true);
			if (!_targetLocked)
			{
				if (surfaceTracker == null)
				{
					surfaceTracker = new GameObject("TeleportSurfaceTracker").transform;
				}
				surfaceTracker.position = target.position;
				surfaceTracker.rotation = target.rotation;
				surfaceTracker.parent = _hitObject;
			}
			Vector3 vector3 = pointer.position - vector2;
			vector3.y = 0f;
			CalculateArcArray(vector3.magnitude);
		}
		else
		{
			_invalid = true;
			target.gameObject.SetActive(value: false);
			CalculateArcArray(7f);
		}
		MakeArcMesh();
		meshRenderer.transform.position = pointer.position;
		meshRenderer.transform.rotation = Quaternion.Euler(0f, pointer.rotation.eulerAngles.y, 0f);
		meshRenderer.enabled = true;
		SetValid(IsTargetValid());
	}

	public void SetForwardRotation(Vector3 forward)
	{
		target.rotation = Quaternion.LookRotation(Vector3.ProjectOnPlane(forward, _hitNormal), _hitNormal);
	}

	public void LockTarget()
	{
		_targetLocked = true;
	}

	private void SetValid(bool valid)
	{
		if (valid)
		{
			validTarget.SetActive(value: true);
			invalidTarget.SetActive(value: false);
			meshRenderer.material = validMaterial;
		}
		else
		{
			validTarget.SetActive(value: false);
			invalidTarget.SetActive(value: true);
			meshRenderer.material = invalidMaterial;
		}
	}

	public bool IsTargetValid()
	{
		if (!_invalid && ((1 << _hitLayer) & (int)teleportableLayerMask) > 0 && Mathf.Abs(target.position.y - Player.Instance.playerFeet.position.y) <= maxYDistance && Vector3.Angle(_hitNormal, Vector3.up) < Player.Instance.characterController.slopeLimit)
		{
			return Player.Instance.IsPositionValid(target.position);
		}
		return false;
	}

	private Vector3 GetPosition(Vector3 v, float time)
	{
		return v * time + gravity * time * time / 2f;
	}

	private void MakeArcMesh()
	{
		meshFilter.mesh.Clear();
		float num = meshWidth * 0.5f;
		for (int i = 0; i <= arcSegments; i++)
		{
			Vector3 vector = ((i != 0) ? ((i >= arcSegments) ? (_arcArray[i] - _arcArray[i - 1]) : (_arcArray[i + 1] - _arcArray[i - 1])) : (_arcArray[i + 1] - _arcArray[i]));
			Vector3 vector2 = num * new Vector3(0f, vector.x, 0f - vector.y).normalized;
			_vertices[i * 4] = new Vector3(num, _arcArray[i].y, _arcArray[i].x) + vector2;
			_vertices[i * 4 + 1] = new Vector3(0f - num, _arcArray[i].y, _arcArray[i].x) + vector2;
			_vertices[i * 4 + 2] = new Vector3(num, _arcArray[i].y, _arcArray[i].x) - vector2;
			_vertices[i * 4 + 3] = new Vector3(0f - num, _arcArray[i].y, _arcArray[i].x) - vector2;
		}
		meshFilter.mesh.vertices = _vertices;
		meshFilter.mesh.triangles = _triangles;
	}

	private void CalculateArcArray(float maxDistance)
	{
		_radianAngle = (float)Math.PI / 180f * Vector3.SignedAngle(pointer.forward, Vector3.ProjectOnPlane(pointer.forward, Vector3.up), (pointer.up.y > 0f) ? pointer.right : (-pointer.right));
		float tan = Mathf.Tan(_radianAngle);
		float num = Mathf.Cos(_radianAngle);
		float factor = (0f - gravity.y) / (2f * velocity * velocity * num * num);
		for (int i = 0; i <= arcSegments; i++)
		{
			float t = (float)i / (float)arcSegments;
			_arcArray[i] = CalculateArcPoint(t, maxDistance, tan, factor);
		}
	}

	private Vector3 CalculateArcPoint(float t, float maxDistance, float tan, float factor)
	{
		float num = t * maxDistance;
		float y = num * tan - num * num * factor;
		return new Vector3(num, y);
	}
}
public class TeleportSettingsManager : MonoBehaviour
{
	public Toggle right;

	public Toggle left;

	public Toggle both;

	public GameObject teleportRight;

	public GameObject teleportLeft;

	public GameObject locomotionRight;

	public GameObject locomotionLeft;

	public void UpdateControls()
	{
		if (right.isOn)
		{
			teleportRight.SetActive(value: true);
			locomotionLeft.SetActive(value: true);
			teleportLeft.SetActive(value: false);
			locomotionRight.SetActive(value: false);
		}
		else if (left.isOn)
		{
			teleportRight.SetActive(value: false);
			locomotionLeft.SetActive(value: false);
			teleportLeft.SetActive(value: true);
			locomotionRight.SetActive(value: true);
		}
		else if (both.isOn)
		{
			teleportRight.SetActive(value: true);
			locomotionLeft.SetActive(value: false);
			teleportLeft.SetActive(value: true);
			locomotionRight.SetActive(value: false);
		}
	}
}
public class Caption : MonoBehaviour
{
	public CanvasGroup group;

	public Image background;

	public TextMeshProUGUI textBox;

	public Segment updateSegment;

	public float fadeTime = 0.2f;

	public bool followPlayer = true;

	public float followSpeed = 1f;

	public Vector3 followOffset;

	public OVRPlugin.FixedFoveatedRenderingLevel quest1FixedFoveatedRenderingLevel;

	private CoroutineHandle _handle;

	private CoroutineHandle _fadeHandle;

	private CoroutineHandle _followHandle;

	private bool _isShowingText;

	private string _textID;

	private bool _changedSurface;

	private bool _isPaused;

	private AudioSource _lastAudioSource;

	private void Awake()
	{
		UpdateText();
		GameEvent languageChanged = References.LanguageChanged;
		languageChanged.OnTrue = (System.Action)Delegate.Combine(languageChanged.OnTrue, new System.Action(UpdateText));
		TrackingSpace instance = Singleton<TrackingSpace>.Instance;
		instance.onChangedSurface = (System.Action)Delegate.Combine(instance.onChangedSurface, new System.Action(OnChangedSurface));
	}

	private void OnDestroy()
	{
		GameEvent languageChanged = References.LanguageChanged;
		languageChanged.OnTrue = (System.Action)Delegate.Remove(languageChanged.OnTrue, new System.Action(UpdateText));
		if (Singleton<TrackingSpace>.Instance != null)
		{
			TrackingSpace instance = Singleton<TrackingSpace>.Instance;
			instance.onChangedSurface = (System.Action)Delegate.Remove(instance.onChangedSurface, new System.Action(OnChangedSurface));
		}
	}

	private void OnChangedSurface()
	{
		_changedSurface = true;
	}

	public void DisplayTextString(string textID, float duration, bool forceDisplay = false)
	{
		if (textID != null && (forceDisplay || Settings.Current.subtitles))
		{
			_handle = Timing.RunCoroutineSingleton(RunTextString(textID, duration), _handle, updateSegment, SingletonBehavior.Overwrite);
		}
	}

	public void DisplayText(string textID, float duration, AudioSource source, bool forceDisplay = false)
	{
		if (source != null && source != _lastAudioSource)
		{
			if (_lastAudioSource != null && _lastAudioSource.isPlaying)
			{
				_lastAudioSource.Stop();
			}
			_lastAudioSource = source;
		}
		if (textID != null && (forceDisplay || Settings.Current.subtitles))
		{
			_handle = Timing.RunCoroutineSingleton(RunText(textID, duration), _handle, updateSegment, SingletonBehavior.Overwrite);
		}
	}

	public void EndDisplay()
	{
		if (_isShowingText)
		{
			_handle = Timing.RunCoroutineSingleton(EndText(), _handle, updateSegment, SingletonBehavior.Overwrite);
		}
	}

	private IEnumerator<float> EndText()
	{
		_fadeHandle = Timing.RunCoroutineSingleton(FadeOut(), _fadeHandle, updateSegment, SingletonBehavior.Overwrite);
		yield return Timing.WaitUntilDone(_fadeHandle);
		_isShowingText = false;
		base.gameObject.SetActive(value: false);
		if (OVRPlugin.GetSystemHeadsetType() == OVRPlugin.SystemHeadset.Oculus_Quest)
		{
			OVRPlugin.fixedFoveatedRenderingLevel = OVRPlugin.FixedFoveatedRenderingLevel.Off;
		}
		References.OnCaptionsShow.RaiseFalse();
	}

	private void UpdateText()
	{
		textBox.font = LocalizationManager.GetFont(isCaption: true);
		if (!string.IsNullOrEmpty(_textID))
		{
			textBox.text = LocalizationManager.GetText(_textID);
			if (background != null)
			{
				Timing.RunCoroutine(SetImageSize());
			}
		}
		else
		{
			textBox.text = string.Empty;
		}
	}

	private IEnumerator<float> SetImageSize()
	{
		yield return float.NegativeInfinity;
		Vector2 renderedValues = textBox.GetRenderedValues(onlyVisibleCharacters: true);
		background.rectTransform.sizeDelta = renderedValues / renderedValues.x * background.rectTransform.sizeDelta.x;
	}

	private IEnumerator<float> RunTextString(string text, float duration)
	{
		float startTime = Time.time;
		if (_isShowingText)
		{
			_fadeHandle = Timing.RunCoroutineSingleton(FadeOut(), _fadeHandle, updateSegment, SingletonBehavior.Overwrite);
			yield return Timing.WaitUntilDone(_fadeHandle);
		}
		if (OVRPlugin.GetSystemHeadsetType() == OVRPlugin.SystemHeadset.Oculus_Quest)
		{
			OVRPlugin.fixedFoveatedRenderingLevel = quest1FixedFoveatedRenderingLevel;
		}
		base.gameObject.SetActive(value: true);
		_isShowingText = true;
		References.OnCaptionsShow.RaiseTrue();
		_textID = text;
		textBox.text = text;
		_fadeHandle = Timing.RunCoroutineSingleton(FadeIn(), _fadeHandle, updateSegment, SingletonBehavior.Overwrite);
		base.transform.position = References.Headset.TransformPoint(followOffset);
		base.transform.rotation = Quaternion.Euler(References.Headset.rotation.eulerAngles.x, References.Headset.rotation.eulerAngles.y, 0f);
		if (followPlayer)
		{
			_followHandle = Timing.RunCoroutineSingleton(FollowPlayer(), _followHandle, (updateSegment == Segment.Update) ? Segment.LateUpdate : updateSegment, SingletonBehavior.Abort);
		}
		yield return Timing.WaitForSeconds(Time.time - startTime + duration - fadeTime);
		_fadeHandle = Timing.RunCoroutineSingleton(FadeOut(), _fadeHandle, updateSegment, SingletonBehavior.Overwrite);
		yield return Timing.WaitUntilDone(_fadeHandle);
		_isShowingText = false;
		base.gameObject.SetActive(value: false);
		if (OVRPlugin.GetSystemHeadsetType() == OVRPlugin.SystemHeadset.Oculus_Quest)
		{
			OVRPlugin.fixedFoveatedRenderingLevel = OVRPlugin.FixedFoveatedRenderingLevel.Off;
		}
		References.OnCaptionsShow.RaiseFalse();
	}

	private IEnumerator<float> RunText(string textID, float duration)
	{
		float startTime = Time.time;
		if (_isShowingText)
		{
			_fadeHandle = Timing.RunCoroutineSingleton(FadeOut(), _fadeHandle, updateSegment, SingletonBehavior.Overwrite);
			yield return Timing.WaitUntilDone(_fadeHandle);
		}
		if (OVRPlugin.GetSystemHeadsetType() == OVRPlugin.SystemHeadset.Oculus_Quest)
		{
			OVRPlugin.fixedFoveatedRenderingLevel = quest1FixedFoveatedRenderingLevel;
		}
		base.gameObject.SetActive(value: true);
		_isShowingText = true;
		References.OnCaptionsShow.RaiseTrue();
		_textID = textID;
		textBox.text = LocalizationManager.GetText(textID);
		_fadeHandle = Timing.RunCoroutineSingleton(FadeIn(), _fadeHandle, updateSegment, SingletonBehavior.Overwrite);
		base.transform.position = References.Headset.TransformPoint(followOffset);
		base.transform.rotation = Quaternion.Euler(References.Headset.rotation.eulerAngles.x, References.Headset.rotation.eulerAngles.y, 0f);
		if (followPlayer)
		{
			_followHandle = Timing.RunCoroutineSingleton(FollowPlayer(), _followHandle, (updateSegment == Segment.Update) ? Segment.LateUpdate : updateSegment, SingletonBehavior.Abort);
		}
		if (background != null)
		{
			yield return float.NegativeInfinity;
			Vector2 renderedValues = textBox.GetRenderedValues(onlyVisibleCharacters: true);
			background.rectTransform.sizeDelta = renderedValues / renderedValues.x * background.rectTransform.sizeDelta.x;
		}
		if (updateSegment == Segment.Update)
		{
			yield return Timing.WaitForSeconds(Time.time - startTime + duration - fadeTime);
		}
		else
		{
			float t = Time.time - startTime + duration - fadeTime;
			while (t > 0f)
			{
				if (!VRSystem.IsPaused)
				{
					t -= Time.unscaledDeltaTime;
				}
				yield return float.NegativeInfinity;
			}
		}
		_fadeHandle = Timing.RunCoroutineSingleton(FadeOut(), _fadeHandle, updateSegment, SingletonBehavior.Overwrite);
		yield return Timing.WaitUntilDone(_fadeHandle);
		_isShowingText = false;
		base.gameObject.SetActive(value: false);
		if (OVRPlugin.GetSystemHeadsetType() == OVRPlugin.SystemHeadset.Oculus_Quest)
		{
			OVRPlugin.fixedFoveatedRenderingLevel = OVRPlugin.FixedFoveatedRenderingLevel.Off;
		}
		References.OnCaptionsShow.RaiseFalse();
	}

	private IEnumerator<float> FollowPlayer()
	{
		Transform surface = Singleton<TrackingSpace>.Instance.surfaceTracker;
		Vector3 surfacePos = Singleton<TrackingSpace>.Instance.surfaceTracker.position;
		while (_isShowingText)
		{
			if (VRSystem.IsPaused)
			{
				if (!_isPaused)
				{
					_isPaused = true;
					Timing.PauseCoroutines(_handle, _fadeHandle);
				}
				yield return float.NegativeInfinity;
				continue;
			}
			if (_isPaused)
			{
				Timing.ResumeCoroutines(_handle, _fadeHandle);
				_isPaused = false;
			}
			Vector3 b = References.Headset.TransformPoint(followOffset);
			Vector3 a = (_changedSurface ? base.transform.position : (base.transform.position + surface.position - surfacePos));
			_changedSurface = false;
			surfacePos = surface.position;
			base.transform.position = Vector3.Slerp(a, b, ((updateSegment == Segment.Update) ? Time.deltaTime : Time.unscaledDeltaTime) * followSpeed);
			base.transform.rotation = Quaternion.LookRotation(base.transform.position - References.Headset.position, References.Headset.up);
			yield return float.NegativeInfinity;
		}
	}

	private IEnumerator<float> FadeIn()
	{
		while (group.alpha < 1f)
		{
			group.alpha += ((updateSegment == Segment.Update) ? Time.deltaTime : Time.unscaledDeltaTime) / fadeTime;
			if (group.alpha >= 1f)
			{
				group.alpha = 1f;
				break;
			}
			yield return float.NegativeInfinity;
		}
	}

	private IEnumerator<float> FadeOut()
	{
		while (group.alpha > 0f)
		{
			group.alpha -= ((updateSegment == Segment.Update) ? Time.deltaTime : Time.unscaledDeltaTime) / fadeTime;
			if (group.alpha <= 0f)
			{
				group.alpha = 0f;
				break;
			}
			yield return float.NegativeInfinity;
		}
	}
}
public class CaptionCamera : MonoBehaviour
{
	private void Start()
	{
		GameEvent onCaptionsShow = References.OnCaptionsShow;
		onCaptionsShow.OnRaise = (Action<bool>)Delegate.Combine(onCaptionsShow.OnRaise, new Action<bool>(CheckCaptions));
		base.gameObject.SetActive(value: false);
	}

	private void OnDestroy()
	{
		GameEvent onCaptionsShow = References.OnCaptionsShow;
		onCaptionsShow.OnRaise = (Action<bool>)Delegate.Remove(onCaptionsShow.OnRaise, new Action<bool>(CheckCaptions));
	}

	private void CheckCaptions(bool on)
	{
		base.gameObject.SetActive(References.Subtitles.gameObject.activeSelf || References.MenuSubtitles.gameObject.activeSelf || References.SystemText.gameObject.activeSelf);
	}
}
[ExecuteInEditMode]
public class LocalizationManager : Singleton<LocalizationManager>
{
	public TMP_FontAsset font;

	public TMP_FontAsset fontKorean;

	public TMP_FontAsset fontJapanese;

	public TMP_FontAsset fontCaption;

	public TMP_FontAsset fontKoreanCaption;

	public TMP_FontAsset fontJapaneseCaption;

	private static Language? _currentLanguage;

	private static Dictionary<string, string> _allText = new Dictionary<string, string>();

	protected override void Awake()
	{
		base.Awake();
		SetLanguage(GetDefaultLanguage());
	}

	public static Language GetDefaultLanguage()
	{
		return UnityEngine.Application.systemLanguage switch
		{
			SystemLanguage.French => Language.French, 
			SystemLanguage.German => Language.German, 
			SystemLanguage.Korean => Language.Korean, 
			SystemLanguage.Japanese => Language.Japanese, 
			SystemLanguage.Spanish => Language.LatinAmericanSpanish, 
			_ => Language.English, 
		};
	}

	public void SetLanguage(int languageID)
	{
		SetLanguage((Language)languageID);
	}

	public void SetLanguage(Language language)
	{
		if (_currentLanguage == language)
		{
			return;
		}
		_currentLanguage = language;
		_allText.Clear();
		string[] array = Resources.Load<TextAsset>("Localizations/" + language).text.Replace("\r", "").Split("\n"[0]);
		char[] separator = new char[1] { ',' };
		for (int i = 0; i < array.Length; i++)
		{
			string[] array2 = array[i].Split(separator, 2, StringSplitOptions.None);
			if (array2[1][0] == '"' && array2[1][array2[1].Length - 1] == '"')
			{
				array2[1] = array2[1].Substring(1, array2[1].Length - 2).Replace("\"\"", "\"");
			}
			else
			{
				array2[1] = array2[1].Replace("\"\"", "\"");
			}
			_allText.Add(array2[0], array2[1]);
		}
		References.LanguageChanged?.RaiseTrue();
	}

	public static string GetText(string id)
	{
		if (_allText.ContainsKey(id))
		{
			return _allText[id];
		}
		return null;
	}

	public static TMP_FontAsset GetFont(bool isCaption = false)
	{
		switch (_currentLanguage)
		{
		case Language.Korean:
			if (!isCaption)
			{
				return Singleton<LocalizationManager>.Instance.fontKorean;
			}
			return Singleton<LocalizationManager>.Instance.fontKoreanCaption;
		case Language.Japanese:
			if (!isCaption)
			{
				return Singleton<LocalizationManager>.Instance.fontJapanese;
			}
			return Singleton<LocalizationManager>.Instance.fontJapaneseCaption;
		default:
			if (!isCaption)
			{
				return Singleton<LocalizationManager>.Instance.font;
			}
			return Singleton<LocalizationManager>.Instance.fontCaption;
		}
	}
}
public class LocalizeText : MonoBehaviour
{
	public string textID;

	public TextMeshProUGUI textField;

	private void OnEnable()
	{
		UpdateText();
		GameEvent languageChanged = References.LanguageChanged;
		languageChanged.OnTrue = (System.Action)Delegate.Combine(languageChanged.OnTrue, new System.Action(UpdateText));
	}

	private void OnDisable()
	{
		GameEvent languageChanged = References.LanguageChanged;
		languageChanged.OnTrue = (System.Action)Delegate.Remove(languageChanged.OnTrue, new System.Action(UpdateText));
	}

	private void OnDestroy()
	{
		GameEvent languageChanged = References.LanguageChanged;
		languageChanged.OnTrue = (System.Action)Delegate.Remove(languageChanged.OnTrue, new System.Action(UpdateText));
	}

	public void UpdateText()
	{
		textField.text = LocalizationManager.GetText(textID);
		textField.font = LocalizationManager.GetFont();
	}

	public void SetText(string textID)
	{
		this.textID = textID;
		UpdateText();
	}
}
public class TutorialText : MonoBehaviour
{
	public string textID;

	[UnityEngine.Tooltip("Text ID to use for left hand, if different (leave blank otherwise)")]
	public string leftTextID;

	[UnityEngine.Tooltip("Text ID to use for both hands. If set, all options refer to teleport settings instead of primary hand.")]
	public string bothTextID;

	public TextMeshProUGUI textBox;

	private void Awake()
	{
		GameEvent languageChanged = References.LanguageChanged;
		languageChanged.OnTrue = (System.Action)Delegate.Combine(languageChanged.OnTrue, new System.Action(UpdateText));
		GameEvent handChanged = References.HandChanged;
		handChanged.OnRaise = (Action<bool>)Delegate.Combine(handChanged.OnRaise, new Action<bool>(UpdateText));
		GameEvent teleportHandChanged = References.TeleportHandChanged;
		teleportHandChanged.OnTrue = (System.Action)Delegate.Combine(teleportHandChanged.OnTrue, new System.Action(UpdateText));
	}

	private void OnEnable()
	{
		if (!Settings.Current.toolTips)
		{
			base.gameObject.SetActive(value: false);
		}
		else
		{
			UpdateText();
		}
	}

	private void OnDestroy()
	{
		GameEvent languageChanged = References.LanguageChanged;
		languageChanged.OnTrue = (System.Action)Delegate.Remove(languageChanged.OnTrue, new System.Action(UpdateText));
		GameEvent handChanged = References.HandChanged;
		handChanged.OnRaise = (Action<bool>)Delegate.Remove(handChanged.OnRaise, new Action<bool>(UpdateText));
		GameEvent teleportHandChanged = References.TeleportHandChanged;
		teleportHandChanged.OnTrue = (System.Action)Delegate.Remove(teleportHandChanged.OnTrue, new System.Action(UpdateText));
	}

	private void UpdateText(bool right)
	{
		UpdateText();
	}

	private void UpdateText()
	{
		if (!string.IsNullOrEmpty(bothTextID))
		{
			textBox.text = LocalizationManager.GetText((Settings.Current.teleportHand == HandMode.Both) ? bothTextID : ((Settings.Current.teleportHand == HandMode.Left) ? leftTextID : textID));
		}
		else
		{
			textBox.text = LocalizationManager.GetText((!string.IsNullOrEmpty(leftTextID) && Settings.Current.dominantHand == HandMode.Left) ? leftTextID : textID);
		}
		textBox.font = LocalizationManager.GetFont();
	}
}
public class TextureLocalizer : MonoBehaviour
{
	public Texture2D[] textures;

	private void Awake()
	{
		GetComponent<Renderer>().material.mainTexture = textures[(int)LocalizationManager.GetDefaultLanguage()];
	}
}
[ExecuteInEditMode]
public class UniqueId : MonoBehaviour
{
	public string uniqueId;

	private static readonly Dictionary<string, UniqueId> IDs = new Dictionary<string, UniqueId>();

	public static GameObject Find(string ID)
	{
		if (string.IsNullOrEmpty(ID))
		{
			return null;
		}
		if (IDs.ContainsKey(ID) && IDs[ID] != null)
		{
			return IDs[ID].gameObject;
		}
		UniqueId[] array = Resources.FindObjectsOfTypeAll<UniqueId>();
		IDs.Clear();
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].gameObject.scene.name != null)
			{
				if (string.IsNullOrEmpty(array[i].uniqueId))
				{
					UnityEngine.Debug.LogError(string.Concat("Missing Unique ID: ", array[i], ". Looking for ID: ", ID));
				}
				else
				{
					IDs.Add(array[i].uniqueId, array[i]);
				}
			}
		}
		if (IDs.ContainsKey(ID))
		{
			return IDs[ID].gameObject;
		}
		return null;
	}

	public static Transform FindTransform(string ID)
	{
		GameObject gameObject = Find(ID);
		if (gameObject == null)
		{
			return null;
		}
		return gameObject.transform;
	}

	public static T Find<T>(string ID) where T : Component
	{
		GameObject gameObject = Find(ID);
		if (gameObject == null)
		{
			return null;
		}
		return gameObject.GetComponent<T>();
	}
}
public class AssetLoader : MonoBehaviour
{
	private void Start()
	{
		AssetBundle.LoadFromFile($"/sdcard/Android/obb/com.Zojoi.ShadowgateVR/main.{31}.com.Zojoi.ShadowgateVR.obb");
	}
}
public static class BundleVersion
{
	public const int BUNDLEVERSION = 31;
}
public static class DebugExtension
{
	public static void DebugPoint(Vector3 position, Color color, float scale = 1f, float duration = 0f, bool depthTest = true)
	{
		color = ((color == default(Color)) ? Color.white : color);
		UnityEngine.Debug.DrawRay(position + Vector3.up * (scale * 0.5f), -Vector3.up * scale, color, duration, depthTest);
		UnityEngine.Debug.DrawRay(position + Vector3.right * (scale * 0.5f), -Vector3.right * scale, color, duration, depthTest);
		UnityEngine.Debug.DrawRay(position + Vector3.forward * (scale * 0.5f), -Vector3.forward * scale, color, duration, depthTest);
	}

	public static void DebugPoint(Vector3 position, float scale = 1f, float duration = 0f, bool depthTest = true)
	{
		DebugPoint(position, Color.white, scale, duration, depthTest);
	}

	public static void DebugBounds(Bounds bounds, Color color, float duration = 0f, bool depthTest = true)
	{
		Vector3 center = bounds.center;
		float x = bounds.extents.x;
		float y = bounds.extents.y;
		float z = bounds.extents.z;
		Vector3 start = center + new Vector3(x, y, z);
		Vector3 vector = center + new Vector3(x, y, 0f - z);
		Vector3 vector2 = center + new Vector3(0f - x, y, z);
		Vector3 vector3 = center + new Vector3(0f - x, y, 0f - z);
		Vector3 vector4 = center + new Vector3(x, 0f - y, z);
		Vector3 end = center + new Vector3(x, 0f - y, 0f - z);
		Vector3 vector5 = center + new Vector3(0f - x, 0f - y, z);
		Vector3 vector6 = center + new Vector3(0f - x, 0f - y, 0f - z);
		UnityEngine.Debug.DrawLine(start, vector2, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start, vector, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector2, vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector, vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start, vector4, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector, end, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector2, vector5, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector3, vector6, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector4, vector5, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector4, end, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector5, vector6, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector6, end, color, duration, depthTest);
	}

	public static void DebugBounds(Bounds bounds, float duration = 0f, bool depthTest = true)
	{
		DebugBounds(bounds, Color.white, duration, depthTest);
	}

	public static void DebugLocalCube(Transform transform, Vector3 size, Color color, Vector3 center = default(Vector3), float duration = 0f, bool depthTest = true)
	{
		Vector3 vector = transform.TransformPoint(center + -size * 0.5f);
		Vector3 vector2 = transform.TransformPoint(center + new Vector3(size.x, 0f - size.y, 0f - size.z) * 0.5f);
		Vector3 vector3 = transform.TransformPoint(center + new Vector3(size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector4 = transform.TransformPoint(center + new Vector3(0f - size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector5 = transform.TransformPoint(center + new Vector3(0f - size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector6 = transform.TransformPoint(center + new Vector3(size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector7 = transform.TransformPoint(center + size * 0.5f);
		Vector3 vector8 = transform.TransformPoint(center + new Vector3(0f - size.x, size.y, size.z) * 0.5f);
		UnityEngine.Debug.DrawLine(vector, vector2, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector2, vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector3, vector4, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector4, vector, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector5, vector6, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector6, vector7, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector7, vector8, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector8, vector5, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector, vector5, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector2, vector6, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector3, vector7, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector4, vector8, color, duration, depthTest);
	}

	public static void DebugLocalCube(Transform transform, Vector3 size, Vector3 center = default(Vector3), float duration = 0f, bool depthTest = true)
	{
		DebugLocalCube(transform, size, Color.white, center, duration, depthTest);
	}

	public static void DebugLocalCube(Matrix4x4 space, Vector3 size, Color color, Vector3 center = default(Vector3), float duration = 0f, bool depthTest = true)
	{
		color = ((color == default(Color)) ? Color.white : color);
		Vector3 vector = space.MultiplyPoint3x4(center + -size * 0.5f);
		Vector3 vector2 = space.MultiplyPoint3x4(center + new Vector3(size.x, 0f - size.y, 0f - size.z) * 0.5f);
		Vector3 vector3 = space.MultiplyPoint3x4(center + new Vector3(size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector4 = space.MultiplyPoint3x4(center + new Vector3(0f - size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector5 = space.MultiplyPoint3x4(center + new Vector3(0f - size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector6 = space.MultiplyPoint3x4(center + new Vector3(size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector7 = space.MultiplyPoint3x4(center + size * 0.5f);
		Vector3 vector8 = space.MultiplyPoint3x4(center + new Vector3(0f - size.x, size.y, size.z) * 0.5f);
		UnityEngine.Debug.DrawLine(vector, vector2, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector2, vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector3, vector4, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector4, vector, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector5, vector6, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector6, vector7, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector7, vector8, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector8, vector5, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector, vector5, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector2, vector6, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector3, vector7, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(vector4, vector8, color, duration, depthTest);
	}

	public static void DebugLocalCube(Matrix4x4 space, Vector3 size, Vector3 center = default(Vector3), float duration = 0f, bool depthTest = true)
	{
		DebugLocalCube(space, size, Color.white, center, duration, depthTest);
	}

	public static void DebugCircle(Vector3 position, Vector3 up, Color color, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		Vector3 vector = up.normalized * radius;
		Vector3 rhs = Vector3.Slerp(vector, -vector, 0.5f);
		Vector3 vector2 = Vector3.Cross(vector, rhs).normalized * radius;
		Matrix4x4 matrix4x = default(Matrix4x4);
		matrix4x[0] = vector2.x;
		matrix4x[1] = vector2.y;
		matrix4x[2] = vector2.z;
		matrix4x[4] = vector.x;
		matrix4x[5] = vector.y;
		matrix4x[6] = vector.z;
		matrix4x[8] = rhs.x;
		matrix4x[9] = rhs.y;
		matrix4x[10] = rhs.z;
		Vector3 start = position + matrix4x.MultiplyPoint3x4(new Vector3(Mathf.Cos(0f), 0f, Mathf.Sin(0f)));
		Vector3 vector3 = Vector3.zero;
		color = ((color == default(Color)) ? Color.white : color);
		for (int i = 0; i < 91; i++)
		{
			vector3.x = Mathf.Cos((float)(i * 4) * ((float)Math.PI / 180f));
			vector3.z = Mathf.Sin((float)(i * 4) * ((float)Math.PI / 180f));
			vector3.y = 0f;
			vector3 = position + matrix4x.MultiplyPoint3x4(vector3);
			UnityEngine.Debug.DrawLine(start, vector3, color, duration, depthTest);
			start = vector3;
		}
	}

	public static void DebugCircle(Vector3 position, Color color, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		DebugCircle(position, Vector3.up, color, radius, duration, depthTest);
	}

	public static void DebugCircle(Vector3 position, Vector3 up, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		DebugCircle(position, up, Color.white, radius, duration, depthTest);
	}

	public static void DebugCircle(Vector3 position, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		DebugCircle(position, Vector3.up, Color.white, radius, duration, depthTest);
	}

	public static void DebugWireSphere(Vector3 position, Color color, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		float num = 10f;
		Vector3 start = new Vector3(position.x, position.y + radius * Mathf.Sin(0f), position.z + radius * Mathf.Cos(0f));
		Vector3 start2 = new Vector3(position.x + radius * Mathf.Cos(0f), position.y, position.z + radius * Mathf.Sin(0f));
		Vector3 start3 = new Vector3(position.x + radius * Mathf.Cos(0f), position.y + radius * Mathf.Sin(0f), position.z);
		for (int i = 1; i < 37; i++)
		{
			Vector3 vector = new Vector3(position.x, position.y + radius * Mathf.Sin(num * (float)i * ((float)Math.PI / 180f)), position.z + radius * Mathf.Cos(num * (float)i * ((float)Math.PI / 180f)));
			Vector3 vector2 = new Vector3(position.x + radius * Mathf.Cos(num * (float)i * ((float)Math.PI / 180f)), position.y, position.z + radius * Mathf.Sin(num * (float)i * ((float)Math.PI / 180f)));
			Vector3 vector3 = new Vector3(position.x + radius * Mathf.Cos(num * (float)i * ((float)Math.PI / 180f)), position.y + radius * Mathf.Sin(num * (float)i * ((float)Math.PI / 180f)), position.z);
			UnityEngine.Debug.DrawLine(start, vector, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(start2, vector2, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(start3, vector3, color, duration, depthTest);
			start = vector;
			start2 = vector2;
			start3 = vector3;
		}
	}

	public static void DebugWireSphere(Vector3 position, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		DebugWireSphere(position, Color.white, radius, duration, depthTest);
	}

	public static void DebugCylinder(Vector3 start, Vector3 end, Color color, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		Vector3 vector = (end - start).normalized * radius;
		Vector3 vector2 = Vector3.Slerp(vector, -vector, 0.5f);
		Vector3 vector3 = Vector3.Cross(vector, vector2).normalized * radius;
		DebugCircle(start, vector, color, radius, duration, depthTest);
		DebugCircle(end, -vector, color, radius, duration, depthTest);
		DebugCircle((start + end) * 0.5f, vector, color, radius, duration, depthTest);
		UnityEngine.Debug.DrawLine(start + vector3, end + vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start - vector3, end - vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start + vector2, end + vector2, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start - vector2, end - vector2, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start - vector3, start + vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start - vector2, start + vector2, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(end - vector3, end + vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(end - vector2, end + vector2, color, duration, depthTest);
	}

	public static void DebugCylinder(Vector3 start, Vector3 end, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		DebugCylinder(start, end, Color.white, radius, duration, depthTest);
	}

	public static void DebugCone(Vector3 position, Vector3 direction, Color color, float angle = 45f, float duration = 0f, bool depthTest = true)
	{
		float magnitude = direction.magnitude;
		Vector3 vector = direction;
		Vector3 vector2 = Vector3.Slerp(vector, -vector, 0.5f);
		Vector3 vector3 = Vector3.Cross(vector, vector2).normalized * magnitude;
		direction = direction.normalized;
		Vector3 direction2 = Vector3.Slerp(vector, vector2, angle / 90f);
		Plane plane = new Plane(-direction, position + vector);
		Ray ray = new Ray(position, direction2);
		plane.Raycast(ray, out var enter);
		UnityEngine.Debug.DrawRay(position, direction2.normalized * enter, color);
		UnityEngine.Debug.DrawRay(position, Vector3.Slerp(vector, -vector2, angle / 90f).normalized * enter, color, duration, depthTest);
		UnityEngine.Debug.DrawRay(position, Vector3.Slerp(vector, vector3, angle / 90f).normalized * enter, color, duration, depthTest);
		UnityEngine.Debug.DrawRay(position, Vector3.Slerp(vector, -vector3, angle / 90f).normalized * enter, color, duration, depthTest);
		DebugCircle(position + vector, direction, color, (vector - direction2.normalized * enter).magnitude, duration, depthTest);
		DebugCircle(position + vector * 0.5f, direction, color, (vector * 0.5f - direction2.normalized * (enter * 0.5f)).magnitude, duration, depthTest);
	}

	public static void DebugCone(Vector3 position, Vector3 direction, float angle = 45f, float duration = 0f, bool depthTest = true)
	{
		DebugCone(position, direction, Color.white, angle, duration, depthTest);
	}

	public static void DebugCone(Vector3 position, Color color, float angle = 45f, float duration = 0f, bool depthTest = true)
	{
		DebugCone(position, Vector3.up, color, angle, duration, depthTest);
	}

	public static void DebugCone(Vector3 position, float angle = 45f, float duration = 0f, bool depthTest = true)
	{
		DebugCone(position, Vector3.up, Color.white, angle, duration, depthTest);
	}

	public static void DebugArrow(Vector3 position, Vector3 direction, Color color, float duration = 0f, bool depthTest = true)
	{
		UnityEngine.Debug.DrawRay(position, direction, color, duration, depthTest);
		DebugCone(position + direction, -direction * 0.333f, color, 15f, duration, depthTest);
	}

	public static void DebugArrow(Vector3 position, Vector3 direction, float duration = 0f, bool depthTest = true)
	{
		DebugArrow(position, direction, Color.white, duration, depthTest);
	}

	public static void DebugCapsule(Vector3 start, Vector3 end, Color color, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		Vector3 vector = (end - start).normalized * radius;
		Vector3 vector2 = Vector3.Slerp(vector, -vector, 0.5f);
		Vector3 vector3 = Vector3.Cross(vector, vector2).normalized * radius;
		float magnitude = (start - end).magnitude;
		float num = Mathf.Max(0f, magnitude * 0.5f - radius);
		Vector3 vector4 = (end + start) * 0.5f;
		start = vector4 + (start - vector4).normalized * num;
		end = vector4 + (end - vector4).normalized * num;
		DebugCircle(start, vector, color, radius, duration, depthTest);
		DebugCircle(end, -vector, color, radius, duration, depthTest);
		UnityEngine.Debug.DrawLine(start + vector3, end + vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start - vector3, end - vector3, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start + vector2, end + vector2, color, duration, depthTest);
		UnityEngine.Debug.DrawLine(start - vector2, end - vector2, color, duration, depthTest);
		for (int i = 1; i < 26; i++)
		{
			UnityEngine.Debug.DrawLine(Vector3.Slerp(vector3, -vector, (float)i / 25f) + start, Vector3.Slerp(vector3, -vector, (float)(i - 1) / 25f) + start, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(Vector3.Slerp(-vector3, -vector, (float)i / 25f) + start, Vector3.Slerp(-vector3, -vector, (float)(i - 1) / 25f) + start, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(Vector3.Slerp(vector2, -vector, (float)i / 25f) + start, Vector3.Slerp(vector2, -vector, (float)(i - 1) / 25f) + start, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(Vector3.Slerp(-vector2, -vector, (float)i / 25f) + start, Vector3.Slerp(-vector2, -vector, (float)(i - 1) / 25f) + start, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(Vector3.Slerp(vector3, vector, (float)i / 25f) + end, Vector3.Slerp(vector3, vector, (float)(i - 1) / 25f) + end, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(Vector3.Slerp(-vector3, vector, (float)i / 25f) + end, Vector3.Slerp(-vector3, vector, (float)(i - 1) / 25f) + end, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(Vector3.Slerp(vector2, vector, (float)i / 25f) + end, Vector3.Slerp(vector2, vector, (float)(i - 1) / 25f) + end, color, duration, depthTest);
			UnityEngine.Debug.DrawLine(Vector3.Slerp(-vector2, vector, (float)i / 25f) + end, Vector3.Slerp(-vector2, vector, (float)(i - 1) / 25f) + end, color, duration, depthTest);
		}
	}

	public static void DebugCapsule(Vector3 start, Vector3 end, float radius = 1f, float duration = 0f, bool depthTest = true)
	{
		DebugCapsule(start, end, Color.white, radius, duration, depthTest);
	}

	public static void DrawPoint(Vector3 position, Color color, float scale = 1f)
	{
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Gizmos.DrawRay(position + Vector3.up * (scale * 0.5f), -Vector3.up * scale);
		Gizmos.DrawRay(position + Vector3.right * (scale * 0.5f), -Vector3.right * scale);
		Gizmos.DrawRay(position + Vector3.forward * (scale * 0.5f), -Vector3.forward * scale);
		Gizmos.color = color2;
	}

	public static void DrawPoint(Vector3 position, float scale = 1f)
	{
		DrawPoint(position, Color.white, scale);
	}

	public static void DrawBounds(Bounds bounds, Color color)
	{
		Vector3 center = bounds.center;
		float x = bounds.extents.x;
		float y = bounds.extents.y;
		float z = bounds.extents.z;
		Vector3 from = center + new Vector3(x, y, z);
		Vector3 vector = center + new Vector3(x, y, 0f - z);
		Vector3 vector2 = center + new Vector3(0f - x, y, z);
		Vector3 vector3 = center + new Vector3(0f - x, y, 0f - z);
		Vector3 vector4 = center + new Vector3(x, 0f - y, z);
		Vector3 to = center + new Vector3(x, 0f - y, 0f - z);
		Vector3 vector5 = center + new Vector3(0f - x, 0f - y, z);
		Vector3 vector6 = center + new Vector3(0f - x, 0f - y, 0f - z);
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Gizmos.DrawLine(from, vector2);
		Gizmos.DrawLine(from, vector);
		Gizmos.DrawLine(vector2, vector3);
		Gizmos.DrawLine(vector, vector3);
		Gizmos.DrawLine(from, vector4);
		Gizmos.DrawLine(vector, to);
		Gizmos.DrawLine(vector2, vector5);
		Gizmos.DrawLine(vector3, vector6);
		Gizmos.DrawLine(vector4, vector5);
		Gizmos.DrawLine(vector4, to);
		Gizmos.DrawLine(vector5, vector6);
		Gizmos.DrawLine(vector6, to);
		Gizmos.color = color2;
	}

	public static void DrawBounds(Bounds bounds)
	{
		DrawBounds(bounds, Color.white);
	}

	public static void DrawLocalCube(Transform transform, Vector3 size, Color color, Vector3 center = default(Vector3))
	{
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Vector3 vector = transform.TransformPoint(center + -size * 0.5f);
		Vector3 vector2 = transform.TransformPoint(center + new Vector3(size.x, 0f - size.y, 0f - size.z) * 0.5f);
		Vector3 vector3 = transform.TransformPoint(center + new Vector3(size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector4 = transform.TransformPoint(center + new Vector3(0f - size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector5 = transform.TransformPoint(center + new Vector3(0f - size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector6 = transform.TransformPoint(center + new Vector3(size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector7 = transform.TransformPoint(center + size * 0.5f);
		Vector3 vector8 = transform.TransformPoint(center + new Vector3(0f - size.x, size.y, size.z) * 0.5f);
		Gizmos.DrawLine(vector, vector2);
		Gizmos.DrawLine(vector2, vector3);
		Gizmos.DrawLine(vector3, vector4);
		Gizmos.DrawLine(vector4, vector);
		Gizmos.DrawLine(vector5, vector6);
		Gizmos.DrawLine(vector6, vector7);
		Gizmos.DrawLine(vector7, vector8);
		Gizmos.DrawLine(vector8, vector5);
		Gizmos.DrawLine(vector, vector5);
		Gizmos.DrawLine(vector2, vector6);
		Gizmos.DrawLine(vector3, vector7);
		Gizmos.DrawLine(vector4, vector8);
		Gizmos.color = color2;
	}

	public static void DrawLocalCube(Transform transform, Vector3 size, Vector3 center = default(Vector3))
	{
		DrawLocalCube(transform, size, Color.white, center);
	}

	public static void DrawLocalCube(Matrix4x4 space, Vector3 size, Color color, Vector3 center = default(Vector3))
	{
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Vector3 vector = space.MultiplyPoint3x4(center + -size * 0.5f);
		Vector3 vector2 = space.MultiplyPoint3x4(center + new Vector3(size.x, 0f - size.y, 0f - size.z) * 0.5f);
		Vector3 vector3 = space.MultiplyPoint3x4(center + new Vector3(size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector4 = space.MultiplyPoint3x4(center + new Vector3(0f - size.x, 0f - size.y, size.z) * 0.5f);
		Vector3 vector5 = space.MultiplyPoint3x4(center + new Vector3(0f - size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector6 = space.MultiplyPoint3x4(center + new Vector3(size.x, size.y, 0f - size.z) * 0.5f);
		Vector3 vector7 = space.MultiplyPoint3x4(center + size * 0.5f);
		Vector3 vector8 = space.MultiplyPoint3x4(center + new Vector3(0f - size.x, size.y, size.z) * 0.5f);
		Gizmos.DrawLine(vector, vector2);
		Gizmos.DrawLine(vector2, vector3);
		Gizmos.DrawLine(vector3, vector4);
		Gizmos.DrawLine(vector4, vector);
		Gizmos.DrawLine(vector5, vector6);
		Gizmos.DrawLine(vector6, vector7);
		Gizmos.DrawLine(vector7, vector8);
		Gizmos.DrawLine(vector8, vector5);
		Gizmos.DrawLine(vector, vector5);
		Gizmos.DrawLine(vector2, vector6);
		Gizmos.DrawLine(vector3, vector7);
		Gizmos.DrawLine(vector4, vector8);
		Gizmos.color = color2;
	}

	public static void DrawLocalCube(Matrix4x4 space, Vector3 size, Vector3 center = default(Vector3))
	{
		DrawLocalCube(space, size, Color.white, center);
	}

	public static void DrawCircle(Vector3 position, Vector3 up, Color color, float radius = 1f)
	{
		up = ((up == Vector3.zero) ? Vector3.up : up).normalized * radius;
		Vector3 rhs = Vector3.Slerp(up, -up, 0.5f);
		Vector3 vector = Vector3.Cross(up, rhs).normalized * radius;
		Matrix4x4 matrix4x = default(Matrix4x4);
		matrix4x[0] = vector.x;
		matrix4x[1] = vector.y;
		matrix4x[2] = vector.z;
		matrix4x[4] = up.x;
		matrix4x[5] = up.y;
		matrix4x[6] = up.z;
		matrix4x[8] = rhs.x;
		matrix4x[9] = rhs.y;
		matrix4x[10] = rhs.z;
		Vector3 from = position + matrix4x.MultiplyPoint3x4(new Vector3(Mathf.Cos(0f), 0f, Mathf.Sin(0f)));
		Vector3 vector2 = Vector3.zero;
		Color color2 = Gizmos.color;
		Gizmos.color = ((color == default(Color)) ? Color.white : color);
		for (int i = 0; i < 91; i++)
		{
			vector2.x = Mathf.Cos((float)(i * 4) * ((float)Math.PI / 180f));
			vector2.z = Mathf.Sin((float)(i * 4) * ((float)Math.PI / 180f));
			vector2.y = 0f;
			vector2 = position + matrix4x.MultiplyPoint3x4(vector2);
			Gizmos.DrawLine(from, vector2);
			from = vector2;
		}
		Gizmos.color = color2;
	}

	public static void DrawCircle(Vector3 position, Color color, float radius = 1f)
	{
		DrawCircle(position, Vector3.up, color, radius);
	}

	public static void DrawCircle(Vector3 position, Vector3 up, float radius = 1f)
	{
		DrawCircle(position, position, Color.white, radius);
	}

	public static void DrawCircle(Vector3 position, float radius = 1f)
	{
		DrawCircle(position, Vector3.up, Color.white, radius);
	}

	public static void DrawCylinder(Vector3 start, Vector3 end, Color color, float radius = 1f)
	{
		Vector3 vector = (end - start).normalized * radius;
		Vector3 vector2 = Vector3.Slerp(vector, -vector, 0.5f);
		Vector3 vector3 = Vector3.Cross(vector, vector2).normalized * radius;
		DrawCircle(start, vector, color, radius);
		DrawCircle(end, -vector, color, radius);
		DrawCircle((start + end) * 0.5f, vector, color, radius);
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Gizmos.DrawLine(start + vector3, end + vector3);
		Gizmos.DrawLine(start - vector3, end - vector3);
		Gizmos.DrawLine(start + vector2, end + vector2);
		Gizmos.DrawLine(start - vector2, end - vector2);
		Gizmos.DrawLine(start - vector3, start + vector3);
		Gizmos.DrawLine(start - vector2, start + vector2);
		Gizmos.DrawLine(end - vector3, end + vector3);
		Gizmos.DrawLine(end - vector2, end + vector2);
		Gizmos.color = color2;
	}

	public static void DrawCylinder(Vector3 start, Vector3 end, float radius = 1f)
	{
		DrawCylinder(start, end, Color.white, radius);
	}

	public static void DrawCone(Vector3 position, Vector3 direction, Color color, float angle = 45f)
	{
		float magnitude = direction.magnitude;
		Vector3 vector = direction;
		Vector3 vector2 = Vector3.Slerp(vector, -vector, 0.5f);
		Vector3 vector3 = Vector3.Cross(vector, vector2).normalized * magnitude;
		direction = direction.normalized;
		Vector3 direction2 = Vector3.Slerp(vector, vector2, angle / 90f);
		Plane plane = new Plane(-direction, position + vector);
		Ray ray = new Ray(position, direction2);
		plane.Raycast(ray, out var enter);
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Gizmos.DrawRay(position, direction2.normalized * enter);
		Gizmos.DrawRay(position, Vector3.Slerp(vector, -vector2, angle / 90f).normalized * enter);
		Gizmos.DrawRay(position, Vector3.Slerp(vector, vector3, angle / 90f).normalized * enter);
		Gizmos.DrawRay(position, Vector3.Slerp(vector, -vector3, angle / 90f).normalized * enter);
		DrawCircle(position + vector, direction, color, (vector - direction2.normalized * enter).magnitude);
		DrawCircle(position + vector * 0.5f, direction, color, (vector * 0.5f - direction2.normalized * (enter * 0.5f)).magnitude);
		Gizmos.color = color2;
	}

	public static void DrawCone(Vector3 position, Vector3 direction, float angle = 45f)
	{
		DrawCone(position, direction, Color.white, angle);
	}

	public static void DrawCone(Vector3 position, Color color, float angle = 45f)
	{
		DrawCone(position, Vector3.up, color, angle);
	}

	public static void DrawCone(Vector3 position, float angle = 45f)
	{
		DrawCone(position, Vector3.up, Color.white, angle);
	}

	public static void DrawArrow(Vector3 position, Vector3 direction, Color color)
	{
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		Gizmos.DrawRay(position, direction);
		DrawCone(position + direction, -direction * 0.333f, color, 15f);
		Gizmos.color = color2;
	}

	public static void DrawArrow(Vector3 position, Vector3 direction)
	{
		DrawArrow(position, direction, Color.white);
	}

	public static void DrawCapsule(Vector3 start, Vector3 end, Color color, float radius = 1f)
	{
		Vector3 vector = (end - start).normalized * radius;
		Vector3 vector2 = Vector3.Slerp(vector, -vector, 0.5f);
		Vector3 vector3 = Vector3.Cross(vector, vector2).normalized * radius;
		Color color2 = Gizmos.color;
		Gizmos.color = color;
		float magnitude = (start - end).magnitude;
		float num = Mathf.Max(0f, magnitude * 0.5f - radius);
		Vector3 vector4 = (end + start) * 0.5f;
		start = vector4 + (start - vector4).normalized * num;
		end = vector4 + (end - vector4).normalized * num;
		DrawCircle(start, vector, color, radius);
		DrawCircle(end, -vector, color, radius);
		Gizmos.DrawLine(start + vector3, end + vector3);
		Gizmos.DrawLine(start - vector3, end - vector3);
		Gizmos.DrawLine(start + vector2, end + vector2);
		Gizmos.DrawLine(start - vector2, end - vector2);
		for (int i = 1; i < 26; i++)
		{
			Gizmos.DrawLine(Vector3.Slerp(vector3, -vector, (float)i / 25f) + start, Vector3.Slerp(vector3, -vector, (float)(i - 1) / 25f) + start);
			Gizmos.DrawLine(Vector3.Slerp(-vector3, -vector, (float)i / 25f) + start, Vector3.Slerp(-vector3, -vector, (float)(i - 1) / 25f) + start);
			Gizmos.DrawLine(Vector3.Slerp(vector2, -vector, (float)i / 25f) + start, Vector3.Slerp(vector2, -vector, (float)(i - 1) / 25f) + start);
			Gizmos.DrawLine(Vector3.Slerp(-vector2, -vector, (float)i / 25f) + start, Vector3.Slerp(-vector2, -vector, (float)(i - 1) / 25f) + start);
			Gizmos.DrawLine(Vector3.Slerp(vector3, vector, (float)i / 25f) + end, Vector3.Slerp(vector3, vector, (float)(i - 1) / 25f) + end);
			Gizmos.DrawLine(Vector3.Slerp(-vector3, vector, (float)i / 25f) + end, Vector3.Slerp(-vector3, vector, (float)(i - 1) / 25f) + end);
			Gizmos.DrawLine(Vector3.Slerp(vector2, vector, (float)i / 25f) + end, Vector3.Slerp(vector2, vector, (float)(i - 1) / 25f) + end);
			Gizmos.DrawLine(Vector3.Slerp(-vector2, vector, (float)i / 25f) + end, Vector3.Slerp(-vector2, vector, (float)(i - 1) / 25f) + end);
		}
		Gizmos.color = color2;
	}

	public static void DrawCapsule(Vector3 start, Vector3 end, float radius = 1f)
	{
		DrawCapsule(start, end, Color.white, radius);
	}

	public static string MethodsOfObject(object obj, bool includeInfo = false)
	{
		string text = "";
		MethodInfo[] methods = obj.GetType().GetMethods();
		for (int i = 0; i < methods.Length; i++)
		{
			text = ((!includeInfo) ? (text + methods[i].Name + "\n") : string.Concat(text, methods[i], "\n"));
		}
		return text;
	}

	public static string MethodsOfType(Type type, bool includeInfo = false)
	{
		string text = "";
		MethodInfo[] methods = type.GetMethods();
		for (int i = 0; i < methods.Length; i++)
		{
			text = ((!includeInfo) ? (text + methods[i].Name + "\n") : string.Concat(text, methods[i], "\n"));
		}
		return text;
	}
}
public class EnumFlagsAttribute : PropertyAttribute
{
	public string enumName;

	public EnumFlagsAttribute()
	{
	}

	public EnumFlagsAttribute(string name)
	{
		enumName = name;
	}
}
public enum HandPose
{
	Idle,
	GrabWand,
	GrabWide,
	Fist,
	GrabLever,
	GrabLeverUpDown,
	HoldOilcan,
	HoldGem,
	HoldKey,
	HoldGear,
	GrabValve1,
	Reaching
}
public enum Axis
{
	X,
	Y,
	Z
}
[Flags]
public enum DamageType
{
	None = 0,
	Fire = 1,
	Cold = 2,
	Lightning = 4,
	Poison = 8
}
public enum ColliderType
{
	Sphere,
	Box,
	Capsule
}
public enum Gender
{
	Male,
	Female
}
[Flags]
public enum HandMode
{
	Right = 1,
	Left = 2,
	Both = 3
}
public enum TeleportMode
{
	Blink,
	Dash
}
public enum TurnMode
{
	Snap,
	Smooth
}
public enum TurnDegrees
{
	Thirty = 30,
	FortyFive = 45,
	Ninety = 90
}
public enum ComfortMode
{
	Stand,
	Sit
}
public enum Difficulty
{
	Easy = 1,
	Normal,
	Hard
}
public enum GameEvents
{
	AllowTeleport = 1,
	Combat,
	HintRequested,
	OdinSummonRequested,
	OdinView,
	OdinViewRequested,
	OdinViewTransition,
	OnGameLoaded,
	OnPlayerDamaged,
	OnPlayerDeath,
	OnPlayerHealed,
	OnPlayerRespawn,
	OnRotated,
	OnTeleported,
	PlayerInsideWall,
	ComfortModeChanged,
	DifficultyChanged,
	OnGamePaused,
	OnCaptionsShow
}
[Flags]
public enum DamageTargets
{
	Player = 1,
	Enemies = 2,
	Objects = 4
}
public enum Language
{
	English,
	French,
	German,
	Korean,
	Japanese,
	LatinAmericanSpanish
}
public class ObjectID : MonoBehaviour
{
	[UnityEngine.Tooltip("Unique ID. This can be any string. Should not be modified directly at runtime.")]
	[SerializeField]
	private string ID;

	private static readonly Dictionary<string, GameObject> _index = new Dictionary<string, GameObject>();

	protected virtual void OnValidate()
	{
		if (string.IsNullOrEmpty(ID))
		{
			ID = GetRandomID();
		}
	}

	protected virtual void Awake()
	{
		if (!_index.ContainsKey(ID))
		{
			_index.Add(ID, base.gameObject);
		}
	}

	protected virtual void OnDestroy()
	{
		_index.Remove(ID);
	}

	private static string GetRandomID()
	{
		string text = UnityEngine.Random.Range(10000000, 100000000).ToString();
		if (_index.ContainsKey(text))
		{
			return GetRandomID();
		}
		return text;
	}

	public static GameObject Get(string ID)
	{
		if (string.IsNullOrEmpty(ID))
		{
			return null;
		}
		if (_index.ContainsKey(ID) && _index[ID] != null)
		{
			return _index[ID];
		}
		ObjectID[] array = Resources.FindObjectsOfTypeAll<ObjectID>();
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].gameObject.scene.name != null)
			{
				if (string.IsNullOrEmpty(array[i].ID))
				{
					UnityEngine.Debug.LogError(string.Concat("Missing Unique ID: ", array[i], ". Looking for ID: ", ID));
				}
				else if (!_index.ContainsKey(array[i].ID))
				{
					_index.Add(array[i].ID, array[i].gameObject);
				}
			}
		}
		if (_index.ContainsKey(ID))
		{
			return _index[ID];
		}
		UnityEngine.Debug.LogError("Could not find object with ID: " + ID);
		return null;
	}

	public static T Get<T>(string ID) where T : Component
	{
		GameObject gameObject = Get(ID);
		if (gameObject != null)
		{
			return gameObject.GetComponent<T>();
		}
		return null;
	}

	public void SetID(string ID)
	{
		_index.Remove(ID);
		this.ID = ID;
		_index.Add(ID, base.gameObject);
	}

	public string GetID()
	{
		return ID;
	}
}
public abstract class Singleton<T> : MonoBehaviour where T : Singleton<T>
{
	public static T Instance { get; private set; }

	protected virtual void Awake()
	{
		if (Instance == null && Instance != this)
		{
			Instance = (T)this;
		}
		else
		{
			UnityEngine.Object.Destroy(this);
		}
	}

	private void OnDestroy()
	{
		if (Instance == this)
		{
			Instance = null;
		}
	}
}
[Serializable]
public class BoolUnityEvent : UnityEvent<bool>
{
}
[Serializable]
public class FloatUnityEvent : UnityEvent<float>
{
}
[Serializable]
public class IntUnityEvent : UnityEvent<int>
{
}
[Serializable]
public class StringUnityEvent : UnityEvent<string>
{
}
public static class Utilities
{
	public class RaycastHitDistanceComparer : IComparer
	{
		private static RaycastHitDistanceComparer _comparer;

		public static RaycastHitDistanceComparer Comparer
		{
			get
			{
				if (_comparer == null)
				{
					_comparer = new RaycastHitDistanceComparer();
				}
				return _comparer;
			}
		}

		public int Compare(object x, object y)
		{
			if (((RaycastHit)x).distance > ((RaycastHit)y).distance)
			{
				return 1;
			}
			if (((RaycastHit)x).distance == ((RaycastHit)y).distance)
			{
				return 0;
			}
			return -1;
		}
	}

	public class ColliderAngleComparer : IComparer
	{
		private Vector3 position;

		private Vector3 forward;

		public ColliderAngleComparer(Vector3 position, Vector3 forward)
		{
			this.position = position;
			this.forward = forward;
		}

		public int Compare(object x, object y)
		{
			Vector3 to = ((Collider)x).bounds.center - position;
			float num = Vector3.Angle(forward, to);
			Vector3 to2 = ((Collider)y).bounds.center - position;
			float num2 = Vector3.Angle(forward, to2);
			if (num > num2)
			{
				return 1;
			}
			if (num == num2)
			{
				return 0;
			}
			return -1;
		}
	}

	public static readonly Collider[] colliderPool = new Collider[100];

	public static readonly RaycastHit[] raycastHitPool = new RaycastHit[100];

	public static Vector2 Rotate(this Vector2 v, float angle)
	{
		float num = Mathf.Sin(angle);
		float num2 = Mathf.Cos(angle);
		float x = v.x;
		float y = v.y;
		return new Vector2(num2 * x - num * y, num2 * y + num * x);
	}

	public static Vector3 RotateAroundAxis(this Vector3 v, float degrees, Vector3 axis)
	{
		return Quaternion.AngleAxis(degrees, axis) * v;
	}

	public static float GetPitch(this Vector3 v)
	{
		float x = Mathf.Sqrt(v.x * v.x + v.z * v.z);
		return 0f - Mathf.Atan2(v.y, x);
	}

	public static float GetYaw(this Vector3 v)
	{
		return Mathf.Atan2(v.x, v.z);
	}

	public static bool HasComponent<T>(this GameObject g) where T : Component
	{
		return g.GetComponent<T>() != null;
	}

	public static void SortByDist(this RaycastHit[] hitArray, int count)
	{
		Array.Sort(hitArray, 0, count, RaycastHitDistanceComparer.Comparer);
	}

	public static void SortByAngle(this Collider[] hitArray, int count, Vector3 position, Vector3 forward)
	{
		Array.Sort(hitArray, 0, count, new ColliderAngleComparer(position, forward));
	}

	public static bool HasClearPathToTarget(this Transform start, Ray ray, Transform target, float distance = float.PositiveInfinity)
	{
		int num = Physics.RaycastNonAlloc(ray, raycastHitPool, distance, References.SolidLayers);
		if (num > 0)
		{
			Array.Sort(raycastHitPool, 0, num, RaycastHitDistanceComparer.Comparer);
		}
		for (int i = 0; i < num; i++)
		{
			Transform transform = raycastHitPool[i].transform;
			if (transform == target || transform.IsChildOf(target) || target.IsChildOf(transform))
			{
				return true;
			}
			if (!transform.IsChildOf(start) && !start.IsChildOf(transform))
			{
				return false;
			}
		}
		return true;
	}

	public static void FadeOut(this AudioSource audio, float duration, float delay = 0f)
	{
		Timing.RunCoroutine(FadeOutRoutine(audio, duration, delay));
	}

	private static IEnumerator<float> FadeOutRoutine(AudioSource audio, float duration, float delay = 0f)
	{
		if (delay > 0f)
		{
			yield return Timing.WaitForSeconds(delay);
		}
		float initialVolume = audio.volume;
		float lastVolume = initialVolume;
		while (lastVolume == audio.volume && audio.volume > 0f)
		{
			audio.volume -= initialVolume * Time.deltaTime / duration;
			lastVolume = audio.volume;
			yield return float.NegativeInfinity;
		}
		audio.Stop();
		audio.volume = initialVolume;
	}

	public static void FadeIn(this AudioSource audio, float duration, float finalVolume = 1f, float delay = 0f)
	{
		Timing.RunCoroutine(FadeInRoutine(audio, duration, finalVolume, delay));
	}

	private static IEnumerator<float> FadeInRoutine(AudioSource audio, float duration, float finalVolume, float delay = 0f)
	{
		if (delay > 0f)
		{
			yield return Timing.WaitForSeconds(delay);
		}
		float lastVolume = audio.volume;
		audio.Play();
		while (lastVolume == audio.volume && audio.volume < finalVolume)
		{
			audio.volume += finalVolume * Time.deltaTime / duration;
			lastVolume = audio.volume;
			yield return float.NegativeInfinity;
		}
		audio.volume = finalVolume;
	}

	public static bool Contains(this DamageTargets target, DamageTargets comparison)
	{
		return (target & comparison) >= comparison;
	}

	public static bool IsValidTarget(this DamageTargets validTargets, ref IDamageable target)
	{
		if (target == null)
		{
			return false;
		}
		target = target.GetTarget();
		IDamageable damageable = target;
		if (damageable != null)
		{
			if (damageable is Player)
			{
				return validTargets.Contains(DamageTargets.Player);
			}
			if (damageable is Mob)
			{
				return validTargets.Contains(DamageTargets.Enemies);
			}
		}
		return validTargets.Contains(DamageTargets.Objects);
	}
}
public class ActiveHandSelector : MonoBehaviour
{
	[SerializeField]
	private Transform _leftHandAnchor;

	[SerializeField]
	private Transform _rightHandAnchor;

	[SerializeField]
	private OVRInputModule _inputModule;

	[SerializeField]
	private GameEvent[] _rightControllerButtonEvents;

	[SerializeField]
	private GameEvent[] _leftControllerButtonEvents;

	private void Start()
	{
		for (int i = 0; i < _rightControllerButtonEvents.Length; i++)
		{
			GameEvent obj = _rightControllerButtonEvents[i];
			obj.OnTrue = (System.Action)Delegate.Combine(obj.OnTrue, new System.Action(SetActiveControllerRight));
		}
		for (int j = 0; j < _leftControllerButtonEvents.Length; j++)
		{
			GameEvent obj2 = _leftControllerButtonEvents[j];
			obj2.OnTrue = (System.Action)Delegate.Combine(obj2.OnTrue, new System.Action(SetActiveControllerLeft));
		}
	}

	private void OnDestroy()
	{
		for (int i = 0; i < _rightControllerButtonEvents.Length; i++)
		{
			GameEvent obj = _rightControllerButtonEvents[i];
			obj.OnTrue = (System.Action)Delegate.Remove(obj.OnTrue, new System.Action(SetActiveControllerRight));
		}
		for (int j = 0; j < _leftControllerButtonEvents.Length; j++)
		{
			GameEvent obj2 = _leftControllerButtonEvents[j];
			obj2.OnTrue = (System.Action)Delegate.Remove(obj2.OnTrue, new System.Action(SetActiveControllerLeft));
		}
	}

	private void SetActiveControllerRight()
	{
		_inputModule.rayTransform = _rightHandAnchor;
	}

	private void SetActiveControllerLeft()
	{
		_inputModule.rayTransform = _leftHandAnchor;
	}
}
public class CharacterControllerVR : MonoBehaviour
{
	public float slopeLimit;

	public float stepOffset;

	public float skinWidth;

	public float minMoveDistance;

	public Vector3 center;

	public float radius;

	public float height;

	public LayerMask fallColliderLayerMask;

	public bool useGravity;

	private Vector3 _movement;

	private Vector3 _gravityVelocity;

	private Rigidbody _rigidbody;

	public bool isGrounded { get; private set; }

	public bool isValidPosition { get; private set; }

	private void Awake()
	{
		_rigidbody = GetComponent<Rigidbody>();
	}

	public void Move(Vector3 speed)
	{
		if (speed != Vector3.zero && isGrounded)
		{
			_rigidbody.MovePosition(base.transform.position + speed);
		}
	}

	private Vector3 GetMovement(Vector3 offset)
	{
		Vector3 normalized = offset.normalized;
		int num = Physics.CapsuleCastNonAlloc(base.transform.position + Vector3.up * (radius + stepOffset), base.transform.position + Vector3.up * (height - radius - stepOffset), radius, normalized, Utilities.raycastHitPool, offset.magnitude, fallColliderLayerMask, QueryTriggerInteraction.Ignore);
		if (num > 0)
		{
			float num2 = float.MaxValue;
			for (int i = 0; i < num; i++)
			{
				UnityEngine.Debug.Log(string.Concat(i, " ", Utilities.raycastHitPool[i].collider, " ", Utilities.raycastHitPool[i].normal, " ", Vector3.Angle(Utilities.raycastHitPool[i].normal, Vector3.up), " ", Vector3.Angle(Vector3.ProjectOnPlane(Utilities.raycastHitPool[i].normal, Vector3.up), Utilities.raycastHitPool[i].normal)));
				UnityEngine.Debug.DrawRay(base.transform.position, Utilities.raycastHitPool[i++].point - base.transform.position, new Color(i % 2, i % 3 / 2, i-- % 4 / 3), 1f);
				if (Utilities.raycastHitPool[i].point != Vector3.zero && Utilities.raycastHitPool[i].distance < num2 && Vector3.Angle(Utilities.raycastHitPool[i].normal, Vector3.up) > slopeLimit && Utilities.raycastHitPool[i].collider.GetComponentInParent<Mob>() == null)
				{
					num2 = Utilities.raycastHitPool[i].distance;
					UnityEngine.Debug.Log(offset.magnitude + " " + num2);
					if ((double)num2 < 0.01)
					{
						return Vector3.zero;
					}
				}
			}
			if (num2 == float.MaxValue)
			{
				return offset;
			}
			return normalized * (num2 - 0.01f);
		}
		return offset;
	}
}
public class Climbable : MonoBehaviour, IGrabbableObject, IGrabTrigger
{
	public Vector3 climbDirection;

	public bool useLocalDirection;

	public HandPose grabPose = HandPose.Fist;

	[UnityEngine.Tooltip("The grip's right/red axis should be aligned along the shaft of the climbable object")]
	public Transform gripPoint;

	private Transform gripPointLeft;

	public bool onlyDirectionalMovement;

	public AudioSource playOnGrab;

	[SerializeField]
	private BoxCollider _collider;

	private void OnValidate()
	{
		if (_collider == null)
		{
			_collider = GetComponentInParent<BoxCollider>();
		}
	}

	private void Awake()
	{
		gripPointLeft = UnityEngine.Object.Instantiate(gripPoint, gripPoint.position, gripPoint.rotation, gripPoint.parent);
	}

	public Transform GetGripSnapPoint(Hand hand)
	{
		if (hand.IsRightHand())
		{
			return gripPoint;
		}
		return gripPointLeft;
	}

	private void PositionGrabPoint(Hand hand)
	{
		if (hand.IsRightHand())
		{
			gripPoint.localPosition = _collider.center + Vector3.Project(base.transform.InverseTransformPoint(hand.gripPoint.position) - _collider.center, useLocalDirection ? climbDirection : base.transform.InverseTransformDirection(climbDirection));
		}
		else
		{
			gripPointLeft.localPosition = _collider.center + Vector3.Project(base.transform.InverseTransformPoint(hand.gripPoint.position) - _collider.center, useLocalDirection ? climbDirection : base.transform.InverseTransformDirection(climbDirection));
		}
	}

	public void GrabWith(Hand hand)
	{
		hand.SetGrabbing(this);
		PositionGrabPoint(hand);
		Haptics.Play(0.5f, 0.3f, 0.1f, hand);
		if (playOnGrab != null)
		{
			playOnGrab.Play();
		}
		References.TrackingSpace.MoveRelativeTo(hand.trackingTarget);
		References.PlayerFallLock.LockUsing(hand);
		References.OdinVisionLock.LockUsing(hand);
	}

	public void Release(Hand hand, bool playSound = true)
	{
		hand.StopGrabbing(this);
		References.TrackingSpace.StopTracking(hand.trackingTarget);
		References.PlayerFallLock.Unlock(hand);
		References.OdinVisionLock.Unlock(hand);
	}

	public HandPose GetGripPose()
	{
		return grabPose;
	}

	public bool HandClingsToTarget()
	{
		return true;
	}

	public bool ReleaseOnGrip()
	{
		return false;
	}

	public bool ClimbOnTarget()
	{
		return true;
	}

	public bool CanGrab()
	{
		return true;
	}
}
public class FollowTransform : MonoBehaviour
{
	public Transform target;

	private void Update()
	{
		base.transform.position = target.position;
	}
}
public class Hand : MonoBehaviour, IDamageable
{
	public const string ANIM_PARAM_NAME_FLEX = "Flex";

	public const string ANIM_PARAM_NAME_POSE = "Pose";

	public const string ANIM_PARAM_NAME_PINCH = "Pinch";

	public const string ANIM_PARAM_NAME_POINT = "Point";

	public const float INPUT_RATE_CHANGE = 20f;

	public static Hand RightHand;

	public static Hand LeftHand;

	public GameEvent gripEvent;

	public GameEvent triggerTouchEvent;

	public GameEvent triggerPressEvent;

	public GameEvent stickPressEvent;

	public Transform gripPoint;

	public Transform teleportOrigin;

	public Transform trackingTarget;

	public GameObject poke;

	public BoolVariable gripTrigger;

	public BoolVariable indexTrigger;

	public BoolVariable stickTouch;

	[SerializeField]
	private OVRInput.Controller m_controller;

	[SerializeField]
	private Animator _animator;

	[SerializeField]
	private HandPose m_defaultIdlePose;

	[SerializeField]
	private HandPose m_reachingPose;

	[SerializeField]
	private Transform[] _IKTransforms;

	[SerializeField]
	private BoxCollider _collider;

	[SerializeField]
	private BoxCollider _extendedCollider;

	[SerializeField]
	private ParticleSystem _highlightParticles;

	private int m_animParamIndexFlex = -1;

	private int m_animParamIndexPose = -1;

	private int m_animParamIndexPoint = -1;

	private bool _isPointing;

	private HashSet<ForceHandPoint> _forcePointing = new HashSet<ForceHandPoint>();

	private bool m_isGivingThumbsUp;

	private float m_pointBlend;

	private float m_thumbsUpBlend;

	private float _fistBlend;

	private List<Renderer> m_showAfterInputFocusAcquired;

	private bool m_restoreOnInputAcquired;

	private IGrabbableObject _grabbedObject;

	private Transform _clingTarget;

	private Vector3 _initialGripPosition;

	private Quaternion _initialGripRotation;

	private Vector3[] _IKPositions;

	private Quaternion[] _IKRotations;

	private Vector3 _colliderSize;

	private Vector3 _extendedColliderSize;

	private float _gripRadius = 0.04f;

	private float _normalGripRadius = 0.04f;

	private float _extendedGripRadius = 0.09f;

	private IGrabTrigger _gripTarget;

	private Transform _gripTargetTransform;

	private IGrabbableObject _lastGrabbedObject;

	private void Start()
	{
		m_showAfterInputFocusAcquired = new List<Renderer>();
		if (IsRightHand())
		{
			RightHand = this;
		}
		else
		{
			LeftHand = this;
		}
		m_animParamIndexFlex = Animator.StringToHash("Flex");
		m_animParamIndexPose = Animator.StringToHash("Pose");
		m_animParamIndexPoint = Animator.StringToHash("Point");
		OVRManager.InputFocusAcquired += OnInputFocusAcquired;
		OVRManager.InputFocusLost += OnInputFocusLost;
		References.PlayerInterfaceLock.OnLock += Disable;
		References.PlayerInterfaceLock.OnUnlock += Enable;
		GameEvent odinViewTransition = References.OdinViewTransition;
		odinViewTransition.OnTrue = (System.Action)Delegate.Combine(odinViewTransition.OnTrue, new System.Action(Disable));
		GameEvent odinViewTransition2 = References.OdinViewTransition;
		odinViewTransition2.OnFalse = (System.Action)Delegate.Combine(odinViewTransition2.OnFalse, new System.Action(Enable));
		_IKPositions = new Vector3[_IKTransforms.Length];
		_IKRotations = new Quaternion[_IKTransforms.Length];
		for (int i = 0; i < _IKTransforms.Length; i++)
		{
			_IKPositions[i] = _IKTransforms[i].localPosition;
			_IKRotations[i] = _IKTransforms[i].localRotation;
		}
		_initialGripPosition = gripPoint.localPosition;
		_initialGripRotation = gripPoint.localRotation;
		_colliderSize = new Vector3(_collider.size.x / 2f, _collider.size.y / 2f, _collider.size.z / 2f);
		_extendedColliderSize = new Vector3(_extendedCollider.size.x / 2f, _extendedCollider.size.y / 2f, _extendedCollider.size.z / 2f);
		base.enabled = false;
		base.enabled = true;
	}

	private void OnDestroy()
	{
		OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
		OVRManager.InputFocusLost -= OnInputFocusLost;
		References.PlayerInterfaceLock.OnLock -= Disable;
		References.PlayerInterfaceLock.OnUnlock -= Enable;
		GameEvent odinViewTransition = References.OdinViewTransition;
		odinViewTransition.OnTrue = (System.Action)Delegate.Remove(odinViewTransition.OnTrue, new System.Action(Disable));
		GameEvent odinViewTransition2 = References.OdinViewTransition;
		odinViewTransition2.OnFalse = (System.Action)Delegate.Remove(odinViewTransition2.OnFalse, new System.Action(Enable));
	}

	private void Enable()
	{
		base.enabled = true;
	}

	private void Disable()
	{
		base.enabled = false;
	}

	private void Update()
	{
		if (!VRSystem.IsPaused)
		{
			UpdateCapTouchStates();
			m_pointBlend = InputValueRateChange(_isPointing, m_pointBlend);
			m_thumbsUpBlend = InputValueRateChange(m_isGivingThumbsUp, m_thumbsUpBlend);
			UpdateAnimStates();
			UpdatePosition();
			UpdateGripTarget();
		}
	}

	private void OnEnable()
	{
		GameEvent gameEvent = gripEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Combine(gameEvent.OnTrue, new System.Action(OnGrip));
		GameEvent gameEvent2 = gripEvent;
		gameEvent2.OnFalse = (System.Action)Delegate.Combine(gameEvent2.OnFalse, new System.Action(OnUngrip));
		GameEvent onTeleported = References.OnTeleported;
		onTeleported.OnTrue = (System.Action)Delegate.Combine(onTeleported.OnTrue, new System.Action(Teleported));
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnRaise = (Action<bool>)Delegate.Combine(comfortModeChanged.OnRaise, new Action<bool>(SetComfortMode));
	}

	private void OnDisable()
	{
		GameEvent gameEvent = gripEvent;
		gameEvent.OnTrue = (System.Action)Delegate.Remove(gameEvent.OnTrue, new System.Action(OnGrip));
		GameEvent gameEvent2 = gripEvent;
		gameEvent2.OnFalse = (System.Action)Delegate.Remove(gameEvent2.OnFalse, new System.Action(OnUngrip));
		GameEvent onTeleported = References.OnTeleported;
		onTeleported.OnTrue = (System.Action)Delegate.Remove(onTeleported.OnTrue, new System.Action(Teleported));
		GameEvent comfortModeChanged = References.ComfortModeChanged;
		comfortModeChanged.OnRaise = (Action<bool>)Delegate.Remove(comfortModeChanged.OnRaise, new Action<bool>(SetComfortMode));
	}

	private void OnGrip()
	{
		if (!MenuManager.IsInMenu)
		{
			if (_grabbedObject != null && _grabbedObject.ReleaseOnGrip())
			{
				_grabbedObject.Release(this);
			}
			else
			{
				FindNearestGrabbable()?.GrabWith(this);
			}
		}
	}

	private void OnUngrip()
	{
		if (_grabbedObject != null && !_grabbedObject.ReleaseOnGrip())
		{
			_grabbedObject.Release(this);
		}
	}

	public void SetGrabbing(IGrabbableObject target)
	{
		if (target == null)
		{
			StopGrabbing();
			return;
		}
		_grabbedObject = target;
		_clingTarget = _grabbedObject.GetGripSnapPoint(this);
	}

	public void StopGrabbing(IGrabbableObject target = null)
	{
		if (target == null || target == _grabbedObject)
		{
			_grabbedObject = null;
			gripPoint.localPosition = _initialGripPosition;
			gripPoint.localRotation = _initialGripRotation;
		}
	}

	private IGrabTrigger FindNearestGrabbable(bool checkCling = false)
	{
		int num = ((Settings.Current.comfortMode != 0) ? Physics.OverlapBoxNonAlloc(_extendedCollider.transform.TransformPoint(_extendedCollider.center), _extendedColliderSize, Utilities.colliderPool, _extendedCollider.transform.rotation, -1, QueryTriggerInteraction.Collide) : Physics.OverlapBoxNonAlloc(_collider.transform.TransformPoint(_collider.center), _colliderSize, Utilities.colliderPool, _collider.transform.rotation, -1, QueryTriggerInteraction.Collide));
		float num2 = float.PositiveInfinity;
		IGrabTrigger result = null;
		for (int i = 0; i < num; i++)
		{
			IGrabTrigger componentInParent = Utilities.colliderPool[i].GetComponentInParent<IGrabTrigger>();
			if (componentInParent != null && componentInParent.CanGrab())
			{
				float sqrMagnitude = (gripPoint.position - componentInParent.GetGripSnapPoint(this).position).sqrMagnitude;
				if (sqrMagnitude < num2 && (!checkCling || !(componentInParent is IGrabbableObject) || !((IGrabbableObject)componentInParent).HandClingsToTarget() || sqrMagnitude <= _gripRadius))
				{
					result = componentInParent;
					num2 = sqrMagnitude;
				}
			}
		}
		return result;
	}

	public void UpdatePosition(bool checkGrip = true)
	{
		if (_grabbedObject != null && _grabbedObject.HandClingsToTarget())
		{
			if (checkGrip && (_clingTarget.position - GetGripPositionFromTrackingTarget()).sqrMagnitude > _gripRadius)
			{
				OnUngrip();
				base.transform.position = trackingTarget.position;
				base.transform.rotation = trackingTarget.rotation;
			}
			else if (_grabbedObject.ClimbOnTarget())
			{
				base.transform.rotation = _clingTarget.rotation;
				gripPoint.position = _clingTarget.position;
				Vector3 forward = Vector3.ProjectOnPlane(trackingTarget.forward, _clingTarget.right);
				Vector3 upwards = ((Vector3.Angle(_clingTarget.right, trackingTarget.up) > 90f) ? (-_clingTarget.right) : _clingTarget.right);
				gripPoint.rotation = Quaternion.LookRotation(forward, upwards);
			}
			else
			{
				base.transform.position = trackingTarget.position;
				base.transform.rotation = trackingTarget.rotation;
				gripPoint.position = _clingTarget.position;
				Vector3 forward2 = Vector3.ProjectOnPlane(trackingTarget.forward, _clingTarget.up);
				Vector3 upwards2 = ((Vector3.Angle(_clingTarget.up, trackingTarget.up) > 90f) ? (-_clingTarget.up) : _clingTarget.up);
				gripPoint.rotation = Quaternion.LookRotation(forward2, upwards2);
			}
		}
		else
		{
			base.transform.position = trackingTarget.position;
			base.transform.rotation = trackingTarget.rotation;
		}
	}

	private void UpdateCapTouchStates()
	{
		m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);
	}

	private float InputValueRateChange(bool isDown, float value)
	{
		float num = Time.unscaledDeltaTime * 20f;
		float num2 = (isDown ? 1f : (-1f));
		return Mathf.Clamp01(value + num * num2);
	}

	private void UpdateAnimStates()
	{
		HandPose value = m_defaultIdlePose;
		bool flag;
		if (_grabbedObject != null)
		{
			value = _grabbedObject.GetGripPose();
			_animator.SetFloat(m_animParamIndexPoint, 0f);
			flag = false;
		}
		else if (_gripTarget != null)
		{
			value = m_reachingPose;
			_animator.SetFloat(m_animParamIndexPoint, 0f);
			flag = false;
		}
		else
		{
			_animator.SetFloat(m_animParamIndexPoint, m_pointBlend);
			flag = ((bool)gripTrigger && !indexTrigger) || Inventory.IsOpen || _forcePointing.Count > 0;
		}
		if (_isPointing != flag)
		{
			poke.SetActive(flag);
			_isPointing = flag;
		}
		_animator.SetInteger(m_animParamIndexPose, (int)value);
		float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
		if (num > _fistBlend)
		{
			_fistBlend = Mathf.Clamp(_fistBlend + Time.unscaledDeltaTime * 20f, 0f, num);
		}
		else if (num < _fistBlend)
		{
			_fistBlend = Mathf.Clamp(_fistBlend - Time.unscaledDeltaTime * 20f, num, 1f);
		}
		_animator.SetFloat(m_animParamIndexFlex, Mathf.Min(1f - m_pointBlend, _fistBlend));
	}

	private void UpdateGripTarget()
	{
		if (MenuManager.IsInMenu)
		{
			_highlightParticles.gameObject.SetActive(value: false);
			return;
		}
		if (_grabbedObject != null)
		{
			_gripTarget = null;
			_highlightParticles.gameObject.SetActive(value: false);
			return;
		}
		_gripTarget = FindNearestGrabbable(checkCling: true);
		if (_gripTarget != null && _gripTarget is InventorySlotBelt)
		{
			_gripTarget = ((InventorySlotBelt)_gripTarget).ItemInSlot();
		}
		if (Settings.Current.comfortMode == ComfortMode.Sit)
		{
			if (_gripTarget == null || LeftHand._grabbedObject == _gripTarget || RightHand._grabbedObject == _gripTarget || _gripTarget is OdinQuip)
			{
				_highlightParticles.gameObject.SetActive(value: false);
				return;
			}
			_gripTargetTransform = _gripTarget.GetGripSnapPoint(this);
			_highlightParticles.transform.SetPositionAndRotation(((Settings.Current.comfortMode == ComfortMode.Sit) ? _extendedCollider : _collider).ClosestPoint(_gripTargetTransform.position), _gripTargetTransform.rotation);
			_highlightParticles.gameObject.SetActive(value: true);
		}
	}

	public void RemoveObjectFromHand(bool ignoreEquipment)
	{
		IGrabbableObject grabbedObject = _grabbedObject;
		if (grabbedObject != null && (!ignoreEquipment || !grabbedObject.ReleaseOnGrip()))
		{
			grabbedObject.Release(Player.Instance.leftHand, playSound: false);
			if (grabbedObject.ReleaseOnGrip())
			{
				_lastGrabbedObject = grabbedObject;
			}
		}
	}

	public void ReplaceObjectInHand()
	{
		if (_lastGrabbedObject != null)
		{
			_lastGrabbedObject.GrabWith(this);
			_lastGrabbedObject = null;
		}
	}

	public void ForcePointing(ForceHandPoint source)
	{
		_forcePointing.Add(source);
	}

	public void StopForcePointing(ForceHandPoint source)
	{
		_forcePointing.Remove(source);
	}

	private void OnInputFocusLost()
	{
		if (!base.gameObject.activeInHierarchy)
		{
			return;
		}
		m_showAfterInputFocusAcquired.Clear();
		Renderer[] componentsInChildren = _animator.GetComponentsInChildren<Renderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (componentsInChildren[i].enabled)
			{
				componentsInChildren[i].enabled = false;
				m_showAfterInputFocusAcquired.Add(componentsInChildren[i]);
			}
		}
		m_restoreOnInputAcquired = true;
	}

	private void OnInputFocusAcquired()
	{
		if (!m_restoreOnInputAcquired)
		{
			return;
		}
		for (int i = 0; i < m_showAfterInputFocusAcquired.Count; i++)
		{
			if ((bool)m_showAfterInputFocusAcquired[i])
			{
				m_showAfterInputFocusAcquired[i].enabled = true;
			}
		}
		m_showAfterInputFocusAcquired.Clear();
		m_restoreOnInputAcquired = false;
	}

	private void SetComfortMode(bool sit)
	{
		_gripRadius = (sit ? _extendedGripRadius : _normalGripRadius);
	}

	public bool IsRightHand()
	{
		return m_controller == OVRInput.Controller.RTouch;
	}

	public Vector3 GetGripPosition()
	{
		return base.transform.TransformPoint(_initialGripPosition);
	}

	public Vector3 GetGripPositionFromTrackingTarget()
	{
		return trackingTarget.TransformPoint(_initialGripPosition);
	}

	public IGrabbableObject GetGrabbedObject()
	{
		return _grabbedObject;
	}

	private void Teleported()
	{
		if (_grabbedObject != null && _grabbedObject.HandClingsToTarget())
		{
			OnUngrip();
		}
	}

	public IDamageable GetTarget()
	{
		return Player.Instance;
	}

	public void ApplyDamage(int amount, string source, DamageType type = DamageType.None)
	{
		Player.Instance.ApplyDamage(amount, source, type);
	}

	public bool IsDestroyed()
	{
		return Player.Instance.IsDestroyed();
	}
}
public class HandPoke : MonoBehaviour
{
	public Hand hand;
}
public class Haptics : MonoBehaviour
{
	public class Vibration : Poolable<Vibration>
	{
		public VibrationProperties properties;

		public bool rightHand;

		public bool manualCutoff;

		public float lastUpdated;

		public void Stop()
		{
			_vibrations.Remove(this);
			Poolable<Vibration>.Return(this);
		}

		public IEnumerator<float> QueueRemove()
		{
			yield return float.NegativeInfinity;
			if (_vibrations.Remove(this))
			{
				Poolable<Vibration>.Return(this);
			}
		}

		public void SetAmplitude(float amplitude)
		{
			properties.amplitude = amplitude;
			lastUpdated = Time.realtimeSinceStartup;
		}

		public void SetFrequency(float frequency)
		{
			properties.frequency = frequency;
			lastUpdated = Time.realtimeSinceStartup;
		}
	}

	private static Haptics Instance;

	private static readonly HashSet<Vibration> _vibrations = new HashSet<Vibration>();

	private void Awake()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		else
		{
			UnityEngine.Object.Destroy(this);
		}
	}

	private void OnDestroy()
	{
		if (Instance == this)
		{
			Instance = null;
		}
	}

	private void Update()
	{
		if (VRSystem.IsPaused || MenuManager.IsInMenu)
		{
			OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.RTouch);
			OVRInput.SetControllerVibration(0f, 0f, OVRInput.Controller.LTouch);
			return;
		}
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		foreach (Vibration vibration in _vibrations)
		{
			if ((!vibration.manualCutoff && vibration.properties.time <= Time.realtimeSinceStartup) || (vibration.manualCutoff && vibration.lastUpdated <= Time.realtimeSinceStartup - 1f))
			{
				Timing.RunCoroutine(vibration.QueueRemove());
			}
			else if (vibration.rightHand)
			{
				num = 1f - (1f - num) * (1f - vibration.properties.frequency);
				num2 = 1f - (1f - num2) * (1f - vibration.properties.amplitude);
			}
			else
			{
				num3 = 1f - (1f - num3) * (1f - vibration.properties.frequency);
				num4 = 1f - (1f - num4) * (1f - vibration.properties.amplitude);
			}
		}
		OVRInput.SetControllerVibration(num, num2, OVRInput.Controller.RTouch);
		OVRInput.SetControllerVibration(num3, num4, OVRInput.Controller.LTouch);
	}

	public static Vibration Play(VibrationProperties properties, Hand hand)
	{
		if (hand == null)
		{
			return null;
		}
		return Play(properties.frequency, properties.amplitude, properties.time, hand.IsRightHand());
	}

	public static Vibration Play(VibrationProperties properties, bool rightHand)
	{
		return Play(properties.frequency, properties.amplitude, properties.time, rightHand);
	}

	public static Vibration Play(float frequency, float amplitude, float duration, Hand hand)
	{
		if (hand == null)
		{
			return null;
		}
		return Play(frequency, amplitude, duration, hand.IsRightHand());
	}

	public static Vibration Play(float frequency, float amplitude, float duration, bool rightHand)
	{
		Vibration vibration = Poolable<Vibration>.Get();
		vibration.properties.frequency = frequency;
		vibration.properties.amplitude = amplitude;
		vibration.lastUpdated = Time.realtimeSinceStartup;
		if (duration == 0f)
		{
			vibration.properties.time = 0f;
			vibration.manualCutoff = true;
		}
		else
		{
			vibration.properties.time = Time.realtimeSinceStartup + duration;
			vibration.manualCutoff = false;
		}
		vibration.rightHand = rightHand;
		_vibrations.Add(vibration);
		return vibration;
	}

	public static void Stop(Vibration vibration)
	{
		_vibrations.Remove(vibration);
	}
}
[Serializable]
public struct VibrationProperties
{
	public float frequency;

	public float amplitude;

	public float time;

	public VibrationProperties(float frequency, float amplitude, float time)
	{
		this.frequency = frequency;
		this.amplitude = amplitude;
		this.time = time;
	}
}
public class HeadCollision : MonoBehaviour, IDamageable
{
	public CameraColorOverlay overlay;

	public LayerMask playerCollisionLayers;

	public Collider[] ignoreColliders;

	[SerializeField]
	private Collider _collider;

	private readonly Queue<RelativeLocation> _lastValidLocations = new Queue<RelativeLocation>(10);

	private readonly HashSet<Collider> _currentColliders = new HashSet<Collider>();

	private readonly List<Collider> _toRemove = new List<Collider>();

	public bool IsInWall { get; private set; }

	public RelativeLocation ReturnLocation { get; private set; }

	private void Start()
	{
		Vector3 headPosition = Player.Instance.GetHeadPosition();
		Vector3 forward = base.transform.forward;
		for (int i = 0; i < 10; i++)
		{
			_lastValidLocations.Enqueue(new RelativeLocation(null, headPosition, forward));
		}
		for (int j = 0; j < ignoreColliders.Length; j++)
		{
			Physics.IgnoreCollision(_collider, ignoreColliders[j]);
		}
	}

	private void Update()
	{
		if (MenuManager.IsInMenu || OdinView.IsViewingOrTransitioning())
		{
			return;
		}
		if (_currentColliders.Count > 0)
		{
			ReturnLocation = GetRecentValidLocation();
			foreach (Collider currentCollider in _currentColliders)
			{
				if (currentCollider == null || !currentCollider.enabled || !currentCollider.gameObject.activeInHierarchy || !Physics.ComputePenetration(_collider, base.transform.position, base.transform.rotation, currentCollider, currentCollider.transform.position, currentCollider.transform.rotation, out var _, out var _))
				{
					_toRemove.Add(currentCollider);
				}
			}
			for (int i = 0; i < _toRemove.Count; i++)
			{
				_currentColliders.Remove(_toRemove[i]);
			}
			_toRemove.Clear();
		}
		if (IsInWall && _currentColliders.Count == 0)
		{
			ReturnLocation = GetRecentValidLocation();
			Vector3 vector = ReturnLocation.GetWorldPos() + Vector3.up;
			if (Physics.Raycast(vector, base.transform.position - vector, out var hitInfo, Vector3.Distance(vector, base.transform.position), playerCollisionLayers, QueryTriggerInteraction.Ignore) && !hitInfo.transform.IsChildOf(Singleton<VRSystem>.Instance.transform))
			{
				return;
			}
			Singleton<VRSystem>.Instance.SetTimeScale(1f);
			IsInWall = false;
			overlay.RemoveColorOverlay();
			References.PlayerInsideWall.RaiseFalse();
			Player.Instance.SetCollidersActive(active: true);
		}
		if (!IsInWall)
		{
			_lastValidLocations.Enqueue(_lastValidLocations.Dequeue().Set((Player.Instance.splineController != null) ? Player.Instance.splineController.transform : Player.Instance.Surface, Player.Instance.GetHeadPosition(), base.transform.forward));
		}
	}

	public void OnTriggerEnter(Collider other)
	{
		if (!other.isTrigger && !(other.GetComponentInParent<VRSystem>() != null) && !(other.GetComponentInParent<Mob>() != null) && _currentColliders.Add(other) && _currentColliders.Count == 1)
		{
			overlay.enabled = true;
			overlay.AddColorOverlay();
			IsInWall = true;
			References.PlayerInsideWall.RaiseTrue();
			Player.Instance.SetCollidersActive(active: false);
		}
	}

	private void OnTriggerStay(Collider other)
	{
		if (!other.isTrigger && !(other.GetComponentInParent<VRSystem>() != null) && !(other.GetComponentInParent<Mob>() != null) && _currentColliders.Add(other) && _currentColliders.Count == 1)
		{
			overlay.enabled = true;
			overlay.AddColorOverlay();
			IsInWall = true;
			References.PlayerInsideWall.RaiseTrue();
			Player.Instance.SetCollidersActive(active: false);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (!VRSystem.IsPaused && _currentColliders.Contains(other))
		{
			_currentColliders.Remove(other);
		}
	}

	public void SetValidLocation()
	{
		if (_lastValidLocations.Count != 0 && !MenuManager.IsInMenu && !VRSystem.IsPaused && !OdinView.IsViewingOrTransitioning())
		{
			Vector3 headPosition = Player.Instance.GetHeadPosition();
			Vector3 forward = base.transform.forward;
			for (int i = 0; i < 10; i++)
			{
				_lastValidLocations.Enqueue(_lastValidLocations.Dequeue().Set((Player.Instance.splineController != null) ? Player.Instance.splineController.transform : Player.Instance.Surface, headPosition, forward));
			}
		}
	}

	public RelativeLocation GetRecentValidLocation()
	{
		return _lastValidLocations.Peek();
	}

	public IDamageable GetTarget()
	{
		return Player.Instance;
	}

	public void ApplyDamage(int amount, string source, DamageType type = DamageType.None)
	{
		Player.Instance.ApplyDamage(amount, source, type);
	}

	public bool IsDestroyed()
	{
		return Player.Instance.IsDestroyed();
	}
}
public class HingeHandle : MonoBehaviour, IGrabbableObject, IGrabTrigger
{
	public HingeJoint hingeJoint;

	public FixedJoint fixedJoint;

	public HandPose grabPose = HandPose.Fist;

	public Transform gripSnapPoint;

	public float hapticFrequency = 0.8f;

	public float hapticAmplitude = 0.1f;

	public float grabbedMass = 100f;

	public float grabbedAngularDrag = 100f;

	public float releasedMass = 1f;

	public float releasedAngularDrag = 1f;

	public AudioSource playOnMove;

	public AudioSource playOnMoveLocked;

	public bool isLocked;

	protected Hand _hand;

	protected Rigidbody _rigidbody;

	protected Vector3 _lastHapticPosition;

	protected float _lastHapticTime;

	protected bool _hasPlayedAudio;

	protected Vector3 _lastHandPosition;

	private CoroutineHandle _handle;

	public virtual void OnValidate()
	{
		if (hingeJoint == null)
		{
			hingeJoint = GetComponentInParent<HingeJoint>();
		}
		if (fixedJoint == null)
		{
			fixedJoint = GetComponentInChildren<FixedJoint>();
		}
	}

	public virtual void Awake()
	{
		_rigidbody = fixedJoint.GetComponent<Rigidbody>();
	}

	private void OnEnable()
	{
		_handle = Timing.RunCoroutineSingleton(OnFixedUpdate(), _handle, Segment.FixedUpdate, SingletonBehavior.AbortAndUnpause);
	}

	private void OnDisable()
	{
		Timing.KillCoroutines(_handle);
	}

	protected virtual void Update()
	{
		if (_hand != null)
		{
			_lastHandPosition = hingeJoint.transform.InverseTransformPoint(_hand.GetGripPosition());
			if (Time.time - _lastHapticTime > 0.05f && (_lastHandPosition - _lastHapticPosition).sqrMagnitude > 0.0001f)
			{
				_lastHapticTime = Time.time;
				_lastHapticPosition = _lastHandPosition;
				Haptics.Play(hapticFrequency, hapticAmplitude, 0.05f, _hand);
				if (!isLocked && playOnMove != null && !_hasPlayedAudio)
				{
					playOnMove.Play();
					_hasPlayedAudio = true;
				}
				else if (isLocked && playOnMoveLocked != null && !_hasPlayedAudio)
				{
					playOnMoveLocked.Play();
					_hasPlayedAudio = true;
				}
			}
		}
		else
		{
			base.enabled = false;
		}
	}

	private IEnumerator<float> OnFixedUpdate()
	{
		while (!(_hand == null))
		{
			if (!isLocked)
			{
				_rigidbody.MovePosition(_hand.GetGripPosition());
			}
			yield return float.NegativeInfinity;
		}
		OnReleased();
	}

	public virtual void GrabWith(Hand hand)
	{
		if (_hand != null && _hand != hand)
		{
			_hand.StopGrabbing(this);
		}
		else
		{
			_rigidbody.mass = grabbedMass;
			_rigidbody.angularDrag = grabbedAngularDrag;
		}
		_hand = hand;
		_hand.SetGrabbing(this);
		Haptics.Play(0.5f, 0.3f, 0.1f, _hand);
		_lastHapticPosition = _hand.GetGripPosition();
		_lastHapticTime = Time.time;
		base.enabled = true;
	}

	public void Release(Hand hand, bool playSound = true)
	{
		hand.StopGrabbing(this);
		OnReleased();
		_hand = null;
		_hasPlayedAudio = false;
	}

	public void Lock(bool setLocked = true)
	{
		isLocked = setLocked;
		hingeJoint.GetComponent<Rigidbody>().isKinematic = isLocked;
	}

	public virtual void OnReleased()
	{
		if (_rigidbody != null)
		{
			_rigidbody.mass = releasedMass;
			_rigidbody.angularDrag = releasedAngularDrag;
		}
		base.enabled = false;
	}

	public Transform GetGripSnapPoint(Hand hand)
	{
		return gripSnapPoint;
	}

	public HandPose GetGripPose()
	{
		return grabPose;
	}

	public bool HandClingsToTarget()
	{
		return true;
	}

	public bool ReleaseOnGrip()
	{
		return false;
	}

	public bool ClimbOnTarget()
	{
		return false;
	}

	public bool CanGrab()
	{
		return !isLocked;
	}
}
public class HingeMonitor : MonoBehaviour
{
	public HingeJoint hingeJoint;

	public FloatUnityEvent onValueChanged;

	public FloatUnityEvent onNormalizedValueChanged;

	private float _lastVal;

	private void OnValidate()
	{
		if (hingeJoint == null)
		{
			hingeJoint = GetComponentInParent<HingeJoint>();
		}
	}

	private void Update()
	{
		if (!Mathf.Approximately(hingeJoint.angle, _lastVal))
		{
			_lastVal = hingeJoint.angle;
			onValueChanged.Invoke(_lastVal % 360f);
			onNormalizedValueChanged.Invoke(Mathf.Clamp((_lastVal % 360f - hingeJoint.limits.min) / (hingeJoint.limits.max - hingeJoint.limits.min), 0f, 1f));
		}
	}
}
public interface IGrabbableObject : IGrabTrigger
{
	void Release(Hand hand, bool playSound = true);

	HandPose GetGripPose();

	bool HandClingsToTarget();

	bool ReleaseOnGrip();

	bool ClimbOnTarget();
}
public interface IGrabTrigger
{
	void GrabWith(Hand hand);

	Transform GetGripSnapPoint(Hand hand);

	bool CanGrab();
}
public class LocomotionManager : MonoBehaviour
{
	public FloatVariable xAxis;

	public FloatVariable yAxis;

	public float minValueForTrue = 0.25f;

	public Transform playAreaAlias;

	public Transform headsetAlias;

	public Player player;

	private void Update()
	{
		Vector3 vector = new Vector3((Mathf.Abs(xAxis) > minValueForTrue) ? ((float)xAxis) : 0f, 0f, (Mathf.Abs(yAxis) > minValueForTrue) ? ((float)yAxis) : 0f).RotateAroundAxis(headsetAlias.eulerAngles.y, Vector3.up);
		if (vector != Vector3.zero)
		{
			player.InputMovement(vector.normalized * (vector.magnitude - minValueForTrue) / (1f - minValueForTrue));
		}
	}
}
public class MixedRealityCapture : MonoBehaviour
{
	private bool inited;

	public Camera defaultExternalCamera;

	private void Start()
	{
		if (!defaultExternalCamera)
		{
			UnityEngine.Debug.LogWarning("defaultExternalCamera undefined");
		}
	}

	private void Initialize()
	{
		if (!inited && OVRPlugin.Media.GetInitialized())
		{
			OVRPlugin.ResetDefaultExternalCamera();
			UnityEngine.Debug.LogFormat("GetExternalCameraCount before adding manual external camera {0}", OVRPlugin.GetExternalCameraCount());
			UpdateDefaultExternalCamera();
			UnityEngine.Debug.LogFormat("GetExternalCameraCount after adding manual external camera {0}", OVRPlugin.GetExternalCameraCount());
			OVRPlugin.GetMixedRealityCameraInfo(0, out var _, out var _);
			inited = true;
		}
	}

	private void UpdateDefaultExternalCamera()
	{
		OVRPlugin.CameraIntrinsics cameraIntrinsics = default(OVRPlugin.CameraIntrinsics);
		OVRPlugin.CameraExtrinsics cameraExtrinsics = default(OVRPlugin.CameraExtrinsics);
		cameraIntrinsics.IsValid = OVRPlugin.Bool.True;
		cameraIntrinsics.LastChangedTimeSeconds = Time.time;
		float num = defaultExternalCamera.fieldOfView * ((float)Math.PI / 180f);
		float num2 = Mathf.Atan(Mathf.Tan(num * 0.5f) * 1.7777778f) * 2f;
		OVRPlugin.Fovf fOVPort = default(OVRPlugin.Fovf);
		fOVPort.UpTan = (fOVPort.DownTan = Mathf.Tan(num * 0.5f));
		fOVPort.LeftTan = (fOVPort.RightTan = Mathf.Tan(num2 * 0.5f));
		cameraIntrinsics.FOVPort = fOVPort;
		cameraIntrinsics.VirtualNearPlaneDistanceMeters = defaultExternalCamera.nearClipPlane;
		cameraIntrinsics.VirtualFarPlaneDistanceMeters = defaultExternalCamera.farClipPlane;
		cameraIntrinsics.ImageSensorPixelResolution.w = 1920;
		cameraIntrinsics.ImageSensorPixelResolution.h = 1080;
		cameraExtrinsics.IsValid = OVRPlugin.Bool.True;
		cameraExtrinsics.LastChangedTimeSeconds = Time.time;
		cameraExtrinsics.CameraStatusData = OVRPlugin.CameraStatus.CameraStatus_Calibrated;
		cameraExtrinsics.AttachedToNode = OVRPlugin.Node.None;
		OVRCameraRig componentInParent = Camera.main.GetComponentInParent<OVRCameraRig>();
		if ((bool)componentInParent)
		{
			OVRPose oVRPose = componentInParent.trackingSpace.ToOVRPose();
			OVRPose oVRPose2 = defaultExternalCamera.transform.ToOVRPose();
			OVRPose oVRPose3 = oVRPose.Inverse() * oVRPose2;
			cameraExtrinsics.RelativePose = (OVRPlugin.GetTrackingTransformRelativePose(OVRPlugin.TrackingOrigin.Stage).ToOVRPose().Inverse() * oVRPose3).ToPosef();
		}
		else
		{
			cameraExtrinsics.RelativePose = OVRPlugin.Posef.identity;
		}
		if (!OVRPlugin.SetDefaultExternalCamera("UnityExternalCamera", ref cameraIntrinsics, ref cameraExtrinsics))
		{
			UnityEngine.Debug.LogError("SetDefaultExternalCamera() failed");
		}
	}

	private void Update()
	{
		if (!inited)
		{
			Initialize();
		}
		else if ((bool)defaultExternalCamera && OVRPlugin.Media.GetInitialized())
		{
			UpdateDefaultExternalCamera();
			OVRPlugin.OverrideExternalCameraFov(0, useOverriddenFov: false, default(OVRPlugin.Fovf));
			OVRPlugin.OverrideExternalCameraStaticPose(0, useOverriddenPose: false, OVRPlugin.Posef.identity);
		}
	}
}
public class OculusPlatformInitializer : MonoBehaviour
{
	public bool performEntitlementCheck;

	private void Awake()
	{
		try
		{
			Core.AsyncInitialize();
			if (performEntitlementCheck)
			{
				Entitlements.IsUserEntitledToApplication().OnComplete(EntitlementCallback);
			}
		}
		catch (UnityException exception)
		{
			UnityEngine.Debug.LogError("Platform failed to initialize due to exception.");
			UnityEngine.Debug.LogException(exception);
			UnityEngine.Application.Quit();
		}
	}

	private void EntitlementCallback(Message msg)
	{
		if (msg.IsError)
		{
			UnityEngine.Debug.LogError("You are NOT entitled to use this app.");
			UnityEngine.Application.Quit();
		}
		else
		{
			UnityEngine.Debug.Log("You are entitled to use this app.");
		}
	}
}
public class PauseInLogoScreen : MonoBehaviour
{
	private bool _hmdUnmounted;

	private bool _vrFocusLost;

	private bool _inputFocusLost;

	private bool _appPaused;

	private void Awake()
	{
		OVRManager.HMDUnmounted += HMDUnmounted;
		OVRManager.HMDMounted += HMDMounted;
		OVRManager.VrFocusLost += VrFocusLost;
		OVRManager.VrFocusAcquired += VrFocusAcquired;
		OVRManager.InputFocusLost += InputFocusLost;
		OVRManager.InputFocusAcquired += InputFocusAcquired;
	}

	private void OnDestroy()
	{
		OVRManager.HMDUnmounted -= HMDUnmounted;
		OVRManager.HMDMounted -= HMDMounted;
		OVRManager.VrFocusLost -= VrFocusLost;
		OVRManager.VrFocusAcquired -= VrFocusAcquired;
		OVRManager.InputFocusLost -= InputFocusLost;
		OVRManager.InputFocusAcquired -= InputFocusAcquired;
	}

	private void HMDUnmounted()
	{
		_hmdUnmounted = true;
		CheckPause();
	}

	private void HMDMounted()
	{
		_hmdUnmounted = false;
		CheckPause();
	}

	private void VrFocusLost()
	{
		_vrFocusLost = true;
		CheckPause();
	}

	private void VrFocusAcquired()
	{
		_vrFocusLost = false;
		CheckPause();
	}

	private void InputFocusLost()
	{
		_inputFocusLost = true;
		CheckPause();
	}

	private void InputFocusAcquired()
	{
		_inputFocusLost = false;
		CheckPause();
	}

	private void OnApplicationPause(bool pause)
	{
		_appPaused = pause;
		CheckPause();
	}

	private void CheckPause()
	{
		if (_hmdUnmounted || _vrFocusLost || _inputFocusLost || _appPaused)
		{
			PauseGame();
		}
		else
		{
			UnpauseGame();
		}
	}

	private void PauseGame()
	{
		AudioListener.pause = true;
		Time.timeScale = 0f;
	}

	private void UnpauseGame()
	{
		Time.timeScale = 1f;
		AudioListener.pause = false;
	}
}
public class PositionManager : MonoBehaviour
{
	public Segment updateSegment = Segment.LateUpdate;

	private Transform _targetTransform;

	private Vector3 _targetPosition;

	private Quaternion _targetRotation;

	private CoroutineHandle _handle;

	public void OnEnable()
	{
		if (_handle.IsValid)
		{
			Timing.ResumeCoroutines(_handle);
		}
		else
		{
			_handle = Timing.RunCoroutine(UpdateFinalPosition(), updateSegment);
		}
	}

	public void OnDisable()
	{
		Timing.PauseCoroutines(_handle);
	}

	public void SetTransform(Transform target)
	{
		_targetTransform = target;
	}

	public void SetPosition(Vector3 position)
	{
		_targetPosition = position;
	}

	public void ModifyPosition(Vector3 position)
	{
		_targetPosition += position;
	}

	public void SetRotation(Quaternion rotation)
	{
		_targetRotation = rotation;
	}

	public void ModifyRotation(Quaternion rotation)
	{
		_targetRotation = Quaternion.Euler(_targetRotation.eulerAngles + rotation.eulerAngles);
	}

	private IEnumerator<float> UpdateFinalPosition()
	{
		while (true)
		{
			if (_targetTransform != null)
			{
				base.transform.position = _targetTransform.position;
				base.transform.rotation = _targetTransform.rotation;
			}
			else
			{
				base.transform.position = _targetPosition;
				base.transform.rotation = _targetRotation;
			}
			yield return float.NegativeInfinity;
		}
	}
}
public class References : MonoBehaviour
{
	public TrackingSpace trackingSpace;

	public Transform headset;

	public Transform leftController;

	public Transform rightController;

	public Transform mouth;

	public Lock odinHintLock;

	public Lock odinVisionLock;

	public Lock playerFallLock;

	public Lock playerInterfaceLock;

	public Lock playerMoveTeleportLock;

	public Lock saveGameLock;

	public GameEvent allowTeleport;

	public GameEvent hintRequested;

	public GameEvent odinSummonRequested;

	public GameEvent odinView;

	public GameEvent odinViewRequested;

	public GameEvent odinViewTransition;

	public GameEvent onGameLoaded;

	public GameEvent onLoadNewProfile;

	public GameEvent onPlayerDamaged;

	public GameEvent onPlayerDeath;

	public GameEvent onPlayerHealed;

	public GameEvent onPlayerRespawn;

	public GameEvent onRotated;

	public GameEvent onTeleported;

	public GameEvent playerInsideWall;

	public GameEvent comfortModeChanged;

	public GameEvent handChanged;

	public GameEvent teleportHandChanged;

	public GameEvent languageChanged;

	public GameEvent difficultyChanged;

	public GameEvent onGamePaused;

	public GameEvent onMenuOpened;

	public GameEvent onCaptionsShow;

	public GameEvent combat;

	public InventoryManager inventoryManager;

	public AchievementManager achievementManager;

	public MenuManager menuManager;

	public Inventory inventory;

	public ItemType shieldItem;

	public Caption systemText;

	public Caption subtitles;

	public Caption menuSubtitles;

	public LayerMask solidLayers;

	public LayerMask hardSolidLayers;

	public Element fire;

	public Element ice;

	public GameObjectPool dummyObjectPool;

	public AudioMixer audioMixer;

	public GameObject headCollider;

	public GameObject webEffect;

	public Room[] rooms;

	public static bool IsInitialized { get; private set; }

	public static TrackingSpace TrackingSpace { get; private set; }

	public static Transform TrackingSpaceTransform { get; private set; }

	public static Transform Headset { get; private set; }

	public static Transform LeftController { get; private set; }

	public static Transform RightController { get; private set; }

	public static Transform Mouth { get; private set; }

	public static Lock OdinHintLock { get; private set; }

	public static Lock OdinVisionLock { get; private set; }

	public static Lock PlayerFallLock { get; private set; }

	public static Lock PlayerInterfaceLock { get; private set; }

	public static Lock PlayerMoveTeleportLock { get; private set; }

	public static Lock SaveGameLock { get; private set; }

	public static GameEvent AllowTeleport { get; private set; }

	public static GameEvent Combat { get; private set; }

	public static GameEvent HintRequested { get; private set; }

	public static GameEvent OdinSummonRequested { get; private set; }

	public static GameEvent OdinView { get; private set; }

	public static GameEvent OdinViewRequested { get; private set; }

	public static GameEvent OdinViewTransition { get; private set; }

	public static GameEvent OnGameLoaded { get; private set; }

	public static GameEvent OnLoadNewProfile { get; private set; }

	public static GameEvent OnPlayerDamaged { get; private set; }

	public static GameEvent OnPlayerDeath { get; private set; }

	public static GameEvent OnPlayerHealed { get; private set; }

	public static GameEvent OnPlayerRespawn { get; private set; }

	public static GameEvent OnRotated { get; private set; }

	public static GameEvent OnTeleported { get; private set; }

	public static GameEvent PlayerInsideWall { get; private set; }

	public static GameEvent ComfortModeChanged { get; private set; }

	public static GameEvent HandChanged { get; private set; }

	public static GameEvent TeleportHandChanged { get; private set; }

	public static GameEvent LanguageChanged { get; private set; }

	public static GameEvent DifficultyChanged { get; private set; }

	public static GameEvent OnGamePaused { get; private set; }

	public static GameEvent OnMenuOpened { get; private set; }

	public static GameEvent OnCaptionsShow { get; private set; }

	public static InventoryManager InventoryManager { get; private set; }

	public static AchievementManager AchievementManager { get; private set; }

	public static MenuManager MenuManager { get; private set; }

	public static Inventory Inventory { get; private set; }

	public static Wand Wand { get; set; }

	public static Shield Shield { get; set; }

	public static ItemType ShieldItem { get; private set; }

	public static Caption SystemText { get; private set; }

	public static Caption Subtitles { get; private set; }

	public static Caption MenuSubtitles { get; private set; }

	public static LayerMask SolidLayers { get; private set; }

	public static LayerMask HardSolidLayers { get; private set; }

	public static Element Fire { get; private set; }

	public static Element Ice { get; private set; }

	public static GameObjectPool DummyObjectPool { get; private set; }

	public static AudioMixer AudioMixer { get; private set; }

	public static GameObject WebEffect { get; private set; }

	public static GameObject HeadCollider { get; private set; }

	public static HeadCollision HeadColliderScript { get; private set; }

	public static Room[] Rooms { get; private set; }

	protected void Awake()
	{
		if (!IsInitialized)
		{
			odinVisionLock.UnlockAll();
			playerFallLock.UnlockAll();
			playerInterfaceLock.UnlockAll();
			playerMoveTeleportLock.UnlockAll();
			TrackingSpace = trackingSpace;
			TrackingSpaceTransform = trackingSpace.transform;
			Headset = headset;
			LeftController = leftController;
			RightController = rightController;
			Mouth = mouth;
			OdinHintLock = odinHintLock;
			OdinVisionLock = odinVisionLock;
			PlayerFallLock = playerFallLock;
			PlayerInterfaceLock = playerInterfaceLock;
			PlayerMoveTeleportLock = playerMoveTeleportLock;
			SaveGameLock = saveGameLock;
			AllowTeleport = allowTeleport;
			Combat = combat;
			HintRequested = hintRequested;
			OdinSummonRequested = odinSummonRequested;
			OdinView = odinView;
			OdinViewRequested = odinViewRequested;
			OdinViewTransition = odinViewTransition;
			OnGameLoaded = onGameLoaded;
			OnLoadNewProfile = onLoadNewProfile;
			OnPlayerDamaged = onPlayerDamaged;
			OnPlayerDeath = onPlayerDeath;
			OnPlayerHealed = onPlayerHealed;
			OnPlayerRespawn = onPlayerRespawn;
			OnRotated = onRotated;
			OnTeleported = onTeleported;
			PlayerInsideWall = playerInsideWall;
			ComfortModeChanged = comfortModeChanged;
			HandChanged = handChanged;
			TeleportHandChanged = teleportHandChanged;
			LanguageChanged = languageChanged;
			InventoryManager = inventoryManager;
			DifficultyChanged = difficultyChanged;
			OnGamePaused = onGamePaused;
			OnMenuOpened = onMenuOpened;
			OnCaptionsShow = onCaptionsShow;
			AchievementManager = achievementManager;
			MenuManager = menuManager;
			Inventory = inventory;
			SystemText = systemText;
			Subtitles = subtitles;
			MenuSubtitles = menuSubtitles;
			SolidLayers = solidLayers;
			HardSolidLayers = hardSolidLayers;
			AudioMixer = audioMixer;
			Fire = fire;
			Ice = ice;
			DummyObjectPool = dummyObjectPool;
			WebEffect = webEffect;
			HeadCollider = headCollider;
			HeadColliderScript = headCollider.GetComponent<HeadCollision>();
			Rooms = rooms;
			ShieldItem = shieldItem;
			IsInitialized = true;
		}
		UnityEngine.Object.Destroy(base.gameObject);
	}

	public static GameEvent GetGameEvent(GameEvents gameEvent)
	{
		return gameEvent switch
		{
			GameEvents.AllowTeleport => AllowTeleport, 
			GameEvents.Combat => Combat, 
			GameEvents.HintRequested => HintRequested, 
			GameEvents.OdinSummonRequested => OdinSummonRequested, 
			GameEvents.OdinView => OdinView, 
			GameEvents.OdinViewRequested => OdinViewRequested, 
			GameEvents.OdinViewTransition => OdinViewTransition, 
			GameEvents.OnGameLoaded => OnGameLoaded, 
			GameEvents.OnGamePaused => OnGamePaused, 
			GameEvents.OnPlayerDamaged => OnPlayerDamaged, 
			GameEvents.OnPlayerDeath => OnPlayerDeath, 
			GameEvents.OnPlayerHealed => OnPlayerHealed, 
			GameEvents.OnPlayerRespawn => OnPlayerRespawn, 
			GameEvents.OnRotated => OnRotated, 
			GameEvents.OnTeleported => OnTeleported, 
			GameEvents.PlayerInsideWall => PlayerInsideWall, 
			GameEvents.ComfortModeChanged => ComfortModeChanged, 
			GameEvents.DifficultyChanged => DifficultyChanged, 
			GameEvents.OnCaptionsShow => OnCaptionsShow, 
			_ => null, 
		};
	}

	public static Room GetRoom(string name)
	{
		for (int i = 0; i < Rooms.Length; i++)
		{
			if (Rooms[i].name == name)
			{
				return Rooms[i];
			}
		}
		return null;
	}
}
public class ScreenShakeCameraPostProcessor : MonoBehaviour
{
	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		ScreenShakeVR.instance.material.SetFloat("_ShakeFac", ScreenShakeVR.instance.ShakeVal);
		Graphics.Blit(source, destination, ScreenShakeVR.instance.material);
	}
}
public class ScreenShakeVR : MonoBehaviour
{
	public class ShakeEvent
	{
		public float magnitude;

		public float length;

		private float exponent;

		private float time;

		public bool finished => time >= length;

		public float currentStrength => magnitude * Mathf.Clamp01(1f - Mathf.Pow(time / length, exponent));

		public ShakeEvent(float mag, float len, float exp = 2f)
		{
			magnitude = mag;
			length = len;
			exponent = exp;
		}

		public void Update(float deltaTime)
		{
			time += deltaTime;
		}
	}

	public static ScreenShakeVR instance;

	public float shakeMagnitude = 0.1f;

	public float shakeFrequency = 20f;

	private CoroutineHandle handle;

	private ScreenShakeCameraPostProcessor[] postProcessors;

	public List<ShakeEvent> activeShakes = new List<ShakeEvent>();

	public float ShakeVal { get; private set; }

	public Material material { get; private set; }

	private void Start()
	{
		instance = this;
		if (material != null)
		{
			material.shader = Shader.Find("Hidden/ScreenShakeVR");
		}
		else
		{
			material = new Material(Shader.Find("Hidden/ScreenShakeVR"));
		}
		Camera[] array = UnityEngine.Object.FindObjectsOfType<Camera>();
		postProcessors = new ScreenShakeCameraPostProcessor[array.Length];
		for (int i = 0; i < array.Length; i++)
		{
			ScreenShakeCameraPostProcessor component = array[i].GetComponent<ScreenShakeCameraPostProcessor>();
			if (component == null)
			{
				postProcessors[i] = array[i].gameObject.AddComponent<ScreenShakeCameraPostProcessor>();
			}
			else
			{
				postProcessors[i] = component;
			}
			postProcessors[i].enabled = false;
		}
		handle = Timing.RunCoroutine(ProcessShakes());
	}

	public void Shake(float magnitude, float length, float exponent = 2f)
	{
		activeShakes.Add(new ShakeEvent(magnitude, length, exponent));
		if (activeShakes.Count != 1)
		{
			return;
		}
		for (int i = 0; i < postProcessors.Length; i++)
		{
			if (postProcessors[i] != null)
			{
				postProcessors[i].enabled = true;
			}
		}
		Timing.ResumeCoroutines(handle);
	}

	public static void TriggerShake(float magnitude, float length, float exponent = 2f)
	{
		instance.Shake(magnitude, length, exponent);
	}

	private IEnumerator<float> ProcessShakes()
	{
		while (true)
		{
			float num = 0f;
			for (int num2 = activeShakes.Count - 1; num2 >= 0; num2--)
			{
				activeShakes[num2].Update(Time.deltaTime);
				if (activeShakes[num2].finished)
				{
					activeShakes.RemoveAt(num2);
				}
				else
				{
					num += activeShakes[num2].currentStrength;
				}
			}
			if (activeShakes.Count == 0)
			{
				for (int i = 0; i < postProcessors.Length; i++)
				{
					postProcessors[i].enabled = false;
				}
				Timing.PauseCoroutines(handle);
			}
			else
			{
				ShakeVal = num * shakeMagnitude * Mathf.PerlinNoise(Time.time * shakeFrequency, 10.234896f);
			}
			yield return 0f;
		}
	}
}
public static class Settings
{
	[Serializable]
	public class PlayerSettings
	{
		public Gender gender;

		public HandMode dominantHand = HandMode.Right;

		public HandMode teleportHand = HandMode.Right;

		public TeleportMode teleportMode;

		public TurnMode turnMode;

		public TurnDegrees turnDegrees = TurnDegrees.FortyFive;

		public float turnSpeed = 180f;

		public ComfortMode comfortMode;

		public float sitHeight = 0.48f;

		public bool subtitles;

		public Language language;

		public bool hints = true;

		public bool quips = true;

		public bool toolTips = true;

		public Difficulty difficulty = Difficulty.Normal;

		public float music = 0.8f;

		public float ambient = 0.8f;

		public float sfx = 0.8f;

		public float voice = 1f;

		public PlayerSettings()
		{
			subtitles = LocalizationManager.GetDefaultLanguage() != Language.English;
		}

		public PlayerSettings Copy()
		{
			return new PlayerSettings
			{
				gender = gender,
				dominantHand = dominantHand,
				teleportHand = teleportHand,
				teleportMode = teleportMode,
				turnMode = turnMode,
				turnDegrees = turnDegrees,
				turnSpeed = turnSpeed,
				comfortMode = comfortMode,
				sitHeight = sitHeight,
				subtitles = subtitles,
				language = language,
				hints = hints,
				quips = quips,
				toolTips = toolTips,
				difficulty = difficulty,
				music = music,
				ambient = ambient,
				sfx = sfx,
				voice = voice
			};
		}
	}

	public static PlayerSettings Current = new PlayerSettings();

	public static void ResetToDefault()
	{
		Current = new PlayerSettings();
		SetGender(Gender.Male);
		SetDominantHand(HandMode.Right);
		SetTeleportHand(HandMode.Right);
		SetTeleportMode(TeleportMode.Blink);
		SetTurnMode(TurnMode.Snap);
		SetTurnDegrees(TurnDegrees.FortyFive);
		SetTurnSpeed(180f);
		SetComfortMode(ComfortMode.Stand);
		SetSitHeight(0.48f);
		SetLanguage(LocalizationManager.GetDefaultLanguage());
		SetSubtitles(Current.language != Language.English);
		SetHints(active: true);
		SetQuips(active: true);
		SetToolTips(active: true);
		SetDifficulty(Difficulty.Normal);
		Current.music = 0.8f;
		Current.ambient = 0.8f;
		Current.sfx = 0.8f;
		Current.voice = 1f;
	}

	public static void ApplySettings()
	{
		Singleton<VRSystem>.Instance.maleModel.SetActive(Current.gender == Gender.Male);
		Singleton<VRSystem>.Instance.femaleModel.SetActive(Current.gender == Gender.Female);
		Singleton<VRSystem>.Instance.controlsRight.SetActive(Current.dominantHand.HasFlag(HandMode.Right));
		Singleton<VRSystem>.Instance.controlsLeft.SetActive(Current.dominantHand.HasFlag(HandMode.Left));
		Singleton<VRSystem>.Instance.teleportRight.SetActive(Current.teleportHand.HasFlag(HandMode.Right));
		Singleton<VRSystem>.Instance.teleportLeft.SetActive(Current.teleportHand.HasFlag(HandMode.Left));
		Singleton<VRSystem>.Instance.locomotionRight.SetActive(!Current.teleportHand.HasFlag(HandMode.Right));
		Singleton<VRSystem>.Instance.locomotionLeft.SetActive(!Current.teleportHand.HasFlag(HandMode.Left));
		SetComfortMode(Current.comfortMode);
		Singleton<LocalizationManager>.Instance.SetLanguage(Current.language);
		References.AudioMixer.SetFloat("Music", Mathf.Log10(Current.music) * 20f);
		References.AudioMixer.SetFloat("Ambient", Mathf.Log10(Current.ambient) * 20f);
		References.AudioMixer.SetFloat("SFX", Mathf.Log10(Current.sfx) * 20f);
		References.AudioMixer.SetFloat("Voice", Mathf.Log10(Current.voice) * 20f);
	}

	public static void SetGender(Gender gender)
	{
		Current.gender = gender;
		Singleton<VRSystem>.Instance.maleModel.SetActive(gender == Gender.Male);
		Singleton<VRSystem>.Instance.femaleModel.SetActive(gender == Gender.Female);
	}

	public static void SetDominantHand(HandMode mode)
	{
		if (Current.dominantHand != mode)
		{
			if (mode == HandMode.Right)
			{
				References.HandChanged.RaiseTrue();
			}
			else
			{
				References.HandChanged.RaiseFalse();
			}
			Current.dominantHand = mode;
			Singleton<VRSystem>.Instance.controlsRight.SetActive(mode.HasFlag(HandMode.Right));
			Singleton<VRSystem>.Instance.controlsLeft.SetActive(mode.HasFlag(HandMode.Left));
			References.Inventory.SetDominantHand(mode);
		}
	}

	public static void SetTeleportHand(HandMode mode)
	{
		Current.teleportHand = mode;
		Singleton<VRSystem>.Instance.teleportRight.SetActive(mode.HasFlag(HandMode.Right));
		Singleton<VRSystem>.Instance.teleportLeft.SetActive(mode.HasFlag(HandMode.Left));
		Singleton<VRSystem>.Instance.locomotionRight.SetActive(!mode.HasFlag(HandMode.Right));
		Singleton<VRSystem>.Instance.locomotionLeft.SetActive(!mode.HasFlag(HandMode.Left));
		References.TeleportHandChanged.RaiseTrue();
	}

	public static void SetTeleportMode(TeleportMode mode)
	{
		Current.teleportMode = mode;
	}

	public static void SetTurnMode(TurnMode mode)
	{
		Current.turnMode = mode;
	}

	public static void SetTurnDegrees(TurnDegrees degrees)
	{
		Current.turnDegrees = degrees;
	}

	public static void SetTurnSpeed(float speed)
	{
		Current.turnSpeed = speed;
	}

	public static void SetComfortMode(ComfortMode mode)
	{
		Current.comfortMode = mode;
		if (mode == ComfortMode.Sit)
		{
			References.ComfortModeChanged.RaiseTrue();
		}
		if (mode == ComfortMode.Stand)
		{
			References.ComfortModeChanged.RaiseFalse();
		}
	}

	public static void SetSitHeight(float height)
	{
		Current.sitHeight = height;
		References.ComfortModeChanged.RaiseTrue();
	}

	public static void SetSubtitles(bool active)
	{
		Current.subtitles = active;
	}

	public static void SetLanguage(Language language)
	{
		Current.language = language;
		Singleton<LocalizationManager>.Instance.SetLanguage(language);
	}

	public static void SetHints(bool active)
	{
		Current.hints = active;
	}

	public static void SetQuips(bool active)
	{
		Current.quips = active;
		if (active && Singleton<OdinQuip>.Instance != null)
		{
			Singleton<OdinQuip>.Instance.Unpause();
		}
	}

	public static void SetToolTips(bool active)
	{
		Current.toolTips = active;
	}

	public static void SetDifficulty(Difficulty difficulty)
	{
		Current.difficulty = difficulty;
		References.DifficultyChanged.RaiseTrue();
	}

	public static void SetVolMusic(float value)
	{
		Current.music = value;
		References.AudioMixer.SetFloat("Music", Mathf.Log10(value) * 20f);
	}

	public static void SetVolAmbient(float value)
	{
		Current.ambient = value;
		References.AudioMixer.SetFloat("Ambient", Mathf.Log10(value) * 20f);
	}

	public static void SetVolSFX(float value)
	{
		Current.sfx = value;
		References.AudioMixer.SetFloat("SFX", Mathf.Log10(value) * 20f);
	}

	public static void SetVolVoice(float value)
	{
		Current.voice = value;
		References.AudioMixer.SetFloat("Voice", Mathf.Log10(value) * 20f);
	}
}
public class TeleportRotateManager : MonoBehaviour
{
	public FloatVariable xAxis;

	public FloatVariable yAxis;

	public float minValueForTrue = 0.75f;

	public CameraColorOverlayRealtime overlay;

	public Hand handAlias;

	public LayerMask blockTeleportLayers;

	public TeleportArc teleportArc;

	public float dashSpeed = 60f;

	private bool _teleporterSelectionActive;

	private static bool _isTeleporting;

	private static bool _isRotating;

	private float _prevX;

	private float _prevY;

	private float _minValueForTrueSqr;

	private Player _player;

	public static bool IsDashTeleporting
	{
		get
		{
			if (_isTeleporting)
			{
				return Settings.Current.teleportMode == TeleportMode.Dash;
			}
			return false;
		}
	}

	private void Start()
	{
		_minValueForTrueSqr = minValueForTrue * minValueForTrue;
		_player = Player.Instance;
	}

	private void Update()
	{
		if (_isRotating || _isTeleporting || References.HeadColliderScript.IsInWall)
		{
			return;
		}
		if (VRSystem.IsPaused || MenuManager.IsInMenu)
		{
			_teleporterSelectionActive = false;
			teleportArc.Deactivate(cancel: true);
			if (VRSystem.IsPaused)
			{
				return;
			}
		}
		if (!MenuManager.IsInMenu && (float)yAxis >= minValueForTrue && _prevY < minValueForTrue)
		{
			_teleporterSelectionActive = true;
		}
		if (_teleporterSelectionActive)
		{
			if (References.PlayerMoveTeleportLock.IsLocked() || References.PlayerInterfaceLock.IsLocked())
			{
				teleportArc.Deactivate(cancel: true);
			}
			else
			{
				bool flag = true;
				int num = Physics.RaycastNonAlloc(References.Headset.position, handAlias.teleportOrigin.position - References.Headset.position, Utilities.raycastHitPool, Vector3.Distance(References.Headset.position, handAlias.teleportOrigin.position), blockTeleportLayers, QueryTriggerInteraction.Collide);
				for (int i = 0; i < num; i++)
				{
					if (!(Utilities.raycastHitPool[i].transform.GetComponentInParent<VRSystem>() != null))
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					teleportArc.gameObject.SetActive(value: true);
					if (new Vector2(xAxis, yAxis).sqrMagnitude < _minValueForTrueSqr)
					{
						_teleporterSelectionActive = false;
						if (teleportArc.IsTargetValid())
						{
							teleportArc.LockTarget();
							Timing.RunCoroutine(Teleport());
						}
					}
					else
					{
						teleportArc.SetForwardRotation(handAlias.transform.TransformDirection(xAxis, 0f, yAxis));
					}
				}
				else
				{
					teleportArc.Deactivate(cancel: true);
				}
			}
		}
		else
		{
			teleportArc.Deactivate();
			if (Settings.Current.turnMode == TurnMode.Smooth)
			{
				if ((float)xAxis >= minValueForTrue)
				{
					SmoothRotate((float)(int)Settings.Current.turnSpeed * ((float)xAxis - minValueForTrue) / (1f - minValueForTrue));
				}
				else if ((float)xAxis <= 0f - minValueForTrue)
				{
					SmoothRotate((float)(-(int)Settings.Current.turnSpeed) * (0f - (float)xAxis - minValueForTrue) / (1f - minValueForTrue));
				}
			}
			else if ((float)xAxis >= minValueForTrue && _prevX < minValueForTrue)
			{
				Timing.RunCoroutine(Rotate((float)Settings.Current.turnDegrees), MenuManager.IsInMenu ? Segment.RealtimeUpdate : Segment.Update);
			}
			else if ((float)xAxis <= 0f - minValueForTrue && _prevX > 0f - minValueForTrue)
			{
				Timing.RunCoroutine(Rotate(0 - Settings.Current.turnDegrees), MenuManager.IsInMenu ? Segment.RealtimeUpdate : Segment.Update);
			}
		}
		_prevX = xAxis;
		_prevY = yAxis;
	}

	private IEnumerator<float> Teleport()
	{
		_isTeleporting = true;
		if (Settings.Current.teleportMode == TeleportMode.Blink)
		{
			overlay.Blink();
			yield return Timing.WaitForSeconds(overlay.AddDuration);
			_player.SetPositionAndRotation(teleportArc.surfaceTracker, useHeadPosition: false);
			References.TrackingSpace.SetSurface(teleportArc.surfaceTracker.parent);
			teleportArc.Deactivate();
			References.OnTeleported.RaiseTrue();
			yield return Timing.WaitForSeconds(overlay.AppliedDuration + overlay.RemoveDuration);
		}
		else
		{
			References.PlayerFallLock.LockUsing(this);
			References.TrackingSpace.SetSurface(null);
			_player.SetCollidersActive(active: false);
			Vector3 position = _player.GetPosition();
			Vector3 currentPosition = position;
			Vector3 startForward = References.Headset.forward;
			float distTraveled = 0f;
			float totalDist = Vector3.Distance(position, teleportArc.surfaceTracker.position);
			while (true)
			{
				float num = dashSpeed * Time.deltaTime;
				distTraveled += num;
				Vector3 position2 = teleportArc.surfaceTracker.position;
				if (!(Vector3.Distance(currentPosition, position2) > num))
				{
					break;
				}
				currentPosition = Vector3.MoveTowards(currentPosition, position2, num);
				_player.SetPositionAndRotation(currentPosition, Vector3.Slerp(startForward, teleportArc.surfaceTracker.forward, distTraveled / totalDist), useHeadPosition: false, setValid: false);
				_player.SetPosition(currentPosition, useHeadPosition: false, setValid: false);
				yield return float.NegativeInfinity;
			}
			_player.SetPositionAndRotation(teleportArc.surfaceTracker, useHeadPosition: false, setValid: false);
			yield return float.NegativeInfinity;
			_player.SetPositionAndRotation(teleportArc.surfaceTracker, useHeadPosition: false);
			References.TrackingSpace.SetSurface(teleportArc.surfaceTracker.parent);
			teleportArc.Deactivate();
			References.OnTeleported.RaiseTrue();
			References.PlayerFallLock.Unlock(this);
			yield return float.NegativeInfinity;
			yield return float.NegativeInfinity;
			_player.SetCollidersActive(active: true);
		}
		_isTeleporting = false;
	}

	private IEnumerator<float> Rotate(float degrees)
	{
		_isRotating = true;
		overlay.Blink();
		yield return Timing.WaitForSeconds(overlay.AddDuration);
		References.TrackingSpaceTransform.RotateAround(References.Headset.position, Vector3.up, degrees);
		References.OnRotated.RaiseTrue();
		yield return Timing.WaitForSeconds(overlay.AppliedDuration + overlay.RemoveDuration);
		_isRotating = false;
	}

	private void SmoothRotate(float speed)
	{
		References.TrackingSpaceTransform.RotateAround(References.Headset.position, Vector3.up, speed * Time.unscaledDeltaTime);
	}
}
public class TouchAction : BooleanAction
{
	public OVRInput.Controller controller = OVRInput.Controller.Active;

	public OVRInput.Axis1D axis;

	public OVRInput.Touch touch;

	public float positiveValue = 0.1f;

	private void Update()
	{
		Receive(OVRInput.Get(touch, controller) || OVRInput.Get(axis, controller) > positiveValue);
	}
}
public class TrackingSpace : Singleton<TrackingSpace>
{
	public Transform surfaceTracker;

	public System.Action onChangedSurface;

	private Player _player;

	private readonly List<Transform> _relativeTracking = new List<Transform>();

	private Vector3 _lastPos;

	private Vector3 _directionLock;

	private bool _lockDirection;

	private Transform _currentSurface;

	private Vector3 _currentSurfaceOffset;

	private Vector3 _currentVelocity;

	public bool IsClimbing => _relativeTracking.Count > 0;

	private void Start()
	{
		_player = Player.Instance;
	}

	public void MoveRelativeTo(Transform target, Vector3? directionLock = null)
	{
		if (directionLock.HasValue)
		{
			_lockDirection = true;
			_directionLock = directionLock.Value;
		}
		else
		{
			_lockDirection = false;
		}
		_lastPos = target.position;
		_relativeTracking.Insert(0, target);
		SetSurface(null);
		if (_relativeTracking.Count == 1)
		{
			Timing.RunCoroutine(Singleton<TrackingSpace>.Instance.Track());
		}
	}

	public void StopTracking(Transform target)
	{
		_relativeTracking.Remove(target);
		if (_relativeTracking.Count > 0)
		{
			_lastPos = _relativeTracking[0].position;
		}
	}

	public void SetSurface(Transform target)
	{
		if (!(_currentSurface == target))
		{
			_currentSurface = target;
			onChangedSurface?.Invoke();
			if (target != null)
			{
				surfaceTracker.position = target.position;
				surfaceTracker.rotation = target.rotation;
				_currentSurfaceOffset = surfaceTracker.InverseTransformPoint(base.transform.position);
			}
			else
			{
				_currentVelocity = Vector3.zero;
			}
		}
	}

	public Vector3 GetSurfaceVelocity()
	{
		if (_currentSurface != null)
		{
			return _currentVelocity;
		}
		return Vector3.zero;
	}

	private IEnumerator<float> Track()
	{
		while (_relativeTracking.Count > 0)
		{
			if (!VRSystem.IsPaused)
			{
				Vector3 vector = ((!_lockDirection) ? (_relativeTracking[0].position - _lastPos) : Vector3.Project(_relativeTracking[0].position - _lastPos, _directionLock));
				Vector3 vector2 = _player.characterController.transform.TransformPoint(_player.characterController.center);
				Vector3 vector3 = Vector3.up * (_player.characterController.height / 2f - _player.characterController.radius);
				float magnitude = vector.magnitude;
				int num = Physics.SphereCastNonAlloc(vector2 - vector3, _player.characterController.radius, -vector.normalized, Utilities.raycastHitPool, magnitude, References.SolidLayers);
				if (num > 0)
				{
					Array.Sort(Utilities.raycastHitPool, 0, num, Utilities.RaycastHitDistanceComparer.Comparer);
					for (int i = 0; i < num; i++)
					{
						Transform transform = Utilities.raycastHitPool[i].transform;
						if (!transform.IsChildOf(Singleton<VRSystem>.Instance.transform) && !transform.gameObject.TryGetComponent<Climbable>(out var _))
						{
							vector *= Utilities.raycastHitPool[i].distance / magnitude;
							break;
						}
					}
				}
				base.transform.position -= vector;
				_lastPos = _relativeTracking[0].position;
			}
			yield return 0f;
		}
	}

	private void Update()
	{
		if (VRSystem.IsPaused || Time.timeScale == 0f || !(_currentSurface != null))
		{
			return;
		}
		if (OdinView.IsViewingOrTransitioning())
		{
			if (Vector3.SqrMagnitude(_currentSurface.position - surfaceTracker.position) > 1E-07f || _currentSurface.rotation != surfaceTracker.rotation)
			{
				surfaceTracker.position = _currentSurface.position;
				if (_currentSurface.rotation != surfaceTracker.rotation)
				{
					Quaternion quaternion = Quaternion.FromToRotation(Vector3.ProjectOnPlane(surfaceTracker.forward, Vector3.up), Vector3.ProjectOnPlane(_currentSurface.forward, Vector3.up));
					_player.playerFeet.rotation *= quaternion;
					surfaceTracker.rotation = _currentSurface.rotation;
				}
				_player.playerFeet.position = surfaceTracker.TransformPoint(_currentSurfaceOffset);
				_player.transform.position = _player.playerFeet.position + _player.collider.height / 2f * Vector3.up;
				_currentSurfaceOffset = surfaceTracker.InverseTransformPoint(_player.playerFeet.position);
			}
			return;
		}
		if (Vector3.SqrMagnitude(_currentSurface.position - surfaceTracker.position) > 1E-07f || _currentSurface.rotation != surfaceTracker.rotation)
		{
			Vector3 vector = surfaceTracker.InverseTransformPoint(base.transform.position) - _currentSurfaceOffset;
			_currentVelocity = base.transform.position;
			surfaceTracker.position = _currentSurface.position;
			if (_currentSurface.rotation != surfaceTracker.rotation)
			{
				Quaternion quaternion2 = Quaternion.FromToRotation(Vector3.ProjectOnPlane(surfaceTracker.forward, Vector3.up), Vector3.ProjectOnPlane(_currentSurface.forward, Vector3.up));
				base.transform.rotation *= quaternion2;
				surfaceTracker.rotation = _currentSurface.rotation;
			}
			base.transform.position = surfaceTracker.TransformPoint(_currentSurfaceOffset + vector);
			_currentVelocity = (base.transform.position - _currentVelocity) / Time.deltaTime;
			if (float.IsNaN(_currentVelocity.x))
			{
				_currentVelocity = Vector3.zero;
			}
		}
		else
		{
			_currentVelocity = Vector3.zero;
		}
		_currentSurfaceOffset = surfaceTracker.InverseTransformPoint(base.transform.position);
	}
}
public class VRSystem : Singleton<VRSystem>
{
	public GameObject controlsRight;

	public GameObject controlsLeft;

	public GameObject teleportRight;

	public GameObject teleportLeft;

	public GameObject locomotionRight;

	public GameObject locomotionLeft;

	public GameObject maleModel;

	public GameObject femaleModel;

	public Camera centerCamera;

	private float _desiredTimescale;

	private bool _hmdUnmounted;

	private bool _vrFocusLost;

	private bool _inputFocusLost;

	private bool _trackingLost;

	private bool _appPaused;

	private int _cameraLayerMask;

	private Vector3 _returnPos;

	public static bool IsPaused { get; private set; }

	protected override void Awake()
	{
		base.Awake();
		if (Singleton<VRSystem>.Instance == this)
		{
			Settings.ResetToDefault();
		}
		OVRManager.HMDUnmounted += HMDUnmounted;
		OVRManager.HMDMounted += HMDMounted;
		OVRManager.VrFocusLost += VrFocusLost;
		OVRManager.VrFocusAcquired += VrFocusAcquired;
		OVRManager.InputFocusLost += InputFocusLost;
		OVRManager.InputFocusAcquired += InputFocusAcquired;
		OVRManager.TrackingLost += TrackingLost;
		OVRManager.TrackingAcquired += TrackingAcquired;
	}

	private void OnDestroy()
	{
		OVRManager.HMDUnmounted -= HMDUnmounted;
		OVRManager.HMDMounted -= HMDMounted;
		OVRManager.VrFocusLost -= VrFocusLost;
		OVRManager.VrFocusAcquired -= VrFocusAcquired;
		OVRManager.InputFocusLost -= InputFocusLost;
		OVRManager.InputFocusAcquired -= InputFocusAcquired;
		OVRManager.TrackingLost -= TrackingLost;
		OVRManager.TrackingAcquired -= TrackingAcquired;
	}

	public void SetTimeScale(float timeScale)
	{
		_desiredTimescale = timeScale;
		if (!IsPaused)
		{
			Time.timeScale = _desiredTimescale;
		}
	}

	private void HMDUnmounted()
	{
		_hmdUnmounted = true;
		CheckPause();
	}

	private void HMDMounted()
	{
		_hmdUnmounted = false;
		CheckPause();
	}

	private void VrFocusLost()
	{
		_vrFocusLost = true;
		CheckPause();
	}

	private void VrFocusAcquired()
	{
		_vrFocusLost = false;
		CheckPause();
	}

	private void InputFocusLost()
	{
		_inputFocusLost = true;
		CheckPause();
	}

	private void InputFocusAcquired()
	{
		_inputFocusLost = false;
		CheckPause();
	}

	private void TrackingLost()
	{
		_trackingLost = true;
		CheckPause();
	}

	private void TrackingAcquired()
	{
		_trackingLost = false;
		CheckPause();
	}

	private void OnApplicationPause(bool pause)
	{
		_appPaused = pause;
		CheckPause();
	}

	private void CheckPause()
	{
		if (_hmdUnmounted || _vrFocusLost || _inputFocusLost || _trackingLost || _appPaused)
		{
			PauseGame();
		}
		else
		{
			UnpauseGame();
		}
	}

	private void PauseGame()
	{
		if (!IsPaused)
		{
			if (!MenuManager.IsInMenu)
			{
				Player.Instance.leftHand.RemoveObjectFromHand(ignoreEquipment: true);
				Player.Instance.rightHand.RemoveObjectFromHand(ignoreEquipment: true);
			}
			AudioListener.pause = true;
			Time.timeScale = 0f;
			IsPaused = true;
			_cameraLayerMask = centerCamera.cullingMask;
			centerCamera.cullingMask = 0;
			centerCamera.clearFlags = CameraClearFlags.Color;
			References.OnGamePaused.RaiseTrue();
			_returnPos = Player.Instance.GetHeadPosition();
		}
	}

	private void UnpauseGame()
	{
		if (IsPaused)
		{
			if (!MenuManager.IsInMenu)
			{
				Player.Instance.leftHand.ReplaceObjectInHand();
				Player.Instance.rightHand.ReplaceObjectInHand();
			}
			centerCamera.cullingMask = _cameraLayerMask;
			centerCamera.clearFlags = CameraClearFlags.Skybox;
			Time.timeScale = _desiredTimescale;
			AudioListener.pause = false;
			IsPaused = false;
			Player.Instance.SetPosition(_returnPos, useHeadPosition: true, setValid: false);
			References.OnGamePaused.RaiseFalse();
		}
	}
}
public class VRTracker : MonoBehaviour
{
	public Transform target;

	public Transform relativeTarget;

	private void Update()
	{
		base.transform.position = target.position;
		base.transform.rotation = target.rotation;
	}
}
public class WheelHandle : HingeHandle
{
	public AudioSource playOnTurn;

	private Vector3 _grabOffset;

	private float _grabRadius;

	private float _lastAngle;

	private float _trgtVol;

	public override void Awake()
	{
		base.Awake();
		_grabOffset = hingeJoint.transform.InverseTransformPoint(fixedJoint.transform.position);
		_grabRadius = new Vector3(_grabOffset.x, _grabOffset.y, 0f).magnitude;
		gripSnapPoint.localPosition = Vector3.zero;
	}

	protected override void Update()
	{
		if (isLocked)
		{
			base.Update();
		}
		else if (_hand != null)
		{
			float angle = hingeJoint.angle;
			float num = Mathf.Abs(angle - _lastAngle);
			_trgtVol = 0.01f * num / Time.deltaTime;
			if (_trgtVol < 0.2f)
			{
				_trgtVol = 0f;
			}
			if (playOnTurn != null)
			{
				playOnTurn.volume = Mathf.Clamp01(Mathf.Lerp(playOnTurn.volume, _trgtVol, Time.deltaTime * 20f));
				if (!playOnTurn.isPlaying)
				{
					if (playOnTurn.volume > 0f)
					{
						playOnTurn.Play();
					}
				}
				else if (playOnTurn.volume == 0f)
				{
					playOnTurn.Stop();
				}
			}
			_lastAngle = angle;
		}
		else
		{
			base.enabled = false;
		}
	}

	public override void GrabWith(Hand grabbing)
	{
		base.GrabWith(grabbing);
		SetGripPos();
		_lastAngle = hingeJoint.angle;
		Timing.RunCoroutine(HandleHaptics());
	}

	private void SetGripPos()
	{
		Vector3 vector = hingeJoint.transform.InverseTransformPoint(_hand.GetGripPosition());
		vector.z = 0f;
		vector = vector.normalized * _grabRadius;
		fixedJoint.transform.position = hingeJoint.transform.TransformPoint(new Vector3(vector.x, vector.y, _grabOffset.z));
		fixedJoint.connectedAnchor = fixedJoint.transform.localPosition;
		gripSnapPoint.localPosition = fixedJoint.transform.localPosition;
		Vector3 vector2 = base.transform.position - gripSnapPoint.position;
		Vector3 upwards = Vector3.Cross(-base.transform.forward, vector2);
		gripSnapPoint.rotation = Quaternion.LookRotation(vector2, upwards);
	}

	public override void OnReleased()
	{
		base.OnReleased();
		_trgtVol = 0f;
		gripSnapPoint.localPosition = Vector3.zero;
		if (playOnTurn != null && playOnTurn.isPlaying)
		{
			playOnTurn.FadeOut(0.05f);
		}
	}

	private IEnumerator<float> HandleHaptics()
	{
		Hand hand = _hand;
		Haptics.Vibration vibration = Haptics.Play(hapticFrequency, 0f, 0f, _hand);
		while (_hand != null && _hand == hand && _hand.GetGrabbedObject() == this)
		{
			vibration.SetAmplitude(_trgtVol * hapticAmplitude);
			yield return float.NegativeInfinity;
		}
		vibration.Stop();
	}
}
public class ValveRotator : MonoBehaviour
{
	public Transform rotationTarget;

	public Axis rotationAxis;

	public bool invertRotation = true;

	public float maxSpeed;

	[UnityEngine.Tooltip("The target will begin to decelerate when it is within this many degrees of the target value, and it takes this many degrees to reach its max turning speed.")]
	[Range(0.0001f, 360f)]
	public float dampenDegrees = 10f;

	public float snapAngle;

	public float initialAngle;

	public AudioSource playOnRotate;

	public PlayMakerFSM fsmOnRotate;

	public string eventOnRotate;

	private float _targetVal;

	private float _speed;

	private bool _isRotating;

	private float _acceleration;

	private void Start()
	{
		Vector3 eulerAngles = base.transform.localRotation.eulerAngles;
		eulerAngles.z = initialAngle;
		base.transform.localRotation = Quaternion.Euler(eulerAngles);
		if (snapAngle > 0f)
		{
			_targetVal = Mathf.Floor((eulerAngles.z + snapAngle / 2f) / snapAngle) * snapAngle;
		}
		else
		{
			_targetVal = eulerAngles.z;
		}
		if (invertRotation)
		{
			_targetVal = 0f - _targetVal;
		}
		SetRotation(rotationTarget.localRotation.eulerAngles, _targetVal);
		_acceleration = 2f * dampenDegrees / (dampenDegrees / (maxSpeed / 2f) * (dampenDegrees / (maxSpeed / 2f)));
	}

	private void Update()
	{
		Vector3 eulerAngles = base.transform.localRotation.eulerAngles;
		if (snapAngle > 0f)
		{
			_targetVal = Mathf.Floor((eulerAngles.z + snapAngle / 2f) / snapAngle) * snapAngle;
		}
		else
		{
			_targetVal = eulerAngles.z;
		}
		if (invertRotation)
		{
			_targetVal = 0f - _targetVal;
		}
		Vector3 eulerAngles2 = rotationTarget.localRotation.eulerAngles;
		float rotation = GetRotation(eulerAngles2);
		if (Mathf.Abs(Mathf.DeltaAngle(rotation, _targetVal)) > 0.1f)
		{
			if (!_isRotating)
			{
				if (playOnRotate != null && !playOnRotate.isPlaying)
				{
					playOnRotate.Play();
				}
				_isRotating = true;
				if (fsmOnRotate != null)
				{
					fsmOnRotate.SendEvent(eventOnRotate);
				}
			}
			GetDesiredSpeed(rotation, _targetVal);
			SetRotation(eulerAngles2, rotation + _speed * Time.deltaTime);
		}
		else if (_isRotating)
		{
			SetRotation(eulerAngles2, _targetVal);
			_isRotating = false;
		}
	}

	private float GetDesiredSpeed(float currentAngle, float targetAngle)
	{
		float num = Mathf.DeltaAngle(currentAngle, targetAngle);
		float num2 = maxSpeed;
		if (num > 0f)
		{
			if (_speed < maxSpeed)
			{
				num2 = ((!(num < dampenDegrees)) ? Mathf.Min(_speed + _acceleration * Time.deltaTime, maxSpeed) : Mathf.Min(_speed + _acceleration * Time.deltaTime, Mathf.Sqrt(Mathf.Abs(num) / dampenDegrees) * maxSpeed));
			}
			else if (num < dampenDegrees)
			{
				num2 = Mathf.Min(_speed, Mathf.Sqrt(Mathf.Abs(num) / dampenDegrees) * maxSpeed);
			}
		}
		else if (num < 0f)
		{
			if (_speed > 0f - maxSpeed)
			{
				num2 = ((!(num < dampenDegrees)) ? Mathf.Max(_speed - _acceleration * Time.deltaTime, 0f - maxSpeed) : Mathf.Max(_speed - _acceleration * Time.deltaTime, (0f - Mathf.Sqrt(Mathf.Abs(num) / dampenDegrees)) * maxSpeed));
			}
			else if (num < dampenDegrees)
			{
				num2 = Mathf.Max(_speed, (0f - Mathf.Sqrt(Mathf.Abs(num) / dampenDegrees)) * maxSpeed);
			}
		}
		_speed = num2;
		return num2;
	}

	private float GetRotation(Vector3 rotation)
	{
		return rotationAxis switch
		{
			Axis.X => rotation.x, 
			Axis.Y => rotation.y, 
			_ => rotation.z, 
		};
	}

	private void SetRotation(Vector3 rotation, float value)
	{
		switch (rotationAxis)
		{
		case Axis.X:
			rotationTarget.localRotation = Quaternion.Euler(value, rotation.y, rotation.z);
			break;
		case Axis.Y:
			rotationTarget.localRotation = Quaternion.Euler(rotation.x, value, rotation.z);
			break;
		default:
			rotationTarget.localRotation = Quaternion.Euler(rotation.x, rotation.y, value);
			break;
		}
	}
}
[Serializable]
public class BoolReference
{
	public bool UseConstant = true;

	public bool ConstantValue;

	public BoolVariable Variable;

	public bool Value
	{
		get
		{
			if (!UseConstant)
			{
				return Variable.Value;
			}
			return ConstantValue;
		}
	}

	public BoolReference()
	{
	}

	public BoolReference(bool value)
	{
		UseConstant = true;
		ConstantValue = value;
	}

	public static implicit operator bool(BoolReference reference)
	{
		return reference.Value;
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/Boolean")]
public class BoolVariable : ScriptableObject
{
	public bool Value;

	public void SetValue(bool value)
	{
		Value = value;
	}

	public void SetValue(BoolVariable value)
	{
		Value = value.Value;
	}

	public static implicit operator bool(BoolVariable var)
	{
		return var?.Value ?? false;
	}

	public override string ToString()
	{
		return Value.ToString();
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/Float with Difficulty")]
public class FloatDifficultyVariable : FloatVariable
{
	public float ValueEasy;

	public float ValueHard;

	public static implicit operator float(FloatDifficultyVariable var)
	{
		if (var == null)
		{
			return 0f;
		}
		return var.GetValue();
	}

	protected override float GetValue()
	{
		return Settings.Current.difficulty switch
		{
			Difficulty.Easy => ValueEasy, 
			Difficulty.Hard => ValueHard, 
			_ => Value, 
		};
	}
}
[Serializable]
public class FloatReference
{
	public bool UseConstant = true;

	public float ConstantValue;

	public FloatVariable Variable;

	public float Value
	{
		get
		{
			if (!UseConstant)
			{
				return Variable;
			}
			return ConstantValue;
		}
	}

	public FloatReference()
	{
	}

	public FloatReference(float value)
	{
		UseConstant = true;
		ConstantValue = value;
	}

	public static implicit operator float(FloatReference reference)
	{
		return reference.Value;
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/Float")]
public class FloatVariable : ScriptableObject
{
	public float Value;

	public void SetValue(float value)
	{
		Value = value;
	}

	public void SetValue(FloatVariable value)
	{
		Value = value.Value;
	}

	public void ApplyChange(float amount)
	{
		Value += amount;
	}

	public void ApplyChange(FloatVariable amount)
	{
		Value += amount.Value;
	}

	public static implicit operator float(FloatVariable var)
	{
		return var?.GetValue() ?? 0f;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	protected virtual float GetValue()
	{
		return Value;
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/Int with Difficulty")]
public class IntDifficultyVariable : IntVariable
{
	public int ValueEasy;

	public int ValueHard;

	public static implicit operator int(IntDifficultyVariable var)
	{
		if (var == null)
		{
			return 0;
		}
		return var.GetValue();
	}

	protected override int GetValue()
	{
		return Settings.Current.difficulty switch
		{
			Difficulty.Easy => ValueEasy, 
			Difficulty.Hard => ValueHard, 
			_ => Value, 
		};
	}
}
[Serializable]
public class IntReference
{
	public bool UseConstant = true;

	public int ConstantValue;

	public IntVariable Variable;

	public int Value
	{
		get
		{
			if (!UseConstant)
			{
				return Variable;
			}
			return ConstantValue;
		}
	}

	public IntReference()
	{
	}

	public IntReference(int value)
	{
		UseConstant = true;
		ConstantValue = value;
	}

	public static implicit operator int(IntReference reference)
	{
		return reference.Value;
	}

	public static IntReference operator -(IntReference value, int subtract)
	{
		if (value.UseConstant)
		{
			value.ConstantValue -= subtract;
		}
		else
		{
			value.Variable.Value -= subtract;
		}
		return value;
	}

	public static IntReference operator +(IntReference value, int add)
	{
		if (value.UseConstant)
		{
			value.ConstantValue += add;
		}
		else
		{
			value.Variable.Value += add;
		}
		return value;
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/Int")]
public class IntVariable : ScriptableObject
{
	public int Value;

	public void SetValue(int value)
	{
		Value = value;
	}

	public void SetValue(IntVariable value)
	{
		Value = value.Value;
	}

	public void ApplyChange(int amount)
	{
		Value += amount;
	}

	public void ApplyChange(IntVariable amount)
	{
		Value += amount.Value;
	}

	public static implicit operator int(IntVariable var)
	{
		return var?.GetValue() ?? 0;
	}

	public override string ToString()
	{
		return Value.ToString();
	}

	protected virtual int GetValue()
	{
		return Value;
	}
}
[CreateAssetMenu(menuName = "Custom/Lock")]
public class Lock : ScriptableObject
{
	private readonly List<object> locks = new List<object>();

	public event System.Action OnLock;

	public event System.Action OnUnlock;

	public event Action<bool> OnChange;

	public void LockUsing(object o)
	{
		if (!locks.Contains(o))
		{
			locks.Add(o);
			if (locks.Count == 1)
			{
				this.OnChange?.Invoke(obj: true);
				this.OnLock?.Invoke();
			}
		}
	}

	public void Unlock(object o)
	{
		if (locks.Contains(o))
		{
			locks.Remove(o);
			if (locks.Count == 0)
			{
				this.OnChange?.Invoke(obj: false);
				this.OnUnlock?.Invoke();
			}
		}
	}

	public bool IsLocked()
	{
		return locks.Count > 0;
	}

	public void UnlockAll()
	{
		if (locks.Count > 0)
		{
			locks.Clear();
			this.OnChange?.Invoke(obj: false);
			this.OnUnlock?.Invoke();
		}
	}
}
[Serializable]
public class MultiLock
{
	public Lock[] locks;

	public bool IsLocked()
	{
		for (int i = 0; i < locks.Length; i++)
		{
			if (locks[i].IsLocked())
			{
				return true;
			}
		}
		return false;
	}

	public int NumLocked()
	{
		int num = 0;
		for (int i = 0; i < locks.Length; i++)
		{
			if (locks[i].IsLocked())
			{
				num++;
			}
		}
		return num;
	}
}
[Serializable]
public class ObjectIDReference
{
	public bool UseConstant = true;

	public GameObject ConstantValue;

	public ObjectIDVariable Variable;

	public GameObject Value
	{
		get
		{
			if (!UseConstant)
			{
				return Variable;
			}
			return ConstantValue;
		}
	}

	public ObjectIDReference()
	{
	}

	public ObjectIDReference(GameObject value)
	{
		UseConstant = true;
		ConstantValue = value;
	}

	public ObjectIDReference(string value)
	{
		UseConstant = false;
		Variable.ID = value;
	}

	public static implicit operator GameObject(ObjectIDReference reference)
	{
		return reference.Value;
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/ObjectID")]
public class ObjectIDVariable : ScriptableObject
{
	public string ID;

	public GameObject Value => ObjectID.Get(ID);

	public void SetValue(string value)
	{
		ID = value;
	}

	public void SetValue(ObjectIDVariable value)
	{
		ID = value.ID;
	}

	public void SetValue(GameObject value)
	{
		ObjectID objectID = value.GetComponent<ObjectID>();
		if (objectID == null)
		{
			objectID = value.AddComponent<ObjectID>();
		}
		ID = objectID.GetID();
	}

	public static implicit operator GameObject(ObjectIDVariable var)
	{
		if ((object)var == null)
		{
			return null;
		}
		return ObjectID.Get(var.ID);
	}

	public override string ToString()
	{
		GameObject gameObject = ObjectID.Get(ID);
		if (gameObject == null)
		{
			return null;
		}
		return gameObject.ToString();
	}

	public T GetValue<T>() where T : Component
	{
		return ObjectID.Get<T>(ID);
	}
}
[Serializable]
public class ScriptReference<T> where T : Component
{
	public bool UseConstant = true;

	public T ConstantValue;

	public string Variable;

	public T Value
	{
		get
		{
			if (!UseConstant)
			{
				return ObjectID.Get<T>(Variable);
			}
			return ConstantValue;
		}
	}

	public ScriptReference()
	{
	}

	public ScriptReference(T value)
	{
		UseConstant = true;
		ConstantValue = value;
	}

	public static implicit operator T(ScriptReference<T> reference)
	{
		return reference.Value;
	}
}
[Serializable]
public class InventoryItemReference : ScriptReference<InventoryItem>
{
}
[Serializable]
public class PlayMakerFSMReference : ScriptReference<PlayMakerFSM>
{
}
[Serializable]
public class TransformReference : ScriptReference<Transform>
{
}
[Serializable]
public class StringReference
{
	public bool UseConstant = true;

	public string ConstantValue;

	public StringVariable Variable;

	public string Value
	{
		get
		{
			if (!UseConstant)
			{
				return Variable.Value;
			}
			return ConstantValue;
		}
	}

	public StringReference()
	{
	}

	public StringReference(string value)
	{
		UseConstant = true;
		ConstantValue = value;
	}

	public static implicit operator string(StringReference reference)
	{
		return reference.Value;
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/String")]
public class StringVariable : ScriptableObject
{
	[SerializeField]
	private string value = string.Empty;

	public string Value
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public static implicit operator string(StringVariable var)
	{
		return var.Value;
	}

	public override string ToString()
	{
		return value;
	}
}
[CreateAssetMenu(menuName = "Custom/Variable/Transform")]
public class TransformVariable : ScriptableObject
{
	[SerializeField]
	private Transform value;

	public Transform Value
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public static implicit operator Transform(TransformVariable var)
	{
		return var.Value;
	}

	public override string ToString()
	{
		return Value.ToString();
	}
}
[ExecuteInEditMode]
public class WaypointPath : MonoBehaviour
{
	[SerializeField]
	private List<Vector3> waypoints = new List<Vector3> { Vector3.zero };

	public Vector3 GetWaypoint(ref int index)
	{
		index %= waypoints.Count;
		return waypoints[index] + base.transform.position;
	}

	public Vector3 GetWaypoint(int index)
	{
		return waypoints[index % waypoints.Count] + base.transform.position;
	}

	public int GetNextIndex(int index)
	{
		return (index + 1) % waypoints.Count;
	}

	public int GetPrevIndex(int index)
	{
		if (index >= 1)
		{
			return index - 1;
		}
		return waypoints.Count - 1;
	}

	public Vector3 GetBezier(int index, float t)
	{
		Vector3 waypoint = GetWaypoint(index - 2);
		Vector3 waypoint2 = GetWaypoint(index - 1);
		return Vector3.Lerp(b: Vector3.Lerp(waypoint2, GetWaypoint(index), t), a: Vector3.Lerp(waypoint, waypoint2, t), t: t);
	}
}
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshFilter))]
[ExecuteInEditMode]
[DisallowMultipleComponent]
public abstract class MeshChainRenderer : MonoBehaviour
{
	private static readonly GradientColorKey k_DefaultStartColor = new GradientColorKey(Color.white, 0f);

	private static readonly GradientColorKey k_DefaultEndColor = new GradientColorKey(Color.white, 1f);

	private static readonly GradientAlphaKey k_DefaultStartAlpha = new GradientAlphaKey(1f, 0f);

	private static readonly GradientAlphaKey k_DefaultEndAlpha = new GradientAlphaKey(1f, 1f);

	[SerializeField]
	[UnityEngine.Tooltip("Materials to use when rendering.")]
	protected Material[] m_Materials;

	[SerializeField]
	[UnityEngine.Tooltip("The multiplier applied to the curve, describing the width (in world space) along the line.")]
	protected float m_Width = 1f;

	[SerializeField]
	[UnityEngine.Tooltip("The curve describing the width of the line at various points along its length.")]
	protected AnimationCurve m_WidthCurve = new AnimationCurve();

	[SerializeField]
	[UnityEngine.Tooltip("The gradient describing color along the line.")]
	protected Gradient m_Color = new Gradient();

	[SerializeField]
	[HideInInspector]
	protected MeshRenderer m_MeshRenderer;

	protected XRMeshChain m_XRMeshData;

	protected bool m_MeshNeedsRefreshing;

	protected float m_StepSize = 1f;

	public virtual Material material
	{
		get
		{
			return m_MeshRenderer.material;
		}
		set
		{
			m_MeshRenderer.material = value;
		}
	}

	public virtual Material[] materials
	{
		get
		{
			return m_MeshRenderer.materials;
		}
		set
		{
			m_MeshRenderer.materials = value;
		}
	}

	public virtual Material sharedMaterial
	{
		get
		{
			return m_MeshRenderer.sharedMaterial;
		}
		set
		{
			m_MeshRenderer.sharedMaterial = value;
		}
	}

	public virtual Material[] SharedMaterials
	{
		get
		{
			return m_MeshRenderer.materials;
		}
		set
		{
			m_MeshRenderer.sharedMaterials = value;
		}
	}

	public float widthStart
	{
		get
		{
			return m_WidthCurve.Evaluate(0f) * m_Width;
		}
		set
		{
			Keyframe[] keys = m_WidthCurve.keys;
			keys[0].value = value;
			m_WidthCurve.keys = keys;
			UpdateWidth();
		}
	}

	public float widthEnd
	{
		get
		{
			return m_WidthCurve.Evaluate(1f) * m_Width;
		}
		set
		{
			Keyframe[] keys = m_WidthCurve.keys;
			int num = keys.Length - 1;
			keys[num].value = value;
			m_WidthCurve.keys = keys;
			UpdateWidth();
		}
	}

	public float widthMultiplier
	{
		get
		{
			return m_Width;
		}
		set
		{
			m_Width = value;
			UpdateWidth();
		}
	}

	public AnimationCurve widthCurve
	{
		get
		{
			return m_WidthCurve;
		}
		set
		{
			m_WidthCurve = value ?? new AnimationCurve(new Keyframe(0f, 1f));
			UpdateWidth();
		}
	}

	public Gradient colorGradient
	{
		get
		{
			return m_Color;
		}
		set
		{
			if (m_Color != value)
			{
				m_Color = value ?? new Gradient
				{
					alphaKeys = new GradientAlphaKey[2] { k_DefaultStartAlpha, k_DefaultEndAlpha },
					colorKeys = new GradientColorKey[2] { k_DefaultStartColor, k_DefaultEndColor },
					mode = GradientMode.Blend
				};
				UpdateColors();
			}
		}
	}

	public Color colorStart
	{
		get
		{
			return m_Color.Evaluate(0f);
		}
		set
		{
			GradientColorKey[] colorKeys = m_Color.colorKeys;
			GradientAlphaKey[] alphaKeys = m_Color.alphaKeys;
			Color color = value;
			color.a = 1f;
			colorKeys[0].color = color;
			alphaKeys[0].alpha = value.a;
			m_Color.colorKeys = colorKeys;
			m_Color.alphaKeys = alphaKeys;
			UpdateColors();
		}
	}

	public Color colorEnd
	{
		get
		{
			return m_Color.Evaluate(1f);
		}
		set
		{
			GradientColorKey[] colorKeys = m_Color.colorKeys;
			GradientAlphaKey[] alphaKeys = m_Color.alphaKeys;
			int num = colorKeys.Length - 1;
			int num2 = alphaKeys.Length - 1;
			Color color = value;
			color.a = 1f;
			colorKeys[num].color = color;
			alphaKeys[num2].alpha = value.a;
			m_Color.colorKeys = colorKeys;
			m_Color.alphaKeys = alphaKeys;
			UpdateColors();
		}
	}

	public void SetTotalWidth(float newWidth)
	{
		m_Width = newWidth;
		m_WidthCurve = new AnimationCurve(new Keyframe(0f, 1f));
		UpdateWidth();
	}

	public void SetTotalColor(Color newColor)
	{
		Color col = newColor;
		col.a = 1f;
		m_Color = new Gradient
		{
			alphaKeys = new GradientAlphaKey[2]
			{
				new GradientAlphaKey(newColor.a, 0f),
				new GradientAlphaKey(newColor.a, 1f)
			},
			colorKeys = new GradientColorKey[2]
			{
				new GradientColorKey(col, 0f),
				new GradientColorKey(col, 1f)
			},
			mode = GradientMode.Blend
		};
		UpdateColors();
	}

	private void OnValidate()
	{
		SetupMeshBackend();
		if (!NeedsReinitialize())
		{
			EditorCheckForUpdate();
		}
	}

	private void SetupMeshBackend()
	{
		m_MeshRenderer = GetComponent<MeshRenderer>();
		m_MeshRenderer.hideFlags = HideFlags.HideInInspector;
		GetComponent<MeshFilter>().hideFlags = HideFlags.HideInInspector;
		if (m_Materials == null || m_Materials.Length == 0)
		{
			m_Materials = m_MeshRenderer.sharedMaterials;
		}
		m_MeshRenderer.sharedMaterials = m_Materials;
		if (m_WidthCurve == null || m_WidthCurve.keys == null || m_WidthCurve.keys.Length == 0)
		{
			m_WidthCurve = new AnimationCurve(new Keyframe(0f, 1f));
		}
		m_Color = m_Color ?? new Gradient
		{
			alphaKeys = new GradientAlphaKey[2] { k_DefaultStartAlpha, k_DefaultEndAlpha },
			colorKeys = new GradientColorKey[2] { k_DefaultStartColor, k_DefaultEndColor },
			mode = GradientMode.Blend
		};
	}

	protected virtual void Awake()
	{
		SetupMeshBackend();
		Initialize();
	}

	private void Reset()
	{
		SetupMeshBackend();
		Initialize();
	}

	private void Start()
	{
		Initialize();
	}

	protected virtual void LateUpdate()
	{
		if (m_MeshNeedsRefreshing)
		{
			m_XRMeshData.RefreshMesh();
			m_MeshNeedsRefreshing = false;
		}
	}

	public static implicit operator Renderer(MeshChainRenderer lr)
	{
		return lr.m_MeshRenderer;
	}

	private void EditorCheckForUpdate()
	{
		if (this != null)
		{
			Initialize();
		}
	}

	protected virtual void UpdateColors()
	{
	}

	protected virtual void UpdateWidth()
	{
	}

	protected virtual void Initialize()
	{
	}

	protected virtual bool NeedsReinitialize()
	{
		return true;
	}

	protected virtual void OnEnable()
	{
		m_MeshRenderer.enabled = true;
	}

	protected virtual void OnDisable()
	{
		m_MeshRenderer.enabled = false;
	}
}
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshFilter))]
[ExecuteInEditMode]
public class XRLineRenderer : MeshChainRenderer
{
	[SerializeField]
	[UnityEngine.Tooltip("All of the connected points to render as a line.")]
	private Vector3[] m_Positions;

	[SerializeField]
	[FormerlySerializedAs("m_WorldSpaceData")]
	[UnityEngine.Tooltip("Draw lines in worldspace (or local space) - driven via shader.")]
	private bool m_UseWorldSpace;

	[SerializeField]
	[UnityEngine.Tooltip("Connect the first and last vertices, to create a loop.")]
	private bool m_Loop;

	public bool loop
	{
		get
		{
			return m_Loop;
		}
		set
		{
			m_Loop = value;
			if (NeedsReinitialize())
			{
				Initialize();
			}
		}
	}

	public bool useWorldSpace => m_UseWorldSpace;

	public override Material material
	{
		get
		{
			return m_MeshRenderer.material;
		}
		set
		{
			m_MeshRenderer.material = value;
			CopyWorldSpaceDataFromMaterial();
		}
	}

	public override Material[] materials
	{
		get
		{
			return m_MeshRenderer.materials;
		}
		set
		{
			m_MeshRenderer.materials = value;
			CopyWorldSpaceDataFromMaterial();
		}
	}

	public override Material sharedMaterial
	{
		get
		{
			return m_MeshRenderer.sharedMaterial;
		}
		set
		{
			m_MeshRenderer.sharedMaterial = value;
			CopyWorldSpaceDataFromMaterial();
		}
	}

	public override Material[] SharedMaterials
	{
		get
		{
			return m_MeshRenderer.materials;
		}
		set
		{
			m_MeshRenderer.sharedMaterials = value;
			CopyWorldSpaceDataFromMaterial();
		}
	}

	private void CopyWorldSpaceDataFromMaterial()
	{
		Material material = m_MeshRenderer.sharedMaterial;
		if (!(material == null))
		{
			if (material.HasProperty("_WorldData"))
			{
				m_UseWorldSpace = !Mathf.Approximately(material.GetFloat("_WorldData"), 0f);
			}
			else
			{
				m_UseWorldSpace = false;
			}
		}
	}

	public Vector3 GetPosition(int index)
	{
		return m_Positions[index];
	}

	public void SetPosition(int index, Vector3 position)
	{
		m_Positions[index] = position;
		if (NeedsReinitialize())
		{
			Initialize();
			return;
		}
		int num = (index - 1 + m_Positions.Length) % m_Positions.Length;
		int num2 = (index + 1) % m_Positions.Length;
		if (index > 0 || m_Loop)
		{
			m_XRMeshData.SetElementPipe(index * 2 - 1, ref m_Positions[num], ref m_Positions[index]);
		}
		m_XRMeshData.SetElementPosition(index * 2, ref m_Positions[index]);
		if (index < m_Positions.Length - 1 || m_Loop)
		{
			m_XRMeshData.SetElementPipe(index * 2 + 1, ref m_Positions[index], ref m_Positions[num2]);
		}
		m_XRMeshData.SetMeshDataDirty(XRMeshChain.MeshRefreshFlag.Positions);
		m_MeshNeedsRefreshing = true;
	}

	public int GetPositions(Vector3[] positions)
	{
		if (m_Positions != null)
		{
			m_Positions.CopyTo(positions, 0);
			return m_Positions.Length;
		}
		return 0;
	}

	public void SetPositions(Vector3[] newPositions, bool knownSizeChange = false)
	{
		m_Positions = newPositions;
		if (NeedsReinitialize())
		{
			if (!knownSizeChange)
			{
				UnityEngine.Debug.LogWarning("New positions does not match size of existing array.  Adjusting vertex count as well");
			}
			Initialize();
		}
		else if (m_Positions.Length != 0)
		{
			int num = 0;
			int num2 = 0;
			m_XRMeshData.SetElementPosition(num2, ref m_Positions[num]);
			num2++;
			for (num++; num < m_Positions.Length; num++)
			{
				m_XRMeshData.SetElementPipe(num2, ref m_Positions[num - 1], ref m_Positions[num]);
				num2++;
				m_XRMeshData.SetElementPosition(num2, ref m_Positions[num]);
				num2++;
			}
			if (m_Loop)
			{
				m_XRMeshData.SetElementPipe(num2, ref m_Positions[num - 1], ref m_Positions[0]);
			}
			m_XRMeshData.SetMeshDataDirty(XRMeshChain.MeshRefreshFlag.Positions);
			m_MeshNeedsRefreshing = true;
		}
	}

	public void SetVertexCount(int count)
	{
		if (m_Positions.Length != count)
		{
			Vector3[] array = new Vector3[count];
			int num = Mathf.Min(m_Positions.Length, count);
			for (int i = 0; i < num; i++)
			{
				array[i] = m_Positions[i];
			}
			m_Positions = array;
			Initialize();
		}
	}

	public int GetVertexCount()
	{
		return m_Positions.Length;
	}

	protected override void UpdateColors()
	{
		if (NeedsReinitialize())
		{
			Initialize();
		}
		else if (m_Positions.Length != 0)
		{
			int num = 0;
			int num2 = 0;
			float num3 = 0f;
			Color color = m_Color.Evaluate(num3);
			m_XRMeshData.SetElementColor(num2, ref color);
			num2++;
			num++;
			num3 += m_StepSize;
			while (num < m_Positions.Length)
			{
				Color endColor = m_Color.Evaluate(num3);
				m_XRMeshData.SetElementColor(num2, ref color, ref endColor);
				num2++;
				m_XRMeshData.SetElementColor(num2, ref endColor);
				color = endColor;
				num2++;
				num++;
				num3 += m_StepSize;
			}
			if (m_Loop)
			{
				color = m_Color.Evaluate(num3);
				m_XRMeshData.SetElementColor(num2, ref color);
			}
			m_XRMeshData.SetMeshDataDirty(XRMeshChain.MeshRefreshFlag.Colors);
			m_MeshNeedsRefreshing = true;
		}
	}

	protected override void UpdateWidth()
	{
		if (NeedsReinitialize())
		{
			Initialize();
		}
		else if (m_Positions.Length != 0)
		{
			int num = 0;
			int num2 = 0;
			float num3 = 0f;
			float num4 = m_WidthCurve.Evaluate(num3) * m_Width;
			m_XRMeshData.SetElementSize(num2, num4);
			num2++;
			num++;
			num3 += m_StepSize;
			while (num < m_Positions.Length)
			{
				float num5 = m_WidthCurve.Evaluate(num3) * m_Width;
				m_XRMeshData.SetElementSize(num2, num4, num5);
				num2++;
				m_XRMeshData.SetElementSize(num2, num5);
				num4 = num5;
				num2++;
				num++;
				num3 += m_StepSize;
			}
			if (m_Loop)
			{
				float endSize = m_WidthCurve.Evaluate(num3) * m_Width;
				m_XRMeshData.SetElementSize(num2, num4, endSize);
			}
			m_XRMeshData.SetMeshDataDirty(XRMeshChain.MeshRefreshFlag.Sizes);
			m_MeshNeedsRefreshing = true;
		}
	}

	protected override void Initialize()
	{
		base.Initialize();
		CopyWorldSpaceDataFromMaterial();
		if (m_Positions == null)
		{
			m_Positions = new Vector3[0];
		}
		int num = (m_Loop ? 1 : 0);
		num = Mathf.Max(num + m_Positions.Length * 2 - 1, 0);
		if (m_XRMeshData == null)
		{
			m_XRMeshData = new XRMeshChain();
		}
		if (m_XRMeshData.reservedElements != num)
		{
			m_XRMeshData.worldSpaceData = useWorldSpace;
			m_XRMeshData.GenerateMesh(base.gameObject, dynamic: true, num);
		}
		if (num == 0)
		{
			m_StepSize = 1f;
			return;
		}
		m_StepSize = 1f / Mathf.Max(m_Loop ? m_Positions.Length : (m_Positions.Length - 1), 1f);
		int num2 = 0;
		int num3 = 0;
		float num4 = 0f;
		Color color = m_Color.Evaluate(num4);
		float num5 = m_WidthCurve.Evaluate(num4) * m_Width;
		m_XRMeshData.SetElementSize(num3, num5);
		m_XRMeshData.SetElementPosition(num3, ref m_Positions[num2]);
		m_XRMeshData.SetElementColor(num3, ref color);
		num3++;
		num2++;
		num4 += m_StepSize;
		while (num2 < m_Positions.Length)
		{
			float num6 = m_WidthCurve.Evaluate(num4) * m_Width;
			Color endColor = m_Color.Evaluate(num4);
			m_XRMeshData.SetElementSize(num3, num5, num6);
			m_XRMeshData.SetElementPipe(num3, ref m_Positions[num2 - 1], ref m_Positions[num2]);
			m_XRMeshData.SetElementColor(num3, ref color, ref endColor);
			num3++;
			m_XRMeshData.SetElementSize(num3, num6);
			m_XRMeshData.SetElementPosition(num3, ref m_Positions[num2]);
			m_XRMeshData.SetElementColor(num3, ref endColor);
			num5 = num6;
			color = endColor;
			num3++;
			num2++;
			num4 += m_StepSize;
		}
		if (m_Loop)
		{
			float endSize = m_WidthCurve.Evaluate(num4) * m_Width;
			Color endColor2 = m_Color.Evaluate(num4);
			m_XRMeshData.SetElementSize(num3, num5, endSize);
			m_XRMeshData.SetElementPipe(num3, ref m_Positions[num2 - 1], ref m_Positions[0]);
			m_XRMeshData.SetElementColor(num3, ref color, ref endColor2);
		}
		m_XRMeshData.SetMeshDataDirty(XRMeshChain.MeshRefreshFlag.All);
		m_MeshNeedsRefreshing = true;
	}

	protected override bool NeedsReinitialize()
	{
		if (m_XRMeshData == null)
		{
			return true;
		}
		int num = 0;
		if (m_Positions != null)
		{
			num = Mathf.Max(m_Positions.Length * 2 - 1, 0);
			if (m_Loop)
			{
				num++;
			}
		}
		return m_XRMeshData.reservedElements != num;
	}
}
public class XRMeshChain
{
	[Flags]
	public enum MeshRefreshFlag
	{
		None = 0,
		Positions = 1,
		Colors = 2,
		Sizes = 4,
		All = 7
	}

	private Vector3[] m_Verts;

	private Color32[] m_Colors;

	private List<Vector4> m_ShapeData;

	private List<Vector3> m_NeighborPoints;

	private MeshRefreshFlag m_DataThatNeedsUpdate = MeshRefreshFlag.All;

	private Mesh m_Mesh;

	private Transform m_OwnerTransform;

	private bool m_WorldSpaceData;

	public bool worldSpaceData
	{
		get
		{
			return m_WorldSpaceData;
		}
		set
		{
			m_WorldSpaceData = value;
		}
	}

	public int reservedElements { get; private set; }

	public bool centerAtRoot { get; set; }

	public XRMeshChain()
	{
		reservedElements = 0;
	}

	public void GenerateMesh(GameObject owner, bool dynamic, int totalElements)
	{
		if (m_Mesh == null)
		{
			m_Mesh = new Mesh();
		}
		if (dynamic)
		{
			m_Mesh.MarkDynamic();
		}
		owner.GetComponent<MeshFilter>().mesh = m_Mesh;
		m_OwnerTransform = owner.transform;
		reservedElements = totalElements;
		int num = 4 * reservedElements;
		int num2 = 6 * reservedElements;
		m_Verts = new Vector3[num];
		m_Colors = new Color32[num];
		m_ShapeData = new List<Vector4>(num);
		m_NeighborPoints = new List<Vector3>(num);
		int[] array = new int[num2];
		Color32 color = new Color32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
		Vector4 item = new Vector4(0f, 0f, 1f, 1f);
		Vector4 item2 = new Vector4(1f, 0f, 1f, 1f);
		Vector4 item3 = new Vector4(1f, 1f, 1f, 1f);
		Vector4 item4 = new Vector4(0f, 1f, 1f, 1f);
		for (int i = 0; i < reservedElements; i++)
		{
			int num3 = i * 4;
			int num4 = i * 6;
			m_Colors[num3] = color;
			m_Colors[num3 + 1] = color;
			m_Colors[num3 + 2] = color;
			m_Colors[num3 + 3] = color;
			m_ShapeData.Add(item);
			m_ShapeData.Add(item2);
			m_ShapeData.Add(item3);
			m_ShapeData.Add(item4);
			m_NeighborPoints.Add(Vector3.zero);
			m_NeighborPoints.Add(Vector3.zero);
			m_NeighborPoints.Add(Vector3.zero);
			m_NeighborPoints.Add(Vector3.zero);
			array[num4] = num3;
			array[num4 + 1] = num3 + 1;
			array[num4 + 2] = num3 + 2;
			array[num4 + 3] = num3;
			array[num4 + 4] = num3 + 2;
			array[num4 + 5] = num3 + 3;
		}
		m_Mesh.triangles = null;
		m_Mesh.vertices = m_Verts;
		m_Mesh.SetUVs(0, m_ShapeData);
		m_Mesh.SetUVs(1, m_NeighborPoints);
		m_Mesh.triangles = array;
	}

	public void RefreshMesh()
	{
		if ((m_DataThatNeedsUpdate & MeshRefreshFlag.Positions) != 0)
		{
			m_Mesh.vertices = m_Verts;
			m_Mesh.SetUVs(1, m_NeighborPoints);
		}
		if ((m_DataThatNeedsUpdate & MeshRefreshFlag.Colors) != 0)
		{
			m_Mesh.colors32 = m_Colors;
		}
		if ((m_DataThatNeedsUpdate & MeshRefreshFlag.Sizes) != 0)
		{
			m_Mesh.SetUVs(0, m_ShapeData);
		}
		m_DataThatNeedsUpdate = MeshRefreshFlag.None;
		m_Mesh.RecalculateBounds();
		if (m_WorldSpaceData)
		{
			Bounds bounds = m_Mesh.bounds;
			bounds.center = (centerAtRoot ? Vector3.zero : m_OwnerTransform.InverseTransformPoint(bounds.center));
			m_Mesh.bounds = bounds;
		}
	}

	public void SetMeshDataDirty(MeshRefreshFlag dataThatNeedsUpdate)
	{
		m_DataThatNeedsUpdate |= dataThatNeedsUpdate;
	}

	public void SetElementPosition(int elementIndex, ref Vector3 position)
	{
		int num = elementIndex * 4;
		m_Verts[num] = position;
		m_Verts[num + 1] = position;
		m_Verts[num + 2] = position;
		m_Verts[num + 3] = position;
		m_NeighborPoints[num] = position;
		m_NeighborPoints[num + 1] = position;
		m_NeighborPoints[num + 2] = position;
		m_NeighborPoints[num + 3] = position;
	}

	public void SetElementPipe(int elementIndex, ref Vector3 startPoint, ref Vector3 endPoint)
	{
		int num = elementIndex * 4;
		m_Verts[num] = startPoint;
		m_Verts[num + 1] = startPoint;
		m_Verts[num + 2] = endPoint;
		m_Verts[num + 3] = endPoint;
		m_NeighborPoints[num] = endPoint;
		m_NeighborPoints[num + 1] = endPoint;
		m_NeighborPoints[num + 2] = startPoint;
		m_NeighborPoints[num + 3] = startPoint;
	}

	public void SetElementSize(int elementIndex, float sizeModification)
	{
		int num = elementIndex * 4;
		m_ShapeData[num] = new Vector4(0f, 0f, sizeModification, sizeModification);
		m_ShapeData[num + 1] = new Vector4(1f, 0f, sizeModification, sizeModification);
		m_ShapeData[num + 2] = new Vector4(1f, 1f, sizeModification, sizeModification);
		m_ShapeData[num + 3] = new Vector4(0f, 1f, sizeModification, sizeModification);
	}

	public void SetElementSize(int elementIndex, float startSize, float endSize)
	{
		int num = elementIndex * 4;
		m_ShapeData[num] = new Vector4(0f, 0f, startSize, endSize);
		m_ShapeData[num + 1] = new Vector4(1f, 0f, startSize, endSize);
		m_ShapeData[num + 2] = new Vector4(1f, 1f, endSize, startSize);
		m_ShapeData[num + 3] = new Vector4(0f, 1f, endSize, startSize);
	}

	public void SetElementColor(int elementIndex, ref Color color)
	{
		int num = elementIndex * 4;
		m_Colors[num] = color;
		m_Colors[num + 1] = m_Colors[num];
		m_Colors[num + 2] = m_Colors[num];
		m_Colors[num + 3] = m_Colors[num];
	}

	public void SetElementColor32(int elementIndex, ref Color32 color)
	{
		int num = elementIndex * 4;
		m_Colors[num] = color;
		m_Colors[num + 1] = color;
		m_Colors[num + 2] = color;
		m_Colors[num + 3] = color;
	}

	public void SetElementColor(int elementIndex, ref Color startColor, ref Color endColor)
	{
		int num = elementIndex * 4;
		m_Colors[num] = startColor;
		m_Colors[num + 1] = m_Colors[num];
		m_Colors[num + 2] = endColor;
		m_Colors[num + 3] = m_Colors[num + 2];
	}

	public void SetElementColor32(int elementIndex, ref Color32 startColor, ref Color32 endColor)
	{
		int num = elementIndex * 4;
		m_Colors[num] = startColor;
		m_Colors[num + 1] = m_Colors[num];
		m_Colors[num + 2] = endColor;
		m_Colors[num + 3] = m_Colors[num + 2];
	}
}
[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshFilter))]
[ExecuteInEditMode]
public class XRTrailRenderer : MeshChainRenderer
{
	private const float k_AbsoluteMinVertexDistance = 0.01f;

	[SerializeField]
	[UnityEngine.Tooltip("How many points to store for tracing.")]
	private int m_MaxTrailPoints = 20;

	[SerializeField]
	[UnityEngine.Tooltip("Whether to use the last point or the first point of the trail when more are needed and none are available.")]
	private bool m_StealLastPointWhenEmpty = true;

	[SerializeField]
	[UnityEngine.Tooltip("How long the tail should be (second) [ 0, infinity ].")]
	private float m_Time = 5f;

	[SerializeField]
	[UnityEngine.Tooltip("The minimum distance to spawn a new point on the trail [ 0, infinity ].")]
	private float m_MinVertexDistance = 0.1f;

	[SerializeField]
	[UnityEngine.Tooltip("Destroy GameObject when there is no trail?")]
	private bool m_Autodestruct;

	[SerializeField]
	[UnityEngine.Tooltip("With this enabled, the last point will smooth lerp between the last recorded anchor point and the one after it")]
	private bool m_SmoothInterpolation;

	private Vector3[] m_Points;

	private float[] m_PointTimes;

	private int m_PointIndexStart;

	private int m_PointIndexEnd;

	private Vector3 m_LastRecordedPoint = Vector3.zero;

	private float m_LastPointTime;

	private float m_EditorDeltaHelper;

	public float time
	{
		get
		{
			return m_Time;
		}
		set
		{
			m_Time = Mathf.Max(value, 0f);
		}
	}

	public float minVertexDistance
	{
		get
		{
			return m_MinVertexDistance;
		}
		set
		{
			m_MinVertexDistance = Mathf.Max(value, 0.01f);
		}
	}

	public int positionCount { get; private set; }

	public bool autodestruct
	{
		get
		{
			return m_Autodestruct;
		}
		set
		{
			m_Autodestruct = value;
		}
	}

	public bool smoothInterpolation
	{
		get
		{
			return m_SmoothInterpolation;
		}
		set
		{
			m_SmoothInterpolation = value;
		}
	}

	protected override void LateUpdate()
	{
		float num = Time.deltaTime;
		if (!UnityEngine.Application.isPlaying)
		{
			num = Time.realtimeSinceStartup - m_EditorDeltaHelper;
			m_EditorDeltaHelper = Time.realtimeSinceStartup;
		}
		Vector3 position = base.transform.position;
		float sqrMagnitude = (position - m_LastRecordedPoint).sqrMagnitude;
		bool flag = false;
		if (sqrMagnitude > m_MinVertexDistance * m_MinVertexDistance)
		{
			if (m_PointIndexStart == m_PointIndexEnd)
			{
				m_Points[m_PointIndexStart] = m_LastRecordedPoint;
				m_PointTimes[m_PointIndexStart] = m_Time;
			}
			int num2 = (m_PointIndexEnd + 1) % m_MaxTrailPoints;
			if (num2 != m_PointIndexStart)
			{
				m_PointIndexEnd = num2;
				m_PointTimes[m_PointIndexEnd] = 0f;
				positionCount++;
			}
			else if (m_StealLastPointWhenEmpty)
			{
				m_XRMeshData.SetElementSize(m_PointIndexStart * 2, 0f);
				m_XRMeshData.SetElementSize(m_PointIndexStart * 2 + 1, 0f);
				m_PointIndexStart = (m_PointIndexStart + 1) % m_MaxTrailPoints;
				m_PointIndexEnd = num2;
				m_PointTimes[m_PointIndexEnd] = 0f;
				m_LastPointTime = m_PointTimes[m_PointIndexStart];
			}
			m_Points[m_PointIndexEnd] = position;
			m_LastRecordedPoint = position;
		}
		m_PointTimes[m_PointIndexEnd] = Mathf.Min(m_PointTimes[m_PointIndexEnd] + num, m_Time);
		if (m_PointIndexStart != m_PointIndexEnd)
		{
			m_PointTimes[m_PointIndexStart] -= num;
			if (m_PointTimes[m_PointIndexStart] <= 0f)
			{
				m_XRMeshData.SetElementSize(m_PointIndexStart * 2, 0f);
				m_XRMeshData.SetElementSize(m_PointIndexStart * 2 + 1, 0f);
				m_PointIndexStart = (m_PointIndexStart + 1) % m_MaxTrailPoints;
				m_LastPointTime = m_PointTimes[m_PointIndexStart];
				positionCount--;
				flag = true;
			}
		}
		if (m_PointIndexStart != m_PointIndexEnd)
		{
			m_MeshNeedsRefreshing = true;
			m_MeshRenderer.enabled = true;
		}
		else
		{
			m_MeshNeedsRefreshing = false;
			m_MeshRenderer.enabled = false;
			if (m_Autodestruct && UnityEngine.Application.isPlaying && flag)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
		if (m_MeshNeedsRefreshing)
		{
			m_MeshRenderer.enabled = true;
			int num3 = (m_PointIndexStart + 1) % m_MaxTrailPoints;
			if (m_SmoothInterpolation)
			{
				float t = 1f - m_PointTimes[m_PointIndexStart] / m_LastPointTime;
				Vector3 position2 = Vector3.Lerp(m_Points[m_PointIndexStart], m_Points[num3], t);
				m_XRMeshData.SetElementPosition(m_PointIndexStart * 2, ref position2);
				m_XRMeshData.SetElementPipe(m_PointIndexStart * 2 + 1, ref position2, ref m_Points[num3]);
			}
			else
			{
				m_XRMeshData.SetElementPosition(m_PointIndexStart * 2, ref m_Points[m_PointIndexStart]);
				m_XRMeshData.SetElementPipe(m_PointIndexStart * 2 + 1, ref m_Points[m_PointIndexStart], ref m_Points[num3]);
			}
			int num4 = m_PointIndexEnd - 1;
			if (num4 < 0)
			{
				num4 = m_MaxTrailPoints - 1;
			}
			m_XRMeshData.SetElementPipe(num4 * 2 + 1, ref m_Points[num4], ref m_Points[m_PointIndexEnd]);
			m_XRMeshData.SetElementPosition(m_PointIndexEnd * 2, ref m_Points[m_PointIndexEnd]);
			int num5 = m_PointIndexStart;
			int num6 = 0;
			m_StepSize = ((positionCount > 0) ? (1f / (float)positionCount) : 1f);
			float num7 = 0f;
			float num8 = m_WidthCurve.Evaluate(num7) * m_Width;
			Color color = m_Color.Evaluate(num7);
			num7 += m_StepSize;
			while (num5 != m_PointIndexEnd)
			{
				float num9 = m_WidthCurve.Evaluate(num7) * m_Width;
				m_XRMeshData.SetElementSize(num5 * 2, num8);
				m_XRMeshData.SetElementSize(num5 * 2 + 1, num8, num9);
				num8 = num9;
				Color endColor = m_Color.Evaluate(num7);
				m_XRMeshData.SetElementColor(num5 * 2, ref color);
				m_XRMeshData.SetElementColor(num5 * 2 + 1, ref color, ref endColor);
				color = endColor;
				num5 = (num5 + 1) % m_MaxTrailPoints;
				num6++;
				num7 += m_StepSize;
			}
			num8 = m_WidthCurve.Evaluate(1f) * m_Width;
			m_XRMeshData.SetElementSize(m_PointIndexEnd * 2, num8);
			color = m_Color.Evaluate(1f);
			m_XRMeshData.SetElementColor(m_PointIndexEnd * 2, ref color);
			m_XRMeshData.SetMeshDataDirty(XRMeshChain.MeshRefreshFlag.All);
			m_XRMeshData.RefreshMesh();
		}
	}

	public void EditorCheckForUpdate()
	{
		Initialize();
	}

	public void Clear()
	{
		Vector3 position = Vector3.zero;
		Color color = Color.clear;
		int num = 0;
		for (int i = 0; i < m_Points.Length; i++)
		{
			m_XRMeshData.SetElementSize(num, 0f);
			m_XRMeshData.SetElementPosition(num, ref position);
			m_XRMeshData.SetElementColor(num, ref color);
			num++;
			m_XRMeshData.SetElementSize(num, 0f);
			m_XRMeshData.SetElementPipe(num, ref position, ref position);
			m_XRMeshData.SetElementColor(num, ref color);
			num++;
		}
		m_PointIndexStart = 0;
		m_PointIndexEnd = 0;
		positionCount = 0;
		m_LastRecordedPoint = base.transform.position;
	}

	protected override void Initialize()
	{
		base.Initialize();
		m_MaxTrailPoints = Mathf.Max(m_MaxTrailPoints, 3);
		if (m_Points != null && m_MaxTrailPoints == m_Points.Length && m_XRMeshData != null)
		{
			Clear();
			return;
		}
		m_Points = new Vector3[m_MaxTrailPoints];
		m_PointTimes = new float[m_MaxTrailPoints];
		int num = Mathf.Max(m_MaxTrailPoints * 2, 0);
		if (m_XRMeshData == null)
		{
			m_XRMeshData = new XRMeshChain();
		}
		if (m_XRMeshData.reservedElements != num)
		{
			m_XRMeshData.worldSpaceData = true;
			m_XRMeshData.centerAtRoot = true;
			m_XRMeshData.GenerateMesh(base.gameObject, dynamic: true, num);
			if (num == 0)
			{
				return;
			}
			m_MeshRenderer.enabled = false;
			m_XRMeshData.SetMeshDataDirty(XRMeshChain.MeshRefreshFlag.All);
			m_MeshNeedsRefreshing = true;
		}
		Clear();
	}

	protected override bool NeedsReinitialize()
	{
		if (m_XRMeshData == null)
		{
			return true;
		}
		if (m_Points == null || m_MaxTrailPoints != m_Points.Length)
		{
			return true;
		}
		m_MaxTrailPoints = Mathf.Max(m_MaxTrailPoints, 3);
		int num = Mathf.Max(m_MaxTrailPoints * 2, 0);
		return m_XRMeshData.reservedElements != num;
	}

	protected override void OnEnable()
	{
		m_MeshRenderer.enabled = m_PointIndexStart != m_PointIndexEnd;
	}
}
public class SetPhysicsLayersMatrix : MonoBehaviour
{
	private void Awake()
	{
		Physics.IgnoreLayerCollision(2, 2, ignore: true);
	}
}
public class ForwardToMaterialProperty : MonoBehaviour
{
	public Renderer targetRenderer;

	public string propertyName;

	public Transform forwardTransform;

	public bool update = true;

	private void Start()
	{
		UpdateForwardValue();
	}

	private void Update()
	{
		if (update)
		{
			UpdateForwardValue();
		}
	}

	public void UpdateForwardValue()
	{
		if (targetRenderer != null && forwardTransform != null)
		{
			targetRenderer.material.SetVector(propertyName, forwardTransform.forward);
		}
	}
}
public class CameraLookAt : MonoBehaviour
{
	public Transform target;

	private void Start()
	{
	}

	private void Update()
	{
		base.transform.LookAt(target);
	}
}
public class Spider : MonoBehaviour
{
	public Animator spider;

	private IEnumerator coroutine;

	private void Start()
	{
	}

	private void Update()
	{
		if (Input.GetKey(KeyCode.Alpha1))
		{
			spider.SetBool("idle", value: true);
			spider.SetBool("running", value: false);
			spider.SetBool("walking", value: false);
			spider.SetBool("attack", value: false);
			spider.SetBool("jumping", value: false);
		}
		if (Input.GetKey("up"))
		{
			spider.SetBool("running", value: true);
			spider.SetBool("idle", value: false);
			spider.SetBool("walking", value: false);
			spider.SetBool("turnright", value: false);
			spider.SetBool("turnleft", value: false);
		}
		if (Input.GetKey("down"))
		{
			spider.SetBool("running", value: false);
			spider.SetBool("walking", value: true);
			spider.SetBool("idle", value: false);
			spider.SetBool("turnleft", value: false);
			spider.SetBool("turnright", value: false);
		}
		if (Input.GetKey(KeyCode.Alpha2))
		{
			spider.SetBool("attack", value: true);
			spider.SetBool("walking", value: false);
			spider.SetBool("idle", value: false);
			spider.SetBool("running", value: false);
			StartCoroutine("idle");
			idle();
		}
		if (Input.GetKey(KeyCode.Alpha3))
		{
			spider.SetBool("attack2", value: true);
			spider.SetBool("attack", value: false);
			spider.SetBool("idle", value: false);
			spider.SetBool("running", value: false);
			StartCoroutine("idle2");
			idle2();
		}
		if (Input.GetKey(KeyCode.Space))
		{
			spider.SetBool("idle", value: false);
			spider.SetBool("jumping", value: true);
		}
		if (Input.GetKey(KeyCode.Alpha5))
		{
			spider.SetBool("idle", value: false);
			spider.SetBool("hited", value: true);
			StartCoroutine("idle");
			idle();
		}
		if (Input.GetKey(KeyCode.Alpha6))
		{
			spider.SetBool("idle", value: false);
			spider.SetBool("died", value: true);
		}
		if (Input.GetKey("left"))
		{
			spider.SetBool("turnleft", value: true);
			spider.SetBool("walking", value: false);
			spider.SetBool("turnright", value: false);
			spider.SetBool("idle", value: false);
			spider.SetBool("running", value: false);
			StartCoroutine("idle2");
			idle2();
		}
		if (Input.GetKey("right"))
		{
			spider.SetBool("turnright", value: true);
			spider.SetBool("walking", value: false);
			spider.SetBool("turnleft", value: false);
			spider.SetBool("idle", value: false);
			spider.SetBool("running", value: false);
			StartCoroutine("idle2");
			idle2();
		}
	}

	private IEnumerator idle()
	{
		yield return new WaitForSeconds(0.35f);
		spider.SetBool("attack", value: false);
		spider.SetBool("attack2", value: false);
		spider.SetBool("idle", value: true);
		spider.SetBool("hited", value: false);
	}

	private IEnumerator idle2()
	{
		yield return new WaitForSeconds(1f);
		spider.SetBool("attack", value: false);
		spider.SetBool("attack2", value: false);
		spider.SetBool("idle", value: true);
		spider.SetBool("turnleft", value: false);
		spider.SetBool("turnright", value: false);
	}
}
public class Rotator : MonoBehaviour
{
	public float rotateSpeed = 5f;

	private void Update()
	{
		base.transform.Rotate(new Vector3(0f, rotateSpeed * Time.deltaTime, 0f));
	}
}
public class CameraManager : MonoBehaviour
{
	public Transform _lookatTarget;

	public Transform _cameraToControl;

	public float _radius = 256f;

	public float _minRadius = 10f;

	public float _maxRadius = 32f;

	public float _elevation;

	public float _minElevation;

	public float _maxElevation = 30f;

	public float xRotSpeed = 1f;

	public float yRotSpeed = 1f;

	public float translateSpeed = 0.75f;

	public float wheelSpeed = 1f;

	public int yMinLimit = -20;

	public int yMaxLimit = 80;

	public float _rotX = -50f;

	public float _rotY = 20.8f;

	private void Start()
	{
		RefreshCamera();
	}

	private void Update()
	{
		UpdateCamera();
	}

	public void UpdateCamera()
	{
		bool mouseButton = Input.GetMouseButton(0);
		bool radiusFlag = Input.GetMouseButton(1) || (mouseButton && (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift)));
		bool panFlag = Input.GetMouseButton(2) || (mouseButton && (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)));
		UpdateCameraControls(mouseButton, radiusFlag, panFlag, Input.GetAxis("Mouse ScrollWheel") != 0f);
	}

	public void UpdateCameraControls(bool orbitFlag, bool radiusFlag, bool panFlag, bool wheelFlag)
	{
		if (radiusFlag)
		{
			AdjustCameraRadius(Input.GetAxis("Mouse Y") * xRotSpeed * Time.smoothDeltaTime * 80f);
		}
		else if (wheelFlag)
		{
			AdjustCameraRadius(Input.GetAxis("Mouse ScrollWheel") * wheelSpeed);
		}
		else if (panFlag)
		{
			Vector3 direction = new Vector3(0f - Input.GetAxis("Mouse X"), 0f - Input.GetAxis("Mouse Y"), 0f);
			direction = _cameraToControl.TransformDirection(direction);
			direction.Normalize();
			_lookatTarget.Translate(direction * translateSpeed);
		}
		else if (orbitFlag)
		{
			_rotX += Input.GetAxis("Mouse X") * xRotSpeed;
			_rotY -= Input.GetAxis("Mouse Y") * yRotSpeed;
			if (_rotX < -360f)
			{
				_rotX += 360f;
			}
			if (_rotX > 360f)
			{
				_rotX -= 360f;
			}
			_rotY = wrapAngle(_rotY, yMinLimit, yMaxLimit);
		}
		if (orbitFlag || panFlag || radiusFlag || wheelFlag)
		{
			RefreshCamera();
		}
	}

	public void RefreshCamera()
	{
		Vector3 vector = new Vector3(0f, 0f, 0f - _radius);
		Quaternion quaternion = Quaternion.Euler(_rotY, _rotX, 0f);
		Vector3 localPosition = quaternion * vector + _lookatTarget.position;
		_cameraToControl.localRotation = quaternion;
		_cameraToControl.localPosition = localPosition;
	}

	public void Camera_OrbitMovement(bool useAxisX)
	{
		if (useAxisX)
		{
			_rotX += Input.GetAxis("Mouse X") * xRotSpeed;
			if (_rotX < -360f)
			{
				_rotX += 360f;
			}
			if (_rotX > 360f)
			{
				_rotX -= 360f;
			}
		}
		_rotY -= Input.GetAxis("Mouse Y") * yRotSpeed;
		_rotY = wrapAngle(_rotY, yMinLimit, yMaxLimit);
		RefreshCamera();
	}

	private void AdjustCameraRadius(float amount)
	{
		_radius = Mathf.Clamp(_radius - amount, _minRadius, _maxRadius);
	}

	public void SetCameraRadiusByValue(float offset)
	{
		_radius = Mathf.Clamp(offset, _minRadius, _maxRadius);
		RefreshCamera();
	}

	public void SetCameraRadiusByRatio(float ratio)
	{
		_radius = _minRadius + (_maxRadius - _minRadius) * ratio;
		RefreshCamera();
	}

	public float GetCameraRadiusByRatio()
	{
		return (_radius - _minRadius) / (_maxRadius - _minRadius);
	}

	private float wrapAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}
}
public class CanvasMenuSupport : MonoBehaviour
{
	public Material _glassWallMaterial;

	public Text _stencilSupportTextComponent;

	public Text _warningTextComponent;

	private PortalContentCulling[] _portalContentCulling;

	private GameObject[] _glassWalls;

	private GameObject[] _depthMaskCubes;

	private void Start()
	{
		_glassWalls = GameObject.FindGameObjectsWithTag("GlassWalls");
		_depthMaskCubes = GameObject.FindGameObjectsWithTag("DepthMaskCubes");
		_portalContentCulling = UnityEngine.Object.FindObjectsOfType<PortalContentCulling>();
		_stencilSupportTextComponent.text = $"Stencil Support: {true}\n3D API: {SystemInfo.graphicsDeviceType.ToString()}";
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}

	public void Toggle_ImageEffect(bool val)
	{
		_warningTextComponent.gameObject.SetActive(value: false);
	}

	public void Toggle_PortalContentCulling()
	{
		PortalContentCulling[] portalContentCulling = _portalContentCulling;
		foreach (PortalContentCulling obj in portalContentCulling)
		{
			obj.enabled = !obj.enabled;
		}
	}

	public void Toggle_DepthMaskCubes()
	{
		GameObject[] depthMaskCubes = _depthMaskCubes;
		foreach (GameObject obj in depthMaskCubes)
		{
			obj.SetActive(!obj.activeSelf);
		}
	}

	public void Toggle_Glass()
	{
		GameObject[] glassWalls = _glassWalls;
		foreach (GameObject obj in glassWalls)
		{
			obj.SetActive(!obj.activeSelf);
		}
	}

	public void Set_GlassWallStrength(float val)
	{
		_glassWallMaterial.SetFloat("_BumpAmt", val);
	}
}
public class ClothControl : MonoBehaviour
{
	private void OnEnable()
	{
		GetComponent<Cloth>().enabled = false;
		GetComponent<Cloth>().enabled = true;
	}

	private void OnDisable()
	{
		GetComponent<Cloth>().enabled = false;
	}
}
public class PortalContentCulling : MonoBehaviour
{
	public GameObject _portalGroupForRoom;

	private void Start()
	{
	}

	private void OnDisable()
	{
		_portalGroupForRoom.SetActive(value: true);
	}

	private void Update()
	{
		Vector3 rhs = base.transform.position - Camera.main.transform.position;
		float num = Vector3.Dot(base.transform.forward, rhs);
		if (_portalGroupForRoom.activeInHierarchy != num > 0f)
		{
			_portalGroupForRoom.SetActive(num > 0f);
		}
	}
}
public class PortalMaterialControl : MonoBehaviour
{
	[Range(0f, 255f)]
	public int m_StencilReferenceID = 1;

	private void SetUpPropertyBlocks()
	{
		MaterialPropertyBlock materialPropertyBlock = new MaterialPropertyBlock();
		materialPropertyBlock.Clear();
		materialPropertyBlock.SetFloat("_StencilReferenceID", m_StencilReferenceID);
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].SetPropertyBlock(materialPropertyBlock);
		}
	}

	private void OnEnable()
	{
		SetUpPropertyBlocks();
	}

	private void OnValidate()
	{
		SetUpPropertyBlocks();
	}
}
public class UI_FrameRateMonitor : MonoBehaviour
{
	public float m_UpdateFrequency = 1f;

	private float m_FramerateMin = 65535f;

	private float m_FramerateMax;

	private float m_FramerateAvg;

	private float m_Accumelated;

	private int m_AccumelatedCount;

	private float m_NextTime = 1f;

	private string m_DisplayFormatStr = " Now: {0:F2}  Min: {1:F2}  Max: {2:F2}  Avg: {3:F2}  Delta: {4:F4} / {5:F2}   Time: {6:F2}";

	private Text m_TextComponent;

	private void Awake()
	{
		m_TextComponent = GetComponent<Text>();
	}

	private void OnEnable()
	{
		Reset();
		StartCoroutine(FrameUpdate());
	}

	private void OnDisable()
	{
		StopAllCoroutines();
	}

	private IEnumerator FrameUpdate()
	{
		yield return null;
		m_NextTime = Time.realtimeSinceStartup + m_UpdateFrequency;
		while (true)
		{
			float deltaTime = Time.deltaTime;
			m_Accumelated += deltaTime;
			m_AccumelatedCount++;
			if (deltaTime < m_FramerateMax)
			{
				m_FramerateMax = deltaTime;
			}
			if (deltaTime > m_FramerateMin)
			{
				m_FramerateMin = deltaTime;
			}
			if (Time.realtimeSinceStartup > m_NextTime)
			{
				m_FramerateAvg = 1f / (m_Accumelated / (float)m_AccumelatedCount);
				m_TextComponent.text = string.Format(m_DisplayFormatStr, 1f / deltaTime, 1f / m_FramerateMin, 1f / m_FramerateMax, m_FramerateAvg, Time.deltaTime, 1f / Time.deltaTime, Time.realtimeSinceStartup);
				m_Accumelated = 0f;
				m_AccumelatedCount = 0;
				m_FramerateMin = 0f;
				m_FramerateMax = 65536f;
				yield return null;
				yield return null;
				m_NextTime = Time.realtimeSinceStartup + m_UpdateFrequency;
			}
			yield return null;
		}
	}

	private void Reset()
	{
		m_FramerateMin = 0f;
		m_FramerateMax = 65536f;
		m_FramerateAvg = 0f;
		m_Accumelated = 0f;
		m_AccumelatedCount = 0;
		m_TextComponent.text = " Resetting fps ...";
		m_NextTime = Time.realtimeSinceStartup + m_UpdateFrequency;
	}
}
public class Wormhole : MonoBehaviour
{
	public float tunnelTextureTwist = -0.1f;

	public float tunnelTextureSpeed = -1f;

	public float tunnelMeshAnimSpeed = 1f;

	public GameObject tunnel;

	private Renderer _myRenderer;

	private bool scroll = true;

	private void Start()
	{
		_myRenderer = GetComponent<Renderer>();
		if (_myRenderer == null)
		{
			base.enabled = false;
		}
		tunnel.GetComponent<Animator>().speed = tunnelMeshAnimSpeed;
	}

	public void FixedUpdate()
	{
		if (scroll)
		{
			float y = Time.time * tunnelTextureSpeed;
			float x = Time.time * tunnelTextureTwist;
			_myRenderer.material.mainTextureOffset = new Vector2(x, y);
		}
	}

	public void DoActivateTrigger()
	{
		scroll = !scroll;
	}
}
[ExecuteInEditMode]
public class statsbar : MonoBehaviour
{
	public RectTransform powerrect;

	public RectTransform shieldrect;

	public RectTransform health0rect;

	public RectTransform health1rect;

	public float power;

	public float shield;

	public float health;

	private void Update()
	{
		power = Mathf.Clamp01(power);
		shield = Mathf.Clamp01(shield);
		health = Mathf.Clamp01(health);
		powerrect.localRotation = Quaternion.AngleAxis(130f * (1f - power), Vector3.forward);
		shieldrect.localRotation = Quaternion.AngleAxis(130f * (1f - shield), Vector3.forward);
		health0rect.localRotation = Quaternion.AngleAxis(122f * (1f - health), Vector3.forward);
		health1rect.localRotation = Quaternion.AngleAxis(95f * (1f - health), Vector3.forward);
	}
}
namespace VacuumShaders.CurvedWorld.Example
{
	public class RotateAround : MonoBehaviour
	{
		public Vector3 eular;

		private void Start()
		{
		}

		private void Update()
		{
			base.transform.Rotate(eular * Time.deltaTime);
		}
	}
}
namespace NoiseCrime.StencilPortals
{
	[ExecuteInEditMode]
	public class StencilViewer : MonoBehaviour
	{
		public enum StencilViewerMode
		{
			StencilColors,
			StencilTable
		}

		public StencilViewerMode _stencilViewerMode;

		public int _maxStencilID = 4;

		public Color[] _colours;

		public Texture2D _stencilTable;

		public Shader _stencilViewerColor;

		public Shader _stencilViewerTable;

		private void Start()
		{
		}

		private void OnPostRender()
		{
			if (_stencilViewerMode == StencilViewerMode.StencilColors)
			{
				RenderViaStencilColors();
			}
			else
			{
				RenderViaStencilTable();
			}
		}

		private void RenderViaStencilColors()
		{
			int num = Mathf.Min(_maxStencilID, _colours.Length);
			Material material = new Material(_stencilViewerColor);
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < num; i++)
			{
				material.SetColor("_Color", _colours[i]);
				material.SetFloat("_StencilReferenceID", i);
				material.SetPass(0);
				GL.Begin(7);
				GL.TexCoord2(0f, 0f);
				GL.Vertex3(0f, 0f, 0f);
				GL.TexCoord2(0f, 1f);
				GL.Vertex3(0f, 1f, 0f);
				GL.TexCoord2(1f, 1f);
				GL.Vertex3(1f, 1f, 0f);
				GL.TexCoord2(1f, 0f);
				GL.Vertex3(1f, 0f, 0f);
				GL.End();
			}
			GL.PopMatrix();
			if (null != material)
			{
				UnityEngine.Object.DestroyImmediate(material);
			}
		}

		private void RenderViaStencilTable()
		{
			Material material = new Material(_stencilViewerTable);
			material.SetTexture("_StencilTable", _stencilTable);
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < _maxStencilID; i++)
			{
				material.SetFloat("_StencilReferenceID", i);
				material.SetPass(0);
				GL.Begin(7);
				GL.TexCoord2(0f, 0f);
				GL.Vertex3(0f, 0f, 0f);
				GL.TexCoord2(0f, 1f);
				GL.Vertex3(0f, 1f, 0f);
				GL.TexCoord2(1f, 1f);
				GL.Vertex3(1f, 1f, 0f);
				GL.TexCoord2(1f, 0f);
				GL.Vertex3(1f, 0f, 0f);
				GL.End();
			}
			GL.PopMatrix();
			if (null != material)
			{
				UnityEngine.Object.DestroyImmediate(material);
			}
		}
	}
}
namespace UnityEngine.Rendering
{
	[Flags]
	public enum Shader_ColorWriteMask
	{
		None = 0,
		Alpha = 1,
		Blue = 2,
		Green = 4,
		Red = 8,
		All = 0xF
	}
}
namespace SensorToolkit
{
	[RequireComponent(typeof(MeshCollider))]
	[ExecuteInEditMode]
	public class FOVCollider : MonoBehaviour
	{
		[UnityEngine.Tooltip("The length of the field of view cone in world units.")]
		public float Length = 5f;

		[UnityEngine.Tooltip("The size of the field of view cones base in world units.")]
		public float BaseSize = 0.5f;

		[Range(1f, 180f)]
		[UnityEngine.Tooltip("The arc angle of the fov cone.")]
		public float FOVAngle = 90f;

		[Range(1f, 180f)]
		[UnityEngine.Tooltip("The elevation angle of the cone.")]
		public float ElevationAngle = 90f;

		[Range(0f, 8f)]
		[UnityEngine.Tooltip("The number of vertices used to approximate the arc of the fov cone. Ideally this should be as low as possible.")]
		public int Resolution;

		private Mesh mesh;

		private MeshCollider mc;

		private Vector3[] pts;

		private int[] triangles;

		public Mesh FOVMesh => mesh;

		private void Awake()
		{
			mc = GetComponent<MeshCollider>();
			CreateCollider();
		}

		private void OnValidate()
		{
			Length = Mathf.Max(0f, Length);
			BaseSize = Mathf.Max(0f, BaseSize);
			if (mc != null)
			{
				CreateCollider();
			}
		}

		public void CreateCollider()
		{
			pts = new Vector3[4 + (2 + Resolution) * (2 + Resolution)];
			int num = 6;
			int num2 = (Resolution + 1) * (Resolution + 1) * 2 * 3;
			int num3 = (Resolution + 2) * 3;
			triangles = new int[num + num2 + num3 * 4];
			pts[0] = new Vector3((0f - BaseSize) / 2f, (0f - BaseSize) / 2f, 0f);
			pts[1] = new Vector3(BaseSize / 2f, (0f - BaseSize) / 2f, 0f);
			pts[2] = new Vector3(BaseSize / 2f, BaseSize / 2f, 0f);
			pts[3] = new Vector3((0f - BaseSize) / 2f, BaseSize / 2f, 0f);
			triangles[0] = 2;
			triangles[1] = 1;
			triangles[2] = 0;
			triangles[3] = 3;
			triangles[4] = 2;
			triangles[5] = 0;
			for (int i = 0; i < 2 + Resolution; i++)
			{
				for (int j = 0; j < 2 + Resolution; j++)
				{
					int num4 = 4 + i * (2 + Resolution) + j;
					float y = Mathf.Lerp((0f - FOVAngle) / 2f, FOVAngle / 2f, (float)j / (float)(Resolution + 1));
					Vector3 vector = Quaternion.Euler(Mathf.Lerp((0f - ElevationAngle) / 2f, ElevationAngle / 2f, (float)i / (float)(Resolution + 1)), y, 0f) * Vector3.forward * Length;
					pts[num4] = vector;
					if (j < 1 + Resolution && i < 1 + Resolution)
					{
						int num5 = num + (i * (Resolution + 1) + j) * 3 * 2;
						triangles[num5] = num4 + 1 + (2 + Resolution);
						triangles[num5 + 1] = num4 + 1;
						triangles[num5 + 2] = num4;
						triangles[num5 + 3] = num4 + (2 + Resolution);
						triangles[num5 + 4] = num4 + (2 + Resolution) + 1;
						triangles[num5 + 5] = num4;
					}
				}
			}
			for (int k = 0; k < 2 + Resolution; k++)
			{
				int num6 = 4 + k;
				int num7 = 4 + (1 + Resolution) * (2 + Resolution) + k;
				int num8 = num + num2 + k * 3;
				int num9 = num8 + num3;
				if (k == 0)
				{
					triangles[num8] = 2;
					triangles[num8 + 1] = 3;
					triangles[num8 + 2] = num6;
					triangles[num9] = 0;
					triangles[num9 + 1] = 1;
					triangles[num9 + 2] = num7;
				}
				else
				{
					triangles[num8] = num6;
					triangles[num8 + 1] = 2;
					triangles[num8 + 2] = num6 - 1;
					triangles[num9] = 1;
					triangles[num9 + 1] = num7;
					triangles[num9 + 2] = num7 - 1;
				}
			}
			int num10 = 2 + Resolution;
			for (int l = 0; l < 2 + Resolution; l++)
			{
				int num11 = 4 + l * (2 + Resolution);
				int num12 = num11 + (1 + Resolution);
				int num13 = num + num2 + num3 * 2 + l * 3;
				int num14 = num13 + num3;
				if (l == 0)
				{
					triangles[num13] = 3;
					triangles[num13 + 1] = 0;
					triangles[num13 + 2] = num11;
					triangles[num14] = 1;
					triangles[num14 + 1] = 2;
					triangles[num14 + 2] = num12;
				}
				else
				{
					triangles[num13] = 0;
					triangles[num13 + 1] = num11;
					triangles[num13 + 2] = num11 - num10;
					triangles[num14] = num12;
					triangles[num14 + 1] = 1;
					triangles[num14 + 2] = num12 - num10;
				}
			}
			releaseMesh();
			mesh = new Mesh();
			mc.sharedMesh = mesh;
			mesh.vertices = pts;
			mesh.triangles = triangles;
			mesh.name = "FOVColliderPoints";
			mc.convex = true;
			mc.isTrigger = true;
		}

		private void releaseMesh()
		{
			if (mc.sharedMesh != null && mc.sharedMesh == mesh)
			{
				UnityEngine.Object.DestroyImmediate(mc.sharedMesh, allowDestroyingAssets: true);
			}
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.green;
			Vector3[] array = pts;
			foreach (Vector3 position in array)
			{
				Gizmos.DrawSphere(base.transform.TransformPoint(position), 0.1f);
			}
		}
	}
	[RequireComponent(typeof(PolygonCollider2D))]
	[ExecuteInEditMode]
	public class FOVCollider2D : MonoBehaviour
	{
		[UnityEngine.Tooltip("The length of the field of view cone in world units.")]
		public float Length = 5f;

		[UnityEngine.Tooltip("The size of the field of view cones base in world units.")]
		public float BaseSize = 0.5f;

		[Range(1f, 360f)]
		[UnityEngine.Tooltip("The arc angle of the fov cone.")]
		public float FOVAngle = 90f;

		[Range(0f, 16f)]
		[UnityEngine.Tooltip("The number of vertices used to approximate the arc of the fov cone. Ideally this should be as low as possible.")]
		public int Resolution;

		private PolygonCollider2D pc;

		private Vector2[] pts;

		private Mesh mesh;

		public Mesh FOVMesh => mesh;

		private void Awake()
		{
			pc = GetComponent<PolygonCollider2D>();
			CreateCollider();
		}

		private void OnValidate()
		{
			Length = Mathf.Max(0f, Length);
			BaseSize = Mathf.Max(0f, BaseSize);
			if (pc != null)
			{
				CreateCollider();
			}
		}

		public void CreateCollider()
		{
			pts = new Vector2[4 + Resolution];
			pts[0] = new Vector3((0f - BaseSize) / 2f, 0f);
			pts[1] = new Vector3(BaseSize / 2f, 0f);
			for (int i = 0; i <= 1 + Resolution; i++)
			{
				Vector2 vector = Quaternion.AngleAxis((0f - FOVAngle) / 2f + FOVAngle * ((float)i / (float)(1 + Resolution)), Vector3.forward) * (Vector2.up * Length);
				pts[i + 2] = vector;
			}
			pc.points = pts;
			Vector3[] array = new Vector3[4 + Resolution];
			for (int j = 0; j < array.Length; j++)
			{
				array[j] = pts[j];
			}
			int[] array2 = new int[(2 + Resolution) * 3];
			for (int k = 0; k < 2 + Resolution; k++)
			{
				int num = k * 3;
				if (k == 0)
				{
					array2[num] = 1;
					array2[num + 1] = 0;
					array2[num + 2] = 2;
				}
				else
				{
					array2[num] = k + 1;
					array2[num + 1] = 0;
					array2[num + 2] = k + 2;
				}
			}
			mesh = new Mesh();
			mesh.vertices = array;
			mesh.triangles = array2;
			mesh.name = "FOV2DColliderPoints";
		}

		private void OnDrawGizmosSelected()
		{
			Gizmos.color = Color.green;
			Vector2[] array = pts;
			foreach (Vector3 position in array)
			{
				Gizmos.DrawSphere(base.transform.TransformPoint(position), 0.1f);
			}
		}
	}
	public class LOSTargets : MonoBehaviour
	{
		public Transform[] Targets;

		protected static readonly Color GizmoColor = new Color(0.2f, 1f, 1f);

		public virtual void OnDrawGizmosSelected()
		{
			if (Targets == null)
			{
				return;
			}
			Gizmos.color = GizmoColor;
			Transform[] targets = Targets;
			foreach (Transform transform in targets)
			{
				if (transform == null)
				{
					break;
				}
				Gizmos.DrawCube(transform.position, Vector3.one * 0.1f);
			}
		}
	}
	[ExecuteInEditMode]
	public class RangeSensor : BaseVolumeSensor
	{
		public enum UpdateMode
		{
			FixedInterval,
			Manual
		}

		public delegate void SensorUpdateHandler();

		[UnityEngine.Tooltip("The radius in world units that the sensor detects colliders in.")]
		public float SensorRange = 10f;

		[UnityEngine.Tooltip("The physics layer mask that the sensor detects colliders on.")]
		public LayerMask DetectsOnLayers;

		[UnityEngine.Tooltip("Automatic or manually pulsing mode.")]
		public UpdateMode SensorUpdateMode;

		[UnityEngine.Tooltip("If the chosen update mode is automatic then this is the interval in seconds between each automatic pulse.")]
		public float CheckInterval = 1f;

		[UnityEngine.Tooltip("The initial size of the buffer used when calling Physics.OverlapSphereNoAlloc.")]
		public int InitialBufferSize = 20;

		[UnityEngine.Tooltip("When set true the buffer used with Physics.OverlapSphereNoAlloc is expanded if its not sufficiently large.")]
		public bool DynamicallyIncreaseBufferSize = true;

		private HashSet<GameObject> previousDetectedObjects = new HashSet<GameObject>();

		private Collider[] collidersBuffer;

		private float timer;

		public int CurrentBufferSize { get; private set; }

		public event SensorUpdateHandler OnSensorUpdate;

		public override void Pulse()
		{
			if (base.isActiveAndEnabled)
			{
				testSensor();
			}
		}

		protected override void Awake()
		{
			base.Awake();
			CurrentBufferSize = 0;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			previousDetectedObjects.Clear();
		}

		private void Update()
		{
			if (!UnityEngine.Application.isPlaying)
			{
				return;
			}
			if (SensorUpdateMode == UpdateMode.FixedInterval)
			{
				timer += Time.deltaTime;
				if (timer >= CheckInterval)
				{
					testSensor();
					timer = 0f;
				}
			}
			else
			{
				timer = 0f;
			}
		}

		private void testSensor()
		{
			prepareCollidersBuffer();
			int num = Physics.OverlapSphereNonAlloc(base.transform.position, SensorRange, collidersBuffer, DetectsOnLayers);
			if (num == CurrentBufferSize)
			{
				if (DynamicallyIncreaseBufferSize)
				{
					CurrentBufferSize *= 2;
					testSensor();
					return;
				}
				logInsufficientBufferSize();
			}
			clearColliders();
			for (int i = 0; i < num; i++)
			{
				GameObject gameObject = addCollider(collidersBuffer[i]);
				if (gameObject != null)
				{
					if (previousDetectedObjects.Contains(gameObject))
					{
						previousDetectedObjects.Remove(gameObject);
					}
					else
					{
						OnDetected.Invoke(gameObject, this);
					}
				}
			}
			HashSet<GameObject>.Enumerator enumerator = previousDetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				OnLostDetection.Invoke(current, this);
			}
			previousDetectedObjects.Clear();
			List<GameObject>.Enumerator enumerator2 = DetectedObjects.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				previousDetectedObjects.Add(enumerator2.Current);
			}
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void logInsufficientBufferSize()
		{
			UnityEngine.Debug.LogWarning("A range sensor on " + base.name + " has an insufficient buffer size. Some objects may not be detected");
		}

		private void prepareCollidersBuffer()
		{
			if (CurrentBufferSize == 0)
			{
				InitialBufferSize = Math.Max(1, InitialBufferSize);
				CurrentBufferSize = InitialBufferSize;
			}
			if (collidersBuffer == null || collidersBuffer.Length != CurrentBufferSize)
			{
				collidersBuffer = new Collider[CurrentBufferSize];
			}
		}

		private void reset()
		{
			clearColliders();
			CurrentBufferSize = 0;
		}

		public override void OnDrawGizmosSelected()
		{
			base.OnDrawGizmosSelected();
			if (base.isActiveAndEnabled)
			{
				Gizmos.color = BaseVolumeSensor.GizmoColor;
				Gizmos.DrawWireSphere(base.transform.position, SensorRange);
			}
		}
	}
	[ExecuteInEditMode]
	public class RangeSensor2D : BaseAreaSensor
	{
		public enum UpdateMode
		{
			FixedInterval,
			Manual
		}

		public delegate void SensorUpdateHandler();

		[UnityEngine.Tooltip("The radius in world units that the sensor detects colliders in.")]
		public float SensorRange = 10f;

		[UnityEngine.Tooltip("The physics layer mask that the sensor detects colliders on.")]
		public LayerMask DetectsOnLayers;

		[UnityEngine.Tooltip("Automatic or manually pulsing mode.")]
		public UpdateMode SensorUpdateMode;

		[UnityEngine.Tooltip("If the chosen update mode is automatic then this is the interval in seconds between each automatic pulse.")]
		public float CheckInterval = 1f;

		[UnityEngine.Tooltip("The initial size of the buffer used when calling Physics.OverlapSphereNoAlloc.")]
		public int InitialBufferSize = 20;

		[UnityEngine.Tooltip("When set true the buffer used with Physics.OverlapSphereNoAlloc is expanded if its not sufficiently large.")]
		public bool DynamicallyIncreaseBufferSize = true;

		private HashSet<GameObject> previousDetectedObjects = new HashSet<GameObject>();

		private Collider2D[] collidersBuffer;

		private float timer;

		public int CurrentBufferSize { get; private set; }

		public event SensorUpdateHandler OnSensorUpdate;

		public override void Pulse()
		{
			if (base.isActiveAndEnabled)
			{
				testSensor();
			}
		}

		protected override void Awake()
		{
			base.Awake();
			CurrentBufferSize = 0;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			previousDetectedObjects.Clear();
		}

		private void Update()
		{
			if (!UnityEngine.Application.isPlaying)
			{
				return;
			}
			if (SensorUpdateMode == UpdateMode.FixedInterval)
			{
				timer += Time.deltaTime;
				if (timer >= CheckInterval)
				{
					testSensor();
					timer = 0f;
				}
			}
			else
			{
				timer = 0f;
			}
		}

		private void testSensor()
		{
			prepareCollidersBuffer();
			int num = Physics2D.OverlapCircleNonAlloc(base.transform.position, SensorRange, collidersBuffer, DetectsOnLayers);
			if (num == CurrentBufferSize)
			{
				if (DynamicallyIncreaseBufferSize)
				{
					CurrentBufferSize *= 2;
					testSensor();
					return;
				}
				logInsufficientBufferSize();
			}
			clearColliders();
			for (int i = 0; i < num; i++)
			{
				GameObject gameObject = addCollider(collidersBuffer[i]);
				if (gameObject != null)
				{
					if (previousDetectedObjects.Contains(gameObject))
					{
						previousDetectedObjects.Remove(gameObject);
					}
					else
					{
						OnDetected.Invoke(gameObject, this);
					}
				}
			}
			HashSet<GameObject>.Enumerator enumerator = previousDetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				OnLostDetection.Invoke(current, this);
			}
			previousDetectedObjects.Clear();
			List<GameObject>.Enumerator enumerator2 = DetectedObjects.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				previousDetectedObjects.Add(enumerator2.Current);
			}
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void logInsufficientBufferSize()
		{
			UnityEngine.Debug.LogWarning("A range sensor on " + base.name + " has an insufficient buffer size. Some objects may not be detected");
		}

		private void prepareCollidersBuffer()
		{
			if (CurrentBufferSize == 0)
			{
				InitialBufferSize = Math.Max(1, InitialBufferSize);
				CurrentBufferSize = InitialBufferSize;
			}
			if (collidersBuffer == null || collidersBuffer.Length != CurrentBufferSize)
			{
				collidersBuffer = new Collider2D[CurrentBufferSize];
			}
		}

		private void reset()
		{
			clearColliders();
			CurrentBufferSize = 0;
		}

		public override void OnDrawGizmosSelected()
		{
			base.OnDrawGizmosSelected();
			if (base.isActiveAndEnabled)
			{
				Gizmos.color = BaseAreaSensor.GizmoColor;
				Gizmos.DrawWireSphere(base.transform.position, SensorRange);
			}
		}
	}
	[ExecuteInEditMode]
	public class RaySensor : Sensor
	{
		public enum UpdateMode
		{
			EachFrame,
			Manual
		}

		public delegate void SensorUpdateHandler();

		private class RayDistanceComparer : IComparer<RaycastHit>
		{
			public int Compare(RaycastHit x, RaycastHit y)
			{
				if (x.distance < y.distance)
				{
					return -1;
				}
				if (x.distance > y.distance)
				{
					return 1;
				}
				return 0;
			}
		}

		[UnityEngine.Tooltip("The detection range in world units.")]
		public float Length = 5f;

		[UnityEngine.Tooltip("The radius of the ray, with values above zero the sensor will do a spherecast")]
		public float Radius;

		[UnityEngine.Tooltip("A layermask for colliders that will block the ray sensors path.")]
		public LayerMask ObstructedByLayers;

		[UnityEngine.Tooltip("A layermask for colliders that are detected by the ray sensor.")]
		public LayerMask DetectsOnLayers;

		[UnityEngine.Tooltip("In Collider mode the sensor detects GameObjects attached to colliders. In RigidBody mode it detects the RigidBody GameObject attached to colliders.")]
		public SensorMode DetectionMode;

		[UnityEngine.Tooltip("What direction does the ray sensor point in.")]
		public Vector3 Direction = Vector3.forward;

		[UnityEngine.Tooltip("Is the Direction parameter in world space or local space.")]
		public bool WorldSpace;

		[UnityEngine.Tooltip("Should the sensor pulse each frame automatically or will it be pulsed manually.")]
		public UpdateMode SensorUpdateMode;

		[UnityEngine.Tooltip("The initial size of the buffer used when calling Physics.RaycastNonAlloc or Physics.SphereCastNonAlloc.")]
		public int InitialBufferSize = 20;

		[UnityEngine.Tooltip("When set true the buffer used with Physics.RaycastNonAlloc is expanded if its not sufficiently large.")]
		public bool DynamicallyIncreaseBufferSize = true;

		[SerializeField]
		public SensorEventHandler OnObstruction;

		[SerializeField]
		public SensorEventHandler OnClear;

		private RayDistanceComparer distanceComparer = new RayDistanceComparer();

		private bool isObstructed;

		private RaycastHit obstructionRayHit;

		private Dictionary<GameObject, RaycastHit> detectedObjectHits = new Dictionary<GameObject, RaycastHit>();

		private HashSet<GameObject> previousDetectedObjects = new HashSet<GameObject>();

		private List<GameObject> detectedObjectsInternal = new List<GameObject>();

		private List<GameObject> detectedObjects = new List<GameObject>();

		private RaycastHit[] hitsBuffer;

		protected static readonly Color GizmoColor = new Color(0.2f, 1f, 1f);

		protected static readonly Color GizmoBlockedColor = Color.red;

		private static Mesh primitiveCylinderCache;

		public int CurrentBufferSize { get; private set; }

		public override List<GameObject> DetectedObjects
		{
			get
			{
				detectedObjects.Clear();
				List<GameObject>.Enumerator enumerator = detectedObjectsInternal.GetEnumerator();
				while (enumerator.MoveNext())
				{
					GameObject current = enumerator.Current;
					if (current != null && current.activeInHierarchy)
					{
						detectedObjects.Add(current);
					}
				}
				return detectedObjects;
			}
		}

		public override List<GameObject> DetectedObjectsOrderedByDistance => DetectedObjects;

		public List<RaycastHit> DetectedObjectRayHits => new List<RaycastHit>(detectedObjectHits.Values);

		public Collider ObstructedBy => obstructionRayHit.collider;

		public RaycastHit ObstructionRayHit => obstructionRayHit;

		public bool IsObstructed
		{
			get
			{
				if (isObstructed)
				{
					return ObstructedBy != null;
				}
				return false;
			}
		}

		private Vector3 direction
		{
			get
			{
				if (!WorldSpace)
				{
					return base.transform.rotation * Direction.normalized;
				}
				return Direction.normalized;
			}
		}

		private static Mesh primitiveCylinder
		{
			get
			{
				if (primitiveCylinderCache == null)
				{
					GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
					primitiveCylinderCache = obj.GetComponent<MeshFilter>().sharedMesh;
					UnityEngine.Object.DestroyImmediate(obj);
				}
				return primitiveCylinderCache;
			}
		}

		public event SensorUpdateHandler OnSensorUpdate;

		public override bool IsDetected(GameObject go)
		{
			return detectedObjectHits.ContainsKey(go);
		}

		public override void Pulse()
		{
			if (base.isActiveAndEnabled)
			{
				testRay();
			}
		}

		public RaycastHit GetRayHit(GameObject detectedGameObject)
		{
			if (!detectedObjectHits.TryGetValue(detectedGameObject, out var value))
			{
				UnityEngine.Debug.LogWarning("Tried to get the RaycastHit for a GameObject that isn't detected by RaySensor.");
			}
			return value;
		}

		protected override void Awake()
		{
			base.Awake();
			CurrentBufferSize = 0;
			if (OnObstruction == null)
			{
				OnObstruction = new SensorEventHandler();
			}
			if (OnClear == null)
			{
				OnClear = new SensorEventHandler();
			}
		}

		private void OnEnable()
		{
			clearDetectedObjects();
			previousDetectedObjects.Clear();
		}

		private void Update()
		{
			if (UnityEngine.Application.isPlaying && SensorUpdateMode == UpdateMode.EachFrame)
			{
				testRay();
			}
		}

		private bool layerMaskIsSubsetOf(LayerMask lm, LayerMask subsetOf)
		{
			return (((int)lm | (int)subsetOf) & ~(int)subsetOf) == 0;
		}

		private void testRay()
		{
			bool num = !layerMaskIsSubsetOf(DetectsOnLayers, ObstructedByLayers) && (IgnoreList == null || IgnoreList.Count == 0);
			clearDetectedObjects();
			if (!num && (IgnoreList == null || IgnoreList.Count == 0))
			{
				testRaySingle();
			}
			else
			{
				testRayMulti();
			}
			obstructionEvents();
			detectionEvents();
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void obstructionEvents()
		{
			if (isObstructed && obstructionRayHit.collider == null)
			{
				isObstructed = false;
				OnClear.Invoke(this);
			}
			else if (!isObstructed && obstructionRayHit.collider != null)
			{
				isObstructed = true;
				OnObstruction.Invoke(this);
			}
		}

		private void detectionEvents()
		{
			HashSet<GameObject>.Enumerator enumerator = previousDetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				OnLostDetection.Invoke(enumerator.Current, this);
			}
			previousDetectedObjects.Clear();
			for (int i = 0; i < detectedObjectsInternal.Count; i++)
			{
				previousDetectedObjects.Add(detectedObjectsInternal[i]);
			}
		}

		private void testRaySingle()
		{
			Ray ray = new Ray(base.transform.position, direction);
			RaycastHit hitInfo;
			if (Radius > 0f)
			{
				if (Physics.SphereCast(ray, Radius, out hitInfo, Length, ObstructedByLayers))
				{
					if (((1 << hitInfo.collider.gameObject.layer) & (int)DetectsOnLayers) != 0)
					{
						addRayHit(hitInfo);
					}
					obstructionRayHit = hitInfo;
				}
			}
			else if (Physics.Raycast(ray, out hitInfo, Length, ObstructedByLayers))
			{
				if (((1 << hitInfo.collider.gameObject.layer) & (int)DetectsOnLayers) != 0)
				{
					addRayHit(hitInfo);
				}
				obstructionRayHit = hitInfo;
			}
		}

		private void testRayMulti()
		{
			Ray ray = new Ray(base.transform.position, direction);
			LayerMask layerMask = (int)DetectsOnLayers | (int)ObstructedByLayers;
			RaycastHit[] array;
			int num;
			if (Radius > 0f)
			{
				prepareHitsBuffer();
				array = hitsBuffer;
				num = Physics.SphereCastNonAlloc(ray, Radius, array, Length, layerMask);
				if (num == CurrentBufferSize)
				{
					if (DynamicallyIncreaseBufferSize)
					{
						CurrentBufferSize *= 2;
						testRayMulti();
						return;
					}
					logInsufficientBufferSize();
				}
			}
			else
			{
				prepareHitsBuffer();
				array = hitsBuffer;
				num = Physics.RaycastNonAlloc(ray, array, Length, layerMask);
				if (num == CurrentBufferSize)
				{
					if (DynamicallyIncreaseBufferSize)
					{
						CurrentBufferSize *= 2;
						testRayMulti();
						return;
					}
					logInsufficientBufferSize();
				}
			}
			Array.Sort(array, 0, num, distanceComparer);
			for (int i = 0; i < num; i++)
			{
				RaycastHit hit = array[i];
				if (((1 << hit.collider.gameObject.layer) & (int)DetectsOnLayers) != 0)
				{
					addRayHit(hit);
				}
				if (((1 << hit.collider.gameObject.layer) & (int)ObstructedByLayers) != 0 && !shouldIgnore(hit.collider.gameObject) && (!(hit.rigidbody != null) || !shouldIgnore(hit.rigidbody.gameObject)))
				{
					obstructionRayHit = hit;
					break;
				}
			}
		}

		private void logInsufficientBufferSize()
		{
			UnityEngine.Debug.LogWarning("A ray sensor on " + base.name + " has an insufficient buffer size. Some objects may not be detected");
		}

		private void prepareHitsBuffer()
		{
			if (CurrentBufferSize == 0)
			{
				InitialBufferSize = Math.Max(1, InitialBufferSize);
				CurrentBufferSize = InitialBufferSize;
			}
			if (hitsBuffer == null || hitsBuffer.Length != CurrentBufferSize)
			{
				hitsBuffer = new RaycastHit[CurrentBufferSize];
			}
		}

		private void addRayHit(RaycastHit hit)
		{
			GameObject gameObject;
			if (DetectionMode == SensorMode.RigidBodies)
			{
				if (hit.rigidbody == null)
				{
					return;
				}
				gameObject = hit.rigidbody.gameObject;
			}
			else
			{
				gameObject = hit.collider.gameObject;
			}
			if (!detectedObjectHits.ContainsKey(gameObject) && !shouldIgnore(gameObject))
			{
				detectedObjectHits.Add(gameObject, hit);
				detectedObjectsInternal.Add(gameObject);
				if (!previousDetectedObjects.Contains(gameObject))
				{
					OnDetected.Invoke(gameObject, this);
				}
				else
				{
					previousDetectedObjects.Remove(gameObject);
				}
			}
		}

		private void clearDetectedObjects()
		{
			obstructionRayHit = default(RaycastHit);
			detectedObjectHits.Clear();
			detectedObjectsInternal.Clear();
			detectedObjects.Clear();
		}

		private void reset()
		{
			clearDetectedObjects();
			isObstructed = false;
			CurrentBufferSize = 0;
		}

		public void OnDrawGizmosSelected()
		{
			if (!base.isActiveAndEnabled)
			{
				return;
			}
			Vector3 vector;
			if (IsObstructed)
			{
				Gizmos.color = GizmoBlockedColor;
				vector = base.transform.position + direction * obstructionRayHit.distance;
			}
			else
			{
				Gizmos.color = GizmoColor;
				vector = base.transform.position + direction * Length;
			}
			if (Radius > 0f)
			{
				Gizmos.DrawWireSphere(base.transform.position, Radius);
				Gizmos.DrawWireSphere(vector, Radius);
				Vector3 vector2 = vector - base.transform.position;
				if (vector2 == Vector3.zero)
				{
					vector2 = Vector3.forward * Length;
				}
				Vector3 position = base.transform.position + vector2 / 2f;
				float magnitude = vector2.magnitude;
				Quaternion rotation = Quaternion.LookRotation(vector2.normalized) * Quaternion.Euler(90f, 0f, 0f);
				Gizmos.DrawWireMesh(primitiveCylinder, position, rotation, new Vector3(Radius * 2f, magnitude / 2f, Radius * 2f));
			}
			else
			{
				Gizmos.DrawLine(base.transform.position, vector);
			}
			Gizmos.color = GizmoColor;
			foreach (RaycastHit detectedObjectRayHit in DetectedObjectRayHits)
			{
				Gizmos.DrawIcon(detectedObjectRayHit.point, "SensorToolkit/eye.png", allowScaling: true);
			}
		}
	}
	[ExecuteInEditMode]
	public class RaySensor2D : Sensor
	{
		public enum UpdateMode
		{
			EachFrame,
			Manual
		}

		public delegate void SensorUpdateHandler();

		private class RayDistanceComparer2D : IComparer<RaycastHit2D>
		{
			public int Compare(RaycastHit2D x, RaycastHit2D y)
			{
				if (x.distance < y.distance)
				{
					return -1;
				}
				if (x.distance > y.distance)
				{
					return 1;
				}
				return 0;
			}
		}

		[UnityEngine.Tooltip("The detection range in world units.")]
		public float Length = 5f;

		[UnityEngine.Tooltip("The radius of the ray, with values above zero the sensor will do a circlecast")]
		public float Radius;

		[UnityEngine.Tooltip("A layermask for colliders that will block the ray sensors path.")]
		public LayerMask ObstructedByLayers;

		[UnityEngine.Tooltip("A layermask for colliders that are detected by the ray sensor.")]
		public LayerMask DetectsOnLayers;

		[UnityEngine.Tooltip("In Collider mode the sensor detects GameObjects attached to colliders. In RigidBody mode it detects the RigidBody GameObject attached to colliders.")]
		public SensorMode DetectionMode;

		[UnityEngine.Tooltip("What direction does the ray sensor point in.")]
		public Vector2 Direction = Vector2.up;

		[UnityEngine.Tooltip("Is the Direction parameter in world space or local space.")]
		public bool WorldSpace;

		[UnityEngine.Tooltip("Should the sensor pulse each frame automatically or will it be pulsed manually.")]
		public UpdateMode SensorUpdateMode;

		[UnityEngine.Tooltip("The initial size of the buffer used when calling Physics2D.RaycastNonAlloc or Physics2D.CircleCastNnoAlloc.")]
		public int InitialBufferSize = 20;

		[UnityEngine.Tooltip("When set true the buffer used with Physics2D.RaycastNonAlloc is expanded if its not sufficiently large.")]
		public bool DynamicallyIncreaseBufferSize = true;

		[SerializeField]
		public SensorEventHandler OnObstruction;

		[SerializeField]
		public SensorEventHandler OnClear;

		private RayDistanceComparer2D distanceComparer = new RayDistanceComparer2D();

		private bool isObstructed;

		private RaycastHit2D obstructionRayHit;

		private Dictionary<GameObject, RaycastHit2D> detectedObjectHits = new Dictionary<GameObject, RaycastHit2D>();

		private HashSet<GameObject> previousDetectedObjects = new HashSet<GameObject>();

		private List<GameObject> detectedObjectsInternal = new List<GameObject>();

		private List<GameObject> detectedObjects = new List<GameObject>();

		private RaycastHit2D[] hitsBuffer;

		protected static readonly Color GizmoColor = new Color(0.2f, 1f, 1f);

		protected static readonly Color GizmoBlockedColor = Color.red;

		private static Mesh primitiveBoxCache;

		public int CurrentBufferSize { get; private set; }

		public override List<GameObject> DetectedObjects
		{
			get
			{
				detectedObjects.Clear();
				List<GameObject>.Enumerator enumerator = detectedObjectsInternal.GetEnumerator();
				while (enumerator.MoveNext())
				{
					GameObject current = enumerator.Current;
					if (current != null && current.activeInHierarchy)
					{
						detectedObjects.Add(current);
					}
				}
				return detectedObjects;
			}
		}

		public override List<GameObject> DetectedObjectsOrderedByDistance => DetectedObjects;

		public List<RaycastHit2D> DetectedObjectRayHits => new List<RaycastHit2D>(detectedObjectHits.Values);

		public Collider2D ObstructedBy => obstructionRayHit.collider;

		public RaycastHit2D ObstructionRayHit => obstructionRayHit;

		public bool IsObstructed
		{
			get
			{
				if (isObstructed)
				{
					return ObstructedBy != null;
				}
				return false;
			}
		}

		private Vector2 direction
		{
			get
			{
				if (!WorldSpace)
				{
					return base.transform.TransformDirection(Direction.normalized);
				}
				return Direction.normalized;
			}
		}

		private static Mesh primitiveBox
		{
			get
			{
				if (primitiveBoxCache == null)
				{
					GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Quad);
					primitiveBoxCache = obj.GetComponent<MeshFilter>().sharedMesh;
					UnityEngine.Object.DestroyImmediate(obj);
				}
				return primitiveBoxCache;
			}
		}

		public event SensorUpdateHandler OnSensorUpdate;

		public override bool IsDetected(GameObject go)
		{
			return detectedObjectHits.ContainsKey(go);
		}

		public override void Pulse()
		{
			if (base.isActiveAndEnabled)
			{
				testRay();
			}
		}

		public RaycastHit2D GetRayHit(GameObject detectedGameObject)
		{
			if (!detectedObjectHits.TryGetValue(detectedGameObject, out var value))
			{
				UnityEngine.Debug.LogWarning("Tried to get the RaycastHit for a GameObject that isn't detected by RaySensor.");
			}
			return value;
		}

		protected override void Awake()
		{
			base.Awake();
			CurrentBufferSize = 0;
			if (OnObstruction == null)
			{
				OnObstruction = new SensorEventHandler();
			}
			if (OnClear == null)
			{
				OnClear = new SensorEventHandler();
			}
		}

		private void OnEnable()
		{
			clearDetectedObjects();
			previousDetectedObjects.Clear();
		}

		private void Update()
		{
			if (UnityEngine.Application.isPlaying && SensorUpdateMode == UpdateMode.EachFrame)
			{
				testRay();
			}
		}

		private bool layerMaskIsSubsetOf(LayerMask lm, LayerMask subsetOf)
		{
			return (((int)lm | (int)subsetOf) & ~(int)subsetOf) == 0;
		}

		private void testRay()
		{
			bool num = !layerMaskIsSubsetOf(DetectsOnLayers, ObstructedByLayers) && (IgnoreList == null || IgnoreList.Count == 0);
			clearDetectedObjects();
			if (!num && (IgnoreList == null || IgnoreList.Count == 0))
			{
				testRaySingle();
			}
			else
			{
				testRayMulti();
			}
			obstructionEvents();
			detectionEvents();
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void obstructionEvents()
		{
			if (isObstructed && obstructionRayHit.collider == null)
			{
				isObstructed = false;
				OnClear.Invoke(this);
			}
			else if (!isObstructed && obstructionRayHit.collider != null)
			{
				isObstructed = true;
				OnObstruction.Invoke(this);
			}
		}

		private void detectionEvents()
		{
			HashSet<GameObject>.Enumerator enumerator = previousDetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				OnLostDetection.Invoke(enumerator.Current, this);
			}
			previousDetectedObjects.Clear();
			for (int i = 0; i < detectedObjectsInternal.Count; i++)
			{
				previousDetectedObjects.Add(detectedObjectsInternal[i]);
			}
		}

		private void testRaySingle()
		{
			RaycastHit2D hit = ((!(Radius > 0f)) ? Physics2D.Raycast(base.transform.position, direction, Length, ObstructedByLayers) : Physics2D.CircleCast(base.transform.position, Radius, direction, Length, ObstructedByLayers));
			if (hit.collider != null)
			{
				if (((1 << hit.collider.gameObject.layer) & (int)DetectsOnLayers) != 0)
				{
					addRayHit(hit);
				}
				obstructionRayHit = hit;
			}
		}

		private void testRayMulti()
		{
			LayerMask layerMask = (int)DetectsOnLayers | (int)ObstructedByLayers;
			RaycastHit2D[] array;
			int num;
			if (Radius > 0f)
			{
				prepareHitsBuffer();
				array = hitsBuffer;
				num = Physics2D.CircleCastNonAlloc(base.transform.position, Radius, direction, array, Length, layerMask);
				if (num == CurrentBufferSize)
				{
					if (DynamicallyIncreaseBufferSize)
					{
						CurrentBufferSize *= 2;
						testRayMulti();
						return;
					}
					logInsufficientBufferSize();
				}
			}
			else
			{
				prepareHitsBuffer();
				array = hitsBuffer;
				num = Physics2D.RaycastNonAlloc(base.transform.position, direction, array, Length, layerMask);
				if (num == CurrentBufferSize)
				{
					if (DynamicallyIncreaseBufferSize)
					{
						CurrentBufferSize *= 2;
						testRayMulti();
						return;
					}
					logInsufficientBufferSize();
				}
			}
			Array.Sort(array, 0, num, distanceComparer);
			for (int i = 0; i < num; i++)
			{
				RaycastHit2D hit = array[i];
				if (((1 << hit.collider.gameObject.layer) & (int)DetectsOnLayers) != 0)
				{
					addRayHit(hit);
				}
				if (((1 << hit.collider.gameObject.layer) & (int)ObstructedByLayers) != 0 && !shouldIgnore(hit.collider.gameObject) && (!(hit.rigidbody != null) || !shouldIgnore(hit.rigidbody.gameObject)))
				{
					obstructionRayHit = hit;
					break;
				}
			}
		}

		private void logInsufficientBufferSize()
		{
			UnityEngine.Debug.LogWarning("A ray sensor on " + base.name + " has an insufficient buffer size. Some objects may not be detected");
		}

		private void prepareHitsBuffer()
		{
			if (CurrentBufferSize == 0)
			{
				InitialBufferSize = Math.Max(1, InitialBufferSize);
				CurrentBufferSize = InitialBufferSize;
			}
			if (hitsBuffer == null || hitsBuffer.Length != CurrentBufferSize)
			{
				hitsBuffer = new RaycastHit2D[CurrentBufferSize];
			}
		}

		private void addRayHit(RaycastHit2D hit)
		{
			GameObject gameObject;
			if (DetectionMode == SensorMode.RigidBodies)
			{
				if (hit.rigidbody == null)
				{
					return;
				}
				gameObject = hit.rigidbody.gameObject;
			}
			else
			{
				gameObject = hit.collider.gameObject;
			}
			if (!detectedObjectHits.ContainsKey(gameObject) && !shouldIgnore(gameObject))
			{
				detectedObjectHits.Add(gameObject, hit);
				detectedObjectsInternal.Add(gameObject);
				if (!previousDetectedObjects.Contains(gameObject))
				{
					OnDetected.Invoke(gameObject, this);
				}
				else
				{
					previousDetectedObjects.Remove(gameObject);
				}
			}
		}

		private void clearDetectedObjects()
		{
			obstructionRayHit = default(RaycastHit2D);
			detectedObjectHits.Clear();
			detectedObjectsInternal.Clear();
			detectedObjects.Clear();
		}

		private void reset()
		{
			clearDetectedObjects();
			isObstructed = false;
			CurrentBufferSize = 0;
		}

		public void OnDrawGizmosSelected()
		{
			if (!base.isActiveAndEnabled)
			{
				return;
			}
			Vector3 vector;
			if (IsObstructed)
			{
				Gizmos.color = GizmoBlockedColor;
				vector = base.transform.position + (Vector3)direction * obstructionRayHit.distance;
			}
			else
			{
				Gizmos.color = GizmoColor;
				vector = base.transform.position + (Vector3)direction * Length;
			}
			if (Radius > 0f)
			{
				Gizmos.DrawWireSphere(base.transform.position, Radius);
				Gizmos.DrawWireSphere(vector, Radius);
				Vector3 vector2 = vector - base.transform.position;
				if (vector2 == Vector3.zero)
				{
					vector2 = Vector3.forward * Length;
				}
				Vector3 position = base.transform.position + vector2 / 2f;
				float magnitude = vector2.magnitude;
				Quaternion rotation = Quaternion.LookRotation(vector2.normalized, Vector3.back) * Quaternion.Euler(90f, 0f, 0f);
				Gizmos.DrawWireMesh(primitiveBox, position, rotation, new Vector3(Radius * 2f, magnitude, 1f));
			}
			else
			{
				Gizmos.DrawLine(base.transform.position, vector);
			}
			Gizmos.color = GizmoColor;
			foreach (RaycastHit2D detectedObjectRayHit in DetectedObjectRayHits)
			{
				Gizmos.DrawIcon(detectedObjectRayHit.point, "SensorToolkit/eye.png", allowScaling: true);
			}
		}
	}
	public class SteeringRig : MonoBehaviour
	{
		[UnityEngine.Tooltip("The rig won't try to steer around objects in this list.")]
		public List<GameObject> IgnoreList;

		[Range(0.1f, 4f)]
		[UnityEngine.Tooltip("Lower numbers mean the rig will move closer to obstacles.")]
		public float AvoidanceSensitivity = 1f;

		[Range(1f, 2f)]
		[UnityEngine.Tooltip("The max distance that can be steered from the target direction.")]
		public float MaxAvoidanceLength = 1f;

		[UnityEngine.Tooltip("Should the rig steer along the Y-axis, up and down. Should be false for characters that move along the ground, but true for spaceships or airoplanes.")]
		public bool YAxis = true;

		[UnityEngine.Tooltip("Rotate the rig towards the target direction before calculating steer vectors. Useful for creating asymetric ray sensor setups. See the example prefabs, they are all RotateTowardsTarget = true.")]
		public bool RotateTowardsTarget;

		[UnityEngine.Tooltip("If assigned the steering rig will control the movement of this rigid body.")]
		public Rigidbody RB;

		[UnityEngine.Tooltip("The maximum torque that will be applied to the rigid body.")]
		public float TurnForce;

		[UnityEngine.Tooltip("The maximum force that will be applied to the rigid body in a forwards direction.")]
		public float MoveForce;

		[UnityEngine.Tooltip("The maximum force that will be applied to the rigid body in a sideways or backwards direction.")]
		public float StrafeForce;

		[UnityEngine.Tooltip("The maximum turning speed that will be applied to kinematic rigid bodies.")]
		public float TurnSpeed;

		[UnityEngine.Tooltip("The maximum movement speed that will be applied to kinematic rigid bodies in a forwards direction.")]
		public float MoveSpeed;

		[UnityEngine.Tooltip("The maximum movement speed that will be applied to kinematic rigid bodies in a sideways or backwards direction.")]
		public float StrafeSpeed;

		[UnityEngine.Tooltip("The distance threshold for the rig to arrive at a destination position.")]
		public float StoppingDistance = 0.5f;

		[UnityEngine.Tooltip("The rig will attempt to move towards this transform.")]
		public Transform DestinationTransform;

		[UnityEngine.Tooltip("The rig will face towards this transform, even strafing while moving towards destination.")]
		public Transform FaceTowardsTransform;

		private RaySensor[] sensors;

		private Vector3 destination;

		private bool trackingToDestinationPosition;

		private Vector3 faceDirection;

		private bool directionToFaceAssigned;

		private Vector3 previousAttractionVector;

		private Vector3 previousRepulsionVector;

		private Vector3 previousAvoidanceVector;

		protected static readonly Color AttractionVectorColor = new Color(0.2f, 1f, 1f);

		protected static readonly Color RepulsionVectorColor = Color.yellow;

		protected static readonly Color AvoidanceVectorColor = Color.green;

		public Vector3 Destination
		{
			get
			{
				if (DestinationTransform != null)
				{
					trackingToDestinationPosition = false;
					return Vector3.Scale(DestinationTransform.position, axisConstraint);
				}
				return Vector3.Scale(destination, axisConstraint);
			}
			set
			{
				if (DestinationTransform != null)
				{
					UnityEngine.Debug.LogWarning("Cannot set Destination while DestinationTransform is not Null.");
					return;
				}
				destination = value;
				trackingToDestinationPosition = true;
			}
		}

		public bool IsSeeking
		{
			get
			{
				if (RB != null)
				{
					if (!(DestinationTransform != null))
					{
						return trackingToDestinationPosition;
					}
					return true;
				}
				return false;
			}
		}

		public Vector3 DirectionToFace
		{
			get
			{
				if (FaceTowardsTransform != null)
				{
					return (FaceTowardsTransform.position - RB.transform.position).normalized;
				}
				if (directionToFaceAssigned)
				{
					return faceDirection;
				}
				return Vector3.zero;
			}
			set
			{
				if (FaceTowardsTransform != null)
				{
					UnityEngine.Debug.LogWarning("Cannot set DirectionToFace while FaceTowardsTransform is not Null.");
					return;
				}
				if (value == Vector3.zero)
				{
					ClearDirectionToFace();
					return;
				}
				directionToFaceAssigned = true;
				faceDirection = value.normalized;
			}
		}

		public bool IsDirectionToFaceAssigned
		{
			get
			{
				if (!(FaceTowardsTransform != null))
				{
					return directionToFaceAssigned;
				}
				return true;
			}
		}

		private Vector3 axisConstraint => new Vector3(1f, YAxis ? 1f : 0f, 1f);

		public void ClearDirectionToFace()
		{
			FaceTowardsTransform = null;
			directionToFaceAssigned = false;
		}

		public Vector3 GetSteeredDirection(Vector3 targetDirection)
		{
			targetDirection = Vector3.Scale(targetDirection, axisConstraint).normalized;
			if (RotateTowardsTarget)
			{
				base.transform.rotation = Quaternion.LookRotation(targetDirection, Vector3.up);
			}
			return accumForces(targetDirection);
		}

		private void Awake()
		{
			if (IgnoreList == null)
			{
				IgnoreList = new List<GameObject>();
			}
			sensors = GetComponentsInChildren<RaySensor>();
			trackingToDestinationPosition = false;
		}

		private void Update()
		{
			if (RB == null || !RB.isKinematic)
			{
				return;
			}
			if (IsDirectionToFaceAssigned)
			{
				FaceDirectionKinematic(DirectionToFace);
			}
			if (!IsSeeking)
			{
				return;
			}
			if (hasReachedDestination())
			{
				trackingToDestinationPosition = false;
				return;
			}
			Vector3 normalized = (Destination - RB.transform.position).normalized;
			Vector3 steeredDirection = GetSteeredDirection(normalized);
			if (!IsDirectionToFaceAssigned)
			{
				FaceDirectionKinematic(steeredDirection);
			}
			float value = Vector3.Dot(RB.transform.forward, steeredDirection.normalized);
			steeredDirection = Mathf.Lerp(StrafeSpeed, MoveSpeed, Mathf.Clamp(value, 0f, 1f)) * steeredDirection;
			RB.transform.position = RB.transform.position + steeredDirection * Time.deltaTime;
		}

		private void FaceDirectionKinematic(Vector3 direction)
		{
			Quaternion to = Quaternion.LookRotation(direction, Vector3.up);
			RB.transform.rotation = Quaternion.RotateTowards(RB.transform.rotation, to, TurnSpeed * Time.deltaTime);
		}

		private void FixedUpdate()
		{
			if (RB == null || RB.isKinematic)
			{
				return;
			}
			if (IsDirectionToFaceAssigned)
			{
				FaceDirectionForces(DirectionToFace);
			}
			if (!IsSeeking)
			{
				return;
			}
			if (hasReachedDestination())
			{
				trackingToDestinationPosition = false;
				return;
			}
			Vector3 targetDirection = Destination - RB.transform.position;
			Vector3 steeredDirection = GetSteeredDirection(targetDirection);
			if (!IsDirectionToFaceAssigned)
			{
				FaceDirectionForces(steeredDirection);
			}
			float value = Vector3.Dot(RB.transform.forward, steeredDirection);
			Vector3 force = Mathf.Lerp(StrafeForce, MoveForce, Mathf.Clamp(value, 0f, 1f)) * steeredDirection;
			RB.AddForce(force);
			if (YAxis)
			{
				float num = RB.rotation.eulerAngles.z;
				if (num > 180f)
				{
					num -= 360f;
				}
				float num2 = Mathf.Clamp(num / 10f, -1f, 1f) * TurnForce;
				RB.AddTorque(RB.transform.forward * (0f - num2));
			}
		}

		private void FaceDirectionForces(Vector3 direction)
		{
			((!YAxis) ? Quaternion.AngleAxis(signedAngleXZ(RB.transform.forward, direction), Vector3.up) : Quaternion.FromToRotation(RB.transform.forward, direction)).ToAngleAxis(out var angle, out var axis);
			angle = ((angle > 180f) ? (angle - 360f) : angle);
			float num = Mathf.Clamp(angle / 20f, -1f, 1f) * TurnForce;
			RB.AddTorque(axis * num);
		}

		private Vector3 accumForces(Vector3 targetDirection)
		{
			previousAttractionVector = attractionForce(targetDirection);
			previousRepulsionVector = repulsionForce();
			Vector3 vector = previousAttractionVector + previousRepulsionVector;
			if (vector.sqrMagnitude > 0.01f)
			{
				previousAvoidanceVector = vector.normalized;
				return previousAvoidanceVector;
			}
			previousAvoidanceVector = vector * 100f;
			return previousAvoidanceVector;
		}

		private Vector3 attractionForce(Vector3 targetDirection)
		{
			Vector3 result = Vector3.Scale(targetDirection, axisConstraint);
			if (result.sqrMagnitude > 1f)
			{
				return result.normalized;
			}
			return result;
		}

		private Vector3 repulsionForce()
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < sensors.Length; i++)
			{
				RaySensor raySensor = sensors[i];
				raySensor.IgnoreList = IgnoreList;
				raySensor.Pulse();
				if (raySensor.IsObstructed)
				{
					float num = Mathf.Pow(1f - raySensor.ObstructionRayHit.distance / raySensor.Length, 1f / AvoidanceSensitivity);
					zero += num * raySensor.ObstructionRayHit.normal;
				}
			}
			float magnitude = zero.magnitude;
			zero = Vector3.Scale(zero, axisConstraint).normalized;
			if (magnitude > MaxAvoidanceLength)
			{
				return zero * MaxAvoidanceLength;
			}
			return zero * magnitude;
		}

		private float signedAngleXZ(Vector3 a, Vector3 b)
		{
			float current = Mathf.Atan2(a.x, a.z) * 57.29578f;
			float target = Mathf.Atan2(b.x, b.z) * 57.29578f;
			return Mathf.DeltaAngle(current, target);
		}

		private bool hasReachedDestination()
		{
			return (RB.transform.position - Destination).magnitude <= StoppingDistance;
		}

		public void OnDrawGizmosSelected()
		{
			if (base.isActiveAndEnabled)
			{
				Vector3 vector = base.transform.position + previousAttractionVector * 2f;
				Vector3 to = vector + previousRepulsionVector * 2f;
				Vector3 to2 = base.transform.position + previousAvoidanceVector * 2f;
				Gizmos.color = AttractionVectorColor;
				Gizmos.DrawLine(base.transform.position, vector);
				Gizmos.color = RepulsionVectorColor;
				Gizmos.DrawLine(vector, to);
				Gizmos.color = AvoidanceVectorColor;
				Gizmos.DrawLine(base.transform.position, to2);
			}
		}
	}
	public class SteeringRig2D : MonoBehaviour
	{
		[UnityEngine.Tooltip("The rig won't try to steer around objects in this list.")]
		public List<GameObject> IgnoreList;

		[Range(0.1f, 4f)]
		[UnityEngine.Tooltip("Lower numbers mean the rig will move closer to obstacles.")]
		public float AvoidanceSensitivity = 1f;

		[Range(1f, 2f)]
		[UnityEngine.Tooltip("The max distance that can be steered from the target direction.")]
		public float MaxAvoidanceLength = 1f;

		[UnityEngine.Tooltip("Rotate the rig towards the target direction before calculating steer vectors. Useful for creating asymetric ray sensor setups. See the example prefabs, they are all RotateTowardsTarget = true.")]
		public bool RotateTowardsTarget;

		[UnityEngine.Tooltip("If assigned the steering rig will control the movement of this rigid body.")]
		public Rigidbody2D RB;

		[UnityEngine.Tooltip("The maximum torque that will be applied to the rigid body.")]
		public float TurnForce;

		[UnityEngine.Tooltip("The maximum force that will be applied to the rigid body in a forwards direction.")]
		public float MoveForce;

		[UnityEngine.Tooltip("The maximum force that will be applied to the rigid body in a sideways or backwards direction.")]
		public float StrafeForce;

		[UnityEngine.Tooltip("The maximum turning speed that will be applied to kinematic rigid bodies.")]
		public float TurnSpeed;

		[UnityEngine.Tooltip("The maximum movement speed that will be applied to kinematic rigid bodies in a forwards direction.")]
		public float MoveSpeed;

		[UnityEngine.Tooltip("The maximum movement speed that will be applied to kinematic rigid bodies in a sideways or backwards direction.")]
		public float StrafeSpeed;

		[UnityEngine.Tooltip("The distance threshold for the rig to arrive at a destination position.")]
		public float StoppingDistance = 0.5f;

		[UnityEngine.Tooltip("The rig will attempt to move towards this transform.")]
		public Transform DestinationTransform;

		[UnityEngine.Tooltip("The rig will face towards this transform, even strafing while moving towards destination.")]
		public Transform FaceTowardsTransform;

		private RaySensor2D[] sensors;

		private Vector2 destination;

		private bool trackingToDestinationPosition;

		private Vector2 faceDirection;

		private bool directionToFaceAssigned;

		private Vector2 previousAttractionVector;

		private Vector2 previousRepulsionVector;

		private Vector2 previousAvoidanceVector;

		protected static readonly Color AttractionVectorColor = new Color(0.2f, 1f, 1f);

		protected static readonly Color RepulsionVectorColor = Color.yellow;

		protected static readonly Color AvoidanceVectorColor = Color.green;

		public Vector2 Destination
		{
			get
			{
				if (!(DestinationTransform != null))
				{
					return destination;
				}
				return DestinationTransform.position;
			}
			set
			{
				if (DestinationTransform != null)
				{
					UnityEngine.Debug.LogWarning("Cannot set Destination while DestinationTransform is not Null.");
					return;
				}
				destination = value;
				trackingToDestinationPosition = true;
			}
		}

		public bool IsSeeking
		{
			get
			{
				if (RB != null)
				{
					if (!(DestinationTransform != null))
					{
						return trackingToDestinationPosition;
					}
					return true;
				}
				return false;
			}
		}

		public Vector2 DirectionToFace
		{
			get
			{
				if (FaceTowardsTransform != null)
				{
					return (FaceTowardsTransform.position - RB.transform.position).normalized;
				}
				if (directionToFaceAssigned)
				{
					return faceDirection;
				}
				return Vector2.zero;
			}
			set
			{
				if (FaceTowardsTransform != null)
				{
					UnityEngine.Debug.LogWarning("Cannot set DirectionToFace while FaceTowardsTransform is not Null.");
					return;
				}
				if (value == Vector2.zero)
				{
					ClearDirectionToFace();
					return;
				}
				directionToFaceAssigned = true;
				faceDirection = value.normalized;
			}
		}

		public bool IsDirectionToFaceAssigned
		{
			get
			{
				if (!(FaceTowardsTransform != null))
				{
					return directionToFaceAssigned;
				}
				return true;
			}
		}

		public void ClearDirectionToFace()
		{
			FaceTowardsTransform = null;
			directionToFaceAssigned = false;
		}

		public Vector2 GetSteeredDirection(Vector2 targetDirection)
		{
			if (RotateTowardsTarget)
			{
				float num = Mathf.Atan2(targetDirection.y, targetDirection.x) * 57.29578f;
				base.transform.rotation = Quaternion.Euler(0f, 0f, num - 90f);
			}
			return accumForces(targetDirection);
		}

		private void Awake()
		{
			if (IgnoreList == null)
			{
				IgnoreList = new List<GameObject>();
			}
			sensors = GetComponentsInChildren<RaySensor2D>();
			trackingToDestinationPosition = false;
		}

		private void Update()
		{
			if (RB == null || !RB.isKinematic)
			{
				return;
			}
			if (IsDirectionToFaceAssigned)
			{
				FaceDirectionKinematic(DirectionToFace);
			}
			if (!IsSeeking)
			{
				return;
			}
			if (hasReachedDestination())
			{
				trackingToDestinationPosition = false;
				return;
			}
			Vector2 normalized = (Destination - (Vector2)RB.transform.position).normalized;
			Vector2 steeredDirection = GetSteeredDirection(normalized);
			if (!IsDirectionToFaceAssigned)
			{
				FaceDirectionKinematic(steeredDirection);
			}
			float value = Vector3.Dot(RB.transform.up, steeredDirection.normalized);
			steeredDirection = Mathf.Lerp(StrafeSpeed, MoveSpeed, Mathf.Clamp(value, 0f, 1f)) * steeredDirection;
			RB.transform.position = (Vector2)RB.transform.position + steeredDirection * Time.deltaTime;
		}

		private void FaceDirectionKinematic(Vector2 direction)
		{
			float num = signedAngleXY(RB.transform.up, direction);
			float num2 = TurnSpeed * Time.deltaTime * Mathf.Min(1f, Mathf.Abs(num) / 20f);
			num = Mathf.Clamp(num, 0f - num2, num2);
			RB.transform.rotation = Quaternion.Euler(0f, 0f, RB.transform.rotation.eulerAngles.z - num);
		}

		private void FixedUpdate()
		{
			if (RB == null || RB.isKinematic)
			{
				return;
			}
			if (IsDirectionToFaceAssigned)
			{
				FaceDirectionForces(DirectionToFace);
			}
			if (!IsSeeking)
			{
				return;
			}
			if (hasReachedDestination())
			{
				trackingToDestinationPosition = false;
				return;
			}
			Vector2 targetDirection = Destination - (Vector2)RB.transform.position;
			Vector2 steeredDirection = GetSteeredDirection(targetDirection);
			if (!IsDirectionToFaceAssigned)
			{
				FaceDirectionForces(steeredDirection);
			}
			float value = Vector3.Dot(RB.transform.up, steeredDirection);
			Vector3 vector = Mathf.Lerp(StrafeForce, MoveForce, Mathf.Clamp(value, 0f, 1f)) * steeredDirection;
			RB.AddForce(vector);
		}

		private void FaceDirectionForces(Vector2 direction)
		{
			float num = Mathf.Clamp(signedAngleXY(RB.transform.up, direction) / 20f, -1f, 1f) * TurnForce;
			RB.AddTorque(0f - num);
		}

		private Vector3 accumForces(Vector3 targetDirection)
		{
			previousAttractionVector = attractionForce(targetDirection);
			previousRepulsionVector = repulsionForce();
			Vector2 vector = previousAttractionVector + previousRepulsionVector;
			if (vector.sqrMagnitude > 0.01f)
			{
				previousAvoidanceVector = vector.normalized;
				return previousAvoidanceVector;
			}
			previousAvoidanceVector = vector * 100f;
			return previousAvoidanceVector;
		}

		private Vector3 attractionForce(Vector3 targetDirection)
		{
			Vector3 result = targetDirection;
			if (result.sqrMagnitude > 1f)
			{
				return result.normalized;
			}
			return result;
		}

		private Vector3 repulsionForce()
		{
			Vector2 zero = Vector2.zero;
			for (int i = 0; i < sensors.Length; i++)
			{
				RaySensor2D raySensor2D = sensors[i];
				raySensor2D.IgnoreList = IgnoreList;
				raySensor2D.Pulse();
				if (raySensor2D.IsObstructed)
				{
					float num = Mathf.Pow(1f - raySensor2D.ObstructionRayHit.distance / raySensor2D.Length, 1f / AvoidanceSensitivity);
					zero += num * raySensor2D.ObstructionRayHit.normal;
				}
			}
			float magnitude = zero.magnitude;
			if (magnitude > MaxAvoidanceLength)
			{
				return zero * MaxAvoidanceLength;
			}
			return zero * magnitude;
		}

		private float signedAngleXY(Vector2 a, Vector2 b)
		{
			float current = Mathf.Atan2(a.x, a.y) * 57.29578f;
			float target = Mathf.Atan2(b.x, b.y) * 57.29578f;
			return Mathf.DeltaAngle(current, target);
		}

		private bool hasReachedDestination()
		{
			return ((Vector2)RB.transform.position - Destination).magnitude <= StoppingDistance;
		}

		public void OnDrawGizmosSelected()
		{
			if (base.isActiveAndEnabled)
			{
				Vector2 vector = (Vector2)base.transform.position + previousAttractionVector * 2f;
				Vector2 vector2 = vector + previousRepulsionVector * 2f;
				Vector2 vector3 = (Vector2)base.transform.position + previousAvoidanceVector * 2f;
				Gizmos.color = AttractionVectorColor;
				Gizmos.DrawLine(base.transform.position, vector);
				Gizmos.color = RepulsionVectorColor;
				Gizmos.DrawLine(vector, vector2);
				Gizmos.color = AvoidanceVectorColor;
				Gizmos.DrawLine(base.transform.position, vector3);
			}
		}
	}
	public class TriggerSensor : BaseVolumeSensor
	{
		public enum UpdateMode
		{
			FixedInterval,
			Manual
		}

		public delegate void SensorUpdateHandler();

		[UnityEngine.Tooltip("Should the sensor be pulsed automatically at fixed intervals or should it be pulsed manually. For the trigger sensor this is only relevant to refreshing the line of sight tests as the colliders are detected outside of the pulse method.")]
		public UpdateMode LineOfSightUpdateMode;

		[UnityEngine.Tooltip("If set to pulse automatically this is the interval in seconds between each automatic pulse.")]
		public float CheckLineOfSightInterval = 1f;

		private HashSet<GameObject> previousDetectedObjects = new HashSet<GameObject>();

		private Dictionary<Collider, int> triggerStayLag = new Dictionary<Collider, int>();

		private SensorMode oldDetectionMode;

		private bool oldRequiresLineOfSight;

		private List<Collider> collidersToRemove = new List<Collider>();

		private List<Collider> collidersToIncrement = new List<Collider>();

		private float timer;

		private List<GameObject> tempGOList = new List<GameObject>();

		public event SensorUpdateHandler OnSensorUpdate;

		public override void Pulse()
		{
			if (base.isActiveAndEnabled)
			{
				testSensor();
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			previousDetectedObjects.Clear();
			triggerStayLag.Clear();
			oldDetectionMode = DetectionMode;
			oldRequiresLineOfSight = RequiresLineOfSight;
			collidersToRemove.Clear();
			collidersToIncrement.Clear();
			if (!checkForTriggers())
			{
				UnityEngine.Debug.LogWarning("Trigger Sensor cannot detect anything if there are no triggers on the same GameObject.", base.gameObject);
			}
			if (DetectionMode == SensorMode.Colliders && GetComponent<Rigidbody>() == null)
			{
				UnityEngine.Debug.LogWarning("In order to detect GameObjects without RigidBodies the TriggerSensor must itself have a RigidBody. Recommend adding a kinematic RigidBody.");
			}
		}

		private void Update()
		{
			if (oldDetectionMode != DetectionMode || oldRequiresLineOfSight != RequiresLineOfSight)
			{
				sensorDetectionEvents();
				oldDetectionMode = DetectionMode;
				oldRequiresLineOfSight = RequiresLineOfSight;
			}
			collidersToRemove.Clear();
			collidersToIncrement.Clear();
			Dictionary<Collider, int>.Enumerator enumerator = triggerStayLag.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Collider key = enumerator.Current.Key;
				triggerStayLag.TryGetValue(key, out var value);
				if (value >= 10)
				{
					collidersToRemove.Add(key);
				}
				else
				{
					collidersToIncrement.Add(key);
				}
			}
			for (int i = 0; i < collidersToRemove.Count; i++)
			{
				removeCollider(collidersToRemove[i]);
			}
			for (int j = 0; j < collidersToIncrement.Count; j++)
			{
				Collider key2 = collidersToIncrement[j];
				triggerStayLag.TryGetValue(key2, out var value2);
				triggerStayLag[key2] = value2 + 1;
			}
			if (RequiresLineOfSight && LineOfSightUpdateMode == UpdateMode.FixedInterval)
			{
				timer += Time.deltaTime;
				if (timer > CheckLineOfSightInterval)
				{
					testSensor();
					timer = 0f;
				}
			}
			else
			{
				timer = 0f;
			}
		}

		private void OnTriggerEnter(Collider other)
		{
			addCollider(other);
		}

		private void OnTriggerStay(Collider other)
		{
			if (!triggerStayLag.ContainsKey(other))
			{
				addCollider(other);
			}
			triggerStayLag[other] = 0;
		}

		private void OnTriggerExit(Collider other)
		{
			removeCollider(other);
		}

		private new void addCollider(Collider other)
		{
			GameObject gameObject = base.addCollider(other);
			triggerStayLag[other] = 0;
			if (gameObject != null)
			{
				OnDetected.Invoke(gameObject, this);
				previousDetectedObjects.Add(gameObject);
			}
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private new void removeCollider(Collider other)
		{
			triggerStayLag.Remove(other);
			GameObject gameObject = base.removeCollider(other);
			if (gameObject != null)
			{
				OnLostDetection.Invoke(gameObject, this);
				previousDetectedObjects.Remove(gameObject);
			}
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void testSensor()
		{
			refreshLineOfSight();
			sensorDetectionEvents();
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void sensorDetectionEvents()
		{
			tempGOList.Clear();
			tempGOList.AddRange(DetectedObjects);
			List<GameObject>.Enumerator enumerator = tempGOList.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (previousDetectedObjects.Contains(current))
				{
					previousDetectedObjects.Remove(current);
				}
				else
				{
					OnDetected.Invoke(current, this);
				}
			}
			HashSet<GameObject>.Enumerator enumerator2 = previousDetectedObjects.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				GameObject current2 = enumerator2.Current;
				OnLostDetection.Invoke(current2, this);
			}
			previousDetectedObjects.Clear();
			enumerator = DetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				previousDetectedObjects.Add(enumerator.Current);
			}
		}

		private bool checkForTriggers()
		{
			if (GetComponent<Rigidbody>() != null)
			{
				Collider[] componentsInChildren = GetComponentsInChildren<Collider>();
				foreach (Collider collider in componentsInChildren)
				{
					if (collider.enabled && collider.isTrigger)
					{
						return true;
					}
				}
			}
			else
			{
				Collider[] componentsInChildren = GetComponents<Collider>();
				foreach (Collider collider2 in componentsInChildren)
				{
					if (collider2.enabled && collider2.isTrigger)
					{
						return true;
					}
				}
			}
			return false;
		}
	}
	public class TriggerSensor2D : BaseAreaSensor
	{
		public enum UpdateMode
		{
			FixedInterval,
			Manual
		}

		public delegate void SensorUpdateHandler();

		[UnityEngine.Tooltip("Should the sensor be pulsed automatically at fixed intervals or should it be pulsed manually. For the trigger sensor this is only relevant to refreshing the line of sight tests as the colliders are detected outside of the pulse method.")]
		public UpdateMode LineOfSightUpdateMode;

		[UnityEngine.Tooltip("If set to pulse automatically this is the interval in seconds between each automatic pulse.")]
		public float CheckLineOfSightInterval = 1f;

		private HashSet<GameObject> previousDetectedObjects = new HashSet<GameObject>();

		private Dictionary<Collider2D, int> triggerStayLag = new Dictionary<Collider2D, int>();

		private SensorMode oldDetectionMode;

		private bool oldRequiresLineOfSight;

		private List<Collider2D> collidersToRemove = new List<Collider2D>();

		private List<Collider2D> collidersToIncrement = new List<Collider2D>();

		private float timer;

		private List<GameObject> tempGOList = new List<GameObject>();

		public event SensorUpdateHandler OnSensorUpdate;

		public override void Pulse()
		{
			if (base.isActiveAndEnabled)
			{
				testSensor();
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			previousDetectedObjects.Clear();
			triggerStayLag.Clear();
			oldDetectionMode = DetectionMode;
			oldRequiresLineOfSight = RequiresLineOfSight;
			collidersToRemove.Clear();
			collidersToIncrement.Clear();
			if (!checkForTriggers())
			{
				UnityEngine.Debug.LogWarning("Trigger Sensor cannot detect anything if there are no triggers on the same GameObject.", base.gameObject);
			}
			if (GetComponent<Rigidbody2D>() == null)
			{
				UnityEngine.Debug.LogWarning("In order to detect GameObjects properly the TriggerSensor must itself have a RigidBody. Recommend adding a kinematic RigidBody.");
			}
			else if (GetComponent<Rigidbody2D>().sleepMode != 0)
			{
				UnityEngine.Debug.LogWarning("The rigidbody which owns the trigger collider should have its 'Sleeping Mode' parameter set to 'Never Sleep'");
			}
		}

		private void Update()
		{
			if (oldDetectionMode != DetectionMode || oldRequiresLineOfSight != RequiresLineOfSight)
			{
				sensorDetectionEvents();
				oldDetectionMode = DetectionMode;
				oldRequiresLineOfSight = RequiresLineOfSight;
			}
			collidersToRemove.Clear();
			collidersToIncrement.Clear();
			Dictionary<Collider2D, int>.Enumerator enumerator = triggerStayLag.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Collider2D key = enumerator.Current.Key;
				triggerStayLag.TryGetValue(key, out var value);
				if (value >= 10)
				{
					collidersToRemove.Add(key);
				}
				else
				{
					collidersToIncrement.Add(key);
				}
			}
			for (int i = 0; i < collidersToRemove.Count; i++)
			{
				removeCollider(collidersToRemove[i]);
			}
			for (int j = 0; j < collidersToIncrement.Count; j++)
			{
				Collider2D key2 = collidersToIncrement[j];
				triggerStayLag.TryGetValue(key2, out var value2);
				triggerStayLag[key2] = value2 + 1;
			}
			if (RequiresLineOfSight && LineOfSightUpdateMode == UpdateMode.FixedInterval)
			{
				timer += Time.deltaTime;
				if (timer > CheckLineOfSightInterval)
				{
					testSensor();
					timer = 0f;
				}
			}
			else
			{
				timer = 0f;
			}
		}

		private void OnTriggerEnter2D(Collider2D other)
		{
			addCollider(other);
		}

		private void OnTriggerStay2D(Collider2D other)
		{
			if (!triggerStayLag.ContainsKey(other))
			{
				addCollider(other);
			}
			triggerStayLag[other] = 0;
		}

		private void OnTriggerExit2D(Collider2D other)
		{
			removeCollider(other);
		}

		private new void addCollider(Collider2D other)
		{
			GameObject gameObject = base.addCollider(other);
			triggerStayLag[other] = 0;
			if (gameObject != null)
			{
				OnDetected.Invoke(gameObject, this);
				previousDetectedObjects.Add(gameObject);
			}
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private new void removeCollider(Collider2D other)
		{
			triggerStayLag.Remove(other);
			GameObject gameObject = base.removeCollider(other);
			if (gameObject != null)
			{
				OnLostDetection.Invoke(gameObject, this);
				previousDetectedObjects.Remove(gameObject);
			}
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void testSensor()
		{
			refreshLineOfSight();
			sensorDetectionEvents();
			if (this.OnSensorUpdate != null)
			{
				this.OnSensorUpdate();
			}
		}

		private void sensorDetectionEvents()
		{
			tempGOList.Clear();
			tempGOList.AddRange(DetectedObjects);
			List<GameObject>.Enumerator enumerator = DetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (previousDetectedObjects.Contains(current))
				{
					previousDetectedObjects.Remove(current);
				}
				else
				{
					OnDetected.Invoke(current, this);
				}
			}
			HashSet<GameObject>.Enumerator enumerator2 = previousDetectedObjects.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				GameObject current2 = enumerator2.Current;
				OnLostDetection.Invoke(current2, this);
			}
			previousDetectedObjects.Clear();
			enumerator = DetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				previousDetectedObjects.Add(enumerator.Current);
			}
		}

		private bool checkForTriggers()
		{
			if (GetComponent<Rigidbody2D>() != null)
			{
				Collider2D[] componentsInChildren = GetComponentsInChildren<Collider2D>();
				foreach (Collider2D collider2D in componentsInChildren)
				{
					if (collider2D.enabled && collider2D.isTrigger)
					{
						return true;
					}
				}
			}
			else
			{
				Collider2D[] componentsInChildren = GetComponents<Collider2D>();
				foreach (Collider2D collider2D2 in componentsInChildren)
				{
					if (collider2D2.enabled && collider2D2.isTrigger)
					{
						return true;
					}
				}
			}
			return false;
		}
	}
	[ExecuteInEditMode]
	public abstract class BaseAreaSensor : Sensor
	{
		private class RayCastTargetsCache : ObjectCache<RayCastTargets>
		{
			public override void Dispose(RayCastTargets obj)
			{
				obj.dispose();
				base.Dispose(obj);
			}
		}

		private struct RayCastResult
		{
			public GameObject go;

			public Vector2 testPoint;

			public Vector2 obstructionPoint;

			public bool isObstructed;
		}

		private class RayCastTargets
		{
			private GameObject go;

			private Transform[] targetTransforms;

			private List<Vector2> targetPoints;

			private List<Vector2> returnPoints;

			private List<bool> isTargetVisible;

			public RayCastTargets()
			{
				returnPoints = new List<Vector2>();
				isTargetVisible = new List<bool>();
			}

			public bool IsTransforms()
			{
				return targetTransforms != null;
			}

			public void Set(GameObject go, Transform[] targets)
			{
				this.go = go;
				targetTransforms = targets;
				targetPoints = null;
				isTargetVisible.Clear();
				for (int i = 0; i < targets.Length; i++)
				{
					isTargetVisible.Add(item: false);
				}
			}

			public void Set(GameObject go, List<Vector2> targets)
			{
				this.go = go;
				targetTransforms = null;
				targetPoints = targets;
				isTargetVisible.Clear();
				for (int i = 0; i < targets.Count; i++)
				{
					isTargetVisible.Add(item: false);
				}
			}

			public List<Transform> GetVisibleTransforms()
			{
				List<Transform> list = new List<Transform>();
				for (int i = 0; i < isTargetVisible.Count; i++)
				{
					if (isTargetVisible[i])
					{
						list.Add(targetTransforms[i]);
					}
				}
				return list;
			}

			public List<Vector2> GetVisibleTargetPositions()
			{
				List<Vector2> list = new List<Vector2>();
				if (targetTransforms != null)
				{
					for (int i = 0; i < isTargetVisible.Count; i++)
					{
						if (isTargetVisible[i])
						{
							list.Add(targetTransforms[i].position);
						}
					}
				}
				else
				{
					for (int j = 0; j < isTargetVisible.Count; j++)
					{
						if (isTargetVisible[j])
						{
							list.Add(go.transform.TransformPoint(targetPoints[j]));
						}
					}
				}
				return list;
			}

			public void SetIsTargetVisible(int i, bool isVisible)
			{
				isTargetVisible[i] = isVisible;
			}

			public List<Vector2> getTargetPoints()
			{
				returnPoints.Clear();
				if (targetTransforms != null)
				{
					for (int i = 0; i < targetTransforms.Length; i++)
					{
						returnPoints.Add(targetTransforms[i].position);
					}
				}
				else
				{
					GameObject gameObject = go;
					for (int j = 0; j < targetPoints.Count; j++)
					{
						returnPoints.Add(gameObject.transform.TransformPoint(targetPoints[j]));
					}
				}
				return returnPoints;
			}

			public void dispose()
			{
				if (targetPoints != null)
				{
					vector2ListCache.Dispose(targetPoints);
				}
			}
		}

		[UnityEngine.Tooltip("In Collider mode the sensor detects GameObjects attached to colliders. In RigidBody mode it detects the RigidBody GameObject attached to colliders.")]
		public SensorMode DetectionMode;

		[UnityEngine.Tooltip("GameObjects are only detected if they pass a line of sight test.")]
		public bool RequiresLineOfSight;

		[UnityEngine.Tooltip("Line of Sight rays will be tested against this layer mask.")]
		public LayerMask BlocksLineOfSight;

		[UnityEngine.Tooltip("If true will only perform line of sight tests on objects with a LOSTargets component, if false then the sensor will auto-generate test points for object which don't have this component.")]
		public bool TestLOSTargetsOnly;

		[Range(1f, 20f)]
		[UnityEngine.Tooltip("Number of test points the Sensor will generate on objects that don't have a LOSTargets component.")]
		public int NumberOfRays = 1;

		[Range(0f, 1f)]
		[UnityEngine.Tooltip("Minimum visibility an object must be for it to be detected.")]
		public float MinimumVisibility = 0.5f;

		public HashSet<GameObject> ShowRayCastDebug;

		private Dictionary<GameObject, List<Collider2D>> gameObjectColliders = new Dictionary<GameObject, List<Collider2D>>();

		private Dictionary<GameObject, List<Collider2D>> rigidBodyColliders = new Dictionary<GameObject, List<Collider2D>>();

		private Dictionary<Collider2D, GameObject> attachedRigidBody = new Dictionary<Collider2D, GameObject>();

		private Dictionary<GameObject, RayCastTargets> rayCastTargets = new Dictionary<GameObject, RayCastTargets>();

		private Dictionary<GameObject, float> objectVisibility = new Dictionary<GameObject, float>();

		private List<RayCastResult> raycastResults = new List<RayCastResult>();

		private List<GameObject> gameObjectList = new List<GameObject>();

		private List<GameObject> detectedObjects = new List<GameObject>();

		private List<GameObject> detectedObjectsOrderedByDistance = new List<GameObject>();

		private DistanceFromPointComparer distanceComparer = new DistanceFromPointComparer();

		private int prevNumberOfRays;

		protected static ListCache<Collider2D> colliderListCache = new ListCache<Collider2D>();

		protected static ListCache<Vector2> vector2ListCache = new ListCache<Vector2>();

		private static RayCastTargetsCache rayCastTargetsCache = new RayCastTargetsCache();

		protected static readonly Color GizmoColor = new Color(0.2f, 1f, 1f);

		protected static readonly Color GizmoBlockedColor = Color.red;

		public override List<GameObject> DetectedObjects
		{
			get
			{
				detectedObjects.Clear();
				if (RequiresLineOfSight)
				{
					Dictionary<GameObject, float>.Enumerator enumerator = objectVisibility.GetEnumerator();
					while (enumerator.MoveNext())
					{
						KeyValuePair<GameObject, float> current = enumerator.Current;
						GameObject key = current.Key;
						if (key != null && key.activeInHierarchy && !shouldIgnore(key) && current.Value >= MinimumVisibility)
						{
							detectedObjects.Add(key);
						}
					}
				}
				else if (DetectionMode == SensorMode.RigidBodies)
				{
					Dictionary<GameObject, List<Collider2D>>.Enumerator enumerator2 = rigidBodyColliders.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						GameObject key2 = enumerator2.Current.Key;
						if (key2 != null && key2.activeInHierarchy && !shouldIgnore(key2))
						{
							detectedObjects.Add(key2);
						}
					}
				}
				else
				{
					Dictionary<GameObject, List<Collider2D>>.Enumerator enumerator3 = gameObjectColliders.GetEnumerator();
					while (enumerator3.MoveNext())
					{
						GameObject key3 = enumerator3.Current.Key;
						if (key3 != null && key3.activeInHierarchy && !shouldIgnore(key3))
						{
							detectedObjects.Add(key3);
						}
					}
				}
				return detectedObjects;
			}
		}

		public override List<GameObject> DetectedObjectsOrderedByDistance
		{
			get
			{
				detectedObjectsOrderedByDistance.Clear();
				detectedObjectsOrderedByDistance.AddRange(DetectedObjects);
				distanceComparer.Point = base.transform.position;
				detectedObjectsOrderedByDistance.Sort(distanceComparer);
				return detectedObjectsOrderedByDistance;
			}
		}

		public Dictionary<GameObject, float> ObjectVisibilities => objectVisibility;

		public override float GetVisibility(GameObject go)
		{
			if (!RequiresLineOfSight)
			{
				return base.GetVisibility(go);
			}
			if (objectVisibility.ContainsKey(go))
			{
				return objectVisibility[go];
			}
			return 0f;
		}

		public List<Transform> GetVisibleTransforms(GameObject go)
		{
			if (go != null && rayCastTargets.TryGetValue(go, out var value))
			{
				return value.GetVisibleTransforms();
			}
			return new List<Transform>();
		}

		public List<Vector2> GetVisiblePositions(GameObject go)
		{
			if (go != null && rayCastTargets.TryGetValue(go, out var value))
			{
				return value.GetVisibleTargetPositions();
			}
			return new List<Vector2>();
		}

		protected virtual void OnEnable()
		{
			clearColliders();
			clearRayCastTargets();
			objectVisibility.Clear();
			raycastResults.Clear();
			gameObjectList.Clear();
		}

		protected GameObject addCollider(Collider2D c)
		{
			GameObject gameObject = null;
			GameObject gameObject2 = null;
			if (addColliderToMap(c, c.gameObject, gameObjectColliders))
			{
				disposeRayCastTarget(c.gameObject);
				gameObject = c.gameObject;
			}
			if (c.attachedRigidbody != null)
			{
				attachedRigidBody[c] = c.attachedRigidbody.gameObject;
				if (addColliderToMap(c, c.attachedRigidbody.gameObject, rigidBodyColliders))
				{
					disposeRayCastTarget(c.attachedRigidbody.gameObject);
					gameObject2 = c.attachedRigidbody.gameObject;
				}
			}
			GameObject gameObject3 = ((DetectionMode == SensorMode.Colliders) ? gameObject : gameObject2);
			if (shouldIgnore(gameObject3))
			{
				return null;
			}
			if (RequiresLineOfSight && gameObject3 != null)
			{
				bool flag = objectVisibility.ContainsKey(gameObject3) && objectVisibility[gameObject3] >= MinimumVisibility;
				RayCastTargets rayCastTargets = getRayCastTargets(gameObject3);
				if (TestLOSTargetsOnly && !rayCastTargets.IsTransforms())
				{
					return null;
				}
				objectVisibility[gameObject3] = testObjectVisibility(gameObject3, rayCastTargets);
				if (!flag && objectVisibility[gameObject3] >= MinimumVisibility)
				{
					return gameObject3;
				}
				return null;
			}
			return gameObject3;
		}

		protected GameObject removeCollider(Collider2D c)
		{
			if (c == null)
			{
				clearDestroyedGameObjects();
				return null;
			}
			GameObject gameObject = null;
			GameObject gameObject2 = null;
			if (removeColliderFromMap(c, c.gameObject, gameObjectColliders))
			{
				disposeRayCastTarget(c.gameObject);
				gameObject = c.gameObject;
			}
			if (attachedRigidBody.TryGetValue(c, out var value))
			{
				if (removeColliderFromMap(c, value, rigidBodyColliders))
				{
					disposeRayCastTarget(value);
					gameObject2 = value;
				}
				attachedRigidBody.Remove(c);
			}
			GameObject gameObject3 = ((DetectionMode == SensorMode.Colliders) ? gameObject : gameObject2);
			if (shouldIgnore(gameObject3))
			{
				return null;
			}
			if (RequiresLineOfSight && gameObject3 != null)
			{
				if (objectVisibility.TryGetValue(gameObject3, out var value2))
				{
					objectVisibility.Remove(gameObject3);
					if (value2 >= MinimumVisibility)
					{
						return gameObject3;
					}
				}
				return null;
			}
			return gameObject3;
		}

		protected void clearDestroyedGameObjects()
		{
			gameObjectList.Clear();
			Dictionary<GameObject, List<Collider2D>>.Enumerator enumerator = gameObjectColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject key = enumerator.Current.Key;
				if (key == null)
				{
					gameObjectList.Add(key);
				}
			}
			for (int i = 0; i < gameObjectList.Count; i++)
			{
				gameObjectColliders.Remove(gameObjectList[i]);
			}
			gameObjectList.Clear();
			Dictionary<GameObject, List<Collider2D>>.Enumerator enumerator2 = rigidBodyColliders.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				GameObject key2 = enumerator2.Current.Key;
				if (key2 == null)
				{
					gameObjectList.Add(key2);
				}
			}
			for (int j = 0; j < gameObjectList.Count; j++)
			{
				List<Collider2D> list = rigidBodyColliders[gameObjectList[j]];
				for (int k = 0; k < list.Count; k++)
				{
					attachedRigidBody.Remove(list[k]);
				}
				rigidBodyColliders.Remove(gameObjectList[j]);
			}
		}

		protected void clearColliders()
		{
			Dictionary<GameObject, List<Collider2D>>.Enumerator enumerator = gameObjectColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				List<Collider2D> value = enumerator.Current.Value;
				colliderListCache.Dispose(value);
			}
			gameObjectColliders.Clear();
			enumerator = rigidBodyColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				List<Collider2D> value2 = enumerator.Current.Value;
				colliderListCache.Dispose(value2);
			}
			rigidBodyColliders.Clear();
			attachedRigidBody.Clear();
			clearLineOfSight();
		}

		protected void clearLineOfSight()
		{
			objectVisibility.Clear();
			raycastResults.Clear();
		}

		protected void refreshLineOfSight()
		{
			if (prevNumberOfRays != NumberOfRays)
			{
				prevNumberOfRays = NumberOfRays;
				clearRayCastTargets();
			}
			objectVisibility.Clear();
			raycastResults.Clear();
			if (DetectionMode == SensorMode.RigidBodies)
			{
				Dictionary<GameObject, List<Collider2D>>.Enumerator enumerator = rigidBodyColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					GameObject key = enumerator.Current.Key;
					if (!(key == null) && !shouldIgnore(key))
					{
						RayCastTargets rayCastTargets = getRayCastTargets(key);
						if (!TestLOSTargetsOnly || rayCastTargets.IsTransforms())
						{
							objectVisibility[key] = testObjectVisibility(key, rayCastTargets);
						}
					}
				}
				return;
			}
			Dictionary<GameObject, List<Collider2D>>.Enumerator enumerator2 = gameObjectColliders.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				GameObject key2 = enumerator2.Current.Key;
				if (!(key2 == null) && !shouldIgnore(key2))
				{
					RayCastTargets rayCastTargets2 = getRayCastTargets(key2);
					if (!TestLOSTargetsOnly || rayCastTargets2.IsTransforms())
					{
						objectVisibility[key2] = testObjectVisibility(key2, rayCastTargets2);
					}
				}
			}
		}

		private float testObjectVisibility(GameObject go, RayCastTargets targets)
		{
			int num = 0;
			RayCastTargets rayCastTargets = getRayCastTargets(go);
			List<Vector2> targetPoints = rayCastTargets.getTargetPoints();
			for (int i = 0; i < targetPoints.Count; i++)
			{
				Vector2 testPoint = targetPoints[i];
				RayCastResult item = default(RayCastResult);
				item.go = go;
				item.testPoint = testPoint;
				item.isObstructed = false;
				if (isInLineOfSight(go, testPoint, out var obstructionPoint))
				{
					num++;
					rayCastTargets.SetIsTargetVisible(i, isVisible: true);
				}
				else
				{
					item.isObstructed = true;
					item.obstructionPoint = obstructionPoint;
					rayCastTargets.SetIsTargetVisible(i, isVisible: false);
				}
				raycastResults.Add(item);
			}
			return (float)num / (float)targetPoints.Count;
		}

		private RayCastTargets getRayCastTargets(GameObject go)
		{
			if (rayCastTargets.TryGetValue(go, out var value))
			{
				return value;
			}
			LOSTargets component = go.GetComponent<LOSTargets>();
			value = rayCastTargetsCache.Get();
			if (component != null && component.Targets != null)
			{
				value.Set(go, component.Targets);
				rayCastTargets.Add(go, value);
				return value;
			}
			value.Set(go, generateRayCastTargets(go));
			rayCastTargets.Add(go, value);
			return value;
		}

		private List<Vector2> generateRayCastTargets(GameObject go)
		{
			List<Collider2D> list = ((DetectionMode != 0) ? rigidBodyColliders[go] : gameObjectColliders[go]);
			List<Vector2> list2 = vector2ListCache.Get();
			if (NumberOfRays == 1)
			{
				list2.Add(getCentreOfColliders(go, list));
			}
			else
			{
				for (int i = 0; i < NumberOfRays; i++)
				{
					list2.Add(getRandomPointInColliders(go, list));
				}
			}
			return list2;
		}

		private bool isInLineOfSight(GameObject go, Vector2 testPoint, out Vector2 obstructionPoint)
		{
			obstructionPoint = Vector3.zero;
			Vector2 vector = testPoint - (Vector2)base.transform.position;
			RaycastHit2D raycastHit2D = Physics2D.Raycast(base.transform.position, vector.normalized, vector.magnitude, BlocksLineOfSight);
			if (raycastHit2D.collider != null)
			{
				if (DetectionMode == SensorMode.RigidBodies && raycastHit2D.rigidbody != null && raycastHit2D.rigidbody.gameObject == go)
				{
					return true;
				}
				if (DetectionMode == SensorMode.Colliders && raycastHit2D.collider.gameObject == go)
				{
					return true;
				}
				obstructionPoint = raycastHit2D.point;
				return false;
			}
			return true;
		}

		private Vector2 getCentreOfColliders(GameObject goRoot, List<Collider2D> goColliders)
		{
			Vector2 zero = Vector2.zero;
			for (int i = 0; i < goColliders.Count; i++)
			{
				Collider2D collider2D = goColliders[i];
				zero += (Vector2)collider2D.bounds.center - (Vector2)goRoot.transform.position;
			}
			return zero / goColliders.Count;
		}

		private Vector2 getRandomPointInColliders(GameObject goRoot, List<Collider2D> colliders)
		{
			Collider2D collider2D = colliders[0];
			float num = 0f;
			for (int i = 0; i < colliders.Count; i++)
			{
				Collider2D collider2D2 = colliders[i];
				num += collider2D2.bounds.size.x * collider2D2.bounds.size.y;
			}
			float num2 = UnityEngine.Random.Range(0f, 1f);
			for (int j = 0; j < colliders.Count; j++)
			{
				Collider2D collider2D3 = colliders[j];
				collider2D = collider2D3;
				float num3 = collider2D3.bounds.size.x * collider2D3.bounds.size.y;
				num2 -= num3 / num;
				if (num2 <= 0f)
				{
					break;
				}
			}
			Vector2 vector = new Vector2(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-0.5f, 0.5f));
			vector.Scale(collider2D.bounds.size);
			return vector + (Vector2)(collider2D.bounds.center - goRoot.transform.position);
		}

		private bool addColliderToMap(Collider2D c, GameObject go, Dictionary<GameObject, List<Collider2D>> dict)
		{
			bool result = false;
			if (!dict.TryGetValue(go, out var value))
			{
				result = true;
				value = (dict[go] = colliderListCache.Get());
			}
			if (!value.Contains(c))
			{
				value.Add(c);
			}
			return result;
		}

		private bool removeColliderFromMap(Collider2D c, GameObject go, Dictionary<GameObject, List<Collider2D>> dict)
		{
			bool result = false;
			if (dict.TryGetValue(go, out var value))
			{
				value.Remove(c);
				if (value.Count == 0)
				{
					result = true;
					dict.Remove(go);
					colliderListCache.Dispose(value);
				}
			}
			return result;
		}

		private void clearRayCastTargets()
		{
			Dictionary<GameObject, RayCastTargets>.Enumerator enumerator = rayCastTargets.GetEnumerator();
			while (enumerator.MoveNext())
			{
				RayCastTargets value = enumerator.Current.Value;
				rayCastTargetsCache.Dispose(value);
			}
			rayCastTargets.Clear();
		}

		private void disposeRayCastTarget(GameObject forGameObject)
		{
			if (rayCastTargets.ContainsKey(forGameObject))
			{
				rayCastTargetsCache.Dispose(rayCastTargets[forGameObject]);
				rayCastTargets.Remove(forGameObject);
			}
		}

		public virtual void OnDrawGizmosSelected()
		{
			if (!base.isActiveAndEnabled)
			{
				return;
			}
			Gizmos.color = GizmoColor;
			foreach (GameObject detectedObject in DetectedObjects)
			{
				Gizmos.DrawIcon(getCentreOfColliders(detectedObject, (DetectionMode == SensorMode.RigidBodies && rigidBodyColliders.ContainsKey(detectedObject)) ? rigidBodyColliders[detectedObject] : gameObjectColliders[detectedObject]) + (Vector2)detectedObject.transform.position, "SensorToolkit/eye.png", allowScaling: true);
			}
			if (!RequiresLineOfSight || ShowRayCastDebug == null)
			{
				return;
			}
			foreach (RayCastResult raycastResult in raycastResults)
			{
				if (ShowRayCastDebug.Contains(raycastResult.go))
				{
					Gizmos.color = GizmoColor;
					if (raycastResult.isObstructed)
					{
						Gizmos.DrawLine(base.transform.position, raycastResult.obstructionPoint);
						Gizmos.color = GizmoBlockedColor;
						Gizmos.DrawLine(raycastResult.obstructionPoint, raycastResult.testPoint);
						Gizmos.DrawCube(raycastResult.testPoint, Vector3.one * 0.1f);
					}
					else
					{
						Gizmos.DrawLine(base.transform.position, raycastResult.testPoint);
						Gizmos.DrawCube(raycastResult.testPoint, Vector3.one * 0.1f);
					}
				}
			}
		}
	}
	[ExecuteInEditMode]
	public abstract class BaseVolumeSensor : Sensor
	{
		private class RayCastTargetsCache : ObjectCache<RayCastTargets>
		{
			public override void Dispose(RayCastTargets obj)
			{
				obj.dispose();
				base.Dispose(obj);
			}
		}

		private struct RayCastResult
		{
			public GameObject go;

			public Vector3 testPoint;

			public Vector3 obstructionPoint;

			public bool isObstructed;
		}

		private class RayCastTargets
		{
			private GameObject go;

			private Transform[] targetTransforms;

			private List<Vector3> targetPoints;

			private List<Vector3> returnPoints;

			private List<bool> isTargetVisible;

			public RayCastTargets()
			{
				returnPoints = new List<Vector3>();
				isTargetVisible = new List<bool>();
			}

			public bool IsTransforms()
			{
				return targetTransforms != null;
			}

			public void Set(GameObject go, Transform[] targets)
			{
				this.go = go;
				targetTransforms = targets;
				targetPoints = null;
				isTargetVisible.Clear();
				for (int i = 0; i < targets.Length; i++)
				{
					isTargetVisible.Add(item: false);
				}
			}

			public void Set(GameObject go, List<Vector3> targets)
			{
				this.go = go;
				targetTransforms = null;
				targetPoints = targets;
				isTargetVisible.Clear();
				for (int i = 0; i < targets.Count; i++)
				{
					isTargetVisible.Add(item: false);
				}
			}

			public List<Transform> GetVisibleTransforms()
			{
				List<Transform> list = new List<Transform>();
				for (int i = 0; i < isTargetVisible.Count; i++)
				{
					if (isTargetVisible[i])
					{
						list.Add(targetTransforms[i]);
					}
				}
				return list;
			}

			public List<Vector3> GetVisibleTargetPositions()
			{
				List<Vector3> list = new List<Vector3>();
				if (targetTransforms != null)
				{
					for (int i = 0; i < isTargetVisible.Count; i++)
					{
						if (isTargetVisible[i])
						{
							list.Add(targetTransforms[i].position);
						}
					}
				}
				else
				{
					for (int j = 0; j < isTargetVisible.Count; j++)
					{
						if (isTargetVisible[j])
						{
							list.Add(go.transform.TransformPoint(targetPoints[j]));
						}
					}
				}
				return list;
			}

			public void SetIsTargetVisible(int i, bool isVisible)
			{
				isTargetVisible[i] = isVisible;
			}

			public List<Vector3> getTargetPoints()
			{
				returnPoints.Clear();
				if (targetTransforms != null)
				{
					for (int i = 0; i < targetTransforms.Length; i++)
					{
						returnPoints.Add(targetTransforms[i].position);
					}
				}
				else
				{
					GameObject gameObject = go;
					for (int j = 0; j < targetPoints.Count; j++)
					{
						returnPoints.Add(gameObject.transform.TransformPoint(targetPoints[j]));
					}
				}
				return returnPoints;
			}

			public void dispose()
			{
				if (targetPoints != null)
				{
					vector3ListCache.Dispose(targetPoints);
				}
			}
		}

		[UnityEngine.Tooltip("In Collider mode the sensor detects GameObjects attached to colliders. In RigidBody mode it detects the RigidBody GameObject attached to colliders.")]
		public SensorMode DetectionMode;

		[UnityEngine.Tooltip("GameObjects are only detected if they pass a line of sight test.")]
		public bool RequiresLineOfSight;

		[UnityEngine.Tooltip("Line of Sight rays will be tested against this layer mask.")]
		public LayerMask BlocksLineOfSight;

		[UnityEngine.Tooltip("If true will only perform line of sight tests on objects with a LOSTargets component, if false then the sensor will auto-generate test points for object which don't have this component.")]
		public bool TestLOSTargetsOnly;

		[Range(1f, 20f)]
		[UnityEngine.Tooltip("Number of test points the Sensor will generate on objects that don't have a LOSTargets component.")]
		public int NumberOfRays = 1;

		[Range(0f, 1f)]
		[UnityEngine.Tooltip("Minimum visibility an object must be for it to be detected.")]
		public float MinimumVisibility = 0.5f;

		public HashSet<GameObject> ShowRayCastDebug;

		private Dictionary<GameObject, List<Collider>> gameObjectColliders = new Dictionary<GameObject, List<Collider>>();

		private Dictionary<GameObject, List<Collider>> rigidBodyColliders = new Dictionary<GameObject, List<Collider>>();

		private Dictionary<Collider, GameObject> attachedRigidBody = new Dictionary<Collider, GameObject>();

		private Dictionary<GameObject, RayCastTargets> rayCastTargets = new Dictionary<GameObject, RayCastTargets>();

		private Dictionary<GameObject, float> objectVisibility = new Dictionary<GameObject, float>();

		private List<RayCastResult> raycastResults = new List<RayCastResult>();

		private List<GameObject> gameObjectList = new List<GameObject>();

		private List<GameObject> detectedObjects = new List<GameObject>();

		private List<GameObject> detectedObjectsOrderedByDistance = new List<GameObject>();

		private DistanceFromPointComparer distanceComparer = new DistanceFromPointComparer();

		private int prevNumberOfRays;

		protected static ListCache<Collider> colliderListCache = new ListCache<Collider>();

		protected static ListCache<Vector3> vector3ListCache = new ListCache<Vector3>();

		private static RayCastTargetsCache rayCastTargetsCache = new RayCastTargetsCache();

		protected static readonly Color GizmoColor = new Color(0.2f, 1f, 1f);

		protected static readonly Color GizmoBlockedColor = Color.red;

		public override List<GameObject> DetectedObjects
		{
			get
			{
				detectedObjects.Clear();
				if (RequiresLineOfSight)
				{
					Dictionary<GameObject, float>.Enumerator enumerator = objectVisibility.GetEnumerator();
					while (enumerator.MoveNext())
					{
						KeyValuePair<GameObject, float> current = enumerator.Current;
						GameObject key = current.Key;
						if (key != null && key.activeInHierarchy && !shouldIgnore(key) && current.Value >= MinimumVisibility)
						{
							detectedObjects.Add(key);
						}
					}
				}
				else if (DetectionMode == SensorMode.RigidBodies)
				{
					Dictionary<GameObject, List<Collider>>.Enumerator enumerator2 = rigidBodyColliders.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						GameObject key2 = enumerator2.Current.Key;
						if (key2 != null && key2.activeInHierarchy && !shouldIgnore(key2))
						{
							detectedObjects.Add(key2);
						}
					}
				}
				else
				{
					Dictionary<GameObject, List<Collider>>.Enumerator enumerator3 = gameObjectColliders.GetEnumerator();
					while (enumerator3.MoveNext())
					{
						GameObject key3 = enumerator3.Current.Key;
						if (key3 != null && key3.activeInHierarchy && !shouldIgnore(key3))
						{
							detectedObjects.Add(key3);
						}
					}
				}
				return detectedObjects;
			}
		}

		public override List<GameObject> DetectedObjectsOrderedByDistance
		{
			get
			{
				detectedObjectsOrderedByDistance.Clear();
				detectedObjectsOrderedByDistance.AddRange(DetectedObjects);
				distanceComparer.Point = base.transform.position;
				detectedObjectsOrderedByDistance.Sort(distanceComparer);
				return detectedObjectsOrderedByDistance;
			}
		}

		public Dictionary<GameObject, float> ObjectVisibilities => objectVisibility;

		public override float GetVisibility(GameObject go)
		{
			if (!RequiresLineOfSight)
			{
				return base.GetVisibility(go);
			}
			if (objectVisibility.ContainsKey(go))
			{
				return objectVisibility[go];
			}
			return 0f;
		}

		public List<Transform> GetVisibleTransforms(GameObject go)
		{
			if (go != null && rayCastTargets.TryGetValue(go, out var value))
			{
				return value.GetVisibleTransforms();
			}
			return new List<Transform>();
		}

		public List<Vector3> GetVisiblePositions(GameObject go)
		{
			if (go != null && rayCastTargets.TryGetValue(go, out var value))
			{
				return value.GetVisibleTargetPositions();
			}
			return new List<Vector3>();
		}

		protected virtual void OnEnable()
		{
			clearColliders();
			clearRayCastTargets();
			objectVisibility.Clear();
			raycastResults.Clear();
			gameObjectList.Clear();
		}

		protected GameObject addCollider(Collider c)
		{
			GameObject gameObject = null;
			GameObject gameObject2 = null;
			if (addColliderToMap(c, c.gameObject, gameObjectColliders))
			{
				disposeRayCastTarget(c.gameObject);
				gameObject = c.gameObject;
			}
			if (c.attachedRigidbody != null)
			{
				attachedRigidBody[c] = c.attachedRigidbody.gameObject;
				if (addColliderToMap(c, c.attachedRigidbody.gameObject, rigidBodyColliders))
				{
					disposeRayCastTarget(c.attachedRigidbody.gameObject);
					gameObject2 = c.attachedRigidbody.gameObject;
				}
			}
			GameObject gameObject3 = ((DetectionMode == SensorMode.Colliders) ? gameObject : gameObject2);
			if (shouldIgnore(gameObject3))
			{
				return null;
			}
			if (RequiresLineOfSight && gameObject3 != null)
			{
				bool flag = objectVisibility.ContainsKey(gameObject3) && objectVisibility[gameObject3] >= MinimumVisibility;
				RayCastTargets rayCastTargets = getRayCastTargets(gameObject3);
				if (TestLOSTargetsOnly && !rayCastTargets.IsTransforms())
				{
					return null;
				}
				objectVisibility[gameObject3] = testObjectVisibility(gameObject3, rayCastTargets);
				if (!flag && objectVisibility[gameObject3] >= MinimumVisibility)
				{
					return gameObject3;
				}
				return null;
			}
			return gameObject3;
		}

		protected GameObject removeCollider(Collider c)
		{
			if (c == null)
			{
				clearDestroyedGameObjects();
				return null;
			}
			GameObject gameObject = null;
			GameObject gameObject2 = null;
			if (removeColliderFromMap(c, c.gameObject, gameObjectColliders))
			{
				disposeRayCastTarget(c.gameObject);
				gameObject = c.gameObject;
			}
			if (attachedRigidBody.TryGetValue(c, out var value))
			{
				if (removeColliderFromMap(c, value, rigidBodyColliders))
				{
					disposeRayCastTarget(value);
					gameObject2 = value;
				}
				attachedRigidBody.Remove(c);
			}
			GameObject gameObject3 = ((DetectionMode == SensorMode.Colliders) ? gameObject : gameObject2);
			if (shouldIgnore(gameObject3))
			{
				return null;
			}
			if (RequiresLineOfSight && gameObject3 != null)
			{
				if (objectVisibility.TryGetValue(gameObject3, out var value2))
				{
					objectVisibility.Remove(gameObject3);
					if (value2 >= MinimumVisibility)
					{
						return gameObject3;
					}
				}
				return null;
			}
			return gameObject3;
		}

		protected void clearDestroyedGameObjects()
		{
			gameObjectList.Clear();
			Dictionary<GameObject, List<Collider>>.Enumerator enumerator = gameObjectColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject key = enumerator.Current.Key;
				if (key == null)
				{
					gameObjectList.Add(key);
				}
			}
			for (int i = 0; i < gameObjectList.Count; i++)
			{
				gameObjectColliders.Remove(gameObjectList[i]);
			}
			gameObjectList.Clear();
			Dictionary<GameObject, List<Collider>>.Enumerator enumerator2 = rigidBodyColliders.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				GameObject key2 = enumerator2.Current.Key;
				if (key2 == null)
				{
					gameObjectList.Add(key2);
				}
			}
			for (int j = 0; j < gameObjectList.Count; j++)
			{
				List<Collider> list = rigidBodyColliders[gameObjectList[j]];
				for (int k = 0; k < list.Count; k++)
				{
					attachedRigidBody.Remove(list[k]);
				}
				rigidBodyColliders.Remove(gameObjectList[j]);
			}
		}

		protected void clearColliders()
		{
			Dictionary<GameObject, List<Collider>>.Enumerator enumerator = gameObjectColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				List<Collider> value = enumerator.Current.Value;
				colliderListCache.Dispose(value);
			}
			gameObjectColliders.Clear();
			enumerator = rigidBodyColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				List<Collider> value2 = enumerator.Current.Value;
				colliderListCache.Dispose(value2);
			}
			rigidBodyColliders.Clear();
			attachedRigidBody.Clear();
			clearLineOfSight();
		}

		protected void clearLineOfSight()
		{
			objectVisibility.Clear();
			raycastResults.Clear();
		}

		protected void refreshLineOfSight()
		{
			if (prevNumberOfRays != NumberOfRays)
			{
				prevNumberOfRays = NumberOfRays;
				clearRayCastTargets();
			}
			objectVisibility.Clear();
			raycastResults.Clear();
			if (DetectionMode == SensorMode.RigidBodies)
			{
				Dictionary<GameObject, List<Collider>>.Enumerator enumerator = rigidBodyColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					GameObject key = enumerator.Current.Key;
					if (!(key == null) && !shouldIgnore(key))
					{
						RayCastTargets rayCastTargets = getRayCastTargets(key);
						if (!TestLOSTargetsOnly || rayCastTargets.IsTransforms())
						{
							objectVisibility[key] = testObjectVisibility(key, rayCastTargets);
						}
					}
				}
				return;
			}
			Dictionary<GameObject, List<Collider>>.Enumerator enumerator2 = gameObjectColliders.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				GameObject key2 = enumerator2.Current.Key;
				if (!(key2 == null) && !shouldIgnore(key2))
				{
					RayCastTargets rayCastTargets2 = getRayCastTargets(key2);
					if (!TestLOSTargetsOnly || rayCastTargets2.IsTransforms())
					{
						objectVisibility[key2] = testObjectVisibility(key2, rayCastTargets2);
					}
				}
			}
		}

		private float testObjectVisibility(GameObject go, RayCastTargets targets)
		{
			int num = 0;
			RayCastTargets rayCastTargets = getRayCastTargets(go);
			List<Vector3> targetPoints = rayCastTargets.getTargetPoints();
			for (int i = 0; i < targetPoints.Count; i++)
			{
				Vector3 testPoint = targetPoints[i];
				RayCastResult item = default(RayCastResult);
				item.go = go;
				item.testPoint = testPoint;
				item.isObstructed = false;
				if (isInLineOfSight(go, testPoint, out var obstructionPoint))
				{
					num++;
					rayCastTargets.SetIsTargetVisible(i, isVisible: true);
				}
				else
				{
					item.isObstructed = true;
					item.obstructionPoint = obstructionPoint;
					rayCastTargets.SetIsTargetVisible(i, isVisible: false);
				}
				raycastResults.Add(item);
			}
			return (float)num / (float)targetPoints.Count;
		}

		private RayCastTargets getRayCastTargets(GameObject go)
		{
			if (rayCastTargets.TryGetValue(go, out var value))
			{
				return value;
			}
			LOSTargets component = go.GetComponent<LOSTargets>();
			value = rayCastTargetsCache.Get();
			if (component != null && component.Targets != null)
			{
				value.Set(go, component.Targets);
				rayCastTargets.Add(go, value);
				return value;
			}
			value.Set(go, generateRayCastTargets(go));
			rayCastTargets.Add(go, value);
			return value;
		}

		private List<Vector3> generateRayCastTargets(GameObject go)
		{
			List<Collider> list = ((DetectionMode != 0) ? rigidBodyColliders[go] : gameObjectColliders[go]);
			List<Vector3> list2 = vector3ListCache.Get();
			if (NumberOfRays == 1)
			{
				list2.Add(getCentreOfColliders(go, list));
			}
			else
			{
				for (int i = 0; i < NumberOfRays; i++)
				{
					list2.Add(getRandomPointInColliders(go, list));
				}
			}
			return list2;
		}

		private bool isInLineOfSight(GameObject go, Vector3 testPoint, out Vector3 obstructionPoint)
		{
			obstructionPoint = Vector3.zero;
			Vector3 vector = testPoint - base.transform.position;
			if (Physics.Raycast(new Ray(base.transform.position, vector.normalized), out var hitInfo, vector.magnitude, BlocksLineOfSight))
			{
				if (DetectionMode == SensorMode.RigidBodies && hitInfo.rigidbody != null && hitInfo.rigidbody.gameObject == go)
				{
					return true;
				}
				if (DetectionMode == SensorMode.Colliders && hitInfo.collider.gameObject == go)
				{
					return true;
				}
				obstructionPoint = hitInfo.point;
				return false;
			}
			return true;
		}

		private Vector3 getCentreOfColliders(GameObject goRoot, List<Collider> goColliders)
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < goColliders.Count; i++)
			{
				Collider collider = goColliders[i];
				zero += collider.bounds.center - goRoot.transform.position;
			}
			return zero / goColliders.Count;
		}

		private Vector3 getRandomPointInColliders(GameObject goRoot, List<Collider> colliders)
		{
			Collider collider = colliders[0];
			float num = 0f;
			for (int i = 0; i < colliders.Count; i++)
			{
				Collider collider2 = colliders[i];
				num += collider2.bounds.size.x * collider2.bounds.size.y + collider2.bounds.size.z;
			}
			float num2 = UnityEngine.Random.Range(0f, 1f);
			for (int j = 0; j < colliders.Count; j++)
			{
				Collider collider3 = colliders[j];
				collider = collider3;
				float num3 = collider3.bounds.size.x * collider3.bounds.size.y * collider3.bounds.size.z;
				num2 -= num3 / num;
				if (num2 <= 0f)
				{
					break;
				}
			}
			Vector3 vector = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-0.5f, 0.5f));
			vector.Scale(collider.bounds.size);
			return vector + (collider.bounds.center - goRoot.transform.position);
		}

		private bool addColliderToMap(Collider c, GameObject go, Dictionary<GameObject, List<Collider>> dict)
		{
			bool result = false;
			if (!dict.TryGetValue(go, out var value))
			{
				result = true;
				value = (dict[go] = colliderListCache.Get());
			}
			if (!value.Contains(c))
			{
				value.Add(c);
			}
			return result;
		}

		private bool removeColliderFromMap(Collider c, GameObject go, Dictionary<GameObject, List<Collider>> dict)
		{
			bool result = false;
			if (dict.TryGetValue(go, out var value))
			{
				value.Remove(c);
				if (value.Count == 0)
				{
					result = true;
					dict.Remove(go);
					colliderListCache.Dispose(value);
				}
			}
			return result;
		}

		private void clearRayCastTargets()
		{
			Dictionary<GameObject, RayCastTargets>.Enumerator enumerator = rayCastTargets.GetEnumerator();
			while (enumerator.MoveNext())
			{
				RayCastTargets value = enumerator.Current.Value;
				rayCastTargetsCache.Dispose(value);
			}
			rayCastTargets.Clear();
		}

		private void disposeRayCastTarget(GameObject forGameObject)
		{
			if (rayCastTargets.ContainsKey(forGameObject))
			{
				rayCastTargetsCache.Dispose(rayCastTargets[forGameObject]);
				rayCastTargets.Remove(forGameObject);
			}
		}

		public virtual void OnDrawGizmosSelected()
		{
			if (!base.isActiveAndEnabled)
			{
				return;
			}
			Gizmos.color = GizmoColor;
			foreach (GameObject detectedObject in DetectedObjects)
			{
				Gizmos.DrawIcon(getCentreOfColliders(detectedObject, (DetectionMode == SensorMode.RigidBodies && rigidBodyColliders.ContainsKey(detectedObject)) ? rigidBodyColliders[detectedObject] : gameObjectColliders[detectedObject]) + detectedObject.transform.position, "SensorToolkit/eye.png", allowScaling: true);
			}
			if (!RequiresLineOfSight || ShowRayCastDebug == null)
			{
				return;
			}
			foreach (RayCastResult raycastResult in raycastResults)
			{
				if (ShowRayCastDebug.Contains(raycastResult.go))
				{
					Gizmos.color = GizmoColor;
					if (raycastResult.isObstructed)
					{
						Gizmos.DrawLine(base.transform.position, raycastResult.obstructionPoint);
						Gizmos.color = GizmoBlockedColor;
						Gizmos.DrawLine(raycastResult.obstructionPoint, raycastResult.testPoint);
						Gizmos.DrawCube(raycastResult.testPoint, Vector3.one * 0.1f);
					}
					else
					{
						Gizmos.DrawLine(base.transform.position, raycastResult.testPoint);
						Gizmos.DrawCube(raycastResult.testPoint, Vector3.one * 0.1f);
					}
				}
			}
		}
	}
	public class ObjectCache<T>
	{
		private Stack<T> cache;

		public ObjectCache()
			: this(10)
		{
		}

		public ObjectCache(int startSize)
		{
			cache = new Stack<T>();
			for (int i = 0; i < startSize; i++)
			{
				cache.Push(create());
			}
		}

		public T Get()
		{
			if (cache.Count > 0)
			{
				return cache.Pop();
			}
			return create();
		}

		public virtual void Dispose(T obj)
		{
			cache.Push(obj);
		}

		protected virtual T create()
		{
			return Activator.CreateInstance<T>();
		}
	}
	public class ListCache<T> : ObjectCache<List<T>>
	{
		public override void Dispose(List<T> obj)
		{
			obj.Clear();
			base.Dispose(obj);
		}
	}
	[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer), typeof(FOVCollider))]
	[ExecuteInEditMode]
	public class RenderFOVCollider : MonoBehaviour
	{
		private MeshFilter mf;

		private FOVCollider fov;

		private void Awake()
		{
			mf = GetComponent<MeshFilter>();
			fov = GetComponent<FOVCollider>();
		}

		private void Update()
		{
			if (mf.sharedMesh != fov.FOVMesh)
			{
				mf.sharedMesh = fov.FOVMesh;
			}
		}
	}
	[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer), typeof(FOVCollider2D))]
	[ExecuteInEditMode]
	public class RenderFOVCollider2D : MonoBehaviour
	{
		private MeshFilter mf;

		private FOVCollider2D fov;

		private void Awake()
		{
			mf = GetComponent<MeshFilter>();
			fov = GetComponent<FOVCollider2D>();
		}

		private void Update()
		{
			if (mf.sharedMesh != fov.FOVMesh)
			{
				mf.sharedMesh = fov.FOVMesh;
			}
		}
	}
	public enum SensorMode
	{
		Colliders,
		RigidBodies
	}
	public class TagSelectorAttribute : PropertyAttribute
	{
	}
	public abstract class Sensor : MonoBehaviour
	{
		[Serializable]
		public class SensorEventHandler : UnityEvent<Sensor>
		{
		}

		[Serializable]
		public class SensorDetectionEventHandler : UnityEvent<GameObject, Sensor>
		{
		}

		[UnityEngine.Tooltip("Any GameObject in this list will not be detected by this sensor, however it may still block line of sight.")]
		public List<GameObject> IgnoreList;

		[UnityEngine.Tooltip("When set to true the sensor will only detect objects whose tags are in the 'TagFilter' array.")]
		public bool EnableTagFilter;

		[UnityEngine.Tooltip("Array of tags that will be detected by the sensor.")]
		[TagSelector]
		public string[] AllowedTags;

		[SerializeField]
		public SensorDetectionEventHandler OnDetected;

		[SerializeField]
		public SensorDetectionEventHandler OnLostDetection;

		public abstract List<GameObject> DetectedObjects { get; }

		public abstract List<GameObject> DetectedObjectsOrderedByDistance { get; }

		protected virtual void Awake()
		{
			if (IgnoreList == null)
			{
				IgnoreList = new List<GameObject>();
			}
			if (OnDetected == null)
			{
				OnDetected = new SensorDetectionEventHandler();
			}
			if (OnLostDetection == null)
			{
				OnLostDetection = new SensorDetectionEventHandler();
			}
		}

		public virtual bool IsDetected(GameObject go)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjects.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (enumerator.Current == go)
				{
					return true;
				}
			}
			return false;
		}

		public virtual float GetVisibility(GameObject go)
		{
			if (!IsDetected(go))
			{
				return 0f;
			}
			return 1f;
		}

		public abstract void Pulse();

		public List<GameObject> GetDetected()
		{
			return new List<GameObject>(DetectedObjectsOrderedByDistance);
		}

		public List<T> GetDetectedByComponent<T>() where T : Component
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<T> list = new List<T>();
			while (enumerator.MoveNext())
			{
				T component = enumerator.Current.GetComponent<T>();
				if (component != null)
				{
					list.Add(component);
				}
			}
			return list;
		}

		public List<Component> GetDetectedByComponent(Type t)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<Component> list = new List<Component>();
			while (enumerator.MoveNext())
			{
				Component component = enumerator.Current.GetComponent(t);
				if (component != null)
				{
					list.Add(component);
				}
			}
			return list;
		}

		public List<GameObject> GetDetectedByName(string name)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<GameObject> list = new List<GameObject>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.name == name)
				{
					list.Add(current);
				}
			}
			return list;
		}

		public List<T> GetDetectedByNameAndComponent<T>(string name) where T : Component
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<T> list = new List<T>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.name == name)
				{
					T component = current.GetComponent<T>();
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list;
		}

		public List<Component> GetDetectedByNameAndComponent(string name, Type t)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<Component> list = new List<Component>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.name == name)
				{
					Component component = current.GetComponent<Component>();
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list;
		}

		public List<GameObject> GetDetectedByTag(string tag)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<GameObject> list = new List<GameObject>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.CompareTag(tag))
				{
					list.Add(current);
				}
			}
			return list;
		}

		public List<T> GetDetectedByTagAndComponent<T>(string tag) where T : Component
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<T> list = new List<T>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.CompareTag(tag))
				{
					T component = current.GetComponent<T>();
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list;
		}

		public List<Component> GetDetectedByTagAndComponent(string tag, Type t)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<Component> list = new List<Component>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.CompareTag(tag))
				{
					Component component = current.GetComponent(t);
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list;
		}

		public List<GameObject> GetDetectedByNameAndTag(string name, string tag)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<GameObject> list = new List<GameObject>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.CompareTag(tag) && current.name == name)
				{
					list.Add(current);
				}
			}
			return list;
		}

		public List<T> GetDetectedByNameAndTagAndComponent<T>(string name, string tag) where T : Component
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<T> list = new List<T>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.CompareTag(tag) && current.name == name)
				{
					T component = GetComponent<T>();
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list;
		}

		public List<Component> GetDetectedByNameAndTagAndComponent(string name, string tag, Type t)
		{
			List<GameObject>.Enumerator enumerator = DetectedObjectsOrderedByDistance.GetEnumerator();
			List<Component> list = new List<Component>();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.CompareTag(tag) && current.name == name)
				{
					Component component = GetComponent(t);
					if (component != null)
					{
						list.Add(component);
					}
				}
			}
			return list;
		}

		public GameObject GetNearestToPoint(Vector3 p)
		{
			return nearestToPoint(DetectedObjects, p);
		}

		public T GetNearestToPointByComponent<T>(Vector3 p) where T : Component
		{
			return nearestToPointWithComponent<T>(DetectedObjects, p);
		}

		public Component GetNearestToPointByComponent(Vector3 p, Type t)
		{
			return nearestToPointWithComponent(DetectedObjects, p, t);
		}

		public GameObject GetNearestToPointByName(Vector3 p, string name)
		{
			return nearestToPointWithName(DetectedObjects, p, name);
		}

		public T GetNearestToPointByNameAndComponent<T>(Vector3 p, string name) where T : Component
		{
			return nearestToPointWithNameAndComponent<T>(DetectedObjects, p, name);
		}

		public Component GetNearestToPointByNameAndComponent(Vector3 p, string name, Type t)
		{
			return nearestToPointWithNameAndComponent(DetectedObjects, p, name, t);
		}

		public GameObject GetNearestToPointByTag(Vector3 p, string tag)
		{
			return nearestToPointWithTag(DetectedObjects, p, tag);
		}

		public T GetNearestToPointByTagAndComponent<T>(Vector3 p, string tag) where T : Component
		{
			return nearestToPointWithTagAndComponent<T>(DetectedObjects, p, tag);
		}

		public Component GetNearestToPointByTagAndComponent(Vector3 p, string tag, Type t)
		{
			return nearestToPointWithTagAndComponent(DetectedObjects, p, tag, t);
		}

		public GameObject GetNearestToPointByNameAndTag(Vector3 p, string name, string tag)
		{
			return nearestToPointWithNameAndTag(DetectedObjects, p, name, tag);
		}

		public T GetNearestToPointByNameAndTagAndComponent<T>(Vector3 p, string name, string tag) where T : Component
		{
			return nearestToPointWithNameAndTagAndComponent<T>(DetectedObjects, p, name, tag);
		}

		public Component GetNearestToPointByNameAndTagAndComponent(Vector3 p, string name, string tag, Type t)
		{
			return nearestToPointWithNameAndTagAndComponent(DetectedObjects, p, name, tag, t);
		}

		public GameObject GetNearest()
		{
			return nearestToPoint(DetectedObjects, base.transform.position);
		}

		public T GetNearestByComponent<T>() where T : Component
		{
			return nearestToPointWithComponent<T>(DetectedObjects, base.transform.position);
		}

		public Component GetNearestByComponent(Type t)
		{
			return nearestToPointWithComponent(DetectedObjects, base.transform.position, t);
		}

		public GameObject GetNearestByName(string name)
		{
			return nearestToPointWithName(DetectedObjects, base.transform.position, name);
		}

		public T GetNearestByNameAndComponent<T>(string name) where T : Component
		{
			return nearestToPointWithNameAndComponent<T>(DetectedObjects, base.transform.position, name);
		}

		public Component GetNearestByNameAndComponent(string name, Type t)
		{
			return nearestToPointWithNameAndComponent(DetectedObjects, base.transform.position, name, t);
		}

		public GameObject GetNearestByTag(string tag)
		{
			return nearestToPointWithTag(DetectedObjects, base.transform.position, tag);
		}

		public T GetNearestByTagAndComponent<T>(string tag) where T : Component
		{
			return nearestToPointWithTagAndComponent<T>(DetectedObjects, base.transform.position, tag);
		}

		public Component GetNearestByTagAndComponent(string tag, Type t)
		{
			return nearestToPointWithTagAndComponent(DetectedObjects, base.transform.position, tag, t);
		}

		public GameObject GetNearestByNameAndTag(string name, string tag)
		{
			return nearestToPointWithNameAndTag(DetectedObjects, base.transform.position, name, tag);
		}

		public T GetNearestByNameAndTagAndComponent<T>(string name, string tag) where T : Component
		{
			return nearestToPointWithNameAndTagAndComponent<T>(DetectedObjects, base.transform.position, name, tag);
		}

		public Component GetNearestByNameAndTagAndComponent(string name, string tag, Type t)
		{
			return nearestToPointWithNameAndTagAndComponent(DetectedObjects, base.transform.position, name, tag, t);
		}

		protected bool shouldIgnore(GameObject go)
		{
			if (EnableTagFilter)
			{
				bool flag = false;
				for (int i = 0; i < AllowedTags.Length; i++)
				{
					if (AllowedTags[i] != "" && go != null && go.CompareTag(AllowedTags[i]))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return true;
				}
			}
			for (int j = 0; j < IgnoreList.Count; j++)
			{
				if (IgnoreList[j] == go)
				{
					return true;
				}
			}
			return false;
		}

		private GameObject nearestToPoint(List<GameObject> gos, Vector3 point)
		{
			GameObject gameObject = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				float num2 = Vector3.SqrMagnitude(current.transform.position - point);
				if (gameObject == null || num2 < num)
				{
					gameObject = current;
					num = num2;
				}
			}
			return gameObject;
		}

		private T nearestToPointWithComponent<T>(List<GameObject> gos, Vector3 point) where T : Component
		{
			T val = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				T component = current.GetComponent<T>();
				if (!(component == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (val == null || num2 < num)
					{
						val = component;
						num = num2;
					}
				}
			}
			return val;
		}

		private Component nearestToPointWithComponent(List<GameObject> gos, Vector3 point, Type t)
		{
			Component component = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				Component component2 = current.GetComponent(t);
				if (!(component2 == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (component == null || num2 < num)
					{
						component = component2;
						num = num2;
					}
				}
			}
			return component;
		}

		private GameObject nearestToPointWithName(List<GameObject> gos, Vector3 point, string name)
		{
			GameObject gameObject = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (!(current.name != name))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (gameObject == null || num2 < num)
					{
						gameObject = current;
						num = num2;
					}
				}
			}
			return gameObject;
		}

		private T nearestToPointWithNameAndComponent<T>(List<GameObject> gos, Vector3 point, string name) where T : Component
		{
			T val = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.name != name)
				{
					continue;
				}
				T component = current.GetComponent<T>();
				if (!(component == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (val == null || num2 < num)
					{
						val = component;
						num = num2;
					}
				}
			}
			return val;
		}

		private Component nearestToPointWithNameAndComponent(List<GameObject> gos, Vector3 point, string name, Type t)
		{
			Component component = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.name != name)
				{
					continue;
				}
				Component component2 = current.GetComponent(t);
				if (!(component2 == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (component == null || num2 < num)
					{
						component = component2;
						num = num2;
					}
				}
			}
			return component;
		}

		private GameObject nearestToPointWithTag(List<GameObject> gos, Vector3 point, string tag)
		{
			GameObject gameObject = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.CompareTag(tag))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (gameObject == null || num2 < num)
					{
						gameObject = current;
						num = num2;
					}
				}
			}
			return gameObject;
		}

		private T nearestToPointWithTagAndComponent<T>(List<GameObject> gos, Vector3 point, string tag) where T : Component
		{
			T val = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (!current.CompareTag(tag))
				{
					continue;
				}
				T component = current.GetComponent<T>();
				if (!(component == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (val == null || num2 < num)
					{
						val = component;
						num = num2;
					}
				}
			}
			return val;
		}

		private Component nearestToPointWithTagAndComponent(List<GameObject> gos, Vector3 point, string tag, Type t)
		{
			Component component = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (!current.CompareTag(tag))
				{
					continue;
				}
				Component component2 = current.GetComponent(t);
				if (!(component2 == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (component == null || num2 < num)
					{
						component = component2;
						num = num2;
					}
				}
			}
			return component;
		}

		private GameObject nearestToPointWithNameAndTag(List<GameObject> gos, Vector3 point, string name, string tag)
		{
			GameObject gameObject = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (!(current.name != name) && current.CompareTag(tag))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (gameObject == null || num2 < num)
					{
						gameObject = current;
						num = num2;
					}
				}
			}
			return gameObject;
		}

		private T nearestToPointWithNameAndTagAndComponent<T>(List<GameObject> gos, Vector3 point, string name, string tag) where T : Component
		{
			T val = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.name != name || !current.CompareTag(tag))
				{
					continue;
				}
				T component = current.GetComponent<T>();
				if (!(component == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (val == null || num2 < num)
					{
						val = component;
						num = num2;
					}
				}
			}
			return val;
		}

		private Component nearestToPointWithNameAndTagAndComponent(List<GameObject> gos, Vector3 point, string name, string tag, Type t)
		{
			Component component = null;
			float num = 0f;
			List<GameObject>.Enumerator enumerator = gos.GetEnumerator();
			while (enumerator.MoveNext())
			{
				GameObject current = enumerator.Current;
				if (current.name != name || !current.CompareTag(tag))
				{
					continue;
				}
				Component component2 = current.GetComponent(t);
				if (!(component2 == null))
				{
					float num2 = Vector3.SqrMagnitude(current.transform.position - point);
					if (component == null || num2 < num)
					{
						component = component2;
						num = num2;
					}
				}
			}
			return component;
		}
	}
	public class DistanceFromPointComparer : IComparer<GameObject>
	{
		public Vector3 Point;

		public int Compare(GameObject x, GameObject y)
		{
			float num = Vector3.SqrMagnitude(x.transform.position - Point);
			float num2 = Vector3.SqrMagnitude(y.transform.position - Point);
			if (num < num2)
			{
				return -1;
			}
			if (num > num2)
			{
				return 1;
			}
			return 0;
		}
	}
}
namespace SensorToolkit.PlayMaker
{
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Compute the steered direction from a target direction which avoids nearby obstacles.")]
	public class GetSteeredDirection : SensorToolkitComponentAction<SteeringRig>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[HutongGames.PlayMaker.Tooltip("The target direction to be steered.")]
		public FsmVector3 targetDirection;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the steered direction.")]
		public FsmVector3 storeSteeredDirection;

		[HutongGames.PlayMaker.Tooltip("Compute steered vector every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			targetDirection = null;
			storeSteeredDirection = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)) && targetDirection != null)
			{
				storeSteeredDirection.Value = base.steeringRig.GetSteeredDirection(targetDirection.Value);
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Compute the steered direction from a target direction which avoids nearby obstacles. For use with the 2D Steering rig.")]
	public class GetSteeredDirection2D : SensorToolkitComponentAction<SteeringRig2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig2D))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[HutongGames.PlayMaker.Tooltip("The target direction to be steered.")]
		public FsmVector2 targetDirection;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the steered direction.")]
		public FsmVector2 storeSteeredDirection;

		[HutongGames.PlayMaker.Tooltip("Compute steered vector every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			targetDirection = null;
			storeSteeredDirection = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)) && targetDirection != null)
			{
				storeSteeredDirection.Value = base.steeringRig.GetSteeredDirection(targetDirection.Value);
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Manually perform a test on a sensor to refresh it's list of detected GameObjects.")]
	public class PulseSensor : SensorToolkitComponentAction<Sensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[HutongGames.PlayMaker.Tooltip("Perform test every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				base.sensor.Pulse();
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a 2D Ray Sensor for the RaycastHit details of a GameObject it has detected.")]
	public class RaySensor2DGetRaycastHit : SensorToolkitComponentAction<RaySensor2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(RaySensor2D))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Ray Sensor.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("A GameObject detected by this sensor to get the RaycastHit details for.")]
		public FsmGameObject detectedGameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the rays distance to the detected GameObject, if there is one.")]
		public FsmFloat storeDistance;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the position of the ray intersection point, if there is one.")]
		public FsmVector2 storePoint;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the normal to the ray intersection point, if there is one.")]
		public FsmVector2 storeNormal;

		public override void Reset()
		{
			gameObject = null;
			detectedGameObject = null;
			storeDistance = null;
			storePoint = null;
			storeNormal = null;
		}

		public override void OnEnter()
		{
			doCheck();
			Finish();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)) && !detectedGameObject.IsNone)
			{
				RaycastHit2D rayHit = base.raySensor2D.GetRayHit(detectedGameObject.Value);
				storeDistance.Value = rayHit.distance;
				storePoint.Value = rayHit.point;
				storeNormal.Value = rayHit.normal;
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a 2D Ray Sensor to determine if it's obstructed.")]
	public class RaySensor2DObstructed : SensorToolkitComponentAction<RaySensor2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(RaySensor2D))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Ray Sensor.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the result, is it obstructed or not.")]
		public FsmBool storeIsObstructed;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the GameObject obstructing the sensor, if there is one.")]
		public FsmGameObject storeObstruction;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the distance to the obstruction, if there is one.")]
		public FsmFloat storeDistance;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the position of the obstruction point, if there is one.")]
		public FsmVector2 storePoint;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the normal to the obstruction point, if there is one.")]
		public FsmVector2 storeNormal;

		[HutongGames.PlayMaker.Tooltip("Fires this event if obstructed.")]
		public FsmEvent obstructedEvent;

		[HutongGames.PlayMaker.Tooltip("Fires this event if not obstructed.")]
		public FsmEvent notObstructedEvent;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeIsObstructed = null;
			storeObstruction = null;
			storeDistance = float.PositiveInfinity;
			storePoint = null;
			storeNormal = null;
			obstructedEvent = null;
			notObstructedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				storeIsObstructed.Value = base.raySensor2D.IsObstructed;
				storeObstruction.Value = (storeIsObstructed.Value ? base.raySensor2D.ObstructedBy.gameObject : null);
				storeDistance.Value = base.raySensor2D.ObstructionRayHit.distance;
				storePoint.Value = base.raySensor2D.ObstructionRayHit.point;
				storeNormal.Value = base.raySensor2D.ObstructionRayHit.normal;
				if (storeIsObstructed.Value)
				{
					base.Fsm.Event(obstructedEvent);
				}
				else
				{
					base.Fsm.Event(notObstructedEvent);
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a Ray Sensor for the RaycastHit details of a GameObject it has detected.")]
	public class RaySensorGetRaycastHit : SensorToolkitComponentAction<RaySensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(RaySensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Ray Sensor.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("A GameObject detected by this sensor to get the RaycastHit details for.")]
		public FsmGameObject detectedGameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the rays distance to the detected GameObject, if there is one.")]
		public FsmFloat storeDistance;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the position of the ray intersection point, if there is one.")]
		public FsmVector3 storePoint;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the normal to the ray intersection point, if there is one.")]
		public FsmVector3 storeNormal;

		public override void Reset()
		{
			gameObject = null;
			detectedGameObject = null;
			storeDistance = null;
			storePoint = null;
			storeNormal = null;
		}

		public override void OnEnter()
		{
			doCheck();
			Finish();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)) && !detectedGameObject.IsNone)
			{
				RaycastHit rayHit = base.raySensor.GetRayHit(detectedGameObject.Value);
				storeDistance.Value = rayHit.distance;
				storePoint.Value = rayHit.point;
				storeNormal.Value = rayHit.normal;
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a Ray Sensor to determine if it's obstructed.")]
	public class RaySensorObstructed : SensorToolkitComponentAction<RaySensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(RaySensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Ray Sensor.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the result, is it obstructed or not.")]
		public FsmBool storeIsObstructed;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the GameObject obstructing the sensor, if there is one.")]
		public FsmGameObject storeObstruction;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the distance to the obstruction, if there is one.")]
		public FsmFloat storeDistance;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the position of the obstruction point, if there is one.")]
		public FsmVector3 storePoint;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the normal to the obstruction point, if there is one.")]
		public FsmVector3 storeNormal;

		[HutongGames.PlayMaker.Tooltip("Fires this event if obstructed.")]
		public FsmEvent obstructedEvent;

		[HutongGames.PlayMaker.Tooltip("Fires this event if not obstructed.")]
		public FsmEvent notObstructedEvent;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeIsObstructed = null;
			storeObstruction = null;
			storeDistance = float.PositiveInfinity;
			storePoint = null;
			storeNormal = null;
			obstructedEvent = null;
			notObstructedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				storeIsObstructed.Value = base.raySensor.IsObstructed;
				storeObstruction.Value = (storeIsObstructed.Value ? base.raySensor.ObstructedBy.gameObject : null);
				storeDistance.Value = base.raySensor.ObstructionRayHit.distance;
				storePoint.Value = base.raySensor.ObstructionRayHit.point;
				storeNormal.Value = base.raySensor.ObstructionRayHit.normal;
				if (storeIsObstructed.Value)
				{
					base.Fsm.Event(obstructedEvent);
				}
				else
				{
					base.Fsm.Event(notObstructedEvent);
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("React to a sensors detection events. Can listen for new GameObjects being detected, or losing sight of GameObjects that are already detected.")]
	public class SensorDetectionEvent : SensorToolkitComponentAction<Sensor>
	{
		public enum EventType
		{
			NewDetection,
			LostDetection
		}

		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[HutongGames.PlayMaker.Tooltip("The sensor event that triggers this action.")]
		public EventType trigger;

		[HutongGames.PlayMaker.Tooltip("The FSM event to send.")]
		public FsmEvent sendEvent;

		[HutongGames.PlayMaker.Tooltip("Stores the GameObject that was Detected/Lost.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeGameObject;

		public override void Reset()
		{
			gameObject = null;
			trigger = EventType.NewDetection;
			sendEvent = null;
			storeGameObject = null;
		}

		public override void OnEnter()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				if (trigger == EventType.NewDetection)
				{
					base.sensor.OnDetected.AddListener(doEvent);
				}
				else
				{
					base.sensor.OnLostDetection.AddListener(doEvent);
				}
			}
		}

		public override void OnExit()
		{
			if (!(base.sensor == null))
			{
				if (trigger == EventType.NewDetection)
				{
					base.sensor.OnDetected.RemoveListener(doEvent);
				}
				else
				{
					base.sensor.OnLostDetection.RemoveListener(doEvent);
				}
			}
		}

		private void doEvent(GameObject go, Sensor sensor)
		{
			storeGameObject.Value = go;
			base.Fsm.Event(sendEvent);
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a sensor for all GameObjects it has detected.")]
	public class SensorGetDetected : SensorToolkitComponentAction<Sensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[HutongGames.PlayMaker.Tooltip("Filter detected GameObjects with the specified tag.")]
		public FsmString tag;

		[HutongGames.PlayMaker.Tooltip("Filter detected GameObjects with the specified name.")]
		public FsmString name;

		[HutongGames.PlayMaker.Tooltip("Filter detected GameObjects with the specified component type and store them here.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Unknown, "", 0, 0, 65536)]
		public FsmArray storeComponents;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores GameObjects detected by the sensor, if there is one.")]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray storeDetected;

		[HutongGames.PlayMaker.Tooltip("Fires this event if there is at least one detected GameObject that matches the search filters.")]
		public FsmEvent detectedEvent;

		[HutongGames.PlayMaker.Tooltip("Fires this event if no GameObject is detected that matches the search filters.")]
		public FsmEvent noneDetectedEvent;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			tag = null;
			name = null;
			storeComponents = null;
			storeDetected = null;
			detectedEvent = null;
			noneDetectedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		public override string ErrorCheck()
		{
			if (!storeComponents.IsNone && !storeComponents.ObjectType.IsSubclassOf(typeof(Component)))
			{
				return "'Store Components' array type must be a subclass of UnityEngine.Component";
			}
			return base.ErrorCheck();
		}

		private void doCheck()
		{
			if (!UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				return;
			}
			if (!storeComponents.IsNone)
			{
				Type objectType = storeComponents.ObjectType;
				if (!objectType.IsSubclassOf(typeof(Component)))
				{
					LogError("'Store Components' array type must be a subclass of UnityEngine.Component");
					return;
				}
				if (!string.IsNullOrEmpty(tag.Value))
				{
					if (!string.IsNullOrEmpty(name.Value))
					{
						FsmArray fsmArray = storeComponents;
						object[] values = base.sensor.GetDetectedByNameAndTagAndComponent(name.Value, tag.Value, objectType).ToArray();
						fsmArray.Values = values;
					}
					else
					{
						FsmArray fsmArray2 = storeComponents;
						object[] values = base.sensor.GetDetectedByTagAndComponent(tag.Value, objectType).ToArray();
						fsmArray2.Values = values;
					}
				}
				else if (!string.IsNullOrEmpty(name.Value))
				{
					FsmArray fsmArray3 = storeComponents;
					object[] values = base.sensor.GetDetectedByNameAndComponent(name.Value, objectType).ToArray();
					fsmArray3.Values = values;
				}
				else
				{
					FsmArray fsmArray4 = storeComponents;
					object[] values = base.sensor.GetDetectedByComponent(objectType).ToArray();
					fsmArray4.Values = values;
				}
				if (storeComponents.Values != null)
				{
					FsmArray fsmArray5 = storeDetected;
					object[] values = storeComponents.Values.Select((object c) => (c as Component).gameObject).ToArray();
					fsmArray5.Values = values;
				}
				else
				{
					storeDetected.Values = null;
				}
			}
			else if (!string.IsNullOrEmpty(tag.Value))
			{
				if (!string.IsNullOrEmpty(name.Value))
				{
					FsmArray fsmArray6 = storeDetected;
					object[] values = base.sensor.GetDetectedByNameAndTag(name.Value, tag.Value).ToArray();
					fsmArray6.Values = values;
				}
				else
				{
					FsmArray fsmArray7 = storeDetected;
					object[] values = base.sensor.GetDetectedByTag(tag.Value).ToArray();
					fsmArray7.Values = values;
				}
			}
			else if (!string.IsNullOrEmpty(name.Value))
			{
				FsmArray fsmArray8 = storeDetected;
				object[] values = base.sensor.GetDetectedByName(name.Value).ToArray();
				fsmArray8.Values = values;
			}
			else
			{
				FsmArray fsmArray9 = storeDetected;
				object[] values = base.sensor.GetDetected().ToArray();
				fsmArray9.Values = values;
			}
			if (storeDetected.Values.Length != 0)
			{
				base.Fsm.Event(detectedEvent);
			}
			else
			{
				base.Fsm.Event(noneDetectedEvent);
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a sensor for it's nearest detected gameobject.")]
	public class SensorGetNearest : SensorToolkitComponentAction<Sensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[HutongGames.PlayMaker.Tooltip("Find the nearest detected GameObject with the specified tag.")]
		public FsmString tag;

		[HutongGames.PlayMaker.Tooltip("Find the nearest detected GameObject with the specified name.")]
		public FsmString name;

		[HutongGames.PlayMaker.Tooltip("Find the nearest detected GameObject with the specified component type and store it here.")]
		[UIHint(UIHint.Variable)]
		public FsmObject storeComponent;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the nearest GameObject detected by the sensor, if there are any.")]
		public FsmGameObject storeNearest;

		[HutongGames.PlayMaker.Tooltip("Fires this event if there is a detected GameObject that matches the search filter.")]
		public FsmEvent detectedEvent;

		[HutongGames.PlayMaker.Tooltip("Fires this event if no GameObject is detected that matches the search filter.")]
		public FsmEvent noneDetectedEvent;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			tag = null;
			name = null;
			storeComponent = null;
			storeNearest = null;
			detectedEvent = null;
			noneDetectedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		public override string ErrorCheck()
		{
			if (!storeComponent.IsNone && !storeComponent.ObjectType.IsSubclassOf(typeof(Component)))
			{
				return "'Store Component type must be a subclass of UnityEngine.Component";
			}
			return base.ErrorCheck();
		}

		private void doCheck()
		{
			if (!UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				return;
			}
			if (!storeComponent.IsNone)
			{
				Type objectType = storeComponent.ObjectType;
				if (!string.IsNullOrEmpty(tag.Value))
				{
					if (!string.IsNullOrEmpty(name.Value))
					{
						storeComponent.Value = base.sensor.GetNearestByNameAndTagAndComponent(name.Value, tag.Value, objectType);
					}
					else
					{
						storeComponent.Value = base.sensor.GetNearestByTagAndComponent(tag.Value, objectType);
					}
				}
				else if (!string.IsNullOrEmpty(name.Value))
				{
					storeComponent.Value = base.sensor.GetNearestByNameAndComponent(name.Value, objectType);
				}
				else
				{
					storeComponent.Value = base.sensor.GetNearestByComponent(objectType);
				}
				if (storeComponent.Value != null)
				{
					storeNearest.Value = (storeComponent.Value as Component).gameObject;
				}
				else
				{
					storeNearest.Value = null;
				}
			}
			else if (!string.IsNullOrEmpty(tag.Value))
			{
				if (!string.IsNullOrEmpty(name.Value))
				{
					storeNearest.Value = base.sensor.GetNearestByNameAndTag(name.Value, tag.Value);
				}
				else
				{
					storeNearest.Value = base.sensor.GetNearestByTag(tag.Value);
				}
			}
			else if (!string.IsNullOrEmpty(name.Value))
			{
				storeNearest.Value = base.sensor.GetNearestByName(name.Value);
			}
			else
			{
				storeNearest.Value = base.sensor.GetNearest();
			}
			if (storeNearest.Value != null)
			{
				base.Fsm.Event(detectedEvent);
			}
			else
			{
				base.Fsm.Event(noneDetectedEvent);
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a sensor for the nearest detected GameObject to a specified world position.")]
	public class SensorGetNearestToPoint : SensorToolkitComponentAction<Sensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The world position to measure distance from.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 P;

		[HutongGames.PlayMaker.Tooltip("Filter detected GameObjects with the specified tag.")]
		public FsmString tag;

		[HutongGames.PlayMaker.Tooltip("Filter detected GameObjects with the specified name.")]
		public FsmString name;

		[HutongGames.PlayMaker.Tooltip("Filter detected GameObjects with the specified component and store the one belonging to the nearest GameObject here.")]
		[UIHint(UIHint.Variable)]
		public FsmObject storeComponent;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the GameObject nearest to the specified world position, if there are any.")]
		public FsmGameObject storeNearest;

		[HutongGames.PlayMaker.Tooltip("Fires this event if there is a detected GameObject that matches the search filter.")]
		public FsmEvent detectedEvent;

		[HutongGames.PlayMaker.Tooltip("Fires this event if no GameObject is detected that matches the search filter.")]
		public FsmEvent noneDetectedEvent;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			P = null;
			tag = null;
			name = null;
			storeComponent = null;
			storeNearest = null;
			detectedEvent = null;
			noneDetectedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		public override string ErrorCheck()
		{
			if (!storeComponent.IsNone && !storeComponent.ObjectType.IsSubclassOf(typeof(Component)))
			{
				return "'Store Component type must be a subclass of UnityEngine.Component";
			}
			return base.ErrorCheck();
		}

		private void doCheck()
		{
			if (!UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				return;
			}
			if (!storeComponent.IsNone)
			{
				Type objectType = storeComponent.ObjectType;
				if (!string.IsNullOrEmpty(tag.Value))
				{
					if (!string.IsNullOrEmpty(name.Value))
					{
						storeComponent.Value = base.sensor.GetNearestToPointByNameAndTagAndComponent(P.Value, name.Value, tag.Value, objectType);
					}
					else
					{
						storeComponent.Value = base.sensor.GetNearestToPointByTagAndComponent(P.Value, tag.Value, objectType);
					}
				}
				else if (!string.IsNullOrEmpty(name.Value))
				{
					storeComponent.Value = base.sensor.GetNearestToPointByNameAndComponent(P.Value, name.Value, objectType);
				}
				else
				{
					storeComponent.Value = base.sensor.GetNearestToPointByComponent(P.Value, objectType);
				}
				if (storeComponent.Value != null)
				{
					storeNearest.Value = (storeComponent.Value as Component).gameObject;
				}
				else
				{
					storeNearest.Value = null;
				}
			}
			else if (!string.IsNullOrEmpty(tag.Value))
			{
				if (!string.IsNullOrEmpty(name.Value))
				{
					storeNearest.Value = base.sensor.GetNearestToPointByNameAndTag(P.Value, name.Value, tag.Value);
				}
				else
				{
					storeNearest.Value = base.sensor.GetNearestToPointByTag(P.Value, tag.Value);
				}
			}
			else if (!string.IsNullOrEmpty(name.Value))
			{
				storeNearest.Value = base.sensor.GetNearestToPointByName(P.Value, name.Value);
			}
			else
			{
				storeNearest.Value = base.sensor.GetNearestToPoint(P.Value);
			}
			if (storeNearest.Value != null)
			{
				base.Fsm.Event(detectedEvent);
			}
			else
			{
				base.Fsm.Event(noneDetectedEvent);
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Get the computed visibility of a GameObject from a sensor. Visibility is calculated when line of sight tests are enabled, it is the ratio of rays from the sensor to the GameObject that are unobstructed.")]
	public class SensorGetVisibility : SensorToolkitComponentAction<Sensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The game object to check the visibility of.")]
		public FsmGameObject checkObject;

		[HutongGames.PlayMaker.Tooltip("Stores the visibility ratio of the game object.")]
		public FsmFloat storeVisibility;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeVisibility = 0f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				storeVisibility.Value = base.sensor.GetVisibility(checkObject.Value);
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("For a given detected object get an array of all its ray cast targets that passed line of sight tests.")]
	public class SensorGetVisibleRaycastTargets : SensorToolkitComponentAction<BaseVolumeSensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(BaseVolumeSensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the sensor.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The target object whose raycast targets should be queried.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject targetObject;

		[HutongGames.PlayMaker.Tooltip("Store the array of visible LOSTarget Transforms here.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray storeTargetTransforms;

		[HutongGames.PlayMaker.Tooltip("Store the array of visible target positions here.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Vector3, "", 0, 0, 65536)]
		public FsmArray storeTargetPositions;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			storeTargetTransforms = null;
			storeTargetPositions = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (!UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				return;
			}
			if (!storeTargetTransforms.IsNone)
			{
				List<Transform> visibleTransforms = base.volumeSensor.GetVisibleTransforms(targetObject.Value);
				GameObject[] array = new GameObject[visibleTransforms.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = visibleTransforms[i].gameObject;
				}
				FsmArray fsmArray = storeTargetTransforms;
				object[] values = array;
				fsmArray.Values = values;
			}
			if (!storeTargetPositions.IsNone)
			{
				List<Vector3> visiblePositions = base.volumeSensor.GetVisiblePositions(targetObject.Value);
				object[] array2 = new object[visiblePositions.Count];
				for (int j = 0; j < visiblePositions.Count; j++)
				{
					array2[j] = visiblePositions[j];
				}
				storeTargetPositions.Values = array2;
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("For a given detected object get an array of all its ray cast targets that passed line of sight tests.")]
	public class SensorGetVisibleRaycastTargets2D : SensorToolkitComponentAction<BaseAreaSensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(BaseVolumeSensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the sensor.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The target object whose raycast targets should be queried.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject targetObject;

		[HutongGames.PlayMaker.Tooltip("Store the array of visible LOSTarget Transforms here.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray storeTargetTransforms;

		[HutongGames.PlayMaker.Tooltip("Store the array of visible target positions here.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Vector2, "", 0, 0, 65536)]
		public FsmArray storeTargetPositions;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			storeTargetTransforms = null;
			storeTargetPositions = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (!UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				return;
			}
			if (!storeTargetTransforms.IsNone)
			{
				List<Transform> visibleTransforms = base.volumeSensor.GetVisibleTransforms(targetObject.Value);
				GameObject[] array = new GameObject[visibleTransforms.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = visibleTransforms[i].gameObject;
				}
				FsmArray fsmArray = storeTargetTransforms;
				object[] values = array;
				fsmArray.Values = values;
			}
			if (!storeTargetPositions.IsNone)
			{
				List<Vector3> visiblePositions = base.volumeSensor.GetVisiblePositions(targetObject.Value);
				object[] array2 = new object[visiblePositions.Count];
				for (int j = 0; j < visiblePositions.Count; j++)
				{
					array2[j] = visiblePositions[j];
				}
				storeTargetPositions.Values = array2;
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Query a sensor if it currently detects a specific Game Object.")]
	public class SensorIsDetected : SensorToolkitComponentAction<Sensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Check if this Game Object is currently detected.")]
		public FsmGameObject checkGameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Stores the result, is it detected or not.")]
		public FsmBool storeResult;

		[HutongGames.PlayMaker.Tooltip("Fires this event if the Game Object is detected.")]
		public FsmEvent detectedEvent;

		[HutongGames.PlayMaker.Tooltip("Fires this event if the Game Object isn't detected.")]
		public FsmEvent notDetectedEvent;

		[HutongGames.PlayMaker.Tooltip("Check every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			checkGameObject = null;
			storeResult = null;
			detectedEvent = null;
			notDetectedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				bool flag = base.sensor.IsDetected(checkGameObject.Value);
				if (!storeResult.IsNone)
				{
					storeResult.Value = flag;
				}
				if (flag)
				{
					base.Fsm.Event(detectedEvent);
				}
				else
				{
					base.Fsm.Event(notDetectedEvent);
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets the ignore list array on a sensor")]
	public class SensorSetIgnoreList : SensorToolkitComponentAction<Sensor>
	{
		[RequiredField]
		[CheckForComponent(typeof(Sensor))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the Sensor.")]
		public FsmOwnerDefault gameObject;

		[HutongGames.PlayMaker.Tooltip("The array of GameObjects to ignore")]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray ignoreList;

		[HutongGames.PlayMaker.Tooltip("Sets the ignore list each frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			ignoreList = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)) && !ignoreList.IsNone)
			{
				int length = ignoreList.Length;
				base.sensor.IgnoreList.Clear();
				for (int i = 0; i < length; i++)
				{
					base.sensor.IgnoreList.Add(ignoreList.Get(i) as GameObject);
				}
			}
		}
	}
	public abstract class SensorToolkitComponentAction<T> : FsmStateAction where T : Component
	{
		private GameObject cachedGameObject;

		protected T component;

		protected RaySensor raySensor => component as RaySensor;

		protected RaySensor2D raySensor2D => component as RaySensor2D;

		protected RangeSensor rangeSensor => component as RangeSensor;

		protected TriggerSensor triggerSensor => component as TriggerSensor;

		protected Sensor sensor => component as Sensor;

		protected BaseVolumeSensor volumeSensor => component as BaseVolumeSensor;

		protected BaseAreaSensor areaSensor => component as BaseAreaSensor;

		protected FOVCollider fovCollider => component as FOVCollider;

		protected FOVCollider2D fovCollider2D => component as FOVCollider2D;

		protected SteeringRig steeringRig => component as SteeringRig;

		protected SteeringRig2D steeringRig2D => component as SteeringRig2D;

		protected bool UpdateCache(GameObject go)
		{
			if (go == null)
			{
				return false;
			}
			if (component == null || cachedGameObject != go)
			{
				component = go.GetComponent<T>();
				cachedGameObject = go;
				if (component == null)
				{
					LogWarning("Missing component: " + typeof(T).FullName + " on: " + go.name);
				}
			}
			return component != null;
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets the properties of a FOVCollider object. Note that rebuilding the collider can incur a large performance cost, so it is not recommended on a per-frame basis.")]
	public class SetFOVCollider : SensorToolkitComponentAction<FOVCollider>
	{
		[RequiredField]
		[CheckForComponent(typeof(FOVCollider))]
		public FsmOwnerDefault gameObject;

		public FsmFloat length;

		public FsmFloat baseSize;

		[HasFloatSlider(0f, 180f)]
		public FsmFloat FOVAngle;

		[HasFloatSlider(0f, 180f)]
		public FsmFloat elevationAngle;

		public FsmInt resolution;

		public override void Reset()
		{
			length = 5f;
			baseSize = 0.5f;
			FOVAngle = 90f;
			resolution = 1;
			elevationAngle = 90f;
		}

		public override void OnEnter()
		{
			setCollider();
			Finish();
		}

		private void setCollider()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)) && !(base.Fsm.GetOwnerDefaultTarget(gameObject) == null))
			{
				base.fovCollider.Length = length.Value;
				base.fovCollider.BaseSize = baseSize.Value;
				base.fovCollider.FOVAngle = FOVAngle.Value;
				base.fovCollider.ElevationAngle = elevationAngle.Value;
				base.fovCollider.Resolution = resolution.Value;
				base.fovCollider.CreateCollider();
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets the properties of a FOVCollider2D object. Note that rebuilding the collider can incur a large performance cost, so it is not recommended on a per-frame basis.")]
	public class SetFOVCollider2D : SensorToolkitComponentAction<FOVCollider2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(FOVCollider2D))]
		public FsmOwnerDefault gameObject;

		public FsmFloat length;

		public FsmFloat baseSize;

		[HasFloatSlider(0f, 180f)]
		public FsmFloat FOVAngle;

		public FsmInt resolution;

		public override void Reset()
		{
			length = 5f;
			baseSize = 0.5f;
			FOVAngle = 90f;
			resolution = 1;
		}

		public override void OnEnter()
		{
			setCollider();
			Finish();
		}

		private void setCollider()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)) && !(base.Fsm.GetOwnerDefaultTarget(gameObject) == null))
			{
				base.fovCollider2D.Length = length.Value;
				base.fovCollider2D.BaseSize = baseSize.Value;
				base.fovCollider2D.FOVAngle = FOVAngle.Value;
				base.fovCollider2D.Resolution = resolution.Value;
				base.fovCollider2D.CreateCollider();
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets a steering rigs destination. Set either a GameObject or a Vector3 position to track to.")]
	public class SetSteeringDestination : SensorToolkitComponentAction<SteeringRig>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The gameobject that should be moved to.")]
		public FsmGameObject destinationGameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The position that should be moved to.")]
		public FsmVector3 destinationPosition;

		[HutongGames.PlayMaker.Tooltip("Set steering targets each frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			destinationPosition = null;
			destinationGameObject = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		public override string ErrorCheck()
		{
			if (!destinationGameObject.IsNone && !destinationPosition.IsNone)
			{
				return "You cannot set both a destination GameObject and a destination position. One of these must be None.";
			}
			return base.ErrorCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				if (!destinationGameObject.IsNone && destinationGameObject.Value != null)
				{
					base.steeringRig.DestinationTransform = destinationGameObject.Value.transform;
				}
				else
				{
					base.steeringRig.DestinationTransform = null;
				}
				if (!destinationPosition.IsNone)
				{
					base.steeringRig.Destination = destinationPosition.Value;
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets a steering rigs destination. Set either a GameObject or a Vector2 position to track to. For use with the 2D Steering rig.")]
	public class SetSteeringDestination2D : SensorToolkitComponentAction<SteeringRig2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig2D))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The gameobject that should be moved to.")]
		public FsmGameObject destinationGameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The position that should be moved to.")]
		public FsmVector2 destinationPosition;

		[HutongGames.PlayMaker.Tooltip("Set steering targets each frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			destinationPosition = null;
			destinationGameObject = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		public override string ErrorCheck()
		{
			if (!destinationGameObject.IsNone && !destinationPosition.IsNone)
			{
				return "You cannot set both a destination GameObject and a destination position. One of these must be None.";
			}
			return base.ErrorCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				if (!destinationGameObject.IsNone && destinationGameObject.Value != null)
				{
					base.steeringRig.DestinationTransform = destinationGameObject.Value.transform;
				}
				else
				{
					base.steeringRig.DestinationTransform = null;
				}
				if (!destinationPosition.IsNone)
				{
					base.steeringRig.Destination = destinationPosition.Value;
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets a steering rigs target direction which it should face. Assign it a GameObject or a Vector3 position to face towards. If you want thw Steering rig to stop strafing then assign both the direction and gameobject parameters to None.")]
	public class SetSteeringTargetToFace : SensorToolkitComponentAction<SteeringRig>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The direction that should be faced towards.")]
		public FsmVector3 directionToFace;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The gameobject that should be faced towards.")]
		public FsmGameObject gameObjectToFace;

		[HutongGames.PlayMaker.Tooltip("Set steering targets each frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			directionToFace = null;
			gameObjectToFace = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		public override string ErrorCheck()
		{
			if (!gameObjectToFace.IsNone && !directionToFace.IsNone)
			{
				return "You cannot set both a GameObject and a Vector3 direction to face. Set one parameter to None.";
			}
			return base.ErrorCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				if (!gameObjectToFace.IsNone && gameObjectToFace.Value != null)
				{
					base.steeringRig.ClearDirectionToFace();
					base.steeringRig.FaceTowardsTransform = gameObjectToFace.Value.transform;
				}
				else
				{
					base.steeringRig.FaceTowardsTransform = null;
					base.steeringRig.DirectionToFace = directionToFace.Value;
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets a steering rigs target direction which it should face. Assign it a GameObject or a Vector2 position to face towards. If you want thw Steering rig to stop strafing then assign both the direction and gameobject parameters to None. For use with the 2D Steering rig.")]
	public class SetSteeringTargetToFace2D : SensorToolkitComponentAction<SteeringRig2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig2D))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The direction that should be faced towards.")]
		public FsmVector2 directionToFace;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The gameobject that should be faced towards.")]
		public FsmGameObject gameObjectToFace;

		[HutongGames.PlayMaker.Tooltip("Set steering targets each frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			directionToFace = null;
			gameObjectToFace = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		public override string ErrorCheck()
		{
			if (!gameObjectToFace.IsNone && !directionToFace.IsNone)
			{
				return "You cannot set both a GameObject and a Vector2 direction to face. Set one parameter to None.";
			}
			return base.ErrorCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				if (!gameObjectToFace.IsNone && gameObjectToFace.Value != null)
				{
					base.steeringRig.ClearDirectionToFace();
					base.steeringRig.FaceTowardsTransform = gameObjectToFace.Value.transform;
				}
				else
				{
					base.steeringRig.FaceTowardsTransform = null;
					base.steeringRig.DirectionToFace = directionToFace.Value;
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets a steering rigs destination position or direction to face.")]
	public class SetSteeringTargets : SensorToolkitComponentAction<SteeringRig>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The gameobject that should be moved to.")]
		public FsmGameObject destinationGameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The position that should be moved to.")]
		public FsmVector3 destinationPosition;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The direction that should be faced towards.")]
		public FsmVector3 directionToFace;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The gameobject that should be faced towards.")]
		public FsmGameObject gameObjectToFace;

		[HutongGames.PlayMaker.Tooltip("If checked will clear the direction to face setting. Will cause the object to stop strafing.")]
		public FsmBool ClearDirectionToFace;

		[HutongGames.PlayMaker.Tooltip("Set steering targets each frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			destinationPosition = null;
			destinationGameObject = null;
			directionToFace = null;
			gameObjectToFace = null;
			ClearDirectionToFace = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				if (destinationPosition != null)
				{
					base.steeringRig.Destination = destinationPosition.Value;
				}
				if (destinationGameObject != null)
				{
					base.steeringRig.DestinationTransform = destinationGameObject.Value.transform;
				}
				else
				{
					base.steeringRig.DestinationTransform = null;
				}
				if (directionToFace != null)
				{
					base.steeringRig.DirectionToFace = directionToFace.Value;
				}
				if (ClearDirectionToFace.Value)
				{
					base.steeringRig.ClearDirectionToFace();
				}
			}
		}
	}
	[ActionCategory("Sensors")]
	[HutongGames.PlayMaker.Tooltip("Sets a steering rigs destination position or direction to face. For use with the 2D Steering rig.")]
	public class SetSteeringTargets2D : SensorToolkitComponentAction<SteeringRig2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(SteeringRig2D))]
		[HutongGames.PlayMaker.Tooltip("The game object owning the steering rig.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The position that should be moved to.")]
		public FsmVector2 destinationPosition;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optional. The direction that should be faced towards.")]
		public FsmVector2 directionToFace;

		[HutongGames.PlayMaker.Tooltip("If checked will clear the direction to face setting. Will cause the object to stop strafing.")]
		public FsmBool ClearDirectionToFace;

		[HutongGames.PlayMaker.Tooltip("Set steering targets each frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			destinationPosition = null;
			directionToFace = null;
			ClearDirectionToFace = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			doCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			doCheck();
		}

		private void doCheck()
		{
			if (UpdateCache(base.Fsm.GetOwnerDefaultTarget(gameObject)))
			{
				if (destinationPosition != null)
				{
					base.steeringRig.Destination = destinationPosition.Value;
				}
				if (directionToFace != null)
				{
					base.steeringRig.DirectionToFace = directionToFace.Value;
				}
				if (ClearDirectionToFace.Value)
				{
					base.steeringRig.ClearDirectionToFace();
				}
			}
		}
	}
}
namespace SensorToolkit.Example
{
	public class ScoreZone : MonoBehaviour
	{
		public Sensor PickupSensor;

		public GameObject ScoreEffect;

		private void Update()
		{
			Holdable nearestByComponent = PickupSensor.GetNearestByComponent<Holdable>();
			if (nearestByComponent != null)
			{
				if (ScoreEffect != null)
				{
					UnityEngine.Object.Instantiate(ScoreEffect, nearestByComponent.transform.position, nearestByComponent.transform.rotation);
				}
				UnityEngine.Object.Destroy(nearestByComponent.gameObject);
			}
		}
	}
	[RequireComponent(typeof(CharacterControls), typeof(GunWithClip), typeof(TeamMember))]
	public class SoldierAI : MonoBehaviour
	{
		public Sensor Sight;

		public Sensor InteractionRange;

		public SteeringRig SteerSensor;

		private CharacterControls movement;

		private GunWithClip gun;

		private Teams team;

		private GameObject myBaseCache;

		private List<GameObject> enemiesSpotted
		{
			get
			{
				List<GameObject> detected = Sight.GetDetected();
				for (int num = detected.Count - 1; num >= 0; num--)
				{
					TeamMember component = detected[num].GetComponent<TeamMember>();
					if (component == null || component.Team == team || component.Team == Teams.None)
					{
						detected.RemoveAt(num);
					}
				}
				return detected;
			}
		}

		private List<GameObject> friendsSpotted
		{
			get
			{
				List<GameObject> detected = Sight.GetDetected();
				for (int num = detected.Count - 1; num >= 0; num--)
				{
					TeamMember component = detected[num].GetComponent<TeamMember>();
					if (component == null || component.Team != team || component.Team == Teams.None)
					{
						detected.RemoveAt(num);
					}
				}
				return detected;
			}
		}

		private List<Holdable> pickupsSpotted => Sight.GetDetectedByComponent<Holdable>();

		private GameObject MyBase
		{
			get
			{
				if (myBaseCache == null)
				{
					myBaseCache = GameObject.Find((team == Teams.Yellow) ? "YellowBase" : "MagentaBase");
				}
				return myBaseCache;
			}
		}

		private void Start()
		{
			movement = GetComponent<CharacterControls>();
			gun = GetComponent<GunWithClip>();
			team = GetComponent<TeamMember>().Team;
			StartCoroutine(DefaultState());
		}

		private IEnumerator DefaultState()
		{
			while (true)
			{
				if (movement.Held != null)
				{
					StartCoroutine(CarryToBaseState());
					yield break;
				}
				List<Holdable> list = pickupsSpotted;
				if (list.Count > 0)
				{
					if (list[0].IsHeld && list[0].Holder.GetComponent<TeamMember>().Team != team)
					{
						StartCoroutine(AttackState(list[0].Holder));
						yield break;
					}
					if (UnityEngine.Random.value > 0.9f)
					{
						StartCoroutine(PickUpState());
						yield break;
					}
				}
				if (enemiesSpotted.Count > 0)
				{
					break;
				}
				float countdown = 1f;
				while (countdown > 0f)
				{
					Vector3 steeredDirection = SteerSensor.GetSteeredDirection(-base.transform.position);
					movement.Move = steeredDirection;
					movement.Face = steeredDirection;
					countdown -= Time.deltaTime;
					yield return null;
				}
			}
			StartCoroutine(AttackState());
		}

		private IEnumerator AttackState(GameObject target = null)
		{
			if (target == null)
			{
				List<GameObject> list = enemiesSpotted;
				if (list.Count == 0)
				{
					StartCoroutine(DefaultState());
					yield break;
				}
				target = list[0];
			}
			float cooldown = UnityEngine.Random.Range(0.5f, 2f);
			if ((target.transform.position - base.transform.position).magnitude > 10f)
			{
				while (cooldown > 0f && !(target == null))
				{
					Vector3 normalized = (target.transform.position - base.transform.position).normalized;
					movement.Move = SteerSensor.GetSteeredDirection(normalized);
					movement.Face = normalized;
					gun.Fire();
					if (gun.IsEmptyClip)
					{
						gun.Reload();
					}
					cooldown -= Time.deltaTime;
					yield return null;
				}
			}
			else
			{
				Vector3 strafeDirection = new Vector3(UnityEngine.Random.Range(-1f, 1f), 0f, UnityEngine.Random.Range(-1f, 1f)).normalized;
				while (cooldown > 0f && !(target == null))
				{
					Vector3 normalized2 = (target.transform.position - base.transform.position).normalized;
					movement.Move = SteerSensor.GetSteeredDirection(strafeDirection);
					movement.Face = normalized2;
					gun.Fire();
					if (gun.IsEmptyClip && !gun.IsReloading)
					{
						gun.Reload();
						if (UnityEngine.Random.value > 0.5f)
						{
							StartCoroutine(FleeState());
							yield break;
						}
					}
					cooldown -= Time.deltaTime;
					yield return null;
				}
			}
			StartCoroutine(DefaultState());
		}

		private IEnumerator FleeState()
		{
			float cooldown = UnityEngine.Random.Range(2f, 4f);
			List<GameObject> list = enemiesSpotted;
			if (list.Count == 0)
			{
				StartCoroutine(DefaultState());
				yield break;
			}
			Vector3 enemyRepulse2 = Vector3.zero;
			for (int i = 0; i < list.Count; i++)
			{
				enemyRepulse2 -= (list[i].transform.position - base.transform.position).normalized;
			}
			enemyRepulse2 = enemyRepulse2.normalized;
			while (cooldown > 0f)
			{
				movement.Move = SteerSensor.GetSteeredDirection(enemyRepulse2);
				movement.Face = movement.Move;
				cooldown -= Time.deltaTime;
				yield return null;
			}
			StartCoroutine(DefaultState());
		}

		private IEnumerator PickUpState()
		{
			List<Holdable> list = pickupsSpotted;
			if (list.Count == 0)
			{
				StartCoroutine(DefaultState());
				yield break;
			}
			Holdable pickup = list[0];
			float countdown = 2f;
			while (countdown > 0f)
			{
				countdown -= Time.deltaTime;
				if (pickup.IsHeld)
				{
					StartCoroutine(DefaultState());
					yield break;
				}
				movement.Move = SteerSensor.GetSteeredDirection(pickup.transform.position - base.transform.position);
				movement.Face = movement.Move;
				if (InteractionRange.IsDetected(pickup.gameObject))
				{
					movement.PickUp(pickup);
					break;
				}
				yield return null;
			}
			StartCoroutine(DefaultState());
		}

		private IEnumerator CarryToBaseState()
		{
			while (!(movement.Held == null))
			{
				Vector3 targetDirection = MyBase.transform.position - base.transform.position;
				movement.Move = SteerSensor.GetSteeredDirection(targetDirection);
				movement.Face = movement.Move;
				yield return null;
			}
			StartCoroutine(DefaultState());
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class Asteroid : MonoBehaviour
	{
		public float MaxRandomSpin;

		public float MaxRandomForce;

		public float BoundaryRadius;

		public float ReturnForce;

		public float ReturnForceLerpDistance;

		private Rigidbody rb;

		private void Start()
		{
			rb = GetComponent<Rigidbody>();
			rb.AddTorque(randomVector() * UnityEngine.Random.Range(0f, MaxRandomSpin));
			rb.AddForce(randomVector() * UnityEngine.Random.Range(0f, MaxRandomForce));
		}

		private void Update()
		{
			float magnitude = base.transform.position.magnitude;
			if (magnitude >= BoundaryRadius)
			{
				float num = Mathf.Lerp(0f, ReturnForce, (magnitude - BoundaryRadius) / ReturnForceLerpDistance);
				rb.AddForce(num * -base.transform.position.normalized);
			}
		}

		private Vector3 randomVector()
		{
			return new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)).normalized;
		}
	}
	public class CollectPickups : MonoBehaviour
	{
		public Sensor PickupSensor;

		public Sensor InteractionRange;

		public SteeringRig Steering;

		private Holdable target;

		private void Update()
		{
			if (target == null)
			{
				target = PickupSensor.GetNearestByComponent<Holdable>();
				if (target != null)
				{
					Steering.IgnoreList.Clear();
					Steering.IgnoreList.Add(target.gameObject);
					Steering.DestinationTransform = target.transform;
				}
			}
			else if (InteractionRange.IsDetected(target.gameObject))
			{
				UnityEngine.Object.Destroy(target.gameObject);
				target = null;
			}
		}
	}
	public class AlarmController : MonoBehaviour
	{
		public Light PointLight;

		public Color AlarmColour;

		public float FlashFrequency;

		public Transform[] LinearLevelWaypoints;

		private bool alarmStarted;

		private GameObject whoTrippedAlarm;

		private static AlarmController instance;

		public static AlarmController Instance
		{
			get
			{
				if (instance == null)
				{
					instance = UnityEngine.Object.FindObjectOfType<AlarmController>();
				}
				return instance;
			}
		}

		public bool IsAlarmState
		{
			get
			{
				if (alarmStarted)
				{
					return WhoTrippedAlarm != null;
				}
				return false;
			}
		}

		public GameObject WhoTrippedAlarm => whoTrippedAlarm;

		public void StartAlarm(GameObject whoTrippedAlarm)
		{
			if (!alarmStarted)
			{
				this.whoTrippedAlarm = whoTrippedAlarm;
				StartCoroutine(alarmRoutine());
			}
		}

		public Transform[] PathToWhoTrippedAlarm(GameObject from)
		{
			int nearestWaypointIndex = getNearestWaypointIndex(from.transform.position);
			int nearestWaypointIndex2 = getNearestWaypointIndex(whoTrippedAlarm.transform.position);
			int num = Mathf.Abs(nearestWaypointIndex - nearestWaypointIndex2);
			bool flag = nearestWaypointIndex2 > nearestWaypointIndex;
			Transform[] array = new Transform[num];
			for (int i = 0; i < num; i++)
			{
				int num2 = (flag ? i : (-i));
				array[i] = LinearLevelWaypoints[nearestWaypointIndex + num2];
			}
			return array;
		}

		private IEnumerator alarmRoutine()
		{
			alarmStarted = true;
			PointLight.color = AlarmColour;
			float startIntensity = PointLight.intensity;
			while (true)
			{
				float intensity = (Mathf.Sin(FlashFrequency * Time.time * (float)Math.PI * 2f) + 1f) / 2f * startIntensity;
				PointLight.intensity = intensity;
				yield return null;
			}
		}

		private int getNearestWaypointIndex(Vector3 toPos)
		{
			float num = 0f;
			int num2 = -1;
			for (int i = 0; i < LinearLevelWaypoints.Length; i++)
			{
				float sqrMagnitude = (toPos - LinearLevelWaypoints[i].position).sqrMagnitude;
				if (sqrMagnitude < num || num2 == -1)
				{
					num2 = i;
					num = sqrMagnitude;
				}
			}
			return num2;
		}
	}
	public class AutomaticSlidingDoor : MonoBehaviour
	{
		public Sensor ObjectSensor;

		public GameObject LeftDoor;

		public GameObject RightDoor;

		public float SlideAmount;

		public float Speed;

		private Vector3 leftStart;

		private Vector3 rightStart;

		private void Start()
		{
			leftStart = LeftDoor.transform.localPosition;
			rightStart = RightDoor.transform.localPosition;
			StartCoroutine(ClosingState());
		}

		private IEnumerator ClosingState()
		{
			while (!(ObjectSensor.GetNearest() != null))
			{
				LeftDoor.transform.localPosition = Vector3.Lerp(LeftDoor.transform.localPosition, leftStart, Time.deltaTime * Speed);
				RightDoor.transform.localPosition = Vector3.Lerp(RightDoor.transform.localPosition, rightStart, Time.deltaTime * Speed);
				yield return null;
			}
			StartCoroutine(OpeningState());
		}

		private IEnumerator OpeningState()
		{
			while (!(ObjectSensor.GetNearest() == null))
			{
				LeftDoor.transform.localPosition = Vector3.Lerp(LeftDoor.transform.localPosition, leftStart - Vector3.right * SlideAmount, Time.deltaTime * Speed);
				RightDoor.transform.localPosition = Vector3.Lerp(RightDoor.transform.localPosition, rightStart + Vector3.right * SlideAmount, Time.deltaTime * Speed);
				yield return null;
			}
			StartCoroutine(ClosingState());
		}
	}
	public class CameraFollow : MonoBehaviour
	{
		public GameObject ToFollow;

		public float Speed;

		private Vector3 offset;

		private void Start()
		{
			offset = base.transform.position - ToFollow.transform.position;
		}

		private void LateUpdate()
		{
			if (!(ToFollow == null))
			{
				Vector3 b = ToFollow.transform.position + offset;
				base.transform.position = Vector3.Lerp(base.transform.position, b, Time.deltaTime * Speed);
			}
		}
	}
	[RequireComponent(typeof(GunWithClip), typeof(TeamMember))]
	public class GuardAI : MonoBehaviour
	{
		public GameObject GunPivot;

		public SteeringRig Steering;

		public Sensor Sight;

		public Transform[] PatrolPath;

		public float WaypointArriveDistance;

		public float PauseTime;

		public float WanderDistance;

		public float SoundAlarmTime;

		private GunWithClip gun;

		private TeamMember team;

		private bool ascending = true;

		private void Start()
		{
			gun = GetComponent<GunWithClip>();
			team = GetComponent<TeamMember>();
			StartCoroutine(PatrolState());
		}

		private IEnumerator PatrolState()
		{
			int nextWaypoint = getNearestWaypointIndex();
			while (true)
			{
				if (attackEnemyIfSpotted() || chaseIfAlarmSounded())
				{
					yield break;
				}
				Steering.DestinationTransform = PatrolPath[nextWaypoint];
				if ((base.transform.position - PatrolPath[nextWaypoint].position).magnitude < WaypointArriveDistance)
				{
					nextWaypoint = (ascending ? (nextWaypoint + 1) : (nextWaypoint - 1));
					if (nextWaypoint >= PatrolPath.Length || nextWaypoint < 0)
					{
						break;
					}
				}
				yield return null;
			}
			ascending = !ascending;
			StartCoroutine(PauseState());
		}

		private IEnumerator PauseState()
		{
			Steering.DestinationTransform = null;
			Steering.Destination = base.transform.position + wanderVector();
			float timer = PauseTime;
			while (timer > 0f)
			{
				if (attackEnemyIfSpotted() || chaseIfAlarmSounded())
				{
					yield break;
				}
				timer -= Time.deltaTime;
				yield return null;
			}
			StartCoroutine(PatrolState());
		}

		private IEnumerator AttackState(GameObject ToAttack)
		{
			Steering.DestinationTransform = null;
			Steering.FaceTowardsTransform = ToAttack.transform;
			float alarmTimer = SoundAlarmTime;
			while (true)
			{
				if (ToAttack == null)
				{
					StartCoroutine(PauseState());
					yield break;
				}
				alarmTimer -= Time.deltaTime;
				if (alarmTimer <= 0f)
				{
					AlarmController.Instance.StartAlarm(ToAttack);
				}
				if (!Sight.IsDetected(ToAttack))
				{
					break;
				}
				GunPivot.transform.LookAt(new Vector3(ToAttack.transform.position.x, GunPivot.transform.position.y, ToAttack.transform.position.z));
				if (gun.IsEmptyClip)
				{
					gun.Reload();
				}
				else
				{
					gun.Fire();
				}
				yield return null;
			}
			Steering.FaceTowardsTransform = null;
			GunPivot.transform.localRotation = Quaternion.identity;
			StartCoroutine(Investigate(ToAttack.transform.position));
		}

		private IEnumerator Investigate(Vector3 position)
		{
			Steering.DestinationTransform = null;
			Steering.Destination = position;
			float timer = 0f;
			while (true)
			{
				if (attackEnemyIfSpotted())
				{
					yield break;
				}
				timer += Time.deltaTime;
				if (timer > 5f || !Steering.IsSeeking)
				{
					break;
				}
				yield return null;
			}
			StartCoroutine(PauseState());
		}

		private IEnumerator Chase()
		{
			while (true)
			{
				Transform[] chasePath = AlarmController.Instance.PathToWhoTrippedAlarm(base.gameObject);
				if (chasePath.Length <= 1)
				{
					break;
				}
				int nextWaypoint = 0;
				while (true)
				{
					if (attackEnemyIfSpotted())
					{
						yield break;
					}
					Steering.DestinationTransform = chasePath[nextWaypoint];
					if ((base.transform.position - chasePath[nextWaypoint].position).magnitude < WaypointArriveDistance)
					{
						nextWaypoint++;
						if (nextWaypoint >= chasePath.Length)
						{
							break;
						}
					}
					yield return null;
				}
			}
			StartCoroutine(AttackState(AlarmController.Instance.WhoTrippedAlarm));
		}

		private bool attackEnemyIfSpotted()
		{
			List<TeamMember> detectedByComponent = Sight.GetDetectedByComponent<TeamMember>();
			for (int i = 0; i < detectedByComponent.Count; i++)
			{
				if (detectedByComponent[i].Team != team.Team)
				{
					StartCoroutine(AttackState(detectedByComponent[i].gameObject));
					return true;
				}
			}
			return false;
		}

		private bool chaseIfAlarmSounded()
		{
			if (AlarmController.Instance.IsAlarmState)
			{
				StartCoroutine(Chase());
				return true;
			}
			return false;
		}

		private int getNearestWaypointIndex()
		{
			float num = 0f;
			int num2 = -1;
			for (int i = 0; i < PatrolPath.Length; i++)
			{
				float sqrMagnitude = (base.transform.position - PatrolPath[i].position).sqrMagnitude;
				if (sqrMagnitude < num || num2 == -1)
				{
					num2 = i;
					num = sqrMagnitude;
				}
			}
			return num2;
		}

		private Vector3 wanderVector()
		{
			return new Vector3(UnityEngine.Random.Range(-1f, 1f), 0f, UnityEngine.Random.Range(-1f, 1f)).normalized * WanderDistance;
		}
	}
	[RequireComponent(typeof(CharacterControls))]
	public class PlayerInput : MonoBehaviour
	{
		public Sensor InteractionRange;

		private CharacterControls cc;

		private void Start()
		{
			cc = GetComponent<CharacterControls>();
		}

		private void Update()
		{
			float axis = Input.GetAxis("Horizontal");
			float axis2 = Input.GetAxis("Vertical");
			cc.Move = new Vector3(axis, 0f, axis2);
			Vector3 mousePosition = Input.mousePosition;
			Vector3 position = Camera.main.transform.position;
			Vector3 forward = Camera.main.transform.forward;
			float z = (0f - position.y) / forward.y;
			mousePosition.z = z;
			Vector3 vector = Camera.main.ScreenToWorldPoint(mousePosition);
			cc.Face = (vector - base.transform.position).normalized;
			Holdable nearestByComponent = InteractionRange.GetNearestByComponent<Holdable>();
			if (nearestByComponent != null && !nearestByComponent.IsHeld)
			{
				cc.PickUp(nearestByComponent);
			}
		}
	}
	[RequireComponent(typeof(TeamMember))]
	public class SecurityCamera : MonoBehaviour
	{
		public float RotationSpeed;

		public float ScanTime;

		public float TrackTime;

		public float ScanArcAngle;

		public Light SpotLight;

		public Sensor Sensor;

		public Color ScanColour;

		public Color TrackColour;

		public Color AlarmColour;

		private Quaternion leftExtreme;

		private Quaternion rightExtreme;

		private TeamMember team;

		private Quaternion targetRotation;

		private void Awake()
		{
			leftExtreme = Quaternion.AngleAxis(ScanArcAngle / 2f, Vector3.up) * base.transform.rotation;
			rightExtreme = Quaternion.AngleAxis((0f - ScanArcAngle) / 2f, Vector3.up) * base.transform.rotation;
			team = GetComponent<TeamMember>();
		}

		private void OnEnable()
		{
			targetRotation = base.transform.rotation;
			base.transform.rotation = rightExtreme;
			StartCoroutine(scanState());
		}

		private void Update()
		{
			base.transform.rotation = Quaternion.RotateTowards(base.transform.rotation, targetRotation, RotationSpeed * Time.deltaTime);
		}

		private IEnumerator scanState()
		{
			StartCoroutine(scanMovement());
			while (true)
			{
				if (AlarmController.Instance.IsAlarmState)
				{
					StopAllCoroutines();
					StartCoroutine(alarmState());
					yield break;
				}
				if (getSpottedEnemy() != null)
				{
					break;
				}
				yield return null;
			}
			StopAllCoroutines();
			StartCoroutine(trackState());
		}

		private IEnumerator scanMovement()
		{
			SpotLight.color = ScanColour;
			while (true)
			{
				targetRotation = leftExtreme;
				yield return new WaitForSeconds(ScanTime);
				targetRotation = rightExtreme;
				yield return new WaitForSeconds(ScanTime);
			}
		}

		private IEnumerator trackState()
		{
			SpotLight.color = TrackColour;
			GameObject enemy = getSpottedEnemy();
			float timer = 0f;
			while (Sensor.IsDetected(enemy))
			{
				targetRotation = Quaternion.LookRotation(enemy.transform.position - base.transform.position, Vector3.up);
				timer += Time.deltaTime;
				if (timer >= TrackTime)
				{
					AlarmController.Instance.StartAlarm(enemy);
					StopAllCoroutines();
					StartCoroutine(alarmState());
					break;
				}
				yield return null;
			}
			StopAllCoroutines();
			StartCoroutine(scanState());
		}

		private IEnumerator alarmState()
		{
			targetRotation = base.transform.rotation;
			SpotLight.color = AlarmColour;
			yield return null;
		}

		private GameObject getSpottedEnemy()
		{
			List<TeamMember> detectedByComponent = Sensor.GetDetectedByComponent<TeamMember>();
			for (int i = 0; i < detectedByComponent.Count; i++)
			{
				if (detectedByComponent[i].Team != team.Team)
				{
					return detectedByComponent[i].gameObject;
				}
			}
			return null;
		}
	}
	public class BoxSpawner : MonoBehaviour
	{
		public Teams Team;

		public GameObject ToSpawn;

		public int Number;

		public float SpawnInterval;

		public int StartSpawnAmount;

		public float SizeX = 10f;

		public float SizeY = 10f;

		public float SizeZ = 10f;

		public float ClearRadius = 1f;

		public LayerMask ObstructingLayers;

		private float spawnCountdown;

		private GameObject[] spawned;

		protected static readonly Color YellowColor = Color.yellow;

		protected static readonly Color MagentaColor = Color.magenta;

		protected static readonly Color NoneColor = Color.green;

		protected static readonly Color RedColor = Color.red;

		private int nextAvailableSlot
		{
			get
			{
				for (int i = 0; i < spawned.Length; i++)
				{
					if (spawned[i] == null)
					{
						return i;
					}
				}
				return -1;
			}
		}

		private void Awake()
		{
			spawned = new GameObject[Number];
		}

		private void Start()
		{
			for (int i = 0; i < StartSpawnAmount; i++)
			{
				spawn();
			}
		}

		private void OnEnable()
		{
			StartCoroutine(SpawnRoutine());
		}

		private IEnumerator SpawnRoutine()
		{
			spawnCountdown = SpawnInterval;
			while (true)
			{
				spawnCountdown -= Time.deltaTime;
				if (spawnCountdown <= 0f)
				{
					spawn();
				}
				yield return null;
			}
		}

		private void spawn()
		{
			spawnCountdown = SpawnInterval;
			int num = nextAvailableSlot;
			if (num == -1)
			{
				return;
			}
			int num2 = 0;
			Vector3 vector;
			do
			{
				num2++;
				if (num2 > 10)
				{
					UnityEngine.Debug.LogWarning("Failed to find spawn location after 10 tries, aborting.", base.gameObject);
					return;
				}
				vector = chooseLocation();
			}
			while (locationIsObstructed(vector));
			GameObject gameObject = UnityEngine.Object.Instantiate(ToSpawn, vector, base.transform.rotation);
			gameObject.transform.SetParent(base.transform.parent);
			if (Team != Teams.None)
			{
				TeamMember component = gameObject.GetComponent<TeamMember>();
				if (component != null)
				{
					component.StartTeam = Team;
				}
			}
			spawned[num] = gameObject;
		}

		private Vector3 chooseLocation()
		{
			Vector3 a = new Vector3(SizeX / 2f, SizeY / 2f, SizeZ / 2f);
			Vector3 b = new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f));
			return Vector3.Scale(a, b) + base.transform.position;
		}

		private bool locationIsObstructed(Vector3 location)
		{
			return Physics.CheckSphere(location, ClearRadius, ObstructingLayers);
		}

		public void OnDrawGizmosSelected()
		{
			if (base.isActiveAndEnabled)
			{
				if (Team == Teams.Yellow)
				{
					Gizmos.color = YellowColor;
				}
				else if (Team == Teams.Magenta)
				{
					Gizmos.color = MagentaColor;
				}
				else
				{
					Gizmos.color = NoneColor;
				}
				Gizmos.DrawCube(base.transform.position, new Vector3(SizeX, SizeY, SizeZ));
				Gizmos.color = RedColor;
				Gizmos.DrawSphere(base.transform.position + Vector3.up * (SizeY / 2f + ClearRadius), ClearRadius);
			}
		}
	}
	[RequireComponent(typeof(RaySensor))]
	public class Bullet : MonoBehaviour
	{
		public float Speed;

		public float Damage;

		public float MaxAge;

		public float ImpactForce;

		public GameObject HitEffect;

		private float age;

		private RaySensor raySensor;

		private void Start()
		{
			raySensor = GetComponent<RaySensor>();
			raySensor.SensorUpdateMode = RaySensor.UpdateMode.Manual;
			age = 0f;
		}

		private void Update()
		{
			age += Time.deltaTime;
			if (age > MaxAge)
			{
				explode(Vector3.up);
				return;
			}
			Vector3 vector = base.transform.forward * Speed * Time.deltaTime;
			raySensor.Length = vector.magnitude;
			raySensor.Pulse();
			base.transform.position += vector;
		}

		public void HitObject(GameObject g, Sensor s)
		{
			Health component = g.GetComponent<Health>();
			if (component != null)
			{
				component.Impact(Damage, base.transform.forward * ImpactForce, raySensor.GetRayHit(g).point);
			}
			explode(raySensor.GetRayHit(g).normal);
		}

		public void HitWall()
		{
			explode(raySensor.ObstructionRayHit.normal);
		}

		private void explode(Vector3 direction)
		{
			if (HitEffect != null)
			{
				UnityEngine.Object.Instantiate(HitEffect, base.transform.position, Quaternion.LookRotation(direction));
			}
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class CharacterControls : MonoBehaviour
	{
		public float MaxMoveForce;

		public float MaxStrafeForce;

		public float MaxTurnForce;

		public Sensor InteractionRange;

		public FixedJoint HoldSlot;

		private Rigidbody rb;

		private bool isInteracting;

		private Holdable held;

		private Vector3 move;

		private Vector3 face;

		public Vector3 Move
		{
			get
			{
				return move;
			}
			set
			{
				move = ((value.sqrMagnitude > 1f) ? value.normalized : value);
			}
		}

		public Vector3 Face
		{
			get
			{
				return face;
			}
			set
			{
				face = value.normalized;
			}
		}

		public Holdable Held => held;

		private float weightPenalty
		{
			get
			{
				if (!(held != null))
				{
					return 1f;
				}
				return held.WeightPenalty + 1f;
			}
		}

		public void PickUp(Holdable holdable)
		{
			if (!(held != null) && !isInteracting && InteractionRange.IsDetected(holdable.gameObject) && !holdable.IsHeld)
			{
				StartCoroutine(PickUpRoutine(holdable));
			}
		}

		private IEnumerator PickUpRoutine(Holdable holdable)
		{
			float countdown = holdable.PickupTime;
			isInteracting = true;
			while (countdown > 0f)
			{
				countdown -= Time.deltaTime;
				if (holdable.IsHeld || !InteractionRange.IsDetected(holdable.gameObject))
				{
					isInteracting = false;
					yield break;
				}
				yield return null;
			}
			holdable.PickUp(base.gameObject);
			if (holdable.Holder == base.gameObject)
			{
				held = holdable;
				held.transform.position = HoldSlot.transform.position;
				held.transform.rotation = HoldSlot.transform.rotation;
				HoldSlot.connectedBody = held.GetComponent<Rigidbody>();
			}
			isInteracting = false;
		}

		private void Start()
		{
			rb = GetComponent<Rigidbody>();
			isInteracting = false;
			held = null;
		}

		private void FixedUpdate()
		{
			float num = Mathf.Clamp(signedAngleXZ(rb.transform.forward, Face) / 10f, -1f, 1f) * MaxTurnForce;
			rb.AddTorque(Vector3.up * num / weightPenalty);
			if (!isInteracting)
			{
				float value = Vector3.Dot(base.transform.forward, Move.normalized);
				Vector3 vector = Mathf.Lerp(MaxStrafeForce, MaxMoveForce, Mathf.Clamp(value, 0f, 1f)) * Move;
				rb.AddForce(vector / weightPenalty);
			}
		}

		private float signedAngleXZ(Vector3 a, Vector3 b)
		{
			float current = Mathf.Atan2(a.x, a.z) * 57.29578f;
			float target = Mathf.Atan2(b.x, b.z) * 57.29578f;
			return Mathf.DeltaAngle(current, target);
		}
	}
	public class Gravity : MonoBehaviour
	{
		public Vector3 GravityForce;

		private void Awake()
		{
			Physics.gravity = GravityForce;
		}
	}
	public class GunWithClip : MonoBehaviour
	{
		public float FireInterval;

		public int ClipSize;

		public float ReloadTime;

		public GameObject Nozzle;

		public GameObject Bullet;

		public GameObject FireEffect;

		private int clipRemaining;

		private float cooldown;

		public bool IsReady => cooldown <= float.Epsilon;

		public bool IsEmptyClip => clipRemaining == 0;

		public bool IsReloading { get; private set; }

		public float ReloadFraction
		{
			get
			{
				if (!IsReloading)
				{
					return 1f;
				}
				return 1f - cooldown / ReloadTime;
			}
		}

		public void Fire()
		{
			if (IsReady && !IsEmptyClip)
			{
				RaySensor component = UnityEngine.Object.Instantiate(Bullet, Nozzle.transform.position, Nozzle.transform.rotation).GetComponent<RaySensor>();
				component.IgnoreList.Clear();
				component.IgnoreList.Add(base.gameObject);
				UnityEngine.Object.Instantiate(FireEffect, Nozzle.transform.position, Nozzle.transform.rotation).transform.SetParent(Nozzle.transform);
				cooldown = FireInterval;
				clipRemaining--;
			}
		}

		public void Reload()
		{
			if (IsReady && clipRemaining < ClipSize && !IsReloading)
			{
				StopCoroutine("FiringRoutine");
				StartCoroutine("ReloadRoutine");
			}
		}

		private void Start()
		{
			StartCoroutine("FiringRoutine");
		}

		private IEnumerator FiringRoutine()
		{
			cooldown = 0f;
			clipRemaining = ClipSize;
			IsReloading = false;
			while (true)
			{
				cooldown = Mathf.Max(cooldown - Time.deltaTime, 0f);
				yield return null;
			}
		}

		private IEnumerator ReloadRoutine()
		{
			IsReloading = true;
			cooldown = ReloadTime;
			while (true)
			{
				cooldown = Mathf.Max(cooldown - Time.deltaTime, 0f);
				if (IsReady)
				{
					break;
				}
				yield return null;
			}
			StartCoroutine("FiringRoutine");
		}
	}
	public class Health : MonoBehaviour
	{
		public float MaxHP;

		public GameObject Corpse;

		private Rigidbody rb;

		public float HP { get; private set; }

		public void Impact(float amount, Vector3 impactForce, Vector3 impactPoint)
		{
			HP -= amount;
			if (HP <= 0f)
			{
				GameObject obj = UnityEngine.Object.Instantiate(Corpse, base.transform.position, base.transform.rotation);
				obj.transform.SetParent(base.transform.parent);
				TeamMember component = GetComponent<TeamMember>();
				TeamMember component2 = obj.GetComponent<TeamMember>();
				if (component != null && component2 != null)
				{
					component2.StartTeam = component.Team;
				}
				Rigidbody[] componentsInChildren = obj.GetComponentsInChildren<Rigidbody>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].AddForceAtPosition(impactForce, impactPoint);
				}
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else if (rb != null)
			{
				rb.AddForceAtPosition(impactForce, impactPoint);
			}
		}

		public void Damage(float amount)
		{
			Impact(amount, Vector3.zero, Vector3.zero);
		}

		private void Start()
		{
			rb = GetComponent<Rigidbody>();
			HP = MaxHP;
		}
	}
	public class Holdable : MonoBehaviour
	{
		public float PickupTime;

		public float WeightPenalty;

		private Collider[] colliders;

		private bool collidersDisabled;

		public GameObject Holder { get; private set; }

		public bool IsHeld => Holder != null;

		public void PickUp(GameObject holder)
		{
			if (!IsHeld)
			{
				Holder = holder;
			}
		}

		public void Drop()
		{
			Holder = null;
		}

		private void Start()
		{
			colliders = GetComponentsInChildren<Collider>();
			collidersDisabled = false;
		}

		private void Update()
		{
			if (IsHeld && !collidersDisabled)
			{
				for (int i = 0; i < colliders.Length; i++)
				{
					colliders[i].enabled = false;
					collidersDisabled = true;
				}
			}
			else if (!IsHeld && collidersDisabled)
			{
				for (int j = 0; j < colliders.Length; j++)
				{
					colliders[j].enabled = true;
					collidersDisabled = false;
				}
			}
		}
	}
	public class Lifetime : MonoBehaviour
	{
		public float MaxAge;

		private float age;

		private void OnEnable()
		{
			age = 0f;
		}

		private void Update()
		{
			age += Time.deltaTime;
			if (age >= MaxAge)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public enum Teams
	{
		Yellow,
		Magenta,
		None
	}
	public class TeamMember : MonoBehaviour
	{
		public Teams StartTeam;

		public Material YellowMaterial;

		public Material MagentaMaterial;

		public MeshRenderer[] TeamRenderers;

		private Teams team;

		private bool initialised;

		public Teams Team
		{
			get
			{
				if (!initialised)
				{
					return StartTeam;
				}
				return team;
			}
			set
			{
				team = value;
				Material sharedMaterial = ((team == Teams.Yellow) ? YellowMaterial : MagentaMaterial);
				for (int i = 0; i < TeamRenderers.Length; i++)
				{
					TeamRenderers[i].sharedMaterial = sharedMaterial;
				}
			}
		}

		private void Start()
		{
			Team = StartTeam;
			initialised = true;
		}
	}
}
namespace Zinnia.Visual
{
	public class CameraColorOverlayRealtime : MonoBehaviour
	{
		[Serializable]
		public class EventData
		{
			[Serialized]
			[field: DocumentedByXml]
			public Color Color { get; set; }

			public EventData Set(EventData source)
			{
				return Set(source.Color);
			}

			public EventData Set(Color color)
			{
				Color = color;
				return this;
			}

			public void Clear()
			{
				Set(default(Color));
			}
		}

		[Serializable]
		public class UnityEvent : UnityEvent<EventData>
		{
		}

		public RuleContainer CameraValidity;

		public Color OverlayColor = Color.black;

		public Material OverlayMaterial;

		public float AddDuration;

		public float RemoveDuration = 1f;

		public float AppliedDuration;

		public UnityEvent Added = new UnityEvent();

		[DocumentedByXml]
		public UnityEvent AddTransitioned = new UnityEvent();

		[DocumentedByXml]
		public UnityEvent Removed = new UnityEvent();

		[DocumentedByXml]
		public UnityEvent RemoveTransitioned = new UnityEvent();

		[DocumentedByXml]
		public UnityEvent Changed = new UnityEvent();

		protected float targetDuration;

		protected Material workingMaterial;

		protected Color targetColor = new Color(0f, 0f, 0f, 0f);

		protected Color currentColor = new Color(0f, 0f, 0f, 0f);

		protected Color deltaColor = new Color(0f, 0f, 0f, 0f);

		protected CoroutineHandle blinkRoutine;

		protected readonly EventData eventData = new EventData();

		public bool IsAddTransitioning { get; protected set; }

		public bool IsRemoveTransitioning { get; protected set; }

		[RequiresBehaviourState(GameObjectActivity.InHierarchy, true)]
		public virtual void AddColorOverlay(Color overlayColor, float addDuration)
		{
			OverlayColor = overlayColor;
			AddDuration = addDuration;
			AddColorOverlay();
		}

		[RequiresBehaviourState(GameObjectActivity.InHierarchy, true)]
		public virtual void AddColorOverlay()
		{
			ApplyColorOverlay(OverlayColor, AddDuration);
		}

		[RequiresBehaviourState(GameObjectActivity.InHierarchy, true)]
		public virtual void RemoveColorOverlay()
		{
			ApplyColorOverlay(Color.clear, RemoveDuration);
			Removed?.Invoke(eventData.Set(Color.clear));
		}

		[RequiresBehaviourState(GameObjectActivity.InHierarchy, true)]
		public virtual void Blink()
		{
			ApplyColorOverlay(OverlayColor, AddDuration);
			blinkRoutine = Timing.RunCoroutine(ResetBlink(), Segment.RealtimeUpdate);
		}

		protected virtual void OnEnable()
		{
			CopyMaterialOverlayToWorking();
			Camera.onPostRender = (Camera.CameraCallback)Delegate.Combine(Camera.onPostRender, new Camera.CameraCallback(PostRender));
		}

		protected virtual void OnDisable()
		{
			CancelBlinkRoutine();
			Camera.onPostRender = (Camera.CameraCallback)Delegate.Remove(Camera.onPostRender, new Camera.CameraCallback(PostRender));
		}

		protected virtual void ApplyColorOverlay(Color newColor, float duration)
		{
			CancelBlinkRoutine();
			if (newColor != targetColor || !duration.ApproxEquals(targetDuration))
			{
				targetDuration = duration;
				targetColor = newColor;
				if (duration > 0f)
				{
					deltaColor = (targetColor - currentColor) / duration;
				}
				else
				{
					currentColor = newColor;
				}
				IsAddTransitioning = false;
				IsRemoveTransitioning = false;
				if (newColor != Color.clear)
				{
					IsAddTransitioning = true;
					Added?.Invoke(eventData.Set(newColor));
				}
				else
				{
					IsRemoveTransitioning = true;
				}
			}
		}

		protected virtual IEnumerator<float> ResetBlink()
		{
			yield return Timing.WaitForSeconds(AddDuration + AppliedDuration);
			RemoveColorOverlay();
		}

		protected virtual void CancelBlinkRoutine()
		{
			Timing.KillCoroutines(blinkRoutine);
		}

		protected virtual void PostRender(Camera sceneCamera)
		{
			if (!CameraValidity.Accepts(sceneCamera))
			{
				return;
			}
			if (currentColor != targetColor)
			{
				if (Mathf.Abs(currentColor.a - targetColor.a) < Mathf.Abs(deltaColor.a) * Time.unscaledDeltaTime)
				{
					currentColor = targetColor;
					deltaColor = new Color(0f, 0f, 0f, 0f);
				}
				else
				{
					currentColor += deltaColor * Time.unscaledDeltaTime;
				}
				Changed?.Invoke(eventData.Set(currentColor));
			}
			else if (IsAddTransitioning)
			{
				AddTransitioned?.Invoke(eventData.Set(currentColor));
				IsAddTransitioning = false;
			}
			else if (IsRemoveTransitioning)
			{
				RemoveTransitioned?.Invoke(eventData.Set(currentColor));
				IsRemoveTransitioning = false;
			}
			if (currentColor.a > 0f && workingMaterial != null)
			{
				currentColor.a = ((targetColor.a > currentColor.a && currentColor.a > 0.98f) ? 1f : currentColor.a);
				workingMaterial.color = currentColor;
				workingMaterial.SetPass(0);
				GL.PushMatrix();
				GL.LoadOrtho();
				GL.Color(workingMaterial.color);
				GL.Begin(7);
				GL.Vertex3(0f, 0f, 0.9999f);
				GL.Vertex3(0f, 1f, 0.9999f);
				GL.Vertex3(1f, 1f, 0.9999f);
				GL.Vertex3(1f, 0f, 0.9999f);
				GL.End();
				GL.PopMatrix();
			}
		}

		protected virtual void CopyMaterialOverlayToWorking()
		{
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Object.Destroy(workingMaterial);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(workingMaterial);
			}
			if (OverlayMaterial != null)
			{
				workingMaterial = new Material(OverlayMaterial);
			}
		}

		[CalledAfterChangeOf("OverlayMaterial")]
		protected virtual void OnAfterOverlayMaterialChange()
		{
			CopyMaterialOverlayToWorking();
		}
	}
}
namespace Zinnia.Rule
{
	public class AcceptAllButSceneCameraRule : Rule
	{
		public override bool Accepts(object target)
		{
			return true;
		}
	}
	public class AcceptAllRule : Rule
	{
		public override bool Accepts(object target)
		{
			return true;
		}
	}
	public class TeleportRule : GameObjectRule
	{
		public LayerMask layerMask;

		public Transform headsetAlias;

		public Transform handAlias;

		public LayerMask blockTeleportLayers;

		private RaycastHit _hit;

		private Hand _hand;

		protected override bool Accepts(GameObject targetGameObject)
		{
			if (((int)layerMask & (1 << targetGameObject.layer)) != 0)
			{
				Physics.Raycast(headsetAlias.position, handAlias.position - headsetAlias.position, out _hit, 2f, blockTeleportLayers, QueryTriggerInteraction.Collide);
				if (_hit.transform != null)
				{
					_hand = _hit.transform.GetComponentInParent<Hand>();
					if (_hand != null && _hand.transform == handAlias)
					{
						return true;
					}
				}
				else
				{
					_hand = null;
				}
				UnityEngine.Debug.Log(string.Concat("Target Object: ", targetGameObject, " | Layer: ", targetGameObject.layer, " | Hit: ", _hit.transform, " | Hand: ", _hand));
			}
			UnityEngine.Debug.Log(string.Concat("Target Object: ", targetGameObject, " | Layer: ", targetGameObject.layer));
			return false;
		}
	}
}
namespace RayFire
{
	[Serializable]
	public class RFFace
	{
		public int id;

		public float area;

		public Vector3 pos;

		public Vector3 normal;

		public List<int> tris;

		public RFFace(int Id, float Area, Vector3 Normal)
		{
			id = Id;
			area = Area;
			normal = Normal;
			tris = new List<int>();
		}

		private List<RFFace> GetFaces(List<RFTriangle> Triangles)
		{
			List<int> list = new List<int>();
			List<RFFace> list2 = new List<RFFace>();
			int num = 0;
			foreach (RFTriangle Triangle in Triangles)
			{
				if (list.Contains(Triangle.id))
				{
					continue;
				}
				list.Add(Triangle.id);
				RFFace rFFace = new RFFace(num, Triangle.area, Triangle.normal);
				rFFace.pos = Triangle.pos;
				num++;
				rFFace.tris.Add(Triangle.id);
				List<RFTriangle> list3 = new List<RFTriangle>();
				list3.Add(Triangle);
				while (list3.Count > 0)
				{
					foreach (int neib in list3[0].neibs)
					{
						if (!list.Contains(neib))
						{
							RFTriangle rFTriangle = Triangles[neib];
							if (Triangle.normal == rFTriangle.normal)
							{
								rFFace.area += rFTriangle.area;
								rFFace.pos += rFTriangle.pos;
								rFFace.tris.Add(neib);
								list.Add(neib);
								list3.Add(rFTriangle);
							}
						}
					}
					list3.RemoveAt(0);
				}
				rFFace.pos /= (float)rFFace.tris.Count;
				list2.Add(rFFace);
			}
			return list2;
		}
	}
	[Serializable]
	public class RFTriangle
	{
		public int id;

		public float area;

		public Vector3 normal;

		public Vector3 pos;

		public List<int> neibs;

		public RFTriangle(int Id, float Area, Vector3 Normal, Vector3 Pos)
		{
			id = Id;
			area = Area;
			normal = Normal;
			pos = Pos;
			neibs = new List<int>();
		}

		public static void SetTriangles(RFShard shard, MeshFilter mf)
		{
			if (shard.tris == null)
			{
				int[] triangles = mf.sharedMesh.triangles;
				Vector3[] vertices = mf.sharedMesh.vertices;
				shard.tris = new List<RFTriangle>();
				for (int i = 0; i < triangles.Length; i += 3)
				{
					int num = triangles[i];
					int num2 = triangles[i + 1];
					int num3 = triangles[i + 2];
					Vector3 vector = shard.tm.TransformPoint(vertices[num]);
					Vector3 vector2 = shard.tm.TransformPoint(vertices[num2]);
					Vector3 vector3 = shard.tm.TransformPoint(vertices[num3]);
					Vector3 vector4 = Vector3.Cross(vector - vector2, vector - vector3);
					Vector3 vector5 = (vector + vector2 + vector3) / 3f;
					shard.tris.Add(new RFTriangle(i / 3, vector4.magnitude * 0.5f, mf.sharedMesh.normals[num], vector5));
				}
			}
		}

		public static void Clear(RFShard shard)
		{
			if (shard.tris != null)
			{
				shard.tris.Clear();
			}
			shard.tris = null;
		}
	}
	[Serializable]
	public class RFManDemolition
	{
		public enum FragmentParentType
		{
			Manager,
			Parent
		}

		[Header("  Fragments")]
		[Space(2f)]
		public FragmentParentType parent;

		public int maximumAmount = 1000;

		[HideInInspector]
		public int currentAmount;

		[Range(1f, 10f)]
		public int badMeshTry = 3;

		[Header("  Shadow Casting")]
		[Range(0f, 1f)]
		public float sizeThreshold = 0.05f;
	}
	[Serializable]
	public class RFMaterial
	{
		private string name;

		[Header("  Demolition")]
		[Space(2f)]
		public bool destructible;

		[Range(0.01f, 100f)]
		public int solidity;

		[Header("  Rigid Body")]
		[Space(2f)]
		[Range(0.01f, 100f)]
		public float density;

		[Range(0f, 1f)]
		public float drag;

		[Range(0f, 1f)]
		public float angularDrag;

		[Header("  Physic Material")]
		[Space(2f)]
		public PhysicMaterial material;

		[Range(0.01f, 1f)]
		public float dynamicFriction;

		[Range(0.01f, 1f)]
		public float staticFriction;

		[Range(0.01f, 1f)]
		public float bounciness;

		public PhysicMaterial Material => new PhysicMaterial
		{
			name = name,
			dynamicFriction = dynamicFriction,
			staticFriction = staticFriction,
			bounciness = bounciness,
			frictionCombine = PhysicMaterialCombine.Minimum
		};

		public RFMaterial(string Name, float Density, float Drag, float AngularDrag, int Solidity, bool Destructible, float DynFriction, float StFriction, float Bounce)
		{
			name = Name;
			density = Density;
			drag = Drag;
			angularDrag = AngularDrag;
			solidity = Solidity;
			destructible = Destructible;
			dynamicFriction = DynFriction;
			staticFriction = StFriction;
			bounciness = Bounce;
		}
	}
	[Serializable]
	public class RFMaterialPresets
	{
		public RFMaterial heavyMetal;

		public RFMaterial lightMetal;

		public RFMaterial denseRock;

		public RFMaterial porousRock;

		public RFMaterial concrete;

		public RFMaterial brick;

		public RFMaterial glass;

		public RFMaterial rubber;

		public RFMaterial ice;

		public RFMaterial wood;

		public RFMaterialPresets()
		{
			heavyMetal = new RFMaterial("HeavyMetal", 11f, 0f, 0.05f, 80, Destructible: false, 0.75f, 0.7f, 0.17f);
			lightMetal = new RFMaterial("LightMetal", 8f, 0f, 0.05f, 50, Destructible: false, 0.71f, 0.72f, 0.14f);
			denseRock = new RFMaterial("DenseRock", 4f, 0f, 0.05f, 22, Destructible: true, 0.88f, 0.87f, 0.14f);
			porousRock = new RFMaterial("PorousRock", 2.5f, 0f, 0.05f, 12, Destructible: true, 0.84f, 0.82f, 0.16f);
			concrete = new RFMaterial("Concrete", 3f, 0f, 0.05f, 18, Destructible: true, 0.81f, 0.83f, 0.15f);
			brick = new RFMaterial("Brick", 2.3f, 0f, 0.05f, 10, Destructible: true, 0.76f, 0.75f, 0.13f);
			glass = new RFMaterial("Glass", 1.8f, 0f, 0.05f, 3, Destructible: true, 0.53f, 0.53f, 0.2f);
			rubber = new RFMaterial("Rubber", 1.4f, 0f, 0.05f, 1, Destructible: false, 0.95f, 0.98f, 0.93f);
			ice = new RFMaterial("Ice", 1f, 0f, 0.05f, 2, Destructible: true, 0.07f, 0.07f, 0f);
			wood = new RFMaterial("Wood", 0.7f, 0f, 0.05f, 4, Destructible: true, 0.75f, 0.73f, 0.22f);
		}

		public void SetMaterials()
		{
			if (heavyMetal.material == null)
			{
				heavyMetal.material = heavyMetal.Material;
			}
			if (lightMetal.material == null)
			{
				lightMetal.material = lightMetal.Material;
			}
			if (denseRock.material == null)
			{
				denseRock.material = denseRock.Material;
			}
			if (porousRock.material == null)
			{
				porousRock.material = porousRock.Material;
			}
			if (concrete.material == null)
			{
				concrete.material = concrete.Material;
			}
			if (brick.material == null)
			{
				brick.material = brick.Material;
			}
			if (glass.material == null)
			{
				glass.material = glass.Material;
			}
			if (rubber.material == null)
			{
				rubber.material = rubber.Material;
			}
			if (ice.material == null)
			{
				ice.material = ice.Material;
			}
			if (wood.material == null)
			{
				wood.material = wood.Material;
			}
		}

		public float Density(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.density, 
				MaterialType.LightMetal => lightMetal.density, 
				MaterialType.DenseRock => denseRock.density, 
				MaterialType.PorousRock => porousRock.density, 
				MaterialType.Concrete => concrete.density, 
				MaterialType.Brick => brick.density, 
				MaterialType.Glass => glass.density, 
				MaterialType.Rubber => rubber.density, 
				MaterialType.Ice => ice.density, 
				MaterialType.Wood => wood.density, 
				_ => 2f, 
			};
		}

		public float Drag(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.drag, 
				MaterialType.LightMetal => lightMetal.drag, 
				MaterialType.DenseRock => denseRock.drag, 
				MaterialType.PorousRock => porousRock.drag, 
				MaterialType.Concrete => concrete.drag, 
				MaterialType.Brick => brick.drag, 
				MaterialType.Glass => glass.drag, 
				MaterialType.Rubber => rubber.drag, 
				MaterialType.Ice => ice.drag, 
				MaterialType.Wood => wood.drag, 
				_ => 0f, 
			};
		}

		public float AngularDrag(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.angularDrag, 
				MaterialType.LightMetal => lightMetal.angularDrag, 
				MaterialType.DenseRock => denseRock.angularDrag, 
				MaterialType.PorousRock => porousRock.angularDrag, 
				MaterialType.Concrete => concrete.angularDrag, 
				MaterialType.Brick => brick.angularDrag, 
				MaterialType.Glass => glass.angularDrag, 
				MaterialType.Rubber => rubber.angularDrag, 
				MaterialType.Ice => ice.angularDrag, 
				MaterialType.Wood => wood.angularDrag, 
				_ => 0.05f, 
			};
		}

		public int Solidity(MaterialType materialType)
		{
			int num = 1;
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.solidity, 
				MaterialType.LightMetal => lightMetal.solidity, 
				MaterialType.DenseRock => denseRock.solidity, 
				MaterialType.PorousRock => porousRock.solidity, 
				MaterialType.Concrete => concrete.solidity, 
				MaterialType.Brick => brick.solidity, 
				MaterialType.Glass => glass.solidity, 
				MaterialType.Rubber => rubber.solidity, 
				MaterialType.Ice => ice.solidity, 
				MaterialType.Wood => wood.solidity, 
				_ => num, 
			};
		}

		public bool Destructible(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => heavyMetal.destructible, 
				MaterialType.LightMetal => lightMetal.destructible, 
				MaterialType.DenseRock => denseRock.destructible, 
				MaterialType.PorousRock => porousRock.destructible, 
				MaterialType.Concrete => concrete.destructible, 
				MaterialType.Brick => brick.destructible, 
				MaterialType.Glass => glass.destructible, 
				MaterialType.Rubber => rubber.destructible, 
				MaterialType.Ice => ice.destructible, 
				MaterialType.Wood => wood.destructible, 
				_ => true, 
			};
		}

		public static PhysicMaterial Material(MaterialType materialType)
		{
			return materialType switch
			{
				MaterialType.HeavyMetal => RayfireMan.inst.materialPresets.heavyMetal.material, 
				MaterialType.LightMetal => RayfireMan.inst.materialPresets.lightMetal.material, 
				MaterialType.DenseRock => RayfireMan.inst.materialPresets.denseRock.material, 
				MaterialType.PorousRock => RayfireMan.inst.materialPresets.porousRock.material, 
				MaterialType.Concrete => RayfireMan.inst.materialPresets.concrete.material, 
				MaterialType.Brick => RayfireMan.inst.materialPresets.brick.material, 
				MaterialType.Glass => RayfireMan.inst.materialPresets.glass.material, 
				MaterialType.Rubber => RayfireMan.inst.materialPresets.rubber.material, 
				MaterialType.Ice => RayfireMan.inst.materialPresets.ice.material, 
				MaterialType.Wood => RayfireMan.inst.materialPresets.wood.material, 
				_ => RayfireMan.inst.materialPresets.concrete.material, 
			};
		}
	}
	[Serializable]
	public class RFPoolingParticles
	{
		public bool enable = true;

		[Range(1f, 500f)]
		public int capacity = 60;

		[HideInInspector]
		public int poolRate = 2;

		[HideInInspector]
		public ParticleSystem poolInstance;

		[HideInInspector]
		public Transform poolRoot;

		[HideInInspector]
		public List<ParticleSystem> poolList;

		public void CreatePoolRoot(Transform manTm)
		{
			if (poolRoot == null)
			{
				GameObject gameObject = new GameObject("Pool_Particles");
				poolRoot = gameObject.transform;
				poolRoot.position = manTm.position;
				poolRoot.parent = manTm;
			}
		}

		public void CreateInstance(Transform manTm)
		{
			if (!(poolInstance != null))
			{
				poolInstance = CreateParticleInstance();
				poolInstance.transform.position = manTm.position;
				poolInstance.transform.rotation = manTm.rotation;
				poolInstance.transform.parent = poolRoot;
			}
		}

		public static ParticleSystem CreateParticleInstance()
		{
			GameObject gameObject = new GameObject("Instance");
			gameObject.SetActive(value: false);
			ParticleSystem particleSystem = gameObject.AddComponent<ParticleSystem>();
			particleSystem.Stop();
			return particleSystem;
		}

		public ParticleSystem GetPoolObject(Transform manTm)
		{
			ParticleSystem result;
			if (poolList.Count > 0)
			{
				result = poolList[poolList.Count - 1];
				poolList.RemoveAt(poolList.Count - 1);
			}
			else
			{
				result = CreatePoolObject(manTm);
			}
			return result;
		}

		private ParticleSystem CreatePoolObject(Transform manTm)
		{
			if (poolInstance == null)
			{
				CreateInstance(manTm);
			}
			return UnityEngine.Object.Instantiate(poolInstance, poolRoot);
		}

		public IEnumerator StartPoolingCor(Transform manTm)
		{
			poolList = new List<ParticleSystem>();
			WaitForSeconds delay = new WaitForSeconds(0.53f);
			while (enable)
			{
				if (poolList.Count < capacity)
				{
					for (int i = 0; i < poolRate; i++)
					{
						poolList.Add(CreatePoolObject(manTm));
					}
				}
				yield return delay;
			}
		}
	}
	[Serializable]
	public class RFPoolingFragment
	{
		public bool enable = true;

		[Range(1f, 500f)]
		public int capacity = 60;

		[HideInInspector]
		public int poolRate = 2;

		[HideInInspector]
		public RayfireRigid poolInstance;

		[HideInInspector]
		public Transform poolRoot;

		[HideInInspector]
		public List<RayfireRigid> poolList;

		public void CreatePoolRoot(Transform manTm)
		{
			if (poolRoot == null)
			{
				GameObject gameObject = new GameObject("Pool_Fragments");
				poolRoot = gameObject.transform;
				poolRoot.position = manTm.position;
				poolRoot.parent = manTm;
			}
		}

		public void CreateInstance(Transform manTm)
		{
			if (!(poolInstance != null))
			{
				poolInstance = CreateRigidInstance();
				poolInstance.transForm.position = manTm.position;
				poolInstance.transForm.rotation = manTm.rotation;
				poolInstance.transForm.parent = poolRoot;
			}
		}

		public static RayfireRigid CreateRigidInstance()
		{
			GameObject gameObject = new GameObject("Instance");
			gameObject.SetActive(value: false);
			MeshFilter meshFilter = gameObject.AddComponent<MeshFilter>();
			MeshRenderer meshRenderer = gameObject.AddComponent<MeshRenderer>();
			RayfireRigid rayfireRigid = gameObject.AddComponent<RayfireRigid>();
			rayfireRigid.initialization = RayfireRigid.InitType.AtStart;
			Rigidbody rigidbody = gameObject.AddComponent<Rigidbody>();
			rigidbody.collisionDetectionMode = RayfireMan.inst.collisionDetection;
			rayfireRigid.transForm = gameObject.transform;
			rayfireRigid.meshFilter = meshFilter;
			rayfireRigid.meshRenderer = meshRenderer;
			rayfireRigid.physics.rigidBody = rigidbody;
			return rayfireRigid;
		}

		public RayfireRigid GetPoolObject(Transform manTm)
		{
			RayfireRigid result;
			if (poolList != null && poolList.Count > 0)
			{
				result = poolList[poolList.Count - 1];
				poolList.RemoveAt(poolList.Count - 1);
			}
			else
			{
				result = CreatePoolObject(manTm);
			}
			return result;
		}

		private RayfireRigid CreatePoolObject(Transform manTm)
		{
			if (poolInstance == null)
			{
				CreateInstance(manTm);
			}
			return UnityEngine.Object.Instantiate(poolInstance, poolRoot);
		}

		public IEnumerator StartPoolingCor(Transform manTm)
		{
			poolList = new List<RayfireRigid>();
			WaitForSeconds delay = new WaitForSeconds(0.5f);
			while (enable)
			{
				if (poolList.Count < capacity)
				{
					for (int i = 0; i < poolRate; i++)
					{
						poolList.Add(CreatePoolObject(manTm));
					}
				}
				yield return delay;
			}
		}
	}
	[Serializable]
	public class RFCluster : IComparable<RFCluster>
	{
		public int id;

		public Transform tm;

		[HideInInspector]
		public int depth;

		[HideInInspector]
		public Vector3 pos;

		[HideInInspector]
		public Quaternion rot;

		[HideInInspector]
		public Bounds bound;

		[HideInInspector]
		public bool demolishable;

		[HideInInspector]
		public RayfireRigid rigid;

		[HideInInspector]
		public List<RFShard> shards;

		[HideInInspector]
		public float areaCollapse;

		[HideInInspector]
		public float minimumArea;

		[HideInInspector]
		public float maximumArea;

		[HideInInspector]
		public float sizeCollapse;

		[HideInInspector]
		public float minimumSize;

		[HideInInspector]
		public float maximumSize;

		[HideInInspector]
		public int randomCollapse;

		[HideInInspector]
		public int randomSeed;

		[NonSerialized]
		public bool initialized;

		[NonSerialized]
		public RFCluster mainCluster;

		[NonSerialized]
		public List<RFCluster> childClusters;

		[NonSerialized]
		public List<RFCluster> neibClusters;

		[NonSerialized]
		public List<float> neibArea;

		[NonSerialized]
		public List<float> neibPerc;

		public bool HasChildClusters
		{
			get
			{
				if (childClusters != null)
				{
					return childClusters.Count > 0;
				}
				return false;
			}
		}

		public bool UnyieldingByShard
		{
			get
			{
				for (int i = 0; i < shards.Count; i++)
				{
					if (shards[i].uny)
					{
						return true;
					}
				}
				return false;
			}
		}

		public bool UnyieldingByRigid
		{
			get
			{
				for (int i = 0; i < shards.Count; i++)
				{
					if (shards[i].rigid.activation.unyielding)
					{
						return true;
					}
				}
				return false;
			}
		}

		public RFCluster()
		{
			id = -1;
			tm = null;
			depth = 0;
			initialized = false;
			demolishable = true;
			shards = new List<RFShard>();
			rigid = null;
			minimumArea = 0f;
			maximumArea = 0f;
			minimumSize = 0f;
			maximumSize = 0f;
			randomCollapse = 0;
			mainCluster = null;
			childClusters = null;
		}

		public RFCluster(RFCluster source)
		{
			id = source.id;
			tm = source.tm;
			depth = source.depth;
			pos = source.pos;
			rot = source.rot;
			bound = source.bound;
			rigid = source.rigid;
			demolishable = source.demolishable;
			areaCollapse = source.areaCollapse;
			minimumArea = source.minimumArea;
			maximumArea = source.maximumArea;
			sizeCollapse = source.sizeCollapse;
			minimumSize = source.minimumSize;
			maximumSize = source.maximumSize;
			randomCollapse = source.randomCollapse;
			randomSeed = source.randomSeed;
			shards = new List<RFShard>();
			for (int i = 0; i < source.shards.Count; i++)
			{
				shards.Add(new RFShard(source.shards[i]));
			}
			if (source.HasChildClusters)
			{
				childClusters = new List<RFCluster>();
				for (int j = 0; j < source.childClusters.Count; j++)
				{
					childClusters.Add(new RFCluster(source.childClusters[j]));
				}
			}
			initialized = false;
		}

		public int CompareTo(RFCluster otherCluster)
		{
			float magnitude = bound.size.magnitude;
			float magnitude2 = otherCluster.bound.size.magnitude;
			if (magnitude > magnitude2)
			{
				return -1;
			}
			if (magnitude < magnitude2)
			{
				return 1;
			}
			return 0;
		}

		public static void InitCluster(RayfireRigid scr, RFCluster cluster)
		{
			if (cluster.initialized)
			{
				return;
			}
			if (scr.objectType == ObjectType.ConnectedCluster)
			{
				for (int i = 0; i < cluster.shards.Count; i++)
				{
					cluster.shards[i].cluster = cluster;
					cluster.shards[i].neibShards = new List<RFShard>();
					for (int j = 0; j < cluster.shards[i].nIds.Count; j++)
					{
						cluster.shards[i].neibShards.Add(cluster.shards[cluster.shards[i].nIds[j]]);
					}
				}
			}
			if (scr.objectType == ObjectType.NestedCluster)
			{
				UnfoldNestedCluster(scr, cluster);
			}
			cluster.initialized = true;
		}

		private static void UnfoldNestedCluster(RayfireRigid scr, RFCluster cluster)
		{
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				cluster.shards[i].cluster = cluster;
			}
			for (int j = 0; j < scr.clusterDemolition.minorClusters.Count; j++)
			{
				if (cluster.tm == scr.clusterDemolition.minorClusters[j].tm.parent)
				{
					if (!cluster.HasChildClusters)
					{
						cluster.childClusters = new List<RFCluster>();
					}
					scr.clusterDemolition.minorClusters[j].mainCluster = scr.clusterDemolition.cluster;
					cluster.childClusters.Add(scr.clusterDemolition.minorClusters[j]);
				}
			}
			if (cluster.HasChildClusters)
			{
				for (int k = 0; k < cluster.childClusters.Count; k++)
				{
					UnfoldNestedCluster(scr, cluster.childClusters[k]);
				}
			}
		}

		public static void ConnectivityUnyCheck(RFCluster cluster)
		{
			if (cluster.childClusters != null)
			{
				cluster.childClusters.Clear();
			}
			if (cluster.shards.Count <= 1)
			{
				return;
			}
			int count = cluster.shards.Count;
			List<int> list = new List<int>();
			List<RFShard> list2 = new List<RFShard>();
			List<RFShard> list3 = new List<RFShard>();
			for (int num = cluster.shards.Count - 1; num >= 0; num--)
			{
				if (!list.Contains(cluster.shards[num].id))
				{
					list.Add(cluster.shards[num].id);
					list3.Clear();
					list3.Add(cluster.shards[num]);
					list2.Clear();
					list2.Add(cluster.shards[num]);
					while (list2.Count > 0)
					{
						for (int i = 0; i < list2[0].neibShards.Count; i++)
						{
							if (!list3.Contains(list2[0].neibShards[i]))
							{
								list2.Add(list2[0].neibShards[i]);
								list3.Add(list2[0].neibShards[i]);
								list.Add(list2[0].neibShards[i].id);
							}
						}
						list2.RemoveAt(0);
					}
					if (count == list3.Count)
					{
						break;
					}
					if (!RFShard.UnyieldingByShard(list3))
					{
						RFCluster rFCluster = new RFCluster();
						for (int j = 0; j < list3.Count; j++)
						{
							rFCluster.shards.Add(list3[j]);
						}
						rFCluster.demolishable = cluster.demolishable;
						if (cluster.mainCluster == null)
						{
							rFCluster.mainCluster = cluster;
						}
						else
						{
							rFCluster.mainCluster = cluster.mainCluster;
						}
						rFCluster.id = GetUniqClusterId(rFCluster);
						for (int k = 0; k < rFCluster.shards.Count; k++)
						{
							rFCluster.shards[k].cluster = rFCluster;
						}
						if (cluster.childClusters == null)
						{
							cluster.childClusters = new List<RFCluster>();
						}
						cluster.childClusters.Add(rFCluster);
					}
				}
			}
			if (cluster.childClusters != null && cluster.childClusters.Count > 0)
			{
				for (int num2 = cluster.shards.Count - 1; num2 >= 0; num2--)
				{
					if (cluster.shards[num2].cluster != cluster)
					{
						cluster.shards.RemoveAt(num2);
					}
				}
			}
			list.Clear();
			if (cluster.shards.Count == 0)
			{
				ReduceChildClusters(cluster);
			}
		}

		public static void ConnectivityCheck(RFCluster cluster)
		{
			if (cluster.childClusters != null)
			{
				cluster.childClusters.Clear();
			}
			if (cluster.shards.Count <= 1)
			{
				return;
			}
			int count = cluster.shards.Count;
			List<RFShard> list = new List<RFShard>();
			List<RFShard> list2 = new List<RFShard>();
			while (cluster.shards.Count > 0)
			{
				list.Clear();
				list.Add(cluster.shards[0]);
				list2.Clear();
				list2.Add(cluster.shards[0]);
				while (list.Count > 0)
				{
					for (int i = 0; i < list[0].neibShards.Count; i++)
					{
						if (!list2.Contains(list[0].neibShards[i]))
						{
							list.Add(list[0].neibShards[i]);
							list2.Add(list[0].neibShards[i]);
						}
					}
					list.RemoveAt(0);
				}
				if (count == list2.Count)
				{
					break;
				}
				RFCluster rFCluster = new RFCluster();
				for (int j = 0; j < list2.Count; j++)
				{
					rFCluster.shards.Add(list2[j]);
				}
				rFCluster.demolishable = cluster.demolishable;
				if (cluster.mainCluster == null)
				{
					rFCluster.mainCluster = cluster;
				}
				else
				{
					rFCluster.mainCluster = cluster.mainCluster;
				}
				rFCluster.id = GetUniqClusterId(rFCluster);
				for (int k = 0; k < rFCluster.shards.Count; k++)
				{
					rFCluster.shards[k].cluster = rFCluster;
				}
				if (cluster.childClusters == null)
				{
					cluster.childClusters = new List<RFCluster>();
				}
				cluster.childClusters.Add(rFCluster);
				for (int num = cluster.shards.Count - 1; num >= 0; num--)
				{
					if (cluster.shards[num].cluster != cluster)
					{
						cluster.shards.RemoveAt(num);
					}
				}
			}
		}

		public static void ReduceChildClusters(RFCluster cluster)
		{
			if (cluster.childClusters != null && cluster.childClusters.Count > 0)
			{
				int biggestCluster = GetBiggestCluster(cluster.childClusters);
				cluster.shards = cluster.childClusters[biggestCluster].shards;
				for (int i = 0; i < cluster.shards.Count; i++)
				{
					cluster.shards[i].cluster = cluster;
				}
				cluster.childClusters.RemoveAt(biggestCluster);
			}
		}

		public static void ConnectivityCheckUny(RFCluster cluster)
		{
			if (cluster.shards.Count == 0)
			{
				return;
			}
			cluster.childClusters = new List<RFCluster>();
			List<RFShard> list = new List<RFShard>();
			List<RFShard> list2 = new List<RFShard>();
			foreach (RFShard shard in cluster.shards)
			{
				if (shard.rigid.activation.unyielding)
				{
					list2.Add(shard);
				}
				else
				{
					list.Add(shard);
				}
			}
			if (list.Count == 0)
			{
				cluster.shards.Clear();
				return;
			}
			while (list2.Count > 0)
			{
				foreach (RFShard neibShard in list2[0].neibShards)
				{
					if (list.Contains(neibShard))
					{
						list.Remove(neibShard);
						list2.Add(neibShard);
					}
				}
				list2.RemoveAt(0);
			}
			foreach (RFShard item in list)
			{
				cluster.shards.Remove(item);
			}
			if (list.Count != 0)
			{
				RFCluster rFCluster = new RFCluster();
				rFCluster.shards = list;
				cluster.childClusters.Add(rFCluster);
			}
		}

		public static Bounds GetChildrenBound(Transform tm)
		{
			List<Renderer> list = tm.GetComponentsInChildren<Renderer>().ToList();
			List<Bounds> list2 = new List<Bounds>();
			for (int i = 0; i < list.Count; i++)
			{
				list2.Add(list[i].bounds);
			}
			return GetBoundsBound(list2);
		}

		public static Bounds GetClusterBound(RFCluster cluster)
		{
			List<Bounds> list = new List<Bounds>();
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				list.Add(cluster.shards[i].bnd);
			}
			for (int j = 0; j < cluster.childClusters.Count; j++)
			{
				list.Add(cluster.childClusters[j].bound);
			}
			return GetBoundsBound(list);
		}

		public static Bounds GetBoundsBound(List<Bounds> bounds)
		{
			Bounds result = default(Bounds);
			if (bounds.Count == 0)
			{
				UnityEngine.Debug.Log("GetBoundsBound error");
				return result;
			}
			float x = bounds[0].min.x;
			float y = bounds[0].min.y;
			float z = bounds[0].min.z;
			float x2 = bounds[0].max.x;
			float y2 = bounds[0].max.y;
			float z2 = bounds[0].max.z;
			if (bounds.Count > 1)
			{
				for (int i = 1; i < bounds.Count; i++)
				{
					if (bounds[i].min.x < x)
					{
						x = bounds[i].min.x;
					}
					if (bounds[i].min.y < y)
					{
						y = bounds[i].min.y;
					}
					if (bounds[i].min.z < z)
					{
						z = bounds[i].min.z;
					}
					if (bounds[i].max.x > x2)
					{
						x2 = bounds[i].max.x;
					}
					if (bounds[i].max.y > y2)
					{
						y2 = bounds[i].max.y;
					}
					if (bounds[i].max.z > z2)
					{
						z2 = bounds[i].max.z;
					}
				}
			}
			result.center = new Vector3((x2 - x) / 2f, (y2 - y) / 2f, (z2 - z) / 2f);
			result.min = new Vector3(x, y, z);
			result.max = new Vector3(x2, y2, z2);
			return result;
		}

		public static Bounds GetShardsBound(List<RFShard> shards)
		{
			Bounds result = default(Bounds);
			if (shards.Count == 0)
			{
				UnityEngine.Debug.Log("GetBoundsBound error");
				return result;
			}
			float x = shards[0].bnd.min.x;
			float y = shards[0].bnd.min.y;
			float z = shards[0].bnd.min.z;
			float x2 = shards[0].bnd.max.x;
			float y2 = shards[0].bnd.max.y;
			float z2 = shards[0].bnd.max.z;
			if (shards.Count > 1)
			{
				for (int i = 1; i < shards.Count; i++)
				{
					if (shards[i].bnd.min.x < x)
					{
						x = shards[i].bnd.min.x;
					}
					if (shards[i].bnd.min.y < y)
					{
						y = shards[i].bnd.min.y;
					}
					if (shards[i].bnd.min.z < z)
					{
						z = shards[i].bnd.min.z;
					}
					if (shards[i].bnd.max.x > x2)
					{
						x2 = shards[i].bnd.max.x;
					}
					if (shards[i].bnd.max.y > y2)
					{
						y2 = shards[i].bnd.max.y;
					}
					if (shards[i].bnd.max.z > z2)
					{
						z2 = shards[i].bnd.max.z;
					}
				}
			}
			result.center = new Vector3((x2 - x) / 2f, (y2 - y) / 2f, (z2 - z) / 2f);
			result.min = new Vector3(x, y, z);
			result.max = new Vector3(x2, y2, z2);
			return result;
		}

		public static int GetBiggestCluster(List<RFCluster> clusters)
		{
			if (clusters.Count == 1)
			{
				return 0;
			}
			int result = 0;
			int num = 0;
			for (int i = 0; i < clusters.Count; i++)
			{
				if (clusters[i].shards.Count > num)
				{
					num = clusters[i].shards.Count;
					result = i;
				}
			}
			return result;
		}

		public static void GetSoloShards(RFCluster cluster, List<RFShard> soloShards)
		{
			for (int num = cluster.shards.Count - 1; num >= 0; num--)
			{
				if (cluster.shards[num].neibShards.Count == 0)
				{
					soloShards.Add(cluster.shards[num]);
					cluster.shards[num].cluster = null;
					cluster.shards.RemoveAt(num);
				}
			}
		}

		public static int GetUniqClusterId(RFCluster cluster)
		{
			if (cluster.mainCluster == null)
			{
				return 1;
			}
			if (cluster.mainCluster.rigid == null)
			{
				return 2;
			}
			cluster.mainCluster.rigid.clusterDemolition.clsCount++;
			return cluster.mainCluster.rigid.clusterDemolition.clsCount;
		}

		public static bool IntegrityCheck(RFCluster cluster)
		{
			if (cluster != null && cluster.shards.Count > 0)
			{
				for (int i = 0; i < cluster.shards.Count; i++)
				{
					if (cluster.shards[i].tm == null)
					{
						return false;
					}
				}
			}
			return true;
		}

		private List<RFShard> GetNestedShards(bool OwnShards = false)
		{
			List<RFShard> list = new List<RFShard>();
			List<RFCluster> list2 = new List<RFCluster>();
			list2.AddRange(childClusters);
			if (OwnShards)
			{
				list.AddRange(shards);
			}
			while (list2.Count > 0)
			{
				list.AddRange(list2[0].shards);
				list2.AddRange(list2[0].childClusters);
				list2.RemoveAt(0);
			}
			return list;
		}

		public List<RFCluster> GetNestedClusters()
		{
			List<RFCluster> list = new List<RFCluster>();
			list.AddRange(childClusters);
			List<RFCluster> list2 = new List<RFCluster>();
			list2.AddRange(childClusters);
			while (list2.Count > 0)
			{
				list.AddRange(list2[0].childClusters);
				list2.RemoveAt(0);
			}
			return list;
		}

		private bool TrisNeib(RFCluster otherCluster)
		{
			foreach (RFShard shard in shards)
			{
				for (int i = 0; i < shard.neibShards.Count; i++)
				{
					if (otherCluster.shards.Contains(shard.neibShards[i]))
					{
						return true;
					}
				}
			}
			List<RFShard> nestedShards = GetNestedShards();
			List<RFShard> nestedShards2 = otherCluster.GetNestedShards();
			foreach (RFShard item in nestedShards)
			{
				for (int j = 0; j < item.neibShards.Count; j++)
				{
					if (nestedShards2.Contains(item.neibShards[j]))
					{
						return true;
					}
				}
			}
			return false;
		}

		private float NeibArea(RFCluster otherCluster)
		{
			float num = 0f;
			foreach (RFShard shard in shards)
			{
				for (int i = 0; i < shard.neibShards.Count; i++)
				{
					if (otherCluster.shards.Contains(shard.neibShards[i]))
					{
						num += shard.nArea[i];
					}
				}
			}
			List<RFShard> nestedShards = GetNestedShards();
			List<RFShard> nestedShards2 = otherCluster.GetNestedShards();
			foreach (RFShard item in nestedShards)
			{
				for (int j = 0; j < item.neibShards.Count; j++)
				{
					if (nestedShards2.Contains(item.neibShards[j]))
					{
						num += item.nArea[j];
					}
				}
			}
			return num;
		}

		public int GetNeibIndArea(List<RFCluster> clusterList = null)
		{
			float num = 0f;
			int result = 0;
			for (int i = 0; i < neibClusters.Count; i++)
			{
				if ((clusterList == null || clusterList.Contains(neibClusters[i])) && neibArea[i] > num)
				{
					num = neibArea[i];
					result = i;
				}
			}
			if (num > 0f)
			{
				return result;
			}
			return -1;
		}

		public static void SetClusterNeib(List<RFCluster> clusters, bool connectivity)
		{
			foreach (RFCluster cluster in clusters)
			{
				cluster.neibClusters = new List<RFCluster>();
				cluster.neibArea = new List<float>();
				cluster.neibPerc = new List<float>();
			}
			for (int i = 0; i < clusters.Count; i++)
			{
				for (int j = 0; j < clusters.Count; j++)
				{
					if (j != i && !clusters[j].neibClusters.Contains(clusters[i]) && clusters[i].bound.Intersects(clusters[j].bound))
					{
						if (!connectivity)
						{
							float magnitude = clusters[i].bound.size.magnitude;
							clusters[i].neibClusters.Add(clusters[j]);
							clusters[i].neibArea.Add(magnitude);
							clusters[j].neibClusters.Add(clusters[i]);
							clusters[j].neibArea.Add(magnitude);
						}
						else if (clusters[i].TrisNeib(clusters[j]))
						{
							float item = clusters[i].NeibArea(clusters[j]);
							clusters[i].neibClusters.Add(clusters[j]);
							clusters[i].neibArea.Add(item);
							clusters[j].neibClusters.Add(clusters[i]);
							clusters[j].neibArea.Add(item);
						}
					}
				}
				float num = Mathf.Max(clusters[i].neibArea.ToArray());
				foreach (float item2 in clusters[i].neibArea)
				{
					if (num > 0f)
					{
						clusters[i].neibPerc.Add(item2 / num);
					}
					else
					{
						clusters[i].neibPerc.Add(0f);
					}
				}
			}
		}

		public static RFCluster GetNeibClusterArea(List<RFCluster> clusters, List<RFCluster> clusterList)
		{
			if (clusterList.Count == 0)
			{
				return null;
			}
			List<RFCluster> list = new List<RFCluster>();
			float num = 0f;
			RFCluster result = null;
			foreach (RFCluster cluster in clusters)
			{
				for (int i = 0; i < cluster.neibClusters.Count; i++)
				{
					if (!(cluster.neibPerc[i] < 0.5f) && !(num >= cluster.neibArea[i]) && !list.Contains(cluster.neibClusters[i]) && clusterList.Contains(cluster.neibClusters[i]))
					{
						list.Add(cluster.neibClusters[i]);
						num = cluster.neibArea[i];
						result = cluster.neibClusters[i];
					}
				}
			}
			return result;
		}
	}
	public class RFEvent
	{
		public delegate void EventAction(RayfireRigid rigid);

		public event EventAction LocalEvent;

		public void InvokeLocalEvent(RayfireRigid rigid)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(rigid);
			}
		}
	}
	public class RFDemolitionEvent : RFEvent
	{
		public static event EventAction GlobalEvent;

		public static void InvokeGlobalEvent(RayfireRigid rigid)
		{
			if (RFDemolitionEvent.GlobalEvent != null)
			{
				RFDemolitionEvent.GlobalEvent(rigid);
			}
		}
	}
	public class RFActivationEvent : RFEvent
	{
		public static event EventAction GlobalEvent;

		public static void InvokeGlobalEvent(RayfireRigid rigid)
		{
			if (RFActivationEvent.GlobalEvent != null)
			{
				RFActivationEvent.GlobalEvent(rigid);
			}
		}
	}
	public class RFRestrictionEvent : RFEvent
	{
		public static event EventAction GlobalEvent;

		public static void InvokeGlobalEvent(RayfireRigid rigid)
		{
			if (RFRestrictionEvent.GlobalEvent != null)
			{
				RFRestrictionEvent.GlobalEvent(rigid);
			}
		}
	}
	public class RFShotEvent
	{
		public delegate void EventAction(RayfireGun gun);

		public static event EventAction GlobalEvent;

		public event EventAction LocalEvent;

		public static void InvokeGlobalEvent(RayfireGun gun)
		{
			if (RFShotEvent.GlobalEvent != null)
			{
				RFShotEvent.GlobalEvent(gun);
			}
		}

		public void InvokeLocalEvent(RayfireGun gun)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(gun);
			}
		}
	}
	public class RFExplosionEvent
	{
		public delegate void EventAction(RayfireBomb bomb);

		public static event EventAction GlobalEvent;

		public event EventAction LocalEvent;

		public static void InvokeGlobalEvent(RayfireBomb bomb)
		{
			if (RFExplosionEvent.GlobalEvent != null)
			{
				RFExplosionEvent.GlobalEvent(bomb);
			}
		}

		public void InvokeLocalEvent(RayfireBomb bomb)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(bomb);
			}
		}
	}
	public class RFSliceEvent
	{
		public delegate void EventAction(RayfireBlade blade);

		public static event EventAction GlobalEvent;

		public event EventAction LocalEvent;

		public static void InvokeGlobalEvent(RayfireBlade blade)
		{
			if (RFSliceEvent.GlobalEvent != null)
			{
				RFSliceEvent.GlobalEvent(blade);
			}
		}

		public void InvokeLocalEvent(RayfireBlade blade)
		{
			if (this.LocalEvent != null)
			{
				this.LocalEvent(blade);
			}
		}
	}
	[Serializable]
	public class RFFlash
	{
		[Header("  Intensity")]
		[Space(3f)]
		[Range(0.1f, 5f)]
		public float intensityMin;

		[Space(1f)]
		[Range(0.1f, 5f)]
		public float intensityMax;

		[Header("  Range")]
		[Space(3f)]
		[Range(0.01f, 10f)]
		public float rangeMin;

		[Space(1f)]
		[Range(0.01f, 10f)]
		public float rangeMax;

		[Header("  Other")]
		[Space(3f)]
		[Range(0.01f, 2f)]
		public float distance;

		[Space(1f)]
		public Color color;

		public RFFlash()
		{
			intensityMin = 0.5f;
			intensityMax = 0.7f;
			rangeMin = 5f;
			rangeMax = 7f;
			distance = 0.4f;
			color = new Color(1f, 1f, 0.8f);
		}
	}
	[Serializable]
	public class RFDecals
	{
		public bool enable;

		[Header("  Size")]
		[Space(2f)]
		[Range(0.1f, 5f)]
		public float sizeMin;

		[Space(1f)]
		[Range(0.1f, 5f)]
		public float sizeMax;

		[Header("  Limitations")]
		[Space(2f)]
		[Range(0.01f, 2f)]
		public float distance;

		public RFDecals()
		{
			enable = true;
			distance = 0.4f;
		}
	}
	[Serializable]
	public class RFMesh
	{
		[Serializable]
		public class RFSubMeshTris
		{
			public List<int> triangles;

			public RFSubMeshTris()
			{
				triangles = new List<int>();
			}

			public RFSubMeshTris(List<int> tris)
			{
				triangles = tris;
			}
		}

		public bool compress;

		public int subMeshCount;

		public Bounds bounds;

		public int[] triangles;

		public List<RFSubMeshTris> subTriangles;

		public Vector2[] uv;

		public Vector3[] vertices;

		public Vector4[] tangents;

		public List<int> uvComp;

		public List<int> verticesComp;

		public List<int> tangentsComp;

		public RFMesh(Mesh mesh, bool comp = false)
		{
			compress = comp;
			subMeshCount = mesh.subMeshCount;
			bounds = mesh.bounds;
			subTriangles = new List<RFSubMeshTris>();
			if (subMeshCount <= 1)
			{
				triangles = mesh.triangles;
			}
			else if (subMeshCount > 1)
			{
				for (int i = 0; i < subMeshCount; i++)
				{
					subTriangles.Add(new RFSubMeshTris(mesh.GetTriangles(i).ToList()));
				}
			}
			if (!comp)
			{
				uv = mesh.uv;
				vertices = mesh.vertices;
				tangents = mesh.tangents;
				return;
			}
			uvComp = new List<int>();
			verticesComp = new List<int>();
			tangentsComp = new List<int>();
			Vector2[] array = mesh.uv;
			for (int j = 0; j < array.Length; j++)
			{
				Vector2 vector = array[j];
				uvComp.Add(Mathf.RoundToInt(vector.x * 1000f));
				uvComp.Add(Mathf.RoundToInt(vector.y * 1000f));
			}
			Vector3[] array2 = mesh.vertices;
			for (int j = 0; j < array2.Length; j++)
			{
				Vector3 vector2 = array2[j];
				verticesComp.Add(Mathf.RoundToInt(vector2.x * 1000f));
				verticesComp.Add(Mathf.RoundToInt(vector2.y * 1000f));
				verticesComp.Add(Mathf.RoundToInt(vector2.z * 1000f));
			}
			Vector4[] array3 = mesh.tangents;
			for (int j = 0; j < array3.Length; j++)
			{
				Vector4 vector3 = array3[j];
				tangentsComp.Add(Mathf.RoundToInt(vector3.x * 1000f));
				tangentsComp.Add(Mathf.RoundToInt(vector3.y * 1000f));
				tangentsComp.Add(Mathf.RoundToInt(vector3.z * 1000f));
			}
		}

		public Mesh GetMesh()
		{
			Mesh mesh = new Mesh();
			mesh.subMeshCount = subMeshCount;
			if (!compress)
			{
				mesh.vertices = vertices;
				LoadTriangles(mesh);
				mesh.uv = uv;
				mesh.tangents = tangents;
			}
			else
			{
				mesh.vertices = SetCompressedVertices(verticesComp);
				LoadTriangles(mesh);
				mesh.uv = SetCompressedUv(uvComp);
				mesh.tangents = SetCompressedTangents(tangentsComp);
			}
			mesh.RecalculateNormals();
			mesh.RecalculateTangents();
			mesh.RecalculateBounds();
			return mesh;
		}

		private void LoadTriangles(Mesh mesh)
		{
			if (subMeshCount == 1)
			{
				mesh.triangles = triangles;
			}
			else if (subMeshCount > 1)
			{
				for (int i = 0; i < subMeshCount; i++)
				{
					mesh.SetTriangles(subTriangles[i].triangles, i);
				}
			}
		}

		public static Mesh BakeMesh(SkinnedMeshRenderer skin)
		{
			Mesh mesh = new Mesh();
			skin.BakeMesh(mesh);
			mesh.name = skin.name + "_bake";
			return mesh;
		}

		public static void ConvertRfMeshes(RayfireRigid rigid)
		{
			rigid.meshes = new Mesh[rigid.rfMeshes.Length];
			for (int i = 0; i < rigid.rfMeshes.Length; i++)
			{
				rigid.meshes[i] = rigid.rfMeshes[i].GetMesh();
			}
			rigid.rfMeshes = null;
		}

		private static Vector2[] SetCompressedUv(List<int> uvComp)
		{
			Vector2[] array = new Vector2[uvComp.Count / 2];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Vector2((float)uvComp[i * 2] / 1000f, (float)uvComp[i * 2 + 1] / 1000f);
			}
			return array;
		}

		private static Vector3[] SetCompressedVertices(List<int> verticesComp)
		{
			Vector3[] array = new Vector3[verticesComp.Count / 3];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Vector3((float)verticesComp[i * 3] / 1000f, (float)verticesComp[i * 3 + 1] / 1000f, (float)verticesComp[i * 3 + 2] / 1000f);
			}
			return array;
		}

		private static Vector4[] SetCompressedTangents(List<int> tangentsComp)
		{
			Vector4[] array = new Vector4[tangentsComp.Count / 3];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new Vector3((float)tangentsComp[i * 3] / 1000f, (float)tangentsComp[i * 3 + 1] / 1000f, (float)tangentsComp[i * 3 + 2] / 1000f);
			}
			return array;
		}
	}
	[Serializable]
	public class RFParticleNoise
	{
		[Header("  Main")]
		[Space(3f)]
		public bool enabled;

		[Space(2f)]
		public ParticleSystemNoiseQuality quality;

		[Header("  Strength")]
		[Space(3f)]
		[Range(0f, 3f)]
		public float strengthMin;

		[Space(2f)]
		[Range(0f, 3f)]
		public float strengthMax;

		[Header("  Other")]
		[Space(3f)]
		[Range(0.001f, 3f)]
		public float frequency;

		[Space(2f)]
		[Range(0f, 2f)]
		public float scrollSpeed;

		[Space(2f)]
		public bool damping;

		public RFParticleNoise()
		{
			enabled = false;
			strengthMin = 0.3f;
			strengthMax = 0.6f;
			frequency = 0.3f;
			scrollSpeed = 0.7f;
			damping = true;
			quality = ParticleSystemNoiseQuality.High;
		}

		public void CopyFrom(RFParticleNoise source)
		{
			enabled = source.enabled;
			strengthMin = source.strengthMin;
			strengthMax = source.strengthMax;
			frequency = source.frequency;
			scrollSpeed = source.scrollSpeed;
			damping = source.damping;
			quality = source.quality;
		}
	}
	[Serializable]
	public class RFParticleRendering
	{
		[Header("  Shadows")]
		[Space(3f)]
		public bool castShadows;

		[Space(2f)]
		public bool receiveShadows;

		public RFParticleRendering()
		{
			castShadows = true;
			receiveShadows = true;
		}

		public void CopyFrom(RFParticleRendering source)
		{
			castShadows = source.castShadows;
			receiveShadows = source.receiveShadows;
		}
	}
	[Serializable]
	public class RFParticleDynamicDebris
	{
		[Header("  Speed")]
		[Space(3f)]
		[Range(0f, 10f)]
		public float speedMin;

		[Space(2f)]
		[Range(0f, 10f)]
		public float speedMax;

		[Header("  Inherit Velocity")]
		[Space(3f)]
		[Range(0f, 3f)]
		public float velocityMin;

		[Space(2f)]
		[Range(0f, 3f)]
		public float velocityMax;

		[Header("  Gravity Modifier")]
		[Space(3f)]
		[Range(-2f, 2f)]
		public float gravityMin;

		[Space(2f)]
		[Range(-2f, 2f)]
		public float gravityMax;

		[Header("  Rotation")]
		[Space(3f)]
		[Range(0f, 1f)]
		public float rotationSpeed;

		public RFParticleDynamicDebris()
		{
			speedMin = 1f;
			speedMax = 4f;
			velocityMin = 0.5f;
			velocityMax = 1.5f;
			rotationSpeed = 0.5f;
			gravityMin = 0.8f;
			gravityMax = 1.1f;
		}

		public void CopyFrom(RFParticleDynamicDebris source)
		{
			speedMin = source.speedMin;
			speedMax = source.speedMax;
			velocityMin = source.velocityMin;
			velocityMax = source.velocityMax;
			rotationSpeed = source.rotationSpeed;
			gravityMin = source.gravityMin;
			gravityMax = source.gravityMax;
		}
	}
	[Serializable]
	public class RFParticleDynamicDust
	{
		[Header("  Velocity")]
		[Space(3f)]
		[Range(0f, 10f)]
		public float speedMin;

		[Space(2f)]
		[Range(0f, 10f)]
		public float speedMax;

		[Header("  Rotation")]
		[Space(3f)]
		[Range(0f, 1f)]
		public float rotation;

		[Header("  Gravity Modifier")]
		[Space(3f)]
		[Range(-2f, 2f)]
		public float gravityMin;

		[Space(2f)]
		[Range(-2f, 2f)]
		public float gravityMax;

		public RFParticleDynamicDust()
		{
			speedMin = 0.5f;
			speedMax = 1f;
			rotation = 0.5f;
			gravityMin = 0.01f;
			gravityMax = 0.6f;
		}

		public void CopyFrom(RFParticleDynamicDust source)
		{
			speedMin = source.speedMin;
			speedMax = source.speedMax;
			rotation = source.rotation;
			gravityMin = source.gravityMin;
			gravityMax = source.gravityMax;
		}
	}
	[Serializable]
	public class RFParticleEmission
	{
		[Header("  Burst")]
		[Space(3f)]
		public RFParticles.BurstType burstType;

		[Space(2f)]
		[Range(0f, 500f)]
		public int burstAmount;

		[Header("  Distance")]
		[Space(3f)]
		[Range(0f, 5f)]
		public float distanceRate;

		[Space(2f)]
		[Range(0.5f, 10f)]
		public float duration;

		[Header("  Lifetime")]
		[Space(3f)]
		[Range(1f, 60f)]
		public float lifeMin;

		[Space(2f)]
		[Range(1f, 60f)]
		public float lifeMax;

		[Header("  Size")]
		[Space(3f)]
		[Range(0.1f, 10f)]
		public float sizeMin;

		[Space(2f)]
		[Range(0.1f, 10f)]
		public float sizeMax;

		public RFParticleEmission()
		{
			burstType = RFParticles.BurstType.PerOneUnitSize;
			burstAmount = 20;
			duration = 4f;
			distanceRate = 1f;
			lifeMin = 2f;
			lifeMax = 13f;
			sizeMin = 0.5f;
			sizeMax = 2.5f;
		}

		public void CopyFrom(RFParticleEmission source)
		{
			burstType = source.burstType;
			burstAmount = source.burstAmount;
			distanceRate = source.distanceRate;
			lifeMin = source.lifeMin;
			lifeMax = source.lifeMax;
			sizeMin = source.sizeMin;
			sizeMax = source.sizeMax;
		}
	}
	[Serializable]
	public class RFParticleLimitations
	{
		[Header("  Particle system")]
		[Space(3f)]
		[Range(3f, 100f)]
		public int minParticles;

		[Space(2f)]
		[Range(5f, 100f)]
		public int maxParticles;

		[Header("  Fragments")]
		[Space(3f)]
		[Range(10f, 100f)]
		public int percentage;

		[Space(2f)]
		[Range(0.05f, 5f)]
		public float sizeThreshold;

		[HideInInspector]
		[Range(0f, 5f)]
		public int demolitionDepth;

		public RFParticleLimitations()
		{
			minParticles = 3;
			maxParticles = 20;
			percentage = 50;
			sizeThreshold = 0.5f;
			demolitionDepth = 2;
		}

		public void CopyFrom(RFParticleLimitations source)
		{
			minParticles = source.minParticles;
			maxParticles = source.maxParticles;
			percentage = source.percentage;
			sizeThreshold = source.sizeThreshold;
			demolitionDepth = source.demolitionDepth;
		}
	}
	[Serializable]
	public class RFParticleCollisionDebris
	{
		public enum RFParticleCollisionWithType
		{
			Everything,
			Nothing
		}

		public enum RFParticleCollisionMatType
		{
			ByPhysicalMaterial,
			ByProperties
		}

		[Header("  Common")]
		[Space(3f)]
		public RFParticleCollisionWithType collidesWith;

		[Space(2f)]
		public ParticleSystemCollisionQuality quality;

		[Space(2f)]
		[Range(0.1f, 2f)]
		public float radiusScale;

		[Header("  Dampen")]
		[Space(3f)]
		public RFParticleCollisionMatType dampenType;

		[Space(2f)]
		[Range(0f, 1f)]
		public float dampenMin;

		[Space(2f)]
		[Range(0f, 1f)]
		public float dampenMax;

		[Header("  Bounce")]
		[Space(3f)]
		public RFParticleCollisionMatType bounceType;

		[Space(2f)]
		[Range(0f, 1f)]
		public float bounceMin;

		[Space(2f)]
		[Range(0f, 1f)]
		public float bounceMax;

		[HideInInspector]
		public bool propertiesSet;

		public RFParticleCollisionDebris()
		{
			collidesWith = RFParticleCollisionWithType.Everything;
			quality = ParticleSystemCollisionQuality.High;
			radiusScale = 0.1f;
			dampenType = RFParticleCollisionMatType.ByProperties;
			dampenMin = 0.1f;
			dampenMax = 0.4f;
			bounceType = RFParticleCollisionMatType.ByProperties;
			bounceMin = 0.2f;
			bounceMax = 0.4f;
		}

		public void CopyFrom(RFParticleCollisionDebris source)
		{
			collidesWith = source.collidesWith;
			quality = source.quality;
			radiusScale = source.radiusScale;
			dampenType = source.dampenType;
			dampenMin = source.dampenMin;
			dampenMax = source.dampenMax;
			bounceType = source.bounceType;
			bounceMin = source.bounceMin;
			bounceMax = source.bounceMax;
			propertiesSet = source.propertiesSet;
		}

		public void SetMaterialProps(RayfireDebris debris)
		{
			if (propertiesSet)
			{
				return;
			}
			propertiesSet = true;
			if (debris.collision.collidesWith == RFParticleCollisionWithType.Nothing || (dampenType == RFParticleCollisionMatType.ByProperties && bounceType == RFParticleCollisionMatType.ByProperties))
			{
				return;
			}
			Collider collider = ((!(debris.rigid == null) && !(debris.rigid.physics.meshCollider == null)) ? debris.rigid.physics.meshCollider : debris.GetComponent<Collider>());
			if (!(collider == null) && !(collider.sharedMaterial == null))
			{
				if (dampenType == RFParticleCollisionMatType.ByPhysicalMaterial)
				{
					dampenMin = collider.sharedMaterial.dynamicFriction;
					dampenMax = dampenMin * 0.05f + dampenMin;
				}
				if (bounceType == RFParticleCollisionMatType.ByPhysicalMaterial)
				{
					bounceMin = collider.sharedMaterial.bounciness;
					bounceMax = bounceMin * 0.05f + bounceMin;
				}
			}
		}
	}
	[Serializable]
	public class RFParticleCollisionDust
	{
		[Header("  Common")]
		[Space(3f)]
		public RFParticles.RFParticleCollisionWithType collidesWith;

		[Space(2f)]
		public ParticleSystemCollisionQuality quality;

		[Space(2f)]
		[Range(0.1f, 2f)]
		public float radiusScale;

		public RFParticleCollisionDust()
		{
			collidesWith = RFParticles.RFParticleCollisionWithType.Everything;
			quality = ParticleSystemCollisionQuality.High;
			radiusScale = 1f;
		}

		public void CopyFrom(RFParticleCollisionDust source)
		{
			collidesWith = source.collidesWith;
			quality = source.quality;
			radiusScale = source.radiusScale;
		}
	}
	[Serializable]
	public class RFParticles
	{
		public enum RFParticleCollisionWithType
		{
			Everything,
			Nothing
		}

		public enum RFParticleCollisionMatType
		{
			ByPhysicalMaterial,
			ByProperties
		}

		public enum BurstType
		{
			None,
			TotalAmount,
			PerOneUnitSize,
			FragmentAmount
		}

		public static ParticleSystem.MinMaxCurve constantCurve = new ParticleSystem.MinMaxCurve(1f, 2f);

		private static string debrisStr = "_debris";

		private static string dustStr = "_dust";

		public static void SetParticleComponents(RayfireRigid scr)
		{
			if (scr.HasDebris)
			{
				scr.debrisList.Clear();
			}
			else
			{
				scr.debrisList = new List<RayfireDebris>();
			}
			RayfireDebris[] components = scr.GetComponents<RayfireDebris>();
			if (components.Length != 0)
			{
				for (int i = 0; i < components.Length; i++)
				{
					components[i].Initialize();
				}
				scr.debrisList = new List<RayfireDebris>();
				for (int j = 0; j < components.Length; j++)
				{
					if (components[j].initialized)
					{
						scr.debrisList.Add(components[j]);
						components[j].rigid = scr;
					}
				}
			}
			if (scr.HasDust)
			{
				scr.dustList.Clear();
			}
			else
			{
				scr.dustList = new List<RayfireDust>();
			}
			RayfireDust[] components2 = scr.GetComponents<RayfireDust>();
			if (components2.Length == 0)
			{
				return;
			}
			for (int k = 0; k < components2.Length; k++)
			{
				components2[k].Initialize();
			}
			scr.dustList = new List<RayfireDust>();
			for (int l = 0; l < components2.Length; l++)
			{
				if (components2[l].initialized)
				{
					scr.dustList.Add(components2[l]);
					components2[l].rigid = scr;
				}
			}
		}

		public static void InitDemolitionParticles(RayfireRigid source)
		{
			if (source.demolitionType == DemolitionType.ReferenceDemolition || source.HasFragments)
			{
				if (source.HasDebris)
				{
					CreateDemolitionDebris(source);
				}
				if (source.HasDust)
				{
					CreateDemolitionDust(source);
				}
				DetachParticles(source);
			}
		}

		public static void CreateDemolitionDebris(RayfireRigid source)
		{
			List<RayfireDebris> list = new List<RayfireDebris>();
			for (int i = 0; i < source.debrisList.Count; i++)
			{
				if (!source.debrisList[i].onDemolition)
				{
					continue;
				}
				if (source.demolitionType == DemolitionType.ReferenceDemolition && !source.HasFragments)
				{
					SetDebrisFinalAmount(new List<RayfireDebris> { source.debrisList[i] }, source.debrisList[i].emission.burstType, source.debrisList[i].emission.burstAmount);
					CreateDebrisRigid(source.debrisList[i]);
				}
				else
				{
					if (!source.debrisList[i].HasChildren)
					{
						continue;
					}
					GetDebrisTargets(list, source.debrisList[i].children, source.debrisList[i].limitations.sizeThreshold, source.debrisList[i].limitations.percentage, 0);
					if (list.Count != 0)
					{
						SetDebrisFinalAmount(list, source.debrisList[i].emission.burstType, source.debrisList[i].emission.burstAmount);
						int num = 0;
						for (int j = 0; j < list.Count; j++)
						{
							UnityEngine.Random.InitState(num++);
							CreateDebrisRigid(list[j]);
						}
						list.Clear();
					}
				}
			}
		}

		public static void CreateDemolitionDust(RayfireRigid source)
		{
			List<RayfireDust> list = new List<RayfireDust>();
			for (int i = 0; i < source.dustList.Count; i++)
			{
				if (!source.dustList[i].onDemolition)
				{
					continue;
				}
				if (source.demolitionType == DemolitionType.ReferenceDemolition && !source.HasFragments)
				{
					SetDustFinalAmount(new List<RayfireDust> { source.dustList[i] }, source.dustList[i].emission.burstType, source.dustList[i].emission.burstAmount);
					CreateDustRigid(source.dustList[i]);
				}
				else
				{
					if (!source.dustList[i].HasChildren)
					{
						continue;
					}
					GetDustTargets(list, source.dustList[i].children, source.dustList[i].limitations.sizeThreshold, source.dustList[i].limitations.percentage, 1);
					if (list.Count != 0)
					{
						SetDustFinalAmount(list, source.dustList[i].emission.burstType, source.dustList[i].emission.burstAmount);
						int num = 0;
						for (int j = 0; j < list.Count; j++)
						{
							UnityEngine.Random.InitState(num++);
							CreateDustRigid(list[j]);
						}
						list.Clear();
					}
				}
			}
		}

		public static void CreateDebrisRigid(RayfireDebris target)
		{
			if (target.amountFinal >= target.limitations.minParticles || target.emission.distanceRate != 0f)
			{
				CreateParticleSystemDebris(target);
				int emissionMatIndex = GetEmissionMatIndex(target.rigid.meshRenderer, target.emissionMaterial);
				target.CreateDebris(target.rigid.transForm, target, target.rigid.meshFilter, emissionMatIndex, target.pSystem);
			}
		}

		public static void CreateDustRigid(RayfireDust target)
		{
			if (target.amountFinal >= target.limitations.minParticles || target.emission.distanceRate != 0f)
			{
				CreateParticleSystemDust(target);
				int emissionMatIndex = GetEmissionMatIndex(target.rigid.meshRenderer, target.emissionMaterial);
				target.CreateDust(target.rigid.transForm, target, target.rigid.meshFilter, emissionMatIndex, target.pSystem);
			}
		}

		public static void InitActivationParticles(RayfireRigid source)
		{
			if (source.HasDebris)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					if (source.debrisList[i].onActivation)
					{
						CreateDebrisRigid(source.debrisList[i]);
					}
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			for (int j = 0; j < source.dustList.Count; j++)
			{
				if (source.dustList[j].onActivation)
				{
					CreateDustRigid(source.dustList[j]);
				}
			}
		}

		public static void CreateDebrisImpact(RayfireDebris debris, Vector3 impactPos, Vector3 impactNormal)
		{
			ParticleSystem ps = CreateParticleSystemDebris(debris);
			debris.hostTm.position = impactPos;
			debris.hostTm.LookAt(impactPos + impactNormal);
			debris.hostTm.parent = RayfireMan.inst.transForm;
			debris.hostTm.localScale = Vector3.one;
			debris.amountFinal = debris.emission.burstAmount;
			debris.CreateDebris(debris.rigid.transForm, debris, null, -1, ps);
		}

		public static void CreateDustImpact(RayfireDust dust, Vector3 impactPos, Vector3 impactNormal)
		{
			ParticleSystem ps = CreateParticleSystemDust(dust);
			dust.hostTm.position = impactPos;
			dust.hostTm.LookAt(impactPos + impactNormal);
			dust.hostTm.parent = RayfireMan.inst.transForm;
			dust.hostTm.localScale = Vector3.one;
			dust.amountFinal = dust.emission.burstAmount;
			dust.CreateDust(dust.rigid.transForm, dust, null, -1, ps);
		}

		private static ParticleSystem CreateParticleSystem(Transform tm)
		{
			ParticleSystem obj = ((RayfireMan.inst == null) ? RFPoolingParticles.CreateParticleInstance() : RayfireMan.inst.particles.GetPoolObject(RayfireMan.inst.transForm));
			obj.transform.position = tm.position;
			obj.transform.rotation = tm.rotation;
			obj.transform.SetParent(tm);
			obj.transform.localScale = Vector3.one;
			obj.gameObject.SetActive(value: true);
			obj.Stop();
			return obj;
		}

		public static ParticleSystem CreateParticleSystemDebris(RayfireDebris debris)
		{
			debris.pSystem = CreateParticleSystem(debris.transform);
			debris.pSystem.name = debris.name + debrisStr;
			debris.hostTm = debris.pSystem.transform;
			UnityEngine.Object.Destroy(debris.pSystem.gameObject, debris.emission.lifeMax + debris.pSystem.main.duration);
			return debris.pSystem;
		}

		public static ParticleSystem CreateParticleSystemDust(RayfireDust dust)
		{
			dust.pSystem = CreateParticleSystem(dust.transform);
			dust.pSystem.name = dust.name + dustStr;
			dust.hostTm = dust.pSystem.transform;
			UnityEngine.Object.Destroy(dust.pSystem.gameObject, dust.emission.lifeMax + dust.pSystem.main.duration);
			return dust.pSystem;
		}

		private static void DetachParticles(RayfireRigid source)
		{
			if (source.HasDebris)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					if (source.debrisList[i].HasChildren)
					{
						foreach (RayfireDebris child in source.debrisList[i].children)
						{
							if (child.hostTm != null)
							{
								child.hostTm.parent = RayfireMan.inst.transForm;
								child.hostTm.localScale = Vector3.one;
							}
						}
					}
					if (source.debrisList[i].hostTm != null)
					{
						source.debrisList[i].hostTm.parent = RayfireMan.inst.transForm;
						source.debrisList[i].hostTm.localScale = Vector3.one;
					}
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			for (int j = 0; j < source.dustList.Count; j++)
			{
				if (source.dustList[j].HasChildren)
				{
					foreach (RayfireDust child2 in source.dustList[j].children)
					{
						if (child2.hostTm != null)
						{
							child2.hostTm.parent = RayfireMan.inst.transForm;
							child2.hostTm.localScale = Vector3.one;
						}
					}
				}
				if (source.dustList[j].hostTm != null)
				{
					source.dustList[j].hostTm.parent = RayfireMan.inst.transForm;
					source.dustList[j].hostTm.localScale = Vector3.one;
				}
			}
		}

		public static void CopyParticles(RayfireRigid source, RayfireRigid target)
		{
			if (source.HasDebris)
			{
				if (target.debrisList == null)
				{
					target.debrisList = new List<RayfireDebris>();
				}
				else
				{
					target.debrisList.Clear();
				}
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					RayfireDebris rayfireDebris = target.gameObject.AddComponent<RayfireDebris>();
					rayfireDebris.CopyFrom(source.debrisList[i]);
					rayfireDebris.rigid = target;
					if (!source.debrisList[i].HasChildren)
					{
						source.debrisList[i].children = new List<RayfireDebris>();
					}
					source.debrisList[i].children.Add(rayfireDebris);
					target.debrisList.Add(rayfireDebris);
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			if (target.dustList == null)
			{
				target.dustList = new List<RayfireDust>();
			}
			else
			{
				target.dustList.Clear();
			}
			for (int j = 0; j < source.dustList.Count; j++)
			{
				RayfireDust rayfireDust = target.gameObject.AddComponent<RayfireDust>();
				rayfireDust.CopyFrom(source.dustList[j]);
				rayfireDust.rigid = target;
				if (!source.dustList[j].HasChildren)
				{
					source.dustList[j].children = new List<RayfireDust>();
				}
				source.dustList[j].children.Add(rayfireDust);
				target.dustList.Add(rayfireDust);
			}
		}

		public static void CopyRootMeshParticles(RayfireRigid source, List<RayfireRigid> targets)
		{
			if (source.HasDebris)
			{
				for (int num = source.debrisList.Count - 1; num >= 0; num--)
				{
					if (source.debrisList[num] == null)
					{
						source.debrisList.RemoveAt(num);
					}
				}
			}
			if (source.HasDebris)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					int num2 = targets.Count;
					for (int j = 0; j < targets.Count; j++)
					{
						if (num2 <= 0)
						{
							break;
						}
						if (UnityEngine.Random.Range(0, 100) <= source.debrisList[i].limitations.percentage)
						{
							RayfireDebris rayfireDebris = targets[j].gameObject.AddComponent<RayfireDebris>();
							rayfireDebris.CopyFrom(source.debrisList[i]);
							rayfireDebris.rigid = targets[j];
							if (targets[j].debrisList == null)
							{
								targets[j].debrisList = new List<RayfireDebris>();
							}
							targets[j].debrisList.Add(rayfireDebris);
							if (source.debrisList[i].children == null)
							{
								source.debrisList[i].children = new List<RayfireDebris>();
							}
							source.debrisList[i].children.Add(rayfireDebris);
							num2--;
						}
					}
					SetDebrisFinalAmount(source.debrisList[i].children, source.debrisList[i].emission.burstType, source.debrisList[i].emission.burstAmount);
				}
			}
			if (source.HasDust)
			{
				for (int num3 = source.dustList.Count - 1; num3 >= 0; num3--)
				{
					if (source.dustList[num3] == null)
					{
						source.dustList.RemoveAt(num3);
					}
				}
			}
			if (!source.HasDust)
			{
				return;
			}
			for (int k = 0; k < source.dustList.Count; k++)
			{
				int num4 = targets.Count;
				if (source.dustList[k].limitations.percentage < 100)
				{
					num4 = targets.Count * source.dustList[k].limitations.percentage / 100;
				}
				for (int l = 0; l < targets.Count; l++)
				{
					if (num4 <= 0)
					{
						break;
					}
					if (UnityEngine.Random.Range(0, 100) <= source.dustList[k].limitations.percentage)
					{
						RayfireDust rayfireDust = targets[l].gameObject.AddComponent<RayfireDust>();
						rayfireDust.CopyFrom(source.dustList[k]);
						rayfireDust.rigid = targets[l];
						if (targets[l].dustList == null)
						{
							targets[l].dustList = new List<RayfireDust>();
						}
						targets[l].dustList.Add(rayfireDust);
						if (source.dustList[k].children == null)
						{
							source.dustList[k].children = new List<RayfireDust>();
						}
						source.dustList[k].children.Add(rayfireDust);
						num4--;
					}
				}
				SetDustFinalAmount(source.dustList[k].children, source.dustList[k].emission.burstType, source.dustList[k].emission.burstAmount);
			}
		}

		public static void SetMain(ParticleSystem.MainModule main, float lifeMin, float lifeMax, float sizeMin, float sizeMax, float gravityMin, float gravityMax, float speedMin, float speedMax, float divergence, int maxParticles, float duration)
		{
			main.duration = duration;
			main.loop = false;
			main.simulationSpace = ParticleSystemSimulationSpace.World;
			main.maxParticles = maxParticles;
			main.emitterVelocityMode = ParticleSystemEmitterVelocityMode.Transform;
			constantCurve.constantMin = lifeMin;
			constantCurve.constantMax = lifeMax;
			main.startLifetime = constantCurve;
			constantCurve.constantMin = speedMin;
			constantCurve.constantMax = speedMax;
			main.startSpeed = constantCurve;
			constantCurve.constantMin = sizeMin;
			constantCurve.constantMax = sizeMax;
			main.startSize = constantCurve;
			constantCurve.constantMin = 0f - divergence;
			constantCurve.constantMax = divergence;
			main.startRotation = constantCurve;
			constantCurve.constantMin = gravityMin;
			constantCurve.constantMax = gravityMax;
			main.gravityModifier = constantCurve;
		}

		public static void SetEmission(ParticleSystem.EmissionModule emissionModule, float distanceRate, int burstAmount)
		{
			emissionModule.enabled = true;
			emissionModule.rateOverTimeMultiplier = 0f;
			emissionModule.rateOverDistanceMultiplier = distanceRate;
			if (burstAmount > 0)
			{
				ParticleSystem.Burst burst = new ParticleSystem.Burst(0f, (short)burstAmount, (short)burstAmount, 1, 999f);
				ParticleSystem.Burst[] bursts = new ParticleSystem.Burst[1] { burst };
				emissionModule.SetBursts(bursts);
			}
		}

		public static void SetShapeMesh(ParticleSystem.ShapeModule shapeModule, Mesh mesh, int emitMatIndex, Vector3 shapeScale)
		{
			shapeModule.normalOffset = 0f;
			shapeModule.shapeType = ParticleSystemShapeType.Mesh;
			shapeModule.meshShapeType = ParticleSystemMeshShapeType.Triangle;
			shapeModule.mesh = mesh;
			shapeModule.scale = shapeScale;
			if (emitMatIndex > 0)
			{
				shapeModule.useMeshMaterialIndex = true;
				shapeModule.meshMaterialIndex = emitMatIndex;
			}
		}

		public static void SetShapeObject(ParticleSystem.ShapeModule shapeModule)
		{
			shapeModule.shapeType = ParticleSystemShapeType.Hemisphere;
			shapeModule.radius = 0.2f;
			shapeModule.radiusThickness = 0f;
		}

		public static int GetEmissionMatIndex(Renderer renderer, Material mat)
		{
			if (mat != null)
			{
				for (int i = 0; i < renderer.sharedMaterials.Length; i++)
				{
					if (renderer.sharedMaterials[i] == mat)
					{
						return i;
					}
				}
			}
			return -1;
		}

		public static void SetVelocity(ParticleSystem.InheritVelocityModule velocity, RFParticleDynamicDebris dynamic)
		{
			if (dynamic.velocityMin > 0f || dynamic.velocityMax > 0f)
			{
				velocity.enabled = true;
				velocity.mode = ParticleSystemInheritVelocityMode.Initial;
				constantCurve.constantMin = dynamic.velocityMin;
				constantCurve.constantMax = dynamic.velocityMax;
				velocity.curve = constantCurve;
			}
		}

		public static void SetRotationOverLifeTime(ParticleSystem.RotationOverLifetimeModule rotation, RFParticleDynamicDust dynamic)
		{
			if (dynamic.rotation > 0f)
			{
				rotation.enabled = true;
				rotation.separateAxes = true;
				rotation.z = GetCurveRotationByLife(dynamic.rotation);
			}
		}

		public static ParticleSystem.MinMaxCurve GetCurveRotationByLife(float spin)
		{
			float num = spin * 4f;
			Keyframe[] obj = new Keyframe[2]
			{
				new Keyframe(0f, num),
				new Keyframe(1f, num * 0.1f)
			};
			AnimationCurve max = new AnimationCurve(obj);
			obj[0] = new Keyframe(0f, 0f - num);
			obj[1] = new Keyframe(1f, (0f - num) * 0.1f);
			AnimationCurve min = new AnimationCurve(obj);
			return new ParticleSystem.MinMaxCurve(1f, min, max);
		}

		public static void SetSizeOverLifeTime(ParticleSystem.SizeOverLifetimeModule sizeOverLifeTime, float size)
		{
			sizeOverLifeTime.enabled = true;
			sizeOverLifeTime.size = GetCurveSizeOverLifeTime(size);
		}

		public static void SetSizeOverLifeTime(ParticleSystem.SizeOverLifetimeModule sizeOverLifeTime, Vector3 size)
		{
			sizeOverLifeTime.enabled = true;
			sizeOverLifeTime.separateAxes = true;
			sizeOverLifeTime.x = GetCurveSizeOverLifeTime(size.x);
			sizeOverLifeTime.y = GetCurveSizeOverLifeTime(size.y);
			sizeOverLifeTime.z = GetCurveSizeOverLifeTime(size.z);
		}

		public static ParticleSystem.MinMaxCurve GetCurveSizeOverLifeTime(float val)
		{
			AnimationCurve curve = new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.01f, val), new Keyframe(0.95f, val), new Keyframe(1f, 0f));
			return new ParticleSystem.MinMaxCurve(1f, curve);
		}

		public static void SetRotationBySpeed(ParticleSystem.RotationBySpeedModule rotationBySpeed, float rotationSpeed)
		{
			if (rotationSpeed > 0f)
			{
				rotationBySpeed.enabled = true;
				rotationBySpeed.range = new Vector2(1f, 0f);
				rotationBySpeed.z = GetCurveRotationBySpeed(rotationSpeed);
			}
		}

		public static ParticleSystem.MinMaxCurve GetCurveRotationBySpeed(float rotationSpeed)
		{
			float num = rotationSpeed * 40f;
			Keyframe[] obj = new Keyframe[2]
			{
				new Keyframe(0f, num),
				new Keyframe(0.5f, 0f)
			};
			AnimationCurve max = new AnimationCurve(obj);
			obj[0] = new Keyframe(0f, 0f - num);
			AnimationCurve min = new AnimationCurve(obj);
			return new ParticleSystem.MinMaxCurve(1f, min, max);
		}

		public static void SetColorOverLife(ParticleSystem.ColorOverLifetimeModule colorLife, float opacity)
		{
			colorLife.enabled = true;
			GradientAlphaKey[] alphaKeys = new GradientAlphaKey[4]
			{
				new GradientAlphaKey(0f, 0f),
				new GradientAlphaKey(opacity, 0.1f),
				new GradientAlphaKey(opacity, 0.2f),
				new GradientAlphaKey(0f, 1f)
			};
			Gradient gradient = new Gradient();
			gradient.alphaKeys = alphaKeys;
			colorLife.color = new ParticleSystem.MinMaxGradient(gradient);
		}

		public static void SetNoise(ParticleSystem.NoiseModule psNoise, RFParticleNoise scrNoise)
		{
			psNoise.enabled = scrNoise.enabled;
			if (scrNoise.enabled)
			{
				psNoise.strength = new ParticleSystem.MinMaxCurve(scrNoise.strengthMin, scrNoise.strengthMax);
				psNoise.frequency = scrNoise.frequency;
				psNoise.scrollSpeed = scrNoise.scrollSpeed;
				psNoise.damping = scrNoise.damping;
				psNoise.quality = scrNoise.quality;
				psNoise.separateAxes = true;
				constantCurve.constantMin = scrNoise.strengthMin;
				constantCurve.constantMax = scrNoise.strengthMax;
				psNoise.strengthX = constantCurve;
				constantCurve.constantMin = scrNoise.strengthMin * 0.3f;
				constantCurve.constantMax = scrNoise.strengthMax * 0.3f;
				psNoise.strengthY = constantCurve;
				constantCurve.constantMin = scrNoise.strengthMin;
				constantCurve.constantMax = scrNoise.strengthMax;
				psNoise.strengthZ = constantCurve;
			}
		}

		public static void SetCollisionDebris(ParticleSystem.CollisionModule psCollision, RFParticleCollisionDebris coll)
		{
			psCollision.enabled = true;
			psCollision.type = ParticleSystemCollisionType.World;
			psCollision.collidesWith = (int)(coll.collidesWith - 1);
			psCollision.quality = coll.quality;
			psCollision.radiusScale = coll.radiusScale;
			constantCurve.constantMin = coll.dampenMin;
			constantCurve.constantMax = coll.dampenMax;
			psCollision.dampen = constantCurve;
			constantCurve.constantMin = coll.bounceMin;
			constantCurve.constantMax = coll.bounceMax;
			psCollision.bounce = constantCurve;
		}

		public static void SetCollisionDust(ParticleSystem.CollisionModule psCollision, RFParticleCollisionDust coll)
		{
			psCollision.enabled = true;
			psCollision.type = ParticleSystemCollisionType.World;
			psCollision.collidesWith = (int)(coll.collidesWith - 1);
			psCollision.quality = coll.quality;
			psCollision.radiusScale = coll.radiusScale;
			psCollision.dampenMultiplier = 0f;
			psCollision.bounceMultiplier = 0f;
			psCollision.enableDynamicColliders = false;
		}

		public static void GetDebrisTargets(List<RayfireDebris> filtered, List<RayfireDebris> targets, float sizeThreshold, int percentage, int pType)
		{
			int num = 0;
			for (int i = 0; i < targets.Count; i++)
			{
				if (!targets[i].oldChild)
				{
					num++;
				}
			}
			if (percentage < 100)
			{
				num = num * percentage / 100;
			}
			for (int j = 0; j < targets.Count; j++)
			{
				if (filtered.Count >= num)
				{
					break;
				}
				if (targets[j].rigid.objectType == ObjectType.Mesh && !targets[j].oldChild && !(targets[j].rigid.limitations.bboxSize < sizeThreshold) && UnityEngine.Random.Range(0, 100) <= percentage)
				{
					filtered.Add(targets[j]);
				}
			}
			for (int k = 0; k < targets.Count; k++)
			{
				targets[k].oldChild = true;
			}
		}

		public static void GetDustTargets(List<RayfireDust> filtered, List<RayfireDust> targets, float sizeThreshold, int percentage, int pType)
		{
			int num = 0;
			for (int i = 0; i < targets.Count; i++)
			{
				if (!targets[i].oldChild)
				{
					num++;
				}
			}
			if (percentage < 100)
			{
				num = num * percentage / 100;
			}
			for (int j = 0; j < targets.Count; j++)
			{
				if (filtered.Count >= num)
				{
					break;
				}
				if (targets[j].rigid.objectType == ObjectType.Mesh && !targets[j].oldChild && !(targets[j].rigid.limitations.bboxSize < sizeThreshold) && UnityEngine.Random.Range(0, 100) <= percentage)
				{
					filtered.Add(targets[j]);
				}
			}
			for (int k = 0; k < targets.Count; k++)
			{
				targets[k].oldChild = true;
			}
		}

		public static void SetDebrisFinalAmount(List<RayfireDebris> targets, BurstType burstType, int burstAmount)
		{
			if (burstType == BurstType.None)
			{
				for (int i = 0; i < targets.Count; i++)
				{
					targets[i].amountFinal = 0;
				}
			}
			switch (burstType)
			{
			case BurstType.FragmentAmount:
			{
				for (int l = 0; l < targets.Count; l++)
				{
					targets[l].amountFinal = burstAmount;
				}
				break;
			}
			case BurstType.PerOneUnitSize:
			{
				for (int m = 0; m < targets.Count; m++)
				{
					targets[m].amountFinal = (int)((float)burstAmount * targets[m].rigid.limitations.bboxSize);
				}
				break;
			}
			case BurstType.TotalAmount:
			{
				float num = 0f;
				for (int j = 0; j < targets.Count; j++)
				{
					num += targets[j].rigid.limitations.bboxSize;
				}
				float num2 = num / (float)burstAmount;
				for (int k = 0; k < targets.Count; k++)
				{
					targets[k].amountFinal = (int)(targets[k].rigid.limitations.bboxSize / num2);
				}
				break;
			}
			}
		}

		public static void SetDustFinalAmount(List<RayfireDust> targets, BurstType burstType, int burstAmount)
		{
			if (burstType == BurstType.None)
			{
				for (int i = 0; i < targets.Count; i++)
				{
					targets[i].amountFinal = 0;
				}
			}
			switch (burstType)
			{
			case BurstType.FragmentAmount:
			{
				for (int l = 0; l < targets.Count; l++)
				{
					targets[l].amountFinal = burstAmount;
				}
				break;
			}
			case BurstType.PerOneUnitSize:
			{
				for (int m = 0; m < targets.Count; m++)
				{
					targets[m].amountFinal = (int)((float)burstAmount * targets[m].rigid.limitations.bboxSize);
				}
				break;
			}
			case BurstType.TotalAmount:
			{
				float num = 0f;
				for (int j = 0; j < targets.Count; j++)
				{
					num += targets[j].rigid.limitations.bboxSize;
				}
				float num2 = num / (float)burstAmount;
				for (int k = 0; k < targets.Count; k++)
				{
					targets[k].amountFinal = (int)(targets[k].rigid.limitations.bboxSize / num2);
				}
				break;
			}
			}
		}

		public static bool AmountCheck(RayfireRigid source, int pType)
		{
			if (pType == 0)
			{
				for (int i = 0; i < source.debrisList.Count; i++)
				{
					if (source.debrisList[i].emission.burstType == BurstType.None && source.debrisList[i].emission.distanceRate == 0f)
					{
						UnityEngine.Debug.Log(source.name + " has debris enabled but has no amount");
						return false;
					}
				}
			}
			if (pType == 1)
			{
				for (int j = 0; j < source.dustList.Count; j++)
				{
					if (source.dustList[j].emission.burstType == BurstType.None && source.dustList[j].emission.distanceRate == 0f)
					{
						UnityEngine.Debug.Log(source.name + " has dust enabled but has no amount");
						return false;
					}
				}
			}
			return true;
		}
	}
	[Serializable]
	public class RFShard : IComparable<RFShard>
	{
		public int id;

		public Transform tm;

		public Vector3 pos;

		public Quaternion rot;

		public Bounds bnd;

		public float sz;

		public bool uny;

		public int nAm;

		public List<int> nIds;

		public List<float> nArea;

		public RayfireRigid rigid;

		public Collider col;

		public Rigidbody rb;

		[NonSerialized]
		public MeshFilter mf;

		[NonSerialized]
		public Vector3 initPos;

		[NonSerialized]
		public List<RFTriangle> tris;

		[NonSerialized]
		public RFCluster cluster;

		[NonSerialized]
		public List<RFShard> neibShards;

		public RFShard(RFShard source)
		{
			id = source.id;
			tm = source.tm;
			pos = source.pos;
			rot = source.rot;
			bnd = source.bnd;
			sz = source.sz;
			nAm = source.nAm;
			uny = source.uny;
			if (source.nIds != null)
			{
				nIds = new List<int>();
				for (int i = 0; i < source.nIds.Count; i++)
				{
					nIds.Add(source.nIds[i]);
				}
				nArea = new List<float>();
				for (int j = 0; j < source.nArea.Count; j++)
				{
					nArea.Add(source.nArea[j]);
				}
			}
			col = source.col;
			rigid = source.rigid;
		}

		public RFShard(Transform Tm, int Id)
		{
			tm = Tm;
			id = Id;
			initPos = tm.position;
			Renderer component = Tm.GetComponent<Renderer>();
			if (component != null)
			{
				bnd = component.bounds;
			}
			bnd.Expand(0.01f);
			sz = bnd.size.magnitude;
		}

		public int CompareTo(RFShard otherShard)
		{
			if (sz > otherShard.sz)
			{
				return -1;
			}
			if (sz < otherShard.sz)
			{
				return 1;
			}
			return 0;
		}

		public static void SetShards(RFCluster cluster, ConnectivityType connectivity, bool setRigid = false)
		{
			List<Transform> list = new List<Transform>();
			for (int i = 0; i < cluster.tm.childCount; i++)
			{
				list.Add(cluster.tm.GetChild(i));
			}
			SetShardsByTransforms(cluster, list, connectivity, setRigid);
		}

		public static void SetShardsByTransforms(RFCluster cluster, List<Transform> tmList, ConnectivityType connectivity, bool setRigid = false)
		{
			cluster.shards = new List<RFShard>();
			for (int i = 0; i < tmList.Count; i++)
			{
				MeshFilter component = tmList[i].GetComponent<MeshFilter>();
				if (!(component == null) && !(component.sharedMesh == null))
				{
					RFShard rFShard = new RFShard(tmList[i], i);
					rFShard.cluster = cluster;
					if (connectivity == ConnectivityType.ByMesh || connectivity == ConnectivityType.ByBoundingBoxAndMesh)
					{
						RFTriangle.SetTriangles(rFShard, component);
					}
					cluster.shards.Add(rFShard);
				}
			}
			if (setRigid)
			{
				for (int j = 0; j < cluster.shards.Count; j++)
				{
					cluster.shards[j].rigid = cluster.shards[j].tm.GetComponent<RayfireRigid>();
				}
			}
		}

		private bool TrisNeib(RFShard otherShard)
		{
			for (int i = 0; i < tris.Count; i++)
			{
				for (int j = 0; j < otherShard.tris.Count; j++)
				{
					if (Mathf.Abs(tris[i].area - otherShard.tris[j].area) < 0.001f && Vector3.Distance(tris[i].pos, otherShard.tris[j].pos) < 0.01f)
					{
						return true;
					}
				}
			}
			return false;
		}

		private float NeibArea(RFShard otherShard)
		{
			float num = 0f;
			for (int i = 0; i < tris.Count; i++)
			{
				for (int j = 0; j < otherShard.tris.Count; j++)
				{
					if (Mathf.Abs(tris[i].area - otherShard.tris[j].area) < 0.001f && Vector3.Distance(tris[i].pos, otherShard.tris[j].pos) < 0.01f)
					{
						num += tris[i].area;
						break;
					}
				}
			}
			return num;
		}

		public int GetNeibIndArea(List<RFShard> shardList = null)
		{
			float num = 0f;
			int result = 0;
			for (int i = 0; i < neibShards.Count; i++)
			{
				if ((shardList == null || shardList.Contains(neibShards[i])) && nArea[i] > num)
				{
					num = nArea[i];
					result = i;
				}
			}
			if (num > 0f)
			{
				return result;
			}
			return -1;
		}

		public static void SetShardNeibs(List<RFShard> shards, ConnectivityType type, float minArea = 0f, float minSize = 0f, int perc = 0, int seed = 0)
		{
			for (int i = 0; i < shards.Count; i++)
			{
				shards[i].neibShards = new List<RFShard>();
				shards[i].nArea = new List<float>();
				shards[i].nIds = new List<int>();
				shards[i].nAm = 0;
			}
			for (int j = 0; j < shards.Count; j++)
			{
				if (minSize > 0f && shards[j].sz < minSize)
				{
					continue;
				}
				for (int k = 0; k < shards.Count; k++)
				{
					if (k == j || (minSize > 0f && shards[k].sz < minSize))
					{
						continue;
					}
					if (perc > 0)
					{
						UnityEngine.Random.InitState(shards[j].id + shards[k].id + seed);
						if (UnityEngine.Random.Range(0, 100) < perc)
						{
							continue;
						}
					}
					if (!shards[k].nIds.Contains(shards[j].id) && shards[j].bnd.Intersects(shards[k].bnd))
					{
						float num = 0f;
						if (type != 0)
						{
							num = shards[j].NeibArea(shards[k]);
						}
						if (type != ConnectivityType.ByMesh)
						{
							num = (shards[j].sz + shards[k].sz) / 4f;
						}
						if ((!(minArea > 0f) || !(num < minArea)) && num > 0f)
						{
							shards[j].neibShards.Add(shards[k]);
							shards[j].nArea.Add(num);
							shards[j].nIds.Add(shards[k].id);
							shards[k].neibShards.Add(shards[j]);
							shards[k].nArea.Add(num);
							shards[k].nIds.Add(shards[j].id);
						}
					}
				}
				shards[j].nAm = shards[j].nIds.Count;
			}
			if (type == ConnectivityType.ByMesh)
			{
				for (int l = 0; l < shards.Count; l++)
				{
					RFTriangle.Clear(shards[l]);
				}
			}
		}

		public static RFShard GetNeibShardArea(List<RFShard> shardGroup, List<RFShard> shardList)
		{
			if (shardList.Count == 0)
			{
				return null;
			}
			List<RFShard> list = new List<RFShard>();
			float num = 0f;
			RFShard result = null;
			foreach (RFShard item in shardGroup)
			{
				for (int i = 0; i < item.neibShards.Count; i++)
				{
					if (!(num >= item.nArea[i]) && !list.Contains(item.neibShards[i]) && shardList.Contains(item.neibShards[i]))
					{
						list.Add(item.neibShards[i]);
						num = item.nArea[i];
						result = item.neibShards[i];
					}
				}
			}
			list = null;
			return result;
		}

		public static void ReinitNeibs(List<RFShard> shards)
		{
			if (shards.Count <= 0)
			{
				return;
			}
			for (int i = 0; i < shards.Count; i++)
			{
				for (int num = shards[i].neibShards.Count - 1; num >= 0; num--)
				{
					if (shards[i].neibShards[num].cluster != shards[i].cluster)
					{
						shards[i].nIds.RemoveAt(num);
						shards[i].nArea.RemoveAt(num);
						shards[i].neibShards.RemoveAt(num);
					}
				}
			}
		}

		public static Plane GetSlicePlane(Bounds bound)
		{
			Vector3 size = bound.size;
			Vector3 center = bound.center;
			Vector3 inNormal = ((size.x >= size.y && size.x >= size.z) ? Vector3.right : ((!(size.y >= size.x) || !(size.y >= size.z)) ? Vector3.forward : Vector3.up));
			return new Plane(inNormal, center);
		}

		public static List<RFShard> SortByDistanceToPoint(List<RFShard> shards, Vector3 point, int amount)
		{
			List<float> list = new List<float>();
			List<RFShard> list2 = new List<RFShard>();
			float item = Vector3.Distance(point, shards[0].tm.position);
			list.Add(item);
			list2.Add(shards[0]);
			for (int i = 1; i < shards.Count; i++)
			{
				item = Vector3.Distance(point, shards[i].tm.position);
				for (int j = 0; j < list.Count; j++)
				{
					if (item <= list[j])
					{
						list2.Insert(j, shards[i]);
						list.Insert(j, item);
						break;
					}
				}
			}
			if (amount > list2.Count)
			{
				amount = list2.Count;
			}
			list2.RemoveRange(amount, list2.Count - amount);
			return list2;
		}

		public static List<RFShard> SortByDistanceToPlane(List<RFShard> shards, Vector3 point, Vector3 normal, int amount)
		{
			List<float> list = new List<float>();
			List<RFShard> list2 = new List<RFShard>();
			Plane plane = new Plane(normal, point);
			float item = Math.Abs(plane.GetDistanceToPoint(shards[0].tm.position));
			list.Add(item);
			list2.Add(shards[0]);
			for (int i = 1; i < shards.Count; i++)
			{
				item = Math.Abs(plane.GetDistanceToPoint(shards[i].tm.position));
				for (int j = 0; j < list.Count; j++)
				{
					if (item <= list[j])
					{
						list2.Insert(j, shards[i]);
						list.Insert(j, item);
						break;
					}
				}
			}
			if (amount > list2.Count)
			{
				amount = list2.Count;
			}
			list2.RemoveRange(amount, list2.Count - amount);
			return list2;
		}

		public static List<RFShard> ContactShards(RFShard shard, int amount)
		{
			List<RFShard> list = new List<RFShard>();
			List<RFShard> list2 = new List<RFShard>();
			list2.Add(shard);
			list.Add(shard);
			while (list2.Count > 0 && list.Count < amount)
			{
				for (int i = 0; i < list2[0].neibShards.Count; i++)
				{
					if (list2[0].neibShards[i].cluster == null && !list.Contains(list2[0].neibShards[i]))
					{
						list2.Add(list2[0].neibShards[i]);
						list.Add(list2[0].neibShards[i]);
					}
				}
				list2.RemoveAt(0);
			}
			return list;
		}

		public static bool UnyieldingByShard(List<RFShard> shards)
		{
			for (int i = 0; i < shards.Count; i++)
			{
				if (shards[i].uny)
				{
					return true;
				}
			}
			return false;
		}

		public static bool UnyieldingByShardAll(List<RFShard> shards)
		{
			for (int i = 0; i < shards.Count; i++)
			{
				if (!shards[i].uny)
				{
					return false;
				}
			}
			return true;
		}
	}
	[Serializable]
	public class RFSound
	{
		[Space(2f)]
		public bool enable;

		[Space(1f)]
		[UnityEngine.Tooltip("Volume multiplier")]
		[Range(0.01f, 1f)]
		public float multiplier;

		[Space(2f)]
		public AudioClip clip;

		[Space(1f)]
		[UnityEngine.Tooltip("Random List")]
		public List<AudioClip> clips;

		public bool HasClips
		{
			get
			{
				if (clips != null)
				{
					return clips.Count > 0;
				}
				return false;
			}
		}

		public RFSound()
		{
			enable = true;
			multiplier = 1f;
		}

		public RFSound(RFSound source)
		{
			enable = source.enable;
			multiplier = source.multiplier;
			clip = source.clip;
			if (source.HasClips)
			{
				clips = new List<AudioClip>();
				for (int i = 0; i < source.clips.Count; i++)
				{
					clips.Add(source.clips[i]);
				}
			}
		}

		public static void CopyRootMeshSound(RayfireRigid source, List<RayfireRigid> targets)
		{
			if (!(source.sound == null))
			{
				for (int i = 0; i < targets.Count; i++)
				{
					targets[i].sound = targets[i].gameObject.AddComponent<RayfireSound>();
					targets[i].sound.CopyFrom(source.sound);
				}
			}
		}

		public static void InitializationSound(RayfireSound scr, float size)
		{
			if (scr == null || !scr.initialization.enable)
			{
				return;
			}
			if (scr.rigid == null)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + scr.name + " Initialization sound warning. Rigid component required", scr.gameObject);
				return;
			}
			if (size <= 0f)
			{
				size = scr.rigid.limitations.bboxSize;
			}
			if (FilterCheck(scr, size))
			{
				if (scr.initialization.HasClips)
				{
					scr.initialization.clip = scr.initialization.clips[UnityEngine.Random.Range(0, scr.activation.clips.Count - 1)];
				}
				if (!(scr.initialization.clip == null))
				{
					float volume = GeVolume(scr, size);
					AudioSource.PlayClipAtPoint(scr.initialization.clip, scr.gameObject.transform.position, volume);
				}
			}
		}

		public static void ActivationSound(RayfireSound scr, float size)
		{
			if (scr == null || !scr.activation.enable)
			{
				return;
			}
			if (scr.rigid == null)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + scr.name + " Activation sound warning. Rigid component required", scr.gameObject);
				return;
			}
			if (size <= 0f)
			{
				size = scr.rigid.limitations.bboxSize;
			}
			if (FilterCheck(scr, size))
			{
				if (scr.activation.HasClips)
				{
					scr.activation.clip = scr.activation.clips[UnityEngine.Random.Range(0, scr.activation.clips.Count - 1)];
				}
				if (!(scr.activation.clip == null))
				{
					float volume = GeVolume(scr, size);
					AudioSource.PlayClipAtPoint(scr.activation.clip, scr.gameObject.transform.position, volume);
				}
			}
		}

		public static void DemolitionSound(RayfireSound scr, float size)
		{
			if (scr == null || !scr.demolition.enable)
			{
				return;
			}
			if (scr.rigid == null)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + scr.name + " Demolition sound warning. Rigid component required", scr.gameObject);
				return;
			}
			if (size <= 0f)
			{
				size = scr.rigid.limitations.bboxSize;
			}
			if (FilterCheck(scr, size))
			{
				if (scr.demolition.HasClips)
				{
					scr.demolition.clip = scr.demolition.clips[UnityEngine.Random.Range(0, scr.demolition.clips.Count - 1)];
				}
				if (!(scr.demolition.clip == null))
				{
					float volume = GeVolume(scr, size);
					AudioSource.PlayClipAtPoint(scr.demolition.clip, scr.gameObject.transform.position, volume);
				}
			}
		}

		public static float GeVolume(RayfireSound scr, float size)
		{
			if (size <= 0f && scr.rigid != null)
			{
				size = scr.rigid.limitations.bboxSize;
			}
			float num = scr.baseVolume;
			if (scr.sizeVolume > 0f)
			{
				num += size * scr.sizeVolume;
			}
			return num * scr.activation.multiplier;
		}

		private static bool FilterCheck(RayfireSound scr, float size)
		{
			if (scr.minimumSize > 0f && size < scr.minimumSize)
			{
				return false;
			}
			if (scr.cameraDistance > 0f && Camera.main != null && Vector3.Distance(Camera.main.transform.position, scr.transform.position) > scr.cameraDistance)
			{
				return false;
			}
			return true;
		}
	}
	[Serializable]
	public class RFSoundActivation
	{
		[Space(2f)]
		public bool enable;

		[Space(1f)]
		[Range(0.01f, 2f)]
		public float multiplier;

		[Space(2f)]
		public AudioClip clip;

		[Space(1f)]
		public List<AudioClip> clips;
	}
	public enum AxisType
	{
		XRed,
		YGreen,
		ZBlue
	}
	public enum PlaneType
	{
		XY,
		XZ,
		YZ
	}
	public enum FragType
	{
		Voronoi = 0,
		Splinters = 1,
		Slabs = 2,
		Radial = 3,
		Custom = 5,
		Slices = 7,
		Tets = 11,
		Decompose = 15
	}
	public enum DemolitionType
	{
		None = 0,
		Runtime = 1,
		AwakePrecache = 2,
		AwakePrefragment = 3,
		ReferenceDemolition = 9
	}
	public enum CachingType
	{
		Disable,
		ByFrames,
		ByFragmentsPerFrame
	}
	public enum FadeType
	{
		None = 0,
		SimExclude = 1,
		MoveDown = 2,
		ScaleDown = 3,
		Destroy = 5
	}
	public enum MaterialType
	{
		HeavyMetal,
		LightMetal,
		DenseRock,
		PorousRock,
		Concrete,
		Brick,
		Glass,
		Rubber,
		Ice,
		Wood
	}
	public enum MassType
	{
		MaterialDensity,
		MassProperty
	}
	public enum ObjectType
	{
		Mesh = 0,
		MeshRoot = 1,
		SkinnedMesh = 2,
		NestedCluster = 4,
		ConnectedCluster = 5
	}
	public enum SimType
	{
		Dynamic,
		Sleeping,
		Inactive,
		Kinematic,
		Static
	}
	public enum ConnectivityType
	{
		ByBoundingBox,
		ByMesh,
		ByBoundingBoxAndMesh
	}
	public enum FragmentMode
	{
		Runtime,
		Editor
	}
	public enum RFColliderType
	{
		Mesh = 0,
		Box = 1,
		Sphere = 2,
		None = 4
	}
	public class RFFrag
	{
		public Mesh mesh;

		public Vector3 pivot;

		public RFDictionary subId;

		public RayfireRigid fragment;
	}
	public class RFTri
	{
		public int meshId;

		public int subMeshId = -1;

		public List<int> ids = new List<int>();

		public List<Vector3> vpos = new List<Vector3>();

		public List<Vector3> vnormal = new List<Vector3>();

		public List<Vector2> uvs = new List<Vector2>();

		public List<Vector4> tangents = new List<Vector4>();

		public List<RFTri> neibTris = new List<RFTri>();
	}
	[Serializable]
	public class RFDictionary
	{
		public List<int> keys;

		public List<int> values;

		public RFDictionary(Dictionary<int, int> dictionary)
		{
			keys = new List<int>();
			values = new List<int>();
			keys = dictionary.Keys.ToList();
			values = dictionary.Values.ToList();
		}
	}
	[Serializable]
	public class RFShatterCluster
	{
		[Header("  Main")]
		[Space(2f)]
		public bool enable;

		[UnityEngine.Tooltip("Amount of clusters defined by random point cloud.")]
		[Range(2f, 200f)]
		public int count;

		[UnityEngine.Tooltip("Random seed for clusters point cloud generator.")]
		[Range(0f, 100f)]
		public int seed;

		[UnityEngine.Tooltip("Smooth strength for cluster inner surface.")]
		[Range(0f, 1f)]
		public float relax;

		[Header("  Debris")]
		[Space(2f)]
		[UnityEngine.Tooltip("Amount of debris in last layer in percents relative to amount of fragments in cluster.")]
		[Range(0f, 100f)]
		public int amount;

		[UnityEngine.Tooltip("Amount of debris layers at cluster border.")]
		[Range(0f, 5f)]
		public int layers;

		[UnityEngine.Tooltip("Scale variation for inner debris.")]
		[Range(0.1f, 1f)]
		public float scale;

		[UnityEngine.Tooltip("Minimum amount of fragments in debris cluster.")]
		[Range(1f, 20f)]
		public int min;

		[UnityEngine.Tooltip("Maximum amount of fragments in debris cluster.")]
		[Range(1f, 20f)]
		public int max;

		public RFShatterCluster()
		{
			enable = false;
			count = 10;
			seed = 1;
			relax = 0.5f;
			layers = 0;
			amount = 0;
			scale = 1f;
			min = 1;
			max = 3;
		}

		public RFShatterCluster(RFShatterCluster src)
		{
			enable = src.enable;
			count = src.count;
			seed = src.seed;
			relax = src.relax;
			layers = src.layers;
			amount = src.amount;
			scale = src.scale;
			min = src.min;
			max = src.max;
		}
	}
	[Serializable]
	public class RFVoronoi
	{
		public int amount;

		[Range(0f, 1f)]
		public float centerBias;

		public int Amount
		{
			get
			{
				if (amount < 1)
				{
					return 1;
				}
				if (amount > 20000)
				{
					return 2;
				}
				return amount;
			}
		}

		public RFVoronoi()
		{
			amount = 30;
			centerBias = 0f;
		}

		public RFVoronoi(RFVoronoi src)
		{
			amount = src.amount;
			centerBias = src.centerBias;
		}
	}
	[Serializable]
	public class RFSplinters
	{
		public AxisType axis;

		public int amount;

		[Range(0f, 1f)]
		public float strength;

		[Range(0f, 1f)]
		public float centerBias;

		public int Amount
		{
			get
			{
				if (amount < 2)
				{
					return 2;
				}
				if (amount > 20000)
				{
					return 2;
				}
				return amount;
			}
		}

		public RFSplinters()
		{
			axis = AxisType.YGreen;
			amount = 30;
			strength = 0.7f;
			centerBias = 0f;
		}

		public RFSplinters(RFSplinters src)
		{
			axis = src.axis;
			amount = src.amount;
			strength = src.strength;
			centerBias = src.centerBias;
		}
	}
	[Serializable]
	public class RFRadial
	{
		[Header("  Common")]
		[Space(2f)]
		public AxisType centerAxis;

		[Range(0.01f, 30f)]
		public float radius;

		[Range(0f, 1f)]
		public float divergence;

		public bool restrictToPlane;

		[Header("  Rings")]
		[Space(2f)]
		[Range(3f, 60f)]
		public int rings;

		[Range(0f, 100f)]
		public int focus;

		[Range(0f, 100f)]
		public int focusStr;

		[Range(0f, 100f)]
		public int randomRings;

		[Header("  Rays")]
		[Space(2f)]
		[Range(3f, 60f)]
		public int rays;

		[Range(0f, 100f)]
		public int randomRays;

		[Range(-90f, 90f)]
		public int twist;

		public RFRadial()
		{
			centerAxis = AxisType.YGreen;
			radius = 1f;
			divergence = 1f;
			restrictToPlane = true;
			rings = 10;
			focus = 0;
			focusStr = 50;
			randomRings = 50;
			rays = 10;
			randomRays = 0;
			twist = 0;
		}

		public RFRadial(RFRadial src)
		{
			centerAxis = src.centerAxis;
			radius = src.radius;
			divergence = src.divergence;
			restrictToPlane = src.restrictToPlane;
			rings = src.rings;
			focus = src.focus;
			focusStr = src.focusStr;
			randomRings = src.randomRings;
			rays = src.rays;
			randomRays = src.randomRays;
			twist = src.twist;
		}
	}
	[Serializable]
	public class RFSlice
	{
		public PlaneType plane;

		public List<Transform> sliceList;

		public RFSlice()
		{
			plane = PlaneType.XZ;
		}

		public RFSlice(RFSlice src)
		{
			plane = src.plane;
			sliceList = src.sliceList;
		}

		public Vector3 Axis(Transform tm)
		{
			if (plane == PlaneType.YZ)
			{
				return tm.right;
			}
			if (plane == PlaneType.XZ)
			{
				return tm.up;
			}
			return tm.forward;
		}
	}
	[Serializable]
	public class RFTets
	{
		public enum TetType
		{
			Uniform,
			Curved
		}

		[HideInInspector]
		public TetType lattice;

		[Range(1f, 30f)]
		public int density;

		[Range(0f, 100f)]
		public int noise;

		public RFTets()
		{
			lattice = TetType.Uniform;
			density = 7;
			noise = 100;
		}

		public RFTets(RFTets src)
		{
			lattice = src.lattice;
			density = src.density;
			noise = src.noise;
		}
	}
	[Serializable]
	public class RFActivation
	{
		[Header("  Activation")]
		[Space(3f)]
		[UnityEngine.Tooltip("Inactive object will be activated when it's velocity will be higher than By Velocity value when pushed by other dynamic objects.")]
		public float byVelocity;

		[Space(1f)]
		[UnityEngine.Tooltip("Inactive object will be activated if will be pushed from it's original position farther than By Offset value.")]
		public float byOffset;

		[Space(1f)]
		[UnityEngine.Tooltip("Inactive object will be activated if will get total damage higher than this value.")]
		public float byDamage;

		[Space(1f)]
		[UnityEngine.Tooltip("Inactive object will be activated by overlapping with object with RayFire Activator component.")]
		public bool byActivator;

		[Space(1f)]
		[UnityEngine.Tooltip("Inactive object will be activated when it will be shot by RayFireGun component.")]
		public bool byImpact;

		[Space(1f)]
		[UnityEngine.Tooltip("Inactive object will be activated by Connectivity component if it will not be connected with Unyielding zone.")]
		public bool byConnectivity;

		[Header("  Connectivity")]
		[Space(3f)]
		public bool unyielding;

		[Space(1f)]
		public bool activatable;

		[NonSerialized]
		public bool activated;

		[NonSerialized]
		public RayfireConnectivity connect;

		public RFActivation()
		{
			byVelocity = 0f;
			byOffset = 0f;
			byDamage = 0f;
			byActivator = false;
			byImpact = false;
			byConnectivity = false;
			unyielding = false;
			activatable = false;
			activated = false;
			Reset();
		}

		public void CopyFrom(RFActivation act)
		{
			byActivator = act.byActivator;
			byImpact = act.byImpact;
			byVelocity = act.byVelocity;
			byOffset = act.byOffset;
			byDamage = act.byDamage;
			byConnectivity = act.byConnectivity;
			unyielding = act.unyielding;
			activatable = act.activatable;
		}

		public void Reset()
		{
			activated = false;
		}

		public void CheckConnectivity()
		{
			if (byConnectivity && connect != null)
			{
				connect.checkNeed = true;
				connect = null;
			}
		}

		public IEnumerator ActivationVelocityCor(RayfireRigid scr)
		{
			while (!scr.activation.activated && scr.activation.byVelocity > 0f)
			{
				if (scr.physics.rigidBody.velocity.magnitude > byVelocity)
				{
					scr.Activate();
				}
				yield return null;
			}
		}

		public IEnumerator ActivationOffsetCor(RayfireRigid scr)
		{
			while (!scr.activation.activated && scr.activation.byOffset > 0f)
			{
				if (Vector3.Distance(scr.transForm.position, scr.physics.initPosition) > scr.activation.byOffset)
				{
					scr.Activate();
				}
				yield return null;
			}
		}

		public IEnumerator InactiveCor(RayfireRigid scr)
		{
			while (scr.simulationType == SimType.Inactive)
			{
				scr.physics.rigidBody.velocity = Vector3.zero;
				scr.physics.rigidBody.angularVelocity = Vector3.zero;
				yield return null;
			}
		}

		public static void Activate(RayfireRigid scr)
		{
			if (scr.physics.exclude || (!scr.activation.activatable && scr.activation.unyielding))
			{
				return;
			}
			if (!scr.initialized)
			{
				scr.Initialize();
			}
			if (scr.simulationType == SimType.Kinematic)
			{
				MeshCollider meshCollider = scr.physics.meshCollider as MeshCollider;
				if (meshCollider != null)
				{
					meshCollider.convex = true;
				}
				if (scr.physics.rec)
				{
					scr.simulationType = SimType.Dynamic;
					scr.physics.rigidBody.isKinematic = false;
					scr.physics.rigidBody.useGravity = scr.physics.useGravity;
					GameObject gameObject = UnityEngine.Object.Instantiate(scr.gameObject);
					gameObject.transform.position = scr.transForm.position;
					gameObject.transform.rotation = scr.transForm.rotation;
					Rigidbody component = gameObject.GetComponent<Rigidbody>();
					if (component != null)
					{
						component.velocity = scr.physics.rigidBody.velocity;
						component.angularVelocity = scr.physics.rigidBody.angularVelocity;
					}
					scr.gameObject.SetActive(value: false);
				}
			}
			scr.activation.CheckConnectivity();
			scr.activation.activated = true;
			scr.simulationType = SimType.Dynamic;
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
			if (scr.fading.onActivation)
			{
				if (scr.fading.sizeFilter > 0f && scr.fading.sizeFilter > scr.limitations.bboxSize)
				{
					scr.Fade();
				}
				else
				{
					scr.Fade();
				}
			}
			RFParticles.InitActivationParticles(scr);
			RFSound.ActivationSound(scr.sound, scr.limitations.bboxSize);
			scr.activationEvent.InvokeLocalEvent(scr);
			RFActivationEvent.InvokeGlobalEvent(scr);
			if (scr.physics.rigidBody.angularVelocity == Vector3.zero)
			{
				float num = 1f;
				scr.physics.rigidBody.angularVelocity = new Vector3(UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num), UnityEngine.Random.Range(0f - num, num));
			}
		}

		public static void SetUnyielding(RayfireRigid scr)
		{
			if (scr.simulationType == SimType.Inactive || scr.simulationType == SimType.Kinematic)
			{
				RayfireUnyielding[] components = scr.GetComponents<RayfireUnyielding>();
				for (int i = 0; i < components.Length; i++)
				{
					components[i].SetUnyByOverlap(scr);
				}
			}
		}
	}
	public class RFBackupCluster
	{
		private RFCluster cluster;

		private bool saved;

		private RFBackupCluster()
		{
			saved = false;
		}

		public static void SaveBackup(RayfireRigid scr)
		{
			if (scr.reset.action == RFReset.PostDemolitionType.DeactivateToReset && scr.clusterDemolition.cluster.id <= 1)
			{
				if (scr.clusterDemolition.backup == null)
				{
					scr.clusterDemolition.backup = new RFBackupCluster();
				}
				if (!scr.clusterDemolition.backup.saved)
				{
					scr.clusterDemolition.backup.cluster = new RFCluster(scr.clusterDemolition.cluster);
					RFCluster.InitCluster(scr, scr.clusterDemolition.backup.cluster);
					SaveTmRecursive(scr.clusterDemolition.backup.cluster);
					scr.clusterDemolition.backup.saved = true;
				}
			}
		}

		public static void RestoreBackup(RayfireRigid scr)
		{
			if (scr.reset.action == RFReset.PostDemolitionType.DeactivateToReset && scr.clusterDemolition.cluster.id <= 1 && scr.clusterDemolition.backup != null && (scr.objectType != ObjectType.ConnectedCluster || scr.clusterDemolition.cluster.shards.Count != scr.clusterDemolition.backup.cluster.shards.Count))
			{
				scr.fragments = null;
				DestroyParticles(scr);
				ResetDeepShardRigid(scr, scr.clusterDemolition.backup.cluster);
				if (scr.objectType == ObjectType.NestedCluster)
				{
					ResetRootsRecursive(scr.clusterDemolition.backup.cluster);
					RestoreClusterTmRecursive(scr.clusterDemolition.backup.cluster);
					ResetRootsParentsRecursive(scr.clusterDemolition.backup.cluster);
				}
				RestoreShardTmRecursive(scr.clusterDemolition.backup.cluster);
				if (scr.objectType == ObjectType.ConnectedCluster)
				{
					DestroyRoots(scr);
				}
				scr.clusterDemolition.cluster = new RFCluster(scr.clusterDemolition.backup.cluster);
				RFPhysic.CollectClusterColliders(scr, scr.clusterDemolition.cluster);
				RFCluster.InitCluster(scr, scr.clusterDemolition.cluster);
				scr.clusterDemolition.collapse.inProgress = false;
			}
		}

		private static void DestroyParticles(RayfireRigid scr)
		{
			if (scr.HasDebris)
			{
				for (int i = 0; i < scr.debrisList.Count; i++)
				{
					for (int num = scr.debrisList[i].children.Count - 1; num >= 0; num--)
					{
						if (scr.debrisList[i].children[num] != null)
						{
							if (scr.debrisList[i].children[num].hostTm != null)
							{
								UnityEngine.Object.Destroy(scr.debrisList[i].children[num].hostTm.gameObject);
							}
							UnityEngine.Object.Destroy(scr.debrisList[i].children[num]);
						}
						scr.debrisList[i].children.RemoveAt(num);
					}
					scr.debrisList[i].children = null;
				}
			}
			if (!scr.HasDust)
			{
				return;
			}
			for (int j = 0; j < scr.dustList.Count; j++)
			{
				for (int num2 = scr.dustList[j].children.Count - 1; num2 >= 0; num2--)
				{
					if (scr.dustList[j].children[num2] != null)
					{
						if (scr.dustList[j].children[num2].hostTm != null)
						{
							UnityEngine.Object.Destroy(scr.dustList[j].children[num2].hostTm.gameObject);
						}
						UnityEngine.Object.Destroy(scr.dustList[j].children[num2]);
					}
					scr.dustList[j].children.RemoveAt(num2);
				}
				scr.dustList[j].children = null;
			}
		}

		private static void ResetDeepShardRigid(RayfireRigid scr, RFCluster cluster)
		{
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				ResetShardRigid(cluster.shards[i]);
			}
			if (scr.objectType == ObjectType.NestedCluster && cluster.HasChildClusters)
			{
				for (int j = 0; j < cluster.childClusters.Count; j++)
				{
					ResetDeepShardRigid(scr, cluster.childClusters[j]);
				}
			}
		}

		private static void ResetShardRigid(RFShard shard)
		{
			shard.rigid = shard.tm.GetComponent<RayfireRigid>();
			if (!(shard.rigid != null))
			{
				return;
			}
			if (shard.rigid.physics.rigidBody != null)
			{
				shard.rigid.physics.rigidBody.velocity = Vector3.zero;
				UnityEngine.Object.Destroy(shard.rigid.physics.rigidBody);
			}
			if (shard.rigid.HasDebris || shard.rigid.HasDust)
			{
				for (int num = shard.tm.childCount - 1; num >= 0; num--)
				{
					UnityEngine.Object.Destroy(shard.tm.GetChild(num).gameObject);
				}
			}
			UnityEngine.Object.Destroy(shard.rigid);
		}

		private static void SaveTmRecursive(RFCluster cluster)
		{
			cluster.pos = cluster.tm.position;
			cluster.rot = cluster.tm.rotation;
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				cluster.shards[i].pos = cluster.shards[i].tm.position;
				cluster.shards[i].rot = cluster.shards[i].tm.rotation;
			}
			if (cluster.HasChildClusters)
			{
				for (int j = 0; j < cluster.childClusters.Count; j++)
				{
					SaveTmRecursive(cluster.childClusters[j]);
				}
			}
		}

		private static void RestoreShardTmRecursive(RFCluster cluster)
		{
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				cluster.shards[i].tm.SetParent(null);
				cluster.shards[i].tm.SetPositionAndRotation(cluster.shards[i].pos, cluster.shards[i].rot);
				cluster.shards[i].tm.SetParent(cluster.tm, worldPositionStays: true);
			}
			if (cluster.HasChildClusters)
			{
				for (int j = 0; j < cluster.childClusters.Count; j++)
				{
					RestoreShardTmRecursive(cluster.childClusters[j]);
				}
			}
		}

		private static void RestoreClusterTmRecursive(RFCluster cluster)
		{
			cluster.tm.rotation = cluster.rot;
			cluster.tm.position = cluster.pos;
			if (cluster.HasChildClusters)
			{
				for (int i = 0; i < cluster.childClusters.Count; i++)
				{
					RestoreClusterTmRecursive(cluster.childClusters[i]);
				}
			}
		}

		private static void ResetRootsRecursive(RFCluster cluster)
		{
			if (!cluster.HasChildClusters)
			{
				return;
			}
			for (int i = 0; i < cluster.childClusters.Count; i++)
			{
				cluster.childClusters[i].tm.parent = null;
				cluster.childClusters[i].rigid = cluster.childClusters[i].tm.GetComponent<RayfireRigid>();
				if (cluster.childClusters[i].rigid != null)
				{
					if (cluster.childClusters[i].rigid.physics.rigidBody != null)
					{
						UnityEngine.Object.Destroy(cluster.childClusters[i].rigid.physics.rigidBody);
					}
					UnityEngine.Object.Destroy(cluster.childClusters[i].rigid);
				}
				cluster.childClusters[i].tm.gameObject.SetActive(value: true);
				ResetRootsRecursive(cluster.childClusters[i]);
			}
		}

		private static void ResetRootsParentsRecursive(RFCluster cluster)
		{
			if (cluster.HasChildClusters)
			{
				for (int i = 0; i < cluster.childClusters.Count; i++)
				{
					cluster.childClusters[i].tm.parent = cluster.tm;
					ResetRootsParentsRecursive(cluster.childClusters[i]);
				}
			}
		}

		private static void DestroyRoots(RayfireRigid scr)
		{
			for (int i = 0; i < scr.clusterDemolition.minorClusters.Count; i++)
			{
				if (scr.clusterDemolition.minorClusters[i].tm != null)
				{
					scr.clusterDemolition.minorClusters[i].tm.gameObject.SetActive(value: false);
					UnityEngine.Object.Destroy(scr.clusterDemolition.minorClusters[i].tm.gameObject);
				}
			}
		}
	}
	[Serializable]
	public class RFCollapse
	{
		public enum RFCollapseType
		{
			ByArea = 1,
			BySize = 3,
			Random = 5
		}

		public RFCollapseType type;

		[Space(2f)]
		[Range(0f, 99f)]
		public int start;

		[Space(2f)]
		[Range(1f, 100f)]
		public int end;

		[Space(2f)]
		[Range(1f, 100f)]
		public int steps;

		[Space(2f)]
		[Range(0f, 60f)]
		public float duration;

		[NonSerialized]
		public bool inProgress;

		public RFCollapse()
		{
			type = RFCollapseType.ByArea;
			start = 0;
			end = 75;
			steps = 10;
			duration = 15f;
		}

		public static void StartCollapse(RayfireRigid scr)
		{
			if (scr.initialized && !scr.clusterDemolition.collapse.inProgress && scr.clusterDemolition.cluster.shards.Count > 1)
			{
				scr.StartCoroutine(scr.clusterDemolition.collapse.CollapseCor(scr));
			}
		}

		private IEnumerator CollapseCor(RayfireRigid scr)
		{
			WaitForSeconds wait = new WaitForSeconds(duration / (float)steps);
			inProgress = true;
			float step = (float)(end - start) / (float)steps;
			for (int i = 0; i < steps; i++)
			{
				float num = (float)start + step * (float)i;
				if (type == RFCollapseType.ByArea)
				{
					AreaCollapse(scr, (int)num);
				}
				else if (type == RFCollapseType.BySize)
				{
					SizeCollapse(scr, (int)num);
				}
				else if (type == RFCollapseType.Random)
				{
					RandomCollapse(scr, (int)num, scr.clusterDemolition.seed);
				}
				yield return wait;
			}
			inProgress = false;
		}

		public static void StartCollapse(RayfireConnectivity scr)
		{
			if (!scr.collapse.inProgress && scr.cluster.shards.Count > 1)
			{
				scr.StartCoroutine(scr.collapse.CollapseCor(scr));
			}
		}

		private IEnumerator CollapseCor(RayfireConnectivity scr)
		{
			WaitForSeconds wait = new WaitForSeconds(duration / (float)steps);
			inProgress = true;
			float step = (float)(end - start) / (float)steps;
			for (int i = 0; i < steps; i++)
			{
				float num = (float)start + step * (float)i;
				if (type == RFCollapseType.ByArea)
				{
					AreaCollapse(scr, (int)num);
				}
				else if (type == RFCollapseType.BySize)
				{
					SizeCollapse(scr, (int)num);
				}
				else if (type == RFCollapseType.Random)
				{
					RandomCollapse(scr, (int)num, scr.seed);
				}
				yield return wait;
			}
			inProgress = false;
		}

		public static void AreaCollapse(RayfireRigid scr, int areaPercentage)
		{
			areaPercentage = Mathf.Clamp(areaPercentage, 0, 100);
			AreaCollapse(scr, Mathf.Lerp(scr.clusterDemolition.cluster.minimumArea, scr.clusterDemolition.cluster.maximumArea, (float)areaPercentage / 100f));
		}

		public static void SizeCollapse(RayfireRigid scr, int sizePercentage)
		{
			sizePercentage = Mathf.Clamp(sizePercentage, 0, 100);
			SizeCollapse(scr, Mathf.Lerp(scr.clusterDemolition.cluster.minimumSize, scr.clusterDemolition.cluster.maximumSize, (float)sizePercentage / 100f));
		}

		public static void AreaCollapse(RayfireRigid scr, float minAreaValue)
		{
			if (scr.initialized && !(minAreaValue < scr.clusterDemolition.cluster.areaCollapse))
			{
				scr.clusterDemolition.cluster.areaCollapse = minAreaValue;
				if (RemNeibByArea(scr.clusterDemolition.cluster, minAreaValue) > 0)
				{
					CollapseCluster(scr);
				}
			}
		}

		public static void SizeCollapse(RayfireRigid scr, float minSizeValue)
		{
			if (scr.initialized && !(minSizeValue < scr.clusterDemolition.cluster.sizeCollapse))
			{
				scr.clusterDemolition.cluster.sizeCollapse = minSizeValue;
				if (RemNeibBySize(scr.clusterDemolition.cluster, minSizeValue) > 0)
				{
					CollapseCluster(scr);
				}
			}
		}

		public static void RandomCollapse(RayfireRigid scr, int randomValue, int randomSeed)
		{
			if (scr.initialized && randomValue >= scr.clusterDemolition.cluster.randomCollapse)
			{
				scr.clusterDemolition.cluster.randomCollapse = randomValue;
				scr.clusterDemolition.cluster.randomSeed = randomSeed;
				if (RemNeibRandom(scr.clusterDemolition.cluster, randomValue, randomSeed) > 0)
				{
					CollapseCluster(scr);
				}
			}
		}

		private static void CollapseCluster(RayfireRigid scr)
		{
			List<RFShard> list = new List<RFShard>();
			RFCluster.GetSoloShards(scr.clusterDemolition.cluster, list);
			if (scr.HasFragments)
			{
				scr.fragments.Clear();
			}
			if (scr.simulationType == SimType.Dynamic || scr.simulationType == SimType.Sleeping)
			{
				RFCluster.ConnectivityCheck(scr.clusterDemolition.cluster);
				RFCluster.ReduceChildClusters(scr.clusterDemolition.cluster);
			}
			else if (scr.simulationType == SimType.Kinematic || scr.simulationType == SimType.Inactive)
			{
				RFCluster.ConnectivityUnyCheck(scr.clusterDemolition.cluster);
			}
			RFDemolitionCluster.PostDemolitionCluster(scr, list);
		}

		public static void AreaCollapse(RayfireConnectivity connectivity, int areaPercentage)
		{
			areaPercentage = Mathf.Clamp(areaPercentage, 0, 100);
			AreaCollapse(connectivity, Mathf.Lerp(connectivity.cluster.minimumArea, connectivity.cluster.maximumArea, (float)areaPercentage / 100f));
		}

		public static void SizeCollapse(RayfireConnectivity connectivity, int sizePercentage)
		{
			sizePercentage = Mathf.Clamp(sizePercentage, 0, 100);
			SizeCollapse(connectivity, Mathf.Lerp(connectivity.cluster.minimumSize, connectivity.cluster.maximumSize, (float)sizePercentage / 100f));
		}

		public static void AreaCollapse(RayfireConnectivity connectivity, float areaValue)
		{
			if (!(areaValue < connectivity.cluster.areaCollapse))
			{
				connectivity.cluster.areaCollapse = areaValue;
				if (RemNeibByArea(connectivity.cluster, areaValue) > 0)
				{
					connectivity.CheckConnectivity();
				}
			}
		}

		public static void SizeCollapse(RayfireConnectivity connectivity, float sizeValue)
		{
			if (!(sizeValue < connectivity.cluster.sizeCollapse))
			{
				connectivity.cluster.sizeCollapse = sizeValue;
				if (RemNeibBySize(connectivity.cluster, sizeValue) > 0)
				{
					connectivity.CheckConnectivity();
				}
			}
		}

		public static void RandomCollapse(RayfireConnectivity connectivity, int randomPercentage, int seedValue)
		{
			randomPercentage = Mathf.Clamp(randomPercentage, 0, 100);
			if (randomPercentage >= connectivity.cluster.randomCollapse)
			{
				connectivity.cluster.randomCollapse = randomPercentage;
				connectivity.cluster.randomSeed = seedValue;
				if (RemNeibRandom(connectivity.cluster, randomPercentage, seedValue) > 0)
				{
					connectivity.CheckConnectivity();
				}
			}
		}

		private static int RemNeibByArea(RFCluster cluster, float minArea)
		{
			int num = 0;
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				if (cluster.shards[i].uny)
				{
					continue;
				}
				for (int num2 = cluster.shards[i].neibShards.Count - 1; num2 >= 0; num2--)
				{
					if (cluster.shards[i].nArea[num2] < minArea)
					{
						for (int num3 = cluster.shards[i].neibShards[num2].neibShards.Count - 1; num3 >= 0; num3--)
						{
							if (cluster.shards[i].neibShards[num2].neibShards[num3] == cluster.shards[i])
							{
								cluster.shards[i].neibShards[num2].nIds.RemoveAt(num3);
								cluster.shards[i].neibShards[num2].nArea.RemoveAt(num3);
								cluster.shards[i].neibShards[num2].neibShards.RemoveAt(num3);
								break;
							}
						}
						cluster.shards[i].nIds.RemoveAt(num2);
						cluster.shards[i].nArea.RemoveAt(num2);
						cluster.shards[i].neibShards.RemoveAt(num2);
						num++;
					}
				}
			}
			return num;
		}

		private static int RemNeibBySize(RFCluster cluster, float minSize)
		{
			int num = 0;
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				if (cluster.shards[i].uny || !(cluster.shards[i].sz < minSize))
				{
					continue;
				}
				for (int num2 = cluster.shards[i].neibShards.Count - 1; num2 >= 0; num2--)
				{
					for (int num3 = cluster.shards[i].neibShards[num2].neibShards.Count - 1; num3 >= 0; num3--)
					{
						if (cluster.shards[i].neibShards[num2].neibShards[num3] == cluster.shards[i])
						{
							cluster.shards[i].neibShards[num2].nIds.RemoveAt(num3);
							cluster.shards[i].neibShards[num2].nArea.RemoveAt(num3);
							cluster.shards[i].neibShards[num2].neibShards.RemoveAt(num3);
							break;
						}
					}
				}
				cluster.shards[i].nIds.Clear();
				cluster.shards[i].nArea.Clear();
				cluster.shards[i].neibShards.Clear();
				num++;
			}
			return num;
		}

		private static int RemNeibRandom(RFCluster cluster, int percent, int seed)
		{
			int num = 0;
			cluster.randomSeed = seed;
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				if (cluster.shards[i].uny)
				{
					continue;
				}
				for (int num2 = cluster.shards[i].neibShards.Count - 1; num2 >= 0; num2--)
				{
					UnityEngine.Random.InitState(cluster.shards[i].id + cluster.shards[i].neibShards[num2].id + seed);
					if (UnityEngine.Random.Range(0, 100) < percent)
					{
						for (int num3 = cluster.shards[i].neibShards[num2].neibShards.Count - 1; num3 >= 0; num3--)
						{
							if (cluster.shards[i].neibShards[num2].neibShards[num3] == cluster.shards[i])
							{
								cluster.shards[i].neibShards[num2].nIds.RemoveAt(num3);
								cluster.shards[i].neibShards[num2].nArea.RemoveAt(num3);
								cluster.shards[i].neibShards[num2].neibShards.RemoveAt(num3);
								break;
							}
						}
						cluster.shards[i].nIds.RemoveAt(num2);
						cluster.shards[i].nArea.RemoveAt(num2);
						cluster.shards[i].neibShards.RemoveAt(num2);
						num++;
					}
				}
			}
			return num;
		}

		public static void SetRangeData(RFCluster cluster, int perc = 0, int seed = 0)
		{
			if (cluster.shards.Count == 0)
			{
				return;
			}
			cluster.maximumSize = cluster.shards[0].sz;
			cluster.minimumSize = cluster.shards[0].sz;
			cluster.maximumArea = 0f;
			cluster.minimumArea = 10000f;
			cluster.randomCollapse = perc;
			cluster.randomSeed = seed;
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				if (cluster.shards[i].sz > cluster.maximumSize)
				{
					cluster.maximumSize = cluster.shards[i].sz;
				}
				if (cluster.shards[i].sz < cluster.minimumSize)
				{
					cluster.minimumSize = cluster.shards[i].sz;
				}
				for (int j = 0; j < cluster.shards[i].nArea.Count; j++)
				{
					if (cluster.shards[i].nArea[j] > cluster.maximumArea)
					{
						cluster.maximumArea = cluster.shards[i].nArea[j];
					}
					if (cluster.shards[i].nArea[j] < cluster.minimumArea)
					{
						cluster.minimumArea = cluster.shards[i].nArea[j];
					}
				}
			}
			if (cluster.minimumArea < 0.001f)
			{
				cluster.minimumArea = 0f;
			}
			cluster.areaCollapse = cluster.minimumArea;
			cluster.sizeCollapse = cluster.minimumSize;
		}
	}
	[Serializable]
	public class RFDamage
	{
		[Header("  Properties")]
		[Space(2f)]
		[UnityEngine.Tooltip("Allows to demolish object by it's own floating Damage value.")]
		public bool enable;

		[UnityEngine.Tooltip("Defines maximum allowed damage for object before it will be demolished.")]
		public float maxDamage;

		[UnityEngine.Tooltip("Shows current damage value. Can be increased by public method: \nApplyDamage(float damageValue, Vector3 damagePosition)")]
		public float currentDamage;

		[Header("  Collisions")]
		[Space(2f)]
		[UnityEngine.Tooltip("Allows to accumulate damage value by collisions during dynamic simulation.")]
		public bool collect;

		[UnityEngine.Tooltip("Defines maximum allowed damage for object before it will be demolished.")]
		[Range(0.01f, 5f)]
		public float multiplier;

		public RFDamage()
		{
			enable = false;
			maxDamage = 100f;
			collect = false;
			multiplier = 1f;
			Reset();
		}

		public void CopyFrom(RFDamage damage)
		{
			enable = damage.enable;
			maxDamage = damage.maxDamage;
			collect = damage.collect;
			multiplier = damage.multiplier;
			Reset();
		}

		public void Reset()
		{
			currentDamage = 0f;
		}

		private static bool Apply(RayfireRigid scr, float damageValue)
		{
			scr.damage.currentDamage = scr.damage.currentDamage + damageValue;
			if (scr.damage.enable && scr.damage.currentDamage >= scr.damage.maxDamage)
			{
				return true;
			}
			return false;
		}

		public static bool ApplyDamage(RayfireRigid scr, float damageValue, Vector3 damagePoint, float damageRadius = 0f)
		{
			if (!scr.initialized)
			{
				scr.Initialize();
			}
			if (scr.limitations.demolished || scr.limitations.demolitionShould)
			{
				return false;
			}
			if (Apply(scr, damageValue))
			{
				if (!scr.DemolitionState())
				{
					return false;
				}
				scr.limitations.contactVector3 = damagePoint;
				scr.clusterDemolition.damageRadius = damageRadius;
				scr.limitations.demolitionShould = true;
				scr.Demolish();
				if (scr.limitations.demolished)
				{
					return true;
				}
			}
			if (scr.activation.byDamage > 0f && scr.damage.currentDamage > scr.activation.byDamage)
			{
				scr.Activate();
			}
			return false;
		}
	}
	[Serializable]
	public class RFDemolitionCluster
	{
		public enum RFDetachType
		{
			RatioToSize = 0,
			WorldUnits = 3
		}

		[Header("  Properties")]
		[Space(3f)]
		[UnityEngine.Tooltip("Defines Connectivity algorithm for clusters.")]
		public ConnectivityType connectivity;

		[Header("  Connection Filters")]
		[Space(3f)]
		[Range(0f, 1f)]
		public float minimumArea;

		[Space(2f)]
		[Range(0f, 10f)]
		public float minimumSize;

		[Space(2f)]
		[Range(0f, 100f)]
		public int percentage;

		[Space(2f)]
		[Range(0f, 100f)]
		public int seed;

		[Header("  Demolition Distance")]
		[Space(3f)]
		public RFDetachType type;

		[Space(2f)]
		[UnityEngine.Tooltip("Defines distance from contact point in percentage relative to object's size which will be detached at contact.")]
		[Range(1f, 100f)]
		public int ratio;

		[Space(2f)]
		[Range(0f, 10f)]
		public float units;

		[Header("  Shards")]
		[Space(3f)]
		[Range(0f, 100f)]
		public int shardArea;

		[Space(2f)]
		public bool shardDemolition;

		[Header("  Clusters")]
		[Space(3f)]
		[Range(2f, 20f)]
		public int minAmount;

		[Space(2f)]
		[Range(2f, 20f)]
		public int maxAmount;

		[Space(2f)]
		public bool demolishable;

		[Header("  Collapse")]
		[Space(3f)]
		public RFCollapse collapse;

		[HideInInspector]
		public int clsCount;

		[HideInInspector]
		public RFCluster cluster;

		[HideInInspector]
		public List<RFCluster> minorClusters;

		[HideInInspector]
		public bool cn;

		[HideInInspector]
		public bool nd;

		[NonSerialized]
		public RFBackupCluster backup;

		[NonSerialized]
		public float damageRadius;

		[NonSerialized]
		[Range(0.8f, 1f)]
		public float scaleFactor;

		[NonSerialized]
		public int edgeShardArea;

		private static string nameApp = "_cls_";

		public bool HasChildClusters
		{
			get
			{
				if (cluster.childClusters != null)
				{
					return cluster.childClusters.Count > 0;
				}
				return false;
			}
		}

		public bool HasMinorClusters
		{
			get
			{
				if (minorClusters != null)
				{
					return minorClusters.Count > 0;
				}
				return false;
			}
		}

		public RFDemolitionCluster()
		{
			connectivity = ConnectivityType.ByBoundingBox;
			minimumArea = 0f;
			minimumSize = 0f;
			percentage = 0;
			seed = 0;
			ratio = 15;
			units = 1f;
			shardArea = 100;
			scaleFactor = 1f;
			shardDemolition = false;
			edgeShardArea = 0;
			minAmount = 3;
			maxAmount = 6;
			demolishable = true;
			cn = false;
			nd = false;
			clsCount = 1;
			Reset();
		}

		public void CopyFrom(RFDemolitionCluster demolition)
		{
			connectivity = demolition.connectivity;
			minimumArea = demolition.minimumArea;
			minimumSize = demolition.minimumSize;
			percentage = demolition.percentage;
			seed = demolition.seed;
			type = demolition.type;
			ratio = demolition.ratio;
			units = demolition.units;
			shardArea = demolition.shardArea;
			shardDemolition = demolition.shardDemolition;
			scaleFactor = demolition.scaleFactor;
			maxAmount = demolition.maxAmount;
			minAmount = demolition.minAmount;
			demolishable = demolition.demolishable;
			cn = demolition.cn;
			nd = demolition.nd;
			Reset();
		}

		public void Reset()
		{
			damageRadius = 0f;
		}

		public static bool SetupCluster(RayfireRigid scr)
		{
			if (scr.objectType != ObjectType.ConnectedCluster && scr.objectType != ObjectType.NestedCluster)
			{
				return false;
			}
			RFPhysic.DestroyColliders(scr);
			scr.clusterDemolition.cluster = new RFCluster();
			scr.clusterDemolition.clsCount = 1;
			scr.clusterDemolition.minorClusters = null;
			scr.SetComponentsBasic();
			RFParticles.SetParticleComponents(scr);
			return Clusterize(scr);
		}

		public static bool Clusterize(RayfireRigid scr)
		{
			if (scr.transForm.childCount == 0)
			{
				return false;
			}
			if (scr.objectType == ObjectType.NestedCluster)
			{
				ClusterizeNested(scr);
			}
			else if (scr.objectType == ObjectType.ConnectedCluster)
			{
				ClusterizeConnected(scr);
			}
			RFCluster.InitCluster(scr, scr.clusterDemolition.cluster);
			bool result = RFPhysic.SetClusterCollidersByShards(scr);
			RFActivation.SetUnyielding(scr);
			RFBackupCluster.SaveBackup(scr);
			return result;
		}

		private static void ClusterizeNested(RayfireRigid scr)
		{
			if (!scr.clusterDemolition.HasMinorClusters && scr.clusterDemolition.cluster.id == -1)
			{
				scr.clusterDemolition.cluster = new RFCluster();
				scr.clusterDemolition.cluster.id = RFCluster.GetUniqClusterId(scr.clusterDemolition.cluster);
				scr.clusterDemolition.cluster.tm = scr.transForm;
				scr.clusterDemolition.cluster.depth = 0;
				scr.clusterDemolition.cluster.pos = scr.transForm.position;
				scr.clusterDemolition.cluster.rot = scr.transForm.rotation;
				scr.clusterDemolition.cluster.demolishable = true;
				scr.clusterDemolition.cluster.rigid = scr;
				scr.clusterDemolition.cluster.initialized = true;
				scr.clusterDemolition.minorClusters = new List<RFCluster>();
				ClusterizeNestedRecursive(scr, scr.transForm, scr.clusterDemolition.cluster, scr.clusterDemolition.connectivity);
			}
		}

		private static void ClusterizeNestedRecursive(RayfireRigid scr, Transform transform, RFCluster cluster, ConnectivityType connectivity)
		{
			List<Transform> list = new List<Transform>();
			List<Transform> list2 = new List<Transform>();
			for (int i = 0; i < transform.childCount; i++)
			{
				Transform child = transform.GetChild(i);
				if (child.childCount == 0)
				{
					list.Add(child);
				}
				else
				{
					list2.Add(child);
				}
			}
			if (list.Count > 0)
			{
				RFShard.SetShardsByTransforms(cluster, list, connectivity, setRigid: true);
			}
			if (list2.Count <= 0)
			{
				return;
			}
			for (int num = list2.Count - 1; num >= 0; num--)
			{
				RFCluster rFCluster = new RFCluster();
				rFCluster.mainCluster = scr.clusterDemolition.cluster;
				rFCluster.id = RFCluster.GetUniqClusterId(rFCluster);
				rFCluster.tm = list2[num];
				rFCluster.depth = 0;
				rFCluster.pos = list2[num].position;
				rFCluster.rot = list2[num].rotation;
				rFCluster.initialized = true;
				rFCluster.demolishable = true;
				rFCluster.bound = RFCluster.GetChildrenBound(rFCluster.tm);
				rFCluster.rigid = rFCluster.tm.GetComponent<RayfireRigid>();
				scr.clusterDemolition.minorClusters.Add(rFCluster);
				ClusterizeNestedRecursive(scr, list2[num], rFCluster, connectivity);
				if (cluster.childClusters == null)
				{
					cluster.childClusters = new List<RFCluster>();
				}
				cluster.childClusters.Add(rFCluster);
			}
		}

		private static void ClusterizeConnected(RayfireRigid scr)
		{
			if (scr.clusterDemolition.cluster.shards.Count == 0)
			{
				scr.clusterDemolition.cluster = new RFCluster();
				scr.clusterDemolition.cluster.id = RFCluster.GetUniqClusterId(scr.clusterDemolition.cluster);
				scr.clusterDemolition.cluster.tm = scr.transForm;
				scr.clusterDemolition.cluster.depth = 0;
				scr.clusterDemolition.cluster.pos = scr.transForm.position;
				scr.clusterDemolition.cluster.demolishable = true;
				scr.clusterDemolition.cluster.rigid = scr;
				scr.clusterDemolition.cluster.initialized = true;
				RFShard.SetShards(scr.clusterDemolition.cluster, scr.clusterDemolition.connectivity, setRigid: true);
				RFShard.SetShardNeibs(scr.clusterDemolition.cluster.shards, scr.clusterDemolition.connectivity, scr.clusterDemolition.minimumArea, scr.clusterDemolition.minimumSize, scr.clusterDemolition.percentage, scr.clusterDemolition.seed);
				RFCollapse.SetRangeData(scr.clusterDemolition.cluster, scr.clusterDemolition.percentage, scr.clusterDemolition.seed);
			}
		}

		public static bool DemolishCluster(RayfireRigid scr)
		{
			if (scr.objectType != ObjectType.NestedCluster && scr.objectType != ObjectType.ConnectedCluster)
			{
				return false;
			}
			if (scr.demolitionType != DemolitionType.Runtime)
			{
				return true;
			}
			if (scr.objectType == ObjectType.NestedCluster)
			{
				DemolishClusterNested(scr);
			}
			else if (scr.objectType == ObjectType.ConnectedCluster)
			{
				DemolishConnectedCluster(scr);
			}
			scr.limitations.demolitionShould = false;
			if (scr.limitations.demolished)
			{
				RayfireMan.DestroyFragment(scr, null);
			}
			return true;
		}

		public static void PostDemolitionCluster(RayfireRigid scr, List<RFShard> detachShards)
		{
			if (scr.fragments == null)
			{
				scr.fragments = new List<RayfireRigid>();
			}
			else
			{
				scr.fragments.Clear();
			}
			CreateRigidShards(scr, detachShards);
			CreateChildClusters(scr, scr.clusterDemolition.cluster.childClusters);
			UpdateOriginalCluster(scr);
			RFPhysic.SetFragmentsVelocity(scr);
			if (scr.fading.onDemolition)
			{
				scr.fading.DemolitionFade(scr.fragments);
			}
			RFParticles.InitDemolitionParticles(scr);
			RFSound.DemolitionSound(scr.sound, scr.limitations.bboxSize);
			scr.demolitionEvent.InvokeLocalEvent(scr);
			RFDemolitionEvent.InvokeGlobalEvent(scr);
		}

		private static void DemolishClusterNested(RayfireRigid scr)
		{
			scr.limitations.demolished = true;
			List<RFShard> list = new List<RFShard>();
			for (int i = 0; i < scr.clusterDemolition.cluster.shards.Count; i++)
			{
				list.Add(scr.clusterDemolition.cluster.shards[i]);
			}
			if (scr.reset.action == RFReset.PostDemolitionType.DestroyWithDelay)
			{
				scr.clusterDemolition.cluster.shards.Clear();
			}
			PostDemolitionCluster(scr, list);
		}

		public static void DemolishConnectedCluster(RayfireRigid scr, Collider[] detachColliders = null)
		{
			if (detachColliders == null)
			{
				detachColliders = GetDetachColliders(scr);
			}
			if (detachColliders.Length == 0)
			{
				return;
			}
			_ = scr.clusterDemolition.cluster.shards.Count;
			List<RFShard> detachShards = GetDetachShards(scr, detachColliders);
			if (detachShards.Count != 0 && ((scr.simulationType != SimType.Kinematic && scr.simulationType != SimType.Inactive) || !RFShard.UnyieldingByShardAll(detachShards)))
			{
				int clusterAmount = UnityEngine.Random.Range(scr.clusterDemolition.maxAmount, scr.clusterDemolition.minAmount + 1);
				if (scr.HasFragments)
				{
					scr.fragments.Clear();
				}
				if (scr.simulationType == SimType.Dynamic || scr.simulationType == SimType.Sleeping)
				{
					RFCluster.ConnectivityCheck(scr.clusterDemolition.cluster);
					RFCluster.ReduceChildClusters(scr.clusterDemolition.cluster);
				}
				if (scr.simulationType == SimType.Kinematic || scr.simulationType == SimType.Inactive)
				{
					RFCluster.ConnectivityUnyCheck(scr.clusterDemolition.cluster);
				}
				ClusterizeDetachShards(scr, detachShards, clusterAmount, 0);
				PostDemolitionCluster(scr, detachShards);
			}
		}

		private static Collider[] GetDetachColliders(RayfireRigid scr)
		{
			if (scr.clusterDemolition.damageRadius > 0f)
			{
				Collider[] result = Physics.OverlapSphere(scr.limitations.contactVector3, scr.clusterDemolition.damageRadius, 1 << scr.gameObject.layer);
				scr.clusterDemolition.damageRadius = 0f;
				return result;
			}
			if (scr.clusterDemolition.type == RFDetachType.WorldUnits && scr.clusterDemolition.units > 0f)
			{
				return Physics.OverlapSphere(scr.limitations.contactVector3, scr.clusterDemolition.units, 1 << scr.gameObject.layer);
			}
			if (scr.clusterDemolition.ratio == 100)
			{
				return scr.physics.clusterColliders.ToArray();
			}
			float radius = scr.limitations.bboxSize / 100f * (float)scr.clusterDemolition.ratio;
			return Physics.OverlapSphere(scr.limitations.contactVector3, radius, 1 << scr.gameObject.layer);
		}

		private static List<RFShard> GetDetachShards(RayfireRigid scr, Collider[] detachColliders)
		{
			List<RFShard> list = new List<RFShard>();
			for (int num = scr.physics.clusterColliders.Count - 1; num >= 0; num--)
			{
				if (detachColliders.Contains(scr.physics.clusterColliders[num]))
				{
					list.Add(scr.clusterDemolition.cluster.shards[num]);
					scr.clusterDemolition.cluster.shards.RemoveAt(num);
					scr.physics.clusterColliders.RemoveAt(num);
				}
			}
			if (list.Count == 0)
			{
				return list;
			}
			if (scr.clusterDemolition.cluster.shards.Count == 1)
			{
				list.Add(scr.clusterDemolition.cluster.shards[0]);
				scr.clusterDemolition.cluster.shards.Clear();
				scr.physics.clusterColliders.Clear();
			}
			for (int i = 0; i < list.Count; i++)
			{
				list[i].cluster = null;
			}
			if (scr.clusterDemolition.cluster.shards.Count > 0)
			{
				RFShard.ReinitNeibs(scr.clusterDemolition.cluster.shards);
				RFCluster.GetSoloShards(scr.clusterDemolition.cluster, list);
			}
			return list;
		}

		public static void SliceConnectedCluster(RayfireRigid scr)
		{
			float num = 0f;
			if (scr.clusterDemolition.type == RFDetachType.WorldUnits && scr.clusterDemolition.units > 0f)
			{
				num = scr.clusterDemolition.units;
			}
			if (scr.clusterDemolition.type == RFDetachType.RatioToSize)
			{
				num = scr.limitations.bboxSize / 100f * (float)scr.clusterDemolition.ratio;
			}
			List<RFShard> list = new List<RFShard>();
			List<RFShard> list2 = new List<RFShard>();
			List<RFShard> list3 = new List<RFShard>();
			Plane plane = new Plane(scr.limitations.slicePlanes[1], scr.limitations.slicePlanes[0]);
			scr.limitations.slicePlanes.Clear();
			for (int i = 0; i < scr.clusterDemolition.cluster.shards.Count; i++)
			{
				Vector3 position = scr.clusterDemolition.cluster.shards[i].tm.position;
				if (num > 0f && Math.Abs(plane.GetDistanceToPoint(position)) < num)
				{
					list.Add(scr.clusterDemolition.cluster.shards[i]);
					scr.clusterDemolition.cluster.shards[i].cluster = null;
				}
				else if (plane.GetSide(position))
				{
					list2.Add(scr.clusterDemolition.cluster.shards[i]);
				}
				else
				{
					list3.Add(scr.clusterDemolition.cluster.shards[i]);
				}
			}
			if (list2.Count == 1)
			{
				list.Add(list2[0]);
				list2.Clear();
			}
			if (list3.Count == 1)
			{
				list.Add(list3[0]);
				list3.Clear();
			}
			if (list.Count == 0 && (list2.Count == scr.clusterDemolition.cluster.shards.Count || list3.Count == scr.clusterDemolition.cluster.shards.Count))
			{
				return;
			}
			if (scr.simulationType == SimType.Dynamic || scr.simulationType == SimType.Sleeping)
			{
				if (list2.Count >= 2 || list3.Count >= 2)
				{
					if (scr.clusterDemolition.cluster.childClusters == null)
					{
						scr.clusterDemolition.cluster.childClusters = new List<RFCluster>();
					}
					else
					{
						scr.clusterDemolition.cluster.childClusters.Clear();
					}
				}
				SetupPlaneShards(scr, list2, list);
				SetupPlaneShards(scr, list3, list);
				RFCluster.ReduceChildClusters(scr.clusterDemolition.cluster);
			}
			if (scr.simulationType == SimType.Kinematic || scr.simulationType == SimType.Inactive)
			{
				for (int num2 = scr.clusterDemolition.cluster.shards.Count - 1; num2 >= 0; num2--)
				{
					if (scr.clusterDemolition.cluster.shards[num2].cluster != scr.clusterDemolition.cluster)
					{
						scr.clusterDemolition.cluster.shards.RemoveAt(num2);
					}
				}
				RFShard.ReinitNeibs(scr.clusterDemolition.cluster.shards);
				RFCluster.ConnectivityUnyCheck(scr.clusterDemolition.cluster);
			}
			if (list.Count > 0)
			{
				RFShard.ReinitNeibs(list);
				scr.limitations.contactVector3 = plane.ClosestPointOnPlane(list[0].tm.position);
				scr.limitations.contactNormal = plane.normal;
				int clusterAmount = UnityEngine.Random.Range(scr.clusterDemolition.maxAmount, scr.clusterDemolition.minAmount + 1);
				ClusterizeDetachShards(scr, list, clusterAmount, 1);
			}
			PostDemolitionCluster(scr, list);
		}

		private static void SetupPlaneShards(RayfireRigid scr, List<RFShard> clusterShards, List<RFShard> detachShards)
		{
			if (clusterShards.Count < 2)
			{
				return;
			}
			RFCluster rFCluster = new RFCluster();
			rFCluster.id = 2;
			rFCluster.shards = clusterShards;
			rFCluster.demolishable = true;
			for (int i = 0; i < rFCluster.shards.Count; i++)
			{
				rFCluster.shards[i].cluster = rFCluster;
			}
			rFCluster.mainCluster = scr.clusterDemolition.cluster;
			RFShard.ReinitNeibs(rFCluster.shards);
			for (int num = rFCluster.shards.Count - 1; num >= 0; num--)
			{
				if (rFCluster.shards[num].neibShards.Count == 0)
				{
					detachShards.Add(rFCluster.shards[num]);
					rFCluster.shards[num].cluster = null;
					rFCluster.shards.RemoveAt(num);
				}
			}
			if (rFCluster.shards.Count == 0)
			{
				return;
			}
			RFCluster.ConnectivityCheck(rFCluster);
			RFCluster.ReduceChildClusters(rFCluster);
			scr.clusterDemolition.cluster.childClusters.Add(rFCluster);
			if (rFCluster.HasChildClusters)
			{
				for (int j = 0; j < rFCluster.childClusters.Count; j++)
				{
					scr.clusterDemolition.cluster.childClusters.Add(rFCluster.childClusters[j]);
				}
				rFCluster.childClusters.Clear();
			}
		}

		private static void ClusterizeDetachShards(RayfireRigid scr, List<RFShard> detachShards, int clusterAmount, int sortType)
		{
			if (scr.clusterDemolition.shardArea == 100 || detachShards.Count <= 1)
			{
				return;
			}
			_ = scr.clusterDemolition.shardArea;
			int num = detachShards.Count * scr.clusterDemolition.shardArea / 100;
			if (detachShards.Count - num <= 1 || detachShards.Count <= clusterAmount)
			{
				return;
			}
			if (scr.clusterDemolition.cluster.childClusters == null)
			{
				scr.clusterDemolition.cluster.childClusters = new List<RFCluster>();
			}
			int count = scr.clusterDemolition.cluster.childClusters.Count;
			List<RFShard> list = null;
			if (num > 0)
			{
				switch (sortType)
				{
				case 0:
					list = RFShard.SortByDistanceToPoint(detachShards, scr.limitations.contactVector3, num);
					break;
				case 1:
					list = RFShard.SortByDistanceToPlane(detachShards, scr.limitations.contactVector3, scr.limitations.contactNormal, num);
					break;
				}
				if (list != null)
				{
					for (int num2 = detachShards.Count - 1; num2 >= 0; num2--)
					{
						if (list.Contains(detachShards[num2]))
						{
							detachShards.RemoveAt(num2);
						}
					}
					for (int i = 0; i < list.Count; i++)
					{
						list[i].cluster = scr.clusterDemolition.cluster;
					}
				}
			}
			DivideAllShards(scr.clusterDemolition.cluster, detachShards, clusterAmount);
			DetachOneNeibShards(scr.clusterDemolition.cluster.childClusters, detachShards, num, count);
			if (list != null)
			{
				for (int j = 0; j < list.Count; j++)
				{
					list[j].cluster = null;
				}
				detachShards.AddRange(list);
			}
		}

		private static void CreateRigidShards(RayfireRigid scr, List<RFShard> detachShards)
		{
			if (detachShards.Count != 0)
			{
				Transform parent = scr.transform.parent;
				if (scr.clusterDemolition.cluster.mainCluster != null && scr.clusterDemolition.cluster.mainCluster.tm != null)
				{
					parent = scr.clusterDemolition.cluster.mainCluster.tm.parent;
				}
				AddRigidComponent(scr, detachShards, parent);
			}
		}

		private static void CreateChildClusters(RayfireRigid scr, List<RFCluster> childClusters)
		{
			if (childClusters != null && childClusters.Count != 0)
			{
				for (int i = 0; i < childClusters.Count; i++)
				{
					childClusters[i].demolishable = scr.clusterDemolition.demolishable;
					CreateClusterRuntime(scr, childClusters[i]);
				}
			}
		}

		private static void UpdateOriginalCluster(RayfireRigid scr)
		{
			if (scr.clusterDemolition.cluster.shards.Count == 0)
			{
				scr.physics.rigidBody.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
				scr.physics.rigidBody.isKinematic = true;
				scr.limitations.demolished = true;
				if (scr.objectType == ObjectType.ConnectedCluster && scr.clusterDemolition.cluster.mainCluster != null && scr.clusterDemolition.cluster.mainCluster.rigid != null)
				{
					scr.clusterDemolition.cluster.mainCluster.rigid.clusterDemolition.minorClusters.Remove(scr.clusterDemolition.cluster);
				}
				return;
			}
			RFPhysic.CollectClusterColliders(scr, scr.clusterDemolition.cluster);
			RFPhysic.SetDensity(scr);
			if ((scr.simulationType == SimType.Kinematic || scr.simulationType == SimType.Inactive) && scr.activation.byConnectivity && !scr.clusterDemolition.cluster.UnyieldingByShard)
			{
				scr.Activate();
			}
			scr.limitations.birthTime = Time.time;
			scr.clusterDemolition.cluster.bound = RFCluster.GetShardsBound(scr.clusterDemolition.cluster.shards);
			scr.limitations.bboxSize = scr.clusterDemolition.cluster.bound.size.magnitude;
			scr.physics.rigidBody.ResetCenterOfMass();
		}

		public static void CreateClusterRuntime(RayfireRigid scr, RFCluster cluster)
		{
			if (cluster.shards.Count == 1)
			{
				UnityEngine.Debug.Log("Solo cluster warning");
			}
			if (scr.objectType == ObjectType.ConnectedCluster && cluster.mainCluster != null && cluster.mainCluster.rigid != null)
			{
				if (cluster.mainCluster.rigid.clusterDemolition.minorClusters == null)
				{
					cluster.mainCluster.rigid.clusterDemolition.minorClusters = new List<RFCluster>();
				}
				cluster.mainCluster.rigid.clusterDemolition.minorClusters.Add(cluster);
			}
			if (cluster.bound.size.magnitude == 0f)
			{
				if (scr.objectType == ObjectType.ConnectedCluster)
				{
					cluster.bound = RFCluster.GetShardsBound(cluster.shards);
				}
				else if (scr.objectType == ObjectType.NestedCluster)
				{
					cluster.bound = RFCluster.GetClusterBound(cluster);
				}
			}
			if (cluster.tm == null)
			{
				GameObject gameObject = new GameObject(scr.gameObject.name + nameApp + cluster.id);
				cluster.tm = gameObject.transform;
				cluster.tm.position = cluster.shards[0].tm.position;
				cluster.tm.rotation = scr.transForm.rotation;
				gameObject.layer = scr.gameObject.layer;
				gameObject.tag = scr.gameObject.tag;
			}
			cluster.tm.parent = scr.transForm.parent;
			if (scr.objectType == ObjectType.ConnectedCluster)
			{
				for (int i = 0; i < cluster.shards.Count; i++)
				{
					cluster.shards[i].tm.parent = cluster.tm;
				}
			}
			if (cluster.rigid == null)
			{
				cluster.rigid = cluster.tm.gameObject.GetComponent<RayfireRigid>();
			}
			if (cluster.rigid == null)
			{
				cluster.rigid = cluster.tm.gameObject.AddComponent<RayfireRigid>();
			}
			if (scr.fragments == null)
			{
				scr.fragments = new List<RayfireRigid>();
			}
			scr.fragments.Add(cluster.rigid);
			scr.CopyPropertiesTo(cluster.rigid);
			RFParticles.CopyParticles(scr, cluster.rigid);
			cluster.rigid.physics.colliderType = RFColliderType.Mesh;
			if ((cluster.rigid.simulationType == SimType.Kinematic || cluster.rigid.simulationType == SimType.Inactive) && cluster.rigid.activation.byConnectivity && !cluster.UnyieldingByShard)
			{
				cluster.rigid.simulationType = SimType.Dynamic;
			}
			cluster.rigid.demolitionType = (cluster.demolishable ? DemolitionType.Runtime : DemolitionType.None);
			if (scr.reset.action == RFReset.PostDemolitionType.DeactivateToReset)
			{
				cluster.rigid.reset.action = RFReset.PostDemolitionType.DeactivateToReset;
			}
			cluster.initialized = true;
			cluster.rigid.clusterDemolition.cluster = cluster;
			if (cluster.rigid.objectType == ObjectType.ConnectedCluster)
			{
				RFCollapse.SetRangeData(cluster.rigid.clusterDemolition.cluster, cluster.rigid.clusterDemolition.percentage, cluster.rigid.clusterDemolition.seed);
			}
			RFPhysic.CollectClusterColliders(cluster.rigid, cluster.rigid.clusterDemolition.cluster);
			cluster.rigid.Initialize();
		}

		private static void DivideAllShards(RFCluster cluster, List<RFShard> detachShards, int amount)
		{
			int count = cluster.childClusters.Count;
			RFShard.ReinitNeibs(detachShards);
			RFCluster rFCluster = new RFCluster();
			rFCluster.mainCluster = ((cluster.mainCluster == null) ? cluster : cluster.mainCluster);
			rFCluster.id = RFCluster.GetUniqClusterId(rFCluster);
			for (int num = detachShards.Count - 1; num >= 0; num--)
			{
				if (detachShards[num].neibShards.Count > 0)
				{
					rFCluster.shards.Add(detachShards[num]);
					detachShards[num].cluster = rFCluster;
					detachShards.RemoveAt(num);
				}
			}
			cluster.childClusters.Add(rFCluster);
			RFShard.ReinitNeibs(rFCluster.shards);
			for (int i = 0; i < amount - 1; i++)
			{
				int index = 0;
				int num2 = 0;
				for (int j = count; j < cluster.childClusters.Count; j++)
				{
					if (cluster.childClusters[j].shards.Count > num2)
					{
						index = j;
						num2 = cluster.childClusters[j].shards.Count;
					}
				}
				if (cluster.childClusters[index].shards.Count < 4)
				{
					break;
				}
				DivideShards(cluster, cluster.childClusters[index]);
				if (num2 == cluster.childClusters[index].shards.Count)
				{
					break;
				}
			}
			for (int num3 = cluster.childClusters.Count - 1; num3 >= count; num3--)
			{
				for (int num4 = cluster.childClusters[num3].shards.Count - 1; num4 >= 0; num4--)
				{
					if (cluster.childClusters[num3].shards[num4].neibShards.Count == 0)
					{
						detachShards.Add(cluster.childClusters[num3].shards[num4]);
						cluster.childClusters[num3].shards[num4].cluster = null;
						cluster.childClusters[num3].shards.RemoveAt(num4);
					}
				}
				if (cluster.childClusters[num3].shards.Count == 0)
				{
					cluster.childClusters.RemoveAt(num3);
				}
			}
			for (int k = count; k < cluster.childClusters.Count; k++)
			{
				RFCluster.ConnectivityCheck(cluster.childClusters[k]);
				RFCluster.ReduceChildClusters(cluster.childClusters[k]);
			}
			for (int num5 = cluster.childClusters.Count - 1; num5 >= count; num5--)
			{
				if (cluster.childClusters[num5].HasChildClusters)
				{
					cluster.childClusters.AddRange(cluster.childClusters[num5].childClusters);
					cluster.childClusters[num5].childClusters = null;
				}
			}
		}

		private static void DivideShards(RFCluster cluster, RFCluster childCluster)
		{
			childCluster.bound = RFCluster.GetShardsBound(childCluster.shards);
			Plane slicePlane = RFShard.GetSlicePlane(childCluster.bound);
			List<int> list = new List<int>();
			for (int i = 0; i < childCluster.shards.Count; i++)
			{
				if (slicePlane.GetSide(childCluster.shards[i].tm.position))
				{
					list.Add(i);
				}
			}
			if (list.Count > 1 && list.Count <= childCluster.shards.Count - 2)
			{
				RFCluster rFCluster = new RFCluster();
				rFCluster.mainCluster = ((cluster.mainCluster == null) ? cluster : cluster.mainCluster);
				rFCluster.id = RFCluster.GetUniqClusterId(rFCluster);
				rFCluster.shards = new List<RFShard>();
				for (int num = list.Count - 1; num >= 0; num--)
				{
					rFCluster.shards.Add(childCluster.shards[list[num]]);
					childCluster.shards[list[num]].cluster = rFCluster;
					childCluster.shards.RemoveAt(list[num]);
				}
				cluster.childClusters.Add(rFCluster);
				RFShard.ReinitNeibs(rFCluster.shards);
				RFShard.ReinitNeibs(childCluster.shards);
			}
		}

		private static void DetachEdgeShards(RayfireRigid scr, RFCluster cluster, List<RFShard> detachShards, int edgeShardArea)
		{
			if (edgeShardArea == 0)
			{
				return;
			}
			for (int i = 0; i < cluster.childClusters.Count; i++)
			{
				if (cluster.childClusters[i].shards.Count < 5 || cluster.childClusters[i].shards.Count * edgeShardArea / 100 <= 0)
				{
					continue;
				}
				for (int num = cluster.childClusters[i].shards.Count - 1; num >= 0; num--)
				{
					if (cluster.childClusters[i].shards[num].neibShards.Count < cluster.childClusters[i].shards[num].nAm)
					{
						detachShards.Add(cluster.childClusters[i].shards[num]);
						cluster.childClusters[i].shards[num].cluster = null;
						cluster.childClusters[i].shards.RemoveAt(num);
					}
				}
				RFShard.ReinitNeibs(cluster.childClusters[i].shards);
			}
		}

		private static void DetachOneNeibShards(List<RFCluster> childClusters, List<RFShard> detachShards, int edgeAmount, int startIndex)
		{
			while (edgeAmount >= detachShards.Count)
			{
				int count = detachShards.Count;
				for (int num = childClusters.Count - 1; num >= startIndex; num--)
				{
					DetachOneNeibShard(childClusters[num], detachShards);
					if (edgeAmount >= detachShards.Count)
					{
						return;
					}
				}
				if (detachShards.Count == count)
				{
					break;
				}
			}
		}

		private static void DetachOneNeibShard(RFCluster cls, List<RFShard> detachShards)
		{
			if (cls.shards.Count < 3)
			{
				return;
			}
			for (int num = cls.shards.Count - 1; num >= 0; num--)
			{
				if (cls.shards[num].neibShards.Count == 1)
				{
					detachShards.Add(cls.shards[num]);
					cls.shards[num].cluster = null;
					for (int num2 = cls.shards[num].neibShards[0].neibShards.Count - 1; num2 >= 0; num2--)
					{
						if (cls.shards[num].neibShards[0].neibShards[num2].cluster == null)
						{
							cls.shards[num].neibShards[0].neibShards.RemoveAt(num2);
							cls.shards[num].neibShards[0].nArea.RemoveAt(num2);
							cls.shards[num].neibShards[0].nIds.RemoveAt(num2);
						}
					}
					cls.shards.RemoveAt(num);
					if (cls.shards.Count <= 2)
					{
						break;
					}
				}
			}
		}

		private static void AddRigidComponent(RayfireRigid scr, List<RFShard> shardList, Transform parent)
		{
			for (int i = 0; i < shardList.Count; i++)
			{
				AddRigidComponent(scr, shardList[i], parent, shardList[i].uny);
			}
		}

		private static void AddRigidComponent(RayfireRigid scr, RFShard shard, Transform parent, bool uny = false)
		{
			shard.tm.parent = parent;
			if (shard.rigid == null)
			{
				shard.rigid = shard.tm.gameObject.AddComponent<RayfireRigid>();
			}
			if (!shard.rigid.physics.exclude)
			{
				scr.fragments.Add(shard.rigid);
				scr.CopyPropertiesTo(shard.rigid);
				shard.rigid.activation.unyielding = uny;
				RFParticles.CopyParticles(scr, shard.rigid);
				shard.rigid.objectType = ObjectType.Mesh;
				shard.rigid.physics.colliderType = RFColliderType.Mesh;
				if ((shard.rigid.simulationType == SimType.Kinematic || shard.rigid.simulationType == SimType.Inactive) && shard.rigid.activation.byConnectivity && !uny)
				{
					shard.rigid.simulationType = SimType.Dynamic;
				}
				if (!scr.clusterDemolition.shardDemolition)
				{
					shard.rigid.demolitionType = DemolitionType.None;
				}
				if (scr.reset.action == RFReset.PostDemolitionType.DeactivateToReset)
				{
					shard.rigid.reset.action = RFReset.PostDemolitionType.DeactivateToReset;
				}
				shard.rigid.limitations.currentDepth = scr.limitations.currentDepth + 1;
				if (scr.clusterDemolition.scaleFactor != 1f)
				{
					shard.rigid.transform.localScale *= scr.clusterDemolition.scaleFactor;
				}
				shard.rigid.Initialize();
				if (shard.rigid.objectType == ObjectType.Mesh && shard.rigid.physics.meshCollider != null)
				{
					((MeshCollider)shard.rigid.physics.meshCollider).convex = true;
				}
			}
		}

		private static bool SameClusterCheck(RayfireRigid scr, List<RFShard> detachShards, int shardAmount, int clusterAmount)
		{
			if (shardAmount == detachShards.Count && clusterAmount == 1)
			{
				UnityEngine.Debug.Log("same");
				scr.limitations.demolitionShould = false;
				scr.clusterDemolition.cluster.shards = detachShards;
				for (int i = 0; i < scr.clusterDemolition.cluster.shards.Count; i++)
				{
					scr.clusterDemolition.cluster.shards[i].cluster = scr.clusterDemolition.cluster;
				}
				RFPhysic.CollectClusterColliders(scr, scr.clusterDemolition.cluster);
				return true;
			}
			return false;
		}
	}
	[Serializable]
	public class RFDemolitionSkin
	{
		public List<Transform> bones;

		public List<SkinnedMeshRenderer> skins;

		public List<SkinnedMeshRenderer> skins0;

		public List<SkinnedMeshRenderer> skins1;

		public List<SkinnedMeshRenderer> skins2;

		public void SetupSkin(RayfireRigid rigid)
		{
			skins = rigid.GetComponentsInChildren<SkinnedMeshRenderer>().ToList();
			for (int i = 0; i < skins.Count; i++)
			{
			}
		}

		public void SeparateSkins(Vector3 planeNormal, Vector3 planePoint)
		{
			Plane plane = new Plane(planeNormal, planePoint);
			for (int i = 0; i < skins.Count; i++)
			{
				bool side = plane.GetSide(skins[i].bounds.min);
				bool side2 = plane.GetSide(skins[i].bounds.max);
				if (side == side2)
				{
					if (side)
					{
						skins1.Add(skins[i]);
					}
					else
					{
						skins2.Add(skins[i]);
					}
				}
				else
				{
					skins0.Add(skins[i]);
				}
			}
		}
	}
	[Serializable]
	public class RFDemolitionMesh
	{
		public enum MeshInputType
		{
			AtStart = 3,
			AtInitialization = 6,
			AtDemolition = 9
		}

		[Header("  Fragments")]
		[Space(3f)]
		[UnityEngine.Tooltip("Defines amount of new fragments after demolition.")]
		[Range(3f, 300f)]
		public int amount;

		[Space(1f)]
		[UnityEngine.Tooltip("Defines additional amount variation for object in percents.")]
		[Range(0f, 100f)]
		public int variation;

		[Space(1f)]
		[UnityEngine.Tooltip("Amount multiplier for next Depth level. Allows to decrease fragments amount of every next demolition level.")]
		[Range(0.01f, 1f)]
		public float depthFade;

		[Space(3f)]
		[UnityEngine.Tooltip("Higher value allows to create more tiny fragments closer to collision contact point and bigger fragments far from it.")]
		[Range(0f, 1f)]
		public float contactBias;

		[Space(1f)]
		[UnityEngine.Tooltip("Defines Seed for fragmentation algorithm. Same Seed will produce same fragments for same object every time.")]
		[Range(1f, 50f)]
		public int seed;

		[UnityEngine.Tooltip("Allows to use RayFire Shatter properties for fragmentation. Works only if object has RayFire Shatter component.")]
		public bool useShatter;

		[Header("  Advanced")]
		[Space(3f)]
		[UnityEngine.Tooltip("Allows to decrease runtime demolition time for mid and hi poly objects.")]
		public MeshInputType meshInput;

		public RFFragmentProperties properties;

		public RFRuntimeCaching runtimeCaching;

		[NonSerialized]
		public int badMesh;

		[NonSerialized]
		public int shatterMode;

		[NonSerialized]
		public int totalAmount;

		[NonSerialized]
		public int innerSubId;

		[NonSerialized]
		public bool compressPrefab;

		[HideInInspector]
		public Quaternion cacheRotationStart;

		[HideInInspector]
		public Mesh mesh;

		[HideInInspector]
		public RFShatter rfShatter;

		[HideInInspector]
		public RayfireShatter scrShatter;

		private static string fragmentStr = "_fr_";

		public RFDemolitionMesh()
		{
			amount = 15;
			variation = 0;
			depthFade = 0.5f;
			contactBias = 0f;
			seed = 1;
			useShatter = false;
			meshInput = MeshInputType.AtDemolition;
			properties = new RFFragmentProperties();
			runtimeCaching = new RFRuntimeCaching();
			Reset();
			shatterMode = 1;
			innerSubId = 0;
			compressPrefab = true;
			cacheRotationStart = Quaternion.identity;
			mesh = null;
			rfShatter = null;
		}

		public void CopyFrom(RFDemolitionMesh demolition)
		{
			amount = demolition.amount;
			variation = demolition.variation;
			depthFade = demolition.depthFade;
			seed = demolition.seed;
			contactBias = demolition.contactBias;
			useShatter = false;
			meshInput = demolition.meshInput;
			meshInput = MeshInputType.AtDemolition;
			properties.CopyFrom(demolition.properties);
			runtimeCaching = new RFRuntimeCaching();
			Reset();
			shatterMode = 1;
			innerSubId = 0;
			compressPrefab = true;
			cacheRotationStart = Quaternion.identity;
			mesh = null;
			rfShatter = null;
		}

		public void Reset()
		{
			badMesh = 0;
			totalAmount = 0;
		}

		public static bool DemolishMesh(RayfireRigid scr)
		{
			if (scr.objectType != 0 && scr.objectType != ObjectType.SkinnedMesh)
			{
				return true;
			}
			if (scr.demolitionType == DemolitionType.ReferenceDemolition)
			{
				return true;
			}
			if (scr.HasFragments)
			{
				scr.rootChild.position = scr.transForm.position;
				scr.rootChild.rotation = scr.transForm.rotation;
				scr.rootChild.transform.parent = RayfireMan.inst.transForm;
				scr.rootChild.gameObject.SetActive(value: true);
				for (int i = 0; i < scr.fragments.Count; i++)
				{
					scr.fragments[i].StartAllCoroutines();
				}
				scr.limitations.demolished = true;
				return true;
			}
			if (scr.HasRfMeshes && !scr.HasMeshes)
			{
				RFMesh.ConvertRfMeshes(scr);
			}
			if (scr.HasMeshes)
			{
				scr.fragments = CreateFragments(scr);
				scr.limitations.demolished = true;
				return true;
			}
			if (!scr.HasMeshes)
			{
				CacheRuntime(scr);
				if (scr.meshDemolition.runtimeCaching.inProgress)
				{
					return false;
				}
				if (scr.HasMeshes)
				{
					scr.fragments = CreateFragments(scr);
					scr.limitations.demolished = true;
					return true;
				}
			}
			return false;
		}

		public static List<RayfireRigid> CreateFragments(RayfireRigid scr)
		{
			List<RayfireRigid> list = new List<RayfireRigid>();
			if (scr.meshes == null)
			{
				return list;
			}
			RayfireMan.RayFireManInit();
			RFLimitations.CreateRoot(scr);
			int layer = scr.meshDemolition.GetLayer(scr);
			string tag = scr.gameObject.tag;
			string text = scr.gameObject.name + fragmentStr;
			if (scr.demolitionType == DemolitionType.AwakePrecache)
			{
				scr.rootChild.transform.rotation = scr.cacheRotation;
			}
			Material[] sharedMaterials = ((scr.skinnedMeshRend != null) ? scr.skinnedMeshRend.sharedMaterials : scr.meshRenderer.sharedMaterials);
			for (int i = 0; i < scr.meshes.Length; i++)
			{
				RayfireRigid rayfireRigid = ((RayfireMan.inst == null) ? RFPoolingFragment.CreateRigidInstance() : RayfireMan.inst.fragments.GetPoolObject(RayfireMan.inst.transForm));
				rayfireRigid.transform.position = scr.transForm.position + scr.pivots[i];
				rayfireRigid.transform.parent = scr.rootChild;
				rayfireRigid.name = text + i;
				rayfireRigid.gameObject.tag = tag;
				rayfireRigid.gameObject.layer = layer;
				rayfireRigid.meshFilter.sharedMesh = scr.meshes[i];
				rayfireRigid.rootParent = scr.rootChild;
				scr.CopyPropertiesTo(rayfireRigid);
				RFParticles.CopyParticles(scr, rayfireRigid);
				RFPhysic.SetFragmentMeshCollider(rayfireRigid, scr.meshes[i]);
				if (RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > 0f && RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > scr.meshes[i].bounds.size.magnitude)
				{
					rayfireRigid.meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
				}
				rayfireRigid.gameObject.SetActive(value: true);
				RFSurface.SetMaterial(scr.subIds, sharedMaterials, scr.materials, rayfireRigid.meshRenderer, i, scr.meshes.Length);
				rayfireRigid.limitations.currentDepth = scr.limitations.currentDepth + 1;
				rayfireRigid.meshDemolition.amount = (int)((float)rayfireRigid.meshDemolition.amount * rayfireRigid.meshDemolition.depthFade);
				if (rayfireRigid.meshDemolition.amount < 3)
				{
					rayfireRigid.meshDemolition.amount = 3;
				}
				list.Add(rayfireRigid);
			}
			if (scr.demolitionType == DemolitionType.AwakePrecache)
			{
				scr.rootChild.rotation = scr.transForm.rotation;
			}
			if (scr.demolitionType == DemolitionType.Runtime && scr.meshDemolition.runtimeCaching.type != 0)
			{
				Quaternion quaternion = scr.transForm.rotation * Quaternion.Inverse(scr.meshDemolition.cacheRotationStart);
				scr.rootChild.rotation = quaternion * scr.rootChild.rotation;
			}
			scr.rootChild.localScale = Vector3.one;
			if (RayfireMan.inst != null && RayfireMan.inst.advancedDemolitionProperties.parent == RFManDemolition.FragmentParentType.Manager)
			{
				scr.rootChild.parent = RayfireMan.inst.transform;
			}
			return list;
		}

		public static void SliceMesh(RayfireRigid scr)
		{
			scr.DeleteCache();
			scr.DeleteFragments();
			RFFragment.SliceMeshes(ref scr.meshes, ref scr.pivots, ref scr.subIds, scr, scr.limitations.slicePlanes);
			scr.limitations.slicePlanes.Clear();
			if (scr.HasMeshes)
			{
				scr.fragments = CreateSlices(scr);
				scr.limitations.demolished = true;
				scr.InitMeshFragments();
				scr.demolitionEvent.InvokeLocalEvent(scr);
				RFDemolitionEvent.InvokeGlobalEvent(scr);
				RayfireMan.DestroyFragment(scr, scr.rootParent);
			}
		}

		public static List<RayfireRigid> CreateSlices(RayfireRigid scr)
		{
			List<RayfireRigid> list = new List<RayfireRigid>();
			if (scr.meshes == null)
			{
				return list;
			}
			RayfireMan.RayFireManInit();
			RFLimitations.CreateRoot(scr);
			int layer = scr.meshDemolition.GetLayer(scr);
			string tag = scr.gameObject.tag;
			string text = scr.gameObject.name + fragmentStr;
			Material[] sharedMaterials = ((scr.skinnedMeshRend != null) ? scr.skinnedMeshRend.sharedMaterials : scr.meshRenderer.sharedMaterials);
			for (int i = 0; i < scr.meshes.Length; i++)
			{
				RayfireRigid rayfireRigid = ((RayfireMan.inst == null) ? RFPoolingFragment.CreateRigidInstance() : RayfireMan.inst.fragments.GetPoolObject(RayfireMan.inst.transForm));
				rayfireRigid.transform.position = scr.transForm.position + scr.pivots[i];
				rayfireRigid.transform.parent = scr.rootChild;
				rayfireRigid.name = text + i;
				rayfireRigid.gameObject.tag = tag;
				rayfireRigid.gameObject.layer = layer;
				rayfireRigid.meshFilter.sharedMesh = scr.meshes[i];
				rayfireRigid.rootParent = scr.rootChild;
				scr.CopyPropertiesTo(rayfireRigid);
				RFParticles.CopyParticles(scr, rayfireRigid);
				RFPhysic.SetFragmentMeshCollider(rayfireRigid, scr.meshes[i]);
				if (RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > 0f && RayfireMan.inst.advancedDemolitionProperties.sizeThreshold > scr.meshes[i].bounds.size.magnitude)
				{
					rayfireRigid.meshRenderer.shadowCastingMode = ShadowCastingMode.Off;
				}
				rayfireRigid.gameObject.SetActive(value: true);
				RFSurface.SetMaterial(scr.subIds, sharedMaterials, scr.materials, rayfireRigid.meshRenderer, i, scr.meshes.Length);
				rayfireRigid.limitations.currentDepth = scr.limitations.currentDepth + 1;
				list.Add(rayfireRigid);
			}
			scr.DeleteCache();
			return list;
		}

		private static void CacheRuntime(RayfireRigid scr)
		{
			if (scr.reset.action != RFReset.PostDemolitionType.DeactivateToReset || scr.reset.mesh != RFReset.MeshResetType.ReuseFragmentMeshes || !scr.HasMeshes)
			{
				scr.DeleteCache();
				if (scr.meshDemolition.runtimeCaching.type == CachingType.Disable)
				{
					CacheInstant(scr);
				}
				else
				{
					scr.CacheFrames();
				}
			}
		}

		public static void CacheInstant(RayfireRigid scr)
		{
			if (RFFragment.InputMesh(scr))
			{
				RFFragment.CacheMeshesInst(ref scr.meshes, ref scr.pivots, ref scr.subIds, scr);
			}
		}

		public int GetLayer(RayfireRigid scr)
		{
			if (properties.layer.Length == 0)
			{
				return scr.gameObject.layer;
			}
			if (!RayfireMan.inst.layers.Contains(properties.layer))
			{
				return 0;
			}
			return LayerMask.NameToLayer(properties.layer);
		}

		public IEnumerator RuntimeCachingCor(RayfireRigid scr)
		{
			bool demolitionShouldLocal = scr.limitations.demolitionShould;
			scr.limitations.demolitionShould = false;
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			if (!RFFragment.InputMesh(scr))
			{
				yield break;
			}
			List<int> batchAmount = ((runtimeCaching.type == CachingType.ByFrames) ? RFRuntimeCaching.GetBatchByFrames(runtimeCaching.frames, totalAmount) : RFRuntimeCaching.GetBatchByFragments(runtimeCaching.fragments, totalAmount));
			runtimeCaching.inProgress = true;
			if (Time.realtimeSinceStartup - realtimeSinceStartup > 0.025f || batchAmount.Count > 5)
			{
				yield return null;
			}
			GameObject tmRefGo = RFRuntimeCaching.CreateTmRef(scr);
			cacheRotationStart = scr.transForm.rotation;
			List<Mesh> meshesList = new List<Mesh>();
			List<Vector3> pivotsList = new List<Vector3>();
			List<RFDictionary> subList = new List<RFDictionary>();
			for (int i = 0; i < batchAmount.Count; i++)
			{
				if (runtimeCaching.stop)
				{
					ResetRuntimeCaching(scr, tmRefGo);
					yield break;
				}
				RFFragment.CacheMeshesMult(tmRefGo.transform, ref meshesList, ref pivotsList, ref subList, scr, batchAmount, i);
				yield return null;
			}
			scr.meshes = meshesList.ToArray();
			scr.pivots = pivotsList.ToArray();
			scr.subIds = subList;
			scr.DestroyObject(tmRefGo);
			scr.meshDemolition.scrShatter = null;
			if (!runtimeCaching.skipFirstDemolition && demolitionShouldLocal)
			{
				scr.limitations.demolitionShould = true;
			}
			if (runtimeCaching.skipFirstDemolition && demolitionShouldLocal)
			{
				scr.damage.Reset();
			}
			runtimeCaching.inProgress = false;
			runtimeCaching.wasUsed = true;
		}

		public void StopRuntimeCaching()
		{
			if (runtimeCaching.inProgress)
			{
				runtimeCaching.stop = true;
			}
		}

		private void ResetRuntimeCaching(RayfireRigid scr, GameObject tmRefGo)
		{
			scr.DestroyObject(tmRefGo);
			runtimeCaching.stop = false;
			runtimeCaching.inProgress = false;
			scr.meshDemolition.rfShatter = null;
			scr.DeleteCache();
		}
	}
	[Serializable]
	public class RFFade
	{
		public enum RFFadeLifeType
		{
			ByLifeTime = 4,
			BySimulationAndLifeTime = 8
		}

		[Header("  Initiate")]
		[Space(2f)]
		public bool onDemolition;

		public bool onActivation;

		[Header("  Life")]
		[Space(2f)]
		public RFFadeLifeType lifeType;

		[Range(0f, 90f)]
		public float lifeTime;

		[Range(0f, 20f)]
		public float lifeVariation;

		[Header("  Fade")]
		[Space(2f)]
		public FadeType fadeType;

		[Range(1f, 20f)]
		public float fadeTime;

		[Range(0f, 20f)]
		public float sizeFilter;

		[NonSerialized]
		public int state;

		[NonSerialized]
		public bool stop;

		[NonSerialized]
		public Vector3 position;

		public RFFade()
		{
			onDemolition = true;
			onActivation = false;
			lifeType = RFFadeLifeType.ByLifeTime;
			lifeTime = 7f;
			lifeVariation = 3f;
			fadeType = FadeType.None;
			fadeTime = 5f;
			sizeFilter = 0f;
			Reset();
		}

		public void CopyFrom(RFFade fade)
		{
			onDemolition = fade.onDemolition;
			onActivation = fade.onActivation;
			lifeType = fade.lifeType;
			lifeTime = fade.lifeTime;
			lifeVariation = fade.lifeVariation;
			fadeType = fade.fadeType;
			fadeTime = fade.fadeTime;
			sizeFilter = fade.sizeFilter;
			Reset();
		}

		public void Reset()
		{
			state = 0;
			stop = false;
		}

		public void DemolitionFade(List<RayfireRigid> fadeObjects)
		{
			if (fadeType == FadeType.None || fadeObjects.Count == 0)
			{
				return;
			}
			if (lifeTime < 1f)
			{
				lifeTime = 1f;
			}
			for (int i = 0; i < fadeObjects.Count; i++)
			{
				if (!(fadeObjects[i] == null) && (!(sizeFilter > 0f) || !(fadeObjects[i].limitations.bboxSize > sizeFilter)))
				{
					Fade(fadeObjects[i]);
				}
			}
		}

		public static void Fade(RayfireRigid scr)
		{
			if (!scr.initialized)
			{
				scr.Initialize();
			}
			if (scr.fading.fadeType != 0 && scr.gameObject.activeSelf && scr.fading.state <= 0)
			{
				scr.StartCoroutine(scr.fading.LivingCor(scr));
			}
		}

		private IEnumerator LivingCor(RayfireRigid scr)
		{
			if (scr.fading.lifeType == RFFadeLifeType.BySimulationAndLifeTime)
			{
				yield return scr.StartCoroutine(SimulationCor(scr));
			}
			scr.fading.state = 1;
			float num = scr.fading.lifeTime;
			if (scr.fading.lifeVariation > 0f)
			{
				num += UnityEngine.Random.Range(0f, scr.fading.lifeVariation);
			}
			if (num > 0f)
			{
				yield return new WaitForSeconds(num);
			}
			if (stop)
			{
				scr.fading.Reset();
				yield break;
			}
			scr.fading.state = 2;
			if (scr.fading.fadeType == FadeType.SimExclude)
			{
				FadeExclude(scr);
			}
			else if (scr.fading.fadeType == FadeType.MoveDown)
			{
				scr.StartCoroutine(FadeMoveDown(scr));
			}
			else if (scr.fading.fadeType == FadeType.ScaleDown)
			{
				scr.StartCoroutine(FadeScaleDownCor(scr));
			}
			else if (scr.fading.fadeType == FadeType.Destroy)
			{
				RayfireMan.DestroyFragment(scr, scr.rootParent);
			}
		}

		private static void FadeExclude(RayfireRigid scr)
		{
			scr.fading.state = 2;
			if (scr.reset.action == RFReset.PostDemolitionType.DestroyWithDelay)
			{
				scr.DestroyRb(scr.physics.rigidBody);
				scr.DestroyCollider(scr.physics.meshCollider);
				scr.DestroyRigid(scr);
			}
			else if (scr.reset.action == RFReset.PostDemolitionType.DeactivateToReset)
			{
				scr.physics.rigidBody.isKinematic = true;
				scr.physics.meshCollider.enabled = false;
				scr.StopAllCoroutines();
			}
		}

		private static IEnumerator FadeMoveDown(RayfireRigid scr)
		{
			if (scr.simulationType == SimType.Inactive)
			{
				scr.Activate();
			}
			scr.physics.rigidBody.WakeUp();
			if (scr.objectType == ObjectType.Mesh)
			{
				if (scr.physics.meshCollider != null)
				{
					scr.physics.meshCollider.enabled = false;
				}
			}
			else if ((scr.objectType == ObjectType.ConnectedCluster || scr.objectType == ObjectType.NestedCluster) && scr.physics.clusterColliders != null)
			{
				for (int i = 0; i < scr.physics.clusterColliders.Count; i++)
				{
					scr.physics.clusterColliders[i].enabled = false;
				}
			}
			yield return new WaitForSeconds(scr.fading.fadeTime);
			RayfireMan.DestroyFragment(scr, scr.rootParent);
		}

		private static IEnumerator FadeScaleDownCor(RayfireRigid scr)
		{
			float waitStep = 0.04f;
			int steps = (int)(scr.fading.fadeTime / waitStep);
			Vector3 vectorStep = scr.transForm.localScale / steps;
			while (steps > 0)
			{
				steps--;
				scr.transForm.localScale -= vectorStep;
				yield return new WaitForSeconds(waitStep);
				if (steps < 4)
				{
					RayfireMan.DestroyFragment(scr, scr.rootParent);
				}
			}
		}

		private static IEnumerator SimulationCor(RayfireRigid scr)
		{
			float timeStep = UnityEngine.Random.Range(2.5f, 3.5f);
			float distanceThreshold = 0.15f;
			bool check = true;
			while (check)
			{
				scr.fading.position = scr.transForm.position;
				yield return new WaitForSeconds(timeStep);
				if (Vector3.Distance(scr.fading.position, scr.transForm.position) < distanceThreshold)
				{
					check = false;
				}
			}
		}
	}
	[Serializable]
	public class RFFragmentProperties
	{
		[Header("  Collider")]
		[Space(2f)]
		public RFColliderType colliderType;

		[UnityEngine.Tooltip("Fragments with size less than this value will not get collider")]
		[Range(0f, 10f)]
		public float sizeFilter;

		[Header("  Mesh Ops")]
		[Space(2f)]
		[UnityEngine.Tooltip("Detach all not connected with each other faces into separate meshes.")]
		public bool decompose;

		[UnityEngine.Tooltip("Remove collier vertices to decrease amount of triangles")]
		public bool removeCollinear;

		[Header("  Custom Layer")]
		[Space(2f)]
		[UnityEngine.Tooltip("Custom layer for fragments")]
		public string layer;

		public RFFragmentProperties()
		{
			colliderType = RFColliderType.Mesh;
			sizeFilter = 0f;
			decompose = false;
			removeCollinear = false;
			layer = "";
		}

		public void CopyFrom(RFFragmentProperties fragmentProperties)
		{
			colliderType = fragmentProperties.colliderType;
			sizeFilter = fragmentProperties.sizeFilter;
			decompose = false;
			removeCollinear = fragmentProperties.removeCollinear;
			layer = fragmentProperties.layer;
		}
	}
	[Serializable]
	public class RFLimitations
	{
		[UnityEngine.Tooltip("Local Object solidity multiplier for object. Low Solidity makes object more fragile.")]
		[Range(0f, 10f)]
		public float solidity;

		[Space(1f)]
		[UnityEngine.Tooltip("Defines how deep object can be demolished. Depth is limitless if set to 0.")]
		[Range(0f, 7f)]
		public int depth;

		[Space(1f)]
		[UnityEngine.Tooltip("Safe time. Measures in seconds and allows to prevent fragments from being demolished right after they were just created.")]
		[Range(0.05f, 10f)]
		public float time;

		[Space(1f)]
		[UnityEngine.Tooltip("Prevent objects with bounding box size less than defined value to be demolished.")]
		[Range(0.01f, 5f)]
		public float size;

		[Space(1f)]
		[UnityEngine.Tooltip("Object will be demolished only if it is visible to any camera including scene camera.")]
		public bool visible;

		[UnityEngine.Tooltip("Allows object to be sliced by object with RayFire Blade component.")]
		public bool sliceByBlade;

		[NonSerialized]
		public List<Vector3> slicePlanes;

		[NonSerialized]
		public ContactPoint contactPoint;

		[NonSerialized]
		public Vector3 contactVector3;

		[NonSerialized]
		public Vector3 contactNormal;

		[NonSerialized]
		public bool demolitionShould;

		[NonSerialized]
		public bool demolished;

		[NonSerialized]
		public float birthTime;

		[NonSerialized]
		public float bboxSize;

		[NonSerialized]
		public int currentDepth;

		[NonSerialized]
		public RayfireRigid ancestor;

		[NonSerialized]
		public List<RayfireRigid> descendants;

		[HideInInspector]
		public Bounds bound;

		private static string rootStr = "_root";

		public RFLimitations()
		{
			solidity = 0.1f;
			depth = 1;
			time = 0.2f;
			size = 0.1f;
			visible = false;
			sliceByBlade = false;
			currentDepth = 0;
			birthTime = 0f;
			bboxSize = 0f;
			ancestor = null;
			descendants = null;
			Reset();
		}

		public void CopyFrom(RFLimitations limitations)
		{
			solidity = limitations.solidity;
			depth = limitations.depth;
			time = limitations.time;
			size = limitations.size;
			visible = limitations.visible;
			sliceByBlade = limitations.sliceByBlade;
			Reset();
		}

		public void Reset()
		{
			slicePlanes = new List<Vector3>();
			contactVector3 = Vector3.zero;
			contactNormal = Vector3.down;
			demolitionShould = false;
			demolished = false;
		}

		public IEnumerator DemolishableCor(RayfireRigid scr)
		{
			while (scr.demolitionType != 0)
			{
				if (scr.limitations.depth > 0 && scr.limitations.currentDepth >= scr.limitations.depth)
				{
					scr.demolitionType = DemolitionType.None;
				}
				if (scr.limitations.demolitionShould)
				{
					scr.Demolish();
				}
				else if (scr.limitations.sliceByBlade && scr.limitations.slicePlanes.Count > 1)
				{
					scr.Slice();
				}
				yield return null;
			}
		}

		public static void Checks(RayfireRigid scr)
		{
			_ = scr.objectType;
			if (scr.simulationType == SimType.Static && scr.demolitionType != 0)
			{
				UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Simulation Type set to " + scr.simulationType.ToString() + " but Demolition Type is not None. Static object can not be demolished. Demolition Type set to None.", scr.gameObject);
				scr.demolitionType = DemolitionType.None;
			}
			if (scr.simulationType != SimType.Static && scr.gameObject.isStatic)
			{
				UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Simulation Type set to " + scr.simulationType.ToString() + " but object is Static. Turn off Static checkbox in Inspector.", scr.gameObject);
			}
			if (scr.objectType == ObjectType.Mesh)
			{
				if (scr.meshFilter == null || scr.meshFilter.sharedMesh == null)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but object has no mesh. Object Excluded from simulation.", scr.gameObject);
					scr.physics.exclude = true;
				}
				if (scr.demolitionType != 0 && scr.meshFilter != null && scr.meshFilter.sharedMesh != null && !scr.meshFilter.sharedMesh.isReadable)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Mesh is not readable. Demolition type set to None. Open Import Settings and turn On Read/Write Enabled property", scr.meshFilter.gameObject);
					scr.demolitionType = DemolitionType.None;
					scr.meshDemolition.badMesh = 10;
				}
			}
			else if (scr.objectType == ObjectType.NestedCluster || scr.objectType == ObjectType.ConnectedCluster)
			{
				if (scr.transForm.childCount == 0)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but object has no children. Object Excluded from simulation.", scr.gameObject);
					scr.physics.exclude = true;
				}
			}
			else if (scr.objectType == ObjectType.SkinnedMesh)
			{
				if (scr.skinnedMeshRend == null)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but object has no SkinnedMeshRenderer. Object Excluded from simulation.", scr.gameObject);
				}
				scr.physics.exclude = true;
			}
			if (scr.demolitionType != 0)
			{
				if ((scr.objectType == ObjectType.SkinnedMesh || scr.objectType == ObjectType.NestedCluster || scr.objectType == ObjectType.ConnectedCluster) && scr.demolitionType != DemolitionType.Runtime && scr.demolitionType != DemolitionType.ReferenceDemolition)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Object Type set to " + scr.objectType.ToString() + " but Demolition Type is " + scr.demolitionType.ToString() + ". Demolition Type set to Runtime.", scr.gameObject);
					scr.demolitionType = DemolitionType.Runtime;
				}
				if (scr.meshDemolition.scrShatter == null && scr.meshDemolition.useShatter && (scr.demolitionType == DemolitionType.Runtime || scr.demolitionType == DemolitionType.AwakePrecache || scr.demolitionType == DemolitionType.AwakePrefragment))
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + "Demolition Type is " + scr.demolitionType.ToString() + ". Has no Shatter component, but Use Shatter property is On. Use Shatter property was turned Off.", scr.gameObject);
					scr.meshDemolition.useShatter = false;
				}
			}
			if (scr.demolitionType == DemolitionType.None)
			{
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to None. Had manually precached meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to None. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to None. Had manually precached serialized meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
			}
			else if (scr.demolitionType == DemolitionType.Runtime)
			{
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Runtime. Had manually precached meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Runtime. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Runtime. Had manually precached serialized meshes which were destroyed.", scr.gameObject);
					scr.DeleteCache();
				}
				if (scr.meshDemolition.useShatter && scr.meshDemolition.runtimeCaching.type != 0 && (scr.meshDemolition.scrShatter.type == FragType.Decompose || scr.meshDemolition.scrShatter.type == FragType.Tets || scr.meshDemolition.scrShatter.type == FragType.Slices || scr.meshDemolition.scrShatter.clusters.enable))
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type is Runtime, Use Shatter is On. Unsupported fragments type. Runtime Caching supports only Voronoi, Splinters, Slabs and Radial fragmentation types. Runtime Caching was Disabled.", scr.gameObject);
					scr.meshDemolition.runtimeCaching.type = CachingType.Disable;
				}
			}
			else if (scr.demolitionType == DemolitionType.AwakePrecache)
			{
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Precache. Had manually precached Unity meshes which were overwritten.", scr.gameObject);
				}
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Precache. Had manually prefragmented objects which were destroyed.", scr.gameObject);
					scr.DeleteFragments();
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Awake Precache. Has manually precached serialized meshes.", scr.gameObject);
				}
			}
			else if (scr.demolitionType == DemolitionType.AwakePrefragment)
			{
				if (scr.HasFragments)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Prefragment. Has manually prefragmented objects", scr.gameObject);
				}
				if (scr.HasMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid: " + scr.name + " Demolition Type set to Awake Prefragment. Has manually precached Unity meshes.", scr.gameObject);
				}
				if (scr.HasRfMeshes)
				{
					UnityEngine.Debug.Log("RayFire Rigid:" + scr.name + " Demolition Type set to Awake Prefragment. Has manually precached serialized meshes.", scr.gameObject);
				}
			}
		}

		public static void SetBound(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.Mesh)
			{
				scr.limitations.bound = scr.meshRenderer.bounds;
			}
			else if (scr.objectType == ObjectType.SkinnedMesh)
			{
				scr.limitations.bound = scr.skinnedMeshRend.bounds;
			}
			else if (scr.objectType == ObjectType.NestedCluster || scr.objectType == ObjectType.ConnectedCluster)
			{
				scr.limitations.bound = RFCluster.GetChildrenBound(scr.transForm);
			}
			scr.limitations.bboxSize = scr.limitations.bound.size.magnitude;
		}

		public static void SetAncestor(RayfireRigid scr)
		{
			if (scr.limitations.ancestor == null)
			{
				for (int i = 0; i < scr.fragments.Count; i++)
				{
					scr.fragments[i].limitations.ancestor = scr;
				}
			}
			else
			{
				for (int j = 0; j < scr.fragments.Count; j++)
				{
					scr.fragments[j].limitations.ancestor = scr.limitations.ancestor;
				}
			}
		}

		public static void SetDescendants(RayfireRigid scr)
		{
			if (scr.limitations.ancestor == null)
			{
				scr.limitations.descendants.AddRange(scr.fragments);
			}
			else
			{
				scr.limitations.ancestor.limitations.descendants.AddRange(scr.fragments);
			}
		}

		public static void CreateRoot(RayfireRigid rfScr)
		{
			GameObject gameObject = new GameObject(rfScr.gameObject.name + rootStr);
			rfScr.rootChild = gameObject.transform;
			rfScr.rootChild.position = rfScr.transForm.position;
			rfScr.rootChild.rotation = rfScr.transForm.rotation;
			rfScr.rootChild.SetParent(rfScr.gameObject.transform.parent);
		}
	}
	[Serializable]
	public class RFPhysic
	{
		[Header("  Physic Material")]
		[Space(3f)]
		[UnityEngine.Tooltip("Material preset with predefined density, friction, elasticity and solidity. Can be edited in Rayfire Man component.")]
		public MaterialType materialType;

		[Space(2f)]
		[UnityEngine.Tooltip("Allows to define own Physic Material.")]
		public PhysicMaterial material;

		[Header("  Mass")]
		[Space(3f)]
		public MassType massBy;

		[Space(2f)]
		[Range(0.1f, 100f)]
		public float mass;

		[Header("  Other")]
		[Space(3f)]
		public RFColliderType colliderType;

		[Space(2f)]
		public bool useGravity;

		[Header("  Fragments")]
		[Space(3f)]
		[UnityEngine.Tooltip("Multiplier for demolished fragments velocity.")]
		[Range(0f, 5f)]
		public float dampening;

		[HideInInspector]
		public Rigidbody rigidBody;

		[HideInInspector]
		public Collider meshCollider;

		[HideInInspector]
		public List<Collider> clusterColliders;

		[NonSerialized]
		public bool rec;

		[NonSerialized]
		public bool exclude;

		[NonSerialized]
		public bool destructible;

		[NonSerialized]
		public int solidity;

		[NonSerialized]
		public Quaternion rotation;

		[NonSerialized]
		public Vector3 position;

		[NonSerialized]
		public Vector3 velocity;

		[NonSerialized]
		public Vector3 initScale;

		[NonSerialized]
		public Vector3 initPosition;

		[NonSerialized]
		public Quaternion initRotation;

		public bool HasClusterColliders
		{
			get
			{
				if (clusterColliders != null && clusterColliders.Count > 0)
				{
					return true;
				}
				return false;
			}
		}

		public bool Destructible => RayfireMan.inst.materialPresets.Destructible(materialType);

		public int Solidity => RayfireMan.inst.materialPresets.Solidity(materialType);

		private PhysicMaterial PhysMaterial
		{
			get
			{
				if (material != null)
				{
					return material;
				}
				return RFMaterialPresets.Material(materialType);
			}
		}

		public RFPhysic()
		{
			materialType = MaterialType.Concrete;
			material = null;
			massBy = MassType.MaterialDensity;
			mass = 1f;
			colliderType = RFColliderType.Mesh;
			useGravity = true;
			dampening = 0.8f;
			solidity = 1;
			Reset();
			rotation = Quaternion.identity;
			position = Vector3.zero;
			velocity = Vector3.zero;
			initScale = Vector3.one;
			initPosition = Vector3.zero;
			initRotation = Quaternion.identity;
		}

		public void CopyFrom(RFPhysic physics)
		{
			materialType = physics.materialType;
			material = physics.material;
			massBy = physics.massBy;
			mass = physics.mass;
			colliderType = physics.colliderType;
			useGravity = physics.useGravity;
			dampening = physics.dampening;
			Reset();
		}

		public void Reset()
		{
			rec = false;
			exclude = false;
		}

		public static void SetSimulationType(RayfireRigid scr)
		{
			if (scr.simulationType == SimType.Dynamic)
			{
				SetDynamic(scr);
			}
			else if (scr.simulationType == SimType.Sleeping)
			{
				SetSleeping(scr);
			}
			else if (scr.simulationType == SimType.Inactive)
			{
				SetInactive(scr);
			}
			else if (scr.simulationType == SimType.Kinematic)
			{
				SetKinematic(scr);
			}
		}

		private static void SetDynamic(RayfireRigid scr)
		{
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
		}

		private static void SetSleeping(RayfireRigid scr)
		{
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
			scr.physics.rigidBody.interpolation = RigidbodyInterpolation.Interpolate;
			scr.physics.rigidBody.Sleep();
		}

		private static void SetInactive(RayfireRigid scr)
		{
			scr.physics.rigidBody.isKinematic = false;
			scr.physics.rigidBody.useGravity = false;
			scr.physics.rigidBody.Sleep();
		}

		private static void SetKinematic(RayfireRigid scr)
		{
			scr.physics.rigidBody.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
			scr.physics.rigidBody.isKinematic = true;
			scr.physics.rigidBody.useGravity = scr.physics.useGravity;
		}

		public static void SetDensity(RayfireRigid scr)
		{
			if (scr.physics.rigidBody.isKinematic)
			{
				return;
			}
			float num = scr.physics.mass;
			if (scr.objectType == ObjectType.Mesh && scr.physics.massBy == MassType.MaterialDensity)
			{
				scr.physics.rigidBody.SetDensity(RayfireMan.inst.materialPresets.Density(scr.physics.materialType));
				num = scr.physics.rigidBody.mass;
			}
			else if (scr.objectType == ObjectType.ConnectedCluster || scr.objectType == ObjectType.NestedCluster)
			{
				num = 0.1f;
				float num2 = RayfireMan.inst.materialPresets.Density(scr.physics.materialType);
				for (int i = 0; i < scr.clusterDemolition.cluster.shards.Count; i++)
				{
					num += scr.clusterDemolition.cluster.shards[i].sz * num2;
				}
				if (scr.objectType == ObjectType.NestedCluster && scr.clusterDemolition.cluster.HasChildClusters)
				{
					for (int j = 0; j < scr.clusterDemolition.cluster.childClusters.Count; j++)
					{
						num += scr.clusterDemolition.cluster.childClusters[j].bound.size.magnitude * num2;
					}
				}
			}
			if (RayfireMan.inst.minimumMass > 0f && num < RayfireMan.inst.minimumMass)
			{
				num = RayfireMan.inst.minimumMass;
			}
			if (RayfireMan.inst.maximumMass > 0f && num > RayfireMan.inst.maximumMass)
			{
				num = RayfireMan.inst.maximumMass;
			}
			scr.physics.rigidBody.mass = num;
		}

		public static void SetDrag(RayfireRigid scr)
		{
			scr.physics.rigidBody.drag = RayfireMan.inst.materialPresets.Drag(scr.physics.materialType);
			scr.physics.rigidBody.angularDrag = RayfireMan.inst.materialPresets.AngularDrag(scr.physics.materialType);
		}

		public static void SetFragmentsVelocity(RayfireRigid scr)
		{
			if (scr.meshDemolition.runtimeCaching.wasUsed && !scr.meshDemolition.runtimeCaching.skipFirstDemolition)
			{
				for (int i = 0; i < scr.fragments.Count; i++)
				{
					if (scr.fragments[i] != null)
					{
						scr.fragments[i].physics.rigidBody.velocity = scr.physics.rigidBody.GetPointVelocity(scr.fragments[i].transForm.position) * scr.physics.dampening;
					}
				}
				return;
			}
			Vector3 vector = scr.physics.velocity * scr.physics.dampening;
			for (int j = 0; j < scr.fragments.Count; j++)
			{
				if (scr.fragments[j].physics.rigidBody != null)
				{
					scr.fragments[j].physics.rigidBody.velocity = vector;
				}
			}
		}

		public static void SetFragmentMeshCollider(RayfireRigid scr, Mesh mesh)
		{
			scr.physics.colliderType = scr.meshDemolition.properties.colliderType;
			if (scr.meshDemolition.properties.sizeFilter > 0f && mesh.bounds.size.magnitude < scr.meshDemolition.properties.sizeFilter)
			{
				scr.physics.colliderType = RFColliderType.None;
			}
			SetMeshCollider(scr, mesh);
		}

		public static void SetMeshCollider(RayfireRigid scr, Mesh mesh = null)
		{
			if (scr.physics.colliderType == RFColliderType.None)
			{
				return;
			}
			if (scr.physics.meshCollider != null && scr.physics.meshCollider.isTrigger)
			{
				scr.physics.meshCollider = null;
			}
			if (!(scr.physics.meshCollider == null))
			{
				return;
			}
			if (scr.physics.colliderType == RFColliderType.Mesh)
			{
				MeshCollider meshCollider = scr.gameObject.AddComponent<MeshCollider>();
				if (mesh != null)
				{
					meshCollider.sharedMesh = mesh;
				}
				if (scr.simulationType != SimType.Static)
				{
					meshCollider.convex = true;
				}
				scr.physics.meshCollider = meshCollider;
			}
			else if (scr.physics.colliderType == RFColliderType.Box)
			{
				scr.physics.meshCollider = scr.gameObject.AddComponent<BoxCollider>();
			}
			else if (scr.physics.colliderType == RFColliderType.Sphere)
			{
				scr.physics.meshCollider = scr.gameObject.AddComponent<SphereCollider>();
			}
		}

		public static bool SetClusterCollidersByShards(RayfireRigid scr)
		{
			scr.physics.CollidersRemoveNull(scr);
			if (scr.physics.HasClusterColliders)
			{
				return true;
			}
			if (scr.physics.clusterColliders == null)
			{
				scr.physics.clusterColliders = new List<Collider>();
			}
			if (scr.objectType == ObjectType.ConnectedCluster)
			{
				SetShardColliders(scr, scr.clusterDemolition.cluster);
			}
			else if (scr.objectType == ObjectType.NestedCluster)
			{
				SetDeepShardColliders(scr, scr.clusterDemolition.cluster);
			}
			return true;
		}

		private static void SetShardColliders(RayfireRigid scr, RFCluster cluster)
		{
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				MeshCollider meshCollider = cluster.shards[i].tm.GetComponent<MeshCollider>();
				if (meshCollider == null)
				{
					MeshFilter component = cluster.shards[i].tm.GetComponent<MeshFilter>();
					meshCollider = component.gameObject.AddComponent<MeshCollider>();
					meshCollider.sharedMesh = component.sharedMesh;
				}
				meshCollider.convex = true;
				cluster.shards[i].col = meshCollider;
				scr.physics.clusterColliders.Add(meshCollider);
			}
		}

		private static void SetDeepShardColliders(RayfireRigid scr, RFCluster cluster)
		{
			SetShardColliders(scr, cluster);
			if (cluster.HasChildClusters)
			{
				for (int i = 0; i < cluster.childClusters.Count; i++)
				{
					SetDeepShardColliders(scr, cluster.childClusters[i]);
				}
			}
		}

		public static void CollectClusterColliders(RayfireRigid scr, RFCluster cluster)
		{
			if (scr.physics.clusterColliders == null)
			{
				scr.physics.clusterColliders = new List<Collider>();
			}
			else
			{
				scr.physics.clusterColliders.Clear();
			}
			CollectDeepColliders(scr, cluster);
		}

		private static void CollectDeepColliders(RayfireRigid scr, RFCluster cluster)
		{
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				scr.physics.clusterColliders.Add(cluster.shards[i].col);
			}
			if (scr.objectType == ObjectType.NestedCluster && cluster.HasChildClusters)
			{
				for (int j = 0; j < cluster.childClusters.Count; j++)
				{
					CollectDeepColliders(scr, cluster.childClusters[j]);
				}
			}
		}

		public static void SetColliderMaterial(RayfireRigid scr)
		{
			if (scr.physics.material == null)
			{
				scr.physics.material = scr.physics.PhysMaterial;
			}
			if (scr.physics.meshCollider != null)
			{
				scr.physics.meshCollider.sharedMaterial = scr.physics.material;
				if (scr.HasDebris)
				{
					for (int i = 0; i < scr.debrisList.Count; i++)
					{
						scr.debrisList[i].collision.SetMaterialProps(scr.debrisList[i]);
					}
				}
			}
			else if (scr.physics.HasClusterColliders)
			{
				for (int j = 0; j < scr.physics.clusterColliders.Count; j++)
				{
					scr.physics.clusterColliders[j].sharedMaterial = scr.physics.material;
				}
			}
		}

		public static void SetColliderConvex(RayfireRigid scr)
		{
			if (scr.physics.meshCollider != null && scr.physics.meshCollider is MeshCollider)
			{
				MeshCollider meshCollider = (MeshCollider)scr.physics.meshCollider;
				if (!scr.physics.rigidBody.isKinematic)
				{
					meshCollider.convex = true;
				}
			}
		}

		public static void DestroyColliders(RayfireRigid scr)
		{
			if (scr.physics.HasClusterColliders)
			{
				for (int num = scr.physics.clusterColliders.Count - 1; num >= 0; num--)
				{
					if (scr.physics.clusterColliders[num] != null)
					{
						UnityEngine.Object.DestroyImmediate(scr.physics.clusterColliders[num], allowDestroyingAssets: true);
					}
				}
			}
			scr.physics.clusterColliders.Clear();
		}

		public void CollidersRemoveNull(RayfireRigid scr)
		{
			if (!scr.physics.HasClusterColliders)
			{
				return;
			}
			for (int num = scr.physics.clusterColliders.Count - 1; num >= 0; num--)
			{
				if (scr.physics.clusterColliders[num] == null)
				{
					scr.physics.clusterColliders.RemoveAt(num);
				}
			}
		}

		public IEnumerator PhysicsDataCor(RayfireRigid scr)
		{
			velocity = scr.physics.rigidBody.velocity;
			position = scr.transForm.position;
			rotation = scr.transForm.rotation;
			while (!exclude)
			{
				if (scr.transForm.hasChanged)
				{
					velocity = scr.physics.rigidBody.velocity;
					position = scr.transForm.position;
					rotation = scr.transForm.rotation;
					scr.transForm.hasChanged = false;
				}
				yield return null;
			}
		}
	}
	[Serializable]
	public class RFReferenceDemolition
	{
		[Header("  Source")]
		[Space(1f)]
		public GameObject reference;

		public List<GameObject> randomList;

		[Header("  Properties")]
		[Space(1f)]
		[UnityEngine.Tooltip("Add RayFire Rigid component to reference with mesh")]
		public bool addRigid;

		public bool inheritScale;

		public RFReferenceDemolition()
		{
			reference = null;
			addRigid = true;
			inheritScale = true;
		}

		public void CopyFrom(RFReferenceDemolition referenceDemolitionDml)
		{
			reference = referenceDemolitionDml.reference;
			if (referenceDemolitionDml.randomList != null && referenceDemolitionDml.randomList.Count > 0)
			{
				if (randomList == null)
				{
					randomList = new List<GameObject>();
				}
				randomList = referenceDemolitionDml.randomList;
			}
			addRigid = referenceDemolitionDml.addRigid;
			inheritScale = referenceDemolitionDml.inheritScale;
		}

		public GameObject GetReference()
		{
			if (reference != null && randomList.Count == 0)
			{
				return reference;
			}
			List<GameObject> list = new List<GameObject>();
			if (randomList.Count > 0)
			{
				for (int i = 0; i < randomList.Count; i++)
				{
					if (randomList[i] != null)
					{
						list.Add(randomList[i]);
					}
				}
				if (list.Count > 0)
				{
					return list[UnityEngine.Random.Range(0, list.Count)];
				}
			}
			return null;
		}

		public static bool DemolishReference(RayfireRigid scr)
		{
			if (scr.demolitionType == DemolitionType.ReferenceDemolition)
			{
				scr.limitations.demolished = true;
				scr.gameObject.SetActive(value: false);
				GameObject gameObject = scr.referenceDemolition.GetReference();
				if (gameObject == null)
				{
					return true;
				}
				GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject, scr.transForm.position, scr.transForm.rotation);
				gameObject2.name = gameObject.name;
				if (RayfireMan.inst != null && RayfireMan.inst.advancedDemolitionProperties.parent == RFManDemolition.FragmentParentType.Manager)
				{
					gameObject2.transform.parent = RayfireMan.inst.transform;
				}
				else
				{
					gameObject2.transform.parent = scr.transForm.parent;
				}
				scr.rootChild = gameObject2.transform;
				if (scr.referenceDemolition.inheritScale)
				{
					scr.rootChild.localScale = scr.transForm.localScale;
				}
				scr.fragments = new List<RayfireRigid>();
				RayfireRigid rayfireRigid = gameObject2.gameObject.GetComponent<RayfireRigid>();
				if (rayfireRigid == null && scr.referenceDemolition.addRigid)
				{
					rayfireRigid = gameObject2.gameObject.AddComponent<RayfireRigid>();
					scr.CopyPropertiesTo(rayfireRigid);
					RFParticles.CopyParticles(scr, rayfireRigid);
					if (gameObject2.transform.childCount == 0)
					{
						rayfireRigid.objectType = ObjectType.Mesh;
					}
					if (gameObject2.transform.childCount > 0)
					{
						rayfireRigid.objectType = ObjectType.MeshRoot;
					}
				}
				gameObject2.transform.gameObject.SetActive(value: true);
				if (rayfireRigid != null)
				{
					rayfireRigid.Initialize();
					if (rayfireRigid.objectType == ObjectType.MeshRoot)
					{
						for (int i = 0; i < rayfireRigid.fragments.Count; i++)
						{
							rayfireRigid.fragments[i].limitations.currentDepth++;
						}
						scr.fragments.AddRange(rayfireRigid.fragments);
						scr.DestroyRigid(rayfireRigid);
					}
					else if (rayfireRigid.objectType == ObjectType.Mesh || rayfireRigid.objectType == ObjectType.SkinnedMesh)
					{
						rayfireRigid.meshDemolition.runtimeCaching.type = CachingType.Disable;
						RFDemolitionMesh.DemolishMesh(rayfireRigid);
						scr.fragments.AddRange(rayfireRigid.fragments);
						RayfireMan.DestroyFragment(rayfireRigid, rayfireRigid.rootParent, 1f);
					}
					else if (rayfireRigid.objectType == ObjectType.NestedCluster || rayfireRigid.objectType == ObjectType.ConnectedCluster)
					{
						rayfireRigid.Default();
						rayfireRigid.limitations.contactPoint = scr.limitations.contactPoint;
						rayfireRigid.limitations.contactVector3 = scr.limitations.contactVector3;
						rayfireRigid.limitations.contactNormal = scr.limitations.contactNormal;
						RFDemolitionCluster.DemolishCluster(rayfireRigid);
						scr.fragments.AddRange(rayfireRigid.fragments);
					}
				}
			}
			return true;
		}
	}
	[Serializable]
	public class RFReset
	{
		public enum PostDemolitionType
		{
			DestroyWithDelay,
			DeactivateToReset
		}

		public enum MeshResetType
		{
			Destroy = 0,
			ReuseInputMesh = 2,
			ReuseFragmentMeshes = 4
		}

		public enum FragmentsResetType
		{
			Destroy = 0,
			Reuse = 2,
			Preserve = 4
		}

		public enum ShardsResetType
		{
			DestroyRigid = 0,
			ReuseRigid = 2
		}

		[Header("  Reset")]
		[Space(3f)]
		public bool transform;

		[Space(2f)]
		public bool damage;

		[Header("  Post Demolition")]
		[Space(3f)]
		public PostDemolitionType action;

		[Space(2f)]
		[Range(1f, 60f)]
		public int destroyDelay;

		[Header("  Reuse")]
		[Space(3f)]
		public MeshResetType mesh;

		[Space(2f)]
		public FragmentsResetType fragments;

		[Space(2f)]
		[HideInInspector]
		public ShardsResetType shards;

		[NonSerialized]
		public bool toBeDestroyed;

		public RFReset()
		{
			action = PostDemolitionType.DestroyWithDelay;
			destroyDelay = 1;
			transform = true;
			damage = true;
			mesh = MeshResetType.ReuseFragmentMeshes;
			fragments = FragmentsResetType.Destroy;
			shards = ShardsResetType.DestroyRigid;
			toBeDestroyed = false;
		}

		public void CopyFrom(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.MeshRoot)
			{
				action = scr.reset.action;
				transform = scr.reset.transform;
				damage = scr.reset.damage;
				mesh = scr.reset.mesh;
				fragments = scr.reset.fragments;
				shards = scr.reset.shards;
			}
			else if (scr.objectType == ObjectType.ConnectedCluster)
			{
				action = ((scr.reset.fragments == FragmentsResetType.Reuse) ? PostDemolitionType.DeactivateToReset : PostDemolitionType.DestroyWithDelay);
				transform = false;
				damage = false;
				mesh = scr.reset.mesh;
				fragments = scr.reset.fragments;
				shards = scr.reset.shards;
			}
			else
			{
				action = ((scr.reset.fragments == FragmentsResetType.Reuse) ? PostDemolitionType.DeactivateToReset : PostDemolitionType.DestroyWithDelay);
				transform = false;
				damage = false;
				mesh = MeshResetType.Destroy;
				fragments = FragmentsResetType.Destroy;
				shards = scr.reset.shards;
			}
			destroyDelay = scr.reset.destroyDelay;
		}

		public static void ResetRigid(RayfireRigid scr)
		{
			if (ObjectReuseState(scr))
			{
				int state = scr.fading.state;
				bool demolished = scr.limitations.demolished;
				if (scr.reset.transform)
				{
					RestoreTransform(scr);
				}
				if (scr.activation.activated)
				{
					scr.simulationType = SimType.Inactive;
				}
				Reset(scr);
				scr.StopAllCoroutines();
				if (state >= 1)
				{
					ResetFade(scr);
				}
				if (demolished)
				{
					ResetMeshDemolition(scr);
				}
				ResetClusterDemolition(scr);
				if (!scr.gameObject.activeSelf)
				{
					scr.gameObject.SetActive(value: true);
				}
				scr.StartAllCoroutines();
			}
		}

		private static void ResetFade(RayfireRigid scr)
		{
			if (scr.fading.fadeType == FadeType.SimExclude)
			{
				scr.physics.meshCollider.enabled = true;
			}
			else if (scr.fading.fadeType == FadeType.MoveDown)
			{
				scr.physics.meshCollider.enabled = true;
				scr.gameObject.SetActive(value: true);
			}
			else if (scr.fading.fadeType == FadeType.ScaleDown)
			{
				scr.transForm.localScale = scr.physics.initScale;
				scr.gameObject.SetActive(value: true);
			}
			else if (scr.fading.fadeType == FadeType.Destroy)
			{
				scr.gameObject.SetActive(value: true);
			}
		}

		private static void ResetMeshDemolition(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.Mesh)
			{
				if (scr.reset.mesh != MeshResetType.ReuseInputMesh)
				{
					scr.meshDemolition.rfShatter = null;
				}
				if (scr.reset.mesh != MeshResetType.ReuseFragmentMeshes)
				{
					scr.meshes = null;
				}
				if (scr.reset.fragments == FragmentsResetType.Reuse)
				{
					if (FragmentReuseState(scr))
					{
						ReuseFragments(scr);
					}
					else
					{
						DestroyFragments(scr);
					}
				}
				else if (scr.reset.fragments == FragmentsResetType.Destroy)
				{
					DestroyFragments(scr);
				}
				else if (scr.reset.fragments == FragmentsResetType.Preserve)
				{
					PreserveFragments(scr);
				}
			}
			scr.gameObject.SetActive(value: true);
		}

		private static void DestroyFragments(RayfireRigid scr)
		{
			if (!scr.HasFragments)
			{
				return;
			}
			int num = scr.fragments.Count((RayfireRigid t) => t != null);
			for (int num2 = scr.fragments.Count - 1; num2 >= 0; num2--)
			{
				if (scr.fragments[num2] != null)
				{
					DestroyParticles(scr.fragments[num2]);
					scr.fragments[num2].gameObject.SetActive(value: false);
					RayfireMan.DestroyGo(scr.fragments[num2].gameObject);
					if (scr.fragments[num2].rootParent != null)
					{
						scr.fragments[num2].rootParent.gameObject.SetActive(value: false);
						RayfireMan.DestroyGo(scr.fragments[num2].rootParent.gameObject);
					}
				}
			}
			scr.fragments = null;
			RayfireMan.inst.advancedDemolitionProperties.currentAmount -= num;
			if (scr.limitations.descendants.Count <= 0)
			{
				return;
			}
			int num3 = scr.limitations.descendants.Count((RayfireRigid t) => t != null);
			for (int i = 0; i < scr.limitations.descendants.Count; i++)
			{
				if (scr.limitations.descendants[i] != null)
				{
					scr.limitations.descendants[i].gameObject.SetActive(value: false);
					RayfireMan.DestroyGo(scr.limitations.descendants[i].gameObject);
					if (scr.limitations.descendants[i].rootParent != null)
					{
						scr.limitations.descendants[i].rootParent.gameObject.SetActive(value: false);
						RayfireMan.DestroyGo(scr.limitations.descendants[i].rootParent.gameObject);
					}
				}
			}
			scr.limitations.descendants.Clear();
			RayfireMan.inst.advancedDemolitionProperties.currentAmount -= num3;
		}

		private static void DestroyParticles(RayfireRigid scr)
		{
			if (scr.HasDebris)
			{
				for (int i = 0; i < scr.debrisList.Count; i++)
				{
					if (scr.debrisList[i].hostTm != null)
					{
						scr.debrisList[i].hostTm.gameObject.SetActive(value: false);
						RayfireMan.DestroyGo(scr.debrisList[i].hostTm.gameObject);
					}
				}
			}
			if (!scr.HasDust)
			{
				return;
			}
			for (int j = 0; j < scr.dustList.Count; j++)
			{
				if (scr.dustList[j].hostTm != null)
				{
					scr.dustList[j].hostTm.gameObject.SetActive(value: false);
					RayfireMan.DestroyGo(scr.dustList[j].hostTm.gameObject);
				}
			}
		}

		private static void ReuseFragments(RayfireRigid scr)
		{
			RayfireMan.inst.advancedDemolitionProperties.currentAmount -= scr.fragments.Count;
			if (scr.rootChild != null)
			{
				scr.rootChild.gameObject.SetActive(value: false);
				scr.rootChild.position = scr.transForm.position;
				scr.rootChild.rotation = scr.transForm.rotation;
			}
			for (int num = scr.fragments.Count - 1; num >= 0; num--)
			{
				DestroyParticles(scr.fragments[num]);
				scr.fragments[num].transForm.localScale = scr.fragments[num].physics.initScale;
				scr.fragments[num].transForm.position = scr.transForm.position + scr.pivots[num];
				scr.fragments[num].transForm.rotation = Quaternion.identity;
				if (scr.fragments[num].activation.activated)
				{
					scr.fragments[num].simulationType = SimType.Inactive;
				}
				if (scr.fragments[num].fading.state >= 1)
				{
					ResetFade(scr.fragments[num]);
				}
				Reset(scr.fragments[num]);
			}
			scr.limitations.descendants.Clear();
		}

		private static void PreserveFragments(RayfireRigid scr)
		{
			scr.fragments = null;
			scr.rootChild = null;
			scr.limitations.descendants.Clear();
		}

		private static void ResetClusterDemolition(RayfireRigid scr)
		{
			if (scr.objectType == ObjectType.ConnectedCluster || scr.objectType == ObjectType.NestedCluster)
			{
				RFBackupCluster.RestoreBackup(scr);
			}
		}

		private static bool ObjectReuseState(RayfireRigid scr)
		{
			if (scr.physics.exclude)
			{
				UnityEngine.Debug.Log("Demolished " + scr.objectType.ToString() + " reset not supported yet.");
				return false;
			}
			if (scr.objectType == ObjectType.Mesh || scr.objectType == ObjectType.ConnectedCluster || scr.objectType == ObjectType.NestedCluster)
			{
				return true;
			}
			return false;
		}

		private static bool FragmentReuseState(RayfireRigid scr)
		{
			if (scr.demolitionType == DemolitionType.ReferenceDemolition)
			{
				return false;
			}
			if (!scr.HasFragments)
			{
				return false;
			}
			if (scr.fragments.Any((RayfireRigid t) => t == null))
			{
				return false;
			}
			if (scr.fragments.Any((RayfireRigid t) => t.reset.toBeDestroyed))
			{
				return false;
			}
			if (scr.fragments.Any((RayfireRigid t) => t.limitations.demolished))
			{
				return false;
			}
			return true;
		}

		private static void RestoreTransform(RayfireRigid scr)
		{
			scr.transForm.localScale = scr.physics.initScale;
			scr.transForm.position = scr.physics.initPosition;
			scr.transForm.rotation = scr.physics.initRotation;
			scr.physics.velocity = Vector3.zero;
			if (scr.physics.rigidBody != null)
			{
				scr.physics.rigidBody.velocity = Vector3.zero;
				scr.physics.rigidBody.angularVelocity = Vector3.zero;
			}
		}

		private static void Reset(RayfireRigid scr)
		{
			scr.meshDemolition.StopRuntimeCaching();
			scr.activation.Reset();
			if (scr.restriction != null)
			{
				scr.restriction.Reset();
			}
			scr.limitations.Reset();
			scr.meshDemolition.Reset();
			scr.clusterDemolition.Reset();
			scr.fading.Reset();
			if (scr.reset.damage)
			{
				scr.damage.Reset();
			}
			RFPhysic.SetSimulationType(scr);
		}
	}
	[Serializable]
	public class RFRuntimeCaching
	{
		public CachingType type;

		[Range(2f, 300f)]
		public int frames;

		[Range(1f, 20f)]
		public int fragments;

		public bool skipFirstDemolition;

		[HideInInspector]
		public bool inProgress;

		[HideInInspector]
		public bool wasUsed;

		[HideInInspector]
		public bool stop;

		public RFRuntimeCaching()
		{
			type = CachingType.Disable;
			frames = 3;
			fragments = 4;
			skipFirstDemolition = false;
			inProgress = false;
			wasUsed = false;
			stop = false;
		}

		public static List<int> GetBatchByFrames(int frames, int amount)
		{
			int item = amount / frames;
			List<int> list = new List<int>();
			for (int i = 0; i < frames; i++)
			{
				list.Add(item);
			}
			int num = amount % frames;
			if (num > 0)
			{
				for (int j = 0; j < num; j++)
				{
					list[j]++;
				}
			}
			if (frames > amount)
			{
				for (int num2 = list.Count - 1; num2 >= 0; num2--)
				{
					if (list[num2] == 0)
					{
						list.RemoveAt(num2);
					}
				}
			}
			return list;
		}

		public static List<int> GetBatchByFragments(int fragments, int amount)
		{
			int num = amount / fragments;
			List<int> list = new List<int>();
			if (num > 0)
			{
				for (int i = 0; i < num; i++)
				{
					list.Add(fragments);
				}
			}
			int num2 = amount % fragments;
			if (num2 > 0)
			{
				list.Add(num2);
			}
			return list;
		}

		public static List<int> GetMarkedElements(int batchInd, List<int> batchAmount)
		{
			int num = 0;
			if (batchInd > 0)
			{
				for (int i = 0; i < batchInd; i++)
				{
					num += batchAmount[i];
				}
			}
			List<int> list = new List<int>();
			for (int j = 0; j < batchAmount[batchInd]; j++)
			{
				list.Add(j + num);
			}
			return list;
		}

		public static GameObject CreateTmRef(RayfireRigid rfScr)
		{
			GameObject gameObject = new GameObject("RFTempGo");
			gameObject.SetActive(value: false);
			gameObject.transform.position = rfScr.transForm.position;
			gameObject.transform.rotation = rfScr.transForm.rotation;
			gameObject.transform.localScale = rfScr.transForm.localScale;
			gameObject.transform.parent = RayfireMan.inst.transform;
			return gameObject;
		}
	}
	[Serializable]
	public class RFCustom
	{
		public enum RFPointCloudSourceType
		{
			ChildrenTransform = 4,
			TransformArray = 8,
			Vector3Array = 12
		}

		public enum RFPointCloudUseType
		{
			VolumePoints = 4,
			PointCloud = 12
		}

		public enum RFModifierType
		{
			None = 0,
			Splinters = 3,
			Slabs = 6
		}

		[Header("  Point Cloud")]
		[Space(2f)]
		public RFPointCloudSourceType source;

		[Space(2f)]
		public RFPointCloudUseType useAs;

		[Space(2f)]
		[Header("  Volume")]
		[Space(2f)]
		[Range(3f, 1000f)]
		public int amount;

		[Range(0.01f, 4f)]
		public float radius;

		[Header("  Preview")]
		[Space(2f)]
		public bool enable;

		[Range(0.01f, 0.4f)]
		public float size;

		[Header("  Arrays")]
		[Space(2f)]
		public Transform[] transforms;

		public Vector3[] vector3;

		[HideInInspector]
		public bool noPoints;

		public RFCustom()
		{
			source = RFPointCloudSourceType.ChildrenTransform;
			useAs = RFPointCloudUseType.PointCloud;
			amount = 100;
			radius = 1f;
			enable = true;
			size = 0.05f;
		}

		public RFCustom(RFCustom src)
		{
			source = src.source;
			useAs = src.useAs;
			amount = src.amount;
			radius = src.radius;
			enable = false;
			size = src.size;
			transforms = src.transforms;
			vector3 = src.vector3;
		}
	}
	public static class RFFragment
	{
		private static List<Mesh> meshListStatic = new List<Mesh>();

		private static List<Vector3> pivotListStatic = new List<Vector3>();

		private static List<Dictionary<int, int>> subIdsListStatic = new List<Dictionary<int, int>>();

		public static void CacheMeshes(ref Mesh[] meshes, ref Vector3[] pivots, ref List<RFDictionary> origSubMeshIdsRf, RayfireShatter scrShatter)
		{
			int shatterMode = GetShatterMode(scrShatter);
			Mesh demolitionMesh = GetDemolitionMesh(scrShatter);
			FragmentMode mode = scrShatter.mode;
			if (scrShatter.type == FragType.Decompose)
			{
				mode = FragmentMode.Editor;
			}
			if (scrShatter.type == FragType.Slices)
			{
				mode = FragmentMode.Runtime;
			}
			RFShatter rFShatter = SetShatter(shatterMode, demolitionMesh, scrShatter.transform, scrShatter.material, scrShatter.advanced.decompose, scrShatter.advanced.removeCollinear, scrShatter.advanced.seed, mode, scrShatter.advanced.inputPrecap, scrShatter.advanced.outputPrecap, scrShatter.advanced.removeDoubleFaces, scrShatter.advanced.excludeInnerFragments, scrShatter.advanced.elementSizeThreshold);
			if (rFShatter == null)
			{
				meshes = null;
				pivots = null;
				return;
			}
			int innerSubId = RFSurface.SetInnerSubId(scrShatter);
			SetFragmentProperties(rFShatter, scrShatter, null);
			if (scrShatter.type == FragType.Custom && scrShatter.custom.noPoints)
			{
				meshes = null;
				pivots = null;
				UnityEngine.Debug.Log("No custom ponts");
				return;
			}
			List<Dictionary<int, int>> subIds = new List<Dictionary<int, int>>();
			bool flag = Compute(shatterMode, rFShatter, scrShatter.transform, ref meshes, ref pivots, demolitionMesh, innerSubId, ref subIds, scrShatter);
			origSubMeshIdsRf = new List<RFDictionary>();
			for (int i = 0; i < subIds.Count; i++)
			{
				origSubMeshIdsRf.Add(new RFDictionary(subIds[i]));
			}
			if (!flag)
			{
				UnityEngine.Debug.Log("Bad shatter output mesh: " + scrShatter.name);
				return;
			}
			for (int j = 0; j < meshes.Length; j++)
			{
				meshes[j].name = scrShatter.name + "_" + j;
			}
		}

		public static bool InputMesh(RayfireRigid scr)
		{
			if (!SetRigidShatter(scr))
			{
				return false;
			}
			scr.meshDemolition.innerSubId = RFSurface.SetInnerSubId(scr);
			SetFragmentProperties(scr.meshDemolition.rfShatter, scr.meshDemolition.scrShatter, scr);
			return true;
		}

		private static bool SetRigidShatter(RayfireRigid scr)
		{
			if (scr.meshDemolition.rfShatter == null)
			{
				scr.cacheRotation = scr.transForm.rotation;
				scr.meshDemolition.shatterMode = GetShatterMode(scr.meshDemolition.scrShatter);
				scr.meshDemolition.mesh = GetDemolitionMesh(scr);
				scr.meshDemolition.rfShatter = SetShatter(scr.meshDemolition.shatterMode, scr.meshDemolition.mesh, scr.transform, scr.materials, scr.meshDemolition.properties.decompose, scr.meshDemolition.properties.removeCollinear, scr.meshDemolition.seed, FragmentMode.Runtime, preCap: false, remCap: false, remDbl: false);
			}
			if (scr.meshDemolition.rfShatter == null)
			{
				scr.limitations.demolitionShould = false;
				scr.meshDemolition.badMesh += 10;
				scr.meshDemolition.mesh = null;
				return false;
			}
			return true;
		}

		public static void CacheMeshesInst(ref Mesh[] meshes, ref Vector3[] pivots, ref List<RFDictionary> origSubMeshIdsRf, RayfireRigid scrRigid)
		{
			List<Dictionary<int, int>> subIds = new List<Dictionary<int, int>>();
			bool successState = Compute(scrRigid.meshDemolition.shatterMode, scrRigid.meshDemolition.rfShatter, scrRigid.transform, ref meshes, ref pivots, scrRigid.meshDemolition.mesh, scrRigid.meshDemolition.innerSubId, ref subIds, scrRigid);
			if (origSubMeshIdsRf == null)
			{
				origSubMeshIdsRf = new List<RFDictionary>();
			}
			else
			{
				origSubMeshIdsRf.Clear();
			}
			for (int i = 0; i < subIds.Count; i++)
			{
				origSubMeshIdsRf.Add(new RFDictionary(subIds[i]));
			}
			FinalCacheMeshes(ref meshes, scrRigid, successState);
		}

		public static void CacheMeshesMult(Transform tmSaved, ref List<Mesh> meshesList, ref List<Vector3> pivotsList, ref List<RFDictionary> subList, RayfireRigid scrRigid, List<int> batchAmount, int batchInd)
		{
			List<int> markedElements = RFRuntimeCaching.GetMarkedElements(batchInd, batchAmount);
			Mesh[] out_mesh = new Mesh[batchAmount.Count];
			Vector3[] pivots = new Vector3[batchAmount.Count];
			List<Dictionary<int, int>> OrigSubMeshIDs = new List<Dictionary<int, int>>();
			if (scrRigid.meshDemolition.rfShatter.SimpleCompute(tmSaved, ref out_mesh, ref pivots, scrRigid.meshDemolition.mesh, scrRigid.meshDemolition.innerSubId, ref OrigSubMeshIDs, markedElements, batchInd == 0) && out_mesh != null && out_mesh.Length != 0)
			{
				for (int i = 0; i < out_mesh.Length; i++)
				{
					out_mesh[i].RecalculateTangents();
					out_mesh[i].name = scrRigid.name + "_fr";
				}
				for (int j = 0; j < OrigSubMeshIDs.Count; j++)
				{
					subList.Add(new RFDictionary(OrigSubMeshIDs[j]));
				}
				meshesList.AddRange(out_mesh);
				pivotsList.AddRange(pivots);
			}
		}

		private static void FinalCacheMeshes(ref Mesh[] meshes, RayfireRigid scrRigid, bool successState)
		{
			if (!successState)
			{
				scrRigid.meshDemolition.badMesh++;
				UnityEngine.Debug.Log("Bad mesh: " + scrRigid.name);
				return;
			}
			for (int i = 0; i < meshes.Length; i++)
			{
				meshes[i].name = scrRigid.name + "_" + i;
			}
		}

		private static Mesh GetDemolitionMesh(RayfireRigid scr)
		{
			if (scr.skinnedMeshRend != null)
			{
				return RFMesh.BakeMesh(scr.skinnedMeshRend);
			}
			return scr.meshFilter.sharedMesh;
		}

		private static Mesh GetDemolitionMesh(RayfireShatter scr)
		{
			if (scr.skinnedMeshRend != null)
			{
				return RFMesh.BakeMesh(scr.skinnedMeshRend);
			}
			return scr.meshFilter.sharedMesh;
		}

		public static void SliceMeshes(ref Mesh[] meshes, ref Vector3[] pivots, ref List<RFDictionary> origSubMeshIdsRf, RayfireRigid scr, List<Vector3> sliceData)
		{
			scr.meshDemolition.mesh = GetDemolitionMesh(scr);
			RFShatter rFShatter = SetShatter(2, scr.meshDemolition.mesh, scr.transform, scr.materials, decompose: true, scr.meshDemolition.properties.removeCollinear, scr.meshDemolition.seed, FragmentMode.Runtime, preCap: true, remCap: false, remDbl: false);
			if (rFShatter == null)
			{
				meshes = null;
				pivots = null;
				scr.meshDemolition.badMesh++;
				return;
			}
			int innerSubId = RFSurface.SetInnerSubId(scr);
			List<Vector3> list = new List<Vector3>();
			List<Vector3> list2 = new List<Vector3>();
			int num;
			for (num = 0; num < sliceData.Count; num++)
			{
				list.Add(sliceData[num]);
				list2.Add(sliceData[num + 1]);
				num++;
			}
			rFShatter.SetBricksParams(list.ToArray(), list2.ToArray(), scr.transform);
			List<Dictionary<int, int>> subIds = new List<Dictionary<int, int>>();
			bool flag = Compute(2, rFShatter, scr.transform, ref meshes, ref pivots, scr.meshDemolition.mesh, innerSubId, ref subIds, scr.gameObject);
			origSubMeshIdsRf = new List<RFDictionary>();
			for (int i = 0; i < subIds.Count; i++)
			{
				origSubMeshIdsRf.Add(new RFDictionary(subIds[i]));
			}
			if (!flag)
			{
				scr.meshDemolition.badMesh++;
				UnityEngine.Debug.Log("Bad mesh: " + scr.name, scr.gameObject);
				return;
			}
			for (int j = 0; j < meshes.Length; j++)
			{
				meshes[j].name = scr.name + "_" + j;
			}
		}

		private static bool Compute(int shatterMode, RFShatter shatter, Transform tm, ref Mesh[] meshes, ref Vector3[] pivots, Mesh mesh, int innerSubId, ref List<Dictionary<int, int>> subIds, UnityEngine.Object obj, List<int> markedElements = null)
		{
			if (!((shatterMode == 0) ? shatter.Compute(tm, ref meshes, ref pivots, mesh, innerSubId, ref subIds) : shatter.SimpleCompute(tm, ref meshes, ref pivots, mesh, innerSubId, ref subIds, markedElements)))
			{
				meshes = null;
				pivots = null;
				subIds = new List<Dictionary<int, int>>();
				return false;
			}
			if (meshes == null)
			{
				UnityEngine.Debug.Log("Null mesh", obj);
				meshes = null;
				pivots = null;
				subIds = new List<Dictionary<int, int>>();
				return false;
			}
			if (EmptyMeshState(meshes))
			{
				for (int i = 0; i < meshes.Length; i++)
				{
					if (meshes[i].vertexCount > 2)
					{
						meshListStatic.Add(meshes[i]);
						pivotListStatic.Add(pivots[i]);
						subIdsListStatic.Add(subIds[i]);
					}
				}
				pivots = pivotListStatic.ToArray();
				meshes = meshListStatic.ToArray();
				subIds = subIdsListStatic;
				meshListStatic.Clear();
				pivotListStatic.Clear();
				subIdsListStatic.Clear();
				UnityEngine.Debug.Log("Empty Mesh", obj);
			}
			if (meshes.Length <= 1)
			{
				UnityEngine.Debug.Log("Mesh amount " + meshes.Length, obj);
				meshes = null;
				pivots = null;
				subIds = new List<Dictionary<int, int>>();
				return false;
			}
			for (int j = 0; j < meshes.Length; j++)
			{
				meshes[j].RecalculateTangents();
			}
			return true;
		}

		private static int GetShatterMode(RayfireShatter scrShatter = null)
		{
			if (scrShatter == null)
			{
				return 1;
			}
			if (scrShatter.type == FragType.Slices)
			{
				return 2;
			}
			if (scrShatter.type == FragType.Decompose)
			{
				return 1;
			}
			int result = scrShatter.shatterMode;
			if (scrShatter.type == FragType.Custom)
			{
				result = 0;
			}
			if (scrShatter.type == FragType.Tets)
			{
				result = 0;
			}
			if (scrShatter.clusters.enable)
			{
				result = 0;
			}
			return result;
		}

		private static bool EmptyMeshState(Mesh[] meshes)
		{
			for (int i = 0; i < meshes.Length; i++)
			{
				if (meshes[i].vertexCount <= 2)
				{
					return true;
				}
			}
			return false;
		}

		private static void SetFragmentProperties(RFShatter shatter, RayfireShatter scrSh, RayfireRigid scrRigid)
		{
			if (scrRigid != null && scrSh == null)
			{
				int num = UnityEngine.Random.Range(0, scrRigid.meshDemolition.amount * scrRigid.meshDemolition.variation / 100);
				scrRigid.meshDemolition.totalAmount = scrRigid.meshDemolition.amount + num;
				SetVoronoi(shatter, scrRigid.meshDemolition.totalAmount, scrRigid.transform, scrRigid.limitations.contactVector3, scrRigid.meshDemolition.contactBias);
				return;
			}
			if (scrRigid != null && scrSh != null)
			{
				scrSh.centerPosition = scrRigid.transForm.InverseTransformPoint(scrRigid.limitations.contactVector3);
				if (scrSh.type == FragType.Voronoi)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.voronoi.Amount;
				}
				else if (scrSh.type == FragType.Splinters)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.splinters.Amount;
				}
				else if (scrSh.type == FragType.Slabs)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.slabs.Amount;
				}
				else if (scrSh.type == FragType.Radial)
				{
					scrRigid.meshDemolition.totalAmount = scrSh.radial.rings * scrSh.radial.rays;
				}
			}
			if (scrSh != null)
			{
				Vector3 centerPos = scrSh.transform.TransformPoint(scrSh.centerPosition);
				if (scrSh.type == FragType.Voronoi)
				{
					SetVoronoi(shatter, scrSh.voronoi.Amount, scrSh.transform, centerPos, scrSh.voronoi.centerBias);
				}
				else if (scrSh.type == FragType.Splinters)
				{
					SetSplinters(shatter, scrSh.splinters, scrSh.transform, centerPos, scrSh.splinters.centerBias);
				}
				else if (scrSh.type == FragType.Slabs)
				{
					SetSlabs(shatter, scrSh.slabs, scrSh.transform, centerPos, scrSh.splinters.centerBias);
				}
				else if (scrSh.type == FragType.Radial)
				{
					SetRadial(shatter, scrSh.radial, scrSh.transform, centerPos, scrSh.centerDirection);
				}
				else if (scrSh.type == FragType.Custom)
				{
					SetCustom(shatter, scrSh.custom, scrSh.transform, scrSh.meshFilter, scrSh.bound, scrSh.splinters, scrSh.slabs, scrSh.advanced.seed);
				}
				else if (scrSh.type == FragType.Slices)
				{
					SetSlices(shatter, scrSh.transform, scrSh.slice);
				}
				else if (scrSh.type == FragType.Tets)
				{
					SetTet(shatter, scrSh.bound, scrSh.tets);
				}
				else if (scrSh.type == FragType.Decompose)
				{
					SetDecompose(shatter);
				}
				if (scrSh.clusters.enable)
				{
					SetClusters(shatter, scrSh.clusters);
				}
			}
		}

		private static RFShatter SetShatter(int shatterMode, Mesh mesh, Transform transform, RFSurface interior, bool decompose, bool deleteCol, int seed = 1, FragmentMode mode = FragmentMode.Runtime, bool preCap = true, bool remCap = false, bool remDbl = true, bool exInside = false, int percSize = 3)
		{
			RFShatter rFShatter = new RFShatter((RFShatter.RFShatterMode)shatterMode, enable_fragmenting: true);
			if (mode == FragmentMode.Editor)
			{
				float sizeFilter = mesh.bounds.size.magnitude * (float)percSize / 100f;
				SetShatterEditorMode(rFShatter, sizeFilter, preCap, remCap, remDbl, exInside);
			}
			else
			{
				SetShatterRuntimeMode(rFShatter);
			}
			rFShatter.DecomposeResultMesh(decompose);
			rFShatter.SetFragmentParameter(RFShatter.FragmentParams.seed, seed);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.pre_weld_threshold, 0.001f);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.delete_collinear, deleteCol);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.maping_scale, interior.mappingScale);
			rFShatter.SetGeneralParameter(RFShatter.GeneralParams.restore_normals, value: true);
			if (!rFShatter.SetInputMesh(transform, mesh))
			{
				UnityEngine.Debug.Log("Bad input mesh: " + transform.name, transform.gameObject);
				return null;
			}
			return rFShatter;
		}

		private static void SetShatterEditorMode(RFShatter shatter, float sizeFilter, bool preCap, bool remCap, bool remDbl, bool exInside)
		{
			shatter.EditorMode(enable: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_pre_cap, preCap);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_remove_cap_faces, remCap);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_separate_only, value: false);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_elliminateCollinears_maxIterFuse, 150);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_min_bbox_diag_size_filter, sizeFilter);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_exclude_inside, exInside);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_remove_double_faces, remDbl);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_remove_inversed_double_faces, remDbl);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.minFacesFilter, 0);
		}

		private static void SetShatterRuntimeMode(RFShatter shatter)
		{
			shatter.EditorMode(enable: false);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.pre_shatter, value: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.pre_cap, value: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.pre_weld, value: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.minFacesFilter, 3);
		}

		private static void SetVoronoi(RFShatter shatter, int numFragments, Transform tm, Vector3 centerPos, float centerBias)
		{
			int num = numFragments;
			if (num < 1)
			{
				num = 1;
			}
			if (num > 20000)
			{
				num = 2;
			}
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_num, num);
			if (centerBias > 0f)
			{
				shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_bias, centerBias);
				shatter.SetCenterParameter(centerPos, tm, Vector3.forward);
			}
		}

		private static void SetSplinters(RFShatter shatter, RFSplinters splint, Transform tm, Vector3 centerPos, float centerBias)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_num, splint.Amount);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_bias, centerBias);
			shatter.SetCenterParameter(centerPos, tm, Vector3.forward);
			SetStretching(shatter, splint.axis, splint.strength, FragType.Splinters);
		}

		private static void SetSlabs(RFShatter shatter, RFSplinters slabs, Transform tm, Vector3 centerPos, float centerBias)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_num, slabs.Amount);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_irr_bias, centerBias);
			shatter.SetCenterParameter(centerPos, tm, Vector3.forward);
			SetStretching(shatter, slabs.axis, slabs.strength, FragType.Slabs);
		}

		private static void SetRadial(RFShatter shatter, RFRadial radial, Transform tm, Vector3 centerPos, Quaternion centerDirection)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 2);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_radius, radial.radius);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_divergence, radial.divergence);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_restrict, radial.restrictToPlane);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_count, radial.rings);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_focus, radial.focus);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_strenght, radial.focusStr);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rings_random, radial.randomRings);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rays_count, radial.rays);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rays_random, radial.randomRays);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_rad_rays_twist, radial.twist);
			Vector3 vector = DirectionAxis(radial.centerAxis);
			Vector3 normal = tm.rotation * centerDirection * vector;
			shatter.SetCenterParameter(centerPos, tm, normal);
		}

		private static void SetCustom(RFShatter shatter, RFCustom custom, Transform tm, MeshFilter mf, Bounds bound, RFSplinters splint, RFSplinters slabs, int seed)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 1);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.voronoi_type, 1);
			List<Vector3> customPointCLoud = GetCustomPointCLoud(custom, tm, seed, bound);
			shatter.SetVoroCustomPoints(customPointCLoud.ToArray(), tm);
		}

		private static void SetSlices(RFShatter shatter, Transform tm, RFSlice slices)
		{
			List<Transform> list = new List<Transform>();
			for (int i = 0; i < slices.sliceList.Count; i++)
			{
				if (slices.sliceList[i] != null)
				{
					list.Add(slices.sliceList[i]);
				}
			}
			if (list.Count != 0)
			{
				Vector3[] points = list.Select((Transform t) => t.position).ToArray();
				Vector3[] normals = list.Select((Transform t) => slices.Axis(t)).ToArray();
				shatter.SetBricksParams(points, normals, tm);
			}
		}

		private static void SetTet(RFShatter shatter, Bounds bounds, RFTets tets)
		{
			shatter.SetFragmentParameter(RFShatter.FragmentParams.type, 0);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.tetra_type, (int)tets.lattice);
			float num = bounds.size.x;
			if (bounds.size.y > num)
			{
				num = bounds.size.y;
			}
			if (bounds.size.z > num)
			{
				num = bounds.size.z;
			}
			if (num == 0f)
			{
				num = 0.01f;
			}
			Vector3Int vector3Int = new Vector3Int((int)Mathf.Ceil(bounds.size.x / num * (float)tets.density), (int)Mathf.Ceil(bounds.size.y / num * (float)tets.density), (int)Mathf.Ceil(bounds.size.z / num * (float)tets.density));
			if (vector3Int.x > 30)
			{
				vector3Int.x = 30;
			}
			else if (vector3Int.x < 1)
			{
				vector3Int.x = 1;
			}
			if (vector3Int.y > 30)
			{
				vector3Int.y = 30;
			}
			else if (vector3Int.y < 1)
			{
				vector3Int.y = 1;
			}
			if (vector3Int.z > 30)
			{
				vector3Int.z = 30;
			}
			else if (vector3Int.z < 1)
			{
				vector3Int.z = 1;
			}
			shatter.SetPoint3Parameter(10011, vector3Int);
			shatter.SetPoint3Parameter(10010, vector3Int);
			shatter.SetFragmentParameter(RFShatter.FragmentParams.tetra_noise, tets.noise);
		}

		private static void SetDecompose(RFShatter shatter)
		{
			shatter.SetGeneralParameter(RFShatter.GeneralParams.editor_mode_separate_only, value: true);
		}

		public static List<Vector3> GetCustomPointCLoud(RFCustom custom, Transform tm, int seed, Bounds bound)
		{
			List<Vector3> customInputCloud = GetCustomInputCloud(custom, tm);
			List<Vector3> customBoundPoints = GetCustomBoundPoints(GetCustomOutputCloud(custom, customInputCloud, seed, bound), bound);
			if (customBoundPoints.Count <= 1)
			{
				custom.noPoints = true;
			}
			return customBoundPoints;
		}

		private static List<Vector3> GetCustomInputCloud(RFCustom custom, Transform tm)
		{
			custom.noPoints = false;
			List<Vector3> list = new List<Vector3>();
			if (custom.source == RFCustom.RFPointCloudSourceType.ChildrenTransform)
			{
				if (tm.childCount > 0)
				{
					for (int i = 0; i < tm.childCount; i++)
					{
						list.Add(tm.GetChild(i).position);
					}
				}
			}
			else if (custom.source == RFCustom.RFPointCloudSourceType.TransformArray)
			{
				if (custom.transforms != null && custom.transforms.Length != 0)
				{
					for (int j = 0; j < custom.transforms.Length; j++)
					{
						if (custom.transforms[j] != null)
						{
							list.Add(custom.transforms[j].position);
						}
					}
				}
			}
			else if (custom.source == RFCustom.RFPointCloudSourceType.Vector3Array && custom.vector3 != null && custom.vector3.Length != 0)
			{
				for (int k = 0; k < custom.vector3.Length; k++)
				{
					list.Add(custom.vector3[k]);
				}
			}
			return list;
		}

		private static List<Vector3> GetCustomOutputCloud(RFCustom custom, List<Vector3> inputPoints, int seed, Bounds bound)
		{
			if (custom.useAs == RFCustom.RFPointCloudUseType.PointCloud)
			{
				return inputPoints;
			}
			if (custom.useAs == RFCustom.RFPointCloudUseType.VolumePoints)
			{
				if (inputPoints.Count == 0)
				{
					return inputPoints;
				}
				int num = custom.amount / inputPoints.Count;
				int num2 = seed;
				List<Vector3> list = new List<Vector3>();
				for (int i = 0; i < inputPoints.Count; i++)
				{
					num2++;
					UnityEngine.Random.InitState(num2);
					for (int j = 0; j < num; j++)
					{
						Vector3 vector = RandomPointInRadius(inputPoints[i], custom.radius);
						if (!bound.Contains(vector))
						{
							vector = RandomPointInRadius(inputPoints[i], custom.radius);
							if (!bound.Contains(vector))
							{
								vector = RandomPointInRadius(inputPoints[i], custom.radius);
							}
						}
						list.Add(vector);
					}
				}
				return list;
			}
			return inputPoints;
		}

		private static List<Vector3> GetCustomBoundPoints(List<Vector3> inputPoints, Bounds bound)
		{
			for (int num = inputPoints.Count - 1; num >= 0; num--)
			{
				if (!bound.Contains(inputPoints[num]))
				{
					inputPoints.RemoveAt(num);
				}
			}
			return inputPoints;
		}

		private static Vector3 RandomVector()
		{
			return new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f));
		}

		private static Vector3 RandomPointInRadius(Vector3 point, float radius)
		{
			return RandomVector() * UnityEngine.Random.Range(0f, radius) + point;
		}

		private static void SetClusters(RFShatter shatter, RFShatterCluster gluing)
		{
			shatter.InitClustering(enable: true);
			shatter.SetClusterParameter(RFShatter.ClusterParams.enabled, value: true);
			shatter.SetClusterParameter(RFShatter.ClusterParams.by_pcloud_count, gluing.count);
			shatter.SetClusterParameter(RFShatter.ClusterParams.options_seed, gluing.seed);
			shatter.SetClusterParameter(RFShatter.ClusterParams.preview_scale, 100f);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_layers_count, gluing.layers);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_count, gluing.amount);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_scale, gluing.scale);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_min, gluing.min);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_max, gluing.max);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_tessellate, value: false);
			shatter.SetClusterParameter(RFShatter.ClusterParams.debris_remove, value: false);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.glue, value: true);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.glue_weld_threshold, 0.001f);
			shatter.SetGeneralParameter(RFShatter.GeneralParams.relax, gluing.relax);
		}

		private static void SetStretching(RFShatter shatter, AxisType axis, float strength, FragType fragType)
		{
			Vector3 vector = DirectionAxis(axis);
			if (fragType == FragType.Slabs)
			{
				Vector3 vector2 = default(Vector3);
				if (vector.x <= 0f)
				{
					vector2.x = 1f;
				}
				if (vector.x >= 1f)
				{
					vector2.x = 0f;
				}
				if (vector.y <= 0f)
				{
					vector2.y = 1f;
				}
				if (vector.y >= 1f)
				{
					vector2.y = 0f;
				}
				if (vector.z <= 0f)
				{
					vector2.z = 1f;
				}
				if (vector.z >= 1f)
				{
					vector2.z = 0f;
				}
				vector = vector2;
			}
			shatter.SetPoint3Parameter(10008, vector * Mathf.Lerp(40f, 99f, strength));
		}

		private static Vector3 DirectionAxis(AxisType axisType)
		{
			return axisType switch
			{
				AxisType.YGreen => Vector3.up, 
				AxisType.ZBlue => Vector3.forward, 
				_ => Vector3.right, 
			};
		}

		public static void RescaleMesh(Mesh mesh, float scale)
		{
			Vector3[] vertices = mesh.vertices;
			for (int i = 0; i < vertices.Length; i++)
			{
				vertices[i] /= scale;
			}
			mesh.SetVertices(vertices.ToList());
		}
	}
	[Serializable]
	public class RFMeshExport
	{
		public enum MeshExportType
		{
			LastFragments = 0,
			Children = 3
		}

		public MeshExportType source;

		public string suffix = "_frags";
	}
	[Serializable]
	public class RFShatterAdvanced
	{
		[Header("  Common")]
		[Space(2f)]
		[Range(0f, 100f)]
		public int seed;

		public bool decompose;

		public bool removeCollinear;

		public bool copyComponents;

		[Header("  Editor Mode")]
		[Space(2f)]
		[UnityEngine.Tooltip("Create extra triangles to connect open edges and close mesh volume.")]
		public bool inputPrecap;

		[Space(1f)]
		[UnityEngine.Tooltip("Keep or Delete fragment's faces created by Input Precap.")]
		public bool outputPrecap;

		[Space(1f)]
		[UnityEngine.Tooltip("Delete faces which overlap with each other.")]
		public bool removeDoubleFaces;

		[Space(1f)]
		[UnityEngine.Tooltip("Delete all inner fragments which has no outer surface.")]
		public bool excludeInnerFragments;

		[Space(1f)]
		[UnityEngine.Tooltip("Measures in percents relative to original object size. Do not fragment elements with size less than this value.")]
		[Range(1f, 100f)]
		public int elementSizeThreshold;

		[Header("  Limitations")]
		[Space(2f)]
		public bool vertexLimitation;

		[Space(1f)]
		[Range(100f, 1900f)]
		public int vertexAmount;

		public RFShatterAdvanced()
		{
			seed = 1;
			decompose = true;
			removeCollinear = false;
			copyComponents = false;
			inputPrecap = true;
			outputPrecap = false;
			removeDoubleFaces = true;
			excludeInnerFragments = false;
			elementSizeThreshold = 5;
			vertexLimitation = false;
			vertexAmount = 300;
		}

		public RFShatterAdvanced(RFShatterAdvanced src)
		{
			seed = src.seed;
			decompose = src.decompose;
			removeCollinear = src.removeCollinear;
			copyComponents = src.copyComponents;
			inputPrecap = src.inputPrecap;
			outputPrecap = src.outputPrecap;
			removeDoubleFaces = src.removeDoubleFaces;
			excludeInnerFragments = src.excludeInnerFragments;
			elementSizeThreshold = src.elementSizeThreshold;
			vertexLimitation = src.vertexLimitation;
			vertexAmount = src.vertexAmount;
		}
	}
	[Serializable]
	public class RFSurface
	{
		[Header("  Inner surface")]
		[Space(1f)]
		[UnityEngine.Tooltip("Defines material for fragment's inner surface.")]
		public Material innerMaterial;

		[Space(1f)]
		[UnityEngine.Tooltip("Defines mapping scale for inner surface.")]
		[Range(0.01f, 2f)]
		public float mappingScale;

		[Header("  Outer surface")]
		[Space(1f)]
		public Material outerMaterial;

		[HideInInspector]
		public bool needNewMat;

		public RFSurface()
		{
			innerMaterial = null;
			mappingScale = 0.1f;
			needNewMat = false;
			outerMaterial = null;
		}

		public void CopyFrom(RFSurface interior)
		{
			innerMaterial = interior.innerMaterial;
			mappingScale = interior.mappingScale;
			needNewMat = interior.needNewMat;
			outerMaterial = interior.outerMaterial;
		}

		public static void SetMaterial(List<RFDictionary> origSubMeshIdsRF, Material[] sharedMaterials, RFSurface interior, MeshRenderer targetRend, int i, int amount)
		{
			if (origSubMeshIdsRF == null || origSubMeshIdsRF.Count != amount)
			{
				return;
			}
			Material[] array = new Material[origSubMeshIdsRF[i].values.Count];
			for (int j = 0; j < origSubMeshIdsRF[i].values.Count; j++)
			{
				int num = origSubMeshIdsRF[i].values[j];
				if (num < sharedMaterials.Length)
				{
					if (interior.outerMaterial == null)
					{
						array[j] = sharedMaterials[num];
					}
					else
					{
						array[j] = interior.outerMaterial;
					}
				}
				else
				{
					array[j] = interior.innerMaterial;
				}
			}
			targetRend.sharedMaterials = array;
		}

		public static int SetInnerSubId(RayfireRigid scr)
		{
			if (scr.materials.innerMaterial == null)
			{
				return 0;
			}
			Material[] array = ((scr.skinnedMeshRend != null) ? scr.skinnedMeshRend.sharedMaterials : scr.meshRenderer.sharedMaterials);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == scr.materials.innerMaterial)
				{
					return i;
				}
			}
			return -1;
		}

		public static int SetInnerSubId(RayfireShatter scr)
		{
			if (scr.material.innerMaterial == null)
			{
				return 0;
			}
			Material[] array = ((scr.skinnedMeshRend != null) ? scr.skinnedMeshRend.sharedMaterials : scr.meshRenderer.sharedMaterials);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == scr.material.innerMaterial)
				{
					return i;
				}
			}
			return -1;
		}
	}
	[AddComponentMenu("RayFire/Rayfire Activator")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-activator-component/")]
	public class RayfireActivator : MonoBehaviour
	{
		public enum ActivationType
		{
			OnEnter,
			OnExit
		}

		public enum AnimationType
		{
			ByPositionList,
			ByStaticLine,
			ByDynamicLine
		}

		public enum GizmoType
		{
			Sphere,
			Box,
			Collider
		}

		[Header("  Gizmo")]
		[Space(3f)]
		public GizmoType gizmoType;

		[Space(2f)]
		[Range(0.1f, 100f)]
		public float sphereRadius = 5f;

		[Space(2f)]
		public Vector3 boxSize = new Vector3(5f, 2f, 5f);

		[Header("  Activation")]
		[Space(3f)]
		public ActivationType type;

		[Space(2f)]
		[Range(0f, 100f)]
		public float delay;

		[Space(2f)]
		public bool demolishCluster;

		[Header("  Animation")]
		[Space(3f)]
		[Range(0.1f, 100f)]
		public float duration = 3f;

		[Space(2f)]
		[Range(1f, 50f)]
		public float scaleAnimation = 1f;

		[Space(2f)]
		public AnimationType positionAnimation;

		[Space(2f)]
		public LineRenderer line;

		[Space(2f)]
		public List<Vector3> positionList;

		[HideInInspector]
		public bool showGizmo = true;

		private bool animating;

		private float pathRatio;

		private float lineLength;

		private List<float> checkpoints = new List<float>();

		private float delta;

		private float deltaRatioStep;

		private float distDeltaStep;

		private float distRatio;

		private float timePassed;

		private int activeSegment;

		private Vector3 positionStart;

		private Vector3 scaleStart;

		private void Start()
		{
		}

		private void Awake()
		{
			ColliderCheck();
			positionStart = base.transform.position;
			scaleStart = base.transform.localScale;
		}

		private void OnTriggerEnter(Collider coll)
		{
			if (type == ActivationType.OnEnter)
			{
				ActivationCheck(coll);
			}
		}

		private void OnTriggerExit(Collider coll)
		{
			if (type == ActivationType.OnExit)
			{
				ActivationCheck(coll);
			}
		}

		private void ActivationCheck(Collider coll)
		{
			RayfireRigid rayfireRigid = ((coll.attachedRigidbody == null) ? coll.GetComponent<RayfireRigid>() : coll.attachedRigidbody.GetComponent<RayfireRigid>());
			if (rayfireRigid == null)
			{
				return;
			}
			if (rayfireRigid.activation.byActivator && (rayfireRigid.simulationType == SimType.Inactive || rayfireRigid.simulationType == SimType.Kinematic))
			{
				if (delay <= 0f)
				{
					rayfireRigid.Activate();
				}
				else
				{
					StartCoroutine(DelayedActivationCor(rayfireRigid));
				}
			}
			if (rayfireRigid.objectType == ObjectType.ConnectedCluster && demolishCluster)
			{
				if (delay <= 0f)
				{
					RFDemolitionCluster.DemolishConnectedCluster(rayfireRigid, new Collider[1] { coll });
				}
				else
				{
					StartCoroutine(DelayedClusterCor(rayfireRigid, coll));
				}
			}
		}

		private IEnumerator DelayedActivationCor(RayfireRigid rigid)
		{
			yield return new WaitForSeconds(delay);
			if (rigid != null)
			{
				rigid.Activate();
			}
		}

		private IEnumerator DelayedClusterCor(RayfireRigid rigid, Collider coll)
		{
			yield return new WaitForSeconds(delay);
			if (rigid != null && coll != null)
			{
				RFDemolitionCluster.DemolishConnectedCluster(rigid, new Collider[1] { coll });
			}
		}

		private void ColliderCheck()
		{
			if (gizmoType == GizmoType.Sphere)
			{
				SphereCollider sphereCollider = base.gameObject.AddComponent<SphereCollider>();
				sphereCollider.isTrigger = true;
				sphereCollider.radius = sphereRadius;
			}
			if (gizmoType == GizmoType.Box)
			{
				BoxCollider boxCollider = base.gameObject.AddComponent<BoxCollider>();
				boxCollider.isTrigger = true;
				boxCollider.size = boxSize;
			}
			if (gizmoType == GizmoType.Collider)
			{
				Collider[] components = GetComponents<Collider>();
				if (components.Length == 0)
				{
					UnityEngine.Debug.Log(base.gameObject.name + " has no activation collider", base.gameObject);
				}
				Collider[] array = components;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].isTrigger = true;
				}
			}
		}

		public void TriggerAnimation()
		{
			if (!animating)
			{
				SetAnimation();
				if (positionList.Count < 2 && scaleAnimation == 1f)
				{
					UnityEngine.Debug.Log("Position list is empty and scale is not animated");
				}
				else
				{
					StartCoroutine(AnimationCor());
				}
			}
		}

		private void SetAnimation()
		{
			if (positionAnimation == AnimationType.ByStaticLine || positionAnimation == AnimationType.ByDynamicLine)
			{
				SetWorldPointsByLine();
			}
			SetCheckPoints();
		}

		private void SetWorldPointsByLine()
		{
			if (line == null)
			{
				UnityEngine.Debug.Log("Path line is not defined");
				return;
			}
			positionList = new List<Vector3>();
			for (int i = 0; i < line.positionCount; i++)
			{
				positionList.Add(line.transform.TransformPoint(line.GetPosition(i)));
			}
			if (line.loop)
			{
				positionList.Add(positionList[0]);
			}
		}

		private void SetCheckPoints()
		{
			if (positionList.Count < 2)
			{
				return;
			}
			lineLength = 0f;
			List<float> list = new List<float>();
			if (positionList.Count >= 2)
			{
				for (int i = 0; i < positionList.Count - 1; i++)
				{
					float num = Vector3.Distance(positionList[i], positionList[i + 1]);
					list.Add(num);
					lineLength += num;
				}
			}
			float num2 = 0f;
			checkpoints = new List<float>();
			for (int j = 0; j < list.Count; j++)
			{
				float num3 = list[j] / lineLength * 100f;
				checkpoints.Add(num2);
				num2 += num3;
			}
			checkpoints.Add(100f);
		}

		private IEnumerator AnimationCor()
		{
			if (animating)
			{
				yield break;
			}
			animating = true;
			if (positionList.Count >= 2)
			{
				base.transform.position = positionList[0];
			}
			while (timePassed < duration)
			{
				if (!animating)
				{
					yield break;
				}
				if (positionAnimation == AnimationType.ByDynamicLine)
				{
					SetAnimation();
				}
				delta = Time.deltaTime;
				timePassed += delta;
				if (positionList.Count >= 2)
				{
					deltaRatioStep = delta / duration;
					distDeltaStep = lineLength * deltaRatioStep;
					distRatio = distDeltaStep / lineLength * 100f;
					pathRatio += distRatio;
					activeSegment = GetSegment(pathRatio);
					float t = (checkpoints[activeSegment + 1] - pathRatio) / (checkpoints[activeSegment + 1] - checkpoints[activeSegment]);
					Vector3 position = Vector3.Lerp(positionList[activeSegment + 1], positionList[activeSegment], t);
					base.transform.position = position;
				}
				if (scaleAnimation > 1f)
				{
					float t2 = timePassed / duration;
					Vector3 localScale = Vector3.Lerp(b: new Vector3(scaleAnimation, scaleAnimation, scaleAnimation), a: scaleStart, t: t2);
					base.transform.localScale = localScale;
				}
				yield return null;
			}
			ResetData();
		}

		private int GetSegment(float ration)
		{
			if (checkpoints.Count > 2)
			{
				for (int i = 0; i < checkpoints.Count - 1; i++)
				{
					if (ration > checkpoints[i] && ration < checkpoints[i + 1])
					{
						return i;
					}
				}
				return checkpoints.Count - 2;
			}
			return 0;
		}

		private void ResetData()
		{
			animating = false;
			pathRatio = 0f;
			lineLength = 0f;
			checkpoints.Clear();
			delta = 0f;
			deltaRatioStep = 0f;
			distDeltaStep = 0f;
			distRatio = 0f;
			timePassed = 0f;
			activeSegment = 0;
		}

		public void StopAnimation()
		{
			animating = false;
		}

		public void ResetAnimation()
		{
			ResetData();
			base.transform.position = positionStart;
		}

		public void AddPosition(Vector3 newPos)
		{
			if (positionList == null)
			{
				positionList = new List<Vector3>();
			}
			if (positionList.Count > 0 && newPos == positionList[positionList.Count - 1])
			{
				UnityEngine.Debug.Log("Activator at the same position");
			}
			else if (positionList.Count == 0 || newPos != positionList[positionList.Count - 1])
			{
				positionList.Add(newPos);
			}
		}
	}
	[AddComponentMenu("RayFire/Rayfire Blade")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-blade-component/")]
	public class RayfireBlade : MonoBehaviour
	{
		public enum CutType
		{
			Enter,
			Exit,
			EnterExit
		}

		public enum ActionType
		{
			Slice,
			Demolish
		}

		[Header("  Properties")]
		[Space(2f)]
		public ActionType actionType;

		public CutType onTrigger = CutType.Exit;

		[Header("  Slicing")]
		[Space(2f)]
		public PlaneType sliceType;

		public GameObject target;

		public List<GameObject> targets;

		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public Vector3[] enterPlane;

		[HideInInspector]
		public Vector3[] exitPlane;

		[HideInInspector]
		public Collider colLider;

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		public RFSliceEvent sliceEvent = new RFSliceEvent();

		private void Awake()
		{
			DefineComponents();
		}

		private void DefineComponents()
		{
			transForm = GetComponent<Transform>();
			colLider = GetComponent<Collider>();
			if (colLider == null)
			{
				colLider = base.gameObject.AddComponent<MeshCollider>();
			}
			if (colLider is MeshCollider)
			{
				((MeshCollider)colLider).convex = true;
			}
			colLider.isTrigger = true;
		}

		private void OnTriggerEnter(Collider col)
		{
			TriggerEnter(col);
		}

		private void OnTriggerExit(Collider col)
		{
			TriggerExit(col);
		}

		private void TriggerEnter(Collider col)
		{
			if (onTrigger == CutType.Enter)
			{
				if (actionType == ActionType.Slice)
				{
					Slice(col.gameObject, GetSlicePlane());
				}
				else
				{
					Demolish(col.gameObject);
				}
			}
			else if (onTrigger == CutType.EnterExit && actionType == ActionType.Slice)
			{
				enterPlane = GetSlicePlane();
			}
		}

		private void TriggerExit(Collider col)
		{
			if (onTrigger == CutType.Exit)
			{
				if (actionType == ActionType.Slice)
				{
					Slice(col.gameObject, GetSlicePlane());
				}
				else
				{
					Demolish(col.gameObject);
				}
			}
			else if (onTrigger == CutType.EnterExit)
			{
				if (actionType == ActionType.Slice)
				{
					exitPlane = GetSlicePlane();
					Slice(slicePlane: new Vector3[2]
					{
						(enterPlane[0] + exitPlane[0]) / 2f,
						(enterPlane[1] + exitPlane[1]) / 2f
					}, targetObject: col.gameObject);
				}
				else
				{
					Demolish(col.gameObject);
				}
			}
		}

		private void Demolish(GameObject targetObject)
		{
			if ((!(tagFilter != "Untagged") || targetObject.CompareTag(tagFilter)) && LayerCheck(targetObject.layer))
			{
				RayfireRigid component = targetObject.GetComponent<RayfireRigid>();
				if (!(component == null) && component.demolitionType != 0 && component.State())
				{
					component.limitations.demolitionShould = true;
				}
			}
		}

		public void SliceTarget()
		{
			if (target != null)
			{
				Slice(target, GetSlicePlane());
			}
			if (targets == null || targets.Count <= 0)
			{
				return;
			}
			for (int i = 0; i < targets.Count; i++)
			{
				if (targets[i] != null)
				{
					Slice(targets[i], GetSlicePlane());
				}
			}
		}

		private void Slice(GameObject targetObject, Vector3[] slicePlane)
		{
			if ((!(tagFilter != "Untagged") || targetObject.CompareTag(tagFilter)) && LayerCheck(targetObject.layer))
			{
				RayfireRigid component = targetObject.GetComponent<RayfireRigid>();
				if (!(component == null) && component.demolitionType != 0 && component.limitations.sliceByBlade && component.State())
				{
					component.AddSlicePlane(slicePlane);
					sliceEvent.InvokeLocalEvent(this);
					RFSliceEvent.InvokeGlobalEvent(this);
				}
			}
		}

		private Vector3[] GetSlicePlane()
		{
			Vector3[] array = new Vector3[2]
			{
				transForm.position,
				default(Vector3)
			};
			if (sliceType == PlaneType.XY)
			{
				array[1] = transForm.forward;
			}
			else if (sliceType == PlaneType.XZ)
			{
				array[1] = transForm.up;
			}
			else if (sliceType == PlaneType.YZ)
			{
				array[1] = transForm.right;
			}
			return array;
		}

		private bool LayerCheck(int layerId)
		{
			return mask == (mask | (1 << layerId));
		}
	}
	[AddComponentMenu("RayFire/Rayfire Bomb")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-bomb-component/")]
	public class RayfireBomb : MonoBehaviour
	{
		public enum RangeType
		{
			Spherical
		}

		public enum FadeType
		{
			Linear,
			Exponential,
			None
		}

		[Serializable]
		public class Projectile
		{
			public Vector3 positionPivot;

			public Vector3 positionClosest;

			public float fade;

			public Rigidbody rb;

			public RayfireRigid scrRigid;

			public Quaternion rotation;
		}

		[Header("  Range")]
		[Space(3f)]
		public RangeType rangeType;

		[Space(1f)]
		public FadeType fadeType;

		[Space(1f)]
		public float range = 5f;

		[Header("  Impulse")]
		[Space(3f)]
		[Range(0f, 10f)]
		public float strength = 1f;

		[Space(1f)]
		[Range(0f, 100f)]
		public int variation = 50;

		[Space(1f)]
		[Range(0f, 90f)]
		public int chaos = 30;

		[Space(1f)]
		public bool forceByMass = true;

		[Space(1f)]
		public bool affectKinematic;

		[Header("  Detonation")]
		[Space(3f)]
		public float heightOffset;

		[Space(1f)]
		public float delay;

		[Header("  Damage")]
		[Space(3f)]
		public bool applyDamage = true;

		[Space(1f)]
		public float damageValue = 1f;

		[Header("  Audio")]
		[Space(3f)]
		public bool play;

		[Space(1f)]
		[Range(0.01f, 1f)]
		public float volume = 1f;

		[Space(1f)]
		public AudioClip clip;

		public RFExplosionEvent explosionEvent = new RFExplosionEvent();

		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public Vector3 bombPosition;

		[HideInInspector]
		public Vector3 explPosition;

		[HideInInspector]
		public Collider[] colliders;

		[HideInInspector]
		public List<Projectile> projectiles = new List<Projectile>();

		[HideInInspector]
		public List<Rigidbody> rigidbodies = new List<Rigidbody>();

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		private void Awake()
		{
			DefineComponents();
			ClearLists();
		}

		private void DefineComponents()
		{
			transForm = GetComponent<Transform>();
		}

		public void CopyFrom(RayfireBomb scr)
		{
			rangeType = scr.rangeType;
			fadeType = scr.fadeType;
			range = scr.range;
			strength = scr.strength;
			variation = scr.variation;
			chaos = scr.chaos;
			forceByMass = scr.forceByMass;
			affectKinematic = scr.affectKinematic;
			heightOffset = scr.heightOffset;
			delay = scr.delay;
			applyDamage = scr.applyDamage;
			damageValue = scr.damageValue;
			clip = scr.clip;
			volume = scr.volume;
		}

		public void Explode(float delayLoc)
		{
			if (delayLoc == 0f)
			{
				Explode();
			}
			else if (delayLoc > 0f)
			{
				StartCoroutine(ExplodeCor());
			}
		}

		private IEnumerator ExplodeCor()
		{
			yield return new WaitForSeconds(delay);
			Explode();
		}

		private void Explode()
		{
			SetPositions();
			if (Setup() && (!SetRigidDamage() || Setup()))
			{
				SetForce();
				explosionEvent.InvokeLocalEvent(this);
				RFExplosionEvent.InvokeGlobalEvent(this);
				PlayAudio();
				if (!UnityEngine.Application.isEditor)
				{
					ClearLists();
				}
			}
		}

		private void PlayAudio()
		{
			if (play && clip != null)
			{
				if (volume < 0f)
				{
					volume = 1f;
				}
				AudioSource.PlayClipAtPoint(clip, base.transform.position, volume);
			}
		}

		private bool Setup()
		{
			ClearLists();
			SetColliders();
			SetProjectiles();
			if (projectiles.Count == 0)
			{
				return false;
			}
			return true;
		}

		public void Restore()
		{
			foreach (Projectile projectile in projectiles)
			{
				if (projectile.rb != null)
				{
					projectile.rb.velocity = Vector3.zero;
					projectile.rb.angularVelocity = Vector3.zero;
					projectile.rb.transform.position = projectile.positionPivot;
					projectile.rb.transform.rotation = projectile.rotation;
				}
			}
		}

		private void ClearLists()
		{
			colliders = null;
			rigidbodies.Clear();
			projectiles.Clear();
		}

		private void SetPositions()
		{
			bombPosition = base.transform.position;
			explPosition = base.transform.position;
			if (heightOffset != 0f)
			{
				explPosition.y = bombPosition.y + heightOffset;
			}
		}

		private void SetColliders()
		{
			if (rangeType == RangeType.Spherical)
			{
				colliders = Physics.OverlapSphere(bombPosition, range, mask);
			}
		}

		private void SetProjectiles()
		{
			projectiles.Clear();
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				if (!(tagFilter != "Untagged") || collider.gameObject.CompareTag(tagFilter))
				{
					Rigidbody attachedRigidbody = collider.attachedRigidbody;
					if (!(attachedRigidbody == null) && !rigidbodies.Contains(attachedRigidbody))
					{
						Projectile projectile = new Projectile();
						projectile.rb = attachedRigidbody;
						projectile.positionPivot = attachedRigidbody.transform.position;
						projectile.rotation = attachedRigidbody.transform.rotation;
						projectile.positionClosest = collider.bounds.ClosestPoint(transForm.position);
						projectile.fade = Fade(transForm.position, projectile.positionClosest);
						projectile.scrRigid = projectile.rb.GetComponent<RayfireRigid>();
						projectiles.Add(projectile);
						rigidbodies.Add(attachedRigidbody);
					}
				}
			}
		}

		private bool SetRigidDamage()
		{
			bool result = false;
			if (applyDamage && damageValue > 0f)
			{
				foreach (Projectile projectile in projectiles)
				{
					if (projectile.scrRigid != null && projectile.scrRigid.damage.enable && projectile.scrRigid.ApplyDamage(damageValue * projectile.fade, base.transform.position))
					{
						result = true;
					}
				}
			}
			return result;
		}

		private void SetForce()
		{
			UnityEngine.Random.InitState(1);
			foreach (Projectile projectile in projectiles)
			{
				ForceMode mode = ForceMode.Impulse;
				if (!forceByMass)
				{
					mode = ForceMode.VelocityChange;
				}
				Vector3 vector = Vector(projectile);
				SetKinematic(projectile);
				float max = strength * (float)variation / 100f + strength;
				float num = UnityEngine.Random.Range(strength, max);
				float num2 = projectile.fade * num * 10f;
				projectile.rb.AddForce(vector * num2, mode);
				Vector3 angularVelocity = new Vector3(UnityEngine.Random.Range(-chaos, chaos), UnityEngine.Random.Range(-chaos, chaos), UnityEngine.Random.Range(-chaos, chaos));
				projectile.rb.angularVelocity = angularVelocity;
			}
		}

		private void SetKinematic(Projectile projectile)
		{
			if (!affectKinematic || !(projectile.fade > 0f) || !projectile.rb.isKinematic)
			{
				return;
			}
			if (projectile.scrRigid != null)
			{
				projectile.scrRigid.Activate();
				return;
			}
			projectile.rb.isKinematic = false;
			MeshCollider component = projectile.rb.gameObject.GetComponent<MeshCollider>();
			if (component != null && !component.convex)
			{
				component.convex = true;
			}
		}

		private float Fade(Vector3 bombPos, Vector3 fragPos)
		{
			float num = 1f;
			if (fadeType == FadeType.Linear)
			{
				num = 1f - Vector3.Distance(bombPos, fragPos) / range;
			}
			else if (fadeType == FadeType.Exponential)
			{
				num = 1f - Vector3.Distance(bombPos, fragPos) / range;
				num *= num;
			}
			if (num < 0f)
			{
				num = 0f;
			}
			return num;
		}

		private Vector3 Vector(Projectile projectile)
		{
			Vector3 result = Vector3.up;
			if (rangeType == RangeType.Spherical)
			{
				result = Vector3.Normalize(projectile.positionPivot - explPosition);
			}
			return result;
		}
	}
	[SelectionBase]
	[AddComponentMenu("RayFire/Rayfire Cluster")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-cluster-component/")]
	public class RayfireCluster : MonoBehaviour
	{
		public enum ClusterType
		{
			ByPointCloud,
			BySharedArea
		}

		[Space(2f)]
		[Header("  Properties")]
		[Space(2f)]
		public ClusterType type;

		[Range(1f, 7f)]
		public int depth = 1;

		[Range(0f, 100f)]
		public int seed = 1;

		[Range(0f, 4f)]
		public int smoothPass = 1;

		[Header("  By Point Cloud")]
		[Space(2f)]
		[Range(2f, 100f)]
		public int baseAmount = 5;

		[Range(2f, 50f)]
		public int depthAmount = 2;

		public ConnectivityType connectivity;

		[Header("  By Shared Area")]
		[Space(2f)]
		[Range(2f, 8f)]
		public int minimumAmount = 2;

		[Range(2f, 8f)]
		public int maximumAmount = 5;

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public bool colorPreview;

		[HideInInspector]
		public bool scalePreview;

		[HideInInspector]
		public Color wireColor = new Color(0.58f, 0.77f, 1f);

		[HideInInspector]
		public float previewScale;

		[HideInInspector]
		public List<RFCluster> allClusters = new List<RFCluster>();

		[HideInInspector]
		public List<RFShard> allShards = new List<RFShard>();

		private int clusterId;

		public void Extract()
		{
			previewScale = 0f;
			allShards.Clear();
			allClusters.Clear();
			List<Transform> list = GetComponentsInChildren<Transform>().ToList();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				if (list[num].GetComponents(typeof(Component)).Length == 1)
				{
					UnityEngine.Object.DestroyImmediate(list[num].gameObject);
					list.RemoveAt(num);
				}
				else
				{
					list[num].parent = base.transform;
				}
			}
		}

		public void Clusterize()
		{
			Extract();
			allShards.Clear();
			allClusters.Clear();
			ClusterizeVoronoi();
			ClusterizeRange();
		}

		private void ClusterizeVoronoi()
		{
			if (type != 0)
			{
				return;
			}
			RFCluster rFCluster = SetupMainCluster(connectivity);
			if (baseAmount >= rFCluster.shards.Count)
			{
				return;
			}
			RFShard.SetShardNeibs(rFCluster.shards, connectivity);
			List<RFCluster> list = new List<RFCluster> { rFCluster };
			allClusters.Add(rFCluster);
			while (list.Count > 0)
			{
				RFCluster rFCluster2 = list[0];
				list.RemoveAt(0);
				if (rFCluster2.shards.Count >= 4)
				{
					int amount = baseAmount;
					if (rFCluster2.depth > 0)
					{
						amount = depthAmount;
					}
					rFCluster2.childClusters = ClusterizeClusterByAmount(rFCluster2, amount);
					allClusters.AddRange(rFCluster2.childClusters);
					if (rFCluster2.childClusters.Count > 0 && depth > rFCluster2.depth + 1)
					{
						list.AddRange(rFCluster2.childClusters);
					}
				}
			}
			SetClusterNames();
		}

		private List<RFCluster> ClusterizeClusterByAmount(RFCluster parentCluster, int amount)
		{
			List<RFCluster> list = new List<RFCluster>();
			if (parentCluster.tm.childCount <= 2)
			{
				return list;
			}
			if (amount >= parentCluster.shards.Count)
			{
				return list;
			}
			Bounds childrenBound = RFCluster.GetChildrenBound(parentCluster.tm);
			foreach (Vector3 item in VoronoiPointCloud(childrenBound, amount))
			{
				RFCluster rFCluster = new RFCluster();
				rFCluster.pos = item;
				rFCluster.depth = parentCluster.depth + 1;
				clusterId++;
				rFCluster.id = clusterId;
				list.Add(rFCluster);
			}
			foreach (RFShard shard in parentCluster.shards)
			{
				float num = Vector3.Distance(shard.tm.position, list[0].pos);
				float num2 = num;
				shard.cluster = list[0];
				if (list.Count > 1)
				{
					for (int i = 1; i < list.Count; i++)
					{
						num = Vector3.Distance(shard.tm.position, list[i].pos);
						if (num < num2)
						{
							num2 = num;
							shard.cluster = list[i];
						}
					}
				}
				shard.cluster.shards.Add(shard);
				shard.cluster = null;
			}
			List<RFShard> list2 = new List<RFShard>();
			for (int num3 = list.Count - 1; num3 >= 0; num3--)
			{
				if (list[num3].shards.Count < 2)
				{
					list2.AddRange(list[num3].shards);
					list.RemoveAt(num3);
				}
			}
			SetSoloShardToCluster(list2, list);
			SetSoloShardToCluster(list2, list);
			if (smoothPass > 0 && connectivity == ConnectivityType.ByMesh)
			{
				for (int j = 0; j < smoothPass; j++)
				{
					RoughnessPassShards(list);
				}
			}
			if (connectivity == ConnectivityType.ByMesh)
			{
				ConnectivityCheck(list);
			}
			if (list.Count == 1)
			{
				list.Clear();
				return list;
			}
			foreach (RFCluster item2 in list)
			{
				CreateRoot(item2, parentCluster.tm);
			}
			return list;
		}

		private void ConnectivityCheck(List<RFCluster> childClusters)
		{
			List<RFShard> list = new List<RFShard>();
			List<RFCluster> list2 = new List<RFCluster>();
			foreach (RFCluster childCluster in childClusters)
			{
				for (int num = childCluster.shards.Count - 1; num >= 0; num--)
				{
					if (childCluster.shards[num].neibShards.Count == 0)
					{
						list.Add(childCluster.shards[num]);
					}
				}
				List<RFShard> list3 = new List<RFShard>();
				foreach (RFShard shard in childCluster.shards)
				{
					list3.Add(shard);
				}
				int count = list3.Count;
				List<RFCluster> list4 = new List<RFCluster>();
				while (list3.Count > 0)
				{
					List<RFShard> list5 = new List<RFShard>();
					List<RFShard> list6 = new List<RFShard>();
					list6.Add(list3[0]);
					list5.Add(list3[0]);
					while (list6.Count > 0)
					{
						foreach (RFShard neibShard in list6[0].neibShards)
						{
							if (list3.Contains(neibShard) && !list5.Contains(neibShard))
							{
								list6.Add(neibShard);
								list5.Add(neibShard);
							}
						}
						list6.RemoveAt(0);
					}
					if (count == list5.Count)
					{
						list3.Clear();
						continue;
					}
					RFCluster rFCluster = new RFCluster();
					rFCluster.pos = childCluster.pos;
					rFCluster.depth = childCluster.depth;
					rFCluster.shards = list5;
					clusterId++;
					rFCluster.id = clusterId;
					list4.Add(rFCluster);
					for (int num2 = list3.Count - 1; num2 >= 0; num2--)
					{
						if (list5.Contains(list3[num2]))
						{
							list3.RemoveAt(num2);
						}
					}
				}
				if (list4.Count > 0)
				{
					childCluster.shards.Clear();
					list2.AddRange(list4);
				}
			}
			for (int num3 = childClusters.Count - 1; num3 >= 0; num3--)
			{
				if (childClusters[num3].shards.Count == 0)
				{
					childClusters.RemoveAt(num3);
				}
			}
			childClusters.AddRange(list2);
			RFCluster.SetClusterNeib(childClusters, connectivity: true);
			SetSoloShardToCluster(list, childClusters);
			if (smoothPass > 0)
			{
				RoughnessPassShards(childClusters);
			}
		}

		private void ClusterizeRange()
		{
			if (type != ClusterType.BySharedArea)
			{
				return;
			}
			UnityEngine.Random.InitState(seed);
			RFCluster rFCluster = SetupMainCluster(ConnectivityType.ByMesh);
			allClusters.Add(rFCluster);
			RFShard.SetShardNeibs(rFCluster.shards, ConnectivityType.ByMesh);
			List<RFCluster> list = ClusterizeRangeShards(rFCluster);
			foreach (RFCluster item in list)
			{
				CreateRoot(item, base.transform);
			}
			allClusters.AddRange(list);
			if (depth > 1)
			{
				for (int i = 1; i < depth; i++)
				{
					RFCluster.SetClusterNeib(rFCluster.childClusters, connectivity: true);
					List<RFCluster> list2 = ClusterizeRangeClusters(rFCluster);
					if (list2.Count <= 1)
					{
						continue;
					}
					foreach (RFCluster item2 in list2)
					{
						CreateRoot(item2, rFCluster.tm);
						foreach (RFCluster childCluster in item2.childClusters)
						{
							childCluster.tm.parent = item2.tm;
						}
					}
					rFCluster.childClusters = list2;
					allClusters.AddRange(list2);
					foreach (RFCluster allCluster in allClusters)
					{
						if (allCluster.id != 0)
						{
							allCluster.depth++;
						}
					}
				}
			}
			SetClusterNames();
		}

		private List<RFCluster> ClusterizeRangeShards(RFCluster mainCluster)
		{
			List<RFShard> list = new List<RFShard>();
			List<RFCluster> list2 = new List<RFCluster>();
			mainCluster.shards.Sort();
			while (mainCluster.shards.Count > 0)
			{
				int num = UnityEngine.Random.Range(minimumAmount, maximumAmount);
				RFShard item = mainCluster.shards[0];
				mainCluster.shards.RemoveAt(0);
				List<RFShard> list3 = new List<RFShard>();
				list3.Add(item);
				for (int i = 0; i < num - 1; i++)
				{
					RFShard biggestShard = RFShard.GetNeibShardArea(list3, mainCluster.shards);
					if (biggestShard == null)
					{
						break;
					}
					list3.Add(biggestShard);
					mainCluster.shards.RemoveAll((RFShard t) => t.id == biggestShard.id);
				}
				if (list3.Count == 1)
				{
					list.Add(item);
				}
				else if (list3.Count > 1)
				{
					RFCluster rFCluster = new RFCluster();
					rFCluster.shards.AddRange(list3);
					rFCluster.depth = 1;
					clusterId++;
					rFCluster.id = clusterId;
					list2.Add(rFCluster);
					mainCluster.childClusters.Add(rFCluster);
				}
			}
			SetSoloShardToCluster(list, list2);
			SetSoloShardToCluster(list, list2);
			if (smoothPass > 0)
			{
				for (int j = 0; j < smoothPass; j++)
				{
					RoughnessPassShards(list2);
				}
			}
			int num2 = 1;
			for (int k = 0; k < list2.Count; k++)
			{
				list2[k].id = num2 + k;
			}
			mainCluster.shards.Clear();
			mainCluster.shards.AddRange(list);
			return list2;
		}

		private List<RFCluster> ClusterizeRangeClusters(RFCluster parentCluster)
		{
			List<RFCluster> list = new List<RFCluster>();
			List<RFCluster> list2 = new List<RFCluster>();
			parentCluster.childClusters.Sort();
			while (parentCluster.childClusters.Count > 0)
			{
				int num = UnityEngine.Random.Range(minimumAmount, maximumAmount);
				RFCluster item = parentCluster.childClusters[0];
				parentCluster.childClusters.RemoveAt(0);
				List<RFCluster> list3 = new List<RFCluster>();
				list3.Add(item);
				for (int i = 0; i < num - 1; i++)
				{
					RFCluster biggestCluster = RFCluster.GetNeibClusterArea(list3, parentCluster.childClusters);
					if (biggestCluster == null)
					{
						break;
					}
					list3.Add(biggestCluster);
					parentCluster.childClusters.RemoveAll((RFCluster t) => t.id == biggestCluster.id);
				}
				if (list3.Count == 1)
				{
					list.Add(item);
					continue;
				}
				RFCluster rFCluster = new RFCluster();
				rFCluster.childClusters.AddRange(list3);
				rFCluster.depth = 0;
				clusterId++;
				rFCluster.id = clusterId;
				list2.Add(rFCluster);
			}
			SetSoloClusterToCluster(list, list2);
			SetSoloClusterToCluster(list, list2);
			if (smoothPass > 0)
			{
				for (int j = 0; j < smoothPass; j++)
				{
					RoughnessPassClusters(list2);
				}
			}
			return list2;
		}

		private static void RoughnessPassShards(List<RFCluster> clusters)
		{
			RFCluster.SetClusterNeib(clusters, connectivity: true);
			for (int num = clusters.Count - 1; num >= 0; num--)
			{
				RFCluster rFCluster = clusters[num];
				if (rFCluster.shards.Count != 2 && rFCluster.neibClusters.Count != 0)
				{
					List<RFShard> list = new List<RFShard>();
					List<RFCluster> list2 = new List<RFCluster>();
					foreach (RFShard shard in rFCluster.shards)
					{
						float num2 = 0f;
						for (int i = 0; i < shard.neibShards.Count; i++)
						{
							if (rFCluster.shards.Contains(shard.neibShards[i]))
							{
								num2 += shard.nArea[i];
							}
						}
						List<float> list3 = new List<float>();
						foreach (RFCluster neibCluster in rFCluster.neibClusters)
						{
							float num3 = 0f;
							for (int j = 0; j < shard.neibShards.Count; j++)
							{
								if (neibCluster.shards.Contains(shard.neibShards[j]))
								{
									num3 += shard.nArea[j];
								}
							}
							list3.Add(num3);
						}
						float num4 = list3.Max();
						if (num2 >= num4)
						{
							continue;
						}
						for (int k = 0; k < list3.Count; k++)
						{
							if (num4 == list3[k])
							{
								list.Add(shard);
								list2.Add(rFCluster.neibClusters[k]);
							}
						}
					}
					if (list.Count > 0)
					{
						for (int l = 0; l < list.Count; l++)
						{
							for (int num5 = rFCluster.shards.Count - 1; num5 >= 0; num5--)
							{
								if (rFCluster.shards[num5] == list[l])
								{
									rFCluster.shards.RemoveAt(num5);
								}
							}
							list2[l].shards.Add(list[l]);
						}
					}
				}
			}
			for (int num6 = clusters.Count - 1; num6 >= 0; num6--)
			{
				if (clusters[num6].shards.Count == 1)
				{
					clusters[num6].shards.Clear();
				}
				if (clusters[num6].shards.Count == 0)
				{
					clusters.RemoveAt(num6);
				}
			}
		}

		private void RoughnessPassClusters(List<RFCluster> clusters)
		{
			RFCluster.SetClusterNeib(clusters, connectivity: true);
			foreach (RFCluster cluster in clusters)
			{
				if (cluster.childClusters.Count <= 2 || cluster.neibClusters.Count == 0)
				{
					continue;
				}
				List<RFCluster> list = new List<RFCluster>();
				List<RFCluster> list2 = new List<RFCluster>();
				foreach (RFCluster childCluster in cluster.childClusters)
				{
					float num = 0f;
					for (int i = 0; i < childCluster.neibClusters.Count; i++)
					{
						if (cluster.childClusters.Contains(childCluster.neibClusters[i]))
						{
							num += childCluster.neibArea[i];
						}
					}
					List<float> list3 = new List<float>();
					foreach (RFCluster neibCluster in cluster.neibClusters)
					{
						float num2 = 0f;
						for (int j = 0; j < childCluster.neibClusters.Count; j++)
						{
							if (neibCluster.childClusters.Contains(childCluster.neibClusters[j]))
							{
								num2 += childCluster.neibArea[j];
							}
						}
						list3.Add(num2);
					}
					float num3 = list3.Max();
					if (num >= num3)
					{
						continue;
					}
					for (int k = 0; k < list3.Count; k++)
					{
						if (num3 == list3[k])
						{
							list.Add(childCluster);
							list2.Add(cluster.neibClusters[k]);
						}
					}
				}
				if (list.Count + 1 >= cluster.childClusters.Count || list.Count <= 0)
				{
					continue;
				}
				for (int l = 0; l < list.Count; l++)
				{
					for (int num4 = cluster.shards.Count - 1; num4 >= 0; num4--)
					{
						if (cluster.childClusters[num4] == list[l])
						{
							cluster.childClusters.RemoveAt(num4);
						}
					}
					list2[l].childClusters.Add(list[l]);
				}
			}
		}

		private void SetSoloShardToCluster(List<RFShard> soloShards, List<RFCluster> childClusters)
		{
			if (soloShards.Count == 0)
			{
				return;
			}
			for (int num = soloShards.Count - 1; num >= 0; num--)
			{
				int neibIndArea = soloShards[num].GetNeibIndArea();
				if (neibIndArea >= 0)
				{
					RFShard item = soloShards[num].neibShards[neibIndArea];
					for (int i = 0; i < childClusters.Count; i++)
					{
						if (childClusters[i].shards.Contains(item))
						{
							childClusters[i].shards.Add(soloShards[num]);
							soloShards.RemoveAt(num);
						}
					}
				}
			}
		}

		private void SetSoloClusterToCluster(List<RFCluster> soloClusters, List<RFCluster> childClusters)
		{
			if (soloClusters.Count == 0)
			{
				return;
			}
			for (int num = soloClusters.Count - 1; num >= 0; num--)
			{
				int neibIndArea = soloClusters[num].GetNeibIndArea();
				if (neibIndArea >= 0)
				{
					RFCluster item = soloClusters[num].neibClusters[neibIndArea];
					for (int i = 0; i < childClusters.Count; i++)
					{
						if (childClusters[i].childClusters.Contains(item))
						{
							childClusters[i].childClusters.Add(soloClusters[num]);
							soloClusters.RemoveAt(num);
						}
					}
				}
			}
		}

		private RFCluster SetupMainCluster(ConnectivityType connect)
		{
			RFCluster rFCluster = new RFCluster();
			rFCluster.tm = base.transform;
			rFCluster.depth = 0;
			rFCluster.pos = base.transform.position;
			rFCluster.id = 0;
			RFShard.SetShards(rFCluster, connectivity);
			clusterId = 0;
			allShards.Clear();
			allShards.AddRange(rFCluster.shards);
			return rFCluster;
		}

		private void SetClusterNames()
		{
			foreach (RFCluster allCluster in allClusters)
			{
				if (allCluster.id > 0 && allCluster.tm != null)
				{
					allCluster.tm.name = base.gameObject.name + "_cls_" + allCluster.id;
				}
			}
		}

		private void CreateRoot(RFCluster childCluster, Transform parentTm)
		{
			Bounds bounds = (childCluster.bound = GetShardsBound(childCluster.shards, childCluster.childClusters));
			GameObject gameObject = new GameObject();
			childCluster.tm = gameObject.transform;
			childCluster.pos = bounds.center;
			childCluster.tm.position = bounds.center;
			childCluster.tm.parent = parentTm;
			foreach (RFShard shard in childCluster.shards)
			{
				shard.tm.parent = childCluster.tm;
			}
		}

		private Bounds GetShardsBound(List<RFShard> shards, List<RFCluster> clusters = null)
		{
			List<Bounds> list = new List<Bounds>();
			foreach (RFShard shard in shards)
			{
				list.Add(shard.bnd);
			}
			if (clusters != null)
			{
				foreach (RFCluster cluster in clusters)
				{
					list.Add(cluster.bound);
				}
			}
			return RFCluster.GetBoundsBound(list);
		}

		private List<Vector3> VoronoiPointCloud(Bounds bound, int am)
		{
			UnityEngine.Random.InitState(seed + clusterId);
			List<Vector3> list = new List<Vector3>();
			for (int i = 0; i < am; i++)
			{
				float x = UnityEngine.Random.Range(bound.min.x, bound.max.x);
				float y = UnityEngine.Random.Range(bound.min.y, bound.max.y);
				float z = UnityEngine.Random.Range(bound.min.z, bound.max.z);
				Vector3 item = new Vector3(x, y, z);
				list.Add(item);
			}
			return list;
		}
	}
	[AddComponentMenu("RayFire/Rayfire Combine")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-combine-component/")]
	public class RayfireCombine : MonoBehaviour
	{
		public enum CombType
		{
			Children,
			ObjectsList
		}

		[Header("  Object source")]
		[Space(3f)]
		public CombType type;

		[Space(1f)]
		public List<GameObject> objects;

		[Header("  Mesh source")]
		[Space(3f)]
		public bool meshFilters = true;

		[Space(1f)]
		public bool skinnedMeshes = true;

		[Space(1f)]
		public bool particleSystems = true;

		[Space(3f)]
		[Header("  Filters")]
		[Space(3f)]
		[Range(0f, 10f)]
		public float sizeThreshold = 0.1f;

		[Space(1f)]
		[Range(0f, 100f)]
		public int vertexThreshold = 5;

		private Transform transForm;

		private MeshFilter mFilter;

		private MeshRenderer meshRenderer;

		private List<bool> invertNormals;

		private List<Transform> transForms;

		private List<MeshFilter> mFilters;

		private List<SkinnedMeshRenderer> skinnedMeshRends;

		private List<ParticleSystemRenderer> particleRends;

		private List<Mesh> meshList;

		private List<List<int>> matIdList;

		private List<List<Material>> matList;

		private List<Material> allMaterials;

		private List<int> combTrianglesSubId;

		private List<List<int>> combTriangles;

		private List<Vector3> combVertices;

		private List<Vector3> combNormals;

		private List<Vector2> combUvs;

		private List<Vector4> combTangents;

		public void Combine()
		{
			SetData();
			SetCombinedMesh();
			CreateMesh();
		}

		private void SetData()
		{
			transForm = GetComponent<Transform>();
			mFilter = GetComponent<MeshFilter>();
			if (mFilter == null)
			{
				mFilter = base.gameObject.AddComponent<MeshFilter>();
			}
			mFilter.sharedMesh = null;
			meshRenderer = GetComponent<MeshRenderer>();
			if (meshRenderer == null)
			{
				meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
			meshRenderer.sharedMaterials = new Material[0];
			if (type == CombType.Children)
			{
				if (meshFilters)
				{
					mFilters = GetComponentsInChildren<MeshFilter>().ToList();
				}
				if (skinnedMeshes)
				{
					skinnedMeshRends = GetComponentsInChildren<SkinnedMeshRenderer>().ToList();
				}
				if (particleSystems)
				{
					particleRends = GetComponentsInChildren<ParticleSystemRenderer>().ToList();
				}
			}
			if (type == CombType.ObjectsList)
			{
				mFilters = new List<MeshFilter>();
				if (meshFilters)
				{
					foreach (GameObject @object in objects)
					{
						MeshFilter component = @object.GetComponent<MeshFilter>();
						if (component != null && component.sharedMesh != null)
						{
							mFilters.Add(component);
						}
					}
				}
				skinnedMeshRends = new List<SkinnedMeshRenderer>();
				if (skinnedMeshes)
				{
					foreach (GameObject object2 in objects)
					{
						SkinnedMeshRenderer component2 = object2.GetComponent<SkinnedMeshRenderer>();
						if (component2 != null && component2.sharedMesh != null)
						{
							skinnedMeshRends.Add(component2);
						}
					}
				}
				particleRends = new List<ParticleSystemRenderer>();
				if (particleSystems)
				{
					foreach (GameObject object3 in objects)
					{
						ParticleSystemRenderer component3 = object3.GetComponent<ParticleSystemRenderer>();
						if (component3 != null)
						{
							particleRends.Add(component3);
						}
					}
				}
			}
			for (int num = mFilters.Count - 1; num >= 0; num--)
			{
				if (mFilters[num].sharedMesh == null)
				{
					mFilters.RemoveAt(num);
				}
			}
			for (int num2 = skinnedMeshRends.Count - 1; num2 >= 0; num2--)
			{
				if (skinnedMeshRends[num2].sharedMesh == null)
				{
					skinnedMeshRends.RemoveAt(num2);
				}
			}
			meshList = new List<Mesh>();
			transForms = new List<Transform>();
			matList = new List<List<Material>>();
			foreach (MeshFilter mFilter in mFilters)
			{
				if (mFilter.sharedMesh.vertexCount < vertexThreshold)
				{
					continue;
				}
				MeshRenderer component4 = mFilter.GetComponent<MeshRenderer>();
				if (!(component4 != null) || !(component4.bounds.size.magnitude < sizeThreshold))
				{
					meshList.Add(mFilter.sharedMesh);
					transForms.Add(mFilter.transform);
					List<Material> item = new List<Material>();
					if (component4 != null)
					{
						item = component4.sharedMaterials.ToList();
					}
					matList.Add(item);
				}
			}
			foreach (SkinnedMeshRenderer skinnedMeshRend in skinnedMeshRends)
			{
				if (skinnedMeshRend.sharedMesh.vertexCount >= vertexThreshold && !(skinnedMeshRend.bounds.size.magnitude < sizeThreshold))
				{
					meshList.Add(RFMesh.BakeMesh(skinnedMeshRend));
					transForms.Add(skinnedMeshRend.transform);
					matList.Add(skinnedMeshRend.sharedMaterials.ToList());
				}
			}
			if (particleRends.Count > 0)
			{
				GameObject gameObject = new GameObject();
				foreach (ParticleSystemRenderer particleRend in particleRends)
				{
					Mesh mesh = new Mesh();
					particleRend.BakeMesh(mesh, useTransform: true);
					if (mesh.vertexCount > 3)
					{
						meshList.Add(mesh);
						transForms.Add(gameObject.transform);
						matList.Add(particleRend.sharedMaterials.ToList());
					}
				}
				UnityEngine.Object.DestroyImmediate(gameObject);
			}
			if (meshList.Count == 0)
			{
				UnityEngine.Debug.Log("No meshes to combine");
				return;
			}
			invertNormals = new List<bool>();
			allMaterials = new List<Material>();
			matIdList = new List<List<int>>();
			for (int i = 0; i < transForms.Count; i++)
			{
				foreach (Material item2 in matList[i])
				{
					if (!allMaterials.Contains(item2))
					{
						allMaterials.Add(item2);
					}
				}
				matIdList.Add(matList[i].Select((Material t) => allMaterials.IndexOf(t)).ToList());
				bool flag = false;
				if (transForms[i].localScale.x < 0f)
				{
					flag = !flag;
				}
				if (transForms[i].localScale.y < 0f)
				{
					flag = !flag;
				}
				if (transForms[i].localScale.z < 0f)
				{
					flag = !flag;
				}
				invertNormals.Add(flag);
			}
		}

		private void SetCombinedMesh()
		{
			int num = 0;
			combTrianglesSubId = new List<int>();
			combTriangles = new List<List<int>>();
			combVertices = new List<Vector3>();
			combNormals = new List<Vector3>();
			combUvs = new List<Vector2>();
			combTangents = new List<Vector4>();
			int i;
			for (i = 0; i < meshList.Count; i++)
			{
				Mesh mesh = meshList[i];
				combVertices.AddRange(mesh.vertices.Select((Vector3 t) => transForm.InverseTransformPoint(transForms[i].TransformPoint(t))));
				combNormals.AddRange(invertNormals[i] ? mesh.normals.Select((Vector3 o) => -o).ToList() : mesh.normals.ToList());
				combUvs.AddRange(mesh.uv.ToList());
				combTangents.AddRange(mesh.tangents.ToList());
				for (int j = 0; j < mesh.subMeshCount; j++)
				{
					int[] array = mesh.GetTriangles(j);
					if (invertNormals[i])
					{
						array = array.Reverse().ToArray();
					}
					for (int k = 0; k < array.Length; k++)
					{
						array[k] += num;
					}
					if (combTrianglesSubId.Contains(matIdList[i][j]))
					{
						int index = combTrianglesSubId.IndexOf(matIdList[i][j]);
						combTriangles[index].AddRange(array.ToList());
					}
					else
					{
						combTriangles.Add(array.ToList());
						combTrianglesSubId.Add(matIdList[i][j]);
					}
				}
				num += mesh.vertices.Length;
			}
		}

		private void CreateMesh()
		{
			Mesh mesh = new Mesh();
			mesh.name = base.name + "_Comb";
			mesh.SetVertices(combVertices);
			mesh.SetNormals(combNormals);
			mesh.SetUVs(0, combUvs);
			mesh.SetTangents(combTangents);
			mesh.subMeshCount = combTrianglesSubId.Count;
			for (int i = 0; i < combTriangles.Count; i++)
			{
				mesh.SetTriangles(combTriangles[i], combTrianglesSubId[i]);
			}
			mesh.RecalculateNormals();
			mesh.RecalculateBounds();
			mesh.RecalculateTangents();
			mFilter.sharedMesh = mesh;
			meshRenderer.sharedMaterials = allMaterials.ToArray();
		}
	}
	[AddComponentMenu("RayFire/Rayfire Connectivity")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-connectivity-component/")]
	public class RayfireConnectivity : MonoBehaviour
	{
		[Header("  Connectivity")]
		[Space(3f)]
		public ConnectivityType type;

		[Header("  Filters")]
		[Space(3f)]
		[Range(0f, 1f)]
		public float minimumArea;

		[Space(2f)]
		[Range(0f, 10f)]
		public float minimumSize;

		[Space(2f)]
		[Range(0f, 100f)]
		public int percentage;

		[Space(2f)]
		[Range(0f, 100f)]
		public int seed;

		[Header("  Cluster Properties")]
		[Space(3f)]
		public bool clusterize = true;

		[Space(2f)]
		public bool demolishable;

		[Header("  Collapse")]
		[Space(3f)]
		public RFCollapse collapse;

		[HideInInspector]
		public bool showConnections = true;

		[HideInInspector]
		public bool showNodes = true;

		[HideInInspector]
		public bool checkConnectivity;

		[HideInInspector]
		public bool checkNeed;

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public List<RayfireRigid> rigidList;

		[HideInInspector]
		public RFCluster cluster;

		[NonSerialized]
		private bool childrenChanged;

		private void Awake()
		{
			SetByChildren();
		}

		private void Start()
		{
			if (rigidList.Count == 0)
			{
				UnityEngine.Debug.Log("RayFire Connectivity: " + base.name + " has no objects to check for connectivity. Connectivity disabled.", base.gameObject);
				return;
			}
			RayfireRigid component = GetComponent<RayfireRigid>();
			if (component != null && component.objectType != ObjectType.MeshRoot)
			{
				UnityEngine.Debug.Log("RayFire Connectivity: " + base.name + " object has Rigid component but object type is not Mesh Root. Connectivity disabled.", base.gameObject);
				return;
			}
			StartCoroutine(ChildrenCor());
			StartCoroutine(ConnectivityCor());
		}

		private void OnTransformChildrenChanged()
		{
			childrenChanged = true;
		}

		private IEnumerator ChildrenCor()
		{
			bool checkChildren = true;
			while (checkChildren)
			{
				if (childrenChanged)
				{
					CheckConnectivity();
				}
				yield return null;
			}
		}

		private void ChildrenCHeck()
		{
			for (int num = cluster.shards.Count - 1; num >= 0; num--)
			{
				if (cluster.shards[num].tm == null)
				{
					if (cluster.shards[num].neibShards.Count > 0)
					{
						for (int i = 0; i < cluster.shards[num].neibShards.Count; i++)
						{
							for (int j = 0; j < cluster.shards[num].neibShards[i].neibShards.Count; j++)
							{
								if (cluster.shards[num].neibShards[i].neibShards[j] == cluster.shards[num])
								{
									cluster.shards[num].neibShards[i].neibShards.RemoveAt(j);
									cluster.shards[num].neibShards[i].nArea.RemoveAt(j);
									cluster.shards[num].neibShards[i].nIds.RemoveAt(j);
									break;
								}
							}
						}
					}
					cluster.shards.RemoveAt(num);
				}
			}
			childrenChanged = false;
		}

		public void SetByChildren()
		{
			List<Transform> list = new List<Transform>();
			for (int i = 0; i < base.transform.childCount; i++)
			{
				list.Add(base.transform.GetChild(i));
			}
			SetConnectivity(list);
		}

		private void SetConnectivity(List<Transform> tmList)
		{
			SetRigids(tmList);
			SetCluster(tmList);
		}

		private void SetRigids(List<Transform> tmList)
		{
			if (tmList.Count == 0)
			{
				return;
			}
			rigidList = new List<RayfireRigid>();
			for (int i = 0; i < tmList.Count; i++)
			{
				RayfireRigid component = tmList[i].GetComponent<RayfireRigid>();
				if (component != null && (component.simulationType == SimType.Inactive || component.simulationType == SimType.Kinematic) && component.activation.byConnectivity)
				{
					rigidList.Add(component);
				}
			}
			if (rigidList.Count != 0)
			{
				for (int j = 0; j < rigidList.Count; j++)
				{
					rigidList[j].activation.connect = this;
				}
			}
		}

		private void SetCluster(List<Transform> tmList)
		{
			if (cluster == null)
			{
				cluster = new RFCluster();
			}
			if (cluster.shards.Count > 0)
			{
				InitShards(rigidList, cluster);
			}
			if (cluster.shards.Count == 0)
			{
				cluster = new RFCluster();
				cluster.id = RFCluster.GetUniqClusterId(cluster);
				cluster.tm = base.transform;
				cluster.depth = 0;
				cluster.pos = base.transform.position;
				cluster.initialized = true;
				cluster.demolishable = demolishable;
				if (UnityEngine.Application.isPlaying)
				{
					SetShardsByRigids(cluster, rigidList, type);
				}
				else
				{
					RFShard.SetShardsByTransforms(cluster, tmList, type);
				}
				RFShard.SetShardNeibs(cluster.shards, type, minimumArea, minimumSize, percentage, seed);
				RFCollapse.SetRangeData(cluster, percentage, seed);
			}
		}

		private static void SetShardsByRigids(RFCluster cluster, List<RayfireRigid> rigidList, ConnectivityType connectivity)
		{
			for (int i = 0; i < rigidList.Count; i++)
			{
				MeshFilter component = rigidList[i].GetComponent<MeshFilter>();
				if (!(component == null))
				{
					RFShard rFShard = new RFShard(rigidList[i].transform, i);
					rFShard.cluster = cluster;
					rFShard.rigid = rigidList[i];
					rFShard.uny = rigidList[i].activation.unyielding;
					rFShard.col = rigidList[i].physics.meshCollider;
					if (connectivity == ConnectivityType.ByMesh)
					{
						RFTriangle.SetTriangles(rFShard, component);
					}
					cluster.shards.Add(rFShard);
				}
			}
		}

		public static void InitShards(List<RayfireRigid> rigids, RFCluster cluster)
		{
			if (cluster.initialized)
			{
				return;
			}
			if (cluster.shards.Count != rigids.Count)
			{
				cluster.shards.Clear();
				return;
			}
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				if (rigids[i] != null)
				{
					cluster.shards[i].rigid = rigids[i];
					cluster.shards[i].uny = rigids[i].activation.unyielding;
				}
				cluster.shards[i].cluster = cluster;
				cluster.shards[i].neibShards = new List<RFShard>();
				for (int j = 0; j < cluster.shards[i].nIds.Count; j++)
				{
					cluster.shards[i].neibShards.Add(cluster.shards[cluster.shards[i].nIds[j]]);
				}
			}
			cluster.initialized = true;
		}

		private IEnumerator ConnectivityCor()
		{
			checkConnectivity = true;
			while (checkConnectivity)
			{
				if (childrenChanged)
				{
					ChildrenCHeck();
				}
				if (checkNeed)
				{
					CheckConnectivity();
				}
				yield return null;
			}
		}

		public void CheckConnectivity()
		{
			checkNeed = false;
			CleanUpActivatedShards(cluster);
			if (cluster.shards.Count == 0)
			{
				return;
			}
			RFShard.ReinitNeibs(cluster.shards);
			List<RFShard> list = new List<RFShard>();
			RFCluster.GetSoloShards(cluster, list);
			RFShard.ReinitNeibs(cluster.shards);
			RFCluster.ConnectivityCheck(cluster);
			CheckUnyielding(cluster);
			if (list.Count > 0)
			{
				for (int i = 0; i < list.Count; i++)
				{
					list[i].rigid.Activate();
				}
			}
			if (cluster.HasChildClusters)
			{
				if (clusterize)
				{
					Clusterize();
				}
				else
				{
					for (int j = 0; j < cluster.childClusters.Count; j++)
					{
						for (int k = 0; k < cluster.childClusters[j].shards.Count; k++)
						{
							cluster.childClusters[j].shards[k].rigid.Activate();
						}
					}
				}
			}
			if (cluster.shards.Count == 0)
			{
				checkConnectivity = false;
			}
		}

		private void Clusterize()
		{
			for (int i = 0; i < cluster.childClusters.Count; i++)
			{
				cluster.demolishable = demolishable;
				cluster.childClusters[i].bound = RFCluster.GetShardsBound(cluster.childClusters[i].shards);
				cluster.childClusters[i].shards[0].rigid.simulationType = SimType.Dynamic;
				cluster.childClusters[i].shards[0].rigid.objectType = ObjectType.ConnectedCluster;
				RFDemolitionCluster.CreateClusterRuntime(cluster.childClusters[i].shards[0].rigid, cluster.childClusters[i]);
				cluster.childClusters[i].shards[0].rigid.objectType = ObjectType.Mesh;
				cluster.childClusters[i].rigid.clusterDemolition.cn = showConnections;
				cluster.childClusters[i].rigid.clusterDemolition.nd = showNodes;
				for (int j = 0; j < cluster.childClusters[i].shards.Count; j++)
				{
					UnityEngine.Object.Destroy(cluster.childClusters[i].shards[j].rigid.physics.rigidBody);
					UnityEngine.Object.Destroy(cluster.childClusters[i].shards[j].rigid);
				}
			}
		}

		private static void CleanUpActivatedShards(RFCluster cluster)
		{
			for (int num = cluster.shards.Count - 1; num >= 0; num--)
			{
				if (cluster.shards[num].rigid == null || cluster.shards[num].rigid.activation.connect == null || cluster.shards[num].rigid.limitations.demolished)
				{
					cluster.shards[num].cluster = null;
					cluster.shards.RemoveAt(num);
				}
			}
		}

		private static void CheckUnyielding(RFCluster cluster)
		{
			if (!cluster.HasChildClusters)
			{
				return;
			}
			for (int num = cluster.childClusters.Count - 1; num >= 0; num--)
			{
				if (cluster.childClusters[num].UnyieldingByRigid)
				{
					cluster.shards.AddRange(cluster.childClusters[num].shards);
					cluster.childClusters.RemoveAt(num);
				}
			}
			for (int i = 0; i < cluster.shards.Count; i++)
			{
				cluster.shards[i].cluster = cluster;
			}
		}
	}
	[SelectionBase]
	[AddComponentMenu("RayFire/Rayfire Debris")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-debris-component/")]
	public class RayfireDebris : MonoBehaviour
	{
		[Header("  Emit Debris")]
		[Space(3f)]
		public bool onDemolition;

		[Space(1f)]
		public bool onActivation;

		[Space(1f)]
		public bool onImpact;

		[Header("  Main")]
		[Space(3f)]
		public GameObject debrisReference;

		[Space(2f)]
		public Material debrisMaterial;

		[Space(2f)]
		public Material emissionMaterial;

		[Header("  Properties")]
		[Space(3f)]
		public RFParticleEmission emission;

		[Space(2f)]
		public RFParticleDynamicDebris dynamic;

		[Space(2f)]
		public RFParticleNoise noise;

		[Space(2f)]
		public RFParticleCollisionDebris collision;

		[Space(2f)]
		public RFParticleLimitations limitations;

		[Space(2f)]
		public RFParticleRendering rendering;

		[HideInInspector]
		public RayfireRigid rigid;

		[HideInInspector]
		public ParticleSystem pSystem;

		[HideInInspector]
		public Transform hostTm;

		[HideInInspector]
		public bool initialized;

		[HideInInspector]
		public List<Mesh> debrisMeshList;

		[HideInInspector]
		public Vector3 refScale = Vector3.one;

		[HideInInspector]
		public List<RayfireDebris> children;

		[HideInInspector]
		public int amountFinal;

		[HideInInspector]
		public bool oldChild;

		public bool HasChildren
		{
			get
			{
				if (children != null)
				{
					return children.Count > 0;
				}
				return false;
			}
		}

		public RayfireDebris()
		{
			onDemolition = false;
			onActivation = false;
			onImpact = false;
			debrisReference = null;
			debrisMaterial = null;
			emissionMaterial = null;
			emission = new RFParticleEmission();
			dynamic = new RFParticleDynamicDebris();
			noise = new RFParticleNoise();
			collision = new RFParticleCollisionDebris();
			limitations = new RFParticleLimitations();
			rendering = new RFParticleRendering();
			debrisMeshList = new List<Mesh>();
			hostTm = null;
			initialized = false;
			amountFinal = 0;
		}

		public void CopyFrom(RayfireDebris source)
		{
			onDemolition = source.onDemolition;
			onActivation = source.onActivation;
			onImpact = source.onImpact;
			debrisReference = source.debrisReference;
			debrisMaterial = source.debrisMaterial;
			emissionMaterial = source.emissionMaterial;
			emission.CopyFrom(source.emission);
			dynamic.CopyFrom(source.dynamic);
			noise.CopyFrom(source.noise);
			collision.CopyFrom(source.collision);
			limitations.CopyFrom(source.limitations);
			rendering.CopyFrom(source.rendering);
			debrisMeshList = source.debrisMeshList;
			initialized = source.initialized;
		}

		public void Initialize()
		{
			if (!initialized)
			{
				SetReferenceMeshes(debrisReference);
			}
		}

		public void Emit()
		{
			Initialize();
			if (initialized)
			{
				collision.SetMaterialProps(this);
				ParticleSystem ps = RFParticles.CreateParticleSystemDebris(this);
				MeshFilter component = GetComponent<MeshFilter>();
				int emissionMatIndex = RFParticles.GetEmissionMatIndex(GetComponent<MeshRenderer>(), emissionMaterial);
				amountFinal = 30;
				CreateDebris(base.transform, this, component, emissionMatIndex, ps);
			}
		}

		public void CreateDebris(Transform host, RayfireDebris scr, MeshFilter emitMeshFilter, int emitMatIndex, ParticleSystem ps)
		{
			RFParticles.SetMain(ps.main, scr.emission.lifeMin, scr.emission.lifeMax, scr.emission.sizeMin, scr.emission.sizeMax, scr.dynamic.gravityMin, scr.dynamic.gravityMax, scr.dynamic.speedMin, scr.dynamic.speedMax, 3.1f, scr.limitations.maxParticles, scr.emission.duration);
			RFParticles.SetEmission(ps.emission, scr.emission.distanceRate, scr.amountFinal);
			if (emitMeshFilter != null)
			{
				RFParticles.SetShapeMesh(ps.shape, emitMeshFilter.sharedMesh, emitMatIndex, emitMeshFilter.transform.localScale);
			}
			else
			{
				RFParticles.SetShapeObject(ps.shape);
			}
			RFParticles.SetVelocity(ps.inheritVelocity, scr.dynamic);
			RFParticles.SetSizeOverLifeTime(ps.sizeOverLifetime, scr.refScale);
			RFParticles.SetRotationBySpeed(ps.rotationBySpeed, scr.dynamic.rotationSpeed);
			RFParticles.SetCollisionDebris(ps.collision, scr.collision);
			RFParticles.SetNoise(ps.noise, scr.noise);
			SetParticleRendererDebris(ps.GetComponent<ParticleSystemRenderer>(), scr);
			ps.Play();
		}

		public void SetParticleRendererDebris(ParticleSystemRenderer rend, RayfireDebris scr)
		{
			rend.renderMode = ParticleSystemRenderMode.Mesh;
			rend.alignment = ParticleSystemRenderSpace.World;
			if (scr.debrisMeshList.Count > 0)
			{
				if (scr.debrisMeshList.Count <= 4)
				{
					rend.SetMeshes(scr.debrisMeshList.ToArray());
					rend.mesh = scr.debrisMeshList[0];
				}
				else
				{
					List<Mesh> list = new List<Mesh>();
					for (int i = 0; i < 4; i++)
					{
						list.Add(scr.debrisMeshList[UnityEngine.Random.Range(0, scr.debrisMeshList.Count)]);
					}
					rend.SetMeshes(list.ToArray());
					rend.mesh = list[0];
				}
			}
			rend.sharedMaterial = scr.debrisMaterial;
			rend.shadowCastingMode = (scr.rendering.castShadows ? ShadowCastingMode.On : ShadowCastingMode.Off);
			rend.receiveShadows = scr.rendering.receiveShadows;
		}

		private void SetReferenceMeshes(GameObject refs)
		{
			debrisMeshList = new List<Mesh>();
			if (refs == null)
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Debris reference not defined.", base.gameObject);
				return;
			}
			List<MeshFilter> list = new List<MeshFilter>();
			MeshFilter component = refs.GetComponent<MeshFilter>();
			if (component != null)
			{
				list.Add(component);
			}
			if (refs.transform.childCount > 0)
			{
				list.AddRange(refs.GetComponentsInChildren<MeshFilter>().ToList());
			}
			if (list.Count == 0)
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Debris reference mesh is not defined.", base.gameObject);
				return;
			}
			debrisMeshList = (from mf in list
				where mf.sharedMesh != null && mf.sharedMesh.vertexCount > 3
				select mf.sharedMesh).ToList();
			if (debrisMeshList.Count == 0)
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Debris reference mesh is not defined.", base.gameObject);
				return;
			}
			SetDebrisMaterial(list);
			refScale = list[0].transform.lossyScale;
			initialized = true;
		}

		private void SetDebrisMaterial(List<MeshFilter> mfs)
		{
			if (debrisMaterial != null)
			{
				return;
			}
			for (int i = 0; i < mfs.Count; i++)
			{
				Renderer component = mfs[i].GetComponent<Renderer>();
				if (component != null && component.sharedMaterial != null)
				{
					debrisMaterial = component.sharedMaterial;
					return;
				}
			}
			if (debrisMaterial == null)
			{
				debrisMaterial = GetComponent<Renderer>().sharedMaterial;
			}
		}
	}
	[SelectionBase]
	[AddComponentMenu("RayFire/Rayfire Dust")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-dust-component/")]
	public class RayfireDust : MonoBehaviour
	{
		[Header("  Emit Dust")]
		[Space(3f)]
		public bool onDemolition;

		[Space(1f)]
		public bool onActivation;

		[Space(1f)]
		public bool onImpact;

		[Header("  Main")]
		[Space(3f)]
		[Range(0.01f, 1f)]
		public float opacity;

		[Space(2f)]
		public Material dustMaterial;

		[Space(2f)]
		public Material[] dustMaterials;

		[Space(2f)]
		public Material emissionMaterial;

		[Header("  Properties")]
		[Space(3f)]
		public RFParticleEmission emission;

		[Space(2f)]
		public RFParticleDynamicDust dynamic;

		[Space(2f)]
		public RFParticleNoise noise;

		[Space(2f)]
		public RFParticleCollisionDust collision;

		[Space(2f)]
		public RFParticleLimitations limitations;

		[Space(2f)]
		public RFParticleRendering rendering;

		[HideInInspector]
		public RayfireRigid rigid;

		[HideInInspector]
		public ParticleSystem pSystem;

		[HideInInspector]
		public Transform hostTm;

		[HideInInspector]
		public bool initialized;

		[HideInInspector]
		public List<RayfireDust> children;

		[HideInInspector]
		public int amountFinal;

		[HideInInspector]
		public bool oldChild;

		public bool HasChildren
		{
			get
			{
				if (children != null)
				{
					return children.Count > 0;
				}
				return false;
			}
		}

		public RayfireDust()
		{
			onDemolition = true;
			onActivation = false;
			onImpact = false;
			dustMaterial = null;
			opacity = 0.25f;
			emissionMaterial = null;
			emission = new RFParticleEmission();
			dynamic = new RFParticleDynamicDust();
			noise = new RFParticleNoise();
			collision = new RFParticleCollisionDust();
			limitations = new RFParticleLimitations();
			rendering = new RFParticleRendering();
			hostTm = null;
			initialized = false;
			amountFinal = 5;
		}

		public void CopyFrom(RayfireDust source)
		{
			onDemolition = source.onDemolition;
			onActivation = source.onActivation;
			onImpact = source.onImpact;
			opacity = source.opacity;
			dustMaterial = source.dustMaterial;
			dustMaterials = source.dustMaterials;
			emissionMaterial = source.emissionMaterial;
			emission.CopyFrom(source.emission);
			dynamic.CopyFrom(source.dynamic);
			noise.CopyFrom(source.noise);
			collision.CopyFrom(source.collision);
			limitations.CopyFrom(source.limitations);
			rendering.CopyFrom(source.rendering);
			initialized = source.initialized;
		}

		public void Initialize()
		{
			if (dustMaterial == null && (dustMaterials == null || dustMaterials.Length == 0))
			{
				UnityEngine.Debug.Log(base.gameObject.name + ": Dust material not defined.", base.gameObject);
				initialized = false;
			}
			else
			{
				initialized = true;
			}
		}

		public void Emit()
		{
			Initialize();
			if (initialized)
			{
				ParticleSystem ps = RFParticles.CreateParticleSystemDust(this);
				MeshFilter component = GetComponent<MeshFilter>();
				int emissionMatIndex = RFParticles.GetEmissionMatIndex(GetComponent<MeshRenderer>(), emissionMaterial);
				amountFinal = 30;
				CreateDust(base.transform, this, component, emissionMatIndex, ps);
			}
		}

		public void CreateDust(Transform host, RayfireDust scr, MeshFilter emitMeshFilter, int emitMatIndex, ParticleSystem ps)
		{
			RFParticles.SetMain(ps.main, scr.emission.lifeMin, scr.emission.lifeMax, scr.emission.sizeMin, scr.emission.sizeMax, scr.dynamic.gravityMin, scr.dynamic.gravityMax, scr.dynamic.speedMin, scr.dynamic.speedMax, 6f, scr.limitations.maxParticles, scr.emission.duration);
			RFParticles.SetEmission(ps.emission, scr.emission.distanceRate, (short)scr.amountFinal);
			if (emitMeshFilter != null)
			{
				RFParticles.SetShapeMesh(ps.shape, emitMeshFilter.sharedMesh, emitMatIndex, emitMeshFilter.transform.localScale);
			}
			else
			{
				RFParticles.SetShapeObject(ps.shape);
			}
			RFParticles.SetCollisionDust(ps.collision, scr.collision);
			RFParticles.SetColorOverLife(ps.colorOverLifetime, scr.opacity);
			RFParticles.SetRotationOverLifeTime(ps.rotationOverLifetime, scr.dynamic);
			RFParticles.SetNoise(ps.noise, scr.noise);
			SetParticleRendererDust(ps.GetComponent<ParticleSystemRenderer>(), scr.dustMaterial, scr.dustMaterials, scr.rendering.castShadows, scr.rendering.receiveShadows);
			ps.Play();
		}

		public void SetParticleRendererDust(ParticleSystemRenderer rend, Material material, Material[] materials, bool cast, bool receive)
		{
			rend.renderMode = ParticleSystemRenderMode.Billboard;
			rend.alignment = ParticleSystemRenderSpace.World;
			rend.normalDirection = 1f;
			if (materials != null && materials.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, materials.Length);
				rend.sharedMaterial = materials[num];
			}
			else
			{
				rend.sharedMaterial = material;
			}
			rend.shadowCastingMode = (cast ? ShadowCastingMode.On : ShadowCastingMode.Off);
			rend.receiveShadows = receive;
			rend.sortMode = ParticleSystemSortMode.OldestInFront;
			rend.minParticleSize = 0.0001f;
			rend.maxParticleSize = 999999f;
			rend.alignment = ParticleSystemRenderSpace.Facing;
		}

		private void SetMaterialDust(ParticleSystemRenderer rend, List<Material> mats)
		{
			if (mats.Count == 0)
			{
				UnityEngine.Debug.Log("Define dust material");
			}
			else if (mats.Count == 1)
			{
				rend.sharedMaterial = mats[0];
			}
			else
			{
				rend.sharedMaterial = mats[UnityEngine.Random.Range(0, mats.Count - 1)];
			}
		}
	}
	[AddComponentMenu("RayFire/Rayfire Gun")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-gun-component/")]
	public class RayfireGun : MonoBehaviour
	{
		[Header("  Properties")]
		[Space(3f)]
		public AxisType axis;

		[Space(1f)]
		[Range(0f, 100f)]
		public float maxDistance = 50f;

		[Space(1f)]
		public Transform target;

		[Header("  Burst")]
		[Space(3f)]
		[Range(2f, 20f)]
		public int rounds = 1;

		[Space(1f)]
		[Range(0.01f, 5f)]
		public float rate = 0.3f;

		[Header("  Impact")]
		[Space(3f)]
		[Range(0f, 2f)]
		public float strength = 1f;

		[Space(1f)]
		[Range(0f, 10f)]
		public float radius = 1f;

		[Space(1f)]
		public bool affectInactive = true;

		[Space(1f)]
		public bool demolishCluster = true;

		[Space(1f)]
		public bool affectRigidBodies = true;

		[Header("  Damage")]
		[Space(3f)]
		[Range(0f, 100f)]
		public float damage = 1f;

		[Header("  Vfx")]
		[Space(3f)]
		public bool debris = true;

		[Space(1f)]
		public bool dust = true;

		[Space(1f)]
		public bool flash = true;

		[Header("  Properties")]
		[Space(2f)]
		public RFFlash Flash = new RFFlash();

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		[HideInInspector]
		public bool showRay = true;

		[HideInInspector]
		public bool showHit = true;

		[HideInInspector]
		public bool shooting;

		private static string untagged = "Untagged";

		public RFShotEvent shotEvent = new RFShotEvent();

		private Collider[] impactColliders;

		public Vector3 ShootVector
		{
			get
			{
				if (target != null)
				{
					return (target.position - base.transform.position).normalized;
				}
				if (axis == AxisType.XRed)
				{
					return base.transform.right;
				}
				if (axis == AxisType.YGreen)
				{
					return base.transform.up;
				}
				if (axis == AxisType.ZBlue)
				{
					return base.transform.forward;
				}
				return base.transform.up;
			}
		}

		public void StartShooting()
		{
			if (!shooting)
			{
				StartCoroutine(StartShootCor());
			}
		}

		private IEnumerator StartShootCor()
		{
			int shootId = 0;
			shooting = true;
			while (shooting)
			{
				Shoot(shootId);
				shootId++;
				yield return new WaitForSeconds(rate);
			}
		}

		public void StopShooting()
		{
			shooting = false;
		}

		public void Shoot(int shootId = 1)
		{
			Vector3 shootVector = ShootVector;
			if (shootId > 1)
			{
				shootVector = ShootVector;
			}
			Vector3 position = base.transform.position;
			Shoot(position, shootVector);
		}

		public void Shoot(Vector3 shootPos, Vector3 shootVector)
		{
			shotEvent.InvokeLocalEvent(this);
			RFShotEvent.InvokeGlobalEvent(this);
			if (Physics.Raycast(shootPos, shootVector, out var hitInfo, maxDistance, mask, QueryTriggerInteraction.Ignore) && (!(tagFilter != untagged) || CompareTag(hitInfo.transform.tag)))
			{
				Vector3 point = hitInfo.point;
				Vector3 normal = hitInfo.normal;
				ImpactFlash(point, normal);
				RayfireRigid rayfireRigid = ((hitInfo.collider.attachedRigidbody == null) ? hitInfo.collider.GetComponent<RayfireRigid>() : hitInfo.collider.attachedRigidbody.transform.GetComponent<RayfireRigid>());
				if (rayfireRigid != null)
				{
					ImpactDebris(rayfireRigid, point, normal);
					ImpactDust(rayfireRigid, point, normal);
					rayfireRigid = ImpactDamage(rayfireRigid, hitInfo, shootPos, shootVector, point);
				}
				if (!(rayfireRigid == null))
				{
					ImpactHit(rayfireRigid, hitInfo, point, shootVector);
				}
			}
		}

		private void ImpactHit(RayfireRigid rigid, RaycastHit hit, Vector3 impactPoint, Vector3 shootVector)
		{
			List<Rigidbody> list = new List<Rigidbody>();
			if (radius == 0f)
			{
				if (rigid.objectType == ObjectType.Mesh && (rigid.simulationType == SimType.Inactive || rigid.simulationType == SimType.Kinematic) && rigid.activation.byImpact)
				{
					rigid.Activate();
				}
				if (rigid.objectType == ObjectType.ConnectedCluster && demolishCluster)
				{
					RFDemolitionCluster.DemolishConnectedCluster(rigid, new Collider[1] { hit.collider });
				}
				list.Add(hit.collider.attachedRigidbody);
			}
			if (radius > 0f)
			{
				impactColliders = null;
				impactColliders = Physics.OverlapSphere(impactPoint, radius, mask);
				_ = tagFilter != untagged;
				if (impactColliders == null)
				{
					return;
				}
				if (rigid.objectType == ObjectType.ConnectedCluster && demolishCluster)
				{
					RFDemolitionCluster.DemolishConnectedCluster(rigid, impactColliders);
				}
				List<RayfireRigid> list2 = new List<RayfireRigid>();
				for (int i = 0; i < impactColliders.Length; i++)
				{
					RayfireRigid rayfireRigid = ((impactColliders[i].attachedRigidbody == null) ? impactColliders[i].GetComponent<RayfireRigid>() : impactColliders[i].attachedRigidbody.transform.GetComponent<RayfireRigid>());
					if (rayfireRigid != null)
					{
						if (!list2.Contains(rayfireRigid))
						{
							list2.Add(rayfireRigid);
						}
					}
					else if (affectRigidBodies && impactColliders[i].attachedRigidbody == null && !list.Contains(impactColliders[i].attachedRigidbody))
					{
						list.Add(impactColliders[i].attachedRigidbody);
					}
				}
				for (int j = 0; j < list2.Count; j++)
				{
					if (list2[j].activation.byImpact && (list2[j].simulationType == SimType.Inactive || list2[j].simulationType == SimType.Kinematic))
					{
						list2[j].Activate();
					}
				}
				if (strength > 0f)
				{
					for (int k = 0; k < list2.Count; k++)
					{
						if (list2[k].simulationType != SimType.Inactive || affectInactive)
						{
							list.Add(list2[k].physics.rigidBody);
						}
					}
				}
			}
			if (strength == 0f || list.Count == 0)
			{
				return;
			}
			for (int l = 0; l < list.Count; l++)
			{
				if (!(list[l] == null) && !list[l].isKinematic)
				{
					list[l].AddForceAtPosition(shootVector * strength, impactPoint, ForceMode.VelocityChange);
				}
			}
		}

		private RayfireRigid ImpactDamage(RayfireRigid scrRigid, RaycastHit hit, Vector3 shootPos, Vector3 shootVector, Vector3 impactPoint)
		{
			if (damage == 0f || !scrRigid.damage.enable)
			{
				return scrRigid;
			}
			if (!scrRigid.ApplyDamage(damage, impactPoint, radius))
			{
				return scrRigid;
			}
			if (scrRigid.HasFragments && Physics.Raycast(shootPos, shootVector, out hit, maxDistance, mask, QueryTriggerInteraction.Ignore))
			{
				if (hit.collider.attachedRigidbody != null)
				{
					return hit.collider.attachedRigidbody.transform.GetComponent<RayfireRigid>();
				}
				if (hit.collider != null)
				{
					return hit.collider.transform.GetComponent<RayfireRigid>();
				}
			}
			return null;
		}

		public void Burst()
		{
			if (!shooting)
			{
				StartCoroutine(BurstCor());
			}
		}

		private IEnumerator BurstCor()
		{
			shooting = true;
			for (int i = 0; i < rounds; i++)
			{
				if (!shooting)
				{
					break;
				}
				Shoot(i);
				yield return new WaitForSeconds(rate);
			}
		}

		private void ImpactFlash(Vector3 position, Vector3 normal)
		{
			if (flash)
			{
				Vector3 position2 = normal * Flash.distance + position;
				GameObject obj = new GameObject("impactFlash");
				obj.transform.position = position2;
				Light light = obj.AddComponent<Light>();
				light.color = Flash.color;
				light.intensity = UnityEngine.Random.Range(Flash.intensityMin, Flash.intensityMax);
				light.range = UnityEngine.Random.Range(Flash.rangeMin, Flash.rangeMax);
				light.shadows = LightShadows.Hard;
				UnityEngine.Object.Destroy(obj, 0.2f);
			}
		}

		private void ImpactDebris(RayfireRigid source, Vector3 impactPos, Vector3 impactNormal)
		{
			if (!debris || !source.HasDebris)
			{
				return;
			}
			for (int i = 0; i < source.debrisList.Count; i++)
			{
				if (source.debrisList[i].onImpact)
				{
					RFParticles.CreateDebrisImpact(source.debrisList[i], impactPos, impactNormal);
				}
			}
		}

		private void ImpactDust(RayfireRigid source, Vector3 impactPos, Vector3 impactNormal)
		{
			if (!dust || !source.HasDust)
			{
				return;
			}
			for (int i = 0; i < source.dustList.Count; i++)
			{
				if (source.dustList[i].onImpact)
				{
					RFParticles.CreateDustImpact(source.dustList[i], impactPos, impactNormal);
				}
			}
		}

		private List<RayfireRigid> ActivationCheck(RayfireRigid scrTarget, Vector3 position)
		{
			List<RayfireRigid> list = new List<RayfireRigid>();
			if (scrTarget != null)
			{
				list.Add(scrTarget);
			}
			if (radius > 0f)
			{
				Collider[] array = Physics.OverlapSphere(position, radius, mask);
				for (int i = 0; i < array.Length; i++)
				{
					if (!(tagFilter != untagged) || array[i].CompareTag(tagFilter))
					{
						RayfireRigid component = array[i].gameObject.GetComponent<RayfireRigid>();
						if (component != null && !list.Contains(component))
						{
							list.Add(component);
						}
					}
				}
			}
			for (int j = 0; j < list.Count; j++)
			{
				if ((list[j].simulationType == SimType.Inactive || list[j].simulationType == SimType.Kinematic) && list[j].activation.byImpact)
				{
					list[j].Activate();
				}
			}
			return list;
		}
	}
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Man")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-man-component/")]
	public class RayfireMan : MonoBehaviour
	{
		public static RayfireMan inst;

		[Header("  Gravity")]
		[Space(3f)]
		public bool setGravity;

		[Space(2f)]
		[Range(0f, 1f)]
		public float multiplier = 1f;

		[Header("  Physics")]
		[Space(3f)]
		public CollisionDetectionMode collisionDetection = CollisionDetectionMode.ContinuousDynamic;

		[Header("  Materials")]
		[Space(3f)]
		[Range(0f, 1f)]
		public float minimumMass = 0.1f;

		[Space(2f)]
		[Range(0f, 400f)]
		public float maximumMass = 400f;

		[Space(2f)]
		public RFMaterialPresets materialPresets = new RFMaterialPresets();

		[Header("  Demolition")]
		[Space(3f)]
		[Range(0f, 5f)]
		public float globalSolidity = 1f;

		[Space(2f)]
		[UnityEngine.Tooltip("Maximum time in milliseconds per frame allowed to be used for demolitions. Off if 0.")]
		[Range(0f, 0.1f)]
		public float timeQuota = 0.033f;

		[Space(2f)]
		public RFManDemolition advancedDemolitionProperties = new RFManDemolition();

		[Header("  Pooling")]
		[Space(3f)]
		public RFPoolingFragment fragments = new RFPoolingFragment();

		[Space(2f)]
		public RFPoolingParticles particles = new RFPoolingParticles();

		[Header("  About")]
		[Space(3f)]
		public static int buildMajor = 1;

		public static int buildMinor = 25;

		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public List<string> layers;

		[HideInInspector]
		public float maxTimeThisFrame;

		private List<RayfireRigid> activationOffset = new List<RayfireRigid>();

		private List<RayfireRigid> inactive = new List<RayfireRigid>();

		public static bool MaxAmountCheck => inst.advancedDemolitionProperties.currentAmount < inst.advancedDemolitionProperties.maximumAmount;

		private void Awake()
		{
			SetInstance();
		}

		private void LateUpdate()
		{
			maxTimeThisFrame = 0f;
		}

		private void SetInstance()
		{
			if (inst == null)
			{
				inst = this;
			}
			if (inst != null)
			{
				if (inst == this)
				{
					SetVariables();
					StartPooling();
				}
				if (inst != this)
				{
					UnityEngine.Object.Destroy(base.gameObject);
				}
			}
		}

		private void SetVariables()
		{
			transForm = GetComponent<Transform>();
			advancedDemolitionProperties.currentAmount = 0;
			SetGravity();
			materialPresets.SetMaterials();
			SetLayers();
		}

		private void SetGravity()
		{
			if (setGravity)
			{
				Physics.gravity = -9.81f * multiplier * Vector3.up;
			}
		}

		public static void RayFireManInit()
		{
			if (inst == null)
			{
				inst = new GameObject("RayFireMan").AddComponent<RayfireMan>();
			}
			EditorCreate();
		}

		private static void EditorCreate()
		{
			if (!UnityEngine.Application.isPlaying)
			{
				inst.SetInstance();
			}
		}

		private void SetLayers()
		{
			layers = new List<string>();
			for (int i = 0; i < 32; i++)
			{
				string text = LayerMask.LayerToName(i);
				if (text.Length > 0)
				{
					layers.Add(text);
				}
			}
		}

		private void StartPooling()
		{
			fragments.CreatePoolRoot(base.transform);
			fragments.CreateInstance(base.transform);
			if (UnityEngine.Application.isPlaying && fragments.enable)
			{
				StartCoroutine(fragments.StartPoolingCor(transForm));
			}
			particles.CreatePoolRoot(base.transform);
			particles.CreateInstance(base.transform);
			if (UnityEngine.Application.isPlaying && particles.enable)
			{
				StartCoroutine(particles.StartPoolingCor(transForm));
			}
		}

		public static void DestroyFragment(RayfireRigid scr, Transform tm, float time = 0f)
		{
			if (UnityEngine.Application.isPlaying)
			{
				inst.advancedDemolitionProperties.currentAmount--;
			}
			scr.gameObject.SetActive(value: false);
			if (scr.reset.action == RFReset.PostDemolitionType.DestroyWithDelay)
			{
				DestroyOp(scr, tm, time);
			}
			else if (scr.reset.action == RFReset.PostDemolitionType.DeactivateToReset && scr.objectType == ObjectType.ConnectedCluster && scr.clusterDemolition.cluster.id > 1)
			{
				DestroyOp(scr, tm, time);
			}
		}

		public static void DestroyGo(GameObject go)
		{
			UnityEngine.Object.Destroy(go);
		}

		private static void DestroyOp(RayfireRigid scr, Transform tm, float time = 0f)
		{
			if (time == 0f)
			{
				time = scr.reset.destroyDelay;
			}
			scr.reset.toBeDestroyed = true;
			if (time <= 0f)
			{
				UnityEngine.Object.Destroy(scr.gameObject);
			}
			else
			{
				UnityEngine.Object.Destroy(scr.gameObject, time);
			}
			if (tm != null && tm.childCount == 0)
			{
				UnityEngine.Object.Destroy(tm.gameObject);
			}
		}

		public void AddInactive(RayfireRigid scr)
		{
			int count = inactive.Count;
			inactive.Add(scr);
			if (count == 0)
			{
				StartCoroutine(InactiveCor());
			}
		}

		private IEnumerator InactiveCor()
		{
			while (inactive.Count > 0)
			{
				for (int num = inactive.Count - 1; num >= 0; num--)
				{
					if (inactive[num].simulationType == SimType.Inactive)
					{
						inactive[num].physics.rigidBody.velocity = Vector3.zero;
						inactive[num].physics.rigidBody.angularVelocity = Vector3.zero;
					}
					else
					{
						inactive.RemoveAt(num);
					}
				}
				yield return null;
			}
		}

		public void AddActivationOffset(RayfireRigid scr)
		{
			int count = activationOffset.Count;
			activationOffset.Add(scr);
			if (count == 0)
			{
				StartCoroutine(ActivationOffsetCor());
			}
		}

		private IEnumerator ActivationOffsetCor()
		{
			while (activationOffset.Count > 0)
			{
				for (int num = activationOffset.Count - 1; num >= 0; num--)
				{
					if (!activationOffset[num].activation.activated)
					{
						if (Vector3.Distance(activationOffset[num].transForm.position, activationOffset[num].physics.initPosition) > activationOffset[num].activation.byOffset)
						{
							activationOffset[num].Activate();
						}
					}
					else
					{
						activationOffset.RemoveAt(num);
					}
				}
				yield return null;
			}
		}
	}
	[Serializable]
	public class RFCache
	{
		public string name;

		public List<bool> act;

		public List<Vector3> pos;

		public List<Quaternion> rot;

		public Transform transform;

		public RFCache(Transform parent, Transform tm)
		{
			act = new List<bool>();
			pos = new List<Vector3>();
			rot = new List<Quaternion>();
			transform = tm;
			name = tm.name;
			if (tm.parent != parent)
			{
				Transform parent2 = tm.parent;
				while (parent != parent2)
				{
					name = name.Insert(0, "/");
					name = name.Insert(0, parent2.name);
					parent2 = parent2.parent;
				}
			}
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Recorder")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-recorder-component/")]
	public class RayfireRecorder : MonoBehaviour
	{
		public enum AnimatorType
		{
			None = 0,
			Record = 2,
			Play = 8
		}

		[Space(5f)]
		public AnimatorType mode;

		[Header("  Record Properties")]
		[Space(3f)]
		public bool recordOnStart = true;

		[Space(1f)]
		public string clipName;

		[Space(1f)]
		[Range(0f, 60f)]
		public float duration = 5f;

		[Space(1f)]
		[Range(1f, 60f)]
		public int rate = 15;

		[Space(5f)]
		public bool reduceKeys = true;

		[Space(1f)]
		[Range(0f, 0.5f)]
		public float threshold;

		[Header("  Playback Properties")]
		[Space(3f)]
		public bool playOnStart;

		[Space(1f)]
		public AnimationClip animationClip;

		[Space(1f)]
		public RuntimeAnimatorController controller;

		[Header("  Rigid Playback")]
		[Space(3f)]
		public bool setToKinematic = true;

		[HideInInspector]
		public bool recorder;

		[HideInInspector]
		public float recordedTime;

		private int stateNameHash;

		private string assetFolder;

		private string clipFolder = "RayFireRecords/";

		private float stepTime;

		private Animator animator;

		private List<Transform> tmList;

		private List<RFCache> cacheList;

		private List<float> timeList;

		private void Awake()
		{
			SetVariables();
		}

		private void Start()
		{
			SetRigid();
			if (mode == AnimatorType.Record && recordOnStart)
			{
				StartRecord();
			}
			else if (mode == AnimatorType.Play && playOnStart)
			{
				StartPlay();
			}
		}

		private void SetRigid()
		{
			if (mode != AnimatorType.Play)
			{
				return;
			}
			foreach (RayfireRigid item in base.gameObject.GetComponentsInChildren<RayfireRigid>().ToList())
			{
				if (!item.physics.exclude)
				{
					item.physics.rec = true;
					if (setToKinematic && (item.simulationType != SimType.Static || item.simulationType == SimType.Kinematic))
					{
						item.simulationType = SimType.Kinematic;
						RFPhysic.SetSimulationType(item);
					}
				}
			}
		}

		private void SetVariables()
		{
			if (mode != 0)
			{
				animator = GetComponent<Animator>();
				tmList = base.gameObject.GetComponentsInChildren<Transform>(includeInactive: false).ToList();
				tmList.Remove(base.transform);
				if (tmList.Count == 0)
				{
					UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but object has no children. Mode set to None.", base.gameObject);
					mode = AnimatorType.None;
				}
				else
				{
					SetModeRecord();
					SetModePlay();
				}
			}
		}

		private void SetModeRecord()
		{
			if (mode != AnimatorType.Record)
			{
				return;
			}
			if (animator != null)
			{
				animator.runtimeAnimatorController = null;
			}
			cacheList = new List<RFCache>();
			if (tmList.Count > 0)
			{
				for (int i = 0; i < tmList.Count; i++)
				{
					cacheList.Add(new RFCache(base.transform, tmList[i]));
				}
			}
			timeList = new List<float>();
			stepTime = 1f / (float)rate;
			assetFolder = "Assets/" + clipFolder;
		}

		private void SetModePlay()
		{
			if (mode != AnimatorType.Play)
			{
				return;
			}
			if (controller == null)
			{
				UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but controller is not defined. Mode set to None.", base.gameObject);
				mode = AnimatorType.None;
				return;
			}
			if (animationClip == null)
			{
				UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but animation clip is not defined. Mode set to None.", base.gameObject);
				mode = AnimatorType.None;
				return;
			}
			bool flag = false;
			AnimationClip[] animationClips = controller.animationClips;
			for (int i = 0; i < animationClips.Length; i++)
			{
				if (animationClips[i] == animationClip)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				UnityEngine.Debug.Log("RayFire Record: " + base.gameObject.name + " Mode set to " + mode.ToString() + " but animation clip is not defined in controller. Mode set to None.", base.gameObject);
				mode = AnimatorType.None;
			}
			else
			{
				if (animator == null)
				{
					animator = base.gameObject.AddComponent<Animator>();
				}
				animator.updateMode = AnimatorUpdateMode.AnimatePhysics;
				animator.runtimeAnimatorController = controller;
			}
		}

		private void Reset()
		{
			clipName = base.gameObject.name;
		}

		public void StartRecord()
		{
			if (cacheList.Count != 0)
			{
				StartCoroutine(RecordCor());
			}
		}

		private IEnumerator RecordCor()
		{
			recorder = true;
			while (recorder)
			{
				timeList.Add(recordedTime);
				for (int i = 0; i < tmList.Count; i++)
				{
					if (tmList[i] != null)
					{
						cacheList[i].act.Add(tmList[i].gameObject.activeSelf);
						cacheList[i].pos.Add(tmList[i].localPosition);
						cacheList[i].rot.Add(tmList[i].localRotation);
					}
				}
				recordedTime += stepTime;
				yield return new WaitForSeconds(stepTime);
				if (duration > 0f && recordedTime > duration)
				{
					StopRecord();
				}
			}
		}

		public void StopRecord()
		{
			recorder = false;
		}

		public void StartPlay()
		{
			if (mode == AnimatorType.Play)
			{
				animator.Play(animationClip.name);
			}
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Restriction")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-rrestriction-component/")]
	public class RayfireRestriction : MonoBehaviour
	{
		public enum RFBoundActionType
		{
			Fade = 2,
			Reset = 4,
			PostDemolitionAction = 9
		}

		public enum RFDistanceType
		{
			InitializePosition = 0,
			TargetPosition = 2
		}

		public enum RFBoundTriggerType
		{
			Inside = 0,
			Outside = 2
		}

		[Header("  Properties")]
		[Space(3f)]
		public bool enable;

		[Space(1f)]
		public RFBoundActionType breakAction;

		[Space(1f)]
		[Range(0f, 60f)]
		public float actionDelay;

		[Space(1f)]
		[Range(0.1f, 60f)]
		public float checkInterval;

		[Header("  Distance Restriction")]
		[Space(3f)]
		[Range(0f, 99f)]
		public float distance;

		[Space(1f)]
		public RFDistanceType position;

		[Space(1f)]
		public Transform target;

		[Header("  Trigger Restriction")]
		[Space(3f)]
		public Collider Collider;

		[Space(1f)]
		public RFBoundTriggerType region;

		[HideInInspector]
		public bool broke;

		public RayfireRestriction()
		{
			enable = false;
			checkInterval = 5f;
			breakAction = RFBoundActionType.PostDemolitionAction;
			distance = 30f;
			position = RFDistanceType.InitializePosition;
			target = null;
			Collider = null;
			region = RFBoundTriggerType.Inside;
			Reset();
		}

		public void CopyFrom(RayfireRestriction rest)
		{
			enable = rest.enable;
			checkInterval = rest.checkInterval;
			breakAction = rest.breakAction;
			distance = rest.distance;
			position = rest.position;
			target = rest.target;
			Collider = rest.Collider;
			region = rest.region;
			Reset();
		}

		public void Reset()
		{
			broke = false;
		}

		public static void InitRestriction(RayfireRigid scr)
		{
			if (scr.restriction == null || !scr.restriction.enable || scr.restriction.broke)
			{
				return;
			}
			if (scr.restriction.distance > 0f)
			{
				if (scr.restriction.position == RFDistanceType.InitializePosition)
				{
					scr.StartCoroutine(RestrictionDistanceCor(scr));
				}
				else if (scr.restriction.target != null)
				{
					scr.StartCoroutine(RestrictionDistanceCor(scr));
				}
				else
				{
					UnityEngine.Debug.Log("Target is not defined", scr.gameObject);
				}
			}
			if (scr.restriction.Collider != null)
			{
				if (!scr.restriction.Collider.isTrigger)
				{
					UnityEngine.Debug.Log("Collider is not trigger", scr.gameObject);
				}
				scr.StartCoroutine(RestrictionTriggerCor(scr));
			}
		}

		private static void BrokeRestriction(RayfireRigid scr)
		{
			scr.restriction.broke = true;
			scr.restrictionEvent.InvokeLocalEvent(scr);
			RFRestrictionEvent.InvokeGlobalEvent(scr);
			if (scr.restriction.breakAction == RFBoundActionType.PostDemolitionAction)
			{
				RayfireMan.DestroyFragment(scr, scr.rootParent);
			}
			else if (scr.restriction.breakAction == RFBoundActionType.Fade)
			{
				RFFade.Fade(scr);
			}
			else if (scr.restriction.breakAction == RFBoundActionType.Reset)
			{
				RFReset.ResetRigid(scr);
			}
		}

		private static IEnumerator RestrictionDistanceCor(RayfireRigid scr)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.2f));
			WaitForSeconds intervalDelay = new WaitForSeconds(scr.restriction.checkInterval);
			WaitForSeconds actionDelay = new WaitForSeconds(scr.restriction.actionDelay);
			Vector3 checkPosition = scr.physics.initPosition;
			while (!scr.restriction.broke)
			{
				yield return intervalDelay;
				if (scr.restriction.position == RFDistanceType.TargetPosition && scr.restriction.target != null)
				{
					checkPosition = scr.restriction.target.position;
				}
				if (Vector3.Distance(checkPosition, scr.transForm.position) > scr.restriction.distance)
				{
					if (scr.restriction.actionDelay > 0f)
					{
						yield return actionDelay;
					}
					BrokeRestriction(scr);
				}
			}
		}

		private static IEnumerator RestrictionTriggerCor(RayfireRigid scr)
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.2f));
			WaitForSeconds intervalDelay = new WaitForSeconds(scr.restriction.checkInterval);
			WaitForSeconds actionDelay = new WaitForSeconds(scr.restriction.actionDelay);
			bool brokeState = false;
			while (!scr.restriction.broke)
			{
				yield return intervalDelay;
				if (scr.restriction.Collider == null)
				{
					break;
				}
				Vector3 direction;
				float num;
				bool flag = Physics.ComputePenetration(scr.restriction.Collider, scr.restriction.Collider.transform.position, scr.restriction.Collider.transform.rotation, scr.physics.meshCollider, scr.transForm.position, scr.transForm.rotation, out direction, out num);
				if (!flag && scr.restriction.region == RFBoundTriggerType.Inside)
				{
					brokeState = true;
				}
				else if (flag && scr.restriction.region == RFBoundTriggerType.Outside)
				{
					brokeState = true;
				}
				if (brokeState)
				{
					if (scr.restriction.actionDelay > 0f)
					{
						yield return actionDelay;
					}
					BrokeRestriction(scr);
				}
			}
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Rigid")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-rigid-component/")]
	public class RayfireRigid : MonoBehaviour
	{
		public enum InitType
		{
			ByMethod,
			AtStart
		}

		[Space(2f)]
		public InitType initialization;

		[Header("  Main")]
		[Space(3f)]
		[UnityEngine.Tooltip("Defines behaviour of object during simulation.")]
		public SimType simulationType;

		[Space(2f)]
		public ObjectType objectType;

		[Space(2f)]
		public DemolitionType demolitionType;

		[Header("  Simulation")]
		[Space(3f)]
		public RFPhysic physics = new RFPhysic();

		[Space(2f)]
		public RFActivation activation = new RFActivation();

		[Header("  Demolition")]
		[Space(3f)]
		public RFLimitations limitations = new RFLimitations();

		[Space(2f)]
		public RFDemolitionMesh meshDemolition = new RFDemolitionMesh();

		[Space(2f)]
		public RFDemolitionCluster clusterDemolition = new RFDemolitionCluster();

		[Space(2f)]
		public RFReferenceDemolition referenceDemolition = new RFReferenceDemolition();

		[Space(2f)]
		public RFSurface materials = new RFSurface();

		[Space(2f)]
		public RFDamage damage = new RFDamage();

		[Header("  Common")]
		[Space(3f)]
		public RFFade fading = new RFFade();

		[Space(2f)]
		public RFReset reset = new RFReset();

		[Header("  Info")]
		[HideInInspector]
		public bool initialized;

		[HideInInspector]
		public Mesh[] meshes;

		[HideInInspector]
		public Vector3[] pivots;

		[HideInInspector]
		public RFMesh[] rfMeshes;

		[HideInInspector]
		public List<RFDictionary> subIds;

		[HideInInspector]
		public List<RayfireRigid> fragments;

		[HideInInspector]
		public Quaternion cacheRotation;

		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public Transform rootChild;

		[HideInInspector]
		public Transform rootParent;

		[HideInInspector]
		public MeshFilter meshFilter;

		[HideInInspector]
		public MeshRenderer meshRenderer;

		[HideInInspector]
		public SkinnedMeshRenderer skinnedMeshRend;

		[HideInInspector]
		public List<RayfireDebris> debrisList;

		[HideInInspector]
		public List<RayfireDust> dustList;

		[HideInInspector]
		public RayfireRestriction restriction;

		[HideInInspector]
		public RayfireSound sound;

		public RFDemolitionEvent demolitionEvent = new RFDemolitionEvent();

		public RFActivationEvent activationEvent = new RFActivationEvent();

		public RFRestrictionEvent restrictionEvent = new RFRestrictionEvent();

		public bool HasFragments
		{
			get
			{
				if (fragments != null)
				{
					return fragments.Count > 0;
				}
				return false;
			}
		}

		public bool HasMeshes
		{
			get
			{
				if (meshes != null)
				{
					return meshes.Length != 0;
				}
				return false;
			}
		}

		public bool HasRfMeshes
		{
			get
			{
				if (rfMeshes != null)
				{
					return rfMeshes.Length != 0;
				}
				return false;
			}
		}

		public bool HasDebris
		{
			get
			{
				if (debrisList != null)
				{
					return debrisList.Count > 0;
				}
				return false;
			}
		}

		public bool HasDust
		{
			get
			{
				if (dustList != null)
				{
					return dustList.Count > 0;
				}
				return false;
			}
		}

		private void Awake()
		{
			if (objectType == ObjectType.Mesh && demolitionType == DemolitionType.Runtime && meshDemolition.meshInput == RFDemolitionMesh.MeshInputType.AtStart)
			{
				MeshInput();
			}
			if (initialization == InitType.AtStart)
			{
				Initialize();
			}
		}

		private void OnEnable()
		{
			if (base.gameObject.activeSelf)
			{
				_ = initialized;
			}
		}

		private void AwakeMethods()
		{
			RayfireMan.RayFireManInit();
			SetComponentsBasic();
			RFParticles.SetParticleComponents(this);
			if (!SetRootMesh())
			{
				RFLimitations.Checks(this);
				SetComponentsPhysics();
				if (meshDemolition.meshInput == RFDemolitionMesh.MeshInputType.AtInitialization)
				{
					MeshInput();
				}
				AwakePrecache();
				AwakePrefragment();
			}
		}

		private void StartMethods()
		{
			if (objectType == ObjectType.SkinnedMesh)
			{
				Default();
				if (demolitionType != 0)
				{
					StartCoroutine(limitations.DemolishableCor(this));
				}
				initialized = true;
			}
			if (!physics.exclude)
			{
				SetObjectType();
				StartAllCoroutines();
				initialized = true;
			}
		}

		public void Initialize()
		{
			if (!initialized)
			{
				AwakeMethods();
				StartMethods();
				RFSound.InitializationSound(sound, limitations.bboxSize);
			}
		}

		private bool SetRootMesh()
		{
			if (objectType == ObjectType.MeshRoot)
			{
				if (limitations.demolished || physics.exclude)
				{
					return true;
				}
				List<Transform> list = new List<Transform>();
				for (int i = 0; i < base.transform.childCount; i++)
				{
					list.Add(base.transform.GetChild(i));
				}
				fragments = new List<RayfireRigid>();
				for (int j = 0; j < list.Count; j++)
				{
					if (list[j].GetComponent<MeshFilter>() != null)
					{
						RayfireRigid rayfireRigid = list[j].gameObject.GetComponent<RayfireRigid>();
						if (rayfireRigid == null)
						{
							rayfireRigid = list[j].gameObject.AddComponent<RayfireRigid>();
						}
						fragments.Add(rayfireRigid);
						CopyPropertiesTo(rayfireRigid);
						rayfireRigid.Initialize();
					}
				}
				RayfireShatter.CopyRootMeshShatter(this, fragments);
				RFParticles.CopyRootMeshParticles(this, fragments);
				RFSound.CopyRootMeshSound(this, fragments);
				RayfireUnyielding[] components = base.transform.GetComponents<RayfireUnyielding>();
				for (int k = 0; k < components.Length; k++)
				{
					components[k].SetUnyByOverlap(this);
				}
				demolitionType = DemolitionType.None;
				physics.exclude = true;
				return true;
			}
			return false;
		}

		public void SetComponentsBasic()
		{
			meshDemolition.scrShatter = (meshDemolition.useShatter ? GetComponent<RayfireShatter>() : null);
			transForm = GetComponent<Transform>();
			meshFilter = GetComponent<MeshFilter>();
			meshRenderer = GetComponent<MeshRenderer>();
			skinnedMeshRend = GetComponent<SkinnedMeshRenderer>();
			restriction = GetComponent<RayfireRestriction>();
			sound = GetComponent<RayfireSound>();
			if (sound != null)
			{
				sound.rigid = this;
				sound.Initialize();
			}
			if (meshFilter != null && meshRenderer == null)
			{
				meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
			}
			if (reset.action == RFReset.PostDemolitionType.DeactivateToReset)
			{
				limitations.descendants = new List<RayfireRigid>();
			}
		}

		private void SetComponentsPhysics()
		{
			if (!physics.exclude)
			{
				physics.rigidBody = GetComponent<Rigidbody>();
				physics.meshCollider = GetComponent<Collider>();
				if (objectType == ObjectType.Mesh)
				{
					RFPhysic.SetMeshCollider(this);
				}
				if (objectType == ObjectType.NestedCluster || objectType == ObjectType.ConnectedCluster)
				{
					Clusterize();
				}
				if (simulationType != SimType.Static && physics.rigidBody == null)
				{
					physics.rigidBody = base.gameObject.AddComponent<Rigidbody>();
					physics.rigidBody.collisionDetectionMode = RayfireMan.inst.collisionDetection;
				}
			}
		}

		private void Clusterize()
		{
			if ((objectType != ObjectType.NestedCluster || clusterDemolition.cluster.id <= 1) && !RFDemolitionCluster.Clusterize(this))
			{
				physics.exclude = true;
				UnityEngine.Debug.Log("RayFire Rigid: " + base.name + " has no children with mesh. Object Excluded from simulation.", base.gameObject);
			}
		}

		private void SetObjectType()
		{
			if (objectType == ObjectType.Mesh || objectType == ObjectType.NestedCluster || objectType == ObjectType.ConnectedCluster)
			{
				Default();
				SetPhysics();
			}
		}

		public void Default()
		{
			limitations.Reset();
			meshDemolition.Reset();
			if (clusterDemolition != null)
			{
				clusterDemolition.Reset();
			}
			limitations.birthTime = Time.time + UnityEngine.Random.Range(0f, 0.3f);
			physics.initScale = transForm.localScale;
			physics.initPosition = transForm.position;
			physics.initRotation = transForm.rotation;
			RFLimitations.SetBound(this);
		}

		private void SetPhysics()
		{
			if (!physics.exclude)
			{
				RFPhysic.SetColliderMaterial(this);
				RFPhysic.SetSimulationType(this);
				if (simulationType != SimType.Static)
				{
					RFPhysic.SetColliderConvex(this);
					RFPhysic.SetDensity(this);
					RFPhysic.SetDrag(this);
					physics.solidity = physics.Solidity;
					physics.destructible = physics.Destructible;
				}
			}
		}

		public void StartAllCoroutines()
		{
			if (simulationType == SimType.Static || !base.gameObject.activeSelf || physics.exclude)
			{
				return;
			}
			if (demolitionType != 0)
			{
				StartCoroutine(limitations.DemolishableCor(this));
			}
			if (simulationType == SimType.Inactive || simulationType == SimType.Kinematic)
			{
				if (activation.byVelocity > 0f)
				{
					StartCoroutine(activation.ActivationVelocityCor(this));
				}
				if (activation.byOffset > 0f)
				{
					StartCoroutine(activation.ActivationOffsetCor(this));
				}
			}
			if (simulationType == SimType.Inactive)
			{
				StartCoroutine(activation.InactiveCor(this));
			}
			StartCoroutine(physics.PhysicsDataCor(this));
			RayfireRestriction.InitRestriction(this);
		}

		public void MeshInput()
		{
			if (objectType == ObjectType.Mesh)
			{
				SetComponentsBasic();
				RFFragment.InputMesh(this);
			}
		}

		private void AwakePrecache()
		{
			if (demolitionType == DemolitionType.AwakePrecache && objectType == ObjectType.Mesh)
			{
				RFDemolitionMesh.CacheInstant(this);
			}
		}

		private void AwakePrefragment()
		{
			if (demolitionType == DemolitionType.AwakePrefragment && objectType == ObjectType.Mesh)
			{
				RFDemolitionMesh.CacheInstant(this);
				Prefragment();
			}
		}

		private void OnCollisionEnter(Collision collision)
		{
			if (DemolitionState() && CollisionDemolition(collision))
			{
				limitations.demolitionShould = true;
			}
		}

		private bool CollisionDemolition(Collision collision)
		{
			if (collision.rigidbody != null && collision.rigidbody.isKinematic && collision.impulse.magnitude > (float)physics.solidity * limitations.solidity * RayfireMan.inst.globalSolidity * 7f)
			{
				limitations.contactPoint = collision.contacts[0];
				limitations.contactVector3 = collision.contacts[0].point;
				limitations.contactNormal = collision.contacts[0].normal;
				return true;
			}
			float magnitude = collision.relativeVelocity.magnitude;
			for (int i = 0; i < collision.contacts.Length; i++)
			{
				limitations.contactPoint = collision.contacts[i];
				limitations.contactVector3 = collision.contacts[i].point;
				limitations.contactNormal = collision.contacts[i].normal;
				if (magnitude > (float)physics.solidity * limitations.solidity * RayfireMan.inst.globalSolidity)
				{
					return true;
				}
				if (damage.enable && damage.collect && ApplyDamage(magnitude * damage.multiplier, limitations.contactVector3))
				{
					return true;
				}
			}
			return false;
		}

		public bool State()
		{
			if (limitations.demolished)
			{
				return false;
			}
			if (meshDemolition.runtimeCaching.inProgress)
			{
				return false;
			}
			if (meshDemolition.badMesh > RayfireMan.inst.advancedDemolitionProperties.badMeshTry)
			{
				return false;
			}
			if (!RayfireMan.MaxAmountCheck)
			{
				return false;
			}
			if (limitations.depth > 0 && limitations.currentDepth >= limitations.depth)
			{
				return false;
			}
			if (limitations.bboxSize < limitations.size)
			{
				return false;
			}
			if (Time.time - limitations.birthTime < limitations.time)
			{
				return false;
			}
			if (simulationType == SimType.Static)
			{
				return false;
			}
			if (fading.state == 2)
			{
				return false;
			}
			return true;
		}

		public bool DemolitionState()
		{
			if (demolitionType == DemolitionType.None)
			{
				return false;
			}
			if (!physics.destructible)
			{
				return false;
			}
			if (limitations.visible)
			{
				if (meshRenderer != null && !meshRenderer.isVisible)
				{
					return false;
				}
				if (skinnedMeshRend != null && !skinnedMeshRend.isVisible)
				{
					return false;
				}
			}
			if (!State())
			{
				return false;
			}
			if (RayfireMan.inst.timeQuota > 0f && RayfireMan.inst.maxTimeThisFrame > RayfireMan.inst.timeQuota)
			{
				return false;
			}
			return true;
		}

		public void Demolish()
		{
			if (!initialized)
			{
				Initialize();
			}
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			transForm.position = physics.position;
			transForm.rotation = physics.rotation;
			if (RFReferenceDemolition.DemolishReference(this) && RFDemolitionMesh.DemolishMesh(this) && !RFDemolitionCluster.DemolishCluster(this))
			{
				if (!limitations.demolished)
				{
					limitations.demolitionShould = false;
					demolitionType = DemolitionType.None;
					return;
				}
				activation.CheckConnectivity();
				InitMeshFragments();
				RayfireMan.inst.maxTimeThisFrame += Time.realtimeSinceStartup - realtimeSinceStartup;
				RFParticles.InitDemolitionParticles(this);
				RFSound.DemolitionSound(sound, limitations.bboxSize);
				demolitionEvent.InvokeLocalEvent(this);
				RFDemolitionEvent.InvokeGlobalEvent(this);
				RayfireMan.DestroyFragment(this, rootParent);
			}
		}

		public void CopyPropertiesTo(RayfireRigid toScr)
		{
			toScr.objectType = objectType;
			if (objectType == ObjectType.MeshRoot || objectType == ObjectType.SkinnedMesh)
			{
				toScr.objectType = ObjectType.Mesh;
			}
			toScr.simulationType = simulationType;
			if (objectType != ObjectType.MeshRoot && simulationType == SimType.Static)
			{
				toScr.simulationType = SimType.Dynamic;
			}
			toScr.demolitionType = demolitionType;
			if (objectType != ObjectType.MeshRoot && demolitionType != 0)
			{
				toScr.demolitionType = DemolitionType.Runtime;
			}
			if (demolitionType == DemolitionType.ReferenceDemolition)
			{
				toScr.demolitionType = DemolitionType.None;
			}
			toScr.physics.CopyFrom(physics);
			if (objectType != ObjectType.MeshRoot && (simulationType == SimType.Sleeping || simulationType == SimType.Kinematic))
			{
				toScr.simulationType = SimType.Dynamic;
			}
			toScr.activation.CopyFrom(activation);
			toScr.limitations.CopyFrom(limitations);
			toScr.meshDemolition.CopyFrom(meshDemolition);
			toScr.clusterDemolition.CopyFrom(clusterDemolition);
			if (objectType == ObjectType.MeshRoot)
			{
				toScr.referenceDemolition.CopyFrom(referenceDemolition);
			}
			toScr.materials.CopyFrom(materials);
			toScr.damage.CopyFrom(damage);
			toScr.fading.CopyFrom(fading);
			toScr.reset.CopyFrom(this);
			if (restriction != null)
			{
				toScr.restriction = toScr.gameObject.AddComponent<RayfireRestriction>();
				toScr.restriction.CopyFrom(restriction);
			}
		}

		public void InitMeshFragments()
		{
			if (HasFragments)
			{
				RFPhysic.SetFragmentsVelocity(this);
				RayfireMan.inst.advancedDemolitionProperties.currentAmount += fragments.Count;
				if (reset.mesh == RFReset.MeshResetType.ReuseInputMesh)
				{
					RFLimitations.SetAncestor(this);
					RFLimitations.SetDescendants(this);
				}
				if (fading.onDemolition)
				{
					fading.DemolitionFade(fragments);
				}
			}
		}

		private void Prefragment()
		{
			DeleteFragments();
			fragments = RFDemolitionMesh.CreateFragments(this);
			if (!HasFragments)
			{
				demolitionType = DemolitionType.None;
				return;
			}
			for (int i = 0; i < fragments.Count; i++)
			{
				fragments[i].SetComponentsBasic();
				fragments[i].SetComponentsPhysics();
				fragments[i].SetObjectType();
			}
			if (rootChild != null)
			{
				rootChild.gameObject.SetActive(value: false);
			}
		}

		public void DeleteCache()
		{
			meshes = null;
			pivots = null;
			rfMeshes = null;
			subIds = new List<RFDictionary>();
		}

		public void DeleteFragments()
		{
			if (rootChild != null)
			{
				if (UnityEngine.Application.isPlaying)
				{
					UnityEngine.Object.Destroy(rootChild.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(rootChild.gameObject);
				}
				rootChild = null;
			}
			fragments = null;
		}

		public void AddSlicePlane(Vector3[] slicePlane)
		{
			if (slicePlane.Length % 2 != 1)
			{
				limitations.slicePlanes.AddRange(slicePlane);
			}
		}

		public void Slice()
		{
			if (objectType == ObjectType.Mesh || objectType == ObjectType.SkinnedMesh)
			{
				RFDemolitionMesh.SliceMesh(this);
			}
			else if (objectType == ObjectType.ConnectedCluster)
			{
				RFDemolitionCluster.SliceConnectedCluster(this);
			}
		}

		public void CacheFrames()
		{
			StartCoroutine(meshDemolition.RuntimeCachingCor(this));
		}

		public bool ApplyDamage(float damageValue, Vector3 damagePoint, float damageRadius = 0f)
		{
			return RFDamage.ApplyDamage(this, damageValue, damagePoint, damageRadius);
		}

		public void Activate()
		{
			RFActivation.Activate(this);
		}

		public void Fade()
		{
			RFFade.Fade(this);
		}

		public void ResetRigid()
		{
			RFReset.ResetRigid(this);
		}

		public void DestroyCollider(Collider col)
		{
			UnityEngine.Object.Destroy(col);
		}

		public void DestroyObject(GameObject go)
		{
			UnityEngine.Object.Destroy(go);
		}

		public void DestroyRigid(RayfireRigid rigid)
		{
			UnityEngine.Object.Destroy(rigid);
		}

		public void DestroyRb(Rigidbody rb)
		{
			UnityEngine.Object.Destroy(rb);
		}
	}
	[AddComponentMenu("RayFire/Rayfire Shatter")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-shatter-component/")]
	public class RayfireShatter : MonoBehaviour
	{
		private enum PrefabMode
		{
			Scene,
			Asset,
			PrefabEditingMode
		}

		[Header("  Fragments")]
		[Space(2f)]
		public FragType type;

		[Space(2f)]
		public RFVoronoi voronoi = new RFVoronoi();

		[Space(2f)]
		public RFSplinters splinters = new RFSplinters();

		[Space(2f)]
		public RFSplinters slabs = new RFSplinters();

		[Space(2f)]
		public RFRadial radial = new RFRadial();

		[Space(2f)]
		public RFCustom custom = new RFCustom();

		[Space(2f)]
		public RFSlice slice = new RFSlice();

		[Space(2f)]
		public RFTets tets = new RFTets();

		[Header("  Properties")]
		[Space(2f)]
		[UnityEngine.Tooltip("Editor: Allows to fragment complex multi element hi poly meshes with topology issues like open edges and unwelded vertices.")]
		public FragmentMode mode = FragmentMode.Editor;

		[Space(2f)]
		public RFSurface material = new RFSurface();

		public RFShatterCluster clusters = new RFShatterCluster();

		public RFShatterAdvanced advanced = new RFShatterAdvanced();

		[Header("  Export to asset")]
		[Space(2f)]
		public RFMeshExport export = new RFMeshExport();

		[Header("Center")]
		[HideInInspector]
		public bool showCenter;

		[HideInInspector]
		public Vector3 centerPosition;

		[HideInInspector]
		public Quaternion centerDirection;

		[Header("Components")]
		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public MeshFilter meshFilter;

		[HideInInspector]
		public MeshRenderer meshRenderer;

		[HideInInspector]
		public SkinnedMeshRenderer skinnedMeshRend;

		[Header("Variables")]
		[HideInInspector]
		public Mesh[] meshes;

		[HideInInspector]
		public Vector3[] pivots;

		[HideInInspector]
		public List<Transform> rootChildList = new List<Transform>();

		[HideInInspector]
		public List<GameObject> fragmentsAll = new List<GameObject>();

		[HideInInspector]
		public List<GameObject> fragmentsLast = new List<GameObject>();

		[HideInInspector]
		public List<RFDictionary> origSubMeshIdsRF = new List<RFDictionary>();

		[HideInInspector]
		public int shatterMode = 1;

		[HideInInspector]
		public bool colorPreview;

		[HideInInspector]
		public bool scalePreview = true;

		[HideInInspector]
		public float previewScale;

		[HideInInspector]
		public float size;

		[HideInInspector]
		public float rescaleFix = 1f;

		[HideInInspector]
		public Vector3 originalScale;

		[HideInInspector]
		public Bounds bound;

		private static float minSize = 0.01f;

		[HideInInspector]
		public bool resetState;

		private void Reset()
		{
			ResetCenter();
		}

		private void SetVariables()
		{
			size = 0f;
			rescaleFix = 1f;
			originalScale = transForm.localScale;
		}

		private bool DefineComponents()
		{
			if (base.gameObject.scene.rootCount == 0)
			{
				UnityEngine.Debug.Log("Shatter component unable to fragment prefab because prefab unable to store Unity mesh. Fragment prefab in scene.");
				return false;
			}
			meshFilter = GetComponent<MeshFilter>();
			skinnedMeshRend = GetComponent<SkinnedMeshRenderer>();
			if (meshFilter == null && skinnedMeshRend == null)
			{
				UnityEngine.Debug.Log("No mesh");
				return false;
			}
			if (meshFilter != null && meshFilter.sharedMesh == null)
			{
				UnityEngine.Debug.Log("No mesh");
				return false;
			}
			if (skinnedMeshRend != null && skinnedMeshRend.sharedMesh == null)
			{
				UnityEngine.Debug.Log("No mesh");
				return false;
			}
			if (meshFilter != null && !meshFilter.sharedMesh.isReadable)
			{
				UnityEngine.Debug.Log("Mesh is not readable. Open Import Settings and turn On Read/Write Enabled", meshFilter.gameObject);
				return false;
			}
			transForm = GetComponent<Transform>();
			origSubMeshIdsRF = new List<RFDictionary>();
			if (skinnedMeshRend == null)
			{
				meshRenderer = GetComponent<MeshRenderer>();
				if (meshRenderer == null)
				{
					meshRenderer = base.gameObject.AddComponent<MeshRenderer>();
				}
				bound = meshRenderer.bounds;
			}
			if (skinnedMeshRend != null)
			{
				bound = skinnedMeshRend.bounds;
			}
			return true;
		}

		public Bounds GetBound()
		{
			if (meshRenderer == null)
			{
				meshRenderer = GetComponent<MeshRenderer>();
				if (meshRenderer != null)
				{
					return meshRenderer.bounds;
				}
				if (skinnedMeshRend == null)
				{
					skinnedMeshRend = GetComponent<SkinnedMeshRenderer>();
					if (skinnedMeshRend != null)
					{
						return skinnedMeshRend.bounds;
					}
				}
				return default(Bounds);
			}
			return meshRenderer.bounds;
		}

		private static PrefabMode GetPrefabMode(GameObject go)
		{
			if (go.scene.path.EndsWith(".prefab"))
			{
				return PrefabMode.Asset;
			}
			if (string.IsNullOrEmpty(go.scene.path))
			{
				return PrefabMode.PrefabEditingMode;
			}
			return PrefabMode.Scene;
		}

		public void Fragment(int fragmentMode = 0)
		{
			if (!DefineComponents())
			{
				return;
			}
			SetVariables();
			ScaleCheck();
			RFFragment.CacheMeshes(ref meshes, ref pivots, ref origSubMeshIdsRF, this);
			if (meshes == null)
			{
				return;
			}
			if (fragmentMode == 1)
			{
				if (rootChildList[rootChildList.Count - 1] != null)
				{
					fragmentsLast = CreateFragments(rootChildList[rootChildList.Count - 1].gameObject);
				}
				else
				{
					fragmentMode = 0;
				}
			}
			if (fragmentMode == 0)
			{
				fragmentsLast = CreateFragments();
			}
			VertexLimitation();
			fragmentsAll.AddRange(fragmentsLast);
			transForm.localScale = originalScale;
		}

		private List<GameObject> CreateFragments(GameObject lastRoot = null)
		{
			if (meshes == null)
			{
				return null;
			}
			GameObject[] array = new GameObject[meshes.Length];
			string text = base.gameObject.name;
			string text2 = text + "_sh_";
			GameObject gameObject = lastRoot;
			if (lastRoot == null)
			{
				gameObject = new GameObject(text + "_rootss");
				gameObject.transform.position = transForm.position;
				gameObject.transform.rotation = transForm.rotation;
				rootChildList.Add(gameObject.transform);
			}
			GameObject gameObject2;
			if (advanced.copyComponents)
			{
				gameObject2 = UnityEngine.Object.Instantiate(base.gameObject);
				gameObject2.transform.rotation = Quaternion.identity;
				gameObject2.transform.localScale = Vector3.one;
				UnityEngine.Object.DestroyImmediate(gameObject2.GetComponent<RayfireShatter>());
			}
			else
			{
				gameObject2 = new GameObject();
				gameObject2.AddComponent<MeshFilter>();
				gameObject2.AddComponent<MeshRenderer>();
			}
			Material[] sharedMaterials = ((skinnedMeshRend != null) ? skinnedMeshRend.sharedMaterials : meshRenderer.sharedMaterials);
			for (int i = 0; i < meshes.Length; i++)
			{
				if (rescaleFix != 1f)
				{
					RFFragment.RescaleMesh(meshes[i], rescaleFix);
				}
				GameObject gameObject3 = UnityEngine.Object.Instantiate(gameObject2);
				gameObject3.transform.localScale = Vector3.one;
				MeshRenderer component = gameObject3.GetComponent<MeshRenderer>();
				RFSurface.SetMaterial(origSubMeshIdsRF, sharedMaterials, material, component, i, meshes.Length);
				gameObject3.name = text2 + (i + 1);
				gameObject3.transform.position = gameObject.transform.position + pivots[i] / rescaleFix;
				gameObject3.transform.parent = gameObject.transform;
				MeshFilter component2 = gameObject3.GetComponent<MeshFilter>();
				component2.sharedMesh = meshes[i];
				component2.sharedMesh.name = gameObject3.name;
				MeshCollider component3 = gameObject3.GetComponent<MeshCollider>();
				if (component3 != null)
				{
					component3.sharedMesh = meshes[i];
				}
				array[i] = gameObject3;
			}
			gameObject.transform.parent = transForm.parent;
			gameObject.transform.localScale = Vector3.one;
			UnityEngine.Object.DestroyImmediate(gameObject2);
			meshes = null;
			pivots = null;
			origSubMeshIdsRF = new List<RFDictionary>();
			return array.ToList();
		}

		public void DeleteFragmentsLast(int destroyMode = 0)
		{
			if (destroyMode == 1)
			{
				for (int num = fragmentsLast.Count - 1; num >= 0; num--)
				{
					if (fragmentsLast[num] != null)
					{
						UnityEngine.Object.DestroyImmediate(fragmentsLast[num]);
					}
				}
			}
			fragmentsLast.Clear();
			for (int num2 = fragmentsAll.Count - 1; num2 >= 0; num2--)
			{
				if (fragmentsAll[num2] == null)
				{
					fragmentsAll.RemoveAt(num2);
				}
			}
			for (int num3 = rootChildList.Count - 1; num3 >= 0; num3--)
			{
				if (rootChildList[num3] == null)
				{
					rootChildList.RemoveAt(num3);
				}
			}
			if (rootChildList.Count == 0)
			{
				return;
			}
			if (destroyMode == 0)
			{
				UnityEngine.Object.DestroyImmediate(rootChildList[rootChildList.Count - 1].gameObject);
				rootChildList.RemoveAt(rootChildList.Count - 1);
			}
			for (int num4 = fragmentsAll.Count - 1; num4 >= 0; num4--)
			{
				if (fragmentsAll[num4] == null)
				{
					fragmentsAll.RemoveAt(num4);
				}
			}
		}

		public void DeleteFragmentsAll()
		{
			fragmentsLast.Clear();
			fragmentsAll.Clear();
			for (int num = rootChildList.Count - 1; num >= 0; num--)
			{
				if (rootChildList[num] != null)
				{
					UnityEngine.Object.DestroyImmediate(rootChildList[num].gameObject);
				}
			}
			rootChildList.Clear();
		}

		public void ResetCenter()
		{
			centerPosition = Vector3.zero;
			centerDirection = Quaternion.identity;
			Renderer component = GetComponent<Renderer>();
			if (component != null)
			{
				centerPosition = base.transform.InverseTransformPoint(component.bounds.center);
			}
		}

		private void ScaleCheck()
		{
			if (meshRenderer != null)
			{
				size = meshRenderer.bounds.size.magnitude;
			}
			if (skinnedMeshRend != null)
			{
				size = skinnedMeshRend.bounds.size.magnitude;
			}
			if (size != 0f && size < minSize)
			{
				rescaleFix = 1f / size;
				Vector3 localScale = transForm.localScale * rescaleFix;
				transForm.localScale = localScale;
				UnityEngine.Debug.Log("Warning. Object " + base.name + " is too small.");
			}
		}

		public void ResetScale(float scaleValue)
		{
			if (!resetState || scaleValue != 0f)
			{
				return;
			}
			if (skinnedMeshRend != null)
			{
				skinnedMeshRend.enabled = true;
			}
			if (meshRenderer != null)
			{
				meshRenderer.enabled = true;
			}
			if (fragmentsLast.Count > 0)
			{
				foreach (GameObject item in fragmentsLast)
				{
					if (item != null)
					{
						item.transform.localScale = Vector3.one;
					}
				}
			}
			resetState = false;
		}

		public static void CopyRootMeshShatter(RayfireRigid source, List<RayfireRigid> targets)
		{
			if (!(source.meshDemolition.scrShatter == null))
			{
				for (int i = 0; i < targets.Count; i++)
				{
					targets[i].meshDemolition.scrShatter = targets[i].gameObject.AddComponent<RayfireShatter>();
					targets[i].meshDemolition.scrShatter.CopyFrom(source.meshDemolition.scrShatter);
				}
			}
		}

		private void CopyFrom(RayfireShatter shatter)
		{
			type = shatter.type;
			voronoi = new RFVoronoi(shatter.voronoi);
			splinters = new RFSplinters(shatter.splinters);
			slabs = new RFSplinters(shatter.slabs);
			radial = new RFRadial(shatter.radial);
			custom = new RFCustom(shatter.custom);
			slice = new RFSlice(shatter.slice);
			tets = new RFTets(shatter.tets);
			mode = shatter.mode;
			material.CopyFrom(shatter.material);
			clusters = new RFShatterCluster(shatter.clusters);
			advanced = new RFShatterAdvanced(shatter.advanced);
		}

		private void VertexLimitation()
		{
			if (!advanced.vertexLimitation)
			{
				return;
			}
			for (int num = fragmentsLast.Count - 1; num >= 0; num--)
			{
				if (fragmentsLast[num].GetComponent<MeshFilter>().sharedMesh.vertexCount > advanced.vertexAmount)
				{
					RayfireShatter rayfireShatter = fragmentsLast[num].AddComponent<RayfireShatter>();
					rayfireShatter.voronoi.amount = 4;
					rayfireShatter.Fragment();
					UnityEngine.Debug.Log(rayfireShatter.name);
					if (rayfireShatter.fragmentsLast.Count > 0)
					{
						fragmentsLast.AddRange(rayfireShatter.fragmentsLast);
						UnityEngine.Object.DestroyImmediate(rayfireShatter.gameObject);
						fragmentsLast.RemoveAt(num);
					}
				}
			}
		}
	}
	[SelectionBase]
	[DisallowMultipleComponent]
	[AddComponentMenu("RayFire/Rayfire Snapshot")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-snapshot-component/")]
	public class RayfireSnapshot : MonoBehaviour
	{
		[Header("  Save Properties")]
		[Space(2f)]
		public string assetName;

		public bool compress;

		[Header("  Load Properties")]
		[Space(2f)]
		public UnityEngine.Object snapshotAsset;

		[Range(0f, 1f)]
		public float sizeFilter;

		private void Reset()
		{
			assetName = base.gameObject.name;
		}
	}
	[SelectionBase]
	[AddComponentMenu("RayFire/Rayfire Sound")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-sound-component/")]
	public class RayfireSound : MonoBehaviour
	{
		[Header("  Properties")]
		[Space(3f)]
		[UnityEngine.Tooltip("Base volume. Can be increased by Size Volume property")]
		[Range(0.01f, 1f)]
		public float baseVolume;

		[Space(1f)]
		[UnityEngine.Tooltip("Additional volume per one unit size")]
		[Range(0f, 1f)]
		public float sizeVolume;

		[Header("  Events")]
		[Space(3f)]
		public RFSound initialization;

		[Space(2f)]
		public RFSound activation;

		[Space(2f)]
		public RFSound demolition;

		[Header("  Filters")]
		[Space(3f)]
		[UnityEngine.Tooltip("Objects with size lower than defined value will not make sound")]
		[Range(0f, 1f)]
		public float minimumSize;

		[Space(1f)]
		[UnityEngine.Tooltip("Objects with distance to main camera higher than defined value will not make sound")]
		[Range(0f, 999f)]
		public float cameraDistance;

		[HideInInspector]
		public RayfireRigid rigid;

		public RayfireSound()
		{
			baseVolume = 1f;
			sizeVolume = 0.2f;
			minimumSize = 0f;
			cameraDistance = 0f;
		}

		public void Initialize()
		{
			if (rigid == null)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + base.name + " Warning. Sound component has no attached Rigid", base.gameObject);
			}
			if (!initialization.enable && !activation.enable && !demolition.enable)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + base.name + " Warning. All events disabled", base.gameObject);
			}
			if (initialization.enable && initialization.clip == null && !initialization.HasClips)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + base.name + " Warning. Initialization sound has no clips to play", base.gameObject);
			}
			if (activation.enable && activation.clip == null && !activation.HasClips)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + base.name + " Warning. Activation sound has no clips to play", base.gameObject);
			}
			if (demolition.enable && demolition.clip == null && !demolition.HasClips)
			{
				UnityEngine.Debug.Log("RayFire Sound: " + base.name + " Warning. Demolition sound has no clips to play", base.gameObject);
			}
		}

		public void CopyFrom(RayfireSound source)
		{
			baseVolume = source.baseVolume;
			sizeVolume = source.sizeVolume;
			initialization = new RFSound(source.initialization);
			activation = new RFSound(source.activation);
			demolition = new RFSound(source.demolition);
			minimumSize = source.minimumSize;
			cameraDistance = source.cameraDistance;
		}

		private void CreateSource(RayfireRigid scr)
		{
			GameObject obj = new GameObject("SoundSource");
			obj.transform.position = scr.gameObject.transform.position;
			AudioSource audioSource = obj.AddComponent<AudioSource>();
			audioSource.clip = demolition.clip;
			audioSource.mute = false;
			audioSource.bypassEffects = false;
			audioSource.bypassListenerEffects = false;
			audioSource.bypassReverbZones = false;
			audioSource.playOnAwake = false;
			audioSource.loop = false;
			audioSource.priority = 127;
			audioSource.volume = demolition.multiplier;
			audioSource.pitch = 1f;
			audioSource.panStereo = 0f;
			audioSource.spatialBlend = 0f;
			audioSource.reverbZoneMix = 1f;
			audioSource.minDistance = 0f;
			audioSource.PlayOneShot(demolition.clip, demolition.multiplier);
			UnityEngine.Object.Destroy(obj, demolition.clip.length);
		}
	}
	[AddComponentMenu("RayFire/Rayfire Unyielding")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-unyielding-component/")]
	public class RayfireUnyielding : MonoBehaviour
	{
		public enum RFUnyType
		{
			AtStart = 0,
			ByMethod = 3
		}

		[HideInInspector]
		public Vector3 size = new Vector3(1f, 1f, 1f);

		[HideInInspector]
		public Vector3 centerPosition;

		[HideInInspector]
		public List<RayfireRigid> rigidList;

		[HideInInspector]
		public bool initialized;

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public bool showCenter;

		[Space(3f)]
		public RFUnyType initialize = RFUnyType.ByMethod;

		private void Start()
		{
			if (initialize == RFUnyType.AtStart)
			{
				Initialize();
			}
		}

		public void SetUnyByOverlap(RayfireRigid scr)
		{
			if (!base.enabled || initialize == RFUnyType.AtStart || initialized)
			{
				return;
			}
			Collider[] source = Physics.OverlapBox(base.transform.TransformPoint(centerPosition), size / 2f, base.transform.rotation, 1 << scr.gameObject.layer);
			if (scr.objectType == ObjectType.Mesh)
			{
				if (scr.physics.meshCollider != null && source.Contains(scr.physics.meshCollider))
				{
					scr.activation.unyielding = true;
				}
			}
			else if (scr.objectType == ObjectType.MeshRoot)
			{
				for (int i = 0; i < scr.fragments.Count; i++)
				{
					if (scr.fragments[i].physics.meshCollider != null && source.Contains(scr.fragments[i].physics.meshCollider))
					{
						scr.fragments[i].activation.unyielding = true;
					}
				}
			}
			else if (scr.objectType == ObjectType.ConnectedCluster)
			{
				for (int j = 0; j < scr.physics.clusterColliders.Count; j++)
				{
					if (scr.physics.clusterColliders[j] != null && source.Contains(scr.physics.clusterColliders[j]))
					{
						scr.clusterDemolition.cluster.shards[j].uny = true;
					}
				}
			}
			initialized = true;
		}

		public void Initialize()
		{
			if (base.enabled && !initialized)
			{
				Collider[] unyByColliders = Physics.OverlapBox(base.transform.TransformPoint(centerPosition), size / 2f, base.transform.rotation);
				SetUnyByColliders(unyByColliders);
			}
		}

		public void SetUnyByColliders(Collider[] colliders)
		{
			if (rigidList == null)
			{
				rigidList = new List<RayfireRigid>();
			}
			else
			{
				rigidList.Clear();
			}
			for (int i = 0; i < colliders.Length; i++)
			{
				RayfireRigid component = colliders[i].GetComponent<RayfireRigid>();
				if (component != null && !rigidList.Contains(component))
				{
					rigidList.Add(component);
				}
			}
			SetUnyRigids(rigidList);
		}

		public void SetUnyRigids(List<RayfireRigid> rigids)
		{
			if (rigids.Count > 0)
			{
				for (int i = 0; i < rigids.Count; i++)
				{
					rigids[i].activation.unyielding = true;
				}
			}
		}
	}
	[AddComponentMenu("RayFire/Rayfire Vortex")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-vortex-component/")]
	public class RayfireVortex : MonoBehaviour
	{
		[Header("Hidden")]
		[HideInInspector]
		public Transform transForm;

		[HideInInspector]
		public Collider[] colliders;

		[HideInInspector]
		public List<Rigidbody> rigidbodies = new List<Rigidbody>();

		[HideInInspector]
		public List<Rigidbody> myRigidbodies = new List<Rigidbody>();

		private Vector3 bot;

		private Vector3 top;

		private Vector3 normal;

		private Vector3 direction;

		private Vector3 rbPos;

		private Vector3 linePoint;

		private Vector3 vectorUp;

		private Vector3 centerOutVector;

		private Vector3 vectorCenter;

		private Vector3 perpend;

		private Vector3 vectorSwirl;

		private Vector3 forceVector;

		private float distancePerpend;

		private float distanceBottom;

		private float upRateNow;

		private float localRadius;

		private float upRateOwn;

		private float centerRateOwn;

		private float centerRateNow;

		private float upRateDif;

		private float centerRateDif;

		private float maxRadius;

		private float axisDistance;

		private Plane bottomPlane;

		private float torqueVal;

		[Header("Anchor points")]
		public Vector3 topAnchor = new Vector3(3f, 30f, 2f);

		public Vector3 bottomAnchor = new Vector3(0f, 0f, 0f);

		[Header("Gizmo")]
		[Range(0.1f, 50f)]
		public float topRadius = 15f;

		[Range(0f, 50f)]
		public float bottomRadius = 3f;

		[Header("Eye")]
		[Range(0.05f, 0.9f)]
		public float eye = 0.1f;

		[Header("Strength")]
		public bool forceByMass = true;

		[Range(1f, 10f)]
		public float stiffness = 1f;

		[Range(-40f, 40f)]
		public float swirlStrength = 10f;

		[Header("Torque")]
		public bool enableTorque = true;

		[Range(-1f, 1f)]
		public float torqueStrength = 0.5f;

		[Range(0f, 1f)]
		public float torqueVariation = 0.5f;

		[Header("Height bias")]
		public bool enableHeightBias = true;

		[Range(0f, 1f)]
		public float biasSpeed = 0.025f;

		[Range(0f, 1f)]
		public float biasSpread = 1f;

		[Header("Seed")]
		[Range(0f, 100f)]
		public int seed;

		[Header("Preview")]
		[Range(2f, 10f)]
		public int circles = 3;

		[HideInInspector]
		public bool showGizmo = true;

		[HideInInspector]
		public bool topHandle;

		[Header("Filters")]
		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		private void Awake()
		{
			DefineComponents();
		}

		private void DefineComponents()
		{
			transForm = GetComponent<Transform>();
			colliders = new Collider[10];
		}

		private IEnumerator VortexForceCor()
		{
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.95f));
			while (base.enabled)
			{
				SetForce();
				yield return new WaitForSeconds(0.066f);
			}
		}

		private IEnumerator SetCollidersCor()
		{
			SetColliderGizmo();
			yield return new WaitForSeconds(UnityEngine.Random.Range(0f, 0.95f));
			while (base.enabled)
			{
				SetColliders();
				SetRigidBodies();
				yield return new WaitForSeconds(0.3f);
			}
		}

		private void OnEnable()
		{
			StartCoroutine(SetCollidersCor());
			StartCoroutine(VortexForceCor());
		}

		private void SetColliders()
		{
			int num = Physics.OverlapCapsuleNonAlloc(bot, top, maxRadius, colliders, mask);
			if (num == colliders.Length)
			{
				colliders = new Collider[num + 30];
				Physics.OverlapCapsuleNonAlloc(bot, top, maxRadius, colliders, mask);
			}
			if (colliders.Length > num + 50)
			{
				colliders = new Collider[num - 30];
				Physics.OverlapCapsuleNonAlloc(bot, top, maxRadius, colliders, mask);
			}
		}

		private void SetColliderGizmo()
		{
			bot = transForm.TransformPoint(bottomAnchor);
			top = transForm.TransformPoint(topAnchor);
			direction = top - bot;
			normal = base.transform.up;
			axisDistance = topAnchor.y - bottomAnchor.y;
			maxRadius = topRadius;
			if (bottomRadius > topRadius)
			{
				maxRadius = bottomRadius;
			}
			bottomPlane = new Plane(base.transform.up, bot);
		}

		private void SetRigidBodies()
		{
			rigidbodies.Clear();
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				if (!(collider == null) && (!(tagFilter != "Untagged") || !(collider.tag != tagFilter)))
				{
					Rigidbody attachedRigidbody = collider.attachedRigidbody;
					if (attachedRigidbody != null && !attachedRigidbody.isKinematic && !rigidbodies.Contains(attachedRigidbody))
					{
						rigidbodies.Add(attachedRigidbody);
					}
				}
			}
		}

		private void SetForce()
		{
			SetColliderGizmo();
			ForceMode mode = ForceMode.Impulse;
			if (!forceByMass)
			{
				mode = ForceMode.VelocityChange;
			}
			foreach (Rigidbody rigidbody in rigidbodies)
			{
				if (rigidbody == null)
				{
					continue;
				}
				UnityEngine.Random.InitState(rigidbody.GetInstanceID() + seed);
				rbPos = rigidbody.transform.position;
				linePoint = GetClosetLinePoint(rbPos);
				distancePerpend = Vector3.Distance(linePoint, rbPos);
				distanceBottom = bottomPlane.GetDistanceToPoint(linePoint);
				upRateNow = distanceBottom / axisDistance;
				if (!bottomPlane.GetSide(linePoint))
				{
					upRateNow = 0f - upRateNow;
				}
				localRadius = Mathf.Lerp(bottomRadius, topRadius, upRateNow);
				if (!(localRadius < distancePerpend))
				{
					upRateOwn = UnityEngine.Random.Range(0.03f, 0.97f);
					centerRateOwn = UnityEngine.Random.Range(eye, 0.9f);
					if (enableHeightBias)
					{
						upRateOwn = HeightBias(upRateOwn, centerRateOwn);
					}
					centerRateNow = distancePerpend / localRadius;
					upRateDif = (upRateOwn - upRateNow) * stiffness;
					centerRateDif = (centerRateOwn - centerRateNow) * stiffness;
					vectorUp = upRateDif * (stiffness + 2f) * normal;
					centerOutVector = (rbPos - linePoint).normalized;
					vectorCenter = Mathf.Abs(swirlStrength) * centerRateDif * centerOutVector;
					perpend = Vector3.Cross(normal, centerOutVector);
					vectorSwirl = swirlStrength * perpend.normalized;
					forceVector = vectorUp + vectorCenter + vectorSwirl;
					rigidbody.velocity = Vector3.zero;
					rigidbody.AddForce(forceVector, mode);
					if (enableTorque)
					{
						torqueVal = (torqueStrength + UnityEngine.Random.Range(0f - torqueVariation, torqueVariation)) * 10f;
						rigidbody.AddTorque(torqueVal * swirlStrength * UnityEngine.Random.Range(0f, 1f) * transForm.up, mode);
					}
				}
			}
		}

		private Vector3 GetClosetLinePoint(Vector3 worldPos)
		{
			return Vector3.Project(worldPos - bot, direction) + bot;
		}

		private Vector3 GetParallelLinePoint(Vector3 worldPos)
		{
			return Vector3.Project(worldPos - bot, direction) + bot;
		}

		public static bool LinePlaneIntersection(out Vector3 intersection, Vector3 linePoint, Vector3 lineVec, Vector3 planeNormal, Vector3 planePoint)
		{
			intersection = Vector3.zero;
			float num = Vector3.Dot(planePoint - linePoint, planeNormal);
			float num2 = Vector3.Dot(lineVec, planeNormal);
			if (num2 != 0f)
			{
				float size = num / num2;
				Vector3 vector = SetVectorLength(lineVec, size);
				intersection = linePoint + vector;
				return true;
			}
			return false;
		}

		private static Vector3 SetVectorLength(Vector3 vector, float size)
		{
			return Vector3.Normalize(vector) * size;
		}

		private float HeightBias(float upRateOwnLoc, float centerRateOwnLoc)
		{
			if (biasSpread > 0f)
			{
				float num = Mathf.PerlinNoise(Time.time * biasSpeed * centerRateOwnLoc, upRateOwnLoc) * biasSpread;
				int num2 = 1;
				if ((double)UnityEngine.Random.value >= 0.5)
				{
					num2 = -1;
				}
				float num3 = num * (float)num2;
				upRateOwnLoc += num3;
				if (upRateOwnLoc > 1f)
				{
					upRateOwnLoc = ((!(upRateOwnLoc > 2f)) ? (1f - (upRateOwnLoc - 1f)) : (upRateOwnLoc - 2f));
				}
				else if (upRateOwnLoc < 0f)
				{
					upRateOwnLoc = ((!(upRateOwnLoc < -1f)) ? (0f - upRateOwnLoc) : (upRateOwnLoc + 2f));
				}
			}
			return upRateOwnLoc;
		}
	}
	[AddComponentMenu("RayFire/Rayfire Wind")]
	[HelpURL("http://rayfirestudios.com/unity-online-help/unity-wind-component/")]
	public class RayfireWind : MonoBehaviour
	{
		public enum DirType
		{
			Directional,
			Point
		}

		private Transform transForm;

		private Collider[] colliders;

		private Vector3 halfExtents;

		private Vector3 center;

		private float offset;

		[Header("  Gizmo")]
		public Vector3 gizmoSize = new Vector3(30f, 2f, 50f);

		[HideInInspector]
		public bool showGizmo = true;

		[Header("  Noise")]
		[Range(1f, 100f)]
		public float globalScale = 10f;

		[Range(1f, 300f)]
		public float lengthScale = 100f;

		[Range(1f, 300f)]
		public float widthScale = 100f;

		[Range(-200f, 200f)]
		public float speed = 15f;

		[HideInInspector]
		public bool showNoise;

		[Header("  Strength")]
		[Range(-5f, 5f)]
		public float minimum;

		[Range(-5f, 5f)]
		public float maximum = 1f;

		[Range(0f, 10f)]
		public float torque = 2f;

		public bool forceByMass = true;

		[Header("  Direction")]
		[Range(0f, 180f)]
		public float divergency = 120f;

		[Range(0.01f, 2f)]
		public float turbulence = 0.5f;

		[Header("  Preview")]
		[Range(0.5f, 5f)]
		public float previewDensity = 1f;

		[Range(0.1f, 5f)]
		public float previewSize = 1f;

		[Header("  Affected Rigid Bodies")]
		[HideInInspector]
		public List<Rigidbody> rigidbodies = new List<Rigidbody>();

		[HideInInspector]
		public int mask = -1;

		[HideInInspector]
		public string tagFilter = "Untagged";

		private void Awake()
		{
			DefineComponents();
		}

		private void DefineComponents()
		{
			transForm = GetComponent<Transform>();
			colliders = new Collider[10];
		}

		private IEnumerator WindForceCor()
		{
			while (base.enabled)
			{
				SetColliders();
				SetRigidBodies();
				SetForce();
				yield return new WaitForSeconds(0.05f);
			}
		}

		private void OnEnable()
		{
			StartCoroutine(WindForceCor());
		}

		private void Reset()
		{
			globalScale = 10f;
		}

		private void SetColliders()
		{
			SetColliderGizmo();
			int num = Physics.OverlapBoxNonAlloc(center, halfExtents, colliders, transForm.rotation, mask);
			if (num == colliders.Length)
			{
				colliders = new Collider[num + 30];
				Physics.OverlapBoxNonAlloc(center, halfExtents, colliders, transForm.rotation, mask);
			}
			if (colliders.Length > num + 50)
			{
				colliders = new Collider[num - 30];
				Physics.OverlapBoxNonAlloc(center, halfExtents, colliders, transForm.rotation, mask);
			}
		}

		private void SetColliderGizmo()
		{
			halfExtents = gizmoSize / 2f;
			center = transForm.position;
			center.y += halfExtents.y;
		}

		private void SetRigidBodies()
		{
			rigidbodies.Clear();
			Collider[] array = colliders;
			foreach (Collider collider in array)
			{
				if (!(collider == null) && (!(tagFilter != "Untagged") || !(collider.tag != tagFilter)))
				{
					Rigidbody attachedRigidbody = collider.attachedRigidbody;
					if (attachedRigidbody != null && !attachedRigidbody.isKinematic && !rigidbodies.Contains(attachedRigidbody))
					{
						rigidbodies.Add(attachedRigidbody);
					}
				}
			}
		}

		private void SetForce()
		{
			UnityEngine.Random.InitState(1);
			SetSpeed();
			ForceMode mode = ForceMode.Acceleration;
			if (forceByMass)
			{
				mode = ForceMode.Force;
			}
			foreach (Rigidbody rigidbody in rigidbodies)
			{
				Vector3 position = rigidbody.transform.position;
				float val = PerlinFixedGlobal(position);
				float num = WindStrength(val) * 10f;
				Vector3 vectorGlobal = GetVectorGlobal(position);
				rigidbody.AddForce(vectorGlobal * num, mode);
				if (torque > 0f)
				{
					rigidbody.AddTorque(num * torque * transForm.right, mode);
				}
			}
		}

		private Vector3 GetVectorGlobal(Vector3 worldPos)
		{
			return GetVectorLocal(transForm.InverseTransformPoint(worldPos));
		}

		public Vector3 GetVectorLocal(Vector3 localPos)
		{
			Vector3 vector = base.transform.forward;
			if (divergency > 0f)
			{
				float t = PerlinCustomLocal(localPos, gizmoSize.x, gizmoSize.z, widthScale, lengthScale, globalScale * turbulence, offset + gizmoSize.z);
				float y = Mathf.Lerp(0f - divergency, divergency, t);
				vector = Quaternion.Euler(0f, y, 0f) * vector;
			}
			return vector;
		}

		private float PerlinFixedGlobal(Vector3 worldPos)
		{
			return PerlinFixedLocal(transForm.InverseTransformPoint(worldPos));
		}

		public float PerlinFixedLocal(Vector3 localPos)
		{
			localPos.z += offset;
			float x = (localPos.x + gizmoSize.x / 2f) / widthScale * globalScale;
			float y = (localPos.z + gizmoSize.z / 2f) / lengthScale * globalScale;
			return Mathf.PerlinNoise(x, y);
		}

		public float PerlinCustomGlobal(Vector3 worldPos, float SizeX, float SizeZ, float WidthScale, float LengthScale, float GlobalScale, float Offset)
		{
			return PerlinCustomLocal(transForm.InverseTransformPoint(worldPos), SizeX, SizeZ, WidthScale, LengthScale, GlobalScale, Offset);
		}

		public float PerlinCustomLocal(Vector3 localPos, float SizeX, float SizeZ, float WidthScale, float LengthScale, float GlobalScale, float Offset)
		{
			localPos.z += Offset;
			float x = (localPos.x + SizeX / 2f) / WidthScale * GlobalScale;
			float y = (localPos.z + SizeZ / 2f) / LengthScale * GlobalScale;
			return Mathf.PerlinNoise(x, y);
		}

		public float WindStrength(float val)
		{
			return Mathf.Lerp(minimum, maximum, val);
		}

		private void SetSpeed()
		{
			if (speed != 0f)
			{
				offset -= 0.015f * speed;
				if (offset < -100000f || offset > 100000f)
				{
					offset = 0f;
				}
			}
		}
	}
}
namespace HutongGames
{
	public class EasingFunction
	{
		public enum Ease
		{
			EaseInQuad,
			EaseOutQuad,
			EaseInOutQuad,
			EaseInCubic,
			EaseOutCubic,
			EaseInOutCubic,
			EaseInQuart,
			EaseOutQuart,
			EaseInOutQuart,
			EaseInQuint,
			EaseOutQuint,
			EaseInOutQuint,
			EaseInSine,
			EaseOutSine,
			EaseInOutSine,
			EaseInExpo,
			EaseOutExpo,
			EaseInOutExpo,
			EaseInCirc,
			EaseOutCirc,
			EaseInOutCirc,
			Linear,
			Spring,
			EaseInBounce,
			EaseOutBounce,
			EaseInOutBounce,
			EaseInBack,
			EaseOutBack,
			EaseInOutBack,
			EaseInElastic,
			EaseOutElastic,
			EaseInOutElastic,
			CustomCurve
		}

		public delegate float Function(float s, float e, float v);

		private const float NATURAL_LOG_OF_2 = 0.6931472f;

		public static AnimationCurve AnimationCurve;

		public static float Linear(float start, float end, float value)
		{
			return Mathf.Lerp(start, end, value);
		}

		public static float Spring(float start, float end, float value)
		{
			value = Mathf.Clamp01(value);
			value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
			return start + (end - start) * value;
		}

		public static float EaseInQuad(float start, float end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static float EaseOutQuad(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * value * (value - 2f) + start;
		}

		public static float EaseInOutQuad(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value + start;
			}
			value -= 1f;
			return (0f - end) * 0.5f * (value * (value - 2f) - 1f) + start;
		}

		public static float EaseInCubic(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value + start;
		}

		public static float EaseOutCubic(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value + 1f) + start;
		}

		public static float EaseInOutCubic(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value + start;
			}
			value -= 2f;
			return end * 0.5f * (value * value * value + 2f) + start;
		}

		public static float EaseInQuart(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value + start;
		}

		public static float EaseOutQuart(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return (0f - end) * (value * value * value * value - 1f) + start;
		}

		public static float EaseInOutQuart(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value * value + start;
			}
			value -= 2f;
			return (0f - end) * 0.5f * (value * value * value * value - 2f) + start;
		}

		public static float EaseInQuint(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value * value + start;
		}

		public static float EaseOutQuint(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value * value * value + 1f) + start;
		}

		public static float EaseInOutQuint(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value * value * value + start;
			}
			value -= 2f;
			return end * 0.5f * (value * value * value * value * value + 2f) + start;
		}

		public static float EaseInSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static float EaseOutSine(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static float EaseInOutSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static float EaseInExpo(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}

		public static float EaseOutExpo(float start, float end, float value)
		{
			end -= start;
			return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
		}

		public static float EaseInOutExpo(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
			}
			value -= 1f;
			return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
		}

		public static float EaseInCirc(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}

		public static float EaseOutCirc(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * Mathf.Sqrt(1f - value * value) + start;
		}

		public static float EaseInOutCirc(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return (0f - end) * 0.5f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
			}
			value -= 2f;
			return end * 0.5f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
		}

		public static float EaseInBounce(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			return end - EaseOutBounce(0f, end, num - value) + start;
		}

		public static float EaseOutBounce(float start, float end, float value)
		{
			value /= 1f;
			end -= start;
			if (value < 0.36363637f)
			{
				return end * (7.5625f * value * value) + start;
			}
			if (value < 0.72727275f)
			{
				value -= 0.54545456f;
				return end * (7.5625f * value * value + 0.75f) + start;
			}
			if ((double)value < 0.9090909090909091)
			{
				value -= 0.8181818f;
				return end * (7.5625f * value * value + 0.9375f) + start;
			}
			value -= 21f / 22f;
			return end * (7.5625f * value * value + 63f / 64f) + start;
		}

		public static float EaseInOutBounce(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			if (value < num * 0.5f)
			{
				return EaseInBounce(0f, end, value * 2f) * 0.5f + start;
			}
			return EaseOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
		}

		public static float EaseInBack(float start, float end, float value)
		{
			end -= start;
			value /= 1f;
			float num = 1.70158f;
			return end * value * value * ((num + 1f) * value - num) + start;
		}

		public static float EaseOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value -= 1f;
			return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
		}

		public static float EaseInOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value /= 0.5f;
			if (value < 1f)
			{
				num *= 1.525f;
				return end * 0.5f * (value * value * ((num + 1f) * value - num)) + start;
			}
			value -= 2f;
			num *= 1.525f;
			return end * 0.5f * (value * value * ((num + 1f) * value + num) + 2f) + start;
		}

		public static float EaseInElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num) == 1f)
			{
				return start + end;
			}
			float num4;
			if (num3 == 0f || num3 < Mathf.Abs(end))
			{
				num3 = end;
				num4 = num2 / 4f;
			}
			else
			{
				num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
			}
			return 0f - num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2) + start;
		}

		public static float EaseOutElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num) == 1f)
			{
				return start + end;
			}
			float num4;
			if (num3 == 0f || num3 < Mathf.Abs(end))
			{
				num3 = end;
				num4 = num2 * 0.25f;
			}
			else
			{
				num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
			}
			return num3 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2) + end + start;
		}

		public static float EaseInOutElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num * 0.5f) == 2f)
			{
				return start + end;
			}
			float num4;
			if (num3 == 0f || num3 < Mathf.Abs(end))
			{
				num3 = end;
				num4 = num2 / 4f;
			}
			else
			{
				num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
			}
			if (value < 1f)
			{
				return -0.5f * (num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2)) + start;
			}
			return num3 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
		}

		public static float LinearD(float start, float end, float value)
		{
			return end - start;
		}

		public static float EaseInQuadD(float start, float end, float value)
		{
			return 2f * (end - start) * value;
		}

		public static float EaseOutQuadD(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * value - end * (value - 2f);
		}

		public static float EaseInOutQuadD(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * value;
			}
			value -= 1f;
			return end * (1f - value);
		}

		public static float EaseInCubicD(float start, float end, float value)
		{
			return 3f * (end - start) * value * value;
		}

		public static float EaseOutCubicD(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return 3f * end * value * value;
		}

		public static float EaseInOutCubicD(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return 1.5f * end * value * value;
			}
			value -= 2f;
			return 1.5f * end * value * value;
		}

		public static float EaseInQuartD(float start, float end, float value)
		{
			return 4f * (end - start) * value * value * value;
		}

		public static float EaseOutQuartD(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return -4f * end * value * value * value;
		}

		public static float EaseInOutQuartD(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return 2f * end * value * value * value;
			}
			value -= 2f;
			return -2f * end * value * value * value;
		}

		public static float EaseInQuintD(float start, float end, float value)
		{
			return 5f * (end - start) * value * value * value * value;
		}

		public static float EaseOutQuintD(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return 5f * end * value * value * value * value;
		}

		public static float EaseInOutQuintD(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return 2.5f * end * value * value * value * value;
			}
			value -= 2f;
			return 2.5f * end * value * value * value * value;
		}

		public static float EaseInSineD(float start, float end, float value)
		{
			return (end - start) * 0.5f * (float)Math.PI * Mathf.Sin((float)Math.PI / 2f * value);
		}

		public static float EaseOutSineD(float start, float end, float value)
		{
			end -= start;
			return (float)Math.PI / 2f * end * Mathf.Cos(value * ((float)Math.PI / 2f));
		}

		public static float EaseInOutSineD(float start, float end, float value)
		{
			end -= start;
			return end * 0.5f * (float)Math.PI * Mathf.Cos((float)Math.PI * value);
		}

		public static float EaseInExpoD(float start, float end, float value)
		{
			return 6.931472f * (end - start) * Mathf.Pow(2f, 10f * (value - 1f));
		}

		public static float EaseOutExpoD(float start, float end, float value)
		{
			end -= start;
			return 3.465736f * end * Mathf.Pow(2f, 1f - 10f * value);
		}

		public static float EaseInOutExpoD(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return 3.465736f * end * Mathf.Pow(2f, 10f * (value - 1f));
			}
			value -= 1f;
			return 3.465736f * end / Mathf.Pow(2f, 10f * value);
		}

		public static float EaseInCircD(float start, float end, float value)
		{
			return (end - start) * value / Mathf.Sqrt(1f - value * value);
		}

		public static float EaseOutCircD(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return (0f - end) * value / Mathf.Sqrt(1f - value * value);
		}

		public static float EaseInOutCircD(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * value / (2f * Mathf.Sqrt(1f - value * value));
			}
			value -= 2f;
			return (0f - end) * value / (2f * Mathf.Sqrt(1f - value * value));
		}

		public static float EaseInBounceD(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			return EaseOutBounceD(0f, end, num - value);
		}

		public static float EaseOutBounceD(float start, float end, float value)
		{
			value /= 1f;
			end -= start;
			if (value < 0.36363637f)
			{
				return 2f * end * 7.5625f * value;
			}
			if (value < 0.72727275f)
			{
				value -= 0.54545456f;
				return 2f * end * 7.5625f * value;
			}
			if ((double)value < 0.9090909090909091)
			{
				value -= 0.8181818f;
				return 2f * end * 7.5625f * value;
			}
			value -= 21f / 22f;
			return 2f * end * 7.5625f * value;
		}

		public static float EaseInOutBounceD(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			if (value < num * 0.5f)
			{
				return EaseInBounceD(0f, end, value * 2f) * 0.5f;
			}
			return EaseOutBounceD(0f, end, value * 2f - num) * 0.5f;
		}

		public static float EaseInBackD(float start, float end, float value)
		{
			float num = 1.70158f;
			return 3f * (num + 1f) * (end - start) * value * value - 2f * num * (end - start) * value;
		}

		public static float EaseOutBackD(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value -= 1f;
			return end * ((num + 1f) * value * value + 2f * value * ((num + 1f) * value + num));
		}

		public static float EaseInOutBackD(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value /= 0.5f;
			if (value < 1f)
			{
				num *= 1.525f;
				return 0.5f * end * (num + 1f) * value * value + end * value * ((num + 1f) * value - num);
			}
			value -= 2f;
			num *= 1.525f;
			return 0.5f * end * ((num + 1f) * value * value + 2f * value * ((num + 1f) * value + num));
		}

		public static float EaseInElasticD(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4;
			if (num3 == 0f || num3 < Mathf.Abs(end))
			{
				num3 = end;
				num4 = num2 / 4f;
			}
			else
			{
				num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
			}
			float num5 = (float)Math.PI * 2f;
			return (0f - num3) * num * num5 * Mathf.Cos(num5 * (num * (value - 1f) - num4) / num2) / num2 - 3.465736f * num3 * Mathf.Sin(num5 * (num * (value - 1f) - num4) / num2) * Mathf.Pow(2f, 10f * (value - 1f) + 1f);
		}

		public static float EaseOutElasticD(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4;
			if (num3 == 0f || num3 < Mathf.Abs(end))
			{
				num3 = end;
				num4 = num2 * 0.25f;
			}
			else
			{
				num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
			}
			return num3 * (float)Math.PI * num * Mathf.Pow(2f, 1f - 10f * value) * Mathf.Cos((float)Math.PI * 2f * (num * value - num4) / num2) / num2 - 3.465736f * num3 * Mathf.Pow(2f, 1f - 10f * value) * Mathf.Sin((float)Math.PI * 2f * (num * value - num4) / num2);
		}

		public static float EaseInOutElasticD(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4;
			if (num3 == 0f || num3 < Mathf.Abs(end))
			{
				num3 = end;
				num4 = num2 / 4f;
			}
			else
			{
				num4 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num3);
			}
			if (value < 1f)
			{
				value -= 1f;
				return -3.465736f * num3 * Mathf.Pow(2f, 10f * value) * Mathf.Sin((float)Math.PI * 2f * (num * value - 2f) / num2) - num3 * (float)Math.PI * num * Mathf.Pow(2f, 10f * value) * Mathf.Cos((float)Math.PI * 2f * (num * value - num4) / num2) / num2;
			}
			value -= 1f;
			return num3 * (float)Math.PI * num * Mathf.Cos((float)Math.PI * 2f * (num * value - num4) / num2) / (num2 * Mathf.Pow(2f, 10f * value)) - 3.465736f * num3 * Mathf.Sin((float)Math.PI * 2f * (num * value - num4) / num2) / Mathf.Pow(2f, 10f * value);
		}

		public static float SpringD(float start, float end, float value)
		{
			value = Mathf.Clamp01(value);
			end -= start;
			return end * (6f * (1f - value) / 5f + 1f) * (-2.2f * Mathf.Pow(1f - value, 1.2f) * Mathf.Sin((float)Math.PI * value * (2.5f * value * value * value + 0.2f)) + Mathf.Pow(1f - value, 2.2f) * ((float)Math.PI * (2.5f * value * value * value + 0.2f) + 23.561945f * value * value * value) * Mathf.Cos((float)Math.PI * value * (2.5f * value * value * value + 0.2f)) + 1f) - 6f * end * (Mathf.Pow(1f - value, 2.2f) * Mathf.Sin((float)Math.PI * value * (2.5f * value * value * value + 0.2f)) + value / 5f);
		}

		public static float CustomCurve(float start, float end, float value)
		{
			if (AnimationCurve == null)
			{
				return Mathf.Lerp(start, end, value);
			}
			return Mathf.Lerp(start, end, AnimationCurve.Evaluate(value));
		}

		public static Function GetEasingFunction(Ease easingFunction)
		{
			return easingFunction switch
			{
				Ease.CustomCurve => CustomCurve, 
				Ease.EaseInQuad => EaseInQuad, 
				Ease.EaseOutQuad => EaseOutQuad, 
				Ease.EaseInOutQuad => EaseInOutQuad, 
				Ease.EaseInCubic => EaseInCubic, 
				Ease.EaseOutCubic => EaseOutCubic, 
				Ease.EaseInOutCubic => EaseInOutCubic, 
				Ease.EaseInQuart => EaseInQuart, 
				Ease.EaseOutQuart => EaseOutQuart, 
				Ease.EaseInOutQuart => EaseInOutQuart, 
				Ease.EaseInQuint => EaseInQuint, 
				Ease.EaseOutQuint => EaseOutQuint, 
				Ease.EaseInOutQuint => EaseInOutQuint, 
				Ease.EaseInSine => EaseInSine, 
				Ease.EaseOutSine => EaseOutSine, 
				Ease.EaseInOutSine => EaseInOutSine, 
				Ease.EaseInExpo => EaseInExpo, 
				Ease.EaseOutExpo => EaseOutExpo, 
				Ease.EaseInOutExpo => EaseInOutExpo, 
				Ease.EaseInCirc => EaseInCirc, 
				Ease.EaseOutCirc => EaseOutCirc, 
				Ease.EaseInOutCirc => EaseInOutCirc, 
				Ease.Linear => Linear, 
				Ease.Spring => Spring, 
				Ease.EaseInBounce => EaseInBounce, 
				Ease.EaseOutBounce => EaseOutBounce, 
				Ease.EaseInOutBounce => EaseInOutBounce, 
				Ease.EaseInBack => EaseInBack, 
				Ease.EaseOutBack => EaseOutBack, 
				Ease.EaseInOutBack => EaseInOutBack, 
				Ease.EaseInElastic => EaseInElastic, 
				Ease.EaseOutElastic => EaseOutElastic, 
				Ease.EaseInOutElastic => EaseInOutElastic, 
				_ => null, 
			};
		}

		public static Function GetEasingFunctionDerivative(Ease easingFunction)
		{
			return easingFunction switch
			{
				Ease.EaseInQuad => EaseInQuadD, 
				Ease.EaseOutQuad => EaseOutQuadD, 
				Ease.EaseInOutQuad => EaseInOutQuadD, 
				Ease.EaseInCubic => EaseInCubicD, 
				Ease.EaseOutCubic => EaseOutCubicD, 
				Ease.EaseInOutCubic => EaseInOutCubicD, 
				Ease.EaseInQuart => EaseInQuartD, 
				Ease.EaseOutQuart => EaseOutQuartD, 
				Ease.EaseInOutQuart => EaseInOutQuartD, 
				Ease.EaseInQuint => EaseInQuintD, 
				Ease.EaseOutQuint => EaseOutQuintD, 
				Ease.EaseInOutQuint => EaseInOutQuintD, 
				Ease.EaseInSine => EaseInSineD, 
				Ease.EaseOutSine => EaseOutSineD, 
				Ease.EaseInOutSine => EaseInOutSineD, 
				Ease.EaseInExpo => EaseInExpoD, 
				Ease.EaseOutExpo => EaseOutExpoD, 
				Ease.EaseInOutExpo => EaseInOutExpoD, 
				Ease.EaseInCirc => EaseInCircD, 
				Ease.EaseOutCirc => EaseOutCircD, 
				Ease.EaseInOutCirc => EaseInOutCircD, 
				Ease.Linear => LinearD, 
				Ease.Spring => SpringD, 
				Ease.EaseInBounce => EaseInBounceD, 
				Ease.EaseOutBounce => EaseOutBounceD, 
				Ease.EaseInOutBounce => EaseInOutBounceD, 
				Ease.EaseInBack => EaseInBackD, 
				Ease.EaseOutBack => EaseOutBackD, 
				Ease.EaseInOutBack => EaseInOutBackD, 
				Ease.EaseInElastic => EaseInElasticD, 
				Ease.EaseOutElastic => EaseOutElasticD, 
				Ease.EaseInOutElastic => EaseInOutElasticD, 
				_ => null, 
			};
		}
	}
}
namespace HutongGames.PlayMaker
{
	public static class ActionHelpers
	{
		public static RaycastHit mousePickInfo;

		private static float mousePickRaycastTime;

		private static float mousePickDistanceUsed;

		private static int mousePickLayerMaskUsed;

		public static Texture2D WhiteTexture => Texture2D.whiteTexture;

		public static Color BlendColor(ColorBlendMode blendMode, Color c1, Color c2)
		{
			switch (blendMode)
			{
			case ColorBlendMode.Normal:
				return Color.Lerp(c1, c2, c2.a);
			case ColorBlendMode.Multiply:
				return Color.Lerp(c1, c1 * c2, c2.a);
			case ColorBlendMode.Screen:
			{
				Color b = Color.white - (Color.white - c1) * (Color.white - c2);
				return Color.Lerp(c1, b, c2.a);
			}
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public static bool IsVisible(GameObject go)
		{
			if (go == null)
			{
				return false;
			}
			Renderer component = go.GetComponent<Renderer>();
			if (component != null)
			{
				return component.isVisible;
			}
			return false;
		}

		public static GameObject GetOwnerDefault(FsmStateAction action, FsmOwnerDefault ownerDefault)
		{
			return action.Fsm.GetOwnerDefaultTarget(ownerDefault);
		}

		public static PlayMakerFSM GetGameObjectFsm(GameObject go, string fsmName)
		{
			if (!string.IsNullOrEmpty(fsmName))
			{
				PlayMakerFSM[] components = go.GetComponents<PlayMakerFSM>();
				foreach (PlayMakerFSM playMakerFSM in components)
				{
					if (playMakerFSM.FsmName == fsmName)
					{
						return playMakerFSM;
					}
				}
				UnityEngine.Debug.LogWarning("Could not find FSM: " + fsmName);
			}
			return go.GetComponent<PlayMakerFSM>();
		}

		public static int GetRandomWeightedIndex(FsmFloat[] weights)
		{
			float num = 0f;
			foreach (FsmFloat fsmFloat in weights)
			{
				num += fsmFloat.Value;
			}
			float num2 = UnityEngine.Random.Range(0f, num);
			for (int j = 0; j < weights.Length; j++)
			{
				if (num2 < weights[j].Value)
				{
					return j;
				}
				num2 -= weights[j].Value;
			}
			return -1;
		}

		public static void AddAnimationClip(GameObject go, AnimationClip animClip)
		{
			if (!(animClip == null))
			{
				Animation component = go.GetComponent<Animation>();
				if (component != null)
				{
					component.AddClip(animClip, animClip.name);
				}
			}
		}

		public static bool HasAnimationFinished(AnimationState anim, float prevTime, float currentTime)
		{
			if (anim.wrapMode == WrapMode.Loop || anim.wrapMode == WrapMode.PingPong)
			{
				return false;
			}
			if ((anim.wrapMode == WrapMode.Default || anim.wrapMode == WrapMode.Once) && prevTime > 0f && currentTime.Equals(0f))
			{
				return true;
			}
			if (prevTime < anim.length)
			{
				return currentTime >= anim.length;
			}
			return false;
		}

		public static Vector3 GetPosition(FsmGameObject fsmGameObject, FsmVector3 fsmVector3)
		{
			if (fsmGameObject.Value != null)
			{
				return (!fsmVector3.IsNone) ? fsmGameObject.Value.transform.TransformPoint(fsmVector3.Value) : fsmGameObject.Value.transform.position;
			}
			return fsmVector3.Value;
		}

		public static Quaternion GetTargetRotation(RotationOptions option, Transform owner, Transform target, Vector3 rotation)
		{
			if (owner == null)
			{
				return Quaternion.identity;
			}
			switch (option)
			{
			case RotationOptions.CurrentRotation:
				return owner.rotation;
			case RotationOptions.WorldRotation:
				return Quaternion.Euler(rotation);
			case RotationOptions.LocalRotation:
				if (owner.parent == null)
				{
					return Quaternion.Euler(rotation);
				}
				return owner.parent.rotation * Quaternion.Euler(rotation);
			case RotationOptions.WorldOffsetRotation:
				return Quaternion.Euler(rotation) * owner.rotation;
			case RotationOptions.LocalOffsetRotation:
				return owner.rotation * Quaternion.Euler(rotation);
			case RotationOptions.MatchGameObjectRotation:
				if (target == null)
				{
					return owner.rotation;
				}
				return target.rotation * Quaternion.Euler(rotation);
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public static bool GetTargetRotation(RotationOptions option, Transform owner, FsmVector3 rotation, FsmGameObject target, out Quaternion targetRotation)
		{
			targetRotation = Quaternion.identity;
			if (owner == null || !CanEditTargetRotation(option, rotation, target))
			{
				return false;
			}
			targetRotation = GetTargetRotation(option, owner, (target.Value != null) ? target.Value.transform : null, rotation.Value);
			return true;
		}

		private static bool CanEditTargetRotation(RotationOptions option, NamedVariable rotation, FsmGameObject target)
		{
			switch (option)
			{
			case RotationOptions.CurrentRotation:
				return false;
			case RotationOptions.WorldRotation:
			case RotationOptions.LocalRotation:
			case RotationOptions.WorldOffsetRotation:
			case RotationOptions.LocalOffsetRotation:
				return !rotation.IsNone;
			case RotationOptions.MatchGameObjectRotation:
				return target.Value != null;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public static Vector3 GetTargetScale(ScaleOptions option, Transform owner, Transform target, Vector3 scale)
		{
			if (owner == null)
			{
				return Vector3.one;
			}
			switch (option)
			{
			case ScaleOptions.CurrentScale:
				return owner.localScale;
			case ScaleOptions.LocalScale:
				return scale;
			case ScaleOptions.MultiplyScale:
				return new Vector3(owner.localScale.x * scale.x, owner.localScale.y * scale.y, owner.localScale.z * scale.z);
			case ScaleOptions.AddToScale:
				return new Vector3(owner.localScale.x + scale.x, owner.localScale.y + scale.y, owner.localScale.z + scale.z);
			case ScaleOptions.MatchGameObject:
				if (target == null)
				{
					return owner.localScale;
				}
				return target.localScale;
			default:
				return owner.localScale;
			}
		}

		public static bool GetTargetPosition(PositionOptions option, Transform owner, FsmVector3 position, FsmGameObject target, out Vector3 targetPosition)
		{
			targetPosition = Vector3.zero;
			if (owner == null || !IsValidTargetPosition(option, position, target))
			{
				return false;
			}
			targetPosition = GetTargetPosition(option, owner, (target != null && target.Value != null) ? target.Value.transform : null, position.Value);
			return true;
		}

		private static bool IsValidTargetPosition(PositionOptions option, NamedVariable position, FsmGameObject target)
		{
			switch (option)
			{
			case PositionOptions.CurrentPosition:
				return true;
			case PositionOptions.WorldPosition:
			case PositionOptions.LocalPosition:
			case PositionOptions.WorldOffset:
			case PositionOptions.LocalOffset:
				return !position.IsNone;
			case PositionOptions.TargetGameObject:
				return target.Value != null;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public static bool CanEditTargetPosition(PositionOptions option, NamedVariable position, FsmGameObject target)
		{
			switch (option)
			{
			case PositionOptions.CurrentPosition:
				return false;
			case PositionOptions.WorldPosition:
			case PositionOptions.LocalPosition:
			case PositionOptions.WorldOffset:
			case PositionOptions.LocalOffset:
				return !position.IsNone;
			case PositionOptions.TargetGameObject:
				return target.Value != null;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public static Vector3 GetTargetPosition(PositionOptions option, Transform owner, Transform target, Vector3 position)
		{
			if (owner == null)
			{
				return Vector3.zero;
			}
			switch (option)
			{
			case PositionOptions.CurrentPosition:
				return owner.position;
			case PositionOptions.WorldPosition:
				return position;
			case PositionOptions.LocalPosition:
				if (owner.parent == null)
				{
					return position;
				}
				return owner.parent.TransformPoint(position);
			case PositionOptions.WorldOffset:
				return owner.position + position;
			case PositionOptions.LocalOffset:
				return owner.TransformPoint(position);
			case PositionOptions.TargetGameObject:
				if (target == null)
				{
					return owner.position;
				}
				if (position != Vector3.zero)
				{
					return target.TransformPoint(position);
				}
				return target.position;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public static bool IsMouseOver(GameObject gameObject, float distance, int layerMask)
		{
			if (gameObject == null)
			{
				return false;
			}
			return gameObject == MouseOver(distance, layerMask);
		}

		public static RaycastHit MousePick(float distance, int layerMask)
		{
			if (!mousePickRaycastTime.Equals(Time.frameCount) || mousePickDistanceUsed < distance || mousePickLayerMaskUsed != layerMask)
			{
				DoMousePick(distance, layerMask);
			}
			return mousePickInfo;
		}

		public static GameObject MouseOver(float distance, int layerMask)
		{
			if (!mousePickRaycastTime.Equals(Time.frameCount) || mousePickDistanceUsed < distance || mousePickLayerMaskUsed != layerMask)
			{
				DoMousePick(distance, layerMask);
			}
			if (mousePickInfo.collider != null && mousePickInfo.distance < distance)
			{
				return mousePickInfo.collider.gameObject;
			}
			return null;
		}

		private static void DoMousePick(float distance, int layerMask)
		{
			if (!(Camera.main == null))
			{
				Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out mousePickInfo, distance, layerMask);
				mousePickLayerMaskUsed = layerMask;
				mousePickDistanceUsed = distance;
				mousePickRaycastTime = Time.frameCount;
			}
		}

		public static int LayerArrayToLayerMask(FsmInt[] layers, bool invert)
		{
			int num = 0;
			foreach (FsmInt fsmInt in layers)
			{
				num |= 1 << fsmInt.Value;
			}
			if (invert)
			{
				num = ~num;
			}
			if (num != 0)
			{
				return num;
			}
			return -5;
		}

		public static bool IsLoopingWrapMode(WrapMode wrapMode)
		{
			if (wrapMode != WrapMode.Loop)
			{
				return wrapMode == WrapMode.PingPong;
			}
			return true;
		}

		public static string CheckRayDistance(float rayDistance)
		{
			if (!(rayDistance <= 0f))
			{
				return "";
			}
			return "Ray Distance should be greater than zero!\n";
		}

		public static string CheckForValidEvent(FsmState state, string eventName)
		{
			if (state == null)
			{
				return "Invalid State!";
			}
			if (string.IsNullOrEmpty(eventName))
			{
				return "";
			}
			FsmTransition[] globalTransitions = state.Fsm.GlobalTransitions;
			for (int i = 0; i < globalTransitions.Length; i++)
			{
				if (globalTransitions[i].EventName == eventName)
				{
					return "";
				}
			}
			globalTransitions = state.Transitions;
			for (int i = 0; i < globalTransitions.Length; i++)
			{
				if (globalTransitions[i].EventName == eventName)
				{
					return "";
				}
			}
			return "Fsm will not respond to Event: " + eventName;
		}

		public static string CheckPhysicsSetup(FsmOwnerDefault ownerDefault)
		{
			if (ownerDefault == null)
			{
				return "";
			}
			return CheckPhysicsSetup(ownerDefault.GameObject.Value);
		}

		public static string CheckOwnerPhysicsSetup(GameObject gameObject)
		{
			return CheckPhysicsSetup(gameObject);
		}

		public static string CheckPhysicsSetup(GameObject gameObject)
		{
			string text = string.Empty;
			if (gameObject != null && gameObject.GetComponent<Collider>() == null && gameObject.GetComponent<Rigidbody>() == null)
			{
				text += "GameObject requires RigidBody/Collider!\n";
			}
			return text;
		}

		public static string CheckPhysics2dSetup(FsmOwnerDefault ownerDefault)
		{
			if (ownerDefault == null)
			{
				return "";
			}
			return CheckPhysics2dSetup(ownerDefault.GameObject.Value);
		}

		public static string CheckOwnerPhysics2dSetup(GameObject gameObject)
		{
			return CheckPhysics2dSetup(gameObject);
		}

		public static string CheckPhysics2dSetup(GameObject gameObject)
		{
			string text = string.Empty;
			if (gameObject != null && gameObject.GetComponent<Collider2D>() == null && gameObject.GetComponent<Rigidbody2D>() == null)
			{
				text += "GameObject requires a RigidBody2D or Collider2D component!\n";
			}
			return text;
		}

		public static void DebugLog(Fsm fsm, LogLevel logLevel, string text, bool sendToUnityLog = false)
		{
			if (!UnityEngine.Application.isEditor && sendToUnityLog)
			{
				string message = FormatUnityLogString(text);
				switch (logLevel)
				{
				case LogLevel.Warning:
					UnityEngine.Debug.LogWarning(message);
					break;
				case LogLevel.Error:
					UnityEngine.Debug.LogError(message);
					break;
				default:
					UnityEngine.Debug.Log(message);
					break;
				}
			}
			if (FsmLog.LoggingEnabled && fsm != null)
			{
				switch (logLevel)
				{
				case LogLevel.Info:
					fsm.MyLog.LogAction(FsmLogType.Info, text, sendToUnityLog);
					break;
				case LogLevel.Warning:
					fsm.MyLog.LogAction(FsmLogType.Warning, text, sendToUnityLog);
					break;
				case LogLevel.Error:
					fsm.MyLog.LogAction(FsmLogType.Error, text, sendToUnityLog);
					break;
				}
			}
		}

		public static void LogError(string text)
		{
			DebugLog(FsmExecutionStack.ExecutingFsm, LogLevel.Error, text, sendToUnityLog: true);
		}

		public static void LogWarning(string text)
		{
			DebugLog(FsmExecutionStack.ExecutingFsm, LogLevel.Warning, text, sendToUnityLog: true);
		}

		public static string FormatUnityLogString(string text)
		{
			if (FsmExecutionStack.ExecutingFsm == null)
			{
				return text;
			}
			string text2 = Fsm.GetFullFsmLabel(FsmExecutionStack.ExecutingFsm);
			if (FsmExecutionStack.ExecutingState != null)
			{
				text2 = text2 + " : " + FsmExecutionStack.ExecutingStateName;
			}
			if (FsmExecutionStack.ExecutingAction != null)
			{
				text2 += FsmExecutionStack.ExecutingAction.Name;
			}
			return text2 + " : " + text;
		}

		public static string GetValueLabel(INamedVariable variable)
		{
			return "";
		}

		public static string GetValueLabel(Fsm fsm, FsmOwnerDefault ownerDefault)
		{
			if (ownerDefault == null)
			{
				return "[null]";
			}
			if (ownerDefault.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				return "Owner";
			}
			return GetValueLabel(ownerDefault.GameObject);
		}

		public static string AutoName(FsmStateAction action, params INamedVariable[] exposedFields)
		{
			if (action != null)
			{
				return AutoName(action.GetType().Name, exposedFields);
			}
			return null;
		}

		public static string AutoName(string actionName, params INamedVariable[] exposedFields)
		{
			string text = actionName + " :";
			foreach (INamedVariable variable in exposedFields)
			{
				text = text + " " + GetValueLabel(variable);
			}
			return text;
		}

		public static string AutoNameRange(FsmStateAction action, NamedVariable min, NamedVariable max)
		{
			if (action != null)
			{
				return AutoNameRange(action.GetType().Name, min, max);
			}
			return null;
		}

		public static string AutoNameRange(string actionName, NamedVariable min, NamedVariable max)
		{
			return actionName + " : " + GetValueLabel(min) + " - " + GetValueLabel(max);
		}

		public static string AutoNameSetVar(FsmStateAction action, NamedVariable var, NamedVariable value)
		{
			if (action != null)
			{
				return AutoNameSetVar(action.GetType().Name, var, value);
			}
			return null;
		}

		public static string AutoNameSetVar(string actionName, NamedVariable var, NamedVariable value)
		{
			return actionName + " : " + GetValueLabel(var) + " = " + GetValueLabel(value);
		}

		public static string AutoNameConvert(FsmStateAction action, NamedVariable fromVariable, NamedVariable toVariable)
		{
			if (action != null)
			{
				return AutoNameConvert(action.GetType().Name, fromVariable, toVariable);
			}
			return null;
		}

		public static string AutoNameConvert(string actionName, NamedVariable fromVariable, NamedVariable toVariable)
		{
			return actionName.Replace("Convert", "") + " : " + GetValueLabel(fromVariable) + " to " + GetValueLabel(toVariable);
		}

		public static string AutoNameGetProperty(FsmStateAction action, NamedVariable property, NamedVariable store)
		{
			if (action != null)
			{
				return AutoNameGetProperty(action.GetType().Name, property, store);
			}
			return null;
		}

		public static string AutoNameGetProperty(string actionName, NamedVariable property, NamedVariable store)
		{
			return actionName + " : " + GetValueLabel(property) + " -> " + GetValueLabel(store);
		}

		[Obsolete("Use LogError instead.")]
		public static void RuntimeError(FsmStateAction action, string error)
		{
			action.LogError(string.Concat(action, " : ", error));
		}
	}
	public class PlayMakerCanvasRaycastFilterProxy : MonoBehaviour, ICanvasRaycastFilter
	{
		public bool RayCastingEnabled = true;

		public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)
		{
			return RayCastingEnabled;
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Bool Value Changed Event")]
	public class PlayMakerUiBoolValueChangedEvent : PlayMakerUiEventBase
	{
		public Toggle toggle;

		protected override void Initialize()
		{
			if (!initialized)
			{
				initialized = true;
				if (toggle == null)
				{
					toggle = GetComponent<Toggle>();
				}
				if (toggle != null)
				{
					toggle.onValueChanged.AddListener(OnValueChanged);
				}
			}
		}

		protected void OnDisable()
		{
			initialized = false;
			if (toggle != null)
			{
				toggle.onValueChanged.RemoveListener(OnValueChanged);
			}
		}

		private void OnValueChanged(bool value)
		{
			Fsm.EventData.BoolData = value;
			SendEvent(FsmEvent.UiBoolValueChanged);
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Click Event")]
	public class PlayMakerUiClickEvent : PlayMakerUiEventBase
	{
		public Button button;

		protected override void Initialize()
		{
			if (!initialized)
			{
				initialized = true;
				if (button == null)
				{
					button = GetComponent<Button>();
				}
				if (button != null)
				{
					button.onClick.AddListener(DoOnClick);
				}
			}
		}

		protected void OnDisable()
		{
			initialized = false;
			if (button != null)
			{
				button.onClick.RemoveListener(DoOnClick);
			}
		}

		private void DoOnClick()
		{
			SendEvent(FsmEvent.UiClick);
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Drag Events")]
	public class PlayMakerUiDragEvents : PlayMakerUiEventBase, IDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler
	{
		public void OnBeginDrag(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiBeginDrag);
		}

		public void OnDrag(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiDrag);
		}

		public void OnEndDrag(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiEndDrag);
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Drop Event")]
	public class PlayMakerUiDropEvent : PlayMakerUiEventBase, IDropHandler, IEventSystemHandler
	{
		public void OnDrop(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiDrop);
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI End Edit Event")]
	public class PlayMakerUiEndEditEvent : PlayMakerUiEventBase
	{
		public InputField inputField;

		protected override void Initialize()
		{
			if (!initialized)
			{
				initialized = true;
				if (inputField == null)
				{
					inputField = GetComponent<InputField>();
				}
				if (inputField != null)
				{
					inputField.onEndEdit.AddListener(DoOnEndEdit);
				}
			}
		}

		protected void OnDisable()
		{
			initialized = false;
			if (inputField != null)
			{
				inputField.onEndEdit.RemoveListener(DoOnEndEdit);
			}
		}

		private void DoOnEndEdit(string value)
		{
			Fsm.EventData.StringData = value;
			SendEvent(FsmEvent.UiEndEdit);
		}
	}
	public abstract class PlayMakerUiEventBase : MonoBehaviour
	{
		public List<PlayMakerFSM> targetFsms = new List<PlayMakerFSM>();

		[NonSerialized]
		protected bool initialized;

		public void AddTargetFsm(PlayMakerFSM fsm)
		{
			if (!TargetsFsm(fsm))
			{
				targetFsms.Add(fsm);
			}
			Initialize();
		}

		private bool TargetsFsm(PlayMakerFSM fsm)
		{
			for (int i = 0; i < targetFsms.Count; i++)
			{
				PlayMakerFSM playMakerFSM = targetFsms[i];
				if (fsm == playMakerFSM)
				{
					return true;
				}
			}
			return false;
		}

		protected void OnEnable()
		{
			Initialize();
		}

		public void PreProcess()
		{
			Initialize();
		}

		protected virtual void Initialize()
		{
			initialized = true;
		}

		protected void SendEvent(FsmEvent fsmEvent)
		{
			for (int i = 0; i < targetFsms.Count; i++)
			{
				targetFsms[i].Fsm.Event(base.gameObject, fsmEvent);
			}
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Float Value Changed Event")]
	public class PlayMakerUiFloatValueChangedEvent : PlayMakerUiEventBase
	{
		public Slider slider;

		public Scrollbar scrollbar;

		protected override void Initialize()
		{
			if (!initialized)
			{
				initialized = true;
				if (slider == null)
				{
					slider = GetComponent<Slider>();
				}
				if (slider != null)
				{
					slider.onValueChanged.AddListener(OnValueChanged);
				}
				if (scrollbar == null)
				{
					scrollbar = GetComponent<Scrollbar>();
				}
				if (scrollbar != null)
				{
					scrollbar.onValueChanged.AddListener(OnValueChanged);
				}
			}
		}

		protected void OnDisable()
		{
			initialized = false;
			if (slider != null)
			{
				slider.onValueChanged.RemoveListener(OnValueChanged);
			}
			if (scrollbar != null)
			{
				scrollbar.onValueChanged.RemoveListener(OnValueChanged);
			}
		}

		private void OnValueChanged(float value)
		{
			Fsm.EventData.FloatData = value;
			SendEvent(FsmEvent.UiFloatValueChanged);
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Int Value Changed Event")]
	public class PlayMakerUiIntValueChangedEvent : PlayMakerUiEventBase
	{
		public Dropdown dropdown;

		protected override void Initialize()
		{
			if (!initialized)
			{
				initialized = true;
				if (dropdown == null)
				{
					dropdown = GetComponent<Dropdown>();
				}
				if (dropdown != null)
				{
					dropdown.onValueChanged.AddListener(OnValueChanged);
				}
			}
		}

		protected void OnDisable()
		{
			initialized = false;
			if (dropdown != null)
			{
				dropdown.onValueChanged.RemoveListener(OnValueChanged);
			}
		}

		private void OnValueChanged(int value)
		{
			Fsm.EventData.IntData = value;
			SendEvent(FsmEvent.UiIntValueChanged);
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Pointer Events")]
	public class PlayMakerUiPointerEvents : PlayMakerUiEventBase, IPointerClickHandler, IEventSystemHandler, IPointerDownHandler, IPointerEnterHandler, IPointerExitHandler, IPointerUpHandler
	{
		public void OnPointerClick(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiPointerClick);
		}

		public void OnPointerDown(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiPointerDown);
		}

		public void OnPointerEnter(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiPointerEnter);
		}

		public void OnPointerExit(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiPointerExit);
		}

		public void OnPointerUp(PointerEventData eventData)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = eventData;
			SendEvent(FsmEvent.UiPointerUp);
		}
	}
	[AddComponentMenu("PlayMaker/UI/UI Vector2 Value Changed Event")]
	public class PlayMakerUiVector2ValueChangedEvent : PlayMakerUiEventBase
	{
		public ScrollRect scrollRect;

		protected override void Initialize()
		{
			if (!initialized)
			{
				initialized = true;
				if (scrollRect == null)
				{
					scrollRect = GetComponent<ScrollRect>();
				}
				if (scrollRect != null)
				{
					scrollRect.onValueChanged.AddListener(OnValueChanged);
				}
			}
		}

		protected void OnDisable()
		{
			initialized = false;
			if (scrollRect != null)
			{
				scrollRect.onValueChanged.RemoveListener(OnValueChanged);
			}
		}

		private void OnValueChanged(Vector2 value)
		{
			Fsm.EventData.Vector2Data = value;
			SendEvent(FsmEvent.UiVector2ValueChanged);
		}
	}
	[Preserve]
	public class FsmProcessor
	{
		public static void OnPreprocess(PlayMakerFSM fsm)
		{
			if (fsm.Fsm.HandleLegacyNetworking && !AddEventHandlerComponent(fsm, ReflectionUtils.GetGlobalType("PlayMakerLegacyNetworking")))
			{
				UnityEngine.Debug.LogError("Could not add PlayMakerLegacyNetworking proxy!");
			}
			if (fsm.Fsm.HandleUiEvents != 0)
			{
				HandleUiEvent<PlayMakerUiClickEvent>(fsm, UiEvents.Click);
				HandleUiEvent<PlayMakerUiDragEvents>(fsm, UiEvents.DragEvents);
				HandleUiEvent<PlayMakerUiDropEvent>(fsm, UiEvents.Drop);
				HandleUiEvent<PlayMakerUiPointerEvents>(fsm, UiEvents.PointerEvents);
				HandleUiEvent<PlayMakerUiBoolValueChangedEvent>(fsm, UiEvents.BoolValueChanged);
				HandleUiEvent<PlayMakerUiFloatValueChangedEvent>(fsm, UiEvents.FloatValueChanged);
				HandleUiEvent<PlayMakerUiIntValueChangedEvent>(fsm, UiEvents.IntValueChanged);
				HandleUiEvent<PlayMakerUiVector2ValueChangedEvent>(fsm, UiEvents.Vector2ValueChanged);
				HandleUiEvent<PlayMakerUiEndEditEvent>(fsm, UiEvents.EndEdit);
			}
		}

		private static void HandleUiEvent<T>(PlayMakerFSM fsm, UiEvents uiEvent) where T : PlayMakerUiEventBase
		{
			if ((fsm.Fsm.HandleUiEvents & uiEvent) != 0)
			{
				AddUiEventHandler<T>(fsm);
			}
		}

		private static void AddUiEventHandler<T>(PlayMakerFSM fsm) where T : PlayMakerUiEventBase
		{
			T val = fsm.GetComponent<T>();
			if (val == null)
			{
				val = fsm.gameObject.AddComponent<T>();
				if (!PlayMakerPrefs.ShowEventHandlerComponents)
				{
					val.hideFlags = HideFlags.HideInInspector;
				}
			}
			val.AddTargetFsm(fsm);
		}

		private static bool AddEventHandlerComponent(PlayMakerFSM fsm, Type type)
		{
			if (type == null)
			{
				return false;
			}
			PlayMakerProxyBase eventHandlerComponent = GetEventHandlerComponent(fsm.gameObject, type);
			if (eventHandlerComponent == null)
			{
				return false;
			}
			eventHandlerComponent.AddTarget(fsm);
			if (!PlayMakerGlobals.IsEditor && PlayMakerPrefs.LogPerformanceWarnings)
			{
				UnityEngine.Debug.Log("AddEventHandlerComponent: " + type.FullName);
			}
			return true;
		}

		public static PlayMakerProxyBase GetEventHandlerComponent(GameObject go, Type type)
		{
			if (go == null)
			{
				return null;
			}
			Component component = go.GetComponent(type);
			if (component == null)
			{
				component = go.AddComponent(type);
				if (!PlayMakerPrefs.ShowEventHandlerComponents)
				{
					component.hideFlags = HideFlags.HideInInspector;
				}
			}
			return component as PlayMakerProxyBase;
		}
	}
	public class UpdateHelper
	{
		private static bool editorPrefLoaded;

		public static void SetDirty(Fsm fsm)
		{
		}
	}
}
namespace HutongGames.PlayMaker.Ecosystem.utils
{
	public class Comment : MonoBehaviour
	{
		public string Text;
	}
	public struct VersionInfo : IComparable<VersionInfo>
	{
		public enum VersionType
		{
			Alpha,
			Beta,
			ReleaseCandidate,
			Final
		}

		public int Major;

		public int Minor;

		public int Patch;

		public int Maintenance;

		public VersionType Type;

		public int Build;

		public string Appendix;

		public VersionInfo(int major, int minor = 0, int patch = 0)
		{
			Major = major;
			Minor = minor;
			Patch = patch;
			Type = VersionType.Final;
			Build = 0;
			Appendix = "";
			Maintenance = 0;
		}

		public VersionInfo(int major, int minor = 0, int patch = 0, int build = 0)
		{
			Major = major;
			Minor = minor;
			Patch = patch;
			Type = VersionType.Final;
			Build = build;
			Appendix = "";
			Maintenance = 0;
		}

		public VersionInfo(int major, int minor = 0, int patch = 0, VersionType type = VersionType.Final, int build = 0)
		{
			Major = major;
			Minor = minor;
			Patch = patch;
			Type = type;
			Build = build;
			Appendix = "";
			Maintenance = 0;
		}

		public VersionInfo(int major, int minor = 0, int patch = 0, int maintenance = 0, VersionType type = VersionType.Final, int build = 0)
		{
			Major = major;
			Minor = minor;
			Patch = patch;
			Maintenance = maintenance;
			Type = type;
			Build = build;
			Appendix = "";
		}

		public VersionInfo(string version)
		{
			Major = 0;
			Minor = 0;
			Patch = 0;
			Maintenance = 0;
			Type = VersionType.Final;
			Build = 0;
			Appendix = "";
			if (!string.IsNullOrEmpty(version))
			{
				Match match = Regex.Match(version, "^(\\d+)\\.(\\d+)(\\.(\\d+))?\\s*\\.*(\\w+)?", RegexOptions.IgnoreCase);
				if (match.Groups.Count > 1)
				{
					Major = Convert.ToInt32(match.Groups[1].Value);
				}
				if (match.Groups.Count > 2)
				{
					Minor = Convert.ToInt32(match.Groups[2].Value);
				}
				if (match.Groups.Count > 3 && match.Groups[3].Value.StartsWith("."))
				{
					Patch = Convert.ToInt32(match.Groups[4].Value);
				}
				if (match.Groups.Count > 5)
				{
					Appendix = match.Groups[5].Value;
					Appendix = Appendix.Trim();
				}
				Type = VersionType.Final;
				Build = 0;
			}
		}

		public static VersionInfo UnityVersion()
		{
			Match match = Regex.Match(UnityEngine.Application.unityVersion, "^(\\d+)\\.(\\d+)\\.(\\d+)");
			int build = 0;
			VersionInfo result = default(VersionInfo);
			result.Major = Convert.ToInt32(match.Groups[1].Value);
			result.Minor = Convert.ToInt32(match.Groups[2].Value);
			result.Patch = Convert.ToInt32(match.Groups[3].Value);
			result.Build = build;
			return result;
		}

		public VersionInfo Clone()
		{
			return new VersionInfo(Major, Minor, Patch, Type, Build);
		}

		public int CompareTo(VersionInfo other)
		{
			if (Major < other.Major)
			{
				return -1;
			}
			if (Major > other.Major)
			{
				return 1;
			}
			if (Minor < other.Minor)
			{
				return -1;
			}
			if (Minor > other.Minor)
			{
				return 1;
			}
			if (Patch < other.Patch)
			{
				return -1;
			}
			if (Patch > other.Patch)
			{
				return 1;
			}
			if (Build < other.Build)
			{
				return -1;
			}
			if (Build > other.Build)
			{
				return 1;
			}
			return 0;
		}

		public bool isDefined()
		{
			if (Major == 0 && Minor == 0 && Patch == 0 && Maintenance == 0)
			{
				return false;
			}
			return true;
		}

		public static bool operator ==(VersionInfo a, VersionInfo b)
		{
			return a.CompareTo(b) == 0;
		}

		public static bool operator !=(VersionInfo a, VersionInfo b)
		{
			return a.CompareTo(b) != 0;
		}

		public static bool operator <=(VersionInfo a, VersionInfo b)
		{
			return a.CompareTo(b) <= 0;
		}

		public static bool operator >=(VersionInfo a, VersionInfo b)
		{
			return a.CompareTo(b) >= 0;
		}

		public static bool operator <(VersionInfo a, VersionInfo b)
		{
			return a.CompareTo(b) < 0;
		}

		public static bool operator >(VersionInfo a, VersionInfo b)
		{
			return a.CompareTo(b) > 0;
		}

		public static VersionType GetVersionTypeFromString(string type)
		{
			if (string.IsNullOrEmpty(type))
			{
				return VersionType.Final;
			}
			switch (type.ToLower())
			{
			case "a":
			case "alpha":
				return VersionType.Alpha;
			case "b":
			case "beta":
				return VersionType.Beta;
			case "rc":
			case "releasecandidate":
				return VersionType.ReleaseCandidate;
			case "f":
			case "final":
				return VersionType.Final;
			default:
				return VersionType.Final;
			}
		}

		public static string GetVersionTypeAsString(VersionType type)
		{
			return type switch
			{
				VersionType.Alpha => "a", 
				VersionType.Beta => "b", 
				VersionType.ReleaseCandidate => "rc", 
				_ => "f", 
			};
		}

		public static string GetVersionTypeAsLongString(VersionType type)
		{
			return type switch
			{
				VersionType.Alpha => "Alpha", 
				VersionType.Beta => "Beta", 
				VersionType.ReleaseCandidate => "Release Candidate", 
				_ => "Final", 
			};
		}

		public override string ToString()
		{
			if (Build == 0)
			{
				return $"{Major}.{Minor}.{Patch} {Appendix}".Trim();
			}
			return $"{Major}.{Minor}.{Patch} {GetVersionTypeAsLongString(Type)} {Build} {Appendix}".Trim();
		}

		public string ToShortString()
		{
			if (Build == 0)
			{
				return $"{Major}.{Minor}.{Patch} {Appendix}".Trim();
			}
			return $"{Major}.{Minor}.{Patch}{GetVersionTypeAsString(Type)}{Build}{Appendix}".Trim();
		}

		public string ToString(string format = "{0}.{1}.{2}{3}{5} {6}")
		{
			return string.Format("{0}.{1}.{2}{3}{5} {6}", Major, Minor, Patch, GetVersionTypeAsString(Type), GetVersionTypeAsLongString(Type), Build, Appendix).Trim();
		}

		public override bool Equals(object other)
		{
			if (other is VersionInfo)
			{
				return this == (VersionInfo)other;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return Major.GetHashCode() ^ Minor.GetHashCode() ^ Patch.GetHashCode() ^ Build.GetHashCode();
		}
	}
}
namespace HutongGames.PlayMaker.Ecosystem.Utils
{
	public class TransformEventsBridge : MonoBehaviour
	{
		public PlayMakerEventTarget eventTarget = new PlayMakerEventTarget(includeChildren: false);

		[EventTargetVariable("eventTarget")]
		public PlayMakerEvent parentChangedEvent;

		[EventTargetVariable("eventTarget")]
		public PlayMakerEvent childrenChangedEvent;

		public bool debug;

		private void OnTransformParentChanged()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("OnTransformParentChanged(): Send " + parentChangedEvent.ToString() + " on " + eventTarget.ToString(), this);
			}
			parentChangedEvent.SendEvent(null, eventTarget);
		}

		private void OnTransformChildrenChanged()
		{
			if (debug)
			{
				UnityEngine.Debug.Log("OnTransformChildrenChanged(): Send " + childrenChangedEvent.ToString() + " on " + eventTarget.ToString(), this);
			}
			childrenChangedEvent.SendEvent(null, eventTarget);
		}
	}
	public class ButtonAttribute : PropertyAttribute
	{
		public string methodName;

		public string buttonName;

		public bool useValue;

		public BindingFlags flags;

		public ButtonAttribute(string methodName, string buttonName, bool useValue, BindingFlags flags = BindingFlags.Instance | BindingFlags.Public)
		{
			this.methodName = methodName;
			this.buttonName = buttonName;
			this.useValue = useValue;
			this.flags = flags;
		}

		public ButtonAttribute(string methodName, bool useValue, BindingFlags flags)
			: this(methodName, methodName, useValue, flags)
		{
		}

		public ButtonAttribute(string methodName, bool useValue)
			: this(methodName, methodName, useValue)
		{
		}

		public ButtonAttribute(string methodName, string buttonName, BindingFlags flags)
			: this(methodName, buttonName, useValue: false, flags)
		{
		}

		public ButtonAttribute(string methodName, string buttonName)
			: this(methodName, buttonName, useValue: false)
		{
		}

		public ButtonAttribute(string methodName, BindingFlags flags)
			: this(methodName, methodName, useValue: false, flags)
		{
		}

		public ButtonAttribute(string methodName)
			: this(methodName, methodName, useValue: false)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	public class EventTargetVariable : Attribute
	{
		public string variable;

		public EventTargetVariable(string variable)
		{
			this.variable = variable;
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	public class ExpectComponent : Attribute
	{
		public readonly Type expectedComponentType;

		public ExpectComponent(Type type)
		{
			expectedComponentType = type;
		}

		public static Type GetTypeFromString(string typeString)
		{
			return Type.GetType(typeString);
		}

		public static string GetTypeAsString(Type type)
		{
			return type.AssemblyQualifiedName;
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	public class FsmVariableTargetVariable : Attribute
	{
		public string variable;

		public FsmVariableTargetVariable(string variable)
		{
			this.variable = variable;
		}
	}
	[AttributeUsage(AttributeTargets.All)]
	public class FsmVariableType : Attribute
	{
		public VariableType variableType;

		public FsmVariableType(VariableType variableType)
		{
			this.variableType = variableType;
		}
	}
	public class Required : PropertyAttribute
	{
	}
	[AttributeUsage(AttributeTargets.All)]
	public class ShowOptions : Attribute
	{
	}
	public enum CameraSelectionOptions
	{
		MainCamera,
		Owner,
		SpecifyGameObject
	}
	[Serializable]
	public class MainCameraTarget
	{
		public CameraSelectionOptions selection;

		[SerializeField]
		private GameObject _gameObject;

		public Component component;

		public string expectedComponentType;

		public GameObject gameObject
		{
			get
			{
				if (selection == CameraSelectionOptions.MainCamera)
				{
					return Camera.main.gameObject;
				}
				return _gameObject;
			}
			set
			{
				if (selection == CameraSelectionOptions.MainCamera && value != Camera.main)
				{
					UnityEngine.Debug.LogError("MainCameraTarget: you are trying to assign a GameObject that is not the MainCamera");
				}
				else
				{
					_gameObject = value;
				}
			}
		}
	}
	public enum OwnerSelectionOptions
	{
		Owner,
		SpecifyGameObject
	}
	[Serializable]
	public class Owner
	{
		public OwnerSelectionOptions selection;

		public GameObject gameObject;

		public Component component;

		public string expectedComponentType;
	}
	[Serializable]
	public class PlayMakerEvent
	{
		public string eventName;

		public bool allowLocalEvents;

		public string defaultEventName;

		public bool isNone => string.IsNullOrEmpty(eventName);

		public PlayMakerEvent()
		{
		}

		public PlayMakerEvent(string defaultEventName)
		{
			this.defaultEventName = defaultEventName;
			eventName = defaultEventName;
		}

		public PlayMakerFSM SanitizeFsmEventSender(PlayMakerFSM fsm)
		{
			if (fsm == null)
			{
				if (PlayMakerUtils.FsmEventSender == null)
				{
					PlayMakerUtils.FsmEventSender = new GameObject("PlayMaker Send Event Proxy").AddComponent<PlayMakerFSM>();
					PlayMakerUtils.FsmEventSender.FsmName = "Send Event Proxy";
					PlayMakerUtils.FsmEventSender.FsmDescription = "This Fsm was created at runtime, because a script or component is willing to send a PlayMaker event";
				}
				return PlayMakerUtils.FsmEventSender;
			}
			return fsm;
		}

		public bool SendEvent(PlayMakerFSM fromFsm, PlayMakerEventTarget eventTarget, bool debug = false)
		{
			fromFsm = SanitizeFsmEventSender(fromFsm);
			if (debug)
			{
				UnityEngine.Debug.Log(string.Concat("Sending event <", eventName, "> from fsm:", fromFsm.FsmName, " ", eventTarget.eventTarget, " ", eventTarget.gameObject, " ", eventTarget.fsmComponent));
			}
			if (eventTarget.eventTarget == ProxyEventTarget.BroadCastAll)
			{
				PlayMakerFSM.BroadcastEvent(eventName);
			}
			else if (eventTarget.eventTarget == ProxyEventTarget.Owner || eventTarget.eventTarget == ProxyEventTarget.GameObject)
			{
				PlayMakerUtils.SendEventToGameObject(fromFsm, eventTarget.gameObject, eventName, eventTarget.includeChildren);
			}
			else if (eventTarget.eventTarget == ProxyEventTarget.FsmComponent)
			{
				eventTarget.fsmComponent.SendEvent(eventName);
			}
			return true;
		}

		public override string ToString()
		{
			string arg = "<color=blue>" + eventName + "</color>";
			if (isNone)
			{
				arg = "<color=red>None</color>";
			}
			return $"PlayMaker Event : {arg}";
		}
	}
	public enum ProxyEventTarget
	{
		Owner,
		GameObject,
		BroadCastAll,
		FsmComponent
	}
	[Serializable]
	public class PlayMakerEventTarget
	{
		public ProxyEventTarget eventTarget;

		public GameObject gameObject;

		public bool includeChildren = true;

		public PlayMakerFSM fsmComponent;

		public PlayMakerEventTarget()
		{
		}

		public PlayMakerEventTarget(bool includeChildren = true)
		{
			this.includeChildren = includeChildren;
		}

		public PlayMakerEventTarget(ProxyEventTarget evenTarget, bool includeChildren = true)
		{
			eventTarget = evenTarget;
			this.includeChildren = includeChildren;
		}

		public void SetOwner(GameObject owner)
		{
			if (eventTarget == ProxyEventTarget.Owner)
			{
				gameObject = owner;
			}
		}

		public override string ToString()
		{
			string text = eventTarget.ToString();
			if (eventTarget == ProxyEventTarget.GameObject)
			{
				text = text + " : " + gameObject.name;
			}
			if (eventTarget == ProxyEventTarget.GameObject || eventTarget == ProxyEventTarget.Owner)
			{
				text += (includeChildren ? ", " : ", not ");
				text += "including children";
			}
			return text;
		}
	}
	public enum ProxyFsmTarget
	{
		Owner,
		GameObject,
		FsmComponent
	}
	[Serializable]
	public class PlayMakerFsmTarget
	{
		public ProxyFsmTarget target;

		public GameObject gameObject;

		public string fsmName;

		[SerializeField]
		private PlayMakerFSM _fsmComponent;

		private bool _initialized;

		public PlayMakerFSM fsmComponent
		{
			get
			{
				Initialize();
				return _fsmComponent;
			}
			set
			{
				_fsmComponent = value;
			}
		}

		public PlayMakerFsmTarget()
		{
		}

		public PlayMakerFsmTarget(ProxyFsmTarget target)
		{
			this.target = target;
		}

		public void Initialize()
		{
			if (!UnityEngine.Application.isPlaying || _initialized)
			{
				return;
			}
			_initialized = true;
			if (target != ProxyFsmTarget.FsmComponent)
			{
				if (gameObject != null)
				{
					fsmComponent = PlayMakerUtils.FindFsmOnGameObject(gameObject, fsmName);
				}
				if (fsmComponent == null)
				{
					UnityEngine.Debug.LogError("Initialized with no FsmComponent found");
				}
			}
		}
	}
	public enum VariableSelectionChoice
	{
		Any,
		Float,
		Int,
		Bool,
		GameObject,
		String,
		Vector2,
		Vector3,
		Color,
		Rect,
		Material,
		Texture,
		Quaternion,
		Object
	}
	[Serializable]
	public class PlayMakerFsmVariable
	{
		public VariableSelectionChoice variableSelectionChoice;

		public VariableType selectedType = VariableType.Unknown;

		public string variableName;

		public string defaultVariableName;

		public bool initialized;

		public bool targetUndefined = true;

		private string variableNameToUse = "";

		private FsmVariables fsmVariables;

		private NamedVariable _namedVariable;

		private FsmFloat _float;

		private FsmInt _int;

		private FsmBool _bool;

		private FsmGameObject _gameObject;

		private FsmColor _color;

		private FsmMaterial _material;

		private FsmObject _object;

		private FsmQuaternion _quaternion;

		private FsmRect _rect;

		private FsmString _string;

		private FsmTexture _texture;

		private FsmVector2 _vector2;

		private FsmVector3 _vector3;

		public NamedVariable namedVariable => _namedVariable;

		public FsmFloat FsmFloat
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Float) || selectedType != 0)
				{
					UnityEngine.Debug.LogError("Trying to access a FloatFsm Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_float == null && fsmVariables != null && selectedType == VariableType.Float)
				{
					_float = fsmVariables.GetFsmFloat(variableNameToUse);
				}
				return _float;
			}
		}

		public FsmInt FsmInt
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Int) || selectedType != VariableType.Int)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmInt Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_int == null && fsmVariables != null && selectedType == VariableType.Int)
				{
					_int = fsmVariables.GetFsmInt(variableNameToUse);
				}
				return _int;
			}
		}

		public FsmBool FsmBool
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Bool) || selectedType != VariableType.Bool)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmBool Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_bool == null && fsmVariables != null && selectedType == VariableType.Bool)
				{
					_bool = fsmVariables.GetFsmBool(variableNameToUse);
				}
				return _bool;
			}
		}

		public FsmGameObject FsmGameObject
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.GameObject) || selectedType != VariableType.GameObject)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmGameObject Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_gameObject == null && fsmVariables != null && selectedType == VariableType.GameObject)
				{
					_gameObject = fsmVariables.GetFsmGameObject(variableNameToUse);
				}
				return _gameObject;
			}
		}

		public FsmColor FsmColor
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Color) || selectedType != VariableType.Color)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmColor Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_color == null && fsmVariables != null && selectedType == VariableType.Color)
				{
					_color = fsmVariables.GetFsmColor(variableNameToUse);
				}
				return _color;
			}
		}

		public FsmMaterial FsmMaterial
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Material) || selectedType != VariableType.Material)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmMaterial Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_material == null && fsmVariables != null && selectedType == VariableType.Material)
				{
					_material = fsmVariables.GetFsmMaterial(variableNameToUse);
				}
				return _material;
			}
		}

		public FsmObject FsmObject
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Object) || selectedType != VariableType.Object)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmObject Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_object == null && fsmVariables != null && selectedType == VariableType.Object)
				{
					_object = fsmVariables.GetFsmObject(variableNameToUse);
				}
				return _object;
			}
		}

		public FsmQuaternion FsmQuaternion
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Quaternion) || selectedType != VariableType.Quaternion)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmQuaternion Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_quaternion == null && fsmVariables != null && selectedType == VariableType.Quaternion)
				{
					_quaternion = fsmVariables.GetFsmQuaternion(variableNameToUse);
				}
				return _quaternion;
			}
		}

		public FsmRect FsmRect
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Rect) || selectedType != VariableType.Rect)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmRect Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_rect == null && fsmVariables != null && selectedType == VariableType.Rect)
				{
					_rect = fsmVariables.GetFsmRect(variableNameToUse);
				}
				return _rect;
			}
		}

		public FsmString FsmString
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.String) || selectedType != VariableType.String)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmString Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_string == null && fsmVariables != null && selectedType == VariableType.String)
				{
					_string = fsmVariables.GetFsmString(variableNameToUse);
				}
				return _string;
			}
		}

		public FsmTexture FsmTexture
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Texture) || selectedType != VariableType.Texture)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmTexture Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_texture == null && fsmVariables != null && selectedType == VariableType.Texture)
				{
					_texture = fsmVariables.GetFsmTexture(variableNameToUse);
				}
				return _texture;
			}
		}

		public FsmVector2 FsmVector2
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Vector2) || selectedType != VariableType.Vector2)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmVector2 Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_vector2 == null && fsmVariables != null && selectedType == VariableType.Vector2)
				{
					_vector2 = fsmVariables.GetFsmVector2(variableNameToUse);
				}
				return _vector2;
			}
		}

		public FsmVector3 FsmVector3
		{
			get
			{
				if ((variableSelectionChoice != 0 && variableSelectionChoice != VariableSelectionChoice.Vector3) || selectedType != VariableType.Vector3)
				{
					UnityEngine.Debug.LogError("Trying to access a FsmVector3 Variable when the variable type is actually " + selectedType);
					return null;
				}
				if (_vector3 == null && fsmVariables != null && selectedType == VariableType.Vector3)
				{
					_vector3 = fsmVariables.GetFsmVector3(variableNameToUse);
				}
				return _vector3;
			}
		}

		public PlayMakerFsmVariable()
		{
		}

		public PlayMakerFsmVariable(VariableSelectionChoice variableSelectionChoice)
		{
			this.variableSelectionChoice = variableSelectionChoice;
		}

		public PlayMakerFsmVariable(string defaultVariableName)
		{
			this.defaultVariableName = defaultVariableName;
		}

		public PlayMakerFsmVariable(VariableSelectionChoice variableSelectionChoice, string defaultVariableName)
		{
			this.variableSelectionChoice = variableSelectionChoice;
			this.defaultVariableName = defaultVariableName;
		}

		public bool GetVariable(PlayMakerFsmVariableTarget variableTarget)
		{
			initialized = true;
			targetUndefined = true;
			if (variableTarget.FsmVariables != null)
			{
				targetUndefined = false;
				variableNameToUse = (string.IsNullOrEmpty(variableName) ? defaultVariableName : variableName);
				fsmVariables = variableTarget.FsmVariables;
				_namedVariable = fsmVariables.GetVariable(variableNameToUse);
				if (_namedVariable != null)
				{
					selectedType = GetTypeFromChoice(variableSelectionChoice);
					return true;
				}
			}
			selectedType = VariableType.Unknown;
			return false;
		}

		public override string ToString()
		{
			string text = "<color=blue>" + variableName + "</color>";
			if (string.IsNullOrEmpty(text))
			{
				text = "<color=red>None</color>";
			}
			return string.Format(string.Concat("PlayMaker Variable<{0}>: {1} (", _namedVariable, ")"), variableSelectionChoice, text);
		}

		public static VariableType GetTypeFromChoice(VariableSelectionChoice choice)
		{
			return choice switch
			{
				VariableSelectionChoice.Any => VariableType.Unknown, 
				VariableSelectionChoice.Float => VariableType.Float, 
				VariableSelectionChoice.Int => VariableType.Int, 
				VariableSelectionChoice.Bool => VariableType.Bool, 
				VariableSelectionChoice.GameObject => VariableType.GameObject, 
				VariableSelectionChoice.String => VariableType.String, 
				VariableSelectionChoice.Vector2 => VariableType.Vector2, 
				VariableSelectionChoice.Vector3 => VariableType.Vector3, 
				VariableSelectionChoice.Color => VariableType.Color, 
				VariableSelectionChoice.Rect => VariableType.Rect, 
				VariableSelectionChoice.Material => VariableType.Material, 
				VariableSelectionChoice.Texture => VariableType.Texture, 
				VariableSelectionChoice.Quaternion => VariableType.Quaternion, 
				VariableSelectionChoice.Object => VariableType.Object, 
				_ => VariableType.Unknown, 
			};
		}
	}
	public enum ProxyFsmVariableTarget
	{
		Owner,
		GameObject,
		GlobalVariable,
		FsmComponent
	}
	[Serializable]
	public class PlayMakerFsmVariableTarget
	{
		public ProxyFsmVariableTarget variableTarget;

		public GameObject gameObject;

		public string fsmName;

		[SerializeField]
		private PlayMakerFSM _fsmComponent;

		private FsmVariables _fsmVariables;

		[NonSerialized]
		private bool _initialized;

		public bool isTargetAvailable => FsmVariables != null;

		public FsmVariables FsmVariables
		{
			get
			{
				if (_fsmVariables == null || !_initialized)
				{
					Initialize();
				}
				return _fsmVariables;
			}
		}

		public PlayMakerFSM fsmComponent
		{
			get
			{
				Initialize();
				return _fsmComponent;
			}
			set
			{
				_fsmComponent = value;
			}
		}

		public PlayMakerFsmVariableTarget()
		{
		}

		public PlayMakerFsmVariableTarget(ProxyFsmVariableTarget target)
		{
			variableTarget = target;
		}

		public void Initialize(bool forceRefresh = false)
		{
			if (_initialized && !forceRefresh)
			{
				return;
			}
			_initialized = true;
			_fsmVariables = null;
			if (variableTarget == ProxyFsmVariableTarget.GlobalVariable)
			{
				_fsmVariables = FsmVariables.GlobalVariables;
			}
			else if (variableTarget == ProxyFsmVariableTarget.FsmComponent)
			{
				if (_fsmComponent != null)
				{
					_fsmVariables = _fsmComponent.FsmVariables;
					UnityEngine.Debug.LogWarning(string.Concat("Setting FsmVariables for ", variableTarget, " _fsmComponent= ", _fsmComponent));
				}
			}
			else
			{
				if (gameObject != null)
				{
					fsmComponent = PlayMakerUtils.FindFsmOnGameObject(gameObject, fsmName);
				}
				if (fsmComponent == null)
				{
					_fsmVariables = null;
				}
				else
				{
					_fsmVariables = _fsmComponent.FsmVariables;
				}
			}
		}

		public override string ToString()
		{
			return $"[PlayMakerFsmVariableTarget: FsmVariables={FsmVariables}, fsmComponent={fsmComponent}]";
		}
	}
	public class PlayMakerEventProxy : MonoBehaviour
	{
		public PlayMakerEventTarget eventTarget = new PlayMakerEventTarget(includeChildren: false);

		[EventTargetVariable("eventTarget")]
		public PlayMakerEvent fsmEvent;

		public bool debug;

		protected void SendPlayMakerEvent()
		{
			if (debug || !UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("Send " + fsmEvent.ToString() + " on " + eventTarget.ToString(), this);
			}
			if (!UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("<color=RED>Application must run to send a PlayMaker Event, but the proxy at least works</color>", this);
			}
			else
			{
				fsmEvent.SendEvent(null, eventTarget);
			}
		}
	}
}
namespace HutongGames.PlayMaker.Actions
{
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Fades in the Volume of the Audio Clip played by the AudioSource component on a Game Object.")]
	public class AudioFadeIn : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HasFloatSlider(0f, 1f)]
		[Tooltip("The volume to reach")]
		public FsmFloat inVolume;

		[RequiredField]
		[HasFloatSlider(0f, 10f)]
		[Tooltip("Fade in time in seconds.")]
		public FsmFloat time;

		[Tooltip("Event to send when finished.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		private AudioSource _audioSource;

		private float m;

		public override void Reset()
		{
			inVolume = 1f;
			gameObject = null;
			time = 1f;
			finishEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_audioSource = ownerDefaultTarget.GetComponent<AudioSource>();
			}
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			if (time.Value > 0f)
			{
				m = inVolume.Value / time.Value;
			}
			else
			{
				m = 0f;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			if (_audioSource != null)
			{
				_audioSource.volume = m * currentTime;
			}
			if (currentTime > time.Value)
			{
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Fades out the Volume of the Audio Clip played by the AudioSource component on a Game Object.")]
	public class AudioFadeOut : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HasFloatSlider(0f, 10f)]
		[Tooltip("Fade in time in seconds.")]
		public FsmFloat time;

		[Tooltip("Event to send when finished.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		private AudioSource _audioSource;

		private float m;

		private float b;

		public override void Reset()
		{
			gameObject = null;
			time = 1f;
			finishEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_audioSource = ownerDefaultTarget.GetComponent<AudioSource>();
				if (_audioSource != null)
				{
					b = _audioSource.volume;
				}
			}
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			if (time.Value > 0f)
			{
				m = (0f - b) / time.Value;
			}
			else
			{
				m = 0f;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			if (_audioSource != null)
			{
				_audioSource.volume = m * currentTime + b;
			}
			if (currentTime > time.Value)
			{
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[ActionTarget(typeof(AudioSource), "gameObject", false)]
	[ActionTarget(typeof(AudioClip), "oneShotClip", false)]
	[Tooltip("Plays the Audio Clip set with Set Audio Clip or in the Audio Source inspector on a Game Object. Optionally plays a one shot Audio Clip. The audio clip's name must match the subtitle ID.")]
	public class AudioPlayWithSubtitles : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		[Tooltip("The GameObject with an AudioSource component.")]
		public FsmOwnerDefault gameObject;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Set the volume.")]
		public FsmFloat volume;

		[ObjectType(typeof(AudioClip))]
		[Tooltip("Optionally play a 'one shot' AudioClip. NOTE: Volume cannot be adjusted while playing a 'one shot' AudioClip.")]
		public FsmObject[] oneShotClip = new FsmObject[1];

		[Tooltip("Wait until the end of the clip to send the Finish Event. Set to false to send the finish event immediately.")]
		public FsmBool WaitForEndOfClip;

		[Tooltip("Event to send when the action finishes.")]
		public FsmEvent finishedEvent;

		private AudioSource audio;

		private int index;

		private float remainingTime;

		public override void Reset()
		{
			gameObject = null;
			volume = 1f;
			oneShotClip = new FsmObject[1];
			finishedEvent = null;
			WaitForEndOfClip = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				audio = ownerDefaultTarget.GetComponent<AudioSource>();
				if (audio != null)
				{
					if (oneShotClip.Length == 0 || oneShotClip[0].Value == null)
					{
						audio.Play();
						References.Subtitles.DisplayText(audio.clip.name, audio.clip.length, audio);
						if (!volume.IsNone)
						{
							audio.volume = volume.Value;
						}
						return;
					}
					AudioClip audioClip = oneShotClip[0].Value as AudioClip;
					index = 0;
					References.Subtitles.DisplayText(audioClip.name, audioClip.length, audio);
					if (!volume.IsNone)
					{
						audio.volume = volume.Value;
					}
					remainingTime = audioClip.length;
					audio.clip = audioClip;
					audio.Play();
					if (!WaitForEndOfClip.Value)
					{
						base.Fsm.Event(finishedEvent);
						if (oneShotClip.Length == 1)
						{
							Finish();
						}
					}
					return;
				}
			}
			Finish();
		}

		public override void OnUpdate()
		{
			if (audio == null)
			{
				Finish();
				return;
			}
			remainingTime -= Time.deltaTime;
			if (remainingTime <= 0f)
			{
				index++;
				if (oneShotClip.Length > index)
				{
					AudioClip audioClip = oneShotClip[index].Value as AudioClip;
					remainingTime = audioClip.length;
					References.Subtitles.DisplayText(audioClip.name, audioClip.length, audio);
					if (!volume.IsNone)
					{
						audio.PlayOneShot(audioClip, volume.Value);
					}
					else
					{
						audio.PlayOneShot(audioClip);
					}
				}
				else
				{
					if (WaitForEndOfClip.Value)
					{
						base.Fsm.Event(finishedEvent);
					}
					Finish();
				}
			}
			else if (!volume.IsNone && volume.Value != audio.volume)
			{
				audio.volume = volume.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Shakes the Camera.")]
	public class ScreenShake : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The amount of the shaking. Should be from 0-1.")]
		public FsmFloat magnitude;

		[RequiredField]
		[Tooltip("The duration of the shaking.")]
		public FsmFloat length;

		[RequiredField]
		[Tooltip("The falloff of the shaking. The higher the value, the more abruptly the shaking will end. Should be 1 or higher.")]
		public FsmFloat exponent;

		public override void Reset()
		{
			magnitude = 0.5f;
			length = 1f;
			exponent = 2f;
		}

		public override void OnEnter()
		{
			ScreenShakeVR.TriggerShake(magnitude.Value, length.Value, exponent.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Enables or disables Odin's hurry quip system.")]
	public class EnableCollider : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject on which to enable/disable colliders")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("If true, enables the colliders, otherwise disables it.")]
		public bool setEnabled;

		[RequiredField]
		[Tooltip("If true, affects all colliders on children of the target GameObject.")]
		public bool setRecursively;

		public override void Reset()
		{
			gameObject = null;
			setEnabled = false;
			setRecursively = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				Collider[] array = (setRecursively ? ownerDefaultTarget.GetComponentsInChildren<Collider>() : ownerDefaultTarget.GetComponents<Collider>());
				for (int i = 0; i < array.Length; i++)
				{
					array[i].enabled = setEnabled;
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets a GameObject by its ObjectID.")]
	public class GetObjectByID : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The ObjectID to get.")]
		public string objectID;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a GameObject variable.")]
		public FsmGameObject storeResult;

		public override void Reset()
		{
			objectID = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			storeResult.Value = ObjectID.Get(objectID);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the next available Game Object in a Game Object Pool and stores it in a variable.")]
	public class GetObjectFromPool : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObjectPool to get an object from.")]
		public GameObjectPool gameObjectPool;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a GameObject variable.")]
		public FsmGameObject storeResult;

		[Tooltip("Make the object a child of this GameObject.")]
		public FsmGameObject parent;

		[Tooltip("Match this object's position and rotation.")]
		public FsmGameObject matchTransform;

		[Tooltip("Activate the object immediately.")]
		public bool activateObject;

		public override void Reset()
		{
			gameObjectPool = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			GameObject gameObject = gameObjectPool.Get();
			if (!storeResult.IsNone)
			{
				storeResult.Value = gameObject;
			}
			if (!matchTransform.IsNone && matchTransform.Value != null)
			{
				gameObject.transform.position = matchTransform.Value.transform.position;
				gameObject.transform.rotation = matchTransform.Value.transform.rotation;
			}
			if (!parent.IsNone && parent.Value != null)
			{
				gameObject.transform.parent = parent.Value.transform;
			}
			if (activateObject)
			{
				gameObject.SetActive(value: true);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the ObjectID of a GameObject.")]
	public class GetObjectID : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to get the ID of.")]
		public FsmGameObject gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a string variable.")]
		public FsmString storeResult;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			ObjectID component = gameObject.Value.GetComponent<ObjectID>();
			if (component != null)
			{
				storeResult.Value = component.GetID();
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Sets the ObjectID of a GameObject.")]
	public class SetObjectID : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to set the ID of.")]
		public FsmGameObject gameObject;

		[RequiredField]
		[Tooltip("The ID to assign.")]
		public FsmString ID;

		public override void Reset()
		{
			gameObject = null;
			ID = null;
		}

		public override void OnEnter()
		{
			ObjectID objectID = gameObject.Value.GetComponent<ObjectID>();
			if (objectID == null)
			{
				objectID = gameObject.Value.AddComponent<ObjectID>();
			}
			objectID.SetID(ID.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on difficulty settings.")]
	public class CheckDifficulty : FsmStateAction
	{
		[Tooltip("Set an int variable to 1 for easy, 2 for normal, 3 for hard.")]
		[UIHint(UIHint.Variable)]
		public FsmInt storeDifficulty;

		[Tooltip("Event to send if the difficulty is Easy.")]
		public FsmEvent isEasy;

		[Tooltip("Event to send if the difficulty is Normal.")]
		public FsmEvent isNormal;

		[Tooltip("Event to send if the difficulty is Hard.")]
		public FsmEvent isHard;

		public override void Reset()
		{
			storeDifficulty = null;
			isEasy = null;
			isNormal = null;
			isHard = null;
		}

		public override void OnEnter()
		{
			if (storeDifficulty != null)
			{
				storeDifficulty.Value = (int)Settings.Current.difficulty;
			}
			switch (Settings.Current.difficulty)
			{
			case Difficulty.Easy:
				base.Fsm.Event(isEasy);
				break;
			case Difficulty.Normal:
				base.Fsm.Event(isNormal);
				break;
			case Difficulty.Hard:
				base.Fsm.Event(isHard);
				break;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Checks a lock.")]
	public class CheckGameLock : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Lock to check.")]
		public Lock checkLock;

		[Tooltip("Event to run when locked.")]
		public FsmEvent locked;

		[Tooltip("Event to run when unlocked.")]
		public FsmEvent unlocked;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			checkLock = null;
			locked = null;
			unlocked = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.Fsm.Event(checkLock.IsLocked() ? locked : unlocked);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on what headset is being used.")]
	public class CheckHeadset : FsmStateAction
	{
		[Tooltip("Event to send if the headset is a Quest.")]
		public FsmEvent isQuest1;

		[Tooltip("Event to send if the headset is a Quest 2.")]
		public FsmEvent isQuest2;

		[Tooltip("Event to send if the headset is other or unknown.")]
		public FsmEvent isGeneric;

		public override void Reset()
		{
			isQuest1 = null;
			isQuest2 = null;
			isGeneric = null;
		}

		public override void OnEnter()
		{
			switch (OVRPlugin.GetSystemHeadsetType())
			{
			case OVRPlugin.SystemHeadset.Oculus_Quest_2:
				base.Fsm.Event(isQuest2);
				break;
			case OVRPlugin.SystemHeadset.Oculus_Quest:
				base.Fsm.Event(isQuest1);
				break;
			default:
				base.Fsm.Event(isGeneric);
				break;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on whether the player is currently in combat or not.")]
	public class CheckInCombat : FsmStateAction
	{
		[Tooltip("Event to send if the player is in combat.")]
		public FsmEvent isTrue;

		[Tooltip("Event to send if the player is not in combat.")]
		public FsmEvent isFalse;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			isTrue = null;
			isFalse = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.Fsm.Event(CombatTracker.IsInCombat ? isTrue : isFalse);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			base.Fsm.Event(CombatTracker.IsInCombat ? isTrue : isFalse);
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on whether or not there is a clear path between two points.")]
	public class CheckLineOfSight : FsmStateAction
	{
		[Tooltip("Starting point of the raycast.")]
		[RequiredField]
		public FsmOwnerDefault raycastStart;

		[Tooltip("Ending point of the raycast.")]
		[RequiredField]
		public FsmGameObject raycastEnd;

		[Tooltip("The length of the ray. Set to -1 for infinity.")]
		public FsmFloat distance;

		[Tooltip("Set a bool variable to true if clear, otherwise false.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storePathClear;

		[Tooltip("Event to send if the path is not blocked.")]
		public FsmEvent isClear;

		[Tooltip("Event to send if the path is blocked.")]
		public FsmEvent isBlocked;

		[Tooltip("Set how often to cast a ray. 0 = once, don't repeat; 1 = every frame; 2 = every other frame... \nSince raycasts can get expensive use the highest repeat interval you can get away with.")]
		public FsmInt repeatInterval;

		private int repeat;

		public override void Reset()
		{
			raycastStart = null;
			raycastEnd = null;
			distance = 100f;
			storePathClear = null;
			isClear = null;
			isBlocked = null;
			repeatInterval = 1;
		}

		public override void OnEnter()
		{
			DoRaycast();
			if (repeatInterval.Value == 0)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			repeat--;
			if (repeat == 0)
			{
				DoRaycast();
			}
		}

		private void DoRaycast()
		{
			repeat = repeatInterval.Value;
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(raycastStart);
			if (ownerDefaultTarget == null || raycastEnd.Value == null)
			{
				return;
			}
			Vector3 position = ownerDefaultTarget.transform.position;
			if (Vector3.Distance(position, raycastEnd.Value.transform.position) > distance.Value)
			{
				storePathClear.Value = false;
				base.Fsm.Event(isBlocked);
			}
			Vector3 direction = raycastEnd.Value.transform.position - position;
			int num = Physics.RaycastNonAlloc(position, direction, Utilities.raycastHitPool, (distance.Value > 0f) ? distance.Value : float.PositiveInfinity, References.SolidLayers);
			if (num > 0)
			{
				Array.Sort(Utilities.raycastHitPool, 0, num, Utilities.RaycastHitDistanceComparer.Comparer);
			}
			for (int i = 0; i < num; i++)
			{
				Transform transform = Utilities.raycastHitPool[i].transform;
				if (transform.IsChildOf(raycastEnd.Value.transform) || raycastEnd.Value.transform.IsChildOf(transform))
				{
					break;
				}
				if (!transform.IsChildOf(ownerDefaultTarget.transform) && !ownerDefaultTarget.transform.IsChildOf(transform))
				{
					storePathClear.Value = false;
					base.Fsm.Event(isBlocked);
					return;
				}
			}
			storePathClear.Value = true;
			base.Fsm.Event(isClear);
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Loads or unloads a scene.")]
	public class LoadRoom : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Room to load or unload.")]
		public Room room;

		public bool preloadOnly;

		public bool unload;

		[Tooltip("Event to send once the room finishes loading (only activates for full load, not preload).")]
		public FsmEvent finishedEvent;

		public override void Reset()
		{
			room = null;
			preloadOnly = false;
			unload = false;
		}

		public override void OnEnter()
		{
			if (room == null)
			{
				UnityEngine.Debug.LogError("Attempted to load a null room.");
				return;
			}
			if (unload)
			{
				Timing.RunCoroutine(SceneStateManager.UnloadRoom(room));
			}
			else if (preloadOnly)
			{
				SceneStateManager.PreloadRoom(room);
			}
			else
			{
				if (finishedEvent != null)
				{
					Timing.RunCoroutine(LoadRoutine());
					return;
				}
				Timing.RunCoroutine(SceneStateManager.LoadRoom(room));
				Finish();
			}
			Finish();
		}

		private IEnumerator<float> LoadRoutine()
		{
			yield return Timing.WaitUntilDone(SceneStateManager.LoadRoom(room));
			base.Fsm.Event(finishedEvent);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Enables or disables Odin's hurry quip system.")]
	public class ActivateOdinQuips : FsmStateAction
	{
		[RequiredField]
		[Tooltip("If true, enables quips.")]
		public bool setActive;

		public override void Reset()
		{
			setActive = false;
		}

		public override void OnEnter()
		{
			if (setActive)
			{
				Singleton<OdinQuip>.Instance.EnableQuips();
			}
			else
			{
				Singleton<OdinQuip>.Instance.DisableQuips();
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Adds to the shield's gem count.")]
	public class AddShieldGem : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The number of gems to add.")]
		public int gemCount = 1;

		public override void Reset()
		{
			gemCount = 1;
		}

		public override void OnEnter()
		{
			Player.Instance.shieldGems += gemCount;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Deals damage to a mob.")]
	public class DamageMob : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The target to deal damage to.")]
		public FsmGameObject damageTarget;

		[RequiredField]
		[Tooltip("The amount of damage to deal.")]
		public FsmInt damageAmount;

		[RequiredField]
		[Tooltip("The type of damage to deal.")]
		public DamageType damageType;

		public override void Reset()
		{
			damageTarget = null;
			damageAmount = 0;
			damageType = DamageType.None;
		}

		public override void OnEnter()
		{
			IDamageable component = damageTarget.Value.GetComponent<IDamageable>();
			if (component == null)
			{
				UnityEngine.Debug.LogError("Target gameobject has no damageable component");
			}
			else
			{
				component.ApplyDamage(damageAmount.Value, $"FSM: {base.Fsm.GetOwnerDefaultTarget(new FsmOwnerDefault())}", damageType);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Marks a puzzle complete in the hint system.")]
	public class MarkPuzzleComplete : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The puzzle to mark complete.")]
		public string puzzleName;

		public override void Reset()
		{
			puzzleName = string.Empty;
		}

		public override void OnEnter()
		{
			HintSystem.CompletePuzzle(puzzleName);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Tells Odin to use either indoor or outdoor quips.")]
	public class OdinQuipsSetIndoors : FsmStateAction
	{
		[RequiredField]
		[Tooltip("If true, enables quips.")]
		public bool isIndoors;

		public override void Reset()
		{
			isIndoors = false;
		}

		public override void OnEnter()
		{
			Singleton<OdinQuip>.Instance.SetIndoors(isIndoors);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Quits the current game and returns to the profile selection menu.")]
	public class QuitToMenu : FsmStateAction
	{
		public override void OnEnter()
		{
			References.MenuManager.EndGame();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Raises a game event.")]
	public class RaiseGameEvent : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameEvent to raise.")]
		public GameEvent gameEvent;

		[RequiredField]
		[Tooltip("Send the event as true or false.")]
		public FsmBool sendTrue;

		public override void Reset()
		{
			gameEvent = null;
			sendTrue = true;
		}

		public override void OnEnter()
		{
			gameEvent.Raise(sendTrue.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Saves the current game.")]
	public class SaveGame : FsmStateAction
	{
		[Tooltip("Override the player's position to match this transform (optional).")]
		public FsmGameObject playerPosition;

		[Tooltip("If true, the usual Progress Saved indicator will not appear")]
		public bool hideSaveText;

		public override void Reset()
		{
			playerPosition = null;
		}

		public override void OnEnter()
		{
			SaveSystem.Save((playerPosition.Value != null) ? playerPosition.Value.transform : null, hideSaveText);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Sets a mob as engaged in combat with the player or not.")]
	public class SetCombatEngaged : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Mob to set as engaged")]
		public FsmOwnerDefault mob;

		[Tooltip("Set the mob as engaged with the player.")]
		public bool engaged = true;

		public override void Reset()
		{
			mob = null;
			engaged = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(mob);
			Mob component = ownerDefaultTarget.GetComponent<Mob>();
			if (component == null)
			{
				UnityEngine.Debug.LogError($"Target gameobject {ownerDefaultTarget} is not a Mob.");
			}
			else if (engaged)
			{
				CombatTracker.Engage(component);
			}
			else
			{
				CombatTracker.Disengage(component);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Adds or removes a lock.")]
	public class SetGameLock : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Lock to open or close.")]
		public Lock lockTarget;

		[RequiredField]
		[Tooltip("Lock.")]
		public FsmBool addLock;

		[RequiredField]
		[Tooltip("Object to use for lock.")]
		public FsmOwnerDefault lockObject;

		public override void Reset()
		{
			lockTarget = null;
			lockObject = null;
			addLock = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(lockObject);
			if (addLock.Value)
			{
				lockTarget.LockUsing(ownerDefaultTarget);
			}
			else
			{
				lockTarget.Unlock(ownerDefaultTarget);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Grants the achievements related to winning the game.")]
	public class SetGameWonAchievement : FsmStateAction
	{
		public override void OnEnter()
		{
			References.AchievementManager.Win();
			Finish();
		}
	}
	public abstract class FsmStateActionAdvanced : FsmStateAction
	{
		public enum FrameUpdateSelector
		{
			OnUpdate,
			OnLateUpdate,
			OnFixedUpdate
		}

		[ActionSection("Update type")]
		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public FrameUpdateSelector updateType;

		public abstract void OnActionUpdate();

		public override void Reset()
		{
			everyFrame = false;
			updateType = FrameUpdateSelector.OnUpdate;
		}

		public override void Awake()
		{
			if (updateType == FrameUpdateSelector.OnFixedUpdate)
			{
				base.Fsm.HandleFixedUpdate = true;
			}
		}

		public override void OnUpdate()
		{
			if (updateType == FrameUpdateSelector.OnUpdate)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnLateUpdate()
		{
			if (updateType == FrameUpdateSelector.OnLateUpdate)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			if (updateType == FrameUpdateSelector.OnFixedUpdate)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Enables or disables the current link of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentActivateCurrentOffMeshLink : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Flag to Enables or disables the current link of the NavMesh Agent.")]
		[UIHint(UIHint.FsmFloat)]
		public FsmBool activate;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			activate = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoActivateCurrentOffMeshLink();
			Finish();
		}

		private void DoActivateCurrentOffMeshLink()
		{
			if (activate != null && !(_agent == null))
			{
				_agent.ActivateCurrentOffMeshLink(activate.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Terminate current OffMeshLink of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentCompleteOffMeshLink : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoCompleteOffMeshLink();
			Finish();
		}

		private void DoCompleteOffMeshLink()
		{
			if (!(_agent == null))
			{
				_agent.CompleteOffMeshLink();
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Locate the closest NavMesh edge. \nYou can dispatch events if nearest edge found or not. \nYou can then store information about the location (navMeshHit). \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentFindClosestEdge : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[Tooltip("True if a nearest edge is found.")]
		public FsmBool nearestEdgeFound;

		[Tooltip("Trigger event if a nearest edge is found.")]
		public FsmEvent nearestEdgeFoundEvent;

		[Tooltip("Trigger event if a nearest edge is NOT found.")]
		public FsmEvent nearestEdgeNotFoundEvent;

		[ActionSection("Hit information (of the found edge)")]
		[Tooltip("Position of hit")]
		public FsmVector3 position;

		[Tooltip("Normal at the point of hit")]
		public FsmVector3 normal;

		[Tooltip("Distance to the point of hit")]
		public FsmFloat distance;

		[Tooltip("Mask specifying NavMeshLayers at point of hit.")]
		public FsmInt mask;

		[Tooltip("Flag when hit")]
		public FsmBool hit;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject gameObject = ((this.gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : this.gameObject.GameObject.Value);
			if (!(gameObject == null))
			{
				_agent = gameObject.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			nearestEdgeFound = new FsmBool
			{
				UseVariable = true
			};
			nearestEdgeFoundEvent = null;
			nearestEdgeNotFoundEvent = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			normal = new FsmVector3
			{
				UseVariable = true
			};
			distance = new FsmFloat
			{
				UseVariable = true
			};
			mask = new FsmInt
			{
				UseVariable = true
			};
			hit = new FsmBool
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			_getAgent();
			DoFindClosestEdge();
			Finish();
		}

		private void DoFindClosestEdge()
		{
			if (_agent == null)
			{
				return;
			}
			NavMeshHit navMeshHit;
			bool flag = _agent.FindClosestEdge(out navMeshHit);
			nearestEdgeFound.Value = flag;
			position.Value = navMeshHit.position;
			normal.Value = navMeshHit.normal;
			distance.Value = navMeshHit.distance;
			mask.Value = navMeshHit.mask;
			hit.Value = navMeshHit.hit;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(nearestEdgeFoundEvent))
				{
					base.Fsm.Event(nearestEdgeFoundEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(nearestEdgeNotFoundEvent))
			{
				base.Fsm.Event(nearestEdgeNotFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Apply relative movement to current path position of a navMesh Agent. \nIf the agent has a path it will be adjusted. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentMove : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The relative move vector.")]
		public FsmVector3 offset;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			offset = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoMove();
			Finish();
		}

		private void DoMove()
		{
			if (!(_agent == null))
			{
				_agent.Move(offset.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Trace movement towards a target postion in the NavMesh, without moving the agent. \nYou can dispatch events If terminated before reaching the target position or not. \nYou can then store information about the location (navMeshHit). \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentRayCast : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The desired end position of movement.")]
		[UIHint(UIHint.FsmVector3)]
		public FsmVector3 targetPosition;

		[ActionSection("Result")]
		[Tooltip("true If terminated before reaching target position.")]
		[UIHint(UIHint.Variable)]
		public FsmBool reachedBeforeTargetPosition;

		[Tooltip("Trigger event if sample reached before the target position.")]
		public FsmEvent reachedBeforeTargetPositionEvent;

		[Tooltip("Trigger event if sample reached after the target position.")]
		public FsmEvent reachedAfterTargetPositionEvent;

		[ActionSection("Hit information of the sample")]
		[Tooltip("Position of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 position;

		[Tooltip("Normal at the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 normal;

		[Tooltip("Distance to the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmFloat distance;

		[Tooltip("Mask specifying NavMeshLayers at point of hit.")]
		[UIHint(UIHint.Variable)]
		public FsmInt mask;

		[Tooltip("Flag when hit")]
		[UIHint(UIHint.Variable)]
		public FsmBool hit;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			targetPosition = null;
			reachedBeforeTargetPosition = null;
			reachedBeforeTargetPositionEvent = null;
			reachedAfterTargetPositionEvent = null;
			position = null;
			normal = null;
			distance = null;
			mask = null;
			hit = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoRaycast();
			Finish();
		}

		private void DoRaycast()
		{
			if (_agent == null)
			{
				return;
			}
			NavMeshHit navMeshHit;
			bool flag = _agent.Raycast(targetPosition.Value, out navMeshHit);
			reachedBeforeTargetPosition.Value = flag;
			position.Value = navMeshHit.position;
			normal.Value = navMeshHit.normal;
			distance.Value = navMeshHit.distance;
			mask.Value = navMeshHit.mask;
			hit.Value = navMeshHit.hit;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(reachedBeforeTargetPositionEvent))
				{
					base.Fsm.Event(reachedBeforeTargetPositionEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(reachedAfterTargetPositionEvent))
			{
				base.Fsm.Event(reachedAfterTargetPositionEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Clears the current path of a NavMesh Agent. \nNOTE: that the agent will not start looking for a new path until SetDestination is called. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentResetPath : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoResetPath();
			Finish();
		}

		private void DoResetPath()
		{
			if (!(_agent == null) && _agent.hasPath)
			{
				_agent.ResetPath();
			}
		}
	}
	[Obsolete("Please use AgentIsStopped action")]
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Resumes the movement along the current path of a navMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentResume : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoResume();
			Finish();
		}

		private void DoResume()
		{
			if (!(_agent == null))
			{
				_agent.Resume();
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Sample a position along the current path. \nYou can dispatch events If terminated before reaching position at maxDistance or not. \nYou can then store information about the location (navMeshHit). \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentSamplePathPosition : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The mask specifying which NavMesh layers can be passed when tracing the path.")]
		public FsmInt passableMask;

		[Tooltip("Terminate scanning the path at this distance.")]
		public FsmFloat maxDistance;

		[ActionSection("Result")]
		[Tooltip("True If terminated before reaching position at maxDistance.")]
		[UIHint(UIHint.Variable)]
		public FsmBool reachedBeforeMaxDistance;

		[Tooltip("Trigger event if sample reached before the maxDistance.")]
		public FsmEvent reachedBeforeMaxDistanceEvent;

		[Tooltip("Trigger event if sample reached after the maxDistance.")]
		public FsmEvent reachedAfterMaxDistanceEvent;

		[ActionSection("Hit information of the sample")]
		[Tooltip("Position of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 position;

		[Tooltip("Normal at the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 normal;

		[Tooltip("Distance to the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmFloat distance;

		[Tooltip("Mask specifying NavMeshLayers at point of hit.")]
		[UIHint(UIHint.Variable)]
		public FsmInt mask;

		[Tooltip("Flag when hit")]
		[UIHint(UIHint.Variable)]
		public FsmBool hit;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			passableMask = -1;
			reachedBeforeMaxDistance = null;
			reachedBeforeMaxDistanceEvent = null;
			reachedAfterMaxDistanceEvent = null;
			position = null;
			normal = null;
			distance = null;
			mask = null;
			hit = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSamplePath();
			Finish();
		}

		private void DoSamplePath()
		{
			if (_agent == null)
			{
				return;
			}
			NavMeshHit navMeshHit;
			bool flag = _agent.SamplePathPosition(passableMask.Value, maxDistance.Value, out navMeshHit);
			reachedBeforeMaxDistance.Value = flag;
			position.Value = navMeshHit.position;
			normal.Value = navMeshHit.normal;
			distance.Value = navMeshHit.distance;
			mask.Value = navMeshHit.mask;
			hit.Value = navMeshHit.hit;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(reachedBeforeMaxDistanceEvent))
				{
					base.Fsm.Event(reachedBeforeMaxDistanceEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(reachedAfterMaxDistanceEvent))
			{
				base.Fsm.Event(reachedAfterMaxDistanceEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Assign path to NavMesh Agent. Uses FsmNavMeshPath component. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentSetPath : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The Game Object holding the path. NOTE: The Game Object must have a FsmNavMeshPath component attached.")]
		[CheckForComponent(typeof(FsmNavMeshPath))]
		public FsmOwnerDefault path;

		[Tooltip("True if succesfully assigned.")]
		public FsmBool pathAssigned;

		[Tooltip("Trigger event if path assigned.")]
		public FsmEvent pathAssignedEvent;

		[Tooltip("Trigger event if path not assigned.")]
		public FsmEvent pathNotAssignedEvent;

		private NavMeshAgent _agent;

		private FsmNavMeshPath _pathProxy;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		private void _getPathProxy()
		{
			GameObject gameObject = ((path.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : path.GameObject.Value);
			if (!(gameObject == null))
			{
				_pathProxy = gameObject.GetComponent<FsmNavMeshPath>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			path = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			_getPathProxy();
			DoSetPath();
			Finish();
		}

		private void DoSetPath()
		{
			if (_pathProxy == null || _agent == null)
			{
				return;
			}
			bool flag = _agent.SetPath(_pathProxy.path);
			pathAssigned.Value = flag;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(pathAssignedEvent))
				{
					base.Fsm.Event(pathAssignedEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(pathNotAssignedEvent))
			{
				base.Fsm.Event(pathNotAssignedEvent);
			}
		}
	}
	[Obsolete("Please use AgentIsStopped action")]
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Stop movement of the agent along the current path. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentStop : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoStop();
			Finish();
		}

		private void DoStop()
		{
			if (!(_agent == null))
			{
				_agent.Stop();
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Warps agent to the provided position. Send events base on result: Returns true if successful, otherwise returns false \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class AgentWarp : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("New position to warp the agent to.")]
		public FsmVector3 newPosition;

		[ActionSection("Result")]
		[Tooltip("True if successful, otherwise returns false")]
		[UIHint(UIHint.Variable)]
		public FsmBool success;

		[Tooltip("Trigger this event Warp to new position is successful")]
		public FsmEvent successEvent;

		[Tooltip("Trigger this event when Warp to new position failed")]
		public FsmEvent failureEvent;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			newPosition = null;
			success = null;
			successEvent = null;
			failureEvent = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoWarp();
			Finish();
		}

		private void DoWarp()
		{
			if (!(_agent == null))
			{
				bool flag = _agent.Warp(newPosition.Value);
				success.Value = flag;
				if (flag)
				{
					base.Fsm.Event(successEvent);
				}
				else
				{
					base.Fsm.Event(failureEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the flag of NavMesh Agent avoids overshooting the destination point. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentAutoBraking : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the agent that avoids overshooting the destination point.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Runs every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetAutoBraking();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetAutoBraking();
		}

		private void DoGetAutoBraking()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.autoBraking;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the flag of NavMesh Agent if it attempts to acquire a new path if the existing path becomes invalid. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentAutoRepath : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the agent if it attempts to acquire a new path if the existing path becomes invalid.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetAutoRepath();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetAutoRepath();
		}

		private void DoGetAutoRepath()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.autoRepath;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Get flag to automate movement onto and off of OffMeshLinks. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentAutoTraverseOffMeshLink : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the flag for automatic movement onto and off of OffMeshLinks")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetAutoTraverseOffMeshLink();
			Finish();
		}

		private void DoGetAutoTraverseOffMeshLink()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.autoTraverseOffMeshLink;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the avoidance priority level.\nWhen the agent is performing avoidance, agents of lower priority are ignored.\nThe valid range is from 0 to 99 where: Most important = 0. Least important = 99. Default = 50\nNOTE: The Game Object must have a NavMeshAgent.")]
	public class GetAgentAvoidancePriority : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("the avoidance priority level. Most important = 0. Least important = 99. Default = 50")]
		[UIHint(UIHint.Variable)]
		public FsmFloat avoidancePriority;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			avoidancePriority = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetAvoidancePriority();
		}

		private void DoGetAvoidancePriority()
		{
			if (!(_agent == null) && avoidancePriority != null)
			{
				avoidancePriority.Value = _agent.avoidancePriority;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the relative vertical displacement of the owning GameObject. \nNOTE: The Game Object must have a NavMeshAgent.")]
	public class GetAgentBaseOffset : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("the relative vertical displacement of the owning GameObject")]
		[UIHint(UIHint.Variable)]
		public FsmFloat baseOffset;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			baseOffset = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetBaseOffset();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetBaseOffset();
		}

		private void DoGetBaseOffset()
		{
			if (!(_agent == null) && baseOffset != null)
			{
				baseOffset.Value = _agent.baseOffset;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the current offMeshLink data of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentCurrentOffMeshLinkData : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[Tooltip("Link start world position")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 startPos;

		[Tooltip("Link start GameObject representing the link start position")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject startGameObject;

		[Tooltip("Link end world position")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 endPos;

		[Tooltip("Link end GameObject representing the link end position")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject endGameObject;

		[Tooltip("Is Link activated")]
		[UIHint(UIHint.Variable)]
		public FsmBool activated;

		[Tooltip("Is Link valid")]
		[UIHint(UIHint.Variable)]
		public FsmBool valid;

		[Tooltip("Is Link occupied")]
		[UIHint(UIHint.Variable)]
		public FsmBool occupied;

		[Tooltip("LinkTypeSpecifier: range: manual, dropDown, jumpAcross")]
		[UIHint(UIHint.Variable)]
		public FsmString OffMeshlinkType;

		[Tooltip("The pathfinding cost for the link")]
		[UIHint(UIHint.Variable)]
		public FsmFloat costOverride;

		[Tooltip("Can link be traversed in both directions")]
		[UIHint(UIHint.Variable)]
		public FsmBool biDirectional;

		[Tooltip("Is Link automatically updating endpoints")]
		[UIHint(UIHint.Variable)]
		public FsmBool autoUpdatePositions;

		[Tooltip("The area for this OffMeshLink component")]
		[UIHint(UIHint.Variable)]
		public FsmInt navmeshArea;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			startPos = new FsmVector3
			{
				UseVariable = true
			};
			startGameObject = new FsmGameObject
			{
				UseVariable = true
			};
			endPos = new FsmVector3
			{
				UseVariable = true
			};
			endGameObject = new FsmGameObject
			{
				UseVariable = true
			};
			activated = new FsmBool
			{
				UseVariable = true
			};
			valid = new FsmBool
			{
				UseVariable = true
			};
			occupied = new FsmBool
			{
				UseVariable = true
			};
			OffMeshlinkType = new FsmString
			{
				UseVariable = true
			};
			biDirectional = new FsmBool
			{
				UseVariable = true
			};
			autoUpdatePositions = new FsmBool
			{
				UseVariable = true
			};
			navmeshArea = new FsmInt
			{
				UseVariable = true
			};
			costOverride = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetOffMeshLinkData();
			Finish();
		}

		private void DoGetOffMeshLinkData()
		{
			if (_agent == null || !_agent.isOnOffMeshLink)
			{
				return;
			}
			OffMeshLinkData offMeshLinkData = default(OffMeshLinkData);
			offMeshLinkData = _agent.currentOffMeshLinkData;
			if (!startPos.IsNone)
			{
				startPos.Value = offMeshLinkData.startPos;
			}
			if (!endPos.IsNone)
			{
				endPos.Value = offMeshLinkData.endPos;
			}
			if (!activated.IsNone)
			{
				activated.Value = offMeshLinkData.activated;
			}
			if (!valid.IsNone)
			{
				valid.Value = offMeshLinkData.valid;
			}
			if (!OffMeshlinkType.IsNone)
			{
				switch (offMeshLinkData.linkType)
				{
				case OffMeshLinkType.LinkTypeManual:
					OffMeshlinkType.Value = "manual";
					break;
				case OffMeshLinkType.LinkTypeDropDown:
					OffMeshlinkType.Value = "dropDown";
					break;
				case OffMeshLinkType.LinkTypeJumpAcross:
					OffMeshlinkType.Value = "jumpAcross";
					break;
				}
			}
			if (!costOverride.IsNone)
			{
				costOverride.Value = offMeshLinkData.offMeshLink.costOverride;
			}
			if (!occupied.IsNone)
			{
				occupied.Value = offMeshLinkData.offMeshLink.occupied;
			}
			if (!autoUpdatePositions.IsNone)
			{
				autoUpdatePositions.Value = offMeshLinkData.offMeshLink.autoUpdatePositions;
			}
			if (!navmeshArea.IsNone)
			{
				navmeshArea.Value = offMeshLinkData.offMeshLink.area;
			}
			if (!startGameObject.IsNone)
			{
				startGameObject.Value = offMeshLinkData.offMeshLink.startTransform.gameObject;
			}
			if (!endGameObject.IsNone)
			{
				endGameObject.Value = offMeshLinkData.offMeshLink.endTransform.gameObject;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the reference to the game object of current OffMeshLink of a NavMeshAgent. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentCurrentOffMeshLinkGameObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The GameObject with the current OffMeshLink component attached")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeOffMeshLinkGameObject;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeOffMeshLinkGameObject = new FsmGameObject
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetCurrentOffMeshLinkGameObject();
			Finish();
		}

		private void DoGetCurrentOffMeshLinkGameObject()
		{
			if (!(_agent == null) && _agent.isOnOffMeshLink)
			{
				OffMeshLink offMeshLink = _agent.currentOffMeshLinkData.offMeshLink;
				if (offMeshLink != null)
				{
					storeOffMeshLinkGameObject.Value = offMeshLink.gameObject;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the desired velocity of the agent including any potential contribution from avoidance. \nNOTE: The Game Object must have a NavMeshAgent.")]
	public class GetAgentDesiredVelocity : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("the relative vertical displacement of the owning GameObject")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 desiredVelocity;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			desiredVelocity = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetDesiredVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetDesiredVelocity();
		}

		private void DoGetDesiredVelocity()
		{
			if (!(_agent == null))
			{
				desiredVelocity.Value = _agent.desiredVelocity;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the destination of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentDestination : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store the destination of the navMesh Agent.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeResult;

		[Tooltip("Runs every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetDestination();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetDestination();
		}

		private void DoGetDestination()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.destination;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the flag a NavMesh Agent if it currently has a path. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentHasPath : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the agent if it currently has a path.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetHasPath();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetHasPath();
		}

		private void DoGetHasPath()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.hasPath;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the height of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentHeight : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the agent height.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetHeight();
			Finish();
		}

		private void DoGetHeight()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.height;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets if agent currently positioned on an OffMeshLink. \nNOTE: The Game Object must have a NavMeshAgent.")]
	public class GetAgentIsOnOffMeshLink : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store flag if agent currently positioned on an OffMeshLink.")]
		public FsmBool isOnOffMeshLink;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			isOnOffMeshLink = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetIsOnOffMeshLink();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetIsOnOffMeshLink();
		}

		private void DoGetIsOnOffMeshLink()
		{
			if (isOnOffMeshLink != null && !(_agent == null))
			{
				isOnOffMeshLink.Value = _agent.isOnOffMeshLink;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the flag a NavMesh Agent if the current path stale. \nWhen true, the path may no longer be valid or optimal. \nThis flag will be set : \n--if there are any changes to the walkableMask, \n--if any off-mesh link is enabled or disabled, \n--or if the costs for the NavMeshLayers have been changed. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentIsPathStale : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the agent if the current path stale.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Runs every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetIsPathStale();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetIsPathStale();
		}

		private void DoGetIsPathStale()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.isPathStale;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the stop or resume condition of the NavMesh agent. The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentIsStopped : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store the agent isStopped condition.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Runs every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetIsPathStale();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetIsPathStale();
		}

		private void DoGetIsPathStale()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.isStopped;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the cost for path calculation when crossing area of a particular type.. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentAreaCost : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Area index.")]
		public FsmInt area;

		[Tooltip("OR the Area name.")]
		public FsmString orAreaName;

		[ActionSection("Result")]
		[Tooltip("Store the Area Cost")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			area = null;
			orAreaName = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetLayerCost();
			Finish();
		}

		private void DoGetLayerCost()
		{
			if (!(_agent == null))
			{
				int areaIndex = area.Value;
				if (orAreaName.Value != "")
				{
					areaIndex = NavMesh.GetAreaFromName(orAreaName.Value);
				}
				storeResult.Value = _agent.GetAreaCost(areaIndex);
			}
		}

		public override string ErrorCheck()
		{
			if (orAreaName.Value != "")
			{
				int areaFromName = NavMesh.GetAreaFromName(orAreaName.Value);
				if (areaFromName == -1)
				{
					return "Layer Name '" + orAreaName.Value + "' doesn't exists";
				}
				if (area.Value != 0)
				{
					if (areaFromName == area.Value)
					{
						return "Area reference redundancy. Use 'Area' OR 'Area Name', not both at the same time..";
					}
					return "Area conflict, area name '" + orAreaName.Value + "' will be used";
				}
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the maximum acceleration of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentMaximumAcceleration : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the agent maximum acceleration")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetAcceleration();
			Finish();
		}

		private void DoGetAcceleration()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.acceleration;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the Maximum rotation speed in (deg/s) of a NavMesh Agent. \nWARNING, this is the maximum speed, not the current velocity. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentMaximumAngularSpeed : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the agent Maximum rotation speed in (deg/s).")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetAngularSpeed();
			Finish();
		}

		private void DoGetAngularSpeed()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.angularSpeed;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the maximum movement speed of a NavMesh Agent. \nWARNING, this is the maximum speed possible for the agent, not the actual current speed ( use getAgentVelocity for this). \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentMaximumSpeed : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the agent maximum movement speed")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetSpeed();
			Finish();
		}

		private void DoGetSpeed()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.speed;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the next offMeshLink data of a NavMesh Agent on the current path. In the case that the current path does not contain an OffMeshLink the OffMeshLinkData is marked as invalid. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentNextOffMeshLinkData : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[Tooltip("Link start world position")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 startPos;

		[Tooltip("Link start GameObject representing the link start position")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject startGameObject;

		[Tooltip("Link end world position")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 endPos;

		[Tooltip("Link end GameObject representing the link end position")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject endGameObject;

		[Tooltip("Is Link activated")]
		[UIHint(UIHint.Variable)]
		public FsmBool activated;

		[Tooltip("Is Link valid")]
		[UIHint(UIHint.Variable)]
		public FsmBool valid;

		[Tooltip("Is Link occupied")]
		[UIHint(UIHint.Variable)]
		public FsmBool occupied;

		[Tooltip("LinkTypeSpecifier: range: manual, dropDown, jumpAcross")]
		[UIHint(UIHint.Variable)]
		public FsmString OffMeshlinkType;

		[Tooltip("The pathfinding cost for the link")]
		[UIHint(UIHint.Variable)]
		public FsmFloat costOverride;

		[Tooltip("Can link be traversed in both directions")]
		[UIHint(UIHint.Variable)]
		public FsmBool biDirectional;

		[Tooltip("Is Link automatically updating endpoints")]
		[UIHint(UIHint.Variable)]
		public FsmBool autoUpdatePositions;

		[Tooltip("The Area for this OffMeshLink component")]
		[UIHint(UIHint.Variable)]
		public FsmInt navmeshArea;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			startPos = new FsmVector3
			{
				UseVariable = true
			};
			startGameObject = new FsmGameObject
			{
				UseVariable = true
			};
			endPos = new FsmVector3
			{
				UseVariable = true
			};
			endGameObject = new FsmGameObject
			{
				UseVariable = true
			};
			activated = new FsmBool
			{
				UseVariable = true
			};
			valid = new FsmBool
			{
				UseVariable = true
			};
			occupied = new FsmBool
			{
				UseVariable = true
			};
			OffMeshlinkType = new FsmString
			{
				UseVariable = true
			};
			biDirectional = new FsmBool
			{
				UseVariable = true
			};
			autoUpdatePositions = new FsmBool
			{
				UseVariable = true
			};
			navmeshArea = new FsmInt
			{
				UseVariable = true
			};
			costOverride = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetOffMeshLinkData();
			Finish();
		}

		private void DoGetOffMeshLinkData()
		{
			if (_agent == null || !_agent.isOnOffMeshLink)
			{
				return;
			}
			OffMeshLinkData offMeshLinkData = default(OffMeshLinkData);
			offMeshLinkData = _agent.nextOffMeshLinkData;
			if (!startPos.IsNone)
			{
				startPos.Value = offMeshLinkData.startPos;
			}
			if (!endPos.IsNone)
			{
				endPos.Value = offMeshLinkData.endPos;
			}
			if (!activated.IsNone)
			{
				activated.Value = offMeshLinkData.activated;
			}
			if (!valid.IsNone)
			{
				valid.Value = offMeshLinkData.valid;
			}
			if (!OffMeshlinkType.IsNone)
			{
				switch (offMeshLinkData.linkType)
				{
				case OffMeshLinkType.LinkTypeManual:
					OffMeshlinkType.Value = "manual";
					break;
				case OffMeshLinkType.LinkTypeDropDown:
					OffMeshlinkType.Value = "dropDown";
					break;
				case OffMeshLinkType.LinkTypeJumpAcross:
					OffMeshlinkType.Value = "jumpAcross";
					break;
				}
			}
			if (!costOverride.IsNone)
			{
				costOverride.Value = offMeshLinkData.offMeshLink.costOverride;
			}
			if (!occupied.IsNone)
			{
				occupied.Value = offMeshLinkData.offMeshLink.occupied;
			}
			if (!autoUpdatePositions.IsNone)
			{
				autoUpdatePositions.Value = offMeshLinkData.offMeshLink.autoUpdatePositions;
			}
			if (!navmeshArea.IsNone)
			{
				navmeshArea.Value = offMeshLinkData.offMeshLink.area;
			}
			if (!startGameObject.IsNone)
			{
				startGameObject.Value = offMeshLinkData.offMeshLink.startTransform.gameObject;
			}
			if (!endGameObject.IsNone)
			{
				endGameObject.Value = offMeshLinkData.offMeshLink.endTransform.gameObject;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the next position on the current path of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent.")]
	public class GetAgentNextPosition : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The next position on the current path of the navMesh Agent.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 nextPosition;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			nextPosition = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetNextPosition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetNextPosition();
		}

		private void DoGetNextPosition()
		{
			if (!(_agent == null) && nextPosition != null)
			{
				nextPosition.Value = _agent.nextPosition;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the level of quality of avoidance of a NavMesh Agent. \nStore as a string or as an int: Range: no:(0), low:(1), medium:(2), good(3), high(4). \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentObstacleAvoidanceType : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the agent level of quality of avoidance. Range: no,low,medium,good,high")]
		[UIHint(UIHint.Variable)]
		public FsmString storeQualityAsString;

		[Tooltip("Store the agent level of quality of avoidance. Range: no:(0), low:(1), medium:(2), good(3), high(4)")]
		[UIHint(UIHint.Variable)]
		public FsmInt storeQualityAsInt;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeQualityAsString = null;
			storeQualityAsInt = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetbstacleAvoidanceType();
			Finish();
		}

		private void DoGetbstacleAvoidanceType()
		{
			if (!(_agent == null))
			{
				string value = "";
				int value2 = 0;
				switch (_agent.obstacleAvoidanceType)
				{
				case ObstacleAvoidanceType.NoObstacleAvoidance:
					value = "no";
					value2 = 0;
					break;
				case ObstacleAvoidanceType.LowQualityObstacleAvoidance:
					value = "low";
					value2 = 1;
					break;
				case ObstacleAvoidanceType.MedQualityObstacleAvoidance:
					value = "medium";
					value2 = 2;
					break;
				case ObstacleAvoidanceType.GoodQualityObstacleAvoidance:
					value = "good";
					value2 = 3;
					break;
				case ObstacleAvoidanceType.HighQualityObstacleAvoidance:
					value = "high";
					value2 = 4;
					break;
				}
				if (storeQualityAsString != null)
				{
					storeQualityAsString.Value = value;
				}
				if (storeQualityAsInt != null)
				{
					storeQualityAsInt.Value = value2;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the flag a NavMesh Agent if a path is being computed, but not yet ready. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentPathPending : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the agent if a path is being computed, but not yet ready. ")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetPathPending();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetPathPending();
		}

		private void DoGetPathPending()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.pathPending;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the path status or an Agent and dispatch events. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentPathStatus : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The path terminates at the destination.")]
		public FsmEvent pathCompleteEvent;

		[Tooltip("The path cannot reach the destination.")]
		public FsmEvent pathPartialEvent;

		[Tooltip("The path is invalid.")]
		public FsmEvent pathInvalidEvent;

		[Tooltip("Path is being computed, but not yet ready. ")]
		public FsmEvent pathPendingEvent;

		[Tooltip("The agent does not currently have a path.")]
		public FsmEvent pathUndefinedEvent;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			pathCompleteEvent = null;
			pathPartialEvent = null;
			pathInvalidEvent = null;
			pathPendingEvent = null;
			pathUndefinedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetPathStatus();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetPathStatus();
		}

		private void DoGetPathStatus()
		{
			if (!(_agent == null))
			{
				if (!_agent.hasPath && pathUndefinedEvent != null)
				{
					base.Fsm.Event(pathUndefinedEvent);
					Finish();
				}
				if (!_agent.pathPending && pathPendingEvent != null)
				{
					base.Fsm.Event(pathPendingEvent);
					Finish();
				}
				if (_agent.pathStatus == NavMeshPathStatus.PathComplete && pathCompleteEvent != null)
				{
					base.Fsm.Event(pathCompleteEvent);
					Finish();
				}
				if (_agent.pathStatus == NavMeshPathStatus.PathPartial && pathPartialEvent != null)
				{
					base.Fsm.Event(pathPartialEvent);
					Finish();
				}
				if (_agent.pathStatus == NavMeshPathStatus.PathInvalid && pathInvalidEvent != null)
				{
					base.Fsm.Event(pathInvalidEvent);
					Finish();
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the radius of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentRadius : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the agent radius.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetRadius();
			Finish();
		}

		private void DoGetRadius()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.radius;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the remaining distance on the current path of a NavMesh Agent. Can also send an event when arrived. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentRemainingDistance : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the remaining distance on the current path.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		[Tooltip("When remaining distance is 0, sends event.")]
		public FsmEvent arrivedEvent;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			arrivedEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetRemainingDistance();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetRemainingDistance();
		}

		private void DoGetRemainingDistance()
		{
			if (storeResult != null && !(_agent == null) && _agent.isActiveAndEnabled)
			{
				storeResult.Value = _agent.remainingDistance;
				if (_agent.remainingDistance == 0f && arrivedEvent != null)
				{
					base.Fsm.Event(arrivedEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the current steering target - usually the next corner or end point of the current path. (Read Only) \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentSteeringTarget : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the steering target.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetSteeringTarget();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSteeringTarget();
		}

		private void DoGetSteeringTarget()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.steeringTarget;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the stopping distance from the destination position of a NavMesh Agente. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentStoppingDistance : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store the stopping distance from the target position")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetStoppingDistance();
			Finish();
		}

		private void DoGetStoppingDistance()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.stoppingDistance;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the flag a NavMesh Agent if it should update the transform position. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentUpdatePosition : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the agent if it should update the position.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		private void DoGetUpdatePosition()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.updatePosition;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the flag a NavMesh Agent if it should update the transform rotation. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class GetAgentUpdateRotation : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the agent if it should update the rotation.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetUpdateRotation();
		}

		private void DoGetUpdateRotation()
		{
			if (storeResult != null && !(_agent == null))
			{
				storeResult.Value = _agent.updateRotation;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the velocity of a NavMesh Agent and stores it in a float Variable ( the magnitude) or in a vector3 directly. \nNOTE: The Game Object must have a NavMeshAgent.")]
	public class GetAgentVelocity : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The current velocity of the navMesh Agent.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 velocity;

		[Tooltip("The current velocity magnitude  of the navMesh Agent.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat velocityMagnitude;

		[Tooltip("The current squared velocity magnitude of the navMesh Agent. NOTE: Faster than getting the actual magnitude")]
		[UIHint(UIHint.Variable)]
		public FsmFloat velocitySqrMagnitude;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			velocity = null;
			velocityMagnitude = null;
			velocitySqrMagnitude = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetVelocity();
		}

		private void DoGetVelocity()
		{
			if (!(_agent == null))
			{
				if (velocity != null)
				{
					velocity.Value = _agent.velocity;
				}
				if (velocityMagnitude != null)
				{
					velocityMagnitude.Value = _agent.velocity.magnitude;
				}
				if (velocitySqrMagnitude != null)
				{
					velocitySqrMagnitude.Value = _agent.velocity.sqrMagnitude;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Gets the area mask of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class GetAgentAreaMask : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Store the walkable mask")]
		[UIHint(UIHint.Variable)]
		public FsmInt storeResult;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoGetWalkableMask();
			Finish();
		}

		private void DoGetWalkableMask()
		{
			if (!storeResult.IsNone && !(_agent == null))
			{
				storeResult.Value = _agent.areaMask;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Specifies which NavMesh areas are passable. \nChanging AreaMask will make the path stale (see isPathStale). \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentAreaMask : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Pick the walkable NavMesh areas")]
		public FsmInt NavMeshAreaMask;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			NavMeshAreaMask = -1;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetAreaMask();
			Finish();
		}

		private void DoSetAreaMask()
		{
			if (!(_agent == null))
			{
				_agent.areaMask = NavMeshAreaMask.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the flag for the agent to brake automatically to avoid overshooting the destination point\nIf the agent needs to land close to the destination point then it will typically need to brake to avoid overshooting or endless 'orbiting around the target zone.If this property is set to true, the agent will brake automatically as it nears the destination.NOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentAutoBraking : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Flag to brake automatically to avoid overshooting the destination point")]
		public FsmBool autoBraking;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			autoBraking = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetAutoBraking();
			Finish();
		}

		private void DoSetAutoBraking()
		{
			if (autoBraking != null && !(_agent == null))
			{
				_agent.autoBraking = autoBraking.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the flag to attempt to acquire a new path \nif the existing path of a NavMesh Agent becomes invalid \nor if the agent reaches the end of a partial and stale path. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentAutoRepath : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Flag to attempt to acquire a new path if the existing path of a NavMesh Agent becomes invalid or if the agent reaches the end of a partial and stale path.")]
		public FsmBool isStopped;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			isStopped = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetAutoRepath();
			Finish();
		}

		private void DoSetAutoRepath()
		{
			if (isStopped != null && !(_agent == null))
			{
				_agent.autoRepath = isStopped.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set flag to automate movement onto and off of OffMeshLinks. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentAutoTraverseOffMeshLink : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("flag for automatic movement onto and off of OffMeshLinks")]
		public FsmBool autoTraverseOffMeshLink;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			autoTraverseOffMeshLink = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetAutoTraverseOffMeshLink();
			Finish();
		}

		private void DoSetAutoTraverseOffMeshLink()
		{
			if (autoTraverseOffMeshLink != null && !(_agent == null))
			{
				_agent.autoTraverseOffMeshLink = autoTraverseOffMeshLink.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the avoidance priority level a NavMesh Agent.\nWhen the agent is performing avoidance, agents of lower priority are ignored.\nThe valid range is from 0 to 99 where: Most important = 0. Least important = 99. Default = 50.  \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentAvoidancePriority : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The avoidance priority of the navMesh Agent.")]
		public FsmInt avoidancePriority;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			avoidancePriority = 50;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetAvoidancePriority();
			Finish();
		}

		private void DoSetAvoidancePriority()
		{
			if (avoidancePriority != null && !(_agent == null))
			{
				_agent.avoidancePriority = avoidancePriority.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the destination of a NavMesh Agent. \nAn Event can be triggered when the new path calculation is finished (pathPending flag). \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class SetAgentDestination : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Set the destination to navigate towards.")]
		public FsmVector3 destination;

		[Tooltip("Trigger event when path is computed (pathPending flag)")]
		public FsmEvent pathPendingDoneEvent;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			destination = null;
			pathPendingDoneEvent = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetDestination();
			if (pathPendingDoneEvent == null)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (!_agent.pathPending)
			{
				base.Fsm.Event(pathPendingDoneEvent);
				Finish();
			}
		}

		private void DoSetDestination()
		{
			if (destination != null && !(_agent == null) && _agent.gameObject.activeInHierarchy && _agent.isOnNavMesh)
			{
				_agent.SetDestination(destination.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the destination of a NavMesh Agent to a gameObject. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class SetAgentDestinationAsGameObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Set the destination to navigate towards.")]
		public FsmGameObject destination;

		[RequiredField]
		[Tooltip("Define the gameObject minimum movement distance to retrigger path computation.")]
		public FsmFloat triggerThreshold;

		private NavMeshAgent _agent;

		private Vector3 lastPosition;

		private float lastDistance;

		private float squareDistance;

		private GameObject _lastGo;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			destination = null;
			triggerThreshold = 1f;
		}

		public override void OnEnter()
		{
			_lastGo = null;
			_getAgent();
			DoSetDestination();
		}

		public override void OnUpdate()
		{
			DoSetDestination();
		}

		private void DoSetDestination()
		{
			if (!(destination.Value == null) && !(_agent == null))
			{
				bool flag = false;
				if (_lastGo != destination.Value)
				{
					flag = true;
					_lastGo = destination.Value;
				}
				if (lastDistance != triggerThreshold.Value)
				{
					lastDistance = triggerThreshold.Value;
					squareDistance = lastDistance * lastDistance;
				}
				Vector3 position = destination.Value.transform.position;
				if ((position - lastPosition).sqrMagnitude > squareDistance || flag)
				{
					_agent.SetDestination(position);
					lastPosition = destination.Value.transform.position;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the height a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentHeight : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The height of the navMesh Agent.")]
		public FsmFloat height;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			height = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetHeight();
			Finish();
		}

		private void DoSetHeight()
		{
			if (height != null && !(_agent == null))
			{
				_agent.height = height.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Sets the stop or resume condition of the NavMesh agent. If set to True, the NavMesh agent's movement will be stopped along its current path. If set to False after the NavMesh agent has stopped, it will resume moving along its current path.")]
	public class SetAgentIsStopped : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The stop or resume condition of the NavMesh agent")]
		public FsmBool isStopped;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			isStopped = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetIsStopped();
			Finish();
		}

		private void DoSetIsStopped()
		{
			if (isStopped != null && !(_agent == null))
			{
				_agent.isStopped = isStopped.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Sets the cost for traversing over geometry of the layer type. \n Cost should be between 1 and infinite. A cost of 3 means that walking 1 meter feels as walking 3 meter when cost is 1. So a higher value means 'more expensive'.\nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentLayerCost : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Area index.")]
		public FsmInt area;

		[Tooltip("OR the Area name.")]
		public FsmString orAreaName;

		[Tooltip("The Layer Cost. A cost of 3 means that walking 1 meter feels as walking 3 meter when cost is 1")]
		public FsmFloat cost;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			area = null;
			orAreaName = new FsmString
			{
				UseVariable = true
			};
			cost = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetLayerCost();
			Finish();
		}

		private void DoSetLayerCost()
		{
			if (!(_agent == null))
			{
				int areaIndex = area.Value;
				if (orAreaName.Value != "")
				{
					areaIndex = NavMesh.GetAreaFromName(orAreaName.Value);
				}
				_agent.SetAreaCost(areaIndex, cost.Value);
			}
		}

		public override string ErrorCheck()
		{
			if (orAreaName.Value != "")
			{
				int areaFromName = NavMesh.GetAreaFromName(orAreaName.Value);
				if (areaFromName == -1)
				{
					return "Layer Name '" + orAreaName.Value + "' doesn't exists";
				}
				if (area.Value != 0)
				{
					if (areaFromName == area.Value)
					{
						return "Area reference redundancy. Use 'Area' OR 'Area Name', not both at the same time..";
					}
					return "Area conflict, area name '" + orAreaName.Value + "' will be used";
				}
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the maximum acceleration of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentMaximumAcceleration : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The maximum acceleration of the navMesh Agent.")]
		public FsmFloat maximumAcceleration;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			maximumAcceleration = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetMaximumAcceleration();
			Finish();
		}

		private void DoSetMaximumAcceleration()
		{
			if (maximumAcceleration != null && !(_agent == null))
			{
				_agent.acceleration = maximumAcceleration.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the maximum rotation speed in (deg/s) of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentMaximumAngularSpeed : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The maximum rotation speed in (deg/s) of the navMesh Agent.")]
		public FsmFloat maximumAngularSpeed;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			maximumAngularSpeed = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetMaximumAngularSpeed();
			Finish();
		}

		private void DoSetMaximumAngularSpeed()
		{
			if (maximumAngularSpeed != null && !(_agent == null))
			{
				_agent.angularSpeed = maximumAngularSpeed.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the maximum movement speed of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentMaximumSpeed : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The maximum movement speed of the navMesh Agent.")]
		public FsmFloat maximumSpeed;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			maximumSpeed = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetMaximumSpeed();
			Finish();
		}

		private void DoSetMaximumSpeed()
		{
			if (maximumSpeed != null && !(_agent == null))
			{
				_agent.speed = maximumSpeed.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the agent obstacle avoidance type of a NavMesh Agent. \nUse either a string or an int: range: no:(0), low:(1), medium:(2), good(3), high(4). \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentObstacleAvoidanceType : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[Tooltip("The agent level of quality of avoidance")]
		public ObstacleAvoidanceType quality;

		[Tooltip("OR The agent level of quality of avoidance as a string. Range: no, low, medium, good, high]")]
		[UIHint(UIHint.Variable)]
		public FsmString orQualityFromString;

		[Tooltip("OR The agent level of quality of avoidance as an int. Range: no:(0), low:(1), medium:(2), good(3), high(4))]")]
		[UIHint(UIHint.Variable)]
		public FsmInt orQualityFromInt;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			quality = ObstacleAvoidanceType.NoObstacleAvoidance;
			orQualityFromString = null;
			orQualityFromInt = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetObstacleAvoidanceType();
			Finish();
		}

		private void DoSetObstacleAvoidanceType()
		{
			if (_agent == null)
			{
				return;
			}
			ObstacleAvoidanceType obstacleAvoidanceType = quality;
			if (!orQualityFromInt.IsNone)
			{
				switch (orQualityFromInt.Value)
				{
				case 0:
					obstacleAvoidanceType = ObstacleAvoidanceType.NoObstacleAvoidance;
					break;
				case 1:
					obstacleAvoidanceType = ObstacleAvoidanceType.LowQualityObstacleAvoidance;
					break;
				case 2:
					obstacleAvoidanceType = ObstacleAvoidanceType.MedQualityObstacleAvoidance;
					break;
				case 3:
					obstacleAvoidanceType = ObstacleAvoidanceType.GoodQualityObstacleAvoidance;
					break;
				case 4:
					obstacleAvoidanceType = ObstacleAvoidanceType.HighQualityObstacleAvoidance;
					break;
				}
			}
			else if (!orQualityFromString.IsNone)
			{
				switch (orQualityFromString.Value)
				{
				case "no":
					obstacleAvoidanceType = ObstacleAvoidanceType.NoObstacleAvoidance;
					break;
				case "low":
					obstacleAvoidanceType = ObstacleAvoidanceType.LowQualityObstacleAvoidance;
					break;
				case "medium":
					obstacleAvoidanceType = ObstacleAvoidanceType.MedQualityObstacleAvoidance;
					break;
				case "good":
					obstacleAvoidanceType = ObstacleAvoidanceType.GoodQualityObstacleAvoidance;
					break;
				case "high":
					obstacleAvoidanceType = ObstacleAvoidanceType.HighQualityObstacleAvoidance;
					break;
				}
			}
			_agent.obstacleAvoidanceType = obstacleAvoidanceType;
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Assign path to NavMesh Agent. Uses FsmNavMeshPath component. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentPath : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The Game Object holding the path. NOTE: The Game Object must have a FsmNavMeshPath component attached.")]
		[CheckForComponent(typeof(FsmNavMeshPath))]
		public FsmOwnerDefault path;

		[Tooltip("True if succesfully assigned.")]
		public FsmBool pathAssigned;

		[Tooltip("Trigger event if path assigned.")]
		public FsmEvent pathAssignedEvent;

		[Tooltip("Trigger event if path not assigned.")]
		public FsmEvent pathNotAssignedEvent;

		private NavMeshAgent _agent;

		private FsmNavMeshPath _pathProxy;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		private void _getPathProxy()
		{
			GameObject gameObject = ((path.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : path.GameObject.Value);
			if (!(gameObject == null))
			{
				_pathProxy = gameObject.GetComponent<FsmNavMeshPath>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			path = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			_getPathProxy();
			DoSetPath();
			Finish();
		}

		private void DoSetPath()
		{
			if (_pathProxy == null || _agent == null)
			{
				return;
			}
			bool flag = _agent.SetPath(_pathProxy.path);
			pathAssigned.Value = flag;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(pathAssignedEvent))
				{
					base.Fsm.Event(pathAssignedEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(pathNotAssignedEvent))
			{
				base.Fsm.Event(pathNotAssignedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the radius a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentRadius : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The radius of the navMesh Agent.")]
		public FsmFloat radius;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			radius = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetRadius();
			Finish();
		}

		private void DoSetRadius()
		{
			if (radius != null && !(_agent == null))
			{
				_agent.radius = radius.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Sets the Stopping distance from the destination position of a NavMesh Agent. \nNOTE: The Game Object must have a NavMeshAgentcomponent attached.")]
	public class SetAgentStoppingDistance : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The Stopping distance from the destination position")]
		public FsmFloat stoppingDistance;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			stoppingDistance = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetStoppingDistance();
			Finish();
		}

		private void DoSetStoppingDistance()
		{
			if (stoppingDistance != null && !(_agent == null))
			{
				_agent.stoppingDistance = stoppingDistance.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the flag for a NavMesh Agent to update the transform position. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentUpdatePosition : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Should the Agent update the transform position")]
		public FsmBool updatePosition;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			updatePosition = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetUpdatePosition();
			Finish();
		}

		private void DoSetUpdatePosition()
		{
			if (updatePosition != null && !(_agent == null))
			{
				_agent.updatePosition = updatePosition.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Set the flag for a NavMesh Agent to update the transform rotation. \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class SetAgentUpdateRotation : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Should the Agent update the transform rotation")]
		public FsmBool updateRotation;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			updateRotation = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			DoSetUpdateRotation();
			Finish();
		}

		private void DoSetUpdateRotation()
		{
			if (updateRotation != null && !(_agent == null))
			{
				_agent.updateRotation = updateRotation.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMeshAgent)]
	[Tooltip("Watch the agent entering and leaving OffMeshLinks. Use this to send an event on change, or store a bool that can be used in other operations. \nNOTE: The Game Object must have a NavMeshAgent.")]
	public class WatchAgentIsOnOffMeshLink : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have a NavMeshAgent component attached.")]
		[CheckForComponent(typeof(NavMeshAgent))]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[Tooltip("Store flag if agent currently positioned on an OffMeshLink.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isOnOffMeshLink;

		[Tooltip("Trigger this event when isOnOffMeshLink switches to true. Essentially triggers when agent enters an offmeshlink")]
		public FsmEvent isOnOffMeshLinkEvent;

		[Tooltip("Trigger this event when isOnOffMeshLink switches to false. Essentially triggers when agent leaves an offmeshlink")]
		public FsmEvent isNotOnOffMeshLinkEvent;

		private bool previousValue;

		private NavMeshAgent _agent;

		private void _getAgent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			isOnOffMeshLink = null;
			isOnOffMeshLinkEvent = null;
			isNotOnOffMeshLinkEvent = null;
		}

		public override void OnEnter()
		{
			_getAgent();
			if (!(_agent == null))
			{
				previousValue = _agent.isOnOffMeshLink;
			}
		}

		public override void OnUpdate()
		{
			DoWatchIsOnOffMeshLink();
		}

		private void DoWatchIsOnOffMeshLink()
		{
			if (_agent == null)
			{
				return;
			}
			if (!isOnOffMeshLink.IsNone)
			{
				isOnOffMeshLink.Value = _agent.isOnOffMeshLink;
			}
			if (previousValue != _agent.isOnOffMeshLink)
			{
				previousValue = _agent.isOnOffMeshLink;
				if (_agent.isOnOffMeshLink && isOnOffMeshLinkEvent != null)
				{
					base.Fsm.Event(isOnOffMeshLinkEvent);
				}
				else if (!_agent.isOnOffMeshLink && isNotOnOffMeshLinkEvent != null)
				{
					base.Fsm.Event(isNotOnOffMeshLinkEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Calculate a path between two points and store the resulting path.")]
	public class NavMeshCalculatePath : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The mask specifying which NavMesh layers can be passed when calculating the path.")]
		[UIHint(UIHint.FsmInt)]
		public FsmInt passableMask;

		[RequiredField]
		[Tooltip("The initial position of the path requested.")]
		[UIHint(UIHint.FsmVector3)]
		public FsmVector3 sourcePosition;

		[RequiredField]
		[Tooltip("The final position of the path requested.")]
		[UIHint(UIHint.FsmVector3)]
		public FsmVector3 targetPosition;

		[ActionSection("Result")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Vector3, "", 0, 0, 65536)]
		[Tooltip("Store the calculated path corners")]
		public FsmArray calculatedPathCorners;

		[Tooltip("The Fsm NavMeshPath proxy component to hold the resulting path")]
		[UIHint(UIHint.Variable)]
		[CheckForComponent(typeof(FsmNavMeshPath))]
		public FsmOwnerDefault calculatedPath;

		[Tooltip("True If a resulting path is found.")]
		[UIHint(UIHint.Variable)]
		public FsmBool resultingPathFound;

		[Tooltip("Trigger event if resulting path found.")]
		public FsmEvent resultingPathFoundEvent;

		[Tooltip("Trigger event if no path could be found.")]
		public FsmEvent resultingPathNotFoundEvent;

		private FsmNavMeshPath _NavMeshPathProxy;

		private void _getNavMeshPathProxy()
		{
			GameObject gameObject = ((calculatedPath.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : calculatedPath.GameObject.Value);
			if (!(gameObject == null))
			{
				_NavMeshPathProxy = gameObject.GetComponent<FsmNavMeshPath>();
			}
		}

		public override void Reset()
		{
			calculatedPath = new FsmOwnerDefault();
			calculatedPath.OwnerOption = OwnerDefaultOption.SpecifyGameObject;
			calculatedPath.GameObject = new FsmGameObject
			{
				UseVariable = true
			};
			calculatedPathCorners = null;
			passableMask = -1;
			sourcePosition = null;
			targetPosition = null;
			resultingPathFound = null;
			resultingPathFoundEvent = null;
			resultingPathNotFoundEvent = null;
		}

		public override void OnEnter()
		{
			DoCalculatePath();
			Finish();
		}

		private void DoCalculatePath()
		{
			_getNavMeshPathProxy();
			NavMeshPath navMeshPath = new NavMeshPath();
			bool flag = NavMesh.CalculatePath(sourcePosition.Value, targetPosition.Value, passableMask.Value, navMeshPath);
			if (_NavMeshPathProxy != null)
			{
				_NavMeshPathProxy.path = navMeshPath;
			}
			if (!calculatedPathCorners.IsNone)
			{
				calculatedPathCorners.Resize(navMeshPath.corners.Length);
				for (int i = 0; i < calculatedPathCorners.Length; i++)
				{
					calculatedPathCorners.Set(i, navMeshPath.corners[i]);
				}
				calculatedPathCorners.SaveChanges();
			}
			resultingPathFound.Value = flag;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(resultingPathFoundEvent))
				{
					base.Fsm.Event(resultingPathFoundEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(resultingPathNotFoundEvent))
			{
				base.Fsm.Event(resultingPathNotFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Calculate a path between two GameObjects and store the resulting path.")]
	public class NavMeshCalculatePathBetweenGameObjects : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The mask specifying which NavMesh layers can be passed when calculating the path.")]
		public FsmInt passableMask;

		[RequiredField]
		[Tooltip("The initial position of the path requested.")]
		public FsmOwnerDefault sourceGameObject;

		[RequiredField]
		[Tooltip("The final position of the path requested.")]
		public FsmGameObject targetGameObject;

		[ActionSection("Result")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Vector3, "", 0, 0, 65536)]
		[Tooltip("Store the calculated path corners")]
		public FsmArray calculatedPathCorners;

		[Tooltip("The Fsm NavMeshPath proxy component to hold the resulting path")]
		[UIHint(UIHint.Variable)]
		[CheckForComponent(typeof(FsmNavMeshPath))]
		public FsmOwnerDefault calculatedPath;

		[Tooltip("True If a resulting path is found.")]
		[UIHint(UIHint.Variable)]
		public FsmBool resultingPathFound;

		[Tooltip("Trigger event if resulting path found.")]
		public FsmEvent resultingPathFoundEvent;

		[Tooltip("Trigger event if no path could be found.")]
		public FsmEvent resultingPathNotFoundEvent;

		private FsmNavMeshPath _NavMeshPathProxy;

		private void _getNavMeshPathProxy()
		{
			GameObject gameObject = ((calculatedPath.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : calculatedPath.GameObject.Value);
			if (!(gameObject == null))
			{
				_NavMeshPathProxy = gameObject.GetComponent<FsmNavMeshPath>();
			}
		}

		public override void Reset()
		{
			calculatedPath = new FsmOwnerDefault();
			calculatedPath.OwnerOption = OwnerDefaultOption.SpecifyGameObject;
			calculatedPath.GameObject = new FsmGameObject
			{
				UseVariable = true
			};
			calculatedPathCorners = null;
			passableMask = -1;
			sourceGameObject = null;
			targetGameObject = null;
			resultingPathFound = null;
			resultingPathFoundEvent = null;
			resultingPathNotFoundEvent = null;
		}

		public override void OnEnter()
		{
			DoCalculatePath();
			Finish();
		}

		private void DoCalculatePath()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(sourceGameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			GameObject value = targetGameObject.Value;
			if (value == null)
			{
				return;
			}
			_getNavMeshPathProxy();
			NavMeshPath navMeshPath = new NavMeshPath();
			bool flag = NavMesh.CalculatePath(ownerDefaultTarget.transform.position, value.transform.position, passableMask.Value, navMeshPath);
			if (_NavMeshPathProxy != null)
			{
				_NavMeshPathProxy.path = navMeshPath;
			}
			if (!calculatedPathCorners.IsNone)
			{
				calculatedPathCorners.Resize(navMeshPath.corners.Length);
				for (int i = 0; i < calculatedPathCorners.Length; i++)
				{
					calculatedPathCorners.Set(i, navMeshPath.corners[i]);
				}
				calculatedPathCorners.SaveChanges();
			}
			resultingPathFound.Value = flag;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(resultingPathFoundEvent))
				{
					base.Fsm.Event(resultingPathFoundEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(resultingPathNotFoundEvent))
			{
				base.Fsm.Event(resultingPathNotFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Locate the closest NavMesh edge from a point close to the NavMesh. \nYou can dispatch events If terminated before reaching the target position or not. \nYou can then store information about the location (navMeshHit).")]
	public class NavMeshFindClosestEdge : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The origin of the distance query.")]
		public FsmVector3 sourcePosition;

		[RequiredField]
		[Tooltip("The mask specifying which NavMesh layers can be passed when finding the nearest edge.")]
		public FsmInt passableMask;

		[ActionSection("Result")]
		[Tooltip("True if a nearest edge is found.")]
		[UIHint(UIHint.Variable)]
		public FsmBool nearestEdgeFound;

		[Tooltip("Trigger event if a nearest edge is found.")]
		public FsmEvent nearestEdgeFoundEvent;

		[Tooltip("Trigger event if a nearest edge is NOT found.")]
		public FsmEvent nearestEdgeNotFoundEvent;

		[ActionSection("Hit information (of the found edge)")]
		[Tooltip("Position of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 position;

		[Tooltip("Normal at the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 normal;

		[Tooltip("Distance to the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmFloat distance;

		[Tooltip("Mask specifying NavMeshLayers at point of hit.")]
		[UIHint(UIHint.Variable)]
		public FsmInt mask;

		[Tooltip("Flag when hit")]
		[UIHint(UIHint.Variable)]
		public FsmBool hit;

		public override void Reset()
		{
			sourcePosition = null;
			passableMask = -1;
			nearestEdgeFound = null;
			nearestEdgeFoundEvent = null;
			nearestEdgeNotFoundEvent = null;
			position = null;
			normal = null;
			distance = null;
			mask = null;
			hit = null;
		}

		public override void OnEnter()
		{
			DoGetDistancetoEdge();
			Finish();
		}

		private void DoGetDistancetoEdge()
		{
			NavMeshHit navMeshHit;
			bool flag = NavMesh.FindClosestEdge(sourcePosition.Value, out navMeshHit, passableMask.Value);
			nearestEdgeFound.Value = flag;
			position.Value = navMeshHit.position;
			normal.Value = navMeshHit.normal;
			distance.Value = navMeshHit.distance;
			mask.Value = navMeshHit.mask;
			hit.Value = navMeshHit.hit;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(nearestEdgeFoundEvent))
				{
					base.Fsm.Event(nearestEdgeFoundEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(nearestEdgeNotFoundEvent))
			{
				base.Fsm.Event(nearestEdgeNotFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Gets the cost for path finding over geometry of the area type.\nThe value applies to all agents unless you the value has been customized per agent by calling NavMeshAgentSetAreaCost.")]
	public class NavMeshGetAreaCost : FsmStateAction
	{
		[ActionSection("Set up")]
		[Tooltip("The Area index.")]
		public FsmInt area;

		[Tooltip("OR the layer name.")]
		public FsmString orAreaName;

		[ActionSection("Result")]
		[Tooltip("Store the Layer Cost")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		private NavMeshAgent _agent;

		public override void Reset()
		{
			area = null;
			orAreaName = new FsmString
			{
				UseVariable = true
			};
			storeResult = null;
		}

		public override void OnEnter()
		{
			DoGetAreaCost();
			Finish();
		}

		private void DoGetAreaCost()
		{
			int areaIndex = area.Value;
			if (orAreaName.Value != "")
			{
				areaIndex = NavMesh.GetAreaFromName(orAreaName.Value);
			}
			storeResult.Value = NavMesh.GetAreaCost(areaIndex);
		}

		public override string ErrorCheck()
		{
			if (orAreaName.Value != "")
			{
				int areaFromName = NavMesh.GetAreaFromName(orAreaName.Value);
				if (areaFromName == -1)
				{
					return "Layer Name '" + orAreaName.Value + "' doesn't exists";
				}
				if (area.Value != 0)
				{
					if (areaFromName == area.Value)
					{
						return "Area reference redundancy. Use 'Area' OR 'Area Name', not both at the same time..";
					}
					return "Area conflict, area name '" + orAreaName.Value + "' will be used";
				}
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Gets the area index for a named area.")]
	public class NavMeshGetLayerFromName : FsmStateAction
	{
		[Tooltip("The area Name")]
		public FsmString areaName;

		[ActionSection("Result")]
		[Tooltip("Store the area Index for this area Name")]
		[UIHint(UIHint.Variable)]
		public FsmInt areaIndex;

		public override void Reset()
		{
			areaName = null;
			areaIndex = null;
		}

		public override void OnEnter()
		{
			DoGetAreaFromName();
			Finish();
		}

		private void DoGetAreaFromName()
		{
			areaIndex.Value = NavMesh.GetAreaFromName(areaName.Value);
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Trace a ray between two points on the NavMesh. \nYou can dispatch events If terminated before reaching the target position or not. \nYou can then store information about the location (navMeshHit). \nNOTE: The Game Object must have a NavMeshAgent component attached.")]
	public class NavMeshRaycast : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The origin of the ray.")]
		public FsmVector3 sourcePosition;

		[RequiredField]
		[Tooltip("The end of the ray.")]
		public FsmVector3 targetPosition;

		[RequiredField]
		[Tooltip("The mask specifying which NavMesh layers can be passed when tracing the ray.")]
		public FsmInt passableMask;

		[ActionSection("Result")]
		[Tooltip("true If terminated before reaching target position.")]
		[UIHint(UIHint.Variable)]
		public FsmBool reachedBeforeTargetPosition;

		[Tooltip("Trigger event if sample reached before the target position.")]
		public FsmEvent reachedBeforeTargetPositionEvent;

		[Tooltip("Trigger event if sample reached after the target position.")]
		public FsmEvent reachedAfterTargetPositionEvent;

		[ActionSection("Hit information of the sample")]
		[Tooltip("Position of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 position;

		[Tooltip("Normal at the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 normal;

		[Tooltip("Distance to the point of hit")]
		[UIHint(UIHint.Variable)]
		public FsmFloat distance;

		[Tooltip("Mask specifying NavMeshLayers at point of hit.")]
		[UIHint(UIHint.Variable)]
		public FsmInt mask;

		[Tooltip("Flag when hit")]
		[UIHint(UIHint.Variable)]
		public FsmBool hit;

		public override void Reset()
		{
			sourcePosition = null;
			targetPosition = null;
			passableMask = -1;
			reachedBeforeTargetPosition = null;
			reachedBeforeTargetPositionEvent = null;
			reachedAfterTargetPositionEvent = null;
			position = null;
			normal = null;
			distance = null;
			mask = null;
			hit = null;
		}

		public override void OnEnter()
		{
			DoRaycast();
			Finish();
		}

		private void DoRaycast()
		{
			NavMeshHit navMeshHit;
			bool flag = NavMesh.Raycast(sourcePosition.Value, targetPosition.Value, out navMeshHit, passableMask.Value);
			reachedBeforeTargetPosition.Value = flag;
			position.Value = navMeshHit.position;
			normal.Value = navMeshHit.normal;
			distance.Value = navMeshHit.distance;
			mask.Value = navMeshHit.mask;
			hit.Value = navMeshHit.hit;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(reachedBeforeTargetPositionEvent))
				{
					base.Fsm.Event(reachedBeforeTargetPositionEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(reachedAfterTargetPositionEvent))
			{
				base.Fsm.Event(reachedAfterTargetPositionEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Sample the NavMesh closest to the point specified. \nYou can dispatch events If terminated before reaching the target position or not. \nYou can then store information about the location (navMeshHit).")]
	public class NavMeshSamplePosition : FsmStateAction
	{
		[ActionSection("Set up")]
		[RequiredField]
		[Tooltip("The origin of the sample query.")]
		public FsmVector3 sourcePosition;

		[RequiredField]
		[Tooltip("The mask specifying which NavMesh layer is allowed when finding the nearest point.")]
		public FsmInt allowedMask;

		[Tooltip("Sample within this distance from sourcePosition.")]
		public FsmFloat maxDistance;

		[ActionSection("Result")]
		[Tooltip("True if a nearest point is found.")]
		public FsmBool nearestPointFound;

		[Tooltip("Trigger event if a nearest point is found.")]
		public FsmEvent nearestPointFoundEvent;

		[Tooltip("Trigger event if a nearest point is not found.")]
		public FsmEvent nearestPointNotFoundEvent;

		[ActionSection("Hit information of the sample")]
		[Tooltip("Position of hit")]
		public FsmVector3 position;

		[Tooltip("Normal at the point of hit")]
		public FsmVector3 normal;

		[Tooltip("Distance to the point of hit")]
		public FsmFloat distance;

		[Tooltip("Mask specifying NavMeshLayers at point of hit.")]
		public FsmInt mask;

		[Tooltip("Flag when hit")]
		public FsmBool hit;

		public override void Reset()
		{
			sourcePosition = new FsmVector3
			{
				UseVariable = true
			};
			allowedMask = new FsmInt
			{
				Value = -1
			};
			maxDistance = new FsmFloat();
			maxDistance.Value = 10f;
			nearestPointFound = new FsmBool
			{
				UseVariable = true
			};
			nearestPointFoundEvent = null;
			nearestPointNotFoundEvent = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			normal = new FsmVector3
			{
				UseVariable = true
			};
			distance = new FsmFloat
			{
				UseVariable = true
			};
			mask = new FsmInt
			{
				UseVariable = true
			};
			hit = new FsmBool
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			DoSamplePosition();
			Finish();
		}

		private void DoSamplePosition()
		{
			NavMeshHit navMeshHit;
			bool flag = NavMesh.SamplePosition(sourcePosition.Value, out navMeshHit, maxDistance.Value, allowedMask.Value);
			nearestPointFound.Value = flag;
			position.Value = navMeshHit.position;
			normal.Value = navMeshHit.normal;
			distance.Value = navMeshHit.distance;
			mask.Value = navMeshHit.mask;
			hit.Value = navMeshHit.hit;
			if (flag)
			{
				if (!FsmEvent.IsNullOrEmpty(nearestPointFoundEvent))
				{
					base.Fsm.Event(nearestPointFoundEvent);
				}
			}
			else if (!FsmEvent.IsNullOrEmpty(nearestPointNotFoundEvent))
			{
				base.Fsm.Event(nearestPointNotFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Sets the cost for finding path over geometry of the area type on all agents.\nThis will replace any custom area costs on all agents, and set the default cost for new agents that are created after calling the function. The cost must be larger than 1.0.")]
	public class NavMeshSetLayerCost : FsmStateAction
	{
		[Tooltip("The area index.")]
		public FsmInt area;

		[Tooltip("OR The area name.")]
		public FsmString orAreaName;

		[Tooltip("The Layer Cost")]
		public FsmFloat cost;

		public override void Reset()
		{
			area = null;
			orAreaName = new FsmString
			{
				UseVariable = true
			};
			cost = null;
		}

		public override void OnEnter()
		{
			DoSetAreaCost();
			Finish();
		}

		private void DoSetAreaCost()
		{
			int areaIndex = area.Value;
			if (orAreaName.Value != "")
			{
				areaIndex = NavMesh.GetAreaFromName(orAreaName.Value);
			}
			NavMesh.SetAreaCost(areaIndex, cost.Value);
		}

		public override string ErrorCheck()
		{
			if (orAreaName.Value != "")
			{
				int areaFromName = NavMesh.GetAreaFromName(orAreaName.Value);
				if (areaFromName == -1)
				{
					return "Area Name '" + orAreaName.Value + "' doesn't exists";
				}
				if (area.Value != 0)
				{
					if (areaFromName == area.Value)
					{
						return "Area reference redundancy. Use 'Area' OR 'Area Name', not both at the same time.";
					}
					return "Area conflict, area name '" + orAreaName.Value + "' will be used";
				}
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Gets the active state of an OffMeshLink. \nNOTE: The Game Object must have an OffMeshLink component attached.")]
	public class GetOffMeshLinkActivated : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have an OffMeshLink component attached.")]
		[CheckForComponent(typeof(OffMeshLink))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the offLinkMesh active state")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Runs every frame.")]
		public bool everyFrame;

		private OffMeshLink _offMeshLink;

		private void _getOffMeshLink()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_offMeshLink = ownerDefaultTarget.GetComponent<OffMeshLink>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getOffMeshLink();
			DoGetActivated();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetActivated();
		}

		private void DoGetActivated()
		{
			if (storeResult != null && !(_offMeshLink == null))
			{
				storeResult.Value = _offMeshLink.activated;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Gets the flag of the bi directional state of an OffMeshLink. \nNOTE: The Game Object must have an OffMeshLink component attached.")]
	public class GetOffMeshLinkBiDirectional : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have an OffMeshLink component attached.")]
		[CheckForComponent(typeof(OffMeshLink))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the offLinkMesh bi directional state")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private OffMeshLink _offMeshLink;

		private void _getOffMeshLink()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_offMeshLink = ownerDefaultTarget.GetComponent<OffMeshLink>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getOffMeshLink();
			DoGetBiDirectional();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetBiDirectional();
		}

		private void DoGetBiDirectional()
		{
			if (storeResult != null && !(_offMeshLink == null))
			{
				storeResult.Value = _offMeshLink.biDirectional;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Gets the cost override state of an OffMeshLink. \nNOTE: The Game Object must have an OffMeshLink component attached.")]
	public class GetOffMeshCostOverride : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have an OffMeshLink component attached.")]
		[CheckForComponent(typeof(OffMeshLink))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store the offLinkMesh cost override")]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		[Tooltip("Runs every frame.")]
		public bool everyFrame;

		private OffMeshLink _offMeshLink;

		private void _getOffMeshLink()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_offMeshLink = ownerDefaultTarget.GetComponent<OffMeshLink>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getOffMeshLink();
			DoGetCostOverride();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetCostOverride();
		}

		private void DoGetCostOverride()
		{
			if (storeResult != null)
			{
				_ = _offMeshLink == null;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Gets the occupied state of an OffMeshLink. \nNOTE: The Game Object must have an OffMeshLink component attached.")]
	public class GetOffMeshLinkOccupied : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have an OffMeshLink component attached.")]
		[CheckForComponent(typeof(OffMeshLink))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store flag of the offLinkMesh occupied state")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private OffMeshLink _offMeshLink;

		private void _getOffMeshLink()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_offMeshLink = ownerDefaultTarget.GetComponent<OffMeshLink>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getOffMeshLink();
			DoGetOccupied();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetOccupied();
		}

		private void DoGetOccupied()
		{
			if (storeResult != null && !(_offMeshLink == null))
			{
				storeResult.Value = _offMeshLink.occupied;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("True if the OffMeshLink component will try to match endpoint transforms specified by startTransform and endTransform . See also UpdatePositions. \nNOTE: The Game Object must have an OffMeshLink component attached.")]
	public class GetOffMeshLinkAutoUpdatePositions : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have an OffMeshLink component attached.")]
		[CheckForComponent(typeof(OffMeshLink))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("True if the OffMeshLink component will try to match endpoint transforms specified by startTransform and endTransform")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Runs every frame.")]
		public bool everyFrame;

		private OffMeshLink _offMeshLink;

		private void _getOffMeshLink()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_offMeshLink = ownerDefaultTarget.GetComponent<OffMeshLink>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getOffMeshLink();
			DoGetAutoUpdatePositions();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetAutoUpdatePositions();
		}

		private void DoGetAutoUpdatePositions()
		{
			if (storeResult != null && !(_offMeshLink == null))
			{
				storeResult.Value = _offMeshLink.autoUpdatePositions;
			}
		}
	}
	[ActionCategory(ActionCategory.NavMesh)]
	[Tooltip("Gets the area for this OffMeshLink component. \nNOTE: The Game Object must have an OffMeshLink component attached.")]
	public class GetOffMeshLinkNavMeshArea : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to work with. NOTE: The Game Object must have an OffMeshLink component attached.")]
		[CheckForComponent(typeof(OffMeshLink))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Store the area for this OffMeshLink component")]
		[UIHint(UIHint.Variable)]
		public FsmInt storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private OffMeshLink _offMeshLink;

		private void _getOffMeshLink()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				_offMeshLink = ownerDefaultTarget.GetComponent<OffMeshLink>();
			}
		}

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			_getOffMeshLink();
			DoGetArea();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetArea();
		}

		private void DoGetArea()
		{
			if (storeResult != null && !(_offMeshLink == null))
			{
				storeResult.Value = _offMeshLink.area;
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets properties on the last event that caused a state change. Use Set Event Properties to define these values when sending events")]
	public class GetEventProperties : FsmStateAction
	{
		[CompoundArray("Event Properties", "Key", "Data")]
		public FsmString[] keys;

		[UIHint(UIHint.Variable)]
		public FsmVar[] datas;

		public override void Reset()
		{
			keys = new FsmString[1];
			datas = new FsmVar[1];
		}

		public override void OnEnter()
		{
			try
			{
				if (SetEventProperties.properties == null)
				{
					throw new ArgumentException("no properties");
				}
				for (int i = 0; i < keys.Length; i++)
				{
					if (SetEventProperties.properties.ContainsKey(keys[i].Value))
					{
						PlayMakerUtils.ApplyValueToFsmVar(base.Fsm, datas[i], SetEventProperties.properties[keys[i].Value]);
					}
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.Log("no properties found " + ex);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sets Event Data before sending an event. Get the Event Data, Get Event Properties action.")]
	public class SetEventProperties : FsmStateAction
	{
		[CompoundArray("Event Properties", "Key", "Data")]
		public FsmString[] keys;

		public FsmVar[] datas;

		public static Dictionary<string, object> properties = new Dictionary<string, object>();

		public override void Reset()
		{
			keys = new FsmString[1];
			datas = new FsmVar[1];
		}

		public override void OnEnter()
		{
			properties = new Dictionary<string, object>();
			for (int i = 0; i < keys.Length; i++)
			{
				properties[keys[i].Value] = PlayMakerUtils.GetValueFromFsmVar(base.Fsm, datas[i]);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Animates the value of a Color Variable using an Animation Curve.")]
	public class AnimateColor : AnimateFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmColor colorVariable;

		[RequiredField]
		public FsmAnimationCurve curveR;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to colorVariable.r.")]
		public Calculation calculationR;

		[RequiredField]
		public FsmAnimationCurve curveG;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to colorVariable.g.")]
		public Calculation calculationG;

		[RequiredField]
		public FsmAnimationCurve curveB;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to colorVariable.b.")]
		public Calculation calculationB;

		[RequiredField]
		public FsmAnimationCurve curveA;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to colorVariable.a.")]
		public Calculation calculationA;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			colorVariable = new FsmColor
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[4];
			fromFloats = new float[4];
			fromFloats[0] = (colorVariable.IsNone ? 0f : colorVariable.Value.r);
			fromFloats[1] = (colorVariable.IsNone ? 0f : colorVariable.Value.g);
			fromFloats[2] = (colorVariable.IsNone ? 0f : colorVariable.Value.b);
			fromFloats[3] = (colorVariable.IsNone ? 0f : colorVariable.Value.a);
			curves = new AnimationCurve[4];
			curves[0] = curveR.curve;
			curves[1] = curveG.curve;
			curves[2] = curveB.curve;
			curves[3] = curveA.curve;
			calculations = new Calculation[4];
			calculations[0] = calculationR;
			calculations[1] = calculationG;
			calculations[2] = calculationB;
			calculations[3] = calculationA;
			Init();
			if (Math.Abs(delay.Value) < 0.01f)
			{
				UpdateVariableValue();
			}
		}

		private void UpdateVariableValue()
		{
			if (!colorVariable.IsNone)
			{
				colorVariable.Value = new Color(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
			}
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (isRunning)
			{
				UpdateVariableValue();
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				base.Fsm.Event(finishEvent);
			}
			if (finishAction && !finishInNextStep)
			{
				UpdateVariableValue();
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Animates the value of a Float Variable using an Animation Curve.")]
	public class AnimateFloat : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The animation curve to use.")]
		public FsmAnimationCurve animCurve;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variable to set.")]
		public FsmFloat floatVariable;

		[Tooltip("Optionally send an Event when the animation finishes.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		private float endTime;

		private bool looping;

		public override void Reset()
		{
			animCurve = null;
			floatVariable = null;
			finishEvent = null;
			realTime = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			if (animCurve != null && animCurve.curve != null && animCurve.curve.keys.Length != 0)
			{
				endTime = animCurve.curve.keys[animCurve.curve.length - 1].time;
				looping = ActionHelpers.IsLoopingWrapMode(animCurve.curve.postWrapMode);
				floatVariable.Value = animCurve.curve.Evaluate(0f);
			}
			else
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			if (animCurve != null && animCurve.curve != null && floatVariable != null)
			{
				floatVariable.Value = animCurve.curve.Evaluate(currentTime);
			}
			if (currentTime >= endTime)
			{
				if (!looping)
				{
					Finish();
				}
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Animates the value of a Float Variable using an Animation Curve.")]
	public class AnimateFloatV2 : AnimateFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		[RequiredField]
		public FsmAnimationCurve animCurve;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to floatVariable")]
		public Calculation calculation;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			floatVariable = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[1];
			fromFloats = new float[1];
			fromFloats[0] = (floatVariable.IsNone ? 0f : floatVariable.Value);
			calculations = new Calculation[1];
			calculations[0] = calculation;
			curves = new AnimationCurve[1];
			curves[0] = animCurve.curve;
			Init();
		}

		public override void OnExit()
		{
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!floatVariable.IsNone && isRunning)
			{
				floatVariable.Value = resultFloats[0];
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!floatVariable.IsNone)
				{
					floatVariable.Value = resultFloats[0];
				}
				finishInNextStep = true;
			}
		}
	}
	public abstract class AnimateFsmAction : FsmStateAction
	{
		public enum Calculation
		{
			None,
			SetValue,
			AddToValue,
			SubtractFromValue,
			SubtractValueFromCurve,
			MultiplyValue,
			DivideValue,
			DivideCurveByValue
		}

		[Tooltip("Define animation time,\u00a0scaling the curve to fit.")]
		public FsmFloat time;

		[Tooltip("If you define speed, your animation will speed up or slow down.")]
		public FsmFloat speed;

		[Tooltip("Delayed animation start.")]
		public FsmFloat delay;

		[Tooltip("Animation curve start from any time. If IgnoreCurveOffset is true the animation starts right after the state become entered.")]
		public FsmBool ignoreCurveOffset;

		[Tooltip("Optionally send an Event when the animation finishes.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		private float[] endTimes;

		private float lastTime;

		private float deltaTime;

		private float delayTime;

		private float[] keyOffsets;

		protected AnimationCurve[] curves;

		protected Calculation[] calculations;

		protected float[] resultFloats;

		protected float[] fromFloats;

		protected float[] toFloats;

		protected bool finishAction;

		protected bool isRunning;

		protected bool looping;

		private bool start;

		private float largestEndTime;

		public override void Reset()
		{
			finishEvent = null;
			realTime = false;
			time = new FsmFloat
			{
				UseVariable = true
			};
			speed = new FsmFloat
			{
				UseVariable = true
			};
			delay = new FsmFloat
			{
				UseVariable = true
			};
			ignoreCurveOffset = new FsmBool
			{
				Value = true
			};
			resultFloats = new float[0];
			fromFloats = new float[0];
			toFloats = new float[0];
			endTimes = new float[0];
			keyOffsets = new float[0];
			curves = new AnimationCurve[0];
			finishAction = false;
			start = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			lastTime = FsmTime.RealtimeSinceStartup - startTime;
			deltaTime = 0f;
			currentTime = 0f;
			isRunning = false;
			finishAction = false;
			looping = false;
			delayTime = (delay.IsNone ? 0f : (delayTime = delay.Value));
			start = true;
		}

		protected void Init()
		{
			endTimes = new float[curves.Length];
			keyOffsets = new float[curves.Length];
			largestEndTime = 0f;
			for (int i = 0; i < curves.Length; i++)
			{
				if (curves[i] != null && curves[i].keys.Length != 0)
				{
					keyOffsets[i] = ((curves[i].keys.Length == 0) ? 0f : (time.IsNone ? curves[i].keys[0].time : (time.Value / curves[i].keys[curves[i].length - 1].time * curves[i].keys[0].time)));
					currentTime = (ignoreCurveOffset.IsNone ? 0f : (ignoreCurveOffset.Value ? keyOffsets[i] : 0f));
					if (!time.IsNone)
					{
						endTimes[i] = time.Value;
					}
					else
					{
						endTimes[i] = curves[i].keys[curves[i].length - 1].time;
					}
					if (largestEndTime < endTimes[i])
					{
						largestEndTime = endTimes[i];
					}
					if (!looping)
					{
						looping = ActionHelpers.IsLoopingWrapMode(curves[i].postWrapMode);
					}
				}
				else
				{
					endTimes[i] = -1f;
				}
			}
			for (int j = 0; j < curves.Length; j++)
			{
				if (largestEndTime > 0f && endTimes[j] == -1f)
				{
					endTimes[j] = largestEndTime;
				}
				else if (largestEndTime == 0f && endTimes[j] == -1f)
				{
					if (time.IsNone)
					{
						endTimes[j] = 1f;
					}
					else
					{
						endTimes[j] = time.Value;
					}
				}
			}
			UpdateAnimation();
		}

		public override void OnUpdate()
		{
			CheckStart();
			if (isRunning)
			{
				UpdateTime();
				UpdateAnimation();
				CheckFinished();
			}
		}

		private void CheckStart()
		{
			if (isRunning || !start)
			{
				return;
			}
			if (delayTime >= 0f)
			{
				if (realTime)
				{
					deltaTime = FsmTime.RealtimeSinceStartup - startTime - lastTime;
					lastTime = FsmTime.RealtimeSinceStartup - startTime;
					delayTime -= deltaTime;
				}
				else
				{
					delayTime -= Time.deltaTime;
				}
			}
			else
			{
				isRunning = true;
				start = false;
			}
		}

		private void UpdateTime()
		{
			if (realTime)
			{
				deltaTime = FsmTime.RealtimeSinceStartup - startTime - lastTime;
				lastTime = FsmTime.RealtimeSinceStartup - startTime;
				if (!speed.IsNone)
				{
					currentTime += deltaTime * speed.Value;
				}
				else
				{
					currentTime += deltaTime;
				}
			}
			else if (!speed.IsNone)
			{
				currentTime += Time.deltaTime * speed.Value;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
		}

		public void UpdateAnimation()
		{
			for (int i = 0; i < curves.Length; i++)
			{
				if (curves[i] != null && curves[i].keys.Length != 0)
				{
					if (calculations[i] != 0)
					{
						switch (calculations[i])
						{
						case Calculation.SetValue:
							if (!time.IsNone)
							{
								resultFloats[i] = curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time);
							}
							else
							{
								resultFloats[i] = curves[i].Evaluate(currentTime);
							}
							break;
						case Calculation.AddToValue:
							if (!time.IsNone)
							{
								resultFloats[i] = fromFloats[i] + curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time);
							}
							else
							{
								resultFloats[i] = fromFloats[i] + curves[i].Evaluate(currentTime);
							}
							break;
						case Calculation.SubtractFromValue:
							if (!time.IsNone)
							{
								resultFloats[i] = fromFloats[i] - curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time);
							}
							else
							{
								resultFloats[i] = fromFloats[i] - curves[i].Evaluate(currentTime);
							}
							break;
						case Calculation.SubtractValueFromCurve:
							if (!time.IsNone)
							{
								resultFloats[i] = curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) - fromFloats[i];
							}
							else
							{
								resultFloats[i] = curves[i].Evaluate(currentTime) - fromFloats[i];
							}
							break;
						case Calculation.MultiplyValue:
							if (!time.IsNone)
							{
								resultFloats[i] = curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) * fromFloats[i];
							}
							else
							{
								resultFloats[i] = curves[i].Evaluate(currentTime) * fromFloats[i];
							}
							break;
						case Calculation.DivideValue:
							if (!time.IsNone)
							{
								resultFloats[i] = ((curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) != 0f) ? (fromFloats[i] / curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time)) : float.MaxValue);
							}
							else
							{
								resultFloats[i] = ((curves[i].Evaluate(currentTime) != 0f) ? (fromFloats[i] / curves[i].Evaluate(currentTime)) : float.MaxValue);
							}
							break;
						case Calculation.DivideCurveByValue:
							if (!time.IsNone)
							{
								resultFloats[i] = ((fromFloats[i] != 0f) ? (curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) / fromFloats[i]) : float.MaxValue);
							}
							else
							{
								resultFloats[i] = ((fromFloats[i] != 0f) ? (curves[i].Evaluate(currentTime) / fromFloats[i]) : float.MaxValue);
							}
							break;
						}
					}
					else
					{
						resultFloats[i] = fromFloats[i];
					}
				}
				else
				{
					resultFloats[i] = fromFloats[i];
				}
			}
		}

		private void CheckFinished()
		{
			if (!isRunning || looping)
			{
				return;
			}
			finishAction = true;
			for (int i = 0; i < endTimes.Length; i++)
			{
				if (currentTime < endTimes[i])
				{
					finishAction = false;
				}
			}
			isRunning = !finishAction;
		}
	}
	[ActionCategory("AnimateVariables")]
	[Tooltip("Animates the value of a Rect Variable using an Animation Curve.")]
	public class AnimateRect : AnimateFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmRect rectVariable;

		[RequiredField]
		public FsmAnimationCurve curveX;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to rectVariable.x.")]
		public Calculation calculationX;

		[RequiredField]
		public FsmAnimationCurve curveY;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to rectVariable.y.")]
		public Calculation calculationY;

		[RequiredField]
		public FsmAnimationCurve curveW;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to rectVariable.width.")]
		public Calculation calculationW;

		[RequiredField]
		public FsmAnimationCurve curveH;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to rectVariable.height.")]
		public Calculation calculationH;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			rectVariable = new FsmRect
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[4];
			fromFloats = new float[4];
			fromFloats[0] = (rectVariable.IsNone ? 0f : rectVariable.Value.x);
			fromFloats[1] = (rectVariable.IsNone ? 0f : rectVariable.Value.y);
			fromFloats[2] = (rectVariable.IsNone ? 0f : rectVariable.Value.width);
			fromFloats[3] = (rectVariable.IsNone ? 0f : rectVariable.Value.height);
			curves = new AnimationCurve[4];
			curves[0] = curveX.curve;
			curves[1] = curveY.curve;
			curves[2] = curveW.curve;
			curves[3] = curveH.curve;
			calculations = new Calculation[4];
			calculations[0] = calculationX;
			calculations[1] = calculationY;
			calculations[2] = calculationW;
			calculations[3] = calculationH;
			Init();
			if (Math.Abs(delay.Value) < 0.01f)
			{
				UpdateVariableValue();
			}
		}

		private void UpdateVariableValue()
		{
			if (!rectVariable.IsNone)
			{
				rectVariable.Value = new Rect(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
			}
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (isRunning)
			{
				UpdateVariableValue();
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				base.Fsm.Event(finishEvent);
			}
			if (finishAction && !finishInNextStep)
			{
				UpdateVariableValue();
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Animates the value of a Vector3 Variable using an Animation Curve.")]
	public class AnimateVector3 : AnimateFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vectorVariable;

		[RequiredField]
		public FsmAnimationCurve curveX;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to vectorVariable.x.")]
		public Calculation calculationX;

		[RequiredField]
		public FsmAnimationCurve curveY;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to vectorVariable.y.")]
		public Calculation calculationY;

		[RequiredField]
		public FsmAnimationCurve curveZ;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to vectorVariable.z.")]
		public Calculation calculationZ;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			vectorVariable = new FsmVector3
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[3];
			fromFloats = new float[3];
			fromFloats[0] = (vectorVariable.IsNone ? 0f : vectorVariable.Value.x);
			fromFloats[1] = (vectorVariable.IsNone ? 0f : vectorVariable.Value.y);
			fromFloats[2] = (vectorVariable.IsNone ? 0f : vectorVariable.Value.z);
			curves = new AnimationCurve[3];
			curves[0] = curveX.curve;
			curves[1] = curveY.curve;
			curves[2] = curveZ.curve;
			calculations = new Calculation[3];
			calculations[0] = calculationX;
			calculations[1] = calculationY;
			calculations[2] = calculationZ;
			Init();
			if (Math.Abs(delay.Value) < 0.01f)
			{
				UpdateVariableValue();
			}
		}

		private void UpdateVariableValue()
		{
			if (!vectorVariable.IsNone)
			{
				vectorVariable.Value = new Vector3(resultFloats[0], resultFloats[1], resultFloats[2]);
			}
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (isRunning)
			{
				UpdateVariableValue();
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				base.Fsm.Event(finishEvent);
			}
			if (finishAction && !finishInNextStep)
			{
				UpdateVariableValue();
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Animates the value of a Color Variable FROM-TO with assistance of Deformation Curves.")]
	public class CurveColor : CurveFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmColor colorVariable;

		[RequiredField]
		public FsmColor fromValue;

		[RequiredField]
		public FsmColor toValue;

		[RequiredField]
		public FsmAnimationCurve curveR;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.Red and toValue.Rec.")]
		public Calculation calculationR;

		[RequiredField]
		public FsmAnimationCurve curveG;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.Green and toValue.Green.")]
		public Calculation calculationG;

		[RequiredField]
		public FsmAnimationCurve curveB;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.Blue and toValue.Blue.")]
		public Calculation calculationB;

		[RequiredField]
		public FsmAnimationCurve curveA;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.Alpha and toValue.Alpha.")]
		public Calculation calculationA;

		private Color clr;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			colorVariable = new FsmColor
			{
				UseVariable = true
			};
			toValue = new FsmColor
			{
				UseVariable = true
			};
			fromValue = new FsmColor
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[4];
			fromFloats = new float[4];
			fromFloats[0] = (fromValue.IsNone ? 0f : fromValue.Value.r);
			fromFloats[1] = (fromValue.IsNone ? 0f : fromValue.Value.g);
			fromFloats[2] = (fromValue.IsNone ? 0f : fromValue.Value.b);
			fromFloats[3] = (fromValue.IsNone ? 0f : fromValue.Value.a);
			toFloats = new float[4];
			toFloats[0] = (toValue.IsNone ? 0f : toValue.Value.r);
			toFloats[1] = (toValue.IsNone ? 0f : toValue.Value.g);
			toFloats[2] = (toValue.IsNone ? 0f : toValue.Value.b);
			toFloats[3] = (toValue.IsNone ? 0f : toValue.Value.a);
			curves = new AnimationCurve[4];
			curves[0] = curveR.curve;
			curves[1] = curveG.curve;
			curves[2] = curveB.curve;
			curves[3] = curveA.curve;
			calculations = new Calculation[4];
			calculations[0] = calculationR;
			calculations[1] = calculationG;
			calculations[2] = calculationB;
			calculations[3] = calculationA;
			Init();
		}

		public override void OnExit()
		{
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!colorVariable.IsNone && isRunning)
			{
				clr = new Color(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
				colorVariable.Value = clr;
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!colorVariable.IsNone)
				{
					clr = new Color(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
					colorVariable.Value = clr;
				}
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Animates the value of a Float Variable FROM-TO with assistance of Deformation Curve.")]
	public class CurveFloat : CurveFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		[RequiredField]
		public FsmFloat fromValue;

		[RequiredField]
		public FsmFloat toValue;

		[RequiredField]
		public FsmAnimationCurve animCurve;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue and toValue.")]
		public Calculation calculation;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			floatVariable = new FsmFloat
			{
				UseVariable = true
			};
			toValue = new FsmFloat
			{
				UseVariable = true
			};
			fromValue = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[1];
			fromFloats = new float[1];
			fromFloats[0] = (fromValue.IsNone ? 0f : fromValue.Value);
			toFloats = new float[1];
			toFloats[0] = (toValue.IsNone ? 0f : toValue.Value);
			calculations = new Calculation[1];
			calculations[0] = calculation;
			curves = new AnimationCurve[1];
			curves[0] = animCurve.curve;
			Init();
		}

		public override void OnExit()
		{
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!floatVariable.IsNone && isRunning)
			{
				floatVariable.Value = resultFloats[0];
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!floatVariable.IsNone)
				{
					floatVariable.Value = resultFloats[0];
				}
				finishInNextStep = true;
			}
		}
	}
	[Tooltip("Animate base action - DON'T USE IT!")]
	public abstract class CurveFsmAction : FsmStateAction
	{
		public enum Calculation
		{
			None,
			AddToValue,
			SubtractFromValue,
			SubtractValueFromCurve,
			MultiplyValue,
			DivideValue,
			DivideCurveByValue
		}

		[Tooltip("Define animation time, scaling the curve to fit.")]
		public FsmFloat time;

		[Tooltip("If you define speed, your animation will speed up or slow down.")]
		public FsmFloat speed;

		[Tooltip("Delayed animation start.")]
		public FsmFloat delay;

		[Tooltip("Animation curve start from any time. If IgnoreCurveOffset is true the animation starts right after the state become entered.")]
		public FsmBool ignoreCurveOffset;

		[Tooltip("Optionally send an Event when the animation finishes.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		private float[] endTimes;

		private float lastTime;

		private float deltaTime;

		private float delayTime;

		private float[] keyOffsets;

		protected AnimationCurve[] curves;

		protected Calculation[] calculations;

		protected float[] resultFloats;

		protected float[] fromFloats;

		protected float[] toFloats;

		private float[] distances;

		protected bool finishAction;

		protected bool isRunning;

		protected bool looping;

		private bool start;

		private float largestEndTime;

		public override void Reset()
		{
			finishEvent = null;
			realTime = false;
			time = new FsmFloat
			{
				UseVariable = true
			};
			speed = new FsmFloat
			{
				UseVariable = true
			};
			delay = new FsmFloat
			{
				UseVariable = true
			};
			ignoreCurveOffset = new FsmBool
			{
				Value = true
			};
			resultFloats = new float[0];
			fromFloats = new float[0];
			toFloats = new float[0];
			distances = new float[0];
			endTimes = new float[0];
			keyOffsets = new float[0];
			curves = new AnimationCurve[0];
			finishAction = false;
			start = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			lastTime = FsmTime.RealtimeSinceStartup - startTime;
			deltaTime = 0f;
			currentTime = 0f;
			isRunning = false;
			finishAction = false;
			looping = false;
			delayTime = (delay.IsNone ? 0f : (delayTime = delay.Value));
			start = true;
		}

		protected void Init()
		{
			endTimes = new float[curves.Length];
			keyOffsets = new float[curves.Length];
			largestEndTime = 0f;
			for (int i = 0; i < curves.Length; i++)
			{
				if (curves[i] != null && curves[i].keys.Length != 0)
				{
					keyOffsets[i] = ((curves[i].keys.Length == 0) ? 0f : (time.IsNone ? curves[i].keys[0].time : (time.Value / curves[i].keys[curves[i].length - 1].time * curves[i].keys[0].time)));
					currentTime = (ignoreCurveOffset.IsNone ? 0f : (ignoreCurveOffset.Value ? keyOffsets[i] : 0f));
					if (!time.IsNone)
					{
						endTimes[i] = time.Value;
					}
					else
					{
						endTimes[i] = curves[i].keys[curves[i].length - 1].time;
					}
					if (largestEndTime < endTimes[i])
					{
						largestEndTime = endTimes[i];
					}
					if (!looping)
					{
						looping = ActionHelpers.IsLoopingWrapMode(curves[i].postWrapMode);
					}
				}
				else
				{
					endTimes[i] = -1f;
				}
			}
			for (int j = 0; j < curves.Length; j++)
			{
				if (largestEndTime > 0f && endTimes[j] == -1f)
				{
					endTimes[j] = largestEndTime;
				}
				else if (largestEndTime == 0f && endTimes[j] == -1f)
				{
					if (time.IsNone)
					{
						endTimes[j] = 1f;
					}
					else
					{
						endTimes[j] = time.Value;
					}
				}
			}
			distances = new float[fromFloats.Length];
			for (int k = 0; k < fromFloats.Length; k++)
			{
				distances[k] = toFloats[k] - fromFloats[k];
			}
		}

		public override void OnUpdate()
		{
			if (!isRunning && start)
			{
				if (delayTime >= 0f)
				{
					if (realTime)
					{
						deltaTime = FsmTime.RealtimeSinceStartup - startTime - lastTime;
						lastTime = FsmTime.RealtimeSinceStartup - startTime;
						delayTime -= deltaTime;
					}
					else
					{
						delayTime -= Time.deltaTime;
					}
				}
				else
				{
					isRunning = true;
					start = false;
					startTime = FsmTime.RealtimeSinceStartup;
					lastTime = FsmTime.RealtimeSinceStartup - startTime;
				}
			}
			if (!isRunning || finishAction)
			{
				return;
			}
			if (realTime)
			{
				deltaTime = FsmTime.RealtimeSinceStartup - startTime - lastTime;
				lastTime = FsmTime.RealtimeSinceStartup - startTime;
				if (!speed.IsNone)
				{
					currentTime += deltaTime * speed.Value;
				}
				else
				{
					currentTime += deltaTime;
				}
			}
			else if (!speed.IsNone)
			{
				currentTime += Time.deltaTime * speed.Value;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			for (int i = 0; i < curves.Length; i++)
			{
				if (curves[i] != null && curves[i].keys.Length != 0)
				{
					if (calculations[i] != 0)
					{
						switch (calculations[i])
						{
						case Calculation.AddToValue:
							if (!time.IsNone)
							{
								resultFloats[i] = fromFloats[i] + (distances[i] * (currentTime / time.Value) + curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time));
							}
							else
							{
								resultFloats[i] = fromFloats[i] + (distances[i] * (currentTime / endTimes[i]) + curves[i].Evaluate(currentTime));
							}
							break;
						case Calculation.SubtractFromValue:
							if (!time.IsNone)
							{
								resultFloats[i] = fromFloats[i] + (distances[i] * (currentTime / time.Value) - curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time));
							}
							else
							{
								resultFloats[i] = fromFloats[i] + (distances[i] * (currentTime / endTimes[i]) - curves[i].Evaluate(currentTime));
							}
							break;
						case Calculation.SubtractValueFromCurve:
							if (!time.IsNone)
							{
								resultFloats[i] = curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) - distances[i] * (currentTime / time.Value) + fromFloats[i];
							}
							else
							{
								resultFloats[i] = curves[i].Evaluate(currentTime) - distances[i] * (currentTime / endTimes[i]) + fromFloats[i];
							}
							break;
						case Calculation.MultiplyValue:
							if (!time.IsNone)
							{
								resultFloats[i] = curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) * distances[i] * (currentTime / time.Value) + fromFloats[i];
							}
							else
							{
								resultFloats[i] = curves[i].Evaluate(currentTime) * distances[i] * (currentTime / endTimes[i]) + fromFloats[i];
							}
							break;
						case Calculation.DivideValue:
							if (!time.IsNone)
							{
								resultFloats[i] = ((curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) != 0f) ? (fromFloats[i] + distances[i] * (currentTime / time.Value) / curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time)) : float.MaxValue);
							}
							else
							{
								resultFloats[i] = ((curves[i].Evaluate(currentTime) != 0f) ? (fromFloats[i] + distances[i] * (currentTime / endTimes[i]) / curves[i].Evaluate(currentTime)) : float.MaxValue);
							}
							break;
						case Calculation.DivideCurveByValue:
							if (!time.IsNone)
							{
								resultFloats[i] = ((fromFloats[i] != 0f) ? (curves[i].Evaluate(currentTime / time.Value * curves[i].keys[curves[i].length - 1].time) / (distances[i] * (currentTime / time.Value)) + fromFloats[i]) : float.MaxValue);
							}
							else
							{
								resultFloats[i] = ((fromFloats[i] != 0f) ? (curves[i].Evaluate(currentTime) / (distances[i] * (currentTime / endTimes[i])) + fromFloats[i]) : float.MaxValue);
							}
							break;
						}
					}
					else if (!time.IsNone)
					{
						resultFloats[i] = fromFloats[i] + distances[i] * (currentTime / time.Value);
					}
					else
					{
						resultFloats[i] = fromFloats[i] + distances[i] * (currentTime / endTimes[i]);
					}
				}
				else if (!time.IsNone)
				{
					resultFloats[i] = fromFloats[i] + distances[i] * (currentTime / time.Value);
				}
				else if (largestEndTime == 0f)
				{
					resultFloats[i] = fromFloats[i] + distances[i] * (currentTime / 1f);
				}
				else
				{
					resultFloats[i] = fromFloats[i] + distances[i] * (currentTime / largestEndTime);
				}
			}
			if (!isRunning)
			{
				return;
			}
			finishAction = true;
			for (int j = 0; j < endTimes.Length; j++)
			{
				if (currentTime < endTimes[j])
				{
					finishAction = false;
				}
			}
			isRunning = !finishAction;
		}
	}
	[ActionCategory("AnimateVariables")]
	[Tooltip("Animates the value of a Rect Variable FROM-TO with assistance of Deformation Curves.")]
	public class CurveRect : CurveFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmRect rectVariable;

		[RequiredField]
		public FsmRect fromValue;

		[RequiredField]
		public FsmRect toValue;

		[RequiredField]
		public FsmAnimationCurve curveX;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.x and toValue.x.")]
		public Calculation calculationX;

		[RequiredField]
		public FsmAnimationCurve curveY;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.y and toValue.y.")]
		public Calculation calculationY;

		[RequiredField]
		public FsmAnimationCurve curveW;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.width and toValue.width.")]
		public Calculation calculationW;

		[RequiredField]
		public FsmAnimationCurve curveH;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.height and toValue.height.")]
		public Calculation calculationH;

		private Rect rct;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			rectVariable = new FsmRect
			{
				UseVariable = true
			};
			toValue = new FsmRect
			{
				UseVariable = true
			};
			fromValue = new FsmRect
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[4];
			fromFloats = new float[4];
			fromFloats[0] = (fromValue.IsNone ? 0f : fromValue.Value.x);
			fromFloats[1] = (fromValue.IsNone ? 0f : fromValue.Value.y);
			fromFloats[2] = (fromValue.IsNone ? 0f : fromValue.Value.width);
			fromFloats[3] = (fromValue.IsNone ? 0f : fromValue.Value.height);
			toFloats = new float[4];
			toFloats[0] = (toValue.IsNone ? 0f : toValue.Value.x);
			toFloats[1] = (toValue.IsNone ? 0f : toValue.Value.y);
			toFloats[2] = (toValue.IsNone ? 0f : toValue.Value.width);
			toFloats[3] = (toValue.IsNone ? 0f : toValue.Value.height);
			curves = new AnimationCurve[4];
			curves[0] = curveX.curve;
			curves[1] = curveY.curve;
			curves[2] = curveW.curve;
			curves[3] = curveH.curve;
			calculations = new Calculation[4];
			calculations[0] = calculationX;
			calculations[1] = calculationY;
			calculations[2] = calculationW;
			calculations[2] = calculationH;
			Init();
		}

		public override void OnExit()
		{
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!rectVariable.IsNone && isRunning)
			{
				rct = new Rect(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
				rectVariable.Value = rct;
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!rectVariable.IsNone)
				{
					rct = new Rect(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
					rectVariable.Value = rct;
				}
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Animates the value of a Vector3 Variable FROM-TO with assistance of Deformation Curves.")]
	public class CurveVector3 : CurveFsmAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vectorVariable;

		[RequiredField]
		public FsmVector3 fromValue;

		[RequiredField]
		public FsmVector3 toValue;

		[RequiredField]
		public FsmAnimationCurve curveX;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.x and toValue.x.")]
		public Calculation calculationX;

		[RequiredField]
		public FsmAnimationCurve curveY;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.y and toValue.y.")]
		public Calculation calculationY;

		[RequiredField]
		public FsmAnimationCurve curveZ;

		[Tooltip("Calculation lets you set a type of curve deformation that will be applied to otherwise linear move between fromValue.z and toValue.z.")]
		public Calculation calculationZ;

		private Vector3 vct;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			vectorVariable = new FsmVector3
			{
				UseVariable = true
			};
			toValue = new FsmVector3
			{
				UseVariable = true
			};
			fromValue = new FsmVector3
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			base.OnEnter();
			finishInNextStep = false;
			resultFloats = new float[3];
			fromFloats = new float[3];
			fromFloats[0] = (fromValue.IsNone ? 0f : fromValue.Value.x);
			fromFloats[1] = (fromValue.IsNone ? 0f : fromValue.Value.y);
			fromFloats[2] = (fromValue.IsNone ? 0f : fromValue.Value.z);
			toFloats = new float[3];
			toFloats[0] = (toValue.IsNone ? 0f : toValue.Value.x);
			toFloats[1] = (toValue.IsNone ? 0f : toValue.Value.y);
			toFloats[2] = (toValue.IsNone ? 0f : toValue.Value.z);
			curves = new AnimationCurve[3];
			curves[0] = curveX.curve;
			curves[1] = curveY.curve;
			curves[2] = curveZ.curve;
			calculations = new Calculation[3];
			calculations[0] = calculationX;
			calculations[1] = calculationY;
			calculations[2] = calculationZ;
			Init();
		}

		public override void OnExit()
		{
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!vectorVariable.IsNone && isRunning)
			{
				vct = new Vector3(resultFloats[0], resultFloats[1], resultFloats[2]);
				vectorVariable.Value = vct;
			}
			if (finishInNextStep && !looping)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!vectorVariable.IsNone)
				{
					vct = new Vector3(resultFloats[0], resultFloats[1], resultFloats[2]);
					vectorVariable.Value = vct;
				}
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Easing Animation - Color")]
	public class EaseColor : EaseFsmAction
	{
		[RequiredField]
		public FsmColor fromValue;

		[RequiredField]
		public FsmColor toValue;

		[UIHint(UIHint.Variable)]
		public FsmColor colorVariable;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			colorVariable = null;
			fromValue = null;
			toValue = null;
			finishInNextStep = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			fromFloats = new float[4];
			fromFloats[0] = fromValue.Value.r;
			fromFloats[1] = fromValue.Value.g;
			fromFloats[2] = fromValue.Value.b;
			fromFloats[3] = fromValue.Value.a;
			toFloats = new float[4];
			toFloats[0] = toValue.Value.r;
			toFloats[1] = toValue.Value.g;
			toFloats[2] = toValue.Value.b;
			toFloats[3] = toValue.Value.a;
			resultFloats = new float[4];
			finishInNextStep = false;
			colorVariable.Value = fromValue.Value;
		}

		public override void OnExit()
		{
			base.OnExit();
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!colorVariable.IsNone && isRunning)
			{
				colorVariable.Value = new Color(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
			}
			if (finishInNextStep)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!colorVariable.IsNone)
				{
					colorVariable.Value = new Color(reverse.IsNone ? toValue.Value.r : (reverse.Value ? fromValue.Value.r : toValue.Value.r), reverse.IsNone ? toValue.Value.g : (reverse.Value ? fromValue.Value.g : toValue.Value.g), reverse.IsNone ? toValue.Value.b : (reverse.Value ? fromValue.Value.b : toValue.Value.b), reverse.IsNone ? toValue.Value.a : (reverse.Value ? fromValue.Value.a : toValue.Value.a));
				}
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Easing Animation - Float")]
	public class EaseFloat : EaseFsmAction
	{
		[RequiredField]
		public FsmFloat fromValue;

		[RequiredField]
		public FsmFloat toValue;

		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			floatVariable = null;
			fromValue = null;
			toValue = null;
			finishInNextStep = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			fromFloats = new float[1];
			fromFloats[0] = fromValue.Value;
			toFloats = new float[1];
			toFloats[0] = toValue.Value;
			resultFloats = new float[1];
			finishInNextStep = false;
			floatVariable.Value = fromValue.Value;
		}

		public override void OnExit()
		{
			base.OnExit();
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!floatVariable.IsNone && isRunning)
			{
				floatVariable.Value = resultFloats[0];
			}
			if (finishInNextStep)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!floatVariable.IsNone)
				{
					floatVariable.Value = (reverse.IsNone ? toValue.Value : (reverse.Value ? fromValue.Value : toValue.Value));
				}
				finishInNextStep = true;
			}
		}
	}
	[Tooltip("Ease base action - don't use!")]
	public abstract class EaseFsmAction : FsmStateAction
	{
		protected delegate float EasingFunction(float start, float end, float value);

		public enum EaseType
		{
			easeInQuad,
			easeOutQuad,
			easeInOutQuad,
			easeInCubic,
			easeOutCubic,
			easeInOutCubic,
			easeInQuart,
			easeOutQuart,
			easeInOutQuart,
			easeInQuint,
			easeOutQuint,
			easeInOutQuint,
			easeInSine,
			easeOutSine,
			easeInOutSine,
			easeInExpo,
			easeOutExpo,
			easeInOutExpo,
			easeInCirc,
			easeOutCirc,
			easeInOutCirc,
			linear,
			spring,
			bounce,
			easeInBack,
			easeOutBack,
			easeInOutBack,
			elastic,
			punch
		}

		[RequiredField]
		public FsmFloat time;

		public FsmFloat speed;

		public FsmFloat delay;

		public EaseType easeType = EaseType.linear;

		public FsmBool reverse;

		[Tooltip("Optionally send an Event when the animation finishes.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		protected EasingFunction ease;

		protected float runningTime;

		protected float lastTime;

		protected float startTime;

		protected float deltaTime;

		protected float delayTime;

		protected float percentage;

		protected float[] fromFloats = new float[0];

		protected float[] toFloats = new float[0];

		protected float[] resultFloats = new float[0];

		protected bool finishAction;

		protected bool start;

		protected bool finished;

		protected bool isRunning;

		public override void Reset()
		{
			easeType = EaseType.linear;
			time = new FsmFloat
			{
				Value = 1f
			};
			delay = new FsmFloat
			{
				UseVariable = true
			};
			speed = new FsmFloat
			{
				UseVariable = true
			};
			reverse = new FsmBool
			{
				Value = false
			};
			realTime = false;
			finishEvent = null;
			ease = null;
			runningTime = 0f;
			lastTime = 0f;
			percentage = 0f;
			fromFloats = new float[0];
			toFloats = new float[0];
			resultFloats = new float[0];
			finishAction = false;
			start = false;
			finished = false;
			isRunning = false;
		}

		public override void OnEnter()
		{
			finished = false;
			isRunning = false;
			SetEasingFunction();
			runningTime = 0f;
			percentage = (reverse.IsNone ? 0f : (reverse.Value ? 1f : 0f));
			finishAction = false;
			startTime = FsmTime.RealtimeSinceStartup;
			lastTime = FsmTime.RealtimeSinceStartup - startTime;
			delayTime = (delay.IsNone ? 0f : (delayTime = delay.Value));
			start = true;
		}

		public override void OnExit()
		{
		}

		public override void OnUpdate()
		{
			if (start && !isRunning)
			{
				if (delayTime >= 0f)
				{
					if (realTime)
					{
						deltaTime = FsmTime.RealtimeSinceStartup - startTime - lastTime;
						lastTime = FsmTime.RealtimeSinceStartup - startTime;
						delayTime -= deltaTime;
					}
					else
					{
						delayTime -= Time.deltaTime;
					}
				}
				else
				{
					isRunning = true;
					start = false;
					startTime = FsmTime.RealtimeSinceStartup;
					lastTime = FsmTime.RealtimeSinceStartup - startTime;
				}
			}
			if (!isRunning || finished)
			{
				return;
			}
			if (reverse.IsNone || !reverse.Value)
			{
				UpdatePercentage();
				if (percentage < 1f)
				{
					for (int i = 0; i < fromFloats.Length; i++)
					{
						resultFloats[i] = ease(fromFloats[i], toFloats[i], percentage);
					}
				}
				else
				{
					finishAction = true;
					finished = true;
					isRunning = false;
				}
				return;
			}
			UpdatePercentage();
			if (percentage > 0f)
			{
				for (int j = 0; j < fromFloats.Length; j++)
				{
					resultFloats[j] = ease(fromFloats[j], toFloats[j], percentage);
				}
			}
			else
			{
				finishAction = true;
				finished = true;
				isRunning = false;
			}
		}

		protected void UpdatePercentage()
		{
			if (realTime)
			{
				deltaTime = FsmTime.RealtimeSinceStartup - startTime - lastTime;
				lastTime = FsmTime.RealtimeSinceStartup - startTime;
				if (!speed.IsNone)
				{
					runningTime += deltaTime * speed.Value;
				}
				else
				{
					runningTime += deltaTime;
				}
			}
			else if (!speed.IsNone)
			{
				runningTime += Time.deltaTime * speed.Value;
			}
			else
			{
				runningTime += Time.deltaTime;
			}
			if (!reverse.IsNone && reverse.Value)
			{
				percentage = 1f - runningTime / time.Value;
			}
			else
			{
				percentage = runningTime / time.Value;
			}
		}

		protected void SetEasingFunction()
		{
			switch (easeType)
			{
			case EaseType.easeInQuad:
				ease = easeInQuad;
				break;
			case EaseType.easeOutQuad:
				ease = easeOutQuad;
				break;
			case EaseType.easeInOutQuad:
				ease = easeInOutQuad;
				break;
			case EaseType.easeInCubic:
				ease = easeInCubic;
				break;
			case EaseType.easeOutCubic:
				ease = easeOutCubic;
				break;
			case EaseType.easeInOutCubic:
				ease = easeInOutCubic;
				break;
			case EaseType.easeInQuart:
				ease = easeInQuart;
				break;
			case EaseType.easeOutQuart:
				ease = easeOutQuart;
				break;
			case EaseType.easeInOutQuart:
				ease = easeInOutQuart;
				break;
			case EaseType.easeInQuint:
				ease = easeInQuint;
				break;
			case EaseType.easeOutQuint:
				ease = easeOutQuint;
				break;
			case EaseType.easeInOutQuint:
				ease = easeInOutQuint;
				break;
			case EaseType.easeInSine:
				ease = easeInSine;
				break;
			case EaseType.easeOutSine:
				ease = easeOutSine;
				break;
			case EaseType.easeInOutSine:
				ease = easeInOutSine;
				break;
			case EaseType.easeInExpo:
				ease = easeInExpo;
				break;
			case EaseType.easeOutExpo:
				ease = easeOutExpo;
				break;
			case EaseType.easeInOutExpo:
				ease = easeInOutExpo;
				break;
			case EaseType.easeInCirc:
				ease = easeInCirc;
				break;
			case EaseType.easeOutCirc:
				ease = easeOutCirc;
				break;
			case EaseType.easeInOutCirc:
				ease = easeInOutCirc;
				break;
			case EaseType.linear:
				ease = linear;
				break;
			case EaseType.spring:
				ease = spring;
				break;
			case EaseType.bounce:
				ease = bounce;
				break;
			case EaseType.easeInBack:
				ease = easeInBack;
				break;
			case EaseType.easeOutBack:
				ease = easeOutBack;
				break;
			case EaseType.easeInOutBack:
				ease = easeInOutBack;
				break;
			case EaseType.elastic:
				ease = elastic;
				break;
			case EaseType.punch:
				ease = elastic;
				break;
			}
		}

		protected float linear(float start, float end, float value)
		{
			return Mathf.Lerp(start, end, value);
		}

		protected float clerp(float start, float end, float value)
		{
			float num = 0f;
			float num2 = 360f;
			float num3 = Mathf.Abs((num2 - num) / 2f);
			float num4 = 0f;
			float num5 = 0f;
			if (end - start < 0f - num3)
			{
				num5 = (num2 - start + end) * value;
				return start + num5;
			}
			if (end - start > num3)
			{
				num5 = (0f - (num2 - end + start)) * value;
				return start + num5;
			}
			return start + (end - start) * value;
		}

		protected float spring(float start, float end, float value)
		{
			value = Mathf.Clamp01(value);
			value = (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
			return start + (end - start) * value;
		}

		protected float easeInQuad(float start, float end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		protected float easeOutQuad(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * value * (value - 2f) + start;
		}

		protected float easeInOutQuad(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end / 2f * value * value + start;
			}
			value -= 1f;
			return (0f - end) / 2f * (value * (value - 2f) - 1f) + start;
		}

		protected float easeInCubic(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value + start;
		}

		protected float easeOutCubic(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value + 1f) + start;
		}

		protected float easeInOutCubic(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end / 2f * value * value * value + start;
			}
			value -= 2f;
			return end / 2f * (value * value * value + 2f) + start;
		}

		protected float easeInQuart(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value + start;
		}

		protected float easeOutQuart(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return (0f - end) * (value * value * value * value - 1f) + start;
		}

		protected float easeInOutQuart(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end / 2f * value * value * value * value + start;
			}
			value -= 2f;
			return (0f - end) / 2f * (value * value * value * value - 2f) + start;
		}

		protected float easeInQuint(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value * value + start;
		}

		protected float easeOutQuint(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value * value * value + 1f) + start;
		}

		protected float easeInOutQuint(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end / 2f * value * value * value * value * value + start;
			}
			value -= 2f;
			return end / 2f * (value * value * value * value * value + 2f) + start;
		}

		protected float easeInSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * Mathf.Cos(value / 1f * ((float)Math.PI / 2f)) + end + start;
		}

		protected float easeOutSine(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value / 1f * ((float)Math.PI / 2f)) + start;
		}

		protected float easeInOutSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) / 2f * (Mathf.Cos((float)Math.PI * value / 1f) - 1f) + start;
		}

		protected float easeInExpo(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Pow(2f, 10f * (value / 1f - 1f)) + start;
		}

		protected float easeOutExpo(float start, float end, float value)
		{
			end -= start;
			return end * (0f - Mathf.Pow(2f, -10f * value / 1f) + 1f) + start;
		}

		protected float easeInOutExpo(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end / 2f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
			}
			value -= 1f;
			return end / 2f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
		}

		protected float easeInCirc(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}

		protected float easeOutCirc(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * Mathf.Sqrt(1f - value * value) + start;
		}

		protected float easeInOutCirc(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return (0f - end) / 2f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
			}
			value -= 2f;
			return end / 2f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
		}

		protected float bounce(float start, float end, float value)
		{
			value /= 1f;
			end -= start;
			if (value < 0.36363637f)
			{
				return end * (7.5625f * value * value) + start;
			}
			if (value < 0.72727275f)
			{
				value -= 0.54545456f;
				return end * (7.5625f * value * value + 0.75f) + start;
			}
			if ((double)value < 0.9090909090909091)
			{
				value -= 0.8181818f;
				return end * (7.5625f * value * value + 0.9375f) + start;
			}
			value -= 21f / 22f;
			return end * (7.5625f * value * value + 63f / 64f) + start;
		}

		protected float easeInBack(float start, float end, float value)
		{
			end -= start;
			value /= 1f;
			float num = 1.70158f;
			return end * value * value * ((num + 1f) * value - num) + start;
		}

		protected float easeOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value = value / 1f - 1f;
			return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
		}

		protected float easeInOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value /= 0.5f;
			if (value < 1f)
			{
				num *= 1.525f;
				return end / 2f * (value * value * ((num + 1f) * value - num)) + start;
			}
			value -= 2f;
			num *= 1.525f;
			return end / 2f * (value * value * ((num + 1f) * value + num) + 2f) + start;
		}

		protected float punch(float amplitude, float value)
		{
			float num = 9f;
			if (value == 0f)
			{
				return 0f;
			}
			if (value == 1f)
			{
				return 0f;
			}
			float num2 = 0.3f;
			num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
			return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
		}

		protected float elastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num) == 1f)
			{
				return start + end;
			}
			if (num4 == 0f || num4 < Mathf.Abs(end))
			{
				num4 = end;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
			}
			return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
		}
	}
	[ActionCategory("AnimateVariables")]
	[Tooltip("Easing Animation - Rect.")]
	public class EaseRect : EaseFsmAction
	{
		[RequiredField]
		public FsmRect fromValue;

		[RequiredField]
		public FsmRect toValue;

		[UIHint(UIHint.Variable)]
		public FsmRect rectVariable;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			rectVariable = null;
			fromValue = null;
			toValue = null;
			finishInNextStep = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			fromFloats = new float[4];
			fromFloats[0] = fromValue.Value.x;
			fromFloats[1] = fromValue.Value.y;
			fromFloats[2] = fromValue.Value.width;
			fromFloats[3] = fromValue.Value.height;
			toFloats = new float[4];
			toFloats[0] = toValue.Value.x;
			toFloats[1] = toValue.Value.y;
			toFloats[2] = toValue.Value.width;
			toFloats[3] = toValue.Value.height;
			resultFloats = new float[4];
			finishInNextStep = false;
			rectVariable.Value = fromValue.Value;
		}

		public override void OnExit()
		{
			base.OnExit();
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!rectVariable.IsNone && isRunning)
			{
				rectVariable.Value = new Rect(resultFloats[0], resultFloats[1], resultFloats[2], resultFloats[3]);
			}
			if (finishInNextStep)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!rectVariable.IsNone)
				{
					rectVariable.Value = new Rect(reverse.IsNone ? toValue.Value.x : (reverse.Value ? fromValue.Value.x : toValue.Value.x), reverse.IsNone ? toValue.Value.y : (reverse.Value ? fromValue.Value.y : toValue.Value.y), reverse.IsNone ? toValue.Value.width : (reverse.Value ? fromValue.Value.width : toValue.Value.width), reverse.IsNone ? toValue.Value.height : (reverse.Value ? fromValue.Value.height : toValue.Value.height));
				}
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.AnimateVariables)]
	[Tooltip("Easing Animation - Vector3")]
	public class EaseVector3 : EaseFsmAction
	{
		[RequiredField]
		public FsmVector3 fromValue;

		[RequiredField]
		public FsmVector3 toValue;

		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			vector3Variable = null;
			fromValue = null;
			toValue = null;
			finishInNextStep = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			fromFloats = new float[3];
			fromFloats[0] = fromValue.Value.x;
			fromFloats[1] = fromValue.Value.y;
			fromFloats[2] = fromValue.Value.z;
			toFloats = new float[3];
			toFloats[0] = toValue.Value.x;
			toFloats[1] = toValue.Value.y;
			toFloats[2] = toValue.Value.z;
			resultFloats = new float[3];
			finishInNextStep = false;
			vector3Variable.Value = fromValue.Value;
		}

		public override void OnExit()
		{
			base.OnExit();
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			if (!vector3Variable.IsNone && isRunning)
			{
				vector3Variable.Value = new Vector3(resultFloats[0], resultFloats[1], resultFloats[2]);
			}
			if (finishInNextStep)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				if (!vector3Variable.IsNone)
				{
					vector3Variable.Value = new Vector3(reverse.IsNone ? toValue.Value.x : (reverse.Value ? fromValue.Value.x : toValue.Value.x), reverse.IsNone ? toValue.Value.y : (reverse.Value ? fromValue.Value.y : toValue.Value.y), reverse.IsNone ? toValue.Value.z : (reverse.Value ? fromValue.Value.z : toValue.Value.z));
				}
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Adds a named Animation Clip to a Game Object. Optionally trims the Animation.")]
	public class AddAnimationClip : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("The GameObject to add the Animation Clip to.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[ObjectType(typeof(AnimationClip))]
		[Tooltip("The animation clip to add. NOTE: Make sure the clip is compatible with the object's hierarchy.")]
		public FsmObject animationClip;

		[RequiredField]
		[Tooltip("Name the animation. Used by other actions to reference this animation.")]
		public FsmString animationName;

		[Tooltip("Optionally trim the animation by specifying a first and last frame.")]
		public FsmInt firstFrame;

		[Tooltip("Optionally trim the animation by specifying a first and last frame.")]
		public FsmInt lastFrame;

		[Tooltip("Add an extra looping frame that matches the first frame.")]
		public FsmBool addLoopFrame;

		public override void Reset()
		{
			gameObject = null;
			animationClip = null;
			animationName = "";
			firstFrame = 0;
			lastFrame = 0;
			addLoopFrame = false;
		}

		public override void OnEnter()
		{
			DoAddAnimationClip();
			Finish();
		}

		private void DoAddAnimationClip()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			AnimationClip animationClip = this.animationClip.Value as AnimationClip;
			if (!(animationClip == null))
			{
				Animation component = ownerDefaultTarget.GetComponent<Animation>();
				if (firstFrame.Value == 0 && lastFrame.Value == 0)
				{
					component.AddClip(animationClip, animationName.Value);
				}
				else
				{
					component.AddClip(animationClip, animationName.Value, firstFrame.Value, lastFrame.Value, addLoopFrame.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Play an animation on a subset of the hierarchy. E.g., A waving animation on the upper body.")]
	public class AddMixingTransform : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("The GameObject playing the animation.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The name of the animation to mix. NOTE: The animation should already be added to the Animation Component on the GameObject.")]
		public FsmString animationName;

		[RequiredField]
		[Tooltip("The mixing transform. E.g., root/upper_body/left_shoulder")]
		public FsmString transform;

		[Tooltip("If recursive is true all children of the mix transform will also be animated.")]
		public FsmBool recursive;

		public override void Reset()
		{
			gameObject = null;
			animationName = "";
			transform = "";
			recursive = true;
		}

		public override void OnEnter()
		{
			DoAddMixingTransform();
			Finish();
		}

		private void DoAddMixingTransform()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				AnimationState animationState = base.animation[animationName.Value];
				if (!(animationState == null))
				{
					Transform mix = ownerDefaultTarget.transform.Find(transform.Value);
					animationState.AddMixingTransform(mix, recursive.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Set the Wrap Mode, Blend Mode, Layer and Speed of an Animation.\nNOTE: Settings are applied once, on entering the state, NOT continuously. To dynamically control an animation's settings, use Set Animation Speed etc.")]
	public class AnimationSettings : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("A GameObject with an Animation Component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Animation)]
		[Tooltip("The name of the animation.")]
		public FsmString animName;

		[Tooltip("The behavior of the animation when it wraps.")]
		public WrapMode wrapMode;

		[Tooltip("How the animation is blended with other animations on the Game Object.")]
		public AnimationBlendMode blendMode;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("The speed of the animation. 1 = normal; 2 = double speed...")]
		public FsmFloat speed;

		[Tooltip("The animation layer")]
		public FsmInt layer;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
			wrapMode = WrapMode.Loop;
			blendMode = AnimationBlendMode.Blend;
			speed = 1f;
			layer = 0;
		}

		public override void OnEnter()
		{
			DoAnimationSettings();
			Finish();
		}

		private void DoAnimationSettings()
		{
			if (string.IsNullOrEmpty(animName.Value))
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget))
			{
				return;
			}
			AnimationState animationState = base.animation[animName.Value];
			if (animationState == null)
			{
				LogWarning("Missing animation: " + animName.Value);
				return;
			}
			animationState.wrapMode = wrapMode;
			animationState.blendMode = blendMode;
			if (!layer.IsNone)
			{
				animationState.layer = layer.Value;
			}
			if (!speed.IsNone)
			{
				animationState.speed = speed.Value;
			}
		}
	}
	public abstract class BaseAnimationAction : ComponentAction<Animation>
	{
		public override void OnActionTargetInvoked(object targetObject)
		{
			AnimationClip animationClip = targetObject as AnimationClip;
			if (!(animationClip == null))
			{
				Animation component = base.Owner.GetComponent<Animation>();
				if (component != null)
				{
					component.AddClip(animationClip, animationClip.name);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Blends an Animation towards a Target Weight over a specified Time.\nOptionally sends an Event when finished.")]
	public class BlendAnimation : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("The GameObject to animate.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Animation)]
		[Tooltip("The name of the animation to blend.")]
		public FsmString animName;

		[RequiredField]
		[HasFloatSlider(0f, 1f)]
		[Tooltip("Target weight to blend to.")]
		public FsmFloat targetWeight;

		[RequiredField]
		[HasFloatSlider(0f, 5f)]
		[Tooltip("How long should the blend take.")]
		public FsmFloat time;

		[Tooltip("Event to send when the blend has finished.")]
		public FsmEvent finishEvent;

		private DelayedEvent delayedFinishEvent;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
			targetWeight = 1f;
			time = 0.3f;
			finishEvent = null;
		}

		public override void OnEnter()
		{
			DoBlendAnimation((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
		}

		public override void OnUpdate()
		{
			if (DelayedEvent.WasSent(delayedFinishEvent))
			{
				Finish();
			}
		}

		private void DoBlendAnimation(GameObject go)
		{
			if (go == null)
			{
				return;
			}
			Animation component = go.GetComponent<Animation>();
			if (component == null)
			{
				LogWarning("Missing Animation component on GameObject: " + go.name);
				Finish();
				return;
			}
			AnimationState animationState = component[animName.Value];
			if (animationState == null)
			{
				LogWarning("Missing animation: " + animName.Value);
				Finish();
				return;
			}
			float value = time.Value;
			component.Blend(animName.Value, targetWeight.Value, value);
			if (finishEvent != null)
			{
				delayedFinishEvent = base.Fsm.DelayedEvent(finishEvent, animationState.length);
			}
			else
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Captures the current pose of a hierarchy as an animation clip.\n\nUseful to blend from an arbitrary pose (e.g. a rag-doll death) back to a known animation (e.g. idle).")]
	public class CapturePoseAsAnimationClip : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("The GameObject root of the hierarchy to capture.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Capture position keys.")]
		public FsmBool position;

		[Tooltip("Capture rotation keys.")]
		public FsmBool rotation;

		[Tooltip("Capture scale keys.")]
		public FsmBool scale;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[ObjectType(typeof(AnimationClip))]
		[Tooltip("Store the result in an Object variable of type AnimationClip.")]
		public FsmObject storeAnimationClip;

		public override void Reset()
		{
			gameObject = null;
			position = false;
			rotation = true;
			scale = false;
			storeAnimationClip = null;
		}

		public override void OnEnter()
		{
			DoCaptureAnimationClip();
			Finish();
		}

		private void DoCaptureAnimationClip()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			AnimationClip animationClip = new AnimationClip();
			foreach (Transform item in ownerDefaultTarget.transform)
			{
				CaptureTransform(item, "", animationClip);
			}
			storeAnimationClip.Value = animationClip;
		}

		private void CaptureTransform(Transform transform, string path, AnimationClip clip)
		{
			path += transform.name;
			if (position.Value)
			{
				CapturePosition(transform, path, clip);
			}
			if (rotation.Value)
			{
				CaptureRotation(transform, path, clip);
			}
			if (scale.Value)
			{
				CaptureScale(transform, path, clip);
			}
			foreach (Transform item in transform)
			{
				CaptureTransform(item, path + "/", clip);
			}
		}

		private void CapturePosition(Transform transform, string path, AnimationClip clip)
		{
			SetConstantCurve(clip, path, "localPosition.x", transform.localPosition.x);
			SetConstantCurve(clip, path, "localPosition.y", transform.localPosition.y);
			SetConstantCurve(clip, path, "localPosition.z", transform.localPosition.z);
		}

		private void CaptureRotation(Transform transform, string path, AnimationClip clip)
		{
			SetConstantCurve(clip, path, "localRotation.x", transform.localRotation.x);
			SetConstantCurve(clip, path, "localRotation.y", transform.localRotation.y);
			SetConstantCurve(clip, path, "localRotation.z", transform.localRotation.z);
			SetConstantCurve(clip, path, "localRotation.w", transform.localRotation.w);
		}

		private void CaptureScale(Transform transform, string path, AnimationClip clip)
		{
			SetConstantCurve(clip, path, "localScale.x", transform.localScale.x);
			SetConstantCurve(clip, path, "localScale.y", transform.localScale.y);
			SetConstantCurve(clip, path, "localScale.z", transform.localScale.z);
		}

		private void SetConstantCurve(AnimationClip clip, string childPath, string propertyPath, float value)
		{
			AnimationCurve animationCurve = AnimationCurve.Linear(0f, value, 100f, value);
			animationCurve.postWrapMode = WrapMode.Loop;
			clip.SetCurve(childPath, typeof(Transform), propertyPath, animationCurve);
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Enables/Disables an Animation on a GameObject.\nAnimation time is paused while disabled. Animation must also have a non zero weight to play.")]
	public class EnableAnimation : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("The GameObject playing the animation.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Animation)]
		[Tooltip("The name of the animation to enable/disable.")]
		public FsmString animName;

		[RequiredField]
		[Tooltip("Set to True to enable, False to disable.")]
		public FsmBool enable;

		[Tooltip("Reset the initial enabled state when exiting the state.")]
		public FsmBool resetOnExit;

		private AnimationState anim;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
			enable = true;
			resetOnExit = false;
		}

		public override void OnEnter()
		{
			DoEnableAnimation(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private void DoEnableAnimation(GameObject go)
		{
			if (UpdateCache(go))
			{
				anim = base.animation[animName.Value];
				if (anim != null)
				{
					anim.enabled = enable.Value;
				}
			}
		}

		public override void OnExit()
		{
			if (resetOnExit.Value && anim != null)
			{
				anim.enabled = !enable.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Plays an Animation on a Game Object. You can add named animation clips to the object in the Unity editor, or with the Add Animation Clip action.")]
	public class PlayAnimation : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("Game Object to play the animation on.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Animation)]
		[Tooltip("The name of the animation to play.")]
		public FsmString animName;

		[Tooltip("How to treat previously playing animations.")]
		public PlayMode playMode;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Time taken to blend to this animation.")]
		public FsmFloat blendTime;

		[Tooltip("Event to send when the animation is finished playing. NOTE: Not sent with Loop or PingPong wrap modes!")]
		public FsmEvent finishEvent;

		[Tooltip("Event to send when the animation loops. If you want to send this event to another FSM use Set Event Target. NOTE: This event is only sent with Loop and PingPong wrap modes.")]
		public FsmEvent loopEvent;

		[Tooltip("Stop playing the animation when this state is exited.")]
		public bool stopOnExit;

		private AnimationState anim;

		private float prevAnimtTime;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
			playMode = PlayMode.StopAll;
			blendTime = 0.3f;
			finishEvent = null;
			loopEvent = null;
			stopOnExit = false;
		}

		public override void OnEnter()
		{
			DoPlayAnimation();
		}

		private void DoPlayAnimation()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget))
			{
				Finish();
				return;
			}
			if (string.IsNullOrEmpty(animName.Value))
			{
				LogWarning("Missing animName!");
				Finish();
				return;
			}
			anim = base.animation[animName.Value];
			if (anim == null)
			{
				LogWarning("Missing animation: " + animName.Value);
				Finish();
				return;
			}
			float value = blendTime.Value;
			if (value < 0.001f)
			{
				base.animation.Play(animName.Value, playMode);
			}
			else
			{
				base.animation.CrossFade(animName.Value, value, playMode);
			}
			prevAnimtTime = anim.time;
		}

		public override void OnUpdate()
		{
			if (!(base.Fsm.GetOwnerDefaultTarget(gameObject) == null) && !(anim == null))
			{
				if (!anim.enabled || (anim.wrapMode == WrapMode.ClampForever && anim.time > anim.length))
				{
					base.Fsm.Event(finishEvent);
					Finish();
				}
				if (anim.wrapMode != WrapMode.ClampForever && anim.time > anim.length && prevAnimtTime < anim.length)
				{
					base.Fsm.Event(loopEvent);
				}
			}
		}

		public override void OnExit()
		{
			if (stopOnExit)
			{
				StopAnimation();
			}
		}

		private void StopAnimation()
		{
			if (base.animation != null)
			{
				base.animation.Stop(animName.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Plays a Random Animation on a Game Object. You can set the relative weight of each animation to control how often they are selected.")]
	public class PlayRandomAnimation : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("Game Object to play the animation on.")]
		public FsmOwnerDefault gameObject;

		[CompoundArray("Animations", "Animation", "Weight")]
		[UIHint(UIHint.Animation)]
		public FsmString[] animations;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		[Tooltip("How to treat previously playing animations.")]
		public PlayMode playMode;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Time taken to blend to this animation.")]
		public FsmFloat blendTime;

		[Tooltip("Event to send when the animation is finished playing. NOTE: Not sent with Loop or PingPong wrap modes!")]
		public FsmEvent finishEvent;

		[Tooltip("Event to send when the animation loops. If you want to send this event to another FSM use Set Event Target. NOTE: This event is only sent with Loop and PingPong wrap modes.")]
		public FsmEvent loopEvent;

		[Tooltip("Stop playing the animation when this state is exited.")]
		public bool stopOnExit;

		private AnimationState anim;

		private float prevAnimtTime;

		public override void Reset()
		{
			gameObject = null;
			animations = new FsmString[0];
			weights = new FsmFloat[0];
			playMode = PlayMode.StopAll;
			blendTime = 0.3f;
			finishEvent = null;
			loopEvent = null;
			stopOnExit = false;
		}

		public override void OnEnter()
		{
			DoPlayRandomAnimation();
		}

		private void DoPlayRandomAnimation()
		{
			if (animations.Length != 0)
			{
				int randomWeightedIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				if (randomWeightedIndex != -1)
				{
					DoPlayAnimation(animations[randomWeightedIndex].Value);
				}
			}
		}

		private void DoPlayAnimation(string animName)
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget))
			{
				Finish();
				return;
			}
			if (string.IsNullOrEmpty(animName))
			{
				LogWarning("Missing animName!");
				Finish();
				return;
			}
			anim = base.animation[animName];
			if (anim == null)
			{
				LogWarning("Missing animation: " + animName);
				Finish();
				return;
			}
			float value = blendTime.Value;
			if (value < 0.001f)
			{
				base.animation.Play(animName, playMode);
			}
			else
			{
				base.animation.CrossFade(animName, value, playMode);
			}
			prevAnimtTime = anim.time;
		}

		public override void OnUpdate()
		{
			if (!(base.Fsm.GetOwnerDefaultTarget(gameObject) == null) && !(anim == null))
			{
				if (!anim.enabled || (anim.wrapMode == WrapMode.ClampForever && anim.time > anim.length))
				{
					base.Fsm.Event(finishEvent);
					Finish();
				}
				if (anim.wrapMode != WrapMode.ClampForever && anim.time > anim.length && prevAnimtTime < anim.length)
				{
					base.Fsm.Event(loopEvent);
				}
			}
		}

		public override void OnExit()
		{
			if (stopOnExit)
			{
				StopAnimation();
			}
		}

		private void StopAnimation()
		{
			if (base.animation != null)
			{
				base.animation.Stop(anim.name);
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Removes a mixing transform previously added with Add Mixing Transform. If transform has been added as recursive, then it will be removed as recursive. Once you remove all mixing transforms added to animation state all curves become animated again.")]
	public class RemoveMixingTransform : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		[Tooltip("The GameObject playing the animation.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The name of the animation.")]
		public FsmString animationName;

		[RequiredField]
		[Tooltip("The mixing transform to remove. E.g., root/upper_body/left_shoulder")]
		public FsmString transfrom;

		public override void Reset()
		{
			gameObject = null;
			animationName = "";
		}

		public override void OnEnter()
		{
			DoRemoveMixingTransform();
			Finish();
		}

		private void DoRemoveMixingTransform()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				AnimationState animationState = base.animation[animationName.Value];
				if (!(animationState == null))
				{
					Transform mix = ownerDefaultTarget.transform.Find(transfrom.Value);
					animationState.AddMixingTransform(mix);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Rewinds the named animation.")]
	public class RewindAnimation : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Animation)]
		public FsmString animName;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
		}

		public override void OnEnter()
		{
			DoRewindAnimation();
			Finish();
		}

		private void DoRewindAnimation()
		{
			if (!string.IsNullOrEmpty(animName.Value))
			{
				GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
				if (UpdateCache(ownerDefaultTarget))
				{
					base.animation.Rewind(animName.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Sets the Speed of an Animation. Check Every Frame to update the animation time continuously, e.g., if you're manipulating a variable that controls animation speed.")]
	public class SetAnimationSpeed : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Animation)]
		public FsmString animName;

		public FsmFloat speed = 1f;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
			speed = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetAnimationSpeed((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetAnimationSpeed((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
		}

		private void DoSetAnimationSpeed(GameObject go)
		{
			if (UpdateCache(go))
			{
				AnimationState animationState = base.animation[animName.Value];
				if (animationState == null)
				{
					LogWarning("Missing animation: " + animName.Value);
				}
				else
				{
					animationState.speed = speed.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Sets the current Time of an Animation, Normalize time means 0 (start) to 1 (end); useful if you don't care about the exact time. Check Every Frame to update the time continuously.")]
	public class SetAnimationTime : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Animation)]
		public FsmString animName;

		public FsmFloat time;

		public bool normalized;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
			time = null;
			normalized = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetAnimationTime((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetAnimationTime((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
		}

		private void DoSetAnimationTime(GameObject go)
		{
			if (!UpdateCache(go))
			{
				return;
			}
			base.animation.Play(animName.Value);
			AnimationState animationState = base.animation[animName.Value];
			if (animationState == null)
			{
				LogWarning("Missing animation: " + animName.Value);
				return;
			}
			if (normalized)
			{
				animationState.normalizedTime = time.Value;
			}
			else
			{
				animationState.time = time.Value;
			}
			if (everyFrame)
			{
				animationState.speed = 0f;
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Sets the Blend Weight of an Animation. Check Every Frame to update the weight continuously, e.g., if you're manipulating a variable that controls the weight.")]
	public class SetAnimationWeight : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Animation)]
		public FsmString animName;

		public FsmFloat weight = 1f;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
			weight = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetAnimationWeight((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetAnimationWeight((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
		}

		private void DoSetAnimationWeight(GameObject go)
		{
			if (UpdateCache(go))
			{
				AnimationState animationState = base.animation[animName.Value];
				if (animationState == null)
				{
					LogWarning("Missing animation: " + animName.Value);
				}
				else
				{
					animationState.weight = weight.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animation)]
	[Tooltip("Stops all playing Animations on a Game Object. Optionally, specify a single Animation to Stop.")]
	public class StopAnimation : BaseAnimationAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animation))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Leave empty to stop all playing animations.")]
		[UIHint(UIHint.Animation)]
		public FsmString animName;

		public override void Reset()
		{
			gameObject = null;
			animName = null;
		}

		public override void OnEnter()
		{
			DoStopAnimation();
			Finish();
		}

		private void DoStopAnimation()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (FsmString.IsNullOrEmpty(animName))
				{
					base.animation.Stop();
				}
				else
				{
					base.animation.Stop(animName.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Create a dynamic transition between the current state and the destination state. Both states have to be on the same layer. Note: You cannot change the current state on a synchronized layer, you need to change it on the referenced layer.")]
	public class AnimatorCrossFade : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The name of the state that will be played.")]
		public FsmString stateName;

		[Tooltip("The duration of the transition. Value is in source state normalized time.")]
		public FsmFloat transitionDuration;

		[Tooltip("Layer index containing the destination state. Leave to none to ignore")]
		public FsmInt layer;

		[Tooltip("Start time of the current destination state. Value is in source state normalized time, should be between 0 and 1.")]
		public FsmFloat normalizedTime;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			stateName = null;
			transitionDuration = 1f;
			layer = new FsmInt
			{
				UseVariable = true
			};
			normalizedTime = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator != null)
			{
				int num = (layer.IsNone ? (-1) : layer.Value);
				float normalizedTimeOffset = (normalizedTime.IsNone ? float.NegativeInfinity : normalizedTime.Value);
				_animator.CrossFade(stateName.Value, transitionDuration.Value, num, normalizedTimeOffset);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Interrupts the automatic target matching. CompleteMatch will make the gameobject match the target completely at the next frame.")]
	public class AnimatorInterruptMatchTarget : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Will make the gameobject match the target completely at the next frame")]
		public FsmBool completeMatch;

		public override void Reset()
		{
			gameObject = null;
			completeMatch = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			Animator component = ownerDefaultTarget.GetComponent<Animator>();
			if (component != null)
			{
				component.InterruptMatchTarget(completeMatch.Value);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Automatically adjust the gameobject position and rotation so that the AvatarTarget reaches the matchPosition when the current state is at the specified progress")]
	public class AnimatorMatchTarget : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The body part that is involved in the match")]
		public AvatarTarget bodyPart;

		[Tooltip("The gameObject target to match")]
		public FsmGameObject target;

		[Tooltip("The position of the ik goal. If Goal GameObject set, position is used as an offset from Goal")]
		public FsmVector3 targetPosition;

		[Tooltip("The rotation of the ik goal.If Goal GameObject set, rotation is used as an offset from Goal")]
		public FsmQuaternion targetRotation;

		[Tooltip("The MatchTargetWeightMask Position XYZ weight")]
		public FsmVector3 positionWeight;

		[Tooltip("The MatchTargetWeightMask Rotation weight")]
		public FsmFloat rotationWeight;

		[Tooltip("Start time within the animation clip (0 - beginning of clip, 1 - end of clip)")]
		public FsmFloat startNormalizedTime;

		[Tooltip("End time within the animation clip (0 - beginning of clip, 1 - end of clip), values greater than 1 can be set to trigger a match after a certain number of loops. Ex: 2.3 means at 30% of 2nd loop")]
		public FsmFloat targetNormalizedTime;

		[Tooltip("Should always be true")]
		public bool everyFrame;

		private Animator _animator;

		private Transform _transform;

		public override void Reset()
		{
			gameObject = null;
			bodyPart = AvatarTarget.Root;
			target = null;
			targetPosition = new FsmVector3
			{
				UseVariable = true
			};
			targetRotation = new FsmQuaternion
			{
				UseVariable = true
			};
			positionWeight = Vector3.one;
			rotationWeight = 0f;
			startNormalizedTime = null;
			targetNormalizedTime = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = target.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
			DoMatchTarget();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMatchTarget();
		}

		private void DoMatchTarget()
		{
			if (!(_animator == null))
			{
				Vector3 matchPosition = Vector3.zero;
				Quaternion matchRotation = Quaternion.identity;
				if (_transform != null)
				{
					matchPosition = _transform.position;
					matchRotation = _transform.rotation;
				}
				if (!targetPosition.IsNone)
				{
					matchPosition += targetPosition.Value;
				}
				if (!targetRotation.IsNone)
				{
					matchRotation *= targetRotation.Value;
				}
				MatchTargetWeightMask weightMask = new MatchTargetWeightMask(positionWeight.Value, rotationWeight.Value);
				_animator.MatchTarget(matchPosition, matchRotation, bodyPart, weightMask, startNormalizedTime.Value, targetNormalizedTime.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Plays a state. This could be used to synchronize your animation with audio or synchronize an Animator over the network.")]
	public class AnimatorPlay : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The name of the state that will be played.")]
		public FsmString stateName;

		[Tooltip("The layer where the state is.")]
		public FsmInt layer;

		[Tooltip("The normalized time at which the state will play")]
		public FsmFloat normalizedTime;

		[Tooltip("Repeat every frame. Useful when using normalizedTime to manually control the animation.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			stateName = null;
			layer = new FsmInt
			{
				UseVariable = true
			};
			normalizedTime = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			DoAnimatorPlay();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoAnimatorPlay();
		}

		private void DoAnimatorPlay()
		{
			if (_animator != null)
			{
				int num = (layer.IsNone ? (-1) : layer.Value);
				float num2 = (normalizedTime.IsNone ? float.NegativeInfinity : normalizedTime.Value);
				_animator.Play(stateName.Value, num, num2);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the animator in playback mode.")]
	public class AnimatorStartPlayback : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			Animator component = ownerDefaultTarget.GetComponent<Animator>();
			if (component != null)
			{
				component.StartPlayback();
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the animator in recording mode, and allocates a circular buffer of size frameCount. After this call, the recorder starts collecting up to frameCount frames in the buffer. Note it is not possible to start playback until a call to StopRecording is made")]
	public class AnimatorStartRecording : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The number of frames (updates) that will be recorded. If frameCount is 0, the recording will continue until the user calls StopRecording. The maximum value for frameCount is 10000.")]
		public FsmInt frameCount;

		public override void Reset()
		{
			gameObject = null;
			frameCount = 0;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			Animator component = ownerDefaultTarget.GetComponent<Animator>();
			if (component != null)
			{
				component.StartRecording(frameCount.Value);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Stops the animator playback mode. When playback stops, the avatar resumes getting control from game logic")]
	public class AnimatorStopPlayback : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			Animator component = ownerDefaultTarget.GetComponent<Animator>();
			if (component != null)
			{
				component.StopPlayback();
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Stops the animator record mode. It will lock the recording buffer's contents in its current state. The data get saved for subsequent playback with StartPlayback.")]
	public class AnimatorStopRecording : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component and a PlayMakerAnimatorProxy component are required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The recorder StartTime")]
		public FsmFloat recorderStartTime;

		[UIHint(UIHint.Variable)]
		[Tooltip("The recorder StopTime")]
		public FsmFloat recorderStopTime;

		public override void Reset()
		{
			gameObject = null;
			recorderStartTime = null;
			recorderStopTime = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			Animator component = ownerDefaultTarget.GetComponent<Animator>();
			if (component != null)
			{
				component.StopRecording();
				recorderStartTime.Value = component.recorderStartTime;
				recorderStopTime.Value = component.recorderStopTime;
			}
			Finish();
		}
	}
	public abstract class FsmStateActionAnimatorBase : FsmStateAction
	{
		public enum AnimatorFrameUpdateSelector
		{
			OnUpdate,
			OnAnimatorMove,
			OnAnimatorIK
		}

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[Tooltip("Select when to perform the action, during OnUpdate, OnAnimatorMove, OnAnimatorIK")]
		public AnimatorFrameUpdateSelector everyFrameOption;

		protected int IklayerIndex;

		public abstract void OnActionUpdate();

		public override void Reset()
		{
			everyFrame = false;
			everyFrameOption = AnimatorFrameUpdateSelector.OnUpdate;
		}

		public override void OnPreprocess()
		{
			if (everyFrameOption == AnimatorFrameUpdateSelector.OnAnimatorMove)
			{
				base.Fsm.HandleAnimatorMove = true;
			}
			if (everyFrameOption == AnimatorFrameUpdateSelector.OnAnimatorIK)
			{
				base.Fsm.HandleAnimatorIK = true;
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == AnimatorFrameUpdateSelector.OnUpdate)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void DoAnimatorMove()
		{
			if (everyFrameOption == AnimatorFrameUpdateSelector.OnAnimatorMove)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void DoAnimatorIK(int layerIndex)
		{
			IklayerIndex = layerIndex;
			if (everyFrameOption == AnimatorFrameUpdateSelector.OnAnimatorIK)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the value of ApplyRootMotion of an avatar. If true, root is controlled by animations")]
	public class GetAnimatorApplyRootMotion : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Is the rootMotionapplied. If true, root is controlled by animations")]
		public FsmBool rootMotionApplied;

		[Tooltip("Event send if the root motion is applied")]
		public FsmEvent rootMotionIsAppliedEvent;

		[Tooltip("Event send if the root motion is not applied")]
		public FsmEvent rootMotionIsNotAppliedEvent;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			rootMotionApplied = null;
			rootMotionIsAppliedEvent = null;
			rootMotionIsNotAppliedEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetApplyMotionRoot();
			Finish();
		}

		private void GetApplyMotionRoot()
		{
			if (_animator != null)
			{
				bool applyRootMotion = _animator.applyRootMotion;
				rootMotionApplied.Value = applyRootMotion;
				if (applyRootMotion)
				{
					base.Fsm.Event(rootMotionIsAppliedEvent);
				}
				else
				{
					base.Fsm.Event(rootMotionIsNotAppliedEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the avatar body mass center position and rotation. Optionally accepts a GameObject to get the body transform. \nThe position and rotation are local to the gameobject")]
	public class GetAnimatorBody : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The avatar body mass center")]
		public FsmVector3 bodyPosition;

		[UIHint(UIHint.Variable)]
		[Tooltip("The avatar body mass center")]
		public FsmQuaternion bodyRotation;

		[Tooltip("If set, apply the body mass center position and rotation to this gameObject")]
		public FsmGameObject bodyGameObject;

		private Animator _animator;

		private Transform _transform;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			bodyPosition = null;
			bodyRotation = null;
			bodyGameObject = null;
			everyFrame = false;
			everyFrameOption = AnimatorFrameUpdateSelector.OnAnimatorIK;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = bodyGameObject.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
			if (everyFrameOption != AnimatorFrameUpdateSelector.OnAnimatorIK)
			{
				everyFrameOption = AnimatorFrameUpdateSelector.OnAnimatorIK;
			}
		}

		public override void OnActionUpdate()
		{
			DoGetBodyPosition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoGetBodyPosition()
		{
			if (!(_animator == null))
			{
				bodyPosition.Value = _animator.bodyPosition;
				bodyRotation.Value = _animator.bodyRotation;
				if (_transform != null)
				{
					_transform.position = _animator.bodyPosition;
					_transform.rotation = _animator.bodyRotation;
				}
			}
		}

		public override string ErrorCheck()
		{
			if (everyFrameOption != AnimatorFrameUpdateSelector.OnAnimatorIK)
			{
				return "Getting Body Position should only be done in OnAnimatorIK";
			}
			return string.Empty;
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the GameObject mapped to this human bone id")]
	public class GetAnimatorBoneGameObject : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The bone reference")]
		[ObjectType(typeof(HumanBodyBones))]
		public FsmEnum bone;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bone's GameObject")]
		public FsmGameObject boneGameObject;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			bone = HumanBodyBones.Hips;
			boneGameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetBoneTransform();
			Finish();
		}

		private void GetBoneTransform()
		{
			boneGameObject.Value = _animator.GetBoneTransform((HumanBodyBones)(object)bone.Value).gameObject;
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the value of a bool parameter")]
	public class GetAnimatorBool : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.AnimatorBool)]
		[Tooltip("The animator parameter")]
		public FsmString parameter;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The bool value of the animator parameter")]
		public FsmBool result;

		private Animator _animator;

		private int _paramID;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			parameter = null;
			result = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_paramID = Animator.StringToHash(parameter.Value);
			GetParameter();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetParameter();
		}

		private void GetParameter()
		{
			if (_animator != null)
			{
				result.Value = _animator.GetBool(_paramID);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns the culling of this Animator component. Optionally sends events.\nIf true ('AlwaysAnimate'): always animate the entire character. Object is animated even when offscreen.\nIf False ('BasedOnRenderers') animation is disabled when renderers are not visible.")]
	public class GetAnimatorCullingMode : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("If true, always animate the entire character, else animation is disabled when renderers are not visible")]
		public FsmBool alwaysAnimate;

		[Tooltip("Event send if culling mode is 'AlwaysAnimate'")]
		public FsmEvent alwaysAnimateEvent;

		[Tooltip("Event send if culling mode is 'BasedOnRenders'")]
		public FsmEvent basedOnRenderersEvent;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			alwaysAnimate = null;
			alwaysAnimateEvent = null;
			basedOnRenderersEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoCheckCulling();
			Finish();
		}

		private void DoCheckCulling()
		{
			if (!(_animator == null))
			{
				bool flag = _animator.cullingMode == AnimatorCullingMode.AlwaysAnimate;
				alwaysAnimate.Value = flag;
				if (flag)
				{
					base.Fsm.Event(alwaysAnimateEvent);
				}
				else
				{
					base.Fsm.Event(basedOnRenderersEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the current State information on a specified layer")]
	public class GetAnimatorCurrentStateInfo : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The layer's name.")]
		public FsmString name;

		[UIHint(UIHint.Variable)]
		[Tooltip("The layer's name Hash. Obsolete in Unity 5, use fullPathHash or shortPathHash instead, nameHash will be the same as shortNameHash for legacy")]
		public FsmInt nameHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("The full path hash for this state.")]
		public FsmInt fullPathHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("The name Hash. Doest not include the parent layer's name")]
		public FsmInt shortPathHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("The layer's tag hash")]
		public FsmInt tagHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("Is the state looping. All animations in the state must be looping")]
		public FsmBool isStateLooping;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Current duration of the state. In seconds, can vary when the State contains a Blend Tree ")]
		public FsmFloat length;

		[UIHint(UIHint.Variable)]
		[Tooltip("The integer part is the number of time a state has been looped. The fractional part is the % (0-1) of progress in the current loop")]
		public FsmFloat normalizedTime;

		[UIHint(UIHint.Variable)]
		[Tooltip("The integer part is the number of time a state has been looped. This is extracted from the normalizedTime")]
		public FsmInt loopCount;

		[UIHint(UIHint.Variable)]
		[Tooltip("The progress in the current loop. This is extracted from the normalizedTime")]
		public FsmFloat currentLoopProgress;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			name = null;
			nameHash = null;
			fullPathHash = null;
			shortPathHash = null;
			tagHash = null;
			length = null;
			normalizedTime = null;
			isStateLooping = null;
			loopCount = null;
			currentLoopProgress = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetLayerInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetLayerInfo();
		}

		private void GetLayerInfo()
		{
			if (_animator != null)
			{
				AnimatorStateInfo currentAnimatorStateInfo = _animator.GetCurrentAnimatorStateInfo(layerIndex.Value);
				if (!fullPathHash.IsNone)
				{
					fullPathHash.Value = currentAnimatorStateInfo.fullPathHash;
				}
				if (!shortPathHash.IsNone)
				{
					shortPathHash.Value = currentAnimatorStateInfo.shortNameHash;
				}
				if (!nameHash.IsNone)
				{
					nameHash.Value = currentAnimatorStateInfo.shortNameHash;
				}
				if (!name.IsNone)
				{
					name.Value = _animator.GetLayerName(layerIndex.Value);
				}
				if (!tagHash.IsNone)
				{
					tagHash.Value = currentAnimatorStateInfo.tagHash;
				}
				if (!length.IsNone)
				{
					length.Value = currentAnimatorStateInfo.length;
				}
				if (!isStateLooping.IsNone)
				{
					isStateLooping.Value = currentAnimatorStateInfo.loop;
				}
				if (!normalizedTime.IsNone)
				{
					normalizedTime.Value = currentAnimatorStateInfo.normalizedTime;
				}
				if (!loopCount.IsNone || !currentLoopProgress.IsNone)
				{
					loopCount.Value = (int)Math.Truncate(currentAnimatorStateInfo.normalizedTime);
					currentLoopProgress.Value = currentAnimatorStateInfo.normalizedTime - (float)loopCount.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Check the current State name on a specified layer, this is more than the layer name, it holds the current state as well.")]
	public class GetAnimatorCurrentStateInfoIsName : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component and a PlayMakerAnimatorProxy component are required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[Tooltip("The name to check the layer against.")]
		public FsmString name;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if name matches")]
		public FsmBool isMatching;

		[Tooltip("Event send if name matches")]
		public FsmEvent nameMatchEvent;

		[Tooltip("Event send if name doesn't match")]
		public FsmEvent nameDoNotMatchEvent;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			name = null;
			nameMatchEvent = null;
			nameDoNotMatchEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			IsName();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			IsName();
		}

		private void IsName()
		{
			if (_animator != null)
			{
				AnimatorStateInfo currentAnimatorStateInfo = _animator.GetCurrentAnimatorStateInfo(layerIndex.Value);
				if (!isMatching.IsNone)
				{
					isMatching.Value = currentAnimatorStateInfo.IsName(name.Value);
				}
				if (currentAnimatorStateInfo.IsName(name.Value))
				{
					base.Fsm.Event(nameMatchEvent);
				}
				else
				{
					base.Fsm.Event(nameDoNotMatchEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Does tag match the tag of the active state in the statemachine")]
	public class GetAnimatorCurrentStateInfoIsTag : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[Tooltip("The tag to check the layer against.")]
		public FsmString tag;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if tag matches")]
		public FsmBool tagMatch;

		[Tooltip("Event send if tag matches")]
		public FsmEvent tagMatchEvent;

		[Tooltip("Event send if tag matches")]
		public FsmEvent tagDoNotMatchEvent;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			tag = null;
			tagMatch = null;
			tagMatchEvent = null;
			tagDoNotMatchEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			IsTag();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			IsTag();
		}

		private void IsTag()
		{
			if (_animator != null)
			{
				if (_animator.GetCurrentAnimatorStateInfo(layerIndex.Value).IsTag(tag.Value))
				{
					tagMatch.Value = true;
					base.Fsm.Event(tagMatchEvent);
				}
				else
				{
					tagMatch.Value = false;
					base.Fsm.Event(tagDoNotMatchEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the current transition information on a specified layer. Only valid when during a transition.")]
	public class GetAnimatorCurrentTransitionInfo : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The unique name of the Transition")]
		public FsmString name;

		[UIHint(UIHint.Variable)]
		[Tooltip("The unique name of the Transition")]
		public FsmInt nameHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("The user-specified name of the Transition")]
		public FsmInt userNameHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("Normalized time of the Transition")]
		public FsmFloat normalizedTime;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			name = null;
			nameHash = null;
			userNameHash = null;
			normalizedTime = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetTransitionInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetTransitionInfo();
		}

		private void GetTransitionInfo()
		{
			if (_animator != null)
			{
				AnimatorTransitionInfo animatorTransitionInfo = _animator.GetAnimatorTransitionInfo(layerIndex.Value);
				if (!name.IsNone)
				{
					name.Value = _animator.GetLayerName(layerIndex.Value);
				}
				if (!nameHash.IsNone)
				{
					nameHash.Value = animatorTransitionInfo.nameHash;
				}
				if (!userNameHash.IsNone)
				{
					userNameHash.Value = animatorTransitionInfo.userNameHash;
				}
				if (!normalizedTime.IsNone)
				{
					normalizedTime.Value = animatorTransitionInfo.normalizedTime;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Check the active Transition name on a specified layer. Format is 'CURRENT_STATE -> NEXT_STATE'.")]
	public class GetAnimatorCurrentTransitionInfoIsName : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[Tooltip("The name to check the transition against.")]
		public FsmString name;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if name matches")]
		public FsmBool nameMatch;

		[Tooltip("Event send if name matches")]
		public FsmEvent nameMatchEvent;

		[Tooltip("Event send if name doesn't match")]
		public FsmEvent nameDoNotMatchEvent;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			name = null;
			nameMatch = null;
			nameMatchEvent = null;
			nameDoNotMatchEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			IsName();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			IsName();
		}

		private void IsName()
		{
			if (_animator != null)
			{
				if (_animator.GetAnimatorTransitionInfo(layerIndex.Value).IsName(name.Value))
				{
					nameMatch.Value = true;
					base.Fsm.Event(nameMatchEvent);
				}
				else
				{
					nameMatch.Value = false;
					base.Fsm.Event(nameDoNotMatchEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Check the active Transition user-specified name on a specified layer.")]
	public class GetAnimatorCurrentTransitionInfoIsUserName : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[Tooltip("The user-specified name to check the transition against.")]
		public FsmString userName;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if name matches")]
		public FsmBool nameMatch;

		[Tooltip("Event send if name matches")]
		public FsmEvent nameMatchEvent;

		[Tooltip("Event send if name doesn't match")]
		public FsmEvent nameDoNotMatchEvent;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			userName = null;
			nameMatch = null;
			nameMatchEvent = null;
			nameDoNotMatchEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			IsName();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			IsName();
		}

		private void IsName()
		{
			if (_animator != null)
			{
				bool flag = _animator.GetAnimatorTransitionInfo(layerIndex.Value).IsUserName(userName.Value);
				if (!nameMatch.IsNone)
				{
					nameMatch.Value = flag;
				}
				if (flag)
				{
					base.Fsm.Event(nameMatchEvent);
				}
				else
				{
					base.Fsm.Event(nameDoNotMatchEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the avatar delta position and rotation for the last evaluated frame.")]
	public class GetAnimatorDelta : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("The avatar delta position for the last evaluated frame")]
		public FsmVector3 deltaPosition;

		[UIHint(UIHint.Variable)]
		[Tooltip("The avatar delta position for the last evaluated frame")]
		public FsmQuaternion deltaRotation;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			deltaPosition = null;
			deltaRotation = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoGetDeltaPosition();
			Finish();
		}

		public override void OnActionUpdate()
		{
			DoGetDeltaPosition();
		}

		private void DoGetDeltaPosition()
		{
			if (!(_animator == null))
			{
				deltaPosition.Value = _animator.deltaPosition;
				deltaRotation.Value = _animator.deltaRotation;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns the feet pivot. At 0% blending point is body mass center. At 100% blending point is feet pivot")]
	public class GetAnimatorFeetPivotActive : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The feet pivot Blending. At 0% blending point is body mass center. At 100% blending point is feet pivot")]
		public FsmFloat feetPivotActive;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			feetPivotActive = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoGetFeetPivotActive();
			Finish();
		}

		private void DoGetFeetPivotActive()
		{
			if (!(_animator == null))
			{
				feetPivotActive.Value = _animator.feetPivotActive;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the value of a float parameter")]
	public class GetAnimatorFloat : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.AnimatorFloat)]
		[Tooltip("The animator parameter")]
		public FsmString parameter;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float value of the animator parameter")]
		public FsmFloat result;

		private Animator _animator;

		private int _paramID;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			parameter = null;
			result = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_paramID = Animator.StringToHash(parameter.Value);
			GetParameter();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetParameter();
		}

		private void GetParameter()
		{
			if (_animator != null)
			{
				result.Value = _animator.GetFloat(_paramID);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns The current gravity weight based on current animations that are played")]
	public class GetAnimatorGravityWeight : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The current gravity weight based on current animations that are played")]
		public FsmFloat gravityWeight;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			gravityWeight = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoGetGravityWeight();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetGravityWeight();
		}

		private void DoGetGravityWeight()
		{
			if (!(_animator == null))
			{
				gravityWeight.Value = _animator.gravityWeight;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns the scale of the current Avatar for a humanoid rig, (1 by default if the rig is generic).\n The scale is relative to Unity's Default Avatar")]
	public class GetAnimatorHumanScale : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[UIHint(UIHint.Variable)]
		[Tooltip("the scale of the current Avatar")]
		public FsmFloat humanScale;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			humanScale = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoGetHumanScale();
			Finish();
		}

		private void DoGetHumanScale()
		{
			if (!(_animator == null))
			{
				humanScale.Value = _animator.humanScale;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the position, rotation and weights of an IK goal. A GameObject can be set to use for the position and rotation")]
	public class GetAnimatorIKGoal : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The IK goal")]
		[ObjectType(typeof(AvatarIKGoal))]
		public FsmEnum iKGoal;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The gameObject to apply ik goal position and rotation to")]
		public FsmGameObject goal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Gets The position of the ik goal. If Goal GameObject define, position is used as an offset from Goal")]
		public FsmVector3 position;

		[UIHint(UIHint.Variable)]
		[Tooltip("Gets The rotation of the ik goal.If Goal GameObject define, rotation is used as an offset from Goal")]
		public FsmQuaternion rotation;

		[UIHint(UIHint.Variable)]
		[Tooltip("Gets The translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal)")]
		public FsmFloat positionWeight;

		[UIHint(UIHint.Variable)]
		[Tooltip("Gets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal)")]
		public FsmFloat rotationWeight;

		private Animator _animator;

		private Transform _transform;

		private AvatarIKGoal _iKGoal;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			iKGoal = null;
			goal = null;
			position = null;
			rotation = null;
			positionWeight = null;
			rotationWeight = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = goal.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
		}

		public override void OnActionUpdate()
		{
			DoGetIKGoal();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoGetIKGoal()
		{
			if (!(_animator == null))
			{
				_iKGoal = (AvatarIKGoal)(object)iKGoal.Value;
				if (_transform != null)
				{
					_transform.position = _animator.GetIKPosition(_iKGoal);
					_transform.rotation = _animator.GetIKRotation(_iKGoal);
				}
				if (!position.IsNone)
				{
					position.Value = _animator.GetIKPosition(_iKGoal);
				}
				if (!rotation.IsNone)
				{
					rotation.Value = _animator.GetIKRotation(_iKGoal);
				}
				if (!positionWeight.IsNone)
				{
					positionWeight.Value = _animator.GetIKPositionWeight(_iKGoal);
				}
				if (!rotationWeight.IsNone)
				{
					rotationWeight.Value = _animator.GetIKRotationWeight(_iKGoal);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the value of an int parameter")]
	public class GetAnimatorInt : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.AnimatorInt)]
		[Tooltip("The animator parameter")]
		public FsmString parameter;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The int value of the animator parameter")]
		public FsmInt result;

		private Animator _animator;

		private int _paramID;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			parameter = null;
			result = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_paramID = Animator.StringToHash(parameter.Value);
			GetParameter();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetParameter();
		}

		private void GetParameter()
		{
			if (_animator != null)
			{
				result.Value = _animator.GetInteger(_paramID);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns true if the current rig is humanoid, false if it is generic. Can also sends events")]
	public class GetAnimatorIsHuman : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if the current rig is humanoid, False if it is generic")]
		public FsmBool isHuman;

		[Tooltip("Event send if rig is humanoid")]
		public FsmEvent isHumanEvent;

		[Tooltip("Event send if rig is generic")]
		public FsmEvent isGenericEvent;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			isHuman = null;
			isHumanEvent = null;
			isGenericEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoCheckIsHuman();
			Finish();
		}

		private void DoCheckIsHuman()
		{
			if (!(_animator == null))
			{
				bool flag = _animator.isHuman;
				if (!isHuman.IsNone)
				{
					isHuman.Value = flag;
				}
				if (flag)
				{
					base.Fsm.Event(isHumanEvent);
				}
				else
				{
					base.Fsm.Event(isGenericEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns true if the specified layer is in a transition. Can also send events")]
	public class GetAnimatorIsLayerInTransition : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if automatic matching is active")]
		public FsmBool isInTransition;

		[Tooltip("Event send if automatic matching is active")]
		public FsmEvent isInTransitionEvent;

		[Tooltip("Event send if automatic matching is not active")]
		public FsmEvent isNotInTransitionEvent;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			isInTransition = null;
			isInTransitionEvent = null;
			isNotInTransitionEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoCheckIsInTransition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoCheckIsInTransition();
		}

		private void DoCheckIsInTransition()
		{
			if (!(_animator == null))
			{
				bool flag = _animator.IsInTransition(layerIndex.Value);
				if (!isInTransition.IsNone)
				{
					isInTransition.Value = flag;
				}
				if (flag)
				{
					base.Fsm.Event(isInTransitionEvent);
				}
				else
				{
					base.Fsm.Event(isNotInTransitionEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns true if automatic matching is active. Can also send events")]
	public class GetAnimatorIsMatchingTarget : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component and a PlayMakerAnimatorProxy component are required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if automatic matching is active")]
		public FsmBool isMatchingActive;

		[Tooltip("Event send if automatic matching is active")]
		public FsmEvent matchingActivatedEvent;

		[Tooltip("Event send if automatic matching is not active")]
		public FsmEvent matchingDeactivedEvent;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			isMatchingActive = null;
			matchingActivatedEvent = null;
			matchingDeactivedEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoCheckIsMatchingActive();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoCheckIsMatchingActive();
		}

		private void DoCheckIsMatchingActive()
		{
			if (!(_animator == null))
			{
				bool isMatchingTarget = _animator.isMatchingTarget;
				isMatchingActive.Value = isMatchingTarget;
				if (isMatchingTarget)
				{
					base.Fsm.Event(matchingActivatedEvent);
				}
				else
				{
					base.Fsm.Event(matchingDeactivedEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns true if a parameter is controlled by an additional curve on an animation")]
	public class GetAnimatorIsParameterControlledByCurve : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The parameter's name")]
		public FsmString parameterName;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("True if controlled by curve")]
		public FsmBool isControlledByCurve;

		[Tooltip("Event send if controlled by curve")]
		public FsmEvent isControlledByCurveEvent;

		[Tooltip("Event send if not controlled by curve")]
		public FsmEvent isNotControlledByCurveEvent;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			parameterName = null;
			isControlledByCurve = null;
			isControlledByCurveEvent = null;
			isNotControlledByCurveEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoCheckIsParameterControlledByCurve();
			Finish();
		}

		private void DoCheckIsParameterControlledByCurve()
		{
			if (!(_animator == null))
			{
				bool flag = _animator.IsParameterControlledByCurve(parameterName.Value);
				isControlledByCurve.Value = flag;
				if (flag)
				{
					base.Fsm.Event(isControlledByCurveEvent);
				}
				else
				{
					base.Fsm.Event(isNotControlledByCurveEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns the Animator controller layer count")]
	public class GetAnimatorLayerCount : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Animator controller layer count")]
		public FsmInt layerCount;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			layerCount = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoGetLayerCount();
			Finish();
		}

		private void DoGetLayerCount()
		{
			if (!(_animator == null))
			{
				layerCount.Value = _animator.layerCount;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns the name of a layer from its index")]
	public class GetAnimatorLayerName : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer index")]
		public FsmInt layerIndex;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The layer name")]
		public FsmString layerName;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			layerIndex = null;
			layerName = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoGetLayerName();
			Finish();
		}

		private void DoGetLayerName()
		{
			if (!(_animator == null))
			{
				layerName.Value = _animator.GetLayerName(layerIndex.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the layer's current weight")]
	public class GetAnimatorLayerWeight : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The layer's current weight")]
		public FsmFloat layerWeight;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			layerWeight = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetLayerWeight();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetLayerWeight();
		}

		private void GetLayerWeight()
		{
			if (_animator != null)
			{
				layerWeight.Value = _animator.GetLayerWeight(layerIndex.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns if additional layers affects the mass center")]
	public class GetAnimatorLayersAffectMassCenter : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("If true, additional layers affects the mass center")]
		public FsmBool affectMassCenter;

		[Tooltip("Event send if additional layers affects the mass center")]
		public FsmEvent affectMassCenterEvent;

		[Tooltip("Event send if additional layers do no affects the mass center")]
		public FsmEvent doNotAffectMassCenterEvent;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			affectMassCenter = null;
			affectMassCenterEvent = null;
			doNotAffectMassCenterEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			CheckAffectMassCenter();
			Finish();
		}

		private void CheckAffectMassCenter()
		{
			if (!(_animator == null))
			{
				bool layersAffectMassCenter = _animator.layersAffectMassCenter;
				affectMassCenter.Value = layersAffectMassCenter;
				if (layersAffectMassCenter)
				{
					base.Fsm.Event(affectMassCenterEvent);
				}
				else
				{
					base.Fsm.Event(doNotAffectMassCenterEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Get the left foot bottom height.")]
	public class GetAnimatorLeftFootBottomHeight : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("the left foot bottom height.")]
		public FsmFloat leftFootHeight;

		[Tooltip("Repeat every frame. Useful when value is subject to change over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			leftFootHeight = null;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_getLeftFootBottonHeight();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnLateUpdate()
		{
			_getLeftFootBottonHeight();
		}

		private void _getLeftFootBottonHeight()
		{
			if (_animator != null)
			{
				leftFootHeight.Value = _animator.leftFeetBottomHeight;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the next State information on a specified layer")]
	public class GetAnimatorNextStateInfo : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The layer's name.")]
		public FsmString name;

		[UIHint(UIHint.Variable)]
		[Tooltip("The layer's name Hash. Obsolete in Unity 5, use fullPathHash or shortPathHash instead, nameHash will be the same as shortNameHash for legacy")]
		public FsmInt nameHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("The full path hash for this state.")]
		public FsmInt fullPathHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("The name Hash. Doest not include the parent layer's name")]
		public FsmInt shortPathHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("The layer's tag hash")]
		public FsmInt tagHash;

		[UIHint(UIHint.Variable)]
		[Tooltip("Is the state looping. All animations in the state must be looping")]
		public FsmBool isStateLooping;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Current duration of the state. In seconds, can vary when the State contains a Blend Tree ")]
		public FsmFloat length;

		[UIHint(UIHint.Variable)]
		[Tooltip("The integer part is the number of time a state has been looped. The fractional part is the % (0-1) of progress in the current loop")]
		public FsmFloat normalizedTime;

		[UIHint(UIHint.Variable)]
		[Tooltip("The integer part is the number of time a state has been looped. This is extracted from the normalizedTime")]
		public FsmInt loopCount;

		[UIHint(UIHint.Variable)]
		[Tooltip("The progress in the current loop. This is extracted from the normalizedTime")]
		public FsmFloat currentLoopProgress;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			layerIndex = null;
			name = null;
			nameHash = null;
			fullPathHash = null;
			shortPathHash = null;
			tagHash = null;
			length = null;
			normalizedTime = null;
			isStateLooping = null;
			loopCount = null;
			currentLoopProgress = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetLayerInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetLayerInfo();
		}

		private void GetLayerInfo()
		{
			if (_animator != null)
			{
				AnimatorStateInfo nextAnimatorStateInfo = _animator.GetNextAnimatorStateInfo(layerIndex.Value);
				if (!fullPathHash.IsNone)
				{
					fullPathHash.Value = nextAnimatorStateInfo.fullPathHash;
				}
				if (!shortPathHash.IsNone)
				{
					shortPathHash.Value = nextAnimatorStateInfo.shortNameHash;
				}
				if (!nameHash.IsNone)
				{
					nameHash.Value = nextAnimatorStateInfo.shortNameHash;
				}
				if (!name.IsNone)
				{
					name.Value = _animator.GetLayerName(layerIndex.Value);
				}
				if (!tagHash.IsNone)
				{
					tagHash.Value = nextAnimatorStateInfo.tagHash;
				}
				if (!length.IsNone)
				{
					length.Value = nextAnimatorStateInfo.length;
				}
				if (!isStateLooping.IsNone)
				{
					isStateLooping.Value = nextAnimatorStateInfo.loop;
				}
				if (!normalizedTime.IsNone)
				{
					normalizedTime.Value = nextAnimatorStateInfo.normalizedTime;
				}
				if (!loopCount.IsNone || !currentLoopProgress.IsNone)
				{
					loopCount.Value = (int)Math.Truncate(nextAnimatorStateInfo.normalizedTime);
					currentLoopProgress.Value = nextAnimatorStateInfo.normalizedTime - (float)loopCount.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Returns the pivot weight and/or position. The pivot is the most stable point between the avatar's left and right foot.\n For a weight value of 0, the left foot is the most stable point For a value of 1, the right foot is the most stable point")]
	public class GetAnimatorPivot : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The pivot is the most stable point between the avatar's left and right foot.\n For a value of 0, the left foot is the most stable point For a value of 1, the right foot is the most stable point")]
		public FsmFloat pivotWeight;

		[UIHint(UIHint.Variable)]
		[Tooltip("The pivot is the most stable point between the avatar's left and right foot.\n For a value of 0, the left foot is the most stable point For a value of 1, the right foot is the most stable point")]
		public FsmVector3 pivotPosition;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			pivotWeight = null;
			pivotPosition = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoCheckPivot();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoCheckPivot();
		}

		private void DoCheckPivot()
		{
			if (!(_animator == null))
			{
				if (!pivotWeight.IsNone)
				{
					pivotWeight.Value = _animator.pivotWeight;
				}
				if (!pivotPosition.IsNone)
				{
					pivotPosition.Value = _animator.pivotPosition;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the playback speed of the Animator. 1 is normal playback speed")]
	public class GetAnimatorPlayBackSpeed : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The playBack speed of the animator. 1 is normal playback speed")]
		public FsmFloat playBackSpeed;

		[Tooltip("Repeat every frame. Useful when value is subject to change over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			playBackSpeed = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetPlayBackSpeed();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			GetPlayBackSpeed();
		}

		private void GetPlayBackSpeed()
		{
			if (_animator != null)
			{
				playBackSpeed.Value = _animator.speed;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the playback position in the recording buffer. When in playback mode (use  AnimatorStartPlayback), this value is used for controlling the current playback position in the buffer (in seconds). The value can range between recordingStartTime and recordingStopTime See Also: StartPlayback, StopPlayback.")]
	public class GetAnimatorPlayBackTime : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The playBack time of the animator.")]
		public FsmFloat playBackTime;

		[Tooltip("Repeat every frame. Useful when value is subject to change over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			playBackTime = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetPlayBackTime();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			GetPlayBackTime();
		}

		private void GetPlayBackTime()
		{
			if (_animator != null)
			{
				playBackTime.Value = _animator.playbackTime;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Get the right foot bottom height.")]
	public class GetAnimatorRightFootBottomHeight : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Result")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The right foot bottom height.")]
		public FsmFloat rightFootHeight;

		[Tooltip("Repeat every frame during LateUpdate. Useful when value is subject to change over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			rightFootHeight = null;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_getRightFootBottonHeight();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnLateUpdate()
		{
			_getRightFootBottonHeight();
		}

		private void _getRightFootBottonHeight()
		{
			if (_animator != null)
			{
				rightFootHeight.Value = _animator.rightFeetBottomHeight;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the avatar body mass center position and rotation.Optionally accept a GameObject to get the body transform. \nThe position and rotation are local to the gameobject")]
	public class GetAnimatorRoot : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target.")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The avatar body mass center")]
		public FsmVector3 rootPosition;

		[UIHint(UIHint.Variable)]
		[Tooltip("The avatar body mass center")]
		public FsmQuaternion rootRotation;

		[Tooltip("If set, apply the body mass center position and rotation to this gameObject")]
		public FsmGameObject bodyGameObject;

		private Animator _animator;

		private Transform _transform;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			rootPosition = null;
			rootRotation = null;
			bodyGameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = bodyGameObject.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
			DoGetBodyPosition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetBodyPosition();
		}

		private void DoGetBodyPosition()
		{
			if (!(_animator == null))
			{
				rootPosition.Value = _animator.rootPosition;
				rootRotation.Value = _animator.rootRotation;
				if (_transform != null)
				{
					_transform.position = _animator.rootPosition;
					_transform.rotation = _animator.rootRotation;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the playback speed of the Animator. 1 is normal playback speed")]
	public class GetAnimatorSpeed : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The playBack speed of the animator. 1 is normal playback speed")]
		public FsmFloat speed;

		private Animator _animator;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			speed = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GetPlaybackSpeed();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			GetPlaybackSpeed();
		}

		private void GetPlaybackSpeed()
		{
			if (_animator != null)
			{
				speed.Value = _animator.speed;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Gets the position and rotation of the target specified by SetTarget(AvatarTarget targetIndex, float targetNormalizedTime)).\nThe position and rotation are only valid when a frame has being evaluated after the SetTarget call")]
	public class GetAnimatorTarget : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The target position")]
		public FsmVector3 targetPosition;

		[UIHint(UIHint.Variable)]
		[Tooltip("The target rotation")]
		public FsmQuaternion targetRotation;

		[Tooltip("If set, apply the position and rotation to this gameObject")]
		public FsmGameObject targetGameObject;

		private Animator _animator;

		private Transform _transform;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			targetPosition = null;
			targetRotation = null;
			targetGameObject = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = targetGameObject.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
			DoGetTarget();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetTarget();
		}

		private void DoGetTarget()
		{
			if (!(_animator == null))
			{
				targetPosition.Value = _animator.targetPosition;
				targetRotation.Value = _animator.targetRotation;
				if (_transform != null)
				{
					_transform.position = _animator.targetPosition;
					_transform.rotation = _animator.targetRotation;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Synchronize a NavMesh Agent velocity and rotation with the animator process.")]
	public class NavMeshAgentAnimatorSynchronizer : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(NavMeshAgent))]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Agent target. An Animator component and a NavMeshAgent component are required")]
		public FsmOwnerDefault gameObject;

		private Animator _animator;

		private NavMeshAgent _agent;

		private Transform _trans;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleAnimatorMove = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_agent = ownerDefaultTarget.GetComponent<NavMeshAgent>();
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
			}
			else
			{
				_trans = ownerDefaultTarget.transform;
			}
		}

		public override void DoAnimatorMove()
		{
			_agent.velocity = _animator.deltaPosition / Time.deltaTime;
			_trans.rotation = _animator.rootRotation;
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Set Apply Root Motion: If true, Root is controlled by animations")]
	public class SetAnimatorApplyRootMotion : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("If true, Root is controlled by animations")]
		public FsmBool applyRootMotion;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			applyRootMotion = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoApplyRootMotion();
			Finish();
		}

		private void DoApplyRootMotion()
		{
			if (!(_animator == null))
			{
				_animator.applyRootMotion = applyRootMotion.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the position and rotation of the body. A GameObject can be set to control the position and rotation, or it can be manually expressed.")]
	public class SetAnimatorBody : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The gameObject target of the ik goal")]
		public FsmGameObject target;

		[Tooltip("The position of the ik goal. If Goal GameObject set, position is used as an offset from Goal")]
		public FsmVector3 position;

		[Tooltip("The rotation of the ik goal.If Goal GameObject set, rotation is used as an offset from Goal")]
		public FsmQuaternion rotation;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private Animator _animator;

		private Transform _transform;

		public override void Reset()
		{
			gameObject = null;
			target = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			rotation = new FsmQuaternion
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleAnimatorIK = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = target.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
		}

		public override void DoAnimatorIK(int layerIndex)
		{
			DoSetBody();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetBody()
		{
			if (_animator == null)
			{
				return;
			}
			if (_transform != null)
			{
				if (position.IsNone)
				{
					_animator.bodyPosition = _transform.position;
				}
				else
				{
					_animator.bodyPosition = _transform.position + position.Value;
				}
				if (rotation.IsNone)
				{
					_animator.bodyRotation = _transform.rotation;
				}
				else
				{
					_animator.bodyRotation = _transform.rotation * rotation.Value;
				}
			}
			else
			{
				if (!position.IsNone)
				{
					_animator.bodyPosition = position.Value;
				}
				if (!rotation.IsNone)
				{
					_animator.bodyRotation = rotation.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the value of a bool parameter")]
	public class SetAnimatorBool : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.AnimatorBool)]
		[Tooltip("The animator parameter")]
		public FsmString parameter;

		[Tooltip("The Bool value to assign to the animator parameter")]
		public FsmBool Value;

		private Animator _animator;

		private int _paramID;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			parameter = null;
			Value = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_paramID = Animator.StringToHash(parameter.Value);
			SetParameter();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			SetParameter();
		}

		private void SetParameter()
		{
			if (_animator != null)
			{
				_animator.SetBool(_paramID, Value.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Controls culling of this Animator component.\nIf true, set to 'AlwaysAnimate': always animate the entire character. Object is animated even when offscreen.\nIf False, set to 'BasedOnRenderes' or CullUpdateTransforms ( On Unity 5) animation is disabled when renderers are not visible.")]
	public class SetAnimatorCullingMode : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("If true, always animate the entire character, else animation is disabled when renderers are not visible")]
		public FsmBool alwaysAnimate;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			alwaysAnimate = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			SetCullingMode();
			Finish();
		}

		private void SetCullingMode()
		{
			if (!(_animator == null))
			{
				_animator.cullingMode = ((!alwaysAnimate.Value) ? AnimatorCullingMode.CullUpdateTransforms : AnimatorCullingMode.AlwaysAnimate);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Activates feet pivot. At 0% blending point is body mass center. At 100% blending point is feet pivot")]
	public class SetAnimatorFeetPivotActive : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Activates feet pivot. At 0% blending point is body mass center. At 100% blending point is feet pivot")]
		public FsmFloat feetPivotActive;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			feetPivotActive = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoFeetPivotActive();
			Finish();
		}

		private void DoFeetPivotActive()
		{
			if (!(_animator == null))
			{
				_animator.feetPivotActive = feetPivotActive.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the value of a float parameter")]
	public class SetAnimatorFloat : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.AnimatorFloat)]
		[Tooltip("The animator parameter")]
		public FsmString parameter;

		[Tooltip("The float value to assign to the animator parameter")]
		public FsmFloat Value;

		[Tooltip("Optional: The time allowed to parameter to reach the value. Requires everyFrame Checked on")]
		public FsmFloat dampTime;

		private Animator _animator;

		private int _paramID;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			parameter = null;
			dampTime = new FsmFloat
			{
				UseVariable = true
			};
			Value = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_paramID = Animator.StringToHash(parameter.Value);
			SetParameter();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			SetParameter();
		}

		private void SetParameter()
		{
			if (!(_animator == null))
			{
				if (dampTime.Value > 0f)
				{
					_animator.SetFloat(_paramID, Value.Value, dampTime.Value, Time.deltaTime);
				}
				else
				{
					_animator.SetFloat(_paramID, Value.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the position, rotation and weights of an IK goal. A GameObject can be set to control the position and rotation, or it can be manually expressed.")]
	public class SetAnimatorIKGoal : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The IK goal")]
		public AvatarIKGoal iKGoal;

		[Tooltip("The gameObject target of the ik goal")]
		public FsmGameObject goal;

		[Tooltip("The position of the ik goal. If Goal GameObject set, position is used as an offset from Goal")]
		public FsmVector3 position;

		[Tooltip("The rotation of the ik goal.If Goal GameObject set, rotation is used as an offset from Goal")]
		public FsmQuaternion rotation;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("The translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal)")]
		public FsmFloat positionWeight;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Sets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal)")]
		public FsmFloat rotationWeight;

		[Tooltip("Repeat every frame. Useful when changing over time.")]
		public bool everyFrame;

		private Animator _animator;

		private Transform _transform;

		public override void Reset()
		{
			gameObject = null;
			goal = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			rotation = new FsmQuaternion
			{
				UseVariable = true
			};
			positionWeight = 1f;
			rotationWeight = 1f;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleAnimatorIK = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = goal.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
		}

		public override void DoAnimatorIK(int layerIndex)
		{
			DoSetIKGoal();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetIKGoal()
		{
			if (_animator == null)
			{
				return;
			}
			if (_transform != null)
			{
				if (position.IsNone)
				{
					_animator.SetIKPosition(iKGoal, _transform.position);
				}
				else
				{
					_animator.SetIKPosition(iKGoal, _transform.position + position.Value);
				}
				if (rotation.IsNone)
				{
					_animator.SetIKRotation(iKGoal, _transform.rotation);
				}
				else
				{
					_animator.SetIKRotation(iKGoal, _transform.rotation * rotation.Value);
				}
			}
			else
			{
				if (!position.IsNone)
				{
					_animator.SetIKPosition(iKGoal, position.Value);
				}
				if (!rotation.IsNone)
				{
					_animator.SetIKRotation(iKGoal, rotation.Value);
				}
			}
			if (!positionWeight.IsNone)
			{
				_animator.SetIKPositionWeight(iKGoal, positionWeight.Value);
			}
			if (!rotationWeight.IsNone)
			{
				_animator.SetIKRotationWeight(iKGoal, rotationWeight.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the value of a int parameter")]
	public class SetAnimatorInt : FsmStateActionAnimatorBase
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.AnimatorInt)]
		[Tooltip("The animator parameter")]
		public FsmString parameter;

		[Tooltip("The Int value to assign to the animator parameter")]
		public FsmInt Value;

		private Animator _animator;

		private int _paramID;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			parameter = null;
			Value = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			_paramID = Animator.StringToHash(parameter.Value);
			SetParameter();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			SetParameter();
		}

		private void SetParameter()
		{
			if (_animator != null)
			{
				_animator.SetInteger(_paramID, Value.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the layer's current weight")]
	public class SetAnimatorLayerWeight : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The layer's index")]
		public FsmInt layerIndex;

		[RequiredField]
		[Tooltip("Sets the layer's current weight")]
		public FsmFloat layerWeight;

		[Tooltip("Repeat every frame. Useful for changing over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			layerIndex = null;
			layerWeight = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoLayerWeight();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoLayerWeight();
		}

		private void DoLayerWeight()
		{
			if (!(_animator == null))
			{
				_animator.SetLayerWeight(layerIndex.Value, layerWeight.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("If true, additional layers affects the mass center")]
	public class SetAnimatorLayersAffectMassCenter : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("If true, additional layers affects the mass center")]
		public FsmBool affectMassCenter;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			affectMassCenter = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			SetAffectMassCenter();
			Finish();
		}

		private void SetAffectMassCenter()
		{
			if (!(_animator == null))
			{
				_animator.layersAffectMassCenter = affectMassCenter.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets look at position and weights. A GameObject can be set to control the look at position, or it can be manually expressed.")]
	public class SetAnimatorLookAt : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The gameObject to look at")]
		public FsmGameObject target;

		[Tooltip("The look-at position. If Target GameObject set, targetPosition is used as an offset from Target")]
		public FsmVector3 targetPosition;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("The global weight of the LookAt, multiplier for other parameters. Range from 0 to 1")]
		public FsmFloat weight;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("determines how much the body is involved in the LookAt. Range from 0 to 1")]
		public FsmFloat bodyWeight;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("determines how much the head is involved in the LookAt. Range from 0 to 1")]
		public FsmFloat headWeight;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("determines how much the eyes are involved in the LookAt. Range from 0 to 1")]
		public FsmFloat eyesWeight;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).")]
		public FsmFloat clampWeight;

		[Tooltip("Repeat every frame during OnAnimatorIK(). Useful for changing over time.")]
		public bool everyFrame;

		private Animator _animator;

		private Transform _transform;

		public override void Reset()
		{
			gameObject = null;
			target = null;
			targetPosition = new FsmVector3
			{
				UseVariable = true
			};
			weight = 1f;
			bodyWeight = 0.3f;
			headWeight = 0.6f;
			eyesWeight = 1f;
			clampWeight = 0.5f;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleAnimatorIK = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			GameObject value = target.Value;
			if (value != null)
			{
				_transform = value.transform;
			}
		}

		public override void DoAnimatorIK(int layerIndex)
		{
			DoSetLookAt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetLookAt()
		{
			if (_animator == null)
			{
				return;
			}
			if (_transform != null)
			{
				if (targetPosition.IsNone)
				{
					_animator.SetLookAtPosition(_transform.position);
				}
				else
				{
					_animator.SetLookAtPosition(_transform.position + targetPosition.Value);
				}
			}
			else if (!targetPosition.IsNone)
			{
				_animator.SetLookAtPosition(targetPosition.Value);
			}
			if (!clampWeight.IsNone)
			{
				_animator.SetLookAtWeight(weight.Value, bodyWeight.Value, headWeight.Value, eyesWeight.Value, clampWeight.Value);
			}
			else if (!eyesWeight.IsNone)
			{
				_animator.SetLookAtWeight(weight.Value, bodyWeight.Value, headWeight.Value, eyesWeight.Value);
			}
			else if (!headWeight.IsNone)
			{
				_animator.SetLookAtWeight(weight.Value, bodyWeight.Value, headWeight.Value);
			}
			else if (!bodyWeight.IsNone)
			{
				_animator.SetLookAtWeight(weight.Value, bodyWeight.Value);
			}
			else if (!weight.IsNone)
			{
				_animator.SetLookAtWeight(weight.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the playback speed of the Animator. 1 is normal playback speed")]
	public class SetAnimatorPlayBackSpeed : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("If true, automatically stabilize feet during transition and blending")]
		public FsmFloat playBackSpeed;

		[Tooltip("Repeat every frame. Useful for changing over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			playBackSpeed = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoPlayBackSpeed();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoPlayBackSpeed();
		}

		private void DoPlayBackSpeed()
		{
			if (!(_animator == null))
			{
				_animator.speed = playBackSpeed.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the playback position in the recording buffer. When in playback mode (use AnimatorStartPlayback), this value is used for controlling the current playback position in the buffer (in seconds). The value can range between recordingStartTime and recordingStopTime ")]
	public class SetAnimatorPlayBackTime : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The playBack time")]
		public FsmFloat playbackTime;

		[Tooltip("Repeat every frame. Useful for changing over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			playbackTime = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoPlaybackTime();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoPlaybackTime();
		}

		private void DoPlaybackTime()
		{
			if (!(_animator == null))
			{
				_animator.playbackTime = playbackTime.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets the playback speed of the Animator. 1 is normal playback speed")]
	public class SetAnimatorSpeed : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The playBack speed")]
		public FsmFloat speed;

		[Tooltip("Repeat every frame. Useful for changing over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			speed = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoPlaybackSpeed();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoPlaybackSpeed();
		}

		private void DoPlaybackSpeed()
		{
			if (!(_animator == null))
			{
				_animator.speed = speed.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("If true, automatically stabilize feet during transition and blending")]
	public class SetAnimatorStabilizeFeet : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The Target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[Tooltip("If true, automatically stabilize feet during transition and blending")]
		public FsmBool stabilizeFeet;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			stabilizeFeet = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			DoStabilizeFeet();
			Finish();
		}

		private void DoStabilizeFeet()
		{
			if (!(_animator == null))
			{
				_animator.stabilizeFeet = stabilizeFeet.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets an AvatarTarget and a targetNormalizedTime for the current state")]
	public class SetAnimatorTarget : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The avatar target")]
		public AvatarTarget avatarTarget;

		[Tooltip("The current state Time that is queried")]
		public FsmFloat targetNormalizedTime;

		[Tooltip("Repeat every frame during OnAnimatorMove. Useful when changing over time.")]
		public bool everyFrame;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			avatarTarget = AvatarTarget.Body;
			targetNormalizedTime = null;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleAnimatorMove = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			SetTarget();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void DoAnimatorMove()
		{
			SetTarget();
		}

		private void SetTarget()
		{
			if (_animator != null)
			{
				_animator.SetTarget(avatarTarget, targetNormalizedTime.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Animator)]
	[Tooltip("Sets a trigger parameter to active. Triggers are parameters that act mostly like booleans, but get reset to inactive when they are used in a transition.")]
	public class SetAnimatorTrigger : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Animator))]
		[Tooltip("The target. An Animator component is required")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.AnimatorTrigger)]
		[Tooltip("The trigger name")]
		public FsmString trigger;

		private Animator _animator;

		public override void Reset()
		{
			gameObject = null;
			trigger = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			_animator = ownerDefaultTarget.GetComponent<Animator>();
			if (_animator == null)
			{
				Finish();
				return;
			}
			SetTrigger();
			Finish();
		}

		private void SetTrigger()
		{
			if (_animator != null)
			{
				_animator.SetTrigger(trigger.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Application)]
	[Tooltip("Quits the player application.")]
	public class ApplicationQuit : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnEnter()
		{
			UnityEngine.Application.Quit();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Application)]
	[Tooltip("Sets if the Application should play in the background. Useful for servers or testing network games on one machine.")]
	public class ApplicationRunInBackground : FsmStateAction
	{
		public FsmBool runInBackground;

		public override void Reset()
		{
			runInBackground = true;
		}

		public override void OnEnter()
		{
			UnityEngine.Application.runInBackground = runInBackground.Value;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Application)]
	[Tooltip("Gets the Height of the Screen in pixels.")]
	public class GetScreenHeight : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeScreenHeight;

		public override void Reset()
		{
			storeScreenHeight = null;
		}

		public override void OnEnter()
		{
			storeScreenHeight.Value = Screen.height;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Application)]
	[Tooltip("Gets the Width of the Screen in pixels.")]
	public class GetScreenWidth : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeScreenWidth;

		public override void Reset()
		{
			storeScreenWidth = null;
		}

		public override void OnEnter()
		{
			storeScreenWidth.Value = Screen.width;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Application)]
	[Tooltip("Saves a Screenshot. NOTE: Does nothing in Web Player. On Android, the resulting screenshot is available some time later.")]
	public class TakeScreenshot : FsmStateAction
	{
		public enum Destination
		{
			MyPictures,
			PersistentDataPath,
			CustomPath
		}

		[Tooltip("Where to save the screenshot.")]
		public Destination destination;

		[Tooltip("Path used with Custom Path Destination option.")]
		public FsmString customPath;

		[RequiredField]
		public FsmString filename;

		[Tooltip("Add an auto-incremented number to the filename.")]
		public FsmBool autoNumber;

		[Tooltip("Factor by which to increase resolution.")]
		public FsmInt superSize;

		[Tooltip("Log saved file info in Unity console.")]
		public FsmBool debugLog;

		private int screenshotCount;

		public override void Reset()
		{
			destination = Destination.MyPictures;
			filename = "";
			autoNumber = null;
			superSize = null;
			debugLog = null;
		}

		public override void OnEnter()
		{
			if (string.IsNullOrEmpty(filename.Value))
			{
				return;
			}
			string text = (destination switch
			{
				Destination.MyPictures => Environment.GetFolderPath(Environment.SpecialFolder.MyPictures), 
				Destination.PersistentDataPath => UnityEngine.Application.persistentDataPath, 
				Destination.CustomPath => customPath.Value, 
				_ => "", 
			}).Replace("\\", "/") + "/";
			string text2 = text + filename.Value + ".png";
			if (autoNumber.Value)
			{
				while (File.Exists(text2))
				{
					screenshotCount++;
					text2 = text + filename.Value + screenshotCount + ".png";
				}
			}
			if (debugLog.Value)
			{
				UnityEngine.Debug.Log("TakeScreenshot: " + text2);
			}
			ScreenCapture.CaptureScreenshot(text2, superSize.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Add an item to the end of an Array.")]
	public class ArrayAdd : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to use.")]
		public FsmArray array;

		[RequiredField]
		[MatchElementType("array")]
		[Tooltip("Item to add.")]
		public FsmVar value;

		public override void Reset()
		{
			array = null;
			value = null;
		}

		public override void OnEnter()
		{
			DoAddValue();
			Finish();
		}

		private void DoAddValue()
		{
			array.Resize(array.Length + 1);
			value.UpdateValue();
			array.Set(array.Length - 1, value.GetValue());
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Add values to an array.")]
	public class ArrayAddRange : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to use.")]
		public FsmArray array;

		[RequiredField]
		[MatchElementType("array")]
		[Tooltip("The variables to add.")]
		public FsmVar[] variables;

		public override void Reset()
		{
			array = null;
			variables = new FsmVar[2];
		}

		public override void OnEnter()
		{
			DoAddRange();
			Finish();
		}

		private void DoAddRange()
		{
			int num = variables.Length;
			if (num > 0)
			{
				this.array.Resize(this.array.Length + num);
				FsmVar[] array = variables;
				foreach (FsmVar fsmVar in array)
				{
					fsmVar.UpdateValue();
					this.array.Set(this.array.Length - num, fsmVar.GetValue());
					num--;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Sets all items in an Array to their default value: 0, empty string, false, or null depending on their type. Optionally defines a reset value to use.")]
	public class ArrayClear : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to clear.")]
		public FsmArray array;

		[MatchElementType("array")]
		[Tooltip("Optional reset value. Leave as None for default value.")]
		public FsmVar resetValue;

		public override void Reset()
		{
			array = null;
			resetValue = new FsmVar
			{
				useVariable = true
			};
		}

		public override void OnEnter()
		{
			int length = array.Length;
			array.Reset();
			array.Resize(length);
			if (!resetValue.IsNone)
			{
				resetValue.UpdateValue();
				object value = resetValue.GetValue();
				for (int i = 0; i < length; i++)
				{
					array.Set(i, value);
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if 2 Array Variables have the same values.")]
	public class ArrayCompare : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The first Array Variable to test.")]
		public FsmArray array1;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The second Array Variable to test.")]
		public FsmArray array2;

		[Tooltip("Event to send if the 2 arrays have the same values.")]
		public FsmEvent SequenceEqual;

		[Tooltip("Event to send if the 2 arrays have different values.")]
		public FsmEvent SequenceNotEqual;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a Bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			array1 = null;
			array2 = null;
			SequenceEqual = null;
			SequenceNotEqual = null;
		}

		public override void OnEnter()
		{
			DoSequenceEqual();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSequenceEqual()
		{
			if (array1.Values != null && array2.Values != null)
			{
				storeResult.Value = TestSequenceEqual(array1.Values, array2.Values);
				base.Fsm.Event(storeResult.Value ? SequenceEqual : SequenceNotEqual);
			}
		}

		private bool TestSequenceEqual(object[] _array1, object[] _array2)
		{
			if (_array1.Length != _array2.Length)
			{
				return false;
			}
			for (int i = 0; i < array1.Length; i++)
			{
				if (!_array1[i].Equals(_array2[i]))
				{
					return false;
				}
			}
			return true;
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Check if an Array contains a value. Optionally get its index.")]
	public class ArrayContains : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to use.")]
		public FsmArray array;

		[RequiredField]
		[MatchElementType("array")]
		[Tooltip("The value to check against in the array.")]
		public FsmVar value;

		[ActionSection("Result")]
		[Tooltip("The index of the value in the array.")]
		[UIHint(UIHint.Variable)]
		public FsmInt index;

		[Tooltip("Store in a bool whether it contains that element or not (described below)")]
		[UIHint(UIHint.Variable)]
		public FsmBool isContained;

		[Tooltip("Event sent if the array contains that element (described below)")]
		public FsmEvent isContainedEvent;

		[Tooltip("Event sent if the array does not contains that element (described below)")]
		public FsmEvent isNotContainedEvent;

		public override void Reset()
		{
			array = null;
			value = null;
			index = null;
			isContained = null;
			isContainedEvent = null;
			isNotContainedEvent = null;
		}

		public override void OnEnter()
		{
			DoCheckContainsValue();
			Finish();
		}

		private void DoCheckContainsValue()
		{
			value.UpdateValue();
			int num = -1;
			num = ((value.GetValue() != null && !value.GetValue().Equals(null)) ? Array.IndexOf(array.Values, value.GetValue()) : Array.FindIndex(array.Values, (object x) => x?.Equals(null) ?? true));
			bool flag = num != -1;
			isContained.Value = flag;
			index.Value = num;
			if (flag)
			{
				base.Fsm.Event(isContainedEvent);
			}
			else
			{
				base.Fsm.Event(isNotContainedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Delete the item at an index. Index must be between 0 and the number of items -1. First item is index 0.")]
	public class ArrayDeleteAt : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to use.")]
		public FsmArray array;

		[Tooltip("The index into the array.")]
		public FsmInt index;

		[ActionSection("Result")]
		[Tooltip("The event to trigger if the index is out of range")]
		public FsmEvent indexOutOfRangeEvent;

		public override void Reset()
		{
			array = null;
			index = null;
			indexOutOfRangeEvent = null;
		}

		public override void OnEnter()
		{
			DoDeleteAt();
			Finish();
		}

		private void DoDeleteAt()
		{
			if (index.Value >= 0 && index.Value < array.Length)
			{
				List<object> list = new List<object>(array.Values);
				list.RemoveAt(index.Value);
				array.Values = list.ToArray();
			}
			else
			{
				base.Fsm.Event(indexOutOfRangeEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Iterate through the items in an Array and run an FSM on each item. NOTE: The FSM has to Finish before being run on the next item.")]
	public class ArrayForEach : RunFSMAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Array to iterate through.")]
		public FsmArray array;

		[HideTypeFilter]
		[MatchElementType("array")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the item in a variable")]
		public FsmVar storeItem;

		[ActionSection("Run FSM")]
		public FsmTemplateControl fsmTemplateControl = new FsmTemplateControl();

		[Tooltip("Event to send after iterating through all items in the Array.")]
		public FsmEvent finishEvent;

		private int currentIndex;

		public override void Reset()
		{
			array = null;
			fsmTemplateControl = new FsmTemplateControl();
			runFsm = null;
		}

		public override void Awake()
		{
			if (array != null && fsmTemplateControl.fsmTemplate != null && UnityEngine.Application.isPlaying)
			{
				runFsm = base.Fsm.CreateSubFsm(fsmTemplateControl);
			}
		}

		public override void OnEnter()
		{
			if (array == null || runFsm == null)
			{
				Finish();
				return;
			}
			currentIndex = 0;
			StartFsm();
		}

		public override void OnUpdate()
		{
			runFsm.Update();
			if (runFsm.Finished)
			{
				StartNextFsm();
			}
		}

		public override void OnFixedUpdate()
		{
			runFsm.FixedUpdate();
			if (runFsm.Finished)
			{
				StartNextFsm();
			}
		}

		public override void OnLateUpdate()
		{
			runFsm.LateUpdate();
			if (runFsm.Finished)
			{
				StartNextFsm();
			}
		}

		private void StartNextFsm()
		{
			currentIndex++;
			StartFsm();
		}

		private void StartFsm()
		{
			while (currentIndex < array.Length)
			{
				DoStartFsm();
				if (!runFsm.Finished)
				{
					return;
				}
				currentIndex++;
			}
			base.Fsm.Event(finishEvent);
			Finish();
		}

		private void DoStartFsm()
		{
			storeItem.SetValue(array.Values[currentIndex]);
			fsmTemplateControl.UpdateValues();
			fsmTemplateControl.ApplyOverrides(runFsm);
			runFsm.OnEnable();
			if (!runFsm.Started)
			{
				runFsm.Start();
			}
		}

		protected override void CheckIfFinished()
		{
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Get a value at an index. Index must be between 0 and the number of items -1. First item is index 0.")]
	public class ArrayGet : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to use.")]
		public FsmArray array;

		[Tooltip("The index into the array.")]
		public FsmInt index;

		[RequiredField]
		[MatchElementType("array")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the value in a variable.")]
		public FsmVar storeValue;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		[ActionSection("Events")]
		[Tooltip("The event to trigger if the index is out of range")]
		public FsmEvent indexOutOfRange;

		public override void Reset()
		{
			array = null;
			index = null;
			everyFrame = false;
			storeValue = null;
			indexOutOfRange = null;
		}

		public override void OnEnter()
		{
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (!array.IsNone && !storeValue.IsNone)
			{
				if (index.Value >= 0 && index.Value < array.Length)
				{
					storeValue.SetValue(array.Get(index.Value));
				}
				else
				{
					base.Fsm.Event(indexOutOfRange);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Each time this action is called it gets the next item from a Array. \nThis lets you quickly loop through all the items of an array to perform actions on them.")]
	public class ArrayGetNext : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to use.")]
		public FsmArray array;

		[Tooltip("From where to start iteration, leave as 0 to start from the beginning")]
		public FsmInt startIndex;

		[Tooltip("When to end iteration, leave as 0 to iterate until the end")]
		public FsmInt endIndex;

		[Tooltip("Event to send to get the next item.")]
		public FsmEvent loopEvent;

		[Tooltip("If you want to reset the iteration, raise this flag to true when you enter the state, it will indicate you want to start from the beginning again")]
		[UIHint(UIHint.Variable)]
		public FsmBool resetFlag;

		[Tooltip("Event to send when there are no more items.")]
		public FsmEvent finishedEvent;

		[ActionSection("Result")]
		[MatchElementType("array")]
		[UIHint(UIHint.Variable)]
		public FsmVar result;

		[UIHint(UIHint.Variable)]
		public FsmInt currentIndex;

		private int nextItemIndex;

		public override void Reset()
		{
			array = null;
			startIndex = null;
			endIndex = null;
			currentIndex = null;
			loopEvent = null;
			finishedEvent = null;
			resetFlag = null;
			result = null;
		}

		public override void OnEnter()
		{
			if (nextItemIndex == 0 && startIndex.Value > 0)
			{
				nextItemIndex = startIndex.Value;
			}
			if (resetFlag.Value)
			{
				nextItemIndex = startIndex.Value;
				resetFlag.Value = false;
			}
			DoGetNextItem();
			Finish();
		}

		private void DoGetNextItem()
		{
			if (nextItemIndex >= array.Length)
			{
				nextItemIndex = 0;
				currentIndex.Value = array.Length - 1;
				base.Fsm.Event(finishedEvent);
				return;
			}
			result.SetValue(array.Get(nextItemIndex));
			if (nextItemIndex >= array.Length)
			{
				nextItemIndex = 0;
				currentIndex.Value = array.Length - 1;
				base.Fsm.Event(finishedEvent);
				return;
			}
			if (endIndex.Value > 0 && nextItemIndex >= endIndex.Value)
			{
				nextItemIndex = 0;
				currentIndex.Value = endIndex.Value;
				base.Fsm.Event(finishedEvent);
				return;
			}
			nextItemIndex++;
			currentIndex.Value = nextItemIndex - 1;
			if (loopEvent != null)
			{
				base.Fsm.Event(loopEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Get a Random item from an Array.")]
	public class ArrayGetRandom : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array to use.")]
		public FsmArray array;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the value in a variable.")]
		[MatchElementType("array")]
		public FsmVar storeValue;

		[Tooltip("The index of the value in the array.")]
		[UIHint(UIHint.Variable)]
		public FsmInt index;

		[Tooltip("Don't get the same item twice in a row.")]
		public FsmBool noRepeat;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		private int randomIndex;

		private int lastIndex = -1;

		public override void Reset()
		{
			array = null;
			storeValue = null;
			index = null;
			everyFrame = false;
			noRepeat = false;
		}

		public override void OnEnter()
		{
			DoGetRandomValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetRandomValue();
		}

		private void DoGetRandomValue()
		{
			if (storeValue.IsNone)
			{
				return;
			}
			if (!noRepeat.Value || array.Length == 1)
			{
				randomIndex = UnityEngine.Random.Range(0, array.Length);
			}
			else
			{
				do
				{
					randomIndex = UnityEngine.Random.Range(0, array.Length);
				}
				while (randomIndex == lastIndex);
				lastIndex = randomIndex;
			}
			index.Value = randomIndex;
			storeValue.SetValue(array.Get(index.Value));
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Gets the number of items in an Array.")]
	public class ArrayLength : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable.")]
		public FsmArray array;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the length in an Int Variable.")]
		public FsmInt length;

		[Tooltip("Repeat every frame. Useful if the array is changing and you're waiting for a particular length.")]
		public bool everyFrame;

		public override void Reset()
		{
			array = null;
			length = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			length.Value = array.Length;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			length.Value = array.Length;
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Resize an array.")]
	public class ArrayResize : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to resize")]
		public FsmArray array;

		[Tooltip("The new size of the array.")]
		public FsmInt newSize;

		[Tooltip("The event to trigger if the new size is out of range")]
		public FsmEvent sizeOutOfRangeEvent;

		public override void OnEnter()
		{
			if (newSize.Value >= 0)
			{
				array.Resize(newSize.Value);
			}
			else
			{
				LogError("Size out of range: " + newSize.Value);
				base.Fsm.Event(sizeOutOfRangeEvent);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Reverse the order of items in an Array.")]
	public class ArrayReverse : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array to reverse.")]
		public FsmArray array;

		public override void Reset()
		{
			array = null;
		}

		public override void OnEnter()
		{
			List<object> list = new List<object>(array.Values);
			list.Reverse();
			array.Values = list.ToArray();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Set the value at an index. Index must be between 0 and the number of items -1. First item is index 0.")]
	public class ArraySet : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable to use.")]
		public FsmArray array;

		[Tooltip("The index into the array.")]
		public FsmInt index;

		[RequiredField]
		[MatchElementType("array")]
		[Tooltip("Set the value of the array at the specified index.")]
		public FsmVar value;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		[ActionSection("Events")]
		[Tooltip("The event to trigger if the index is out of range")]
		public FsmEvent indexOutOfRange;

		public override void Reset()
		{
			array = null;
			index = null;
			value = null;
			everyFrame = false;
			indexOutOfRange = null;
		}

		public override void OnEnter()
		{
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (!array.IsNone)
			{
				if (index.Value >= 0 && index.Value < array.Length)
				{
					value.UpdateValue();
					array.Set(index.Value, value.GetValue());
				}
				else
				{
					base.Fsm.Event(indexOutOfRange);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Shuffle values in an array. Optionally set a start index and range to shuffle only part of the array.")]
	public class ArrayShuffle : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array to shuffle.")]
		public FsmArray array;

		[Tooltip("Optional start Index for the shuffling. Leave it to none or 0 for no effect")]
		public FsmInt startIndex;

		[Tooltip("Optional range for the shuffling, starting at the start index if greater than 0. Leave it to none or 0 for no effect, it will shuffle the whole array")]
		public FsmInt shufflingRange;

		public override void Reset()
		{
			array = null;
			startIndex = new FsmInt
			{
				UseVariable = true
			};
			shufflingRange = new FsmInt
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			List<object> list = new List<object>(array.Values);
			int num = 0;
			int num2 = list.Count - 1;
			if (startIndex.Value > 0)
			{
				num = Mathf.Min(startIndex.Value, num2);
			}
			if (shufflingRange.Value > 0)
			{
				num2 = Mathf.Min(list.Count - 1, num + shufflingRange.Value);
			}
			for (int num3 = num2; num3 > num; num3--)
			{
				int index = UnityEngine.Random.Range(num, num3 + 1);
				object value = list[num3];
				list[num3] = list[index];
				list[index] = value;
			}
			array.Values = list.ToArray();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Sort items in an Array.")]
	public class ArraySort : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array to sort.")]
		public FsmArray array;

		public override void Reset()
		{
			array = null;
		}

		public override void OnEnter()
		{
			List<object> list = new List<object>(array.Values);
			list.Sort();
			array.Values = list.ToArray();
			Finish();
		}
	}
	[NoActionTargets]
	[ActionCategory(ActionCategory.Array)]
	[Tooltip("Transfer a value from one array to another, basically a copy/cut paste action on steroids.")]
	public class ArrayTransferValue : FsmStateAction
	{
		public enum ArrayTransferType
		{
			Copy,
			Cut,
			nullify
		}

		public enum ArrayPasteType
		{
			AsFirstItem,
			AsLastItem,
			InsertAtSameIndex,
			ReplaceAtSameIndex
		}

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable source.")]
		public FsmArray arraySource;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Array Variable target.")]
		public FsmArray arrayTarget;

		[MatchFieldType("array")]
		[Tooltip("The index to transfer.")]
		public FsmInt indexToTransfer;

		[ActionSection("Transfer Options")]
		[ObjectType(typeof(ArrayTransferType))]
		public FsmEnum copyType;

		[ObjectType(typeof(ArrayPasteType))]
		public FsmEnum pasteType;

		[ActionSection("Result")]
		[Tooltip("Event sent if this array source does not contains that element (described below)")]
		public FsmEvent indexOutOfRange;

		public override void Reset()
		{
			arraySource = null;
			arrayTarget = null;
			indexToTransfer = null;
			copyType = ArrayTransferType.Copy;
			pasteType = ArrayPasteType.AsLastItem;
		}

		public override void OnEnter()
		{
			DoTransferValue();
			Finish();
		}

		private void DoTransferValue()
		{
			if (arraySource.IsNone || arrayTarget.IsNone)
			{
				return;
			}
			int value = indexToTransfer.Value;
			if (value < 0 || value >= arraySource.Length)
			{
				base.Fsm.Event(indexOutOfRange);
				return;
			}
			object obj = arraySource.Values[value];
			if ((ArrayTransferType)(object)copyType.Value == ArrayTransferType.Cut)
			{
				List<object> list = new List<object>(arraySource.Values);
				list.RemoveAt(value);
				arraySource.Values = list.ToArray();
			}
			else if ((ArrayTransferType)(object)copyType.Value == ArrayTransferType.nullify)
			{
				arraySource.Values.SetValue(null, value);
			}
			if ((ArrayPasteType)(object)pasteType.Value == ArrayPasteType.AsFirstItem)
			{
				List<object> list2 = new List<object>(arrayTarget.Values);
				list2.Insert(0, obj);
				arrayTarget.Values = list2.ToArray();
			}
			else if ((ArrayPasteType)(object)pasteType.Value == ArrayPasteType.AsLastItem)
			{
				arrayTarget.Resize(arrayTarget.Length + 1);
				arrayTarget.Set(arrayTarget.Length - 1, obj);
			}
			else if ((ArrayPasteType)(object)pasteType.Value == ArrayPasteType.InsertAtSameIndex)
			{
				if (value >= arrayTarget.Length)
				{
					base.Fsm.Event(indexOutOfRange);
				}
				List<object> list3 = new List<object>(arrayTarget.Values);
				list3.Insert(value, obj);
				arrayTarget.Values = list3.ToArray();
			}
			else if ((ArrayPasteType)(object)pasteType.Value == ArrayPasteType.ReplaceAtSameIndex)
			{
				if (value >= arrayTarget.Length)
				{
					base.Fsm.Event(indexOutOfRange);
				}
				else
				{
					arrayTarget.Set(value, obj);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Array)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Obsolete("This action was wip and accidentally released.")]
	[Tooltip("Set an item in an Array Variable in another FSM.")]
	public class FsmArraySet : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object.")]
		public FsmString fsmName;

		[RequiredField]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[Tooltip("Set the value of the variable.")]
		public FsmString setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmString()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmString fsmString = fsm.FsmVariables.GetFsmString(variableName.Value);
			if (fsmString != null)
			{
				fsmString.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmString();
		}
	}
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Copy an Array Variable from another FSM.")]
	public class GetFsmArray : BaseFsmVariableAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object.")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmArray)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Get the content of the array variable.")]
		[UIHint(UIHint.Variable)]
		public FsmArray storeValue;

		[Tooltip("If true, makes copies. if false, values share the same reference and editing one array item value will affect the source and vice versa. Warning, this only affect the current items of the source array. Adding or removing items doesn't affect other FsmArrays.")]
		public bool copyValues;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = null;
			storeValue = null;
			copyValues = true;
		}

		public override void OnEnter()
		{
			DoSetFsmArrayCopy();
			Finish();
		}

		private void DoSetFsmArrayCopy()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget, fsmName.Value))
			{
				return;
			}
			FsmArray fsmArray = fsm.FsmVariables.GetFsmArray(variableName.Value);
			if (fsmArray != null)
			{
				if (fsmArray.ElementType != storeValue.ElementType)
				{
					LogError(string.Concat("Can only copy arrays with the same elements type. Found <", fsmArray.ElementType, "> and <", storeValue.ElementType, ">"));
				}
				else
				{
					storeValue.Resize(0);
					if (copyValues)
					{
						storeValue.Values = fsmArray.Values.Clone() as object[];
					}
					else
					{
						storeValue.Values = fsmArray.Values;
					}
					storeValue.SaveChanges();
				}
			}
			else
			{
				DoVariableNotFound(variableName.Value);
			}
		}
	}
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Gets an item in an Array Variable in another FSM.")]
	public class GetFsmArrayItem : BaseFsmVariableIndexAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object.")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmArray)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[Tooltip("The index into the array.")]
		public FsmInt index;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the value of the array at the specified index.")]
		public FsmVar storeValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmArray();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoGetFsmArray()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget, fsmName.Value))
			{
				return;
			}
			FsmArray fsmArray = fsm.FsmVariables.GetFsmArray(variableName.Value);
			if (fsmArray != null)
			{
				if (index.Value < 0 || index.Value >= fsmArray.Length)
				{
					base.Fsm.Event(indexOutOfRange);
					Finish();
				}
				else if (fsmArray.ElementType == storeValue.NamedVar.VariableType)
				{
					storeValue.SetValue(fsmArray.Get(index.Value));
				}
				else
				{
					LogWarning("Incompatible variable type: " + variableName.Value);
				}
			}
			else
			{
				DoVariableNotFound(variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmArray();
		}
	}
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Copy an Array Variable in another FSM.")]
	public class SetFsmArray : BaseFsmVariableAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object.")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmArray)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the content of the array variable.")]
		[UIHint(UIHint.Variable)]
		public FsmArray setValue;

		[Tooltip("If true, makes copies. if false, values share the same reference and editing one array item value will affect the source and vice versa. Warning, this only affect the current items of the source array. Adding or removing items doesn't affect other FsmArrays.")]
		public bool copyValues;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = null;
			setValue = null;
			copyValues = true;
		}

		public override void OnEnter()
		{
			DoSetFsmArrayCopy();
			Finish();
		}

		private void DoSetFsmArrayCopy()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget, fsmName.Value))
			{
				return;
			}
			FsmArray fsmArray = fsm.FsmVariables.GetFsmArray(variableName.Value);
			if (fsmArray != null)
			{
				if (fsmArray.ElementType != setValue.ElementType)
				{
					LogError(string.Concat("Can only copy arrays with the same elements type. Found <", fsmArray.ElementType, "> and <", setValue.ElementType, ">"));
				}
				else
				{
					fsmArray.Resize(0);
					if (copyValues)
					{
						fsmArray.Values = setValue.Values.Clone() as object[];
					}
					else
					{
						fsmArray.Values = setValue.Values;
					}
					fsmArray.SaveChanges();
				}
			}
			else
			{
				DoVariableNotFound(variableName.Value);
			}
		}
	}
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set an item in an Array Variable in another FSM.")]
	public class SetFsmArrayItem : BaseFsmVariableIndexAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object.")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmArray)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[Tooltip("The index into the array.")]
		public FsmInt index;

		[RequiredField]
		[Tooltip("Set the value of the array at the specified index.")]
		public FsmVar value;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			value = null;
		}

		public override void OnEnter()
		{
			DoSetFsmArray();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmArray()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget, fsmName.Value))
			{
				return;
			}
			FsmArray fsmArray = fsm.FsmVariables.GetFsmArray(variableName.Value);
			if (fsmArray != null)
			{
				if (index.Value < 0 || index.Value >= fsmArray.Length)
				{
					base.Fsm.Event(indexOutOfRange);
					Finish();
				}
				else if (fsmArray.ElementType == value.NamedVar.VariableType)
				{
					value.UpdateValue();
					fsmArray.Set(index.Value, value.GetValue());
				}
				else
				{
					LogWarning("Incompatible variable type: " + variableName.Value);
				}
			}
			else
			{
				DoVariableNotFound(variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmArray();
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Mute/unmute the Audio Clip played by an Audio Source component on a Game Object.")]
	public class AudioMute : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		[Tooltip("The GameObject with an Audio Source component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Check to mute, uncheck to unmute.")]
		public FsmBool mute;

		public override void Reset()
		{
			gameObject = null;
			mute = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				AudioSource component = ownerDefaultTarget.GetComponent<AudioSource>();
				if (component != null)
				{
					component.mute = mute.Value;
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Pauses playing the Audio Clip played by an Audio Source component on a Game Object.")]
	public class AudioPause : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		[Tooltip("The GameObject with an Audio Source component.")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				AudioSource component = ownerDefaultTarget.GetComponent<AudioSource>();
				if (component != null)
				{
					component.Pause();
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[ActionTarget(typeof(AudioSource), "gameObject", false)]
	[ActionTarget(typeof(AudioClip), "oneShotClip", false)]
	[Tooltip("Plays the Audio Clip set with Set Audio Clip or in the Audio Source inspector on a Game Object. Optionally plays a one shot Audio Clip.")]
	public class AudioPlay : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		[Tooltip("The GameObject with an AudioSource component.")]
		public FsmOwnerDefault gameObject;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Set the volume.")]
		public FsmFloat volume;

		[ObjectType(typeof(AudioClip))]
		[Tooltip("Optionally play a 'one shot' AudioClip. NOTE: Volume cannot be adjusted while playing a 'one shot' AudioClip.")]
		public FsmObject oneShotClip;

		[Tooltip("Wait until the end of the clip to send the Finish Event. Set to false to send the finish event immediately.")]
		public FsmBool WaitForEndOfClip;

		[Tooltip("Event to send when the action finishes.")]
		public FsmEvent finishedEvent;

		private AudioSource audio;

		public override void Reset()
		{
			gameObject = null;
			volume = 1f;
			oneShotClip = null;
			finishedEvent = null;
			WaitForEndOfClip = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				audio = ownerDefaultTarget.GetComponent<AudioSource>();
				if (audio != null)
				{
					AudioClip audioClip = oneShotClip.Value as AudioClip;
					if (audioClip == null)
					{
						audio.Play();
						if (!volume.IsNone)
						{
							audio.volume = volume.Value;
						}
						if (!WaitForEndOfClip.Value)
						{
							base.Fsm.Event(finishedEvent);
							Finish();
						}
					}
					else
					{
						if (!volume.IsNone)
						{
							audio.PlayOneShot(audioClip, volume.Value);
						}
						else
						{
							audio.PlayOneShot(audioClip);
						}
						if (!WaitForEndOfClip.Value)
						{
							base.Fsm.Event(finishedEvent);
							Finish();
						}
					}
					return;
				}
			}
			Finish();
		}

		public override void OnUpdate()
		{
			if (audio == null)
			{
				Finish();
			}
			else if (!audio.isPlaying)
			{
				base.Fsm.Event(finishedEvent);
				Finish();
			}
			else if (!volume.IsNone && volume.Value != audio.volume)
			{
				audio.volume = volume.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Stops playing the Audio Clip played by an Audio Source component on a Game Object.")]
	public class AudioStop : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		[Tooltip("The GameObject with an AudioSource component.")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				AudioSource component = ownerDefaultTarget.GetComponent<AudioSource>();
				if (component != null)
				{
					component.Stop();
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Plays a Random Audio Clip at a position defined by a Game Object or a Vector3. If a position is defined, it takes priority over the game object. You can set the relative weight of the clips to control how often they are selected.")]
	public class PlayRandomSound : FsmStateAction
	{
		[Tooltip("The GameObject to play the sound.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Use world position instead of GameObject.")]
		public FsmVector3 position;

		[CompoundArray("Audio Clips", "Audio Clip", "Weight")]
		[ObjectType(typeof(AudioClip))]
		public FsmObject[] audioClips;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat volume = 1f;

		[Tooltip("Don't play the same sound twice in a row")]
		public FsmBool noRepeat;

		private int randomIndex;

		private int lastIndex = -1;

		public override void Reset()
		{
			gameObject = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			audioClips = new FsmObject[3];
			weights = new FsmFloat[3] { 1f, 1f, 1f };
			volume = 1f;
			noRepeat = false;
		}

		public override void OnEnter()
		{
			DoPlayRandomClip();
			Finish();
		}

		private void DoPlayRandomClip()
		{
			if (audioClips.Length == 0)
			{
				return;
			}
			if (!noRepeat.Value || weights.Length == 1)
			{
				randomIndex = ActionHelpers.GetRandomWeightedIndex(weights);
			}
			else
			{
				do
				{
					randomIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				}
				while (randomIndex == lastIndex && randomIndex != -1);
				lastIndex = randomIndex;
			}
			if (randomIndex == -1)
			{
				return;
			}
			AudioClip audioClip = audioClips[randomIndex].Value as AudioClip;
			if (!(audioClip != null))
			{
				return;
			}
			if (!position.IsNone)
			{
				AudioSource.PlayClipAtPoint(audioClip, position.Value, volume.Value);
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				AudioSource.PlayClipAtPoint(audioClip, ownerDefaultTarget.transform.position, volume.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Plays an Audio Clip at a position defined by a Game Object or Vector3. If a position is defined, it takes priority over the game object. This action doesn't require an Audio Source component, but offers less control than Audio actions.")]
	public class PlaySound : FsmStateAction
	{
		public FsmOwnerDefault gameObject;

		public FsmVector3 position;

		[RequiredField]
		[Title("Audio Clip")]
		[ObjectType(typeof(AudioClip))]
		public FsmObject clip;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat volume = 1f;

		public override void Reset()
		{
			gameObject = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			clip = null;
			volume = 1f;
		}

		public override void OnEnter()
		{
			DoPlaySound();
			Finish();
		}

		private void DoPlaySound()
		{
			AudioClip audioClip = clip.Value as AudioClip;
			if (audioClip == null)
			{
				LogWarning("Missing Audio Clip!");
				return;
			}
			if (!position.IsNone)
			{
				AudioSource.PlayClipAtPoint(audioClip, position.Value, volume.Value);
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				AudioSource.PlayClipAtPoint(audioClip, ownerDefaultTarget.transform.position, volume.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Sets the Audio Clip played by the AudioSource component on a Game Object.")]
	public class SetAudioClip : ComponentAction<AudioSource>
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		[Tooltip("The GameObject with the AudioSource component.")]
		public FsmOwnerDefault gameObject;

		[ObjectType(typeof(AudioClip))]
		[Tooltip("The AudioClip to set.")]
		public FsmObject audioClip;

		public override void Reset()
		{
			gameObject = null;
			audioClip = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.audio.clip = audioClip.Value as AudioClip;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Sets looping on the AudioSource component on a Game Object.")]
	public class SetAudioLoop : ComponentAction<AudioSource>
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		public FsmOwnerDefault gameObject;

		public FsmBool loop;

		public override void Reset()
		{
			gameObject = null;
			loop = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.audio.loop = loop.Value;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Sets the Pitch of the Audio Clip played by the AudioSource component on a Game Object.")]
	public class SetAudioPitch : ComponentAction<AudioSource>
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		public FsmOwnerDefault gameObject;

		public FsmFloat pitch;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			pitch = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetAudioPitch();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetAudioPitch();
		}

		private void DoSetAudioPitch()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget) && !pitch.IsNone)
			{
				base.audio.pitch = pitch.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Sets the Volume of the Audio Clip played by the AudioSource component on a Game Object.")]
	public class SetAudioVolume : ComponentAction<AudioSource>
	{
		[RequiredField]
		[CheckForComponent(typeof(AudioSource))]
		public FsmOwnerDefault gameObject;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat volume;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			volume = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetAudioVolume();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetAudioVolume();
		}

		private void DoSetAudioVolume()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget) && !volume.IsNone)
			{
				base.audio.volume = volume.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Sets the global sound volume.")]
	public class SetGameVolume : FsmStateAction
	{
		[RequiredField]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat volume;

		public bool everyFrame;

		public override void Reset()
		{
			volume = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			AudioListener.volume = volume.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			AudioListener.volume = volume.Value;
		}
	}
	public abstract class BaseUpdateAction : FsmStateAction
	{
		public enum UpdateType
		{
			OnUpdate,
			OnLateUpdate,
			OnFixedUpdate
		}

		[ActionSection("Update type")]
		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public UpdateType updateType;

		public abstract void OnActionUpdate();

		public override void Reset()
		{
			everyFrame = false;
			updateType = UpdateType.OnUpdate;
		}

		public override void OnPreprocess()
		{
			if (updateType == UpdateType.OnFixedUpdate)
			{
				base.Fsm.HandleFixedUpdate = true;
			}
			else if (updateType == UpdateType.OnLateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnUpdate()
		{
			if (updateType == UpdateType.OnUpdate)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnLateUpdate()
		{
			if (updateType == UpdateType.OnLateUpdate)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			if (updateType == UpdateType.OnFixedUpdate)
			{
				OnActionUpdate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Fade from a fullscreen Color. NOTE: Uses OnGUI so requires a PlayMakerGUI component in the scene.")]
	public class CameraFadeIn : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Color to fade from. E.g., Fade up from black.")]
		public FsmColor color;

		[RequiredField]
		[HasFloatSlider(0f, 10f)]
		[Tooltip("Fade in time in seconds.")]
		public FsmFloat time;

		[Tooltip("Event to send when finished.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		private Color colorLerp;

		public override void Reset()
		{
			color = Color.black;
			time = 1f;
			finishEvent = null;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			colorLerp = color.Value;
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			colorLerp = Color.Lerp(color.Value, Color.clear, currentTime / time.Value);
			if (currentTime > time.Value)
			{
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
				Finish();
			}
		}

		public override void OnGUI()
		{
			Color obj = GUI.color;
			GUI.color = colorLerp;
			GUI.DrawTexture(new Rect(0f, 0f, Screen.width, Screen.height), ActionHelpers.WhiteTexture);
			GUI.color = obj;
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Fade to a fullscreen Color. NOTE: Uses OnGUI so requires a PlayMakerGUI component in the scene.")]
	public class CameraFadeOut : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Color to fade to. E.g., Fade to black.")]
		public FsmColor color;

		[RequiredField]
		[HasFloatSlider(0f, 10f)]
		[Tooltip("Fade out time in seconds.")]
		public FsmFloat time;

		[Tooltip("Event to send when finished.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		private Color colorLerp;

		public override void Reset()
		{
			color = Color.black;
			time = 1f;
			finishEvent = null;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			colorLerp = Color.clear;
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			colorLerp = Color.Lerp(Color.clear, color.Value, currentTime / time.Value);
			if (currentTime > time.Value && finishEvent != null)
			{
				base.Fsm.Event(finishEvent);
			}
		}

		public override void OnGUI()
		{
			Color obj = GUI.color;
			GUI.color = colorLerp;
			GUI.DrawTexture(new Rect(0f, 0f, Screen.width, Screen.height), ActionHelpers.WhiteTexture);
			GUI.color = obj;
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Activates a Camera in the scene.")]
	public class CutToCamera : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Camera to activate.")]
		public Camera camera;

		[Tooltip("Makes the camera the new MainCamera. The old MainCamera will be untagged.")]
		public bool makeMainCamera;

		[Tooltip("Cut back to the original MainCamera when exiting this state.")]
		public bool cutBackOnExit;

		private Camera oldCamera;

		public override void Reset()
		{
			camera = null;
			makeMainCamera = true;
			cutBackOnExit = false;
		}

		public override void OnEnter()
		{
			if (camera == null)
			{
				LogError("Missing camera!");
				return;
			}
			oldCamera = Camera.main;
			SwitchCamera(Camera.main, camera);
			if (makeMainCamera)
			{
				camera.tag = "MainCamera";
			}
			Finish();
		}

		public override void OnExit()
		{
			if (cutBackOnExit)
			{
				SwitchCamera(camera, oldCamera);
			}
		}

		private static void SwitchCamera(Camera camera1, Camera camera2)
		{
			if (camera1 != null)
			{
				camera1.enabled = false;
			}
			if (camera2 != null)
			{
				camera2.enabled = true;
			}
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[ActionTarget(typeof(Camera), "storeGameObject", false)]
	[Tooltip("Gets the GameObject tagged MainCamera from the scene")]
	public class GetMainCamera : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeGameObject;

		public override void Reset()
		{
			storeGameObject = null;
		}

		public override void OnEnter()
		{
			storeGameObject.Value = ((Camera.main != null) ? Camera.main.gameObject : null);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Transforms position from screen space into world space. NOTE: Uses the MainCamera!")]
	public class ScreenToWorldPoint : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Screen position as a vector.")]
		public FsmVector3 screenVector;

		[Tooltip("Screen X position in pixels or normalized. See Normalized.")]
		public FsmFloat screenX;

		[Tooltip("Screen X position in pixels or normalized. See Normalized.")]
		public FsmFloat screenY;

		[Tooltip("Distance into the screen in world units.")]
		public FsmFloat screenZ;

		[Tooltip("If true, X/Y coordinates are considered normalized (0-1), otherwise they are expected to be in pixels")]
		public FsmBool normalized;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the world position in a vector3 variable.")]
		public FsmVector3 storeWorldVector;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the world X position in a float variable.")]
		public FsmFloat storeWorldX;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the world Y position in a float variable.")]
		public FsmFloat storeWorldY;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the world Z position in a float variable.")]
		public FsmFloat storeWorldZ;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			screenVector = null;
			screenX = new FsmFloat
			{
				UseVariable = true
			};
			screenY = new FsmFloat
			{
				UseVariable = true
			};
			screenZ = 1f;
			normalized = false;
			storeWorldVector = null;
			storeWorldX = null;
			storeWorldY = null;
			storeWorldZ = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoScreenToWorldPoint();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoScreenToWorldPoint();
		}

		private void DoScreenToWorldPoint()
		{
			if (Camera.main == null)
			{
				LogError("No MainCamera defined!");
				Finish();
				return;
			}
			Vector3 position = Vector3.zero;
			if (!screenVector.IsNone)
			{
				position = screenVector.Value;
			}
			if (!screenX.IsNone)
			{
				position.x = screenX.Value;
			}
			if (!screenY.IsNone)
			{
				position.y = screenY.Value;
			}
			if (!screenZ.IsNone)
			{
				position.z = screenZ.Value;
			}
			if (normalized.Value)
			{
				position.x *= Screen.width;
				position.y *= Screen.height;
			}
			position = Camera.main.ScreenToWorldPoint(position);
			storeWorldVector.Value = position;
			storeWorldX.Value = position.x;
			storeWorldY.Value = position.y;
			storeWorldZ.Value = position.z;
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Sets the Background Color used by the Camera.")]
	public class SetBackgroundColor : ComponentAction<Camera>
	{
		[RequiredField]
		[CheckForComponent(typeof(Camera))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmColor backgroundColor;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			backgroundColor = Color.black;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetBackgroundColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetBackgroundColor();
		}

		private void DoSetBackgroundColor()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.camera.backgroundColor = backgroundColor.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Sets the Culling Mask used by the Camera.")]
	public class SetCameraCullingMask : ComponentAction<Camera>
	{
		[RequiredField]
		[CheckForComponent(typeof(Camera))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Cull these layers.")]
		[UIHint(UIHint.Layer)]
		public FsmInt[] cullingMask;

		[Tooltip("Invert the mask, so you cull all layers except those defined above.")]
		public FsmBool invertMask;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			cullingMask = new FsmInt[0];
			invertMask = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetCameraCullingMask();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetCameraCullingMask();
		}

		private void DoSetCameraCullingMask()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.camera.cullingMask = ActionHelpers.LayerArrayToLayerMask(cullingMask, invertMask.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Sets Field of View used by the Camera.")]
	public class SetCameraFOV : ComponentAction<Camera>
	{
		[RequiredField]
		[CheckForComponent(typeof(Camera))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmFloat fieldOfView;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			fieldOfView = 50f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetCameraFOV();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetCameraFOV();
		}

		private void DoSetCameraFOV()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.camera.fieldOfView = fieldOfView.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Sets the Main Camera.")]
	public class SetMainCamera : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Camera))]
		[Tooltip("The GameObject to set as the main camera (should have a Camera component).")]
		public FsmGameObject gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			if (gameObject.Value != null)
			{
				if (Camera.main != null)
				{
					Camera.main.gameObject.tag = "Untagged";
				}
				gameObject.Value.tag = "MainCamera";
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Camera)]
	[Tooltip("Transforms position from world space into screen space. NOTE: Uses the MainCamera!")]
	public class WorldToScreenPoint : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("World position to transform into screen coordinates.")]
		public FsmVector3 worldPosition;

		[Tooltip("World X position.")]
		public FsmFloat worldX;

		[Tooltip("World Y position.")]
		public FsmFloat worldY;

		[Tooltip("World Z position.")]
		public FsmFloat worldZ;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the screen position in a Vector3 Variable. Z will equal zero.")]
		public FsmVector3 storeScreenPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the screen X position in a Float Variable.")]
		public FsmFloat storeScreenX;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the screen Y position in a Float Variable.")]
		public FsmFloat storeScreenY;

		[Tooltip("Normalize screen coordinates (0-1). Otherwise coordinates are in pixels.")]
		public FsmBool normalize;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			worldPosition = null;
			worldX = new FsmFloat
			{
				UseVariable = true
			};
			worldY = new FsmFloat
			{
				UseVariable = true
			};
			worldZ = new FsmFloat
			{
				UseVariable = true
			};
			storeScreenPoint = null;
			storeScreenX = null;
			storeScreenY = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoWorldToScreenPoint();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoWorldToScreenPoint();
		}

		private void DoWorldToScreenPoint()
		{
			if (Camera.main == null)
			{
				LogError("No MainCamera defined!");
				Finish();
				return;
			}
			Vector3 position = Vector3.zero;
			if (!worldPosition.IsNone)
			{
				position = worldPosition.Value;
			}
			if (!worldX.IsNone)
			{
				position.x = worldX.Value;
			}
			if (!worldY.IsNone)
			{
				position.y = worldY.Value;
			}
			if (!worldZ.IsNone)
			{
				position.z = worldZ.Value;
			}
			position = Camera.main.WorldToScreenPoint(position);
			if (normalize.Value)
			{
				position.x /= Screen.width;
				position.y /= Screen.height;
			}
			storeScreenPoint.Value = position;
			storeScreenX.Value = position.x;
			storeScreenY.Value = position.y;
		}
	}
	[ActionCategory(ActionCategory.Character)]
	[Tooltip("Tests if a Character Controller on a Game Object was touching the ground during the last move.")]
	public class ControllerIsGrounded : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(CharacterController))]
		[Tooltip("The GameObject to check.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Event to send if touching the ground.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if not touching the ground.")]
		public FsmEvent falseEvent;

		[Tooltip("Store the result in a bool variable.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		private GameObject previousGo;

		private CharacterController controller;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoControllerIsGrounded();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoControllerIsGrounded();
		}

		private void DoControllerIsGrounded()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				if (ownerDefaultTarget != previousGo)
				{
					controller = ownerDefaultTarget.GetComponent<CharacterController>();
					previousGo = ownerDefaultTarget;
				}
				if (!(controller == null))
				{
					bool isGrounded = controller.isGrounded;
					storeResult.Value = isGrounded;
					base.Fsm.Event(isGrounded ? trueEvent : falseEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Character)]
	[Tooltip("Moves a Game Object with a Character Controller. See also Controller Simple Move. NOTE: It is recommended that you make only one call to Move or SimpleMove per frame.")]
	public class ControllerMove : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(CharacterController))]
		[Tooltip("The GameObject to move.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The movement vector.")]
		public FsmVector3 moveVector;

		[Tooltip("Move in local or word space.")]
		public Space space;

		[Tooltip("Movement vector is defined in units per second. Makes movement frame rate independent.")]
		public FsmBool perSecond;

		private GameObject previousGo;

		private CharacterController controller;

		public override void Reset()
		{
			gameObject = null;
			moveVector = new FsmVector3
			{
				UseVariable = true
			};
			space = Space.World;
			perSecond = true;
		}

		public override void OnUpdate()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != previousGo)
			{
				controller = ownerDefaultTarget.GetComponent<CharacterController>();
				previousGo = ownerDefaultTarget;
			}
			if (controller != null)
			{
				Vector3 vector = ((space == Space.World) ? moveVector.Value : ownerDefaultTarget.transform.TransformDirection(moveVector.Value));
				if (perSecond.Value)
				{
					controller.Move(vector * Time.deltaTime);
				}
				else
				{
					controller.Move(vector);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Character)]
	[Tooltip("Modify various character controller settings.\n'None' leaves the setting unchanged.")]
	public class ControllerSettings : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(CharacterController))]
		[Tooltip("The GameObject that owns the CharacterController.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The height of the character's capsule.")]
		public FsmFloat height;

		[Tooltip("The radius of the character's capsule.")]
		public FsmFloat radius;

		[Tooltip("The character controllers slope limit in degrees.")]
		public FsmFloat slopeLimit;

		[Tooltip("The character controllers step offset in meters.")]
		public FsmFloat stepOffset;

		[Tooltip("The center of the character's capsule relative to the transform's position")]
		public FsmVector3 center;

		[Tooltip("Should other rigidbodies or character controllers collide with this character controller (By default always enabled).")]
		public FsmBool detectCollisions;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		private GameObject previousGo;

		private CharacterController controller;

		public override void Reset()
		{
			gameObject = null;
			height = new FsmFloat
			{
				UseVariable = true
			};
			radius = new FsmFloat
			{
				UseVariable = true
			};
			slopeLimit = new FsmFloat
			{
				UseVariable = true
			};
			stepOffset = new FsmFloat
			{
				UseVariable = true
			};
			center = new FsmVector3
			{
				UseVariable = true
			};
			detectCollisions = new FsmBool
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoControllerSettings();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoControllerSettings();
		}

		private void DoControllerSettings()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != previousGo)
			{
				controller = ownerDefaultTarget.GetComponent<CharacterController>();
				previousGo = ownerDefaultTarget;
			}
			if (controller != null)
			{
				if (!height.IsNone)
				{
					controller.height = height.Value;
				}
				if (!radius.IsNone)
				{
					controller.radius = radius.Value;
				}
				if (!slopeLimit.IsNone)
				{
					controller.slopeLimit = slopeLimit.Value;
				}
				if (!stepOffset.IsNone)
				{
					controller.stepOffset = stepOffset.Value;
				}
				if (!center.IsNone)
				{
					controller.center = center.Value;
				}
				if (!detectCollisions.IsNone)
				{
					controller.detectCollisions = detectCollisions.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Character)]
	[Tooltip("Moves a Game Object with a Character Controller. Velocity along the y-axis is ignored. Speed is in meters/s. Gravity is automatically applied.")]
	public class ControllerSimpleMove : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(CharacterController))]
		[Tooltip("The GameObject to move.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The movement vector.")]
		public FsmVector3 moveVector;

		[Tooltip("Multiply the movement vector by a speed factor.")]
		public FsmFloat speed;

		[Tooltip("Move in local or world space.")]
		public Space space;

		private GameObject previousGo;

		private CharacterController controller;

		public override void Reset()
		{
			gameObject = null;
			moveVector = new FsmVector3
			{
				UseVariable = true
			};
			speed = 1f;
			space = Space.World;
		}

		public override void OnUpdate()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				if (ownerDefaultTarget != previousGo)
				{
					controller = ownerDefaultTarget.GetComponent<CharacterController>();
					previousGo = ownerDefaultTarget;
				}
				if (controller != null)
				{
					Vector3 vector = ((space == Space.World) ? moveVector.Value : ownerDefaultTarget.transform.TransformDirection(moveVector.Value));
					controller.SimpleMove(vector * speed.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Character)]
	[Tooltip("Gets the Collision Flags from a Character Controller on a Game Object. Collision flags give you a broad overview of where the character collided with any other object.")]
	public class GetControllerCollisionFlags : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(CharacterController))]
		[Tooltip("The GameObject with a Character Controller component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("True if the Character Controller capsule is on the ground")]
		public FsmBool isGrounded;

		[UIHint(UIHint.Variable)]
		[Tooltip("True if no collisions in last move.")]
		public FsmBool none;

		[UIHint(UIHint.Variable)]
		[Tooltip("True if the Character Controller capsule was hit on the sides.")]
		public FsmBool sides;

		[UIHint(UIHint.Variable)]
		[Tooltip("True if the Character Controller capsule was hit from above.")]
		public FsmBool above;

		[UIHint(UIHint.Variable)]
		[Tooltip("True if the Character Controller capsule was hit from below.")]
		public FsmBool below;

		private GameObject previousGo;

		private CharacterController controller;

		public override void Reset()
		{
			gameObject = null;
			isGrounded = null;
			none = null;
			sides = null;
			above = null;
			below = null;
		}

		public override void OnUpdate()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				if (ownerDefaultTarget != previousGo)
				{
					controller = ownerDefaultTarget.GetComponent<CharacterController>();
					previousGo = ownerDefaultTarget;
				}
				if (controller != null)
				{
					isGrounded.Value = controller.isGrounded;
					none.Value = (controller.collisionFlags & CollisionFlags.None) != 0;
					sides.Value = (controller.collisionFlags & CollisionFlags.Sides) != 0;
					above.Value = (controller.collisionFlags & CollisionFlags.Above) != 0;
					below.Value = (controller.collisionFlags & CollisionFlags.Below) != 0;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Character)]
	[Tooltip("Gets info on the last Character Controller collision and store in variables.")]
	public class GetControllerHitInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the GameObject hit in the last collision.")]
		public FsmGameObject gameObjectHit;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the contact point of the last collision in world coordinates.")]
		public FsmVector3 contactPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the normal of the last collision.")]
		public FsmVector3 contactNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the direction of the last move before the collision.")]
		public FsmVector3 moveDirection;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the distance of the last move before the collision.")]
		public FsmFloat moveLength;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the physics material of the Game Object Hit. Useful for triggering different effects. Audio, particles...")]
		public FsmString physicsMaterialName;

		public override void Reset()
		{
			gameObjectHit = null;
			contactPoint = null;
			contactNormal = null;
			moveDirection = null;
			moveLength = null;
			physicsMaterialName = null;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleControllerColliderHit = true;
		}

		private void StoreTriggerInfo()
		{
			if (base.Fsm.ControllerCollider != null)
			{
				gameObjectHit.Value = base.Fsm.ControllerCollider.gameObject;
				contactPoint.Value = base.Fsm.ControllerCollider.point;
				contactNormal.Value = base.Fsm.ControllerCollider.normal;
				moveDirection.Value = base.Fsm.ControllerCollider.moveDirection;
				moveLength.Value = base.Fsm.ControllerCollider.moveLength;
				physicsMaterialName.Value = base.Fsm.ControllerCollider.collider.material.name;
			}
		}

		public override void OnEnter()
		{
			StoreTriggerInfo();
			Finish();
		}

		public override string ErrorCheck()
		{
			return ActionHelpers.CheckPhysicsSetup(base.Owner);
		}
	}
	[ActionCategory(ActionCategory.Color)]
	[Tooltip("Interpolate through an array of Colors over a specified amount of Time.")]
	public class ColorInterpolate : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Array of colors to interpolate through.")]
		public FsmColor[] colors;

		[RequiredField]
		[Tooltip("Interpolation time.")]
		public FsmFloat time;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the interpolated color in a Color variable.")]
		public FsmColor storeColor;

		[Tooltip("Event to send when the interpolation finishes.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		public override void Reset()
		{
			colors = new FsmColor[3];
			time = 1f;
			storeColor = null;
			finishEvent = null;
			realTime = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			if (colors.Length < 2)
			{
				if (colors.Length == 1)
				{
					storeColor.Value = colors[0].Value;
				}
				Finish();
			}
			else
			{
				storeColor.Value = colors[0].Value;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			if (currentTime > time.Value)
			{
				Finish();
				storeColor.Value = colors[colors.Length - 1].Value;
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
				return;
			}
			float num = (float)(colors.Length - 1) * currentTime / time.Value;
			Color value;
			if (num.Equals(0f))
			{
				value = colors[0].Value;
			}
			else if (num.Equals(colors.Length - 1))
			{
				value = colors[colors.Length - 1].Value;
			}
			else
			{
				Color value2 = colors[Mathf.FloorToInt(num)].Value;
				Color value3 = colors[Mathf.CeilToInt(num)].Value;
				num -= Mathf.Floor(num);
				value = Color.Lerp(value2, value3, num);
			}
			storeColor.Value = value;
		}

		public override string ErrorCheck()
		{
			if (colors.Length >= 2)
			{
				return null;
			}
			return "Define at least 2 colors to make a gradient.";
		}
	}
	[ActionCategory(ActionCategory.Color)]
	[Tooltip("Samples a Color on a continuous Colors gradient.")]
	public class ColorRamp : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Array of colors to defining the gradient.")]
		public FsmColor[] colors;

		[RequiredField]
		[Tooltip("Point on the gradient to sample. Should be between 0 and the number of colors in the gradient.")]
		public FsmFloat sampleAt;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the sampled color in a Color variable.")]
		public FsmColor storeColor;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			colors = new FsmColor[3];
			sampleAt = 0f;
			storeColor = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoColorRamp();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoColorRamp();
		}

		private void DoColorRamp()
		{
			if (colors != null && colors.Length != 0 && sampleAt != null && storeColor != null)
			{
				float num = Mathf.Clamp(sampleAt.Value, 0f, colors.Length - 1);
				Color value;
				if (num == 0f)
				{
					value = colors[0].Value;
				}
				else if (num == (float)colors.Length)
				{
					value = colors[colors.Length - 1].Value;
				}
				else
				{
					Color value2 = colors[Mathf.FloorToInt(num)].Value;
					Color value3 = colors[Mathf.CeilToInt(num)].Value;
					num -= Mathf.Floor(num);
					value = Color.Lerp(value2, value3, num);
				}
				storeColor.Value = value;
			}
		}

		public override string ErrorCheck()
		{
			if (colors.Length < 2)
			{
				return "Define at least 2 colors to make a gradient.";
			}
			return null;
		}
	}
	[ActionCategory(ActionCategory.Color)]
	[Tooltip("Get the RGBA channels of a Color Variable and store them in Float Variables.")]
	public class GetColorRGBA : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Color variable.")]
		public FsmColor color;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the red channel in a float variable.")]
		public FsmFloat storeRed;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the green channel in a float variable.")]
		public FsmFloat storeGreen;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the blue channel in a float variable.")]
		public FsmFloat storeBlue;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the alpha channel in a float variable.")]
		public FsmFloat storeAlpha;

		[Tooltip("Repeat every frame. Useful if the color variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			color = null;
			storeRed = null;
			storeGreen = null;
			storeBlue = null;
			storeAlpha = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetColorRGBA();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetColorRGBA();
		}

		private void DoGetColorRGBA()
		{
			if (!color.IsNone)
			{
				storeRed.Value = color.Value.r;
				storeGreen.Value = color.Value.g;
				storeBlue.Value = color.Value.b;
				storeAlpha.Value = color.Value.a;
			}
		}
	}
	[ActionCategory(ActionCategory.Color)]
	[Tooltip("Select a random Color from an array of Colors.")]
	public class SelectRandomColor : FsmStateAction
	{
		[CompoundArray("Colors", "Color", "Weight")]
		public FsmColor[] colors;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmColor storeColor;

		public override void Reset()
		{
			colors = new FsmColor[3];
			weights = new FsmFloat[3] { 1f, 1f, 1f };
			storeColor = null;
		}

		public override void OnEnter()
		{
			DoSelectRandomColor();
			Finish();
		}

		private void DoSelectRandomColor()
		{
			if (colors != null && colors.Length != 0 && storeColor != null)
			{
				int randomWeightedIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				if (randomWeightedIndex != -1)
				{
					storeColor.Value = colors[randomWeightedIndex].Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Color)]
	[Tooltip("Sets the RGBA channels of a Color Variable. To leave any channel unchanged, set variable to 'None'.")]
	public class SetColorRGBA : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmColor colorVariable;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat red;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat green;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat blue;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat alpha;

		public bool everyFrame;

		public override void Reset()
		{
			colorVariable = null;
			red = 0f;
			green = 0f;
			blue = 0f;
			alpha = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetColorRGBA();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetColorRGBA();
		}

		private void DoSetColorRGBA()
		{
			if (colorVariable != null)
			{
				Color value = colorVariable.Value;
				if (!red.IsNone)
				{
					value.r = red.Value;
				}
				if (!green.IsNone)
				{
					value.g = green.Value;
				}
				if (!blue.IsNone)
				{
					value.b = blue.Value;
				}
				if (!alpha.IsNone)
				{
					value.a = alpha.Value;
				}
				colorVariable.Value = value;
			}
		}
	}
	[ActionCategory(ActionCategory.Color)]
	[Tooltip("Sets the value of a Color Variable.")]
	public class SetColorValue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmColor colorVariable;

		[RequiredField]
		public FsmColor color;

		public bool everyFrame;

		public override void Reset()
		{
			colorVariable = null;
			color = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetColorValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetColorValue();
		}

		private void DoSetColorValue()
		{
			if (colorVariable != null)
			{
				colorVariable.Value = color.Value;
			}
		}
	}
	public abstract class ComponentAction<T> : FsmStateAction where T : Component
	{
		protected GameObject cachedGameObject;

		protected T cachedComponent;

		protected Rigidbody rigidbody => cachedComponent as Rigidbody;

		protected Rigidbody2D rigidbody2d => cachedComponent as Rigidbody2D;

		protected Renderer renderer => cachedComponent as Renderer;

		protected Animation animation => cachedComponent as Animation;

		protected AudioSource audio => cachedComponent as AudioSource;

		protected Camera camera => cachedComponent as Camera;

		protected Light light => cachedComponent as Light;

		protected bool UpdateCache(GameObject go)
		{
			if (go == null)
			{
				return false;
			}
			if (cachedComponent == null || cachedGameObject != go)
			{
				cachedComponent = go.GetComponent<T>();
				cachedGameObject = go;
				if (cachedComponent == null)
				{
					LogWarning("Missing component: " + typeof(T).FullName + " on: " + go.name);
				}
			}
			return cachedComponent != null;
		}

		protected bool UpdateCacheAddComponent(GameObject go)
		{
			if (go == null)
			{
				return false;
			}
			if (cachedComponent == null || cachedGameObject != go)
			{
				cachedComponent = go.GetComponent<T>();
				cachedGameObject = go;
				if (cachedComponent == null)
				{
					cachedComponent = go.AddComponent<T>();
					cachedComponent.hideFlags = HideFlags.DontSaveInEditor;
				}
			}
			return cachedComponent != null;
		}

		protected void SendEvent(FsmEventTarget eventTarget, FsmEvent fsmEvent)
		{
			base.Fsm.Event(cachedGameObject, eventTarget, fsmEvent);
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts a Bool value to a Color.")]
	public class ConvertBoolToColor : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variable to test.")]
		public FsmBool boolVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Color variable to set based on the bool variable value.")]
		public FsmColor colorVariable;

		[Tooltip("Color if Bool variable is false.")]
		public FsmColor falseColor;

		[Tooltip("Color if Bool variable is true.")]
		public FsmColor trueColor;

		[Tooltip("Repeat every frame. Useful if the Bool variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariable = null;
			colorVariable = null;
			falseColor = Color.black;
			trueColor = Color.white;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertBoolToColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertBoolToColor();
		}

		private void DoConvertBoolToColor()
		{
			colorVariable.Value = (boolVariable.Value ? trueColor.Value : falseColor.Value);
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts a Bool value to a Float value.")]
	public class ConvertBoolToFloat : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variable to test.")]
		public FsmBool boolVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Float variable to set based on the Bool variable value.")]
		public FsmFloat floatVariable;

		[Tooltip("Float value if Bool variable is false.")]
		public FsmFloat falseValue;

		[Tooltip("Float value if Bool variable is true.")]
		public FsmFloat trueValue;

		[Tooltip("Repeat every frame. Useful if the Bool variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariable = null;
			floatVariable = null;
			falseValue = 0f;
			trueValue = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertBoolToFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertBoolToFloat();
		}

		private void DoConvertBoolToFloat()
		{
			floatVariable.Value = (boolVariable.Value ? trueValue.Value : falseValue.Value);
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts a Bool value to an Integer value.")]
	public class ConvertBoolToInt : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variable to test.")]
		public FsmBool boolVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Integer variable to set based on the Bool variable value.")]
		public FsmInt intVariable;

		[Tooltip("Integer value if Bool variable is false.")]
		public FsmInt falseValue;

		[Tooltip("Integer value if Bool variable is false.")]
		public FsmInt trueValue;

		[Tooltip("Repeat every frame. Useful if the Bool variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariable = null;
			intVariable = null;
			falseValue = 0;
			trueValue = 1;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertBoolToInt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertBoolToInt();
		}

		private void DoConvertBoolToInt()
		{
			intVariable.Value = (boolVariable.Value ? trueValue.Value : falseValue.Value);
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts a Bool value to a String value.")]
	public class ConvertBoolToString : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variable to test.")]
		public FsmBool boolVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The String variable to set based on the Bool variable value.")]
		public FsmString stringVariable;

		[Tooltip("String value if Bool variable is false.")]
		public FsmString falseString;

		[Tooltip("String value if Bool variable is true.")]
		public FsmString trueString;

		[Tooltip("Repeat every frame. Useful if the Bool variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariable = null;
			stringVariable = null;
			falseString = "False";
			trueString = "True";
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertBoolToString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertBoolToString();
		}

		private void DoConvertBoolToString()
		{
			stringVariable.Value = (boolVariable.Value ? trueString.Value : falseString.Value);
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts an Enum value to a String value.")]
	public class ConvertEnumToString : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Enum variable to convert.")]
		public FsmEnum enumVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The String variable to store the converted value.")]
		public FsmString stringVariable;

		[Tooltip("Repeat every frame. Useful if the Enum variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			enumVariable = null;
			stringVariable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertEnumToString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertEnumToString();
		}

		private void DoConvertEnumToString()
		{
			stringVariable.Value = ((enumVariable.Value != null) ? enumVariable.Value.ToString() : "");
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts a Float value to an Integer value.")]
	public class ConvertFloatToInt : FsmStateAction
	{
		public enum FloatRounding
		{
			RoundDown,
			RoundUp,
			Nearest
		}

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Float variable to convert to an integer.")]
		public FsmFloat floatVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in an Integer variable.")]
		public FsmInt intVariable;

		public FloatRounding rounding;

		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			intVariable = null;
			rounding = FloatRounding.Nearest;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertFloatToInt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertFloatToInt();
		}

		private void DoConvertFloatToInt()
		{
			switch (rounding)
			{
			case FloatRounding.Nearest:
				intVariable.Value = Mathf.RoundToInt(floatVariable.Value);
				break;
			case FloatRounding.RoundDown:
				intVariable.Value = Mathf.FloorToInt(floatVariable.Value);
				break;
			case FloatRounding.RoundUp:
				intVariable.Value = Mathf.CeilToInt(floatVariable.Value);
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts a Float value to a String value with optional format.")]
	public class ConvertFloatToString : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variable to convert.")]
		public FsmFloat floatVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("A string variable to store the converted value.")]
		public FsmString stringVariable;

		[Tooltip("Optional Format, allows for leading zeros. E.g., 0000")]
		public FsmString format;

		[Tooltip("Repeat every frame. Useful if the float variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			stringVariable = null;
			everyFrame = false;
			format = null;
		}

		public override void OnEnter()
		{
			DoConvertFloatToString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertFloatToString();
		}

		private void DoConvertFloatToString()
		{
			if (format.IsNone || string.IsNullOrEmpty(format.Value))
			{
				stringVariable.Value = floatVariable.Value.ToString();
			}
			else
			{
				stringVariable.Value = floatVariable.Value.ToString(format.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts an Integer value to a Float value.")]
	public class ConvertIntToFloat : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Integer variable to convert to a float.")]
		public FsmInt intVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a Float variable.")]
		public FsmFloat floatVariable;

		[Tooltip("Repeat every frame. Useful if the Integer variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			floatVariable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertIntToFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertIntToFloat();
		}

		private void DoConvertIntToFloat()
		{
			floatVariable.Value = intVariable.Value;
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts an Integer value to a String value with an optional format.")]
	public class ConvertIntToString : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Int variable to convert.")]
		public FsmInt intVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("A String variable to store the converted value.")]
		public FsmString stringVariable;

		[Tooltip("Optional Format, allows for leading zeros. E.g., 0000")]
		public FsmString format;

		[Tooltip("Repeat every frame. Useful if the Int variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			stringVariable = null;
			everyFrame = false;
			format = null;
		}

		public override void OnEnter()
		{
			DoConvertIntToString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertIntToString();
		}

		private void DoConvertIntToString()
		{
			if (format.IsNone || string.IsNullOrEmpty(format.Value))
			{
				stringVariable.Value = intVariable.Value.ToString();
			}
			else
			{
				stringVariable.Value = intVariable.Value.ToString(format.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts a Material variable to an Object variable. Useful if you want to use Set Property (which only works on Object variables).")]
	public class ConvertMaterialToObject : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Material variable to convert to an Object.")]
		public FsmMaterial materialVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in an Object variable.")]
		public FsmObject objectVariable;

		[Tooltip("Repeat every frame. Useful if the Material variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			materialVariable = null;
			objectVariable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertMaterialToObject();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertMaterialToObject();
		}

		private void DoConvertMaterialToObject()
		{
			objectVariable.Value = materialVariable.Value;
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[HelpUrl("http://hutonggames.com/playmakerforum/index.php?topic=1711.0")]
	[Tooltip("Converts Seconds to a String value representing the time.")]
	public class ConvertSecondsToString : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The seconds variable to convert.")]
		public FsmFloat secondsVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("A string variable to store the time value.")]
		public FsmString stringVariable;

		[RequiredField]
		[Tooltip("Format. 0 for days, 1 is for hours, 2 for minutes, 3 for seconds and 4 for milliseconds. 5 for total days, 6 for total hours, 7 for total minutes, 8 for total seconds, 9 for total milliseconds, 10 for two digits milliseconds. so {2:D2} would just show the seconds of the current time, NOT the grand total number of seconds, the grand total of seconds would be {8:F0}")]
		public FsmString format;

		[Tooltip("Repeat every frame. Useful if the seconds variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			secondsVariable = null;
			stringVariable = null;
			everyFrame = false;
			format = "{1:D2}h:{2:D2}m:{3:D2}s:{10}ms";
		}

		public override void OnEnter()
		{
			DoConvertSecondsToString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertSecondsToString();
		}

		private void DoConvertSecondsToString()
		{
			TimeSpan timeSpan = TimeSpan.FromSeconds(secondsVariable.Value);
			string text = timeSpan.Milliseconds.ToString("D3").PadLeft(2, '0');
			text = text.Substring(0, 2);
			stringVariable.Value = string.Format(format.Value, timeSpan.Days, timeSpan.Hours, timeSpan.Minutes, timeSpan.Seconds, timeSpan.Milliseconds, timeSpan.TotalDays, timeSpan.TotalHours, timeSpan.TotalMinutes, timeSpan.TotalSeconds, timeSpan.TotalMilliseconds, text);
		}
	}
	[ActionCategory(ActionCategory.Convert)]
	[Tooltip("Converts an String value to an Int value.")]
	public class ConvertStringToInt : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The String variable to convert to an integer.")]
		public FsmString stringVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in an Int variable.")]
		public FsmInt intVariable;

		[Tooltip("Repeat every frame. Useful if the String variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			stringVariable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoConvertStringToInt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoConvertStringToInt();
		}

		private void DoConvertStringToInt()
		{
			intVariable.Value = int.Parse(stringVariable.Value);
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Checks if the conditional expression Is True or Is False. Breaks the execution of the game if the assertion fails.\nThis is a useful way to check your assumptions. If you expect a certain value use an Assert to make sure!\nOnly runs in Editor.")]
	public class Assert : FsmStateAction, IEvaluatorContext
	{
		public enum AssertType
		{
			IsTrue,
			IsFalse
		}

		[UIHint(UIHint.TextArea)]
		[Tooltip("Enter an expression to evaluate.\nExample: (a < b) && c\n$(variable name with spaces)")]
		public FsmString expression;

		[Tooltip("Expected result of the expression.")]
		public AssertType assert;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		private string cachedExpression;

		public CompiledAst Ast { get; set; }

		public string LastErrorMessage { get; set; }

		FsmVar IEvaluatorContext.GetVariable(string name)
		{
			NamedVariable variable = base.Fsm.Variables.GetVariable(name);
			if (variable != null)
			{
				return new FsmVar(variable);
			}
			throw new VariableNotFoundException(name);
		}
	}
	public abstract class BaseLogAction : FsmStateAction
	{
		public bool sendToUnityLog;

		public override void Reset()
		{
			sendToUnityLog = false;
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Adds a text area to the action list. NOTE: Doesn't do anything, just for notes...")]
	public class Comment : FsmStateAction
	{
		[UIHint(UIHint.Comment)]
		public string comment;

		public override void Reset()
		{
			comment = "";
		}

		public override void OnEnter()
		{
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of a Bool Variable in the PlayMaker Log Window.")]
	public class DebugBool : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variable to debug.")]
		public FsmBool boolVariable;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			boolVariable = null;
			base.Reset();
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!boolVariable.IsNone)
			{
				text = boolVariable.Name + ": " + boolVariable.Value;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text, sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Draw Gizmos in the Scene View.")]
	public class DebugDrawShape : FsmStateAction
	{
		public enum ShapeType
		{
			Sphere,
			Cube,
			WireSphere,
			WireCube
		}

		[RequiredField]
		[Tooltip("Draw the Gizmo at a GameObject's position.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The type of Gizmo to draw:\nSphere, Cube, WireSphere, or WireCube.")]
		public ShapeType shape;

		[Tooltip("The color to use.")]
		public FsmColor color;

		[Tooltip("Use this for sphere gizmos")]
		public FsmFloat radius;

		[Tooltip("Use this for cube gizmos")]
		public FsmVector3 size;

		public override void Reset()
		{
			gameObject = null;
			shape = ShapeType.Sphere;
			color = Color.grey;
			radius = 1f;
			size = new Vector3(1f, 1f, 1f);
		}

		public override void OnDrawActionGizmos()
		{
			Transform transform = base.Fsm.GetOwnerDefaultTarget(gameObject).transform;
			if (!(transform == null))
			{
				Gizmos.color = color.Value;
				switch (shape)
				{
				case ShapeType.Sphere:
					Gizmos.DrawSphere(transform.position, radius.Value);
					break;
				case ShapeType.WireSphere:
					Gizmos.DrawWireSphere(transform.position, radius.Value);
					break;
				case ShapeType.Cube:
					Gizmos.DrawCube(transform.position, size.Value);
					break;
				case ShapeType.WireCube:
					Gizmos.DrawWireCube(transform.position, size.Value);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of an Enum Variable in the PlayMaker Log Window.")]
	public class DebugEnum : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Enum Variable to debug.")]
		public FsmEnum enumVariable;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			enumVariable = null;
			base.Reset();
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!enumVariable.IsNone)
			{
				text = enumVariable.Name + ": " + enumVariable.Value;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text, sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of a Float Variable in the PlayMaker Log Window.")]
	public class DebugFloat : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Float variable to debug.")]
		public FsmFloat floatVariable;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			floatVariable = null;
			base.Reset();
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!floatVariable.IsNone)
			{
				text = floatVariable.Name + ": " + floatVariable.Value;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text, sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Print the value of any FSM Variable in the PlayMaker Log Window.")]
	public class DebugFsmVariable : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[HideTypeFilter]
		[UIHint(UIHint.Variable)]
		[Tooltip("The variable to debug.")]
		public FsmVar variable;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			variable = null;
			base.Reset();
		}

		public override void OnEnter()
		{
			ActionHelpers.DebugLog(base.Fsm, logLevel, variable.DebugString(), sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of a Game Object Variable in the PlayMaker Log Window.")]
	public class DebugGameObject : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The GameObject variable to debug.")]
		public FsmGameObject gameObject;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			gameObject = null;
			base.Reset();
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!gameObject.IsNone)
			{
				text = gameObject.Name + ": " + gameObject;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text, sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of an Integer Variable in the PlayMaker Log Window.")]
	public class DebugInt : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Int variable to debug.")]
		public FsmInt intVariable;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			intVariable = null;
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!intVariable.IsNone)
			{
				text = intVariable.Name + ": " + intVariable.Value;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text, sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Sends a log message to the PlayMaker Log Window.")]
	public class DebugLog : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[Tooltip("Text to send to the log.")]
		public FsmString text;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			text = "";
			base.Reset();
		}

		public override void OnEnter()
		{
			if (!string.IsNullOrEmpty(text.Value))
			{
				ActionHelpers.DebugLog(base.Fsm, logLevel, text.Value, sendToUnityLog);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of an Object Variable in the PlayMaker Log Window.")]
	public class DebugObject : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Object variable to debug.")]
		public FsmObject fsmObject;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			fsmObject = null;
			base.Reset();
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!fsmObject.IsNone)
			{
				text = fsmObject.Name + ": " + fsmObject;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text, sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of a Vector3 Variable in the PlayMaker Log Window.")]
	public class DebugVector3 : BaseLogAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Vector3 variable to debug.")]
		public FsmVector3 vector3Variable;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			vector3Variable = null;
			base.Reset();
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!vector3Variable.IsNone)
			{
				text = vector3Variable.Name + ": " + vector3Variable.Value;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text, sendToUnityLog);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Draws a line from a Start point to an End point. Specify the points as Game Objects or Vector3 world positions. If both are specified, position is used as a local offset from the Object's position.")]
	public class DrawDebugLine : FsmStateAction
	{
		[Tooltip("Draw line from a GameObject.")]
		public FsmGameObject fromObject;

		[Tooltip("Draw line from a world position, or local offset from GameObject if provided.")]
		public FsmVector3 fromPosition;

		[Tooltip("Draw line to a GameObject.")]
		public FsmGameObject toObject;

		[Tooltip("Draw line to a world position, or local offset from GameObject if provided.")]
		public FsmVector3 toPosition;

		[Tooltip("The color of the line.")]
		public FsmColor color;

		public override void Reset()
		{
			fromObject = new FsmGameObject
			{
				UseVariable = true
			};
			fromPosition = new FsmVector3
			{
				UseVariable = true
			};
			toObject = new FsmGameObject
			{
				UseVariable = true
			};
			toPosition = new FsmVector3
			{
				UseVariable = true
			};
			color = Color.white;
		}

		public override void OnUpdate()
		{
			Vector3 position = ActionHelpers.GetPosition(fromObject, fromPosition);
			Vector3 position2 = ActionHelpers.GetPosition(toObject, toPosition);
			UnityEngine.Debug.DrawLine(position, position2, color.Value);
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Draws a line from a Start point in a direction. Specify the start point as Game Objects or Vector3 world positions. If both are specified, position is used as a local offset from the Object's position.")]
	public class DrawDebugRay : FsmStateAction
	{
		[Tooltip("Draw ray from a GameObject.")]
		public FsmGameObject fromObject;

		[Tooltip("Draw ray from a world position, or local offset from GameObject if provided.")]
		public FsmVector3 fromPosition;

		[Tooltip("Direction vector of ray.")]
		public FsmVector3 direction;

		[Tooltip("The color of the ray.")]
		public FsmColor color;

		public override void Reset()
		{
			fromObject = new FsmGameObject
			{
				UseVariable = true
			};
			fromPosition = new FsmVector3
			{
				UseVariable = true
			};
			direction = new FsmVector3
			{
				UseVariable = true
			};
			color = Color.white;
		}

		public override void OnUpdate()
		{
			UnityEngine.Debug.DrawRay(ActionHelpers.GetPosition(fromObject, fromPosition), direction.Value, color.Value);
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Draws a state label for this FSM in the Game View. The label is drawn on the game object that owns the FSM. Use this to override the global setting in the PlayMaker Debug menu.")]
	public class DrawStateLabel : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Set to True to show State labels, or False to hide them.")]
		public FsmBool showLabel;

		public override void Reset()
		{
			showLabel = true;
		}

		public override void OnEnter()
		{
			base.Fsm.ShowStateLabel = showLabel.Value;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Sends an Event based on the Orientation of the mobile device.")]
	public class DeviceOrientationEvent : FsmStateAction
	{
		[Tooltip("Note: If device is physically situated between discrete positions, as when (for example) rotated diagonally, system will report Unknown orientation.")]
		public DeviceOrientation orientation;

		[Tooltip("The event to send if the device orientation matches Orientation.")]
		public FsmEvent sendEvent;

		[Tooltip("Repeat every frame. Useful if you want to wait for the orientation to be true.")]
		public bool everyFrame;

		public override void Reset()
		{
			orientation = DeviceOrientation.Portrait;
			sendEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoDetectDeviceOrientation();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoDetectDeviceOrientation();
		}

		private void DoDetectDeviceOrientation()
		{
			if (Input.deviceOrientation == orientation)
			{
				base.Fsm.Event(sendEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Plays a full-screen movie on a handheld device. Please consult the Unity docs for Handheld.PlayFullScreenMovie for proper usage.")]
	public class DevicePlayFullScreenMovie : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Note that player will stream movie directly from the iPhone disc, therefore you have to provide movie as a separate files and not as an usual asset.\nYou will have to create a folder named StreamingAssets inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the iPhone application bundle.")]
		public FsmString moviePath;

		[RequiredField]
		[Tooltip("This action will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content.")]
		public FsmColor fadeColor;

		[Tooltip("Options for displaying movie playback controls. See Unity docs.")]
		public FullScreenMovieControlMode movieControlMode;

		[Tooltip("Scaling modes for displaying movies.. See Unity docs.")]
		public FullScreenMovieScalingMode movieScalingMode;

		public override void Reset()
		{
			moviePath = "";
			fadeColor = Color.black;
			movieControlMode = FullScreenMovieControlMode.Full;
			movieScalingMode = FullScreenMovieScalingMode.AspectFit;
		}

		public override void OnEnter()
		{
			Handheld.PlayFullScreenMovie(moviePath.Value, fadeColor.Value, movieControlMode, movieScalingMode);
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Sends an Event when the mobile device is shaken.")]
	public class DeviceShakeEvent : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Amount of acceleration required to trigger the event. Higher numbers require a harder shake.")]
		public FsmFloat shakeThreshold;

		[RequiredField]
		[Tooltip("Event to send when Shake Threshold is exceeded.")]
		public FsmEvent sendEvent;

		public override void Reset()
		{
			shakeThreshold = 3f;
			sendEvent = null;
		}

		public override void OnUpdate()
		{
			if (Input.acceleration.sqrMagnitude > shakeThreshold.Value * shakeThreshold.Value)
			{
				base.Fsm.Event(sendEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Causes the device to vibrate for half a second.")]
	public class DeviceVibrate : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnEnter()
		{
			Handheld.Vibrate();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Gets the last measured linear acceleration of a device and stores it in a Vector3 Variable.")]
	public class GetDeviceAcceleration : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeVector;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeX;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeY;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeZ;

		public FsmFloat multiplier;

		public bool everyFrame;

		public override void Reset()
		{
			storeVector = null;
			storeX = null;
			storeY = null;
			storeZ = null;
			multiplier = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetDeviceAcceleration();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetDeviceAcceleration();
		}

		private void DoGetDeviceAcceleration()
		{
			Vector3 value = new Vector3(Input.acceleration.x, Input.acceleration.y, Input.acceleration.z);
			if (!multiplier.IsNone)
			{
				value *= multiplier.Value;
			}
			storeVector.Value = value;
			storeX.Value = value.x;
			storeY.Value = value.y;
			storeZ.Value = value.z;
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Gets the rotation of the device around its z axis (into the screen). For example when you steer with the iPhone in a driving game.")]
	public class GetDeviceRoll : FsmStateAction
	{
		public enum BaseOrientation
		{
			Portrait,
			LandscapeLeft,
			LandscapeRight
		}

		[Tooltip("How the user is expected to hold the device (where angle will be zero).")]
		public BaseOrientation baseOrientation;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeAngle;

		public FsmFloat limitAngle;

		public FsmFloat smoothing;

		public bool everyFrame;

		private float lastZAngle;

		public override void Reset()
		{
			baseOrientation = BaseOrientation.LandscapeLeft;
			storeAngle = null;
			limitAngle = new FsmFloat
			{
				UseVariable = true
			};
			smoothing = 5f;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoGetDeviceRoll();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetDeviceRoll();
		}

		private void DoGetDeviceRoll()
		{
			float x = Input.acceleration.x;
			float y = Input.acceleration.y;
			float num = 0f;
			switch (baseOrientation)
			{
			case BaseOrientation.Portrait:
				num = 0f - Mathf.Atan2(x, 0f - y);
				break;
			case BaseOrientation.LandscapeLeft:
				num = Mathf.Atan2(y, 0f - x);
				break;
			case BaseOrientation.LandscapeRight:
				num = 0f - Mathf.Atan2(y, x);
				break;
			}
			if (!limitAngle.IsNone)
			{
				num = Mathf.Clamp(57.29578f * num, 0f - limitAngle.Value, limitAngle.Value);
			}
			if (smoothing.Value > 0f)
			{
				num = Mathf.LerpAngle(lastZAngle, num, smoothing.Value * Time.deltaTime);
			}
			lastZAngle = num;
			storeAngle.Value = num;
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Get various iPhone settings.")]
	public class GetIPhoneSettings : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Allows device to fall into 'sleep' state with screen being dim if no touches occurred. Default value is true.")]
		public FsmBool getScreenCanDarken;

		[UIHint(UIHint.Variable)]
		[Tooltip("A unique device identifier string. It is guaranteed to be unique for every device (Read Only).")]
		public FsmString getUniqueIdentifier;

		[UIHint(UIHint.Variable)]
		[Tooltip("The user defined name of the device (Read Only).")]
		public FsmString getName;

		[UIHint(UIHint.Variable)]
		[Tooltip("The model of the device (Read Only).")]
		public FsmString getModel;

		[UIHint(UIHint.Variable)]
		[Tooltip("The name of the operating system running on the device (Read Only).")]
		public FsmString getSystemName;

		[UIHint(UIHint.Variable)]
		[Tooltip("The generation of the device (Read Only).")]
		public FsmString getGeneration;

		public override void Reset()
		{
			getScreenCanDarken = null;
			getUniqueIdentifier = null;
			getName = null;
			getModel = null;
			getSystemName = null;
			getGeneration = null;
		}

		public override void OnEnter()
		{
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Gets Location Info from a mobile device. NOTE: Use StartLocationService before trying to get location info.")]
	public class GetLocationInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmVector3 vectorPosition;

		[UIHint(UIHint.Variable)]
		public FsmFloat longitude;

		[UIHint(UIHint.Variable)]
		public FsmFloat latitude;

		[UIHint(UIHint.Variable)]
		public FsmFloat altitude;

		[UIHint(UIHint.Variable)]
		public FsmFloat horizontalAccuracy;

		[UIHint(UIHint.Variable)]
		public FsmFloat verticalAccuracy;

		[Tooltip("Event to send if the location cannot be queried.")]
		public FsmEvent errorEvent;

		public override void Reset()
		{
			longitude = null;
			latitude = null;
			altitude = null;
			horizontalAccuracy = null;
			verticalAccuracy = null;
			errorEvent = null;
		}

		public override void OnEnter()
		{
			DoGetLocationInfo();
			Finish();
		}

		private void DoGetLocationInfo()
		{
			if (Input.location.status != LocationServiceStatus.Running)
			{
				base.Fsm.Event(errorEvent);
				return;
			}
			float num = Input.location.lastData.longitude;
			float num2 = Input.location.lastData.latitude;
			float num3 = Input.location.lastData.altitude;
			vectorPosition.Value = new Vector3(num, num2, num3);
			longitude.Value = num;
			latitude.Value = num2;
			altitude.Value = num3;
			horizontalAccuracy.Value = Input.location.lastData.horizontalAccuracy;
			verticalAccuracy.Value = Input.location.lastData.verticalAccuracy;
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Gets the number of Touches.")]
	public class GetTouchCount : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the current number of touches in an Int Variable.")]
		public FsmInt storeCount;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			storeCount = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetTouchCount();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTouchCount();
		}

		private void DoGetTouchCount()
		{
			storeCount.Value = Input.touchCount;
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Gets info on a touch event.")]
	public class GetTouchInfo : FsmStateAction
	{
		[Tooltip("Filter by a Finger ID. You can store a Finger ID in other Touch actions, e.g., Touch Event.")]
		public FsmInt fingerId;

		[Tooltip("If true, all screen coordinates are returned normalized (0-1), otherwise in pixels.")]
		public FsmBool normalize;

		[UIHint(UIHint.Variable)]
		public FsmVector3 storePosition;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeX;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeY;

		[UIHint(UIHint.Variable)]
		public FsmVector3 storeDeltaPosition;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeDeltaX;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeDeltaY;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeDeltaTime;

		[UIHint(UIHint.Variable)]
		public FsmInt storeTapCount;

		public bool everyFrame = true;

		private float screenWidth;

		private float screenHeight;

		public override void Reset()
		{
			fingerId = new FsmInt
			{
				UseVariable = true
			};
			normalize = true;
			storePosition = null;
			storeDeltaPosition = null;
			storeDeltaTime = null;
			storeTapCount = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			screenWidth = Screen.width;
			screenHeight = Screen.height;
			DoGetTouchInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTouchInfo();
		}

		private void DoGetTouchInfo()
		{
			if (Input.touchCount <= 0)
			{
				return;
			}
			Touch[] touches = Input.touches;
			for (int i = 0; i < touches.Length; i++)
			{
				Touch touch = touches[i];
				if (fingerId.IsNone || touch.fingerId == fingerId.Value)
				{
					float num = ((!normalize.Value) ? touch.position.x : (touch.position.x / screenWidth));
					float num2 = ((!normalize.Value) ? touch.position.y : (touch.position.y / screenHeight));
					if (!storePosition.IsNone)
					{
						storePosition.Value = new Vector3(num, num2, 0f);
					}
					storeX.Value = num;
					storeY.Value = num2;
					float num3 = ((!normalize.Value) ? touch.deltaPosition.x : (touch.deltaPosition.x / screenWidth));
					float num4 = ((!normalize.Value) ? touch.deltaPosition.y : (touch.deltaPosition.y / screenHeight));
					if (!storeDeltaPosition.IsNone)
					{
						storeDeltaPosition.Value = new Vector3(num3, num4, 0f);
					}
					storeDeltaX.Value = num3;
					storeDeltaY.Value = num4;
					storeDeltaTime.Value = touch.deltaTime;
					storeTapCount.Value = touch.tapCount;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Projects the location found with Get Location Info to a 2d map using common projections.")]
	public class ProjectLocationToMap : FsmStateAction
	{
		public enum MapProjection
		{
			EquidistantCylindrical,
			Mercator
		}

		[Tooltip("Location vector in degrees longitude and latitude. Typically returned by the Get Location Info action.")]
		public FsmVector3 GPSLocation;

		[Tooltip("The projection used by the map.")]
		public MapProjection mapProjection;

		[ActionSection("Map Region")]
		[HasFloatSlider(-180f, 180f)]
		public FsmFloat minLongitude;

		[HasFloatSlider(-180f, 180f)]
		public FsmFloat maxLongitude;

		[HasFloatSlider(-90f, 90f)]
		public FsmFloat minLatitude;

		[HasFloatSlider(-90f, 90f)]
		public FsmFloat maxLatitude;

		[ActionSection("Screen Region")]
		public FsmFloat minX;

		public FsmFloat minY;

		public FsmFloat width;

		public FsmFloat height;

		[ActionSection("Projection")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the projected X coordinate in a Float Variable. Use this to display a marker on the map.")]
		public FsmFloat projectedX;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the projected Y coordinate in a Float Variable. Use this to display a marker on the map.")]
		public FsmFloat projectedY;

		[Tooltip("If true all coordinates in this action are normalized (0-1); otherwise coordinates are in pixels.")]
		public FsmBool normalized;

		public bool everyFrame;

		private float x;

		private float y;

		public override void Reset()
		{
			GPSLocation = new FsmVector3
			{
				UseVariable = true
			};
			mapProjection = MapProjection.EquidistantCylindrical;
			minLongitude = -180f;
			maxLongitude = 180f;
			minLatitude = -90f;
			maxLatitude = 90f;
			minX = 0f;
			minY = 0f;
			width = 1f;
			height = 1f;
			normalized = true;
			projectedX = null;
			projectedY = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			if (GPSLocation.IsNone)
			{
				Finish();
				return;
			}
			DoProjectGPSLocation();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoProjectGPSLocation();
		}

		private void DoProjectGPSLocation()
		{
			x = Mathf.Clamp(GPSLocation.Value.x, minLongitude.Value, maxLongitude.Value);
			y = Mathf.Clamp(GPSLocation.Value.y, minLatitude.Value, maxLatitude.Value);
			switch (mapProjection)
			{
			case MapProjection.EquidistantCylindrical:
				DoEquidistantCylindrical();
				break;
			case MapProjection.Mercator:
				DoMercatorProjection();
				break;
			}
			x *= width.Value;
			y *= height.Value;
			projectedX.Value = (normalized.Value ? (minX.Value + x) : (minX.Value + x * (float)Screen.width));
			projectedY.Value = (normalized.Value ? (minY.Value + y) : (minY.Value + y * (float)Screen.height));
		}

		private void DoEquidistantCylindrical()
		{
			x = (x - minLongitude.Value) / (maxLongitude.Value - minLongitude.Value);
			y = (y - minLatitude.Value) / (maxLatitude.Value - minLatitude.Value);
		}

		private void DoMercatorProjection()
		{
			x = (x - minLongitude.Value) / (maxLongitude.Value - minLongitude.Value);
			float num = LatitudeToMercator(minLatitude.Value);
			float num2 = LatitudeToMercator(maxLatitude.Value);
			y = (LatitudeToMercator(GPSLocation.Value.y) - num) / (num2 - num);
		}

		private static float LatitudeToMercator(float latitudeInDegrees)
		{
			float num = Mathf.Clamp(latitudeInDegrees, -85f, 85f);
			num = (float)Math.PI / 180f * num;
			return Mathf.Log(Mathf.Tan(num / 2f + (float)Math.PI / 4f));
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Starts location service updates. Last location coordinates can be retrieved with GetLocationInfo.")]
	public class StartLocationServiceUpdates : FsmStateAction
	{
		[Tooltip("Maximum time to wait in seconds before failing.")]
		public FsmFloat maxWait;

		public FsmFloat desiredAccuracy;

		public FsmFloat updateDistance;

		[Tooltip("Event to send when the location services have started.")]
		public FsmEvent successEvent;

		[Tooltip("Event to send if the location services fail to start.")]
		public FsmEvent failedEvent;

		private float startTime;

		public override void Reset()
		{
			maxWait = 20f;
			desiredAccuracy = 10f;
			updateDistance = 10f;
			successEvent = null;
			failedEvent = null;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			Input.location.Start(desiredAccuracy.Value, updateDistance.Value);
		}

		public override void OnUpdate()
		{
			if (Input.location.status == LocationServiceStatus.Failed || Input.location.status == LocationServiceStatus.Stopped || FsmTime.RealtimeSinceStartup - startTime > maxWait.Value)
			{
				base.Fsm.Event(failedEvent);
				Finish();
			}
			if (Input.location.status == LocationServiceStatus.Running)
			{
				base.Fsm.Event(successEvent);
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Stops location service updates. This could be useful for saving battery life.")]
	public class StopLocationServiceUpdates : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnEnter()
		{
			Input.location.Stop();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Sends an event when a swipe is detected.")]
	public class SwipeGestureEvent : FsmStateAction
	{
		[Tooltip("How far a touch has to travel to be considered a swipe. Uses normalized distance (e.g. 1 = 1 screen diagonal distance). Should generally be a very small number.")]
		public FsmFloat minSwipeDistance;

		[Tooltip("Event to send when swipe left detected.")]
		public FsmEvent swipeLeftEvent;

		[Tooltip("Event to send when swipe right detected.")]
		public FsmEvent swipeRightEvent;

		[Tooltip("Event to send when swipe up detected.")]
		public FsmEvent swipeUpEvent;

		[Tooltip("Event to send when swipe down detected.")]
		public FsmEvent swipeDownEvent;

		private float screenDiagonalSize;

		private float minSwipeDistancePixels;

		private bool touchStarted;

		private Vector2 touchStartPos;

		public override void Reset()
		{
			minSwipeDistance = 0.1f;
			swipeLeftEvent = null;
			swipeRightEvent = null;
			swipeUpEvent = null;
			swipeDownEvent = null;
		}

		public override void OnEnter()
		{
			screenDiagonalSize = Mathf.Sqrt(Screen.width * Screen.width + Screen.height * Screen.height);
			minSwipeDistancePixels = minSwipeDistance.Value * screenDiagonalSize;
		}

		public override void OnUpdate()
		{
			if (Input.touchCount <= 0)
			{
				return;
			}
			Touch touch = Input.touches[0];
			switch (touch.phase)
			{
			case TouchPhase.Began:
				touchStarted = true;
				touchStartPos = touch.position;
				break;
			case TouchPhase.Ended:
				if (touchStarted)
				{
					TestForSwipeGesture(touch);
					touchStarted = false;
				}
				break;
			case TouchPhase.Canceled:
				touchStarted = false;
				break;
			case TouchPhase.Moved:
			case TouchPhase.Stationary:
				break;
			}
		}

		private void TestForSwipeGesture(Touch touch)
		{
			Vector2 position = touch.position;
			if (Vector2.Distance(position, touchStartPos) > minSwipeDistancePixels)
			{
				float x = position.y - touchStartPos.y;
				float y = position.x - touchStartPos.x;
				float num = 57.29578f * Mathf.Atan2(y, x);
				num = (360f + num - 45f) % 360f;
				UnityEngine.Debug.Log(num);
				if (num < 90f)
				{
					base.Fsm.Event(swipeRightEvent);
				}
				else if (num < 180f)
				{
					base.Fsm.Event(swipeDownEvent);
				}
				else if (num < 270f)
				{
					base.Fsm.Event(swipeLeftEvent);
				}
				else
				{
					base.Fsm.Event(swipeUpEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Sends events based on Touch Phases. Optionally filter by a fingerID.")]
	public class TouchEvent : FsmStateAction
	{
		public FsmInt fingerId;

		public TouchPhase touchPhase;

		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		public FsmInt storeFingerId;

		public override void Reset()
		{
			fingerId = new FsmInt
			{
				UseVariable = true
			};
			storeFingerId = null;
		}

		public override void OnUpdate()
		{
			if (Input.touchCount <= 0)
			{
				return;
			}
			Touch[] touches = Input.touches;
			for (int i = 0; i < touches.Length; i++)
			{
				Touch touch = touches[i];
				if ((fingerId.IsNone || touch.fingerId == fingerId.Value) && touch.phase == touchPhase)
				{
					storeFingerId.Value = touch.fingerId;
					base.Fsm.Event(sendEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Sends events when a GUI Texture or GUI Text is touched. Optionally filter by a fingerID.")]
	[Obsolete("GUIElement is part of the legacy UI system removed in 2019.3")]
	public class TouchGUIEvent : FsmStateAction
	{
		public enum OffsetOptions
		{
			TopLeft,
			Center,
			TouchStart
		}

		[RequiredField]
		[ActionSection("Obsolete. Use Unity UI instead.")]
		[Tooltip("The Game Object that owns the GUI Texture or GUI Text.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Only detect touches that match this fingerID, or set to None.")]
		public FsmInt fingerId;

		[ActionSection("Events")]
		[Tooltip("Event to send on touch began.")]
		public FsmEvent touchBegan;

		[Tooltip("Event to send on touch moved.")]
		public FsmEvent touchMoved;

		[Tooltip("Event to send on stationary touch.")]
		public FsmEvent touchStationary;

		[Tooltip("Event to send on touch ended.")]
		public FsmEvent touchEnded;

		[Tooltip("Event to send on touch cancel.")]
		public FsmEvent touchCanceled;

		[Tooltip("Event to send if not touching (finger down but not over the GUI element)")]
		public FsmEvent notTouching;

		[ActionSection("Store Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the fingerId of the touch.")]
		public FsmInt storeFingerId;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the screen position where the GUI element was touched.")]
		public FsmVector3 storeHitPoint;

		[Tooltip("Normalize the hit point screen coordinates (0-1).")]
		public FsmBool normalizeHitPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the offset position of the hit.")]
		public FsmVector3 storeOffset;

		[Tooltip("How to measure the offset.")]
		public OffsetOptions relativeTo;

		[Tooltip("Normalize the offset.")]
		public FsmBool normalizeOffset;

		[ActionSection("")]
		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private Vector3 touchStartPos;

		public override void Reset()
		{
			gameObject = null;
			fingerId = new FsmInt
			{
				UseVariable = true
			};
			touchBegan = null;
			touchMoved = null;
			touchStationary = null;
			touchEnded = null;
			touchCanceled = null;
			storeFingerId = null;
			storeHitPoint = null;
			normalizeHitPoint = false;
			storeOffset = null;
			relativeTo = OffsetOptions.Center;
			normalizeOffset = true;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[ActionTarget(typeof(GameObject), "gameObject", false)]
	[Tooltip("Sends events when an object is touched. Optionally filter by a fingerID. NOTE: Uses the MainCamera!")]
	public class TouchObjectEvent : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Collider))]
		[Tooltip("The Game Object to detect touches on.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("How far from the camera is the Game Object pickable.")]
		public FsmFloat pickDistance;

		[Tooltip("Only detect touches that match this fingerID, or set to None.")]
		public FsmInt fingerId;

		[ActionSection("Events")]
		[Tooltip("Event to send on touch began.")]
		public FsmEvent touchBegan;

		[Tooltip("Event to send on touch moved.")]
		public FsmEvent touchMoved;

		[Tooltip("Event to send on stationary touch.")]
		public FsmEvent touchStationary;

		[Tooltip("Event to send on touch ended.")]
		public FsmEvent touchEnded;

		[Tooltip("Event to send on touch cancel.")]
		public FsmEvent touchCanceled;

		[ActionSection("Store Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the fingerId of the touch.")]
		public FsmInt storeFingerId;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the world position where the object was touched.")]
		public FsmVector3 storeHitPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the surface normal vector where the object was touched.")]
		public FsmVector3 storeHitNormal;

		public override void Reset()
		{
			gameObject = null;
			pickDistance = 100f;
			fingerId = new FsmInt
			{
				UseVariable = true
			};
			touchBegan = null;
			touchMoved = null;
			touchStationary = null;
			touchEnded = null;
			touchCanceled = null;
			storeFingerId = null;
			storeHitPoint = null;
			storeHitNormal = null;
		}

		public override void OnUpdate()
		{
			if (Camera.main == null)
			{
				LogError("No MainCamera defined!");
				Finish();
			}
			else
			{
				if (Input.touchCount <= 0)
				{
					return;
				}
				GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
				if (ownerDefaultTarget == null)
				{
					return;
				}
				Touch[] touches = Input.touches;
				for (int i = 0; i < touches.Length; i++)
				{
					Touch touch = touches[i];
					if (!fingerId.IsNone && touch.fingerId != fingerId.Value)
					{
						continue;
					}
					Vector2 position = touch.position;
					Physics.Raycast(Camera.main.ScreenPointToRay(position), out var hitInfo, pickDistance.Value);
					base.Fsm.RaycastHitInfo = hitInfo;
					if (hitInfo.transform != null && hitInfo.transform.gameObject == ownerDefaultTarget)
					{
						storeFingerId.Value = touch.fingerId;
						storeHitPoint.Value = hitInfo.point;
						storeHitNormal.Value = hitInfo.normal;
						switch (touch.phase)
						{
						case TouchPhase.Began:
							base.Fsm.Event(touchBegan);
							return;
						case TouchPhase.Moved:
							base.Fsm.Event(touchMoved);
							return;
						case TouchPhase.Stationary:
							base.Fsm.Event(touchStationary);
							return;
						case TouchPhase.Ended:
							base.Fsm.Event(touchEnded);
							return;
						case TouchPhase.Canceled:
							base.Fsm.Event(touchCanceled);
							return;
						}
					}
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Effects)]
	[Tooltip("Turns a Game Object on/off in a regular repeating pattern.")]
	public class Blink : ComponentAction<Renderer>
	{
		[RequiredField]
		[Tooltip("The GameObject to blink on/off.")]
		public FsmOwnerDefault gameObject;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Time to stay off in seconds.")]
		public FsmFloat timeOff;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Time to stay on in seconds.")]
		public FsmFloat timeOn;

		[Tooltip("Should the object start in the active/visible state?")]
		public FsmBool startOn;

		[Tooltip("Only effect the renderer, keeping other components active.")]
		public bool rendererOnly;

		[Tooltip("Ignore TimeScale. Useful if the game is paused.")]
		public bool realTime;

		private float startTime;

		private float timer;

		private bool blinkOn;

		public override void Reset()
		{
			gameObject = null;
			timeOff = 0.5f;
			timeOn = 0.5f;
			rendererOnly = true;
			startOn = false;
			realTime = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			timer = 0f;
			UpdateBlinkState(startOn.Value);
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				timer = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				timer += Time.deltaTime;
			}
			if (blinkOn && timer > timeOn.Value)
			{
				UpdateBlinkState(state: false);
			}
			if (!blinkOn && timer > timeOff.Value)
			{
				UpdateBlinkState(state: true);
			}
		}

		private void UpdateBlinkState(bool state)
		{
			GameObject gameObject = ((this.gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : this.gameObject.GameObject.Value);
			if (gameObject == null)
			{
				return;
			}
			if (rendererOnly)
			{
				if (UpdateCache(gameObject))
				{
					base.renderer.enabled = state;
				}
			}
			else
			{
				gameObject.SetActive(state);
			}
			blinkOn = state;
			startTime = FsmTime.RealtimeSinceStartup;
			timer = 0f;
		}
	}
	[ActionCategory(ActionCategory.Effects)]
	[Tooltip("Randomly flickers a Game Object on/off.")]
	public class Flicker : ComponentAction<Renderer>
	{
		[RequiredField]
		[Tooltip("The GameObject to flicker.")]
		public FsmOwnerDefault gameObject;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("The frequency of the flicker in seconds.")]
		public FsmFloat frequency;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Amount of time flicker is On (0-1). E.g. Use 0.95 for an occasional flicker.")]
		public FsmFloat amountOn;

		[Tooltip("Only effect the renderer, leaving other components active.")]
		public bool rendererOnly;

		[Tooltip("Ignore time scale. Useful if flickering UI when the game is paused.")]
		public bool realTime;

		private float startTime;

		private float timer;

		public override void Reset()
		{
			gameObject = null;
			frequency = 0.1f;
			amountOn = 0.5f;
			rendererOnly = true;
			realTime = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			timer = 0f;
		}

		public override void OnUpdate()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (realTime)
			{
				timer = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				timer += Time.deltaTime;
			}
			if (!(timer > frequency.Value))
			{
				return;
			}
			bool flag = UnityEngine.Random.Range(0f, 1f) < amountOn.Value;
			if (rendererOnly)
			{
				if (UpdateCache(ownerDefaultTarget))
				{
					base.renderer.enabled = flag;
				}
			}
			else
			{
				ownerDefaultTarget.SetActive(flag);
			}
			startTime = timer;
			timer = 0f;
		}
	}
	[ActionCategory(ActionCategory.Enum)]
	[Tooltip("Sets the value of an Enum Variable.")]
	public class SetEnumValue : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The Enum Variable to set.")]
		public FsmEnum enumVariable;

		[MatchFieldType("enumVariable")]
		[Tooltip("The Enum value to set the variable to.")]
		public FsmEnum enumValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			enumVariable = null;
			enumValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetEnumValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetEnumValue();
		}

		private void DoSetEnumValue()
		{
			enumVariable.Value = enumValue.Value;
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Fills the screen with a Color. NOTE: Uses OnGUI so you need a PlayMakerGUI component in the scene.")]
	public class DrawFullscreenColor : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Color. NOTE: Uses OnGUI so you need a PlayMakerGUI component in the scene.")]
		public FsmColor color;

		public override void Reset()
		{
			color = Color.white;
		}

		public override void OnGUI()
		{
			Color obj = GUI.color;
			GUI.color = color.Value;
			GUI.DrawTexture(new Rect(0f, 0f, Screen.width, Screen.height), ActionHelpers.WhiteTexture);
			GUI.color = obj;
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Draws a GUI Texture. NOTE: Uses OnGUI so you need a PlayMakerGUI component in the scene.")]
	public class DrawTexture : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Texture to draw.")]
		public FsmTexture texture;

		[UIHint(UIHint.Variable)]
		[Tooltip("Rectangle on the screen to draw the texture within. Alternatively, set or override individual properties below.")]
		[Title("Position")]
		public FsmRect screenRect;

		[Tooltip("Left screen coordinate.")]
		public FsmFloat left;

		[Tooltip("Top screen coordinate.")]
		public FsmFloat top;

		[Tooltip("Width of texture on screen.")]
		public FsmFloat width;

		[Tooltip("Height of texture on screen.")]
		public FsmFloat height;

		[Tooltip("How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.")]
		public ScaleMode scaleMode;

		[Tooltip("Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.")]
		public FsmBool alphaBlend;

		[Tooltip("Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used. Pass in w/h for the desired aspect ratio. This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.")]
		public FsmFloat imageAspect;

		[Tooltip("Use normalized screen coordinates (0-1)")]
		public FsmBool normalized;

		private Rect rect;

		public override void Reset()
		{
			texture = null;
			screenRect = null;
			left = 0f;
			top = 0f;
			width = 1f;
			height = 1f;
			scaleMode = ScaleMode.StretchToFill;
			alphaBlend = true;
			imageAspect = 0f;
			normalized = true;
		}

		public override void OnGUI()
		{
			if (!(texture.Value == null))
			{
				rect = ((!screenRect.IsNone) ? screenRect.Value : default(Rect));
				if (!left.IsNone)
				{
					rect.x = left.Value;
				}
				if (!top.IsNone)
				{
					rect.y = top.Value;
				}
				if (!width.IsNone)
				{
					rect.width = width.Value;
				}
				if (!height.IsNone)
				{
					rect.height = height.Value;
				}
				if (normalized.Value)
				{
					rect.x *= Screen.width;
					rect.width *= Screen.width;
					rect.y *= Screen.height;
					rect.height *= Screen.height;
				}
				GUI.DrawTexture(rect, texture.Value, scaleMode, alphaBlend.Value, imageAspect.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Enables/Disables the PlayMakerGUI component in the scene. Note, you need a PlayMakerGUI component in the scene to see OnGUI actions. However, OnGUI can be very expensive on mobile devices. This action lets you turn OnGUI on/off (e.g., turn it on for a menu, and off during gameplay).")]
	public class EnableGUI : FsmStateAction
	{
		[Tooltip("Set to True to enable, False to disable.")]
		public FsmBool enableGUI;

		public override void Reset()
		{
			enableGUI = true;
		}

		public override void OnEnter()
		{
			PlayMakerGUI.Instance.enabled = enableGUI.Value;
			Finish();
		}
	}
	[Tooltip("GUI base action - don't use!")]
	public abstract class GUIAction : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmRect screenRect;

		public FsmFloat left;

		public FsmFloat top;

		public FsmFloat width;

		public FsmFloat height;

		[RequiredField]
		public FsmBool normalized;

		internal Rect rect;

		public override void Reset()
		{
			screenRect = null;
			left = 0f;
			top = 0f;
			width = 1f;
			height = 1f;
			normalized = true;
		}

		public override void OnGUI()
		{
			rect = ((!screenRect.IsNone) ? screenRect.Value : default(Rect));
			if (!left.IsNone)
			{
				rect.x = left.Value;
			}
			if (!top.IsNone)
			{
				rect.y = top.Value;
			}
			if (!width.IsNone)
			{
				rect.width = width.Value;
			}
			if (!height.IsNone)
			{
				rect.height = height.Value;
			}
			if (normalized.Value)
			{
				rect.x *= Screen.width;
				rect.width *= Screen.width;
				rect.y *= Screen.height;
				rect.height *= Screen.height;
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("GUI Box.")]
	public class GUIBox : GUIContentAction
	{
		public override void OnGUI()
		{
			base.OnGUI();
			if (string.IsNullOrEmpty(style.Value))
			{
				GUI.Box(rect, content);
			}
			else
			{
				GUI.Box(rect, content, style.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("GUI button. Sends an Event when pressed. Optionally store the button state in a Bool Variable.")]
	public class GUIButton : GUIContentAction
	{
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool storeButtonState;

		public override void Reset()
		{
			base.Reset();
			sendEvent = null;
			storeButtonState = null;
			style = "Button";
		}

		public override void OnGUI()
		{
			base.OnGUI();
			bool value = false;
			if (GUI.Button(rect, content, style.Value))
			{
				base.Fsm.Event(sendEvent);
				value = true;
			}
			if (storeButtonState != null)
			{
				storeButtonState.Value = value;
			}
		}
	}
	[Tooltip("GUI base action - don't use!")]
	public abstract class GUIContentAction : GUIAction
	{
		public FsmTexture image;

		public FsmString text;

		public FsmString tooltip;

		public FsmString style;

		internal GUIContent content;

		public override void Reset()
		{
			base.Reset();
			image = null;
			text = "";
			tooltip = "";
			style = "";
		}

		public override void OnGUI()
		{
			base.OnGUI();
			content = new GUIContent(text.Value, image.Value, tooltip.Value);
		}
	}
	[ActionCategory(ActionCategory.GUIElement)]
	[Tooltip("Performs a Hit Test on a Game Object with a GUITexture or GUIText component.")]
	[Obsolete("GUIElement is part of the legacy UI system removed in 2019.3")]
	public class GUIElementHitTest : FsmStateAction
	{
		[RequiredField]
		[ActionSection("Obsolete. Use Unity UI instead.")]
		[Tooltip("The GameObject that has a GUITexture or GUIText component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Specify camera or use MainCamera as default.")]
		public Camera camera;

		[Tooltip("A vector position on screen. Usually stored by actions like GetTouchInfo, or World To Screen Point.")]
		public FsmVector3 screenPoint;

		[Tooltip("Specify screen X coordinate.")]
		public FsmFloat screenX;

		[Tooltip("Specify screen Y coordinate.")]
		public FsmFloat screenY;

		[Tooltip("Whether the specified screen coordinates are normalized (0-1).")]
		public FsmBool normalized;

		[Tooltip("Event to send if the Hit Test is true.")]
		public FsmEvent hitEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result of the Hit Test in a bool variable (true/false).")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame. Useful if you want to wait for the hit test to return true.")]
		public FsmBool everyFrame;

		private GameObject gameObjectCached;

		public override void Reset()
		{
			gameObject = null;
			camera = null;
			screenPoint = new FsmVector3
			{
				UseVariable = true
			};
			screenX = new FsmFloat
			{
				UseVariable = true
			};
			screenY = new FsmFloat
			{
				UseVariable = true
			};
			normalized = true;
			hitEvent = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("GUI Horizontal Slider connected to a Float Variable.")]
	public class GUIHorizontalSlider : GUIAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		[RequiredField]
		public FsmFloat leftValue;

		[RequiredField]
		public FsmFloat rightValue;

		public FsmString sliderStyle;

		public FsmString thumbStyle;

		public override void Reset()
		{
			base.Reset();
			floatVariable = null;
			leftValue = 0f;
			rightValue = 100f;
			sliderStyle = "horizontalslider";
			thumbStyle = "horizontalsliderthumb";
		}

		public override void OnGUI()
		{
			base.OnGUI();
			if (floatVariable != null)
			{
				floatVariable.Value = GUI.HorizontalSlider(rect, floatVariable.Value, leftValue.Value, rightValue.Value, (sliderStyle.Value != "") ? sliderStyle.Value : "horizontalslider", (thumbStyle.Value != "") ? thumbStyle.Value : "horizontalsliderthumb");
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("GUI Label.")]
	public class GUILabel : GUIContentAction
	{
		public override void OnGUI()
		{
			base.OnGUI();
			if (string.IsNullOrEmpty(style.Value))
			{
				GUI.Label(rect, content);
			}
			else
			{
				GUI.Label(rect, content, style.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Gets the Tooltip of the control the mouse is currently over and store it in a String Variable.")]
	public class GUITooltip : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmString storeTooltip;

		public override void Reset()
		{
			storeTooltip = null;
		}

		public override void OnGUI()
		{
			storeTooltip.Value = GUI.tooltip;
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("GUI Vertical Slider connected to a Float Variable.")]
	public class GUIVerticalSlider : GUIAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		[RequiredField]
		public FsmFloat topValue;

		[RequiredField]
		public FsmFloat bottomValue;

		public FsmString sliderStyle;

		public FsmString thumbStyle;

		public override void Reset()
		{
			base.Reset();
			floatVariable = null;
			topValue = 100f;
			bottomValue = 0f;
			sliderStyle = "verticalslider";
			thumbStyle = "verticalsliderthumb";
			width = 0.1f;
		}

		public override void OnGUI()
		{
			base.OnGUI();
			if (floatVariable != null)
			{
				floatVariable.Value = GUI.VerticalSlider(rect, floatVariable.Value, topValue.Value, bottomValue.Value, (sliderStyle.Value != "") ? sliderStyle.Value : "verticalslider", (thumbStyle.Value != "") ? thumbStyle.Value : "verticalsliderthumb");
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Resets the GUI matrix. Useful if you've rotated or scaled the GUI and now want to reset it.")]
	public class ResetGUIMatrix : FsmStateAction
	{
		public override void OnGUI()
		{
			PlayMakerGUI.GUIMatrix = (GUI.matrix = Matrix4x4.identity);
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Rotates the GUI around a pivot point. By default only effects GUI rendered by this FSM, check Apply Globally to effect all GUI controls.")]
	public class RotateGUI : FsmStateAction
	{
		[RequiredField]
		public FsmFloat angle;

		[RequiredField]
		public FsmFloat pivotX;

		[RequiredField]
		public FsmFloat pivotY;

		public bool normalized;

		public bool applyGlobally;

		private bool applied;

		public override void Reset()
		{
			angle = 0f;
			pivotX = 0.5f;
			pivotY = 0.5f;
			normalized = true;
			applyGlobally = false;
		}

		public override void OnGUI()
		{
			if (!applied)
			{
				Vector2 pivotPoint = new Vector2(pivotX.Value, pivotY.Value);
				if (normalized)
				{
					pivotPoint.x *= Screen.width;
					pivotPoint.y *= Screen.height;
				}
				GUIUtility.RotateAroundPivot(angle.Value, pivotPoint);
				if (applyGlobally)
				{
					PlayMakerGUI.GUIMatrix = GUI.matrix;
					applied = true;
				}
			}
		}

		public override void OnUpdate()
		{
			applied = false;
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Scales the GUI around a pivot point. By default only effects GUI rendered by this FSM, check Apply Globally to effect all GUI controls.")]
	public class ScaleGUI : FsmStateAction
	{
		[RequiredField]
		public FsmFloat scaleX;

		[RequiredField]
		public FsmFloat scaleY;

		[RequiredField]
		public FsmFloat pivotX;

		[RequiredField]
		public FsmFloat pivotY;

		[Tooltip("Pivot point uses normalized coordinates. E.g. 0.5 is the center of the screen.")]
		public bool normalized;

		public bool applyGlobally;

		private bool applied;

		public override void Reset()
		{
			scaleX = 1f;
			scaleY = 1f;
			pivotX = 0.5f;
			pivotY = 0.5f;
			normalized = true;
			applyGlobally = false;
		}

		public override void OnGUI()
		{
			if (!applied)
			{
				Vector2 scale = new Vector2(scaleX.Value, scaleY.Value);
				if (object.Equals(scale.x, 0))
				{
					scale.x = 0.0001f;
				}
				if (object.Equals(scale.y, 0))
				{
					scale.x = 0.0001f;
				}
				Vector2 pivotPoint = new Vector2(pivotX.Value, pivotY.Value);
				if (normalized)
				{
					pivotPoint.x *= Screen.width;
					pivotPoint.y *= Screen.height;
				}
				GUIUtility.ScaleAroundPivot(scale, pivotPoint);
				if (applyGlobally)
				{
					PlayMakerGUI.GUIMatrix = GUI.matrix;
					applied = true;
				}
			}
		}

		public override void OnUpdate()
		{
			applied = false;
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Sets the global Alpha for the GUI. Useful for fading GUI up/down. By default only effects GUI rendered by this FSM, check Apply Globally to effect all GUI controls.")]
	public class SetGUIAlpha : FsmStateAction
	{
		[RequiredField]
		public FsmFloat alpha;

		public FsmBool applyGlobally;

		public override void Reset()
		{
			alpha = 1f;
		}

		public override void OnGUI()
		{
			GUI.color = new Color(GUI.color.r, GUI.color.g, GUI.color.b, alpha.Value);
			if (applyGlobally.Value)
			{
				PlayMakerGUI.GUIColor = GUI.color;
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Sets the Tinting Color for all background elements rendered by the GUI. By default only effects GUI rendered by this FSM, check Apply Globally to effect all GUI controls.")]
	public class SetGUIBackgroundColor : FsmStateAction
	{
		[RequiredField]
		public FsmColor backgroundColor;

		public FsmBool applyGlobally;

		public override void Reset()
		{
			backgroundColor = Color.white;
		}

		public override void OnGUI()
		{
			GUI.backgroundColor = backgroundColor.Value;
			if (applyGlobally.Value)
			{
				PlayMakerGUI.GUIBackgroundColor = GUI.backgroundColor;
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Sets the Tinting Color for the GUI. By default only effects GUI rendered by this FSM, check Apply Globally to effect all GUI controls.")]
	public class SetGUIColor : FsmStateAction
	{
		[RequiredField]
		public FsmColor color;

		public FsmBool applyGlobally;

		public override void Reset()
		{
			color = Color.white;
		}

		public override void OnGUI()
		{
			GUI.color = color.Value;
			if (applyGlobally.Value)
			{
				PlayMakerGUI.GUIColor = GUI.color;
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Sets the Tinting Color for all text rendered by the GUI. By default only effects GUI rendered by this FSM, check Apply Globally to effect all GUI controls.")]
	public class SetGUIContentColor : FsmStateAction
	{
		[RequiredField]
		public FsmColor contentColor;

		public FsmBool applyGlobally;

		public override void Reset()
		{
			contentColor = Color.white;
		}

		public override void OnGUI()
		{
			GUI.contentColor = contentColor.Value;
			if (applyGlobally.Value)
			{
				PlayMakerGUI.GUIContentColor = GUI.contentColor;
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Sets the sorting depth of subsequent GUI elements.")]
	public class SetGUIDepth : FsmStateAction
	{
		[RequiredField]
		public FsmInt depth;

		public override void Reset()
		{
			depth = 0;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleOnGUI = true;
		}

		public override void OnGUI()
		{
			GUI.depth = depth.Value;
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Sets the GUISkin used by GUI elements.")]
	public class SetGUISkin : FsmStateAction
	{
		[RequiredField]
		public GUISkin skin;

		public FsmBool applyGlobally;

		public override void Reset()
		{
			skin = null;
			applyGlobally = true;
		}

		public override void OnGUI()
		{
			if (skin != null)
			{
				GUI.skin = skin;
			}
			if (applyGlobally.Value)
			{
				PlayMakerGUI.GUISkin = skin;
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.GUI)]
	[Tooltip("Controls the appearance of Mouse Cursor.")]
	public class SetMouseCursor : FsmStateAction
	{
		public FsmTexture cursorTexture;

		public FsmBool hideCursor;

		public FsmBool lockCursor;

		public override void Reset()
		{
			cursorTexture = null;
			hideCursor = false;
			lockCursor = false;
		}

		public override void OnEnter()
		{
			PlayMakerGUI.LockCursor = lockCursor.Value;
			PlayMakerGUI.HideCursor = hideCursor.Value;
			PlayMakerGUI.MouseCursor = cursorTexture.Value;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GUIElement)]
	[Tooltip("Sets the Text used by the GUIText Component attached to a Game Object.")]
	[Obsolete("GUIText is part of the legacy UI system removed in 2019.3")]
	public class SetGUIText : FsmStateAction
	{
		[ActionSection("Obsolete. Use Unity UI instead.")]
		[UIHint(UIHint.TextArea)]
		public FsmString text;
	}
	[ActionCategory(ActionCategory.GUIElement)]
	[Tooltip("Sets the Texture used by the GUITexture attached to a Game Object.")]
	[Obsolete("GUITexture is part of the legacy UI system removed in 2019.3")]
	public class SetGUITexture : FsmStateAction
	{
		[ActionSection("Obsolete. Use Unity UI instead.")]
		public FsmTexture texture;
	}
	[ActionCategory(ActionCategory.GUIElement)]
	[Tooltip("Sets the Alpha of the GUITexture attached to a Game Object. Useful for fading GUI elements in/out.")]
	[Obsolete("GUITexture is part of the legacy UI system removed in 2019.3")]
	public class SetGUITextureAlpha : FsmStateAction
	{
		[ActionSection("Obsolete. Use Unity UI instead.")]
		public FsmFloat alpha;
	}
	[ActionCategory(ActionCategory.GUIElement)]
	[Tooltip("Sets the Color of the GUITexture attached to a Game Object.")]
	[Obsolete("GUITexture is part of the legacy UI system removed in 2019.3")]
	public class SetGUITextureColor : FsmStateAction
	{
		[ActionSection("Obsolete. Use Unity UI instead.")]
		public FsmColor color;
	}
	[Tooltip("GUILayout base action - don't use!")]
	public abstract class GUILayoutAction : FsmStateAction
	{
		public LayoutOption[] layoutOptions;

		private GUILayoutOption[] options;

		public GUILayoutOption[] LayoutOptions
		{
			get
			{
				if (options == null)
				{
					options = new GUILayoutOption[layoutOptions.Length];
					for (int i = 0; i < layoutOptions.Length; i++)
					{
						options[i] = layoutOptions[i].GetGUILayoutOption();
					}
				}
				return options;
			}
		}

		public override void Reset()
		{
			layoutOptions = new LayoutOption[0];
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Begin a GUILayout block of GUI controls in a fixed screen area. NOTE: Block must end with a corresponding GUILayoutEndArea.")]
	public class GUILayoutBeginArea : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmRect screenRect;

		public FsmFloat left;

		public FsmFloat top;

		public FsmFloat width;

		public FsmFloat height;

		public FsmBool normalized;

		public FsmString style;

		private Rect rect;

		public override void Reset()
		{
			screenRect = null;
			left = 0f;
			top = 0f;
			width = 1f;
			height = 1f;
			normalized = true;
			style = "";
		}

		public override void OnGUI()
		{
			rect = ((!screenRect.IsNone) ? screenRect.Value : default(Rect));
			if (!left.IsNone)
			{
				rect.x = left.Value;
			}
			if (!top.IsNone)
			{
				rect.y = top.Value;
			}
			if (!width.IsNone)
			{
				rect.width = width.Value;
			}
			if (!height.IsNone)
			{
				rect.height = height.Value;
			}
			if (normalized.Value)
			{
				rect.x *= Screen.width;
				rect.width *= Screen.width;
				rect.y *= Screen.height;
				rect.height *= Screen.height;
			}
			GUILayout.BeginArea(rect, GUIContent.none, style.Value);
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Begin a GUILayout area that follows the specified game object. Useful for overlays (e.g., playerName). NOTE: Block must end with a corresponding GUILayoutEndArea.")]
	public class GUILayoutBeginAreaFollowObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to follow.")]
		public FsmGameObject gameObject;

		[RequiredField]
		public FsmFloat offsetLeft;

		[RequiredField]
		public FsmFloat offsetTop;

		[RequiredField]
		public FsmFloat width;

		[RequiredField]
		public FsmFloat height;

		[Tooltip("Use normalized screen coordinates (0-1).")]
		public FsmBool normalized;

		[Tooltip("Optional named style in the current GUISkin")]
		public FsmString style;

		public override void Reset()
		{
			gameObject = null;
			offsetLeft = 0f;
			offsetTop = 0f;
			width = 1f;
			height = 1f;
			normalized = true;
			style = "";
		}

		public override void OnGUI()
		{
			GameObject value = gameObject.Value;
			if (value == null || Camera.main == null)
			{
				DummyBeginArea();
				return;
			}
			Vector3 position = value.transform.position;
			if (Camera.main.transform.InverseTransformPoint(position).z < 0f)
			{
				DummyBeginArea();
				return;
			}
			Vector2 vector = Camera.main.WorldToScreenPoint(position);
			float x = vector.x + (normalized.Value ? (offsetLeft.Value * (float)Screen.width) : offsetLeft.Value);
			float y = vector.y + (normalized.Value ? (offsetTop.Value * (float)Screen.width) : offsetTop.Value);
			Rect screenRect = new Rect(x, y, width.Value, height.Value);
			if (normalized.Value)
			{
				screenRect.width *= Screen.width;
				screenRect.height *= Screen.height;
			}
			screenRect.y = (float)Screen.height - screenRect.y;
			GUILayout.BeginArea(screenRect, style.Value);
		}

		private static void DummyBeginArea()
		{
			GUILayout.BeginArea(default(Rect));
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Begin a centered GUILayout block. The block is centered inside a parent GUILayout Area. So to place the block in the center of the screen, first use a GULayout Area the size of the whole screen (the default setting). NOTE: Block must end with a corresponding GUILayoutEndCentered.")]
	public class GUILayoutBeginCentered : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnGUI()
		{
			GUILayout.BeginVertical();
			GUILayout.FlexibleSpace();
			GUILayout.BeginHorizontal();
			GUILayout.FlexibleSpace();
			GUILayout.BeginVertical();
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout BeginHorizontal.")]
	public class GUILayoutBeginHorizontal : GUILayoutAction
	{
		public FsmTexture image;

		public FsmString text;

		public FsmString tooltip;

		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			text = "";
			image = null;
			tooltip = "";
			style = "";
		}

		public override void OnGUI()
		{
			GUILayout.BeginHorizontal(new GUIContent(text.Value, image.Value, tooltip.Value), style.Value, base.LayoutOptions);
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Begins a ScrollView. Use GUILayoutEndScrollView at the end of the block.")]
	public class GUILayoutBeginScrollView : GUILayoutAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Assign a Vector2 variable to store the scroll position of this view.")]
		public FsmVector2 scrollPosition;

		[Tooltip("Always show the horizontal scrollbars.")]
		public FsmBool horizontalScrollbar;

		[Tooltip("Always show the vertical scrollbars.")]
		public FsmBool verticalScrollbar;

		[Tooltip("Define custom styles below. NOTE: You have to define all the styles if you check this option.")]
		public FsmBool useCustomStyle;

		[Tooltip("Named style in the active GUISkin for the horizontal scrollbars.")]
		public FsmString horizontalStyle;

		[Tooltip("Named style in the active GUISkin for the vertical scrollbars.")]
		public FsmString verticalStyle;

		[Tooltip("Named style in the active GUISkin for the background.")]
		public FsmString backgroundStyle;

		public override void Reset()
		{
			base.Reset();
			scrollPosition = null;
			horizontalScrollbar = null;
			verticalScrollbar = null;
			useCustomStyle = null;
			horizontalStyle = null;
			verticalStyle = null;
			backgroundStyle = null;
		}

		public override void OnGUI()
		{
			if (useCustomStyle.Value)
			{
				scrollPosition.Value = GUILayout.BeginScrollView(scrollPosition.Value, horizontalScrollbar.Value, verticalScrollbar.Value, horizontalStyle.Value, verticalStyle.Value, backgroundStyle.Value, base.LayoutOptions);
			}
			else
			{
				scrollPosition.Value = GUILayout.BeginScrollView(scrollPosition.Value, horizontalScrollbar.Value, verticalScrollbar.Value, base.LayoutOptions);
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Begins a vertical control group. The group must be closed with GUILayoutEndVertical action.")]
	public class GUILayoutBeginVertical : GUILayoutAction
	{
		public FsmTexture image;

		public FsmString text;

		public FsmString tooltip;

		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			text = "";
			image = null;
			tooltip = "";
			style = "";
		}

		public override void OnGUI()
		{
			GUILayout.BeginVertical(new GUIContent(text.Value, image.Value, tooltip.Value), style.Value, base.LayoutOptions);
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Box.")]
	public class GUILayoutBox : GUILayoutAction
	{
		[Tooltip("Image to display in the Box.")]
		public FsmTexture image;

		[Tooltip("Text to display in the Box.")]
		public FsmString text;

		[Tooltip("Optional Tooltip string.")]
		public FsmString tooltip;

		[Tooltip("Optional GUIStyle in the active GUISkin.")]
		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			text = "";
			image = null;
			tooltip = "";
			style = "";
		}

		public override void OnGUI()
		{
			if (string.IsNullOrEmpty(style.Value))
			{
				GUILayout.Box(new GUIContent(text.Value, image.Value, tooltip.Value), base.LayoutOptions);
			}
			else
			{
				GUILayout.Box(new GUIContent(text.Value, image.Value, tooltip.Value), style.Value, base.LayoutOptions);
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Button. Sends an Event when pressed. Optionally stores the button state in a Bool Variable.")]
	public class GUILayoutButton : GUILayoutAction
	{
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool storeButtonState;

		public FsmTexture image;

		public FsmString text;

		public FsmString tooltip;

		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			sendEvent = null;
			storeButtonState = null;
			text = "";
			image = null;
			tooltip = "";
			style = "";
		}

		public override void OnGUI()
		{
			bool flag = ((!string.IsNullOrEmpty(style.Value)) ? GUILayout.Button(new GUIContent(text.Value, image.Value, tooltip.Value), style.Value, base.LayoutOptions) : GUILayout.Button(new GUIContent(text.Value, image.Value, tooltip.Value), base.LayoutOptions));
			if (flag)
			{
				base.Fsm.Event(sendEvent);
			}
			if (storeButtonState != null)
			{
				storeButtonState.Value = flag;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Password Field. Optionally send an event if the text has been edited.")]
	public class GUILayoutConfirmPasswordField : GUILayoutAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The password Text")]
		public FsmString text;

		[Tooltip("The Maximum Length of the field")]
		public FsmInt maxLength;

		[Tooltip("The Style of the Field")]
		public FsmString style;

		[Tooltip("Event sent when field content changed")]
		public FsmEvent changedEvent;

		[Tooltip("Replacement character to hide the password")]
		public FsmString mask;

		[Tooltip("GUILayout Password Field. Optionally send an event if the text has been edited.")]
		public FsmBool confirm;

		[Tooltip("Confirmation content")]
		public FsmString password;

		public override void Reset()
		{
			text = null;
			maxLength = 25;
			style = "TextField";
			mask = "*";
			changedEvent = null;
			confirm = false;
			password = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			text.Value = GUILayout.PasswordField(text.Value, mask.Value[0], style.Value, base.LayoutOptions);
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Password Field. Optionally send an event if the text has been edited.")]
	public class GUILayoutEmailField : GUILayoutAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The email Text")]
		public FsmString text;

		[Tooltip("The Maximum Length of the field")]
		public FsmInt maxLength;

		[Tooltip("The Style of the Field")]
		public FsmString style;

		[Tooltip("Event sent when field content changed")]
		public FsmEvent changedEvent;

		[Tooltip("Email valid format flag")]
		public FsmBool valid;

		public override void Reset()
		{
			text = null;
			maxLength = 25;
			style = "TextField";
			valid = true;
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			text.Value = GUILayout.TextField(text.Value, style.Value, base.LayoutOptions);
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Close a GUILayout group started with BeginArea.")]
	public class GUILayoutEndArea : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnGUI()
		{
			GUILayout.EndArea();
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("End a centered GUILayout block started with GUILayoutBeginCentered.")]
	public class GUILayoutEndCentered : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnGUI()
		{
			GUILayout.EndVertical();
			GUILayout.FlexibleSpace();
			GUILayout.EndHorizontal();
			GUILayout.FlexibleSpace();
			GUILayout.EndVertical();
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Close a group started with BeginHorizontal.")]
	public class GUILayoutEndHorizontal : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnGUI()
		{
			GUILayout.EndHorizontal();
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Close a group started with GUILayout Begin ScrollView.")]
	public class GUILayoutEndScrollView : FsmStateAction
	{
		public override void OnGUI()
		{
			GUILayout.EndScrollView();
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Close a group started with BeginVertical.")]
	public class GUILayoutEndVertical : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnGUI()
		{
			GUILayout.EndVertical();
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Inserts a flexible space element.")]
	public class GUILayoutFlexibleSpace : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnGUI()
		{
			GUILayout.FlexibleSpace();
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Text Field to edit a Float Variable. Optionally send an event if the text has been edited.")]
	public class GUILayoutFloatField : GUILayoutAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Float Variable to show in the edit field.")]
		public FsmFloat floatVariable;

		[Tooltip("Optional GUIStyle in the active GUISKin.")]
		public FsmString style;

		[Tooltip("Optional event to send when the value changes.")]
		public FsmEvent changedEvent;

		public override void Reset()
		{
			base.Reset();
			floatVariable = null;
			style = "";
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			if (!string.IsNullOrEmpty(style.Value))
			{
				floatVariable.Value = float.Parse(GUILayout.TextField(floatVariable.Value.ToString(), style.Value, base.LayoutOptions));
			}
			else
			{
				floatVariable.Value = float.Parse(GUILayout.TextField(floatVariable.Value.ToString(), base.LayoutOptions));
			}
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Label for a Float Variable.")]
	public class GUILayoutFloatLabel : GUILayoutAction
	{
		[Tooltip("Text to put before the float variable.")]
		public FsmString prefix;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Float variable to display.")]
		public FsmFloat floatVariable;

		[Tooltip("Optional GUIStyle in the active GUISKin.")]
		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			prefix = "";
			style = "";
			floatVariable = null;
		}

		public override void OnGUI()
		{
			if (string.IsNullOrEmpty(style.Value))
			{
				GUILayout.Label(new GUIContent(prefix.Value + floatVariable.Value), base.LayoutOptions);
			}
			else
			{
				GUILayout.Label(new GUIContent(prefix.Value + floatVariable.Value), style.Value, base.LayoutOptions);
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("A Horizontal Slider linked to a Float Variable.")]
	public class GUILayoutHorizontalSlider : GUILayoutAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		[RequiredField]
		public FsmFloat leftValue;

		[RequiredField]
		public FsmFloat rightValue;

		public FsmEvent changedEvent;

		public override void Reset()
		{
			base.Reset();
			floatVariable = null;
			leftValue = 0f;
			rightValue = 100f;
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			if (floatVariable != null)
			{
				floatVariable.Value = GUILayout.HorizontalSlider(floatVariable.Value, leftValue.Value, rightValue.Value, base.LayoutOptions);
			}
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Text Field to edit an Int Variable. Optionally send an event if the text has been edited.")]
	public class GUILayoutIntField : GUILayoutAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Int Variable to show in the edit field.")]
		public FsmInt intVariable;

		[Tooltip("Optional GUIStyle in the active GUISKin.")]
		public FsmString style;

		[Tooltip("Optional event to send when the value changes.")]
		public FsmEvent changedEvent;

		public override void Reset()
		{
			base.Reset();
			intVariable = null;
			style = "";
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			if (!string.IsNullOrEmpty(style.Value))
			{
				intVariable.Value = int.Parse(GUILayout.TextField(intVariable.Value.ToString(), style.Value, base.LayoutOptions));
			}
			else
			{
				intVariable.Value = int.Parse(GUILayout.TextField(intVariable.Value.ToString(), base.LayoutOptions));
			}
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Label for an Int Variable.")]
	public class GUILayoutIntLabel : GUILayoutAction
	{
		[Tooltip("Text to put before the int variable.")]
		public FsmString prefix;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Int variable to display.")]
		public FsmInt intVariable;

		[Tooltip("Optional GUIStyle in the active GUISKin.")]
		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			prefix = "";
			style = "";
			intVariable = null;
		}

		public override void OnGUI()
		{
			if (string.IsNullOrEmpty(style.Value))
			{
				GUILayout.Label(new GUIContent(prefix.Value + intVariable.Value), base.LayoutOptions);
			}
			else
			{
				GUILayout.Label(new GUIContent(prefix.Value + intVariable.Value), style.Value, base.LayoutOptions);
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Label.")]
	public class GUILayoutLabel : GUILayoutAction
	{
		public FsmTexture image;

		public FsmString text;

		public FsmString tooltip;

		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			text = "";
			image = null;
			tooltip = "";
			style = "";
		}

		public override void OnGUI()
		{
			if (string.IsNullOrEmpty(style.Value))
			{
				GUILayout.Label(new GUIContent(text.Value, image.Value, tooltip.Value), base.LayoutOptions);
			}
			else
			{
				GUILayout.Label(new GUIContent(text.Value, image.Value, tooltip.Value), style.Value, base.LayoutOptions);
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Password Field. Optionally send an event if the text has been edited.")]
	public class GUILayoutPasswordField : GUILayoutAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The password Text")]
		public FsmString text;

		[Tooltip("The Maximum Length of the field")]
		public FsmInt maxLength;

		[Tooltip("The Style of the Field")]
		public FsmString style;

		[Tooltip("Event sent when field content changed")]
		public FsmEvent changedEvent;

		[Tooltip("Replacement character to hide the password")]
		public FsmString mask;

		public override void Reset()
		{
			text = null;
			maxLength = 25;
			style = "TextField";
			mask = "*";
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			text.Value = GUILayout.PasswordField(text.Value, mask.Value[0], style.Value, base.LayoutOptions);
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Repeat Button. Sends an Event while pressed. Optionally store the button state in a Bool Variable.")]
	public class GUILayoutRepeatButton : GUILayoutAction
	{
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool storeButtonState;

		public FsmTexture image;

		public FsmString text;

		public FsmString tooltip;

		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			sendEvent = null;
			storeButtonState = null;
			text = "";
			image = null;
			tooltip = "";
			style = "";
		}

		public override void OnGUI()
		{
			bool flag = ((!string.IsNullOrEmpty(style.Value)) ? GUILayout.RepeatButton(new GUIContent(text.Value, image.Value, tooltip.Value), style.Value, base.LayoutOptions) : GUILayout.RepeatButton(new GUIContent(text.Value, image.Value, tooltip.Value), base.LayoutOptions));
			if (flag)
			{
				base.Fsm.Event(sendEvent);
			}
			storeButtonState.Value = flag;
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Inserts a space in the current layout group.")]
	public class GUILayoutSpace : FsmStateAction
	{
		public FsmFloat space;

		public override void Reset()
		{
			space = 10f;
		}

		public override void OnGUI()
		{
			GUILayout.Space(space.Value);
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Text Field. Optionally send an event if the text has been edited.")]
	public class GUILayoutTextField : GUILayoutAction
	{
		[UIHint(UIHint.Variable)]
		public FsmString text;

		public FsmInt maxLength;

		public FsmString style;

		public FsmEvent changedEvent;

		public override void Reset()
		{
			base.Reset();
			text = null;
			maxLength = 25;
			style = "TextField";
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			text.Value = GUILayout.TextField(text.Value, maxLength.Value, style.Value, base.LayoutOptions);
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Label for simple text.")]
	public class GUILayoutTextLabel : GUILayoutAction
	{
		[Tooltip("Text to display.")]
		public FsmString text;

		[Tooltip("Optional GUIStyle in the active GUISkin.")]
		public FsmString style;

		public override void Reset()
		{
			base.Reset();
			text = "";
			style = "";
		}

		public override void OnGUI()
		{
			if (string.IsNullOrEmpty(style.Value))
			{
				GUILayout.Label(new GUIContent(text.Value), base.LayoutOptions);
			}
			else
			{
				GUILayout.Label(new GUIContent(text.Value), style.Value, base.LayoutOptions);
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Makes an on/off Toggle Button and stores the button state in a Bool Variable.")]
	public class GUILayoutToggle : GUILayoutAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmBool storeButtonState;

		public FsmTexture image;

		public FsmString text;

		public FsmString tooltip;

		public FsmString style;

		public FsmEvent changedEvent;

		public override void Reset()
		{
			base.Reset();
			storeButtonState = null;
			text = "";
			image = null;
			tooltip = "";
			style = "Toggle";
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			storeButtonState.Value = GUILayout.Toggle(storeButtonState.Value, new GUIContent(text.Value, image.Value, tooltip.Value), style.Value, base.LayoutOptions);
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("GUILayout Toolbar. NOTE: Arrays must be the same length as NumButtons or empty.")]
	public class GUILayoutToolbar : GUILayoutAction
	{
		[Tooltip("The number of buttons in the toolbar")]
		public FsmInt numButtons;

		[Tooltip("Store the index of the selected button in an Integer Variable")]
		[UIHint(UIHint.Variable)]
		public FsmInt selectedButton;

		[Tooltip("Event to send when each button is pressed.")]
		public FsmEvent[] buttonEventsArray;

		[Tooltip("Image to use on each button.")]
		public FsmTexture[] imagesArray;

		[Tooltip("Text to use on each button.")]
		public FsmString[] textsArray;

		[Tooltip("Tooltip to use for each button.")]
		public FsmString[] tooltipsArray;

		[Tooltip("A named GUIStyle to use for the toolbar buttons. Default is Button.")]
		public FsmString style;

		[Tooltip("Update the content of the buttons every frame. Useful if the buttons are using variables that change.")]
		public bool everyFrame;

		private GUIContent[] contents;

		public GUIContent[] Contents
		{
			get
			{
				if (contents == null)
				{
					SetButtonsContent();
				}
				return contents;
			}
		}

		private void SetButtonsContent()
		{
			if (contents == null)
			{
				contents = new GUIContent[numButtons.Value];
			}
			for (int i = 0; i < numButtons.Value; i++)
			{
				contents[i] = new GUIContent();
			}
			for (int j = 0; j < imagesArray.Length; j++)
			{
				contents[j].image = imagesArray[j].Value;
			}
			for (int k = 0; k < textsArray.Length; k++)
			{
				contents[k].text = textsArray[k].Value;
			}
			for (int l = 0; l < tooltipsArray.Length; l++)
			{
				contents[l].tooltip = tooltipsArray[l].Value;
			}
		}

		public override void Reset()
		{
			base.Reset();
			numButtons = 0;
			selectedButton = null;
			buttonEventsArray = new FsmEvent[0];
			imagesArray = new FsmTexture[0];
			tooltipsArray = new FsmString[0];
			style = "Button";
			everyFrame = false;
		}

		public override void OnEnter()
		{
			string text = ErrorCheck();
			if (!string.IsNullOrEmpty(text))
			{
				LogError(text);
				Finish();
			}
		}

		public override void OnGUI()
		{
			if (everyFrame)
			{
				SetButtonsContent();
			}
			bool changed = GUI.changed;
			GUI.changed = false;
			selectedButton.Value = GUILayout.Toolbar(selectedButton.Value, Contents, style.Value, base.LayoutOptions);
			if (GUI.changed)
			{
				if (selectedButton.Value < buttonEventsArray.Length)
				{
					base.Fsm.Event(buttonEventsArray[selectedButton.Value]);
					GUIUtility.ExitGUI();
				}
			}
			else
			{
				GUI.changed = changed;
			}
		}

		public override string ErrorCheck()
		{
			string text = "";
			if (imagesArray.Length != 0 && imagesArray.Length != numButtons.Value)
			{
				text += "Images array doesn't match NumButtons.\n";
			}
			if (textsArray.Length != 0 && textsArray.Length != numButtons.Value)
			{
				text += "Texts array doesn't match NumButtons.\n";
			}
			if (tooltipsArray.Length != 0 && tooltipsArray.Length != numButtons.Value)
			{
				text += "Tooltips array doesn't match NumButtons.\n";
			}
			return text;
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("A Vertical Slider linked to a Float Variable.")]
	public class GUILayoutVerticalSlider : GUILayoutAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		[RequiredField]
		public FsmFloat topValue;

		[RequiredField]
		public FsmFloat bottomValue;

		public FsmEvent changedEvent;

		public override void Reset()
		{
			base.Reset();
			floatVariable = null;
			topValue = 100f;
			bottomValue = 0f;
			changedEvent = null;
		}

		public override void OnGUI()
		{
			bool changed = GUI.changed;
			GUI.changed = false;
			if (floatVariable != null)
			{
				floatVariable.Value = GUILayout.VerticalSlider(floatVariable.Value, topValue.Value, bottomValue.Value, base.LayoutOptions);
			}
			if (GUI.changed)
			{
				base.Fsm.Event(changedEvent);
				GUIUtility.ExitGUI();
			}
			else
			{
				GUI.changed = changed;
			}
		}
	}
	[ActionCategory(ActionCategory.GUILayout)]
	[Tooltip("Turn GUILayout on/off. If you don't use GUILayout actions you can get some performance back by turning GUILayout off. This can make a difference on iOS platforms.")]
	public class UseGUILayout : FsmStateAction
	{
		[RequiredField]
		public bool turnOffGUIlayout;

		public override void Reset()
		{
			turnOffGUIlayout = true;
		}

		public override void OnEnter()
		{
			base.Fsm.Owner.useGUILayout = !turnOffGUIlayout;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Activates/deactivates a Game Object. Use this to hide/show areas, or enable/disable many Behaviours at once.")]
	public class ActivateGameObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to activate/deactivate.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Check to activate, uncheck to deactivate Game Object.")]
		public FsmBool activate;

		[Tooltip("Recursively activate/deactivate all children.")]
		public FsmBool recursive;

		[Tooltip("Reset the game objects when exiting this state. Useful if you want an object to be active only while this state is active.\nNote: Only applies to the last Game Object activated/deactivated (won't work if Game Object changes).")]
		public bool resetOnExit;

		[Tooltip("Repeat this action every frame. Useful if Activate changes over time.")]
		public bool everyFrame;

		private GameObject activatedGameObject;

		public override void Reset()
		{
			gameObject = null;
			activate = true;
			recursive = true;
			resetOnExit = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoActivateGameObject();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoActivateGameObject();
		}

		public override void OnExit()
		{
			if (!(activatedGameObject == null) && resetOnExit)
			{
				if (recursive.Value)
				{
					SetActiveRecursively(activatedGameObject, !activate.Value);
				}
				else
				{
					activatedGameObject.SetActive(!activate.Value);
				}
			}
		}

		private void DoActivateGameObject()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				if (recursive.Value)
				{
					SetActiveRecursively(ownerDefaultTarget, activate.Value);
				}
				else
				{
					ownerDefaultTarget.SetActive(activate.Value);
				}
				activatedGameObject = ownerDefaultTarget;
			}
		}

		public void SetActiveRecursively(GameObject go, bool state)
		{
			go.SetActive(state);
			foreach (Transform item in go.transform)
			{
				SetActiveRecursively(item.gameObject, state);
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Adds a Component to a Game Object. Use this to change the behaviour of objects on the fly. Optionally remove the Component on exiting the state.")]
	public class AddComponent : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to add the Component to.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.ScriptComponent)]
		[Title("Component Type")]
		[Tooltip("The type of Component to add to the Game Object.")]
		public FsmString component;

		[UIHint(UIHint.Variable)]
		[ObjectType(typeof(Component))]
		[Tooltip("Store the component in an Object variable. E.g., to use with Set Property.")]
		public FsmObject storeComponent;

		[Tooltip("Remove the Component when this State is exited.")]
		public FsmBool removeOnExit;

		private Component addedComponent;

		public override void Reset()
		{
			gameObject = null;
			component = null;
			storeComponent = null;
		}

		public override void OnEnter()
		{
			DoAddComponent();
			Finish();
		}

		public override void OnExit()
		{
			if (removeOnExit.Value && addedComponent != null)
			{
				UnityEngine.Object.Destroy(addedComponent);
			}
		}

		private void DoAddComponent()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				addedComponent = ownerDefaultTarget.AddComponent(ReflectionUtils.GetGlobalType(component.Value));
				storeComponent.Value = addedComponent;
				if (addedComponent == null)
				{
					LogError("Can't add component: " + component.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Creates a Game Object at a spawn point.\nUse a Game Object and/or Position/Rotation for the Spawn Point. If you specify a Game Object, Position is used as a local offset, and Rotation will override the object's rotation.")]
	public class CreateEmptyObject : FsmStateAction
	{
		[Tooltip("Optional GameObject to create. Usually a Prefab.")]
		public FsmGameObject gameObject;

		[Tooltip("Optional Spawn Point.")]
		public FsmGameObject spawnPoint;

		[Tooltip("Position. If a Spawn Point is defined, this is used as a local offset from the Spawn Point position.")]
		public FsmVector3 position;

		[Tooltip("Rotation. NOTE: Overrides the rotation of the Spawn Point.")]
		public FsmVector3 rotation;

		[UIHint(UIHint.Variable)]
		[Tooltip("Optionally store the created object.")]
		public FsmGameObject storeObject;

		public override void Reset()
		{
			gameObject = null;
			spawnPoint = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			rotation = new FsmVector3
			{
				UseVariable = true
			};
			storeObject = null;
		}

		public override void OnEnter()
		{
			GameObject value = gameObject.Value;
			Vector3 vector = Vector3.zero;
			Vector3 eulerAngles = Vector3.zero;
			if (spawnPoint.Value != null)
			{
				vector = spawnPoint.Value.transform.position;
				if (!position.IsNone)
				{
					vector += position.Value;
				}
				eulerAngles = (rotation.IsNone ? spawnPoint.Value.transform.eulerAngles : rotation.Value);
			}
			else
			{
				if (!position.IsNone)
				{
					vector = position.Value;
				}
				if (!rotation.IsNone)
				{
					eulerAngles = rotation.Value;
				}
			}
			GameObject value2 = storeObject.Value;
			if (value != null)
			{
				value2 = UnityEngine.Object.Instantiate(value);
				storeObject.Value = value2;
			}
			else
			{
				value2 = new GameObject("EmptyObjectFromNull");
				storeObject.Value = value2;
			}
			if (value2 != null)
			{
				value2.transform.position = vector;
				value2.transform.eulerAngles = eulerAngles;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[ActionTarget(typeof(GameObject), "gameObject", true)]
	[Tooltip("Creates a Game Object, usually using a Prefab.")]
	public class CreateObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("GameObject to create. Usually a Prefab.")]
		public FsmGameObject gameObject;

		[Tooltip("Optional Spawn Point.")]
		public FsmGameObject spawnPoint;

		[Tooltip("Position. If a Spawn Point is defined, this is used as a local offset from the Spawn Point position.")]
		public FsmVector3 position;

		[Tooltip("Rotation. NOTE: Overrides the rotation of the Spawn Point.")]
		public FsmVector3 rotation;

		[UIHint(UIHint.Variable)]
		[Tooltip("Optionally store the created object.")]
		public FsmGameObject storeObject;

		public override void Reset()
		{
			gameObject = null;
			spawnPoint = null;
			position = new FsmVector3
			{
				UseVariable = true
			};
			rotation = new FsmVector3
			{
				UseVariable = true
			};
			storeObject = null;
		}

		public override void OnEnter()
		{
			GameObject value = gameObject.Value;
			if (value != null)
			{
				Vector3 vector = Vector3.zero;
				Vector3 euler = Vector3.zero;
				if (spawnPoint.Value != null)
				{
					vector = spawnPoint.Value.transform.position;
					if (!position.IsNone)
					{
						vector += position.Value;
					}
					euler = ((!rotation.IsNone) ? rotation.Value : spawnPoint.Value.transform.eulerAngles);
				}
				else
				{
					if (!position.IsNone)
					{
						vector = position.Value;
					}
					if (!rotation.IsNone)
					{
						euler = rotation.Value;
					}
				}
				GameObject value2 = UnityEngine.Object.Instantiate(value, vector, Quaternion.Euler(euler));
				storeObject.Value = value2;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Destroys a Component of an Object.")]
	public class DestroyComponent : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the Component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.ScriptComponent)]
		[Tooltip("The name of the Component to destroy.")]
		public FsmString component;

		private Component aComponent;

		public override void Reset()
		{
			aComponent = null;
			gameObject = null;
			component = null;
		}

		public override void OnEnter()
		{
			DoDestroyComponent((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			Finish();
		}

		private void DoDestroyComponent(GameObject go)
		{
			aComponent = go.GetComponent(ReflectionUtils.GetGlobalType(component.Value));
			if (aComponent == null)
			{
				LogError("No such component: " + component.Value);
			}
			else
			{
				UnityEngine.Object.Destroy(aComponent);
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Destroys a Game Object.")]
	public class DestroyObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to destroy.")]
		public FsmGameObject gameObject;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Optional delay before destroying the Game Object.")]
		public FsmFloat delay;

		[Tooltip("Detach children before destroying the Game Object.")]
		public FsmBool detachChildren;

		public override void Reset()
		{
			gameObject = null;
			delay = 0f;
		}

		public override void OnEnter()
		{
			GameObject value = gameObject.Value;
			if (value != null)
			{
				if (delay.Value <= 0f)
				{
					UnityEngine.Object.Destroy(value);
				}
				else
				{
					UnityEngine.Object.Destroy(value, delay.Value);
				}
				if (detachChildren.Value)
				{
					value.transform.DetachChildren();
				}
			}
			Finish();
		}

		public override void OnUpdate()
		{
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Destroys GameObjects in an array.")]
	public class DestroyObjects : FsmStateAction
	{
		[RequiredField]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		[Tooltip("The GameObjects to destroy.")]
		public FsmArray gameObjects;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Optional delay before destroying the Game Objects.")]
		public FsmFloat delay;

		[Tooltip("Detach children before destroying the Game Objects.")]
		public FsmBool detachChildren;

		public override void Reset()
		{
			gameObjects = null;
			delay = 0f;
		}

		public override void OnEnter()
		{
			if (gameObjects.Values != null)
			{
				object[] values = gameObjects.Values;
				for (int i = 0; i < values.Length; i++)
				{
					GameObject gameObject = (GameObject)values[i];
					if (gameObject != null)
					{
						if (delay.Value <= 0f)
						{
							UnityEngine.Object.Destroy(gameObject);
						}
						else
						{
							UnityEngine.Object.Destroy(gameObject, delay.Value);
						}
						if (detachChildren.Value)
						{
							gameObject.transform.DetachChildren();
						}
					}
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Destroys the Owner of the Fsm! Useful for spawned Prefabs that need to kill themselves, e.g., a projectile that explodes on impact.")]
	public class DestroySelf : FsmStateAction
	{
		[Tooltip("Detach children before destroying the Owner.")]
		public FsmBool detachChildren;

		public override void Reset()
		{
			detachChildren = false;
		}

		public override void OnEnter()
		{
			if (base.Owner != null)
			{
				if (detachChildren.Value)
				{
					base.Owner.transform.DetachChildren();
				}
				UnityEngine.Object.Destroy(base.Owner);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Unparents all children from the Game Object.")]
	public class DetachChildren : FsmStateAction
	{
		[RequiredField]
		[Tooltip("GameObject to unparent children from.")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			DoDetachChildren(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private static void DoDetachChildren(GameObject go)
		{
			if (go != null)
			{
				go.transform.DetachChildren();
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Finds the Child of a GameObject by Name.\nNote, you can specify a path to the child, e.g., LeftShoulder/Arm/Hand/Finger. If you need to specify a tag, use GetChild.")]
	public class FindChild : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to search.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The name of the child. Note, you can specify a path to the child, e.g., LeftShoulder/Arm/Hand/Finger")]
		public FsmString childName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the child in a GameObject variable.")]
		public FsmGameObject storeResult;

		public override void Reset()
		{
			gameObject = null;
			childName = "";
			storeResult = null;
		}

		public override void OnEnter()
		{
			DoFindChild();
			Finish();
		}

		private void DoFindChild()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Transform transform = ownerDefaultTarget.transform.Find(childName.Value);
				storeResult.Value = ((transform != null) ? transform.gameObject : null);
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Finds the closest object to the specified Game Object.\nOptionally filter by Tag and Visibility.")]
	public class FindClosest : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to measure from.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Tag)]
		[Tooltip("Only consider objects with this Tag. NOTE: It's generally a lot quicker to find objects with a Tag!")]
		public FsmString withTag;

		[Tooltip("If checked, ignores the object that owns this FSM.")]
		public FsmBool ignoreOwner;

		[Tooltip("Only consider objects visible to the camera.")]
		public FsmBool mustBeVisible;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the closest object.")]
		public FsmGameObject storeObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the distance to the closest object.")]
		public FsmFloat storeDistance;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			withTag = "Untagged";
			ignoreOwner = true;
			mustBeVisible = false;
			storeObject = null;
			storeDistance = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoFindClosest();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFindClosest();
		}

		private void DoFindClosest()
		{
			GameObject gameObject = ((this.gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : this.gameObject.GameObject.Value);
			GameObject[] array = ((!string.IsNullOrEmpty(withTag.Value) && !(withTag.Value == "Untagged")) ? GameObject.FindGameObjectsWithTag(withTag.Value) : ((GameObject[])UnityEngine.Object.FindObjectsOfType(typeof(GameObject))));
			GameObject value = null;
			float num = float.PositiveInfinity;
			GameObject[] array2 = array;
			foreach (GameObject gameObject2 in array2)
			{
				if ((!ignoreOwner.Value || !(gameObject2 == base.Owner)) && (!mustBeVisible.Value || ActionHelpers.IsVisible(gameObject2)))
				{
					float sqrMagnitude = (gameObject.transform.position - gameObject2.transform.position).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num = sqrMagnitude;
						value = gameObject2;
					}
				}
			}
			storeObject.Value = value;
			if (!storeDistance.IsNone)
			{
				storeDistance.Value = Mathf.Sqrt(num);
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Finds a Game Object by Name and/or Tag.")]
	public class FindGameObject : FsmStateAction
	{
		[Tooltip("The name of the GameObject to find. You can leave this empty if you specify a Tag.")]
		public FsmString objectName;

		[UIHint(UIHint.Tag)]
		[Tooltip("Find a GameObject with this tag. If Object Name is specified then both name and Tag must match.")]
		public FsmString withTag;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a GameObject variable.")]
		public FsmGameObject store;

		public override void Reset()
		{
			objectName = "";
			withTag = "Untagged";
			store = null;
		}

		public override void OnEnter()
		{
			Find();
			Finish();
		}

		private void Find()
		{
			if (withTag.Value != "Untagged")
			{
				if (!string.IsNullOrEmpty(objectName.Value))
				{
					GameObject[] array = GameObject.FindGameObjectsWithTag(withTag.Value);
					foreach (GameObject gameObject in array)
					{
						if (gameObject.name == objectName.Value)
						{
							store.Value = gameObject;
							return;
						}
					}
					store.Value = null;
				}
				else
				{
					store.Value = GameObject.FindGameObjectWithTag(withTag.Value);
				}
			}
			else
			{
				store.Value = GameObject.Find(objectName.Value);
			}
		}

		public override string ErrorCheck()
		{
			if (string.IsNullOrEmpty(objectName.Value) && string.IsNullOrEmpty(withTag.Value))
			{
				return "Specify Name, Tag, or both.";
			}
			return null;
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Finds the Child of a GameObject by Name and/or Tag. Use this to find attach points etc. NOTE: This action will search recursively through all children and return the first match; To find a specific child use Find Child.")]
	public class GetChild : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to search.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The name of the child to search for.")]
		public FsmString childName;

		[UIHint(UIHint.Tag)]
		[Tooltip("The Tag to search for. If Child Name is set, both name and Tag need to match.")]
		public FsmString withTag;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a GameObject variable.")]
		public FsmGameObject storeResult;

		public override void Reset()
		{
			gameObject = null;
			childName = "";
			withTag = "Untagged";
			storeResult = null;
		}

		public override void OnEnter()
		{
			storeResult.Value = DoGetChildByName(base.Fsm.GetOwnerDefaultTarget(gameObject), childName.Value, withTag.Value);
			Finish();
		}

		private static GameObject DoGetChildByName(GameObject root, string name, string tag)
		{
			if (root == null)
			{
				return null;
			}
			foreach (Transform item in root.transform)
			{
				if (!string.IsNullOrEmpty(name))
				{
					if (item.name == name)
					{
						if (string.IsNullOrEmpty(tag))
						{
							return item.gameObject;
						}
						if (item.tag.Equals(tag))
						{
							return item.gameObject;
						}
					}
				}
				else if (!string.IsNullOrEmpty(tag) && item.tag == tag)
				{
					return item.gameObject;
				}
				GameObject gameObject = DoGetChildByName(item.gameObject, name, tag);
				if (gameObject != null)
				{
					return gameObject;
				}
			}
			return null;
		}

		public override string ErrorCheck()
		{
			if (string.IsNullOrEmpty(childName.Value) && string.IsNullOrEmpty(withTag.Value))
			{
				return "Specify Child Name, Tag, or both.";
			}
			return null;
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the number of children that a GameObject has.")]
	public class GetChildCount : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to test.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the number of children in an int variable.")]
		public FsmInt storeResult;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			DoGetChildCount();
			Finish();
		}

		private void DoGetChildCount()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				storeResult.Value = ownerDefaultTarget.transform.childCount;
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the Child of a GameObject by Index.\nE.g., O to get the first child. HINT: Use this with an integer variable to iterate through children.")]
	public class GetChildNum : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to search.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The index of the child to find.")]
		public FsmInt childIndex;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the child in a GameObject variable.")]
		public FsmGameObject store;

		public override void Reset()
		{
			gameObject = null;
			childIndex = 0;
			store = null;
		}

		public override void OnEnter()
		{
			store.Value = DoGetChildNum(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private GameObject DoGetChildNum(GameObject go)
		{
			if (go == null || go.transform.childCount == 0 || childIndex.Value < 0)
			{
				return null;
			}
			return go.transform.GetChild(childIndex.Value % go.transform.childCount).gameObject;
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Measures the Distance betweens 2 Game Objects and stores the result in a Float Variable.")]
	public class GetDistance : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Measure distance from this GameObject.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Target GameObject.")]
		public FsmGameObject target;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the distance in a float variable.")]
		public FsmFloat storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			target = null;
			storeResult = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoGetDistance();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetDistance();
		}

		private void DoGetDistance()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null) && !(target.Value == null) && storeResult != null)
			{
				storeResult.Value = Vector3.Distance(ownerDefaultTarget.transform.position, target.Value.transform.position);
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets a Game Object's Layer and stores it in an Int Variable.")]
	public class GetLayer : FsmStateAction
	{
		[RequiredField]
		public FsmGameObject gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetLayer();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetLayer();
		}

		private void DoGetLayer()
		{
			if (!(gameObject.Value == null))
			{
				storeResult.Value = gameObject.Value.layer;
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the name of a Game Object and stores it in a String Variable.")]
	public class GetName : FsmStateAction
	{
		[RequiredField]
		public FsmGameObject gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeName;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = new FsmGameObject
			{
				UseVariable = true
			};
			storeName = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetGameObjectName();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetGameObjectName();
		}

		private void DoGetGameObjectName()
		{
			GameObject value = gameObject.Value;
			storeName.Value = ((value != null) ? value.name : "");
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Each time this action is called it gets the next child of a GameObject. This lets you quickly loop through all the children of an object to perform actions on them. NOTE: To find a specific child use Find Child.")]
	public class GetNextChild : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The parent GameObject. Note, if GameObject changes, this action will reset and start again at the first child.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the next child in a GameObject variable.")]
		public FsmGameObject storeNextChild;

		[Tooltip("Event to send to get the next child.")]
		public FsmEvent loopEvent;

		[Tooltip("Event to send when there are no more children.")]
		public FsmEvent finishedEvent;

		[Tooltip("If you want to reset the iteration, raise this flag to true when you enter the state, it will indicate you want to start from the beginning again")]
		[UIHint(UIHint.Variable)]
		public FsmBool resetFlag;

		private GameObject go;

		private int nextChildIndex;

		public override void Reset()
		{
			gameObject = null;
			storeNextChild = null;
			loopEvent = null;
			finishedEvent = null;
			resetFlag = null;
		}

		public override void OnEnter()
		{
			if (resetFlag.Value)
			{
				nextChildIndex = 0;
				resetFlag.Value = false;
			}
			DoGetNextChild(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private void DoGetNextChild(GameObject parent)
		{
			if (parent == null)
			{
				return;
			}
			if (go != parent)
			{
				go = parent;
				nextChildIndex = 0;
			}
			if (nextChildIndex >= go.transform.childCount)
			{
				nextChildIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			storeNextChild.Value = parent.transform.GetChild(nextChildIndex).gameObject;
			if (nextChildIndex >= go.transform.childCount)
			{
				nextChildIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			nextChildIndex++;
			if (loopEvent != null)
			{
				base.Fsm.Event(loopEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the Game Object that owns the FSM and stores it in a game object variable.")]
	public class GetOwner : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeGameObject;

		public override void Reset()
		{
			storeGameObject = null;
		}

		public override void OnEnter()
		{
			storeGameObject.Value = base.Owner;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the Parent of a Game Object.")]
	public class GetParent : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		public FsmGameObject storeResult;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				storeResult.Value = ((ownerDefaultTarget.transform.parent == null) ? null : ownerDefaultTarget.transform.parent.gameObject);
			}
			else
			{
				storeResult.Value = null;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets a Random Child of a Game Object.")]
	public class GetRandomChild : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeResult;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			DoGetRandomChild();
			Finish();
		}

		private void DoGetRandomChild()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				int childCount = ownerDefaultTarget.transform.childCount;
				if (childCount != 0)
				{
					storeResult.Value = ownerDefaultTarget.transform.GetChild(UnityEngine.Random.Range(0, childCount)).gameObject;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets a Random Game Object from the scene.\nOptionally filter by Tag.")]
	public class GetRandomObject : FsmStateAction
	{
		[UIHint(UIHint.Tag)]
		public FsmString withTag;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			withTag = "Untagged";
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetRandomObject();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetRandomObject();
		}

		private void DoGetRandomObject()
		{
			GameObject[] array = ((!(withTag.Value != "Untagged")) ? ((GameObject[])UnityEngine.Object.FindObjectsOfType(typeof(GameObject))) : GameObject.FindGameObjectsWithTag(withTag.Value));
			if (array.Length != 0)
			{
				storeResult.Value = array[UnityEngine.Random.Range(0, array.Length)];
			}
			else
			{
				storeResult.Value = null;
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the top most parent of the Game Object.\nIf the game object has no parent, returns itself.")]
	public class GetRoot : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeRoot;

		public override void Reset()
		{
			gameObject = null;
			storeRoot = null;
		}

		public override void OnEnter()
		{
			DoGetRoot();
			Finish();
		}

		private void DoGetRoot()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				storeRoot.Value = ownerDefaultTarget.transform.root.gameObject;
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets a Game Object's Tag and stores it in a String Variable.")]
	public class GetTag : FsmStateAction
	{
		[RequiredField]
		public FsmGameObject gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetTag();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTag();
		}

		private void DoGetTag()
		{
			if (!(gameObject.Value == null))
			{
				storeResult.Value = gameObject.Value.tag;
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets the number of Game Objects in the scene with the specified Tag.")]
	public class GetTagCount : FsmStateAction
	{
		[UIHint(UIHint.Tag)]
		public FsmString tag;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt storeResult;

		public override void Reset()
		{
			tag = "Untagged";
			storeResult = null;
		}

		public override void OnEnter()
		{
			GameObject[] array = GameObject.FindGameObjectsWithTag(tag.Value);
			if (storeResult != null)
			{
				storeResult.Value = ((array != null) ? array.Length : 0);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Gets a Game Object's Transform and stores it in an Object Variable.")]
	public class GetTransform : FsmStateAction
	{
		[RequiredField]
		public FsmGameObject gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[ObjectType(typeof(Transform))]
		public FsmObject storeTransform;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = new FsmGameObject
			{
				UseVariable = true
			};
			storeTransform = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetGameObjectName();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetGameObjectName();
		}

		private void DoGetGameObjectName()
		{
			GameObject value = gameObject.Value;
			storeTransform.Value = ((value != null) ? value.transform : null);
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Checks if an Object has a Component. Optionally remove the Component on exiting the state.")]
	public class HasComponent : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.ScriptComponent)]
		public FsmString component;

		public FsmBool removeOnExit;

		public FsmEvent trueEvent;

		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool store;

		public bool everyFrame;

		private Component aComponent;

		public override void Reset()
		{
			aComponent = null;
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			component = null;
			store = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoHasComponent((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoHasComponent((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
		}

		public override void OnExit()
		{
			if (removeOnExit.Value && aComponent != null)
			{
				UnityEngine.Object.Destroy(aComponent);
			}
		}

		private void DoHasComponent(GameObject go)
		{
			if (go == null)
			{
				if (!store.IsNone)
				{
					store.Value = false;
				}
				base.Fsm.Event(falseEvent);
				return;
			}
			aComponent = go.GetComponent(ReflectionUtils.GetGlobalType(component.Value));
			if (!store.IsNone)
			{
				store.Value = aComponent != null;
			}
			base.Fsm.Event((aComponent != null) ? trueEvent : falseEvent);
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Selects a Random Game Object from an array of Game Objects.")]
	public class SelectRandomGameObject : FsmStateAction
	{
		[CompoundArray("Game Objects", "Game Object", "Weight")]
		public FsmGameObject[] gameObjects;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeGameObject;

		public override void Reset()
		{
			gameObjects = new FsmGameObject[3];
			weights = new FsmFloat[3] { 1f, 1f, 1f };
			storeGameObject = null;
		}

		public override void OnEnter()
		{
			DoSelectRandomGameObject();
			Finish();
		}

		private void DoSelectRandomGameObject()
		{
			if (gameObjects != null && gameObjects.Length != 0 && storeGameObject != null)
			{
				int randomWeightedIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				if (randomWeightedIndex != -1)
				{
					storeGameObject.Value = gameObjects[randomWeightedIndex].Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Sets the value of a Game Object Variable.")]
	public class SetGameObject : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject variable;

		public FsmGameObject gameObject;

		public bool everyFrame;

		public override void Reset()
		{
			variable = null;
			gameObject = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			variable.Value = gameObject.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			variable.Value = gameObject.Value;
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Sets a Game Object's Layer.")]
	public class SetLayer : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Layer)]
		public int layer;

		public override void Reset()
		{
			gameObject = null;
			layer = 0;
		}

		public override void OnEnter()
		{
			DoSetLayer();
			Finish();
		}

		private void DoSetLayer()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				ownerDefaultTarget.layer = layer;
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Sets a Game Object's Name.")]
	public class SetName : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmString name;

		public override void Reset()
		{
			gameObject = null;
			name = null;
		}

		public override void OnEnter()
		{
			DoSetLayer();
			Finish();
		}

		private void DoSetLayer()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				ownerDefaultTarget.name = name.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Sets the Parent of a Game Object.")]
	public class SetParent : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Game Object to parent.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The new parent for the Game Object.")]
		public FsmGameObject parent;

		[Tooltip("Set the local position to 0,0,0 after parenting.")]
		public FsmBool resetLocalPosition;

		[Tooltip("Set the local rotation to 0,0,0 after parenting.")]
		public FsmBool resetLocalRotation;

		public override void Reset()
		{
			gameObject = null;
			parent = null;
			resetLocalPosition = null;
			resetLocalRotation = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				ownerDefaultTarget.transform.parent = ((parent.Value == null) ? null : parent.Value.transform);
				if (resetLocalPosition.Value)
				{
					ownerDefaultTarget.transform.localPosition = Vector3.zero;
				}
				if (resetLocalRotation.Value)
				{
					ownerDefaultTarget.transform.localRotation = Quaternion.identity;
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Sets a Game Object's Tag.")]
	public class SetTag : FsmStateAction
	{
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Tag)]
		public FsmString tag;

		public override void Reset()
		{
			gameObject = null;
			tag = "Untagged";
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				ownerDefaultTarget.tag = tag.Value;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.GameObject)]
	[Tooltip("Set the Tag on all children of a GameObject. Optionally filter by component.")]
	public class SetTagsOnChildren : FsmStateAction
	{
		[RequiredField]
		[Tooltip("GameObject Parent")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Tag)]
		[Tooltip("Set Tag To...")]
		public FsmString tag;

		[UIHint(UIHint.ScriptComponent)]
		[Tooltip("Only set the Tag on children with this component.")]
		public FsmString filterByComponent;

		private Type componentFilter;

		public override void Reset()
		{
			gameObject = null;
			tag = null;
			filterByComponent = null;
		}

		public override void OnEnter()
		{
			SetTag(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private void SetTag(GameObject parent)
		{
			if (parent == null)
			{
				return;
			}
			if (string.IsNullOrEmpty(filterByComponent.Value))
			{
				foreach (Transform item in parent.transform)
				{
					item.gameObject.tag = tag.Value;
				}
			}
			else
			{
				UpdateComponentFilter();
				if (componentFilter != null)
				{
					Component[] componentsInChildren = parent.GetComponentsInChildren(componentFilter);
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].gameObject.tag = tag.Value;
					}
				}
			}
			Finish();
		}

		private void UpdateComponentFilter()
		{
			componentFilter = ReflectionUtils.GetGlobalType(filterByComponent.Value);
			if (componentFilter == null)
			{
				componentFilter = ReflectionUtils.GetGlobalType("UnityEngine." + filterByComponent.Value);
			}
			if (componentFilter == null)
			{
				UnityEngine.Debug.LogWarning("Couldn't get type: " + filterByComponent.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends an Event when the user hits any Key or Mouse Button.")]
	public class AnyKey : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Event to send when any Key or Mouse Button is pressed.")]
		public FsmEvent sendEvent;

		public override void Reset()
		{
			sendEvent = null;
		}

		public override void OnUpdate()
		{
			if (Input.anyKeyDown)
			{
				base.Fsm.Event(sendEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Gets the value of the specified Input Axis and stores it in a Float Variable. See Unity Input Manager docs.")]
	public class GetAxis : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The name of the axis. Set in the Unity Input Manager.")]
		public FsmString axisName;

		[Tooltip("Axis values are in the range -1 to 1. Use the multiplier to set a larger range.")]
		public FsmFloat multiplier;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a float variable.")]
		public FsmFloat store;

		[Tooltip("Repeat every frame. Typically this would be set to True.")]
		public bool everyFrame;

		public override void Reset()
		{
			axisName = "";
			multiplier = 1f;
			store = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoGetAxis();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetAxis();
		}

		private void DoGetAxis()
		{
			if (!FsmString.IsNullOrEmpty(axisName))
			{
				float num = Input.GetAxis(axisName.Value);
				if (!multiplier.IsNone)
				{
					num *= multiplier.Value;
				}
				store.Value = num;
			}
		}
	}
	[NoActionTargets]
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Gets a world direction Vector from 2 Input Axis. Typically used for a third person controller with Relative To set to the camera.")]
	public class GetAxisVector : FsmStateAction
	{
		public enum AxisPlane
		{
			XZ,
			XY,
			YZ
		}

		[Tooltip("The name of the horizontal input axis. See Unity Input Manager.")]
		public FsmString horizontalAxis;

		[Tooltip("The name of the vertical input axis. See Unity Input Manager.")]
		public FsmString verticalAxis;

		[Tooltip("Input axis are reported in the range -1 to 1, this multiplier lets you set a new range.")]
		public FsmFloat multiplier;

		[RequiredField]
		[Tooltip("The world plane to map the 2d input onto.")]
		public AxisPlane mapToPlane;

		[Tooltip("Make the result relative to a GameObject, typically the main camera.")]
		public FsmGameObject relativeTo;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the direction vector.")]
		public FsmVector3 storeVector;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the length of the direction vector.")]
		public FsmFloat storeMagnitude;

		public override void Reset()
		{
			horizontalAxis = "Horizontal";
			verticalAxis = "Vertical";
			multiplier = 1f;
			mapToPlane = AxisPlane.XZ;
			storeVector = null;
			storeMagnitude = null;
		}

		public override void OnUpdate()
		{
			Vector3 vector = default(Vector3);
			Vector3 vector2 = default(Vector3);
			if (relativeTo.Value == null)
			{
				switch (mapToPlane)
				{
				case AxisPlane.XZ:
					vector = Vector3.forward;
					vector2 = Vector3.right;
					break;
				case AxisPlane.XY:
					vector = Vector3.up;
					vector2 = Vector3.right;
					break;
				case AxisPlane.YZ:
					vector = Vector3.up;
					vector2 = Vector3.forward;
					break;
				}
			}
			else
			{
				Transform transform = relativeTo.Value.transform;
				switch (mapToPlane)
				{
				case AxisPlane.XZ:
					vector = transform.TransformDirection(Vector3.forward);
					vector.y = 0f;
					vector = vector.normalized;
					vector2 = new Vector3(vector.z, 0f, 0f - vector.x);
					break;
				case AxisPlane.XY:
				case AxisPlane.YZ:
					vector = Vector3.up;
					vector.z = 0f;
					vector = vector.normalized;
					vector2 = transform.TransformDirection(Vector3.right);
					break;
				}
			}
			float num = ((horizontalAxis.IsNone || string.IsNullOrEmpty(horizontalAxis.Value)) ? 0f : Input.GetAxis(horizontalAxis.Value));
			float num2 = ((verticalAxis.IsNone || string.IsNullOrEmpty(verticalAxis.Value)) ? 0f : Input.GetAxis(verticalAxis.Value));
			Vector3 value = num * vector2 + num2 * vector;
			value *= multiplier.Value;
			storeVector.Value = value;
			if (!storeMagnitude.IsNone)
			{
				storeMagnitude.Value = value.magnitude;
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Gets the pressed state of the specified Button and stores it in a Bool Variable. See Unity Input Manager docs.")]
	public class GetButton : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The name of the button. Set in the Unity Input Manager.")]
		public FsmString buttonName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			buttonName = "Fire1";
			storeResult = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoGetButton();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetButton();
		}

		private void DoGetButton()
		{
			storeResult.Value = Input.GetButton(buttonName.Value);
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends an Event when a Button is pressed.")]
	public class GetButtonDown : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The name of the button. Set in the Unity Input Manager.")]
		public FsmString buttonName;

		[Tooltip("Event to send if the button is pressed.")]
		public FsmEvent sendEvent;

		[Tooltip("Set to True if the button is pressed.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		public override void Reset()
		{
			buttonName = "Fire1";
			sendEvent = null;
			storeResult = null;
		}

		public override void OnUpdate()
		{
			bool buttonDown = Input.GetButtonDown(buttonName.Value);
			if (buttonDown)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = buttonDown;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends an Event when a Button is released.")]
	public class GetButtonUp : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The name of the button. Set in the Unity Input Manager.")]
		public FsmString buttonName;

		[Tooltip("Event to send if the button is released.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Set to True if the button is released.")]
		public FsmBool storeResult;

		public override void Reset()
		{
			buttonName = "Fire1";
			sendEvent = null;
			storeResult = null;
		}

		public override void OnUpdate()
		{
			bool buttonUp = Input.GetButtonUp(buttonName.Value);
			if (buttonUp)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = buttonUp;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Gets the pressed state of a Key.")]
	public class GetKey : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The key to test.")]
		public KeyCode key;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store if the key is down (True) or up (False).")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame. Useful if you're waiting for a key press/release.")]
		public bool everyFrame;

		public override void Reset()
		{
			key = KeyCode.None;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetKey();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetKey();
		}

		private void DoGetKey()
		{
			storeResult.Value = Input.GetKey(key);
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends an Event when a Key is pressed.")]
	public class GetKeyDown : FsmStateAction
	{
		[RequiredField]
		public KeyCode key;

		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		public override void Reset()
		{
			sendEvent = null;
			key = KeyCode.None;
			storeResult = null;
		}

		public override void OnUpdate()
		{
			bool keyDown = Input.GetKeyDown(key);
			if (keyDown)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = keyDown;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends an Event when a Key is released.")]
	public class GetKeyUp : FsmStateAction
	{
		[RequiredField]
		public KeyCode key;

		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		public override void Reset()
		{
			sendEvent = null;
			key = KeyCode.None;
			storeResult = null;
		}

		public override void OnUpdate()
		{
			bool keyUp = Input.GetKeyUp(key);
			if (keyUp)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = keyUp;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Gets the pressed state of the specified Mouse Button and stores it in a Bool Variable. See Unity Input Manager doc.")]
	public class GetMouseButton : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The mouse button to test.")]
		public MouseButton button;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the pressed state in a Bool Variable.")]
		public FsmBool storeResult;

		public override void Reset()
		{
			button = MouseButton.Left;
			storeResult = null;
		}

		public override void OnEnter()
		{
			storeResult.Value = Input.GetMouseButton((int)button);
		}

		public override void OnUpdate()
		{
			storeResult.Value = Input.GetMouseButton((int)button);
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends an Event when the specified Mouse Button is pressed. Optionally store the button state in a bool variable.")]
	public class GetMouseButtonDown : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The mouse button to test.")]
		public MouseButton button;

		[Tooltip("Event to send if the mouse button is down.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the button state in a Bool Variable.")]
		public FsmBool storeResult;

		[Tooltip("Uncheck to run when entering the state.")]
		public bool inUpdateOnly;

		public override void Reset()
		{
			button = MouseButton.Left;
			sendEvent = null;
			storeResult = null;
			inUpdateOnly = true;
		}

		public override void OnEnter()
		{
			if (!inUpdateOnly)
			{
				DoGetMouseButtonDown();
			}
		}

		public override void OnUpdate()
		{
			DoGetMouseButtonDown();
		}

		private void DoGetMouseButtonDown()
		{
			bool mouseButtonDown = Input.GetMouseButtonDown((int)button);
			if (mouseButtonDown)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = mouseButtonDown;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends an Event when the specified Mouse Button is released. Optionally store the button state in a bool variable.")]
	public class GetMouseButtonUp : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The mouse button to test.")]
		public MouseButton button;

		[Tooltip("Event to send if the mouse button is down.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the pressed state in a Bool Variable.")]
		public FsmBool storeResult;

		[Tooltip("Uncheck to run when entering the state.")]
		public bool inUpdateOnly;

		public override void Reset()
		{
			button = MouseButton.Left;
			sendEvent = null;
			storeResult = null;
			inUpdateOnly = true;
		}

		public override void OnEnter()
		{
			if (!inUpdateOnly)
			{
				DoGetMouseButtonUp();
			}
		}

		public override void OnUpdate()
		{
			DoGetMouseButtonUp();
		}

		public void DoGetMouseButtonUp()
		{
			bool mouseButtonUp = Input.GetMouseButtonUp((int)button);
			if (mouseButtonUp)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = mouseButtonUp;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Gets the X Position of the mouse and stores it in a Float Variable.")]
	public class GetMouseX : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		public bool normalize;

		public override void Reset()
		{
			storeResult = null;
			normalize = true;
		}

		public override void OnEnter()
		{
			DoGetMouseX();
		}

		public override void OnUpdate()
		{
			DoGetMouseX();
		}

		private void DoGetMouseX()
		{
			if (storeResult != null)
			{
				float num = Input.mousePosition.x;
				if (normalize)
				{
					num /= (float)Screen.width;
				}
				storeResult.Value = num;
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Gets the Y Position of the mouse and stores it in a Float Variable.")]
	public class GetMouseY : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		public bool normalize;

		public override void Reset()
		{
			storeResult = null;
			normalize = true;
		}

		public override void OnEnter()
		{
			DoGetMouseY();
		}

		public override void OnUpdate()
		{
			DoGetMouseY();
		}

		private void DoGetMouseY()
		{
			if (storeResult != null)
			{
				float num = Input.mousePosition.y;
				if (normalize)
				{
					num /= (float)Screen.height;
				}
				storeResult.Value = num;
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Rotates a GameObject based on mouse movement. Minimum and Maximum values can be used to constrain the rotation.")]
	public class MouseLook : FsmStateAction
	{
		public enum RotationAxes
		{
			MouseXAndY,
			MouseX,
			MouseY
		}

		[RequiredField]
		[Tooltip("The GameObject to rotate.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The axes to rotate around.")]
		public RotationAxes axes;

		[RequiredField]
		[Tooltip("Sensitivity of movement in X direction.")]
		public FsmFloat sensitivityX;

		[RequiredField]
		[Tooltip("Sensitivity of movement in Y direction.")]
		public FsmFloat sensitivityY;

		[HasFloatSlider(-360f, 360f)]
		[Tooltip("Clamp rotation around X axis. Set to None for no clamping.")]
		public FsmFloat minimumX;

		[HasFloatSlider(-360f, 360f)]
		[Tooltip("Clamp rotation around X axis. Set to None for no clamping.")]
		public FsmFloat maximumX;

		[HasFloatSlider(-360f, 360f)]
		[Tooltip("Clamp rotation around Y axis. Set to None for no clamping.")]
		public FsmFloat minimumY;

		[HasFloatSlider(-360f, 360f)]
		[Tooltip("Clamp rotation around Y axis. Set to None for no clamping.")]
		public FsmFloat maximumY;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private float rotationX;

		private float rotationY;

		public override void Reset()
		{
			gameObject = null;
			axes = RotationAxes.MouseXAndY;
			sensitivityX = 15f;
			sensitivityY = 15f;
			minimumX = new FsmFloat
			{
				UseVariable = true
			};
			maximumX = new FsmFloat
			{
				UseVariable = true
			};
			minimumY = -60f;
			maximumY = 60f;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			Rigidbody component = ownerDefaultTarget.GetComponent<Rigidbody>();
			if (component != null)
			{
				component.freezeRotation = true;
			}
			rotationX = ownerDefaultTarget.transform.localRotation.eulerAngles.y;
			rotationY = ownerDefaultTarget.transform.localRotation.eulerAngles.x;
			DoMouseLook();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMouseLook();
		}

		private void DoMouseLook()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Transform transform = ownerDefaultTarget.transform;
				switch (axes)
				{
				case RotationAxes.MouseXAndY:
					transform.localEulerAngles = new Vector3(GetYRotation(), GetXRotation(), 0f);
					break;
				case RotationAxes.MouseX:
					transform.localEulerAngles = new Vector3(transform.localEulerAngles.x, GetXRotation(), 0f);
					break;
				case RotationAxes.MouseY:
					transform.localEulerAngles = new Vector3(0f - GetYRotation(), transform.localEulerAngles.y, 0f);
					break;
				}
			}
		}

		private float GetXRotation()
		{
			rotationX += Input.GetAxis("Mouse X") * sensitivityX.Value;
			rotationX = ClampAngle(rotationX, minimumX, maximumX);
			return rotationX;
		}

		private float GetYRotation()
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY.Value;
			rotationY = ClampAngle(rotationY, minimumY, maximumY);
			return rotationY;
		}

		private static float ClampAngle(float angle, FsmFloat min, FsmFloat max)
		{
			if (!min.IsNone && angle < min.Value)
			{
				angle = min.Value;
			}
			if (!max.IsNone && angle > max.Value)
			{
				angle = max.Value;
			}
			return angle;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Rotates a GameObject based on mouse movement. Minimum and Maximum values can be used to constrain the rotation.")]
	public class MouseLook2 : ComponentAction<Rigidbody>
	{
		public enum RotationAxes
		{
			MouseXAndY,
			MouseX,
			MouseY
		}

		[RequiredField]
		[Tooltip("The GameObject to rotate.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The axes to rotate around.")]
		public RotationAxes axes;

		[RequiredField]
		public FsmFloat sensitivityX;

		[RequiredField]
		public FsmFloat sensitivityY;

		[RequiredField]
		[HasFloatSlider(-360f, 360f)]
		public FsmFloat minimumX;

		[RequiredField]
		[HasFloatSlider(-360f, 360f)]
		public FsmFloat maximumX;

		[RequiredField]
		[HasFloatSlider(-360f, 360f)]
		public FsmFloat minimumY;

		[RequiredField]
		[HasFloatSlider(-360f, 360f)]
		public FsmFloat maximumY;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private float rotationX;

		private float rotationY;

		public override void Reset()
		{
			gameObject = null;
			axes = RotationAxes.MouseXAndY;
			sensitivityX = 15f;
			sensitivityY = 15f;
			minimumX = -360f;
			maximumX = 360f;
			minimumY = -60f;
			maximumY = 60f;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				Finish();
				return;
			}
			if (!UpdateCache(ownerDefaultTarget) && (bool)base.rigidbody)
			{
				base.rigidbody.freezeRotation = true;
			}
			DoMouseLook();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMouseLook();
		}

		private void DoMouseLook()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Transform transform = ownerDefaultTarget.transform;
				switch (axes)
				{
				case RotationAxes.MouseXAndY:
					transform.localEulerAngles = new Vector3(GetYRotation(), GetXRotation(), 0f);
					break;
				case RotationAxes.MouseX:
					transform.localEulerAngles = new Vector3(transform.localEulerAngles.x, GetXRotation(), 0f);
					break;
				case RotationAxes.MouseY:
					transform.localEulerAngles = new Vector3(0f - GetYRotation(), transform.localEulerAngles.y, 0f);
					break;
				}
			}
		}

		private float GetXRotation()
		{
			rotationX += Input.GetAxis("Mouse X") * sensitivityX.Value;
			rotationX = ClampAngle(rotationX, minimumX, maximumX);
			return rotationX;
		}

		private float GetYRotation()
		{
			rotationY += Input.GetAxis("Mouse Y") * sensitivityY.Value;
			rotationY = ClampAngle(rotationY, minimumY, maximumY);
			return rotationY;
		}

		private static float ClampAngle(float angle, FsmFloat min, FsmFloat max)
		{
			if (!min.IsNone && angle < min.Value)
			{
				angle = min.Value;
			}
			if (!max.IsNone && angle > max.Value)
			{
				angle = max.Value;
			}
			return angle;
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Perform a Mouse Pick on the scene from the Main Camera and stores the results. Use Ray Distance to set how close the camera must be to pick the object.")]
	public class MousePick : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Set the length of the ray to cast from the Main Camera.")]
		public FsmFloat rayDistance = 100f;

		[UIHint(UIHint.Variable)]
		[Tooltip("Set Bool variable true if an object was picked, false if not.")]
		public FsmBool storeDidPickObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the picked GameObject.")]
		public FsmGameObject storeGameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the point of contact.")]
		public FsmVector3 storePoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the normal at the point of contact.")]
		public FsmVector3 storeNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the distance to the point of contact.")]
		public FsmFloat storeDistance;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			rayDistance = 100f;
			storeDidPickObject = null;
			storeGameObject = null;
			storePoint = null;
			storeNormal = null;
			storeDistance = null;
			layerMask = new FsmInt[0];
			invertMask = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoMousePick();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMousePick();
		}

		private void DoMousePick()
		{
			RaycastHit raycastHit = ActionHelpers.MousePick(rayDistance.Value, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			bool flag = raycastHit.collider != null;
			storeDidPickObject.Value = flag;
			if (flag)
			{
				storeGameObject.Value = raycastHit.collider.gameObject;
				storeDistance.Value = raycastHit.distance;
				storePoint.Value = raycastHit.point;
				storeNormal.Value = raycastHit.normal;
			}
			else
			{
				storeGameObject.Value = null;
				storeDistance.Value = float.PositiveInfinity;
				storePoint.Value = Vector3.zero;
				storeNormal.Value = Vector3.zero;
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[ActionTarget(typeof(GameObject), "GameObject", false)]
	[Tooltip("Sends Events based on mouse interactions with a Game Object: MouseOver, MouseDown, MouseUp, MouseOff. Use Ray Distance to set how close the camera must be to pick the object.\n\nNOTE: Picking uses the Main Camera.")]
	public class MousePickEvent : FsmStateAction
	{
		[CheckForComponent(typeof(Collider))]
		public FsmOwnerDefault GameObject;

		[Tooltip("Length of the ray to cast from the camera.")]
		public FsmFloat rayDistance = 100f;

		[Tooltip("Event to send when the mouse is over the GameObject.")]
		public FsmEvent mouseOver;

		[Tooltip("Event to send when the mouse is pressed while over the GameObject.")]
		public FsmEvent mouseDown;

		[Tooltip("Event to send when the mouse is released while over the GameObject.")]
		public FsmEvent mouseUp;

		[Tooltip("Event to send when the mouse moves off the GameObject.")]
		public FsmEvent mouseOff;

		[Tooltip("Pick only from these layers.")]
		[UIHint(UIHint.Layer)]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			GameObject = null;
			rayDistance = 100f;
			mouseOver = null;
			mouseDown = null;
			mouseUp = null;
			mouseOff = null;
			layerMask = new FsmInt[0];
			invertMask = false;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoMousePickEvent();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMousePickEvent();
		}

		private void DoMousePickEvent()
		{
			bool num = DoRaycast();
			base.Fsm.RaycastHitInfo = ActionHelpers.mousePickInfo;
			if (num)
			{
				if (mouseDown != null && Input.GetMouseButtonDown(0))
				{
					base.Fsm.Event(mouseDown);
				}
				if (mouseOver != null)
				{
					base.Fsm.Event(mouseOver);
				}
				if (mouseUp != null && Input.GetMouseButtonUp(0))
				{
					base.Fsm.Event(mouseUp);
				}
			}
			else if (mouseOff != null)
			{
				base.Fsm.Event(mouseOff);
			}
		}

		private bool DoRaycast()
		{
			return ActionHelpers.IsMouseOver((GameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : GameObject.GameObject.Value, rayDistance.Value, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
		}

		public override string ErrorCheck()
		{
			return string.Concat("" + ActionHelpers.CheckRayDistance(rayDistance.Value), ActionHelpers.CheckPhysicsSetup(base.Fsm.GetOwnerDefaultTarget(GameObject)));
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Resets all Input. After ResetInputAxes all axes return to 0 and all buttons return to 0 for one frame")]
	public class ResetInputAxes : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnEnter()
		{
			Input.ResetInputAxes();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Perform a raycast into the scene using screen coordinates and stores the results. Use Ray Distance to set how close the camera must be to pick the object. NOTE: Uses the MainCamera!")]
	public class ScreenPick : FsmStateAction
	{
		[Tooltip("A Vector3 screen position. Commonly stored by other actions.")]
		public FsmVector3 screenVector;

		[Tooltip("X position on screen.")]
		public FsmFloat screenX;

		[Tooltip("Y position on screen.")]
		public FsmFloat screenY;

		[Tooltip("Are the supplied screen coordinates normalized (0-1), or in pixels.")]
		public FsmBool normalized;

		[RequiredField]
		public FsmFloat rayDistance = 100f;

		[UIHint(UIHint.Variable)]
		public FsmBool storeDidPickObject;

		[UIHint(UIHint.Variable)]
		public FsmGameObject storeGameObject;

		[UIHint(UIHint.Variable)]
		public FsmVector3 storePoint;

		[UIHint(UIHint.Variable)]
		public FsmVector3 storeNormal;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeDistance;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		public bool everyFrame;

		public override void Reset()
		{
			screenVector = new FsmVector3
			{
				UseVariable = true
			};
			screenX = new FsmFloat
			{
				UseVariable = true
			};
			screenY = new FsmFloat
			{
				UseVariable = true
			};
			normalized = false;
			rayDistance = 100f;
			storeDidPickObject = null;
			storeGameObject = null;
			storePoint = null;
			storeNormal = null;
			storeDistance = null;
			layerMask = new FsmInt[0];
			invertMask = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoScreenPick();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoScreenPick();
		}

		private void DoScreenPick()
		{
			if (Camera.main == null)
			{
				LogError("No MainCamera defined!");
				Finish();
				return;
			}
			Vector3 pos = Vector3.zero;
			if (!screenVector.IsNone)
			{
				pos = screenVector.Value;
			}
			if (!screenX.IsNone)
			{
				pos.x = screenX.Value;
			}
			if (!screenY.IsNone)
			{
				pos.y = screenY.Value;
			}
			if (normalized.Value)
			{
				pos.x *= Screen.width;
				pos.y *= Screen.height;
			}
			Physics.Raycast(Camera.main.ScreenPointToRay(pos), out var hitInfo, rayDistance.Value, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			bool flag = hitInfo.collider != null;
			storeDidPickObject.Value = flag;
			if (flag)
			{
				storeGameObject.Value = hitInfo.collider.gameObject;
				storeDistance.Value = hitInfo.distance;
				storePoint.Value = hitInfo.point;
				storeNormal.Value = hitInfo.normal;
			}
			else
			{
				storeGameObject.Value = null;
				storeDistance = float.PositiveInfinity;
				storePoint.Value = Vector3.zero;
				storeNormal.Value = Vector3.zero;
			}
		}
	}
	[NoActionTargets]
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Transforms 2d input into a 3d world space vector. E.g., can be used to transform input from a touch joystick to a movement vector.")]
	public class TransformInputToWorldSpace : FsmStateAction
	{
		public enum AxisPlane
		{
			XZ,
			XY,
			YZ
		}

		[UIHint(UIHint.Variable)]
		[Tooltip("The horizontal input.")]
		public FsmFloat horizontalInput;

		[UIHint(UIHint.Variable)]
		[Tooltip("The vertical input.")]
		public FsmFloat verticalInput;

		[Tooltip("Input axis are reported in the range -1 to 1, this multiplier lets you set a new range.")]
		public FsmFloat multiplier;

		[RequiredField]
		[Tooltip("The world plane to map the 2d input onto.")]
		public AxisPlane mapToPlane;

		[Tooltip("Make the result relative to a GameObject, typically the main camera.")]
		public FsmGameObject relativeTo;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the direction vector.")]
		public FsmVector3 storeVector;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the length of the direction vector.")]
		public FsmFloat storeMagnitude;

		public override void Reset()
		{
			horizontalInput = null;
			verticalInput = null;
			multiplier = 1f;
			mapToPlane = AxisPlane.XZ;
			storeVector = null;
			storeMagnitude = null;
		}

		public override void OnUpdate()
		{
			Vector3 vector = default(Vector3);
			Vector3 vector2 = default(Vector3);
			if (relativeTo.Value == null)
			{
				switch (mapToPlane)
				{
				case AxisPlane.XZ:
					vector = Vector3.forward;
					vector2 = Vector3.right;
					break;
				case AxisPlane.XY:
					vector = Vector3.up;
					vector2 = Vector3.right;
					break;
				case AxisPlane.YZ:
					vector = Vector3.up;
					vector2 = Vector3.forward;
					break;
				}
			}
			else
			{
				Transform transform = relativeTo.Value.transform;
				switch (mapToPlane)
				{
				case AxisPlane.XZ:
					vector = transform.TransformDirection(Vector3.forward);
					vector.y = 0f;
					vector = vector.normalized;
					vector2 = new Vector3(vector.z, 0f, 0f - vector.x);
					break;
				case AxisPlane.XY:
				case AxisPlane.YZ:
					vector = Vector3.up;
					vector.z = 0f;
					vector = vector.normalized;
					vector2 = transform.TransformDirection(Vector3.right);
					break;
				}
			}
			float num = (horizontalInput.IsNone ? 0f : horizontalInput.Value);
			float num2 = (verticalInput.IsNone ? 0f : verticalInput.Value);
			Vector3 value = num * vector2 + num2 * vector;
			value *= multiplier.Value;
			storeVector.Value = value;
			if (!storeMagnitude.IsNone)
			{
				storeMagnitude.Value = value.magnitude;
			}
		}
	}
	[ActionCategory(ActionCategory.Level)]
	[Tooltip("Makes the Game Object not be destroyed automatically when loading a new scene.")]
	public class DontDestroyOnLoad : FsmStateAction
	{
		[RequiredField]
		[Tooltip("GameObject to mark as DontDestroyOnLoad.")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				UnityEngine.Object.DontDestroyOnLoad(ownerDefaultTarget.transform.root.gameObject);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Level)]
	[Tooltip("Loads a Level by Name. NOTE: Before you can load a level, you have to add it to the list of levels defined in File->Build Settings...")]
	public class LoadLevel : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The name of the level to load. NOTE: Must be in the list of levels defined in File->Build Settings... ")]
		public FsmString levelName;

		[Tooltip("Load the level additively, keeping the current scene.")]
		public bool additive;

		[Tooltip("Load the level asynchronously in the background.")]
		public bool async;

		[Tooltip("Event to send when the level has loaded. NOTE: This only makes sense if the FSM is still in the scene!")]
		public FsmEvent loadedEvent;

		[Tooltip("Keep this GameObject in the new level. NOTE: The GameObject and components is disabled then enabled on load; uncheck Reset On Disable to keep the active state.")]
		public FsmBool dontDestroyOnLoad;

		[Tooltip("Event to send if the level cannot be loaded.")]
		public FsmEvent failedEvent;

		private AsyncOperation asyncOperation;

		public override void Reset()
		{
			levelName = "";
			additive = false;
			async = false;
			loadedEvent = null;
			dontDestroyOnLoad = false;
		}

		public override void OnEnter()
		{
			if (!UnityEngine.Application.CanStreamedLevelBeLoaded(levelName.Value))
			{
				base.Fsm.Event(failedEvent);
				Finish();
				return;
			}
			if (dontDestroyOnLoad.Value)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.Owner.transform.root.gameObject);
			}
			if (additive)
			{
				if (async)
				{
					asyncOperation = SceneManager.LoadSceneAsync(levelName.Value, LoadSceneMode.Additive);
					UnityEngine.Debug.Log("LoadLevelAdditiveAsyc: " + levelName.Value);
					return;
				}
				SceneManager.LoadScene(levelName.Value, LoadSceneMode.Additive);
				UnityEngine.Debug.Log("LoadLevelAdditive: " + levelName.Value);
			}
			else
			{
				if (async)
				{
					asyncOperation = SceneManager.LoadSceneAsync(levelName.Value, LoadSceneMode.Single);
					UnityEngine.Debug.Log("LoadLevelAsync: " + levelName.Value);
					return;
				}
				SceneManager.LoadScene(levelName.Value, LoadSceneMode.Single);
				UnityEngine.Debug.Log("LoadLevel: " + levelName.Value);
			}
			Log("LOAD COMPLETE");
			base.Fsm.Event(loadedEvent);
			Finish();
		}

		public override void OnUpdate()
		{
			if (asyncOperation.isDone)
			{
				base.Fsm.Event(loadedEvent);
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Level)]
	[Tooltip("Loads a Level by Index number. Before you can load a level, you have to add it to the list of levels defined in File->Build Settings...")]
	public class LoadLevelNum : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The level index in File->Build Settings")]
		public FsmInt levelIndex;

		[Tooltip("Load the level additively, keeping the current scene.")]
		public bool additive;

		[Tooltip("Event to send after the level is loaded.")]
		public FsmEvent loadedEvent;

		[Tooltip("Keep this GameObject in the new level. NOTE: The GameObject and components is disabled then enabled on load; uncheck Reset On Disable to keep the active state.")]
		public FsmBool dontDestroyOnLoad;

		[Tooltip("Event to send if the level cannot be loaded.")]
		public FsmEvent failedEvent;

		public override void Reset()
		{
			levelIndex = null;
			additive = false;
			loadedEvent = null;
			dontDestroyOnLoad = false;
		}

		public override void OnEnter()
		{
			if (!UnityEngine.Application.CanStreamedLevelBeLoaded(levelIndex.Value))
			{
				base.Fsm.Event(failedEvent);
				Finish();
				return;
			}
			if (dontDestroyOnLoad.Value)
			{
				UnityEngine.Object.DontDestroyOnLoad(base.Owner.transform.root.gameObject);
			}
			if (additive)
			{
				SceneManager.LoadScene(levelIndex.Value, LoadSceneMode.Additive);
			}
			else
			{
				SceneManager.LoadScene(levelIndex.Value, LoadSceneMode.Single);
			}
			base.Fsm.Event(loadedEvent);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Level)]
	[Tooltip("Restarts current level.")]
	public class RestartLevel : FsmStateAction
	{
		public override void OnEnter()
		{
			SceneManager.LoadScene(SceneManager.GetActiveScene().name, LoadSceneMode.Single);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Sets the Color of a Light.")]
	public class SetLightColor : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmColor lightColor;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			lightColor = Color.white;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetLightColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetLightColor();
		}

		private void DoSetLightColor()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.color = lightColor.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Sets the Texture projected by a Light.")]
	public class SetLightCookie : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		public FsmTexture lightCookie;

		public override void Reset()
		{
			gameObject = null;
			lightCookie = null;
		}

		public override void OnEnter()
		{
			DoSetLightCookie();
			Finish();
		}

		private void DoSetLightCookie()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.cookie = lightCookie.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Sets the Flare effect used by a Light.")]
	public class SetLightFlare : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		public Flare lightFlare;

		public override void Reset()
		{
			gameObject = null;
			lightFlare = null;
		}

		public override void OnEnter()
		{
			DoSetLightRange();
			Finish();
		}

		private void DoSetLightRange()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.flare = lightFlare;
			}
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Sets the Intensity of a Light.")]
	public class SetLightIntensity : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		public FsmFloat lightIntensity;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			lightIntensity = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetLightIntensity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetLightIntensity();
		}

		private void DoSetLightIntensity()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.intensity = lightIntensity.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Sets the Range of a Light.")]
	public class SetLightRange : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		public FsmFloat lightRange;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			lightRange = 20f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetLightRange();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetLightRange();
		}

		private void DoSetLightRange()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.range = lightRange.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Sets the Spot Angle of a Light.")]
	public class SetLightSpotAngle : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		public FsmFloat lightSpotAngle;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			lightSpotAngle = 20f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetLightRange();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetLightRange();
		}

		private void DoSetLightRange()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.spotAngle = lightSpotAngle.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Set Spot, Directional, or Point Light type.")]
	public class SetLightType : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		[ObjectType(typeof(LightType))]
		public FsmEnum lightType;

		public override void Reset()
		{
			gameObject = null;
			lightType = LightType.Point;
		}

		public override void OnEnter()
		{
			DoSetLightType();
			Finish();
		}

		private void DoSetLightType()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.type = (LightType)(object)lightType.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Lights)]
	[Tooltip("Sets the strength of the shadows cast by a Light.")]
	public class SetShadowStrength : ComponentAction<Light>
	{
		[RequiredField]
		[CheckForComponent(typeof(Light))]
		public FsmOwnerDefault gameObject;

		public FsmFloat shadowStrength;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			shadowStrength = 0.8f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetShadowStrength();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetShadowStrength();
		}

		private void DoSetShadowStrength()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.light.shadowStrength = shadowStrength.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if all the given Bool Variables are True.")]
	public class BoolAllTrue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Readonly]
		[Tooltip("The Bool variables to check.")]
		public FsmBool[] boolVariables;

		[Tooltip("Event to send if all the Bool variables are True.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a Bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariables = null;
			sendEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoAllTrue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoAllTrue();
		}

		private void DoAllTrue()
		{
			if (boolVariables.Length == 0)
			{
				return;
			}
			bool flag = true;
			for (int i = 0; i < boolVariables.Length; i++)
			{
				if (!boolVariables[i].Value)
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = flag;
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if any of the given Bool Variables are True.")]
	public class BoolAnyTrue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variables to check.")]
		public FsmBool[] boolVariables;

		[Tooltip("Event to send if any of the Bool variables are True.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a Bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariables = null;
			sendEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoAnyTrue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoAnyTrue();
		}

		private void DoAnyTrue()
		{
			if (boolVariables.Length == 0)
			{
				return;
			}
			storeResult.Value = false;
			for (int i = 0; i < boolVariables.Length; i++)
			{
				if (boolVariables[i].Value)
				{
					base.Fsm.Event(sendEvent);
					storeResult.Value = true;
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if the value of a Bool Variable has changed. Use this to send an event on change, or store a bool that can be used in other operations.")]
	public class BoolChanged : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variable to watch for changes.")]
		public FsmBool boolVariable;

		[Tooltip("Event to send if the variable changes.")]
		public FsmEvent changedEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Set to True if changed.")]
		public FsmBool storeResult;

		private bool previousValue;

		public override void Reset()
		{
			boolVariable = null;
			changedEvent = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			if (boolVariable.IsNone)
			{
				Finish();
			}
			else
			{
				previousValue = boolVariable.Value;
			}
		}

		public override void OnUpdate()
		{
			storeResult.Value = false;
			if (boolVariable.Value != previousValue)
			{
				storeResult.Value = true;
				base.Fsm.Event(changedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if all the Bool Variables are False.\nSend an event or store the result.")]
	public class BoolNoneTrue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Bool variables to check.")]
		public FsmBool[] boolVariables;

		[Tooltip("Event to send if none of the Bool variables are True.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a Bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariables = null;
			sendEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoNoneTrue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoNoneTrue();
		}

		private void DoNoneTrue()
		{
			if (boolVariables.Length == 0)
			{
				return;
			}
			bool flag = true;
			for (int i = 0; i < boolVariables.Length; i++)
			{
				if (boolVariables[i].Value)
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				base.Fsm.Event(sendEvent);
			}
			storeResult.Value = flag;
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Performs boolean operations on 2 Bool Variables.")]
	public class BoolOperator : FsmStateAction
	{
		public enum Operation
		{
			AND,
			NAND,
			OR,
			XOR
		}

		[RequiredField]
		[Tooltip("The first Bool variable.")]
		public FsmBool bool1;

		[RequiredField]
		[Tooltip("The second Bool variable.")]
		public FsmBool bool2;

		[Tooltip("Boolean Operation.")]
		public Operation operation;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a Bool Variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			bool1 = false;
			bool2 = false;
			operation = Operation.AND;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoBoolOperator();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoBoolOperator();
		}

		private void DoBoolOperator()
		{
			bool value = bool1.Value;
			bool value2 = bool2.Value;
			switch (operation)
			{
			case Operation.AND:
				storeResult.Value = value && value2;
				break;
			case Operation.NAND:
				storeResult.Value = !(value && value2);
				break;
			case Operation.OR:
				storeResult.Value = value || value2;
				break;
			case Operation.XOR:
				storeResult.Value = value ^ value2;
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on the value of a Boolean Variable.")]
	public class BoolTest : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Readonly]
		[Tooltip("The Bool variable to test.")]
		public FsmBool boolVariable;

		[Tooltip("Event to send if the Bool variable is True.")]
		public FsmEvent isTrue;

		[Tooltip("Event to send if the Bool variable is False.")]
		public FsmEvent isFalse;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			boolVariable = null;
			isTrue = null;
			isFalse = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.Fsm.Event(boolVariable.Value ? isTrue : isFalse);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			base.Fsm.Event(boolVariable.Value ? isTrue : isFalse);
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on the comparison of 2 Colors.")]
	public class ColorCompare : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The first Color.")]
		public FsmColor color1;

		[RequiredField]
		[Tooltip("The second Color.")]
		public FsmColor color2;

		[RequiredField]
		[Tooltip("Tolerance of test, to test for 'almost equals' or to ignore small floating point rounding differences.")]
		public FsmFloat tolerance;

		[Tooltip("Event sent if Color 1 equals Color 2 (within Tolerance)")]
		public FsmEvent equal;

		[Tooltip("Event sent if Color 1 does not equal Color 2 (within Tolerance)")]
		public FsmEvent notEqual;

		[Tooltip("Repeat every frame. Useful if the variables are changing and you're waiting for a particular result.")]
		public bool everyFrame;

		public override void Reset()
		{
			color1 = Color.white;
			color2 = Color.white;
			tolerance = 0f;
			equal = null;
			notEqual = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCompare();
		}

		private void DoCompare()
		{
			if (Mathf.Abs(color1.Value.r - color2.Value.r) > tolerance.Value || Mathf.Abs(color1.Value.g - color2.Value.g) > tolerance.Value || Mathf.Abs(color1.Value.b - color2.Value.b) > tolerance.Value || Mathf.Abs(color1.Value.a - color2.Value.a) > tolerance.Value)
			{
				base.Fsm.Event(notEqual);
			}
			else
			{
				base.Fsm.Event(equal);
			}
		}

		public override string ErrorCheck()
		{
			if (FsmEvent.IsNullOrEmpty(equal) && FsmEvent.IsNullOrEmpty(notEqual))
			{
				return "Action sends no events!";
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Compares 2 Enum values and sends Events based on the result.")]
	public class EnumCompare : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmEnum enumVariable;

		[MatchFieldType("enumVariable")]
		public FsmEnum compareTo;

		public FsmEvent equalEvent;

		public FsmEvent notEqualEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the true/false result in a bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame. Useful if the enum is changing over time.")]
		public bool everyFrame;

		public override void Reset()
		{
			enumVariable = null;
			compareTo = null;
			equalEvent = null;
			notEqualEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoEnumCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoEnumCompare();
		}

		private void DoEnumCompare()
		{
			if (enumVariable != null && compareTo != null)
			{
				bool flag = object.Equals(enumVariable.Value, compareTo.Value);
				if (storeResult != null)
				{
					storeResult.Value = flag;
				}
				if (flag && equalEvent != null)
				{
					base.Fsm.Event(equalEvent);
				}
				else if (!flag && notEqualEvent != null)
				{
					base.Fsm.Event(notEqualEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends an Event based on the value of an Enum Variable.")]
	public class EnumSwitch : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmEnum enumVariable;

		[CompoundArray("Enum Switches", "Compare Enum Values", "Send")]
		[MatchFieldType("enumVariable")]
		public FsmEnum[] compareTo;

		public FsmEvent[] sendEvent;

		public bool everyFrame;

		public override void Reset()
		{
			enumVariable = null;
			compareTo = new FsmEnum[0];
			sendEvent = new FsmEvent[0];
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoEnumSwitch();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoEnumSwitch();
		}

		private void DoEnumSwitch()
		{
			if (enumVariable.IsNone)
			{
				return;
			}
			for (int i = 0; i < compareTo.Length; i++)
			{
				if (object.Equals(enumVariable.Value, compareTo[i].Value))
				{
					base.Fsm.Event(sendEvent[i]);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if the value of a Float variable changed. Use this to send an event on change, or store a bool that can be used in other operations.")]
	public class FloatChanged : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Float variable to watch for a change.")]
		public FsmFloat floatVariable;

		[Tooltip("Event to send if the float variable changes.")]
		public FsmEvent changedEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Set to True if the float variable changes.")]
		public FsmBool storeResult;

		private float previousValue;

		public override void Reset()
		{
			floatVariable = null;
			changedEvent = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			if (floatVariable.IsNone)
			{
				Finish();
			}
			else
			{
				previousValue = floatVariable.Value;
			}
		}

		public override void OnUpdate()
		{
			storeResult.Value = false;
			if (floatVariable.Value != previousValue)
			{
				previousValue = floatVariable.Value;
				storeResult.Value = true;
				base.Fsm.Event(changedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on the comparison of 2 Floats.")]
	public class FloatCompare : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The first float variable.")]
		public FsmFloat float1;

		[RequiredField]
		[Tooltip("The second float variable.")]
		public FsmFloat float2;

		[RequiredField]
		[Tooltip("Tolerance for the Equal test (almost equal).\nNOTE: Floats that look the same are often not exactly the same, so you often need to use a small tolerance.")]
		public FsmFloat tolerance;

		[Tooltip("Event sent if Float 1 equals Float 2 (within Tolerance)")]
		public FsmEvent equal;

		[Tooltip("Event sent if Float 1 is less than Float 2")]
		public FsmEvent lessThan;

		[Tooltip("Event sent if Float 1 is greater than Float 2")]
		public FsmEvent greaterThan;

		[Tooltip("Repeat every frame. Useful if the variables are changing and you're waiting for a particular result.")]
		public bool everyFrame;

		public override void Reset()
		{
			float1 = 0f;
			float2 = 0f;
			tolerance = 0f;
			equal = null;
			lessThan = null;
			greaterThan = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCompare();
		}

		private void DoCompare()
		{
			if (Mathf.Abs(float1.Value - float2.Value) <= tolerance.Value)
			{
				base.Fsm.Event(equal);
			}
			else if (float1.Value < float2.Value)
			{
				base.Fsm.Event(lessThan);
			}
			else if (float1.Value > float2.Value)
			{
				base.Fsm.Event(greaterThan);
			}
		}

		public override string ErrorCheck()
		{
			if (FsmEvent.IsNullOrEmpty(equal) && FsmEvent.IsNullOrEmpty(lessThan) && FsmEvent.IsNullOrEmpty(greaterThan))
			{
				return "Action sends no events!";
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on the sign of a Float.")]
	public class FloatSignTest : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variable to test.")]
		public FsmFloat floatValue;

		[Tooltip("Event to send if the float variable is positive.")]
		public FsmEvent isPositive;

		[Tooltip("Event to send if the float variable is negative.")]
		public FsmEvent isNegative;

		[Tooltip("Repeat every frame. Useful if the variable is changing and you're waiting for a particular result.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatValue = 0f;
			isPositive = null;
			isNegative = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSignTest();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSignTest();
		}

		private void DoSignTest()
		{
			if (floatValue != null)
			{
				base.Fsm.Event((floatValue.Value < 0f) ? isNegative : isPositive);
			}
		}

		public override string ErrorCheck()
		{
			if (FsmEvent.IsNullOrEmpty(isPositive) && FsmEvent.IsNullOrEmpty(isNegative))
			{
				return "Action sends no events!";
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends an Event based on the value of a Float Variable. The float could represent distance, angle to a target, health left... The array sets up float ranges that correspond to Events.")]
	public class FloatSwitch : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variable to test.")]
		public FsmFloat floatVariable;

		[CompoundArray("Float Switches", "Less Than", "Send Event")]
		public FsmFloat[] lessThan;

		public FsmEvent[] sendEvent;

		[Tooltip("Repeat every frame. Useful if the variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			lessThan = new FsmFloat[1];
			sendEvent = new FsmEvent[1];
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoFloatSwitch();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFloatSwitch();
		}

		private void DoFloatSwitch()
		{
			if (floatVariable.IsNone)
			{
				return;
			}
			for (int i = 0; i < lessThan.Length; i++)
			{
				if (floatVariable.Value < lessThan[i].Value)
				{
					base.Fsm.Event(sendEvent[i]);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Sends Events based on the current State of an FSM.")]
	public class FsmStateSwitch : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmGameObject gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of Fsm on GameObject. Useful if there is more than one FSM on the GameObject.")]
		public FsmString fsmName;

		[CompoundArray("State Switches", "Compare State", "Send Event")]
		public FsmString[] compareTo;

		public FsmEvent[] sendEvent;

		[Tooltip("Repeat every frame. Useful if you're waiting for a particular result.")]
		public bool everyFrame;

		private GameObject previousGo;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = null;
			compareTo = new FsmString[1];
			sendEvent = new FsmEvent[1];
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoFsmStateSwitch();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFsmStateSwitch();
		}

		private void DoFsmStateSwitch()
		{
			GameObject value = gameObject.Value;
			if (value == null)
			{
				return;
			}
			if (value != previousGo)
			{
				fsm = ActionHelpers.GetGameObjectFsm(value, fsmName.Value);
				previousGo = value;
			}
			if (fsm == null)
			{
				return;
			}
			string activeStateName = fsm.ActiveStateName;
			for (int i = 0; i < compareTo.Length; i++)
			{
				if (activeStateName == compareTo[i].Value)
				{
					base.Fsm.Event(sendEvent[i]);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Tests if an FSM is in the specified State.")]
	public class FsmStateTest : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmGameObject gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of Fsm on Game Object. Useful if there is more than one FSM on the GameObject.")]
		public FsmString fsmName;

		[RequiredField]
		[Tooltip("Check to see if the FSM is in this state.")]
		public FsmString stateName;

		[Tooltip("Event to send if the FSM is in the specified state.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if the FSM is NOT in the specified state.")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result of this test in a bool variable. Useful if other actions depend on this test.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame. Useful if you're waiting for a particular state.")]
		public bool everyFrame;

		private GameObject previousGo;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = null;
			stateName = null;
			trueEvent = null;
			falseEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoFsmStateTest();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFsmStateTest();
		}

		private void DoFsmStateTest()
		{
			GameObject value = gameObject.Value;
			if (value == null)
			{
				return;
			}
			if (value != previousGo)
			{
				fsm = ActionHelpers.GetGameObjectFsm(value, fsmName.Value);
				previousGo = value;
			}
			if (!(fsm == null))
			{
				bool value2 = false;
				if (fsm.ActiveStateName == stateName.Value)
				{
					base.Fsm.Event(trueEvent);
					value2 = true;
				}
				else
				{
					base.Fsm.Event(falseEvent);
				}
				storeResult.Value = value2;
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if the value of a GameObject variable changed. Use this to send an event on change, or store a bool that can be used in other operations.")]
	public class GameObjectChanged : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The GameObject variable to watch for a change.")]
		public FsmGameObject gameObjectVariable;

		[Tooltip("Event to send if the variable changes.")]
		public FsmEvent changedEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Set to True if the variable changes.")]
		public FsmBool storeResult;

		private GameObject previousValue;

		public override void Reset()
		{
			gameObjectVariable = null;
			changedEvent = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			if (gameObjectVariable.IsNone)
			{
				Finish();
			}
			else
			{
				previousValue = gameObjectVariable.Value;
			}
		}

		public override void OnUpdate()
		{
			storeResult.Value = false;
			if (gameObjectVariable.Value != previousValue)
			{
				storeResult.Value = true;
				base.Fsm.Event(changedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Compares 2 Game Objects and sends Events based on the result.")]
	public class GameObjectCompare : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Title("Game Object")]
		[Tooltip("A Game Object variable to compare.")]
		public FsmOwnerDefault gameObjectVariable;

		[RequiredField]
		[Tooltip("Compare the variable with this Game Object")]
		public FsmGameObject compareTo;

		[Tooltip("Send this event if Game Objects are equal")]
		public FsmEvent equalEvent;

		[Tooltip("Send this event if Game Objects are not equal")]
		public FsmEvent notEqualEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result of the check in a Bool Variable. (True if equal, false if not equal).")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame. Useful if you're waiting for a true or false result.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObjectVariable = null;
			compareTo = null;
			equalEvent = null;
			notEqualEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGameObjectCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGameObjectCompare();
		}

		private void DoGameObjectCompare()
		{
			bool flag = base.Fsm.GetOwnerDefaultTarget(gameObjectVariable) == compareTo.Value;
			storeResult.Value = flag;
			if (flag && equalEvent != null)
			{
				base.Fsm.Event(equalEvent);
			}
			else if (!flag && notEqualEvent != null)
			{
				base.Fsm.Event(notEqualEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if a Game Object has a tag.")]
	public class GameObjectCompareTag : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to test.")]
		public FsmGameObject gameObject;

		[RequiredField]
		[UIHint(UIHint.Tag)]
		[Tooltip("The Tag to check for.")]
		public FsmString tag;

		[Tooltip("Event to send if the GameObject has the Tag.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if the GameObject does not have the Tag.")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a Bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			tag = "Untagged";
			trueEvent = null;
			falseEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoCompareTag();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCompareTag();
		}

		private void DoCompareTag()
		{
			bool flag = false;
			if (gameObject.Value != null)
			{
				flag = gameObject.Value.CompareTag(tag.Value);
			}
			storeResult.Value = flag;
			base.Fsm.Event(flag ? trueEvent : falseEvent);
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if a GameObject has children.")]
	public class GameObjectHasChildren : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to test.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Event to send if the GameObject has children.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if the GameObject does not have children.")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoHasChildren();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoHasChildren();
		}

		private void DoHasChildren()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				bool flag = ownerDefaultTarget.transform.childCount > 0;
				storeResult.Value = flag;
				base.Fsm.Event(flag ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if a GameObject is a Child of another GameObject.")]
	public class GameObjectIsChildOf : FsmStateAction
	{
		[RequiredField]
		[Tooltip("GameObject to test.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Is it a child of this GameObject?")]
		public FsmGameObject isChildOf;

		[Tooltip("Event to send if GameObject is a child.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if GameObject is NOT a child.")]
		public FsmEvent falseEvent;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store result in a bool variable")]
		public FsmBool storeResult;

		public override void Reset()
		{
			gameObject = null;
			isChildOf = null;
			trueEvent = null;
			falseEvent = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			DoIsChildOf(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private void DoIsChildOf(GameObject go)
		{
			if (!(go == null) && isChildOf != null)
			{
				bool flag = go.transform.IsChildOf(isChildOf.Value.transform);
				storeResult.Value = flag;
				base.Fsm.Event(flag ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if a GameObject Variable has a null value. E.g., If the FindGameObject action failed to find an object.")]
	public class GameObjectIsNull : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The GameObject variable to test.")]
		public FsmGameObject gameObject;

		[Tooltip("Event to send if the GamObject is null.")]
		public FsmEvent isNull;

		[Tooltip("Event to send if the GamObject is NOT null.")]
		public FsmEvent isNotNull;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			isNull = null;
			isNotNull = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIsGameObjectNull();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIsGameObjectNull();
		}

		private void DoIsGameObjectNull()
		{
			bool flag = gameObject.Value == null;
			if (storeResult != null)
			{
				storeResult.Value = flag;
			}
			base.Fsm.Event(flag ? isNull : isNotNull);
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[ActionTarget(typeof(GameObject), "gameObject", false)]
	[Tooltip("Tests if a Game Object is visible.")]
	public class GameObjectIsVisible : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		[Tooltip("The GameObject to test.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Event to send if the GameObject is visible.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if the GameObject is NOT visible.")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a bool variable.")]
		public FsmBool storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIsVisible();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIsVisible();
		}

		private void DoIsVisible()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				bool isVisible = base.renderer.isVisible;
				storeResult.Value = isVisible;
				base.Fsm.Event(isVisible ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends an Event based on a Game Object's Tag.")]
	public class GameObjectTagSwitch : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The GameObject to test.")]
		public FsmGameObject gameObject;

		[CompoundArray("Tag Switches", "Compare Tag", "Send Event")]
		[UIHint(UIHint.Tag)]
		public FsmString[] compareTo;

		public FsmEvent[] sendEvent;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			compareTo = new FsmString[1];
			sendEvent = new FsmEvent[1];
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoTagSwitch();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoTagSwitch();
		}

		private void DoTagSwitch()
		{
			GameObject value = gameObject.Value;
			if (value == null)
			{
				return;
			}
			for (int i = 0; i < compareTo.Length; i++)
			{
				if (value.tag == compareTo[i].Value)
				{
					base.Fsm.Event(sendEvent[i]);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if the value of an integer variable changed. Use this to send an event on change, or store a bool that can be used in other operations.")]
	public class IntChanged : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt intVariable;

		public FsmEvent changedEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		private int previousValue;

		public override void Reset()
		{
			intVariable = null;
			changedEvent = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			if (intVariable.IsNone)
			{
				Finish();
			}
			else
			{
				previousValue = intVariable.Value;
			}
		}

		public override void OnUpdate()
		{
			storeResult.Value = false;
			if (intVariable.Value != previousValue)
			{
				previousValue = intVariable.Value;
				storeResult.Value = true;
				base.Fsm.Event(changedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends Events based on the comparison of 2 Integers.")]
	public class IntCompare : FsmStateAction
	{
		[RequiredField]
		public FsmInt integer1;

		[RequiredField]
		public FsmInt integer2;

		[Tooltip("Event sent if Int 1 equals Int 2")]
		public FsmEvent equal;

		[Tooltip("Event sent if Int 1 is less than Int 2")]
		public FsmEvent lessThan;

		[Tooltip("Event sent if Int 1 is greater than Int 2")]
		public FsmEvent greaterThan;

		public bool everyFrame;

		public override void Reset()
		{
			integer1 = 0;
			integer2 = 0;
			equal = null;
			lessThan = null;
			greaterThan = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIntCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIntCompare();
		}

		private void DoIntCompare()
		{
			if (integer1.Value == integer2.Value)
			{
				base.Fsm.Event(equal);
			}
			else if (integer1.Value < integer2.Value)
			{
				base.Fsm.Event(lessThan);
			}
			else if (integer1.Value > integer2.Value)
			{
				base.Fsm.Event(greaterThan);
			}
		}

		public override string ErrorCheck()
		{
			if (FsmEvent.IsNullOrEmpty(equal) && FsmEvent.IsNullOrEmpty(lessThan) && FsmEvent.IsNullOrEmpty(greaterThan))
			{
				return "Action sends no events!";
			}
			return "";
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends an Event based on the value of an Integer Variable.")]
	public class IntSwitch : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt intVariable;

		[CompoundArray("Int Switches", "Compare Int", "Send Event")]
		public FsmInt[] compareTo;

		public FsmEvent[] sendEvent;

		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			compareTo = new FsmInt[1];
			sendEvent = new FsmEvent[1];
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIntSwitch();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIntSwitch();
		}

		private void DoIntSwitch()
		{
			if (intVariable.IsNone)
			{
				return;
			}
			for (int i = 0; i < compareTo.Length; i++)
			{
				if (intVariable.Value == compareTo[i].Value)
				{
					base.Fsm.Event(sendEvent[i]);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Compare 2 Object Variables and send events based on the result.")]
	public class ObjectCompare : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Readonly]
		public FsmObject objectVariable;

		[RequiredField]
		public FsmObject compareTo;

		[Tooltip("Event to send if the 2 object values are equal.")]
		public FsmEvent equalEvent;

		[Tooltip("Event to send if the 2 object values are not equal.")]
		public FsmEvent notEqualEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			objectVariable = null;
			compareTo = null;
			storeResult = null;
			equalEvent = null;
			notEqualEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoObjectCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoObjectCompare();
		}

		private void DoObjectCompare()
		{
			bool flag = objectVariable.Value == compareTo.Value;
			storeResult.Value = flag;
			base.Fsm.Event(flag ? equalEvent : notEqualEvent);
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if the value of a string variable has changed. Use this to send an event on change, or store a bool that can be used in other operations.")]
	public class StringChanged : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		public FsmEvent changedEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		private string previousValue;

		public override void Reset()
		{
			stringVariable = null;
			changedEvent = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			if (stringVariable.IsNone)
			{
				Finish();
			}
			else
			{
				previousValue = stringVariable.Value;
			}
		}

		public override void OnUpdate()
		{
			if (stringVariable.Value != previousValue)
			{
				storeResult.Value = true;
				base.Fsm.Event(changedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Compares 2 Strings and sends Events based on the result.")]
	public class StringCompare : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		public FsmString compareTo;

		public FsmEvent equalEvent;

		public FsmEvent notEqualEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the true/false result in a bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame. Useful if any of the strings are changing over time.")]
		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			compareTo = "";
			equalEvent = null;
			notEqualEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoStringCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoStringCompare();
		}

		private void DoStringCompare()
		{
			if (stringVariable != null && compareTo != null)
			{
				bool flag = stringVariable.Value == compareTo.Value;
				if (storeResult != null)
				{
					storeResult.Value = flag;
				}
				if (flag && equalEvent != null)
				{
					base.Fsm.Event(equalEvent);
				}
				else if (!flag && notEqualEvent != null)
				{
					base.Fsm.Event(notEqualEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Tests if a String contains another String.")]
	public class StringContains : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The String variable to test.")]
		public FsmString stringVariable;

		[RequiredField]
		[Tooltip("Test if the String variable contains this string.")]
		public FsmString containsString;

		[Tooltip("Event to send if true.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if false.")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the true/false result in a bool variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame. Useful if any of the strings are changing over time.")]
		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			containsString = "";
			trueEvent = null;
			falseEvent = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoStringContains();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoStringContains();
		}

		private void DoStringContains()
		{
			if (!stringVariable.IsNone && !containsString.IsNone)
			{
				bool flag = stringVariable.Value.Contains(containsString.Value);
				if (storeResult != null)
				{
					storeResult.Value = flag;
				}
				if (flag && trueEvent != null)
				{
					base.Fsm.Event(trueEvent);
				}
				else if (!flag && falseEvent != null)
				{
					base.Fsm.Event(falseEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Logic)]
	[Tooltip("Sends an Event based on the value of a String Variable.")]
	public class StringSwitch : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		[CompoundArray("String Switches", "Compare String", "Send Event")]
		public FsmString[] compareTo;

		public FsmEvent[] sendEvent;

		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			compareTo = new FsmString[1];
			sendEvent = new FsmEvent[1];
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoStringSwitch();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoStringSwitch();
		}

		private void DoStringSwitch()
		{
			if (stringVariable.IsNone)
			{
				return;
			}
			for (int i = 0; i < compareTo.Length; i++)
			{
				if (stringVariable.Value == compareTo[i].Value)
				{
					base.Fsm.Event(sendEvent[i]);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Get a material at index on a gameObject and store it in a variable")]
	public class GetMaterial : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		[Tooltip("The GameObject the Material is applied to.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The index of the Material in the Materials array.")]
		public FsmInt materialIndex;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the material in a variable.")]
		public FsmMaterial material;

		[Tooltip("Get the shared material of this object. NOTE: Modifying the shared material will change the appearance of all objects using this material, and change material settings that are stored in the project too.")]
		public bool getSharedMaterial;

		public override void Reset()
		{
			gameObject = null;
			material = null;
			materialIndex = 0;
			getSharedMaterial = false;
		}

		public override void OnEnter()
		{
			DoGetMaterial();
			Finish();
		}

		private void DoGetMaterial()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (materialIndex.Value == 0 && !getSharedMaterial)
				{
					material.Value = base.renderer.material;
				}
				else if (materialIndex.Value == 0 && getSharedMaterial)
				{
					material.Value = base.renderer.sharedMaterial;
				}
				else if (base.renderer.materials.Length > materialIndex.Value && !getSharedMaterial)
				{
					Material[] materials = base.renderer.materials;
					material.Value = materials[materialIndex.Value];
					base.renderer.materials = materials;
				}
				else if (base.renderer.materials.Length > materialIndex.Value && getSharedMaterial)
				{
					Material[] sharedMaterials = base.renderer.sharedMaterials;
					material.Value = sharedMaterials[materialIndex.Value];
					base.renderer.sharedMaterials = sharedMaterials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Get a texture from a material on a GameObject")]
	public class GetMaterialTexture : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		[Tooltip("The GameObject the Material is applied to.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The index of the Material in the Materials array.")]
		public FsmInt materialIndex;

		[UIHint(UIHint.NamedTexture)]
		[Tooltip("The texture to get. See Unity Shader docs for names.")]
		public FsmString namedTexture;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Title("StoreTexture")]
		[Tooltip("Store the texture in a variable.")]
		public FsmTexture storedTexture;

		[Tooltip("Get the shared version of the texture.")]
		public bool getFromSharedMaterial;

		public override void Reset()
		{
			gameObject = null;
			materialIndex = 0;
			namedTexture = "_MainTex";
			storedTexture = null;
			getFromSharedMaterial = false;
		}

		public override void OnEnter()
		{
			DoGetMaterialTexture();
			Finish();
		}

		private void DoGetMaterialTexture()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				string text = namedTexture.Value;
				if (text == "")
				{
					text = "_MainTex";
				}
				if (materialIndex.Value == 0 && !getFromSharedMaterial)
				{
					storedTexture.Value = base.renderer.material.GetTexture(text);
				}
				else if (materialIndex.Value == 0 && getFromSharedMaterial)
				{
					storedTexture.Value = base.renderer.sharedMaterial.GetTexture(text);
				}
				else if (base.renderer.materials.Length > materialIndex.Value && !getFromSharedMaterial)
				{
					Material[] materials = base.renderer.materials;
					storedTexture.Value = base.renderer.materials[materialIndex.Value].GetTexture(text);
					base.renderer.materials = materials;
				}
				else if (base.renderer.materials.Length > materialIndex.Value && getFromSharedMaterial)
				{
					Material[] sharedMaterials = base.renderer.sharedMaterials;
					storedTexture.Value = base.renderer.sharedMaterials[materialIndex.Value].GetTexture(text);
					base.renderer.materials = sharedMaterials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets the material on a game object.")]
	public class SetMaterial : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		public FsmInt materialIndex;

		[RequiredField]
		public FsmMaterial material;

		public override void Reset()
		{
			gameObject = null;
			material = null;
			materialIndex = 0;
		}

		public override void OnEnter()
		{
			DoSetMaterial();
			Finish();
		}

		private void DoSetMaterial()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (materialIndex.Value == 0)
				{
					base.renderer.material = material.Value;
				}
				else if (base.renderer.materials.Length > materialIndex.Value)
				{
					Material[] materials = base.renderer.materials;
					materials[materialIndex.Value] = material.Value;
					base.renderer.materials = materials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets a named color value in a game object's material.")]
	public class SetMaterialColor : ComponentAction<Renderer>
	{
		[Tooltip("The GameObject that the material is applied to.")]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		[Tooltip("GameObjects can have multiple materials. Specify an index to target a specific material.")]
		public FsmInt materialIndex;

		[Tooltip("Alternatively specify a Material instead of a GameObject and Index.")]
		public FsmMaterial material;

		[UIHint(UIHint.NamedColor)]
		[Tooltip("A named color parameter in the shader.")]
		public FsmString namedColor;

		[RequiredField]
		[Tooltip("Set the parameter value.")]
		public FsmColor color;

		[Tooltip("Repeat every frame. Useful if the value is animated.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			materialIndex = 0;
			material = null;
			namedColor = "_Color";
			color = Color.black;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetMaterialColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetMaterialColor();
		}

		private void DoSetMaterialColor()
		{
			if (color.IsNone)
			{
				return;
			}
			string text = namedColor.Value;
			if (text == "")
			{
				text = "_Color";
			}
			if (material.Value != null)
			{
				material.Value.SetColor(text, color.Value);
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (base.renderer.material == null)
				{
					LogError("Missing Material!");
				}
				else if (materialIndex.Value == 0)
				{
					base.renderer.material.SetColor(text, color.Value);
				}
				else if (base.renderer.materials.Length > materialIndex.Value)
				{
					Material[] materials = base.renderer.materials;
					materials[materialIndex.Value].SetColor(text, color.Value);
					base.renderer.materials = materials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets a named float in a game object's material.")]
	public class SetMaterialFloat : ComponentAction<Renderer>
	{
		[Tooltip("The GameObject that the material is applied to.")]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		[Tooltip("GameObjects can have multiple materials. Specify an index to target a specific material.")]
		public FsmInt materialIndex;

		[Tooltip("Alternatively specify a Material instead of a GameObject and Index.")]
		public FsmMaterial material;

		[RequiredField]
		[Tooltip("A named float parameter in the shader.")]
		public FsmString namedFloat;

		[RequiredField]
		[Tooltip("Set the parameter value.")]
		public FsmFloat floatValue;

		[Tooltip("Repeat every frame. Useful if the value is animated.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			materialIndex = 0;
			material = null;
			namedFloat = "";
			floatValue = 0f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetMaterialFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetMaterialFloat();
		}

		private void DoSetMaterialFloat()
		{
			if (material.Value != null)
			{
				material.Value.SetFloat(namedFloat.Value, floatValue.Value);
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (base.renderer.material == null)
				{
					LogError("Missing Material!");
				}
				else if (materialIndex.Value == 0)
				{
					base.renderer.material.SetFloat(namedFloat.Value, floatValue.Value);
				}
				else if (base.renderer.materials.Length > materialIndex.Value)
				{
					Material[] materials = base.renderer.materials;
					materials[materialIndex.Value].SetFloat(namedFloat.Value, floatValue.Value);
					base.renderer.materials = materials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets a named texture in a game object's material.")]
	public class SetMaterialTexture : ComponentAction<Renderer>
	{
		[Tooltip("The GameObject that the material is applied to.")]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		[Tooltip("GameObjects can have multiple materials. Specify an index to target a specific material.")]
		public FsmInt materialIndex;

		[Tooltip("Alternatively specify a Material instead of a GameObject and Index.")]
		public FsmMaterial material;

		[UIHint(UIHint.NamedTexture)]
		[Tooltip("A named parameter in the shader.")]
		public FsmString namedTexture;

		public FsmTexture texture;

		public override void Reset()
		{
			gameObject = null;
			materialIndex = 0;
			material = null;
			namedTexture = "_MainTex";
			texture = null;
		}

		public override void OnEnter()
		{
			DoSetMaterialTexture();
			Finish();
		}

		private void DoSetMaterialTexture()
		{
			string text = namedTexture.Value;
			if (text == "")
			{
				text = "_MainTex";
			}
			if (material.Value != null)
			{
				material.Value.SetTexture(text, texture.Value);
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (base.renderer.material == null)
				{
					LogError("Missing Material!");
				}
				else if (materialIndex.Value == 0)
				{
					base.renderer.material.SetTexture(text, texture.Value);
				}
				else if (base.renderer.materials.Length > materialIndex.Value)
				{
					Material[] materials = base.renderer.materials;
					materials[materialIndex.Value].SetTexture(text, texture.Value);
					base.renderer.materials = materials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets a Game Object's material randomly from an array of Materials.")]
	public class SetRandomMaterial : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		public FsmInt materialIndex;

		public FsmMaterial[] materials;

		public override void Reset()
		{
			gameObject = null;
			materialIndex = 0;
			materials = new FsmMaterial[3];
		}

		public override void OnEnter()
		{
			DoSetRandomMaterial();
			Finish();
		}

		private void DoSetRandomMaterial()
		{
			if (materials == null || materials.Length == 0)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (base.renderer.material == null)
				{
					LogError("Missing Material!");
				}
				else if (materialIndex.Value == 0)
				{
					base.renderer.material = materials[UnityEngine.Random.Range(0, materials.Length)].Value;
				}
				else if (base.renderer.materials.Length > materialIndex.Value)
				{
					Material[] array = base.renderer.materials;
					array[materialIndex.Value] = materials[UnityEngine.Random.Range(0, materials.Length)].Value;
					base.renderer.materials = array;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets the Offset of a named texture in a Game Object's Material. Useful for scrolling texture effects.")]
	public class SetTextureOffset : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		public FsmInt materialIndex;

		[RequiredField]
		[UIHint(UIHint.NamedColor)]
		public FsmString namedTexture;

		[RequiredField]
		public FsmFloat offsetX;

		[RequiredField]
		public FsmFloat offsetY;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			materialIndex = 0;
			namedTexture = "_MainTex";
			offsetX = 0f;
			offsetY = 0f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetTextureOffset();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetTextureOffset();
		}

		private void DoSetTextureOffset()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (base.renderer.material == null)
				{
					LogError("Missing Material!");
				}
				else if (materialIndex.Value == 0)
				{
					base.renderer.material.SetTextureOffset(namedTexture.Value, new Vector2(offsetX.Value, offsetY.Value));
				}
				else if (base.renderer.materials.Length > materialIndex.Value)
				{
					Material[] materials = base.renderer.materials;
					materials[materialIndex.Value].SetTextureOffset(namedTexture.Value, new Vector2(offsetX.Value, offsetY.Value));
					base.renderer.materials = materials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets the Scale of a named texture in a Game Object's Material. Useful for special effects.")]
	public class SetTextureScale : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		public FsmInt materialIndex;

		[UIHint(UIHint.NamedColor)]
		public FsmString namedTexture;

		[RequiredField]
		public FsmFloat scaleX;

		[RequiredField]
		public FsmFloat scaleY;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			materialIndex = 0;
			namedTexture = "_MainTex";
			scaleX = 1f;
			scaleY = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetTextureScale();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetTextureScale();
		}

		private void DoSetTextureScale()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (base.renderer.material == null)
				{
					LogError("Missing Material!");
				}
				else if (materialIndex.Value == 0)
				{
					base.renderer.material.SetTextureScale(namedTexture.Value, new Vector2(scaleX.Value, scaleY.Value));
				}
				else if (base.renderer.materials.Length > materialIndex.Value)
				{
					Material[] materials = base.renderer.materials;
					materials[materialIndex.Value].SetTextureScale(namedTexture.Value, new Vector2(scaleX.Value, scaleY.Value));
					base.renderer.materials = materials;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Material)]
	[Tooltip("Sets the visibility of a GameObject. Note: this action sets the GameObject Renderer's enabled state.")]
	public class SetVisibility : ComponentAction<Renderer>
	{
		[RequiredField]
		[CheckForComponent(typeof(Renderer))]
		public FsmOwnerDefault gameObject;

		[Tooltip("Should the object visibility be toggled?\nHas priority over the 'visible' setting")]
		public FsmBool toggle;

		[Tooltip("Should the object be set to visible or invisible?")]
		public FsmBool visible;

		[Tooltip("Resets to the initial visibility when it leaves the state")]
		public bool resetOnExit;

		private bool initialVisibility;

		public override void Reset()
		{
			gameObject = null;
			toggle = false;
			visible = false;
			resetOnExit = true;
			initialVisibility = false;
		}

		public override void OnEnter()
		{
			DoSetVisibility(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private void DoSetVisibility(GameObject go)
		{
			if (UpdateCache(go))
			{
				initialVisibility = base.renderer.enabled;
				if (!toggle.Value)
				{
					base.renderer.enabled = visible.Value;
				}
				else
				{
					base.renderer.enabled = !base.renderer.enabled;
				}
			}
		}

		public override void OnExit()
		{
			if (resetOnExit)
			{
				ResetVisibility();
			}
		}

		private void ResetVisibility()
		{
			if (base.renderer != null)
			{
				base.renderer.enabled = initialVisibility;
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Flips the value of a Bool Variable.")]
	public class BoolFlip : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Bool variable to flip.")]
		public FsmBool boolVariable;

		public override void Reset()
		{
			boolVariable = null;
		}

		public override void OnEnter()
		{
			boolVariable.Value = !boolVariable.Value;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets a Float variable to its absolute value.")]
	public class FloatAbs : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Float variable.")]
		public FsmFloat floatVariable;

		[Tooltip("Repeat every frame. Useful if the Float variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoFloatAbs();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFloatAbs();
		}

		private void DoFloatAbs()
		{
			floatVariable.Value = Mathf.Abs(floatVariable.Value);
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Adds a value to a Float Variable.")]
	public class FloatAdd : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Float variable to add to.")]
		public FsmFloat floatVariable;

		[RequiredField]
		[Tooltip("Amount to add.")]
		public FsmFloat add;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		[Tooltip("Used with Every Frame. Adds the value over one second to make the operation frame rate independent.")]
		public bool perSecond;

		public override void Reset()
		{
			floatVariable = null;
			add = null;
			everyFrame = false;
			perSecond = false;
		}

		public override void OnEnter()
		{
			DoFloatAdd();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFloatAdd();
		}

		private void DoFloatAdd()
		{
			if (!perSecond)
			{
				floatVariable.Value += add.Value;
			}
			else
			{
				floatVariable.Value += add.Value * Time.deltaTime;
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Adds multiple float variables to float variable.")]
	public class FloatAddMultiple : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variables to add.")]
		public FsmFloat[] floatVariables;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Add to this variable.")]
		public FsmFloat addTo;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatVariables = null;
			addTo = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoFloatAdd();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFloatAdd();
		}

		private void DoFloatAdd()
		{
			for (int i = 0; i < floatVariables.Length; i++)
			{
				addTo.Value += floatVariables[i].Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Clamps the value of Float Variable to a Min/Max range.")]
	public class FloatClamp : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Float variable to clamp.")]
		public FsmFloat floatVariable;

		[RequiredField]
		[Tooltip("The minimum value.")]
		public FsmFloat minValue;

		[RequiredField]
		[Tooltip("The maximum value.")]
		public FsmFloat maxValue;

		[Tooltip("Repeat every frame. Useful if the float variable is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			minValue = null;
			maxValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoClamp();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoClamp();
		}

		private void DoClamp()
		{
			floatVariable.Value = Mathf.Clamp(floatVariable.Value, minValue.Value, maxValue.Value);
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Divides one Float by another.")]
	public class FloatDivide : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variable to divide.")]
		public FsmFloat floatVariable;

		[RequiredField]
		[Tooltip("Divide the float variable by this value.")]
		public FsmFloat divideBy;

		[Tooltip("Repeat every frame. Useful if the variables are changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			divideBy = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			floatVariable.Value /= divideBy.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			floatVariable.Value /= divideBy.Value;
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Interpolates between 2 Float values over a specified Time.")]
	public class FloatInterpolate : FsmStateAction
	{
		[Tooltip("Interpolation mode: Linear or EaseInOut.")]
		public InterpolationType mode;

		[RequiredField]
		[Tooltip("Interpolate from this value.")]
		public FsmFloat fromFloat;

		[RequiredField]
		[Tooltip("Interpolate to this value.")]
		public FsmFloat toFloat;

		[RequiredField]
		[Tooltip("Interpolate over this amount of time in seconds.")]
		public FsmFloat time;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the current value in a float variable.")]
		public FsmFloat storeResult;

		[Tooltip("Event to send when the interpolation is finished.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale. Useful if the game is paused (Time scaled to 0).")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		public override void Reset()
		{
			mode = InterpolationType.Linear;
			fromFloat = null;
			toFloat = null;
			time = 1f;
			storeResult = null;
			finishEvent = null;
			realTime = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			if (storeResult == null)
			{
				Finish();
			}
			else
			{
				storeResult.Value = fromFloat.Value;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			float num = currentTime / time.Value;
			switch (mode)
			{
			case InterpolationType.Linear:
				storeResult.Value = Mathf.Lerp(fromFloat.Value, toFloat.Value, num);
				break;
			case InterpolationType.EaseInOut:
				storeResult.Value = Mathf.SmoothStep(fromFloat.Value, toFloat.Value, num);
				break;
			}
			if (num >= 1f)
			{
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Multiplies one Float by another.")]
	public class FloatMultiply : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variable to multiply.")]
		public FsmFloat floatVariable;

		[RequiredField]
		[Tooltip("Multiply the float variable by this value.")]
		public FsmFloat multiplyBy;

		[Tooltip("Repeat every frame. Useful if the variables are changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			multiplyBy = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			floatVariable.Value *= multiplyBy.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			floatVariable.Value *= multiplyBy.Value;
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Performs math operations on 2 Floats: Add, Subtract, Multiply, Divide, Min, Max.")]
	public class FloatOperator : FsmStateAction
	{
		public enum Operation
		{
			Add,
			Subtract,
			Multiply,
			Divide,
			Min,
			Max
		}

		[RequiredField]
		[Tooltip("The first float.")]
		public FsmFloat float1;

		[RequiredField]
		[Tooltip("The second float.")]
		public FsmFloat float2;

		[Tooltip("The math operation to perform on the floats.")]
		public Operation operation;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result of the operation in a float variable.")]
		public FsmFloat storeResult;

		[Tooltip("Repeat every frame. Useful if the variables are changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			float1 = null;
			float2 = null;
			operation = Operation.Add;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoFloatOperator();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFloatOperator();
		}

		private void DoFloatOperator()
		{
			float value = float1.Value;
			float value2 = float2.Value;
			switch (operation)
			{
			case Operation.Add:
				storeResult.Value = value + value2;
				break;
			case Operation.Subtract:
				storeResult.Value = value - value2;
				break;
			case Operation.Multiply:
				storeResult.Value = value * value2;
				break;
			case Operation.Divide:
				storeResult.Value = value / value2;
				break;
			case Operation.Min:
				storeResult.Value = Mathf.Min(value, value2);
				break;
			case Operation.Max:
				storeResult.Value = Mathf.Max(value, value2);
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Subtracts a value from a Float Variable.")]
	public class FloatSubtract : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The float variable to subtract from.")]
		public FsmFloat floatVariable;

		[RequiredField]
		[Tooltip("Value to subtract from the float variable.")]
		public FsmFloat subtract;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		[Tooltip("Used with Every Frame. Adds the value over one second to make the operation frame rate independent.")]
		public bool perSecond;

		public override void Reset()
		{
			floatVariable = null;
			subtract = null;
			everyFrame = false;
			perSecond = false;
		}

		public override void OnEnter()
		{
			DoFloatSubtract();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFloatSubtract();
		}

		private void DoFloatSubtract()
		{
			if (!perSecond)
			{
				floatVariable.Value -= subtract.Value;
			}
			else
			{
				floatVariable.Value -= subtract.Value * Time.deltaTime;
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Adds a value to an Integer Variable.")]
	public class IntAdd : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt intVariable;

		[RequiredField]
		public FsmInt add;

		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			add = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			intVariable.Value += add.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			intVariable.Value += add.Value;
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Clamp the value of an Integer Variable to a Min/Max range.")]
	public class IntClamp : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt intVariable;

		[RequiredField]
		public FsmInt minValue;

		[RequiredField]
		public FsmInt maxValue;

		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			minValue = null;
			maxValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoClamp();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoClamp();
		}

		private void DoClamp()
		{
			intVariable.Value = Mathf.Clamp(intVariable.Value, minValue.Value, maxValue.Value);
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Performs math operation on 2 Integers: Add, Subtract, Multiply, Divide, Min, Max.")]
	public class IntOperator : FsmStateAction
	{
		public enum Operation
		{
			Add,
			Subtract,
			Multiply,
			Divide,
			Min,
			Max
		}

		[RequiredField]
		public FsmInt integer1;

		[RequiredField]
		public FsmInt integer2;

		public Operation operation;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			integer1 = null;
			integer2 = null;
			operation = Operation.Add;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIntOperator();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIntOperator();
		}

		private void DoIntOperator()
		{
			int value = integer1.Value;
			int value2 = integer2.Value;
			switch (operation)
			{
			case Operation.Add:
				storeResult.Value = value + value2;
				break;
			case Operation.Subtract:
				storeResult.Value = value - value2;
				break;
			case Operation.Multiply:
				storeResult.Value = value * value2;
				break;
			case Operation.Divide:
				storeResult.Value = value / value2;
				break;
			case Operation.Min:
				storeResult.Value = Mathf.Min(value, value2);
				break;
			case Operation.Max:
				storeResult.Value = Mathf.Max(value, value2);
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets a Bool Variable to True or False randomly.")]
	public class RandomBool : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmBool storeResult;

		public override void Reset()
		{
			storeResult = null;
		}

		public override void OnEnter()
		{
			storeResult.Value = UnityEngine.Random.Range(0, 100) < 50;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets a Float Variable to a random value between Min/Max.")]
	public class RandomFloat : FsmStateAction
	{
		[RequiredField]
		public FsmFloat min;

		[RequiredField]
		public FsmFloat max;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		public override void Reset()
		{
			min = 0f;
			max = 1f;
			storeResult = null;
		}

		public override void OnEnter()
		{
			storeResult.Value = UnityEngine.Random.Range(min.Value, max.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets an Integer Variable to a random value between Min/Max.")]
	public class RandomInt : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Minimum value for the random number.")]
		public FsmInt min;

		[RequiredField]
		[Tooltip("Maximim value for the random number.")]
		public FsmInt max;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in an Integer variable.")]
		public FsmInt storeResult;

		[Tooltip("Should the Max value be included in the possible results?")]
		public bool inclusiveMax;

		[Tooltip("Don't repeat the same value twice.")]
		public FsmBool noRepeat;

		private int randomIndex;

		private int lastIndex = -1;

		public override void Reset()
		{
			min = 0;
			max = 100;
			storeResult = null;
			inclusiveMax = false;
			noRepeat = true;
		}

		public override void OnEnter()
		{
			PickRandom();
			Finish();
		}

		private void PickRandom()
		{
			if (noRepeat.Value && max.Value != min.Value && !inclusiveMax && Mathf.Abs(max.Value - min.Value) > 1)
			{
				do
				{
					randomIndex = (inclusiveMax ? UnityEngine.Random.Range(min.Value, max.Value + 1) : UnityEngine.Random.Range(min.Value, max.Value));
				}
				while (randomIndex == lastIndex);
				lastIndex = randomIndex;
				storeResult.Value = randomIndex;
			}
			else
			{
				randomIndex = (inclusiveMax ? UnityEngine.Random.Range(min.Value, max.Value + 1) : UnityEngine.Random.Range(min.Value, max.Value));
				storeResult.Value = randomIndex;
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Gets the value of a curve at a given time and stores it in a Float Variable. NOTE: This can be used for more than just animation! It's a general way to transform an input number into an output number using a curve (e.g., linear input -> bell curve).")]
	public class SampleCurve : FsmStateAction
	{
		[RequiredField]
		public FsmAnimationCurve curve;

		[RequiredField]
		public FsmFloat sampleAt;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeValue;

		public bool everyFrame;

		public override void Reset()
		{
			curve = null;
			sampleAt = null;
			storeValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSampleCurve();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSampleCurve();
		}

		private void DoSampleCurve()
		{
			if (curve != null && curve.curve != null && storeValue != null)
			{
				storeValue.Value = curve.curve.Evaluate(sampleAt.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets the value of a Bool Variable.")]
	public class SetBoolValue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmBool boolVariable;

		[RequiredField]
		public FsmBool boolValue;

		public bool everyFrame;

		public override void Reset()
		{
			boolVariable = null;
			boolValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			boolVariable.Value = boolValue.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			boolVariable.Value = boolValue.Value;
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets the value of a Float Variable.")]
	public class SetFloatValue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat floatVariable;

		[RequiredField]
		public FsmFloat floatValue;

		public bool everyFrame;

		public override void Reset()
		{
			floatVariable = null;
			floatValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			floatVariable.Value = floatValue.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			floatVariable.Value = floatValue.Value;
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets the value of an integer variable using a float value.")]
	public class SetIntFromFloat : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt intVariable;

		public FsmFloat floatValue;

		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			floatValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			intVariable.Value = (int)floatValue.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			intVariable.Value = (int)floatValue.Value;
		}
	}
	[ActionCategory(ActionCategory.Math)]
	[Tooltip("Sets the value of an Integer Variable.")]
	public class SetIntValue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Int Variable to Set")]
		public FsmInt intVariable;

		[RequiredField]
		[Tooltip("Int Value")]
		public FsmInt intValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			intVariable = null;
			intValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			intVariable.Value = intValue.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			intVariable.Value = intValue.Value;
		}
	}
	[ActionCategory("Mesh")]
	[Tooltip("Gets the number of vertices in a GameObject's mesh. Useful in conjunction with GetVertexPosition.")]
	public class GetVertexCount : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(MeshFilter))]
		[Tooltip("The GameObject to check.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the vertex count in a variable.")]
		public FsmInt storeCount;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeCount = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetVertexCount();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetVertexCount();
		}

		private void DoGetVertexCount()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				MeshFilter component = ownerDefaultTarget.GetComponent<MeshFilter>();
				if (component == null)
				{
					LogError("Missing MeshFilter!");
				}
				else
				{
					storeCount.Value = component.mesh.vertexCount;
				}
			}
		}
	}
	[ActionCategory("Mesh")]
	[Tooltip("Gets the position of a vertex in a GameObject's mesh. Hint: Use GetVertexCount to get the number of vertices in a mesh.")]
	public class GetVertexPosition : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(MeshFilter))]
		[Tooltip("The GameObject to check.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The index of the vertex.")]
		public FsmInt vertexIndex;

		[Tooltip("Coordinate system to use.")]
		public Space space;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the vertex position in a variable.")]
		public FsmVector3 storePosition;

		[Tooltip("Repeat every frame. Useful if the mesh is animated.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			space = Space.World;
			storePosition = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetVertexPosition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetVertexPosition();
		}

		private void DoGetVertexPosition()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget != null))
			{
				return;
			}
			MeshFilter component = ownerDefaultTarget.GetComponent<MeshFilter>();
			if (component == null)
			{
				LogError("Missing MeshFilter!");
				return;
			}
			switch (space)
			{
			case Space.World:
			{
				Vector3 position = component.mesh.vertices[vertexIndex.Value];
				storePosition.Value = ownerDefaultTarget.transform.TransformPoint(position);
				break;
			}
			case Space.Self:
				storePosition.Value = component.mesh.vertices[vertexIndex.Value];
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Applies a force to a Game Object that simulates explosion effects. The explosion force will fall off linearly with distance. Hint: Use the Explosion Action instead to apply an explosion force to all objects in a blast radius.")]
	public class AddExplosionForce : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		[Tooltip("The GameObject to add the explosion force to.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The center of the explosion. Hint: this is often the position returned from a GetCollisionInfo action.")]
		public FsmVector3 center;

		[RequiredField]
		[Tooltip("The strength of the explosion.")]
		public FsmFloat force;

		[RequiredField]
		[Tooltip("The radius of the explosion. Force falls off linearly with distance.")]
		public FsmFloat radius;

		[Tooltip("Applies the force as if it was applied from beneath the object. This is useful since explosions that throw things up instead of pushing things to the side look cooler. A value of 2 will apply a force as if it is applied from 2 meters below while not changing the actual explosion position.")]
		public FsmFloat upwardsModifier;

		[Tooltip("The type of force to apply. See Unity Physics docs.")]
		public ForceMode forceMode;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			center = new FsmVector3
			{
				UseVariable = true
			};
			upwardsModifier = 0f;
			forceMode = ForceMode.Force;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoAddExplosionForce();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoAddExplosionForce();
		}

		private void DoAddExplosionForce()
		{
			GameObject go = ((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			if (center != null && UpdateCache(go))
			{
				base.rigidbody.AddExplosionForce(force.Value, center.Value, radius.Value, upwardsModifier.Value, forceMode);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Adds a force to a Game Object. Use Vector3 variable and/or Float variables for each axis.")]
	public class AddForce : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		[Tooltip("The GameObject to apply the force to.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Optionally apply the force at a position on the object. This will also add some torque. The position is often returned from MousePick or GetCollisionInfo actions.")]
		public FsmVector3 atPosition;

		[UIHint(UIHint.Variable)]
		[Tooltip("A Vector3 force to add. Optionally override any axis with the X, Y, Z parameters.")]
		public FsmVector3 vector;

		[Tooltip("Force along the X axis. To leave unchanged, set to 'None'.")]
		public FsmFloat x;

		[Tooltip("Force along the Y axis. To leave unchanged, set to 'None'.")]
		public FsmFloat y;

		[Tooltip("Force along the Z axis. To leave unchanged, set to 'None'.")]
		public FsmFloat z;

		[Tooltip("Apply the force in world or local space.")]
		public Space space;

		[Tooltip("The type of force to apply. See Unity Physics docs.")]
		public ForceMode forceMode;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			atPosition = new FsmVector3
			{
				UseVariable = true
			};
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			space = Space.World;
			forceMode = ForceMode.Force;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoAddForce();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoAddForce();
		}

		private void DoAddForce()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!UpdateCache(ownerDefaultTarget))
			{
				return;
			}
			Vector3 force = (vector.IsNone ? default(Vector3) : vector.Value);
			if (!x.IsNone)
			{
				force.x = x.Value;
			}
			if (!y.IsNone)
			{
				force.y = y.Value;
			}
			if (!z.IsNone)
			{
				force.z = z.Value;
			}
			if (space == Space.World)
			{
				if (!atPosition.IsNone)
				{
					base.rigidbody.AddForceAtPosition(force, atPosition.Value, forceMode);
				}
				else
				{
					base.rigidbody.AddForce(force, forceMode);
				}
			}
			else
			{
				base.rigidbody.AddRelativeForce(force, forceMode);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Adds torque (rotational force) to a Game Object.")]
	public class AddTorque : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		[Tooltip("The GameObject to add torque to.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("A Vector3 torque. Optionally override any axis with the X, Y, Z parameters.")]
		public FsmVector3 vector;

		[Tooltip("Torque around the X axis. To leave unchanged, set to 'None'.")]
		public FsmFloat x;

		[Tooltip("Torque around the Y axis. To leave unchanged, set to 'None'.")]
		public FsmFloat y;

		[Tooltip("Torque around the Z axis. To leave unchanged, set to 'None'.")]
		public FsmFloat z;

		[Tooltip("Apply the force in world or local space.")]
		public Space space;

		[Tooltip("The type of force to apply. See Unity Physics docs.")]
		public ForceMode forceMode;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			space = Space.World;
			forceMode = ForceMode.Force;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoAddTorque();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoAddTorque();
		}

		private void DoAddTorque()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				Vector3 torque = (vector.IsNone ? new Vector3(x.Value, y.Value, z.Value) : vector.Value);
				if (!x.IsNone)
				{
					torque.x = x.Value;
				}
				if (!y.IsNone)
				{
					torque.y = y.Value;
				}
				if (!z.IsNone)
				{
					torque.z = z.Value;
				}
				if (space == Space.World)
				{
					base.rigidbody.AddTorque(torque, forceMode);
				}
				else
				{
					base.rigidbody.AddRelativeTorque(torque, forceMode);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Detect collisions between Game Objects that have RigidBody/Collider components.")]
	public class CollisionEvent : FsmStateAction
	{
		[Tooltip("The GameObject to detect collisions on.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The type of collision to detect.")]
		public CollisionType collision;

		[UIHint(UIHint.TagMenu)]
		[Tooltip("Filter by Tag.")]
		public FsmString collideTag;

		[Tooltip("Event to send if a collision is detected.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the GameObject that collided with the Owner of this FSM.")]
		public FsmGameObject storeCollider;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the force of the collision. NOTE: Use Get Collision Info to get more info about the collision.")]
		public FsmFloat storeForce;

		private PlayMakerProxyBase cachedProxy;

		public override void Reset()
		{
			gameObject = null;
			collision = CollisionType.OnCollisionEnter;
			collideTag = "";
			sendEvent = null;
			storeCollider = null;
			storeForce = null;
		}

		public override void OnPreprocess()
		{
			if (gameObject == null)
			{
				gameObject = new FsmOwnerDefault();
			}
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				switch (collision)
				{
				case CollisionType.OnCollisionEnter:
					base.Fsm.HandleCollisionEnter = true;
					break;
				case CollisionType.OnCollisionStay:
					base.Fsm.HandleCollisionStay = true;
					break;
				case CollisionType.OnCollisionExit:
					base.Fsm.HandleCollisionExit = true;
					break;
				case CollisionType.OnControllerColliderHit:
					base.Fsm.HandleControllerColliderHit = true;
					break;
				case CollisionType.OnParticleCollision:
					base.Fsm.HandleParticleCollision = true;
					break;
				}
			}
			else
			{
				GetProxyComponent();
			}
		}

		public override void OnEnter()
		{
			if (gameObject.OwnerOption != 0)
			{
				if (cachedProxy == null)
				{
					GetProxyComponent();
				}
				AddCallback();
				gameObject.GameObject.OnChange += UpdateCallback;
			}
		}

		public override void OnExit()
		{
			if (gameObject.OwnerOption != 0)
			{
				RemoveCallback();
				gameObject.GameObject.OnChange -= UpdateCallback;
			}
		}

		private void UpdateCallback()
		{
			RemoveCallback();
			GetProxyComponent();
			AddCallback();
		}

		private void GetProxyComponent()
		{
			cachedProxy = null;
			GameObject value = gameObject.GameObject.Value;
			if (!(value == null))
			{
				switch (collision)
				{
				case CollisionType.OnCollisionEnter:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerCollisionEnter>(value);
					break;
				case CollisionType.OnCollisionStay:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerCollisionStay>(value);
					break;
				case CollisionType.OnCollisionExit:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerCollisionExit>(value);
					break;
				case CollisionType.OnParticleCollision:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerParticleCollision>(value);
					break;
				case CollisionType.OnControllerColliderHit:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerControllerColliderHit>(value);
					break;
				}
			}
		}

		private void AddCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (collision)
				{
				case CollisionType.OnCollisionEnter:
					cachedProxy.AddCollisionEventCallback(CollisionEnter);
					break;
				case CollisionType.OnCollisionStay:
					cachedProxy.AddCollisionEventCallback(CollisionStay);
					break;
				case CollisionType.OnCollisionExit:
					cachedProxy.AddCollisionEventCallback(CollisionExit);
					break;
				case CollisionType.OnParticleCollision:
					cachedProxy.AddParticleCollisionEventCallback(ParticleCollision);
					break;
				case CollisionType.OnControllerColliderHit:
					cachedProxy.AddControllerCollisionEventCallback(ControllerColliderHit);
					break;
				}
			}
		}

		private void RemoveCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (collision)
				{
				case CollisionType.OnCollisionEnter:
					cachedProxy.RemoveCollisionEventCallback(CollisionEnter);
					break;
				case CollisionType.OnCollisionStay:
					cachedProxy.RemoveCollisionEventCallback(CollisionStay);
					break;
				case CollisionType.OnCollisionExit:
					cachedProxy.RemoveCollisionEventCallback(CollisionExit);
					break;
				case CollisionType.OnParticleCollision:
					cachedProxy.RemoveParticleCollisionEventCallback(ParticleCollision);
					break;
				case CollisionType.OnControllerColliderHit:
					cachedProxy.RemoveControllerCollisionEventCallback(ControllerColliderHit);
					break;
				}
			}
		}

		private void StoreCollisionInfo(Collision collisionInfo)
		{
			storeCollider.Value = collisionInfo.gameObject;
			storeForce.Value = collisionInfo.relativeVelocity.magnitude;
		}

		public override void DoCollisionEnter(Collision collisionInfo)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				CollisionEnter(collisionInfo);
			}
		}

		public override void DoCollisionStay(Collision collisionInfo)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				CollisionStay(collisionInfo);
			}
		}

		public override void DoCollisionExit(Collision collisionInfo)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				CollisionExit(collisionInfo);
			}
		}

		public override void DoControllerColliderHit(ControllerColliderHit collisionInfo)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				ControllerColliderHit(collisionInfo);
			}
		}

		public override void DoParticleCollision(GameObject other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				ParticleCollision(other);
			}
		}

		private void CollisionEnter(Collision collisionInfo)
		{
			if (collision == CollisionType.OnCollisionEnter && FsmStateAction.TagMatches(collideTag, collisionInfo))
			{
				StoreCollisionInfo(collisionInfo);
				base.Fsm.Event(sendEvent);
			}
		}

		private void CollisionStay(Collision collisionInfo)
		{
			if (collision == CollisionType.OnCollisionStay && FsmStateAction.TagMatches(collideTag, collisionInfo))
			{
				StoreCollisionInfo(collisionInfo);
				base.Fsm.Event(sendEvent);
			}
		}

		private void CollisionExit(Collision collisionInfo)
		{
			if (collision == CollisionType.OnCollisionExit && FsmStateAction.TagMatches(collideTag, collisionInfo))
			{
				StoreCollisionInfo(collisionInfo);
				base.Fsm.Event(sendEvent);
			}
		}

		private void ControllerColliderHit(ControllerColliderHit collisionInfo)
		{
			if (collision == CollisionType.OnControllerColliderHit && FsmStateAction.TagMatches(collideTag, collisionInfo))
			{
				if (storeCollider != null)
				{
					storeCollider.Value = collisionInfo.gameObject;
				}
				storeForce.Value = 0f;
				base.Fsm.Event(sendEvent);
			}
		}

		private void ParticleCollision(GameObject other)
		{
			if (collision == CollisionType.OnParticleCollision && FsmStateAction.TagMatches(collideTag, other))
			{
				if (storeCollider != null)
				{
					storeCollider.Value = other;
				}
				storeForce.Value = 0f;
				base.Fsm.Event(sendEvent);
			}
		}

		public override string ErrorCheck()
		{
			return ActionHelpers.CheckPhysicsSetup(base.Fsm.GetOwnerDefaultTarget(gameObject));
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Applies an explosion Force to all Game Objects with a Rigid Body inside a Radius.")]
	public class Explosion : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The world position of the center of the explosion.")]
		public FsmVector3 center;

		[RequiredField]
		[Tooltip("The strength of the explosion.")]
		public FsmFloat force;

		[RequiredField]
		[Tooltip("The radius of the explosion. Force falls of linearly with distance.")]
		public FsmFloat radius;

		[Tooltip("Applies the force as if it was applied from beneath the object. This is useful since explosions that throw things up instead of pushing things to the side look cooler. A value of 2 will apply a force as if it is applied from 2 meters below while not changing the actual explosion position.")]
		public FsmFloat upwardsModifier;

		[Tooltip("The type of force to apply.")]
		public ForceMode forceMode;

		[UIHint(UIHint.Layer)]
		public FsmInt layer;

		[UIHint(UIHint.Layer)]
		[Tooltip("Layers to effect.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you effect all layers except those defined above.")]
		public FsmBool invertMask;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			center = null;
			upwardsModifier = 0f;
			forceMode = ForceMode.Force;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoExplosion();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoExplosion();
		}

		private void DoExplosion()
		{
			Collider[] array = Physics.OverlapSphere(center.Value, radius.Value);
			foreach (Collider collider in array)
			{
				Rigidbody component = collider.gameObject.GetComponent<Rigidbody>();
				if (component != null && ShouldApplyForce(collider.gameObject))
				{
					component.AddExplosionForce(force.Value, center.Value, radius.Value, upwardsModifier.Value, forceMode);
				}
			}
		}

		private bool ShouldApplyForce(GameObject go)
		{
			int num = ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value);
			return ((1 << go.layer) & num) > 0;
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets info on the last collision event and store in variables. See Unity Physics docs.")]
	public class GetCollisionInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the GameObject hit.")]
		public FsmGameObject gameObjectHit;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the relative velocity of the collision.")]
		public FsmVector3 relativeVelocity;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the relative speed of the collision. Useful for controlling reactions. E.g., selecting an appropriate sound fx.")]
		public FsmFloat relativeSpeed;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the world position of the collision contact. Useful for spawning effects etc.")]
		public FsmVector3 contactPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the collision normal vector. Useful for aligning spawned effects etc.")]
		public FsmVector3 contactNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the name of the physics material of the colliding GameObject. Useful for triggering different effects. Audio, particles...")]
		public FsmString physicsMaterialName;

		public override void Reset()
		{
			gameObjectHit = null;
			relativeVelocity = null;
			relativeSpeed = null;
			contactPoint = null;
			contactNormal = null;
			physicsMaterialName = null;
		}

		private void StoreCollisionInfo()
		{
			if (base.Fsm.CollisionInfo != null)
			{
				gameObjectHit.Value = base.Fsm.CollisionInfo.gameObject;
				relativeSpeed.Value = base.Fsm.CollisionInfo.relativeVelocity.magnitude;
				relativeVelocity.Value = base.Fsm.CollisionInfo.relativeVelocity;
				physicsMaterialName.Value = base.Fsm.CollisionInfo.collider.material.name;
				if (base.Fsm.CollisionInfo.contacts != null && base.Fsm.CollisionInfo.contacts.Length != 0)
				{
					contactPoint.Value = base.Fsm.CollisionInfo.contacts[0].point;
					contactNormal.Value = base.Fsm.CollisionInfo.contacts[0].normal;
				}
			}
		}

		public override void OnEnter()
		{
			StoreCollisionInfo();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets info on the last joint break event.")]
	public class GetJointBreakInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the force that broke the joint.")]
		public FsmFloat breakForce;

		public override void Reset()
		{
			breakForce = null;
		}

		public override void OnEnter()
		{
			breakForce.Value = base.Fsm.JointBreakForce;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets the Mass of a Game Object's Rigid Body.")]
	public class GetMass : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		[Tooltip("The GameObject that owns the Rigidbody")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the mass in a float variable.")]
		public FsmFloat storeResult;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			DoGetMass();
			Finish();
		}

		private void DoGetMass()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				storeResult.Value = base.rigidbody.mass;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets info on the last particle collision event. See Unity Particle System docs.")]
	public class GetParticleCollisionInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the GameObject hit.")]
		public FsmGameObject gameObjectHit;

		public override void Reset()
		{
			gameObjectHit = null;
		}

		private void StoreCollisionInfo()
		{
			gameObjectHit.Value = base.Fsm.ParticleCollisionGO;
		}

		public override void OnEnter()
		{
			StoreCollisionInfo();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets info on the last RaycastAll and store in array variables.")]
	public class GetRaycastAllInfo : FsmStateAction
	{
		[Tooltip("Store the GameObjects hit in an array variable.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray storeHitObjects;

		[Tooltip("Get the world position of all ray hit point and store them in an array variable.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Vector3, "", 0, 0, 65536)]
		public FsmArray points;

		[Tooltip("Get the normal at all hit points and store them in an array variable.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Vector3, "", 0, 0, 65536)]
		public FsmArray normals;

		[Tooltip("Get the distance along the ray to all hit points and store them in an array variable.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.Float, "", 0, 0, 65536)]
		public FsmArray distances;

		[Tooltip("Repeat every frame. Warning, this could be affecting performances")]
		public bool everyFrame;

		public override void Reset()
		{
			storeHitObjects = null;
			points = null;
			normals = null;
			distances = null;
			everyFrame = false;
		}

		private void StoreRaycastAllInfo()
		{
			if (RaycastAll.RaycastAllHitInfo != null)
			{
				storeHitObjects.Resize(RaycastAll.RaycastAllHitInfo.Length);
				points.Resize(RaycastAll.RaycastAllHitInfo.Length);
				normals.Resize(RaycastAll.RaycastAllHitInfo.Length);
				distances.Resize(RaycastAll.RaycastAllHitInfo.Length);
				for (int i = 0; i < RaycastAll.RaycastAllHitInfo.Length; i++)
				{
					storeHitObjects.Values[i] = RaycastAll.RaycastAllHitInfo[i].collider.gameObject;
					points.Values[i] = RaycastAll.RaycastAllHitInfo[i].point;
					normals.Values[i] = RaycastAll.RaycastAllHitInfo[i].normal;
					distances.Values[i] = RaycastAll.RaycastAllHitInfo[i].distance;
				}
			}
		}

		public override void OnEnter()
		{
			StoreRaycastAllInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			StoreRaycastAllInfo();
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets info on the last Raycast and store in variables.")]
	public class GetRaycastHitInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the GameObject hit by the last Raycast and store it in a variable.")]
		public FsmGameObject gameObjectHit;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the world position of the ray hit point and store it in a variable.")]
		[Title("Hit Point")]
		public FsmVector3 point;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the normal at the hit point and store it in a variable.")]
		public FsmVector3 normal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the distance along the ray to the hit point and store it in a variable.")]
		public FsmFloat distance;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObjectHit = null;
			point = null;
			normal = null;
			distance = null;
			everyFrame = false;
		}

		private void StoreRaycastInfo()
		{
			if (base.Fsm.RaycastHitInfo.collider != null)
			{
				gameObjectHit.Value = base.Fsm.RaycastHitInfo.collider.gameObject;
				point.Value = base.Fsm.RaycastHitInfo.point;
				normal.Value = base.Fsm.RaycastHitInfo.normal;
				distance.Value = base.Fsm.RaycastHitInfo.distance;
			}
		}

		public override void OnEnter()
		{
			StoreRaycastInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			StoreRaycastInfo();
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets the Speed of a Game Object and stores it in a Float Variable. NOTE: The Game Object must have a rigid body.")]
	public class GetSpeed : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		[Tooltip("The GameObject with a Rigidbody.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the speed in a float variable.")]
		public FsmFloat storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetSpeed();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSpeed();
		}

		private void DoGetSpeed()
		{
			if (storeResult != null)
			{
				GameObject go = ((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
				if (UpdateCache(go))
				{
					Vector3 velocity = base.rigidbody.velocity;
					storeResult.Value = velocity.magnitude;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets info on the last Trigger event and store in variables.")]
	public class GetTriggerInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmGameObject gameObjectHit;

		[UIHint(UIHint.Variable)]
		[Tooltip("Useful for triggering different effects. Audio, particles...")]
		public FsmString physicsMaterialName;

		public override void Reset()
		{
			gameObjectHit = null;
			physicsMaterialName = null;
		}

		private void StoreTriggerInfo()
		{
			if (!(base.Fsm.TriggerCollider == null))
			{
				gameObjectHit.Value = base.Fsm.TriggerCollider.gameObject;
				physicsMaterialName.Value = base.Fsm.TriggerCollider.material.name;
			}
		}

		public override void OnEnter()
		{
			StoreTriggerInfo();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Gets the Velocity of a Game Object and stores it in a Vector3 Variable or each Axis in a Float Variable. NOTE: The Game Object must have a Rigid Body.")]
	public class GetVelocity : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		public FsmVector3 vector;

		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		[UIHint(UIHint.Variable)]
		public FsmFloat z;

		public Space space;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = null;
			y = null;
			z = null;
			space = Space.World;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetVelocity();
		}

		private void DoGetVelocity()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				Vector3 vector = base.rigidbody.velocity;
				if (space == Space.Self)
				{
					vector = ownerDefaultTarget.transform.InverseTransformDirection(vector);
				}
				this.vector.Value = vector;
				x.Value = vector.x;
				y.Value = vector.y;
				z.Value = vector.z;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Tests if a Game Object's Rigid Body is Kinematic.")]
	public class IsKinematic : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		public FsmEvent trueEvent;

		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool store;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			store = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIsKinematic();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIsKinematic();
		}

		private void DoIsKinematic()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				bool isKinematic = base.rigidbody.isKinematic;
				store.Value = isKinematic;
				base.Fsm.Event(isKinematic ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Tests if a Game Object's Rigid Body is sleeping.")]
	public class IsSleeping : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		public FsmEvent trueEvent;

		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		public FsmBool store;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			store = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIsSleeping();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIsSleeping();
		}

		private void DoIsSleeping()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				bool flag = base.rigidbody.IsSleeping();
				store.Value = flag;
				base.Fsm.Event(flag ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Casts a Ray against all Colliders in the scene. Use either a Game Object or Vector3 world position as the origin of the ray. Use GetRaycastInfo to get more detailed info.")]
	public class Raycast : FsmStateAction
	{
		[Tooltip("Start ray at game object position. \nOr use From Position parameter.")]
		public FsmOwnerDefault fromGameObject;

		[Tooltip("Start ray at a vector3 world position. \nOr use Game Object parameter.")]
		public FsmVector3 fromPosition;

		[Tooltip("A vector3 direction vector")]
		public FsmVector3 direction;

		[Tooltip("Cast the ray in world or local space. Note if no Game Object is specified, the direction is in world space.")]
		public Space space;

		[Tooltip("The length of the ray. Set to -1 for infinity.")]
		public FsmFloat distance;

		[ActionSection("Result")]
		[Tooltip("Event to send if the ray hits an object.")]
		[UIHint(UIHint.Variable)]
		public FsmEvent hitEvent;

		[Tooltip("Set a bool variable to true if hit something, otherwise false.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeDidHit;

		[Tooltip("Store the game object hit in a variable.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeHitObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the world position of the ray hit point and store it in a variable.")]
		public FsmVector3 storeHitPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the normal at the hit point and store it in a variable.")]
		public FsmVector3 storeHitNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the distance along the ray to the hit point and store it in a variable.")]
		public FsmFloat storeHitDistance;

		[ActionSection("Filter")]
		[Tooltip("Set how often to cast a ray. 0 = once, don't repeat; 1 = everyFrame; 2 = every other frame... \nSince raycasts can get expensive use the highest repeat interval you can get away with.")]
		public FsmInt repeatInterval;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Debug")]
		[Tooltip("The color to use for the debug line.")]
		public FsmColor debugColor;

		[Tooltip("Draw a debug line. Note: Check Gizmos in the Game View to see it in game.")]
		public FsmBool debug;

		private int repeat;

		public override void Reset()
		{
			fromGameObject = null;
			fromPosition = new FsmVector3
			{
				UseVariable = true
			};
			direction = new FsmVector3
			{
				UseVariable = true
			};
			space = Space.Self;
			distance = 100f;
			hitEvent = null;
			storeDidHit = null;
			storeHitObject = null;
			storeHitPoint = null;
			storeHitNormal = null;
			storeHitDistance = null;
			repeatInterval = 1;
			layerMask = new FsmInt[0];
			invertMask = false;
			debugColor = Color.yellow;
			debug = false;
		}

		public override void OnEnter()
		{
			DoRaycast();
			if (repeatInterval.Value == 0)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			repeat--;
			if (repeat == 0)
			{
				DoRaycast();
			}
		}

		private void DoRaycast()
		{
			repeat = repeatInterval.Value;
			if (distance.Value != 0f)
			{
				GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(fromGameObject);
				Vector3 vector = ((ownerDefaultTarget != null) ? ownerDefaultTarget.transform.position : fromPosition.Value);
				float num = float.PositiveInfinity;
				if (distance.Value > 0f)
				{
					num = distance.Value;
				}
				Vector3 vector2 = direction.Value;
				if (ownerDefaultTarget != null && space == Space.Self)
				{
					vector2 = ownerDefaultTarget.transform.TransformDirection(direction.Value);
				}
				Physics.Raycast(vector, vector2, out var hitInfo, num, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
				base.Fsm.RaycastHitInfo = hitInfo;
				bool flag = hitInfo.collider != null;
				storeDidHit.Value = flag;
				if (flag)
				{
					storeHitObject.Value = hitInfo.collider.gameObject;
					storeHitPoint.Value = base.Fsm.RaycastHitInfo.point;
					storeHitNormal.Value = base.Fsm.RaycastHitInfo.normal;
					storeHitDistance.Value = base.Fsm.RaycastHitInfo.distance;
					base.Fsm.Event(hitEvent);
				}
				if (debug.Value)
				{
					float num2 = Mathf.Min(num, 1000f);
					UnityEngine.Debug.DrawLine(vector, vector + vector2 * num2, debugColor.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Casts a Ray against all Colliders in the scene. Use either a GameObject or Vector3 world position as the origin of the ray. Use GetRaycastAllInfo to get more detailed info.")]
	public class RaycastAll : FsmStateAction
	{
		public static RaycastHit[] RaycastAllHitInfo;

		[Tooltip("Start ray at game object position. \nOr use From Position parameter.")]
		public FsmOwnerDefault fromGameObject;

		[Tooltip("Start ray at a vector3 world position. \nOr use Game Object parameter.")]
		public FsmVector3 fromPosition;

		[Tooltip("A vector3 direction vector")]
		public FsmVector3 direction;

		[Tooltip("Cast the ray in world or local space. Note if no Game Object is specified, the direction is in world space.")]
		public Space space;

		[Tooltip("The length of the ray. Set to -1 for infinity.")]
		public FsmFloat distance;

		[ActionSection("Result")]
		[Tooltip("Event to send if the ray hits an object.")]
		[UIHint(UIHint.Variable)]
		public FsmEvent hitEvent;

		[Tooltip("Set a bool variable to true if hit something, otherwise false.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeDidHit;

		[Tooltip("Store the GameObjects hit in an array variable.")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray storeHitObjects;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the world position of the ray hit point and store it in a variable.")]
		public FsmVector3 storeHitPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the normal at the hit point and store it in a variable.")]
		public FsmVector3 storeHitNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the distance along the ray to the hit point and store it in a variable.")]
		public FsmFloat storeHitDistance;

		[ActionSection("Filter")]
		[Tooltip("Set how often to cast a ray. 0 = once, don't repeat; 1 = everyFrame; 2 = every other frame... \nSince raycasts can get expensive use the highest repeat interval you can get away with.")]
		public FsmInt repeatInterval;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Debug")]
		[Tooltip("The color to use for the debug line.")]
		public FsmColor debugColor;

		[Tooltip("Draw a debug line. Note: Check Gizmos in the Game View to see it in game.")]
		public FsmBool debug;

		private int repeat;

		public override void Reset()
		{
			fromGameObject = null;
			fromPosition = new FsmVector3
			{
				UseVariable = true
			};
			direction = new FsmVector3
			{
				UseVariable = true
			};
			space = Space.Self;
			distance = 100f;
			hitEvent = null;
			storeDidHit = null;
			storeHitObjects = null;
			storeHitPoint = null;
			storeHitNormal = null;
			storeHitDistance = null;
			repeatInterval = 1;
			layerMask = new FsmInt[0];
			invertMask = false;
			debugColor = Color.yellow;
			debug = false;
		}

		public override void OnEnter()
		{
			DoRaycast();
			if (repeatInterval.Value == 0)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			repeat--;
			if (repeat == 0)
			{
				DoRaycast();
			}
		}

		private void DoRaycast()
		{
			repeat = repeatInterval.Value;
			if (distance.Value == 0f)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(fromGameObject);
			Vector3 vector = ((ownerDefaultTarget != null) ? ownerDefaultTarget.transform.position : fromPosition.Value);
			float num = float.PositiveInfinity;
			if (distance.Value > 0f)
			{
				num = distance.Value;
			}
			Vector3 vector2 = direction.Value;
			if (ownerDefaultTarget != null && space == Space.Self)
			{
				vector2 = ownerDefaultTarget.transform.TransformDirection(direction.Value);
			}
			RaycastAllHitInfo = Physics.RaycastAll(vector, vector2, num, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			bool flag = RaycastAllHitInfo.Length != 0;
			storeDidHit.Value = flag;
			if (flag)
			{
				GameObject[] array = new GameObject[RaycastAllHitInfo.Length];
				for (int i = 0; i < RaycastAllHitInfo.Length; i++)
				{
					RaycastHit raycastHit = RaycastAllHitInfo[i];
					array[i] = raycastHit.collider.gameObject;
				}
				FsmArray fsmArray = storeHitObjects;
				object[] values = array;
				fsmArray.Values = values;
				storeHitPoint.Value = base.Fsm.RaycastHitInfo.point;
				storeHitNormal.Value = base.Fsm.RaycastHitInfo.normal;
				storeHitDistance.Value = base.Fsm.RaycastHitInfo.distance;
				base.Fsm.Event(hitEvent);
			}
			if (debug.Value)
			{
				float num2 = Mathf.Min(num, 1000f);
				UnityEngine.Debug.DrawLine(vector, vector + vector2 * num2, debugColor.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[HelpUrl("http://hutonggames.com/playmakerforum/index.php?topic=4734.0")]
	[Tooltip("Sets the Drag of a Game Object's Rigid Body.")]
	public class SetDrag : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HasFloatSlider(0f, 10f)]
		public FsmFloat drag;

		[Tooltip("Repeat every frame. Typically this would be set to True.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			drag = 1f;
		}

		public override void OnEnter()
		{
			DoSetDrag();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetDrag();
		}

		private void DoSetDrag()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody.drag = drag.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Sets the gravity vector, or individual axis.")]
	public class SetGravity : FsmStateAction
	{
		public FsmVector3 vector;

		public FsmFloat x;

		public FsmFloat y;

		public FsmFloat z;

		public bool everyFrame;

		public override void Reset()
		{
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetGravity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetGravity();
		}

		private void DoSetGravity()
		{
			Vector3 value = vector.Value;
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			if (!z.IsNone)
			{
				value.z = z.Value;
			}
			Physics.gravity = value;
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Controls whether physics affects the Game Object.")]
	public class SetIsKinematic : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmBool isKinematic;

		public override void Reset()
		{
			gameObject = null;
			isKinematic = false;
		}

		public override void OnEnter()
		{
			DoSetIsKinematic();
			Finish();
		}

		private void DoSetIsKinematic()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody.isKinematic = isKinematic.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Connect a joint to a game object.")]
	public class SetJointConnectedBody : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Joint))]
		[Tooltip("The joint to connect. Requires a Joint component.")]
		public FsmOwnerDefault joint;

		[CheckForComponent(typeof(Rigidbody))]
		[Tooltip("The game object to connect to the Joint. Set to none to connect the Joint to the world.")]
		public FsmGameObject rigidBody;

		public override void Reset()
		{
			joint = null;
			rigidBody = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(joint);
			if (ownerDefaultTarget != null)
			{
				Joint component = ownerDefaultTarget.GetComponent<Joint>();
				if (component != null)
				{
					component.connectedBody = ((rigidBody.Value == null) ? null : rigidBody.Value.GetComponent<Rigidbody>());
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Sets the Mass of a Game Object's Rigid Body.")]
	public class SetMass : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HasFloatSlider(0.1f, 10f)]
		public FsmFloat mass;

		public override void Reset()
		{
			gameObject = null;
			mass = 1f;
		}

		public override void OnEnter()
		{
			DoSetMass();
			Finish();
		}

		private void DoSetMass()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody.mass = mass.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Sets the Velocity of a Game Object. To leave any axis unchanged, set variable to 'None'. NOTE: Game object must have a rigidbody.")]
	public class SetVelocity : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		public FsmVector3 vector;

		public FsmFloat x;

		public FsmFloat y;

		public FsmFloat z;

		public Space space;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			space = Space.Self;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoSetVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoSetVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetVelocity()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				Vector3 vector = ((!this.vector.IsNone) ? this.vector.Value : ((space == Space.World) ? base.rigidbody.velocity : ownerDefaultTarget.transform.InverseTransformDirection(base.rigidbody.velocity)));
				if (!x.IsNone)
				{
					vector.x = x.Value;
				}
				if (!y.IsNone)
				{
					vector.y = y.Value;
				}
				if (!z.IsNone)
				{
					vector.z = z.Value;
				}
				base.rigidbody.velocity = ((space == Space.World) ? vector : ownerDefaultTarget.transform.TransformDirection(vector));
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Forces a Game Object's Rigid Body to Sleep at least one frame.")]
	public class Sleep : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			DoSleep();
			Finish();
		}

		private void DoSleep()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody.Sleep();
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Detect trigger collisions between GameObjects that have RigidBody/Collider components.")]
	public class TriggerEvent : FsmStateAction
	{
		[Tooltip("The GameObject to detect trigger events on.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The type of trigger event to detect.")]
		public TriggerType trigger;

		[UIHint(UIHint.TagMenu)]
		[Tooltip("Filter by Tag.")]
		public FsmString collideTag;

		[Tooltip("Event to send if the trigger event is detected.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the GameObject that collided with the Owner of this FSM.")]
		public FsmGameObject storeCollider;

		private PlayMakerProxyBase cachedProxy;

		public override void Reset()
		{
			gameObject = null;
			trigger = TriggerType.OnTriggerEnter;
			collideTag = "";
			sendEvent = null;
			storeCollider = null;
		}

		public override void OnPreprocess()
		{
			if (gameObject == null)
			{
				gameObject = new FsmOwnerDefault();
			}
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				switch (trigger)
				{
				case TriggerType.OnTriggerEnter:
					base.Fsm.HandleTriggerEnter = true;
					break;
				case TriggerType.OnTriggerStay:
					base.Fsm.HandleTriggerStay = true;
					break;
				case TriggerType.OnTriggerExit:
					base.Fsm.HandleTriggerExit = true;
					break;
				}
			}
			else
			{
				GetProxyComponent();
			}
		}

		public override void OnEnter()
		{
			if (gameObject.OwnerOption != 0)
			{
				if (cachedProxy == null)
				{
					GetProxyComponent();
				}
				AddCallback();
				gameObject.GameObject.OnChange += UpdateCallback;
			}
		}

		public override void OnExit()
		{
			if (gameObject.OwnerOption != 0)
			{
				RemoveCallback();
				gameObject.GameObject.OnChange -= UpdateCallback;
			}
		}

		private void UpdateCallback()
		{
			RemoveCallback();
			GetProxyComponent();
			AddCallback();
		}

		private void GetProxyComponent()
		{
			cachedProxy = null;
			GameObject value = gameObject.GameObject.Value;
			if (!(value == null))
			{
				switch (trigger)
				{
				case TriggerType.OnTriggerEnter:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerTriggerEnter>(value);
					break;
				case TriggerType.OnTriggerStay:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerTriggerStay>(value);
					break;
				case TriggerType.OnTriggerExit:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerTriggerExit>(value);
					break;
				}
			}
		}

		private void AddCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (trigger)
				{
				case TriggerType.OnTriggerEnter:
					cachedProxy.AddTriggerEventCallback(TriggerEnter);
					break;
				case TriggerType.OnTriggerStay:
					cachedProxy.AddTriggerEventCallback(TriggerStay);
					break;
				case TriggerType.OnTriggerExit:
					cachedProxy.AddTriggerEventCallback(TriggerExit);
					break;
				}
			}
		}

		private void RemoveCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (trigger)
				{
				case TriggerType.OnTriggerEnter:
					cachedProxy.RemoveTriggerEventCallback(TriggerEnter);
					break;
				case TriggerType.OnTriggerStay:
					cachedProxy.RemoveTriggerEventCallback(TriggerStay);
					break;
				case TriggerType.OnTriggerExit:
					cachedProxy.RemoveTriggerEventCallback(TriggerExit);
					break;
				}
			}
		}

		private void StoreCollisionInfo(Collider collisionInfo)
		{
			storeCollider.Value = collisionInfo.gameObject;
		}

		public override void DoTriggerEnter(Collider other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				TriggerEnter(other);
			}
		}

		public override void DoTriggerStay(Collider other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				TriggerStay(other);
			}
		}

		public override void DoTriggerExit(Collider other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				TriggerExit(other);
			}
		}

		private void TriggerEnter(Collider other)
		{
			if (trigger == TriggerType.OnTriggerEnter && FsmStateAction.TagMatches(collideTag, other))
			{
				StoreCollisionInfo(other);
				base.Fsm.Event(sendEvent);
			}
		}

		private void TriggerStay(Collider other)
		{
			if (trigger == TriggerType.OnTriggerStay && FsmStateAction.TagMatches(collideTag, other))
			{
				StoreCollisionInfo(other);
				base.Fsm.Event(sendEvent);
			}
		}

		private void TriggerExit(Collider other)
		{
			if (trigger == TriggerType.OnTriggerExit && FsmStateAction.TagMatches(collideTag, other))
			{
				StoreCollisionInfo(other);
				base.Fsm.Event(sendEvent);
			}
		}

		public override string ErrorCheck()
		{
			return ActionHelpers.CheckPhysicsSetup(base.Fsm.GetOwnerDefaultTarget(gameObject));
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Sets whether a Game Object's Rigidbody is affected by Gravity.")]
	public class UseGravity : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmBool useGravity;

		public override void Reset()
		{
			gameObject = null;
			useGravity = true;
		}

		public override void OnEnter()
		{
			DoUseGravity();
			Finish();
		}

		private void DoUseGravity()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody.useGravity = useGravity.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Rigid bodies start sleeping when they come to rest. This action wakes up all rigid bodies in the scene. E.g., if you Set Gravity and want objects at rest to respond.")]
	public class WakeAllRigidBodies : FsmStateAction
	{
		public bool everyFrame;

		private Rigidbody[] bodies;

		public override void Reset()
		{
			everyFrame = false;
		}

		public override void OnEnter()
		{
			bodies = UnityEngine.Object.FindObjectsOfType(typeof(Rigidbody)) as Rigidbody[];
			DoWakeAll();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoWakeAll();
		}

		private void DoWakeAll()
		{
			bodies = UnityEngine.Object.FindObjectsOfType(typeof(Rigidbody)) as Rigidbody[];
			if (bodies != null)
			{
				Rigidbody[] array = bodies;
				for (int i = 0; i < array.Length; i++)
				{
					array[i].WakeUp();
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics)]
	[Tooltip("Forces a Game Object's Rigid Body to wake up.")]
	public class WakeUp : ComponentAction<Rigidbody>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody))]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			DoWakeUp();
			Finish();
		}

		private void DoWakeUp()
		{
			GameObject go = ((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			if (UpdateCache(go))
			{
				base.rigidbody.WakeUp();
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Adds a 2d force to a Game Object. Use Vector2 variable and/or Float variables for each axis.")]
	public class AddForce2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject to apply the force to.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Option for applying the force")]
		public ForceMode2D forceMode;

		[UIHint(UIHint.Variable)]
		[Tooltip("Optionally apply the force at a position on the object. This will also add some torque. The position is often returned from MousePick or GetCollision2dInfo actions.")]
		public FsmVector2 atPosition;

		[UIHint(UIHint.Variable)]
		[Tooltip("A Vector2 force to add. Optionally override any axis with the X, Y parameters.")]
		public FsmVector2 vector;

		[Tooltip("Force along the X axis. To leave unchanged, set to 'None'.")]
		public FsmFloat x;

		[Tooltip("Force along the Y axis. To leave unchanged, set to 'None'.")]
		public FsmFloat y;

		[Tooltip("A Vector3 force to add. z is ignored")]
		public FsmVector3 vector3;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			atPosition = new FsmVector2
			{
				UseVariable = true
			};
			forceMode = ForceMode2D.Force;
			vector = null;
			vector3 = new FsmVector3
			{
				UseVariable = true
			};
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoAddForce();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoAddForce();
		}

		private void DoAddForce()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				Vector2 force = (vector.IsNone ? new Vector2(x.Value, y.Value) : vector.Value);
				if (!vector3.IsNone)
				{
					force.x = vector3.Value.x;
					force.y = vector3.Value.y;
				}
				if (!x.IsNone)
				{
					force.x = x.Value;
				}
				if (!y.IsNone)
				{
					force.y = y.Value;
				}
				if (!atPosition.IsNone)
				{
					base.rigidbody2d.AddForceAtPosition(force, atPosition.Value, forceMode);
				}
				else
				{
					base.rigidbody2d.AddForce(force, forceMode);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Adds a relative 2d force to a Game Object. Use Vector2 variable and/or Float variables for each axis.")]
	public class AddRelativeForce2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject to apply the force to.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Option for applying the force")]
		public ForceMode2D forceMode;

		[UIHint(UIHint.Variable)]
		[Tooltip("A Vector2 force to add. Optionally override any axis with the X, Y parameters.")]
		public FsmVector2 vector;

		[Tooltip("Force along the X axis. To leave unchanged, set to 'None'.")]
		public FsmFloat x;

		[Tooltip("Force along the Y axis. To leave unchanged, set to 'None'.")]
		public FsmFloat y;

		[Tooltip("A Vector3 force to add. z is ignored")]
		public FsmVector3 vector3;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			forceMode = ForceMode2D.Force;
			vector = null;
			vector3 = new FsmVector3
			{
				UseVariable = true
			};
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoAddRelativeForce();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoAddRelativeForce();
		}

		private void DoAddRelativeForce()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				Vector2 relativeForce = (vector.IsNone ? new Vector2(x.Value, y.Value) : vector.Value);
				if (!vector3.IsNone)
				{
					relativeForce.x = vector3.Value.x;
					relativeForce.y = vector3.Value.y;
				}
				if (!x.IsNone)
				{
					relativeForce.x = x.Value;
				}
				if (!y.IsNone)
				{
					relativeForce.y = y.Value;
				}
				base.rigidbody2d.AddRelativeForce(relativeForce, forceMode);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Adds a 2d torque (rotational force) to a Game Object.")]
	public class AddTorque2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject to add torque to.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Option for applying the force")]
		public ForceMode2D forceMode;

		[Tooltip("Torque")]
		public FsmFloat torque;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		public override void OnPreprocess()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void Reset()
		{
			gameObject = null;
			torque = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoAddTorque();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoAddTorque();
		}

		private void DoAddTorque()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody2d.AddTorque(torque.Value, forceMode);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Detect collisions between Game Objects that have RigidBody2D/Collider2D components.")]
	public class Collision2dEvent : FsmStateAction
	{
		[Tooltip("The GameObject to detect collisions on.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The type of collision to detect.")]
		public Collision2DType collision;

		[UIHint(UIHint.TagMenu)]
		[Tooltip("Filter by Tag.")]
		public FsmString collideTag;

		[Tooltip("Event to send if a collision is detected.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the GameObject that collided with the Owner of this FSM.")]
		public FsmGameObject storeCollider;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the force of the collision. NOTE: Use Get Collision 2D Info to get more info about the collision.")]
		public FsmFloat storeForce;

		private PlayMakerProxyBase cachedProxy;

		public override void Reset()
		{
			collision = Collision2DType.OnCollisionEnter2D;
			collideTag = "";
			sendEvent = null;
			storeCollider = null;
			storeForce = null;
		}

		public override void OnPreprocess()
		{
			if (gameObject == null)
			{
				gameObject = new FsmOwnerDefault();
			}
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				switch (collision)
				{
				case Collision2DType.OnCollisionEnter2D:
					base.Fsm.HandleCollisionEnter2D = true;
					break;
				case Collision2DType.OnCollisionStay2D:
					base.Fsm.HandleCollisionStay2D = true;
					break;
				case Collision2DType.OnCollisionExit2D:
					base.Fsm.HandleCollisionExit2D = true;
					break;
				case Collision2DType.OnParticleCollision:
					base.Fsm.HandleParticleCollision = true;
					break;
				}
			}
			else
			{
				GetProxyComponent();
			}
		}

		public override void OnEnter()
		{
			if (gameObject.OwnerOption != 0)
			{
				if (cachedProxy == null)
				{
					GetProxyComponent();
				}
				AddCallback();
				gameObject.GameObject.OnChange += UpdateCallback;
			}
		}

		public override void OnExit()
		{
			if (gameObject.OwnerOption != 0)
			{
				RemoveCallback();
				gameObject.GameObject.OnChange -= UpdateCallback;
			}
		}

		private void UpdateCallback()
		{
			RemoveCallback();
			GetProxyComponent();
			AddCallback();
		}

		private void GetProxyComponent()
		{
			cachedProxy = null;
			GameObject value = gameObject.GameObject.Value;
			if (!(value == null))
			{
				switch (collision)
				{
				case Collision2DType.OnCollisionEnter2D:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerCollisionEnter2D>(value);
					break;
				case Collision2DType.OnCollisionStay2D:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerCollisionStay2D>(value);
					break;
				case Collision2DType.OnCollisionExit2D:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerCollisionExit2D>(value);
					break;
				case Collision2DType.OnParticleCollision:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerParticleCollision>(value);
					break;
				}
			}
		}

		private void AddCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (collision)
				{
				case Collision2DType.OnCollisionEnter2D:
					cachedProxy.AddCollision2DEventCallback(CollisionEnter2D);
					break;
				case Collision2DType.OnCollisionStay2D:
					cachedProxy.AddCollision2DEventCallback(CollisionStay2D);
					break;
				case Collision2DType.OnCollisionExit2D:
					cachedProxy.AddCollision2DEventCallback(CollisionExit2D);
					break;
				case Collision2DType.OnParticleCollision:
					cachedProxy.AddParticleCollisionEventCallback(ParticleCollision);
					break;
				}
			}
		}

		private void RemoveCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (collision)
				{
				case Collision2DType.OnCollisionEnter2D:
					cachedProxy.RemoveCollision2DEventCallback(CollisionEnter2D);
					break;
				case Collision2DType.OnCollisionStay2D:
					cachedProxy.RemoveCollision2DEventCallback(CollisionStay2D);
					break;
				case Collision2DType.OnCollisionExit2D:
					cachedProxy.RemoveCollision2DEventCallback(CollisionExit2D);
					break;
				case Collision2DType.OnParticleCollision:
					cachedProxy.RemoveParticleCollisionEventCallback(ParticleCollision);
					break;
				}
			}
		}

		private void StoreCollisionInfo(Collision2D collisionInfo)
		{
			storeCollider.Value = collisionInfo.gameObject;
			storeForce.Value = collisionInfo.relativeVelocity.magnitude;
		}

		public override void DoCollisionEnter2D(Collision2D collisionInfo)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				CollisionEnter2D(collisionInfo);
			}
		}

		public override void DoCollisionStay2D(Collision2D collisionInfo)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				CollisionStay2D(collisionInfo);
			}
		}

		public override void DoCollisionExit2D(Collision2D collisionInfo)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				CollisionExit2D(collisionInfo);
			}
		}

		public override void DoParticleCollision(GameObject other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				ParticleCollision(other);
			}
		}

		private void CollisionEnter2D(Collision2D collisionInfo)
		{
			if (collision == Collision2DType.OnCollisionEnter2D && FsmStateAction.TagMatches(collideTag, collisionInfo))
			{
				StoreCollisionInfo(collisionInfo);
				base.Fsm.Event(sendEvent);
			}
		}

		private void CollisionStay2D(Collision2D collisionInfo)
		{
			if (collision == Collision2DType.OnCollisionStay2D && FsmStateAction.TagMatches(collideTag, collisionInfo))
			{
				StoreCollisionInfo(collisionInfo);
				base.Fsm.Event(sendEvent);
			}
		}

		private void CollisionExit2D(Collision2D collisionInfo)
		{
			if (collision == Collision2DType.OnCollisionExit2D && FsmStateAction.TagMatches(collideTag, collisionInfo))
			{
				StoreCollisionInfo(collisionInfo);
				base.Fsm.Event(sendEvent);
			}
		}

		private void ParticleCollision(GameObject other)
		{
			if (collision == Collision2DType.OnParticleCollision && FsmStateAction.TagMatches(collideTag, other))
			{
				if (storeCollider != null)
				{
					storeCollider.Value = other;
				}
				storeForce.Value = 0f;
				base.Fsm.Event(sendEvent);
			}
		}

		public override string ErrorCheck()
		{
			return ActionHelpers.CheckPhysics2dSetup(base.Fsm.GetOwnerDefaultTarget(gameObject));
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Gets info on the last collision 2D event and store in variables. See Unity and PlayMaker docs on Unity 2D physics.")]
	public class GetCollision2dInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the GameObject hit.")]
		public FsmGameObject gameObjectHit;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the relative velocity of the collision.")]
		public FsmVector3 relativeVelocity;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the relative speed of the collision. Useful for controlling reactions. E.g., selecting an appropriate sound fx.")]
		public FsmFloat relativeSpeed;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the world position of the collision contact. Useful for spawning effects etc.")]
		public FsmVector3 contactPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the collision normal vector. Useful for aligning spawned effects etc.")]
		public FsmVector3 contactNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("The number of separate shaped regions in the collider.")]
		public FsmInt shapeCount;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the name of the physics 2D material of the colliding GameObject. Useful for triggering different effects. Audio, particles...")]
		public FsmString physics2dMaterialName;

		public override void Reset()
		{
			gameObjectHit = null;
			relativeVelocity = null;
			relativeSpeed = null;
			contactPoint = null;
			contactNormal = null;
			shapeCount = null;
			physics2dMaterialName = null;
		}

		private void StoreCollisionInfo()
		{
			if (base.Fsm.Collision2DInfo != null)
			{
				gameObjectHit.Value = base.Fsm.Collision2DInfo.gameObject;
				relativeSpeed.Value = base.Fsm.Collision2DInfo.relativeVelocity.magnitude;
				relativeVelocity.Value = base.Fsm.Collision2DInfo.relativeVelocity;
				physics2dMaterialName.Value = ((base.Fsm.Collision2DInfo.collider.sharedMaterial != null) ? base.Fsm.Collision2DInfo.collider.sharedMaterial.name : "");
				shapeCount.Value = base.Fsm.Collision2DInfo.collider.shapeCount;
				if (base.Fsm.Collision2DInfo.contacts != null && base.Fsm.Collision2DInfo.contacts.Length != 0)
				{
					contactPoint.Value = base.Fsm.Collision2DInfo.contacts[0].point;
					contactNormal.Value = base.Fsm.Collision2DInfo.contacts[0].normal;
				}
			}
		}

		public override void OnEnter()
		{
			StoreCollisionInfo();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Gets info on the last joint break 2D event.")]
	public class GetJointBreak2dInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[ObjectType(typeof(Joint2D))]
		[Tooltip("Get the broken joint.")]
		public FsmObject brokenJoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the reaction force exerted by the broken joint. Unity 5.3+")]
		public FsmVector2 reactionForce;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the magnitude of the reaction force exerted by the broken joint. Unity 5.3+")]
		public FsmFloat reactionForceMagnitude;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the reaction torque exerted by the broken joint. Unity 5.3+")]
		public FsmFloat reactionTorque;

		public override void Reset()
		{
			brokenJoint = null;
			reactionForce = null;
			reactionTorque = null;
		}

		private void StoreInfo()
		{
			if (!(base.Fsm.BrokenJoint2D == null))
			{
				brokenJoint.Value = base.Fsm.BrokenJoint2D;
				reactionForce.Value = base.Fsm.BrokenJoint2D.reactionForce;
				reactionForceMagnitude.Value = base.Fsm.BrokenJoint2D.reactionForce.magnitude;
				reactionTorque.Value = base.Fsm.BrokenJoint2D.reactionTorque;
			}
		}

		public override void OnEnter()
		{
			StoreInfo();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Gets the Mass of a Game Object's Rigid Body 2D.")]
	public class GetMass2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with a Rigidbody2D attached.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the mass of gameObject.")]
		public FsmFloat storeResult;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
		}

		public override void OnEnter()
		{
			DoGetMass();
			Finish();
		}

		private void DoGetMass()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				storeResult.Value = base.rigidbody2d.mass;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Iterate through a list of all colliders detected by a LineCastThe colliders iterated are sorted in order of increasing Z coordinate. No iteration will take place if there are no colliders within the area.")]
	public class GetNextLineCast2d : FsmStateAction
	{
		[ActionSection("Setup")]
		[Tooltip("Start ray at game object position. \nOr use From Position parameter.")]
		public FsmOwnerDefault fromGameObject;

		[Tooltip("Start ray at a vector2 world position. \nOr use fromGameObject parameter. If both define, will add fromPosition to the fromGameObject position")]
		public FsmVector2 fromPosition;

		[Tooltip("End ray at game object position. \nOr use From Position parameter.")]
		public FsmGameObject toGameObject;

		[Tooltip("End ray at a vector2 world position. \nOr use fromGameObject parameter. If both define, will add toPosition to the ToGameObject position")]
		public FsmVector2 toPosition;

		[Tooltip("Only include objects with a Z coordinate (depth) greater than this value. leave to none for no effect")]
		public FsmInt minDepth;

		[Tooltip("Only include objects with a Z coordinate (depth) less than this value. leave to none")]
		public FsmInt maxDepth;

		[Tooltip("If you want to reset the iteration, raise this flag to true when you enter the state, it will indicate you want to start from the beginning again")]
		[UIHint(UIHint.Variable)]
		public FsmBool resetFlag;

		[ActionSection("Filter")]
		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Result")]
		[Tooltip("Store the number of colliders found for this overlap.")]
		[UIHint(UIHint.Variable)]
		public FsmInt collidersCount;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the next collider in a GameObject variable.")]
		public FsmGameObject storeNextCollider;

		[Tooltip("Get the 2d position of the next ray hit point and store it in a variable.")]
		public FsmVector2 storeNextHitPoint;

		[Tooltip("Get the 2d normal at the next hit point and store it in a variable.")]
		public FsmVector2 storeNextHitNormal;

		[Tooltip("Get the distance along the ray to the next hit point and store it in a variable.")]
		public FsmFloat storeNextHitDistance;

		[Tooltip("Event to send to get the next collider.")]
		public FsmEvent loopEvent;

		[Tooltip("Event to send when there are no more colliders to iterate.")]
		public FsmEvent finishedEvent;

		private RaycastHit2D[] hits;

		private int colliderCount;

		private int nextColliderIndex;

		public override void Reset()
		{
			fromGameObject = null;
			fromPosition = new FsmVector2
			{
				UseVariable = true
			};
			toGameObject = null;
			toPosition = new FsmVector2
			{
				UseVariable = true
			};
			minDepth = new FsmInt
			{
				UseVariable = true
			};
			maxDepth = new FsmInt
			{
				UseVariable = true
			};
			layerMask = new FsmInt[0];
			invertMask = false;
			resetFlag = null;
			collidersCount = null;
			storeNextCollider = null;
			storeNextHitPoint = null;
			storeNextHitNormal = null;
			storeNextHitDistance = null;
			loopEvent = null;
			finishedEvent = null;
		}

		public override void OnEnter()
		{
			if (hits == null || resetFlag.Value)
			{
				nextColliderIndex = 0;
				hits = GetLineCastAll();
				colliderCount = hits.Length;
				collidersCount.Value = colliderCount;
				resetFlag.Value = false;
			}
			DoGetNextCollider();
			Finish();
		}

		private void DoGetNextCollider()
		{
			if (nextColliderIndex >= colliderCount)
			{
				hits = null;
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			Fsm.RecordLastRaycastHit2DInfo(base.Fsm, hits[nextColliderIndex]);
			storeNextCollider.Value = hits[nextColliderIndex].collider.gameObject;
			storeNextHitPoint.Value = hits[nextColliderIndex].point;
			storeNextHitNormal.Value = hits[nextColliderIndex].normal;
			storeNextHitDistance.Value = hits[nextColliderIndex].fraction;
			if (nextColliderIndex >= colliderCount)
			{
				hits = new RaycastHit2D[0];
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			nextColliderIndex++;
			if (loopEvent != null)
			{
				base.Fsm.Event(loopEvent);
			}
		}

		private RaycastHit2D[] GetLineCastAll()
		{
			Vector2 value = fromPosition.Value;
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(fromGameObject);
			if (ownerDefaultTarget != null)
			{
				value.x += ownerDefaultTarget.transform.position.x;
				value.y += ownerDefaultTarget.transform.position.y;
			}
			Vector2 value2 = toPosition.Value;
			GameObject value3 = toGameObject.Value;
			if (value3 != null)
			{
				value2.x += value3.transform.position.x;
				value2.y += value3.transform.position.y;
			}
			if (minDepth.IsNone && maxDepth.IsNone)
			{
				return Physics2D.LinecastAll(value, value2, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			}
			float num = (minDepth.IsNone ? float.NegativeInfinity : ((float)minDepth.Value));
			float num2 = (maxDepth.IsNone ? float.PositiveInfinity : ((float)maxDepth.Value));
			return Physics2D.LinecastAll(value, value2, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value), num, num2);
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Iterate through a list of all colliders that fall within a rectangular area.The colliders iterated are sorted in order of increasing Z coordinate. No iteration will take place if there are no colliders within the area.")]
	public class GetNextOverlapArea2d : FsmStateAction
	{
		[ActionSection("Setup")]
		[Tooltip("First corner of the rectangle area using the game object position. \nOr use firstCornerPosition parameter.")]
		public FsmOwnerDefault firstCornerGameObject;

		[Tooltip("First Corner of the rectangle area as a world position. \nOr use FirstCornerGameObject parameter. If both define, will add firstCornerPosition to the FirstCornerGameObject position")]
		public FsmVector2 firstCornerPosition;

		[Tooltip("Second corner of the rectangle area using the game object position. \nOr use secondCornerPosition parameter.")]
		public FsmGameObject secondCornerGameObject;

		[Tooltip("Second Corner rectangle area as a world position. \nOr use SecondCornerGameObject parameter. If both define, will add secondCornerPosition to the SecondCornerGameObject position")]
		public FsmVector2 secondCornerPosition;

		[Tooltip("Only include objects with a Z coordinate (depth) greater than this value. leave to none for no effect")]
		public FsmInt minDepth;

		[Tooltip("Only include objects with a Z coordinate (depth) less than this value. leave to none")]
		public FsmInt maxDepth;

		[Tooltip("If you want to reset the iteration, raise this flag to true when you enter the state, it will indicate you want to start from the beginning again")]
		[UIHint(UIHint.Variable)]
		public FsmBool resetFlag;

		[ActionSection("Filter")]
		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Result")]
		[Tooltip("Store the number of colliders found for this overlap.")]
		[UIHint(UIHint.Variable)]
		public FsmInt collidersCount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the next collider in a GameObject variable.")]
		public FsmGameObject storeNextCollider;

		[Tooltip("Event to send to get the next collider.")]
		public FsmEvent loopEvent;

		[Tooltip("Event to send when there are no more colliders to iterate.")]
		public FsmEvent finishedEvent;

		private Collider2D[] colliders;

		private int colliderCount;

		private int nextColliderIndex;

		public override void Reset()
		{
			firstCornerGameObject = null;
			firstCornerPosition = new FsmVector2
			{
				UseVariable = true
			};
			secondCornerGameObject = null;
			secondCornerPosition = new FsmVector2
			{
				UseVariable = true
			};
			minDepth = new FsmInt
			{
				UseVariable = true
			};
			maxDepth = new FsmInt
			{
				UseVariable = true
			};
			layerMask = new FsmInt[0];
			invertMask = false;
			resetFlag = null;
			collidersCount = null;
			storeNextCollider = null;
			loopEvent = null;
			finishedEvent = null;
		}

		public override void OnEnter()
		{
			if (colliders == null || resetFlag.Value)
			{
				nextColliderIndex = 0;
				colliders = GetOverlapAreaAll();
				colliderCount = colliders.Length;
				collidersCount.Value = colliderCount;
				resetFlag.Value = false;
			}
			DoGetNextCollider();
			Finish();
		}

		private void DoGetNextCollider()
		{
			if (nextColliderIndex >= colliderCount)
			{
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			storeNextCollider.Value = colliders[nextColliderIndex].gameObject;
			if (nextColliderIndex >= colliderCount)
			{
				colliders = null;
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			nextColliderIndex++;
			if (loopEvent != null)
			{
				base.Fsm.Event(loopEvent);
			}
		}

		private Collider2D[] GetOverlapAreaAll()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(firstCornerGameObject);
			Vector2 value = firstCornerPosition.Value;
			if (ownerDefaultTarget != null)
			{
				value.x += ownerDefaultTarget.transform.position.x;
				value.y += ownerDefaultTarget.transform.position.y;
			}
			GameObject value2 = secondCornerGameObject.Value;
			Vector2 value3 = secondCornerPosition.Value;
			if (value2 != null)
			{
				value3.x += value2.transform.position.x;
				value3.y += value2.transform.position.y;
			}
			if (minDepth.IsNone && maxDepth.IsNone)
			{
				return Physics2D.OverlapAreaAll(value, value3, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			}
			float num = (minDepth.IsNone ? float.NegativeInfinity : ((float)minDepth.Value));
			float num2 = (maxDepth.IsNone ? float.PositiveInfinity : ((float)maxDepth.Value));
			return Physics2D.OverlapAreaAll(value, value3, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value), num, num2);
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Iterate through a list of all colliders that fall within a circular area.The colliders iterated are sorted in order of increasing Z coordinate. No iteration will take place if there are no colliders within the area.")]
	public class GetNextOverlapCircle2d : FsmStateAction
	{
		[ActionSection("Setup")]
		[Tooltip("Center of the circle area. \nOr use From Position parameter.")]
		public FsmOwnerDefault fromGameObject;

		[Tooltip("CEnter of the circle area as a world position. \nOr use fromGameObject parameter. If both define, will add fromPosition to the fromGameObject position")]
		public FsmVector2 fromPosition;

		[Tooltip("The circle radius")]
		public FsmFloat radius;

		[Tooltip("Only include objects with a Z coordinate (depth) greater than this value. leave to none for no effect")]
		public FsmInt minDepth;

		[Tooltip("Only include objects with a Z coordinate (depth) less than this value. leave to none")]
		public FsmInt maxDepth;

		[Tooltip("If you want to reset the iteration, raise this flag to true when you enter the state, it will indicate you want to start from the beginning again")]
		[UIHint(UIHint.Variable)]
		public FsmBool resetFlag;

		[ActionSection("Filter")]
		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Result")]
		[Tooltip("Store the number of colliders found for this overlap.")]
		[UIHint(UIHint.Variable)]
		public FsmInt collidersCount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the next collider in a GameObject variable.")]
		public FsmGameObject storeNextCollider;

		[Tooltip("Event to send to get the next collider.")]
		public FsmEvent loopEvent;

		[Tooltip("Event to send when there are no more colliders to iterate.")]
		public FsmEvent finishedEvent;

		private Collider2D[] colliders;

		private int colliderCount;

		private int nextColliderIndex;

		public override void Reset()
		{
			fromGameObject = null;
			fromPosition = new FsmVector2
			{
				UseVariable = true
			};
			radius = 10f;
			minDepth = new FsmInt
			{
				UseVariable = true
			};
			maxDepth = new FsmInt
			{
				UseVariable = true
			};
			layerMask = new FsmInt[0];
			invertMask = false;
			resetFlag = null;
			collidersCount = null;
			storeNextCollider = null;
			loopEvent = null;
			finishedEvent = null;
		}

		public override void OnEnter()
		{
			if (colliders == null || resetFlag.Value)
			{
				nextColliderIndex = 0;
				colliders = GetOverlapCircleAll();
				colliderCount = colliders.Length;
				collidersCount.Value = colliderCount;
				resetFlag.Value = false;
			}
			DoGetNextCollider();
			Finish();
		}

		private void DoGetNextCollider()
		{
			if (nextColliderIndex >= colliderCount)
			{
				nextColliderIndex = 0;
				colliders = null;
				base.Fsm.Event(finishedEvent);
				return;
			}
			storeNextCollider.Value = colliders[nextColliderIndex].gameObject;
			if (nextColliderIndex >= colliderCount)
			{
				colliders = null;
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			nextColliderIndex++;
			if (loopEvent != null)
			{
				base.Fsm.Event(loopEvent);
			}
		}

		private Collider2D[] GetOverlapCircleAll()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(fromGameObject);
			Vector2 value = fromPosition.Value;
			if (ownerDefaultTarget != null)
			{
				value.x += ownerDefaultTarget.transform.position.x;
				value.y += ownerDefaultTarget.transform.position.y;
			}
			if (minDepth.IsNone && maxDepth.IsNone)
			{
				return Physics2D.OverlapCircleAll(value, radius.Value, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			}
			float num = (minDepth.IsNone ? float.NegativeInfinity : ((float)minDepth.Value));
			float num2 = (maxDepth.IsNone ? float.PositiveInfinity : ((float)maxDepth.Value));
			return Physics2D.OverlapCircleAll(value, radius.Value, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value), num, num2);
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Iterate through a list of all colliders that overlap a point in space.The colliders iterated are sorted in order of increasing Z coordinate. No iteration will take place if there are no colliders overlap this point.")]
	public class GetNextOverlapPoint2d : FsmStateAction
	{
		[ActionSection("Setup")]
		[Tooltip("Point using the gameObject position. \nOr use From Position parameter.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Point as a world position. \nOr use gameObject parameter. If both define, will add position to the gameObject position")]
		public FsmVector2 position;

		[Tooltip("Only include objects with a Z coordinate (depth) greater than this value. leave to none for no effect")]
		public FsmInt minDepth;

		[Tooltip("Only include objects with a Z coordinate (depth) less than this value. leave to none")]
		public FsmInt maxDepth;

		[Tooltip("If you want to reset the iteration, raise this flag to true when you enter the state, it will indicate you want to start from the beginning again")]
		[UIHint(UIHint.Variable)]
		public FsmBool resetFlag;

		[ActionSection("Filter")]
		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Result")]
		[Tooltip("Store the number of colliders found for this overlap.")]
		[UIHint(UIHint.Variable)]
		public FsmInt collidersCount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the next collider in a GameObject variable.")]
		public FsmGameObject storeNextCollider;

		[Tooltip("Event to send to get the next collider.")]
		public FsmEvent loopEvent;

		[Tooltip("Event to send when there are no more colliders to iterate.")]
		public FsmEvent finishedEvent;

		private Collider2D[] colliders;

		private int colliderCount;

		private int nextColliderIndex;

		public override void Reset()
		{
			gameObject = null;
			position = new FsmVector2
			{
				UseVariable = true
			};
			minDepth = new FsmInt
			{
				UseVariable = true
			};
			maxDepth = new FsmInt
			{
				UseVariable = true
			};
			layerMask = new FsmInt[0];
			invertMask = false;
			resetFlag = null;
			collidersCount = null;
			storeNextCollider = null;
			loopEvent = null;
			finishedEvent = null;
		}

		public override void OnEnter()
		{
			if (colliders == null || resetFlag.Value)
			{
				nextColliderIndex = 0;
				colliders = GetOverlapPointAll();
				colliderCount = colliders.Length;
				collidersCount.Value = colliderCount;
				resetFlag.Value = false;
			}
			DoGetNextCollider();
			Finish();
		}

		private void DoGetNextCollider()
		{
			if (nextColliderIndex >= colliderCount)
			{
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			storeNextCollider.Value = colliders[nextColliderIndex].gameObject;
			if (nextColliderIndex >= colliderCount)
			{
				colliders = null;
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			nextColliderIndex++;
			if (loopEvent != null)
			{
				base.Fsm.Event(loopEvent);
			}
		}

		private Collider2D[] GetOverlapPointAll()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			Vector2 value = position.Value;
			if (ownerDefaultTarget != null)
			{
				value.x += ownerDefaultTarget.transform.position.x;
				value.y += ownerDefaultTarget.transform.position.y;
			}
			if (minDepth.IsNone && maxDepth.IsNone)
			{
				return Physics2D.OverlapPointAll(value, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			}
			float num = (minDepth.IsNone ? float.NegativeInfinity : ((float)minDepth.Value));
			float num2 = (maxDepth.IsNone ? float.PositiveInfinity : ((float)maxDepth.Value));
			return Physics2D.OverlapPointAll(value, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value), num, num2);
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Iterate through a list of all colliders detected by a RayCastThe colliders iterated are sorted in order of increasing Z coordinate. No iteration will take place if there are no colliders within the area.")]
	public class GetNextRayCast2d : FsmStateAction
	{
		[ActionSection("Setup")]
		[Tooltip("Start ray at game object position. \nOr use From Position parameter.")]
		public FsmOwnerDefault fromGameObject;

		[Tooltip("Start ray at a vector2 world position. \nOr use Game Object parameter.")]
		public FsmVector2 fromPosition;

		[Tooltip("A vector2 direction vector")]
		public FsmVector2 direction;

		[Tooltip("Cast the ray in world or local space. Note if no Game Object is specified, the direction is in world space.")]
		public Space space;

		[Tooltip("The length of the ray. Set to -1 for infinity.")]
		public FsmFloat distance;

		[Tooltip("Only include objects with a Z coordinate (depth) greater than this value. leave to none for no effect")]
		public FsmInt minDepth;

		[Tooltip("Only include objects with a Z coordinate (depth) less than this value. leave to none")]
		public FsmInt maxDepth;

		[Tooltip("If you want to reset the iteration, raise this flag to true when you enter the state, it will indicate you want to start from the beginning again")]
		[UIHint(UIHint.Variable)]
		public FsmBool resetFlag;

		[ActionSection("Filter")]
		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Result")]
		[Tooltip("Store the number of colliders found for this overlap.")]
		[UIHint(UIHint.Variable)]
		public FsmInt collidersCount;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the next collider in a GameObject variable.")]
		public FsmGameObject storeNextCollider;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the 2d position of the next ray hit point and store it in a variable.")]
		public FsmVector2 storeNextHitPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the 2d normal at the next hit point and store it in a variable.")]
		public FsmVector2 storeNextHitNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the distance along the ray to the next hit point and store it in a variable.")]
		public FsmFloat storeNextHitDistance;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the fraction along the ray to the hit point and store it in a variable. If the ray's direction vector is normalized then this value is simply the distance between the origin and the hit point. If the direction is not normalized then this distance is expressed as a 'fraction' (which could be greater than 1) of the vector's magnitude.")]
		public FsmFloat storeNextHitFraction;

		[Tooltip("Event to send to get the next collider.")]
		public FsmEvent loopEvent;

		[Tooltip("Event to send when there are no more colliders to iterate.")]
		public FsmEvent finishedEvent;

		private RaycastHit2D[] hits;

		private int colliderCount;

		private int nextColliderIndex;

		public override void Reset()
		{
			fromGameObject = null;
			fromPosition = new FsmVector2
			{
				UseVariable = true
			};
			direction = new FsmVector2
			{
				UseVariable = true
			};
			space = Space.Self;
			minDepth = new FsmInt
			{
				UseVariable = true
			};
			maxDepth = new FsmInt
			{
				UseVariable = true
			};
			layerMask = new FsmInt[0];
			invertMask = false;
			resetFlag = null;
			collidersCount = null;
			storeNextCollider = null;
			storeNextHitPoint = null;
			storeNextHitNormal = null;
			storeNextHitDistance = null;
			storeNextHitFraction = null;
			loopEvent = null;
			finishedEvent = null;
		}

		public override void OnEnter()
		{
			if (hits == null || resetFlag.Value)
			{
				nextColliderIndex = 0;
				hits = GetRayCastAll();
				colliderCount = hits.Length;
				collidersCount.Value = colliderCount;
				resetFlag.Value = false;
			}
			DoGetNextCollider();
			Finish();
		}

		private void DoGetNextCollider()
		{
			if (nextColliderIndex >= colliderCount)
			{
				hits = null;
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			Fsm.RecordLastRaycastHit2DInfo(base.Fsm, hits[nextColliderIndex]);
			storeNextCollider.Value = hits[nextColliderIndex].collider.gameObject;
			storeNextHitPoint.Value = hits[nextColliderIndex].point;
			storeNextHitNormal.Value = hits[nextColliderIndex].normal;
			storeNextHitDistance.Value = hits[nextColliderIndex].distance;
			storeNextHitFraction.Value = hits[nextColliderIndex].fraction;
			if (nextColliderIndex >= colliderCount)
			{
				hits = new RaycastHit2D[0];
				nextColliderIndex = 0;
				base.Fsm.Event(finishedEvent);
				return;
			}
			nextColliderIndex++;
			if (loopEvent != null)
			{
				base.Fsm.Event(loopEvent);
			}
		}

		private RaycastHit2D[] GetRayCastAll()
		{
			if (Math.Abs(distance.Value) < Mathf.Epsilon)
			{
				return new RaycastHit2D[0];
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(fromGameObject);
			Vector2 value = fromPosition.Value;
			if (ownerDefaultTarget != null)
			{
				value.x += ownerDefaultTarget.transform.position.x;
				value.y += ownerDefaultTarget.transform.position.y;
			}
			float num = float.PositiveInfinity;
			if (distance.Value > 0f)
			{
				num = distance.Value;
			}
			Vector2 normalized = direction.Value.normalized;
			if (ownerDefaultTarget != null && space == Space.Self)
			{
				Vector3 vector = ownerDefaultTarget.transform.TransformDirection(new Vector3(direction.Value.x, direction.Value.y, 0f));
				normalized.x = vector.x;
				normalized.y = vector.y;
			}
			if (minDepth.IsNone && maxDepth.IsNone)
			{
				return Physics2D.RaycastAll(value, normalized, num, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			}
			float num2 = (minDepth.IsNone ? float.NegativeInfinity : ((float)minDepth.Value));
			float num3 = (maxDepth.IsNone ? float.PositiveInfinity : ((float)maxDepth.Value));
			return Physics2D.RaycastAll(value, normalized, num, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value), num2, num3);
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Gets info on the last 2d Raycast or LineCast and store in variables.")]
	public class GetRayCastHit2dInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the GameObject hit by the last Raycast and store it in a variable.")]
		public FsmGameObject gameObjectHit;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the world position of the ray hit point and store it in a variable.")]
		[Title("Hit Point")]
		public FsmVector2 point;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the normal at the hit point and store it in a variable.")]
		public FsmVector3 normal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the distance along the ray to the hit point and store it in a variable.")]
		public FsmFloat distance;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObjectHit = null;
			point = null;
			normal = null;
			distance = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			StoreRaycastInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			StoreRaycastInfo();
		}

		private void StoreRaycastInfo()
		{
			RaycastHit2D lastRaycastHit2DInfo = Fsm.GetLastRaycastHit2DInfo(base.Fsm);
			if (lastRaycastHit2DInfo.collider != null)
			{
				gameObjectHit.Value = lastRaycastHit2DInfo.collider.gameObject;
				point.Value = lastRaycastHit2DInfo.point;
				normal.Value = lastRaycastHit2DInfo.normal;
				distance.Value = lastRaycastHit2DInfo.fraction;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Gets the 2d Speed of a Game Object and stores it in a Float Variable. NOTE: The Game Object must have a rigid body 2D.")]
	public class GetSpeed2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The speed, or in technical terms: velocity magnitude")]
		public FsmFloat storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetSpeed();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSpeed();
		}

		private void DoGetSpeed()
		{
			if (!storeResult.IsNone)
			{
				GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
				if (UpdateCache(ownerDefaultTarget))
				{
					storeResult.Value = base.rigidbody2d.velocity.magnitude;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Gets info on the last Trigger 2d event and store in variables.  See Unity and PlayMaker docs on Unity 2D physics.")]
	public class GetTrigger2dInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Get the GameObject hit.")]
		public FsmGameObject gameObjectHit;

		[UIHint(UIHint.Variable)]
		[Tooltip("The number of separate shaped regions in the collider.")]
		public FsmInt shapeCount;

		[UIHint(UIHint.Variable)]
		[Tooltip("Useful for triggering different effects. Audio, particles...")]
		public FsmString physics2dMaterialName;

		public override void Reset()
		{
			gameObjectHit = null;
			shapeCount = null;
			physics2dMaterialName = null;
		}

		private void StoreTriggerInfo()
		{
			if (!(base.Fsm.TriggerCollider2D == null))
			{
				gameObjectHit.Value = base.Fsm.TriggerCollider2D.gameObject;
				shapeCount.Value = base.Fsm.TriggerCollider2D.shapeCount;
				physics2dMaterialName.Value = ((base.Fsm.TriggerCollider2D.sharedMaterial != null) ? base.Fsm.TriggerCollider2D.sharedMaterial.name : "");
			}
		}

		public override void OnEnter()
		{
			StoreTriggerInfo();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Gets the 2d Velocity of a Game Object and stores it in a Vector2 Variable or each Axis in a Float Variable. NOTE: The Game Object must have a Rigid Body 2D.")]
	public class GetVelocity2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("The velocity")]
		public FsmVector2 vector;

		[UIHint(UIHint.Variable)]
		[Tooltip("The x value of the velocity")]
		public FsmFloat x;

		[UIHint(UIHint.Variable)]
		[Tooltip("The y value of the velocity")]
		public FsmFloat y;

		[Tooltip("The space reference to express the velocity")]
		public Space space;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = null;
			y = null;
			space = Space.World;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetVelocity();
		}

		private void DoGetVelocity()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				Vector2 vector = base.rigidbody2d.velocity;
				if (space == Space.Self)
				{
					vector = base.rigidbody2d.transform.InverseTransformDirection(vector);
				}
				this.vector.Value = vector;
				x.Value = vector.x;
				y.Value = vector.y;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Is the rigidbody2D constrained from rotating?Note: Prefer SetRigidBody2dConstraints when working in Unity 5")]
	public class IsFixedAngle2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Event sent if the Rigidbody2D does have fixed angle")]
		public FsmEvent trueEvent;

		[Tooltip("Event sent if the Rigidbody2D doesn't have fixed angle")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the fixedAngle flag")]
		public FsmBool store;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			store = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIsFixedAngle();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIsFixedAngle();
		}

		private void DoIsFixedAngle()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				bool flag = false;
				flag = (base.rigidbody2d.constraints & RigidbodyConstraints2D.FreezeRotation) != 0;
				store.Value = flag;
				base.Fsm.Event(flag ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Tests if a Game Object's Rigid Body 2D is Kinematic.")]
	public class IsKinematic2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("the GameObject with a Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Event Sent if Kinematic")]
		public FsmEvent trueEvent;

		[Tooltip("Event sent if not Kinematic")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the Kinematic state")]
		public FsmBool store;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			store = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIsKinematic();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIsKinematic();
		}

		private void DoIsKinematic()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				bool isKinematic = base.rigidbody2d.isKinematic;
				store.Value = isKinematic;
				base.Fsm.Event(isKinematic ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Tests if a Game Object's Rigidbody 2D is sleeping.")]
	public class IsSleeping2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Event sent if sleeping")]
		public FsmEvent trueEvent;

		[Tooltip("Event sent if not sleeping")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the value in a Boolean variable")]
		public FsmBool store;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			trueEvent = null;
			falseEvent = null;
			store = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoIsSleeping();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoIsSleeping();
		}

		private void DoIsSleeping()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				bool flag = base.rigidbody2d.IsSleeping();
				store.Value = flag;
				base.Fsm.Event(flag ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Casts a Ray against all Colliders in the scene.A linecast is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar raycast in that raycasting specifies the line using an origin and direction.Use GetRaycastHit2dInfo to get more detailed info.")]
	public class LineCast2d : FsmStateAction
	{
		[ActionSection("Setup")]
		[Tooltip("Start ray at game object position. \nOr use From Position parameter.")]
		public FsmOwnerDefault fromGameObject;

		[Tooltip("Start ray at a vector2 world position. \nOr use fromGameObject parameter. If both define, will add fromPosition to the fromGameObject position")]
		public FsmVector2 fromPosition;

		[Tooltip("End ray at game object position. \nOr use From Position parameter.")]
		public FsmGameObject toGameObject;

		[Tooltip("End ray at a vector2 world position. \nOr use fromGameObject parameter. If both define, will add toPosition to the ToGameObject position")]
		public FsmVector2 toPosition;

		[Tooltip("Only include objects with a Z coordinate (depth) greater than this value. leave to none for no effect")]
		public FsmInt minDepth;

		[Tooltip("Only include objects with a Z coordinate (depth) less than this value. leave to none")]
		public FsmInt maxDepth;

		[ActionSection("Result")]
		[Tooltip("Event to send if the ray hits an object.")]
		[UIHint(UIHint.Variable)]
		public FsmEvent hitEvent;

		[Tooltip("Set a bool variable to true if hit something, otherwise false.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeDidHit;

		[Tooltip("Store the game object hit in a variable.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeHitObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the 2d position of the ray hit point and store it in a variable.")]
		public FsmVector2 storeHitPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the 2d normal at the hit point and store it in a variable.")]
		public FsmVector2 storeHitNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the distance along the ray to the hit point and store it in a variable.")]
		public FsmFloat storeHitDistance;

		[ActionSection("Filter")]
		[Tooltip("Set how often to cast a ray. 0 = once, don't repeat; 1 = everyFrame; 2 = every other frame... \nSince raycasts can get expensive use the highest repeat interval you can get away with.")]
		public FsmInt repeatInterval;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Debug")]
		[Tooltip("The color to use for the debug line.")]
		public FsmColor debugColor;

		[Tooltip("Draw a debug line. Note: Check Gizmos in the Game View to see it in game.")]
		public FsmBool debug;

		private Transform _fromTrans;

		private Transform _toTrans;

		private int repeat;

		public override void Reset()
		{
			fromGameObject = null;
			fromPosition = new FsmVector2
			{
				UseVariable = true
			};
			toGameObject = null;
			toPosition = new FsmVector2
			{
				UseVariable = true
			};
			hitEvent = null;
			storeDidHit = null;
			storeHitObject = null;
			storeHitPoint = null;
			storeHitNormal = null;
			storeHitDistance = null;
			repeatInterval = 1;
			layerMask = new FsmInt[0];
			invertMask = false;
			debugColor = Color.yellow;
			debug = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(fromGameObject);
			if (ownerDefaultTarget != null)
			{
				_fromTrans = ownerDefaultTarget.transform;
			}
			GameObject value = toGameObject.Value;
			if (value != null)
			{
				_toTrans = value.transform;
			}
			DoRaycast();
			if (repeatInterval.Value == 0)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			repeat--;
			if (repeat == 0)
			{
				DoRaycast();
			}
		}

		private void DoRaycast()
		{
			repeat = repeatInterval.Value;
			Vector2 value = fromPosition.Value;
			if (_fromTrans != null)
			{
				value.x += _fromTrans.position.x;
				value.y += _fromTrans.position.y;
			}
			Vector2 value2 = toPosition.Value;
			if (_toTrans != null)
			{
				value2.x += _toTrans.position.x;
				value2.y += _toTrans.position.y;
			}
			RaycastHit2D info;
			if (minDepth.IsNone && maxDepth.IsNone)
			{
				info = Physics2D.Linecast(value, value2, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			}
			else
			{
				float num = (minDepth.IsNone ? float.NegativeInfinity : ((float)minDepth.Value));
				float num2 = (maxDepth.IsNone ? float.PositiveInfinity : ((float)maxDepth.Value));
				info = Physics2D.Linecast(value, value2, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value), num, num2);
			}
			Fsm.RecordLastRaycastHit2DInfo(base.Fsm, info);
			bool flag = info.collider != null;
			storeDidHit.Value = flag;
			if (flag)
			{
				storeHitObject.Value = info.collider.gameObject;
				storeHitPoint.Value = info.point;
				storeHitNormal.Value = info.normal;
				storeHitDistance.Value = info.fraction;
				base.Fsm.Event(hitEvent);
			}
			if (debug.Value)
			{
				Vector3 start = new Vector3(value.x, value.y, 0f);
				Vector3 end = new Vector3(value2.x, value2.y, 0f);
				UnityEngine.Debug.DrawLine(start, end, debugColor.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Rotates a 2d Game Object on it's z axis so its forward vector points at a 2d or 3d position.")]
	public class LookAt2d : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to rotate.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The 2d position to Look At.")]
		public FsmVector2 vector2Target;

		[Tooltip("The 3d position to Look At. If not set to none, will be added to the 2d target")]
		public FsmVector3 vector3Target;

		[Tooltip("Set the GameObject starting offset. In degrees. 0 if your object is facing right, 180 if facing left etc...")]
		public FsmFloat rotationOffset;

		[Title("Draw Debug Line")]
		[Tooltip("Draw a debug line from the GameObject to the Target.")]
		public FsmBool debug;

		[Tooltip("Color to use for the debug line.")]
		public FsmColor debugLineColor;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame = true;

		public override void Reset()
		{
			gameObject = null;
			vector2Target = null;
			vector3Target = new FsmVector3
			{
				UseVariable = true
			};
			debug = false;
			debugLineColor = Color.green;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoLookAt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoLookAt();
		}

		private void DoLookAt()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 vector = new Vector3(vector2Target.Value.x, vector2Target.Value.y, 0f);
				if (!vector3Target.IsNone)
				{
					vector += vector3Target.Value;
				}
				Vector3 vector2 = vector - ownerDefaultTarget.transform.position;
				vector2.Normalize();
				float num = Mathf.Atan2(vector2.y, vector2.x) * 57.29578f;
				ownerDefaultTarget.transform.rotation = Quaternion.Euler(0f, 0f, num - rotationOffset.Value);
				if (debug.Value)
				{
					UnityEngine.Debug.DrawLine(ownerDefaultTarget.transform.position, vector, debugLineColor.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Rotates a 2d Game Object on it's z axis so its forward vector points at a Target.")]
	public class LookAt2dGameObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to rotate.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The GameObject to Look At.")]
		public FsmGameObject targetObject;

		[Tooltip("Set the GameObject starting offset. In degrees. 0 if your object is facing right, 180 if facing left etc...")]
		public FsmFloat rotationOffset;

		[Title("Draw Debug Line")]
		[Tooltip("Draw a debug line from the GameObject to the Target.")]
		public FsmBool debug;

		[Tooltip("Color to use for the debug line.")]
		public FsmColor debugLineColor;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame = true;

		private GameObject go;

		private GameObject goTarget;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			debug = false;
			debugLineColor = Color.green;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoLookAt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoLookAt();
		}

		private void DoLookAt()
		{
			go = base.Fsm.GetOwnerDefaultTarget(gameObject);
			goTarget = targetObject.Value;
			if (!(go == null) && targetObject != null)
			{
				Vector3 vector = goTarget.transform.position - go.transform.position;
				vector.Normalize();
				float num = Mathf.Atan2(vector.y, vector.x) * 57.29578f;
				go.transform.rotation = Quaternion.Euler(0f, 0f, num - rotationOffset.Value);
				if (debug.Value)
				{
					UnityEngine.Debug.DrawLine(go.transform.position, goTarget.transform.position, debugLineColor.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Perform a Mouse Pick on a 2d scene and stores the results. Use Ray Distance to set how close the camera must be to pick the 2d object.")]
	public class MousePick2d : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store if a GameObject was picked in a Bool variable. True if a GameObject was picked, otherwise false.")]
		public FsmBool storeDidPickObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the picked GameObject in a variable.")]
		public FsmGameObject storeGameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the picked point in a variable.")]
		public FsmVector2 storePoint;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			storeDidPickObject = null;
			storeGameObject = null;
			storePoint = null;
			layerMask = new FsmInt[0];
			invertMask = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoMousePick2d();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMousePick2d();
		}

		private void DoMousePick2d()
		{
			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			bool flag = rayIntersection.collider != null;
			storeDidPickObject.Value = flag;
			if (flag)
			{
				storeGameObject.Value = rayIntersection.collider.gameObject;
				storePoint.Value = rayIntersection.point;
			}
			else
			{
				storeGameObject.Value = null;
				storePoint.Value = Vector3.zero;
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends Events based on mouse interactions with a 2d Game Object: MouseOver, MouseDown, MouseUp, MouseOff.")]
	public class MousePick2dEvent : FsmStateAction
	{
		[CheckForComponent(typeof(Collider2D))]
		[Tooltip("The GameObject with a Collider2D attached.")]
		public FsmOwnerDefault GameObject;

		[Tooltip("Event to send when the mouse is over the GameObject.")]
		public FsmEvent mouseOver;

		[Tooltip("Event to send when the mouse is pressed while over the GameObject.")]
		public FsmEvent mouseDown;

		[Tooltip("Event to send when the mouse is released while over the GameObject.")]
		public FsmEvent mouseUp;

		[Tooltip("Event to send when the mouse moves off the GameObject.")]
		public FsmEvent mouseOff;

		[Tooltip("Pick only from these layers.")]
		[UIHint(UIHint.Layer)]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			GameObject = null;
			mouseOver = null;
			mouseDown = null;
			mouseUp = null;
			mouseOff = null;
			layerMask = new FsmInt[0];
			invertMask = false;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoMousePickEvent();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMousePickEvent();
		}

		private void DoMousePickEvent()
		{
			if (DoRaycast())
			{
				if (mouseDown != null && Input.GetMouseButtonDown(0))
				{
					base.Fsm.Event(mouseDown);
				}
				if (mouseOver != null)
				{
					base.Fsm.Event(mouseOver);
				}
				if (mouseUp != null && Input.GetMouseButtonUp(0))
				{
					base.Fsm.Event(mouseUp);
				}
			}
			else if (mouseOff != null)
			{
				base.Fsm.Event(mouseOff);
			}
		}

		private bool DoRaycast()
		{
			GameObject gameObject = ((GameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : GameObject.GameObject.Value);
			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(Input.mousePosition), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			Fsm.RecordLastRaycastHit2DInfo(base.Fsm, rayIntersection);
			if (rayIntersection.transform != null && rayIntersection.transform.gameObject == gameObject)
			{
				return true;
			}
			return false;
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Casts a Ray against all Colliders in the scene. A raycast is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. Use GetRaycastHit2dInfo to get more detailed info.")]
	public class RayCast2d : FsmStateAction
	{
		[ActionSection("Setup")]
		[Tooltip("Start ray at game object position. \nOr use From Position parameter.")]
		public FsmOwnerDefault fromGameObject;

		[Tooltip("Start ray at a vector2 world position. \nOr use Game Object parameter.")]
		public FsmVector2 fromPosition;

		[Tooltip("A vector2 direction vector")]
		public FsmVector2 direction;

		[Tooltip("Cast the ray in world or local space. Note if no Game Object is specified, the direction is in world space.")]
		public Space space;

		[Tooltip("The length of the ray. Set to -1 for infinity.")]
		public FsmFloat distance;

		[Tooltip("Only include objects with a Z coordinate (depth) greater than this value. leave to none for no effect")]
		public FsmInt minDepth;

		[Tooltip("Only include objects with a Z coordinate (depth) less than this value. leave to none")]
		public FsmInt maxDepth;

		[ActionSection("Result")]
		[Tooltip("Event to send if the ray hits an object.")]
		[UIHint(UIHint.Variable)]
		public FsmEvent hitEvent;

		[Tooltip("Set a bool variable to true if hit something, otherwise false.")]
		[UIHint(UIHint.Variable)]
		public FsmBool storeDidHit;

		[Tooltip("Store the game object hit in a variable.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeHitObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the 2d position of the ray hit point and store it in a variable.")]
		public FsmVector2 storeHitPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the 2d normal at the hit point and store it in a variable.")]
		public FsmVector2 storeHitNormal;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the distance along the ray to the hit point and store it in a variable.")]
		public FsmFloat storeHitDistance;

		[UIHint(UIHint.Variable)]
		[Tooltip("Get the fraction along the ray to the hit point and store it in a variable. If the ray's direction vector is normalized then this value is simply the distance between the origin and the hit point. If the direction is not normalized then this distance is expressed as a 'fraction' (which could be greater than 1) of the vector's magnitude.")]
		public FsmFloat storeHitFraction;

		[ActionSection("Filter")]
		[Tooltip("Set how often to cast a ray. 0 = once, don't repeat; 1 = everyFrame; 2 = every other frame... \nSince raycasts can get expensive use the highest repeat interval you can get away with.")]
		public FsmInt repeatInterval;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[ActionSection("Debug")]
		[Tooltip("The color to use for the debug line.")]
		public FsmColor debugColor;

		[Tooltip("Draw a debug line. Note: Check Gizmos in the Game View to see it in game.")]
		public FsmBool debug;

		private Transform _transform;

		private int repeat;

		public override void Reset()
		{
			fromGameObject = null;
			fromPosition = new FsmVector2
			{
				UseVariable = true
			};
			direction = new FsmVector2
			{
				UseVariable = true
			};
			space = Space.Self;
			minDepth = new FsmInt
			{
				UseVariable = true
			};
			maxDepth = new FsmInt
			{
				UseVariable = true
			};
			distance = 100f;
			hitEvent = null;
			storeDidHit = null;
			storeHitObject = null;
			storeHitPoint = null;
			storeHitNormal = null;
			storeHitDistance = null;
			storeHitFraction = null;
			repeatInterval = 1;
			layerMask = new FsmInt[0];
			invertMask = false;
			debugColor = Color.yellow;
			debug = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(fromGameObject);
			if (ownerDefaultTarget != null)
			{
				_transform = ownerDefaultTarget.transform;
			}
			DoRaycast();
			if (repeatInterval.Value == 0)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			repeat--;
			if (repeat == 0)
			{
				DoRaycast();
			}
		}

		private void DoRaycast()
		{
			repeat = repeatInterval.Value;
			if (!(Math.Abs(distance.Value) < Mathf.Epsilon))
			{
				Vector2 value = fromPosition.Value;
				if (_transform != null)
				{
					value.x += _transform.position.x;
					value.y += _transform.position.y;
				}
				float a = float.PositiveInfinity;
				if (distance.Value > 0f)
				{
					a = distance.Value;
				}
				Vector2 normalized = direction.Value.normalized;
				if (_transform != null && space == Space.Self)
				{
					Vector3 vector = _transform.TransformDirection(new Vector3(direction.Value.x, direction.Value.y, 0f));
					normalized.x = vector.x;
					normalized.y = vector.y;
				}
				RaycastHit2D info;
				if (minDepth.IsNone && maxDepth.IsNone)
				{
					info = Physics2D.Raycast(value, normalized, a, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
				}
				else
				{
					float num = (minDepth.IsNone ? float.NegativeInfinity : ((float)minDepth.Value));
					float num2 = (maxDepth.IsNone ? float.PositiveInfinity : ((float)maxDepth.Value));
					info = Physics2D.Raycast(value, normalized, a, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value), num, num2);
				}
				Fsm.RecordLastRaycastHit2DInfo(base.Fsm, info);
				bool flag = info.collider != null;
				storeDidHit.Value = flag;
				if (flag)
				{
					storeHitObject.Value = info.collider.gameObject;
					storeHitPoint.Value = info.point;
					storeHitNormal.Value = info.normal;
					storeHitDistance.Value = info.distance;
					storeHitFraction.Value = info.fraction;
					base.Fsm.Event(hitEvent);
				}
				if (debug.Value)
				{
					float num3 = Mathf.Min(a, 1000f);
					Vector3 vector2 = new Vector3(value.x, value.y, 0f);
					Vector3 vector3 = new Vector3(normalized.x, normalized.y, 0f);
					Vector3 end = vector2 + vector3 * num3;
					UnityEngine.Debug.DrawLine(vector2, end, debugColor.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Perform a raycast into the 2d scene using screen coordinates and stores the results. Use Ray Distance to set how close the camera must be to pick the 2d object. NOTE: Uses the MainCamera!")]
	public class ScreenPick2d : FsmStateAction
	{
		[Tooltip("A Vector3 screen position. Commonly stored by other actions.")]
		public FsmVector3 screenVector;

		[Tooltip("X position on screen.")]
		public FsmFloat screenX;

		[Tooltip("Y position on screen.")]
		public FsmFloat screenY;

		[Tooltip("Are the supplied screen coordinates normalized (0-1), or in pixels.")]
		public FsmBool normalized;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store whether the Screen pick did pick a GameObject")]
		public FsmBool storeDidPickObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the picked GameObject")]
		public FsmGameObject storeGameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the picked position in world Space")]
		public FsmVector3 storePoint;

		[UIHint(UIHint.Layer)]
		[Tooltip("Pick only from these layers.")]
		public FsmInt[] layerMask;

		[Tooltip("Invert the mask, so you pick from all layers except those defined above.")]
		public FsmBool invertMask;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			screenVector = new FsmVector3
			{
				UseVariable = true
			};
			screenX = new FsmFloat
			{
				UseVariable = true
			};
			screenY = new FsmFloat
			{
				UseVariable = true
			};
			normalized = false;
			storeDidPickObject = null;
			storeGameObject = null;
			storePoint = null;
			layerMask = new FsmInt[0];
			invertMask = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoScreenPick();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoScreenPick();
		}

		private void DoScreenPick()
		{
			if (Camera.main == null)
			{
				LogError("No MainCamera defined!");
				Finish();
				return;
			}
			Vector3 pos = Vector3.zero;
			if (!screenVector.IsNone)
			{
				pos = screenVector.Value;
			}
			if (!screenX.IsNone)
			{
				pos.x = screenX.Value;
			}
			if (!screenY.IsNone)
			{
				pos.y = screenY.Value;
			}
			if (normalized.Value)
			{
				pos.x *= Screen.width;
				pos.y *= Screen.height;
			}
			RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(pos), float.PositiveInfinity, ActionHelpers.LayerArrayToLayerMask(layerMask, invertMask.Value));
			bool flag = rayIntersection.collider != null;
			storeDidPickObject.Value = flag;
			if (flag)
			{
				storeGameObject.Value = rayIntersection.collider.gameObject;
				storePoint.Value = rayIntersection.point;
			}
			else
			{
				storeGameObject.Value = null;
				storePoint.Value = Vector3.zero;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Set the isTrigger option of a Collider2D. Optionally set all collider2D found on the gameobject Target.")]
	public class SetCollider2dIsTrigger : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Collider2D))]
		[Tooltip("The GameObject with the Collider2D attached")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The flag value")]
		public FsmBool isTrigger;

		[Tooltip("Set all Colliders on the GameObject target")]
		public bool setAllColliders;

		public override void Reset()
		{
			gameObject = null;
			isTrigger = false;
			setAllColliders = false;
		}

		public override void OnEnter()
		{
			DoSetIsTrigger();
			Finish();
		}

		private void DoSetIsTrigger()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (setAllColliders)
			{
				Collider2D[] components = ownerDefaultTarget.GetComponents<Collider2D>();
				for (int i = 0; i < components.Length; i++)
				{
					components[i].isTrigger = isTrigger.Value;
				}
			}
			else if (ownerDefaultTarget.GetComponent<Collider2D>() != null)
			{
				ownerDefaultTarget.GetComponent<Collider2D>().isTrigger = isTrigger.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Sets the gravity vector, or individual axis.")]
	public class SetGravity2d : FsmStateAction
	{
		[Tooltip("Gravity as Vector2.")]
		public FsmVector2 vector;

		[Tooltip("Override the x value of the gravity")]
		public FsmFloat x;

		[Tooltip("Override the y value of the gravity")]
		public FsmFloat y;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetGravity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetGravity();
		}

		private void DoSetGravity()
		{
			Vector2 value = vector.Value;
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			Physics2D.gravity = value;
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Sets The degree to which this object is affected by gravity.  NOTE: Game object must have a rigidbody 2D.")]
	public class SetGravity2dScale : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with a Rigidbody 2d attached")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The gravity scale effect")]
		public FsmFloat gravityScale;

		public override void Reset()
		{
			gameObject = null;
			gravityScale = 1f;
		}

		public override void OnEnter()
		{
			DoSetGravityScale();
			Finish();
		}

		private void DoSetGravityScale()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody2d.gravityScale = gravityScale.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Sets the various properties of a HingeJoint2d component")]
	public class SetHingeJoint2dProperties : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The HingeJoint2d target")]
		[CheckForComponent(typeof(HingeJoint2D))]
		public FsmOwnerDefault gameObject;

		[ActionSection("Limits")]
		[Tooltip("Should limits be placed on the range of rotation?")]
		public FsmBool useLimits;

		[Tooltip("Lower angular limit of rotation.")]
		public FsmFloat min;

		[Tooltip("Upper angular limit of rotation")]
		public FsmFloat max;

		[ActionSection("Motor")]
		[Tooltip("Should a motor force be applied automatically to the Rigidbody2D?")]
		public FsmBool useMotor;

		[Tooltip("The desired speed for the Rigidbody2D to reach as it moves with the joint.")]
		public FsmFloat motorSpeed;

		[Tooltip("The maximum force that can be applied to the Rigidbody2D at the joint to attain the target speed.")]
		public FsmFloat maxMotorTorque;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		private HingeJoint2D _joint;

		private JointMotor2D _motor;

		private JointAngleLimits2D _limits;

		public override void Reset()
		{
			useLimits = new FsmBool
			{
				UseVariable = true
			};
			min = new FsmFloat
			{
				UseVariable = true
			};
			max = new FsmFloat
			{
				UseVariable = true
			};
			useMotor = new FsmBool
			{
				UseVariable = true
			};
			motorSpeed = new FsmFloat
			{
				UseVariable = true
			};
			maxMotorTorque = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_joint = ownerDefaultTarget.GetComponent<HingeJoint2D>();
				if (_joint != null)
				{
					_motor = _joint.motor;
					_limits = _joint.limits;
				}
			}
			SetProperties();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			SetProperties();
		}

		private void SetProperties()
		{
			if (!(_joint == null))
			{
				if (!useMotor.IsNone)
				{
					_joint.useMotor = useMotor.Value;
				}
				if (!motorSpeed.IsNone)
				{
					_motor.motorSpeed = motorSpeed.Value;
					_joint.motor = _motor;
				}
				if (!maxMotorTorque.IsNone)
				{
					_motor.maxMotorTorque = maxMotorTorque.Value;
					_joint.motor = _motor;
				}
				if (!useLimits.IsNone)
				{
					_joint.useLimits = useLimits.Value;
				}
				if (!min.IsNone)
				{
					_limits.min = min.Value;
					_joint.limits = _limits;
				}
				if (!max.IsNone)
				{
					_limits.max = max.Value;
					_joint.limits = _limits;
				}
			}
		}
	}
	[Obsolete("This action is obsolete; use Constraints instead.")]
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Controls whether the rigidbody 2D should be prevented from rotating")]
	public class SetIsFixedAngle2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The flag value")]
		public FsmBool isFixedAngle;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			isFixedAngle = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetIsFixedAngle();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetIsFixedAngle();
		}

		private void DoSetIsFixedAngle()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (isFixedAngle.Value)
				{
					base.rigidbody2d.constraints = base.rigidbody2d.constraints | RigidbodyConstraints2D.FreezeRotation;
				}
				else
				{
					base.rigidbody2d.constraints = base.rigidbody2d.constraints & ~RigidbodyConstraints2D.FreezeRotation;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Controls whether 2D physics affects the Game Object.")]
	public class SetIsKinematic2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The isKinematic value")]
		public FsmBool isKinematic;

		public override void Reset()
		{
			gameObject = null;
			isKinematic = false;
		}

		public override void OnEnter()
		{
			DoSetIsKinematic();
			Finish();
		}

		private void DoSetIsKinematic()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody2d.isKinematic = isKinematic.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Sets the Mass of a Game Object's Rigid Body 2D.")]
	public class SetMass2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HasFloatSlider(0.1f, 10f)]
		[Tooltip("The Mass")]
		public FsmFloat mass;

		public override void Reset()
		{
			gameObject = null;
			mass = 1f;
		}

		public override void OnEnter()
		{
			DoSetMass();
			Finish();
		}

		private void DoSetMass()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody2d.mass = mass.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Sets the 2d Velocity of a Game Object. To leave any axis unchanged, set variable to 'None'. NOTE: Game object must have a rigidbody 2D.")]
	public class SetVelocity2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with the Rigidbody2D attached")]
		public FsmOwnerDefault gameObject;

		[Tooltip("A Vector2 value for the velocity")]
		public FsmVector2 vector;

		[Tooltip("The y value of the velocity. Overrides 'Vector' x value if set")]
		public FsmFloat x;

		[Tooltip("The y value of the velocity. Overrides 'Vector' y value if set")]
		public FsmFloat y;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void Awake()
		{
			base.Fsm.HandleFixedUpdate = true;
		}

		public override void OnEnter()
		{
			DoSetVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			DoSetVelocity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetVelocity()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				Vector2 velocity = ((!vector.IsNone) ? vector.Value : base.rigidbody2d.velocity);
				if (!x.IsNone)
				{
					velocity.x = x.Value;
				}
				if (!y.IsNone)
				{
					velocity.y = y.Value;
				}
				base.rigidbody2d.velocity = velocity;
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Sets the various properties of a WheelJoint2d component")]
	public class SetWheelJoint2dProperties : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The WheelJoint2d target")]
		[CheckForComponent(typeof(WheelJoint2D))]
		public FsmOwnerDefault gameObject;

		[ActionSection("Motor")]
		[Tooltip("Should a motor force be applied automatically to the Rigidbody2D?")]
		public FsmBool useMotor;

		[Tooltip("The desired speed for the Rigidbody2D to reach as it moves with the joint.")]
		public FsmFloat motorSpeed;

		[Tooltip("The maximum force that can be applied to the Rigidbody2D at the joint to attain the target speed.")]
		public FsmFloat maxMotorTorque;

		[ActionSection("Suspension")]
		[Tooltip("The world angle along which the suspension will move. This provides 2D constrained motion similar to a SliderJoint2D. This is typically how suspension works in the real world.")]
		public FsmFloat angle;

		[Tooltip("The amount by which the suspension spring force is reduced in proportion to the movement speed.")]
		public FsmFloat dampingRatio;

		[Tooltip("The frequency at which the suspension spring oscillates.")]
		public FsmFloat frequency;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		private WheelJoint2D _wj2d;

		private JointMotor2D _motor;

		private JointSuspension2D _suspension;

		public override void Reset()
		{
			useMotor = new FsmBool
			{
				UseVariable = true
			};
			motorSpeed = new FsmFloat
			{
				UseVariable = true
			};
			maxMotorTorque = new FsmFloat
			{
				UseVariable = true
			};
			angle = new FsmFloat
			{
				UseVariable = true
			};
			dampingRatio = new FsmFloat
			{
				UseVariable = true
			};
			frequency = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_wj2d = ownerDefaultTarget.GetComponent<WheelJoint2D>();
				if (_wj2d != null)
				{
					_motor = _wj2d.motor;
					_suspension = _wj2d.suspension;
				}
			}
			SetProperties();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			SetProperties();
		}

		private void SetProperties()
		{
			if (!(_wj2d == null))
			{
				if (!useMotor.IsNone)
				{
					_wj2d.useMotor = useMotor.Value;
				}
				if (!motorSpeed.IsNone)
				{
					_motor.motorSpeed = motorSpeed.Value;
					_wj2d.motor = _motor;
				}
				if (!maxMotorTorque.IsNone)
				{
					_motor.maxMotorTorque = maxMotorTorque.Value;
					_wj2d.motor = _motor;
				}
				if (!angle.IsNone)
				{
					_suspension.angle = angle.Value;
					_wj2d.suspension = _suspension;
				}
				if (!dampingRatio.IsNone)
				{
					_suspension.dampingRatio = dampingRatio.Value;
					_wj2d.suspension = _suspension;
				}
				if (!frequency.IsNone)
				{
					_suspension.frequency = frequency.Value;
					_wj2d.suspension = _suspension;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Forces a Game Object's Rigid Body 2D to Sleep at least one frame.")]
	public class Sleep2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with a Rigidbody2d attached")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			DoSleep();
			Finish();
		}

		private void DoSleep()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody2d.Sleep();
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Smoothly Rotates a 2d Game Object so its right vector points at a Target. The target can be defined as a 2d Game Object or a 2d/3d world Position. If you specify both, then the position will be used as a local offset from the object's position.")]
	public class SmoothLookAt2d : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to rotate to face a target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("A target GameObject.")]
		public FsmGameObject targetObject;

		[Tooltip("A target position. If a Target Object is defined, this is used as a local offset.")]
		public FsmVector2 targetPosition2d;

		[Tooltip("A target position. If a Target Object is defined, this is used as a local offset.")]
		public FsmVector3 targetPosition;

		[Tooltip("Set the GameObject starting offset. In degrees. 0 if your object is facing right, 180 if facing left etc...")]
		public FsmFloat rotationOffset;

		[HasFloatSlider(0.5f, 15f)]
		[Tooltip("How fast the look at moves.")]
		public FsmFloat speed;

		[Tooltip("Draw a line in the Scene View to the look at position.")]
		public FsmBool debug;

		[Tooltip("If the angle to the target is less than this, send the Finish Event below. Measured in degrees.")]
		public FsmFloat finishTolerance;

		[Tooltip("Event to send if the angle to target is less than the Finish Tolerance.")]
		public FsmEvent finishEvent;

		private GameObject previousGo;

		private Quaternion lastRotation;

		private Quaternion desiredRotation;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			targetPosition2d = new FsmVector2
			{
				UseVariable = true
			};
			targetPosition = new FsmVector3
			{
				UseVariable = true
			};
			rotationOffset = 0f;
			debug = false;
			speed = 5f;
			finishTolerance = 1f;
			finishEvent = null;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnEnter()
		{
			previousGo = null;
		}

		public override void OnLateUpdate()
		{
			DoSmoothLookAt();
		}

		private void DoSmoothLookAt()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			GameObject value = targetObject.Value;
			if (previousGo != ownerDefaultTarget)
			{
				lastRotation = ownerDefaultTarget.transform.rotation;
				desiredRotation = lastRotation;
				previousGo = ownerDefaultTarget;
			}
			Vector3 vector = new Vector3(targetPosition2d.Value.x, targetPosition2d.Value.y, 0f);
			if (!targetPosition.IsNone)
			{
				vector += targetPosition.Value;
			}
			if (value != null)
			{
				vector = value.transform.position;
				Vector3 zero = Vector3.zero;
				if (!targetPosition.IsNone)
				{
					zero += targetPosition.Value;
				}
				if (!targetPosition2d.IsNone)
				{
					zero.x += targetPosition2d.Value.x;
					zero.y += targetPosition2d.Value.y;
				}
				if (!targetPosition2d.IsNone || !targetPosition.IsNone)
				{
					vector += value.transform.TransformPoint(targetPosition2d.Value);
				}
			}
			Vector3 vector2 = vector - ownerDefaultTarget.transform.position;
			vector2.Normalize();
			float num = Mathf.Atan2(vector2.y, vector2.x) * 57.29578f;
			desiredRotation = Quaternion.Euler(0f, 0f, num - rotationOffset.Value);
			lastRotation = Quaternion.Slerp(lastRotation, desiredRotation, speed.Value * Time.deltaTime);
			ownerDefaultTarget.transform.rotation = lastRotation;
			if (debug.Value)
			{
				UnityEngine.Debug.DrawLine(ownerDefaultTarget.transform.position, vector, Color.grey);
			}
			if (finishEvent != null && Mathf.Abs(Vector3.Angle(desiredRotation.eulerAngles, lastRotation.eulerAngles)) <= finishTolerance.Value)
			{
				base.Fsm.Event(finishEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Device)]
	[Tooltip("Sends events when a 2d object is touched. Optionally filter by a fingerID. NOTE: Uses the MainCamera!")]
	public class TouchObject2dEvent : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Collider2D))]
		[Tooltip("The Game Object to detect touches on.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Only detect touches that match this fingerID, or set to None.")]
		public FsmInt fingerId;

		[ActionSection("Events")]
		[Tooltip("Event to send on touch began.")]
		public FsmEvent touchBegan;

		[Tooltip("Event to send on touch moved.")]
		public FsmEvent touchMoved;

		[Tooltip("Event to send on stationary touch.")]
		public FsmEvent touchStationary;

		[Tooltip("Event to send on touch ended.")]
		public FsmEvent touchEnded;

		[Tooltip("Event to send on touch cancel.")]
		public FsmEvent touchCanceled;

		[ActionSection("Store Results")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the fingerId of the touch.")]
		public FsmInt storeFingerId;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the 2d position where the object was touched.")]
		public FsmVector2 storeHitPoint;

		public override void Reset()
		{
			gameObject = null;
			fingerId = new FsmInt
			{
				UseVariable = true
			};
			touchBegan = null;
			touchMoved = null;
			touchStationary = null;
			touchEnded = null;
			touchCanceled = null;
			storeFingerId = null;
			storeHitPoint = null;
		}

		public override void OnUpdate()
		{
			if (Camera.main == null)
			{
				LogError("No MainCamera defined!");
				Finish();
			}
			else
			{
				if (Input.touchCount <= 0)
				{
					return;
				}
				GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
				if (ownerDefaultTarget == null)
				{
					return;
				}
				Touch[] touches = Input.touches;
				for (int i = 0; i < touches.Length; i++)
				{
					Touch touch = touches[i];
					if (!fingerId.IsNone && touch.fingerId != fingerId.Value)
					{
						continue;
					}
					Vector2 position = touch.position;
					RaycastHit2D rayIntersection = Physics2D.GetRayIntersection(Camera.main.ScreenPointToRay(position), float.PositiveInfinity);
					Fsm.RecordLastRaycastHit2DInfo(base.Fsm, rayIntersection);
					if (rayIntersection.transform != null && rayIntersection.transform.gameObject == ownerDefaultTarget)
					{
						storeFingerId.Value = touch.fingerId;
						storeHitPoint.Value = rayIntersection.point;
						switch (touch.phase)
						{
						case TouchPhase.Began:
							base.Fsm.Event(touchBegan);
							return;
						case TouchPhase.Moved:
							base.Fsm.Event(touchMoved);
							return;
						case TouchPhase.Stationary:
							base.Fsm.Event(touchStationary);
							return;
						case TouchPhase.Ended:
							base.Fsm.Event(touchEnded);
							return;
						case TouchPhase.Canceled:
							base.Fsm.Event(touchCanceled);
							return;
						}
					}
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Detect 2D trigger collisions between Game Objects that have RigidBody2D/Collider2D components.")]
	public class Trigger2dEvent : FsmStateAction
	{
		[Tooltip("The GameObject to detect collisions on.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The type of trigger event to detect.")]
		public Trigger2DType trigger;

		[UIHint(UIHint.TagMenu)]
		[Tooltip("Filter by Tag.")]
		public FsmString collideTag;

		[Tooltip("Event to send if the trigger event is detected.")]
		public FsmEvent sendEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the GameObject that collided with the Owner of this FSM.")]
		public FsmGameObject storeCollider;

		private PlayMakerProxyBase cachedProxy;

		public override void Reset()
		{
			gameObject = null;
			trigger = Trigger2DType.OnTriggerEnter2D;
			collideTag = "";
			sendEvent = null;
			storeCollider = null;
		}

		public override void OnPreprocess()
		{
			if (gameObject == null)
			{
				gameObject = new FsmOwnerDefault();
			}
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				switch (trigger)
				{
				case Trigger2DType.OnTriggerEnter2D:
					base.Fsm.HandleTriggerEnter2D = true;
					break;
				case Trigger2DType.OnTriggerStay2D:
					base.Fsm.HandleTriggerStay2D = true;
					break;
				case Trigger2DType.OnTriggerExit2D:
					base.Fsm.HandleTriggerExit2D = true;
					break;
				}
			}
			else
			{
				GetProxyComponent();
			}
		}

		public override void OnEnter()
		{
			if (gameObject.OwnerOption != 0)
			{
				if (cachedProxy == null)
				{
					GetProxyComponent();
				}
				AddCallback();
				gameObject.GameObject.OnChange += UpdateCallback;
			}
		}

		public override void OnExit()
		{
			if (gameObject.OwnerOption != 0)
			{
				RemoveCallback();
				gameObject.GameObject.OnChange -= UpdateCallback;
			}
		}

		private void UpdateCallback()
		{
			RemoveCallback();
			GetProxyComponent();
			AddCallback();
		}

		private void GetProxyComponent()
		{
			cachedProxy = null;
			GameObject value = gameObject.GameObject.Value;
			if (!(value == null))
			{
				switch (trigger)
				{
				case Trigger2DType.OnTriggerEnter2D:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerTriggerEnter2D>(value);
					break;
				case Trigger2DType.OnTriggerStay2D:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerTriggerStay2D>(value);
					break;
				case Trigger2DType.OnTriggerExit2D:
					cachedProxy = PlayMakerFSM.GetEventHandlerComponent<PlayMakerTriggerExit2D>(value);
					break;
				}
			}
		}

		private void AddCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (trigger)
				{
				case Trigger2DType.OnTriggerEnter2D:
					cachedProxy.AddTrigger2DEventCallback(TriggerEnter2D);
					break;
				case Trigger2DType.OnTriggerStay2D:
					cachedProxy.AddTrigger2DEventCallback(TriggerStay2D);
					break;
				case Trigger2DType.OnTriggerExit2D:
					cachedProxy.AddTrigger2DEventCallback(TriggerExit2D);
					break;
				}
			}
		}

		private void RemoveCallback()
		{
			if (!(cachedProxy == null))
			{
				switch (trigger)
				{
				case Trigger2DType.OnTriggerEnter2D:
					cachedProxy.RemoveTrigger2DEventCallback(TriggerEnter2D);
					break;
				case Trigger2DType.OnTriggerStay2D:
					cachedProxy.RemoveTrigger2DEventCallback(TriggerStay2D);
					break;
				case Trigger2DType.OnTriggerExit2D:
					cachedProxy.RemoveTrigger2DEventCallback(TriggerExit2D);
					break;
				}
			}
		}

		private void StoreCollisionInfo(Collider2D collisionInfo)
		{
			storeCollider.Value = collisionInfo.gameObject;
		}

		public override void DoTriggerEnter2D(Collider2D other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				TriggerEnter2D(other);
			}
		}

		public override void DoTriggerStay2D(Collider2D other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				TriggerStay2D(other);
			}
		}

		public override void DoTriggerExit2D(Collider2D other)
		{
			if (gameObject.OwnerOption == OwnerDefaultOption.UseOwner)
			{
				TriggerExit2D(other);
			}
		}

		private void TriggerEnter2D(Collider2D other)
		{
			if (trigger == Trigger2DType.OnTriggerEnter2D && FsmStateAction.TagMatches(collideTag, other))
			{
				StoreCollisionInfo(other);
				base.Fsm.Event(sendEvent);
			}
		}

		private void TriggerStay2D(Collider2D other)
		{
			if (trigger == Trigger2DType.OnTriggerStay2D && FsmStateAction.TagMatches(collideTag, other))
			{
				StoreCollisionInfo(other);
				base.Fsm.Event(sendEvent);
			}
		}

		private void TriggerExit2D(Collider2D other)
		{
			if (trigger == Trigger2DType.OnTriggerExit2D && FsmStateAction.TagMatches(collideTag, other))
			{
				StoreCollisionInfo(other);
				base.Fsm.Event(sendEvent);
			}
		}

		public override string ErrorCheck()
		{
			return ActionHelpers.CheckPhysics2dSetup(base.Fsm.GetOwnerDefaultTarget(gameObject));
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Rigid bodies 2D start sleeping when they come to rest. This action wakes up all rigid bodies 2D in the scene. E.g., if you Set Gravity 2D and want objects at rest to respond.")]
	public class WakeAllRigidBodies2d : FsmStateAction
	{
		[Tooltip("Repeat every frame. Note: This would be very expensive!")]
		public bool everyFrame;

		public override void Reset()
		{
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoWakeAll();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoWakeAll();
		}

		private void DoWakeAll()
		{
			if (UnityEngine.Object.FindObjectsOfType(typeof(Rigidbody2D)) is Rigidbody2D[] array)
			{
				Rigidbody2D[] array2 = array;
				for (int i = 0; i < array2.Length; i++)
				{
					array2[i].WakeUp();
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Physics2D)]
	[Tooltip("Forces a Game Object's Rigid Body 2D to wake up.")]
	public class WakeUp2d : ComponentAction<Rigidbody2D>
	{
		[RequiredField]
		[CheckForComponent(typeof(Rigidbody2D))]
		[Tooltip("The GameObject with a Rigidbody2d attached")]
		public FsmOwnerDefault gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			DoWakeUp();
			Finish();
		}

		private void DoWakeUp()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				base.rigidbody2d.WakeUp();
			}
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Removes all keys and values from the preferences. Use with caution.")]
	public class PlayerPrefsDeleteAll : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnEnter()
		{
			PlayerPrefs.DeleteAll();
			Finish();
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Removes key and its corresponding value from the preferences.")]
	public class PlayerPrefsDeleteKey : FsmStateAction
	{
		public FsmString key;

		public override void Reset()
		{
			key = "";
		}

		public override void OnEnter()
		{
			if (!key.IsNone && !key.Value.Equals(""))
			{
				PlayerPrefs.DeleteKey(key.Value);
			}
			Finish();
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Returns the value corresponding to key in the preference file if it exists.")]
	public class PlayerPrefsGetFloat : FsmStateAction
	{
		[CompoundArray("Count", "Key", "Variable")]
		[Tooltip("Case sensitive key.")]
		public FsmString[] keys;

		[UIHint(UIHint.Variable)]
		public FsmFloat[] variables;

		public override void Reset()
		{
			keys = new FsmString[1];
			variables = new FsmFloat[1];
		}

		public override void OnEnter()
		{
			for (int i = 0; i < keys.Length; i++)
			{
				if (!keys[i].IsNone || !keys[i].Value.Equals(""))
				{
					variables[i].Value = PlayerPrefs.GetFloat(keys[i].Value, variables[i].IsNone ? 0f : variables[i].Value);
				}
			}
			Finish();
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Returns the value corresponding to key in the preference file if it exists.")]
	public class PlayerPrefsGetInt : FsmStateAction
	{
		[CompoundArray("Count", "Key", "Variable")]
		[Tooltip("Case sensitive key.")]
		public FsmString[] keys;

		[UIHint(UIHint.Variable)]
		public FsmInt[] variables;

		public override void Reset()
		{
			keys = new FsmString[1];
			variables = new FsmInt[1];
		}

		public override void OnEnter()
		{
			for (int i = 0; i < keys.Length; i++)
			{
				if (!keys[i].IsNone || !keys[i].Value.Equals(""))
				{
					variables[i].Value = PlayerPrefs.GetInt(keys[i].Value, (!variables[i].IsNone) ? variables[i].Value : 0);
				}
			}
			Finish();
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Returns the value corresponding to key in the preference file if it exists.")]
	public class PlayerPrefsGetString : FsmStateAction
	{
		[CompoundArray("Count", "Key", "Variable")]
		[Tooltip("Case sensitive key.")]
		public FsmString[] keys;

		[UIHint(UIHint.Variable)]
		public FsmString[] variables;

		public override void Reset()
		{
			keys = new FsmString[1];
			variables = new FsmString[1];
		}

		public override void OnEnter()
		{
			for (int i = 0; i < keys.Length; i++)
			{
				if (!keys[i].IsNone || !keys[i].Value.Equals(""))
				{
					variables[i].Value = PlayerPrefs.GetString(keys[i].Value, variables[i].IsNone ? "" : variables[i].Value);
				}
			}
			Finish();
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Returns true if key exists in the preferences.")]
	public class PlayerPrefsHasKey : FsmStateAction
	{
		[RequiredField]
		public FsmString key;

		[UIHint(UIHint.Variable)]
		[Title("Store Result")]
		public FsmBool variable;

		[Tooltip("Event to send if key exists.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if key does not exist.")]
		public FsmEvent falseEvent;

		public override void Reset()
		{
			key = "";
		}

		public override void OnEnter()
		{
			Finish();
			if (!key.IsNone && !key.Value.Equals(""))
			{
				variable.Value = PlayerPrefs.HasKey(key.Value);
			}
			base.Fsm.Event(variable.Value ? trueEvent : falseEvent);
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Sets the value of the preference identified by key.")]
	public class PlayerPrefsSetFloat : FsmStateAction
	{
		[CompoundArray("Count", "Key", "Value")]
		[Tooltip("Case sensitive key.")]
		public FsmString[] keys;

		public FsmFloat[] values;

		public override void Reset()
		{
			keys = new FsmString[1];
			values = new FsmFloat[1];
		}

		public override void OnEnter()
		{
			for (int i = 0; i < keys.Length; i++)
			{
				if (!keys[i].IsNone || !keys[i].Value.Equals(""))
				{
					PlayerPrefs.SetFloat(keys[i].Value, values[i].IsNone ? 0f : values[i].Value);
				}
			}
			Finish();
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Sets the value of the preference identified by key.")]
	public class PlayerPrefsSetInt : FsmStateAction
	{
		[CompoundArray("Count", "Key", "Value")]
		[Tooltip("Case sensitive key.")]
		public FsmString[] keys;

		public FsmInt[] values;

		public override void Reset()
		{
			keys = new FsmString[1];
			values = new FsmInt[1];
		}

		public override void OnEnter()
		{
			for (int i = 0; i < keys.Length; i++)
			{
				if (!keys[i].IsNone || !keys[i].Value.Equals(""))
				{
					PlayerPrefs.SetInt(keys[i].Value, (!values[i].IsNone) ? values[i].Value : 0);
				}
			}
			Finish();
		}
	}
	[ActionCategory("PlayerPrefs")]
	[Tooltip("Sets the value of the preference identified by key.")]
	public class PlayerPrefsSetString : FsmStateAction
	{
		[CompoundArray("Count", "Key", "Value")]
		[Tooltip("Case sensitive key.")]
		public FsmString[] keys;

		public FsmString[] values;

		public override void Reset()
		{
			keys = new FsmString[1];
			values = new FsmString[1];
		}

		public override void OnEnter()
		{
			for (int i = 0; i < keys.Length; i++)
			{
				if (!keys[i].IsNone || !keys[i].Value.Equals(""))
				{
					PlayerPrefs.SetString(keys[i].Value, values[i].IsNone ? "" : values[i].Value);
				}
			}
			Finish();
		}
	}
	[ActionCategory("Substance")]
	[Tooltip("Rebuilds all dirty textures. By default the rebuild is spread over multiple frames so it won't halt the game. Check Immediately to rebuild all textures in a single frame.")]
	public class RebuildTextures : FsmStateAction
	{
		[RequiredField]
		public FsmMaterial substanceMaterial;

		[RequiredField]
		public FsmBool immediately;

		public bool everyFrame;

		public override void Reset()
		{
			substanceMaterial = null;
			immediately = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoRebuildTextures();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoRebuildTextures();
		}

		private void DoRebuildTextures()
		{
		}
	}
	[ActionCategory("Substance")]
	[Tooltip("Set a named bool property in a Substance material. NOTE: Use Rebuild Textures after setting Substance properties.")]
	public class SetProceduralBoolean : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Substance Material.")]
		public FsmMaterial substanceMaterial;

		[RequiredField]
		[Tooltip("The named bool property in the material.")]
		public FsmString boolProperty;

		[RequiredField]
		[Tooltip("The value to set the property to.")]
		public FsmBool boolValue;

		[Tooltip("NOTE: Updating procedural materials every frame can be very slow!")]
		public bool everyFrame;

		public override void Reset()
		{
			substanceMaterial = null;
			boolProperty = "";
			boolValue = false;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetProceduralFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetProceduralFloat();
		}

		private void DoSetProceduralFloat()
		{
		}
	}
	[ActionCategory("Substance")]
	[Tooltip("Set a named color property in a Substance material. NOTE: Use Rebuild Textures after setting Substance properties.")]
	public class SetProceduralColor : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Substance Material.")]
		public FsmMaterial substanceMaterial;

		[RequiredField]
		[Tooltip("The named color property in the material.")]
		public FsmString colorProperty;

		[RequiredField]
		[Tooltip("The value to set the property to.")]
		public FsmColor colorValue;

		[Tooltip("NOTE: Updating procedural materials every frame can be very slow!")]
		public bool everyFrame;

		public override void Reset()
		{
			substanceMaterial = null;
			colorProperty = "";
			colorValue = Color.white;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetProceduralFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetProceduralFloat();
		}

		private void DoSetProceduralFloat()
		{
		}
	}
	[ActionCategory("Substance")]
	[Tooltip("Set a named float property in a Substance material. NOTE: Use Rebuild Textures after setting Substance properties.")]
	public class SetProceduralFloat : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Substance Material.")]
		public FsmMaterial substanceMaterial;

		[RequiredField]
		[Tooltip("The named float property in the material.")]
		public FsmString floatProperty;

		[RequiredField]
		[Tooltip("The value to set the property to.")]
		public FsmFloat floatValue;

		[Tooltip("NOTE: Updating procedural materials every frame can be very slow!")]
		public bool everyFrame;

		public override void Reset()
		{
			substanceMaterial = null;
			floatProperty = "";
			floatValue = 0f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetProceduralFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetProceduralFloat();
		}

		private void DoSetProceduralFloat()
		{
		}
	}
	[ActionCategory("Substance")]
	[Tooltip("Set a named Vector2 property in a Substance material. NOTE: Use Rebuild Textures after setting Substance properties.")]
	public class SetProceduralVector2 : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Substance Material.")]
		public FsmMaterial substanceMaterial;

		[RequiredField]
		[Tooltip("The named vector property in the material.")]
		public FsmString vector2Property;

		[RequiredField]
		[Tooltip("The Vector3 value to set the property to.\nNOTE: Use Set Procedural Vector2 for Vector3 values.")]
		public FsmVector2 vector2Value;

		[Tooltip("NOTE: Updating procedural materials every frame can be very slow!")]
		public bool everyFrame;

		public override void Reset()
		{
			substanceMaterial = null;
			vector2Property = null;
			vector2Value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetProceduralVector();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetProceduralVector();
		}

		private void DoSetProceduralVector()
		{
		}
	}
	[ActionCategory("Substance")]
	[Tooltip("Set a named Vector3 property in a Substance material. NOTE: Use Rebuild Textures after setting Substance properties.")]
	public class SetProceduralVector3 : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Substance Material.")]
		public FsmMaterial substanceMaterial;

		[RequiredField]
		[Tooltip("The named vector property in the material.")]
		public FsmString vector3Property;

		[RequiredField]
		[Tooltip("The value to set the property to.\nNOTE: Use Set Procedural Vector3 for Vector3 values.")]
		public FsmVector3 vector3Value;

		[Tooltip("NOTE: Updating procedural materials every frame can be very slow!")]
		public bool everyFrame;

		public override void Reset()
		{
			substanceMaterial = null;
			vector3Property = null;
			vector3Value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetProceduralVector();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetProceduralVector();
		}

		private void DoSetProceduralVector()
		{
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Gets a quaternion as euler angles.")]
	public class GetQuaternionEulerAngles : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("The rotation")]
		public FsmQuaternion quaternion;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The euler angles of the quaternion.")]
		public FsmVector3 eulerAngles;

		public override void Reset()
		{
			quaternion = null;
			eulerAngles = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			GetQuatEuler();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				GetQuatEuler();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				GetQuatEuler();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				GetQuatEuler();
			}
		}

		private void GetQuatEuler()
		{
			eulerAngles.Value = quaternion.Value.eulerAngles;
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Creates a rotation which rotates from fromDirection to toDirection. Usually you use this to rotate a transform so that one of its axes, e.g., the y-axis - follows a target direction toDirection in world space.")]
	public class GetQuaternionFromRotation : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("the 'from' direction")]
		public FsmVector3 fromDirection;

		[RequiredField]
		[Tooltip("the 'to' direction")]
		public FsmVector3 toDirection;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("the resulting quaternion")]
		public FsmQuaternion result;

		public override void Reset()
		{
			fromDirection = null;
			toDirection = null;
			result = null;
			everyFrame = false;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatFromRotation();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatFromRotation();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatFromRotation();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatFromRotation();
			}
		}

		private void DoQuatFromRotation()
		{
			result.Value = Quaternion.FromToRotation(fromDirection.Value, toDirection.Value);
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Get the quaternion from a quaternion multiplied by a quaternion.")]
	public class GetQuaternionMultipliedByQuaternion : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("The first quaternion to multiply")]
		public FsmQuaternion quaternionA;

		[RequiredField]
		[Tooltip("The second quaternion to multiply")]
		public FsmQuaternion quaternionB;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting quaternion")]
		public FsmQuaternion result;

		public override void Reset()
		{
			quaternionA = null;
			quaternionB = null;
			result = null;
			everyFrame = false;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatMult();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatMult();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatMult();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatMult();
			}
		}

		private void DoQuatMult()
		{
			result.Value = quaternionA.Value * quaternionB.Value;
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Get the vector3 from a quaternion multiplied by a vector.")]
	public class GetQuaternionMultipliedByVector : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("The quaternion to multiply")]
		public FsmQuaternion quaternion;

		[RequiredField]
		[Tooltip("The vector3 to multiply")]
		public FsmVector3 vector3;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting vector3")]
		public FsmVector3 result;

		public override void Reset()
		{
			quaternion = null;
			vector3 = null;
			result = null;
			everyFrame = false;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatMult();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatMult();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatMult();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatMult();
			}
		}

		private void DoQuatMult()
		{
			result.Value = quaternion.Value * vector3.Value;
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Creates a rotation which rotates angle degrees around axis.")]
	public class QuaternionAngleAxis : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("The angle.")]
		public FsmFloat angle;

		[RequiredField]
		[Tooltip("The rotation axis.")]
		public FsmVector3 axis;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the rotation of this quaternion variable.")]
		public FsmQuaternion result;

		public override void Reset()
		{
			angle = null;
			axis = null;
			result = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatAngleAxis();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatAngleAxis();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatAngleAxis();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatAngleAxis();
			}
		}

		private void DoQuatAngleAxis()
		{
			result.Value = Quaternion.AngleAxis(angle.Value, axis.Value);
		}
	}
	public abstract class QuaternionBaseAction : FsmStateAction
	{
		public enum everyFrameOptions
		{
			Update,
			FixedUpdate,
			LateUpdate
		}

		[Tooltip("Repeat every frame. Useful if any of the values are changing.")]
		public bool everyFrame;

		[Tooltip("Defines how to perform the action when 'every Frame' is enabled.")]
		public everyFrameOptions everyFrameOption;

		public override void Awake()
		{
			if (everyFrame)
			{
				switch (everyFrameOption)
				{
				case everyFrameOptions.FixedUpdate:
					base.Fsm.HandleFixedUpdate = true;
					break;
				case everyFrameOptions.LateUpdate:
					base.Fsm.HandleLateUpdate = true;
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Check if two quaternions are equals or not. Takes in account inversed representations of quaternions")]
	public class QuaternionCompare : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("First Quaternion")]
		public FsmQuaternion Quaternion1;

		[RequiredField]
		[Tooltip("Second Quaternion")]
		public FsmQuaternion Quaternion2;

		[Tooltip("true if Quaternions are equal")]
		public FsmBool equal;

		[Tooltip("Event sent if Quaternions are equal")]
		public FsmEvent equalEvent;

		[Tooltip("Event sent if Quaternions are not equal")]
		public FsmEvent notEqualEvent;

		public override void Reset()
		{
			Quaternion1 = new FsmQuaternion
			{
				UseVariable = true
			};
			Quaternion2 = new FsmQuaternion
			{
				UseVariable = true
			};
			equal = null;
			equalEvent = null;
			notEqualEvent = null;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatCompare();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatCompare();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatCompare();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatCompare();
			}
		}

		private void DoQuatCompare()
		{
			bool flag = Mathf.Abs(Quaternion.Dot(Quaternion1.Value, Quaternion2.Value)) > 0.999999f;
			equal.Value = flag;
			if (flag)
			{
				base.Fsm.Event(equalEvent);
			}
			else
			{
				base.Fsm.Event(notEqualEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order).")]
	public class QuaternionEuler : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("The Euler angles.")]
		public FsmVector3 eulerAngles;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the euler angles of this quaternion variable.")]
		public FsmQuaternion result;

		public override void Reset()
		{
			eulerAngles = null;
			result = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatEuler();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatEuler();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatEuler();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatEuler();
			}
		}

		private void DoQuatEuler()
		{
			result.Value = Quaternion.Euler(eulerAngles.Value);
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Inverse a quaternion")]
	public class QuaternionInverse : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("the rotation")]
		public FsmQuaternion rotation;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the inverse of the rotation variable.")]
		public FsmQuaternion result;

		public override void Reset()
		{
			rotation = null;
			result = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatInverse();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatInverse();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatInverse();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatInverse();
			}
		}

		private void DoQuatInverse()
		{
			result.Value = Quaternion.Inverse(rotation.Value);
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Interpolates between from and to by t and normalizes the result afterwards.")]
	public class QuaternionLerp : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("From Quaternion.")]
		public FsmQuaternion fromQuaternion;

		[RequiredField]
		[Tooltip("To Quaternion.")]
		public FsmQuaternion toQuaternion;

		[RequiredField]
		[Tooltip("Interpolate between fromQuaternion and toQuaternion by this amount. Value is clamped to 0-1 range. 0 = fromQuaternion; 1 = toQuaternion; 0.5 = half way between.")]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat amount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in this quaternion variable.")]
		public FsmQuaternion storeResult;

		public override void Reset()
		{
			fromQuaternion = new FsmQuaternion
			{
				UseVariable = true
			};
			toQuaternion = new FsmQuaternion
			{
				UseVariable = true
			};
			amount = 0.5f;
			storeResult = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatLerp();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatLerp();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatLerp();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatLerp();
			}
		}

		private void DoQuatLerp()
		{
			storeResult.Value = Quaternion.Lerp(fromQuaternion.Value, toQuaternion.Value, amount.Value);
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Creates a rotation that looks along forward with the head upwards along upwards.")]
	public class QuaternionLookRotation : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("the rotation direction")]
		public FsmVector3 direction;

		[Tooltip("The up direction")]
		public FsmVector3 upVector;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the inverse of the rotation variable.")]
		public FsmQuaternion result;

		public override void Reset()
		{
			direction = null;
			upVector = new FsmVector3
			{
				UseVariable = true
			};
			result = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatLookRotation();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatLookRotation();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatLookRotation();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatLookRotation();
			}
		}

		private void DoQuatLookRotation()
		{
			if (!upVector.IsNone)
			{
				result.Value = Quaternion.LookRotation(direction.Value, upVector.Value);
			}
			else
			{
				result.Value = Quaternion.LookRotation(direction.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Use a low pass filter to reduce the influence of sudden changes in a quaternion Variable.")]
	public class QuaternionLowPassFilter : QuaternionBaseAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("quaternion Variable to filter. Should generally come from some constantly updated input")]
		public FsmQuaternion quaternionVariable;

		[Tooltip("Determines how much influence new changes have. E.g., 0.1 keeps 10 percent of the unfiltered quaternion and 90 percent of the previously filtered value.")]
		public FsmFloat filteringFactor;

		private Quaternion filteredQuaternion;

		public override void Reset()
		{
			quaternionVariable = null;
			filteringFactor = 0.1f;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			filteredQuaternion = new Quaternion(quaternionVariable.Value.x, quaternionVariable.Value.y, quaternionVariable.Value.z, quaternionVariable.Value.w);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatLowPassFilter();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatLowPassFilter();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatLowPassFilter();
			}
		}

		private void DoQuatLowPassFilter()
		{
			filteredQuaternion.x = quaternionVariable.Value.x * filteringFactor.Value + filteredQuaternion.x * (1f - filteringFactor.Value);
			filteredQuaternion.y = quaternionVariable.Value.y * filteringFactor.Value + filteredQuaternion.y * (1f - filteringFactor.Value);
			filteredQuaternion.z = quaternionVariable.Value.z * filteringFactor.Value + filteredQuaternion.z * (1f - filteringFactor.Value);
			filteredQuaternion.w = quaternionVariable.Value.w * filteringFactor.Value + filteredQuaternion.w * (1f - filteringFactor.Value);
			quaternionVariable.Value = new Quaternion(filteredQuaternion.x, filteredQuaternion.y, filteredQuaternion.z, filteredQuaternion.w);
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Rotates a rotation from towards to. This is essentially the same as Quaternion.Slerp but instead the function will ensure that the angular speed never exceeds maxDegreesDelta. Negative values of maxDegreesDelta pushes the rotation away from to.")]
	public class QuaternionRotateTowards : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("From Quaternion.")]
		public FsmQuaternion fromQuaternion;

		[RequiredField]
		[Tooltip("To Quaternion.")]
		public FsmQuaternion toQuaternion;

		[RequiredField]
		[Tooltip("The angular speed never exceeds maxDegreesDelta. Negative values of maxDegreesDelta pushes the rotation away from to.")]
		public FsmFloat maxDegreesDelta;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in this quaternion variable.")]
		public FsmQuaternion storeResult;

		public override void Reset()
		{
			fromQuaternion = new FsmQuaternion
			{
				UseVariable = true
			};
			toQuaternion = new FsmQuaternion
			{
				UseVariable = true
			};
			maxDegreesDelta = 10f;
			storeResult = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatRotateTowards();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatRotateTowards();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatRotateTowards();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatRotateTowards();
			}
		}

		private void DoQuatRotateTowards()
		{
			storeResult.Value = Quaternion.RotateTowards(fromQuaternion.Value, toQuaternion.Value, maxDegreesDelta.Value);
		}
	}
	[ActionCategory(ActionCategory.Quaternion)]
	[Tooltip("Spherically interpolates between from and to by t.")]
	public class QuaternionSlerp : QuaternionBaseAction
	{
		[RequiredField]
		[Tooltip("From Quaternion.")]
		public FsmQuaternion fromQuaternion;

		[RequiredField]
		[Tooltip("To Quaternion.")]
		public FsmQuaternion toQuaternion;

		[RequiredField]
		[Tooltip("Interpolate between fromQuaternion and toQuaternion by this amount. Value is clamped to 0-1 range. 0 = fromQuaternion; 1 = toQuaternion; 0.5 = half way between.")]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat amount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in this quaternion variable.")]
		public FsmQuaternion storeResult;

		public override void Reset()
		{
			fromQuaternion = new FsmQuaternion
			{
				UseVariable = true
			};
			toQuaternion = new FsmQuaternion
			{
				UseVariable = true
			};
			amount = 0.1f;
			storeResult = null;
			everyFrame = true;
			everyFrameOption = everyFrameOptions.Update;
		}

		public override void OnEnter()
		{
			DoQuatSlerp();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (everyFrameOption == everyFrameOptions.Update)
			{
				DoQuatSlerp();
			}
		}

		public override void OnLateUpdate()
		{
			if (everyFrameOption == everyFrameOptions.LateUpdate)
			{
				DoQuatSlerp();
			}
		}

		public override void OnFixedUpdate()
		{
			if (everyFrameOption == everyFrameOptions.FixedUpdate)
			{
				DoQuatSlerp();
			}
		}

		private void DoQuatSlerp()
		{
			storeResult.Value = Quaternion.Slerp(fromQuaternion.Value, toQuaternion.Value, amount.Value);
		}
	}
	[ActionCategory(ActionCategory.Rect)]
	[Tooltip("Get the individual fields of a Rect Variable and store them in Float Variables.")]
	public class GetRectFields : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmRect rectVariable;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeX;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeY;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeWidth;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeHeight;

		public bool everyFrame;

		public override void Reset()
		{
			rectVariable = null;
			storeX = null;
			storeY = null;
			storeWidth = null;
			storeHeight = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetRectFields();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetRectFields();
		}

		private void DoGetRectFields()
		{
			if (!rectVariable.IsNone)
			{
				storeX.Value = rectVariable.Value.x;
				storeY.Value = rectVariable.Value.y;
				storeWidth.Value = rectVariable.Value.width;
				storeHeight.Value = rectVariable.Value.height;
			}
		}
	}
	[ActionCategory(ActionCategory.Rect)]
	[Tooltip("Tests if a point is inside a rectangle.")]
	public class RectContains : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Rectangle to test.")]
		public FsmRect rectangle;

		[Tooltip("Point to test.")]
		public FsmVector3 point;

		[Tooltip("Specify/override X value.")]
		public FsmFloat x;

		[Tooltip("Specify/override Y value.")]
		public FsmFloat y;

		[Tooltip("Event to send if the Point is inside the Rectangle.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if the Point is outside the Rectangle.")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			rectangle = new FsmRect
			{
				UseVariable = true
			};
			point = new FsmVector3
			{
				UseVariable = true
			};
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			storeResult = null;
			trueEvent = null;
			falseEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoRectContains();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoRectContains();
		}

		private void DoRectContains()
		{
			if (!rectangle.IsNone)
			{
				Vector3 value = point.Value;
				if (!x.IsNone)
				{
					value.x = x.Value;
				}
				if (!y.IsNone)
				{
					value.y = y.Value;
				}
				bool flag = rectangle.Value.Contains(value);
				storeResult.Value = flag;
				base.Fsm.Event(flag ? trueEvent : falseEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Rect)]
	[Tooltip("Tests if 2 Rects overlap.")]
	public class RectOverlaps : FsmStateAction
	{
		[RequiredField]
		[Tooltip("First Rectangle.")]
		public FsmRect rect1;

		[RequiredField]
		[Tooltip("Second Rectangle.")]
		public FsmRect rect2;

		[Tooltip("Event to send if the Rects overlap.")]
		public FsmEvent trueEvent;

		[Tooltip("Event to send if the Rects do not overlap.")]
		public FsmEvent falseEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in a variable.")]
		public FsmBool storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			rect1 = new FsmRect
			{
				UseVariable = true
			};
			rect2 = new FsmRect
			{
				UseVariable = true
			};
			storeResult = null;
			trueEvent = null;
			falseEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoRectOverlap();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoRectOverlap();
		}

		private void DoRectOverlap()
		{
			if (!rect1.IsNone && !rect2.IsNone)
			{
				bool flag = Intersect(rect1.Value, rect2.Value);
				storeResult.Value = flag;
				base.Fsm.Event(flag ? trueEvent : falseEvent);
			}
		}

		public static bool Intersect(Rect a, Rect b)
		{
			FlipNegative(ref a);
			FlipNegative(ref b);
			bool num = a.xMin < b.xMax;
			bool flag = a.xMax > b.xMin;
			bool flag2 = a.yMin < b.yMax;
			bool flag3 = a.yMax > b.yMin;
			return num && flag && flag2 && flag3;
		}

		public static void FlipNegative(ref Rect r)
		{
			if (r.width < 0f)
			{
				r.x -= (r.width *= -1f);
			}
			if (r.height < 0f)
			{
				r.y -= (r.height *= -1f);
			}
		}
	}
	[ActionCategory(ActionCategory.Rect)]
	[Tooltip("Sets the individual fields of a Rect Variable. To leave any field unchanged, set variable to 'None'.")]
	public class SetRectFields : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmRect rectVariable;

		public FsmFloat x;

		public FsmFloat y;

		public FsmFloat width;

		public FsmFloat height;

		public bool everyFrame;

		public override void Reset()
		{
			rectVariable = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			width = new FsmFloat
			{
				UseVariable = true
			};
			height = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetRectFields();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetRectFields();
		}

		private void DoSetRectFields()
		{
			if (!rectVariable.IsNone)
			{
				Rect value = rectVariable.Value;
				if (!x.IsNone)
				{
					value.x = x.Value;
				}
				if (!y.IsNone)
				{
					value.y = y.Value;
				}
				if (!width.IsNone)
				{
					value.width = width.Value;
				}
				if (!height.IsNone)
				{
					value.height = height.Value;
				}
				rectVariable.Value = value;
			}
		}
	}
	[ActionCategory(ActionCategory.Rect)]
	[Tooltip("Sets the value of a Rect Variable.")]
	public class SetRectValue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmRect rectVariable;

		[RequiredField]
		public FsmRect rectValue;

		public bool everyFrame;

		public override void Reset()
		{
			rectVariable = null;
			rectValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			rectVariable.Value = rectValue.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			rectVariable.Value = rectValue.Value;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Check if a RectTransform contains the screen point as seen from the given camera.")]
	public class RectTransformContainsScreenPoint : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The screenPoint as a Vector2. Leave to none if you want to use the Vector3 alternative")]
		public FsmVector2 screenPointVector2;

		[Tooltip("The screenPoint as a Vector3. Leave to none if you want to use the Vector2 alternative")]
		public FsmVector3 orScreenPointVector3;

		[Tooltip("Define if screenPoint are expressed as normalized screen coordinates (0-1). Otherwise coordinates are in pixels.")]
		public bool normalizedScreenPoint;

		[Tooltip("The Camera. For a RectTransform in a Canvas set to Screen Space - Overlay mode, the cam parameter should be set to null explicitly (default).\nLeave to none and the camera will be the one from EventSystem.current.camera")]
		[CheckForComponent(typeof(Camera))]
		public FsmGameObject camera;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		[ActionSection("Result")]
		[Tooltip("Store the result.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isContained;

		[Tooltip("Event sent if screenPoint is contained in RectTransform.")]
		public FsmEvent isContainedEvent;

		[Tooltip("Event sent if screenPoint is NOT contained in RectTransform.")]
		public FsmEvent isNotContainedEvent;

		private RectTransform _rt;

		private Camera _camera;

		public override void Reset()
		{
			gameObject = null;
			screenPointVector2 = null;
			orScreenPointVector3 = new FsmVector3
			{
				UseVariable = true
			};
			normalizedScreenPoint = false;
			camera = null;
			everyFrame = false;
			isContained = null;
			isContainedEvent = null;
			isNotContainedEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			if (!camera.IsNone)
			{
				_camera = camera.Value.GetComponent<Camera>();
			}
			else
			{
				_camera = EventSystem.current.GetComponent<Camera>();
			}
			DoCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCheck();
		}

		private void DoCheck()
		{
			if (_rt == null)
			{
				return;
			}
			Vector2 value = screenPointVector2.Value;
			if (!orScreenPointVector3.IsNone)
			{
				value.x = orScreenPointVector3.Value.x;
				value.y = orScreenPointVector3.Value.y;
			}
			if (normalizedScreenPoint)
			{
				value.x *= Screen.width;
				value.y *= Screen.height;
			}
			bool flag = RectTransformUtility.RectangleContainsScreenPoint(_rt, value, _camera);
			if (!isContained.IsNone)
			{
				isContained.Value = flag;
			}
			if (flag)
			{
				if (isContainedEvent != null)
				{
					base.Fsm.Event(isContainedEvent);
				}
			}
			else if (isNotContainedEvent != null)
			{
				base.Fsm.Event(isNotContainedEvent);
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Flips the horizontal and vertical axes of the RectTransform size and alignment, and optionally its children as well.")]
	public class RectTransformFlipLayoutAxis : FsmStateAction
	{
		public enum RectTransformFlipOptions
		{
			Horizontal,
			Vertical,
			Both
		}

		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The axis to flip")]
		public RectTransformFlipOptions axis;

		[Tooltip("Flips around the pivot if true. Flips within the parent rect if false.")]
		public FsmBool keepPositioning;

		[Tooltip("Flip the children as well?")]
		public FsmBool recursive;

		public override void Reset()
		{
			gameObject = null;
			axis = RectTransformFlipOptions.Both;
			keepPositioning = null;
			recursive = null;
		}

		public override void OnEnter()
		{
			DoFlip();
			Finish();
		}

		private void DoFlip()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget != null))
			{
				return;
			}
			RectTransform component = ownerDefaultTarget.GetComponent<RectTransform>();
			if (component != null)
			{
				if (axis == RectTransformFlipOptions.Both)
				{
					RectTransformUtility.FlipLayoutAxes(component, keepPositioning.Value, recursive.Value);
				}
				else if (axis == RectTransformFlipOptions.Horizontal)
				{
					RectTransformUtility.FlipLayoutOnAxis(component, 0, keepPositioning.Value, recursive.Value);
				}
				else if (axis == RectTransformFlipOptions.Vertical)
				{
					RectTransformUtility.FlipLayoutOnAxis(component, 1, keepPositioning.Value, recursive.Value);
				}
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the normalized position in the parent RectTransform that the upper right corner is anchored to.")]
	public class RectTransformGetAnchorMax : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The anchorMax")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 anchorMax;

		[Tooltip("The x component of the anchorMax")]
		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[Tooltip("The y component of the anchorMax")]
		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			anchorMax = null;
			x = null;
			y = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!anchorMax.IsNone)
			{
				anchorMax.Value = _rt.anchorMax;
			}
			if (!x.IsNone)
			{
				x.Value = _rt.anchorMax.x;
			}
			if (!y.IsNone)
			{
				y.Value = _rt.anchorMax.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the normalized position in the parent RectTransform that the lower left corner is anchored to.")]
	public class RectTransformGetAnchorMin : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The anchorMin")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 anchorMin;

		[Tooltip("The x component of the anchorMin")]
		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[Tooltip("The y component of the anchorMin")]
		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			anchorMin = null;
			x = null;
			y = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!anchorMin.IsNone)
			{
				anchorMin.Value = _rt.anchorMin;
			}
			if (!x.IsNone)
			{
				x.Value = _rt.anchorMin.x;
			}
			if (!y.IsNone)
			{
				y.Value = _rt.anchorMin.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The normalized position in the parent RectTransform that the upper right corner is anchored to. This is relative screen space, values ranges from 0 to 1")]
	public class RectTransformGetAnchorMinAndMax : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 anchor max. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 anchorMax;

		[Tooltip("The Vector2 anchor min. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 anchorMin;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMax x value if set. Set to none for no effect")]
		public FsmFloat xMax;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMax x value if set. Set to none for no effect")]
		public FsmFloat yMax;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMin x value if set. Set to none for no effect")]
		public FsmFloat xMin;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMin x value if set. Set to none for no effect")]
		public FsmFloat yMin;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			anchorMax = null;
			anchorMin = null;
			xMax = null;
			yMax = null;
			xMin = null;
			yMin = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!anchorMax.IsNone)
			{
				anchorMax.Value = _rt.anchorMax;
			}
			if (!anchorMin.IsNone)
			{
				anchorMin.Value = _rt.anchorMax;
			}
			if (!xMax.IsNone)
			{
				xMax.Value = _rt.anchorMax.x;
			}
			if (!yMax.IsNone)
			{
				yMax.Value = _rt.anchorMax.y;
			}
			if (!xMin.IsNone)
			{
				xMin.Value = _rt.anchorMin.x;
			}
			if (!yMin.IsNone)
			{
				yMin.Value = _rt.anchorMin.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the position of the pivot of this RectTransform relative to the anchor reference point.")]
	public class RectTransformGetAnchoredPosition : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The anchored Position")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 position;

		[Tooltip("The x component of the anchored Position")]
		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[Tooltip("The y component of the anchored Position")]
		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			position = null;
			x = null;
			y = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!position.IsNone)
			{
				position.Value = _rt.anchoredPosition;
			}
			if (!x.IsNone)
			{
				x.Value = _rt.anchoredPosition.x;
			}
			if (!y.IsNone)
			{
				y.Value = _rt.anchoredPosition.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the Local position of this RectTransform. This is Screen Space values using the anchoring as reference, so 0,0 is the center of the screen if the anchor is te center of the screen.")]
	public class RectTransformGetLocalPosition : BaseUpdateAction
	{
		public enum LocalPositionReference
		{
			Anchor,
			CenterPosition
		}

		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		public LocalPositionReference reference;

		[Tooltip("The position")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 position;

		[Tooltip("The position in a Vector 2d ")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 position2d;

		[Tooltip("The x component of the Position")]
		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[Tooltip("The y component of the Position")]
		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		[Tooltip("The z component of the Position")]
		[UIHint(UIHint.Variable)]
		public FsmFloat z;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			reference = LocalPositionReference.Anchor;
			position = null;
			position2d = null;
			x = null;
			y = null;
			z = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!(_rt == null))
			{
				Vector3 localPosition = _rt.localPosition;
				if (reference == LocalPositionReference.CenterPosition)
				{
					localPosition.x += _rt.rect.center.x;
					localPosition.y += _rt.rect.center.y;
				}
				if (!position.IsNone)
				{
					position.Value = localPosition;
				}
				if (!position2d.IsNone)
				{
					position2d.Value = new Vector2(localPosition.x, localPosition.y);
				}
				if (!x.IsNone)
				{
					x.Value = localPosition.x;
				}
				if (!y.IsNone)
				{
					y.Value = localPosition.y;
				}
				if (!z.IsNone)
				{
					z.Value = localPosition.z;
				}
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Gets the local rotation of this RectTransform.")]
	public class RectTransformGetLocalRotation : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The rotation")]
		public FsmVector3 rotation;

		[Tooltip("The x component of the rotation")]
		public FsmFloat x;

		[Tooltip("The y component of the rotation")]
		public FsmFloat y;

		[Tooltip("The z component of the rotation")]
		public FsmFloat z;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			rotation = new FsmVector3
			{
				UseVariable = true
			};
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!(_rt == null))
			{
				if (!rotation.IsNone)
				{
					rotation.Value = _rt.eulerAngles;
				}
				if (!x.IsNone)
				{
					x.Value = _rt.eulerAngles.x;
				}
				if (!y.IsNone)
				{
					y.Value = _rt.eulerAngles.y;
				}
				if (!z.IsNone)
				{
					z.Value = _rt.eulerAngles.z;
				}
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the offset of the upper right corner of the rectangle relative to the upper right anchor")]
	public class RectTransformGetOffsetMax : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The offsetMax")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 offsetMax;

		[Tooltip("The x component of the offsetMax")]
		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[Tooltip("The y component of the offsetMax")]
		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			offsetMax = null;
			x = null;
			y = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!offsetMax.IsNone)
			{
				offsetMax.Value = _rt.offsetMax;
			}
			if (!x.IsNone)
			{
				x.Value = _rt.offsetMax.x;
			}
			if (!y.IsNone)
			{
				y.Value = _rt.offsetMax.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the offset of the lower left corner of the rectangle relative to the lower left anchor")]
	public class RectTransformGetOffsetMin : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The offsetMin")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 offsetMin;

		[Tooltip("The x component of the offsetMin")]
		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[Tooltip("The y component of the offsetMin")]
		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			offsetMin = null;
			x = null;
			y = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!offsetMin.IsNone)
			{
				offsetMin.Value = _rt.offsetMin;
			}
			if (!x.IsNone)
			{
				x.Value = _rt.offsetMin.x;
			}
			if (!y.IsNone)
			{
				y.Value = _rt.offsetMin.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the normalized position in this RectTransform that it rotates around.")]
	public class RectTransformGetPivot : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The pivot")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 pivot;

		[Tooltip("The x component of the pivot")]
		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[Tooltip("The y component of the pivot")]
		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			pivot = null;
			x = null;
			y = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!pivot.IsNone)
			{
				pivot.Value = _rt.pivot;
			}
			if (!x.IsNone)
			{
				x.Value = _rt.pivot.x;
			}
			if (!y.IsNone)
			{
				y.Value = _rt.pivot.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The calculated rectangle in the local space of the Transform.")]
	public class RectTransformGetRect : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("The rect")]
		public FsmRect rect;

		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		[UIHint(UIHint.Variable)]
		public FsmFloat width;

		[UIHint(UIHint.Variable)]
		public FsmFloat height;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			rect = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			width = new FsmFloat
			{
				UseVariable = true
			};
			height = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!rect.IsNone)
			{
				rect.Value = _rt.rect;
			}
			if (!x.IsNone)
			{
				x.Value = _rt.rect.x;
			}
			if (!y.IsNone)
			{
				y.Value = _rt.rect.y;
			}
			if (!width.IsNone)
			{
				width.Value = _rt.rect.width;
			}
			if (!height.IsNone)
			{
				height.Value = _rt.rect.height;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Get the size of this RectTransform relative to the distances between the anchors. this is the 'Width' and 'Height' values in the RectTransform inspector.")]
	public class RectTransformGetSizeDelta : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The sizeDelta")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 sizeDelta;

		[Tooltip("The x component of the sizeDelta, the width.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat width;

		[Tooltip("The y component of the sizeDelta, the height")]
		[UIHint(UIHint.Variable)]
		public FsmFloat height;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			sizeDelta = null;
			width = null;
			height = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!sizeDelta.IsNone)
			{
				sizeDelta.Value = _rt.sizeDelta;
			}
			if (!width.IsNone)
			{
				width.Value = _rt.sizeDelta.x;
			}
			if (!height.IsNone)
			{
				height.Value = _rt.sizeDelta.y;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Convert a given point in screen space into a pixel correct point.")]
	public class RectTransformPixelAdjustPoint : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[CheckForComponent(typeof(Canvas))]
		[Tooltip("The canvas. Leave to none to use the canvas of the gameObject")]
		public FsmGameObject canvas;

		[Tooltip("The screen position.")]
		public FsmVector2 screenPoint;

		[ActionSection("Result")]
		[RequiredField]
		[Tooltip("Pixel adjusted point from the screen position.")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 pixelPoint;

		private RectTransform _rt;

		private Canvas _canvas;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			canvas = new FsmGameObject
			{
				UseVariable = true
			};
			screenPoint = null;
			pixelPoint = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			GameObject value = canvas.Value;
			if (value != null)
			{
				_canvas = value.GetComponent<Canvas>();
			}
			if (_canvas == null && ownerDefaultTarget != null)
			{
				Graphic component = ownerDefaultTarget.GetComponent<Graphic>();
				if (component != null)
				{
					_canvas = component.canvas;
				}
			}
			DoAction();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoAction();
		}

		private void DoAction()
		{
			pixelPoint.Value = RectTransformUtility.PixelAdjustPoint(screenPoint.Value, _rt, _canvas);
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Given a rect transform, return the corner points in pixel accurate coordinates.")]
	public class RectTransformPixelAdjustRect : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[CheckForComponent(typeof(Canvas))]
		[Tooltip("The canvas. Leave to none to use the canvas of the gameObject")]
		public FsmGameObject canvas;

		[ActionSection("Result")]
		[RequiredField]
		[Tooltip("Pixel adjusted rect.")]
		[UIHint(UIHint.Variable)]
		public FsmRect pixelRect;

		private RectTransform _rt;

		private Canvas _canvas;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			canvas = new FsmGameObject
			{
				UseVariable = true
			};
			pixelRect = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			GameObject value = canvas.Value;
			if (value != null)
			{
				_canvas = value.GetComponent<Canvas>();
			}
			if (_canvas == null && ownerDefaultTarget != null)
			{
				Graphic component = ownerDefaultTarget.GetComponent<Graphic>();
				if (component != null)
				{
					_canvas = component.canvas;
				}
			}
			DoAction();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoAction();
		}

		private void DoAction()
		{
			pixelRect.Value = RectTransformUtility.PixelAdjustRect(_rt, _canvas);
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Transform a screen space point to a local position that is on the plane of the given RectTransform. Also check if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.")]
	public class RectTransformScreenPointToLocalPointInRectangle : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The screenPoint as a Vector2. Leave to none if you want to use the Vector3 alternative")]
		public FsmVector2 screenPointVector2;

		[Tooltip("The screenPoint as a Vector3. Leave to none if you want to use the Vector2 alternative")]
		public FsmVector3 orScreenPointVector3;

		[Tooltip("Define if screenPoint are expressed as normalized screen coordinates (0-1). Otherwise coordinates are in pixels.")]
		public bool normalizedScreenPoint;

		[Tooltip("The Camera. For a RectTransform in a Canvas set to Screen Space - Overlay mode, the cam parameter should be set to null explicitly (default).\nLeave to none and the camera will be the one from EventSystem.current.camera")]
		[CheckForComponent(typeof(Camera))]
		public FsmGameObject camera;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		[ActionSection("Result")]
		[Tooltip("Store the local Position as a vector3 of the screenPoint on the RectTransform Plane.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 localPosition;

		[Tooltip("Store the local Position as a vector2 of the screenPoint on the RectTransform Plane.")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 localPosition2d;

		[Tooltip("True if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isHit;

		[Tooltip("Event sent if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.")]
		public FsmEvent hitEvent;

		[Tooltip("Event sent if the plane of the RectTransform is NOT hit, regardless of whether the point is inside the rectangle.")]
		public FsmEvent noHitEvent;

		private RectTransform _rt;

		private Camera _camera;

		public override void Reset()
		{
			gameObject = null;
			screenPointVector2 = null;
			orScreenPointVector3 = new FsmVector3
			{
				UseVariable = true
			};
			normalizedScreenPoint = false;
			camera = new FsmGameObject
			{
				UseVariable = true
			};
			everyFrame = false;
			localPosition = null;
			localPosition2d = null;
			isHit = null;
			hitEvent = null;
			noHitEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			if (!camera.IsNone)
			{
				_camera = camera.Value.GetComponent<Camera>();
			}
			else
			{
				_camera = EventSystem.current.GetComponent<Camera>();
			}
			DoCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCheck();
		}

		private void DoCheck()
		{
			if (_rt == null)
			{
				return;
			}
			Vector2 value = screenPointVector2.Value;
			if (!orScreenPointVector3.IsNone)
			{
				value.x = orScreenPointVector3.Value.x;
				value.y = orScreenPointVector3.Value.y;
			}
			if (normalizedScreenPoint)
			{
				value.x *= Screen.width;
				value.y *= Screen.height;
			}
			bool flag = false;
			flag = RectTransformUtility.ScreenPointToLocalPointInRectangle(_rt, value, _camera, out var localPoint);
			if (!localPosition2d.IsNone)
			{
				localPosition2d.Value = localPoint;
			}
			if (!localPosition.IsNone)
			{
				localPosition.Value = new Vector3(localPoint.x, localPoint.y, 0f);
			}
			if (!isHit.IsNone)
			{
				isHit.Value = flag;
			}
			if (flag)
			{
				if (hitEvent != null)
				{
					base.Fsm.Event(hitEvent);
				}
			}
			else if (noHitEvent != null)
			{
				base.Fsm.Event(noHitEvent);
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Transform a screen space point to a world position that is on the plane of the given RectTransform. Also check if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.")]
	public class RectTransformScreenPointToWorldPointInRectangle : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The screenPoint as a Vector2. Leave to none if you want to use the Vector3 alternative")]
		public FsmVector2 screenPointVector2;

		[Tooltip("The screenPoint as a Vector3. Leave to none if you want to use the Vector2 alternative")]
		public FsmVector3 orScreenPointVector3;

		[Tooltip("Define if screenPoint are expressed as normalized screen coordinates (0-1). Otherwise coordinates are in pixels.")]
		public bool normalizedScreenPoint;

		[Tooltip("The Camera. For a RectTransform in a Canvas set to Screen Space - Overlay mode, the cam parameter should be set to null explicitly (default).\nLeave to none and the camera will be the one from EventSystem.current.camera")]
		[CheckForComponent(typeof(Camera))]
		public FsmGameObject camera;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		[ActionSection("Result")]
		[Tooltip("Store the world Position of the screenPoint on the RectTransform Plane.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 worldPosition;

		[Tooltip("True if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isHit;

		[Tooltip("Event sent if the plane of the RectTransform is hit, regardless of whether the point is inside the rectangle.")]
		public FsmEvent hitEvent;

		[Tooltip("Event sent if the plane of the RectTransform is NOT hit, regardless of whether the point is inside the rectangle.")]
		public FsmEvent noHitEvent;

		private RectTransform _rt;

		private Camera _camera;

		public override void Reset()
		{
			gameObject = null;
			screenPointVector2 = null;
			orScreenPointVector3 = new FsmVector3
			{
				UseVariable = true
			};
			normalizedScreenPoint = false;
			camera = new FsmGameObject
			{
				UseVariable = true
			};
			everyFrame = false;
			worldPosition = null;
			isHit = null;
			hitEvent = null;
			noHitEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			if (!camera.IsNone)
			{
				_camera = camera.Value.GetComponent<Camera>();
			}
			else
			{
				_camera = EventSystem.current.GetComponent<Camera>();
			}
			DoCheck();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCheck();
		}

		private void DoCheck()
		{
			if (_rt == null)
			{
				return;
			}
			Vector2 value = screenPointVector2.Value;
			if (!orScreenPointVector3.IsNone)
			{
				value.x = orScreenPointVector3.Value.x;
				value.y = orScreenPointVector3.Value.y;
			}
			if (normalizedScreenPoint)
			{
				value.x *= Screen.width;
				value.y *= Screen.height;
			}
			bool flag = false;
			flag = RectTransformUtility.ScreenPointToWorldPointInRectangle(_rt, value, _camera, out var worldPoint);
			worldPosition.Value = worldPoint;
			if (!isHit.IsNone)
			{
				isHit.Value = flag;
			}
			if (flag)
			{
				if (hitEvent != null)
				{
					base.Fsm.Event(hitEvent);
				}
			}
			else if (noHitEvent != null)
			{
				base.Fsm.Event(noHitEvent);
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The normalized position in the parent RectTransform that the upper right corner is anchored to. This is relative screen space, values ranges from 0 to 1")]
	public class RectTransformSetAnchorMax : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 anchor. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 anchorMax;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMax x value if set. Set to none for no effect")]
		public FsmFloat x;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMax x value if set. Set to none for no effect")]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			anchorMax = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetAnchorMax();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetAnchorMax();
		}

		private void DoSetAnchorMax()
		{
			Vector2 value = _rt.anchorMax;
			if (!anchorMax.IsNone)
			{
				value = anchorMax.Value;
			}
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			_rt.anchorMax = value;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The normalized position in the parent RectTransform that the lower left corner is anchored to. This is relative screen space, values ranges from 0 to 1")]
	public class RectTransformSetAnchorMin : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 anchor. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 anchorMin;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMin x value if set. Set to none for no effect")]
		public FsmFloat x;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMin x value if set. Set to none for no effect")]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			anchorMin = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetAnchorMin();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetAnchorMin();
		}

		private void DoSetAnchorMin()
		{
			Vector2 value = _rt.anchorMin;
			if (!anchorMin.IsNone)
			{
				value = anchorMin.Value;
			}
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			_rt.anchorMin = value;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The normalized position in the parent RectTransform that the upper right corner is anchored to. This is relative screen space, values ranges from 0 to 1")]
	public class RectTransformSetAnchorMinAndMax : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 anchor max. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 anchorMax;

		[Tooltip("The Vector2 anchor min. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 anchorMin;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMax x value if set. Set to none for no effect")]
		public FsmFloat xMax;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMax x value if set. Set to none for no effect")]
		public FsmFloat yMax;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMin x value if set. Set to none for no effect")]
		public FsmFloat xMin;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides anchorMin x value if set. Set to none for no effect")]
		public FsmFloat yMin;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			anchorMax = null;
			anchorMin = null;
			xMax = new FsmFloat
			{
				UseVariable = true
			};
			yMax = new FsmFloat
			{
				UseVariable = true
			};
			xMin = new FsmFloat
			{
				UseVariable = true
			};
			yMin = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetAnchorMax();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetAnchorMax();
		}

		private void DoSetAnchorMax()
		{
			Vector2 value = _rt.anchorMax;
			Vector2 value2 = _rt.anchorMin;
			if (!anchorMax.IsNone)
			{
				value = anchorMax.Value;
				value2 = anchorMin.Value;
			}
			if (!xMax.IsNone)
			{
				value.x = xMax.Value;
			}
			if (!yMax.IsNone)
			{
				value.y = yMax.Value;
			}
			if (!xMin.IsNone)
			{
				value2.x = xMin.Value;
			}
			if (!yMin.IsNone)
			{
				value2.y = yMin.Value;
			}
			_rt.anchorMax = value;
			_rt.anchorMin = value2;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The position ( normalized or not) in the parent RectTransform keeping the anchor rect size intact. This lets you position the whole Rect in one go. Use this to easily animate movement (like IOS sliding UIView)")]
	public class RectTransformSetAnchorRectPosition : BaseUpdateAction
	{
		public enum AnchorReference
		{
			TopLeft,
			Top,
			TopRight,
			Right,
			BottomRight,
			Bottom,
			BottomLeft,
			Left,
			Center
		}

		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The reference for the given position")]
		public AnchorReference anchorReference;

		[Tooltip("Are the supplied screen coordinates normalized (0-1), or in pixels.")]
		public FsmBool normalized;

		[Tooltip("The Vector2 position, and/or set individual axis below.")]
		public FsmVector2 anchor;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat x;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat y;

		private RectTransform _rt;

		private Rect _anchorRect;

		public override void Reset()
		{
			base.Reset();
			normalized = true;
			gameObject = null;
			anchorReference = AnchorReference.BottomLeft;
			anchor = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetAnchor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetAnchor();
		}

		private void DoSetAnchor()
		{
			_anchorRect = default(Rect);
			_anchorRect.min = _rt.anchorMin;
			_anchorRect.max = _rt.anchorMax;
			Vector2 zero = Vector2.zero;
			zero = _anchorRect.min;
			if (!anchor.IsNone)
			{
				if (normalized.Value)
				{
					zero = anchor.Value;
				}
				else
				{
					zero.x = anchor.Value.x / (float)Screen.width;
					zero.y = anchor.Value.y / (float)Screen.height;
				}
			}
			if (!x.IsNone)
			{
				if (normalized.Value)
				{
					zero.x = x.Value;
				}
				else
				{
					zero.x = x.Value / (float)Screen.width;
				}
			}
			if (!y.IsNone)
			{
				if (normalized.Value)
				{
					zero.y = y.Value;
				}
				else
				{
					zero.y = y.Value / (float)Screen.height;
				}
			}
			if (anchorReference == AnchorReference.BottomLeft)
			{
				_anchorRect.x = zero.x;
				_anchorRect.y = zero.y;
			}
			else if (anchorReference == AnchorReference.Left)
			{
				_anchorRect.x = zero.x;
				_anchorRect.y = zero.y - 0.5f;
			}
			else if (anchorReference == AnchorReference.TopLeft)
			{
				_anchorRect.x = zero.x;
				_anchorRect.y = zero.y - 1f;
			}
			else if (anchorReference == AnchorReference.Top)
			{
				_anchorRect.x = zero.x - 0.5f;
				_anchorRect.y = zero.y - 1f;
			}
			else if (anchorReference == AnchorReference.TopRight)
			{
				_anchorRect.x = zero.x - 1f;
				_anchorRect.y = zero.y - 1f;
			}
			else if (anchorReference == AnchorReference.Right)
			{
				_anchorRect.x = zero.x - 1f;
				_anchorRect.y = zero.y - 0.5f;
			}
			else if (anchorReference == AnchorReference.BottomRight)
			{
				_anchorRect.x = zero.x - 1f;
				_anchorRect.y = zero.y;
			}
			else if (anchorReference == AnchorReference.Bottom)
			{
				_anchorRect.x = zero.x - 0.5f;
				_anchorRect.y = zero.y;
			}
			else if (anchorReference == AnchorReference.Center)
			{
				_anchorRect.x = zero.x - 0.5f;
				_anchorRect.y = zero.y - 0.5f;
			}
			_rt.anchorMin = _anchorRect.min;
			_rt.anchorMax = _anchorRect.max;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The position of the pivot of this RectTransform relative to the anchor reference point.The anchor reference point is where the anchors are. If the anchor are not together, the four anchor positions are interpolated according to the pivot normalized values.")]
	public class RectTransformSetAnchoredPosition : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 position. Set to none for no effect, and/or set individual axis below. ")]
		public FsmVector2 position;

		[Tooltip("Setting only the x value. Overrides position x value if set. Set to none for no effect")]
		public FsmFloat x;

		[Tooltip("Setting only the y value. Overrides position x value if set. Set to none for no effect")]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			position = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetAnchoredPosition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetAnchoredPosition();
		}

		private void DoSetAnchoredPosition()
		{
			Vector2 anchoredPosition = _rt.anchoredPosition;
			if (!position.IsNone)
			{
				anchoredPosition = position.Value;
			}
			if (!x.IsNone)
			{
				anchoredPosition.x = x.Value;
			}
			if (!y.IsNone)
			{
				anchoredPosition.y = y.Value;
			}
			_rt.anchoredPosition = anchoredPosition;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Set the local position of this RectTransform.")]
	public class RectTransformSetLocalPosition : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The position. Set to none for no effect")]
		public FsmVector2 position2d;

		[Tooltip("Or the 3d position. Set to none for no effect")]
		public FsmVector3 position;

		[Tooltip("The x component of the rotation. Set to none for no effect")]
		public FsmFloat x;

		[Tooltip("The y component of the rotation. Set to none for no effect")]
		public FsmFloat y;

		[Tooltip("The z component of the rotation. Set to none for no effect")]
		public FsmFloat z;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			position2d = new FsmVector2
			{
				UseVariable = true
			};
			position = new FsmVector3
			{
				UseVariable = true
			};
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetValues();
		}

		private void DoSetValues()
		{
			if (!(_rt == null))
			{
				Vector3 localPosition = _rt.localPosition;
				if (!position.IsNone)
				{
					localPosition = position.Value;
				}
				if (!position2d.IsNone)
				{
					localPosition.x = position2d.Value.x;
					localPosition.y = position2d.Value.y;
				}
				if (!x.IsNone)
				{
					localPosition.x = x.Value;
				}
				if (!y.IsNone)
				{
					localPosition.y = y.Value;
				}
				if (!z.IsNone)
				{
					localPosition.z = z.Value;
				}
				_rt.localPosition = localPosition;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Set the local rotation of this RectTransform.")]
	public class RectTransformSetLocalRotation : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The rotation. Set to none for no effect")]
		public FsmVector3 rotation;

		[Tooltip("The x component of the rotation. Set to none for no effect")]
		public FsmFloat x;

		[Tooltip("The y component of the rotation. Set to none for no effect")]
		public FsmFloat y;

		[Tooltip("The z component of the rotation. Set to none for no effect")]
		public FsmFloat z;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			rotation = new FsmVector3
			{
				UseVariable = true
			};
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetValues();
		}

		private void DoSetValues()
		{
			if (!(_rt == null))
			{
				Vector3 eulerAngles = _rt.eulerAngles;
				if (!rotation.IsNone)
				{
					eulerAngles = rotation.Value;
				}
				if (!x.IsNone)
				{
					eulerAngles.x = x.Value;
				}
				if (!y.IsNone)
				{
					eulerAngles.y = y.Value;
				}
				if (!z.IsNone)
				{
					eulerAngles.z = z.Value;
				}
				_rt.eulerAngles = eulerAngles;
			}
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("\tThe offset of the upper right corner of the rectangle relative to the upper right anchor.")]
	public class RectTransformSetOffsetMax : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 offsetMax. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 offsetMax;

		[Tooltip("Setting only the x value. Overrides offsetMax x value if set. Set to none for no effect")]
		public FsmFloat x;

		[Tooltip("Setting only the y value. Overrides offsetMax y value if set. Set to none for no effect")]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			offsetMax = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetOffsetMax();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetOffsetMax();
		}

		private void DoSetOffsetMax()
		{
			Vector2 value = _rt.offsetMax;
			if (!offsetMax.IsNone)
			{
				value = offsetMax.Value;
			}
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			_rt.offsetMax = value;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The offset of the lower left corner of the rectangle relative to the lower left anchor.")]
	public class RectTransformSetOffsetMin : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 offsetMin. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 offsetMin;

		[Tooltip("Setting only the x value. Overrides offsetMin x value if set. Set to none for no effect")]
		public FsmFloat x;

		[Tooltip("Setting only the x value. Overrides offsetMin y value if set. Set to none for no effect")]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			offsetMin = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetOffsetMin();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetOffsetMin();
		}

		private void DoSetOffsetMin()
		{
			Vector2 value = _rt.offsetMin;
			if (!offsetMin.IsNone)
			{
				value = offsetMin.Value;
			}
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			_rt.offsetMin = value;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("The normalized position in this RectTransform that it rotates around.")]
	public class RectTransformSetPivot : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Vector2 pivot. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 pivot;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides pivot x value if set. Set to none for no effect")]
		public FsmFloat x;

		[HasFloatSlider(0f, 1f)]
		[Tooltip("Setting only the x value. Overrides pivot y value if set. Set to none for no effect")]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			pivot = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetPivotPosition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetPivotPosition();
		}

		private void DoSetPivotPosition()
		{
			Vector2 value = _rt.pivot;
			if (!pivot.IsNone)
			{
				value = pivot.Value;
			}
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			_rt.pivot = value;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("Set the size of this RectTransform relative to the distances between the anchors. this is the 'Width' and 'Height' values in the RectTransform inspector.")]
	public class RectTransformSetSizeDelta : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("TheVector2 sizeDelta. Set to none for no effect, and/or set individual axis below.")]
		public FsmVector2 sizeDelta;

		[Tooltip("Setting only the x value. Overrides sizeDelta x value if set. Set to none for no effect")]
		public FsmFloat x;

		[Tooltip("Setting only the x value. Overrides sizeDelta y value if set. Set to none for no effect")]
		public FsmFloat y;

		private RectTransform _rt;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			sizeDelta = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			DoSetSizeDelta();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoSetSizeDelta();
		}

		private void DoSetSizeDelta()
		{
			Vector2 value = _rt.sizeDelta;
			if (!sizeDelta.IsNone)
			{
				value = sizeDelta.Value;
			}
			if (!x.IsNone)
			{
				value.x = x.Value;
			}
			if (!y.IsNone)
			{
				value.y = y.Value;
			}
			_rt.sizeDelta = value;
		}
	}
	[ActionCategory("RectTransform")]
	[Tooltip("RectTransforms position from world space into screen space. Leave the camera to none for default behavior")]
	public class RectTransformWorldToScreenPoint : BaseUpdateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(RectTransform))]
		[Tooltip("The GameObject target.")]
		public FsmOwnerDefault gameObject;

		[CheckForComponent(typeof(Camera))]
		[Tooltip("The camera to perform the calculation. Leave to none for default behavior")]
		public FsmOwnerDefault camera;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the screen position in a Vector3 Variable. Z will equal zero.")]
		public FsmVector3 screenPoint;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the screen X position in a Float Variable.")]
		public FsmFloat screenX;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the screen Y position in a Float Variable.")]
		public FsmFloat screenY;

		[Tooltip("Normalize screen coordinates (0-1). Otherwise coordinates are in pixels.")]
		public FsmBool normalize;

		private RectTransform _rt;

		private Camera _cam;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			camera = new FsmOwnerDefault();
			camera.OwnerOption = OwnerDefaultOption.SpecifyGameObject;
			camera.GameObject = new FsmGameObject
			{
				UseVariable = true
			};
			screenPoint = null;
			screenX = null;
			screenY = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_rt = ownerDefaultTarget.GetComponent<RectTransform>();
			}
			if (base.Fsm.GetOwnerDefaultTarget(camera) != null)
			{
				_cam = ownerDefaultTarget.GetComponent<Camera>();
			}
			DoWorldToScreenPoint();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnActionUpdate()
		{
			DoWorldToScreenPoint();
		}

		private void DoWorldToScreenPoint()
		{
			Vector2 vector = RectTransformUtility.WorldToScreenPoint(_cam, _rt.position);
			if (normalize.Value)
			{
				vector.x /= Screen.width;
				vector.y /= Screen.height;
			}
			screenPoint.Value = vector;
			screenX.Value = vector.x;
			screenY.Value = vector.y;
		}
	}
	[ActionCategory(ActionCategory.RenderSettings)]
	[Tooltip("Enables/Disables Fog in the scene.")]
	public class EnableFog : FsmStateAction
	{
		[Tooltip("Set to True to enable, False to disable.")]
		public FsmBool enableFog;

		[Tooltip("Repeat every frame. Useful if the Enable Fog setting is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			enableFog = true;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			RenderSettings.fog = enableFog.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			RenderSettings.fog = enableFog.Value;
		}
	}
	[ActionCategory(ActionCategory.RenderSettings)]
	[Tooltip("Sets the Ambient Light Color for the scene.")]
	public class SetAmbientLight : FsmStateAction
	{
		[RequiredField]
		public FsmColor ambientColor;

		public bool everyFrame;

		public override void Reset()
		{
			ambientColor = Color.gray;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetAmbientColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetAmbientColor();
		}

		private void DoSetAmbientColor()
		{
			RenderSettings.ambientLight = ambientColor.Value;
		}
	}
	[ActionCategory(ActionCategory.RenderSettings)]
	[Tooltip("Sets the intensity of all Flares in the scene.")]
	public class SetFlareStrength : FsmStateAction
	{
		[RequiredField]
		public FsmFloat flareStrength;

		public bool everyFrame;

		public override void Reset()
		{
			flareStrength = 0.2f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFlareStrength();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetFlareStrength();
		}

		private void DoSetFlareStrength()
		{
			RenderSettings.flareStrength = flareStrength.Value;
		}
	}
	[ActionCategory(ActionCategory.RenderSettings)]
	[Tooltip("Sets the color of the Fog in the scene.")]
	public class SetFogColor : FsmStateAction
	{
		[RequiredField]
		public FsmColor fogColor;

		public bool everyFrame;

		public override void Reset()
		{
			fogColor = Color.white;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFogColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetFogColor();
		}

		private void DoSetFogColor()
		{
			RenderSettings.fogColor = fogColor.Value;
		}
	}
	[ActionCategory(ActionCategory.RenderSettings)]
	[Tooltip("Sets the density of the Fog in the scene.")]
	public class SetFogDensity : FsmStateAction
	{
		[RequiredField]
		public FsmFloat fogDensity;

		public bool everyFrame;

		public override void Reset()
		{
			fogDensity = 0.5f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFogDensity();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetFogDensity();
		}

		private void DoSetFogDensity()
		{
			RenderSettings.fogDensity = fogDensity.Value;
		}
	}
	[ActionCategory(ActionCategory.RenderSettings)]
	[Tooltip("Sets the size of light halos.")]
	public class SetHaloStrength : FsmStateAction
	{
		[RequiredField]
		public FsmFloat haloStrength;

		public bool everyFrame;

		public override void Reset()
		{
			haloStrength = 0.5f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetHaloStrength();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetHaloStrength();
		}

		private void DoSetHaloStrength()
		{
			RenderSettings.haloStrength = haloStrength.Value;
		}
	}
	[ActionCategory(ActionCategory.RenderSettings)]
	[Tooltip("Sets the global Skybox.")]
	public class SetSkybox : FsmStateAction
	{
		public FsmMaterial skybox;

		[Tooltip("Repeat every frame. Useful if the Skybox is changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			skybox = null;
		}

		public override void OnEnter()
		{
			RenderSettings.skybox = skybox.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			RenderSettings.skybox = skybox.Value;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Allow scenes to be activated. Use this after LoadSceneAsynch where you did not activated the scene upon loading")]
	public class AllowSceneActivation : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The name of the new scene. It cannot be empty or null, or same as the name of the existing scenes.")]
		public FsmInt aSynchOperationHashCode;

		[Tooltip("Allow the scene to be activated")]
		public FsmBool allowSceneActivation;

		[ActionSection("Result")]
		[Tooltip("The loading's progress.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat progress;

		[Tooltip("True when loading is done")]
		[UIHint(UIHint.Variable)]
		public FsmBool isDone;

		[Tooltip("Event sent when scene loading is done")]
		public FsmEvent doneEvent;

		[Tooltip("Event sent when action could not be performed. Check Log for more information")]
		public FsmEvent failureEvent;

		public override void Reset()
		{
			aSynchOperationHashCode = null;
			allowSceneActivation = true;
			progress = null;
			isDone = null;
			doneEvent = null;
			failureEvent = null;
		}

		public override void OnEnter()
		{
			DoAllowSceneActivation();
		}

		public override void OnUpdate()
		{
			if (!progress.IsNone)
			{
				progress.Value = LoadSceneAsynch.aSyncOperationLUT[aSynchOperationHashCode.Value].progress;
			}
			if (!isDone.IsNone)
			{
				isDone.Value = LoadSceneAsynch.aSyncOperationLUT[aSynchOperationHashCode.Value].isDone;
			}
			if (LoadSceneAsynch.aSyncOperationLUT[aSynchOperationHashCode.Value].isDone)
			{
				LoadSceneAsynch.aSyncOperationLUT.Remove(aSynchOperationHashCode.Value);
				base.Fsm.Event(doneEvent);
				Finish();
			}
		}

		private void DoAllowSceneActivation()
		{
			if (aSynchOperationHashCode.IsNone || allowSceneActivation.IsNone || LoadSceneAsynch.aSyncOperationLUT == null || !LoadSceneAsynch.aSyncOperationLUT.ContainsKey(aSynchOperationHashCode.Value))
			{
				base.Fsm.Event(failureEvent);
				Finish();
			}
			else
			{
				LoadSceneAsynch.aSyncOperationLUT[aSynchOperationHashCode.Value].allowSceneActivation = allowSceneActivation.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Create an empty new scene with the given name additively. The path of the new scene will be empty")]
	public class CreateScene : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The name of the new scene. It cannot be empty or null, or same as the name of the existing scenes.")]
		public FsmString sceneName;

		public override void Reset()
		{
			sceneName = null;
		}

		public override void OnEnter()
		{
			SceneManager.CreateScene(sceneName.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get the last activateChanged Scene Event data when event was sent from the action 'SendSceneActiveChangedEvent")]
	public class GetSceneActivateChangedEventData : FsmStateAction
	{
		[ActionSection("New Active Scene")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The new active scene name")]
		public FsmString newName;

		[Tooltip("The new active scene path")]
		[UIHint(UIHint.Variable)]
		public FsmString newPath;

		[Tooltip("true if the new active scene is valid.")]
		[UIHint(UIHint.Variable)]
		public FsmBool newIsValid;

		[Tooltip("The new active scene Build Index")]
		[UIHint(UIHint.Variable)]
		public FsmInt newBuildIndex;

		[Tooltip("true if the new active scene is loaded.")]
		[UIHint(UIHint.Variable)]
		public FsmBool newIsLoaded;

		[UIHint(UIHint.Variable)]
		[Tooltip("true if the new active scene is modified.")]
		public FsmBool newIsDirty;

		[Tooltip("The new active scene RootCount")]
		[UIHint(UIHint.Variable)]
		public FsmInt newRootCount;

		[Tooltip("The new active scene Root GameObjects")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray newRootGameObjects;

		[ActionSection("Previous Active Scene")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The previous active scene name")]
		public FsmString previousName;

		[Tooltip("The previous active scene path")]
		[UIHint(UIHint.Variable)]
		public FsmString previousPath;

		[Tooltip("true if the previous active scene is valid.")]
		[UIHint(UIHint.Variable)]
		public FsmBool previousIsValid;

		[Tooltip("The previous active scene Build Index")]
		[UIHint(UIHint.Variable)]
		public FsmInt previousBuildIndex;

		[Tooltip("true if the previous active scene is loaded.")]
		[UIHint(UIHint.Variable)]
		public FsmBool previousIsLoaded;

		[UIHint(UIHint.Variable)]
		[Tooltip("true if the previous active scene is modified.")]
		public FsmBool previousIsDirty;

		[Tooltip("The previous active scene RootCount")]
		[UIHint(UIHint.Variable)]
		public FsmInt previousRootCount;

		[Tooltip("The previous active scene Root GameObjects")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray previousRootGameObjects;

		private Scene _scene;

		public override void Reset()
		{
			newName = null;
			newPath = null;
			newIsValid = null;
			newBuildIndex = null;
			newIsLoaded = null;
			newRootCount = null;
			newRootGameObjects = null;
			newIsDirty = null;
			previousName = null;
			previousPath = null;
			previousIsValid = null;
			previousBuildIndex = null;
			previousIsLoaded = null;
			previousRootCount = null;
			previousRootGameObjects = null;
			previousIsDirty = null;
		}

		public override void OnEnter()
		{
			DoGetSceneProperties();
			Finish();
		}

		public override void OnUpdate()
		{
			DoGetSceneProperties();
		}

		private void DoGetSceneProperties()
		{
			_scene = SendActiveSceneChangedEvent.lastPreviousActiveScene;
			if (!previousName.IsNone)
			{
				previousName.Value = _scene.name;
			}
			if (!previousBuildIndex.IsNone)
			{
				previousBuildIndex.Value = _scene.buildIndex;
			}
			if (!previousPath.IsNone)
			{
				previousPath.Value = _scene.path;
			}
			if (!previousIsValid.IsNone)
			{
				previousIsValid.Value = _scene.IsValid();
			}
			if (!previousIsDirty.IsNone)
			{
				previousIsDirty.Value = _scene.isDirty;
			}
			if (!previousIsLoaded.IsNone)
			{
				previousIsLoaded.Value = _scene.isLoaded;
			}
			if (!previousRootCount.IsNone)
			{
				previousRootCount.Value = _scene.rootCount;
			}
			if (!previousRootGameObjects.IsNone)
			{
				if (_scene.IsValid())
				{
					FsmArray fsmArray = previousRootGameObjects;
					object[] rootGameObjects = _scene.GetRootGameObjects();
					fsmArray.Values = rootGameObjects;
				}
				else
				{
					previousRootGameObjects.Resize(0);
				}
			}
			_scene = SendActiveSceneChangedEvent.lastNewActiveScene;
			if (!newName.IsNone)
			{
				newName.Value = _scene.name;
			}
			if (!newBuildIndex.IsNone)
			{
				newBuildIndex.Value = _scene.buildIndex;
			}
			if (!newPath.IsNone)
			{
				newPath.Value = _scene.path;
			}
			if (!newIsValid.IsNone)
			{
				newIsValid.Value = _scene.IsValid();
			}
			if (!newIsDirty.IsNone)
			{
				newIsDirty.Value = _scene.isDirty;
			}
			if (!newIsLoaded.IsNone)
			{
				newIsLoaded.Value = _scene.isLoaded;
			}
			if (!newRootCount.IsNone)
			{
				newRootCount.Value = _scene.rootCount;
			}
			if (!newRootGameObjects.IsNone)
			{
				if (_scene.IsValid())
				{
					FsmArray fsmArray2 = newRootGameObjects;
					object[] rootGameObjects = _scene.GetRootGameObjects();
					fsmArray2.Values = rootGameObjects;
				}
				else
				{
					newRootGameObjects.Resize(0);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Returns the index of a scene in the Build Settings. Always returns -1 if the scene was loaded through an AssetBundle.")]
	public class GetSceneBuildIndex : GetSceneActionBase
	{
		[ActionSection("Result")]
		[Tooltip("The scene Build Index")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt buildIndex;

		public override void Reset()
		{
			base.Reset();
			buildIndex = null;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneBuildIndex();
			Finish();
		}

		private void DoGetSceneBuildIndex()
		{
			if (_sceneFound)
			{
				if (!buildIndex.IsNone)
				{
					buildIndex.Value = _scene.buildIndex;
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get the total number of currently loaded scenes.")]
	public class GetSceneCount : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The number of currently loaded scenes.")]
		public FsmInt sceneCount;

		[Tooltip("Repeat every Frame")]
		public bool everyFrame;

		public override void Reset()
		{
			sceneCount = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetSceneCount();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSceneCount();
		}

		private void DoGetSceneCount()
		{
			sceneCount.Value = SceneManager.sceneCount;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get the number of scenes in Build Settings.")]
	public class GetSceneCountInBuildSettings : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The number of scenes in Build Settings.")]
		public FsmInt sceneCountInBuildSettings;

		public override void Reset()
		{
			sceneCountInBuildSettings = null;
		}

		public override void OnEnter()
		{
			DoGetSceneCountInBuildSettings();
			Finish();
		}

		private void DoGetSceneCountInBuildSettings()
		{
			sceneCountInBuildSettings.Value = SceneManager.sceneCountInBuildSettings;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene isDirty flag. true if the scene is modified. ")]
	public class GetSceneIsDirty : GetSceneActionBase
	{
		[ActionSection("Result")]
		[UIHint(UIHint.Variable)]
		[Tooltip("true if the scene is modified.")]
		public FsmBool isDirty;

		[Tooltip("Event sent if the scene is modified.")]
		public FsmEvent isDirtyEvent;

		[Tooltip("Event sent if the scene is unmodified.")]
		public FsmEvent isNotDirtyEvent;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			base.Reset();
			isDirty = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneIsDirty();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSceneIsDirty();
		}

		private void DoGetSceneIsDirty()
		{
			if (_sceneFound)
			{
				if (!isDirty.IsNone)
				{
					isDirty.Value = _scene.isDirty;
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene isLoaded flag.")]
	public class GetSceneIsLoaded : GetSceneActionBase
	{
		[ActionSection("Result")]
		[Tooltip("true if the scene is loaded.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isLoaded;

		[Tooltip("Event sent if the scene is loaded.")]
		public FsmEvent isLoadedEvent;

		[Tooltip("Event sent if the scene is not loaded.")]
		public FsmEvent isNotLoadedEvent;

		[Tooltip("Repeat every Frame")]
		public bool everyFrame;

		public override void Reset()
		{
			base.Reset();
			isLoaded = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneIsLoaded();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSceneIsLoaded();
		}

		private void DoGetSceneIsLoaded()
		{
			if (_sceneFound)
			{
				if (!isLoaded.IsNone)
				{
					isLoaded.Value = _scene.isLoaded;
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene isValid flag. A scene may be invalid if, for example, you tried to open a scene that does not exist. In this case, the scene returned from EditorSceneManager.OpenScene would return False for IsValid. ")]
	public class GetSceneIsValid : GetSceneActionBase
	{
		[ActionSection("Result")]
		[UIHint(UIHint.Variable)]
		[Tooltip("true if the scene is loaded.")]
		public FsmBool isValid;

		[Tooltip("Event sent if the scene is valid.")]
		public FsmEvent isValidEvent;

		[Tooltip("Event sent if the scene is not valid.")]
		public FsmEvent isNotValidEvent;

		public override void Reset()
		{
			base.Reset();
			isValid = null;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneIsValid();
			Finish();
		}

		private void DoGetSceneIsValid()
		{
			if (_sceneFound)
			{
				if (!isValid.IsNone)
				{
					isValid.Value = _scene.IsValid();
				}
				if (_scene.IsValid())
				{
					base.Fsm.Event(isValidEvent);
				}
				else
				{
					base.Fsm.Event(isNotValidEvent);
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get the last Loaded Scene Event data when event was sent from the action 'SendSceneLoadedEvent")]
	public class GetSceneLoadedEventData : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The scene loaded mode")]
		[ObjectType(typeof(LoadSceneMode))]
		public FsmEnum loadedMode;

		[UIHint(UIHint.Variable)]
		[Tooltip("The scene name")]
		public FsmString name;

		[Tooltip("The scene path")]
		[UIHint(UIHint.Variable)]
		public FsmString path;

		[Tooltip("true if the scene is valid.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isValid;

		[Tooltip("The scene Build Index")]
		[UIHint(UIHint.Variable)]
		public FsmInt buildIndex;

		[Tooltip("true if the scene is loaded.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isLoaded;

		[UIHint(UIHint.Variable)]
		[Tooltip("true if the scene is modified.")]
		public FsmBool isDirty;

		[Tooltip("The scene RootCount")]
		[UIHint(UIHint.Variable)]
		public FsmInt rootCount;

		[Tooltip("The scene Root GameObjects")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray rootGameObjects;

		private Scene _scene;

		public override void Reset()
		{
			loadedMode = null;
			name = null;
			path = null;
			isValid = null;
			buildIndex = null;
			isLoaded = null;
			rootCount = null;
			rootGameObjects = null;
			isDirty = null;
		}

		public override void OnEnter()
		{
			DoGetSceneProperties();
			Finish();
		}

		private void DoGetSceneProperties()
		{
			_scene = SendSceneLoadedEvent.lastLoadedScene;
			if (!name.IsNone)
			{
				loadedMode.Value = SendSceneLoadedEvent.lastLoadedMode;
			}
			if (!name.IsNone)
			{
				name.Value = _scene.name;
			}
			if (!buildIndex.IsNone)
			{
				buildIndex.Value = _scene.buildIndex;
			}
			if (!path.IsNone)
			{
				path.Value = _scene.path;
			}
			if (!isValid.IsNone)
			{
				isValid.Value = _scene.IsValid();
			}
			if (!isDirty.IsNone)
			{
				isDirty.Value = _scene.isDirty;
			}
			if (!isLoaded.IsNone)
			{
				isLoaded.Value = _scene.isLoaded;
			}
			if (!rootCount.IsNone)
			{
				rootCount.Value = _scene.rootCount;
			}
			if (!rootGameObjects.IsNone)
			{
				if (_scene.IsValid())
				{
					FsmArray fsmArray = rootGameObjects;
					object[] values = _scene.GetRootGameObjects();
					fsmArray.Values = values;
				}
				else
				{
					rootGameObjects.Resize(0);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene name.")]
	public class GetSceneName : GetSceneActionBase
	{
		[ActionSection("Result")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The scene name")]
		public FsmString name;

		public override void Reset()
		{
			base.Reset();
			name = null;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneName();
			Finish();
		}

		private void DoGetSceneName()
		{
			if (_sceneFound)
			{
				if (!name.IsNone)
				{
					name.Value = _scene.name;
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene path.")]
	public class GetScenePath : GetSceneActionBase
	{
		[ActionSection("Result")]
		[Tooltip("The scene path")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString path;

		public override void Reset()
		{
			base.Reset();
			path = null;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetScenePath();
			Finish();
		}

		private void DoGetScenePath()
		{
			if (_sceneFound)
			{
				if (!path.IsNone)
				{
					path.Value = _scene.path;
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene isDirty flag. true if the scene is modified. ")]
	public class GetSceneProperties : GetSceneActionBase
	{
		[ActionSection("Result")]
		[UIHint(UIHint.Variable)]
		[Tooltip("The scene name")]
		public FsmString name;

		[Tooltip("The scene path")]
		[UIHint(UIHint.Variable)]
		public FsmString path;

		[Tooltip("The scene Build Index")]
		[UIHint(UIHint.Variable)]
		public FsmInt buildIndex;

		[Tooltip("true if the scene is valid.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isValid;

		[Tooltip("true if the scene is loaded.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isLoaded;

		[UIHint(UIHint.Variable)]
		[Tooltip("true if the scene is modified.")]
		public FsmBool isDirty;

		[Tooltip("The scene RootCount")]
		[UIHint(UIHint.Variable)]
		public FsmInt rootCount;

		[Tooltip("The scene Root GameObjects")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray rootGameObjects;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			base.Reset();
			name = null;
			path = null;
			buildIndex = null;
			isValid = null;
			isLoaded = null;
			rootCount = null;
			rootGameObjects = null;
			isDirty = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneProperties();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoGetSceneProperties()
		{
			if (!_sceneFound)
			{
				return;
			}
			if (!name.IsNone)
			{
				name.Value = _scene.name;
			}
			if (!buildIndex.IsNone)
			{
				buildIndex.Value = _scene.buildIndex;
			}
			if (!path.IsNone)
			{
				path.Value = _scene.path;
			}
			if (!isValid.IsNone)
			{
				isValid.Value = _scene.IsValid();
			}
			if (!isDirty.IsNone)
			{
				isDirty.Value = _scene.isDirty;
			}
			if (!isLoaded.IsNone)
			{
				isLoaded.Value = _scene.isLoaded;
			}
			if (!rootCount.IsNone)
			{
				rootCount.Value = _scene.rootCount;
			}
			if (!rootGameObjects.IsNone)
			{
				if (_scene.IsValid())
				{
					FsmArray fsmArray = rootGameObjects;
					object[] values = _scene.GetRootGameObjects();
					fsmArray.Values = values;
				}
				else
				{
					rootGameObjects.Resize(0);
				}
			}
			base.Fsm.Event(sceneFoundEvent);
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene RootCount, the number of root transforms of this scene.")]
	public class GetSceneRootCount : GetSceneActionBase
	{
		[ActionSection("Result")]
		[Tooltip("The scene RootCount")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt rootCount;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			base.Reset();
			rootCount = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneRootCount();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSceneRootCount();
		}

		private void DoGetSceneRootCount()
		{
			if (_sceneFound)
			{
				if (!rootCount.IsNone)
				{
					rootCount.Value = _scene.rootCount;
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get a scene Root GameObjects.")]
	public class GetSceneRootGameObjects : GetSceneActionBase
	{
		[ActionSection("Result")]
		[Tooltip("The scene Root GameObjects")]
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray rootGameObjects;

		[Tooltip("Repeat every Frame")]
		public bool everyFrame;

		public override void Reset()
		{
			base.Reset();
			rootGameObjects = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			DoGetSceneRootGameObjects();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSceneRootGameObjects();
		}

		private void DoGetSceneRootGameObjects()
		{
			if (_sceneFound)
			{
				if (!rootGameObjects.IsNone)
				{
					FsmArray fsmArray = rootGameObjects;
					object[] values = _scene.GetRootGameObjects();
					fsmArray.Values = values;
				}
				base.Fsm.Event(sceneFoundEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Get the last Unloaded Scene Event data when event was sent from the action 'SendSceneUnloadedEvent")]
	public class GetSceneUnloadedEventData : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The scene name")]
		public FsmString name;

		[Tooltip("The scene path")]
		[UIHint(UIHint.Variable)]
		public FsmString path;

		[Tooltip("The scene Build Index")]
		[UIHint(UIHint.Variable)]
		public FsmInt buildIndex;

		[Tooltip("true if the scene is valid.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isValid;

		[Tooltip("true if the scene is loaded.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isLoaded;

		[UIHint(UIHint.Variable)]
		[Tooltip("true if the scene is modified.")]
		public FsmBool isDirty;

		[Tooltip("The scene RootCount")]
		[UIHint(UIHint.Variable)]
		public FsmInt rootCount;

		[Tooltip("The scene Root GameObjects")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray rootGameObjects;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		private Scene _scene;

		public override void Reset()
		{
			name = null;
			path = null;
			buildIndex = null;
			isLoaded = null;
			rootCount = null;
			rootGameObjects = null;
			isDirty = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetSceneProperties();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSceneProperties();
		}

		private void DoGetSceneProperties()
		{
			_scene = SendSceneUnloadedEvent.lastUnLoadedScene;
			if (!name.IsNone)
			{
				name.Value = _scene.name;
			}
			if (!buildIndex.IsNone)
			{
				buildIndex.Value = _scene.buildIndex;
			}
			if (!path.IsNone)
			{
				path.Value = _scene.path;
			}
			if (!isValid.IsNone)
			{
				isValid.Value = _scene.IsValid();
			}
			if (!isDirty.IsNone)
			{
				isDirty.Value = _scene.isDirty;
			}
			if (!isLoaded.IsNone)
			{
				isLoaded.Value = _scene.isLoaded;
			}
			if (!rootCount.IsNone)
			{
				rootCount.Value = _scene.rootCount;
			}
			if (!rootGameObjects.IsNone)
			{
				if (_scene.IsValid())
				{
					FsmArray fsmArray = rootGameObjects;
					object[] values = _scene.GetRootGameObjects();
					fsmArray.Values = values;
				}
				else
				{
					rootGameObjects.Resize(0);
				}
			}
		}
	}
	public abstract class GetSceneActionBase : FsmStateAction
	{
		public enum SceneReferenceOptions
		{
			SceneAtIndex,
			SceneByName,
			SceneByPath
		}

		public enum SceneSimpleReferenceOptions
		{
			SceneAtIndex,
			SceneByName
		}

		public enum SceneBuildReferenceOptions
		{
			SceneAtBuildIndex,
			SceneByName
		}

		public enum SceneAllReferenceOptions
		{
			ActiveScene,
			SceneAtIndex,
			SceneByName,
			SceneByPath,
			SceneByGameObject
		}

		[Tooltip("The reference option of the Scene")]
		public SceneAllReferenceOptions sceneReference;

		[Tooltip("The scene Index.")]
		public FsmInt sceneAtIndex;

		[Tooltip("The scene Name.")]
		public FsmString sceneByName;

		[Tooltip("The scene Path.")]
		public FsmString sceneByPath;

		[Tooltip("The Scene of GameObject")]
		public FsmOwnerDefault sceneByGameObject;

		[Tooltip("True if SceneReference resolves to a scene")]
		[UIHint(UIHint.Variable)]
		public FsmBool sceneFound;

		[Tooltip("Event sent if SceneReference resolves to a scene")]
		public FsmEvent sceneFoundEvent;

		[Tooltip("Event sent if SceneReference do not resolve to a scene")]
		public FsmEvent sceneNotFoundEvent;

		[Tooltip("The Scene Cache")]
		protected Scene _scene;

		[Tooltip("True if a scene was found, use _scene to access it")]
		protected bool _sceneFound;

		public override void Reset()
		{
			base.Reset();
			sceneReference = SceneAllReferenceOptions.ActiveScene;
			sceneAtIndex = null;
			sceneByName = null;
			sceneByPath = null;
			sceneByGameObject = null;
			sceneFound = null;
			sceneFoundEvent = null;
			sceneNotFoundEvent = null;
		}

		public override void OnEnter()
		{
			try
			{
				switch (sceneReference)
				{
				case SceneAllReferenceOptions.ActiveScene:
					_scene = SceneManager.GetActiveScene();
					break;
				case SceneAllReferenceOptions.SceneAtIndex:
					_scene = SceneManager.GetSceneAt(sceneAtIndex.Value);
					break;
				case SceneAllReferenceOptions.SceneByName:
					_scene = SceneManager.GetSceneByName(sceneByName.Value);
					break;
				case SceneAllReferenceOptions.SceneByPath:
					_scene = SceneManager.GetSceneByPath(sceneByPath.Value);
					break;
				case SceneAllReferenceOptions.SceneByGameObject:
				{
					GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(sceneByGameObject);
					if (ownerDefaultTarget == null)
					{
						throw new Exception("Null GameObject");
					}
					_scene = ownerDefaultTarget.scene;
					break;
				}
				}
			}
			catch (Exception ex)
			{
				LogError(ex.Message);
			}
			if (_scene == default(Scene))
			{
				_sceneFound = false;
				if (!sceneFound.IsNone)
				{
					sceneFound.Value = false;
				}
				base.Fsm.Event(sceneNotFoundEvent);
			}
			else
			{
				_sceneFound = true;
				if (!sceneFound.IsNone)
				{
					sceneFound.Value = true;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Loads the scene by its name or index in Build Settings. ")]
	public class LoadScene : FsmStateAction
	{
		[Tooltip("The reference options of the Scene")]
		public GetSceneActionBase.SceneSimpleReferenceOptions sceneReference;

		[Tooltip("The name of the scene to load. The given sceneName can either be the last part of the path, without .unity extension or the full path still without the .unity extension")]
		public FsmString sceneByName;

		[Tooltip("The index of the scene to load.")]
		public FsmInt sceneAtIndex;

		[Tooltip("Allows you to specify whether or not to load the scene additively. See LoadSceneMode Unity doc for more information about the options.")]
		[ObjectType(typeof(LoadSceneMode))]
		public FsmEnum loadSceneMode;

		[ActionSection("Result")]
		[Tooltip("True if the scene was loaded")]
		public FsmBool success;

		[Tooltip("Event sent if the scene was loaded")]
		public FsmEvent successEvent;

		[Tooltip("Event sent if a problem occurred, check log for information")]
		public FsmEvent failureEvent;

		public override void Reset()
		{
			sceneReference = GetSceneActionBase.SceneSimpleReferenceOptions.SceneAtIndex;
			sceneByName = null;
			sceneAtIndex = null;
			loadSceneMode = null;
			success = null;
			successEvent = null;
			failureEvent = null;
		}

		public override void OnEnter()
		{
			bool flag = DoLoadScene();
			if (!success.IsNone)
			{
				success.Value = flag;
			}
			if (flag)
			{
				base.Fsm.Event(successEvent);
			}
			else
			{
				base.Fsm.Event(failureEvent);
			}
			Finish();
		}

		private bool DoLoadScene()
		{
			if (sceneReference == GetSceneActionBase.SceneSimpleReferenceOptions.SceneAtIndex)
			{
				if (SceneManager.GetActiveScene().buildIndex == sceneAtIndex.Value)
				{
					return false;
				}
				SceneManager.LoadScene(sceneAtIndex.Value, (LoadSceneMode)(object)loadSceneMode.Value);
			}
			else
			{
				if (SceneManager.GetActiveScene().name == sceneByName.Value)
				{
					return false;
				}
				SceneManager.LoadScene(sceneByName.Value, (LoadSceneMode)(object)loadSceneMode.Value);
			}
			return true;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Loads the scene by its name or index in Build Settings.")]
	public class LoadSceneAsynch : FsmStateAction
	{
		[Tooltip("The reference options of the Scene")]
		public GetSceneActionBase.SceneSimpleReferenceOptions sceneReference;

		[Tooltip("The name of the scene to load. The given sceneName can either be the last part of the path, without .unity extension or the full path still without the .unity extension")]
		public FsmString sceneByName;

		[Tooltip("The index of the scene to load.")]
		public FsmInt sceneAtIndex;

		[Tooltip("Allows you to specify whether or not to load the scene additively. See LoadSceneMode Unity doc for more information about the options.")]
		[ObjectType(typeof(LoadSceneMode))]
		public FsmEnum loadSceneMode;

		[Tooltip("Allow the scene to be activated as soon as it's ready")]
		public FsmBool allowSceneActivation;

		[Tooltip("lets you tweak in which order async operation calls will be performed. Leave to none for default")]
		public FsmInt operationPriority;

		[ActionSection("Result")]
		[Tooltip("Use this hash to activate the Scene if you have set 'AllowSceneActivation' to false, you'll need to use it in the action 'AllowSceneActivation' to effectively load the scene.")]
		[UIHint(UIHint.Variable)]
		public FsmInt aSyncOperationHashCode;

		[Tooltip("The loading's progress.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat progress;

		[Tooltip("True when loading is done")]
		[UIHint(UIHint.Variable)]
		public FsmBool isDone;

		[Tooltip("True when loading is done but still waiting for scene activation")]
		[UIHint(UIHint.Variable)]
		public FsmBool pendingActivation;

		[Tooltip("Event sent when scene loading is done")]
		public FsmEvent doneEvent;

		[Tooltip("Event sent when scene loading is done but scene not yet activated. Use aSyncOperationHashCode value in 'AllowSceneActivation' to proceed")]
		public FsmEvent pendingActivationEvent;

		[Tooltip("Event sent if the scene to load was not found")]
		public FsmEvent sceneNotFoundEvent;

		private AsyncOperation _asyncOperation;

		private int _asynchOperationUid = -1;

		private bool pendingActivationCallBackDone;

		public static Dictionary<int, AsyncOperation> aSyncOperationLUT;

		private static int aSynchUidCounter;

		public override void Reset()
		{
			sceneReference = GetSceneActionBase.SceneSimpleReferenceOptions.SceneAtIndex;
			sceneByName = null;
			sceneAtIndex = null;
			loadSceneMode = null;
			aSyncOperationHashCode = null;
			allowSceneActivation = null;
			operationPriority = new FsmInt
			{
				UseVariable = true
			};
			pendingActivation = null;
			pendingActivationEvent = null;
			isDone = null;
			progress = null;
			doneEvent = null;
			sceneNotFoundEvent = null;
		}

		public override void OnEnter()
		{
			pendingActivationCallBackDone = false;
			pendingActivation.Value = false;
			isDone.Value = false;
			progress.Value = 0f;
			if (!DoLoadAsynch())
			{
				base.Fsm.Event(sceneNotFoundEvent);
				Finish();
			}
		}

		private bool DoLoadAsynch()
		{
			if (sceneReference == GetSceneActionBase.SceneSimpleReferenceOptions.SceneAtIndex)
			{
				if (SceneManager.GetActiveScene().buildIndex == sceneAtIndex.Value)
				{
					return false;
				}
				_asyncOperation = SceneManager.LoadSceneAsync(sceneAtIndex.Value, (LoadSceneMode)(object)loadSceneMode.Value);
			}
			else
			{
				if (SceneManager.GetActiveScene().name == sceneByName.Value)
				{
					return false;
				}
				_asyncOperation = SceneManager.LoadSceneAsync(sceneByName.Value, (LoadSceneMode)(object)loadSceneMode.Value);
			}
			if (!operationPriority.IsNone)
			{
				_asyncOperation.priority = operationPriority.Value;
			}
			_asyncOperation.allowSceneActivation = allowSceneActivation.Value;
			if (!aSyncOperationHashCode.IsNone)
			{
				if (aSyncOperationLUT == null)
				{
					aSyncOperationLUT = new Dictionary<int, AsyncOperation>();
				}
				_asynchOperationUid = ++aSynchUidCounter;
				aSyncOperationHashCode.Value = _asynchOperationUid;
				aSyncOperationLUT.Add(_asynchOperationUid, _asyncOperation);
			}
			return true;
		}

		public override void OnUpdate()
		{
			if (_asyncOperation == null)
			{
				return;
			}
			if (_asyncOperation.isDone)
			{
				isDone.Value = true;
				progress.Value = _asyncOperation.progress;
				if (aSyncOperationLUT != null && _asynchOperationUid != -1)
				{
					aSyncOperationLUT.Remove(_asynchOperationUid);
				}
				_asyncOperation = null;
				base.Fsm.Event(doneEvent);
				Finish();
				return;
			}
			progress.Value = _asyncOperation.progress;
			if (!_asyncOperation.allowSceneActivation && allowSceneActivation.Value)
			{
				_asyncOperation.allowSceneActivation = true;
			}
			if (_asyncOperation.progress == 0.9f && !_asyncOperation.allowSceneActivation && !pendingActivationCallBackDone)
			{
				pendingActivationCallBackDone = true;
				if (!pendingActivation.IsNone)
				{
					pendingActivation.Value = true;
				}
				base.Fsm.Event(pendingActivationEvent);
			}
		}

		public override void OnExit()
		{
			_asyncOperation = null;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("This will merge the source scene into the destinationScene. This function merges the contents of the source scene into the destination scene, and deletes the source scene. All GameObjects at the root of the source scene are moved to the root of the destination scene. NOTE: This function is destructive: The source scene will be destroyed once the merge has been completed.")]
	public class MergeScenes : FsmStateAction
	{
		[ActionSection("Source")]
		[Tooltip("The reference options of the source Scene")]
		public GetSceneActionBase.SceneAllReferenceOptions sourceReference;

		[Tooltip("The source scene Index.")]
		public FsmInt sourceAtIndex;

		[Tooltip("The source scene Name.")]
		public FsmString sourceByName;

		[Tooltip("The source scene Path.")]
		public FsmString sourceByPath;

		[Tooltip("The source scene from GameObject")]
		public FsmOwnerDefault sourceByGameObject;

		[ActionSection("Destination")]
		[Tooltip("The reference options of the destination Scene")]
		public GetSceneActionBase.SceneAllReferenceOptions destinationReference;

		[Tooltip("The destination scene Index.")]
		public FsmInt destinationAtIndex;

		[Tooltip("The destination scene Name.")]
		public FsmString destinationByName;

		[Tooltip("The destination scene Path.")]
		public FsmString destinationByPath;

		[Tooltip("The destination scene from GameObject")]
		public FsmOwnerDefault destinationByGameObject;

		[ActionSection("Result")]
		[Tooltip("True if the merge succeeded")]
		[UIHint(UIHint.Variable)]
		public FsmBool success;

		[Tooltip("Event sent if merge succeeded")]
		public FsmEvent successEvent;

		[Tooltip("Event sent if merge failed")]
		public FsmEvent failureEvent;

		private Scene _sourceScene;

		private bool _sourceFound;

		private Scene _destinationScene;

		private bool _destinationFound;

		public override void Reset()
		{
			sourceReference = GetSceneActionBase.SceneAllReferenceOptions.SceneAtIndex;
			sourceByPath = null;
			sourceByName = null;
			sourceAtIndex = null;
			sourceByGameObject = null;
			destinationReference = GetSceneActionBase.SceneAllReferenceOptions.ActiveScene;
			destinationByPath = null;
			destinationByName = null;
			destinationAtIndex = null;
			destinationByGameObject = null;
			success = null;
			successEvent = null;
			failureEvent = null;
		}

		public override void OnEnter()
		{
			GetSourceScene();
			GetDestinationScene();
			if (_destinationFound && _sourceFound)
			{
				if (_destinationScene.Equals(_sourceScene))
				{
					LogError("Source and Destination scenes can not be the same");
				}
				else
				{
					SceneManager.MergeScenes(_sourceScene, _destinationScene);
				}
				success.Value = true;
				base.Fsm.Event(successEvent);
			}
			else
			{
				success.Value = false;
				base.Fsm.Event(failureEvent);
			}
			Finish();
		}

		private void GetSourceScene()
		{
			try
			{
				switch (sourceReference)
				{
				case GetSceneActionBase.SceneAllReferenceOptions.ActiveScene:
					_sourceScene = SceneManager.GetActiveScene();
					break;
				case GetSceneActionBase.SceneAllReferenceOptions.SceneAtIndex:
					_sourceScene = SceneManager.GetSceneAt(sourceAtIndex.Value);
					break;
				case GetSceneActionBase.SceneAllReferenceOptions.SceneByName:
					_sourceScene = SceneManager.GetSceneByName(sourceByName.Value);
					break;
				case GetSceneActionBase.SceneAllReferenceOptions.SceneByPath:
					_sourceScene = SceneManager.GetSceneByPath(sourceByPath.Value);
					break;
				}
			}
			catch (Exception ex)
			{
				LogError(ex.Message);
			}
			if (_sourceScene == default(Scene))
			{
				_sourceFound = false;
			}
			else
			{
				_sourceFound = true;
			}
		}

		private void GetDestinationScene()
		{
			try
			{
				switch (sourceReference)
				{
				case GetSceneActionBase.SceneAllReferenceOptions.ActiveScene:
					_destinationScene = SceneManager.GetActiveScene();
					break;
				case GetSceneActionBase.SceneAllReferenceOptions.SceneAtIndex:
					_destinationScene = SceneManager.GetSceneAt(destinationAtIndex.Value);
					break;
				case GetSceneActionBase.SceneAllReferenceOptions.SceneByName:
					_destinationScene = SceneManager.GetSceneByName(destinationByName.Value);
					break;
				case GetSceneActionBase.SceneAllReferenceOptions.SceneByPath:
					_destinationScene = SceneManager.GetSceneByPath(destinationByPath.Value);
					break;
				}
			}
			catch (Exception ex)
			{
				LogError(ex.Message);
			}
			if (_destinationScene == default(Scene))
			{
				_destinationFound = false;
			}
			else
			{
				_destinationFound = true;
			}
		}

		public override string ErrorCheck()
		{
			if (sourceReference == GetSceneActionBase.SceneAllReferenceOptions.ActiveScene && destinationReference == GetSceneActionBase.SceneAllReferenceOptions.ActiveScene)
			{
				return "Source and Destination scenes can not be the same";
			}
			return string.Empty;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Move a GameObject from its current scene to a new scene. It is required that the GameObject is at the root of its current scene.")]
	public class MoveGameObjectToScene : GetSceneActionBase
	{
		[RequiredField]
		[Tooltip("The Root GameObject to move to the referenced scene")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Only root GameObject can be moved, set to true to get the root of the gameobject if necessary, else watch for failure events.")]
		public FsmBool findRootIfNecessary;

		[ActionSection("Result")]
		[Tooltip("True if the merge succeeded")]
		[UIHint(UIHint.Variable)]
		public FsmBool success;

		[Tooltip("Event sent if merge succeeded")]
		public FsmEvent successEvent;

		[Tooltip("Event sent if merge failed. Check log for information")]
		public FsmEvent failureEvent;

		private GameObject _go;

		public override void Reset()
		{
			base.Reset();
			gameObject = null;
			findRootIfNecessary = null;
			success = null;
			successEvent = null;
			failureEvent = null;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			if (_sceneFound)
			{
				_go = base.Fsm.GetOwnerDefaultTarget(gameObject);
				if (findRootIfNecessary.Value)
				{
					_go = _go.transform.root.gameObject;
				}
				if (_go.transform.parent == null)
				{
					SceneManager.MoveGameObjectToScene(_go, _scene);
					success.Value = true;
					base.Fsm.Event(successEvent);
				}
				else
				{
					LogError("GameObject must be a root ");
					success.Value = false;
					base.Fsm.Event(failureEvent);
				}
				base.Fsm.Event(sceneFoundEvent);
				_go = null;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Send an event when the active scene has changed.")]
	public class SendActiveSceneChangedEvent : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The event to send when an active scene changed")]
		public FsmEvent activeSceneChanged;

		public static Scene lastPreviousActiveScene;

		public static Scene lastNewActiveScene;

		public override void Reset()
		{
			activeSceneChanged = null;
		}

		public override void OnEnter()
		{
			SceneManager.activeSceneChanged += SceneManager_activeSceneChanged;
			Finish();
		}

		private void SceneManager_activeSceneChanged(Scene previousActiveScene, Scene activeScene)
		{
			lastNewActiveScene = activeScene;
			lastPreviousActiveScene = previousActiveScene;
			base.Fsm.Event(activeSceneChanged);
			Finish();
		}

		public override void OnExit()
		{
			SceneManager.activeSceneChanged -= SceneManager_activeSceneChanged;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Send an event when a scene was loaded. Use the Safe version when you want to access content of the loaded scene. Use GetSceneloadedEventData to find out about the loaded Scene and load mode")]
	public class SendSceneLoadedEvent : FsmStateAction
	{
		[Tooltip("The event to send when a scene was loaded")]
		public FsmEvent sceneLoaded;

		[Tooltip("The event to send when a scene was loaded, with a one frame delay to make sure the scene content was indeed initialized fully")]
		public FsmEvent sceneLoadedSafe;

		public static Scene lastLoadedScene;

		public static LoadSceneMode lastLoadedMode;

		private int _loaded = -1;

		public override void Reset()
		{
			sceneLoaded = null;
		}

		public override void OnEnter()
		{
			_loaded = -1;
			SceneManager.sceneLoaded += SceneManager_sceneLoaded;
		}

		private void SceneManager_sceneLoaded(Scene scene, LoadSceneMode mode)
		{
			lastLoadedScene = scene;
			lastLoadedMode = mode;
			base.Fsm.Event(sceneLoaded);
			_loaded = Time.frameCount;
			if (sceneLoadedSafe == null)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (_loaded > -1 && Time.frameCount > _loaded)
			{
				_loaded = -1;
				base.Fsm.Event(sceneLoadedSafe);
				Finish();
			}
		}

		public override void OnExit()
		{
			SceneManager.sceneLoaded -= SceneManager_sceneLoaded;
		}

		public override string ErrorCheck()
		{
			if (sceneLoaded == null && sceneLoadedSafe == null)
			{
				return "At least one event setup is required";
			}
			return string.Empty;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Send an event when a scene was unloaded.")]
	public class SendSceneUnloadedEvent : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The event to send when scene was unloaded")]
		public FsmEvent sceneUnloaded;

		public static Scene lastUnLoadedScene;

		public override void Reset()
		{
			sceneUnloaded = null;
		}

		public override void OnEnter()
		{
			SceneManager.sceneUnloaded += SceneManager_sceneUnloaded;
			Finish();
		}

		private void SceneManager_sceneUnloaded(Scene scene)
		{
			UnityEngine.Debug.Log(scene.name);
			lastUnLoadedScene = scene;
			base.Fsm.Event(sceneUnloaded);
			Finish();
		}

		public override void OnExit()
		{
			SceneManager.sceneUnloaded -= SceneManager_sceneUnloaded;
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Set the scene to be active.")]
	public class SetActiveScene : FsmStateAction
	{
		public enum SceneReferenceOptions
		{
			SceneAtBuildIndex,
			SceneAtIndex,
			SceneByName,
			SceneByPath,
			SceneByGameObject
		}

		[Tooltip("The reference options of the Scene")]
		public SceneReferenceOptions sceneReference;

		[Tooltip("The name of the scene to activate. The given sceneName can either be the last part of the path, without .unity extension or the full path still without the .unity extension")]
		public FsmString sceneByName;

		[Tooltip("The build index of the scene to activate.")]
		public FsmInt sceneAtBuildIndex;

		[Tooltip("The index of the scene to activate.")]
		public FsmInt sceneAtIndex;

		[Tooltip("The scene Path.")]
		public FsmString sceneByPath;

		[Tooltip("The GameObject scene to activate")]
		public FsmOwnerDefault sceneByGameObject;

		[ActionSection("Result")]
		[Tooltip("True if set active succeeded")]
		[UIHint(UIHint.Variable)]
		public FsmBool success;

		[Tooltip("Event sent if setActive succeeded ")]
		public FsmEvent successEvent;

		[Tooltip("True if SceneReference resolves to a scene")]
		[UIHint(UIHint.Variable)]
		public FsmBool sceneFound;

		[Tooltip("Event sent if scene not activated yet")]
		[UIHint(UIHint.Variable)]
		public FsmEvent sceneNotActivatedEvent;

		[Tooltip("Event sent if SceneReference do not resolve to a scene")]
		public FsmEvent sceneNotFoundEvent;

		private Scene _scene;

		private bool _sceneFound;

		private bool _success;

		public override void Reset()
		{
			sceneReference = SceneReferenceOptions.SceneAtIndex;
			sceneByName = null;
			sceneAtBuildIndex = null;
			sceneAtIndex = null;
			sceneByPath = null;
			sceneByGameObject = null;
			success = null;
			successEvent = null;
			sceneFound = null;
			sceneNotActivatedEvent = null;
			sceneNotFoundEvent = null;
		}

		public override void OnEnter()
		{
			DoSetActivate();
			if (!success.IsNone)
			{
				success.Value = _success;
			}
			if (!sceneFound.IsNone)
			{
				sceneFound.Value = _sceneFound;
			}
			if (_success)
			{
				base.Fsm.Event(successEvent);
			}
		}

		private void DoSetActivate()
		{
			try
			{
				switch (sceneReference)
				{
				case SceneReferenceOptions.SceneAtIndex:
					_scene = SceneManager.GetSceneAt(sceneAtIndex.Value);
					break;
				case SceneReferenceOptions.SceneByName:
					_scene = SceneManager.GetSceneByName(sceneByName.Value);
					break;
				case SceneReferenceOptions.SceneByPath:
					_scene = SceneManager.GetSceneByPath(sceneByPath.Value);
					break;
				case SceneReferenceOptions.SceneByGameObject:
				{
					GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(sceneByGameObject);
					if (ownerDefaultTarget == null)
					{
						throw new Exception("Null GameObject");
					}
					_scene = ownerDefaultTarget.scene;
					break;
				}
				}
			}
			catch (Exception ex)
			{
				LogError(ex.Message);
				_sceneFound = false;
				base.Fsm.Event(sceneNotFoundEvent);
				return;
			}
			if (_scene == default(Scene))
			{
				_sceneFound = false;
				base.Fsm.Event(sceneNotFoundEvent);
			}
			else
			{
				_success = SceneManager.SetActiveScene(_scene);
				_sceneFound = true;
			}
		}
	}
	[Obsolete("Use UnloadSceneAsynch Instead")]
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Unload Scene. Note that assets are currently not unloaded, in order to free up asset memory call Resources.UnloadUnusedAssets.")]
	public class UnloadScene : FsmStateAction
	{
		public enum SceneReferenceOptions
		{
			ActiveScene,
			SceneAtBuildIndex,
			SceneAtIndex,
			SceneByName,
			SceneByPath,
			SceneByGameObject
		}

		[Tooltip("The reference options of the Scene")]
		public SceneReferenceOptions sceneReference;

		[Tooltip("The name of the scene to load. The given sceneName can either be the last part of the path, without .unity extension or the full path still without the .unity extension")]
		public FsmString sceneByName;

		[Tooltip("The build index of the scene to unload.")]
		public FsmInt sceneAtBuildIndex;

		[Tooltip("The index of the scene to unload.")]
		public FsmInt sceneAtIndex;

		[Tooltip("The scene Path.")]
		public FsmString sceneByPath;

		[Tooltip("The GameObject unload scene of")]
		public FsmOwnerDefault sceneByGameObject;

		[ActionSection("Result")]
		[Tooltip("True if scene was unloaded")]
		[UIHint(UIHint.Variable)]
		public FsmBool unloaded;

		[Tooltip("Event sent if scene was unloaded ")]
		public FsmEvent unloadedEvent;

		[Tooltip("Event sent scene was not unloaded")]
		[UIHint(UIHint.Variable)]
		public FsmEvent failureEvent;

		public override void Reset()
		{
			sceneReference = SceneReferenceOptions.SceneAtBuildIndex;
			sceneByName = null;
			sceneAtBuildIndex = null;
			sceneAtIndex = null;
			sceneByPath = null;
			sceneByGameObject = null;
			unloaded = null;
			unloadedEvent = null;
			failureEvent = null;
		}

		public override void OnEnter()
		{
			bool flag = false;
			try
			{
				switch (sceneReference)
				{
				case SceneReferenceOptions.ActiveScene:
					flag = SceneManager.UnloadScene(SceneManager.GetActiveScene());
					break;
				case SceneReferenceOptions.SceneAtBuildIndex:
					flag = SceneManager.UnloadScene(sceneAtBuildIndex.Value);
					break;
				case SceneReferenceOptions.SceneAtIndex:
					flag = SceneManager.UnloadScene(SceneManager.GetSceneAt(sceneAtIndex.Value));
					break;
				case SceneReferenceOptions.SceneByName:
					flag = SceneManager.UnloadScene(sceneByName.Value);
					break;
				case SceneReferenceOptions.SceneByPath:
					flag = SceneManager.UnloadScene(SceneManager.GetSceneByPath(sceneByPath.Value));
					break;
				case SceneReferenceOptions.SceneByGameObject:
				{
					GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(sceneByGameObject);
					if (ownerDefaultTarget == null)
					{
						throw new Exception("Null GameObject");
					}
					flag = SceneManager.UnloadScene(ownerDefaultTarget.scene);
					break;
				}
				}
			}
			catch (Exception ex)
			{
				LogError(ex.Message);
			}
			if (!unloaded.IsNone)
			{
				unloaded.Value = flag;
			}
			if (flag)
			{
				base.Fsm.Event(unloadedEvent);
			}
			else
			{
				base.Fsm.Event(failureEvent);
			}
			Finish();
		}

		public override string ErrorCheck()
		{
			return sceneReference switch
			{
				_ => string.Empty, 
			};
		}
	}
	[ActionCategory(ActionCategory.Scene)]
	[Tooltip("Unload a scene asynchronously by its name or index in Build Settings. Destroys all GameObjects associated with the given scene and removes the scene from the SceneManager.")]
	public class UnloadSceneAsynch : FsmStateAction
	{
		public enum SceneReferenceOptions
		{
			ActiveScene,
			SceneAtBuildIndex,
			SceneAtIndex,
			SceneByName,
			SceneByPath,
			SceneByGameObject
		}

		[Tooltip("The reference options of the Scene")]
		public SceneReferenceOptions sceneReference;

		[Tooltip("The name of the scene to load. The given sceneName can either be the last part of the path, without .unity extension or the full path still without the .unity extension")]
		public FsmString sceneByName;

		[Tooltip("The build index of the scene to unload.")]
		public FsmInt sceneAtBuildIndex;

		[Tooltip("The index of the scene to unload.")]
		public FsmInt sceneAtIndex;

		[Tooltip("The scene Path.")]
		public FsmString sceneByPath;

		[Tooltip("The GameObject unload scene of")]
		public FsmOwnerDefault sceneByGameObject;

		[Tooltip("lets you tweak in which order async operation calls will be performed. Leave to none for default")]
		public FsmInt operationPriority;

		[ActionSection("Result")]
		[Tooltip("The loading's progress.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat progress;

		[Tooltip("True when loading is done")]
		[UIHint(UIHint.Variable)]
		public FsmBool isDone;

		[Tooltip("Event sent when scene loading is done")]
		public FsmEvent doneEvent;

		[Tooltip("Event sent if the scene to load was not found")]
		public FsmEvent sceneNotFoundEvent;

		private AsyncOperation _asyncOperation;

		public override void Reset()
		{
			sceneReference = SceneReferenceOptions.SceneAtBuildIndex;
			sceneByName = null;
			sceneAtBuildIndex = null;
			sceneAtIndex = null;
			sceneByPath = null;
			sceneByGameObject = null;
			operationPriority = new FsmInt
			{
				UseVariable = true
			};
			isDone = null;
			progress = null;
			doneEvent = null;
			sceneNotFoundEvent = null;
		}

		public override void OnEnter()
		{
			isDone.Value = false;
			progress.Value = 0f;
			if (!DoUnLoadAsynch())
			{
				base.Fsm.Event(sceneNotFoundEvent);
				Finish();
			}
		}

		private bool DoUnLoadAsynch()
		{
			try
			{
				switch (sceneReference)
				{
				case SceneReferenceOptions.ActiveScene:
					_asyncOperation = SceneManager.UnloadSceneAsync(SceneManager.GetActiveScene());
					break;
				case SceneReferenceOptions.SceneAtBuildIndex:
					_asyncOperation = SceneManager.UnloadSceneAsync(sceneAtBuildIndex.Value);
					break;
				case SceneReferenceOptions.SceneAtIndex:
					_asyncOperation = SceneManager.UnloadSceneAsync(SceneManager.GetSceneAt(sceneAtIndex.Value));
					break;
				case SceneReferenceOptions.SceneByName:
					_asyncOperation = SceneManager.UnloadSceneAsync(sceneByName.Value);
					break;
				case SceneReferenceOptions.SceneByPath:
					_asyncOperation = SceneManager.UnloadSceneAsync(SceneManager.GetSceneByPath(sceneByPath.Value));
					break;
				case SceneReferenceOptions.SceneByGameObject:
				{
					GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(sceneByGameObject);
					if (ownerDefaultTarget == null)
					{
						throw new Exception("Null GameObject");
					}
					_asyncOperation = SceneManager.UnloadSceneAsync(ownerDefaultTarget.scene);
					break;
				}
				}
			}
			catch (Exception ex)
			{
				LogError(ex.Message);
				return false;
			}
			if (!operationPriority.IsNone)
			{
				_asyncOperation.priority = operationPriority.Value;
			}
			return true;
		}

		public override void OnUpdate()
		{
			if (_asyncOperation != null)
			{
				if (_asyncOperation.isDone)
				{
					isDone.Value = true;
					progress.Value = _asyncOperation.progress;
					_asyncOperation = null;
					base.Fsm.Event(doneEvent);
					Finish();
				}
				else
				{
					progress.Value = _asyncOperation.progress;
				}
			}
		}

		public override void OnExit()
		{
			_asyncOperation = null;
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Adds a Script to a Game Object. Use this to change the behaviour of objects on the fly. Optionally remove the Script on exiting the state.")]
	public class AddScript : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to add the script to.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The Script to add to the GameObject.")]
		[UIHint(UIHint.ScriptComponent)]
		public FsmString script;

		[Tooltip("Remove the script from the GameObject when this State is exited.")]
		public FsmBool removeOnExit;

		private Component addedComponent;

		public override void Reset()
		{
			gameObject = null;
			script = null;
		}

		public override void OnEnter()
		{
			DoAddComponent((gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : gameObject.GameObject.Value);
			Finish();
		}

		public override void OnExit()
		{
			if (removeOnExit.Value && addedComponent != null)
			{
				UnityEngine.Object.Destroy(addedComponent);
			}
		}

		private void DoAddComponent(GameObject go)
		{
			addedComponent = go.AddComponent(ReflectionUtils.GetGlobalType(script.Value));
			if (addedComponent == null)
			{
				LogError("Can't add script: " + script.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Input)]
	[Tooltip("Sends events based on the direction of Input Axis (Left/Right/Up/Down...).")]
	public class AxisEvent : FsmStateAction
	{
		[Tooltip("Horizontal axis as defined in the Input Manager")]
		public FsmString horizontalAxis;

		[Tooltip("Vertical axis as defined in the Input Manager")]
		public FsmString verticalAxis;

		[Tooltip("Event to send if input is to the left.")]
		public FsmEvent leftEvent;

		[Tooltip("Event to send if input is to the right.")]
		public FsmEvent rightEvent;

		[Tooltip("Event to send if input is to the up.")]
		public FsmEvent upEvent;

		[Tooltip("Event to send if input is to the down.")]
		public FsmEvent downEvent;

		[Tooltip("Event to send if input is in any direction.")]
		public FsmEvent anyDirection;

		[Tooltip("Event to send if no axis input (centered).")]
		public FsmEvent noDirection;

		public override void Reset()
		{
			horizontalAxis = "Horizontal";
			verticalAxis = "Vertical";
			leftEvent = null;
			rightEvent = null;
			upEvent = null;
			downEvent = null;
			anyDirection = null;
			noDirection = null;
		}

		public override void OnUpdate()
		{
			float num = ((horizontalAxis.Value != "") ? Input.GetAxis(horizontalAxis.Value) : 0f);
			float num2 = ((verticalAxis.Value != "") ? Input.GetAxis(verticalAxis.Value) : 0f);
			if ((num * num + num2 * num2).Equals(0f))
			{
				if (noDirection != null)
				{
					base.Fsm.Event(noDirection);
				}
				return;
			}
			float num3 = Mathf.Atan2(num2, num) * 57.29578f + 45f;
			if (num3 < 0f)
			{
				num3 += 360f;
			}
			int num4 = (int)(num3 / 90f);
			if (num4 == 0 && rightEvent != null)
			{
				base.Fsm.Event(rightEvent);
			}
			else if (num4 == 1 && upEvent != null)
			{
				base.Fsm.Event(upEvent);
			}
			else if (num4 == 2 && leftEvent != null)
			{
				base.Fsm.Event(leftEvent);
			}
			else if (num4 == 3 && downEvent != null)
			{
				base.Fsm.Event(downEvent);
			}
			else if (anyDirection != null)
			{
				base.Fsm.Event(anyDirection);
			}
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Call a method in a component on a GameObject.")]
	public class CallMethod : FsmStateAction
	{
		[ObjectType(typeof(Component))]
		[Tooltip("The behaviour on a GameObject that has the method you want to call. Drag the script component from the Unity inspector into this slot. HINT: Use Lock if the script is on another GameObject.\n\nNOTE: Unity Object fields only show the GameObject name, so for clarity we show the Behaviour name in a readonly field below.")]
		public FsmObject behaviour;

		[Tooltip("Name of the method to call on the component")]
		public FsmString methodName;

		[Tooltip("Method parameters. NOTE: these must match the method's signature!")]
		public FsmVar[] parameters;

		[ActionSection("Store Result")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result of the method call.")]
		public FsmVar storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[Tooltip("Use the old manual editor UI.")]
		public bool manualUI;

		private FsmObject cachedBehaviour;

		private FsmString cachedMethodName;

		private Type cachedType;

		private MethodInfo cachedMethodInfo;

		private ParameterInfo[] cachedParameterInfo;

		private object[] parametersArray;

		private string errorString;

		public override void Reset()
		{
			behaviour = null;
			methodName = null;
			parameters = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			parametersArray = new object[parameters.Length];
			DoMethodCall();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMethodCall();
		}

		private void DoMethodCall()
		{
			if (behaviour.Value == null)
			{
				Finish();
				return;
			}
			if (NeedToUpdateCache() && !DoCache())
			{
				UnityEngine.Debug.LogError(errorString);
				Finish();
				return;
			}
			object value;
			if (cachedParameterInfo.Length == 0)
			{
				value = cachedMethodInfo.Invoke(cachedBehaviour.Value, null);
			}
			else
			{
				for (int i = 0; i < parameters.Length; i++)
				{
					FsmVar fsmVar = parameters[i];
					fsmVar.UpdateValue();
					if (fsmVar.Type == VariableType.Array)
					{
						fsmVar.UpdateValue();
						object[] array = fsmVar.GetValue() as object[];
						Array array2 = Array.CreateInstance(cachedParameterInfo[i].ParameterType.GetElementType(), array.Length);
						for (int j = 0; j < array.Length; j++)
						{
							array2.SetValue(array[j], j);
						}
						parametersArray[i] = array2;
					}
					else
					{
						fsmVar.UpdateValue();
						parametersArray[i] = fsmVar.GetValue();
					}
				}
				value = cachedMethodInfo.Invoke(cachedBehaviour.Value, parametersArray);
			}
			if (storeResult != null && !storeResult.IsNone && storeResult.Type != VariableType.Unknown)
			{
				storeResult.SetValue(value);
			}
		}

		private bool NeedToUpdateCache()
		{
			if (cachedBehaviour != null && cachedMethodName != null && !(cachedBehaviour.Value != behaviour.Value) && !(cachedBehaviour.Name != behaviour.Name) && !(cachedMethodName.Value != methodName.Value))
			{
				return cachedMethodName.Name != methodName.Name;
			}
			return true;
		}

		private void ClearCache()
		{
			cachedBehaviour = null;
			cachedMethodName = null;
			cachedType = null;
			cachedMethodInfo = null;
			cachedParameterInfo = null;
		}

		private bool DoCache()
		{
			ClearCache();
			errorString = string.Empty;
			cachedBehaviour = new FsmObject(behaviour);
			cachedMethodName = new FsmString(methodName);
			if (cachedBehaviour.Value == null)
			{
				if (!behaviour.UsesVariable || UnityEngine.Application.isPlaying)
				{
					errorString += "Behaviour is invalid!\n";
				}
				Finish();
				return false;
			}
			cachedType = behaviour.Value.GetType();
			List<Type> list = new List<Type>(parameters.Length);
			FsmVar[] array = parameters;
			foreach (FsmVar fsmVar in array)
			{
				list.Add(fsmVar.RealType);
			}
			cachedMethodInfo = cachedType.GetMethod(methodName.Value, list.ToArray());
			if (cachedMethodInfo == null)
			{
				errorString = errorString + "Invalid Method Name or Parameters: " + methodName.Value + "\n";
				Finish();
				return false;
			}
			cachedParameterInfo = cachedMethodInfo.GetParameters();
			return true;
		}

		public override string ErrorCheck()
		{
			if (UnityEngine.Application.isPlaying)
			{
				return errorString;
			}
			if (!DoCache())
			{
				return errorString;
			}
			if (parameters.Length != cachedParameterInfo.Length)
			{
				return "Parameter count does not match method.\nMethod has " + cachedParameterInfo.Length + " parameters.\nYou specified " + parameters.Length + " paramaters.";
			}
			for (int i = 0; i < parameters.Length; i++)
			{
				Type realType = parameters[i].RealType;
				Type parameterType = cachedParameterInfo[i].ParameterType;
				if ((object)realType != parameterType)
				{
					return string.Concat("Parameters do not match method signature.\nParameter ", i + 1, " (", realType, ") should be of type: ", parameterType);
				}
			}
			if ((object)cachedMethodInfo.ReturnType == typeof(void))
			{
				if (!string.IsNullOrEmpty(storeResult.variableName))
				{
					return "Method does not have return.\nSpecify 'none' in Store Result.";
				}
			}
			else if ((object)cachedMethodInfo.ReturnType != storeResult.RealType)
			{
				return "Store Result is of the wrong type.\nIt should be of type: " + cachedMethodInfo.ReturnType;
			}
			return string.Empty;
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Call a static method in a class.")]
	public class CallStaticMethod : FsmStateAction
	{
		[Tooltip("Full path to the class that contains the static method.")]
		public FsmString className;

		[Tooltip("The static method to call.")]
		public FsmString methodName;

		[Tooltip("Method parameters. NOTE: these must match the method's signature!")]
		public FsmVar[] parameters;

		[ActionSection("Store Result")]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result of the method call.")]
		public FsmVar storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private Type cachedType;

		private string cachedClassName;

		private string cachedMethodName;

		private MethodInfo cachedMethodInfo;

		private ParameterInfo[] cachedParameterInfo;

		private object[] parametersArray;

		private string errorString;

		public override void OnEnter()
		{
			parametersArray = new object[parameters.Length];
			DoMethodCall();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoMethodCall();
		}

		private void DoMethodCall()
		{
			if (className == null || string.IsNullOrEmpty(className.Value))
			{
				Finish();
				return;
			}
			if (cachedClassName != className.Value || cachedMethodName != methodName.Value)
			{
				errorString = string.Empty;
				if (!DoCache())
				{
					UnityEngine.Debug.LogError(errorString);
					Finish();
					return;
				}
			}
			object obj = null;
			if (cachedParameterInfo.Length == 0)
			{
				obj = cachedMethodInfo.Invoke(null, null);
			}
			else
			{
				for (int i = 0; i < parameters.Length; i++)
				{
					FsmVar fsmVar = parameters[i];
					fsmVar.UpdateValue();
					parametersArray[i] = fsmVar.GetValue();
				}
				obj = cachedMethodInfo.Invoke(null, parametersArray);
			}
			storeResult.SetValue(obj);
		}

		private bool DoCache()
		{
			cachedType = ReflectionUtils.GetGlobalType(className.Value);
			if (cachedType == null)
			{
				errorString = errorString + "Class is invalid: " + className.Value + "\n";
				Finish();
				return false;
			}
			cachedClassName = className.Value;
			List<Type> list = new List<Type>(parameters.Length);
			FsmVar[] array = parameters;
			foreach (FsmVar fsmVar in array)
			{
				list.Add(fsmVar.RealType);
			}
			cachedMethodInfo = cachedType.GetMethod(methodName.Value, list.ToArray());
			if (cachedMethodInfo == null)
			{
				errorString = errorString + "Invalid Method Name or Parameters: " + methodName.Value + "\n";
				Finish();
				return false;
			}
			cachedMethodName = methodName.Value;
			cachedParameterInfo = cachedMethodInfo.GetParameters();
			return true;
		}

		public override string ErrorCheck()
		{
			errorString = string.Empty;
			DoCache();
			if (!string.IsNullOrEmpty(errorString))
			{
				return errorString;
			}
			if (parameters.Length != cachedParameterInfo.Length)
			{
				return "Parameter count does not match method.\nMethod has " + cachedParameterInfo.Length + " parameters.\nYou specified " + parameters.Length + " paramaters.";
			}
			for (int i = 0; i < parameters.Length; i++)
			{
				Type realType = parameters[i].RealType;
				Type parameterType = cachedParameterInfo[i].ParameterType;
				if ((object)realType != parameterType)
				{
					return string.Concat("Parameters do not match method signature.\nParameter ", i + 1, " (", realType, ") should be of type: ", parameterType);
				}
			}
			if ((object)cachedMethodInfo.ReturnType == typeof(void))
			{
				if (!string.IsNullOrEmpty(storeResult.variableName))
				{
					return "Method does not have return.\nSpecify 'none' in Store Result.";
				}
			}
			else if ((object)cachedMethodInfo.ReturnType != storeResult.RealType)
			{
				return "Store Result is of the wrong type.\nIt should be of type: " + cachedMethodInfo.ReturnType;
			}
			return string.Empty;
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Enables/Disables a Behaviour on a GameObject. Optionally reset the Behaviour on exit - useful if you want the Behaviour to be active only while this state is active.")]
	public class EnableBehaviour : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the Behaviour.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Behaviour)]
		[Tooltip("The name of the Behaviour to enable/disable.")]
		public FsmString behaviour;

		[Tooltip("Optionally drag a component directly into this field (behavior name will be ignored).")]
		public Component component;

		[RequiredField]
		[Tooltip("Set to True to enable, False to disable.")]
		public FsmBool enable;

		public FsmBool resetOnExit;

		private Behaviour componentTarget;

		public override void Reset()
		{
			gameObject = null;
			behaviour = null;
			component = null;
			enable = true;
			resetOnExit = true;
		}

		public override void OnEnter()
		{
			DoEnableBehaviour(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private void DoEnableBehaviour(GameObject go)
		{
			if (!(go == null))
			{
				if (component != null)
				{
					componentTarget = component as Behaviour;
				}
				else
				{
					componentTarget = go.GetComponent(ReflectionUtils.GetGlobalType(behaviour.Value)) as Behaviour;
				}
				if (componentTarget == null)
				{
					LogWarning(" " + go.name + " missing behaviour: " + behaviour.Value);
				}
				else
				{
					componentTarget.enabled = enable.Value;
				}
			}
		}

		public override void OnExit()
		{
			if (!(componentTarget == null) && resetOnExit.Value)
			{
				componentTarget.enabled = !enable.Value;
			}
		}

		public override string ErrorCheck()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null || component != null || behaviour.IsNone || string.IsNullOrEmpty(behaviour.Value))
			{
				return null;
			}
			if (!(ownerDefaultTarget.GetComponent(ReflectionUtils.GetGlobalType(behaviour.Value)) as Behaviour != null))
			{
				return "Behaviour missing";
			}
			return null;
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Invokes a Method in a Behaviour attached to a Game Object. See Unity InvokeMethod docs.")]
	public class InvokeMethod : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The game object that owns the behaviour.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Script)]
		[Tooltip("The behaviour that contains the method.")]
		public FsmString behaviour;

		[RequiredField]
		[UIHint(UIHint.Method)]
		[Tooltip("The name of the method to invoke.")]
		public FsmString methodName;

		[HasFloatSlider(0f, 10f)]
		[Tooltip("Optional time delay in seconds.")]
		public FsmFloat delay;

		[Tooltip("Call the method repeatedly.")]
		public FsmBool repeating;

		[HasFloatSlider(0f, 10f)]
		[Tooltip("Delay between repeated calls in seconds.")]
		public FsmFloat repeatDelay;

		[Tooltip("Stop calling the method when the state is exited.")]
		public FsmBool cancelOnExit;

		private MonoBehaviour component;

		public override void Reset()
		{
			gameObject = null;
			behaviour = null;
			methodName = "";
			delay = null;
			repeating = false;
			repeatDelay = 1f;
			cancelOnExit = false;
		}

		public override void OnEnter()
		{
			DoInvokeMethod(base.Fsm.GetOwnerDefaultTarget(gameObject));
			Finish();
		}

		private void DoInvokeMethod(GameObject go)
		{
			if (!(go == null))
			{
				component = go.GetComponent(ReflectionUtils.GetGlobalType(behaviour.Value)) as MonoBehaviour;
				if (component == null)
				{
					LogWarning("InvokeMethod: " + go.name + " missing behaviour: " + behaviour.Value);
				}
				else if (repeating.Value)
				{
					component.InvokeRepeating(methodName.Value, delay.Value, repeatDelay.Value);
				}
				else
				{
					component.Invoke(methodName.Value, delay.Value);
				}
			}
		}

		public override void OnExit()
		{
			if (!(component == null) && cancelOnExit.Value)
			{
				component.CancelInvoke(methodName.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Sends a Message to a Game Object. See Unity docs for SendMessage.")]
	public class SendMessage : FsmStateAction
	{
		public enum MessageType
		{
			SendMessage,
			SendMessageUpwards,
			BroadcastMessage
		}

		[RequiredField]
		[Tooltip("GameObject that sends the message.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the message.\nSee Unity docs.")]
		public MessageType delivery;

		[Tooltip("Send options.\nSee Unity docs.")]
		public SendMessageOptions options;

		[RequiredField]
		public FunctionCall functionCall;

		public override void Reset()
		{
			gameObject = null;
			delivery = MessageType.SendMessage;
			options = SendMessageOptions.DontRequireReceiver;
			functionCall = null;
		}

		public override void OnEnter()
		{
			DoSendMessage();
			Finish();
		}

		private void DoSendMessage()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				object obj = null;
				switch (functionCall.ParameterType)
				{
				case "bool":
					obj = functionCall.BoolParameter.Value;
					break;
				case "int":
					obj = functionCall.IntParameter.Value;
					break;
				case "float":
					obj = functionCall.FloatParameter.Value;
					break;
				case "string":
					obj = functionCall.StringParameter.Value;
					break;
				case "Vector2":
					obj = functionCall.Vector2Parameter.Value;
					break;
				case "Vector3":
					obj = functionCall.Vector3Parameter.Value;
					break;
				case "Rect":
					obj = functionCall.RectParamater.Value;
					break;
				case "GameObject":
					obj = functionCall.GameObjectParameter.Value;
					break;
				case "Material":
					obj = functionCall.MaterialParameter.Value;
					break;
				case "Texture":
					obj = functionCall.TextureParameter.Value;
					break;
				case "Color":
					obj = functionCall.ColorParameter.Value;
					break;
				case "Quaternion":
					obj = functionCall.QuaternionParameter.Value;
					break;
				case "Object":
					obj = functionCall.ObjectParameter.Value;
					break;
				case "Enum":
					obj = functionCall.EnumParameter.Value;
					break;
				case "Array":
					obj = functionCall.ArrayParameter.Values;
					break;
				}
				switch (delivery)
				{
				case MessageType.SendMessage:
					ownerDefaultTarget.SendMessage(functionCall.FunctionName, obj, options);
					break;
				case MessageType.SendMessageUpwards:
					ownerDefaultTarget.SendMessageUpwards(functionCall.FunctionName, obj, options);
					break;
				case MessageType.BroadcastMessage:
					ownerDefaultTarget.BroadcastMessage(functionCall.FunctionName, obj, options);
					break;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.ScriptControl)]
	[Tooltip("Start a Coroutine in a Behaviour on a Game Object. See Unity StartCoroutine docs.")]
	public class StartCoroutine : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The game object that owns the Behaviour.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Behaviour)]
		[Tooltip("The Behaviour that contains the method to start as a coroutine.")]
		public FsmString behaviour;

		[RequiredField]
		[UIHint(UIHint.Coroutine)]
		[Tooltip("The name of the coroutine method.")]
		public FunctionCall functionCall;

		[Tooltip("Stop the coroutine when the state is exited.")]
		public bool stopOnExit;

		private MonoBehaviour component;

		public override void Reset()
		{
			gameObject = null;
			behaviour = null;
			functionCall = null;
			stopOnExit = false;
		}

		public override void OnEnter()
		{
			DoStartCoroutine();
			Finish();
		}

		private void DoStartCoroutine()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			component = ownerDefaultTarget.GetComponent(ReflectionUtils.GetGlobalType(behaviour.Value)) as MonoBehaviour;
			if (component == null)
			{
				LogWarning("StartCoroutine: " + ownerDefaultTarget.name + " missing behaviour: " + behaviour.Value);
				return;
			}
			switch (functionCall.ParameterType)
			{
			case "None":
				component.StartCoroutine(functionCall.FunctionName);
				break;
			case "int":
				component.StartCoroutine(functionCall.FunctionName, functionCall.IntParameter.Value);
				break;
			case "float":
				component.StartCoroutine(functionCall.FunctionName, functionCall.FloatParameter.Value);
				break;
			case "string":
				component.StartCoroutine(functionCall.FunctionName, functionCall.StringParameter.Value);
				break;
			case "bool":
				component.StartCoroutine(functionCall.FunctionName, functionCall.BoolParameter.Value);
				break;
			case "Vector2":
				component.StartCoroutine(functionCall.FunctionName, functionCall.Vector2Parameter.Value);
				break;
			case "Vector3":
				component.StartCoroutine(functionCall.FunctionName, functionCall.Vector3Parameter.Value);
				break;
			case "Rect":
				component.StartCoroutine(functionCall.FunctionName, functionCall.RectParamater.Value);
				break;
			case "GameObject":
				component.StartCoroutine(functionCall.FunctionName, functionCall.GameObjectParameter.Value);
				break;
			case "Material":
				component.StartCoroutine(functionCall.FunctionName, functionCall.MaterialParameter.Value);
				break;
			case "Texture":
				component.StartCoroutine(functionCall.FunctionName, functionCall.TextureParameter.Value);
				break;
			case "Quaternion":
				component.StartCoroutine(functionCall.FunctionName, functionCall.QuaternionParameter.Value);
				break;
			case "Object":
				component.StartCoroutine(functionCall.FunctionName, functionCall.ObjectParameter.Value);
				break;
			}
		}

		public override void OnExit()
		{
			if (!(component == null) && stopOnExit)
			{
				component.StopCoroutine(functionCall.FunctionName);
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	public abstract class BaseFsmVariableAction : FsmStateAction
	{
		[ActionSection("Events")]
		[Tooltip("The event to send if the FSM is not found.")]
		public FsmEvent fsmNotFound;

		[Tooltip("The event to send if the Variable is not found.")]
		public FsmEvent variableNotFound;

		private GameObject cachedGameObject;

		private string cachedFsmName;

		protected PlayMakerFSM fsm;

		public override void Reset()
		{
			fsmNotFound = null;
			variableNotFound = null;
		}

		protected bool UpdateCache(GameObject go, string fsmName)
		{
			if (go == null)
			{
				return false;
			}
			if (fsm == null || cachedGameObject != go || cachedFsmName != fsmName)
			{
				fsm = ActionHelpers.GetGameObjectFsm(go, fsmName);
				cachedGameObject = go;
				cachedFsmName = fsmName;
				if (fsm == null)
				{
					LogWarning("Could not find FSM: " + fsmName);
					base.Fsm.Event(fsmNotFound);
				}
			}
			return true;
		}

		protected void DoVariableNotFound(string variableName)
		{
			LogWarning("Could not find variable: " + variableName);
			base.Fsm.Event(variableNotFound);
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	public abstract class BaseFsmVariableIndexAction : FsmStateAction
	{
		[ActionSection("Events")]
		[Tooltip("The event to trigger if the index is out of range")]
		public FsmEvent indexOutOfRange;

		[Tooltip("The event to send if the FSM is not found.")]
		public FsmEvent fsmNotFound;

		[Tooltip("The event to send if the Variable is not found.")]
		public FsmEvent variableNotFound;

		private GameObject cachedGameObject;

		private string cachedFsmName;

		protected PlayMakerFSM fsm;

		public override void Reset()
		{
			fsmNotFound = null;
			variableNotFound = null;
		}

		protected bool UpdateCache(GameObject go, string fsmName)
		{
			if (go == null)
			{
				return false;
			}
			if (fsm == null || cachedGameObject != go || cachedFsmName != fsmName)
			{
				fsm = ActionHelpers.GetGameObjectFsm(go, fsmName);
				cachedGameObject = go;
				cachedFsmName = fsmName;
				if (fsm == null)
				{
					LogWarning("Could not find FSM: " + fsmName);
					base.Fsm.Event(fsmNotFound);
				}
			}
			return true;
		}

		protected void DoVariableNotFound(string variableName)
		{
			LogWarning("Could not find variable: " + variableName);
			base.Fsm.Event(variableNotFound);
		}
	}
	[Obsolete("This action is obsolete; use Send Event with Event Target instead.")]
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sends an Event to all FSMs in the scene or to all FSMs on a Game Object.\nNOTE: This action won't work on the very first frame of the game...")]
	public class BroadcastEvent : FsmStateAction
	{
		[RequiredField]
		public FsmString broadcastEvent;

		[Tooltip("Optionally specify a game object to broadcast the event to all FSMs on that game object.")]
		public FsmGameObject gameObject;

		[Tooltip("Broadcast to all FSMs on the game object's children.")]
		public FsmBool sendToChildren;

		public FsmBool excludeSelf;

		public override void Reset()
		{
			broadcastEvent = null;
			gameObject = null;
			sendToChildren = false;
			excludeSelf = false;
		}

		public override void OnEnter()
		{
			if (!string.IsNullOrEmpty(broadcastEvent.Value))
			{
				if (gameObject.Value != null)
				{
					base.Fsm.BroadcastEventToGameObject(gameObject.Value, broadcastEvent.Value, sendToChildren.Value, excludeSelf.Value);
				}
				else
				{
					base.Fsm.BroadcastEvent(broadcastEvent.Value, excludeSelf.Value);
				}
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Enables/Disables an FSM component on a GameObject.")]
	public class EnableFSM : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on GameObject. Useful if you have more than one FSM on a GameObject.")]
		public FsmString fsmName;

		[Tooltip("Set to True to enable, False to disable.")]
		public FsmBool enable;

		[Tooltip("Reset the initial enabled state when exiting the state.")]
		public FsmBool resetOnExit;

		private PlayMakerFSM fsmComponent;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			enable = true;
			resetOnExit = true;
		}

		public override void OnEnter()
		{
			DoEnableFSM();
			Finish();
		}

		private void DoEnableFSM()
		{
			GameObject gameObject = ((this.gameObject.OwnerOption == OwnerDefaultOption.UseOwner) ? base.Owner : this.gameObject.GameObject.Value);
			if (gameObject == null)
			{
				return;
			}
			if (!string.IsNullOrEmpty(fsmName.Value))
			{
				PlayMakerFSM[] components = gameObject.GetComponents<PlayMakerFSM>();
				foreach (PlayMakerFSM playMakerFSM in components)
				{
					if (playMakerFSM.FsmName == fsmName.Value)
					{
						fsmComponent = playMakerFSM;
						break;
					}
				}
			}
			else
			{
				fsmComponent = gameObject.GetComponent<PlayMakerFSM>();
			}
			if (fsmComponent == null)
			{
				LogError("Missing FsmComponent!");
			}
			else
			{
				fsmComponent.enabled = enable.Value;
			}
		}

		public override void OnExit()
		{
			if (!(fsmComponent == null) && resetOnExit.Value)
			{
				fsmComponent.enabled = !enable.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Note("Stop this FSM. If this FSM was launched by a Run FSM action, it will trigger a Finish event in that state.")]
	[Tooltip("Stop this FSM. If this FSM was launched by a Run FSM action, it will trigger a Finish event in that state.")]
	public class FinishFSM : FsmStateAction
	{
		public override void OnEnter()
		{
			base.Fsm.Stop();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Forwards all event received by this FSM to another target. Optionally specify a list of events to ignore.")]
	public class ForwardAllEvents : FsmStateAction
	{
		[Tooltip("Forward to this target.")]
		public FsmEventTarget forwardTo;

		[Tooltip("Don't forward these events.")]
		public FsmEvent[] exceptThese;

		[Tooltip("Should this action eat the events or pass them on.")]
		public bool eatEvents;

		public override void Reset()
		{
			forwardTo = new FsmEventTarget
			{
				target = FsmEventTarget.EventTarget.FSMComponent
			};
			exceptThese = new FsmEvent[1] { FsmEvent.Finished };
			eatEvents = true;
		}

		public override bool Event(FsmEvent fsmEvent)
		{
			if (exceptThese != null)
			{
				FsmEvent[] array = exceptThese;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == fsmEvent)
					{
						return false;
					}
				}
			}
			base.Fsm.Event(forwardTo, fsmEvent);
			return eatEvents;
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Forward an event received by this FSM to another target.")]
	public class ForwardEvent : FsmStateAction
	{
		[Tooltip("Forward to this target.")]
		public FsmEventTarget forwardTo;

		[Tooltip("The events to forward.")]
		public FsmEvent[] eventsToForward;

		[Tooltip("Should this action eat the events or pass them on.")]
		public bool eatEvents;

		public override void Reset()
		{
			forwardTo = new FsmEventTarget
			{
				target = FsmEventTarget.EventTarget.FSMComponent
			};
			eventsToForward = null;
			eatEvents = true;
		}

		public override bool Event(FsmEvent fsmEvent)
		{
			if (eventsToForward != null)
			{
				FsmEvent[] array = eventsToForward;
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i] == fsmEvent)
					{
						base.Fsm.Event(forwardTo, fsmEvent);
						return eatEvents;
					}
				}
			}
			return false;
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the Bool data from the last Event.")]
	public class GetEventBoolData : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the bool data in a variable.")]
		public FsmBool getBoolData;

		public override void Reset()
		{
			getBoolData = null;
		}

		public override void OnEnter()
		{
			getBoolData.Value = Fsm.EventData.BoolData;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the Float data from the last Event.")]
	public class GetEventFloatData : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the float data in a variable.")]
		public FsmFloat getFloatData;

		public override void Reset()
		{
			getFloatData = null;
		}

		public override void OnEnter()
		{
			getFloatData.Value = Fsm.EventData.FloatData;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets info on the last event that caused a state change. See also Set Event Data action.")]
	public class GetEventInfo : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmGameObject sentByGameObject;

		[UIHint(UIHint.Variable)]
		public FsmString fsmName;

		[UIHint(UIHint.Variable)]
		public FsmBool getBoolData;

		[UIHint(UIHint.Variable)]
		public FsmInt getIntData;

		[UIHint(UIHint.Variable)]
		public FsmFloat getFloatData;

		[UIHint(UIHint.Variable)]
		public FsmVector2 getVector2Data;

		[UIHint(UIHint.Variable)]
		public FsmVector3 getVector3Data;

		[UIHint(UIHint.Variable)]
		public FsmString getStringData;

		[UIHint(UIHint.Variable)]
		public FsmGameObject getGameObjectData;

		[UIHint(UIHint.Variable)]
		public FsmRect getRectData;

		[UIHint(UIHint.Variable)]
		public FsmQuaternion getQuaternionData;

		[UIHint(UIHint.Variable)]
		public FsmMaterial getMaterialData;

		[UIHint(UIHint.Variable)]
		public FsmTexture getTextureData;

		[UIHint(UIHint.Variable)]
		public FsmColor getColorData;

		[UIHint(UIHint.Variable)]
		public FsmObject getObjectData;

		public override void Reset()
		{
			sentByGameObject = null;
			fsmName = null;
			getBoolData = null;
			getIntData = null;
			getFloatData = null;
			getVector2Data = null;
			getVector3Data = null;
			getStringData = null;
			getGameObjectData = null;
			getRectData = null;
			getQuaternionData = null;
			getMaterialData = null;
			getTextureData = null;
			getColorData = null;
			getObjectData = null;
		}

		public override void OnEnter()
		{
			if (Fsm.EventData.SentByGameObject != null)
			{
				sentByGameObject.Value = Fsm.EventData.SentByGameObject;
			}
			else if (Fsm.EventData.SentByFsm != null)
			{
				sentByGameObject.Value = Fsm.EventData.SentByFsm.GameObject;
				fsmName.Value = Fsm.EventData.SentByFsm.Name;
			}
			else
			{
				sentByGameObject.Value = null;
				fsmName.Value = "";
			}
			getBoolData.Value = Fsm.EventData.BoolData;
			getIntData.Value = Fsm.EventData.IntData;
			getFloatData.Value = Fsm.EventData.FloatData;
			getVector2Data.Value = Fsm.EventData.Vector2Data;
			getVector3Data.Value = Fsm.EventData.Vector3Data;
			getStringData.Value = Fsm.EventData.StringData;
			getGameObjectData.Value = Fsm.EventData.GameObjectData;
			getRectData.Value = Fsm.EventData.RectData;
			getQuaternionData.Value = Fsm.EventData.QuaternionData;
			getMaterialData.Value = Fsm.EventData.MaterialData;
			getTextureData.Value = Fsm.EventData.TextureData;
			getColorData.Value = Fsm.EventData.ColorData;
			getObjectData.Value = Fsm.EventData.ObjectData;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the Int data from the last Event.")]
	public class GetEventIntData : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the int data in a variable.")]
		public FsmInt getIntData;

		public override void Reset()
		{
			getIntData = null;
		}

		public override void OnEnter()
		{
			getIntData.Value = Fsm.EventData.IntData;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the sender of the last event.")]
	public class GetEventSentBy : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the GameObject that sent the event.")]
		public FsmGameObject sentByGameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the name of the GameObject that sent the event.")]
		public FsmString gameObjectName;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the name of the FSM that sent the event.")]
		public FsmString fsmName;

		public override void Reset()
		{
			sentByGameObject = null;
			gameObjectName = null;
			fsmName = null;
		}

		public override void OnEnter()
		{
			if (Fsm.EventData.SentByGameObject != null)
			{
				sentByGameObject.Value = Fsm.EventData.SentByGameObject;
			}
			else if (Fsm.EventData.SentByFsm != null)
			{
				sentByGameObject.Value = Fsm.EventData.SentByFsm.GameObject;
				fsmName.Value = Fsm.EventData.SentByFsm.Name;
			}
			else
			{
				sentByGameObject.Value = null;
				fsmName.Value = "";
			}
			if (sentByGameObject.Value != null)
			{
				gameObjectName.Value = sentByGameObject.Value.name;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the String data from the last Event.")]
	public class GetEventStringData : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the string data in a variable.")]
		public FsmString getStringData;

		public override void Reset()
		{
			getStringData = null;
		}

		public override void OnEnter()
		{
			getStringData.Value = Fsm.EventData.StringData;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the Vector2 data from the last Event.")]
	public class GetEventVector2Data : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the vector2 data in a variable.")]
		public FsmVector2 getVector2Data;

		public override void Reset()
		{
			getVector2Data = null;
		}

		public override void OnEnter()
		{
			getVector2Data.Value = Fsm.EventData.Vector2Data;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the Vector3 data from the last Event.")]
	public class GetEventVector3Data : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the vector3 data in a variable.")]
		public FsmVector3 getVector3Data;

		public override void Reset()
		{
			getVector3Data = null;
		}

		public override void OnEnter()
		{
			getVector3Data.Value = Fsm.EventData.Vector3Data;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Bool Variable from another FSM.")]
	public class GetFsmBool : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmBool)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmBool storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmBool();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmBool();
		}

		private void DoGetFsmBool()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmBool fsmBool = fsm.FsmVariables.GetFsmBool(variableName.Value);
				if (fsmBool != null)
				{
					storeValue.Value = fsmBool.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Color Variable from another FSM.")]
	public class GetFsmColor : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmColor)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmColor storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmColor();
		}

		private void DoGetFsmColor()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmColor fsmColor = fsm.FsmVariables.GetFsmColor(variableName.Value);
				if (fsmColor != null)
				{
					storeValue.Value = fsmColor.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of an Enum Variable from another FSM.")]
	public class GetFsmEnum : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The target FSM")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmBool)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmEnum storeValue;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmEnum();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmEnum();
		}

		private void DoGetFsmEnum()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmEnum fsmEnum = fsm.FsmVariables.GetFsmEnum(variableName.Value);
				if (fsmEnum != null)
				{
					storeValue.Value = fsmEnum.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Float Variable from another FSM.")]
	public class GetFsmFloat : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmFloat)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmFloat();
		}

		private void DoGetFsmFloat()
		{
			if (storeValue.IsNone)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmFloat fsmFloat = fsm.FsmVariables.GetFsmFloat(variableName.Value);
				if (fsmFloat != null)
				{
					storeValue.Value = fsmFloat.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Game Object Variable from another FSM.")]
	public class GetFsmGameObject : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmGameObject)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmGameObject storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmGameObject();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmGameObject();
		}

		private void DoGetFsmGameObject()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmGameObject fsmGameObject = fsm.FsmVariables.GetFsmGameObject(variableName.Value);
				if (fsmGameObject != null)
				{
					storeValue.Value = fsmGameObject.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of an Integer Variable from another FSM.")]
	public class GetFsmInt : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmInt)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmInt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmInt();
		}

		private void DoGetFsmInt()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmInt fsmInt = fsm.FsmVariables.GetFsmInt(variableName.Value);
				if (fsmInt != null)
				{
					storeValue.Value = fsmInt.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Material Variable from another FSM.")]
	public class GetFsmMaterial : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmMaterial)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmMaterial storeValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		protected PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			storeValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetFsmVariable();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVariable();
		}

		private void DoGetFsmVariable()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null) && storeValue != null)
			{
				FsmMaterial fsmMaterial = fsm.FsmVariables.GetFsmMaterial(variableName.Value);
				if (fsmMaterial != null)
				{
					storeValue.Value = fsmMaterial.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of an Object Variable from another FSM.")]
	public class GetFsmObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmObject)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmObject storeValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		protected PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			storeValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetFsmVariable();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVariable();
		}

		private void DoGetFsmVariable()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null) && storeValue != null)
			{
				FsmObject fsmObject = fsm.FsmVariables.GetFsmObject(variableName.Value);
				if (fsmObject != null)
				{
					storeValue.Value = fsmObject.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Quaternion Variable from another FSM.")]
	public class GetFsmQuaternion : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmQuaternion)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmQuaternion storeValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		protected PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			storeValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetFsmVariable();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVariable();
		}

		private void DoGetFsmVariable()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null) && storeValue != null)
			{
				FsmQuaternion fsmQuaternion = fsm.FsmVariables.GetFsmQuaternion(variableName.Value);
				if (fsmQuaternion != null)
				{
					storeValue.Value = fsmQuaternion.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Rect Variable from another FSM.")]
	public class GetFsmRect : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmRect)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmRect storeValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		protected PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			storeValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetFsmVariable();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVariable();
		}

		private void DoGetFsmVariable()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null) && storeValue != null)
			{
				FsmRect fsmRect = fsm.FsmVariables.GetFsmRect(variableName.Value);
				if (fsmRect != null)
				{
					storeValue.Value = fsmRect.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "fsmComponent", false)]
	[Tooltip("Gets the name of the specified FSMs current state. Either reference the fsm component directly, or find it on a game object.")]
	public class GetFsmState : FsmStateAction
	{
		[Tooltip("Drag a PlayMakerFSM component here.")]
		public PlayMakerFSM fsmComponent;

		[Tooltip("If not specifying the component above, specify the GameObject that owns the FSM")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of Fsm on Game Object. If left blank it will find the first PlayMakerFSM on the GameObject.")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the state name in a string variable.")]
		public FsmString storeResult;

		[Tooltip("Repeat every frame. E.g.,  useful if you're waiting for the state to change.")]
		public bool everyFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			fsmComponent = null;
			gameObject = null;
			fsmName = "";
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetFsmState();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmState();
		}

		private void DoGetFsmState()
		{
			if (fsm == null)
			{
				if (fsmComponent != null)
				{
					fsm = fsmComponent;
				}
				else
				{
					GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
					if (ownerDefaultTarget != null)
					{
						fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
					}
				}
				if (fsm == null)
				{
					storeResult.Value = "";
					return;
				}
			}
			storeResult.Value = fsm.ActiveStateName;
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a String Variable from another FSM.")]
	public class GetFsmString : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmString)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmString();
		}

		private void DoGetFsmString()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmString fsmString = fsm.FsmVariables.GetFsmString(variableName.Value);
				if (fsmString != null)
				{
					storeValue.Value = fsmString.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Texture Variable from another FSM.")]
	public class GetFsmTexture : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmTexture)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmTexture storeValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		protected PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			storeValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetFsmVariable();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVariable();
		}

		private void DoGetFsmVariable()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null) && storeValue != null)
			{
				FsmTexture fsmTexture = fsm.FsmVariables.GetFsmTexture(variableName.Value);
				if (fsmTexture != null)
				{
					storeValue.Value = fsmTexture.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a variable in another FSM and store it in a variable of the same name in this FSM.")]
	public class GetFsmVariable : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[HideTypeFilter]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the value of the FsmVariable")]
		public FsmVar storeValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private GameObject cachedGO;

		private string cachedFsmName;

		private PlayMakerFSM sourceFsm;

		private INamedVariable sourceVariable;

		private NamedVariable targetVariable;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = new FsmVar();
		}

		public override void OnEnter()
		{
			InitFsmVar();
			DoGetFsmVariable();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVariable();
		}

		private void InitFsmVar()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null) && (ownerDefaultTarget != cachedGO || cachedFsmName != fsmName.Value))
			{
				sourceFsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
				sourceVariable = sourceFsm.FsmVariables.GetVariable(storeValue.variableName);
				targetVariable = base.Fsm.Variables.GetVariable(storeValue.variableName);
				storeValue.Type = targetVariable.VariableType;
				if (!string.IsNullOrEmpty(storeValue.variableName) && sourceVariable == null)
				{
					LogWarning("Missing Variable: " + storeValue.variableName);
				}
				cachedGO = ownerDefaultTarget;
				cachedFsmName = fsmName.Value;
			}
		}

		private void DoGetFsmVariable()
		{
			if (!storeValue.IsNone)
			{
				InitFsmVar();
				storeValue.GetValueFrom(sourceVariable);
				storeValue.ApplyValueTo(targetVariable);
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the values of multiple variables in another FSM and store in variables of the same name in this FSM.")]
	public class GetFsmVariables : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[HideTypeFilter]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the values of the FsmVariables")]
		public FsmVar[] getVariables;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private GameObject cachedGO;

		private string cachedFsmName;

		private PlayMakerFSM sourceFsm;

		private INamedVariable[] sourceVariables;

		private NamedVariable[] targetVariables;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			getVariables = null;
		}

		private void InitFsmVars()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null || (!(ownerDefaultTarget != cachedGO) && !(cachedFsmName != fsmName.Value)))
			{
				return;
			}
			sourceVariables = new INamedVariable[getVariables.Length];
			targetVariables = new NamedVariable[getVariables.Length];
			for (int i = 0; i < getVariables.Length; i++)
			{
				string variableName = getVariables[i].variableName;
				sourceFsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
				sourceVariables[i] = sourceFsm.FsmVariables.GetVariable(variableName);
				targetVariables[i] = base.Fsm.Variables.GetVariable(variableName);
				getVariables[i].Type = targetVariables[i].VariableType;
				if (!string.IsNullOrEmpty(variableName) && sourceVariables[i] == null)
				{
					LogWarning("Missing Variable: " + variableName);
				}
				cachedGO = ownerDefaultTarget;
				cachedFsmName = fsmName.Value;
			}
		}

		public override void OnEnter()
		{
			InitFsmVars();
			DoGetFsmVariables();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVariables();
		}

		private void DoGetFsmVariables()
		{
			InitFsmVars();
			for (int i = 0; i < getVariables.Length; i++)
			{
				getVariables[i].GetValueFrom(sourceVariables[i]);
				getVariables[i].ApplyValueTo(targetVariables[i]);
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Vector2 Variable from another FSM.")]
	public class GetFsmVector2 : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmVector2)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector2 storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmVector2();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVector2();
		}

		private void DoGetFsmVector2()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmVector2 fsmVector = fsm.FsmVariables.GetFsmVector2(variableName.Value);
				if (fsmVector != null)
				{
					storeValue.Value = fsmVector.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Get the value of a Vector3 Variable from another FSM.")]
	public class GetFsmVector3 : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmVector3)]
		public FsmString variableName;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeValue;

		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			storeValue = null;
		}

		public override void OnEnter()
		{
			DoGetFsmVector3();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFsmVector3();
		}

		private void DoGetFsmVector3()
		{
			if (storeValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmVector3 fsmVector = fsm.FsmVariables.GetFsmVector3(variableName.Value);
				if (fsmVector != null)
				{
					storeValue.Value = fsmVector.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the event that caused the transition to the current state, and stores it in a String Variable.")]
	public class GetLastEvent : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmString storeEvent;

		public override void Reset()
		{
			storeEvent = null;
		}

		public override void OnEnter()
		{
			storeEvent.Value = ((base.Fsm.LastTransition == null) ? "START" : base.Fsm.LastTransition.EventName);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Gets the name of the previously active state and stores it in a String Variable.")]
	public class GetPreviousStateName : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		public FsmString storeName;

		public override void Reset()
		{
			storeName = null;
		}

		public override void OnEnter()
		{
			storeName.Value = ((base.Fsm.PreviousActiveState == null) ? null : base.Fsm.PreviousActiveState.Name);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Immediately return to the previously active state.")]
	public class GotoPreviousState : FsmStateAction
	{
		public override void Reset()
		{
		}

		public override void OnEnter()
		{
			if (base.Fsm.PreviousActiveState != null)
			{
				Log("Goto Previous State: " + base.Fsm.PreviousActiveState.Name);
				base.Fsm.GotoPreviousState();
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Note("Kill all queued delayed events.")]
	[Tooltip("Kill all queued delayed events. Normally delayed events are automatically killed when the active state is exited, but you can override this behaviour in FSM settings. If you choose to keep delayed events you can use this action to kill them when needed.")]
	public class KillDelayedEvents : FsmStateAction
	{
		public override void OnEnter()
		{
			base.Fsm.KillDelayedEvents();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sends an Event in the next frame. Useful if you want to loop states every frame.")]
	public class NextFrameEvent : FsmStateAction
	{
		[RequiredField]
		public FsmEvent sendEvent;

		public override void Reset()
		{
			sendEvent = null;
		}

		public override void OnEnter()
		{
		}

		public override void OnUpdate()
		{
			Finish();
			base.Fsm.Event(sendEvent);
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sends a Random State Event after an optional delay. Use this to transition to a random state from the current state.")]
	public class RandomEvent : FsmStateAction
	{
		[HasFloatSlider(0f, 10f)]
		[Tooltip("Delay before sending the event.")]
		public FsmFloat delay;

		[Tooltip("Don't repeat the same event twice in a row.")]
		public FsmBool noRepeat;

		private DelayedEvent delayedEvent;

		private int randomEventIndex;

		private int lastEventIndex = -1;

		public override void Reset()
		{
			delay = null;
			noRepeat = false;
		}

		public override void OnEnter()
		{
			if (base.State.Transitions.Length != 0)
			{
				if (lastEventIndex == -1)
				{
					lastEventIndex = UnityEngine.Random.Range(0, base.State.Transitions.Length);
				}
				if (delay.Value < 0.001f)
				{
					base.Fsm.Event(GetRandomEvent());
					Finish();
				}
				else
				{
					delayedEvent = base.Fsm.DelayedEvent(GetRandomEvent(), delay.Value);
				}
			}
		}

		public override void OnUpdate()
		{
			if (DelayedEvent.WasSent(delayedEvent))
			{
				Finish();
			}
		}

		private FsmEvent GetRandomEvent()
		{
			do
			{
				randomEventIndex = UnityEngine.Random.Range(0, base.State.Transitions.Length);
			}
			while (noRepeat.Value && base.State.Transitions.Length > 1 && randomEventIndex == lastEventIndex);
			lastEventIndex = randomEventIndex;
			return base.State.Transitions[randomEventIndex].FsmEvent;
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Creates an FSM from a saved FSM Template.")]
	public class RunFSM : RunFSMAction
	{
		public FsmTemplateControl fsmTemplateControl = new FsmTemplateControl();

		[UIHint(UIHint.Variable)]
		public FsmInt storeID;

		[Tooltip("Event to send when the FSM has finished (usually because it ran a Finish FSM action).")]
		public FsmEvent finishEvent;

		public override void Reset()
		{
			fsmTemplateControl = new FsmTemplateControl();
			storeID = null;
			runFsm = null;
		}

		public override void Awake()
		{
			if (fsmTemplateControl.fsmTemplate != null && UnityEngine.Application.isPlaying)
			{
				runFsm = base.Fsm.CreateSubFsm(fsmTemplateControl);
			}
		}

		public override void OnEnter()
		{
			if (runFsm == null)
			{
				Finish();
				return;
			}
			fsmTemplateControl.UpdateValues();
			fsmTemplateControl.ApplyOverrides(runFsm);
			runFsm.OnEnable();
			if (!runFsm.Started)
			{
				runFsm.Start();
			}
			storeID.Value = fsmTemplateControl.ID;
			CheckIfFinished();
		}

		protected override void CheckIfFinished()
		{
			if (runFsm == null || runFsm.Finished)
			{
				Finish();
				base.Fsm.Event(finishEvent);
			}
		}
	}
	[Tooltip("Base class for actions that want to run a sub FSM.")]
	public abstract class RunFSMAction : FsmStateAction
	{
		protected Fsm runFsm;

		public override void Reset()
		{
			runFsm = null;
		}

		public override bool Event(FsmEvent fsmEvent)
		{
			if (runFsm != null && (fsmEvent.IsGlobal || fsmEvent.IsSystemEvent))
			{
				runFsm.Event(fsmEvent);
			}
			return false;
		}

		public override void OnEnter()
		{
			if (runFsm == null)
			{
				Finish();
				return;
			}
			runFsm.OnEnable();
			if (!runFsm.Started)
			{
				runFsm.Start();
			}
			CheckIfFinished();
		}

		public override void OnUpdate()
		{
			if (runFsm != null)
			{
				runFsm.Update();
				CheckIfFinished();
			}
			else
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			if (runFsm != null)
			{
				runFsm.FixedUpdate();
				CheckIfFinished();
			}
			else
			{
				Finish();
			}
		}

		public override void OnLateUpdate()
		{
			if (runFsm != null)
			{
				runFsm.LateUpdate();
				CheckIfFinished();
			}
			else
			{
				Finish();
			}
		}

		public override void DoTriggerEnter(Collider other)
		{
			if (runFsm.HandleTriggerEnter)
			{
				runFsm.OnTriggerEnter(other);
			}
		}

		public override void DoTriggerStay(Collider other)
		{
			if (runFsm.HandleTriggerStay)
			{
				runFsm.OnTriggerStay(other);
			}
		}

		public override void DoTriggerExit(Collider other)
		{
			if (runFsm.HandleTriggerExit)
			{
				runFsm.OnTriggerExit(other);
			}
		}

		public override void DoCollisionEnter(Collision collisionInfo)
		{
			if (runFsm.HandleCollisionEnter)
			{
				runFsm.OnCollisionEnter(collisionInfo);
			}
		}

		public override void DoCollisionStay(Collision collisionInfo)
		{
			if (runFsm.HandleCollisionStay)
			{
				runFsm.OnCollisionStay(collisionInfo);
			}
		}

		public override void DoCollisionExit(Collision collisionInfo)
		{
			if (runFsm.HandleCollisionExit)
			{
				runFsm.OnCollisionExit(collisionInfo);
			}
		}

		public override void DoParticleCollision(GameObject other)
		{
			if (runFsm.HandleParticleCollision)
			{
				runFsm.OnParticleCollision(other);
			}
		}

		public override void DoControllerColliderHit(ControllerColliderHit collisionInfo)
		{
			if (runFsm.HandleControllerColliderHit)
			{
				runFsm.OnControllerColliderHit(collisionInfo);
			}
		}

		public override void DoTriggerEnter2D(Collider2D other)
		{
			if (runFsm.HandleTriggerEnter2D)
			{
				runFsm.OnTriggerEnter2D(other);
			}
		}

		public override void DoTriggerStay2D(Collider2D other)
		{
			if (runFsm.HandleTriggerStay2D)
			{
				runFsm.OnTriggerStay2D(other);
			}
		}

		public override void DoTriggerExit2D(Collider2D other)
		{
			if (runFsm.HandleTriggerExit2D)
			{
				runFsm.OnTriggerExit2D(other);
			}
		}

		public override void DoCollisionEnter2D(Collision2D collisionInfo)
		{
			if (runFsm.HandleCollisionEnter2D)
			{
				runFsm.OnCollisionEnter2D(collisionInfo);
			}
		}

		public override void DoCollisionStay2D(Collision2D collisionInfo)
		{
			if (runFsm.HandleCollisionStay2D)
			{
				runFsm.OnCollisionStay2D(collisionInfo);
			}
		}

		public override void DoCollisionExit2D(Collision2D collisionInfo)
		{
			if (runFsm.HandleCollisionExit2D)
			{
				runFsm.OnCollisionExit2D(collisionInfo);
			}
		}

		public override void OnGUI()
		{
			if (runFsm != null && runFsm.HandleOnGUI)
			{
				runFsm.OnGUI();
			}
		}

		public override void OnExit()
		{
			if (runFsm != null)
			{
				runFsm.Stop();
			}
		}

		protected virtual void CheckIfFinished()
		{
			if (runFsm == null || runFsm.Finished)
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "eventTarget", false)]
	[ActionTarget(typeof(GameObject), "eventTarget", false)]
	[Tooltip("Sends an Event after an optional delay. NOTE: To send events between FSMs they must be marked as Global in the Events Browser.")]
	public class SendEvent : FsmStateAction
	{
		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[RequiredField]
		[Tooltip("The event to send. NOTE: Events must be marked Global to send between FSMs.")]
		public FsmEvent sendEvent;

		[HasFloatSlider(0f, 10f)]
		[Tooltip("Optional delay in seconds.")]
		public FsmFloat delay;

		[Tooltip("Repeat every frame. Rarely needed, but can be useful when sending events to other FSMs.")]
		public bool everyFrame;

		private DelayedEvent delayedEvent;

		public override void Reset()
		{
			eventTarget = null;
			sendEvent = null;
			delay = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			if (delay.Value < 0.001f)
			{
				base.Fsm.Event(eventTarget, sendEvent);
				if (!everyFrame)
				{
					Finish();
				}
			}
			else
			{
				delayedEvent = base.Fsm.DelayedEvent(eventTarget, sendEvent, delay.Value);
			}
		}

		public override void OnUpdate()
		{
			if (!everyFrame)
			{
				if (DelayedEvent.WasSent(delayedEvent))
				{
					Finish();
				}
			}
			else
			{
				base.Fsm.Event(eventTarget, sendEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sends an Event by name after an optional delay. NOTE: Use this over Send Event if you store events as string variables.")]
	public class SendEventByName : FsmStateAction
	{
		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[RequiredField]
		[Tooltip("The event to send. NOTE: Events must be marked Global to send between FSMs.")]
		public FsmString sendEvent;

		[HasFloatSlider(0f, 10f)]
		[Tooltip("Optional delay in seconds.")]
		public FsmFloat delay;

		[Tooltip("Repeat every frame. Rarely needed, but can be useful when sending events to other FSMs.")]
		public bool everyFrame;

		private DelayedEvent delayedEvent;

		public override void Reset()
		{
			eventTarget = null;
			sendEvent = null;
			delay = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			if (delay.Value < 0.001f)
			{
				base.Fsm.Event(eventTarget, sendEvent.Value);
				if (!everyFrame)
				{
					Finish();
				}
			}
			else
			{
				delayedEvent = base.Fsm.DelayedEvent(eventTarget, FsmEvent.GetFsmEvent(sendEvent.Value), delay.Value);
			}
		}

		public override void OnUpdate()
		{
			if (!everyFrame)
			{
				if (DelayedEvent.WasSent(delayedEvent))
				{
					Finish();
				}
			}
			else
			{
				base.Fsm.Event(eventTarget, sendEvent.Value);
			}
		}
	}
	[Obsolete("This action is obsolete; use Send Event with Event Target instead.")]
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sends an Event to another Fsm after an optional delay. Specify an Fsm Name or use the first Fsm on the object.")]
	public class SendEventToFsm : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of Fsm on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmEvent)]
		public FsmString sendEvent;

		[HasFloatSlider(0f, 10f)]
		public FsmFloat delay;

		private bool requireReceiver;

		private GameObject go;

		private DelayedEvent delayedEvent;

		public override void Reset()
		{
			gameObject = null;
			fsmName = null;
			sendEvent = null;
			delay = null;
			requireReceiver = false;
		}

		public override void OnEnter()
		{
			go = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (go == null)
			{
				Finish();
				return;
			}
			PlayMakerFSM gameObjectFsm = ActionHelpers.GetGameObjectFsm(go, fsmName.Value);
			if (gameObjectFsm == null)
			{
				if (requireReceiver)
				{
					LogError("GameObject doesn't have FsmComponent: " + go.name + " " + fsmName.Value);
				}
			}
			else if ((double)delay.Value < 0.001)
			{
				gameObjectFsm.Fsm.Event(sendEvent.Value);
				Finish();
			}
			else
			{
				delayedEvent = gameObjectFsm.Fsm.DelayedEvent(FsmEvent.GetFsmEvent(sendEvent.Value), delay.Value);
			}
		}

		public override void OnUpdate()
		{
			if (DelayedEvent.WasSent(delayedEvent))
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sends a Random Event picked from an array of Events. Optionally set the relative weight of each event.")]
	public class SendRandomEvent : FsmStateAction
	{
		[CompoundArray("Events", "Event", "Weight")]
		public FsmEvent[] events;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		public FsmFloat delay;

		private DelayedEvent delayedEvent;

		public override void Reset()
		{
			events = new FsmEvent[3];
			weights = new FsmFloat[3] { 1f, 1f, 1f };
			delay = null;
		}

		public override void OnEnter()
		{
			if (events.Length != 0)
			{
				int randomWeightedIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				if (randomWeightedIndex != -1)
				{
					if (delay.Value < 0.001f)
					{
						base.Fsm.Event(events[randomWeightedIndex]);
						Finish();
					}
					else
					{
						delayedEvent = base.Fsm.DelayedEvent(events[randomWeightedIndex], delay.Value);
					}
					return;
				}
			}
			Finish();
		}

		public override void OnUpdate()
		{
			if (DelayedEvent.WasSent(delayedEvent))
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sends the next event on the state each time the state is entered.")]
	public class SequenceEvent : FsmStateAction
	{
		[HasFloatSlider(0f, 10f)]
		public FsmFloat delay;

		[UIHint(UIHint.Variable)]
		[Tooltip("Assign a variable to control reset. Set it to True to reset the sequence. Value is set to False after resetting.")]
		public FsmBool reset;

		private DelayedEvent delayedEvent;

		private int eventIndex;

		public override void Reset()
		{
			delay = null;
		}

		public override void OnEnter()
		{
			if (reset.Value)
			{
				eventIndex = 0;
				reset.Value = false;
			}
			int num = base.State.Transitions.Length;
			if (num > 0)
			{
				FsmEvent fsmEvent = base.State.Transitions[eventIndex].FsmEvent;
				if (delay.Value < 0.001f)
				{
					base.Fsm.Event(fsmEvent);
					Finish();
				}
				else
				{
					delayedEvent = base.Fsm.DelayedEvent(fsmEvent, delay.Value);
				}
				eventIndex++;
				if (eventIndex == num)
				{
					eventIndex = 0;
				}
			}
		}

		public override void OnUpdate()
		{
			if (DelayedEvent.WasSent(delayedEvent))
			{
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sets Event Data before sending an event. Get the Event Data, along with sender information, using Get Event Info action.")]
	public class SetEventData : FsmStateAction
	{
		public FsmGameObject setGameObjectData;

		public FsmInt setIntData;

		public FsmFloat setFloatData;

		public FsmString setStringData;

		public FsmBool setBoolData;

		public FsmVector2 setVector2Data;

		public FsmVector3 setVector3Data;

		public FsmRect setRectData;

		public FsmQuaternion setQuaternionData;

		public FsmColor setColorData;

		public FsmMaterial setMaterialData;

		public FsmTexture setTextureData;

		public FsmObject setObjectData;

		public override void Reset()
		{
			setGameObjectData = new FsmGameObject
			{
				UseVariable = true
			};
			setIntData = new FsmInt
			{
				UseVariable = true
			};
			setFloatData = new FsmFloat
			{
				UseVariable = true
			};
			setStringData = new FsmString
			{
				UseVariable = true
			};
			setBoolData = new FsmBool
			{
				UseVariable = true
			};
			setVector2Data = new FsmVector2
			{
				UseVariable = true
			};
			setVector3Data = new FsmVector3
			{
				UseVariable = true
			};
			setRectData = new FsmRect
			{
				UseVariable = true
			};
			setQuaternionData = new FsmQuaternion
			{
				UseVariable = true
			};
			setColorData = new FsmColor
			{
				UseVariable = true
			};
			setMaterialData = new FsmMaterial
			{
				UseVariable = true
			};
			setTextureData = new FsmTexture
			{
				UseVariable = true
			};
			setObjectData = new FsmObject
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			Fsm.EventData.BoolData = setBoolData.Value;
			Fsm.EventData.IntData = setIntData.Value;
			Fsm.EventData.FloatData = setFloatData.Value;
			Fsm.EventData.Vector2Data = setVector2Data.Value;
			Fsm.EventData.Vector3Data = setVector3Data.Value;
			Fsm.EventData.StringData = setStringData.Value;
			Fsm.EventData.GameObjectData = setGameObjectData.Value;
			Fsm.EventData.RectData = setRectData.Value;
			Fsm.EventData.QuaternionData = setQuaternionData.Value;
			Fsm.EventData.ColorData = setColorData.Value;
			Fsm.EventData.MaterialData = setMaterialData.Value;
			Fsm.EventData.TextureData = setTextureData.Value;
			Fsm.EventData.ObjectData = setObjectData.Value;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[Tooltip("Sets the target FSM for all subsequent events sent by this state. The default 'Self' sends events to this FSM.")]
	public class SetEventTarget : FsmStateAction
	{
		public FsmEventTarget eventTarget;

		public override void Reset()
		{
		}

		public override void OnEnter()
		{
			base.Fsm.EventTarget = eventTarget;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Bool Variable in another FSM.")]
	public class SetFsmBool : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmBool)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmBool setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmBool();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmBool()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmBool fsmBool = fsm.FsmVariables.FindFsmBool(variableName.Value);
			if (fsmBool != null)
			{
				fsmBool.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmBool();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Color Variable in another FSM.")]
	public class SetFsmColor : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmColor)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmColor setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmColor();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmColor()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmColor fsmColor = fsm.FsmVariables.GetFsmColor(variableName.Value);
			if (fsmColor != null)
			{
				fsmColor.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmColor();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a String Variable in another FSM.")]
	public class SetFsmEnum : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object.")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmEnum)]
		[Tooltip("Enum variable name needs to match the FSM variable name on Game Object.")]
		public FsmString variableName;

		[RequiredField]
		public FsmEnum setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmEnum();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmEnum()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmEnum fsmEnum = fsm.FsmVariables.GetFsmEnum(variableName.Value);
			if (fsmEnum != null)
			{
				fsmEnum.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmEnum();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Float Variable in another FSM.")]
	public class SetFsmFloat : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmFloat)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmFloat setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmFloat();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmFloat()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmFloat fsmFloat = fsm.FsmVariables.GetFsmFloat(variableName.Value);
			if (fsmFloat != null)
			{
				fsmFloat.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmFloat();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Game Object Variable in another FSM. Accept null reference")]
	public class SetFsmGameObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmGameObject)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[Tooltip("Set the value of the variable.")]
		public FsmGameObject setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFsmGameObject();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmGameObject()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (!(fsm == null))
			{
				FsmGameObject fsmGameObject = fsm.FsmVariables.FindFsmGameObject(variableName.Value);
				if (fsmGameObject != null)
				{
					fsmGameObject.Value = ((setValue == null) ? null : setValue.Value);
				}
				else
				{
					LogWarning("Could not find variable: " + variableName.Value);
				}
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmGameObject();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of an Integer Variable in another FSM.")]
	public class SetFsmInt : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmInt)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmInt setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmInt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmInt()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmInt fsmInt = fsm.FsmVariables.GetFsmInt(variableName.Value);
			if (fsmInt != null)
			{
				fsmInt.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmInt();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Material Variable in another FSM.")]
	public class SetFsmMaterial : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmMaterial)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmMaterial setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			setValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFsmBool();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmBool()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmMaterial fsmMaterial = fsm.FsmVariables.GetFsmMaterial(variableName.Value);
			if (fsmMaterial != null)
			{
				fsmMaterial.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmBool();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of an Object Variable in another FSM.")]
	public class SetFsmObject : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmObject)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[Tooltip("Set the value of the variable.")]
		public FsmObject setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			setValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFsmBool();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmBool()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmObject fsmObject = fsm.FsmVariables.GetFsmObject(variableName.Value);
			if (fsmObject != null)
			{
				fsmObject.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmBool();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Quaternion Variable in another FSM.")]
	public class SetFsmQuaternion : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmQuaternion)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmQuaternion setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			setValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFsmQuaternion();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmQuaternion()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmQuaternion fsmQuaternion = fsm.FsmVariables.GetFsmQuaternion(variableName.Value);
			if (fsmQuaternion != null)
			{
				fsmQuaternion.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmQuaternion();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Rect Variable in another FSM.")]
	public class SetFsmRect : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmRect)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmRect setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			setValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFsmBool();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmBool()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmRect fsmRect = fsm.FsmVariables.GetFsmRect(variableName.Value);
			if (fsmRect != null)
			{
				fsmRect.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmBool();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a String Variable in another FSM.")]
	public class SetFsmString : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object.")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmString)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[Tooltip("Set the value of the variable.")]
		public FsmString setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmString()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmString fsmString = fsm.FsmVariables.GetFsmString(variableName.Value);
			if (fsmString != null)
			{
				fsmString.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmString();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Texture Variable in another FSM.")]
	public class SetFsmTexture : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmTexture)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[Tooltip("Set the value of the variable.")]
		public FsmTexture setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			variableName = "";
			setValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetFsmTexture();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmTexture()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmTexture fsmTexture = fsm.FsmVariables.FindFsmTexture(variableName.Value);
			if (fsmTexture != null)
			{
				fsmTexture.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmTexture();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a variable in another FSM.")]
	public class SetFsmVariable : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[Tooltip("The name of the variable in the target FSM.")]
		public FsmString variableName;

		[RequiredField]
		public FsmVar setValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private PlayMakerFSM targetFsm;

		private NamedVariable targetVariable;

		private GameObject cachedGameObject;

		private string cachedFsmName;

		private string cachedVariableName;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = new FsmVar();
		}

		public override void OnEnter()
		{
			DoSetFsmVariable();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmVariable();
		}

		private void DoSetFsmVariable()
		{
			if (setValue.IsNone || string.IsNullOrEmpty(variableName.Value))
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != cachedGameObject || fsmName.Value != cachedFsmName)
			{
				targetFsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
				if (targetFsm == null)
				{
					return;
				}
				cachedGameObject = ownerDefaultTarget;
				cachedFsmName = fsmName.Value;
			}
			if (variableName.Value != cachedVariableName)
			{
				targetVariable = targetFsm.FsmVariables.FindVariable(setValue.Type, variableName.Value);
				cachedVariableName = variableName.Value;
			}
			if (targetVariable == null)
			{
				LogWarning("Missing Variable: " + variableName.Value);
				return;
			}
			setValue.UpdateValue();
			setValue.ApplyValueTo(targetVariable);
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Vector2 Variable in another FSM.")]
	public class SetFsmVector2 : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmVector2)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmVector2 setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmVector2();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmVector2()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmVector2 fsmVector = fsm.FsmVariables.GetFsmVector2(variableName.Value);
			if (fsmVector != null)
			{
				fsmVector.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmVector2();
		}
	}
	[ActionCategory(ActionCategory.StateMachine)]
	[ActionTarget(typeof(PlayMakerFSM), "gameObject,fsmName", false)]
	[Tooltip("Set the value of a Vector3 Variable in another FSM.")]
	public class SetFsmVector3 : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject that owns the FSM.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.FsmName)]
		[Tooltip("Optional name of FSM on Game Object")]
		public FsmString fsmName;

		[RequiredField]
		[UIHint(UIHint.FsmVector3)]
		[Tooltip("The name of the FSM variable.")]
		public FsmString variableName;

		[RequiredField]
		[Tooltip("Set the value of the variable.")]
		public FsmVector3 setValue;

		[Tooltip("Repeat every frame. Useful if the value is changing.")]
		public bool everyFrame;

		private GameObject goLastFrame;

		private string fsmNameLastFrame;

		private PlayMakerFSM fsm;

		public override void Reset()
		{
			gameObject = null;
			fsmName = "";
			setValue = null;
		}

		public override void OnEnter()
		{
			DoSetFsmVector3();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetFsmVector3()
		{
			if (setValue == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (ownerDefaultTarget != goLastFrame || fsmName.Value != fsmNameLastFrame)
			{
				goLastFrame = ownerDefaultTarget;
				fsmNameLastFrame = fsmName.Value;
				fsm = ActionHelpers.GetGameObjectFsm(ownerDefaultTarget, fsmName.Value);
			}
			if (fsm == null)
			{
				LogWarning("Could not find FSM: " + fsmName.Value);
				return;
			}
			FsmVector3 fsmVector = fsm.FsmVariables.GetFsmVector3(variableName.Value);
			if (fsmVector != null)
			{
				fsmVector.Value = setValue.Value;
			}
			else
			{
				LogWarning("Could not find variable: " + variableName.Value);
			}
		}

		public override void OnUpdate()
		{
			DoSetFsmVector3();
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Builds a String from other Strings.")]
	public class BuildString : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Array of Strings to combine.")]
		public FsmString[] stringParts;

		[Tooltip("Separator to insert between each String. E.g. space character.")]
		public FsmString separator;

		[Tooltip("Add Separator to end of built string.")]
		public FsmBool addToEnd;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the final String in a variable.")]
		public FsmString storeResult;

		[Tooltip("Repeat every frame while the state is active.")]
		public bool everyFrame;

		private string result;

		public override void Reset()
		{
			stringParts = new FsmString[3];
			separator = null;
			addToEnd = true;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoBuildString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoBuildString();
		}

		private void DoBuildString()
		{
			if (storeResult != null)
			{
				result = "";
				for (int i = 0; i < stringParts.Length - 1; i++)
				{
					result += stringParts[i];
					result += separator.Value;
				}
				result += stringParts[stringParts.Length - 1];
				if (addToEnd.Value)
				{
					result += separator.Value;
				}
				storeResult.Value = result;
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Replaces each format item in a specified string with the text equivalent of variable's value. Stores the result in a string variable.")]
	public class FormatString : FsmStateAction
	{
		[RequiredField]
		[Tooltip("E.g. Hello {0} and {1}\nWith 2 variables that replace {0} and {1}\nSee C# string.Format docs.")]
		public FsmString format;

		[Tooltip("Variables to use for each formatting item.")]
		public FsmVar[] variables;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the formatted result in a string variable.")]
		public FsmString storeResult;

		[Tooltip("Repeat every frame. This is useful if the variables are changing.")]
		public bool everyFrame;

		private object[] objectArray;

		public override void Reset()
		{
			format = null;
			variables = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			objectArray = new object[variables.Length];
			DoFormatString();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoFormatString();
		}

		private void DoFormatString()
		{
			for (int i = 0; i < variables.Length; i++)
			{
				variables[i].UpdateValue();
				objectArray[i] = variables[i].GetValue();
			}
			try
			{
				storeResult.Value = string.Format(format.Value, objectArray);
			}
			catch (FormatException ex)
			{
				LogError(ex.Message);
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Gets the Left n characters from a String Variable.")]
	public class GetStringLeft : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		[Tooltip("Number of characters to get.")]
		public FsmInt charCount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			charCount = 0;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetStringLeft();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetStringLeft();
		}

		private void DoGetStringLeft()
		{
			if (!stringVariable.IsNone && !storeResult.IsNone)
			{
				storeResult.Value = stringVariable.Value.Substring(0, Mathf.Clamp(charCount.Value, 0, stringVariable.Value.Length));
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Gets the Length of a String.")]
	public class GetStringLength : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmInt storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetStringLength();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetStringLength();
		}

		private void DoGetStringLength()
		{
			if (stringVariable != null && storeResult != null)
			{
				storeResult.Value = stringVariable.Value.Length;
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Gets the Right n characters from a String.")]
	public class GetStringRight : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		[Tooltip("Number of characters to get.")]
		public FsmInt charCount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeResult;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			charCount = 0;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetStringRight();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetStringRight();
		}

		private void DoGetStringRight()
		{
			if (!stringVariable.IsNone && !storeResult.IsNone)
			{
				string value = stringVariable.Value;
				int num = Mathf.Clamp(charCount.Value, 0, value.Length);
				storeResult.Value = value.Substring(value.Length - num, num);
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Gets a sub-string from a String Variable.")]
	public class GetSubstring : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		[RequiredField]
		public FsmInt startIndex;

		[RequiredField]
		public FsmInt length;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			startIndex = 0;
			length = 1;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetSubstring();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetSubstring();
		}

		private void DoGetSubstring()
		{
			if (stringVariable != null && storeResult != null)
			{
				storeResult.Value = stringVariable.Value.Substring(startIndex.Value, length.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Select a Random String from an array of Strings.")]
	public class SelectRandomString : FsmStateAction
	{
		[CompoundArray("Strings", "String", "Weight")]
		public FsmString[] strings;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeString;

		public override void Reset()
		{
			strings = new FsmString[3];
			weights = new FsmFloat[3] { 1f, 1f, 1f };
			storeString = null;
		}

		public override void OnEnter()
		{
			DoSelectRandomString();
			Finish();
		}

		private void DoSelectRandomString()
		{
			if (strings != null && strings.Length != 0 && storeString != null)
			{
				int randomWeightedIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				if (randomWeightedIndex != -1)
				{
					storeString.Value = strings[randomWeightedIndex].Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Sets the value of a String Variable.")]
	public class SetStringValue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		[UIHint(UIHint.TextArea)]
		public FsmString stringValue;

		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			stringValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetStringValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetStringValue();
		}

		private void DoSetStringValue()
		{
			if (stringVariable != null && stringValue != null)
			{
				stringVariable.Value = stringValue.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Adds a String to the end of a String.")]
	public class StringAppend : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Strings to add to.")]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		[Tooltip("String to append")]
		public FsmString appendString;

		public override void Reset()
		{
			stringVariable = null;
			appendString = null;
		}

		public override void OnEnter()
		{
			stringVariable.Value += appendString.Value;
			Finish();
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Join an array of strings into a single string.")]
	public class StringJoin : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.String, "", 0, 0, 65536)]
		[Tooltip("Array of string to join into a single string.")]
		public FsmArray stringArray;

		[Tooltip("Separator to add between each string.")]
		public FsmString separator;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the joined string in string variable.")]
		public FsmString storeResult;

		public override void OnEnter()
		{
			if (!stringArray.IsNone && !storeResult.IsNone)
			{
				storeResult.Value = string.Join(separator.Value, stringArray.stringValues);
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Replace a substring with a new String.")]
	public class StringReplace : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString stringVariable;

		public FsmString replace;

		public FsmString with;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmString storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			stringVariable = null;
			replace = "";
			with = "";
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoReplace();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoReplace();
		}

		private void DoReplace()
		{
			if (stringVariable != null && storeResult != null)
			{
				storeResult.Value = stringVariable.Value.Replace(replace.Value, with.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.String)]
	[Tooltip("Splits a string into substrings using separator characters.")]
	public class StringSplit : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("String to split.")]
		public FsmString stringToSplit;

		[Tooltip("Characters used to split the string.\nUse '\\n' for newline\nUse '\\t' for tab")]
		public FsmString separators;

		[Tooltip("Remove all leading and trailing white-space characters from each separated string.")]
		public FsmBool trimStrings;

		[Tooltip("Optional characters used to trim each separated string.")]
		public FsmString trimChars;

		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.String, "", 0, 0, 65536)]
		[Tooltip("Store the split strings in a String Array.")]
		public FsmArray stringArray;

		public override void Reset()
		{
			stringToSplit = null;
			separators = null;
			trimStrings = false;
			trimChars = null;
			stringArray = null;
		}

		public override void OnEnter()
		{
			char[] array = trimChars.Value.ToCharArray();
			if (!stringToSplit.IsNone && !stringArray.IsNone)
			{
				FsmArray fsmArray = stringArray;
				object[] values = stringToSplit.Value.Split(separators.Value.ToCharArray());
				fsmArray.Values = values;
				if (trimStrings.Value)
				{
					for (int i = 0; i < stringArray.Values.Length; i++)
					{
						if (stringArray.Values[i] is string text)
						{
							if (!trimChars.IsNone && array.Length != 0)
							{
								stringArray.Set(i, text.Trim(array));
							}
							else
							{
								stringArray.Set(i, text.Trim());
							}
						}
					}
				}
				stringArray.SaveChanges();
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Time)]
	[Tooltip("Gets system date and time info and stores it in a string variable. An optional format string gives you a lot of control over the formatting (see online docs for format syntax).")]
	public class GetSystemDateTime : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Store System DateTime as a string.")]
		public FsmString storeString;

		[Tooltip("Optional format string. E.g., MM/dd/yyyy HH:mm")]
		public FsmString format;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			storeString = null;
			format = "MM/dd/yyyy HH:mm";
		}

		public override void OnEnter()
		{
			storeString.Value = DateTime.Now.ToString(format.Value);
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			storeString.Value = DateTime.Now.ToString(format.Value);
		}
	}
	[ActionCategory(ActionCategory.Time)]
	[Tooltip("Gets various useful Time measurements.")]
	public class GetTimeInfo : FsmStateAction
	{
		public enum TimeInfo
		{
			DeltaTime,
			TimeScale,
			SmoothDeltaTime,
			TimeInCurrentState,
			TimeSinceStartup,
			TimeSinceLevelLoad,
			RealTimeSinceStartup,
			RealTimeInCurrentState
		}

		public TimeInfo getInfo;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeValue;

		public bool everyFrame;

		public override void Reset()
		{
			getInfo = TimeInfo.TimeSinceLevelLoad;
			storeValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetTimeInfo();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTimeInfo();
		}

		private void DoGetTimeInfo()
		{
			switch (getInfo)
			{
			case TimeInfo.DeltaTime:
				storeValue.Value = Time.deltaTime;
				break;
			case TimeInfo.TimeScale:
				storeValue.Value = Time.timeScale;
				break;
			case TimeInfo.SmoothDeltaTime:
				storeValue.Value = Time.smoothDeltaTime;
				break;
			case TimeInfo.TimeInCurrentState:
				storeValue.Value = base.State.StateTime;
				break;
			case TimeInfo.TimeSinceStartup:
				storeValue.Value = Time.time;
				break;
			case TimeInfo.TimeSinceLevelLoad:
				storeValue.Value = Time.timeSinceLevelLoad;
				break;
			case TimeInfo.RealTimeSinceStartup:
				storeValue.Value = FsmTime.RealtimeSinceStartup;
				break;
			case TimeInfo.RealTimeInCurrentState:
				storeValue.Value = FsmTime.RealtimeSinceStartup - base.State.RealStartTime;
				break;
			default:
				storeValue.Value = 0f;
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Time)]
	[Tooltip("Multiplies a Float by Time.deltaTime to use in frame-rate independent operations. E.g., 10 becomes 10 units per second.")]
	public class PerSecond : FsmStateAction
	{
		[RequiredField]
		public FsmFloat floatValue;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			floatValue = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoPerSecond();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoPerSecond();
		}

		private void DoPerSecond()
		{
			if (storeResult != null)
			{
				storeResult.Value = floatValue.Value * Time.deltaTime;
			}
		}
	}
	[ActionCategory(ActionCategory.Time)]
	[Tooltip("Delays a State from finishing by a random time. NOTE: Other actions continue, but FINISHED can't happen before Time.")]
	public class RandomWait : FsmStateAction
	{
		[RequiredField]
		[Tooltip("Minimum amount of time to wait.")]
		public FsmFloat min;

		[RequiredField]
		[Tooltip("Maximum amount of time to wait.")]
		public FsmFloat max;

		[Tooltip("Event to send when timer is finished.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore time scale.")]
		public bool realTime;

		private float startTime;

		private float timer;

		private float time;

		public override void Reset()
		{
			min = 0f;
			max = 1f;
			finishEvent = null;
			realTime = false;
		}

		public override void OnEnter()
		{
			time = UnityEngine.Random.Range(min.Value, max.Value);
			if (time <= 0f)
			{
				base.Fsm.Event(finishEvent);
				Finish();
			}
			else
			{
				startTime = FsmTime.RealtimeSinceStartup;
				timer = 0f;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				timer = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				timer += Time.deltaTime;
			}
			if (timer >= time)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Time)]
	[Tooltip("Scales time: 1 = normal, 0.5 = half speed, 2 = double speed.")]
	public class ScaleTime : FsmStateAction
	{
		[RequiredField]
		[HasFloatSlider(0f, 4f)]
		[Tooltip("Scales time: 1 = normal, 0.5 = half speed, 2 = double speed.")]
		public FsmFloat timeScale;

		[Tooltip("Adjust the fixed physics time step to match the time scale.")]
		public FsmBool adjustFixedDeltaTime;

		[Tooltip("Repeat every frame. Useful when animating the value.")]
		public bool everyFrame;

		public override void Reset()
		{
			timeScale = 1f;
			adjustFixedDeltaTime = true;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoTimeScale();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoTimeScale();
		}

		private void DoTimeScale()
		{
			Time.timeScale = timeScale.Value;
			if (adjustFixedDeltaTime.Value)
			{
				Time.fixedDeltaTime = 0.02f * Time.timeScale;
			}
		}
	}
	[ActionCategory(ActionCategory.Time)]
	[Tooltip("Delays a State from finishing by the specified time. NOTE: Other actions continue, but FINISHED can't happen before Time.")]
	public class Wait : FsmStateAction
	{
		[RequiredField]
		public FsmFloat time;

		public FsmEvent finishEvent;

		public bool realTime;

		private float startTime;

		private float timer;

		public override void Reset()
		{
			time = 1f;
			finishEvent = null;
			realTime = false;
		}

		public override void OnEnter()
		{
			if (time.Value <= 0f)
			{
				base.Fsm.Event(finishEvent);
				Finish();
			}
			else
			{
				startTime = FsmTime.RealtimeSinceStartup;
				timer = 0f;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				timer = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				timer += Time.deltaTime;
			}
			if (timer >= time.Value)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Gets the Angle between a GameObject's forward axis and a Target. The Target can be defined as a GameObject or a world Position. If you specify both, then the Position will be used as a local offset from the Target Object's position.")]
	public class GetAngleToTarget : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The game object whose forward axis we measure from. If the target is dead ahead the angle will be 0.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The target object to measure the angle to. Or use target position.")]
		public FsmGameObject targetObject;

		[Tooltip("The world position to measure an angle to. If Target Object is also specified, this vector is used as an offset from that object's position.")]
		public FsmVector3 targetPosition;

		[Tooltip("Ignore height differences when calculating the angle.")]
		public FsmBool ignoreHeight;

		[Tooltip("Return a signed angle.")]
		public FsmBool getSignedAngle;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the angle in a float variable.")]
		public FsmFloat storeAngle;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			targetPosition = new FsmVector3
			{
				UseVariable = true
			};
			ignoreHeight = true;
			storeAngle = null;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnLateUpdate()
		{
			DoGetAngleToTarget();
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoGetAngleToTarget()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			GameObject value = targetObject.Value;
			if (!(value == null) || !targetPosition.IsNone)
			{
				Vector3 vector = ((!(value != null)) ? targetPosition.Value : ((!targetPosition.IsNone) ? value.transform.TransformPoint(targetPosition.Value) : value.transform.position));
				if (ignoreHeight.Value)
				{
					vector.y = ownerDefaultTarget.transform.position.y;
				}
				Vector3 vector2 = vector - ownerDefaultTarget.transform.position;
				if (getSignedAngle.Value)
				{
					storeAngle.Value = Vector3.SignedAngle(ownerDefaultTarget.transform.forward, vector2, ownerDefaultTarget.transform.up);
				}
				else
				{
					storeAngle.Value = Vector3.Angle(vector2, ownerDefaultTarget.transform.forward);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Gets the Position of a Game Object and stores it in a Vector3 Variable or each Axis in a Float Variable")]
	public class GetPosition : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		public FsmVector3 vector;

		[UIHint(UIHint.Variable)]
		public FsmFloat x;

		[UIHint(UIHint.Variable)]
		public FsmFloat y;

		[UIHint(UIHint.Variable)]
		public FsmFloat z;

		public Space space;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = null;
			y = null;
			z = null;
			space = Space.World;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetPosition();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetPosition();
		}

		private void DoGetPosition()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 value = ((space == Space.World) ? ownerDefaultTarget.transform.position : ownerDefaultTarget.transform.localPosition);
				vector.Value = value;
				x.Value = value.x;
				y.Value = value.y;
				z.Value = value.z;
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Gets the Rotation of a Game Object and stores it in a Vector3 Variable or each Axis in a Float Variable")]
	public class GetRotation : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		public FsmQuaternion quaternion;

		[UIHint(UIHint.Variable)]
		[Title("Euler Angles")]
		public FsmVector3 vector;

		[UIHint(UIHint.Variable)]
		public FsmFloat xAngle;

		[UIHint(UIHint.Variable)]
		public FsmFloat yAngle;

		[UIHint(UIHint.Variable)]
		public FsmFloat zAngle;

		public Space space;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			quaternion = null;
			vector = null;
			xAngle = null;
			yAngle = null;
			zAngle = null;
			space = Space.World;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetRotation();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetRotation();
		}

		private void DoGetRotation()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				if (space == Space.World)
				{
					quaternion.Value = ownerDefaultTarget.transform.rotation;
					Vector3 eulerAngles = ownerDefaultTarget.transform.eulerAngles;
					vector.Value = eulerAngles;
					xAngle.Value = eulerAngles.x;
					yAngle.Value = eulerAngles.y;
					zAngle.Value = eulerAngles.z;
				}
				else
				{
					Vector3 localEulerAngles = ownerDefaultTarget.transform.localEulerAngles;
					quaternion.Value = Quaternion.Euler(localEulerAngles);
					vector.Value = localEulerAngles;
					xAngle.Value = localEulerAngles.x;
					yAngle.Value = localEulerAngles.y;
					zAngle.Value = localEulerAngles.z;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Gets the Scale of a Game Object and stores it in a Vector3 Variable or each Axis in a Float Variable")]
	public class GetScale : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		public FsmVector3 vector;

		[UIHint(UIHint.Variable)]
		public FsmFloat xScale;

		[UIHint(UIHint.Variable)]
		public FsmFloat yScale;

		[UIHint(UIHint.Variable)]
		public FsmFloat zScale;

		public Space space;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			xScale = null;
			yScale = null;
			zScale = null;
			space = Space.World;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetScale();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetScale();
		}

		private void DoGetScale()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 value = ((space == Space.World) ? ownerDefaultTarget.transform.lossyScale : ownerDefaultTarget.transform.localScale);
				vector.Value = value;
				xScale.Value = value.x;
				yScale.Value = value.y;
				zScale.Value = value.z;
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Transforms a Direction from world space to a Game Object's local space. The opposite of TransformDirection.")]
	public class InverseTransformDirection : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmVector3 worldDirection;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			worldDirection = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoInverseTransformDirection();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoInverseTransformDirection();
		}

		private void DoInverseTransformDirection()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				storeResult.Value = ownerDefaultTarget.transform.InverseTransformDirection(worldDirection.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Transforms position from world space to a Game Object's local space. The opposite of TransformPoint.")]
	public class InverseTransformPoint : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmVector3 worldPosition;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			worldPosition = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoInverseTransformPoint();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoInverseTransformPoint();
		}

		private void DoInverseTransformPoint()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				storeResult.Value = ownerDefaultTarget.transform.InverseTransformPoint(worldPosition.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Rotates a Game Object so its forward vector points at a Target. The Target can be specified as a GameObject or a world Position. If you specify both, then Position specifies a local offset from the target object's Position.")]
	public class LookAt : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to rotate.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The GameObject to Look At.")]
		public FsmGameObject targetObject;

		[Tooltip("World position to look at, or local offset from Target Object if specified.")]
		public FsmVector3 targetPosition;

		[Tooltip("Rotate the GameObject to point its up direction vector in the direction hinted at by the Up Vector. See Unity Look At docs for more details.")]
		public FsmVector3 upVector;

		[Tooltip("Don't rotate vertically.")]
		public FsmBool keepVertical;

		[Title("Draw Debug Line")]
		[Tooltip("Draw a debug line from the GameObject to the Target.")]
		public FsmBool debug;

		[Tooltip("Color to use for the debug line.")]
		public FsmColor debugLineColor;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame = true;

		private GameObject go;

		private GameObject goTarget;

		private Vector3 lookAtPos;

		private Vector3 lookAtPosWithVertical;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			targetPosition = new FsmVector3
			{
				UseVariable = true
			};
			upVector = new FsmVector3
			{
				UseVariable = true
			};
			keepVertical = true;
			debug = false;
			debugLineColor = Color.yellow;
			everyFrame = true;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnEnter()
		{
			DoLookAt();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnLateUpdate()
		{
			DoLookAt();
		}

		private void DoLookAt()
		{
			if (UpdateLookAtPosition())
			{
				go.transform.LookAt(lookAtPos, upVector.IsNone ? Vector3.up : upVector.Value);
				if (debug.Value)
				{
					UnityEngine.Debug.DrawLine(go.transform.position, lookAtPos, debugLineColor.Value);
				}
			}
		}

		public bool UpdateLookAtPosition()
		{
			if (base.Fsm == null)
			{
				return false;
			}
			go = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (go == null)
			{
				return false;
			}
			goTarget = targetObject.Value;
			if (goTarget == null && targetPosition.IsNone)
			{
				return false;
			}
			if (goTarget != null)
			{
				lookAtPos = ((!targetPosition.IsNone) ? goTarget.transform.TransformPoint(targetPosition.Value) : goTarget.transform.position);
			}
			else
			{
				lookAtPos = targetPosition.Value;
			}
			lookAtPosWithVertical = lookAtPos;
			if (keepVertical.Value)
			{
				lookAtPos.y = go.transform.position.y;
			}
			return true;
		}

		public Vector3 GetLookAtPosition()
		{
			return lookAtPos;
		}

		public Vector3 GetLookAtPositionWithVertical()
		{
			return lookAtPosWithVertical;
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[HelpUrl("http://hutonggames.com/playmakerforum/index.php?topic=4758.0")]
	[Tooltip("Move a GameObject to another GameObject. Works like iTween Move To, but with better performance.")]
	public class MoveObject : EaseFsmAction
	{
		[RequiredField]
		public FsmOwnerDefault objectToMove;

		[RequiredField]
		public FsmGameObject destination;

		private FsmVector3 fromValue;

		private FsmVector3 toVector;

		private FsmVector3 fromVector;

		private bool finishInNextStep;

		public override void Reset()
		{
			base.Reset();
			fromValue = null;
			toVector = null;
			finishInNextStep = false;
			fromVector = null;
		}

		public override void OnEnter()
		{
			base.OnEnter();
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(objectToMove);
			fromVector = ownerDefaultTarget.transform.position;
			toVector = destination.Value.transform.position;
			fromFloats = new float[3];
			fromFloats[0] = fromVector.Value.x;
			fromFloats[1] = fromVector.Value.y;
			fromFloats[2] = fromVector.Value.z;
			toFloats = new float[3];
			toFloats[0] = toVector.Value.x;
			toFloats[1] = toVector.Value.y;
			toFloats[2] = toVector.Value.z;
			resultFloats = new float[3];
			resultFloats[0] = fromVector.Value.x;
			resultFloats[1] = fromVector.Value.y;
			resultFloats[2] = fromVector.Value.z;
			finishInNextStep = false;
		}

		public override void OnUpdate()
		{
			base.OnUpdate();
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(objectToMove);
			ownerDefaultTarget.transform.position = new Vector3(resultFloats[0], resultFloats[1], resultFloats[2]);
			if (finishInNextStep)
			{
				Finish();
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
			}
			if (finishAction && !finishInNextStep)
			{
				ownerDefaultTarget.transform.position = new Vector3(reverse.IsNone ? toVector.Value.x : (reverse.Value ? fromValue.Value.x : toVector.Value.x), reverse.IsNone ? toVector.Value.y : (reverse.Value ? fromValue.Value.y : toVector.Value.y), reverse.IsNone ? toVector.Value.z : (reverse.Value ? fromValue.Value.z : toVector.Value.z));
				finishInNextStep = true;
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Moves a Game Object towards a Target. Optionally sends an event when successful. The Target can be specified as a Game Object or a world Position. If you specify both, then the Position is used as a local offset from the Object's Position.")]
	public class MoveTowards : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to Move")]
		public FsmOwnerDefault gameObject;

		[Tooltip("A target GameObject to move towards. Or use a world Target Position below.")]
		public FsmGameObject targetObject;

		[Tooltip("A world position if no Target Object. Otherwise used as a local offset from the Target Object.")]
		public FsmVector3 targetPosition;

		[Tooltip("Ignore any height difference in the target.")]
		public FsmBool ignoreVertical;

		[HasFloatSlider(0f, 20f)]
		[Tooltip("The maximum movement speed. HINT: You can make this a variable to change it over time.")]
		public FsmFloat maxSpeed;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Distance at which the move is considered finished, and the Finish Event is sent.")]
		public FsmFloat finishDistance;

		[Tooltip("Event to send when the Finish Distance is reached.")]
		public FsmEvent finishEvent;

		private GameObject go;

		private GameObject goTarget;

		private Vector3 targetPos;

		private Vector3 targetPosWithVertical;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			maxSpeed = 10f;
			finishDistance = 1f;
			finishEvent = null;
		}

		public override void OnUpdate()
		{
			DoMoveTowards();
		}

		private void DoMoveTowards()
		{
			if (UpdateTargetPos())
			{
				go.transform.position = Vector3.MoveTowards(go.transform.position, targetPos, maxSpeed.Value * Time.deltaTime);
				if ((go.transform.position - targetPos).magnitude < finishDistance.Value)
				{
					base.Fsm.Event(finishEvent);
					Finish();
				}
			}
		}

		public bool UpdateTargetPos()
		{
			go = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (go == null)
			{
				return false;
			}
			goTarget = targetObject.Value;
			if (goTarget == null && targetPosition.IsNone)
			{
				return false;
			}
			if (goTarget != null)
			{
				targetPos = ((!targetPosition.IsNone) ? goTarget.transform.TransformPoint(targetPosition.Value) : goTarget.transform.position);
			}
			else
			{
				targetPos = targetPosition.Value;
			}
			targetPosWithVertical = targetPos;
			if (ignoreVertical.Value)
			{
				targetPos.y = go.transform.position.y;
			}
			return true;
		}

		public Vector3 GetTargetPos()
		{
			return targetPos;
		}

		public Vector3 GetTargetPosWithVertical()
		{
			return targetPosWithVertical;
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Rotates a Game Object around each Axis. Use a Vector3 Variable and/or XYZ components. To leave any axis unchanged, set variable to 'None'.")]
	public class Rotate : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The game object to rotate.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("A rotation vector specifying rotation around x, y, and z axis. NOTE: You can override individual axis below.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector;

		[Tooltip("Rotation around x axis.")]
		public FsmFloat xAngle;

		[Tooltip("Rotation around y axis.")]
		public FsmFloat yAngle;

		[Tooltip("Rotation around z axis.")]
		public FsmFloat zAngle;

		[Tooltip("Rotate in local or world space.")]
		public Space space;

		[Tooltip("Rotation is specified in degrees per second. In other words, the amount to rotate in over one second. This allows rotations to be frame rate independent. It is the same as multiplying the rotation by Time.deltaTime.")]
		public bool perSecond;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[Tooltip("Perform the rotation in LateUpdate. This is useful if you want to override the rotation of objects that are animated or otherwise rotated in Update.")]
		public bool lateUpdate;

		[Tooltip("Perform the rotation in FixedUpdate. This is useful when working with rigid bodies and physics.")]
		public bool fixedUpdate;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			xAngle = new FsmFloat
			{
				UseVariable = true
			};
			yAngle = new FsmFloat
			{
				UseVariable = true
			};
			zAngle = new FsmFloat
			{
				UseVariable = true
			};
			space = Space.Self;
			perSecond = false;
			everyFrame = true;
			lateUpdate = false;
			fixedUpdate = false;
		}

		public override void OnPreprocess()
		{
			if (fixedUpdate)
			{
				base.Fsm.HandleFixedUpdate = true;
			}
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			if (!everyFrame && !lateUpdate && !fixedUpdate)
			{
				DoRotate();
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (!lateUpdate && !fixedUpdate)
			{
				DoRotate();
			}
		}

		public override void OnLateUpdate()
		{
			if (lateUpdate)
			{
				DoRotate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			if (fixedUpdate)
			{
				DoRotate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoRotate()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 vector = (this.vector.IsNone ? new Vector3(xAngle.Value, yAngle.Value, zAngle.Value) : this.vector.Value);
				if (!xAngle.IsNone)
				{
					vector.x = xAngle.Value;
				}
				if (!yAngle.IsNone)
				{
					vector.y = yAngle.Value;
				}
				if (!zAngle.IsNone)
				{
					vector.z = zAngle.Value;
				}
				if (!perSecond)
				{
					ownerDefaultTarget.transform.Rotate(vector, space);
				}
				else
				{
					ownerDefaultTarget.transform.Rotate(vector * Time.deltaTime, space);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Sets the Position of a Game Object. To leave any axis unchanged, set variable to 'None'.")]
	public class SetPosition : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to position.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Use a stored Vector3 position, and/or set individual axis below.")]
		public FsmVector3 vector;

		public FsmFloat x;

		public FsmFloat y;

		public FsmFloat z;

		[Tooltip("Use local or world space.")]
		public Space space;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[Tooltip("Perform in LateUpdate. This is useful if you want to override the position of objects that are animated or otherwise positioned in Update.")]
		public bool lateUpdate;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			space = Space.Self;
			everyFrame = false;
			lateUpdate = false;
		}

		public override void OnPreprocess()
		{
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			if (!everyFrame && !lateUpdate)
			{
				DoSetPosition();
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (!lateUpdate)
			{
				DoSetPosition();
			}
		}

		public override void OnLateUpdate()
		{
			if (lateUpdate)
			{
				DoSetPosition();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetPosition()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 vector = ((!this.vector.IsNone) ? this.vector.Value : ((space == Space.World) ? ownerDefaultTarget.transform.position : ownerDefaultTarget.transform.localPosition));
				if (!x.IsNone)
				{
					vector.x = x.Value;
				}
				if (!y.IsNone)
				{
					vector.y = y.Value;
				}
				if (!z.IsNone)
				{
					vector.z = z.Value;
				}
				if (space == Space.World)
				{
					ownerDefaultTarget.transform.position = vector;
				}
				else
				{
					ownerDefaultTarget.transform.localPosition = vector;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Sets Random Rotation for a Game Object. Uncheck an axis to keep its current value.")]
	public class SetRandomRotation : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmBool x;

		[RequiredField]
		public FsmBool y;

		[RequiredField]
		public FsmBool z;

		public override void Reset()
		{
			gameObject = null;
			x = true;
			y = true;
			z = true;
		}

		public override void OnEnter()
		{
			DoRandomRotation();
			Finish();
		}

		private void DoRandomRotation()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 localEulerAngles = ownerDefaultTarget.transform.localEulerAngles;
				float num = localEulerAngles.x;
				float num2 = localEulerAngles.y;
				float num3 = localEulerAngles.z;
				if (x.Value)
				{
					num = UnityEngine.Random.Range(0, 360);
				}
				if (y.Value)
				{
					num2 = UnityEngine.Random.Range(0, 360);
				}
				if (z.Value)
				{
					num3 = UnityEngine.Random.Range(0, 360);
				}
				ownerDefaultTarget.transform.localEulerAngles = new Vector3(num, num2, num3);
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Sets the Rotation of a Game Object. To leave any axis unchanged, set variable to 'None'.")]
	public class SetRotation : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to rotate.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Use a stored quaternion, or vector angles below.")]
		public FsmQuaternion quaternion;

		[UIHint(UIHint.Variable)]
		[Title("Euler Angles")]
		[Tooltip("Use euler angles stored in a Vector3 variable, and/or set each axis below.")]
		public FsmVector3 vector;

		public FsmFloat xAngle;

		public FsmFloat yAngle;

		public FsmFloat zAngle;

		[Tooltip("Use local or world space.")]
		public Space space;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[Tooltip("Perform in LateUpdate. This is useful if you want to override the position of objects that are animated or otherwise positioned in Update.")]
		public bool lateUpdate;

		public override void Reset()
		{
			gameObject = null;
			quaternion = null;
			vector = null;
			xAngle = new FsmFloat
			{
				UseVariable = true
			};
			yAngle = new FsmFloat
			{
				UseVariable = true
			};
			zAngle = new FsmFloat
			{
				UseVariable = true
			};
			space = Space.World;
			everyFrame = false;
			lateUpdate = false;
		}

		public override void OnPreprocess()
		{
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			if (!everyFrame && !lateUpdate)
			{
				DoSetRotation();
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (!lateUpdate)
			{
				DoSetRotation();
			}
		}

		public override void OnLateUpdate()
		{
			if (lateUpdate)
			{
				DoSetRotation();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetRotation()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 vector = ((!quaternion.IsNone) ? quaternion.Value.eulerAngles : (this.vector.IsNone ? ((space == Space.Self) ? ownerDefaultTarget.transform.localEulerAngles : ownerDefaultTarget.transform.eulerAngles) : this.vector.Value));
				if (!xAngle.IsNone)
				{
					vector.x = xAngle.Value;
				}
				if (!yAngle.IsNone)
				{
					vector.y = yAngle.Value;
				}
				if (!zAngle.IsNone)
				{
					vector.z = zAngle.Value;
				}
				if (space == Space.Self)
				{
					ownerDefaultTarget.transform.localEulerAngles = vector;
				}
				else
				{
					ownerDefaultTarget.transform.eulerAngles = vector;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Sets the Scale of a Game Object. To leave any axis unchanged, set variable to 'None'.")]
	public class SetScale : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to scale.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Use stored Vector3 value, and/or set each axis below.")]
		public FsmVector3 vector;

		public FsmFloat x;

		public FsmFloat y;

		public FsmFloat z;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[Tooltip("Perform in LateUpdate. This is useful if you want to override the position of objects that are animated or otherwise positioned in Update.")]
		public bool lateUpdate;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
			lateUpdate = false;
		}

		public override void OnPreprocess()
		{
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			DoSetScale();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (!lateUpdate)
			{
				DoSetScale();
			}
		}

		public override void OnLateUpdate()
		{
			if (lateUpdate)
			{
				DoSetScale();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoSetScale()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 localScale = (vector.IsNone ? ownerDefaultTarget.transform.localScale : vector.Value);
				if (!x.IsNone)
				{
					localScale.x = x.Value;
				}
				if (!y.IsNone)
				{
					localScale.y = y.Value;
				}
				if (!z.IsNone)
				{
					localScale.z = z.Value;
				}
				ownerDefaultTarget.transform.localScale = localScale;
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Action version of Unity's Smooth Follow script.")]
	public class SmoothFollowAction : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The game object to control. E.g. The camera.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The GameObject to follow.")]
		public FsmGameObject targetObject;

		[RequiredField]
		[Tooltip("The distance in the x-z plane to the target.")]
		public FsmFloat distance;

		[RequiredField]
		[Tooltip("The height we want the camera to be above the target")]
		public FsmFloat height;

		[RequiredField]
		[Tooltip("How much to dampen height movement.")]
		public FsmFloat heightDamping;

		[RequiredField]
		[Tooltip("How much to dampen rotation changes.")]
		public FsmFloat rotationDamping;

		private GameObject cachedObject;

		private Transform myTransform;

		private GameObject cachedTarget;

		private Transform targetTransform;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			distance = 10f;
			height = 5f;
			heightDamping = 2f;
			rotationDamping = 3f;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnLateUpdate()
		{
			if (targetObject.Value == null)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				if (cachedObject != ownerDefaultTarget)
				{
					cachedObject = ownerDefaultTarget;
					myTransform = ownerDefaultTarget.transform;
				}
				if (cachedTarget != targetObject.Value)
				{
					cachedTarget = targetObject.Value;
					targetTransform = cachedTarget.transform;
				}
				float y = targetTransform.eulerAngles.y;
				float b = targetTransform.position.y + height.Value;
				float y2 = myTransform.eulerAngles.y;
				float y3 = myTransform.position.y;
				y2 = Mathf.LerpAngle(y2, y, rotationDamping.Value * Time.deltaTime);
				y3 = Mathf.Lerp(y3, b, heightDamping.Value * Time.deltaTime);
				Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
				myTransform.position = targetTransform.position;
				myTransform.position -= quaternion * Vector3.forward * distance.Value;
				myTransform.position = new Vector3(myTransform.position.x, y3, myTransform.position.z);
				myTransform.LookAt(targetTransform);
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Smoothly Rotates a Game Object so its forward vector points at a Target. The target can be defined as a Game Object or a world Position. If you specify both, then the position will be used as a local offset from the object's position.")]
	public class SmoothLookAt : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to rotate to face a target.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("A target GameObject.")]
		public FsmGameObject targetObject;

		[Tooltip("A target position. If a Target Object is defined, this is used as a local offset.")]
		public FsmVector3 targetPosition;

		[Tooltip("Used to keep the game object generally upright. If left undefined the world y axis is used.")]
		public FsmVector3 upVector;

		[Tooltip("Force the game object to remain vertical. Useful for characters.")]
		public FsmBool keepVertical;

		[HasFloatSlider(0.5f, 15f)]
		[Tooltip("How fast the look at moves.")]
		public FsmFloat speed;

		[Tooltip("Draw a line in the Scene View to the look at position.")]
		public FsmBool debug;

		[Tooltip("If the angle to the target is less than this, send the Finish Event below. Measured in degrees.")]
		public FsmFloat finishTolerance;

		[Tooltip("Event to send if the angle to target is less than the Finish Tolerance.")]
		public FsmEvent finishEvent;

		private GameObject previousGo;

		private Quaternion lastRotation;

		private Quaternion desiredRotation;

		public override void Reset()
		{
			gameObject = null;
			targetObject = null;
			targetPosition = new FsmVector3
			{
				UseVariable = true
			};
			upVector = new FsmVector3
			{
				UseVariable = true
			};
			keepVertical = true;
			debug = false;
			speed = 5f;
			finishTolerance = 1f;
			finishEvent = null;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnEnter()
		{
			previousGo = null;
		}

		public override void OnLateUpdate()
		{
			DoSmoothLookAt();
		}

		private void DoSmoothLookAt()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			GameObject value = targetObject.Value;
			if (!(value == null) || !targetPosition.IsNone)
			{
				if (previousGo != ownerDefaultTarget)
				{
					lastRotation = ownerDefaultTarget.transform.rotation;
					desiredRotation = lastRotation;
					previousGo = ownerDefaultTarget;
				}
				Vector3 vector = ((!(value != null)) ? targetPosition.Value : ((!targetPosition.IsNone) ? value.transform.TransformPoint(targetPosition.Value) : value.transform.position));
				if (keepVertical.Value)
				{
					vector.y = ownerDefaultTarget.transform.position.y;
				}
				Vector3 vector2 = vector - ownerDefaultTarget.transform.position;
				if (vector2 != Vector3.zero && vector2.sqrMagnitude > 0f)
				{
					desiredRotation = Quaternion.LookRotation(vector2, upVector.IsNone ? Vector3.up : upVector.Value);
				}
				lastRotation = Quaternion.Slerp(lastRotation, desiredRotation, speed.Value * Time.deltaTime);
				ownerDefaultTarget.transform.rotation = lastRotation;
				if (debug.Value)
				{
					UnityEngine.Debug.DrawLine(ownerDefaultTarget.transform.position, vector, Color.grey);
				}
				if (finishEvent != null && Mathf.Abs(Vector3.Angle(vector - ownerDefaultTarget.transform.position, ownerDefaultTarget.transform.forward)) <= finishTolerance.Value)
				{
					base.Fsm.Event(finishEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Smoothly Rotates a Game Object so its forward vector points in the specified Direction. Lets you fire an event when minmagnitude is reached")]
	public class SmoothLookAtDirection : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The GameObject to rotate.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The direction to smoothly rotate towards.")]
		public FsmVector3 targetDirection;

		[Tooltip("Only rotate if Target Direction Vector length is greater than this threshold.")]
		public FsmFloat minMagnitude;

		[Tooltip("Keep this vector pointing up as the GameObject rotates.")]
		public FsmVector3 upVector;

		[RequiredField]
		[Tooltip("Eliminate any tilt up/down as the GameObject rotates.")]
		public FsmBool keepVertical;

		[RequiredField]
		[HasFloatSlider(0.5f, 15f)]
		[Tooltip("How quickly to rotate.")]
		public FsmFloat speed;

		[Tooltip("Perform in LateUpdate. This can help eliminate jitters in some situations.")]
		public bool lateUpdate;

		[Tooltip("Event to send if the direction difference is less than Min Magnitude.")]
		public FsmEvent finishEvent;

		[Tooltip("Stop running the action if the direction difference is less than Min Magnitude.")]
		public FsmBool finish;

		private GameObject previousGo;

		private Quaternion lastRotation;

		private Quaternion desiredRotation;

		public override void Reset()
		{
			gameObject = null;
			targetDirection = new FsmVector3
			{
				UseVariable = true
			};
			minMagnitude = 0.1f;
			upVector = new FsmVector3
			{
				UseVariable = true
			};
			keepVertical = true;
			speed = 5f;
			lateUpdate = true;
			finishEvent = null;
		}

		public override void OnPreprocess()
		{
			base.Fsm.HandleLateUpdate = true;
		}

		public override void OnEnter()
		{
			previousGo = null;
		}

		public override void OnUpdate()
		{
			if (!lateUpdate)
			{
				DoSmoothLookAtDirection();
			}
		}

		public override void OnLateUpdate()
		{
			if (lateUpdate)
			{
				DoSmoothLookAtDirection();
			}
		}

		private void DoSmoothLookAtDirection()
		{
			if (targetDirection.IsNone)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget == null)
			{
				return;
			}
			if (previousGo != ownerDefaultTarget)
			{
				lastRotation = ownerDefaultTarget.transform.rotation;
				desiredRotation = lastRotation;
				previousGo = ownerDefaultTarget;
			}
			Vector3 value = targetDirection.Value;
			if (keepVertical.Value)
			{
				value.y = 0f;
			}
			bool flag = false;
			if (value.sqrMagnitude > minMagnitude.Value)
			{
				desiredRotation = Quaternion.LookRotation(value, upVector.IsNone ? Vector3.up : upVector.Value);
			}
			else
			{
				flag = true;
			}
			lastRotation = Quaternion.Slerp(lastRotation, desiredRotation, speed.Value * Time.deltaTime);
			ownerDefaultTarget.transform.rotation = lastRotation;
			if (flag)
			{
				base.Fsm.Event(finishEvent);
				if (finish.Value)
				{
					Finish();
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Transforms a Direction from a Game Object's local space to world space.")]
	public class TransformDirection : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmVector3 localDirection;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			localDirection = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoTransformDirection();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoTransformDirection();
		}

		private void DoTransformDirection()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				storeResult.Value = ownerDefaultTarget.transform.TransformDirection(localDirection.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Transforms a Position from a Game Object's local space to world space.")]
	public class TransformPoint : FsmStateAction
	{
		[RequiredField]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		public FsmVector3 localPosition;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeResult;

		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			localPosition = null;
			storeResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoTransformPoint();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoTransformPoint();
		}

		private void DoTransformPoint()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				storeResult.Value = ownerDefaultTarget.transform.TransformPoint(localPosition.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.Transform)]
	[Tooltip("Translates a Game Object. Use a Vector3 variable and/or XYZ components. To leave any axis unchanged, set variable to 'None'.")]
	public class Translate : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The game object to translate.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Readonly]
		[Tooltip("A translation vector. NOTE: You can override individual axis below.")]
		public FsmVector3 vector;

		[Tooltip("Translation along x axis.")]
		public FsmFloat x;

		[Tooltip("Translation along y axis.")]
		public FsmFloat y;

		[Tooltip("Translation along z axis.")]
		public FsmFloat z;

		[Tooltip("Translate in local or world space.")]
		public Space space;

		[Tooltip("Translate over one second")]
		public bool perSecond;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[Tooltip("Perform the translate in LateUpdate. This is useful if you want to override the position of objects that are animated or otherwise positioned in Update.")]
		public bool lateUpdate;

		[Tooltip("Perform the translate in FixedUpdate. This is useful when working with rigid bodies and physics.")]
		public bool fixedUpdate;

		public override void Reset()
		{
			gameObject = null;
			vector = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			space = Space.Self;
			perSecond = true;
			everyFrame = true;
			lateUpdate = false;
			fixedUpdate = false;
		}

		public override void OnPreprocess()
		{
			if (fixedUpdate)
			{
				base.Fsm.HandleFixedUpdate = true;
			}
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			if (!everyFrame && !lateUpdate && !fixedUpdate)
			{
				DoTranslate();
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if (!lateUpdate && !fixedUpdate)
			{
				DoTranslate();
			}
		}

		public override void OnLateUpdate()
		{
			if (lateUpdate)
			{
				DoTranslate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnFixedUpdate()
		{
			if (fixedUpdate)
			{
				DoTranslate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoTranslate()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (!(ownerDefaultTarget == null))
			{
				Vector3 vector = (this.vector.IsNone ? new Vector3(x.Value, y.Value, z.Value) : this.vector.Value);
				if (!x.IsNone)
				{
					vector.x = x.Value;
				}
				if (!y.IsNone)
				{
					vector.y = y.Value;
				}
				if (!z.IsNone)
				{
					vector.z = z.Value;
				}
				if (!perSecond)
				{
					ownerDefaultTarget.transform.Translate(vector, space);
				}
				else
				{
					ownerDefaultTarget.transform.Translate(vector * Time.deltaTime, space);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the Arc Cosine. You can get the result in degrees, simply check on the RadToDeg conversion")]
	public class GetACosine : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The value of the cosine")]
		public FsmFloat Value;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting angle. Note:If you want degrees, simply check RadToDeg")]
		public FsmFloat angle;

		[Tooltip("Check on if you want the angle expressed in degrees.")]
		public FsmBool RadToDeg;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			angle = null;
			RadToDeg = true;
			everyFrame = false;
			Value = null;
		}

		public override void OnEnter()
		{
			DoACosine();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoACosine();
		}

		private void DoACosine()
		{
			float num = Mathf.Acos(Value.Value);
			if (RadToDeg.Value)
			{
				num *= 57.29578f;
			}
			angle.Value = num;
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the Arc sine. You can get the result in degrees, simply check on the RadToDeg conversion")]
	public class GetASine : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The value of the sine")]
		public FsmFloat Value;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting angle. Note:If you want degrees, simply check RadToDeg")]
		public FsmFloat angle;

		[Tooltip("Check on if you want the angle expressed in degrees.")]
		public FsmBool RadToDeg;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			angle = null;
			RadToDeg = true;
			everyFrame = false;
			Value = null;
		}

		public override void OnEnter()
		{
			DoASine();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoASine();
		}

		private void DoASine()
		{
			float num = Mathf.Asin(Value.Value);
			if (RadToDeg.Value)
			{
				num *= 57.29578f;
			}
			angle.Value = num;
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the Arc Tangent. You can get the result in degrees, simply check on the RadToDeg conversion")]
	public class GetAtan : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The value of the tan")]
		public FsmFloat Value;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting angle. Note:If you want degrees, simply check RadToDeg")]
		public FsmFloat angle;

		[Tooltip("Check on if you want the angle expressed in degrees.")]
		public FsmBool RadToDeg;

		public bool everyFrame;

		public override void Reset()
		{
			Value = null;
			RadToDeg = true;
			everyFrame = false;
			angle = null;
		}

		public override void OnEnter()
		{
			DoATan();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoATan();
		}

		private void DoATan()
		{
			float num = Mathf.Atan(Value.Value);
			if (RadToDeg.Value)
			{
				num *= 57.29578f;
			}
			angle.Value = num;
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the Arc Tangent 2 as in atan2(y,x). You can get the result in degrees, simply check on the RadToDeg conversion")]
	public class GetAtan2 : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The x value of the tan")]
		public FsmFloat xValue;

		[RequiredField]
		[Tooltip("The y value of the tan")]
		public FsmFloat yValue;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting angle. Note:If you want degrees, simply check RadToDeg")]
		public FsmFloat angle;

		[Tooltip("Check on if you want the angle expressed in degrees.")]
		public FsmBool RadToDeg;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			xValue = null;
			yValue = null;
			RadToDeg = true;
			everyFrame = false;
			angle = null;
		}

		public override void OnEnter()
		{
			DoATan();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoATan();
		}

		private void DoATan()
		{
			float num = Mathf.Atan2(yValue.Value, xValue.Value);
			if (RadToDeg.Value)
			{
				num *= 57.29578f;
			}
			angle.Value = num;
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the Arc Tangent 2 as in atan2(y,x) from a vector 2. You can get the result in degrees, simply check on the RadToDeg conversion")]
	public class GetAtan2FromVector2 : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The vector2 of the tan")]
		public FsmVector2 vector2;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting angle. Note:If you want degrees, simply check RadToDeg")]
		public FsmFloat angle;

		[Tooltip("Check on if you want the angle expressed in degrees.")]
		public FsmBool RadToDeg;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2 = null;
			RadToDeg = true;
			everyFrame = false;
			angle = null;
		}

		public override void OnEnter()
		{
			DoATan();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoATan();
		}

		private void DoATan()
		{
			float num = Mathf.Atan2(vector2.Value.y, vector2.Value.x);
			if (RadToDeg.Value)
			{
				num *= 57.29578f;
			}
			angle.Value = num;
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the Arc Tangent 2 as in atan2(y,x) from a vector 3, where you pick which is x and y from the vector 3. You can get the result in degrees, simply check on the RadToDeg conversion")]
	public class GetAtan2FromVector3 : FsmStateAction
	{
		public enum aTan2EnumAxis
		{
			x,
			y,
			z
		}

		[RequiredField]
		[Tooltip("The vector3 definition of the tan")]
		public FsmVector3 vector3;

		[RequiredField]
		[Tooltip("which axis in the vector3 to use as the x value of the tan")]
		public aTan2EnumAxis xAxis;

		[RequiredField]
		[Tooltip("which axis in the vector3 to use as the y value of the tan")]
		public aTan2EnumAxis yAxis;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The resulting angle. Note:If you want degrees, simply check RadToDeg")]
		public FsmFloat angle;

		[Tooltip("Check on if you want the angle expressed in degrees.")]
		public FsmBool RadToDeg;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			vector3 = null;
			xAxis = aTan2EnumAxis.x;
			yAxis = aTan2EnumAxis.y;
			RadToDeg = true;
			everyFrame = false;
			angle = null;
		}

		public override void OnEnter()
		{
			DoATan();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoATan();
		}

		private void DoATan()
		{
			float x = vector3.Value.x;
			if (xAxis == aTan2EnumAxis.y)
			{
				x = vector3.Value.y;
			}
			else if (xAxis == aTan2EnumAxis.z)
			{
				x = vector3.Value.z;
			}
			float y = vector3.Value.y;
			if (yAxis == aTan2EnumAxis.x)
			{
				y = vector3.Value.x;
			}
			else if (yAxis == aTan2EnumAxis.z)
			{
				y = vector3.Value.z;
			}
			float num = Mathf.Atan2(y, x);
			if (RadToDeg.Value)
			{
				num *= 57.29578f;
			}
			angle.Value = num;
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the cosine. You can use degrees, simply check on the DegToRad conversion")]
	public class GetCosine : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The angle. Note: You can use degrees, simply check DegtoRad if the angle is expressed in degrees.")]
		public FsmFloat angle;

		[Tooltip("Check on if the angle is expressed in degrees.")]
		public FsmBool DegToRad;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The angle cosine")]
		public FsmFloat result;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			angle = null;
			DegToRad = true;
			everyFrame = false;
			result = null;
		}

		public override void OnEnter()
		{
			DoCosine();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCosine();
		}

		private void DoCosine()
		{
			float num = angle.Value;
			if (DegToRad.Value)
			{
				num *= (float)Math.PI / 180f;
			}
			result.Value = Mathf.Cos(num);
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the sine. You can use degrees, simply check on the DegToRad conversion")]
	public class GetSine : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The angle. Note: You can use degrees, simply check DegtoRad if the angle is expressed in degrees.")]
		public FsmFloat angle;

		[Tooltip("Check on if the angle is expressed in degrees.")]
		public FsmBool DegToRad;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The angle tan")]
		public FsmFloat result;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			angle = null;
			DegToRad = true;
			everyFrame = false;
			result = null;
		}

		public override void OnEnter()
		{
			DoSine();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSine();
		}

		private void DoSine()
		{
			float num = angle.Value;
			if (DegToRad.Value)
			{
				num *= (float)Math.PI / 180f;
			}
			result.Value = Mathf.Sin(num);
		}
	}
	[ActionCategory(ActionCategory.Trigonometry)]
	[Tooltip("Get the Tangent. You can use degrees, simply check on the DegToRad conversion")]
	public class GetTan : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The angle. Note: You can use degrees, simply check DegtoRad if the angle is expressed in degrees.")]
		public FsmFloat angle;

		[Tooltip("Check on if the angle is expressed in degrees.")]
		public FsmBool DegToRad;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The angle tan")]
		public FsmFloat result;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			angle = null;
			DegToRad = true;
			everyFrame = false;
			result = null;
		}

		public override void OnEnter()
		{
			DoTan();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoTan();
		}

		private void DoTan()
		{
			float num = angle.Value;
			if (DegToRad.Value)
			{
				num *= (float)Math.PI / 180f;
			}
			result.Value = Mathf.Tan(num);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Enable or disable Canvas Raycasting. Optionally reset on state exit")]
	public class UiCanvasEnableRaycast : ComponentAction<PlayMakerCanvasRaycastFilterProxy>
	{
		[RequiredField]
		[Tooltip("The GameObject to enable or disable Canvas Raycasting on.")]
		public FsmOwnerDefault gameObject;

		public FsmBool enableRaycasting;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		public bool everyFrame;

		[SerializeField]
		private PlayMakerCanvasRaycastFilterProxy raycastFilterProxy;

		private bool originalValue;

		public override void Reset()
		{
			gameObject = null;
			enableRaycasting = false;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnPreprocess()
		{
			if (gameObject == null)
			{
				gameObject = new FsmOwnerDefault();
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCacheAddComponent(ownerDefaultTarget))
			{
				raycastFilterProxy = cachedComponent;
			}
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCacheAddComponent(ownerDefaultTarget))
			{
				raycastFilterProxy = cachedComponent;
				originalValue = raycastFilterProxy.RayCastingEnabled;
			}
			DoAction();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoAction();
		}

		private void DoAction()
		{
			if (raycastFilterProxy != null)
			{
				raycastFilterProxy.RayCastingEnabled = enableRaycasting.Value;
			}
		}

		public override void OnExit()
		{
			if (!(raycastFilterProxy == null) && resetOnExit.Value)
			{
				raycastFilterProxy.RayCastingEnabled = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Force all canvases to update their content.\nCode that relies on up-to-date layout or content can call this method to ensure it before executing code that relies on it.")]
	public class UiCanvasForceUpdateCanvases : FsmStateAction
	{
		public override void OnEnter()
		{
			Canvas.ForceUpdateCanvases();
			Finish();
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Set Group Alpha.")]
	public class UiCanvasGroupSetAlpha : ComponentAction<CanvasGroup>
	{
		[RequiredField]
		[CheckForComponent(typeof(CanvasGroup))]
		[Tooltip("The GameObject with a UI CanvasGroup component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The alpha of the UI component.")]
		public FsmFloat alpha;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private CanvasGroup component;

		private float originalValue;

		public override void Reset()
		{
			gameObject = null;
			alpha = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				component = cachedComponent;
			}
			originalValue = component.alpha;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (component != null)
			{
				component.alpha = alpha.Value;
			}
		}

		public override void OnExit()
		{
			if (!(component == null) && resetOnExit.Value)
			{
				component.alpha = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets properties of a UI CanvasGroup component.")]
	public class UiCanvasGroupSetProperties : ComponentAction<CanvasGroup>
	{
		[RequiredField]
		[CheckForComponent(typeof(CanvasGroup))]
		[Tooltip("The GameObject with the UI CanvasGroup component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Canvas group alpha. Ranges from 0.0 to 1.0.")]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat alpha;

		[Tooltip("Is the group interactable (are the elements beneath the group enabled). Leave as None for no effect")]
		public FsmBool interactable;

		[Tooltip("Does this group block raycasting (allow collision). Leave as None for no effect")]
		public FsmBool blocksRaycasts;

		[Tooltip("Should the group ignore parent groups? Leave as None for no effect")]
		public FsmBool ignoreParentGroup;

		[Tooltip("Reset when exiting this state. Leave as None for no effect")]
		public FsmBool resetOnExit;

		public bool everyFrame;

		private CanvasGroup component;

		private float originalAlpha;

		private bool originalInteractable;

		private bool originalBlocksRaycasts;

		private bool originalIgnoreParentGroup;

		public override void Reset()
		{
			gameObject = null;
			alpha = new FsmFloat
			{
				UseVariable = true
			};
			interactable = new FsmBool
			{
				UseVariable = true
			};
			blocksRaycasts = new FsmBool
			{
				UseVariable = true
			};
			ignoreParentGroup = new FsmBool
			{
				UseVariable = true
			};
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				component = cachedComponent;
				if (component != null)
				{
					originalAlpha = component.alpha;
					originalInteractable = component.interactable;
					originalBlocksRaycasts = component.blocksRaycasts;
					originalIgnoreParentGroup = component.ignoreParentGroups;
				}
			}
			DoAction();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoAction();
		}

		private void DoAction()
		{
			if (!(component == null))
			{
				if (!alpha.IsNone)
				{
					component.alpha = alpha.Value;
				}
				if (!interactable.IsNone)
				{
					component.interactable = interactable.Value;
				}
				if (!blocksRaycasts.IsNone)
				{
					component.blocksRaycasts = blocksRaycasts.Value;
				}
				if (!ignoreParentGroup.IsNone)
				{
					component.ignoreParentGroups = ignoreParentGroup.Value;
				}
			}
		}

		public override void OnExit()
		{
			if (!(component == null) && resetOnExit.Value)
			{
				if (!alpha.IsNone)
				{
					component.alpha = originalAlpha;
				}
				if (!interactable.IsNone)
				{
					component.interactable = originalInteractable;
				}
				if (!blocksRaycasts.IsNone)
				{
					component.blocksRaycasts = originalBlocksRaycasts;
				}
				if (!ignoreParentGroup.IsNone)
				{
					component.ignoreParentGroups = originalIgnoreParentGroup;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Get the ScaleFactor of a CanvasScaler.")]
	public class UiCanvasScalerGetScaleFactor : ComponentAction<CanvasScaler>
	{
		[RequiredField]
		[CheckForComponent(typeof(CanvasScaler))]
		[Tooltip("The GameObject with a UI CanvasScaler component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The scaleFactor of the CanvasScaler component.")]
		public FsmFloat scaleFactor;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private CanvasScaler component;

		public override void Reset()
		{
			gameObject = null;
			scaleFactor = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				component = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (component != null)
			{
				scaleFactor.Value = component.scaleFactor;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the ScaleFactor of a CanvasScaler.")]
	public class UiCanvasScalerSetScaleFactor : ComponentAction<CanvasScaler>
	{
		[RequiredField]
		[CheckForComponent(typeof(CanvasScaler))]
		[Tooltip("The GameObject with a UI CanvasScaler component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The scaleFactor of the UI CanvasScaler.")]
		public FsmFloat scaleFactor;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private CanvasScaler component;

		public override void Reset()
		{
			gameObject = null;
			scaleFactor = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				component = cachedComponent;
			}
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (component != null)
			{
				component.scaleFactor = scaleFactor.Value;
			}
		}
	}
	public abstract class EventTriggerActionBase : ComponentAction<EventTrigger>
	{
		[DisplayOrder(0)]
		[RequiredField]
		[Tooltip("The GameObject with the UI component.")]
		public FsmOwnerDefault gameObject;

		[DisplayOrder(1)]
		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		protected EventTrigger trigger;

		protected EventTrigger.Entry entry;

		public override void Reset()
		{
			gameObject = null;
			eventTarget = FsmEventTarget.Self;
		}

		protected void Init(EventTriggerType eventTriggerType, UnityAction<BaseEventData> call)
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCacheAddComponent(ownerDefaultTarget))
			{
				trigger = cachedComponent;
				if (entry == null)
				{
					entry = new EventTrigger.Entry();
				}
				entry.eventID = eventTriggerType;
				entry.callback.AddListener(call);
				trigger.triggers.Add(entry);
			}
		}

		public override void OnExit()
		{
			entry.callback.RemoveAllListeners();
			trigger.triggers.Remove(entry);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("The eventType will be executed on all components on the GameObject that can handle it.")]
	public class UiEventSystemCurrentRayCastAll : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The ScreenPosition in pixels")]
		public FsmVector3 screenPosition;

		[Tooltip("The ScreenPosition in a Vector2")]
		public FsmVector2 orScreenPosition2d;

		[Tooltip("GameObjects hit by the raycast")]
		[UIHint(UIHint.Variable)]
		[ArrayEditor(VariableType.GameObject, "", 0, 0, 65536)]
		public FsmArray gameObjectList;

		[Tooltip("Number of hits")]
		[UIHint(UIHint.Variable)]
		public FsmInt hitCount;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private PointerEventData pointer;

		private List<RaycastResult> raycastResults = new List<RaycastResult>();

		public override void Reset()
		{
			screenPosition = null;
			orScreenPosition2d = new FsmVector2
			{
				UseVariable = true
			};
			gameObjectList = null;
			hitCount = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			ExecuteRayCastAll();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			ExecuteRayCastAll();
		}

		private void ExecuteRayCastAll()
		{
			pointer = new PointerEventData(EventSystem.current);
			if (!orScreenPosition2d.IsNone)
			{
				pointer.position = orScreenPosition2d.Value;
			}
			else
			{
				pointer.position = new Vector2(screenPosition.Value.x, screenPosition.Value.y);
			}
			EventSystem.current.RaycastAll(pointer, raycastResults);
			if (!hitCount.IsNone)
			{
				hitCount.Value = raycastResults.Count;
			}
			gameObjectList.Resize(raycastResults.Count);
			int index = 0;
			foreach (RaycastResult raycastResult in raycastResults)
			{
				if (!gameObjectList.IsNone)
				{
					gameObjectList.Set(index, raycastResult.gameObject);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("The eventType will be executed on all components on the GameObject that can handle it.")]
	public class UiEventSystemExecuteEvent : FsmStateAction
	{
		public enum EventHandlers
		{
			Submit,
			beginDrag,
			cancel,
			deselectHandler,
			dragHandler,
			dropHandler,
			endDragHandler,
			initializePotentialDrag,
			pointerClickHandler,
			pointerDownHandler,
			pointerEnterHandler,
			pointerExitHandler,
			pointerUpHandler,
			scrollHandler,
			submitHandler,
			updateSelectedHandler
		}

		[RequiredField]
		[Tooltip("The GameObject with  an IEventSystemHandler component (a UI button for example).")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Type of handler to execute")]
		[ObjectType(typeof(EventHandlers))]
		public FsmEnum eventHandler;

		[Tooltip("Event Sent if execution was possible on GameObject")]
		public FsmEvent success;

		[Tooltip("Event Sent if execution was NOT possible on GameObject because it can not handle the eventHandler selected")]
		public FsmEvent canNotHandleEvent;

		private GameObject go;

		public override void Reset()
		{
			gameObject = null;
			eventHandler = EventHandlers.Submit;
			success = null;
			canNotHandleEvent = null;
		}

		public override void OnEnter()
		{
			base.Fsm.Event(ExecuteEvent() ? success : canNotHandleEvent);
			Finish();
		}

		private bool ExecuteEvent()
		{
			go = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (go == null)
			{
				LogError("Missing GameObject ");
				return false;
			}
			switch ((EventHandlers)(object)eventHandler.Value)
			{
			case EventHandlers.Submit:
				if (!ExecuteEvents.CanHandleEvent<ISubmitHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.submitHandler);
				break;
			case EventHandlers.beginDrag:
				if (!ExecuteEvents.CanHandleEvent<IBeginDragHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.beginDragHandler);
				break;
			case EventHandlers.cancel:
				if (!ExecuteEvents.CanHandleEvent<ICancelHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.cancelHandler);
				break;
			case EventHandlers.deselectHandler:
				if (!ExecuteEvents.CanHandleEvent<IDeselectHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.deselectHandler);
				break;
			case EventHandlers.dragHandler:
				if (!ExecuteEvents.CanHandleEvent<IDragHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.dragHandler);
				break;
			case EventHandlers.dropHandler:
				if (!ExecuteEvents.CanHandleEvent<IDropHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.dropHandler);
				break;
			case EventHandlers.endDragHandler:
				if (!ExecuteEvents.CanHandleEvent<IEndDragHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.endDragHandler);
				break;
			case EventHandlers.initializePotentialDrag:
				if (!ExecuteEvents.CanHandleEvent<IInitializePotentialDragHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.initializePotentialDrag);
				break;
			case EventHandlers.pointerClickHandler:
				if (!ExecuteEvents.CanHandleEvent<IPointerClickHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.pointerClickHandler);
				break;
			case EventHandlers.pointerDownHandler:
				if (!ExecuteEvents.CanHandleEvent<IPointerDownHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.pointerDownHandler);
				break;
			case EventHandlers.pointerUpHandler:
				if (!ExecuteEvents.CanHandleEvent<IPointerUpHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.pointerUpHandler);
				break;
			case EventHandlers.pointerEnterHandler:
				if (!ExecuteEvents.CanHandleEvent<IPointerEnterHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.pointerEnterHandler);
				break;
			case EventHandlers.pointerExitHandler:
				if (!ExecuteEvents.CanHandleEvent<IPointerExitHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.pointerExitHandler);
				break;
			case EventHandlers.scrollHandler:
				if (!ExecuteEvents.CanHandleEvent<IScrollHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.scrollHandler);
				break;
			case EventHandlers.updateSelectedHandler:
				if (!ExecuteEvents.CanHandleEvent<IUpdateSelectedHandler>(go))
				{
					return false;
				}
				ExecuteEvents.Execute(go, new BaseEventData(EventSystem.current), ExecuteEvents.updateSelectedHandler);
				break;
			}
			return true;
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets pointer data on the last System event.")]
	public class UiGetLastPointerDataInfo : FsmStateAction
	{
		public static PointerEventData lastPointerEventData;

		[Tooltip("Number of clicks in a row.")]
		[UIHint(UIHint.Variable)]
		public FsmInt clickCount;

		[Tooltip("The last time a click event was sent.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat clickTime;

		[Tooltip("Pointer delta since last update.")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 delta;

		[Tooltip("Is a drag operation currently occuring.")]
		[UIHint(UIHint.Variable)]
		public FsmBool dragging;

		[Tooltip("The InputButton for this event.")]
		[UIHint(UIHint.Variable)]
		[ObjectType(typeof(PointerEventData.InputButton))]
		public FsmEnum inputButton;

		[Tooltip("Is the pointer being pressed? (Not documented by Unity)")]
		[UIHint(UIHint.Variable)]
		public FsmBool eligibleForClick;

		[Tooltip("The camera associated with the last OnPointerEnter event.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject enterEventCamera;

		[Tooltip("The camera associated with the last OnPointerPress event.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject pressEventCamera;

		[Tooltip("Is the pointer moving.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isPointerMoving;

		[Tooltip("Is scroll being used on the input device.")]
		[UIHint(UIHint.Variable)]
		public FsmBool isScrolling;

		[Tooltip("The GameObject for the last press event.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject lastPress;

		[Tooltip("The object that is receiving OnDrag.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject pointerDrag;

		[Tooltip("The object that received 'OnPointerEnter'.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject pointerEnter;

		[Tooltip("Id of the pointer (touch id).")]
		[UIHint(UIHint.Variable)]
		public FsmInt pointerId;

		[Tooltip("The GameObject that received the OnPointerDown.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject pointerPress;

		[Tooltip("Current pointer position.")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 position;

		[Tooltip("Position of the press.")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 pressPosition;

		[Tooltip("The object that the press happened on even if it can not handle the press event.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject rawPointerPress;

		[Tooltip("The amount of scroll since the last update.")]
		[UIHint(UIHint.Variable)]
		public FsmVector2 scrollDelta;

		[Tooltip("Is the event used?")]
		[UIHint(UIHint.Variable)]
		public FsmBool used;

		[Tooltip("Should a drag threshold be used?")]
		[UIHint(UIHint.Variable)]
		public FsmBool useDragThreshold;

		[Tooltip("The normal of the last raycast in world coordinates.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 worldNormal;

		[Tooltip("The world position of the last raycast.")]
		[UIHint(UIHint.Variable)]
		public FsmVector3 worldPosition;

		public override void Reset()
		{
			clickCount = null;
			clickTime = null;
			delta = null;
			dragging = null;
			inputButton = PointerEventData.InputButton.Left;
			eligibleForClick = null;
			enterEventCamera = null;
			pressEventCamera = null;
			isPointerMoving = null;
			isScrolling = null;
			lastPress = null;
			pointerDrag = null;
			pointerEnter = null;
			pointerId = null;
			pointerPress = null;
			position = null;
			pressPosition = null;
			rawPointerPress = null;
			scrollDelta = null;
			used = null;
			useDragThreshold = null;
			worldNormal = null;
			worldPosition = null;
		}

		public override void OnEnter()
		{
			if (lastPointerEventData == null)
			{
				Finish();
				return;
			}
			if (!clickCount.IsNone)
			{
				clickCount.Value = lastPointerEventData.clickCount;
			}
			if (!clickTime.IsNone)
			{
				clickTime.Value = lastPointerEventData.clickTime;
			}
			if (!delta.IsNone)
			{
				delta.Value = lastPointerEventData.delta;
			}
			if (!dragging.IsNone)
			{
				dragging.Value = lastPointerEventData.dragging;
			}
			if (!inputButton.IsNone)
			{
				inputButton.Value = lastPointerEventData.button;
			}
			if (!eligibleForClick.IsNone)
			{
				eligibleForClick.Value = lastPointerEventData.eligibleForClick;
			}
			if (!enterEventCamera.IsNone)
			{
				enterEventCamera.Value = lastPointerEventData.enterEventCamera.gameObject;
			}
			if (!isPointerMoving.IsNone)
			{
				isPointerMoving.Value = lastPointerEventData.IsPointerMoving();
			}
			if (!isScrolling.IsNone)
			{
				isScrolling.Value = lastPointerEventData.IsScrolling();
			}
			if (!lastPress.IsNone)
			{
				lastPress.Value = lastPointerEventData.lastPress;
			}
			if (!pointerDrag.IsNone)
			{
				pointerDrag.Value = lastPointerEventData.pointerDrag;
			}
			if (!pointerEnter.IsNone)
			{
				pointerEnter.Value = lastPointerEventData.pointerEnter;
			}
			if (!pointerId.IsNone)
			{
				pointerId.Value = lastPointerEventData.pointerId;
			}
			if (!pointerPress.IsNone)
			{
				pointerPress.Value = lastPointerEventData.pointerPress;
			}
			if (!position.IsNone)
			{
				position.Value = lastPointerEventData.position;
			}
			if (!pressEventCamera.IsNone)
			{
				pressEventCamera.Value = lastPointerEventData.pressEventCamera.gameObject;
			}
			if (!pressPosition.IsNone)
			{
				pressPosition.Value = lastPointerEventData.pressPosition;
			}
			if (!rawPointerPress.IsNone)
			{
				rawPointerPress.Value = lastPointerEventData.rawPointerPress;
			}
			if (!scrollDelta.IsNone)
			{
				scrollDelta.Value = lastPointerEventData.scrollDelta;
			}
			if (!used.IsNone)
			{
				used.Value = lastPointerEventData.used;
			}
			if (!useDragThreshold.IsNone)
			{
				useDragThreshold.Value = lastPointerEventData.useDragThreshold;
			}
			if (!worldNormal.IsNone)
			{
				worldNormal.Value = lastPointerEventData.pointerCurrentRaycast.worldNormal;
			}
			if (!worldPosition.IsNone)
			{
				worldPosition.Value = lastPointerEventData.pointerCurrentRaycast.worldPosition;
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets pointer data Input Button on the last System event.")]
	public class UiGetLastPointerEventDataInputButton : FsmStateAction
	{
		[Tooltip("Store the Input Button pressed (Left, Right, Middle)")]
		[UIHint(UIHint.Variable)]
		[ObjectType(typeof(PointerEventData.InputButton))]
		public FsmEnum inputButton;

		[Tooltip("Event to send if Left Button clicked.")]
		public FsmEvent leftClick;

		[Tooltip("Event to send if Middle Button clicked.")]
		public FsmEvent middleClick;

		[Tooltip("Event to send if Right Button clicked.")]
		public FsmEvent rightClick;

		public override void Reset()
		{
			inputButton = PointerEventData.InputButton.Left;
			leftClick = null;
			middleClick = null;
			rightClick = null;
		}

		public override void OnEnter()
		{
			ExecuteAction();
			Finish();
		}

		private void ExecuteAction()
		{
			if (UiGetLastPointerDataInfo.lastPointerEventData != null)
			{
				if (!inputButton.IsNone)
				{
					inputButton.Value = UiGetLastPointerDataInfo.lastPointerEventData.button;
				}
				if (!string.IsNullOrEmpty(leftClick.Name) && UiGetLastPointerDataInfo.lastPointerEventData.button == PointerEventData.InputButton.Left)
				{
					base.Fsm.Event(leftClick);
				}
				else if (!string.IsNullOrEmpty(middleClick.Name) && UiGetLastPointerDataInfo.lastPointerEventData.button == PointerEventData.InputButton.Middle)
				{
					base.Fsm.Event(middleClick);
				}
				else if (!string.IsNullOrEmpty(rightClick.Name) && UiGetLastPointerDataInfo.lastPointerEventData.button == PointerEventData.InputButton.Right)
				{
					base.Fsm.Event(rightClick);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Returns the EventSystem's currently select GameObject.")]
	public class UiGetSelectedGameObject : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("The currently selected GameObject")]
		public FsmGameObject StoreGameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Event when the selected GameObject changes")]
		public FsmEvent ObjectChangedEvent;

		[UIHint(UIHint.Variable)]
		[Tooltip("If true, each frame will check the currently selected GameObject")]
		public bool everyFrame;

		private GameObject lastGameObject;

		public override void Reset()
		{
			StoreGameObject = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GetCurrentSelectedGameObject();
			lastGameObject = StoreGameObject.Value;
		}

		public override void OnUpdate()
		{
			GetCurrentSelectedGameObject();
			if (StoreGameObject.Value != lastGameObject && ObjectChangedEvent != null)
			{
				base.Fsm.Event(ObjectChangedEvent);
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void GetCurrentSelectedGameObject()
		{
			StoreGameObject.Value = EventSystem.current.currentSelectedGameObject;
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Checks if Pointer is over a UI object, optionally takes a pointer ID, otherwise uses the current event.")]
	public class UiIsPointerOverUiObject : FsmStateAction
	{
		[Tooltip("Optional PointerId. Leave to none to use the current event")]
		public FsmInt pointerId;

		[Tooltip("Event to send when the Pointer is over an UI object.")]
		public FsmEvent pointerOverUI;

		[Tooltip("Event to send when the Pointer is NOT over an UI object.")]
		public FsmEvent pointerNotOverUI;

		[UIHint(UIHint.Variable)]
		public FsmBool isPointerOverUI;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			pointerId = new FsmInt
			{
				UseVariable = true
			};
			pointerOverUI = null;
			pointerNotOverUI = null;
			isPointerOverUI = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoCheckPointer();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoCheckPointer();
		}

		private void DoCheckPointer()
		{
			bool flag = false;
			if (pointerId.IsNone)
			{
				flag = EventSystem.current.IsPointerOverGameObject();
			}
			else if (EventSystem.current.currentInputModule is PointerInputModule)
			{
				flag = (EventSystem.current.currentInputModule as PointerInputModule).IsPointerOverGameObject(pointerId.Value);
			}
			isPointerOverUI.Value = flag;
			base.Fsm.Event(flag ? pointerOverUI : pointerNotOverUI);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when user starts to drag a GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnBeginDragEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnBeginDrag is called")]
		public FsmEvent onBeginDragEvent;

		public override void Reset()
		{
			base.Reset();
			onBeginDragEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.BeginDrag, OnBeginDragDelegate);
		}

		private void OnBeginDragDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onBeginDragEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnCancel is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnCancelEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnCancelEvent is called")]
		public FsmEvent onCancelEvent;

		public override void Reset()
		{
			gameObject = null;
			onCancelEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Cancel, OnCancelDelegate);
		}

		private void OnCancelDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onCancelEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnDeselect is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnDeselectEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnDeselectEvent is called")]
		public FsmEvent onDeselectEvent;

		public override void Reset()
		{
			base.Reset();
			onDeselectEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Deselect, OnDeselectDelegate);
		}

		private void OnDeselectDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onDeselectEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnDrag is called on the GameObject. Warning this event is sent every frame while dragging.\n Use GetLastPointerDataInfo action to get info from the event.")]
	public class UiOnDragEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnDrag is called")]
		public FsmEvent onDragEvent;

		public override void Reset()
		{
			base.Reset();
			onDragEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Drag, OnDragDelegate);
		}

		private void OnDragDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onDragEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnDrop is called on the GameObject. Warning this event is sent everyframe while dragging.\n Use GetLastPointerDataInfo action to get info from the event.")]
	public class UiOnDropEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnDrop is called")]
		public FsmEvent onDropEvent;

		public override void Reset()
		{
			base.Reset();
			onDropEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Drop, OnDropDelegate);
		}

		private void OnDropDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onDropEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event Called by the EventSystem once dragging ends.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnEndDragEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnEndDrag is called")]
		public FsmEvent onEndDragEvent;

		public override void Reset()
		{
			base.Reset();
			onEndDragEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.EndDrag, OnEndDragDelegate);
		}

		private void OnEndDragDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onEndDragEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when Called by the EventSystem when a drag has been found, but before it is valid to begin the drag.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnInitializePotentialDragEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnInitializePotentialDrag is called")]
		public FsmEvent onInitializePotentialDragEvent;

		public override void Reset()
		{
			base.Reset();
			onInitializePotentialDragEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.InitializePotentialDrag, OnInitializePotentialDragDelegate);
		}

		private void OnInitializePotentialDragDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onInitializePotentialDragEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnMoveEvent is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnMoveEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnMoveEvent is called")]
		public FsmEvent onMoveEvent;

		public override void Reset()
		{
			base.Reset();
			onMoveEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Move, OnMoveDelegate);
		}

		private void OnMoveDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onMoveEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnPointerClick is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnPointerClickEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when PointerClick is called")]
		public FsmEvent onPointerClickEvent;

		public override void Reset()
		{
			base.Reset();
			onPointerClickEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.PointerClick, OnPointerClickDelegate);
		}

		private void OnPointerClickDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onPointerClickEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnPointerDown is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnPointerDownEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when PointerDown is called")]
		public FsmEvent onPointerDownEvent;

		public override void Reset()
		{
			base.Reset();
			onPointerDownEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.PointerDown, OnPointerDownDelegate);
		}

		private void OnPointerDownDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onPointerDownEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnPointerEnter is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnPointerEnterEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when PointerEnter is called")]
		public FsmEvent onPointerEnterEvent;

		public override void Reset()
		{
			base.Reset();
			onPointerEnterEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.PointerEnter, OnPointerEnterDelegate);
		}

		private void OnPointerEnterDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onPointerEnterEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnPointerExit is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnPointerExitEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when PointerExit is called")]
		public FsmEvent onPointerExitEvent;

		public override void Reset()
		{
			base.Reset();
			onPointerExitEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.PointerExit, OnPointerExitDelegate);
		}

		private void OnPointerExitDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onPointerExitEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnPointerUp is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnPointerUpEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when PointerUp is called")]
		public FsmEvent onPointerUpEvent;

		public override void Reset()
		{
			base.Reset();
			onPointerUpEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.PointerUp, OnPointerUpDelegate);
		}

		private void OnPointerUpDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onPointerUpEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnScroll is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnScrollEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnScroll is called")]
		public FsmEvent onScrollEvent;

		public override void Reset()
		{
			base.Reset();
			onScrollEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Scroll, OnScrollDelegate);
		}

		private void OnScrollDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onScrollEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when Called by the EventSystem when a Select event occurs.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnSelectEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnSelect is called")]
		public FsmEvent onSelectEvent;

		public override void Reset()
		{
			base.Reset();
			onSelectEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Select, OnSelectDelegate);
		}

		private void OnSelectDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onSelectEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when OnSubmit is called on the GameObject.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnSubmitEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnSubmitEvent is called")]
		public FsmEvent onSubmitEvent;

		public override void Reset()
		{
			base.Reset();
			onSubmitEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.Submit, OnSubmitDelegate);
		}

		private void OnSubmitDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onSubmitEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends event when Called by the EventSystem when the object associated with this EventTrigger is updated.\n Use GetLastPointerDataInfo action to get info from the event")]
	public class UiOnUpdateSelectedEvent : EventTriggerActionBase
	{
		[UIHint(UIHint.Variable)]
		[Tooltip("Event sent when OnUpdateSelected is called")]
		public FsmEvent onUpdateSelectedEvent;

		public override void Reset()
		{
			base.Reset();
			onUpdateSelectedEvent = null;
		}

		public override void OnEnter()
		{
			Init(EventTriggerType.UpdateSelected, OnUpdateSelectedDelegate);
		}

		private void OnUpdateSelectedDelegate(BaseEventData data)
		{
			UiGetLastPointerDataInfo.lastPointerEventData = (PointerEventData)data;
			SendEvent(eventTarget, onUpdateSelectedEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the EventSystem's currently select GameObject.")]
	public class UiSetSelectedGameObject : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The GameObject to select.")]
		public FsmGameObject gameObject;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			DoSetSelectedGameObject();
			Finish();
		}

		private void DoSetSelectedGameObject()
		{
			EventSystem.current.SetSelectedGameObject(gameObject.Value);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets various properties of a UI Layout Element component.")]
	public class UiLayoutElementGetValues : ComponentAction<LayoutElement>
	{
		[RequiredField]
		[CheckForComponent(typeof(LayoutElement))]
		[Tooltip("The GameObject with the UI LayoutElement component.")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Values")]
		[Tooltip("Is this element use Layout constraints")]
		[UIHint(UIHint.Variable)]
		public FsmBool ignoreLayout;

		[Tooltip("The minimum width enabled state")]
		[UIHint(UIHint.Variable)]
		public FsmBool minWidthEnabled;

		[Tooltip("The minimum width this layout element should have.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat minWidth;

		[Tooltip("The minimum height enabled state")]
		[UIHint(UIHint.Variable)]
		public FsmBool minHeightEnabled;

		[Tooltip("The minimum height this layout element should have.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat minHeight;

		[Tooltip("The preferred width enabled state")]
		[UIHint(UIHint.Variable)]
		public FsmBool preferredWidthEnabled;

		[Tooltip("The preferred width this layout element should have before additional available width is allocated.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat preferredWidth;

		[Tooltip("The preferred height enabled state")]
		[UIHint(UIHint.Variable)]
		public FsmBool preferredHeightEnabled;

		[Tooltip("The preferred height this layout element should have before additional available height is allocated.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat preferredHeight;

		[Tooltip("The flexible width enabled state")]
		[UIHint(UIHint.Variable)]
		public FsmBool flexibleWidthEnabled;

		[Tooltip("The relative amount of additional available width this layout element should fill out relative to its siblings.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat flexibleWidth;

		[Tooltip("The flexible height enabled state")]
		[UIHint(UIHint.Variable)]
		public FsmBool flexibleHeightEnabled;

		[Tooltip("The relative amount of additional available height this layout element should fill out relative to its siblings.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat flexibleHeight;

		[ActionSection("Options")]
		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private LayoutElement layoutElement;

		public override void Reset()
		{
			gameObject = null;
			ignoreLayout = null;
			minWidthEnabled = null;
			minHeightEnabled = null;
			preferredWidthEnabled = null;
			preferredHeightEnabled = null;
			flexibleWidthEnabled = null;
			flexibleHeightEnabled = null;
			minWidth = null;
			minHeight = null;
			preferredWidth = null;
			preferredHeight = null;
			flexibleWidth = null;
			flexibleHeight = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				layoutElement = cachedComponent;
			}
			DoGetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValues();
		}

		private void DoGetValues()
		{
			if (!(layoutElement == null))
			{
				if (!ignoreLayout.IsNone)
				{
					ignoreLayout.Value = layoutElement.ignoreLayout;
				}
				if (!minWidthEnabled.IsNone)
				{
					minWidthEnabled.Value = layoutElement.minWidth != 0f;
				}
				if (!minWidth.IsNone)
				{
					minWidth.Value = layoutElement.minWidth;
				}
				if (!minHeightEnabled.IsNone)
				{
					minHeightEnabled.Value = layoutElement.minHeight != 0f;
				}
				if (!minHeight.IsNone)
				{
					minHeight.Value = layoutElement.minHeight;
				}
				if (!preferredWidthEnabled.IsNone)
				{
					preferredWidthEnabled.Value = layoutElement.preferredWidth != 0f;
				}
				if (!preferredWidth.IsNone)
				{
					preferredWidth.Value = layoutElement.preferredWidth;
				}
				if (!preferredHeightEnabled.IsNone)
				{
					preferredHeightEnabled.Value = layoutElement.preferredHeight != 0f;
				}
				if (!preferredHeight.IsNone)
				{
					preferredHeight.Value = layoutElement.preferredHeight;
				}
				if (!flexibleWidthEnabled.IsNone)
				{
					flexibleWidthEnabled.Value = layoutElement.flexibleWidth != 0f;
				}
				if (!flexibleWidth.IsNone)
				{
					flexibleWidth.Value = layoutElement.flexibleWidth;
				}
				if (!flexibleHeightEnabled.IsNone)
				{
					flexibleHeightEnabled.Value = layoutElement.flexibleHeight != 0f;
				}
				if (!flexibleHeight.IsNone)
				{
					flexibleHeight.Value = layoutElement.flexibleHeight;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets various properties of a UI Layout Element component.")]
	public class UiLayoutElementSetValues : ComponentAction<LayoutElement>
	{
		[RequiredField]
		[CheckForComponent(typeof(LayoutElement))]
		[Tooltip("The GameObject with the UI LayoutElement component.")]
		public FsmOwnerDefault gameObject;

		[ActionSection("Values")]
		[Tooltip("The minimum width this layout element should have.")]
		public FsmFloat minWidth;

		[Tooltip("The minimum height this layout element should have.")]
		public FsmFloat minHeight;

		[Tooltip("The preferred width this layout element should have before additional available width is allocated.")]
		public FsmFloat preferredWidth;

		[Tooltip("The preferred height this layout element should have before additional available height is allocated.")]
		public FsmFloat preferredHeight;

		[Tooltip("The relative amount of additional available width this layout element should fill out relative to its siblings.")]
		public FsmFloat flexibleWidth;

		[Tooltip("The relative amount of additional available height this layout element should fill out relative to its siblings.")]
		public FsmFloat flexibleHeight;

		[ActionSection("Options")]
		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private LayoutElement layoutElement;

		public override void Reset()
		{
			gameObject = null;
			minWidth = new FsmFloat
			{
				UseVariable = true
			};
			minHeight = new FsmFloat
			{
				UseVariable = true
			};
			preferredWidth = new FsmFloat
			{
				UseVariable = true
			};
			preferredHeight = new FsmFloat
			{
				UseVariable = true
			};
			flexibleWidth = new FsmFloat
			{
				UseVariable = true
			};
			flexibleHeight = new FsmFloat
			{
				UseVariable = true
			};
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				layoutElement = cachedComponent;
			}
			DoSetValues();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValues();
		}

		private void DoSetValues()
		{
			if (!(layoutElement == null))
			{
				if (!minWidth.IsNone)
				{
					layoutElement.minWidth = minWidth.Value;
				}
				if (!minHeight.IsNone)
				{
					layoutElement.minHeight = minHeight.Value;
				}
				if (!preferredWidth.IsNone)
				{
					layoutElement.preferredWidth = preferredWidth.Value;
				}
				if (!preferredHeight.IsNone)
				{
					layoutElement.preferredHeight = preferredHeight.Value;
				}
				if (!flexibleWidth.IsNone)
				{
					layoutElement.flexibleWidth = flexibleWidth.Value;
				}
				if (!flexibleHeight.IsNone)
				{
					layoutElement.flexibleHeight = flexibleHeight.Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the explicit navigation properties of a UI Selectable component. ")]
	public class UiNavigationExplicitGetProperties : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The down Selectable.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject selectOnDown;

		[Tooltip("The up Selectable.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject selectOnUp;

		[Tooltip("The left Selectable.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject selectOnLeft;

		[Tooltip("The right Selectable.")]
		[UIHint(UIHint.Variable)]
		public FsmGameObject selectOnRight;

		private Selectable _selectable;

		public override void Reset()
		{
			gameObject = null;
			selectOnDown = null;
			selectOnUp = null;
			selectOnLeft = null;
			selectOnRight = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_selectable = ownerDefaultTarget.GetComponent<Selectable>();
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (_selectable != null)
			{
				if (!selectOnUp.IsNone)
				{
					selectOnUp.Value = ((_selectable.navigation.selectOnUp == null) ? null : _selectable.navigation.selectOnUp.gameObject);
				}
				if (!selectOnDown.IsNone)
				{
					selectOnDown.Value = ((_selectable.navigation.selectOnDown == null) ? null : _selectable.navigation.selectOnDown.gameObject);
				}
				if (!selectOnLeft.IsNone)
				{
					selectOnLeft.Value = ((_selectable.navigation.selectOnLeft == null) ? null : _selectable.navigation.selectOnLeft.gameObject);
				}
				if (!selectOnRight.IsNone)
				{
					selectOnRight.Value = ((_selectable.navigation.selectOnRight == null) ? null : _selectable.navigation.selectOnRight.gameObject);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the explicit navigation properties of a UI Selectable component. Note that it will have no effect until Navigation mode is set to 'Explicit'.")]
	public class UiNavigationExplicitSetProperties : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The down Selectable. Leave as None for no effect")]
		[CheckForComponent(typeof(Selectable))]
		public FsmGameObject selectOnDown;

		[Tooltip("The up Selectable.  Leave as None for no effect")]
		[CheckForComponent(typeof(Selectable))]
		public FsmGameObject selectOnUp;

		[Tooltip("The left Selectable.  Leave as None for no effect")]
		[CheckForComponent(typeof(Selectable))]
		public FsmGameObject selectOnLeft;

		[Tooltip("The right Selectable.  Leave as None for no effect")]
		[CheckForComponent(typeof(Selectable))]
		public FsmGameObject selectOnRight;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Selectable selectable;

		private Navigation navigation;

		private Navigation originalState;

		public override void Reset()
		{
			gameObject = null;
			selectOnDown = new FsmGameObject
			{
				UseVariable = true
			};
			selectOnUp = new FsmGameObject
			{
				UseVariable = true
			};
			selectOnLeft = new FsmGameObject
			{
				UseVariable = true
			};
			selectOnRight = new FsmGameObject
			{
				UseVariable = true
			};
			resetOnExit = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			if (selectable != null && resetOnExit.Value)
			{
				originalState = selectable.navigation;
			}
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (!(selectable == null))
			{
				navigation = selectable.navigation;
				if (!selectOnDown.IsNone)
				{
					navigation.selectOnDown = GetComponentFromFsmGameObject<Selectable>(selectOnDown);
				}
				if (!selectOnUp.IsNone)
				{
					navigation.selectOnUp = GetComponentFromFsmGameObject<Selectable>(selectOnUp);
				}
				if (!selectOnLeft.IsNone)
				{
					navigation.selectOnLeft = GetComponentFromFsmGameObject<Selectable>(selectOnLeft);
				}
				if (!selectOnRight.IsNone)
				{
					navigation.selectOnRight = GetComponentFromFsmGameObject<Selectable>(selectOnRight);
				}
				selectable.navigation = navigation;
			}
		}

		public override void OnExit()
		{
			if (!(selectable == null) && resetOnExit.Value)
			{
				navigation = selectable.navigation;
				navigation.selectOnDown = originalState.selectOnDown;
				navigation.selectOnLeft = originalState.selectOnLeft;
				navigation.selectOnRight = originalState.selectOnRight;
				navigation.selectOnUp = originalState.selectOnUp;
				selectable.navigation = navigation;
			}
		}

		private static T GetComponentFromFsmGameObject<T>(FsmGameObject variable) where T : Component
		{
			if (variable.Value != null)
			{
				return variable.Value.GetComponent<T>();
			}
			return null;
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the Color Block of a UI Selectable component.")]
	public class UiGetColorBlock : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The fade duration value. Leave as None for no effect")]
		[UIHint(UIHint.Variable)]
		public FsmFloat fadeDuration;

		[Tooltip("The color multiplier value. Leave as None for no effect")]
		[UIHint(UIHint.Variable)]
		public FsmFloat colorMultiplier;

		[Tooltip("The normal color value. Leave as None for no effect")]
		[UIHint(UIHint.Variable)]
		public FsmColor normalColor;

		[Tooltip("The pressed color value. Leave as None for no effect")]
		[UIHint(UIHint.Variable)]
		public FsmColor pressedColor;

		[Tooltip("The highlighted color value. Leave as None for no effect")]
		[UIHint(UIHint.Variable)]
		public FsmColor highlightedColor;

		[Tooltip("The disabled color value. Leave as None for no effect")]
		[UIHint(UIHint.Variable)]
		public FsmColor disabledColor;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private Selectable selectable;

		public override void Reset()
		{
			gameObject = null;
			fadeDuration = null;
			colorMultiplier = null;
			normalColor = null;
			highlightedColor = null;
			pressedColor = null;
			disabledColor = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (!(selectable == null))
			{
				if (!colorMultiplier.IsNone)
				{
					colorMultiplier.Value = selectable.colors.colorMultiplier;
				}
				if (!fadeDuration.IsNone)
				{
					fadeDuration.Value = selectable.colors.fadeDuration;
				}
				if (!normalColor.IsNone)
				{
					normalColor.Value = selectable.colors.normalColor;
				}
				if (!pressedColor.IsNone)
				{
					pressedColor.Value = selectable.colors.pressedColor;
				}
				if (!highlightedColor.IsNone)
				{
					highlightedColor.Value = selectable.colors.highlightedColor;
				}
				if (!disabledColor.IsNone)
				{
					disabledColor.Value = selectable.colors.disabledColor;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the interactable flag of a UI Selectable component.")]
	public class UiGetIsInteractable : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Interactable value")]
		[UIHint(UIHint.Variable)]
		public FsmBool isInteractable;

		[Tooltip("Event sent if Component is Interactable")]
		public FsmEvent isInteractableEvent;

		[Tooltip("Event sent if Component is not Interactable")]
		public FsmEvent isNotInteractableEvent;

		private Selectable selectable;

		private bool originalState;

		public override void Reset()
		{
			gameObject = null;
			isInteractable = null;
			isInteractableEvent = null;
			isNotInteractableEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (!(selectable == null))
			{
				bool flag = selectable.IsInteractable();
				isInteractable.Value = flag;
				if (flag)
				{
					base.Fsm.Event(isInteractableEvent);
				}
				else
				{
					base.Fsm.Event(isNotInteractableEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the navigation mode of a UI Selectable component.")]
	public class UiNavigationGetMode : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The navigation mode value")]
		public FsmString navigationMode;

		[Tooltip("Event sent if transition is ColorTint")]
		public FsmEvent automaticEvent;

		[Tooltip("Event sent if transition is ColorTint")]
		public FsmEvent horizontalEvent;

		[Tooltip("Event sent if transition is SpriteSwap")]
		public FsmEvent verticalEvent;

		[Tooltip("Event sent if transition is Animation")]
		public FsmEvent explicitEvent;

		[Tooltip("Event sent if transition is none")]
		public FsmEvent noNavigationEvent;

		private Selectable selectable;

		private Selectable.Transition originalTransition;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (!(selectable == null))
			{
				navigationMode.Value = selectable.navigation.mode.ToString();
				if (selectable.navigation.mode == Navigation.Mode.None)
				{
					base.Fsm.Event(noNavigationEvent);
				}
				else if (selectable.navigation.mode == Navigation.Mode.Automatic)
				{
					base.Fsm.Event(automaticEvent);
				}
				else if (selectable.navigation.mode == Navigation.Mode.Vertical)
				{
					base.Fsm.Event(verticalEvent);
				}
				else if (selectable.navigation.mode == Navigation.Mode.Horizontal)
				{
					base.Fsm.Event(horizontalEvent);
				}
				else if (selectable.navigation.mode == Navigation.Mode.Explicit)
				{
					base.Fsm.Event(explicitEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the navigation mode of a UI Selectable component.")]
	public class UiNavigationSetMode : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The navigation mode value")]
		public Navigation.Mode navigationMode;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Selectable selectable;

		private Navigation _navigation;

		private Navigation.Mode originalValue;

		public override void Reset()
		{
			gameObject = null;
			navigationMode = Navigation.Mode.Automatic;
			resetOnExit = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			if (selectable != null && resetOnExit.Value)
			{
				originalValue = selectable.navigation.mode;
			}
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (selectable != null)
			{
				_navigation = selectable.navigation;
				_navigation.mode = navigationMode;
				selectable.navigation = _navigation;
			}
		}

		public override void OnExit()
		{
			if (!(selectable == null) && resetOnExit.Value)
			{
				_navigation = selectable.navigation;
				_navigation.mode = originalValue;
				selectable.navigation = _navigation;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the Animation Triggers of a UI Selectable component. Modifications will not be visible if transition is not Animation")]
	public class UiSetAnimationTriggers : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The normal trigger value. Leave as None for no effect")]
		public FsmString normalTrigger;

		[Tooltip("The highlighted trigger value. Leave as None for no effect")]
		public FsmString highlightedTrigger;

		[Tooltip("The pressed trigger value. Leave as None for no effect")]
		public FsmString pressedTrigger;

		[Tooltip("The disabled trigger value. Leave as None for no effect")]
		public FsmString disabledTrigger;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Selectable selectable;

		private AnimationTriggers _animationTriggers;

		private AnimationTriggers originalAnimationTriggers;

		public override void Reset()
		{
			gameObject = null;
			normalTrigger = new FsmString
			{
				UseVariable = true
			};
			highlightedTrigger = new FsmString
			{
				UseVariable = true
			};
			pressedTrigger = new FsmString
			{
				UseVariable = true
			};
			disabledTrigger = new FsmString
			{
				UseVariable = true
			};
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			if (selectable != null && resetOnExit.Value)
			{
				originalAnimationTriggers = selectable.animationTriggers;
			}
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (!(selectable == null))
			{
				_animationTriggers = selectable.animationTriggers;
				if (!normalTrigger.IsNone)
				{
					_animationTriggers.normalTrigger = normalTrigger.Value;
				}
				if (!highlightedTrigger.IsNone)
				{
					_animationTriggers.highlightedTrigger = highlightedTrigger.Value;
				}
				if (!pressedTrigger.IsNone)
				{
					_animationTriggers.pressedTrigger = pressedTrigger.Value;
				}
				if (!disabledTrigger.IsNone)
				{
					_animationTriggers.disabledTrigger = disabledTrigger.Value;
				}
				selectable.animationTriggers = _animationTriggers;
			}
		}

		public override void OnExit()
		{
			if (!(selectable == null) && resetOnExit.Value)
			{
				selectable.animationTriggers = originalAnimationTriggers;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the Color Block of a UI Selectable component. Modifications will not be visible if transition is not ColorTint")]
	public class UiSetColorBlock : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The fade duration value. Leave as None for no effect")]
		public FsmFloat fadeDuration;

		[Tooltip("The color multiplier value. Leave as None for no effect")]
		public FsmFloat colorMultiplier;

		[Tooltip("The normal color value. Leave as None for no effect")]
		public FsmColor normalColor;

		[Tooltip("The pressed color value. Leave as None for no effect")]
		public FsmColor pressedColor;

		[Tooltip("The highlighted color value. Leave as None for no effect")]
		public FsmColor highlightedColor;

		[Tooltip("The disabled color value. Leave as None for no effect")]
		public FsmColor disabledColor;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private Selectable selectable;

		private ColorBlock _colorBlock;

		private ColorBlock originalColorBlock;

		public override void Reset()
		{
			gameObject = null;
			fadeDuration = new FsmFloat
			{
				UseVariable = true
			};
			colorMultiplier = new FsmFloat
			{
				UseVariable = true
			};
			normalColor = new FsmColor
			{
				UseVariable = true
			};
			highlightedColor = new FsmColor
			{
				UseVariable = true
			};
			pressedColor = new FsmColor
			{
				UseVariable = true
			};
			disabledColor = new FsmColor
			{
				UseVariable = true
			};
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			if (selectable != null && resetOnExit.Value)
			{
				originalColorBlock = selectable.colors;
			}
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (!(selectable == null))
			{
				_colorBlock = selectable.colors;
				if (!colorMultiplier.IsNone)
				{
					_colorBlock.colorMultiplier = colorMultiplier.Value;
				}
				if (!fadeDuration.IsNone)
				{
					_colorBlock.fadeDuration = fadeDuration.Value;
				}
				if (!normalColor.IsNone)
				{
					_colorBlock.normalColor = normalColor.Value;
				}
				if (!pressedColor.IsNone)
				{
					_colorBlock.pressedColor = pressedColor.Value;
				}
				if (!highlightedColor.IsNone)
				{
					_colorBlock.highlightedColor = highlightedColor.Value;
				}
				if (!disabledColor.IsNone)
				{
					_colorBlock.disabledColor = disabledColor.Value;
				}
				selectable.colors = _colorBlock;
			}
		}

		public override void OnExit()
		{
			if (!(selectable == null) && resetOnExit.Value)
			{
				selectable.colors = originalColorBlock;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the interactable flag of a UI Selectable component.")]
	public class UiSetIsInteractable : FsmStateAction
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Interactable value")]
		public FsmBool isInteractable;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Selectable _selectable;

		private bool _originalState;

		public override void Reset()
		{
			gameObject = null;
			isInteractable = null;
			resetOnExit = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (ownerDefaultTarget != null)
			{
				_selectable = ownerDefaultTarget.GetComponent<Selectable>();
			}
			if (_selectable != null && resetOnExit.Value)
			{
				_originalState = _selectable.IsInteractable();
			}
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (_selectable != null)
			{
				_selectable.interactable = isInteractable.Value;
			}
		}

		public override void OnExit()
		{
			if (!(_selectable == null) && resetOnExit.Value)
			{
				_selectable.interactable = _originalState;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the transition type of a UI Selectable component.")]
	public class UiTransitionGetType : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The transition value")]
		public FsmString transition;

		[Tooltip("Event sent if transition is ColorTint")]
		public FsmEvent colorTintEvent;

		[Tooltip("Event sent if transition is SpriteSwap")]
		public FsmEvent spriteSwapEvent;

		[Tooltip("Event sent if transition is Animation")]
		public FsmEvent animationEvent;

		[Tooltip("Event sent if transition is none")]
		public FsmEvent noTransitionEvent;

		private Selectable selectable;

		private Selectable.Transition originalTransition;

		public override void Reset()
		{
			gameObject = null;
			transition = null;
			colorTintEvent = null;
			spriteSwapEvent = null;
			animationEvent = null;
			noTransitionEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (!(selectable == null))
			{
				transition.Value = selectable.transition.ToString();
				if (selectable.transition == Selectable.Transition.None)
				{
					base.Fsm.Event(noTransitionEvent);
				}
				else if (selectable.transition == Selectable.Transition.ColorTint)
				{
					base.Fsm.Event(colorTintEvent);
				}
				else if (selectable.transition == Selectable.Transition.SpriteSwap)
				{
					base.Fsm.Event(spriteSwapEvent);
				}
				else if (selectable.transition == Selectable.Transition.Animation)
				{
					base.Fsm.Event(animationEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the transition type of a UI Selectable component.")]
	public class UiTransitionSetType : ComponentAction<Selectable>
	{
		[RequiredField]
		[CheckForComponent(typeof(Selectable))]
		[Tooltip("The GameObject with the UI Selectable component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The transition value")]
		public Selectable.Transition transition;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Selectable selectable;

		private Selectable.Transition originalTransition;

		public override void Reset()
		{
			gameObject = null;
			transition = Selectable.Transition.ColorTint;
			resetOnExit = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				selectable = cachedComponent;
			}
			if (selectable != null && resetOnExit.Value)
			{
				originalTransition = selectable.transition;
			}
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (selectable != null)
			{
				selectable.transition = transition;
			}
		}

		public override void OnExit()
		{
			if (!(selectable == null) && resetOnExit.Value)
			{
				selectable.transition = originalTransition;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Set up multiple button events in a single action.")]
	public class UiButtonArray : FsmStateAction
	{
		[Tooltip("Where to send the events.")]
		public FsmEventTarget eventTarget;

		[CompoundArray("Buttons", "Button", "Click Event")]
		[CheckForComponent(typeof(Button))]
		[Tooltip("The GameObject with the UI button component.")]
		public FsmGameObject[] gameObjects;

		[Tooltip("Send this event when the button is Clicked.")]
		public FsmEvent[] clickEvents;

		[SerializeField]
		private Button[] buttons;

		[SerializeField]
		private GameObject[] cachedGameObjects;

		private UnityAction[] actions;

		private int clickedButton;

		public override void Reset()
		{
			gameObjects = new FsmGameObject[3];
			clickEvents = new FsmEvent[3];
		}

		public override void OnPreprocess()
		{
			buttons = new Button[gameObjects.Length];
			cachedGameObjects = new GameObject[gameObjects.Length];
			actions = new UnityAction[gameObjects.Length];
			InitButtons();
		}

		private void InitButtons()
		{
			if (cachedGameObjects == null || cachedGameObjects.Length != gameObjects.Length)
			{
				OnPreprocess();
			}
			for (int i = 0; i < gameObjects.Length; i++)
			{
				GameObject value = gameObjects[i].Value;
				if (value != null && cachedGameObjects[i] != value)
				{
					buttons[i] = value.GetComponent<Button>();
					cachedGameObjects[i] = value;
				}
			}
		}

		public override void OnEnter()
		{
			InitButtons();
			for (int i = 0; i < buttons.Length; i++)
			{
				Button button = buttons[i];
				if (!(button == null))
				{
					int index = i;
					actions[i] = delegate
					{
						OnClick(index);
					};
					button.onClick.AddListener(actions[i]);
				}
			}
		}

		public override void OnExit()
		{
			for (int i = 0; i < gameObjects.Length; i++)
			{
				FsmGameObject fsmGameObject = gameObjects[i];
				if (!(fsmGameObject.Value == null))
				{
					fsmGameObject.Value.GetComponent<Button>().onClick.RemoveListener(actions[i]);
				}
			}
		}

		public void OnClick(int index)
		{
			base.Fsm.Event(gameObjects[index].Value, eventTarget, clickEvents[index]);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sends an event when a UI Button is clicked.")]
	public class UiButtonOnClickEvent : ComponentAction<Button>
	{
		[RequiredField]
		[CheckForComponent(typeof(Button))]
		[Tooltip("The GameObject with the UI Button component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[Tooltip("Send this event when Clicked.")]
		public FsmEvent sendEvent;

		private Button button;

		public override void Reset()
		{
			gameObject = null;
			sendEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (button != null)
				{
					button.onClick.RemoveListener(DoOnClick);
				}
				button = cachedComponent;
				if (button != null)
				{
					button.onClick.AddListener(DoOnClick);
				}
				else
				{
					LogError("Missing UI.Button on " + ownerDefaultTarget.name);
				}
			}
			else
			{
				LogError("Missing GameObject ");
			}
		}

		public override void OnExit()
		{
			if (button != null)
			{
				button.onClick.RemoveListener(DoOnClick);
			}
		}

		public void DoOnClick()
		{
			SendEvent(eventTarget, sendEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Add multiple options to the options of the Dropdown UI Component")]
	public class UiDropDownAddOptions : ComponentAction<Dropdown>
	{
		[RequiredField]
		[CheckForComponent(typeof(Dropdown))]
		[Tooltip("The GameObject with the UI DropDown component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Options.")]
		[CompoundArray("Options", "Text", "Image")]
		public FsmString[] optionText;

		[ObjectType(typeof(Sprite))]
		public FsmObject[] optionImage;

		private Dropdown dropDown;

		private List<Dropdown.OptionData> options;

		public override void Reset()
		{
			gameObject = null;
			optionText = new FsmString[1];
			optionImage = new FsmObject[1];
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				dropDown = cachedComponent;
			}
			DoAddOptions();
			Finish();
		}

		private void DoAddOptions()
		{
			if (!(dropDown == null))
			{
				options = new List<Dropdown.OptionData>();
				for (int i = 0; i < optionText.Length; i++)
				{
					FsmString fsmString = optionText[i];
					options.Add(new Dropdown.OptionData
					{
						text = fsmString.Value,
						image = (optionImage[i].RawValue as Sprite)
					});
				}
				dropDown.AddOptions(options);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Clear the list of options in a UI Dropdown Component")]
	public class UiDropDownClearOptions : ComponentAction<Dropdown>
	{
		[RequiredField]
		[CheckForComponent(typeof(Dropdown))]
		[Tooltip("The GameObject with the UI DropDown component.")]
		public FsmOwnerDefault gameObject;

		private Dropdown dropDown;

		public override void Reset()
		{
			gameObject = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				dropDown = cachedComponent;
			}
			if (dropDown != null)
			{
				dropDown.ClearOptions();
			}
			Finish();
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Get the selected value (zero based index), sprite and text from a UI Dropdown Component")]
	public class UiDropDownGetSelectedData : ComponentAction<Dropdown>
	{
		[RequiredField]
		[CheckForComponent(typeof(Dropdown))]
		[Tooltip("The GameObject with the UI DropDown component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The selected index of the dropdown (zero based index).")]
		[UIHint(UIHint.Variable)]
		public FsmInt index;

		[Tooltip("The selected text.")]
		[UIHint(UIHint.Variable)]
		public FsmString getText;

		[ObjectType(typeof(Sprite))]
		[Tooltip("The selected text.")]
		[UIHint(UIHint.Variable)]
		public FsmObject getImage;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Dropdown dropDown;

		public override void Reset()
		{
			gameObject = null;
			index = null;
			getText = null;
			getImage = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				dropDown = cachedComponent;
			}
			GetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			GetValue();
		}

		private void GetValue()
		{
			if (!(dropDown == null))
			{
				if (!index.IsNone)
				{
					index.Value = dropDown.value;
				}
				if (!getText.IsNone)
				{
					getText.Value = dropDown.options[dropDown.value].text;
				}
				if (!getImage.IsNone)
				{
					getImage.Value = dropDown.options[dropDown.value].image;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Set the selected value (zero based index) of the UI Dropdown Component")]
	public class UiDropDownSetValue : ComponentAction<Dropdown>
	{
		[RequiredField]
		[CheckForComponent(typeof(Dropdown))]
		[Tooltip("The GameObject with the UI DropDown component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The selected index of the dropdown (zero based index).")]
		public FsmInt value;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Dropdown dropDown;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				dropDown = cachedComponent;
			}
			SetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			SetValue();
		}

		private void SetValue()
		{
			if (!(dropDown == null) && dropDown.value != value.Value)
			{
				dropDown.value = value.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Tweens the alpha of the CanvasRenderer color associated with this Graphic.")]
	public class UiGraphicCrossFadeAlpha : ComponentAction<Graphic>
	{
		[RequiredField]
		[CheckForComponent(typeof(Graphic))]
		[Tooltip("The GameObject with an Unity UI component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The alpha target")]
		public FsmFloat alpha;

		[Tooltip("The duration of the tween")]
		public FsmFloat duration;

		[Tooltip("Should ignore Time.scale?")]
		public FsmBool ignoreTimeScale;

		private Graphic uiComponent;

		public override void Reset()
		{
			gameObject = null;
			alpha = null;
			duration = 1f;
			ignoreTimeScale = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				uiComponent = cachedComponent;
			}
			uiComponent.CrossFadeAlpha(alpha.Value, duration.Value, ignoreTimeScale.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Tweens the color of the CanvasRenderer color associated with this Graphic.")]
	public class UiGraphicCrossFadeColor : ComponentAction<Graphic>
	{
		[RequiredField]
		[CheckForComponent(typeof(Graphic))]
		[Tooltip("The GameObject with a UI component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Color target of the UI component. Leave to none and set the individual color values, for example to affect just the alpha channel")]
		public FsmColor color;

		[Tooltip("The red channel Color target of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat red;

		[Tooltip("The green channel Color target of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat green;

		[Tooltip("The blue channel Color target of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat blue;

		[Tooltip("The alpha channel Color target of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat alpha;

		[Tooltip("The duration of the tween")]
		public FsmFloat duration;

		[Tooltip("Should ignore Time.scale?")]
		public FsmBool ignoreTimeScale;

		[Tooltip("Should also Tween the alpha channel?")]
		public FsmBool useAlpha;

		private Graphic uiComponent;

		public override void Reset()
		{
			gameObject = null;
			color = null;
			red = new FsmFloat
			{
				UseVariable = true
			};
			green = new FsmFloat
			{
				UseVariable = true
			};
			blue = new FsmFloat
			{
				UseVariable = true
			};
			alpha = new FsmFloat
			{
				UseVariable = true
			};
			useAlpha = null;
			duration = 1f;
			ignoreTimeScale = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				uiComponent = cachedComponent;
			}
			Color value = uiComponent.color;
			if (!color.IsNone)
			{
				value = color.Value;
			}
			if (!red.IsNone)
			{
				value.r = red.Value;
			}
			if (!green.IsNone)
			{
				value.g = green.Value;
			}
			if (!blue.IsNone)
			{
				value.b = blue.Value;
			}
			if (!alpha.IsNone)
			{
				value.a = alpha.Value;
			}
			uiComponent.CrossFadeColor(value, duration.Value, ignoreTimeScale.Value, useAlpha.Value);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the color of a UI Graphic component. (E.g. UI Sprite)")]
	public class UiGraphicGetColor : ComponentAction<Graphic>
	{
		[RequiredField]
		[CheckForComponent(typeof(Graphic))]
		[Tooltip("The GameObject with the UI component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Color of the UI component")]
		public FsmColor color;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Graphic uiComponent;

		public override void Reset()
		{
			gameObject = null;
			color = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				uiComponent = cachedComponent;
			}
			DoGetColorValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetColorValue();
		}

		private void DoGetColorValue()
		{
			if (uiComponent != null)
			{
				color.Value = uiComponent.color;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Set Graphic Color. E.g. to set Sprite Color.")]
	public class UiGraphicSetColor : ComponentAction<Graphic>
	{
		[RequiredField]
		[CheckForComponent(typeof(Graphic))]
		[Tooltip("The GameObject with a UI component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The Color of the UI component. Leave to none and set the individual color values, for example to affect just the alpha channel")]
		public FsmColor color;

		[Tooltip("The red channel Color of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat red;

		[Tooltip("The green channel Color of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat green;

		[Tooltip("The blue channel Color of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat blue;

		[Tooltip("The alpha channel Color of the UI component. Leave to none for no effect, else it overrides the color property")]
		public FsmFloat alpha;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private Graphic uiComponent;

		private Color originalColor;

		public override void Reset()
		{
			gameObject = null;
			color = null;
			red = new FsmFloat
			{
				UseVariable = true
			};
			green = new FsmFloat
			{
				UseVariable = true
			};
			blue = new FsmFloat
			{
				UseVariable = true
			};
			alpha = new FsmFloat
			{
				UseVariable = true
			};
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				uiComponent = cachedComponent;
			}
			originalColor = uiComponent.color;
			DoSetColorValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetColorValue();
		}

		private void DoSetColorValue()
		{
			if (!(uiComponent == null))
			{
				Color value = uiComponent.color;
				if (!color.IsNone)
				{
					value = color.Value;
				}
				if (!red.IsNone)
				{
					value.r = red.Value;
				}
				if (!green.IsNone)
				{
					value.g = green.Value;
				}
				if (!blue.IsNone)
				{
					value.b = blue.Value;
				}
				if (!alpha.IsNone)
				{
					value.a = alpha.Value;
				}
				uiComponent.color = value;
			}
		}

		public override void OnExit()
		{
			if (!(uiComponent == null) && resetOnExit.Value)
			{
				uiComponent.color = originalColor;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Set The Fill Amount on a UI Image")]
	public class UiImageGetFillAmount : ComponentAction<Image>
	{
		[RequiredField]
		[CheckForComponent(typeof(Image))]
		[Tooltip("The GameObject with the UI Image component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The fill amount.")]
		public FsmFloat ImageFillAmount;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Image image;

		public override void Reset()
		{
			gameObject = null;
			ImageFillAmount = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				image = cachedComponent;
			}
			DoGetFillAmount();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetFillAmount();
		}

		private void DoGetFillAmount()
		{
			if (image != null)
			{
				ImageFillAmount.Value = image.fillAmount;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the source image sprite of a UI Image component.")]
	public class UiImageGetSprite : ComponentAction<Image>
	{
		[RequiredField]
		[CheckForComponent(typeof(Image))]
		[Tooltip("The GameObject with the UI Image component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The source sprite of the UI Image component.")]
		[UIHint(UIHint.Variable)]
		[ObjectType(typeof(Sprite))]
		public FsmObject sprite;

		private Image image;

		public override void Reset()
		{
			gameObject = null;
			sprite = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				image = cachedComponent;
			}
			DoSetImageSourceValue();
			Finish();
		}

		private void DoSetImageSourceValue()
		{
			if (image != null)
			{
				sprite.Value = image.sprite;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Set The Fill Amount on a UI Image")]
	public class UiImageSetFillAmount : ComponentAction<Image>
	{
		[RequiredField]
		[CheckForComponent(typeof(Image))]
		[Tooltip("The GameObject with the UI Image component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HasFloatSlider(0f, 1f)]
		[Tooltip("The fill amount.")]
		public FsmFloat ImageFillAmount;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Image image;

		public override void Reset()
		{
			gameObject = null;
			ImageFillAmount = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				image = cachedComponent;
			}
			DoSetFillAmount();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetFillAmount();
		}

		private void DoSetFillAmount()
		{
			if (image != null)
			{
				image.fillAmount = ImageFillAmount.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the source image sprite of a UI Image component.")]
	public class UiImageSetSprite : ComponentAction<Image>
	{
		[RequiredField]
		[CheckForComponent(typeof(Image))]
		[Tooltip("The GameObject with the Image UI component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The source sprite of the UI Image component.")]
		[ObjectType(typeof(Sprite))]
		public FsmObject sprite;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Image image;

		private Sprite originalSprite;

		public override void Reset()
		{
			gameObject = null;
			resetOnExit = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				image = cachedComponent;
			}
			originalSprite = image.sprite;
			DoSetImageSourceValue();
			Finish();
		}

		private void DoSetImageSourceValue()
		{
			if (!(image == null))
			{
				image.sprite = sprite.Value as Sprite;
			}
		}

		public override void OnExit()
		{
			if (!(image == null) && resetOnExit.Value)
			{
				image.sprite = originalSprite;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Activate a UI InputField component to begin processing Events. Optionally Deactivate on state exit")]
	public class UiInputFieldActivate : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool deactivateOnExit;

		private InputField inputField;

		public override void Reset()
		{
			gameObject = null;
			deactivateOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoAction();
			Finish();
		}

		private void DoAction()
		{
			if (inputField != null)
			{
				inputField.ActivateInputField();
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && deactivateOnExit.Value)
			{
				inputField.DeactivateInputField();
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Deactivate a UI InputField to stop the processing of Events and send OnSubmit if not canceled. Optionally Activate on state exit")]
	public class UiInputFieldDeactivate : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Activate when exiting this state.")]
		public FsmBool activateOnExit;

		private InputField inputField;

		public override void Reset()
		{
			gameObject = null;
			activateOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoAction();
			Finish();
		}

		private void DoAction()
		{
			if (inputField != null)
			{
				inputField.DeactivateInputField();
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && activateOnExit.Value)
			{
				inputField.ActivateInputField();
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the caret's blink rate of a UI InputField component.")]
	public class UiInputFieldGetCaretBlinkRate : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The caret's blink rate for the UI InputField component.")]
		public FsmFloat caretBlinkRate;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private InputField inputField;

		public override void Reset()
		{
			caretBlinkRate = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (inputField != null)
			{
				caretBlinkRate.Value = inputField.caretBlinkRate;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the Character Limit value of a UI InputField component. This is the maximum number of characters that the user can type into the field.")]
	public class UiInputFieldGetCharacterLimit : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The maximum number of characters that the user can type into the UI InputField component.")]
		public FsmInt characterLimit;

		[Tooltip("Event sent if limit is infinite (equal to 0)")]
		public FsmEvent hasNoLimitEvent;

		[Tooltip("Event sent if limit is more than 0")]
		public FsmEvent isLimitedEvent;

		[Tooltip("Repeats every frame, useful for animation")]
		public bool everyFrame;

		private InputField inputField;

		public override void Reset()
		{
			characterLimit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (!(inputField == null))
			{
				characterLimit.Value = inputField.characterLimit;
				base.Fsm.Event((inputField.characterLimit > 0) ? isLimitedEvent : hasNoLimitEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the Hide Mobile Input value of a UI InputField component.")]
	public class UiInputFieldGetHideMobileInput : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the Hide Mobile flag value of the UI InputField component.")]
		public FsmBool hideMobileInput;

		[Tooltip("Event sent if hide mobile input property is true")]
		public FsmEvent mobileInputHiddenEvent;

		[Tooltip("Event sent if hide mobile input property is false")]
		public FsmEvent mobileInputShownEvent;

		private InputField inputField;

		public override void Reset()
		{
			hideMobileInput = null;
			mobileInputHiddenEvent = null;
			mobileInputShownEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (!(inputField == null))
			{
				hideMobileInput.Value = inputField.shouldHideMobileInput;
				base.Fsm.Event(inputField.shouldHideMobileInput ? mobileInputHiddenEvent : mobileInputShownEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the focused state of a UI InputField component.")]
	public class UiInputFieldGetIsFocused : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the is focused flag value of the UI InputField component.")]
		public FsmBool isFocused;

		[Tooltip("Event sent if inputField is focused")]
		public FsmEvent isfocusedEvent;

		[Tooltip("Event sent if nputField is not focused")]
		public FsmEvent isNotFocusedEvent;

		private InputField inputField;

		public override void Reset()
		{
			isFocused = null;
			isfocusedEvent = null;
			isNotFocusedEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (!(inputField == null))
			{
				isFocused.Value = inputField.isFocused;
				base.Fsm.Event(inputField.isFocused ? isfocusedEvent : isNotFocusedEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the placeHolder GameObject of a UI InputField component.")]
	public class UiInputFieldGetPlaceHolder : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the placeholder for the UI InputField component.")]
		public FsmGameObject placeHolder;

		[Tooltip("true if placeholder is found")]
		public FsmBool placeHolderDefined;

		[Tooltip("Event sent if no placeholder is defined")]
		public FsmEvent foundEvent;

		[Tooltip("Event sent if a placeholder is defined")]
		public FsmEvent notFoundEvent;

		private InputField inputField;

		public override void Reset()
		{
			placeHolder = null;
			placeHolderDefined = null;
			foundEvent = null;
			notFoundEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (!(inputField == null))
			{
				Graphic placeholder = inputField.placeholder;
				placeHolderDefined.Value = placeholder != null;
				if (placeholder != null)
				{
					placeHolder.Value = placeholder.gameObject;
					base.Fsm.Event(foundEvent);
				}
				else
				{
					base.Fsm.Event(notFoundEvent);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the selection color of a UI InputField component. This is the color of the highlighter to show what characters are selected")]
	public class UiInputFieldGetSelectionColor : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("This is the color of the highlighter to show what characters are selected of the UI InputField component.")]
		public FsmColor selectionColor;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private InputField inputField;

		public override void Reset()
		{
			selectionColor = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (inputField != null)
			{
				selectionColor.Value = inputField.selectionColor;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the text value of a UI InputField component.")]
	public class UiInputFieldGetText : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The text value of the UI InputField component.")]
		public FsmString text;

		public bool everyFrame;

		private InputField inputField;

		public override void Reset()
		{
			text = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetTextValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTextValue();
		}

		private void DoGetTextValue()
		{
			if (inputField != null)
			{
				text.Value = inputField.text;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the text value of a UI InputField component as a float.")]
	public class UiInputFieldGetTextAsFloat : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The text value as a float of the UI InputField component.")]
		public FsmFloat value;

		[UIHint(UIHint.Variable)]
		[Tooltip("true if text resolves to a float")]
		public FsmBool isFloat;

		[Tooltip("true if text resolves to a float")]
		public FsmEvent isFloatEvent;

		[Tooltip("Event sent if text does not resolves to a float")]
		public FsmEvent isNotFloatEvent;

		public bool everyFrame;

		private InputField inputField;

		private float _value;

		private bool _success;

		public override void Reset()
		{
			value = null;
			isFloat = null;
			isFloatEvent = null;
			isNotFloatEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetTextValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTextValue();
		}

		private void DoGetTextValue()
		{
			if (!(inputField == null))
			{
				_success = float.TryParse(inputField.text, out _value);
				value.Value = _value;
				isFloat.Value = _success;
				base.Fsm.Event(_success ? isFloatEvent : isNotFloatEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the text value of a UI InputField component as an Int.")]
	public class UiInputFieldGetTextAsInt : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the text value as an int.")]
		public FsmInt value;

		[UIHint(UIHint.Variable)]
		[Tooltip("True if text resolves to an int")]
		public FsmBool isInt;

		[Tooltip("Event to send if text resolves to an int")]
		public FsmEvent isIntEvent;

		[Tooltip("Event to send if text does NOT resolve to an int")]
		public FsmEvent isNotIntEvent;

		public bool everyFrame;

		private InputField inputField;

		private int _value;

		private bool _success;

		public override void Reset()
		{
			value = null;
			isInt = null;
			isIntEvent = null;
			isNotIntEvent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetTextValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTextValue();
		}

		private void DoGetTextValue()
		{
			if (!(inputField == null))
			{
				_success = int.TryParse(inputField.text, out _value);
				value.Value = _value;
				isInt.Value = _success;
				base.Fsm.Event(_success ? isIntEvent : isNotIntEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the cancel state of a UI InputField component. This relates to the last onEndEdit Event")]
	public class UiInputFieldGetWasCanceled : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("The was canceled flag value of the UI InputField component.")]
		public FsmBool wasCanceled;

		[Tooltip("Event sent if inputField was canceled")]
		public FsmEvent wasCanceledEvent;

		[Tooltip("Event sent if inputField was not canceled")]
		public FsmEvent wasNotCanceledEvent;

		private InputField inputField;

		public override void Reset()
		{
			wasCanceled = null;
			wasCanceledEvent = null;
			wasNotCanceledEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			if (!(inputField == null))
			{
				wasCanceled.Value = inputField.wasCanceled;
				base.Fsm.Event(inputField.wasCanceled ? wasCanceledEvent : wasNotCanceledEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Move Caret to text end in a UI InputField component. Optionally select from the current caret position")]
	public class UiInputFieldMoveCaretToTextEnd : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Define if we select or not from the current caret position. Default is true = no selection")]
		public FsmBool shift;

		private InputField inputField;

		public override void Reset()
		{
			gameObject = null;
			shift = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoAction();
			Finish();
		}

		private void DoAction()
		{
			if (inputField != null)
			{
				inputField.MoveTextEnd(shift.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Move Caret to text start in a UI InputField component. Optionally select from the current caret position")]
	public class UiInputFieldMoveCaretToTextStart : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Define if we select or not from the current caret position. Default is true = no selection")]
		public FsmBool shift;

		private InputField inputField;

		public override void Reset()
		{
			gameObject = null;
			shift = true;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			DoAction();
			Finish();
		}

		private void DoAction()
		{
			if (inputField != null)
			{
				inputField.MoveTextStart(shift.Value);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Fires an event when editing ended in a UI InputField component. Event string data will contain the text value, and the boolean will be true is it was a cancel action")]
	public class UiInputFieldOnEndEditEvent : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[Tooltip("Send this event when editing ended.")]
		public FsmEvent sendEvent;

		[Tooltip("The content of the InputField when edited ended")]
		[UIHint(UIHint.Variable)]
		public FsmString text;

		[Tooltip("The canceled state of the InputField when edited ended")]
		[UIHint(UIHint.Variable)]
		public FsmBool wasCanceled;

		private InputField inputField;

		public override void Reset()
		{
			gameObject = null;
			sendEvent = null;
			text = null;
			wasCanceled = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
				if (inputField != null)
				{
					inputField.onEndEdit.AddListener(DoOnEndEdit);
				}
			}
		}

		public override void OnExit()
		{
			if (inputField != null)
			{
				inputField.onEndEdit.RemoveListener(DoOnEndEdit);
			}
		}

		public void DoOnEndEdit(string value)
		{
			text.Value = value;
			wasCanceled.Value = inputField.wasCanceled;
			Fsm.EventData.StringData = value;
			Fsm.EventData.BoolData = inputField.wasCanceled;
			SendEvent(eventTarget, sendEvent);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Fires an event when user submits from a UI InputField component. \nThis only fires if the user press Enter, not when field looses focus or user escaped the field.\nEvent string data will contain the text value.")]
	public class UiInputFieldOnSubmitEvent : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[Tooltip("Send this event when editing ended.")]
		public FsmEvent sendEvent;

		[Tooltip("The content of the InputField when submitting")]
		[UIHint(UIHint.Variable)]
		public FsmString text;

		private InputField inputField;

		public override void Reset()
		{
			gameObject = null;
			eventTarget = FsmEventTarget.Self;
			sendEvent = null;
			text = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
				if (inputField != null)
				{
					inputField.onEndEdit.AddListener(DoOnEndEdit);
				}
			}
		}

		public override void OnExit()
		{
			if (inputField != null)
			{
				inputField.onEndEdit.RemoveListener(DoOnEndEdit);
			}
		}

		public void DoOnEndEdit(string value)
		{
			if (!inputField.wasCanceled)
			{
				text.Value = value;
				Fsm.EventData.StringData = value;
				SendEvent(eventTarget, sendEvent);
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Catches UI InputField onValueChanged event. Store the new value and/or send events. Event string data also contains the new value.")]
	public class UiInputFieldOnValueChangeEvent : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[Tooltip("Send this event when value changed.")]
		public FsmEvent sendEvent;

		[Tooltip("Store new value in string variable.")]
		[UIHint(UIHint.Variable)]
		public FsmString text;

		private InputField inputField;

		public override void Reset()
		{
			gameObject = null;
			text = null;
			eventTarget = FsmEventTarget.Self;
			sendEvent = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
				if (inputField != null)
				{
					inputField.onValueChanged.AddListener(DoOnValueChange);
				}
			}
		}

		public override void OnExit()
		{
			if (inputField != null)
			{
				inputField.onValueChanged.RemoveListener(DoOnValueChange);
			}
		}

		public void DoOnValueChange(string value)
		{
			text.Value = value;
			Fsm.EventData.StringData = value;
			SendEvent(eventTarget, sendEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the Asterix Character of a UI InputField component.")]
	public class UiInputFieldSetAsterixChar : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The asterix Character used for password field type of the UI InputField component. Only the first character will be used, the rest of the string will be ignored")]
		public FsmString asterixChar;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private InputField inputField;

		private char originalValue;

		private static char __char__ = ' ';

		public override void Reset()
		{
			gameObject = null;
			asterixChar = "*";
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			originalValue = inputField.asteriskChar;
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			char asteriskChar = __char__;
			if (asterixChar.Value.Length > 0)
			{
				asteriskChar = asterixChar.Value[0];
			}
			if (inputField != null)
			{
				inputField.asteriskChar = asteriskChar;
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && resetOnExit.Value)
			{
				inputField.asteriskChar = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the caret's blink rate of a UI InputField component.")]
	public class UiInputFieldSetCaretBlinkRate : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The caret's blink rate for the UI InputField component.")]
		public FsmInt caretBlinkRate;

		[Tooltip("Deactivate when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private InputField inputField;

		private float originalValue;

		public override void Reset()
		{
			gameObject = null;
			caretBlinkRate = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			originalValue = inputField.caretBlinkRate;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (inputField != null)
			{
				inputField.caretBlinkRate = caretBlinkRate.Value;
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && resetOnExit.Value)
			{
				inputField.caretBlinkRate = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the maximum number of characters that the user can type into a UI InputField component. Optionally reset on exit")]
	public class UiInputFieldSetCharacterLimit : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The maximum number of characters that the user can type into the UI InputField component. 0 = infinite")]
		public FsmInt characterLimit;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private InputField inputField;

		private int originalValue;

		public override void Reset()
		{
			gameObject = null;
			characterLimit = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			originalValue = inputField.characterLimit;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (inputField != null)
			{
				inputField.characterLimit = characterLimit.Value;
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && resetOnExit.Value)
			{
				inputField.characterLimit = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the Hide Mobile Input property of a UI InputField component.")]
	public class UiInputFieldSetHideMobileInput : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.TextArea)]
		[Tooltip("The Hide Mobile Input flag value of the UI InputField component.")]
		public FsmBool hideMobileInput;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private InputField inputField;

		private bool originalValue;

		public override void Reset()
		{
			gameObject = null;
			hideMobileInput = null;
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			originalValue = inputField.shouldHideMobileInput;
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (inputField != null)
			{
				inputField.shouldHideMobileInput = hideMobileInput.Value;
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && resetOnExit.Value)
			{
				inputField.shouldHideMobileInput = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the placeholder of a UI InputField component. Optionally reset on exit")]
	public class UiInputFieldSetPlaceHolder : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[CheckForComponent(typeof(Graphic))]
		[Tooltip("The placeholder (any graphic UI Component) for the UI InputField component.")]
		public FsmGameObject placeholder;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private InputField inputField;

		private Graphic originalValue;

		public override void Reset()
		{
			gameObject = null;
			placeholder = null;
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			originalValue = inputField.placeholder;
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (inputField != null)
			{
				GameObject value = placeholder.Value;
				if (value == null)
				{
					inputField.placeholder = null;
				}
				else
				{
					inputField.placeholder = value.GetComponent<Graphic>();
				}
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && resetOnExit.Value)
			{
				inputField.placeholder = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the selection color of a UI InputField component. This is the color of the highlighter to show what characters are selected.")]
	public class UiInputFieldSetSelectionColor : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The color of the highlighter to show what characters are selected for the UI InputField component.")]
		public FsmColor selectionColor;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private InputField inputField;

		private Color originalValue;

		public override void Reset()
		{
			gameObject = null;
			selectionColor = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			originalValue = inputField.selectionColor;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (inputField != null)
			{
				inputField.selectionColor = selectionColor.Value;
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && resetOnExit.Value)
			{
				inputField.selectionColor = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the text value of a UI InputField component.")]
	public class UiInputFieldSetText : ComponentAction<InputField>
	{
		[RequiredField]
		[CheckForComponent(typeof(InputField))]
		[Tooltip("The GameObject with the UI InputField component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.TextArea)]
		[Tooltip("The text of the UI InputField component.")]
		public FsmString text;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private InputField inputField;

		private string originalString;

		public override void Reset()
		{
			gameObject = null;
			text = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				inputField = cachedComponent;
			}
			originalString = inputField.text;
			DoSetTextValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetTextValue();
		}

		private void DoSetTextValue()
		{
			if (inputField != null)
			{
				inputField.text = text.Value;
			}
		}

		public override void OnExit()
		{
			if (!(inputField == null) && resetOnExit.Value)
			{
				inputField.text = originalString;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the texture of a UI RawImage component.")]
	public class UiRawImageSetTexture : ComponentAction<RawImage>
	{
		[RequiredField]
		[CheckForComponent(typeof(RawImage))]
		[Tooltip("The GameObject with the UI RawImage component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The texture of the UI RawImage component.")]
		public FsmTexture texture;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private RawImage _texture;

		private Texture _originalTexture;

		public override void Reset()
		{
			gameObject = null;
			texture = null;
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				_texture = cachedComponent;
			}
			_originalTexture = _texture.texture;
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (_texture != null)
			{
				_texture.texture = texture.Value;
			}
		}

		public override void OnExit()
		{
			if (!(_texture == null) && resetOnExit.Value)
			{
				_texture.texture = _originalTexture;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Rebuild a UI Graphic component.")]
	public class UiRebuild : ComponentAction<Graphic>
	{
		[RequiredField]
		[CheckForComponent(typeof(Graphic))]
		[Tooltip("The GameObject with the UI Graphic component.")]
		public FsmOwnerDefault gameObject;

		public CanvasUpdate canvasUpdate;

		[Tooltip("Only Rebuild when state exits.")]
		public bool rebuildOnExit;

		private Graphic graphic;

		public override void Reset()
		{
			gameObject = null;
			canvasUpdate = CanvasUpdate.LatePreRender;
			rebuildOnExit = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				graphic = cachedComponent;
			}
			if (!rebuildOnExit)
			{
				DoAction();
			}
			Finish();
		}

		private void DoAction()
		{
			if (graphic != null)
			{
				graphic.Rebuild(canvasUpdate);
			}
		}

		public override void OnExit()
		{
			if (rebuildOnExit)
			{
				DoAction();
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the UI ScrollRect horizontal flag")]
	public class UiScrollRectSetHorizontal : ComponentAction<ScrollRect>
	{
		[RequiredField]
		[CheckForComponent(typeof(ScrollRect))]
		[Tooltip("The GameObject with the UI ScrollRect component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The horizontal flag")]
		public FsmBool horizontal;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private ScrollRect scrollRect;

		private bool originalValue;

		public override void Reset()
		{
			gameObject = null;
			horizontal = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollRect = cachedComponent;
			}
			originalValue = scrollRect.vertical;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (scrollRect != null)
			{
				scrollRect.horizontal = horizontal.Value;
			}
		}

		public override void OnExit()
		{
			if (!(scrollRect == null) && resetOnExit.Value)
			{
				scrollRect.horizontal = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("The normalized scroll position as a Vector2 between (0,0) and (1,1) with (0,0) being the lower left corner.")]
	public class UiScrollRectSetNormalizedPosition : ComponentAction<ScrollRect>
	{
		[RequiredField]
		[CheckForComponent(typeof(ScrollRect))]
		[Tooltip("The GameObject with the UI ScrollRect component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The position's value of the UI ScrollRect component. Ranges from 0.0 to 1.0.")]
		public FsmVector2 normalizedPosition;

		[Tooltip("The horizontal position's value of the UI ScrollRect component. Ranges from 0.0 to 1.0.")]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat horizontalPosition;

		[Tooltip("The vertical position's value of the UI ScrollRect component. Ranges from 0.0 to 1.0.")]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat verticalPosition;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private ScrollRect scrollRect;

		private Vector2 originalValue;

		public override void Reset()
		{
			gameObject = null;
			normalizedPosition = null;
			horizontalPosition = new FsmFloat
			{
				UseVariable = true
			};
			verticalPosition = new FsmFloat
			{
				UseVariable = true
			};
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollRect = cachedComponent;
			}
			originalValue = scrollRect.normalizedPosition;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (!(scrollRect == null))
			{
				Vector2 value = scrollRect.normalizedPosition;
				if (!normalizedPosition.IsNone)
				{
					value = normalizedPosition.Value;
				}
				if (!horizontalPosition.IsNone)
				{
					value.x = horizontalPosition.Value;
				}
				if (!verticalPosition.IsNone)
				{
					value.y = verticalPosition.Value;
				}
				scrollRect.normalizedPosition = value;
			}
		}

		public override void OnExit()
		{
			if (!(scrollRect == null) && resetOnExit.Value)
			{
				scrollRect.normalizedPosition = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the UI ScrollRect vertical flag")]
	public class UiScrollRectSetVertical : ComponentAction<ScrollRect>
	{
		[RequiredField]
		[CheckForComponent(typeof(ScrollRect))]
		[Tooltip("The GameObject with the UI ScrollRect component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The vertical flag")]
		public FsmBool vertical;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private ScrollRect scrollRect;

		private bool originalValue;

		public override void Reset()
		{
			gameObject = null;
			vertical = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollRect = cachedComponent;
			}
			originalValue = scrollRect.vertical;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (scrollRect != null)
			{
				scrollRect.vertical = vertical.Value;
			}
		}

		public override void OnExit()
		{
			if (!(scrollRect == null) && resetOnExit.Value)
			{
				scrollRect.vertical = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the direction of a UI Scrollbar component.")]
	public class UiScrollbarGetDirection : ComponentAction<Scrollbar>
	{
		[RequiredField]
		[CheckForComponent(typeof(Scrollbar))]
		[Tooltip("The GameObject with the UI Scrollbar component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the direction of the UI Scrollbar.")]
		[ObjectType(typeof(Scrollbar.Direction))]
		public FsmEnum direction;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Scrollbar scrollbar;

		public override void Reset()
		{
			gameObject = null;
			direction = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollbar = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (scrollbar != null)
			{
				direction.Value = scrollbar.direction;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the value of a UI Scrollbar component.")]
	public class UiScrollbarGetValue : ComponentAction<Scrollbar>
	{
		[RequiredField]
		[CheckForComponent(typeof(Scrollbar))]
		[Tooltip("The GameObject with the UI Scrollbar component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The position value of the UI Scrollbar.")]
		public FsmFloat value;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Scrollbar scrollbar;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollbar = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (scrollbar != null)
			{
				value.Value = scrollbar.value;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Catches UI Scrollbar onValueChanged event. Store the new value and/or send events. Event float data will contain the new Scrollbar value")]
	public class UiScrollbarOnValueChanged : ComponentAction<Scrollbar>
	{
		[RequiredField]
		[CheckForComponent(typeof(Scrollbar))]
		[Tooltip("The GameObject with the UI Scrollbar component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[Tooltip("Send this event when the UI Scrollbar value changes.")]
		public FsmEvent sendEvent;

		[Tooltip("Store new value in float variable.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat value;

		private Scrollbar scrollbar;

		public override void Reset()
		{
			gameObject = null;
			eventTarget = FsmEventTarget.Self;
			sendEvent = null;
			value = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollbar = cachedComponent;
				if (scrollbar != null)
				{
					scrollbar.onValueChanged.AddListener(DoOnValueChanged);
				}
			}
		}

		public override void OnExit()
		{
			if (scrollbar != null)
			{
				scrollbar.onValueChanged.RemoveListener(DoOnValueChanged);
			}
		}

		public void DoOnValueChanged(float _value)
		{
			value.Value = _value;
			Fsm.EventData.FloatData = _value;
			SendEvent(eventTarget, sendEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the direction of a UI Scrollbar component.")]
	public class UiScrollbarSetDirection : ComponentAction<Scrollbar>
	{
		[RequiredField]
		[CheckForComponent(typeof(Scrollbar))]
		[Tooltip("The GameObject with the UI Scrollbar component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The direction of the UI Scrollbar.")]
		[ObjectType(typeof(Scrollbar.Direction))]
		public FsmEnum direction;

		[Tooltip("Include the  RectLayouts. Leave to none for no effect")]
		public FsmBool includeRectLayouts;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Scrollbar scrollbar;

		private Scrollbar.Direction originalValue;

		public override void Reset()
		{
			gameObject = null;
			direction = Scrollbar.Direction.LeftToRight;
			includeRectLayouts = new FsmBool
			{
				UseVariable = true
			};
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollbar = cachedComponent;
			}
			if (resetOnExit.Value)
			{
				originalValue = scrollbar.direction;
			}
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (!(scrollbar == null))
			{
				if (includeRectLayouts.IsNone)
				{
					scrollbar.direction = (Scrollbar.Direction)(object)direction.Value;
				}
				else
				{
					scrollbar.SetDirection((Scrollbar.Direction)(object)direction.Value, includeRectLayouts.Value);
				}
			}
		}

		public override void OnExit()
		{
			if (!(scrollbar == null) && resetOnExit.Value)
			{
				if (includeRectLayouts.IsNone)
				{
					scrollbar.direction = originalValue;
				}
				else
				{
					scrollbar.SetDirection(originalValue, includeRectLayouts.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the number of distinct scroll positions allowed for a UI Scrollbar component.")]
	public class UiScrollbarSetNumberOfSteps : ComponentAction<Scrollbar>
	{
		[RequiredField]
		[CheckForComponent(typeof(Scrollbar))]
		[Tooltip("The GameObject with the UI Scrollbar component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The number of distinct scroll positions allowed for the UI Scrollbar.")]
		public FsmInt value;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Scrollbar scrollbar;

		private int originalValue;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollbar = cachedComponent;
			}
			originalValue = scrollbar.numberOfSteps;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (scrollbar != null)
			{
				scrollbar.numberOfSteps = value.Value;
			}
		}

		public override void OnExit()
		{
			if (!(scrollbar == null) && resetOnExit.Value)
			{
				scrollbar.numberOfSteps = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the fractional size of the handle of a UI Scrollbar component. Ranges from 0.0 to 1.0.")]
	public class UiScrollbarSetSize : ComponentAction<Scrollbar>
	{
		[RequiredField]
		[CheckForComponent(typeof(Scrollbar))]
		[Tooltip("The GameObject with the UI Scrollbar component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The fractional size of the handle for the UI Scrollbar. Ranges from 0.0 to 1.0.")]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat value;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Scrollbar scrollbar;

		private float originalValue;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollbar = cachedComponent;
			}
			if (resetOnExit.Value)
			{
				originalValue = scrollbar.size;
			}
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (scrollbar != null)
			{
				scrollbar.size = value.Value;
			}
		}

		public override void OnExit()
		{
			if (!(scrollbar == null) && resetOnExit.Value)
			{
				scrollbar.size = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the position value of a UI Scrollbar component. Ranges from 0.0 to 1.0.")]
	public class UiScrollbarSetValue : ComponentAction<Scrollbar>
	{
		[RequiredField]
		[CheckForComponent(typeof(Scrollbar))]
		[Tooltip("The GameObject with the UI Scrollbar component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The position's value of the UI Scrollbar component. Ranges from 0.0 to 1.0.")]
		[HasFloatSlider(0f, 1f)]
		public FsmFloat value;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Scrollbar scrollbar;

		private float originalValue;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				scrollbar = cachedComponent;
			}
			originalValue = scrollbar.value;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (scrollbar != null)
			{
				scrollbar.value = value.Value;
			}
		}

		public override void OnExit()
		{
			if (!(scrollbar == null) && resetOnExit.Value)
			{
				scrollbar.value = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the direction of a UI Slider component.")]
	public class UiSliderGetDirection : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The direction of the UI Slider.")]
		[ObjectType(typeof(Slider.Direction))]
		public FsmEnum direction;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Slider slider;

		public override void Reset()
		{
			gameObject = null;
			direction = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (slider != null)
			{
				direction.Value = slider.direction;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the minimum and maximum limits for the value of a UI Slider component.")]
	public class UiSliderGetMinMax : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the minimum value of the UI Slider.")]
		public FsmFloat minValue;

		[UIHint(UIHint.Variable)]
		[Tooltip("Store the maximum value of the UI Slider.")]
		public FsmFloat maxValue;

		private Slider slider;

		public override void Reset()
		{
			gameObject = null;
			minValue = null;
			maxValue = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (slider != null)
			{
				if (!minValue.IsNone)
				{
					minValue.Value = slider.minValue;
				}
				if (!maxValue.IsNone)
				{
					maxValue.Value = slider.maxValue;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the normalized value (between 0 and 1) of a UI Slider component.")]
	public class UiSliderGetNormalizedValue : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The normalized value (between 0 and 1) of the UI Slider.")]
		public FsmFloat value;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Slider slider;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (slider != null)
			{
				value.Value = slider.normalizedValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the value of a UI Slider component.")]
	public class UiSliderGetValue : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The value of the UI Slider component.")]
		public FsmFloat value;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Slider slider;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (slider != null)
			{
				value.Value = slider.value;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the wholeNumbers property of a UI Slider component. If true, the Slider is constrained to integer values")]
	public class UiSliderGetWholeNumbers : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("Is the Slider constrained to integer values?")]
		public FsmBool wholeNumbers;

		[Tooltip("Event sent if slider is showing integers")]
		public FsmEvent isShowingWholeNumbersEvent;

		[Tooltip("Event sent if slider is showing floats")]
		public FsmEvent isNotShowingWholeNumbersEvent;

		private Slider slider;

		public override void Reset()
		{
			gameObject = null;
			isShowingWholeNumbersEvent = null;
			isNotShowingWholeNumbersEvent = null;
			wholeNumbers = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			DoGetValue();
			Finish();
		}

		private void DoGetValue()
		{
			bool flag = false;
			if (slider != null)
			{
				flag = slider.wholeNumbers;
			}
			wholeNumbers.Value = flag;
			base.Fsm.Event(flag ? isShowingWholeNumbersEvent : isNotShowingWholeNumbersEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Catches onValueChanged event for a UI Slider component. Store the new value and/or send events. Event float data will contain the new slider value")]
	public class UiSliderOnValueChangedEvent : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[Tooltip("Send this event when Clicked.")]
		public FsmEvent sendEvent;

		[Tooltip("Store the new value in float variable.")]
		[UIHint(UIHint.Variable)]
		public FsmFloat value;

		private Slider slider;

		public override void Reset()
		{
			gameObject = null;
			eventTarget = FsmEventTarget.Self;
			sendEvent = null;
			value = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
				if (slider != null)
				{
					slider.onValueChanged.AddListener(DoOnValueChanged);
				}
			}
		}

		public override void OnExit()
		{
			if (slider != null)
			{
				slider.onValueChanged.RemoveListener(DoOnValueChanged);
			}
		}

		public void DoOnValueChanged(float _value)
		{
			value.Value = _value;
			Fsm.EventData.FloatData = _value;
			SendEvent(eventTarget, sendEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the direction of a UI Slider component.")]
	public class UiSliderSetDirection : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The direction of the UI Slider component.")]
		[ObjectType(typeof(Slider.Direction))]
		public FsmEnum direction;

		[Tooltip("Include the  RectLayouts. Leave to none for no effect")]
		public FsmBool includeRectLayouts;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Slider slider;

		private Slider.Direction originalValue;

		public override void Reset()
		{
			gameObject = null;
			direction = Slider.Direction.LeftToRight;
			includeRectLayouts = new FsmBool
			{
				UseVariable = true
			};
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			originalValue = slider.direction;
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (!(slider == null))
			{
				if (includeRectLayouts.IsNone)
				{
					slider.direction = (Slider.Direction)(object)direction.Value;
				}
				else
				{
					slider.SetDirection((Slider.Direction)(object)direction.Value, includeRectLayouts.Value);
				}
			}
		}

		public override void OnExit()
		{
			if (!(slider == null) && resetOnExit.Value)
			{
				if (includeRectLayouts.IsNone)
				{
					slider.direction = originalValue;
				}
				else
				{
					slider.SetDirection(originalValue, includeRectLayouts.Value);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the minimum and maximum limits for the value of a UI Slider component. Optionally resets on exit")]
	public class UiSliderSetMinMax : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("The minimum value of the UI Slider component. Leave as None for no effect")]
		public FsmFloat minValue;

		[Tooltip("The maximum value of the UI Slider component. Leave as None for no effect")]
		public FsmFloat maxValue;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Slider slider;

		private float originalMinValue;

		private float originalMaxValue;

		public override void Reset()
		{
			gameObject = null;
			minValue = new FsmFloat
			{
				UseVariable = true
			};
			maxValue = new FsmFloat
			{
				UseVariable = true
			};
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			if (resetOnExit.Value)
			{
				originalMinValue = slider.minValue;
				originalMaxValue = slider.maxValue;
			}
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (!(slider == null))
			{
				if (!minValue.IsNone)
				{
					slider.minValue = minValue.Value;
				}
				if (!maxValue.IsNone)
				{
					slider.maxValue = maxValue.Value;
				}
			}
		}

		public override void OnExit()
		{
			if (!(slider == null) && resetOnExit.Value)
			{
				slider.minValue = originalMinValue;
				slider.maxValue = originalMaxValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the normalized value ( between 0 and 1) of a UI Slider component.")]
	public class UiSliderSetNormalizedValue : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[HasFloatSlider(0f, 1f)]
		[Tooltip("The normalized value ( between 0 and 1) of the UI Slider component.")]
		public FsmFloat value;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Slider slider;

		private float originalValue;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			originalValue = slider.normalizedValue;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (slider != null)
			{
				slider.normalizedValue = value.Value;
			}
		}

		public override void OnExit()
		{
			if (!(slider == null) && resetOnExit.Value)
			{
				slider.normalizedValue = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the value of a UI Slider component.")]
	public class UiSliderSetValue : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("The value of the UI Slider component.")]
		public FsmFloat value;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Slider slider;

		private float originalValue;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			originalValue = slider.value;
			DoSetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetValue();
		}

		private void DoSetValue()
		{
			if (slider != null)
			{
				slider.value = value.Value;
			}
		}

		public override void OnExit()
		{
			if (!(slider == null) && resetOnExit.Value)
			{
				slider.value = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the wholeNumbers property of a UI Slider component. This defines if the slider will be constrained to integer values ")]
	public class UiSliderSetWholeNumbers : ComponentAction<Slider>
	{
		[RequiredField]
		[CheckForComponent(typeof(Slider))]
		[Tooltip("The GameObject with the UI Slider component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Should the slider be constrained to integer values?")]
		public FsmBool wholeNumbers;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Slider slider;

		private bool originalValue;

		public override void Reset()
		{
			gameObject = null;
			wholeNumbers = null;
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				slider = cachedComponent;
			}
			originalValue = slider.wholeNumbers;
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (slider != null)
			{
				slider.wholeNumbers = wholeNumbers.Value;
			}
		}

		public override void OnExit()
		{
			if (!(slider == null) && resetOnExit.Value)
			{
				slider.wholeNumbers = originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the text value of a UI Text component.")]
	public class UiTextGetText : ComponentAction<Text>
	{
		[RequiredField]
		[CheckForComponent(typeof(Text))]
		[Tooltip("The GameObject with the UI Text component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The text value of the UI Text component.")]
		public FsmString text;

		[Tooltip("Runs every frame. Useful to animate values over time.")]
		public bool everyFrame;

		private Text uiText;

		public override void Reset()
		{
			text = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				uiText = cachedComponent;
			}
			DoGetTextValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetTextValue();
		}

		private void DoGetTextValue()
		{
			if (uiText != null)
			{
				text.Value = uiText.text;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the text value of a UI Text component.")]
	public class UiTextSetText : ComponentAction<Text>
	{
		[RequiredField]
		[CheckForComponent(typeof(Text))]
		[Tooltip("The GameObject with the UI Text component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.TextArea)]
		[Tooltip("The text of the UI Text component.")]
		public FsmString text;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Text uiText;

		private string originalString;

		public override void Reset()
		{
			gameObject = null;
			text = null;
			resetOnExit = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				uiText = cachedComponent;
			}
			originalString = uiText.text;
			DoSetTextValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetTextValue();
		}

		private void DoSetTextValue()
		{
			if (!(uiText == null))
			{
				uiText.text = text.Value;
			}
		}

		public override void OnExit()
		{
			if (!(uiText == null) && resetOnExit.Value)
			{
				uiText.text = originalString;
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Gets the isOn value of a UI Toggle component. Optionally send events")]
	public class UiToggleGetIsOn : ComponentAction<Toggle>
	{
		[RequiredField]
		[CheckForComponent(typeof(Toggle))]
		[Tooltip("The GameObject with the UI Toggle component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[Tooltip("The isOn Value of the UI Toggle component.")]
		public FsmBool value;

		[Tooltip("Event sent when isOn Value is true.")]
		public FsmEvent isOnEvent;

		[Tooltip("Event sent when isOn Value is false.")]
		public FsmEvent isOffEvent;

		[Tooltip("Repeats every frame")]
		public bool everyFrame;

		private Toggle _toggle;

		public override void Reset()
		{
			gameObject = null;
			value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				_toggle = cachedComponent;
			}
			DoGetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetValue();
		}

		private void DoGetValue()
		{
			if (!(_toggle == null))
			{
				value.Value = _toggle.isOn;
				base.Fsm.Event(_toggle.isOn ? isOnEvent : isOffEvent);
			}
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Catches onValueChanged event in a UI Toggle component. Store the new value and/or send events. Event bool data will contain the new Toggle value")]
	public class UiToggleOnValueChangedEvent : ComponentAction<Toggle>
	{
		[RequiredField]
		[CheckForComponent(typeof(Toggle))]
		[Tooltip("The GameObject with the UI Toggle component.")]
		public FsmOwnerDefault gameObject;

		[Tooltip("Where to send the event.")]
		public FsmEventTarget eventTarget;

		[Tooltip("Send this event when the value changes.")]
		public FsmEvent sendEvent;

		[Tooltip("Store the new value in bool variable.")]
		[UIHint(UIHint.Variable)]
		public FsmBool value;

		private Toggle toggle;

		public override void Reset()
		{
			gameObject = null;
			eventTarget = FsmEventTarget.Self;
			sendEvent = null;
			value = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				if (toggle != null)
				{
					toggle.onValueChanged.RemoveListener(DoOnValueChanged);
				}
				toggle = cachedComponent;
				if (toggle != null)
				{
					toggle.onValueChanged.AddListener(DoOnValueChanged);
				}
				else
				{
					LogError("Missing UI.Toggle on " + ownerDefaultTarget.name);
				}
			}
			else
			{
				LogError("Missing GameObject");
			}
		}

		public override void OnExit()
		{
			if (toggle != null)
			{
				toggle.onValueChanged.RemoveListener(DoOnValueChanged);
			}
		}

		public void DoOnValueChanged(bool _value)
		{
			value.Value = _value;
			Fsm.EventData.BoolData = _value;
			SendEvent(eventTarget, sendEvent);
		}
	}
	[ActionCategory(ActionCategory.UI)]
	[Tooltip("Sets the isOn property of a UI Toggle component.")]
	public class UiToggleSetIsOn : ComponentAction<Toggle>
	{
		[RequiredField]
		[CheckForComponent(typeof(Toggle))]
		[Tooltip("The GameObject with the UI Toggle component.")]
		public FsmOwnerDefault gameObject;

		[RequiredField]
		[Tooltip("Should the toggle be on?")]
		public FsmBool isOn;

		[Tooltip("Reset when exiting this state.")]
		public FsmBool resetOnExit;

		private Toggle _toggle;

		private bool _originalValue;

		public override void Reset()
		{
			gameObject = null;
			isOn = null;
			resetOnExit = null;
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
			if (UpdateCache(ownerDefaultTarget))
			{
				_toggle = cachedComponent;
			}
			DoSetValue();
			Finish();
		}

		private void DoSetValue()
		{
			if (_toggle != null)
			{
				_originalValue = _toggle.isOn;
				_toggle.isOn = isOn.Value;
			}
		}

		public override void OnExit()
		{
			if (!(_toggle == null) && resetOnExit.Value)
			{
				_toggle.isOn = _originalValue;
			}
		}
	}
	[ActionCategory(ActionCategory.UnityObject)]
	[Tooltip("Gets a Component attached to a GameObject and stores it in an Object variable. NOTE: Set the Object variable's Object Type to get a component of that type. E.g., set Object Type to UnityEngine.AudioListener to get the AudioListener component on the camera.")]
	public class GetComponent : FsmStateAction
	{
		[Tooltip("The GameObject that owns the component.")]
		public FsmOwnerDefault gameObject;

		[UIHint(UIHint.Variable)]
		[RequiredField]
		[Tooltip("Store the component in an Object variable.\nNOTE: Set theObject variable's Object Type to get a component of that type. E.g., set Object Type to UnityEngine.AudioListener to get the AudioListener component on the camera.")]
		public FsmObject storeComponent;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			gameObject = null;
			storeComponent = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetComponent();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetComponent();
		}

		private void DoGetComponent()
		{
			if (storeComponent != null)
			{
				GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(gameObject);
				if (!(ownerDefaultTarget == null) && !storeComponent.IsNone)
				{
					storeComponent.Value = ownerDefaultTarget.GetComponent(storeComponent.ObjectType);
				}
			}
		}
	}
	[ActionCategory(ActionCategory.UnityObject)]
	[ActionTarget(typeof(Component), "targetProperty", false)]
	[ActionTarget(typeof(GameObject), "targetProperty", false)]
	[Tooltip("Gets the value of any public property or field on the targeted Unity Object and stores it in a variable. E.g., Drag and drop any component attached to a Game Object to access its properties.")]
	public class GetProperty : FsmStateAction
	{
		public FsmProperty targetProperty;

		public bool everyFrame;

		public override void Reset()
		{
			targetProperty = new FsmProperty
			{
				setProperty = false
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			targetProperty.GetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			targetProperty.GetValue();
		}
	}
	[ActionCategory(ActionCategory.UnityObject)]
	[Tooltip("Sets the value of an Object Variable.")]
	public class SetObjectValue : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmObject objectVariable;

		[RequiredField]
		public FsmObject objectValue;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			objectVariable = null;
			objectValue = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			objectVariable.Value = objectValue.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			objectVariable.Value = objectValue.Value;
		}
	}
	[ActionCategory(ActionCategory.UnityObject)]
	[ActionTarget(typeof(Component), "targetProperty", false)]
	[ActionTarget(typeof(GameObject), "targetProperty", false)]
	[Tooltip("Sets the value of any public property or field on the targeted Unity Object. E.g., Drag and drop any component attached to a Game Object to access its properties.")]
	public class SetProperty : FsmStateAction
	{
		public FsmProperty targetProperty;

		public bool everyFrame;

		public override void Reset()
		{
			targetProperty = new FsmProperty
			{
				setProperty = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			targetProperty.SetValue();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			targetProperty.SetValue();
		}
	}
	[ActionCategory(ActionCategory.Debug)]
	[Tooltip("Logs the value of a Vector2 Variable in the PlayMaker Log Window.")]
	public class DebugVector2 : FsmStateAction
	{
		[Tooltip("Info, Warning, or Error.")]
		public LogLevel logLevel;

		[UIHint(UIHint.Variable)]
		[Tooltip("Prints the value of a Vector2 variable in the PlayMaker log window.")]
		public FsmVector2 vector2Variable;

		public override void Reset()
		{
			logLevel = LogLevel.Info;
			vector2Variable = null;
		}

		public override void OnEnter()
		{
			string text = "None";
			if (!vector2Variable.IsNone)
			{
				text = vector2Variable.Name + ": " + vector2Variable.Value;
			}
			ActionHelpers.DebugLog(base.Fsm, logLevel, text);
			Finish();
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Get Vector2 Length.")]
	public class GetVector2Length : FsmStateAction
	{
		[Tooltip("The Vector2 to get the length from")]
		public FsmVector2 vector2;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Vector2 the length")]
		public FsmFloat storeLength;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2 = null;
			storeLength = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoVectorLength();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVectorLength();
		}

		private void DoVectorLength()
		{
			if (vector2 != null && storeLength != null)
			{
				storeLength.Value = vector2.Value.magnitude;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Get the XY channels of a Vector2 Variable and store them in Float Variables.")]
	public class GetVector2XY : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector2 source")]
		public FsmVector2 vector2Variable;

		[UIHint(UIHint.Variable)]
		[Tooltip("The x component")]
		public FsmFloat storeX;

		[UIHint(UIHint.Variable)]
		[Tooltip("The y component")]
		public FsmFloat storeY;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			storeX = null;
			storeY = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetVector2XYZ();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetVector2XYZ();
		}

		private void DoGetVector2XYZ()
		{
			if (vector2Variable != null)
			{
				if (storeX != null)
				{
					storeX.Value = vector2Variable.Value.x;
				}
				if (storeY != null)
				{
					storeY.Value = vector2Variable.Value.y;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Select a Random Vector2 from a Vector2 array.")]
	public class SelectRandomVector2 : FsmStateAction
	{
		[Tooltip("The array of Vectors and respective weights")]
		[CompoundArray("Vectors", "Vector", "Weight")]
		public FsmVector2[] vector2Array;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The picked vector2")]
		public FsmVector2 storeVector2;

		public override void Reset()
		{
			vector2Array = new FsmVector2[3];
			weights = new FsmFloat[3] { 1f, 1f, 1f };
			storeVector2 = null;
		}

		public override void OnEnter()
		{
			DoSelectRandomColor();
			Finish();
		}

		private void DoSelectRandomColor()
		{
			if (vector2Array != null && vector2Array.Length != 0 && storeVector2 != null)
			{
				int randomWeightedIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				if (randomWeightedIndex != -1)
				{
					storeVector2.Value = vector2Array[randomWeightedIndex].Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Sets the value of a Vector2 Variable.")]
	public class SetVector2Value : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector2 target")]
		public FsmVector2 vector2Variable;

		[RequiredField]
		[Tooltip("The vector2 source")]
		public FsmVector2 vector2Value;

		[Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			vector2Value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector2Variable.Value = vector2Value.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector2Variable.Value = vector2Value.Value;
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Sets the XY channels of a Vector2 Variable. To leave any channel unchanged, set variable to 'None'.")]
	public class SetVector2XY : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector2 target")]
		public FsmVector2 vector2Variable;

		[UIHint(UIHint.Variable)]
		[Tooltip("The vector2 source")]
		public FsmVector2 vector2Value;

		[Tooltip("The x component. Override vector2Value if set")]
		public FsmFloat x;

		[Tooltip("The y component.Override vector2Value if set")]
		public FsmFloat y;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			vector2Value = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetVector2XYZ();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetVector2XYZ();
		}

		private void DoSetVector2XYZ()
		{
			if (vector2Variable != null)
			{
				Vector2 value = vector2Variable.Value;
				if (!vector2Value.IsNone)
				{
					value = vector2Value.Value;
				}
				if (!x.IsNone)
				{
					value.x = x.Value;
				}
				if (!y.IsNone)
				{
					value.y = y.Value;
				}
				vector2Variable.Value = value;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Adds a value to Vector2 Variable.")]
	public class Vector2Add : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector2 target")]
		public FsmVector2 vector2Variable;

		[RequiredField]
		[Tooltip("The vector2 to add")]
		public FsmVector2 addVector;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		[Tooltip("Add the value on a per second bases.")]
		public bool perSecond;

		public override void Reset()
		{
			vector2Variable = null;
			addVector = new FsmVector2
			{
				UseVariable = true
			};
			everyFrame = false;
			perSecond = false;
		}

		public override void OnEnter()
		{
			DoVector2Add();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector2Add();
		}

		private void DoVector2Add()
		{
			if (perSecond)
			{
				vector2Variable.Value += addVector.Value * Time.deltaTime;
			}
			else
			{
				vector2Variable.Value += addVector.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Adds a XY values to Vector2 Variable.")]
	public class Vector2AddXY : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector2 target")]
		public FsmVector2 vector2Variable;

		[Tooltip("The x component to add")]
		public FsmFloat addX;

		[Tooltip("The y component to add")]
		public FsmFloat addY;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		[Tooltip("Add the value on a per second bases.")]
		public bool perSecond;

		public override void Reset()
		{
			vector2Variable = null;
			addX = 0f;
			addY = 0f;
			everyFrame = false;
			perSecond = false;
		}

		public override void OnEnter()
		{
			DoVector2AddXYZ();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector2AddXYZ();
		}

		private void DoVector2AddXYZ()
		{
			Vector2 vector = new Vector2(addX.Value, addY.Value);
			if (perSecond)
			{
				vector2Variable.Value += vector * Time.deltaTime;
			}
			else
			{
				vector2Variable.Value += vector;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Clamps the Magnitude of Vector2 Variable.")]
	public class Vector2ClampMagnitude : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Vector2")]
		public FsmVector2 vector2Variable;

		[RequiredField]
		[Tooltip("The maximum Magnitude")]
		public FsmFloat maxLength;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			maxLength = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoVector2ClampMagnitude();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector2ClampMagnitude();
		}

		private void DoVector2ClampMagnitude()
		{
			vector2Variable.Value = Vector2.ClampMagnitude(vector2Variable.Value, maxLength.Value);
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Use a high pass filter to isolate sudden changes in a Vector2 Variable.")]
	public class Vector2HighPassFilter : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Vector2 Variable to filter. Should generally come from some constantly updated input.")]
		public FsmVector2 vector2Variable;

		[Tooltip("Determines how much influence new changes have.")]
		public FsmFloat filteringFactor;

		private Vector2 filteredVector;

		public override void Reset()
		{
			vector2Variable = null;
			filteringFactor = 0.1f;
		}

		public override void OnEnter()
		{
			filteredVector = new Vector2(vector2Variable.Value.x, vector2Variable.Value.y);
		}

		public override void OnUpdate()
		{
			filteredVector.x = vector2Variable.Value.x - (vector2Variable.Value.x * filteringFactor.Value + filteredVector.x * (1f - filteringFactor.Value));
			filteredVector.y = vector2Variable.Value.y - (vector2Variable.Value.y * filteringFactor.Value + filteredVector.y * (1f - filteringFactor.Value));
			vector2Variable.Value = new Vector2(filteredVector.x, filteredVector.y);
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Interpolates between 2 Vector2 values over a specified Time.")]
	public class Vector2Interpolate : FsmStateAction
	{
		[Tooltip("The interpolation type")]
		public InterpolationType mode;

		[RequiredField]
		[Tooltip("The vector to interpolate from")]
		public FsmVector2 fromVector;

		[RequiredField]
		[Tooltip("The vector to interpolate to")]
		public FsmVector2 toVector;

		[RequiredField]
		[Tooltip("the interpolate time")]
		public FsmFloat time;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("the interpolated result")]
		public FsmVector2 storeResult;

		[Tooltip("This event is fired when the interpolation is done.")]
		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		public override void Reset()
		{
			mode = InterpolationType.Linear;
			fromVector = new FsmVector2
			{
				UseVariable = true
			};
			toVector = new FsmVector2
			{
				UseVariable = true
			};
			time = 1f;
			storeResult = null;
			finishEvent = null;
			realTime = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			if (storeResult == null)
			{
				Finish();
			}
			else
			{
				storeResult.Value = fromVector.Value;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			float num = currentTime / time.Value;
			InterpolationType interpolationType = mode;
			if (interpolationType != 0 && interpolationType == InterpolationType.EaseInOut)
			{
				num = Mathf.SmoothStep(0f, 1f, num);
			}
			storeResult.Value = Vector2.Lerp(fromVector.Value, toVector.Value, num);
			if (num >= 1f)
			{
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Reverses the direction of a Vector2 Variable. Same as multiplying by -1.")]
	public class Vector2Invert : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector to invert")]
		public FsmVector2 vector2Variable;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector2Variable.Value *= -1f;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector2Variable.Value *= -1f;
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Linearly interpolates between 2 vectors.")]
	public class Vector2Lerp : FsmStateAction
	{
		[RequiredField]
		[Tooltip("First Vector.")]
		public FsmVector2 fromVector;

		[RequiredField]
		[Tooltip("Second Vector.")]
		public FsmVector2 toVector;

		[RequiredField]
		[Tooltip("Interpolate between From Vector and ToVector by this amount. Value is clamped to 0-1 range. 0 = From Vector; 1 = To Vector; 0.5 = half way between.")]
		public FsmFloat amount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in this vector variable.")]
		public FsmVector2 storeResult;

		[Tooltip("Repeat every frame. Useful if any of the values are changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			fromVector = new FsmVector2
			{
				UseVariable = true
			};
			toVector = new FsmVector2
			{
				UseVariable = true
			};
			storeResult = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoVector2Lerp();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector2Lerp();
		}

		private void DoVector2Lerp()
		{
			storeResult.Value = Vector2.Lerp(fromVector.Value, toVector.Value, amount.Value);
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Use a low pass filter to reduce the influence of sudden changes in a Vector2 Variable.")]
	public class Vector2LowPassFilter : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Vector2 Variable to filter. Should generally come from some constantly updated input")]
		public FsmVector2 vector2Variable;

		[Tooltip("Determines how much influence new changes have. E.g., 0.1 keeps 10 percent of the unfiltered vector and 90 percent of the previously filtered value")]
		public FsmFloat filteringFactor;

		private Vector2 filteredVector;

		public override void Reset()
		{
			vector2Variable = null;
			filteringFactor = 0.1f;
		}

		public override void OnEnter()
		{
			filteredVector = new Vector2(vector2Variable.Value.x, vector2Variable.Value.y);
		}

		public override void OnUpdate()
		{
			filteredVector.x = vector2Variable.Value.x * filteringFactor.Value + filteredVector.x * (1f - filteringFactor.Value);
			filteredVector.y = vector2Variable.Value.y * filteringFactor.Value + filteredVector.y * (1f - filteringFactor.Value);
			vector2Variable.Value = new Vector2(filteredVector.x, filteredVector.y);
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Moves a Vector2 towards a Target. Optionally sends an event when successful.")]
	public class Vector2MoveTowards : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The Vector2 to Move")]
		public FsmVector2 source;

		[Tooltip("A target Vector2 to move towards.")]
		public FsmVector2 target;

		[HasFloatSlider(0f, 20f)]
		[Tooltip("The maximum movement speed. HINT: You can make this a variable to change it over time.")]
		public FsmFloat maxSpeed;

		[HasFloatSlider(0f, 5f)]
		[Tooltip("Distance at which the move is considered finished, and the Finish Event is sent.")]
		public FsmFloat finishDistance;

		[Tooltip("Event to send when the Finish Distance is reached.")]
		public FsmEvent finishEvent;

		public override void Reset()
		{
			source = null;
			target = null;
			maxSpeed = 10f;
			finishDistance = 1f;
			finishEvent = null;
		}

		public override void OnUpdate()
		{
			DoMoveTowards();
		}

		private void DoMoveTowards()
		{
			source.Value = Vector2.MoveTowards(source.Value, target.Value, maxSpeed.Value * Time.deltaTime);
			if ((source.Value - target.Value).magnitude < finishDistance.Value)
			{
				base.Fsm.Event(finishEvent);
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Multiplies a Vector2 variable by a Float.")]
	public class Vector2Multiply : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector to Multiply")]
		public FsmVector2 vector2Variable;

		[RequiredField]
		[Tooltip("The multiplication factor")]
		public FsmFloat multiplyBy;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			multiplyBy = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector2Variable.Value *= multiplyBy.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector2Variable.Value *= multiplyBy.Value;
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Normalizes a Vector2 Variable.")]
	public class Vector2Normalize : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The vector to normalize")]
		public FsmVector2 vector2Variable;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector2Variable.Value = vector2Variable.Value.normalized;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector2Variable.Value = vector2Variable.Value.normalized;
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Performs most possible operations on 2 Vector2: Dot product, Distance, Angle, Add, Subtract, Multiply, Divide, Min, Max")]
	public class Vector2Operator : FsmStateAction
	{
		public enum Vector2Operation
		{
			DotProduct,
			Distance,
			Angle,
			Add,
			Subtract,
			Multiply,
			Divide,
			Min,
			Max
		}

		[RequiredField]
		[Tooltip("The first vector")]
		public FsmVector2 vector1;

		[RequiredField]
		[Tooltip("The second vector")]
		public FsmVector2 vector2;

		[Tooltip("The operation")]
		public Vector2Operation operation = Vector2Operation.Add;

		[UIHint(UIHint.Variable)]
		[Tooltip("The Vector2 result when it applies.")]
		public FsmVector2 storeVector2Result;

		[UIHint(UIHint.Variable)]
		[Tooltip("The float result when it applies")]
		public FsmFloat storeFloatResult;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector1 = null;
			vector2 = null;
			operation = Vector2Operation.Add;
			storeVector2Result = null;
			storeFloatResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoVector2Operator();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector2Operator();
		}

		private void DoVector2Operator()
		{
			Vector2 value = vector1.Value;
			Vector2 value2 = vector2.Value;
			switch (operation)
			{
			case Vector2Operation.DotProduct:
				storeFloatResult.Value = Vector2.Dot(value, value2);
				break;
			case Vector2Operation.Distance:
				storeFloatResult.Value = Vector2.Distance(value, value2);
				break;
			case Vector2Operation.Angle:
				storeFloatResult.Value = Vector2.Angle(value, value2);
				break;
			case Vector2Operation.Add:
				storeVector2Result.Value = value + value2;
				break;
			case Vector2Operation.Subtract:
				storeVector2Result.Value = value - value2;
				break;
			case Vector2Operation.Multiply:
			{
				Vector2 zero2 = Vector2.zero;
				zero2.x = value.x * value2.x;
				zero2.y = value.y * value2.y;
				storeVector2Result.Value = zero2;
				break;
			}
			case Vector2Operation.Divide:
			{
				Vector2 zero = Vector2.zero;
				zero.x = value.x / value2.x;
				zero.y = value.y / value2.y;
				storeVector2Result.Value = zero;
				break;
			}
			case Vector2Operation.Min:
				storeVector2Result.Value = Vector2.Min(value, value2);
				break;
			case Vector2Operation.Max:
				storeVector2Result.Value = Vector2.Max(value, value2);
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Multiplies a Vector2 variable by Time.deltaTime. Useful for frame rate independent motion.")]
	public class Vector2PerSecond : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Vector2")]
		public FsmVector2 vector2Variable;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			vector2Variable.Value *= Time.deltaTime;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector2Variable.Value *= Time.deltaTime;
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Rotates a Vector2 direction from Current towards Target.")]
	public class Vector2RotateTowards : FsmStateAction
	{
		[RequiredField]
		[Tooltip("The current direction. This will be the result of the rotation as well.")]
		public FsmVector2 currentDirection;

		[RequiredField]
		[Tooltip("The direction to reach")]
		public FsmVector2 targetDirection;

		[RequiredField]
		[Tooltip("Rotation speed in degrees per second")]
		public FsmFloat rotateSpeed;

		private Vector3 current;

		private Vector3 target;

		public override void Reset()
		{
			currentDirection = new FsmVector2
			{
				UseVariable = true
			};
			targetDirection = new FsmVector2
			{
				UseVariable = true
			};
			rotateSpeed = 360f;
		}

		public override void OnEnter()
		{
			current = new Vector3(currentDirection.Value.x, currentDirection.Value.y, 0f);
			target = new Vector3(targetDirection.Value.x, targetDirection.Value.y, 0f);
		}

		public override void OnUpdate()
		{
			current.x = currentDirection.Value.x;
			current.y = currentDirection.Value.y;
			current = Vector3.RotateTowards(current, target, rotateSpeed.Value * ((float)Math.PI / 180f) * Time.deltaTime, 1000f);
			currentDirection.Value = new Vector2(current.x, current.y);
		}
	}
	[ActionCategory(ActionCategory.Vector2)]
	[Tooltip("Subtracts a Vector2 value from a Vector2 variable.")]
	public class Vector2Subtract : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("The Vector2 operand")]
		public FsmVector2 vector2Variable;

		[RequiredField]
		[Tooltip("The vector2 to subtract with")]
		public FsmVector2 subtractVector;

		[Tooltip("Repeat every frame")]
		public bool everyFrame;

		public override void Reset()
		{
			vector2Variable = null;
			subtractVector = new FsmVector2
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector2Variable.Value -= subtractVector.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector2Variable.Value -= subtractVector.Value;
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Get the XYZ channels of a Vector3 Variable and store them in Float Variables.")]
	public class GetVector3XYZ : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeX;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeY;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeZ;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			storeX = null;
			storeY = null;
			storeZ = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoGetVector3XYZ();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoGetVector3XYZ();
		}

		private void DoGetVector3XYZ()
		{
			if (vector3Variable != null)
			{
				if (storeX != null)
				{
					storeX.Value = vector3Variable.Value.x;
				}
				if (storeY != null)
				{
					storeY.Value = vector3Variable.Value.y;
				}
				if (storeZ != null)
				{
					storeZ.Value = vector3Variable.Value.z;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Get Vector3 Length.")]
	public class GetVectorLength : FsmStateAction
	{
		public FsmVector3 vector3;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmFloat storeLength;

		public override void Reset()
		{
			vector3 = null;
			storeLength = null;
		}

		public override void OnEnter()
		{
			DoVectorLength();
			Finish();
		}

		private void DoVectorLength()
		{
			if (vector3 != null && storeLength != null)
			{
				storeLength.Value = vector3.Value.magnitude;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Select a Random Vector3 from a Vector3 array.")]
	public class SelectRandomVector3 : FsmStateAction
	{
		[CompoundArray("Vectors", "Vector", "Weight")]
		public FsmVector3[] vector3Array;

		[HasFloatSlider(0f, 1f)]
		public FsmFloat[] weights;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeVector3;

		public override void Reset()
		{
			vector3Array = new FsmVector3[3];
			weights = new FsmFloat[3] { 1f, 1f, 1f };
			storeVector3 = null;
		}

		public override void OnEnter()
		{
			DoSelectRandomColor();
			Finish();
		}

		private void DoSelectRandomColor()
		{
			if (vector3Array != null && vector3Array.Length != 0 && storeVector3 != null)
			{
				int randomWeightedIndex = ActionHelpers.GetRandomWeightedIndex(weights);
				if (randomWeightedIndex != -1)
				{
					storeVector3.Value = vector3Array[randomWeightedIndex].Value;
				}
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Sets the value of a Vector3 Variable.")]
	public class SetVector3Value : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		[RequiredField]
		public FsmVector3 vector3Value;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			vector3Value = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector3Variable.Value = vector3Value.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector3Variable.Value = vector3Value.Value;
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Sets the XYZ channels of a Vector3 Variable. To leave any channel unchanged, set variable to 'None'.")]
	public class SetVector3XYZ : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Value;

		public FsmFloat x;

		public FsmFloat y;

		public FsmFloat z;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			vector3Value = null;
			x = new FsmFloat
			{
				UseVariable = true
			};
			y = new FsmFloat
			{
				UseVariable = true
			};
			z = new FsmFloat
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoSetVector3XYZ();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoSetVector3XYZ();
		}

		private void DoSetVector3XYZ()
		{
			if (vector3Variable != null)
			{
				Vector3 value = vector3Variable.Value;
				if (!vector3Value.IsNone)
				{
					value = vector3Value.Value;
				}
				if (!x.IsNone)
				{
					value.x = x.Value;
				}
				if (!y.IsNone)
				{
					value.y = y.Value;
				}
				if (!z.IsNone)
				{
					value.z = z.Value;
				}
				vector3Variable.Value = value;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Adds a value to Vector3 Variable.")]
	public class Vector3Add : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		[RequiredField]
		public FsmVector3 addVector;

		public bool everyFrame;

		public bool perSecond;

		public override void Reset()
		{
			vector3Variable = null;
			addVector = new FsmVector3
			{
				UseVariable = true
			};
			everyFrame = false;
			perSecond = false;
		}

		public override void OnEnter()
		{
			DoVector3Add();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector3Add();
		}

		private void DoVector3Add()
		{
			if (perSecond)
			{
				vector3Variable.Value += addVector.Value * Time.deltaTime;
			}
			else
			{
				vector3Variable.Value += addVector.Value;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Adds a XYZ values to Vector3 Variable.")]
	public class Vector3AddXYZ : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		public FsmFloat addX;

		public FsmFloat addY;

		public FsmFloat addZ;

		public bool everyFrame;

		public bool perSecond;

		public override void Reset()
		{
			vector3Variable = null;
			addX = 0f;
			addY = 0f;
			addZ = 0f;
			everyFrame = false;
			perSecond = false;
		}

		public override void OnEnter()
		{
			DoVector3AddXYZ();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector3AddXYZ();
		}

		private void DoVector3AddXYZ()
		{
			Vector3 vector = new Vector3(addX.Value, addY.Value, addZ.Value);
			if (perSecond)
			{
				vector3Variable.Value += vector * Time.deltaTime;
			}
			else
			{
				vector3Variable.Value += vector;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Clamps the Magnitude of Vector3 Variable.")]
	public class Vector3ClampMagnitude : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		[RequiredField]
		public FsmFloat maxLength;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			maxLength = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoVector3ClampMagnitude();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector3ClampMagnitude();
		}

		private void DoVector3ClampMagnitude()
		{
			vector3Variable.Value = Vector3.ClampMagnitude(vector3Variable.Value, maxLength.Value);
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Use a high pass filter to isolate sudden changes in a Vector3 Variable. Useful when working with Get Device Acceleration to remove the constant effect of gravity.")]
	public class Vector3HighPassFilter : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Vector3 Variable to filter. Should generally come from some constantly updated input, e.g., acceleration.")]
		public FsmVector3 vector3Variable;

		[Tooltip("Determines how much influence new changes have.")]
		public FsmFloat filteringFactor;

		private Vector3 filteredVector;

		public override void Reset()
		{
			vector3Variable = null;
			filteringFactor = 0.1f;
		}

		public override void OnEnter()
		{
			filteredVector = new Vector3(vector3Variable.Value.x, vector3Variable.Value.y, vector3Variable.Value.z);
		}

		public override void OnUpdate()
		{
			filteredVector.x = vector3Variable.Value.x - (vector3Variable.Value.x * filteringFactor.Value + filteredVector.x * (1f - filteringFactor.Value));
			filteredVector.y = vector3Variable.Value.y - (vector3Variable.Value.y * filteringFactor.Value + filteredVector.y * (1f - filteringFactor.Value));
			filteredVector.z = vector3Variable.Value.z - (vector3Variable.Value.z * filteringFactor.Value + filteredVector.z * (1f - filteringFactor.Value));
			vector3Variable.Value = new Vector3(filteredVector.x, filteredVector.y, filteredVector.z);
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Interpolates between 2 Vector3 values over a specified Time.")]
	public class Vector3Interpolate : FsmStateAction
	{
		public InterpolationType mode;

		[RequiredField]
		public FsmVector3 fromVector;

		[RequiredField]
		public FsmVector3 toVector;

		[RequiredField]
		public FsmFloat time;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 storeResult;

		public FsmEvent finishEvent;

		[Tooltip("Ignore TimeScale")]
		public bool realTime;

		private float startTime;

		private float currentTime;

		public override void Reset()
		{
			mode = InterpolationType.Linear;
			fromVector = new FsmVector3
			{
				UseVariable = true
			};
			toVector = new FsmVector3
			{
				UseVariable = true
			};
			time = 1f;
			storeResult = null;
			finishEvent = null;
			realTime = false;
		}

		public override void OnEnter()
		{
			startTime = FsmTime.RealtimeSinceStartup;
			currentTime = 0f;
			if (storeResult == null)
			{
				Finish();
			}
			else
			{
				storeResult.Value = fromVector.Value;
			}
		}

		public override void OnUpdate()
		{
			if (realTime)
			{
				currentTime = FsmTime.RealtimeSinceStartup - startTime;
			}
			else
			{
				currentTime += Time.deltaTime;
			}
			float num = currentTime / time.Value;
			InterpolationType interpolationType = mode;
			if (interpolationType != 0 && interpolationType == InterpolationType.EaseInOut)
			{
				num = Mathf.SmoothStep(0f, 1f, num);
			}
			storeResult.Value = Vector3.Lerp(fromVector.Value, toVector.Value, num);
			if (num >= 1f)
			{
				if (finishEvent != null)
				{
					base.Fsm.Event(finishEvent);
				}
				Finish();
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Reverses the direction of a Vector3 Variable. Same as multiplying by -1.")]
	public class Vector3Invert : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector3Variable.Value *= -1f;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector3Variable.Value *= -1f;
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Linearly interpolates between 2 vectors.")]
	public class Vector3Lerp : FsmStateAction
	{
		[RequiredField]
		[Tooltip("First Vector.")]
		public FsmVector3 fromVector;

		[RequiredField]
		[Tooltip("Second Vector.")]
		public FsmVector3 toVector;

		[RequiredField]
		[Tooltip("Interpolate between From Vector and ToVector by this amount. Value is clamped to 0-1 range. 0 = From Vector; 1 = To Vector; 0.5 = half way between.")]
		public FsmFloat amount;

		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Store the result in this vector variable.")]
		public FsmVector3 storeResult;

		[Tooltip("Repeat every frame. Useful if any of the values are changing.")]
		public bool everyFrame;

		public override void Reset()
		{
			fromVector = new FsmVector3
			{
				UseVariable = true
			};
			toVector = new FsmVector3
			{
				UseVariable = true
			};
			storeResult = null;
			everyFrame = true;
		}

		public override void OnEnter()
		{
			DoVector3Lerp();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector3Lerp();
		}

		private void DoVector3Lerp()
		{
			storeResult.Value = Vector3.Lerp(fromVector.Value, toVector.Value, amount.Value);
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Use a low pass filter to reduce the influence of sudden changes in a Vector3 Variable. Useful when working with Get Device Acceleration to isolate gravity.")]
	public class Vector3LowPassFilter : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		[Tooltip("Vector3 Variable to filter. Should generally come from some constantly updated input, e.g., acceleration.")]
		public FsmVector3 vector3Variable;

		[Tooltip("Determines how much influence new changes have. E.g., 0.1 keeps 10 percent of the unfiltered vector and 90 percent of the previously filtered value.")]
		public FsmFloat filteringFactor;

		private Vector3 filteredVector;

		public override void Reset()
		{
			vector3Variable = null;
			filteringFactor = 0.1f;
		}

		public override void OnEnter()
		{
			filteredVector = new Vector3(vector3Variable.Value.x, vector3Variable.Value.y, vector3Variable.Value.z);
		}

		public override void OnUpdate()
		{
			filteredVector.x = vector3Variable.Value.x * filteringFactor.Value + filteredVector.x * (1f - filteringFactor.Value);
			filteredVector.y = vector3Variable.Value.y * filteringFactor.Value + filteredVector.y * (1f - filteringFactor.Value);
			filteredVector.z = vector3Variable.Value.z * filteringFactor.Value + filteredVector.z * (1f - filteringFactor.Value);
			vector3Variable.Value = new Vector3(filteredVector.x, filteredVector.y, filteredVector.z);
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Multiplies a Vector3 variable by a Float.")]
	public class Vector3Multiply : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		[RequiredField]
		public FsmFloat multiplyBy;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			multiplyBy = 1f;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector3Variable.Value *= multiplyBy.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector3Variable.Value *= multiplyBy.Value;
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Normalizes a Vector3 Variable.")]
	public class Vector3Normalize : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector3Variable.Value = vector3Variable.Value.normalized;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector3Variable.Value = vector3Variable.Value.normalized;
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Performs most possible operations on 2 Vector3: Dot product, Cross product, Distance, Angle, Project, Reflect, Add, Subtract, Multiply, Divide, Min, Max")]
	public class Vector3Operator : FsmStateAction
	{
		public enum Vector3Operation
		{
			DotProduct,
			CrossProduct,
			Distance,
			Angle,
			Project,
			Reflect,
			Add,
			Subtract,
			Multiply,
			Divide,
			Min,
			Max
		}

		[RequiredField]
		public FsmVector3 vector1;

		[RequiredField]
		public FsmVector3 vector2;

		public Vector3Operation operation = Vector3Operation.Add;

		[UIHint(UIHint.Variable)]
		public FsmVector3 storeVector3Result;

		[UIHint(UIHint.Variable)]
		public FsmFloat storeFloatResult;

		public bool everyFrame;

		public override void Reset()
		{
			vector1 = null;
			vector2 = null;
			operation = Vector3Operation.Add;
			storeVector3Result = null;
			storeFloatResult = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			DoVector3Operator();
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoVector3Operator();
		}

		private void DoVector3Operator()
		{
			Vector3 value = vector1.Value;
			Vector3 value2 = vector2.Value;
			switch (operation)
			{
			case Vector3Operation.DotProduct:
				storeFloatResult.Value = Vector3.Dot(value, value2);
				break;
			case Vector3Operation.CrossProduct:
				storeVector3Result.Value = Vector3.Cross(value, value2);
				break;
			case Vector3Operation.Distance:
				storeFloatResult.Value = Vector3.Distance(value, value2);
				break;
			case Vector3Operation.Angle:
				storeFloatResult.Value = Vector3.Angle(value, value2);
				break;
			case Vector3Operation.Project:
				storeVector3Result.Value = Vector3.Project(value, value2);
				break;
			case Vector3Operation.Reflect:
				storeVector3Result.Value = Vector3.Reflect(value, value2);
				break;
			case Vector3Operation.Add:
				storeVector3Result.Value = value + value2;
				break;
			case Vector3Operation.Subtract:
				storeVector3Result.Value = value - value2;
				break;
			case Vector3Operation.Multiply:
			{
				Vector3 zero2 = Vector3.zero;
				zero2.x = value.x * value2.x;
				zero2.y = value.y * value2.y;
				zero2.z = value.z * value2.z;
				storeVector3Result.Value = zero2;
				break;
			}
			case Vector3Operation.Divide:
			{
				Vector3 zero = Vector3.zero;
				zero.x = value.x / value2.x;
				zero.y = value.y / value2.y;
				zero.z = value.z / value2.z;
				storeVector3Result.Value = zero;
				break;
			}
			case Vector3Operation.Min:
				storeVector3Result.Value = Vector3.Min(value, value2);
				break;
			case Vector3Operation.Max:
				storeVector3Result.Value = Vector3.Max(value, value2);
				break;
			}
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Multiplies a Vector3 variable by Time.deltaTime. Useful for frame rate independent motion.")]
	public class Vector3PerSecond : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector3Variable.Value *= Time.deltaTime;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector3Variable.Value *= Time.deltaTime;
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Rotates a Vector3 direction from Current towards Target.")]
	public class Vector3RotateTowards : FsmStateAction
	{
		[RequiredField]
		public FsmVector3 currentDirection;

		[RequiredField]
		public FsmVector3 targetDirection;

		[RequiredField]
		[Tooltip("Rotation speed in degrees per second")]
		public FsmFloat rotateSpeed;

		[RequiredField]
		[Tooltip("Max Magnitude per second")]
		public FsmFloat maxMagnitude;

		public override void Reset()
		{
			currentDirection = new FsmVector3
			{
				UseVariable = true
			};
			targetDirection = new FsmVector3
			{
				UseVariable = true
			};
			rotateSpeed = 360f;
			maxMagnitude = 1f;
		}

		public override void OnUpdate()
		{
			currentDirection.Value = Vector3.RotateTowards(currentDirection.Value, targetDirection.Value, rotateSpeed.Value * ((float)Math.PI / 180f) * Time.deltaTime, maxMagnitude.Value);
		}
	}
	[ActionCategory(ActionCategory.Vector3)]
	[Tooltip("Subtracts a Vector3 value from a Vector3 variable.")]
	public class Vector3Subtract : FsmStateAction
	{
		[RequiredField]
		[UIHint(UIHint.Variable)]
		public FsmVector3 vector3Variable;

		[RequiredField]
		public FsmVector3 subtractVector;

		public bool everyFrame;

		public override void Reset()
		{
			vector3Variable = null;
			subtractVector = new FsmVector3
			{
				UseVariable = true
			};
			everyFrame = false;
		}

		public override void OnEnter()
		{
			vector3Variable.Value -= subtractVector.Value;
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			vector3Variable.Value -= subtractVector.Value;
		}
	}
	[ActionCategory(ActionCategory.Audio)]
	[Tooltip("Adjusts the currently playing background music.")]
	public class ChangeMusic : FsmStateAction
	{
		public int themeIndex;

		[RequiredField]
		[Tooltip("Fade time in seconds.")]
		public float fadeTime = 2f;

		public bool isOneShot;

		public LockType[] trackStates;

		public MusicCommand musicAction = MusicCommand.Modify;

		public override void OnEnter()
		{
			if (themeIndex < 0 && musicAction != MusicCommand.Stop)
			{
				UnityEngine.Debug.LogError("No audio theme selected");
				return;
			}
			if (MusicManager.Instance == null)
			{
				UnityEngine.Debug.LogError("Music Manager must be in the scene");
				return;
			}
			if (MusicManager.Instance.musicDatabase == null)
			{
				UnityEngine.Debug.LogError("Missing music database");
				return;
			}
			switch (musicAction)
			{
			case MusicCommand.PlayFromBeginning:
			{
				MusicTrack track = MusicManager.Instance.musicDatabase.GetTrack(themeIndex);
				List<AudioClip> list = new List<AudioClip>();
				for (int j = 0; j < track.clips.Length; j++)
				{
					if (trackStates[j] == LockType.Enabled)
					{
						list.Add(track.clips[j]);
					}
				}
				MusicManager.Stop(fadeTime);
				MusicManager.Play(track, fadeTime, list, isOneShot);
				break;
			}
			case MusicCommand.Stop:
				MusicManager.Stop(fadeTime);
				break;
			case MusicCommand.Modify:
			{
				MusicTrack track = MusicManager.Instance.musicDatabase.GetTrack(themeIndex);
				if (MusicManager.ActiveTrack != track)
				{
					break;
				}
				for (int i = 0; i < track.clips.Length; i++)
				{
					switch (trackStates[i])
					{
					case LockType.Enabled:
						MusicManager.UnMuteTrack(i, fadeTime);
						break;
					case LockType.Disabled:
						MusicManager.MuteTrack(i, fadeTime);
						break;
					}
				}
				break;
			}
			}
		}
	}
	public enum MusicCommand
	{
		PlayFromBeginning,
		Stop,
		Modify
	}
	public enum LockType
	{
		Enabled,
		Disabled,
		NoChange
	}
}
namespace FluffyUnderware.Curvy.PlayMaker
{
	[AddComponentMenu("Curvy/PlayMaker/Component Proxy")]
	[HelpUrl("https://curvyeditor.com/doclink/pmplaymakercurvycomponentproxy")]
	public class PlayMakerCurvyComponentProxy : MonoBehaviour
	{
		public enum PlayMakerProxyEventTarget
		{
			Owner,
			GameObject,
			BroadCastAll,
			FsmComponent
		}

		[Serializable]
		public struct FsmEventSetup
		{
			public PlayMakerProxyEventTarget target;

			public GameObject gameObject;

			public PlayMakerFSM fsmComponent;

			public string customEventName;

			public string builtInEventName;

			public bool debug;

			public string EventString
			{
				get
				{
					if (!IsCustomEvent)
					{
						return builtInEventName;
					}
					return customEventName;
				}
			}

			public bool IsCustomEvent => !string.IsNullOrEmpty(customEventName);

			public bool IsSetup => target switch
			{
				PlayMakerProxyEventTarget.GameObject => gameObject != null, 
				PlayMakerProxyEventTarget.FsmComponent => fsmComponent != null, 
				_ => true, 
			};

			public FsmEventSetup(string eventName)
			{
				target = PlayMakerProxyEventTarget.Owner;
				gameObject = null;
				fsmComponent = null;
				customEventName = null;
				builtInEventName = eventName;
				debug = fsmComponent;
			}
		}

		public OwnerDefaultOption CurvyTargetOption;

		public GameObject CurvyTarget;

		public FsmEventSetup SplineOnRefresh = new FsmEventSetup("CURVY / ON SPLINE REFRESH");

		private FsmEventTarget splineOnRefreshEventTarget;

		public FsmEventSetup CGOnRefresh = new FsmEventSetup("CURVY / ON GENERATOR REFRESH");

		private FsmEventTarget cgOnRefreshEventTarget;

		public FsmEventSetup SplineControllerOnCPReached = new FsmEventSetup("CURVY / ON CP REACHED");

		private FsmEventTarget splineControllerOnCPreachedTarget;

		public static CurvySplineMoveEventArgs _OnCPReachedEventData;

		private void Start()
		{
			CurvySpline component = CurvyTarget.GetComponent<CurvySpline>();
			if ((bool)component)
			{
				hookSplineEvents(component);
			}
			CurvyGenerator component2 = CurvyTarget.GetComponent<CurvyGenerator>();
			if ((bool)component2)
			{
				hookCGEvents(component2);
			}
			SplineController component3 = CurvyTarget.GetComponent<SplineController>();
			if ((bool)component3)
			{
				hookControllerEvents(component3);
			}
		}

		public bool DoesTargetImplementsEvent(FsmEventSetup fsmEventSetup)
		{
			string eventString = fsmEventSetup.EventString;
			if (fsmEventSetup.target == PlayMakerProxyEventTarget.BroadCastAll)
			{
				return FsmEvent.IsEventGlobal(eventString);
			}
			if (fsmEventSetup.target == PlayMakerProxyEventTarget.FsmComponent)
			{
				return PlayMakerUtils.DoesFsmImplementsEvent(fsmEventSetup.fsmComponent, eventString);
			}
			if (fsmEventSetup.target == PlayMakerProxyEventTarget.GameObject)
			{
				return PlayMakerUtils.DoesGameObjectImplementsEvent(fsmEventSetup.gameObject, eventString);
			}
			if (fsmEventSetup.target == PlayMakerProxyEventTarget.Owner)
			{
				return PlayMakerUtils.DoesGameObjectImplementsEvent(base.gameObject, eventString);
			}
			return false;
		}

		private void setupEventTarget(FsmEventSetup fsmEventSetup, ref FsmEventTarget fsmEventTarget)
		{
			if (fsmEventTarget == null)
			{
				fsmEventTarget = new FsmEventTarget();
			}
			if (fsmEventSetup.target == PlayMakerProxyEventTarget.BroadCastAll)
			{
				fsmEventTarget.target = FsmEventTarget.EventTarget.BroadcastAll;
				fsmEventTarget.excludeSelf = false;
			}
			else if (fsmEventSetup.target == PlayMakerProxyEventTarget.FsmComponent)
			{
				fsmEventTarget.target = FsmEventTarget.EventTarget.FSMComponent;
				fsmEventTarget.fsmComponent = fsmEventSetup.fsmComponent;
			}
			else if (fsmEventSetup.target == PlayMakerProxyEventTarget.GameObject)
			{
				fsmEventTarget.target = FsmEventTarget.EventTarget.GameObject;
				fsmEventTarget.gameObject = new FsmOwnerDefault();
				fsmEventTarget.gameObject.OwnerOption = OwnerDefaultOption.SpecifyGameObject;
				fsmEventTarget.gameObject.GameObject.Value = fsmEventSetup.gameObject;
			}
			else if (fsmEventSetup.target == PlayMakerProxyEventTarget.Owner)
			{
				fsmEventTarget.ResetParameters();
				fsmEventTarget.target = FsmEventTarget.EventTarget.GameObject;
				fsmEventTarget.gameObject = new FsmOwnerDefault();
				fsmEventTarget.gameObject.OwnerOption = OwnerDefaultOption.SpecifyGameObject;
				fsmEventTarget.gameObject.GameObject.Value = base.gameObject;
			}
		}

		private void FirePlayMakerEvent(FsmEventSetup fsmEventSetup, FsmEventTarget fsmEventTarget, FsmEventData eventData)
		{
			if (eventData != null)
			{
				Fsm.EventData = eventData;
			}
			fsmEventTarget.excludeSelf = false;
			if (PlayMakerCurvySceneProxy.fsm == null)
			{
				UnityEngine.Debug.LogError("Missing 'PlayMaker Curvy' prefab in scene");
				return;
			}
			Fsm fsm = PlayMakerCurvySceneProxy.fsm.Fsm;
			if (fsmEventSetup.debug)
			{
				UnityEngine.Debug.Log("Fire event: " + fsmEventSetup.EventString);
			}
			fsm.Event(fsmEventTarget, fsmEventSetup.EventString);
		}

		private void hookSplineEvents(CurvySpline spline)
		{
			if (SplineOnRefresh.IsSetup)
			{
				spline.OnRefresh.AddListener(onSplineRefresh);
				setupEventTarget(SplineOnRefresh, ref splineOnRefreshEventTarget);
			}
		}

		private void onSplineRefresh(CurvySplineEventArgs e)
		{
			FsmEventData eventData = new FsmEventData();
			FirePlayMakerEvent(SplineOnRefresh, splineOnRefreshEventTarget, eventData);
		}

		private void hookCGEvents(CurvyGenerator cg)
		{
			if (CGOnRefresh.IsSetup)
			{
				cg.OnRefresh.AddListener(onCGRefresh);
				setupEventTarget(CGOnRefresh, ref cgOnRefreshEventTarget);
			}
		}

		private void onCGRefresh(CurvyCGEventArgs e)
		{
			FsmEventData eventData = new FsmEventData();
			FirePlayMakerEvent(CGOnRefresh, cgOnRefreshEventTarget, eventData);
		}

		private void hookControllerEvents(SplineController c)
		{
			if (SplineControllerOnCPReached.IsSetup)
			{
				c.OnControlPointReached.AddListener(onControllerCPReached);
				setupEventTarget(SplineControllerOnCPReached, ref splineControllerOnCPreachedTarget);
			}
		}

		private void onControllerCPReached(CurvySplineMoveEventArgs e)
		{
			FsmEventData eventData = new FsmEventData();
			_OnCPReachedEventData = e;
			FirePlayMakerEvent(SplineControllerOnCPReached, splineControllerOnCPreachedTarget, eventData);
			e = _OnCPReachedEventData;
		}
	}
	public class PlayMakerCurvySceneProxy : MonoBehaviour
	{
		public static PlayMakerFSM fsm;

		private void Start()
		{
			fsm = GetComponent<PlayMakerFSM>();
		}
	}
}
namespace FluffyUnderware.Curvy.PlayMaker.Actions
{
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Align a GameObject to a Curvy Spline ")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvyaligntospline")]
	public class CurvyAlignToSpline : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The GameObject to align")]
		public FsmOwnerDefault GameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline or SplineGroup to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmGameObject Spline;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("Position on spline (TF or distance)")]
		public FsmFloat Position;

		public CurvyPositionMode PositionMode;

		public CurvyClamping Clamping;

		public FsmBool UseCache;

		[HutongGames.PlayMaker.Tooltip("Set Orientation?")]
		public bool SetOrientation;

		public Space Space;

		[HutongGames.PlayMaker.Tooltip("Repeat every frame.")]
		public bool everyFrame;

		public PlayMakerActionsUtils.EveryFrameUpdateSelector updateType;

		private CurvySpline mSpline;

		public override void OnPreprocess()
		{
			if (updateType == PlayMakerActionsUtils.EveryFrameUpdateSelector.OnFixedUpdate)
			{
				base.Fsm.HandleFixedUpdate = true;
			}
			if (updateType == PlayMakerActionsUtils.EveryFrameUpdateSelector.OnLateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			if (!Spline.IsNone)
			{
				mSpline = Spline.Value.GetComponent<CurvySpline>();
			}
			if ((bool)mSpline && !everyFrame)
			{
				DoInterpolate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if ((bool)mSpline && updateType == PlayMakerActionsUtils.EveryFrameUpdateSelector.OnUpdate)
			{
				DoInterpolate();
			}
		}

		public override void OnLateUpdate()
		{
			if ((bool)mSpline && updateType == PlayMakerActionsUtils.EveryFrameUpdateSelector.OnLateUpdate)
			{
				DoInterpolate();
			}
		}

		public override void OnFixedUpdate()
		{
			if ((bool)mSpline && updateType == PlayMakerActionsUtils.EveryFrameUpdateSelector.OnFixedUpdate)
			{
				DoInterpolate();
			}
		}

		private void DoInterpolate()
		{
			if (!mSpline.IsInitialized)
			{
				return;
			}
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if (!ownerDefaultTarget)
			{
				return;
			}
			float tf = ((PositionMode == CurvyPositionMode.Relative) ? CurvyUtility.ClampTF(Position.Value, Clamping) : mSpline.DistanceToTF(Position.Value, Clamping));
			Vector3 vector = (UseCache.Value ? mSpline.InterpolateFast(tf) : mSpline.Interpolate(tf));
			if (Space == Space.Self)
			{
				ownerDefaultTarget.transform.localPosition = vector;
				if (SetOrientation)
				{
					ownerDefaultTarget.transform.localRotation = mSpline.GetOrientationFast(tf);
				}
			}
			else
			{
				ownerDefaultTarget.transform.position = mSpline.transform.TransformPoint(vector);
				ownerDefaultTarget.transform.localRotation = mSpline.transform.rotation * mSpline.GetOrientationFast(tf);
			}
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			Spline = null;
			SetOrientation = true;
			UseCache = false;
			Position = 0f;
			Space = Space.World;
			PositionMode = CurvyPositionMode.Relative;
			Clamping = CurvyClamping.Clamp;
			everyFrame = false;
			updateType = PlayMakerActionsUtils.EveryFrameUpdateSelector.OnUpdate;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Send a command to a CurvyController. This is a convenience shortcut for the CallMethod action!")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvycallcontrollermethod")]
	public class CurvyCallControllerMethod : FsmStateAction
	{
		public enum Methods
		{
			Stop,
			Play
		}

		[ActionSection("Source")]
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Controller")]
		[CheckForComponent(typeof(CurvyController))]
		public FsmOwnerDefault GameObject;

		public Methods Command;

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if (!(ownerDefaultTarget != null))
			{
				return;
			}
			CurvyController component = ownerDefaultTarget.GetComponent<CurvyController>();
			if ((bool)component)
			{
				switch (Command)
				{
				case Methods.Stop:
					component.Stop();
					break;
				case Methods.Play:
					component.Play();
					break;
				}
			}
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Delete all spline Control Points")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvyclearspline")]
	public class CurvyClearSpline : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmOwnerDefault GameObject;

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				CurvySpline component = ownerDefaultTarget.GetComponent<CurvySpline>();
				if ((bool)component)
				{
					component.Clear();
					component.Refresh();
				}
			}
			Finish();
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Creates a Curvy spline")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvycreatespline")]
	public class CurvyCreateSpline : FsmStateAction
	{
		public CurvyInterpolation Interpolation;

		[HutongGames.PlayMaker.Tooltip("Close the spline?")]
		public FsmBool CloseSpline;

		[HutongGames.PlayMaker.Tooltip("Automatic end tangents?")]
		public FsmBool AutoEndTangents;

		[HutongGames.PlayMaker.Tooltip("Granularity of internal approximation")]
		public FsmInt CacheDensity;

		[HutongGames.PlayMaker.Tooltip("How the Up-Vector should be calculated")]
		public CurvyOrientation Orientation;

		[HutongGames.PlayMaker.Tooltip("Automatically refresh when a Control Point position changed")]
		public FsmBool AutoRefresh;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Optionally store the created spline object")]
		public FsmGameObject storeObject;

		public override void OnEnter()
		{
			CurvySpline curvySpline = CurvySpline.Create();
			curvySpline.Closed = CloseSpline.Value;
			curvySpline.AutoEndTangents = AutoEndTangents.Value;
			curvySpline.CacheDensity = CacheDensity.Value;
			curvySpline.Orientation = Orientation;
			storeObject.Value = curvySpline.gameObject;
			Finish();
		}

		public override void Reset()
		{
			base.Reset();
			CloseSpline = true;
			AutoEndTangents = true;
			CacheDensity = 25;
			Orientation = CurvyOrientation.Dynamic;
			AutoRefresh = true;
			storeObject = null;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Delete spline Control Points")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvydeletecontrolpoints")]
	public class CurvyDeleteControlPoints : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmOwnerDefault GameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The start Control Point Index to delete")]
		public FsmInt StartIndex;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The number of Control Points to delete")]
		public FsmInt Count;

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				CurvySpline component = ownerDefaultTarget.GetComponent<CurvySpline>();
				if ((bool)component && !StartIndex.IsNone && !Count.IsNone && Count.Value > 0)
				{
					for (int i = 0; i < Count.Value; i++)
					{
						component.Delete(component.ControlPointsList[StartIndex.Value]);
					}
					component.Refresh();
				}
			}
			Finish();
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			StartIndex = 0;
			Count = 1;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Gets a Control Point or Segment GameObject")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvygetcontrolpoint")]
	public class CurvyGetControlPoint : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmOwnerDefault GameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("Index of Control Point or Segment")]
		public FsmInt Index;

		[HutongGames.PlayMaker.Tooltip("Whether to retrieve Segments or Control Points")]
		public FsmBool GetSegment;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Control Point")]
		public FsmGameObject StoreObject;

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				CurvySpline component = ownerDefaultTarget.GetComponent<CurvySpline>();
				if ((bool)component)
				{
					if (GetSegment.Value)
					{
						if (component.Count > 0)
						{
							StoreObject.Value = component[Mathf.Clamp(Index.Value, 0, component.Count - 1)].gameObject;
						}
					}
					else if (component.ControlPointCount > 0)
					{
						StoreObject.Value = component.ControlPointsList[Mathf.Clamp(Index.Value, 0, component.ControlPointCount - 1)].gameObject;
					}
				}
			}
			Finish();
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			StoreObject = new FsmGameObject
			{
				UseVariable = true
			};
			GetSegment = false;
			Index = 0;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Get Spline Event data")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvygetcontrolpointeventdata")]
	public class CurvyGetControlPointEventData : CurvyGetSplineEventData
	{
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Control Point")]
		public FsmObject StoreControlPoint;

		protected override void getData(CurvySplineMoveEventArgs e)
		{
			base.getData(e);
			if (e != null && !StoreControlPoint.IsNone)
			{
				StoreControlPoint.Value = e.ControlPoint;
			}
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Get data from a spline point nearest to a given point")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvygetnearestpoint")]
	public class CurvyGetNearestPoint : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline or SplineGroup to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmOwnerDefault GameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The known point in space")]
		public FsmVector3 SourcePoint;

		public Space SourceSpace;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store TF")]
		public FsmFloat StoreTF;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated position")]
		public FsmVector3 StorePosition;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated tangent")]
		public FsmVector3 StoreTangent;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Up-Vector")]
		public FsmVector3 StoreUpVector;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Rotation")]
		public FsmQuaternion StoreRotation;

		public Space Space;

		[HutongGames.PlayMaker.Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[HutongGames.PlayMaker.Tooltip("Perform in LateUpdate.")]
		public bool lateUpdate;

		private CurvySpline mSpline;

		public override void OnPreprocess()
		{
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				mSpline = ownerDefaultTarget.GetComponent<CurvySpline>();
				if ((bool)mSpline && !everyFrame && !lateUpdate)
				{
					DoFindPoint();
				}
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if ((bool)mSpline && !lateUpdate)
			{
				DoFindPoint();
			}
		}

		public override void OnLateUpdate()
		{
			if ((bool)mSpline && lateUpdate)
			{
				DoFindPoint();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoFindPoint()
		{
			if (!mSpline.IsInitialized || !SourcePoint.UseVariable || (!StoreTF.UseVariable && !StorePosition.UseVariable && !StoreUpVector.UseVariable && !StoreRotation.UseVariable))
			{
				return;
			}
			Vector3 localPosition = ((Space == Space.Self) ? SourcePoint.Value : mSpline.transform.InverseTransformPoint(SourcePoint.Value));
			float nearestPointTF = mSpline.GetNearestPointTF(localPosition);
			if (StoreTF.UseVariable)
			{
				StoreTF.Value = nearestPointTF;
			}
			if (StorePosition.UseVariable)
			{
				StorePosition.Value = ((Space == Space.Self) ? mSpline.Interpolate(nearestPointTF) : mSpline.transform.TransformPoint(mSpline.Interpolate(nearestPointTF)));
			}
			if (StoreTangent.UseVariable)
			{
				StoreTangent.Value = ((Space == Space.Self) ? mSpline.GetTangent(nearestPointTF) : mSpline.transform.TransformDirection(mSpline.GetTangent(nearestPointTF)));
			}
			if (StoreUpVector.UseVariable)
			{
				StoreUpVector.Value = ((Space == Space.Self) ? mSpline.GetOrientationUpFast(nearestPointTF) : mSpline.transform.TransformDirection(mSpline.GetOrientationUpFast(nearestPointTF)));
			}
			if (StoreRotation.UseVariable)
			{
				if (Space == Space.Self)
				{
					StoreRotation.Value = (StoreUpVector.IsNone ? mSpline.GetOrientationFast(nearestPointTF) : Quaternion.LookRotation(mSpline.GetTangent(nearestPointTF), StoreUpVector.Value));
				}
				else
				{
					StoreRotation.Value = Quaternion.LookRotation(mSpline.transform.TransformDirection(mSpline.GetTangent(nearestPointTF)), mSpline.transform.TransformDirection(mSpline.GetOrientationUpFast(nearestPointTF)));
				}
			}
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			SourcePoint = new FsmVector3
			{
				UseVariable = true
			};
			StoreTF = new FsmFloat
			{
				UseVariable = true
			};
			StorePosition = new FsmVector3
			{
				UseVariable = true
			};
			StoreTangent = new FsmVector3
			{
				UseVariable = true
			};
			StoreUpVector = new FsmVector3
			{
				UseVariable = true
			};
			StoreRotation = new FsmQuaternion
			{
				UseVariable = true
			};
			everyFrame = false;
			lateUpdate = false;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Retrieve or convert several segment values")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvygetsegmentvalue")]
	public class CurvyGetSegmentValue : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline Segment to address")]
		[CheckForComponent(typeof(CurvySplineSegment))]
		public FsmOwnerDefault GameObject;

		[ActionSection("Input")]
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("Input value (F or Distance)")]
		public FsmFloat Input;

		[HutongGames.PlayMaker.Tooltip("Whether Input value is in World Units (Distance) or F")]
		public FsmBool UseWorldUnits;

		[HutongGames.PlayMaker.Tooltip("Use a linear approximation (slightly faster) for position?")]
		public FsmBool UseCache;

		[ActionSection("Based on Input")]
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated position")]
		public FsmVector3 StorePosition;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated tangent")]
		public FsmVector3 StoreTangent;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Up-Vector")]
		public FsmVector3 StoreUpVector;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Rotation")]
		public FsmQuaternion StoreRotation;

		[HutongGames.PlayMaker.Tooltip("Index of the UserValue you're interested in")]
		public FsmInt UserValueIndex;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Scale")]
		public FsmVector3 StoreScale;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the TF")]
		public FsmFloat StoreTF;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Distance")]
		public FsmFloat StoreDistance;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the local F")]
		public FsmFloat StoreSegmentF;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the local Distance")]
		public FsmFloat StoreSegmentDistance;

		[ActionSection("MetaData")]
		public FsmString MetaDataType;

		public FsmObject StoreMetadata;

		[Title("Store Interpolated")]
		public FsmVar StoreInterpolatedMetadata;

		[ActionSection("General")]
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Segment length")]
		public FsmFloat StoreLength;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the SegmentIndex")]
		public FsmInt StoreSegmentIndex;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the ControlPointIndex")]
		public FsmInt StoreControlPointIndex;

		[HutongGames.PlayMaker.Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[HutongGames.PlayMaker.Tooltip("Perform in LateUpdate. This is useful if you want to override the position of objects that are animated or otherwise positioned in Update.")]
		public bool lateUpdate;

		private CurvySplineSegment mSegment;

		public override void OnPreprocess()
		{
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				mSegment = ownerDefaultTarget.GetComponent<CurvySplineSegment>();
				if ((bool)mSegment && !everyFrame && !lateUpdate)
				{
					DoInterpolate();
				}
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if ((bool)mSegment && !lateUpdate)
			{
				DoInterpolate();
			}
		}

		public override void OnLateUpdate()
		{
			if ((bool)mSegment && lateUpdate)
			{
				DoInterpolate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoInterpolate()
		{
			if (!mSegment.Spline.IsInitialized)
			{
				return;
			}
			if (!Input.IsNone)
			{
				Type type = Type.GetType(MetaDataType.Value);
				float num = (UseWorldUnits.Value ? mSegment.DistanceToLocalF(Input.Value) : Input.Value);
				if (StorePosition.UseVariable)
				{
					StorePosition.Value = (UseCache.Value ? mSegment.InterpolateFast(num) : mSegment.Interpolate(num));
				}
				if (StoreTangent.UseVariable)
				{
					StoreTangent.Value = mSegment.GetTangent(num);
				}
				if (StoreUpVector.UseVariable)
				{
					StoreUpVector.Value = mSegment.GetOrientationUpFast(num);
				}
				if (StoreRotation.UseVariable)
				{
					StoreRotation.Value = (StoreUpVector.IsNone ? mSegment.GetOrientationFast(num) : Quaternion.LookRotation(mSegment.GetTangent(num), StoreUpVector.Value));
				}
				if (StoreScale.UseVariable)
				{
					CurvySplineSegment nextControlPoint = mSegment.Spline.GetNextControlPoint(mSegment);
					StoreScale.Value = (nextControlPoint ? Vector3.Lerp(mSegment.transform.lossyScale, nextControlPoint.transform.lossyScale, num) : mSegment.transform.lossyScale);
				}
				if (StoreTF.UseVariable)
				{
					StoreTF.Value = mSegment.LocalFToTF(num);
				}
				if (StoreSegmentDistance.UseVariable)
				{
					StoreSegmentDistance.Value = mSegment.LocalFToDistance(num);
				}
				if (StoreDistance.UseVariable)
				{
					StoreDistance.Value = (StoreSegmentDistance.UseVariable ? (StoreSegmentDistance.Value + mSegment.Distance) : (mSegment.LocalFToDistance(num) + mSegment.Distance));
				}
				if (StoreSegmentF.UseVariable)
				{
					StoreSegmentF.Value = num;
				}
				if (type != null)
				{
					if (!type.IsSubclassOf(typeof(CurvyMetadataBase)))
					{
						UnityEngine.Debug.LogError("Meta data type " + type.FullName + " should be a subclass of CurvyInterpolatableMetadataBase<T>");
					}
					else
					{
						if (StoreMetadata.UseVariable)
						{
							MethodInfo methodInfo = mSegment.GetType().GetMethod("GetMetadata").MakeGenericMethod(type);
							StoreMetadata.Value = (UnityEngine.Object)methodInfo.Invoke(mSegment, new object[1] { false });
						}
						if (StoreInterpolatedMetadata.useVariable)
						{
							Type interpolatableMetadataGenericType = CurvyGetValue.GetInterpolatableMetadataGenericType(type);
							if (interpolatableMetadataGenericType == null)
							{
								UnityEngine.Debug.LogError("Meta data type " + type.FullName + " should be a subclass of CurvyInterpolatableMetadataBase<T>");
							}
							else
							{
								MethodInfo methodInfo2 = mSegment.GetType().GetMethod("GetInterpolatedMetadata").MakeGenericMethod(type, interpolatableMetadataGenericType);
								StoreInterpolatedMetadata.SetValue(methodInfo2.Invoke(mSegment, new object[1] { num }));
							}
						}
					}
				}
			}
			if (StoreLength.UseVariable)
			{
				StoreLength.Value = mSegment.Length;
			}
			if (StoreSegmentIndex.UseVariable)
			{
				StoreSegmentIndex.Value = mSegment.Spline.GetSegmentIndex(mSegment);
			}
			if (StoreControlPointIndex.UseVariable)
			{
				StoreControlPointIndex.Value = mSegment.Spline.GetControlPointIndex(mSegment);
			}
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			UseCache = false;
			UseWorldUnits = false;
			StorePosition = new FsmVector3
			{
				UseVariable = true
			};
			StoreUpVector = new FsmVector3
			{
				UseVariable = true
			};
			StoreRotation = new FsmQuaternion
			{
				UseVariable = true
			};
			UserValueIndex = new FsmInt
			{
				UseVariable = true
			};
			StoreTangent = new FsmVector3
			{
				UseVariable = true
			};
			StoreDistance = new FsmFloat
			{
				UseVariable = true
			};
			StoreTF = new FsmFloat
			{
				UseVariable = true
			};
			StoreSegmentIndex = new FsmInt
			{
				UseVariable = true
			};
			StoreControlPointIndex = new FsmInt
			{
				UseVariable = true
			};
			StoreSegmentDistance = new FsmFloat
			{
				UseVariable = true
			};
			StoreSegmentF = new FsmFloat
			{
				UseVariable = true
			};
			StoreMetadata = new FsmObject
			{
				UseVariable = true
			};
			StoreInterpolatedMetadata = new FsmVar
			{
				useVariable = true
			};
			Input = 0f;
			everyFrame = false;
			lateUpdate = false;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Get Control Point Event Data")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvygetsplineeventdata")]
	public class CurvyGetSplineEventData : FsmStateAction
	{
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Spline")]
		public FsmObject StoreSpline;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Spline's GameObject")]
		public FsmGameObject StoreGameObject;

		public override void OnEnter()
		{
			string eventName = base.State.Fsm.LastTransition.EventName;
			if (eventName == "CURVY / ON CP REACHED")
			{
				getData(PlayMakerCurvyComponentProxy._OnCPReachedEventData);
			}
			Finish();
		}

		protected virtual void getData(CurvySplineMoveEventArgs e)
		{
			if (e != null)
			{
				if (!StoreSpline.IsNone)
				{
					StoreSpline.Value = e.Spline;
				}
				if (!StoreGameObject.IsNone)
				{
					StoreGameObject.Value = e.Spline.gameObject;
				}
			}
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Retrieve or convert several spline values")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvygetvalue")]
	public class CurvyGetValue : FsmStateAction
	{
		[ActionSection("Input")]
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline or SplineGroup to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmOwnerDefault GameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("Input value (TF or Distance)")]
		public FsmFloat Input;

		[HutongGames.PlayMaker.Tooltip("Whether Input value is in World Units (Distance) or TF")]
		public FsmBool UseWorldUnits;

		[HutongGames.PlayMaker.Tooltip("Use a linear approximation (slightly faster) for position?")]
		public FsmBool UseCache;

		[ActionSection("Based on Input")]
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated position")]
		public FsmVector3 StorePosition;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated tangent")]
		public FsmVector3 StoreTangent;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Up-Vector")]
		public FsmVector3 StoreUpVector;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Rotation")]
		public FsmQuaternion StoreRotation;

		[HutongGames.PlayMaker.Tooltip("Index of the UserValue you're interested in")]
		public FsmInt UserValueIndex;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the interpolated Scale")]
		public FsmVector3 StoreScale;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the TF")]
		public FsmFloat StoreTF;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Distance")]
		public FsmFloat StoreDistance;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the Segment")]
		public FsmGameObject StoreSegment;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the local F")]
		public FsmFloat StoreSegmentF;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the local Distance")]
		public FsmFloat StoreSegmentDistance;

		[ActionSection("MetaData")]
		public FsmString MetaDataType;

		public FsmObject StoreMetadata;

		[Title("Store Interpolated")]
		public FsmVar StoreInterpolatedMetadata;

		[ActionSection("General")]
		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the total spline length")]
		public FsmFloat StoreLength;

		[UIHint(UIHint.Variable)]
		[HutongGames.PlayMaker.Tooltip("Store the number of segments or splines (depending on input GameObject)")]
		public FsmInt StoreCount;

		[HutongGames.PlayMaker.Tooltip("Repeat every frame.")]
		public bool everyFrame;

		[HutongGames.PlayMaker.Tooltip("Perform in LateUpdate. This is useful if you want to override the position of objects that are animated or otherwise positioned in Update.")]
		public bool lateUpdate;

		private CurvySpline mSpline;

		public override void OnPreprocess()
		{
			if (lateUpdate)
			{
				base.Fsm.HandleLateUpdate = true;
			}
		}

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				mSpline = ownerDefaultTarget.GetComponent<CurvySpline>();
				if ((bool)mSpline && !everyFrame && !lateUpdate)
				{
					DoInterpolate();
				}
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			if ((bool)mSpline && !lateUpdate)
			{
				DoInterpolate();
			}
		}

		public override void OnLateUpdate()
		{
			if ((bool)mSpline && lateUpdate)
			{
				DoInterpolate();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		private void DoInterpolate()
		{
			if (!mSpline.IsInitialized)
			{
				return;
			}
			Type type = TypeExt.GetLoadedTypes().FirstOrDefault((Type t) => t.FullName == MetaDataType.Value);
			if (!Input.IsNone)
			{
				float num = (UseWorldUnits.Value ? mSpline.DistanceToTF(Input.Value) : Input.Value);
				if (StorePosition.UseVariable)
				{
					StorePosition.Value = (UseCache.Value ? mSpline.InterpolateFast(num) : mSpline.Interpolate(num));
				}
				if (StoreTangent.UseVariable)
				{
					StoreTangent.Value = mSpline.GetTangent(num);
				}
				if (StoreUpVector.UseVariable)
				{
					StoreUpVector.Value = mSpline.GetOrientationUpFast(num);
				}
				if (StoreRotation.UseVariable)
				{
					StoreRotation.Value = (StoreUpVector.IsNone ? mSpline.GetOrientationFast(num) : Quaternion.LookRotation(mSpline.GetTangent(num), StoreUpVector.Value));
				}
				if (StoreScale.UseVariable)
				{
					float localF;
					CurvySplineSegment curvySplineSegment = mSpline.TFToSegment(num, out localF);
					CurvySplineSegment nextControlPoint = curvySplineSegment.Spline.GetNextControlPoint(curvySplineSegment);
					if ((object)curvySplineSegment != null)
					{
						StoreScale.Value = (nextControlPoint ? Vector3.Lerp(curvySplineSegment.transform.lossyScale, nextControlPoint.transform.lossyScale, localF) : curvySplineSegment.transform.lossyScale);
					}
					else
					{
						StoreScale.Value = Vector3.zero;
					}
				}
				if (StoreTF.UseVariable)
				{
					StoreTF.Value = num;
				}
				if (StoreDistance.UseVariable)
				{
					StoreDistance.Value = (UseWorldUnits.Value ? Input.Value : mSpline.TFToDistance(num));
				}
				if (type != null)
				{
					if (!type.IsSubclassOf(typeof(CurvyMetadataBase)))
					{
						UnityEngine.Debug.LogError("Meta data type " + type.FullName + " should be a subclass of CurvyInterpolatableMetadataBase<T>");
					}
					else
					{
						if (StoreMetadata.UseVariable)
						{
							MethodInfo methodInfo = mSpline.GetType().GetMethod("GetMetadata").MakeGenericMethod(type);
							StoreMetadata.Value = (UnityEngine.Object)methodInfo.Invoke(mSpline, new object[1] { num });
						}
						if (StoreInterpolatedMetadata.useVariable)
						{
							Type interpolatableMetadataGenericType = GetInterpolatableMetadataGenericType(type);
							if (interpolatableMetadataGenericType == null)
							{
								UnityEngine.Debug.LogError("Meta data type " + type.FullName + " should be a subclass of CurvyInterpolatableMetadataBase<T>");
							}
							else
							{
								MethodInfo methodInfo2 = mSpline.GetType().GetMethod("GetInterpolatedMetadata").MakeGenericMethod(type, interpolatableMetadataGenericType);
								StoreInterpolatedMetadata.SetValue(methodInfo2.Invoke(mSpline, new object[1] { num }));
							}
						}
					}
				}
				CurvySplineSegment curvySplineSegment2 = null;
				float localF2 = 0f;
				if (StoreSegment.UseVariable)
				{
					curvySplineSegment2 = getSegment(num, out localF2);
					StoreSegment.Value = curvySplineSegment2.gameObject;
				}
				if (StoreSegmentF.UseVariable)
				{
					if (!curvySplineSegment2)
					{
						curvySplineSegment2 = getSegment(num, out localF2);
					}
					StoreSegmentF.Value = localF2;
				}
				if (StoreSegmentDistance.UseVariable)
				{
					if (!curvySplineSegment2)
					{
						curvySplineSegment2 = getSegment(num, out localF2);
					}
					StoreSegmentDistance.Value = curvySplineSegment2.LocalFToDistance(localF2);
				}
			}
			if (StoreLength.UseVariable)
			{
				StoreLength.Value = mSpline.Length;
			}
			if (StoreCount.UseVariable)
			{
				StoreCount.Value = mSpline.Count;
			}
		}

		internal static Type GetInterpolatableMetadataGenericType(Type metaType)
		{
			Type type = metaType;
			Type result = null;
			while (type != typeof(CurvyMetadataBase))
			{
				if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(CurvyInterpolatableMetadataBase<>))
				{
					result = type.GetGenericArguments().Single();
					break;
				}
				type = type.BaseType;
			}
			return result;
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			UseCache = false;
			UseWorldUnits = false;
			StorePosition = new FsmVector3
			{
				UseVariable = true
			};
			StoreUpVector = new FsmVector3
			{
				UseVariable = true
			};
			StoreRotation = new FsmQuaternion
			{
				UseVariable = true
			};
			UserValueIndex = new FsmInt
			{
				UseVariable = true
			};
			StoreTangent = new FsmVector3
			{
				UseVariable = true
			};
			StoreDistance = new FsmFloat
			{
				UseVariable = true
			};
			StoreTF = new FsmFloat
			{
				UseVariable = true
			};
			StoreSegment = new FsmGameObject
			{
				UseVariable = true
			};
			StoreSegmentDistance = new FsmFloat
			{
				UseVariable = true
			};
			StoreSegmentF = new FsmFloat
			{
				UseVariable = true
			};
			StoreLength = new FsmFloat
			{
				UseVariable = true
			};
			StoreCount = new FsmInt
			{
				UseVariable = true
			};
			MetaDataType = new FsmString();
			StoreMetadata = new FsmObject
			{
				UseVariable = true
			};
			StoreInterpolatedMetadata = new FsmVar
			{
				useVariable = true
			};
			Input = 0f;
			everyFrame = false;
			lateUpdate = false;
		}

		private CurvySplineSegment getSegment(float tf, out float localF)
		{
			return mSpline.TFToSegment(tf, out localF);
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Fire an event when the Curvy Spline is fully loaded")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvyinitialize")]
	public class CurvyInitialize : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmOwnerDefault GameObject;

		[HutongGames.PlayMaker.Tooltip("Event to fire when the Curvy spline is fully loaded")]
		public FsmEvent successEvent;

		private CurvySpline _spl;

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				_spl = ownerDefaultTarget.GetComponent<CurvySpline>();
			}
		}

		public override void OnUpdate()
		{
			if ((bool)_spl && _spl.IsInitialized)
			{
				base.Fsm.Event(successEvent);
				Finish();
			}
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			successEvent = FsmEvent.Finished;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Delete spline Control Points")]
	[HelpUrl("https://curvyeditor.com/doclink/pmcurvyinsertcontrolpoints")]
	public class CurvyInsertControlPoints : FsmStateAction
	{
		public enum InsertMode
		{
			Before,
			After
		}

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Spline to address")]
		[CheckForComponent(typeof(CurvySpline))]
		public FsmOwnerDefault GameObject;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The Control Point Index to add before/after")]
		public FsmInt Index;

		public InsertMode Mode = InsertMode.After;

		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("Points to insert")]
		public FsmVector3[] Points;

		public Space Space;

		public override void OnEnter()
		{
			GameObject ownerDefaultTarget = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)ownerDefaultTarget)
			{
				CurvySpline component = ownerDefaultTarget.GetComponent<CurvySpline>();
				if ((bool)component && !Index.IsNone)
				{
					CurvySplineSegment controlPoint = ((Index.Value >= 0 && Index.Value < component.ControlPointCount) ? component.ControlPointsList[Index.Value] : null);
					for (int i = 0; i < Points.Length; i++)
					{
						if (!Points[i].IsNone)
						{
							CurvySplineSegment curvySplineSegment = ((Mode != InsertMode.After) ? component.InsertBefore(controlPoint) : component.InsertAfter(controlPoint));
							if (Space == Space.Self)
							{
								curvySplineSegment.SetLocalPosition(Points[i].Value);
							}
							else
							{
								curvySplineSegment.SetPosition(Points[i].Value);
							}
						}
					}
					component.Refresh();
				}
			}
			Finish();
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			Index = -1;
			Points = new FsmVector3[1];
			Space = Space.Self;
			Mode = InsertMode.After;
		}
	}
	[ActionCategory("Curvy")]
	[HutongGames.PlayMaker.Tooltip("Set the various move properties value of curvy Spline Controller ")]
	public class CurvySplineControllerSetMoveProperties : FsmStateAction
	{
		[RequiredField]
		[HutongGames.PlayMaker.Tooltip("The GameObject with curvy Spline Controller")]
		[CheckForComponent(typeof(CurvyController))]
		public FsmOwnerDefault GameObject;

		[HutongGames.PlayMaker.Tooltip("Move mode")]
		[ObjectType(typeof(CurvyController.MoveModeEnum))]
		public FsmEnum MoveMode;

		[HutongGames.PlayMaker.Tooltip("Move Speed")]
		public FsmFloat Speed;

		[HutongGames.PlayMaker.Tooltip("Clamping mode")]
		[ObjectType(typeof(CurvyClamping))]
		public FsmEnum Clamping;

		[HutongGames.PlayMaker.Tooltip("Repeat every frame.")]
		public bool everyFrame;

		private CurvyController mCurvyController;

		private GameObject go;

		public override void OnEnter()
		{
			go = base.Fsm.GetOwnerDefaultTarget(GameObject);
			if ((bool)go)
			{
				mCurvyController = go.GetComponent<CurvyController>();
			}
			if (!everyFrame)
			{
				DoAction();
			}
			if (!everyFrame)
			{
				Finish();
			}
		}

		public override void OnUpdate()
		{
			DoAction();
		}

		private void DoAction()
		{
			if (!MoveMode.IsNone)
			{
				mCurvyController.MoveMode = (CurvyController.MoveModeEnum)(object)MoveMode.Value;
			}
			if (!Speed.IsNone)
			{
				mCurvyController.Speed = Speed.Value;
			}
			if (!Clamping.IsNone)
			{
				mCurvyController.Clamping = (CurvyClamping)(object)Clamping.Value;
			}
		}

		public override void Reset()
		{
			base.Reset();
			GameObject = null;
			Speed = null;
			everyFrame = false;
		}
	}
}
namespace OculusSampleFramework
{
	public class ColorGrabbable : OVRGrabbable
	{
		public static readonly Color COLOR_GRAB = new Color(1f, 0.5f, 0f, 1f);

		public static readonly Color COLOR_HIGHLIGHT = new Color(1f, 0f, 1f, 1f);

		private Color m_color = Color.black;

		private MeshRenderer[] m_meshRenderers;

		private bool m_highlight;

		public bool Highlight
		{
			get
			{
				return m_highlight;
			}
			set
			{
				m_highlight = value;
				UpdateColor();
			}
		}

		protected void UpdateColor()
		{
			if (base.isGrabbed)
			{
				SetColor(COLOR_GRAB);
			}
			else if (Highlight)
			{
				SetColor(COLOR_HIGHLIGHT);
			}
			else
			{
				SetColor(m_color);
			}
		}

		public override void GrabBegin(OVRGrabber hand, Collider grabPoint)
		{
			base.GrabBegin(hand, grabPoint);
			UpdateColor();
		}

		public override void GrabEnd(Vector3 linearVelocity, Vector3 angularVelocity)
		{
			base.GrabEnd(linearVelocity, angularVelocity);
			UpdateColor();
		}

		private void Awake()
		{
			if (m_grabPoints.Length == 0)
			{
				Collider component = GetComponent<Collider>();
				if (component == null)
				{
					throw new ArgumentException("Grabbables cannot have zero grab points and no collider -- please add a grab point or collider.");
				}
				m_grabPoints = new Collider[1] { component };
				m_meshRenderers = new MeshRenderer[1];
				m_meshRenderers[0] = GetComponent<MeshRenderer>();
			}
			else
			{
				m_meshRenderers = GetComponentsInChildren<MeshRenderer>();
			}
			m_color = new Color(UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), UnityEngine.Random.Range(0.1f, 0.95f), 1f);
			SetColor(m_color);
		}

		private void SetColor(Color color)
		{
			for (int i = 0; i < m_meshRenderers.Length; i++)
			{
				MeshRenderer meshRenderer = m_meshRenderers[i];
				for (int j = 0; j < meshRenderer.materials.Length; j++)
				{
					meshRenderer.materials[j].color = color;
				}
			}
		}
	}
	public class DistanceGrabbable : OVRGrabbable
	{
		public string m_materialColorField;

		private GrabbableCrosshair m_crosshair;

		private GrabManager m_crosshairManager;

		private Renderer m_renderer;

		private MaterialPropertyBlock m_mpb;

		private bool m_inRange;

		private bool m_targeted;

		public bool InRange
		{
			get
			{
				return m_inRange;
			}
			set
			{
				m_inRange = value;
				RefreshCrosshair();
			}
		}

		public bool Targeted
		{
			get
			{
				return m_targeted;
			}
			set
			{
				m_targeted = value;
				RefreshCrosshair();
			}
		}

		protected override void Start()
		{
			base.Start();
			m_crosshair = base.gameObject.GetComponentInChildren<GrabbableCrosshair>();
			m_renderer = base.gameObject.GetComponent<Renderer>();
			m_crosshairManager = UnityEngine.Object.FindObjectOfType<GrabManager>();
			m_mpb = new MaterialPropertyBlock();
			RefreshCrosshair();
			m_renderer.SetPropertyBlock(m_mpb);
		}

		private void RefreshCrosshair()
		{
			if ((bool)m_crosshair)
			{
				if (base.isGrabbed)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else if (!InRange)
				{
					m_crosshair.SetState(GrabbableCrosshair.CrosshairState.Disabled);
				}
				else
				{
					m_crosshair.SetState((!Targeted) ? GrabbableCrosshair.CrosshairState.Enabled : GrabbableCrosshair.CrosshairState.Targeted);
				}
			}
			if (m_materialColorField != null)
			{
				m_renderer.GetPropertyBlock(m_mpb);
				if (base.isGrabbed || !InRange)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorOutOfRange);
				}
				else if (Targeted)
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorHighlighted);
				}
				else
				{
					m_mpb.SetColor(m_materialColorField, m_crosshairManager.OutlineColorInRange);
				}
				m_renderer.SetPropertyBlock(m_mpb);
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class DistanceGrabber : OVRGrabber
	{
		[SerializeField]
		private float m_spherecastRadius;

		[SerializeField]
		private float m_noSnapThreshhold = 0.05f;

		[SerializeField]
		private bool m_useSpherecast;

		[SerializeField]
		public bool m_preventGrabThroughWalls;

		[SerializeField]
		private float m_objectPullVelocity = 10f;

		private float m_objectPullMaxRotationRate = 360f;

		private bool m_movingObjectToHand;

		[SerializeField]
		private float m_maxGrabDistance;

		[SerializeField]
		private int m_grabObjectsInLayer;

		[SerializeField]
		private int m_obstructionLayer;

		private DistanceGrabber m_otherHand;

		protected DistanceGrabbable m_target;

		protected Collider m_targetCollider;

		public bool UseSpherecast
		{
			get
			{
				return m_useSpherecast;
			}
			set
			{
				m_useSpherecast = value;
				GrabVolumeEnable(!m_useSpherecast);
			}
		}

		protected override void Start()
		{
			base.Start();
			Collider componentInChildren = m_player.GetComponentInChildren<Collider>();
			if (componentInChildren != null)
			{
				m_maxGrabDistance = componentInChildren.bounds.size.z * 0.5f + 3f;
			}
			else
			{
				m_maxGrabDistance = 12f;
			}
			if (m_parentHeldObject)
			{
				UnityEngine.Debug.LogError("m_parentHeldObject incompatible with DistanceGrabber. Setting to false.");
				m_parentHeldObject = false;
			}
			DistanceGrabber[] array = UnityEngine.Object.FindObjectsOfType<DistanceGrabber>();
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != this)
				{
					m_otherHand = array[i];
				}
			}
		}

		public override void Update()
		{
			base.Update();
			UnityEngine.Debug.DrawRay(base.transform.position, base.transform.forward, Color.red, 0.1f);
			FindTarget(out var dgOut, out var collOut);
			if (dgOut != m_target)
			{
				if (m_target != null)
				{
					m_target.Targeted = m_otherHand.m_target == m_target;
				}
				m_target = dgOut;
				m_targetCollider = collOut;
				if (m_target != null)
				{
					m_target.Targeted = true;
				}
			}
		}

		protected override void GrabBegin()
		{
			DistanceGrabbable target = m_target;
			Collider targetCollider = m_targetCollider;
			GrabVolumeEnable(enabled: false);
			if (!(target != null))
			{
				return;
			}
			if (target.isGrabbed)
			{
				((DistanceGrabber)target.grabbedBy).OffhandGrabbed(target);
			}
			m_grabbedObj = target;
			m_grabbedObj.GrabBegin(this, targetCollider);
			SetPlayerIgnoreCollision(m_grabbedObj.gameObject, ignore: true);
			m_movingObjectToHand = true;
			m_lastPos = base.transform.position;
			m_lastRot = base.transform.rotation;
			Vector3 vector = targetCollider.ClosestPointOnBounds(m_gripTransform.position);
			if (!m_grabbedObj.snapPosition && !m_grabbedObj.snapOrientation && m_noSnapThreshhold > 0f && (vector - m_gripTransform.position).magnitude < m_noSnapThreshhold)
			{
				Vector3 vector2 = m_grabbedObj.transform.position - base.transform.position;
				m_movingObjectToHand = false;
				vector2 = Quaternion.Inverse(base.transform.rotation) * vector2;
				m_grabbedObjectPosOff = vector2;
				Quaternion grabbedObjectRotOff = Quaternion.Inverse(base.transform.rotation) * m_grabbedObj.transform.rotation;
				m_grabbedObjectRotOff = grabbedObjectRotOff;
				return;
			}
			m_grabbedObjectPosOff = m_gripTransform.localPosition;
			if ((bool)m_grabbedObj.snapOffset)
			{
				Vector3 position = m_grabbedObj.snapOffset.position;
				if (m_controller == OVRInput.Controller.LTouch)
				{
					position.x = 0f - position.x;
				}
				m_grabbedObjectPosOff += position;
			}
			m_grabbedObjectRotOff = m_gripTransform.localRotation;
			if ((bool)m_grabbedObj.snapOffset)
			{
				m_grabbedObjectRotOff = m_grabbedObj.snapOffset.rotation * m_grabbedObjectRotOff;
			}
		}

		protected override void MoveGrabbedObject(Vector3 pos, Quaternion rot, bool forceTeleport = false)
		{
			if (m_grabbedObj == null)
			{
				return;
			}
			Rigidbody grabbedRigidbody = m_grabbedObj.grabbedRigidbody;
			Vector3 vector = pos + rot * m_grabbedObjectPosOff;
			Quaternion quaternion = rot * m_grabbedObjectRotOff;
			if (m_movingObjectToHand)
			{
				float num = m_objectPullVelocity * Time.deltaTime;
				Vector3 vector2 = vector - m_grabbedObj.transform.position;
				if (num * num * 1.1f > vector2.sqrMagnitude)
				{
					m_movingObjectToHand = false;
				}
				else
				{
					vector2.Normalize();
					vector = m_grabbedObj.transform.position + vector2 * num;
					quaternion = Quaternion.RotateTowards(m_grabbedObj.transform.rotation, quaternion, m_objectPullMaxRotationRate * Time.deltaTime);
				}
			}
			grabbedRigidbody.MovePosition(vector);
			grabbedRigidbody.MoveRotation(quaternion);
		}

		private static DistanceGrabbable HitInfoToGrabbable(RaycastHit hitInfo)
		{
			if (hitInfo.collider != null)
			{
				GameObject gameObject = hitInfo.collider.gameObject;
				return gameObject.GetComponent<DistanceGrabbable>() ?? gameObject.GetComponentInParent<DistanceGrabbable>();
			}
			return null;
		}

		protected bool FindTarget(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			float num = float.MaxValue;
			foreach (OVRGrabbable key in m_grabCandidates.Keys)
			{
				DistanceGrabbable distanceGrabbable = key as DistanceGrabbable;
				bool flag = distanceGrabbable != null && distanceGrabbable.InRange && (!distanceGrabbable.isGrabbed || distanceGrabbable.allowOffhandGrab);
				if (flag && m_grabObjectsInLayer >= 0)
				{
					flag = distanceGrabbable.gameObject.layer == m_grabObjectsInLayer;
				}
				if (!flag)
				{
					continue;
				}
				for (int i = 0; i < distanceGrabbable.grabPoints.Length; i++)
				{
					Collider collider = distanceGrabbable.grabPoints[i];
					Vector3 vector = collider.ClosestPointOnBounds(m_gripTransform.position);
					float sqrMagnitude = (m_gripTransform.position - vector).sqrMagnitude;
					if (!(sqrMagnitude < num))
					{
						continue;
					}
					bool flag2 = true;
					if (m_preventGrabThroughWalls)
					{
						Ray ray = default(Ray);
						ray.direction = distanceGrabbable.transform.position - m_gripTransform.position;
						ray.origin = m_gripTransform.position;
						UnityEngine.Debug.DrawRay(ray.origin, ray.direction, Color.red, 0.1f);
						if (Physics.Raycast(ray, out var hitInfo, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore) && (double)(collider.ClosestPointOnBounds(m_gripTransform.position) - m_gripTransform.position).magnitude > (double)hitInfo.distance * 1.1)
						{
							flag2 = false;
						}
					}
					if (flag2)
					{
						num = sqrMagnitude;
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
			}
			if (dgOut == null && m_useSpherecast)
			{
				return FindTargetWithSpherecast(out dgOut, out collOut);
			}
			return dgOut != null;
		}

		protected bool FindTargetWithSpherecast(out DistanceGrabbable dgOut, out Collider collOut)
		{
			dgOut = null;
			collOut = null;
			Ray ray = new Ray(m_gripTransform.position, m_gripTransform.forward);
			int layerMask = ((m_grabObjectsInLayer == -1) ? (-1) : (1 << m_grabObjectsInLayer));
			if (Physics.SphereCast(ray, m_spherecastRadius, out var hitInfo, m_maxGrabDistance, layerMask))
			{
				DistanceGrabbable distanceGrabbable = null;
				Collider collider = null;
				if (hitInfo.collider != null)
				{
					distanceGrabbable = hitInfo.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
					collider = ((distanceGrabbable == null) ? null : hitInfo.collider);
					if ((bool)distanceGrabbable)
					{
						dgOut = distanceGrabbable;
						collOut = collider;
					}
				}
				if (distanceGrabbable != null && m_preventGrabThroughWalls)
				{
					ray.direction = hitInfo.point - m_gripTransform.position;
					dgOut = distanceGrabbable;
					collOut = collider;
					if (Physics.Raycast(ray, out var hitInfo2, m_maxGrabDistance, 1 << m_obstructionLayer, QueryTriggerInteraction.Ignore))
					{
						DistanceGrabbable distanceGrabbable2 = null;
						if (hitInfo.collider != null)
						{
							distanceGrabbable2 = hitInfo2.collider.gameObject.GetComponentInParent<DistanceGrabbable>();
						}
						if (distanceGrabbable2 != distanceGrabbable && hitInfo2.distance < hitInfo.distance)
						{
							dgOut = null;
							collOut = null;
						}
					}
				}
			}
			return dgOut != null;
		}

		protected override void GrabVolumeEnable(bool enabled)
		{
			if (m_useSpherecast)
			{
				enabled = false;
			}
			base.GrabVolumeEnable(enabled);
		}

		protected override void OffhandGrabbed(OVRGrabbable grabbable)
		{
			base.OffhandGrabbed(grabbable);
		}
	}
	public class GrabManager : MonoBehaviour
	{
		private Collider m_grabVolume;

		public Color OutlineColorInRange;

		public Color OutlineColorHighlighted;

		public Color OutlineColorOutOfRange;

		private void OnTriggerEnter(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = true;
			}
		}

		private void OnTriggerExit(Collider otherCollider)
		{
			DistanceGrabbable componentInChildren = otherCollider.GetComponentInChildren<DistanceGrabbable>();
			if ((bool)componentInChildren)
			{
				componentInChildren.InRange = false;
			}
		}
	}
	public class GrabbableCrosshair : MonoBehaviour
	{
		public enum CrosshairState
		{
			Disabled,
			Enabled,
			Targeted
		}

		private CrosshairState m_state;

		private Transform m_centerEyeAnchor;

		[SerializeField]
		private GameObject m_targetedCrosshair;

		[SerializeField]
		private GameObject m_enabledCrosshair;

		private void Start()
		{
			m_centerEyeAnchor = GameObject.Find("CenterEyeAnchor").transform;
		}

		public void SetState(CrosshairState cs)
		{
			m_state = cs;
			switch (cs)
			{
			case CrosshairState.Disabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: false);
				break;
			case CrosshairState.Enabled:
				m_targetedCrosshair.SetActive(value: false);
				m_enabledCrosshair.SetActive(value: true);
				break;
			case CrosshairState.Targeted:
				m_targetedCrosshair.SetActive(value: true);
				m_enabledCrosshair.SetActive(value: false);
				break;
			}
		}

		private void Update()
		{
			if (m_state != 0)
			{
				base.transform.LookAt(m_centerEyeAnchor);
			}
		}
	}
	public class PauseOnInputLoss : MonoBehaviour
	{
		private void Start()
		{
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			Time.timeScale = 0f;
		}

		private void OnInputFocusAcquired()
		{
			Time.timeScale = 1f;
		}
	}
	public class BoneCapsuleTriggerLogic : MonoBehaviour
	{
		public InteractableToolTags ToolTags;

		public HashSet<ColliderZone> CollidersTouchingUs = new HashSet<ColliderZone>();

		private List<ColliderZone> _elementsToCleanUp = new List<ColliderZone>();

		private void OnDisable()
		{
			CollidersTouchingUs.Clear();
		}

		private void Update()
		{
			CleanUpDeadColliders();
		}

		private void OnTriggerEnter(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Add(component);
			}
		}

		private void OnTriggerExit(Collider other)
		{
			ButtonTriggerZone component = other.GetComponent<ButtonTriggerZone>();
			if (component != null && ((uint)component.ParentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
			{
				CollidersTouchingUs.Remove(component);
			}
		}

		private void CleanUpDeadColliders()
		{
			_elementsToCleanUp.Clear();
			foreach (ColliderZone collidersTouchingU in CollidersTouchingUs)
			{
				if (!collidersTouchingU.Collider.gameObject.activeInHierarchy)
				{
					_elementsToCleanUp.Add(collidersTouchingU);
				}
			}
			foreach (ColliderZone item in _elementsToCleanUp)
			{
				CollidersTouchingUs.Remove(item);
			}
		}
	}
	public class ButtonController : Interactable
	{
		public enum ContactTest
		{
			PerpenTest,
			BackwardsPress
		}

		private const float ENTRY_DOT_THRESHOLD = 0.8f;

		private const float PERP_DOT_THRESHOLD = 0.5f;

		[SerializeField]
		private GameObject _proximityZone;

		[SerializeField]
		private GameObject _contactZone;

		[SerializeField]
		private GameObject _actionZone;

		[SerializeField]
		private ContactTest[] _contactTests;

		[SerializeField]
		private Transform _buttonPlaneCenter;

		[SerializeField]
		private bool _makeSureToolIsOnPositiveSide = true;

		[SerializeField]
		private Vector3 _localButtonDirection = Vector3.down;

		[SerializeField]
		private InteractableToolTags[] _allValidToolsTags = new InteractableToolTags[1] { InteractableToolTags.All };

		private int _toolTagsMask;

		private InteractableState _currentButtonState;

		private Dictionary<InteractableTool, InteractableState> _toolToState = new Dictionary<InteractableTool, InteractableState>();

		public override int ValidToolTagsMask => _toolTagsMask;

		public Vector3 LocalButtonDirection => _localButtonDirection;

		protected override void Awake()
		{
			base.Awake();
			InteractableToolTags[] allValidToolsTags = _allValidToolsTags;
			foreach (InteractableToolTags interactableToolTags in allValidToolsTags)
			{
				_toolTagsMask |= (int)interactableToolTags;
			}
			_proximityZoneCollider = _proximityZone.GetComponent<ColliderZone>();
			_contactZoneCollider = _contactZone.GetComponent<ColliderZone>();
			_actionZoneCollider = _actionZone.GetComponent<ColliderZone>();
		}

		private void FireInteractionEventsOnDepth(InteractableCollisionDepth oldDepth, InteractableTool collidingTool, InteractionType interactionType)
		{
			switch (oldDepth)
			{
			case InteractableCollisionDepth.Action:
				OnActionZoneEvent(new ColliderZoneArgs(base.ActionCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Contact:
				OnContactZoneEvent(new ColliderZoneArgs(base.ContactCollider, Time.frameCount, collidingTool, interactionType));
				break;
			case InteractableCollisionDepth.Proximity:
				OnProximityZoneEvent(new ColliderZoneArgs(base.ProximityCollider, Time.frameCount, collidingTool, interactionType));
				break;
			}
		}

		public override void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth)
		{
			bool isFarFieldTool = interactableTool.IsFarFieldTool;
			if (!isFarFieldTool && _toolToState.Keys.Count > 0 && !_toolToState.ContainsKey(interactableTool))
			{
				return;
			}
			InteractableState currentButtonState = _currentButtonState;
			Vector3 vector = base.transform.TransformDirection(_localButtonDirection);
			bool validContact = IsValidContact(interactableTool, vector) || interactableTool.IsFarFieldTool;
			bool toolIsInProximity = newCollisionDepth >= InteractableCollisionDepth.Proximity;
			bool flag = newCollisionDepth == InteractableCollisionDepth.Contact;
			bool flag2 = newCollisionDepth == InteractableCollisionDepth.Action;
			bool flag3 = oldCollisionDepth != newCollisionDepth;
			if (flag3)
			{
				FireInteractionEventsOnDepth(oldCollisionDepth, interactableTool, InteractionType.Exit);
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Enter);
			}
			else
			{
				FireInteractionEventsOnDepth(newCollisionDepth, interactableTool, InteractionType.Stay);
			}
			InteractableState interactableState = currentButtonState;
			if (interactableTool.IsFarFieldTool)
			{
				interactableState = (flag ? InteractableState.ContactState : (flag2 ? InteractableState.ActionState : InteractableState.Default));
			}
			else
			{
				Plane plane = new Plane(-vector, _buttonPlaneCenter.position);
				bool onPositiveSideOfInteractable = !_makeSureToolIsOnPositiveSide || plane.GetSide(interactableTool.InteractionPosition);
				interactableState = GetUpcomingStateNearField(currentButtonState, newCollisionDepth, flag2, flag, toolIsInProximity, validContact, onPositiveSideOfInteractable);
			}
			if (interactableState != 0)
			{
				_toolToState[interactableTool] = interactableState;
			}
			else
			{
				_toolToState.Remove(interactableTool);
			}
			if (isFarFieldTool)
			{
				foreach (InteractableState value in _toolToState.Values)
				{
					if (interactableState < value)
					{
						interactableState = value;
					}
				}
			}
			if (currentButtonState != interactableState)
			{
				_currentButtonState = interactableState;
				InteractionType interactionType = ((!flag3) ? InteractionType.Stay : ((newCollisionDepth == InteractableCollisionDepth.None) ? InteractionType.Exit : InteractionType.Enter));
				ColliderZone collider = ((_currentButtonState == InteractableState.ProximityState) ? base.ProximityCollider : ((_currentButtonState == InteractableState.ContactState) ? base.ContactCollider : ((_currentButtonState == InteractableState.ActionState) ? base.ActionCollider : null)));
				if (InteractableStateChanged != null)
				{
					InteractableStateChanged.Invoke(new InteractableStateArgs(this, interactableTool, _currentButtonState, currentButtonState, new ColliderZoneArgs(collider, Time.frameCount, interactableTool, interactionType)));
				}
			}
		}

		private InteractableState GetUpcomingStateNearField(InteractableState oldState, InteractableCollisionDepth newCollisionDepth, bool toolIsInActionZone, bool toolIsInContactZone, bool toolIsInProximity, bool validContact, bool onPositiveSideOfInteractable)
		{
			InteractableState result = oldState;
			switch (oldState)
			{
			case InteractableState.ActionState:
				if (!toolIsInActionZone)
				{
					result = ((!toolIsInContactZone) ? (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default) : InteractableState.ContactState);
				}
				break;
			case InteractableState.ContactState:
				if (newCollisionDepth < InteractableCollisionDepth.Contact)
				{
					result = (toolIsInProximity ? InteractableState.ProximityState : InteractableState.Default);
				}
				else if (toolIsInActionZone && validContact && onPositiveSideOfInteractable)
				{
					result = InteractableState.ActionState;
				}
				break;
			case InteractableState.ProximityState:
				if (newCollisionDepth < InteractableCollisionDepth.Proximity)
				{
					result = InteractableState.Default;
				}
				else if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				break;
			case InteractableState.Default:
				if (validContact && onPositiveSideOfInteractable && newCollisionDepth > InteractableCollisionDepth.Proximity)
				{
					result = ((newCollisionDepth == InteractableCollisionDepth.Action) ? InteractableState.ActionState : InteractableState.ContactState);
				}
				else if (toolIsInProximity)
				{
					result = InteractableState.ProximityState;
				}
				break;
			}
			return result;
		}

		private bool IsValidContact(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (_contactTests == null || collidingTool.IsFarFieldTool)
			{
				return true;
			}
			ContactTest[] contactTests = _contactTests;
			foreach (ContactTest contactTest in contactTests)
			{
				if (contactTest == ContactTest.BackwardsPress)
				{
					if (!PassEntryTest(collidingTool, buttonDirection))
					{
						return false;
					}
				}
				else if (!PassPerpTest(collidingTool, buttonDirection))
				{
					return false;
				}
			}
			return true;
		}

		private bool PassEntryTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			if (Vector3.Dot(collidingTool.Velocity.normalized, buttonDirection) < 0.8f)
			{
				return false;
			}
			return true;
		}

		private bool PassPerpTest(InteractableTool collidingTool, Vector3 buttonDirection)
		{
			Vector3 vector = collidingTool.ToolTransform.right;
			if (collidingTool.IsRightHandedTool)
			{
				vector = -vector;
			}
			if (Vector3.Dot(vector, buttonDirection) < 0.5f)
			{
				return false;
			}
			return true;
		}
	}
	public class ButtonTriggerZone : MonoBehaviour, ColliderZone
	{
		[SerializeField]
		private GameObject _parentInteractableObj;

		public Collider Collider { get; private set; }

		public Interactable ParentInteractable { get; private set; }

		public InteractableCollisionDepth CollisionDepth
		{
			get
			{
				if (ParentInteractable.ProximityCollider != this)
				{
					if (ParentInteractable.ContactCollider != this)
					{
						if (ParentInteractable.ActionCollider != this)
						{
							return InteractableCollisionDepth.None;
						}
						return InteractableCollisionDepth.Action;
					}
					return InteractableCollisionDepth.Contact;
				}
				return InteractableCollisionDepth.Proximity;
			}
		}

		private void Awake()
		{
			Collider = GetComponent<Collider>();
			ParentInteractable = _parentInteractableObj.GetComponent<Interactable>();
		}
	}
	public interface ColliderZone
	{
		Collider Collider { get; }

		Interactable ParentInteractable { get; }

		InteractableCollisionDepth CollisionDepth { get; }
	}
	public class ColliderZoneArgs : EventArgs
	{
		public readonly ColliderZone Collider;

		public readonly float FrameTime;

		public readonly InteractableTool CollidingTool;

		public readonly InteractionType InteractionT;

		public ColliderZoneArgs(ColliderZone collider, float frameTime, InteractableTool collidingTool, InteractionType interactionType)
		{
			Collider = collider;
			FrameTime = frameTime;
			CollidingTool = collidingTool;
			InteractionT = interactionType;
		}
	}
	public enum InteractionType
	{
		Enter,
		Stay,
		Exit
	}
	public class HandsManager : MonoBehaviour
	{
		public enum HandsVisualMode
		{
			Mesh,
			Skeleton,
			Both
		}

		private const string SKELETON_VISUALIZER_NAME = "SkeletonRenderer";

		[SerializeField]
		private GameObject _leftHand;

		[SerializeField]
		private GameObject _rightHand;

		public HandsVisualMode VisualMode;

		private OVRHand[] _hand = new OVRHand[2];

		private OVRSkeleton[] _handSkeleton = new OVRSkeleton[2];

		private OVRSkeletonRenderer[] _handSkeletonRenderer = new OVRSkeletonRenderer[2];

		private OVRMesh[] _handMesh = new OVRMesh[2];

		private OVRMeshRenderer[] _handMeshRenderer = new OVRMeshRenderer[2];

		private SkinnedMeshRenderer _leftMeshRenderer;

		private SkinnedMeshRenderer _rightMeshRenderer;

		private GameObject _leftSkeletonVisual;

		private GameObject _rightSkeletonVisual;

		private float _currentHandAlpha = 1f;

		private int HandAlphaId = Shader.PropertyToID("_HandAlpha");

		public OVRHand RightHand
		{
			get
			{
				return _hand[1];
			}
			private set
			{
				_hand[1] = value;
			}
		}

		public OVRSkeleton RightHandSkeleton
		{
			get
			{
				return _handSkeleton[1];
			}
			private set
			{
				_handSkeleton[1] = value;
			}
		}

		public OVRSkeletonRenderer RightHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[1];
			}
			private set
			{
				_handSkeletonRenderer[1] = value;
			}
		}

		public OVRMesh RightHandMesh
		{
			get
			{
				return _handMesh[1];
			}
			private set
			{
				_handMesh[1] = value;
			}
		}

		public OVRMeshRenderer RightHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[1];
			}
			private set
			{
				_handMeshRenderer[1] = value;
			}
		}

		public OVRHand LeftHand
		{
			get
			{
				return _hand[0];
			}
			private set
			{
				_hand[0] = value;
			}
		}

		public OVRSkeleton LeftHandSkeleton
		{
			get
			{
				return _handSkeleton[0];
			}
			private set
			{
				_handSkeleton[0] = value;
			}
		}

		public OVRSkeletonRenderer LeftHandSkeletonRenderer
		{
			get
			{
				return _handSkeletonRenderer[0];
			}
			private set
			{
				_handSkeletonRenderer[0] = value;
			}
		}

		public OVRMesh LeftHandMesh
		{
			get
			{
				return _handMesh[0];
			}
			private set
			{
				_handMesh[0] = value;
			}
		}

		public OVRMeshRenderer LeftHandMeshRenderer
		{
			get
			{
				return _handMeshRenderer[0];
			}
			private set
			{
				_handMeshRenderer[0] = value;
			}
		}

		public static HandsManager Instance { get; private set; }

		private void Awake()
		{
			if ((bool)Instance && Instance != this)
			{
				UnityEngine.Object.Destroy(this);
				return;
			}
			Instance = this;
			LeftHand = _leftHand.GetComponent<OVRHand>();
			LeftHandSkeleton = _leftHand.GetComponent<OVRSkeleton>();
			LeftHandSkeletonRenderer = _leftHand.GetComponent<OVRSkeletonRenderer>();
			LeftHandMesh = _leftHand.GetComponent<OVRMesh>();
			LeftHandMeshRenderer = _leftHand.GetComponent<OVRMeshRenderer>();
			RightHand = _rightHand.GetComponent<OVRHand>();
			RightHandSkeleton = _rightHand.GetComponent<OVRSkeleton>();
			RightHandSkeletonRenderer = _rightHand.GetComponent<OVRSkeletonRenderer>();
			RightHandMesh = _rightHand.GetComponent<OVRMesh>();
			RightHandMeshRenderer = _rightHand.GetComponent<OVRMeshRenderer>();
			_leftMeshRenderer = LeftHand.GetComponent<SkinnedMeshRenderer>();
			_rightMeshRenderer = RightHand.GetComponent<SkinnedMeshRenderer>();
			StartCoroutine(FindSkeletonVisualGameObjects());
		}

		private void Update()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
			case HandsVisualMode.Skeleton:
				_currentHandAlpha = 1f;
				break;
			case HandsVisualMode.Both:
				_currentHandAlpha = 0.6f;
				break;
			default:
				_currentHandAlpha = 1f;
				break;
			}
			_rightMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
			_leftMeshRenderer.sharedMaterial.SetFloat(HandAlphaId, _currentHandAlpha);
		}

		private IEnumerator FindSkeletonVisualGameObjects()
		{
			while (!_leftSkeletonVisual || !_rightSkeletonVisual)
			{
				if (!_leftSkeletonVisual)
				{
					Transform transform = LeftHand.transform.Find("SkeletonRenderer");
					if ((bool)transform)
					{
						_leftSkeletonVisual = transform.gameObject;
					}
				}
				if (!_rightSkeletonVisual)
				{
					Transform transform2 = RightHand.transform.Find("SkeletonRenderer");
					if ((bool)transform2)
					{
						_rightSkeletonVisual = transform2.gameObject;
					}
				}
				yield return null;
			}
			SetToCurrentVisualMode();
		}

		public void SwitchVisualization()
		{
			if ((bool)_leftSkeletonVisual && (bool)_rightSkeletonVisual)
			{
				VisualMode = (HandsVisualMode)((int)(VisualMode + 1) % 3);
				SetToCurrentVisualMode();
			}
		}

		private void SetToCurrentVisualMode()
		{
			switch (VisualMode)
			{
			case HandsVisualMode.Mesh:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: false);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: false);
				break;
			case HandsVisualMode.Skeleton:
				RightHandMeshRenderer.enabled = false;
				_rightMeshRenderer.enabled = false;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = false;
				_leftMeshRenderer.enabled = false;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			case HandsVisualMode.Both:
				RightHandMeshRenderer.enabled = true;
				_rightMeshRenderer.enabled = true;
				_rightSkeletonVisual.gameObject.SetActive(value: true);
				LeftHandMeshRenderer.enabled = true;
				_leftMeshRenderer.enabled = true;
				_leftSkeletonVisual.gameObject.SetActive(value: true);
				break;
			}
		}

		public static List<OVRBoneCapsule> GetCapsulesPerBone(OVRSkeleton skeleton, OVRSkeleton.BoneId boneId)
		{
			List<OVRBoneCapsule> list = new List<OVRBoneCapsule>();
			IList<OVRBoneCapsule> capsules = skeleton.Capsules;
			for (int i = 0; i < capsules.Count; i++)
			{
				if (capsules[i].BoneIndex == (short)boneId)
				{
					list.Add(capsules[i]);
				}
			}
			return list;
		}

		public bool IsInitialized()
		{
			if ((bool)LeftHandSkeleton && LeftHandSkeleton.IsInitialized && (bool)RightHandSkeleton && RightHandSkeleton.IsInitialized && (bool)LeftHandMesh && LeftHandMesh.IsInitialized && (bool)RightHandMesh)
			{
				return RightHandMesh.IsInitialized;
			}
			return false;
		}
	}
	public abstract class Interactable : MonoBehaviour
	{
		[Serializable]
		public class InteractableStateArgsEvent : UnityEvent<InteractableStateArgs>
		{
		}

		protected ColliderZone _proximityZoneCollider;

		protected ColliderZone _contactZoneCollider;

		protected ColliderZone _actionZoneCollider;

		public InteractableStateArgsEvent InteractableStateChanged;

		public ColliderZone ProximityCollider => _proximityZoneCollider;

		public ColliderZone ContactCollider => _contactZoneCollider;

		public ColliderZone ActionCollider => _actionZoneCollider;

		public virtual int ValidToolTagsMask => -1;

		public event Action<ColliderZoneArgs> ProximityZoneEvent;

		public event Action<ColliderZoneArgs> ContactZoneEvent;

		public event Action<ColliderZoneArgs> ActionZoneEvent;

		protected virtual void OnProximityZoneEvent(ColliderZoneArgs args)
		{
			if (this.ProximityZoneEvent != null)
			{
				this.ProximityZoneEvent(args);
			}
		}

		protected virtual void OnContactZoneEvent(ColliderZoneArgs args)
		{
			if (this.ContactZoneEvent != null)
			{
				this.ContactZoneEvent(args);
			}
		}

		protected virtual void OnActionZoneEvent(ColliderZoneArgs args)
		{
			if (this.ActionZoneEvent != null)
			{
				this.ActionZoneEvent(args);
			}
		}

		public abstract void UpdateCollisionDepth(InteractableTool interactableTool, InteractableCollisionDepth oldCollisionDepth, InteractableCollisionDepth newCollisionDepth);

		protected virtual void Awake()
		{
			InteractableRegistry.RegisterInteractable(this);
		}

		protected virtual void OnDestroy()
		{
			InteractableRegistry.UnregisterInteractable(this);
		}
	}
	public enum InteractableCollisionDepth
	{
		None,
		Proximity,
		Contact,
		Action
	}
	public enum InteractableState
	{
		Default,
		ProximityState,
		ContactState,
		ActionState
	}
	public class InteractableStateArgs : EventArgs
	{
		public readonly Interactable Interactable;

		public readonly InteractableTool Tool;

		public readonly InteractableState OldInteractableState;

		public readonly InteractableState NewInteractableState;

		public readonly ColliderZoneArgs ColliderArgs;

		public InteractableStateArgs(Interactable interactable, InteractableTool tool, InteractableState newInteractableState, InteractableState oldState, ColliderZoneArgs colliderArgs)
		{
			Interactable = interactable;
			Tool = tool;
			NewInteractableState = newInteractableState;
			OldInteractableState = oldState;
			ColliderArgs = colliderArgs;
		}
	}
	public class InteractableRegistry : MonoBehaviour
	{
		public static HashSet<Interactable> _interactables = new HashSet<Interactable>();

		public static HashSet<Interactable> Interactables => _interactables;

		public static void RegisterInteractable(Interactable interactable)
		{
			Interactables.Add(interactable);
		}

		public static void UnregisterInteractable(Interactable interactable)
		{
			Interactables.Remove(interactable);
		}
	}
	public class InteractableToolsCreator : MonoBehaviour
	{
		[SerializeField]
		private Transform[] LeftHandTools;

		[SerializeField]
		private Transform[] RightHandTools;

		private void Awake()
		{
			if (LeftHandTools != null && LeftHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(LeftHandTools, isRightHand: false));
			}
			if (RightHandTools != null && RightHandTools.Length != 0)
			{
				StartCoroutine(AttachToolsToHands(RightHandTools, isRightHand: true));
			}
		}

		private IEnumerator AttachToolsToHands(Transform[] toolObjects, bool isRightHand)
		{
			HandsManager handsManagerObj;
			while (true)
			{
				HandsManager instance;
				handsManagerObj = (instance = HandsManager.Instance);
				if (!(instance == null) && handsManagerObj.IsInitialized())
				{
					break;
				}
				yield return null;
			}
			HashSet<Transform> hashSet = new HashSet<Transform>();
			foreach (Transform transform in toolObjects)
			{
				hashSet.Add(transform.transform);
			}
			foreach (Transform toolObject in hashSet)
			{
				OVRSkeleton handSkeletonToAttachTo = (isRightHand ? handsManagerObj.RightHandSkeleton : handsManagerObj.LeftHandSkeleton);
				while (handSkeletonToAttachTo == null || handSkeletonToAttachTo.Bones == null)
				{
					yield return null;
				}
				AttachToolToHandTransform(toolObject, isRightHand);
			}
		}

		private void AttachToolToHandTransform(Transform tool, bool isRightHanded)
		{
			Transform obj = UnityEngine.Object.Instantiate(tool).transform;
			obj.localPosition = Vector3.zero;
			InteractableTool component = obj.GetComponent<InteractableTool>();
			component.IsRightHandedTool = isRightHanded;
			component.Initialize();
		}
	}
	public class InteractableToolsInputRouter : MonoBehaviour
	{
		private static InteractableToolsInputRouter _instance;

		private bool _leftPinch;

		private bool _rightPinch;

		private HashSet<InteractableTool> _leftHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _leftHandFarTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandNearTools = new HashSet<InteractableTool>();

		private HashSet<InteractableTool> _rightHandFarTools = new HashSet<InteractableTool>();

		public static InteractableToolsInputRouter Instance
		{
			get
			{
				if (_instance == null)
				{
					InteractableToolsInputRouter[] array = UnityEngine.Object.FindObjectsOfType<InteractableToolsInputRouter>();
					if (array.Length != 0)
					{
						_instance = array[0];
						for (int i = 1; i < array.Length; i++)
						{
							UnityEngine.Object.Destroy(array[i].gameObject);
						}
					}
				}
				return _instance;
			}
		}

		public void RegisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Add(interactableTool);
				}
				else
				{
					_rightHandNearTools.Add(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Add(interactableTool);
			}
			else
			{
				_leftHandNearTools.Add(interactableTool);
			}
		}

		public void UnregisterInteractableTool(InteractableTool interactableTool)
		{
			if (interactableTool.IsRightHandedTool)
			{
				if (interactableTool.IsFarFieldTool)
				{
					_rightHandFarTools.Remove(interactableTool);
				}
				else
				{
					_rightHandNearTools.Remove(interactableTool);
				}
			}
			else if (interactableTool.IsFarFieldTool)
			{
				_leftHandFarTools.Remove(interactableTool);
			}
			else
			{
				_leftHandNearTools.Remove(interactableTool);
			}
		}

		private void Update()
		{
			if (HandsManager.Instance.IsInitialized())
			{
				bool flag = HandsManager.Instance.LeftHand.IsTracked && HandsManager.Instance.LeftHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool flag2 = HandsManager.Instance.RightHand.IsTracked && HandsManager.Instance.RightHand.HandConfidence == OVRHand.TrackingConfidence.High;
				bool isPointerPoseValid = HandsManager.Instance.LeftHand.IsPointerPoseValid;
				bool isPointerPoseValid2 = HandsManager.Instance.RightHand.IsPointerPoseValid;
				bool flag3 = UpdateToolsAndEnableState(_leftHandNearTools, flag);
				UpdateToolsAndEnableState(_leftHandFarTools, !flag3 && flag && isPointerPoseValid);
				bool flag4 = UpdateToolsAndEnableState(_rightHandNearTools, flag2);
				UpdateToolsAndEnableState(_rightHandFarTools, !flag4 && flag2 && isPointerPoseValid2);
			}
		}

		private bool UpdateToolsAndEnableState(HashSet<InteractableTool> tools, bool toolsAreEnabledThisFrame)
		{
			bool result = UpdateTools(tools, !toolsAreEnabledThisFrame);
			ToggleToolsEnableState(tools, toolsAreEnabledThisFrame);
			return result;
		}

		private bool UpdateTools(HashSet<InteractableTool> tools, bool resetCollisionData = false)
		{
			bool flag = false;
			foreach (InteractableTool tool in tools)
			{
				List<InteractableCollisionInfo> nextIntersectingObjects = tool.GetNextIntersectingObjects();
				if (nextIntersectingObjects.Count > 0 && !resetCollisionData)
				{
					if (!flag)
					{
						flag = nextIntersectingObjects.Count > 0;
					}
					tool.UpdateCurrentCollisionsBasedOnDepth();
					if (tool.IsFarFieldTool)
					{
						KeyValuePair<Interactable, InteractableCollisionInfo> firstCurrentCollisionInfo = tool.GetFirstCurrentCollisionInfo();
						if (tool.ToolInputState == ToolInputState.PrimaryInputUp)
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ActionCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Action;
						}
						else
						{
							firstCurrentCollisionInfo.Value.InteractableCollider = firstCurrentCollisionInfo.Key.ContactCollider;
							firstCurrentCollisionInfo.Value.CollisionDepth = InteractableCollisionDepth.Contact;
						}
						tool.FocusOnInteractable(firstCurrentCollisionInfo.Key, firstCurrentCollisionInfo.Value.InteractableCollider);
					}
				}
				else
				{
					tool.DeFocus();
					tool.ClearAllCurrentCollisionInfos();
				}
				tool.UpdateLatestCollisionData();
			}
			return flag;
		}

		private void ToggleToolsEnableState(HashSet<InteractableTool> tools, bool enableState)
		{
			foreach (InteractableTool tool in tools)
			{
				if (tool.EnableState != enableState)
				{
					tool.EnableState = enableState;
				}
			}
		}
	}
	public class FingerTipPokeTool : InteractableTool
	{
		private const int NUM_VELOCITY_FRAMES = 10;

		[SerializeField]
		private FingerTipPokeToolView _fingerTipPokeToolView;

		[SerializeField]
		private OVRPlugin.HandFinger _fingerToFollow = OVRPlugin.HandFinger.Index;

		private Vector3[] _velocityFrames;

		private int _currVelocityFrame;

		private bool _sampledMaxFramesAlready;

		private Vector3 _position;

		private BoneCapsuleTriggerLogic[] _boneCapsuleTriggerLogic;

		private float _lastScale = 1f;

		private bool _isInitialized;

		private OVRBoneCapsule _capsuleToTrack;

		public override InteractableToolTags ToolTags => InteractableToolTags.Poke;

		public override ToolInputState ToolInputState => ToolInputState.Inactive;

		public override bool IsFarFieldTool => false;

		public override bool EnableState
		{
			get
			{
				return _fingerTipPokeToolView.gameObject.activeSelf;
			}
			set
			{
				_fingerTipPokeToolView.gameObject.SetActive(value);
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_fingerTipPokeToolView.InteractableTool = this;
			_velocityFrames = new Vector3[10];
			Array.Clear(_velocityFrames, 0, 10);
			StartCoroutine(AttachTriggerLogic());
		}

		private IEnumerator AttachTriggerLogic()
		{
			while (!HandsManager.Instance || !HandsManager.Instance.IsInitialized())
			{
				yield return null;
			}
			OVRSkeleton skeleton = (base.IsRightHandedTool ? HandsManager.Instance.RightHandSkeleton : HandsManager.Instance.LeftHandSkeleton);
			OVRSkeleton.BoneId boneId = _fingerToFollow switch
			{
				OVRPlugin.HandFinger.Thumb => OVRSkeleton.BoneId.Hand_Thumb3, 
				OVRPlugin.HandFinger.Index => OVRSkeleton.BoneId.Hand_Index3, 
				OVRPlugin.HandFinger.Middle => OVRSkeleton.BoneId.Hand_Middle3, 
				OVRPlugin.HandFinger.Ring => OVRSkeleton.BoneId.Hand_Ring3, 
				_ => OVRSkeleton.BoneId.Hand_Pinky3, 
			};
			List<BoneCapsuleTriggerLogic> list = new List<BoneCapsuleTriggerLogic>();
			List<OVRBoneCapsule> capsulesPerBone = HandsManager.GetCapsulesPerBone(skeleton, boneId);
			foreach (OVRBoneCapsule item in capsulesPerBone)
			{
				BoneCapsuleTriggerLogic boneCapsuleTriggerLogic = item.CapsuleRigidbody.gameObject.AddComponent<BoneCapsuleTriggerLogic>();
				item.CapsuleCollider.isTrigger = true;
				boneCapsuleTriggerLogic.ToolTags = ToolTags;
				list.Add(boneCapsuleTriggerLogic);
			}
			_boneCapsuleTriggerLogic = list.ToArray();
			if (capsulesPerBone.Count > 0)
			{
				_capsuleToTrack = capsulesPerBone[0];
			}
			_isInitialized = true;
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _isInitialized && _capsuleToTrack != null)
			{
				float handScale = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand).HandScale;
				Transform transform = _capsuleToTrack.CapsuleCollider.transform;
				Vector3 right = transform.right;
				Vector3 vector = transform.position + _capsuleToTrack.CapsuleCollider.height * 0.5f * right;
				Vector3 vector2 = handScale * _fingerTipPokeToolView.SphereRadius * right;
				Vector3 position = vector + vector2;
				base.transform.position = position;
				base.transform.rotation = transform.rotation;
				base.InteractionPosition = vector;
				UpdateAverageVelocity();
				CheckAndUpdateScale();
			}
		}

		private void UpdateAverageVelocity()
		{
			Vector3 position = _position;
			Vector3 position2 = base.transform.position;
			Vector3 vector = (position2 - position) / Time.deltaTime;
			_position = position2;
			_velocityFrames[_currVelocityFrame] = vector;
			_currVelocityFrame = (_currVelocityFrame + 1) % 10;
			base.Velocity = Vector3.zero;
			if (!_sampledMaxFramesAlready && _currVelocityFrame == 9)
			{
				_sampledMaxFramesAlready = true;
			}
			int num = (_sampledMaxFramesAlready ? 10 : (_currVelocityFrame + 1));
			for (int i = 0; i < num; i++)
			{
				base.Velocity += _velocityFrames[i];
			}
			base.Velocity /= (float)num;
		}

		private void CheckAndUpdateScale()
		{
			float num = (base.IsRightHandedTool ? HandsManager.Instance.RightHand.HandScale : HandsManager.Instance.LeftHand.HandScale);
			if (Mathf.Abs(num - _lastScale) > Mathf.Epsilon)
			{
				base.transform.localScale = new Vector3(num, num, num);
				_lastScale = num;
			}
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			_currentIntersectingObjects.Clear();
			BoneCapsuleTriggerLogic[] boneCapsuleTriggerLogic = _boneCapsuleTriggerLogic;
			for (int i = 0; i < boneCapsuleTriggerLogic.Length; i++)
			{
				foreach (ColliderZone collidersTouchingU in boneCapsuleTriggerLogic[i].CollidersTouchingUs)
				{
					_currentIntersectingObjects.Add(new InteractableCollisionInfo(collidersTouchingU, collidersTouchingU.CollisionDepth, this));
				}
			}
			return _currentIntersectingObjects;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
		}

		public override void DeFocus()
		{
		}
	}
	public class FingerTipPokeToolView : MonoBehaviour, InteractableToolView
	{
		[SerializeField]
		private MeshRenderer _sphereMeshRenderer;

		public InteractableTool InteractableTool { get; set; }

		public bool EnableState
		{
			get
			{
				return _sphereMeshRenderer.enabled;
			}
			set
			{
				_sphereMeshRenderer.enabled = value;
			}
		}

		public bool ToolActivateState { get; set; }

		public float SphereRadius { get; private set; }

		private void Awake()
		{
			SphereRadius = _sphereMeshRenderer.transform.localScale.z * 0.5f;
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
		}
	}
	[Flags]
	public enum InteractableToolTags
	{
		None = 0,
		Ray = 1,
		Poke = 4,
		All = -1
	}
	public enum ToolInputState
	{
		Inactive,
		PrimaryInputDown,
		PrimaryInputDownStay,
		PrimaryInputUp
	}
	public class InteractableCollisionInfo
	{
		public ColliderZone InteractableCollider;

		public InteractableCollisionDepth CollisionDepth;

		public InteractableTool CollidingTool;

		public InteractableCollisionInfo(ColliderZone collider, InteractableCollisionDepth collisionDepth, InteractableTool collidingTool)
		{
			InteractableCollider = collider;
			CollisionDepth = collisionDepth;
			CollidingTool = collidingTool;
		}
	}
	public abstract class InteractableTool : MonoBehaviour
	{
		protected List<InteractableCollisionInfo> _currentIntersectingObjects = new List<InteractableCollisionInfo>();

		private List<Interactable> _addedInteractables = new List<Interactable>();

		private List<Interactable> _removedInteractables = new List<Interactable>();

		private List<Interactable> _remainingInteractables = new List<Interactable>();

		private Dictionary<Interactable, InteractableCollisionInfo> _currInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		private Dictionary<Interactable, InteractableCollisionInfo> _prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>();

		public Transform ToolTransform => base.transform;

		public bool IsRightHandedTool { get; set; }

		public abstract InteractableToolTags ToolTags { get; }

		public abstract ToolInputState ToolInputState { get; }

		public abstract bool IsFarFieldTool { get; }

		public Vector3 Velocity { get; protected set; }

		public Vector3 InteractionPosition { get; protected set; }

		public abstract bool EnableState { get; set; }

		public List<InteractableCollisionInfo> GetCurrentIntersectingObjects()
		{
			return _currentIntersectingObjects;
		}

		public abstract List<InteractableCollisionInfo> GetNextIntersectingObjects();

		public abstract void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone);

		public abstract void DeFocus();

		public abstract void Initialize();

		public KeyValuePair<Interactable, InteractableCollisionInfo> GetFirstCurrentCollisionInfo()
		{
			return _currInteractableToCollisionInfos.First();
		}

		public void ClearAllCurrentCollisionInfos()
		{
			_currInteractableToCollisionInfos.Clear();
		}

		public virtual void UpdateCurrentCollisionsBasedOnDepth()
		{
			_currInteractableToCollisionInfos.Clear();
			foreach (InteractableCollisionInfo currentIntersectingObject in _currentIntersectingObjects)
			{
				Interactable parentInteractable = currentIntersectingObject.InteractableCollider.ParentInteractable;
				InteractableCollisionDepth collisionDepth = currentIntersectingObject.CollisionDepth;
				InteractableCollisionInfo value = null;
				if (!_currInteractableToCollisionInfos.TryGetValue(parentInteractable, out value))
				{
					_currInteractableToCollisionInfos[parentInteractable] = currentIntersectingObject;
				}
				else if (value.CollisionDepth < collisionDepth)
				{
					value.InteractableCollider = currentIntersectingObject.InteractableCollider;
					value.CollisionDepth = collisionDepth;
				}
			}
		}

		public virtual void UpdateLatestCollisionData()
		{
			_addedInteractables.Clear();
			_removedInteractables.Clear();
			_remainingInteractables.Clear();
			foreach (Interactable key in _currInteractableToCollisionInfos.Keys)
			{
				if (!_prevInteractableToCollisionInfos.ContainsKey(key))
				{
					_addedInteractables.Add(key);
				}
				else
				{
					_remainingInteractables.Add(key);
				}
			}
			foreach (Interactable key2 in _prevInteractableToCollisionInfos.Keys)
			{
				if (!_currInteractableToCollisionInfos.ContainsKey(key2))
				{
					_removedInteractables.Add(key2);
				}
			}
			foreach (Interactable removedInteractable in _removedInteractables)
			{
				removedInteractable.UpdateCollisionDepth(this, _prevInteractableToCollisionInfos[removedInteractable].CollisionDepth, InteractableCollisionDepth.None);
			}
			foreach (Interactable addedInteractable in _addedInteractables)
			{
				InteractableCollisionDepth collisionDepth = _currInteractableToCollisionInfos[addedInteractable].CollisionDepth;
				addedInteractable.UpdateCollisionDepth(this, InteractableCollisionDepth.None, collisionDepth);
			}
			foreach (Interactable remainingInteractable in _remainingInteractables)
			{
				InteractableCollisionDepth collisionDepth2 = _currInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				InteractableCollisionDepth collisionDepth3 = _prevInteractableToCollisionInfos[remainingInteractable].CollisionDepth;
				remainingInteractable.UpdateCollisionDepth(this, collisionDepth3, collisionDepth2);
			}
			_prevInteractableToCollisionInfos = new Dictionary<Interactable, InteractableCollisionInfo>(_currInteractableToCollisionInfos);
		}
	}
	public interface InteractableToolView
	{
		InteractableTool InteractableTool { get; }

		bool EnableState { get; set; }

		bool ToolActivateState { get; set; }

		void SetFocusedInteractable(Interactable interactable);
	}
	public class PinchStateModule
	{
		private enum PinchState
		{
			None,
			PinchDown,
			PinchStay,
			PinchUp
		}

		private const float PINCH_STRENGTH_THRESHOLD = 1f;

		private PinchState _currPinchState;

		private Interactable _firstFocusedInteractable;

		public bool PinchUpAndDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchUp)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchSteadyOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchStay)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public bool PinchDownOnFocusedObject
		{
			get
			{
				if (_currPinchState == PinchState.PinchDown)
				{
					return _firstFocusedInteractable != null;
				}
				return false;
			}
		}

		public PinchStateModule()
		{
			_currPinchState = PinchState.None;
			_firstFocusedInteractable = null;
		}

		public void UpdateState(OVRHand hand, Interactable currFocusedInteractable)
		{
			float fingerPinchStrength = hand.GetFingerPinchStrength(OVRHand.HandFinger.Index);
			bool flag = Mathf.Abs(1f - fingerPinchStrength) < Mathf.Epsilon;
			switch (_currPinchState)
			{
			case PinchState.PinchUp:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					if (currFocusedInteractable != _firstFocusedInteractable)
					{
						_firstFocusedInteractable = null;
					}
				}
				else
				{
					_currPinchState = PinchState.None;
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchStay:
				if (!flag)
				{
					_currPinchState = PinchState.PinchUp;
				}
				if (currFocusedInteractable != _firstFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			case PinchState.PinchDown:
				_currPinchState = (flag ? PinchState.PinchStay : PinchState.PinchUp);
				if (_firstFocusedInteractable != currFocusedInteractable)
				{
					_firstFocusedInteractable = null;
				}
				break;
			default:
				if (flag)
				{
					_currPinchState = PinchState.PinchDown;
					_firstFocusedInteractable = currFocusedInteractable;
				}
				break;
			}
		}
	}
	public class RayTool : InteractableTool
	{
		private const float MINIMUM_RAY_CAST_DISTANCE = 0.8f;

		private const float COLLIDER_RADIUS = 0.01f;

		private const int NUM_MAX_PRIMARY_HITS = 10;

		private const int NUM_MAX_SECONDARY_HITS = 25;

		private const int NUM_COLLIDERS_TO_TEST = 20;

		[SerializeField]
		private RayToolView _rayToolView;

		[Range(0f, 45f)]
		[SerializeField]
		private float _coneAngleDegrees = 20f;

		[SerializeField]
		private float _farFieldMaxDistance = 5f;

		private PinchStateModule _pinchStateModule = new PinchStateModule();

		private Interactable _focusedInteractable;

		private Collider[] _collidersOverlapped = new Collider[20];

		private Interactable _currInteractableCastedAgainst;

		private float _coneAngleReleaseDegrees;

		private RaycastHit[] _primaryHits = new RaycastHit[10];

		private Collider[] _secondaryOverlapResults = new Collider[25];

		private bool _initialized;

		public override InteractableToolTags ToolTags => InteractableToolTags.Ray;

		public override ToolInputState ToolInputState
		{
			get
			{
				if (_pinchStateModule.PinchDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDown;
				}
				if (_pinchStateModule.PinchSteadyOnFocusedObject)
				{
					return ToolInputState.PrimaryInputDownStay;
				}
				if (_pinchStateModule.PinchUpAndDownOnFocusedObject)
				{
					return ToolInputState.PrimaryInputUp;
				}
				return ToolInputState.Inactive;
			}
		}

		public override bool IsFarFieldTool => true;

		public override bool EnableState
		{
			get
			{
				return _rayToolView.EnableState;
			}
			set
			{
				_rayToolView.EnableState = value;
			}
		}

		public override void Initialize()
		{
			InteractableToolsInputRouter.Instance.RegisterInteractableTool(this);
			_rayToolView.InteractableTool = this;
			_coneAngleReleaseDegrees = _coneAngleDegrees * 1.2f;
			_initialized = true;
		}

		private void OnDestroy()
		{
			if (InteractableToolsInputRouter.Instance != null)
			{
				InteractableToolsInputRouter.Instance.UnregisterInteractableTool(this);
			}
		}

		private void Update()
		{
			if ((bool)HandsManager.Instance && HandsManager.Instance.IsInitialized() && _initialized)
			{
				OVRHand oVRHand = (base.IsRightHandedTool ? HandsManager.Instance.RightHand : HandsManager.Instance.LeftHand);
				Transform pointerPose = oVRHand.PointerPose;
				base.transform.position = pointerPose.position;
				base.transform.rotation = pointerPose.rotation;
				Vector3 interactionPosition = base.InteractionPosition;
				Vector3 position = base.transform.position;
				base.Velocity = (position - interactionPosition) / Time.deltaTime;
				base.InteractionPosition = position;
				_pinchStateModule.UpdateState(oVRHand, _focusedInteractable);
				_rayToolView.ToolActivateState = _pinchStateModule.PinchSteadyOnFocusedObject || _pinchStateModule.PinchDownOnFocusedObject;
			}
		}

		private Vector3 GetRayCastOrigin()
		{
			return base.transform.position + 0.8f * base.transform.forward;
		}

		public override List<InteractableCollisionInfo> GetNextIntersectingObjects()
		{
			if (!_initialized)
			{
				return _currentIntersectingObjects;
			}
			if (_currInteractableCastedAgainst != null && HasRayReleasedInteractable(_currInteractableCastedAgainst))
			{
				_currInteractableCastedAgainst = null;
			}
			if (_currInteractableCastedAgainst == null)
			{
				_currentIntersectingObjects.Clear();
				_currInteractableCastedAgainst = FindTargetInteractable();
				if (_currInteractableCastedAgainst != null)
				{
					int num = Physics.OverlapSphereNonAlloc(_currInteractableCastedAgainst.transform.position, 0.01f, _collidersOverlapped);
					for (int i = 0; i < num; i++)
					{
						ColliderZone component = _collidersOverlapped[i].GetComponent<ColliderZone>();
						if (component != null)
						{
							Interactable parentInteractable = component.ParentInteractable;
							if (!(parentInteractable == null) && !(parentInteractable != _currInteractableCastedAgainst))
							{
								InteractableCollisionInfo item = new InteractableCollisionInfo(component, component.CollisionDepth, this);
								_currentIntersectingObjects.Add(item);
							}
						}
					}
					if (_currentIntersectingObjects.Count == 0)
					{
						_currInteractableCastedAgainst = null;
					}
				}
			}
			return _currentIntersectingObjects;
		}

		private bool HasRayReleasedInteractable(Interactable focusedInteractable)
		{
			Vector3 position = base.transform.position;
			Vector3 forward = base.transform.forward;
			float num = Mathf.Cos(_coneAngleReleaseDegrees * ((float)Math.PI / 180f));
			Vector3 lhs = focusedInteractable.transform.position - position;
			lhs.Normalize();
			return Vector3.Dot(lhs, forward) < num;
		}

		private Interactable FindTargetInteractable()
		{
			Vector3 rayCastOrigin = GetRayCastOrigin();
			Vector3 forward = base.transform.forward;
			Interactable interactable = null;
			interactable = FindPrimaryRaycastHit(rayCastOrigin, forward);
			if (interactable == null)
			{
				interactable = FindInteractableViaConeTest(rayCastOrigin, forward);
			}
			return interactable;
		}

		private Interactable FindPrimaryRaycastHit(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			int num = Physics.RaycastNonAlloc(new Ray(rayOrigin, rayDirection), _primaryHits, float.PositiveInfinity);
			float num2 = 0f;
			for (int i = 0; i < num; i++)
			{
				RaycastHit raycastHit = _primaryHits[i];
				ColliderZone component = raycastHit.transform.GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					float magnitude = (parentInteractable.transform.position - rayOrigin).magnitude;
					if (interactable == null || magnitude < num2)
					{
						interactable = parentInteractable;
						num2 = magnitude;
					}
				}
			}
			return interactable;
		}

		private Interactable FindInteractableViaConeTest(Vector3 rayOrigin, Vector3 rayDirection)
		{
			Interactable interactable = null;
			float num = 0f;
			float num2 = Mathf.Cos(_coneAngleDegrees * ((float)Math.PI / 180f));
			float num3 = Mathf.Tan((float)Math.PI / 180f * _coneAngleDegrees * 0.5f) * _farFieldMaxDistance;
			int num4 = Physics.OverlapBoxNonAlloc(rayOrigin + rayDirection * _farFieldMaxDistance * 0.5f, new Vector3(num3, num3, _farFieldMaxDistance * 0.5f), _secondaryOverlapResults, base.transform.rotation);
			for (int i = 0; i < num4; i++)
			{
				ColliderZone component = _secondaryOverlapResults[i].GetComponent<ColliderZone>();
				if (component == null)
				{
					continue;
				}
				Interactable parentInteractable = component.ParentInteractable;
				if (!(parentInteractable == null) && ((uint)parentInteractable.ValidToolTagsMask & (uint)ToolTags) != 0)
				{
					Vector3 lhs = parentInteractable.transform.position - rayOrigin;
					float magnitude = lhs.magnitude;
					lhs /= magnitude;
					if (!(Vector3.Dot(lhs, rayDirection) < num2) && (interactable == null || magnitude < num))
					{
						interactable = parentInteractable;
						num = magnitude;
					}
				}
			}
			return interactable;
		}

		public override void FocusOnInteractable(Interactable focusedInteractable, ColliderZone colliderZone)
		{
			_rayToolView.SetFocusedInteractable(focusedInteractable);
			_focusedInteractable = focusedInteractable;
		}

		public override void DeFocus()
		{
			_rayToolView.SetFocusedInteractable(null);
			_focusedInteractable = null;
		}
	}
	public class RayToolView : MonoBehaviour, InteractableToolView
	{
		private const int NUM_RAY_LINE_POSITIONS = 25;

		private const float DEFAULT_RAY_CAST_DISTANCE = 3f;

		[SerializeField]
		private Transform _targetTransform;

		[SerializeField]
		private LineRenderer _lineRenderer;

		private bool _toolActivateState;

		private Transform _focusedTransform;

		private Vector3[] linePositions = new Vector3[25];

		private Gradient _oldColorGradient;

		private Gradient _highLightColorGradient;

		public bool EnableState
		{
			get
			{
				return _lineRenderer.enabled;
			}
			set
			{
				_targetTransform.gameObject.SetActive(value);
				_lineRenderer.enabled = value;
			}
		}

		public bool ToolActivateState
		{
			get
			{
				return _toolActivateState;
			}
			set
			{
				_toolActivateState = value;
				_lineRenderer.colorGradient = (_toolActivateState ? _highLightColorGradient : _oldColorGradient);
			}
		}

		public InteractableTool InteractableTool { get; set; }

		private void Awake()
		{
			_lineRenderer.positionCount = 25;
			_oldColorGradient = _lineRenderer.colorGradient;
			_highLightColorGradient = new Gradient();
			_highLightColorGradient.SetKeys(new GradientColorKey[2]
			{
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 0f),
				new GradientColorKey(new Color(0.9f, 0.9f, 0.9f), 1f)
			}, new GradientAlphaKey[2]
			{
				new GradientAlphaKey(1f, 0f),
				new GradientAlphaKey(1f, 1f)
			});
		}

		public void SetFocusedInteractable(Interactable interactable)
		{
			if (interactable == null)
			{
				_focusedTransform = null;
			}
			else
			{
				_focusedTransform = interactable.transform;
			}
		}

		private void Update()
		{
			Vector3 position = InteractableTool.ToolTransform.position;
			Vector3 forward = InteractableTool.ToolTransform.forward;
			Vector3 vector = ((_focusedTransform != null) ? _focusedTransform.position : (position + forward * 3f));
			float magnitude = (vector - position).magnitude;
			Vector3 p = position;
			Vector3 p2 = position + forward * magnitude * 0.3333333f;
			Vector3 p3 = position + forward * magnitude * (2f / 3f);
			Vector3 p4 = vector;
			for (int i = 0; i < 25; i++)
			{
				linePositions[i] = GetPointOnBezierCurve(p, p2, p3, p4, (float)i / 25f);
			}
			_lineRenderer.SetPositions(linePositions);
			_targetTransform.position = vector;
		}

		public static Vector3 GetPointOnBezierCurve(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)
		{
			t = Mathf.Clamp01(t);
			float num = 1f - t;
			float num2 = num * num;
			float num3 = t * t;
			return num * num2 * p0 + 3f * num2 * t * p1 + 3f * num * num3 * p2 + t * num3 * p3;
		}
	}
	public class DistanceGrabberSample : MonoBehaviour
	{
		private bool useSpherecast;

		private bool allowGrabThroughWalls;

		[SerializeField]
		private DistanceGrabber[] m_grabbers;

		public bool UseSpherecast
		{
			get
			{
				return useSpherecast;
			}
			set
			{
				useSpherecast = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].UseSpherecast = useSpherecast;
				}
			}
		}

		public bool AllowGrabThroughWalls
		{
			get
			{
				return allowGrabThroughWalls;
			}
			set
			{
				allowGrabThroughWalls = value;
				for (int i = 0; i < m_grabbers.Length; i++)
				{
					m_grabbers[i].m_preventGrabThroughWalls = !allowGrabThroughWalls;
				}
			}
		}

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("Distance Grab Sample");
			DebugUIBuilder.instance.AddToggle("Use Spherecasting", ToggleSphereCasting, useSpherecast);
			DebugUIBuilder.instance.AddToggle("Grab Through Walls", ToggleGrabThroughWalls, allowGrabThroughWalls);
			DebugUIBuilder.instance.Show();
			float displayFrequency = OVRManager.display.displayFrequency;
			if (displayFrequency > 0.1f)
			{
				UnityEngine.Debug.Log("Setting Time.fixedDeltaTime to: " + 1f / displayFrequency);
				Time.fixedDeltaTime = 1f / displayFrequency;
			}
		}

		public void ToggleSphereCasting(Toggle t)
		{
			UseSpherecast = !UseSpherecast;
		}

		public void ToggleGrabThroughWalls(Toggle t)
		{
			AllowGrabThroughWalls = !AllowGrabThroughWalls;
		}
	}
	public class ControllerBoxController : MonoBehaviour
	{
		[SerializeField]
		private TrainLocomotive _locomotive;

		[SerializeField]
		private CowController _cowController;

		private void Awake()
		{
		}

		public void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.StartStopStateChanged();
			}
		}

		public void DecreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.DecreaseSpeedStateChanged();
			}
		}

		public void IncreaseSpeedStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.IncreaseSpeedStateChanged();
			}
		}

		public void SmokeButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.SmokeButtonStateChanged();
			}
		}

		public void WhistleButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.WhistleButtonStateChanged();
			}
		}

		public void ReverseButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_locomotive.ReverseButtonStateChanged();
			}
		}

		public void SwitchVisualization(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				HandsManager.Instance.SwitchVisualization();
			}
		}

		public void GoMoo(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				_cowController.GoMooCowGo();
			}
		}
	}
	public class CowController : MonoBehaviour
	{
		[SerializeField]
		private Animation _cowAnimation;

		[SerializeField]
		private AudioSource _mooCowAudioSource;

		private void Start()
		{
		}

		public void PlayMooSound()
		{
			_mooCowAudioSource.timeSamples = 0;
			_mooCowAudioSource.Play();
		}

		public void GoMooCowGo()
		{
			_cowAnimation.Rewind();
			_cowAnimation.Play();
		}
	}
	public class PanelHMDFollower : MonoBehaviour
	{
		private const float TOTAL_DURATION = 3f;

		private const float HMD_MOVEMENT_THRESHOLD = 0.3f;

		[SerializeField]
		private float _maxDistance = 0.3f;

		[SerializeField]
		private float _minDistance = 0.05f;

		[SerializeField]
		private float _minZDistance = 0.05f;

		private OVRCameraRig _cameraRig;

		private Vector3 _panelInitialPosition = Vector3.zero;

		private Coroutine _coroutine;

		private Vector3 _prevPos = Vector3.zero;

		private Vector3 _lastMovedToPos = Vector3.zero;

		private void Awake()
		{
			_cameraRig = UnityEngine.Object.FindObjectOfType<OVRCameraRig>();
			_panelInitialPosition = base.transform.position;
		}

		private void Update()
		{
			Vector3 position = _cameraRig.centerEyeAnchor.position;
			_ = base.transform.position;
			float num = Vector3.Distance(position, _lastMovedToPos);
			float num2 = (_cameraRig.centerEyeAnchor.position - _prevPos).magnitude / Time.deltaTime;
			Vector3 vector = base.transform.position - position;
			float magnitude = vector.magnitude;
			if ((num > _maxDistance || _minZDistance > vector.z || _minDistance > magnitude) && num2 < 0.3f && _coroutine == null && _coroutine == null)
			{
				_coroutine = StartCoroutine(LerpToHMD());
			}
			_prevPos = _cameraRig.centerEyeAnchor.position;
		}

		private Vector3 CalculateIdealAnchorPosition()
		{
			return _cameraRig.centerEyeAnchor.position + _panelInitialPosition;
		}

		private IEnumerator LerpToHMD()
		{
			Vector3 newPanelPosition = CalculateIdealAnchorPosition();
			_lastMovedToPos = _cameraRig.centerEyeAnchor.position;
			float startTime = Time.time;
			float endTime = Time.time + 3f;
			while (Time.time < endTime)
			{
				base.transform.position = Vector3.Lerp(base.transform.position, newPanelPosition, (Time.time - startTime) / 3f);
				yield return null;
			}
			base.transform.position = newPanelPosition;
			_coroutine = null;
		}
	}
	public class SelectionCylinder : MonoBehaviour
	{
		public enum SelectionState
		{
			Off,
			Selected,
			Highlighted
		}

		[SerializeField]
		private MeshRenderer _selectionMeshRenderer;

		private static int _colorId = Shader.PropertyToID("_Color");

		private Material[] _selectionMaterials;

		private Color[] _defaultSelectionColors;

		private Color[] _highlightColors;

		private SelectionState _currSelectionState;

		public SelectionState CurrSelectionState
		{
			get
			{
				return _currSelectionState;
			}
			set
			{
				SelectionState currSelectionState = _currSelectionState;
				_currSelectionState = value;
				if (currSelectionState != _currSelectionState)
				{
					if (_currSelectionState > SelectionState.Off)
					{
						_selectionMeshRenderer.enabled = true;
						AffectSelectionColor((_currSelectionState == SelectionState.Selected) ? _defaultSelectionColors : _highlightColors);
					}
					else
					{
						_selectionMeshRenderer.enabled = false;
					}
				}
			}
		}

		private void Awake()
		{
			_selectionMaterials = _selectionMeshRenderer.materials;
			int num = _selectionMaterials.Length;
			_defaultSelectionColors = new Color[num];
			_highlightColors = new Color[num];
			for (int i = 0; i < num; i++)
			{
				_defaultSelectionColors[i] = _selectionMaterials[i].GetColor(_colorId);
				_highlightColors[i] = new Color(1f, 1f, 1f, _defaultSelectionColors[i].a);
			}
			CurrSelectionState = SelectionState.Off;
		}

		private void OnDestroy()
		{
			if (_selectionMaterials == null)
			{
				return;
			}
			Material[] selectionMaterials = _selectionMaterials;
			foreach (Material material in selectionMaterials)
			{
				if (material != null)
				{
					UnityEngine.Object.Destroy(material);
				}
			}
		}

		private void AffectSelectionColor(Color[] newColors)
		{
			int num = newColors.Length;
			for (int i = 0; i < num; i++)
			{
				_selectionMaterials[i].SetColor(_colorId, newColors[i]);
			}
		}
	}
	public class TrackSegment : MonoBehaviour
	{
		public enum SegmentType
		{
			Straight,
			LeftTurn,
			RightTurn,
			Switch
		}

		[SerializeField]
		private SegmentType _segmentType;

		[SerializeField]
		private MeshFilter _straight;

		[SerializeField]
		private MeshFilter _leftTurn;

		[SerializeField]
		private MeshFilter _rightTurn;

		private float _gridSize = 0.8f;

		private int _subDivCount = 20;

		private const float _originalGridSize = 0.8f;

		private const float _trackWidth = 0.15f;

		private GameObject _mesh;

		private Pose _p1 = new Pose();

		private Pose _p2 = new Pose();

		private Pose _endPose = new Pose();

		public float StartDistance { get; set; }

		public float GridSize
		{
			get
			{
				return _gridSize;
			}
			private set
			{
				_gridSize = value;
			}
		}

		public int SubDivCount
		{
			get
			{
				return _subDivCount;
			}
			set
			{
				_subDivCount = value;
			}
		}

		public SegmentType Type => _segmentType;

		public Pose EndPose
		{
			get
			{
				UpdatePose(SegmentLength, _endPose);
				return _endPose;
			}
		}

		public float Radius => 0.5f * GridSize;

		public float SegmentLength
		{
			get
			{
				switch (Type)
				{
				case SegmentType.Straight:
					return GridSize;
				case SegmentType.LeftTurn:
				case SegmentType.RightTurn:
					return (float)Math.PI / 2f * Radius;
				default:
					return 1f;
				}
			}
		}

		public float setGridSize(float size)
		{
			GridSize = size;
			return GridSize / 0.8f;
		}

		private void Awake()
		{
		}

		public void UpdatePose(float distanceIntoSegment, Pose pose)
		{
			if (Type == SegmentType.Straight)
			{
				pose.Position = base.transform.position + distanceIntoSegment * base.transform.forward;
				pose.Rotation = base.transform.rotation;
			}
			else if (Type == SegmentType.LeftTurn)
			{
				float num = distanceIntoSegment / SegmentLength;
				float num2 = (float)Math.PI / 2f * num;
				Vector3 position = new Vector3(Radius * Mathf.Cos(num2) - Radius, 0f, Radius * Mathf.Sin(num2));
				Quaternion quaternion = Quaternion.Euler(0f, (0f - num2) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position);
				pose.Rotation = base.transform.rotation * quaternion;
			}
			else if (Type == SegmentType.RightTurn)
			{
				float num3 = (float)Math.PI - (float)Math.PI / 2f * distanceIntoSegment / SegmentLength;
				Vector3 position2 = new Vector3(Radius * Mathf.Cos(num3) + Radius, 0f, Radius * Mathf.Sin(num3));
				Quaternion quaternion2 = Quaternion.Euler(0f, ((float)Math.PI - num3) * 57.29578f, 0f);
				pose.Position = base.transform.TransformPoint(position2);
				pose.Rotation = base.transform.rotation * quaternion2;
			}
			else
			{
				pose.Position = Vector3.zero;
				pose.Rotation = Quaternion.identity;
			}
		}

		private void Update()
		{
		}

		private void OnDisable()
		{
			UnityEngine.Object.Destroy(_mesh);
		}

		private void DrawDebugLines()
		{
			for (int i = 1; i < SubDivCount + 1; i++)
			{
				float num = SegmentLength / (float)SubDivCount;
				UpdatePose((float)(i - 1) * num, _p1);
				UpdatePose((float)i * num, _p2);
				float num2 = 0.075f;
				UnityEngine.Debug.DrawLine(_p1.Position + num2 * (_p1.Rotation * Vector3.right), _p2.Position + num2 * (_p2.Rotation * Vector3.right));
				UnityEngine.Debug.DrawLine(_p1.Position - num2 * (_p1.Rotation * Vector3.right), _p2.Position - num2 * (_p2.Rotation * Vector3.right));
			}
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right, base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position + 0.5f * GridSize * base.transform.right, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
			UnityEngine.Debug.DrawLine(base.transform.position - 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, base.transform.position + 0.5f * GridSize * base.transform.right + GridSize * base.transform.forward, Color.yellow);
		}

		public void RegenerateTrackAndMesh()
		{
			if (base.transform.childCount > 0 && !_mesh)
			{
				_mesh = base.transform.GetChild(0).gameObject;
			}
			if ((bool)_mesh)
			{
				UnityEngine.Object.DestroyImmediate(_mesh);
			}
			if (_segmentType == SegmentType.LeftTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_leftTurn.gameObject);
			}
			else if (_segmentType == SegmentType.RightTurn)
			{
				_mesh = UnityEngine.Object.Instantiate(_rightTurn.gameObject);
			}
			else
			{
				_mesh = UnityEngine.Object.Instantiate(_straight.gameObject);
			}
			_mesh.transform.SetParent(base.transform, worldPositionStays: false);
			_mesh.transform.position += GridSize / 2f * base.transform.forward;
			_mesh.transform.localScale = new Vector3(GridSize / 0.8f, GridSize / 0.8f, GridSize / 0.8f);
		}
	}
	public class TrainButtonVisualController : MonoBehaviour
	{
		private const float LERP_TO_OLD_POS_DURATION = 1f;

		private const float LOCAL_SIZE_HALVED = 0.5f;

		[SerializeField]
		private MeshRenderer _meshRenderer;

		[SerializeField]
		private MeshRenderer _glowRenderer;

		[SerializeField]
		private ButtonController _buttonController;

		[SerializeField]
		private Color _buttonContactColor = new Color(0.51f, 0.78f, 0.92f, 1f);

		[SerializeField]
		private Color _buttonActionColor = new Color(0.24f, 0.72f, 0.98f, 1f);

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _actionSoundEffect;

		[SerializeField]
		private Transform _buttonContactTransform;

		[SerializeField]
		private float _contactMaxDisplacementDistance = 0.0141f;

		private Material _buttonMaterial;

		private Color _buttonDefaultColor;

		private int _materialColorId;

		private bool _buttonInContactOrActionStates;

		private Coroutine _lerpToOldPositionCr;

		private Vector3 _oldPosition;

		private void Awake()
		{
			_materialColorId = Shader.PropertyToID("_Color");
			_buttonMaterial = _meshRenderer.material;
			_buttonDefaultColor = _buttonMaterial.GetColor(_materialColorId);
			_oldPosition = base.transform.localPosition;
		}

		private void OnDestroy()
		{
			if (_buttonMaterial != null)
			{
				UnityEngine.Object.Destroy(_buttonMaterial);
			}
		}

		private void OnEnable()
		{
			_buttonController.InteractableStateChanged.AddListener(InteractableStateChanged);
			_buttonController.ContactZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonController.ActionZoneEvent += ActionOrInContactZoneStayEvent;
			_buttonInContactOrActionStates = false;
		}

		private void OnDisable()
		{
			if (_buttonController != null)
			{
				_buttonController.InteractableStateChanged.RemoveListener(InteractableStateChanged);
				_buttonController.ContactZoneEvent -= ActionOrInContactZoneStayEvent;
				_buttonController.ActionZoneEvent -= ActionOrInContactZoneStayEvent;
			}
		}

		private void ActionOrInContactZoneStayEvent(ColliderZoneArgs collisionArgs)
		{
			if (_buttonInContactOrActionStates && !collisionArgs.CollidingTool.IsFarFieldTool)
			{
				Vector3 localScale = _buttonContactTransform.localScale;
				Vector3 interactionPosition = collisionArgs.CollidingTool.InteractionPosition;
				float num = (_buttonContactTransform.InverseTransformPoint(interactionPosition) - 0.5f * Vector3.one).y * localScale.y;
				if (num > 0f - _contactMaxDisplacementDistance && num <= 0f)
				{
					base.transform.localPosition = new Vector3(_oldPosition.x, _oldPosition.y + num, _oldPosition.z);
				}
			}
		}

		private void InteractableStateChanged(InteractableStateArgs obj)
		{
			_buttonInContactOrActionStates = false;
			_glowRenderer.gameObject.SetActive(obj.NewInteractableState > InteractableState.Default);
			switch (obj.NewInteractableState)
			{
			case InteractableState.ContactState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonContactColor);
				_buttonInContactOrActionStates = true;
				break;
			case InteractableState.ProximityState:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			case InteractableState.ActionState:
				StopResetLerping();
				_buttonMaterial.SetColor(_materialColorId, _buttonActionColor);
				PlaySound(_actionSoundEffect);
				_buttonInContactOrActionStates = true;
				break;
			default:
				_buttonMaterial.SetColor(_materialColorId, _buttonDefaultColor);
				LerpToOldPosition();
				break;
			}
		}

		private void PlaySound(AudioClip clip)
		{
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}

		private void StopResetLerping()
		{
			if (_lerpToOldPositionCr != null)
			{
				StopCoroutine(_lerpToOldPositionCr);
			}
		}

		private void LerpToOldPosition()
		{
			if (!((base.transform.localPosition - _oldPosition).sqrMagnitude < Mathf.Epsilon))
			{
				StopResetLerping();
				_lerpToOldPositionCr = StartCoroutine(ResetPosition());
			}
		}

		private IEnumerator ResetPosition()
		{
			float startTime = Time.time;
			float endTime = Time.time + 1f;
			while (Time.time < endTime)
			{
				base.transform.localPosition = Vector3.Lerp(base.transform.localPosition, _oldPosition, (Time.time - startTime) / 1f);
				yield return null;
			}
			base.transform.localPosition = _oldPosition;
			_lerpToOldPositionCr = null;
		}
	}
	public class TrainCar : TrainCarBase
	{
		[SerializeField]
		private TrainCarBase _parentLocomotive;

		[SerializeField]
		protected float _distanceBehindParent = 0.1f;

		public float DistanceBehindParentScaled => scale * _distanceBehindParent;

		protected override void Awake()
		{
			base.Awake();
		}

		public override void UpdatePosition()
		{
			base.Distance = _parentLocomotive.Distance - DistanceBehindParentScaled;
			UpdateCarPosition();
			RotateCarWheels();
		}
	}
	public abstract class TrainCarBase : MonoBehaviour
	{
		private static Vector3 OFFSET = new Vector3(0f, 0.0195f, 0f);

		private const float WHEEL_RADIUS = 0.027f;

		private const float TWO_PI = (float)Math.PI * 2f;

		[SerializeField]
		protected Transform _frontWheels;

		[SerializeField]
		protected Transform _rearWheels;

		[SerializeField]
		protected TrainTrack _trainTrack;

		[SerializeField]
		protected Transform[] _individualWheels;

		protected float scale = 1f;

		private Pose _frontPose = new Pose();

		private Pose _rearPose = new Pose();

		public float Distance { get; protected set; }

		public float Scale
		{
			get
			{
				return scale;
			}
			set
			{
				scale = value;
			}
		}

		protected virtual void Awake()
		{
		}

		public void UpdatePose(float distance, TrainCarBase train, Pose pose)
		{
			distance = (train._trainTrack.TrackLength + distance) % train._trainTrack.TrackLength;
			if (distance < 0f)
			{
				distance += train._trainTrack.TrackLength;
			}
			TrackSegment segment = train._trainTrack.GetSegment(distance);
			float distanceIntoSegment = distance - segment.StartDistance;
			segment.UpdatePose(distanceIntoSegment, pose);
		}

		protected void UpdateCarPosition()
		{
			UpdatePose(Distance + _frontWheels.transform.localPosition.z * scale, this, _frontPose);
			UpdatePose(Distance + _rearWheels.transform.localPosition.z * scale, this, _rearPose);
			Vector3 vector = 0.5f * (_frontPose.Position + _rearPose.Position);
			Vector3 forward = _frontPose.Position - _rearPose.Position;
			base.transform.position = vector + OFFSET;
			base.transform.rotation = Quaternion.LookRotation(forward, base.transform.up);
			_frontWheels.transform.rotation = _frontPose.Rotation;
			_rearWheels.transform.rotation = _rearPose.Rotation;
		}

		protected void RotateCarWheels()
		{
			float num = Distance / 0.027f % ((float)Math.PI * 2f);
			Transform[] individualWheels = _individualWheels;
			for (int i = 0; i < individualWheels.Length; i++)
			{
				individualWheels[i].localRotation = Quaternion.AngleAxis(57.29578f * num, Vector3.right);
			}
		}

		public abstract void UpdatePosition();
	}
	public class TrainCrossingController : MonoBehaviour
	{
		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip[] _crossingSounds;

		[SerializeField]
		private MeshRenderer _lightSide1Renderer;

		[SerializeField]
		private MeshRenderer _lightSide2Renderer;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private Material _lightsSide1Mat;

		private Material _lightsSide2Mat;

		private int _colorId = Shader.PropertyToID("_Color");

		private Coroutine _xingAnimationCr;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_lightsSide1Mat = _lightSide1Renderer.material;
			_lightsSide2Mat = _lightSide2Renderer.material;
		}

		private void OnDestroy()
		{
			if (_lightsSide1Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide1Mat);
			}
			if (_lightsSide2Mat != null)
			{
				UnityEngine.Object.Destroy(_lightsSide2Mat);
			}
		}

		public void CrossingButtonStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				ActivateTrainCrossing();
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}

		private void ActivateTrainCrossing()
		{
			int num = _crossingSounds.Length - 1;
			AudioClip audioClip = _crossingSounds[(int)(UnityEngine.Random.value * (float)num)];
			_audioSource.clip = audioClip;
			_audioSource.timeSamples = 0;
			_audioSource.Play();
			if (_xingAnimationCr != null)
			{
				StopCoroutine(_xingAnimationCr);
			}
			_xingAnimationCr = StartCoroutine(AnimateCrossing(audioClip.length * 0.75f));
		}

		private IEnumerator AnimateCrossing(float animationLength)
		{
			ToggleLightObjects(enableState: true);
			float animationEndTime = Time.time + animationLength;
			float lightBlinkDuration = animationLength * 0.1f;
			float lightBlinkStartTime = Time.time;
			float lightBlinkEndTime = Time.time + lightBlinkDuration;
			Material lightToBlinkOn = _lightsSide1Mat;
			Material lightToBlinkOff = _lightsSide2Mat;
			Color onColor = new Color(1f, 1f, 1f, 1f);
			Color offColor = new Color(1f, 1f, 1f, 0f);
			while (Time.time < animationEndTime)
			{
				float t = (Time.time - lightBlinkStartTime) / lightBlinkDuration;
				lightToBlinkOn.SetColor(_colorId, Color.Lerp(offColor, onColor, t));
				lightToBlinkOff.SetColor(_colorId, Color.Lerp(onColor, offColor, t));
				if (Time.time > lightBlinkEndTime)
				{
					Material material = lightToBlinkOn;
					lightToBlinkOn = lightToBlinkOff;
					lightToBlinkOff = material;
					lightBlinkStartTime = Time.time;
					lightBlinkEndTime = Time.time + lightBlinkDuration;
				}
				yield return null;
			}
			ToggleLightObjects(enableState: false);
		}

		private void AffectMaterials(Material[] materials, Color newColor)
		{
			for (int i = 0; i < materials.Length; i++)
			{
				materials[i].SetColor(_colorId, newColor);
			}
		}

		private void ToggleLightObjects(bool enableState)
		{
			_lightSide1Renderer.gameObject.SetActive(enableState);
			_lightSide2Renderer.gameObject.SetActive(enableState);
		}
	}
	public class TrainLocomotive : TrainCarBase
	{
		private enum EngineSoundState
		{
			Start,
			AccelerateOrSetProperSpeed,
			Stop
		}

		private const float MIN_SPEED = 0.2f;

		private const float MAX_SPEED = 2.7f;

		private const float SMOKE_SPEED_MULTIPLIER = 8f;

		private const int MAX_PARTICLES_MULTIPLIER = 3;

		[SerializeField]
		[Range(0.2f, 2.7f)]
		protected float _initialSpeed;

		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private GameObject _decreaseSpeedButton;

		[SerializeField]
		private GameObject _increaseSpeedButton;

		[SerializeField]
		private GameObject _smokeButton;

		[SerializeField]
		private GameObject _whistleButton;

		[SerializeField]
		private GameObject _reverseButton;

		[SerializeField]
		private AudioSource _whistleAudioSource;

		[SerializeField]
		private AudioClip _whistleSound;

		[SerializeField]
		private AudioSource _engineAudioSource;

		[SerializeField]
		private AudioClip[] _accelerationSounds;

		[SerializeField]
		private AudioClip[] _decelerationSounds;

		[SerializeField]
		private AudioClip _startUpSound;

		[SerializeField]
		private AudioSource _smokeStackAudioSource;

		[SerializeField]
		private AudioClip _smokeSound;

		[SerializeField]
		private ParticleSystem _smoke1;

		[SerializeField]
		private ParticleSystem _smoke2;

		[SerializeField]
		private TrainCarBase[] _childCars;

		private bool _isMoving = true;

		private bool _reverse;

		private float _currentSpeed;

		private float _speedDiv;

		private float _standardRateOverTimeMultiplier;

		private int _standardMaxParticles;

		private Coroutine _startStopTrainCr;

		private void Start()
		{
			_standardRateOverTimeMultiplier = _smoke1.emission.rateOverTimeMultiplier;
			_standardMaxParticles = _smoke1.main.maxParticles;
			base.Distance = 0f;
			_speedDiv = 2.5f / (float)_accelerationSounds.Length;
			_currentSpeed = _initialSpeed;
			UpdateCarPosition();
			_smoke1.Stop();
			_startStopTrainCr = StartCoroutine(StartStopTrain(startTrain: true));
		}

		private void Update()
		{
			UpdatePosition();
		}

		public override void UpdatePosition()
		{
			if (_isMoving)
			{
				if (_trainTrack != null)
				{
					UpdateDistance();
					UpdateCarPosition();
					RotateCarWheels();
				}
				TrainCarBase[] childCars = _childCars;
				for (int i = 0; i < childCars.Length; i++)
				{
					childCars[i].UpdatePosition();
				}
			}
		}

		public void StartStopStateChanged()
		{
			if (_startStopTrainCr == null)
			{
				_startStopTrainCr = StartCoroutine(StartStopTrain(!_isMoving));
			}
		}

		private IEnumerator StartStopTrain(bool startTrain)
		{
			float endSpeed = (startTrain ? _initialSpeed : 0f);
			float timePeriodForSpeedChange2;
			if (startTrain)
			{
				_smoke1.Play();
				_isMoving = true;
				ParticleSystem.EmissionModule emission = _smoke1.emission;
				ParticleSystem.MainModule main = _smoke1.main;
				emission.rateOverTimeMultiplier = _standardRateOverTimeMultiplier;
				main.maxParticles = _standardMaxParticles;
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Start);
			}
			else
			{
				timePeriodForSpeedChange2 = PlayEngineSound(EngineSoundState.Stop);
			}
			_engineAudioSource.loop = false;
			timePeriodForSpeedChange2 *= 0.9f;
			float startTime = Time.time;
			float endTime = Time.time + timePeriodForSpeedChange2;
			float startSpeed = _currentSpeed;
			while (Time.time < endTime)
			{
				float num = (Time.time - startTime) / timePeriodForSpeedChange2;
				_currentSpeed = startSpeed * (1f - num) + endSpeed * num;
				UpdateSmokeEmissionBasedOnSpeed();
				yield return null;
			}
			_currentSpeed = endSpeed;
			_startStopTrainCr = null;
			_isMoving = startTrain;
			if (!_isMoving)
			{
				_smoke1.Stop();
				yield break;
			}
			_engineAudioSource.loop = true;
			PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
		}

		private float PlayEngineSound(EngineSoundState engineSoundState)
		{
			AudioClip audioClip = null;
			if (engineSoundState == EngineSoundState.Start)
			{
				audioClip = _startUpSound;
			}
			else
			{
				AudioClip[] obj = ((engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed) ? _accelerationSounds : _decelerationSounds);
				int num = obj.Length;
				int value = (int)Mathf.Round((_currentSpeed - 0.2f) / _speedDiv);
				audioClip = obj[Mathf.Clamp(value, 0, num - 1)];
			}
			if (_engineAudioSource.clip == audioClip && _engineAudioSource.isPlaying && engineSoundState == EngineSoundState.AccelerateOrSetProperSpeed)
			{
				return 0f;
			}
			_engineAudioSource.clip = audioClip;
			_engineAudioSource.timeSamples = 0;
			_engineAudioSource.Play();
			return audioClip.length;
		}

		private void UpdateDistance()
		{
			float num = (_reverse ? (0f - _currentSpeed) : _currentSpeed);
			base.Distance = (base.Distance + num * Time.deltaTime) % _trainTrack.TrackLength;
		}

		public void DecreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed - _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		public void IncreaseSpeedStateChanged()
		{
			if (_startStopTrainCr == null && _isMoving)
			{
				_currentSpeed = Mathf.Clamp(_currentSpeed + _speedDiv, 0.2f, 2.7f);
				UpdateSmokeEmissionBasedOnSpeed();
				PlayEngineSound(EngineSoundState.AccelerateOrSetProperSpeed);
			}
		}

		private void UpdateSmokeEmissionBasedOnSpeed()
		{
			ParticleSystem.EmissionModule emission = _smoke1.emission;
			emission.rateOverTimeMultiplier = GetCurrentSmokeEmission();
			ParticleSystem.MainModule main = _smoke1.main;
			main.maxParticles = (int)Mathf.Lerp(_standardMaxParticles, _standardMaxParticles * 3, _currentSpeed / 2.5f);
		}

		private float GetCurrentSmokeEmission()
		{
			return Mathf.Lerp(_standardRateOverTimeMultiplier, _standardRateOverTimeMultiplier * 8f, _currentSpeed / 2.5f);
		}

		public void SmokeButtonStateChanged()
		{
			if (_isMoving)
			{
				_smokeStackAudioSource.clip = _smokeSound;
				_smokeStackAudioSource.timeSamples = 0;
				_smokeStackAudioSource.Play();
				_smoke2.time = 0f;
				_smoke2.Play();
			}
		}

		public void WhistleButtonStateChanged()
		{
			if (_whistleSound != null)
			{
				_whistleAudioSource.clip = _whistleSound;
				_whistleAudioSource.timeSamples = 0;
				_whistleAudioSource.Play();
			}
		}

		public void ReverseButtonStateChanged()
		{
			_reverse = !_reverse;
		}
	}
	public class TrainTrack : MonoBehaviour
	{
		[SerializeField]
		private float _gridSize = 0.5f;

		[SerializeField]
		private int _subDivCount = 20;

		[SerializeField]
		private Transform _segmentParent;

		[SerializeField]
		private Transform _trainParent;

		[SerializeField]
		private bool _regnerateTrackMeshOnAwake;

		private float _trainLength = -1f;

		private TrackSegment[] _trackSegments;

		public float TrackLength
		{
			get
			{
				return _trainLength;
			}
			private set
			{
				_trainLength = value;
			}
		}

		private void Awake()
		{
			Regenerate();
		}

		public TrackSegment GetSegment(float distance)
		{
			int childCount = _segmentParent.childCount;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment = _trackSegments[i];
				TrackSegment trackSegment2 = _trackSegments[(i + 1) % childCount];
				if (distance >= trackSegment.StartDistance && (distance < trackSegment2.StartDistance || i == childCount - 1))
				{
					return trackSegment;
				}
			}
			return null;
		}

		public void Regenerate()
		{
			_trackSegments = _segmentParent.GetComponentsInChildren<TrackSegment>();
			TrackLength = 0f;
			int childCount = _segmentParent.childCount;
			TrackSegment trackSegment = null;
			float scale = 0f;
			for (int i = 0; i < childCount; i++)
			{
				TrackSegment trackSegment2 = _trackSegments[i];
				trackSegment2.SubDivCount = _subDivCount;
				scale = trackSegment2.setGridSize(_gridSize);
				if (trackSegment != null)
				{
					Pose endPose = trackSegment.EndPose;
					trackSegment2.transform.position = endPose.Position;
					trackSegment2.transform.rotation = endPose.Rotation;
					trackSegment2.StartDistance = TrackLength;
				}
				if (_regnerateTrackMeshOnAwake)
				{
					trackSegment2.RegenerateTrackAndMesh();
				}
				TrackLength += trackSegment2.SegmentLength;
				trackSegment = trackSegment2;
			}
			SetScale(scale);
		}

		private void SetScale(float ratio)
		{
			_trainParent.localScale = new Vector3(ratio, ratio, ratio);
			TrainCar[] componentsInChildren = _trainParent.GetComponentsInChildren<TrainCar>();
			_trainParent.GetComponentInChildren<TrainLocomotive>().Scale = ratio;
			TrainCar[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Scale = ratio;
			}
		}
	}
	public class Pose
	{
		public Vector3 Position;

		public Quaternion Rotation;

		public Pose()
		{
			Position = Vector3.zero;
			Rotation = Quaternion.identity;
		}

		public Pose(Vector3 position, Quaternion rotation)
		{
			Position = position;
			Rotation = rotation;
		}
	}
	public class WindmillBladesController : MonoBehaviour
	{
		private const float MAX_TIME = 1f;

		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private AudioClip _windMillRotationSound;

		[SerializeField]
		private AudioClip _windMillStartSound;

		[SerializeField]
		private AudioClip _windMillStopSound;

		private float _currentSpeed;

		private Coroutine _lerpSpeedCoroutine;

		private Coroutine _audioChangeCr;

		private Quaternion _originalRotation;

		private float _rotAngle;

		public bool IsMoving { get; private set; }

		private void Start()
		{
			_originalRotation = base.transform.localRotation;
		}

		private void Update()
		{
			_rotAngle += _currentSpeed * Time.deltaTime;
			if (_rotAngle > 360f)
			{
				_rotAngle = 0f;
			}
			base.transform.localRotation = _originalRotation * Quaternion.AngleAxis(_rotAngle, Vector3.forward);
		}

		public void SetMoveState(bool newMoveState, float goalSpeed)
		{
			IsMoving = newMoveState;
			if (_lerpSpeedCoroutine != null)
			{
				StopCoroutine(_lerpSpeedCoroutine);
			}
			_lerpSpeedCoroutine = StartCoroutine(LerpToSpeed(goalSpeed));
		}

		private IEnumerator LerpToSpeed(float goalSpeed)
		{
			float totalTime = 0f;
			float startSpeed = _currentSpeed;
			if (_audioChangeCr != null)
			{
				StopCoroutine(_audioChangeCr);
			}
			if (IsMoving)
			{
				_audioChangeCr = StartCoroutine(PlaySoundDelayed(_windMillStartSound, _windMillRotationSound, _windMillStartSound.length * 0.95f));
			}
			else
			{
				PlaySound(_windMillStopSound);
			}
			for (float num = Mathf.Abs(_currentSpeed - goalSpeed); num > Mathf.Epsilon; num = Mathf.Abs(_currentSpeed - goalSpeed))
			{
				_currentSpeed = Mathf.Lerp(startSpeed, goalSpeed, totalTime / 1f);
				totalTime += Time.deltaTime;
				yield return null;
			}
			_lerpSpeedCoroutine = null;
		}

		private IEnumerator PlaySoundDelayed(AudioClip initial, AudioClip clip, float timeDelayAfterInitial)
		{
			PlaySound(initial);
			yield return new WaitForSeconds(timeDelayAfterInitial);
			PlaySound(clip, loop: true);
		}

		private void PlaySound(AudioClip clip, bool loop = false)
		{
			_audioSource.loop = loop;
			_audioSource.timeSamples = 0;
			_audioSource.clip = clip;
			_audioSource.Play();
		}
	}
	public class WindmillController : MonoBehaviour
	{
		[SerializeField]
		private GameObject _startStopButton;

		[SerializeField]
		private float _maxSpeed = 10f;

		[SerializeField]
		private SelectionCylinder _selectionCylinder;

		private WindmillBladesController _bladesRotation;

		private InteractableTool _toolInteractingWithMe;

		private void Awake()
		{
			_bladesRotation = GetComponentInChildren<WindmillBladesController>();
			_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
		}

		private void OnEnable()
		{
			_startStopButton.GetComponent<Interactable>().InteractableStateChanged.AddListener(StartStopStateChanged);
		}

		private void OnDisable()
		{
			if (_startStopButton != null)
			{
				_startStopButton.GetComponent<Interactable>().InteractableStateChanged.RemoveListener(StartStopStateChanged);
			}
		}

		private void StartStopStateChanged(InteractableStateArgs obj)
		{
			if (obj.NewInteractableState == InteractableState.ActionState)
			{
				if (_bladesRotation.IsMoving)
				{
					_bladesRotation.SetMoveState(newMoveState: false, 0f);
				}
				else
				{
					_bladesRotation.SetMoveState(newMoveState: true, _maxSpeed);
				}
			}
			_toolInteractingWithMe = ((obj.NewInteractableState > InteractableState.Default) ? obj.Tool : null);
		}

		private void Update()
		{
			if (_toolInteractingWithMe == null)
			{
				_selectionCylinder.CurrSelectionState = SelectionCylinder.SelectionState.Off;
			}
			else
			{
				_selectionCylinder.CurrSelectionState = ((_toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDown && _toolInteractingWithMe.ToolInputState != ToolInputState.PrimaryInputDownStay) ? SelectionCylinder.SelectionState.Selected : SelectionCylinder.SelectionState.Highlighted);
			}
		}
	}
	public enum EUiDisplayType
	{
		EUDT_WorldGeoQuad,
		EUDT_OverlayQuad,
		EUDT_None,
		EUDT_MaxDislayTypes
	}
	public class OVROverlaySample : MonoBehaviour
	{
		private bool inMenu;

		private const string ovrOverlayID = "OVROverlayID";

		private const string applicationID = "ApplicationID";

		private const string noneID = "NoneID";

		private Toggle applicationRadioButton;

		private Toggle noneRadioButton;

		[Header("App vs Compositor Comparison Settings")]
		public GameObject mainCamera;

		public GameObject uiCamera;

		public GameObject uiGeoParent;

		public GameObject worldspaceGeoParent;

		public OVROverlay cameraRenderOverlay;

		public OVROverlay renderingLabelOverlay;

		public Texture applicationLabelTexture;

		public Texture compositorLabelTexture;

		[Header("Level Loading Sim Settings")]
		public GameObject prefabForLevelLoadSim;

		public OVROverlay cubemapOverlay;

		public OVROverlay loadingTextQuadOverlay;

		public float distanceFromCamToLoadText;

		public float cubeSpawnRadius;

		public float heightBetweenItems;

		public int numObjectsPerLevel;

		public int numLevels;

		public int numLoopsTrigger = 500000000;

		private List<GameObject> spawnedCubes = new List<GameObject>();

		private void Start()
		{
			DebugUIBuilder.instance.AddLabel("OVROverlay Sample");
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("Level Loading Example");
			DebugUIBuilder.instance.AddButton("Simulate Level Load", TriggerLoad);
			DebugUIBuilder.instance.AddButton("Destroy Cubes", TriggerUnload);
			DebugUIBuilder.instance.AddDivider();
			DebugUIBuilder.instance.AddLabel("OVROverlay vs. Application Render Comparison");
			DebugUIBuilder.instance.AddRadio("OVROverlay", "group", delegate(Toggle t)
			{
				RadioPressed("OVROverlayID", "group", t);
			}).GetComponentInChildren<Toggle>();
			applicationRadioButton = DebugUIBuilder.instance.AddRadio("Application", "group", delegate(Toggle t)
			{
				RadioPressed("ApplicationID", "group", t);
			}).GetComponentInChildren<Toggle>();
			noneRadioButton = DebugUIBuilder.instance.AddRadio("None", "group", delegate(Toggle t)
			{
				RadioPressed("NoneID", "group", t);
			}).GetComponentInChildren<Toggle>();
			DebugUIBuilder.instance.Show();
			CameraAndRenderTargetSetup();
			cameraRenderOverlay.enabled = true;
			cameraRenderOverlay.currentOverlayShape = OVROverlay.OverlayShape.Quad;
			spawnedCubes.Capacity = numObjectsPerLevel * numLevels;
		}

		private void Update()
		{
			if (OVRInput.GetDown(OVRInput.Button.Two) || OVRInput.GetDown(OVRInput.Button.Start))
			{
				if (inMenu)
				{
					DebugUIBuilder.instance.Hide();
				}
				else
				{
					DebugUIBuilder.instance.Show();
				}
				inMenu = !inMenu;
			}
			if (Input.GetKeyDown(KeyCode.A))
			{
				TriggerLoad();
			}
		}

		private void ActivateWorldGeo()
		{
			worldspaceGeoParent.SetActive(value: true);
			uiGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = applicationLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateWorldGeo");
		}

		private void ActivateOVROverlay()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: true);
			cameraRenderOverlay.enabled = true;
			uiGeoParent.SetActive(value: true);
			renderingLabelOverlay.enabled = true;
			renderingLabelOverlay.textures[0] = compositorLabelTexture;
			UnityEngine.Debug.Log("Switched to ActivateOVROVerlay");
		}

		private void ActivateNone()
		{
			worldspaceGeoParent.SetActive(value: false);
			uiCamera.SetActive(value: false);
			cameraRenderOverlay.enabled = false;
			uiGeoParent.SetActive(value: false);
			renderingLabelOverlay.enabled = false;
			UnityEngine.Debug.Log("Switched to ActivateNone");
		}

		private void TriggerLoad()
		{
			StartCoroutine(WaitforOVROverlay());
		}

		private IEnumerator WaitforOVROverlay()
		{
			Transform transform = mainCamera.transform;
			Transform obj = loadingTextQuadOverlay.transform;
			Vector3 position = transform.position + transform.forward * distanceFromCamToLoadText;
			position.y = transform.position.y;
			obj.position = position;
			cubemapOverlay.enabled = true;
			loadingTextQuadOverlay.enabled = true;
			noneRadioButton.isOn = true;
			yield return new WaitForSeconds(0.1f);
			ClearObjects();
			SimulateLevelLoad();
			cubemapOverlay.enabled = false;
			loadingTextQuadOverlay.enabled = false;
			yield return null;
		}

		private void TriggerUnload()
		{
			ClearObjects();
			applicationRadioButton.isOn = true;
		}

		private void CameraAndRenderTargetSetup()
		{
			float x = cameraRenderOverlay.transform.localScale.x;
			float y = cameraRenderOverlay.transform.localScale.y;
			float z = cameraRenderOverlay.transform.localScale.z;
			float num = 1440f;
			float num2 = 2560f * 0.5f;
			float num3 = mainCamera.GetComponent<Camera>().fieldOfView / 2f;
			float num4 = 2f * z * Mathf.Tan((float)Math.PI / 180f * num3);
			float num5 = num / num4 * x;
			float num6 = 0f;
			float num7 = num4 * mainCamera.GetComponent<Camera>().aspect;
			num6 = num2 / num7 * x;
			float orthographicSize = y / 2f;
			float aspect = x / y;
			uiCamera.GetComponent<Camera>().orthographicSize = orthographicSize;
			uiCamera.GetComponent<Camera>().aspect = aspect;
			if (uiCamera.GetComponent<Camera>().targetTexture != null)
			{
				uiCamera.GetComponent<Camera>().targetTexture.Release();
			}
			RenderTexture renderTexture = new RenderTexture((int)num6 * 2, (int)num5 * 2, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.sRGB);
			UnityEngine.Debug.Log("Created RT of resolution w: " + num6 + " and h: " + num5);
			renderTexture.hideFlags = HideFlags.DontSave;
			renderTexture.useMipMap = true;
			renderTexture.filterMode = FilterMode.Trilinear;
			renderTexture.anisoLevel = 4;
			renderTexture.autoGenerateMips = true;
			uiCamera.GetComponent<Camera>().targetTexture = renderTexture;
			cameraRenderOverlay.textures[0] = renderTexture;
		}

		private void SimulateLevelLoad()
		{
			int num = 0;
			for (int i = 0; i < numLoopsTrigger; i++)
			{
				num++;
			}
			UnityEngine.Debug.Log("Finished " + num + " Loops");
			Vector3 position = mainCamera.transform.position;
			position.y = 0.5f;
			for (int j = 0; j < numLevels; j++)
			{
				for (int k = 0; k < numObjectsPerLevel; k++)
				{
					float f = (float)k * (float)Math.PI * 2f / (float)numObjectsPerLevel;
					float num2 = ((k % 2 == 0) ? 1.5f : 1f);
					Vector3 vector = new Vector3(Mathf.Cos(f), 0f, Mathf.Sin(f)) * cubeSpawnRadius * num2;
					vector.y = (float)j * heightBetweenItems;
					GameObject gameObject = UnityEngine.Object.Instantiate(prefabForLevelLoadSim, vector + position, Quaternion.identity);
					Transform obj = gameObject.transform;
					obj.LookAt(position);
					Vector3 eulerAngles = obj.rotation.eulerAngles;
					eulerAngles.x = 0f;
					obj.rotation = Quaternion.Euler(eulerAngles);
					spawnedCubes.Add(gameObject);
				}
			}
		}

		private void ClearObjects()
		{
			for (int i = 0; i < spawnedCubes.Count; i++)
			{
				UnityEngine.Object.DestroyImmediate(spawnedCubes[i]);
			}
			spawnedCubes.Clear();
			GC.Collect();
		}

		public void RadioPressed(string radioLabel, string group, Toggle t)
		{
			if (string.Compare(radioLabel, "OVROverlayID") == 0)
			{
				ActivateOVROverlay();
			}
			else if (string.Compare(radioLabel, "ApplicationID") == 0)
			{
				ActivateWorldGeo();
			}
			else if (string.Compare(radioLabel, "NoneID") == 0)
			{
				ActivateNone();
			}
		}
	}
}
namespace OVRTouchSample
{
	[RequireComponent(typeof(OVRGrabber))]
	public class Hand : MonoBehaviour
	{
		public const string ANIM_LAYER_NAME_POINT = "Point Layer";

		public const string ANIM_LAYER_NAME_THUMB = "Thumb Layer";

		public const string ANIM_PARAM_NAME_FLEX = "Flex";

		public const string ANIM_PARAM_NAME_POSE = "Pose";

		public const float THRESH_COLLISION_FLEX = 0.9f;

		public const float INPUT_RATE_CHANGE = 20f;

		public const float COLLIDER_SCALE_MIN = 0.01f;

		public const float COLLIDER_SCALE_MAX = 1f;

		public const float COLLIDER_SCALE_PER_SECOND = 1f;

		public const float TRIGGER_DEBOUNCE_TIME = 0.05f;

		public const float THUMB_DEBOUNCE_TIME = 0.15f;

		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		[SerializeField]
		private HandPose m_defaultGrabPose;

		private Collider[] m_colliders;

		private bool m_collisionEnabled = true;

		private OVRGrabber m_grabber;

		private List<Renderer> m_showAfterInputFocusAcquired;

		private int m_animLayerIndexThumb = -1;

		private int m_animLayerIndexPoint = -1;

		private int m_animParamIndexFlex = -1;

		private int m_animParamIndexPose = -1;

		private bool m_isPointing;

		private bool m_isGivingThumbsUp;

		private float m_pointBlend;

		private float m_thumbsUpBlend;

		private bool m_restoreOnInputAcquired;

		private float m_collisionScaleCurrent;

		private void Awake()
		{
			m_grabber = GetComponent<OVRGrabber>();
		}

		private void Start()
		{
			m_showAfterInputFocusAcquired = new List<Renderer>();
			m_colliders = (from childCollider in GetComponentsInChildren<Collider>()
				where !childCollider.isTrigger
				select childCollider).ToArray();
			CollisionEnable(enabled: false);
			m_animLayerIndexPoint = m_animator.GetLayerIndex("Point Layer");
			m_animLayerIndexThumb = m_animator.GetLayerIndex("Thumb Layer");
			m_animParamIndexFlex = Animator.StringToHash("Flex");
			m_animParamIndexPose = Animator.StringToHash("Pose");
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnDestroy()
		{
			OVRManager.InputFocusAcquired -= OnInputFocusAcquired;
			OVRManager.InputFocusLost -= OnInputFocusLost;
		}

		private void Update()
		{
			UpdateCapTouchStates();
			m_pointBlend = InputValueRateChange(m_isPointing, m_pointBlend);
			m_thumbsUpBlend = InputValueRateChange(m_isGivingThumbsUp, m_thumbsUpBlend);
			float num = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			bool flag = m_grabber.grabbedObject == null && num >= 0.9f;
			CollisionEnable(flag);
			UpdateAnimStates();
		}

		private void UpdateCapTouchStates()
		{
			m_isPointing = !OVRInput.Get(OVRInput.NearTouch.PrimaryIndexTrigger, m_controller);
			m_isGivingThumbsUp = !OVRInput.Get(OVRInput.NearTouch.PrimaryThumbButtons, m_controller);
		}

		private void LateUpdate()
		{
			if (m_collisionEnabled && m_collisionScaleCurrent + Mathf.Epsilon < 1f)
			{
				m_collisionScaleCurrent = Mathf.Min(1f, m_collisionScaleCurrent + Time.deltaTime * 1f);
				for (int i = 0; i < m_colliders.Length; i++)
				{
					m_colliders[i].transform.localScale = new Vector3(m_collisionScaleCurrent, m_collisionScaleCurrent, m_collisionScaleCurrent);
				}
			}
		}

		private void OnInputFocusLost()
		{
			if (!base.gameObject.activeInHierarchy)
			{
				return;
			}
			m_showAfterInputFocusAcquired.Clear();
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				if (componentsInChildren[i].enabled)
				{
					componentsInChildren[i].enabled = false;
					m_showAfterInputFocusAcquired.Add(componentsInChildren[i]);
				}
			}
			CollisionEnable(enabled: false);
			m_restoreOnInputAcquired = true;
		}

		private void OnInputFocusAcquired()
		{
			if (!m_restoreOnInputAcquired)
			{
				return;
			}
			for (int i = 0; i < m_showAfterInputFocusAcquired.Count; i++)
			{
				if ((bool)m_showAfterInputFocusAcquired[i])
				{
					m_showAfterInputFocusAcquired[i].enabled = true;
				}
			}
			m_showAfterInputFocusAcquired.Clear();
			m_restoreOnInputAcquired = false;
		}

		private float InputValueRateChange(bool isDown, float value)
		{
			float num = Time.deltaTime * 20f;
			float num2 = (isDown ? 1f : (-1f));
			return Mathf.Clamp01(value + num * num2);
		}

		private void UpdateAnimStates()
		{
			bool num = m_grabber.grabbedObject != null;
			HandPose handPose = m_defaultGrabPose;
			if (num)
			{
				HandPose component = m_grabber.grabbedObject.GetComponent<HandPose>();
				if (component != null)
				{
					handPose = component;
				}
			}
			HandPoseId poseId = handPose.PoseId;
			m_animator.SetInteger(m_animParamIndexPose, (int)poseId);
			float value = OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller);
			m_animator.SetFloat(m_animParamIndexFlex, value);
			float weight = ((!num || handPose.AllowPointing) ? m_pointBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexPoint, weight);
			float weight2 = ((!num || handPose.AllowThumbsUp) ? m_thumbsUpBlend : 0f);
			m_animator.SetLayerWeight(m_animLayerIndexThumb, weight2);
			float value2 = OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller);
			m_animator.SetFloat("Pinch", value2);
		}

		private void CollisionEnable(bool enabled)
		{
			if (m_collisionEnabled == enabled)
			{
				return;
			}
			m_collisionEnabled = enabled;
			if (enabled)
			{
				m_collisionScaleCurrent = 0.01f;
				for (int i = 0; i < m_colliders.Length; i++)
				{
					Collider obj = m_colliders[i];
					obj.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
					obj.enabled = true;
				}
			}
			else
			{
				m_collisionScaleCurrent = 1f;
				for (int j = 0; j < m_colliders.Length; j++)
				{
					Collider obj2 = m_colliders[j];
					obj2.enabled = false;
					obj2.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
				}
			}
		}
	}
	public enum HandPoseId
	{
		Default,
		Generic,
		PingPongBall,
		Controller
	}
	public class HandPose : MonoBehaviour
	{
		[SerializeField]
		private bool m_allowPointing;

		[SerializeField]
		private bool m_allowThumbsUp;

		[SerializeField]
		private HandPoseId m_poseId;

		public bool AllowPointing => m_allowPointing;

		public bool AllowThumbsUp => m_allowThumbsUp;

		public HandPoseId PoseId => m_poseId;
	}
	public class TouchController : MonoBehaviour
	{
		[SerializeField]
		private OVRInput.Controller m_controller;

		[SerializeField]
		private Animator m_animator;

		private bool m_restoreOnInputAcquired;

		private void Update()
		{
			m_animator.SetFloat("Button 1", OVRInput.Get(OVRInput.Button.One, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Button 2", OVRInput.Get(OVRInput.Button.Two, m_controller) ? 1f : 0f);
			m_animator.SetFloat("Joy X", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).x);
			m_animator.SetFloat("Joy Y", OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick, m_controller).y);
			m_animator.SetFloat("Grip", OVRInput.Get(OVRInput.Axis1D.PrimaryHandTrigger, m_controller));
			m_animator.SetFloat("Trigger", OVRInput.Get(OVRInput.Axis1D.PrimaryIndexTrigger, m_controller));
			OVRManager.InputFocusAcquired += OnInputFocusAcquired;
			OVRManager.InputFocusLost += OnInputFocusLost;
		}

		private void OnInputFocusLost()
		{
			if (base.gameObject.activeInHierarchy)
			{
				base.gameObject.SetActive(value: false);
				m_restoreOnInputAcquired = true;
			}
		}

		private void OnInputFocusAcquired()
		{
			if (m_restoreOnInputAcquired)
			{
				base.gameObject.SetActive(value: true);
				m_restoreOnInputAcquired = false;
			}
		}
	}
}
namespace Oculus.Spatializer.Propagation
{
	public enum FaceType : uint
	{
		TRIANGLES,
		QUADS
	}
	public enum MaterialProperty : uint
	{
		ABSORPTION,
		TRANSMISSION,
		SCATTERING
	}
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct MeshGroup
	{
		public UIntPtr indexOffset;

		public UIntPtr faceCount;

		[MarshalAs(UnmanagedType.U4)]
		public FaceType faceType;

		public IntPtr material;
	}
}
namespace Oculus.Avatar
{
	public static class AvatarLogger
	{
		public const string LogAvatar = "[Avatars] - ";

		public const string Tab = "    ";

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_BASIC")]
		public static void Log(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.Log("[Avatars] - " + logMsg, context);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_WARNING")]
		public static void LogWarning(string logMsg)
		{
			UnityEngine.Debug.LogWarning("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg);
		}

		[Conditional("ENABLE_AVATAR_LOGS")]
		[Conditional("ENABLE_AVATAR_LOG_ERROR")]
		public static void LogError(string logMsg, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogError("[Avatars] - " + logMsg, context);
		}
	}
	public class CAPI
	{
		public delegate void LoggingDelegate(IntPtr str);

		public enum Result
		{
			Success = 0,
			Failure = -1000,
			Failure_InvalidParameter = -1001,
			Failure_NotInitialized = -1002,
			Failure_InvalidOperation = -1003,
			Failure_Unsupported = -1004,
			Failure_NotYetImplemented = -1005,
			Failure_OperationFailed = -1006,
			Failure_InsufficientSize = -1007
		}

		private static class OVRP_1_30_0
		{
			public static readonly Version version = new Version(1, 30, 0);

			[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl)]
			public static extern Result ovrp_SendEvent2(string name, string param, string source);
		}

		private const string LibFile = "ovravatarloader";

		private static IntPtr nativeVisemeData = IntPtr.Zero;

		private static IntPtr nativeGazeTargetsData = IntPtr.Zero;

		private static IntPtr nativeAvatarLightsData = IntPtr.Zero;

		private static IntPtr DebugLineCountData = IntPtr.Zero;

		private static float[] scratchBufferFloat = new float[16];

		private static GameObject debugLineGo;

		private static string SDKRuntimePrefix = "[RUNTIME] - ";

		private const string ovrPluginDLL = "OVRPlugin";

		private static Version ovrPluginVersion;

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_InitializeAndroidUnity(string appID);

		public static void Initialize()
		{
			nativeVisemeData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarVisemes)));
			nativeGazeTargetsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarGazeTargets)));
			nativeAvatarLightsData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarLights)));
			DebugLineCountData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			debugLineGo = new GameObject();
			debugLineGo.name = "AvatarSDKDebugDrawHelper";
		}

		public static void Shutdown()
		{
			Marshal.FreeHGlobal(nativeVisemeData);
			Marshal.FreeHGlobal(nativeGazeTargetsData);
			Marshal.FreeHGlobal(nativeAvatarLightsData);
			Marshal.FreeHGlobal(DebugLineCountData);
			debugLineGo = null;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Shutdown();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarMessage_Pop();

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMessageType ovrAvatarMessage_GetType(IntPtr msg);

		public static ovrAvatarMessage_AvatarSpecification ovrAvatarMessage_GetAvatarSpecification(IntPtr msg)
		{
			return (ovrAvatarMessage_AvatarSpecification)Marshal.PtrToStructure(ovrAvatarMessage_GetAvatarSpecification_Native(msg), typeof(ovrAvatarMessage_AvatarSpecification));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAvatarSpecification")]
		private static extern IntPtr ovrAvatarMessage_GetAvatarSpecification_Native(IntPtr msg);

		public static ovrAvatarMessage_AssetLoaded ovrAvatarMessage_GetAssetLoaded(IntPtr msg)
		{
			return (ovrAvatarMessage_AssetLoaded)Marshal.PtrToStructure(ovrAvatarMessage_GetAssetLoaded_Native(msg), typeof(ovrAvatarMessage_AssetLoaded));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarMessage_GetAssetLoaded")]
		private static extern IntPtr ovrAvatarMessage_GetAssetLoaded_Native(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarMessage_Free(IntPtr msg);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarSpecificationRequest_Create(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_Destroy(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetCombineMeshes(IntPtr specificationRequest, bool useCombinedMesh);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetLevelOfDetail(IntPtr specificationRequest, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecification(ulong userID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RequestAvatarSpecificationFromSpecRequest(IntPtr specificationRequest);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetFallbackLookAndFeelVersion(IntPtr specificationRequest, ovrAvatarLookAndFeelVersion version);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarSpecificationRequest_SetExpressiveFlag(IntPtr specificationRequest, bool enable);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatar_Create(IntPtr avatarSpecification, ovrAvatarCapabilities capabilities);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_Destroy(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateBody(IntPtr avatar, ovrAvatarTransform headPose);

		public static void ovrAvatarPose_UpdateVoiceVisualization(IntPtr avatar, float[] pcmData)
		{
			ovrAvatarPose_UpdateVoiceVisualization_Native(avatar, (uint)pcmData.Length, pcmData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_UpdateVoiceVisualization")]
		private static extern void ovrAvatarPose_UpdateVoiceVisualization_Native(IntPtr avatar, uint pcmDataSize, [In] float[] pcmData);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHands(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_UpdateHandsWithType(IntPtr avatar, ovrAvatarHandInputState inputStateLeft, ovrAvatarHandInputState inputStateRight, ovrAvatarControllerType type);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPose_Finalize(IntPtr avatar, float elapsedSeconds);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightControllerVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandVisibility(IntPtr avatar, bool show);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarComponent_Count(IntPtr avatar);

		public static void ovrAvatarComponent_Get(IntPtr avatar, uint index, bool includeName, ref ovrAvatarComponent component)
		{
			ovrAvatarComponent_Get(ovrAvatarComponent_Get_Native(avatar, index), includeName, ref component);
		}

		public static void ovrAvatarComponent_Get(IntPtr componentPtr, bool includeName, ref ovrAvatarComponent component)
		{
			Marshal.Copy(new IntPtr(componentPtr.ToInt64() + ovrAvatarComponent_Offsets.transform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.transform);
			component.renderPartCount = (uint)Marshal.ReadInt32(componentPtr, ovrAvatarComponent_Offsets.renderPartCount);
			component.renderParts = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.renderParts);
			if (includeName)
			{
				IntPtr ptr = Marshal.ReadIntPtr(componentPtr, ovrAvatarComponent_Offsets.name);
				component.name = Marshal.PtrToStringAnsi(ptr);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarComponent_Get")]
		public static extern IntPtr ovrAvatarComponent_Get_Native(IntPtr avatar, uint index);

		public static bool ovrAvatarPose_GetBaseComponent(IntPtr avatar, ref ovrAvatarBaseComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBaseComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarBaseComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBaseComponent")]
		private static extern IntPtr ovrAvatarPose_GetBaseComponent_Native(IntPtr avatar);

		public static IntPtr MarshalRenderComponent<T>(IntPtr ptr) where T : struct
		{
			return Marshal.ReadIntPtr(new IntPtr(ptr.ToInt64() + Marshal.OffsetOf(typeof(T), "renderComponent").ToInt64()));
		}

		public static bool ovrAvatarPose_GetBodyComponent(IntPtr avatar, ref ovrAvatarBodyComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetBodyComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.leftEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.leftEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.rightEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.rightEyeTransform);
			Marshal.Copy(new IntPtr(intPtr.ToInt64() + ovrAvatarBodyComponent_Offsets.centerEyeTransform), scratchBufferFloat, 0, 10);
			OvrAvatar.ConvertTransform(scratchBufferFloat, ref component.centerEyeTransform);
			component.renderComponent = MarshalRenderComponent<ovrAvatarBodyComponent>(intPtr);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetBodyComponent")]
		private static extern IntPtr ovrAvatarPose_GetBodyComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightControllerComponent(IntPtr avatar, ref ovrAvatarControllerComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightControllerComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarControllerComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightControllerComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightControllerComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetLeftHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetLeftHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetLeftHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetLeftHandComponent_Native(IntPtr avatar);

		public static bool ovrAvatarPose_GetRightHandComponent(IntPtr avatar, ref ovrAvatarHandComponent component)
		{
			IntPtr intPtr = ovrAvatarPose_GetRightHandComponent_Native(avatar);
			if (intPtr == IntPtr.Zero)
			{
				return false;
			}
			int ofs = Marshal.SizeOf(typeof(ovrAvatarHandComponent)) - Marshal.SizeOf(typeof(IntPtr));
			component.renderComponent = Marshal.ReadIntPtr(intPtr, ofs);
			return true;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarPose_GetRightHandComponent")]
		private static extern IntPtr ovrAvatarPose_GetRightHandComponent_Native(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarAsset_BeginLoading(ulong assetID);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarAsset_BeginLoadingLOD(ulong assetId, ovrAvatarAssetLevelOfDetail lod);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarAssetType ovrAvatarAsset_GetType(IntPtr assetHandle);

		public static ovrAvatarMeshAssetData ovrAvatarAsset_GetMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetData));
		}

		public static ovrAvatarMeshAssetDataV2 ovrAvatarAsset_GetCombinedMeshData(IntPtr assetPtr)
		{
			return (ovrAvatarMeshAssetDataV2)Marshal.PtrToStructure(ovrAvatarAsset_GetCombinedMeshData_Native(assetPtr), typeof(ovrAvatarMeshAssetDataV2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetCombinedMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMeshData")]
		private static extern IntPtr ovrAvatarAsset_GetMeshData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetMeshBlendShapeCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeName(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshCount(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarAsset_GetSubmeshLastIndex(IntPtr assetPtr, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetMeshBlendShapeVertices(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarAsset_GetAvatar(IntPtr assetHandle);

		public static ulong[] ovrAvatarAsset_GetCombinedMeshIDs(IntPtr assetHandle)
		{
			uint structure = 0u;
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(structure));
			IntPtr ptr = ovrAvatarAsset_GetCombinedMeshIDs_Native(assetHandle, intPtr);
			structure = (uint)Marshal.PtrToStructure(intPtr, typeof(uint));
			ulong[] array = new ulong[structure];
			for (int i = 0; i < structure; i++)
			{
				array[i] = (ulong)Marshal.ReadInt64(ptr, i * Marshal.SizeOf(typeof(ulong)));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetCombinedMeshIDs")]
		public static extern IntPtr ovrAvatarAsset_GetCombinedMeshIDs_Native(IntPtr assetHandle, IntPtr count);

		public static void ovrAvatar_GetCombinedMeshAlphaData(IntPtr avatar, ref ulong textureID, ref Vector4 offset)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ulong)));
			IntPtr intPtr2 = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Vector4)));
			ovrAvatar_GetCombinedMeshAlphaData_Native(avatar, intPtr, intPtr2);
			textureID = (ulong)Marshal.PtrToStructure(intPtr, typeof(ulong));
			offset = (Vector4)Marshal.PtrToStructure(intPtr2, typeof(Vector4));
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetCombinedMeshAlphaData")]
		public static extern IntPtr ovrAvatar_GetCombinedMeshAlphaData_Native(IntPtr avatar, IntPtr textureIDPtr, IntPtr offsetPtr);

		public static ovrAvatarTextureAssetData ovrAvatarAsset_GetTextureData(IntPtr assetPtr)
		{
			return (ovrAvatarTextureAssetData)Marshal.PtrToStructure(ovrAvatarAsset_GetTextureData_Native(assetPtr), typeof(ovrAvatarTextureAssetData));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetTextureData")]
		private static extern IntPtr ovrAvatarAsset_GetTextureData_Native(IntPtr assetPtr);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarAsset_GetMaterialData")]
		private static extern IntPtr ovrAvatarAsset_GetMaterialData_Native(IntPtr assetPtr);

		public static ovrAvatarMaterialState ovrAvatarAsset_GetMaterialState(IntPtr assetPtr)
		{
			return (ovrAvatarMaterialState)Marshal.PtrToStructure(ovrAvatarAsset_GetMaterialData_Native(assetPtr), typeof(ovrAvatarMaterialState));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarRenderPartType ovrAvatarRenderPart_GetType(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRender ovrAvatarRenderPart_GetSkinnedMeshRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRender_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRender));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetTransform(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRender_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRender_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarSkinnedMeshRenderPBSV2_MaterialStateChanged(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBS_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarVisibilityFlags ovrAvatarSkinnedMeshRenderPBSV2_GetVisibilityMask(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarMaterialState ovrAvatarSkinnedMeshRender_GetMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarPBSMaterialState ovrAvatarSkinnedMeshRenderPBSV2_GetPBSMaterialState(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarExpressiveParameters ovrAvatar_GetExpressiveParameters(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRender_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBSV2_GetDirtyJoints(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRender_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitOnsetSpeed(IntPtr avatar, float onsetSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetActionUnitFalloffSpeed(IntPtr avatar, float falloffSpeed);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetVisemeMultiplier(IntPtr avatar, float visemeMultiplier);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBS_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ovrAvatarTransform ovrAvatarSkinnedMeshRenderPBSV2_GetJointTransform(IntPtr renderPart, uint jointIndex);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetAlbedoTextureAssetID(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatarSkinnedMeshRenderPBS_GetSurfaceTextureAssetID(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS ovrAvatarRenderPart_GetSkinnedMeshRenderPBS(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBS")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBS_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2 ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2)Marshal.PtrToStructure(ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(renderPart), typeof(ovrAvatarRenderPart_SkinnedMeshRenderPBS_V2));
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2")]
		private static extern IntPtr ovrAvatarRenderPart_GetSkinnedMeshRenderPBSV2_Native(IntPtr renderPart);

		public static void ovrAvatarSkinnedMeshRender_GetBlendShapeParams(IntPtr renderPart, ref ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr ptr = ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(renderPart);
			blendParams.blendShapeParamCount = (uint)Marshal.ReadInt32(ptr);
			Marshal.Copy(new IntPtr(ptr.ToInt64() + ovrAvatarBlendShapeParams_Offsets.blendShapeParams), blendParams.blendShapeParams, 0, (int)blendParams.blendShapeParamCount);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarSkinnedMeshRender_GetBlendShapeParams")]
		private static extern IntPtr ovrAvatarSkinnedMeshRender_GetBlendShapeParams_Native(IntPtr renderPart);

		public static ovrAvatarRenderPart_ProjectorRender ovrAvatarRenderPart_GetProjectorRender(IntPtr renderPart)
		{
			return (ovrAvatarRenderPart_ProjectorRender)Marshal.PtrToStructure(ovrAvatarRenderPart_GetProjectorRender_Native(renderPart), typeof(ovrAvatarRenderPart_ProjectorRender));
		}

		public static ovrAvatarPBSMaterialState[] ovrAvatar_GetBodyPBSMaterialStates(IntPtr renderPart)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)));
			IntPtr intPtr2 = ovrAvatar_GetBodyPBSMaterialStates_Native(renderPart, intPtr);
			ovrAvatarPBSMaterialState[] array = new ovrAvatarPBSMaterialState[Marshal.ReadInt32(intPtr)];
			for (int i = 0; i < array.Length; i++)
			{
				IntPtr ptr = new IntPtr(intPtr2.ToInt64() + i * Marshal.SizeOf(typeof(ovrAvatarPBSMaterialState)));
				array[i] = (ovrAvatarPBSMaterialState)Marshal.PtrToStructure(ptr, typeof(ovrAvatarPBSMaterialState));
			}
			Marshal.FreeHGlobal(intPtr);
			return array;
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetBodyPBSMaterialStates")]
		private static extern IntPtr ovrAvatar_GetBodyPBSMaterialStates_Native(IntPtr avatar, IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatarRenderPart_GetProjectorRender")]
		private static extern IntPtr ovrAvatarRenderPart_GetProjectorRender_Native(IntPtr renderPart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatar_GetReferencedAssetCount(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern ulong ovrAvatar_GetReferencedAsset(IntPtr avatar, uint index);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandGesture(IntPtr avatar, ovrAvatarHandGesture gesture);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLeftHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetRightHandCustomGesture(IntPtr avatar, uint jointCount, [In] ovrAvatarTransform[] customJointTransforms);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdatePoseFromPacket(IntPtr avatar, IntPtr packet, float secondsFromStart);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_BeginRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_EndRecording(IntPtr avatar);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern uint ovrAvatarPacket_GetSize(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern float ovrAvatarPacket_GetDurationSeconds(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatarPacket_Free(IntPtr packet);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern bool ovrAvatarPacket_Write(IntPtr packet, uint bufferSize, [Out] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern IntPtr ovrAvatarPacket_Read(uint bufferSize, [In] byte[] buffer);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		private static extern void ovrAvatar_SetInternalForceASTCTextures(bool value);

		public static void ovrAvatar_SetForceASTCTextures(bool value)
		{
			ovrAvatar_SetInternalForceASTCTextures(value);
		}

		public static void ovrAvatar_OverrideExpressiveLogic(IntPtr avatar, ovrAvatarBlendShapeParams blendParams)
		{
			IntPtr intPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(ovrAvatarBlendShapeParams)));
			Marshal.StructureToPtr(blendParams, intPtr, fDeleteOld: false);
			ovrAvatar_OverrideExpressiveLogic_Native(avatar, intPtr);
			Marshal.FreeHGlobal(intPtr);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_OverrideExpressiveLogic")]
		private static extern void ovrAvatar_OverrideExpressiveLogic_Native(IntPtr avatar, IntPtr state);

		public static void ovrAvatar_SetVisemes(IntPtr avatar, ovrAvatarVisemes visemes)
		{
			Marshal.WriteInt32(nativeVisemeData, (int)visemes.visemeParamCount);
			Marshal.Copy(visemes.visemeParams, 0, new IntPtr(nativeVisemeData.ToInt64() + ovrAvatarVisemes_Offsets.visemeParams), (int)visemes.visemeParamCount);
			ovrAvatar_SetVisemes_Native(avatar, nativeVisemeData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_SetVisemes")]
		private static extern void ovrAvatar_SetVisemes_Native(IntPtr avatar, IntPtr visemes);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_UpdateWorldTransform(IntPtr avatar, ovrAvatarTransform transform);

		public static void ovrAvatar_UpdateGazeTargets(ovrAvatarGazeTargets targets)
		{
			Marshal.WriteInt32(nativeGazeTargetsData, (int)targets.targetCount);
			long targets2 = ovrAvatarGazeTargets_Offsets.targets;
			for (uint num = 0u; num < targets.targetCount; num++)
			{
				long num2 = targets2 + num * Marshal.SizeOf(typeof(ovrAvatarGazeTarget));
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.id), (int)targets.targets[num].id);
				scratchBufferFloat[0] = targets.targets[num].worldPosition.x;
				scratchBufferFloat[1] = targets.targets[num].worldPosition.y;
				scratchBufferFloat[2] = targets.targets[num].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.worldPosition), 3);
				Marshal.WriteInt32(new IntPtr(nativeGazeTargetsData.ToInt64() + num2 + ovrAvatarGazeTarget_Offsets.type), (int)targets.targets[num].type);
			}
			ovrAvatar_UpdateGazeTargets_Native(nativeGazeTargetsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateGazeTargets")]
		private static extern void ovrAvatar_UpdateGazeTargets_Native(IntPtr targets);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveGazeTargets(uint targetCount, uint[] ids);

		public static void ovrAvatar_UpdateLights(ovrAvatarLights lights)
		{
			scratchBufferFloat[0] = lights.ambientIntensity;
			Marshal.Copy(scratchBufferFloat, 0, nativeAvatarLightsData, 1);
			Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + Marshal.OffsetOf(typeof(ovrAvatarLights), "lightCount").ToInt64()), (int)lights.lightCount);
			long num = Marshal.OffsetOf(typeof(ovrAvatarLights), "lights").ToInt64();
			for (uint num2 = 0u; num2 < lights.lightCount; num2++)
			{
				long num3 = num + num2 * Marshal.SizeOf(typeof(ovrAvatarLight));
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "id").ToInt64()), (int)lights.lights[num2].id);
				Marshal.WriteInt32(new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "type").ToInt64()), (int)lights.lights[num2].type);
				scratchBufferFloat[0] = lights.lights[num2].intensity;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "intensity").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].worldDirection.x;
				scratchBufferFloat[1] = lights.lights[num2].worldDirection.y;
				scratchBufferFloat[2] = lights.lights[num2].worldDirection.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldDirection").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].worldPosition.x;
				scratchBufferFloat[1] = lights.lights[num2].worldPosition.y;
				scratchBufferFloat[2] = lights.lights[num2].worldPosition.z;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "worldPosition").ToInt64()), 3);
				scratchBufferFloat[0] = lights.lights[num2].range;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "range").ToInt64()), 1);
				scratchBufferFloat[0] = lights.lights[num2].spotAngleDeg;
				Marshal.Copy(scratchBufferFloat, 0, new IntPtr(nativeAvatarLightsData.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarLight), "spotAngleDeg").ToInt64()), 1);
			}
			ovrAvatar_UpdateLights_Native(nativeAvatarLightsData);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_UpdateLights")]
		private static extern void ovrAvatar_UpdateLights_Native(IntPtr lights);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RemoveLights(uint lightCount, uint[] ids);

		[MonoPInvokeCallback(typeof(LoggingDelegate))]
		public static void LoggingCallback(IntPtr str)
		{
			Marshal.PtrToStringAnsi(str);
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_RegisterLoggingCallback(LoggingDelegate callback);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetLoggingLevel(ovrAvatarLogLevel level);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugTransforms")]
		public static extern IntPtr ovrAvatar_GetDebugTransforms_Native(IntPtr count);

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrAvatar_GetDebugLines")]
		public static extern IntPtr ovrAvatar_GetDebugLines_Native(IntPtr count);

		public static void ovrAvatar_DrawDebugLines()
		{
			IntPtr intPtr = ovrAvatar_GetDebugLines_Native(DebugLineCountData);
			int num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugLine ovrAvatarDebugLine = default(ovrAvatarDebugLine);
			for (int i = 0; i < num; i++)
			{
				int num2 = i * Marshal.SizeOf(typeof(ovrAvatarDebugLine));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num2), scratchBufferFloat, 0, 9);
				ovrAvatarDebugLine.startPoint.x = scratchBufferFloat[0];
				ovrAvatarDebugLine.startPoint.y = scratchBufferFloat[1];
				ovrAvatarDebugLine.startPoint.z = 0f - scratchBufferFloat[2];
				ovrAvatarDebugLine.endPoint.x = scratchBufferFloat[3];
				ovrAvatarDebugLine.endPoint.y = scratchBufferFloat[4];
				ovrAvatarDebugLine.endPoint.z = 0f - scratchBufferFloat[5];
				ovrAvatarDebugLine.color.x = scratchBufferFloat[6];
				ovrAvatarDebugLine.color.y = scratchBufferFloat[7];
				ovrAvatarDebugLine.color.z = scratchBufferFloat[8];
				ovrAvatarDebugLine.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "context").ToInt64()));
				ovrAvatarDebugLine.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num2 + Marshal.OffsetOf(typeof(ovrAvatarDebugLine), "text").ToInt64()));
				UnityEngine.Debug.DrawLine(ovrAvatarDebugLine.startPoint, ovrAvatarDebugLine.endPoint, new Color(ovrAvatarDebugLine.color.x, ovrAvatarDebugLine.color.y, ovrAvatarDebugLine.color.z));
			}
			intPtr = ovrAvatar_GetDebugTransforms_Native(DebugLineCountData);
			num = Marshal.ReadInt32(DebugLineCountData);
			ovrAvatarDebugTransform ovrAvatarDebugTransform = default(ovrAvatarDebugTransform);
			for (int j = 0; j < num; j++)
			{
				int num3 = j * Marshal.SizeOf(typeof(ovrAvatarDebugTransform));
				Marshal.Copy(new IntPtr(intPtr.ToInt64() + num3), scratchBufferFloat, 0, 10);
				OvrAvatar.ConvertTransform(scratchBufferFloat, ref ovrAvatarDebugTransform.transform);
				OvrAvatar.ConvertTransform(ovrAvatarDebugTransform.transform, debugLineGo.transform);
				ovrAvatarDebugTransform.context = (ovrAvatarDebugContext)Marshal.ReadInt32(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "context").ToInt64()));
				ovrAvatarDebugTransform.text = Marshal.ReadIntPtr(new IntPtr(intPtr.ToInt64() + num3 + Marshal.OffsetOf(typeof(ovrAvatarDebugTransform), "text").ToInt64()));
				Vector3 vector = 0.1f * debugLineGo.transform.TransformVector(Vector3.up);
				Vector3 vector2 = 0.1f * debugLineGo.transform.TransformVector(Vector3.right);
				Vector3 vector3 = 0.1f * debugLineGo.transform.TransformVector(Vector3.forward);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector, Color.green);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector2, Color.red);
				UnityEngine.Debug.DrawLine(debugLineGo.transform.position, debugLineGo.transform.position + vector3, Color.blue);
			}
		}

		[DllImport("ovravatarloader", CallingConvention = CallingConvention.Cdecl)]
		public static extern void ovrAvatar_SetDebugDrawContext(uint context);

		public static bool SendEvent(string name, string param = "", string source = "")
		{
			try
			{
				if (ovrPluginVersion == null)
				{
					string text = ovrp_GetVersion();
					if (!string.IsNullOrEmpty(text))
					{
						ovrPluginVersion = new Version(text.Split('-')[0]);
					}
					else
					{
						ovrPluginVersion = new Version(0, 0, 0);
					}
				}
				if (ovrPluginVersion >= OVRP_1_30_0.version)
				{
					return OVRP_1_30_0.ovrp_SendEvent2(name, param, (source.Length == 0) ? "avatar_sdk" : source) == Result.Success;
				}
				return false;
			}
			catch (Exception)
			{
				return false;
			}
		}

		[DllImport("OVRPlugin", CallingConvention = CallingConvention.Cdecl, EntryPoint = "ovrp_GetVersion")]
		private static extern IntPtr _ovrp_GetVersion();

		public static string ovrp_GetVersion()
		{
			return Marshal.PtrToStringAnsi(_ovrp_GetVersion());
		}
	}
}
namespace OVR
{
	public class TestScript : MonoBehaviour
	{
		[InspectorNote("Sound Setup", "Press '1' to play testSound1 and '2' to play testSound2")]
		public SoundFXRef testSound1;

		public SoundFXRef testSound2;

		private void Start()
		{
		}

		private void Update()
		{
			if (Input.GetKeyDown(KeyCode.Alpha1))
			{
				testSound1.PlaySoundAt(base.transform.position);
			}
			if (Input.GetKeyDown(KeyCode.Alpha2))
			{
				testSound2.PlaySoundAt(new Vector3(5f, 0f, 0f));
			}
		}
	}
	public class AmbienceEmitter : MonoBehaviour
	{
		public SoundFXRef[] ambientSounds = new SoundFXRef[0];

		public bool autoActivate = true;

		[UnityEngine.Tooltip("Automatically play the sound randomly again when checked.  Should be OFF for looping sounds")]
		public bool autoRetrigger = true;

		[MinMax(2f, 4f, 0.1f, 10f)]
		public Vector2 randomRetriggerDelaySecs = new Vector2(2f, 4f);

		[UnityEngine.Tooltip("If defined, the sounds will randomly play from these transform positions, otherwise the sound will play from this transform")]
		public Transform[] playPositions = new Transform[0];

		private bool activated;

		private int playingIdx = -1;

		private float nextPlayTime;

		private float fadeTime = 0.25f;

		private int lastPosIdx = -1;

		private void Awake()
		{
			if (autoActivate)
			{
				activated = true;
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
			Transform[] array = playPositions;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == null)
				{
					UnityEngine.Debug.LogWarning("[AmbienceEmitter] Invalid play positions in " + base.name);
					playPositions = new Transform[0];
					break;
				}
			}
		}

		private void Update()
		{
			if (activated && (playingIdx == -1 || autoRetrigger) && Time.time >= nextPlayTime)
			{
				Play();
				if (!autoRetrigger)
				{
					activated = false;
				}
			}
		}

		public void OnTriggerEnter(Collider col)
		{
			activated = !activated;
		}

		public void Play()
		{
			Transform transform = base.transform;
			if (playPositions.Length != 0)
			{
				int num = UnityEngine.Random.Range(0, playPositions.Length);
				while (playPositions.Length > 1 && num == lastPosIdx)
				{
					num = UnityEngine.Random.Range(0, playPositions.Length);
				}
				transform = playPositions[num];
				lastPosIdx = num;
			}
			playingIdx = ambientSounds[UnityEngine.Random.Range(0, ambientSounds.Length)].PlaySoundAt(transform.position);
			if (playingIdx != -1)
			{
				AudioManager.FadeInSound(playingIdx, fadeTime);
				nextPlayTime = Time.time + UnityEngine.Random.Range(randomRetriggerDelaySecs.x, randomRetriggerDelaySecs.y);
			}
		}

		public void EnableEmitter(bool enable)
		{
			activated = enable;
			if (enable)
			{
				Play();
			}
			else if (playingIdx != -1)
			{
				AudioManager.FadeOutSound(playingIdx, fadeTime);
			}
		}
	}
	public enum PreloadSounds
	{
		Default,
		Preload,
		ManualPreload
	}
	public enum Fade
	{
		In,
		Out
	}
	[Serializable]
	public class SoundGroup
	{
		public string name = string.Empty;

		public SoundFX[] soundList = new SoundFX[0];

		public AudioMixerGroup mixerGroup;

		[Range(0f, 64f)]
		public int maxPlayingSounds;

		public PreloadSounds preloadAudio;

		public float volumeOverride = 1f;

		[HideInInspector]
		public int playingSoundCount;

		public SoundGroup(string name)
		{
			this.name = name;
		}

		public SoundGroup()
		{
			mixerGroup = null;
			maxPlayingSounds = 0;
			preloadAudio = PreloadSounds.Default;
			volumeOverride = 1f;
		}

		public void IncrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(++playingSoundCount, 0, maxPlayingSounds);
		}

		public void DecrementPlayCount()
		{
			playingSoundCount = Mathf.Clamp(--playingSoundCount, 0, maxPlayingSounds);
		}

		public bool CanPlaySound()
		{
			if (maxPlayingSounds != 0)
			{
				return playingSoundCount < maxPlayingSounds;
			}
			return true;
		}
	}
	public class AudioManager : MonoBehaviour
	{
		public enum Fade
		{
			In,
			Out
		}

		[UnityEngine.Tooltip("Make the audio manager persistent across all scene loads")]
		public bool makePersistent = true;

		[UnityEngine.Tooltip("Enable the OSP audio plugin features")]
		public bool enableSpatializedAudio = true;

		[UnityEngine.Tooltip("Always play spatialized sounds with no reflections (Default)")]
		public bool enableSpatializedFastOverride;

		[UnityEngine.Tooltip("The audio mixer asset used for snapshot blends, etc.")]
		public AudioMixer audioMixer;

		[UnityEngine.Tooltip("The audio mixer group used for the pooled emitters")]
		public AudioMixerGroup defaultMixerGroup;

		[UnityEngine.Tooltip("The audio mixer group used for the reserved pool emitter")]
		public AudioMixerGroup reservedMixerGroup;

		[UnityEngine.Tooltip("The audio mixer group used for voice chat")]
		public AudioMixerGroup voiceChatMixerGroup;

		[UnityEngine.Tooltip("Log all PlaySound calls to the Unity console")]
		public bool verboseLogging;

		[UnityEngine.Tooltip("Maximum sound emitters")]
		public int maxSoundEmitters = 32;

		[UnityEngine.Tooltip("Default volume for all sounds modulated by individual sound FX volumes")]
		public float volumeSoundFX = 1f;

		[UnityEngine.Tooltip("Sound FX fade time")]
		public float soundFxFadeSecs = 1f;

		public float audioMinFallOffDistance = 1f;

		public float audioMaxFallOffDistance = 25f;

		public SoundGroup[] soundGroupings = new SoundGroup[0];

		private Dictionary<string, SoundFX> soundFXCache;

		private static AudioManager theAudioManager = null;

		private static FastList<string> names = new FastList<string>();

		private static string[] defaultSound = new string[1] { "Default Sound" };

		private static SoundFX nullSound = new SoundFX();

		private static bool hideWarnings = false;

		private float audioMaxFallOffDistanceSqr = 625f;

		private SoundEmitter[] soundEmitters;

		private FastList<SoundEmitter> playingEmitters = new FastList<SoundEmitter>();

		private FastList<SoundEmitter> nextFreeEmitters = new FastList<SoundEmitter>();

		private MixerSnapshot currentSnapshot;

		private static GameObject soundEmitterParent = null;

		private static Transform staticListenerPosition = null;

		private static bool showPlayingEmitterCount = false;

		private static bool forceShowEmitterCount = false;

		private static bool soundEnabled = true;

		private static readonly AnimationCurve defaultReverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		public static bool enableSpatialization
		{
			get
			{
				if (!(theAudioManager != null))
				{
					return false;
				}
				return theAudioManager.enableSpatializedAudio;
			}
		}

		public static AudioManager Instance => theAudioManager;

		public static float NearFallOff => theAudioManager.audioMinFallOffDistance;

		public static float FarFallOff => theAudioManager.audioMaxFallOffDistance;

		public static AudioMixerGroup EmitterGroup => theAudioManager.defaultMixerGroup;

		public static AudioMixerGroup ReservedGroup => theAudioManager.reservedMixerGroup;

		public static AudioMixerGroup VoipGroup => theAudioManager.voiceChatMixerGroup;

		public static bool SoundEnabled => soundEnabled;

		private void Awake()
		{
			Init();
		}

		private void OnDestroy()
		{
			if (theAudioManager == this && soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
		}

		private void Init()
		{
			if (theAudioManager != null)
			{
				if (UnityEngine.Application.isPlaying && theAudioManager != this)
				{
					base.enabled = false;
				}
				return;
			}
			theAudioManager = this;
			nullSound.name = "Default Sound";
			RebuildSoundFXCache();
			if (UnityEngine.Application.isPlaying)
			{
				InitializeSoundSystem();
				if (makePersistent && base.transform.parent == null)
				{
					UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
				}
			}
		}

		private void Update()
		{
			UpdateFreeEmitters();
		}

		private void RebuildSoundFXCache()
		{
			int num = 0;
			for (int i = 0; i < soundGroupings.Length; i++)
			{
				num += soundGroupings[i].soundList.Length;
			}
			soundFXCache = new Dictionary<string, SoundFX>(num + 1);
			soundFXCache.Add(nullSound.name, nullSound);
			for (int j = 0; j < soundGroupings.Length; j++)
			{
				for (int k = 0; k < soundGroupings[j].soundList.Length; k++)
				{
					if (soundFXCache.ContainsKey(soundGroupings[j].soundList[k].name))
					{
						UnityEngine.Debug.LogError("ERROR: Duplicate Sound FX name in the audio manager: '" + soundGroupings[j].name + "' > '" + soundGroupings[j].soundList[k].name + "'");
					}
					else
					{
						soundGroupings[j].soundList[k].Group = soundGroupings[j];
						soundFXCache.Add(soundGroupings[j].soundList[k].name, soundGroupings[j].soundList[k]);
					}
				}
				soundGroupings[j].playingSoundCount = 0;
			}
		}

		public static SoundFX FindSoundFX(string name, bool rebuildCache = false)
		{
			if (string.IsNullOrEmpty(name))
			{
				return nullSound;
			}
			if (rebuildCache)
			{
				theAudioManager.RebuildSoundFXCache();
			}
			if (!theAudioManager.soundFXCache.ContainsKey(name))
			{
				return nullSound;
			}
			return theAudioManager.soundFXCache[name];
		}

		private static bool FindAudioManager()
		{
			GameObject gameObject = GameObject.Find("AudioManager");
			if (gameObject == null || gameObject.GetComponent<AudioManager>() == null)
			{
				if (!hideWarnings)
				{
					UnityEngine.Debug.LogError("[ERROR] AudioManager object missing from hierarchy!");
					hideWarnings = true;
				}
				return false;
			}
			gameObject.GetComponent<AudioManager>().Init();
			return true;
		}

		public static GameObject GetGameObject()
		{
			if (theAudioManager == null && !FindAudioManager())
			{
				return null;
			}
			return theAudioManager.gameObject;
		}

		public static string NameMinusGroup(string name)
		{
			if (name.IndexOf("/") > -1)
			{
				return name.Substring(name.IndexOf("/") + 1);
			}
			return name;
		}

		public static string[] GetSoundFXNames(string currentValue, out int currentIdx)
		{
			currentIdx = 0;
			names.Clear();
			if (theAudioManager == null && !FindAudioManager())
			{
				return defaultSound;
			}
			names.Add(nullSound.name);
			for (int i = 0; i < theAudioManager.soundGroupings.Length; i++)
			{
				for (int j = 0; j < theAudioManager.soundGroupings[i].soundList.Length; j++)
				{
					if (string.Compare(currentValue, theAudioManager.soundGroupings[i].soundList[j].name, ignoreCase: true) == 0)
					{
						currentIdx = names.Count;
					}
					names.Add(theAudioManager.soundGroupings[i].name + "/" + theAudioManager.soundGroupings[i].soundList[j].name);
				}
			}
			return names.ToArray();
		}

		private static int CalculateMaxEmittersSize()
		{
			return theAudioManager.maxSoundEmitters + 1;
		}

		private static bool ValidateEmitterIndex(int index)
		{
			if (index > -1)
			{
				return index < CalculateMaxEmittersSize();
			}
			return false;
		}

		private void InitializeSoundSystem()
		{
			int bufferLength = 960;
			int numBuffers = 4;
			AudioSettings.GetDSPBufferSize(out bufferLength, out numBuffers);
			if (UnityEngine.Application.isPlaying)
			{
				UnityEngine.Debug.Log("[AudioManager] Audio Sample Rate: " + AudioSettings.outputSampleRate);
				UnityEngine.Debug.Log("[AudioManager] Audio Buffer Length: " + bufferLength + " Size: " + numBuffers);
			}
			AudioListener audioListener = UnityEngine.Object.FindObjectOfType<AudioListener>();
			if (audioListener == null)
			{
				UnityEngine.Debug.LogError("[AudioManager] Missing AudioListener object!  Add one to the scene.");
			}
			else
			{
				staticListenerPosition = audioListener.transform;
			}
			soundEmitters = new SoundEmitter[CalculateMaxEmittersSize()];
			soundEmitterParent = GameObject.Find("__SoundEmitters__");
			if (soundEmitterParent != null)
			{
				UnityEngine.Object.Destroy(soundEmitterParent);
			}
			soundEmitterParent = new GameObject("__SoundEmitters__");
			for (int i = 0; i < CalculateMaxEmittersSize(); i++)
			{
				GameObject gameObject = new GameObject("SoundEmitter_" + i);
				gameObject.transform.parent = soundEmitterParent.transform;
				gameObject.transform.position = Vector3.zero;
				gameObject.hideFlags = HideFlags.DontSaveInEditor;
				soundEmitters[i] = gameObject.AddComponent<SoundEmitter>();
				soundEmitters[i].SetDefaultParent(soundEmitterParent.transform);
				soundEmitters[i].SetChannel(i);
				soundEmitters[i].Stop();
				soundEmitters[i].originalIdx = i;
			}
			ResetFreeEmitters();
			soundEmitterParent.hideFlags = HideFlags.DontSaveInEditor;
			audioMaxFallOffDistanceSqr = audioMaxFallOffDistance * audioMaxFallOffDistance;
		}

		private void UpdateFreeEmitters()
		{
			if (verboseLogging)
			{
				if (Input.GetKeyDown(KeyCode.A))
				{
					forceShowEmitterCount = !forceShowEmitterCount;
				}
				if (forceShowEmitterCount)
				{
					showPlayingEmitterCount = true;
				}
			}
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			int num6 = 0;
			int num7 = 0;
			while (num7 < playingEmitters.size)
			{
				if (playingEmitters[num7] == null)
				{
					UnityEngine.Debug.LogError("[AudioManager] ERROR: playingEmitters list had a null emitter! Something nuked a sound emitter!!!");
					playingEmitters.RemoveAtFast(num7);
					return;
				}
				if (!playingEmitters[num7].IsPlaying())
				{
					if (verboseLogging && nextFreeEmitters.Contains(playingEmitters[num7]))
					{
						UnityEngine.Debug.LogError("[AudioManager] ERROR: playing sound emitter already in the free emitters list!");
					}
					playingEmitters[num7].Stop();
					nextFreeEmitters.Add(playingEmitters[num7]);
					playingEmitters.RemoveAtFast(num7);
					continue;
				}
				if (verboseLogging && showPlayingEmitterCount)
				{
					num++;
					switch (playingEmitters[num7].priority)
					{
					case SoundPriority.VeryLow:
						num2++;
						break;
					case SoundPriority.Low:
						num3++;
						break;
					case SoundPriority.Default:
						num4++;
						break;
					case SoundPriority.High:
						num5++;
						break;
					case SoundPriority.VeryHigh:
						num6++;
						break;
					}
				}
				num7++;
			}
			if (verboseLogging && showPlayingEmitterCount)
			{
				UnityEngine.Debug.LogWarning($"[AudioManager] Playing sounds: Total {Fmt(num)} | VeryLow {Fmt(num2)} | Low {Fmt(num3)} | Default {Fmt(num4)} | High {Fmt(num5)} | VeryHigh {Fmt(num6)} | Free {FmtFree(nextFreeEmitters.Count)}");
				showPlayingEmitterCount = false;
			}
		}

		private string Fmt(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.5f)
			{
				return "<color=green>" + count + "</color>";
			}
			if ((double)num < 0.7)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=red>" + count + "</color>";
		}

		private string FmtFree(int count)
		{
			float num = (float)count / (float)theAudioManager.maxSoundEmitters;
			if (num < 0.2f)
			{
				return "<color=red>" + count + "</color>";
			}
			if ((double)num < 0.3)
			{
				return "<color=yellow>" + count + "</color>";
			}
			return "<color=green>" + count + "</color>";
		}

		private void OnPreSceneLoad()
		{
			UnityEngine.Debug.Log("[AudioManager] OnPreSceneLoad cleanup");
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				soundEmitters[i].Stop();
				soundEmitters[i].ResetParent(soundEmitterParent.transform);
			}
			ResetFreeEmitters();
		}

		private void ResetFreeEmitters()
		{
			nextFreeEmitters.Clear();
			playingEmitters.Clear();
			for (int i = 1; i < soundEmitters.Length; i++)
			{
				nextFreeEmitters.Add(soundEmitters[i]);
			}
		}

		public static void FadeOutSoundChannel(int channel, float delaySecs, float fadeTime)
		{
			theAudioManager.soundEmitters[channel].FadeOutDelayed(delaySecs, fadeTime);
		}

		public static bool StopSound(int idx, bool fadeOut = true, bool stopReserved = false)
		{
			if (!stopReserved && idx == 0)
			{
				return false;
			}
			if (!fadeOut)
			{
				theAudioManager.soundEmitters[idx].Stop();
			}
			else
			{
				theAudioManager.soundEmitters[idx].FadeOut(theAudioManager.soundFxFadeSecs);
			}
			return true;
		}

		public static void FadeInSound(int idx, float fadeTime, float volume)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime, volume);
		}

		public static void FadeInSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeIn(fadeTime);
		}

		public static void FadeOutSound(int idx, float fadeTime)
		{
			theAudioManager.soundEmitters[idx].FadeOut(fadeTime);
		}

		public static void StopAllSounds(bool fadeOut, bool stopReserved = false)
		{
			for (int i = 0; i < theAudioManager.soundEmitters.Length; i++)
			{
				StopSound(i, fadeOut, stopReserved);
			}
		}

		public void MuteAllSounds(bool mute, bool muteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if (muteReserved || i != 0)
				{
					soundEmitters[i].audioSource.mute = true;
				}
			}
		}

		public void UnMuteAllSounds(bool unmute, bool unmuteReserved = false)
		{
			for (int i = 0; i < soundEmitters.Length; i++)
			{
				if ((unmuteReserved || i != 0) && soundEmitters[i].audioSource.isPlaying)
				{
					soundEmitters[i].audioSource.mute = false;
				}
			}
		}

		public static float GetEmitterEndTime(int idx)
		{
			return theAudioManager.soundEmitters[idx].endPlayTime;
		}

		public static float SetEmitterTime(int idx, float time)
		{
			return theAudioManager.soundEmitters[idx].time = time;
		}

		public static int PlaySound(AudioClip clip, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitchVariance = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, clip, volume, src, delay, pitchVariance, loop);
		}

		private static int FindFreeEmitter(EmitterChannel src, SoundPriority priority)
		{
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[0];
			if (src == EmitterChannel.Any)
			{
				if (theAudioManager.nextFreeEmitters.size > 0)
				{
					soundEmitter = theAudioManager.nextFreeEmitters[0];
					theAudioManager.nextFreeEmitters.RemoveAtFast(0);
				}
				else
				{
					if (priority == SoundPriority.VeryLow)
					{
						return -1;
					}
					soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority < priority);
					if (soundEmitter == null)
					{
						if (priority < SoundPriority.Default)
						{
							if (theAudioManager.verboseLogging)
							{
								UnityEngine.Debug.LogWarning("[AudioManager] skipping sound " + priority);
							}
							return -1;
						}
						soundEmitter = theAudioManager.playingEmitters.Find((SoundEmitter item) => item != null && item.priority <= SoundPriority.Default);
					}
					if (soundEmitter != null)
					{
						if (theAudioManager.verboseLogging)
						{
							UnityEngine.Debug.LogWarning("[AudioManager] cannabalizing " + soundEmitter.originalIdx + " Time: " + Time.time);
						}
						soundEmitter.Stop();
						theAudioManager.playingEmitters.RemoveFast(soundEmitter);
					}
				}
			}
			if (soundEmitter == null)
			{
				UnityEngine.Debug.LogError(string.Concat("[AudioManager] ERROR - absolutely couldn't find a free emitter! Priority = ", priority, " TOO MANY PlaySound* calls!"));
				showPlayingEmitterCount = true;
				return -1;
			}
			return soundEmitter.originalIdx;
		}

		public static int PlaySound(SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			return PlaySoundAt((staticListenerPosition != null) ? staticListenerPosition.position : Vector3.zero, soundFX, src, delay);
		}

		public static int PlaySoundAt(Vector3 position, SoundFX soundFX, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			AudioClip clip = soundFX.GetClip();
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null)
			{
				float sqrMagnitude = (staticListenerPosition.position - position).sqrMagnitude;
				if (sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
				{
					return -1;
				}
				if (sqrMagnitude > soundFX.MaxFalloffDistSquared)
				{
					return -1;
				}
			}
			if (soundFX.ReachedGroupPlayLimit())
			{
				if (theAudioManager.verboseLogging)
				{
					UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() with " + soundFX.name + " skipped due to group play limit");
				}
				return -1;
			}
			int num = FindFreeEmitter(src, soundFX.priority);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource source = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			source.enabled = true;
			source.volume = Mathf.Clamp01(Mathf.Clamp01(theAudioManager.volumeSoundFX * soundFX.volume) * volumeOverride * soundFX.GroupVolumeOverride);
			source.pitch = soundFX.GetPitch() * pitchMultiplier;
			source.time = 0f;
			source.spatialBlend = 1f;
			source.rolloffMode = soundFX.falloffCurve;
			if (soundFX.falloffCurve == AudioRolloffMode.Custom)
			{
				source.SetCustomCurve(AudioSourceCurveType.CustomRolloff, soundFX.volumeFalloffCurve);
			}
			source.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, soundFX.reverbZoneMix);
			source.dopplerLevel = 0f;
			source.clip = clip;
			source.spread = soundFX.spread;
			source.loop = soundFX.looping;
			source.mute = false;
			source.minDistance = soundFX.falloffDistance.x;
			source.maxDistance = soundFX.falloffDistance.y;
			source.outputAudioMixerGroup = soundFX.GetMixerGroup(EmitterGroup);
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = source.volume;
			soundEmitter.priority = soundFX.priority;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(soundFX.Group);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = soundFX.ospProps.enableSpatialization;
				osp.EnableRfl = ((theAudioManager.enableSpatializedFastOverride || soundFX.ospProps.useFastOverride) ? true : false);
				osp.Gain = soundFX.ospProps.gain;
				osp.UseInvSqr = soundFX.ospProps.enableInvSquare;
				osp.Near = soundFX.ospProps.invSquareFalloff.x;
				osp.Far = soundFX.ospProps.invSquareFalloff.y;
				source.spatialBlend = (soundFX.ospProps.enableSpatialization ? 1f : 0.8f);
				osp.SetParameters(ref source);
			}
			source.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " soundFX = " + soundFX.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				source.PlayDelayed(delay);
			}
			else
			{
				source.Play();
			}
			return num;
		}

		public static int PlayRandomSoundAt(Vector3 position, AudioClip[] clips, float volume, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (clips == null || clips.Length == 0)
			{
				return -1;
			}
			int num = UnityEngine.Random.Range(0, clips.Length);
			return PlaySoundAt(position, clips[num], volume, src, delay, pitch, loop);
		}

		public static int PlaySoundAt(Vector3 position, AudioClip clip, float volume = 1f, EmitterChannel src = EmitterChannel.Any, float delay = 0f, float pitch = 1f, bool loop = false)
		{
			if (!SoundEnabled)
			{
				return -1;
			}
			if (clip == null)
			{
				return -1;
			}
			if (staticListenerPosition != null && (staticListenerPosition.position - position).sqrMagnitude > theAudioManager.audioMaxFallOffDistanceSqr)
			{
				return -1;
			}
			int num = FindFreeEmitter(src, SoundPriority.Default);
			if (num == -1)
			{
				return -1;
			}
			SoundEmitter soundEmitter = theAudioManager.soundEmitters[num];
			soundEmitter.ResetParent(soundEmitterParent.transform);
			soundEmitter.gameObject.SetActive(value: true);
			AudioSource audioSource = soundEmitter.audioSource;
			ONSPAudioSource osp = soundEmitter.osp;
			audioSource.enabled = true;
			audioSource.volume = Mathf.Clamp01(theAudioManager.volumeSoundFX * volume);
			audioSource.pitch = pitch;
			audioSource.spatialBlend = 0.8f;
			audioSource.rolloffMode = AudioRolloffMode.Linear;
			audioSource.SetCustomCurve(AudioSourceCurveType.ReverbZoneMix, defaultReverbZoneMix);
			audioSource.dopplerLevel = 0f;
			audioSource.clip = clip;
			audioSource.spread = 0f;
			audioSource.loop = loop;
			audioSource.mute = false;
			audioSource.minDistance = theAudioManager.audioMinFallOffDistance;
			audioSource.maxDistance = theAudioManager.audioMaxFallOffDistance;
			audioSource.outputAudioMixerGroup = EmitterGroup;
			soundEmitter.endPlayTime = Time.time + clip.length + delay;
			soundEmitter.defaultVolume = audioSource.volume;
			soundEmitter.priority = SoundPriority.Default;
			soundEmitter.onFinished = null;
			soundEmitter.SetPlayingSoundGroup(null);
			if (src == EmitterChannel.Any)
			{
				theAudioManager.playingEmitters.AddUnique(soundEmitter);
			}
			if (osp != null)
			{
				osp.EnableSpatialization = false;
			}
			audioSource.transform.position = position;
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] PlaySoundAt() channel = " + num + " clip = " + clip.name + " volume = " + soundEmitter.volume + " Delay = " + delay + " time = " + Time.time + "\n");
			}
			if (delay > 0f)
			{
				audioSource.PlayDelayed(delay);
			}
			else
			{
				audioSource.Play();
			}
			return num;
		}

		public static void SetOnFinished(int emitterIdx, System.Action onFinished)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished);
			}
		}

		public static void SetOnFinished(int emitterIdx, Action<object> onFinished, object obj)
		{
			if (ValidateEmitterIndex(emitterIdx))
			{
				theAudioManager.soundEmitters[emitterIdx].SetOnFinished(onFinished, obj);
			}
		}

		public static void AttachSoundToParent(int idx, Transform parent)
		{
			if (theAudioManager.verboseLogging)
			{
				string text = parent.name;
				if (parent.parent != null)
				{
					text = parent.parent.name + "/" + text;
				}
				UnityEngine.Debug.Log("[AudioManager] ATTACHING INDEX " + idx + " to " + text);
			}
			theAudioManager.soundEmitters[idx].ParentTo(parent);
		}

		public static void DetachSoundFromParent(int idx)
		{
			if (theAudioManager.verboseLogging)
			{
				UnityEngine.Debug.Log("[AudioManager] DETACHING INDEX " + idx);
			}
			theAudioManager.soundEmitters[idx].DetachFromParent();
		}

		public static void DetachSoundsFromParent(SoundEmitter[] emitters, bool stopSounds = true)
		{
			if (emitters == null)
			{
				return;
			}
			foreach (SoundEmitter soundEmitter in emitters)
			{
				if (soundEmitter.defaultParent != null)
				{
					if (stopSounds)
					{
						soundEmitter.Stop();
					}
					soundEmitter.DetachFromParent();
					soundEmitter.gameObject.SetActive(value: true);
				}
				else if (stopSounds)
				{
					soundEmitter.Stop();
				}
			}
		}

		public static void SetEmitterMixerGroup(int idx, AudioMixerGroup mixerGroup)
		{
			if (theAudioManager != null && idx > -1)
			{
				theAudioManager.soundEmitters[idx].SetAudioMixer(mixerGroup);
			}
		}

		public static MixerSnapshot GetActiveSnapshot()
		{
			if (!(theAudioManager != null))
			{
				return null;
			}
			return theAudioManager.currentSnapshot;
		}

		public static void SetCurrentSnapshot(MixerSnapshot mixerSnapshot)
		{
			if (theAudioManager != null)
			{
				if (mixerSnapshot != null && mixerSnapshot.snapshot != null)
				{
					mixerSnapshot.snapshot.TransitionTo(mixerSnapshot.transitionTime);
				}
				else
				{
					mixerSnapshot = null;
				}
				theAudioManager.currentSnapshot = mixerSnapshot;
			}
		}

		public static void BlendWithCurrentSnapshot(MixerSnapshot blendSnapshot, float weight, float blendTime = 0f)
		{
			if (!(theAudioManager != null))
			{
				return;
			}
			if (theAudioManager.audioMixer == null)
			{
				UnityEngine.Debug.LogWarning("[AudioManager] can't call BlendWithCurrentSnapshot if the audio mixer is not set!");
				return;
			}
			if (blendTime == 0f)
			{
				blendTime = Time.deltaTime;
			}
			if (theAudioManager.currentSnapshot != null && theAudioManager.currentSnapshot.snapshot != null && blendSnapshot != null && blendSnapshot.snapshot != null)
			{
				weight = Mathf.Clamp01(weight);
				if (weight == 0f)
				{
					theAudioManager.currentSnapshot.snapshot.TransitionTo(blendTime);
					return;
				}
				AudioMixerSnapshot[] snapshots = new AudioMixerSnapshot[2]
				{
					theAudioManager.currentSnapshot.snapshot,
					blendSnapshot.snapshot
				};
				float[] weights = new float[2]
				{
					1f - weight,
					weight
				};
				theAudioManager.audioMixer.TransitionToSnapshots(snapshots, weights, blendTime);
			}
		}
	}
	public enum EmitterChannel
	{
		None = -1,
		Reserved,
		Any
	}
	[Serializable]
	public class MixerSnapshot
	{
		public AudioMixerSnapshot snapshot;

		public float transitionTime = 0.25f;
	}
	public class MinMaxAttribute : PropertyAttribute
	{
		public float minDefaultVal = 1f;

		public float maxDefaultVal = 1f;

		public float min;

		public float max = 1f;

		public MinMaxAttribute(float minDefaultVal, float maxDefaultVal, float min, float max)
		{
			this.minDefaultVal = minDefaultVal;
			this.maxDefaultVal = maxDefaultVal;
			this.min = min;
			this.max = max;
		}
	}
	public class SoundEmitter : MonoBehaviour
	{
		public enum FadeState
		{
			Null,
			FadingIn,
			FadingOut,
			Ducking
		}

		public EmitterChannel channel;

		public bool disableSpatialization;

		private FadeState state;

		[NonSerialized]
		[HideInInspector]
		public AudioSource audioSource;

		[NonSerialized]
		[HideInInspector]
		public SoundPriority priority;

		[NonSerialized]
		[HideInInspector]
		public ONSPAudioSource osp;

		[NonSerialized]
		[HideInInspector]
		public float endPlayTime;

		private Transform lastParentTransform;

		[NonSerialized]
		[HideInInspector]
		public float defaultVolume = 1f;

		[NonSerialized]
		[HideInInspector]
		public Transform defaultParent;

		[NonSerialized]
		[HideInInspector]
		public int originalIdx = -1;

		[NonSerialized]
		[HideInInspector]
		public System.Action onFinished;

		[NonSerialized]
		[HideInInspector]
		public Action<object> onFinishedObject;

		[NonSerialized]
		[HideInInspector]
		public object onFinishedParam;

		[NonSerialized]
		[HideInInspector]
		public SoundGroup playingSoundGroup;

		public float volume
		{
			get
			{
				return audioSource.volume;
			}
			set
			{
				audioSource.volume = value;
			}
		}

		public float pitch
		{
			get
			{
				return audioSource.pitch;
			}
			set
			{
				audioSource.pitch = value;
			}
		}

		public AudioClip clip
		{
			get
			{
				return audioSource.clip;
			}
			set
			{
				audioSource.clip = value;
			}
		}

		public float time
		{
			get
			{
				return audioSource.time;
			}
			set
			{
				audioSource.time = value;
			}
		}

		public float length
		{
			get
			{
				if (!(audioSource.clip != null))
				{
					return 0f;
				}
				return audioSource.clip.length;
			}
		}

		public bool loop
		{
			get
			{
				return audioSource.loop;
			}
			set
			{
				audioSource.loop = value;
			}
		}

		public bool mute
		{
			get
			{
				return audioSource.mute;
			}
			set
			{
				audioSource.mute = value;
			}
		}

		public AudioVelocityUpdateMode velocityUpdateMode
		{
			get
			{
				return audioSource.velocityUpdateMode;
			}
			set
			{
				audioSource.velocityUpdateMode = value;
			}
		}

		public bool isPlaying => audioSource.isPlaying;

		private void Awake()
		{
			audioSource = GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = base.gameObject.AddComponent<AudioSource>();
			}
			if (AudioManager.enableSpatialization && !disableSpatialization)
			{
				osp = GetComponent<ONSPAudioSource>();
				if (osp == null)
				{
					osp = base.gameObject.AddComponent<ONSPAudioSource>();
				}
			}
			audioSource.playOnAwake = false;
			audioSource.Stop();
		}

		public void SetPlayingSoundGroup(SoundGroup soundGroup)
		{
			playingSoundGroup = soundGroup;
			soundGroup?.IncrementPlayCount();
		}

		public void SetOnFinished(System.Action onFinished)
		{
			this.onFinished = onFinished;
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			onFinishedObject = onFinished;
			onFinishedParam = obj;
		}

		public void SetChannel(int _channel)
		{
			channel = (EmitterChannel)_channel;
		}

		public void SetDefaultParent(Transform parent)
		{
			defaultParent = parent;
		}

		public void SetAudioMixer(AudioMixerGroup _mixer)
		{
			if (audioSource != null)
			{
				audioSource.outputAudioMixerGroup = _mixer;
			}
		}

		public bool IsPlaying()
		{
			if (loop && audioSource.isPlaying)
			{
				return true;
			}
			return endPlayTime > Time.time;
		}

		public void Play()
		{
			state = FadeState.Null;
			endPlayTime = Time.time + length;
			StopAllCoroutines();
			audioSource.Play();
		}

		public void Pause()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			audioSource.Pause();
		}

		public void Stop()
		{
			state = FadeState.Null;
			StopAllCoroutines();
			if (audioSource != null)
			{
				audioSource.Stop();
			}
			if (onFinished != null)
			{
				onFinished();
				onFinished = null;
			}
			if (onFinishedObject != null)
			{
				onFinishedObject(onFinishedParam);
				onFinishedObject = null;
			}
			if (playingSoundGroup != null)
			{
				playingSoundGroup.DecrementPlayCount();
				playingSoundGroup = null;
			}
		}

		private int GetSampleTime()
		{
			return audioSource.clip.samples - audioSource.timeSamples;
		}

		public void ParentTo(Transform parent)
		{
			if (lastParentTransform != null)
			{
				UnityEngine.Debug.LogError("[SoundEmitter] You must detach the sound emitter before parenting to another object!");
				return;
			}
			lastParentTransform = base.transform.parent;
			base.transform.parent = parent;
		}

		public void DetachFromParent()
		{
			if (lastParentTransform == null)
			{
				base.transform.parent = defaultParent;
				return;
			}
			base.transform.parent = lastParentTransform;
			lastParentTransform = null;
		}

		public void ResetParent(Transform parent)
		{
			base.transform.parent = parent;
			lastParentTransform = null;
		}

		public void SyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			StartCoroutine(DelayedSyncTo(other, fadeTime, toVolume));
		}

		private IEnumerator DelayedSyncTo(SoundEmitter other, float fadeTime, float toVolume)
		{
			yield return new WaitForEndOfFrame();
			audioSource.time = other.time;
			audioSource.Play();
			FadeTo(fadeTime, toVolume);
		}

		public void FadeTo(float fadeTime, float toVolume)
		{
			if (state != FadeState.FadingOut)
			{
				state = FadeState.Ducking;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannelTo(fadeTime, toVolume));
			}
		}

		public void FadeIn(float fadeTime, float defaultVolume)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeIn(float fadeTime)
		{
			audioSource.volume = 0f;
			state = FadeState.FadingIn;
			StopAllCoroutines();
			StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.In, defaultVolume));
		}

		public void FadeOut(float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(0f, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		public void FadeOutDelayed(float delayedSecs, float fadeTime)
		{
			if (audioSource.isPlaying)
			{
				state = FadeState.FadingOut;
				StopAllCoroutines();
				StartCoroutine(FadeSoundChannel(delayedSecs, fadeTime, Fade.Out, audioSource.volume));
			}
		}

		private IEnumerator FadeSoundChannelTo(float fadeTime, float toVolume)
		{
			float start = audioSource.volume;
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, toVolume, t);
				yield return 0;
			}
			state = FadeState.Null;
		}

		private IEnumerator FadeSoundChannel(float delaySecs, float fadeTime, Fade fadeType, float defaultVolume)
		{
			if (delaySecs > 0f)
			{
				yield return new WaitForSeconds(delaySecs);
			}
			float start = ((fadeType == Fade.In) ? 0f : defaultVolume);
			float end = ((fadeType == Fade.In) ? defaultVolume : 0f);
			bool restartPlay = false;
			if (fadeType == Fade.In)
			{
				if (Time.time == 0f)
				{
					restartPlay = true;
				}
				audioSource.volume = 0f;
				audioSource.Play();
			}
			float startTime = Time.realtimeSinceStartup;
			float elapsedTime = 0f;
			while (elapsedTime < fadeTime)
			{
				elapsedTime = Time.realtimeSinceStartup - startTime;
				float t = elapsedTime / fadeTime;
				audioSource.volume = Mathf.Lerp(start, end, t);
				yield return 0;
				if (restartPlay && Time.time > 0f)
				{
					audioSource.Play();
					restartPlay = false;
				}
				if (!audioSource.isPlaying)
				{
					break;
				}
			}
			if (fadeType == Fade.Out)
			{
				Stop();
			}
			state = FadeState.Null;
		}
	}
	public enum SoundFXNext
	{
		Random,
		Sequential
	}
	public enum FreqHint
	{
		None,
		Wide,
		Narrow
	}
	public enum SoundPriority
	{
		VeryLow = -2,
		Low,
		Default,
		High,
		VeryHigh
	}
	[Serializable]
	public class OSPProps
	{
		[UnityEngine.Tooltip("Set to true to play the sound FX spatialized with binaural HRTF, default = false")]
		public bool enableSpatialization;

		[UnityEngine.Tooltip("Play the sound FX with reflections, default = false")]
		public bool useFastOverride;

		[UnityEngine.Tooltip("Boost the gain on the spatialized sound FX, default = 0.0")]
		[Range(0f, 24f)]
		public float gain;

		[UnityEngine.Tooltip("Enable Inverse Square attenuation curve, default = false")]
		public bool enableInvSquare;

		[UnityEngine.Tooltip("Change the sound from point source (0.0f) to a spherical volume, default = 0.0")]
		[Range(0f, 1000f)]
		public float volumetric;

		[UnityEngine.Tooltip("Set the near and far falloff value for the OSP attenuation curve, default = 1.0")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 invSquareFalloff = new Vector2(1f, 25f);

		public OSPProps()
		{
			enableSpatialization = false;
			useFastOverride = false;
			gain = 0f;
			enableInvSquare = false;
			volumetric = 0f;
			invSquareFalloff = new Vector2(1f, 25f);
		}
	}
	[Serializable]
	public class SoundFX
	{
		[UnityEngine.Tooltip("Each sound FX should have a unique name")]
		public string name = string.Empty;

		[UnityEngine.Tooltip("Sound diversity playback option when multiple audio clips are defined, default = Random")]
		public SoundFXNext playback;

		[UnityEngine.Tooltip("Default volume for this sound FX, default = 1.0")]
		[Range(0f, 1f)]
		public float volume = 1f;

		[UnityEngine.Tooltip("Random pitch variance each time a sound FX is played, default = 1.0 (none)")]
		[MinMax(1f, 1f, 0f, 2f)]
		public Vector2 pitchVariance = Vector2.one;

		[UnityEngine.Tooltip("Falloff distance for the sound FX, default = 1m min to 25m max")]
		[MinMax(1f, 25f, 0f, 250f)]
		public Vector2 falloffDistance = new Vector2(1f, 25f);

		[UnityEngine.Tooltip("Volume falloff curve - sets how the sound FX attenuates over distance, default = Linear")]
		public AudioRolloffMode falloffCurve = AudioRolloffMode.Linear;

		[UnityEngine.Tooltip("Defines the custom volume falloff curve")]
		public AnimationCurve volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[UnityEngine.Tooltip("The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones | Valid range is 0.0 - 1.1, default = 1.0")]
		public AnimationCurve reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));

		[UnityEngine.Tooltip("Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space, default = 0")]
		[Range(0f, 360f)]
		public float spread;

		[UnityEngine.Tooltip("The percentage chance that this sound FX will play | 0.0 = none, 1.0 = 100%, default = 1.0")]
		[Range(0f, 1f)]
		public float pctChanceToPlay = 1f;

		[UnityEngine.Tooltip("Sets the priority for this sound to play and/or to override a currently playing sound FX, default = Default")]
		public SoundPriority priority;

		[UnityEngine.Tooltip("Specifies the default delay when this sound FX is played, default = 0.0 secs")]
		[MinMax(0f, 0f, 0f, 2f)]
		public Vector2 delay = Vector2.zero;

		[UnityEngine.Tooltip("Set to true for the sound to loop continuously, default = false")]
		public bool looping;

		public OSPProps ospProps = new OSPProps();

		[UnityEngine.Tooltip("List of the audio clips assigned to this sound FX")]
		public AudioClip[] soundClips = new AudioClip[1];

		public bool visibilityToggle;

		[NonSerialized]
		private SoundGroup soundGroup;

		private int lastIdx = -1;

		private int playingIdx = -1;

		public int Length => soundClips.Length;

		public bool IsValid
		{
			get
			{
				if (soundClips.Length != 0)
				{
					return soundClips[0] != null;
				}
				return false;
			}
		}

		public SoundGroup Group
		{
			get
			{
				return soundGroup;
			}
			set
			{
				soundGroup = value;
			}
		}

		public float MaxFalloffDistSquared => falloffDistance.y * falloffDistance.y;

		public float GroupVolumeOverride
		{
			get
			{
				if (soundGroup == null)
				{
					return 1f;
				}
				return soundGroup.volumeOverride;
			}
		}

		public SoundFX()
		{
			playback = SoundFXNext.Random;
			volume = 1f;
			pitchVariance = Vector2.one;
			falloffDistance = new Vector2(1f, 25f);
			falloffCurve = AudioRolloffMode.Linear;
			volumeFalloffCurve = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			reverbZoneMix = new AnimationCurve(new Keyframe(0f, 1f), new Keyframe(1f, 1f));
			spread = 0f;
			pctChanceToPlay = 1f;
			priority = SoundPriority.Default;
			delay = Vector2.zero;
			looping = false;
			ospProps = new OSPProps();
		}

		public AudioClip GetClip()
		{
			if (soundClips.Length == 0)
			{
				return null;
			}
			if (soundClips.Length == 1)
			{
				return soundClips[0];
			}
			if (playback == SoundFXNext.Random)
			{
				int num;
				for (num = UnityEngine.Random.Range(0, soundClips.Length); num == lastIdx; num = UnityEngine.Random.Range(0, soundClips.Length))
				{
				}
				lastIdx = num;
				return soundClips[num];
			}
			if (++lastIdx >= soundClips.Length)
			{
				lastIdx = 0;
			}
			return soundClips[lastIdx];
		}

		public AudioMixerGroup GetMixerGroup(AudioMixerGroup defaultMixerGroup)
		{
			if (soundGroup != null)
			{
				if (!(soundGroup.mixerGroup != null))
				{
					return defaultMixerGroup;
				}
				return soundGroup.mixerGroup;
			}
			return defaultMixerGroup;
		}

		public bool ReachedGroupPlayLimit()
		{
			if (soundGroup != null)
			{
				return !soundGroup.CanPlaySound();
			}
			return false;
		}

		public float GetClipLength(int idx)
		{
			if (idx == -1 || soundClips.Length == 0 || idx >= soundClips.Length || soundClips[idx] == null)
			{
				return 0f;
			}
			return soundClips[idx].length;
		}

		public float GetPitch()
		{
			return UnityEngine.Random.Range(pitchVariance.x, pitchVariance.y);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySound(this, EmitterChannel.Any, delaySecs);
			}
			return playingIdx;
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volumeOverride = 1f, float pitchMultiplier = 1f)
		{
			playingIdx = -1;
			if (!IsValid)
			{
				return playingIdx;
			}
			if (pctChanceToPlay > 0.99f || UnityEngine.Random.value < pctChanceToPlay)
			{
				if (delay.y > 0f)
				{
					delaySecs = UnityEngine.Random.Range(delay.x, delay.y);
				}
				playingIdx = AudioManager.PlaySoundAt(pos, this, EmitterChannel.Any, delaySecs, volumeOverride, pitchMultiplier);
			}
			return playingIdx;
		}

		public void SetOnFinished(System.Action onFinished)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished);
			}
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			if (playingIdx > -1)
			{
				AudioManager.SetOnFinished(playingIdx, onFinished, obj);
			}
		}

		public bool StopSound()
		{
			bool result = false;
			if (playingIdx > -1)
			{
				result = AudioManager.StopSound(playingIdx);
				playingIdx = -1;
			}
			return result;
		}

		public void AttachToParent(Transform parent)
		{
			if (playingIdx > -1)
			{
				AudioManager.AttachSoundToParent(playingIdx, parent);
			}
		}

		public void DetachFromParent()
		{
			if (playingIdx > -1)
			{
				AudioManager.DetachSoundFromParent(playingIdx);
			}
		}
	}
	[Serializable]
	public class SoundFXRef
	{
		public string soundFXName = string.Empty;

		private bool initialized;

		private SoundFX soundFXCached;

		public SoundFX soundFX
		{
			get
			{
				if (!initialized)
				{
					Init();
				}
				return soundFXCached;
			}
		}

		public string name
		{
			get
			{
				return soundFXName;
			}
			set
			{
				soundFXName = value;
				Init();
			}
		}

		public int Length => soundFX.Length;

		public bool IsValid => soundFX.IsValid;

		private void Init()
		{
			soundFXCached = AudioManager.FindSoundFX(soundFXName);
			if (soundFXCached == null)
			{
				soundFXCached = AudioManager.FindSoundFX(string.Empty);
			}
			initialized = true;
		}

		public AudioClip GetClip()
		{
			return soundFX.GetClip();
		}

		public float GetClipLength(int idx)
		{
			return soundFX.GetClipLength(idx);
		}

		public int PlaySound(float delaySecs = 0f)
		{
			return soundFX.PlaySound(delaySecs);
		}

		public int PlaySoundAt(Vector3 pos, float delaySecs = 0f, float volume = 1f, float pitchMultiplier = 1f)
		{
			return soundFX.PlaySoundAt(pos, delaySecs, volume, pitchMultiplier);
		}

		public void SetOnFinished(System.Action onFinished)
		{
			soundFX.SetOnFinished(onFinished);
		}

		public void SetOnFinished(Action<object> onFinished, object obj)
		{
			soundFX.SetOnFinished(onFinished, obj);
		}

		public bool StopSound()
		{
			return soundFX.StopSound();
		}

		public void AttachToParent(Transform parent)
		{
			soundFX.AttachToParent(parent);
		}

		public void DetachFromParent()
		{
			soundFX.DetachFromParent();
		}
	}
}
namespace MalbersAnimations
{
	public class Readme : ScriptableObject
	{
		[Serializable]
		public class Section
		{
			public string heading;

			public string text;

			public string linkText;

			public string url;
		}

		public Texture2D icon;

		public string title;

		public Section[] sections;
	}
	public class UseTransform : MonoBehaviour
	{
		public enum UpdateMode
		{
			Update = 1,
			FixedUpdate = 2,
			LateUpdate = 4
		}

		public Transform Reference;

		public bool rotation = true;

		public UpdateMode updateMode = UpdateMode.LateUpdate;

		private void Update()
		{
			if (updateMode == UpdateMode.Update)
			{
				SetTransformReference();
			}
		}

		private void LateUpdate()
		{
			if (updateMode == UpdateMode.LateUpdate)
			{
				SetTransformReference();
			}
		}

		private void FixedUpdate()
		{
			if (updateMode == UpdateMode.FixedUpdate)
			{
				SetTransformReference();
			}
		}

		private void SetTransformReference()
		{
			if ((bool)Reference)
			{
				base.transform.position = Reference.position;
				if (rotation)
				{
					base.transform.rotation = Reference.rotation;
				}
			}
		}
	}
}
namespace MalbersAnimations.Events
{
	public class UnityEventRaiser : MonoBehaviour
	{
		public float Delayed;

		public UnityEvent OnEnableEvent;

		public void OnEnable()
		{
			if (Delayed > 0f)
			{
				Invoke("StartEvent", Delayed);
			}
			else
			{
				OnEnableEvent.Invoke();
			}
		}

		private void StartEvent()
		{
			OnEnableEvent.Invoke();
		}

		public void DestroyMe(float time)
		{
			UnityEngine.Object.Destroy(base.gameObject, time);
		}

		public void DestroyMe()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}

		public void DestroyGameObject(GameObject go)
		{
			UnityEngine.Object.Destroy(go);
		}

		public void DestroyComponent(Component component)
		{
			UnityEngine.Object.Destroy(component);
		}

		public void Parent(Transform newParent)
		{
			base.transform.parent = newParent;
		}
	}
}
namespace UnityStandardAssets.ImageEffects
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Bloom and Glow/Bloom")]
	public class Bloom : PostEffectsBase
	{
		public enum LensFlareStyle
		{
			Ghosting,
			Anamorphic,
			Combined
		}

		public enum TweakMode
		{
			Basic,
			Complex
		}

		public enum HDRBloomMode
		{
			Auto,
			On,
			Off
		}

		public enum BloomScreenBlendMode
		{
			Screen,
			Add
		}

		public enum BloomQuality
		{
			Cheap,
			High
		}

		public TweakMode tweakMode;

		public BloomScreenBlendMode screenBlendMode = BloomScreenBlendMode.Add;

		public HDRBloomMode hdr;

		private bool doHdr;

		public float sepBlurSpread = 2.5f;

		public BloomQuality quality = BloomQuality.High;

		public float bloomIntensity = 0.5f;

		public float bloomThreshold = 0.5f;

		public Color bloomThresholdColor = Color.white;

		public int bloomBlurIterations = 2;

		public int hollywoodFlareBlurIterations = 2;

		public float flareRotation;

		public LensFlareStyle lensflareMode = LensFlareStyle.Anamorphic;

		public float hollyStretchWidth = 2.5f;

		public float lensflareIntensity;

		public float lensflareThreshold = 0.3f;

		public float lensFlareSaturation = 0.75f;

		public Color flareColorA = new Color(0.4f, 0.4f, 0.8f, 0.75f);

		public Color flareColorB = new Color(0.4f, 0.8f, 0.8f, 0.75f);

		public Color flareColorC = new Color(0.8f, 0.4f, 0.8f, 0.75f);

		public Color flareColorD = new Color(0.8f, 0.4f, 0f, 0.75f);

		public Texture2D lensFlareVignetteMask;

		public Shader lensFlareShader;

		private Material lensFlareMaterial;

		public Shader screenBlendShader;

		private Material screenBlend;

		public Shader blurAndFlaresShader;

		private Material blurAndFlaresMaterial;

		public Shader brightPassFilterShader;

		private Material brightPassFilterMaterial;

		public override bool CheckResources()
		{
			CheckSupport(needDepth: false);
			screenBlend = CheckShaderAndCreateMaterial(screenBlendShader, screenBlend);
			lensFlareMaterial = CheckShaderAndCreateMaterial(lensFlareShader, lensFlareMaterial);
			blurAndFlaresMaterial = CheckShaderAndCreateMaterial(blurAndFlaresShader, blurAndFlaresMaterial);
			brightPassFilterMaterial = CheckShaderAndCreateMaterial(brightPassFilterShader, brightPassFilterMaterial);
			if (!isSupported)
			{
				ReportAutoDisable();
			}
			return isSupported;
		}

		public void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			if (!CheckResources())
			{
				Graphics.Blit(source, destination);
				return;
			}
			doHdr = false;
			if (hdr == HDRBloomMode.Auto)
			{
				doHdr = source.format == RenderTextureFormat.ARGBHalf && GetComponent<Camera>().allowHDR;
			}
			else
			{
				doHdr = hdr == HDRBloomMode.On;
			}
			doHdr = doHdr && supportHDRTextures;
			BloomScreenBlendMode bloomScreenBlendMode = screenBlendMode;
			if (doHdr)
			{
				bloomScreenBlendMode = BloomScreenBlendMode.Add;
			}
			RenderTextureFormat format = (doHdr ? RenderTextureFormat.ARGBHalf : RenderTextureFormat.Default);
			int width = source.width / 2;
			int height = source.height / 2;
			int width2 = source.width / 4;
			int height2 = source.height / 4;
			float num = 1f * (float)source.width / (1f * (float)source.height);
			float num2 = 0.001953125f;
			RenderTexture temporary = RenderTexture.GetTemporary(width2, height2, 0, format);
			RenderTexture temporary2 = RenderTexture.GetTemporary(width, height, 0, format);
			if (quality > BloomQuality.Cheap)
			{
				Graphics.Blit(source, temporary2, screenBlend, 2);
				RenderTexture temporary3 = RenderTexture.GetTemporary(width2, height2, 0, format);
				Graphics.Blit(temporary2, temporary3, screenBlend, 2);
				Graphics.Blit(temporary3, temporary, screenBlend, 6);
				RenderTexture.ReleaseTemporary(temporary3);
			}
			else
			{
				Graphics.Blit(source, temporary2);
				Graphics.Blit(temporary2, temporary, screenBlend, 6);
			}
			RenderTexture.ReleaseTemporary(temporary2);
			RenderTexture renderTexture = RenderTexture.GetTemporary(width2, height2, 0, format);
			BrightFilter(bloomThreshold * bloomThresholdColor, temporary, renderTexture);
			if (bloomBlurIterations < 1)
			{
				bloomBlurIterations = 1;
			}
			else if (bloomBlurIterations > 10)
			{
				bloomBlurIterations = 10;
			}
			for (int i = 0; i < bloomBlurIterations; i++)
			{
				float num3 = (1f + (float)i * 0.25f) * sepBlurSpread;
				RenderTexture temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, num3 * num2, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				temporary4 = RenderTexture.GetTemporary(width2, height2, 0, format);
				blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num3 / num * num2, 0f, 0f, 0f));
				Graphics.Blit(renderTexture, temporary4, blurAndFlaresMaterial, 4);
				RenderTexture.ReleaseTemporary(renderTexture);
				renderTexture = temporary4;
				if (quality > BloomQuality.Cheap)
				{
					if (i == 0)
					{
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(renderTexture, temporary);
					}
					else
					{
						temporary.MarkRestoreExpected();
						Graphics.Blit(renderTexture, temporary, screenBlend, 10);
					}
				}
			}
			if (quality > BloomQuality.Cheap)
			{
				Graphics.SetRenderTarget(renderTexture);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(temporary, renderTexture, screenBlend, 6);
			}
			if (lensflareIntensity > Mathf.Epsilon)
			{
				RenderTexture temporary5 = RenderTexture.GetTemporary(width2, height2, 0, format);
				if (lensflareMode == LensFlareStyle.Ghosting)
				{
					BrightFilter(lensflareThreshold, renderTexture, temporary5);
					if (quality > BloomQuality.Cheap)
					{
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(0f, 1.5f / (1f * (float)temporary.height), 0f, 0f));
						Graphics.SetRenderTarget(temporary);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(1.5f / (1f * (float)temporary.width), 0f, 0f, 0f));
						Graphics.SetRenderTarget(temporary5);
						GL.Clear(clearDepth: false, clearColor: true, Color.black);
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
					}
					Vignette(0.975f, temporary5, temporary5);
					BlendFlares(temporary5, renderTexture);
				}
				else
				{
					float num4 = 1f * Mathf.Cos(flareRotation);
					float num5 = 1f * Mathf.Sin(flareRotation);
					float num6 = hollyStretchWidth * 1f / num * num2;
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4, num5, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_Threshhold", new Vector4(lensflareThreshold, 1f, 0f, 0f));
					blurAndFlaresMaterial.SetVector("_TintColor", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * flareColorA.a * lensflareIntensity);
					blurAndFlaresMaterial.SetFloat("_Saturation", lensFlareSaturation);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 2);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 3);
					blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num4 * num6, num5 * num6, 0f, 0f));
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 2f);
					temporary5.DiscardContents();
					Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 1);
					blurAndFlaresMaterial.SetFloat("_StretchWidth", hollyStretchWidth * 4f);
					temporary.DiscardContents();
					Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 1);
					for (int j = 0; j < hollywoodFlareBlurIterations; j++)
					{
						num6 = hollyStretchWidth * 2f / num * num2;
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary5.DiscardContents();
						Graphics.Blit(temporary, temporary5, blurAndFlaresMaterial, 4);
						blurAndFlaresMaterial.SetVector("_Offsets", new Vector4(num6 * num4, num6 * num5, 0f, 0f));
						temporary.DiscardContents();
						Graphics.Blit(temporary5, temporary, blurAndFlaresMaterial, 4);
					}
					if (lensflareMode == LensFlareStyle.Anamorphic)
					{
						AddTo(1f, temporary, renderTexture);
					}
					else
					{
						Vignette(1f, temporary, temporary5);
						BlendFlares(temporary5, temporary);
						AddTo(1f, temporary, renderTexture);
					}
				}
				RenderTexture.ReleaseTemporary(temporary5);
			}
			int pass = (int)bloomScreenBlendMode;
			screenBlend.SetFloat("_Intensity", bloomIntensity);
			screenBlend.SetTexture("_ColorBuffer", source);
			if (quality > BloomQuality.Cheap)
			{
				RenderTexture temporary6 = RenderTexture.GetTemporary(width, height, 0, format);
				Graphics.Blit(renderTexture, temporary6);
				Graphics.Blit(temporary6, destination, screenBlend, pass);
				RenderTexture.ReleaseTemporary(temporary6);
			}
			else
			{
				Graphics.Blit(renderTexture, destination, screenBlend, pass);
			}
			RenderTexture.ReleaseTemporary(temporary);
			RenderTexture.ReleaseTemporary(renderTexture);
		}

		private void AddTo(float intensity_, RenderTexture from, RenderTexture to)
		{
			screenBlend.SetFloat("_Intensity", intensity_);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, screenBlend, 9);
		}

		private void BlendFlares(RenderTexture from, RenderTexture to)
		{
			lensFlareMaterial.SetVector("colorA", new Vector4(flareColorA.r, flareColorA.g, flareColorA.b, flareColorA.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorB", new Vector4(flareColorB.r, flareColorB.g, flareColorB.b, flareColorB.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorC", new Vector4(flareColorC.r, flareColorC.g, flareColorC.b, flareColorC.a) * lensflareIntensity);
			lensFlareMaterial.SetVector("colorD", new Vector4(flareColorD.r, flareColorD.g, flareColorD.b, flareColorD.a) * lensflareIntensity);
			to.MarkRestoreExpected();
			Graphics.Blit(from, to, lensFlareMaterial);
		}

		private void BrightFilter(float thresh, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", new Vector4(thresh, thresh, thresh, thresh));
			Graphics.Blit(from, to, brightPassFilterMaterial, 0);
		}

		private void BrightFilter(Color threshColor, RenderTexture from, RenderTexture to)
		{
			brightPassFilterMaterial.SetVector("_Threshhold", threshColor);
			Graphics.Blit(from, to, brightPassFilterMaterial, 1);
		}

		private void Vignette(float amount, RenderTexture from, RenderTexture to)
		{
			if ((bool)lensFlareVignetteMask)
			{
				screenBlend.SetTexture("_ColorBuffer", lensFlareVignetteMask);
				to.MarkRestoreExpected();
				Graphics.Blit((from == to) ? null : from, to, screenBlend, (from == to) ? 7 : 3);
			}
			else if (from != to)
			{
				Graphics.SetRenderTarget(to);
				GL.Clear(clearDepth: false, clearColor: true, Color.black);
				Graphics.Blit(from, to);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	public class PostEffectsBase : MonoBehaviour
	{
		protected bool supportHDRTextures = true;

		protected bool supportDX11;

		protected bool isSupported = true;

		protected Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				base.enabled = false;
				return null;
			}
			if (s.isSupported && (bool)m2Create && m2Create.shader == s)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				NotSupported();
				UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not supported on this platform!");
				return null;
			}
			m2Create = new Material(s);
			m2Create.hideFlags = HideFlags.DontSave;
			if ((bool)m2Create)
			{
				return m2Create;
			}
			return null;
		}

		protected Material CreateMaterial(Shader s, Material m2Create)
		{
			if (!s)
			{
				UnityEngine.Debug.Log("Missing shader in " + ToString());
				return null;
			}
			if ((bool)m2Create && m2Create.shader == s && s.isSupported)
			{
				return m2Create;
			}
			if (!s.isSupported)
			{
				return null;
			}
			m2Create = new Material(s);
			m2Create.hideFlags = HideFlags.DontSave;
			if ((bool)m2Create)
			{
				return m2Create;
			}
			return null;
		}

		private void OnEnable()
		{
			isSupported = true;
		}

		protected bool CheckSupport()
		{
			return CheckSupport(needDepth: false);
		}

		public virtual bool CheckResources()
		{
			UnityEngine.Debug.LogWarning("CheckResources () for " + ToString() + " should be overwritten.");
			return isSupported;
		}

		protected void Start()
		{
			CheckResources();
		}

		protected bool CheckSupport(bool needDepth)
		{
			isSupported = true;
			supportHDRTextures = SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf);
			supportDX11 = SystemInfo.graphicsShaderLevel >= 50 && SystemInfo.supportsComputeShaders;
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				NotSupported();
				return false;
			}
			if (needDepth)
			{
				GetComponent<Camera>().depthTextureMode |= DepthTextureMode.Depth;
			}
			return true;
		}

		protected bool CheckSupport(bool needDepth, bool needHdr)
		{
			if (!CheckSupport(needDepth))
			{
				return false;
			}
			if (needHdr && !supportHDRTextures)
			{
				NotSupported();
				return false;
			}
			return true;
		}

		public bool Dx11Support()
		{
			return supportDX11;
		}

		protected void ReportAutoDisable()
		{
			UnityEngine.Debug.LogWarning("The image effect " + ToString() + " has been disabled as it's not supported on the current platform.");
		}

		private bool CheckShader(Shader s)
		{
			UnityEngine.Debug.Log("The shader " + s.ToString() + " on effect " + ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package.");
			if (!s.isSupported)
			{
				NotSupported();
				return false;
			}
			return false;
		}

		protected void NotSupported()
		{
			base.enabled = false;
			isSupported = false;
		}

		protected void DrawBorder(RenderTexture dest, Material material)
		{
			RenderTexture.active = dest;
			bool flag = true;
			GL.PushMatrix();
			GL.LoadOrtho();
			for (int i = 0; i < material.passCount; i++)
			{
				material.SetPass(i);
				float y;
				float y2;
				if (flag)
				{
					y = 1f;
					y2 = 0f;
				}
				else
				{
					y = 0f;
					y2 = 1f;
				}
				float x = 0f + 1f / ((float)dest.width * 1f);
				float y3 = 0f;
				float y4 = 1f;
				GL.Begin(7);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				float x2 = 1f - 1f / ((float)dest.width * 1f);
				x = 1f;
				y3 = 0f;
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(x2, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(x2, y4, 0.1f);
				x = 1f;
				y3 = 0f;
				y4 = 0f + 1f / ((float)dest.height * 1f);
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				x = 1f;
				y3 = 1f - 1f / ((float)dest.height * 1f);
				y4 = 1f;
				GL.TexCoord2(0f, y);
				GL.Vertex3(0f, y3, 0.1f);
				GL.TexCoord2(1f, y);
				GL.Vertex3(x, y3, 0.1f);
				GL.TexCoord2(1f, y2);
				GL.Vertex3(x, y4, 0.1f);
				GL.TexCoord2(0f, y2);
				GL.Vertex3(0f, y4, 0.1f);
				GL.End();
			}
			GL.PopMatrix();
		}
	}
}
namespace UnityStandardAssets.CinematicEffects
{
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Cinematic/ME_Bloom")]
	[ImageEffectAllowedInSceneView]
	public class ME_Bloom : MonoBehaviour
	{
		[Serializable]
		public struct Settings
		{
			[SerializeField]
			[UnityEngine.Tooltip("Filters out pixels under this level of brightness.")]
			public float threshold;

			[SerializeField]
			[Range(0f, 1f)]
			[UnityEngine.Tooltip("Makes transition between under/over-threshold gradual.")]
			public float softKnee;

			[SerializeField]
			[Range(1f, 7f)]
			[UnityEngine.Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
			public float radius;

			[SerializeField]
			[UnityEngine.Tooltip("Blend factor of the result image.")]
			public float intensity;

			[SerializeField]
			[UnityEngine.Tooltip("Controls filter quality and buffer resolution.")]
			public bool highQuality;

			[SerializeField]
			[UnityEngine.Tooltip("Reduces flashing noise with an additional filter.")]
			public bool antiFlicker;

			[UnityEngine.Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
			public Texture dirtTexture;

			[ME_Min(0f)]
			[UnityEngine.Tooltip("Amount of lens dirtiness.")]
			public float dirtIntensity;

			public float thresholdGamma
			{
				get
				{
					return Mathf.Max(0f, threshold);
				}
				set
				{
					threshold = value;
				}
			}

			public float thresholdLinear
			{
				get
				{
					return Mathf.GammaToLinearSpace(thresholdGamma);
				}
				set
				{
					threshold = Mathf.LinearToGammaSpace(value);
				}
			}

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.threshold = 1.1f;
					result.softKnee = 0.1f;
					result.radius = 7f;
					result.intensity = 0.5f;
					result.highQuality = true;
					result.antiFlicker = true;
					result.dirtTexture = null;
					result.dirtIntensity = 2.5f;
					return result;
				}
			}
		}

		[SerializeField]
		public Settings settings = Settings.defaultSettings;

		[SerializeField]
		[HideInInspector]
		private Shader m_Shader;

		private Material m_Material;

		private const int kMaxIterations = 16;

		private RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

		private RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

		private int m_Threshold;

		private int m_Curve;

		private int m_PrefilterOffs;

		private int m_SampleScale;

		private int m_Intensity;

		private int m_DirtTex;

		private int m_DirtIntensity;

		private int m_BaseTex;

		public Shader shader
		{
			get
			{
				if (m_Shader == null)
				{
					m_Shader = Shader.Find("Hidden/Image Effects/Cinematic/ME_Bloom");
				}
				return m_Shader;
			}
		}

		public Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = ME_ImageEffectHelper.CheckShaderAndCreateMaterial(shader);
				}
				return m_Material;
			}
		}

		private void Awake()
		{
			m_Threshold = Shader.PropertyToID("_Threshold");
			m_Curve = Shader.PropertyToID("_Curve");
			m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
			m_SampleScale = Shader.PropertyToID("_SampleScale");
			m_Intensity = Shader.PropertyToID("_Intensity");
			m_DirtTex = Shader.PropertyToID("_DirtTex");
			m_DirtIntensity = Shader.PropertyToID("_DirtIntensity");
			m_BaseTex = Shader.PropertyToID("_BaseTex");
		}

		private void OnEnable()
		{
			if (!ME_ImageEffectHelper.IsSupported(shader, needDepth: true, needHdr: false, this))
			{
				base.enabled = false;
			}
		}

		private void OnDisable()
		{
			if (m_Material != null)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
			m_Material = null;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
			int num = source.width;
			int num2 = source.height;
			if (!settings.highQuality)
			{
				num /= 2;
				num2 /= 2;
			}
			RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
			float num3 = Mathf.Log(num2, 2f) + settings.radius - 8f;
			int num4 = (int)num3;
			int num5 = Mathf.Clamp(num4, 1, 16);
			float thresholdLinear = settings.thresholdLinear;
			material.SetFloat(m_Threshold, thresholdLinear);
			float num6 = thresholdLinear * settings.softKnee + 1E-05f;
			Vector3 vector = new Vector3(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
			material.SetVector(m_Curve, vector);
			bool flag = !settings.highQuality && settings.antiFlicker;
			material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
			material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
			material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
			bool flag2 = false;
			if (settings.dirtTexture != null)
			{
				material.SetTexture(m_DirtTex, settings.dirtTexture);
				material.SetFloat(m_DirtIntensity, settings.dirtIntensity);
				flag2 = true;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
			Graphics.Blit(source, temporary, material, settings.antiFlicker ? 1 : 0);
			RenderTexture renderTexture = temporary;
			for (int i = 0; i < num5; i++)
			{
				m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
				renderTexture = m_blurBuffer1[i];
			}
			for (int num7 = num5 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture2 = m_blurBuffer1[num7];
				material.SetTexture(m_BaseTex, renderTexture2);
				m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
				renderTexture = m_blurBuffer2[num7];
			}
			int num8 = (flag2 ? 9 : 7);
			num8 += (settings.highQuality ? 1 : 0);
			material.SetTexture(m_BaseTex, source);
			Graphics.Blit(renderTexture, destination, material, num8);
			for (int j = 0; j < 16; j++)
			{
				if (m_blurBuffer1[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
				}
				if (m_blurBuffer2[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
				}
				m_blurBuffer1[j] = null;
				m_blurBuffer2[j] = null;
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	public static class ME_ImageEffectHelper
	{
		public static bool supportsDX11
		{
			get
			{
				if (SystemInfo.graphicsShaderLevel >= 50)
				{
					return SystemInfo.supportsComputeShaders;
				}
				return false;
			}
		}

		public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
		{
			if (s == null || !s.isSupported)
			{
				UnityEngine.Debug.LogWarningFormat("Missing shader for image effect {0}", effect);
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				UnityEngine.Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", effect);
				return false;
			}
			if (needHdr && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
			{
				UnityEngine.Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", effect);
				return false;
			}
			return true;
		}

		public static Material CheckShaderAndCreateMaterial(Shader s)
		{
			if (s == null || !s.isSupported)
			{
				return null;
			}
			return new Material(s)
			{
				hideFlags = HideFlags.DontSave
			};
		}
	}
	public sealed class ME_MinAttribute : PropertyAttribute
	{
		public readonly float min;

		public ME_MinAttribute(float min)
		{
			this.min = min;
		}
	}
	public class ME_RenderTextureUtility
	{
		private List<RenderTexture> m_TemporaryRTs = new List<RenderTexture>();

		public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, FilterMode filterMode = FilterMode.Bilinear)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format);
			temporary.filterMode = filterMode;
			temporary.wrapMode = TextureWrapMode.Clamp;
			temporary.name = "RenderTextureUtilityTempTexture";
			m_TemporaryRTs.Add(temporary);
			return temporary;
		}

		public void ReleaseTemporaryRenderTexture(RenderTexture rt)
		{
			if (!(rt == null))
			{
				if (!m_TemporaryRTs.Contains(rt))
				{
					UnityEngine.Debug.LogErrorFormat("Attempting to remove texture that was not allocated: {0}", rt);
				}
				else
				{
					m_TemporaryRTs.Remove(rt);
					RenderTexture.ReleaseTemporary(rt);
				}
			}
		}

		public void ReleaseAllTemporaryRenderTextures()
		{
			for (int i = 0; i < m_TemporaryRTs.Count; i++)
			{
				RenderTexture.ReleaseTemporary(m_TemporaryRTs[i]);
			}
			m_TemporaryRTs.Clear();
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Cinematic/Bloom")]
	[ImageEffectAllowedInSceneView]
	public class Bloom : MonoBehaviour
	{
		[Serializable]
		public struct Settings
		{
			[SerializeField]
			[UnityEngine.Tooltip("Filters out pixels under this level of brightness.")]
			public float threshold;

			[SerializeField]
			[Range(0f, 1f)]
			[UnityEngine.Tooltip("Makes transition between under/over-threshold gradual.")]
			public float softKnee;

			[SerializeField]
			[Range(1f, 7f)]
			[UnityEngine.Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
			public float radius;

			[SerializeField]
			[UnityEngine.Tooltip("Blend factor of the result image.")]
			public float intensity;

			[SerializeField]
			[UnityEngine.Tooltip("Controls filter quality and buffer resolution.")]
			public bool highQuality;

			[SerializeField]
			[UnityEngine.Tooltip("Reduces flashing noise with an additional filter.")]
			public bool antiFlicker;

			[UnityEngine.Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
			public Texture dirtTexture;

			[Min(0f)]
			[UnityEngine.Tooltip("Amount of lens dirtiness.")]
			public float dirtIntensity;

			public float thresholdGamma
			{
				get
				{
					return Mathf.Max(0f, threshold);
				}
				set
				{
					threshold = value;
				}
			}

			public float thresholdLinear
			{
				get
				{
					return Mathf.GammaToLinearSpace(thresholdGamma);
				}
				set
				{
					threshold = Mathf.LinearToGammaSpace(value);
				}
			}

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.threshold = 0.9f;
					result.softKnee = 0.5f;
					result.radius = 2f;
					result.intensity = 0.7f;
					result.highQuality = true;
					result.antiFlicker = false;
					result.dirtTexture = null;
					result.dirtIntensity = 2.5f;
					return result;
				}
			}
		}

		[SerializeField]
		public Settings settings = Settings.defaultSettings;

		[SerializeField]
		[HideInInspector]
		private Shader m_Shader;

		private Material m_Material;

		private const int kMaxIterations = 16;

		private RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

		private RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

		private int m_Threshold;

		private int m_Curve;

		private int m_PrefilterOffs;

		private int m_SampleScale;

		private int m_Intensity;

		private int m_DirtTex;

		private int m_DirtIntensity;

		private int m_BaseTex;

		public Shader shader
		{
			get
			{
				if (m_Shader == null)
				{
					m_Shader = Shader.Find("Hidden/Image Effects/Cinematic/Bloom");
				}
				return m_Shader;
			}
		}

		public Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = ImageEffectHelper.CheckShaderAndCreateMaterial(shader);
				}
				return m_Material;
			}
		}

		private void Awake()
		{
			m_Threshold = Shader.PropertyToID("_Threshold");
			m_Curve = Shader.PropertyToID("_Curve");
			m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
			m_SampleScale = Shader.PropertyToID("_SampleScale");
			m_Intensity = Shader.PropertyToID("_Intensity");
			m_DirtTex = Shader.PropertyToID("_DirtTex");
			m_DirtIntensity = Shader.PropertyToID("_DirtIntensity");
			m_BaseTex = Shader.PropertyToID("_BaseTex");
		}

		private void OnEnable()
		{
			if (!ImageEffectHelper.IsSupported(shader, needDepth: true, needHdr: false, this))
			{
				base.enabled = false;
			}
		}

		private void OnDisable()
		{
			if (m_Material != null)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
			m_Material = null;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
			int num = source.width;
			int num2 = source.height;
			if (!settings.highQuality)
			{
				num /= 2;
				num2 /= 2;
			}
			RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
			float num3 = Mathf.Log(num2, 2f) + settings.radius - 8f;
			int num4 = (int)num3;
			int num5 = Mathf.Clamp(num4, 1, 16);
			float thresholdLinear = settings.thresholdLinear;
			material.SetFloat(m_Threshold, thresholdLinear);
			float num6 = thresholdLinear * settings.softKnee + 1E-05f;
			Vector3 vector = new Vector3(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
			material.SetVector(m_Curve, vector);
			bool flag = !settings.highQuality && settings.antiFlicker;
			material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
			material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
			material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
			bool flag2 = false;
			if (settings.dirtTexture != null)
			{
				material.SetTexture(m_DirtTex, settings.dirtTexture);
				material.SetFloat(m_DirtIntensity, settings.dirtIntensity);
				flag2 = true;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
			Graphics.Blit(source, temporary, material, settings.antiFlicker ? 1 : 0);
			RenderTexture renderTexture = temporary;
			for (int i = 0; i < num5; i++)
			{
				m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
				renderTexture = m_blurBuffer1[i];
			}
			for (int num7 = num5 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture2 = m_blurBuffer1[num7];
				material.SetTexture(m_BaseTex, renderTexture2);
				m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
				renderTexture = m_blurBuffer2[num7];
			}
			int num8 = (flag2 ? 9 : 7);
			num8 += (settings.highQuality ? 1 : 0);
			material.SetTexture(m_BaseTex, source);
			Graphics.Blit(renderTexture, destination, material, num8);
			for (int j = 0; j < 16; j++)
			{
				if (m_blurBuffer1[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
				}
				if (m_blurBuffer2[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
				}
				m_blurBuffer1[j] = null;
				m_blurBuffer2[j] = null;
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(Camera))]
	[AddComponentMenu("Image Effects/Cinematic/RFX1_Bloom")]
	[ImageEffectAllowedInSceneView]
	public class RFX1_Bloom : MonoBehaviour
	{
		[Serializable]
		public struct Settings
		{
			[SerializeField]
			[UnityEngine.Tooltip("Filters out pixels under this level of brightness.")]
			public float threshold;

			[SerializeField]
			[Range(0f, 1f)]
			[UnityEngine.Tooltip("Makes transition between under/over-threshold gradual.")]
			public float softKnee;

			[SerializeField]
			[Range(1f, 7f)]
			[UnityEngine.Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
			public float radius;

			[SerializeField]
			[UnityEngine.Tooltip("Blend factor of the result image.")]
			public float intensity;

			[SerializeField]
			[UnityEngine.Tooltip("Controls filter quality and buffer resolution.")]
			public bool highQuality;

			[SerializeField]
			[UnityEngine.Tooltip("Reduces flashing noise with an additional filter.")]
			public bool antiFlicker;

			[UnityEngine.Tooltip("Dirtiness texture to add smudges or dust to the lens.")]
			public Texture dirtTexture;

			[RFX1_Min(0f)]
			[UnityEngine.Tooltip("Amount of lens dirtiness.")]
			public float dirtIntensity;

			public float thresholdGamma
			{
				get
				{
					return Mathf.Max(0f, threshold);
				}
				set
				{
					threshold = value;
				}
			}

			public float thresholdLinear
			{
				get
				{
					return Mathf.GammaToLinearSpace(thresholdGamma);
				}
				set
				{
					threshold = Mathf.LinearToGammaSpace(value);
				}
			}

			public static Settings defaultSettings
			{
				get
				{
					Settings result = default(Settings);
					result.threshold = 0.9f;
					result.softKnee = 0.5f;
					result.radius = 2f;
					result.intensity = 0.7f;
					result.highQuality = true;
					result.antiFlicker = false;
					result.dirtTexture = null;
					result.dirtIntensity = 2.5f;
					return result;
				}
			}
		}

		[SerializeField]
		public Settings settings = Settings.defaultSettings;

		[SerializeField]
		[HideInInspector]
		private Shader m_Shader;

		private Material m_Material;

		private const int kMaxIterations = 16;

		private RenderTexture[] m_blurBuffer1 = new RenderTexture[16];

		private RenderTexture[] m_blurBuffer2 = new RenderTexture[16];

		private int m_Threshold;

		private int m_Curve;

		private int m_PrefilterOffs;

		private int m_SampleScale;

		private int m_Intensity;

		private int m_DirtTex;

		private int m_DirtIntensity;

		private int m_BaseTex;

		public Shader shader
		{
			get
			{
				if (m_Shader == null)
				{
					m_Shader = Shader.Find("Hidden/Image Effects/Cinematic/RFX1_Bloom");
				}
				return m_Shader;
			}
		}

		public Material material
		{
			get
			{
				if (m_Material == null)
				{
					m_Material = RFX1_ImageEffectHelper.CheckShaderAndCreateMaterial(shader);
				}
				return m_Material;
			}
		}

		private void Awake()
		{
			m_Threshold = Shader.PropertyToID("_Threshold");
			m_Curve = Shader.PropertyToID("_Curve");
			m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
			m_SampleScale = Shader.PropertyToID("_SampleScale");
			m_Intensity = Shader.PropertyToID("_Intensity");
			m_DirtTex = Shader.PropertyToID("_DirtTex");
			m_DirtIntensity = Shader.PropertyToID("_DirtIntensity");
			m_BaseTex = Shader.PropertyToID("_BaseTex");
		}

		private void OnEnable()
		{
			if (!RFX1_ImageEffectHelper.IsSupported(shader, needDepth: true, needHdr: false, this))
			{
				base.enabled = false;
			}
		}

		private void OnDisable()
		{
			if (m_Material != null)
			{
				UnityEngine.Object.DestroyImmediate(m_Material);
			}
			m_Material = null;
		}

		private void OnRenderImage(RenderTexture source, RenderTexture destination)
		{
			bool isMobilePlatform = UnityEngine.Application.isMobilePlatform;
			int num = source.width;
			int num2 = source.height;
			if (!settings.highQuality)
			{
				num /= 2;
				num2 /= 2;
			}
			RenderTextureFormat format = (isMobilePlatform ? RenderTextureFormat.Default : RenderTextureFormat.DefaultHDR);
			float num3 = Mathf.Log(num2, 2f) + settings.radius - 8f;
			int num4 = (int)num3;
			int num5 = Mathf.Clamp(num4, 1, 16);
			float thresholdLinear = settings.thresholdLinear;
			material.SetFloat(m_Threshold, thresholdLinear);
			float num6 = thresholdLinear * settings.softKnee + 1E-05f;
			Vector3 vector = new Vector3(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
			material.SetVector(m_Curve, vector);
			bool flag = !settings.highQuality && settings.antiFlicker;
			material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
			material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
			material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
			bool flag2 = false;
			if (settings.dirtTexture != null)
			{
				material.SetTexture(m_DirtTex, settings.dirtTexture);
				material.SetFloat(m_DirtIntensity, settings.dirtIntensity);
				flag2 = true;
			}
			RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, format);
			Graphics.Blit(source, temporary, material, settings.antiFlicker ? 1 : 0);
			RenderTexture renderTexture = temporary;
			for (int i = 0; i < num5; i++)
			{
				m_blurBuffer1[i] = RenderTexture.GetTemporary(renderTexture.width / 2, renderTexture.height / 2, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
				renderTexture = m_blurBuffer1[i];
			}
			for (int num7 = num5 - 2; num7 >= 0; num7--)
			{
				RenderTexture renderTexture2 = m_blurBuffer1[num7];
				material.SetTexture(m_BaseTex, renderTexture2);
				m_blurBuffer2[num7] = RenderTexture.GetTemporary(renderTexture2.width, renderTexture2.height, 0, format);
				Graphics.Blit(renderTexture, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
				renderTexture = m_blurBuffer2[num7];
			}
			int num8 = (flag2 ? 9 : 7);
			num8 += (settings.highQuality ? 1 : 0);
			material.SetTexture(m_BaseTex, source);
			Graphics.Blit(renderTexture, destination, material, num8);
			for (int j = 0; j < 16; j++)
			{
				if (m_blurBuffer1[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
				}
				if (m_blurBuffer2[j] != null)
				{
					RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
				}
				m_blurBuffer1[j] = null;
				m_blurBuffer2[j] = null;
			}
			RenderTexture.ReleaseTemporary(temporary);
		}
	}
	public static class ImageEffectHelper
	{
		public static bool supportsDX11
		{
			get
			{
				if (SystemInfo.graphicsShaderLevel >= 50)
				{
					return SystemInfo.supportsComputeShaders;
				}
				return false;
			}
		}

		public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
		{
			if (s == null || !s.isSupported)
			{
				UnityEngine.Debug.LogWarningFormat("Missing shader for image effect {0}", effect);
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				UnityEngine.Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", effect);
				return false;
			}
			if (needHdr && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
			{
				UnityEngine.Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", effect);
				return false;
			}
			return true;
		}

		public static Material CheckShaderAndCreateMaterial(Shader s)
		{
			if (s == null || !s.isSupported)
			{
				return null;
			}
			return new Material(s)
			{
				hideFlags = HideFlags.DontSave
			};
		}
	}
	public sealed class MinAttribute : PropertyAttribute
	{
		public readonly float min;

		public MinAttribute(float min)
		{
			this.min = min;
		}
	}
	public static class RFX1_ImageEffectHelper
	{
		public static bool supportsDX11
		{
			get
			{
				if (SystemInfo.graphicsShaderLevel >= 50)
				{
					return SystemInfo.supportsComputeShaders;
				}
				return false;
			}
		}

		public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
		{
			if (s == null || !s.isSupported)
			{
				UnityEngine.Debug.LogWarningFormat("Missing shader for image effect {0}", effect);
				return false;
			}
			if (needDepth && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.Depth))
			{
				UnityEngine.Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", effect);
				return false;
			}
			if (needHdr && !SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf))
			{
				UnityEngine.Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", effect);
				return false;
			}
			return true;
		}

		public static Material CheckShaderAndCreateMaterial(Shader s)
		{
			if (s == null || !s.isSupported)
			{
				return null;
			}
			return new Material(s)
			{
				hideFlags = HideFlags.DontSave
			};
		}
	}
	public sealed class RFX1_MinAttribute : PropertyAttribute
	{
		public readonly float min;

		public RFX1_MinAttribute(float min)
		{
			this.min = min;
		}
	}
	public class RFX1_RenderTextureUtility
	{
		private List<RenderTexture> m_TemporaryRTs = new List<RenderTexture>();

		public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, FilterMode filterMode = FilterMode.Bilinear)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format);
			temporary.filterMode = filterMode;
			temporary.wrapMode = TextureWrapMode.Clamp;
			temporary.name = "RenderTextureUtilityTempTexture";
			m_TemporaryRTs.Add(temporary);
			return temporary;
		}

		public void ReleaseTemporaryRenderTexture(RenderTexture rt)
		{
			if (!(rt == null))
			{
				if (!m_TemporaryRTs.Contains(rt))
				{
					UnityEngine.Debug.LogErrorFormat("Attempting to remove texture that was not allocated: {0}", rt);
				}
				else
				{
					m_TemporaryRTs.Remove(rt);
					RenderTexture.ReleaseTemporary(rt);
				}
			}
		}

		public void ReleaseAllTemporaryRenderTextures()
		{
			for (int i = 0; i < m_TemporaryRTs.Count; i++)
			{
				RenderTexture.ReleaseTemporary(m_TemporaryRTs[i]);
			}
			m_TemporaryRTs.Clear();
		}
	}
	public class RenderTextureUtility
	{
		private List<RenderTexture> m_TemporaryRTs = new List<RenderTexture>();

		public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.ARGBHalf, FilterMode filterMode = FilterMode.Bilinear)
		{
			RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format);
			temporary.filterMode = filterMode;
			temporary.wrapMode = TextureWrapMode.Clamp;
			temporary.name = "RenderTextureUtilityTempTexture";
			m_TemporaryRTs.Add(temporary);
			return temporary;
		}

		public void ReleaseTemporaryRenderTexture(RenderTexture rt)
		{
			if (!(rt == null))
			{
				if (!m_TemporaryRTs.Contains(rt))
				{
					UnityEngine.Debug.LogErrorFormat("Attempting to remove texture that was not allocated: {0}", rt);
				}
				else
				{
					m_TemporaryRTs.Remove(rt);
					RenderTexture.ReleaseTemporary(rt);
				}
			}
		}

		public void ReleaseAllTemporaryRenderTextures()
		{
			for (int i = 0; i < m_TemporaryRTs.Count; i++)
			{
				RenderTexture.ReleaseTemporary(m_TemporaryRTs[i]);
			}
			m_TemporaryRTs.Clear();
		}
	}
}
