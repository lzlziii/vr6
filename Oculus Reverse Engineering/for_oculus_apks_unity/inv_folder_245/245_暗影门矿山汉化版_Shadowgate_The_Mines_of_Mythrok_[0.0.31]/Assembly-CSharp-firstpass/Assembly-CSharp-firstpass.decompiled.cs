using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using FluffyUnderware.Curvy.Components;
using FluffyUnderware.Curvy.Controllers;
using FluffyUnderware.Curvy.Generator;
using FluffyUnderware.Curvy.Generator.Modules;
using FluffyUnderware.Curvy.Shapes;
using FluffyUnderware.Curvy.ThirdParty.LibTessDotNet;
using FluffyUnderware.Curvy.Utils;
using FluffyUnderware.DevTools;
using FluffyUnderware.DevTools.Extensions;
using JetBrains.Annotations;
using MEC;
using Microsoft.CodeAnalysis;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Rendering;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnityEngine.UI;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
}
public class AnimationHelper : MonoBehaviour
{
	public void Play(Animation animation)
	{
		animation.Play();
	}

	public void RewindThenPlay(Animation animation)
	{
		animation.Rewind();
		animation.Play();
	}
}
public class MixingAnimator : MonoBehaviour
{
	public ModifierVariableMixShapes VariableMixShapes;

	private void Update()
	{
		Keyframe[] keys = VariableMixShapes.MixCurve.keys;
		keys[1].value = Mathf.Sin(Time.time);
		VariableMixShapes.MixCurve.keys = keys;
		VariableMixShapes.Dirty = true;
	}
}
public class SinusoidalMover : MonoBehaviour
{
	public float MovementAmplitude = 11f;

	private void Update()
	{
		base.transform.position = new Vector3(MovementAmplitude * Mathf.Sin(Time.time), base.transform.position.y, MovementAmplitude * Mathf.Sin(Time.time * 2f));
	}
}
public class ToggleBehaviourByTrigger : MonoBehaviour
{
	public Behaviour UIElement;

	private void OnTriggerEnter()
	{
		if ((bool)UIElement)
		{
			UIElement.enabled = !UIElement.enabled;
		}
	}
}
public static class MECExtensionMethods2
{
	public static IEnumerator<float> Delay(this IEnumerator<float> coroutine, float timeToDelay)
	{
		yield return Timing.WaitForSeconds(timeToDelay);
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> Delay(this IEnumerator<float> coroutine, Func<bool> condition)
	{
		while (!condition())
		{
			yield return 0f;
		}
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> Delay<T>(this IEnumerator<float> coroutine, T data, Func<T, bool> condition)
	{
		while (!condition(data))
		{
			yield return 0f;
		}
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> DelayFrames(this IEnumerator<float> coroutine, int framesToDelay)
	{
		while (framesToDelay-- > 0)
		{
			yield return 0f;
		}
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> CancelWith(this IEnumerator<float> coroutine, GameObject gameObject)
	{
		while (Timing.MainThread != Thread.CurrentThread || ((bool)gameObject && gameObject.activeInHierarchy && coroutine.MoveNext()))
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> CancelWith(this IEnumerator<float> coroutine, GameObject gameObject1, GameObject gameObject2)
	{
		while (Timing.MainThread != Thread.CurrentThread || ((bool)gameObject1 && gameObject1.activeInHierarchy && (bool)gameObject2 && gameObject2.activeInHierarchy && coroutine.MoveNext()))
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> CancelWith<T>(this IEnumerator<float> coroutine, T script) where T : MonoBehaviour
	{
		GameObject myGO = script.gameObject;
		while (Timing.MainThread != Thread.CurrentThread || ((bool)myGO && myGO.activeInHierarchy && script != null && coroutine.MoveNext()))
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> CancelWith(this IEnumerator<float> coroutine, Func<bool> condition)
	{
		if (condition != null)
		{
			while (Timing.MainThread != Thread.CurrentThread || (condition() && coroutine.MoveNext()))
			{
				yield return coroutine.Current;
			}
		}
	}

	public static IEnumerator<float> PauseWith(this IEnumerator<float> coroutine, GameObject gameObject)
	{
		while (Timing.MainThread == Thread.CurrentThread && (bool)gameObject)
		{
			if (gameObject.activeInHierarchy)
			{
				if (!coroutine.MoveNext())
				{
					break;
				}
				yield return coroutine.Current;
			}
			else
			{
				yield return float.NegativeInfinity;
			}
		}
	}

	public static IEnumerator<float> PauseWith(this IEnumerator<float> coroutine, GameObject gameObject1, GameObject gameObject2)
	{
		while (Timing.MainThread == Thread.CurrentThread && (bool)gameObject1 && (bool)gameObject2)
		{
			if (gameObject1.activeInHierarchy && gameObject2.activeInHierarchy)
			{
				if (!coroutine.MoveNext())
				{
					break;
				}
				yield return coroutine.Current;
			}
			else
			{
				yield return float.NegativeInfinity;
			}
		}
	}

	public static IEnumerator<float> PauseWith<T>(this IEnumerator<float> coroutine, T script) where T : MonoBehaviour
	{
		GameObject myGO = script.gameObject;
		while (Timing.MainThread == Thread.CurrentThread && (bool)myGO && myGO.GetComponent<T>() != null)
		{
			if (myGO.activeInHierarchy && script.enabled)
			{
				if (!coroutine.MoveNext())
				{
					break;
				}
				yield return coroutine.Current;
			}
			else
			{
				yield return float.NegativeInfinity;
			}
		}
	}

	public static IEnumerator<float> PauseWith(this IEnumerator<float> coroutine, Func<bool> condition)
	{
		if (condition != null)
		{
			while (Timing.MainThread != Thread.CurrentThread || (condition() && coroutine.MoveNext()))
			{
				yield return coroutine.Current;
			}
		}
	}

	public static IEnumerator<float> KillWith(this IEnumerator<float> coroutine, CoroutineHandle otherCoroutine)
	{
		while (otherCoroutine.IsRunning && coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> Append(this IEnumerator<float> coroutine, IEnumerator<float> nextCoroutine)
	{
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
		if (nextCoroutine != null)
		{
			while (nextCoroutine.MoveNext())
			{
				yield return nextCoroutine.Current;
			}
		}
	}

	public static IEnumerator<float> Append(this IEnumerator<float> coroutine, Action onDone)
	{
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
		onDone?.Invoke();
	}

	public static IEnumerator<float> Prepend(this IEnumerator<float> coroutine, IEnumerator<float> lastCoroutine)
	{
		if (lastCoroutine != null)
		{
			while (lastCoroutine.MoveNext())
			{
				yield return lastCoroutine.Current;
			}
		}
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> Prepend(this IEnumerator<float> coroutine, Action onStart)
	{
		onStart?.Invoke();
		while (coroutine.MoveNext())
		{
			yield return coroutine.Current;
		}
	}

	public static IEnumerator<float> Superimpose(this IEnumerator<float> coroutineA, IEnumerator<float> coroutineB)
	{
		return coroutineA.Superimpose(coroutineB, Timing.Instance);
	}

	public static IEnumerator<float> Superimpose(this IEnumerator<float> coroutineA, IEnumerator<float> coroutineB, Timing instance)
	{
		while (coroutineA != null || coroutineB != null)
		{
			if (coroutineA != null && !(instance.localTime < coroutineA.Current) && !coroutineA.MoveNext())
			{
				coroutineA = null;
			}
			if (coroutineB != null && !(instance.localTime < coroutineB.Current) && !coroutineB.MoveNext())
			{
				coroutineB = null;
			}
			if ((coroutineA != null && float.IsNaN(coroutineA.Current)) || (coroutineB != null && float.IsNaN(coroutineB.Current)))
			{
				yield return float.NaN;
			}
			else if (coroutineA != null && coroutineB != null)
			{
				yield return (coroutineA.Current < coroutineB.Current) ? coroutineA.Current : coroutineB.Current;
			}
			else if (coroutineA == null && coroutineB != null)
			{
				yield return coroutineB.Current;
			}
			else if (coroutineA != null)
			{
				yield return coroutineA.Current;
			}
		}
	}

	public static IEnumerator<float> Hijack(this IEnumerator<float> coroutine, Func<float, float> newReturn)
	{
		if (newReturn != null)
		{
			while (coroutine.MoveNext())
			{
				yield return newReturn(coroutine.Current);
			}
		}
	}

	public static IEnumerator<float> RerouteExceptions(this IEnumerator<float> coroutine, Action<Exception> exceptionHandler)
	{
		while (true)
		{
			try
			{
				if (!coroutine.MoveNext())
				{
					break;
				}
			}
			catch (Exception obj)
			{
				exceptionHandler?.Invoke(obj);
				break;
			}
			yield return coroutine.Current;
		}
	}
}
namespace MEC
{
	public class Timing : MonoBehaviour
	{
		private struct ProcessIndex : IEquatable<ProcessIndex>
		{
			public Segment seg;

			public int i;

			public bool Equals(ProcessIndex other)
			{
				if (seg == other.seg)
				{
					return i == other.i;
				}
				return false;
			}

			public override bool Equals(object other)
			{
				if (other is ProcessIndex)
				{
					return Equals((ProcessIndex)other);
				}
				return false;
			}

			public static bool operator ==(ProcessIndex a, ProcessIndex b)
			{
				if (a.seg == b.seg)
				{
					return a.i == b.i;
				}
				return false;
			}

			public static bool operator !=(ProcessIndex a, ProcessIndex b)
			{
				if (a.seg == b.seg)
				{
					return a.i != b.i;
				}
				return true;
			}

			public override int GetHashCode()
			{
				return (int)(seg - 4) * 306783378 + i;
			}
		}

		[Tooltip("How quickly the SlowUpdate segment ticks.")]
		public float TimeBetweenSlowUpdateCalls = 1f / 7f;

		[Tooltip("How much data should be sent to the profiler window when it's open.")]
		public DebugInfoType ProfilerDebugAmount;

		[Tooltip("When using manual timeframe, should it run automatically after the update loop or only when TriggerManualTimframeUpdate is called.")]
		public bool AutoTriggerManualTimeframe = true;

		[Tooltip("A count of the number of Update coroutines that are currently running.")]
		[Space(12f)]
		public int UpdateCoroutines;

		[Tooltip("A count of the number of FixedUpdate coroutines that are currently running.")]
		public int FixedUpdateCoroutines;

		[Tooltip("A count of the number of LateUpdate coroutines that are currently running.")]
		public int LateUpdateCoroutines;

		[Tooltip("A count of the number of SlowUpdate coroutines that are currently running.")]
		public int SlowUpdateCoroutines;

		[Tooltip("A count of the number of RealtimeUpdate coroutines that are currently running.")]
		public int RealtimeUpdateCoroutines;

		[Tooltip("A count of the number of EditorUpdate coroutines that are currently running.")]
		public int EditorUpdateCoroutines;

		[Tooltip("A count of the number of EditorSlowUpdate coroutines that are currently running.")]
		public int EditorSlowUpdateCoroutines;

		[Tooltip("A count of the number of EndOfFrame coroutines that are currently running.")]
		public int EndOfFrameCoroutines;

		[Tooltip("A count of the number of ManualTimeframe coroutines that are currently running.")]
		public int ManualTimeframeCoroutines;

		[NonSerialized]
		public float localTime;

		[NonSerialized]
		public float deltaTime;

		public Func<float, float> SetManualTimeframeTime;

		public static Func<IEnumerator<float>, CoroutineHandle, IEnumerator<float>> ReplacementFunction;

		public const float WaitForOneFrame = float.NegativeInfinity;

		private static object _tmpRef;

		private static int _tmpInt;

		private static bool _tmpBool;

		private static Segment _tmpSegment;

		private static CoroutineHandle _tmpHandle;

		private int _currentUpdateFrame;

		private int _currentLateUpdateFrame;

		private int _currentSlowUpdateFrame;

		private int _currentRealtimeUpdateFrame;

		private int _currentEndOfFrameFrame;

		private int _nextUpdateProcessSlot;

		private int _nextLateUpdateProcessSlot;

		private int _nextFixedUpdateProcessSlot;

		private int _nextSlowUpdateProcessSlot;

		private int _nextRealtimeUpdateProcessSlot;

		private int _nextEditorUpdateProcessSlot;

		private int _nextEditorSlowUpdateProcessSlot;

		private int _nextEndOfFrameProcessSlot;

		private int _nextManualTimeframeProcessSlot;

		private int _lastUpdateProcessSlot;

		private int _lastLateUpdateProcessSlot;

		private int _lastFixedUpdateProcessSlot;

		private int _lastSlowUpdateProcessSlot;

		private int _lastRealtimeUpdateProcessSlot;

		private int _lastEndOfFrameProcessSlot;

		private int _lastManualTimeframeProcessSlot;

		private float _lastUpdateTime;

		private float _lastLateUpdateTime;

		private float _lastFixedUpdateTime;

		private float _lastSlowUpdateTime;

		private float _lastRealtimeUpdateTime;

		private float _lastEndOfFrameTime;

		private float _lastManualTimeframeTime;

		private float _lastSlowUpdateDeltaTime;

		private float _lastEditorUpdateDeltaTime;

		private float _lastEditorSlowUpdateDeltaTime;

		private float _lastManualTimeframeDeltaTime;

		private ushort _framesSinceUpdate;

		private ushort _expansions = 1;

		[SerializeField]
		[HideInInspector]
		private byte _instanceID;

		private bool _EOFPumpRan;

		private static readonly Dictionary<CoroutineHandle, HashSet<CoroutineHandle>> Links = new Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>();

		private static readonly WaitForEndOfFrame EofWaitObject = new WaitForEndOfFrame();

		private readonly Dictionary<CoroutineHandle, HashSet<CoroutineHandle>> _waitingTriggers = new Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>();

		private readonly HashSet<CoroutineHandle> _allWaiting = new HashSet<CoroutineHandle>();

		private readonly Dictionary<CoroutineHandle, ProcessIndex> _handleToIndex = new Dictionary<CoroutineHandle, ProcessIndex>();

		private readonly Dictionary<ProcessIndex, CoroutineHandle> _indexToHandle = new Dictionary<ProcessIndex, CoroutineHandle>();

		private readonly Dictionary<CoroutineHandle, string> _processTags = new Dictionary<CoroutineHandle, string>();

		private readonly Dictionary<string, HashSet<CoroutineHandle>> _taggedProcesses = new Dictionary<string, HashSet<CoroutineHandle>>();

		private readonly Dictionary<CoroutineHandle, int> _processLayers = new Dictionary<CoroutineHandle, int>();

		private readonly Dictionary<int, HashSet<CoroutineHandle>> _layeredProcesses = new Dictionary<int, HashSet<CoroutineHandle>>();

		private IEnumerator<float>[] UpdateProcesses = new IEnumerator<float>[256];

		private IEnumerator<float>[] LateUpdateProcesses = new IEnumerator<float>[8];

		private IEnumerator<float>[] FixedUpdateProcesses = new IEnumerator<float>[64];

		private IEnumerator<float>[] SlowUpdateProcesses = new IEnumerator<float>[64];

		private IEnumerator<float>[] RealtimeUpdateProcesses = new IEnumerator<float>[8];

		private IEnumerator<float>[] EditorUpdateProcesses = new IEnumerator<float>[8];

		private IEnumerator<float>[] EditorSlowUpdateProcesses = new IEnumerator<float>[8];

		private IEnumerator<float>[] EndOfFrameProcesses = new IEnumerator<float>[8];

		private IEnumerator<float>[] ManualTimeframeProcesses = new IEnumerator<float>[8];

		private bool[] UpdatePaused = new bool[256];

		private bool[] LateUpdatePaused = new bool[8];

		private bool[] FixedUpdatePaused = new bool[64];

		private bool[] SlowUpdatePaused = new bool[64];

		private bool[] RealtimeUpdatePaused = new bool[8];

		private bool[] EditorUpdatePaused = new bool[8];

		private bool[] EditorSlowUpdatePaused = new bool[8];

		private bool[] EndOfFramePaused = new bool[8];

		private bool[] ManualTimeframePaused = new bool[8];

		private bool[] UpdateHeld = new bool[256];

		private bool[] LateUpdateHeld = new bool[8];

		private bool[] FixedUpdateHeld = new bool[64];

		private bool[] SlowUpdateHeld = new bool[64];

		private bool[] RealtimeUpdateHeld = new bool[8];

		private bool[] EditorUpdateHeld = new bool[8];

		private bool[] EditorSlowUpdateHeld = new bool[8];

		private bool[] EndOfFrameHeld = new bool[8];

		private bool[] ManualTimeframeHeld = new bool[8];

		private CoroutineHandle _eofWatcherHandle;

		private const ushort FramesUntilMaintenance = 64;

		private const int ProcessArrayChunkSize = 64;

		private const int InitialBufferSizeLarge = 256;

		private const int InitialBufferSizeMedium = 64;

		private const int InitialBufferSizeSmall = 8;

		private static Timing[] ActiveInstances = new Timing[16];

		private static Timing _instance;

		public static float LocalTime => Instance.localTime;

		public static float DeltaTime => Instance.deltaTime;

		public static Thread MainThread { get; private set; }

		public static CoroutineHandle CurrentCoroutine
		{
			get
			{
				for (int i = 0; i < ActiveInstances.Length; i++)
				{
					if (ActiveInstances[i] != null && ActiveInstances[i].currentCoroutine.IsValid)
					{
						return ActiveInstances[i].currentCoroutine;
					}
				}
				return default(CoroutineHandle);
			}
		}

		public CoroutineHandle currentCoroutine { get; private set; }

		public static Timing Instance
		{
			get
			{
				if (_instance == null || !_instance.gameObject)
				{
					GameObject gameObject = GameObject.Find("Timing Controller");
					if (gameObject == null)
					{
						gameObject = new GameObject
						{
							name = "Timing Controller"
						};
						UnityEngine.Object.DontDestroyOnLoad(gameObject);
					}
					_instance = gameObject.GetComponent<Timing>() ?? gameObject.AddComponent<Timing>();
					_instance.InitializeInstanceID();
				}
				return _instance;
			}
			set
			{
				_instance = value;
			}
		}

		public static event Action OnPreExecute;

		private void OnDestroy()
		{
			if (_instance == this)
			{
				_instance = null;
			}
		}

		private void OnEnable()
		{
			if (MainThread == null)
			{
				MainThread = Thread.CurrentThread;
			}
			if (_nextEditorUpdateProcessSlot > 0 || _nextEditorSlowUpdateProcessSlot > 0)
			{
				OnEditorStart();
			}
			InitializeInstanceID();
			if (_nextEndOfFrameProcessSlot > 0)
			{
				RunCoroutineSingletonOnInstance(_EOFPumpWatcher(), "MEC_EOFPumpWatcher", SingletonBehavior.Abort);
			}
		}

		private void OnDisable()
		{
			if (_instanceID < ActiveInstances.Length)
			{
				ActiveInstances[_instanceID] = null;
			}
		}

		private void InitializeInstanceID()
		{
			if (!(ActiveInstances[_instanceID] == null))
			{
				return;
			}
			if (_instanceID == 0)
			{
				_instanceID++;
			}
			while (_instanceID <= 16)
			{
				if (_instanceID == 16)
				{
					UnityEngine.Object.Destroy(base.gameObject);
					throw new OverflowException("You are only allowed 15 different contexts for MEC to run inside at one time.");
				}
				if (ActiveInstances[_instanceID] == null)
				{
					ActiveInstances[_instanceID] = this;
					break;
				}
				_instanceID++;
			}
		}

		private void Update()
		{
			if (Timing.OnPreExecute != null)
			{
				Timing.OnPreExecute();
			}
			if (_lastSlowUpdateTime + TimeBetweenSlowUpdateCalls < Time.realtimeSinceStartup && _nextSlowUpdateProcessSlot > 0)
			{
				ProcessIndex processIndex = default(ProcessIndex);
				processIndex.seg = Segment.SlowUpdate;
				ProcessIndex key = processIndex;
				if (UpdateTimeValues(key.seg))
				{
					_lastSlowUpdateProcessSlot = _nextSlowUpdateProcessSlot;
				}
				key.i = 0;
				while (key.i < _lastSlowUpdateProcessSlot)
				{
					try
					{
						if (!SlowUpdatePaused[key.i] && !SlowUpdateHeld[key.i] && SlowUpdateProcesses[key.i] != null && !(localTime < SlowUpdateProcesses[key.i].Current))
						{
							currentCoroutine = _indexToHandle[key];
							if (ProfilerDebugAmount != 0)
							{
								_indexToHandle.ContainsKey(key);
							}
							if (!SlowUpdateProcesses[key.i].MoveNext())
							{
								if (_indexToHandle.ContainsKey(key))
								{
									KillCoroutinesOnInstance(_indexToHandle[key]);
								}
							}
							else if (SlowUpdateProcesses[key.i] != null && float.IsNaN(SlowUpdateProcesses[key.i].Current))
							{
								if (ReplacementFunction != null)
								{
									SlowUpdateProcesses[key.i] = ReplacementFunction(SlowUpdateProcesses[key.i], _indexToHandle[key]);
									ReplacementFunction = null;
								}
								key.i--;
							}
							_ = ProfilerDebugAmount;
						}
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.LogException(ex);
						if (ex is MissingReferenceException)
						{
							UnityEngine.Debug.LogError("This exception can probably be fixed by adding \"CancelWith(gameObject)\" when you run the coroutine.\nExample: Timing.RunCoroutine(_foo().CancelWith(gameObject), Segment.SlowUpdate);");
						}
					}
					key.i++;
				}
			}
			if (_nextRealtimeUpdateProcessSlot > 0)
			{
				ProcessIndex processIndex = default(ProcessIndex);
				processIndex.seg = Segment.RealtimeUpdate;
				ProcessIndex key2 = processIndex;
				if (UpdateTimeValues(key2.seg))
				{
					_lastRealtimeUpdateProcessSlot = _nextRealtimeUpdateProcessSlot;
				}
				key2.i = 0;
				while (key2.i < _lastRealtimeUpdateProcessSlot)
				{
					try
					{
						if (!RealtimeUpdatePaused[key2.i] && !RealtimeUpdateHeld[key2.i] && RealtimeUpdateProcesses[key2.i] != null && !(localTime < RealtimeUpdateProcesses[key2.i].Current))
						{
							currentCoroutine = _indexToHandle[key2];
							if (ProfilerDebugAmount != 0)
							{
								_indexToHandle.ContainsKey(key2);
							}
							if (!RealtimeUpdateProcesses[key2.i].MoveNext())
							{
								if (_indexToHandle.ContainsKey(key2))
								{
									KillCoroutinesOnInstance(_indexToHandle[key2]);
								}
							}
							else if (RealtimeUpdateProcesses[key2.i] != null && float.IsNaN(RealtimeUpdateProcesses[key2.i].Current))
							{
								if (ReplacementFunction != null)
								{
									RealtimeUpdateProcesses[key2.i] = ReplacementFunction(RealtimeUpdateProcesses[key2.i], _indexToHandle[key2]);
									ReplacementFunction = null;
								}
								key2.i--;
							}
							_ = ProfilerDebugAmount;
						}
					}
					catch (Exception ex2)
					{
						UnityEngine.Debug.LogException(ex2);
						if (ex2 is MissingReferenceException)
						{
							UnityEngine.Debug.LogError("This exception can probably be fixed by adding \"CancelWith(gameObject)\" when you run the coroutine.\nExample: Timing.RunCoroutine(_foo().CancelWith(gameObject), Segment.RealtimeUpdate);");
						}
					}
					key2.i++;
				}
			}
			if (_nextUpdateProcessSlot > 0)
			{
				ProcessIndex processIndex = default(ProcessIndex);
				processIndex.seg = Segment.Update;
				ProcessIndex key3 = processIndex;
				if (UpdateTimeValues(key3.seg))
				{
					_lastUpdateProcessSlot = _nextUpdateProcessSlot;
				}
				key3.i = 0;
				while (key3.i < _lastUpdateProcessSlot)
				{
					try
					{
						if (!UpdatePaused[key3.i] && !UpdateHeld[key3.i] && UpdateProcesses[key3.i] != null && !(localTime < UpdateProcesses[key3.i].Current))
						{
							currentCoroutine = _indexToHandle[key3];
							if (ProfilerDebugAmount != 0)
							{
								_indexToHandle.ContainsKey(key3);
							}
							if (!UpdateProcesses[key3.i].MoveNext())
							{
								if (_indexToHandle.ContainsKey(key3))
								{
									KillCoroutinesOnInstance(_indexToHandle[key3]);
								}
							}
							else if (UpdateProcesses[key3.i] != null && float.IsNaN(UpdateProcesses[key3.i].Current))
							{
								if (ReplacementFunction != null)
								{
									UpdateProcesses[key3.i] = ReplacementFunction(UpdateProcesses[key3.i], _indexToHandle[key3]);
									ReplacementFunction = null;
								}
								key3.i--;
							}
							_ = ProfilerDebugAmount;
						}
					}
					catch (Exception ex3)
					{
						UnityEngine.Debug.LogException(ex3);
						if (ex3 is MissingReferenceException)
						{
							UnityEngine.Debug.LogError("This exception can probably be fixed by adding \"CancelWith(gameObject)\" when you run the coroutine.\nExample: Timing.RunCoroutine(_foo().CancelWith(gameObject), Segment.Update);");
						}
					}
					key3.i++;
				}
			}
			if (AutoTriggerManualTimeframe)
			{
				TriggerManualTimeframeUpdate();
			}
			else if (++_framesSinceUpdate > 64)
			{
				_framesSinceUpdate = 0;
				_ = ProfilerDebugAmount;
				RemoveUnused();
				_ = ProfilerDebugAmount;
			}
			currentCoroutine = default(CoroutineHandle);
		}

		private void FixedUpdate()
		{
			if (Timing.OnPreExecute != null)
			{
				Timing.OnPreExecute();
			}
			if (_nextFixedUpdateProcessSlot <= 0)
			{
				return;
			}
			ProcessIndex processIndex = default(ProcessIndex);
			processIndex.seg = Segment.FixedUpdate;
			ProcessIndex key = processIndex;
			if (UpdateTimeValues(key.seg))
			{
				_lastFixedUpdateProcessSlot = _nextFixedUpdateProcessSlot;
			}
			key.i = 0;
			while (key.i < _lastFixedUpdateProcessSlot)
			{
				try
				{
					if (!FixedUpdatePaused[key.i] && !FixedUpdateHeld[key.i] && FixedUpdateProcesses[key.i] != null && !(localTime < FixedUpdateProcesses[key.i].Current))
					{
						currentCoroutine = _indexToHandle[key];
						if (ProfilerDebugAmount != 0)
						{
							_indexToHandle.ContainsKey(key);
						}
						if (!FixedUpdateProcesses[key.i].MoveNext())
						{
							if (_indexToHandle.ContainsKey(key))
							{
								KillCoroutinesOnInstance(_indexToHandle[key]);
							}
						}
						else if (FixedUpdateProcesses[key.i] != null && float.IsNaN(FixedUpdateProcesses[key.i].Current))
						{
							if (ReplacementFunction != null)
							{
								FixedUpdateProcesses[key.i] = ReplacementFunction(FixedUpdateProcesses[key.i], _indexToHandle[key]);
								ReplacementFunction = null;
							}
							key.i--;
						}
						_ = ProfilerDebugAmount;
					}
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogException(ex);
					if (ex is MissingReferenceException)
					{
						UnityEngine.Debug.LogError("This exception can probably be fixed by adding \"CancelWith(gameObject)\" when you run the coroutine.\nExample: Timing.RunCoroutine(_foo().CancelWith(gameObject), Segment.FixedUpdate);");
					}
				}
				key.i++;
			}
			currentCoroutine = default(CoroutineHandle);
		}

		private void LateUpdate()
		{
			if (Timing.OnPreExecute != null)
			{
				Timing.OnPreExecute();
			}
			if (_nextLateUpdateProcessSlot <= 0)
			{
				return;
			}
			ProcessIndex processIndex = default(ProcessIndex);
			processIndex.seg = Segment.LateUpdate;
			ProcessIndex key = processIndex;
			if (UpdateTimeValues(key.seg))
			{
				_lastLateUpdateProcessSlot = _nextLateUpdateProcessSlot;
			}
			key.i = 0;
			while (key.i < _lastLateUpdateProcessSlot)
			{
				try
				{
					if (!LateUpdatePaused[key.i] && !LateUpdateHeld[key.i] && LateUpdateProcesses[key.i] != null && !(localTime < LateUpdateProcesses[key.i].Current))
					{
						currentCoroutine = _indexToHandle[key];
						if (ProfilerDebugAmount != 0)
						{
							_indexToHandle.ContainsKey(key);
						}
						if (!LateUpdateProcesses[key.i].MoveNext())
						{
							if (_indexToHandle.ContainsKey(key))
							{
								KillCoroutinesOnInstance(_indexToHandle[key]);
							}
						}
						else if (LateUpdateProcesses[key.i] != null && float.IsNaN(LateUpdateProcesses[key.i].Current))
						{
							if (ReplacementFunction != null)
							{
								LateUpdateProcesses[key.i] = ReplacementFunction(LateUpdateProcesses[key.i], _indexToHandle[key]);
								ReplacementFunction = null;
							}
							key.i--;
						}
						_ = ProfilerDebugAmount;
					}
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogException(ex);
					if (ex is MissingReferenceException)
					{
						UnityEngine.Debug.LogError("This exception can probably be fixed by adding \"CancelWith(gameObject)\" when you run the coroutine.\nExample: Timing.RunCoroutine(_foo().CancelWith(gameObject), Segment.LateUpdate);");
					}
				}
				key.i++;
			}
			currentCoroutine = default(CoroutineHandle);
		}

		public void TriggerManualTimeframeUpdate()
		{
			if (Timing.OnPreExecute != null)
			{
				Timing.OnPreExecute();
			}
			if (_nextManualTimeframeProcessSlot > 0)
			{
				ProcessIndex processIndex = default(ProcessIndex);
				processIndex.seg = Segment.ManualTimeframe;
				ProcessIndex key = processIndex;
				if (UpdateTimeValues(key.seg))
				{
					_lastManualTimeframeProcessSlot = _nextManualTimeframeProcessSlot;
				}
				key.i = 0;
				while (key.i < _lastManualTimeframeProcessSlot)
				{
					try
					{
						if (!ManualTimeframePaused[key.i] && !ManualTimeframeHeld[key.i] && ManualTimeframeProcesses[key.i] != null && !(localTime < ManualTimeframeProcesses[key.i].Current))
						{
							currentCoroutine = _indexToHandle[key];
							if (ProfilerDebugAmount != 0)
							{
								_indexToHandle.ContainsKey(key);
							}
							if (!ManualTimeframeProcesses[key.i].MoveNext())
							{
								if (_indexToHandle.ContainsKey(key))
								{
									KillCoroutinesOnInstance(_indexToHandle[key]);
								}
							}
							else if (ManualTimeframeProcesses[key.i] != null && float.IsNaN(ManualTimeframeProcesses[key.i].Current))
							{
								if (ReplacementFunction != null)
								{
									ManualTimeframeProcesses[key.i] = ReplacementFunction(ManualTimeframeProcesses[key.i], _indexToHandle[key]);
									ReplacementFunction = null;
								}
								key.i--;
							}
							_ = ProfilerDebugAmount;
						}
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.LogException(ex);
						if (ex is MissingReferenceException)
						{
							UnityEngine.Debug.LogError("This exception can probably be fixed by adding \"CancelWith(gameObject)\" when you run the coroutine.\nExample: Timing.RunCoroutine(_foo().CancelWith(gameObject), Segment.ManualTimeframe);");
						}
					}
					key.i++;
				}
			}
			if (++_framesSinceUpdate > 64)
			{
				_framesSinceUpdate = 0;
				_ = ProfilerDebugAmount;
				RemoveUnused();
				_ = ProfilerDebugAmount;
			}
			currentCoroutine = default(CoroutineHandle);
		}

		private bool OnEditorStart()
		{
			return false;
		}

		private IEnumerator<float> _EOFPumpWatcher()
		{
			while (_nextEndOfFrameProcessSlot > 0)
			{
				if (!_EOFPumpRan)
				{
					base.StartCoroutine(_EOFPump());
				}
				_EOFPumpRan = false;
				yield return float.NegativeInfinity;
			}
			_EOFPumpRan = false;
		}

		private IEnumerator _EOFPump()
		{
			while (_nextEndOfFrameProcessSlot > 0)
			{
				yield return EofWaitObject;
				if (Timing.OnPreExecute != null)
				{
					Timing.OnPreExecute();
				}
				ProcessIndex processIndex = default(ProcessIndex);
				processIndex.seg = Segment.EndOfFrame;
				ProcessIndex key = processIndex;
				_EOFPumpRan = true;
				if (UpdateTimeValues(key.seg))
				{
					_lastEndOfFrameProcessSlot = _nextEndOfFrameProcessSlot;
				}
				key.i = 0;
				while (key.i < _lastEndOfFrameProcessSlot)
				{
					try
					{
						if (!EndOfFramePaused[key.i] && !EndOfFrameHeld[key.i] && EndOfFrameProcesses[key.i] != null && !(localTime < EndOfFrameProcesses[key.i].Current))
						{
							currentCoroutine = _indexToHandle[key];
							if (ProfilerDebugAmount != 0)
							{
								_indexToHandle.ContainsKey(key);
							}
							if (!EndOfFrameProcesses[key.i].MoveNext())
							{
								if (_indexToHandle.ContainsKey(key))
								{
									KillCoroutinesOnInstance(_indexToHandle[key]);
								}
							}
							else if (EndOfFrameProcesses[key.i] != null && float.IsNaN(EndOfFrameProcesses[key.i].Current))
							{
								if (ReplacementFunction != null)
								{
									EndOfFrameProcesses[key.i] = ReplacementFunction(EndOfFrameProcesses[key.i], _indexToHandle[key]);
									ReplacementFunction = null;
								}
								key.i--;
							}
							_ = ProfilerDebugAmount;
						}
					}
					catch (Exception ex)
					{
						UnityEngine.Debug.LogException(ex);
						if (ex is MissingReferenceException)
						{
							UnityEngine.Debug.LogError("This exception can probably be fixed by adding \"CancelWith(gameObject)\" when you run the coroutine.\nExample: Timing.RunCoroutine(_foo().CancelWith(gameObject), Segment.EndOfFrame);");
						}
					}
					key.i++;
				}
			}
			currentCoroutine = default(CoroutineHandle);
		}

		private void RemoveUnused()
		{
			Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>.Enumerator enumerator = _waitingTriggers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (enumerator.Current.Value.Count == 0)
				{
					_waitingTriggers.Remove(enumerator.Current.Key);
					enumerator = _waitingTriggers.GetEnumerator();
				}
				else if (_handleToIndex.ContainsKey(enumerator.Current.Key) && CoindexIsNull(_handleToIndex[enumerator.Current.Key]))
				{
					CloseWaitingProcess(enumerator.Current.Key);
					enumerator = _waitingTriggers.GetEnumerator();
				}
			}
			ProcessIndex key = default(ProcessIndex);
			ProcessIndex processIndex = default(ProcessIndex);
			key.seg = (processIndex.seg = Segment.Update);
			key.i = (processIndex.i = 0);
			while (key.i < _nextUpdateProcessSlot)
			{
				if (UpdateProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						UpdateProcesses[processIndex.i] = UpdateProcesses[key.i];
						UpdatePaused[processIndex.i] = UpdatePaused[key.i];
						UpdateHeld[processIndex.i] = UpdateHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextUpdateProcessSlot)
			{
				UpdateProcesses[key.i] = null;
				UpdatePaused[key.i] = false;
				UpdateHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			UpdateCoroutines = (_nextUpdateProcessSlot = processIndex.i);
			key.seg = (processIndex.seg = Segment.FixedUpdate);
			key.i = (processIndex.i = 0);
			while (key.i < _nextFixedUpdateProcessSlot)
			{
				if (FixedUpdateProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						FixedUpdateProcesses[processIndex.i] = FixedUpdateProcesses[key.i];
						FixedUpdatePaused[processIndex.i] = FixedUpdatePaused[key.i];
						FixedUpdateHeld[processIndex.i] = FixedUpdateHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextFixedUpdateProcessSlot)
			{
				FixedUpdateProcesses[key.i] = null;
				FixedUpdatePaused[key.i] = false;
				FixedUpdateHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			FixedUpdateCoroutines = (_nextFixedUpdateProcessSlot = processIndex.i);
			key.seg = (processIndex.seg = Segment.LateUpdate);
			key.i = (processIndex.i = 0);
			while (key.i < _nextLateUpdateProcessSlot)
			{
				if (LateUpdateProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						LateUpdateProcesses[processIndex.i] = LateUpdateProcesses[key.i];
						LateUpdatePaused[processIndex.i] = LateUpdatePaused[key.i];
						LateUpdateHeld[processIndex.i] = LateUpdateHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextLateUpdateProcessSlot)
			{
				LateUpdateProcesses[key.i] = null;
				LateUpdatePaused[key.i] = false;
				LateUpdateHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			LateUpdateCoroutines = (_nextLateUpdateProcessSlot = processIndex.i);
			key.seg = (processIndex.seg = Segment.SlowUpdate);
			key.i = (processIndex.i = 0);
			while (key.i < _nextSlowUpdateProcessSlot)
			{
				if (SlowUpdateProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						SlowUpdateProcesses[processIndex.i] = SlowUpdateProcesses[key.i];
						SlowUpdatePaused[processIndex.i] = SlowUpdatePaused[key.i];
						SlowUpdateHeld[processIndex.i] = SlowUpdateHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextSlowUpdateProcessSlot)
			{
				SlowUpdateProcesses[key.i] = null;
				SlowUpdatePaused[key.i] = false;
				SlowUpdateHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			SlowUpdateCoroutines = (_nextSlowUpdateProcessSlot = processIndex.i);
			key.seg = (processIndex.seg = Segment.RealtimeUpdate);
			key.i = (processIndex.i = 0);
			while (key.i < _nextRealtimeUpdateProcessSlot)
			{
				if (RealtimeUpdateProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						RealtimeUpdateProcesses[processIndex.i] = RealtimeUpdateProcesses[key.i];
						RealtimeUpdatePaused[processIndex.i] = RealtimeUpdatePaused[key.i];
						RealtimeUpdateHeld[processIndex.i] = RealtimeUpdateHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextRealtimeUpdateProcessSlot)
			{
				RealtimeUpdateProcesses[key.i] = null;
				RealtimeUpdatePaused[key.i] = false;
				RealtimeUpdateHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			RealtimeUpdateCoroutines = (_nextRealtimeUpdateProcessSlot = processIndex.i);
			key.seg = (processIndex.seg = Segment.EndOfFrame);
			key.i = (processIndex.i = 0);
			while (key.i < _nextEndOfFrameProcessSlot)
			{
				if (EndOfFrameProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						EndOfFrameProcesses[processIndex.i] = EndOfFrameProcesses[key.i];
						EndOfFramePaused[processIndex.i] = EndOfFramePaused[key.i];
						EndOfFrameHeld[processIndex.i] = EndOfFrameHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextEndOfFrameProcessSlot)
			{
				EndOfFrameProcesses[key.i] = null;
				EndOfFramePaused[key.i] = false;
				EndOfFrameHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			EndOfFrameCoroutines = (_nextEndOfFrameProcessSlot = processIndex.i);
			key.seg = (processIndex.seg = Segment.ManualTimeframe);
			key.i = (processIndex.i = 0);
			while (key.i < _nextManualTimeframeProcessSlot)
			{
				if (ManualTimeframeProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						ManualTimeframeProcesses[processIndex.i] = ManualTimeframeProcesses[key.i];
						ManualTimeframePaused[processIndex.i] = ManualTimeframePaused[key.i];
						ManualTimeframeHeld[processIndex.i] = ManualTimeframeHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextManualTimeframeProcessSlot)
			{
				ManualTimeframeProcesses[key.i] = null;
				ManualTimeframePaused[key.i] = false;
				ManualTimeframeHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			ManualTimeframeCoroutines = (_nextManualTimeframeProcessSlot = processIndex.i);
		}

		private void EditorRemoveUnused()
		{
			Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>.Enumerator enumerator = _waitingTriggers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (_handleToIndex.ContainsKey(enumerator.Current.Key) && CoindexIsNull(_handleToIndex[enumerator.Current.Key]))
				{
					CloseWaitingProcess(enumerator.Current.Key);
					enumerator = _waitingTriggers.GetEnumerator();
				}
			}
			ProcessIndex key = default(ProcessIndex);
			ProcessIndex processIndex = default(ProcessIndex);
			key.seg = (processIndex.seg = Segment.EditorUpdate);
			key.i = (processIndex.i = 0);
			while (key.i < _nextEditorUpdateProcessSlot)
			{
				if (EditorUpdateProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						EditorUpdateProcesses[processIndex.i] = EditorUpdateProcesses[key.i];
						EditorUpdatePaused[processIndex.i] = EditorUpdatePaused[key.i];
						EditorUpdateHeld[processIndex.i] = EditorUpdateHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextEditorUpdateProcessSlot)
			{
				EditorUpdateProcesses[key.i] = null;
				EditorUpdatePaused[key.i] = false;
				EditorUpdateHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			EditorUpdateCoroutines = (_nextEditorUpdateProcessSlot = processIndex.i);
			key.seg = (processIndex.seg = Segment.EditorSlowUpdate);
			key.i = (processIndex.i = 0);
			while (key.i < _nextEditorSlowUpdateProcessSlot)
			{
				if (EditorSlowUpdateProcesses[key.i] != null)
				{
					if (key.i != processIndex.i)
					{
						EditorSlowUpdateProcesses[processIndex.i] = EditorSlowUpdateProcesses[key.i];
						EditorUpdatePaused[processIndex.i] = EditorUpdatePaused[key.i];
						EditorUpdateHeld[processIndex.i] = EditorUpdateHeld[key.i];
						if (_indexToHandle.ContainsKey(processIndex))
						{
							RemoveGraffiti(_indexToHandle[processIndex]);
							_handleToIndex.Remove(_indexToHandle[processIndex]);
							_indexToHandle.Remove(processIndex);
						}
						_handleToIndex[_indexToHandle[key]] = processIndex;
						_indexToHandle.Add(processIndex, _indexToHandle[key]);
						_indexToHandle.Remove(key);
					}
					processIndex.i++;
				}
				key.i++;
			}
			key.i = processIndex.i;
			while (key.i < _nextEditorSlowUpdateProcessSlot)
			{
				EditorSlowUpdateProcesses[key.i] = null;
				EditorSlowUpdatePaused[key.i] = false;
				EditorSlowUpdateHeld[key.i] = false;
				if (_indexToHandle.ContainsKey(key))
				{
					RemoveGraffiti(_indexToHandle[key]);
					_handleToIndex.Remove(_indexToHandle[key]);
					_indexToHandle.Remove(key);
				}
				key.i++;
			}
			EditorSlowUpdateCoroutines = (_nextEditorSlowUpdateProcessSlot = processIndex.i);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, GameObject gameObj)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, int layer)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, string tag)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, GameObject gameObj, string tag)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, int layer, string tag)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, Segment segment)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, Segment segment, GameObject gameObj)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, segment, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, Segment segment, int layer)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, Segment segment, string tag)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, Segment segment, GameObject gameObj, string tag)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, segment, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutine(IEnumerator<float> coroutine, Segment segment, int layer, string tag)
		{
			if (coroutine != null)
			{
				return Instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, null, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, GameObject gameObj)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, Segment.Update, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, null, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, int layer)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, null, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, string tag)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, GameObject gameObj, string tag)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, Segment.Update, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, int layer, string tag)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, Segment segment)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, null, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, Segment segment, GameObject gameObj)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, segment, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, null, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, Segment segment, int layer)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, null, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, Segment segment, string tag)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, Segment segment, GameObject gameObj, string tag)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, segment, (!(gameObj == null)) ? gameObj.GetInstanceID() : 0, gameObj != null, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle RunCoroutineOnInstance(IEnumerator<float> coroutine, Segment segment, int layer, string tag)
		{
			if (coroutine != null)
			{
				return RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, CoroutineHandle handle, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(handle);
			}
			else if (IsRunning(handle))
			{
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
					return handle;
				case SingletonBehavior.AbortAndUnpause:
					ResumeCoroutines(handle);
					return handle;
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = Instance.RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, null, new CoroutineHandle(Instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, handle, warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return Instance.RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, GameObject gameObj, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingleton(coroutine, gameObj.GetInstanceID(), behaviorOnCollision);
			}
			return RunCoroutine(coroutine);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, int layer, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(layer);
			}
			else if (Instance._layeredProcesses.ContainsKey(layer))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					_instance.ResumeCoroutinesOnInstance(_instance._layeredProcesses[layer]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = Instance._layeredProcesses[layer].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = Instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, null, new CoroutineHandle(Instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _instance._layeredProcesses[layer], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return Instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(tag);
			}
			else if (Instance._taggedProcesses.ContainsKey(tag))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					_instance.ResumeCoroutinesOnInstance(_instance._taggedProcesses[tag]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = Instance._taggedProcesses[tag].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = Instance.RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, tag, new CoroutineHandle(Instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _instance._taggedProcesses[tag], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return Instance.RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, GameObject gameObj, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingleton(coroutine, gameObj.GetInstanceID(), tag, behaviorOnCollision);
			}
			return RunCoroutineSingleton(coroutine, tag, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, int layer, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(layer, tag);
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			if (!Instance._taggedProcesses.ContainsKey(tag) || !Instance._layeredProcesses.ContainsKey(layer))
			{
				return Instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
			{
				ResumeCoroutines(layer, tag);
			}
			if (behaviorOnCollision == SingletonBehavior.Abort || behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
			{
				HashSet<CoroutineHandle>.Enumerator enumerator = Instance._taggedProcesses[tag].GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (_instance._processLayers.ContainsKey(enumerator.Current) && _instance._processLayers[enumerator.Current] == layer)
					{
						return enumerator.Current;
					}
				}
			}
			if (behaviorOnCollision == SingletonBehavior.Wait)
			{
				List<CoroutineHandle> list = new List<CoroutineHandle>();
				HashSet<CoroutineHandle>.Enumerator enumerator2 = Instance._taggedProcesses[tag].GetEnumerator();
				while (enumerator2.MoveNext())
				{
					if (Instance._processLayers.ContainsKey(enumerator2.Current) && Instance._processLayers[enumerator2.Current] == layer)
					{
						list.Add(enumerator2.Current);
					}
				}
				if (list.Count > 0)
				{
					CoroutineHandle coroutineHandle = _instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(_instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, list, warnOnIssue: false);
					return coroutineHandle;
				}
			}
			return Instance.RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, CoroutineHandle handle, Segment segment, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(handle);
			}
			else if (IsRunning(handle))
			{
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
					return handle;
				case SingletonBehavior.AbortAndUnpause:
					ResumeCoroutines(handle);
					return handle;
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = Instance.RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, null, new CoroutineHandle(Instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, handle, warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return Instance.RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, Segment segment, GameObject gameObj, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingleton(coroutine, segment, gameObj.GetInstanceID(), behaviorOnCollision);
			}
			return RunCoroutine(coroutine, segment);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, Segment segment, int layer, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(layer);
			}
			else if (Instance._layeredProcesses.ContainsKey(layer))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					_instance.ResumeCoroutinesOnInstance(_instance._layeredProcesses[layer]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = Instance._layeredProcesses[layer].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = Instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, null, new CoroutineHandle(Instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _instance._layeredProcesses[layer], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return Instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, null, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, Segment segment, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(tag);
			}
			else if (Instance._taggedProcesses.ContainsKey(tag))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					_instance.ResumeCoroutinesOnInstance(_instance._taggedProcesses[tag]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = Instance._taggedProcesses[tag].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = Instance.RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, tag, new CoroutineHandle(Instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _instance._taggedProcesses[tag], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return Instance.RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, Segment segment, GameObject gameObj, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingleton(coroutine, segment, gameObj.GetInstanceID(), tag, behaviorOnCollision);
			}
			return RunCoroutineSingleton(coroutine, segment, tag, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(IEnumerator<float> coroutine, Segment segment, int layer, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutines(layer, tag);
				return Instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			if (!Instance._taggedProcesses.ContainsKey(tag) || !Instance._layeredProcesses.ContainsKey(layer))
			{
				return Instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
			}
			if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
			{
				ResumeCoroutines(layer, tag);
			}
			switch (behaviorOnCollision)
			{
			case SingletonBehavior.Abort:
			case SingletonBehavior.AbortAndUnpause:
			{
				HashSet<CoroutineHandle>.Enumerator enumerator2 = Instance._taggedProcesses[tag].GetEnumerator();
				while (enumerator2.MoveNext())
				{
					if (_instance._processLayers.ContainsKey(enumerator2.Current) && _instance._processLayers[enumerator2.Current] == layer)
					{
						return enumerator2.Current;
					}
				}
				break;
			}
			case SingletonBehavior.Wait:
			{
				List<CoroutineHandle> list = new List<CoroutineHandle>();
				HashSet<CoroutineHandle>.Enumerator enumerator = Instance._taggedProcesses[tag].GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (_instance._processLayers.ContainsKey(enumerator.Current) && _instance._processLayers[enumerator.Current] == layer)
					{
						list.Add(enumerator.Current);
					}
				}
				if (list.Count > 0)
				{
					CoroutineHandle coroutineHandle = _instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(_instance._instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, list, warnOnIssue: false);
					return coroutineHandle;
				}
				break;
			}
			}
			return Instance.RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(Instance._instanceID), prewarm: true);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, CoroutineHandle handle, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutinesOnInstance(handle);
			}
			else if (_handleToIndex.ContainsKey(handle) && !CoindexIsNull(_handleToIndex[handle]))
			{
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
					return handle;
				case SingletonBehavior.AbortAndUnpause:
					ResumeCoroutinesOnInstance(handle);
					return handle;
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, null, new CoroutineHandle(_instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, handle, warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, null, new CoroutineHandle(_instanceID), prewarm: true);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, GameObject gameObj, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingletonOnInstance(coroutine, gameObj.GetInstanceID(), behaviorOnCollision);
			}
			return RunCoroutineOnInstance(coroutine);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, int layer, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutinesOnInstance(layer);
			}
			else if (_layeredProcesses.ContainsKey(layer))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					ResumeCoroutinesOnInstance(_layeredProcesses[layer]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = _layeredProcesses[layer].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, null, new CoroutineHandle(_instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _layeredProcesses[layer], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, null, new CoroutineHandle(_instanceID), prewarm: true);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutinesOnInstance(tag);
			}
			else if (_taggedProcesses.ContainsKey(tag))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					ResumeCoroutinesOnInstance(_taggedProcesses[tag]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, tag, new CoroutineHandle(_instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _taggedProcesses[tag], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return RunCoroutineInternal(coroutine, Segment.Update, 0, layerHasValue: false, tag, new CoroutineHandle(_instanceID), prewarm: true);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, GameObject gameObj, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingletonOnInstance(coroutine, gameObj.GetInstanceID(), tag, behaviorOnCollision);
			}
			return RunCoroutineSingletonOnInstance(coroutine, tag, behaviorOnCollision);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, int layer, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutinesOnInstance(layer, tag);
				return RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			if (!_taggedProcesses.ContainsKey(tag) || !_layeredProcesses.ContainsKey(layer))
			{
				return RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
			{
				ResumeCoroutinesOnInstance(layer, tag);
			}
			if (behaviorOnCollision == SingletonBehavior.Abort || behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
			{
				HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (_processLayers.ContainsKey(enumerator.Current) && _processLayers[enumerator.Current] == layer)
					{
						return enumerator.Current;
					}
				}
			}
			if (behaviorOnCollision == SingletonBehavior.Wait)
			{
				List<CoroutineHandle> list = new List<CoroutineHandle>();
				HashSet<CoroutineHandle>.Enumerator enumerator2 = _taggedProcesses[tag].GetEnumerator();
				while (enumerator2.MoveNext())
				{
					if (_processLayers.ContainsKey(enumerator2.Current) && _processLayers[enumerator2.Current] == layer)
					{
						list.Add(enumerator2.Current);
					}
				}
				if (list.Count > 0)
				{
					CoroutineHandle coroutineHandle = RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, list, warnOnIssue: false);
					return coroutineHandle;
				}
			}
			return RunCoroutineInternal(coroutine, Segment.Update, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, Segment segment, GameObject gameObj, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingletonOnInstance(coroutine, segment, gameObj.GetInstanceID(), behaviorOnCollision);
			}
			return RunCoroutineOnInstance(coroutine, segment);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, Segment segment, int layer, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutinesOnInstance(layer);
			}
			else if (_layeredProcesses.ContainsKey(layer))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					ResumeCoroutinesOnInstance(_layeredProcesses[layer]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = _layeredProcesses[layer].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, null, new CoroutineHandle(_instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _layeredProcesses[layer], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, null, new CoroutineHandle(_instanceID), prewarm: true);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, Segment segment, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutinesOnInstance(tag);
			}
			else if (_taggedProcesses.ContainsKey(tag))
			{
				if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
				{
					ResumeCoroutinesOnInstance(_taggedProcesses[tag]);
				}
				switch (behaviorOnCollision)
				{
				case SingletonBehavior.Abort:
				case SingletonBehavior.AbortAndUnpause:
				{
					HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (IsRunning(enumerator.Current))
						{
							return enumerator.Current;
						}
					}
					break;
				}
				case SingletonBehavior.Wait:
				{
					CoroutineHandle coroutineHandle = RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, tag, new CoroutineHandle(_instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, _taggedProcesses[tag], warnOnIssue: false);
					return coroutineHandle;
				}
				}
			}
			return RunCoroutineInternal(coroutine, segment, 0, layerHasValue: false, tag, new CoroutineHandle(_instanceID), prewarm: true);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, Segment segment, GameObject gameObj, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return RunCoroutineSingletonOnInstance(coroutine, segment, gameObj.GetInstanceID(), tag, behaviorOnCollision);
			}
			return RunCoroutineSingletonOnInstance(coroutine, segment, tag, behaviorOnCollision);
		}

		public CoroutineHandle RunCoroutineSingletonOnInstance(IEnumerator<float> coroutine, Segment segment, int layer, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (coroutine == null)
			{
				return default(CoroutineHandle);
			}
			if (behaviorOnCollision == SingletonBehavior.Overwrite)
			{
				KillCoroutinesOnInstance(layer, tag);
				return RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			if (!_taggedProcesses.ContainsKey(tag) || !_layeredProcesses.ContainsKey(layer))
			{
				return RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
			}
			if (behaviorOnCollision == SingletonBehavior.AbortAndUnpause)
			{
				ResumeCoroutinesOnInstance(layer, tag);
			}
			switch (behaviorOnCollision)
			{
			case SingletonBehavior.Abort:
			case SingletonBehavior.AbortAndUnpause:
			{
				HashSet<CoroutineHandle>.Enumerator enumerator2 = _taggedProcesses[tag].GetEnumerator();
				while (enumerator2.MoveNext())
				{
					if (_processLayers.ContainsKey(enumerator2.Current) && _processLayers[enumerator2.Current] == layer)
					{
						return enumerator2.Current;
					}
				}
				break;
			}
			case SingletonBehavior.Wait:
			{
				List<CoroutineHandle> list = new List<CoroutineHandle>();
				HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
				while (enumerator.MoveNext())
				{
					if (_processLayers.ContainsKey(enumerator.Current) && _processLayers[enumerator.Current] == layer)
					{
						list.Add(enumerator.Current);
					}
				}
				if (list.Count > 0)
				{
					CoroutineHandle coroutineHandle = RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: false);
					WaitForOtherHandles(coroutineHandle, list, warnOnIssue: false);
					return coroutineHandle;
				}
				break;
			}
			}
			return RunCoroutineInternal(coroutine, segment, layer, layerHasValue: true, tag, new CoroutineHandle(_instanceID), prewarm: true);
		}

		private CoroutineHandle RunCoroutineInternal(IEnumerator<float> coroutine, Segment segment, int layer, bool layerHasValue, string tag, CoroutineHandle handle, bool prewarm)
		{
			ProcessIndex processIndex = default(ProcessIndex);
			processIndex.seg = segment;
			ProcessIndex processIndex2 = processIndex;
			if (_handleToIndex.ContainsKey(handle))
			{
				_indexToHandle.Remove(_handleToIndex[handle]);
				_handleToIndex.Remove(handle);
			}
			float num = localTime;
			float num2 = deltaTime;
			CoroutineHandle coroutineHandle = currentCoroutine;
			currentCoroutine = handle;
			try
			{
				switch (segment)
				{
				case Segment.Update:
					if (_nextUpdateProcessSlot >= UpdateProcesses.Length)
					{
						IEnumerator<float>[] updateProcesses = UpdateProcesses;
						bool[] updatePaused = UpdatePaused;
						bool[] updateHeld = UpdateHeld;
						UpdateProcesses = new IEnumerator<float>[UpdateProcesses.Length + 64 * _expansions++];
						UpdatePaused = new bool[UpdateProcesses.Length];
						UpdateHeld = new bool[UpdateProcesses.Length];
						for (int j = 0; j < updateProcesses.Length; j++)
						{
							UpdateProcesses[j] = updateProcesses[j];
							UpdatePaused[j] = updatePaused[j];
							UpdateHeld[j] = updateHeld[j];
						}
					}
					if (UpdateTimeValues(processIndex2.seg))
					{
						_lastUpdateProcessSlot = _nextUpdateProcessSlot;
					}
					processIndex2.i = _nextUpdateProcessSlot++;
					UpdateProcesses[processIndex2.i] = coroutine;
					if (tag != null)
					{
						AddTagOnInstance(tag, handle);
					}
					if (layerHasValue)
					{
						AddLayerOnInstance(layer, handle);
					}
					_indexToHandle.Add(processIndex2, handle);
					_handleToIndex.Add(handle, processIndex2);
					while (prewarm)
					{
						if (!UpdateProcesses[processIndex2.i].MoveNext())
						{
							if (_indexToHandle.ContainsKey(processIndex2))
							{
								KillCoroutinesOnInstance(_indexToHandle[processIndex2]);
							}
							prewarm = false;
						}
						else if (UpdateProcesses[processIndex2.i] != null && float.IsNaN(UpdateProcesses[processIndex2.i].Current))
						{
							if (ReplacementFunction != null)
							{
								UpdateProcesses[processIndex2.i] = ReplacementFunction(UpdateProcesses[processIndex2.i], _indexToHandle[processIndex2]);
								ReplacementFunction = null;
							}
							prewarm = !UpdatePaused[processIndex2.i] && !UpdateHeld[processIndex2.i];
						}
						else
						{
							prewarm = false;
						}
					}
					break;
				case Segment.FixedUpdate:
					if (_nextFixedUpdateProcessSlot >= FixedUpdateProcesses.Length)
					{
						IEnumerator<float>[] fixedUpdateProcesses = FixedUpdateProcesses;
						bool[] fixedUpdatePaused = FixedUpdatePaused;
						bool[] fixedUpdateHeld = FixedUpdateHeld;
						FixedUpdateProcesses = new IEnumerator<float>[FixedUpdateProcesses.Length + 64 * _expansions++];
						FixedUpdatePaused = new bool[FixedUpdateProcesses.Length];
						FixedUpdateHeld = new bool[FixedUpdateProcesses.Length];
						for (int num3 = 0; num3 < fixedUpdateProcesses.Length; num3++)
						{
							FixedUpdateProcesses[num3] = fixedUpdateProcesses[num3];
							FixedUpdatePaused[num3] = fixedUpdatePaused[num3];
							FixedUpdateHeld[num3] = fixedUpdateHeld[num3];
						}
					}
					if (UpdateTimeValues(processIndex2.seg))
					{
						_lastFixedUpdateProcessSlot = _nextFixedUpdateProcessSlot;
					}
					processIndex2.i = _nextFixedUpdateProcessSlot++;
					FixedUpdateProcesses[processIndex2.i] = coroutine;
					if (tag != null)
					{
						AddTagOnInstance(tag, handle);
					}
					if (layerHasValue)
					{
						AddLayerOnInstance(layer, handle);
					}
					_indexToHandle.Add(processIndex2, handle);
					_handleToIndex.Add(handle, processIndex2);
					while (prewarm)
					{
						if (!FixedUpdateProcesses[processIndex2.i].MoveNext())
						{
							if (_indexToHandle.ContainsKey(processIndex2))
							{
								KillCoroutinesOnInstance(_indexToHandle[processIndex2]);
							}
							prewarm = false;
						}
						else if (FixedUpdateProcesses[processIndex2.i] != null && float.IsNaN(FixedUpdateProcesses[processIndex2.i].Current))
						{
							if (ReplacementFunction != null)
							{
								FixedUpdateProcesses[processIndex2.i] = ReplacementFunction(FixedUpdateProcesses[processIndex2.i], _indexToHandle[processIndex2]);
								ReplacementFunction = null;
							}
							prewarm = !FixedUpdatePaused[processIndex2.i] && !FixedUpdateHeld[processIndex2.i];
						}
						else
						{
							prewarm = false;
						}
					}
					break;
				case Segment.LateUpdate:
					if (_nextLateUpdateProcessSlot >= LateUpdateProcesses.Length)
					{
						IEnumerator<float>[] lateUpdateProcesses = LateUpdateProcesses;
						bool[] lateUpdatePaused = LateUpdatePaused;
						bool[] lateUpdateHeld = LateUpdateHeld;
						LateUpdateProcesses = new IEnumerator<float>[LateUpdateProcesses.Length + 64 * _expansions++];
						LateUpdatePaused = new bool[LateUpdateProcesses.Length];
						LateUpdateHeld = new bool[LateUpdateProcesses.Length];
						for (int l = 0; l < lateUpdateProcesses.Length; l++)
						{
							LateUpdateProcesses[l] = lateUpdateProcesses[l];
							LateUpdatePaused[l] = lateUpdatePaused[l];
							LateUpdateHeld[l] = lateUpdateHeld[l];
						}
					}
					if (UpdateTimeValues(processIndex2.seg))
					{
						_lastLateUpdateProcessSlot = _nextLateUpdateProcessSlot;
					}
					processIndex2.i = _nextLateUpdateProcessSlot++;
					LateUpdateProcesses[processIndex2.i] = coroutine;
					if (tag != null)
					{
						AddTagOnInstance(tag, handle);
					}
					if (layerHasValue)
					{
						AddLayerOnInstance(layer, handle);
					}
					_indexToHandle.Add(processIndex2, handle);
					_handleToIndex.Add(handle, processIndex2);
					while (prewarm)
					{
						if (!LateUpdateProcesses[processIndex2.i].MoveNext())
						{
							if (_indexToHandle.ContainsKey(processIndex2))
							{
								KillCoroutinesOnInstance(_indexToHandle[processIndex2]);
							}
							prewarm = false;
						}
						else if (LateUpdateProcesses[processIndex2.i] != null && float.IsNaN(LateUpdateProcesses[processIndex2.i].Current))
						{
							if (ReplacementFunction != null)
							{
								LateUpdateProcesses[processIndex2.i] = ReplacementFunction(LateUpdateProcesses[processIndex2.i], _indexToHandle[processIndex2]);
								ReplacementFunction = null;
							}
							prewarm = !LateUpdatePaused[processIndex2.i] && !LateUpdateHeld[processIndex2.i];
						}
						else
						{
							prewarm = false;
						}
					}
					break;
				case Segment.SlowUpdate:
					if (_nextSlowUpdateProcessSlot >= SlowUpdateProcesses.Length)
					{
						IEnumerator<float>[] slowUpdateProcesses = SlowUpdateProcesses;
						bool[] slowUpdatePaused = SlowUpdatePaused;
						bool[] slowUpdateHeld = SlowUpdateHeld;
						SlowUpdateProcesses = new IEnumerator<float>[SlowUpdateProcesses.Length + 64 * _expansions++];
						SlowUpdatePaused = new bool[SlowUpdateProcesses.Length];
						SlowUpdateHeld = new bool[SlowUpdateProcesses.Length];
						for (int m = 0; m < slowUpdateProcesses.Length; m++)
						{
							SlowUpdateProcesses[m] = slowUpdateProcesses[m];
							SlowUpdatePaused[m] = slowUpdatePaused[m];
							SlowUpdateHeld[m] = slowUpdateHeld[m];
						}
					}
					if (UpdateTimeValues(processIndex2.seg))
					{
						_lastSlowUpdateProcessSlot = _nextSlowUpdateProcessSlot;
					}
					processIndex2.i = _nextSlowUpdateProcessSlot++;
					SlowUpdateProcesses[processIndex2.i] = coroutine;
					if (tag != null)
					{
						AddTagOnInstance(tag, handle);
					}
					if (layerHasValue)
					{
						AddLayerOnInstance(layer, handle);
					}
					_indexToHandle.Add(processIndex2, handle);
					_handleToIndex.Add(handle, processIndex2);
					while (prewarm)
					{
						if (!SlowUpdateProcesses[processIndex2.i].MoveNext())
						{
							if (_indexToHandle.ContainsKey(processIndex2))
							{
								KillCoroutinesOnInstance(_indexToHandle[processIndex2]);
							}
							prewarm = false;
						}
						else if (SlowUpdateProcesses[processIndex2.i] != null && float.IsNaN(SlowUpdateProcesses[processIndex2.i].Current))
						{
							if (ReplacementFunction != null)
							{
								SlowUpdateProcesses[processIndex2.i] = ReplacementFunction(SlowUpdateProcesses[processIndex2.i], _indexToHandle[processIndex2]);
								ReplacementFunction = null;
							}
							prewarm = !SlowUpdatePaused[processIndex2.i] && !SlowUpdateHeld[processIndex2.i];
						}
						else
						{
							prewarm = false;
						}
					}
					break;
				case Segment.RealtimeUpdate:
					if (_nextRealtimeUpdateProcessSlot >= RealtimeUpdateProcesses.Length)
					{
						IEnumerator<float>[] realtimeUpdateProcesses = RealtimeUpdateProcesses;
						bool[] realtimeUpdatePaused = RealtimeUpdatePaused;
						bool[] realtimeUpdateHeld = RealtimeUpdateHeld;
						RealtimeUpdateProcesses = new IEnumerator<float>[RealtimeUpdateProcesses.Length + 64 * _expansions++];
						RealtimeUpdatePaused = new bool[RealtimeUpdateProcesses.Length];
						RealtimeUpdateHeld = new bool[RealtimeUpdateProcesses.Length];
						for (int k = 0; k < realtimeUpdateProcesses.Length; k++)
						{
							RealtimeUpdateProcesses[k] = realtimeUpdateProcesses[k];
							RealtimeUpdatePaused[k] = realtimeUpdatePaused[k];
							RealtimeUpdateHeld[k] = realtimeUpdateHeld[k];
						}
					}
					if (UpdateTimeValues(processIndex2.seg))
					{
						_lastRealtimeUpdateProcessSlot = _nextRealtimeUpdateProcessSlot;
					}
					processIndex2.i = _nextRealtimeUpdateProcessSlot++;
					RealtimeUpdateProcesses[processIndex2.i] = coroutine;
					if (tag != null)
					{
						AddTagOnInstance(tag, handle);
					}
					if (layerHasValue)
					{
						AddLayerOnInstance(layer, handle);
					}
					_indexToHandle.Add(processIndex2, handle);
					_handleToIndex.Add(handle, processIndex2);
					while (prewarm)
					{
						if (!RealtimeUpdateProcesses[processIndex2.i].MoveNext())
						{
							if (_indexToHandle.ContainsKey(processIndex2))
							{
								KillCoroutinesOnInstance(_indexToHandle[processIndex2]);
							}
							prewarm = false;
						}
						else if (RealtimeUpdateProcesses[processIndex2.i] != null && float.IsNaN(RealtimeUpdateProcesses[processIndex2.i].Current))
						{
							if (ReplacementFunction != null)
							{
								RealtimeUpdateProcesses[processIndex2.i] = ReplacementFunction(RealtimeUpdateProcesses[processIndex2.i], _indexToHandle[processIndex2]);
								ReplacementFunction = null;
							}
							prewarm = !RealtimeUpdatePaused[processIndex2.i] && !RealtimeUpdateHeld[processIndex2.i];
						}
						else
						{
							prewarm = false;
						}
					}
					break;
				case Segment.EndOfFrame:
					if (_nextEndOfFrameProcessSlot >= EndOfFrameProcesses.Length)
					{
						IEnumerator<float>[] endOfFrameProcesses = EndOfFrameProcesses;
						bool[] endOfFramePaused = EndOfFramePaused;
						bool[] endOfFrameHeld = EndOfFrameHeld;
						EndOfFrameProcesses = new IEnumerator<float>[EndOfFrameProcesses.Length + 64 * _expansions++];
						EndOfFramePaused = new bool[EndOfFrameProcesses.Length];
						EndOfFrameHeld = new bool[EndOfFrameProcesses.Length];
						for (int n = 0; n < endOfFrameProcesses.Length; n++)
						{
							EndOfFrameProcesses[n] = endOfFrameProcesses[n];
							EndOfFramePaused[n] = endOfFramePaused[n];
							EndOfFrameHeld[n] = endOfFrameHeld[n];
						}
					}
					if (UpdateTimeValues(processIndex2.seg))
					{
						_lastEndOfFrameProcessSlot = _nextEndOfFrameProcessSlot;
					}
					processIndex2.i = _nextEndOfFrameProcessSlot++;
					EndOfFrameProcesses[processIndex2.i] = coroutine;
					if (tag != null)
					{
						AddTagOnInstance(tag, handle);
					}
					if (layerHasValue)
					{
						AddLayerOnInstance(layer, handle);
					}
					_indexToHandle.Add(processIndex2, handle);
					_handleToIndex.Add(handle, processIndex2);
					_eofWatcherHandle = RunCoroutineSingletonOnInstance(_EOFPumpWatcher(), _eofWatcherHandle, SingletonBehavior.Abort);
					break;
				case Segment.ManualTimeframe:
					if (_nextManualTimeframeProcessSlot >= ManualTimeframeProcesses.Length)
					{
						IEnumerator<float>[] manualTimeframeProcesses = ManualTimeframeProcesses;
						bool[] manualTimeframePaused = ManualTimeframePaused;
						bool[] manualTimeframeHeld = ManualTimeframeHeld;
						ManualTimeframeProcesses = new IEnumerator<float>[ManualTimeframeProcesses.Length + 64 * _expansions++];
						ManualTimeframePaused = new bool[ManualTimeframeProcesses.Length];
						ManualTimeframeHeld = new bool[ManualTimeframeProcesses.Length];
						for (int i = 0; i < manualTimeframeProcesses.Length; i++)
						{
							ManualTimeframeProcesses[i] = manualTimeframeProcesses[i];
							ManualTimeframePaused[i] = manualTimeframePaused[i];
							ManualTimeframeHeld[i] = manualTimeframeHeld[i];
						}
					}
					if (UpdateTimeValues(processIndex2.seg))
					{
						_lastManualTimeframeProcessSlot = _nextManualTimeframeProcessSlot;
					}
					processIndex2.i = _nextManualTimeframeProcessSlot++;
					ManualTimeframeProcesses[processIndex2.i] = coroutine;
					if (tag != null)
					{
						AddTagOnInstance(tag, handle);
					}
					if (layerHasValue)
					{
						AddLayerOnInstance(layer, handle);
					}
					_indexToHandle.Add(processIndex2, handle);
					_handleToIndex.Add(handle, processIndex2);
					break;
				default:
					handle = default(CoroutineHandle);
					break;
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			localTime = num;
			deltaTime = num2;
			currentCoroutine = coroutineHandle;
			return handle;
		}

		public static int KillCoroutines()
		{
			if (!(_instance == null))
			{
				return _instance.KillCoroutinesOnInstance();
			}
			return 0;
		}

		public int KillCoroutinesOnInstance()
		{
			int result = _nextUpdateProcessSlot + _nextLateUpdateProcessSlot + _nextFixedUpdateProcessSlot + _nextSlowUpdateProcessSlot + _nextRealtimeUpdateProcessSlot + _nextEditorUpdateProcessSlot + _nextEditorSlowUpdateProcessSlot + _nextEndOfFrameProcessSlot + _nextManualTimeframeProcessSlot;
			UpdateProcesses = new IEnumerator<float>[256];
			UpdatePaused = new bool[256];
			UpdateHeld = new bool[256];
			UpdateCoroutines = 0;
			_nextUpdateProcessSlot = 0;
			LateUpdateProcesses = new IEnumerator<float>[8];
			LateUpdatePaused = new bool[8];
			LateUpdateHeld = new bool[8];
			LateUpdateCoroutines = 0;
			_nextLateUpdateProcessSlot = 0;
			FixedUpdateProcesses = new IEnumerator<float>[64];
			FixedUpdatePaused = new bool[64];
			FixedUpdateHeld = new bool[64];
			FixedUpdateCoroutines = 0;
			_nextFixedUpdateProcessSlot = 0;
			SlowUpdateProcesses = new IEnumerator<float>[64];
			SlowUpdatePaused = new bool[64];
			SlowUpdateHeld = new bool[64];
			SlowUpdateCoroutines = 0;
			_nextSlowUpdateProcessSlot = 0;
			RealtimeUpdateProcesses = new IEnumerator<float>[8];
			RealtimeUpdatePaused = new bool[8];
			RealtimeUpdateHeld = new bool[8];
			RealtimeUpdateCoroutines = 0;
			_nextRealtimeUpdateProcessSlot = 0;
			EditorUpdateProcesses = new IEnumerator<float>[8];
			EditorUpdatePaused = new bool[8];
			EditorUpdateHeld = new bool[8];
			EditorUpdateCoroutines = 0;
			_nextEditorUpdateProcessSlot = 0;
			EditorSlowUpdateProcesses = new IEnumerator<float>[8];
			EditorSlowUpdatePaused = new bool[8];
			EditorSlowUpdateHeld = new bool[8];
			EditorSlowUpdateCoroutines = 0;
			_nextEditorSlowUpdateProcessSlot = 0;
			EndOfFrameProcesses = new IEnumerator<float>[8];
			EndOfFramePaused = new bool[8];
			EndOfFrameHeld = new bool[8];
			EndOfFrameCoroutines = 0;
			_nextEndOfFrameProcessSlot = 0;
			ManualTimeframeProcesses = new IEnumerator<float>[8];
			ManualTimeframePaused = new bool[8];
			ManualTimeframeHeld = new bool[8];
			ManualTimeframeCoroutines = 0;
			_nextManualTimeframeProcessSlot = 0;
			_processTags.Clear();
			_taggedProcesses.Clear();
			_processLayers.Clear();
			_layeredProcesses.Clear();
			_handleToIndex.Clear();
			_indexToHandle.Clear();
			_waitingTriggers.Clear();
			_expansions = (ushort)(_expansions / 2 + 1);
			Links.Clear();
			return result;
		}

		public static int KillCoroutines(CoroutineHandle handle)
		{
			if (!(ActiveInstances[handle.Key] != null))
			{
				return 0;
			}
			return GetInstance(handle.Key).KillCoroutinesOnInstance(handle);
		}

		public static int KillCoroutines(params CoroutineHandle[] handles)
		{
			int num = 0;
			for (int i = 0; i < handles.Length; i++)
			{
				num += ((ActiveInstances[handles[i].Key] != null) ? GetInstance(handles[i].Key).KillCoroutinesOnInstance(handles[i]) : 0);
			}
			return num;
		}

		public int KillCoroutinesOnInstance(CoroutineHandle handle)
		{
			int num = 0;
			if (_handleToIndex.ContainsKey(handle))
			{
				if (_waitingTriggers.ContainsKey(handle))
				{
					CloseWaitingProcess(handle);
				}
				if (Nullify(handle))
				{
					num++;
				}
				RemoveGraffiti(handle);
			}
			if (Links.ContainsKey(handle))
			{
				HashSet<CoroutineHandle>.Enumerator enumerator = Links[handle].GetEnumerator();
				Links.Remove(handle);
				while (enumerator.MoveNext())
				{
					num += KillCoroutines(enumerator.Current);
				}
			}
			return num;
		}

		public static int KillCoroutines(GameObject gameObj)
		{
			if (!(_instance == null))
			{
				return _instance.KillCoroutinesOnInstance(gameObj.GetInstanceID());
			}
			return 0;
		}

		public int KillCoroutinesOnInstance(GameObject gameObj)
		{
			return KillCoroutinesOnInstance(gameObj.GetInstanceID());
		}

		public static int KillCoroutines(int layer)
		{
			if (!(_instance == null))
			{
				return _instance.KillCoroutinesOnInstance(layer);
			}
			return 0;
		}

		public int KillCoroutinesOnInstance(int layer)
		{
			int num = 0;
			while (_layeredProcesses.ContainsKey(layer))
			{
				HashSet<CoroutineHandle>.Enumerator enumerator = _layeredProcesses[layer].GetEnumerator();
				enumerator.MoveNext();
				if (Nullify(enumerator.Current))
				{
					if (_waitingTriggers.ContainsKey(enumerator.Current))
					{
						CloseWaitingProcess(enumerator.Current);
					}
					num++;
				}
				RemoveGraffiti(enumerator.Current);
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle>.Enumerator enumerator2 = Links[enumerator.Current].GetEnumerator();
					Links.Remove(enumerator.Current);
					while (enumerator2.MoveNext())
					{
						num += KillCoroutines(enumerator2.Current);
					}
				}
			}
			return num;
		}

		public static int KillCoroutines(string tag)
		{
			if (!(_instance == null))
			{
				return _instance.KillCoroutinesOnInstance(tag);
			}
			return 0;
		}

		public int KillCoroutinesOnInstance(string tag)
		{
			if (tag == null)
			{
				return 0;
			}
			int num = 0;
			while (_taggedProcesses.ContainsKey(tag))
			{
				HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
				enumerator.MoveNext();
				if (Nullify(_handleToIndex[enumerator.Current]))
				{
					if (_waitingTriggers.ContainsKey(enumerator.Current))
					{
						CloseWaitingProcess(enumerator.Current);
					}
					num++;
				}
				RemoveGraffiti(enumerator.Current);
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle>.Enumerator enumerator2 = Links[enumerator.Current].GetEnumerator();
					Links.Remove(enumerator.Current);
					while (enumerator2.MoveNext())
					{
						num += KillCoroutines(enumerator2.Current);
					}
				}
			}
			return num;
		}

		public static int KillCoroutines(GameObject gameObj, string tag)
		{
			if (!(_instance == null))
			{
				return _instance.KillCoroutinesOnInstance(gameObj.GetInstanceID(), tag);
			}
			return 0;
		}

		public int KillCoroutinesOnInstance(GameObject gameObj, string tag)
		{
			return KillCoroutinesOnInstance(gameObj.GetInstanceID(), tag);
		}

		public static int KillCoroutines(int layer, string tag)
		{
			if (!(_instance == null))
			{
				return _instance.KillCoroutinesOnInstance(layer, tag);
			}
			return 0;
		}

		public int KillCoroutinesOnInstance(int layer, string tag)
		{
			if (tag == null)
			{
				return KillCoroutinesOnInstance(layer);
			}
			if (!_layeredProcesses.ContainsKey(layer) || !_taggedProcesses.ContainsKey(tag))
			{
				return 0;
			}
			int num = 0;
			HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (CoindexIsNull(_handleToIndex[enumerator.Current]) || !_layeredProcesses[layer].Contains(enumerator.Current) || !Nullify(enumerator.Current))
				{
					continue;
				}
				if (_waitingTriggers.ContainsKey(enumerator.Current))
				{
					CloseWaitingProcess(enumerator.Current);
				}
				num++;
				RemoveGraffiti(enumerator.Current);
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle>.Enumerator enumerator2 = Links[enumerator.Current].GetEnumerator();
					Links.Remove(enumerator.Current);
					while (enumerator2.MoveNext())
					{
						KillCoroutines(enumerator2.Current);
					}
				}
				if (!_taggedProcesses.ContainsKey(tag) || !_layeredProcesses.ContainsKey(layer))
				{
					break;
				}
				enumerator = _taggedProcesses[tag].GetEnumerator();
			}
			return num;
		}

		public static Timing GetInstance(byte ID)
		{
			if (ID >= 16)
			{
				return null;
			}
			return ActiveInstances[ID];
		}

		public static float WaitForSeconds(float waitTime)
		{
			if (float.IsNaN(waitTime))
			{
				waitTime = 0f;
			}
			return LocalTime + waitTime;
		}

		public float WaitForSecondsOnInstance(float waitTime)
		{
			if (float.IsNaN(waitTime))
			{
				waitTime = 0f;
			}
			return localTime + waitTime;
		}

		private bool UpdateTimeValues(Segment segment)
		{
			switch (segment)
			{
			case Segment.Update:
				if (_currentUpdateFrame != Time.frameCount)
				{
					deltaTime = Time.deltaTime;
					_lastUpdateTime += deltaTime;
					localTime = _lastUpdateTime;
					_currentUpdateFrame = Time.frameCount;
					return true;
				}
				deltaTime = Time.deltaTime;
				localTime = _lastUpdateTime;
				return false;
			case Segment.LateUpdate:
				if (_currentLateUpdateFrame != Time.frameCount)
				{
					deltaTime = Time.deltaTime;
					_lastLateUpdateTime += deltaTime;
					localTime = _lastLateUpdateTime;
					_currentLateUpdateFrame = Time.frameCount;
					return true;
				}
				deltaTime = Time.deltaTime;
				localTime = _lastLateUpdateTime;
				return false;
			case Segment.FixedUpdate:
				deltaTime = Time.fixedDeltaTime;
				localTime = Time.fixedTime;
				if (_lastFixedUpdateTime + 0.0001f < Time.fixedTime)
				{
					_lastFixedUpdateTime = Time.fixedTime;
					return true;
				}
				return false;
			case Segment.SlowUpdate:
				if (_currentSlowUpdateFrame != Time.frameCount)
				{
					deltaTime = (_lastSlowUpdateDeltaTime = Time.realtimeSinceStartup - _lastSlowUpdateTime);
					localTime = (_lastSlowUpdateTime = Time.realtimeSinceStartup);
					_currentSlowUpdateFrame = Time.frameCount;
					return true;
				}
				localTime = _lastSlowUpdateTime;
				deltaTime = _lastSlowUpdateDeltaTime;
				return false;
			case Segment.RealtimeUpdate:
				if (_currentRealtimeUpdateFrame != Time.frameCount)
				{
					deltaTime = Time.unscaledDeltaTime;
					_lastRealtimeUpdateTime += deltaTime;
					localTime = _lastRealtimeUpdateTime;
					_currentRealtimeUpdateFrame = Time.frameCount;
					return true;
				}
				deltaTime = Time.unscaledDeltaTime;
				localTime = _lastRealtimeUpdateTime;
				return false;
			case Segment.EndOfFrame:
				if (_currentEndOfFrameFrame != Time.frameCount)
				{
					deltaTime = Time.deltaTime;
					_lastEndOfFrameTime += deltaTime;
					localTime = _lastEndOfFrameTime;
					_currentEndOfFrameFrame = Time.frameCount;
					return true;
				}
				deltaTime = Time.deltaTime;
				localTime = _lastEndOfFrameTime;
				return false;
			case Segment.ManualTimeframe:
			{
				float num = ((SetManualTimeframeTime == null) ? Time.time : SetManualTimeframeTime(_lastManualTimeframeTime));
				if ((double)_lastManualTimeframeTime + 0.0001 < (double)num && (double)_lastManualTimeframeTime - 0.0001 > (double)num)
				{
					localTime = num;
					deltaTime = localTime - _lastManualTimeframeTime;
					if (deltaTime > Time.maximumDeltaTime)
					{
						deltaTime = Time.maximumDeltaTime;
					}
					_lastManualTimeframeDeltaTime = deltaTime;
					_lastManualTimeframeTime = num;
					return true;
				}
				deltaTime = _lastManualTimeframeDeltaTime;
				localTime = _lastManualTimeframeTime;
				return false;
			}
			default:
				return true;
			}
		}

		private float GetSegmentTime(Segment segment)
		{
			switch (segment)
			{
			case Segment.Update:
				if (_currentUpdateFrame == Time.frameCount)
				{
					return _lastUpdateTime;
				}
				return _lastUpdateTime + Time.deltaTime;
			case Segment.LateUpdate:
				if (_currentUpdateFrame == Time.frameCount)
				{
					return _lastLateUpdateTime;
				}
				return _lastLateUpdateTime + Time.deltaTime;
			case Segment.FixedUpdate:
				return Time.fixedTime;
			case Segment.SlowUpdate:
				return Time.realtimeSinceStartup;
			case Segment.RealtimeUpdate:
				if (_currentRealtimeUpdateFrame == Time.frameCount)
				{
					return _lastRealtimeUpdateTime;
				}
				return _lastRealtimeUpdateTime + Time.unscaledDeltaTime;
			case Segment.EndOfFrame:
				if (_currentUpdateFrame == Time.frameCount)
				{
					return _lastEndOfFrameTime;
				}
				return _lastEndOfFrameTime + Time.deltaTime;
			case Segment.ManualTimeframe:
				return _lastManualTimeframeTime;
			default:
				return 0f;
			}
		}

		public static int PauseCoroutines()
		{
			if (!(_instance == null))
			{
				return _instance.PauseCoroutinesOnInstance();
			}
			return 0;
		}

		public int PauseCoroutinesOnInstance()
		{
			int num = 0;
			for (int i = 0; i < _nextUpdateProcessSlot; i++)
			{
				if (!UpdatePaused[i] && UpdateProcesses[i] != null)
				{
					num++;
					UpdatePaused[i] = true;
					if (UpdateProcesses[i].Current > GetSegmentTime(Segment.Update))
					{
						UpdateProcesses[i] = _InjectDelay(UpdateProcesses[i], UpdateProcesses[i].Current - GetSegmentTime(Segment.Update));
					}
				}
			}
			for (int i = 0; i < _nextLateUpdateProcessSlot; i++)
			{
				if (!LateUpdatePaused[i] && LateUpdateProcesses[i] != null)
				{
					num++;
					LateUpdatePaused[i] = true;
					if (LateUpdateProcesses[i].Current > GetSegmentTime(Segment.LateUpdate))
					{
						LateUpdateProcesses[i] = _InjectDelay(LateUpdateProcesses[i], LateUpdateProcesses[i].Current - GetSegmentTime(Segment.LateUpdate));
					}
				}
			}
			for (int i = 0; i < _nextFixedUpdateProcessSlot; i++)
			{
				if (!FixedUpdatePaused[i] && FixedUpdateProcesses[i] != null)
				{
					num++;
					FixedUpdatePaused[i] = true;
					if (FixedUpdateProcesses[i].Current > GetSegmentTime(Segment.FixedUpdate))
					{
						FixedUpdateProcesses[i] = _InjectDelay(FixedUpdateProcesses[i], FixedUpdateProcesses[i].Current - GetSegmentTime(Segment.FixedUpdate));
					}
				}
			}
			for (int i = 0; i < _nextSlowUpdateProcessSlot; i++)
			{
				if (!SlowUpdatePaused[i] && SlowUpdateProcesses[i] != null)
				{
					num++;
					SlowUpdatePaused[i] = true;
					if (SlowUpdateProcesses[i].Current > GetSegmentTime(Segment.SlowUpdate))
					{
						SlowUpdateProcesses[i] = _InjectDelay(SlowUpdateProcesses[i], SlowUpdateProcesses[i].Current - GetSegmentTime(Segment.SlowUpdate));
					}
				}
			}
			for (int i = 0; i < _nextRealtimeUpdateProcessSlot; i++)
			{
				if (!RealtimeUpdatePaused[i] && RealtimeUpdateProcesses[i] != null)
				{
					num++;
					RealtimeUpdatePaused[i] = true;
					if (RealtimeUpdateProcesses[i].Current > GetSegmentTime(Segment.RealtimeUpdate))
					{
						RealtimeUpdateProcesses[i] = _InjectDelay(RealtimeUpdateProcesses[i], RealtimeUpdateProcesses[i].Current - GetSegmentTime(Segment.RealtimeUpdate));
					}
				}
			}
			for (int i = 0; i < _nextEditorUpdateProcessSlot; i++)
			{
				if (!EditorUpdatePaused[i] && EditorUpdateProcesses[i] != null)
				{
					num++;
					EditorUpdatePaused[i] = true;
					if (EditorUpdateProcesses[i].Current > GetSegmentTime(Segment.EditorUpdate))
					{
						EditorUpdateProcesses[i] = _InjectDelay(EditorUpdateProcesses[i], EditorUpdateProcesses[i].Current - GetSegmentTime(Segment.EditorUpdate));
					}
				}
			}
			for (int i = 0; i < _nextEditorSlowUpdateProcessSlot; i++)
			{
				if (!EditorSlowUpdatePaused[i] && EditorSlowUpdateProcesses[i] != null)
				{
					num++;
					EditorSlowUpdatePaused[i] = true;
					if (EditorSlowUpdateProcesses[i].Current > GetSegmentTime(Segment.EditorSlowUpdate))
					{
						EditorSlowUpdateProcesses[i] = _InjectDelay(EditorSlowUpdateProcesses[i], EditorSlowUpdateProcesses[i].Current - GetSegmentTime(Segment.EditorSlowUpdate));
					}
				}
			}
			for (int i = 0; i < _nextEndOfFrameProcessSlot; i++)
			{
				if (!EndOfFramePaused[i] && EndOfFrameProcesses[i] != null)
				{
					num++;
					EndOfFramePaused[i] = true;
					if (EndOfFrameProcesses[i].Current > GetSegmentTime(Segment.EndOfFrame))
					{
						EndOfFrameProcesses[i] = _InjectDelay(EndOfFrameProcesses[i], EndOfFrameProcesses[i].Current - GetSegmentTime(Segment.EndOfFrame));
					}
				}
			}
			for (int i = 0; i < _nextManualTimeframeProcessSlot; i++)
			{
				if (!ManualTimeframePaused[i] && ManualTimeframeProcesses[i] != null)
				{
					num++;
					ManualTimeframePaused[i] = true;
					if (ManualTimeframeProcesses[i].Current > GetSegmentTime(Segment.ManualTimeframe))
					{
						ManualTimeframeProcesses[i] = _InjectDelay(ManualTimeframeProcesses[i], ManualTimeframeProcesses[i].Current - GetSegmentTime(Segment.ManualTimeframe));
					}
				}
			}
			Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>.Enumerator enumerator = Links.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (_handleToIndex.ContainsKey(enumerator.Current.Key))
				{
					HashSet<CoroutineHandle>.Enumerator enumerator2 = enumerator.Current.Value.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += PauseCoroutines(enumerator2.Current);
					}
				}
			}
			return num;
		}

		public int PauseCoroutinesOnInstance(CoroutineHandle handle)
		{
			int num = 0;
			if (_handleToIndex.ContainsKey(handle) && !CoindexIsNull(_handleToIndex[handle]) && !SetPause(_handleToIndex[handle], newPausedState: true))
			{
				num++;
			}
			if (Links.ContainsKey(handle))
			{
				HashSet<CoroutineHandle> hashSet = Links[handle];
				Links.Remove(handle);
				HashSet<CoroutineHandle>.Enumerator enumerator = hashSet.GetEnumerator();
				while (enumerator.MoveNext())
				{
					num += PauseCoroutines(enumerator.Current);
				}
				Links.Add(handle, hashSet);
			}
			return num;
		}

		public static int PauseCoroutines(CoroutineHandle handle)
		{
			if (!(_instance == null))
			{
				return _instance.PauseCoroutinesOnInstance(handle);
			}
			return 0;
		}

		public static int PauseCoroutines(params CoroutineHandle[] handles)
		{
			int num = 0;
			for (int i = 0; i < handles.Length; i++)
			{
				num += ((ActiveInstances[handles[i].Key] != null) ? GetInstance(handles[i].Key).PauseCoroutinesOnInstance(handles[i]) : 0);
			}
			return num;
		}

		public static int PauseCoroutines(GameObject gameObj)
		{
			if (!(_instance == null))
			{
				return _instance.PauseCoroutinesOnInstance(gameObj);
			}
			return 0;
		}

		public int PauseCoroutinesOnInstance(GameObject gameObj)
		{
			if (!(gameObj == null))
			{
				return PauseCoroutinesOnInstance(gameObj.GetInstanceID());
			}
			return 0;
		}

		public static int PauseCoroutines(int layer)
		{
			if (!(_instance == null))
			{
				return _instance.PauseCoroutinesOnInstance(layer);
			}
			return 0;
		}

		public int PauseCoroutinesOnInstance(int layer)
		{
			if (!_layeredProcesses.ContainsKey(layer))
			{
				return 0;
			}
			int num = 0;
			HashSet<CoroutineHandle>.Enumerator enumerator = _layeredProcesses[layer].GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (!CoindexIsNull(_handleToIndex[enumerator.Current]) && !SetPause(_handleToIndex[enumerator.Current], newPausedState: true))
				{
					num++;
				}
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle> hashSet = Links[enumerator.Current];
					Links.Remove(enumerator.Current);
					HashSet<CoroutineHandle>.Enumerator enumerator2 = hashSet.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += PauseCoroutines(enumerator2.Current);
					}
					Links.Add(enumerator.Current, hashSet);
				}
			}
			return num;
		}

		public static int PauseCoroutines(string tag)
		{
			if (!(_instance == null))
			{
				return _instance.PauseCoroutinesOnInstance(tag);
			}
			return 0;
		}

		public int PauseCoroutinesOnInstance(string tag)
		{
			if (tag == null || !_taggedProcesses.ContainsKey(tag))
			{
				return 0;
			}
			int num = 0;
			HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (!CoindexIsNull(_handleToIndex[enumerator.Current]) && !SetPause(_handleToIndex[enumerator.Current], newPausedState: true))
				{
					num++;
				}
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle> hashSet = Links[enumerator.Current];
					Links.Remove(enumerator.Current);
					HashSet<CoroutineHandle>.Enumerator enumerator2 = hashSet.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += PauseCoroutines(enumerator2.Current);
					}
					Links.Add(enumerator.Current, hashSet);
				}
			}
			return num;
		}

		public static int PauseCoroutines(GameObject gameObj, string tag)
		{
			if (!(_instance == null))
			{
				return _instance.PauseCoroutinesOnInstance(gameObj.GetInstanceID(), tag);
			}
			return 0;
		}

		public int PauseCoroutinesOnInstance(GameObject gameObj, string tag)
		{
			if (!(gameObj == null))
			{
				return PauseCoroutinesOnInstance(gameObj.GetInstanceID(), tag);
			}
			return 0;
		}

		public static int PauseCoroutines(int layer, string tag)
		{
			if (!(_instance == null))
			{
				return _instance.PauseCoroutinesOnInstance(layer, tag);
			}
			return 0;
		}

		public int PauseCoroutinesOnInstance(int layer, string tag)
		{
			if (tag == null)
			{
				return PauseCoroutinesOnInstance(layer);
			}
			if (!_taggedProcesses.ContainsKey(tag) || !_layeredProcesses.ContainsKey(layer))
			{
				return 0;
			}
			int num = 0;
			HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (!_processLayers.ContainsKey(enumerator.Current) || _processLayers[enumerator.Current] != layer || CoindexIsNull(_handleToIndex[enumerator.Current]))
				{
					continue;
				}
				if (!SetPause(_handleToIndex[enumerator.Current], newPausedState: true))
				{
					num++;
				}
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle> hashSet = Links[enumerator.Current];
					Links.Remove(enumerator.Current);
					HashSet<CoroutineHandle>.Enumerator enumerator2 = hashSet.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += PauseCoroutines(enumerator2.Current);
					}
					Links.Add(enumerator.Current, hashSet);
				}
			}
			return num;
		}

		public static int ResumeCoroutines()
		{
			if (!(_instance == null))
			{
				return _instance.ResumeCoroutinesOnInstance();
			}
			return 0;
		}

		public int ResumeCoroutinesOnInstance()
		{
			int num = 0;
			ProcessIndex processIndex = default(ProcessIndex);
			processIndex.i = 0;
			processIndex.seg = Segment.Update;
			while (processIndex.i < _nextUpdateProcessSlot)
			{
				if (UpdatePaused[processIndex.i] && UpdateProcesses[processIndex.i] != null)
				{
					UpdatePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.LateUpdate;
			while (processIndex.i < _nextLateUpdateProcessSlot)
			{
				if (LateUpdatePaused[processIndex.i] && LateUpdateProcesses[processIndex.i] != null)
				{
					LateUpdatePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.FixedUpdate;
			while (processIndex.i < _nextFixedUpdateProcessSlot)
			{
				if (FixedUpdatePaused[processIndex.i] && FixedUpdateProcesses[processIndex.i] != null)
				{
					FixedUpdatePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.SlowUpdate;
			while (processIndex.i < _nextSlowUpdateProcessSlot)
			{
				if (SlowUpdatePaused[processIndex.i] && SlowUpdateProcesses[processIndex.i] != null)
				{
					SlowUpdatePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.RealtimeUpdate;
			while (processIndex.i < _nextRealtimeUpdateProcessSlot)
			{
				if (RealtimeUpdatePaused[processIndex.i] && RealtimeUpdateProcesses[processIndex.i] != null)
				{
					RealtimeUpdatePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.EditorUpdate;
			while (processIndex.i < _nextEditorUpdateProcessSlot)
			{
				if (EditorUpdatePaused[processIndex.i] && EditorUpdateProcesses[processIndex.i] != null)
				{
					EditorUpdatePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.EditorSlowUpdate;
			while (processIndex.i < _nextEditorSlowUpdateProcessSlot)
			{
				if (EditorSlowUpdatePaused[processIndex.i] && EditorSlowUpdateProcesses[processIndex.i] != null)
				{
					EditorSlowUpdatePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.EndOfFrame;
			while (processIndex.i < _nextEndOfFrameProcessSlot)
			{
				if (EndOfFramePaused[processIndex.i] && EndOfFrameProcesses[processIndex.i] != null)
				{
					EndOfFramePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			processIndex.i = 0;
			processIndex.seg = Segment.ManualTimeframe;
			while (processIndex.i < _nextManualTimeframeProcessSlot)
			{
				if (ManualTimeframePaused[processIndex.i] && ManualTimeframeProcesses[processIndex.i] != null)
				{
					ManualTimeframePaused[processIndex.i] = false;
					num++;
				}
				processIndex.i++;
			}
			Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>.Enumerator enumerator = Links.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (_handleToIndex.ContainsKey(enumerator.Current.Key))
				{
					HashSet<CoroutineHandle>.Enumerator enumerator2 = enumerator.Current.Value.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += ResumeCoroutines(enumerator2.Current);
					}
				}
			}
			return num;
		}

		public static int ResumeCoroutines(CoroutineHandle handle)
		{
			if (!(_instance == null))
			{
				return _instance.ResumeCoroutinesOnInstance(handle);
			}
			return 0;
		}

		public static int ResumeCoroutines(params CoroutineHandle[] handles)
		{
			int num = 0;
			for (int i = 0; i < handles.Length; i++)
			{
				num += ((ActiveInstances[handles[i].Key] != null) ? GetInstance(handles[i].Key).ResumeCoroutinesOnInstance(handles[i]) : 0);
			}
			return num;
		}

		public int ResumeCoroutinesOnInstance(CoroutineHandle handle)
		{
			int num = 0;
			if (_handleToIndex.ContainsKey(handle) && !CoindexIsNull(_handleToIndex[handle]) && SetPause(_handleToIndex[handle], newPausedState: false))
			{
				num++;
			}
			if (Links.ContainsKey(handle))
			{
				HashSet<CoroutineHandle> hashSet = Links[handle];
				Links.Remove(handle);
				HashSet<CoroutineHandle>.Enumerator enumerator = hashSet.GetEnumerator();
				while (enumerator.MoveNext())
				{
					num += ResumeCoroutines(enumerator.Current);
				}
				Links.Add(handle, hashSet);
			}
			return num;
		}

		public int ResumeCoroutinesOnInstance(IEnumerable<CoroutineHandle> handles)
		{
			int result = 0;
			IEnumerator<CoroutineHandle> enumerator = handles.GetEnumerator();
			while (!enumerator.MoveNext())
			{
				ResumeCoroutinesOnInstance(enumerator.Current);
			}
			return result;
		}

		public static int ResumeCoroutines(GameObject gameObj)
		{
			if (!(_instance == null))
			{
				return _instance.ResumeCoroutinesOnInstance(gameObj.GetInstanceID());
			}
			return 0;
		}

		public int ResumeCoroutinesOnInstance(GameObject gameObj)
		{
			if (!(gameObj == null))
			{
				return ResumeCoroutinesOnInstance(gameObj.GetInstanceID());
			}
			return 0;
		}

		public static int ResumeCoroutines(int layer)
		{
			if (!(_instance == null))
			{
				return _instance.ResumeCoroutinesOnInstance(layer);
			}
			return 0;
		}

		public int ResumeCoroutinesOnInstance(int layer)
		{
			if (!_layeredProcesses.ContainsKey(layer))
			{
				return 0;
			}
			int num = 0;
			HashSet<CoroutineHandle>.Enumerator enumerator = _layeredProcesses[layer].GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (!CoindexIsNull(_handleToIndex[enumerator.Current]) && SetPause(_handleToIndex[enumerator.Current], newPausedState: false))
				{
					num++;
				}
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle> hashSet = Links[enumerator.Current];
					Links.Remove(enumerator.Current);
					HashSet<CoroutineHandle>.Enumerator enumerator2 = hashSet.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += ResumeCoroutines(enumerator2.Current);
					}
					Links.Add(enumerator.Current, hashSet);
				}
			}
			return num;
		}

		public static int ResumeCoroutines(string tag)
		{
			if (!(_instance == null))
			{
				return _instance.ResumeCoroutinesOnInstance(tag);
			}
			return 0;
		}

		public int ResumeCoroutinesOnInstance(string tag)
		{
			if (tag == null || !_taggedProcesses.ContainsKey(tag))
			{
				return 0;
			}
			int num = 0;
			HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (!CoindexIsNull(_handleToIndex[enumerator.Current]) && SetPause(_handleToIndex[enumerator.Current], newPausedState: false))
				{
					num++;
				}
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle> hashSet = Links[enumerator.Current];
					Links.Remove(enumerator.Current);
					HashSet<CoroutineHandle>.Enumerator enumerator2 = hashSet.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += ResumeCoroutines(enumerator2.Current);
					}
					Links.Add(enumerator.Current, hashSet);
				}
			}
			return num;
		}

		public static int ResumeCoroutines(GameObject gameObj, string tag)
		{
			if (!(_instance == null))
			{
				return _instance.ResumeCoroutinesOnInstance(gameObj.GetInstanceID(), tag);
			}
			return 0;
		}

		public int ResumeCoroutinesOnInstance(GameObject gameObj, string tag)
		{
			if (!(gameObj == null))
			{
				return ResumeCoroutinesOnInstance(gameObj.GetInstanceID(), tag);
			}
			return 0;
		}

		public static int ResumeCoroutines(int layer, string tag)
		{
			if (!(_instance == null))
			{
				return _instance.ResumeCoroutinesOnInstance(layer, tag);
			}
			return 0;
		}

		public int ResumeCoroutinesOnInstance(int layer, string tag)
		{
			if (tag == null)
			{
				return ResumeCoroutinesOnInstance(layer);
			}
			if (!_layeredProcesses.ContainsKey(layer) || !_taggedProcesses.ContainsKey(tag))
			{
				return 0;
			}
			int num = 0;
			HashSet<CoroutineHandle>.Enumerator enumerator = _taggedProcesses[tag].GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (CoindexIsNull(_handleToIndex[enumerator.Current]) || !_layeredProcesses[layer].Contains(enumerator.Current))
				{
					continue;
				}
				if (SetPause(_handleToIndex[enumerator.Current], newPausedState: false))
				{
					num++;
				}
				if (Links.ContainsKey(enumerator.Current))
				{
					HashSet<CoroutineHandle> hashSet = Links[enumerator.Current];
					Links.Remove(enumerator.Current);
					HashSet<CoroutineHandle>.Enumerator enumerator2 = hashSet.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						num += ResumeCoroutines(enumerator2.Current);
					}
					Links.Add(enumerator.Current, hashSet);
				}
			}
			return num;
		}

		public static string GetTag(CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			if (!(instance != null) || !instance._handleToIndex.ContainsKey(handle) || !instance._processTags.ContainsKey(handle))
			{
				return null;
			}
			return instance._processTags[handle];
		}

		public static int? GetLayer(CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			if (!(instance != null) || !instance._handleToIndex.ContainsKey(handle) || !instance._processLayers.ContainsKey(handle))
			{
				return null;
			}
			return instance._processLayers[handle];
		}

		public static string GetDebugName(CoroutineHandle handle)
		{
			if (handle.Key == 0)
			{
				return "Uninitialized handle";
			}
			Timing instance = GetInstance(handle.Key);
			if (instance == null)
			{
				return "Invalid handle";
			}
			if (!instance._handleToIndex.ContainsKey(handle))
			{
				return "Expired coroutine";
			}
			return instance.CoindexPeek(instance._handleToIndex[handle]).ToString();
		}

		public static Segment GetSegment(CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			if (!(instance != null) || !instance._handleToIndex.ContainsKey(handle))
			{
				return Segment.Invalid;
			}
			return instance._handleToIndex[handle].seg;
		}

		public static bool SetTag(CoroutineHandle handle, string newTag, bool overwriteExisting = true)
		{
			Timing instance = GetInstance(handle.Key);
			if (instance == null || !instance._handleToIndex.ContainsKey(handle) || instance.CoindexIsNull(instance._handleToIndex[handle]) || (!overwriteExisting && instance._processTags.ContainsKey(handle)))
			{
				return false;
			}
			instance.RemoveTagOnInstance(handle);
			instance.AddTagOnInstance(newTag, handle);
			return true;
		}

		public static bool SetLayer(CoroutineHandle handle, int newLayer, bool overwriteExisting = true)
		{
			Timing instance = GetInstance(handle.Key);
			if (instance == null || !instance._handleToIndex.ContainsKey(handle) || instance.CoindexIsNull(instance._handleToIndex[handle]) || (!overwriteExisting && instance._processLayers.ContainsKey(handle)))
			{
				return false;
			}
			instance.RemoveLayerOnInstance(handle);
			instance.AddLayerOnInstance(newLayer, handle);
			return true;
		}

		public static bool SetSegment(CoroutineHandle handle, Segment newSegment)
		{
			Timing instance = GetInstance(handle.Key);
			if (instance == null || !instance._handleToIndex.ContainsKey(handle) || instance.CoindexIsNull(instance._handleToIndex[handle]))
			{
				return false;
			}
			ProcessIndex coindex = instance._handleToIndex[handle];
			IEnumerator<float> enumerator = instance.CoindexExtract(coindex);
			bool newHeldState = instance.CoindexIsHeld(coindex);
			bool newPausedState = instance.CoindexIsPaused(coindex);
			if (enumerator.Current > instance.GetSegmentTime(coindex.seg))
			{
				enumerator = instance._InjectDelay(enumerator, enumerator.Current - instance.GetSegmentTime(coindex.seg));
			}
			instance.RunCoroutineInternal(enumerator, newSegment, 0, layerHasValue: false, null, handle, prewarm: false);
			coindex = instance._handleToIndex[handle];
			instance.SetHeld(coindex, newHeldState);
			instance.SetPause(coindex, newPausedState);
			return true;
		}

		public static bool RemoveTag(CoroutineHandle handle)
		{
			return SetTag(handle, null);
		}

		public static bool RemoveLayer(CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			if (instance == null || !instance._handleToIndex.ContainsKey(handle) || instance.CoindexIsNull(instance._handleToIndex[handle]))
			{
				return false;
			}
			instance.RemoveLayerOnInstance(handle);
			return true;
		}

		public static bool IsRunning(CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			if (instance != null && instance._handleToIndex.ContainsKey(handle))
			{
				return !instance.CoindexIsNull(instance._handleToIndex[handle]);
			}
			return false;
		}

		public static bool IsAliveAndPaused(CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			if (instance != null && instance._handleToIndex.ContainsKey(handle) && !instance.CoindexIsNull(instance._handleToIndex[handle]))
			{
				return instance.CoindexIsPaused(instance._handleToIndex[handle]);
			}
			return false;
		}

		private void AddTagOnInstance(string tag, CoroutineHandle handle)
		{
			_processTags.Add(handle, tag);
			if (_taggedProcesses.ContainsKey(tag))
			{
				_taggedProcesses[tag].Add(handle);
				return;
			}
			_taggedProcesses.Add(tag, new HashSet<CoroutineHandle> { handle });
		}

		private void AddLayerOnInstance(int layer, CoroutineHandle handle)
		{
			_processLayers.Add(handle, layer);
			if (_layeredProcesses.ContainsKey(layer))
			{
				_layeredProcesses[layer].Add(handle);
				return;
			}
			_layeredProcesses.Add(layer, new HashSet<CoroutineHandle> { handle });
		}

		private void RemoveTagOnInstance(CoroutineHandle handle)
		{
			if (_processTags.ContainsKey(handle))
			{
				if (_taggedProcesses[_processTags[handle]].Count > 1)
				{
					_taggedProcesses[_processTags[handle]].Remove(handle);
				}
				else
				{
					_taggedProcesses.Remove(_processTags[handle]);
				}
				_processTags.Remove(handle);
			}
		}

		private void RemoveLayerOnInstance(CoroutineHandle handle)
		{
			if (_processLayers.ContainsKey(handle))
			{
				if (_layeredProcesses[_processLayers[handle]].Count > 1)
				{
					_layeredProcesses[_processLayers[handle]].Remove(handle);
				}
				else
				{
					_layeredProcesses.Remove(_processLayers[handle]);
				}
				_processLayers.Remove(handle);
			}
		}

		private void RemoveGraffiti(CoroutineHandle handle)
		{
			if (_processLayers.ContainsKey(handle))
			{
				if (_layeredProcesses[_processLayers[handle]].Count > 1)
				{
					_layeredProcesses[_processLayers[handle]].Remove(handle);
				}
				else
				{
					_layeredProcesses.Remove(_processLayers[handle]);
				}
				_processLayers.Remove(handle);
			}
			if (_processTags.ContainsKey(handle))
			{
				if (_taggedProcesses[_processTags[handle]].Count > 1)
				{
					_taggedProcesses[_processTags[handle]].Remove(handle);
				}
				else
				{
					_taggedProcesses.Remove(_processTags[handle]);
				}
				_processTags.Remove(handle);
			}
		}

		private IEnumerator<float> CoindexExtract(ProcessIndex coindex)
		{
			switch (coindex.seg)
			{
			case Segment.Update:
			{
				IEnumerator<float> result9 = UpdateProcesses[coindex.i];
				UpdateProcesses[coindex.i] = null;
				return result9;
			}
			case Segment.FixedUpdate:
			{
				IEnumerator<float> result8 = FixedUpdateProcesses[coindex.i];
				FixedUpdateProcesses[coindex.i] = null;
				return result8;
			}
			case Segment.LateUpdate:
			{
				IEnumerator<float> result7 = LateUpdateProcesses[coindex.i];
				LateUpdateProcesses[coindex.i] = null;
				return result7;
			}
			case Segment.SlowUpdate:
			{
				IEnumerator<float> result6 = SlowUpdateProcesses[coindex.i];
				SlowUpdateProcesses[coindex.i] = null;
				return result6;
			}
			case Segment.RealtimeUpdate:
			{
				IEnumerator<float> result5 = RealtimeUpdateProcesses[coindex.i];
				RealtimeUpdateProcesses[coindex.i] = null;
				return result5;
			}
			case Segment.EditorUpdate:
			{
				IEnumerator<float> result4 = EditorUpdateProcesses[coindex.i];
				EditorUpdateProcesses[coindex.i] = null;
				return result4;
			}
			case Segment.EditorSlowUpdate:
			{
				IEnumerator<float> result3 = EditorSlowUpdateProcesses[coindex.i];
				EditorSlowUpdateProcesses[coindex.i] = null;
				return result3;
			}
			case Segment.EndOfFrame:
			{
				IEnumerator<float> result2 = EndOfFrameProcesses[coindex.i];
				EndOfFrameProcesses[coindex.i] = null;
				return result2;
			}
			case Segment.ManualTimeframe:
			{
				IEnumerator<float> result = ManualTimeframeProcesses[coindex.i];
				ManualTimeframeProcesses[coindex.i] = null;
				return result;
			}
			default:
				return null;
			}
		}

		private bool CoindexIsNull(ProcessIndex coindex)
		{
			return coindex.seg switch
			{
				Segment.Update => UpdateProcesses[coindex.i] == null, 
				Segment.FixedUpdate => FixedUpdateProcesses[coindex.i] == null, 
				Segment.LateUpdate => LateUpdateProcesses[coindex.i] == null, 
				Segment.SlowUpdate => SlowUpdateProcesses[coindex.i] == null, 
				Segment.RealtimeUpdate => RealtimeUpdateProcesses[coindex.i] == null, 
				Segment.EditorUpdate => EditorUpdateProcesses[coindex.i] == null, 
				Segment.EditorSlowUpdate => EditorSlowUpdateProcesses[coindex.i] == null, 
				Segment.EndOfFrame => EndOfFrameProcesses[coindex.i] == null, 
				Segment.ManualTimeframe => ManualTimeframeProcesses[coindex.i] == null, 
				_ => true, 
			};
		}

		private IEnumerator<float> CoindexPeek(ProcessIndex coindex)
		{
			return coindex.seg switch
			{
				Segment.Update => UpdateProcesses[coindex.i], 
				Segment.FixedUpdate => FixedUpdateProcesses[coindex.i], 
				Segment.LateUpdate => LateUpdateProcesses[coindex.i], 
				Segment.SlowUpdate => SlowUpdateProcesses[coindex.i], 
				Segment.RealtimeUpdate => RealtimeUpdateProcesses[coindex.i], 
				Segment.EditorUpdate => EditorUpdateProcesses[coindex.i], 
				Segment.EditorSlowUpdate => EditorSlowUpdateProcesses[coindex.i], 
				Segment.EndOfFrame => EndOfFrameProcesses[coindex.i], 
				Segment.ManualTimeframe => ManualTimeframeProcesses[coindex.i], 
				_ => null, 
			};
		}

		private bool Nullify(CoroutineHandle handle)
		{
			return Nullify(_handleToIndex[handle]);
		}

		private bool Nullify(ProcessIndex coindex)
		{
			switch (coindex.seg)
			{
			case Segment.Update:
			{
				bool result9 = UpdateProcesses[coindex.i] != null;
				UpdateProcesses[coindex.i] = null;
				return result9;
			}
			case Segment.FixedUpdate:
			{
				bool result8 = FixedUpdateProcesses[coindex.i] != null;
				FixedUpdateProcesses[coindex.i] = null;
				return result8;
			}
			case Segment.LateUpdate:
			{
				bool result7 = LateUpdateProcesses[coindex.i] != null;
				LateUpdateProcesses[coindex.i] = null;
				return result7;
			}
			case Segment.SlowUpdate:
			{
				bool result6 = SlowUpdateProcesses[coindex.i] != null;
				SlowUpdateProcesses[coindex.i] = null;
				return result6;
			}
			case Segment.RealtimeUpdate:
			{
				bool result5 = RealtimeUpdateProcesses[coindex.i] != null;
				RealtimeUpdateProcesses[coindex.i] = null;
				return result5;
			}
			case Segment.EditorUpdate:
			{
				bool result4 = UpdateProcesses[coindex.i] != null;
				EditorUpdateProcesses[coindex.i] = null;
				return result4;
			}
			case Segment.EditorSlowUpdate:
			{
				bool result3 = EditorSlowUpdateProcesses[coindex.i] != null;
				EditorSlowUpdateProcesses[coindex.i] = null;
				return result3;
			}
			case Segment.EndOfFrame:
			{
				bool result2 = EndOfFrameProcesses[coindex.i] != null;
				EndOfFrameProcesses[coindex.i] = null;
				return result2;
			}
			case Segment.ManualTimeframe:
			{
				bool result = ManualTimeframeProcesses[coindex.i] != null;
				ManualTimeframeProcesses[coindex.i] = null;
				return result;
			}
			default:
				return false;
			}
		}

		private bool SetPause(ProcessIndex coindex, bool newPausedState)
		{
			if (CoindexPeek(coindex) == null)
			{
				return false;
			}
			switch (coindex.seg)
			{
			case Segment.Update:
			{
				bool result2 = UpdatePaused[coindex.i];
				UpdatePaused[coindex.i] = newPausedState;
				if (newPausedState && UpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					UpdateProcesses[coindex.i] = _InjectDelay(UpdateProcesses[coindex.i], UpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result2;
			}
			case Segment.FixedUpdate:
			{
				bool result6 = FixedUpdatePaused[coindex.i];
				FixedUpdatePaused[coindex.i] = newPausedState;
				if (newPausedState && FixedUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					FixedUpdateProcesses[coindex.i] = _InjectDelay(FixedUpdateProcesses[coindex.i], FixedUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result6;
			}
			case Segment.LateUpdate:
			{
				bool result3 = LateUpdatePaused[coindex.i];
				LateUpdatePaused[coindex.i] = newPausedState;
				if (newPausedState && LateUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					LateUpdateProcesses[coindex.i] = _InjectDelay(LateUpdateProcesses[coindex.i], LateUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result3;
			}
			case Segment.SlowUpdate:
			{
				bool result7 = SlowUpdatePaused[coindex.i];
				SlowUpdatePaused[coindex.i] = newPausedState;
				if (newPausedState && SlowUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					SlowUpdateProcesses[coindex.i] = _InjectDelay(SlowUpdateProcesses[coindex.i], SlowUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result7;
			}
			case Segment.RealtimeUpdate:
			{
				bool result4 = RealtimeUpdatePaused[coindex.i];
				RealtimeUpdatePaused[coindex.i] = newPausedState;
				if (newPausedState && RealtimeUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					RealtimeUpdateProcesses[coindex.i] = _InjectDelay(RealtimeUpdateProcesses[coindex.i], RealtimeUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result4;
			}
			case Segment.EditorUpdate:
			{
				bool result8 = EditorUpdatePaused[coindex.i];
				EditorUpdatePaused[coindex.i] = newPausedState;
				if (newPausedState && EditorUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					EditorUpdateProcesses[coindex.i] = _InjectDelay(EditorUpdateProcesses[coindex.i], EditorUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result8;
			}
			case Segment.EditorSlowUpdate:
			{
				bool result9 = EditorSlowUpdatePaused[coindex.i];
				EditorSlowUpdatePaused[coindex.i] = newPausedState;
				if (newPausedState && EditorSlowUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					EditorSlowUpdateProcesses[coindex.i] = _InjectDelay(EditorSlowUpdateProcesses[coindex.i], EditorSlowUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result9;
			}
			case Segment.EndOfFrame:
			{
				bool result5 = EndOfFramePaused[coindex.i];
				EndOfFramePaused[coindex.i] = newPausedState;
				if (newPausedState && EndOfFrameProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					EndOfFrameProcesses[coindex.i] = _InjectDelay(EndOfFrameProcesses[coindex.i], EndOfFrameProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result5;
			}
			case Segment.ManualTimeframe:
			{
				bool result = ManualTimeframePaused[coindex.i];
				ManualTimeframePaused[coindex.i] = newPausedState;
				if (newPausedState && ManualTimeframeProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					ManualTimeframeProcesses[coindex.i] = _InjectDelay(ManualTimeframeProcesses[coindex.i], ManualTimeframeProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result;
			}
			default:
				return false;
			}
		}

		private bool SetHeld(ProcessIndex coindex, bool newHeldState)
		{
			if (CoindexPeek(coindex) == null)
			{
				return false;
			}
			switch (coindex.seg)
			{
			case Segment.Update:
			{
				bool result2 = UpdateHeld[coindex.i];
				UpdateHeld[coindex.i] = newHeldState;
				if (newHeldState && UpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					UpdateProcesses[coindex.i] = _InjectDelay(UpdateProcesses[coindex.i], UpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result2;
			}
			case Segment.FixedUpdate:
			{
				bool result6 = FixedUpdateHeld[coindex.i];
				FixedUpdateHeld[coindex.i] = newHeldState;
				if (newHeldState && FixedUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					FixedUpdateProcesses[coindex.i] = _InjectDelay(FixedUpdateProcesses[coindex.i], FixedUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result6;
			}
			case Segment.LateUpdate:
			{
				bool result3 = LateUpdateHeld[coindex.i];
				LateUpdateHeld[coindex.i] = newHeldState;
				if (newHeldState && LateUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					LateUpdateProcesses[coindex.i] = _InjectDelay(LateUpdateProcesses[coindex.i], LateUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result3;
			}
			case Segment.SlowUpdate:
			{
				bool result7 = SlowUpdateHeld[coindex.i];
				SlowUpdateHeld[coindex.i] = newHeldState;
				if (newHeldState && SlowUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					SlowUpdateProcesses[coindex.i] = _InjectDelay(SlowUpdateProcesses[coindex.i], SlowUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result7;
			}
			case Segment.RealtimeUpdate:
			{
				bool result4 = RealtimeUpdateHeld[coindex.i];
				RealtimeUpdateHeld[coindex.i] = newHeldState;
				if (newHeldState && RealtimeUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					RealtimeUpdateProcesses[coindex.i] = _InjectDelay(RealtimeUpdateProcesses[coindex.i], RealtimeUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result4;
			}
			case Segment.EditorUpdate:
			{
				bool result8 = EditorUpdateHeld[coindex.i];
				EditorUpdateHeld[coindex.i] = newHeldState;
				if (newHeldState && EditorUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					EditorUpdateProcesses[coindex.i] = _InjectDelay(EditorUpdateProcesses[coindex.i], EditorUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result8;
			}
			case Segment.EditorSlowUpdate:
			{
				bool result9 = EditorSlowUpdateHeld[coindex.i];
				EditorSlowUpdateHeld[coindex.i] = newHeldState;
				if (newHeldState && EditorSlowUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					EditorSlowUpdateProcesses[coindex.i] = _InjectDelay(EditorSlowUpdateProcesses[coindex.i], EditorSlowUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result9;
			}
			case Segment.EndOfFrame:
			{
				bool result5 = EndOfFrameHeld[coindex.i];
				EndOfFrameHeld[coindex.i] = newHeldState;
				if (newHeldState && EndOfFrameProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					EndOfFrameProcesses[coindex.i] = _InjectDelay(EndOfFrameProcesses[coindex.i], EndOfFrameProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result5;
			}
			case Segment.ManualTimeframe:
			{
				bool result = ManualTimeframeHeld[coindex.i];
				ManualTimeframeHeld[coindex.i] = newHeldState;
				if (newHeldState && ManualTimeframeProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					ManualTimeframeProcesses[coindex.i] = _InjectDelay(ManualTimeframeProcesses[coindex.i], ManualTimeframeProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return result;
			}
			default:
				return false;
			}
		}

		private IEnumerator<float> CreateHold(ProcessIndex coindex, IEnumerator<float> coptr)
		{
			if (CoindexPeek(coindex) == null)
			{
				return null;
			}
			switch (coindex.seg)
			{
			case Segment.Update:
				UpdateHeld[coindex.i] = true;
				if (UpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(UpdateProcesses[coindex.i], UpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.FixedUpdate:
				FixedUpdateHeld[coindex.i] = true;
				if (FixedUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(FixedUpdateProcesses[coindex.i], FixedUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.LateUpdate:
				LateUpdateHeld[coindex.i] = true;
				if (LateUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(LateUpdateProcesses[coindex.i], LateUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.SlowUpdate:
				SlowUpdateHeld[coindex.i] = true;
				if (SlowUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(SlowUpdateProcesses[coindex.i], SlowUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.RealtimeUpdate:
				RealtimeUpdateHeld[coindex.i] = true;
				if (RealtimeUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(RealtimeUpdateProcesses[coindex.i], RealtimeUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.EditorUpdate:
				EditorUpdateHeld[coindex.i] = true;
				if (EditorUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(EditorUpdateProcesses[coindex.i], EditorUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.EditorSlowUpdate:
				EditorSlowUpdateHeld[coindex.i] = true;
				if (EditorSlowUpdateProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(EditorSlowUpdateProcesses[coindex.i], EditorSlowUpdateProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.EndOfFrame:
				EndOfFrameHeld[coindex.i] = true;
				if (EndOfFrameProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(EndOfFrameProcesses[coindex.i], EndOfFrameProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			case Segment.ManualTimeframe:
				ManualTimeframeHeld[coindex.i] = true;
				if (ManualTimeframeProcesses[coindex.i].Current > GetSegmentTime(coindex.seg))
				{
					coptr = _InjectDelay(ManualTimeframeProcesses[coindex.i], ManualTimeframeProcesses[coindex.i].Current - GetSegmentTime(coindex.seg));
				}
				return coptr;
			default:
				return coptr;
			}
		}

		private bool CoindexIsPaused(ProcessIndex coindex)
		{
			return coindex.seg switch
			{
				Segment.Update => UpdatePaused[coindex.i], 
				Segment.FixedUpdate => FixedUpdatePaused[coindex.i], 
				Segment.LateUpdate => LateUpdatePaused[coindex.i], 
				Segment.SlowUpdate => SlowUpdatePaused[coindex.i], 
				Segment.RealtimeUpdate => RealtimeUpdatePaused[coindex.i], 
				Segment.EditorUpdate => EditorUpdatePaused[coindex.i], 
				Segment.EditorSlowUpdate => EditorSlowUpdatePaused[coindex.i], 
				Segment.EndOfFrame => EndOfFramePaused[coindex.i], 
				Segment.ManualTimeframe => ManualTimeframePaused[coindex.i], 
				_ => false, 
			};
		}

		private bool CoindexIsHeld(ProcessIndex coindex)
		{
			return coindex.seg switch
			{
				Segment.Update => UpdateHeld[coindex.i], 
				Segment.FixedUpdate => FixedUpdateHeld[coindex.i], 
				Segment.LateUpdate => LateUpdateHeld[coindex.i], 
				Segment.SlowUpdate => SlowUpdateHeld[coindex.i], 
				Segment.RealtimeUpdate => RealtimeUpdateHeld[coindex.i], 
				Segment.EditorUpdate => EditorUpdateHeld[coindex.i], 
				Segment.EditorSlowUpdate => EditorSlowUpdateHeld[coindex.i], 
				Segment.EndOfFrame => EndOfFrameHeld[coindex.i], 
				Segment.ManualTimeframe => ManualTimeframeHeld[coindex.i], 
				_ => false, 
			};
		}

		private void CoindexReplace(ProcessIndex coindex, IEnumerator<float> replacement)
		{
			switch (coindex.seg)
			{
			case Segment.Update:
				UpdateProcesses[coindex.i] = replacement;
				break;
			case Segment.FixedUpdate:
				FixedUpdateProcesses[coindex.i] = replacement;
				break;
			case Segment.LateUpdate:
				LateUpdateProcesses[coindex.i] = replacement;
				break;
			case Segment.SlowUpdate:
				SlowUpdateProcesses[coindex.i] = replacement;
				break;
			case Segment.RealtimeUpdate:
				RealtimeUpdateProcesses[coindex.i] = replacement;
				break;
			case Segment.EditorUpdate:
				EditorUpdateProcesses[coindex.i] = replacement;
				break;
			case Segment.EditorSlowUpdate:
				EditorSlowUpdateProcesses[coindex.i] = replacement;
				break;
			case Segment.EndOfFrame:
				EndOfFrameProcesses[coindex.i] = replacement;
				break;
			case Segment.ManualTimeframe:
				ManualTimeframeProcesses[coindex.i] = replacement;
				break;
			}
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, CurrentCoroutine.Segment), warnOnIssue: true);
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine, string tag)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, CurrentCoroutine.Segment, tag), warnOnIssue: true);
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine, int layer)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, CurrentCoroutine.Segment, layer), warnOnIssue: true);
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine, int layer, string tag)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, CurrentCoroutine.Segment, layer, tag), warnOnIssue: true);
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine, Segment segment)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, segment), warnOnIssue: true);
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine, Segment segment, string tag)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, segment, tag), warnOnIssue: true);
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine, Segment segment, int layer)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, segment, layer), warnOnIssue: true);
		}

		public static float WaitUntilDone(IEnumerator<float> newCoroutine, Segment segment, int layer, string tag)
		{
			return WaitUntilDone(RunCoroutine(newCoroutine, segment, layer, tag), warnOnIssue: true);
		}

		public static float WaitUntilDone(CoroutineHandle otherCoroutine)
		{
			return WaitUntilDone(otherCoroutine, warnOnIssue: true);
		}

		public static float WaitUntilDone(CoroutineHandle otherCoroutine, bool warnOnIssue)
		{
			Timing instance = GetInstance(otherCoroutine.Key);
			if (instance != null && instance._handleToIndex.ContainsKey(otherCoroutine))
			{
				if (instance.CoindexIsNull(instance._handleToIndex[otherCoroutine]))
				{
					return 0f;
				}
				if (!instance._waitingTriggers.ContainsKey(otherCoroutine))
				{
					instance.CoindexReplace(instance._handleToIndex[otherCoroutine], instance._StartWhenDone(otherCoroutine, instance.CoindexPeek(instance._handleToIndex[otherCoroutine])));
					instance._waitingTriggers.Add(otherCoroutine, new HashSet<CoroutineHandle>());
				}
				if (instance.currentCoroutine == otherCoroutine)
				{
					return float.NegativeInfinity;
				}
				if (!instance.currentCoroutine.IsValid)
				{
					return float.NegativeInfinity;
				}
				instance._waitingTriggers[otherCoroutine].Add(instance.currentCoroutine);
				if (!instance._allWaiting.Contains(instance.currentCoroutine))
				{
					instance._allWaiting.Add(instance.currentCoroutine);
				}
				instance.SetHeld(instance._handleToIndex[instance.currentCoroutine], newHeldState: true);
				instance.SwapToLast(otherCoroutine, instance.currentCoroutine);
				return float.NaN;
			}
			return 0f;
		}

		public static void WaitForOtherHandles(CoroutineHandle handle, CoroutineHandle otherHandle, bool warnOnIssue = true)
		{
			if (!IsRunning(handle) || !IsRunning(otherHandle) || handle == otherHandle || handle.Key != otherHandle.Key)
			{
				return;
			}
			Timing instance = GetInstance(handle.Key);
			if (instance != null && instance._handleToIndex.ContainsKey(handle) && instance._handleToIndex.ContainsKey(otherHandle) && !instance.CoindexIsNull(instance._handleToIndex[otherHandle]))
			{
				if (!instance._waitingTriggers.ContainsKey(otherHandle))
				{
					instance.CoindexReplace(instance._handleToIndex[otherHandle], instance._StartWhenDone(otherHandle, instance.CoindexPeek(instance._handleToIndex[otherHandle])));
					instance._waitingTriggers.Add(otherHandle, new HashSet<CoroutineHandle>());
				}
				instance._waitingTriggers[otherHandle].Add(handle);
				if (!instance._allWaiting.Contains(handle))
				{
					instance._allWaiting.Add(handle);
				}
				instance.SetHeld(instance._handleToIndex[handle], newHeldState: true);
				instance.SwapToLast(otherHandle, handle);
			}
		}

		public static void WaitForOtherHandles(CoroutineHandle handle, IEnumerable<CoroutineHandle> otherHandles, bool warnOnIssue = true)
		{
			if (!IsRunning(handle))
			{
				return;
			}
			Timing instance = GetInstance(handle.Key);
			IEnumerator<CoroutineHandle> enumerator = otherHandles.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (IsRunning(enumerator.Current) && !(handle == enumerator.Current) && handle.Key == enumerator.Current.Key)
				{
					if (!instance._waitingTriggers.ContainsKey(enumerator.Current))
					{
						instance.CoindexReplace(instance._handleToIndex[enumerator.Current], instance._StartWhenDone(enumerator.Current, instance.CoindexPeek(instance._handleToIndex[enumerator.Current])));
						instance._waitingTriggers.Add(enumerator.Current, new HashSet<CoroutineHandle>());
					}
					instance._waitingTriggers[enumerator.Current].Add(handle);
					if (!instance._allWaiting.Contains(handle))
					{
						instance._allWaiting.Add(handle);
					}
					instance.SetHeld(instance._handleToIndex[handle], newHeldState: true);
					instance.SwapToLast(enumerator.Current, handle);
				}
			}
		}

		private void SwapToLast(CoroutineHandle firstHandle, CoroutineHandle lastHandle)
		{
			if (firstHandle.Key != lastHandle.Key)
			{
				return;
			}
			ProcessIndex processIndex = _handleToIndex[firstHandle];
			ProcessIndex processIndex2 = _handleToIndex[lastHandle];
			if (processIndex.seg != processIndex2.seg || processIndex.i <= processIndex2.i)
			{
				return;
			}
			IEnumerator<float> replacement = CoindexPeek(processIndex);
			CoindexReplace(processIndex, CoindexPeek(processIndex2));
			CoindexReplace(processIndex2, replacement);
			_indexToHandle[processIndex] = lastHandle;
			_indexToHandle[processIndex2] = firstHandle;
			_handleToIndex[firstHandle] = processIndex2;
			_handleToIndex[lastHandle] = processIndex;
			bool newPausedState = SetPause(processIndex, CoindexIsPaused(processIndex2));
			SetPause(processIndex2, newPausedState);
			newPausedState = SetHeld(processIndex, CoindexIsHeld(processIndex2));
			SetHeld(processIndex2, newPausedState);
			if (_waitingTriggers.ContainsKey(lastHandle))
			{
				HashSet<CoroutineHandle>.Enumerator enumerator = _waitingTriggers[lastHandle].GetEnumerator();
				while (enumerator.MoveNext())
				{
					SwapToLast(lastHandle, enumerator.Current);
				}
			}
			if (!_allWaiting.Contains(firstHandle))
			{
				return;
			}
			Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>.Enumerator enumerator2 = _waitingTriggers.GetEnumerator();
			while (enumerator2.MoveNext())
			{
				HashSet<CoroutineHandle>.Enumerator enumerator3 = enumerator2.Current.Value.GetEnumerator();
				while (enumerator3.MoveNext())
				{
					if (enumerator3.Current == firstHandle)
					{
						SwapToLast(enumerator2.Current.Key, firstHandle);
					}
				}
			}
		}

		private IEnumerator<float> _StartWhenDone(CoroutineHandle handle, IEnumerator<float> proc)
		{
			if (!_waitingTriggers.ContainsKey(handle))
			{
				yield break;
			}
			try
			{
				if (proc.Current > localTime)
				{
					yield return proc.Current;
				}
				while (proc.MoveNext())
				{
					yield return proc.Current;
				}
			}
			finally
			{
				CloseWaitingProcess(handle);
			}
		}

		private void CloseWaitingProcess(CoroutineHandle handle)
		{
			if (!_waitingTriggers.ContainsKey(handle))
			{
				return;
			}
			HashSet<CoroutineHandle>.Enumerator enumerator = _waitingTriggers[handle].GetEnumerator();
			_waitingTriggers.Remove(handle);
			while (enumerator.MoveNext())
			{
				if (_handleToIndex.ContainsKey(enumerator.Current) && !HandleIsInWaitingList(enumerator.Current))
				{
					SetHeld(_handleToIndex[enumerator.Current], newHeldState: false);
					_allWaiting.Remove(enumerator.Current);
				}
			}
		}

		private bool HandleIsInWaitingList(CoroutineHandle handle)
		{
			Dictionary<CoroutineHandle, HashSet<CoroutineHandle>>.Enumerator enumerator = _waitingTriggers.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (enumerator.Current.Value.Contains(handle))
				{
					return true;
				}
			}
			return false;
		}

		private static IEnumerator<float> ReturnTmpRefForRepFunc(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			return _tmpRef as IEnumerator<float>;
		}

		public static float WaitUntilDone(UnityEngine.AsyncOperation operation)
		{
			if (operation == null || operation.isDone)
			{
				return float.NaN;
			}
			CoroutineHandle key = CurrentCoroutine;
			Timing instance = GetInstance(CurrentCoroutine.Key);
			if (instance == null)
			{
				return float.NaN;
			}
			_tmpRef = _StartWhenDone(operation, instance.CoindexPeek(instance._handleToIndex[key]));
			ReplacementFunction = ReturnTmpRefForRepFunc;
			return float.NaN;
		}

		private static IEnumerator<float> _StartWhenDone(UnityEngine.AsyncOperation operation, IEnumerator<float> pausedProc)
		{
			while (!operation.isDone)
			{
				yield return float.NegativeInfinity;
			}
			_tmpRef = pausedProc;
			ReplacementFunction = ReturnTmpRefForRepFunc;
			yield return float.NaN;
		}

		public static float WaitUntilDone(CustomYieldInstruction operation)
		{
			if (operation == null || !operation.keepWaiting)
			{
				return float.NaN;
			}
			CoroutineHandle key = CurrentCoroutine;
			Timing instance = GetInstance(CurrentCoroutine.Key);
			if (instance == null)
			{
				return float.NaN;
			}
			_tmpRef = _StartWhenDone(operation, instance.CoindexPeek(instance._handleToIndex[key]));
			ReplacementFunction = ReturnTmpRefForRepFunc;
			return float.NaN;
		}

		private static IEnumerator<float> _StartWhenDone(CustomYieldInstruction operation, IEnumerator<float> pausedProc)
		{
			while (operation.keepWaiting)
			{
				yield return float.NegativeInfinity;
			}
			_tmpRef = pausedProc;
			ReplacementFunction = ReturnTmpRefForRepFunc;
			yield return float.NaN;
		}

		public static float WaitUntilTrue(Func<bool> evaluatorFunc)
		{
			if (evaluatorFunc == null || evaluatorFunc())
			{
				return float.NaN;
			}
			_tmpRef = evaluatorFunc;
			ReplacementFunction = WaitUntilTrueHelper;
			return float.NaN;
		}

		private static IEnumerator<float> WaitUntilTrueHelper(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			return _StartWhenDone(_tmpRef as Func<bool>, continueOn: false, coptr);
		}

		public static float WaitUntilFalse(Func<bool> evaluatorFunc)
		{
			if (evaluatorFunc == null || !evaluatorFunc())
			{
				return float.NaN;
			}
			_tmpRef = evaluatorFunc;
			ReplacementFunction = WaitUntilFalseHelper;
			return float.NaN;
		}

		private static IEnumerator<float> WaitUntilFalseHelper(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			return _StartWhenDone(_tmpRef as Func<bool>, continueOn: true, coptr);
		}

		private static IEnumerator<float> _StartWhenDone(Func<bool> evaluatorFunc, bool continueOn, IEnumerator<float> pausedProc)
		{
			while (evaluatorFunc() == continueOn)
			{
				yield return float.NegativeInfinity;
			}
			_tmpRef = pausedProc;
			ReplacementFunction = ReturnTmpRefForRepFunc;
			yield return float.NaN;
		}

		private IEnumerator<float> _InjectDelay(IEnumerator<float> proc, float waitTime)
		{
			yield return WaitForSecondsOnInstance(waitTime);
			_tmpRef = proc;
			ReplacementFunction = ReturnTmpRefForRepFunc;
			yield return float.NaN;
		}

		public bool LockCoroutine(CoroutineHandle coroutine, CoroutineHandle key)
		{
			if (coroutine.Key != _instanceID || key == default(CoroutineHandle) || key.Key != 0)
			{
				return false;
			}
			if (!_waitingTriggers.ContainsKey(key))
			{
				_waitingTriggers.Add(key, new HashSet<CoroutineHandle> { coroutine });
			}
			else
			{
				_waitingTriggers[key].Add(coroutine);
			}
			_allWaiting.Add(coroutine);
			SetHeld(_handleToIndex[coroutine], newHeldState: true);
			return true;
		}

		public bool UnlockCoroutine(CoroutineHandle coroutine, CoroutineHandle key)
		{
			if (coroutine.Key != _instanceID || key == default(CoroutineHandle) || !_handleToIndex.ContainsKey(coroutine) || !_waitingTriggers.ContainsKey(key))
			{
				return false;
			}
			if (_waitingTriggers[key].Count == 1)
			{
				_waitingTriggers.Remove(key);
			}
			else
			{
				_waitingTriggers[key].Remove(coroutine);
			}
			if (!HandleIsInWaitingList(coroutine))
			{
				SetHeld(_handleToIndex[coroutine], newHeldState: false);
				_allWaiting.Remove(coroutine);
			}
			return true;
		}

		public static int LinkCoroutines(CoroutineHandle master, CoroutineHandle slave)
		{
			if (!IsRunning(slave) || !master.IsValid)
			{
				return 0;
			}
			if (!IsRunning(master))
			{
				KillCoroutines(slave);
				return 1;
			}
			if (Links.ContainsKey(master))
			{
				if (!Links[master].Contains(slave))
				{
					Links[master].Add(slave);
					return 1;
				}
				return 0;
			}
			Links.Add(master, new HashSet<CoroutineHandle> { slave });
			return 1;
		}

		public static int UnlinkCoroutines(CoroutineHandle master, CoroutineHandle slave, bool twoWay = false)
		{
			int num = 0;
			if (Links.ContainsKey(master) && Links[master].Contains(slave))
			{
				if (Links[master].Count <= 1)
				{
					Links.Remove(master);
				}
				else
				{
					Links[master].Remove(slave);
				}
				num++;
			}
			if (twoWay && Links.ContainsKey(slave) && Links[slave].Contains(master))
			{
				if (Links[slave].Count <= 1)
				{
					Links.Remove(slave);
				}
				else
				{
					Links[slave].Remove(master);
				}
				num++;
			}
			return num;
		}

		[Obsolete("Use Timing.CurrentCoroutine instead.", false)]
		public static float GetMyHandle(Action<CoroutineHandle> reciever)
		{
			_tmpRef = reciever;
			ReplacementFunction = GetHandleHelper;
			return float.NaN;
		}

		private static IEnumerator<float> GetHandleHelper(IEnumerator<float> input, CoroutineHandle handle)
		{
			if (_tmpRef is Action<CoroutineHandle> action)
			{
				action(handle);
			}
			return input;
		}

		public static float SwitchCoroutine(Segment newSegment)
		{
			_tmpSegment = newSegment;
			ReplacementFunction = SwitchCoroutineRepS;
			return float.NaN;
		}

		private static IEnumerator<float> SwitchCoroutineRepS(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			GetInstance(handle.Key).RunCoroutineInternal(coptr, _tmpSegment, 0, layerHasValue: false, null, handle, prewarm: false);
			return null;
		}

		public static float SwitchCoroutine(Segment newSegment, string newTag)
		{
			_tmpSegment = newSegment;
			_tmpRef = newTag;
			ReplacementFunction = SwitchCoroutineRepST;
			return float.NaN;
		}

		private static IEnumerator<float> SwitchCoroutineRepST(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			instance.RemoveTagOnInstance(handle);
			if (_tmpRef is string)
			{
				instance.AddTagOnInstance((string)_tmpRef, handle);
			}
			instance.RunCoroutineInternal(coptr, _tmpSegment, 0, layerHasValue: false, null, handle, prewarm: false);
			return null;
		}

		public static float SwitchCoroutine(Segment newSegment, int newLayer)
		{
			_tmpSegment = newSegment;
			_tmpInt = newLayer;
			ReplacementFunction = SwitchCoroutineRepSL;
			return float.NaN;
		}

		private static IEnumerator<float> SwitchCoroutineRepSL(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			RemoveLayer(handle);
			instance.AddLayerOnInstance(_tmpInt, handle);
			instance.RunCoroutineInternal(coptr, _tmpSegment, _tmpInt, layerHasValue: false, null, handle, prewarm: false);
			return null;
		}

		public static float SwitchCoroutine(Segment newSegment, int newLayer, string newTag)
		{
			_tmpSegment = newSegment;
			_tmpInt = newLayer;
			_tmpRef = newTag;
			ReplacementFunction = SwitchCoroutineRepSLT;
			return float.NaN;
		}

		private static IEnumerator<float> SwitchCoroutineRepSLT(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			instance.RemoveTagOnInstance(handle);
			if (_tmpRef is string)
			{
				instance.AddTagOnInstance((string)_tmpRef, handle);
			}
			RemoveLayer(handle);
			instance.AddLayerOnInstance(_tmpInt, handle);
			instance.RunCoroutineInternal(coptr, _tmpSegment, _tmpInt, layerHasValue: false, null, handle, prewarm: false);
			return null;
		}

		public static float SwitchCoroutine(string newTag)
		{
			_tmpRef = newTag;
			ReplacementFunction = SwitchCoroutineRepT;
			return float.NaN;
		}

		private static IEnumerator<float> SwitchCoroutineRepT(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			instance.RemoveTagOnInstance(handle);
			if (_tmpRef is string)
			{
				instance.AddTagOnInstance((string)_tmpRef, handle);
			}
			return coptr;
		}

		public static float SwitchCoroutine(int newLayer)
		{
			_tmpInt = newLayer;
			ReplacementFunction = SwitchCoroutineRepL;
			return float.NaN;
		}

		private static IEnumerator<float> SwitchCoroutineRepL(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			RemoveLayer(handle);
			GetInstance(handle.Key).AddLayerOnInstance(_tmpInt, handle);
			return coptr;
		}

		public static float SwitchCoroutine(int newLayer, string newTag)
		{
			_tmpInt = newLayer;
			_tmpRef = newTag;
			ReplacementFunction = SwitchCoroutineRepLT;
			return float.NaN;
		}

		private static IEnumerator<float> SwitchCoroutineRepLT(IEnumerator<float> coptr, CoroutineHandle handle)
		{
			Timing instance = GetInstance(handle.Key);
			instance.RemoveLayerOnInstance(handle);
			instance.AddLayerOnInstance(_tmpInt, handle);
			instance.RemoveTagOnInstance(handle);
			if (_tmpRef is string)
			{
				instance.AddTagOnInstance((string)_tmpRef, handle);
			}
			return coptr;
		}

		public static CoroutineHandle CallDelayed(float delay, Action action)
		{
			if (action != null)
			{
				return RunCoroutine(Instance._DelayedCall(delay, action, null));
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle CallDelayedOnInstance(float delay, Action action)
		{
			if (action != null)
			{
				return RunCoroutineOnInstance(_DelayedCall(delay, action, null));
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle CallDelayed(float delay, Action action, GameObject gameObject)
		{
			if (action != null)
			{
				return RunCoroutine(Instance._DelayedCall(delay, action, gameObject), gameObject);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle CallDelayedOnInstance(float delay, Action action, GameObject gameObject)
		{
			if (action != null)
			{
				return RunCoroutineOnInstance(_DelayedCall(delay, action, gameObject), gameObject);
			}
			return default(CoroutineHandle);
		}

		private IEnumerator<float> _DelayedCall(float delay, Action action, GameObject cancelWith)
		{
			yield return WaitForSecondsOnInstance(delay);
			if ((object)cancelWith == null || cancelWith != null)
			{
				action();
			}
		}

		public static CoroutineHandle CallDelayed(float delay, Segment segment, Action action)
		{
			if (action != null)
			{
				return RunCoroutine(Instance._DelayedCall(delay, action, null), segment);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle CallDelayedOnInstance(float delay, Segment segment, Action action)
		{
			if (action != null)
			{
				return RunCoroutineOnInstance(_DelayedCall(delay, action, null), segment);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle CallDelayed(float delay, Segment segment, Action action, GameObject gameObject)
		{
			if (action != null)
			{
				return RunCoroutine(Instance._DelayedCall(delay, action, gameObject), segment, gameObject);
			}
			return default(CoroutineHandle);
		}

		public CoroutineHandle CallDelayedOnInstance(float delay, Segment segment, Action action, GameObject gameObject)
		{
			if (action != null)
			{
				return RunCoroutineOnInstance(_DelayedCall(delay, action, gameObject), segment, gameObject);
			}
			return default(CoroutineHandle);
		}

		public static CoroutineHandle CallPeriodically(float timeframe, float period, Action action, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(period, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, null, onDone));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance(float timeframe, float period, Action action, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(period, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, null, onDone));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallPeriodically(float timeframe, float period, Action action, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(period, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance(float timeframe, float period, Action action, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(period, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallPeriodically(float timeframe, float period, Action action, Segment timing, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(period, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, null, onDone), timing);
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance(float timeframe, float period, Action action, Segment timing, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(period, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, null, onDone), timing));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallPeriodically(float timeframe, float period, Action action, Segment timing, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(period, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance(float timeframe, float period, Action action, Segment timing, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(period, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously(float timeframe, Action action, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(0f, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, null, onDone)));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance(float timeframe, Action action, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(0f, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, null, onDone)));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously(float timeframe, Action action, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(0f, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance(float timeframe, Action action, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(0f, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously(float timeframe, Action action, Segment timing, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(0f, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, null, onDone), timing));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance(float timeframe, Action action, Segment timing, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(0f, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, null, onDone), timing));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously(float timeframe, Action action, Segment timing, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(0f, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance(float timeframe, Action action, Segment timing, GameObject gameObject, Action onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(0f, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		private IEnumerator<float> _WatchCall(float timeframe, CoroutineHandle handle, GameObject gObject, Action onDone)
		{
			yield return WaitForSecondsOnInstance(timeframe);
			KillCoroutinesOnInstance(handle);
			if (onDone != null && ((object)gObject == null || gObject != null))
			{
				onDone();
			}
		}

		private IEnumerator<float> _CallContinuously(float period, Action action, GameObject gObject)
		{
			while ((object)gObject == null || gObject != null)
			{
				yield return WaitForSecondsOnInstance(period);
				if ((object)gObject == null || (gObject != null && gObject.activeInHierarchy))
				{
					action();
				}
			}
		}

		public static CoroutineHandle CallPeriodically<T>(T reference, float timeframe, float period, Action<T> action, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, period, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, null, onDone)));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance<T>(T reference, float timeframe, float period, Action<T> action, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, period, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, null, onDone)));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallPeriodically<T>(T reference, float timeframe, float period, Action<T> action, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, period, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance<T>(T reference, float timeframe, float period, Action<T> action, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, period, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallPeriodically<T>(T reference, float timeframe, float period, Action<T> action, Segment timing, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, period, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, null, onDone), timing));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance<T>(T reference, float timeframe, float period, Action<T> action, Segment timing, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, period, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, null, onDone), timing));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallPeriodically<T>(T reference, float timeframe, float period, Action<T> action, Segment timing, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, period, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallPeriodicallyOnInstance<T>(T reference, float timeframe, float period, Action<T> action, Segment timing, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, period, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously<T>(T reference, float timeframe, Action<T> action, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, 0f, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, null, onDone)));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance<T>(T reference, float timeframe, Action<T> action, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, 0f, action, null)));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, null, onDone)));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously<T>(T reference, float timeframe, Action<T> action, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, 0f, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance<T>(T reference, float timeframe, Action<T> action, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, 0f, action, gameObject), gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), gameObject));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously<T>(T reference, float timeframe, Action<T> action, Segment timing, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, 0f, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, null, onDone), timing));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance<T>(T reference, float timeframe, Action<T> action, Segment timing, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, 0f, action, null), timing));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, null, onDone), timing));
			}
			return coroutineHandle;
		}

		public static CoroutineHandle CallContinuously<T>(T reference, float timeframe, Action<T> action, Segment timing, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutine(Instance._CallContinuously(reference, 0f, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutine(Instance._WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		public CoroutineHandle CallContinuouslyOnInstance<T>(T reference, float timeframe, Action<T> action, Segment timing, GameObject gameObject, Action<T> onDone = null)
		{
			CoroutineHandle coroutineHandle = ((action == null) ? default(CoroutineHandle) : RunCoroutineOnInstance(_CallContinuously(reference, 0f, action, gameObject), timing, gameObject));
			if (!float.IsPositiveInfinity(timeframe))
			{
				LinkCoroutines(coroutineHandle, RunCoroutineOnInstance(_WatchCall(reference, timeframe, coroutineHandle, gameObject, onDone), timing, gameObject));
			}
			return coroutineHandle;
		}

		private IEnumerator<float> _WatchCall<T>(T reference, float timeframe, CoroutineHandle handle, GameObject gObject, Action<T> onDone)
		{
			yield return WaitForSecondsOnInstance(timeframe);
			KillCoroutinesOnInstance(handle);
			if (onDone != null && ((object)gObject == null || gObject != null))
			{
				onDone(reference);
			}
		}

		private IEnumerator<float> _CallContinuously<T>(T reference, float period, Action<T> action, GameObject gObject)
		{
			while ((object)gObject == null || gObject != null)
			{
				yield return WaitForSecondsOnInstance(period);
				if ((object)gObject == null || (gObject != null && gObject.activeInHierarchy))
				{
					action(reference);
				}
			}
		}

		[Obsolete("Unity coroutine function, use RunCoroutine instead.", true)]
		public new Coroutine StartCoroutine(IEnumerator routine)
		{
			return null;
		}

		[Obsolete("Unity coroutine function, use RunCoroutine instead.", true)]
		public new Coroutine StartCoroutine(string methodName, object value)
		{
			return null;
		}

		[Obsolete("Unity coroutine function, use RunCoroutine instead.", true)]
		public new Coroutine StartCoroutine(string methodName)
		{
			return null;
		}

		[Obsolete("Unity coroutine function, use RunCoroutine instead.", true)]
		public new Coroutine StartCoroutine_Auto(IEnumerator routine)
		{
			return null;
		}

		[Obsolete("Unity coroutine function, use KillCoroutines instead.", true)]
		public new void StopCoroutine(string methodName)
		{
		}

		[Obsolete("Unity coroutine function, use KillCoroutines instead.", true)]
		public new void StopCoroutine(IEnumerator routine)
		{
		}

		[Obsolete("Unity coroutine function, use KillCoroutines instead.", true)]
		public new void StopCoroutine(Coroutine routine)
		{
		}

		[Obsolete("Unity coroutine function, use KillCoroutines instead.", true)]
		public new void StopAllCoroutines()
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void Destroy(UnityEngine.Object obj)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void Destroy(UnityEngine.Object obj, float f)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void DestroyObject(UnityEngine.Object obj)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void DestroyObject(UnityEngine.Object obj, float f)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void DestroyImmediate(UnityEngine.Object obj)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void DestroyImmediate(UnityEngine.Object obj, bool b)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void Instantiate(UnityEngine.Object obj)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void Instantiate(UnityEngine.Object original, Vector3 position, Quaternion rotation)
		{
		}

		[Obsolete("Use your own GameObject for this.", true)]
		public new static void Instantiate<T>(T original) where T : UnityEngine.Object
		{
		}

		[Obsolete("Just.. no.", true)]
		public new static T FindObjectOfType<T>() where T : UnityEngine.Object
		{
			return null;
		}

		[Obsolete("Just.. no.", true)]
		public new static UnityEngine.Object FindObjectOfType(Type t)
		{
			return null;
		}

		[Obsolete("Just.. no.", true)]
		public new static T[] FindObjectsOfType<T>() where T : UnityEngine.Object
		{
			return null;
		}

		[Obsolete("Just.. no.", true)]
		public new static UnityEngine.Object[] FindObjectsOfType(Type t)
		{
			return null;
		}

		[Obsolete("Just.. no.", true)]
		public new static void print(object message)
		{
		}
	}
	public enum Segment
	{
		Invalid = -1,
		Update,
		FixedUpdate,
		LateUpdate,
		SlowUpdate,
		RealtimeUpdate,
		EditorUpdate,
		EditorSlowUpdate,
		EndOfFrame,
		ManualTimeframe
	}
	public enum DebugInfoType
	{
		None,
		SeperateCoroutines,
		SeperateTags
	}
	public enum SingletonBehavior
	{
		Abort,
		Overwrite,
		Wait,
		AbortAndUnpause
	}
	public struct CoroutineHandle : IEquatable<CoroutineHandle>
	{
		private const byte ReservedSpace = 15;

		private static readonly int[] NextIndex = new int[16]
		{
			16, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0
		};

		private readonly int _id;

		public byte Key => (byte)((uint)_id & 0xFu);

		public string Tag
		{
			get
			{
				return Timing.GetTag(this);
			}
			set
			{
				Timing.SetTag(this, value);
			}
		}

		public int? Layer
		{
			get
			{
				return Timing.GetLayer(this);
			}
			set
			{
				if (!value.HasValue)
				{
					Timing.RemoveLayer(this);
				}
				else
				{
					Timing.SetLayer(this, value.Value);
				}
			}
		}

		public Segment Segment
		{
			get
			{
				return Timing.GetSegment(this);
			}
			set
			{
				Timing.SetSegment(this, value);
			}
		}

		public bool IsRunning
		{
			get
			{
				return Timing.IsRunning(this);
			}
			set
			{
				if (!value)
				{
					Timing.KillCoroutines(this);
				}
			}
		}

		public bool IsAliveAndPaused
		{
			get
			{
				return Timing.IsAliveAndPaused(this);
			}
			set
			{
				if (value)
				{
					Timing.PauseCoroutines(this);
				}
				else
				{
					Timing.ResumeCoroutines(this);
				}
			}
		}

		public bool IsValid => Key != 0;

		public CoroutineHandle(byte ind)
		{
			if (ind > 15)
			{
				ind -= 15;
			}
			_id = NextIndex[ind] + ind;
			NextIndex[ind] += 16;
		}

		public CoroutineHandle(CoroutineHandle other)
		{
			_id = other._id;
		}

		public bool Equals(CoroutineHandle other)
		{
			return _id == other._id;
		}

		public override bool Equals(object other)
		{
			if (other is CoroutineHandle)
			{
				return Equals((CoroutineHandle)other);
			}
			return false;
		}

		public static bool operator ==(CoroutineHandle a, CoroutineHandle b)
		{
			return a._id == b._id;
		}

		public static bool operator !=(CoroutineHandle a, CoroutineHandle b)
		{
			return a._id != b._id;
		}

		public override int GetHashCode()
		{
			return _id;
		}

		public override string ToString()
		{
			if (Timing.GetTag(this) == null)
			{
				if (!Timing.GetLayer(this).HasValue)
				{
					return Timing.GetDebugName(this);
				}
				return Timing.GetDebugName(this) + " Layer: " + Timing.GetLayer(this);
			}
			if (!Timing.GetLayer(this).HasValue)
			{
				return Timing.GetDebugName(this) + " Tag: " + Timing.GetTag(this);
			}
			return Timing.GetDebugName(this) + " Tag: " + Timing.GetTag(this) + " Layer: " + Timing.GetLayer(this);
		}

		public CoroutineHandle OnDestroy(Action action, Segment segment = Segment.Update)
		{
			Timing instance = Timing.GetInstance(Key);
			if (action == null || instance == null)
			{
				return default(CoroutineHandle);
			}
			return instance.RunCoroutineOnInstance(_OnDestroy(this, action), segment);
		}

		public CoroutineHandle OnDestroy(IEnumerator<float> action, Segment segment = Segment.Update)
		{
			Timing instance = Timing.GetInstance(Key);
			if (action == null || instance == null)
			{
				return default(CoroutineHandle);
			}
			return instance.RunCoroutineOnInstance(_OnDestroy(this, action), segment);
		}

		private static IEnumerator<float> _OnDestroy(CoroutineHandle watched, Action action)
		{
			while (watched.IsRunning)
			{
				yield return float.NegativeInfinity;
			}
			action();
		}

		private static IEnumerator<float> _OnDestroy(CoroutineHandle watched, IEnumerator<float> action)
		{
			while (watched.IsRunning)
			{
				yield return float.NegativeInfinity;
			}
			while (action.MoveNext())
			{
				yield return action.Current;
			}
		}
	}
	public static class MECExtensionMethods1
	{
		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine)
		{
			return Timing.RunCoroutine(coroutine);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, GameObject gameObj)
		{
			return Timing.RunCoroutine(coroutine, gameObj);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, int layer)
		{
			return Timing.RunCoroutine(coroutine, layer);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, string tag)
		{
			return Timing.RunCoroutine(coroutine, tag);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, GameObject gameObj, string tag)
		{
			return Timing.RunCoroutine(coroutine, gameObj, tag);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, int layer, string tag)
		{
			return Timing.RunCoroutine(coroutine, layer, tag);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, Segment segment)
		{
			return Timing.RunCoroutine(coroutine, segment);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, Segment segment, GameObject gameObj)
		{
			return Timing.RunCoroutine(coroutine, segment, gameObj);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, Segment segment, int layer)
		{
			return Timing.RunCoroutine(coroutine, segment, layer);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, Segment segment, string tag)
		{
			return Timing.RunCoroutine(coroutine, segment, tag);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, Segment segment, GameObject gameObj, string tag)
		{
			return Timing.RunCoroutine(coroutine, segment, gameObj, tag);
		}

		public static CoroutineHandle RunCoroutine(this IEnumerator<float> coroutine, Segment segment, int layer, string tag)
		{
			return Timing.RunCoroutine(coroutine, segment, layer, tag);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, CoroutineHandle handle, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, handle, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, GameObject gameObj, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return Timing.RunCoroutineSingleton(coroutine, gameObj.GetInstanceID(), behaviorOnCollision);
			}
			return Timing.RunCoroutine(coroutine);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, int layer, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, layer, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, string tag, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, tag, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, GameObject gameObj, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return Timing.RunCoroutineSingleton(coroutine, gameObj.GetInstanceID(), tag, behaviorOnCollision);
			}
			return Timing.RunCoroutineSingleton(coroutine, tag, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, int layer, string tag, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, layer, tag, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, CoroutineHandle handle, Segment segment, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, handle, segment, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, Segment segment, GameObject gameObj, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return Timing.RunCoroutineSingleton(coroutine, segment, gameObj.GetInstanceID(), behaviorOnCollision);
			}
			return Timing.RunCoroutine(coroutine, segment);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, Segment segment, int layer, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, segment, layer, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, Segment segment, string tag, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, segment, tag, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, Segment segment, GameObject gameObj, string tag, SingletonBehavior behaviorOnCollision)
		{
			if (!(gameObj == null))
			{
				return Timing.RunCoroutineSingleton(coroutine, segment, gameObj.GetInstanceID(), tag, behaviorOnCollision);
			}
			return Timing.RunCoroutineSingleton(coroutine, segment, tag, behaviorOnCollision);
		}

		public static CoroutineHandle RunCoroutineSingleton(this IEnumerator<float> coroutine, Segment segment, int layer, string tag, SingletonBehavior behaviorOnCollision)
		{
			return Timing.RunCoroutineSingleton(coroutine, segment, layer, tag, behaviorOnCollision);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine)
		{
			return Timing.WaitUntilDone(newCoroutine);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine, string tag)
		{
			return Timing.WaitUntilDone(newCoroutine, tag);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine, int layer)
		{
			return Timing.WaitUntilDone(newCoroutine, layer);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine, int layer, string tag)
		{
			return Timing.WaitUntilDone(newCoroutine, layer, tag);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine, Segment segment)
		{
			return Timing.WaitUntilDone(newCoroutine, segment);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine, Segment segment, string tag)
		{
			return Timing.WaitUntilDone(newCoroutine, segment, tag);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine, Segment segment, int layer)
		{
			return Timing.WaitUntilDone(newCoroutine, segment, layer);
		}

		public static float WaitUntilDone(this IEnumerator<float> newCoroutine, Segment segment, int layer, string tag)
		{
			return Timing.WaitUntilDone(newCoroutine, segment, layer, tag);
		}
	}
}
namespace FluffyUnderware.DevTools
{
	public interface IDTGroupParsingAttribute
	{
		string Path { get; }
	}
	public interface IDTFieldParsingAttribute
	{
	}
	public interface IDTGroupRenderAttribute
	{
	}
	public interface IDTFieldRenderAttribute
	{
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
	public class DTVersionAttribute : Attribute
	{
		public readonly string Version;

		public DTVersionAttribute(string version)
		{
			Version = version;
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
	public class DTAttribute : Attribute, IComparable
	{
		public int Sort = 100;

		public bool ShowBelowProperty;

		public int Space;

		public int TypeSort { get; protected set; }

		public virtual int CompareTo(object obj)
		{
			DTAttribute dTAttribute = (DTAttribute)obj;
			int num = ShowBelowProperty.CompareTo(dTAttribute.ShowBelowProperty);
			if (num == 0)
			{
				int num2 = TypeSort.CompareTo(dTAttribute.TypeSort);
				if (num2 == 0)
				{
					return Sort.CompareTo(dTAttribute.Sort);
				}
				return num2;
			}
			return num;
		}

		public DTAttribute(int sortOrder, bool showBelow = false)
		{
			TypeSort = sortOrder;
			ShowBelowProperty = showBelow;
		}
	}
	public class GroupAttribute : DTAttribute, IDTGroupParsingAttribute, IDTGroupRenderAttribute
	{
		public bool Expanded = true;

		public bool Invisible;

		public string Label;

		public string Tooltip;

		public string HelpURL;

		private string mPath;

		public string Path
		{
			get
			{
				return mPath;
			}
			protected set
			{
				PathIsAbsolute = !string.IsNullOrEmpty(value) && value.StartsWith("@");
				if (PathIsAbsolute)
				{
					mPath = value.Substring(1);
					if (string.IsNullOrEmpty(mPath))
					{
						mPath = null;
					}
				}
				else
				{
					mPath = value;
				}
			}
		}

		public bool PathIsAbsolute { get; private set; }

		public GroupAttribute(string pathAndName)
			: base(15)
		{
			Path = pathAndName;
		}
	}
	public class ActionAttribute : DTAttribute
	{
		public enum ActionEnum
		{
			Show,
			Hide,
			Enable,
			Disable,
			ShowInfo,
			ShowWarning,
			ShowError,
			Callback
		}

		public enum ActionPositionEnum
		{
			Above,
			Below
		}

		public ActionEnum Action = ActionEnum.Callback;

		public ActionPositionEnum Position = ActionPositionEnum.Below;

		public object ActionData;

		private MethodInfo mCallback;

		protected ActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
			: base(50)
		{
			ActionData = actionData;
			Action = action;
		}

		public void Callback(object classInstance)
		{
			string text = ActionData as string;
			if (!string.IsNullOrEmpty(text))
			{
				if (mCallback == null)
				{
					mCallback = classInstance.GetType().MethodByName(text, includeInherited: true, includePrivate: true);
				}
				if (mCallback != null)
				{
					mCallback.Invoke(classInstance, null);
					return;
				}
				UnityEngine.Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", text, classInstance.GetType().Name);
			}
		}
	}
	public class ConditionalAttribute : ActionAttribute
	{
		public enum OperatorEnum
		{
			AND,
			OR
		}

		public class Condition
		{
			public string FieldName;

			public FieldInfo FieldInfo;

			public PropertyInfo PropertyInfo;

			public object CompareTo;

			public bool CompareFalse;

			public OperatorEnum Operator;

			public MethodInfo MethodInfo;

			public string MethodName;
		}

		public Condition[] Conditions;

		protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[1]
			{
				new Condition
				{
					FieldName = fieldOrProperty,
					CompareTo = compareTo,
					CompareFalse = compareFalse
				}
			};
		}

		protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[2]
			{
				new Condition
				{
					FieldName = fieldOrProperty,
					CompareTo = compareTo,
					CompareFalse = compareFalse
				},
				new Condition
				{
					FieldName = fieldOrProperty2,
					CompareTo = compareTo2,
					CompareFalse = compareFalse2,
					Operator = op
				}
			};
		}

		protected ConditionalAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2, string fieldOrProperty3, object compareTo3, bool compareFalse3)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[3]
			{
				new Condition
				{
					FieldName = fieldOrProperty,
					CompareTo = compareTo,
					CompareFalse = compareFalse
				},
				new Condition
				{
					FieldName = fieldOrProperty2,
					CompareTo = compareTo2,
					CompareFalse = compareFalse2,
					Operator = op
				},
				new Condition
				{
					FieldName = fieldOrProperty3,
					CompareTo = compareTo3,
					CompareFalse = compareFalse3,
					Operator = op
				}
			};
		}

		protected ConditionalAttribute(string methodToQuery)
			: base(null, ActionEnum.Show)
		{
			base.TypeSort = 55;
			Conditions = new Condition[1]
			{
				new Condition
				{
					MethodName = methodToQuery,
					CompareTo = null
				}
			};
		}

		public virtual bool ConditionMet(object classInstance)
		{
			bool flag = evaluate(Conditions[0], classInstance);
			for (int i = 1; i < Conditions.Length; i++)
			{
				Condition condition = Conditions[i];
				switch (condition.Operator)
				{
				case OperatorEnum.AND:
					flag = flag && evaluate(condition, classInstance);
					break;
				case OperatorEnum.OR:
					flag = flag || evaluate(condition, classInstance);
					break;
				}
			}
			return flag;
		}

		private bool evaluate(Condition cond, object classInstance)
		{
			if (!string.IsNullOrEmpty(cond.MethodName))
			{
				if (cond.MethodInfo == null)
				{
					cond.MethodInfo = classInstance.GetType().MethodByName(cond.MethodName, includeInherited: true, includePrivate: true);
				}
				if (cond.MethodInfo != null)
				{
					if (cond.CompareFalse)
					{
						return !(bool)cond.MethodInfo.Invoke(classInstance, null);
					}
					return (bool)cond.MethodInfo.Invoke(classInstance, null);
				}
				UnityEngine.Debug.LogWarningFormat("[DevTools] Unable to find method '{0}' at class '{1}' !", cond.MethodName, classInstance.GetType().Name);
				return cond.CompareFalse;
			}
			if (cond.FieldInfo == null)
			{
				cond.FieldInfo = classInstance.GetType().FieldByName(cond.FieldName, includeInherited: true, includePrivate: true);
				if (cond.FieldInfo == null)
				{
					cond.PropertyInfo = classInstance.GetType().PropertyByName(cond.FieldName, includeInherited: true, includePrivate: true);
				}
			}
			object obj = null;
			if (cond.FieldInfo != null)
			{
				obj = cond.FieldInfo.GetValue(classInstance);
			}
			else if (cond.PropertyInfo != null)
			{
				obj = cond.PropertyInfo.GetValue(classInstance, null);
			}
			if (obj == null)
			{
				if (cond.CompareTo == null)
				{
					return !cond.CompareFalse;
				}
				return false;
			}
			return obj.Equals(cond.CompareTo) == !cond.CompareFalse;
		}
	}
	public class SortOrderAttribute : DTAttribute, IDTFieldParsingAttribute
	{
		public SortOrderAttribute(int sort = 100)
			: base(0)
		{
			Sort = sort;
		}
	}
	public class AsGroupAttribute : GroupAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
	{
		public AsGroupAttribute(string pathAndName = null)
			: base(pathAndName)
		{
			base.TypeSort = 10;
		}
	}
	public class TabAttribute : GroupAttribute
	{
		public readonly string TabName;

		public readonly string TabBarName;

		public TabAttribute(string pathAndName)
			: base("")
		{
			base.TypeSort = 10;
			split(pathAndName, out var path, out TabBarName, out TabName);
			base.Path = path;
		}

		private static bool split(string pathAndName, out string path, out string tabBar, out string tabname)
		{
			string[] array = pathAndName.Split('/');
			path = string.Empty;
			tabBar = string.Empty;
			tabname = pathAndName;
			if (array.Length == 0)
			{
				return false;
			}
			if (array.Length == 1)
			{
				tabname = array[0];
				tabBar = "Default";
				return true;
			}
			tabname = array[^1];
			tabBar = array[^2];
			path = string.Join("/", array, 0, array.Length - 2);
			return true;
		}
	}
	public class SectionAttribute : GroupAttribute
	{
		public bool Fixed;

		public SectionAttribute(string name, bool expanded = true, bool fix = false, int sort = 100)
			: base(name)
		{
			Expanded = expanded;
			base.TypeSort = 10;
			Sort = sort;
			Fixed = fix;
		}
	}
	public class NoSectionAttribute : SectionAttribute
	{
		public NoSectionAttribute()
			: base("")
		{
			base.TypeSort = 10;
		}
	}
	public class Hide : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
	{
		public Hide()
			: base(20)
		{
		}
	}
	public class Inline : DTAttribute, IDTFieldParsingAttribute, IDTFieldRenderAttribute
	{
		public Inline()
			: base(21)
		{
		}
	}
	public class ArrayExAttribute : DTAttribute, IDTFieldParsingAttribute
	{
		public bool Draggable = true;

		public bool ShowHeader = true;

		public bool ShowAdd = true;

		public bool ShowDelete = true;

		public bool DropTarget = true;

		public ArrayExAttribute()
			: base(35)
		{
		}
	}
	public class FieldActionAttribute : ActionAttribute, IDTFieldRenderAttribute
	{
		public FieldActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
			: base(actionData, action)
		{
		}
	}
	public class GroupActionAttribute : ActionAttribute, IDTGroupRenderAttribute
	{
		public GroupActionAttribute(string actionData, ActionEnum action = ActionEnum.Callback)
			: base(actionData, action)
		{
		}
	}
	public class FieldConditionAttribute : ConditionalAttribute, IDTFieldRenderAttribute
	{
		public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false, ActionEnum action = ActionEnum.Show, object actionData = null, ActionPositionEnum position = ActionPositionEnum.Below)
			: base(fieldOrProperty, compareTo, compareFalse)
		{
			Action = action;
			ActionData = actionData;
			Position = position;
		}

		public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2)
		{
		}

		public FieldConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2, string fieldOrProperty3, object compareTo3, bool compareFalse3)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3)
		{
		}

		public FieldConditionAttribute(string methodToQuery)
			: base(methodToQuery)
		{
		}
	}
	public class GroupConditionAttribute : ConditionalAttribute, IDTGroupRenderAttribute
	{
		public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse = false)
			: base(fieldOrProperty, compareTo, compareFalse)
		{
		}

		public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2)
		{
		}

		public GroupConditionAttribute(string fieldOrProperty, object compareTo, bool compareFalse, OperatorEnum op, string fieldOrProperty2, object compareTo2, bool compareFalse2, string fieldOrProperty3, object compareTo3, bool compareFalse3)
			: base(fieldOrProperty, compareTo, compareFalse, op, fieldOrProperty2, compareTo2, compareFalse2, fieldOrProperty3, compareTo3, compareFalse3)
		{
		}

		public GroupConditionAttribute(string methodToQuery)
			: base(methodToQuery)
		{
		}
	}
	public class Couple<T1, T2>
	{
		public T1 First { get; set; }

		public T2 Second { get; set; }

		public Couple(T1 first, T2 second)
		{
			First = first;
			Second = second;
		}
	}
	public static class DTTween
	{
		public enum EasingMethod
		{
			Linear,
			ExponentialIn,
			ExponentialOut,
			ExponentialInOut,
			ExponentialOutIn,
			CircularIn,
			CircularOut,
			CircularInOut,
			CircularOutIn,
			QuadraticIn,
			QuadraticOut,
			QuadraticInOut,
			QuadraticOutIn,
			SinusIn,
			SinusOut,
			SinusInOut,
			SinusOutIn,
			CubicIn,
			CubicOut,
			CubicInOut,
			CubicOutIn,
			QuarticIn,
			QuarticOut,
			QuarticInOut,
			QuarticOutIn,
			QuinticIn,
			QuinticOut,
			QuinticInOut,
			QuinticOutIn
		}

		public static float Ease(EasingMethod method, float t, float b, float c)
		{
			return method switch
			{
				EasingMethod.ExponentialIn => ExpoIn(t, b, c), 
				EasingMethod.ExponentialOut => ExpoOut(t, b, c), 
				EasingMethod.ExponentialInOut => ExpoInOut(t, b, c), 
				EasingMethod.ExponentialOutIn => ExpoOutIn(t, b, c), 
				EasingMethod.CircularIn => CircIn(t, b, c), 
				EasingMethod.CircularOut => CircOut(t, b, c), 
				EasingMethod.CircularInOut => CircInOut(t, b, c), 
				EasingMethod.CircularOutIn => CircOutIn(t, b, c), 
				EasingMethod.QuadraticIn => QuadIn(t, b, c), 
				EasingMethod.QuadraticOut => QuadOut(t, b, c), 
				EasingMethod.QuadraticInOut => QuadInOut(t, b, c), 
				EasingMethod.QuadraticOutIn => QuadOutIn(t, b, c), 
				EasingMethod.SinusIn => SineIn(t, b, c), 
				EasingMethod.SinusOut => SineOut(t, b, c), 
				EasingMethod.SinusInOut => SineInOut(t, b, c), 
				EasingMethod.SinusOutIn => SineOutIn(t, b, c), 
				EasingMethod.CubicIn => CubicIn(t, b, c), 
				EasingMethod.CubicOut => CubicOut(t, b, c), 
				EasingMethod.CubicInOut => CubicInOut(t, b, c), 
				EasingMethod.CubicOutIn => CubicOutIn(t, b, c), 
				EasingMethod.QuarticIn => QuartIn(t, b, c), 
				EasingMethod.QuarticOut => QuartOut(t, b, c), 
				EasingMethod.QuarticInOut => QuartInOut(t, b, c), 
				EasingMethod.QuarticOutIn => QuartOutIn(t, b, c), 
				EasingMethod.QuinticIn => QuintIn(t, b, c), 
				EasingMethod.QuinticOut => QuintOut(t, b, c), 
				EasingMethod.QuinticInOut => QuintInOut(t, b, c), 
				EasingMethod.QuinticOutIn => QuintOutIn(t, b, c), 
				_ => Linear(t, b, c), 
			};
		}

		public static float Ease(EasingMethod method, float t, float b, float c, float d)
		{
			return method switch
			{
				EasingMethod.ExponentialIn => ExpoIn(t, b, c, d), 
				EasingMethod.ExponentialOut => ExpoOut(t, b, c, d), 
				EasingMethod.ExponentialInOut => ExpoInOut(t, b, c, d), 
				EasingMethod.ExponentialOutIn => ExpoOutIn(t, b, c, d), 
				EasingMethod.CircularIn => CircIn(t, b, c, d), 
				EasingMethod.CircularOut => CircOut(t, b, c, d), 
				EasingMethod.CircularInOut => CircInOut(t, b, c, d), 
				EasingMethod.CircularOutIn => CircOutIn(t, b, c, d), 
				EasingMethod.QuadraticIn => QuadIn(t, b, c, d), 
				EasingMethod.QuadraticOut => QuadOut(t, b, c, d), 
				EasingMethod.QuadraticInOut => QuadInOut(t, b, c, d), 
				EasingMethod.QuadraticOutIn => QuadOutIn(t, b, c, d), 
				EasingMethod.SinusIn => SineIn(t, b, c, d), 
				EasingMethod.SinusOut => SineOut(t, b, c, d), 
				EasingMethod.SinusInOut => SineInOut(t, b, c, d), 
				EasingMethod.SinusOutIn => SineOutIn(t, b, c, d), 
				EasingMethod.CubicIn => CubicIn(t, b, c, d), 
				EasingMethod.CubicOut => CubicOut(t, b, c, d), 
				EasingMethod.CubicInOut => CubicInOut(t, b, c, d), 
				EasingMethod.CubicOutIn => CubicOutIn(t, b, c, d), 
				EasingMethod.QuarticIn => QuartIn(t, b, c, d), 
				EasingMethod.QuarticOut => QuartOut(t, b, c, d), 
				EasingMethod.QuarticInOut => QuartInOut(t, b, c, d), 
				EasingMethod.QuarticOutIn => QuartOutIn(t, b, c, d), 
				EasingMethod.QuinticIn => QuintIn(t, b, c, d), 
				EasingMethod.QuinticOut => QuintOut(t, b, c, d), 
				EasingMethod.QuinticInOut => QuintInOut(t, b, c, d), 
				EasingMethod.QuinticOutIn => QuintOutIn(t, b, c, d), 
				_ => Linear(t, b, c, d), 
			};
		}

		public static float Linear(float t, float b, float c)
		{
			return c * Mathf.Clamp01(t) + b;
		}

		public static float Linear(float t, float b, float c, float d)
		{
			return c * t / d + b;
		}

		public static float ExpoOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t != 1f)
			{
				return c * (0f - Mathf.Pow(2f, -10f * t) + 1f) + b;
			}
			return b + c;
		}

		public static float ExpoOut(float t, float b, float c, float d)
		{
			if (t != d)
			{
				return c * (0f - Mathf.Pow(2f, -10f * t / d) + 1f) + b;
			}
			return b + c;
		}

		public static float ExpoIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t != 0f)
			{
				return c * Mathf.Pow(2f, 10f * (t - 1f)) + b;
			}
			return b;
		}

		public static float ExpoIn(float t, float b, float c, float d)
		{
			if (t != 0f)
			{
				return c * Mathf.Pow(2f, 10f * (t / d - 1f)) + b;
			}
			return b;
		}

		public static float ExpoInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t == 0f)
			{
				return b;
			}
			if (t == 1f)
			{
				return b + c;
			}
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * Mathf.Pow(2f, 10f * (t - 1f)) + b;
			}
			return c / 2f * (0f - Mathf.Pow(2f, -10f * (t -= 1f)) + 2f) + b;
		}

		public static float ExpoInOut(float t, float b, float c, float d)
		{
			if (t == 0f)
			{
				return b;
			}
			if (t == d)
			{
				return b + c;
			}
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * Mathf.Pow(2f, 10f * (t - 1f)) + b;
			}
			return c / 2f * (0f - Mathf.Pow(2f, -10f * (t -= 1f)) + 2f) + b;
		}

		public static float ExpoOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return ExpoOut(t * 2f, b, c / 2f);
			}
			return ExpoIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float ExpoOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return ExpoOut(t * 2f, b, c / 2f, d);
			}
			return ExpoIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float CircOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * Mathf.Sqrt(1f - (t -= 1f) * t) + b;
		}

		public static float CircOut(float t, float b, float c, float d)
		{
			return c * Mathf.Sqrt(1f - (t = t / d - 1f) * t) + b;
		}

		public static float CircIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (0f - c) * (Mathf.Sqrt(1f - t * t) - 1f) + b;
		}

		public static float CircIn(float t, float b, float c, float d)
		{
			return (0f - c) * (Mathf.Sqrt(1f - (t /= d) * t) - 1f) + b;
		}

		public static float CircInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float CircInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float CircOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return CircOut(t * 2f, b, c / 2f);
			}
			return CircIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float CircOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return CircOut(t * 2f, b, c / 2f, d);
			}
			return CircIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float QuadOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (0f - c) * t * (t - 2f) + b;
		}

		public static float QuadOut(float t, float b, float c, float d)
		{
			return (0f - c) * (t /= d) * (t - 2f) + b;
		}

		public static float QuadIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t + b;
		}

		public static float QuadIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t + b;
		}

		public static float QuadInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float QuadInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return (0f - c) / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + b;
			}
			return c / 2f * (Mathf.Sqrt(1f - (t -= 2f) * t) + 1f) + b;
		}

		public static float QuadOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return QuadOut(t * 2f, b, c / 2f);
			}
			return QuadIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float QuadOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return QuadOut(t * 2f, b, c / 2f, d);
			}
			return QuadIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float SineOut(float t, float b, float c)
		{
			return c * Mathf.Sin(Mathf.Clamp01(t) * ((float)Math.PI / 2f)) + b;
		}

		public static float SineOut(float t, float b, float c, float d)
		{
			return c * Mathf.Sin(t / d * ((float)Math.PI / 2f)) + b;
		}

		public static float SineIn(float t, float b, float c)
		{
			return (0f - c) * Mathf.Cos(Mathf.Clamp01(t) * ((float)Math.PI / 2f)) + c + b;
		}

		public static float SineIn(float t, float b, float c, float d)
		{
			return (0f - c) * Mathf.Cos(t / d * ((float)Math.PI / 2f)) + c + b;
		}

		public static float SineInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * Mathf.Sin((float)Math.PI * t / 2f) + b;
			}
			return (0f - c) / 2f * (Mathf.Cos((float)Math.PI * (t -= 1f) / 2f) - 2f) + b;
		}

		public static float SineInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * Mathf.Sin((float)Math.PI * t / 2f) + b;
			}
			return (0f - c) / 2f * (Mathf.Cos((float)Math.PI * (t -= 1f) / 2f) - 2f) + b;
		}

		public static float SineOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return SineOut(t * 2f, b, c / 2f);
			}
			return SineIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float SineOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return SineOut(t * 2f, b, c / 2f, d);
			}
			return SineIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float CubicOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * ((t -= 1f) * t * t + 1f) + b;
		}

		public static float CubicOut(float t, float b, float c, float d)
		{
			return c * ((t = t / d - 1f) * t * t + 1f) + b;
		}

		public static float CubicIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t * t + b;
		}

		public static float CubicIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t * t + b;
		}

		public static float CubicInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t + 2f) + b;
		}

		public static float CubicInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t + 2f) + b;
		}

		public static float CubicOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return CubicOut(t * 2f, b, c / 2f);
			}
			return CubicIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float CubicOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return CubicOut(t * 2f, b, c / 2f, d);
			}
			return CubicIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float QuartOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return (0f - c) * ((t -= 1f) * t * t * t - 1f) + b;
		}

		public static float QuartOut(float t, float b, float c, float d)
		{
			return (0f - c) * ((t = t / d - 1f) * t * t * t - 1f) + b;
		}

		public static float QuartIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t * t * t + b;
		}

		public static float QuartIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t * t * t + b;
		}

		public static float QuartInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * t * t * t * t + b;
			}
			return (0f - c) / 2f * ((t -= 2f) * t * t * t - 2f) + b;
		}

		public static float QuartInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * t * t * t * t + b;
			}
			return (0f - c) / 2f * ((t -= 2f) * t * t * t - 2f) + b;
		}

		public static float QuartOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return QuartOut(t * 2f, b, c / 2f);
			}
			return QuartIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float QuartOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return QuartOut(t * 2f, b, c / 2f, d);
			}
			return QuartIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}

		public static float QuintOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * ((t -= 1f) * t * t * t * t + 1f) + b;
		}

		public static float QuintOut(float t, float b, float c, float d)
		{
			return c * ((t = t / d - 1f) * t * t * t * t + 1f) + b;
		}

		public static float QuintIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			return c * t * t * t * t * t + b;
		}

		public static float QuintIn(float t, float b, float c, float d)
		{
			return c * (t /= d) * t * t * t * t + b;
		}

		public static float QuintInOut(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if ((t /= 0.5f) < 1f)
			{
				return c / 2f * t * t * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t * t * t + 2f) + b;
		}

		public static float QuintInOut(float t, float b, float c, float d)
		{
			if ((t /= d / 2f) < 1f)
			{
				return c / 2f * t * t * t * t * t + b;
			}
			return c / 2f * ((t -= 2f) * t * t * t * t + 2f) + b;
		}

		public static float QuintOutIn(float t, float b, float c)
		{
			t = Mathf.Clamp01(t);
			if (t < 0.5f)
			{
				return QuintOut(t * 2f, b, c / 2f);
			}
			return QuintIn(t * 2f - 1f, b + c / 2f, c / 2f);
		}

		public static float QuintOutIn(float t, float b, float c, float d)
		{
			if (t < d / 2f)
			{
				return QuintOut(t * 2f, b, c / 2f, d);
			}
			return QuintIn(t * 2f - d, b + c / 2f, c / 2f, d);
		}
	}
	public class DTObjectDump
	{
		private const int INDENTSPACES = 5;

		private string mIndent;

		private StringBuilder mSB;

		private object mObject;

		public DTObjectDump(object o, int indent = 0)
		{
			mIndent = new string(' ', indent);
			mSB = new StringBuilder();
			mObject = o;
			Type type = o.GetType();
			FieldInfo[] allFields = type.GetAllFields(includeInherited: false, includePrivate: true);
			if (allFields.Length != 0)
			{
				AppendHeader("Fields");
			}
			FieldInfo[] array = allFields;
			foreach (FieldInfo info in array)
			{
				AppendMember(info);
			}
			PropertyInfo[] allProperties = type.GetAllProperties(includeInherited: false, includePrivate: true);
			if (allProperties.Length != 0)
			{
				AppendHeader("Properties");
			}
			PropertyInfo[] array2 = allProperties;
			foreach (PropertyInfo info2 in array2)
			{
				AppendMember(info2);
			}
		}

		public override string ToString()
		{
			return mSB.ToString();
		}

		private void AppendHeader(string name)
		{
			mSB.AppendLine(mIndent + "<b>---===| " + name + " |===---</b>\n");
		}

		private void AppendMember(MemberInfo info)
		{
			FieldInfo fieldInfo = info as FieldInfo;
			Type type;
			string arg;
			object value;
			if (fieldInfo != null)
			{
				type = fieldInfo.FieldType;
				arg = type.Name;
				value = fieldInfo.GetValue(mObject);
			}
			else
			{
				PropertyInfo obj = info as PropertyInfo;
				type = obj.PropertyType;
				arg = type.Name;
				value = obj.GetValue(mObject, null);
			}
			if (value == null)
			{
				return;
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				string text = mIndent;
				int num = 0;
				if (value is IEnumerable enumerable)
				{
					if (type.GetEnumerableType().BaseType == typeof(ValueType))
					{
						foreach (object item in enumerable)
						{
							text += $"<b>{num++.ToString()}</b>: {item.ToString()} ";
						}
					}
					else
					{
						if (typeof(IList).IsAssignableFrom(type))
						{
							arg = string.Concat("IList<", type.GetEnumerableType(), ">");
						}
						text += "\n";
						foreach (object item2 in enumerable)
						{
							text += $"<b>{num++.ToString()}</b>: {new DTObjectDump(item2, mIndent.Length + 5).ToString()} ";
						}
					}
				}
				mSB.Append(mIndent);
				mSB.AppendFormat("(<i>{0}</i>) <b>{1}[{2}]</b> = ", arg, info.Name, num);
				mSB.AppendLine(text);
			}
			else
			{
				mSB.Append(mIndent);
				mSB.AppendFormat("(<i>{0}</i>) <b>{1}</b> = ", arg, info.Name);
				mSB.AppendLine(mIndent + value.ToString());
			}
		}
	}
	public static class DTUtility
	{
		public const string HelpUrlBase = "https://curvyeditor.com/doclink/";

		public static bool IsEditorStateChange => false;

		public static Material GetDefaultMaterial()
		{
			return null;
		}

		public static float GetHandleSize(Vector3 position)
		{
			Camera current = Camera.current;
			if ((bool)current)
			{
				Transform transform = current.transform;
				Vector3 direction = default(Vector3);
				direction.x = 0f;
				direction.y = 0f;
				direction.z = 1f;
				Vector3 cameraZDirection = transform.TransformDirection(direction);
				return GetHandleSize(Gizmos.matrix.MultiplyPoint(position), current, transform.position, cameraZDirection, transform);
			}
			return 20f;
		}

		public static float GetHandleSize(Vector3 position, Camera camera, Vector3 cameraPosition, Vector3 cameraZDirection, Transform cameraTransform)
		{
			Vector3 lhs = position;
			lhs.x -= cameraPosition.x;
			lhs.y -= cameraPosition.y;
			lhs.z -= cameraPosition.z;
			float z = Vector3.Dot(lhs, cameraZDirection);
			Vector3 direction = default(Vector3);
			direction.x = 0f;
			direction.y = 0f;
			direction.z = z;
			Vector3 vector = cameraTransform.TransformDirection(direction);
			Vector3 direction2 = default(Vector3);
			direction2.x = 1f;
			direction2.y = 0f;
			direction2.z = z;
			Vector3 vector2 = cameraTransform.TransformDirection(direction2);
			Vector3 position2 = cameraPosition;
			position2.x += vector.x;
			position2.y += vector.y;
			position2.z += vector.z;
			Vector3 vector3 = camera.WorldToScreenPoint(position2);
			Vector3 position3 = cameraPosition;
			position3.x += vector2.x;
			position3.y += vector2.y;
			position3.z += vector2.z;
			Vector3 vector4 = camera.WorldToScreenPoint(position3);
			Vector3 vector5 = vector3;
			vector5.x -= vector4.x;
			vector5.y -= vector4.y;
			vector5.z -= vector4.z;
			return 80f / Mathf.Max(vector5.magnitude, 0.0001f);
		}

		public static void SetPlayerPrefs<T>(string key, T value)
		{
			Type typeFromHandle = typeof(T);
			if (typeFromHandle.IsEnum)
			{
				PlayerPrefs.SetInt(key, Convert.ToInt32(Enum.Parse(typeof(T), value.ToString()) as Enum));
				return;
			}
			if (typeFromHandle.IsArray)
			{
				throw new NotImplementedException();
			}
			if (typeFromHandle.Matches(typeof(int), typeof(int)))
			{
				PlayerPrefs.SetInt(key, (value as int?).Value);
			}
			else if (typeFromHandle == typeof(string))
			{
				PlayerPrefs.SetString(key, value as string);
			}
			else if (typeFromHandle == typeof(float))
			{
				PlayerPrefs.SetFloat(key, (value as float?).Value);
			}
			else if (typeFromHandle == typeof(bool))
			{
				PlayerPrefs.SetInt(key, (value as bool?).Value ? 1 : 0);
			}
			else if (typeFromHandle == typeof(Color))
			{
				PlayerPrefs.SetString(key, (value as Color?).Value.ToHtml());
			}
			else
			{
				UnityEngine.Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + typeFromHandle.Name);
			}
		}

		public static T GetPlayerPrefs<T>(string key, T defaultValue)
		{
			if (PlayerPrefs.HasKey(key))
			{
				Type typeFromHandle = typeof(T);
				try
				{
					if (typeFromHandle.IsEnum || typeFromHandle.Matches(typeof(int), typeof(int)))
					{
						return (T)(object)PlayerPrefs.GetInt(key, (int)(object)defaultValue);
					}
					if (typeFromHandle.IsArray)
					{
						throw new NotImplementedException();
					}
					if (typeFromHandle == typeof(string))
					{
						return (T)(object)PlayerPrefs.GetString(key, defaultValue.ToString());
					}
					if (typeFromHandle == typeof(float))
					{
						return (T)(object)PlayerPrefs.GetFloat(key, (float)(object)defaultValue);
					}
					if (typeFromHandle == typeof(bool))
					{
						return (T)(object)(PlayerPrefs.GetInt(key, ((bool)(object)defaultValue) ? 1 : 0) == 1);
					}
					if (typeFromHandle == typeof(Color))
					{
						return (T)(object)PlayerPrefs.GetString(key, ((Color)(object)defaultValue).ToHtml()).ColorFromHtml();
					}
					UnityEngine.Debug.LogError("[DevTools.SetEditorPrefs] Unsupported datatype: " + typeFromHandle.Name);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					return defaultValue;
				}
			}
			return defaultValue;
		}

		public static float RandomSign()
		{
			return UnityEngine.Random.Range(0, 2) * 2 - 1;
		}

		public static string GetHelpUrl(object forClass)
		{
			if (forClass != null)
			{
				return GetHelpUrl(forClass.GetType());
			}
			return string.Empty;
		}

		public static string GetHelpUrl(Type classType)
		{
			if (classType != null)
			{
				object[] customAttributes = classType.GetCustomAttributes(typeof(HelpURLAttribute), inherit: true);
				if (customAttributes.Length != 0)
				{
					return ((HelpURLAttribute)customAttributes[0]).URL;
				}
			}
			return string.Empty;
		}

		public static Vector3 GetCenterPosition(Vector3 fallback, params Vector3[] vectors)
		{
			if (vectors.Length == 0)
			{
				return fallback;
			}
			Vector3 vector = vectors[0];
			for (int i = 1; i < vectors.Length; i++)
			{
				vector += vectors[i];
			}
			return vector / vectors.Length;
		}

		public static T CreateGameObject<T>(Transform parent, string name) where T : MonoBehaviour
		{
			GameObject gameObject = new GameObject(name);
			gameObject.transform.parent = parent;
			gameObject.transform.localPosition = Vector3.zero;
			gameObject.transform.localRotation = Quaternion.identity;
			return gameObject.AddComponent<T>();
		}
	}
	public static class DTTime
	{
		private static float _EditorDeltaTime;

		private static float _EditorLastTime;

		public static double TimeSinceStartup => Time.timeSinceLevelLoad;

		public static float deltaTime
		{
			get
			{
				if (!Application.isPlaying)
				{
					return _EditorDeltaTime;
				}
				return Time.deltaTime;
			}
		}

		public static void InitializeEditorTime()
		{
			_EditorLastTime = Time.realtimeSinceStartup;
			_EditorDeltaTime = 0f;
		}

		public static void UpdateEditorTime()
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			_EditorDeltaTime = realtimeSinceStartup - _EditorLastTime;
			_EditorLastTime = realtimeSinceStartup;
		}
	}
	public class TimeMeasure : Ring<long>
	{
		public Stopwatch mWatch = new Stopwatch();

		public double LastTicks => base[base.Count - 1];

		public double LastMS => LastTicks / 10000.0;

		public double AverageMS
		{
			get
			{
				long num = 0L;
				for (int i = 0; i < base.Count; i++)
				{
					num += base[i];
				}
				return DTMath.FixNaN((double)num / 10000.0 / (double)base.Count);
			}
		}

		public double MinimumMS
		{
			get
			{
				long num = long.MaxValue;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Min(num, base[i]);
				}
				return DTMath.FixNaN((double)num / 10000.0);
			}
		}

		public double MaximumMS
		{
			get
			{
				long num = long.MinValue;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Max(num, base[i]);
				}
				return DTMath.FixNaN((double)num / 10000.0);
			}
		}

		public double AverageTicks
		{
			get
			{
				long num = 0L;
				for (int i = 0; i < base.Count; i++)
				{
					num += base[i];
				}
				return (double)num / (double)base.Count;
			}
		}

		public double MinimumTicks
		{
			get
			{
				long num = long.MaxValue;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Min(num, base[i]);
				}
				return num;
			}
		}

		public double MaximumTicks
		{
			get
			{
				long num = 0L;
				for (int i = 0; i < base.Count; i++)
				{
					num = Math.Max(num, base[i]);
				}
				return num;
			}
		}

		public TimeMeasure(int size)
			: base(size)
		{
		}

		public void Start()
		{
			mWatch.Start();
		}

		public void Stop()
		{
			mWatch.Stop();
			Add(mWatch.ElapsedTicks);
			mWatch.Reset();
		}

		public void Pause()
		{
			mWatch.Stop();
		}
	}
	public static class DTMath
	{
		public static Vector3 ParallelTransportFrame(Vector3 up, Vector3 tan0, Vector3 tan1)
		{
			Vector3 axis = Vector3.Cross(tan0, tan1);
			if (tan0 == -tan1)
			{
				UnityEngine.Debug.LogWarning("[DevTools] ParallelTransportFrame's result is undefined for cases where tan0 == -tan1");
			}
			float num = Mathf.Atan2(axis.magnitude, Vector3.Dot(tan0, tan1));
			return Quaternion.AngleAxis(57.29578f * num, axis) * up;
		}

		public static Vector3 LeftTan(ref Vector3 tan, ref Vector3 up)
		{
			return Vector3.Cross(tan, up);
		}

		public static Vector3 RightTan(ref Vector3 tan, ref Vector3 up)
		{
			return Vector3.Cross(up, tan);
		}

		public static float Repeat(float t, float length)
		{
			if (t != length)
			{
				return t - Mathf.Floor(t / length) * length;
			}
			return t;
		}

		public static double FixNaN(double v)
		{
			if (double.IsNaN(v))
			{
				v = 0.0;
			}
			return v;
		}

		public static float FixNaN(float v)
		{
			if (float.IsNaN(v))
			{
				v = 0f;
			}
			return v;
		}

		public static Vector2 FixNaN(Vector2 v)
		{
			if (float.IsNaN(v.x))
			{
				v.x = 0f;
			}
			if (float.IsNaN(v.y))
			{
				v.y = 0f;
			}
			return v;
		}

		public static Vector3 FixNaN(Vector3 v)
		{
			if (float.IsNaN(v.x))
			{
				v.x = 0f;
			}
			if (float.IsNaN(v.y))
			{
				v.y = 0f;
			}
			if (float.IsNaN(v.z))
			{
				v.z = 0f;
			}
			return v;
		}

		public static float MapValue(float min, float max, float value, float vMin = -1f, float vMax = 1f)
		{
			return min + (max - min) * (value - vMin) / (vMax - vMin);
		}

		public static float SnapPrecision(float value, int decimals)
		{
			if (decimals < 0)
			{
				return value;
			}
			return (float)Math.Round(value, decimals);
		}

		public static Vector2 SnapPrecision(Vector2 value, int decimals)
		{
			if (decimals < 0)
			{
				return value;
			}
			value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals));
			return value;
		}

		public static Vector3 SnapPrecision(Vector3 value, int decimals)
		{
			if (decimals < 0)
			{
				return value;
			}
			value.Set(SnapPrecision(value.x, decimals), SnapPrecision(value.y, decimals), SnapPrecision(value.z, decimals));
			return value;
		}

		public static float LinePointDistanceSqr(Vector3 l1, Vector3 l2, Vector3 p, out float frag)
		{
			Vector3 vector = l2 - l1;
			float num = Vector3.Dot(p - l1, vector);
			if (num <= 0f)
			{
				frag = 0f;
				return (p - l1).sqrMagnitude;
			}
			float num2 = Vector3.Dot(vector, vector);
			if (num2 <= num)
			{
				frag = 1f;
				return (p - l2).sqrMagnitude;
			}
			frag = num / num2;
			Vector3 vector2 = l1 + frag * vector;
			return (p - vector2).sqrMagnitude;
		}

		public static bool RayLineSegmentIntersection(Vector2 r0, Vector2 dir, Vector2 l1, Vector2 l2, out Vector2 hit, out float frag)
		{
			Vector2 vector = l2 - l1;
			frag = ((0f - dir.y) * (r0.x - l1.x) + dir.x * (r0.y - l1.y)) / ((0f - vector.x) * dir.y + dir.x * vector.y);
			float num = (vector.x * (r0.y - l1.y) - vector.y * (r0.x - l1.x)) / ((0f - vector.x) * dir.y + dir.x * vector.y);
			if (frag >= 0f && frag <= 1f && num > 0f)
			{
				hit = new Vector2(r0.x + num * dir.x, r0.y + num * dir.y);
				return true;
			}
			hit = Vector2.zero;
			return false;
		}

		public static bool ShortestIntersectionLine(Vector3 line1A, Vector3 line1B, Vector3 line2A, Vector3 line2B, out Vector3 resultSegmentA, out Vector3 resultSegmentB)
		{
			resultSegmentA = Vector3.zero;
			resultSegmentB = Vector3.zero;
			Vector3 vector = line1A;
			Vector3 vector2 = line2A;
			Vector3 vector3 = vector - vector2;
			Vector3 vector4 = line2B - vector2;
			if (vector4.sqrMagnitude < Mathf.Epsilon)
			{
				return false;
			}
			Vector3 vector5 = line1B - vector;
			if (vector5.sqrMagnitude < Mathf.Epsilon)
			{
				return false;
			}
			double num = (double)vector3.x * (double)vector4.x + (double)vector3.y * (double)vector4.y + (double)vector3.z * (double)vector4.z;
			double num2 = (double)vector4.x * (double)vector5.x + (double)vector4.y * (double)vector5.y + (double)vector4.z * (double)vector5.z;
			double num3 = (double)vector3.x * (double)vector5.x + (double)vector3.y * (double)vector5.y + (double)vector3.z * (double)vector5.z;
			double num4 = (double)vector4.x * (double)vector4.x + (double)vector4.y * (double)vector4.y + (double)vector4.z * (double)vector4.z;
			double num5 = ((double)vector5.x * (double)vector5.x + (double)vector5.y * (double)vector5.y + (double)vector5.z * (double)vector5.z) * num4 - num2 * num2;
			if (Math.Abs(num5) < double.Epsilon)
			{
				return false;
			}
			double num6 = (num * num2 - num3 * num4) / num5;
			double num7 = (num + num2 * num6) / num4;
			resultSegmentA = new Vector3((float)((double)vector.x + num6 * (double)vector5.x), (float)((double)vector.y + num6 * (double)vector5.y), (float)((double)vector.z + num6 * (double)vector5.z));
			resultSegmentB = new Vector3((float)((double)vector2.x + num7 * (double)vector4.x), (float)((double)vector2.y + num7 * (double)vector4.y), (float)((double)vector2.z + num7 * (double)vector4.z));
			return true;
		}

		public static bool LineLineIntersection(Vector3 line1A, Vector3 line1B, Vector3 line2A, Vector3 line2B, out Vector3 hitPoint)
		{
			if (ShortestIntersectionLine(line1A, line1B, line2A, line2B, out hitPoint, out var resultSegmentB) && (resultSegmentB - hitPoint).sqrMagnitude <= Mathf.Epsilon * Mathf.Epsilon)
			{
				return true;
			}
			return false;
		}

		public static bool LineLineIntersect(Vector2 line1A, Vector2 line1B, Vector2 line2A, Vector2 line2B, out Vector2 hitPoint, bool segmentOnly = true)
		{
			hitPoint = Vector2.zero;
			double num = (line2B.y - line2A.y) * (line1B.x - line1A.x) - (line2B.x - line2A.x) * (line1B.y - line1A.y);
			double num2 = (line2B.x - line2A.x) * (line1A.y - line2A.y) - (line2B.y - line2A.y) * (line1A.x - line2A.x);
			double num3 = (line1B.x - line1A.x) * (line1A.y - line2A.y) - (line1B.y - line1A.y) * (line1A.x - line2A.x);
			if (num == 0.0)
			{
				return false;
			}
			double num4 = num2 / num;
			double num5 = num3 / num;
			if (!segmentOnly || (num4 >= 0.0 && num4 <= 1.0 && num5 >= 0.0 && num5 <= 1.0))
			{
				hitPoint.Set((float)((double)line1A.x + num4 * (double)(line1B.x - line1A.x)), (float)((double)line1A.y + num4 * (double)(line1B.y - line1A.y)));
				return true;
			}
			return false;
		}

		public static bool PointInsideTriangle(Vector3 A, Vector3 B, Vector3 C, Vector3 p, out float ac, out float ab, bool edgesAllowed)
		{
			Vector3 vector = C - A;
			Vector3 vector2 = B - A;
			Vector3 rhs = p - A;
			float num = Vector3.Dot(vector, vector);
			float num2 = Vector3.Dot(vector, vector2);
			float num3 = Vector3.Dot(vector, rhs);
			float num4 = Vector3.Dot(vector2, vector2);
			float num5 = Vector3.Dot(vector2, rhs);
			float num6 = 1f / (num * num4 - num2 * num2);
			ac = (num4 * num3 - num2 * num5) * num6;
			ab = (num * num5 - num2 * num3) * num6;
			if (edgesAllowed)
			{
				if (ac >= 0f && ab >= 0f)
				{
					return ac + ab < 1f;
				}
				return false;
			}
			if (ac > 0f && ab > 0f)
			{
				return ac + ab < 1f;
			}
			return false;
		}
	}
	public class UnityEventEx<T0> : UnityEvent<T0>
	{
		private object mCallerList;

		private MethodInfo mCallsCount;

		private int mCount = -1;

		public void AddListenerOnce(UnityAction<T0> call)
		{
			RemoveListener(call);
			AddListener(call);
			CheckForListeners();
		}

		public bool HasListeners()
		{
			if (mCallsCount == null)
			{
				FieldInfo fieldInfo = typeof(UnityEventBase).FieldByName("m_Calls", includeInherited: false, includePrivate: true);
				if (fieldInfo != null)
				{
					mCallerList = fieldInfo.GetValue(this);
					if (mCallerList != null)
					{
						mCallsCount = mCallerList.GetType().PropertyByName("Count").GetGetMethod();
					}
				}
			}
			if (mCount == -1)
			{
				if (mCallerList != null && mCallsCount != null)
				{
					mCount = (int)mCallsCount.Invoke(mCallerList, null);
				}
				mCount += GetPersistentEventCount();
			}
			return mCount > 0;
		}

		public void CheckForListeners()
		{
			mCount = -1;
		}
	}
	public static class DTLog
	{
		public static void Log(object message)
		{
			UnityEngine.Debug.Log(message);
		}

		public static void Log(object message, UnityEngine.Object context)
		{
			UnityEngine.Debug.Log(message, context);
		}

		public static void LogError(object message)
		{
			UnityEngine.Debug.LogError(message);
		}

		public static void LogError(object message, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogError(message, context);
		}

		public static void LogErrorFormat(string format, params object[] args)
		{
			UnityEngine.Debug.LogErrorFormat(format, args);
		}

		public static void LogErrorFormat(UnityEngine.Object context, string format, params object[] args)
		{
			UnityEngine.Debug.LogErrorFormat(context, format, args);
		}

		public static void LogException(Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}

		public static void LogException(Exception exception, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogException(exception, context);
		}

		public static void LogFormat(string format, params object[] args)
		{
			UnityEngine.Debug.LogFormat(format, args);
		}

		public static void LogFormat(UnityEngine.Object context, string format, params object[] args)
		{
			UnityEngine.Debug.LogFormat(context, format, args);
		}

		public static void LogWarning(object message)
		{
			UnityEngine.Debug.LogWarning(message);
		}

		public static void LogWarning(object message, UnityEngine.Object context)
		{
			UnityEngine.Debug.LogWarning(message, context);
		}

		public static void LogWarningFormat(string format, params object[] args)
		{
			UnityEngine.Debug.LogWarningFormat(format, args);
		}

		public static void LogWarningFormat(UnityEngine.Object context, string format, params object[] args)
		{
			UnityEngine.Debug.LogWarningFormat(context, format, args);
		}
	}
	[Serializable]
	public struct FloatRegion : IEquatable<FloatRegion>
	{
		public float From;

		public float To;

		public bool SimpleValue;

		public static FloatRegion ZeroOne => new FloatRegion(0f, 1f);

		public bool Positive => From <= To;

		public float Low
		{
			get
			{
				if (!Positive)
				{
					return To;
				}
				return From;
			}
			set
			{
				if (Positive)
				{
					From = value;
				}
				else
				{
					To = value;
				}
			}
		}

		public float High
		{
			get
			{
				if (!Positive)
				{
					return From;
				}
				return To;
			}
			set
			{
				if (Positive)
				{
					To = value;
				}
				else
				{
					From = value;
				}
			}
		}

		public float Random => UnityEngine.Random.Range(From, To);

		public float Next
		{
			get
			{
				if (SimpleValue)
				{
					return From;
				}
				return Random;
			}
		}

		public float Length => To - From;

		public float LengthPositive
		{
			get
			{
				if (!Positive)
				{
					return From - To;
				}
				return To - From;
			}
		}

		public FloatRegion(float value)
		{
			From = value;
			To = value;
			SimpleValue = true;
		}

		public FloatRegion(float A, float B)
		{
			From = A;
			To = B;
			SimpleValue = false;
		}

		public void MakePositive()
		{
			if (To < From)
			{
				float to = To;
				To = From;
				From = to;
			}
		}

		public void Clamp(float low, float high)
		{
			Low = Mathf.Clamp(Low, low, high);
			High = Mathf.Clamp(High, low, high);
		}

		public override string ToString()
		{
			return $"({From:F2}-{To:F2})";
		}

		public override int GetHashCode()
		{
			return From.GetHashCode() ^ (To.GetHashCode() << 2);
		}

		public bool Equals(FloatRegion other)
		{
			if (From.Equals(other.From))
			{
				return To.Equals(other.To);
			}
			return false;
		}

		public override bool Equals(object other)
		{
			if (!(other is FloatRegion floatRegion))
			{
				return false;
			}
			if (From.Equals(floatRegion.From))
			{
				return To.Equals(floatRegion.To);
			}
			return false;
		}

		public static FloatRegion operator +(FloatRegion a, FloatRegion b)
		{
			return new FloatRegion(a.From + b.From, a.To + b.To);
		}

		public static FloatRegion operator -(FloatRegion a, FloatRegion b)
		{
			return new FloatRegion(a.From - b.From, a.To - b.To);
		}

		public static FloatRegion operator -(FloatRegion a)
		{
			return new FloatRegion(0f - a.From, 0f - a.To);
		}

		public static FloatRegion operator *(FloatRegion a, float v)
		{
			return new FloatRegion(a.From * v, a.To * v);
		}

		public static FloatRegion operator *(float v, FloatRegion a)
		{
			return new FloatRegion(a.From * v, a.To * v);
		}

		public static FloatRegion operator /(FloatRegion a, float v)
		{
			return new FloatRegion(a.From / v, a.To / v);
		}

		public static bool operator ==(FloatRegion lhs, FloatRegion rhs)
		{
			if (lhs.SimpleValue == rhs.SimpleValue && Mathf.Approximately(lhs.From, rhs.From))
			{
				return Mathf.Approximately(lhs.To, rhs.To);
			}
			return false;
		}

		public static bool operator !=(FloatRegion lhs, FloatRegion rhs)
		{
			if (lhs.SimpleValue == rhs.SimpleValue && Mathf.Approximately(lhs.From, rhs.From))
			{
				return !Mathf.Approximately(lhs.To, rhs.To);
			}
			return true;
		}
	}
	[Serializable]
	public struct IntRegion : IEquatable<IntRegion>
	{
		public int From;

		public int To;

		public bool SimpleValue;

		public static IntRegion ZeroOne => new IntRegion(0, 1);

		public bool Positive => From <= To;

		public int Low
		{
			get
			{
				if (!Positive)
				{
					return To;
				}
				return From;
			}
			set
			{
				if (Positive)
				{
					From = value;
				}
				else
				{
					To = value;
				}
			}
		}

		public int High
		{
			get
			{
				if (!Positive)
				{
					return From;
				}
				return To;
			}
			set
			{
				if (Positive)
				{
					To = value;
				}
				else
				{
					From = value;
				}
			}
		}

		public int Random => UnityEngine.Random.Range(From, To);

		public int Length => To - From;

		public int LengthPositive
		{
			get
			{
				if (!Positive)
				{
					return From - To;
				}
				return To - From;
			}
		}

		public IntRegion(int value)
		{
			From = value;
			To = value;
			SimpleValue = true;
		}

		public IntRegion(int A, int B)
		{
			From = A;
			To = B;
			SimpleValue = false;
		}

		public void MakePositive()
		{
			if (To < From)
			{
				int to = To;
				To = From;
				From = to;
			}
		}

		public void Clamp(int low, int high)
		{
			Low = Mathf.Clamp(Low, low, high);
			High = Mathf.Clamp(High, low, high);
		}

		public override string ToString()
		{
			return $"({From}-{To})";
		}

		public override int GetHashCode()
		{
			return From.GetHashCode() ^ (To.GetHashCode() << 2);
		}

		public bool Equals(IntRegion other)
		{
			if (From.Equals(other.From))
			{
				return To.Equals(other.To);
			}
			return false;
		}

		public override bool Equals(object other)
		{
			if (!(other is IntRegion intRegion))
			{
				return false;
			}
			if (From.Equals(intRegion.From))
			{
				return To.Equals(intRegion.To);
			}
			return false;
		}

		public static IntRegion operator +(IntRegion a, IntRegion b)
		{
			return new IntRegion(a.From + b.From, a.To + b.To);
		}

		public static IntRegion operator -(IntRegion a, IntRegion b)
		{
			return new IntRegion(a.From - b.From, a.To - b.To);
		}

		public static IntRegion operator -(IntRegion a)
		{
			return new IntRegion(-a.From, -a.To);
		}

		public static IntRegion operator *(IntRegion a, int v)
		{
			return new IntRegion(a.From * v, a.To * v);
		}

		public static IntRegion operator *(int v, IntRegion a)
		{
			return new IntRegion(a.From * v, a.To * v);
		}

		public static IntRegion operator /(IntRegion a, int v)
		{
			return new IntRegion(a.From / v, a.To / v);
		}

		public static bool operator ==(IntRegion lhs, IntRegion rhs)
		{
			if (lhs.From == rhs.From && lhs.To == rhs.To)
			{
				return lhs.SimpleValue != rhs.SimpleValue;
			}
			return false;
		}

		public static bool operator !=(IntRegion lhs, IntRegion rhs)
		{
			if (lhs.From == rhs.From && lhs.To == rhs.To)
			{
				return lhs.SimpleValue != rhs.SimpleValue;
			}
			return true;
		}
	}
	public class WeightedRandom<T>
	{
		private List<T> mData;

		private int mCurrentPosition = -1;

		private T mCurrentItem;

		public int Seed { get; set; }

		public bool RandomizeSeed { get; set; }

		private int Capacity => mData.Capacity;

		public int Size => mData.Count;

		public WeightedRandom(int initCapacity = 0)
		{
			mData = new List<T>(initCapacity);
		}

		public WeightedRandom(int initCapacity, int seed)
			: this(initCapacity)
		{
			Seed = seed;
		}

		public void Add(T item, int amount)
		{
			for (int i = 0; i < amount; i++)
			{
				mData.Add(item);
			}
			mCurrentPosition = Size - 1;
		}

		public T Next()
		{
			if (mCurrentPosition < 1)
			{
				mCurrentPosition = Size - 1;
				mCurrentItem = mData[0];
				return mCurrentItem;
			}
			UnityEngine.Random.State state = UnityEngine.Random.state;
			if (RandomizeSeed)
			{
				Seed = UnityEngine.Random.Range(0, int.MaxValue);
			}
			UnityEngine.Random.InitState(Seed);
			int index = UnityEngine.Random.Range(0, mCurrentPosition);
			UnityEngine.Random.state = state;
			mCurrentItem = mData[index];
			mData[index] = mData[mCurrentPosition];
			mData[mCurrentPosition] = mCurrentItem;
			mCurrentPosition--;
			return mCurrentItem;
		}

		public void Reset()
		{
			mCurrentPosition = Size - 1;
		}

		public void Clear()
		{
			mData.Clear();
			mCurrentPosition = -1;
		}
	}
	public class Ring<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		private List<T> mList;

		private int mIndex;

		public int Size { get; private set; }

		public T this[int index]
		{
			get
			{
				return mList[index];
			}
			set
			{
				mList[index] = value;
			}
		}

		public int Count => mList.Count;

		public bool IsReadOnly
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public Ring(int size)
		{
			mList = new List<T>(size);
			Size = size;
		}

		public void Add(T item)
		{
			if (mList.Count == Size)
			{
				mList[mIndex++] = item;
				if (mIndex == mList.Count)
				{
					mIndex = 0;
				}
			}
			else
			{
				mList.Add(item);
			}
		}

		public void Clear()
		{
			mList.Clear();
			mIndex = 0;
		}

		public int IndexOf(T item)
		{
			return mList.IndexOf(item);
		}

		public void Insert(int index, T item)
		{
			throw new NotSupportedException();
		}

		public void RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		public IEnumerator GetEnumerator()
		{
			return mList.GetEnumerator();
		}

		public bool Contains(T item)
		{
			return mList.Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			mList.CopyTo(array, arrayIndex);
		}

		public bool Remove(T item)
		{
			return mList.Remove(item);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			throw new NotImplementedException();
		}
	}
	public class Pool<T> : IPool
	{
		private List<T> mObjects = new List<T>();

		private double mLastTime;

		private double mDeltaTime;

		public string Identifier { get; set; }

		public PoolSettings Settings { get; protected set; }

		public Type Type => typeof(T);

		public int Count => mObjects.Count;

		public Pool(PoolSettings settings = null)
		{
			Settings = settings ?? new PoolSettings();
			Identifier = typeof(T).FullName;
			mLastTime = DTTime.TimeSinceStartup + (double)UnityEngine.Random.Range(0f, Settings.Speed);
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		public void Update()
		{
			mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
			mLastTime = DTTime.TimeSinceStartup;
			if (Settings.Speed > 0f)
			{
				int num = (int)(mDeltaTime / (double)Settings.Speed);
				mDeltaTime -= num;
				if (Count > Settings.Threshold)
				{
					num = Mathf.Min(num, Count - Settings.Threshold);
					while (num-- > 0)
					{
						destroy(mObjects[0]);
						mObjects.RemoveAt(0);
						log("Threshold exceeded: Deleting item");
					}
				}
				else if (Count < Settings.MinItems)
				{
					num = Mathf.Min(num, Settings.MinItems - Count);
					while (num-- > 0)
					{
						mObjects.Add(create());
						log("Below MinItems: Adding item");
					}
				}
			}
			else
			{
				mDeltaTime = 0.0;
			}
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				while (Count < Settings.MinItems)
				{
					mObjects.Add(create());
				}
				while (Count > Settings.Threshold)
				{
					destroy(mObjects[0]);
					mObjects.RemoveAt(0);
				}
				log("Prewarm/Reset");
			}
		}

		public void Clear()
		{
			log("Clear");
			for (int i = 0; i < Count; i++)
			{
				destroy(mObjects[i]);
			}
			mObjects.Clear();
		}

		public virtual T Pop(Transform parent = null)
		{
			T val = default(T);
			if (Count > 0)
			{
				val = mObjects[0];
				mObjects.RemoveAt(0);
			}
			else if (Settings.AutoCreate || !Application.isPlaying)
			{
				log("Auto create item");
				val = create();
			}
			if (val != null)
			{
				sendAfterPop(val);
				setParent(val, parent);
				log("Pop " + val);
			}
			return val;
		}

		public virtual void Push(T item)
		{
			log("Push " + item);
			if (Application.isPlaying && item != null)
			{
				sendBeforePush(item);
				mObjects.Add(item);
			}
		}

		protected virtual void sendBeforePush(T item)
		{
			if (item is IPoolable)
			{
				((IPoolable)(object)item).OnBeforePush();
			}
		}

		protected virtual void sendAfterPop(T item)
		{
			if (item is IPoolable)
			{
				((IPoolable)(object)item).OnAfterPop();
			}
		}

		protected virtual void setParent(T item, Transform parent)
		{
		}

		protected virtual T create()
		{
			return Activator.CreateInstance<T>();
		}

		protected virtual void destroy(T item)
		{
		}

		private void log(string msg)
		{
			if (Settings.Debug)
			{
				UnityEngine.Debug.Log($"[{Identifier}] ({Count} items) {msg}");
			}
		}
	}
	[Serializable]
	public class PoolSettings
	{
		[SerializeField]
		private bool m_Prewarm;

		[SerializeField]
		private bool m_AutoCreate = true;

		[SerializeField]
		private bool m_AutoEnableDisable = true;

		[Positive]
		[SerializeField]
		private int m_MinItems;

		[Positive]
		[SerializeField]
		private int m_Threshold;

		[Positive]
		[SerializeField]
		private float m_Speed = 1f;

		public bool Debug;

		public bool Prewarm
		{
			get
			{
				return m_Prewarm;
			}
			set
			{
				if (m_Prewarm != value)
				{
					m_Prewarm = value;
				}
			}
		}

		public bool AutoCreate
		{
			get
			{
				return m_AutoCreate;
			}
			set
			{
				if (m_AutoCreate != value)
				{
					m_AutoCreate = value;
				}
			}
		}

		public bool AutoEnableDisable
		{
			get
			{
				return m_AutoEnableDisable;
			}
			set
			{
				if (m_AutoEnableDisable != value)
				{
					m_AutoEnableDisable = value;
				}
			}
		}

		public int MinItems
		{
			get
			{
				return m_MinItems;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_MinItems != num)
				{
					m_MinItems = num;
				}
			}
		}

		public int Threshold
		{
			get
			{
				return m_Threshold;
			}
			set
			{
				int num = Mathf.Max(MinItems, value);
				if (m_Threshold != num)
				{
					m_Threshold = num;
				}
			}
		}

		public float Speed
		{
			get
			{
				return m_Speed;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Speed != num)
				{
					m_Speed = num;
				}
			}
		}

		public PoolSettings()
		{
		}

		public PoolSettings(PoolSettings src)
		{
			Prewarm = src.Prewarm;
			AutoCreate = src.AutoCreate;
			MinItems = src.MinItems;
			Threshold = src.Threshold;
			Speed = src.Speed;
			Debug = src.Debug;
		}

		public void OnValidate()
		{
			MinItems = m_MinItems;
			Threshold = m_Threshold;
			Speed = m_Speed;
		}
	}
	public interface IPool
	{
		string Identifier { get; set; }

		PoolSettings Settings { get; }

		int Count { get; }

		void Clear();

		void Reset();

		void Update();
	}
	public interface IPoolable
	{
		void OnBeforePush();

		void OnAfterPop();
	}
	public enum DTMessageType
	{
		None,
		Info,
		Warning,
		Error
	}
	public enum AttributeOptionsFlags
	{
		None = 0,
		Compact = 1,
		Clipboard = 128,
		Zero = 256,
		One = 512,
		Negate = 1024,
		Full = 1920,
		FullCompact = 1921
	}
	public class DTPropertyAttribute : PropertyAttribute
	{
		public string Label;

		public string Tooltip;

		public string Color;

		public AttributeOptionsFlags Options;

		public int Precision = -1;

		public DTPropertyAttribute(string label = "", string tooltip = "")
		{
			Label = label;
			Tooltip = tooltip;
		}
	}
	public class LabelAttribute : DTPropertyAttribute
	{
		public LabelAttribute()
		{
		}

		public LabelAttribute(string label, string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class ToggleButtonAttribute : DTPropertyAttribute
	{
		public ToggleButtonAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class LayerAttribute : DTPropertyAttribute
	{
		public LayerAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class TagAttribute : DTPropertyAttribute
	{
		public TagAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class VectorExAttribute : DTPropertyAttribute
	{
		public VectorExAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			Options = AttributeOptionsFlags.Full;
		}
	}
	public class AnimationCurveExAttribute : DTPropertyAttribute
	{
		public AnimationCurveExAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			Options = AttributeOptionsFlags.Clipboard;
		}
	}
	public class MinAttribute : DTPropertyAttribute
	{
		public float MinValue;

		public string MinFieldOrPropertyName;

		public MinAttribute(float value, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinValue = value;
		}

		public MinAttribute(string fieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinFieldOrPropertyName = fieldOrProperty;
		}
	}
	public class PositiveAttribute : MinAttribute
	{
		public PositiveAttribute()
			: base(0f)
		{
		}
	}
	public class MaxAttribute : DTPropertyAttribute
	{
		public float MaxValue;

		public string MaxFieldOrPropertyName;

		public MaxAttribute(float value, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MaxValue = value;
		}

		public MaxAttribute(string fieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MaxFieldOrPropertyName = fieldOrProperty;
		}
	}
	public class RangeExAttribute : DTPropertyAttribute
	{
		public float MinValue;

		public string MinFieldOrPropertyName;

		public float MaxValue;

		public string MaxFieldOrPropertyName;

		public bool Slider = true;

		public RangeExAttribute(float minValue, float maxValue, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinValue = minValue;
			MaxValue = maxValue;
		}

		public RangeExAttribute(string minFieldOrProperty, float maxValue, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinFieldOrPropertyName = minFieldOrProperty;
			MaxValue = maxValue;
		}

		public RangeExAttribute(float minValue, string maxFieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinValue = minValue;
			MaxFieldOrPropertyName = maxFieldOrProperty;
		}

		public RangeExAttribute(string minFieldOrProperty, string maxFieldOrProperty, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MinFieldOrPropertyName = minFieldOrProperty;
			MaxFieldOrPropertyName = maxFieldOrProperty;
		}
	}
	public class MinMaxAttribute : DTPropertyAttribute
	{
		public readonly string MaxValueField;

		public float Min;

		public string MinBoundFieldOrPropertyName;

		public float Max;

		public string MaxBoundFieldOrPropertyName;

		public MinMaxAttribute(string maxValueField, string label = "", string tooltip = "")
			: base(label, tooltip)
		{
			MaxValueField = maxValueField;
			Min = 0f;
			Max = 1f;
		}
	}
	public class EnumFlagAttribute : DTPropertyAttribute
	{
		public EnumFlagAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class ObjectSelectorAttribute : DTPropertyAttribute
	{
		public ObjectSelectorAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class PathSelectorAttribute : DTPropertyAttribute
	{
		public enum DialogMode
		{
			OpenFile,
			OpenFolder,
			CreateFile
		}

		public readonly DialogMode Mode;

		public string Title;

		public string Directory;

		public string Extension;

		public string DefaultName;

		public PathSelectorAttribute(DialogMode mode = DialogMode.OpenFile)
		{
			Mode = mode;
			Directory = Application.dataPath;
		}
	}
	public class EnumSelectionGridAttribute : DTPropertyAttribute
	{
		public EnumSelectionGridAttribute(string label = "", string tooltip = "")
			: base(label, tooltip)
		{
		}
	}
	public class DTRegionAttribute : DTPropertyAttribute
	{
		public bool RegionIsOptional;

		public string RegionOptionsPropertyName;

		public bool UseSlider = true;
	}
	public class FloatRegionAttribute : DTRegionAttribute
	{
	}
	public class IntRegionAttribute : DTRegionAttribute
	{
	}
	public struct RegionOptions<T>
	{
		public string LabelFrom;

		public string LabelTo;

		public string OptionalTooltip;

		public DTValueClamping ClampFrom;

		public DTValueClamping ClampTo;

		public T FromMin;

		public T FromMax;

		public T ToMin;

		public T ToMax;

		public static RegionOptions<T> Default
		{
			get
			{
				RegionOptions<T> result = default(RegionOptions<T>);
				result.OptionalTooltip = "Range";
				result.LabelFrom = "From";
				result.LabelTo = "To";
				result.ClampFrom = DTValueClamping.None;
				result.ClampTo = DTValueClamping.None;
				return result;
			}
		}

		public static RegionOptions<T> MinMax(T min, T max)
		{
			RegionOptions<T> result = default(RegionOptions<T>);
			result.LabelFrom = "From";
			result.LabelTo = "To";
			result.ClampFrom = DTValueClamping.Range;
			result.ClampTo = DTValueClamping.Range;
			result.FromMin = min;
			result.FromMax = max;
			result.ToMin = min;
			result.ToMax = max;
			return result;
		}
	}
	public enum DTValueClamping
	{
		None,
		Min,
		Max,
		Range
	}
	public class ThreadPoolWorker<T> : IDisposable
	{
		private readonly SimplePool<QueuedCallback> queuedCallbackPool = new SimplePool<QueuedCallback>(4);

		private readonly SimplePool<LoopState<T>> loopStatePool = new SimplePool<LoopState<T>>(4);

		private int _remainingWorkItems = 1;

		private ManualResetEvent _done = new ManualResetEvent(initialState: false);

		private WaitCallback handleWorkItemCallBack;

		private WaitCallback handleLoopCallBack;

		public ThreadPoolWorker()
		{
			handleWorkItemCallBack = delegate(object o)
			{
				QueuedCallback queuedCallback = (QueuedCallback)o;
				try
				{
					queuedCallback.Callback(queuedCallback.State);
				}
				finally
				{
					lock (queuedCallbackPool)
					{
						queuedCallbackPool.ReleaseItem(queuedCallback);
					}
					DoneWorkItem();
				}
			};
			handleLoopCallBack = delegate(object state)
			{
				LoopState<T> loopState = (LoopState<T>)state;
				for (int i = loopState.StartIndex; i <= loopState.EndIndex; i++)
				{
					loopState.Action(loopState.Items[i]);
				}
				lock (loopStatePool)
				{
					loopStatePool.ReleaseItem(loopState);
				}
			};
		}

		public void ParralelFor(Action<T> action, List<T> list)
		{
			int val = Environment.ProcessorCount - 1;
			int num = 1 + Math.Min(val, Environment.ProcessorCount - 1);
			int count = list.Count;
			int num2 = ((num == 1) ? count : ((int)Math.Ceiling((float)count / (float)num)));
			int num3 = 0;
			while (num3 < count)
			{
				int num4 = Math.Min(num3 + num2 - 1, count - 1);
				if (num4 == count - 1)
				{
					for (int i = num3; i <= num4; i++)
					{
						action(list[i]);
					}
				}
				else
				{
					QueuedCallback item;
					lock (queuedCallbackPool)
					{
						item = queuedCallbackPool.GetItem();
					}
					LoopState<T> item2;
					lock (loopStatePool)
					{
						item2 = loopStatePool.GetItem();
					}
					item2.StartIndex = (short)num3;
					item2.EndIndex = (short)num4;
					item2.Action = action;
					item2.Items = list;
					item.State = item2;
					item.Callback = handleLoopCallBack;
					ThrowIfDisposed();
					lock (_done)
					{
						_remainingWorkItems++;
					}
					ThreadPool.QueueUserWorkItem(handleWorkItemCallBack, item);
				}
				num3 = num4 + 1;
			}
			WaitAll(-1, exitContext: false);
		}

		private bool WaitAll(int millisecondsTimeout, bool exitContext)
		{
			ThrowIfDisposed();
			DoneWorkItem();
			bool flag = _done.WaitOne(millisecondsTimeout, exitContext);
			lock (_done)
			{
				if (flag)
				{
					_remainingWorkItems = 1;
					_done.Reset();
				}
				else
				{
					_remainingWorkItems++;
				}
			}
			return flag;
		}

		private void ThrowIfDisposed()
		{
			if (_done == null)
			{
				throw new ObjectDisposedException(GetType().Name);
			}
		}

		private void DoneWorkItem()
		{
			lock (_done)
			{
				_remainingWorkItems--;
				if (_remainingWorkItems == 0)
				{
					_done.Set();
				}
			}
		}

		public void Dispose()
		{
			if (_done != null)
			{
				((IDisposable)_done).Dispose();
				_done = null;
			}
		}
	}
	internal class SimplePool<T> where T : new()
	{
		private readonly List<T> freeItemsBackfield;

		public SimplePool(int preCreatedElementsCount)
		{
			freeItemsBackfield = new List<T>();
			for (int i = 0; i < preCreatedElementsCount; i++)
			{
				freeItemsBackfield.Add(new T());
			}
		}

		public T GetItem()
		{
			T result;
			if (freeItemsBackfield.Count == 0)
			{
				result = new T();
			}
			else
			{
				int index = freeItemsBackfield.Count - 1;
				result = freeItemsBackfield[index];
				freeItemsBackfield.RemoveAt(index);
			}
			return result;
		}

		public void ReleaseItem(T item)
		{
			freeItemsBackfield.Add(item);
		}
	}
	internal class QueuedCallback
	{
		public WaitCallback Callback;

		public object State;
	}
	internal class LoopState<T>
	{
		public short StartIndex;

		public short EndIndex;

		public List<T> Items;

		public Action<T> Action;
	}
	public class ThreadPoolWorker : IDisposable
	{
		private int _remainingWorkItems = 1;

		private ManualResetEvent _done = new ManualResetEvent(initialState: false);

		public void QueueWorkItem(WaitCallback callback)
		{
			QueueWorkItem(callback, null);
		}

		public void QueueWorkItem(Action act)
		{
			QueueWorkItem(act, null);
		}

		public void ParralelFor<T>(Action<T> action, List<T> list)
		{
			int val = Environment.ProcessorCount - 1;
			int num = 1 + Math.Min(val, Environment.ProcessorCount - 1);
			int count = list.Count;
			if (num == 1 || count == 1)
			{
				for (int i = 0; i < count; i++)
				{
					action(list[i]);
				}
				return;
			}
			int num2 = (int)Math.Ceiling((float)count / (float)num);
			int num3 = 0;
			while (num3 < count)
			{
				QueuedCallback queuedCallback = new QueuedCallback();
				int num4 = Math.Min(num3 + num2, count - 1);
				LoopState<T> loopState = new LoopState<T>();
				loopState.StartIndex = (short)num3;
				loopState.EndIndex = (short)num4;
				loopState.Action = action;
				loopState.Items = list;
				queuedCallback.State = loopState;
				queuedCallback.Callback = delegate(object state)
				{
					LoopState<T> loopState2 = (LoopState<T>)state;
					for (int j = loopState2.StartIndex; j <= loopState2.EndIndex; j++)
					{
						loopState2.Action(loopState2.Items[j]);
					}
				};
				QueueWorkItem(queuedCallback);
				num3 = num4 + 1;
			}
		}

		private void QueueWorkItem(QueuedCallback callback)
		{
			ThrowIfDisposed();
			lock (_done)
			{
				_remainingWorkItems++;
			}
			ThreadPool.QueueUserWorkItem(HandleWorkItem, callback);
		}

		public void QueueWorkItem(WaitCallback callback, object state)
		{
			QueuedCallback queuedCallback = new QueuedCallback();
			queuedCallback.Callback = callback;
			queuedCallback.State = state;
			QueueWorkItem(queuedCallback);
		}

		public void QueueWorkItem(Action act, object state)
		{
			QueuedCallback queuedCallback = new QueuedCallback();
			queuedCallback.Callback = delegate
			{
				act();
			};
			queuedCallback.State = state;
			QueueWorkItem(queuedCallback);
		}

		public bool WaitAll()
		{
			return WaitAll(-1, exitContext: false);
		}

		public bool WaitAll(TimeSpan timeout, bool exitContext)
		{
			return WaitAll((int)timeout.TotalMilliseconds, exitContext);
		}

		public bool WaitAll(int millisecondsTimeout, bool exitContext)
		{
			ThrowIfDisposed();
			DoneWorkItem();
			bool flag = _done.WaitOne(millisecondsTimeout, exitContext);
			lock (_done)
			{
				if (flag)
				{
					_remainingWorkItems = 1;
					_done.Reset();
				}
				else
				{
					_remainingWorkItems++;
				}
			}
			return flag;
		}

		private void HandleWorkItem(object state)
		{
			QueuedCallback queuedCallback = (QueuedCallback)state;
			try
			{
				queuedCallback.Callback(queuedCallback.State);
			}
			finally
			{
				DoneWorkItem();
			}
		}

		private void DoneWorkItem()
		{
			lock (_done)
			{
				_remainingWorkItems--;
				if (_remainingWorkItems == 0)
				{
					_done.Set();
				}
			}
		}

		private void ThrowIfDisposed()
		{
			if (_done == null)
			{
				throw new ObjectDisposedException(GetType().Name);
			}
		}

		public void Dispose()
		{
			if (_done != null)
			{
				((IDisposable)_done).Dispose();
				_done = null;
			}
		}
	}
	[HelpURL("https://curvyeditor.com/doclink/dtcomponentpool")]
	public class ComponentPool : MonoBehaviour, IPool, ISerializationCallbackReceiver
	{
		[SerializeField]
		[HideInInspector]
		private string m_Identifier;

		[Inline]
		[SerializeField]
		private PoolSettings m_Settings;

		private PoolManager mManager;

		private List<UnityEngine.Component> mObjects = new List<UnityEngine.Component>();

		private double mLastTime;

		private double mDeltaTime;

		public PoolSettings Settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				if (m_Settings != value)
				{
					m_Settings = value;
				}
				if (m_Settings != null)
				{
					m_Settings.OnValidate();
				}
			}
		}

		public PoolManager Manager
		{
			get
			{
				if (mManager == null)
				{
					mManager = GetComponent<PoolManager>();
				}
				return mManager;
			}
		}

		public string Identifier
		{
			get
			{
				return m_Identifier;
			}
			set
			{
				throw new InvalidOperationException("Component pool's identifier should always indicate the pooled type's assembly qualified name");
			}
		}

		public Type Type
		{
			get
			{
				Type type = null;
				if (Identifier != null)
				{
					type = Type.GetType(Identifier);
				}
				if (type == null)
				{
					DTLog.LogWarning("[DevTools] ComponentPool's Type is an unknown type " + m_Identifier);
				}
				return type;
			}
		}

		public int Count => mObjects.Count;

		public void Initialize(Type type, PoolSettings settings)
		{
			m_Identifier = type.AssemblyQualifiedName;
			m_Settings = settings;
			mLastTime = DTTime.TimeSinceStartup + (double)UnityEngine.Random.Range(0f, Settings.Speed);
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		private void Start()
		{
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		private void OnEnable()
		{
			SceneManager.sceneLoaded += OnSceneLoaded;
		}

		private void OnDisable()
		{
		}

		public void Update()
		{
			if (!Application.isPlaying)
			{
				return;
			}
			mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
			mLastTime = DTTime.TimeSinceStartup;
			if (Settings.Speed > 0f)
			{
				int num = (int)(mDeltaTime / (double)Settings.Speed);
				mDeltaTime -= num;
				if (Count > Settings.Threshold)
				{
					num = Mathf.Min(num, Count - Settings.Threshold);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Threshold exceeded: Deleting item");
						}
						destroy(mObjects[0]);
						mObjects.RemoveAt(0);
					}
				}
				else
				{
					if (Count >= Settings.MinItems)
					{
						return;
					}
					num = Mathf.Min(num, Settings.MinItems - Count);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Below MinItems: Adding item");
						}
						mObjects.Add(create());
					}
				}
			}
			else
			{
				mDeltaTime = 0.0;
			}
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				while (Count < Settings.MinItems)
				{
					mObjects.Add(create());
				}
				while (Count > Settings.Threshold)
				{
					destroy(mObjects[0]);
					mObjects.RemoveAt(0);
				}
				if (Settings.Debug)
				{
					log("Prewarm/Reset");
				}
			}
		}

		public void OnSceneLoaded(Scene scn, LoadSceneMode mode)
		{
			for (int num = mObjects.Count - 1; num >= 0; num--)
			{
				if (mObjects[num] == null)
				{
					mObjects.RemoveAt(num);
				}
			}
		}

		public void Clear()
		{
			if (Settings.Debug)
			{
				log("Clear");
			}
			for (int i = 0; i < Count; i++)
			{
				destroy(mObjects[i]);
			}
			mObjects.Clear();
		}

		public void Push(UnityEngine.Component item)
		{
			sendBeforePush(item);
			if (item != null)
			{
				mObjects.Add(item);
				item.transform.parent = Manager.transform;
				item.gameObject.hideFlags = (Settings.Debug ? HideFlags.DontSave : HideFlags.HideAndDontSave);
				if (Settings.AutoEnableDisable)
				{
					item.gameObject.SetActive(value: false);
				}
			}
		}

		public UnityEngine.Component Pop(Transform parent = null)
		{
			UnityEngine.Component component = null;
			if (Count > 0)
			{
				component = mObjects[0];
				mObjects.RemoveAt(0);
			}
			else if (Settings.AutoCreate || !Application.isPlaying)
			{
				if (Settings.Debug)
				{
					log("Auto create item");
				}
				component = create();
			}
			if ((bool)component)
			{
				component.gameObject.hideFlags = HideFlags.None;
				component.transform.parent = parent;
				if (Settings.AutoEnableDisable)
				{
					component.gameObject.SetActive(value: true);
				}
				sendAfterPop(component);
				if (Settings.Debug)
				{
					log("Pop " + component);
				}
			}
			return component;
		}

		public T Pop<T>(Transform parent) where T : UnityEngine.Component
		{
			return Pop(parent) as T;
		}

		private UnityEngine.Component create()
		{
			GameObject gameObject = new GameObject();
			gameObject.name = Identifier;
			gameObject.transform.parent = Manager.transform;
			if (Settings.AutoEnableDisable)
			{
				gameObject.SetActive(value: false);
			}
			Type type = Type;
			UnityEngine.Component result = null;
			if (type != null)
			{
				result = gameObject.AddComponent(type);
			}
			else
			{
				DTLog.LogError($"[DevTools] ComponentPool {m_Identifier} could not create component because the associated type is null");
			}
			return result;
		}

		private void destroy(UnityEngine.Component item)
		{
			if (item != null)
			{
				UnityEngine.Object.Destroy(item.gameObject);
			}
		}

		private void setParent(UnityEngine.Component item, Transform parent)
		{
			if (item != null)
			{
				item.transform.parent = parent;
			}
		}

		private void sendAfterPop(UnityEngine.Component item)
		{
			GameObject gameObject = item.gameObject;
			if (gameObject.activeSelf && gameObject.activeInHierarchy)
			{
				gameObject.SendMessage("OnAfterPop", SendMessageOptions.DontRequireReceiver);
			}
			else if (item is IPoolable)
			{
				((IPoolable)item).OnAfterPop();
			}
			else
			{
				DTLog.LogWarning("[Curvy] sendAfterPop could not send message because the receiver " + item.name + " is not active");
			}
		}

		private void sendBeforePush(UnityEngine.Component item)
		{
			GameObject gameObject = item.gameObject;
			if (gameObject.activeSelf && gameObject.activeInHierarchy)
			{
				gameObject.SendMessage("OnBeforePush", SendMessageOptions.DontRequireReceiver);
			}
			else if (item is IPoolable)
			{
				((IPoolable)item).OnBeforePush();
			}
			else
			{
				DTLog.LogWarning("[Curvy] sendBeforePush could not send message because the receiver " + item.name + " is not active");
			}
		}

		private void log(string msg)
		{
			UnityEngine.Debug.Log($"[{Identifier}] ({Count} items) {msg}");
		}

		public void OnBeforeSerialize()
		{
		}

		public void OnAfterDeserialize()
		{
			if (!(Type.GetType(m_Identifier) == null))
			{
				return;
			}
			string[] array = m_Identifier.Split(',');
			if (array.Length >= 5)
			{
				string typeName = string.Join(",", array.SubArray(0, array.Length - 4));
				Type type = TypeExt.GetLoadedTypes().FirstOrDefault((Type t) => t.FullName == typeName);
				if (type != null)
				{
					m_Identifier = type.AssemblyQualifiedName;
				}
			}
		}
	}
	public class DTSingleton<T> : MonoBehaviour, IDTSingleton where T : MonoBehaviour, IDTSingleton
	{
		private static T _instance;

		private static object _lock = new object();

		private static bool applicationIsQuitting = false;

		private bool isDuplicateInstance;

		public static bool HasInstance => _instance != null;

		public static T Instance
		{
			get
			{
				if (!Application.isPlaying)
				{
					applicationIsQuitting = false;
				}
				if (applicationIsQuitting)
				{
					return null;
				}
				if (_instance == null)
				{
					lock (_lock)
					{
						if (_instance == null)
						{
							IEnumerable<UnityEngine.Object> source = from o in UnityEngine.Object.FindObjectsOfType(typeof(T))
								where o != null
								select o;
							_instance = (source.Any() ? ((T)source.ElementAt(0)) : new GameObject().AddComponent<T>());
						}
					}
				}
				return _instance;
			}
		}

		public virtual void Awake()
		{
			T instance = Instance;
			lock (_lock)
			{
				if (instance == null)
				{
					DTLog.LogError("[DevTools] DTSingleton instance was null. This happens if the instance is destroyed by the user, which is not a supported operation. If you did not destroy the singleton's instance, then please fill a bug report.");
				}
				else if (GetInstanceID() != instance.GetInstanceID())
				{
					instance.MergeDoubleLoaded(this);
					isDuplicateInstance = true;
					Invoke("DestroySelf", 0f);
				}
			}
		}

		protected virtual void OnDestroy()
		{
			lock (_lock)
			{
				if (Application.isPlaying && !isDuplicateInstance)
				{
					applicationIsQuitting = true;
					_instance = null;
				}
			}
		}

		public virtual void MergeDoubleLoaded(IDTSingleton newInstance)
		{
		}

		private void DestroySelf()
		{
			UnityEngine.Object.Destroy(base.gameObject);
		}
	}
	public interface IDTSingleton
	{
		void MergeDoubleLoaded(IDTSingleton newInstance);
	}
	public abstract class DTVersionedMonoBehaviour : MonoBehaviour
	{
		[SerializeField]
		[HideInInspector]
		private string m_Version;

		public string Version
		{
			get
			{
				return m_Version;
			}
			protected set
			{
				m_Version = value;
			}
		}

		public void Destroy()
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(base.gameObject);
			}
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(MeshFilter))]
	public abstract class DuplicateEditorMesh : MonoBehaviour
	{
		private MeshFilter mFilter;

		public MeshFilter Filter
		{
			get
			{
				if (mFilter == null)
				{
					mFilter = GetComponent<MeshFilter>();
				}
				return mFilter;
			}
		}

		protected virtual void Awake()
		{
			if (Application.isPlaying)
			{
				return;
			}
			MeshFilter filter = Filter;
			if (!filter || !(filter.sharedMesh != null))
			{
				return;
			}
			DuplicateEditorMesh[] array = UnityEngine.Object.FindObjectsOfType<DuplicateEditorMesh>();
			foreach (DuplicateEditorMesh duplicateEditorMesh in array)
			{
				if (duplicateEditorMesh != this)
				{
					MeshFilter filter2 = duplicateEditorMesh.Filter;
					if ((bool)filter2 && filter2.sharedMesh == filter.sharedMesh)
					{
						Mesh mesh = new Mesh();
						mesh.name = filter2.sharedMesh.name;
						filter.mesh = mesh;
					}
				}
			}
		}
	}
	[HelpURL("https://curvyeditor.com/doclink/dtinspectornode")]
	public class InspectorNote : MonoBehaviour
	{
		[TextArea(5, 20)]
		[SerializeField]
		private string m_Note;
	}
	[HelpURL("https://curvyeditor.com/doclink/dtpoolmanager")]
	[ExecuteInEditMode]
	[DisallowMultipleComponent]
	public class PoolManager : MonoBehaviour
	{
		[Section("General", true, false, 100)]
		[SerializeField]
		private bool m_AutoCreatePools = true;

		[AsGroup(null, Expanded = false)]
		[SerializeField]
		private PoolSettings m_DefaultSettings = new PoolSettings();

		public Dictionary<string, IPool> Pools = new Dictionary<string, IPool>();

		public Dictionary<Type, IPool> TypePools = new Dictionary<Type, IPool>();

		private IPool[] mPools = new IPool[0];

		public bool AutoCreatePools
		{
			get
			{
				return m_AutoCreatePools;
			}
			set
			{
				if (m_AutoCreatePools != value)
				{
					m_AutoCreatePools = value;
				}
			}
		}

		public PoolSettings DefaultSettings
		{
			get
			{
				return m_DefaultSettings;
			}
			set
			{
				if (m_DefaultSettings != value)
				{
					m_DefaultSettings = value;
				}
				if (m_DefaultSettings != null)
				{
					m_DefaultSettings.OnValidate();
				}
			}
		}

		public bool IsInitialized { get; private set; }

		public int Count => Pools.Count + TypePools.Count;

		private void OnDisable()
		{
			IsInitialized = false;
		}

		private void Update()
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			if (mPools.Length != TypePools.Count)
			{
				Array.Resize(ref mPools, TypePools.Count);
				TypePools.Values.CopyTo(mPools, 0);
			}
			for (int i = 0; i < mPools.Length; i++)
			{
				mPools[i].Update();
			}
		}

		private void Initialize()
		{
			Pools.Clear();
			IPool[] components = GetComponents<IPool>();
			foreach (IPool pool in components)
			{
				if (pool is ComponentPool)
				{
					if (!Pools.ContainsKey(pool.Identifier))
					{
						Pools.Add(pool.Identifier, pool);
						continue;
					}
					DTLog.Log("[DevTools] Found a duplicated ComponentPool for type " + pool.Identifier + ". The duplicated pool will be destroyed");
					UnityEngine.Object.Destroy(pool as ComponentPool);
				}
				else
				{
					pool.Identifier = GetUniqueIdentifier(pool.Identifier);
					Pools.Add(pool.Identifier, pool);
				}
			}
			IsInitialized = true;
		}

		public string GetUniqueIdentifier(string ident)
		{
			int num = 0;
			string text = ident;
			while (Pools.ContainsKey(text))
			{
				int num2 = ++num;
				text = ident + num2;
			}
			return text;
		}

		public Pool<T> GetTypePool<T>()
		{
			IPool value = null;
			if (!TypePools.TryGetValue(typeof(T), out value) && AutoCreatePools)
			{
				value = CreateTypePool<T>();
			}
			return (Pool<T>)value;
		}

		public ComponentPool GetComponentPool<T>() where T : UnityEngine.Component
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			IPool value = null;
			if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out value) && AutoCreatePools)
			{
				value = CreateComponentPool<T>();
			}
			return (ComponentPool)value;
		}

		public PrefabPool GetPrefabPool(string identifier, params GameObject[] prefabs)
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			if (!Pools.TryGetValue(identifier, out var value) && AutoCreatePools)
			{
				value = CreatePrefabPool(identifier, null, prefabs);
			}
			return (PrefabPool)value;
		}

		public Pool<T> CreateTypePool<T>(PoolSettings settings = null)
		{
			PoolSettings settings2 = settings ?? new PoolSettings(DefaultSettings);
			IPool value = null;
			if (!TypePools.TryGetValue(typeof(T), out value))
			{
				value = new Pool<T>(settings2);
				TypePools.Add(typeof(T), value);
			}
			return (Pool<T>)value;
		}

		public ComponentPool CreateComponentPool<T>(PoolSettings settings = null) where T : UnityEngine.Component
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			PoolSettings settings2 = settings ?? new PoolSettings(DefaultSettings);
			IPool value = null;
			if (!Pools.TryGetValue(typeof(T).AssemblyQualifiedName, out value))
			{
				value = base.gameObject.AddComponent<ComponentPool>();
				((ComponentPool)value).Initialize(typeof(T), settings2);
				Pools.Add(value.Identifier, value);
			}
			return (ComponentPool)value;
		}

		public PrefabPool CreatePrefabPool(string name, PoolSettings settings = null, params GameObject[] prefabs)
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			PoolSettings settings2 = settings ?? new PoolSettings(DefaultSettings);
			IPool value = null;
			if (!Pools.TryGetValue(name, out value))
			{
				PrefabPool prefabPool = base.gameObject.AddComponent<PrefabPool>();
				prefabPool.Initialize(name, settings2, prefabs);
				Pools.Add(name, prefabPool);
				return prefabPool;
			}
			return (PrefabPool)value;
		}

		public List<IPool> FindPools(string identifierStartsWith)
		{
			List<IPool> list = new List<IPool>();
			foreach (KeyValuePair<string, IPool> pool in Pools)
			{
				if (pool.Key.StartsWith(identifierStartsWith))
				{
					list.Add(pool.Value);
				}
			}
			return list;
		}

		public void DeletePools(string startsWith)
		{
			List<IPool> list = FindPools(startsWith);
			for (int num = list.Count - 1; num >= 0; num--)
			{
				DeletePool(list[num]);
			}
		}

		public void DeletePool(IPool pool)
		{
			if (pool is PrefabPool || pool is ComponentPool)
			{
				UnityEngine.Object.Destroy((MonoBehaviour)pool);
				Pools.Remove(pool.Identifier);
			}
		}

		public void DeletePool<T>()
		{
			TypePools.Remove(typeof(T));
		}
	}
	[RequireComponent(typeof(PoolManager))]
	[HelpURL("https://curvyeditor.com/doclink/dtprefabpool")]
	public class PrefabPool : MonoBehaviour, IPool
	{
		[FieldCondition("m_Identifier", "", false, ActionAttribute.ActionEnum.ShowWarning, "Please enter an identifier! (Select a prefab to set automatically)", ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private string m_Identifier;

		[SerializeField]
		private List<GameObject> m_Prefabs = new List<GameObject>();

		[Inline]
		[SerializeField]
		private PoolSettings m_Settings;

		private PoolManager mManager;

		private List<GameObject> mObjects = new List<GameObject>();

		private double mLastTime;

		private double mDeltaTime;

		public string Identifier
		{
			get
			{
				return m_Identifier;
			}
			set
			{
				if (m_Identifier != value)
				{
					string ident = value;
					if (string.IsNullOrEmpty(m_Identifier))
					{
						ident = Manager.GetUniqueIdentifier(ident);
					}
					m_Identifier = value;
				}
			}
		}

		public List<GameObject> Prefabs
		{
			get
			{
				return m_Prefabs;
			}
			set
			{
				if (m_Prefabs != value)
				{
					m_Prefabs = value;
				}
			}
		}

		public PoolSettings Settings
		{
			get
			{
				return m_Settings;
			}
			set
			{
				if (m_Settings != value)
				{
					m_Settings = value;
				}
				if (m_Settings != null)
				{
					m_Settings.OnValidate();
				}
			}
		}

		public PoolManager Manager
		{
			get
			{
				if (mManager == null)
				{
					mManager = GetComponent<PoolManager>();
				}
				return mManager;
			}
		}

		public int Count => mObjects.Count;

		private void Awake()
		{
		}

		private void Start()
		{
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		public void Initialize(string ident, PoolSettings settings, params GameObject[] prefabs)
		{
			Identifier = ident;
			m_Settings = settings;
			Prefabs = new List<GameObject>(prefabs);
			mLastTime = DTTime.TimeSinceStartup + (double)UnityEngine.Random.Range(0f, Settings.Speed);
			if (Settings.Prewarm)
			{
				Reset();
			}
		}

		public void Update()
		{
			if (!Application.isPlaying)
			{
				return;
			}
			mDeltaTime += DTTime.TimeSinceStartup - mLastTime;
			mLastTime = DTTime.TimeSinceStartup;
			if (Settings.Speed > 0f)
			{
				int num = (int)(mDeltaTime / (double)Settings.Speed);
				mDeltaTime -= num;
				if (Count > Settings.Threshold)
				{
					num = Mathf.Min(num, Count - Settings.Threshold);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Threshold exceeded: Deleting item");
						}
						destroy(mObjects[0]);
						mObjects.RemoveAt(0);
					}
				}
				else
				{
					if (Count >= Settings.MinItems)
					{
						return;
					}
					num = Mathf.Min(num, Settings.MinItems - Count);
					while (num-- > 0)
					{
						if (Settings.Debug)
						{
							log("Below MinItems: Adding item");
						}
						mObjects.Add(create());
					}
				}
			}
			else
			{
				mDeltaTime = 0.0;
			}
		}

		public void Reset()
		{
			if (Application.isPlaying)
			{
				while (Count < Settings.MinItems)
				{
					mObjects.Add(create());
				}
				while (Count > Settings.Threshold)
				{
					destroy(mObjects[0]);
					mObjects.RemoveAt(0);
				}
				if (Settings.Debug)
				{
					log("Prewarm/Reset");
				}
			}
		}

		public void Clear()
		{
			if (Settings.Debug)
			{
				log("Clear");
			}
			for (int i = 0; i < Count; i++)
			{
				destroy(mObjects[i]);
			}
			mObjects.Clear();
		}

		public GameObject Pop(Transform parent = null)
		{
			GameObject gameObject = null;
			if (Count > 0)
			{
				gameObject = mObjects[0];
				mObjects.RemoveAt(0);
			}
			else if (Settings.AutoCreate || !Application.isPlaying)
			{
				if (Settings.Debug)
				{
					log("Auto create item");
				}
				gameObject = create();
			}
			if ((bool)gameObject)
			{
				gameObject.gameObject.hideFlags = HideFlags.None;
				gameObject.transform.parent = parent;
				if (Settings.AutoEnableDisable)
				{
					gameObject.SetActive(value: true);
				}
				sendAfterPop(gameObject);
				if (Settings.Debug)
				{
					log("Pop " + gameObject);
				}
			}
			return gameObject;
		}

		public virtual void Push(GameObject item)
		{
			if (Settings.Debug)
			{
				log("Push " + item);
			}
			if (item != null)
			{
				sendBeforePush(item);
				mObjects.Add(item);
				item.transform.parent = base.transform;
				item.gameObject.hideFlags = (Settings.Debug ? HideFlags.DontSave : HideFlags.HideAndDontSave);
				if (Settings.AutoEnableDisable)
				{
					item.SetActive(value: false);
				}
			}
		}

		private GameObject create()
		{
			if (Prefabs.Count == 0)
			{
				throw new InvalidOperationException($"[Curvy] The Prefab Pool '{Identifier}' in game object '{base.gameObject.name}' could not create a pool element because its Prefabs list is empty");
			}
			GameObject gameObject = Prefabs[UnityEngine.Random.Range(0, Prefabs.Count)];
			GameObject gameObject2 = UnityEngine.Object.Instantiate(gameObject);
			gameObject2.name = gameObject.name;
			gameObject2.transform.parent = base.transform;
			if (Settings.AutoEnableDisable)
			{
				gameObject2.SetActive(value: false);
			}
			return gameObject2;
		}

		private void destroy(GameObject go)
		{
			UnityEngine.Object.Destroy(go);
		}

		private void log(string msg)
		{
			UnityEngine.Debug.Log($"[{Identifier}] ({Count} items) {msg}");
		}

		private void setParent(Transform item, Transform parent)
		{
			if (item != null)
			{
				item.parent = parent;
			}
		}

		private void sendAfterPop(GameObject item)
		{
			item.SendMessage("OnAfterPop", SendMessageOptions.DontRequireReceiver);
		}

		private void sendBeforePush(GameObject item)
		{
			item.SendMessage("OnBeforePush", SendMessageOptions.DontRequireReceiver);
		}
	}
}
namespace FluffyUnderware.DevTools.Extensions
{
	public static class ObjectExt
	{
		public static void Destroy(this UnityEngine.Object c)
		{
			UnityEngine.Object.Destroy(c);
		}

		public static string ToDumpString(this object o)
		{
			return new DTObjectDump(o).ToString();
		}
	}
	public static class Vector2Ext
	{
		public static Vector2 Snap(this Vector2 v, float snapX, float snapY = -1f)
		{
			if (snapY == -1f)
			{
				snapY = snapX;
			}
			return new Vector2(v.x - v.x % snapX, v.y - v.y % snapY);
		}

		public static float AngleSigned(this Vector2 a, Vector2 b)
		{
			float num = Mathf.Sign(a.x * b.y - a.y * b.x);
			return Vector2.Angle(a, b) * num;
		}

		public static Vector2 LeftNormal(this Vector2 v)
		{
			return new Vector2(0f - v.y, v.x);
		}

		public static Vector2 RightNormal(this Vector2 v)
		{
			return new Vector2(v.y, 0f - v.x);
		}

		public static Vector2 Rotate(this Vector2 v, float degree)
		{
			float f = degree * ((float)Math.PI / 180f);
			float num = Mathf.Cos(f);
			float num2 = Mathf.Sin(f);
			return new Vector2(num * v.x - num2 * v.y, num2 * v.x + num * v.y);
		}

		public static Vector2 ToVector3(this Vector2 v)
		{
			return new Vector3(v.x, v.y, 0f);
		}
	}
	public static class Vector3Ext
	{
		public static float AngleSigned(this Vector3 a, Vector3 b, Vector3 normal)
		{
			return Mathf.Atan2(Vector3.Dot(normal, Vector3.Cross(a, b)), Vector3.Dot(a, b)) * 57.29578f;
		}

		public static Vector3 RotateAround(this Vector3 point, Vector3 origin, Quaternion rotation)
		{
			Vector3 vector = point - origin;
			vector = rotation * vector;
			return origin + vector;
		}

		public static Vector2 ToVector2(this Vector3 v)
		{
			return new Vector2(v.x, v.y);
		}

		public static bool Approximately(this Vector3 v1, Vector3 v2)
		{
			Vector3 vector = v1;
			vector.x -= v2.x;
			vector.y -= v2.y;
			vector.z -= v2.z;
			return Vector3.SqrMagnitude(vector) < 1E-06f;
		}

		public static bool NotApproximately(this Vector3 v1, Vector3 v2)
		{
			return !v1.Approximately(v2);
		}
	}
	public static class QuaternionExt
	{
		public static bool SameOrientation(this Quaternion q1, Quaternion q2)
		{
			return Math.Abs((double)Quaternion.Dot(q1, q2)) > 0.999998986721039;
		}

		public static bool DifferentOrientation(this Quaternion q1, Quaternion q2)
		{
			return Math.Abs((double)Quaternion.Dot(q1, q2)) <= 0.999998986721039;
		}
	}
	public static class CameraExt
	{
		private static Plane[] camPlanes = new Plane[6];

		private static Vector3 camPos;

		private static Vector3 camForward;

		private static float fov;

		private static float screenW;

		private static float screenH;

		public static bool BoundsInView(this Camera c, Bounds bounds)
		{
			if (camPos != c.transform.position || camForward != c.transform.forward || screenW != (float)Screen.width || screenH != (float)Screen.height || fov != c.fieldOfView)
			{
				camPos = c.transform.position;
				camForward = c.transform.forward;
				screenW = Screen.width;
				screenH = Screen.height;
				fov = c.fieldOfView;
				GeometryUtility.CalculateFrustumPlanes(c, camPlanes);
			}
			return GeometryUtility.TestPlanesAABB(camPlanes, bounds);
		}

		public static bool BoundsPartiallyInView(this Camera c, Bounds bounds)
		{
			Plane[] planes = GeometryUtility.CalculateFrustumPlanes(c);
			Vector3 zero = Vector3.zero;
			Vector3 center = bounds.center;
			Vector3 extents = bounds.extents;
			zero.Set(center.x - extents.x, center.y + extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y + extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x - extents.x, center.y - extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y - extents.y, center.z - extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x - extents.x, center.y + extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y + extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x - extents.x, center.y - extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			zero.Set(center.x + extents.x, center.y - extents.y, center.z + extents.z);
			if (GeometryUtility.TestPlanesAABB(planes, new Bounds(zero, new Vector3(0.1f, 0.1f, 0.1f))))
			{
				return true;
			}
			return false;
		}
	}
	public static class GameObjectExt
	{
		public static GameObject DuplicateGameObject(this GameObject source, Transform newParent, bool keepPrefabReference = false)
		{
			if (!source)
			{
				return null;
			}
			GameObject gameObject = UnityEngine.Object.Instantiate(source.gameObject);
			if ((bool)gameObject)
			{
				gameObject.transform.parent = newParent;
			}
			return gameObject;
		}

		public static void StripComponents(this GameObject go, params Type[] toKeep)
		{
			List<Type> list = new List<Type>(toKeep);
			list.Add(typeof(Transform));
			list.Add(typeof(RectTransform));
			UnityEngine.Component[] components = go.GetComponents<UnityEngine.Component>();
			for (int i = 0; i < components.Length; i++)
			{
				if (!list.Contains(components[i].GetType()))
				{
					if (!Application.isPlaying)
					{
						UnityEngine.Object.DestroyImmediate(components[i]);
					}
					else
					{
						UnityEngine.Object.Destroy(components[i]);
					}
				}
			}
		}
	}
	public static class ComponentExt
	{
		public static void StripComponents(this UnityEngine.Component c, params Type[] toKeep)
		{
			if (toKeep.Length == 0)
			{
				c.gameObject.StripComponents(c.GetType());
			}
			else
			{
				c.gameObject.StripComponents(toKeep);
			}
		}

		public static GameObject AddChildGameObject(this UnityEngine.Component c, string name)
		{
			GameObject gameObject = new GameObject(name);
			gameObject.transform.SetParent(c.transform);
			return gameObject;
		}

		public static T AddChildGameObject<T>(this UnityEngine.Component c, string name) where T : UnityEngine.Component
		{
			GameObject gameObject = new GameObject(name);
			if ((bool)gameObject)
			{
				gameObject.transform.SetParent(c.transform);
				return gameObject.AddComponent<T>();
			}
			return null;
		}

		public static T DuplicateGameObject<T>(this UnityEngine.Component source, Transform newParent, bool keepPrefabConnection = false) where T : UnityEngine.Component
		{
			if (!source || !source.gameObject)
			{
				return null;
			}
			int num = new List<UnityEngine.Component>(source.gameObject.GetComponents<UnityEngine.Component>()).IndexOf(source);
			GameObject gameObject = UnityEngine.Object.Instantiate(source.gameObject);
			if ((bool)gameObject)
			{
				gameObject.transform.SetParent(newParent, worldPositionStays: false);
				return gameObject.GetComponents<UnityEngine.Component>()[num] as T;
			}
			return null;
		}

		public static UnityEngine.Component DuplicateGameObject(this UnityEngine.Component source, Transform newParent, bool keepPrefabConnection = false)
		{
			if (!source || !source.gameObject || !newParent)
			{
				return null;
			}
			int num = new List<UnityEngine.Component>(source.gameObject.GetComponents<UnityEngine.Component>()).IndexOf(source);
			GameObject gameObject = UnityEngine.Object.Instantiate(source.gameObject);
			if ((bool)gameObject)
			{
				gameObject.transform.SetParent(newParent, worldPositionStays: false);
				return gameObject.GetComponents<UnityEngine.Component>()[num];
			}
			return null;
		}
	}
	public static class ColorExt
	{
		public static string ToHtml(this Color c)
		{
			Color32 color = c;
			return $"#{color.r:X2}{color.g:X2}{color.b:X2}{color.a:X2}";
		}
	}
	public static class EnumExt
	{
		public static bool HasFlag(this Enum variable, params Enum[] flags)
		{
			if (flags.Length == 0)
			{
				throw new ArgumentNullException("flags");
			}
			int num = Convert.ToInt32(variable);
			Type type = variable.GetType();
			for (int i = 0; i < flags.Length; i++)
			{
				if (!Enum.IsDefined(type, flags[i]))
				{
					throw new ArgumentException($"Enumeration type mismatch.  The flag is of type '{flags[i].GetType()}', was expecting '{type}'.");
				}
				int num2 = Convert.ToInt32(flags[i]);
				if ((num & num2) == num2)
				{
					return true;
				}
			}
			return false;
		}

		public static bool HasFlag<T>(this T value, T flag) where T : struct
		{
			long num = Convert.ToInt64(value);
			long num2 = Convert.ToInt64(flag);
			return (num & num2) != 0;
		}

		public static T Set<T>(this Enum value, T append)
		{
			return value.Set(append, OnOff: true);
		}

		public static T Set<T>(this Enum value, T append, bool OnOff)
		{
			if (append == null)
			{
				throw new ArgumentNullException("append");
			}
			Type type = value.GetType();
			if (OnOff)
			{
				return (T)Enum.Parse(type, (Convert.ToUInt64(value) | Convert.ToUInt64(append)).ToString());
			}
			return (T)Enum.Parse(type, (Convert.ToUInt64(value) & ~Convert.ToUInt64(append)).ToString());
		}
	}
	public static class RectExt
	{
		public static Rect Set(this Rect rect, Vector2 pos, Vector2 size)
		{
			rect.Set(pos.x, pos.y, size.x, size.y);
			return new Rect(rect);
		}

		public static Rect SetBetween(this Rect rect, Vector2 pos, Vector2 pos2)
		{
			rect.Set(pos.x, pos.y, pos2.x - pos.x, pos2.y - pos.y);
			return new Rect(rect);
		}

		public static Rect SetPosition(this Rect rect, Vector2 pos)
		{
			rect.x = pos.x;
			rect.y = pos.y;
			return new Rect(rect);
		}

		public static Rect SetPosition(this Rect rect, float x, float y)
		{
			rect.x = x;
			rect.y = y;
			return new Rect(rect);
		}

		public static Vector2 GetSize(this Rect rect)
		{
			return new Vector2(rect.width, rect.height);
		}

		public static Rect SetSize(this Rect rect, Vector2 size)
		{
			rect.width = size.x;
			rect.height = size.y;
			return new Rect(rect);
		}

		public static Rect ScaleBy(this Rect rect, int pixel)
		{
			return rect.ScaleBy(pixel, pixel);
		}

		public static Rect ScaleBy(this Rect rect, int x, int y)
		{
			rect.x -= x;
			rect.y -= y;
			rect.width += (float)x * 2f;
			rect.height += (float)y * 2f;
			return new Rect(rect);
		}

		public static Rect ShiftBy(this Rect rect, int x, int y)
		{
			rect.x += x;
			rect.y += y;
			return new Rect(rect);
		}

		public static Rect Include(this Rect rect, Rect other)
		{
			Rect result = default(Rect);
			result.xMin = Mathf.Min(rect.xMin, other.xMin);
			result.xMax = Mathf.Max(rect.xMax, other.xMax);
			result.yMin = Mathf.Min(rect.yMin, other.yMin);
			result.yMax = Mathf.Max(rect.yMax, other.yMax);
			return result;
		}
	}
	public static class StringExt
	{
		public static Color ColorFromHtml(this string hexString)
		{
			if (hexString.Length < 9)
			{
				hexString += "FF";
			}
			if (hexString.StartsWith("#") && hexString.Length == 9)
			{
				int[] array = new int[4];
				try
				{
					array[0] = int.Parse(hexString.Substring(1, 2), NumberStyles.HexNumber);
					array[1] = int.Parse(hexString.Substring(3, 2), NumberStyles.HexNumber);
					array[2] = int.Parse(hexString.Substring(5, 2), NumberStyles.HexNumber);
					array[3] = int.Parse(hexString.Substring(7, 2), NumberStyles.HexNumber);
					return new Color((float)array[0] / 255f, (float)array[1] / 255f, (float)array[2] / 255f, (float)array[3] / 255f);
				}
				catch (Exception exception)
				{
					UnityEngine.Debug.LogException(exception);
					return Color.white;
				}
			}
			return Color.white;
		}

		public static string TrimStart(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
		{
			if (!s.StartsWith(trim, compare))
			{
				return s;
			}
			return s.Substring(trim.Length);
		}

		public static string TrimEnd(this string s, string trim, StringComparison compare = StringComparison.CurrentCultureIgnoreCase)
		{
			if (!s.EndsWith(trim, compare))
			{
				return s;
			}
			return s.Substring(0, s.Length - trim.Length);
		}
	}
	public static class IEnumerableExt
	{
		public static void ForEach<T>(this IEnumerable<T> ie, Action<T> action)
		{
			foreach (T item in ie)
			{
				action(item);
			}
		}
	}
	public static class ArrayExt
	{
		public static T[] SubArray<T>(this T[] data, int index, int length)
		{
			length = Mathf.Clamp(length, 0, data.Length - index);
			T[] array = new T[length];
			if (length > 0)
			{
				Array.Copy(data, index, array, 0, length);
			}
			return array;
		}

		public static T[] RemoveAt<T>(this T[] source, int index)
		{
			T[] array = new T[source.Length - 1];
			if (index > 0)
			{
				Array.Copy(source, 0, array, 0, index);
			}
			if (index < source.Length - 1)
			{
				Array.Copy(source, index + 1, array, index, source.Length - index - 1);
			}
			return array;
		}

		public static T[] InsertAt<T>(this T[] source, int index)
		{
			T[] array = new T[source.Length + 1];
			index = Mathf.Clamp(index, 0, source.Length - 1);
			if (index > 0)
			{
				Array.Copy(source, 0, array, 0, index);
			}
			Array.Copy(source, index, array, index + 1, source.Length - index);
			return array;
		}

		public static T[] Swap<T>(this T[] source, int index, int with)
		{
			index = Mathf.Clamp(index, 0, source.Length - 1);
			with = Mathf.Clamp(index, 0, source.Length - 1);
			T val = source[index];
			source[index] = source[with];
			source[with] = val;
			return source;
		}

		public static T[] Add<T>(this T[] source, T item)
		{
			Array.Resize(ref source, source.Length + 1);
			source[^1] = item;
			return source;
		}

		public static T[] AddRange<T>(this T[] source, T[] items)
		{
			Array.Resize(ref source, source.Length + items.Length);
			Array.Copy(items, 0, source, source.Length - items.Length, items.Length);
			return source;
		}

		public static T[] RemoveDuplicates<T>(this T[] source)
		{
			List<T> list = new List<T>();
			HashSet<T> hashSet = new HashSet<T>();
			foreach (T item in source)
			{
				if (hashSet.Add(item))
				{
					list.Add(item);
				}
			}
			return list.ToArray();
		}

		public static int IndexOf<T>(this T[] source, T item)
		{
			for (int i = 0; i < source.Length; i++)
			{
				if (source[i].Equals(item))
				{
					return i;
				}
			}
			return -1;
		}

		public static T[] Remove<T>(this T[] source, T item)
		{
			int num = source.IndexOf(item);
			if (num > -1)
			{
				return source.RemoveAt(num);
			}
			return source;
		}
	}
	public static class MeshFilterExt
	{
		public static Mesh PrepareNewShared(this MeshFilter m, string name = "Mesh")
		{
			if (m == null)
			{
				return null;
			}
			if (m.sharedMesh == null)
			{
				Mesh mesh = new Mesh();
				mesh.MarkDynamic();
				mesh.name = name;
				m.sharedMesh = mesh;
			}
			else
			{
				m.sharedMesh.Clear();
				m.sharedMesh.name = name;
				m.sharedMesh.subMeshCount = 0;
			}
			return m.sharedMesh;
		}

		public static void CalculateTangents(this MeshFilter m)
		{
			int[] triangles = m.sharedMesh.triangles;
			Vector3[] vertices = m.sharedMesh.vertices;
			Vector2[] uv = m.sharedMesh.uv;
			Vector3[] normals = m.sharedMesh.normals;
			if (uv.Length != 0)
			{
				int num = triangles.Length;
				int num2 = vertices.Length;
				Vector3[] array = new Vector3[num2];
				Vector3[] array2 = new Vector3[num2];
				Vector4[] array3 = new Vector4[num2];
				for (int i = 0; i < num; i += 3)
				{
					int num3 = triangles[i];
					int num4 = triangles[i + 1];
					int num5 = triangles[i + 2];
					Vector3 vector = vertices[num3];
					Vector3 vector2 = vertices[num4];
					Vector3 vector3 = vertices[num5];
					Vector2 vector4 = uv[num3];
					Vector2 vector5 = uv[num4];
					Vector2 vector6 = uv[num5];
					float num6 = vector2.x - vector.x;
					float num7 = vector3.x - vector.x;
					float num8 = vector2.y - vector.y;
					float num9 = vector3.y - vector.y;
					float num10 = vector2.z - vector.z;
					float num11 = vector3.z - vector.z;
					float num12 = vector5.x - vector4.x;
					float num13 = vector6.x - vector4.x;
					float num14 = vector5.y - vector4.y;
					float num15 = vector6.y - vector4.y;
					float num16 = num12 * num15 - num13 * num14;
					float num17 = ((num16 == 0f) ? 0f : (1f / num16));
					float num18 = (num15 * num6 - num14 * num7) * num17;
					float num19 = (num15 * num8 - num14 * num9) * num17;
					float num20 = (num15 * num10 - num14 * num11) * num17;
					float num21 = (num12 * num7 - num13 * num6) * num17;
					float num22 = (num12 * num9 - num13 * num8) * num17;
					float num23 = (num12 * num11 - num13 * num10) * num17;
					array[num3].x += num18;
					array[num3].y += num19;
					array[num3].z += num20;
					array[num4].x += num18;
					array[num4].y += num19;
					array[num4].z += num20;
					array[num5].x += num18;
					array[num5].y += num19;
					array[num5].z += num20;
					array2[num3].x += num21;
					array2[num3].y += num22;
					array2[num3].z += num23;
					array2[num4].x += num21;
					array2[num4].y += num22;
					array2[num4].z += num23;
					array2[num5].x += num21;
					array2[num5].y += num22;
					array2[num5].z += num23;
				}
				for (int j = 0; j < num2; j++)
				{
					Vector3 normal = normals[j];
					Vector3 tangent = array[j];
					Vector3.OrthoNormalize(ref normal, ref tangent);
					array3[j].x = tangent.x;
					array3[j].y = tangent.y;
					array3[j].z = tangent.z;
					float num24 = (normal.y * tangent.z - normal.z * tangent.y) * array2[j].x + (normal.z * tangent.x - normal.x * tangent.z) * array2[j].y + (normal.x * tangent.y - normal.y * tangent.x) * array2[j].z;
					array3[j].w = ((num24 < 0f) ? (-1f) : 1f);
				}
				m.sharedMesh.tangents = array3;
			}
		}
	}
	public static class TypeExt
	{
		public static Type[] GetLoadedTypes()
		{
			IEnumerable<Assembly> loadedAssemblies = GetLoadedAssemblies();
			List<Type> list = new List<Type>(loadedAssemblies.Count() * 100);
			foreach (Assembly item in loadedAssemblies)
			{
				try
				{
					list.AddRange(item.GetTypes());
				}
				catch (ReflectionTypeLoadException ex)
				{
					for (int i = 0; i < ex.Types.Length; i++)
					{
						Type type = ex.Types[i];
						if (type != null)
						{
							list.Add(type);
						}
					}
				}
			}
			return list.ToArray();
		}

		public static IEnumerable<Assembly> GetLoadedAssemblies()
		{
			return AppDomain.CurrentDomain.GetAssemblies();
		}

		public static Dictionary<U, Type> GetAllTypesWithAttribute<U>(this Type type)
		{
			Dictionary<U, Type> dictionary = new Dictionary<U, Type>();
			Type[] loadedTypes = GetLoadedTypes();
			foreach (Type type2 in loadedTypes)
			{
				if (type2.IsSubclassOf(type))
				{
					object[] customAttributes = type2.GetCustomAttributes(typeof(U), inherit: false);
					if (customAttributes.Length != 0)
					{
						dictionary.Add((U)customAttributes[0], type2);
					}
				}
			}
			return dictionary;
		}

		public static List<FieldInfo> GetFieldsWithAttribute<T>(this Type type, bool includeInherited = false, bool includePrivate = false) where T : Attribute
		{
			FieldInfo[] allFields = type.GetAllFields(includeInherited, includePrivate);
			List<FieldInfo> list = new List<FieldInfo>();
			FieldInfo[] array = allFields;
			foreach (FieldInfo fieldInfo in array)
			{
				if (fieldInfo.GetCustomAttribute<T>() != null)
				{
					list.Add(fieldInfo);
				}
			}
			return list;
		}

		public static T GetCustomAttribute<T>(this Type type) where T : Attribute
		{
			object[] customAttributes = type.GetCustomAttributes(typeof(T), inherit: true);
			if (customAttributes.Length == 0)
			{
				return null;
			}
			return (T)customAttributes[0];
		}

		public static MethodInfo MethodByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				return type.GetMethodIncludingBaseClasses(name, bindingFlags);
			}
			return type.GetMethod(name, bindingFlags);
		}

		public static FieldInfo FieldByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				return type.GetFieldIncludingBaseClasses(name, bindingFlags);
			}
			return type.GetField(name, bindingFlags);
		}

		public static PropertyInfo PropertyByName(this Type type, string name, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				return type.GetPropertyIncludingBaseClasses(name, bindingFlags);
			}
			return type.GetProperty(name, bindingFlags);
		}

		public static FieldInfo[] GetAllFields(this Type type, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				Type type2 = type;
				List<FieldInfo> list = new List<FieldInfo>();
				while (type2 != typeof(object))
				{
					list.AddRange(type2.GetFields(bindingFlags));
					type2 = type2.BaseType;
				}
				return list.ToArray();
			}
			return type.GetFields(bindingFlags);
		}

		public static PropertyInfo[] GetAllProperties(this Type type, bool includeInherited = false, bool includePrivate = false)
		{
			BindingFlags bindingFlags = BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public;
			if (includePrivate)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			if (includeInherited)
			{
				Type type2 = type;
				List<PropertyInfo> list = new List<PropertyInfo>();
				while (type2 != typeof(object))
				{
					list.AddRange(type2.GetProperties(bindingFlags));
					type2 = type2.BaseType;
				}
				return list.ToArray();
			}
			return type.GetProperties(bindingFlags);
		}

		public static bool IsFrameworkType(this Type type)
		{
			if (!type.IsPrimitive && !type.Equals(typeof(string)))
			{
				return type.Equals(typeof(DateTime));
			}
			return true;
		}

		public static bool IsArrayOrList(this Type type)
		{
			if (!type.IsArray)
			{
				if (type.IsGenericType)
				{
					return type.GetGenericTypeDefinition() == typeof(List<>);
				}
				return false;
			}
			return true;
		}

		public static Type GetEnumerableType(this Type t)
		{
			Type type = FindIEnumerable(t);
			if (type == null)
			{
				return t;
			}
			return type.GetGenericArguments()[0];
		}

		private static Type FindIEnumerable(Type seqType)
		{
			if (seqType == null || seqType == typeof(string))
			{
				return null;
			}
			if (seqType.IsArray)
			{
				return typeof(IEnumerable<>).MakeGenericType(seqType.GetElementType());
			}
			if (seqType.IsGenericType)
			{
				Type[] genericArguments = seqType.GetGenericArguments();
				foreach (Type type in genericArguments)
				{
					Type type2 = typeof(IEnumerable<>).MakeGenericType(type);
					if (type2.IsAssignableFrom(seqType))
					{
						return type2;
					}
				}
			}
			Type[] interfaces = seqType.GetInterfaces();
			if (interfaces != null && interfaces.Length != 0)
			{
				Type[] genericArguments = interfaces;
				for (int i = 0; i < genericArguments.Length; i++)
				{
					Type type3 = FindIEnumerable(genericArguments[i]);
					if (type3 != null)
					{
						return type3;
					}
				}
			}
			if (seqType.BaseType != null && seqType.BaseType != typeof(object))
			{
				return FindIEnumerable(seqType.BaseType);
			}
			return null;
		}

		private static MethodInfo GetMethodIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
		{
			MethodInfo method = type.GetMethod(name, bindingFlags);
			if (type.BaseType == typeof(object))
			{
				return method;
			}
			Type type2 = type;
			while (type2 != typeof(object))
			{
				method = type2.GetMethod(name, bindingFlags);
				if (method != null)
				{
					return method;
				}
				type2 = type2.BaseType;
			}
			return null;
		}

		private static FieldInfo GetFieldIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
		{
			FieldInfo field = type.GetField(name, bindingFlags);
			if (type.BaseType == typeof(object))
			{
				return field;
			}
			Type type2 = type;
			while (type2 != typeof(object))
			{
				field = type2.GetField(name, bindingFlags);
				if (field != null)
				{
					return field;
				}
				type2 = type2.BaseType;
			}
			return null;
		}

		private static PropertyInfo GetPropertyIncludingBaseClasses(this Type type, string name, BindingFlags bindingFlags)
		{
			PropertyInfo property = type.GetProperty(name, bindingFlags);
			if (type.BaseType == typeof(object))
			{
				return property;
			}
			Type type2 = type;
			while (type2 != typeof(object))
			{
				property = type2.GetProperty(name, bindingFlags);
				if (property != null)
				{
					return property;
				}
				type2 = type2.BaseType;
			}
			return null;
		}

		public static bool Matches(this Type type, params Type[] types)
		{
			foreach (Type type2 in types)
			{
				if (type == type2 || type.IsAssignableFrom(type2))
				{
					return true;
				}
			}
			return false;
		}
	}
	public static class FieldInfoExt
	{
		public static T GetCustomAttribute<T>(this FieldInfo field) where T : Attribute
		{
			object[] customAttributes = field.GetCustomAttributes(typeof(T), inherit: true);
			if (customAttributes.Length == 0)
			{
				return null;
			}
			return (T)customAttributes[0];
		}
	}
}
namespace FluffyUnderware.Curvy
{
	[HelpURL("https://curvyeditor.com/doclink/metacgoptions")]
	public class MetaCGOptions : CurvyMetadataBase
	{
		[Positive]
		[SerializeField]
		private int m_MaterialID;

		[SerializeField]
		private bool m_HardEdge;

		[Positive(Tooltip = "Max step distance when using optimization")]
		[SerializeField]
		private float m_MaxStepDistance;

		[Section("Extended UV", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/metacgoptions_extendeduv")]
		[FieldCondition("showUVEdge", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private bool m_UVEdge;

		[Positive]
		[FieldCondition("showExplicitU", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private bool m_ExplicitU;

		[FieldCondition("showFirstU", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[FieldAction("CBSetFirstU", ActionAttribute.ActionEnum.Callback)]
		[Positive]
		[SerializeField]
		private float m_FirstU;

		[FieldCondition("showSecondU", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Positive]
		[SerializeField]
		private float m_SecondU;

		public int MaterialID
		{
			get
			{
				return m_MaterialID;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_MaterialID != num)
				{
					m_MaterialID = num;
					NotifyModification();
				}
			}
		}

		public bool HardEdge
		{
			get
			{
				return m_HardEdge;
			}
			set
			{
				if (m_HardEdge != value)
				{
					m_HardEdge = value;
					NotifyModification();
				}
			}
		}

		public bool UVEdge
		{
			get
			{
				return m_UVEdge;
			}
			set
			{
				if (m_UVEdge != value)
				{
					m_UVEdge = value;
					NotifyModification();
				}
			}
		}

		public bool ExplicitU
		{
			get
			{
				return m_ExplicitU;
			}
			set
			{
				if (m_ExplicitU != value)
				{
					m_ExplicitU = value;
					NotifyModification();
				}
			}
		}

		public float FirstU
		{
			get
			{
				return m_FirstU;
			}
			set
			{
				if (m_FirstU != value)
				{
					m_FirstU = value;
					NotifyModification();
				}
			}
		}

		public float SecondU
		{
			get
			{
				return m_SecondU;
			}
			set
			{
				if (m_SecondU != value)
				{
					m_SecondU = value;
					NotifyModification();
				}
			}
		}

		public float MaxStepDistance
		{
			get
			{
				return m_MaxStepDistance;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_MaxStepDistance != num)
				{
					m_MaxStepDistance = num;
					NotifyModification();
				}
			}
		}

		public bool HasDifferentMaterial
		{
			get
			{
				MetaCGOptions previousData = GetPreviousData<MetaCGOptions>();
				if ((bool)previousData)
				{
					return previousData.MaterialID != MaterialID;
				}
				return false;
			}
		}

		private bool showUVEdge
		{
			get
			{
				if ((bool)base.ControlPoint && (base.Spline.Closed || (!(base.Spline.FirstVisibleControlPoint == base.ControlPoint) && !(base.Spline.LastVisibleControlPoint == base.ControlPoint))))
				{
					return !HasDifferentMaterial;
				}
				return false;
			}
		}

		private bool showExplicitU
		{
			get
			{
				if ((bool)base.ControlPoint && !UVEdge)
				{
					return !HasDifferentMaterial;
				}
				return false;
			}
		}

		private bool showFirstU
		{
			get
			{
				bool result = false;
				if ((bool)base.ControlPoint)
				{
					result = UVEdge || ExplicitU || HasDifferentMaterial;
				}
				return result;
			}
		}

		private bool showSecondU
		{
			get
			{
				if (!UVEdge)
				{
					return HasDifferentMaterial;
				}
				return true;
			}
		}

		public void Reset()
		{
			MaterialID = 0;
			HardEdge = false;
			MaxStepDistance = 0f;
			UVEdge = false;
			ExplicitU = false;
			FirstU = 0f;
			SecondU = 0f;
		}

		public float GetDefinedFirstU(float defaultValue)
		{
			if (!UVEdge && !ExplicitU && !HasDifferentMaterial)
			{
				return defaultValue;
			}
			return FirstU;
		}

		public float GetDefinedSecondU(float defaultValue)
		{
			if (!UVEdge && !HasDifferentMaterial)
			{
				return GetDefinedFirstU(defaultValue);
			}
			return SecondU;
		}
	}
	public enum OrientationModeEnum
	{
		None,
		Orientation,
		Tangent
	}
	public enum OrientationAxisEnum
	{
		Up,
		Down,
		Forward,
		Backward,
		Left,
		Right
	}
	public enum ConnectionHeadingEnum
	{
		Minus = -1,
		Sharp,
		Plus,
		Auto
	}
	public static class ConnectionHeadingEnumMethods
	{
		public static ConnectionHeadingEnum ResolveAuto(this ConnectionHeadingEnum heading, CurvySplineSegment followUp)
		{
			if (heading == ConnectionHeadingEnum.Auto)
			{
				heading = (CurvySplineSegment.CanFollowUpHeadToEnd(followUp) ? ConnectionHeadingEnum.Plus : (CurvySplineSegment.CanFollowUpHeadToStart(followUp) ? ConnectionHeadingEnum.Minus : ConnectionHeadingEnum.Sharp));
			}
			return heading;
		}
	}
	public enum CurvyUpdateMethod
	{
		Update,
		LateUpdate,
		FixedUpdate
	}
	public enum CurvyRepeatingOrderEnum
	{
		Random,
		Row
	}
	public enum CurvyPlane
	{
		XY,
		XZ,
		YZ
	}
	public enum CurvyPositionMode
	{
		Relative,
		WorldUnits
	}
	[Flags]
	public enum CurvyBezierModeEnum
	{
		None = 0,
		Direction = 1,
		Length = 2,
		Connections = 4,
		Combine = 8
	}
	public enum CurvyAdvBezierModeEnum
	{
		None = 0,
		Direction = 1,
		Length = 2,
		Combine = 8
	}
	public enum CurvyInterpolation
	{
		Linear,
		CatmullRom,
		TCB,
		Bezier
	}
	public enum CurvyClamping
	{
		Clamp,
		Loop,
		PingPong
	}
	public enum CurvyOrientation
	{
		None,
		Dynamic,
		Static
	}
	public enum CurvyOrientationSwirl
	{
		None,
		Segment,
		AnchorGroup,
		AnchorGroupAbs
	}
	public enum CurvySplineGizmos
	{
		None = 0,
		Curve = 2,
		Approximation = 4,
		Tangents = 8,
		Orientation = 16,
		Labels = 32,
		Metadata = 64,
		Bounds = 128,
		All = 65535
	}
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvyconnection")]
	public class CurvyConnection : MonoBehaviour, ISerializationCallbackReceiver
	{
		[SerializeField]
		[Hide]
		private List<CurvySplineSegment> m_ControlPoints = new List<CurvySplineSegment>();

		private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;

		private Couple<Vector3, Quaternion> processedConnectionCoordinates;

		[SerializeField]
		[Hide]
		private List<ControlPointCoordinates> processedControlPointsCoordinates = new List<ControlPointCoordinates>();

		public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
		{
			get
			{
				if (readOnlyControlPoints == null)
				{
					readOnlyControlPoints = m_ControlPoints.AsReadOnly();
				}
				return readOnlyControlPoints;
			}
		}

		public int Count => m_ControlPoints.Count;

		public CurvySplineSegment this[int idx] => m_ControlPoints[idx];

		private void OnEnable()
		{
			SceneManager.sceneLoaded += OnSceneLoaded;
			ResetProcessedCoordinates();
		}

		private void OnDisable()
		{
			SceneManager.sceneLoaded -= OnSceneLoaded;
		}

		private void Update()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void LateUpdate()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (Application.isPlaying)
			{
				DoUpdate();
			}
		}

		private void OnDestroy()
		{
			if (1 == 0)
			{
				return;
			}
			foreach (CurvySplineSegment item in new List<CurvySplineSegment>(m_ControlPoints))
			{
				item.Disconnect(destroyEmptyConnection: false);
			}
			m_ControlPoints.Clear();
			processedControlPointsCoordinates.Clear();
		}

		public static CurvyConnection Create(params CurvySplineSegment[] controlPoints)
		{
			CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
			if (instance == null)
			{
				DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
				return null;
			}
			CurvyConnection curvyConnection = instance.AddChildGameObject<CurvyConnection>("Connection");
			if (!curvyConnection)
			{
				return null;
			}
			if (controlPoints.Length != 0)
			{
				curvyConnection.transform.position = controlPoints[0].transform.position;
				curvyConnection.AddControlPoints(controlPoints);
			}
			return curvyConnection;
		}

		public void AddControlPoints(params CurvySplineSegment[] controlPoints)
		{
			foreach (CurvySplineSegment curvySplineSegment in controlPoints)
			{
				if ((bool)curvySplineSegment.Connection)
				{
					DTLog.LogErrorFormat("[Curvy] CurvyConnection.AddControlPoints called on a control point '{0}' that has already a connection. Only control points with no connection can be added.", curvySplineSegment);
				}
				else
				{
					m_ControlPoints.Add(curvySplineSegment);
					processedControlPointsCoordinates.Add(new ControlPointCoordinates(curvySplineSegment));
					curvySplineSegment.Connection = this;
				}
			}
			AutoSetFollowUp();
		}

		public void AutoSetFollowUp()
		{
			if (Count != 2)
			{
				return;
			}
			CurvySplineSegment curvySplineSegment = m_ControlPoints[0];
			CurvySplineSegment curvySplineSegment2 = m_ControlPoints[1];
			if (curvySplineSegment.transform.position == curvySplineSegment2.transform.position && curvySplineSegment.ConnectionSyncPosition && curvySplineSegment2.ConnectionSyncPosition)
			{
				if (curvySplineSegment.FollowUp == null && (bool)curvySplineSegment.Spline && curvySplineSegment.Spline.CanControlPointHaveFollowUp(curvySplineSegment))
				{
					curvySplineSegment.SetFollowUp(curvySplineSegment2);
				}
				if (curvySplineSegment2.FollowUp == null && (bool)curvySplineSegment2.Spline && curvySplineSegment2.Spline.CanControlPointHaveFollowUp(curvySplineSegment2))
				{
					curvySplineSegment2.SetFollowUp(curvySplineSegment);
				}
			}
		}

		public void RemoveControlPoint(CurvySplineSegment controlPoint, bool destroySelfIfEmpty = true)
		{
			controlPoint.Connection = null;
			m_ControlPoints.Remove(controlPoint);
			processedControlPointsCoordinates.RemoveAll((ControlPointCoordinates element) => (object)element.ControlPoint == controlPoint);
			foreach (CurvySplineSegment controlPoint2 in m_ControlPoints)
			{
				if (controlPoint2.FollowUp == controlPoint)
				{
					controlPoint2.SetFollowUp(null);
				}
			}
			if (m_ControlPoints.Count == 0 && destroySelfIfEmpty)
			{
				Delete();
			}
		}

		public void Delete()
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public List<CurvySplineSegment> OtherControlPoints(CurvySplineSegment source)
		{
			List<CurvySplineSegment> list = new List<CurvySplineSegment>(m_ControlPoints);
			list.Remove(source);
			return list;
		}

		public void SetSynchronisationPositionAndRotation(Vector3 referencePosition, Quaternion referenceRotation)
		{
			Transform obj = base.transform;
			obj.position = referencePosition;
			obj.rotation = referenceRotation;
			obj.hasChanged = false;
			processedConnectionCoordinates.First = referencePosition;
			processedConnectionCoordinates.Second = referenceRotation;
			for (int i = 0; i < m_ControlPoints.Count; i++)
			{
				CurvySplineSegment controlPoint = m_ControlPoints[i];
				bool flag = controlPoint.ConnectionSyncPosition && controlPoint.transform.position.NotApproximately(referencePosition);
				bool flag2 = controlPoint.ConnectionSyncRotation && controlPoint.transform.rotation.DifferentOrientation(referenceRotation);
				if (flag)
				{
					controlPoint.transform.position = referencePosition;
				}
				if (flag2)
				{
					controlPoint.transform.rotation = referenceRotation;
				}
				ControlPointCoordinates controlPointCoordinates = processedControlPointsCoordinates.Single((ControlPointCoordinates element) => (object)element.ControlPoint == controlPoint);
				controlPointCoordinates.Position = controlPoint.transform.position;
				controlPointCoordinates.Rotation = controlPoint.transform.rotation;
				if (flag || (flag2 && controlPoint.OrientatinInfluencesSpline))
				{
					controlPoint.Spline.SetDirtyPartial(controlPoint, flag ? SplineDirtyingType.Everything : SplineDirtyingType.OrientationOnly);
				}
			}
		}

		private void DoUpdate()
		{
			Transform transform = base.transform;
			bool flag;
			if (transform.hasChanged)
			{
				transform.hasChanged = false;
				if (transform.position.NotApproximately(processedConnectionCoordinates.First) || transform.rotation.DifferentOrientation(processedConnectionCoordinates.Second))
				{
					SetSynchronisationPositionAndRotation(transform.position, transform.rotation);
					flag = true;
				}
				else
				{
					flag = false;
				}
			}
			else
			{
				flag = false;
			}
			if (flag)
			{
				return;
			}
			Vector3? vector = null;
			Quaternion? quaternion = null;
			foreach (CurvySplineSegment controlPoint in m_ControlPoints)
			{
				if (controlPoint.gameObject == null)
				{
					DTLog.LogError($"[Curvy] Connection named '{base.name}' had in its list a control point with no game object. Control point was ignored");
					continue;
				}
				ControlPointCoordinates controlPointCoordinates = processedControlPointsCoordinates.Single((ControlPointCoordinates element) => (object)element.ControlPoint == controlPoint);
				Transform transform2 = controlPoint.transform;
				if (controlPoint.ConnectionSyncPosition && transform2.position.NotApproximately(controlPointCoordinates.Position))
				{
					vector = transform2.position;
				}
				if (controlPoint.ConnectionSyncRotation && transform2.rotation.DifferentOrientation(controlPointCoordinates.Rotation))
				{
					quaternion = transform2.rotation;
				}
				if (!vector.HasValue || !quaternion.HasValue)
				{
					continue;
				}
				break;
			}
			if (vector.HasValue || quaternion.HasValue)
			{
				SetSynchronisationPositionAndRotation(vector ?? base.transform.position, quaternion ?? base.transform.rotation);
			}
		}

		private void OnSceneLoaded(Scene arg0, LoadSceneMode arg1)
		{
			if (m_ControlPoints.RemoveAll((CurvySplineSegment cp) => cp == null) != 0)
			{
				if (m_ControlPoints.Count == 0)
				{
					Delete();
					return;
				}
				DTLog.LogWarning("[Curvy] Connection " + base.name + " was not destroyed after scene switch. That should not happen. Please raise a bug report.");
				ResetProcessedCoordinates();
			}
		}

		private void ResetProcessedCoordinates()
		{
			Transform transform = base.transform;
			processedConnectionCoordinates = new Couple<Vector3, Quaternion>(transform.position, transform.rotation);
			processedControlPointsCoordinates.Clear();
			for (int i = 0; i < m_ControlPoints.Count; i++)
			{
				processedControlPointsCoordinates.Add(new ControlPointCoordinates(m_ControlPoints[i]));
			}
		}

		public void OnBeforeSerialize()
		{
			m_ControlPoints.RemoveAll((CurvySplineSegment cp) => (object)cp == null);
		}

		public void OnAfterDeserialize()
		{
			m_ControlPoints.RemoveAll((CurvySplineSegment cp) => (object)cp == null);
		}
	}
	[Serializable]
	internal class ControlPointCoordinates
	{
		[SerializeField]
		internal CurvySplineSegment ControlPoint;

		[SerializeField]
		internal Vector3 Position;

		[SerializeField]
		internal Quaternion Rotation;

		internal ControlPointCoordinates(CurvySplineSegment controlPoint)
		{
			ControlPoint = controlPoint;
			if ((bool)controlPoint.gameObject)
			{
				Position = controlPoint.transform.position;
				Rotation = controlPoint.transform.rotation;
			}
		}
	}
	public class CurvyEventArgs : EventArgs
	{
		public readonly MonoBehaviour Sender;

		public readonly object Data;

		public CurvyEventArgs(MonoBehaviour sender, object data)
		{
			Sender = sender;
			Data = data;
		}
	}
	[Serializable]
	public class CurvySplineEvent : UnityEventEx<CurvySplineEventArgs>
	{
	}
	[Serializable]
	public class CurvyControlPointEvent : UnityEventEx<CurvyControlPointEventArgs>
	{
	}
	public class CurvyControlPointEventArgs : CurvySplineEventArgs
	{
		public enum ModeEnum
		{
			None,
			AddBefore,
			AddAfter,
			Delete
		}

		public readonly ModeEnum Mode;

		public readonly CurvySplineSegment ControlPoint;

		public CurvyControlPointEventArgs(MonoBehaviour sender, CurvySpline spline, CurvySplineSegment cp, ModeEnum mode = ModeEnum.None, object data = null)
			: base(sender, spline, data)
		{
			ControlPoint = cp;
			Mode = mode;
		}
	}
	public class CurvySplineEventArgs : CurvyEventArgs
	{
		public readonly CurvySpline Spline;

		public CurvySplineEventArgs(MonoBehaviour sender, CurvySpline spline, object data = null)
			: base(sender, data)
		{
			Spline = spline;
		}
	}
	[Serializable]
	public class CurvyCGEvent : UnityEventEx<CurvyCGEventArgs>
	{
	}
	public class CurvyCGEventArgs : EventArgs
	{
		public readonly MonoBehaviour Sender;

		public readonly CurvyGenerator Generator;

		public readonly CGModule Module;

		public CurvyCGEventArgs(CGModule module)
		{
			Sender = module;
			Generator = module.Generator;
			Module = module;
		}

		public CurvyCGEventArgs(CurvyGenerator generator, CGModule module)
		{
			Sender = generator;
			Generator = generator;
			Module = module;
		}
	}
	public static class CurvyGizmoHelper
	{
		public static Matrix4x4 Matrix = Matrix4x4.identity;

		public static void SegmentCurveGizmo(CurvySplineSegment seg, Color col, float stepSize = 0.05f)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			if (seg.Spline.Interpolation == CurvyInterpolation.Linear)
			{
				Gizmos.DrawLine(seg.Interpolate(0f), seg.Interpolate(1f));
				return;
			}
			Vector3 from = seg.Interpolate(0f);
			for (float num = stepSize; num < 1f; num += stepSize)
			{
				Vector3 vector = seg.Interpolate(num);
				Gizmos.DrawLine(from, vector);
				from = vector;
			}
			Gizmos.DrawLine(from, seg.Interpolate(1f));
			Gizmos.matrix = matrix;
		}

		public static void SegmentApproximationGizmo(CurvySplineSegment seg, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			Vector3 a = new Vector3(0.1f / seg.Spline.transform.localScale.x, 0.1f / seg.Spline.transform.localScale.y, 0.1f / seg.Spline.transform.localScale.z);
			Camera current = Camera.current;
			Transform transform = current.transform;
			Vector3 position = transform.position;
			Vector3 cameraZDirection = transform.TransformDirection(new Vector3(0f, 0f, 1f));
			Matrix4x4 matrix2 = Gizmos.matrix;
			for (int i = 0; i < seg.Approximation.Length; i++)
			{
				Vector3 vector = seg.Approximation[i];
				float handleSize = DTUtility.GetHandleSize(matrix2.MultiplyPoint(vector), current, position, cameraZDirection, transform);
				Gizmos.DrawCube(vector, handleSize.Multiply(a));
			}
			Gizmos.matrix = matrix;
		}

		public static void SegmentOrientationAnchorGizmo(CurvySplineSegment seg, Color col)
		{
			if (seg.ApproximationUp.Length != 0)
			{
				Matrix4x4 matrix = Gizmos.matrix;
				Gizmos.matrix = Matrix;
				Gizmos.color = col;
				Vector3 vector = new Vector3(1f / seg.Spline.transform.localScale.x, 1f / seg.Spline.transform.localScale.y, 1f / seg.Spline.transform.localScale.z);
				Vector3 vector2 = seg.ApproximationUp[0];
				vector2.Set(vector2.x * vector.x, vector2.y * vector.y, vector2.z * vector.z);
				Gizmos.DrawRay(seg.Approximation[0], vector2 * CurvyGlobalManager.GizmoOrientationLength * 1.75f);
				Gizmos.matrix = matrix;
			}
		}

		public static void SegmentOrientationGizmo(CurvySplineSegment seg, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			Vector3 vector = new Vector3(1f / seg.Spline.transform.localScale.x, 1f / seg.Spline.transform.localScale.y, 1f / seg.Spline.transform.localScale.z);
			for (int i = 0; i < seg.ApproximationUp.Length; i++)
			{
				Vector3 vector2 = seg.Approximation[i];
				Vector3 a = seg.ApproximationUp[i];
				a.Set(a.x * vector.x, a.y * vector.y, a.z * vector.z);
				Gizmos.DrawLine(vector2, vector2.Addition(a.Multiply(CurvyGlobalManager.GizmoOrientationLength)));
			}
			Gizmos.matrix = matrix;
		}

		public static void SegmentTangentGizmo(CurvySplineSegment seg, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			int cacheSize = seg.CacheSize;
			for (int i = 0; i < seg.ApproximationT.Length; i++)
			{
				switch (i)
				{
				case 0:
					Gizmos.color = Color.blue;
					break;
				case 1:
					Gizmos.color = col;
					break;
				default:
					if (i == cacheSize)
					{
						Gizmos.color = Color.black;
					}
					break;
				}
				Vector3 vector = seg.Approximation[i];
				Gizmos.DrawLine(vector, vector.Addition(seg.ApproximationT[i].Multiply(CurvyGlobalManager.GizmoOrientationLength)));
			}
			Gizmos.matrix = matrix;
		}

		public static void ControlPointGizmo(CurvySplineSegment cp, bool selected, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix4x4.identity;
			Gizmos.color = col;
			Vector3 vector = Matrix.MultiplyPoint(cp.transform.localPosition);
			float num = (selected ? 1f : 0.7f);
			if ((bool)cp.Spline && cp.Spline.RestrictTo2D)
			{
				Gizmos.DrawCube(vector, Vector3.one * DTUtility.GetHandleSize(vector) * num * CurvyGlobalManager.GizmoControlPointSize);
			}
			else
			{
				Gizmos.DrawSphere(vector, DTUtility.GetHandleSize(vector) * num * CurvyGlobalManager.GizmoControlPointSize);
			}
			Gizmos.matrix = matrix;
		}

		public static void BoundsGizmo(CurvySplineSegment cp, Color col)
		{
			Matrix4x4 matrix = Gizmos.matrix;
			Gizmos.matrix = Matrix;
			Gizmos.color = col;
			Gizmos.DrawWireCube(cp.Bounds.center, cp.Bounds.size);
			Gizmos.matrix = matrix;
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(PoolManager))]
	[HelpURL("https://curvyeditor.com/doclink/curvyglobalmanager")]
	public class CurvyGlobalManager : DTSingleton<CurvyGlobalManager>
	{
		public static bool HideManager = false;

		public static float SceneViewResolution = 0.5f;

		public static Color DefaultGizmoColor = new Color(0.71f, 0.71f, 0.71f);

		public static Color DefaultGizmoSelectionColor = new Color(0.15f, 0.35f, 0.68f);

		public static CurvyInterpolation DefaultInterpolation = CurvyInterpolation.CatmullRom;

		public static float GizmoControlPointSize = 0.15f;

		public static float GizmoOrientationLength = 1f;

		public static Color GizmoOrientationColor = new Color(0.75f, 0.75f, 0.4f);

		public static int SplineLayer = 0;

		public static CurvySplineGizmos Gizmos = (CurvySplineGizmos)18;

		private PoolManager mPoolManager;

		private ComponentPool mControlPointPool;

		public static bool ShowCurveGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Curve) == CurvySplineGizmos.Curve;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Curve;
				}
				else
				{
					Gizmos &= (CurvySplineGizmos)(-3);
				}
			}
		}

		public static bool ShowApproximationGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Approximation) == CurvySplineGizmos.Approximation;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Approximation;
				}
				else
				{
					Gizmos &= (CurvySplineGizmos)(-5);
				}
			}
		}

		public static bool ShowTangentsGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Tangents) == CurvySplineGizmos.Tangents;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Tangents;
				}
				else
				{
					Gizmos &= (CurvySplineGizmos)(-9);
				}
			}
		}

		public static bool ShowOrientationGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Orientation) == CurvySplineGizmos.Orientation;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Orientation;
				}
				else
				{
					Gizmos &= (CurvySplineGizmos)(-17);
				}
			}
		}

		public static bool ShowLabelsGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Labels) == CurvySplineGizmos.Labels;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Labels;
				}
				else
				{
					Gizmos &= (CurvySplineGizmos)(-33);
				}
			}
		}

		public static bool ShowMetadataGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Metadata) == CurvySplineGizmos.Metadata;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Metadata;
				}
				else
				{
					Gizmos &= (CurvySplineGizmos)(-65);
				}
			}
		}

		public static bool ShowBoundsGizmo
		{
			get
			{
				return (Gizmos & CurvySplineGizmos.Bounds) == CurvySplineGizmos.Bounds;
			}
			set
			{
				if (value)
				{
					Gizmos |= CurvySplineGizmos.Bounds;
				}
				else
				{
					Gizmos &= (CurvySplineGizmos)(-129);
				}
			}
		}

		public PoolManager PoolManager
		{
			get
			{
				if (mPoolManager == null)
				{
					mPoolManager = GetComponent<PoolManager>();
				}
				return mPoolManager;
			}
		}

		public ComponentPool ControlPointPool => mControlPointPool;

		public CurvyConnection[] Connections => GetComponentsInChildren<CurvyConnection>();

		public CurvyConnection[] GetContainingConnections(params CurvySpline[] splines)
		{
			List<CurvyConnection> list = new List<CurvyConnection>();
			List<CurvySpline> list2 = new List<CurvySpline>(splines);
			foreach (CurvySpline item in list2)
			{
				foreach (CurvySplineSegment controlPoints in item.ControlPointsList)
				{
					if (!(controlPoints.Connection != null) || list.Contains(controlPoints.Connection))
					{
						continue;
					}
					bool flag = true;
					foreach (CurvySplineSegment controlPoints2 in controlPoints.Connection.ControlPointsList)
					{
						if (controlPoints2.Spline != null && !list2.Contains(controlPoints2.Spline))
						{
							flag = false;
							break;
						}
					}
					if (flag)
					{
						list.Add(controlPoints.Connection);
					}
				}
			}
			return list.ToArray();
		}

		public override void Awake()
		{
			base.Awake();
			base.name = "_CurvyGlobal_";
			base.transform.SetAsLastSibling();
			if (Application.isPlaying)
			{
				UnityEngine.Object.DontDestroyOnLoad(this);
			}
			mPoolManager = GetComponent<PoolManager>();
			PoolSettings settings = new PoolSettings
			{
				MinItems = 0,
				Threshold = 50,
				Prewarm = true,
				AutoCreate = true,
				AutoEnableDisable = true
			};
			mControlPointPool = mPoolManager.CreateComponentPool<CurvySplineSegment>(settings);
		}

		private void Start()
		{
			if (HideManager)
			{
				base.gameObject.hideFlags = HideFlags.HideInHierarchy;
			}
			else
			{
				base.gameObject.hideFlags = HideFlags.None;
			}
		}

		[RuntimeInitializeOnLoadMethod]
		private static void LoadRuntimeSettings()
		{
			if (!PlayerPrefs.HasKey("Curvy_MaxCachePPU"))
			{
				SaveRuntimeSettings();
			}
			SceneViewResolution = DTUtility.GetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
			HideManager = DTUtility.GetPlayerPrefs("Curvy_HideManager", HideManager);
			DefaultGizmoColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
			DefaultGizmoSelectionColor = DTUtility.GetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoColor);
			DefaultInterpolation = DTUtility.GetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
			GizmoControlPointSize = DTUtility.GetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
			GizmoOrientationLength = DTUtility.GetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
			GizmoOrientationColor = DTUtility.GetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
			Gizmos = DTUtility.GetPlayerPrefs("Curvy_Gizmos", Gizmos);
			SplineLayer = DTUtility.GetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
		}

		public static void SaveRuntimeSettings()
		{
			DTUtility.SetPlayerPrefs("Curvy_SceneViewResolution", SceneViewResolution);
			DTUtility.SetPlayerPrefs("Curvy_HideManager", HideManager);
			DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoColor", DefaultGizmoColor);
			DTUtility.SetPlayerPrefs("Curvy_DefaultGizmoSelectionColor", DefaultGizmoSelectionColor);
			DTUtility.SetPlayerPrefs("Curvy_DefaultInterpolation", DefaultInterpolation);
			DTUtility.SetPlayerPrefs("Curvy_ControlPointSize", GizmoControlPointSize);
			DTUtility.SetPlayerPrefs("Curvy_OrientationLength", GizmoOrientationLength);
			DTUtility.SetPlayerPrefs("Curvy_OrientationColor", GizmoOrientationColor);
			DTUtility.SetPlayerPrefs("Curvy_Gizmos", Gizmos);
			DTUtility.SetPlayerPrefs("Curvy_SplineLayer", SplineLayer);
			PlayerPrefs.Save();
		}

		public override void MergeDoubleLoaded(IDTSingleton newInstance)
		{
			base.MergeDoubleLoaded(newInstance);
			CurvyConnection[] connections = (newInstance as CurvyGlobalManager).Connections;
			for (int i = 0; i < connections.Length; i++)
			{
				connections[i].transform.SetParent(base.transform);
			}
		}
	}
	[ExecuteInEditMode]
	public abstract class CurvyInterpolatableMetadataBase<T> : CurvyMetadataBase
	{
		public abstract T MetaDataValue { get; }

		public abstract T Interpolate(CurvyInterpolatableMetadataBase<T> nextMetadata, float interpolationTime);
	}
	[RequireComponent(typeof(CurvySplineSegment))]
	[ExecuteInEditMode]
	public abstract class CurvyMetadataBase : MonoBehaviour
	{
		private CurvySplineSegment mCP;

		public CurvySplineSegment ControlPoint => mCP;

		public CurvySpline Spline
		{
			get
			{
				if (!mCP)
				{
					return null;
				}
				return mCP.Spline;
			}
		}

		protected virtual void Awake()
		{
			mCP = GetComponent<CurvySplineSegment>();
			mCP.RegisterMetaData(this);
		}

		private void OnDestroy()
		{
			mCP.UnregisterMetaData(this);
		}

		public T GetPreviousData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : CurvyMetadataBase
		{
			if ((bool)ControlPoint)
			{
				CurvySplineSegment controlPoint = ControlPoint;
				CurvySpline spline = Spline;
				CurvySplineSegment curvySplineSegment;
				if (!spline || spline.ControlPointsList.Count == 0)
				{
					curvySplineSegment = null;
				}
				else
				{
					curvySplineSegment = (useFollowUp ? spline.GetPreviousControlPointUsingFollowUp(controlPoint) : spline.GetPreviousControlPoint(controlPoint));
					if (segmentsOnly && (bool)curvySplineSegment && !curvySplineSegment.Spline.IsControlPointASegment(curvySplineSegment))
					{
						curvySplineSegment = null;
					}
				}
				if ((bool)curvySplineSegment)
				{
					return curvySplineSegment.GetMetadata<T>(autoCreate);
				}
			}
			return null;
		}

		public T GetNextData<T>(bool autoCreate = true, bool segmentsOnly = true, bool useFollowUp = false) where T : CurvyMetadataBase
		{
			if ((bool)ControlPoint)
			{
				CurvySplineSegment controlPoint = ControlPoint;
				CurvySpline spline = Spline;
				CurvySplineSegment curvySplineSegment;
				if (!spline || spline.ControlPointsList.Count == 0)
				{
					curvySplineSegment = null;
				}
				else
				{
					curvySplineSegment = (useFollowUp ? spline.GetNextControlPointUsingFollowUp(controlPoint) : spline.GetNextControlPoint(controlPoint));
					if (segmentsOnly && (bool)curvySplineSegment && !curvySplineSegment.Spline.IsControlPointASegment(curvySplineSegment))
					{
						curvySplineSegment = null;
					}
				}
				if ((bool)curvySplineSegment)
				{
					return curvySplineSegment.GetMetadata<T>(autoCreate);
				}
			}
			return null;
		}

		protected void NotifyModification()
		{
			CurvySpline spline = Spline;
			if ((bool)spline && spline.IsInitialized)
			{
				spline.NotifyMetaDataModification();
			}
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public class CGResourceManagerAttribute : DTPropertyAttribute
	{
		public readonly string ResourceName;

		public bool ReadOnly;

		public CGResourceManagerAttribute(string resourceName)
		{
			ResourceName = resourceName;
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public sealed class CGResourceCollectionManagerAttribute : CGResourceManagerAttribute
	{
		public bool ShowCount;

		public CGResourceCollectionManagerAttribute(string resourceName)
			: base(resourceName)
		{
			ReadOnly = true;
		}
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public sealed class CGDataReferenceSelectorAttribute : DTPropertyAttribute
	{
		public readonly Type DataType;

		public CGDataReferenceSelectorAttribute(Type dataType)
		{
			DataType = dataType;
		}
	}
	[RequireComponent(typeof(CurvySpline))]
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvyshape")]
	public class CurvyShape : DTVersionedMonoBehaviour
	{
		[SerializeField]
		[Label("Plane", "")]
		private CurvyPlane m_Plane;

		[SerializeField]
		[HideInInspector]
		private bool m_Persistent = true;

		private static Dictionary<CurvyShapeInfo, Type> mShapeDefs = new Dictionary<CurvyShapeInfo, Type>();

		private CurvySpline mSpline;

		[NonSerialized]
		public bool Dirty;

		public CurvyPlane Plane
		{
			get
			{
				return m_Plane;
			}
			set
			{
				if (m_Plane != value)
				{
					m_Plane = value;
					Dirty = true;
				}
			}
		}

		public bool Persistent
		{
			get
			{
				return m_Persistent;
			}
			set
			{
				if (m_Persistent != value)
				{
					m_Persistent = value;
					base.hideFlags = ((!value) ? HideFlags.HideInInspector : HideFlags.None);
				}
			}
		}

		public CurvySpline Spline
		{
			get
			{
				if (!mSpline)
				{
					mSpline = GetComponent<CurvySpline>();
				}
				return mSpline;
			}
		}

		public static Dictionary<CurvyShapeInfo, Type> ShapeDefinitions
		{
			get
			{
				if (mShapeDefs.Count == 0)
				{
					mShapeDefs = typeof(CurvyShape).GetAllTypesWithAttribute<CurvyShapeInfo>();
				}
				return mShapeDefs;
			}
		}

		private void Update()
		{
			base.hideFlags = ((!Persistent) ? HideFlags.HideInInspector : HideFlags.None);
			Refresh();
		}

		protected virtual void Reset()
		{
			Plane = CurvyPlane.XY;
		}

		public void Delete()
		{
			UnityEngine.Object.Destroy(this);
		}

		public void Refresh()
		{
			if ((bool)Spline && Spline.IsInitialized && Dirty)
			{
				ApplyShape();
				applyPlane();
				Spline.SetDirtyAll();
				Spline.Refresh();
			}
			Dirty = false;
		}

		public CurvyShape Replace(string menuName)
		{
			bool persistent = Persistent;
			Type shapeType = GetShapeType(menuName);
			if (shapeType != null)
			{
				GameObject obj = base.gameObject;
				Delete();
				CurvyShape obj2 = (CurvyShape)obj.AddComponent(shapeType);
				obj2.Persistent = persistent;
				obj2.Dirty = true;
				return obj2;
			}
			return null;
		}

		protected void PrepareSpline(CurvyInterpolation interpolation, CurvyOrientation orientation = CurvyOrientation.Dynamic, int cachedensity = 50, bool closed = true)
		{
			Spline.Interpolation = interpolation;
			Spline.Orientation = orientation;
			Spline.CacheDensity = cachedensity;
			Spline.Closed = closed;
			Spline.RestrictTo2D = this is CurvyShape2D;
		}

		protected void SetPosition(int no, Vector3 position)
		{
			Spline.ControlPointsList[no].SetLocalPosition(position);
		}

		protected void SetRotation(int no, Quaternion rotation)
		{
			Spline.ControlPointsList[no].SetLocalRotation(rotation);
		}

		protected void SetBezierHandles(int no, float distanceFrag)
		{
			SetBezierHandles(no, distanceFrag, distanceFrag);
		}

		protected void SetBezierHandles(int no, float inDistanceFrag, float outDistanceFrag)
		{
			CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];
			if (no >= 0 && no < Spline.ControlPointCount)
			{
				if (inDistanceFrag == outDistanceFrag)
				{
					curvySplineSegment.AutoHandles = true;
					curvySplineSegment.AutoHandleDistance = inDistanceFrag;
					return;
				}
				curvySplineSegment.AutoHandles = false;
				curvySplineSegment.AutoHandleDistance = (inDistanceFrag + outDistanceFrag) / 2f;
				SetBezierHandles(inDistanceFrag, true, false, curvySplineSegment);
				SetBezierHandles(outDistanceFrag, false, true, curvySplineSegment);
			}
		}

		protected void SetBezierHandles(int no, Vector3 i, Vector3 o, Space space = Space.World)
		{
			if (no >= 0 && no < Spline.ControlPointCount)
			{
				CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[no];
				curvySplineSegment.AutoHandles = false;
				if (space == Space.World)
				{
					curvySplineSegment.HandleInPosition = i;
					curvySplineSegment.HandleOutPosition = o;
				}
				else
				{
					curvySplineSegment.HandleIn = i;
					curvySplineSegment.HandleOut = o;
				}
			}
		}

		public static void SetBezierHandles(float distanceFrag, bool setIn, bool setOut, params CurvySplineSegment[] controlPoints)
		{
			if (controlPoints.Length != 0)
			{
				for (int i = 0; i < controlPoints.Length; i++)
				{
					controlPoints[i].SetBezierHandles(distanceFrag, setIn, setOut);
				}
			}
		}

		protected void SetCGHardEdges(params int[] controlPoints)
		{
			if (controlPoints.Length == 0)
			{
				for (int i = 0; i < Spline.ControlPointCount; i++)
				{
					Spline.ControlPointsList[i].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge = true;
				}
				return;
			}
			for (int j = 0; j < controlPoints.Length; j++)
			{
				if (j >= 0 && j < Spline.ControlPointCount)
				{
					Spline.ControlPointsList[j].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge = true;
				}
			}
		}

		protected virtual void ApplyShape()
		{
		}

		protected void PrepareControlPoints(int count)
		{
			int i = count - Spline.ControlPointCount;
			bool flag = i != 0;
			while (i > 0)
			{
				Spline.InsertAfter(null, skipRefreshingAndEvents: true);
				i--;
			}
			for (; i < 0; i++)
			{
				Spline.Delete(Spline.LastVisibleControlPoint, skipRefreshingAndEvents: true, isUndoableDeletion: false);
			}
			for (int j = 0; j < Spline.ControlPointsList.Count; j++)
			{
				CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[j];
				curvySplineSegment.Reset();
				curvySplineSegment.Disconnect();
				MetaCGOptions metadata = curvySplineSegment.GetMetadata<MetaCGOptions>();
				if ((bool)metadata)
				{
					metadata.Reset();
				}
			}
			if (flag)
			{
				Spline.Refresh();
			}
		}

		public static List<string> GetShapesMenuNames(bool only2D = false)
		{
			List<string> list = new List<string>();
			foreach (CurvyShapeInfo key in ShapeDefinitions.Keys)
			{
				if (!only2D || key.Is2D)
				{
					list.Add(key.Name);
				}
			}
			return list;
		}

		public static List<string> GetShapesMenuNames(Type currentShapeType, out int currentIndex, bool only2D = false)
		{
			currentIndex = 0;
			if (currentShapeType == null)
			{
				return GetShapesMenuNames(only2D);
			}
			List<string> list = new List<string>();
			foreach (KeyValuePair<CurvyShapeInfo, Type> shapeDefinition in ShapeDefinitions)
			{
				if (!only2D || shapeDefinition.Key.Is2D)
				{
					list.Add(shapeDefinition.Key.Name);
				}
				if (shapeDefinition.Value == currentShapeType)
				{
					currentIndex = list.Count - 1;
				}
			}
			return list;
		}

		public static string GetShapeName(Type shapeType)
		{
			foreach (KeyValuePair<CurvyShapeInfo, Type> shapeDefinition in ShapeDefinitions)
			{
				if (shapeDefinition.Value == shapeType)
				{
					return shapeDefinition.Key.Name;
				}
			}
			return null;
		}

		public static Type GetShapeType(string menuName)
		{
			foreach (CurvyShapeInfo key in ShapeDefinitions.Keys)
			{
				if (key.Name == menuName)
				{
					return ShapeDefinitions[key];
				}
			}
			return null;
		}

		private void applyPlane()
		{
			switch (Plane)
			{
			case CurvyPlane.XZ:
				applyRotation(Quaternion.Euler(90f, 0f, 0f));
				break;
			case CurvyPlane.YZ:
				applyRotation(Quaternion.Euler(0f, 90f, 0f));
				break;
			default:
				applyRotation(Quaternion.Euler(0f, 0f, 0f));
				break;
			}
		}

		private void applyRotation(Quaternion q)
		{
			Spline.transform.localRotation = Quaternion.identity;
			if (Spline.Interpolation == CurvyInterpolation.Bezier)
			{
				for (int i = 0; i < Spline.ControlPointCount; i++)
				{
					CurvySplineSegment curvySplineSegment = Spline.ControlPointsList[i];
					curvySplineSegment.SetLocalPosition(q * curvySplineSegment.transform.localPosition);
					curvySplineSegment.HandleIn = q * curvySplineSegment.HandleIn;
					curvySplineSegment.HandleOut = q * curvySplineSegment.HandleOut;
				}
			}
			else
			{
				for (int j = 0; j < Spline.ControlPointCount; j++)
				{
					CurvySplineSegment curvySplineSegment2 = Spline.ControlPointsList[j];
					curvySplineSegment2.SetLocalRotation(Quaternion.identity);
					curvySplineSegment2.SetLocalPosition(q * curvySplineSegment2.transform.localPosition);
				}
			}
			Spline.ControlPointsList[0].transform.localRotation = q;
		}
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
	public sealed class CurvyShapeInfo : Attribute
	{
		public readonly string Name;

		public readonly bool Is2D;

		public CurvyShapeInfo(string name, bool is2D = true)
		{
			Name = name;
			Is2D = is2D;
		}
	}
	public class CurvyShape2D : CurvyShape
	{
	}
	[HelpURL("https://curvyeditor.com/doclink/curvyspline")]
	[AddComponentMenu("Curvy/Curvy Spline", 1)]
	[ExecuteInEditMode]
	public class CurvySpline : DTVersionedMonoBehaviour
	{
		public const string VERSION = "7.1.3";

		public const string APIVERSION = "710";

		public const string WEBROOT = "https://curvyeditor.com/";

		public const string DOCLINK = "https://curvyeditor.com/doclink/";

		[SerializeField]
		[HideInInspector]
		private List<CurvySplineSegment> ControlPoints = new List<CurvySplineSegment>();

		[HideInInspector]
		public bool ShowGizmos = true;

		[Section("General", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_general")]
		[Tooltip("Interpolation Method")]
		[SerializeField]
		[FormerlySerializedAs("Interpolation")]
		private CurvyInterpolation m_Interpolation = CurvyGlobalManager.DefaultInterpolation;

		[Tooltip("Restrict Control Points to local X/Y axis")]
		[FieldAction("CBCheck2DPlanar", ActionAttribute.ActionEnum.Callback)]
		[SerializeField]
		private bool m_RestrictTo2D;

		[SerializeField]
		[FormerlySerializedAs("Closed")]
		private bool m_Closed;

		[FieldCondition("canHaveManualEndCP", Action = ActionAttribute.ActionEnum.Enable)]
		[Tooltip("Handle End Control Points automatically?")]
		[SerializeField]
		[FormerlySerializedAs("AutoEndTangents")]
		private bool m_AutoEndTangents = true;

		[Tooltip("Orientation Flow")]
		[SerializeField]
		[FormerlySerializedAs("Orientation")]
		private CurvyOrientation m_Orientation = CurvyOrientation.Dynamic;

		[Section("Global Bezier Options", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_bezier")]
		[GroupCondition("m_Interpolation", CurvyInterpolation.Bezier, false)]
		[RangeEx(0f, 1f, "Default Distance %", "Handle length by distance to neighbours")]
		[SerializeField]
		private float m_AutoHandleDistance = 0.39f;

		[Section("Global TCB Options", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_tcb")]
		[GroupCondition("m_Interpolation", CurvyInterpolation.TCB, false)]
		[GroupAction("TCBOptionsGUI", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("Tension")]
		private float m_Tension;

		[SerializeField]
		[FormerlySerializedAs("Continuity")]
		private float m_Continuity;

		[SerializeField]
		[FormerlySerializedAs("Bias")]
		private float m_Bias;

		[Section("Advanced Settings", true, false, 100, HelpURL = "https://curvyeditor.com/doclink/curvyspline_advanced")]
		[FieldAction("ShowGizmoGUI", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Above)]
		[Label("Color", "Gizmo color")]
		[SerializeField]
		private Color m_GizmoColor = CurvyGlobalManager.DefaultGizmoColor;

		[Label("Active Color", "Selected Gizmo color")]
		[SerializeField]
		private Color m_GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;

		[RangeEx(1f, 100f, "", "")]
		[SerializeField]
		[FormerlySerializedAs("Granularity")]
		[Tooltip("Defines how densely the cached points are. When the value is 100, the number of cached points per world distance unit is equal to the spline's MaxPointsPerUnit")]
		private int m_CacheDensity = 50;

		[SerializeField]
		[Tooltip("The maximum number of sampling points per world distance unit. Sampling is used in caching or shape extrusion for example")]
		private float m_MaxPointsPerUnit = 8f;

		[SerializeField]
		[Tooltip("Use a GameObject pool at runtime")]
		private bool m_UsePooling = true;

		[SerializeField]
		[Tooltip("Use threading where applicable. Threading is is currently not supported when targetting WebGL and Universal Windows Platform")]
		private bool m_UseThreading;

		[Tooltip("Refresh when Control Point position change?")]
		[SerializeField]
		[FormerlySerializedAs("AutoRefresh")]
		private bool m_CheckTransform = true;

		[SerializeField]
		private CurvyUpdateMethod m_UpdateIn;

		[Group("Events", Expanded = false, Sort = 1000, HelpURL = "https://curvyeditor.com/doclink/curvyspline_events")]
		[SortOrder(0)]
		[SerializeField]
		protected CurvySplineEvent m_OnRefresh = new CurvySplineEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(1)]
		[SerializeField]
		protected CurvySplineEvent m_OnAfterControlPointChanges = new CurvySplineEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(2)]
		[SerializeField]
		protected CurvyControlPointEvent m_OnBeforeControlPointAdd = new CurvyControlPointEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(3)]
		[SerializeField]
		protected CurvyControlPointEvent m_OnAfterControlPointAdd = new CurvyControlPointEvent();

		[Group("Events", Sort = 1000)]
		[SortOrder(4)]
		[SerializeField]
		protected CurvyControlPointEvent m_OnBeforeControlPointDelete = new CurvyControlPointEvent();

		private bool mIsInitialized;

		private bool isStarted;

		private bool sendOnRefreshEventNextUpdate;

		private readonly object controlPointsRelationshipCacheLock = new object();

		private List<CurvySplineSegment> mSegments = new List<CurvySplineSegment>();

		private ReadOnlyCollection<CurvySplineSegment> readOnlyControlPoints;

		private float length = -1f;

		private int mCacheSize = -1;

		private Bounds? mBounds;

		private bool mDirtyCurve;

		private bool mDirtyOrientation;

		private HashSet<CurvySplineSegment> dirtyControlPointsMinimalSet = new HashSet<CurvySplineSegment>();

		private List<CurvySplineSegment> dirtyCpsExtendedList = new List<CurvySplineSegment>();

		private bool allControlPointsAreDirty;

		private ThreadPoolWorker<CurvySplineSegment> mThreadWorker = new ThreadPoolWorker<CurvySplineSegment>();

		private readonly CurvySplineEventArgs defaultSplineEventArgs;

		private readonly CurvyControlPointEventArgs defaultAddAfterEventArgs;

		private readonly CurvyControlPointEventArgs defaultDeleteEventArgs;

		private float[] controlPointsDistances = new float[0];

		private readonly Action<CurvySplineSegment> refreshCurveAction;

		private Vector3 lastProcessedPosition;

		private Quaternion lastProcessedRotation;

		private Vector3 lastProcessedScale;

		private bool globalCoordinatesChangedThisFrame;

		private bool isCpsRelationshipCacheValid;

		private CurvySplineSegment firstSegment;

		private CurvySplineSegment lastSegment;

		private CurvySplineSegment firstVisibleControlPoint;

		private CurvySplineSegment lastVisibleControlPoint;

		private const float MinimalMaxPointsPerUnit = 0.0001f;

		private static readonly string InvalidCPErrorMessage = "[Curvy] Method called with a control point '{0}' that is not part of the current spline '{1}'";

		private Transform cachedTransform;

		public CurvyInterpolation Interpolation
		{
			get
			{
				return m_Interpolation;
			}
			set
			{
				if (m_Interpolation != value)
				{
					m_Interpolation = value;
					InvalidateControlPointsRelationshipCacheINTERNAL();
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
				AutoEndTangents = m_AutoEndTangents;
			}
		}

		public bool RestrictTo2D
		{
			get
			{
				return m_RestrictTo2D;
			}
			set
			{
				if (m_RestrictTo2D != value)
				{
					m_RestrictTo2D = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float AutoHandleDistance
		{
			get
			{
				return m_AutoHandleDistance;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_AutoHandleDistance != num)
				{
					m_AutoHandleDistance = num;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public bool Closed
		{
			get
			{
				return m_Closed;
			}
			set
			{
				if (m_Closed != value)
				{
					m_Closed = value;
					InvalidateControlPointsRelationshipCacheINTERNAL();
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
				}
				AutoEndTangents = m_AutoEndTangents;
			}
		}

		public bool AutoEndTangents
		{
			get
			{
				return m_AutoEndTangents;
			}
			set
			{
				bool flag = !canHaveManualEndCP() || value;
				if (m_AutoEndTangents != flag)
				{
					m_AutoEndTangents = flag;
					InvalidateControlPointsRelationshipCacheINTERNAL();
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
				}
			}
		}

		public CurvyOrientation Orientation
		{
			get
			{
				return m_Orientation;
			}
			set
			{
				if (m_Orientation != value)
				{
					m_Orientation = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public CurvyUpdateMethod UpdateIn
		{
			get
			{
				return m_UpdateIn;
			}
			set
			{
				if (m_UpdateIn != value)
				{
					m_UpdateIn = value;
				}
			}
		}

		public Color GizmoColor
		{
			get
			{
				return m_GizmoColor;
			}
			set
			{
				if (m_GizmoColor != value)
				{
					m_GizmoColor = value;
				}
			}
		}

		public Color GizmoSelectionColor
		{
			get
			{
				return m_GizmoSelectionColor;
			}
			set
			{
				if (m_GizmoSelectionColor != value)
				{
					m_GizmoSelectionColor = value;
				}
			}
		}

		public int CacheDensity
		{
			get
			{
				return m_CacheDensity;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_CacheDensity != num)
				{
					m_CacheDensity = num;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float MaxPointsPerUnit
		{
			get
			{
				return m_MaxPointsPerUnit;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.0001f, 1000f);
				if (m_MaxPointsPerUnit != num)
				{
					m_MaxPointsPerUnit = num;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public bool UsePooling
		{
			get
			{
				return m_UsePooling;
			}
			set
			{
				if (m_UsePooling != value)
				{
					m_UsePooling = value;
				}
			}
		}

		public bool UseThreading
		{
			get
			{
				return m_UseThreading;
			}
			set
			{
				if (m_UseThreading != value)
				{
					m_UseThreading = value;
				}
			}
		}

		public bool CheckTransform
		{
			get
			{
				return m_CheckTransform;
			}
			set
			{
				if (m_CheckTransform != value)
				{
					m_CheckTransform = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float Tension
		{
			get
			{
				return m_Tension;
			}
			set
			{
				if (m_Tension != value)
				{
					m_Tension = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float Continuity
		{
			get
			{
				return m_Continuity;
			}
			set
			{
				if (m_Continuity != value)
				{
					m_Continuity = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public float Bias
		{
			get
			{
				return m_Bias;
			}
			set
			{
				if (m_Bias != value)
				{
					m_Bias = value;
					SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
				}
			}
		}

		public bool IsInitialized => mIsInitialized;

		public Bounds Bounds
		{
			get
			{
				if (!mBounds.HasValue)
				{
					Bounds bounds2;
					if (Count > 0)
					{
						Bounds bounds = this[0].Bounds;
						for (int i = 1; i < Count; i++)
						{
							bounds.Encapsulate(this[i].Bounds);
						}
						bounds2 = bounds;
					}
					else
					{
						bounds2 = new Bounds(base.transform.position, Vector3.zero);
					}
					if (!Dirty)
					{
						mBounds = bounds2;
					}
					return bounds2;
				}
				return mBounds.Value;
			}
		}

		public int Count => Segments.Count;

		public int ControlPointCount => ControlPoints.Count;

		public int CacheSize
		{
			get
			{
				if (mCacheSize < 0)
				{
					int num = 0;
					List<CurvySplineSegment> segments = Segments;
					for (int i = 0; i < segments.Count; i++)
					{
						num += segments[i].CacheSize;
					}
					if (!Dirty)
					{
						mCacheSize = num;
					}
					return num;
				}
				return mCacheSize;
			}
		}

		public float Length
		{
			get
			{
				if (length < 0f)
				{
					float result = ((Segments.Count != 0) ? (Closed ? (this[Count - 1].Distance + this[Count - 1].Length) : LastVisibleControlPoint.Distance) : 0f);
					if (!Dirty)
					{
						length = result;
					}
					return result;
				}
				return length;
			}
		}

		public bool Dirty
		{
			get
			{
				if (!allControlPointsAreDirty)
				{
					return dirtyControlPointsMinimalSet.Count > 0;
				}
				return true;
			}
		}

		public CurvySplineSegment this[int idx] => Segments[idx];

		public ReadOnlyCollection<CurvySplineSegment> ControlPointsList
		{
			get
			{
				if (readOnlyControlPoints == null)
				{
					readOnlyControlPoints = ControlPoints.AsReadOnly();
				}
				return readOnlyControlPoints;
			}
		}

		[CanBeNull]
		public CurvySplineSegment FirstVisibleControlPoint
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return firstVisibleControlPoint;
			}
		}

		[CanBeNull]
		public CurvySplineSegment LastVisibleControlPoint
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return lastVisibleControlPoint;
			}
		}

		public CurvySplineSegment FirstSegment
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return firstSegment;
			}
		}

		public CurvySplineSegment LastSegment
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return lastSegment;
			}
		}

		public bool GlobalCoordinatesChangedThisFrame => globalCoordinatesChangedThisFrame;

		public Action<CurvySpline> OnGlobalCoordinatesChanged { get; set; }

		public CurvySplineEvent OnRefresh
		{
			get
			{
				return m_OnRefresh;
			}
			set
			{
				if (m_OnRefresh != value)
				{
					m_OnRefresh = value;
				}
			}
		}

		public CurvySplineEvent OnAfterControlPointChanges
		{
			get
			{
				return m_OnAfterControlPointChanges;
			}
			set
			{
				if (m_OnAfterControlPointChanges != value)
				{
					m_OnAfterControlPointChanges = value;
				}
			}
		}

		public CurvyControlPointEvent OnBeforeControlPointAdd
		{
			get
			{
				return m_OnBeforeControlPointAdd;
			}
			set
			{
				if (m_OnBeforeControlPointAdd != value)
				{
					m_OnBeforeControlPointAdd = value;
				}
			}
		}

		public CurvyControlPointEvent OnAfterControlPointAdd
		{
			get
			{
				return m_OnAfterControlPointAdd;
			}
			set
			{
				if (m_OnAfterControlPointAdd != value)
				{
					m_OnAfterControlPointAdd = value;
				}
			}
		}

		public CurvyControlPointEvent OnBeforeControlPointDelete
		{
			get
			{
				return m_OnBeforeControlPointDelete;
			}
			set
			{
				if (m_OnBeforeControlPointDelete != value)
				{
					m_OnBeforeControlPointDelete = value;
				}
			}
		}

		private List<CurvySplineSegment> Segments
		{
			get
			{
				if (!isCpsRelationshipCacheValid)
				{
					RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
				}
				return mSegments;
			}
		}

		public CurvySpline()
		{
			refreshCurveAction = delegate(CurvySplineSegment controlPoint)
			{
				controlPoint.refreshCurveINTERNAL();
			};
			defaultSplineEventArgs = new CurvySplineEventArgs(this, this);
			defaultAddAfterEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.AddAfter);
			defaultDeleteEventArgs = new CurvyControlPointEventArgs(this, this, null, CurvyControlPointEventArgs.ModeEnum.Delete);
		}

		public static CurvySpline Create()
		{
			CurvySpline component = new GameObject("Curvy Spline", typeof(CurvySpline)).GetComponent<CurvySpline>();
			component.gameObject.layer = CurvyGlobalManager.SplineLayer;
			component.Start();
			return component;
		}

		public static CurvySpline Create(CurvySpline takeOptionsFrom)
		{
			CurvySpline curvySpline = Create();
			if ((bool)takeOptionsFrom)
			{
				curvySpline.RestrictTo2D = takeOptionsFrom.RestrictTo2D;
				curvySpline.GizmoColor = takeOptionsFrom.GizmoColor;
				curvySpline.GizmoSelectionColor = takeOptionsFrom.GizmoSelectionColor;
				curvySpline.Interpolation = takeOptionsFrom.Interpolation;
				curvySpline.Closed = takeOptionsFrom.Closed;
				curvySpline.AutoEndTangents = takeOptionsFrom.AutoEndTangents;
				curvySpline.CacheDensity = takeOptionsFrom.CacheDensity;
				curvySpline.MaxPointsPerUnit = takeOptionsFrom.MaxPointsPerUnit;
				curvySpline.Orientation = takeOptionsFrom.Orientation;
				curvySpline.CheckTransform = takeOptionsFrom.CheckTransform;
			}
			return curvySpline;
		}

		public static int CalculateCacheSize(int density, float splineLength, float maxPointsPerUnit)
		{
			return Mathf.FloorToInt(CalculateSamplingPointsPerUnit(density, maxPointsPerUnit) * splineLength) + 1;
		}

		public static float CalculateSamplingPointsPerUnit(int density, float maxPointsPerUnit)
		{
			int num = Mathf.Clamp(density, 1, 100);
			if (num != density)
			{
				DTLog.LogWarning("[Curvy] CalculateSamplingPointsPerUnit got an invalid density parameter. It should be between 1 and 100. The parameter value was " + density);
				density = num;
			}
			return DTTween.QuadIn(density - 1, 0.0001f, maxPointsPerUnit, 99f);
		}

		public static Vector3 Bezier(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
		{
			double num = (double)(0f - P0.x) + 3.0 * (double)T0.x + -3.0 * (double)T1.x + (double)P1.x;
			double num2 = 3.0 * (double)P0.x + -6.0 * (double)T0.x + 3.0 * (double)T1.x;
			double num3 = -3.0 * (double)P0.x + 3.0 * (double)T0.x;
			double num4 = P0.x;
			double num5 = (double)(0f - P0.y) + 3.0 * (double)T0.y + -3.0 * (double)T1.y + (double)P1.y;
			double num6 = 3.0 * (double)P0.y + -6.0 * (double)T0.y + 3.0 * (double)T1.y;
			double num7 = -3.0 * (double)P0.y + 3.0 * (double)T0.y;
			double num8 = P0.y;
			double num9 = (double)(0f - P0.z) + 3.0 * (double)T0.z + -3.0 * (double)T1.z + (double)P1.z;
			double num10 = 3.0 * (double)P0.z + -6.0 * (double)T0.z + 3.0 * (double)T1.z;
			double num11 = -3.0 * (double)P0.z + 3.0 * (double)T0.z;
			double num12 = P0.z;
			float x = (float)(((num * (double)f + num2) * (double)f + num3) * (double)f + num4);
			float y = (float)(((num5 * (double)f + num6) * (double)f + num7) * (double)f + num8);
			float z = (float)(((num9 * (double)f + num10) * (double)f + num11) * (double)f + num12);
			Vector3 result = default(Vector3);
			result.x = x;
			result.y = y;
			result.z = z;
			return result;
		}

		public static Vector3 BezierTangent(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
		{
			Vector3 vector = P1 - 3f * T1 + 3f * T0 - P0;
			Vector3 vector2 = 3f * T1 - 6f * T0 + 3f * P0;
			Vector3 vector3 = 3f * T0 - 3f * P0;
			return 3f * vector * f * f + 2f * vector2 * f + vector3;
		}

		public static Vector3 CatmullRom(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f)
		{
			double num = -0.5 * (double)T0.x + 1.5 * (double)P0.x + -1.5 * (double)P1.x + 0.5 * (double)T1.x;
			double num2 = (double)T0.x + -2.5 * (double)P0.x + 2.0 * (double)P1.x + -0.5 * (double)T1.x;
			double num3 = -0.5 * (double)T0.x + 0.5 * (double)P1.x;
			double num4 = P0.x;
			double num5 = -0.5 * (double)T0.y + 1.5 * (double)P0.y + -1.5 * (double)P1.y + 0.5 * (double)T1.y;
			double num6 = (double)T0.y + -2.5 * (double)P0.y + 2.0 * (double)P1.y + -0.5 * (double)T1.y;
			double num7 = -0.5 * (double)T0.y + 0.5 * (double)P1.y;
			double num8 = P0.y;
			double num9 = -0.5 * (double)T0.z + 1.5 * (double)P0.z + -1.5 * (double)P1.z + 0.5 * (double)T1.z;
			double num10 = (double)T0.z + -2.5 * (double)P0.z + 2.0 * (double)P1.z + -0.5 * (double)T1.z;
			double num11 = -0.5 * (double)T0.z + 0.5 * (double)P1.z;
			double num12 = P0.z;
			float x = (float)(((num * (double)f + num2) * (double)f + num3) * (double)f + num4);
			float y = (float)(((num5 * (double)f + num6) * (double)f + num7) * (double)f + num8);
			float z = (float)(((num9 * (double)f + num10) * (double)f + num11) * (double)f + num12);
			Vector3 result = default(Vector3);
			result.x = x;
			result.y = y;
			result.z = z;
			return result;
		}

		public static Vector3 TCB(Vector3 T0, Vector3 P0, Vector3 P1, Vector3 T1, float f, float FT0, float FC0, float FB0, float FT1, float FC1, float FB1)
		{
			double num = (1f - FT0) * (1f + FC0) * (1f + FB0);
			double num2 = (1f - FT0) * (1f - FC0) * (1f - FB0);
			double num3 = (1f - FT1) * (1f - FC1) * (1f + FB1);
			double num4 = (1f - FT1) * (1f + FC1) * (1f - FB1);
			double num5 = 2.0;
			double num6 = (0.0 - num) / num5;
			double num7 = (4.0 + num - num2 - num3) / num5;
			double num8 = (-4.0 + num2 + num3 - num4) / num5;
			double num9 = num4 / num5;
			double num10 = 2.0 * num / num5;
			double num11 = (-6.0 - 2.0 * num + 2.0 * num2 + num3) / num5;
			double num12 = (6.0 - 2.0 * num2 - num3 + num4) / num5;
			double num13 = (0.0 - num4) / num5;
			double num14 = (0.0 - num) / num5;
			double num15 = (num - num2) / num5;
			double num16 = num2 / num5;
			double num17 = 2.0 / num5;
			double num18 = num6 * (double)T0.x + num7 * (double)P0.x + num8 * (double)P1.x + num9 * (double)T1.x;
			double num19 = num10 * (double)T0.x + num11 * (double)P0.x + num12 * (double)P1.x + num13 * (double)T1.x;
			double num20 = num14 * (double)T0.x + num15 * (double)P0.x + num16 * (double)P1.x;
			double num21 = num17 * (double)P0.x;
			double num22 = num6 * (double)T0.y + num7 * (double)P0.y + num8 * (double)P1.y + num9 * (double)T1.y;
			double num23 = num10 * (double)T0.y + num11 * (double)P0.y + num12 * (double)P1.y + num13 * (double)T1.y;
			double num24 = num14 * (double)T0.y + num15 * (double)P0.y + num16 * (double)P1.y;
			double num25 = num17 * (double)P0.y;
			double num26 = num6 * (double)T0.z + num7 * (double)P0.z + num8 * (double)P1.z + num9 * (double)T1.z;
			double num27 = num10 * (double)T0.z + num11 * (double)P0.z + num12 * (double)P1.z + num13 * (double)T1.z;
			double num28 = num14 * (double)T0.z + num15 * (double)P0.z + num16 * (double)P1.z;
			double num29 = num17 * (double)P0.z;
			float x = (float)(((num18 * (double)f + num19) * (double)f + num20) * (double)f + num21);
			float y = (float)(((num22 * (double)f + num23) * (double)f + num24) * (double)f + num25);
			float z = (float)(((num26 * (double)f + num27) * (double)f + num28) * (double)f + num29);
			Vector3 result = default(Vector3);
			result.x = x;
			result.y = y;
			result.z = z;
			return result;
		}

		[NotNull]
		public static CurvySplineSegment GetFollowUpHeadingControlPoint(CurvySplineSegment followUp, ConnectionHeadingEnum headingDirection)
		{
			return headingDirection.ResolveAuto(followUp) switch
			{
				ConnectionHeadingEnum.Minus => followUp.Spline.GetPreviousControlPoint(followUp), 
				ConnectionHeadingEnum.Plus => followUp.Spline.GetNextControlPoint(followUp), 
				ConnectionHeadingEnum.Sharp => followUp, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		public Vector3 Interpolate(float tf, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				return curvySplineSegment.Interpolate(localF, space);
			}
			if (space != Space.Self)
			{
				return cachedTransform.position;
			}
			return Vector3.zero;
		}

		public Vector3 InterpolateFast(float tf, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				return curvySplineSegment.InterpolateFast(localF, space);
			}
			if (space != Space.Self)
			{
				return cachedTransform.position;
			}
			return Vector3.zero;
		}

		public Vector3 InterpolateByDistance(float distance, Space space = Space.Self)
		{
			return Interpolate(DistanceToTF(distance), space);
		}

		public Vector3 InterpolateByDistanceFast(float distance, Space space = Space.Self)
		{
			return InterpolateFast(DistanceToTF(distance), space);
		}

		public Vector3 GetTangent(float tf, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				return curvySplineSegment.GetTangent(localF, space);
			}
			if (space != Space.Self)
			{
				return cachedTransform.position;
			}
			return Vector3.zero;
		}

		public Vector3 GetTangent(float tf, Vector3 position, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				return curvySplineSegment.GetTangent(localF, position, space);
			}
			if (space != Space.Self)
			{
				return cachedTransform.position;
			}
			return Vector3.zero;
		}

		public Vector3 GetTangentFast(float tf, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				return curvySplineSegment.GetTangentFast(localF, space);
			}
			if (space != Space.Self)
			{
				return cachedTransform.position;
			}
			return Vector3.zero;
		}

		public Vector3 GetTangentByDistance(float distance, Space space = Space.Self)
		{
			return GetTangent(DistanceToTF(distance), space);
		}

		public Vector3 GetTangentByDistanceFast(float distance, Space space = Space.Self)
		{
			return GetTangentFast(DistanceToTF(distance), space);
		}

		public void InterpolateAndGetTangent(float tf, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				curvySplineSegment.InterpolateAndGetTangent(localF, out position, out tangent, space);
			}
			else
			{
				position = (tangent = ((space == Space.Self) ? Vector3.zero : cachedTransform.position));
			}
		}

		public void InterpolateAndGetTangentFast(float tf, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				curvySplineSegment.InterpolateAndGetTangentFast(localF, out position, out tangent, space);
			}
			else
			{
				position = (tangent = ((space == Space.Self) ? Vector3.zero : cachedTransform.position));
			}
		}

		public Vector3 GetOrientationUpFast(float tf, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				return curvySplineSegment.GetOrientationUpFast(localF, space);
			}
			if (space != Space.Self)
			{
				return cachedTransform.position;
			}
			return Vector3.zero;
		}

		public Quaternion GetOrientationFast(float tf, bool inverse = false, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				return curvySplineSegment.GetOrientationFast(localF, inverse, space);
			}
			if (space != Space.Self)
			{
				return cachedTransform.rotation;
			}
			return Quaternion.identity;
		}

		[Obsolete("Member not used by Curvy, will get remove. Copy it if you still need it")]
		public Vector3 InterpolateScale(float tf)
		{
			float localF;
			return TFToSegment(tf, out localF)?.InterpolateScale(localF) ?? Vector3.zero;
		}

		public T GetMetadata<T>(float tf) where T : CurvyMetadataBase
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment == null)
			{
				return null;
			}
			return curvySplineSegment.GetMetadata<T>();
		}

		public U GetInterpolatedMetadata<T, U>(float tf) where T : CurvyInterpolatableMetadataBase<U>
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF);
			if ((object)curvySplineSegment == null)
			{
				return default(U);
			}
			return curvySplineSegment.GetInterpolatedMetadata<T, U>(localF);
		}

		public float TFToDistance(float tf, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			float num = Length;
			if (num == 0f)
			{
				return 0f;
			}
			if (tf == 0f)
			{
				return 0f;
			}
			if (tf == 1f)
			{
				return num;
			}
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(tf, out localF, clamping);
			return ((object)curvySplineSegment != null) ? (curvySplineSegment.Distance + curvySplineSegment.LocalFToDistance(localF)) : 0f;
		}

		public CurvySplineSegment TFToSegment(float tf, out float localF, out bool isOnSegmentStart, out bool isOnSegmentEnd, CurvyClamping clamping)
		{
			tf = CurvyUtility.ClampTF(tf, clamping);
			int count = Count;
			if (count == 0)
			{
				localF = 0f;
				isOnSegmentStart = false;
				isOnSegmentEnd = false;
				return null;
			}
			float num = tf * (float)count;
			int num2 = (int)num;
			localF = num - (float)num2;
			if (num2 == count)
			{
				num2--;
				localF = 1f;
			}
			isOnSegmentStart = num == (float)num2;
			isOnSegmentEnd = tf == 1f;
			return this[num2];
		}

		public CurvySplineSegment TFToSegment(float tf, out float localF, CurvyClamping clamping)
		{
			bool isOnSegmentStart;
			bool isOnSegmentEnd;
			return TFToSegment(tf, out localF, out isOnSegmentStart, out isOnSegmentEnd, clamping);
		}

		public CurvySplineSegment TFToSegment(float tf, CurvyClamping clamping)
		{
			float localF;
			return TFToSegment(tf, out localF, clamping);
		}

		public CurvySplineSegment TFToSegment(float tf)
		{
			float localF;
			return TFToSegment(tf, out localF, CurvyClamping.Clamp);
		}

		public CurvySplineSegment TFToSegment(float tf, out float localF)
		{
			return TFToSegment(tf, out localF, CurvyClamping.Clamp);
		}

		public float SegmentToTF(CurvySplineSegment segment)
		{
			return segment.TF;
		}

		public float SegmentToTF(CurvySplineSegment segment, float localF)
		{
			if (IsControlPointASegment(segment))
			{
				return segment.TF + 1f / (float)Count * localF;
			}
			return segment.TF;
		}

		public float DistanceToTF(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			if (Length == 0f)
			{
				return 0f;
			}
			if (distance == 0f)
			{
				return 0f;
			}
			if (distance == Length)
			{
				return 1f;
			}
			float localDistance;
			CurvySplineSegment curvySplineSegment = DistanceToSegment(distance, out localDistance, clamping);
			return ((object)curvySplineSegment != null) ? SegmentToTF(curvySplineSegment, curvySplineSegment.DistanceToLocalF(localDistance)) : 0f;
		}

		public CurvySplineSegment DistanceToSegment(float distance, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			float localDistance;
			return DistanceToSegment(distance, out localDistance, clamping);
		}

		public CurvySplineSegment DistanceToSegment(float distance, out float localDistance, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			bool isOnSegmentStart;
			bool isOnSegmentEnd;
			return DistanceToSegment(distance, out localDistance, out isOnSegmentStart, out isOnSegmentEnd, clamping);
		}

		public CurvySplineSegment DistanceToSegment(float distance, out float localDistance, out bool isOnSegmentStart, out bool isOnSegmentEnd, CurvyClamping clamping = CurvyClamping.Clamp)
		{
			distance = CurvyUtility.ClampDistance(distance, clamping, Length);
			CurvySplineSegment curvySplineSegment;
			if (Count > 0)
			{
				int num = CurvyUtility.InterpolationSearch(controlPointsDistances, distance);
				bool num2 = !AutoEndTangents;
				int count = ControlPointsList.Count;
				if (num2)
				{
					if (num == 0)
					{
						num = 1;
					}
					else if (num == count - 1 || num == count - 2)
					{
						num = count - 3;
					}
				}
				else if (!Closed && num == count - 1)
				{
					num = count - 2;
				}
				curvySplineSegment = ControlPointsList[num];
				localDistance = distance - curvySplineSegment.Distance;
				isOnSegmentStart = distance == curvySplineSegment.Distance;
				isOnSegmentEnd = distance == Length;
			}
			else
			{
				curvySplineSegment = null;
				localDistance = -1f;
				isOnSegmentStart = false;
				isOnSegmentEnd = false;
			}
			return curvySplineSegment;
		}

		public float ClampDistance(float distance, CurvyClamping clamping)
		{
			return CurvyUtility.ClampDistance(distance, clamping, Length);
		}

		public float ClampDistance(float distance, CurvyClamping clamping, float min, float max)
		{
			return CurvyUtility.ClampDistance(distance, clamping, Length, min, max);
		}

		public float ClampDistance(float distance, ref int dir, CurvyClamping clamping)
		{
			return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length);
		}

		public float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float min, float max)
		{
			return CurvyUtility.ClampDistance(distance, ref dir, clamping, Length, min, max);
		}

		public CurvySplineSegment Add()
		{
			return InsertAfter(null);
		}

		public CurvySplineSegment Add(Vector3 controlPointPosition, Space space)
		{
			OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);
			CurvySplineSegment result = InsertAfter(null, controlPointPosition, skipRefreshingAndEvents: true, space);
			Refresh();
			OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			return result;
		}

		public CurvySplineSegment[] Add(params Vector3[] controlPointsLocalPositions)
		{
			OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);
			CurvySplineSegment[] array = new CurvySplineSegment[controlPointsLocalPositions.Length];
			for (int i = 0; i < controlPointsLocalPositions.Length; i++)
			{
				array[i] = InsertAfter(null, controlPointsLocalPositions[i], skipRefreshingAndEvents: true, Space.Self);
			}
			Refresh();
			OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			return array;
		}

		public CurvySplineSegment[] Add(Vector3[] controlPointsPositions, Space space)
		{
			OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);
			CurvySplineSegment[] array = new CurvySplineSegment[controlPointsPositions.Length];
			for (int i = 0; i < controlPointsPositions.Length; i++)
			{
				array[i] = InsertAfter(null, controlPointsPositions[i], skipRefreshingAndEvents: true, space);
			}
			Refresh();
			OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			return array;
		}

		public CurvySplineSegment InsertBefore(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
		{
			CurvySplineSegment previousControlPoint;
			Vector3 position = ((!controlPoint || !(previousControlPoint = GetPreviousControlPoint(controlPoint))) ? base.transform.position : (IsControlPointASegment(previousControlPoint) ? previousControlPoint.Interpolate(0.5f, Space.World) : previousControlPoint.transform.position.LerpUnclamped(controlPoint.transform.position, 0.5f)));
			return InsertBefore(controlPoint, position, skipRefreshingAndEvents);
		}

		public CurvySplineSegment InsertBefore([CanBeNull] CurvySplineSegment controlPoint, Vector3 position, bool skipRefreshingAndEvents = false, Space space = Space.World)
		{
			return InsertAt(controlPoint, position, ((object)controlPoint != null) ? Mathf.Max(0, GetControlPointIndex(controlPoint)) : 0, CurvyControlPointEventArgs.ModeEnum.AddBefore, skipRefreshingAndEvents, space);
		}

		public CurvySplineSegment InsertAfter(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
		{
			Vector3 position;
			if ((bool)controlPoint)
			{
				if (IsControlPointASegment(controlPoint))
				{
					position = controlPoint.Interpolate(0.5f, Space.World);
				}
				else
				{
					CurvySplineSegment nextControlPoint = GetNextControlPoint(controlPoint);
					position = (nextControlPoint ? nextControlPoint.transform.position.LerpUnclamped(controlPoint.transform.position, 0.5f) : controlPoint.transform.position);
				}
			}
			else
			{
				position = base.transform.position;
			}
			return InsertAfter(controlPoint, position, skipRefreshingAndEvents);
		}

		public CurvySplineSegment InsertAfter([CanBeNull] CurvySplineSegment controlPoint, Vector3 position, bool skipRefreshingAndEvents = false, Space space = Space.World)
		{
			return InsertAt(controlPoint, position, ((object)controlPoint != null) ? (GetControlPointIndex(controlPoint) + 1) : ControlPoints.Count, CurvyControlPointEventArgs.ModeEnum.AddAfter, skipRefreshingAndEvents, space);
		}

		public void Clear()
		{
			OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);
			for (int num = ControlPointCount - 1; num >= 0; num--)
			{
				if (UsePooling && Application.isPlaying)
				{
					CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
					if (instance == null)
					{
						DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
					}
					else
					{
						instance.ControlPointPool.Push(ControlPoints[num]);
					}
				}
				else
				{
					UnityEngine.Object.Destroy(ControlPoints[num].gameObject);
				}
			}
			ClearControlPoints();
			Refresh();
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
		}

		public void Delete(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents = false)
		{
			Delete(controlPoint, skipRefreshingAndEvents, isUndoableDeletion: true);
		}

		public void Delete(CurvySplineSegment controlPoint, bool skipRefreshingAndEvents, bool isUndoableDeletion)
		{
			if (!controlPoint)
			{
				return;
			}
			if (!skipRefreshingAndEvents)
			{
				OnBeforeControlPointDeleteEvent(new CurvyControlPointEventArgs(this, this, controlPoint, CurvyControlPointEventArgs.ModeEnum.Delete));
			}
			RemoveControlPoint(controlPoint);
			controlPoint.transform.SetAsLastSibling();
			if (UsePooling && Application.isPlaying)
			{
				CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
				if (instance == null)
				{
					DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
				}
				else
				{
					instance.ControlPointPool.Push(controlPoint);
				}
			}
			else
			{
				UnityEngine.Object.Destroy(controlPoint.gameObject);
			}
			if (!skipRefreshingAndEvents)
			{
				Refresh();
				OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			}
		}

		public Vector3[] GetApproximation(Space space = Space.Self)
		{
			Vector3[] array = new Vector3[CacheSize + 1];
			int num = 0;
			for (int i = 0; i < Count; i++)
			{
				this[i].Approximation.CopyTo(array, num);
				num += Mathf.Max(0, this[i].Approximation.Length - 1);
			}
			if (space == Space.World)
			{
				Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = localToWorldMatrix.MultiplyPoint3x4(array[j]);
				}
			}
			return array;
		}

		public Vector3[] GetApproximation(float fromTF, float toTF, bool includeEndPoint = true, Space space = Space.Self)
		{
			float localF;
			CurvySplineSegment curvySplineSegment = TFToSegment(fromTF, out localF);
			float frag;
			int num = curvySplineSegment.getApproximationIndexINTERNAL(localF, out frag);
			float localF2;
			CurvySplineSegment curvySplineSegment2 = TFToSegment(toTF, out localF2);
			float frag2;
			int approximationIndexINTERNAL = curvySplineSegment2.getApproximationIndexINTERNAL(localF2, out frag2);
			CurvySplineSegment curvySplineSegment3 = curvySplineSegment;
			Vector3[] array = new Vector3[1] { Vector3.Lerp(curvySplineSegment3.Approximation[num], curvySplineSegment3.Approximation[num + 1], frag) };
			while ((bool)curvySplineSegment3 && (object)curvySplineSegment3 != curvySplineSegment2)
			{
				array = array.AddRange(curvySplineSegment3.Approximation.SubArray(num + 1, curvySplineSegment3.Approximation.Length - 1));
				num = 1;
				curvySplineSegment3 = curvySplineSegment3.Spline.GetNextSegment(curvySplineSegment3);
			}
			if ((object)curvySplineSegment3 != null)
			{
				int num2 = ((!(curvySplineSegment == curvySplineSegment3)) ? 1 : (num + 1));
				array = array.AddRange(curvySplineSegment3.Approximation.SubArray(num2, approximationIndexINTERNAL - num2));
				if (includeEndPoint && (frag2 > 0f || frag2 < 1f))
				{
					array = array.Add(Vector3.Lerp(curvySplineSegment3.Approximation[approximationIndexINTERNAL], curvySplineSegment3.Approximation[approximationIndexINTERNAL + 1], frag2));
				}
			}
			if (space == Space.World)
			{
				Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = localToWorldMatrix.MultiplyPoint3x4(array[i]);
				}
			}
			return array;
		}

		[Obsolete("Use GetApproximation instead")]
		public Vector3[] GetApproximationPoints(float fromTF, float toTF, bool includeEndPoint = true, Space space = Space.Self)
		{
			return GetApproximation(fromTF, toTF, includeEndPoint, space);
		}

		public Vector3[] GetApproximationT(Space space = Space.Self)
		{
			Vector3[] array = new Vector3[CacheSize + 1];
			int num = 0;
			for (int i = 0; i < Count; i++)
			{
				this[i].ApproximationT.CopyTo(array, num);
				num += Mathf.Max(0, this[i].ApproximationT.Length - 1);
			}
			if (space == Space.World)
			{
				Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = localToWorldMatrix.MultiplyVector(array[j]);
				}
			}
			return array;
		}

		public Vector3[] GetApproximationUpVectors(Space space = Space.Self)
		{
			Vector3[] array = new Vector3[CacheSize + 1];
			int num = 0;
			for (int i = 0; i < Count; i++)
			{
				this[i].ApproximationUp.CopyTo(array, num);
				num += Mathf.Max(0, this[i].ApproximationUp.Length - 1);
			}
			if (space == Space.World)
			{
				Matrix4x4 localToWorldMatrix = base.transform.localToWorldMatrix;
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = localToWorldMatrix.MultiplyVector(array[j]);
				}
			}
			return array;
		}

		public float GetNearestPointTF(Vector3 localPosition)
		{
			Vector3 nearestPoint;
			CurvySplineSegment nearestSegment;
			float nearestPointLocalF;
			return GetNearestPointTF(localPosition, out nearestPoint, out nearestSegment, out nearestPointLocalF);
		}

		public float GetNearestPointTF(Vector3 position, Space space)
		{
			Vector3 nearestPoint;
			CurvySplineSegment nearestSegment;
			float nearestPointLocalF;
			return GetNearestPointTF(position, out nearestPoint, out nearestSegment, out nearestPointLocalF, 0, -1, space);
		}

		public float GetNearestPointTF(Vector3 localPosition, out Vector3 nearestPoint)
		{
			CurvySplineSegment nearestSegment;
			float nearestPointLocalF;
			return GetNearestPointTF(localPosition, out nearestPoint, out nearestSegment, out nearestPointLocalF);
		}

		public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, Space space)
		{
			CurvySplineSegment nearestSegment;
			float nearestPointLocalF;
			return GetNearestPointTF(position, out nearestPoint, out nearestSegment, out nearestPointLocalF, 0, -1, space);
		}

		public float GetNearestPointTF(Vector3 position, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
		{
			Vector3 nearestPoint;
			CurvySplineSegment nearestSegment;
			float nearestPointLocalF;
			return GetNearestPointTF(position, out nearestPoint, out nearestSegment, out nearestPointLocalF, searchStartSegmentIndex, searchEndSegmentIndex, space);
		}

		public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
		{
			CurvySplineSegment nearestSegment;
			float nearestPointLocalF;
			return GetNearestPointTF(position, out nearestPoint, out nearestSegment, out nearestPointLocalF, searchStartSegmentIndex, searchEndSegmentIndex, space);
		}

		public float GetNearestPointTF(Vector3 position, out Vector3 nearestPoint, [CanBeNull] out CurvySplineSegment nearestSegment, out float nearestPointLocalF, int searchStartSegmentIndex = 0, int searchEndSegmentIndex = -1, Space space = Space.Self)
		{
			nearestPoint = Vector3.zero;
			if (Count == 0)
			{
				nearestSegment = null;
				nearestPointLocalF = -1f;
				return -1f;
			}
			float num = float.MaxValue;
			float num2 = 0f;
			CurvySplineSegment curvySplineSegment = null;
			if (searchEndSegmentIndex == -1)
			{
				searchEndSegmentIndex = Count - 1;
			}
			searchStartSegmentIndex = Mathf.Clamp(searchStartSegmentIndex, 0, Count - 1);
			searchEndSegmentIndex = Mathf.Clamp(searchEndSegmentIndex + 1, searchStartSegmentIndex + 1, Count);
			for (int i = searchStartSegmentIndex; i < searchEndSegmentIndex; i++)
			{
				float nearestPointF = this[i].GetNearestPointF(position, space);
				Vector3 vector = this[i].Interpolate(nearestPointF, space);
				float sqrMagnitude = (vector - position).sqrMagnitude;
				if (sqrMagnitude <= num)
				{
					curvySplineSegment = this[i];
					num2 = nearestPointF;
					nearestPoint = vector;
					num = sqrMagnitude;
				}
			}
			nearestSegment = curvySplineSegment;
			nearestPointLocalF = num2;
			return curvySplineSegment.LocalFToTF(num2);
		}

		public void Refresh()
		{
			ProcessDirtyControlPoints();
			OnRefreshEvent(defaultSplineEventArgs);
		}

		public void SetDirtyAll()
		{
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
		}

		public void SetDirtyAll(SplineDirtyingType dirtyingType, bool dirtyConnectedControlPoints)
		{
			allControlPointsAreDirty = true;
			SetDirtyingFlags(dirtyingType);
			if (!dirtyConnectedControlPoints)
			{
				return;
			}
			for (int i = 0; i < ControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[i];
				if (!curvySplineSegment || !curvySplineSegment.Connection)
				{
					continue;
				}
				ReadOnlyCollection<CurvySplineSegment> controlPointsList = curvySplineSegment.Connection.ControlPointsList;
				for (int j = 0; j < controlPointsList.Count; j++)
				{
					CurvySplineSegment curvySplineSegment2 = controlPointsList[j];
					CurvySpline curvySpline = ((curvySplineSegment2 != null) ? curvySplineSegment2.Spline : null);
					if ((bool)curvySpline && curvySpline != this)
					{
						curvySpline.dirtyControlPointsMinimalSet.Add(curvySplineSegment2);
						curvySpline.SetDirtyingFlags(dirtyingType);
					}
				}
			}
		}

		public void SetDirty(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
		{
			SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), ignoreConnectionOfInputControlPoint: false);
		}

		public void SetDirtyPartial(CurvySplineSegment dirtyControlPoint, SplineDirtyingType dirtyingType)
		{
			SetDirty(dirtyControlPoint, dirtyingType, GetPreviousControlPoint(dirtyControlPoint), GetNextControlPoint(dirtyControlPoint), ignoreConnectionOfInputControlPoint: true);
		}

		public Vector3 ToWorldPosition(Vector3 localPosition)
		{
			return cachedTransform.TransformPoint(localPosition);
		}

		public Vector3 ToWorldDirection(Vector3 localDirection)
		{
			return cachedTransform.TransformDirection(localDirection);
		}

		public Vector3 ToLocalPosition(Vector3 worldPosition)
		{
			return cachedTransform.InverseTransformPoint(worldPosition);
		}

		public Vector3 ToLocalDirection(Vector3 localDirection)
		{
			return cachedTransform.InverseTransformDirection(localDirection);
		}

		public void SyncSplineFromHierarchy()
		{
			ClearControlPoints();
			for (int i = 0; i < base.transform.childCount; i++)
			{
				CurvySplineSegment component = base.transform.GetChild(i).GetComponent<CurvySplineSegment>();
				if ((bool)component)
				{
					AddControlPoint(component);
				}
			}
		}

		public bool IsPlanar(out int ignoreAxis)
		{
			bool xplanar;
			bool yplanar;
			bool zplanar;
			bool result = IsPlanar(out xplanar, out yplanar, out zplanar);
			if (xplanar)
			{
				ignoreAxis = 0;
				return result;
			}
			if (yplanar)
			{
				ignoreAxis = 1;
				return result;
			}
			ignoreAxis = 2;
			return result;
		}

		public bool IsPlanar(out bool xplanar, out bool yplanar, out bool zplanar)
		{
			xplanar = true;
			yplanar = true;
			zplanar = true;
			if (ControlPointCount == 0)
			{
				return true;
			}
			Vector3 localPosition = ControlPoints[0].transform.localPosition;
			for (int i = 1; i < ControlPointCount; i++)
			{
				if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.x, localPosition.x))
				{
					xplanar = false;
				}
				if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.y, localPosition.y))
				{
					yplanar = false;
				}
				if (!Mathf.Approximately(ControlPoints[i].transform.localPosition.z, localPosition.z))
				{
					zplanar = false;
				}
				if (!xplanar && !yplanar && !zplanar)
				{
					return false;
				}
			}
			return true;
		}

		public bool IsPlanar(CurvyPlane plane)
		{
			switch (plane)
			{
			case CurvyPlane.XY:
			{
				for (int j = 0; j < ControlPointCount; j++)
				{
					if (ControlPoints[j].transform.localPosition.z != 0f)
					{
						return false;
					}
				}
				break;
			}
			case CurvyPlane.XZ:
			{
				for (int k = 0; k < ControlPointCount; k++)
				{
					if (ControlPoints[k].transform.localPosition.y != 0f)
					{
						return false;
					}
				}
				break;
			}
			case CurvyPlane.YZ:
			{
				for (int i = 0; i < ControlPointCount; i++)
				{
					if (ControlPoints[i].transform.localPosition.x != 0f)
					{
						return false;
					}
				}
				break;
			}
			}
			return true;
		}

		public void MakePlanar(CurvyPlane plane)
		{
			switch (plane)
			{
			case CurvyPlane.XY:
			{
				for (int j = 0; j < ControlPointCount; j++)
				{
					if (ControlPoints[j].transform.localPosition.z != 0f)
					{
						ControlPoints[j].SetLocalPosition(new Vector3(ControlPoints[j].transform.localPosition.x, ControlPoints[j].transform.localPosition.y, 0f));
					}
				}
				break;
			}
			case CurvyPlane.XZ:
			{
				for (int k = 0; k < ControlPointCount; k++)
				{
					if (ControlPoints[k].transform.localPosition.y != 0f)
					{
						ControlPoints[k].SetLocalPosition(new Vector3(ControlPoints[k].transform.localPosition.x, 0f, ControlPoints[k].transform.localPosition.z));
					}
				}
				break;
			}
			case CurvyPlane.YZ:
			{
				for (int i = 0; i < ControlPointCount; i++)
				{
					if (ControlPoints[i].transform.localPosition.x != 0f)
					{
						ControlPoints[i].SetLocalPosition(new Vector3(0f, ControlPoints[i].transform.localPosition.y, ControlPoints[i].transform.localPosition.z));
					}
				}
				break;
			}
			default:
				throw new NotImplementedException();
			}
			Refresh();
		}

		public void MakePlanar(int axis)
		{
			Vector3 localPosition = ControlPoints[0].transform.localPosition;
			for (int i = 1; i < ControlPointCount; i++)
			{
				Vector3 localPosition2 = ControlPoints[i].transform.localPosition;
				switch (axis)
				{
				case 0:
					localPosition2.x = localPosition.x;
					break;
				case 1:
					localPosition2.y = localPosition.y;
					break;
				case 2:
					localPosition2.z = localPosition.z;
					break;
				}
				ControlPoints[i].transform.localPosition = localPosition2;
			}
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
			Refresh();
		}

		public void Subdivide(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
		{
			if (!fromCP)
			{
				fromCP = FirstVisibleControlPoint;
			}
			if (!toCP)
			{
				toCP = LastVisibleControlPoint;
			}
			if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
			{
				UnityEngine.Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
				return;
			}
			int num = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
			int num2 = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), num + 1, ControlPointCount - 1);
			if (num2 - num < 1)
			{
				UnityEngine.Debug.Log("CurvySpline.Subdivide: Not a valid range selection!");
				return;
			}
			OnBeforeControlPointAddEvent(defaultAddAfterEventArgs);
			_ = base.transform.localToWorldMatrix;
			Dictionary<int, Vector3> dictionary = new Dictionary<int, Vector3>();
			for (int num3 = num2 - 1; num3 >= num; num3--)
			{
				dictionary[num3] = ControlPoints[num3].Interpolate(0.5f);
			}
			for (int num4 = num2 - 1; num4 >= num; num4--)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[num4];
				CurvySplineSegment curvySplineSegment2 = ControlPoints[num4 + 1];
				CurvySplineSegment curvySplineSegment3 = InsertAfter(ControlPoints[num4], dictionary[num4], skipRefreshingAndEvents: true, Space.Self);
				if (Interpolation == CurvyInterpolation.Bezier)
				{
					Vector3 position = curvySplineSegment.transform.position;
					Vector3 handleOutPosition = curvySplineSegment.HandleOutPosition;
					Vector3 handleInPosition = curvySplineSegment2.HandleInPosition;
					Vector3 position2 = curvySplineSegment2.transform.position;
					Vector3 vector = (position + handleOutPosition) / 2f;
					Vector3 vector2 = (handleOutPosition + handleInPosition) / 2f;
					Vector3 vector3 = (handleInPosition + position2) / 2f;
					Vector3 handleInPosition2 = (vector + vector2) / 2f;
					Vector3 handleOutPosition2 = (vector2 + vector3) / 2f;
					curvySplineSegment.AutoHandles = false;
					curvySplineSegment.HandleOutPosition = vector;
					curvySplineSegment2.AutoHandles = false;
					curvySplineSegment2.HandleInPosition = vector3;
					curvySplineSegment3.AutoHandles = false;
					curvySplineSegment3.HandleInPosition = handleInPosition2;
					curvySplineSegment3.HandleOutPosition = handleOutPosition2;
				}
			}
			Refresh();
			OnAfterControlPointAddEvent(defaultAddAfterEventArgs);
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
		}

		public void Simplify(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
		{
			if (!fromCP)
			{
				fromCP = FirstVisibleControlPoint;
			}
			if (!toCP)
			{
				toCP = LastVisibleControlPoint;
			}
			if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
			{
				UnityEngine.Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
				return;
			}
			int num = Mathf.Clamp(fromCP.Spline.GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
			int num2 = Mathf.Clamp(toCP.Spline.GetControlPointIndex(toCP), num + 2, ControlPointCount - 1);
			if (num2 - num < 2)
			{
				UnityEngine.Debug.Log("CurvySpline.Simplify: Not a valid range selection!");
				return;
			}
			OnBeforeControlPointDeleteEvent(defaultDeleteEventArgs);
			for (int num3 = num2 - 2; num3 >= num; num3 -= 2)
			{
				Delete(ControlPoints[num3 + 1], skipRefreshingAndEvents: true);
			}
			Refresh();
			OnAfterControlPointChangesEvent(defaultSplineEventArgs);
		}

		public void Equalize(CurvySplineSegment fromCP = null, CurvySplineSegment toCP = null)
		{
			if (!fromCP)
			{
				fromCP = FirstVisibleControlPoint;
			}
			if (!toCP)
			{
				toCP = LastVisibleControlPoint;
			}
			if (fromCP == null || toCP == null || fromCP.Spline != this || toCP.Spline != this)
			{
				UnityEngine.Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
				return;
			}
			int num = Mathf.Clamp(GetControlPointIndex(fromCP), 0, ControlPointCount - 2);
			int num2 = Mathf.Clamp(GetControlPointIndex(toCP), num + 2, ControlPointCount - 1);
			if (num2 - num < 2)
			{
				UnityEngine.Debug.Log("CurvySpline.Equalize: Not a valid range selection!");
				return;
			}
			float num3 = (ControlPoints[num2].Distance - ControlPoints[num].Distance) / (float)(num2 - num);
			float distance = ControlPoints[num].Distance;
			Vector3[] array = new Vector3[num2 - num - 1];
			for (int i = num + 1; i < num2; i++)
			{
				int num4 = i - num - 1;
				array[num4] = InterpolateByDistance(distance + (float)(num4 + 1) * num3);
			}
			for (int j = num + 1; j < num2; j++)
			{
				int num5 = j - num - 1;
				ControlPoints[j].SetLocalPosition(array[num5]);
			}
			Refresh();
		}

		public void Normalize()
		{
			Vector3 localScale = base.transform.localScale;
			if (localScale != Vector3.one)
			{
				base.transform.localScale = Vector3.one;
				for (int i = 0; i < ControlPointCount; i++)
				{
					CurvySplineSegment curvySplineSegment = ControlPoints[i];
					curvySplineSegment.SetLocalPosition(Vector3.Scale(curvySplineSegment.transform.localPosition, localScale));
					curvySplineSegment.HandleIn = Vector3.Scale(curvySplineSegment.HandleIn, localScale);
					curvySplineSegment.HandleOut = Vector3.Scale(curvySplineSegment.HandleOut, localScale);
				}
				Refresh();
			}
		}

		public Vector3 SetPivot(float xRel = 0f, float yRel = 0f, float zRel = 0f, bool preview = false)
		{
			Bounds bounds = Bounds;
			Vector3 vector = new Vector3(bounds.min.x + bounds.size.x * ((xRel + 1f) / 2f), bounds.max.y - bounds.size.y * ((yRel + 1f) / 2f), bounds.min.z + bounds.size.z * ((zRel + 1f) / 2f));
			Vector3 vector2 = base.transform.position - vector;
			if (preview)
			{
				return base.transform.position - vector2;
			}
			for (int i = 0; i < ControlPoints.Count; i++)
			{
				ControlPoints[i].transform.position += vector2;
			}
			base.transform.position -= vector2;
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
			return base.transform.position;
		}

		public void Flip()
		{
			if (ControlPointCount <= 1)
			{
				return;
			}
			switch (Interpolation)
			{
			case CurvyInterpolation.TCB:
			{
				Bias *= -1f;
				for (int num2 = ControlPointCount - 1; num2 >= 0; num2--)
				{
					CurvySplineSegment curvySplineSegment2 = ControlPoints[num2];
					int num3 = num2 - 1;
					if (num3 >= 0)
					{
						CurvySplineSegment curvySplineSegment3 = ControlPoints[num3];
						curvySplineSegment2.EndBias = curvySplineSegment3.StartBias * -1f;
						curvySplineSegment2.EndContinuity = curvySplineSegment3.StartContinuity;
						curvySplineSegment2.EndTension = curvySplineSegment3.StartTension;
						curvySplineSegment2.StartBias = curvySplineSegment3.EndBias * -1f;
						curvySplineSegment2.StartContinuity = curvySplineSegment3.EndContinuity;
						curvySplineSegment2.StartTension = curvySplineSegment3.EndTension;
						curvySplineSegment2.OverrideGlobalBias = curvySplineSegment3.OverrideGlobalBias;
						curvySplineSegment2.OverrideGlobalContinuity = curvySplineSegment3.OverrideGlobalContinuity;
						curvySplineSegment2.OverrideGlobalTension = curvySplineSegment3.OverrideGlobalTension;
						curvySplineSegment2.SynchronizeTCB = curvySplineSegment3.SynchronizeTCB;
					}
				}
				break;
			}
			case CurvyInterpolation.Bezier:
			{
				for (int num = ControlPointCount - 1; num >= 0; num--)
				{
					CurvySplineSegment curvySplineSegment = ControlPoints[num];
					Vector3 handleIn = curvySplineSegment.HandleIn;
					curvySplineSegment.HandleIn = curvySplineSegment.HandleOut;
					curvySplineSegment.HandleOut = handleIn;
				}
				break;
			}
			}
			ReverseControlPoints();
			Refresh();
		}

		public void MoveControlPoints(int startIndex, int count, CurvySplineSegment destCP)
		{
			if ((bool)destCP && !(this == destCP.Spline) && destCP.Spline.GetControlPointIndex(destCP) != -1)
			{
				startIndex = Mathf.Clamp(startIndex, 0, ControlPointCount - 1);
				count = Mathf.Clamp(count, startIndex, ControlPointCount - startIndex);
				for (int i = 0; i < count; i++)
				{
					CurvySplineSegment curvySplineSegment = ControlPoints[startIndex];
					RemoveControlPoint(curvySplineSegment);
					curvySplineSegment.transform.SetParent(destCP.Spline.transform, worldPositionStays: true);
					destCP.Spline.InsertControlPoint(destCP.Spline.GetControlPointIndex(destCP) + i + 1, curvySplineSegment);
				}
				Refresh();
				destCP.Spline.Refresh();
			}
		}

		public void JoinWith(CurvySplineSegment destCP)
		{
			if (!(destCP.Spline == this))
			{
				MoveControlPoints(0, ControlPointCount, destCP);
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public CurvySpline Split(CurvySplineSegment controlPoint)
		{
			CurvySpline curvySpline = Create(this);
			curvySpline.transform.SetParent(base.transform.parent, worldPositionStays: true);
			curvySpline.name = base.name + "_parted";
			int segmentIndex = GetSegmentIndex(controlPoint);
			List<CurvySplineSegment> list = new List<CurvySplineSegment>(ControlPointCount - segmentIndex);
			for (int i = segmentIndex; i < ControlPointCount; i++)
			{
				list.Add(ControlPoints[i]);
			}
			for (int j = 0; j < list.Count; j++)
			{
				CurvySplineSegment curvySplineSegment = list[j];
				RemoveControlPoint(curvySplineSegment);
				if (Application.isPlaying)
				{
					curvySplineSegment.transform.SetParent(curvySpline.transform, worldPositionStays: true);
				}
				curvySpline.AddControlPoint(curvySplineSegment);
			}
			Refresh();
			curvySpline.Refresh();
			return curvySpline;
		}

		public void SetFirstControlPoint(CurvySplineSegment controlPoint)
		{
			short controlPointIndex = GetControlPointIndex(controlPoint);
			CurvySplineSegment[] array = new CurvySplineSegment[controlPointIndex];
			for (int i = 0; i < controlPointIndex; i++)
			{
				array[i] = ControlPoints[i];
			}
			foreach (CurvySplineSegment item in array)
			{
				RemoveControlPoint(item);
				AddControlPoint(item);
			}
			Refresh();
		}

		public bool IsControlPointAnOrientationAnchor(CurvySplineSegment controlPoint)
		{
			if (IsControlPointVisible(controlPoint))
			{
				if (!controlPoint.SerializedOrientationAnchor)
				{
					if (!(controlPoint == FirstVisibleControlPoint))
					{
						return controlPoint == LastVisibleControlPoint;
					}
					return true;
				}
				return true;
			}
			return false;
		}

		public bool CanControlPointHaveFollowUp(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().CanHaveFollowUp;
		}

		public short GetControlPointIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().ControlPointIndex;
		}

		public short GetSegmentIndex(CurvySplineSegment segment)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return segment.GetExtrinsicPropertiesINTERNAL().SegmentIndex;
		}

		[CanBeNull]
		public CurvySplineSegment GetNextControlPoint(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			short nextControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
			if (nextControlPointIndex != -1)
			{
				return ControlPoints[nextControlPointIndex];
			}
			return null;
		}

		[CanBeNull]
		public short GetNextControlPointIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex;
		}

		[CanBeNull]
		public CurvySplineSegment GetNextControlPointUsingFollowUp(CurvySplineSegment controlPoint)
		{
			if (!(controlPoint.FollowUp != null) || (object)LastVisibleControlPoint != controlPoint)
			{
				return GetNextControlPoint(controlPoint);
			}
			return GetFollowUpHeadingControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading);
		}

		[CanBeNull]
		public CurvySplineSegment GetPreviousControlPoint(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			short previousControlPointIndex = controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
			if (previousControlPointIndex != -1)
			{
				return ControlPoints[previousControlPointIndex];
			}
			return null;
		}

		[CanBeNull]
		public short GetPreviousControlPointIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().PreviousControlPointIndex;
		}

		[CanBeNull]
		public CurvySplineSegment GetPreviousControlPointUsingFollowUp(CurvySplineSegment controlPoint)
		{
			if (!(controlPoint.FollowUp != null) || (object)FirstVisibleControlPoint != controlPoint)
			{
				return GetPreviousControlPoint(controlPoint);
			}
			return GetFollowUpHeadingControlPoint(controlPoint.FollowUp, controlPoint.FollowUpHeading);
		}

		[CanBeNull]
		public CurvySplineSegment GetNextSegment(CurvySplineSegment segment)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			CurvySplineSegment.ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL = segment.GetExtrinsicPropertiesINTERNAL();
			if (!extrinsicPropertiesINTERNAL.NextControlPointIsSegment)
			{
				return null;
			}
			return ControlPoints[extrinsicPropertiesINTERNAL.NextControlPointIndex];
		}

		[CanBeNull]
		public CurvySplineSegment GetPreviousSegment(CurvySplineSegment segment)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			CurvySplineSegment.ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL = segment.GetExtrinsicPropertiesINTERNAL();
			if (!extrinsicPropertiesINTERNAL.PreviousControlPointIsSegment)
			{
				return null;
			}
			return ControlPoints[extrinsicPropertiesINTERNAL.PreviousControlPointIndex];
		}

		public bool IsControlPointASegment(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().IsSegment;
		}

		public bool IsControlPointVisible(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().IsVisible;
		}

		public short GetControlPointOrientationAnchorIndex(CurvySplineSegment controlPoint)
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			return controlPoint.GetExtrinsicPropertiesINTERNAL().OrientationAnchorIndex;
		}

		public void SetFromString(string fieldAndValue)
		{
			string[] array = fieldAndValue.Split('=');
			if (array.Length != 2)
			{
				return;
			}
			FieldInfo fieldInfo = GetType().FieldByName(array[0], includeInherited: true);
			if (fieldInfo != null)
			{
				try
				{
					if (fieldInfo.FieldType.IsEnum)
					{
						fieldInfo.SetValue(this, Enum.Parse(fieldInfo.FieldType, array[1]));
					}
					else
					{
						fieldInfo.SetValue(this, Convert.ChangeType(array[1], fieldInfo.FieldType, CultureInfo.InvariantCulture));
					}
					return;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogWarning(base.name + ".SetFromString(): " + ex.ToString());
					return;
				}
			}
			PropertyInfo propertyInfo = GetType().PropertyByName(array[0], includeInherited: true);
			if (!(propertyInfo != null))
			{
				return;
			}
			try
			{
				if (propertyInfo.PropertyType.IsEnum)
				{
					propertyInfo.SetValue(this, Enum.Parse(propertyInfo.PropertyType, array[1]), null);
				}
				else
				{
					propertyInfo.SetValue(this, Convert.ChangeType(array[1], propertyInfo.PropertyType, CultureInfo.InvariantCulture), null);
				}
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogWarning(base.name + ".SetFromString(): " + ex2.ToString());
			}
		}

		private void Awake()
		{
			cachedTransform = base.transform;
			if (UsePooling)
			{
				_ = DTSingleton<CurvyGlobalManager>.Instance;
			}
		}

		private void OnEnable()
		{
			cachedTransform = base.transform;
			SyncSplineFromHierarchy();
			if (isStarted)
			{
				Initialize();
			}
		}

		public void Start()
		{
			if (!isStarted)
			{
				Initialize();
				isStarted = true;
			}
			Refresh();
		}

		private void OnDisable()
		{
			mIsInitialized = false;
		}

		private void OnDestroy()
		{
			if (true)
			{
				if (UsePooling && Application.isPlaying)
				{
					CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
					if (instance != null)
					{
						for (int i = 0; i < ControlPointCount; i++)
						{
							instance.ControlPointPool.Push(ControlPoints[i]);
						}
					}
				}
				else
				{
					mThreadWorker.Dispose();
				}
			}
			ClearControlPoints();
			isStarted = false;
		}

		protected virtual void Reset()
		{
			Interpolation = CurvyGlobalManager.DefaultInterpolation;
			RestrictTo2D = false;
			AutoHandleDistance = 0.39f;
			Closed = false;
			AutoEndTangents = true;
			Orientation = CurvyOrientation.Dynamic;
			GizmoColor = CurvyGlobalManager.DefaultGizmoColor;
			GizmoSelectionColor = CurvyGlobalManager.DefaultGizmoSelectionColor;
			CacheDensity = 50;
			MaxPointsPerUnit = 8f;
			CheckTransform = true;
			Tension = 0f;
			Continuity = 0f;
			Bias = 0f;
			SyncSplineFromHierarchy();
		}

		private void Update()
		{
			if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.Update)
			{
				doUpdate();
			}
		}

		private void LateUpdate()
		{
			if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.LateUpdate)
			{
				doUpdate();
			}
		}

		private void FixedUpdate()
		{
			if (Application.isPlaying && UpdateIn == CurvyUpdateMethod.FixedUpdate)
			{
				doUpdate();
			}
		}

		private void Initialize()
		{
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: false);
			ProcessDirtyControlPoints();
			UpdatedLastProcessedGlobalCoordinates();
			mIsInitialized = true;
		}

		private void doUpdate()
		{
			int controlPointCount = ControlPointCount;
			for (int i = 0; i < controlPointCount; i++)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[i];
				if (curvySplineSegment.AutoBakeOrientation && curvySplineSegment.ApproximationUp.Length != 0)
				{
					curvySplineSegment.BakeOrientationToTransform();
				}
			}
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			globalCoordinatesChangedThisFrame = false;
			if (cachedTransform.hasChanged)
			{
				cachedTransform.hasChanged = false;
				if (cachedTransform.position.NotApproximately(lastProcessedPosition) || cachedTransform.rotation.DifferentOrientation(lastProcessedRotation) || cachedTransform.lossyScale != lastProcessedScale)
				{
					globalCoordinatesChangedThisFrame = true;
					UpdatedLastProcessedGlobalCoordinates();
					mBounds = null;
					for (int j = 0; j < controlPointCount; j++)
					{
						ControlPoints[j].ClearBoundsINTERNAL();
					}
				}
			}
			if ((CheckTransform || !Application.isPlaying) && !allControlPointsAreDirty)
			{
				for (int k = 0; k < controlPointCount; k++)
				{
					CurvySplineSegment curvySplineSegment2 = ControlPoints[k];
					bool hasUnprocessedLocalPosition = curvySplineSegment2.HasUnprocessedLocalPosition;
					if (hasUnprocessedLocalPosition || (curvySplineSegment2.HasUnprocessedLocalOrientation && curvySplineSegment2.OrientatinInfluencesSpline))
					{
						curvySplineSegment2.Spline.SetDirty(curvySplineSegment2, hasUnprocessedLocalPosition ? SplineDirtyingType.Everything : SplineDirtyingType.OrientationOnly);
					}
				}
			}
			if (Dirty)
			{
				Refresh();
			}
			else if (sendOnRefreshEventNextUpdate)
			{
				OnRefreshEvent(defaultSplineEventArgs);
			}
			sendOnRefreshEventNextUpdate = false;
			if (globalCoordinatesChangedThisFrame && OnGlobalCoordinatesChanged != null)
			{
				OnGlobalCoordinatesChanged(this);
			}
		}

		private bool canHaveManualEndCP()
		{
			if (!Closed)
			{
				if (Interpolation != CurvyInterpolation.CatmullRom)
				{
					return Interpolation == CurvyInterpolation.TCB;
				}
				return true;
			}
			return false;
		}

		private void SetDirty(CurvySplineSegment controlPoint, SplineDirtyingType dirtyingType, CurvySplineSegment previousControlPoint, CurvySplineSegment nextControlPoint, bool ignoreConnectionOfInputControlPoint)
		{
			if ((object)this != controlPoint.Spline)
			{
				throw new ArgumentException(string.Format(InvalidCPErrorMessage, controlPoint, base.name));
			}
			if (!ignoreConnectionOfInputControlPoint && (bool)controlPoint.Connection)
			{
				ReadOnlyCollection<CurvySplineSegment> controlPointsList = controlPoint.Connection.ControlPointsList;
				for (int i = 0; i < controlPointsList.Count; i++)
				{
					CurvySplineSegment curvySplineSegment = controlPointsList[i];
					CurvySpline spline = curvySplineSegment.Spline;
					if ((bool)spline)
					{
						spline.dirtyControlPointsMinimalSet.Add(curvySplineSegment);
						spline.SetDirtyingFlags(dirtyingType);
					}
				}
			}
			else
			{
				dirtyControlPointsMinimalSet.Add(controlPoint);
				SetDirtyingFlags(dirtyingType);
			}
			if ((bool)previousControlPoint && (bool)previousControlPoint.Connection)
			{
				ReadOnlyCollection<CurvySplineSegment> controlPointsList2 = previousControlPoint.Connection.ControlPointsList;
				for (int j = 0; j < controlPointsList2.Count; j++)
				{
					CurvySplineSegment curvySplineSegment2 = controlPointsList2[j];
					CurvySpline spline2 = curvySplineSegment2.Spline;
					if ((bool)spline2 && curvySplineSegment2.FollowUp == previousControlPoint)
					{
						spline2.dirtyControlPointsMinimalSet.Add(curvySplineSegment2);
						spline2.SetDirtyingFlags(dirtyingType);
					}
				}
			}
			if (!nextControlPoint || !nextControlPoint.Connection)
			{
				return;
			}
			ReadOnlyCollection<CurvySplineSegment> controlPointsList3 = nextControlPoint.Connection.ControlPointsList;
			for (int k = 0; k < controlPointsList3.Count; k++)
			{
				CurvySplineSegment curvySplineSegment3 = controlPointsList3[k];
				CurvySpline spline3 = curvySplineSegment3.Spline;
				if ((bool)spline3 && curvySplineSegment3.FollowUp == nextControlPoint)
				{
					spline3.dirtyControlPointsMinimalSet.Add(curvySplineSegment3);
					spline3.SetDirtyingFlags(dirtyingType);
				}
			}
		}

		private void SetDirtyingFlags(SplineDirtyingType dirtyingType)
		{
			mDirtyCurve = mDirtyCurve || dirtyingType == SplineDirtyingType.Everything;
			mDirtyOrientation = true;
			if (mDirtyCurve)
			{
				mCacheSize = -1;
				length = -1f;
				mBounds = null;
			}
		}

		private void ReverseControlPoints()
		{
			ControlPoints.Reverse();
			InvalidateControlPointsRelationshipCacheINTERNAL();
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
		}

		private static short GetNextControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
		{
			if (isSplineClosed && controlPointsCount <= 1)
			{
				return -1;
			}
			if (controlPointIndex + 1 < controlPointsCount)
			{
				return (short)(controlPointIndex + 1);
			}
			return (short)((!isSplineClosed) ? (-1) : 0);
		}

		private static short GetPreviousControlPointIndex(short controlPointIndex, bool isSplineClosed, int controlPointsCount)
		{
			if (isSplineClosed && controlPointsCount <= 1)
			{
				return -1;
			}
			if (controlPointIndex - 1 >= 0)
			{
				return (short)(controlPointIndex - 1);
			}
			return (short)(isSplineClosed ? (controlPointsCount - 1) : (-1));
		}

		private static bool IsControlPointASegment(int controlPointIndex, int controlPointCount, bool isClosed, bool notAutoEndTangentsAndIsCatmullRomOrTCB)
		{
			if (!isClosed || controlPointCount <= 1)
			{
				if (!notAutoEndTangentsAndIsCatmullRomOrTCB)
				{
					return controlPointIndex < controlPointCount - 1;
				}
				if (controlPointIndex > 0)
				{
					return controlPointIndex < controlPointCount - 2;
				}
				return false;
			}
			return true;
		}

		private void AddControlPoint(CurvySplineSegment item)
		{
			ControlPoints.Add(item);
			item.LinkToSpline(this);
			InvalidateControlPointsRelationshipCacheINTERNAL();
			short previousControlPointIndex = GetPreviousControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
			short nextControlPointIndex = GetNextControlPointIndex((short)(ControlPoints.Count - 1), Closed, ControlPoints.Count);
			SetDirty(item, SplineDirtyingType.Everything, (previousControlPointIndex != -1) ? ControlPoints[previousControlPointIndex] : null, (nextControlPointIndex != -1) ? ControlPoints[nextControlPointIndex] : null, ignoreConnectionOfInputControlPoint: false);
		}

		private void InsertControlPoint(int index, CurvySplineSegment item)
		{
			ControlPoints.Insert(index, item);
			item.LinkToSpline(this);
			InvalidateControlPointsRelationshipCacheINTERNAL();
			short previousControlPointIndex = GetPreviousControlPointIndex((short)index, Closed, ControlPoints.Count);
			short nextControlPointIndex = GetNextControlPointIndex((short)index, Closed, ControlPoints.Count);
			SetDirty(item, SplineDirtyingType.Everything, (previousControlPointIndex == -1) ? null : ControlPoints[previousControlPointIndex], (nextControlPointIndex == -1) ? null : ControlPoints[nextControlPointIndex], ignoreConnectionOfInputControlPoint: false);
		}

		private void RemoveControlPoint(CurvySplineSegment item)
		{
			int controlPointIndex = GetControlPointIndex(item);
			if (ControlPoints.Count == 1)
			{
				SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
			}
			else
			{
				short previousControlPointIndex = GetPreviousControlPointIndex((short)controlPointIndex, Closed, ControlPoints.Count);
				short nextControlPointIndex = GetNextControlPointIndex((short)controlPointIndex, Closed, ControlPoints.Count);
				if (previousControlPointIndex != -1)
				{
					SetDirty(ControlPoints[previousControlPointIndex], SplineDirtyingType.Everything);
				}
				if (nextControlPointIndex != -1)
				{
					SetDirty(ControlPoints[nextControlPointIndex], SplineDirtyingType.Everything);
				}
			}
			ControlPoints.RemoveAt(controlPointIndex);
			dirtyControlPointsMinimalSet.Remove(item);
			if (item.Spline == this)
			{
				item.UnlinkFromSpline();
			}
			InvalidateControlPointsRelationshipCacheINTERNAL();
		}

		private void ClearControlPoints()
		{
			SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
			for (int i = 0; i < ControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = ControlPoints[i];
				if ((bool)curvySplineSegment && curvySplineSegment.Spline == this)
				{
					curvySplineSegment.UnlinkFromSpline();
				}
			}
			ControlPoints.Clear();
			dirtyControlPointsMinimalSet.Clear();
			InvalidateControlPointsRelationshipCacheINTERNAL();
		}

		internal void InvalidateControlPointsRelationshipCacheINTERNAL()
		{
			if (isCpsRelationshipCacheValid)
			{
				lock (controlPointsRelationshipCacheLock)
				{
					isCpsRelationshipCacheValid = false;
					firstSegment = (lastSegment = (firstVisibleControlPoint = (lastVisibleControlPoint = null)));
				}
			}
		}

		private void RebuildControlPointsRelationshipCache(bool fixNonCoherentControlPoints)
		{
			lock (controlPointsRelationshipCacheLock)
			{
				if (isCpsRelationshipCacheValid)
				{
					return;
				}
				int count = ControlPoints.Count;
				mSegments.Clear();
				mSegments.Capacity = count;
				if (count > 0)
				{
					CurvySplineSegment curvySplineSegment = null;
					bool flag = false;
					CurvySplineSegment curvySplineSegment2 = null;
					CurvySplineSegment.ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL = new CurvySplineSegment.ControlPointExtrinsicProperties(isVisible: false, -1, -1, -1, -1, previousControlPointIsSegment: false, nextControlPointIsSegment: false, canHaveFollowUp: false, -1);
					bool closed = Closed;
					bool flag2 = Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB;
					bool notAutoEndTangentsAndIsCatmullRomOrTCB = !AutoEndTangents && flag2;
					short num = 0;
					short num2 = -1;
					for (short num3 = 0; num3 < count; num3++)
					{
						CurvySplineSegment curvySplineSegment3 = ControlPoints[num3];
						short previousControlPointIndex = GetPreviousControlPointIndex(num3, closed, count);
						short nextControlPointIndex = GetNextControlPointIndex(num3, closed, count);
						bool flag3 = IsControlPointASegment(num3, count, closed, notAutoEndTangentsAndIsCatmullRomOrTCB);
						bool flag4 = flag3 || extrinsicPropertiesINTERNAL.IsSegment;
						if (flag4 && (num2 == -1 || curvySplineSegment3.SerializedOrientationAnchor || !flag3))
						{
							num2 = num3;
						}
						bool flag5 = flag4 && (nextControlPointIndex == -1 || previousControlPointIndex == -1);
						extrinsicPropertiesINTERNAL = new CurvySplineSegment.ControlPointExtrinsicProperties(flag4, (short)(flag3 ? num : (-1)), num3, previousControlPointIndex, nextControlPointIndex, previousControlPointIndex != -1 && IsControlPointASegment(previousControlPointIndex, count, closed, notAutoEndTangentsAndIsCatmullRomOrTCB), nextControlPointIndex != -1 && IsControlPointASegment(nextControlPointIndex, count, closed, notAutoEndTangentsAndIsCatmullRomOrTCB), flag5, (short)(flag4 ? num2 : (-1)));
						curvySplineSegment3.SetExtrinsicPropertiesINTERNAL(extrinsicPropertiesINTERNAL);
						if (flag3)
						{
							mSegments.Add(curvySplineSegment3);
							num++;
							if (!flag)
							{
								flag = true;
								curvySplineSegment = curvySplineSegment3;
							}
							curvySplineSegment2 = curvySplineSegment3;
						}
						if (fixNonCoherentControlPoints && !flag5)
						{
							curvySplineSegment3.UnsetFollowUpWithoutDirtyingINTERNAL();
						}
					}
					firstSegment = curvySplineSegment;
					lastSegment = curvySplineSegment2;
					firstVisibleControlPoint = firstSegment;
					lastVisibleControlPoint = (((object)lastSegment != null) ? ControlPoints[lastSegment.GetExtrinsicPropertiesINTERNAL().NextControlPointIndex] : null);
				}
				else
				{
					firstSegment = (lastSegment = (firstVisibleControlPoint = (lastVisibleControlPoint = null)));
				}
				isCpsRelationshipCacheValid = true;
			}
		}

		private void ProcessDirtyControlPoints()
		{
			if (!isCpsRelationshipCacheValid)
			{
				RebuildControlPointsRelationshipCache(fixNonCoherentControlPoints: true);
			}
			FillDirtyCpsExtendedList();
			dirtyControlPointsMinimalSet.Clear();
			allControlPointsAreDirty = false;
			if (dirtyCpsExtendedList.Count > 0)
			{
				if (!mDirtyOrientation && !mDirtyCurve)
				{
					UnityEngine.Debug.LogError("Invalid dirtying flags");
				}
				PrepareThreadCompatibleData();
				int controlPointCount = ControlPointCount;
				if (mDirtyCurve)
				{
					if (Interpolation == CurvyInterpolation.Bezier)
					{
						for (int i = 0; i < dirtyCpsExtendedList.Count; i++)
						{
							CurvySplineSegment curvySplineSegment = dirtyCpsExtendedList[i];
							if (curvySplineSegment.AutoHandles)
							{
								curvySplineSegment.SetBezierHandles(-1f, setIn: true, setOut: true, noDirtying: true);
							}
						}
					}
					if (UseThreading)
					{
						mThreadWorker.ParralelFor(refreshCurveAction, dirtyCpsExtendedList);
					}
					else
					{
						for (int j = 0; j < dirtyCpsExtendedList.Count; j++)
						{
							dirtyCpsExtendedList[j].refreshCurveINTERNAL();
						}
					}
					if (controlPointCount > 0)
					{
						List<CurvySplineSegment> segments = Segments;
						int count = segments.Count;
						Array.Resize(ref controlPointsDistances, controlPointCount);
						float[] array = controlPointsDistances;
						float num2 = (ControlPoints[0].Distance = 0f);
						array[0] = num2;
						for (int k = 1; k < controlPointCount; k++)
						{
							float[] array2 = controlPointsDistances;
							int num3 = k;
							num2 = (ControlPoints[k].Distance = ControlPoints[k - 1].Distance + ControlPoints[k - 1].Length);
							array2[num3] = num2;
						}
						if (count == 0)
						{
							for (int l = 1; l < controlPointCount; l++)
							{
								ControlPoints[l].TF = 0f;
							}
						}
						else
						{
							float num5 = 1f / (float)count;
							for (int m = 0; m < count; m++)
							{
								segments[m].TF = (float)m * num5;
							}
							if (!AutoEndTangents)
							{
								ControlPoints[0].TF = 0f;
								ControlPoints[1].TF = 0f;
								ControlPoints[controlPointCount - 1].TF = 1f;
								ControlPoints[controlPointCount - 2].TF = 1f;
							}
							else if (!Closed)
							{
								ControlPoints[controlPointCount - 1].TF = 1f;
							}
						}
						for (int n = 0; n < count; n++)
						{
							CurvySplineSegment curvySplineSegment2 = segments[n];
							CurvySplineSegment nextSegment = GetNextSegment(curvySplineSegment2);
							if ((bool)nextSegment)
							{
								curvySplineSegment2.ApproximationT[curvySplineSegment2.CacheSize] = nextSegment.ApproximationT[0];
							}
							else
							{
								GetNextControlPoint(curvySplineSegment2).ApproximationT[0] = curvySplineSegment2.ApproximationT[curvySplineSegment2.CacheSize];
							}
						}
					}
				}
				if (mDirtyOrientation && Count > 0)
				{
					switch (Orientation)
					{
					case CurvyOrientation.None:
					{
						for (int num19 = 0; num19 < dirtyCpsExtendedList.Count; num19++)
						{
							dirtyCpsExtendedList[num19].refreshOrientationNoneINTERNAL();
						}
						break;
					}
					case CurvyOrientation.Static:
						if (UseThreading)
						{
							Action<CurvySplineSegment> action = delegate(CurvySplineSegment controlPoint)
							{
								controlPoint.refreshOrientationStaticINTERNAL();
							};
							mThreadWorker.ParralelFor(action, dirtyCpsExtendedList);
						}
						else
						{
							for (int num20 = 0; num20 < dirtyCpsExtendedList.Count; num20++)
							{
								dirtyCpsExtendedList[num20].refreshOrientationStaticINTERNAL();
							}
						}
						break;
					case CurvyOrientation.Dynamic:
					{
						int num6 = controlPointCount + 1;
						do
						{
							CurvySplineSegment curvySplineSegment3 = dirtyCpsExtendedList[0];
							if (!IsControlPointASegment(curvySplineSegment3))
							{
								curvySplineSegment3.refreshOrientationDynamicINTERNAL(curvySplineSegment3.getOrthoUp0INTERNAL());
								dirtyCpsExtendedList.RemoveAt(0);
								continue;
							}
							short controlPointOrientationAnchorIndex = GetControlPointOrientationAnchorIndex(curvySplineSegment3);
							CurvySplineSegment curvySplineSegment4 = ControlPoints[controlPointOrientationAnchorIndex];
							int num7 = 0;
							short num8 = controlPointOrientationAnchorIndex;
							CurvySplineSegment curvySplineSegment5 = curvySplineSegment4;
							int num9 = 0;
							float num10 = 0f;
							Vector3 vector = curvySplineSegment4.getOrthoUp0INTERNAL();
							do
							{
								num7 += curvySplineSegment5.CacheSize;
								num9++;
								num10 += curvySplineSegment5.Length;
								curvySplineSegment5.refreshOrientationDynamicINTERNAL(vector);
								vector = curvySplineSegment5.ApproximationUp[curvySplineSegment5.ApproximationUp.Length - 1];
								num8 = GetNextControlPointIndex(num8, m_Closed, controlPointCount);
								curvySplineSegment5 = ControlPoints[num8];
							}
							while (!IsControlPointAnOrientationAnchor(curvySplineSegment5));
							short num11 = num8;
							float num12 = vector.AngleSigned(curvySplineSegment5.getOrthoUp0INTERNAL(), curvySplineSegment5.ApproximationT[0]) / (float)num7;
							float num13;
							switch (curvySplineSegment4.Swirl)
							{
							case CurvyOrientationSwirl.Segment:
								num13 = curvySplineSegment4.SwirlTurns * 360f;
								break;
							case CurvyOrientationSwirl.AnchorGroup:
								num13 = curvySplineSegment4.SwirlTurns * 360f / (float)num9;
								break;
							case CurvyOrientationSwirl.AnchorGroupAbs:
								num13 = curvySplineSegment4.SwirlTurns * 360f / num10;
								break;
							case CurvyOrientationSwirl.None:
								num13 = 0f;
								break;
							default:
								num13 = 0f;
								DTLog.LogError("[Curvy] Invalid Swirl value " + curvySplineSegment4.Swirl);
								break;
							}
							float num14 = num12;
							short num15 = controlPointOrientationAnchorIndex;
							bool flag = curvySplineSegment4.Swirl == CurvyOrientationSwirl.AnchorGroupAbs;
							Vector3 vector2 = curvySplineSegment4.ApproximationUp[0];
							do
							{
								CurvySplineSegment curvySplineSegment6 = ControlPoints[num15];
								float num16 = (flag ? (num12 + num13 * curvySplineSegment6.Length / (float)curvySplineSegment6.CacheSize) : (num12 + num13 / (float)curvySplineSegment6.CacheSize));
								Vector3[] approximationT = curvySplineSegment6.ApproximationT;
								Vector3[] approximationUp = curvySplineSegment6.ApproximationUp;
								int num17 = approximationUp.Length;
								approximationUp[0] = vector2;
								for (int num18 = 1; num18 < num17; num18++)
								{
									approximationUp[num18] = Quaternion.AngleAxis(num14, approximationT[num18]) * approximationUp[num18];
									num14 += num16;
								}
								vector2 = approximationUp[num17 - 1];
								dirtyCpsExtendedList.Remove(curvySplineSegment6);
								num15 = GetNextControlPointIndex(num15, m_Closed, controlPointCount);
							}
							while (num15 != num11);
						}
						while (dirtyCpsExtendedList.Count > 0 && num6-- > 0);
						if (num6 <= 0)
						{
							DTLog.LogWarning("[Curvy] Deadloop in CurvySpline.Refresh! Please raise a bugreport!");
						}
						break;
					}
					default:
						DTLog.LogError("[Curvy] Invalid Orientation value " + Orientation);
						break;
					}
					if (!Closed)
					{
						CurvySplineSegment previousControlPoint = GetPreviousControlPoint(LastVisibleControlPoint);
						LastVisibleControlPoint.ApproximationUp[0] = previousControlPoint.ApproximationUp[previousControlPoint.CacheSize];
					}
				}
			}
			mDirtyCurve = false;
			mDirtyOrientation = false;
		}

		private void PrepareThreadCompatibleData()
		{
			int controlPointCount = ControlPointCount;
			bool useFollowUp = Interpolation == CurvyInterpolation.CatmullRom || Interpolation == CurvyInterpolation.TCB;
			for (int i = 0; i < controlPointCount; i++)
			{
				ControlPoints[i].PrepareThreadCompatibleDataINTERNAL(useFollowUp);
			}
			if (Count > 0)
			{
				CurvySplineSegment previousControlPointUsingFollowUp = GetPreviousControlPointUsingFollowUp(FirstVisibleControlPoint);
				if ((object)previousControlPointUsingFollowUp != null && previousControlPointUsingFollowUp.Spline != this)
				{
					previousControlPointUsingFollowUp.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
				}
				CurvySplineSegment nextControlPointUsingFollowUp = GetNextControlPointUsingFollowUp(LastVisibleControlPoint);
				if ((object)nextControlPointUsingFollowUp != null && nextControlPointUsingFollowUp.Spline != this)
				{
					nextControlPointUsingFollowUp.PrepareThreadCompatibleDataINTERNAL(useFollowUp);
				}
			}
		}

		private void FillDirtyCpsExtendedList()
		{
			int count = ControlPoints.Count;
			dirtyCpsExtendedList.Clear();
			if (allControlPointsAreDirty)
			{
				for (int i = 0; i < count; i++)
				{
					dirtyCpsExtendedList.Add(ControlPoints[i]);
				}
				return;
			}
			int count2 = dirtyControlPointsMinimalSet.Count;
			for (int j = 0; j < count2; j++)
			{
				CurvySplineSegment controlPoint = dirtyControlPointsMinimalSet.ElementAt(j);
				CurvySplineSegment previousControlPoint = GetPreviousControlPoint(controlPoint);
				if ((bool)previousControlPoint)
				{
					dirtyControlPointsMinimalSet.Add(previousControlPoint);
				}
				if (Interpolation == CurvyInterpolation.Linear)
				{
					continue;
				}
				if ((bool)previousControlPoint)
				{
					CurvySplineSegment previousControlPoint2 = GetPreviousControlPoint(previousControlPoint);
					if ((bool)previousControlPoint2)
					{
						dirtyControlPointsMinimalSet.Add(previousControlPoint2);
					}
				}
				CurvySplineSegment nextControlPoint = GetNextControlPoint(controlPoint);
				if ((bool)nextControlPoint)
				{
					dirtyControlPointsMinimalSet.Add(nextControlPoint);
				}
			}
			dirtyCpsExtendedList.AddRange(dirtyControlPointsMinimalSet);
		}

		internal void NotifyMetaDataModification()
		{
			sendOnRefreshEventNextUpdate = true;
		}

		private void SyncHierarchyFromSpline(bool renameControlPoints = true)
		{
		}

		private void UpdatedLastProcessedGlobalCoordinates()
		{
			lastProcessedPosition = cachedTransform.position;
			lastProcessedRotation = cachedTransform.rotation;
			lastProcessedScale = cachedTransform.lossyScale;
		}

		private CurvySplineSegment InsertAt(CurvySplineSegment controlPoint, Vector3 position, int insertionIndex, CurvyControlPointEventArgs.ModeEnum insertionMode, bool skipRefreshingAndEvents, Space space)
		{
			if (!skipRefreshingAndEvents)
			{
				OnBeforeControlPointAddEvent(new CurvyControlPointEventArgs(this, this, controlPoint, insertionMode));
			}
			CurvySplineSegment curvySplineSegment;
			GameObject gameObject;
			if (UsePooling && Application.isPlaying)
			{
				CurvyGlobalManager instance = DTSingleton<CurvyGlobalManager>.Instance;
				if (instance != null)
				{
					curvySplineSegment = instance.ControlPointPool.Pop<CurvySplineSegment>(cachedTransform);
					gameObject = curvySplineSegment.gameObject;
				}
				else
				{
					DTLog.LogError("[Curvy] Couldn't find Curvy Global Manager. Please raise a bug report.");
					gameObject = new GameObject("NewCP", typeof(CurvySplineSegment));
					curvySplineSegment = gameObject.GetComponent<CurvySplineSegment>();
				}
			}
			else
			{
				gameObject = new GameObject("NewCP", typeof(CurvySplineSegment));
				curvySplineSegment = gameObject.GetComponent<CurvySplineSegment>();
			}
			gameObject.layer = base.gameObject.layer;
			gameObject.transform.SetParent(cachedTransform);
			InsertControlPoint(insertionIndex, curvySplineSegment);
			curvySplineSegment.AutoHandleDistance = AutoHandleDistance;
			if (space == Space.World)
			{
				curvySplineSegment.transform.position = position;
			}
			else
			{
				curvySplineSegment.transform.localPosition = position;
			}
			curvySplineSegment.transform.rotation = Quaternion.identity;
			curvySplineSegment.transform.localScale = Vector3.one;
			if (!skipRefreshingAndEvents)
			{
				Refresh();
				OnAfterControlPointAddEvent(new CurvyControlPointEventArgs(this, this, curvySplineSegment, insertionMode));
				OnAfterControlPointChangesEvent(defaultSplineEventArgs);
			}
			return curvySplineSegment;
		}

		private CurvySplineEventArgs OnRefreshEvent(CurvySplineEventArgs e)
		{
			if (OnRefresh != null)
			{
				OnRefresh.Invoke(e);
			}
			return e;
		}

		private CurvyControlPointEventArgs OnBeforeControlPointAddEvent(CurvyControlPointEventArgs e)
		{
			if (OnBeforeControlPointAdd != null)
			{
				OnBeforeControlPointAdd.Invoke(e);
			}
			return e;
		}

		private CurvyControlPointEventArgs OnAfterControlPointAddEvent(CurvyControlPointEventArgs e)
		{
			if (OnAfterControlPointAdd != null)
			{
				OnAfterControlPointAdd.Invoke(e);
			}
			return e;
		}

		private CurvyControlPointEventArgs OnBeforeControlPointDeleteEvent(CurvyControlPointEventArgs e)
		{
			if (OnBeforeControlPointDelete != null)
			{
				OnBeforeControlPointDelete.Invoke(e);
			}
			return e;
		}

		private CurvySplineEventArgs OnAfterControlPointChangesEvent(CurvySplineEventArgs e)
		{
			if (OnAfterControlPointChanges != null)
			{
				OnAfterControlPointChanges.Invoke(e);
			}
			return e;
		}
	}
	public enum SplineDirtyingType
	{
		OrientationOnly,
		Everything
	}
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvysplinesegment")]
	public class CurvySplineSegment : MonoBehaviour, IPoolable
	{
		internal readonly struct ControlPointExtrinsicProperties : IEquatable<ControlPointExtrinsicProperties>
		{
			private readonly bool isVisible;

			private readonly short segmentIndex;

			private readonly short controlPointIndex;

			private readonly short nextControlPointIndex;

			private readonly short previousControlPointIndex;

			private readonly bool previousControlPointIsSegment;

			private readonly bool nextControlPointIsSegment;

			private readonly bool canHaveFollowUp;

			private readonly short orientationAnchorIndex;

			internal bool IsVisible => isVisible;

			internal short SegmentIndex => segmentIndex;

			internal short ControlPointIndex => controlPointIndex;

			internal short NextControlPointIndex => nextControlPointIndex;

			internal short PreviousControlPointIndex => previousControlPointIndex;

			internal bool PreviousControlPointIsSegment => previousControlPointIsSegment;

			internal bool NextControlPointIsSegment => nextControlPointIsSegment;

			internal bool CanHaveFollowUp => canHaveFollowUp;

			internal bool IsSegment => SegmentIndex != -1;

			internal short OrientationAnchorIndex => orientationAnchorIndex;

			internal ControlPointExtrinsicProperties(bool isVisible, short segmentIndex, short controlPointIndex, short previousControlPointIndex, short nextControlPointIndex, bool previousControlPointIsSegment, bool nextControlPointIsSegment, bool canHaveFollowUp, short orientationAnchorIndex)
			{
				this.isVisible = isVisible;
				this.segmentIndex = segmentIndex;
				this.controlPointIndex = controlPointIndex;
				this.nextControlPointIndex = nextControlPointIndex;
				this.previousControlPointIndex = previousControlPointIndex;
				this.previousControlPointIsSegment = previousControlPointIsSegment;
				this.nextControlPointIsSegment = nextControlPointIsSegment;
				this.canHaveFollowUp = canHaveFollowUp;
				this.orientationAnchorIndex = orientationAnchorIndex;
			}

			public bool Equals(ControlPointExtrinsicProperties other)
			{
				if (IsVisible == other.IsVisible && SegmentIndex == other.SegmentIndex && ControlPointIndex == other.ControlPointIndex && NextControlPointIndex == other.NextControlPointIndex && PreviousControlPointIndex == other.PreviousControlPointIndex && PreviousControlPointIsSegment == other.PreviousControlPointIsSegment && NextControlPointIsSegment == other.NextControlPointIsSegment && CanHaveFollowUp == other.CanHaveFollowUp)
				{
					return OrientationAnchorIndex == other.OrientationAnchorIndex;
				}
				return false;
			}

			public override bool Equals(object obj)
			{
				if (obj == null)
				{
					return false;
				}
				if (obj is ControlPointExtrinsicProperties)
				{
					return Equals((ControlPointExtrinsicProperties)obj);
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (((((((((((((((IsVisible.GetHashCode() * 397) ^ SegmentIndex.GetHashCode()) * 397) ^ ControlPointIndex.GetHashCode()) * 397) ^ NextControlPointIndex.GetHashCode()) * 397) ^ PreviousControlPointIndex.GetHashCode()) * 397) ^ PreviousControlPointIsSegment.GetHashCode()) * 397) ^ NextControlPointIsSegment.GetHashCode()) * 397) ^ CanHaveFollowUp.GetHashCode()) * 397) ^ OrientationAnchorIndex.GetHashCode();
			}

			public static bool operator ==(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(ControlPointExtrinsicProperties left, ControlPointExtrinsicProperties right)
			{
				return !left.Equals(right);
			}
		}

		public static readonly Color GizmoTangentColor = new Color(0f, 0.7f, 0f);

		[NonSerialized]
		public Vector3[] Approximation = new Vector3[0];

		[NonSerialized]
		public float[] ApproximationDistances = new float[0];

		[NonSerialized]
		public Vector3[] ApproximationUp = new Vector3[0];

		[NonSerialized]
		public Vector3[] ApproximationT = new Vector3[0];

		[Group("General")]
		[FieldAction("CBBakeOrientation", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Below)]
		[Label("Bake Orientation", "Automatically apply orientation to CP transforms?")]
		[SerializeField]
		private bool m_AutoBakeOrientation;

		[Group("General")]
		[Tooltip("Check to use this transform's rotation")]
		[FieldCondition("IsOrientationAnchorEditable", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private bool m_OrientationAnchor;

		[Label("Swirl", "Add Swirl to orientation?")]
		[Group("General")]
		[FieldCondition("canHaveSwirl", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private CurvyOrientationSwirl m_Swirl;

		[Label("Turns", "Number of swirl turns")]
		[Group("General")]
		[FieldCondition("canHaveSwirl", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_Swirl", CurvyOrientationSwirl.None, true)]
		[SerializeField]
		private float m_SwirlTurns;

		[Section("Bezier Options", true, false, 100, Sort = 1, HelpURL = "https://curvyeditor.com/doclink/curvysplinesegment_bezier")]
		[GroupCondition("interpolation", CurvyInterpolation.Bezier, false)]
		[SerializeField]
		private bool m_AutoHandles = true;

		[RangeEx(0f, 1f, "Distance %", "Handle length by distance to neighbours")]
		[FieldCondition("m_AutoHandles", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[SerializeField]
		private float m_AutoHandleDistance = 0.39f;

		[VectorEx("", "", Precision = 3, Options = (AttributeOptionsFlags)1152, Color = "#FFFF00")]
		[SerializeField]
		[FormerlySerializedAs("HandleIn")]
		private Vector3 m_HandleIn = CurvySplineSegmentDefaultValues.HandleIn;

		[VectorEx("", "", Precision = 3, Options = (AttributeOptionsFlags)1152, Color = "#00FF00")]
		[SerializeField]
		[FormerlySerializedAs("HandleOut")]
		private Vector3 m_HandleOut = CurvySplineSegmentDefaultValues.HandleOut;

		[Section("TCB Options", true, false, 100, Sort = 1, HelpURL = "https://curvyeditor.com/doclink/curvysplinesegment_tcb")]
		[GroupCondition("interpolation", CurvyInterpolation.TCB, false)]
		[GroupAction("TCBOptionsGUI", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Below)]
		[Label("Local Tension", "Override Spline Tension?")]
		[SerializeField]
		[FormerlySerializedAs("OverrideGlobalTension")]
		private bool m_OverrideGlobalTension;

		[Label("Local Continuity", "Override Spline Continuity?")]
		[SerializeField]
		[FormerlySerializedAs("OverrideGlobalContinuity")]
		private bool m_OverrideGlobalContinuity;

		[Label("Local Bias", "Override Spline Bias?")]
		[SerializeField]
		[FormerlySerializedAs("OverrideGlobalBias")]
		private bool m_OverrideGlobalBias;

		[Tooltip("Synchronize Start and End Values")]
		[SerializeField]
		[FormerlySerializedAs("SynchronizeTCB")]
		private bool m_SynchronizeTCB = true;

		[Label("Tension", "")]
		[FieldCondition("m_OverrideGlobalTension", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("StartTension")]
		private float m_StartTension;

		[Label("Tension (End)", "")]
		[FieldCondition("m_OverrideGlobalTension", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
		[SerializeField]
		[FormerlySerializedAs("EndTension")]
		private float m_EndTension;

		[Label("Continuity", "")]
		[FieldCondition("m_OverrideGlobalContinuity", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("StartContinuity")]
		private float m_StartContinuity;

		[Label("Continuity (End)", "")]
		[FieldCondition("m_OverrideGlobalContinuity", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
		[SerializeField]
		[FormerlySerializedAs("EndContinuity")]
		private float m_EndContinuity;

		[Label("Bias", "")]
		[FieldCondition("m_OverrideGlobalBias", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FormerlySerializedAs("StartBias")]
		private float m_StartBias;

		[Label("Bias (End)", "")]
		[FieldCondition("m_OverrideGlobalBias", true, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_SynchronizeTCB", false, false)]
		[SerializeField]
		[FormerlySerializedAs("EndBias")]
		private float m_EndBias;

		[SerializeField]
		[HideInInspector]
		private CurvySplineSegment m_FollowUp;

		[SerializeField]
		[HideInInspector]
		private ConnectionHeadingEnum m_FollowUpHeading = ConnectionHeadingEnum.Auto;

		[SerializeField]
		[HideInInspector]
		private bool m_ConnectionSyncPosition;

		[SerializeField]
		[HideInInspector]
		private bool m_ConnectionSyncRotation;

		[SerializeField]
		[HideInInspector]
		private CurvyConnection m_Connection;

		private int cacheSize = -1;

		private Transform cachedTransform;

		private Vector3 threadSafeLocalPosition;

		private Vector3 threadSafeNextCpLocalPosition;

		private Vector3 threadSafePreviousCpLocalPosition;

		private Quaternion threadSafeLocalRotation;

		private CurvySplineSegment cachedNextControlPoint;

		private CurvySpline mSpline;

		private float mStepSize;

		private Bounds? mBounds;

		private readonly HashSet<CurvyMetadataBase> mMetadata = new HashSet<CurvyMetadataBase>();

		private Vector3 lastProcessedLocalPosition;

		private Quaternion lastProcessedLocalRotation;

		private ControlPointExtrinsicProperties extrinsicPropertiesINTERNAL;

		public bool AutoBakeOrientation
		{
			get
			{
				return m_AutoBakeOrientation;
			}
			set
			{
				if (m_AutoBakeOrientation != value)
				{
					m_AutoBakeOrientation = value;
				}
			}
		}

		public bool SerializedOrientationAnchor
		{
			get
			{
				return m_OrientationAnchor;
			}
			set
			{
				if (m_OrientationAnchor != value)
				{
					m_OrientationAnchor = value;
					Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
					Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
				}
			}
		}

		public CurvyOrientationSwirl Swirl
		{
			get
			{
				return m_Swirl;
			}
			set
			{
				if (m_Swirl != value)
				{
					m_Swirl = value;
					Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
				}
			}
		}

		public float SwirlTurns
		{
			get
			{
				return m_SwirlTurns;
			}
			set
			{
				if (m_SwirlTurns != value)
				{
					m_SwirlTurns = value;
					Spline.SetDirty(this, SplineDirtyingType.OrientationOnly);
				}
			}
		}

		public Vector3 HandleIn
		{
			get
			{
				return m_HandleIn;
			}
			set
			{
				if (m_HandleIn != value)
				{
					m_HandleIn = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public Vector3 HandleOut
		{
			get
			{
				return m_HandleOut;
			}
			set
			{
				if (m_HandleOut != value)
				{
					m_HandleOut = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public Vector3 HandleInPosition
		{
			get
			{
				return cachedTransform.position + Spline.transform.rotation * HandleIn;
			}
			set
			{
				HandleIn = Spline.transform.InverseTransformDirection(value - cachedTransform.position);
			}
		}

		public Vector3 HandleOutPosition
		{
			get
			{
				return cachedTransform.position + Spline.transform.rotation * HandleOut;
			}
			set
			{
				HandleOut = Spline.transform.InverseTransformDirection(value - cachedTransform.position);
			}
		}

		public bool AutoHandles
		{
			get
			{
				return m_AutoHandles;
			}
			set
			{
				if (SetAutoHandles(value))
				{
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float AutoHandleDistance
		{
			get
			{
				return m_AutoHandleDistance;
			}
			set
			{
				if (m_AutoHandleDistance != value)
				{
					float num = Mathf.Clamp01(value);
					if (m_AutoHandleDistance != num)
					{
						m_AutoHandleDistance = num;
						Spline.SetDirty(this, SplineDirtyingType.Everything);
					}
				}
			}
		}

		public bool SynchronizeTCB
		{
			get
			{
				return m_SynchronizeTCB;
			}
			set
			{
				if (m_SynchronizeTCB != value)
				{
					m_SynchronizeTCB = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public bool OverrideGlobalTension
		{
			get
			{
				return m_OverrideGlobalTension;
			}
			set
			{
				if (m_OverrideGlobalTension != value)
				{
					m_OverrideGlobalTension = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public bool OverrideGlobalContinuity
		{
			get
			{
				return m_OverrideGlobalContinuity;
			}
			set
			{
				if (m_OverrideGlobalContinuity != value)
				{
					m_OverrideGlobalContinuity = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public bool OverrideGlobalBias
		{
			get
			{
				return m_OverrideGlobalBias;
			}
			set
			{
				if (m_OverrideGlobalBias != value)
				{
					m_OverrideGlobalBias = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float StartTension
		{
			get
			{
				return m_StartTension;
			}
			set
			{
				if (m_StartTension != value)
				{
					m_StartTension = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float StartContinuity
		{
			get
			{
				return m_StartContinuity;
			}
			set
			{
				if (m_StartContinuity != value)
				{
					m_StartContinuity = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float StartBias
		{
			get
			{
				return m_StartBias;
			}
			set
			{
				if (m_StartBias != value)
				{
					m_StartBias = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float EndTension
		{
			get
			{
				return m_EndTension;
			}
			set
			{
				if (m_EndTension != value)
				{
					m_EndTension = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float EndContinuity
		{
			get
			{
				return m_EndContinuity;
			}
			set
			{
				if (m_EndContinuity != value)
				{
					m_EndContinuity = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public float EndBias
		{
			get
			{
				return m_EndBias;
			}
			set
			{
				if (m_EndBias != value)
				{
					m_EndBias = value;
					Spline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public CurvySplineSegment FollowUp
		{
			get
			{
				return m_FollowUp;
			}
			private set
			{
				if (m_FollowUp != value)
				{
					m_FollowUp = value;
					if (mSpline != null)
					{
						mSpline.SetDirty(this, SplineDirtyingType.Everything);
					}
				}
			}
		}

		public ConnectionHeadingEnum FollowUpHeading
		{
			get
			{
				return GetValidateConnectionHeading(m_FollowUpHeading, FollowUp);
			}
			set
			{
				value = GetValidateConnectionHeading(value, FollowUp);
				if (m_FollowUpHeading != value)
				{
					m_FollowUpHeading = value;
					if (mSpline != null)
					{
						mSpline.SetDirty(this, SplineDirtyingType.Everything);
					}
				}
			}
		}

		public bool ConnectionSyncPosition
		{
			get
			{
				return m_ConnectionSyncPosition;
			}
			set
			{
				if (m_ConnectionSyncPosition != value)
				{
					m_ConnectionSyncPosition = value;
				}
			}
		}

		public bool ConnectionSyncRotation
		{
			get
			{
				return m_ConnectionSyncRotation;
			}
			set
			{
				if (m_ConnectionSyncRotation != value)
				{
					m_ConnectionSyncRotation = value;
				}
			}
		}

		public CurvyConnection Connection
		{
			get
			{
				return m_Connection;
			}
			internal set
			{
				if (SetConnection(value) && mSpline != null)
				{
					mSpline.SetDirty(this, SplineDirtyingType.Everything);
				}
			}
		}

		public int CacheSize
		{
			get
			{
				return cacheSize;
			}
			private set
			{
				cacheSize = value;
			}
		}

		public Bounds Bounds
		{
			get
			{
				if (!mBounds.HasValue)
				{
					Bounds value;
					if (Approximation.Length == 0)
					{
						value = new Bounds(cachedTransform.position, Vector3.zero);
					}
					else
					{
						Matrix4x4 localToWorldMatrix = Spline.transform.localToWorldMatrix;
						value = new Bounds(localToWorldMatrix.MultiplyPoint3x4(Approximation[0]), Vector3.zero);
						int num = Approximation.Length;
						for (int i = 1; i < num; i++)
						{
							value.Encapsulate(localToWorldMatrix.MultiplyPoint(Approximation[i]));
						}
					}
					mBounds = value;
				}
				return mBounds.Value;
			}
		}

		public float Length { get; private set; }

		public float Distance { get; internal set; }

		public float TF { get; internal set; }

		public bool IsFirstControlPoint => Spline.GetControlPointIndex(this) == 0;

		public bool IsLastControlPoint => Spline.GetControlPointIndex(this) == Spline.ControlPointCount - 1;

		[Obsolete("Use Metadata instead")]
		public HashSet<UnityEngine.Component> MetaDataSet
		{
			get
			{
				HashSet<UnityEngine.Component> result = new HashSet<UnityEngine.Component>();
				Metadata.ForEach(delegate(CurvyMetadataBase md)
				{
					result.Add(md);
				});
				return result;
			}
		}

		public HashSet<CurvyMetadataBase> Metadata => mMetadata;

		public CurvySpline Spline => mSpline;

		public bool HasUnprocessedLocalPosition => !(cachedTransform.localPosition == lastProcessedLocalPosition);

		public bool HasUnprocessedLocalOrientation => cachedTransform.localRotation.DifferentOrientation(lastProcessedLocalRotation);

		public bool OrientatinInfluencesSpline
		{
			get
			{
				if (mSpline != null)
				{
					if (mSpline.Orientation != CurvyOrientation.Static)
					{
						return mSpline.IsControlPointAnOrientationAnchor(this);
					}
					return true;
				}
				return false;
			}
		}

		private CurvyInterpolation interpolation
		{
			get
			{
				if (!Spline)
				{
					return CurvyInterpolation.Linear;
				}
				return Spline.Interpolation;
			}
		}

		private bool isDynamicOrientation
		{
			get
			{
				if ((bool)Spline)
				{
					return Spline.Orientation == CurvyOrientation.Dynamic;
				}
				return false;
			}
		}

		private bool IsOrientationAnchorEditable
		{
			get
			{
				CurvySpline spline = Spline;
				if (isDynamicOrientation && spline.IsControlPointVisible(this) && spline.FirstVisibleControlPoint != this)
				{
					return spline.LastVisibleControlPoint != this;
				}
				return false;
			}
		}

		private bool canHaveSwirl
		{
			get
			{
				CurvySpline spline = Spline;
				if (isDynamicOrientation && (bool)spline && spline.IsControlPointAnOrientationAnchor(this))
				{
					if (!spline.Closed)
					{
						return spline.LastVisibleControlPoint != this;
					}
					return true;
				}
				return false;
			}
		}

		public void SetBezierHandleIn(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
		{
			if (space == Space.Self)
			{
				HandleIn = position;
			}
			else
			{
				HandleInPosition = position;
			}
			bool flag = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
			bool flag2 = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
			bool flag3 = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;
			if (flag)
			{
				HandleOut = HandleOut.magnitude * (HandleIn.normalized * -1f);
			}
			if (flag2)
			{
				HandleOut = HandleIn.magnitude * ((HandleOut == Vector3.zero) ? (HandleIn.normalized * -1f) : HandleOut.normalized);
			}
			if (!((bool)Connection && flag3) || !(flag || flag2))
			{
				return;
			}
			ReadOnlyCollection<CurvySplineSegment> controlPointsList = Connection.ControlPointsList;
			for (int i = 0; i < controlPointsList.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = controlPointsList[i];
				if (!(curvySplineSegment == this))
				{
					if (curvySplineSegment.HandleIn.magnitude == 0f)
					{
						curvySplineSegment.HandleIn = HandleIn;
					}
					if (flag)
					{
						curvySplineSegment.SetBezierHandleIn(curvySplineSegment.HandleIn.magnitude * HandleIn.normalized * Mathf.Sign(Vector3.Dot(HandleIn, curvySplineSegment.HandleIn)), Space.Self, CurvyBezierModeEnum.Direction);
					}
					if (flag2)
					{
						curvySplineSegment.SetBezierHandleIn(curvySplineSegment.HandleIn.normalized * HandleIn.magnitude, Space.Self, CurvyBezierModeEnum.Length);
					}
				}
			}
		}

		public void SetBezierHandleOut(Vector3 position, Space space = Space.Self, CurvyBezierModeEnum mode = CurvyBezierModeEnum.None)
		{
			if (space == Space.Self)
			{
				HandleOut = position;
			}
			else
			{
				HandleOutPosition = position;
			}
			bool flag = (mode & CurvyBezierModeEnum.Direction) == CurvyBezierModeEnum.Direction;
			bool flag2 = (mode & CurvyBezierModeEnum.Length) == CurvyBezierModeEnum.Length;
			bool flag3 = (mode & CurvyBezierModeEnum.Connections) == CurvyBezierModeEnum.Connections;
			if (flag)
			{
				HandleIn = HandleIn.magnitude * (HandleOut.normalized * -1f);
			}
			if (flag2)
			{
				HandleIn = HandleOut.magnitude * ((HandleIn == Vector3.zero) ? (HandleOut.normalized * -1f) : HandleIn.normalized);
			}
			if (!((bool)Connection && flag3) || !(flag || flag2))
			{
				return;
			}
			for (int i = 0; i < Connection.ControlPointsList.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = Connection.ControlPointsList[i];
				if (!(curvySplineSegment == this))
				{
					if (curvySplineSegment.HandleOut.magnitude == 0f)
					{
						curvySplineSegment.HandleOut = HandleOut;
					}
					if (flag)
					{
						curvySplineSegment.SetBezierHandleOut(curvySplineSegment.HandleOut.magnitude * HandleOut.normalized * Mathf.Sign(Vector3.Dot(HandleOut, curvySplineSegment.HandleOut)), Space.Self, CurvyBezierModeEnum.Direction);
					}
					if (flag2)
					{
						curvySplineSegment.SetBezierHandleOut(curvySplineSegment.HandleOut.normalized * HandleOut.magnitude, Space.Self, CurvyBezierModeEnum.Length);
					}
				}
			}
		}

		public void SetBezierHandles(float distanceFrag = -1f, bool setIn = true, bool setOut = true, bool noDirtying = false)
		{
			Vector3 zero = Vector3.zero;
			Vector3 zero2 = Vector3.zero;
			if (distanceFrag == -1f)
			{
				distanceFrag = AutoHandleDistance;
			}
			if (distanceFrag > 0f)
			{
				CurvySpline spline = Spline;
				CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
				Transform transform = (nextControlPoint ? nextControlPoint.transform : cachedTransform);
				CurvySplineSegment previousControlPoint = spline.GetPreviousControlPoint(this);
				Transform obj = (previousControlPoint ? previousControlPoint.transform : cachedTransform);
				Vector3 localPosition = cachedTransform.localPosition;
				Vector3 p = obj.localPosition - localPosition;
				Vector3 n = transform.localPosition - localPosition;
				SetBezierHandles(distanceFrag, p, n, setIn, setOut, noDirtying);
				return;
			}
			if (setIn)
			{
				if (noDirtying)
				{
					m_HandleIn = zero;
				}
				else
				{
					HandleIn = zero;
				}
			}
			if (setOut)
			{
				if (noDirtying)
				{
					m_HandleOut = zero2;
				}
				else
				{
					HandleOut = zero2;
				}
			}
		}

		public void SetBezierHandles(float distanceFrag, Vector3 p, Vector3 n, bool setIn = true, bool setOut = true, bool noDirtying = false)
		{
			float magnitude = p.magnitude;
			float magnitude2 = n.magnitude;
			Vector3 handleIn = Vector3.zero;
			Vector3 handleOut = Vector3.zero;
			if (magnitude != 0f || magnitude2 != 0f)
			{
				Vector3 normalized = (magnitude / magnitude2 * n - p).normalized;
				handleIn = -normalized * (magnitude * distanceFrag);
				handleOut = normalized * (magnitude2 * distanceFrag);
			}
			if (setIn)
			{
				if (noDirtying)
				{
					m_HandleIn = handleIn;
				}
				else
				{
					HandleIn = handleIn;
				}
			}
			if (setOut)
			{
				if (noDirtying)
				{
					m_HandleOut = handleOut;
				}
				else
				{
					HandleOut = handleOut;
				}
			}
		}

		public void SetFollowUp(CurvySplineSegment target, ConnectionHeadingEnum heading = ConnectionHeadingEnum.Auto)
		{
			if (target == null)
			{
				FollowUp = target;
				FollowUpHeading = heading;
			}
			else if (Spline.CanControlPointHaveFollowUp(this))
			{
				if (Connection == null || Connection != target.Connection)
				{
					DTLog.LogError("[Curvy] Trying to set as a Follow-Up a Control Point that is not part of the same connection");
					return;
				}
				FollowUp = target;
				FollowUpHeading = heading;
			}
			else
			{
				DTLog.LogError("[Curvy] Setting a Follow-Up to a Control Point that can't have one");
			}
		}

		public void Disconnect()
		{
			Disconnect(destroyEmptyConnection: true);
		}

		public void Disconnect(bool destroyEmptyConnection)
		{
			if ((bool)Connection)
			{
				Connection.RemoveControlPoint(this, destroyEmptyConnection);
			}
			FollowUp = null;
			FollowUpHeading = ConnectionHeadingEnum.Auto;
			ConnectionSyncPosition = false;
			ConnectionSyncRotation = false;
		}

		[Obsolete("Use Disconnect instead")]
		public void ResetConnectionRelatedData()
		{
			Connection = null;
			FollowUp = null;
			FollowUpHeading = ConnectionHeadingEnum.Auto;
			ConnectionSyncPosition = false;
			ConnectionSyncRotation = false;
		}

		public Vector3 Interpolate(float localF, Space space = Space.Self)
		{
			CurvyInterpolation curvyInterpolation = Spline.Interpolation;
			localF = Mathf.Clamp01(localF);
			Vector3 vector;
			switch (curvyInterpolation)
			{
			case CurvyInterpolation.Bezier:
				vector = CurvySpline.Bezier(threadSafeLocalPosition.Addition(HandleOut), threadSafeLocalPosition, threadSafeNextCpLocalPosition, threadSafeNextCpLocalPosition.Addition(cachedNextControlPoint.HandleIn), localF);
				break;
			case CurvyInterpolation.TCB:
			{
				float fT = StartTension;
				float fT2 = EndTension;
				float fC = StartContinuity;
				float fC2 = EndContinuity;
				float fB = StartBias;
				float fB2 = EndBias;
				if (!OverrideGlobalTension)
				{
					fT = (fT2 = mSpline.Tension);
				}
				if (!OverrideGlobalContinuity)
				{
					fC = (fC2 = mSpline.Continuity);
				}
				if (!OverrideGlobalBias)
				{
					fB = (fB2 = mSpline.Bias);
				}
				vector = CurvySpline.TCB(threadSafePreviousCpLocalPosition, threadSafeLocalPosition, threadSafeNextCpLocalPosition, cachedNextControlPoint.threadSafeNextCpLocalPosition, localF, fT, fC, fB, fT2, fC2, fB2);
				break;
			}
			case CurvyInterpolation.CatmullRom:
				vector = CurvySpline.CatmullRom(threadSafePreviousCpLocalPosition, threadSafeLocalPosition, threadSafeNextCpLocalPosition, cachedNextControlPoint.threadSafeNextCpLocalPosition, localF);
				break;
			case CurvyInterpolation.Linear:
				vector = threadSafeLocalPosition.LerpUnclamped(threadSafeNextCpLocalPosition, localF);
				break;
			default:
				DTLog.LogError("[Curvy] Invalid interpolation value " + curvyInterpolation);
				return Vector3.zero;
			}
			if (space == Space.World)
			{
				vector = Spline.ToWorldPosition(vector);
			}
			return vector;
		}

		public Vector3 InterpolateFast(float localF, Space space = Space.Self)
		{
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			int num = Mathf.Min(Approximation.Length - 1, approximationIndexINTERNAL + 1);
			Vector3 vector = Approximation[approximationIndexINTERNAL].LerpUnclamped(Approximation[num], frag);
			if (space == Space.World)
			{
				vector = Spline.ToWorldPosition(vector);
			}
			return vector;
		}

		public Vector3 GetTangent(float localF, Space space = Space.Self)
		{
			localF = Mathf.Clamp01(localF);
			Vector3 position = Interpolate(localF, space);
			return GetTangent(localF, position, space);
		}

		public Vector3 GetTangent(float localF, Vector3 position, Space space = Space.Self)
		{
			CurvySpline spline = Spline;
			int num = 2;
			Vector3 vector;
			do
			{
				float num2 = localF + 0.01f;
				if (num2 > 1f)
				{
					CurvySplineSegment nextSegment = spline.GetNextSegment(this);
					if (!nextSegment)
					{
						num2 = localF - 0.01f;
						return OptimizedOperators.Normalize(position.Subtraction(Interpolate(num2, space)));
					}
					vector = nextSegment.Interpolate(num2 - 1f, space);
				}
				else
				{
					vector = Interpolate(num2, space);
				}
				localF += 0.01f;
			}
			while (vector == position && --num > 0);
			return OptimizedOperators.Normalize(vector.Subtraction(position));
		}

		public Vector3 GetTangentFast(float localF, Space space = Space.Self)
		{
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			int num = Mathf.Min(ApproximationT.Length - 1, approximationIndexINTERNAL + 1);
			Vector3 vector = Vector3.SlerpUnclamped(ApproximationT[approximationIndexINTERNAL], ApproximationT[num], frag);
			if (space == Space.World)
			{
				vector = Spline.ToWorldDirection(vector);
			}
			return vector;
		}

		public void InterpolateAndGetTangent(float localF, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
		{
			localF = Mathf.Clamp01(localF);
			position = Interpolate(localF, space);
			tangent = GetTangent(localF, position, space);
		}

		public void InterpolateAndGetTangentFast(float localF, out Vector3 position, out Vector3 tangent, Space space = Space.Self)
		{
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			int num = Mathf.Min(Approximation.Length - 1, approximationIndexINTERNAL + 1);
			position = Approximation[approximationIndexINTERNAL].LerpUnclamped(Approximation[num], frag);
			tangent = Vector3.SlerpUnclamped(ApproximationT[approximationIndexINTERNAL], ApproximationT[num], frag);
			if (space == Space.World)
			{
				position = Spline.ToWorldPosition(position);
				tangent = Spline.ToWorldDirection(tangent);
			}
		}

		public Vector3 GetOrientationUpFast(float localF, Space space = Space.Self)
		{
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			int num = Mathf.Min(ApproximationUp.Length - 1, approximationIndexINTERNAL + 1);
			Vector3 vector = Vector3.SlerpUnclamped(ApproximationUp[approximationIndexINTERNAL], ApproximationUp[num], frag);
			if (space == Space.World)
			{
				vector = Spline.ToWorldDirection(vector);
			}
			return vector;
		}

		public Quaternion GetOrientationFast(float localF, bool inverse = false, Space space = Space.Self)
		{
			Vector3 tangentFast = GetTangentFast(localF, space);
			if (tangentFast != Vector3.zero)
			{
				if (inverse)
				{
					tangentFast *= -1f;
				}
				return Quaternion.LookRotation(tangentFast, GetOrientationUpFast(localF, space));
			}
			return Quaternion.identity;
		}

		[Obsolete("Member not used by Curvy, will get remove. Copy it if you still need it")]
		public Vector3 InterpolateScale(float localF)
		{
			CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
			if (!nextControlPoint)
			{
				return base.transform.lossyScale;
			}
			return Vector3.Lerp(base.transform.lossyScale, nextControlPoint.transform.lossyScale, localF);
		}

		public void ReloadMetaData()
		{
			Metadata.Clear();
			CurvyMetadataBase[] components = GetComponents<CurvyMetadataBase>();
			foreach (CurvyMetadataBase item in components)
			{
				Metadata.Add(item);
			}
			CheckAgainstMetaDataDuplication();
		}

		public void RegisterMetaData(CurvyMetadataBase metaData)
		{
			Metadata.Add(metaData);
			CheckAgainstMetaDataDuplication();
		}

		public void UnregisterMetaData(CurvyMetadataBase metaData)
		{
			Metadata.Remove(metaData);
		}

		public T GetMetadata<T>(bool autoCreate = false) where T : CurvyMetadataBase
		{
			Type typeFromHandle = typeof(T);
			T val = null;
			foreach (CurvyMetadataBase metadatum in Metadata)
			{
				if (metadatum != null && metadatum.GetType() == typeFromHandle)
				{
					val = (T)metadatum;
					break;
				}
			}
			if (autoCreate && val == null)
			{
				val = base.gameObject.AddComponent<T>();
				Metadata.Add(val);
			}
			return val;
		}

		public U GetInterpolatedMetadata<T, U>(float f) where T : CurvyInterpolatableMetadataBase<U>
		{
			T metadata = GetMetadata<T>();
			if (metadata != null)
			{
				CurvySplineSegment nextControlPointUsingFollowUp = Spline.GetNextControlPointUsingFollowUp(this);
				CurvyInterpolatableMetadataBase<U> nextMetadata = null;
				if ((bool)nextControlPointUsingFollowUp)
				{
					nextMetadata = nextControlPointUsingFollowUp.GetMetadata<T>();
				}
				return metadata.Interpolate(nextMetadata, f);
			}
			return default(U);
		}

		public void DeleteMetadata()
		{
			List<CurvyMetadataBase> list = Metadata.ToList();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				list[num].Destroy();
			}
		}

		public float GetNearestPointF(Vector3 position, Space space = Space.Self)
		{
			if (space == Space.World)
			{
				position = Spline.ToLocalPosition(position);
			}
			int num = CacheSize + 1;
			float num2 = float.MaxValue;
			int num3 = 0;
			Vector3 vector = default(Vector3);
			for (int i = 0; i < num; i++)
			{
				vector.x = Approximation[i].x - position.x;
				vector.y = Approximation[i].y - position.y;
				vector.z = Approximation[i].z - position.z;
				float num4 = vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;
				if (num4 <= num2)
				{
					num2 = num4;
					num3 = i;
				}
			}
			int num5 = ((num3 > 0) ? (num3 - 1) : (-1));
			int num6 = ((num3 < CacheSize) ? (num3 + 1) : (-1));
			float frag = 0f;
			float frag2 = 0f;
			float num7 = float.MaxValue;
			float num8 = float.MaxValue;
			if (num5 > -1)
			{
				num7 = DTMath.LinePointDistanceSqr(Approximation[num5], Approximation[num3], position, out frag);
			}
			if (num6 > -1)
			{
				num8 = DTMath.LinePointDistanceSqr(Approximation[num3], Approximation[num6], position, out frag2);
			}
			if (num7 < num8)
			{
				return getApproximationLocalF(num5) + frag * mStepSize;
			}
			return getApproximationLocalF(num3) + frag2 * mStepSize;
		}

		public float DistanceToLocalF(float localDistance)
		{
			int num = ApproximationDistances.Length;
			if (num <= 1 || localDistance == 0f)
			{
				return 0f;
			}
			int num2 = CurvyUtility.InterpolationSearch(ApproximationDistances, localDistance);
			if (num2 == num - 1)
			{
				return 1f;
			}
			float num3 = (localDistance - ApproximationDistances[num2]) / (ApproximationDistances[num2 + 1] - ApproximationDistances[num2]);
			float approximationLocalF = getApproximationLocalF(num2);
			float approximationLocalF2 = getApproximationLocalF(num2 + 1);
			return approximationLocalF + (approximationLocalF2 - approximationLocalF) * num3;
		}

		public float LocalFToDistance(float localF)
		{
			if (ApproximationDistances.Length <= 1 || localF == 0f)
			{
				return 0f;
			}
			if (localF == 1f)
			{
				return Length;
			}
			float frag;
			int approximationIndexINTERNAL = getApproximationIndexINTERNAL(localF, out frag);
			float num = ApproximationDistances[approximationIndexINTERNAL + 1] - ApproximationDistances[approximationIndexINTERNAL];
			return ApproximationDistances[approximationIndexINTERNAL] + num * frag;
		}

		public float LocalFToTF(float localF)
		{
			return Spline.SegmentToTF(this, localF);
		}

		public override string ToString()
		{
			if (Spline != null)
			{
				return Spline.name + "." + base.name;
			}
			return base.ToString();
		}

		public void BakeOrientationToTransform()
		{
			Quaternion orientationFast = GetOrientationFast(0f);
			if (cachedTransform.localRotation.DifferentOrientation(orientationFast))
			{
				SetLocalRotation(orientationFast);
			}
		}

		public int getApproximationIndexINTERNAL(float localF, out float frag)
		{
			localF = Mathf.Clamp01(localF);
			if (localF == 1f)
			{
				frag = 1f;
				return Mathf.Max(0, Approximation.Length - 2);
			}
			float num = localF / mStepSize;
			int num2 = (int)num;
			frag = num - (float)num2;
			return num2;
		}

		public void LinkToSpline(CurvySpline spline)
		{
			mSpline = spline;
		}

		public void UnlinkFromSpline()
		{
			mSpline = null;
		}

		public void SetLocalPosition(Vector3 newPosition)
		{
			if (cachedTransform.localPosition != newPosition)
			{
				cachedTransform.localPosition = newPosition;
				Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation(ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position, ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
				}
			}
		}

		public void SetPosition(Vector3 value)
		{
			if (cachedTransform.position != value)
			{
				cachedTransform.position = value;
				Spline.SetDirtyPartial(this, SplineDirtyingType.Everything);
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation(ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position, ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
				}
			}
		}

		public void SetLocalRotation(Quaternion value)
		{
			if (cachedTransform.localRotation != value)
			{
				cachedTransform.localRotation = value;
				if (OrientatinInfluencesSpline)
				{
					Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
				}
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation(ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position, ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
				}
			}
		}

		public void SetRotation(Quaternion value)
		{
			if (cachedTransform.rotation != value)
			{
				cachedTransform.rotation = value;
				if (OrientatinInfluencesSpline)
				{
					Spline.SetDirtyPartial(this, SplineDirtyingType.OrientationOnly);
				}
				if ((ConnectionSyncPosition || ConnectionSyncRotation) && Connection != null)
				{
					Connection.SetSynchronisationPositionAndRotation(ConnectionSyncPosition ? cachedTransform.position : Connection.transform.position, ConnectionSyncRotation ? cachedTransform.rotation : Connection.transform.rotation);
				}
			}
		}

		public static bool CanFollowUpHeadToStart([NotNull] CurvySplineSegment followUp)
		{
			return followUp.Spline.GetPreviousControlPointIndex(followUp) != -1;
		}

		public static bool CanFollowUpHeadToEnd([NotNull] CurvySplineSegment followUp)
		{
			return followUp.Spline.GetNextControlPointIndex(followUp) != -1;
		}

		public void OnBeforePush()
		{
			this.StripComponents();
			Disconnect();
			DeleteMetadata();
		}

		public void OnAfterPop()
		{
			Reset();
		}

		private void Awake()
		{
			if ((bool)Connection && !Connection.ControlPointsList.Contains(this))
			{
				SetConnection(null);
			}
			cachedTransform = base.transform;
			ReloadMetaData();
		}

		private void OnEnable()
		{
			Awake();
		}

		private void OnDestroy()
		{
			if (true)
			{
				Disconnect();
			}
		}

		public void Reset()
		{
			m_OrientationAnchor = false;
			m_Swirl = CurvyOrientationSwirl.None;
			m_SwirlTurns = 0f;
			m_AutoHandles = true;
			m_AutoHandleDistance = 0.39f;
			m_HandleIn = new Vector3(-1f, 0f, 0f);
			m_HandleOut = new Vector3(1f, 0f, 0f);
			m_SynchronizeTCB = true;
			m_OverrideGlobalTension = false;
			m_OverrideGlobalContinuity = false;
			m_OverrideGlobalBias = false;
			m_StartTension = 0f;
			m_EndTension = 0f;
			m_StartContinuity = 0f;
			m_EndContinuity = 0f;
			m_StartBias = 0f;
			m_EndBias = 0f;
			if ((bool)mSpline)
			{
				Spline.SetDirty(this, SplineDirtyingType.Everything);
				Spline.InvalidateControlPointsRelationshipCacheINTERNAL();
			}
		}

		internal void SetExtrinsicPropertiesINTERNAL(ControlPointExtrinsicProperties value)
		{
			extrinsicPropertiesINTERNAL = value;
		}

		internal ref readonly ControlPointExtrinsicProperties GetExtrinsicPropertiesINTERNAL()
		{
			return ref extrinsicPropertiesINTERNAL;
		}

		private void CheckAgainstMetaDataDuplication()
		{
			if (Metadata.Count <= 1)
			{
				return;
			}
			HashSet<Type> hashSet = new HashSet<Type>();
			foreach (CurvyMetadataBase metadatum in Metadata)
			{
				Type type = metadatum.GetType();
				if (hashSet.Contains(type))
				{
					DTLog.LogWarning($"[Curvy] Game object '{ToString()}' has multiple Components of type '{type}'. Control Points should have no more than one Component instance for each MetaData type.");
				}
				else
				{
					hashSet.Add(type);
				}
			}
		}

		private bool SetConnection(CurvyConnection newConnection)
		{
			bool result = false;
			if (m_Connection != newConnection)
			{
				result = true;
				m_Connection = newConnection;
			}
			if (m_Connection == null && m_FollowUp != null)
			{
				result = true;
				m_FollowUp = null;
			}
			return result;
		}

		private static ConnectionHeadingEnum GetValidateConnectionHeading(ConnectionHeadingEnum connectionHeading, [CanBeNull] CurvySplineSegment followUp)
		{
			if (followUp == null)
			{
				return connectionHeading;
			}
			if ((connectionHeading == ConnectionHeadingEnum.Minus && !CanFollowUpHeadToStart(followUp)) || (connectionHeading == ConnectionHeadingEnum.Plus && !CanFollowUpHeadToEnd(followUp)))
			{
				return ConnectionHeadingEnum.Auto;
			}
			return connectionHeading;
		}

		private bool SetAutoHandles(bool newValue)
		{
			bool flag = false;
			if ((bool)Connection)
			{
				ReadOnlyCollection<CurvySplineSegment> controlPointsList = Connection.ControlPointsList;
				for (int i = 0; i < controlPointsList.Count; i++)
				{
					CurvySplineSegment curvySplineSegment = controlPointsList[i];
					flag = flag || curvySplineSegment.m_AutoHandles != newValue;
					curvySplineSegment.m_AutoHandles = newValue;
				}
			}
			else
			{
				flag = m_AutoHandles != newValue;
				m_AutoHandles = newValue;
			}
			return flag;
		}

		private float getApproximationLocalF(int idx)
		{
			return (float)idx * mStepSize;
		}

		internal void refreshCurveINTERNAL()
		{
			CurvySpline spline = Spline;
			bool num = spline.IsControlPointASegment(this);
			int num3 = (CacheSize = (num ? CurvySpline.CalculateCacheSize(spline.CacheDensity, (cachedNextControlPoint.threadSafeLocalPosition - threadSafeLocalPosition).magnitude, spline.MaxPointsPerUnit) : 0));
			Array.Resize(ref Approximation, num3 + 1);
			Array.Resize(ref ApproximationT, num3 + 1);
			Array.Resize(ref ApproximationDistances, num3 + 1);
			Array.Resize(ref ApproximationUp, num3 + 1);
			Approximation[0] = threadSafeLocalPosition;
			ApproximationDistances[0] = 0f;
			mBounds = null;
			Length = 0f;
			mStepSize = 1f / (float)num3;
			bool flag = (object)cachedNextControlPoint != null;
			if (num3 != 0)
			{
				Approximation[num3] = (flag ? cachedNextControlPoint.threadSafeLocalPosition : threadSafeLocalPosition);
			}
			if (num)
			{
				float length = 0f;
				switch (spline.Interpolation)
				{
				case CurvyInterpolation.Bezier:
					length = InterpolateBezierSegment(cachedNextControlPoint, num3);
					break;
				case CurvyInterpolation.CatmullRom:
					length = InterpolateCatmullSegment(cachedNextControlPoint, num3);
					break;
				case CurvyInterpolation.TCB:
					length = InterpolateTCBSegment(cachedNextControlPoint, num3, spline.Tension, spline.Continuity, spline.Bias);
					break;
				case CurvyInterpolation.Linear:
					length = InterpolateLinearSegment(cachedNextControlPoint, num3);
					break;
				default:
					DTLog.LogError("[Curvy] Invalid interpolation value " + spline.Interpolation);
					break;
				}
				Length = length;
				Vector3 vector = Approximation[num3] - Approximation[num3 - 1];
				Length += vector.magnitude;
				ApproximationDistances[num3] = Length;
				ApproximationT[num3 - 1] = vector.normalized;
				ApproximationT[num3] = ApproximationT[num3 - 1];
			}
			else if (flag)
			{
				ApproximationT[0] = (cachedNextControlPoint.threadSafeLocalPosition - Approximation[0]).normalized;
			}
			else
			{
				short previousControlPointIndex = spline.GetPreviousControlPointIndex(this);
				if (previousControlPointIndex != -1)
				{
					ApproximationT[0] = (Approximation[0] - spline.ControlPointsList[previousControlPointIndex].threadSafeLocalPosition).normalized;
				}
				else
				{
					ApproximationT[0] = threadSafeLocalRotation * Vector3.forward;
				}
			}
			lastProcessedLocalPosition = threadSafeLocalPosition;
		}

		private float InterpolateBezierSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
		{
			float num = 0f;
			Vector3 vector = threadSafeLocalPosition;
			Vector3 vector2 = vector + HandleOut;
			Vector3 vector3 = nextControlPoint.threadSafeLocalPosition;
			Vector3 vector4 = vector3 + nextControlPoint.HandleIn;
			double num2 = (double)(0f - vector.x) + 3.0 * (double)vector2.x + -3.0 * (double)vector4.x + (double)vector3.x;
			double num3 = 3.0 * (double)vector.x + -6.0 * (double)vector2.x + 3.0 * (double)vector4.x;
			double num4 = -3.0 * (double)vector.x + 3.0 * (double)vector2.x;
			double num5 = vector.x;
			double num6 = (double)(0f - vector.y) + 3.0 * (double)vector2.y + -3.0 * (double)vector4.y + (double)vector3.y;
			double num7 = 3.0 * (double)vector.y + -6.0 * (double)vector2.y + 3.0 * (double)vector4.y;
			double num8 = -3.0 * (double)vector.y + 3.0 * (double)vector2.y;
			double num9 = vector.y;
			double num10 = (double)(0f - vector.z) + 3.0 * (double)vector2.z + -3.0 * (double)vector4.z + (double)vector3.z;
			double num11 = 3.0 * (double)vector.z + -6.0 * (double)vector2.z + 3.0 * (double)vector4.z;
			double num12 = -3.0 * (double)vector.z + 3.0 * (double)vector2.z;
			double num13 = vector.z;
			Vector3 vector5 = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float num14 = (float)i * mStepSize;
				Approximation[i].x = (float)(((num2 * (double)num14 + num3) * (double)num14 + num4) * (double)num14 + num5);
				Approximation[i].y = (float)(((num6 * (double)num14 + num7) * (double)num14 + num8) * (double)num14 + num9);
				Approximation[i].z = (float)(((num10 * (double)num14 + num11) * (double)num14 + num12) * (double)num14 + num13);
				vector5.x = Approximation[i].x - Approximation[i - 1].x;
				vector5.y = Approximation[i].y - Approximation[i - 1].y;
				vector5.z = Approximation[i].z - Approximation[i - 1].z;
				float num15 = Mathf.Sqrt(vector5.x * vector5.x + vector5.y * vector5.y + vector5.z * vector5.z);
				num += num15;
				ApproximationDistances[i] = num;
				if ((double)num15 > 9.99999974737875E-06)
				{
					float num16 = 1f / num15;
					ApproximationT[i - 1].x = vector5.x * num16;
					ApproximationT[i - 1].y = vector5.y * num16;
					ApproximationT[i - 1].z = vector5.z * num16;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		private float InterpolateTCBSegment(CurvySplineSegment nextControlPoint, int newCacheSize, float splineTension, float splineContinuity, float splineBias)
		{
			float num = 0f;
			float num2 = StartTension;
			float num3 = EndTension;
			float num4 = StartContinuity;
			float num5 = EndContinuity;
			float num6 = StartBias;
			float num7 = EndBias;
			if (!OverrideGlobalTension)
			{
				num2 = (num3 = splineTension);
			}
			if (!OverrideGlobalContinuity)
			{
				num4 = (num5 = splineContinuity);
			}
			if (!OverrideGlobalBias)
			{
				num6 = (num7 = splineBias);
			}
			Vector3 vector = threadSafeLocalPosition;
			Vector3 vector2 = threadSafeNextCpLocalPosition;
			Vector3 vector3 = threadSafePreviousCpLocalPosition;
			Vector3 vector4 = nextControlPoint.threadSafeNextCpLocalPosition;
			double num8 = (1f - num2) * (1f + num4) * (1f + num6);
			double num9 = (1f - num2) * (1f - num4) * (1f - num6);
			double num10 = (1f - num3) * (1f - num5) * (1f + num7);
			double num11 = (1f - num3) * (1f + num5) * (1f - num7);
			double num12 = 2.0;
			double num13 = (0.0 - num8) / num12;
			double num14 = (4.0 + num8 - num9 - num10) / num12;
			double num15 = (-4.0 + num9 + num10 - num11) / num12;
			double num16 = num11 / num12;
			double num17 = 2.0 * num8 / num12;
			double num18 = (-6.0 - 2.0 * num8 + 2.0 * num9 + num10) / num12;
			double num19 = (6.0 - 2.0 * num9 - num10 + num11) / num12;
			double num20 = (0.0 - num11) / num12;
			double num21 = (0.0 - num8) / num12;
			double num22 = (num8 - num9) / num12;
			double num23 = num9 / num12;
			double num24 = 2.0 / num12;
			double num25 = num13 * (double)vector3.x + num14 * (double)vector.x + num15 * (double)vector2.x + num16 * (double)vector4.x;
			double num26 = num17 * (double)vector3.x + num18 * (double)vector.x + num19 * (double)vector2.x + num20 * (double)vector4.x;
			double num27 = num21 * (double)vector3.x + num22 * (double)vector.x + num23 * (double)vector2.x;
			double num28 = num24 * (double)vector.x;
			double num29 = num13 * (double)vector3.y + num14 * (double)vector.y + num15 * (double)vector2.y + num16 * (double)vector4.y;
			double num30 = num17 * (double)vector3.y + num18 * (double)vector.y + num19 * (double)vector2.y + num20 * (double)vector4.y;
			double num31 = num21 * (double)vector3.y + num22 * (double)vector.y + num23 * (double)vector2.y;
			double num32 = num24 * (double)vector.y;
			double num33 = num13 * (double)vector3.z + num14 * (double)vector.z + num15 * (double)vector2.z + num16 * (double)vector4.z;
			double num34 = num17 * (double)vector3.z + num18 * (double)vector.z + num19 * (double)vector2.z + num20 * (double)vector4.z;
			double num35 = num21 * (double)vector3.z + num22 * (double)vector.z + num23 * (double)vector2.z;
			double num36 = num24 * (double)vector.z;
			Vector3 vector5 = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float num37 = (float)i * mStepSize;
				Approximation[i].x = (float)(((num25 * (double)num37 + num26) * (double)num37 + num27) * (double)num37 + num28);
				Approximation[i].y = (float)(((num29 * (double)num37 + num30) * (double)num37 + num31) * (double)num37 + num32);
				Approximation[i].z = (float)(((num33 * (double)num37 + num34) * (double)num37 + num35) * (double)num37 + num36);
				vector5.x = Approximation[i].x - Approximation[i - 1].x;
				vector5.y = Approximation[i].y - Approximation[i - 1].y;
				vector5.z = Approximation[i].z - Approximation[i - 1].z;
				float num38 = Mathf.Sqrt(vector5.x * vector5.x + vector5.y * vector5.y + vector5.z * vector5.z);
				num += num38;
				ApproximationDistances[i] = num;
				if ((double)num38 > 9.99999974737875E-06)
				{
					float num39 = 1f / num38;
					ApproximationT[i - 1].x = vector5.x * num39;
					ApproximationT[i - 1].y = vector5.y * num39;
					ApproximationT[i - 1].z = vector5.z * num39;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		private float InterpolateCatmullSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
		{
			float num = 0f;
			Vector3 vector = threadSafeLocalPosition;
			Vector3 vector2 = threadSafeNextCpLocalPosition;
			Vector3 vector3 = threadSafePreviousCpLocalPosition;
			Vector3 vector4 = nextControlPoint.threadSafeNextCpLocalPosition;
			double num2 = -0.5 * (double)vector3.x + 1.5 * (double)vector.x + -1.5 * (double)vector2.x + 0.5 * (double)vector4.x;
			double num3 = (double)vector3.x + -2.5 * (double)vector.x + 2.0 * (double)vector2.x + -0.5 * (double)vector4.x;
			double num4 = -0.5 * (double)vector3.x + 0.5 * (double)vector2.x;
			double num5 = vector.x;
			double num6 = -0.5 * (double)vector3.y + 1.5 * (double)vector.y + -1.5 * (double)vector2.y + 0.5 * (double)vector4.y;
			double num7 = (double)vector3.y + -2.5 * (double)vector.y + 2.0 * (double)vector2.y + -0.5 * (double)vector4.y;
			double num8 = -0.5 * (double)vector3.y + 0.5 * (double)vector2.y;
			double num9 = vector.y;
			double num10 = -0.5 * (double)vector3.z + 1.5 * (double)vector.z + -1.5 * (double)vector2.z + 0.5 * (double)vector4.z;
			double num11 = (double)vector3.z + -2.5 * (double)vector.z + 2.0 * (double)vector2.z + -0.5 * (double)vector4.z;
			double num12 = -0.5 * (double)vector3.z + 0.5 * (double)vector2.z;
			double num13 = vector.z;
			Vector3 vector5 = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float num14 = (float)i * mStepSize;
				Approximation[i].x = (float)(((num2 * (double)num14 + num3) * (double)num14 + num4) * (double)num14 + num5);
				Approximation[i].y = (float)(((num6 * (double)num14 + num7) * (double)num14 + num8) * (double)num14 + num9);
				Approximation[i].z = (float)(((num10 * (double)num14 + num11) * (double)num14 + num12) * (double)num14 + num13);
				vector5.x = Approximation[i].x - Approximation[i - 1].x;
				vector5.y = Approximation[i].y - Approximation[i - 1].y;
				vector5.z = Approximation[i].z - Approximation[i - 1].z;
				float num15 = Mathf.Sqrt(vector5.x * vector5.x + vector5.y * vector5.y + vector5.z * vector5.z);
				num += num15;
				ApproximationDistances[i] = num;
				if ((double)num15 > 9.99999974737875E-06)
				{
					float num16 = 1f / num15;
					ApproximationT[i - 1].x = vector5.x * num16;
					ApproximationT[i - 1].y = vector5.y * num16;
					ApproximationT[i - 1].z = vector5.z * num16;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		private float InterpolateLinearSegment(CurvySplineSegment nextControlPoint, int newCacheSize)
		{
			float num = 0f;
			Vector3 a = threadSafeLocalPosition;
			Vector3 b = nextControlPoint.threadSafeLocalPosition;
			Vector3 vector = default(Vector3);
			for (int i = 1; i < newCacheSize; i++)
			{
				float t = (float)i * mStepSize;
				Approximation[i] = a.LerpUnclamped(b, t);
				vector.x = Approximation[i].x - Approximation[i - 1].x;
				vector.y = Approximation[i].y - Approximation[i - 1].y;
				vector.z = Approximation[i].z - Approximation[i - 1].z;
				float num2 = Mathf.Sqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
				num += num2;
				ApproximationDistances[i] = num;
				if ((double)num2 > 9.99999974737875E-06)
				{
					float num3 = 1f / num2;
					ApproximationT[i - 1].x = vector.x * num3;
					ApproximationT[i - 1].y = vector.y * num3;
					ApproximationT[i - 1].z = vector.z * num3;
				}
				else
				{
					ApproximationT[i - 1].x = 0f;
					ApproximationT[i - 1].y = 0f;
					ApproximationT[i - 1].z = 0f;
				}
			}
			return num;
		}

		internal void refreshOrientationNoneINTERNAL()
		{
			Array.Clear(ApproximationUp, 0, ApproximationUp.Length);
			lastProcessedLocalRotation = threadSafeLocalRotation;
		}

		internal void refreshOrientationStaticINTERNAL()
		{
			Vector3 a = (ApproximationUp[0] = getOrthoUp0INTERNAL());
			if (Approximation.Length > 1)
			{
				int num = CacheSize;
				Vector3 b = (ApproximationUp[num] = getOrthoUp1INTERNAL());
				float num2 = 1f / (float)num;
				for (int i = 1; i < num; i++)
				{
					ApproximationUp[i] = Vector3.SlerpUnclamped(a, b, (float)i * num2);
				}
			}
			lastProcessedLocalRotation = threadSafeLocalRotation;
		}

		internal void refreshOrientationDynamicINTERNAL(Vector3 initialUp)
		{
			int num = ApproximationUp.Length;
			ApproximationUp[0] = initialUp;
			Vector3 axis = default(Vector3);
			for (int i = 1; i < num; i++)
			{
				Vector3 vector = ApproximationT[i - 1];
				Vector3 vector2 = ApproximationT[i];
				axis.x = vector.y * vector2.z - vector.z * vector2.y;
				axis.y = vector.z * vector2.x - vector.x * vector2.z;
				axis.z = vector.x * vector2.y - vector.y * vector2.x;
				float num2 = (float)Math.Atan2(Math.Sqrt(axis.x * axis.x + axis.y * axis.y + axis.z * axis.z), vector.x * vector2.x + vector.y * vector2.y + vector.z * vector2.z);
				ApproximationUp[i] = Quaternion.AngleAxis(57.29578f * num2, axis) * ApproximationUp[i - 1];
			}
			lastProcessedLocalRotation = threadSafeLocalRotation;
		}

		internal void ClearBoundsINTERNAL()
		{
			mBounds = null;
		}

		internal Vector3 getOrthoUp0INTERNAL()
		{
			Vector3 tangent = threadSafeLocalRotation * Vector3.up;
			Vector3.OrthoNormalize(ref ApproximationT[0], ref tangent);
			return tangent;
		}

		private Vector3 getOrthoUp1INTERNAL()
		{
			CurvySplineSegment nextControlPoint = Spline.GetNextControlPoint(this);
			Vector3 tangent = (nextControlPoint ? nextControlPoint.threadSafeLocalRotation : threadSafeLocalRotation) * Vector3.up;
			Vector3.OrthoNormalize(ref ApproximationT[CacheSize], ref tangent);
			return tangent;
		}

		internal void UnsetFollowUpWithoutDirtyingINTERNAL()
		{
			m_FollowUp = null;
			m_FollowUpHeading = ConnectionHeadingEnum.Auto;
		}

		internal void PrepareThreadCompatibleDataINTERNAL(bool useFollowUp)
		{
			CurvySpline spline = Spline;
			CurvySplineSegment previousControlPoint = spline.GetPreviousControlPoint(this);
			CurvySplineSegment nextControlPoint = spline.GetNextControlPoint(this);
			threadSafeLocalPosition = cachedTransform.localPosition;
			threadSafeLocalRotation = cachedTransform.localRotation;
			cachedNextControlPoint = nextControlPoint;
			if (useFollowUp)
			{
				bool num = FollowUp != null;
				CurvySplineSegment curvySplineSegment = ((!num || (object)spline.FirstVisibleControlPoint != this) ? previousControlPoint : CurvySpline.GetFollowUpHeadingControlPoint(FollowUp, FollowUpHeading));
				CurvySplineSegment curvySplineSegment2 = ((!num || (object)spline.LastVisibleControlPoint != this) ? nextControlPoint : CurvySpline.GetFollowUpHeadingControlPoint(FollowUp, FollowUpHeading));
				if ((object)curvySplineSegment != null)
				{
					threadSafePreviousCpLocalPosition = (((object)curvySplineSegment.Spline == spline) ? curvySplineSegment.cachedTransform.localPosition : spline.transform.InverseTransformPoint(curvySplineSegment.cachedTransform.position));
				}
				else
				{
					threadSafePreviousCpLocalPosition = threadSafeLocalPosition;
				}
				if ((object)curvySplineSegment2 != null)
				{
					threadSafeNextCpLocalPosition = (((object)curvySplineSegment2.Spline == spline) ? curvySplineSegment2.cachedTransform.localPosition : spline.transform.InverseTransformPoint(curvySplineSegment2.cachedTransform.position));
				}
				else
				{
					threadSafeNextCpLocalPosition = threadSafeLocalPosition;
				}
			}
			else
			{
				threadSafePreviousCpLocalPosition = previousControlPoint?.cachedTransform.localPosition ?? threadSafeLocalPosition;
				threadSafeNextCpLocalPosition = nextControlPoint?.cachedTransform.localPosition ?? threadSafeLocalPosition;
			}
		}
	}
	public static class CurvySplineSegmentDefaultValues
	{
		public const CurvyOrientationSwirl Swirl = CurvyOrientationSwirl.None;

		public const bool AutoHandles = true;

		public const float AutoHandleDistance = 0.39f;

		public static readonly Vector3 HandleIn = new Vector3(-1f, 0f, 0f);

		public static readonly Vector3 HandleOut = new Vector3(1f, 0f, 0f);
	}
	public static class CurvySplineDefaultValues
	{
		public const bool AutoEndTangents = true;

		public const CurvyOrientation Orientation = CurvyOrientation.Dynamic;

		public const float AutoHandleDistance = 0.39f;

		public const int CacheDensity = 50;

		public const float MaxPointsPerUnit = 8f;

		public const bool UsePooling = true;

		public const CurvyUpdateMethod UpdateIn = CurvyUpdateMethod.Update;

		public const bool CheckTransform = true;
	}
	[RequireComponent(typeof(RectTransform))]
	[AddComponentMenu("Curvy/Curvy UI Spline", 2)]
	[HelpURL("https://curvyeditor.com/doclink/curvyuispline")]
	public class CurvyUISpline : CurvySpline
	{
		public static CurvyUISpline CreateUISpline(string gameObjectName = "Curvy UI Spline")
		{
			CurvyUISpline component = new GameObject(gameObjectName, typeof(CurvyUISpline)).GetComponent<CurvyUISpline>();
			component.SetupUISpline();
			return component;
		}

		protected override void Reset()
		{
			base.Reset();
			SetupUISpline();
		}

		private void SetupUISpline()
		{
			base.RestrictTo2D = true;
			base.MaxPointsPerUnit = 1f;
			base.Orientation = CurvyOrientation.None;
		}
	}
}
namespace FluffyUnderware.Curvy.ThirdParty.LibTessDotNet
{
	internal class Dict<TValue> where TValue : class
	{
		public class Node
		{
			internal TValue _key;

			internal Node _prev;

			internal Node _next;

			public TValue Key => _key;

			public Node Prev => _prev;

			public Node Next => _next;
		}

		public delegate bool LessOrEqual(TValue lhs, TValue rhs);

		private LessOrEqual _leq;

		private Node _head;

		public Dict(LessOrEqual leq)
		{
			_leq = leq;
			_head = new Node
			{
				_key = null
			};
			_head._prev = _head;
			_head._next = _head;
		}

		public Node Insert(TValue key)
		{
			return InsertBefore(_head, key);
		}

		public Node InsertBefore(Node node, TValue key)
		{
			do
			{
				node = node._prev;
			}
			while (node._key != null && !_leq(node._key, key));
			Node node2 = new Node
			{
				_key = key
			};
			node2._next = node._next;
			node._next._prev = node2;
			node2._prev = node;
			node._next = node2;
			return node2;
		}

		public Node Find(TValue key)
		{
			Node node = _head;
			do
			{
				node = node._next;
			}
			while (node._key != null && !_leq(key, node._key));
			return node;
		}

		public Node Min()
		{
			return _head._next;
		}

		public void Remove(Node node)
		{
			node._next._prev = node._prev;
			node._prev._next = node._next;
		}
	}
	internal static class Geom
	{
		public static bool IsWindingInside(WindingRule rule, int n)
		{
			switch (rule)
			{
			case WindingRule.EvenOdd:
				return (n & 1) == 1;
			case WindingRule.NonZero:
				return n != 0;
			case WindingRule.Positive:
				return n > 0;
			case WindingRule.Negative:
				return n < 0;
			case WindingRule.AbsGeqTwo:
				if (n < 2)
				{
					return n <= -2;
				}
				return true;
			default:
				throw new Exception("Wrong winding rule");
			}
		}

		public static bool VertCCW(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			return u._s * (v._t - w._t) + v._s * (w._t - u._t) + w._s * (u._t - v._t) >= 0f;
		}

		public static bool VertEq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
		{
			if (lhs._s == rhs._s)
			{
				return lhs._t == rhs._t;
			}
			return false;
		}

		public static bool VertLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
		{
			if (!(lhs._s < rhs._s))
			{
				if (lhs._s == rhs._s)
				{
					return lhs._t <= rhs._t;
				}
				return false;
			}
			return true;
		}

		public static float EdgeEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._s - u._s;
			float num2 = w._s - v._s;
			if (num + num2 > 0f)
			{
				if (num < num2)
				{
					return v._t - u._t + (u._t - w._t) * (num / (num + num2));
				}
				return v._t - w._t + (w._t - u._t) * (num2 / (num + num2));
			}
			return 0f;
		}

		public static float EdgeSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._s - u._s;
			float num2 = w._s - v._s;
			if (num + num2 > 0f)
			{
				return (v._t - w._t) * num + (v._t - u._t) * num2;
			}
			return 0f;
		}

		public static bool TransLeq(MeshUtils.Vertex lhs, MeshUtils.Vertex rhs)
		{
			if (!(lhs._t < rhs._t))
			{
				if (lhs._t == rhs._t)
				{
					return lhs._s <= rhs._s;
				}
				return false;
			}
			return true;
		}

		public static float TransEval(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._t - u._t;
			float num2 = w._t - v._t;
			if (num + num2 > 0f)
			{
				if (num < num2)
				{
					return v._s - u._s + (u._s - w._s) * (num / (num + num2));
				}
				return v._s - w._s + (w._s - u._s) * (num2 / (num + num2));
			}
			return 0f;
		}

		public static float TransSign(MeshUtils.Vertex u, MeshUtils.Vertex v, MeshUtils.Vertex w)
		{
			float num = v._t - u._t;
			float num2 = w._t - v._t;
			if (num + num2 > 0f)
			{
				return (v._s - w._s) * num + (v._s - u._s) * num2;
			}
			return 0f;
		}

		public static bool EdgeGoesLeft(MeshUtils.Edge e)
		{
			return VertLeq(e._Dst, e._Org);
		}

		public static bool EdgeGoesRight(MeshUtils.Edge e)
		{
			return VertLeq(e._Org, e._Dst);
		}

		public static float VertL1dist(MeshUtils.Vertex u, MeshUtils.Vertex v)
		{
			return Math.Abs(u._s - v._s) + Math.Abs(u._t - v._t);
		}

		public static void AddWinding(MeshUtils.Edge eDst, MeshUtils.Edge eSrc)
		{
			eDst._winding += eSrc._winding;
			eDst._Sym._winding += eSrc._Sym._winding;
		}

		public static float Interpolate(float a, float x, float b, float y)
		{
			if (a < 0f)
			{
				a = 0f;
			}
			if (b < 0f)
			{
				b = 0f;
			}
			if (!(a <= b))
			{
				return y + (x - y) * (b / (a + b));
			}
			if (b != 0f)
			{
				return x + (y - x) * (a / (a + b));
			}
			return (x + y) / 2f;
		}

		private static void Swap(ref MeshUtils.Vertex a, ref MeshUtils.Vertex b)
		{
			MeshUtils.Vertex vertex = a;
			a = b;
			b = vertex;
		}

		public static void EdgeIntersect(MeshUtils.Vertex o1, MeshUtils.Vertex d1, MeshUtils.Vertex o2, MeshUtils.Vertex d2, MeshUtils.Vertex v)
		{
			if (!VertLeq(o1, d1))
			{
				Swap(ref o1, ref d1);
			}
			if (!VertLeq(o2, d2))
			{
				Swap(ref o2, ref d2);
			}
			if (!VertLeq(o1, o2))
			{
				Swap(ref o1, ref o2);
				Swap(ref d1, ref d2);
			}
			if (!VertLeq(o2, d1))
			{
				v._s = (o2._s + d1._s) / 2f;
			}
			else if (VertLeq(d1, d2))
			{
				float num = EdgeEval(o1, o2, d1);
				float num2 = EdgeEval(o2, d1, d2);
				if (num + num2 < 0f)
				{
					num = 0f - num;
					num2 = 0f - num2;
				}
				v._s = Interpolate(num, o2._s, num2, d1._s);
			}
			else
			{
				float num3 = EdgeSign(o1, o2, d1);
				float num4 = 0f - EdgeSign(o1, d2, d1);
				if (num3 + num4 < 0f)
				{
					num3 = 0f - num3;
					num4 = 0f - num4;
				}
				v._s = Interpolate(num3, o2._s, num4, d2._s);
			}
			if (!TransLeq(o1, d1))
			{
				Swap(ref o1, ref d1);
			}
			if (!TransLeq(o2, d2))
			{
				Swap(ref o2, ref d2);
			}
			if (!TransLeq(o1, o2))
			{
				Swap(ref o1, ref o2);
				Swap(ref d1, ref d2);
			}
			if (!TransLeq(o2, d1))
			{
				v._t = (o2._t + d1._t) / 2f;
			}
			else if (TransLeq(d1, d2))
			{
				float num5 = TransEval(o1, o2, d1);
				float num6 = TransEval(o2, d1, d2);
				if (num5 + num6 < 0f)
				{
					num5 = 0f - num5;
					num6 = 0f - num6;
				}
				v._t = Interpolate(num5, o2._t, num6, d1._t);
			}
			else
			{
				float num7 = TransSign(o1, o2, d1);
				float num8 = 0f - TransSign(o1, d2, d1);
				if (num7 + num8 < 0f)
				{
					num7 = 0f - num7;
					num8 = 0f - num8;
				}
				v._t = Interpolate(num7, o2._t, num8, d2._t);
			}
		}
	}
	internal class LTMesh : MeshUtils.Pooled<LTMesh>
	{
		internal MeshUtils.Vertex _vHead;

		internal MeshUtils.Face _fHead;

		internal MeshUtils.Edge _eHead;

		internal MeshUtils.Edge _eHeadSym;

		public LTMesh()
		{
			MeshUtils.Vertex vertex = (_vHead = MeshUtils.Pooled<MeshUtils.Vertex>.Create());
			MeshUtils.Face face = (_fHead = MeshUtils.Pooled<MeshUtils.Face>.Create());
			MeshUtils.EdgePair edgePair = MeshUtils.EdgePair.Create();
			MeshUtils.Edge edge = (_eHead = edgePair._e);
			MeshUtils.Edge edge2 = (_eHeadSym = edgePair._eSym);
			vertex._next = (vertex._prev = vertex);
			vertex._anEdge = null;
			face._next = (face._prev = face);
			face._anEdge = null;
			face._trail = null;
			face._marked = false;
			face._inside = false;
			edge._next = edge;
			edge._Sym = edge2;
			edge._Onext = null;
			edge._Lnext = null;
			edge._Org = null;
			edge._Lface = null;
			edge._winding = 0;
			edge._activeRegion = null;
			edge2._next = edge2;
			edge2._Sym = edge;
			edge2._Onext = null;
			edge2._Lnext = null;
			edge2._Org = null;
			edge2._Lface = null;
			edge2._winding = 0;
			edge2._activeRegion = null;
		}

		public override void Reset()
		{
			_vHead = null;
			_fHead = null;
			_eHead = (_eHeadSym = null);
		}

		public override void OnFree()
		{
			MeshUtils.Face face = _fHead._next;
			MeshUtils.Face fHead = _fHead;
			while (face != _fHead)
			{
				fHead = face._next;
				face.Free();
				face = fHead;
			}
			MeshUtils.Vertex vertex = _vHead._next;
			MeshUtils.Vertex vHead = _vHead;
			while (vertex != _vHead)
			{
				vHead = vertex._next;
				vertex.Free();
				vertex = vHead;
			}
			MeshUtils.Edge edge = _eHead._next;
			MeshUtils.Edge eHead = _eHead;
			while (edge != _eHead)
			{
				eHead = edge._next;
				edge.Free();
				edge = eHead;
			}
		}

		public MeshUtils.Edge MakeEdge()
		{
			MeshUtils.Edge edge = MeshUtils.MakeEdge(_eHead);
			MeshUtils.MakeVertex(edge, _vHead);
			MeshUtils.MakeVertex(edge._Sym, _vHead);
			MeshUtils.MakeFace(edge, _fHead);
			return edge;
		}

		public void Splice(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
		{
			if (eOrg != eDst)
			{
				bool flag = false;
				if (eDst._Org != eOrg._Org)
				{
					flag = true;
					MeshUtils.KillVertex(eDst._Org, eOrg._Org);
				}
				bool flag2 = false;
				if (eDst._Lface != eOrg._Lface)
				{
					flag2 = true;
					MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
				}
				MeshUtils.Splice(eDst, eOrg);
				if (!flag)
				{
					MeshUtils.MakeVertex(eDst, eOrg._Org);
					eOrg._Org._anEdge = eOrg;
				}
				if (!flag2)
				{
					MeshUtils.MakeFace(eDst, eOrg._Lface);
					eOrg._Lface._anEdge = eOrg;
				}
			}
		}

		public void Delete(MeshUtils.Edge eDel)
		{
			MeshUtils.Edge sym = eDel._Sym;
			bool flag = false;
			if (eDel._Lface != eDel._Rface)
			{
				flag = true;
				MeshUtils.KillFace(eDel._Lface, eDel._Rface);
			}
			if (eDel._Onext == eDel)
			{
				MeshUtils.KillVertex(eDel._Org, null);
			}
			else
			{
				eDel._Rface._anEdge = eDel._Oprev;
				eDel._Org._anEdge = eDel._Onext;
				MeshUtils.Splice(eDel, eDel._Oprev);
				if (!flag)
				{
					MeshUtils.MakeFace(eDel, eDel._Lface);
				}
			}
			if (sym._Onext == sym)
			{
				MeshUtils.KillVertex(sym._Org, null);
				MeshUtils.KillFace(sym._Lface, null);
			}
			else
			{
				eDel._Lface._anEdge = sym._Oprev;
				sym._Org._anEdge = sym._Onext;
				MeshUtils.Splice(sym, sym._Oprev);
			}
			MeshUtils.KillEdge(eDel);
		}

		public MeshUtils.Edge AddEdgeVertex(MeshUtils.Edge eOrg)
		{
			MeshUtils.Edge edge = MeshUtils.MakeEdge(eOrg);
			MeshUtils.Edge sym = edge._Sym;
			MeshUtils.Splice(edge, eOrg._Lnext);
			edge._Org = eOrg._Dst;
			MeshUtils.MakeVertex(sym, edge._Org);
			edge._Lface = (sym._Lface = eOrg._Lface);
			return edge;
		}

		public MeshUtils.Edge SplitEdge(MeshUtils.Edge eOrg)
		{
			MeshUtils.Edge sym = AddEdgeVertex(eOrg)._Sym;
			MeshUtils.Splice(eOrg._Sym, eOrg._Sym._Oprev);
			MeshUtils.Splice(eOrg._Sym, sym);
			eOrg._Dst = sym._Org;
			sym._Dst._anEdge = sym._Sym;
			sym._Rface = eOrg._Rface;
			sym._winding = eOrg._winding;
			sym._Sym._winding = eOrg._Sym._winding;
			return sym;
		}

		public MeshUtils.Edge Connect(MeshUtils.Edge eOrg, MeshUtils.Edge eDst)
		{
			MeshUtils.Edge edge = MeshUtils.MakeEdge(eOrg);
			MeshUtils.Edge sym = edge._Sym;
			bool flag = false;
			if (eDst._Lface != eOrg._Lface)
			{
				flag = true;
				MeshUtils.KillFace(eDst._Lface, eOrg._Lface);
			}
			MeshUtils.Splice(edge, eOrg._Lnext);
			MeshUtils.Splice(sym, eDst);
			edge._Org = eOrg._Dst;
			sym._Org = eDst._Org;
			edge._Lface = (sym._Lface = eOrg._Lface);
			eOrg._Lface._anEdge = sym;
			if (!flag)
			{
				MeshUtils.MakeFace(edge, eOrg._Lface);
			}
			return edge;
		}

		public void ZapFace(MeshUtils.Face fZap)
		{
			MeshUtils.Edge anEdge = fZap._anEdge;
			MeshUtils.Edge lnext = anEdge._Lnext;
			MeshUtils.Edge edge;
			do
			{
				edge = lnext;
				lnext = edge._Lnext;
				edge._Lface = null;
				if (edge._Rface == null)
				{
					if (edge._Onext == edge)
					{
						MeshUtils.KillVertex(edge._Org, null);
					}
					else
					{
						edge._Org._anEdge = edge._Onext;
						MeshUtils.Splice(edge, edge._Oprev);
					}
					MeshUtils.Edge sym = edge._Sym;
					if (sym._Onext == sym)
					{
						MeshUtils.KillVertex(sym._Org, null);
					}
					else
					{
						sym._Org._anEdge = sym._Onext;
						MeshUtils.Splice(sym, sym._Oprev);
					}
					MeshUtils.KillEdge(edge);
				}
			}
			while (edge != anEdge);
			MeshUtils.Face prev = fZap._prev;
			MeshUtils.Face next = fZap._next;
			next._prev = prev;
			prev._next = next;
			fZap.Free();
		}

		public void MergeConvexFaces(int maxVertsPerFace)
		{
			for (MeshUtils.Face next = _fHead._next; next != _fHead; next = next._next)
			{
				if (next._inside)
				{
					MeshUtils.Edge edge = next._anEdge;
					MeshUtils.Vertex org = edge._Org;
					while (true)
					{
						MeshUtils.Edge lnext = edge._Lnext;
						MeshUtils.Edge sym = edge._Sym;
						if (sym != null && sym._Lface != null && sym._Lface._inside)
						{
							int vertsCount = next.VertsCount;
							int vertsCount2 = sym._Lface.VertsCount;
							if (vertsCount + vertsCount2 - 2 <= maxVertsPerFace && Geom.VertCCW(edge._Lprev._Org, edge._Org, sym._Lnext._Lnext._Org) && Geom.VertCCW(sym._Lprev._Org, sym._Org, edge._Lnext._Lnext._Org))
							{
								lnext = sym._Lnext;
								Delete(sym);
								edge = null;
							}
						}
						if (edge != null && edge._Lnext._Org == org)
						{
							break;
						}
						edge = lnext;
					}
				}
			}
		}

		[System.Diagnostics.Conditional("DEBUG")]
		public void Check()
		{
			MeshUtils.Face fHead = _fHead;
			fHead = _fHead;
			MeshUtils.Face next;
			MeshUtils.Edge edge;
			while ((next = fHead._next) != _fHead)
			{
				edge = next._anEdge;
				do
				{
					edge = edge._Lnext;
				}
				while (edge != next._anEdge);
				fHead = next;
			}
			MeshUtils.Vertex vHead = _vHead;
			vHead = _vHead;
			MeshUtils.Vertex next2;
			while ((next2 = vHead._next) != _vHead)
			{
				edge = next2._anEdge;
				do
				{
					edge = edge._Onext;
				}
				while (edge != next2._anEdge);
				vHead = next2;
			}
			MeshUtils.Edge eHead = _eHead;
			eHead = _eHead;
			while ((edge = eHead._next) != _eHead)
			{
				eHead = edge;
			}
		}
	}
	public struct Vec3
	{
		public static readonly Vec3 Zero;

		public float X;

		public float Y;

		public float Z;

		public float this[int index]
		{
			get
			{
				return index switch
				{
					0 => X, 
					1 => Y, 
					2 => Z, 
					_ => throw new IndexOutOfRangeException(), 
				};
			}
			set
			{
				switch (index)
				{
				case 0:
					X = value;
					break;
				case 1:
					Y = value;
					break;
				case 2:
					Z = value;
					break;
				default:
					throw new IndexOutOfRangeException();
				}
			}
		}

		public static void Sub(ref Vec3 lhs, ref Vec3 rhs, out Vec3 result)
		{
			result.X = lhs.X - rhs.X;
			result.Y = lhs.Y - rhs.Y;
			result.Z = lhs.Z - rhs.Z;
		}

		public static void Neg(ref Vec3 v)
		{
			v.X = 0f - v.X;
			v.Y = 0f - v.Y;
			v.Z = 0f - v.Z;
		}

		public static void Dot(ref Vec3 u, ref Vec3 v, out float dot)
		{
			dot = u.X * v.X + u.Y * v.Y + u.Z * v.Z;
		}

		public static void Normalize(ref Vec3 v)
		{
			float num = v.X * v.X + v.Y * v.Y + v.Z * v.Z;
			num = 1f / (float)Math.Sqrt(num);
			v.X *= num;
			v.Y *= num;
			v.Z *= num;
		}

		public static int LongAxis(ref Vec3 v)
		{
			int num = 0;
			if (Math.Abs(v.Y) > Math.Abs(v.X))
			{
				num = 1;
			}
			if (Math.Abs(v.Z) > Math.Abs((num == 0) ? v.X : v.Y))
			{
				num = 2;
			}
			return num;
		}

		public override string ToString()
		{
			return $"{X}, {Y}, {Z}";
		}
	}
	internal static class MeshUtils
	{
		public abstract class Pooled<T> where T : Pooled<T>, new()
		{
			private static Stack<T> _stack;

			public abstract void Reset();

			public virtual void OnFree()
			{
			}

			public static T Create()
			{
				if (_stack != null && _stack.Count > 0)
				{
					return _stack.Pop();
				}
				return new T();
			}

			public void Free()
			{
				OnFree();
				Reset();
				if (_stack == null)
				{
					_stack = new Stack<T>();
				}
				_stack.Push((T)this);
			}
		}

		public class Vertex : Pooled<Vertex>
		{
			internal Vertex _prev;

			internal Vertex _next;

			internal Edge _anEdge;

			internal Vec3 _coords;

			internal float _s;

			internal float _t;

			internal PQHandle _pqHandle;

			internal int _n;

			internal object _data;

			public override void Reset()
			{
				_prev = (_next = null);
				_anEdge = null;
				_coords = Vec3.Zero;
				_s = 0f;
				_t = 0f;
				_pqHandle = default(PQHandle);
				_n = 0;
				_data = null;
			}
		}

		public class Face : Pooled<Face>
		{
			internal Face _prev;

			internal Face _next;

			internal Edge _anEdge;

			internal Face _trail;

			internal int _n;

			internal bool _marked;

			internal bool _inside;

			internal int VertsCount
			{
				get
				{
					int num = 0;
					Edge edge = _anEdge;
					do
					{
						num++;
						edge = edge._Lnext;
					}
					while (edge != _anEdge);
					return num;
				}
			}

			public override void Reset()
			{
				_prev = (_next = null);
				_anEdge = null;
				_trail = null;
				_n = 0;
				_marked = false;
				_inside = false;
			}
		}

		public struct EdgePair
		{
			internal Edge _e;

			internal Edge _eSym;

			public static EdgePair Create()
			{
				EdgePair edgePair = default(EdgePair);
				edgePair._e = Pooled<Edge>.Create();
				edgePair._e._pair = edgePair;
				edgePair._eSym = Pooled<Edge>.Create();
				edgePair._eSym._pair = edgePair;
				return edgePair;
			}

			public void Reset()
			{
				_e = (_eSym = null);
			}
		}

		public class Edge : Pooled<Edge>
		{
			internal EdgePair _pair;

			internal Edge _next;

			internal Edge _Sym;

			internal Edge _Onext;

			internal Edge _Lnext;

			internal Vertex _Org;

			internal Face _Lface;

			internal Tess.ActiveRegion _activeRegion;

			internal int _winding;

			internal Face _Rface
			{
				get
				{
					return _Sym._Lface;
				}
				set
				{
					_Sym._Lface = value;
				}
			}

			internal Vertex _Dst
			{
				get
				{
					return _Sym._Org;
				}
				set
				{
					_Sym._Org = value;
				}
			}

			internal Edge _Oprev
			{
				get
				{
					return _Sym._Lnext;
				}
				set
				{
					_Sym._Lnext = value;
				}
			}

			internal Edge _Lprev
			{
				get
				{
					return _Onext._Sym;
				}
				set
				{
					_Onext._Sym = value;
				}
			}

			internal Edge _Dprev
			{
				get
				{
					return _Lnext._Sym;
				}
				set
				{
					_Lnext._Sym = value;
				}
			}

			internal Edge _Rprev
			{
				get
				{
					return _Sym._Onext;
				}
				set
				{
					_Sym._Onext = value;
				}
			}

			internal Edge _Dnext
			{
				get
				{
					return _Rprev._Sym;
				}
				set
				{
					_Rprev._Sym = value;
				}
			}

			internal Edge _Rnext
			{
				get
				{
					return _Oprev._Sym;
				}
				set
				{
					_Oprev._Sym = value;
				}
			}

			internal static void EnsureFirst(ref Edge e)
			{
				if (e == e._pair._eSym)
				{
					e = e._Sym;
				}
			}

			public override void Reset()
			{
				_pair.Reset();
				_next = (_Sym = (_Onext = (_Lnext = null)));
				_Org = null;
				_Lface = null;
				_activeRegion = null;
				_winding = 0;
			}
		}

		public const int Undef = -1;

		public static Edge MakeEdge(Edge eNext)
		{
			EdgePair edgePair = EdgePair.Create();
			Edge e = edgePair._e;
			Edge eSym = edgePair._eSym;
			Edge.EnsureFirst(ref eNext);
			(eSym._next = eNext._Sym._next)._Sym._next = e;
			e._next = eNext;
			eNext._Sym._next = eSym;
			e._Sym = eSym;
			e._Onext = e;
			e._Lnext = eSym;
			e._Org = null;
			e._Lface = null;
			e._winding = 0;
			e._activeRegion = null;
			eSym._Sym = e;
			eSym._Onext = eSym;
			eSym._Lnext = e;
			eSym._Org = null;
			eSym._Lface = null;
			eSym._winding = 0;
			eSym._activeRegion = null;
			return e;
		}

		public static void Splice(Edge a, Edge b)
		{
			Edge onext = a._Onext;
			Edge onext2 = b._Onext;
			onext._Sym._Lnext = b;
			onext2._Sym._Lnext = a;
			a._Onext = onext2;
			b._Onext = onext;
		}

		public static void MakeVertex(Edge eOrig, Vertex vNext)
		{
			Vertex vertex = Pooled<Vertex>.Create();
			(vertex._prev = vNext._prev)._next = vertex;
			vertex._next = vNext;
			vNext._prev = vertex;
			vertex._anEdge = eOrig;
			Edge edge = eOrig;
			do
			{
				edge._Org = vertex;
				edge = edge._Onext;
			}
			while (edge != eOrig);
		}

		public static void MakeFace(Edge eOrig, Face fNext)
		{
			Face face = Pooled<Face>.Create();
			(face._prev = fNext._prev)._next = face;
			face._next = fNext;
			fNext._prev = face;
			face._anEdge = eOrig;
			face._trail = null;
			face._marked = false;
			face._inside = fNext._inside;
			Edge edge = eOrig;
			do
			{
				edge._Lface = face;
				edge = edge._Lnext;
			}
			while (edge != eOrig);
		}

		public static void KillEdge(Edge eDel)
		{
			Edge.EnsureFirst(ref eDel);
			Edge next = eDel._next;
			Edge next2 = eDel._Sym._next;
			next._Sym._next = next2;
			next2._Sym._next = next;
			eDel.Free();
		}

		public static void KillVertex(Vertex vDel, Vertex newOrg)
		{
			Edge anEdge = vDel._anEdge;
			Edge edge = anEdge;
			do
			{
				edge._Org = newOrg;
				edge = edge._Onext;
			}
			while (edge != anEdge);
			Vertex prev = vDel._prev;
			Vertex next = vDel._next;
			next._prev = prev;
			prev._next = next;
			vDel.Free();
		}

		public static void KillFace(Face fDel, Face newLFace)
		{
			Edge anEdge = fDel._anEdge;
			Edge edge = anEdge;
			do
			{
				edge._Lface = newLFace;
				edge = edge._Lnext;
			}
			while (edge != anEdge);
			Face prev = fDel._prev;
			Face next = fDel._next;
			next._prev = prev;
			prev._next = next;
			fDel.Free();
		}

		public static float FaceArea(Face f)
		{
			float num = 0f;
			Edge edge = f._anEdge;
			do
			{
				num += (edge._Org._s - edge._Dst._s) * (edge._Org._t + edge._Dst._t);
				edge = edge._Lnext;
			}
			while (edge != f._anEdge);
			return num;
		}
	}
	internal struct PQHandle
	{
		public static readonly int Invalid = 268435455;

		internal int _handle;
	}
	internal class PriorityHeap<TValue> where TValue : class
	{
		public delegate bool LessOrEqual(TValue lhs, TValue rhs);

		protected class HandleElem
		{
			internal TValue _key;

			internal int _node;
		}

		private LessOrEqual _leq;

		private int[] _nodes;

		private HandleElem[] _handles;

		private int _size;

		private int _max;

		private int _freeList;

		private bool _initialized;

		public bool Empty => _size == 0;

		public PriorityHeap(int initialSize, LessOrEqual leq)
		{
			_leq = leq;
			_nodes = new int[initialSize + 1];
			_handles = new HandleElem[initialSize + 1];
			_size = 0;
			_max = initialSize;
			_freeList = 0;
			_initialized = false;
			_nodes[1] = 1;
			_handles[1] = new HandleElem
			{
				_key = null
			};
		}

		private void FloatDown(int curr)
		{
			int num = _nodes[curr];
			while (true)
			{
				int num2 = curr << 1;
				if (num2 < _size && _leq(_handles[_nodes[num2 + 1]]._key, _handles[_nodes[num2]]._key))
				{
					num2++;
				}
				int num3 = _nodes[num2];
				if (num2 > _size || _leq(_handles[num]._key, _handles[num3]._key))
				{
					break;
				}
				_nodes[curr] = num3;
				_handles[num3]._node = curr;
				curr = num2;
			}
			_nodes[curr] = num;
			_handles[num]._node = curr;
		}

		private void FloatUp(int curr)
		{
			int num = _nodes[curr];
			while (true)
			{
				int num2 = curr >> 1;
				int num3 = _nodes[num2];
				if (num2 == 0 || _leq(_handles[num3]._key, _handles[num]._key))
				{
					break;
				}
				_nodes[curr] = num3;
				_handles[num3]._node = curr;
				curr = num2;
			}
			_nodes[curr] = num;
			_handles[num]._node = curr;
		}

		public void Init()
		{
			for (int num = _size; num >= 1; num--)
			{
				FloatDown(num);
			}
			_initialized = true;
		}

		public PQHandle Insert(TValue value)
		{
			int num = ++_size;
			if (num * 2 > _max)
			{
				_max <<= 1;
				Array.Resize(ref _nodes, _max + 1);
				Array.Resize(ref _handles, _max + 1);
			}
			int num2;
			if (_freeList == 0)
			{
				num2 = num;
			}
			else
			{
				num2 = _freeList;
				_freeList = _handles[num2]._node;
			}
			_nodes[num] = num2;
			if (_handles[num2] == null)
			{
				_handles[num2] = new HandleElem
				{
					_key = value,
					_node = num
				};
			}
			else
			{
				_handles[num2]._node = num;
				_handles[num2]._key = value;
			}
			if (_initialized)
			{
				FloatUp(num);
			}
			PQHandle result = default(PQHandle);
			result._handle = num2;
			return result;
		}

		public TValue ExtractMin()
		{
			int num = _nodes[1];
			TValue key = _handles[num]._key;
			if (_size > 0)
			{
				_nodes[1] = _nodes[_size];
				_handles[_nodes[1]]._node = 1;
				_handles[num]._key = null;
				_handles[num]._node = _freeList;
				_freeList = num;
				if (--_size > 0)
				{
					FloatDown(1);
				}
			}
			return key;
		}

		public TValue Minimum()
		{
			return _handles[_nodes[1]]._key;
		}

		public void Remove(PQHandle handle)
		{
			int handle2 = handle._handle;
			int node = _handles[handle2]._node;
			_nodes[node] = _nodes[_size];
			_handles[_nodes[node]]._node = node;
			if (node <= --_size)
			{
				if (node <= 1 || _leq(_handles[_nodes[node >> 1]]._key, _handles[_nodes[node]]._key))
				{
					FloatDown(node);
				}
				else
				{
					FloatUp(node);
				}
			}
			_handles[handle2]._key = null;
			_handles[handle2]._node = _freeList;
			_freeList = handle2;
		}
	}
	internal class PriorityQueue<TValue> where TValue : class
	{
		private class StackItem
		{
			internal int p;

			internal int r;
		}

		private PriorityHeap<TValue>.LessOrEqual _leq;

		private PriorityHeap<TValue> _heap;

		private TValue[] _keys;

		private int[] _order;

		private int _size;

		private int _max;

		private bool _initialized;

		public bool Empty
		{
			get
			{
				if (_size == 0)
				{
					return _heap.Empty;
				}
				return false;
			}
		}

		public PriorityQueue(int initialSize, PriorityHeap<TValue>.LessOrEqual leq)
		{
			_leq = leq;
			_heap = new PriorityHeap<TValue>(initialSize, leq);
			_keys = new TValue[initialSize];
			_size = 0;
			_max = initialSize;
			_initialized = false;
		}

		private static void Swap(ref int a, ref int b)
		{
			int num = a;
			a = b;
			b = num;
		}

		public void Init()
		{
			Stack<StackItem> stack = new Stack<StackItem>();
			uint num = 2016473283u;
			int num2 = 0;
			int num3 = _size - 1;
			_order = new int[_size + 1];
			int num4 = 0;
			for (int i = num2; i <= num3; i++)
			{
				_order[i] = num4;
				num4++;
			}
			stack.Push(new StackItem
			{
				p = num2,
				r = num3
			});
			while (stack.Count > 0)
			{
				StackItem stackItem = stack.Pop();
				num2 = stackItem.p;
				num3 = stackItem.r;
				while (num3 > num2 + 10)
				{
					num = num * 1539415821 + 1;
					int i = num2 + (int)(num % (num3 - num2 + 1));
					num4 = _order[i];
					_order[i] = _order[num2];
					_order[num2] = num4;
					i = num2 - 1;
					int num5 = num3 + 1;
					while (true)
					{
						i++;
						if (_leq(_keys[_order[i]], _keys[num4]))
						{
							do
							{
								num5--;
							}
							while (!_leq(_keys[num4], _keys[_order[num5]]));
							Swap(ref _order[i], ref _order[num5]);
							if (i >= num5)
							{
								break;
							}
						}
					}
					Swap(ref _order[i], ref _order[num5]);
					if (i - num2 < num3 - num5)
					{
						stack.Push(new StackItem
						{
							p = num5 + 1,
							r = num3
						});
						num3 = i - 1;
					}
					else
					{
						stack.Push(new StackItem
						{
							p = num2,
							r = i - 1
						});
						num2 = num5 + 1;
					}
				}
				for (int i = num2 + 1; i <= num3; i++)
				{
					num4 = _order[i];
					int num5 = i;
					while (num5 > num2 && !_leq(_keys[num4], _keys[_order[num5 - 1]]))
					{
						_order[num5] = _order[num5 - 1];
						num5--;
					}
					_order[num5] = num4;
				}
			}
			_max = _size;
			_initialized = true;
			_heap.Init();
		}

		public PQHandle Insert(TValue value)
		{
			if (_initialized)
			{
				return _heap.Insert(value);
			}
			int size = _size;
			if (++_size >= _max)
			{
				_max <<= 1;
				Array.Resize(ref _keys, _max);
			}
			_keys[size] = value;
			PQHandle result = default(PQHandle);
			result._handle = -(size + 1);
			return result;
		}

		public TValue ExtractMin()
		{
			if (_size == 0)
			{
				return _heap.ExtractMin();
			}
			TValue val = _keys[_order[_size - 1]];
			if (!_heap.Empty)
			{
				TValue lhs = _heap.Minimum();
				if (_leq(lhs, val))
				{
					return _heap.ExtractMin();
				}
			}
			do
			{
				_size--;
			}
			while (_size > 0 && _keys[_order[_size - 1]] == null);
			return val;
		}

		public TValue Minimum()
		{
			if (_size == 0)
			{
				return _heap.Minimum();
			}
			TValue val = _keys[_order[_size - 1]];
			if (!_heap.Empty)
			{
				TValue val2 = _heap.Minimum();
				if (_leq(val2, val))
				{
					return val2;
				}
			}
			return val;
		}

		public void Remove(PQHandle handle)
		{
			int handle2 = handle._handle;
			if (handle2 >= 0)
			{
				_heap.Remove(handle);
				return;
			}
			handle2 = -(handle2 + 1);
			_keys[handle2] = null;
			while (_size > 0 && _keys[_order[_size - 1]] == null)
			{
				_size--;
			}
		}
	}
	public class Tess
	{
		internal class ActiveRegion
		{
			internal MeshUtils.Edge _eUp;

			internal Dict<ActiveRegion>.Node _nodeUp;

			internal int _windingNumber;

			internal bool _inside;

			internal bool _sentinel;

			internal bool _dirty;

			internal bool _fixUpperEdge;
		}

		private LTMesh _mesh;

		private Vec3 _normal;

		private Vec3 _sUnit;

		private Vec3 _tUnit;

		private float _bminX;

		private float _bminY;

		private float _bmaxX;

		private float _bmaxY;

		private WindingRule _windingRule;

		private Dict<ActiveRegion> _dict;

		private PriorityQueue<MeshUtils.Vertex> _pq;

		private MeshUtils.Vertex _event;

		private CombineCallback _combineCallback;

		private ContourVertex[] _vertices;

		private int _vertexCount;

		private int[] _elements;

		private int _elementCount;

		public float SUnitX = 1f;

		public float SUnitY;

		public float SentinelCoord = 4E+30f;

		public bool NoEmptyPolygons;

		public bool UsePooling;

		public Vec3 Normal
		{
			get
			{
				return _normal;
			}
			set
			{
				_normal = value;
			}
		}

		public ContourVertex[] Vertices => _vertices;

		public int VertexCount => _vertexCount;

		public int[] Elements => _elements;

		public int ElementCount => _elementCount;

		private ActiveRegion RegionBelow(ActiveRegion reg)
		{
			return reg._nodeUp._prev._key;
		}

		private ActiveRegion RegionAbove(ActiveRegion reg)
		{
			return reg._nodeUp._next._key;
		}

		private bool EdgeLeq(ActiveRegion reg1, ActiveRegion reg2)
		{
			MeshUtils.Edge eUp = reg1._eUp;
			MeshUtils.Edge eUp2 = reg2._eUp;
			if (eUp._Dst == _event)
			{
				if (eUp2._Dst == _event)
				{
					if (Geom.VertLeq(eUp._Org, eUp2._Org))
					{
						return Geom.EdgeSign(eUp2._Dst, eUp._Org, eUp2._Org) <= 0f;
					}
					return Geom.EdgeSign(eUp._Dst, eUp2._Org, eUp._Org) >= 0f;
				}
				return Geom.EdgeSign(eUp2._Dst, _event, eUp2._Org) <= 0f;
			}
			if (eUp2._Dst == _event)
			{
				return Geom.EdgeSign(eUp._Dst, _event, eUp._Org) >= 0f;
			}
			float num = Geom.EdgeEval(eUp._Dst, _event, eUp._Org);
			float num2 = Geom.EdgeEval(eUp2._Dst, _event, eUp2._Org);
			return num >= num2;
		}

		private void DeleteRegion(ActiveRegion reg)
		{
			_ = reg._fixUpperEdge;
			reg._eUp._activeRegion = null;
			_dict.Remove(reg._nodeUp);
		}

		private void FixUpperEdge(ActiveRegion reg, MeshUtils.Edge newEdge)
		{
			_mesh.Delete(reg._eUp);
			reg._fixUpperEdge = false;
			reg._eUp = newEdge;
			newEdge._activeRegion = reg;
		}

		private ActiveRegion TopLeftRegion(ActiveRegion reg)
		{
			MeshUtils.Vertex org = reg._eUp._Org;
			do
			{
				reg = RegionAbove(reg);
			}
			while (reg._eUp._Org == org);
			if (reg._fixUpperEdge)
			{
				MeshUtils.Edge newEdge = _mesh.Connect(RegionBelow(reg)._eUp._Sym, reg._eUp._Lnext);
				FixUpperEdge(reg, newEdge);
				reg = RegionAbove(reg);
			}
			return reg;
		}

		private ActiveRegion TopRightRegion(ActiveRegion reg)
		{
			MeshUtils.Vertex dst = reg._eUp._Dst;
			do
			{
				reg = RegionAbove(reg);
			}
			while (reg._eUp._Dst == dst);
			return reg;
		}

		private ActiveRegion AddRegionBelow(ActiveRegion regAbove, MeshUtils.Edge eNewUp)
		{
			ActiveRegion activeRegion = new ActiveRegion();
			activeRegion._eUp = eNewUp;
			activeRegion._nodeUp = _dict.InsertBefore(regAbove._nodeUp, activeRegion);
			activeRegion._fixUpperEdge = false;
			activeRegion._sentinel = false;
			activeRegion._dirty = false;
			eNewUp._activeRegion = activeRegion;
			return activeRegion;
		}

		private void ComputeWinding(ActiveRegion reg)
		{
			reg._windingNumber = RegionAbove(reg)._windingNumber + reg._eUp._winding;
			reg._inside = Geom.IsWindingInside(_windingRule, reg._windingNumber);
		}

		private void FinishRegion(ActiveRegion reg)
		{
			MeshUtils.Edge eUp = reg._eUp;
			MeshUtils.Face lface = eUp._Lface;
			lface._inside = reg._inside;
			lface._anEdge = eUp;
			DeleteRegion(reg);
		}

		private MeshUtils.Edge FinishLeftRegions(ActiveRegion regFirst, ActiveRegion regLast)
		{
			ActiveRegion activeRegion = regFirst;
			MeshUtils.Edge eUp = regFirst._eUp;
			while (activeRegion != regLast)
			{
				activeRegion._fixUpperEdge = false;
				ActiveRegion activeRegion2 = RegionBelow(activeRegion);
				MeshUtils.Edge edge = activeRegion2._eUp;
				if (edge._Org != eUp._Org)
				{
					if (!activeRegion2._fixUpperEdge)
					{
						FinishRegion(activeRegion);
						break;
					}
					edge = _mesh.Connect(eUp._Lprev, edge._Sym);
					FixUpperEdge(activeRegion2, edge);
				}
				if (eUp._Onext != edge)
				{
					_mesh.Splice(edge._Oprev, edge);
					_mesh.Splice(eUp, edge);
				}
				FinishRegion(activeRegion);
				eUp = activeRegion2._eUp;
				activeRegion = activeRegion2;
			}
			return eUp;
		}

		private void AddRightEdges(ActiveRegion regUp, MeshUtils.Edge eFirst, MeshUtils.Edge eLast, MeshUtils.Edge eTopLeft, bool cleanUp)
		{
			bool flag = true;
			MeshUtils.Edge edge = eFirst;
			do
			{
				AddRegionBelow(regUp, edge._Sym);
				edge = edge._Onext;
			}
			while (edge != eLast);
			if (eTopLeft == null)
			{
				eTopLeft = RegionBelow(regUp)._eUp._Rprev;
			}
			ActiveRegion activeRegion = regUp;
			MeshUtils.Edge edge2 = eTopLeft;
			while (true)
			{
				ActiveRegion activeRegion2 = RegionBelow(activeRegion);
				edge = activeRegion2._eUp._Sym;
				if (edge._Org != edge2._Org)
				{
					break;
				}
				if (edge._Onext != edge2)
				{
					_mesh.Splice(edge._Oprev, edge);
					_mesh.Splice(edge2._Oprev, edge);
				}
				activeRegion2._windingNumber = activeRegion._windingNumber - edge._winding;
				activeRegion2._inside = Geom.IsWindingInside(_windingRule, activeRegion2._windingNumber);
				activeRegion._dirty = true;
				if (!flag && CheckForRightSplice(activeRegion))
				{
					Geom.AddWinding(edge, edge2);
					DeleteRegion(activeRegion);
					_mesh.Delete(edge2);
				}
				flag = false;
				activeRegion = activeRegion2;
				edge2 = edge;
			}
			activeRegion._dirty = true;
			if (cleanUp)
			{
				WalkDirtyRegions(activeRegion);
			}
		}

		private void SpliceMergeVertices(MeshUtils.Edge e1, MeshUtils.Edge e2)
		{
			_mesh.Splice(e1, e2);
		}

		private void VertexWeights(MeshUtils.Vertex isect, MeshUtils.Vertex org, MeshUtils.Vertex dst, out float w0, out float w1)
		{
			float num = Geom.VertL1dist(org, isect);
			float num2 = Geom.VertL1dist(dst, isect);
			w0 = num2 / (num + num2) / 2f;
			w1 = num / (num + num2) / 2f;
			isect._coords.X += w0 * org._coords.X + w1 * dst._coords.X;
			isect._coords.Y += w0 * org._coords.Y + w1 * dst._coords.Y;
			isect._coords.Z += w0 * org._coords.Z + w1 * dst._coords.Z;
		}

		private void GetIntersectData(MeshUtils.Vertex isect, MeshUtils.Vertex orgUp, MeshUtils.Vertex dstUp, MeshUtils.Vertex orgLo, MeshUtils.Vertex dstLo)
		{
			isect._coords = Vec3.Zero;
			VertexWeights(isect, orgUp, dstUp, out var w, out var w2);
			VertexWeights(isect, orgLo, dstLo, out var w3, out var w4);
			if (_combineCallback != null)
			{
				isect._data = _combineCallback(isect._coords, new object[4] { orgUp._data, dstUp._data, orgLo._data, dstLo._data }, new float[4] { w, w2, w3, w4 });
			}
		}

		private bool CheckForRightSplice(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			if (Geom.VertLeq(eUp._Org, eUp2._Org))
			{
				if (Geom.EdgeSign(eUp2._Dst, eUp._Org, eUp2._Org) > 0f)
				{
					return false;
				}
				if (!Geom.VertEq(eUp._Org, eUp2._Org))
				{
					_mesh.SplitEdge(eUp2._Sym);
					_mesh.Splice(eUp, eUp2._Oprev);
					regUp._dirty = (activeRegion._dirty = true);
				}
				else if (eUp._Org != eUp2._Org)
				{
					_pq.Remove(eUp._Org._pqHandle);
					SpliceMergeVertices(eUp2._Oprev, eUp);
				}
			}
			else
			{
				if (Geom.EdgeSign(eUp._Dst, eUp2._Org, eUp._Org) < 0f)
				{
					return false;
				}
				RegionAbove(regUp)._dirty = (regUp._dirty = true);
				_mesh.SplitEdge(eUp._Sym);
				_mesh.Splice(eUp2._Oprev, eUp);
			}
			return true;
		}

		private bool CheckForLeftSplice(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			if (Geom.VertLeq(eUp._Dst, eUp2._Dst))
			{
				if (Geom.EdgeSign(eUp._Dst, eUp2._Dst, eUp._Org) < 0f)
				{
					return false;
				}
				RegionAbove(regUp)._dirty = (regUp._dirty = true);
				MeshUtils.Edge edge = _mesh.SplitEdge(eUp);
				_mesh.Splice(eUp2._Sym, edge);
				edge._Lface._inside = regUp._inside;
			}
			else
			{
				if (Geom.EdgeSign(eUp2._Dst, eUp._Dst, eUp2._Org) > 0f)
				{
					return false;
				}
				regUp._dirty = (activeRegion._dirty = true);
				MeshUtils.Edge edge2 = _mesh.SplitEdge(eUp2);
				_mesh.Splice(eUp._Lnext, eUp2._Sym);
				edge2._Rface._inside = regUp._inside;
			}
			return true;
		}

		private bool CheckForIntersect(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			MeshUtils.Vertex org = eUp._Org;
			MeshUtils.Vertex org2 = eUp2._Org;
			MeshUtils.Vertex dst = eUp._Dst;
			MeshUtils.Vertex dst2 = eUp2._Dst;
			if (org == org2)
			{
				return false;
			}
			float num = Math.Min(org._t, dst._t);
			float num2 = Math.Max(org2._t, dst2._t);
			if (num > num2)
			{
				return false;
			}
			if (Geom.VertLeq(org, org2))
			{
				if (Geom.EdgeSign(dst2, org, org2) > 0f)
				{
					return false;
				}
			}
			else if (Geom.EdgeSign(dst, org2, org) < 0f)
			{
				return false;
			}
			MeshUtils.Vertex vertex = MeshUtils.Pooled<MeshUtils.Vertex>.Create();
			Geom.EdgeIntersect(dst, org, dst2, org2, vertex);
			if (Geom.VertLeq(vertex, _event))
			{
				vertex._s = _event._s;
				vertex._t = _event._t;
			}
			MeshUtils.Vertex vertex2 = (Geom.VertLeq(org, org2) ? org : org2);
			if (Geom.VertLeq(vertex2, vertex))
			{
				vertex._s = vertex2._s;
				vertex._t = vertex2._t;
			}
			if (Geom.VertEq(vertex, org) || Geom.VertEq(vertex, org2))
			{
				CheckForRightSplice(regUp);
				return false;
			}
			if ((!Geom.VertEq(dst, _event) && Geom.EdgeSign(dst, _event, vertex) >= 0f) || (!Geom.VertEq(dst2, _event) && Geom.EdgeSign(dst2, _event, vertex) <= 0f))
			{
				if (dst2 == _event)
				{
					_mesh.SplitEdge(eUp._Sym);
					_mesh.Splice(eUp2._Sym, eUp);
					regUp = TopLeftRegion(regUp);
					eUp = RegionBelow(regUp)._eUp;
					FinishLeftRegions(RegionBelow(regUp), activeRegion);
					AddRightEdges(regUp, eUp._Oprev, eUp, eUp, cleanUp: true);
					return true;
				}
				if (dst == _event)
				{
					_mesh.SplitEdge(eUp2._Sym);
					_mesh.Splice(eUp._Lnext, eUp2._Oprev);
					activeRegion = regUp;
					regUp = TopRightRegion(regUp);
					MeshUtils.Edge rprev = RegionBelow(regUp)._eUp._Rprev;
					activeRegion._eUp = eUp2._Oprev;
					eUp2 = FinishLeftRegions(activeRegion, null);
					AddRightEdges(regUp, eUp2._Onext, eUp._Rprev, rprev, cleanUp: true);
					return true;
				}
				if (Geom.EdgeSign(dst, _event, vertex) >= 0f)
				{
					RegionAbove(regUp)._dirty = (regUp._dirty = true);
					_mesh.SplitEdge(eUp._Sym);
					eUp._Org._s = _event._s;
					eUp._Org._t = _event._t;
				}
				if (Geom.EdgeSign(dst2, _event, vertex) <= 0f)
				{
					regUp._dirty = (activeRegion._dirty = true);
					_mesh.SplitEdge(eUp2._Sym);
					eUp2._Org._s = _event._s;
					eUp2._Org._t = _event._t;
				}
				return false;
			}
			_mesh.SplitEdge(eUp._Sym);
			_mesh.SplitEdge(eUp2._Sym);
			_mesh.Splice(eUp2._Oprev, eUp);
			eUp._Org._s = vertex._s;
			eUp._Org._t = vertex._t;
			eUp._Org._pqHandle = _pq.Insert(eUp._Org);
			if (eUp._Org._pqHandle._handle == PQHandle.Invalid)
			{
				throw new InvalidOperationException("PQHandle should not be invalid");
			}
			GetIntersectData(eUp._Org, org, dst, org2, dst2);
			RegionAbove(regUp)._dirty = (regUp._dirty = (activeRegion._dirty = true));
			return false;
		}

		private void WalkDirtyRegions(ActiveRegion regUp)
		{
			ActiveRegion activeRegion = RegionBelow(regUp);
			while (true)
			{
				if (activeRegion._dirty)
				{
					regUp = activeRegion;
					activeRegion = RegionBelow(activeRegion);
					continue;
				}
				if (!regUp._dirty)
				{
					activeRegion = regUp;
					regUp = RegionAbove(regUp);
					if (regUp == null || !regUp._dirty)
					{
						break;
					}
				}
				regUp._dirty = false;
				MeshUtils.Edge eUp = regUp._eUp;
				MeshUtils.Edge eUp2 = activeRegion._eUp;
				if (eUp._Dst != eUp2._Dst && CheckForLeftSplice(regUp))
				{
					if (activeRegion._fixUpperEdge)
					{
						DeleteRegion(activeRegion);
						_mesh.Delete(eUp2);
						activeRegion = RegionBelow(regUp);
						eUp2 = activeRegion._eUp;
					}
					else if (regUp._fixUpperEdge)
					{
						DeleteRegion(regUp);
						_mesh.Delete(eUp);
						regUp = RegionAbove(activeRegion);
						eUp = regUp._eUp;
					}
				}
				if (eUp._Org != eUp2._Org)
				{
					if (eUp._Dst != eUp2._Dst && !regUp._fixUpperEdge && !activeRegion._fixUpperEdge && (eUp._Dst == _event || eUp2._Dst == _event))
					{
						if (CheckForIntersect(regUp))
						{
							break;
						}
					}
					else
					{
						CheckForRightSplice(regUp);
					}
				}
				if (eUp._Org == eUp2._Org && eUp._Dst == eUp2._Dst)
				{
					Geom.AddWinding(eUp2, eUp);
					DeleteRegion(regUp);
					_mesh.Delete(eUp);
					regUp = RegionAbove(activeRegion);
				}
			}
		}

		private void ConnectRightVertex(ActiveRegion regUp, MeshUtils.Edge eBottomLeft)
		{
			MeshUtils.Edge edge = eBottomLeft._Onext;
			ActiveRegion activeRegion = RegionBelow(regUp);
			MeshUtils.Edge eUp = regUp._eUp;
			MeshUtils.Edge eUp2 = activeRegion._eUp;
			bool flag = false;
			if (eUp._Dst != eUp2._Dst)
			{
				CheckForIntersect(regUp);
			}
			if (Geom.VertEq(eUp._Org, _event))
			{
				_mesh.Splice(edge._Oprev, eUp);
				regUp = TopLeftRegion(regUp);
				edge = RegionBelow(regUp)._eUp;
				FinishLeftRegions(RegionBelow(regUp), activeRegion);
				flag = true;
			}
			if (Geom.VertEq(eUp2._Org, _event))
			{
				_mesh.Splice(eBottomLeft, eUp2._Oprev);
				eBottomLeft = FinishLeftRegions(activeRegion, null);
				flag = true;
			}
			if (flag)
			{
				AddRightEdges(regUp, eBottomLeft._Onext, edge, edge, cleanUp: true);
				return;
			}
			MeshUtils.Edge eDst = ((!Geom.VertLeq(eUp2._Org, eUp._Org)) ? eUp : eUp2._Oprev);
			eDst = _mesh.Connect(eBottomLeft._Lprev, eDst);
			AddRightEdges(regUp, eDst, eDst._Onext, eDst._Onext, cleanUp: false);
			eDst._Sym._activeRegion._fixUpperEdge = true;
			WalkDirtyRegions(regUp);
		}

		private void ConnectLeftDegenerate(ActiveRegion regUp, MeshUtils.Vertex vEvent)
		{
			MeshUtils.Edge eUp = regUp._eUp;
			if (Geom.VertEq(eUp._Org, vEvent))
			{
				throw new InvalidOperationException("Vertices should have been merged before");
			}
			if (!Geom.VertEq(eUp._Dst, vEvent))
			{
				_mesh.SplitEdge(eUp._Sym);
				if (regUp._fixUpperEdge)
				{
					_mesh.Delete(eUp._Onext);
					regUp._fixUpperEdge = false;
				}
				_mesh.Splice(vEvent._anEdge, eUp);
				SweepEvent(vEvent);
				return;
			}
			throw new InvalidOperationException("Vertices should have been merged before");
		}

		private void ConnectLeftVertex(MeshUtils.Vertex vEvent)
		{
			ActiveRegion activeRegion = new ActiveRegion();
			activeRegion._eUp = vEvent._anEdge._Sym;
			ActiveRegion key = _dict.Find(activeRegion).Key;
			ActiveRegion activeRegion2 = RegionBelow(key);
			if (activeRegion2 == null)
			{
				return;
			}
			MeshUtils.Edge eUp = key._eUp;
			MeshUtils.Edge eUp2 = activeRegion2._eUp;
			if (Geom.EdgeSign(eUp._Dst, vEvent, eUp._Org) == 0f)
			{
				ConnectLeftDegenerate(key, vEvent);
				return;
			}
			ActiveRegion activeRegion3 = (Geom.VertLeq(eUp2._Dst, eUp._Dst) ? key : activeRegion2);
			if (key._inside || activeRegion3._fixUpperEdge)
			{
				MeshUtils.Edge edge = ((activeRegion3 != key) ? _mesh.Connect(eUp2._Dnext, vEvent._anEdge)._Sym : _mesh.Connect(vEvent._anEdge._Sym, eUp._Lnext));
				if (activeRegion3._fixUpperEdge)
				{
					FixUpperEdge(activeRegion3, edge);
				}
				else
				{
					ComputeWinding(AddRegionBelow(key, edge));
				}
				SweepEvent(vEvent);
			}
			else
			{
				AddRightEdges(key, vEvent._anEdge, vEvent._anEdge, null, cleanUp: true);
			}
		}

		private void SweepEvent(MeshUtils.Vertex vEvent)
		{
			_event = vEvent;
			MeshUtils.Edge edge = vEvent._anEdge;
			while (edge._activeRegion == null)
			{
				edge = edge._Onext;
				if (edge == vEvent._anEdge)
				{
					ConnectLeftVertex(vEvent);
					return;
				}
			}
			ActiveRegion activeRegion = TopLeftRegion(edge._activeRegion);
			ActiveRegion activeRegion2 = RegionBelow(activeRegion);
			MeshUtils.Edge eUp = activeRegion2._eUp;
			MeshUtils.Edge edge2 = FinishLeftRegions(activeRegion2, null);
			if (edge2._Onext == eUp)
			{
				ConnectRightVertex(activeRegion, edge2);
			}
			else
			{
				AddRightEdges(activeRegion, edge2._Onext, eUp, eUp, cleanUp: true);
			}
		}

		private void AddSentinel(float smin, float smax, float t)
		{
			MeshUtils.Edge edge = _mesh.MakeEdge();
			edge._Org._s = smax;
			edge._Org._t = t;
			edge._Dst._s = smin;
			edge._Dst._t = t;
			_event = edge._Dst;
			ActiveRegion activeRegion = new ActiveRegion();
			activeRegion._eUp = edge;
			activeRegion._windingNumber = 0;
			activeRegion._inside = false;
			activeRegion._fixUpperEdge = false;
			activeRegion._sentinel = true;
			activeRegion._dirty = false;
			activeRegion._nodeUp = _dict.Insert(activeRegion);
		}

		private void InitEdgeDict()
		{
			_dict = new Dict<ActiveRegion>(EdgeLeq);
			AddSentinel(0f - SentinelCoord, SentinelCoord, 0f - SentinelCoord);
			AddSentinel(0f - SentinelCoord, SentinelCoord, SentinelCoord);
		}

		private void DoneEdgeDict()
		{
			ActiveRegion key;
			while ((key = _dict.Min().Key) != null)
			{
				_ = key._sentinel;
				DeleteRegion(key);
			}
			_dict = null;
		}

		private void RemoveDegenerateEdges()
		{
			MeshUtils.Edge eHead = _mesh._eHead;
			MeshUtils.Edge edge = eHead._next;
			while (edge != eHead)
			{
				MeshUtils.Edge next = edge._next;
				MeshUtils.Edge lnext = edge._Lnext;
				if (Geom.VertEq(edge._Org, edge._Dst) && edge._Lnext._Lnext != edge)
				{
					SpliceMergeVertices(lnext, edge);
					_mesh.Delete(edge);
					edge = lnext;
					lnext = edge._Lnext;
				}
				if (lnext._Lnext == edge)
				{
					if (lnext != edge)
					{
						if (lnext == next || lnext == next._Sym)
						{
							next = next._next;
						}
						_mesh.Delete(lnext);
					}
					if (edge == next || edge == next._Sym)
					{
						next = next._next;
					}
					_mesh.Delete(edge);
				}
				edge = next;
			}
		}

		private void InitPriorityQ()
		{
			MeshUtils.Vertex vHead = _mesh._vHead;
			int num = 0;
			for (MeshUtils.Vertex next = vHead._next; next != vHead; next = next._next)
			{
				num++;
			}
			num += 8;
			_pq = new PriorityQueue<MeshUtils.Vertex>(num, Geom.VertLeq);
			vHead = _mesh._vHead;
			for (MeshUtils.Vertex next = vHead._next; next != vHead; next = next._next)
			{
				next._pqHandle = _pq.Insert(next);
				if (next._pqHandle._handle == PQHandle.Invalid)
				{
					throw new InvalidOperationException("PQHandle should not be invalid");
				}
			}
			_pq.Init();
		}

		private void DonePriorityQ()
		{
			_pq = null;
		}

		private void RemoveDegenerateFaces()
		{
			MeshUtils.Face face = _mesh._fHead._next;
			while (face != _mesh._fHead)
			{
				MeshUtils.Face next = face._next;
				MeshUtils.Edge anEdge = face._anEdge;
				if (anEdge._Lnext._Lnext == anEdge)
				{
					Geom.AddWinding(anEdge._Onext, anEdge);
					_mesh.Delete(anEdge);
				}
				face = next;
			}
		}

		protected void ComputeInterior()
		{
			RemoveDegenerateEdges();
			InitPriorityQ();
			RemoveDegenerateFaces();
			InitEdgeDict();
			MeshUtils.Vertex vertex;
			while ((vertex = _pq.ExtractMin()) != null)
			{
				while (true)
				{
					MeshUtils.Vertex vertex2 = _pq.Minimum();
					if (vertex2 == null || !Geom.VertEq(vertex2, vertex))
					{
						break;
					}
					vertex2 = _pq.ExtractMin();
					SpliceMergeVertices(vertex._anEdge, vertex2._anEdge);
				}
				SweepEvent(vertex);
			}
			DoneEdgeDict();
			DonePriorityQ();
			RemoveDegenerateFaces();
		}

		public Tess()
		{
			_normal = Vec3.Zero;
			_bminX = (_bminY = (_bmaxX = (_bmaxY = 0f)));
			_windingRule = WindingRule.EvenOdd;
			_mesh = null;
			_vertices = null;
			_vertexCount = 0;
			_elements = null;
			_elementCount = 0;
		}

		private void ComputeNormal(ref Vec3 norm)
		{
			MeshUtils.Vertex next = _mesh._vHead._next;
			float[] array = new float[3]
			{
				next._coords.X,
				next._coords.Y,
				next._coords.Z
			};
			MeshUtils.Vertex[] array2 = new MeshUtils.Vertex[3] { next, next, next };
			float[] array3 = new float[3]
			{
				next._coords.X,
				next._coords.Y,
				next._coords.Z
			};
			MeshUtils.Vertex[] array4 = new MeshUtils.Vertex[3] { next, next, next };
			while (next != _mesh._vHead)
			{
				if (next._coords.X < array[0])
				{
					array[0] = next._coords.X;
					array2[0] = next;
				}
				if (next._coords.Y < array[1])
				{
					array[1] = next._coords.Y;
					array2[1] = next;
				}
				if (next._coords.Z < array[2])
				{
					array[2] = next._coords.Z;
					array2[2] = next;
				}
				if (next._coords.X > array3[0])
				{
					array3[0] = next._coords.X;
					array4[0] = next;
				}
				if (next._coords.Y > array3[1])
				{
					array3[1] = next._coords.Y;
					array4[1] = next;
				}
				if (next._coords.Z > array3[2])
				{
					array3[2] = next._coords.Z;
					array4[2] = next;
				}
				next = next._next;
			}
			int num = 0;
			if (array3[1] - array[1] > array3[0] - array[0])
			{
				num = 1;
			}
			if (array3[2] - array[2] > array3[num] - array[num])
			{
				num = 2;
			}
			if (array[num] >= array3[num])
			{
				norm = new Vec3
				{
					X = 0f,
					Y = 0f,
					Z = 1f
				};
				return;
			}
			float num2 = 0f;
			MeshUtils.Vertex obj = array2[num];
			MeshUtils.Vertex vertex = array4[num];
			Vec3.Sub(ref obj._coords, ref vertex._coords, out var result);
			Vec3 vec = default(Vec3);
			for (next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				Vec3.Sub(ref next._coords, ref vertex._coords, out var result2);
				vec.X = result.Y * result2.Z - result.Z * result2.Y;
				vec.Y = result.Z * result2.X - result.X * result2.Z;
				vec.Z = result.X * result2.Y - result.Y * result2.X;
				float num3 = vec.X * vec.X + vec.Y * vec.Y + vec.Z * vec.Z;
				if (num3 > num2)
				{
					num2 = num3;
					norm = vec;
				}
			}
			if (num2 <= 0f)
			{
				norm = Vec3.Zero;
				num = Vec3.LongAxis(ref result);
				norm[num] = 1f;
			}
		}

		private void CheckOrientation()
		{
			float num = 0f;
			for (MeshUtils.Face next = _mesh._fHead._next; next != _mesh._fHead; next = next._next)
			{
				if (next._anEdge._winding > 0)
				{
					num += MeshUtils.FaceArea(next);
				}
			}
			if (num < 0f)
			{
				for (MeshUtils.Vertex next2 = _mesh._vHead._next; next2 != _mesh._vHead; next2 = next2._next)
				{
					next2._t = 0f - next2._t;
				}
				Vec3.Neg(ref _tUnit);
			}
		}

		private void ProjectPolygon()
		{
			Vec3 norm = _normal;
			bool flag = false;
			if (norm.X == 0f && norm.Y == 0f && norm.Z == 0f)
			{
				ComputeNormal(ref norm);
				_normal = norm;
				flag = true;
			}
			int num = Vec3.LongAxis(ref norm);
			_sUnit[num] = 0f;
			_sUnit[(num + 1) % 3] = SUnitX;
			_sUnit[(num + 2) % 3] = SUnitY;
			_tUnit[num] = 0f;
			_tUnit[(num + 1) % 3] = ((norm[num] > 0f) ? (0f - SUnitY) : SUnitY);
			_tUnit[(num + 2) % 3] = ((norm[num] > 0f) ? SUnitX : (0f - SUnitX));
			for (MeshUtils.Vertex next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				Vec3.Dot(ref next._coords, ref _sUnit, out next._s);
				Vec3.Dot(ref next._coords, ref _tUnit, out next._t);
			}
			if (flag)
			{
				CheckOrientation();
			}
			bool flag2 = true;
			for (MeshUtils.Vertex next2 = _mesh._vHead._next; next2 != _mesh._vHead; next2 = next2._next)
			{
				if (flag2)
				{
					_bminX = (_bmaxX = next2._s);
					_bminY = (_bmaxY = next2._t);
					flag2 = false;
				}
				else
				{
					if (next2._s < _bminX)
					{
						_bminX = next2._s;
					}
					if (next2._s > _bmaxX)
					{
						_bmaxX = next2._s;
					}
					if (next2._t < _bminY)
					{
						_bminY = next2._t;
					}
					if (next2._t > _bmaxY)
					{
						_bmaxY = next2._t;
					}
				}
			}
		}

		private void TessellateMonoRegion(MeshUtils.Face face)
		{
			MeshUtils.Edge edge = face._anEdge;
			while (Geom.VertLeq(edge._Dst, edge._Org))
			{
				edge = edge._Lprev;
			}
			while (Geom.VertLeq(edge._Org, edge._Dst))
			{
				edge = edge._Lnext;
			}
			MeshUtils.Edge edge2 = edge._Lprev;
			while (edge._Lnext != edge2)
			{
				if (Geom.VertLeq(edge._Dst, edge2._Org))
				{
					while (edge2._Lnext != edge && (Geom.EdgeGoesLeft(edge2._Lnext) || Geom.EdgeSign(edge2._Org, edge2._Dst, edge2._Lnext._Dst) <= 0f))
					{
						edge2 = _mesh.Connect(edge2._Lnext, edge2)._Sym;
					}
					edge2 = edge2._Lprev;
				}
				else
				{
					while (edge2._Lnext != edge && (Geom.EdgeGoesRight(edge._Lprev) || Geom.EdgeSign(edge._Dst, edge._Org, edge._Lprev._Org) >= 0f))
					{
						edge = _mesh.Connect(edge, edge._Lprev)._Sym;
					}
					edge = edge._Lnext;
				}
			}
			while (edge2._Lnext._Lnext != edge)
			{
				edge2 = _mesh.Connect(edge2._Lnext, edge2)._Sym;
			}
		}

		private void TessellateInterior()
		{
			MeshUtils.Face face = _mesh._fHead._next;
			while (face != _mesh._fHead)
			{
				MeshUtils.Face next = face._next;
				if (face._inside)
				{
					TessellateMonoRegion(face);
				}
				face = next;
			}
		}

		private void DiscardExterior()
		{
			MeshUtils.Face face = _mesh._fHead._next;
			while (face != _mesh._fHead)
			{
				MeshUtils.Face next = face._next;
				if (!face._inside)
				{
					_mesh.ZapFace(face);
				}
				face = next;
			}
		}

		private void SetWindingNumber(int value, bool keepOnlyBoundary)
		{
			MeshUtils.Edge edge = _mesh._eHead._next;
			while (edge != _mesh._eHead)
			{
				MeshUtils.Edge next = edge._next;
				if (edge._Rface._inside != edge._Lface._inside)
				{
					edge._winding = (edge._Lface._inside ? value : (-value));
				}
				else if (!keepOnlyBoundary)
				{
					edge._winding = 0;
				}
				else
				{
					_mesh.Delete(edge);
				}
				edge = next;
			}
		}

		private int GetNeighbourFace(MeshUtils.Edge edge)
		{
			if (edge._Rface == null)
			{
				return -1;
			}
			if (!edge._Rface._inside)
			{
				return -1;
			}
			return edge._Rface._n;
		}

		private void OutputPolymesh(ElementType elementType, int polySize)
		{
			int num = 0;
			int num2 = 0;
			if (polySize < 3)
			{
				polySize = 3;
			}
			if (polySize > 3)
			{
				_mesh.MergeConvexFaces(polySize);
			}
			for (MeshUtils.Vertex next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				next._n = -1;
			}
			for (MeshUtils.Face next2 = _mesh._fHead._next; next2 != _mesh._fHead; next2 = next2._next)
			{
				next2._n = -1;
				if (next2._inside && (!NoEmptyPolygons || !(Math.Abs(MeshUtils.FaceArea(next2)) < float.Epsilon)))
				{
					MeshUtils.Edge edge = next2._anEdge;
					int num3 = 0;
					do
					{
						MeshUtils.Vertex next = edge._Org;
						if (next._n == -1)
						{
							next._n = num2;
							num2++;
						}
						num3++;
						edge = edge._Lnext;
					}
					while (edge != next2._anEdge);
					next2._n = num;
					num++;
				}
			}
			_elementCount = num;
			if (elementType == ElementType.ConnectedPolygons)
			{
				num *= 2;
			}
			_elements = new int[num * polySize];
			_vertexCount = num2;
			_vertices = new ContourVertex[_vertexCount];
			for (MeshUtils.Vertex next = _mesh._vHead._next; next != _mesh._vHead; next = next._next)
			{
				if (next._n != -1)
				{
					_vertices[next._n].Position = next._coords;
					_vertices[next._n].Data = next._data;
				}
			}
			int num4 = 0;
			for (MeshUtils.Face next2 = _mesh._fHead._next; next2 != _mesh._fHead; next2 = next2._next)
			{
				if (next2._inside && (!NoEmptyPolygons || !(Math.Abs(MeshUtils.FaceArea(next2)) < float.Epsilon)))
				{
					MeshUtils.Edge edge = next2._anEdge;
					int num3 = 0;
					do
					{
						MeshUtils.Vertex next = edge._Org;
						_elements[num4++] = next._n;
						num3++;
						edge = edge._Lnext;
					}
					while (edge != next2._anEdge);
					for (int i = num3; i < polySize; i++)
					{
						_elements[num4++] = -1;
					}
					if (elementType == ElementType.ConnectedPolygons)
					{
						edge = next2._anEdge;
						do
						{
							_elements[num4++] = GetNeighbourFace(edge);
							edge = edge._Lnext;
						}
						while (edge != next2._anEdge);
						for (int i = num3; i < polySize; i++)
						{
							_elements[num4++] = -1;
						}
					}
				}
			}
		}

		private void OutputContours()
		{
			int num = 0;
			int num2 = 0;
			_vertexCount = 0;
			_elementCount = 0;
			for (MeshUtils.Face next = _mesh._fHead._next; next != _mesh._fHead; next = next._next)
			{
				if (next._inside)
				{
					MeshUtils.Edge edge;
					MeshUtils.Edge edge2 = (edge = next._anEdge);
					do
					{
						_vertexCount++;
						edge = edge._Lnext;
					}
					while (edge != edge2);
					_elementCount++;
				}
			}
			_elements = new int[_elementCount * 2];
			_vertices = new ContourVertex[_vertexCount];
			int num3 = 0;
			int num4 = 0;
			num = 0;
			for (MeshUtils.Face next = _mesh._fHead._next; next != _mesh._fHead; next = next._next)
			{
				if (next._inside)
				{
					num2 = 0;
					MeshUtils.Edge edge;
					MeshUtils.Edge edge2 = (edge = next._anEdge);
					do
					{
						_vertices[num3].Position = edge._Org._coords;
						_vertices[num3].Data = edge._Org._data;
						num3++;
						num2++;
						edge = edge._Lnext;
					}
					while (edge != edge2);
					_elements[num4++] = num;
					_elements[num4++] = num2;
					num += num2;
				}
			}
		}

		private float SignedArea(ContourVertex[] vertices)
		{
			float num = 0f;
			for (int i = 0; i < vertices.Length; i++)
			{
				ContourVertex contourVertex = vertices[i];
				ContourVertex contourVertex2 = vertices[(i + 1) % vertices.Length];
				num += contourVertex.Position.X * contourVertex2.Position.Y;
				num -= contourVertex.Position.Y * contourVertex2.Position.X;
			}
			return 0.5f * num;
		}

		public void AddContour(ContourVertex[] vertices)
		{
			AddContour(vertices, ContourOrientation.Original);
		}

		public void AddContour(ContourVertex[] vertices, ContourOrientation forceOrientation)
		{
			if (_mesh == null)
			{
				_mesh = new LTMesh();
			}
			bool flag = false;
			if (forceOrientation != 0)
			{
				float num = SignedArea(vertices);
				flag = (forceOrientation == ContourOrientation.Clockwise && num < 0f) || (forceOrientation == ContourOrientation.CounterClockwise && num > 0f);
			}
			MeshUtils.Edge edge = null;
			for (int i = 0; i < vertices.Length; i++)
			{
				if (edge == null)
				{
					edge = _mesh.MakeEdge();
					_mesh.Splice(edge, edge._Sym);
				}
				else
				{
					_mesh.SplitEdge(edge);
					edge = edge._Lnext;
				}
				int num2 = (flag ? (vertices.Length - 1 - i) : i);
				edge._Org._coords = vertices[num2].Position;
				edge._Org._data = vertices[num2].Data;
				edge._winding = 1;
				edge._Sym._winding = -1;
			}
		}

		public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize)
		{
			Tessellate(windingRule, elementType, polySize, null);
		}

		public void Tessellate(WindingRule windingRule, ElementType elementType, int polySize, CombineCallback combineCallback)
		{
			_normal = Vec3.Zero;
			_vertices = null;
			_elements = null;
			_windingRule = windingRule;
			_combineCallback = combineCallback;
			if (_mesh != null)
			{
				ProjectPolygon();
				ComputeInterior();
				if (elementType == ElementType.BoundaryContours)
				{
					SetWindingNumber(1, keepOnlyBoundary: true);
				}
				else
				{
					TessellateInterior();
				}
				if (elementType == ElementType.BoundaryContours)
				{
					OutputContours();
				}
				else
				{
					OutputPolymesh(elementType, polySize);
				}
				if (UsePooling)
				{
					_mesh.Free();
				}
				_mesh = null;
			}
		}
	}
	public enum WindingRule
	{
		EvenOdd,
		NonZero,
		Positive,
		Negative,
		AbsGeqTwo
	}
	public enum ElementType
	{
		Polygons,
		ConnectedPolygons,
		BoundaryContours
	}
	public enum ContourOrientation
	{
		Original,
		Clockwise,
		CounterClockwise
	}
	public struct ContourVertex
	{
		public Vec3 Position;

		public object Data;

		public override string ToString()
		{
			return $"{Position}, {Data}";
		}
	}
	public delegate object CombineCallback(Vec3 position, object[] data, float[] weights);
	public static class LibTessVector3Extension
	{
		public static Vec3 Vec3(this Vector3 v)
		{
			Vec3 result = default(Vec3);
			result.X = v.x;
			result.Y = v.y;
			result.Z = v.z;
			return result;
		}

		public static ContourVertex ContourVertex(this Vector3 v)
		{
			ContourVertex result = default(ContourVertex);
			result.Position = v.Vec3();
			return result;
		}
	}
	public static class LibTessV3Extension
	{
		public static Vector3 Vector3(this Vec3 v)
		{
			return new Vector3(v.X, v.Y, v.Z);
		}
	}
	public static class UnityLibTessUtility
	{
		public static ContourVertex[] ToContourVertex(Vector3[] v, bool zeroZ = false)
		{
			ContourVertex[] array = new ContourVertex[v.Length];
			for (int i = 0; i < v.Length; i++)
			{
				array[i].Position.X = v[i].x;
				array[i].Position.Y = v[i].y;
				array[i].Position.Z = (zeroZ ? 0f : v[i].z);
			}
			return array;
		}

		public static Vector3[] FromContourVertex(ContourVertex[] v)
		{
			Vector3[] v3Array = new Vector3[v.Length];
			SetFromContourVertex(ref v3Array, ref v);
			return v3Array;
		}

		public static void SetFromContourVertex(ref Vector3[] v3Array, ref ContourVertex[] cvArray)
		{
			Array.Resize(ref v3Array, cvArray.Length);
			for (int i = 0; i < v3Array.Length; i++)
			{
				v3Array[i].x = cvArray[i].Position.X;
				v3Array[i].y = cvArray[i].Position.Y;
				v3Array[i].z = cvArray[i].Position.Z;
			}
		}

		public static void SetToContourVertex(ref ContourVertex[] cvArray, ref Vector3[] v3Array)
		{
			Array.Resize(ref cvArray, v3Array.Length);
			for (int i = 0; i < cvArray.Length; i++)
			{
				cvArray[i].Position.X = v3Array[i].x;
				cvArray[i].Position.Y = v3Array[i].y;
				cvArray[i].Position.Z = v3Array[i].z;
			}
		}
	}
}
namespace FluffyUnderware.Curvy.ImportExport
{
	public enum CurvySerializationSpace
	{
		Global,
		Local
	}
	[Serializable]
	public class SerializedCurvySpline
	{
		public string Name;

		public Vector3 Position;

		public Vector3 Rotation;

		public CurvyInterpolation Interpolation;

		public bool RestrictTo2D;

		public bool Closed;

		public bool AutoEndTangents;

		public CurvyOrientation Orientation;

		public float AutoHandleDistance;

		public int CacheDensity;

		public float MaxPointsPerUnit;

		public bool UsePooling;

		public bool UseThreading;

		public bool CheckTransform;

		public CurvyUpdateMethod UpdateIn;

		public SerializedCurvySplineSegment[] ControlPoints;

		public SerializedCurvySpline()
		{
			Interpolation = CurvyGlobalManager.DefaultInterpolation;
			AutoEndTangents = true;
			Orientation = CurvyOrientation.Dynamic;
			AutoHandleDistance = 0.39f;
			CacheDensity = 50;
			MaxPointsPerUnit = 8f;
			UsePooling = true;
			CheckTransform = true;
			UpdateIn = CurvyUpdateMethod.Update;
			ControlPoints = new SerializedCurvySplineSegment[0];
		}

		public SerializedCurvySpline([NotNull] CurvySpline spline, CurvySerializationSpace space)
		{
			Name = spline.name;
			Position = ((space == CurvySerializationSpace.Local) ? spline.transform.localPosition : spline.transform.position);
			Rotation = ((space == CurvySerializationSpace.Local) ? spline.transform.localRotation.eulerAngles : spline.transform.rotation.eulerAngles);
			Interpolation = spline.Interpolation;
			RestrictTo2D = spline.RestrictTo2D;
			Closed = spline.Closed;
			AutoEndTangents = spline.AutoEndTangents;
			Orientation = spline.Orientation;
			AutoHandleDistance = spline.AutoHandleDistance;
			CacheDensity = spline.CacheDensity;
			MaxPointsPerUnit = spline.MaxPointsPerUnit;
			UsePooling = spline.UsePooling;
			UseThreading = spline.UseThreading;
			CheckTransform = spline.CheckTransform;
			UpdateIn = spline.UpdateIn;
			ControlPoints = new SerializedCurvySplineSegment[spline.ControlPointCount];
			for (int i = 0; i < spline.ControlPointCount; i++)
			{
				ControlPoints[i] = new SerializedCurvySplineSegment(spline.ControlPointsList[i], space);
			}
		}

		public void WriteIntoSpline([NotNull] CurvySpline deserializedSpline, CurvySerializationSpace space)
		{
			deserializedSpline.name = Name;
			if (space == CurvySerializationSpace.Local)
			{
				deserializedSpline.transform.localPosition = Position;
				deserializedSpline.transform.localRotation = Quaternion.Euler(Rotation);
			}
			else
			{
				deserializedSpline.transform.position = Position;
				deserializedSpline.transform.rotation = Quaternion.Euler(Rotation);
			}
			deserializedSpline.Interpolation = Interpolation;
			deserializedSpline.RestrictTo2D = RestrictTo2D;
			deserializedSpline.Closed = Closed;
			deserializedSpline.AutoEndTangents = AutoEndTangents;
			deserializedSpline.Orientation = Orientation;
			deserializedSpline.AutoHandleDistance = AutoHandleDistance;
			deserializedSpline.CacheDensity = CacheDensity;
			deserializedSpline.MaxPointsPerUnit = MaxPointsPerUnit;
			deserializedSpline.UsePooling = UsePooling;
			deserializedSpline.UseThreading = UseThreading;
			deserializedSpline.CheckTransform = CheckTransform;
			deserializedSpline.UpdateIn = UpdateIn;
			SerializedCurvySplineSegment[] controlPoints = ControlPoints;
			for (int i = 0; i < controlPoints.Length; i++)
			{
				controlPoints[i].WriteIntoControlPoint(deserializedSpline.InsertAfter(null, skipRefreshingAndEvents: true), space);
			}
			deserializedSpline.SetDirtyAll();
		}
	}
	[Serializable]
	public class SerializedCurvySplineSegment
	{
		public Vector3 Position;

		public Vector3 Rotation;

		public bool AutoBakeOrientation;

		public bool OrientationAnchor;

		public CurvyOrientationSwirl Swirl;

		public float SwirlTurns;

		public bool AutoHandles;

		public float AutoHandleDistance;

		public Vector3 HandleOut;

		public Vector3 HandleIn;

		public SerializedCurvySplineSegment()
		{
			Swirl = CurvyOrientationSwirl.None;
			AutoHandles = true;
			AutoHandleDistance = 0.39f;
			HandleOut = CurvySplineSegmentDefaultValues.HandleOut;
			HandleIn = CurvySplineSegmentDefaultValues.HandleIn;
		}

		public SerializedCurvySplineSegment([NotNull] CurvySplineSegment segment, CurvySerializationSpace space)
		{
			Position = ((space == CurvySerializationSpace.Global) ? segment.transform.position : segment.transform.localPosition);
			Rotation = ((space == CurvySerializationSpace.Global) ? segment.transform.rotation.eulerAngles : segment.transform.localRotation.eulerAngles);
			AutoBakeOrientation = segment.AutoBakeOrientation;
			OrientationAnchor = segment.SerializedOrientationAnchor;
			Swirl = segment.Swirl;
			SwirlTurns = segment.SwirlTurns;
			AutoHandles = segment.AutoHandles;
			AutoHandleDistance = segment.AutoHandleDistance;
			HandleOut = segment.HandleOut;
			HandleIn = segment.HandleIn;
		}

		public void WriteIntoControlPoint([NotNull] CurvySplineSegment controlPoint, CurvySerializationSpace space)
		{
			if (space == CurvySerializationSpace.Global)
			{
				controlPoint.transform.position = Position;
				controlPoint.transform.rotation = Quaternion.Euler(Rotation);
			}
			else
			{
				controlPoint.transform.localPosition = Position;
				controlPoint.transform.localRotation = Quaternion.Euler(Rotation);
			}
			controlPoint.AutoBakeOrientation = AutoBakeOrientation;
			controlPoint.SerializedOrientationAnchor = OrientationAnchor;
			controlPoint.Swirl = Swirl;
			controlPoint.SwirlTurns = SwirlTurns;
			controlPoint.AutoHandles = AutoHandles;
			controlPoint.AutoHandleDistance = AutoHandleDistance;
			controlPoint.SetBezierHandleIn(HandleIn);
			controlPoint.SetBezierHandleOut(HandleOut);
		}
	}
}
namespace FluffyUnderware.Curvy.Controllers
{
	public abstract class ConnectedControlPointsSelector : MonoBehaviour
	{
		public abstract CurvySplineSegment SelectConnectedControlPoint(SplineController caller, CurvyConnection connection, CurvySplineSegment currentControlPoint);
	}
	[Serializable]
	public class ControllerEvent : UnityEventEx<CurvyController>
	{
	}
	[Obsolete]
	public class CurvyControllerEventArgs : CurvyEventArgs
	{
		public readonly CurvyController Controller;

		public CurvyControllerEventArgs(MonoBehaviour sender, CurvyController controller)
			: base(sender, null)
		{
			Controller = controller;
		}
	}
	[Serializable]
	public class CurvySplineMoveEvent : UnityEventEx<CurvySplineMoveEventArgs>
	{
	}
	public class CurvySplineMoveEventArgs : CancelEventArgs
	{
		public SplineController Sender { get; private set; }

		public CurvySpline Spline { get; private set; }

		public CurvySplineSegment ControlPoint { get; private set; }

		public bool WorldUnits { get; private set; }

		public MovementDirection MovementDirection { get; private set; }

		public float Delta { get; private set; }

		public float Position { get; private set; }

		public CurvySplineMoveEventArgs(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, bool usingWorldUnits, float delta, MovementDirection direction)
		{
			Set_INTERNAL(sender, spline, controlPoint, position, delta, direction, usingWorldUnits);
		}

		internal void Set_INTERNAL(SplineController sender, CurvySpline spline, CurvySplineSegment controlPoint, float position, float delta, MovementDirection direction, bool usingWorldUnits)
		{
			Sender = sender;
			Spline = spline;
			ControlPoint = controlPoint;
			MovementDirection = direction;
			Delta = delta;
			Position = position;
			WorldUnits = usingWorldUnits;
			base.Cancel = false;
		}
	}
	[ExecuteInEditMode]
	public abstract class CurvyController : DTVersionedMonoBehaviour, ISerializationCallbackReceiver
	{
		public enum MoveModeEnum
		{
			Relative,
			AbsolutePrecise
		}

		public enum CurvyControllerState
		{
			Stopped,
			Playing,
			Paused
		}

		[Section("General", true, false, 100, Sort = 0, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_general")]
		[Label(Tooltip = "Determines when to update")]
		public CurvyUpdateMethod UpdateIn;

		[Section("Position", true, false, 100, Sort = 100, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_position")]
		[SerializeField]
		private CurvyPositionMode m_PositionMode;

		[RangeEx(0f, "maxPosition", "", "")]
		[SerializeField]
		[FormerlySerializedAs("m_InitialPosition")]
		protected float m_Position;

		[Section("Move", true, false, 100, Sort = 200, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_move")]
		[SerializeField]
		private MoveModeEnum m_MoveMode = MoveModeEnum.AbsolutePrecise;

		[Positive]
		[SerializeField]
		private float m_Speed;

		[SerializeField]
		private MovementDirection m_Direction;

		[SerializeField]
		private CurvyClamping m_Clamping = CurvyClamping.Loop;

		[SerializeField]
		[Tooltip("Start playing automatically when entering play mode")]
		private bool m_PlayAutomatically = true;

		[Section("Orientation", true, false, 100, Sort = 300, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_orientation")]
		[Label("Source", "Source Vector")]
		[FieldCondition("ShowOrientationSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private OrientationModeEnum m_OrientationMode = OrientationModeEnum.Orientation;

		[Label("Lock Rotation", "When set, the controller will enforce the rotation to not change")]
		[SerializeField]
		private bool m_LockRotation = true;

		[Label("Target", "Target Vector3")]
		[FieldCondition("m_OrientationMode", OrientationModeEnum.None, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private OrientationAxisEnum m_OrientationAxis;

		[Tooltip("Should the orientation ignore the movement direction?")]
		[FieldCondition("m_OrientationMode", OrientationModeEnum.None, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.OR, "ShowOrientationSection", false, false, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private bool m_IgnoreDirection;

		[FluffyUnderware.DevTools.Min(0f, "Direction Damping Time", "If non zero, the direction vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
		[FieldCondition("ShowOrientationSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private float m_DampingDirection;

		[FluffyUnderware.DevTools.Min(0f, "Up Damping Time", "If non zero, the up vector will not be updated instantly, but using a damping effect that will last the specified amount of time.")]
		[FieldCondition("ShowOrientationSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private float m_DampingUp;

		[Section("Offset", true, false, 100, Sort = 400, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_orientation")]
		[FieldCondition("ShowOffsetSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[RangeEx(-180f, 180f, "", "")]
		[SerializeField]
		private float m_OffsetAngle;

		[FieldCondition("ShowOffsetSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[SerializeField]
		private float m_OffsetRadius;

		[FieldCondition("ShowOffsetSection", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Hide)]
		[Label("Compensate Offset", "")]
		[SerializeField]
		private bool m_OffsetCompensation = true;

		[Section("Events", true, false, 100, Sort = 500)]
		[SerializeField]
		protected ControllerEvent onInitialized = new ControllerEvent();

		protected const string ControllerNotReadyMessage = "The controller is not yet ready";

		protected CurvyControllerState State;

		protected Vector3 DirectionDampingVelocity;

		protected Vector3 UpDampingVelocity;

		protected float PrePlayPosition;

		protected MovementDirection PrePlayDirection;

		protected Quaternion LockedRotation;

		public ControllerEvent OnInitialized => onInitialized;

		public CurvyPositionMode PositionMode
		{
			get
			{
				return m_PositionMode;
			}
			set
			{
				m_PositionMode = value;
			}
		}

		public MoveModeEnum MoveMode
		{
			get
			{
				return m_MoveMode;
			}
			set
			{
				if (m_MoveMode != value)
				{
					m_MoveMode = value;
				}
			}
		}

		public bool PlayAutomatically
		{
			get
			{
				return m_PlayAutomatically;
			}
			set
			{
				if (m_PlayAutomatically != value)
				{
					m_PlayAutomatically = value;
				}
			}
		}

		public CurvyClamping Clamping
		{
			get
			{
				return m_Clamping;
			}
			set
			{
				if (m_Clamping != value)
				{
					m_Clamping = value;
				}
			}
		}

		public OrientationModeEnum OrientationMode
		{
			get
			{
				return m_OrientationMode;
			}
			set
			{
				if (m_OrientationMode != value)
				{
					m_OrientationMode = value;
				}
			}
		}

		public bool LockRotation
		{
			get
			{
				return m_LockRotation;
			}
			set
			{
				if (m_LockRotation != value)
				{
					m_LockRotation = value;
				}
				if (m_LockRotation)
				{
					LockedRotation = Transform.rotation;
				}
			}
		}

		public OrientationAxisEnum OrientationAxis
		{
			get
			{
				return m_OrientationAxis;
			}
			set
			{
				if (m_OrientationAxis != value)
				{
					m_OrientationAxis = value;
				}
			}
		}

		public float DirectionDampingTime
		{
			get
			{
				return m_DampingDirection;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_DampingDirection != num)
				{
					m_DampingDirection = num;
				}
			}
		}

		public float UpDampingTime
		{
			get
			{
				return m_DampingUp;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_DampingUp != num)
				{
					m_DampingUp = num;
				}
			}
		}

		public bool IgnoreDirection
		{
			get
			{
				return m_IgnoreDirection;
			}
			set
			{
				if (m_IgnoreDirection != value)
				{
					m_IgnoreDirection = value;
				}
			}
		}

		public float OffsetAngle
		{
			get
			{
				return m_OffsetAngle;
			}
			set
			{
				if (m_OffsetAngle != value)
				{
					m_OffsetAngle = value;
				}
			}
		}

		public float OffsetRadius
		{
			get
			{
				return m_OffsetRadius;
			}
			set
			{
				if (m_OffsetRadius != value)
				{
					m_OffsetRadius = value;
				}
			}
		}

		public bool OffsetCompensation
		{
			get
			{
				return m_OffsetCompensation;
			}
			set
			{
				m_OffsetCompensation = value;
			}
		}

		public float Speed
		{
			get
			{
				return m_Speed;
			}
			set
			{
				if (value < 0f)
				{
					value = 0f - value;
				}
				m_Speed = value;
			}
		}

		public float RelativePosition
		{
			get
			{
				return PositionMode switch
				{
					CurvyPositionMode.Relative => GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length), 
					CurvyPositionMode.WorldUnits => AbsoluteToRelative(GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length)), 
					_ => throw new NotSupportedException(), 
				};
			}
			set
			{
				float clampedPosition = GetClampedPosition(value, CurvyPositionMode.Relative, Clamping, Length);
				switch (PositionMode)
				{
				case CurvyPositionMode.Relative:
					m_Position = clampedPosition;
					break;
				case CurvyPositionMode.WorldUnits:
					m_Position = RelativeToAbsolute(clampedPosition);
					break;
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
		}

		public float AbsolutePosition
		{
			get
			{
				return PositionMode switch
				{
					CurvyPositionMode.Relative => RelativeToAbsolute(GetClampedPosition(m_Position, CurvyPositionMode.Relative, Clamping, Length)), 
					CurvyPositionMode.WorldUnits => GetClampedPosition(m_Position, CurvyPositionMode.WorldUnits, Clamping, Length), 
					_ => throw new NotSupportedException(), 
				};
			}
			set
			{
				float clampedPosition = GetClampedPosition(value, CurvyPositionMode.WorldUnits, Clamping, Length);
				switch (PositionMode)
				{
				case CurvyPositionMode.Relative:
					m_Position = AbsoluteToRelative(clampedPosition);
					break;
				case CurvyPositionMode.WorldUnits:
					m_Position = clampedPosition;
					break;
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
		}

		public float Position
		{
			get
			{
				return PositionMode switch
				{
					CurvyPositionMode.Relative => RelativePosition, 
					CurvyPositionMode.WorldUnits => AbsolutePosition, 
					_ => throw new NotSupportedException(), 
				};
			}
			set
			{
				switch (PositionMode)
				{
				case CurvyPositionMode.Relative:
					RelativePosition = value;
					break;
				case CurvyPositionMode.WorldUnits:
					AbsolutePosition = value;
					break;
				default:
					throw new NotSupportedException();
				}
			}
		}

		public MovementDirection MovementDirection
		{
			get
			{
				return m_Direction;
			}
			set
			{
				m_Direction = value;
			}
		}

		public CurvyControllerState PlayState => State;

		public abstract bool IsReady { get; }

		public virtual Transform Transform => base.transform;

		protected virtual bool ShowOrientationSection => true;

		protected virtual bool ShowOffsetSection => OrientationMode != OrientationModeEnum.None;

		public abstract float Length { get; }

		protected bool isInitialized { get; private set; }

		protected float TimeSinceLastUpdate => Time.deltaTime;

		protected bool UseOffset => ShowOffsetSection;

		private float maxPosition => PositionMode switch
		{
			CurvyPositionMode.Relative => 1f, 
			CurvyPositionMode.WorldUnits => IsReady ? Length : 0f, 
			_ => throw new NotSupportedException(), 
		};

		protected virtual void OnEnable()
		{
			if (!isInitialized && IsReady)
			{
				Initialize();
				InitializedApplyDeltaTime(0f);
			}
		}

		protected virtual void Start()
		{
			if (!isInitialized && IsReady)
			{
				Initialize();
				InitializedApplyDeltaTime(0f);
			}
			if (PlayAutomatically && Application.isPlaying)
			{
				Play();
			}
		}

		protected virtual void OnDisable()
		{
			if (isInitialized)
			{
				Deinitialize();
			}
		}

		protected virtual void Update()
		{
			if (UpdateIn == CurvyUpdateMethod.Update)
			{
				ApplyDeltaTime(TimeSinceLastUpdate);
			}
		}

		protected virtual void LateUpdate()
		{
			if (UpdateIn == CurvyUpdateMethod.LateUpdate || (!Application.isPlaying && UpdateIn == CurvyUpdateMethod.FixedUpdate))
			{
				ApplyDeltaTime(TimeSinceLastUpdate);
			}
		}

		protected virtual void FixedUpdate()
		{
			if (UpdateIn == CurvyUpdateMethod.FixedUpdate)
			{
				ApplyDeltaTime(TimeSinceLastUpdate);
			}
		}

		protected virtual void Reset()
		{
			UpdateIn = CurvyUpdateMethod.Update;
			PositionMode = CurvyPositionMode.Relative;
			m_Position = 0f;
			PlayAutomatically = true;
			MoveMode = MoveModeEnum.AbsolutePrecise;
			Speed = 0f;
			LockRotation = true;
			Clamping = CurvyClamping.Loop;
			OrientationMode = OrientationModeEnum.Orientation;
			OrientationAxis = OrientationAxisEnum.Up;
			IgnoreDirection = false;
		}

		protected virtual void InitializedApplyDeltaTime(float deltaTime)
		{
			if (State == CurvyControllerState.Playing && Speed * deltaTime != 0f)
			{
				float num = ((UseOffset && OffsetCompensation && OffsetRadius != 0f) ? ComputeOffsetCompensatedSpeed(deltaTime) : Speed);
				if (num * deltaTime != 0f)
				{
					Advance(num, deltaTime);
				}
			}
			Transform transform = Transform;
			Vector3 position = transform.position;
			Quaternion rotation = transform.rotation;
			ComputeTargetPositionAndRotation(out var targetPosition, out var targetUp, out var targetForward);
			Vector3 forward = ((!(DirectionDampingTime > 0f) || State != CurvyControllerState.Playing) ? targetForward : ((deltaTime > 0f) ? Vector3.SmoothDamp(transform.forward, targetForward, ref DirectionDampingVelocity, DirectionDampingTime, float.PositiveInfinity, deltaTime) : transform.forward));
			Vector3 upwards = ((!(UpDampingTime > 0f) || State != CurvyControllerState.Playing) ? targetUp : ((deltaTime > 0f) ? Vector3.SmoothDamp(transform.up, targetUp, ref UpDampingVelocity, UpDampingTime, float.PositiveInfinity, deltaTime) : transform.up));
			transform.rotation = Quaternion.LookRotation(forward, upwards);
			transform.position = targetPosition;
			if (position.NotApproximately(transform.position) || rotation.DifferentOrientation(transform.rotation))
			{
				UserAfterUpdate();
			}
		}

		protected virtual void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
		{
			GetInterpolatedSourcePosition(RelativePosition, out var interpolatedPosition, out var tangent, out var up);
			if (tangent == Vector3.zero || up == Vector3.zero)
			{
				GetOrientationNoneUpAndForward(out targetUp, out targetForward);
			}
			else
			{
				switch (OrientationMode)
				{
				case OrientationModeEnum.None:
					GetOrientationNoneUpAndForward(out targetUp, out targetForward);
					break;
				case OrientationModeEnum.Orientation:
				{
					Vector3 vector2 = ((m_Direction == MovementDirection.Backward && !IgnoreDirection) ? (-tangent) : tangent);
					switch (OrientationAxis)
					{
					case OrientationAxisEnum.Up:
						targetUp = up;
						targetForward = vector2;
						break;
					case OrientationAxisEnum.Down:
						targetUp = -up;
						targetForward = vector2;
						break;
					case OrientationAxisEnum.Forward:
						targetUp = -vector2;
						targetForward = up;
						break;
					case OrientationAxisEnum.Backward:
						targetUp = vector2;
						targetForward = -up;
						break;
					case OrientationAxisEnum.Left:
						targetUp = Vector3.Cross(up, vector2);
						targetForward = vector2;
						break;
					case OrientationAxisEnum.Right:
						targetUp = Vector3.Cross(vector2, up);
						targetForward = vector2;
						break;
					default:
						throw new NotSupportedException();
					}
					break;
				}
				case OrientationModeEnum.Tangent:
				{
					Vector3 vector = ((m_Direction == MovementDirection.Backward && !IgnoreDirection) ? (-tangent) : tangent);
					switch (OrientationAxis)
					{
					case OrientationAxisEnum.Up:
						targetUp = vector;
						targetForward = -up;
						break;
					case OrientationAxisEnum.Down:
						targetUp = -vector;
						targetForward = up;
						break;
					case OrientationAxisEnum.Forward:
						targetUp = up;
						targetForward = vector;
						break;
					case OrientationAxisEnum.Backward:
						targetUp = up;
						targetForward = -vector;
						break;
					case OrientationAxisEnum.Left:
						targetUp = up;
						targetForward = Vector3.Cross(up, vector);
						break;
					case OrientationAxisEnum.Right:
						targetUp = up;
						targetForward = Vector3.Cross(vector, up);
						break;
					default:
						throw new NotSupportedException();
					}
					break;
				}
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
			targetPosition = ((UseOffset && OffsetRadius != 0f) ? ApplyOffset(interpolatedPosition, tangent, up, OffsetAngle, OffsetRadius) : interpolatedPosition);
		}

		protected virtual void Initialize()
		{
			isInitialized = true;
			LockedRotation = Transform.rotation;
			DirectionDampingVelocity = (UpDampingVelocity = Vector3.zero);
			BindEvents();
			UserAfterInit();
			onInitialized.Invoke(this);
		}

		protected virtual void Deinitialize()
		{
			UnbindEvents();
			isInitialized = false;
		}

		protected virtual void BindEvents()
		{
		}

		protected virtual void UnbindEvents()
		{
		}

		protected virtual void SavePrePlayState()
		{
			PrePlayPosition = m_Position;
			PrePlayDirection = m_Direction;
		}

		protected virtual void RestorePrePlayState()
		{
			m_Position = PrePlayPosition;
			m_Direction = PrePlayDirection;
		}

		protected virtual void UserAfterInit()
		{
		}

		protected virtual void UserAfterUpdate()
		{
		}

		protected abstract void Advance(float speed, float deltaTime);

		protected abstract void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime);

		protected abstract float AbsoluteToRelative(float worldUnitDistance);

		protected abstract float RelativeToAbsolute(float relativeDistance);

		protected abstract Vector3 GetInterpolatedSourcePosition(float tf);

		protected abstract void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up);

		protected abstract Vector3 GetOrientation(float tf);

		protected abstract Vector3 GetTangent(float tf);

		public void Play()
		{
			if (PlayState == CurvyControllerState.Stopped)
			{
				SavePrePlayState();
			}
			State = CurvyControllerState.Playing;
		}

		public void Stop()
		{
			if (PlayState != 0)
			{
				RestorePrePlayState();
			}
			State = CurvyControllerState.Stopped;
		}

		public void Pause()
		{
			if (PlayState == CurvyControllerState.Playing)
			{
				State = CurvyControllerState.Paused;
			}
		}

		public void Refresh()
		{
			ApplyDeltaTime(0f);
		}

		public void ApplyDeltaTime(float deltaTime)
		{
			if (!isInitialized && IsReady)
			{
				Initialize();
			}
			else if (isInitialized && !IsReady)
			{
				Deinitialize();
			}
			if (isInitialized)
			{
				InitializedApplyDeltaTime(deltaTime);
			}
		}

		public void TeleportTo(float newPosition)
		{
			float distance = Mathf.Abs(Position - newPosition);
			MovementDirection direction = ((!(Position < newPosition)) ? MovementDirection.Backward : MovementDirection.Forward);
			TeleportBy(distance, direction);
		}

		public void TeleportBy(float distance, MovementDirection direction)
		{
			if (PlayState != CurvyControllerState.Playing)
			{
				DTLog.LogError("[Curvy] Calling TeleportBy on a controller that is stopped. Please make the controller play first");
			}
			float speed = Speed;
			MovementDirection movementDirection = MovementDirection;
			Speed = Mathf.Abs(distance) * 1000f;
			MovementDirection = direction;
			ApplyDeltaTime(0.001f);
			Speed = speed;
			MovementDirection = movementDirection;
		}

		public void SetFromString(string fieldAndValue)
		{
			string[] array = fieldAndValue.Split('=');
			if (array.Length != 2)
			{
				return;
			}
			FieldInfo fieldInfo = GetType().FieldByName(array[0], includeInherited: true);
			if (fieldInfo != null)
			{
				try
				{
					if (fieldInfo.FieldType.IsEnum)
					{
						fieldInfo.SetValue(this, Enum.Parse(fieldInfo.FieldType, array[1]));
					}
					else
					{
						fieldInfo.SetValue(this, Convert.ChangeType(array[1], fieldInfo.FieldType, CultureInfo.InvariantCulture));
					}
					return;
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogWarning(base.name + ".SetFromString(): " + ex.ToString());
					return;
				}
			}
			PropertyInfo propertyInfo = GetType().PropertyByName(array[0], includeInherited: true);
			if (!(propertyInfo != null))
			{
				return;
			}
			try
			{
				if (propertyInfo.PropertyType.IsEnum)
				{
					propertyInfo.SetValue(this, Enum.Parse(propertyInfo.PropertyType, array[1]), null);
				}
				else
				{
					propertyInfo.SetValue(this, Convert.ChangeType(array[1], propertyInfo.PropertyType, CultureInfo.InvariantCulture), null);
				}
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogWarning(base.name + ".SetFromString(): " + ex2.ToString());
			}
		}

		protected static Vector3 ApplyOffset(Vector3 position, Vector3 tangent, Vector3 up, float offsetAngle, float offsetRadius)
		{
			Quaternion quaternion = Quaternion.AngleAxis(offsetAngle, tangent);
			return position.Addition((quaternion * up).Multiply(offsetRadius));
		}

		protected static float GetClampedPosition(float position, CurvyPositionMode positionMode, CurvyClamping clampingMode, float length)
		{
			switch (positionMode)
			{
			case CurvyPositionMode.Relative:
				if (position == 1f)
				{
					return 1f;
				}
				return CurvyUtility.ClampTF(position, clampingMode);
			case CurvyPositionMode.WorldUnits:
				if (position == length)
				{
					return length;
				}
				return CurvyUtility.ClampDistance(position, clampingMode, length);
			default:
				throw new NotSupportedException();
			}
		}

		protected float ComputeOffsetCompensatedSpeed(float deltaTime)
		{
			if (OffsetRadius == 0f)
			{
				return Speed;
			}
			GetInterpolatedSourcePosition(RelativePosition, out var interpolatedPosition, out var tangent, out var up);
			Vector3 vector = ApplyOffset(interpolatedPosition, tangent, up, OffsetAngle, OffsetRadius);
			float tf = RelativePosition;
			MovementDirection curyDirection = m_Direction;
			SimulateAdvance(ref tf, ref curyDirection, Speed, deltaTime);
			GetInterpolatedSourcePosition(tf, out var interpolatedPosition2, out var tangent2, out var up2);
			Vector3 vector2 = ApplyOffset(interpolatedPosition2, tangent2, up2, OffsetAngle, OffsetRadius);
			float magnitude = (interpolatedPosition2 - interpolatedPosition).magnitude;
			float magnitude2 = (vector - vector2).magnitude;
			float num = magnitude / magnitude2;
			return Speed * (float.IsNaN(num) ? 1f : num);
		}

		private void GetOrientationNoneUpAndForward(out Vector3 targetUp, out Vector3 targetForward)
		{
			if (LockRotation)
			{
				targetUp = LockedRotation * Vector3.up;
				targetForward = LockedRotation * Vector3.forward;
			}
			else
			{
				targetUp = Transform.up;
				targetForward = Transform.forward;
			}
		}

		public void OnBeforeSerialize()
		{
		}

		public virtual void OnAfterDeserialize()
		{
			if (m_Speed < 0f)
			{
				m_Speed = Mathf.Abs(m_Speed);
				m_Direction = MovementDirection.Backward;
			}
			if ((short)MoveMode == 2)
			{
				MoveMode = MoveModeEnum.AbsolutePrecise;
			}
		}
	}
	public enum MovementDirection
	{
		Forward,
		Backward
	}
	public static class MovementDirectionMethods
	{
		public static MovementDirection FromInt(int value)
		{
			if (value < 0)
			{
				return MovementDirection.Backward;
			}
			return MovementDirection.Forward;
		}

		public static MovementDirection GetOpposite(this MovementDirection value)
		{
			return value switch
			{
				MovementDirection.Forward => MovementDirection.Backward, 
				MovementDirection.Backward => MovementDirection.Forward, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		public static int ToInt(this MovementDirection direction)
		{
			return direction switch
			{
				MovementDirection.Forward => 1, 
				MovementDirection.Backward => -1, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}
	}
	[AddComponentMenu("Curvy/Controller/CG Path Controller", 7)]
	[HelpURL("https://curvyeditor.com/doclink/pathcontroller")]
	public class PathController : CurvyController
	{
		[Section("General", true, false, 100, Sort = 0)]
		[SerializeField]
		[CGDataReferenceSelector(typeof(CGPath), Label = "Path/Slot")]
		private CGDataReference m_Path = new CGDataReference();

		public CGDataReference Path
		{
			get
			{
				return m_Path;
			}
			set
			{
				m_Path = value;
			}
		}

		public CGPath PathData
		{
			get
			{
				if (!Path.HasValue)
				{
					return null;
				}
				return Path.GetData<CGPath>();
			}
		}

		public override float Length
		{
			get
			{
				if (PathData == null)
				{
					return 0f;
				}
				return PathData.Length;
			}
		}

		public override bool IsReady
		{
			get
			{
				if (Path != null && !Path.IsEmpty)
				{
					return Path.HasValue;
				}
				return false;
			}
		}

		protected override float RelativeToAbsolute(float relativeDistance)
		{
			if (PathData == null)
			{
				return 0f;
			}
			return PathData.FToDistance(relativeDistance);
		}

		protected override float AbsoluteToRelative(float worldUnitDistance)
		{
			if (PathData == null)
			{
				return 0f;
			}
			return PathData.DistanceToF(worldUnitDistance);
		}

		protected override Vector3 GetInterpolatedSourcePosition(float tf)
		{
			return Path.Module.Generator.transform.TransformPoint(PathData.InterpolatePosition(tf));
		}

		protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
		{
			PathData.Interpolate(tf, out interpolatedPosition, out tangent, out up);
			Transform transform = Path.Module.Generator.transform;
			interpolatedPosition = transform.TransformPoint(interpolatedPosition);
			tangent = transform.TransformDirection(tangent);
			up = transform.TransformDirection(up);
		}

		protected override Vector3 GetTangent(float tf)
		{
			return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateDirection(tf));
		}

		protected override Vector3 GetOrientation(float tf)
		{
			return Path.Module.Generator.transform.TransformDirection(PathData.InterpolateUp(tf));
		}

		protected override void Advance(float speed, float deltaTime)
		{
			float tf = base.RelativePosition;
			MovementDirection curyDirection = base.MovementDirection;
			SimulateAdvance(ref tf, ref curyDirection, speed, deltaTime);
			base.MovementDirection = curyDirection;
			base.RelativePosition = tf;
		}

		protected override void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
		{
			int direction = curyDirection.ToInt();
			switch (base.MoveMode)
			{
			case MoveModeEnum.Relative:
				PathData.Move(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			case MoveModeEnum.AbsolutePrecise:
				PathData.MoveBy(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			default:
				throw new NotSupportedException();
			}
			curyDirection = MovementDirectionMethods.FromInt(direction);
		}
	}
	public enum SplineControllerConnectionBehavior
	{
		CurrentSpline,
		FollowUpSpline,
		RandomSpline,
		FollowUpOtherwiseRandom,
		Custom
	}
	[AddComponentMenu("Curvy/Controller/Spline Controller", 5)]
	[HelpURL("https://curvyeditor.com/doclink/splinecontroller")]
	public class SplineController : CurvyController
	{
		[Section("General", true, false, 100, Sort = 0)]
		[FieldCondition("m_Spline", null, false, ActionAttribute.ActionEnum.ShowError, "Missing source Spline", ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		protected CurvySpline m_Spline;

		[SerializeField]
		[Tooltip("Whether spline's cache data should be used. Set this to true to gain performance if precision is not required.")]
		private bool m_UseCache;

		[Section("Connections handling", true, false, 100, Sort = 250, HelpURL = "https://curvyeditor.com/doclink/curvycontroller_move")]
		[SerializeField]
		[Label("At connection, use", "What spline should the controller use when reaching a Connection")]
		private SplineControllerConnectionBehavior connectionBehavior;

		[SerializeField]
		[Label("Allow direction change", "When true, the controller will modify its direction to best fit the connected spline")]
		private bool allowDirectionChange = true;

		[SerializeField]
		[Label("Reject current spline", "Whether the current spline should be excluded from the randomly selected splines")]
		[FieldCondition("ShowRandomConnectionOptions", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private bool rejectCurrentSpline = true;

		[SerializeField]
		[Label("Reject divergent splines", "Whether splines that diverge from the current spline with more than a specific angle should be excluded from the randomly selected splines")]
		[FieldCondition("ShowRandomConnectionOptions", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private bool rejectTooDivergentSplines;

		[SerializeField]
		[Label("Max allowed angle", "Maximum allowed divergence angle in degrees")]
		[Range(0f, 180f)]
		private float maxAllowedDivergenceAngle = 90f;

		[SerializeField]
		[Label("Custom Selector", "A custom logic to select which connected spline to follow. Select a Script inheriting from SplineControllerConnectionBehavior")]
		[FieldCondition("connectionBehavior", SplineControllerConnectionBehavior.Custom, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[FieldCondition("connectionCustomSelector", null, false, ActionAttribute.ActionEnum.ShowWarning, "Missing custom selector", ActionAttribute.ActionPositionEnum.Below)]
		private ConnectedControlPointsSelector connectionCustomSelector;

		[Section("Events", false, false, 1000, HelpURL = "https://curvyeditor.com/doclink/splinecontroller_events")]
		[SerializeField]
		protected CurvySplineMoveEvent m_OnControlPointReached = new CurvySplineMoveEvent();

		[SerializeField]
		protected CurvySplineMoveEvent m_OnEndReached = new CurvySplineMoveEvent();

		[SerializeField]
		protected CurvySplineMoveEvent m_OnSwitch = new CurvySplineMoveEvent();

		private CurvySpline prePlaySpline;

		private readonly CurvySplineMoveEventArgs preAllocatedEventArgs;

		protected float SwitchStartTime;

		protected float SwitchDuration;

		protected CurvySpline SwitchTarget;

		protected float TfOnSwitchTarget;

		protected MovementDirection DirectionOnSwitchTarget;

		private const string InvalidSegmentErrorMessage = "[Curvy] Controller {0} reached segment {1} which is invalid segment because it has a length of 0. Please fix the invalid segment to avoid issues with the controller";

		public virtual CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				m_Spline = value;
			}
		}

		public bool UseCache
		{
			get
			{
				return m_UseCache;
			}
			set
			{
				if (m_UseCache != value)
				{
					m_UseCache = value;
				}
			}
		}

		public SplineControllerConnectionBehavior ConnectionBehavior
		{
			get
			{
				return connectionBehavior;
			}
			set
			{
				connectionBehavior = value;
			}
		}

		public ConnectedControlPointsSelector ConnectionCustomSelector
		{
			get
			{
				return connectionCustomSelector;
			}
			set
			{
				connectionCustomSelector = value;
			}
		}

		public bool AllowDirectionChange
		{
			get
			{
				return allowDirectionChange;
			}
			set
			{
				allowDirectionChange = value;
			}
		}

		public bool RejectCurrentSpline
		{
			get
			{
				return rejectCurrentSpline;
			}
			set
			{
				rejectCurrentSpline = value;
			}
		}

		public bool RejectTooDivergentSplines
		{
			get
			{
				return rejectTooDivergentSplines;
			}
			set
			{
				rejectTooDivergentSplines = value;
			}
		}

		public float MaxAllowedDivergenceAngle
		{
			get
			{
				return maxAllowedDivergenceAngle;
			}
			set
			{
				maxAllowedDivergenceAngle = value;
			}
		}

		public CurvySplineMoveEvent OnControlPointReached
		{
			get
			{
				return m_OnControlPointReached;
			}
			set
			{
				m_OnControlPointReached = value;
			}
		}

		public CurvySplineMoveEvent OnEndReached
		{
			get
			{
				return m_OnEndReached;
			}
			set
			{
				m_OnEndReached = value;
			}
		}

		public CurvySplineMoveEvent OnSwitch
		{
			get
			{
				return m_OnSwitch;
			}
			set
			{
				m_OnSwitch = value;
			}
		}

		public bool IsSwitching { get; private set; }

		public float SwitchProgress
		{
			get
			{
				if (!IsSwitching)
				{
					return 0f;
				}
				return Mathf.Clamp01((Time.time - SwitchStartTime) / SwitchDuration);
			}
		}

		public override float Length
		{
			get
			{
				if ((object)Spline == null)
				{
					return 0f;
				}
				return Spline.Length;
			}
		}

		public override bool IsReady
		{
			get
			{
				if ((object)Spline != null)
				{
					return Spline.IsInitialized;
				}
				return false;
			}
		}

		private bool ShowRandomConnectionOptions
		{
			get
			{
				if (ConnectionBehavior != SplineControllerConnectionBehavior.FollowUpOtherwiseRandom)
				{
					return ConnectionBehavior == SplineControllerConnectionBehavior.RandomSpline;
				}
				return true;
			}
		}

		public SplineController()
		{
			preAllocatedEventArgs = new CurvySplineMoveEventArgs(this, Spline, null, float.NaN, usingWorldUnits: false, float.NaN, MovementDirection.Forward);
		}

		public virtual void SwitchTo(CurvySpline destinationSpline, float destinationTf, float duration)
		{
			if (base.PlayState == CurvyControllerState.Stopped)
			{
				DTLog.LogError("[Curvy] Contoller can not switch when stopped. The switch call will be ignored");
				return;
			}
			SwitchStartTime = Time.time;
			SwitchDuration = duration;
			SwitchTarget = destinationSpline;
			TfOnSwitchTarget = destinationTf;
			DirectionOnSwitchTarget = base.MovementDirection;
			IsSwitching = true;
		}

		public void FinishCurrentSwitch()
		{
			if (IsSwitching)
			{
				IsSwitching = false;
				Spline = SwitchTarget;
				base.RelativePosition = TfOnSwitchTarget;
			}
		}

		public void CancelCurrentSwitch()
		{
			if (IsSwitching)
			{
				IsSwitching = false;
			}
		}

		public static float GetAngleBetweenConnectedSplines(CurvySplineSegment before, MovementDirection movementMode, CurvySplineSegment after, bool allowMovementModeChange)
		{
			Vector3 from = before.GetTangentFast(0f) * movementMode.ToInt();
			Vector3 to = after.GetTangentFast(0f) * GetPostConnectionDirection(after, movementMode, allowMovementModeChange).ToInt();
			return Vector3.Angle(from, to);
		}

		protected override void SavePrePlayState()
		{
			prePlaySpline = Spline;
			base.SavePrePlayState();
		}

		protected override void RestorePrePlayState()
		{
			Spline = prePlaySpline;
			base.RestorePrePlayState();
		}

		protected override float RelativeToAbsolute(float relativeDistance)
		{
			return Spline.TFToDistance(relativeDistance, base.Clamping);
		}

		protected override float AbsoluteToRelative(float worldUnitDistance)
		{
			return Spline.DistanceToTF(worldUnitDistance, base.Clamping);
		}

		protected override Vector3 GetInterpolatedSourcePosition(float tf)
		{
			Vector3 position = (UseCache ? Spline.InterpolateFast(tf) : Spline.Interpolate(tf));
			return Spline.transform.TransformPoint(position);
		}

		protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
		{
			CurvySpline spline = Spline;
			Transform transform = spline.transform;
			float localF;
			CurvySplineSegment curvySplineSegment = spline.TFToSegment(tf, out localF);
			if ((object)curvySplineSegment != null)
			{
				if (UseCache)
				{
					curvySplineSegment.InterpolateAndGetTangentFast(localF, out interpolatedPosition, out tangent);
				}
				else
				{
					curvySplineSegment.InterpolateAndGetTangent(localF, out interpolatedPosition, out tangent);
				}
				up = curvySplineSegment.GetOrientationUpFast(localF);
			}
			else
			{
				interpolatedPosition = Vector3.zero;
				tangent = Vector3.zero;
				up = Vector3.zero;
			}
			interpolatedPosition = transform.TransformPoint(interpolatedPosition);
			tangent = transform.TransformDirection(tangent);
			up = transform.TransformDirection(up);
		}

		protected override Vector3 GetTangent(float tf)
		{
			Vector3 direction = (UseCache ? Spline.GetTangentFast(tf) : Spline.GetTangent(tf));
			return Spline.transform.TransformDirection(direction);
		}

		protected override Vector3 GetOrientation(float tf)
		{
			return Spline.transform.TransformDirection(Spline.GetOrientationUpFast(tf));
		}

		protected override void Advance(float speed, float deltaTime)
		{
			float distance = speed * deltaTime;
			if (Spline.Count != 0)
			{
				EventAwareMove(distance);
			}
			if (IsSwitching && SwitchTarget.Count > 0)
			{
				SimulateAdvanceOnSpline(ref TfOnSwitchTarget, ref DirectionOnSwitchTarget, SwitchTarget, speed * deltaTime);
				preAllocatedEventArgs.Set_INTERNAL(this, SwitchTarget, null, TfOnSwitchTarget, SwitchProgress, DirectionOnSwitchTarget, usingWorldUnits: false);
				OnSwitch.Invoke(preAllocatedEventArgs);
				if (preAllocatedEventArgs.Cancel)
				{
					CancelCurrentSwitch();
				}
			}
		}

		protected override void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
		{
			SimulateAdvanceOnSpline(ref tf, ref curyDirection, Spline, speed * deltaTime);
		}

		private void SimulateAdvanceOnSpline(ref float tf, ref MovementDirection curyDirection, CurvySpline spline, float distance)
		{
			if (spline.Count > 0)
			{
				int dir = curyDirection.ToInt();
				switch (base.MoveMode)
				{
				case MoveModeEnum.AbsolutePrecise:
					tf = spline.DistanceToTF(spline.ClampDistance(spline.TFToDistance(tf) + distance * (float)dir, ref dir, base.Clamping));
					break;
				case MoveModeEnum.Relative:
					tf = CurvyUtility.ClampTF(tf + distance * (float)dir, ref dir, base.Clamping);
					break;
				default:
					throw new NotSupportedException();
				}
				curyDirection = MovementDirectionMethods.FromInt(dir);
			}
		}

		protected override void InitializedApplyDeltaTime(float deltaTime)
		{
			if (Spline.Dirty)
			{
				Spline.Refresh();
			}
			base.InitializedApplyDeltaTime(deltaTime);
			if (IsSwitching && SwitchProgress >= 1f)
			{
				FinishCurrentSwitch();
			}
		}

		protected override void ComputeTargetPositionAndRotation(out Vector3 targetPosition, out Vector3 targetUp, out Vector3 targetForward)
		{
			base.ComputeTargetPositionAndRotation(out var targetPosition2, out var targetUp2, out var targetForward2);
			Quaternion a = Quaternion.LookRotation(targetForward2, targetUp2);
			if (IsSwitching)
			{
				CurvySpline spline = Spline;
				float relativePosition = base.RelativePosition;
				m_Spline = SwitchTarget;
				base.RelativePosition = TfOnSwitchTarget;
				base.ComputeTargetPositionAndRotation(out var targetPosition3, out var targetUp3, out var targetForward3);
				Quaternion b = Quaternion.LookRotation(targetForward3, targetUp3);
				m_Spline = spline;
				base.RelativePosition = relativePosition;
				targetPosition = targetPosition2.LerpUnclamped(targetPosition3, SwitchProgress);
				Quaternion quaternion = Quaternion.LerpUnclamped(a, b, SwitchProgress);
				targetUp = quaternion * Vector3.up;
				targetForward = quaternion * Vector3.forward;
			}
			else
			{
				targetPosition = targetPosition2;
				targetUp = targetUp2;
				targetForward = targetForward2;
			}
		}

		private static float MovementCompatibleGetPosition(SplineController controller, CurvyPositionMode positionMode, out CurvySplineSegment controlPoint, out bool isOnControlPoint, float clampedPosition)
		{
			CurvySpline spline = controller.Spline;
			float localF;
			bool isOnSegmentStart;
			bool isOnSegmentEnd;
			switch (controller.PositionMode)
			{
			case CurvyPositionMode.Relative:
				controlPoint = spline.TFToSegment(clampedPosition, out localF, out isOnSegmentStart, out isOnSegmentEnd, CurvyClamping.Clamp);
				break;
			case CurvyPositionMode.WorldUnits:
				controlPoint = spline.DistanceToSegment(clampedPosition, out localF, out isOnSegmentStart, out isOnSegmentEnd);
				break;
			default:
				throw new NotSupportedException();
			}
			float result = ((positionMode == controller.PositionMode) ? clampedPosition : (positionMode switch
			{
				CurvyPositionMode.Relative => spline.SegmentToTF(controlPoint, controlPoint.DistanceToLocalF(localF)), 
				CurvyPositionMode.WorldUnits => controlPoint.Distance + controlPoint.LocalFToDistance(localF), 
				_ => throw new ArgumentOutOfRangeException(), 
			}));
			if (isOnSegmentEnd)
			{
				controlPoint = spline.GetNextControlPoint(controlPoint);
			}
			isOnControlPoint = isOnSegmentStart || isOnSegmentEnd;
			return result;
		}

		private static void MovementCompatibleSetPosition(SplineController controller, CurvyPositionMode positionMode, float specialClampedPosition)
		{
			if (positionMode == controller.PositionMode)
			{
				controller.m_Position = specialClampedPosition;
				return;
			}
			switch (positionMode)
			{
			case CurvyPositionMode.Relative:
				controller.m_Position = controller.Spline.TFToDistance(specialClampedPosition, controller.Clamping);
				break;
			case CurvyPositionMode.WorldUnits:
				controller.m_Position = controller.Spline.DistanceToTF(specialClampedPosition, controller.Clamping);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private void EventAwareMove(float distance)
		{
			CurvyPositionMode curvyPositionMode = base.MoveMode switch
			{
				MoveModeEnum.AbsolutePrecise => CurvyPositionMode.WorldUnits, 
				MoveModeEnum.Relative => CurvyPositionMode.Relative, 
				_ => throw new NotSupportedException(), 
			};
			float num = distance;
			bool cancelMovement = false;
			switch (base.MovementDirection)
			{
			case MovementDirection.Backward:
				if (m_Position == 0f)
				{
					if (base.Clamping == CurvyClamping.PingPong)
					{
						base.MovementDirection = base.MovementDirection.GetOpposite();
					}
					else if (base.Clamping == CurvyClamping.Clamp)
					{
						return;
					}
				}
				break;
			case MovementDirection.Forward:
			{
				float num2 = base.PositionMode switch
				{
					CurvyPositionMode.Relative => 1f, 
					CurvyPositionMode.WorldUnits => m_Spline.Length, 
					_ => throw new ArgumentOutOfRangeException(), 
				};
				if (m_Position == num2)
				{
					if (base.Clamping == CurvyClamping.PingPong)
					{
						base.MovementDirection = base.MovementDirection.GetOpposite();
					}
					else if (base.Clamping == CurvyClamping.Clamp)
					{
						return;
					}
				}
				break;
			}
			default:
				throw new ArgumentOutOfRangeException();
			}
			CurvySplineSegment controlPoint;
			bool isOnControlPoint;
			float postEventsControlPointPosition = MovementCompatibleGetPosition(this, curvyPositionMode, out controlPoint, out isOnControlPoint, m_Position);
			if (controlPoint.Length == 0f && Spline.IsControlPointASegment(controlPoint))
			{
				DTLog.LogWarning($"[Curvy] Controller {base.name} reached segment {controlPoint} which is invalid segment because it has a length of 0. Please fix the invalid segment to avoid issues with the controller");
			}
			int num3 = 10000;
			while (!cancelMovement && num > 0f && num3-- > 0)
			{
				CurvySplineSegment curvySplineSegment = ((base.MovementDirection != 0) ? (isOnControlPoint ? Spline.GetPreviousControlPoint(controlPoint) : controlPoint) : Spline.GetNextControlPoint(controlPoint));
				if ((object)curvySplineSegment != null && Spline.IsControlPointVisible(curvySplineSegment))
				{
					float num4 = GetControlPointPosition(curvySplineSegment, curvyPositionMode);
					if (base.MovementDirection == MovementDirection.Forward && m_Spline.Closed && num4 == 0f)
					{
						num4 = curvyPositionMode switch
						{
							CurvyPositionMode.Relative => 1f, 
							CurvyPositionMode.WorldUnits => m_Spline.Length, 
							_ => throw new ArgumentOutOfRangeException(), 
						};
					}
					float num5 = Mathf.Abs(num4 - postEventsControlPointPosition);
					if (num5 > num)
					{
						float position = postEventsControlPointPosition + num * (float)base.MovementDirection.ToInt();
						position = CurvyController.GetClampedPosition(position, curvyPositionMode, base.Clamping, m_Spline.Length);
						MovementCompatibleSetPosition(this, curvyPositionMode, position);
						break;
					}
					num -= num5;
					HandleReachingNewControlPoint(curvySplineSegment, num4, curvyPositionMode, num, ref cancelMovement, out controlPoint, out isOnControlPoint, out postEventsControlPointPosition);
				}
				if (isOnControlPoint && (bool)controlPoint.Connection && controlPoint.Connection.ControlPointsList.Count > 1)
				{
					CurvySplineSegment curvySplineSegment2;
					MovementDirection newDirection;
					switch (ConnectionBehavior)
					{
					case SplineControllerConnectionBehavior.CurrentSpline:
						curvySplineSegment2 = controlPoint;
						newDirection = base.MovementDirection;
						break;
					case SplineControllerConnectionBehavior.FollowUpSpline:
						curvySplineSegment2 = HandleFollowUpConnectionBehavior(controlPoint, base.MovementDirection, out newDirection);
						break;
					case SplineControllerConnectionBehavior.FollowUpOtherwiseRandom:
						curvySplineSegment2 = (controlPoint.FollowUp ? HandleFollowUpConnectionBehavior(controlPoint, base.MovementDirection, out newDirection) : HandleRandomConnectionBehavior(controlPoint, base.MovementDirection, out newDirection, controlPoint.Connection.ControlPointsList));
						break;
					case SplineControllerConnectionBehavior.RandomSpline:
						curvySplineSegment2 = HandleRandomConnectionBehavior(controlPoint, base.MovementDirection, out newDirection, controlPoint.Connection.ControlPointsList);
						break;
					case SplineControllerConnectionBehavior.Custom:
						if (ConnectionCustomSelector == null)
						{
							DTLog.LogError("[Curvy] You need to set a non null ConnectionCustomSelector when using SplineControllerConnectionBehavior.Custom");
							curvySplineSegment2 = controlPoint;
						}
						else
						{
							curvySplineSegment2 = ConnectionCustomSelector.SelectConnectedControlPoint(this, controlPoint.Connection, controlPoint);
						}
						newDirection = base.MovementDirection;
						break;
					default:
						throw new ArgumentOutOfRangeException();
					}
					if ((object)curvySplineSegment2 != controlPoint)
					{
						base.MovementDirection = newDirection;
						float controlPointPosition = GetControlPointPosition(curvySplineSegment2, curvyPositionMode);
						HandleReachingNewControlPoint(curvySplineSegment2, controlPointPosition, curvyPositionMode, num, ref cancelMovement, out controlPoint, out isOnControlPoint, out postEventsControlPointPosition);
					}
				}
				if (!isOnControlPoint)
				{
					continue;
				}
				switch (base.Clamping)
				{
				case CurvyClamping.Loop:
					if (!Spline.Closed)
					{
						CurvySplineSegment curvySplineSegment3 = ((base.MovementDirection == MovementDirection.Backward && (object)controlPoint == Spline.FirstVisibleControlPoint) ? Spline.LastVisibleControlPoint : ((base.MovementDirection != 0 || (object)controlPoint != Spline.LastVisibleControlPoint) ? null : Spline.FirstVisibleControlPoint));
						if ((object)curvySplineSegment3 != null)
						{
							float controlPointPosition2 = GetControlPointPosition(curvySplineSegment3, curvyPositionMode);
							HandleReachingNewControlPoint(curvySplineSegment3, controlPointPosition2, curvyPositionMode, num, ref cancelMovement, out controlPoint, out isOnControlPoint, out postEventsControlPointPosition);
						}
					}
					break;
				case CurvyClamping.Clamp:
					if ((base.MovementDirection == MovementDirection.Backward && (object)controlPoint == Spline.FirstVisibleControlPoint) || (base.MovementDirection == MovementDirection.Forward && (object)controlPoint == Spline.LastVisibleControlPoint))
					{
						num = 0f;
					}
					break;
				case CurvyClamping.PingPong:
					if ((base.MovementDirection == MovementDirection.Backward && (object)controlPoint == Spline.FirstVisibleControlPoint) || (base.MovementDirection == MovementDirection.Forward && (object)controlPoint == Spline.LastVisibleControlPoint))
					{
						base.MovementDirection = base.MovementDirection.GetOpposite();
					}
					break;
				default:
					throw new ArgumentOutOfRangeException();
				}
			}
			if (num3 <= 0)
			{
				DTLog.LogError($"[Curvy] Unexpected behavior in Spline Controller '{base.name}'. Please raise a Bug Report.");
			}
		}

		private void HandleReachingNewControlPoint(CurvySplineSegment controlPoint, float controlPointPosition, CurvyPositionMode positionMode, float currentDelta, ref bool cancelMovement, out CurvySplineSegment postEventsControlPoint, out bool postEventsIsControllerOnControlPoint, out float postEventsControlPointPosition)
		{
			MovementCompatibleSetPosition(this, positionMode, controlPointPosition);
			Spline = controlPoint.Spline;
			postEventsControlPoint = controlPoint;
			postEventsIsControllerOnControlPoint = true;
			postEventsControlPointPosition = controlPointPosition;
			if (controlPoint.Length == 0f && Spline.IsControlPointASegment(controlPoint))
			{
				DTLog.LogWarning($"[Curvy] Controller {base.name} reached segment {controlPoint} which is invalid segment because it has a length of 0. Please fix the invalid segment to avoid issues with the controller");
			}
			bool usingWorldUnits = positionMode switch
			{
				CurvyPositionMode.Relative => false, 
				CurvyPositionMode.WorldUnits => true, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
			preAllocatedEventArgs.Set_INTERNAL(this, Spline, controlPoint, controlPointPosition, currentDelta, base.MovementDirection, usingWorldUnits);
			InvokeEventHandler(OnControlPointReached, preAllocatedEventArgs, positionMode, ref postEventsControlPoint, ref postEventsIsControllerOnControlPoint, ref postEventsControlPointPosition);
			if ((object)preAllocatedEventArgs.Spline.FirstVisibleControlPoint == preAllocatedEventArgs.ControlPoint || (object)preAllocatedEventArgs.Spline.LastVisibleControlPoint == preAllocatedEventArgs.ControlPoint)
			{
				InvokeEventHandler(OnEndReached, preAllocatedEventArgs, positionMode, ref postEventsControlPoint, ref postEventsIsControllerOnControlPoint, ref postEventsControlPointPosition);
			}
			cancelMovement |= preAllocatedEventArgs.Cancel;
		}

		private void InvokeEventHandler(CurvySplineMoveEvent @event, CurvySplineMoveEventArgs eventArgument, CurvyPositionMode positionMode, ref CurvySplineSegment postEventsControlPoint, ref bool postEventsIsControllerOnControlPoint, ref float postEventsControlPointPosition)
		{
			float position = m_Position;
			CurvyPositionMode positionMode2 = base.PositionMode;
			CurvySpline spline = m_Spline;
			@event.Invoke(eventArgument);
			if (m_Position != position || base.PositionMode != positionMode2 || (object)m_Spline != spline)
			{
				postEventsControlPointPosition = MovementCompatibleGetPosition(this, positionMode, out postEventsControlPoint, out postEventsIsControllerOnControlPoint, m_Position);
			}
		}

		private CurvySplineSegment HandleRandomConnectionBehavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection, ReadOnlyCollection<CurvySplineSegment> connectedControlPoints)
		{
			List<CurvySplineSegment> list = new List<CurvySplineSegment>(connectedControlPoints.Count);
			for (int i = 0; i < connectedControlPoints.Count; i++)
			{
				CurvySplineSegment curvySplineSegment = connectedControlPoints[i];
				if ((!RejectCurrentSpline || !(curvySplineSegment == currentControlPoint)) && (!RejectTooDivergentSplines || !(GetAngleBetweenConnectedSplines(currentControlPoint, currentDirection, curvySplineSegment, AllowDirectionChange) > MaxAllowedDivergenceAngle)))
				{
					list.Add(curvySplineSegment);
				}
			}
			CurvySplineSegment curvySplineSegment2 = ((list.Count == 0) ? currentControlPoint : list[UnityEngine.Random.Range(0, list.Count)]);
			newDirection = GetPostConnectionDirection(curvySplineSegment2, currentDirection, AllowDirectionChange);
			return curvySplineSegment2;
		}

		private static MovementDirection GetPostConnectionDirection(CurvySplineSegment connectedControlPoint, MovementDirection currentDirection, bool directionChangeAllowed)
		{
			if (!directionChangeAllowed || connectedControlPoint.Spline.Closed)
			{
				return currentDirection;
			}
			return HeadingToDirection(ConnectionHeadingEnum.Auto, connectedControlPoint, currentDirection);
		}

		private CurvySplineSegment HandleFollowUpConnectionBehavior(CurvySplineSegment currentControlPoint, MovementDirection currentDirection, out MovementDirection newDirection)
		{
			CurvySplineSegment result = (currentControlPoint.FollowUp ? currentControlPoint.FollowUp : currentControlPoint);
			newDirection = ((AllowDirectionChange && (bool)currentControlPoint.FollowUp) ? HeadingToDirection(currentControlPoint.FollowUpHeading, currentControlPoint.FollowUp, currentDirection) : currentDirection);
			return result;
		}

		private static MovementDirection HeadingToDirection(ConnectionHeadingEnum heading, CurvySplineSegment controlPoint, MovementDirection currentDirection)
		{
			return heading.ResolveAuto(controlPoint) switch
			{
				ConnectionHeadingEnum.Minus => MovementDirection.Backward, 
				ConnectionHeadingEnum.Sharp => currentDirection, 
				ConnectionHeadingEnum.Plus => MovementDirection.Forward, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		private static float GetControlPointPosition(CurvySplineSegment controlPoint, CurvyPositionMode positionMode)
		{
			return positionMode switch
			{
				CurvyPositionMode.Relative => controlPoint.TF, 
				CurvyPositionMode.WorldUnits => controlPoint.Distance, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}
	}
	[RequireComponent(typeof(Text))]
	[AddComponentMenu("Curvy/Controller/UI Text Spline Controller")]
	[HelpURL("https://curvyeditor.com/doclink/uitextsplinecontroller")]
	public class UITextSplineController : SplineController, IMeshModifier
	{
		protected interface IGlyph
		{
			Vector3 Center { get; }

			void Transpose(Vector3 v);

			void Rotate(Quaternion rotation);
		}

		protected class GlyphQuad : IGlyph
		{
			public UIVertex[] V = new UIVertex[4];

			public Rect Rect;

			public Vector3 Center => Rect.center;

			public void Load(List<UIVertex> verts, int index)
			{
				V[0] = verts[index];
				V[1] = verts[index + 1];
				V[2] = verts[index + 2];
				V[3] = verts[index + 3];
				calcRect();
			}

			public void LoadTris(List<UIVertex> verts, int index)
			{
				V[0] = verts[index];
				V[1] = verts[index + 1];
				V[2] = verts[index + 2];
				V[3] = verts[index + 4];
				calcRect();
			}

			public void calcRect()
			{
				Rect = new Rect(V[0].position.x, V[2].position.y, V[2].position.x - V[0].position.x, V[0].position.y - V[2].position.y);
			}

			public void Save(List<UIVertex> verts, int index)
			{
				verts[index] = V[0];
				verts[index + 1] = V[1];
				verts[index + 2] = V[2];
				verts[index + 3] = V[3];
			}

			public void Save(VertexHelper vh)
			{
				vh.AddUIVertexQuad(V);
			}

			public void Transpose(Vector3 v)
			{
				for (int i = 0; i < 4; i++)
				{
					V[i].position += v;
				}
			}

			public void Rotate(Quaternion rotation)
			{
				for (int i = 0; i < 4; i++)
				{
					V[i].position = V[i].position.RotateAround(Center, rotation);
				}
			}
		}

		protected class GlyphPlain : IGlyph
		{
			public Vector3[] V = new Vector3[4];

			public Rect Rect;

			public Vector3 Center => Rect.center;

			public void Load(ref Vector3[] verts, int index)
			{
				V[0] = verts[index];
				V[1] = verts[index + 1];
				V[2] = verts[index + 2];
				V[3] = verts[index + 3];
				calcRect();
			}

			public void calcRect()
			{
				Rect = new Rect(V[0].x, V[2].y, V[2].x - V[0].x, V[0].y - V[2].y);
			}

			public void Save(ref Vector3[] verts, int index)
			{
				verts[index] = V[0];
				verts[index + 1] = V[1];
				verts[index + 2] = V[2];
				verts[index + 3] = V[3];
			}

			public void Transpose(Vector3 v)
			{
				for (int i = 0; i < 4; i++)
				{
					V[i] += v;
				}
			}

			public void Rotate(Quaternion rotation)
			{
				for (int i = 0; i < 4; i++)
				{
					V[i] = V[i].RotateAround(Center, rotation);
				}
			}
		}

		[Section("Orientation", true, false, 100)]
		[Tooltip("If true, the text characters will keep the same orientation regardless of the spline they follow")]
		[SerializeField]
		private bool staticOrientation;

		private Graphic m_Graphic;

		private RectTransform mRect;

		private Text mText;

		public bool StaticOrientation
		{
			get
			{
				return staticOrientation;
			}
			set
			{
				staticOrientation = value;
			}
		}

		protected override bool ShowOrientationSection => false;

		protected override bool ShowOffsetSection => false;

		protected Text Text
		{
			get
			{
				if (mText == null)
				{
					mText = GetComponent<Text>();
				}
				return mText;
			}
		}

		protected RectTransform Rect
		{
			get
			{
				if (mRect == null)
				{
					mRect = GetComponent<RectTransform>();
				}
				return mRect;
			}
		}

		protected Graphic graphic
		{
			get
			{
				if (m_Graphic == null)
				{
					m_Graphic = GetComponent<Graphic>();
				}
				return m_Graphic;
			}
		}

		public override CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				if (m_Spline != value)
				{
					if (base.isInitialized)
					{
						UnbindSplineRelatedEvents();
					}
					m_Spline = value;
					if (base.isInitialized)
					{
						BindSplineRelatedEvents();
					}
				}
			}
		}

		protected override void InitializedApplyDeltaTime(float deltaTime)
		{
			base.InitializedApplyDeltaTime(deltaTime);
			graphic.SetVerticesDirty();
		}

		public void ModifyMesh(Mesh verts)
		{
			if (base.enabled && base.gameObject.activeInHierarchy && base.isInitialized)
			{
				Vector3[] verts2 = verts.vertices;
				GlyphPlain glyphPlain = new GlyphPlain();
				for (int i = 0; i < Text.text.Length; i++)
				{
					glyphPlain.Load(ref verts2, i * 4);
					UpdateGlyph(glyphPlain);
					glyphPlain.Save(ref verts2, i * 4);
				}
				verts.vertices = verts2;
			}
		}

		public void ModifyMesh(VertexHelper vertexHelper)
		{
			if (base.enabled && base.gameObject.activeInHierarchy && base.isInitialized)
			{
				List<UIVertex> list = new List<UIVertex>();
				GlyphQuad glyphQuad = new GlyphQuad();
				vertexHelper.GetUIVertexStream(list);
				vertexHelper.Clear();
				for (int i = 0; i < Text.text.Length; i++)
				{
					glyphQuad.LoadTris(list, i * 6);
					UpdateGlyph(glyphQuad);
					glyphQuad.Save(vertexHelper);
				}
			}
		}

		private void UpdateGlyph(IGlyph glyph)
		{
			float tf = AbsoluteToRelative(CurvyController.GetClampedPosition(base.AbsolutePosition + glyph.Center.x, CurvyPositionMode.WorldUnits, base.Clamping, Length));
			glyph.Transpose(new Vector3(0f, glyph.Center.y, 0f));
			if (!StaticOrientation)
			{
				Vector3 tangent = GetTangent(tf);
				glyph.Rotate(Quaternion.AngleAxis(Mathf.Atan2(tangent.x, 0f - tangent.y) * 57.29578f - 90f, Vector3.forward));
			}
			glyph.Transpose(-glyph.Center);
			float tf2 = AbsoluteToRelative(CurvyController.GetClampedPosition(base.AbsolutePosition, CurvyPositionMode.WorldUnits, base.Clamping, Length));
			Vector3 vector = (base.UseCache ? Spline.InterpolateFast(tf2) : Spline.Interpolate(tf2));
			Vector3 vector2 = (base.UseCache ? Spline.InterpolateFast(tf) : Spline.Interpolate(tf));
			glyph.Transpose(Spline.transform.TransformDirection(vector2 - vector));
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			if (graphic != null)
			{
				graphic.SetVerticesDirty();
			}
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if (graphic != null)
			{
				graphic.SetVerticesDirty();
			}
		}

		protected override void BindEvents()
		{
			base.BindEvents();
			BindSplineRelatedEvents();
		}

		protected override void UnbindEvents()
		{
			base.UnbindEvents();
			UnbindSplineRelatedEvents();
		}

		private void BindSplineRelatedEvents()
		{
			if ((bool)Spline)
			{
				UnbindSplineRelatedEvents();
				Spline.OnRefresh.AddListener(OnSplineRefreshed);
			}
		}

		private void UnbindSplineRelatedEvents()
		{
			if ((bool)Spline)
			{
				Spline.OnRefresh.RemoveListener(OnSplineRefreshed);
			}
		}

		private void OnSplineRefreshed(CurvySplineEventArgs e)
		{
			CurvySpline curvySpline = e.Sender as CurvySpline;
			if (curvySpline != Spline)
			{
				curvySpline.OnRefresh.RemoveListener(OnSplineRefreshed);
			}
			else
			{
				graphic.SetVerticesDirty();
			}
		}
	}
	[AddComponentMenu("Curvy/Controller/CG Volume Controller", 8)]
	[HelpURL("https://curvyeditor.com/doclink/volumecontroller")]
	public class VolumeController : CurvyController
	{
		private const float CrossPositionRangeMin = -0.5f;

		private const float CrossPositionRangeMax = 0.5f;

		[Section("General", true, false, 100)]
		[CGDataReferenceSelector(typeof(CGVolume), Label = "Volume/Slot")]
		[SerializeField]
		private CGDataReference m_Volume = new CGDataReference();

		[Section("Cross Position", true, false, 100, Sort = 1, HelpURL = "https://curvyeditor.com/doclink/volumecontroller_crossposition")]
		[SerializeField]
		[FloatRegion(UseSlider = true, Precision = 4, RegionOptionsPropertyName = "CrossRangeOptions", Options = AttributeOptionsFlags.Full)]
		private FloatRegion m_CrossRange = new FloatRegion(-0.5f, 0.5f);

		[RangeEx("MinCrossRelativePosition", "MaxCrossRelativePosition", "", "")]
		[SerializeField]
		private float crossRelativePosition;

		[SerializeField]
		private CurvyClamping m_CrossClamping;

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use crossRelativePosition instead. This field is kept for retro compatibility reasons")]
		private float m_CrossInitialPosition;

		public CGDataReference Volume
		{
			get
			{
				return m_Volume;
			}
			set
			{
				m_Volume = value;
			}
		}

		public CGVolume VolumeData
		{
			get
			{
				if (!Volume.HasValue)
				{
					return null;
				}
				return Volume.GetData<CGVolume>();
			}
		}

		public float CrossFrom
		{
			get
			{
				return m_CrossRange.From;
			}
			set
			{
				m_CrossRange.From = Mathf.Clamp(value, -0.5f, 0.5f);
			}
		}

		public float CrossTo
		{
			get
			{
				return m_CrossRange.To;
			}
			set
			{
				m_CrossRange.To = Mathf.Clamp(value, CrossFrom, 0.5f);
			}
		}

		public float CrossLength => m_CrossRange.Length;

		public CurvyClamping CrossClamping
		{
			get
			{
				return m_CrossClamping;
			}
			set
			{
				m_CrossClamping = value;
			}
		}

		public float CrossRelativePosition
		{
			get
			{
				return GetClampedCrossPosition(crossRelativePosition);
			}
			set
			{
				crossRelativePosition = GetClampedCrossPosition(value);
			}
		}

		public override float Length
		{
			get
			{
				if (VolumeData == null)
				{
					return 0f;
				}
				return VolumeData.Length;
			}
		}

		public override bool IsReady
		{
			get
			{
				if (Volume != null && !Volume.IsEmpty)
				{
					return Volume.HasValue;
				}
				return false;
			}
		}

		private RegionOptions<float> CrossRangeOptions => RegionOptions<float>.MinMax(-0.5f, 0.5f);

		private float MinCrossRelativePosition => m_CrossRange.From;

		private float MaxCrossRelativePosition => m_CrossRange.To;

		public float CrossRelativeToAbsolute(float relativeDistance)
		{
			if (VolumeData == null)
			{
				return 0f;
			}
			return VolumeData.CrossFToDistance(base.RelativePosition, relativeDistance, CrossClamping);
		}

		public float CrossAbsoluteToRelative(float worldUnitDistance)
		{
			if (VolumeData == null)
			{
				return 0f;
			}
			return VolumeData.CrossDistanceToF(base.RelativePosition, worldUnitDistance, CrossClamping);
		}

		protected override float RelativeToAbsolute(float relativeDistance)
		{
			if (VolumeData == null)
			{
				return 0f;
			}
			return VolumeData.FToDistance(relativeDistance);
		}

		protected override float AbsoluteToRelative(float worldUnitDistance)
		{
			if (VolumeData == null)
			{
				return 0f;
			}
			return VolumeData.DistanceToF(worldUnitDistance);
		}

		protected override Vector3 GetInterpolatedSourcePosition(float tf)
		{
			return Volume.Module.Generator.transform.TransformPoint(VolumeData.InterpolateVolumePosition(tf, CrossRelativePosition));
		}

		protected override void GetInterpolatedSourcePosition(float tf, out Vector3 interpolatedPosition, out Vector3 tangent, out Vector3 up)
		{
			VolumeData.InterpolateVolume(tf, CrossRelativePosition, out interpolatedPosition, out tangent, out up);
			Transform transform = Volume.Module.Generator.transform;
			interpolatedPosition = transform.TransformPoint(interpolatedPosition);
			tangent = transform.TransformDirection(tangent);
			up = transform.TransformDirection(up);
		}

		protected override Vector3 GetTangent(float tf)
		{
			return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeDirection(tf, CrossRelativePosition));
		}

		protected override Vector3 GetOrientation(float tf)
		{
			return Volume.Module.Generator.transform.TransformDirection(VolumeData.InterpolateVolumeUp(tf, CrossRelativePosition));
		}

		protected override void Advance(float speed, float deltaTime)
		{
			float tf = base.RelativePosition;
			MovementDirection curyDirection = base.MovementDirection;
			SimulateAdvance(ref tf, ref curyDirection, speed, deltaTime);
			base.MovementDirection = curyDirection;
			base.RelativePosition = tf;
		}

		protected override void SimulateAdvance(ref float tf, ref MovementDirection curyDirection, float speed, float deltaTime)
		{
			int direction = curyDirection.ToInt();
			switch (base.MoveMode)
			{
			case MoveModeEnum.Relative:
				VolumeData.Move(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			case MoveModeEnum.AbsolutePrecise:
				VolumeData.MoveBy(ref tf, ref direction, speed * deltaTime, base.Clamping);
				break;
			default:
				throw new NotSupportedException();
			}
			curyDirection = MovementDirectionMethods.FromInt(direction);
		}

		private float GetClampedCrossPosition(float position)
		{
			return CurvyUtility.ClampValue(position, CrossClamping, CrossFrom, CrossTo);
		}

		public override void OnAfterDeserialize()
		{
			base.OnAfterDeserialize();
			if (!float.IsNaN(m_CrossInitialPosition))
			{
				crossRelativePosition = DTMath.MapValue(CrossFrom, CrossTo, m_CrossInitialPosition, -0.5f, 0.5f);
				m_CrossInitialPosition = float.NaN;
			}
		}
	}
}
namespace FluffyUnderware.Curvy.Components
{
	[HelpURL("https://curvyeditor.com/doclink/curvyglrenderer")]
	[AddComponentMenu("Curvy/Misc/Curvy GL Renderer")]
	public class CurvyGLRenderer : MonoBehaviour
	{
		[ArrayEx(ShowAdd = false, Draggable = false)]
		public List<GLSlotData> Splines = new List<GLSlotData>();

		private Material lineMaterial;

		private void CreateLineMaterial()
		{
			if (!lineMaterial)
			{
				lineMaterial = new Material(Shader.Find("Hidden/Internal-Colored"));
				lineMaterial.hideFlags = HideFlags.HideAndDontSave;
				lineMaterial.shader.hideFlags = HideFlags.HideAndDontSave;
			}
		}

		private void OnPostRender()
		{
			sanitize();
			CreateLineMaterial();
			for (int num = Splines.Count - 1; num >= 0; num--)
			{
				Splines[num].Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
				if (Splines[num].VertexData.Count == 0)
				{
					Splines[num].GetVertexData();
				}
				Splines[num].Render(lineMaterial);
			}
		}

		private void sanitize()
		{
			for (int num = Splines.Count - 1; num >= 0; num--)
			{
				if (Splines[num] == null || Splines[num].Spline == null)
				{
					Splines.RemoveAt(num);
				}
			}
		}

		private void OnSplineRefresh(CurvySplineEventArgs e)
		{
			GLSlotData slot = getSlot((CurvySpline)e.Sender);
			if (slot == null)
			{
				((CurvySpline)e.Sender).OnRefresh.RemoveListener(OnSplineRefresh);
			}
			else
			{
				slot.VertexData.Clear();
			}
		}

		private GLSlotData getSlot(CurvySpline spline)
		{
			if ((bool)spline)
			{
				foreach (GLSlotData spline2 in Splines)
				{
					if (spline2.Spline == spline)
					{
						return spline2;
					}
				}
			}
			return null;
		}

		public void Add(CurvySpline spline)
		{
			if (spline != null)
			{
				Splines.Add(new GLSlotData
				{
					Spline = spline
				});
			}
		}

		public void Remove(CurvySpline spline)
		{
			for (int num = Splines.Count - 1; num >= 0; num--)
			{
				if (Splines[num].Spline == spline)
				{
					Splines.RemoveAt(num);
				}
			}
		}
	}
	[Serializable]
	public class GLSlotData
	{
		[SerializeField]
		public CurvySpline Spline;

		public Color LineColor = CurvyGlobalManager.DefaultGizmoColor;

		public List<Vector3[]> VertexData = new List<Vector3[]>();

		public void GetVertexData()
		{
			VertexData.Clear();
			List<CurvySpline> list = new List<CurvySpline>();
			list.Add(Spline);
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].IsInitialized)
				{
					VertexData.Add(list[i].GetApproximation(Space.World));
				}
			}
		}

		public void Render(Material mat)
		{
			for (int i = 0; i < VertexData.Count; i++)
			{
				if (VertexData[i].Length != 0)
				{
					mat.SetPass(0);
					GL.Begin(1);
					GL.Color(LineColor);
					for (int j = 1; j < VertexData[i].Length; j++)
					{
						GL.Vertex(VertexData[i][j - 1]);
						GL.Vertex(VertexData[i][j]);
					}
					GL.End();
				}
			}
		}
	}
	[AddComponentMenu("Curvy/Misc/Curvy Line Renderer")]
	[RequireComponent(typeof(LineRenderer))]
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/curvylinerenderer")]
	public class CurvyLineRenderer : MonoBehaviour
	{
		public CurvySpline m_Spline;

		private LineRenderer mRenderer;

		public CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				if (m_Spline != value)
				{
					UnbindEvents();
					m_Spline = value;
					BindEvents();
					Refresh();
				}
			}
		}

		private void Awake()
		{
			mRenderer = GetComponent<LineRenderer>();
			if (m_Spline == null)
			{
				DTLog.LogWarning($"[Curvy] CurvyLineRenderer in GameObject '{base.name}' had no assigned Spline.");
				m_Spline = GetComponent<CurvySpline>();
				if ((object)m_Spline != null)
				{
					DTLog.LogWarning($"[Curvy] Spline '{base.name}' was assigned to the CurvyLineRenderer by default.");
				}
			}
		}

		private void OnEnable()
		{
			mRenderer = GetComponent<LineRenderer>();
			BindEvents();
		}

		private void OnDisable()
		{
			UnbindEvents();
		}

		private void Start()
		{
			Refresh();
		}

		private void Update()
		{
			EnforceWorldSpaceUsage();
		}

		private void EnforceWorldSpaceUsage()
		{
			if (!mRenderer.useWorldSpace)
			{
				mRenderer.useWorldSpace = true;
			}
		}

		public void Refresh()
		{
			if ((bool)Spline && Spline.IsInitialized)
			{
				EnforceWorldSpaceUsage();
				Vector3[] approximation = Spline.GetApproximation(Space.World);
				mRenderer.positionCount = approximation.Length;
				mRenderer.SetPositions(approximation);
			}
			else if (mRenderer != null)
			{
				EnforceWorldSpaceUsage();
				mRenderer.positionCount = 0;
			}
		}

		private void OnSplineRefresh(CurvySplineEventArgs e)
		{
			Refresh();
		}

		private void OnSplineCoordinatesChanged(CurvySpline spline)
		{
			Refresh();
		}

		private void BindEvents()
		{
			if ((bool)Spline)
			{
				Spline.OnRefresh.AddListenerOnce(OnSplineRefresh);
				CurvySpline spline = Spline;
				spline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Combine(spline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnSplineCoordinatesChanged));
			}
		}

		private void UnbindEvents()
		{
			if ((bool)Spline)
			{
				Spline.OnRefresh.RemoveListener(OnSplineRefresh);
				CurvySpline spline = Spline;
				spline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Remove(spline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnSplineCoordinatesChanged));
			}
		}
	}
}
namespace FluffyUnderware.Curvy.Shapes
{
	[CurvyShapeInfo("2D/Circle", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Circle")]
	public class CSCircle : CurvyShape2D
	{
		[Positive(Tooltip = "Number of Control Points")]
		[SerializeField]
		private int m_Count = 4;

		[SerializeField]
		private float m_Radius = 1f;

		public int Count
		{
			get
			{
				return m_Count;
			}
			set
			{
				int num = Mathf.Max(2, value);
				if (m_Count != num)
				{
					m_Count = num;
					Dirty = true;
				}
			}
		}

		public float Radius
		{
			get
			{
				return m_Radius;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Radius != num)
				{
					m_Radius = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Count = 4;
			Radius = 1f;
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier);
			PrepareControlPoints(Count);
			float num = (float)Math.PI * 2f / (float)Count;
			for (int i = 0; i < Count; i++)
			{
				base.Spline.ControlPointsList[i].transform.localPosition = new Vector3(Mathf.Sin(num * (float)i) * Radius, Mathf.Cos(num * (float)i) * Radius, 0f);
			}
		}
	}
	[CurvyShapeInfo("2D/Pie", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Pie")]
	public class CSPie : CSCircle
	{
		public enum EatModeEnum
		{
			Left,
			Right,
			Center
		}

		[Range(0f, 1f)]
		[SerializeField]
		private float m_Roundness = 1f;

		[SerializeField]
		[RangeEx(0f, "maxEmpty", "Empty", "Number of empty slices")]
		private int m_Empty = 1;

		[Label(Tooltip = "Eat Mode")]
		[SerializeField]
		private EatModeEnum m_Eat = EatModeEnum.Right;

		public float Roundness
		{
			get
			{
				return m_Roundness;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_Roundness != num)
				{
					m_Roundness = num;
					Dirty = true;
				}
			}
		}

		public int Empty
		{
			get
			{
				return m_Empty;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, maxEmpty);
				if (m_Empty != num)
				{
					m_Empty = num;
					Dirty = true;
				}
			}
		}

		private int maxEmpty => base.Count;

		public EatModeEnum Eat
		{
			get
			{
				return m_Eat;
			}
			set
			{
				if (m_Eat != value)
				{
					m_Eat = value;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Roundness = 0.5f;
			Empty = 1;
			Eat = EatModeEnum.Right;
		}

		private Vector3 cpPosition(int i, int empty, float d)
		{
			return Eat switch
			{
				EatModeEnum.Left => new Vector3(Mathf.Sin(d * (float)i) * base.Radius, Mathf.Cos(d * (float)i) * base.Radius, 0f), 
				EatModeEnum.Right => new Vector3(Mathf.Sin(d * (float)(i + empty)) * base.Radius, Mathf.Cos(d * (float)(i + empty)) * base.Radius, 0f), 
				_ => new Vector3(Mathf.Sin(d * ((float)i + (float)empty * 0.5f)) * base.Radius, Mathf.Cos(d * ((float)i + (float)empty * 0.5f)) * base.Radius, 0f), 
			};
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier, CurvyOrientation.Static);
			PrepareControlPoints(base.Count - Empty + 2);
			float d = (float)Math.PI * 2f / (float)base.Count;
			float num = Roundness * 0.39f;
			for (int i = 0; i < base.Spline.ControlPointCount - 1; i++)
			{
				base.Spline.ControlPointsList[i].AutoHandles = true;
				base.Spline.ControlPointsList[i].AutoHandleDistance = num;
				SetPosition(i, cpPosition(i, Empty, d));
				SetRotation(i, Quaternion.Euler(90f, 0f, 0f));
			}
			SetPosition(base.Spline.ControlPointCount - 1, Vector3.zero);
			SetRotation(base.Spline.ControlPointCount - 1, Quaternion.Euler(90f, 0f, 0f));
			SetBezierHandles(base.Spline.ControlPointCount - 1, 0f);
			base.Spline.ControlPointsList[0].AutoHandles = false;
			base.Spline.ControlPointsList[0].HandleIn = Vector3.zero;
			base.Spline.ControlPointsList[0].SetBezierHandles(num, cpPosition(base.Count - 1, Empty, d) - base.Spline.ControlPointsList[0].transform.localPosition, cpPosition(1, Empty, d) - base.Spline.ControlPointsList[0].transform.localPosition, setIn: false);
			base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].AutoHandles = false;
			base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].HandleOut = Vector3.zero;
			base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].SetBezierHandles(num, cpPosition(base.Count - 1 - Empty, Empty, d) - base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].transform.localPosition, cpPosition(base.Count + 1 - Empty, Empty, d) - base.Spline.ControlPointsList[base.Spline.ControlPointCount - 2].transform.localPosition, setIn: true, setOut: false);
		}
	}
	[CurvyShapeInfo("2D/Rectangle", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Rectangle")]
	public class CSRectangle : CurvyShape2D
	{
		[Positive]
		[SerializeField]
		private float m_Width = 1f;

		[Positive]
		[SerializeField]
		private float m_Height = 1f;

		public float Width
		{
			get
			{
				return m_Width;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Width != num)
				{
					m_Width = num;
					Dirty = true;
				}
			}
		}

		public float Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Height != num)
				{
					m_Height = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Width = 1f;
			Height = 1f;
		}

		protected override void ApplyShape()
		{
			base.ApplyShape();
			PrepareSpline(CurvyInterpolation.Linear, CurvyOrientation.Static, 1);
			PrepareControlPoints(4);
			float num = Width / 2f;
			float num2 = Height / 2f;
			SetCGHardEdges();
			SetPosition(0, new Vector3(0f - num, 0f - num2));
			SetPosition(1, new Vector3(0f - num, num2));
			SetPosition(2, new Vector3(num, num2));
			SetPosition(3, new Vector3(num, 0f - num2));
		}
	}
	[CurvyShapeInfo("2D/Rounded Rectangle", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Rounded Rectangle")]
	public class CSRoundedRectangle : CurvyShape2D
	{
		[Positive]
		[SerializeField]
		private float m_Width = 1f;

		[Positive]
		[SerializeField]
		private float m_Height = 1f;

		[Range(0f, 1f)]
		[SerializeField]
		private float m_Roundness = 0.5f;

		public float Width
		{
			get
			{
				return m_Width;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Width != num)
				{
					m_Width = num;
					Dirty = true;
				}
			}
		}

		public float Height
		{
			get
			{
				return m_Height;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Height != num)
				{
					m_Height = num;
					Dirty = true;
				}
			}
		}

		public float Roundness
		{
			get
			{
				return m_Roundness;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_Roundness != num)
				{
					m_Roundness = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Width = 1f;
			Height = 1f;
			Roundness = 0.5f;
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier);
			bool flag = Roundness == 0f;
			PrepareControlPoints(flag ? 4 : 8);
			float num = Width / 2f;
			float num2 = Height / 2f;
			if (flag)
			{
				SetPosition(0, new Vector3(0f - num, 0f - num2));
				SetPosition(1, new Vector3(0f - num, num2));
				SetPosition(2, new Vector3(num, num2));
				SetPosition(3, new Vector3(num, 0f - num2));
				SetBezierHandles(0, Vector3.zero, Vector3.zero, Space.Self);
				SetBezierHandles(1, Vector3.zero, Vector3.zero, Space.Self);
				SetBezierHandles(2, Vector3.zero, Vector3.zero, Space.Self);
				SetBezierHandles(3, Vector3.zero, Vector3.zero, Space.Self);
				return;
			}
			float num3 = Mathf.Min(num, num2) * Roundness;
			SetPosition(0, new Vector3(0f - num, 0f - num2 + num3));
			SetPosition(1, new Vector3(0f - num, num2 - num3));
			SetPosition(2, new Vector3(0f - num + num3, num2));
			SetPosition(3, new Vector3(num - num3, num2));
			SetPosition(4, new Vector3(num, num2 - num3));
			SetPosition(5, new Vector3(num, 0f - num2 + num3));
			SetPosition(6, new Vector3(num - num3, 0f - num2));
			SetPosition(7, new Vector3(0f - num + num3, 0f - num2));
			SetBezierHandles(0, Vector3.down * num3, Vector3.zero, Space.Self);
			SetBezierHandles(1, Vector3.zero, Vector3.up * num3, Space.Self);
			SetBezierHandles(2, Vector3.left * num3, Vector3.right * num3, Space.Self);
			SetBezierHandles(3, Vector3.zero, Vector3.right * num3, Space.Self);
			SetBezierHandles(4, Vector3.up * num3, Vector3.zero, Space.Self);
			SetBezierHandles(5, Vector3.zero, Vector3.down * num3, Space.Self);
			SetBezierHandles(6, Vector3.right * num3, Vector3.zero, Space.Self);
			SetBezierHandles(7, Vector3.zero, Vector3.left * num3, Space.Self);
		}
	}
	[CurvyShapeInfo("3D/Spiral", false)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Spiral")]
	public class CSSpiral : CurvyShape2D
	{
		[Positive(Tooltip = "Number of Control Points per full Circle")]
		[SerializeField]
		private int m_Count = 8;

		[Positive(Tooltip = "Number of Full Circles")]
		[SerializeField]
		private float m_Circles = 3f;

		[Positive(Tooltip = "Base Radius")]
		[SerializeField]
		private float m_Radius = 5f;

		[Label(Tooltip = "Radius Multiplicator")]
		[SerializeField]
		private AnimationCurve m_RadiusFactor = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[SerializeField]
		private AnimationCurve m_Z = AnimationCurve.Linear(0f, 0f, 1f, 10f);

		public int Count
		{
			get
			{
				return m_Count;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_Count != num)
				{
					m_Count = num;
					Dirty = true;
				}
			}
		}

		public float Circles
		{
			get
			{
				return m_Circles;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Circles != num)
				{
					m_Circles = num;
					Dirty = true;
				}
			}
		}

		public float Radius
		{
			get
			{
				return m_Radius;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_Radius != num)
				{
					m_Radius = num;
					Dirty = true;
				}
			}
		}

		public AnimationCurve RadiusFactor
		{
			get
			{
				return m_RadiusFactor;
			}
			set
			{
				if (m_RadiusFactor != value)
				{
					m_RadiusFactor = value;
					Dirty = true;
				}
			}
		}

		public AnimationCurve Z
		{
			get
			{
				return m_Z;
			}
			set
			{
				if (m_Z != value)
				{
					m_Z = value;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Count = 8;
			Circles = 3f;
			Radius = 5f;
			RadiusFactor = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			Z = AnimationCurve.Linear(0f, 0f, 1f, 10f);
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.CatmullRom, CurvyOrientation.Dynamic, 50, closed: false);
			base.Spline.RestrictTo2D = false;
			int num = Mathf.FloorToInt((float)Count * Circles);
			PrepareControlPoints(num);
			if (num != 0)
			{
				float num2 = (float)Math.PI * 2f / (float)Count;
				for (int i = 0; i < num; i++)
				{
					float time = (float)i / (float)num;
					float num3 = Radius * RadiusFactor.Evaluate(time);
					SetPosition(i, new Vector3(Mathf.Sin(num2 * (float)i) * num3, Mathf.Cos(num2 * (float)i) * num3, m_Z.Evaluate(time)));
				}
			}
		}
	}
	[CurvyShapeInfo("2D/Star", true)]
	[RequireComponent(typeof(CurvySpline))]
	[AddComponentMenu("Curvy/Shape/Star")]
	public class CSStar : CurvyShape2D
	{
		[SerializeField]
		[Positive(Tooltip = "Number of Sides", MinValue = 2f)]
		private int m_Sides = 5;

		[SerializeField]
		[Positive]
		private float m_OuterRadius = 2f;

		[SerializeField]
		[RangeEx(0f, 1f, "", "")]
		private float m_OuterRoundness;

		[SerializeField]
		[Positive]
		private float m_InnerRadius = 1f;

		[SerializeField]
		[RangeEx(0f, 1f, "", "")]
		private float m_InnerRoundness;

		public int Sides
		{
			get
			{
				return m_Sides;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_Sides != num)
				{
					m_Sides = num;
					Dirty = true;
				}
			}
		}

		public float OuterRadius
		{
			get
			{
				return m_OuterRadius;
			}
			set
			{
				float num = Mathf.Max(InnerRadius, value);
				if (m_OuterRadius != num)
				{
					m_OuterRadius = num;
					Dirty = true;
				}
			}
		}

		public float OuterRoundness
		{
			get
			{
				return m_OuterRoundness;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_OuterRoundness != num)
				{
					m_OuterRoundness = num;
					Dirty = true;
				}
			}
		}

		public float InnerRadius
		{
			get
			{
				return m_InnerRadius;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_InnerRadius != num)
				{
					m_InnerRadius = num;
					Dirty = true;
				}
			}
		}

		public float InnerRoundness
		{
			get
			{
				return m_InnerRoundness;
			}
			set
			{
				float num = Mathf.Max(0f, value);
				if (m_InnerRoundness != num)
				{
					m_InnerRoundness = num;
					Dirty = true;
				}
			}
		}

		protected override void Reset()
		{
			base.Reset();
			Sides = 5;
			OuterRadius = 2f;
			OuterRoundness = 0f;
			InnerRadius = 1f;
			InnerRoundness = 0f;
		}

		protected override void ApplyShape()
		{
			PrepareSpline(CurvyInterpolation.Bezier);
			PrepareControlPoints(Sides * 2);
			float num = (float)Math.PI * 2f / (float)base.Spline.ControlPointCount;
			for (int i = 0; i < base.Spline.ControlPointCount; i += 2)
			{
				Vector3 vector = new Vector3(Mathf.Sin(num * (float)i), Mathf.Cos(num * (float)i), 0f);
				SetPosition(i, vector * OuterRadius);
				base.Spline.ControlPointsList[i].AutoHandleDistance = OuterRoundness;
				vector = new Vector3(Mathf.Sin(num * (float)(i + 1)), Mathf.Cos(num * (float)(i + 1)), 0f);
				SetPosition(i + 1, vector * InnerRadius);
				base.Spline.ControlPointsList[i + 1].AutoHandleDistance = InnerRoundness;
			}
		}
	}
}
namespace FluffyUnderware.Curvy.Utils
{
	public static class OptimizedOperators
	{
		public static Vector3 Addition(this Vector3 a, Vector3 b)
		{
			a.x += b.x;
			a.y += b.y;
			a.z += b.z;
			return a;
		}

		public static Vector3 UnaryNegation(this Vector3 a)
		{
			Vector3 result = default(Vector3);
			result.x = 0f - a.x;
			result.y = 0f - a.y;
			result.z = 0f - a.z;
			return result;
		}

		public static Vector3 Subtraction(this Vector3 a, Vector3 b)
		{
			a.x -= b.x;
			a.y -= b.y;
			a.z -= b.z;
			return a;
		}

		public static Vector3 Multiply(this Vector3 a, float d)
		{
			a.x *= d;
			a.y *= d;
			a.z *= d;
			return a;
		}

		public static Vector3 Multiply(this float d, Vector3 a)
		{
			a.x *= d;
			a.y *= d;
			a.z *= d;
			return a;
		}

		public static Vector3 Division(this Vector3 a, float d)
		{
			float num = 1f / d;
			a.x *= num;
			a.y *= num;
			a.z *= num;
			return a;
		}

		public static Vector3 Normalize(this Vector3 value)
		{
			float num = (float)Math.Sqrt((double)value.x * (double)value.x + (double)value.y * (double)value.y + (double)value.z * (double)value.z);
			Vector3 result = default(Vector3);
			if ((double)num > 9.99999974737875E-06)
			{
				float num2 = 1f / num;
				result.x = value.x * num2;
				result.y = value.y * num2;
				result.z = value.z * num2;
			}
			else
			{
				result.x = 0f;
				result.y = 0f;
				result.z = 0f;
			}
			return result;
		}

		public static Vector3 LerpUnclamped(this Vector3 a, Vector3 b, float t)
		{
			a.x += (b.x - a.x) * t;
			a.y += (b.y - a.y) * t;
			a.z += (b.z - a.z) * t;
			return a;
		}
	}
	public static class CurvyUtility
	{
		public static float ClampTF(float tf, CurvyClamping clamping)
		{
			return clamping switch
			{
				CurvyClamping.Loop => Mathf.Repeat(tf, 1f), 
				CurvyClamping.PingPong => Mathf.PingPong(tf, 1f), 
				CurvyClamping.Clamp => Mathf.Clamp01(tf), 
				_ => throw new InvalidEnumArgumentException(), 
			};
		}

		public static float ClampTF(float tf, ref int dir, CurvyClamping clamping)
		{
			switch (clamping)
			{
			case CurvyClamping.Loop:
				return Mathf.Repeat(tf, 1f);
			case CurvyClamping.PingPong:
				if (Mathf.FloorToInt(tf) % 2 != 0)
				{
					dir *= -1;
				}
				return Mathf.PingPong(tf, 1f);
			case CurvyClamping.Clamp:
				return Mathf.Clamp01(tf);
			default:
				throw new InvalidEnumArgumentException();
			}
		}

		public static float ClampValue(float tf, CurvyClamping clamping, float minTF, float maxTF)
		{
			switch (clamping)
			{
			case CurvyClamping.Loop:
			{
				float t2 = DTMath.MapValue(0f, 1f, tf, minTF, maxTF);
				return DTMath.MapValue(minTF, maxTF, Mathf.Repeat(t2, 1f), 0f);
			}
			case CurvyClamping.PingPong:
			{
				float t = DTMath.MapValue(0f, 1f, tf, minTF, maxTF);
				return DTMath.MapValue(minTF, maxTF, Mathf.PingPong(t, 1f), 0f);
			}
			case CurvyClamping.Clamp:
				return Mathf.Clamp(tf, minTF, maxTF);
			default:
				throw new InvalidEnumArgumentException();
			}
		}

		public static float ClampDistance(float distance, CurvyClamping clamping, float length)
		{
			if (length == 0f)
			{
				return 0f;
			}
			return clamping switch
			{
				CurvyClamping.Loop => Mathf.Repeat(distance, length), 
				CurvyClamping.PingPong => Mathf.PingPong(distance, length), 
				CurvyClamping.Clamp => Mathf.Clamp(distance, 0f, length), 
				_ => throw new InvalidEnumArgumentException(), 
			};
		}

		public static float ClampDistance(float distance, CurvyClamping clamping, float length, float min, float max)
		{
			if (length == 0f)
			{
				return 0f;
			}
			min = Mathf.Clamp(min, 0f, length);
			max = Mathf.Clamp(max, min, length);
			return clamping switch
			{
				CurvyClamping.Loop => min + Mathf.Repeat(distance, max - min), 
				CurvyClamping.PingPong => min + Mathf.PingPong(distance, max - min), 
				CurvyClamping.Clamp => Mathf.Clamp(distance, min, max), 
				_ => throw new InvalidEnumArgumentException(), 
			};
		}

		public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length)
		{
			if (length == 0f)
			{
				return 0f;
			}
			switch (clamping)
			{
			case CurvyClamping.Loop:
				return Mathf.Repeat(distance, length);
			case CurvyClamping.PingPong:
				if (Mathf.FloorToInt(distance / length) % 2 != 0)
				{
					dir *= -1;
				}
				return Mathf.PingPong(distance, length);
			case CurvyClamping.Clamp:
				return Mathf.Clamp(distance, 0f, length);
			default:
				throw new InvalidEnumArgumentException();
			}
		}

		public static float ClampDistance(float distance, ref int dir, CurvyClamping clamping, float length, float min, float max)
		{
			if (length == 0f)
			{
				return 0f;
			}
			min = Mathf.Clamp(min, 0f, length);
			max = Mathf.Clamp(max, min, length);
			switch (clamping)
			{
			case CurvyClamping.Loop:
				return min + Mathf.Repeat(distance, max - min);
			case CurvyClamping.PingPong:
				if (Mathf.FloorToInt(distance / (max - min)) % 2 != 0)
				{
					dir *= -1;
				}
				return min + Mathf.PingPong(distance, max - min);
			case CurvyClamping.Clamp:
				return Mathf.Clamp(distance, min, max);
			default:
				throw new InvalidEnumArgumentException();
			}
		}

		public static Material GetDefaultMaterial()
		{
			Material material = Resources.Load("CurvyDefaultMaterial") as Material;
			if (material == null)
			{
				material = new Material(Shader.Find("Diffuse"));
			}
			return material;
		}

		public static bool Approximately(this float x, float y)
		{
			float num = Mathf.Epsilon * 8f;
			float num2 = Math.Abs(x);
			float num3 = Math.Abs(y);
			if (num3 < num)
			{
				return num2 < 1E-06f;
			}
			if (num2 < num)
			{
				return num3 < 1E-06f;
			}
			return Mathf.Approximately(x, y);
		}

		public static int InterpolationSearch(float[] array, float x)
		{
			int num = 0;
			int i = array.Length - 1;
			while (num <= i && array[num] <= x && x <= array[i])
			{
				if (num == i)
				{
					if (array[num] != x)
					{
						break;
					}
					return num;
				}
				int num2 = num + (int)((float)(i - num) / (array[i] - array[num]) * (x - array[num]));
				if (array[num2] == x)
				{
					return num2;
				}
				if (array[num2] < x)
				{
					num = num2 + 1;
				}
				else
				{
					i = num2 - 1;
				}
			}
			if (num > i)
			{
				int num3 = i;
				i = num;
				num = num3;
			}
			if (x <= array[num])
			{
				while (num >= 0)
				{
					if (array[num] <= x)
					{
						return num;
					}
					num--;
				}
				return 0;
			}
			if (array[i] < x)
			{
				for (; i < array.Length; i++)
				{
					if (x < array[i])
					{
						return i - 1;
					}
				}
				return array.Length - 1;
			}
			return -1;
		}
	}
	public class Spline2Mesh
	{
		public List<SplinePolyLine> Lines = new List<SplinePolyLine>();

		public WindingRule Winding;

		public Vector2 UVTiling = Vector2.one;

		public Vector2 UVOffset = Vector2.zero;

		public bool SuppressUVMapping;

		public bool UV2;

		public string MeshName = string.Empty;

		public bool VertexLineOnly;

		private Tess mTess;

		private Mesh mMesh;

		public string Error { get; private set; }

		public bool Apply(out Mesh result)
		{
			mTess = null;
			mMesh = null;
			Error = string.Empty;
			bool flag = triangulate();
			if (flag)
			{
				mMesh = new Mesh();
				mMesh.name = MeshName;
				if (VertexLineOnly && Lines.Count > 0 && Lines[0] != null)
				{
					mMesh.vertices = Lines[0].GetVertices();
				}
				else
				{
					mMesh.vertices = UnityLibTessUtility.FromContourVertex(mTess.Vertices);
					mMesh.triangles = mTess.Elements;
				}
				mMesh.RecalculateBounds();
				mMesh.RecalculateNormals();
				if (!SuppressUVMapping && !VertexLineOnly)
				{
					Vector3 size = mMesh.bounds.size;
					Vector3 min = mMesh.bounds.min;
					float num = Mathf.Min(size.x, Mathf.Min(size.y, size.z));
					bool flag2 = num == size.x;
					bool flag3 = num == size.y;
					bool flag4 = num == size.z;
					Vector3[] vertices = mMesh.vertices;
					Vector2[] array = new Vector2[vertices.Length];
					float num2 = 0f;
					float num3 = 0f;
					for (int i = 0; i < vertices.Length; i++)
					{
						float num4;
						float num5;
						if (flag2)
						{
							num4 = UVOffset.x + (vertices[i].y - min.y) / size.y;
							num5 = UVOffset.y + (vertices[i].z - min.z) / size.z;
						}
						else if (flag3)
						{
							num4 = UVOffset.x + (vertices[i].z - min.z) / size.z;
							num5 = UVOffset.y + (vertices[i].x - min.x) / size.x;
						}
						else
						{
							if (!flag4)
							{
								throw new InvalidOperationException("Couldn't find the minimal bound dimension");
							}
							num4 = UVOffset.x + (vertices[i].x - min.x) / size.x;
							num5 = UVOffset.y + (vertices[i].y - min.y) / size.y;
						}
						num4 *= UVTiling.x;
						num5 *= UVTiling.y;
						num2 = ((num4 < num2) ? num2 : num4);
						num3 = ((num5 < num3) ? num3 : num5);
						array[i].x = num4;
						array[i].y = num5;
					}
					mMesh.uv = array;
					Vector2[] array2 = new Vector2[0];
					if (UV2)
					{
						array2 = new Vector2[array.Length];
						float num6 = 1f / num2;
						float num7 = 1f / num3;
						for (int j = 0; j < vertices.Length; j++)
						{
							array2[j].x = array[j].x * num6;
							array2[j].y = array[j].y * num7;
						}
					}
					mMesh.uv2 = array2;
				}
			}
			result = mMesh;
			return flag;
		}

		private bool triangulate()
		{
			if (Lines.Count == 0)
			{
				Error = "Missing splines to triangulate";
				return false;
			}
			if (VertexLineOnly)
			{
				return true;
			}
			mTess = new Tess();
			for (int i = 0; i < Lines.Count; i++)
			{
				if (Lines[i].Spline == null)
				{
					Error = "Missing Spline";
					return false;
				}
				if (!polyLineIsValid(Lines[i]))
				{
					Error = Lines[i].Spline.name + ": Angle must be >0";
					return false;
				}
				Vector3[] vertices = Lines[i].GetVertices();
				if (vertices.Length < 3)
				{
					Error = Lines[i].Spline.name + ": At least 3 Vertices needed!";
					return false;
				}
				mTess.AddContour(UnityLibTessUtility.ToContourVertex(vertices), Lines[i].Orientation);
			}
			try
			{
				mTess.Tessellate(Winding, ElementType.Polygons, 3);
				return true;
			}
			catch (Exception ex)
			{
				Error = ex.Message;
			}
			return false;
		}

		private static bool polyLineIsValid(SplinePolyLine pl)
		{
			if (pl == null || pl.VertexMode != 0)
			{
				return !Mathf.Approximately(0f, pl.Angle);
			}
			return true;
		}
	}
	[Serializable]
	public class SplinePolyLine
	{
		public enum VertexCalculation
		{
			ByApproximation,
			ByAngle
		}

		public ContourOrientation Orientation;

		public CurvySpline Spline;

		public VertexCalculation VertexMode;

		public float Angle;

		public float Distance;

		public Space Space;

		public bool IsClosed
		{
			get
			{
				if ((bool)Spline)
				{
					return Spline.Closed;
				}
				return false;
			}
		}

		public SplinePolyLine(CurvySpline spline)
			: this(spline, VertexCalculation.ByApproximation, 0f, 0f)
		{
		}

		public SplinePolyLine(CurvySpline spline, float angle, float distance)
			: this(spline, VertexCalculation.ByAngle, angle, distance)
		{
		}

		private SplinePolyLine(CurvySpline spline, VertexCalculation vertexMode, float angle, float distance, Space space = Space.World)
		{
			Spline = spline;
			VertexMode = vertexMode;
			Angle = angle;
			Distance = distance;
			Space = space;
		}

		public Vector3[] GetVertices()
		{
			Vector3[] array = new Vector3[0];
			VertexCalculation vertexMode = VertexMode;
			array = ((vertexMode != VertexCalculation.ByAngle) ? Spline.GetApproximation() : GetPolygon(Spline, 0f, 1f, Angle, Distance, -1f, out var _, out var _, includeEndPoint: false));
			if (Space == Space.World)
			{
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Spline.transform.TransformPoint(array[i]);
				}
			}
			return array;
		}

		private static Vector3[] GetPolygon(CurvySpline spline, float fromTF, float toTF, float maxAngle, float minDistance, float maxDistance, out List<float> vertexTF, out List<Vector3> vertexTangents, bool includeEndPoint = true, float stepSize = 0.01f)
		{
			stepSize = Mathf.Clamp(stepSize, 0.002f, 1f);
			maxDistance = ((maxDistance == -1f) ? spline.Length : Mathf.Clamp(maxDistance, 0f, spline.Length));
			minDistance = Mathf.Clamp(minDistance, 0f, maxDistance);
			if (!spline.Closed)
			{
				toTF = Mathf.Clamp01(toTF);
				fromTF = Mathf.Clamp(fromTF, 0f, toTF);
			}
			List<Vector3> vPos = new List<Vector3>();
			List<Vector3> vTan = new List<Vector3>();
			List<float> vTF = new List<float>();
			int linearSteps = 0;
			float angleFromLast = 0f;
			float distAccu = 0f;
			Vector3 curPos = spline.Interpolate(fromTF);
			Vector3 curTangent = spline.GetTangent(fromTF);
			Vector3 vector = curPos;
			Vector3 vector2 = curTangent;
			Action<float> action = delegate(float f)
			{
				vPos.Add(curPos);
				vTan.Add(curTangent);
				vTF.Add(f);
				angleFromLast = 0f;
				distAccu = 0f;
				linearSteps = 0;
			};
			action(fromTF);
			float num = fromTF + stepSize;
			while (num < toTF)
			{
				float num2 = num % 1f;
				spline.InterpolateAndGetTangent(num2, out curPos, out curTangent);
				if (curTangent == Vector3.zero)
				{
					UnityEngine.Debug.Log("zero Tangent! Oh no!");
				}
				distAccu += (curPos - vector).magnitude;
				if (curTangent == vector2)
				{
					linearSteps++;
				}
				if (distAccu >= minDistance)
				{
					if (distAccu >= maxDistance)
					{
						action(num2);
					}
					else
					{
						angleFromLast += Vector3.Angle(vector2, curTangent);
						if (angleFromLast >= maxAngle || (linearSteps > 0 && angleFromLast > 0f))
						{
							action(num2);
						}
					}
				}
				num += stepSize;
				vector = curPos;
				vector2 = curTangent;
			}
			if (includeEndPoint)
			{
				vTF.Add(toTF % 1f);
				spline.InterpolateAndGetTangent(toTF % 1f, out curPos, out var tangent);
				vPos.Add(curPos);
				vTan.Add(tangent);
			}
			vertexTF = vTF;
			vertexTangents = vTan;
			return vPos.ToArray();
		}
	}
}
namespace FluffyUnderware.Curvy.Generator
{
	public abstract class SplineInputModuleBase : CGModule
	{
		[Tab("General")]
		[SerializeField]
		[Tooltip("Makes this module use the cached approximations of the spline's positions and tangents")]
		private bool m_UseCache;

		[Tooltip("Whether to use local or global coordinates of the input's control points.\r\nUsing the global space when the input's transform is updating every frame will lead to the generator refreshing too frequently")]
		[SerializeField]
		private bool m_UseGlobalSpace;

		[Tab("Range")]
		[SerializeField]
		protected CurvySplineSegment m_StartCP;

		[FieldCondition("m_StartCP", null, true, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[SerializeField]
		protected CurvySplineSegment m_EndCP;

		public bool UseCache
		{
			get
			{
				return m_UseCache;
			}
			set
			{
				if (m_UseCache != value)
				{
					m_UseCache = value;
				}
				base.Dirty = true;
			}
		}

		public CurvySplineSegment StartCP
		{
			get
			{
				return m_StartCP;
			}
			set
			{
				if (m_StartCP != value)
				{
					m_StartCP = value;
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public CurvySplineSegment EndCP
		{
			get
			{
				return m_EndCP;
			}
			set
			{
				if (m_EndCP != value)
				{
					m_EndCP = value;
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public bool UseGlobalSpace
		{
			get
			{
				return m_UseGlobalSpace;
			}
			set
			{
				m_UseGlobalSpace = value;
				base.Dirty = true;
			}
		}

		public override bool IsConfigured
		{
			get
			{
				if (base.IsConfigured)
				{
					return InputSpline != null;
				}
				return false;
			}
		}

		public override bool IsInitialized
		{
			get
			{
				if (base.IsInitialized)
				{
					if (!(InputSpline == null))
					{
						return InputSpline.IsInitialized;
					}
					return true;
				}
				return false;
			}
		}

		public bool PathIsClosed
		{
			get
			{
				if (IsConfigured)
				{
					return getPathClosed(InputSpline);
				}
				return false;
			}
		}

		protected abstract CurvySpline InputSpline { get; set; }

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			OnSplineAssigned();
		}

		protected override void OnDisable()
		{
			base.OnDisable();
			if ((bool)InputSpline)
			{
				InputSpline.OnRefresh.RemoveListener(OnSplineRefreshed);
				CurvySpline inputSpline = InputSpline;
				inputSpline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Remove(inputSpline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnInputSplineCoordinatesChanged));
			}
		}

		public override void Reset()
		{
			base.Reset();
			InputSpline = null;
			UseCache = false;
			StartCP = null;
			EndCP = null;
			UseGlobalSpace = false;
		}

		private void OnSplineRefreshed(CurvySplineEventArgs e)
		{
			if (base.enabled && base.gameObject.activeInHierarchy)
			{
				if (InputSpline == e.Spline)
				{
					ForceRefresh();
				}
				else
				{
					e.Spline.OnRefresh.RemoveListener(OnSplineRefreshed);
				}
			}
		}

		private void OnInputSplineCoordinatesChanged(CurvySpline sender)
		{
			if (!base.enabled || !base.gameObject.activeInHierarchy)
			{
				return;
			}
			if (InputSpline == sender)
			{
				if (UseGlobalSpace)
				{
					ForceRefresh();
				}
			}
			else
			{
				CurvySpline inputSpline = InputSpline;
				inputSpline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Remove(inputSpline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnInputSplineCoordinatesChanged));
			}
		}

		private void ForceRefresh()
		{
			base.Dirty = true;
		}

		private float getPathLength(CurvySpline spline)
		{
			if (!spline)
			{
				return 0f;
			}
			if ((bool)StartCP && (bool)EndCP)
			{
				return EndCP.Distance - StartCP.Distance;
			}
			return spline.Length;
		}

		private bool getPathClosed(CurvySpline spline)
		{
			if (!spline || !spline.Closed)
			{
				return false;
			}
			return EndCP == null;
		}

		protected CGData GetSplineData(CurvySpline spline, bool fullPath, CGDataRequestRasterization raster, CGDataRequestMetaCGOptions options)
		{
			if (spline == null || spline.Count == 0)
			{
				return null;
			}
			List<ControlPointOption> list = new List<ControlPointOption>();
			int initialMaterialID = 0;
			float initialMaxStep = float.MaxValue;
			CGShape cGShape = (fullPath ? new CGPath() : new CGShape());
			float pathLength = getPathLength(spline);
			float num;
			float num2;
			if ((bool)StartCP)
			{
				num = StartCP.Distance + pathLength * raster.Start;
				num2 = StartCP.Distance + pathLength * (raster.Start + raster.RasterizedRelativeLength);
			}
			else
			{
				num = spline.Length * raster.Start;
				num2 = spline.Length * (raster.Start + raster.RasterizedRelativeLength);
			}
			float num3 = CurvySpline.CalculateSamplingPointsPerUnit(raster.Resolution, spline.MaxPointsPerUnit);
			float num4 = num2 - num;
			float num5 = Mathf.Min(num4 / (pathLength * raster.RasterizedRelativeLength * num3), num4 / 3f);
			cGShape.Length = num2 - num;
			float tf = spline.DistanceToTF(num);
			float startTF = tf;
			float num6 = ((num2 > spline.Length && spline.Closed) ? (spline.DistanceToTF(num2 - spline.Length) + 1f) : spline.DistanceToTF(num2));
			cGShape.SourceIsManaged = IsManagedResource(spline);
			cGShape.Closed = spline.Closed;
			cGShape.Seamless = spline.Closed && raster.RasterizedRelativeLength == 1f;
			if (cGShape.Length == 0f)
			{
				return cGShape;
			}
			if ((bool)options)
			{
				list = CGUtility.GetControlPointsWithOptions(options, spline, num, num2, raster.Mode == CGDataRequestRasterization.ModeEnum.Optimized, out initialMaterialID, out initialMaxStep);
			}
			List<SamplePointUData> list2 = new List<SamplePointUData>();
			List<Vector3> list3 = new List<Vector3>();
			List<float> list4 = new List<float>();
			List<float> list5 = new List<float>();
			List<Vector3> list6 = new List<Vector3>();
			List<Vector3> list7 = new List<Vector3>();
			float num7 = num;
			Vector3 tangent = Vector3.zero;
			Vector3 up = Vector3.zero;
			List<int> list8 = new List<int>();
			int num8 = 100000;
			Vector3 position;
			switch (raster.Mode)
			{
			case CGDataRequestRasterization.ModeEnum.Even:
			{
				bool flag = false;
				SamplePointsMaterialGroup samplePointsMaterialGroup = new SamplePointsMaterialGroup(initialMaterialID);
				SamplePointsPatch item = new SamplePointsPatch(0);
				CurvyClamping clamping = (cGShape.Closed ? CurvyClamping.Loop : CurvyClamping.Clamp);
				while (num7 <= num2 && --num8 > 0)
				{
					tf = spline.DistanceToTF(spline.ClampDistance(num7, clamping));
					float num9 = (num7 - num) / cGShape.Length;
					if (Mathf.Approximately(1f, num9))
					{
						num9 = 1f;
					}
					float localF;
					CurvySplineSegment curvySplineSegment = spline.TFToSegment(tf, out localF, CurvyClamping.Clamp);
					if (fullPath)
					{
						if (UseCache)
						{
							curvySplineSegment.InterpolateAndGetTangentFast(localF, out position, out tangent);
						}
						else
						{
							curvySplineSegment.InterpolateAndGetTangent(localF, out position, out tangent);
						}
						up = curvySplineSegment.GetOrientationUpFast(localF);
					}
					else
					{
						position = (UseCache ? curvySplineSegment.InterpolateFast(localF) : curvySplineSegment.Interpolate(localF));
					}
					AddPoint(num7 / spline.Length, num9, fullPath, position, tangent, up, list5, list4, list3, list6, list7);
					if (flag)
					{
						AddPoint(num7 / spline.Length, num9, fullPath, position, tangent, up, list5, list4, list3, list6, list7);
						flag = false;
					}
					num7 += num5;
					if (list.Count > 0 && num7 >= list[0].Distance)
					{
						if (list[0].UVEdge || list[0].UVShift)
						{
							list2.Add(new SamplePointUData(list3.Count, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
						}
						num7 = list[0].Distance;
						flag = list[0].HardEdge || list[0].MaterialID != samplePointsMaterialGroup.MaterialID || (options.CheckExtendedUV && list[0].UVEdge);
						if (flag)
						{
							item.End = list3.Count;
							samplePointsMaterialGroup.Patches.Add(item);
							if (samplePointsMaterialGroup.MaterialID != list[0].MaterialID)
							{
								cGShape.MaterialGroups.Add(samplePointsMaterialGroup);
								samplePointsMaterialGroup = new SamplePointsMaterialGroup(list[0].MaterialID);
							}
							item = new SamplePointsPatch(list3.Count + 1);
							if (!list[0].HardEdge)
							{
								list8.Add(list3.Count + 1);
							}
							if (list[0].UVEdge || list[0].UVShift)
							{
								list2.Add(new SamplePointUData(list3.Count + 1, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
							}
						}
						list.RemoveAt(0);
					}
					if (num7 > num2 && num9 < 1f)
					{
						num7 = num2;
					}
				}
				if (num8 <= 0)
				{
					UnityEngine.Debug.LogError("[Curvy] He's dead, Jim! Deadloop in SplineInputModuleBase.GetSplineData (Even)! Please send a bug report.");
				}
				item.End = list3.Count - 1;
				samplePointsMaterialGroup.Patches.Add(item);
				if (cGShape.Closed && !spline[0].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge)
				{
					list8.Add(0);
				}
				FillData(cGShape, samplePointsMaterialGroup, list5, list4, fullPath, list3, list6, list7, UseGlobalSpace, spline.transform, base.Generator.transform);
				break;
			}
			case CGDataRequestRasterization.ModeEnum.Optimized:
			{
				bool flag = false;
				SamplePointsMaterialGroup samplePointsMaterialGroup = new SamplePointsMaterialGroup(initialMaterialID);
				SamplePointsPatch item = new SamplePointsPatch(0);
				float stepDist = num5 / spline.Length;
				float angleThreshold = raster.AngleThreshold;
				if (UseCache)
				{
					spline.InterpolateAndGetTangentFast(tf, out position, out tangent);
				}
				else
				{
					spline.InterpolateAndGetTangent(tf, out position, out tangent);
				}
				while (tf < num6 && num8-- > 0)
				{
					AddPoint(num7 / spline.Length, (num7 - num) / cGShape.Length, fullPath, position, tangent, spline.GetOrientationUpFast(tf % 1f), list5, list4, list3, list6, list7);
					float stopTF = ((list.Count > 0) ? list[0].TF : num6);
					bool flag2 = MoveByAngleExt(spline, UseCache, ref tf, initialMaxStep, angleThreshold, out position, out tangent, stopTF, cGShape.Closed, stepDist);
					num7 = spline.TFToDistance(tf);
					if (Mathf.Approximately(tf, num6) || tf > num6)
					{
						num7 = num2;
						num6 = (cGShape.Closed ? DTMath.Repeat(num6, 1f) : Mathf.Clamp01(num6));
						if (fullPath)
						{
							if (UseCache)
							{
								spline.InterpolateAndGetTangentFast(num6, out position, out tangent);
							}
							else
							{
								spline.InterpolateAndGetTangent(num6, out position, out tangent);
							}
						}
						else
						{
							position = (UseCache ? spline.InterpolateFast(num6) : spline.Interpolate(num6));
						}
						AddPoint(num7 / spline.Length, (num7 - num) / cGShape.Length, fullPath, position, tangent, spline.GetOrientationUpFast(num6), list5, list4, list3, list6, list7);
						break;
					}
					if (!flag2)
					{
						continue;
					}
					if (list.Count > 0)
					{
						if (list[0].UVEdge || list[0].UVShift)
						{
							list2.Add(new SamplePointUData(list3.Count, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
						}
						num7 = list[0].Distance;
						initialMaxStep = list[0].MaxStepDistance;
						if (list[0].HardEdge || list[0].MaterialID != samplePointsMaterialGroup.MaterialID || (options.CheckExtendedUV && list[0].UVEdge))
						{
							item.End = list3.Count;
							samplePointsMaterialGroup.Patches.Add(item);
							if (samplePointsMaterialGroup.MaterialID != list[0].MaterialID)
							{
								cGShape.MaterialGroups.Add(samplePointsMaterialGroup);
								samplePointsMaterialGroup = new SamplePointsMaterialGroup(list[0].MaterialID);
							}
							item = new SamplePointsPatch(list3.Count + 1);
							if (!list[0].HardEdge)
							{
								list8.Add(list3.Count + 1);
							}
							if (list[0].UVEdge || list[0].UVShift)
							{
								list2.Add(new SamplePointUData(list3.Count + 1, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
							}
							AddPoint(num7 / spline.Length, (num7 - num) / cGShape.Length, fullPath, position, tangent, spline.GetOrientationUpFast(tf), list5, list4, list3, list6, list7);
						}
						list.RemoveAt(0);
						continue;
					}
					AddPoint(num7 / spline.Length, (num7 - num) / cGShape.Length, fullPath, position, tangent, spline.GetOrientationUpFast(tf), list5, list4, list3, list6, list7);
					break;
				}
				if (num8 <= 0)
				{
					UnityEngine.Debug.LogError("[Curvy] He's dead, Jim! Deadloop in SplineInputModuleBase.GetSplineData (Optimized)! Please send a bug report.");
				}
				item.End = list3.Count - 1;
				samplePointsMaterialGroup.Patches.Add(item);
				if (list.Count > 0 && list[0].UVShift)
				{
					list2.Add(new SamplePointUData(list3.Count - 1, list[0].UVEdge, list[0].FirstU, list[0].SecondU));
				}
				if (cGShape.Closed && !spline[0].GetMetadata<MetaCGOptions>(autoCreate: true).HardEdge)
				{
					list8.Add(0);
				}
				FillData(cGShape, samplePointsMaterialGroup, list5, list4, fullPath, list3, list6, list7, UseGlobalSpace, spline.transform, base.Generator.transform);
				break;
			}
			}
			cGShape.Map = (float[])cGShape.F.Clone();
			if (!fullPath)
			{
				cGShape.RecalculateNormals(list8);
				if ((bool)options && options.CheckExtendedUV)
				{
					CalculateExtendedUV(spline, startTF, num6, list2, cGShape);
				}
			}
			return cGShape;
		}

		private static void FillData(CGShape dataToFill, SamplePointsMaterialGroup materialGroup, List<float> sourceFs, List<float> relativeFs, bool isFullPath, List<Vector3> positions, List<Vector3> tangents, List<Vector3> normals, bool considerSplineTransform, Transform splineTransform, Transform generatorTransform)
		{
			if (considerSplineTransform)
			{
				for (int i = 0; i < positions.Count; i++)
				{
					positions[i] = generatorTransform.InverseTransformPoint(splineTransform.TransformPoint(positions[i]));
				}
				for (int j = 0; j < tangents.Count; j++)
				{
					tangents[j] = generatorTransform.InverseTransformDirection(splineTransform.TransformDirection(tangents[j]));
				}
				for (int k = 0; k < normals.Count; k++)
				{
					normals[k] = generatorTransform.InverseTransformDirection(splineTransform.TransformDirection(normals[k]));
				}
			}
			dataToFill.MaterialGroups.Add(materialGroup);
			dataToFill.SourceF = sourceFs.ToArray();
			dataToFill.F = relativeFs.ToArray();
			dataToFill.Position = positions.ToArray();
			if (isFullPath)
			{
				((CGPath)dataToFill).Direction = tangents.ToArray();
				dataToFill.Normal = normals.ToArray();
			}
		}

		private static void AddPoint(float sourceF, float relativeF, bool isFullPath, Vector3 position, Vector3 tangent, Vector3 up, List<float> sourceFList, List<float> relativeFList, List<Vector3> positionList, List<Vector3> tangentList, List<Vector3> upList)
		{
			sourceFList.Add(sourceF);
			positionList.Add(position);
			relativeFList.Add(relativeF);
			if (isFullPath)
			{
				tangentList.Add(tangent);
				upList.Add(up);
			}
		}

		private static bool MoveByAngleExt(CurvySpline spline, bool useCache, ref float tf, float maxDistance, float maxAngle, out Vector3 pos, out Vector3 tan, float stopTF, bool loop, float stepDist)
		{
			if (!loop)
			{
				tf = Mathf.Clamp01(tf);
			}
			float tf2 = (loop ? (tf % 1f) : tf);
			CurvySplineSegment curvySplineSegment = spline.TFToSegment(tf2, out var localF, CurvyClamping.Clamp);
			if (useCache)
			{
				curvySplineSegment.InterpolateAndGetTangentFast(localF, out pos, out tan);
			}
			else
			{
				curvySplineSegment.InterpolateAndGetTangent(localF, out pos, out tan);
			}
			Vector3 vector = pos;
			Vector3 from = tan;
			float num = 0f;
			float num2 = 0f;
			if (stopTF < tf && loop)
			{
				stopTF += 1f;
			}
			bool flag = false;
			Vector3 vector2 = default(Vector3);
			while (tf < stopTF && !flag)
			{
				tf = Mathf.Min(stopTF, tf + stepDist);
				tf2 = (loop ? (tf % 1f) : tf);
				curvySplineSegment = spline.TFToSegment(tf2, out localF, CurvyClamping.Clamp);
				if (useCache)
				{
					curvySplineSegment.InterpolateAndGetTangentFast(localF, out pos, out tan);
				}
				else
				{
					curvySplineSegment.InterpolateAndGetTangent(localF, out pos, out tan);
				}
				vector2.x = pos.x - vector.x;
				vector2.y = pos.y - vector.y;
				vector2.z = pos.z - vector.z;
				num += vector2.magnitude;
				float num3 = Vector3.Angle(from, tan);
				num2 += num3;
				if (num >= maxDistance || num2 >= maxAngle || (num3 == 0f && num2 > 0f))
				{
					flag = true;
					continue;
				}
				vector = pos;
				from = tan;
			}
			return Mathf.Approximately(tf, stopTF);
		}

		private static void CalculateExtendedUV(CurvySpline spline, float startTF, float endTF, List<SamplePointUData> ext, CGShape data)
		{
			MetaCGOptions metaCGOptions = findPreviousReferenceCPOptions(spline, startTF, out var cp);
			MetaCGOptions metaCGOptions2 = findNextReferenceCPOptions(spline, startTF, out var cp2);
			ext.Insert(0, new SamplePointUData(uv0: ((!(spline.FirstVisibleControlPoint == cp2)) ? ((data.SourceF[0] * spline.Length - cp.Distance) / (cp2.Distance - cp.Distance)) : ((data.SourceF[0] * spline.Length - cp.Distance) / (spline.Length - cp.Distance))) * (metaCGOptions2.FirstU - metaCGOptions.GetDefinedFirstU(0f)) + metaCGOptions.GetDefinedFirstU(0f), vt: 0, uvEdge: startTF == 0f && metaCGOptions.UVEdge, uv1: (startTF == 0f && metaCGOptions.UVEdge) ? metaCGOptions.SecondU : 0f));
			if (ext[ext.Count - 1].Vertex < data.Count - 1)
			{
				metaCGOptions = findPreviousReferenceCPOptions(spline, endTF, out cp);
				metaCGOptions2 = findNextReferenceCPOptions(spline, endTF, out cp2);
				float num = metaCGOptions2.FirstU;
				float definedSecondU = metaCGOptions.GetDefinedSecondU(0f);
				float num2;
				if (spline.FirstVisibleControlPoint == cp2)
				{
					num2 = (data.SourceF[data.Count - 1] * spline.Length - cp.Distance) / (spline.Length - cp.Distance);
					num = (metaCGOptions2.UVEdge ? metaCGOptions2.FirstU : ((ext.Count <= 1) ? 1f : ((float)(Mathf.FloorToInt(ext[ext.Count - 1].UVEdge ? ext[ext.Count - 1].SecondU : ext[ext.Count - 1].FirstU) + 1))));
				}
				else
				{
					num2 = (data.SourceF[data.Count - 1] * spline.Length - cp.Distance) / (cp2.Distance - cp.Distance);
				}
				ext.Add(new SamplePointUData(data.Count - 1, uvEdge: false, num2 * (num - definedSecondU) + definedSecondU, 0f));
			}
			float num3 = 0f;
			float num4 = (ext[0].UVEdge ? ext[0].SecondU : ext[0].FirstU);
			float firstU = ext[1].FirstU;
			float num5 = data.F[ext[1].Vertex] - data.F[ext[0].Vertex];
			int num6 = 1;
			for (int i = 0; i < data.Count - 1; i++)
			{
				float num7 = (data.F[i] - num3) / num5;
				data.Map[i] = (firstU - num4) * num7 + num4;
				if (ext[num6].Vertex == i)
				{
					if (ext[num6].FirstU == ext[num6 + 1].FirstU)
					{
						num4 = (ext[num6].UVEdge ? ext[num6].SecondU : ext[num6].FirstU);
						num6++;
					}
					else
					{
						num4 = ext[num6].FirstU;
					}
					firstU = ext[num6 + 1].FirstU;
					num5 = data.F[ext[num6 + 1].Vertex] - data.F[ext[num6].Vertex];
					num3 = data.F[i];
					num6++;
				}
			}
			data.Map[data.Count - 1] = ext[ext.Count - 1].FirstU;
		}

		private static MetaCGOptions findPreviousReferenceCPOptions(CurvySpline spline, float tf, out CurvySplineSegment cp)
		{
			cp = spline.TFToSegment(tf);
			MetaCGOptions metadata;
			do
			{
				metadata = cp.GetMetadata<MetaCGOptions>(autoCreate: true);
				if (spline.FirstVisibleControlPoint == cp)
				{
					return metadata;
				}
				cp = spline.GetPreviousSegment(cp);
			}
			while ((bool)cp && !metadata.UVEdge && !metadata.ExplicitU && !metadata.HasDifferentMaterial);
			return metadata;
		}

		private static MetaCGOptions findNextReferenceCPOptions(CurvySpline spline, float tf, out CurvySplineSegment cp)
		{
			cp = spline.TFToSegment(tf, out var _);
			MetaCGOptions metadata;
			do
			{
				cp = spline.GetNextControlPoint(cp);
				metadata = cp.GetMetadata<MetaCGOptions>(autoCreate: true);
				if (!spline.Closed && spline.LastVisibleControlPoint == cp)
				{
					return metadata;
				}
			}
			while (!metadata.UVEdge && !metadata.ExplicitU && !metadata.HasDifferentMaterial && !(spline.FirstSegment == cp));
			return metadata;
		}

		protected virtual void OnSplineAssigned()
		{
			if ((bool)InputSpline)
			{
				InputSpline.OnRefresh.AddListenerOnce(OnSplineRefreshed);
				CurvySpline inputSpline = InputSpline;
				inputSpline.OnGlobalCoordinatesChanged = (Action<CurvySpline>)Delegate.Combine(inputSpline.OnGlobalCoordinatesChanged, new Action<CurvySpline>(OnInputSplineCoordinatesChanged));
			}
		}

		protected void ValidateStartAndEndCps()
		{
			if (!(InputSpline == null))
			{
				if ((bool)m_StartCP && m_StartCP.Spline != InputSpline)
				{
					m_StartCP = null;
				}
				if ((bool)m_EndCP && m_EndCP.Spline != InputSpline)
				{
					m_EndCP = null;
				}
				if (InputSpline.IsInitialized && m_EndCP != null && m_StartCP != null && InputSpline.GetControlPointIndex(m_EndCP) <= InputSpline.GetControlPointIndex(m_StartCP))
				{
					m_EndCP = null;
				}
			}
		}
	}
	public abstract class TRSModuleBase : CGModule
	{
		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Transpose;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Rotation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Scale = Vector3.one;

		public Vector3 Transpose
		{
			get
			{
				return m_Transpose;
			}
			set
			{
				if (m_Transpose != value)
				{
					m_Transpose = value;
				}
				base.Dirty = true;
			}
		}

		public Vector3 Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
				base.Dirty = true;
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
				base.Dirty = true;
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(Transpose, Quaternion.Euler(Rotation), Scale);

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			Transpose = Vector3.zero;
			Rotation = Vector3.zero;
			Scale = Vector3.one;
		}
	}
	[Serializable]
	public class CGBoundsGroup : CGWeightedItem
	{
		public enum RotationModeEnum
		{
			Full,
			Direction,
			Horizontal,
			Independent
		}

		[Obsolete("Enum no more used by Curvy. This enum is kept for retro compatibility reasons")]
		private enum DistributionModeEnum
		{
			Parent,
			Self
		}

		[SerializeField]
		private string m_Name;

		[SerializeField]
		[Tooltip("When checked, the group will only be placed when all items can be placed in the space left")]
		private bool m_KeepTogether;

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_SpaceBefore = new FloatRegion
		{
			SimpleValue = true
		};

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_SpaceAfter = new FloatRegion
		{
			SimpleValue = true
		};

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, RegionOptionsPropertyName = "PositionRangeOptions", UseSlider = true, Precision = 3)]
		private FloatRegion m_CrossBase = new FloatRegion(0f);

		[SerializeField]
		[Tooltip("If ticked, the Cross origin for this group will not take into consideration the Cross parameters in the General tab")]
		private bool m_IgnoreModuleCrossBase;

		[SerializeField]
		[Tooltip("When enabled, items will be selected randomly")]
		private bool m_RandomizeItems;

		[IntRegion(UseSlider = false, RegionOptionsPropertyName = "RepeatingGroupsOptions", Options = AttributeOptionsFlags.Compact)]
		[SerializeField]
		[Tooltip("The randomized items are the the ones that have their indices inside this range")]
		private IntRegion m_RepeatingItems;

		[SerializeField]
		[Tooltip("If unchecked, translation will be done in the global/world space")]
		private bool m_RelativeTranslation = true;

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_TranslationX = new FloatRegion(0f);

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_TranslationY = new FloatRegion(0f);

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_TranslationZ = new FloatRegion(0f);

		[SerializeField]
		[Tooltip("How the rotation axes are defined related to the Volume's data\r\n  - Full : Use Volume's direction and orientation\r\n  - Direction : Use Volume's direction only\r\n  - Horizontal : Use Volume's direction only after projecting it on XZ plane\r\n  - Independent : Do not use Volume's data")]
		private RotationModeEnum m_RotationMode;

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_RotationX = new FloatRegion(0f);

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_RotationY = new FloatRegion(0f);

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_RotationZ = new FloatRegion(0f);

		[SerializeField]
		[Tooltip("Whether the scaling is applied equally on all dimensions")]
		private bool m_UniformScaling = true;

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_ScaleX = new FloatRegion(1f);

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_ScaleY = new FloatRegion(1f);

		[SerializeField]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_ScaleZ = new FloatRegion(1f);

		[SerializeField]
		private List<CGBoundsGroupItem> m_Items = new List<CGBoundsGroupItem>();

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use IgnoreModuleCrossBase instead. This field is kept for retro compatibility reasons")]
		private DistributionModeEnum m_DistributionMode;

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use CrossBase instead. This field is kept for retro compatibility reasons")]
		[FloatRegion(RegionIsOptional = true, RegionOptionsPropertyName = "PositionRangeOptions", UseSlider = true, Precision = 3)]
		private FloatRegion m_PositionOffset = new FloatRegion(0f);

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use TranslationY instead, while setting RelativeTranslation to true. This field is kept for retro compatibility reasons")]
		[FloatRegion(RegionIsOptional = true, Options = AttributeOptionsFlags.Compact)]
		private FloatRegion m_Height = new FloatRegion(0f);

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use RandomizeItems instead. This field is kept for retro compatibility reasons")]
		private CurvyRepeatingOrderEnum m_RepeatingOrder = CurvyRepeatingOrderEnum.Row;

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use RotationX, RotationY and RotationZ instead. This field is kept for retro compatibility reasons")]
		[VectorEx("", "")]
		private Vector3 m_RotationOffset;

		[SerializeField]
		[HideInInspector]
		[Obsolete("Use RotationX, RotationY and RotationZ instead. This field is kept for retro compatibility reasons")]
		[VectorEx("", "")]
		private Vector3 m_RotationScatter;

		public string Name
		{
			get
			{
				return m_Name;
			}
			set
			{
				if (m_Name != value)
				{
					m_Name = value;
				}
			}
		}

		public bool KeepTogether
		{
			get
			{
				return m_KeepTogether;
			}
			set
			{
				if (m_KeepTogether != value)
				{
					m_KeepTogether = value;
				}
			}
		}

		public FloatRegion SpaceBefore
		{
			get
			{
				return m_SpaceBefore;
			}
			set
			{
				if (m_SpaceBefore != value)
				{
					m_SpaceBefore = value;
				}
			}
		}

		public FloatRegion SpaceAfter
		{
			get
			{
				return m_SpaceAfter;
			}
			set
			{
				if (m_SpaceAfter != value)
				{
					m_SpaceAfter = value;
				}
			}
		}

		public bool RandomizeItems
		{
			get
			{
				return m_RandomizeItems;
			}
			set
			{
				if (m_RandomizeItems != value)
				{
					m_RandomizeItems = value;
				}
			}
		}

		public IntRegion RepeatingItems
		{
			get
			{
				return m_RepeatingItems;
			}
			set
			{
				if (m_RepeatingItems != value)
				{
					m_RepeatingItems = value;
				}
			}
		}

		public FloatRegion CrossBase
		{
			get
			{
				return m_CrossBase;
			}
			set
			{
				if (m_CrossBase != value)
				{
					m_CrossBase = value;
				}
			}
		}

		public bool IgnoreModuleCrossBase
		{
			get
			{
				return m_IgnoreModuleCrossBase;
			}
			set
			{
				if (m_IgnoreModuleCrossBase != value)
				{
					m_IgnoreModuleCrossBase = value;
				}
			}
		}

		public RotationModeEnum RotationMode
		{
			get
			{
				return m_RotationMode;
			}
			set
			{
				if (m_RotationMode != value)
				{
					m_RotationMode = value;
				}
			}
		}

		public FloatRegion RotationX
		{
			get
			{
				return m_RotationX;
			}
			set
			{
				if (m_RotationX != value)
				{
					m_RotationX = value;
				}
			}
		}

		public FloatRegion RotationY
		{
			get
			{
				return m_RotationY;
			}
			set
			{
				if (m_RotationY != value)
				{
					m_RotationY = value;
				}
			}
		}

		public FloatRegion RotationZ
		{
			get
			{
				return m_RotationZ;
			}
			set
			{
				if (m_RotationZ != value)
				{
					m_RotationZ = value;
				}
			}
		}

		public bool UniformScaling
		{
			get
			{
				return m_UniformScaling;
			}
			set
			{
				if (m_UniformScaling != value)
				{
					m_UniformScaling = value;
				}
			}
		}

		public FloatRegion ScaleX
		{
			get
			{
				return m_ScaleX;
			}
			set
			{
				if (m_ScaleX != value)
				{
					m_ScaleX = value;
				}
			}
		}

		public FloatRegion ScaleY
		{
			get
			{
				return m_ScaleY;
			}
			set
			{
				if (m_ScaleY != value)
				{
					m_ScaleY = value;
				}
			}
		}

		public FloatRegion ScaleZ
		{
			get
			{
				return m_ScaleZ;
			}
			set
			{
				if (m_ScaleZ != value)
				{
					m_ScaleZ = value;
				}
			}
		}

		public bool RelativeTranslation
		{
			get
			{
				return m_RelativeTranslation;
			}
			set
			{
				if (m_RelativeTranslation != value)
				{
					m_RelativeTranslation = value;
				}
			}
		}

		public FloatRegion TranslationX
		{
			get
			{
				return m_TranslationX;
			}
			set
			{
				if (m_TranslationX != value)
				{
					m_TranslationX = value;
				}
			}
		}

		public FloatRegion TranslationY
		{
			get
			{
				return m_TranslationY;
			}
			set
			{
				if (m_TranslationY != value)
				{
					m_TranslationY = value;
				}
			}
		}

		public FloatRegion TranslationZ
		{
			get
			{
				return m_TranslationZ;
			}
			set
			{
				if (m_TranslationZ != value)
				{
					m_TranslationZ = value;
				}
			}
		}

		public List<CGBoundsGroupItem> Items => m_Items;

		public int FirstRepeating
		{
			get
			{
				return m_RepeatingItems.From;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, Mathf.Max(0, ItemCount - 1));
				if (m_RepeatingItems.From != num)
				{
					m_RepeatingItems.From = num;
				}
			}
		}

		public int LastRepeating
		{
			get
			{
				return m_RepeatingItems.To;
			}
			set
			{
				int num = Mathf.Clamp(value, FirstRepeating, Mathf.Max(0, ItemCount - 1));
				if (m_RepeatingItems.To != num)
				{
					m_RepeatingItems.To = num;
				}
			}
		}

		public int ItemCount => Items.Count;

		private RegionOptions<int> RepeatingGroupsOptions => RegionOptions<int>.MinMax(0, Mathf.Max(0, ItemCount - 1));

		private RegionOptions<float> PositionRangeOptions => RegionOptions<float>.MinMax(-1f, 1f);

		public CGBoundsGroup(string name)
		{
			Name = name;
		}

		public static void FillItemBag(WeightedRandom<int> bag, IEnumerable<CGWeightedItem> itemsWeights, int firstItem, int lastItem)
		{
			for (int i = firstItem; i <= lastItem; i++)
			{
				bag.Add(i, (int)(itemsWeights.ElementAt(i).Weight * 10f));
			}
			if (bag.Size == 0)
			{
				bag.Add(firstItem, 1);
			}
		}

		[Obsolete("Method will get removed once the obsolete data will get removed")]
		public void ConvertObsoleteData()
		{
			RandomizeItems = m_RepeatingOrder == CurvyRepeatingOrderEnum.Random;
			IgnoreModuleCrossBase = m_DistributionMode == DistributionModeEnum.Self;
			CrossBase = m_PositionOffset;
			if (m_Height.From != 0f || (!m_Height.SimpleValue && m_Height.To != 0f))
			{
				TranslationY = m_Height;
				RelativeTranslation = true;
			}
			float num = m_RotationOffset.x - m_RotationScatter.x;
			float num2 = m_RotationOffset.x + m_RotationScatter.x;
			RotationX = ((num == num2) ? new FloatRegion(num) : new FloatRegion(num, num2));
			float num3 = m_RotationOffset.y - m_RotationScatter.y;
			float num4 = m_RotationOffset.y + m_RotationScatter.y;
			RotationY = ((num3 == num4) ? new FloatRegion(num3) : new FloatRegion(num3, num4));
			float num5 = m_RotationOffset.z - m_RotationScatter.z;
			float num6 = m_RotationOffset.z + m_RotationScatter.z;
			RotationZ = ((num5 == num6) ? new FloatRegion(num5) : new FloatRegion(num5, num6));
		}
	}
	public enum CGYesNoAuto
	{
		Yes,
		No,
		Auto
	}
	public enum CGReferenceMode
	{
		Source,
		Self
	}
	public enum CGKeepAspectMode
	{
		Off,
		ScaleU,
		ScaleV
	}
	[Obsolete]
	public enum CGUVEnum
	{
		U,
		V
	}
	public enum CGColliderEnum
	{
		None,
		Mesh,
		Box,
		Sphere,
		Capsule
	}
	[Serializable]
	public struct CGSpot : IEquatable<CGSpot>
	{
		[SerializeField]
		[Label("Idx", "")]
		private int m_Index;

		[SerializeField]
		[VectorEx("Pos", "", Options = AttributeOptionsFlags.Compact, Precision = 4)]
		private Vector3 m_Position;

		[SerializeField]
		[VectorEx("Rot", "", Options = AttributeOptionsFlags.Compact, Precision = 4)]
		private Quaternion m_Rotation;

		[SerializeField]
		[VectorEx("Scl", "", Options = AttributeOptionsFlags.Compact, Precision = 4)]
		private Vector3 m_Scale;

		public int Index => m_Index;

		public Vector3 Position
		{
			get
			{
				return m_Position;
			}
			set
			{
				if (m_Position != value)
				{
					m_Position = value;
				}
			}
		}

		public Quaternion Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(m_Position, m_Rotation, m_Scale);

		public CGSpot(int index)
			: this(index, Vector3.zero, Quaternion.identity, Vector3.one)
		{
		}

		public CGSpot(int index, Vector3 position, Quaternion rotation, Vector3 scale)
		{
			m_Index = index;
			m_Position = position;
			m_Rotation = rotation;
			m_Scale = scale;
		}

		public void ToTransform(Transform transform)
		{
			transform.localPosition = Position;
			transform.localRotation = Rotation;
			transform.localScale = Scale;
		}

		public bool Equals(CGSpot other)
		{
			if (m_Index == other.m_Index && m_Position.Equals(other.m_Position) && m_Rotation.Equals(other.m_Rotation))
			{
				return m_Scale.Equals(other.m_Scale);
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is CGSpot)
			{
				return Equals((CGSpot)obj);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (((((m_Index * 397) ^ m_Position.GetHashCode()) * 397) ^ m_Rotation.GetHashCode()) * 397) ^ m_Scale.GetHashCode();
		}

		public static bool operator ==(CGSpot left, CGSpot right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(CGSpot left, CGSpot right)
		{
			return !left.Equals(right);
		}
	}
	[Serializable]
	public class CGMaterialSettings
	{
		public bool SwapUV;

		public CGKeepAspectMode KeepAspect;

		public float UVRotation;

		public Vector2 UVOffset = Vector2.zero;

		public Vector2 UVScale = Vector2.one;
	}
	[Serializable]
	public class CGMaterialSettingsEx : CGMaterialSettings
	{
		public int MaterialID;
	}
	[Serializable]
	public class CGMeshProperties
	{
		[SerializeField]
		private Mesh m_Mesh;

		[SerializeField]
		private Material[] m_Material = new Material[0];

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Translation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Rotation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Scale = Vector3.one;

		public Mesh Mesh
		{
			get
			{
				return m_Mesh;
			}
			set
			{
				if (m_Mesh != value)
				{
					m_Mesh = value;
				}
				if ((bool)m_Mesh && m_Mesh.subMeshCount != m_Material.Length)
				{
					Array.Resize(ref m_Material, m_Mesh.subMeshCount);
				}
			}
		}

		public Material[] Material
		{
			get
			{
				return m_Material;
			}
			set
			{
				if (m_Material != value)
				{
					m_Material = value;
				}
			}
		}

		public Vector3 Translation
		{
			get
			{
				return m_Translation;
			}
			set
			{
				if (m_Translation != value)
				{
					m_Translation = value;
				}
			}
		}

		public Vector3 Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale);

		public CGMeshProperties()
		{
		}

		public CGMeshProperties(Mesh mesh)
		{
			Mesh = mesh;
			Material = ((mesh != null) ? new Material[mesh.subMeshCount] : new Material[0]);
		}
	}
	[Serializable]
	public class CGGameObjectProperties
	{
		[SerializeField]
		private GameObject m_Object;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Translation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Rotation;

		[SerializeField]
		[VectorEx("", "")]
		private Vector3 m_Scale = Vector3.one;

		public GameObject Object
		{
			get
			{
				return m_Object;
			}
			set
			{
				if (m_Object != value)
				{
					m_Object = value;
				}
			}
		}

		public Vector3 Translation
		{
			get
			{
				return m_Translation;
			}
			set
			{
				if (m_Translation != value)
				{
					m_Translation = value;
				}
			}
		}

		public Vector3 Rotation
		{
			get
			{
				return m_Rotation;
			}
			set
			{
				if (m_Rotation != value)
				{
					m_Rotation = value;
				}
			}
		}

		public Vector3 Scale
		{
			get
			{
				return m_Scale;
			}
			set
			{
				if (m_Scale != value)
				{
					m_Scale = value;
				}
			}
		}

		public Matrix4x4 Matrix => Matrix4x4.TRS(Translation, Quaternion.Euler(Rotation), Scale);

		public CGGameObjectProperties()
		{
		}

		public CGGameObjectProperties(GameObject gameObject)
		{
			Object = gameObject;
		}
	}
	[Serializable]
	public class CGWeightedItem
	{
		[RangeEx(0f, 1f, "", "", Slider = true, Precision = 1)]
		[SerializeField]
		private float m_Weight = 0.5f;

		public float Weight
		{
			get
			{
				return m_Weight;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_Weight != num)
				{
					m_Weight = num;
				}
			}
		}
	}
	[Serializable]
	public class CGBoundsGroupItem : CGWeightedItem
	{
		public int Index;
	}
	public struct ControlPointOption : IEquatable<ControlPointOption>
	{
		public float TF;

		public float Distance;

		public bool Include;

		public int MaterialID;

		public bool HardEdge;

		public float MaxStepDistance;

		public bool UVEdge;

		public bool UVShift;

		public float FirstU;

		public float SecondU;

		public ControlPointOption(float tf, float dist, bool includeAnyways, int materialID, bool hardEdge, float maxStepDistance, bool uvEdge, bool uvShift, float firstU, float secondU)
		{
			TF = tf;
			Distance = dist;
			Include = includeAnyways;
			MaterialID = materialID;
			HardEdge = hardEdge;
			if (maxStepDistance == 0f)
			{
				MaxStepDistance = float.MaxValue;
			}
			else
			{
				MaxStepDistance = maxStepDistance;
			}
			UVEdge = uvEdge;
			UVShift = uvShift;
			FirstU = firstU;
			SecondU = secondU;
		}

		public bool Equals(ControlPointOption other)
		{
			if (TF.Equals(other.TF) && Distance.Equals(other.Distance) && Include == other.Include && MaterialID == other.MaterialID && HardEdge == other.HardEdge && MaxStepDistance.Equals(other.MaxStepDistance) && UVEdge == other.UVEdge && UVShift == other.UVShift && FirstU.Equals(other.FirstU))
			{
				return SecondU.Equals(other.SecondU);
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is ControlPointOption)
			{
				return Equals((ControlPointOption)obj);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (((((((((((((((((TF.GetHashCode() * 397) ^ Distance.GetHashCode()) * 397) ^ Include.GetHashCode()) * 397) ^ MaterialID) * 397) ^ HardEdge.GetHashCode()) * 397) ^ MaxStepDistance.GetHashCode()) * 397) ^ UVEdge.GetHashCode()) * 397) ^ UVShift.GetHashCode()) * 397) ^ FirstU.GetHashCode()) * 397) ^ SecondU.GetHashCode();
		}

		public static bool operator ==(ControlPointOption left, ControlPointOption right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(ControlPointOption left, ControlPointOption right)
		{
			return !left.Equals(right);
		}
	}
	public struct SamplePointsPatch : IEquatable<SamplePointsPatch>
	{
		public int Start;

		public int Count;

		public int End
		{
			get
			{
				return Start + Count;
			}
			set
			{
				Count = Mathf.Max(0, value - Start);
			}
		}

		public int TriangleCount => Count * 2;

		public SamplePointsPatch(int start)
		{
			Start = start;
			Count = 0;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "Size={0} ({1}-{2}, {3} Tris)", Count, Start, End, TriangleCount);
		}

		public bool Equals(SamplePointsPatch other)
		{
			if (Start == other.Start)
			{
				return Count == other.Count;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is SamplePointsPatch)
			{
				return Equals((SamplePointsPatch)obj);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (Start * 397) ^ Count;
		}

		public static bool operator ==(SamplePointsPatch left, SamplePointsPatch right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(SamplePointsPatch left, SamplePointsPatch right)
		{
			return !left.Equals(right);
		}
	}
	public class SamplePointsMaterialGroup
	{
		public int MaterialID;

		public List<SamplePointsPatch> Patches = new List<SamplePointsPatch>();

		public int TriangleCount
		{
			get
			{
				int num = 0;
				for (int i = 0; i < Patches.Count; i++)
				{
					num += Patches[i].TriangleCount;
				}
				return num;
			}
		}

		public int StartVertex => Patches[0].Start;

		public int EndVertex => Patches[Patches.Count - 1].End;

		public int VertexCount => EndVertex - StartVertex + 1;

		public SamplePointsMaterialGroup(int materialID)
		{
			MaterialID = materialID;
		}

		public void GetLengths(CGVolume volume, out float worldLength, out float uLength)
		{
			worldLength = 0f;
			for (int i = StartVertex; i < EndVertex; i++)
			{
				worldLength += (volume.Vertex[i + 1] - volume.Vertex[i]).magnitude;
			}
			uLength = volume.CrossMap[EndVertex] - volume.CrossMap[StartVertex];
		}

		public SamplePointsMaterialGroup Clone()
		{
			return new SamplePointsMaterialGroup(MaterialID)
			{
				Patches = new List<SamplePointsPatch>(Patches)
			};
		}
	}
	public struct SamplePointUData : IEquatable<SamplePointUData>
	{
		public int Vertex;

		public bool UVEdge;

		public float FirstU;

		public float SecondU;

		public SamplePointUData(int vt, bool uvEdge, float uv0, float uv1)
		{
			Vertex = vt;
			UVEdge = uvEdge;
			FirstU = uv0;
			SecondU = uv1;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "SamplePointUData (Vertex={0},Edge={1},FirstU={2},SecondU={3}", Vertex, UVEdge, FirstU, SecondU);
		}

		public bool Equals(SamplePointUData other)
		{
			if (Vertex == other.Vertex && UVEdge == other.UVEdge && FirstU.Equals(other.FirstU))
			{
				return SecondU.Equals(other.SecondU);
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is SamplePointUData)
			{
				return Equals((SamplePointUData)obj);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (((((Vertex * 397) ^ UVEdge.GetHashCode()) * 397) ^ FirstU.GetHashCode()) * 397) ^ SecondU.GetHashCode();
		}

		public static bool operator ==(SamplePointUData left, SamplePointUData right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(SamplePointUData left, SamplePointUData right)
		{
			return !left.Equals(right);
		}
	}
	public class SamplePointsMaterialGroupCollection : List<SamplePointsMaterialGroup>
	{
		public int MaterialID;

		public float AspectCorrection = 1f;

		public int TriangleCount
		{
			get
			{
				int num = 0;
				for (int i = 0; i < base.Count; i++)
				{
					num += base[i].TriangleCount;
				}
				return num;
			}
		}

		public SamplePointsMaterialGroupCollection()
		{
		}

		public SamplePointsMaterialGroupCollection(int capacity)
			: base(capacity)
		{
		}

		public SamplePointsMaterialGroupCollection(IEnumerable<SamplePointsMaterialGroup> collection)
			: base(collection)
		{
		}

		public void CalculateAspectCorrection(CGVolume volume, CGMaterialSettingsEx matSettings)
		{
			if (matSettings.KeepAspect == CGKeepAspectMode.Off)
			{
				AspectCorrection = 1f;
				return;
			}
			float num = 0f;
			float num2 = 0f;
			for (int i = 0; i < base.Count; i++)
			{
				base[i].GetLengths(volume, out var worldLength, out var uLength);
				num += worldLength;
				num2 += uLength;
			}
			AspectCorrection = volume.Length / (num / num2);
		}
	}
	[Serializable]
	public class CGDataReference
	{
		[SerializeField]
		private CGModule m_Module;

		[SerializeField]
		private string m_SlotName;

		private CGModuleOutputSlot mSlot;

		public CGData[] Data
		{
			get
			{
				if (Slot == null)
				{
					return new CGData[0];
				}
				return Slot.Data;
			}
		}

		public CGModuleOutputSlot Slot
		{
			get
			{
				if ((mSlot == null || mSlot.Module != m_Module || mSlot.Info == null || mSlot.Info.Name != m_SlotName) && m_Module != null && m_Module.Generator != null && m_Module.Generator.IsInitialized && !string.IsNullOrEmpty(m_SlotName))
				{
					mSlot = m_Module.GetOutputSlot(m_SlotName);
				}
				return mSlot;
			}
		}

		public bool HasValue
		{
			get
			{
				CGModuleOutputSlot slot = Slot;
				if (slot != null)
				{
					return slot.Data.Length != 0;
				}
				return false;
			}
		}

		public bool IsEmpty => string.IsNullOrEmpty(SlotName);

		public CGModule Module => m_Module;

		public string SlotName => m_SlotName;

		public CGDataReference()
		{
		}

		public CGDataReference(CGModule module, string slotName)
		{
			setINTERNAL(module, slotName);
		}

		public CGDataReference(CurvyGenerator generator, string moduleName, string slotName)
		{
			setINTERNAL(generator, moduleName, slotName);
		}

		public void Clear()
		{
			setINTERNAL(null, string.Empty);
		}

		public T GetData<T>() where T : CGData
		{
			if (Data.Length != 0)
			{
				return Data[0] as T;
			}
			return null;
		}

		public T[] GetAllData<T>() where T : CGData
		{
			return Data as T[];
		}

		public void setINTERNAL(CGModule module, string slotName)
		{
			m_Module = module;
			m_SlotName = slotName;
			mSlot = null;
		}

		public void setINTERNAL(CurvyGenerator generator, string moduleName, string slotName)
		{
			m_Module = generator.GetModule(moduleName);
			m_SlotName = slotName;
			mSlot = null;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class CGDataInfoAttribute : Attribute
	{
		public readonly Color Color;

		public CGDataInfoAttribute(Color color)
		{
			Color = color;
		}

		public CGDataInfoAttribute(float r, float g, float b, float a = 1f)
		{
			Color = new Color(r, g, b, a);
		}

		public CGDataInfoAttribute(string htmlColor)
		{
			Color = htmlColor.ColorFromHtml();
		}
	}
	public class CGData
	{
		public string Name;

		public virtual int Count => 0;

		public static implicit operator bool(CGData a)
		{
			return a != null;
		}

		public virtual T Clone<T>() where T : CGData
		{
			return new CGData() as T;
		}

		protected int getGenericFIndex(ref float[] FMapArray, float fValue, out float frag)
		{
			if (fValue == 1f)
			{
				frag = 1f;
				return FMapArray.Length - 2;
			}
			fValue = Mathf.Repeat(fValue, 1f);
			for (int i = 1; i < FMapArray.Length; i++)
			{
				if (FMapArray[i] > fValue)
				{
					frag = (fValue - FMapArray[i - 1]) / (FMapArray[i] - FMapArray[i - 1]);
					return i - 1;
				}
			}
			frag = 0f;
			return 0;
		}
	}
	[CGDataInfo(0.73f, 0.87f, 0.98f, 1f)]
	public class CGShape : CGData
	{
		public float[] SourceF = new float[0];

		public float[] F = new float[0];

		public Vector3[] Position = new Vector3[0];

		public Vector3[] Normal = new Vector3[0];

		public float[] Map = new float[0];

		public List<SamplePointsMaterialGroup> MaterialGroups = new List<SamplePointsMaterialGroup>();

		public bool SourceIsManaged;

		public bool Closed;

		public bool Seamless;

		public float Length;

		private float mCacheLastF = float.MaxValue;

		private int mCacheLastIndex;

		private float mCacheLastFrag;

		public override int Count => F.Length;

		public CGShape()
		{
		}

		public CGShape(CGShape source)
		{
			Position = (Vector3[])source.Position.Clone();
			Normal = (Vector3[])source.Normal.Clone();
			Map = (float[])source.Map.Clone();
			F = (float[])source.F.Clone();
			SourceF = (float[])source.SourceF.Clone();
			MaterialGroups = source.MaterialGroups.Select((SamplePointsMaterialGroup g) => g.Clone()).ToList();
			Closed = source.Closed;
			Seamless = source.Seamless;
			Length = source.Length;
			SourceIsManaged = source.SourceIsManaged;
		}

		public override T Clone<T>()
		{
			return new CGShape(this) as T;
		}

		public static void Copy(CGShape dest, CGShape source)
		{
			Array.Resize(ref dest.Position, source.Position.Length);
			source.Position.CopyTo(dest.Position, 0);
			Array.Resize(ref dest.Normal, source.Normal.Length);
			source.Normal.CopyTo(dest.Normal, 0);
			Array.Resize(ref dest.Map, source.Map.Length);
			source.Map.CopyTo(dest.Map, 0);
			Array.Resize(ref dest.F, source.F.Length);
			source.F.CopyTo(dest.F, 0);
			Array.Resize(ref dest.SourceF, source.SourceF.Length);
			source.SourceF.CopyTo(dest.SourceF, 0);
			dest.MaterialGroups = source.MaterialGroups.Select((SamplePointsMaterialGroup g) => g.Clone()).ToList();
			dest.Closed = source.Closed;
			dest.Seamless = source.Seamless;
			dest.Length = source.Length;
		}

		public void Copy(CGShape source)
		{
			Copy(this, source);
		}

		public float DistanceToF(float distance)
		{
			return Mathf.Clamp(distance, 0f, Length) / Length;
		}

		public float FToDistance(float f)
		{
			return Mathf.Clamp01(f) * Length;
		}

		public int GetFIndex(float f, out float frag)
		{
			if (mCacheLastF != f)
			{
				mCacheLastF = f;
				mCacheLastIndex = getGenericFIndex(ref F, f, out mCacheLastFrag);
			}
			frag = mCacheLastFrag;
			return mCacheLastIndex;
		}

		public Vector3 InterpolatePosition(float f)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			return Position[fIndex].LerpUnclamped(Position[fIndex + 1], frag);
		}

		public Vector3 InterpolateUp(float f)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			return Vector3.SlerpUnclamped(Normal[fIndex], Normal[fIndex + 1], frag);
		}

		public void Interpolate(float f, out Vector3 position, out Vector3 up)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			position = Position[fIndex].LerpUnclamped(Position[fIndex + 1], frag);
			up = Vector3.SlerpUnclamped(Normal[fIndex], Normal[fIndex + 1], frag);
		}

		public void Move(ref float f, ref int direction, float speed, CurvyClamping clamping)
		{
			f = CurvyUtility.ClampTF(f + speed * (float)direction, ref direction, clamping);
		}

		public void MoveBy(ref float f, ref int direction, float speedDist, CurvyClamping clamping)
		{
			float distance = CurvyUtility.ClampDistance(FToDistance(f) + speedDist * (float)direction, ref direction, clamping, Length);
			f = DistanceToF(distance);
		}

		public virtual void Recalculate()
		{
			Length = 0f;
			float[] array = new float[Count];
			for (int i = 1; i < Count; i++)
			{
				array[i] = array[i - 1] + (Position[i] - Position[i - 1]).magnitude;
			}
			if (Count <= 0)
			{
				return;
			}
			Length = array[Count - 1];
			if (Length > 0f)
			{
				F[0] = 0f;
				float num = 1f / Length;
				for (int j = 1; j < Count - 1; j++)
				{
					F[j] = array[j] * num;
				}
				F[Count - 1] = 1f;
			}
			else
			{
				F = new float[Count];
			}
		}

		public void RecalculateNormals(List<int> softEdges)
		{
			if (Normal.Length != Position.Length)
			{
				Array.Resize(ref Normal, Position.Length);
			}
			for (int i = 0; i < MaterialGroups.Count; i++)
			{
				for (int j = 0; j < MaterialGroups[i].Patches.Count; j++)
				{
					SamplePointsPatch samplePointsPatch = MaterialGroups[i].Patches[j];
					Vector3 normalized;
					for (int k = 0; k < samplePointsPatch.Count; k++)
					{
						int num = samplePointsPatch.Start + k;
						normalized = (Position[num + 1] - Position[num]).normalized;
						Normal[num] = new Vector3(0f - normalized.y, normalized.x, 0f);
					}
					normalized = (Position[samplePointsPatch.End] - Position[samplePointsPatch.End - 1]).normalized;
					Normal[samplePointsPatch.End] = new Vector3(0f - normalized.y, normalized.x, 0f);
				}
			}
			for (int l = 0; l < softEdges.Count; l++)
			{
				int num2 = softEdges[l] - 1;
				if (num2 < 0)
				{
					num2 = Position.Length - 1;
				}
				int num3 = num2 - 1;
				if (num3 < 0)
				{
					num3 = Position.Length - 1;
				}
				int num4 = softEdges[l] + 1;
				if (num4 == Position.Length)
				{
					num4 = 0;
				}
				Normal[softEdges[l]] = Vector3.Slerp(Normal[num3], Normal[num4], 0.5f);
				Normal[num2] = Normal[softEdges[l]];
			}
		}
	}
	[CGDataInfo(0.13f, 0.59f, 0.95f, 1f)]
	public class CGPath : CGShape
	{
		public Vector3[] Direction = new Vector3[0];

		public CGPath()
		{
		}

		public CGPath(CGPath source)
			: base(source)
		{
			Direction = (Vector3[])source.Direction.Clone();
		}

		public override T Clone<T>()
		{
			return new CGPath(this) as T;
		}

		public static void Copy(CGPath dest, CGPath source)
		{
			CGShape.Copy(dest, source);
			Array.Resize(ref dest.Direction, source.Direction.Length);
			source.Direction.CopyTo(dest.Direction, 0);
		}

		public void Interpolate(float f, out Vector3 position, out Vector3 direction, out Vector3 up)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			position = Position[fIndex].LerpUnclamped(Position[fIndex + 1], frag);
			direction = Vector3.SlerpUnclamped(Direction[fIndex], Direction[fIndex + 1], frag);
			up = Vector3.SlerpUnclamped(Normal[fIndex], Normal[fIndex + 1], frag);
		}

		public void Interpolate(float f, float angleF, out Vector3 pos, out Vector3 dir, out Vector3 up)
		{
			Interpolate(f, out pos, out dir, out up);
			if (angleF != 0f)
			{
				Quaternion quaternion = Quaternion.AngleAxis(angleF * -360f, dir);
				up = quaternion * up;
			}
		}

		public Vector3 InterpolateDirection(float f)
		{
			float frag;
			int fIndex = GetFIndex(f, out frag);
			return Vector3.SlerpUnclamped(Direction[fIndex], Direction[fIndex + 1], frag);
		}
	}
	[CGDataInfo(0.08f, 0.4f, 0.75f, 1f)]
	public class CGVolume : CGPath
	{
		public Vector3[] Vertex = new Vector3[0];

		public Vector3[] VertexNormal = new Vector3[0];

		public float[] CrossF = new float[0];

		public float[] CrossMap = new float[0];

		public float[] SegmentLength;

		public bool CrossClosed;

		public bool CrossSeamless;

		public float CrossFShift;

		public SamplePointsMaterialGroupCollection CrossMaterialGroups;

		public int CrossSize => CrossF.Length;

		public int VertexCount => Vertex.Length;

		public CGVolume()
		{
		}

		public CGVolume(int samplePoints, CGShape crossShape)
		{
			CrossF = (float[])crossShape.F.Clone();
			CrossMap = (float[])crossShape.Map.Clone();
			CrossClosed = crossShape.Closed;
			CrossSeamless = crossShape.Seamless;
			CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
			SegmentLength = new float[Count];
			Vertex = new Vector3[CrossSize * samplePoints];
			VertexNormal = new Vector3[Vertex.Length];
		}

		public CGVolume(CGPath path, CGShape crossShape)
			: base(path)
		{
			CrossF = (float[])crossShape.F.Clone();
			CrossMap = (float[])crossShape.Map.Clone();
			SegmentLength = new float[Count];
			CrossClosed = crossShape.Closed;
			CrossSeamless = crossShape.Seamless;
			CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
			Vertex = new Vector3[CrossSize * Count];
			VertexNormal = new Vector3[Vertex.Length];
		}

		public CGVolume(CGVolume source)
			: base(source)
		{
			Vertex = (Vector3[])source.Vertex.Clone();
			VertexNormal = (Vector3[])source.VertexNormal.Clone();
			CrossF = (float[])source.CrossF.Clone();
			CrossMap = (float[])source.CrossMap.Clone();
			SegmentLength = new float[Count];
			CrossClosed = source.Closed;
			CrossSeamless = source.CrossSeamless;
			CrossFShift = source.CrossFShift;
			CrossMaterialGroups = new SamplePointsMaterialGroupCollection(source.CrossMaterialGroups);
		}

		public static CGVolume Get(CGVolume data, CGPath path, CGShape crossShape)
		{
			if (data == null)
			{
				return new CGVolume(path, crossShape);
			}
			CGPath.Copy(data, path);
			Array.Resize(ref data.SegmentLength, data.CrossF.Length);
			data.SegmentLength = new float[data.Count];
			Array.Resize(ref data.CrossF, crossShape.F.Length);
			crossShape.F.CopyTo(data.CrossF, 0);
			Array.Resize(ref data.CrossMap, crossShape.Map.Length);
			crossShape.Map.CopyTo(data.CrossMap, 0);
			data.CrossClosed = crossShape.Closed;
			data.CrossSeamless = crossShape.Seamless;
			data.CrossMaterialGroups = new SamplePointsMaterialGroupCollection(crossShape.MaterialGroups);
			Array.Resize(ref data.Vertex, data.CrossSize * data.Position.Length);
			Array.Resize(ref data.VertexNormal, data.Vertex.Length);
			return data;
		}

		public override T Clone<T>()
		{
			return new CGVolume(this) as T;
		}

		public void InterpolateVolume(float f, float crossF, out Vector3 pos, out Vector3 dir, out Vector3 up)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			Vector3 vector = Vertex[vertexIndex];
			Vector3 vector2 = Vertex[vertexIndex + 1];
			Vector3 vector3 = Vertex[vertexIndex + CrossSize];
			Vector3 vector5;
			Vector3 vector6;
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector4 = Vertex[vertexIndex + CrossSize + 1];
				vector5 = vector4 - vector3;
				vector6 = vector4 - vector2;
				pos = vector3 - vector6 * (1f - pathFrag) + vector5 * crossFrag;
			}
			else
			{
				vector5 = vector2 - vector;
				vector6 = vector3 - vector;
				pos = vector + vector6 * pathFrag + vector5 * crossFrag;
			}
			dir = vector6.normalized;
			up = Vector3.Cross(vector6, vector5);
		}

		public Vector3 InterpolateVolumePosition(float f, float crossF)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			Vector3 vector = Vertex[vertexIndex];
			Vector3 vector2 = Vertex[vertexIndex + 1];
			Vector3 vector3 = Vertex[vertexIndex + CrossSize];
			Vector3 vector5;
			Vector3 vector6;
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector4 = Vertex[vertexIndex + CrossSize + 1];
				vector5 = vector4 - vector3;
				vector6 = vector4 - vector2;
				return vector3 - vector6 * (1f - pathFrag) + vector5 * crossFrag;
			}
			vector5 = vector2 - vector;
			vector6 = vector3 - vector;
			return vector + vector6 * pathFrag + vector5 * crossFrag;
		}

		public Vector3 InterpolateVolumeDirection(float f, float crossF)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector = Vertex[vertexIndex + 1];
				return (Vertex[vertexIndex + CrossSize + 1] - vector).normalized;
			}
			Vector3 vector2 = Vertex[vertexIndex];
			return (Vertex[vertexIndex + CrossSize] - vector2).normalized;
		}

		public Vector3 InterpolateVolumeUp(float f, float crossF)
		{
			float pathFrag;
			float crossFrag;
			int vertexIndex = GetVertexIndex(f, crossF, out pathFrag, out crossFrag);
			Vector3 vector = Vertex[vertexIndex + 1];
			Vector3 vector2 = Vertex[vertexIndex + CrossSize];
			Vector3 rhs;
			Vector3 lhs;
			if (pathFrag + crossFrag > 1f)
			{
				Vector3 vector3 = Vertex[vertexIndex + CrossSize + 1];
				rhs = vector3 - vector2;
				lhs = vector3 - vector;
			}
			else
			{
				Vector3 vector4 = Vertex[vertexIndex];
				rhs = vector - vector4;
				lhs = vector2 - vector4;
			}
			return Vector3.Cross(lhs, rhs);
		}

		public float GetCrossLength(float pathF)
		{
			GetSegmentIndices(pathF, out var s0Index, out var s1Index, out var frag);
			if (SegmentLength[s0Index] == 0f)
			{
				SegmentLength[s0Index] = calcSegmentLength(s0Index);
			}
			if (SegmentLength[s1Index] == 0f)
			{
				SegmentLength[s1Index] = calcSegmentLength(s1Index);
			}
			return Mathf.LerpUnclamped(SegmentLength[s0Index], SegmentLength[s1Index], frag);
		}

		public float CrossFToDistance(float f, float crossF, CurvyClamping crossClamping = CurvyClamping.Clamp)
		{
			return GetCrossLength(f) * CurvyUtility.ClampTF(crossF, crossClamping);
		}

		public float CrossDistanceToF(float f, float distance, CurvyClamping crossClamping = CurvyClamping.Clamp)
		{
			float crossLength = GetCrossLength(f);
			return CurvyUtility.ClampDistance(distance, crossClamping, crossLength) / crossLength;
		}

		public void GetSegmentIndices(float pathF, out int s0Index, out int s1Index, out float frag)
		{
			s0Index = GetFIndex(Mathf.Repeat(pathF, 1f), out frag);
			s1Index = s0Index + 1;
		}

		public int GetSegmentIndex(int segment)
		{
			return segment * CrossSize;
		}

		public int GetCrossFIndex(float crossF, out float frag)
		{
			float num = crossF + CrossFShift;
			if (num != 1f)
			{
				return getGenericFIndex(ref CrossF, Mathf.Repeat(num, 1f), out frag);
			}
			return getGenericFIndex(ref CrossF, num, out frag);
		}

		public int GetVertexIndex(float pathF, out float pathFrag)
		{
			return GetFIndex(pathF, out pathFrag) * CrossSize;
		}

		public int GetVertexIndex(float pathF, float crossF, out float pathFrag, out float crossFrag)
		{
			int vertexIndex = GetVertexIndex(pathF, out pathFrag);
			int crossFIndex = GetCrossFIndex(crossF, out crossFrag);
			return vertexIndex + crossFIndex;
		}

		public Vector3[] GetSegmentVertices(params int[] segmentIndices)
		{
			Vector3[] array = new Vector3[CrossSize * segmentIndices.Length];
			for (int i = 0; i < segmentIndices.Length; i++)
			{
				Array.Copy(Vertex, segmentIndices[i] * CrossSize, array, i * CrossSize, CrossSize);
			}
			return array;
		}

		private float calcSegmentLength(int segmentIndex)
		{
			int num = segmentIndex * CrossSize;
			int num2 = num + CrossSize - 1;
			float num3 = 0f;
			for (int i = num; i < num2; i++)
			{
				num3 += (Vertex[i + 1] - Vertex[i]).magnitude;
			}
			return num3;
		}
	}
	[CGDataInfo(1f, 0.8f, 0.5f, 1f)]
	public class CGBounds : CGData
	{
		protected Bounds? mBounds;

		public Bounds Bounds
		{
			get
			{
				if (!mBounds.HasValue)
				{
					RecalculateBounds();
				}
				return mBounds.Value;
			}
			set
			{
				if (mBounds != value)
				{
					mBounds = value;
				}
			}
		}

		public float Depth => Bounds.size.z;

		public CGBounds()
		{
		}

		public CGBounds(Bounds bounds)
		{
			Bounds = bounds;
		}

		public CGBounds(CGBounds source)
		{
			Name = source.Name;
			if (source.mBounds.HasValue)
			{
				Bounds = source.Bounds;
			}
		}

		public virtual void RecalculateBounds()
		{
			Bounds = default(Bounds);
		}

		public override T Clone<T>()
		{
			return new CGBounds(this) as T;
		}

		public static void Copy(CGBounds dest, CGBounds source)
		{
			if (source.mBounds.HasValue)
			{
				dest.Bounds = source.Bounds;
			}
		}
	}
	public class CGVSubMesh : CGData
	{
		public int[] Triangles;

		public Material Material;

		public override int Count => Triangles.Length;

		public CGVSubMesh(Material material = null)
		{
			Material = material;
			Triangles = new int[0];
		}

		public CGVSubMesh(int[] triangles, Material material = null)
		{
			Material = material;
			Triangles = triangles;
		}

		public CGVSubMesh(int triangleCount, Material material = null)
		{
			Material = material;
			Triangles = new int[triangleCount];
		}

		public CGVSubMesh(CGVSubMesh source)
		{
			Material = source.Material;
			Triangles = (int[])source.Triangles.Clone();
		}

		public override T Clone<T>()
		{
			return new CGVSubMesh(this) as T;
		}

		public static CGVSubMesh Get(CGVSubMesh data, int triangleCount, Material material = null)
		{
			if (data == null)
			{
				return new CGVSubMesh(triangleCount, material);
			}
			Array.Resize(ref data.Triangles, triangleCount);
			data.Material = material;
			return data;
		}

		public void ShiftIndices(int offset, int startIndex = 0)
		{
			for (int i = startIndex; i < Triangles.Length; i++)
			{
				Triangles[i] += offset;
			}
		}

		public void Add(CGVSubMesh other, int shiftIndexOffset = 0)
		{
			int num = Triangles.Length;
			int num2 = other.Triangles.Length;
			if (num2 != 0)
			{
				int[] triangles = Triangles;
				Triangles = new int[num + num2];
				Array.Copy(triangles, Triangles, num);
				Array.Copy(other.Triangles, 0, Triangles, num, num2);
				if (shiftIndexOffset != 0)
				{
					ShiftIndices(shiftIndexOffset, num);
				}
			}
		}
	}
	[CGDataInfo(0.98f, 0.5f, 0f, 1f)]
	public class CGVMesh : CGBounds
	{
		public Vector3[] Vertex;

		public Vector2[] UV;

		public Vector2[] UV2;

		public Vector3[] Normal;

		public Vector4[] Tangents;

		public CGVSubMesh[] SubMeshes;

		public override int Count => Vertex.Length;

		public bool HasUV => UV.Length != 0;

		public bool HasUV2 => UV2.Length != 0;

		public bool HasNormals => Normal.Length != 0;

		public bool HasTangents => Tangents.Length != 0;

		public int TriangleCount
		{
			get
			{
				int num = 0;
				for (int i = 0; i < SubMeshes.Length; i++)
				{
					num += SubMeshes[i].Triangles.Length;
				}
				return num / 3;
			}
		}

		public CGVMesh()
			: this(0)
		{
		}

		public CGVMesh(int vertexCount, bool addUV = false, bool addUV2 = false, bool addNormals = false, bool addTangents = false)
		{
			Vertex = new Vector3[vertexCount];
			UV = (addUV ? new Vector2[vertexCount] : new Vector2[0]);
			UV2 = (addUV2 ? new Vector2[vertexCount] : new Vector2[0]);
			Normal = (addNormals ? new Vector3[vertexCount] : new Vector3[0]);
			Tangents = (addTangents ? new Vector4[vertexCount] : new Vector4[0]);
			SubMeshes = new CGVSubMesh[0];
		}

		public CGVMesh(CGVolume volume)
			: this(volume.Vertex.Length)
		{
			Array.Copy(volume.Vertex, Vertex, volume.Vertex.Length);
		}

		public CGVMesh(CGVolume volume, IntRegion subset)
			: this((subset.LengthPositive + 1) * volume.CrossSize, addUV: false, addUV2: false, addNormals: true)
		{
			int sourceIndex = subset.Low * volume.CrossSize;
			Array.Copy(volume.Vertex, sourceIndex, Vertex, 0, Vertex.Length);
			Array.Copy(volume.VertexNormal, sourceIndex, Normal, 0, Normal.Length);
		}

		public CGVMesh(CGVMesh source)
			: base(source)
		{
			Vertex = (Vector3[])source.Vertex.Clone();
			UV = (Vector2[])source.UV.Clone();
			UV2 = (Vector2[])source.UV2.Clone();
			Normal = (Vector3[])source.Normal.Clone();
			Tangents = (Vector4[])source.Tangents.Clone();
			SubMeshes = new CGVSubMesh[source.SubMeshes.Length];
			for (int i = 0; i < source.SubMeshes.Length; i++)
			{
				SubMeshes[i] = new CGVSubMesh(source.SubMeshes[i]);
			}
		}

		public CGVMesh(CGMeshProperties meshProperties)
			: this(meshProperties.Mesh, meshProperties.Material, meshProperties.Matrix)
		{
		}

		public CGVMesh(Mesh source, Material[] materials, Matrix4x4 trsMatrix)
		{
			Name = source.name;
			Vertex = (Vector3[])source.vertices.Clone();
			Normal = (Vector3[])source.normals.Clone();
			Tangents = (Vector4[])source.tangents.Clone();
			UV = (Vector2[])source.uv.Clone();
			UV2 = (Vector2[])source.uv2.Clone();
			SubMeshes = new CGVSubMesh[source.subMeshCount];
			for (int i = 0; i < source.subMeshCount; i++)
			{
				SubMeshes[i] = new CGVSubMesh(source.GetTriangles(i), (materials.Length > i) ? materials[i] : null);
			}
			base.Bounds = source.bounds;
			if (!trsMatrix.isIdentity)
			{
				TRS(trsMatrix);
			}
		}

		public override T Clone<T>()
		{
			return new CGVMesh(this) as T;
		}

		public static CGVMesh Get(CGVMesh data, CGVolume source, bool addUV, bool reverseNormals)
		{
			return Get(data, source, new IntRegion(0, source.Count - 1), addUV, reverseNormals);
		}

		public static CGVMesh Get(CGVMesh data, CGVolume source, IntRegion subset, bool addUV, bool reverseNormals)
		{
			int sourceIndex = subset.Low * source.CrossSize;
			int num = (subset.LengthPositive + 1) * source.CrossSize;
			if (data == null)
			{
				data = new CGVMesh(num, addUV, addUV, addNormals: true);
			}
			else
			{
				if (data.Vertex.Length != num)
				{
					data.Vertex = new Vector3[num];
				}
				if (data.Normal.Length != num)
				{
					data.Normal = new Vector3[num];
				}
				int num2 = (addUV ? source.Vertex.Length : 0);
				if (data.UV.Length != num2)
				{
					data.UV = new Vector2[num2];
				}
				if (data.UV2.Length != 0)
				{
					data.UV2 = new Vector2[0];
				}
				if (data.Tangents.Length != 0)
				{
					data.Tangents = new Vector4[0];
				}
			}
			Array.Copy(source.Vertex, sourceIndex, data.Vertex, 0, num);
			Array.Copy(source.VertexNormal, sourceIndex, data.Normal, 0, num);
			if (reverseNormals)
			{
				for (int i = 0; i < data.Normal.Length; i++)
				{
					data.Normal[i].x = 0f - data.Normal[i].x;
					data.Normal[i].y = 0f - data.Normal[i].y;
					data.Normal[i].z = 0f - data.Normal[i].z;
				}
			}
			return data;
		}

		public void SetSubMeshCount(int count)
		{
			Array.Resize(ref SubMeshes, count);
		}

		public void AddSubMesh(CGVSubMesh submesh = null)
		{
			SubMeshes = SubMeshes.Add(submesh);
		}

		public void MergeVMesh(CGVMesh source)
		{
			int count = Count;
			copyData(ref source.Vertex, ref Vertex, count, source.Count);
			MergeUVsNormalsAndTangents(source, count);
			for (int i = 0; i < source.SubMeshes.Length; i++)
			{
				GetMaterialSubMesh(source.SubMeshes[i].Material).Add(source.SubMeshes[i], count);
			}
			mBounds = null;
		}

		public void MergeVMesh(CGVMesh source, Matrix4x4 matrix)
		{
			int count = Count;
			Array.Resize(ref Vertex, Count + source.Count);
			int count2 = Count;
			for (int i = count; i < count2; i++)
			{
				Vertex[i] = matrix.MultiplyPoint3x4(source.Vertex[i - count]);
			}
			MergeUVsNormalsAndTangents(source, count);
			for (int j = 0; j < source.SubMeshes.Length; j++)
			{
				GetMaterialSubMesh(source.SubMeshes[j].Material).Add(source.SubMeshes[j], count);
			}
			mBounds = null;
		}

		public void MergeVMeshes(List<CGVMesh> vMeshes, int startIndex, int endIndex)
		{
			int num = 0;
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			Dictionary<Material, List<int[]>> dictionary = new Dictionary<Material, List<int[]>>();
			Dictionary<Material, int> dictionary2 = new Dictionary<Material, int>();
			for (int i = startIndex; i <= endIndex; i++)
			{
				CGVMesh cGVMesh = vMeshes[i];
				num += cGVMesh.Count;
				flag |= cGVMesh.HasNormals;
				flag2 |= cGVMesh.HasTangents;
				flag3 |= cGVMesh.HasUV;
				flag4 |= cGVMesh.HasUV2;
				for (int j = 0; j < cGVMesh.SubMeshes.Length; j++)
				{
					CGVSubMesh cGVSubMesh = cGVMesh.SubMeshes[j];
					if (!dictionary.ContainsKey(cGVSubMesh.Material))
					{
						dictionary[cGVSubMesh.Material] = new List<int[]>(1);
						dictionary2[cGVSubMesh.Material] = 0;
					}
					dictionary[cGVSubMesh.Material].Add(cGVSubMesh.Triangles);
				}
			}
			Vertex = new Vector3[num];
			if (flag)
			{
				Normal = new Vector3[num];
			}
			if (flag2)
			{
				Tangents = new Vector4[num];
			}
			if (flag3)
			{
				UV = new Vector2[num];
			}
			if (flag4)
			{
				UV2 = new Vector2[num];
			}
			foreach (KeyValuePair<Material, List<int[]>> item in dictionary)
			{
				List<int[]> value = item.Value;
				CGVSubMesh cGVSubMesh2 = new CGVSubMesh(item.Key);
				int num2 = 0;
				for (int k = 0; k < item.Value.Count; k++)
				{
					num2 += value[k].Length;
				}
				cGVSubMesh2.Triangles = new int[num2];
				AddSubMesh(cGVSubMesh2);
			}
			int num3 = 0;
			for (int l = startIndex; l <= endIndex; l++)
			{
				CGVMesh cGVMesh2 = vMeshes[l];
				Array.Copy(cGVMesh2.Vertex, 0, Vertex, num3, cGVMesh2.Vertex.Length);
				if (flag && cGVMesh2.HasNormals)
				{
					Array.Copy(cGVMesh2.Normal, 0, Normal, num3, cGVMesh2.Normal.Length);
				}
				if (flag2 && cGVMesh2.HasTangents)
				{
					Array.Copy(cGVMesh2.Tangents, 0, Tangents, num3, cGVMesh2.Tangents.Length);
				}
				if (flag3 && cGVMesh2.HasUV)
				{
					Array.Copy(cGVMesh2.UV, 0, UV, num3, cGVMesh2.UV.Length);
				}
				if (flag4 && cGVMesh2.HasUV2)
				{
					Array.Copy(cGVMesh2.UV2, 0, UV2, num3, cGVMesh2.UV2.Length);
				}
				for (int m = 0; m < cGVMesh2.SubMeshes.Length; m++)
				{
					CGVSubMesh obj = cGVMesh2.SubMeshes[m];
					Material material = obj.Material;
					int[] triangles = obj.Triangles;
					int num4 = triangles.Length;
					int[] triangles2 = GetMaterialSubMesh(material).Triangles;
					int num5 = dictionary2[material];
					if (num4 == 0)
					{
						continue;
					}
					if (num3 == 0)
					{
						Array.Copy(triangles, 0, triangles2, num5, num4);
					}
					else
					{
						for (int n = 0; n < num4; n++)
						{
							triangles2[num5 + n] = triangles[n] + num3;
						}
					}
					dictionary2[material] = num5 + num4;
				}
				num3 += cGVMesh2.Vertex.Length;
			}
		}

		private void MergeUVsNormalsAndTangents(CGVMesh source, int preMergeVertexCount)
		{
			int count = source.Count;
			if (count == 0)
			{
				return;
			}
			int num = preMergeVertexCount + count;
			if (HasUV || source.HasUV)
			{
				Vector2[] uV = UV;
				UV = new Vector2[num];
				if (HasUV)
				{
					Array.Copy(uV, UV, preMergeVertexCount);
				}
				if (source.HasUV)
				{
					Array.Copy(source.UV, 0, UV, preMergeVertexCount, count);
				}
			}
			if (HasUV2 || source.HasUV2)
			{
				Vector2[] uV2 = UV2;
				UV2 = new Vector2[num];
				if (HasUV2)
				{
					Array.Copy(uV2, UV2, preMergeVertexCount);
				}
				if (source.HasUV2)
				{
					Array.Copy(source.UV2, 0, UV2, preMergeVertexCount, count);
				}
			}
			if (HasNormals || source.HasNormals)
			{
				Vector3[] normal = Normal;
				Normal = new Vector3[num];
				if (HasNormals)
				{
					Array.Copy(normal, Normal, preMergeVertexCount);
				}
				if (source.HasNormals)
				{
					Array.Copy(source.Normal, 0, Normal, preMergeVertexCount, count);
				}
			}
			if (HasTangents || source.HasTangents)
			{
				Vector4[] tangents = Tangents;
				Tangents = new Vector4[num];
				if (HasTangents)
				{
					Array.Copy(tangents, Tangents, preMergeVertexCount);
				}
				if (source.HasTangents)
				{
					Array.Copy(source.Tangents, 0, Tangents, preMergeVertexCount, count);
				}
			}
		}

		public CGVSubMesh GetMaterialSubMesh(Material mat, bool createIfMissing = true)
		{
			for (int i = 0; i < SubMeshes.Length; i++)
			{
				if (SubMeshes[i].Material == mat)
				{
					return SubMeshes[i];
				}
			}
			if (createIfMissing)
			{
				CGVSubMesh cGVSubMesh = new CGVSubMesh(mat);
				AddSubMesh(cGVSubMesh);
				return cGVSubMesh;
			}
			return null;
		}

		public Mesh AsMesh()
		{
			Mesh msh = new Mesh();
			ToMesh(ref msh);
			return msh;
		}

		public void ToMesh(ref Mesh msh)
		{
			msh.vertices = Vertex;
			if (HasUV)
			{
				msh.uv = UV;
			}
			if (HasUV2)
			{
				msh.uv2 = UV2;
			}
			if (HasNormals)
			{
				msh.normals = Normal;
			}
			if (HasTangents)
			{
				msh.tangents = Tangents;
			}
			msh.subMeshCount = SubMeshes.Length;
			for (int i = 0; i < SubMeshes.Length; i++)
			{
				msh.SetTriangles(SubMeshes[i].Triangles, i);
			}
		}

		public Material[] GetMaterials()
		{
			List<Material> list = new List<Material>();
			for (int i = 0; i < SubMeshes.Length; i++)
			{
				list.Add(SubMeshes[i].Material);
			}
			return list.ToArray();
		}

		public override void RecalculateBounds()
		{
			if (Count == 0)
			{
				mBounds = new Bounds(Vector3.zero, Vector3.zero);
				return;
			}
			Bounds value = new Bounds(Vertex[0], Vector3.zero);
			int num = Vertex.Length;
			for (int i = 1; i < num; i++)
			{
				value.Encapsulate(Vertex[i]);
			}
			mBounds = value;
		}

		public void RecalculateUV2()
		{
			UV2 = CGUtility.CalculateUV2(UV);
		}

		public void TRS(Matrix4x4 matrix)
		{
			int count = Count;
			for (int i = 0; i < count; i++)
			{
				Vertex[i] = matrix.MultiplyPoint3x4(Vertex[i]);
			}
			count = Normal.Length;
			for (int j = 0; j < count; j++)
			{
				Normal[j] = matrix.MultiplyVector(Normal[j]);
			}
			count = Tangents.Length;
			for (int k = 0; k < count; k++)
			{
				Vector3 vector = matrix.MultiplyVector(Tangents[k]);
				Tangents[k].x = vector.x;
				Tangents[k].y = vector.y;
				Tangents[k].z = vector.z;
			}
			mBounds = null;
		}

		private void copyData<T>(ref T[] src, ref T[] dst, int currentSize, int extraSize)
		{
			if (extraSize != 0)
			{
				T[] sourceArray = dst;
				dst = new T[currentSize + extraSize];
				Array.Copy(sourceArray, dst, currentSize);
				Array.Copy(src, 0, dst, currentSize, extraSize);
			}
		}
	}
	[CGDataInfo("#FFF59D")]
	public class CGGameObject : CGBounds
	{
		public GameObject Object;

		public Vector3 Translate;

		public Vector3 Rotate;

		public Vector3 Scale = Vector3.one;

		public Matrix4x4 Matrix => Matrix4x4.TRS(Translate, Quaternion.Euler(Rotate), Scale);

		public CGGameObject()
		{
		}

		public CGGameObject(CGGameObjectProperties properties)
			: this(properties.Object, properties.Translation, properties.Rotation, properties.Scale)
		{
		}

		public CGGameObject(GameObject obj)
			: this(obj, Vector3.zero, Vector3.zero, Vector3.one)
		{
		}

		public CGGameObject(GameObject obj, Vector3 translate, Vector3 rotate, Vector3 scale)
		{
			Object = obj;
			Translate = translate;
			Rotate = rotate;
			Scale = scale;
			if ((bool)Object)
			{
				Name = Object.name;
			}
		}

		public CGGameObject(CGGameObject source)
			: base(source)
		{
			Object = source.Object;
			Translate = source.Translate;
			Rotate = source.Rotate;
			Scale = source.Scale;
		}

		public override T Clone<T>()
		{
			return new CGGameObject(this) as T;
		}

		[Obsolete("Member not used by Curvy, will get remove. Copy it if you still need it")]
		public static CGGameObject Get(CGGameObject data, GameObject obj, Vector3 translate, Vector3 rotate, Vector3 scale)
		{
			if (data == null)
			{
				return new CGGameObject(obj);
			}
			data.Object = obj;
			data.Name = ((obj != null) ? obj.name : null);
			data.Translate = translate;
			data.Rotate = rotate;
			data.Scale = scale;
			return data;
		}

		public override void RecalculateBounds()
		{
			if (Object == null)
			{
				mBounds = default(Bounds);
				return;
			}
			Renderer[] componentsInChildren = Object.GetComponentsInChildren<Renderer>(includeInactive: true);
			Collider[] componentsInChildren2 = Object.GetComponentsInChildren<Collider>(includeInactive: true);
			Bounds value;
			if (componentsInChildren.Length != 0)
			{
				value = componentsInChildren[0].bounds;
				for (int i = 1; i < componentsInChildren.Length; i++)
				{
					value.Encapsulate(componentsInChildren[i].bounds);
				}
				for (int j = 0; j < componentsInChildren2.Length; j++)
				{
					value.Encapsulate(componentsInChildren2[j].bounds);
				}
			}
			else if (componentsInChildren2.Length != 0)
			{
				value = componentsInChildren2[0].bounds;
				for (int k = 1; k < componentsInChildren2.Length; k++)
				{
					value.Encapsulate(componentsInChildren2[k].bounds);
				}
			}
			else
			{
				value = default(Bounds);
			}
			Vector3 vector = Quaternion.Inverse(Object.transform.localRotation) * value.size;
			value.size = new Vector3(vector.x * Scale.x, vector.y * Scale.y, vector.z * Scale.z);
			mBounds = value;
		}
	}
	[CGDataInfo(0.96f, 0.96f, 0.96f, 1f)]
	public class CGSpots : CGData
	{
		public CGSpot[] Points;

		public override int Count => Points.Length;

		public CGSpots()
		{
			Points = new CGSpot[0];
		}

		public CGSpots(params CGSpot[] points)
		{
			Points = points;
		}

		public CGSpots(params List<CGSpot>[] lists)
		{
			int num = 0;
			for (int i = 0; i < lists.Length; i++)
			{
				num += lists[i].Count;
			}
			Points = new CGSpot[num];
			num = 0;
			for (int j = 0; j < lists.Length; j++)
			{
				lists[j].CopyTo(Points, num);
				num += lists[j].Count;
			}
		}

		public CGSpots(CGSpots source)
		{
			Points = source.Points;
		}

		public override T Clone<T>()
		{
			return new CGSpots(this) as T;
		}
	}
	public class CGDataRequestParameter
	{
		public static implicit operator bool(CGDataRequestParameter a)
		{
			return a != null;
		}
	}
	public class CGDataRequestMetaCGOptions : CGDataRequestParameter
	{
		public bool CheckHardEdges;

		public bool CheckMaterialID;

		public bool IncludeControlPoints;

		public bool CheckExtendedUV;

		public CGDataRequestMetaCGOptions(bool checkEdges, bool checkMaterials, bool includeCP, bool extendedUV)
		{
			CheckHardEdges = checkEdges;
			CheckMaterialID = checkMaterials;
			IncludeControlPoints = includeCP;
			CheckExtendedUV = extendedUV;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is CGDataRequestMetaCGOptions cGDataRequestMetaCGOptions))
			{
				return false;
			}
			if (CheckHardEdges == cGDataRequestMetaCGOptions.CheckHardEdges && CheckMaterialID == cGDataRequestMetaCGOptions.CheckMaterialID && IncludeControlPoints == cGDataRequestMetaCGOptions.IncludeControlPoints)
			{
				return CheckExtendedUV == cGDataRequestMetaCGOptions.CheckExtendedUV;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return new
			{
				A = CheckHardEdges,
				B = CheckMaterialID,
				C = IncludeControlPoints,
				D = CheckExtendedUV
			}.GetHashCode();
		}
	}
	public class CGDataRequestShapeRasterization : CGDataRequestRasterization
	{
		public float[] PathF;

		public CGDataRequestShapeRasterization(float[] pathF, float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even)
			: base(start, rasterizedRelativeLength, resolution, angle, mode)
		{
			PathF = pathF;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is CGDataRequestShapeRasterization cGDataRequestShapeRasterization))
			{
				return false;
			}
			if (base.Equals(obj) && cGDataRequestShapeRasterization.PathF.Length == PathF.Length)
			{
				return cGDataRequestShapeRasterization.PathF.SequenceEqual(PathF);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (base.GetHashCode() * 397) ^ ((PathF != null) ? PathF.GetHashCode() : 0);
		}
	}
	public class CGDataRequestRasterization : CGDataRequestParameter
	{
		public enum ModeEnum
		{
			Even,
			Optimized
		}

		public float Start;

		public float RasterizedRelativeLength;

		public int Resolution;

		public float AngleThreshold;

		public ModeEnum Mode;

		public CGDataRequestRasterization(float start, float rasterizedRelativeLength, int resolution, float angle, ModeEnum mode = ModeEnum.Even)
		{
			Start = Mathf.Repeat(start, 1f);
			RasterizedRelativeLength = Mathf.Clamp01(rasterizedRelativeLength);
			Resolution = resolution;
			AngleThreshold = angle;
			Mode = mode;
		}

		public CGDataRequestRasterization(CGDataRequestRasterization source)
			: this(source.Start, source.RasterizedRelativeLength, source.Resolution, source.AngleThreshold, source.Mode)
		{
		}

		public override bool Equals(object obj)
		{
			if (!(obj is CGDataRequestRasterization cGDataRequestRasterization))
			{
				return false;
			}
			if (Start == cGDataRequestRasterization.Start && RasterizedRelativeLength == cGDataRequestRasterization.RasterizedRelativeLength && Resolution == cGDataRequestRasterization.Resolution && AngleThreshold == cGDataRequestRasterization.AngleThreshold)
			{
				return Mode == cGDataRequestRasterization.Mode;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return new
			{
				A = Start,
				B = RasterizedRelativeLength,
				C = Resolution,
				D = AngleThreshold,
				E = Mode
			}.GetHashCode();
		}
	}
	public interface INoProcessing
	{
	}
	public interface IExternalInput
	{
		bool SupportsIPE { get; }
	}
	public interface IOnRequestProcessing
	{
		CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests);
	}
	public interface IPathProvider
	{
		bool PathIsClosed { get; }
	}
	[Obsolete("IOnRequestPath is an interface with no added value, and will get removed in a future update. Use IOnRequestProcessing or IPathProvider instead")]
	public interface IOnRequestPath : IOnRequestProcessing, IPathProvider
	{
	}
	public interface ICGResourceLoader
	{
		UnityEngine.Component Create(CGModule cgModule, string context);

		void Destroy(CGModule cgModule, UnityEngine.Component obj, string context, bool kill);
	}
	public interface ICGResourceCollection
	{
		int Count { get; }

		UnityEngine.Component[] ItemsArray { get; }
	}
	[RequireComponent(typeof(MeshRenderer))]
	[HelpURL("https://curvyeditor.com/doclink/cgmeshresource")]
	public class CGMeshResource : DuplicateEditorMesh, IPoolable
	{
		private MeshRenderer mRenderer;

		private Collider mCollider;

		public MeshRenderer Renderer
		{
			get
			{
				if (mRenderer == null)
				{
					mRenderer = GetComponent<MeshRenderer>();
				}
				return mRenderer;
			}
		}

		public Collider Collider
		{
			get
			{
				if (mCollider == null)
				{
					mCollider = GetComponent<Collider>();
				}
				return mCollider;
			}
		}

		public Mesh Prepare()
		{
			return base.Filter.PrepareNewShared();
		}

		public bool ColliderMatches(CGColliderEnum type)
		{
			if (Collider == null && type == CGColliderEnum.None)
			{
				return true;
			}
			if (Collider is MeshCollider && type == CGColliderEnum.Mesh)
			{
				return true;
			}
			if (Collider is BoxCollider && type == CGColliderEnum.Box)
			{
				return true;
			}
			if (Collider is SphereCollider && type == CGColliderEnum.Sphere)
			{
				return true;
			}
			if (Collider is CapsuleCollider && type == CGColliderEnum.Capsule)
			{
				return true;
			}
			return false;
		}

		public void RemoveCollider()
		{
			if ((bool)Collider)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(mCollider);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(mCollider);
				}
				mCollider = null;
			}
		}

		public bool UpdateCollider(CGColliderEnum mode, bool convex, bool isTrigger, PhysicMaterial material, MeshColliderCookingOptions meshCookingOptions = MeshColliderCookingOptions.CookForFasterSimulation | MeshColliderCookingOptions.EnableMeshCleaning | MeshColliderCookingOptions.WeldColocatedVertices)
		{
			if (Collider == null)
			{
				switch (mode)
				{
				case CGColliderEnum.Mesh:
					mCollider = base.gameObject.AddComponent<MeshCollider>();
					break;
				case CGColliderEnum.Box:
					mCollider = base.gameObject.AddComponent<BoxCollider>();
					break;
				case CGColliderEnum.Sphere:
					mCollider = base.gameObject.AddComponent<SphereCollider>();
					break;
				case CGColliderEnum.Capsule:
					mCollider = base.gameObject.AddComponent<CapsuleCollider>();
					break;
				default:
					throw new ArgumentOutOfRangeException();
				case CGColliderEnum.None:
					break;
				}
			}
			switch (mode)
			{
			case CGColliderEnum.Mesh:
			{
				MeshCollider meshCollider = Collider as MeshCollider;
				if (meshCollider != null)
				{
					meshCollider.sharedMesh = null;
					meshCollider.convex = convex;
					meshCollider.isTrigger = isTrigger;
					meshCollider.cookingOptions = meshCookingOptions;
					try
					{
						meshCollider.sharedMesh = base.Filter.sharedMesh;
					}
					catch
					{
						return false;
					}
				}
				else
				{
					DTLog.LogError("[Curvy] Collider of wrong type");
				}
				goto IL_0278;
			}
			case CGColliderEnum.Box:
			{
				BoxCollider boxCollider = Collider as BoxCollider;
				if (boxCollider != null)
				{
					boxCollider.isTrigger = isTrigger;
					boxCollider.center = base.Filter.sharedMesh.bounds.center;
					boxCollider.size = base.Filter.sharedMesh.bounds.size;
				}
				else
				{
					DTLog.LogError("[Curvy] Collider of wrong type");
				}
				goto IL_0278;
			}
			case CGColliderEnum.Sphere:
			{
				SphereCollider sphereCollider = Collider as SphereCollider;
				if (sphereCollider != null)
				{
					sphereCollider.isTrigger = isTrigger;
					sphereCollider.center = base.Filter.sharedMesh.bounds.center;
					sphereCollider.radius = base.Filter.sharedMesh.bounds.extents.magnitude;
				}
				else
				{
					DTLog.LogError("[Curvy] Collider of wrong type");
				}
				goto IL_0278;
			}
			case CGColliderEnum.Capsule:
			{
				CapsuleCollider capsuleCollider = Collider as CapsuleCollider;
				if (capsuleCollider != null)
				{
					Bounds bounds = base.Filter.sharedMesh.bounds;
					capsuleCollider.isTrigger = isTrigger;
					capsuleCollider.center = bounds.center;
					capsuleCollider.radius = new Vector2(bounds.extents.x, bounds.extents.y).magnitude;
					capsuleCollider.height = bounds.size.z;
					capsuleCollider.direction = 2;
				}
				else
				{
					DTLog.LogError("[Curvy] Collider of wrong type");
				}
				goto IL_0278;
			}
			default:
				throw new ArgumentOutOfRangeException();
			case CGColliderEnum.None:
				break;
				IL_0278:
				Collider.material = material;
				break;
			}
			return true;
		}

		public void OnBeforePush()
		{
		}

		public void OnAfterPop()
		{
		}
	}
	[Serializable]
	public class CGMeshResourceCollection : ICGResourceCollection
	{
		public List<CGMeshResource> Items = new List<CGMeshResource>();

		public int Count => Items.Count;

		public UnityEngine.Component[] ItemsArray => Items.ToArray();
	}
	[ExecuteInEditMode]
	public abstract class CGModule : DTVersionedMonoBehaviour
	{
		[Group("Events", Expanded = false, Sort = 1000)]
		[SerializeField]
		protected CurvyCGEvent m_OnBeforeRefresh = new CurvyCGEvent();

		[Group("Events")]
		[SerializeField]
		protected CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

		[SerializeField]
		[HideInInspector]
		private string m_ModuleName;

		[SerializeField]
		[HideInInspector]
		private bool m_Active = true;

		[Group("Seed Options", Expanded = false, Sort = 1001)]
		[GroupCondition("usesRandom")]
		[FieldAction("CBSeedOptions", ActionAttribute.ActionEnum.Callback, ShowBelowProperty = true)]
		[SerializeField]
		private bool m_RandomizeSeed;

		[SerializeField]
		[HideInInspector]
		private int m_Seed = (int)DateTime.Now.Ticks;

		[NonSerialized]
		public List<string> UIMessages = new List<string>();

		private CurvyGenerator mGenerator;

		[SerializeField]
		[HideInInspector]
		private int m_UniqueID;

		internal int SortAncestors;

		[HideInInspector]
		public CGModuleProperties Properties = new CGModuleProperties();

		[HideInInspector]
		public List<CGModuleLink> InputLinks = new List<CGModuleLink>();

		[HideInInspector]
		public List<CGModuleLink> OutputLinks = new List<CGModuleLink>();

		private ModuleInfoAttribute mInfo;

		private bool mDirty = true;

		private bool mInitialized;

		private bool mStateChangeDirty;

		private bool mLastIsConfiguredState;

		public CurvyCGEvent OnBeforeRefresh
		{
			get
			{
				return m_OnBeforeRefresh;
			}
			set
			{
				if (m_OnBeforeRefresh != value)
				{
					m_OnBeforeRefresh = value;
				}
			}
		}

		public CurvyCGEvent OnRefresh
		{
			get
			{
				return m_OnRefresh;
			}
			set
			{
				if (m_OnRefresh != value)
				{
					m_OnRefresh = value;
				}
			}
		}

		public string ModuleName
		{
			get
			{
				return base.name;
			}
			set
			{
				if (base.name != value)
				{
					base.name = value;
					renameManagedResourcesINTERNAL();
				}
			}
		}

		public bool Active
		{
			get
			{
				return m_Active;
			}
			set
			{
				if (m_Active != value)
				{
					m_Active = value;
					Dirty = true;
					Generator.sortModulesINTERNAL();
				}
			}
		}

		public int Seed
		{
			get
			{
				return m_Seed;
			}
			set
			{
				if (m_Seed != value)
				{
					m_Seed = value;
				}
				Dirty = true;
			}
		}

		public bool RandomizeSeed
		{
			get
			{
				return m_RandomizeSeed;
			}
			set
			{
				if (m_RandomizeSeed != value)
				{
					m_RandomizeSeed = value;
				}
			}
		}

		public CurvyGenerator Generator => mGenerator;

		public int UniqueID => m_UniqueID;

		public bool CircularReferenceError { get; set; }

		public Dictionary<string, CGModuleInputSlot> InputByName { get; private set; }

		public Dictionary<string, CGModuleOutputSlot> OutputByName { get; private set; }

		public List<CGModuleInputSlot> Input { get; private set; }

		public List<CGModuleOutputSlot> Output { get; private set; }

		public ModuleInfoAttribute Info
		{
			get
			{
				if (mInfo == null)
				{
					mInfo = getInfo();
				}
				return mInfo;
			}
		}

		public bool Dirty
		{
			get
			{
				return mDirty;
			}
			set
			{
				if (mDirty != value)
				{
					mDirty = value;
				}
				if (mDirty)
				{
					bool isConfigured = IsConfigured;
					if (mLastIsConfiguredState != isConfigured)
					{
						mStateChangeDirty = true;
					}
					mLastIsConfiguredState = isConfigured;
					if (Output != null)
					{
						for (int i = 0; i < Output.Count; i++)
						{
							if (!Output[i].IsLinked)
							{
								continue;
							}
							List<CGModule> linkedModules = Output[i].GetLinkedModules();
							for (int j = 0; j < linkedModules.Count; j++)
							{
								if (linkedModules[j] != this || linkedModules[j].CircularReferenceError)
								{
									linkedModules[j].Dirty = true;
								}
							}
						}
					}
				}
				if (!(this is IOnRequestProcessing) && !(this is INoProcessing))
				{
					return;
				}
				mDirty = false;
				if (Output != null)
				{
					for (int k = 0; k < Output.Count; k++)
					{
						Output[k].LastRequestParameters = null;
					}
				}
			}
		}

		public virtual bool IsConfigured
		{
			get
			{
				if (!IsInitialized || CircularReferenceError || !Active)
				{
					return false;
				}
				int num = 0;
				for (int i = 0; i < Input.Count; i++)
				{
					InputSlotInfo inputInfo = Input[i].InputInfo;
					if (Input[i].IsLinked)
					{
						for (int j = 0; j < Input[i].Count; j++)
						{
							if (Input[i].SourceSlot(j) != null)
							{
								if (Input[i].SourceSlot(j).Module.IsConfigured)
								{
									num++;
								}
								else if (!inputInfo.Optional)
								{
									return false;
								}
							}
						}
					}
					else if (inputInfo == null || !inputInfo.Optional)
					{
						return false;
					}
				}
				if (num <= 0)
				{
					return Input.Count == 0;
				}
				return true;
			}
		}

		public virtual bool IsInitialized => mInitialized;

		protected CurvyCGEventArgs OnBeforeRefreshEvent(CurvyCGEventArgs e)
		{
			if (OnBeforeRefresh != null)
			{
				OnBeforeRefresh.Invoke(e);
			}
			return e;
		}

		protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
		{
			if (OnRefresh != null)
			{
				OnRefresh.Invoke(e);
			}
			return e;
		}

		protected virtual void Awake()
		{
			mGenerator = RetrieveGenerator();
		}

		protected virtual void OnEnable()
		{
			if ((bool)mGenerator)
			{
				Initialize();
				Generator.sortModulesINTERNAL();
			}
		}

		public void Initialize()
		{
			if (!mGenerator)
			{
				mGenerator = RetrieveGenerator();
			}
			if (!mGenerator)
			{
				Invoke("Delete", 0f);
				return;
			}
			mInfo = getInfo();
			if (string.IsNullOrEmpty(ModuleName))
			{
				if (string.IsNullOrEmpty(Info.ModuleName))
				{
					ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.MenuName.Substring(Info.MenuName.LastIndexOf("/", StringComparison.Ordinal) + 1));
				}
				else
				{
					ModuleName = Generator.getUniqueModuleNameINTERNAL(Info.ModuleName);
				}
			}
			loadSlots();
			mInitialized = true;
		}

		protected virtual void OnDisable()
		{
		}

		protected virtual void OnDestroy()
		{
			setTreeDirtyStateChange();
			if (true && GetManagedResources(out var components, out var componentNames))
			{
				for (int num = components.Count - 1; num >= 0; num--)
				{
					DeleteManagedResource(componentNames[num], components[num], "", dontUsePool: true);
				}
			}
			foreach (CGModuleInputSlot inputSlot in GetInputSlots())
			{
				foreach (CGModule linkedModule in inputSlot.GetLinkedModules())
				{
					if (linkedModule != null)
					{
						linkedModule.ReInitializeLinkedSlots();
					}
				}
			}
			foreach (CGModuleOutputSlot outputSlot in GetOutputSlots())
			{
				foreach (CGModule linkedModule2 in outputSlot.GetLinkedModules())
				{
					if (linkedModule2 != null)
					{
						linkedModule2.ReInitializeLinkedSlots();
					}
				}
			}
			if ((bool)Generator)
			{
				Generator.ModulesByID.Remove(UniqueID);
				Generator.Modules.Remove(this);
				Generator.sortModulesINTERNAL();
			}
			mInitialized = false;
		}

		private void OnDidApplyAnimationProperties()
		{
			Dirty = true;
		}

		public virtual void Refresh()
		{
			UIMessages.Clear();
		}

		public virtual void Reset()
		{
			ModuleName = (string.IsNullOrEmpty(Info.ModuleName) ? GetType().Name : Info.ModuleName);
			if (OnBeforeRefresh != null)
			{
				OnBeforeRefresh.RemoveAllListeners();
			}
			if (OnRefresh != null)
			{
				OnRefresh.RemoveAllListeners();
			}
			OnBeforeRefresh = new CurvyCGEvent();
			OnRefresh = new CurvyCGEvent();
		}

		public void ReInitializeLinkedSlots()
		{
			List<CGModuleInputSlot> inputSlots = GetInputSlots();
			List<CGModuleOutputSlot> outputSlots = GetOutputSlots();
			for (int i = 0; i < inputSlots.Count; i++)
			{
				inputSlots[i].ReInitializeLinkedSlots();
			}
			for (int j = 0; j < outputSlots.Count; j++)
			{
				outputSlots[j].ReInitializeLinkedSlots();
			}
		}

		public virtual void OnStateChange()
		{
			Dirty = true;
			if (Output != null)
			{
				for (int i = 0; i < Output.Count; i++)
				{
					Output[i].ClearData();
				}
			}
		}

		public virtual void OnTemplateCreated()
		{
		}

		protected static T GetRequestParameter<T>(ref CGDataRequestParameter[] requests) where T : CGDataRequestParameter
		{
			for (int i = 0; i < requests.Length; i++)
			{
				if (requests[i] is T)
				{
					return (T)requests[i];
				}
			}
			return null;
		}

		protected static void RemoveRequestParameter(ref CGDataRequestParameter[] requests, CGDataRequestParameter request)
		{
			for (int i = 0; i < requests.Length; i++)
			{
				if (requests[i] == request)
				{
					requests = requests.RemoveAt(i);
					break;
				}
			}
		}

		public CGModuleLink GetOutputLink(CGModuleOutputSlot outSlot, CGModuleInputSlot inSlot)
		{
			return GetLink(OutputLinks, outSlot, inSlot);
		}

		public List<CGModuleLink> GetOutputLinks(CGModuleOutputSlot outSlot)
		{
			return GetLinks(OutputLinks, outSlot);
		}

		public CGModuleLink GetInputLink(CGModuleInputSlot inSlot, CGModuleOutputSlot outSlot)
		{
			return GetLink(InputLinks, inSlot, outSlot);
		}

		public List<CGModuleLink> GetInputLinks(CGModuleInputSlot inSlot)
		{
			return GetLinks(InputLinks, inSlot);
		}

		private static CGModuleLink GetLink(List<CGModuleLink> lst, CGModuleSlot source, CGModuleSlot target)
		{
			for (int i = 0; i < lst.Count; i++)
			{
				if (lst[i].IsSame(source, target))
				{
					return lst[i];
				}
			}
			return null;
		}

		private static List<CGModuleLink> GetLinks(List<CGModuleLink> lst, CGModuleSlot source)
		{
			List<CGModuleLink> list = new List<CGModuleLink>();
			for (int i = 0; i < lst.Count; i++)
			{
				if (lst[i].IsFrom(source))
				{
					list.Add(lst[i]);
				}
			}
			return list;
		}

		public CGModule CopyTo(CurvyGenerator targetGenerator)
		{
			CGModule cGModule = this.DuplicateGameObject<CGModule>(targetGenerator.transform);
			cGModule.mGenerator = targetGenerator;
			cGModule.Initialize();
			cGModule.ModuleName = ModuleName;
			cGModule.ModuleName = targetGenerator.getUniqueModuleNameINTERNAL(cGModule.ModuleName);
			cGModule.SetUniqueIdINTERNAL();
			cGModule.renameManagedResourcesINTERNAL();
			return cGModule;
		}

		public UnityEngine.Component AddManagedResource(string resourceName, string context = "", int index = -1)
		{
			UnityEngine.Component component = CGResourceHandler.CreateResource(this, resourceName, context);
			if (component == null)
			{
				throw new InvalidOperationException($"[Curvy] Could not create managed resource of type '{resourceName}'. In some cases this is due to not enough elements in a resources Pool");
			}
			RenameResource(resourceName + context, component, index);
			component.transform.SetParent(base.transform);
			return component;
		}

		public void DeleteManagedResource(string resourceName, UnityEngine.Component res, string context = "", bool dontUsePool = false)
		{
			if ((bool)res)
			{
				CGResourceHandler.DestroyResource(this, resourceName, res, context, dontUsePool);
			}
		}

		public bool IsManagedResource(UnityEngine.Component res)
		{
			if ((bool)res)
			{
				return res.transform.parent == base.transform;
			}
			return false;
		}

		protected void RenameResource(string resourceName, UnityEngine.Component resource, int index = -1)
		{
			string text = ((index > -1) ? string.Format(CultureInfo.InvariantCulture, "{0}_{1}_{2}{3:000}", ModuleName, UniqueID, resourceName, index) : string.Format(CultureInfo.InvariantCulture, "{0}_{1}_{2}", ModuleName, UniqueID, resourceName));
			if (resource.name != text)
			{
				resource.name = text;
			}
		}

		protected PrefabPool GetPrefabPool(GameObject prefab)
		{
			return Generator.PoolManager.GetPrefabPool(UniqueID.ToString(CultureInfo.InvariantCulture) + "_" + prefab.name, prefab);
		}

		public List<IPool> GetAllPrefabPools()
		{
			return Generator.PoolManager.FindPools(UniqueID.ToString(CultureInfo.InvariantCulture) + "_");
		}

		public void DeleteAllPrefabPools()
		{
			Generator.PoolManager.DeletePools(UniqueID.ToString(CultureInfo.InvariantCulture) + "_");
		}

		public void Delete()
		{
			OnStateChange();
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		public CGModuleInputSlot GetInputSlot(string name)
		{
			if (InputByName == null || !InputByName.ContainsKey(name))
			{
				return null;
			}
			return InputByName[name];
		}

		public List<CGModuleInputSlot> GetInputSlots(Type filterType = null)
		{
			if (filterType == null)
			{
				return new List<CGModuleInputSlot>(Input);
			}
			List<CGModuleInputSlot> list = new List<CGModuleInputSlot>();
			for (int i = 0; i < Output.Count; i++)
			{
				if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
				{
					list.Add(Input[i]);
				}
			}
			return list;
		}

		public CGModuleOutputSlot GetOutputSlot(string name)
		{
			if (OutputByName == null || !OutputByName.ContainsKey(name))
			{
				return null;
			}
			return OutputByName[name];
		}

		public List<CGModuleOutputSlot> GetOutputSlots(Type filterType = null)
		{
			if (filterType == null)
			{
				return new List<CGModuleOutputSlot>(Output);
			}
			List<CGModuleOutputSlot> list = new List<CGModuleOutputSlot>();
			for (int i = 0; i < Output.Count; i++)
			{
				if (Output[i].Info.DataTypes[0] == filterType || Output[i].Info.DataTypes[0].IsSubclassOf(filterType))
				{
					list.Add(Output[i]);
				}
			}
			return list;
		}

		public bool GetManagedResources(out List<UnityEngine.Component> components, out List<string> componentNames)
		{
			components = new List<UnityEngine.Component>();
			componentNames = new List<string>();
			FieldInfo[] allFields = GetType().GetAllFields(includeInherited: false, includePrivate: true);
			foreach (FieldInfo fieldInfo in allFields)
			{
				CGResourceManagerAttribute customAttribute = fieldInfo.GetCustomAttribute<CGResourceManagerAttribute>();
				if (customAttribute == null)
				{
					continue;
				}
				if (typeof(ICGResourceCollection).IsAssignableFrom(fieldInfo.FieldType))
				{
					if (!(fieldInfo.GetValue(this) is ICGResourceCollection { ItemsArray: var itemsArray }))
					{
						continue;
					}
					foreach (UnityEngine.Component component in itemsArray)
					{
						if ((bool)component && component.transform.parent == base.transform)
						{
							components.Add(component);
							componentNames.Add(customAttribute.ResourceName);
						}
					}
				}
				else
				{
					UnityEngine.Component component2 = fieldInfo.GetValue(this) as UnityEngine.Component;
					if ((bool)component2 && component2.transform.parent == base.transform)
					{
						components.Add(component2);
						componentNames.Add(customAttribute.ResourceName);
					}
				}
			}
			return components.Count > 0;
		}

		public int SetUniqueIdINTERNAL()
		{
			m_UniqueID = ++Generator.m_LastModuleID;
			return m_UniqueID;
		}

		internal void initializeSort()
		{
			SortAncestors = 0;
			CircularReferenceError = false;
			for (int i = 0; i < Input.Count; i++)
			{
				if (Input[i].IsLinked)
				{
					SortAncestors += Input[i].LinkedSlots.Count;
				}
			}
		}

		internal List<CGModule> decrementChilds()
		{
			List<CGModule> list = new List<CGModule>();
			for (int i = 0; i < Output.Count; i++)
			{
				for (int j = 0; j < Output[i].LinkedSlots.Count; j++)
				{
					if (--Output[i].LinkedSlots[j].Module.SortAncestors == 0)
					{
						list.Add(Output[i].LinkedSlots[j].Module);
					}
				}
			}
			return list;
		}

		internal void doRefresh()
		{
			if (RandomizeSeed)
			{
				UnityEngine.Random.InitState((int)DateTime.Now.Ticks);
			}
			else
			{
				UnityEngine.Random.InitState(Seed);
			}
			OnBeforeRefreshEvent(new CurvyCGEventArgs(this));
			Refresh();
			UnityEngine.Random.InitState((int)DateTime.Now.Ticks);
			OnRefreshEvent(new CurvyCGEventArgs(this));
			mDirty = false;
		}

		internal ModuleInfoAttribute getInfo()
		{
			object[] customAttributes = GetType().GetCustomAttributes(typeof(ModuleInfoAttribute), inherit: true);
			if (customAttributes.Length == 0)
			{
				return null;
			}
			return (ModuleInfoAttribute)customAttributes[0];
		}

		private bool usesRandom()
		{
			if (Info != null)
			{
				return Info.UsesRandom;
			}
			return false;
		}

		private void loadSlots()
		{
			InputByName = new Dictionary<string, CGModuleInputSlot>();
			OutputByName = new Dictionary<string, CGModuleOutputSlot>();
			Input = new List<CGModuleInputSlot>();
			Output = new List<CGModuleOutputSlot>();
			FieldInfo[] allFields = GetType().GetAllFields();
			foreach (FieldInfo fieldInfo in allFields)
			{
				if (fieldInfo.FieldType == typeof(CGModuleInputSlot))
				{
					CGModuleInputSlot cGModuleInputSlot = (CGModuleInputSlot)fieldInfo.GetValue(this);
					cGModuleInputSlot.Module = this;
					cGModuleInputSlot.Info = getSlotInfo(fieldInfo);
					cGModuleInputSlot.ReInitializeLinkedSlots();
					InputByName.Add(cGModuleInputSlot.Info.Name, cGModuleInputSlot);
					Input.Add(cGModuleInputSlot);
				}
				else if (fieldInfo.FieldType == typeof(CGModuleOutputSlot))
				{
					CGModuleOutputSlot cGModuleOutputSlot = (CGModuleOutputSlot)fieldInfo.GetValue(this);
					cGModuleOutputSlot.Module = this;
					cGModuleOutputSlot.Info = getSlotInfo(fieldInfo);
					cGModuleOutputSlot.ReInitializeLinkedSlots();
					OutputByName.Add(cGModuleOutputSlot.Info.Name, cGModuleOutputSlot);
					Output.Add(cGModuleOutputSlot);
				}
			}
		}

		private SlotInfo getSlotInfo(FieldInfo f)
		{
			SlotInfo customAttribute = f.GetCustomAttribute<SlotInfo>();
			if (customAttribute != null)
			{
				if (string.IsNullOrEmpty(customAttribute.Name))
				{
					customAttribute.Name = f.Name.TrimStart("In").TrimStart("Out");
				}
				for (int i = 0; i < customAttribute.DataTypes.Length; i++)
				{
					if (!customAttribute.DataTypes[i].IsSubclassOf(typeof(CGData)))
					{
						UnityEngine.Debug.LogError(string.Format(CultureInfo.InvariantCulture, "{0}, Slot '{1}': Data type needs to be subclass of CGData!", GetType().Name, customAttribute.Name));
					}
				}
				return customAttribute;
			}
			UnityEngine.Debug.LogError("The Slot '" + f.Name + "' of type '" + f.DeclaringType.Name + "' needs a SlotInfo attribute!");
			return null;
		}

		private void setTreeDirtyStateChange()
		{
			mStateChangeDirty = true;
			if (Output == null)
			{
				return;
			}
			for (int i = 0; i < Output.Count; i++)
			{
				if (!Output[i].IsLinked)
				{
					continue;
				}
				List<CGModule> linkedModules = Output[i].GetLinkedModules();
				for (int j = 0; j < linkedModules.Count; j++)
				{
					if (linkedModules[j] != this || linkedModules[j].CircularReferenceError)
					{
						linkedModules[j].setTreeDirtyStateChange();
					}
				}
			}
		}

		private CurvyGenerator RetrieveGenerator()
		{
			if (!(base.transform.parent != null))
			{
				return null;
			}
			return base.transform.parent.GetComponent<CurvyGenerator>();
		}

		public void checkOnStateChangedINTERNAL()
		{
			if (mStateChangeDirty)
			{
				OnStateChange();
			}
			mStateChangeDirty = false;
		}

		public void renameManagedResourcesINTERNAL()
		{
			FieldInfo[] allFields = GetType().GetAllFields(includeInherited: false, includePrivate: true);
			foreach (FieldInfo fieldInfo in allFields)
			{
				CGResourceManagerAttribute customAttribute = fieldInfo.GetCustomAttribute<CGResourceManagerAttribute>();
				if (customAttribute != null)
				{
					UnityEngine.Component component = fieldInfo.GetValue(this) as UnityEngine.Component;
					if ((bool)component && component.transform.parent == base.transform)
					{
						RenameResource(customAttribute.ResourceName, component);
					}
				}
			}
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class ModuleInfoAttribute : Attribute, IComparable
	{
		public readonly string MenuName;

		public string ModuleName;

		public string Description;

		public bool UsesRandom;

		public ModuleInfoAttribute(string name)
		{
			MenuName = name;
		}

		public int CompareTo(object obj)
		{
			return string.Compare(MenuName, ((ModuleInfoAttribute)obj).MenuName, StringComparison.Ordinal);
		}
	}
	[Serializable]
	public class CGModuleProperties
	{
		public Rect Dimensions;

		public float MinWidth = 250f;

		public float LabelWidth;

		public Color BackgroundColor = Color.black;
	}
	[Serializable]
	public class CGModuleLink
	{
		[SerializeField]
		private int m_ModuleID;

		[SerializeField]
		private string m_SlotName;

		[SerializeField]
		private int m_TargetModuleID;

		[SerializeField]
		private string m_TargetSlotName;

		public int ModuleID => m_ModuleID;

		public string SlotName => m_SlotName;

		public int TargetModuleID => m_TargetModuleID;

		public string TargetSlotName => m_TargetSlotName;

		public CGModuleLink(int sourceID, string sourceSlotName, int targetID, string targetSlotName)
		{
			m_ModuleID = sourceID;
			m_SlotName = sourceSlotName;
			m_TargetModuleID = targetID;
			m_TargetSlotName = targetSlotName;
		}

		public CGModuleLink(CGModuleSlot source, CGModuleSlot target)
			: this(source.Module.UniqueID, source.Name, target.Module.UniqueID, target.Name)
		{
		}

		public bool IsSame(CGModuleLink o)
		{
			if (ModuleID == o.ModuleID && SlotName == o.SlotName && TargetModuleID == o.TargetModuleID)
			{
				return TargetSlotName == o.m_TargetSlotName;
			}
			return false;
		}

		public bool IsSame(CGModuleSlot source, CGModuleSlot target)
		{
			if (ModuleID == source.Module.UniqueID && SlotName == source.Name && TargetModuleID == target.Module.UniqueID)
			{
				return TargetSlotName == target.Name;
			}
			return false;
		}

		public bool IsTo(CGModuleSlot s)
		{
			if (s.Module.UniqueID == TargetModuleID)
			{
				return s.Name == TargetSlotName;
			}
			return false;
		}

		public bool IsFrom(CGModuleSlot s)
		{
			if (s.Module.UniqueID == ModuleID)
			{
				return s.Name == SlotName;
			}
			return false;
		}

		public bool IsUsing(CGModule module)
		{
			if (ModuleID != module.UniqueID)
			{
				return TargetModuleID == module.UniqueID;
			}
			return true;
		}

		public bool IsBetween(CGModuleSlot one, CGModuleSlot another)
		{
			if (!IsTo(one) || !IsFrom(another))
			{
				if (IsTo(another))
				{
					return IsFrom(one);
				}
				return false;
			}
			return true;
		}

		public void SetModuleIDIINTERNAL(int moduleID, int targetModuleID)
		{
			m_ModuleID = moduleID;
			m_TargetModuleID = targetModuleID;
		}

		public static implicit operator bool(CGModuleLink a)
		{
			return a != null;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}({1})->{2}({3})", SlotName, ModuleID, TargetSlotName, TargetModuleID);
		}
	}
	public class CGModuleSlot
	{
		protected List<CGModuleSlot> mLinkedSlots;

		public CGModule Module { get; internal set; }

		public SlotInfo Info { get; internal set; }

		public Vector2 Origin { get; set; }

		public Rect DropZone { get; set; }

		public bool IsLinked
		{
			get
			{
				if (LinkedSlots != null)
				{
					return LinkedSlots.Count > 0;
				}
				return false;
			}
		}

		public bool IsLinkedAndConfigured
		{
			get
			{
				if (!IsLinked)
				{
					return false;
				}
				for (int i = 0; i < LinkedSlots.Count; i++)
				{
					if (!LinkedSlots[i].Module.IsConfigured)
					{
						return false;
					}
				}
				return true;
			}
		}

		public IOnRequestProcessing OnRequestModule => Module as IOnRequestProcessing;

		[Obsolete("IOnRequestPath is an interface with no added value, and will get removed in a future update. Use OnRequestModule or PathProvider instead")]
		public IOnRequestPath OnRequestPathModule => Module as IOnRequestPath;

		public IPathProvider PathProvider => Module as IPathProvider;

		public IExternalInput ExternalInput => Module as IExternalInput;

		public List<CGModuleSlot> LinkedSlots
		{
			get
			{
				if (mLinkedSlots == null)
				{
					LoadLinkedSlots();
				}
				return mLinkedSlots ?? new List<CGModuleSlot>();
			}
		}

		public int Count => LinkedSlots.Count;

		public string Name
		{
			get
			{
				if (Info == null)
				{
					return "";
				}
				return Info.Name;
			}
		}

		public bool HasLinkTo(CGModuleSlot other)
		{
			for (int i = 0; i < LinkedSlots.Count; i++)
			{
				if (LinkedSlots[i] == other)
				{
					return true;
				}
			}
			return false;
		}

		public List<CGModule> GetLinkedModules()
		{
			List<CGModule> list = new List<CGModule>();
			for (int i = 0; i < LinkedSlots.Count; i++)
			{
				list.Add(LinkedSlots[i].Module);
			}
			return list;
		}

		public virtual void LinkTo(CGModuleSlot other)
		{
			if ((bool)Module)
			{
				Module.Generator.sortModulesINTERNAL();
				Module.Dirty = true;
			}
			if ((bool)other.Module)
			{
				other.Module.Dirty = true;
			}
		}

		protected static void LinkInputAndOutput(CGModuleSlot inputSlot, CGModuleSlot outputSlot)
		{
			if ((!inputSlot.Info.Array || inputSlot.Info.ArrayType == SlotInfo.SlotArrayType.Hidden) && inputSlot.IsLinked)
			{
				inputSlot.UnlinkAll();
			}
			outputSlot.Module.OutputLinks.Add(new CGModuleLink(outputSlot, inputSlot));
			inputSlot.Module.InputLinks.Add(new CGModuleLink(inputSlot, outputSlot));
			if (!outputSlot.LinkedSlots.Contains(inputSlot))
			{
				outputSlot.LinkedSlots.Add(inputSlot);
			}
			if (!inputSlot.LinkedSlots.Contains(outputSlot))
			{
				inputSlot.LinkedSlots.Add(outputSlot);
			}
		}

		public virtual void UnlinkFrom(CGModuleSlot other)
		{
			if ((bool)Module)
			{
				Module.Generator.sortModulesINTERNAL();
				Module.Dirty = true;
			}
			if ((bool)other.Module)
			{
				other.Module.Dirty = true;
			}
		}

		public virtual void UnlinkAll()
		{
		}

		public void ReInitializeLinkedSlots()
		{
			mLinkedSlots = null;
		}

		protected virtual void LoadLinkedSlots()
		{
		}

		public static implicit operator bool(CGModuleSlot a)
		{
			return a != null;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}: {1}.{2}", GetType().Name, Module.name, Name);
		}
	}
	[Serializable]
	public class CGModuleInputSlot : CGModuleSlot
	{
		public InputSlotInfo InputInfo => base.Info as InputSlotInfo;

		protected override void LoadLinkedSlots()
		{
			if (!base.Module.Generator.IsInitialized)
			{
				return;
			}
			base.LoadLinkedSlots();
			mLinkedSlots = new List<CGModuleSlot>();
			foreach (CGModuleLink inputLink in base.Module.GetInputLinks(this))
			{
				CGModule module = base.Module.Generator.GetModule(inputLink.TargetModuleID, includeOnRequestProcessing: true);
				if ((bool)module)
				{
					CGModuleOutputSlot cGModuleOutputSlot = module.OutputByName[inputLink.TargetSlotName];
					if (!cGModuleOutputSlot.Module.GetOutputLink(cGModuleOutputSlot, this))
					{
						cGModuleOutputSlot.Module.OutputLinks.Add(new CGModuleLink(cGModuleOutputSlot, this));
						cGModuleOutputSlot.ReInitializeLinkedSlots();
					}
					if (!mLinkedSlots.Contains(cGModuleOutputSlot))
					{
						mLinkedSlots.Add(cGModuleOutputSlot);
					}
				}
				else
				{
					base.Module.InputLinks.Remove(inputLink);
				}
			}
		}

		public override void UnlinkAll()
		{
			foreach (CGModuleSlot item in new List<CGModuleSlot>(base.LinkedSlots))
			{
				UnlinkFrom(item);
			}
		}

		public override void LinkTo(CGModuleSlot outputSlot)
		{
			if (!HasLinkTo(outputSlot))
			{
				CGModuleSlot.LinkInputAndOutput(this, outputSlot);
				base.LinkTo(outputSlot);
			}
		}

		public override void UnlinkFrom(CGModuleSlot outputSlot)
		{
			if (HasLinkTo(outputSlot))
			{
				CGModuleOutputSlot outSlot = (CGModuleOutputSlot)outputSlot;
				CGModuleLink inputLink = base.Module.GetInputLink(this, outSlot);
				base.Module.InputLinks.Remove(inputLink);
				CGModuleLink outputLink = outputSlot.Module.GetOutputLink(outSlot, this);
				outputSlot.Module.OutputLinks.Remove(outputLink);
				base.LinkedSlots.Remove(outputSlot);
				outputSlot.LinkedSlots.Remove(this);
				base.UnlinkFrom(outputSlot);
			}
		}

		public CGModuleOutputSlot SourceSlot(int index = 0)
		{
			if (index >= base.Count || index < 0)
			{
				return null;
			}
			return (CGModuleOutputSlot)base.LinkedSlots[index];
		}

		public bool CanLinkTo(CGModuleOutputSlot source)
		{
			if (source.Module != base.Module)
			{
				return AreInputAndOutputSlotsCompatible(InputInfo, base.OnRequestModule != null, source.OutputInfo, source.OnRequestModule != null);
			}
			return false;
		}

		public static bool AreInputAndOutputSlotsCompatible(InputSlotInfo inputSlotInfo, bool inputSlotModuleIsOnRequest, OutputSlotInfo outputSlotInfo, bool outputSlotModuleIsOnRequest)
		{
			if (inputSlotInfo.IsValidFrom(outputSlotInfo.DataType))
			{
				if (!outputSlotModuleIsOnRequest || !(inputSlotInfo.RequestDataOnly || inputSlotModuleIsOnRequest))
				{
					if (!outputSlotModuleIsOnRequest)
					{
						return !inputSlotInfo.RequestDataOnly;
					}
					return false;
				}
				return true;
			}
			return false;
		}

		private CGModule SourceModule(int index)
		{
			if (index >= base.Count || index < 0)
			{
				return null;
			}
			return base.LinkedSlots[index].Module;
		}

		public T GetData<T>(params CGDataRequestParameter[] requests) where T : CGData
		{
			CGData[] data = GetData<T>(0, requests);
			if (data != null && data.Length != 0)
			{
				return data[0] as T;
			}
			return null;
		}

		public List<T> GetAllData<T>(params CGDataRequestParameter[] requests) where T : CGData
		{
			List<T> list = new List<T>();
			for (int i = 0; i < base.Count; i++)
			{
				CGData[] data = GetData<T>(i, requests);
				if (data != null)
				{
					if (!base.Info.Array)
					{
						list.Add(data[0] as T);
						break;
					}
					list.Capacity += data.Length;
					for (int j = 0; j < data.Length; j++)
					{
						list.Add(data[j] as T);
					}
				}
			}
			return list;
		}

		private CGData[] GetData<T>(int slotIndex, params CGDataRequestParameter[] requests) where T : CGData
		{
			CGModuleOutputSlot cGModuleOutputSlot = SourceSlot(slotIndex);
			if (cGModuleOutputSlot == null || !cGModuleOutputSlot.Module.Active)
			{
				return new CGData[0];
			}
			if (cGModuleOutputSlot.Module is IOnRequestProcessing)
			{
				bool flag = cGModuleOutputSlot.Data == null || cGModuleOutputSlot.Data.Length == 0;
				if (!flag && cGModuleOutputSlot.LastRequestParameters != null && cGModuleOutputSlot.LastRequestParameters.Length == requests.Length)
				{
					for (int i = 0; i < requests.Length; i++)
					{
						if (!requests[i].Equals(cGModuleOutputSlot.LastRequestParameters[i]))
						{
							flag = true;
							break;
						}
					}
				}
				else
				{
					flag = true;
				}
				if (flag)
				{
					cGModuleOutputSlot.LastRequestParameters = requests;
					cGModuleOutputSlot.Module.UIMessages.Clear();
					cGModuleOutputSlot.SetData(((IOnRequestProcessing)cGModuleOutputSlot.Module).OnSlotDataRequest(this, cGModuleOutputSlot, requests));
				}
			}
			if (!InputInfo.ModifiesData)
			{
				return cGModuleOutputSlot.Data;
			}
			return cloneData<T>(ref cGModuleOutputSlot.Data);
		}

		private static CGData[] cloneData<T>(ref CGData[] source) where T : CGData
		{
			T[] array = new T[source.Length];
			for (int i = 0; i < source.Length; i++)
			{
				array[i] = ((source[i] == null) ? null : source[i].Clone<T>());
			}
			return array;
		}
	}
	[Serializable]
	public class CGModuleOutputSlot : CGModuleSlot
	{
		public CGData[] Data = new CGData[0];

		public CGDataRequestParameter[] LastRequestParameters;

		public OutputSlotInfo OutputInfo => base.Info as OutputSlotInfo;

		public bool HasData
		{
			get
			{
				if (Data != null && Data.Length != 0)
				{
					return Data[0] != null;
				}
				return false;
			}
		}

		protected override void LoadLinkedSlots()
		{
			if (!base.Module.Generator.IsInitialized)
			{
				return;
			}
			base.LoadLinkedSlots();
			mLinkedSlots = new List<CGModuleSlot>();
			foreach (CGModuleLink outputLink in base.Module.GetOutputLinks(this))
			{
				CGModule module = base.Module.Generator.GetModule(outputLink.TargetModuleID, includeOnRequestProcessing: true);
				if ((bool)module)
				{
					CGModuleInputSlot cGModuleInputSlot = module.InputByName[outputLink.TargetSlotName];
					if (!cGModuleInputSlot.Module.GetInputLink(cGModuleInputSlot, this))
					{
						cGModuleInputSlot.Module.InputLinks.Add(new CGModuleLink(cGModuleInputSlot, this));
						cGModuleInputSlot.ReInitializeLinkedSlots();
					}
					if (!mLinkedSlots.Contains(cGModuleInputSlot))
					{
						mLinkedSlots.Add(cGModuleInputSlot);
					}
				}
				else
				{
					base.Module.OutputLinks.Remove(outputLink);
				}
			}
		}

		public override void LinkTo(CGModuleSlot inputSlot)
		{
			if (!HasLinkTo(inputSlot))
			{
				CGModuleSlot.LinkInputAndOutput(inputSlot, this);
				base.LinkTo(inputSlot);
			}
		}

		public override void UnlinkFrom(CGModuleSlot inputSlot)
		{
			if (HasLinkTo(inputSlot))
			{
				CGModuleInputSlot inSlot = (CGModuleInputSlot)inputSlot;
				CGModuleLink outputLink = base.Module.GetOutputLink(this, inSlot);
				base.Module.OutputLinks.Remove(outputLink);
				CGModuleLink inputLink = inputSlot.Module.GetInputLink(inSlot, this);
				inputSlot.Module.InputLinks.Remove(inputLink);
				base.LinkedSlots.Remove(inputSlot);
				inputSlot.LinkedSlots.Remove(this);
				base.UnlinkFrom(inputSlot);
			}
		}

		public void ClearData()
		{
			Data = new CGData[0];
		}

		public void SetData<T>(List<T> data) where T : CGData
		{
			if (data == null)
			{
				Data = new CGData[0];
				return;
			}
			if (!base.Info.Array && data.Count > 1)
			{
				UnityEngine.Debug.LogWarning("[Curvy] " + base.Module.GetType().Name + " (" + base.Info.Name + ") only supports a single data item! Either avoid calculating unnecessary data or define the slot as an array!");
			}
			CGData[] data2 = data.ToArray();
			Data = data2;
		}

		public void SetData(params CGData[] data)
		{
			Data = ((data == null) ? new CGData[0] : data);
		}

		public T GetData<T>() where T : CGData
		{
			if (Data.Length != 0)
			{
				return Data[0] as T;
			}
			return null;
		}

		public T[] GetAllData<T>() where T : CGData
		{
			return Data as T[];
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	public class SlotInfo : Attribute, IComparable
	{
		public enum SlotArrayType
		{
			Unknown,
			Normal,
			Hidden
		}

		public readonly Type[] DataTypes;

		public string Name;

		private string displayName;

		public string Tooltip;

		public bool Array;

		public SlotArrayType ArrayType = SlotArrayType.Normal;

		public string DisplayName
		{
			get
			{
				return displayName ?? Name;
			}
			set
			{
				displayName = value;
			}
		}

		protected SlotInfo(string name, params Type[] type)
		{
			DataTypes = type;
			Name = name;
		}

		protected SlotInfo(params Type[] type)
			: this(null, type)
		{
		}

		public int CompareTo(object obj)
		{
			return string.Compare(((SlotInfo)obj).Name, Name, StringComparison.Ordinal);
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class InputSlotInfo : SlotInfo
	{
		public bool RequestDataOnly;

		public bool Optional;

		public bool ModifiesData;

		public InputSlotInfo(string name, params Type[] type)
			: base(name, type)
		{
		}

		public InputSlotInfo(params Type[] type)
			: this(null, type)
		{
		}

		public bool IsValidFrom(Type outType)
		{
			for (int i = 0; i < DataTypes.Length; i++)
			{
				if (outType == DataTypes[i] || outType.IsSubclassOf(DataTypes[i]))
				{
					return true;
				}
			}
			return false;
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public class OutputSlotInfo : SlotInfo
	{
		public Type DataType => DataTypes[0];

		public OutputSlotInfo(Type type)
			: this(null, type)
		{
		}

		public OutputSlotInfo(string name, Type type)
			: base(name, type)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public class ShapeOutputSlotInfo : OutputSlotInfo
	{
		public bool OutputsVariableShape;

		public ShapeOutputSlotInfo()
			: this(null)
		{
		}

		public ShapeOutputSlotInfo(string name)
			: base(name, typeof(CGShape))
		{
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	public sealed class ResourceLoaderAttribute : Attribute
	{
		public readonly string ResourceName;

		public ResourceLoaderAttribute(string resName)
		{
			ResourceName = resName;
		}
	}
	public static class CGResourceHandler
	{
		private static Dictionary<string, ICGResourceLoader> Loader = new Dictionary<string, ICGResourceLoader>();

		public static UnityEngine.Component CreateResource(CGModule module, string resName, string context)
		{
			if (Loader.Count == 0)
			{
				getLoaders();
			}
			if (Loader.ContainsKey(resName))
			{
				return Loader[resName].Create(module, context);
			}
			UnityEngine.Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
			return null;
		}

		public static void DestroyResource(CGModule module, string resName, UnityEngine.Component obj, string context, bool kill)
		{
			if (Loader.Count == 0)
			{
				getLoaders();
			}
			if (Loader.ContainsKey(resName))
			{
				ICGResourceLoader iCGResourceLoader = Loader[resName];
				try
				{
					iCGResourceLoader.Destroy(module, obj, context, kill);
					return;
				}
				catch (InvalidOperationException ex)
				{
					if (ex.Message.IndexOf("prefab", StringComparison.OrdinalIgnoreCase) >= 0)
					{
						DTLog.LogError("[Curvy] Error while trying to destroy the object '" + obj.name + "'. This is probably because that object is part of a prefab instance, and Unity 2018.3 and beyond forbid deleting such objects without breaking the prefab link. Please remove the corresponding object from the prefab and try the faulty operation again.");
					}
					throw;
				}
			}
			UnityEngine.Debug.LogError("CGResourceHandler: Missing Loader for resource '" + resName + "'");
		}

		private static void getLoaders()
		{
			Type[] loadedTypes = TypeExt.GetLoadedTypes();
			Type typeFromHandle = typeof(ICGResourceLoader);
			Type[] array = loadedTypes;
			foreach (Type type in array)
			{
				if (!typeFromHandle.IsAssignableFrom(type) || !(typeFromHandle != type))
				{
					continue;
				}
				object[] customAttributes = type.GetCustomAttributes(typeof(ResourceLoaderAttribute), inherit: true);
				if (customAttributes.Length != 0)
				{
					ICGResourceLoader iCGResourceLoader = (ICGResourceLoader)Activator.CreateInstance(type);
					if (iCGResourceLoader != null)
					{
						Loader.Add(((ResourceLoaderAttribute)customAttributes[0]).ResourceName, iCGResourceLoader);
					}
				}
				else
				{
					DTLog.LogError($"[Curvy] Could not register resource loader of type {type.FullName} because it does not have a ResourceLoader attribute");
				}
			}
		}
	}
	[ResourceLoader("Spline")]
	public class CGSplineResourceLoader : ICGResourceLoader
	{
		public UnityEngine.Component Create(CGModule cgModule, string context)
		{
			CurvySpline curvySpline = CurvySpline.Create();
			curvySpline.transform.position = Vector3.zero;
			curvySpline.Closed = true;
			curvySpline.Add(new Vector3(0f, 0f, 0f), new Vector3(5f, 0f, 10f), new Vector3(-5f, 0f, 10f));
			return curvySpline;
		}

		public void Destroy(CGModule cgModule, UnityEngine.Component obj, string context, bool kill)
		{
			if (obj != null)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}
	}
	[ResourceLoader("Shape")]
	public class CGShapeResourceLoader : ICGResourceLoader
	{
		public UnityEngine.Component Create(CGModule cgModule, string context)
		{
			CurvySpline curvySpline = CurvySpline.Create();
			curvySpline.transform.position = Vector3.zero;
			curvySpline.RestrictTo2D = true;
			curvySpline.Closed = true;
			curvySpline.Orientation = CurvyOrientation.None;
			curvySpline.gameObject.AddComponent<CSCircle>().Refresh();
			return curvySpline;
		}

		public void Destroy(CGModule cgModule, UnityEngine.Component obj, string context, bool kill)
		{
			if (obj != null)
			{
				UnityEngine.Object.Destroy(obj);
			}
		}
	}
	[ResourceLoader("Mesh")]
	public class CGMeshResourceLoader : ICGResourceLoader
	{
		public UnityEngine.Component Create(CGModule cgModule, string context)
		{
			return cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Pop();
		}

		public void Destroy(CGModule cgModule, UnityEngine.Component obj, string context, bool kill)
		{
			if (!(obj != null))
			{
				return;
			}
			if (kill)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(obj.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(obj.gameObject);
				}
			}
			else
			{
				obj.StripComponents(typeof(CGMeshResource), typeof(MeshFilter), typeof(MeshRenderer));
				cgModule.Generator.PoolManager.GetComponentPool<CGMeshResource>().Push(obj);
			}
		}
	}
	[ResourceLoader("GameObject")]
	public class CGGameObjectResourceLoader : ICGResourceLoader
	{
		public UnityEngine.Component Create(CGModule cgModule, string context)
		{
			GameObject gameObject = cgModule.Generator.PoolManager.GetPrefabPool(context).Pop();
			if (!gameObject)
			{
				return null;
			}
			return gameObject.transform;
		}

		public void Destroy(CGModule cgModule, UnityEngine.Component obj, string context, bool kill)
		{
			if (!(obj != null))
			{
				return;
			}
			if (kill)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(obj.gameObject);
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(obj.gameObject);
				}
			}
			else
			{
				cgModule.Generator.PoolManager.GetPrefabPool(context).Push(obj.gameObject);
			}
		}
	}
	[Serializable]
	public class CGGameObjectResourceCollection : ICGResourceCollection
	{
		public List<Transform> Items = new List<Transform>();

		public List<string> PoolNames = new List<string>();

		public int Count => Items.Count;

		public UnityEngine.Component[] ItemsArray => Items.ToArray();
	}
	public static class CGUtility
	{
		public static Vector2[] CalculateUV2(Vector2[] uv)
		{
			Vector2[] array = new Vector2[uv.Length];
			float num = 0f;
			float num2 = 0f;
			for (int i = 0; i < uv.Length; i++)
			{
				num = ((num < uv[i].x) ? uv[i].x : num);
				num2 = ((num2 < uv[i].y) ? uv[i].y : num2);
			}
			float num3 = 1f / num;
			float num4 = 1f / num2;
			for (int j = 0; j < uv.Length; j++)
			{
				array[j].x = uv[j].x * num3;
				array[j].y = uv[j].y * num4;
			}
			return array;
		}

		public static List<ControlPointOption> GetControlPointsWithOptions(CGDataRequestMetaCGOptions options, CurvySpline shape, float startDist, float endDist, bool optimize, out int initialMaterialID, out float initialMaxStep)
		{
			List<ControlPointOption> list = new List<ControlPointOption>();
			initialMaterialID = 0;
			initialMaxStep = float.MaxValue;
			CurvySplineSegment curvySplineSegment = shape.DistanceToSegment(startDist);
			float num = shape.ClampDistance(endDist, shape.Closed ? CurvyClamping.Loop : CurvyClamping.Clamp);
			if (num == 0f)
			{
				num = endDist;
			}
			CurvySplineSegment curvySplineSegment2 = ((num == shape.Length) ? shape.LastVisibleControlPoint : shape.DistanceToSegment(num));
			if (endDist != shape.Length && endDist > curvySplineSegment2.Distance)
			{
				curvySplineSegment2 = shape.GetNextControlPoint(curvySplineSegment2);
			}
			float num2 = 0f;
			if ((bool)curvySplineSegment)
			{
				MetaCGOptions metadata = curvySplineSegment.GetMetadata<MetaCGOptions>(autoCreate: true);
				initialMaxStep = ((metadata.MaxStepDistance == 0f) ? float.MaxValue : metadata.MaxStepDistance);
				if (options.CheckMaterialID)
				{
					initialMaterialID = metadata.MaterialID;
				}
				int num3 = initialMaterialID;
				float num4 = metadata.MaxStepDistance;
				CurvySplineSegment curvySplineSegment3 = shape.GetNextSegment(curvySplineSegment) ?? shape.GetNextControlPoint(curvySplineSegment);
				do
				{
					metadata = curvySplineSegment3.GetMetadata<MetaCGOptions>(autoCreate: true);
					if (shape.GetControlPointIndex(curvySplineSegment3) < shape.GetControlPointIndex(curvySplineSegment))
					{
						num2 = shape.Length;
					}
					if (options.IncludeControlPoints || (options.CheckHardEdges && metadata.HardEdge) || (options.CheckMaterialID && metadata.MaterialID != num3) || (optimize && metadata.MaxStepDistance != num4) || (options.CheckExtendedUV && (metadata.UVEdge || metadata.ExplicitU)))
					{
						bool flag = metadata.MaterialID != num3;
						num4 = ((metadata.MaxStepDistance == 0f) ? float.MaxValue : metadata.MaxStepDistance);
						num3 = (options.CheckMaterialID ? metadata.MaterialID : initialMaterialID);
						list.Add(new ControlPointOption(curvySplineSegment3.TF + (float)Mathf.FloorToInt(num2 / shape.Length), curvySplineSegment3.Distance + num2, options.IncludeControlPoints, num3, options.CheckHardEdges && metadata.HardEdge, metadata.MaxStepDistance, (options.CheckExtendedUV && metadata.UVEdge) || flag, options.CheckExtendedUV && metadata.ExplicitU, metadata.FirstU, metadata.SecondU));
					}
					curvySplineSegment3 = shape.GetNextSegment(curvySplineSegment3);
				}
				while ((bool)curvySplineSegment3 && curvySplineSegment3 != curvySplineSegment2);
				if (options.CheckExtendedUV && !curvySplineSegment3 && shape.LastVisibleControlPoint == curvySplineSegment2)
				{
					metadata = curvySplineSegment2.GetMetadata<MetaCGOptions>(autoCreate: true);
					if (metadata.ExplicitU)
					{
						list.Add(new ControlPointOption(1f, curvySplineSegment2.Distance + num2, options.IncludeControlPoints, num3, options.CheckHardEdges && metadata.HardEdge, metadata.MaxStepDistance, (options.CheckExtendedUV && metadata.UVEdge) || (options.CheckMaterialID && metadata.MaterialID != num3), options.CheckExtendedUV && metadata.ExplicitU, metadata.FirstU, metadata.SecondU));
					}
				}
			}
			return list;
		}
	}
	[ExecuteInEditMode]
	[HelpURL("https://curvyeditor.com/doclink/generator")]
	[AddComponentMenu("Curvy/Generator", 3)]
	[RequireComponent(typeof(PoolManager))]
	public class CurvyGenerator : DTVersionedMonoBehaviour
	{
		[Tooltip("Show Debug Output?")]
		[SerializeField]
		private bool m_ShowDebug;

		[Tooltip("Whether to automatically refresh the generator's output when necessary")]
		[SerializeField]
		private bool m_AutoRefresh = true;

		[FieldCondition("m_AutoRefresh", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Play mode, in milliseconds")]
		[SerializeField]
		private int m_RefreshDelay;

		[FieldCondition("m_AutoRefresh", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Positive(Tooltip = "The minimum delay between two automatic generator's refreshing while in Edit mode, in milliseconds")]
		[SerializeField]
		private int m_RefreshDelayEditor = 10;

		[Section("Events", false, false, 1000, HelpURL = "https://curvyeditor.com/doclink/generator_events")]
		[SerializeField]
		protected CurvyCGEvent m_OnRefresh = new CurvyCGEvent();

		[HideInInspector]
		public List<CGModule> Modules = new List<CGModule>();

		[SerializeField]
		[HideInInspector]
		internal int m_LastModuleID;

		public Dictionary<int, CGModule> ModulesByID = new Dictionary<int, CGModule>();

		private bool mInitialized;

		private bool mInitializedPhaseOne;

		private bool mNeedSort = true;

		private double mLastUpdateTime;

		private PoolManager mPoolManager;

		private const int ModulesReorderingDeltaX = 50;

		private const int ModulesReorderingDeltaY = 20;

		public bool ShowDebug
		{
			get
			{
				return m_ShowDebug;
			}
			set
			{
				if (m_ShowDebug != value)
				{
					m_ShowDebug = value;
				}
			}
		}

		public bool AutoRefresh
		{
			get
			{
				return m_AutoRefresh;
			}
			set
			{
				if (m_AutoRefresh != value)
				{
					m_AutoRefresh = value;
				}
			}
		}

		public int RefreshDelay
		{
			get
			{
				return m_RefreshDelay;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_RefreshDelay != num)
				{
					m_RefreshDelay = num;
				}
			}
		}

		public int RefreshDelayEditor
		{
			get
			{
				return m_RefreshDelayEditor;
			}
			set
			{
				int num = Mathf.Max(0, value);
				if (m_RefreshDelayEditor != num)
				{
					m_RefreshDelayEditor = num;
				}
			}
		}

		public PoolManager PoolManager
		{
			get
			{
				if (mPoolManager == null)
				{
					mPoolManager = GetComponent<PoolManager>();
				}
				return mPoolManager;
			}
		}

		public CurvyCGEvent OnRefresh
		{
			get
			{
				return m_OnRefresh;
			}
			set
			{
				if (m_OnRefresh != value)
				{
					m_OnRefresh = value;
				}
			}
		}

		public bool IsInitialized => mInitialized;

		public bool Destroying { get; private set; }

		private void OnEnable()
		{
			PoolManager.AutoCreatePools = true;
		}

		private void OnDisable()
		{
			mInitialized = false;
			mInitializedPhaseOne = false;
			mNeedSort = true;
		}

		private void OnDestroy()
		{
			Destroying = true;
		}

		private void Update()
		{
			if (!IsInitialized)
			{
				Initialize();
			}
			else
			{
				TryAutoRefresh();
			}
		}

		public static CurvyGenerator Create()
		{
			return new GameObject("Curvy Generator", typeof(CurvyGenerator)).GetComponent<CurvyGenerator>();
		}

		public T AddModule<T>() where T : CGModule
		{
			return (T)AddModule(typeof(T));
		}

		public CGModule AddModule(Type type)
		{
			GameObject obj = new GameObject("");
			obj.transform.SetParent(base.transform, worldPositionStays: false);
			CGModule cGModule = (CGModule)obj.AddComponent(type);
			cGModule.SetUniqueIdINTERNAL();
			Modules.Add(cGModule);
			ModulesByID.Add(cGModule.UniqueID, cGModule);
			return cGModule;
		}

		public void ArrangeModules()
		{
			Vector2 vector = new Vector2(float.MaxValue, float.MaxValue);
			foreach (CGModule module in Modules)
			{
				vector.x = Mathf.Min(module.Properties.Dimensions.x, vector.x);
				vector.y = Mathf.Min(module.Properties.Dimensions.y, vector.y);
			}
			vector -= new Vector2(10f, 10f);
			foreach (CGModule module2 in Modules)
			{
				module2.Properties.Dimensions.x -= vector.x;
				module2.Properties.Dimensions.y -= vector.y;
			}
		}

		public void ReorderModules()
		{
			Dictionary<CGModule, Rect> dictionary = new Dictionary<CGModule, Rect>(Modules.Count);
			foreach (CGModule module in Modules)
			{
				dictionary[module] = module.Properties.Dimensions;
			}
			List<CGModule> list = Modules.Where((CGModule m) => !m.OutputLinks.Any()).ToList();
			Dictionary<CGModule, HashSet<CGModule>> dictionary2 = new Dictionary<CGModule, HashSet<CGModule>>(Modules.Count);
			foreach (CGModule item in list)
			{
				UpdateModulesRecursiveInputs(dictionary2, item);
			}
			HashSet<int> hashSet = new HashSet<int>();
			for (int i = 0; i < list.Count; i++)
			{
				float y = ((i == 0) ? 0f : (dictionary2[list[i - 1]].Max((CGModule m) => m.Properties.Dimensions.yMax) + 20f));
				CGModule cGModule = list[i];
				cGModule.Properties.Dimensions.position = new Vector2(0f, y);
				hashSet.Add(cGModule.UniqueID);
				ReorderEndpointRecursiveInputs(cGModule, hashSet, dictionary2);
			}
			ArrangeModules();
		}

		public void Clear()
		{
			clearModules();
		}

		public void DeleteModule(CGModule module)
		{
			if ((bool)module)
			{
				module.Delete();
			}
		}

		public List<T> FindModules<T>(bool includeOnRequestProcessing = false) where T : CGModule
		{
			List<T> list = new List<T>();
			for (int i = 0; i < Modules.Count; i++)
			{
				if (Modules[i] is T && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
				{
					list.Add((T)Modules[i]);
				}
			}
			return list;
		}

		public List<CGModule> GetModules(bool includeOnRequestProcessing = false)
		{
			if (includeOnRequestProcessing)
			{
				return new List<CGModule>(Modules);
			}
			List<CGModule> list = new List<CGModule>();
			for (int i = 0; i < Modules.Count; i++)
			{
				if (!(Modules[i] is IOnRequestProcessing))
				{
					list.Add(Modules[i]);
				}
			}
			return list;
		}

		public CGModule GetModule(int moduleID, bool includeOnRequestProcessing = false)
		{
			if (ModulesByID.TryGetValue(moduleID, out var value) && (includeOnRequestProcessing || !(value is IOnRequestProcessing)))
			{
				return value;
			}
			return null;
		}

		public T GetModule<T>(int moduleID, bool includeOnRequestProcessing = false) where T : CGModule
		{
			return GetModule(moduleID, includeOnRequestProcessing) as T;
		}

		public CGModule GetModule(string moduleName, bool includeOnRequestProcessing = false)
		{
			for (int i = 0; i < Modules.Count; i++)
			{
				if (Modules[i].ModuleName.Equals(moduleName, StringComparison.CurrentCultureIgnoreCase) && (includeOnRequestProcessing || !(Modules[i] is IOnRequestProcessing)))
				{
					return Modules[i];
				}
			}
			return null;
		}

		public T GetModule<T>(string moduleName, bool includeOnRequestProcessing = false) where T : CGModule
		{
			return GetModule(moduleName, includeOnRequestProcessing) as T;
		}

		public CGModuleOutputSlot GetModuleOutputSlot(int moduleId, string slotName)
		{
			CGModule module = GetModule(moduleId);
			if ((bool)module)
			{
				return module.GetOutputSlot(slotName);
			}
			return null;
		}

		public CGModuleOutputSlot GetModuleOutputSlot(string moduleName, string slotName)
		{
			CGModule module = GetModule(moduleName);
			if ((bool)module)
			{
				return module.GetOutputSlot(slotName);
			}
			return null;
		}

		public void Initialize(bool force = false)
		{
			if (!mInitializedPhaseOne || force)
			{
				ModulesByID.Clear();
				Modules.Clear();
				GetComponentsInChildren(Modules);
				Modules.RemoveAll((CGModule m) => m.transform.parent != base.transform);
				for (int i = 0; i < Modules.Count; i++)
				{
					if (!Modules[i].IsInitialized || force)
					{
						Modules[i].Initialize();
					}
					if (ModulesByID.ContainsKey(Modules[i].UniqueID))
					{
						UnityEngine.Debug.LogError("ID of '" + Modules[i].ModuleName + "' isn't unique!");
						return;
					}
					ModulesByID.Add(Modules[i].UniqueID, Modules[i]);
				}
				if (Modules.Count > 0)
				{
					sortModulesINTERNAL();
				}
				mInitializedPhaseOne = true;
			}
			for (int j = 0; j < Modules.Count; j++)
			{
				if (Modules[j] is IExternalInput && !Modules[j].IsInitialized)
				{
					return;
				}
			}
			mInitialized = true;
			mInitializedPhaseOne = false;
			mNeedSort |= force;
			Refresh(forceUpdate: true);
		}

		public void Refresh(bool forceUpdate = false)
		{
			if (!IsInitialized)
			{
				return;
			}
			if (mNeedSort)
			{
				doSortModules();
			}
			CGModule cGModule = null;
			for (int i = 0; i < Modules.Count; i++)
			{
				if (forceUpdate && Modules[i] is IOnRequestProcessing)
				{
					Modules[i].Dirty = true;
				}
				if (Modules[i] is INoProcessing || (!Modules[i].Dirty && (!forceUpdate || Modules[i] is IOnRequestProcessing)))
				{
					continue;
				}
				Modules[i].checkOnStateChangedINTERNAL();
				if (!Modules[i].IsInitialized || !Modules[i].IsConfigured)
				{
					continue;
				}
				if (cGModule == null)
				{
					cGModule = Modules[i];
				}
				foreach (CGModuleInputSlot item in Modules[i].Input)
				{
					foreach (CGModuleSlot linkedSlot in item.LinkedSlots)
					{
						if (linkedSlot.Module.IsConfigured && linkedSlot.Module.Dirty)
						{
							DTLog.LogError("[Curvy] Getting data from a dirty module. This shouldn't happen at all. Please raise a bug report. Source module is " + linkedSlot.Module);
						}
					}
				}
				Modules[i].doRefresh();
			}
			if (cGModule != null)
			{
				OnRefreshEvent(new CurvyCGEventArgs(this, cGModule));
			}
		}

		public void TryAutoRefresh()
		{
			if (AutoRefresh && Application.isPlaying && DTTime.TimeSinceStartup - mLastUpdateTime > (double)((float)RefreshDelay * 0.001f))
			{
				mLastUpdateTime = DTTime.TimeSinceStartup;
				Refresh();
			}
		}

		protected CurvyCGEventArgs OnRefreshEvent(CurvyCGEventArgs e)
		{
			if (OnRefresh != null)
			{
				OnRefresh.Invoke(e);
			}
			return e;
		}

		private void clearModules()
		{
			for (int num = Modules.Count - 1; num >= 0; num--)
			{
				if (Application.isPlaying)
				{
					UnityEngine.Object.Destroy(Modules[num].gameObject);
				}
			}
			Modules.Clear();
			ModulesByID.Clear();
			m_LastModuleID = 0;
		}

		public string getUniqueModuleNameINTERNAL(string name)
		{
			string text = name;
			int num = 1;
			bool flag;
			do
			{
				flag = true;
				foreach (CGModule module in Modules)
				{
					if (module.ModuleName.Equals(text, StringComparison.CurrentCultureIgnoreCase))
					{
						text = name + num++.ToString(CultureInfo.InvariantCulture);
						flag = false;
						break;
					}
				}
			}
			while (!flag);
			return text;
		}

		internal void sortModulesINTERNAL()
		{
			mNeedSort = true;
		}

		private bool doSortModules()
		{
			List<CGModule> list = new List<CGModule>(Modules);
			List<CGModule> list2 = new List<CGModule>();
			List<CGModule> list3 = new List<CGModule>();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				list[num].initializeSort();
				if (list[num] is INoProcessing)
				{
					list3.Add(list[num]);
					list.RemoveAt(num);
				}
				else if (list[num].SortAncestors == 0)
				{
					list2.Add(list[num]);
					list.RemoveAt(num);
				}
			}
			Modules.Clear();
			int num2 = 0;
			while (list2.Count > 0)
			{
				CGModule cGModule = list2[0];
				list2.RemoveAt(0);
				List<CGModule> list4 = cGModule.decrementChilds();
				list2.AddRange(list4);
				for (int i = 0; i < list4.Count; i++)
				{
					list.Remove(list4[i]);
				}
				Modules.Add(cGModule);
				cGModule.transform.SetSiblingIndex(num2++);
			}
			for (int j = 0; j < list.Count; j++)
			{
				list[j].CircularReferenceError = true;
			}
			Modules.AddRange(list);
			Modules.AddRange(list3);
			mNeedSort = false;
			return list.Count > 0;
		}

		private static void ReorderEndpointRecursiveInputs(CGModule endPoint, HashSet<int> reordredModuleIds, Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs)
		{
			float num = endPoint.Properties.Dimensions.xMin - 50f;
			float num2 = endPoint.Properties.Dimensions.yMin;
			foreach (CGModule item in endPoint.Input.SelectMany((CGModuleInputSlot i) => i.GetLinkedModules()).ToList())
			{
				float num3 = num - item.Properties.Dimensions.width;
				if (!reordredModuleIds.Contains(item.UniqueID))
				{
					item.Properties.Dimensions.position = new Vector2(num3, num2);
					reordredModuleIds.Add(item.UniqueID);
					ReorderEndpointRecursiveInputs(item, reordredModuleIds, modulesRecursiveInputs);
				}
				else if (num3 < item.Properties.Dimensions.xMin)
				{
					item.Properties.Dimensions.position = new Vector2(num3, item.Properties.Dimensions.yMin);
					ReorderEndpointRecursiveInputs(item, reordredModuleIds, modulesRecursiveInputs);
				}
				num2 = Math.Max(num2, modulesRecursiveInputs[item].Max((CGModule m) => m.Properties.Dimensions.yMax) + 20f);
			}
		}

		private static HashSet<CGModule> UpdateModulesRecursiveInputs(Dictionary<CGModule, HashSet<CGModule>> modulesRecursiveInputs, CGModule moduleToAdd)
		{
			if (modulesRecursiveInputs.ContainsKey(moduleToAdd))
			{
				return modulesRecursiveInputs[moduleToAdd];
			}
			List<CGModule> source = moduleToAdd.Input.SelectMany((CGModuleInputSlot i) => i.GetLinkedModules()).ToList();
			HashSet<CGModule> hashSet = new HashSet<CGModule>();
			hashSet.Add(moduleToAdd);
			hashSet.UnionWith(source.SelectMany((CGModule i) => UpdateModulesRecursiveInputs(modulesRecursiveInputs, i)));
			modulesRecursiveInputs[moduleToAdd] = hashSet;
			return hashSet;
		}
	}
}
namespace FluffyUnderware.Curvy.Generator.Modules
{
	[ModuleInfo("Build/Rasterize Path", ModuleName = "Rasterize Path", Description = "Rasterizes a virtual path")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildrasterizedpath")]
	public class BuildRasterizedPath : CGModule, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path", RequestDataOnly = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath), Name = "Path", DisplayName = "Rasterized Path")]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[FloatRegion(UseSlider = true, RegionOptionsPropertyName = "RangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_Range = FloatRegion.ZeroOne;

		[SerializeField]
		[RangeEx(1f, 100f, "Resolution", "Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
		private int m_Resolution = 50;

		[SerializeField]
		private bool m_Optimize;

		[FieldCondition("m_Optimize", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[RangeEx(0.1f, 120f, "", "")]
		private float m_AngleTreshold = 10f;

		public float From
		{
			get
			{
				return m_Range.From;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_Range.From != num)
				{
					m_Range.From = num;
				}
				base.Dirty = true;
			}
		}

		public float To
		{
			get
			{
				return m_Range.To;
			}
			set
			{
				float num = Mathf.Max(From, value);
				if (PathIsClosed)
				{
					num = Mathf.Repeat(value, 1f);
				}
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public float Length
		{
			get
			{
				if (!PathIsClosed)
				{
					return m_Range.To;
				}
				return m_Range.To - m_Range.From;
			}
			set
			{
				float num = (PathIsClosed ? (value - m_Range.To) : value);
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public int Resolution
		{
			get
			{
				return m_Resolution;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_Resolution != num)
				{
					m_Resolution = num;
				}
				base.Dirty = true;
			}
		}

		public bool Optimize
		{
			get
			{
				return m_Optimize;
			}
			set
			{
				if (m_Optimize != value)
				{
					m_Optimize = value;
				}
				base.Dirty = true;
			}
		}

		public float AngleThreshold
		{
			get
			{
				return m_AngleTreshold;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.1f, 120f);
				if (m_AngleTreshold != num)
				{
					m_AngleTreshold = num;
				}
				base.Dirty = true;
			}
		}

		public CGPath Path => OutPath.GetData<CGPath>();

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return true;
				}
				return InPath.SourceSlot().PathProvider.PathIsClosed;
			}
		}

		private RegionOptions<float> RangeOptions
		{
			get
			{
				if (!PathIsClosed)
				{
					return RegionOptions<float>.MinMax(0f, 1f);
				}
				RegionOptions<float> result = default(RegionOptions<float>);
				result.LabelFrom = "Start";
				result.ClampFrom = DTValueClamping.Min;
				result.FromMin = 0f;
				result.LabelTo = "Length";
				result.ClampTo = DTValueClamping.Range;
				result.ToMin = 0f;
				result.ToMax = 1f;
				return result;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			Properties.LabelWidth = 100f;
		}

		public override void Reset()
		{
			base.Reset();
			m_Range = FloatRegion.ZeroOne;
			Resolution = 50;
			AngleThreshold = 10f;
			OutPath.ClearData();
			Optimize = false;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (Length == 0f)
			{
				Reset();
				return;
			}
			List<CGDataRequestParameter> list = new List<CGDataRequestParameter>();
			list.Add(new CGDataRequestRasterization(From, Length, Resolution, AngleThreshold, Optimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
			CGPath data = InPath.GetData<CGPath>(list.ToArray());
			OutPath.SetData(data);
		}
	}
	[ModuleInfo("Build/Shape Extrusion", ModuleName = "Shape Extrusion", Description = "Simple Shape Extrusion")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildshapeextrusion")]
	public class BuildShapeExtrusion : CGModule, IPathProvider
	{
		public enum ScaleModeEnum
		{
			Simple,
			Advanced
		}

		public enum CrossShiftModeEnum
		{
			None,
			ByOrientation,
			Custom
		}

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, RequestDataOnly = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Array = true, ArrayType = SlotInfo.SlotArrayType.Hidden, RequestDataOnly = true)]
		public CGModuleInputSlot InCross = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVolume))]
		public CGModuleOutputSlot OutVolume = new CGModuleOutputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVolume))]
		public CGModuleOutputSlot OutVolumeHollow = new CGModuleOutputSlot();

		[Tab("Path")]
		[FloatRegion(UseSlider = true, RegionOptionsPropertyName = "RangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_Range = FloatRegion.ZeroOne;

		[SerializeField]
		[RangeEx(1f, 100f, "Resolution", "Defines how densely the path spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
		private int m_Resolution = 50;

		[SerializeField]
		private bool m_Optimize = true;

		[FieldCondition("m_Optimize", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[RangeEx(0.1f, 120f, "", "", Tooltip = "Max angle")]
		private float m_AngleThreshold = 10f;

		[Tab("Cross")]
		[FieldAction("CBEditCrossButton", ActionAttribute.ActionEnum.Callback, Position = ActionAttribute.ActionPositionEnum.Above)]
		[FloatRegion(UseSlider = true, RegionOptionsPropertyName = "CrossRangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_CrossRange = FloatRegion.ZeroOne;

		[SerializeField]
		[RangeEx(1f, 100f, "Resolution", "", Tooltip = "Defines how densely the cross spline's sampling points are. When the value is 100, the number of sampling points per world distance unit is equal to the spline's Max Points Per Unit")]
		private int m_CrossResolution = 50;

		[SerializeField]
		[Label("Optimize", "")]
		private bool m_CrossOptimize = true;

		[FieldCondition("m_CrossOptimize", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[RangeEx(0.1f, 120f, "Angle Threshold", "", Tooltip = "Max angle")]
		private float m_CrossAngleThreshold = 10f;

		[SerializeField]
		[Label("Include CP", "")]
		private bool m_CrossIncludeControlpoints;

		[SerializeField]
		[Label("Hard Edges", "")]
		private bool m_CrossHardEdges;

		[SerializeField]
		[Label("Materials", "")]
		private bool m_CrossMaterials;

		[SerializeField]
		[Label("Extended UV", "")]
		private bool m_CrossExtendedUV;

		[SerializeField]
		[Label("Shift", "", Tooltip = "Defines a shift to be applied on the output volume's cross.\r\nThis shift is used when interpolating values (position, normal, ...) along the volume's surface.")]
		private CrossShiftModeEnum m_CrossShiftMode = CrossShiftModeEnum.ByOrientation;

		[SerializeField]
		[RangeEx(0f, 1f, "Value", "Shift By", Slider = true)]
		[FieldCondition("m_CrossShiftMode", CrossShiftModeEnum.Custom, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private float m_CrossShiftValue;

		[Label("Reverse Normal", "Reverse Vertex Normals?")]
		[SerializeField]
		private bool m_CrossReverseNormals;

		[Tab("Scale")]
		[Label("Mode", "")]
		[SerializeField]
		private ScaleModeEnum m_ScaleMode;

		[FieldCondition("m_ScaleMode", ScaleModeEnum.Advanced, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Label("Reference", "")]
		[SerializeField]
		private CGReferenceMode m_ScaleReference = CGReferenceMode.Self;

		[FieldCondition("m_ScaleMode", ScaleModeEnum.Advanced, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Label("Offset", "")]
		[SerializeField]
		private float m_ScaleOffset;

		[SerializeField]
		[Label("Uniform Scaling", "", Tooltip = "The same scaling value is applied on all dimensions")]
		private bool m_ScaleUniform = true;

		[SerializeField]
		private float m_ScaleX = 1f;

		[SerializeField]
		[FieldCondition("m_ScaleUniform", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		private float m_ScaleY = 1f;

		[SerializeField]
		[FieldCondition("m_ScaleMode", ScaleModeEnum.Advanced, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[AnimationCurveEx("Multiplier X", "")]
		[Tooltip("Defines scale multiplier depending on the TF, the relative position of a point on the path")]
		private AnimationCurve m_ScaleCurveX = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[SerializeField]
		[FieldCondition("m_ScaleUniform", false, false, FluffyUnderware.DevTools.ConditionalAttribute.OperatorEnum.AND, "m_ScaleMode", ScaleModeEnum.Advanced, false)]
		[AnimationCurveEx("Multiplier Y", "")]
		[Tooltip("Defines scale multiplier depending on the TF, the relative position of a point on the path")]
		private AnimationCurve m_ScaleCurveY = AnimationCurve.Linear(0f, 1f, 1f, 1f);

		[Tab("Hollow")]
		[RangeEx(0f, 1f, "", "", Slider = true, Label = "Inset")]
		[SerializeField]
		private float m_HollowInset;

		[Label("Reverse Normal", "Reverse Vertex Normals?")]
		[SerializeField]
		private bool m_HollowReverseNormals;

		public float From
		{
			get
			{
				return m_Range.From;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_Range.From != num)
				{
					m_Range.From = num;
				}
				base.Dirty = true;
			}
		}

		public float To
		{
			get
			{
				return m_Range.To;
			}
			set
			{
				float num = Mathf.Max(From, value);
				if (ClampPath)
				{
					num = DTMath.Repeat(value, 1f);
				}
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public float Length
		{
			get
			{
				if (!ClampPath)
				{
					return m_Range.To;
				}
				return m_Range.To - m_Range.From;
			}
			set
			{
				float num = (ClampPath ? (value - m_Range.To) : value);
				if (m_Range.To != num)
				{
					m_Range.To = num;
				}
				base.Dirty = true;
			}
		}

		public int Resolution
		{
			get
			{
				return m_Resolution;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_Resolution != num)
				{
					m_Resolution = num;
				}
				base.Dirty = true;
			}
		}

		public bool Optimize
		{
			get
			{
				return m_Optimize;
			}
			set
			{
				if (m_Optimize != value)
				{
					m_Optimize = value;
				}
				base.Dirty = true;
			}
		}

		public float AngleThreshold
		{
			get
			{
				return m_AngleThreshold;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.1f, 120f);
				if (m_AngleThreshold != num)
				{
					m_AngleThreshold = num;
				}
				base.Dirty = true;
			}
		}

		public float CrossFrom
		{
			get
			{
				return m_CrossRange.From;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_CrossRange.From != num)
				{
					m_CrossRange.From = num;
				}
				base.Dirty = true;
			}
		}

		public float CrossTo
		{
			get
			{
				return m_CrossRange.To;
			}
			set
			{
				float num = Mathf.Max(CrossFrom, value);
				if (ClampCross)
				{
					num = DTMath.Repeat(value, 1f);
				}
				if (m_CrossRange.To != num)
				{
					m_CrossRange.To = num;
				}
				base.Dirty = true;
			}
		}

		public float CrossLength
		{
			get
			{
				if (!ClampCross)
				{
					return m_CrossRange.To;
				}
				return m_CrossRange.To - m_CrossRange.From;
			}
			set
			{
				float num = (ClampCross ? (value - m_CrossRange.To) : value);
				if (m_CrossRange.To != num)
				{
					m_CrossRange.To = num;
				}
				base.Dirty = true;
			}
		}

		public int CrossResolution
		{
			get
			{
				return m_CrossResolution;
			}
			set
			{
				int num = Mathf.Clamp(value, 1, 100);
				if (m_CrossResolution != num)
				{
					m_CrossResolution = num;
				}
				base.Dirty = true;
			}
		}

		public bool CrossOptimize
		{
			get
			{
				return m_CrossOptimize;
			}
			set
			{
				if (m_CrossOptimize != value)
				{
					m_CrossOptimize = value;
				}
				base.Dirty = true;
			}
		}

		public float CrossAngleThreshold
		{
			get
			{
				return m_CrossAngleThreshold;
			}
			set
			{
				float num = Mathf.Clamp(value, 0.1f, 120f);
				if (m_CrossAngleThreshold != num)
				{
					m_CrossAngleThreshold = num;
				}
				base.Dirty = true;
			}
		}

		public bool CrossIncludeControlPoints
		{
			get
			{
				return m_CrossIncludeControlpoints;
			}
			set
			{
				if (m_CrossIncludeControlpoints != value)
				{
					m_CrossIncludeControlpoints = value;
				}
				base.Dirty = true;
			}
		}

		public bool CrossHardEdges
		{
			get
			{
				return m_CrossHardEdges;
			}
			set
			{
				if (m_CrossHardEdges != value)
				{
					m_CrossHardEdges = value;
				}
				base.Dirty = true;
			}
		}

		public bool CrossMaterials
		{
			get
			{
				return m_CrossMaterials;
			}
			set
			{
				if (m_CrossMaterials != value)
				{
					m_CrossMaterials = value;
				}
				base.Dirty = true;
			}
		}

		public bool CrossExtendedUV
		{
			get
			{
				return m_CrossExtendedUV;
			}
			set
			{
				if (m_CrossExtendedUV != value)
				{
					m_CrossExtendedUV = value;
				}
				base.Dirty = true;
			}
		}

		public CrossShiftModeEnum CrossShiftMode
		{
			get
			{
				return m_CrossShiftMode;
			}
			set
			{
				if (m_CrossShiftMode != value)
				{
					m_CrossShiftMode = value;
				}
				base.Dirty = true;
			}
		}

		public float CrossShiftValue
		{
			get
			{
				return m_CrossShiftValue;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_CrossShiftValue != num)
				{
					m_CrossShiftValue = num;
				}
				base.Dirty = true;
			}
		}

		public bool CrossReverseNormals
		{
			get
			{
				return m_CrossReverseNormals;
			}
			set
			{
				if (m_CrossReverseNormals != value)
				{
					m_CrossReverseNormals = value;
				}
				base.Dirty = true;
			}
		}

		public ScaleModeEnum ScaleMode
		{
			get
			{
				return m_ScaleMode;
			}
			set
			{
				if (m_ScaleMode != value)
				{
					m_ScaleMode = value;
				}
				base.Dirty = true;
			}
		}

		public CGReferenceMode ScaleReference
		{
			get
			{
				return m_ScaleReference;
			}
			set
			{
				if (m_ScaleReference != value)
				{
					m_ScaleReference = value;
				}
				base.Dirty = true;
			}
		}

		public bool ScaleUniform
		{
			get
			{
				return m_ScaleUniform;
			}
			set
			{
				if (m_ScaleUniform != value)
				{
					m_ScaleUniform = value;
				}
				base.Dirty = true;
			}
		}

		public float ScaleOffset
		{
			get
			{
				return m_ScaleOffset;
			}
			set
			{
				if (m_ScaleOffset != value)
				{
					m_ScaleOffset = value;
				}
				base.Dirty = true;
			}
		}

		public float ScaleX
		{
			get
			{
				return m_ScaleX;
			}
			set
			{
				if (m_ScaleX != value)
				{
					m_ScaleX = value;
				}
				base.Dirty = true;
			}
		}

		public float ScaleY
		{
			get
			{
				return m_ScaleY;
			}
			set
			{
				if (m_ScaleY != value)
				{
					m_ScaleY = value;
				}
				base.Dirty = true;
			}
		}

		public AnimationCurve ScaleMultiplierX
		{
			get
			{
				return m_ScaleCurveX;
			}
			set
			{
				if (m_ScaleCurveX != value)
				{
					m_ScaleCurveX = value;
				}
				base.Dirty = true;
			}
		}

		public AnimationCurve ScaleMultiplierY
		{
			get
			{
				return m_ScaleCurveY;
			}
			set
			{
				if (m_ScaleCurveY != value)
				{
					m_ScaleCurveY = value;
				}
				base.Dirty = true;
			}
		}

		public float HollowInset
		{
			get
			{
				return m_HollowInset;
			}
			set
			{
				float num = Mathf.Clamp01(value);
				if (m_HollowInset != num)
				{
					m_HollowInset = num;
				}
				base.Dirty = true;
			}
		}

		public bool HollowReverseNormals
		{
			get
			{
				return m_HollowReverseNormals;
			}
			set
			{
				if (m_HollowReverseNormals != value)
				{
					m_HollowReverseNormals = value;
				}
				base.Dirty = true;
			}
		}

		public int PathSamples { get; private set; }

		public int CrossSamples { get; private set; }

		public int CrossGroups { get; private set; }

		public IExternalInput Cross
		{
			get
			{
				if (!IsConfigured)
				{
					return null;
				}
				return InCross.SourceSlot().ExternalInput;
			}
		}

		public Vector3 CrossPosition { get; protected set; }

		public Quaternion CrossRotation { get; protected set; }

		public bool PathIsClosed => InPath.SourceSlot().PathProvider.PathIsClosed;

		private bool ClampPath
		{
			get
			{
				if (!InPath.IsLinked)
				{
					return true;
				}
				return !InPath.SourceSlot().PathProvider.PathIsClosed;
			}
		}

		private bool ClampCross
		{
			get
			{
				if (!InCross.IsLinked)
				{
					return true;
				}
				return !InCross.SourceSlot().PathProvider.PathIsClosed;
			}
		}

		private RegionOptions<float> RangeOptions
		{
			get
			{
				if (ClampPath)
				{
					return RegionOptions<float>.MinMax(0f, 1f);
				}
				RegionOptions<float> result = default(RegionOptions<float>);
				result.LabelFrom = "Start";
				result.ClampFrom = DTValueClamping.Min;
				result.FromMin = 0f;
				result.LabelTo = "Length";
				result.ClampTo = DTValueClamping.Range;
				result.ToMin = 0f;
				result.ToMax = 1f;
				return result;
			}
		}

		private RegionOptions<float> CrossRangeOptions
		{
			get
			{
				if (ClampCross)
				{
					return RegionOptions<float>.MinMax(0f, 1f);
				}
				RegionOptions<float> result = default(RegionOptions<float>);
				result.LabelFrom = "Start";
				result.ClampFrom = DTValueClamping.Min;
				result.FromMin = 0f;
				result.LabelTo = "Length";
				result.ClampTo = DTValueClamping.Range;
				result.ToMin = 0f;
				result.ToMax = 1f;
				return result;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 270f;
			Properties.LabelWidth = 100f;
		}

		public override void Reset()
		{
			base.Reset();
			From = 0f;
			To = 1f;
			Resolution = 50;
			AngleThreshold = 10f;
			Optimize = true;
			CrossFrom = 0f;
			CrossTo = 1f;
			CrossResolution = 50;
			CrossAngleThreshold = 10f;
			CrossOptimize = true;
			CrossIncludeControlPoints = false;
			CrossHardEdges = false;
			CrossMaterials = false;
			CrossShiftMode = CrossShiftModeEnum.ByOrientation;
			ScaleMode = ScaleModeEnum.Simple;
			ScaleUniform = true;
			ScaleX = 1f;
			ScaleY = 1f;
			ScaleMultiplierX = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			ScaleMultiplierY = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			HollowInset = 0f;
			CrossExtendedUV = false;
			CrossReverseNormals = false;
			HollowReverseNormals = false;
			ScaleReference = CGReferenceMode.Self;
			ScaleOffset = 0f;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (Length == 0f)
			{
				OutVolume.SetData((CGData[])null);
				OutVolumeHollow.SetData((CGData[])null);
				return;
			}
			List<CGDataRequestParameter> list = new List<CGDataRequestParameter>();
			list.Add(new CGDataRequestRasterization(From, Length, Resolution, AngleThreshold, Optimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
			CGPath data = InPath.GetData<CGPath>(list.ToArray());
			list.Clear();
			CGDataRequestRasterization item = ((InCross.LinkedSlots.Count != 1 || !(InCross.LinkedSlots[0].Info is ShapeOutputSlotInfo) || !(InCross.LinkedSlots[0].Info as ShapeOutputSlotInfo).OutputsVariableShape || !data) ? new CGDataRequestRasterization(CrossFrom, CrossLength, CrossResolution, CrossAngleThreshold, CrossOptimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even) : new CGDataRequestShapeRasterization(data.F, CrossFrom, CrossLength, CrossResolution, CrossAngleThreshold, CrossOptimize ? CGDataRequestRasterization.ModeEnum.Optimized : CGDataRequestRasterization.ModeEnum.Even));
			list.Add(item);
			if (CrossIncludeControlPoints || CrossHardEdges || CrossMaterials)
			{
				list.Add(new CGDataRequestMetaCGOptions(CrossHardEdges, CrossMaterials, CrossIncludeControlPoints, CrossExtendedUV));
			}
			List<CGShape> allData = InCross.GetAllData<CGShape>(list.ToArray());
			bool flag = !data || data.Count == 0;
			List<int> source = allData.Select((CGShape c) => c?.Count ?? 0).Distinct().ToList();
			bool flag2;
			if (source.Count() != 1 || source.First() == 0)
			{
				flag2 = true;
				UIMessages.Add("Shape Extrusion: All input Crosses are expected to have the same non zero number of sample points.");
			}
			else
			{
				flag2 = false;
			}
			if (flag || flag2)
			{
				OutVolume.ClearData();
				OutVolumeHollow.ClearData();
				return;
			}
			CGShape cGShape = allData[0];
			CGVolume cGVolume = CGVolume.Get(OutVolume.GetData<CGVolume>(), data, cGShape);
			CGVolume cGVolume2 = (OutVolumeHollow.IsLinked ? CGVolume.Get(OutVolumeHollow.GetData<CGVolume>(), data, cGShape) : null);
			bool flag3 = cGVolume2;
			PathSamples = data.Count;
			CrossSamples = cGShape.Count;
			CrossGroups = cGShape.MaterialGroups.Count;
			CrossPosition = cGVolume.Position[0];
			CrossRotation = Quaternion.LookRotation(cGVolume.Direction[0], cGVolume.Normal[0]);
			Vector3 vector = (ScaleUniform ? new Vector3(ScaleX, ScaleX, 1f) : new Vector3(ScaleX, ScaleY, 1f));
			Vector3 scale = vector;
			int num = 0;
			float[] array = ((ScaleReference == CGReferenceMode.Source) ? data.SourceF : data.F);
			float num2 = ((!CrossReverseNormals) ? 1 : (-1));
			float num3 = ((!HollowReverseNormals) ? 1 : (-1));
			bool flag4 = allData.Count == 1;
			int count = data.Count;
			for (int i = 0; i < count; i++)
			{
				CGShape cGShape2;
				if (flag4)
				{
					cGShape2 = cGShape;
				}
				else
				{
					int index = Mathf.RoundToInt((float)(allData.Count - 1) * data.F[i]);
					cGShape2 = allData[index];
				}
				Vector3[] position = cGShape2.Position;
				Vector3[] normal = cGShape2.Normal;
				Quaternion quaternion = Quaternion.LookRotation(data.Direction[i], data.Normal[i]);
				getScaleInternal(array[i], vector, ref scale);
				Matrix4x4 matrix4x = Matrix4x4.TRS(data.Position[i], quaternion, scale);
				Matrix4x4 matrix4x2 = (flag3 ? Matrix4x4.TRS(data.Position[i], quaternion, scale * (1f - HollowInset)) : default(Matrix4x4));
				int count2 = cGShape2.Count;
				for (int j = 0; j < count2; j++)
				{
					cGVolume.Vertex[num] = matrix4x.MultiplyPoint(position[j]);
					Vector3 vector2 = quaternion * normal[j];
					cGVolume.VertexNormal[num].x = vector2.x * num2;
					cGVolume.VertexNormal[num].y = vector2.y * num2;
					cGVolume.VertexNormal[num].z = vector2.z * num2;
					if (flag3)
					{
						cGVolume2.Vertex[num] = matrix4x2.MultiplyPoint(position[j]);
						cGVolume2.VertexNormal[num].x = vector2.x * num3;
						cGVolume2.VertexNormal[num].y = vector2.y * num3;
						cGVolume2.VertexNormal[num].z = vector2.z * num3;
					}
					num++;
				}
			}
			switch (CrossShiftMode)
			{
			case CrossShiftModeEnum.ByOrientation:
			{
				cGVolume.CrossFShift = 0f;
				for (int k = 0; k < cGShape.Count - 1; k++)
				{
					if (DTMath.RayLineSegmentIntersection(cGVolume.Position[0], cGVolume.Normal[0], cGVolume.Vertex[k], cGVolume.Vertex[k + 1], out var _, out var frag))
					{
						cGVolume.CrossFShift = DTMath.SnapPrecision(cGVolume.CrossF[k] + (cGVolume.CrossF[k + 1] - cGVolume.CrossF[k]) * frag, 2);
						break;
					}
				}
				break;
			}
			case CrossShiftModeEnum.Custom:
				cGVolume.CrossFShift = CrossShiftValue;
				break;
			case CrossShiftModeEnum.None:
				cGVolume.CrossFShift = 0f;
				break;
			default:
				throw new ArgumentOutOfRangeException("CrossShiftMode");
			}
			if (cGVolume2 != null)
			{
				cGVolume2.CrossFShift = cGVolume.CrossFShift;
			}
			OutVolume.SetData(cGVolume);
			OutVolumeHollow.SetData(cGVolume2);
		}

		public Vector3 GetScale(float f)
		{
			Vector3 baseScale = (ScaleUniform ? new Vector3(ScaleX, ScaleX, 1f) : new Vector3(ScaleX, ScaleY, 1f));
			Vector3 scale = Vector3.zero;
			getScaleInternal(f, baseScale, ref scale);
			return scale;
		}

		private void getScaleInternal(float f, Vector3 baseScale, ref Vector3 scale)
		{
			if (ScaleMode == ScaleModeEnum.Advanced)
			{
				float time = DTMath.Repeat(f - ScaleOffset, 1f);
				float num = baseScale.x * ScaleMultiplierX.Evaluate(time);
				scale.Set(num, m_ScaleUniform ? num : (baseScale.y * ScaleMultiplierY.Evaluate(time)), 1f);
			}
			else
			{
				scale = baseScale;
			}
		}
	}
	[ModuleInfo("Build/Volume Caps", ModuleName = "Volume Caps", Description = "Build volume caps")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildvolumecaps")]
	public class BuildVolumeCaps : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) })]
		public CGModuleInputSlot InVolume = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) }, Optional = true, Array = true)]
		public CGModuleInputSlot InVolumeHoles = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		[Tab("General")]
		[SerializeField]
		private CGYesNoAuto m_StartCap = CGYesNoAuto.Auto;

		[SerializeField]
		private CGYesNoAuto m_EndCap = CGYesNoAuto.Auto;

		[SerializeField]
		[FormerlySerializedAs("m_ReverseNormals")]
		private bool m_ReverseTriOrder;

		[SerializeField]
		private bool m_GenerateUV = true;

		[Tab("Start Cap")]
		[Inline]
		[SerializeField]
		private CGMaterialSettings m_StartMaterialSettings = new CGMaterialSettings();

		[Label("Material", "")]
		[SerializeField]
		private Material m_StartMaterial;

		[Tab("End Cap")]
		[SerializeField]
		private bool m_CloneStartCap = true;

		[AsGroup(null, Invisible = true)]
		[GroupCondition("m_CloneStartCap", false, false)]
		[SerializeField]
		private CGMaterialSettings m_EndMaterialSettings = new CGMaterialSettings();

		[Group("Default/End Cap")]
		[Label("Material", "")]
		[FieldCondition("m_CloneStartCap", false, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private Material m_EndMaterial;

		public bool GenerateUV
		{
			get
			{
				return m_GenerateUV;
			}
			set
			{
				if (m_GenerateUV != value)
				{
					m_GenerateUV = value;
				}
				base.Dirty = true;
			}
		}

		public bool ReverseTriOrder
		{
			get
			{
				return m_ReverseTriOrder;
			}
			set
			{
				if (m_ReverseTriOrder != value)
				{
					m_ReverseTriOrder = value;
				}
				base.Dirty = true;
			}
		}

		public CGYesNoAuto StartCap
		{
			get
			{
				return m_StartCap;
			}
			set
			{
				if (m_StartCap != value)
				{
					m_StartCap = value;
				}
				base.Dirty = true;
			}
		}

		public Material StartMaterial
		{
			get
			{
				return m_StartMaterial;
			}
			set
			{
				if (m_StartMaterial != value)
				{
					m_StartMaterial = value;
				}
				base.Dirty = true;
			}
		}

		public CGMaterialSettings StartMaterialSettings => m_StartMaterialSettings;

		public CGYesNoAuto EndCap
		{
			get
			{
				return m_EndCap;
			}
			set
			{
				if (m_EndCap != value)
				{
					m_EndCap = value;
				}
				base.Dirty = true;
			}
		}

		public bool CloneStartCap
		{
			get
			{
				return m_CloneStartCap;
			}
			set
			{
				if (m_CloneStartCap != value)
				{
					m_CloneStartCap = value;
				}
				base.Dirty = true;
			}
		}

		public CGMaterialSettings EndMaterialSettings => m_EndMaterialSettings;

		public Material EndMaterial
		{
			get
			{
				return m_EndMaterial;
			}
			set
			{
				if (m_EndMaterial != value)
				{
					m_EndMaterial = value;
				}
				base.Dirty = true;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			if (StartMaterial == null)
			{
				StartMaterial = CurvyUtility.GetDefaultMaterial();
			}
			if (EndMaterial == null)
			{
				EndMaterial = CurvyUtility.GetDefaultMaterial();
			}
		}

		public override void Reset()
		{
			base.Reset();
			StartCap = CGYesNoAuto.Auto;
			EndCap = CGYesNoAuto.Auto;
			ReverseTriOrder = false;
			GenerateUV = true;
			m_StartMaterialSettings = new CGMaterialSettings();
			m_EndMaterialSettings = new CGMaterialSettings();
			StartMaterial = CurvyUtility.GetDefaultMaterial();
			EndMaterial = CurvyUtility.GetDefaultMaterial();
			CloneStartCap = true;
		}

		public override void Refresh()
		{
			base.Refresh();
			CGVolume data = InVolume.GetData<CGVolume>(Array.Empty<CGDataRequestParameter>());
			List<CGVolume> allData = InVolumeHoles.GetAllData<CGVolume>(Array.Empty<CGDataRequestParameter>());
			if (!data)
			{
				return;
			}
			bool flag = StartCap == CGYesNoAuto.Yes || (StartCap == CGYesNoAuto.Auto && !data.Seamless);
			bool flag2 = EndCap == CGYesNoAuto.Yes || (EndCap == CGYesNoAuto.Auto && !data.Seamless);
			if (!flag && !flag2)
			{
				OutVMesh.SetData((CGData[])null);
				return;
			}
			CGVMesh cGVMesh = new CGVMesh();
			Vector3[] array = new Vector3[0];
			Vector3[] array2 = new Vector3[0];
			cGVMesh.AddSubMesh(new CGVSubMesh());
			CGVSubMesh cGVSubMesh = cGVMesh.SubMeshes[0];
			if (flag)
			{
				Tess tess = new Tess();
				tess.UsePooling = true;
				tess.AddContour(make2DSegment(data, 0));
				for (int i = 0; i < allData.Count; i++)
				{
					if (allData[i].Count < 3)
					{
						OutVMesh.SetData((CGData[])null);
						UIMessages.Add("Hole Cross has less than 3 Vertices: Can't create Caps!");
						return;
					}
					tess.AddContour(make2DSegment(allData[i], 0));
				}
				tess.Tessellate(WindingRule.EvenOdd, ElementType.Polygons, 3);
				array = UnityLibTessUtility.FromContourVertex(tess.Vertices);
				int num = 0;
				cGVMesh.Vertex = applyMatrix(array, getMatrix(data, num, inverse: true), out var bounds);
				Vector3[] array3 = new Vector3[cGVMesh.Vertex.Length];
				Vector3 vector = -data.Direction[num];
				for (int j = 0; j < array3.Length; j++)
				{
					array3[j] = vector;
				}
				cGVMesh.Normal = array3;
				cGVSubMesh.Material = StartMaterial;
				cGVSubMesh.Triangles = tess.Elements;
				if (ReverseTriOrder)
				{
					flipTris(ref cGVSubMesh.Triangles, 0, cGVSubMesh.Triangles.Length);
				}
				if (GenerateUV)
				{
					cGVMesh.UV = new Vector2[array.Length];
					applyUV(array, ref cGVMesh.UV, 0, array.Length, StartMaterialSettings, bounds);
				}
			}
			if (flag2)
			{
				Tess tess2 = new Tess();
				tess2.UsePooling = true;
				tess2.AddContour(make2DSegment(data, data.Count - 1));
				for (int k = 0; k < allData.Count; k++)
				{
					if (allData[k].Count < 3)
					{
						OutVMesh.SetData((CGData[])null);
						UIMessages.Add("Hole Cross has <3 Vertices: Can't create Caps!");
						return;
					}
					tess2.AddContour(make2DSegment(allData[k], allData[k].Count - 1));
				}
				tess2.Tessellate(WindingRule.EvenOdd, ElementType.Polygons, 3);
				array2 = UnityLibTessUtility.FromContourVertex(tess2.Vertices);
				int num2 = cGVMesh.Vertex.Length;
				int num3 = data.Count - 1;
				cGVMesh.Vertex = cGVMesh.Vertex.AddRange(applyMatrix(array2, getMatrix(data, num3, inverse: true), out var bounds2));
				Vector3[] array4 = new Vector3[num2];
				Vector3 vector2 = data.Direction[num3];
				for (int l = 0; l < array4.Length; l++)
				{
					array4[l] = vector2;
				}
				cGVMesh.Normal = cGVMesh.Normal.AddRange(array4);
				int[] indices = tess2.Elements;
				if (!ReverseTriOrder)
				{
					flipTris(ref indices, 0, indices.Length);
				}
				for (int m = 0; m < indices.Length; m++)
				{
					indices[m] += num2;
				}
				if (!CloneStartCap && StartMaterial != EndMaterial)
				{
					cGVMesh.AddSubMesh(new CGVSubMesh(indices, EndMaterial));
				}
				else
				{
					cGVSubMesh.Material = StartMaterial;
					cGVSubMesh.Triangles = cGVSubMesh.Triangles.AddRange(indices);
				}
				if (GenerateUV)
				{
					Array.Resize(ref cGVMesh.UV, cGVMesh.UV.Length + array2.Length);
					applyUV(array2, ref cGVMesh.UV, array.Length, array2.Length, CloneStartCap ? StartMaterialSettings : EndMaterialSettings, bounds2);
				}
			}
			OutVMesh.SetData(cGVMesh);
		}

		private static Matrix4x4 getMatrix(CGVolume vol, int index, bool inverse)
		{
			if (inverse)
			{
				Quaternion q = Quaternion.LookRotation(vol.Direction[index], vol.Normal[index]);
				return Matrix4x4.TRS(vol.Position[index], q, Vector3.one);
			}
			Quaternion quaternion = Quaternion.Inverse(Quaternion.LookRotation(vol.Direction[index], vol.Normal[index]));
			return Matrix4x4.TRS(-(quaternion * vol.Position[index]), quaternion, Vector3.one);
		}

		private static void flipTris(ref int[] indices, int start, int end)
		{
			for (int i = start; i < end; i += 3)
			{
				int num = indices[i];
				indices[i] = indices[i + 2];
				indices[i + 2] = num;
			}
		}

		private static Vector3[] applyMatrix(Vector3[] vt, Matrix4x4 matrix, out Bounds bounds)
		{
			Vector3[] array = new Vector3[vt.Length];
			float num = float.MaxValue;
			float num2 = float.MaxValue;
			float num3 = float.MinValue;
			float num4 = float.MinValue;
			for (int i = 0; i < vt.Length; i++)
			{
				num = Mathf.Min(vt[i].x, num);
				num2 = Mathf.Min(vt[i].y, num2);
				num3 = Mathf.Max(vt[i].x, num3);
				num4 = Mathf.Max(vt[i].y, num4);
				array[i] = matrix.MultiplyPoint(vt[i]);
			}
			Vector3 size = new Vector3(Mathf.Abs(num3 - num), Mathf.Abs(num4 - num2));
			bounds = new Bounds(new Vector3(num + size.x / 2f, num2 + size.y / 2f, 0f), size);
			return array;
		}

		private static ContourVertex[] make2DSegment(CGVolume vol, int segmentIndex)
		{
			Matrix4x4 matrix = getMatrix(vol, segmentIndex, inverse: false);
			int segmentIndex2 = vol.GetSegmentIndex(segmentIndex);
			ContourVertex[] array = new ContourVertex[vol.CrossSize];
			for (int i = 0; i < vol.CrossSize; i++)
			{
				array[i] = matrix.MultiplyPoint(vol.Vertex[segmentIndex2 + i]).ContourVertex();
			}
			return array;
		}

		private static void applyUV(Vector3[] vts, ref Vector2[] uvArray, int index, int count, CGMaterialSettings mat, Bounds bounds)
		{
			float x = bounds.size.x;
			float y = bounds.size.y;
			float x2 = bounds.min.x;
			float y2 = bounds.min.y;
			float num = mat.UVScale.x;
			float num2 = mat.UVScale.y;
			switch (mat.KeepAspect)
			{
			case CGKeepAspectMode.ScaleU:
			{
				float num5 = x * mat.UVScale.x;
				float num6 = y * mat.UVScale.y;
				num *= num5 / num6;
				break;
			}
			case CGKeepAspectMode.ScaleV:
			{
				float num3 = x * mat.UVScale.x;
				float num4 = y * mat.UVScale.y;
				num2 *= num4 / num3;
				break;
			}
			}
			bool swapUV = mat.SwapUV;
			if (mat.UVRotation != 0f)
			{
				float f = mat.UVRotation * ((float)Math.PI / 180f);
				float num7 = Mathf.Sin(f);
				float num8 = Mathf.Cos(f);
				float num9 = num * 0.5f;
				float num10 = num2 * 0.5f;
				for (int i = 0; i < count; i++)
				{
					float num11 = (vts[i].x - x2) / x * num;
					float num12 = (vts[i].y - y2) / y * num2;
					float num13 = num11 - num9;
					float num14 = num12 - num10;
					num11 = num8 * num13 - num7 * num14 + num9 + mat.UVOffset.x;
					num12 = num7 * num13 + num8 * num14 + num10 + mat.UVOffset.y;
					int num15 = i + index;
					uvArray[num15].x = (swapUV ? num12 : num11);
					uvArray[num15].y = (swapUV ? num11 : num12);
				}
			}
			else
			{
				for (int j = 0; j < count; j++)
				{
					float num11 = mat.UVOffset.x + (vts[j].x - x2) / x * num;
					float num12 = mat.UVOffset.y + (vts[j].y - y2) / y * num2;
					int num16 = j + index;
					uvArray[num16].x = (swapUV ? num12 : num11);
					uvArray[num16].y = (swapUV ? num11 : num12);
				}
			}
		}
	}
	[ModuleInfo("Build/Volume Mesh", ModuleName = "Volume Mesh", Description = "Build a volume mesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgbuildvolumemesh")]
	public class BuildVolumeMesh : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) })]
		public CGModuleInputSlot InVolume = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		[Tab("General")]
		[SerializeField]
		private bool m_GenerateUV = true;

		[SerializeField]
		private bool m_Split;

		[Positive(MinValue = 1f)]
		[FieldCondition("m_Split", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		private float m_SplitLength = 100f;

		[FieldAction("CBAddMaterial", ActionAttribute.ActionEnum.Callback)]
		[SerializeField]
		[FormerlySerializedAs("m_ReverseNormals")]
		private bool m_ReverseTriOrder;

		[SerializeField]
		[HideInInspector]
		private List<CGMaterialSettingsEx> m_MaterialSettings = new List<CGMaterialSettingsEx>();

		[SerializeField]
		[HideInInspector]
		private Material[] m_Material = new Material[0];

		private List<SamplePointsMaterialGroupCollection> groupsByMatID;

		public bool GenerateUV
		{
			get
			{
				return m_GenerateUV;
			}
			set
			{
				if (m_GenerateUV != value)
				{
					m_GenerateUV = value;
				}
				base.Dirty = true;
			}
		}

		public bool ReverseTriOrder
		{
			get
			{
				return m_ReverseTriOrder;
			}
			set
			{
				if (m_ReverseTriOrder != value)
				{
					m_ReverseTriOrder = value;
				}
				base.Dirty = true;
			}
		}

		public bool Split
		{
			get
			{
				return m_Split;
			}
			set
			{
				if (m_Split != value)
				{
					m_Split = value;
				}
				base.Dirty = true;
			}
		}

		public float SplitLength
		{
			get
			{
				return m_SplitLength;
			}
			set
			{
				float num = Mathf.Max(1f, value);
				if (m_SplitLength != num)
				{
					m_SplitLength = num;
				}
				base.Dirty = true;
			}
		}

		public List<CGMaterialSettingsEx> MaterialSetttings => m_MaterialSettings;

		public int MaterialCount => m_MaterialSettings.Count;

		protected override void Awake()
		{
			base.Awake();
			if (MaterialCount == 0)
			{
				AddMaterial();
			}
		}

		public override void Reset()
		{
			base.Reset();
			GenerateUV = true;
			Split = false;
			SplitLength = 100f;
			ReverseTriOrder = false;
			m_MaterialSettings = new List<CGMaterialSettingsEx>(new CGMaterialSettingsEx[1]
			{
				new CGMaterialSettingsEx()
			});
			m_Material = new Material[1] { CurvyUtility.GetDefaultMaterial() };
		}

		public override void Refresh()
		{
			base.Refresh();
			CGVolume data = InVolume.GetData<CGVolume>(Array.Empty<CGDataRequestParameter>());
			if ((bool)data && data.Count > 0 && data.CrossSize > 0 && data.CrossMaterialGroups.Count > 0)
			{
				List<IntRegion> list = new List<IntRegion>();
				if (Split)
				{
					float num = 0f;
					int num2 = 0;
					for (int i = 0; i < data.Count; i++)
					{
						float num3 = data.FToDistance(data.F[i]);
						if (num3 - num >= SplitLength)
						{
							list.Add(new IntRegion(num2, i));
							num = num3;
							num2 = i;
						}
					}
					if (num2 < data.Count - 1)
					{
						list.Add(new IntRegion(num2, data.Count - 1));
					}
				}
				else
				{
					list.Add(new IntRegion(0, data.Count - 1));
				}
				CGVMesh[] array = OutVMesh.GetAllData<CGVMesh>();
				Array.Resize(ref array, list.Count);
				prepare(data);
				for (int j = 0; j < list.Count; j++)
				{
					array[j] = CGVMesh.Get(array[j], data, list[j], GenerateUV, ReverseTriOrder);
					build(array[j], data, list[j]);
				}
				CGModuleOutputSlot outVMesh = OutVMesh;
				CGData[] data2 = array;
				outVMesh.SetData(data2);
			}
			else
			{
				OutVMesh.SetData((CGData[])null);
			}
		}

		public int AddMaterial()
		{
			m_MaterialSettings.Add(new CGMaterialSettingsEx());
			m_Material = m_Material.Add(CurvyUtility.GetDefaultMaterial());
			base.Dirty = true;
			return MaterialCount;
		}

		public void RemoveMaterial(int index)
		{
			if (validateMaterialIndex(index))
			{
				m_MaterialSettings.RemoveAt(index);
				m_Material = m_Material.RemoveAt(index);
				base.Dirty = true;
			}
		}

		public void SetMaterial(int index, Material mat)
		{
			if (validateMaterialIndex(index) && !(mat == m_Material[index]) && m_Material[index] != mat)
			{
				m_Material[index] = mat;
				base.Dirty = true;
			}
		}

		public Material GetMaterial(int index)
		{
			if (!validateMaterialIndex(index))
			{
				return null;
			}
			return m_Material[index];
		}

		private void prepare(CGVolume vol)
		{
			groupsByMatID = getMaterialIDGroups(vol);
		}

		private void build(CGVMesh vmesh, CGVolume vol, IntRegion subset)
		{
			if (GenerateUV)
			{
				Array.Resize(ref vmesh.UV, vmesh.Count);
				Array.Resize(ref vmesh.UV2, vmesh.Count);
			}
			prepareSubMeshes(vmesh, groupsByMatID, subset.Length, ref m_Material);
			int num = 0;
			int[] array = new int[groupsByMatID.Count];
			for (int i = subset.From; i < subset.To; i++)
			{
				for (int j = 0; j < groupsByMatID.Count; j++)
				{
					SamplePointsMaterialGroupCollection samplePointsMaterialGroupCollection = groupsByMatID[j];
					for (int k = 0; k < samplePointsMaterialGroupCollection.Count; k++)
					{
						SamplePointsMaterialGroup samplePointsMaterialGroup = samplePointsMaterialGroupCollection[k];
						if (GenerateUV)
						{
							createMaterialGroupUV(vmesh, vol, samplePointsMaterialGroup, samplePointsMaterialGroupCollection.MaterialID, samplePointsMaterialGroupCollection.AspectCorrection, i, num);
						}
						for (int l = 0; l < samplePointsMaterialGroup.Patches.Count; l++)
						{
							createPatchTriangles(ref vmesh.SubMeshes[j].Triangles, ref array[j], num + samplePointsMaterialGroup.Patches[l].Start, samplePointsMaterialGroup.Patches[l].Count, vol.CrossSize, ReverseTriOrder);
						}
					}
				}
				num += vol.CrossSize;
			}
			if (!GenerateUV)
			{
				return;
			}
			for (int m = 0; m < groupsByMatID.Count; m++)
			{
				SamplePointsMaterialGroupCollection samplePointsMaterialGroupCollection = groupsByMatID[m];
				for (int n = 0; n < samplePointsMaterialGroupCollection.Count; n++)
				{
					SamplePointsMaterialGroup samplePointsMaterialGroup = samplePointsMaterialGroupCollection[n];
					createMaterialGroupUV(vmesh, vol, samplePointsMaterialGroup, samplePointsMaterialGroupCollection.MaterialID, samplePointsMaterialGroupCollection.AspectCorrection, subset.To, num);
				}
			}
		}

		private static void prepareSubMeshes(CGVMesh vmesh, List<SamplePointsMaterialGroupCollection> groupsBySubMeshes, int extrusions, ref Material[] materials)
		{
			vmesh.SetSubMeshCount(groupsBySubMeshes.Count);
			for (int i = 0; i < groupsBySubMeshes.Count; i++)
			{
				CGVSubMesh data = vmesh.SubMeshes[i];
				vmesh.SubMeshes[i] = CGVSubMesh.Get(data, groupsBySubMeshes[i].TriangleCount * extrusions * 3, materials[Mathf.Min(groupsBySubMeshes[i].MaterialID, materials.Length - 1)]);
			}
		}

		private void createMaterialGroupUV(CGVMesh vmesh, CGVolume vol, SamplePointsMaterialGroup grp, int matIndex, float grpAspectCorrection, int sample, int baseVertex)
		{
			CGMaterialSettingsEx cGMaterialSettingsEx = m_MaterialSettings[matIndex];
			float num = cGMaterialSettingsEx.UVOffset.y + vol.F[sample] * cGMaterialSettingsEx.UVScale.y * grpAspectCorrection;
			int endVertex = grp.EndVertex;
			bool swapUV = cGMaterialSettingsEx.SwapUV;
			Vector2[] uV = vmesh.UV;
			Vector2[] uV2 = vmesh.UV2;
			for (int i = grp.StartVertex; i <= endVertex; i++)
			{
				float num2 = cGMaterialSettingsEx.UVOffset.x + vol.CrossMap[i] * cGMaterialSettingsEx.UVScale.x;
				uV[baseVertex + i].x = (swapUV ? num : num2);
				uV[baseVertex + i].y = (swapUV ? num2 : num);
			}
			for (int j = grp.StartVertex; j <= endVertex; j++)
			{
				uV2[baseVertex + j].x = vol.CrossF[j];
				uV2[baseVertex + j].y = vol.F[sample];
			}
		}

		private static int createPatchTriangles(ref int[] triangles, ref int triIdx, int curVTIndex, int patchSize, int crossSize, bool reverse)
		{
			int num = (reverse ? 1 : 0);
			int num2 = 1 - num;
			int num3 = curVTIndex + crossSize;
			for (int i = 0; i < patchSize; i++)
			{
				triangles[triIdx + num] = curVTIndex + i;
				triangles[triIdx + num2] = num3 + i;
				triangles[triIdx + 2] = curVTIndex + i + 1;
				triangles[triIdx + num + 3] = curVTIndex + i + 1;
				triangles[triIdx + num2 + 3] = num3 + i;
				triangles[triIdx + 5] = num3 + i + 1;
				triIdx += 6;
			}
			return curVTIndex + patchSize + 1;
		}

		private List<SamplePointsMaterialGroupCollection> getMaterialIDGroups(CGVolume volume)
		{
			Dictionary<int, SamplePointsMaterialGroupCollection> dictionary = new Dictionary<int, SamplePointsMaterialGroupCollection>();
			for (int i = 0; i < volume.CrossMaterialGroups.Count; i++)
			{
				int num = Mathf.Min(volume.CrossMaterialGroups[i].MaterialID, MaterialCount - 1);
				if (!dictionary.TryGetValue(num, out var value))
				{
					value = new SamplePointsMaterialGroupCollection();
					value.MaterialID = num;
					dictionary.Add(num, value);
				}
				value.Add(volume.CrossMaterialGroups[i]);
			}
			List<SamplePointsMaterialGroupCollection> list = new List<SamplePointsMaterialGroupCollection>();
			foreach (SamplePointsMaterialGroupCollection value2 in dictionary.Values)
			{
				value2.CalculateAspectCorrection(volume, MaterialSetttings[value2.MaterialID]);
				list.Add(value2);
			}
			return list;
		}

		private bool validateMaterialIndex(int index)
		{
			if (index < 0 || index >= m_MaterialSettings.Count)
			{
				UnityEngine.Debug.LogError("TriangulateTube: Invalid Material Index!");
				return false;
			}
			return true;
		}
	}
	[ModuleInfo("Build/Volume Spots", ModuleName = "Volume Spots", Description = "Generate spots along a path/volume", UsesRandom = true)]
	[HelpURL("https://curvyeditor.com/doclink/cgvolumespots")]
	public class BuildVolumeSpots : CGModule, ISerializationCallbackReceiver
	{
		private class EndGroupData
		{
			internal CGBoundsGroup BoundsGroup { get; private set; }

			internal int[] ItemIndices { get; private set; }

			internal float GroupDepth { get; }

			internal CGBounds[] ItemBounds { get; }

			internal float SpaceBefore { get; }

			internal float SpaceAfter { get; }

			public EndGroupData(CGBoundsGroup boundsGroup, int[] itemIndices, float groupDepth, CGBounds[] itemBounds, float spaceBefore, float spaceAfter)
			{
				BoundsGroup = boundsGroup;
				ItemIndices = itemIndices;
				GroupDepth = groupDepth;
				ItemBounds = itemBounds;
				SpaceBefore = spaceBefore;
				SpaceAfter = spaceAfter;
			}
		}

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path/Volume", DisplayName = "Volume/Rasterized Path")]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGBounds) }, Array = true)]
		public CGModuleInputSlot InBounds = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGSpots))]
		public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

		[SerializeField]
		[HideInInspector]
		private bool m_WasUpgraded;

		[Tab("General")]
		[Section("Default/General/Volume Path", true, false, 100)]
		[FloatRegion(RegionOptionsPropertyName = "RangeOptions", Precision = 4)]
		[SerializeField]
		private FloatRegion m_Range = FloatRegion.ZeroOne;

		[Section("Default/General/Volume Cross", true, false, 100)]
		[Tooltip("When the source is a Volume, you can choose if you want to use it's path or the volume")]
		[FieldCondition("Volume", null, true, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[Label("Use Volume's Surface", "")]
		private bool m_UseVolume = true;

		[SerializeField]
		[RangeEx(-1f, 1f, "", "")]
		[Tooltip("Shifts the Cross origin value by constant value")]
		private float m_CrossBase;

		[SerializeField]
		[Label("Cross Base Variation", "")]
		[Tooltip("Shifts the Cross origin value by a value that varies along the Volume's length. The Curve's X axis has values between 0 (start of the Range) and 1 (its end)")]
		private AnimationCurve m_CrossCurve = AnimationCurve.Linear(0f, 0f, 1f, 0f);

		[Section("Default/General/Advanced Settings", false, false, 100)]
		[Tooltip("Check to run a dry run without actually creating spots")]
		[SerializeField]
		private bool m_Simulate;

		[SerializeField]
		[Tooltip("Until version 6.3.1, this module had a bug in the computation of the randomized values. Enable this value to keep that bugged behaviour if your project depends on it")]
		private bool m_UseBuggedRNG;

		[Tab("Groups")]
		[ArrayEx(Space = 10)]
		[SerializeField]
		private List<CGBoundsGroup> m_Groups = new List<CGBoundsGroup>();

		[IntRegion(UseSlider = false, RegionOptionsPropertyName = "RepeatingGroupsOptions", Options = AttributeOptionsFlags.Compact)]
		[SerializeField]
		[Tooltip("The range of groups that will be placed repetitively along the volume. Groups that are not in this range will be placed only once")]
		private IntRegion m_RepeatingGroups;

		[SerializeField]
		private CurvyRepeatingOrderEnum m_RepeatingOrder = CurvyRepeatingOrderEnum.Row;

		[SerializeField]
		[FieldCondition("ShowFitEnd", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[Label("Fits The End", "")]
		[Tooltip("If checked, the last non repeating group is placed exactly at the end of the volume used for spots. If not, the last group is placed at the first available spot, which might leave some space between it and the end of the volume")]
		private bool m_FitEnd;

		public CGSpots SimulatedSpots;

		private WeightedRandom<int> mGroupBag;

		private List<CGBounds> mBounds;

		public FloatRegion Range
		{
			get
			{
				return m_Range;
			}
			set
			{
				if (m_Range != value)
				{
					m_Range = value;
				}
				base.Dirty = true;
			}
		}

		public bool UseVolume
		{
			get
			{
				return m_UseVolume;
			}
			set
			{
				if (m_UseVolume != value)
				{
					m_UseVolume = value;
				}
				base.Dirty = true;
			}
		}

		public bool Simulate
		{
			get
			{
				return m_Simulate;
			}
			set
			{
				if (m_Simulate != value)
				{
					m_Simulate = value;
				}
				base.Dirty = true;
			}
		}

		public bool UseBuggedRng
		{
			get
			{
				return m_UseBuggedRNG;
			}
			set
			{
				if (m_UseBuggedRNG != value)
				{
					m_UseBuggedRNG = value;
				}
				base.Dirty = true;
			}
		}

		public float CrossBase
		{
			get
			{
				return m_CrossBase;
			}
			set
			{
				float num = Mathf.Repeat(value, 1f);
				if (m_CrossBase != num)
				{
					m_CrossBase = num;
				}
				base.Dirty = true;
			}
		}

		public AnimationCurve CrossCurve
		{
			get
			{
				return m_CrossCurve;
			}
			set
			{
				if (m_CrossCurve != value)
				{
					m_CrossCurve = value;
				}
				base.Dirty = true;
			}
		}

		public List<CGBoundsGroup> Groups
		{
			get
			{
				return m_Groups;
			}
			set
			{
				if (m_Groups != value)
				{
					m_Groups = value;
				}
			}
		}

		public CurvyRepeatingOrderEnum RepeatingOrder
		{
			get
			{
				return m_RepeatingOrder;
			}
			set
			{
				if (m_RepeatingOrder != value)
				{
					m_RepeatingOrder = value;
				}
				base.Dirty = true;
			}
		}

		public int FirstRepeating
		{
			get
			{
				return m_RepeatingGroups.From;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, Mathf.Max(0, GroupCount - 1));
				if (m_RepeatingGroups.From != num)
				{
					m_RepeatingGroups.From = num;
				}
				base.Dirty = true;
			}
		}

		public int LastRepeating
		{
			get
			{
				return m_RepeatingGroups.To;
			}
			set
			{
				int num = Mathf.Clamp(value, FirstRepeating, Mathf.Max(0, GroupCount - 1));
				if (m_RepeatingGroups.To != num)
				{
					m_RepeatingGroups.To = num;
				}
				base.Dirty = true;
			}
		}

		public bool FitEnd
		{
			get
			{
				return m_FitEnd;
			}
			set
			{
				if (m_FitEnd != value)
				{
					m_FitEnd = value;
				}
				base.Dirty = true;
			}
		}

		public int GroupCount => Groups.Count;

		public GUIContent[] BoundsNames
		{
			get
			{
				if (mBounds == null)
				{
					return new GUIContent[0];
				}
				GUIContent[] array = new GUIContent[mBounds.Count];
				for (int i = 0; i < mBounds.Count; i++)
				{
					array[i] = new GUIContent(string.Format(CultureInfo.InvariantCulture, "{0}:{1}", i.ToString(CultureInfo.InvariantCulture), mBounds[i].Name));
				}
				return array;
			}
		}

		public int[] BoundsIndices
		{
			get
			{
				if (mBounds == null)
				{
					return new int[0];
				}
				int[] array = new int[mBounds.Count];
				for (int i = 0; i < mBounds.Count; i++)
				{
					array[i] = i;
				}
				return array;
			}
		}

		public int Count { get; private set; }

		private int lastGroupIndex => Mathf.Max(0, GroupCount - 1);

		private RegionOptions<float> RangeOptions => RegionOptions<float>.MinMax(0f, 1f);

		private RegionOptions<int> RepeatingGroupsOptions => RegionOptions<int>.MinMax(0, Mathf.Max(0, GroupCount - 1));

		private CGPath Path { get; set; }

		private CGVolume Volume => Path as CGVolume;

		private float Length
		{
			get
			{
				if (Path == null)
				{
					return 0f;
				}
				return Path.Length * m_Range.Length;
			}
		}

		private bool ShowFitEnd => LastRepeating != Groups.Count - 1;

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 350f;
		}

		public override void Reset()
		{
			base.Reset();
			m_Range = FloatRegion.ZeroOne;
			UseVolume = true;
			Simulate = false;
			CrossBase = 0f;
			CrossCurve = AnimationCurve.Linear(0f, 0f, 1f, 0f);
			RepeatingOrder = CurvyRepeatingOrderEnum.Row;
			FirstRepeating = 0;
			LastRepeating = 0;
			FitEnd = false;
			Groups.Clear();
			AddGroup("Group");
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
			if (!IsConfigured)
			{
				Clear();
			}
		}

		public void Clear()
		{
			Count = 0;
			SimulatedSpots = new CGSpots();
			OutSpots.SetData(SimulatedSpots);
		}

		public override void Refresh()
		{
			base.Refresh();
			mBounds = InBounds.GetAllData<CGBounds>(Array.Empty<CGDataRequestParameter>());
			bool flag = false;
			if (mBounds.Count == 0)
			{
				flag = true;
				UIMessages.Add("The input bounds list is empty. Add some to enable spots generation.");
			}
			if (Groups.Count == 0)
			{
				flag = true;
				UIMessages.Add("No group created. Create a group in the Groups tab to enable spots generation");
			}
			for (int j = 0; j < mBounds.Count; j++)
			{
				CGBounds cGBounds = mBounds[j];
				if (cGBounds is CGGameObject && ((CGGameObject)cGBounds).Object == null)
				{
					flag = true;
					UIMessages.Add($"Input object of index {j} has no Game Object attached to it. Correct this to enable spots generation.");
				}
				else if (cGBounds.Depth <= 0.01f)
				{
					CGBounds cGBounds2 = new CGBounds(cGBounds);
					UIMessages.Add($"Input object \"{cGBounds2.Name}\" has bounds with a depth of {cGBounds.Depth}. The minimal accepted depth is {0.01f}. The depth value was overriden.");
					cGBounds2.Bounds = new Bounds(cGBounds.Bounds.center, new Vector3(cGBounds.Bounds.size.x, cGBounds.Bounds.size.y, 0.01f));
					mBounds[j] = cGBounds2;
				}
			}
			foreach (CGBoundsGroup group in Groups)
			{
				if (group.ItemCount == 0)
				{
					flag = true;
					UIMessages.Add($"Group \"{group.Name}\" has 0 item in it. Add some to enable spots generation.");
					continue;
				}
				foreach (CGBoundsGroupItem item in group.Items)
				{
					int index = item.Index;
					if (index < 0 || index >= mBounds.Count)
					{
						flag = true;
						UIMessages.Add($"Group \"{group.Name}\" has a reference to an nonexistent item of index {index}. Correct the reference to enable spots generation.");
						break;
					}
				}
			}
			Path = InPath.GetData<CGPath>(Array.Empty<CGDataRequestParameter>());
			List<CGSpot> spots = new List<CGSpot>();
			Dictionary<CGBoundsGroup, WeightedRandom<int>> dictionary = Prepare();
			if ((bool)Path && !flag)
			{
				bool flag2 = false;
				float num = Path.FToDistance(m_Range.To);
				float num2 = Path.FToDistance(m_Range.Low);
				float currentDistance = num2;
				for (int k = 0; k < FirstRepeating; k++)
				{
					int groupIndex = k;
					flag2 = AddGroupItems(groupIndex, ref spots, num - currentDistance, num2, ref currentDistance, out var _, dictionary, 10000);
					if (flag2)
					{
						break;
					}
				}
				bool flag3 = GroupCount - LastRepeating - 1 > 0;
				List<EndGroupData> list;
				if (!flag2 && flag3)
				{
					list = new List<EndGroupData>();
					for (int l = LastRepeating + 1; l < GroupCount; l++)
					{
						CGBoundsGroup cGBoundsGroup = Groups[l];
						int[] groupItemIndices = GetGroupItemIndices(cGBoundsGroup, dictionary[cGBoundsGroup]);
						float spaceBefore = (UseBuggedRng ? cGBoundsGroup.SpaceBefore.Next : GetRegionNextValue(cGBoundsGroup.SpaceBefore));
						float spaceAfter = (UseBuggedRng ? cGBoundsGroup.SpaceAfter.Next : GetRegionNextValue(cGBoundsGroup.SpaceAfter));
						CGBounds[] itemsBounds;
						float groupDepth = GetGroupDepth(groupItemIndices, spaceBefore, spaceAfter, out itemsBounds);
						list.Add(new EndGroupData(cGBoundsGroup, groupItemIndices, groupDepth, itemsBounds, spaceBefore, spaceAfter));
					}
				}
				else
				{
					list = null;
				}
				float num3 = num;
				if (flag3)
				{
					foreach (EndGroupData endGroupData in list)
					{
						float availableSpace = num3 - currentDistance;
						float num4 = num3 - endGroupData.GroupDepth * 1.00001f;
						if (endGroupData.GroupDepth <= availableSpace)
						{
							num3 = num4;
						}
						else if (!endGroupData.BoundsGroup.KeepTogether && endGroupData.ItemBounds.Any((CGBounds i) => i.Depth + endGroupData.SpaceBefore + endGroupData.SpaceAfter <= availableSpace))
						{
							num3 = num4;
						}
					}
				}
				if (RepeatingOrder == CurvyRepeatingOrderEnum.Row)
				{
					int firstRepeating = FirstRepeating;
					bool failedAddingAllItems2 = false;
					while (!flag2 && !failedAddingAllItems2 && num3 > currentDistance)
					{
						int groupIndex2 = firstRepeating++;
						if (firstRepeating > LastRepeating)
						{
							firstRepeating = FirstRepeating;
						}
						flag2 = AddGroupItems(groupIndex2, ref spots, num3 - currentDistance, num2, ref currentDistance, out failedAddingAllItems2, dictionary, 10000);
						if (flag2)
						{
							break;
						}
					}
				}
				else
				{
					bool failedAddingAllItems3 = false;
					while (!flag2 && !failedAddingAllItems3 && num3 > currentDistance)
					{
						int groupIndex3 = mGroupBag.Next();
						flag2 = AddGroupItems(groupIndex3, ref spots, num3 - currentDistance, num2, ref currentDistance, out failedAddingAllItems3, dictionary, 10000);
						if (flag2)
						{
							break;
						}
					}
				}
				if (!flag2 && flag3)
				{
					if (FitEnd)
					{
						currentDistance = Mathf.Max(currentDistance, num3);
					}
					foreach (EndGroupData item2 in list)
					{
						AddGroupItems(item2.BoundsGroup, ref spots, num - currentDistance, num2, ref currentDistance, out var _, item2.ItemIndices, item2.GroupDepth, item2.ItemBounds, item2.SpaceBefore, item2.SpaceAfter);
						if (spots.Count >= 10000)
						{
							flag2 = true;
							break;
						}
					}
				}
				if (flag2)
				{
					string text = $"Number of generated spots reached the maximal allowed number, which is {10000}. Spots generation was stopped. Try to reduce the number of spots needed by using bigger Bounds as inputs and/or setting bigger space between two spots.";
					UIMessages.Add(text);
					DTLog.LogError("[Curvy] Volume spots: " + text);
				}
			}
			Count = spots.Count;
			SimulatedSpots = new CGSpots(spots);
			if (Simulate)
			{
				OutSpots.SetData(new CGSpots());
			}
			else
			{
				OutSpots.SetData(SimulatedSpots);
			}
		}

		public CGBoundsGroup AddGroup(string name)
		{
			CGBoundsGroup cGBoundsGroup = new CGBoundsGroup(name);
			cGBoundsGroup.Items.Add(new CGBoundsGroupItem());
			Groups.Add(cGBoundsGroup);
			base.Dirty = true;
			return cGBoundsGroup;
		}

		public void RemoveGroup(CGBoundsGroup group)
		{
			Groups.Remove(group);
			base.Dirty = true;
		}

		private static int[] GetGroupItemIndices(CGBoundsGroup boundsGroup, WeightedRandom<int> groupItemBag)
		{
			int[] array = new int[boundsGroup.ItemCount];
			for (int i = 0; i < boundsGroup.ItemCount; i++)
			{
				int index = ((boundsGroup.RandomizeItems && i >= boundsGroup.FirstRepeating && i <= boundsGroup.LastRepeating) ? groupItemBag.Next() : i);
				array[i] = boundsGroup.Items[index].Index;
			}
			return array;
		}

		private float GetGroupDepth(int[] groupItemIndices, float spaceBefore, float spaceAfter, out CGBounds[] itemsBounds)
		{
			itemsBounds = new CGBounds[groupItemIndices.Length];
			float num = spaceBefore + spaceAfter;
			for (int i = 0; i < groupItemIndices.Length; i++)
			{
				CGBounds cGBounds = mBounds[groupItemIndices[i]];
				itemsBounds[i] = cGBounds;
				num += cGBounds.Depth;
			}
			return num;
		}

		private bool AddGroupItems(int groupIndex, ref List<CGSpot> spots, float remainingLength, float startDistance, ref float currentDistance, out bool failedAddingAllItems, Dictionary<CGBoundsGroup, WeightedRandom<int>> itemsBagDictionary, int MaxSpotsCount)
		{
			CGBoundsGroup cGBoundsGroup = Groups[groupIndex];
			WeightedRandom<int> groupItemBag = itemsBagDictionary[cGBoundsGroup];
			int[] groupItemIndices = GetGroupItemIndices(cGBoundsGroup, groupItemBag);
			float spaceBefore = (UseBuggedRng ? cGBoundsGroup.SpaceBefore.Next : GetRegionNextValue(cGBoundsGroup.SpaceBefore));
			float spaceAfter = (UseBuggedRng ? cGBoundsGroup.SpaceAfter.Next : GetRegionNextValue(cGBoundsGroup.SpaceAfter));
			CGBounds[] itemsBounds;
			float groupDepth = GetGroupDepth(groupItemIndices, spaceBefore, spaceAfter, out itemsBounds);
			AddGroupItems(cGBoundsGroup, ref spots, remainingLength, startDistance, ref currentDistance, out failedAddingAllItems, groupItemIndices, groupDepth, itemsBounds, spaceBefore, spaceAfter);
			return spots.Count >= MaxSpotsCount;
		}

		private void AddGroupItems(CGBoundsGroup group, ref List<CGSpot> spots, float remainingLength, float startDistance, ref float currentDistance, out bool failedAddingAllItems, int[] itemIndices, float groupDepth, CGBounds[] itemBounds, float spaceBefore, float spaceAfter)
		{
			if (remainingLength >= groupDepth || !group.KeepTogether)
			{
				failedAddingAllItems = false;
				for (int i = 0; i < itemIndices.Length; i++)
				{
					float num = currentDistance;
					int itemID = itemIndices[i];
					CGBounds cGBounds = itemBounds[i];
					bool flag;
					if (i != 0)
					{
						flag = ((i != itemIndices.Length - 1) ? (remainingLength > cGBounds.Depth) : (remainingLength > spaceAfter + cGBounds.Depth));
					}
					else
					{
						flag = remainingLength > spaceBefore + cGBounds.Depth;
						if (flag)
						{
							currentDistance += spaceBefore;
						}
					}
					if (!flag)
					{
						failedAddingAllItems = true;
						break;
					}
					spots.Add(GetSpot(itemID, group, cGBounds, currentDistance, startDistance));
					if (i == itemIndices.Length - 1)
					{
						currentDistance += cGBounds.Depth + spaceAfter;
					}
					else
					{
						currentDistance += cGBounds.Depth;
					}
					remainingLength -= currentDistance - num;
				}
			}
			else
			{
				failedAddingAllItems = true;
			}
		}

		private CGSpot GetSpot(int itemID, CGBoundsGroup boundsGroup, CGBounds bounds, float currentDistance, float startDistance)
		{
			float f = Path.DistanceToF(currentDistance + bounds.Depth / 2f);
			float time = (currentDistance - startDistance) / Length;
			float num = (UseBuggedRng ? boundsGroup.CrossBase.Next : GetRegionNextValue(boundsGroup.CrossBase));
			if (!boundsGroup.IgnoreModuleCrossBase)
			{
				num += CrossBase + m_CrossCurve.Evaluate(time);
			}
			float num2 = DTMath.MapValue(-0.5f, 0.5f, num);
			bool flag = UseVolume && (bool)Volume;
			Vector3 pos;
			Vector3 dir;
			Vector3 up;
			switch (boundsGroup.RotationMode)
			{
			case CGBoundsGroup.RotationModeEnum.Full:
				if (flag)
				{
					Volume.InterpolateVolume(f, num2, out pos, out dir, out up);
				}
				else
				{
					Path.Interpolate(f, num2, out pos, out dir, out up);
				}
				break;
			case CGBoundsGroup.RotationModeEnum.Direction:
			{
				Vector3 up2;
				if (flag)
				{
					Volume.InterpolateVolume(f, num2, out pos, out dir, out up2);
				}
				else
				{
					Path.Interpolate(f, num2, out pos, out dir, out up2);
				}
				up = Vector3.up;
				break;
			}
			case CGBoundsGroup.RotationModeEnum.Horizontal:
			{
				Vector3 up3;
				if (flag)
				{
					Volume.InterpolateVolume(f, num2, out pos, out dir, out up3);
				}
				else
				{
					Path.Interpolate(f, num2, out pos, out dir, out up3);
				}
				up = Vector3.up;
				dir.y = 0f;
				break;
			}
			case CGBoundsGroup.RotationModeEnum.Independent:
				pos = ((!flag) ? Path.InterpolatePosition(f) : Volume.InterpolateVolumePosition(f, num2));
				up = Vector3.up;
				dir = Vector3.forward;
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
			Quaternion rotation;
			Vector3 translation;
			Vector3 scale;
			if (UseBuggedRng)
			{
				GetTRS630(boundsGroup, dir, up, out rotation, out translation, out scale);
			}
			else
			{
				GetTRS(boundsGroup, dir, up, out rotation, out translation, out scale);
			}
			return new CGSpot(itemID, pos.Addition(boundsGroup.RelativeTranslation ? (rotation * translation) : translation), rotation, scale);
		}

		private static float GetRegionNextValue(FloatRegion floatRegion)
		{
			float result;
			if (floatRegion.SimpleValue)
			{
				result = floatRegion.From;
				UnityEngine.Random.Range(0f, 1f);
			}
			else
			{
				result = UnityEngine.Random.Range(floatRegion.From, floatRegion.To);
			}
			return result;
		}

		private void GetTRS(CGBoundsGroup boundsGroup, Vector3 tangent, Vector3 up, out Quaternion rotation, out Vector3 translation, out Vector3 scale)
		{
			Vector3 euler = default(Vector3);
			euler.x = GetRegionNextValue(boundsGroup.RotationX);
			euler.y = GetRegionNextValue(boundsGroup.RotationY);
			euler.z = GetRegionNextValue(boundsGroup.RotationZ);
			rotation = Quaternion.LookRotation(tangent, up) * Quaternion.Euler(euler);
			translation.x = GetRegionNextValue(boundsGroup.TranslationX);
			translation.y = GetRegionNextValue(boundsGroup.TranslationY);
			translation.z = GetRegionNextValue(boundsGroup.TranslationZ);
			scale.x = GetRegionNextValue(boundsGroup.ScaleX);
			if (boundsGroup.UniformScaling)
			{
				scale.y = (scale.z = scale.x);
				UnityEngine.Random.Range(0f, 1f);
				UnityEngine.Random.Range(0f, 1f);
			}
			else
			{
				scale.y = GetRegionNextValue(boundsGroup.ScaleY);
				scale.z = GetRegionNextValue(boundsGroup.ScaleZ);
			}
		}

		private void GetTRS630(CGBoundsGroup boundsGroup, Vector3 tangent, Vector3 up, out Quaternion rotation, out Vector3 translation, out Vector3 scale)
		{
			Vector3 vector = new Vector3(boundsGroup.RotationX.SimpleValue ? 0f : ((boundsGroup.RotationX.High - boundsGroup.RotationX.Low) * 0.5f), boundsGroup.RotationY.SimpleValue ? 0f : ((boundsGroup.RotationY.High - boundsGroup.RotationY.Low) * 0.5f), boundsGroup.RotationZ.SimpleValue ? 0f : ((boundsGroup.RotationZ.High - boundsGroup.RotationZ.Low) * 0.5f));
			Vector3 vector2 = new Vector3(boundsGroup.RotationX.SimpleValue ? boundsGroup.RotationX.From : ((boundsGroup.RotationX.From + boundsGroup.RotationX.To) * 0.5f), boundsGroup.RotationY.SimpleValue ? boundsGroup.RotationY.From : ((boundsGroup.RotationY.From + boundsGroup.RotationY.To) * 0.5f), boundsGroup.RotationZ.SimpleValue ? boundsGroup.RotationZ.From : ((boundsGroup.RotationZ.From + boundsGroup.RotationZ.To) * 0.5f));
			rotation = Quaternion.LookRotation(tangent, up) * Quaternion.Euler(vector2.x + vector.x * (float)UnityEngine.Random.Range(-1, 1), vector2.y + vector.y * (float)UnityEngine.Random.Range(-1, 1), vector2.z + vector.z * (float)UnityEngine.Random.Range(-1, 1));
			FloatRegion translationX = boundsGroup.TranslationX;
			FloatRegion translationY = boundsGroup.TranslationY;
			FloatRegion translationZ = boundsGroup.TranslationZ;
			if (translationY.SimpleValue)
			{
				translation.y = translationY.From;
			}
			else
			{
				translation.y = UnityEngine.Random.Range(translationY.From, translationY.To);
			}
			UnityEngine.Random.State state = UnityEngine.Random.state;
			if (translationX.SimpleValue)
			{
				translation.x = translationX.From;
			}
			else
			{
				translation.x = UnityEngine.Random.Range(translationX.From, translationX.To);
				UnityEngine.Random.state = state;
			}
			if (translationZ.SimpleValue)
			{
				translation.z = translationZ.From;
			}
			else
			{
				translation.z = UnityEngine.Random.Range(translationZ.From, translationZ.To);
				UnityEngine.Random.state = state;
			}
			FloatRegion scaleX = boundsGroup.ScaleX;
			if (scaleX.SimpleValue)
			{
				scale.x = scaleX.From;
			}
			else
			{
				scale.x = UnityEngine.Random.Range(scaleX.From, scaleX.To);
				UnityEngine.Random.state = state;
			}
			if (boundsGroup.UniformScaling)
			{
				scale.y = (scale.z = scale.x);
				return;
			}
			FloatRegion scaleY = boundsGroup.ScaleY;
			FloatRegion scaleZ = boundsGroup.ScaleZ;
			if (scaleY.SimpleValue)
			{
				scale.y = scaleY.From;
			}
			else
			{
				scale.y = UnityEngine.Random.Range(scaleY.From, scaleY.To);
				UnityEngine.Random.state = state;
			}
			if (scaleZ.SimpleValue)
			{
				scale.z = scaleZ.From;
				return;
			}
			scale.z = UnityEngine.Random.Range(scaleZ.From, scaleZ.To);
			UnityEngine.Random.state = state;
		}

		private Dictionary<CGBoundsGroup, WeightedRandom<int>> Prepare()
		{
			Dictionary<CGBoundsGroup, WeightedRandom<int>> dictionary = new Dictionary<CGBoundsGroup, WeightedRandom<int>>();
			m_RepeatingGroups.MakePositive();
			m_RepeatingGroups.Clamp(0, GroupCount - 1);
			mGroupBag = new WeightedRandom<int>(0, (!UseBuggedRng) ? UnityEngine.Random.Range(0, int.MaxValue) : 0);
			if (RepeatingOrder == CurvyRepeatingOrderEnum.Random)
			{
				List<CGWeightedItem> itemsWeights = Groups.Cast<CGWeightedItem>().ToList();
				CGBoundsGroup.FillItemBag(mGroupBag, itemsWeights, FirstRepeating, LastRepeating);
			}
			for (int i = 0; i < Groups.Count; i++)
			{
				CGBoundsGroup cGBoundsGroup = Groups[i];
				cGBoundsGroup.RepeatingItems.MakePositive();
				cGBoundsGroup.RepeatingItems.Clamp(0, cGBoundsGroup.ItemCount - 1);
				UnityEngine.Random.State state = UnityEngine.Random.state;
				WeightedRandom<int> weightedRandom = new WeightedRandom<int>(0, (!UseBuggedRng) ? UnityEngine.Random.Range(0, int.MaxValue) : 0);
				UnityEngine.Random.state = state;
				dictionary[cGBoundsGroup] = weightedRandom;
				if (cGBoundsGroup.Items.Count != 0 && cGBoundsGroup.RandomizeItems)
				{
					List<CGWeightedItem> itemsWeights2 = cGBoundsGroup.Items.Cast<CGWeightedItem>().ToList();
					CGBoundsGroup.FillItemBag(weightedRandom, itemsWeights2, cGBoundsGroup.FirstRepeating, cGBoundsGroup.LastRepeating);
				}
			}
			return dictionary;
		}

		public void OnBeforeSerialize()
		{
		}

		public void OnAfterDeserialize()
		{
			if (string.IsNullOrEmpty(base.Version))
			{
				base.Version = "1";
				m_WasUpgraded = true;
				for (int i = 0; i < Groups.Count; i++)
				{
					CGBoundsGroup cGBoundsGroup = Groups[i];
					cGBoundsGroup.RelativeTranslation = true;
					cGBoundsGroup.TranslationX = new FloatRegion(0f);
					cGBoundsGroup.TranslationY = new FloatRegion(0f);
					cGBoundsGroup.TranslationZ = new FloatRegion(0f);
					cGBoundsGroup.RotationX = new FloatRegion(0f);
					cGBoundsGroup.RotationY = new FloatRegion(0f);
					cGBoundsGroup.RotationZ = new FloatRegion(0f);
					cGBoundsGroup.UniformScaling = true;
					cGBoundsGroup.ScaleX = new FloatRegion(1f);
					cGBoundsGroup.ScaleY = new FloatRegion(1f);
					cGBoundsGroup.ScaleZ = new FloatRegion(1f);
					cGBoundsGroup.ConvertObsoleteData();
				}
			}
		}
	}
	[ModuleInfo("Modifier/Conform Path", ModuleName = "Conform Path", Description = "Projects a path")]
	[HelpURL("https://curvyeditor.com/doclink/cgconformpath")]
	public class ConformPath : CGModule, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path", ModifiesData = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[SerializeField]
		[VectorEx("", "")]
		[Tooltip("The direction to raycast in ")]
		private Vector3 m_Direction = new Vector3(0f, -1f, 0f);

		[SerializeField]
		[Tooltip("The maximum raycast distance")]
		private float m_MaxDistance = 100f;

		[SerializeField]
		[Tooltip("Defines an offset shift along the raycast direction")]
		private float m_Offset;

		[SerializeField]
		[Tooltip("If enabled, the entire path is moved to the nearest possible distance. If disabled, each path point is moved individually")]
		private bool m_Warp;

		[SerializeField]
		[Tooltip("The layers to raycast against")]
		private LayerMask m_LayerMask;

		public Vector3 Direction
		{
			get
			{
				return m_Direction;
			}
			set
			{
				if (m_Direction != value)
				{
					m_Direction = value;
				}
				base.Dirty = true;
			}
		}

		public float MaxDistance
		{
			get
			{
				return m_MaxDistance;
			}
			set
			{
				if (m_MaxDistance != value)
				{
					m_MaxDistance = value;
				}
				base.Dirty = true;
			}
		}

		public float Offset
		{
			get
			{
				return m_Offset;
			}
			set
			{
				if (m_Offset != value)
				{
					m_Offset = value;
				}
				base.Dirty = true;
			}
		}

		public bool Warp
		{
			get
			{
				return m_Warp;
			}
			set
			{
				if (m_Warp != value)
				{
					m_Warp = value;
				}
				base.Dirty = true;
			}
		}

		public LayerMask LayerMask
		{
			get
			{
				return m_LayerMask;
			}
			set
			{
				if ((int)m_LayerMask != (int)value)
				{
					m_LayerMask = value;
				}
				base.Dirty = true;
			}
		}

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return false;
				}
				return InPath.SourceSlot().PathProvider.PathIsClosed;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.LabelWidth = 80f;
		}

		public override void Reset()
		{
			base.Reset();
			Direction = new Vector3(0f, -1f, 0f);
			MaxDistance = 100f;
			Offset = 0f;
			Warp = false;
			LayerMask = 0;
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (!CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests))
			{
				return null;
			}
			if ((int)LayerMask == 0)
			{
				UIMessages.Add("Please set a Layer Mask different than Nothing.");
			}
			CGPath data = InPath.GetData<CGPath>(requests);
			return new CGData[1] { Conform(base.Generator.transform, data, LayerMask, Direction, Offset, MaxDistance, Warp) };
		}

		public static CGPath Conform(Transform pathTransform, CGPath path, LayerMask layers, Vector3 projectionDirection, float offset, float rayLength, bool warp)
		{
			if (path == null)
			{
				return null;
			}
			int count = path.Count;
			if (projectionDirection != Vector3.zero && rayLength > 0f && count > 0)
			{
				RaycastHit hitInfo;
				if (warp)
				{
					float num = float.MaxValue;
					for (int i = 0; i < count; i++)
					{
						if (Physics.Raycast(pathTransform.TransformPoint(path.Position[i]), projectionDirection, out hitInfo, rayLength, layers) && hitInfo.distance < num)
						{
							num = hitInfo.distance;
						}
					}
					if (num != float.MaxValue)
					{
						Vector3 vector = projectionDirection * (num + offset);
						for (int j = 0; j < path.Count; j++)
						{
							path.Position[j] += vector;
						}
					}
				}
				else
				{
					for (int k = 0; k < count; k++)
					{
						if (Physics.Raycast(pathTransform.TransformPoint(path.Position[k]), projectionDirection, out hitInfo, rayLength, layers))
						{
							path.Position[k] += projectionDirection * (hitInfo.distance + offset);
						}
					}
				}
			}
			return path;
		}
	}
	[ModuleInfo("Create/GameObject", ModuleName = "Create GameObject")]
	[HelpURL("https://curvyeditor.com/doclink/cgcreategameobject")]
	public class CreateGameObject : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGGameObject) }, Array = true, Name = "GameObject")]
		public CGModuleInputSlot InGameObjectArray = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGSpots) }, Name = "Spots")]
		public CGModuleInputSlot InSpots = new CGModuleInputSlot();

		[SerializeField]
		[CGResourceCollectionManager("GameObject", ShowCount = true)]
		private CGGameObjectResourceCollection m_Resources = new CGGameObjectResourceCollection();

		[Tab("General")]
		[SerializeField]
		private bool m_MakeStatic;

		[SerializeField]
		[Layer("", "")]
		private int m_Layer;

		public int Layer
		{
			get
			{
				return m_Layer;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, 32);
				if (m_Layer != num)
				{
					m_Layer = num;
				}
				base.Dirty = true;
			}
		}

		public bool MakeStatic
		{
			get
			{
				return m_MakeStatic;
			}
			set
			{
				if (m_MakeStatic != value)
				{
					m_MakeStatic = value;
				}
				base.Dirty = true;
			}
		}

		public CGGameObjectResourceCollection GameObjects => m_Resources;

		public int GameObjectCount => GameObjects.Count;

		public override void Reset()
		{
			base.Reset();
			MakeStatic = false;
			Layer = 0;
			Clear();
		}

		protected override void OnDestroy()
		{
			if (!base.Generator.Destroying)
			{
				DeleteAllPrefabPools();
			}
			base.OnDestroy();
		}

		public override void OnTemplateCreated()
		{
			Clear();
		}

		public void Clear()
		{
			for (int i = 0; i < GameObjects.Count; i++)
			{
				DeleteManagedResource("GameObject", GameObjects.Items[i], GameObjects.PoolNames[i]);
			}
			GameObjects.Items.Clear();
			GameObjects.PoolNames.Clear();
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
			if (!IsConfigured)
			{
				Clear();
			}
		}

		public override void Refresh()
		{
			base.Refresh();
			List<CGGameObject> allData = InGameObjectArray.GetAllData<CGGameObject>(Array.Empty<CGDataRequestParameter>());
			CGSpots data = InSpots.GetData<CGSpots>(Array.Empty<CGDataRequestParameter>());
			Clear();
			List<IPool> allPrefabPools = GetAllPrefabPools();
			HashSet<string> hashSet = new HashSet<string>();
			if (allData.Count > 0 && data.Count > 0)
			{
				for (int i = 0; i < data.Count; i++)
				{
					CGSpot cGSpot = data.Points[i];
					int index = cGSpot.Index;
					if (index >= 0 && index < allData.Count && allData[index].Object != null)
					{
						CGGameObject cGGameObject = allData[index];
						string identifier = GetPrefabPool(cGGameObject.Object).Identifier;
						hashSet.Add(identifier);
						Transform transform = (Transform)AddManagedResource("GameObject", identifier, i);
						transform.gameObject.isStatic = MakeStatic;
						transform.gameObject.layer = Layer;
						transform.localPosition = cGSpot.Position;
						transform.localRotation = cGSpot.Rotation;
						transform.localScale = new Vector3(cGGameObject.Object.transform.localScale.x * cGSpot.Scale.x * cGGameObject.Scale.x, cGGameObject.Object.transform.localScale.y * cGSpot.Scale.y * cGGameObject.Scale.y, cGGameObject.Object.transform.localScale.z * cGSpot.Scale.z * cGGameObject.Scale.z);
						if (cGGameObject.Translate != Vector3.zero)
						{
							transform.Translate(cGGameObject.Translate);
						}
						if (cGGameObject.Rotate != Vector3.zero)
						{
							transform.Rotate(cGGameObject.Rotate);
						}
						GameObjects.Items.Add(transform);
						GameObjects.PoolNames.Add(identifier);
					}
				}
			}
			foreach (IPool item in allPrefabPools)
			{
				if (!hashSet.Contains(item.Identifier))
				{
					base.Generator.PoolManager.DeletePool(item);
				}
			}
		}
	}
	[ModuleInfo("Create/Mesh", ModuleName = "Create Mesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgcreatemesh")]
	public class CreateMesh : CGModule
	{
		private const string DefaultTag = "Untagged";

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVMesh) }, Array = true, Name = "VMesh")]
		public CGModuleInputSlot InVMeshArray = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGSpots) }, Array = true, Name = "Spots", Optional = true)]
		public CGModuleInputSlot InSpots = new CGModuleInputSlot();

		[SerializeField]
		[CGResourceCollectionManager("Mesh", ShowCount = true)]
		private CGMeshResourceCollection m_MeshResources = new CGMeshResourceCollection();

		[Tab("General")]
		[Tooltip("Merge meshes")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[SerializeField]
		private bool m_Combine;

		[Tooltip("Merge meshes sharing the same Index")]
		[SerializeField]
		private bool m_GroupMeshes = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private CGYesNoAuto m_AddNormals = CGYesNoAuto.Auto;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private CGYesNoAuto m_AddTangents = CGYesNoAuto.No;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_AddUV2 = true;

		[SerializeField]
		[Tooltip("If enabled, meshes will have the Static flag set, and will not be updated in Play Mode")]
		[FieldCondition("canModifyStaticFlag", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_MakeStatic;

		[SerializeField]
		[Tooltip("The Layer of the created game object")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[Layer("", "")]
		private int m_Layer;

		[SerializeField]
		[Tooltip("The Tag of the created game object")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		[Tag("", "")]
		private string m_Tag = "Untagged";

		[Tab("Renderer")]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_RendererEnabled = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private ShadowCastingMode m_CastShadows = ShadowCastingMode.On;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_ReceiveShadows = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private LightProbeUsage m_LightProbeUsage = LightProbeUsage.BlendProbes;

		[HideInInspector]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_UseLightProbes = true;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private ReflectionProbeUsage m_ReflectionProbes = ReflectionProbeUsage.BlendProbes;

		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private Transform m_AnchorOverride;

		[Tab("Collider")]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private CGColliderEnum m_Collider = CGColliderEnum.Mesh;

		[FieldCondition("m_Collider", CGColliderEnum.Mesh, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_Convex;

		[SerializeField]
		[FieldCondition("EnableIsTrigger", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private bool m_IsTrigger;

		[Tooltip("Options used to enable or disable certain features in Collider mesh cooking. See Unity's MeshCollider.cookingOptions for more details")]
		[FieldCondition("m_Collider", CGColliderEnum.Mesh, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[SerializeField]
		[EnumFlag("", "")]
		[FieldCondition("canUpdate", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below, Action = ActionAttribute.ActionEnum.Enable)]
		private MeshColliderCookingOptions m_CookingOptions = MeshColliderCookingOptions.CookForFasterSimulation | MeshColliderCookingOptions.EnableMeshCleaning | MeshColliderCookingOptions.WeldColocatedVertices;

		[Label("Auto Update", "")]
		[SerializeField]
		private bool m_AutoUpdateColliders = true;

		[SerializeField]
		private PhysicMaterial m_Material;

		private int mCurrentMeshCount;

		public bool Combine
		{
			get
			{
				return m_Combine;
			}
			set
			{
				if (m_Combine != value)
				{
					m_Combine = value;
				}
				base.Dirty = true;
			}
		}

		public bool GroupMeshes
		{
			get
			{
				return m_GroupMeshes;
			}
			set
			{
				if (m_GroupMeshes != value)
				{
					m_GroupMeshes = value;
				}
				base.Dirty = true;
			}
		}

		public CGYesNoAuto AddNormals
		{
			get
			{
				return m_AddNormals;
			}
			set
			{
				if (m_AddNormals != value)
				{
					m_AddNormals = value;
				}
				base.Dirty = true;
			}
		}

		public CGYesNoAuto AddTangents
		{
			get
			{
				return m_AddTangents;
			}
			set
			{
				if (m_AddTangents != value)
				{
					m_AddTangents = value;
				}
				base.Dirty = true;
			}
		}

		public bool AddUV2
		{
			get
			{
				return m_AddUV2;
			}
			set
			{
				if (m_AddUV2 != value)
				{
					m_AddUV2 = value;
				}
				base.Dirty = true;
			}
		}

		public int Layer
		{
			get
			{
				return m_Layer;
			}
			set
			{
				int num = Mathf.Clamp(value, 0, 32);
				if (m_Layer != num)
				{
					m_Layer = num;
				}
				base.Dirty = true;
			}
		}

		public string Tag
		{
			get
			{
				return m_Tag;
			}
			set
			{
				if (m_Tag != value)
				{
					m_Tag = value;
				}
				base.Dirty = true;
			}
		}

		public bool MakeStatic
		{
			get
			{
				return m_MakeStatic;
			}
			set
			{
				if (m_MakeStatic != value)
				{
					m_MakeStatic = value;
				}
				base.Dirty = true;
			}
		}

		public bool RendererEnabled
		{
			get
			{
				return m_RendererEnabled;
			}
			set
			{
				if (m_RendererEnabled != value)
				{
					m_RendererEnabled = value;
				}
				base.Dirty = true;
			}
		}

		public ShadowCastingMode CastShadows
		{
			get
			{
				return m_CastShadows;
			}
			set
			{
				if (m_CastShadows != value)
				{
					m_CastShadows = value;
				}
				base.Dirty = true;
			}
		}

		public bool ReceiveShadows
		{
			get
			{
				return m_ReceiveShadows;
			}
			set
			{
				if (m_ReceiveShadows != value)
				{
					m_ReceiveShadows = value;
				}
				base.Dirty = true;
			}
		}

		public bool UseLightProbes
		{
			get
			{
				return m_UseLightProbes;
			}
			set
			{
				if (m_UseLightProbes != value)
				{
					m_UseLightProbes = value;
				}
				base.Dirty = true;
			}
		}

		public LightProbeUsage LightProbeUsage
		{
			get
			{
				return m_LightProbeUsage;
			}
			set
			{
				if (m_LightProbeUsage != value)
				{
					m_LightProbeUsage = value;
				}
				base.Dirty = true;
			}
		}

		public ReflectionProbeUsage ReflectionProbes
		{
			get
			{
				return m_ReflectionProbes;
			}
			set
			{
				if (m_ReflectionProbes != value)
				{
					m_ReflectionProbes = value;
				}
				base.Dirty = true;
			}
		}

		public Transform AnchorOverride
		{
			get
			{
				return m_AnchorOverride;
			}
			set
			{
				if (m_AnchorOverride != value)
				{
					m_AnchorOverride = value;
				}
				base.Dirty = true;
			}
		}

		public CGColliderEnum Collider
		{
			get
			{
				return m_Collider;
			}
			set
			{
				if (m_Collider != value)
				{
					m_Collider = value;
				}
				base.Dirty = true;
			}
		}

		public bool AutoUpdateColliders
		{
			get
			{
				return m_AutoUpdateColliders;
			}
			set
			{
				if (m_AutoUpdateColliders != value)
				{
					m_AutoUpdateColliders = value;
				}
				base.Dirty = true;
			}
		}

		public bool Convex
		{
			get
			{
				return m_Convex;
			}
			set
			{
				if (m_Convex != value)
				{
					m_Convex = value;
				}
				base.Dirty = true;
			}
		}

		public bool IsTrigger
		{
			get
			{
				return m_IsTrigger;
			}
			set
			{
				if (m_IsTrigger != value)
				{
					m_IsTrigger = value;
				}
				base.Dirty = true;
			}
		}

		public MeshColliderCookingOptions CookingOptions
		{
			get
			{
				return m_CookingOptions;
			}
			set
			{
				if (m_CookingOptions != value)
				{
					m_CookingOptions = value;
				}
				base.Dirty = true;
			}
		}

		public PhysicMaterial Material
		{
			get
			{
				return m_Material;
			}
			set
			{
				if (m_Material != value)
				{
					m_Material = value;
				}
				base.Dirty = true;
			}
		}

		public CGMeshResourceCollection Meshes => m_MeshResources;

		public int MeshCount => Meshes.Count;

		public int VertexCount { get; private set; }

		private bool canGroupMeshes
		{
			get
			{
				if (InSpots.IsLinked)
				{
					return m_Combine;
				}
				return false;
			}
		}

		private bool canModifyStaticFlag => false;

		private bool canUpdate
		{
			get
			{
				if (Application.isPlaying)
				{
					return !MakeStatic;
				}
				return true;
			}
		}

		private bool EnableIsTrigger
		{
			get
			{
				if (canUpdate)
				{
					if (m_Collider == CGColliderEnum.Mesh)
					{
						return m_Convex;
					}
					return true;
				}
				return false;
			}
		}

		public override void Reset()
		{
			base.Reset();
			Combine = false;
			GroupMeshes = true;
			AddNormals = CGYesNoAuto.Auto;
			AddTangents = CGYesNoAuto.No;
			MakeStatic = false;
			Material = null;
			Layer = 0;
			Tag = "Untagged";
			CastShadows = ShadowCastingMode.On;
			RendererEnabled = true;
			ReceiveShadows = true;
			UseLightProbes = true;
			LightProbeUsage = LightProbeUsage.BlendProbes;
			ReflectionProbes = ReflectionProbeUsage.BlendProbes;
			AnchorOverride = null;
			Collider = CGColliderEnum.Mesh;
			AutoUpdateColliders = true;
			Convex = false;
			IsTrigger = false;
			AddUV2 = true;
			CookingOptions = MeshColliderCookingOptions.CookForFasterSimulation | MeshColliderCookingOptions.EnableMeshCleaning | MeshColliderCookingOptions.WeldColocatedVertices;
			Clear();
		}

		public override void OnTemplateCreated()
		{
			Clear();
		}

		public void Clear()
		{
			mCurrentMeshCount = 0;
			removeUnusedResource();
			Resources.UnloadUnusedAssets();
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
			if (!IsConfigured)
			{
				Clear();
			}
		}

		public override void Refresh()
		{
			base.Refresh();
			if (canUpdate)
			{
				List<CGVMesh> vMeshes = InVMeshArray.GetAllData<CGVMesh>(Array.Empty<CGDataRequestParameter>());
				List<CGSpots> allData = InSpots.GetAllData<CGSpots>(Array.Empty<CGDataRequestParameter>());
				CGSpot[] array = allData.Count switch
				{
					1 => (allData[0] != null) ? allData[0].Points : null, 
					0 => null, 
					_ => allData.Where((CGSpots s) => s != null).SelectMany((CGSpots s) => s.Points).ToArray(), 
				};
				mCurrentMeshCount = 0;
				VertexCount = 0;
				if (vMeshes.Count > 0 && (!InSpots.IsLinked || (array != null && array.Length != 0)))
				{
					if (array != null && array.Length != 0)
					{
						createSpotMeshes(ref vMeshes, array, Combine);
					}
					else
					{
						createMeshes(ref vMeshes, Combine);
					}
				}
				removeUnusedResource();
				if (AutoUpdateColliders)
				{
					UpdateColliders();
				}
			}
			else
			{
				UIMessages.Add("In Play Mode, and when Make Static is enabled, mesh generation is stopped to avoid overriding the optimizations Unity do to static game objects'meshs.");
			}
		}

		public GameObject SaveToScene(Transform parent = null)
		{
			GetManagedResources(out var components, out var _);
			if (components.Count == 0)
			{
				return null;
			}
			GameObject gameObject;
			if (components.Count > 1)
			{
				gameObject = new GameObject(base.ModuleName);
				gameObject.transform.parent = parent;
				for (int i = 0; i < components.Count; i++)
				{
					SaveMeshResourceToScene(components[i], gameObject.transform);
				}
			}
			else
			{
				gameObject = SaveMeshResourceToScene(components[0], parent);
			}
			gameObject.transform.position = base.transform.position;
			gameObject.transform.rotation = base.transform.rotation;
			gameObject.transform.localScale = base.transform.localScale;
			return gameObject;
		}

		public void UpdateColliders()
		{
			bool flag = true;
			for (int i = 0; i < m_MeshResources.Count; i++)
			{
				if (!(m_MeshResources.Items[i] == null) && !m_MeshResources.Items[i].UpdateCollider(Collider, Convex, IsTrigger, Material, CookingOptions))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				UIMessages.Add("Error setting collider!");
			}
		}

		private static GameObject SaveMeshResourceToScene(UnityEngine.Component managedResource, Transform newParent)
		{
			MeshFilter component = managedResource.GetComponent<MeshFilter>();
			GameObject obj = managedResource.gameObject.DuplicateGameObject(newParent);
			obj.name = managedResource.name;
			obj.GetComponent<CGMeshResource>().Destroy();
			obj.GetComponent<MeshFilter>().sharedMesh = UnityEngine.Object.Instantiate(component.sharedMesh);
			return obj;
		}

		private void createMeshes(ref List<CGVMesh> vMeshes, bool combine)
		{
			if (combine && vMeshes.Count > 1)
			{
				int i = 0;
				while (i < vMeshes.Count)
				{
					int startIndex = i;
					int num;
					for (num = 0; i < vMeshes.Count && num + vMeshes[i].Count <= 65534; i++)
					{
						num += vMeshes[i].Count;
					}
					if (num == 0)
					{
						UIMessages.Add(string.Format(CultureInfo.InvariantCulture, "Mesh of index {0}, and subsequent ones, skipped because vertex count {2} > {1}", i, 65534, vMeshes[i].Count));
						break;
					}
					CGVMesh vmesh = new CGVMesh();
					vmesh.MergeVMeshes(vMeshes, startIndex, i - 1);
					writeVMeshToMesh(ref vmesh);
				}
				return;
			}
			for (int j = 0; j < vMeshes.Count; j++)
			{
				CGVMesh vmesh2 = vMeshes[j];
				if (vmesh2.Count < 65534)
				{
					writeVMeshToMesh(ref vmesh2);
				}
				else
				{
					UIMessages.Add(string.Format(CultureInfo.InvariantCulture, "Mesh of index {0} skipped because vertex count {2} > {1}", j, 65534, vmesh2.Count));
				}
			}
		}

		private void createSpotMeshes(ref List<CGVMesh> vMeshes, CGSpot[] spots, bool combine)
		{
			int num = 0;
			int count = vMeshes.Count;
			if (combine)
			{
				List<CGSpot> list = new List<CGSpot>(spots);
				if (GroupMeshes)
				{
					list.Sort((CGSpot a, CGSpot b) => a.Index.CompareTo(b.Index));
				}
				CGSpot cGSpot = list[0];
				CGVMesh vmesh = new CGVMesh(vMeshes[cGSpot.Index]);
				if (cGSpot.Position != Vector3.zero || cGSpot.Rotation != Quaternion.identity || cGSpot.Scale != Vector3.one)
				{
					vmesh.TRS(cGSpot.Matrix);
				}
				for (int i = 1; i < list.Count; i++)
				{
					cGSpot = list[i];
					if (cGSpot.Index <= -1 || cGSpot.Index >= count)
					{
						continue;
					}
					if (vmesh.Count + vMeshes[cGSpot.Index].Count > 65534 || (GroupMeshes && cGSpot.Index != list[i - 1].Index))
					{
						writeVMeshToMesh(ref vmesh);
						vmesh = new CGVMesh(vMeshes[cGSpot.Index]);
						if (!cGSpot.Matrix.isIdentity)
						{
							vmesh.TRS(cGSpot.Matrix);
						}
					}
					else if (!cGSpot.Matrix.isIdentity)
					{
						vmesh.MergeVMesh(vMeshes[cGSpot.Index], cGSpot.Matrix);
					}
					else
					{
						vmesh.MergeVMesh(vMeshes[cGSpot.Index]);
					}
				}
				writeVMeshToMesh(ref vmesh);
			}
			else
			{
				for (int j = 0; j < spots.Length; j++)
				{
					CGSpot cGSpot = spots[j];
					if (cGSpot.Index <= -1 || cGSpot.Index >= count)
					{
						continue;
					}
					if (vMeshes[cGSpot.Index].Count < 65535)
					{
						CGVMesh vmesh2 = vMeshes[cGSpot.Index];
						CGMeshResource cGMeshResource = writeVMeshToMesh(ref vmesh2);
						if (cGSpot.Position != Vector3.zero || cGSpot.Rotation != Quaternion.identity || cGSpot.Scale != Vector3.one)
						{
							cGSpot.ToTransform(cGMeshResource.Filter.transform);
						}
					}
					else
					{
						num++;
					}
				}
			}
			if (num > 0)
			{
				UIMessages.Add(string.Format(CultureInfo.InvariantCulture, "{0} meshes skipped (VertexCount>65534)", num));
			}
		}

		private CGMeshResource writeVMeshToMesh(ref CGVMesh vmesh)
		{
			bool num = AddNormals != CGYesNoAuto.No;
			bool flag = AddTangents != CGYesNoAuto.No;
			CGMeshResource newMesh = getNewMesh();
			if (canModifyStaticFlag)
			{
				newMesh.Filter.gameObject.isStatic = false;
			}
			Mesh msh = newMesh.Prepare();
			newMesh.gameObject.layer = Layer;
			newMesh.gameObject.tag = Tag;
			vmesh.ToMesh(ref msh);
			VertexCount += vmesh.Count;
			if (AddUV2 && !vmesh.HasUV2)
			{
				msh.uv2 = CGUtility.CalculateUV2(vmesh.UV);
			}
			if (num && !vmesh.HasNormals)
			{
				msh.RecalculateNormals();
			}
			if (flag && !vmesh.HasTangents)
			{
				newMesh.Filter.CalculateTangents();
			}
			newMesh.Filter.transform.localPosition = Vector3.zero;
			newMesh.Filter.transform.localRotation = Quaternion.identity;
			newMesh.Filter.transform.localScale = Vector3.one;
			if (canModifyStaticFlag)
			{
				newMesh.Filter.gameObject.isStatic = MakeStatic;
			}
			newMesh.Renderer.sharedMaterials = vmesh.GetMaterials();
			return newMesh;
		}

		private void removeUnusedResource()
		{
			for (int i = mCurrentMeshCount; i < Meshes.Count; i++)
			{
				DeleteManagedResource("Mesh", Meshes.Items[i]);
			}
			Meshes.Items.RemoveRange(mCurrentMeshCount, Meshes.Count - mCurrentMeshCount);
		}

		private CGMeshResource getNewMesh()
		{
			CGMeshResource cGMeshResource;
			if (mCurrentMeshCount < Meshes.Count)
			{
				cGMeshResource = Meshes.Items[mCurrentMeshCount];
				if (cGMeshResource == null)
				{
					cGMeshResource = (CGMeshResource)AddManagedResource("Mesh", "", mCurrentMeshCount);
					Meshes.Items[mCurrentMeshCount] = cGMeshResource;
				}
			}
			else
			{
				cGMeshResource = (CGMeshResource)AddManagedResource("Mesh", "", mCurrentMeshCount);
				Meshes.Items.Add(cGMeshResource);
			}
			cGMeshResource.Renderer.shadowCastingMode = CastShadows;
			cGMeshResource.Renderer.enabled = RendererEnabled;
			cGMeshResource.Renderer.receiveShadows = ReceiveShadows;
			cGMeshResource.Renderer.lightProbeUsage = LightProbeUsage;
			cGMeshResource.Renderer.reflectionProbeUsage = ReflectionProbes;
			cGMeshResource.Renderer.probeAnchor = AnchorOverride;
			if (!cGMeshResource.ColliderMatches(Collider))
			{
				cGMeshResource.RemoveCollider();
			}
			mCurrentMeshCount++;
			return cGMeshResource;
		}
	}
	[ModuleInfo("Create/Path Line Renderer", ModuleName = "Create Path Line Renderer", Description = "Feeds a Line Renderer with a Path")]
	[HelpURL("https://curvyeditor.com/doclink/cgcreatepathlinerenderer")]
	public class CreatePathLineRenderer : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, DisplayName = "Rasterized Path")]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		private LineRenderer mLineRenderer;

		public LineRenderer LineRenderer
		{
			get
			{
				if (mLineRenderer == null)
				{
					mLineRenderer = GetComponent<LineRenderer>();
				}
				return mLineRenderer;
			}
		}

		protected override void Awake()
		{
			base.Awake();
			createLR();
		}

		public override void Refresh()
		{
			base.Refresh();
			CGPath data = InPath.GetData<CGPath>(Array.Empty<CGDataRequestParameter>());
			if (data != null)
			{
				LineRenderer.positionCount = data.Position.Length;
				LineRenderer.SetPositions(data.Position);
			}
			else
			{
				LineRenderer.positionCount = 0;
			}
		}

		private void createLR()
		{
			if (LineRenderer == null)
			{
				mLineRenderer = base.gameObject.AddComponent<LineRenderer>();
				mLineRenderer.useWorldSpace = false;
				mLineRenderer.textureMode = LineTextureMode.Tile;
				mLineRenderer.sharedMaterial = CurvyUtility.GetDefaultMaterial();
			}
		}
	}
	[ModuleInfo("Debug/Rasterized Path", ModuleName = "Debug Rasterized Path", Description = "Shows the tangents and orientation of a rasterized path")]
	[HelpURL("https://curvyeditor.com/doclink/cgdebugrasterizedpath")]
	public class DebugRasterizedPath : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, DisplayName = "Rasterized Path")]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[Tooltip("Display the normal at each one of the path's points")]
		public bool ShowNormals = true;

		[Tooltip("Display the orientation at each one of the path's points")]
		public bool ShowOrientation = true;

		public override void Reset()
		{
			base.Reset();
			ShowNormals = (ShowOrientation = true);
		}
	}
	[ModuleInfo("Debug/VMesh", ModuleName = "Debug VMesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgdebugvmesh")]
	public class DebugVMesh : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVMesh) }, Name = "VMesh")]
		public CGModuleInputSlot InData = new CGModuleInputSlot();

		[Tab("General")]
		public bool ShowVertices;

		public bool ShowVertexID;

		public bool ShowUV;

		public override void Reset()
		{
			base.Reset();
			ShowVertices = false;
			ShowVertexID = false;
			ShowUV = false;
		}
	}
	[ModuleInfo("Debug/Volume", ModuleName = "Debug Volume")]
	[HelpURL("https://curvyeditor.com/doclink/cgdebugvolume")]
	public class DebugVolume : CGModule
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVolume) }, Name = "Volume")]
		public CGModuleInputSlot InData = new CGModuleInputSlot();

		[Tab("General")]
		public bool ShowPathSamples = true;

		public bool ShowCrossSamples = true;

		[FieldCondition("ShowCrossSamples", true, false, ActionAttribute.ActionEnum.Show, null, ActionAttribute.ActionPositionEnum.Below)]
		[IntRegion(RegionIsOptional = true)]
		public IntRegion LimitCross = new IntRegion(0, 0);

		public bool ShowNormals;

		public bool ShowIndex;

		public bool ShowMap;

		public Color PathColor = Color.white;

		public Color VolumeColor = Color.gray;

		public Color NormalColor = Color.yellow;

		[Tab("Interpolate")]
		public bool Interpolate;

		[RangeEx(-1f, 1f, "Path", "")]
		public float InterpolatePathF;

		[RangeEx(-1f, 1f, "Cross", "")]
		public float InterpolateCrossF;
	}
	[ModuleInfo("Input/Game Objects", ModuleName = "Input GameObjects", Description = "")]
	[HelpURL("https://curvyeditor.com/doclink/cginputgameobject")]
	public class InputGameObject : CGModule
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGGameObject), Array = true)]
		public CGModuleOutputSlot OutGameObject = new CGModuleOutputSlot();

		[ArrayEx]
		[SerializeField]
		private List<CGGameObjectProperties> m_GameObjects = new List<CGGameObjectProperties>();

		public List<CGGameObjectProperties> GameObjects => m_GameObjects;

		public bool SupportsIPE => false;

		public override void Reset()
		{
			base.Reset();
			GameObjects.Clear();
			base.Dirty = true;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (!OutGameObject.IsLinked)
			{
				return;
			}
			CGGameObject[] array = new CGGameObject[GameObjects.Count];
			int newSize = 0;
			for (int i = 0; i < GameObjects.Count; i++)
			{
				if (GameObjects[i] != null)
				{
					array[newSize++] = new CGGameObject(GameObjects[i]);
				}
			}
			Array.Resize(ref array, newSize);
			CGModuleOutputSlot outGameObject = OutGameObject;
			CGData[] data = array;
			outGameObject.SetData(data);
		}

		public override void OnTemplateCreated()
		{
			base.OnTemplateCreated();
			GameObjects.Clear();
		}
	}
	[ModuleInfo("Input/Meshes", ModuleName = "Input Meshes", Description = "Create VMeshes")]
	[HelpURL("https://curvyeditor.com/doclink/cginputmesh")]
	public class InputMesh : CGModule, IExternalInput
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		[SerializeField]
		[ArrayEx]
		private List<CGMeshProperties> m_Meshes = new List<CGMeshProperties>(new CGMeshProperties[1]
		{
			new CGMeshProperties()
		});

		public List<CGMeshProperties> Meshes => m_Meshes;

		public bool SupportsIPE => false;

		public override void Reset()
		{
			base.Reset();
			Meshes.Clear();
			base.Dirty = true;
		}

		public override void Refresh()
		{
			base.Refresh();
			if (!OutVMesh.IsLinked)
			{
				return;
			}
			CGVMesh[] array = new CGVMesh[Meshes.Count];
			int newSize = 0;
			for (int i = 0; i < Meshes.Count; i++)
			{
				if ((bool)Meshes[i].Mesh)
				{
					array[newSize++] = new CGVMesh(Meshes[i]);
				}
			}
			Array.Resize(ref array, newSize);
			CGModuleOutputSlot outVMesh = OutVMesh;
			CGData[] data = array;
			outVMesh.SetData(data);
		}

		public override void OnTemplateCreated()
		{
			base.OnTemplateCreated();
			Meshes.Clear();
		}
	}
	[ModuleInfo("Input/Spline Path", ModuleName = "Input Spline Path", Description = "Spline Path")]
	[HelpURL("https://curvyeditor.com/doclink/cginputsplinepath")]
	public class InputSplinePath : SplineInputModuleBase, IExternalInput, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot Path = new CGModuleOutputSlot();

		[Tab("General", Sort = 0)]
		[SerializeField]
		[CGResourceManager("Spline")]
		[FieldCondition("m_Spline", null, false, ActionAttribute.ActionEnum.ShowWarning, "Create or assign spline", ActionAttribute.ActionPositionEnum.Below)]
		private CurvySpline m_Spline;

		public CurvySpline Spline
		{
			get
			{
				return m_Spline;
			}
			set
			{
				if (m_Spline != value)
				{
					m_Spline = value;
					OnSplineAssigned();
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public bool SupportsIPE => false;

		protected override CurvySpline InputSpline
		{
			get
			{
				return Spline;
			}
			set
			{
				Spline = value;
			}
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests);
			CGDataRequestMetaCGOptions requestParameter2 = CGModule.GetRequestParameter<CGDataRequestMetaCGOptions>(ref requests);
			if ((bool)requestParameter2)
			{
				if (requestParameter2.CheckMaterialID)
				{
					requestParameter2.CheckMaterialID = false;
					UIMessages.Add("MaterialID option not supported!");
				}
				if (requestParameter2.IncludeControlPoints)
				{
					requestParameter2.IncludeControlPoints = false;
					UIMessages.Add("IncludeCP option not supported!");
				}
			}
			if (!requestParameter || requestParameter.RasterizedRelativeLength == 0f)
			{
				return null;
			}
			CGData splineData = GetSplineData(Spline, fullPath: true, requestParameter, requestParameter2);
			return new CGData[1] { splineData };
		}

		public override void OnTemplateCreated()
		{
			base.OnTemplateCreated();
			if ((bool)Spline && !IsManagedResource(Spline))
			{
				Spline = null;
			}
		}
	}
	[ModuleInfo("Input/Spline Shape", ModuleName = "Input Spline Shape", Description = "Spline Shape")]
	[HelpURL("https://curvyeditor.com/doclink/cginputsplineshape")]
	public class InputSplineShape : SplineInputModuleBase, IExternalInput, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGShape))]
		public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

		[Tab("General", Sort = 0)]
		[SerializeField]
		[CGResourceManager("Shape")]
		private CurvySpline m_Shape;

		public CurvySpline Shape
		{
			get
			{
				return m_Shape;
			}
			set
			{
				if (m_Shape != value)
				{
					m_Shape = value;
					OnSplineAssigned();
					ValidateStartAndEndCps();
				}
				base.Dirty = true;
			}
		}

		public bool SupportsIPE => FreeForm;

		public bool FreeForm
		{
			get
			{
				if (Shape != null)
				{
					return Shape.GetComponent<CurvyShape>() == null;
				}
				return false;
			}
			set
			{
				if (Shape != null)
				{
					CurvyShape component = Shape.GetComponent<CurvyShape>();
					if (value && component != null)
					{
						component.Delete();
					}
					else if (!value && component == null)
					{
						Shape.gameObject.AddComponent<CSCircle>();
					}
				}
			}
		}

		protected override CurvySpline InputSpline
		{
			get
			{
				return Shape;
			}
			set
			{
				Shape = value;
			}
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests);
			CGDataRequestMetaCGOptions requestParameter2 = CGModule.GetRequestParameter<CGDataRequestMetaCGOptions>(ref requests);
			if (!requestParameter || requestParameter.RasterizedRelativeLength == 0f)
			{
				return null;
			}
			CGData splineData = GetSplineData(Shape, fullPath: false, requestParameter, requestParameter2);
			return new CGData[1] { splineData };
		}

		public T SetManagedShape<T>() where T : CurvyShape2D
		{
			if (!Shape)
			{
				Shape = (CurvySpline)AddManagedResource("Shape");
			}
			CurvyShape component = Shape.GetComponent<CurvyShape>();
			if (component != null)
			{
				component.Delete();
			}
			return Shape.gameObject.AddComponent<T>();
		}

		public void RemoveManagedShape()
		{
			if ((bool)Shape)
			{
				DeleteManagedResource("Shape", Shape);
			}
		}

		protected override void OnSplineAssigned()
		{
			base.OnSplineAssigned();
			if ((bool)Shape)
			{
				Shape.RestrictTo2D = true;
			}
		}
	}
	[ModuleInfo("Input/Spots", ModuleName = "Input Spots", Description = "Defines an array of placement spots")]
	[HelpURL("https://curvyeditor.com/doclink/cginputspots")]
	public class InputSpots : CGModule
	{
		[HideInInspector]
		[OutputSlotInfo(typeof(CGSpots))]
		public CGModuleOutputSlot OutSpots = new CGModuleOutputSlot();

		[ArrayEx]
		[SerializeField]
		private List<CGSpot> m_Spots = new List<CGSpot>();

		public List<CGSpot> Spots
		{
			get
			{
				return m_Spots;
			}
			set
			{
				if (m_Spots != value)
				{
					m_Spots = value;
				}
				base.Dirty = true;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
		}

		public override void Reset()
		{
			base.Reset();
			Spots.Clear();
			base.Dirty = true;
		}

		public override void OnStateChange()
		{
			base.OnStateChange();
		}

		public override void Refresh()
		{
			if (OutSpots.IsLinked)
			{
				OutSpots.SetData(new CGSpots(Spots.ToArray()));
			}
		}
	}
	[ModuleInfo("Modifier/Mix Paths", ModuleName = "Mix Paths", Description = "Interpolates between two paths")]
	[HelpURL("https://curvyeditor.com/doclink/cgmixpaths")]
	public class ModifierMixPaths : CGModule, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path A")]
		public CGModuleInputSlot InPathA = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path B")]
		public CGModuleInputSlot InPathB = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[SerializeField]
		[RangeEx(-1f, 1f, "", "", Tooltip = "Mix between the paths. Values between -1 for Path A and 1 for Path B")]
		private float m_Mix;

		public float Mix
		{
			get
			{
				return m_Mix;
			}
			set
			{
				if (m_Mix != value)
				{
					m_Mix = value;
				}
				base.Dirty = true;
			}
		}

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return false;
				}
				if (InPathA.SourceSlot().PathProvider.PathIsClosed)
				{
					return InPathB.SourceSlot().PathProvider.PathIsClosed;
				}
				return false;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			Mix = 0f;
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (!CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests))
			{
				return null;
			}
			CGPath data = InPathA.GetData<CGPath>(requests);
			CGPath data2 = InPathB.GetData<CGPath>(requests);
			return new CGData[1] { MixPath(data, data2, Mix, UIMessages) };
		}

		public static CGPath MixPath(CGPath pathA, CGPath pathB, float mix, [NotNull] List<string> warningsContainer)
		{
			if (pathA == null)
			{
				return pathB;
			}
			if (pathB == null)
			{
				return pathA;
			}
			int num = Mathf.Max(pathA.Count, pathB.Count);
			CGPath cGPath = new CGPath();
			cGPath.Direction = new Vector3[num];
			ModifierMixShapes.InterpolateShape(cGPath, pathA, pathB, mix, warningsContainer);
			float t = (mix + 1f) * 0.5f;
			Vector3[] array = new Vector3[num];
			if (pathA.Count == num)
			{
				for (int i = 0; i < num; i++)
				{
					float frag;
					int fIndex = pathB.GetFIndex(pathA.F[i], out frag);
					Vector3 b = Vector3.SlerpUnclamped(pathB.Direction[fIndex], pathB.Direction[fIndex + 1], frag);
					array[i] = Vector3.SlerpUnclamped(pathA.Direction[i], b, t);
				}
			}
			else
			{
				for (int j = 0; j < num; j++)
				{
					float frag2;
					int fIndex2 = pathA.GetFIndex(pathB.F[j], out frag2);
					Vector3 a = Vector3.SlerpUnclamped(pathA.Direction[fIndex2], pathA.Direction[fIndex2 + 1], frag2);
					array[j] = Vector3.SlerpUnclamped(a, pathB.Direction[j], t);
				}
			}
			cGPath.Direction = array;
			return cGPath;
		}
	}
	[ModuleInfo("Modifier/Mix Shapes", ModuleName = "Mix Shapes", Description = "Interpolates between two shapes")]
	[HelpURL("https://curvyeditor.com/doclink/cgmixshapes")]
	public class ModifierMixShapes : CGModule, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape A")]
		public CGModuleInputSlot InShapeA = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape B")]
		public CGModuleInputSlot InShapeB = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGShape))]
		public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

		[SerializeField]
		[RangeEx(-1f, 1f, "", "", Tooltip = "Mix between the shapes. Values between -1 for Shape A and 1 for Shape B")]
		private float m_Mix;

		public float Mix
		{
			get
			{
				return m_Mix;
			}
			set
			{
				if (m_Mix != value)
				{
					m_Mix = value;
				}
				base.Dirty = true;
			}
		}

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return false;
				}
				if (InShapeA.SourceSlot().PathProvider.PathIsClosed)
				{
					return InShapeB.SourceSlot().PathProvider.PathIsClosed;
				}
				return false;
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			Mix = 0f;
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (!CGModule.GetRequestParameter<CGDataRequestRasterization>(ref requests))
			{
				return null;
			}
			CGShape data = InShapeA.GetData<CGShape>(requests);
			CGShape data2 = InShapeB.GetData<CGShape>(requests);
			CGShape cGShape = MixShapes(data, data2, Mix, UIMessages);
			return new CGData[1] { cGShape };
		}

		public static CGShape MixShapes(CGShape shapeA, CGShape shapeB, float mix, [NotNull] List<string> warningsContainer, bool ignoreWarnings = false)
		{
			if (shapeA == null)
			{
				return shapeB;
			}
			if (shapeB == null)
			{
				return shapeA;
			}
			CGShape cGShape = new CGShape();
			InterpolateShape(cGShape, shapeA, shapeB, mix, warningsContainer, ignoreWarnings);
			return cGShape;
		}

		public static void InterpolateShape([NotNull] CGShape resultShape, CGShape shapeA, CGShape shapeB, float mix, [NotNull] List<string> warningsContainer, bool ignoreWarnings = false)
		{
			float num = (mix + 1f) * 0.5f;
			int num2 = Mathf.Max(shapeA.Count, shapeB.Count);
			CGShape cGShape = ((shapeA.Count == num2) ? shapeA : shapeB);
			Vector3[] array = new Vector3[num2];
			Vector3[] array2 = new Vector3[num2];
			if (cGShape == shapeA)
			{
				Vector3 vector = default(Vector3);
				for (int i = 0; i < num2; i++)
				{
					float frag;
					int fIndex = shapeB.GetFIndex(shapeA.F[i], out frag);
					vector.x = shapeB.Position[fIndex].x + (shapeB.Position[fIndex + 1].x - shapeB.Position[fIndex].x) * frag;
					vector.y = shapeB.Position[fIndex].y + (shapeB.Position[fIndex + 1].y - shapeB.Position[fIndex].y) * frag;
					vector.z = shapeB.Position[fIndex].z + (shapeB.Position[fIndex + 1].z - shapeB.Position[fIndex].z) * frag;
					array[i].x = shapeA.Position[i].x + (vector.x - shapeA.Position[i].x) * num;
					array[i].y = shapeA.Position[i].y + (vector.y - shapeA.Position[i].y) * num;
					array[i].z = shapeA.Position[i].z + (vector.z - shapeA.Position[i].z) * num;
					Vector3 b = Vector3.SlerpUnclamped(shapeB.Normal[fIndex], shapeB.Normal[fIndex + 1], frag);
					array2[i] = Vector3.SlerpUnclamped(shapeA.Normal[i], b, num);
				}
			}
			else
			{
				Vector3 vector2 = default(Vector3);
				for (int j = 0; j < num2; j++)
				{
					float frag2;
					int fIndex2 = shapeA.GetFIndex(shapeB.F[j], out frag2);
					vector2.x = shapeA.Position[fIndex2].x + (shapeA.Position[fIndex2 + 1].x - shapeA.Position[fIndex2].x) * frag2;
					vector2.y = shapeA.Position[fIndex2].y + (shapeA.Position[fIndex2 + 1].y - shapeA.Position[fIndex2].y) * frag2;
					vector2.z = shapeA.Position[fIndex2].z + (shapeA.Position[fIndex2 + 1].z - shapeA.Position[fIndex2].z) * frag2;
					array[j].x = vector2.x + (shapeB.Position[j].x - vector2.x) * num;
					array[j].y = vector2.y + (shapeB.Position[j].y - vector2.y) * num;
					array[j].z = vector2.z + (shapeB.Position[j].z - vector2.z) * num;
					Vector3 a = Vector3.SlerpUnclamped(shapeA.Normal[fIndex2], shapeA.Normal[fIndex2 + 1], frag2);
					array2[j] = Vector3.SlerpUnclamped(a, shapeB.Normal[j], num);
				}
			}
			resultShape.Position = array;
			resultShape.F = new float[num2];
			resultShape.Recalculate();
			resultShape.Normal = array2;
			resultShape.Map = (float[])cGShape.Map.Clone();
			resultShape.SourceF = (float[])cGShape.SourceF.Clone();
			resultShape.MaterialGroups = cGShape.MaterialGroups.Select((SamplePointsMaterialGroup g) => g.Clone()).ToList();
			if (!ignoreWarnings)
			{
				if (shapeA.Closed != shapeB.Closed)
				{
					warningsContainer.Add("Mixing inputs with different Closed values is not supported");
				}
				if (shapeA.Seamless != shapeB.Seamless)
				{
					warningsContainer.Add("Mixing inputs with different Seamless values is not supported");
				}
				if (shapeA.SourceIsManaged != shapeB.SourceIsManaged)
				{
					warningsContainer.Add("Mixing inputs with different SourceIsManaged values is not supported");
				}
			}
			resultShape.Closed = shapeA.Closed;
			resultShape.Seamless = shapeA.Seamless;
			resultShape.SourceIsManaged = shapeA.SourceIsManaged;
		}
	}
	[ModuleInfo("Modifier/Path Relative Translation", ModuleName = "Path Relative Translation", Description = "Translates a path relatively to it's direction, instead of relatively to the world as does the TRS Path module.")]
	[HelpURL("https://curvyeditor.com/doclink/cgpathrelativetranslation")]
	public class ModifierPathRelativeTranslation : CGModule, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path A", ModifiesData = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		[SerializeField]
		[Tooltip("The translation amount")]
		private float lateralTranslation;

		public float LateralTranslation
		{
			get
			{
				return lateralTranslation;
			}
			set
			{
				if (lateralTranslation != value)
				{
					lateralTranslation = value;
					base.Dirty = true;
				}
			}
		}

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return false;
				}
				return InPath.SourceSlot().PathProvider.PathIsClosed;
			}
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (requestedSlot == OutPath)
			{
				CGPath data = InPath.GetData<CGPath>(requests);
				if ((bool)data)
				{
					for (int i = 0; i < data.Count; i++)
					{
						Vector3 vector = Vector3.Cross(data.Normal[i], data.Direction[i]) * lateralTranslation;
						data.Position[i].x = data.Position[i].x + vector.x;
						data.Position[i].y = data.Position[i].y + vector.y;
						data.Position[i].z = data.Position[i].z + vector.z;
					}
					data.Recalculate();
				}
				return new CGData[1] { data };
			}
			return null;
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			Properties.LabelWidth = 165f;
		}

		public override void Reset()
		{
			base.Reset();
			LateralTranslation = 0f;
		}
	}
	[ModuleInfo("Modifier/TRS Mesh", ModuleName = "TRS Mesh", Description = "Transform,Rotate,Scale a VMesh")]
	[HelpURL("https://curvyeditor.com/doclink/cgtrsmesh")]
	public class ModifierTRSMesh : TRSModuleBase
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGVMesh) }, Array = true, ModifiesData = true)]
		public CGModuleInputSlot InVMesh = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGVMesh), Array = true)]
		public CGModuleOutputSlot OutVMesh = new CGModuleOutputSlot();

		public override void Refresh()
		{
			base.Refresh();
			if (OutVMesh.IsLinked)
			{
				List<CGVMesh> allData = InVMesh.GetAllData<CGVMesh>(Array.Empty<CGDataRequestParameter>());
				Matrix4x4 matrix = base.Matrix;
				for (int i = 0; i < allData.Count; i++)
				{
					allData[i].TRS(matrix);
				}
				OutVMesh.SetData(allData);
			}
		}
	}
	[ModuleInfo("Modifier/TRS Path", ModuleName = "TRS Path", Description = "Transform,Rotate,Scale a Path")]
	[HelpURL("https://curvyeditor.com/doclink/cgtrspath")]
	public class ModifierTRSPath : TRSModuleBase, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGPath) }, Name = "Path A", ModifiesData = true)]
		public CGModuleInputSlot InPath = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGPath))]
		public CGModuleOutputSlot OutPath = new CGModuleOutputSlot();

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return false;
				}
				return InPath.SourceSlot().PathProvider.PathIsClosed;
			}
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (requestedSlot == OutPath)
			{
				CGPath data = InPath.GetData<CGPath>(requests);
				if ((bool)data)
				{
					Matrix4x4 matrix = base.Matrix;
					Matrix4x4 matrix4x = Matrix4x4.TRS(base.Transpose, Quaternion.Euler(base.Rotation), Vector3.one);
					for (int i = 0; i < data.Count; i++)
					{
						data.Position[i] = matrix.MultiplyPoint3x4(data.Position[i]);
						data.Normal[i] = matrix4x.MultiplyVector(data.Normal[i]);
					}
					data.Recalculate();
				}
				return new CGData[1] { data };
			}
			return null;
		}
	}
	[ModuleInfo("Modifier/TRS Shape", ModuleName = "TRS Shape", Description = "Transform,Rotate,Scale a Shape")]
	[HelpURL("https://curvyeditor.com/doclink/cgtrsshape")]
	public class ModifierTRSShape : TRSModuleBase, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape A", ModifiesData = true)]
		public CGModuleInputSlot InShape = new CGModuleInputSlot();

		[HideInInspector]
		[OutputSlotInfo(typeof(CGShape))]
		public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return false;
				}
				return InShape.SourceSlot().PathProvider.PathIsClosed;
			}
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			if (requestedSlot == OutShape)
			{
				CGShape data = InShape.GetData<CGShape>(requests);
				if ((bool)data)
				{
					Matrix4x4 matrix = base.Matrix;
					Matrix4x4 matrix4x = Matrix4x4.TRS(base.Transpose, Quaternion.Euler(base.Rotation), Vector3.one);
					for (int i = 0; i < data.Count; i++)
					{
						data.Position[i] = matrix.MultiplyPoint3x4(data.Position[i]);
						data.Normal[i] = matrix4x.MultiplyVector(data.Normal[i]);
					}
					data.Recalculate();
				}
				return new CGData[1] { data };
			}
			return null;
		}
	}
	[ModuleInfo("Modifier/Variable Mix Shapes", ModuleName = "Variable Mix Shapes", Description = "Interpolates between two shapes in a way that varies along the shape extrusion")]
	[HelpURL("https://curvyeditor.com/doclink/cgvariablemixshapes")]
	public class ModifierVariableMixShapes : CGModule, IOnRequestPath, IOnRequestProcessing, IPathProvider
	{
		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape A")]
		public CGModuleInputSlot InShapeA = new CGModuleInputSlot();

		[HideInInspector]
		[InputSlotInfo(new Type[] { typeof(CGShape) }, Name = "Shape B")]
		public CGModuleInputSlot InShapeB = new CGModuleInputSlot();

		[HideInInspector]
		[ShapeOutputSlotInfo(OutputsVariableShape = true, Array = true, ArrayType = SlotInfo.SlotArrayType.Hidden)]
		public CGModuleOutputSlot OutShape = new CGModuleOutputSlot();

		[Label("Mix Curve", "Mix between the shapes. Values (Y axis) between -1 for Shape A and 1 for Shape B. Times (X axis) between 0 for extrusion start and 1 for extrusion end")]
		[SerializeField]
		private AnimationCurve m_MixCurve = AnimationCurve.Linear(0f, -1f, 1f, 1f);

		public bool PathIsClosed
		{
			get
			{
				if (!IsConfigured)
				{
					return false;
				}
				if (InShapeA.SourceSlot().PathProvider.PathIsClosed)
				{
					return InShapeB.SourceSlot().PathProvider.PathIsClosed;
				}
				return false;
			}
		}

		public AnimationCurve MixCurve
		{
			get
			{
				return m_MixCurve;
			}
			set
			{
				m_MixCurve = value;
				base.Dirty = true;
			}
		}

		public override void Reset()
		{
			base.Reset();
			m_MixCurve = AnimationCurve.Linear(0f, -1f, 1f, 1f);
		}

		public CGData[] OnSlotDataRequest(CGModuleInputSlot requestedBy, CGModuleOutputSlot requestedSlot, params CGDataRequestParameter[] requests)
		{
			CGDataRequestShapeRasterization requestParameter = CGModule.GetRequestParameter<CGDataRequestShapeRasterization>(ref requests);
			if (!requestParameter)
			{
				return null;
			}
			int num = requestParameter.PathF.Length;
			CGData[] array = new CGData[num];
			for (int i = 0; i < num; i++)
			{
				float mix = MixCurve.Evaluate(requestParameter.PathF[i]);
				array[i] = ModifierMixShapes.MixShapes(InShapeA.GetData<CGShape>(requests), InShapeB.GetData<CGShape>(requests), mix, UIMessages, i != 0);
			}
			return array;
		}
	}
	[ModuleInfo("Note", ModuleName = "Note", Description = "Creates a note")]
	[HelpURL("https://curvyeditor.com/doclink/cgnote")]
	public class Note : CGModule, INoProcessing
	{
		[SerializeField]
		[TextArea(3, 10)]
		private string m_Note;

		public string NoteText
		{
			get
			{
				return m_Note;
			}
			set
			{
				if (m_Note != value)
				{
					m_Note = value;
				}
			}
		}

		protected override void OnEnable()
		{
			base.OnEnable();
			Properties.MinWidth = 250f;
			Properties.LabelWidth = 50f;
		}

		public override void Reset()
		{
			base.Reset();
			m_Note = null;
		}
	}
}
namespace FluffyUnderware.Curvy.Examples
{
	public class CameraLook : MonoBehaviour
	{
		[Range(0f, 10f)]
		[SerializeField]
		private float m_TurnSpeed = 1.5f;

		protected void Update()
		{
			if (!(Time.timeScale < float.Epsilon))
			{
				float axis = Input.GetAxis("Mouse X");
				float num = 0f - Input.GetAxis("Mouse Y");
				base.transform.Rotate(num * m_TurnSpeed, 0f, 0f, Space.Self);
				base.transform.Rotate(0f, axis * m_TurnSpeed, 0f, Space.World);
			}
		}
	}
	[ExecuteInEditMode]
	public class ChaseCam : MonoBehaviour
	{
		public Transform LookAt;

		public Transform MoveTo;

		public Transform RollTo;

		[Positive]
		public float ChaseTime = 0.5f;

		private Vector3 mVelocity;

		private Vector3 mRollVelocity;

		private void LateUpdate()
		{
			if ((bool)MoveTo)
			{
				base.transform.position = Vector3.SmoothDamp(base.transform.position, MoveTo.position, ref mVelocity, ChaseTime);
			}
			if ((bool)LookAt)
			{
				if (!RollTo)
				{
					base.transform.LookAt(LookAt);
				}
				else
				{
					base.transform.LookAt(LookAt, Vector3.SmoothDamp(base.transform.up, RollTo.up, ref mRollVelocity, ChaseTime));
				}
			}
		}
	}
	public class CurvyCamController : SplineController
	{
		[Section("Curvy Cam", true, false, 100)]
		public float MinSpeed;

		public float MaxSpeed;

		public float Mass;

		public float Down;

		public float Up;

		public float Fric = 0.9f;

		protected override void OnEnable()
		{
			base.OnEnable();
			base.Speed = MinSpeed;
		}

		protected override void Advance(float speed, float deltaTime)
		{
			base.Advance(speed, deltaTime);
			Vector3 tangent = GetTangent(base.RelativePosition);
			float num = ((!(tangent.y < 0f)) ? (Up * (0f - tangent.y) * Fric) : (Down * tangent.y * Fric));
			base.Speed = Mathf.Clamp(base.Speed + Mass * num * deltaTime, MinSpeed, MaxSpeed);
			if (base.RelativePosition == 1f)
			{
				base.Speed = 0f;
			}
		}
	}
	public class HeightMetadata : CurvyInterpolatableMetadataBase<float>
	{
		[SerializeField]
		[RangeEx(0f, 1f, "", "", Slider = true)]
		private float m_Height;

		public override float MetaDataValue => m_Height;

		public override float Interpolate(CurvyInterpolatableMetadataBase<float> nextMetadata, float interpolationTime)
		{
			if (!(nextMetadata != null))
			{
				return MetaDataValue;
			}
			return Mathf.Lerp(MetaDataValue, nextMetadata.MetaDataValue, interpolationTime);
		}
	}
	public class InfiniteTrack : MonoBehaviour
	{
		public CurvySpline TrackSpline;

		public CurvyController Controller;

		public Material RoadMaterial;

		public Text TxtStats;

		[Positive]
		public float CurvationX = 10f;

		[Positive]
		public float CurvationY = 10f;

		[Positive]
		public float CPStepSize = 20f;

		[Positive]
		public int HeadCP = 3;

		[Positive]
		public int TailCP = 2;

		[FluffyUnderware.DevTools.Min(3f, "", "")]
		public int Sections = 6;

		[FluffyUnderware.DevTools.Min(1f, "", "")]
		public int SectionCPCount = 2;

		private int mInitState;

		private bool mUpdateSpline;

		private int mUpdateIn;

		private CurvyGenerator[] mGenerators;

		private int mCurrentGen;

		private float lastSectionEndV;

		private Vector3 mDir;

		private TimeMeasure timeSpline = new TimeMeasure(30);

		private TimeMeasure timeCG = new TimeMeasure(1);

		private void Start()
		{
			updateStats();
		}

		private void FixedUpdate()
		{
			if (mInitState == 0)
			{
				StartCoroutine("setup");
			}
			if (mInitState == 2 && mUpdateSpline)
			{
				advanceTrack();
			}
		}

		private IEnumerator setup()
		{
			mInitState = 1;
			mGenerators = new CurvyGenerator[Sections];
			TrackSpline.InsertAfter(null, Vector3.zero, skipRefreshingAndEvents: true);
			mDir = Vector3.forward;
			int num = TailCP + HeadCP + Sections * SectionCPCount;
			for (int j = 0; j < num; j++)
			{
				addTrackCP();
			}
			TrackSpline.Refresh();
			for (int k = 0; k < Sections; k++)
			{
				mGenerators[k] = buildGenerator();
				mGenerators[k].name = "Generator " + k;
			}
			for (int i = 0; i < Sections; i++)
			{
				while (!mGenerators[i].IsInitialized)
				{
					yield return 0;
				}
			}
			for (int l = 0; l < Sections; l++)
			{
				updateSectionGenerator(mGenerators[l], l * SectionCPCount + TailCP, (l + 1) * SectionCPCount + TailCP);
			}
			mInitState = 2;
			mUpdateIn = SectionCPCount;
			Controller.AbsolutePosition = TrackSpline.ControlPointsList[TailCP + 2].Distance;
		}

		private CurvyGenerator buildGenerator()
		{
			CurvyGenerator curvyGenerator = CurvyGenerator.Create();
			curvyGenerator.AutoRefresh = false;
			InputSplinePath inputSplinePath = curvyGenerator.AddModule<InputSplinePath>();
			InputSplineShape inputSplineShape = curvyGenerator.AddModule<InputSplineShape>();
			BuildShapeExtrusion buildShapeExtrusion = curvyGenerator.AddModule<BuildShapeExtrusion>();
			BuildVolumeMesh buildVolumeMesh = curvyGenerator.AddModule<BuildVolumeMesh>();
			CreateMesh createMesh = curvyGenerator.AddModule<CreateMesh>();
			inputSplinePath.OutputByName["Path"].LinkTo(buildShapeExtrusion.InputByName["Path"]);
			inputSplineShape.OutputByName["Shape"].LinkTo(buildShapeExtrusion.InputByName["Cross"]);
			buildShapeExtrusion.OutputByName["Volume"].LinkTo(buildVolumeMesh.InputByName["Volume"]);
			buildVolumeMesh.OutputByName["VMesh"].LinkTo(createMesh.InputByName["VMesh"]);
			inputSplinePath.Spline = TrackSpline;
			inputSplinePath.UseCache = true;
			CSRectangle cSRectangle = inputSplineShape.SetManagedShape<CSRectangle>();
			cSRectangle.Width = 20f;
			cSRectangle.Height = 2f;
			buildShapeExtrusion.Optimize = false;
			buildShapeExtrusion.CrossHardEdges = true;
			buildVolumeMesh.Split = false;
			buildVolumeMesh.SetMaterial(0, RoadMaterial);
			buildVolumeMesh.MaterialSetttings[0].SwapUV = true;
			createMesh.Collider = CGColliderEnum.None;
			return curvyGenerator;
		}

		private void advanceTrack()
		{
			timeSpline.Start();
			float num = Controller.AbsolutePosition;
			for (int i = 0; i < SectionCPCount; i++)
			{
				num -= TrackSpline.ControlPointsList[0].Length;
				TrackSpline.Delete(TrackSpline.ControlPointsList[0], skipRefreshingAndEvents: true);
			}
			for (int j = 0; j < SectionCPCount; j++)
			{
				addTrackCP();
			}
			TrackSpline.Refresh();
			Controller.AbsolutePosition = num;
			mUpdateSpline = false;
			timeSpline.Stop();
			advanceSections();
			updateStats();
		}

		private void advanceSections()
		{
			CurvyGenerator gen = mGenerators[mCurrentGen++];
			int num = TrackSpline.ControlPointCount - HeadCP - 1;
			updateSectionGenerator(gen, num - SectionCPCount, num);
			if (mCurrentGen == Sections)
			{
				mCurrentGen = 0;
			}
		}

		private void updateStats()
		{
			TxtStats.text = $"Spline Update: {timeSpline.AverageMS:0.00} ms\nGenerator Update: {timeCG.AverageMS:0.00} ms";
		}

		private void updateSectionGenerator(CurvyGenerator gen, int startCP, int endCP)
		{
			InputSplinePath inputSplinePath = gen.FindModules<InputSplinePath>(includeOnRequestProcessing: true)[0];
			inputSplinePath.EndCP = null;
			inputSplinePath.StartCP = TrackSpline.ControlPointsList[startCP];
			inputSplinePath.EndCP = TrackSpline.ControlPointsList[endCP];
			BuildVolumeMesh buildVolumeMesh = gen.FindModules<BuildVolumeMesh>()[0];
			buildVolumeMesh.MaterialSetttings[0].UVOffset.y = lastSectionEndV % 1f;
			timeCG.Start();
			gen.Refresh();
			timeCG.Stop();
			CGVMesh data = buildVolumeMesh.OutVMesh.GetData<CGVMesh>();
			lastSectionEndV = data.UV[data.Count - 1].y;
		}

		public void Track_OnControlPointReached(CurvySplineMoveEventArgs e)
		{
			if (--mUpdateIn == 0)
			{
				mUpdateSpline = true;
				mUpdateIn = SectionCPCount;
			}
		}

		private void addTrackCP()
		{
			Vector3 localPosition = TrackSpline.ControlPointsList[TrackSpline.ControlPointCount - 1].transform.localPosition;
			Vector3 position = TrackSpline.transform.localToWorldMatrix.MultiplyPoint3x4(localPosition + mDir * CPStepSize);
			float x = UnityEngine.Random.value * CurvationX * DTUtility.RandomSign();
			float y = UnityEngine.Random.value * CurvationY * DTUtility.RandomSign();
			mDir = Quaternion.Euler(x, y, 0f) * mDir;
			CurvySplineSegment curvySplineSegment = TrackSpline.InsertAfter(null, position, skipRefreshingAndEvents: true);
			if ((TrackSpline.ControlPointCount - 1 - TailCP) % SectionCPCount == 0)
			{
				curvySplineSegment.SerializedOrientationAnchor = true;
			}
		}
	}
	public class MDJunctionControl : CurvyMetadataBase
	{
		public bool UseJunction;

		public void Toggle()
		{
			UseJunction = !UseJunction;
		}
	}
	public class MetaDataController : SplineController
	{
		[Section("MetaController", true, false, 100, Sort = 0)]
		[RangeEx(0f, 30f, "", "")]
		[SerializeField]
		private float m_MaxHeight = 5f;

		public float MaxHeight
		{
			get
			{
				return m_MaxHeight;
			}
			set
			{
				if (m_MaxHeight != value)
				{
					m_MaxHeight = value;
				}
			}
		}

		protected override void UserAfterInit()
		{
			setHeight();
		}

		protected override void UserAfterUpdate()
		{
			setHeight();
		}

		private void setHeight()
		{
			if (Spline.Dirty)
			{
				Spline.Refresh();
			}
			float interpolatedMetadata = Spline.GetInterpolatedMetadata<HeightMetadata, float>(base.RelativePosition);
			base.transform.Translate(0f, interpolatedMetadata * MaxHeight, 0f, Space.Self);
		}
	}
	public class MotorController : SplineController
	{
		[Section("Motor", true, false, 100)]
		public float MaxSpeed = 30f;

		protected override void Update()
		{
			float axis = Input.GetAxis("Vertical");
			base.Speed = Mathf.Abs(axis) * MaxSpeed;
			base.MovementDirection = MovementDirectionMethods.FromInt((int)Mathf.Sign(axis));
			base.Update();
		}
	}
	[ExecuteInEditMode]
	public class MoveToNearestPoint : MonoBehaviour
	{
		public Transform Lookup;

		public CurvySpline Spline;

		public Text StatisticsText;

		public Slider Density;

		private TimeMeasure Timer = new TimeMeasure(30);

		private void Update()
		{
			if ((bool)Spline && Spline.IsInitialized && (bool)Lookup && !Spline.Dirty)
			{
				Timer.Start();
				float nearestPointTF = Spline.GetNearestPointTF(Lookup.position, Space.World);
				Timer.Stop();
				base.transform.position = Spline.Interpolate(nearestPointTF, Space.World);
				StatisticsText.text = $"Blue Curve Cache Points: {Spline.CacheSize} \nAverage Lookup (ms): {Timer.AverageMS:0.000}";
			}
		}

		public void OnSliderChange()
		{
			Spline.CacheDensity = (int)Density.value;
		}
	}
	public class PaintSpline : MonoBehaviour
	{
		public float StepDistance = 30f;

		public SplineController Controller;

		public Text InfoText;

		private CurvySpline mSpline;

		private Vector2 mLastControlPointPos;

		private bool mResetSpline = true;

		private void Awake()
		{
			mSpline = GetComponent<CurvySpline>();
		}

		private void OnGUI()
		{
			if (mSpline == null || !mSpline.IsInitialized || !Controller)
			{
				return;
			}
			Event current = Event.current;
			switch (current.type)
			{
			case EventType.MouseDrag:
				if (mResetSpline)
				{
					mSpline.Clear();
					addCP(current.mousePosition);
					Controller.gameObject.SetActive(value: true);
					Controller.AbsolutePosition = 0f;
					mLastControlPointPos = current.mousePosition;
					mResetSpline = false;
				}
				else if ((current.mousePosition - mLastControlPointPos).magnitude >= StepDistance)
				{
					mLastControlPointPos = current.mousePosition;
					addCP(current.mousePosition);
					if (Controller.PlayState != CurvyController.CurvyControllerState.Playing)
					{
						Controller.Play();
					}
				}
				break;
			case EventType.MouseUp:
				mResetSpline = true;
				break;
			}
		}

		private CurvySplineSegment addCP(Vector3 mousePos)
		{
			Vector3 position = Camera.main.ScreenToWorldPoint(mousePos);
			position.y *= -1f;
			position.z += 100f;
			CurvySplineSegment result = mSpline.InsertAfter(null, position);
			InfoText.text = "Control Points: " + mSpline.ControlPointCount;
			return result;
		}
	}
	public class PerformanceAPI : MonoBehaviour
	{
		private const int LOOPS = 20;

		private List<string> mTests = new List<string>();

		private List<string> mTestResults = new List<string>();

		private CurvyInterpolation mInterpolation = CurvyInterpolation.CatmullRom;

		private CurvyOrientation mOrientation = CurvyOrientation.Dynamic;

		private int mCacheSize = 50;

		private int mControlPointCount = 20;

		private int mTotalSplineLength = 100;

		private bool mUseCache;

		private bool mUseMultiThreads = true;

		private int mCurrentTest = -1;

		private bool mExecuting;

		private TimeMeasure Timer = new TimeMeasure(20);

		private MethodInfo mGUIMethod;

		private MethodInfo mRunMethod;

		private bool mInterpolate_UseDistance;

		private int mRefresh_Mode;

		private void Awake()
		{
			mTests.Add("Interpolate");
			mTests.Add("Refresh");
		}

		private void OnGUI()
		{
			GUILayout.BeginVertical(GUI.skin.box);
			GUILayout.Label("Curvy offers various options to fine-tune performance vs. precision balance:");
			GUILayout.BeginHorizontal();
			GUILayout.Label("Interpolation: ");
			if (GUILayout.Toggle(mInterpolation == CurvyInterpolation.Linear, "Linear", GUI.skin.button))
			{
				mInterpolation = CurvyInterpolation.Linear;
			}
			if (GUILayout.Toggle(mInterpolation == CurvyInterpolation.Bezier, "Bezier", GUI.skin.button))
			{
				mInterpolation = CurvyInterpolation.Bezier;
			}
			if (GUILayout.Toggle(mInterpolation == CurvyInterpolation.CatmullRom, "CatmullRom", GUI.skin.button))
			{
				mInterpolation = CurvyInterpolation.CatmullRom;
			}
			if (GUILayout.Toggle(mInterpolation == CurvyInterpolation.TCB, "TCB", GUI.skin.button))
			{
				mInterpolation = CurvyInterpolation.TCB;
			}
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label("Orientation: ");
			if (GUILayout.Toggle(mOrientation == CurvyOrientation.None, "None", GUI.skin.button))
			{
				mOrientation = CurvyOrientation.None;
			}
			if (GUILayout.Toggle(mOrientation == CurvyOrientation.Static, "Static", GUI.skin.button))
			{
				mOrientation = CurvyOrientation.Static;
			}
			if (GUILayout.Toggle(mOrientation == CurvyOrientation.Dynamic, "Dynamic", GUI.skin.button))
			{
				mOrientation = CurvyOrientation.Dynamic;
			}
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label("Control Points (max): " + mControlPointCount);
			mControlPointCount = (int)GUILayout.HorizontalSlider(mControlPointCount, 2f, 1000f);
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label("Total spline length: " + mTotalSplineLength);
			mTotalSplineLength = (int)GUILayout.HorizontalSlider(mTotalSplineLength, 5f, 10000f);
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label("Cache Density: " + mCacheSize);
			mCacheSize = (int)GUILayout.HorizontalSlider(mCacheSize, 1f, 100f);
			GUILayout.EndHorizontal();
			mUseCache = GUILayout.Toggle(mUseCache, "Use Cache (where applicable)");
			mUseMultiThreads = GUILayout.Toggle(mUseMultiThreads, "Use Multiple Threads (where applicable)");
			GUILayout.Label("Select Test:");
			int num = GUILayout.SelectionGrid(Mathf.Max(0, mCurrentTest), mTests.ToArray(), 4);
			if (num != mCurrentTest)
			{
				mCurrentTest = num;
				Timer.Clear();
				mTestResults.Clear();
				mGUIMethod = GetType().MethodByName("GUI_" + mTests[mCurrentTest], includeInherited: false, includePrivate: true);
				mRunMethod = GetType().MethodByName("Test_" + mTests[mCurrentTest], includeInherited: false, includePrivate: true);
			}
			GUILayout.Space(5f);
			if (mGUIMethod != null)
			{
				mGUIMethod.Invoke(this, null);
			}
			GUI.enabled = !mExecuting && mRunMethod != null;
			if (GUILayout.Button(mExecuting ? "Please wait..." : ("Run (" + 20 + " times)")))
			{
				mExecuting = true;
				Timer.Clear();
				mTestResults.Clear();
				Invoke("runTest", 0.5f);
			}
			GUI.enabled = true;
			if (Timer.Count > 0)
			{
				foreach (string mTestResult in mTestResults)
				{
					GUILayout.Label(mTestResult);
				}
				GUILayout.Label($"Average (ms): {Timer.AverageMS:0.0000}");
				GUILayout.Label($"Minimum (ms): {Timer.MinimumMS:0.0000}");
				GUILayout.Label($"Maximum (ms): {Timer.MaximumMS:0.0000}");
			}
			GUILayout.EndVertical();
		}

		private void GUI_Interpolate()
		{
			GUILayout.Label("Interpolates position");
			mInterpolate_UseDistance = GUILayout.Toggle(mInterpolate_UseDistance, "By Distance");
		}

		private void Test_Interpolate()
		{
			CurvySpline spline = getSpline();
			addRandomCP(ref spline, mControlPointCount, mTotalSplineLength);
			mTestResults.Add("Cache Points: " + spline.CacheSize);
			mTestResults.Add($"Cache Point Distance: {(float)mTotalSplineLength / (float)spline.CacheSize:0.000}");
			Vector3 vector = Vector3.zero;
			if (mInterpolate_UseDistance)
			{
				for (int i = 0; i < 20; i++)
				{
					float distance = UnityEngine.Random.Range(0f, spline.Length);
					if (mUseCache)
					{
						Timer.Start();
						vector = spline.InterpolateByDistanceFast(distance);
						Timer.Stop();
					}
					else
					{
						Timer.Start();
						vector = spline.InterpolateByDistance(distance);
						Timer.Stop();
					}
				}
			}
			else
			{
				for (int j = 0; j < 20; j++)
				{
					float tf = UnityEngine.Random.Range(0, 1);
					if (mUseCache)
					{
						Timer.Start();
						vector = spline.InterpolateFast(tf);
						Timer.Stop();
					}
					else
					{
						Timer.Start();
						vector = spline.Interpolate(tf);
						Timer.Stop();
					}
				}
			}
			UnityEngine.Object.Destroy(spline.gameObject);
			vector.Set(0f, 0f, 0f);
		}

		private void GUI_Refresh()
		{
			GUILayout.Label("Refresh Spline or Single segment!");
			GUILayout.BeginHorizontal();
			GUILayout.Label("Mode:");
			mRefresh_Mode = GUILayout.SelectionGrid(mRefresh_Mode, new string[2] { "All", "Single random segment" }, 2);
			GUILayout.EndHorizontal();
		}

		private void Work()
		{
			for (int i = 0; i < 1000; i++)
			{
				new Vector3(1f, 2f, 3f).Normalize();
			}
		}

		private void work()
		{
			for (int i = 0; i < 1000; i++)
			{
				new Vector3(1f, 2f, 3f).Normalize();
			}
		}

		private void Test_Refresh()
		{
			CurvySpline spline = getSpline();
			addRandomCP(ref spline, mControlPointCount, mTotalSplineLength);
			mTestResults.Add("Cache Points: " + spline.CacheSize);
			mTestResults.Add($"Cache Point Distance: {(float)mTotalSplineLength / (float)spline.CacheSize:0.000}");
			for (int i = 0; i < 20; i++)
			{
				int idx = UnityEngine.Random.Range(0, spline.Count - 1);
				if (mRefresh_Mode == 0)
				{
					Timer.Start();
					spline.SetDirtyAll(SplineDirtyingType.Everything, dirtyConnectedControlPoints: true);
					spline.Refresh();
					Timer.Stop();
				}
				else
				{
					Timer.Start();
					spline.SetDirty(spline[idx], SplineDirtyingType.Everything);
					spline.Refresh();
					Timer.Stop();
				}
			}
			UnityEngine.Object.Destroy(spline.gameObject);
		}

		private CurvySpline getSpline()
		{
			CurvySpline curvySpline = CurvySpline.Create();
			curvySpline.Interpolation = mInterpolation;
			curvySpline.Orientation = mOrientation;
			curvySpline.CacheDensity = mCacheSize;
			curvySpline.UseThreading = mUseMultiThreads;
			curvySpline.Refresh();
			return curvySpline;
		}

		private void addRandomCP(ref CurvySpline spline, int count, int totalLength)
		{
			Vector3[] array = new Vector3[count];
			float num = (float)totalLength / (float)(count - 1);
			array[0] = Vector3.zero;
			for (int i = 1; i < count; i++)
			{
				int num2 = UnityEngine.Random.Range(0, 2);
				int num3 = ((UnityEngine.Random.Range(0f, 1f) > 0.5f) ? 1 : (-1));
				switch (num2)
				{
				case 0:
					array[i] = array[i - 1] + new Vector3(num * (float)num3, 0f, 0f);
					break;
				case 1:
					array[i] = array[i - 1] + new Vector3(0f, num * (float)num3, 0f);
					break;
				case 2:
					array[i] = array[i - 1] + new Vector3(0f, 0f, num * (float)num3);
					break;
				}
			}
			spline.Add(array);
			spline.Refresh();
		}

		private void runTest()
		{
			mRunMethod.Invoke(this, null);
			mExecuting = false;
		}
	}
	public class PerformanceDynamicSpline : MonoBehaviour
	{
		private CurvySpline mSpline;

		public CurvyGenerator Generator;

		[Positive]
		public int UpdateInterval = 200;

		[RangeEx(2f, 2000f, "", "")]
		public int CPCount = 100;

		[Positive]
		public float Radius = 20f;

		public bool AlwaysClear;

		public bool UpdateCG;

		private float mAngleStep;

		private float mCurrentAngle;

		private float mLastUpdateTime;

		private TimeMeasure ExecTimes = new TimeMeasure(10);

		private void Awake()
		{
			mSpline = GetComponent<CurvySpline>();
		}

		private void Start()
		{
			for (int i = 0; i < CPCount; i++)
			{
				addCP();
			}
			mSpline.Refresh();
			mLastUpdateTime = Time.timeSinceLevelLoad + 0.1f;
		}

		private void Update()
		{
			if (Time.timeSinceLevelLoad - (float)UpdateInterval * 0.001f > mLastUpdateTime)
			{
				mLastUpdateTime = Time.timeSinceLevelLoad;
				ExecTimes.Start();
				if (AlwaysClear)
				{
					mSpline.Clear();
				}
				while (mSpline.ControlPointCount > CPCount)
				{
					mSpline.Delete(mSpline.ControlPointsList[0], skipRefreshingAndEvents: true);
				}
				while (mSpline.ControlPointCount <= CPCount)
				{
					addCP();
				}
				mSpline.Refresh();
				ExecTimes.Stop();
			}
		}

		private void addCP()
		{
			mAngleStep = (float)Math.PI * 2f / ((float)CPCount + (float)CPCount * 0.25f);
			Vector3 position = base.transform.localToWorldMatrix.MultiplyPoint3x4(new Vector3(Mathf.Sin(mCurrentAngle) * Radius, Mathf.Cos(mCurrentAngle) * Radius, 0f));
			mSpline.InsertAfter(null, position, skipRefreshingAndEvents: true);
			mCurrentAngle = Mathf.Repeat(mCurrentAngle + mAngleStep, (float)Math.PI * 2f);
		}

		private void OnGUI()
		{
			GUILayout.BeginVertical(GUI.skin.box);
			GUILayout.BeginHorizontal();
			GUILayout.Label("Interval", GUILayout.Width(130f));
			UpdateInterval = (int)GUILayout.HorizontalSlider(UpdateInterval, 0f, 5000f, GUILayout.Width(200f));
			GUILayout.Label(UpdateInterval.ToString());
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label("# of Control Points", GUILayout.Width(130f));
			CPCount = (int)GUILayout.HorizontalSlider(CPCount, 2f, 200f, GUILayout.Width(200f));
			GUILayout.Label(CPCount.ToString());
			GUILayout.EndHorizontal();
			GUILayout.BeginHorizontal();
			GUILayout.Label("Radius", GUILayout.Width(130f));
			Radius = GUILayout.HorizontalSlider(Radius, 10f, 100f, GUILayout.Width(200f));
			GUILayout.Label(Radius.ToString("0.00"));
			GUILayout.EndHorizontal();
			AlwaysClear = GUILayout.Toggle(AlwaysClear, "Always clear");
			bool updateCG = UpdateCG;
			UpdateCG = GUILayout.Toggle(UpdateCG, "Use Curvy Generator");
			if (updateCG != UpdateCG)
			{
				Generator.gameObject.SetActive(UpdateCG);
			}
			GUILayout.Label("Avg. Execution Time (ms): " + ExecTimes.AverageMS.ToString("0.000"));
			GUILayout.EndVertical();
		}
	}
	public class PoolTestRunner : MonoBehaviour
	{
		public CurvySpline Spline;

		public Text PoolCountInfo;

		private void Start()
		{
			checkForSpline();
		}

		private void Update()
		{
			PoolCountInfo.text = $"Control Points in Pool: {DTSingleton<CurvyGlobalManager>.Instance.ControlPointPool.Count}";
		}

		private void checkForSpline()
		{
			if (Spline == null)
			{
				Spline = CurvySpline.Create();
				Camera.main.GetComponent<CurvyGLRenderer>().Add(Spline);
				for (int i = 0; i < 4; i++)
				{
					AddCP();
				}
			}
		}

		public void AddCP()
		{
			checkForSpline();
			Spline.Add(UnityEngine.Random.insideUnitCircle * 50f);
			Spline.Refresh();
		}

		public void DeleteCP()
		{
			if ((bool)Spline && Spline.ControlPointCount > 0)
			{
				int index = UnityEngine.Random.Range(0, Spline.ControlPointCount - 1);
				Spline.Delete(Spline.ControlPointsList[index]);
			}
		}

		public void ClearSpline()
		{
			if ((bool)Spline)
			{
				Spline.Clear();
			}
		}

		public void DeleteSpline()
		{
			if ((bool)Spline)
			{
				Spline.Destroy();
			}
		}
	}
	[RequireComponent(typeof(Rigidbody))]
	public class RigidBodySplineController : MonoBehaviour
	{
		public CurvySpline Spline;

		public SplineController CameraController;

		public float VSpeed = 10f;

		public float HSpeed = 0.5f;

		public float CenterDrag = 0.5f;

		public float JumpForce = 10f;

		private Rigidbody mRigidBody;

		private float mTF;

		private float velocity;

		private void Start()
		{
			mRigidBody = GetComponent<Rigidbody>();
		}

		private void LateUpdate()
		{
			if ((bool)CameraController)
			{
				float target = Spline.TFToDistance(mTF) - 5f;
				CameraController.AbsolutePosition = Mathf.SmoothDamp(CameraController.AbsolutePosition, target, ref velocity, 0.5f);
			}
		}

		private void FixedUpdate()
		{
			if ((bool)Spline)
			{
				float num = Input.GetAxis("Vertical") * VSpeed;
				float num2 = Input.GetAxis("Horizontal") * HSpeed;
				mTF = Spline.GetNearestPointTF(base.transform.localPosition, out var nearestPoint);
				if (num != 0f)
				{
					mRigidBody.AddForce(Spline.GetTangentFast(mTF) * num, ForceMode.Force);
				}
				if (num2 != 0f)
				{
					Vector3 vector = Spline.InterpolateFast(mTF) + Quaternion.AngleAxis(90f, Spline.GetTangentFast(mTF)) * Spline.GetOrientationUpFast(mTF);
					Vector3 vector2 = nearestPoint - vector;
					mRigidBody.AddForce(vector2 * num2, ForceMode.Force);
				}
				if (Input.GetKeyDown(KeyCode.Space))
				{
					mRigidBody.AddForce(Vector3.up * JumpForce, ForceMode.Impulse);
				}
				mRigidBody.AddForce((Spline.Interpolate(mTF) - base.transform.localPosition) * CenterDrag, ForceMode.VelocityChange);
			}
		}
	}
	public class RunnerController : SplineController
	{
		private enum GuideMode
		{
			Guided,
			Jumping,
			FreeFall
		}

		[Section("Jump", true, false, 100)]
		public float JumpHeight = 20f;

		public float JumpSpeed = 0.5f;

		public AnimationCurve JumpCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		public float Gravity = 10f;

		private GuideMode mMode;

		private float jumpHeight;

		private float fallingSpeed;

		private SplineRefMetadata mPossibleSwitchTarget;

		private int mSwitchInProgress;

		protected override void OnDisable()
		{
			base.OnDisable();
			StopAllCoroutines();
		}

		protected override void InitializedApplyDeltaTime(float deltaTime)
		{
			if (Input.GetButtonDown("Fire1") && mMode == GuideMode.Guided)
			{
				StartCoroutine(Jump());
			}
			if (mPossibleSwitchTarget != null && mSwitchInProgress == 0)
			{
				float axisRaw = Input.GetAxisRaw("Horizontal");
				if (mPossibleSwitchTarget.Options == "Right" && axisRaw > 0f)
				{
					Switch(1);
				}
				else if (mPossibleSwitchTarget.Options == "Left" && axisRaw < 0f)
				{
					Switch(-1);
				}
			}
			else if (mSwitchInProgress != 0 && !base.IsSwitching)
			{
				mSwitchInProgress = 0;
				OnCPReached(new CurvySplineMoveEventArgs(this, Spline, Spline.TFToSegment(base.RelativePosition), 0f, usingWorldUnits: false, 0f, MovementDirection.Forward));
			}
			base.InitializedApplyDeltaTime(deltaTime);
			if (mMode == GuideMode.FreeFall)
			{
				fallingSpeed += Gravity * deltaTime;
				base.OffsetRadius -= fallingSpeed;
				if (base.OffsetRadius <= 0f)
				{
					mMode = GuideMode.Guided;
					fallingSpeed = 0f;
					base.OffsetRadius = 0f;
				}
			}
			if (mMode == GuideMode.Jumping)
			{
				base.OffsetRadius = jumpHeight;
			}
		}

		private void Switch(int dir)
		{
			mSwitchInProgress = dir;
			Vector3 vector = mPossibleSwitchTarget.Spline.transform.InverseTransformPoint(base.transform.position);
			Vector3 nearestPoint;
			float nearestPointTF = mPossibleSwitchTarget.Spline.GetNearestPointTF(vector, out nearestPoint, mPossibleSwitchTarget.CP.Spline.GetSegmentIndex(mPossibleSwitchTarget.CP));
			float duration = (nearestPoint - vector).magnitude / base.Speed;
			SwitchTo(mPossibleSwitchTarget.Spline, nearestPointTF, duration);
		}

		private IEnumerator Jump()
		{
			mMode = GuideMode.Jumping;
			float start = Time.time;
			float f = 0f;
			while (f < 1f && mMode == GuideMode.Jumping)
			{
				f = (Time.time - start) / JumpSpeed;
				jumpHeight = JumpCurve.Evaluate(f) * JumpHeight;
				yield return new WaitForEndOfFrame();
			}
			if (mMode == GuideMode.Jumping)
			{
				mMode = GuideMode.Guided;
			}
		}

		public void OnCPReached(CurvySplineMoveEventArgs e)
		{
			mPossibleSwitchTarget = e.ControlPoint.GetMetadata<SplineRefMetadata>();
			if ((bool)mPossibleSwitchTarget && !mPossibleSwitchTarget.Spline)
			{
				mPossibleSwitchTarget = null;
			}
		}

		public void UseFollowUpOrFall(CurvySplineMoveEventArgs e)
		{
			CurvySplineSegment controlPoint = e.ControlPoint;
			if (controlPoint == e.Spline.FirstVisibleControlPoint && (bool)controlPoint.Connection && !controlPoint.FollowUp)
			{
				float f = controlPoint.transform.position.y - controlPoint.Connection.OtherControlPoints(controlPoint)[0].transform.position.y;
				mMode = GuideMode.FreeFall;
				fallingSpeed = 0f;
				base.OffsetRadius += Mathf.Abs(f);
			}
		}
	}
	public class SceneSwitcher : MonoBehaviour
	{
		public Text Text;

		public Dropdown DropDown;

		private Dictionary<string, string> scenesAlternativeNames = new Dictionary<string, string>
		{
			{ "00_SplineController", "Move object: Follow a static spline" },
			{ "04_PaintSpline", "Move object: Follow a dynamic spline" },
			{ "20_CGPaths", "Move object: Follow a blended spline" },
			{ "21_CGExtrusion", "Move object: Follow a Curvy generated volume" },
			{ "06_Orientation", "Basics: Store orientation data in a spline" },
			{ "01_MetaData", "Basics: Store custom data in a spline" },
			{ "05_NearestPoint", "Basics: Find nearest point on spline" },
			{ "03_Connections", "Basics: Connections and events" },
			{ "24_CGConformPath", "Basics: Project a Spline onto a mesh" },
			{ "10_RBSplineController", "Physics: Interaction with a Curvy spline" },
			{ "11_Rigidbody", "Physics: Interaction with a Curvy generated mesh" },
			{ "02_GUI", "Splines and UI" },
			{ "22_CGClonePrefabs", "Advanced: Clone objects along a spline" },
			{ "26_CGExtrusionExtendedUV", "Advanced: Extended UV functionality" },
			{ "27_CGVariableExtrusion", "Advanced: Variable shape extrusion" },
			{ "12_Train", "Train: Railway junction" },
			{ "13_TrainMultiTrackDrifting", "Train: Multi tracks drifting!" },
			{ "25_CGExtrusionAdvanced", "Train: Advanced scene" },
			{ "23_CGTube", "Space tube" },
			{ "50_EndlessRunner", "Space Runner" },
			{ "51_InfiniteTrack", "Dynamically generated infinite track" }
		};

		private int CurrentLevel
		{
			get
			{
				return SceneManager.GetActiveScene().buildIndex;
			}
			set
			{
				if (CurrentLevel != value)
				{
					SceneManager.LoadScene(value, LoadSceneMode.Single);
				}
			}
		}

		private void Start()
		{
			List<string> scenes = getScenes();
			if (scenes.Count == 0 || CurrentLevel < 0)
			{
				Text.text = "Add scenes to the build settings to enable the scene switcher!";
			}
			else
			{
				Text.text = "Scene selector";
				DropDown.ClearOptions();
				DropDown.AddOptions(scenes);
			}
			DropDown.value = CurrentLevel;
			DropDown.onValueChanged.AddListener(OnValueChanged);
		}

		private List<string> getScenes()
		{
			int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
			List<string> list = new List<string>(sceneCountInBuildSettings);
			for (int i = 0; i < sceneCountInBuildSettings; i++)
			{
				string text = SceneUtility.GetScenePathByBuildIndex(i).Split('/')[^1].TrimEnd(".unity");
				string item = ((!scenesAlternativeNames.ContainsKey(text)) ? text : scenesAlternativeNames[text]);
				list.Add(item);
			}
			return list;
		}

		private void OnValueChanged(int value)
		{
			CurrentLevel = DropDown.value;
		}
	}
	public class SmoothFollow : MonoBehaviour
	{
		[SerializeField]
		private Transform target;

		[SerializeField]
		private float distance = 10f;

		[SerializeField]
		private float height = 5f;

		[SerializeField]
		private float rotationDamping;

		[SerializeField]
		private float heightDamping;

		private void Start()
		{
		}

		private void LateUpdate()
		{
			if ((bool)target)
			{
				float y = target.eulerAngles.y;
				float b = target.position.y + height;
				float y2 = base.transform.eulerAngles.y;
				float y3 = base.transform.position.y;
				y2 = Mathf.LerpAngle(y2, y, rotationDamping * Time.deltaTime);
				y3 = Mathf.Lerp(y3, b, heightDamping * Time.deltaTime);
				Quaternion quaternion = Quaternion.Euler(0f, y2, 0f);
				base.transform.position = target.position;
				base.transform.position -= quaternion * Vector3.forward * distance;
				base.transform.position = new Vector3(base.transform.position.x, y3, base.transform.position.z);
				base.transform.LookAt(target);
			}
		}
	}
	public class SplineControllerInputRail : MonoBehaviour
	{
		public float acceleration = 0.1f;

		public float limit = 30f;

		public SplineController splineController;

		private void Update()
		{
			float num = Mathf.Clamp(Input.GetAxis("Vertical"), -1f, 1f);
			splineController.Speed = Mathf.Clamp(splineController.Speed + num * acceleration * Time.deltaTime, 0.001f, limit);
		}
	}
	public class SplineRefMetadata : CurvyMetadataBase
	{
		public new CurvySpline Spline;

		public CurvySplineSegment CP;

		public string Options;
	}
	[ExecuteInEditMode]
	public class TrainCarDrifter : MonoBehaviour
	{
		public float speed = 30f;

		public float wheelSpacing = 9.72f;

		public Vector3 bodyOffset = new Vector3(0f, 1f, 0f);

		public SplineController controllerWheelLeading;

		public SplineController controllerWheelTrailing;

		public Transform trainCar;

		private void Start()
		{
			controllerWheelLeading.Speed = speed;
		}

		private void Update()
		{
			if ((bool)controllerWheelLeading && (bool)controllerWheelTrailing && (bool)controllerWheelLeading.Spline && (bool)controllerWheelTrailing.Spline && controllerWheelLeading.Spline != controllerWheelTrailing.Spline && (bool)trainCar)
			{
				Vector3 localPosition = controllerWheelTrailing.Spline.transform.InverseTransformPoint(controllerWheelLeading.transform.position);
				Vector3 nearestPoint;
				float nearestPointTF = controllerWheelTrailing.Spline.GetNearestPointTF(localPosition, out nearestPoint);
				controllerWheelTrailing.RelativePosition = nearestPointTF;
				float num = Vector3.Distance(controllerWheelLeading.transform.position, nearestPoint);
				float num2 = Mathf.Clamp(Mathf.Sqrt(wheelSpacing * wheelSpacing - num * num), 0f, 20f);
				controllerWheelTrailing.AbsolutePosition -= num2;
				trainCar.position = (controllerWheelLeading.transform.position + controllerWheelTrailing.transform.position) / 2f + bodyOffset;
				Vector3 worldPosition = new Vector3(controllerWheelLeading.transform.position.x, trainCar.transform.position.y, controllerWheelLeading.transform.position.z);
				trainCar.LookAt(worldPosition, controllerWheelLeading.transform.up);
			}
		}
	}
	[ExecuteInEditMode]
	public class TrainCarManager : MonoBehaviour
	{
		public SplineController Waggon;

		public SplineController FrontAxis;

		public SplineController BackAxis;

		private TrainManager mTrain;

		public float Position
		{
			get
			{
				return Waggon.AbsolutePosition;
			}
			set
			{
				if (Waggon.AbsolutePosition != value)
				{
					Waggon.AbsolutePosition = value;
					FrontAxis.AbsolutePosition = value + mTrain.AxisDistance / 2f;
					BackAxis.AbsolutePosition = value - mTrain.AxisDistance / 2f;
				}
			}
		}

		private void LateUpdate()
		{
			if ((bool)mTrain && BackAxis.Spline == FrontAxis.Spline && FrontAxis.RelativePosition > BackAxis.RelativePosition)
			{
				float absolutePosition = Waggon.AbsolutePosition;
				float absolutePosition2 = FrontAxis.AbsolutePosition;
				float absolutePosition3 = BackAxis.AbsolutePosition;
				if (Mathf.Abs(Mathf.Abs(absolutePosition2 - absolutePosition3) - mTrain.AxisDistance) >= mTrain.Limit)
				{
					FrontAxis.AbsolutePosition = absolutePosition + mTrain.AxisDistance / 2f;
					BackAxis.AbsolutePosition = absolutePosition - mTrain.AxisDistance / 2f;
				}
			}
		}

		public void setup()
		{
			mTrain = GetComponentInParent<TrainManager>();
			if ((bool)mTrain.Spline)
			{
				setController(Waggon, mTrain.Spline, mTrain.Speed);
				setController(FrontAxis, mTrain.Spline, mTrain.Speed);
				setController(BackAxis, mTrain.Spline, mTrain.Speed);
			}
		}

		private void setController(SplineController c, CurvySpline spline, float speed)
		{
			c.Spline = spline;
			c.Speed = speed;
			c.OnControlPointReached.AddListenerOnce(OnCPReached);
		}

		public void OnCPReached(CurvySplineMoveEventArgs e)
		{
			MDJunctionControl metadata = e.ControlPoint.GetMetadata<MDJunctionControl>();
			e.Sender.ConnectionBehavior = ((!metadata || metadata.UseJunction) ? SplineControllerConnectionBehavior.RandomSpline : SplineControllerConnectionBehavior.CurrentSpline);
		}
	}
	[ExecuteInEditMode]
	public class TrainManager : MonoBehaviour
	{
		public CurvySpline Spline;

		public float Speed;

		public float Position;

		public float CarSize = 10f;

		public float AxisDistance = 8f;

		public float CarGap = 1f;

		public float Limit = 0.2f;

		private bool isSetup;

		private TrainCarManager[] Cars;

		private void Start()
		{
			setup();
		}

		private void OnDisable()
		{
			isSetup = false;
		}

		private void LateUpdate()
		{
			if (!isSetup)
			{
				setup();
			}
			if (Cars.Length <= 1)
			{
				return;
			}
			TrainCarManager trainCarManager = Cars[0];
			TrainCarManager trainCarManager2 = Cars[Cars.Length - 1];
			if (!(trainCarManager.FrontAxis.Spline == trainCarManager2.BackAxis.Spline) || !(trainCarManager.FrontAxis.RelativePosition > trainCarManager2.BackAxis.RelativePosition))
			{
				return;
			}
			for (int i = 1; i < Cars.Length; i++)
			{
				float num = Cars[i - 1].Position - Cars[i].Position - CarSize - CarGap;
				if (Mathf.Abs(num) >= Limit)
				{
					Cars[i].Position += num;
				}
			}
		}

		private void setup()
		{
			if (Spline.Dirty)
			{
				Spline.Refresh();
			}
			Cars = GetComponentsInChildren<TrainCarManager>();
			float num = Position - CarSize / 2f;
			for (int i = 0; i < Cars.Length; i++)
			{
				Cars[i].setup();
				if ((bool)Cars[i].BackAxis && (bool)Cars[i].FrontAxis && (bool)Cars[i].Waggon)
				{
					Cars[i].Position = num;
				}
				num -= CarSize + CarGap;
			}
			isSetup = true;
		}
	}
	public class VolumeControllerInput : MonoBehaviour
	{
		public float AngularVelocity = 0.2f;

		public ParticleSystem explosionEmitter;

		public VolumeController volumeController;

		public Transform rotatedTransform;

		public float maxSpeed = 40f;

		public float accelerationForward = 20f;

		public float accelerationBackward = 40f;

		private bool mGameOver;

		private void Awake()
		{
			if (!volumeController)
			{
				volumeController = GetComponent<VolumeController>();
			}
		}

		private void Start()
		{
			if (volumeController.IsReady)
			{
				ResetController();
				return;
			}
			volumeController.OnInitialized.AddListener(delegate
			{
				ResetController();
			});
		}

		private void ResetController()
		{
			volumeController.Speed = 0f;
			volumeController.RelativePosition = 0f;
			volumeController.CrossRelativePosition = 0f;
		}

		private void Update()
		{
			if ((bool)volumeController && !mGameOver)
			{
				if (volumeController.PlayState != CurvyController.CurvyControllerState.Playing)
				{
					volumeController.Play();
				}
				Vector2 normalized = new Vector2(Input.GetAxis("Horizontal"), Input.GetAxis("Vertical")).normalized;
				float value = volumeController.Speed + normalized.y * Time.deltaTime * Mathf.Lerp(accelerationBackward, accelerationForward, (normalized.y + 1f) / 2f);
				volumeController.Speed = Mathf.Clamp(value, 0f, maxSpeed);
				volumeController.CrossRelativePosition += AngularVelocity * Mathf.Clamp(volumeController.Speed / 10f, 0.2f, 1f) * normalized.x * Time.deltaTime;
				if ((bool)rotatedTransform)
				{
					float y = Mathf.Lerp(-90f, 90f, (normalized.x + 1f) / 2f);
					rotatedTransform.localRotation = Quaternion.Euler(0f, y, 0f);
				}
			}
		}

		public void OnCollisionEnter(Collision collision)
		{
		}

		public void OnTriggerEnter(Collider other)
		{
			if (!mGameOver)
			{
				explosionEmitter.Emit(200);
				volumeController.Pause();
				mGameOver = true;
				Invoke("StartOver", 1f);
			}
		}

		private void StartOver()
		{
			ResetController();
			mGameOver = false;
		}
	}
}
namespace CrazyMinnow.SALSA.OneClicks
{
	public class OneClickBase : MonoBehaviour
	{
		public const string RESOURCE_CLIP = "Assets/Crazy Minnow Studio/Examples/Audio/Promo-male.mp3";

		public const string PREFAB_ALERT_TITLE = "Prefab Unpack Warning";

		public const string PREFAB_ALERT_MSG = "Your selection is a prefab and must be unpacked to apply this setup. You can create a new prefab once the setup is complete. Do you want to proceed?";

		protected static List<SkinnedMeshRenderer> requiredSmrs = new List<SkinnedMeshRenderer>();

		protected static List<OneClickConfiguration> oneClickConfigurations = new List<OneClickConfiguration>();

		protected static Salsa salsa;

		protected static Emoter emoter;

		protected static UmaUepProxy uepProxy;

		protected static GameObject selectedObject;

		protected static float emphasizerTrigger;

		protected static bool autoAdjustAnalysis = true;

		protected static bool autoAdjustMicrophone = false;

		protected static float audioUpdateDelay = 0.0875f;

		protected static float loCutoff = 0.015f;

		protected static float hiCutoff = 0.75f;

		protected static bool useAdvDyn = true;

		protected static float advDynPrimaryBias = 0.45f;

		protected static bool useAdvDynJitter = true;

		protected static float advDynJitterAmount = 0.1f;

		protected static float advDynJitterProb = 0.2f;

		protected static float advDynSecondaryMix = 0f;

		protected static float emphasisChance = 1f;

		protected static bool useRandomEmotes = false;

		protected static bool isChancePerEmote = false;

		protected static int numRandomEmotesPerCycle = 1;

		protected static float randomEmoteMinTimer = 1f;

		protected static float randomEmoteMaxTimer = 2f;

		protected static float randomChance = 0.5f;

		protected static bool useRandomFrac = false;

		protected static float randomFracBias = 0.5f;

		protected static bool useRandomHoldDuration = false;

		protected static float randomHoldDurationMin = 0.1f;

		protected static float randomHoldDurationMax = 0.5f;

		protected static LerpEasings.EasingType easingType = LerpEasings.EasingType.CubicOut;

		private static OneClickConfiguration currentConfiguration;

		protected static void NewConfiguration(OneClickConfiguration.ConfigType configType)
		{
			oneClickConfigurations.Add(new OneClickConfiguration(configType));
			currentConfiguration = oneClickConfigurations[oneClickConfigurations.Count - 1];
		}

		protected static void AddSmrSearch(string search)
		{
			currentConfiguration.smrSearches.Add(search);
		}

		protected static void NewExpression(string expressionName)
		{
			if (currentConfiguration.type == OneClickConfiguration.ConfigType.Salsa)
			{
				currentConfiguration.oneClickExpressions.Add(new OneClickExpression(expressionName, new List<OneClickComponent>()));
			}
			else
			{
				currentConfiguration.oneClickExpressions.Add(new OneClickEmoterExpression(expressionName, new List<OneClickComponent>()));
			}
		}

		protected static void AddShapeComponent(string[] blendshapeNames, float durOn, float durHold, float durOff, string componentName = "", float amount = 1f, bool useRegex = false)
		{
			currentConfiguration.oneClickExpressions[currentConfiguration.oneClickExpressions.Count - 1].components.Add(new OneClickShapeComponent(componentName, blendshapeNames, amount, durOn, durHold, durOff, OneClickComponent.ComponentType.Shape, useRegex));
		}

		protected static void AddUepPoseComponent(string poseName, float durOn, float durHold, float durOff, string componentName = "", float amount = 1f)
		{
			currentConfiguration.oneClickExpressions[currentConfiguration.oneClickExpressions.Count - 1].components.Add(new OneClickUepComponent(componentName, poseName, amount, durOn, durHold, durOff, OneClickComponent.ComponentType.UMA));
		}

		protected static void AddAnimatorComponent(string componentName, string animatorSearch, float durOn, float durHold, float durOff, int parmIndex, bool isTriggereParmBiDir = false)
		{
			currentConfiguration.oneClickExpressions[currentConfiguration.oneClickExpressions.Count - 1].components.Add(new OneClickAnimatorComponent(componentName, animatorSearch, parmIndex, isTriggereParmBiDir, durOn, durHold, durOff, OneClickComponent.ComponentType.Animator));
		}

		protected static void AddBoneComponent(string componentSearchName, TformBase maxTform, float durOn, float durHold, float durOff, string componentName = "", bool constrainPos = false, bool constrainRot = true, bool constrainScl = false)
		{
			currentConfiguration.oneClickExpressions[currentConfiguration.oneClickExpressions.Count - 1].components.Add(new OneClickBoneComponent(componentName, componentSearchName, maxTform, constrainPos, constrainRot, constrainScl, durOn, durHold, durOff, OneClickComponent.ComponentType.Bone));
		}

		protected static void AddEmoteFlags(bool isRandom, bool isEmph, bool isRepeater, float frac = 1f, bool isAlwaysEmph = false)
		{
			((OneClickEmoterExpression)currentConfiguration.oneClickExpressions[currentConfiguration.oneClickExpressions.Count - 1]).SetEmoterBools(isRandom, isEmph, isRepeater, frac, isAlwaysEmph);
		}

		protected static void DoOneClickiness(GameObject go, AudioClip clip)
		{
			selectedObject = go;
			QueueProcessor queueProcessor = selectedObject.GetComponent<QueueProcessor>();
			if (queueProcessor == null)
			{
				queueProcessor = selectedObject.AddComponent<QueueProcessor>();
			}
			uepProxy = go.GetComponent<UmaUepProxy>();
			foreach (OneClickConfiguration oneClickConfiguration in oneClickConfigurations)
			{
				if (!FindSkinnedMeshRenderers(oneClickConfiguration))
				{
					break;
				}
				switch (oneClickConfiguration.type)
				{
				case OneClickConfiguration.ConfigType.Salsa:
					ConfigureSalsaSettings(clip, queueProcessor);
					break;
				case OneClickConfiguration.ConfigType.Emoter:
					ConfigEmoterSettings(queueProcessor);
					break;
				}
				ConfigureModuleExpressions(oneClickConfiguration);
			}
		}

		private static bool FindSkinnedMeshRenderers(OneClickConfiguration configuration)
		{
			requiredSmrs.Clear();
			if (configuration.smrSearches.Count > 0)
			{
				SkinnedMeshRenderer[] componentsInChildren = selectedObject.GetComponentsInChildren<SkinnedMeshRenderer>();
				if (componentsInChildren == null || componentsInChildren.Length == 0)
				{
					UnityEngine.Debug.LogError("This object does not have the required components. No Skinned Mesh Renderers found. Ensure this one-click script was applied to the root of the model prefab in the scene hierarchy.");
					return false;
				}
				SkinnedMeshRenderer[] array = componentsInChildren;
				foreach (SkinnedMeshRenderer skinnedMeshRenderer in array)
				{
					foreach (string smrSearch in configuration.smrSearches)
					{
						if (Regex.IsMatch(skinnedMeshRenderer.name, smrSearch, RegexOptions.IgnoreCase))
						{
							requiredSmrs.Add(skinnedMeshRenderer);
						}
					}
				}
				if (requiredSmrs.Count == 0)
				{
					string text = "";
					foreach (string smrSearch2 in configuration.smrSearches)
					{
						text = text + smrSearch2 + " ";
					}
					UnityEngine.Debug.LogError("This object does not have the required components. Could not find the referenced SMRs. Ensure the appropriate one-click was used for your model type and generation. " + text);
					return false;
				}
			}
			return true;
		}

		private static void ConfigEmoterSettings(QueueProcessor qp)
		{
			emoter = selectedObject.GetComponent<Emoter>();
			if (emoter == null)
			{
				emoter = selectedObject.AddComponent<Emoter>();
			}
			if (salsa != null)
			{
				salsa.emoter = emoter;
			}
			emoter.queueProcessor = qp;
			emoter.lipsyncEmphasisChance = emphasisChance;
			emoter.useRandomEmotes = useRandomEmotes;
			emoter.isChancePerEmote = isChancePerEmote;
			emoter.NumRandomEmotesPerCycle = numRandomEmotesPerCycle;
			emoter.randomEmoteMinTimer = randomEmoteMinTimer;
			emoter.randomEmoteMaxTimer = randomEmoteMaxTimer;
			emoter.randomChance = randomChance;
			emoter.useRandomFrac = useRandomFrac;
			emoter.randomFracBias = randomFracBias;
			emoter.useRandomHoldDuration = useRandomHoldDuration;
			emoter.randomHoldDurationMin = randomHoldDurationMin;
			emoter.randomHoldDurationMax = randomHoldDurationMax;
			emoter.emotes.Clear();
		}

		private static void ConfigureSalsaSettings(AudioClip clip, QueueProcessor qp)
		{
			salsa = selectedObject.GetComponent<Salsa>();
			if (salsa == null)
			{
				salsa = selectedObject.AddComponent<Salsa>();
			}
			AudioSource audioSource = selectedObject.GetComponent<AudioSource>();
			if (audioSource == null)
			{
				audioSource = selectedObject.AddComponent<AudioSource>();
			}
			audioSource.playOnAwake = true;
			audioSource.loop = false;
			if (clip != null && audioSource.clip == null)
			{
				audioSource.clip = clip;
			}
			salsa.audioSrc = audioSource;
			salsa.queueProcessor = qp;
			salsa.autoAdjustAnalysis = autoAdjustAnalysis;
			salsa.autoAdjustMicrophone = autoAdjustMicrophone;
			salsa.audioUpdateDelay = audioUpdateDelay;
			salsa.loCutoff = loCutoff;
			salsa.hiCutoff = hiCutoff;
			salsa.useAdvDyn = useAdvDyn;
			salsa.advDynPrimaryBias = advDynPrimaryBias;
			salsa.useAdvDynJitter = useAdvDynJitter;
			salsa.advDynJitterAmount = advDynJitterAmount;
			salsa.advDynJitterProb = advDynJitterProb;
			salsa.advDynSecondaryMix = advDynSecondaryMix;
			salsa.emphasizerTrigger = emphasizerTrigger;
			salsa.visemes.Clear();
		}

		protected static void Init()
		{
			oneClickConfigurations.Clear();
			requiredSmrs.Clear();
		}

		private static void ConfigureModuleExpressions(OneClickConfiguration configuration)
		{
			for (int i = 0; i < configuration.oneClickExpressions.Count; i++)
			{
				Expression expression = InitializeExpressionType(configuration, i);
				int num = 0;
				int num2 = 0;
				new ExpressionComponent();
				for (int j = 0; j < configuration.oneClickExpressions[i].components.Count; j++)
				{
					OneClickComponent oneClickComponent = configuration.oneClickExpressions[i].components[j];
					switch (oneClickComponent.type)
					{
					case OneClickComponent.ComponentType.Shape:
					{
						for (int k = 0; k < requiredSmrs.Count; k++)
						{
							OneClickShapeComponent oneClickShapeComponent = (OneClickShapeComponent)oneClickComponent;
							int num3 = -1;
							string[] blendshapeNames = oneClickShapeComponent.blendshapeNames;
							foreach (string text in blendshapeNames)
							{
								num3 = ((!oneClickShapeComponent.useRegex) ? requiredSmrs[k].sharedMesh.GetBlendShapeIndex(text) : RegexFindBlendshapeName(requiredSmrs[k], text));
								if (num3 > -1)
								{
									break;
								}
							}
							if (num3 != -1)
							{
								num2 = CreateNewComponent(num, expression);
								InspectorControllerHelperData inspectorControllerHelperData = expression.controllerVars[num2];
								inspectorControllerHelperData.smr = requiredSmrs[k];
								inspectorControllerHelperData.blendIndex = num3;
								inspectorControllerHelperData.minShape = 0f;
								inspectorControllerHelperData.maxShape = oneClickShapeComponent.maxAmount;
								ExpressionComponent expressionComponent3 = expression.components[num2];
								expressionComponent3.controlType = ExpressionComponent.ControlType.Shape;
								ApplyCommonSettingsToComponent(expressionComponent3, oneClickComponent, num2);
								num++;
							}
						}
						break;
					}
					case OneClickComponent.ComponentType.UMA:
					{
						OneClickUepComponent oneClickUepComponent = (OneClickUepComponent)oneClickComponent;
						num2 = CreateNewComponent(num, expression);
						InspectorControllerHelperData inspectorControllerHelperData = expression.controllerVars[num2];
						inspectorControllerHelperData.umaUepProxy = uepProxy;
						inspectorControllerHelperData.blendIndex = uepProxy.GetPoseIndex(oneClickUepComponent.poseName);
						inspectorControllerHelperData.minShape = 0f;
						inspectorControllerHelperData.uepAmount = oneClickUepComponent.maxAmount;
						ExpressionComponent expressionComponent2 = expression.components[num2];
						expressionComponent2.controlType = ExpressionComponent.ControlType.UMA;
						ApplyCommonSettingsToComponent(expressionComponent2, oneClickComponent, num2);
						num++;
						break;
					}
					case OneClickComponent.ComponentType.Bone:
					{
						OneClickBoneComponent oneClickBoneComponent = (OneClickBoneComponent)oneClickComponent;
						Transform transform = FindBone(oneClickBoneComponent.componentSearchName);
						if (transform == null)
						{
							UnityEngine.Debug.LogWarning("Could not find bone: " + oneClickBoneComponent.componentSearchName);
							break;
						}
						num2 = CreateNewComponent(num, expression);
						InspectorControllerHelperData inspectorControllerHelperData = expression.controllerVars[num2];
						inspectorControllerHelperData.bone = transform;
						inspectorControllerHelperData.startTform = ConvertBoneToTform(transform);
						inspectorControllerHelperData.endTform = oneClickBoneComponent.max;
						inspectorControllerHelperData.fracRot = oneClickBoneComponent.useRot;
						inspectorControllerHelperData.fracPos = oneClickBoneComponent.usePos;
						inspectorControllerHelperData.fracScl = oneClickBoneComponent.useScl;
						inspectorControllerHelperData.inspIsSetStart = true;
						inspectorControllerHelperData.inspIsSetEnd = true;
						ExpressionComponent expressionComponent4 = expression.components[num2];
						expressionComponent4.controlType = ExpressionComponent.ControlType.Bone;
						inspectorControllerHelperData.StoreBoneBase();
						inspectorControllerHelperData.StoreStartTform();
						ApplyCommonSettingsToComponent(expressionComponent4, oneClickComponent, num2);
						num++;
						break;
					}
					case OneClickComponent.ComponentType.Animator:
					{
						OneClickAnimatorComponent oneClickAnimatorComponent = (OneClickAnimatorComponent)oneClickComponent;
						Animator animator = FindAnimator(oneClickAnimatorComponent.componentSearchName);
						if (animator == null)
						{
							UnityEngine.Debug.LogWarning("Could not find Animator: " + oneClickAnimatorComponent.componentSearchName);
							break;
						}
						num2 = CreateNewComponent(num, expression);
						InspectorControllerHelperData inspectorControllerHelperData = expression.controllerVars[num2];
						inspectorControllerHelperData.animator = animator;
						inspectorControllerHelperData.isTriggerParameterBiDirectional = oneClickAnimatorComponent.isTriggerParmBiDirectional;
						inspectorControllerHelperData.blendIndex = oneClickAnimatorComponent.animationParmIndex;
						ExpressionComponent expressionComponent = expression.components[num2];
						expressionComponent.controlType = ExpressionComponent.ControlType.Animator;
						ApplyCommonSettingsToComponent(expressionComponent, oneClickComponent, num2);
						num++;
						break;
					}
					}
				}
				if (num == 0)
				{
					UnityEngine.Debug.Log("Removed expression " + expression.name + " This may be OK, but may indicate a change in the model generator. If this is a supported model, contact Crazy Minnow Studio via assetsupport@crazyminnow.com.");
					switch (configuration.type)
					{
					case OneClickConfiguration.ConfigType.Salsa:
						salsa.visemes.RemoveAt(salsa.visemes.Count - 1);
						break;
					case OneClickConfiguration.ConfigType.Emoter:
						emoter.emotes.RemoveAt(emoter.emotes.Count - 1);
						break;
					}
				}
				if (configuration.type == OneClickConfiguration.ConfigType.Salsa)
				{
					salsa.DistributeTriggers(LerpEasings.EasingType.SquaredIn);
				}
			}
		}

		private static Expression InitializeExpressionType(OneClickConfiguration configuration, int exp)
		{
			switch (configuration.type)
			{
			case OneClickConfiguration.ConfigType.Salsa:
			{
				salsa.visemes.Add(new LipsyncExpression(configuration.oneClickExpressions[exp].name, new InspectorControllerHelperData(), 0f));
				LipsyncExpression lipsyncExpression = salsa.visemes[salsa.visemes.Count - 1];
				lipsyncExpression.expData.inspFoldout = false;
				return lipsyncExpression.expData;
			}
			case OneClickConfiguration.ConfigType.Emoter:
			{
				emoter.emotes.Add(new EmoteExpression(configuration.oneClickExpressions[exp].name, new InspectorControllerHelperData(), isRandomEmote: false, isLipsyncEmphasisEmote: true, isRepeaterEmote: false, 0f));
				EmoteExpression emoteExpression = emoter.emotes[emoter.emotes.Count - 1];
				OneClickEmoterExpression oneClickEmoterExpression = (OneClickEmoterExpression)configuration.oneClickExpressions[exp];
				emoteExpression.expData.inspFoldout = false;
				emoteExpression.isRandomEmote = oneClickEmoterExpression.isRandom;
				emoteExpression.isLipsyncEmphasisEmote = oneClickEmoterExpression.isEmphasis;
				emoteExpression.isAlwaysEmphasisEmote = oneClickEmoterExpression.isAlwaysEmphasis;
				emoteExpression.isRepeaterEmote = oneClickEmoterExpression.isRepeater;
				emoteExpression.frac = oneClickEmoterExpression.expressionDynamics;
				return emoteExpression.expData;
			}
			default:
				return salsa.visemes[salsa.visemes.Count - 1].expData;
			}
		}

		private static int RegexFindBlendshapeName(SkinnedMeshRenderer smr, string bName)
		{
			string[] blendshapeNames = GetBlendshapeNames(smr);
			for (int i = 0; i < blendshapeNames.Length; i++)
			{
				if (Regex.IsMatch(blendshapeNames[i], bName, RegexOptions.IgnoreCase))
				{
					return i;
				}
			}
			return -1;
		}

		private static string[] GetBlendshapeNames(SkinnedMeshRenderer smr)
		{
			string[] array = new string[smr.sharedMesh.blendShapeCount];
			for (int i = 0; i < smr.sharedMesh.blendShapeCount; i++)
			{
				array[i] = smr.sharedMesh.GetBlendShapeName(i);
			}
			return array;
		}

		private static TformBase ConvertBoneToTform(Transform bone)
		{
			return new TformBase(new Vector3(bone.localPosition.x, bone.localPosition.y, bone.localPosition.x), new Quaternion(bone.localRotation.x, bone.localRotation.y, bone.localRotation.z, bone.localRotation.w), new Vector3(bone.localScale.x, bone.localScale.y, bone.localScale.z));
		}

		private static Transform FindBone(string componentSearchName)
		{
			Transform[] componentsInChildren = selectedObject.GetComponentsInChildren<Transform>();
			foreach (Transform transform in componentsInChildren)
			{
				if (Regex.IsMatch(transform.name, componentSearchName, RegexOptions.IgnoreCase))
				{
					return transform;
				}
			}
			return null;
		}

		private static Animator FindAnimator(string componentSearchName)
		{
			Animator[] componentsInChildren = selectedObject.GetComponentsInChildren<Animator>();
			foreach (Animator animator in componentsInChildren)
			{
				if (Regex.IsMatch(animator.name, componentSearchName, RegexOptions.IgnoreCase))
				{
					return animator;
				}
			}
			return null;
		}

		private static void ApplyCommonSettingsToComponent(ExpressionComponent component, OneClickComponent oneClickComponent, int componentNumber)
		{
			component.durationOn = oneClickComponent.durOn;
			component.durationOff = oneClickComponent.durOff;
			component.durationHold = oneClickComponent.durHold;
			component.easing = easingType;
			component.inspFoldout = false;
			component.name = (string.IsNullOrEmpty(oneClickComponent.componentName) ? ("component " + componentNumber) : oneClickComponent.componentName);
		}

		private static int CreateNewComponent(int componentCount, Expression expression)
		{
			if (componentCount > expression.components.Count - 1)
			{
				expression.components.Add(new ExpressionComponent());
				expression.controllerVars.Add(new InspectorControllerHelperData());
			}
			return expression.components.Count - 1;
		}
	}
	public class OneClickBoxHead : OneClickBase
	{
		public static void Setup(GameObject gameObject, AudioClip clip)
		{
			OneClickBase.Init();
			OneClickBase.NewConfiguration(OneClickConfiguration.ConfigType.Salsa);
			OneClickBase.AddSmrSearch("^.*$");
			OneClickBase.autoAdjustAnalysis = true;
			OneClickBase.autoAdjustMicrophone = false;
			OneClickBase.loCutoff = 0.015f;
			OneClickBase.hiCutoff = 0.75f;
			OneClickBase.useAdvDyn = true;
			OneClickBase.advDynPrimaryBias = 0.5f;
			OneClickBase.useAdvDynJitter = true;
			OneClickBase.advDynJitterAmount = 0.1f;
			OneClickBase.advDynJitterProb = 0.2f;
			OneClickBase.advDynSecondaryMix = 0f;
			OneClickBase.emphasizerTrigger = 0f;
			OneClickBase.NewExpression("saySmall");
			OneClickBase.AddShapeComponent(new string[1] { "saySml" }, 0.12f, 0f, 0.06f, "saySml");
			OneClickBase.NewExpression("sayMedium");
			OneClickBase.AddShapeComponent(new string[1] { "sayMed" }, 0.12f, 0f, 0.06f, "sayMed");
			OneClickBase.NewExpression("sayLarge");
			OneClickBase.AddShapeComponent(new string[1] { "sayLrg" }, 0.12f, 0f, 0.06f, "sayLrg");
			OneClickBase.NewConfiguration(OneClickConfiguration.ConfigType.Emoter);
			OneClickBase.AddSmrSearch("^.*$");
			OneClickBase.useRandomEmotes = false;
			OneClickBase.isChancePerEmote = true;
			OneClickBase.numRandomEmotesPerCycle = 0;
			OneClickBase.randomEmoteMinTimer = 1f;
			OneClickBase.randomEmoteMaxTimer = 2f;
			OneClickBase.randomChance = 0.5f;
			OneClickBase.useRandomFrac = false;
			OneClickBase.randomFracBias = 0.5f;
			OneClickBase.useRandomHoldDuration = false;
			OneClickBase.randomHoldDurationMin = 0.1f;
			OneClickBase.randomHoldDurationMax = 0.5f;
			OneClickBase.NewExpression("furrow");
			OneClickBase.AddEmoteFlags(isRandom: false, isEmph: true, isRepeater: false);
			OneClickBase.AddShapeComponent(new string[1] { "furrowedBrow" }, 0.3f, 0.1f, 0.2f, "furrowedBrow");
			OneClickBase.NewExpression("brows up");
			OneClickBase.AddEmoteFlags(isRandom: false, isEmph: false, isRepeater: false);
			OneClickBase.AddShapeComponent(new string[1] { "browsUpLeft" }, 0.3f, 0.1f, 0.2f, "browsUpLeft");
			OneClickBase.AddShapeComponent(new string[1] { "browsUpRight" }, 0.3f, 0.1f, 0.2f, "browsUpRight");
			OneClickBase.NewExpression("brow up R");
			OneClickBase.AddEmoteFlags(isRandom: false, isEmph: true, isRepeater: false, 0.37f);
			OneClickBase.AddShapeComponent(new string[1] { "browsUpRight" }, 0.3f, 0.1f, 0.2f, "browsUpRight");
			OneClickBase.NewExpression("brow up L");
			OneClickBase.AddEmoteFlags(isRandom: false, isEmph: true, isRepeater: false, 0.37f);
			OneClickBase.AddShapeComponent(new string[1] { "browsUpLeft" }, 0.3f, 0.1f, 0.2f, "browsUpLeft");
			OneClickBase.NewExpression("eyes wide");
			OneClickBase.AddEmoteFlags(isRandom: false, isEmph: true, isRepeater: false);
			OneClickBase.AddShapeComponent(new string[1] { "eyesWide" }, 0.3f, 0.1f, 0.2f, "eyesWide");
			OneClickBase.DoOneClickiness(gameObject, clip);
		}
	}
	public class OneClickBoxHeadEyes : MonoBehaviour
	{
		public static void Setup(GameObject go)
		{
			string regexSearch = "boxHead.v2";
			if ((bool)go)
			{
				Eyes component = go.GetComponent<Eyes>();
				if (component == null)
				{
					component = go.AddComponent<Eyes>();
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(component);
					component = go.AddComponent<Eyes>();
				}
				QueueProcessor queueProcessor = go.GetComponent<QueueProcessor>();
				if (queueProcessor == null)
				{
					queueProcessor = go.AddComponent<QueueProcessor>();
				}
				component.characterRoot = go.transform;
				component.queueProcessor = queueProcessor;
				component.BuildHeadTemplate(Eyes.HeadTemplates.Bone_Rotation_XY);
				component.heads[0].expData.controllerVars[0].bone = Eyes.FindTransform(component.characterRoot, regexSearch);
				component.heads[0].expData.name = "head";
				component.heads[0].expData.components[0].name = "head";
				if (go.name.Contains("small"))
				{
					component.headTargetOffset.y = 0.225f;
				}
				else
				{
					component.headTargetOffset.y = 1.4f;
					component.headRandDistRange = new Vector2(3f, 3f);
					component.headTargetRadius = 0.05f;
				}
				component.CaptureMin(ref component.heads);
				component.CaptureMax(ref component.heads);
				SkinnedMeshRenderer component2 = Eyes.FindTransform(component.characterRoot, regexSearch).GetComponent<SkinnedMeshRenderer>();
				component.BuildEyeTemplate(Eyes.EyeTemplates.BlendShapes);
				component.RemoveExpression(ref component.eyes, 1);
				component.eyes[0].expData.controllerVars[0].smr = component2;
				component.eyes[0].expData.controllerVars[0].blendIndex = 4;
				component.eyes[0].expData.controllerVars[1].smr = component2;
				component.eyes[0].expData.controllerVars[1].blendIndex = 7;
				component.eyes[0].expData.controllerVars[2].smr = component2;
				component.eyes[0].expData.controllerVars[2].blendIndex = 5;
				component.eyes[0].expData.controllerVars[3].smr = component2;
				component.eyes[0].expData.controllerVars[3].blendIndex = 6;
				if (go.GetComponentInChildren<EyeGizmo>() != null)
				{
					UnityEngine.Object.DestroyImmediate(go.GetComponentInChildren<EyeGizmo>().gameObject);
				}
				component.eyes[0].gizmo = component.CreateEyeGizmo(component2.name, component.characterRoot);
				component.eyes[0].gizmo.transform.parent = component2.transform;
				if (go.name.Contains("small"))
				{
					component.eyes[0].gizmo.transform.localPosition = new Vector3(0f, 0.2239f, 0.1624f);
				}
				else
				{
					component.eyes[0].gizmo.transform.localPosition = new Vector3(0f, 1.378f, 1.037f);
					component.eyeRandTrackFov = new Vector3(0.4f, 0.2f, 0f);
					component.eyeRandDistRange = new Vector2(3f, 3f);
					component.eyeTargetRadius = 0.05f;
				}
				component.BuildEyelidTemplate(Eyes.EyelidTemplates.BlendShapes, Eyes.EyelidSelection.Upper);
				component.RemoveExpression(ref component.blinklids, 1);
				component.blinklids[0].expData.controllerVars[0].smr = component2;
				component.blinklids[0].expData.controllerVars[0].blendIndex = 8;
				if (go.transform.parent == null)
				{
					component.characterRoot = component.AddParent(go.transform);
				}
				else
				{
					component.characterRoot = go.transform.parent;
				}
				component.Initialize();
			}
		}
	}
	public class OneClickComponent
	{
		public enum ComponentType
		{
			Shape,
			UMA,
			Bone,
			Animator
		}

		public ComponentType type;

		public string componentName;

		public float durOn;

		public float durHold;

		public float durOff;
	}
	public class OneClickShapeComponent : OneClickComponent
	{
		public string[] blendshapeNames;

		public float maxAmount;

		public bool useRegex;

		public OneClickShapeComponent(string componentName, string[] blendshapeNames, float maxAmount, float durOn, float durHold, float durOff, ComponentType type, bool useRegex)
		{
			base.componentName = componentName;
			this.blendshapeNames = blendshapeNames;
			this.maxAmount = maxAmount;
			base.durOn = durOn;
			base.durHold = durHold;
			base.durOff = durOff;
			base.type = type;
			this.useRegex = useRegex;
		}
	}
	public class OneClickBoneComponent : OneClickComponent
	{
		public string componentSearchName;

		public TformBase max;

		public bool usePos;

		public bool useRot;

		public bool useScl;

		public OneClickBoneComponent(string componentName, string boneSearchName, TformBase max, bool usePos, bool useRot, bool useScl, float durOn, float durHold, float durOff, ComponentType type)
		{
			componentSearchName = boneSearchName;
			base.componentName = componentName;
			this.max = max;
			this.usePos = usePos;
			this.useRot = useRot;
			this.useScl = useScl;
			base.durOn = durOn;
			base.durHold = durHold;
			base.durOff = durOff;
			base.type = type;
		}
	}
	public class OneClickUepComponent : OneClickComponent
	{
		public string poseName;

		public float maxAmount;

		public OneClickUepComponent(string componentName, string poseName, float maxAmount, float durOn, float durHold, float durOff, ComponentType type)
		{
			base.componentName = componentName;
			this.poseName = poseName;
			this.maxAmount = maxAmount;
			base.durOn = durOn;
			base.durHold = durHold;
			base.durOff = durOff;
			base.type = type;
		}
	}
	public class OneClickAnimatorComponent : OneClickComponent
	{
		public string componentSearchName;

		public int animationParmIndex;

		public bool isTriggerParmBiDirectional;

		public OneClickAnimatorComponent(string componentName, string animatorSearchName, int animationParmIndex, bool isTriggerParmBiDirectional, float durOn, float durHold, float durOff, ComponentType type)
		{
			base.componentName = componentName;
			componentSearchName = animatorSearchName;
			this.animationParmIndex = animationParmIndex;
			this.isTriggerParmBiDirectional = isTriggerParmBiDirectional;
			base.durOn = durOn;
			base.durHold = durHold;
			base.durOff = durOff;
			base.type = type;
		}
	}
	public class OneClickConfiguration
	{
		public enum ConfigType
		{
			Salsa,
			Emoter
		}

		public ConfigType type;

		public List<string> smrSearches = new List<string>();

		public List<OneClickExpression> oneClickExpressions = new List<OneClickExpression>();

		public OneClickConfiguration(ConfigType type)
		{
			this.type = type;
			smrSearches.Clear();
			oneClickExpressions.Clear();
		}
	}
	public class OneClickExpression
	{
		public string name;

		public List<OneClickComponent> components;

		public OneClickExpression()
		{
		}

		public OneClickExpression(string name, List<OneClickComponent> components)
		{
			this.name = name;
			this.components = components;
		}
	}
	public class OneClickEmoterExpression : OneClickExpression
	{
		public bool isRandom;

		public bool isEmphasis;

		public bool isAlwaysEmphasis;

		public bool isRepeater;

		public float expressionDynamics = 1f;

		public OneClickEmoterExpression(string name, List<OneClickComponent> components)
		{
			base.name = name;
			base.components = components;
		}

		public void SetEmoterBools(bool isRand, bool isEmph, bool isRep, float frac, bool isAlwaysEmph = false)
		{
			isRandom = isRand;
			isEmphasis = isEmph;
			isAlwaysEmphasis = isAlwaysEmph;
			isRepeater = isRep;
			expressionDynamics = frac;
		}
	}
}
