using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Common;
using DG.Tweening;
using DG.Tweening.Core;
using DG.Tweening.Core.Enums;
using DG.Tweening.Plugins.Core.PathCore;
using DG.Tweening.Plugins.Options;
using DearVR;
using Kaine;
using Oculus.Platform;
using StackableDecorator;
using TMPro;
using UTJ;
using UTJ.GameObjectExtensions;
using UTJ.StringQueueExtensions;
using UniRx;
using UniRx.Triggers;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Analytics;
using UnityEngine.EventSystems;
using UnityEngine.Events;
using UnityEngine.Playables;
using UnityEngine.Profiling;
using UnityEngine.SceneManagement;
using UnityEngine.Timeline;
using UnityEngine.UI;
using UnityEngine.Video;
using UnityEngine.XR;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyVersion("0.0.0.0")]
[AttributeUsage(AttributeTargets.Field)]
public class EnumLabelAttribute : PropertyAttribute
{
	public string[] EnumNames { get; private set; }

	public EnumLabelAttribute(Type enumType)
	{
		EnumNames = Enum.GetNames(enumType);
	}
}
public class NotEditableAttribute : PropertyAttribute
{
}
public class PrefabFieldAttribute : PropertyAttribute
{
}
public static class Matrix4x4Extension
{
	public static Vector3 MultiplyPoint3x4(this Matrix4x4 self, ref Vector3 point)
	{
		Vector3 result = default(Vector3);
		result.x = self.m00 * point.x + self.m01 * point.y + self.m02 * point.z + self.m03;
		result.y = self.m10 * point.x + self.m11 * point.y + self.m12 * point.z + self.m13;
		result.z = self.m20 * point.x + self.m21 * point.y + self.m22 * point.z + self.m23;
		return result;
	}

	public static Vector3 MultiplyVector(this Matrix4x4 self, ref Vector3 vector)
	{
		Vector3 result = default(Vector3);
		result.x = self.m00 * vector.x + self.m01 * vector.y + self.m02 * vector.z;
		result.y = self.m10 * vector.x + self.m11 * vector.y + self.m12 * vector.z;
		result.z = self.m20 * vector.x + self.m21 * vector.y + self.m22 * vector.z;
		return result;
	}
}
public static class PlayableDirectorExt
{
	public static IObservable<PlayableDirector> PlayedAsObservable(this PlayableDirector src)
	{
		return Observable.FromEvent(delegate(Action<PlayableDirector> h)
		{
			src.played += h;
		}, delegate(Action<PlayableDirector> h)
		{
			src.played -= h;
		});
	}

	public static IObservable<PlayableDirector> PausedAsObservable(this PlayableDirector src)
	{
		return Observable.FromEvent(delegate(Action<PlayableDirector> h)
		{
			src.paused += h;
		}, delegate(Action<PlayableDirector> h)
		{
			src.paused -= h;
		});
	}

	public static IObservable<PlayableDirector> StoppedAsObservable(this PlayableDirector src)
	{
		return Observable.FromEvent(delegate(Action<PlayableDirector> h)
		{
			src.stopped += h;
		}, delegate(Action<PlayableDirector> h)
		{
			src.stopped -= h;
		});
	}

	public static IObservable<PlayableDirector> PlayAsStream(this PlayableDirector src)
	{
		return Observable.Create(delegate(IObserver<PlayableDirector> observer)
		{
			if (src.state == PlayState.Playing)
			{
				src.Stop();
			}
			src.Play();
			IDisposable disposable = src.StoppedAsObservable().Subscribe(delegate(PlayableDirector x)
			{
				observer.OnNext(x);
				observer.OnCompleted();
			});
			return Disposable.Create(delegate
			{
				disposable.Dispose();
				if (src.state == PlayState.Playing)
				{
					src.Stop();
				}
			});
		});
	}
}
public class DropdownSortingLayer : MonoBehaviour
{
	[SerializeField]
	private bool _overrideSort;

	[SerializeField]
	private string _sortingLayerName = "Front";

	[SerializeField]
	private bool _sortBlocker;

	private void Awake()
	{
		Canvas component = GetComponent<Canvas>();
		if (component != null)
		{
			component.overrideSorting = _overrideSort;
			component.sortingLayerName = _sortingLayerName;
		}
	}

	private void Start()
	{
		GameObject gameObject = GameObject.Find("Blocker");
		if (!(gameObject != null))
		{
			return;
		}
		Canvas component = gameObject.GetComponent<Canvas>();
		if (component != null)
		{
			if (_sortBlocker)
			{
				component.sortingLayerName = _sortingLayerName;
			}
			else
			{
				component.sortingLayerName = "Default";
			}
		}
	}
}
[Serializable]
public class LightControlBehaviour : PlayableBehaviour
{
	public Color color = Color.white;

	public float intensity = 1f;

	public float bounceIntensity = 1f;

	public float range = 10f;
}
[Serializable]
public class LightControlClip : PlayableAsset, ITimelineClipAsset
{
	public LightControlBehaviour template = new LightControlBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<LightControlBehaviour>.Create(graph, template);
	}
}
public class LightControlMixerBehaviour : PlayableBehaviour
{
	private Color m_DefaultColor;

	private float m_DefaultIntensity;

	private float m_DefaultBounceIntensity;

	private float m_DefaultRange;

	private Light m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Light;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_DefaultIntensity = m_TrackBinding.intensity;
			m_DefaultBounceIntensity = m_TrackBinding.bounceIntensity;
			m_DefaultRange = m_TrackBinding.range;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		Color clear = Color.clear;
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 0f;
		float num5 = 0f;
		int num6 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			LightControlBehaviour behaviour = ((ScriptPlayable<LightControlBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += behaviour.intensity * inputWeight;
			num2 += behaviour.bounceIntensity * inputWeight;
			num3 += behaviour.range * inputWeight;
			num4 += inputWeight;
			if (inputWeight > num5)
			{
				num5 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num6++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num4);
		m_TrackBinding.intensity = num + m_DefaultIntensity * (1f - num4);
		m_TrackBinding.bounceIntensity = num2 + m_DefaultBounceIntensity * (1f - num4);
		m_TrackBinding.range = num3 + m_DefaultRange * (1f - num4);
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
		if (!(m_TrackBinding == null))
		{
			m_TrackBinding.color = m_DefaultColor;
			m_TrackBinding.intensity = m_DefaultIntensity;
			m_TrackBinding.bounceIntensity = m_DefaultBounceIntensity;
			m_TrackBinding.range = m_DefaultRange;
		}
	}
}
[TrackColor(0.9454092f, 0.9779412f, 0.3883002f)]
[TrackClipType(typeof(LightControlClip))]
[TrackBindingType(typeof(Light))]
public class LightControlTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<LightControlMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class NavMeshAgentControlBehaviour : PlayableBehaviour
{
	public Transform destination;

	public bool destinationSet;

	public override void OnPlayableCreate(Playable playable)
	{
		destinationSet = false;
	}
}
[Serializable]
public class NavMeshAgentControlClip : PlayableAsset, ITimelineClipAsset
{
	public ExposedReference<Transform> destination;

	[HideInInspector]
	public NavMeshAgentControlBehaviour template = new NavMeshAgentControlBehaviour();

	public ClipCaps clipCaps => ClipCaps.None;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		ScriptPlayable<NavMeshAgentControlBehaviour> scriptPlayable = ScriptPlayable<NavMeshAgentControlBehaviour>.Create(graph, template);
		scriptPlayable.GetBehaviour().destination = destination.Resolve(graph.GetResolver());
		return scriptPlayable;
	}
}
public class NavMeshAgentControlMixerBehaviour : PlayableBehaviour
{
	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		NavMeshAgent navMeshAgent = playerData as NavMeshAgent;
		if (!navMeshAgent)
		{
			return;
		}
		int inputCount = playable.GetInputCount();
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			NavMeshAgentControlBehaviour behaviour = ((ScriptPlayable<NavMeshAgentControlBehaviour>)playable.GetInput(i)).GetBehaviour();
			if (inputWeight > 0.5f && !behaviour.destinationSet && (bool)behaviour.destination && navMeshAgent.isOnNavMesh)
			{
				navMeshAgent.SetDestination(behaviour.destination.position);
				behaviour.destinationSet = true;
			}
		}
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(NavMeshAgentControlClip))]
[TrackBindingType(typeof(NavMeshAgent))]
public class NavMeshAgentControlTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<NavMeshAgentControlMixerBehaviour>.Create(graph, inputCount);
	}
}
[Serializable]
public class ScreenFaderBehaviour : PlayableBehaviour
{
	public Color color = Color.black;
}
[Serializable]
public class ScreenFaderClip : PlayableAsset, ITimelineClipAsset
{
	public ScreenFaderBehaviour template = new ScreenFaderBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<ScreenFaderBehaviour>.Create(graph, template);
	}
}
public class ScreenFaderMixerBehaviour : PlayableBehaviour
{
	private Color m_DefaultColor;

	private Image m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Image;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		Color clear = Color.clear;
		float num = 0f;
		float num2 = 0f;
		int num3 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScreenFaderBehaviour behaviour = ((ScriptPlayable<ScreenFaderBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += inputWeight;
			if (inputWeight > num2)
			{
				num2 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num3++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num);
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
		if (!(m_TrackBinding == null))
		{
			m_TrackBinding.color = m_DefaultColor;
		}
	}
}
[TrackColor(0.875f, 0.5944853f, 0.1737132f)]
[TrackClipType(typeof(ScreenFaderClip))]
[TrackBindingType(typeof(Image))]
public class ScreenFaderTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<ScreenFaderMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class TextSwitcherBehaviour : PlayableBehaviour
{
	public Color color = Color.white;

	public int fontSize = 14;

	public string text;
}
[Serializable]
public class TextSwitcherClip : PlayableAsset, ITimelineClipAsset
{
	public TextSwitcherBehaviour template = new TextSwitcherBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<TextSwitcherBehaviour>.Create(graph, template);
	}
}
public class TextSwitcherMixerBehaviour : PlayableBehaviour
{
	private Color m_DefaultColor;

	private int m_DefaultFontSize;

	private string m_DefaultText;

	private Text m_TrackBinding;

	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as Text;
		if (m_TrackBinding == null)
		{
			return;
		}
		if (!m_FirstFrameHappened)
		{
			m_DefaultColor = m_TrackBinding.color;
			m_DefaultFontSize = m_TrackBinding.fontSize;
			m_DefaultText = m_TrackBinding.text;
			m_FirstFrameHappened = true;
		}
		int inputCount = playable.GetInputCount();
		Color clear = Color.clear;
		float num = 0f;
		float num2 = 0f;
		float num3 = 0f;
		int num4 = 0;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			TextSwitcherBehaviour behaviour = ((ScriptPlayable<TextSwitcherBehaviour>)playable.GetInput(i)).GetBehaviour();
			clear += behaviour.color * inputWeight;
			num += (float)behaviour.fontSize * inputWeight;
			num2 += inputWeight;
			if (inputWeight > num3)
			{
				m_TrackBinding.text = behaviour.text;
				num3 = inputWeight;
			}
			if (!Mathf.Approximately(inputWeight, 0f))
			{
				num4++;
			}
		}
		m_TrackBinding.color = clear + m_DefaultColor * (1f - num2);
		m_TrackBinding.fontSize = Mathf.RoundToInt(num + (float)m_DefaultFontSize * (1f - num2));
		if (num4 != 1 && 1f - num2 > num3)
		{
			m_TrackBinding.text = m_DefaultText;
		}
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
		if (!(m_TrackBinding == null))
		{
			m_TrackBinding.color = m_DefaultColor;
			m_TrackBinding.fontSize = m_DefaultFontSize;
			m_TrackBinding.text = m_DefaultText;
		}
	}
}
[TrackColor(0.1394896f, 0.4411765f, 0.3413077f)]
[TrackClipType(typeof(TextSwitcherClip))]
[TrackBindingType(typeof(Text))]
public class TextSwitcherTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TextSwitcherMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class TimeDilationBehaviour : PlayableBehaviour
{
	public float timeScale = 1f;
}
[Serializable]
public class TimeDilationClip : PlayableAsset, ITimelineClipAsset
{
	public TimeDilationBehaviour template = new TimeDilationBehaviour();

	public ClipCaps clipCaps => ClipCaps.Extrapolation | ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<TimeDilationBehaviour>.Create(graph, template);
	}
}
public class TimeDilationMixerBehaviour : PlayableBehaviour
{
	private float m_OldTimeScale = 1f;

	public override void OnPlayableCreate(Playable playable)
	{
		m_OldTimeScale = Time.timeScale;
	}

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			num2 += inputWeight;
			TimeDilationBehaviour behaviour = ((ScriptPlayable<TimeDilationBehaviour>)playable.GetInput(i)).GetBehaviour();
			num += inputWeight * behaviour.timeScale;
		}
		Time.timeScale = num + m_OldTimeScale * (1f - num2);
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		Time.timeScale = m_OldTimeScale;
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(TimeDilationClip))]
public class TimeDilationTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TimeDilationMixerBehaviour>.Create(graph, inputCount);
	}
}
[Serializable]
public class TransformTweenBehaviour : PlayableBehaviour
{
	public enum TweenType
	{
		Linear,
		Deceleration,
		Harmonic,
		Custom
	}

	public Transform startLocation;

	public Transform endLocation;

	public bool tweenPosition = true;

	public bool tweenRotation = true;

	public TweenType tweenType;

	public AnimationCurve customCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public Vector3 startingPosition;

	public Quaternion startingRotation = Quaternion.identity;

	private AnimationCurve m_LinearCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	private AnimationCurve m_DecelerationCurve = new AnimationCurve(new Keyframe(0f, 0f, -(float)Math.PI / 2f, (float)Math.PI / 2f), new Keyframe(1f, 1f, 0f, 0f));

	private AnimationCurve m_HarmonicCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	private const float k_RightAngleInRads = (float)Math.PI / 2f;

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		if ((bool)startLocation)
		{
			startingPosition = startLocation.position;
			startingRotation = startLocation.rotation;
		}
	}

	public float EvaluateCurrentCurve(float time)
	{
		if (tweenType == TweenType.Custom && !IsCustomCurveNormalised())
		{
			UnityEngine.Debug.LogError("Custom Curve is not normalised.  Curve must start at 0,0 and end at 1,1.");
			return 0f;
		}
		return tweenType switch
		{
			TweenType.Linear => m_LinearCurve.Evaluate(time), 
			TweenType.Deceleration => m_DecelerationCurve.Evaluate(time), 
			TweenType.Harmonic => m_HarmonicCurve.Evaluate(time), 
			_ => customCurve.Evaluate(time), 
		};
	}

	private bool IsCustomCurveNormalised()
	{
		if (!Mathf.Approximately(customCurve[0].time, 0f))
		{
			return false;
		}
		if (!Mathf.Approximately(customCurve[0].value, 0f))
		{
			return false;
		}
		if (!Mathf.Approximately(customCurve[customCurve.length - 1].time, 1f))
		{
			return false;
		}
		return Mathf.Approximately(customCurve[customCurve.length - 1].value, 1f);
	}
}
[Serializable]
public class TransformTweenClip : PlayableAsset, ITimelineClipAsset
{
	public TransformTweenBehaviour template = new TransformTweenBehaviour();

	public ExposedReference<Transform> startLocation;

	public ExposedReference<Transform> endLocation;

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		ScriptPlayable<TransformTweenBehaviour> scriptPlayable = ScriptPlayable<TransformTweenBehaviour>.Create(graph, template);
		TransformTweenBehaviour behaviour = scriptPlayable.GetBehaviour();
		behaviour.startLocation = startLocation.Resolve(graph.GetResolver());
		behaviour.endLocation = endLocation.Resolve(graph.GetResolver());
		return scriptPlayable;
	}
}
public class TransformTweenMixerBehaviour : PlayableBehaviour
{
	private bool m_FirstFrameHappened;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		Transform transform = playerData as Transform;
		if (transform == null)
		{
			return;
		}
		Vector3 position = transform.position;
		Quaternion rotation = transform.rotation;
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		Vector3 zero = Vector3.zero;
		Quaternion quaternion = new Quaternion(0f, 0f, 0f, 0f);
		for (int i = 0; i < inputCount; i++)
		{
			ScriptPlayable<TransformTweenBehaviour> playable2 = (ScriptPlayable<TransformTweenBehaviour>)playable.GetInput(i);
			TransformTweenBehaviour behaviour = playable2.GetBehaviour();
			if (behaviour.endLocation == null)
			{
				continue;
			}
			float inputWeight = playable.GetInputWeight(i);
			if (!m_FirstFrameHappened && !behaviour.startLocation)
			{
				behaviour.startingPosition = position;
				behaviour.startingRotation = rotation;
			}
			float time = (float)(playable2.GetTime() / playable2.GetDuration());
			float t = behaviour.EvaluateCurrentCurve(time);
			if (behaviour.tweenPosition)
			{
				num += inputWeight;
				zero += Vector3.Lerp(behaviour.startingPosition, behaviour.endLocation.position, t) * inputWeight;
			}
			if (behaviour.tweenRotation)
			{
				num2 += inputWeight;
				Quaternion rotation2 = Quaternion.Lerp(behaviour.startingRotation, behaviour.endLocation.rotation, t);
				rotation2 = NormalizeQuaternion(rotation2);
				if (Quaternion.Dot(quaternion, rotation2) < 0f)
				{
					rotation2 = ScaleQuaternion(rotation2, -1f);
				}
				rotation2 = ScaleQuaternion(rotation2, inputWeight);
				quaternion = AddQuaternions(quaternion, rotation2);
			}
		}
		zero += position * (1f - num);
		Quaternion second = ScaleQuaternion(rotation, 1f - num2);
		quaternion = AddQuaternions(quaternion, second);
		transform.position = zero;
		transform.rotation = quaternion;
		m_FirstFrameHappened = true;
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		m_FirstFrameHappened = false;
	}

	private static Quaternion AddQuaternions(Quaternion first, Quaternion second)
	{
		first.w += second.w;
		first.x += second.x;
		first.y += second.y;
		first.z += second.z;
		return first;
	}

	private static Quaternion ScaleQuaternion(Quaternion rotation, float multiplier)
	{
		rotation.w *= multiplier;
		rotation.x *= multiplier;
		rotation.y *= multiplier;
		rotation.z *= multiplier;
		return rotation;
	}

	private static float QuaternionMagnitude(Quaternion rotation)
	{
		return Mathf.Sqrt(Quaternion.Dot(rotation, rotation));
	}

	private static Quaternion NormalizeQuaternion(Quaternion rotation)
	{
		float num = QuaternionMagnitude(rotation);
		if (num > 0f)
		{
			return ScaleQuaternion(rotation, 1f / num);
		}
		UnityEngine.Debug.LogWarning("Cannot normalize a quaternion with zero magnitude.");
		return Quaternion.identity;
	}
}
[TrackColor(0.855f, 0.8623f, 0.87f)]
[TrackClipType(typeof(TransformTweenClip))]
[TrackBindingType(typeof(Transform))]
public class TransformTweenTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<TransformTweenMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
public class LaserController : MonoBehaviour
{
	public enum HandType
	{
		Left,
		Right
	}

	public delegate bool DelegeteGetInput();

	public delegate Vector2 DelegeteGetScrollDelta();

	public delegate void DelegeteVibrate(float length, float power);

	[Header("Hand")]
	[SerializeField]
	private HandType m_handType;

	[Header("Components")]
	[SerializeField]
	private GameObject cursorModel;

	[SerializeField]
	private LineRenderer laserRenderer;

	[Header("Parameters")]
	[SerializeField]
	private float laserCutLength;

	[SerializeField]
	private float laserMaxLength = 100f;

	[SerializeField]
	private float scaleStartDistance = 1f;

	[SerializeField]
	private float scalePerMeter = 0.5f;

	private bool _isLaserPointed = true;

	private bool _isVisibleLaser = true;

	private bool _isAutoDisappear = true;

	private bool _isPointered;

	private float _lineDefaultWidth = 1f;

	private float _currentLength;

	private Vector3 _pointerDefaultScale;

	public DelegeteGetInput InputTriggerDown { get; set; }

	public DelegeteGetInput InputTriggerUp { get; set; }

	public DelegeteGetScrollDelta InputScrollDelta { get; set; }

	public DelegeteVibrate InputVibrate { get; set; }

	private bool FlagVisibleLaser
	{
		get
		{
			if ((_isLaserPointed || !_isAutoDisappear) && _isVisibleLaser)
			{
				return base.enabled;
			}
			return false;
		}
	}

	public bool IsVisibleLaser
	{
		get
		{
			return _isVisibleLaser;
		}
		set
		{
			_isVisibleLaser = value;
			UpdateLaserVisible();
		}
	}

	public bool IsAutoDisappear
	{
		get
		{
			return _isAutoDisappear;
		}
		set
		{
			_isAutoDisappear = value;
		}
	}

	public float CurrentLength => _currentLength;

	public static LaserInputModule module => LaserInputModule.module;

	private void Awake()
	{
		_lineDefaultWidth = laserRenderer.endWidth;
		_pointerDefaultScale = cursorModel.transform.localScale;
	}

	private void Start()
	{
		CreateLaserPointer();
	}

	private void OnDisable()
	{
		AdjustLaserDistance(0f);
	}

	private void OnDestroy()
	{
		module.RemoveLaser(this);
	}

	protected void CreateLaserPointer()
	{
		module.AddLaser(this);
		AdjustLaserDistance(0f);
	}

	public void AdjustLaserDistance(float distance)
	{
		if (!(laserRenderer == null))
		{
			_isLaserPointed = distance > 0f;
			if (distance <= 0f || distance > laserMaxLength)
			{
				distance = laserMaxLength;
				_isPointered = false;
			}
			else
			{
				_isPointered = true;
			}
			UpdateLaserVisible();
			distance -= 0.01f;
			Vector3 position = new Vector3(0f, 0f, distance);
			float distanceScale = GetDistanceScale(distance);
			laserRenderer.SetPosition(1, position);
			laserRenderer.endWidth = distanceScale * _lineDefaultWidth;
			if (laserCutLength > 0f)
			{
				float num = Mathf.Max(laserCutLength, 0f);
				Vector3 position2 = new Vector3(0f, 0f, num);
				laserRenderer.SetPosition(0, position2);
				laserRenderer.startWidth = GetDistanceScale(num) * _lineDefaultWidth;
			}
			cursorModel.transform.localPosition = new Vector3(0f, 0f, distance);
			cursorModel.transform.localScale = _pointerDefaultScale * distanceScale;
			_currentLength = distance;
		}
	}

	private void UpdateLaserVisible()
	{
		bool flagVisibleLaser = FlagVisibleLaser;
		laserRenderer.enabled = flagVisibleLaser;
		cursorModel.SetActive(flagVisibleLaser && _isPointered);
	}

	private float GetDistanceScale(float distance)
	{
		if (distance < scaleStartDistance)
		{
			return 1f;
		}
		return 1f + (distance - scaleStartDistance) * scalePerMeter;
	}

	public bool GetTriggerDown()
	{
		return InputTriggerDown();
	}

	public bool GetTriggerUp()
	{
		return InputTriggerUp();
	}

	public Vector2 GetScrollDelta()
	{
		return Vector2.zero;
	}

	public void Vibrate(float length, float power)
	{
		InputVibrate(length, power);
	}

	public HandType GetHandType()
	{
		return m_handType;
	}
}
public class LaserInputModule : BaseInputModule
{
	public const int LAZER_MAX = 4;

	[SerializeField]
	private float _dragThreshould = 0.2f;

	public static LaserInputModule module;

	private Camera UICamera;

	private List<LaserController> lasers;

	private LaserPointerEventData[] pointEvents;

	public static Camera moduleCamera
	{
		get
		{
			if (module == null)
			{
				return null;
			}
			return module.UICamera;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		module = this;
		lasers = new List<LaserController>();
		pointEvents = new LaserPointerEventData[4];
		MakeUICamera();
	}

	protected override void Start()
	{
		base.Start();
	}

	private void MakeUICamera()
	{
		GameObject gameObject = new GameObject("UICamera");
		UICamera = gameObject.AddComponent<Camera>();
		UICamera.transform.SetParent(base.transform);
		UICamera.nearClipPlane = 0.01f;
		UICamera.stereoTargetEye = StereoTargetEyeMask.None;
		UICamera.clearFlags = CameraClearFlags.Nothing;
		UICamera.allowDynamicResolution = false;
		UICamera.allowHDR = false;
		UICamera.allowMSAA = false;
		UICamera.enabled = false;
		gameObject.AddComponent<PhysicsRaycaster>();
	}

	public void SetUICameraMask(int mask)
	{
		UICamera.cullingMask = mask;
	}

	public void AddLaser(LaserController l)
	{
		lasers.Add(l);
	}

	public void RemoveLaser(LaserController l)
	{
		lasers.Remove(l);
	}

	private bool GUIRaycast(int index)
	{
		Vector3 vector;
		if (pointEvents[index] == null)
		{
			vector = Vector3.zero;
			pointEvents[index] = new LaserPointerEventData(base.eventSystem);
		}
		else
		{
			vector = pointEvents[index].dim3Position;
			pointEvents[index].Reset();
		}
		if (!lasers[index].enabled)
		{
			if (pointEvents[index].pointerCurrentRaycast.gameObject != null)
			{
				pointEvents[index].pointerCurrentRaycast = default(RaycastResult);
			}
			return false;
		}
		pointEvents[index].pointerId = index;
		pointEvents[index].laserController = lasers[index];
		UICamera.transform.position = lasers[index].gameObject.transform.position;
		UICamera.transform.forward = lasers[index].gameObject.transform.forward;
		pointEvents[index].delta = Vector2.zero;
		pointEvents[index].position = new Vector2(Screen.width / 2, Screen.height / 2);
		pointEvents[index].scrollDelta = Vector2.zero;
		base.eventSystem.RaycastAll(pointEvents[index], m_RaycastResultCache);
		pointEvents[index].pointerCurrentRaycast = BaseInputModule.FindFirstRaycast(m_RaycastResultCache);
		m_RaycastResultCache.Clear();
		if (pointEvents[index].pointerCurrentRaycast.gameObject != null)
		{
			pointEvents[index].dim3Position = GetHitPosition(pointEvents[index]);
			pointEvents[index].delta = pointEvents[index].dim3Position - vector;
			return true;
		}
		return false;
	}

	private Vector3 GetHitPosition(PointerEventData pointerEvent)
	{
		Vector3 vector = UICamera.ScreenToWorldPoint(pointerEvent.position) + UICamera.transform.forward * pointerEvent.pointerCurrentRaycast.distance;
		return Quaternion.FromToRotation(pointerEvent.pointerCurrentRaycast.gameObject.transform.forward, Vector3.forward) * vector;
	}

	public override void Process()
	{
		for (int i = 0; i < lasers.Count; i++)
		{
			ClearSelection();
			bool num = GUIRaycast(i);
			HandlePointerExitAndEnter(newEnterTarget: num ? pointEvents[i].pointerCurrentRaycast.gameObject : null, currentPointerData: pointEvents[i]);
			if (!num)
			{
				lasers[i].AdjustLaserDistance(0f);
			}
			else if (pointEvents[i].pointerCurrentRaycast.distance > 0f)
			{
				lasers[i].AdjustLaserDistance(pointEvents[i].pointerCurrentRaycast.distance);
			}
			ProcessPress(i);
			ProcessDrag(i);
			ProcessScroll(i);
		}
	}

	private void ProcessPress(int index)
	{
		LaserPointerEventData laserPointerEventData = pointEvents[index];
		GameObject gameObject = laserPointerEventData.pointerCurrentRaycast.gameObject;
		if (IsPressDown(index))
		{
			laserPointerEventData.pressPosition = laserPointerEventData.position;
			laserPointerEventData.dim3PressPosition = laserPointerEventData.dim3Position;
			laserPointerEventData.pointerPressRaycast = laserPointerEventData.pointerCurrentRaycast;
			laserPointerEventData.pointerPress = null;
			laserPointerEventData.useDragThreshold = true;
			laserPointerEventData.delta = Vector2.zero;
			laserPointerEventData.dragging = false;
			if (gameObject != null)
			{
				laserPointerEventData.eligibleForClick = true;
				GameObject gameObject2 = ExecuteEvents.ExecuteHierarchy(gameObject, laserPointerEventData, ExecuteEvents.pointerDownHandler);
				if (gameObject2 == null)
				{
					gameObject2 = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
				}
				if (gameObject2 != null)
				{
					float unscaledTime = Time.unscaledTime;
					if (gameObject2 == laserPointerEventData.lastPress)
					{
						if (unscaledTime - laserPointerEventData.clickTime < 0.3f)
						{
							laserPointerEventData.clickCount++;
						}
						else
						{
							laserPointerEventData.clickCount = 1;
						}
						laserPointerEventData.clickTime = unscaledTime;
					}
					else
					{
						laserPointerEventData.clickCount = 1;
					}
					laserPointerEventData.pointerPress = gameObject2;
					laserPointerEventData.rawPointerPress = gameObject;
					laserPointerEventData.clickTime = unscaledTime;
					Select(gameObject2);
				}
				laserPointerEventData.pointerDrag = ExecuteEvents.GetEventHandler<IDragHandler>(gameObject);
				if (laserPointerEventData.pointerDrag != null)
				{
					ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.initializePotentialDrag);
				}
			}
		}
		if (IsPressUp(index))
		{
			ExecuteEvents.Execute(laserPointerEventData.pointerPress, laserPointerEventData, ExecuteEvents.pointerUpHandler);
			GameObject eventHandler = ExecuteEvents.GetEventHandler<IPointerClickHandler>(gameObject);
			if (laserPointerEventData.pointerPress == eventHandler && laserPointerEventData.eligibleForClick)
			{
				ExecuteEvents.Execute(laserPointerEventData.pointerPress, laserPointerEventData, ExecuteEvents.pointerClickHandler);
			}
			else if (laserPointerEventData.pointerDrag != null)
			{
				ExecuteEvents.ExecuteHierarchy(gameObject, laserPointerEventData, ExecuteEvents.dropHandler);
			}
			laserPointerEventData.eligibleForClick = false;
			laserPointerEventData.pointerPress = null;
			laserPointerEventData.rawPointerPress = null;
			if (laserPointerEventData.pointerDrag != null && laserPointerEventData.dragging)
			{
				ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.endDragHandler);
			}
			laserPointerEventData.dragging = false;
			laserPointerEventData.pointerDrag = null;
			if (gameObject != laserPointerEventData.pointerEnter)
			{
				HandlePointerExitAndEnter(laserPointerEventData, null);
				HandlePointerExitAndEnter(laserPointerEventData, gameObject);
			}
		}
	}

	private bool IsPressDown(int index)
	{
		return lasers[index].GetTriggerDown();
	}

	private bool IsPressUp(int index)
	{
		return lasers[index].GetTriggerUp();
	}

	private void ProcessDrag(int index)
	{
		LaserPointerEventData laserPointerEventData = pointEvents[index];
		bool flag = laserPointerEventData.IsPointerMoving();
		if (flag && laserPointerEventData.pointerDrag != null && !laserPointerEventData.dragging && ShouldStartDrag(laserPointerEventData.dim3PressPosition, laserPointerEventData.dim3Position, _dragThreshould, laserPointerEventData.useDragThreshold))
		{
			ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.beginDragHandler);
			laserPointerEventData.dragging = true;
		}
		if (laserPointerEventData.dragging && flag && laserPointerEventData.pointerDrag != null)
		{
			if (laserPointerEventData.pointerPress != laserPointerEventData.pointerDrag)
			{
				ExecuteEvents.Execute(laserPointerEventData.pointerPress, laserPointerEventData, ExecuteEvents.pointerUpHandler);
				laserPointerEventData.eligibleForClick = false;
				laserPointerEventData.pointerPress = null;
				laserPointerEventData.rawPointerPress = null;
			}
			ExecuteEvents.Execute(laserPointerEventData.pointerDrag, laserPointerEventData, ExecuteEvents.dragHandler);
		}
	}

	private bool ShouldStartDrag(Vector3 pressPos, Vector3 currentPos, float threshold, bool useDragThreshold)
	{
		if (!useDragThreshold)
		{
			return true;
		}
		return (pressPos - currentPos).sqrMagnitude >= threshold * threshold;
	}

	private void ProcessScroll(int index)
	{
		LaserPointerEventData laserPointerEventData = pointEvents[index];
		if (!Mathf.Approximately((laserPointerEventData.scrollDelta = GetScrollDelta(index)).sqrMagnitude, 0f))
		{
			ExecuteEvents.ExecuteHierarchy(ExecuteEvents.GetEventHandler<IScrollHandler>(laserPointerEventData.pointerCurrentRaycast.gameObject), laserPointerEventData, ExecuteEvents.scrollHandler);
		}
	}

	private Vector2 GetScrollDelta(int index)
	{
		return Vector2.zero;
	}

	private void Vibrate(int index, float length, float power)
	{
		lasers[index].Vibrate(length, power);
	}

	public void ClearSelection()
	{
		if ((bool)base.eventSystem.currentSelectedGameObject)
		{
			base.eventSystem.SetSelectedGameObject(null);
		}
	}

	private void Select(GameObject go)
	{
		ClearSelection();
		if ((bool)ExecuteEvents.GetEventHandler<ISelectHandler>(go))
		{
			base.eventSystem.SetSelectedGameObject(go);
		}
	}
}
public class LaserTargetCanvas : MonoBehaviour
{
	private void Start()
	{
		if (LaserInputModule.moduleCamera == null)
		{
			StartCoroutine(ReserveAddUICamera());
		}
		else
		{
			GetComponent<Canvas>().worldCamera = LaserInputModule.moduleCamera;
		}
	}

	private IEnumerator ReserveAddUICamera()
	{
		yield return new WaitForEndOfFrame();
		while (LaserInputModule.moduleCamera == null)
		{
			yield return new WaitForSeconds(1f);
		}
		GetComponent<Canvas>().worldCamera = LaserInputModule.moduleCamera;
	}
}
public class EnableSwitch : MonoBehaviour
{
	public GameObject[] SwitchTargets;

	public bool SetActive(int target)
	{
		if (target < 0 || target >= SwitchTargets.Length)
		{
			return false;
		}
		for (int i = 0; i < SwitchTargets.Length; i++)
		{
			SwitchTargets[i].SetActive(value: false);
		}
		SwitchTargets[target].SetActive(value: true);
		return true;
	}
}
public class LipSyncDemo_SetCurrentTarget : MonoBehaviour
{
	public EnableSwitch[] SwitchTargets;

	private int targetSet;

	private void Start()
	{
		OVRMessenger.AddListener<OVRTouchpad.TouchEvent>("Touchpad", LocalTouchEventCallback);
		targetSet = 0;
		SwitchTargets[0].SetActive(0);
		SwitchTargets[1].SetActive(0);
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.Alpha1))
		{
			targetSet = 0;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha2))
		{
			targetSet = 1;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha3))
		{
			targetSet = 2;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha4))
		{
			targetSet = 3;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha5))
		{
			targetSet = 4;
			SetCurrentTarget();
		}
		else if (Input.GetKeyDown(KeyCode.Alpha6))
		{
			targetSet = 5;
			SetCurrentTarget();
		}
		if (Input.GetKeyDown(KeyCode.Escape))
		{
			UnityEngine.Application.Quit();
		}
	}

	private void SetCurrentTarget()
	{
		switch (targetSet)
		{
		case 0:
			SwitchTargets[0].SetActive(0);
			SwitchTargets[1].SetActive(0);
			break;
		case 1:
			SwitchTargets[0].SetActive(0);
			SwitchTargets[1].SetActive(1);
			break;
		case 2:
			SwitchTargets[0].SetActive(1);
			SwitchTargets[1].SetActive(2);
			break;
		case 3:
			SwitchTargets[0].SetActive(1);
			SwitchTargets[1].SetActive(3);
			break;
		case 4:
			SwitchTargets[0].SetActive(2);
			SwitchTargets[1].SetActive(4);
			break;
		case 5:
			SwitchTargets[0].SetActive(2);
			SwitchTargets[1].SetActive(5);
			break;
		}
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		case OVRTouchpad.TouchEvent.Left:
			targetSet--;
			if (targetSet < 0)
			{
				targetSet = 3;
			}
			SetCurrentTarget();
			break;
		case OVRTouchpad.TouchEvent.Right:
			targetSet++;
			if (targetSet > 3)
			{
				targetSet = 0;
			}
			SetCurrentTarget();
			break;
		}
	}
}
public class OVRLipSyncDebugConsole : MonoBehaviour
{
	public ArrayList messages = new ArrayList();

	public int maxMessages = 15;

	public Text textMsg;

	private static OVRLipSyncDebugConsole s_Instance;

	private bool clearTimeoutOn;

	private float clearTimeout;

	public static OVRLipSyncDebugConsole instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				if (s_Instance == null)
				{
					GameObject obj = new GameObject();
					obj.AddComponent<OVRLipSyncDebugConsole>();
					obj.name = "OVRLipSyncDebugConsole";
					s_Instance = UnityEngine.Object.FindObjectOfType(typeof(OVRLipSyncDebugConsole)) as OVRLipSyncDebugConsole;
				}
			}
			return s_Instance;
		}
	}

	private void Awake()
	{
		s_Instance = this;
		Init();
	}

	private void Update()
	{
		if (clearTimeoutOn)
		{
			clearTimeout -= Time.deltaTime;
			if (clearTimeout < 0f)
			{
				Clear();
				clearTimeout = 0f;
				clearTimeoutOn = false;
			}
		}
	}

	public void Init()
	{
		if (textMsg == null)
		{
			UnityEngine.Debug.LogWarning("DebugConsole Init WARNING::UI text not set. Will not be able to display anything.");
		}
		Clear();
	}

	public static void Log(string message)
	{
		instance.AddMessage(message, Color.white);
	}

	public static void Log(string message, Color color)
	{
		instance.AddMessage(message, color);
	}

	public static void Clear()
	{
		instance.ClearMessages();
	}

	public static void ClearTimeout(float timeToClear)
	{
		instance.SetClearTimeout(timeToClear);
	}

	public void AddMessage(string message, Color color)
	{
		messages.Add(message);
		if (textMsg != null)
		{
			textMsg.color = color;
		}
		Display();
	}

	public void ClearMessages()
	{
		messages.Clear();
		Display();
	}

	public void SetClearTimeout(float timeout)
	{
		clearTimeout = timeout;
		clearTimeoutOn = true;
	}

	private void Prune()
	{
		if (messages.Count > maxMessages)
		{
			int count = ((messages.Count > 0) ? (messages.Count - maxMessages) : 0);
			messages.RemoveRange(0, count);
		}
	}

	private void Display()
	{
		if (messages.Count > maxMessages)
		{
			Prune();
		}
		if (textMsg != null)
		{
			textMsg.text = "";
			for (int i = 0; i < messages.Count; i++)
			{
				textMsg.text += (string)messages[i];
				textMsg.text += "\n";
			}
		}
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncTestAudio : MonoBehaviour
{
	public AudioSource audioSource;

	private void Start()
	{
		if (!audioSource)
		{
			audioSource = GetComponent<AudioSource>();
		}
		if ((bool)audioSource)
		{
			string dataPath = UnityEngine.Application.dataPath;
			dataPath += "/../";
			dataPath += "TestViseme.wav";
			WWW wWW = new WWW("file:///" + dataPath);
			while (!wWW.isDone)
			{
				UnityEngine.Debug.Log(wWW.progress);
			}
			if (wWW.GetAudioClip() != null)
			{
				audioSource.clip = wWW.GetAudioClip();
				audioSource.loop = true;
				audioSource.mute = false;
				audioSource.Play();
			}
		}
	}
}
public delegate void OVRCallback();
public delegate void OVRCallback<T>(T arg1);
public delegate void OVRCallback<T, U>(T arg1, U arg2);
public delegate void OVRCallback<T, U, V>(T arg1, U arg2, V arg3);
internal static class OVRMessenger
{
	public class BroadcastException : Exception
	{
		public BroadcastException(string msg)
			: base(msg)
		{
		}
	}

	public class ListenerException : Exception
	{
		public ListenerException(string msg)
			: base(msg)
		{
		}
	}

	private static MessengerHelper messengerHelper = new GameObject("MessengerHelper").AddComponent<MessengerHelper>();

	public static Dictionary<string, Delegate> eventTable = new Dictionary<string, Delegate>();

	public static List<string> permanentMessages = new List<string>();

	public static void MarkAsPermanent(string eventType)
	{
		permanentMessages.Add(eventType);
	}

	public static void Cleanup()
	{
		List<string> list = new List<string>();
		foreach (KeyValuePair<string, Delegate> item in eventTable)
		{
			bool flag = false;
			foreach (string permanentMessage in permanentMessages)
			{
				if (item.Key == permanentMessage)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				list.Add(item.Key);
			}
		}
		foreach (string item2 in list)
		{
			eventTable.Remove(item2);
		}
	}

	public static void PrintEventTable()
	{
		UnityEngine.Debug.Log("\t\t\t=== MESSENGER PrintEventTable ===");
		foreach (KeyValuePair<string, Delegate> item in eventTable)
		{
			UnityEngine.Debug.Log("\t\t\t" + item.Key + "\t\t" + item.Value);
		}
		UnityEngine.Debug.Log("\n");
	}

	public static void OnListenerAdding(string eventType, Delegate listenerBeingAdded)
	{
		if (!eventTable.ContainsKey(eventType))
		{
			eventTable.Add(eventType, null);
		}
		Delegate @delegate = eventTable[eventType];
		if ((object)@delegate != null && @delegate.GetType() != listenerBeingAdded.GetType())
		{
			throw new ListenerException($"Attempting to add listener with inconsistent signature for event type {eventType}. Current listeners have type {@delegate.GetType().Name} and listener being added has type {listenerBeingAdded.GetType().Name}");
		}
	}

	public static void OnListenerRemoving(string eventType, Delegate listenerBeingRemoved)
	{
		if (eventTable.ContainsKey(eventType))
		{
			Delegate @delegate = eventTable[eventType];
			if ((object)@delegate == null)
			{
				throw new ListenerException($"Attempting to remove listener with for event type \"{eventType}\" but current listener is null.");
			}
			if (@delegate.GetType() != listenerBeingRemoved.GetType())
			{
				throw new ListenerException($"Attempting to remove listener with inconsistent signature for event type {eventType}. Current listeners have type {@delegate.GetType().Name} and listener being removed has type {listenerBeingRemoved.GetType().Name}");
			}
			return;
		}
		throw new ListenerException($"Attempting to remove listener for type \"{eventType}\" but Messenger doesn't know about this event type.");
	}

	public static void OnListenerRemoved(string eventType)
	{
		if ((object)eventTable[eventType] == null)
		{
			eventTable.Remove(eventType);
		}
	}

	public static void OnBroadcasting(string eventType)
	{
	}

	public static BroadcastException CreateBroadcastSignatureException(string eventType)
	{
		return new BroadcastException($"Broadcasting message \"{eventType}\" but listeners have a different signature than the broadcaster.");
	}

	public static void AddListener(string eventType, OVRCallback handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback)Delegate.Combine((OVRCallback)eventTable[eventType], handler);
	}

	public static void AddListener<T>(string eventType, OVRCallback<T> handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback<T>)Delegate.Combine((OVRCallback<T>)eventTable[eventType], handler);
	}

	public static void AddListener<T, U>(string eventType, OVRCallback<T, U> handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U>)Delegate.Combine((OVRCallback<T, U>)eventTable[eventType], handler);
	}

	public static void AddListener<T, U, V>(string eventType, OVRCallback<T, U, V> handler)
	{
		OnListenerAdding(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U, V>)Delegate.Combine((OVRCallback<T, U, V>)eventTable[eventType], handler);
	}

	public static void RemoveListener(string eventType, OVRCallback handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback)Delegate.Remove((OVRCallback)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void RemoveListener<T>(string eventType, OVRCallback<T> handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback<T>)Delegate.Remove((OVRCallback<T>)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void RemoveListener<T, U>(string eventType, OVRCallback<T, U> handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U>)Delegate.Remove((OVRCallback<T, U>)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void RemoveListener<T, U, V>(string eventType, OVRCallback<T, U, V> handler)
	{
		OnListenerRemoving(eventType, handler);
		eventTable[eventType] = (OVRCallback<T, U, V>)Delegate.Remove((OVRCallback<T, U, V>)eventTable[eventType], handler);
		OnListenerRemoved(eventType);
	}

	public static void Broadcast(string eventType)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback();
		}
	}

	public static void Broadcast<T>(string eventType, T arg1)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback<T> oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback(arg1);
		}
	}

	public static void Broadcast<T, U>(string eventType, T arg1, U arg2)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback<T, U> oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback(arg1, arg2);
		}
	}

	public static void Broadcast<T, U, V>(string eventType, T arg1, U arg2, V arg3)
	{
		OnBroadcasting(eventType);
		if (eventTable.TryGetValue(eventType, out var value))
		{
			if (!(value is OVRCallback<T, U, V> oVRCallback))
			{
				throw CreateBroadcastSignatureException(eventType);
			}
			oVRCallback(arg1, arg2, arg3);
		}
	}
}
public sealed class MessengerHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	public void OnDisable()
	{
		OVRMessenger.Cleanup();
	}
}
internal static class OVRTouchpad
{
	public enum TouchEvent
	{
		SingleTap,
		DoubleTap,
		Left,
		Right,
		Up,
		Down
	}

	private static Vector3 moveAmountMouse;

	private static float minMovMagnitudeMouse = 25f;

	private static OVRTouchpadHelper touchpadHelper = new GameObject("OVRTouchpadHelper").AddComponent<OVRTouchpadHelper>();

	public static void Create()
	{
	}

	public static void Update()
	{
		if (Input.GetMouseButtonDown(0))
		{
			moveAmountMouse = Input.mousePosition;
		}
		else if (Input.GetMouseButtonUp(0))
		{
			moveAmountMouse -= Input.mousePosition;
			HandleInputMouse(ref moveAmountMouse);
		}
	}

	public static void OnDisable()
	{
	}

	private static void HandleInputMouse(ref Vector3 move)
	{
		if (move.magnitude < minMovMagnitudeMouse)
		{
			OVRMessenger.Broadcast("Touchpad", TouchEvent.SingleTap);
			return;
		}
		move.Normalize();
		if (Mathf.Abs(move.x) > Mathf.Abs(move.y))
		{
			if (move.x > 0f)
			{
				OVRMessenger.Broadcast("Touchpad", TouchEvent.Left);
			}
			else
			{
				OVRMessenger.Broadcast("Touchpad", TouchEvent.Right);
			}
		}
		else if (move.y > 0f)
		{
			OVRMessenger.Broadcast("Touchpad", TouchEvent.Down);
		}
		else
		{
			OVRMessenger.Broadcast("Touchpad", TouchEvent.Up);
		}
	}
}
public sealed class OVRTouchpadHelper : MonoBehaviour
{
	private void Awake()
	{
		UnityEngine.Object.DontDestroyOnLoad(base.gameObject);
	}

	private void Start()
	{
		OVRMessenger.AddListener<OVRTouchpad.TouchEvent>("Touchpad", LocalTouchEventCallback);
	}

	private void Update()
	{
		OVRTouchpad.Update();
	}

	public void OnDisable()
	{
		OVRTouchpad.OnDisable();
	}

	private void LocalTouchEventCallback(OVRTouchpad.TouchEvent touchEvent)
	{
		switch (touchEvent)
		{
		}
	}
}
public class OVRLipSync : MonoBehaviour
{
	public enum Result
	{
		Success = 0,
		Unknown = -2200,
		CannotCreateContext = -2201,
		InvalidParam = -2202,
		BadSampleRate = -2203,
		MissingDLL = -2204,
		BadVersion = -2205,
		UndefinedFunction = -2206
	}

	public enum Viseme
	{
		sil,
		PP,
		FF,
		TH,
		DD,
		kk,
		CH,
		SS,
		nn,
		RR,
		aa,
		E,
		ih,
		oh,
		ou
	}

	public enum Flags
	{
		None,
		DelayCompensateAudio
	}

	public enum Signals
	{
		VisemeOn,
		VisemeOff,
		VisemeAmount,
		VisemeSmoothing
	}

	public enum ContextProviders
	{
		Main,
		Other
	}

	[Serializable]
	public class Frame
	{
		public int frameNumber;

		public int frameDelay;

		public float[] Visemes = new float[VisemeCount];

		public void CopyInput(Frame input)
		{
			if (input != null)
			{
				frameNumber = input.frameNumber;
				frameDelay = input.frameDelay;
				input.Visemes.CopyTo(Visemes, 0);
			}
		}
	}

	public static readonly int VisemeCount = Enum.GetNames(typeof(Viseme)).Length;

	public static readonly int SignalCount = Enum.GetNames(typeof(Signals)).Length;

	public const string strOVRLS = "OVRLipSync";

	private static Result sInitialized = Result.Unknown;

	public static OVRLipSync sInstance = null;

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_Initialize(int samplerate, int buffersize);

	[DllImport("OVRLipSync")]
	private static extern void ovrLipSyncDll_Shutdown();

	[DllImport("OVRLipSync")]
	private static extern IntPtr ovrLipSyncDll_GetVersion(ref int Major, ref int Minor, ref int Patch);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_CreateContext(ref uint context, ContextProviders provider);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_DestroyContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ResetContext(uint context);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_SendSignal(uint context, Signals signal, int arg1, int arg2);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrame(uint context, float[] audioBuffer, Flags flags, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount);

	[DllImport("OVRLipSync")]
	private static extern int ovrLipSyncDll_ProcessFrameInterleaved(uint context, float[] audioBuffer, Flags flags, ref int frameNumber, ref int frameDelay, float[] visemes, int visemeCount);

	private void Awake()
	{
		if (sInstance == null)
		{
			sInstance = this;
			int outputSampleRate = AudioSettings.outputSampleRate;
			AudioSettings.GetDSPBufferSize(out var bufferLength, out var _);
			UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Queried SampleRate: {outputSampleRate:F0} BufferSize: {bufferLength:F0}");
			sInitialized = Initialize(outputSampleRate, bufferLength);
			if (sInitialized != 0)
			{
				UnityEngine.Debug.LogWarning($"OvrLipSync Awake: Failed to init Speech Rec library");
			}
		}
		else
		{
			UnityEngine.Debug.LogWarning($"OVRLipSync Awake: Only one instance of OVRPLipSync can exist in the scene.");
		}
	}

	private void OnDestroy()
	{
		if (sInstance != this)
		{
			UnityEngine.Debug.LogWarning("OVRLipSync OnDestroy: This is not the correct OVRLipSync instance.");
		}
	}

	public static Result Initialize(int sampleRate, int bufferSize)
	{
		sInitialized = (Result)ovrLipSyncDll_Initialize(sampleRate, bufferSize);
		return sInitialized;
	}

	public static void Shutdown()
	{
		ovrLipSyncDll_Shutdown();
		sInitialized = Result.Unknown;
	}

	public static Result IsInitialized()
	{
		return sInitialized;
	}

	public static Result CreateContext(ref uint context, ContextProviders provider)
	{
		if (IsInitialized() != 0)
		{
			return Result.CannotCreateContext;
		}
		return (Result)ovrLipSyncDll_CreateContext(ref context, provider);
	}

	public static Result DestroyContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_DestroyContext(context);
	}

	public static Result ResetContext(uint context)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ResetContext(context);
	}

	public static Result SendSignal(uint context, Signals signal, int arg1, int arg2)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_SendSignal(context, signal, arg1, arg2);
	}

	public static Result ProcessFrame(uint context, float[] audioBuffer, Flags flags, Frame frame)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ProcessFrame(context, audioBuffer, flags, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length);
	}

	public static Result ProcessFrameInterleaved(uint context, float[] audioBuffer, Flags flags, Frame frame)
	{
		if (IsInitialized() != 0)
		{
			return Result.Unknown;
		}
		return (Result)ovrLipSyncDll_ProcessFrameInterleaved(context, audioBuffer, flags, ref frame.frameNumber, ref frame.frameDelay, frame.Visemes, frame.Visemes.Length);
	}
}
public class OVRLipSyncContext : OVRLipSyncContextBase
{
	public float gain = 1f;

	public bool audioMute;

	public KeyCode loopback = KeyCode.L;

	public KeyCode debugVisemes = KeyCode.D;

	public bool showVisemes;

	public bool delayCompensate;

	private OVRLipSync.Frame debugFrame = new OVRLipSync.Frame();

	private float debugFrameTimer;

	private float debugFrameTimeoutValue = 0.1f;

	private void Start()
	{
	}

	private void Update()
	{
	}

	private void OnAudioFilterRead(float[] data, int channels)
	{
		if (OVRLipSync.IsInitialized() != 0)
		{
			return;
		}
		for (int i = 0; i < data.Length; i++)
		{
			data[i] *= gain;
		}
		lock (this)
		{
			if (base.Context != 0)
			{
				OVRLipSync.Flags flags = OVRLipSync.Flags.None;
				if (delayCompensate)
				{
					flags |= OVRLipSync.Flags.DelayCompensateAudio;
				}
				OVRLipSync.Frame frame = base.Frame;
				OVRLipSync.ProcessFrameInterleaved(base.Context, data, flags, frame);
			}
		}
		if (audioMute)
		{
			for (int j = 0; j < data.Length; j++)
			{
				data[j] *= 0f;
			}
		}
	}

	private void DebugShowVisemes()
	{
		if (!showVisemes)
		{
			return;
		}
		debugFrameTimer -= Time.deltaTime;
		if (debugFrameTimer < 0f)
		{
			debugFrameTimer += debugFrameTimeoutValue;
			debugFrame.CopyInput(base.Frame);
		}
		string text = "";
		for (int i = 0; i < debugFrame.Visemes.Length; i++)
		{
			if (i < 10)
			{
				text += "0";
			}
			text += i;
			text += ":";
			int num = (int)(50f * debugFrame.Visemes[i]);
			for (int j = 0; j < num; j++)
			{
				text += "*";
			}
			text += "\n";
		}
		OVRLipSyncDebugConsole.Clear();
		OVRLipSyncDebugConsole.Log(text);
	}
}
public class OVRLipSyncContextBase : MonoBehaviour
{
	public AudioSource audioSource;

	public OVRLipSync.ContextProviders provider;

	private OVRLipSync.Frame frame = new OVRLipSync.Frame();

	private uint context;

	public int Smoothing
	{
		set
		{
			OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeSmoothing, value, 0);
		}
	}

	public uint Context => context;

	protected OVRLipSync.Frame Frame => frame;

	private void Awake()
	{
		lock (this)
		{
			if (context == 0 && OVRLipSync.CreateContext(ref context, provider) != 0)
			{
				UnityEngine.Debug.Log("OVRPhonemeContext.Start ERROR: Could not create Phoneme context.");
			}
		}
	}

	private void OnDestroy()
	{
		lock (this)
		{
			if (context != 0 && OVRLipSync.DestroyContext(context) != 0)
			{
				UnityEngine.Debug.Log("OVRPhonemeContext.OnDestroy ERROR: Could not delete Phoneme context.");
			}
		}
	}

	public OVRLipSync.Frame GetCurrentPhonemeFrame()
	{
		return frame;
	}

	public void SetVisemeBlend(int viseme, int amount)
	{
		OVRLipSync.SendSignal(context, OVRLipSync.Signals.VisemeAmount, viseme, amount);
	}

	public OVRLipSync.Result ResetContext()
	{
		return OVRLipSync.ResetContext(context);
	}
}
[RequireComponent(typeof(AudioSource))]
public class OVRLipSyncContextCanned : OVRLipSyncContextBase
{
	public OVRLipSyncSequence currentSequence;

	private void Start()
	{
	}

	private void Update()
	{
		if (audioSource.isPlaying && currentSequence != null)
		{
			OVRLipSync.Frame frameAtTime = currentSequence.GetFrameAtTime(audioSource.time);
			base.Frame.CopyInput(frameAtTime);
		}
	}
}
public class OVRLipSyncContextMorphTarget : MonoBehaviour
{
	public SkinnedMeshRenderer skinnedMeshRenderer;

	public int[] VisemeToBlendTargets = new int[OVRLipSync.VisemeCount];

	public bool enableVisemeSignals;

	public int[] KeySendVisemeSignal = new int[10];

	public int SmoothAmount = 100;

	[SerializeField]
	private OVRLipSyncContextBase lipsyncContext;

	private void Start()
	{
		if (skinnedMeshRenderer == null)
		{
			UnityEngine.Debug.Log("LipSyncContextMorphTarget.Start WARNING: Please set required public components!");
			return;
		}
		if (lipsyncContext == null)
		{
			lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		}
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.Log("LipSyncContextMorphTarget.Start WARNING: No phoneme context component set to object");
		}
		lipsyncContext.Smoothing = SmoothAmount;
	}

	private void LateUpdate()
	{
		if (lipsyncContext != null && skinnedMeshRenderer != null)
		{
			OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
			if (currentPhonemeFrame != null)
			{
				SetVisemeToMorphTarget(currentPhonemeFrame);
			}
			CheckForKeys();
		}
	}

	private void CheckForKeys()
	{
		if (enableVisemeSignals)
		{
			CheckVisemeKey(KeyCode.Alpha1, 0, 100);
			CheckVisemeKey(KeyCode.Alpha2, 1, 100);
			CheckVisemeKey(KeyCode.Alpha3, 2, 100);
			CheckVisemeKey(KeyCode.Alpha4, 3, 100);
			CheckVisemeKey(KeyCode.Alpha5, 4, 100);
			CheckVisemeKey(KeyCode.Alpha6, 5, 100);
			CheckVisemeKey(KeyCode.Alpha7, 6, 100);
			CheckVisemeKey(KeyCode.Alpha8, 7, 100);
			CheckVisemeKey(KeyCode.Alpha9, 8, 100);
			CheckVisemeKey(KeyCode.Alpha0, 9, 100);
			CheckVisemeKey(KeyCode.Q, 10, 100);
			CheckVisemeKey(KeyCode.W, 11, 100);
			CheckVisemeKey(KeyCode.E, 12, 100);
			CheckVisemeKey(KeyCode.R, 13, 100);
			CheckVisemeKey(KeyCode.T, 14, 100);
		}
	}

	private void SetVisemeToMorphTarget(OVRLipSync.Frame frame)
	{
		for (int i = 0; i < VisemeToBlendTargets.Length; i++)
		{
			if (VisemeToBlendTargets[i] != -1)
			{
				skinnedMeshRenderer.SetBlendShapeWeight(VisemeToBlendTargets[i], frame.Visemes[i] * 100f);
			}
		}
	}

	private void CheckVisemeKey(KeyCode key, int viseme, int amount)
	{
		if (Input.GetKeyDown(key))
		{
			lipsyncContext.SetVisemeBlend(KeySendVisemeSignal[viseme], amount);
		}
		if (Input.GetKeyUp(key))
		{
			lipsyncContext.SetVisemeBlend(KeySendVisemeSignal[viseme], 0);
		}
	}
}
public class OVRLipSyncContextTextureFlip : MonoBehaviour
{
	public Material material;

	public Texture[] Textures = new Texture[OVRLipSync.VisemeCount];

	public float smoothing;

	private OVRLipSyncContextBase lipsyncContext;

	private OVRLipSync.Frame oldFrame = new OVRLipSync.Frame();

	private void Start()
	{
		lipsyncContext = GetComponent<OVRLipSyncContextBase>();
		if (lipsyncContext == null)
		{
			UnityEngine.Debug.Log("LipSyncContextTextureFlip.Start WARNING: No lip sync context component set to object");
		}
	}

	private void Update()
	{
		if (!(lipsyncContext != null) || !(material != null))
		{
			return;
		}
		OVRLipSync.Frame currentPhonemeFrame = lipsyncContext.GetCurrentPhonemeFrame();
		if (currentPhonemeFrame != null)
		{
			for (int i = 0; i < currentPhonemeFrame.Visemes.Length; i++)
			{
				oldFrame.Visemes[i] = oldFrame.Visemes[i] * smoothing + currentPhonemeFrame.Visemes[i] * (1f - smoothing);
			}
			SetVisemeToTexture();
		}
	}

	private void SetVisemeToTexture()
	{
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < oldFrame.Visemes.Length; i++)
		{
			if (oldFrame.Visemes[i] > num2)
			{
				num = i;
				num2 = oldFrame.Visemes[i];
			}
		}
		if (num != -1 && num < Textures.Length)
		{
			Texture texture = Textures[num];
			if (texture != null)
			{
				material.SetTexture("_MainTex", texture);
			}
		}
	}
}
[Serializable]
public class OVRLipSyncSequence : ScriptableObject
{
	public List<OVRLipSync.Frame> entries = new List<OVRLipSync.Frame>();

	public float length;

	public OVRLipSync.Frame GetFrameAtTime(float time)
	{
		OVRLipSync.Frame result = null;
		if (time < length && entries.Count > 0)
		{
			float num = time / length;
			result = entries[(int)((float)entries.Count * num)];
		}
		return result;
	}
}
public class AsImageSample : MonoBehaviour
{
	[OnDragDrop(order = 1)]
	[HelpBox("Drop image here.", below = false, messageType = MessageType.None)]
	[AsImage]
	public Texture2D asImage;
}
public class BoxSample : MonoBehaviour
{
	[Box(0f, 0f, 0f, 0f)]
	[StackableField]
	public string box1 = "Simple Box";

	[Box(4f, 4f, 4f, 4f)]
	[StackableField]
	public string box2 = "Padding 4";

	[Box(-4f, -4f, -4f, -4f)]
	[StackableField]
	public string box3 = "Padding -4";

	[Box(2f, 2f, 2f, 2f, style = "ShurikenEffectBg")]
	[StackableField]
	public string box4 = "Style";
}
public class ButtonsSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Buttons(0f, 0f, 0f, 0f, titles = "Button1,Button2,Button3", actions = "Button1,Button2,Button3", below = true)]
	[StackableField]
	public string button1;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[IconSize(16, 16, order = 1)]
	[Buttons(0f, 0f, 0f, 0f, titles = "GameObject,Prefab,Scene", icons = "GameObject Icon,PrefabNormal Icon,SceneAsset Icon", actions = "Button1,Button2,Button3", alignment = TextAlignment.Center)]
	[StackableField]
	public string button2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideButtons(0f, 0f, 0f, 0f, titles = "+,-", actions = "Inc,Dec", onLeft = true, height = 1f)]
	[StackableField]
	public int num1;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideButtons(0f, 0f, 0f, 0f, titles = ",", icons = "ol plus,ol minus", actions = "Inc,Dec")]
	[StackableField]
	public int num2;

	public void Button1()
	{
		button1 = (button2 = "GameObject");
	}

	public void Button2()
	{
		button1 = (button2 = "Prefab");
	}

	public void Button3()
	{
		button1 = (button2 = "Scene");
	}

	public void Inc()
	{
		num2 = ++num1;
	}

	public void Dec()
	{
		num2 = --num1;
	}
}
public class ColorSample : MonoBehaviour
{
	[Color(1f, 0.5f, 0.5f, 1f)]
	[StackableField]
	public string color1 = "Simple Color";

	[Color(0.5f, 0.5f, 1f, 1f, order = 1)]
	[Box(4f, 4f, 4f, 4f)]
	[StackableField]
	public string color2 = "Colored Box";
}
public class DrawerSample : MonoBehaviour
{
	[Box(0f, 0f, 0f, 0f)]
	[StackableField]
	public string box1 = "Simple Box";

	[TextField(placeHolder = "Please enter the text.")]
	public string textField;

	[TextField(3, placeHolder = "Please enter the text.")]
	public string textField2;

	[Color(1f, 0.5f, 0.5f, 1f)]
	[Slider(0f, 100f)]
	public int slider;

	[Color(0.5f, 0.5f, 1f, 1f)]
	[RangeSlider(0f, 100f)]
	public Vector2 rangeSlider = new Vector2(25f, 50f);

	[ToggleLeft]
	public bool toggleLeft;

	[Expandable]
	public string expandable;

	[LabelOnly]
	public string labelOnly;

	[Label(icon = "GameObject Icon")]
	[AsString(label = false, icon = true)]
	public string asString = "As String Sample";

	[ColorField(showEyedropper = false)]
	public Color color;

	[CurveField(1f, 0f, 1f, -1f, -1f, 1f, 1f)]
	public AnimationCurve curve;

	[ProgressBar(100f, decimalPlaces = 0)]
	public int progress = 53;

	[ProgressBar(22f, 88f, showLabel = false, prefix = true)]
	public int progress2 = 39;
}
public class EnableIfSample : MonoBehaviour
{
	public bool enable1;

	public int enable2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[EnableIf("$enable1")]
	[StackableField]
	public string enableIf1 = "Enable if Enable1 is true";

	[EnableIf("$enable1", inverted = true)]
	[StackableField]
	public string enableIf1b = "Enable if Enable1 is false";

	[EnableIf("#Active")]
	[StackableField]
	public string enableIf2 = "Enable if Enable2 is positive";

	[EnableIf("#Active", order = 1)]
	[EnableIf("$enable1", disable = false)]
	[StackableField]
	public string enableIf3 = "EnableIf1 or EnableIf2";

	[EnableIf("#Active", order = 1)]
	[EnableIf("$enable1", enable = false)]
	[StackableField]
	public string enableIf4 = "EnableIf1 and EnableIf2";

	public bool Active()
	{
		return enable2 >= 0;
	}
}
public class EnumButtonSample : MonoBehaviour
{
	public enum Alignment
	{
		Left,
		Center,
		Right
	}

	public enum ColorMask
	{
		R = 1,
		G = 2,
		B = 4,
		A = 8,
		RGB = 7,
		RGBA = 15
	}

	public enum Axis
	{
		X = 1,
		Y = 2,
		Z = 4
	}

	[HorizontalGroup("Main", false, "key", new float[] { -1f, 80f }, order = 1)]
	[Group("Left", 3, new float[] { })]
	[EnumButton]
	public Alignment alignment;

	[InGroup("Left")]
	[EnumButton(exclude = "RGB,RGBA")]
	public ColorMask color;

	[InGroup("Left")]
	[EnumMaskButton(all = false, column = 3)]
	public ColorMask colorMask;

	[InGroup("Left")]
	[EnumMaskButton(styles = "toggle")]
	public Axis axis;

	[InGroup("Main", order = 1)]
	[Label(0f)]
	[EnumButton(column = 1, vOffset = -3)]
	public EventModifiers key;
}
public class EnumPopupSample : MonoBehaviour
{
	public enum Alignment
	{
		Left,
		Center,
		Right
	}

	public enum ColorMask
	{
		R = 1,
		G = 2,
		B = 4,
		A = 8,
		RGB = 7,
		RGBA = 15
	}

	public enum Axis
	{
		X = 1,
		Y = 2,
		Z = 4
	}

	[Heading(0f, 0f, 0f, 0f, title = "Enum Popup")]
	[EnumPopup]
	public Alignment alignment;

	[EnumPopup(exclude = "RGB,RGBA", placeHolder = "Please select a channel.")]
	public ColorMask color1;

	[EnumPopup(names = "Red,Green,Blue,Alpha", placeHolder = "Please select a channel.")]
	public ColorMask color2;

	[EnumPopup(placeHolder = "Please select an axis.")]
	public Axis axis;

	[EnumPopup]
	public EventModifiers key1;

	[EnumPopup(exclude = "None", placeHolder = "Please select modifiers key.")]
	public EventModifiers key2;

	[Heading(0f, 0f, 8f, 0f, title = "Enum Mask Popup")]
	[EnumMaskPopup]
	public ColorMask mask1;

	[EnumMaskPopup(showAll = false, showCombined = true)]
	public ColorMask mask2;

	[EnumMaskPopup(names = "Shift,Alt,Ctrl,Command")]
	public EventModifiers key3;

	[Heading(0f, 0f, 8f, 0f)]
	[DropdownValue("#values", names = "#names", placeHolder = "Please select value.")]
	public int dropdownValue;

	[DropdownMask("#names", "#values", sortCombined = false, showCombined = true)]
	public int dropdownMask;

	[LayerMaskPopup]
	public LayerMask layerMask;

	private string[] names
	{
		get
		{
			return new string[8] { "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight" };
		}
		set
		{
		}
	}

	private int[] values
	{
		get
		{
			return new int[8] { 1, 2, 3, 4, 5, 6, 7, 8 };
		}
		set
		{
		}
	}
}
public class EventSample : MonoBehaviour
{
	[HelpBox("Value Changed", "#showHelpBox", order = 2)]
	[OnValueChanged("OnValueChanged", order = 1)]
	[Group("OnValueChanged", 2, new float[] { })]
	[StackableField]
	public string data1 = "Data1";

	[InGroup("OnValueChanged")]
	[Slider(0f, 100f)]
	public int data2;

	[InGroup("OnValueChanged")]
	[StackableField]
	public Color data3;

	[OnClick("#OnClick", order = 1)]
	[Box(2f, 2f, 2f, 2f)]
	[AsString]
	public string onClick = "Click to hide the help box.";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[OnDragDrop(autoDrop = false, after = true, order = 1)]
	[HelpBox("Drag image out.", below = false, messageType = MessageType.None)]
	[StackableField]
	public Texture2D dragOnly;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[OnDragDrop(order = 1)]
	[HelpBox("Drag image out or drop image here.", below = false, messageType = MessageType.None)]
	[AsImage]
	public Texture2D dragDrop;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 2)]
	[OnDragDrop(autoDrag = false, order = 1)]
	[HelpBox("Drop image here.", below = false, messageType = MessageType.None)]
	[AsImage]
	public Texture2D dropOnly;

	public bool showHelpBox { get; set; }

	public void OnClick()
	{
		showHelpBox = false;
	}

	public void OnValueChanged()
	{
		showHelpBox = true;
	}
}
public class FoldoutSample : MonoBehaviour
{
	[Foldout(title = "Foldout")]
	[StackableField]
	public string foldout1 = "Simple Foldout";

	[Foldout(title = "Foldout Group", order = 2)]
	[Group("Foldout Group", 1, new float[] { })]
	[StackableField]
	public string foldout2a = "Foldout with group";

	[InGroup("Foldout Group")]
	[StackableField]
	public string foldout2b;

	[Box(0f, 0f, 4f, 6f, style = "label", order = 3)]
	[Foldout(title = "Foldout with style", hierarchyMode = false, indentChildren = false, style2 = "flow overlay header lower left", order = 2)]
	[Box(2f, 4f, 2f, 4f, style = "flow overlay box", order = 1)]
	[Group("Foldout with style", 2, new float[] { })]
	[StackableField]
	public string foldout3a = "Foldout with style";

	[InGroup("Foldout with style")]
	[StackableField]
	public string foldout3b;

	[InGroup("Foldout with style")]
	[StackableField]
	public string foldout3c;
}
public class GroupSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string group3a = "Group with all children but group3c";

		public string group3b;

		public string group3c;

		public string group3d;
	}

	[Box(2f, 2f, 2f, 2f, order = 1)]
	[Group("Group 1", 2, new float[] { })]
	[StackableField]
	public string group1a = "Group with 2 following properties";

	[InGroup("Group 1")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1")]
	[StackableField]
	public string group1c;

	[Box(2f, 2f, 2f, 2f, order = 1)]
	[Group("Group 2", false, "group2b,group2c", new float[] { })]
	[StackableField]
	public string group2a = "Group with 2 selected properties";

	[InGroup("Group 2")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2")]
	[StackableField]
	public string group2c;

	[Box(2f, 2f, 2f, 2f, order = 1)]
	[Group("Group 3", true, ".group3c", new float[] { 0f })]
	[StackableField]
	public Children group3;
}
public class HeadingSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, title = "Header")]
	[StackableField]
	public string heading1 = "Simple Heading";

	[Heading(0f, 0f, 0f, 0f, title = "Footer", below = true)]
	[StackableField]
	public string heading2 = "Below";

	[Heading(4f, 4f, 4f, 4f, title = "Header", alignment = TextAlignment.Right)]
	[StackableField]
	public string heading3 = "Padding and right alignment";

	[Heading(4f, 4f, 4f, 4f, title = "Footer", below = true, alignment = TextAlignment.Center, style = "box")]
	[StackableField]
	public string heading4 = "Style, padding and center alignment";

	[Heading(0f, 0f, 0f, 0f, title = "Header", icon = "console.infoicon.sml", width = 0.5f, height = 24f, alignment = TextAlignment.Center, style = "box")]
	[StackableField]
	public string heading5 = "Icon, Width(%) and height";

	[Heading(4f, 0f, -12f, 0f, width = 1f, height = 22f, style = "PR Insertion")]
	[StackableField]
	public string heading6 = "Style and bottom padding -12";

	[Heading(-14f, -5f, 0f, 2f, width = 1f, title = "Header", style = "box")]
	[StackableField]
	public string heading7 = "Negative padding";
}
public class HelpBoxSample : MonoBehaviour
{
	[HelpBox("Helpbox message on top.", below = false, messageType = MessageType.None)]
	[StackableField]
	public string HelpBox1;

	[HelpBox("Helpbox information.", messageType = MessageType.Info)]
	[StackableField]
	public string HelpBox2;

	[HelpBox("Helpbox warning.", messageType = MessageType.Warning)]
	[StackableField]
	public string HelpBox3;

	[HelpBox("Helpbox error.", messageType = MessageType.Error)]
	[StackableField]
	public string HelpBox4;
}
public class HelpBoxSample2 : MonoBehaviour
{
	public bool show1;

	public int show2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[HelpBox("Show if Show1 is true", "$show1")]
	[StackableField]
	public string HelpBox1;

	[HelpBox("Show if Show1 is false", "$show1", inverted = true)]
	[StackableField]
	public string HelpBox1b;

	[HelpBox("Show if Show2 is positive", "#Visible")]
	[StackableField]
	public string HelpBox2;

	[HelpBox("Show if self is positive", "#CheckValue")]
	[StackableField]
	public int HelpBox2b;

	public bool Visible()
	{
		return show2 >= 0;
	}

	public bool CheckValue(int value)
	{
		return value >= 0;
	}
}
public class HierarchyModeSample : MonoBehaviour
{
	[Serializable]
	public class On
	{
		public string hierarchyMode = "HierarchyMode On";
	}

	[Serializable]
	public class Off
	{
		public string hierarchyMode = "HierarchyMode Off";
	}

	public On hierarchyModeOn;

	[HierarchyMode(false)]
	[StackableField]
	public Off hierarchyModeOff;
}
public class HorizontalGroupSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		[Label(0f)]
		[StackableField]
		public string group3a;

		[Label(0f)]
		[StackableField]
		public string group3b;

		[Label(0f)]
		[StackableField]
		public string group3c;

		[Label(0f)]
		[StackableField]
		public string group3d;
	}

	[HorizontalGroup("Group 1", 2, new float[] { -1f, 65f, 65f })]
	[StackableField]
	public string group1a;

	[InGroup("Group 1", order = 1)]
	[Label(-1f, title = "B")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1", order = 1)]
	[Label(-1f, title = "C")]
	[StackableField]
	public string group1c;

	[HorizontalGroup("Group 2", false, "group2b,group2c", new float[] { }, order = 1)]
	[Label(25f, title = "A")]
	[StackableField]
	public string group2a;

	[InGroup("Group 2", order = 1)]
	[Label(25f, title = "B")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2", order = 1)]
	[Label(25f, title = "C")]
	[StackableField]
	public string group2c;

	[HorizontalGroup("Group 3", true, ".group3c", new float[] { 0f }, prefix = true)]
	[StackableField]
	public Children group3;
}
public class IconSizeSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, title = "GameObject", icon = "GameObject Icon")]
	[StackableField]
	public string IconSizeOff = "IconSize Off";

	[IconSize(16, 16, order = 1)]
	[Heading(0f, 0f, 0f, 0f, title = "GameObject", icon = "GameObject Icon")]
	[StackableField]
	public string IconSize = "IconSize 16";
}
public class ImageSample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, image = "GameObject Icon")]
	[StackableField]
	public string image1 = "Using internal resource";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, image = "Assets/StackableDecorator/Sample/logo.png", alignment = TextAlignment.Right)]
	[StackableField]
	public string image2 = "Using file path";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, image = "31929cbaa6b12f441b2d2f5d23cbb8ce", GUID = true, alignment = TextAlignment.Center)]
	[StackableField]
	public string image3 = "Using GUID";

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[Image(0f, 0f, 0f, 0f, texture = "$texture")]
	[StackableField]
	public string image4 = "Using texture";

	public Texture2D texture;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideImage(0f, 0f, 0f, 0f, image = "GameObject Icon", onLeft = true, height = 1f)]
	[StackableField]
	public string side1;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[SideImage(0f, 0f, 0f, 0f, texture = "$texture", height = 48f)]
	[StackableField]
	public string side2;
}
public class IncludeChildrenSample : MonoBehaviour
{
	[Serializable]
	public class On
	{
		public string includeChildren = "IncludeChildren On";
	}

	[Serializable]
	public class Off
	{
		public string includeChildren = "IncludeChildren Off";
	}

	public On includeChildrenOn;

	[IncludeChildren(false)]
	[StackableField]
	public Off includeChildrenOff;
}
public class IndentLevelSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string indentLevel1 = "IndentLevel Off";

		[IndentLevel(-1)]
		[StackableField]
		public string indentLevel2 = "IndentLevel -1";

		[IndentLevel(-2)]
		[StackableField]
		public string indentLevel3 = "IndentLevel -2";

		[IndentLevel(0, absolute = true)]
		[StackableField]
		public string indentLevel4 = "IndentLevel 0 (absolute)";

		[IndentLevel(3, absolute = true)]
		[StackableField]
		public string indentLevel5 = "IndentLevel 3 (absolute)";
	}

	public string indentLevel1 = "IndentLevel Off";

	[IndentLevel(1)]
	[StackableField]
	public string indentLevel2 = "IndentLevel +1";

	[IndentLevel(2)]
	[StackableField]
	public string indentLevel3 = "IndentLevel +2";

	public Children children;
}
public class InlinePropertySample : MonoBehaviour
{
	[InlineProperty(3f, 3f, 3f, 3f)]
	[Expandable]
	public Transform trans;

	[InlineProperty(3f, 3f, 3f, 3f)]
	[Expandable]
	public Material material;

	[InlineProperty(3f, 3f, 3f, 3f)]
	[Expandable]
	public UnityEngine.Object obj;
}
public class LabelSample : MonoBehaviour
{
	[Label(title = "Title")]
	[StackableField]
	public string label1 = "Change Title";

	[Label(title = "GameObject", icon = "GameObject Icon", tooltip = "Tooltip")]
	[StackableField]
	public string label2 = "Change Title, Icon and Tooltip";

	[Label(100f)]
	[StackableField]
	public string label3 = "Change Width";

	[Label(0f)]
	[StackableField]
	public string label4 = "Hide Label";

	[Label(-1f)]
	[StackableField]
	public string label5 = "Auto Width";

	[Label(-1f, title = "Auto Width")]
	[StackableField]
	public string label6 = "Auto Width with title";
}
public class ListSample : MonoBehaviour
{
	[Serializable]
	public class NestedList
	{
		[List(expandable = true)]
		public List<DataList> list;
	}

	[Serializable]
	public class DataList
	{
		[Label(-1f, order = 1)]
		[HorizontalGroup("info", true, "", new float[] { 0f, 15f, -1f, 50f }, prefix = true)]
		[StackableField]
		public List<Data> list;
	}

	[Serializable]
	public class Data
	{
		[Label(0f)]
		[StackableField]
		public bool enable;

		[Label(0f)]
		[Slider(0f, 100f, showField = false)]
		public int value;

		[Label(0f)]
		[StackableField]
		public Color color;
	}

	[List]
	[SerializeField]
	private DataList m_DataList;

	[Heading(0f, 0f, 0f, 0f, title = "Nested List")]
	[List]
	[SerializeField]
	public NestedList nestedList;

	[Heading(0f, 0f, 0f, 0f, title = "SimpleList")]
	[SimpleList("m_DataList.list")]
	public string placeholder1;

	[Heading(0f, 0f, 8f, 0f, title = "SimpleGrid")]
	[SimpleGrid("m_DataList.list", column = 2, cellHeight = 16f)]
	public string placeholder2;

	public List<Data> dataList => m_DataList.list;
}
public class Logo : MonoBehaviour
{
	[Heading(0f, 0f, 8f, 0f, order = 7)]
	[HorizontalGroup("Logo", 0, new float[] { 98f }, order = 6)]
	[Box(4f, 4f, 4f, 4f, style = "flow node 1 on", order = 5)]
	[Heading(0f, 0f, 2f, 6f, title = "Stackable", width = -1f, style = "WarningOverlay", order = 4)]
	[Color(1f, 1f, 0.5f, 1f, order = 3)]
	[Box(4f, 4f, 4f, 4f, style = "flow overlay box", order = 2)]
	[Label(-1f)]
	[StackableField]
	public bool Decorator = true;
}
public class PopupEditorSample : MonoBehaviour
{
	[PopupEditor]
	[StackableField]
	public Transform trans;

	[PopupEditor]
	[StackableField]
	public Material material;

	[PopupEditor(width = -1f, title = "Popup", style = "minibutton")]
	[StackableField]
	public UnityEngine.Object obj;
}
public class PopupSample : MonoBehaviour
{
	[TagPopup]
	public string tag1 = "Untagged";

	[TagPopup(placeHolder = "Please select a tag.", exclude = "Untagged")]
	public string tag2;

	[LayerPopup]
	public int layer1;

	[LayerPopup(placeHolder = "Please select a layer.", exclude = "Default")]
	public string layer2;

	[SortingLayerPopup]
	public int sortingLayer1;

	[SortingLayerPopup(placeHolder = "Please select a layer.", exclude = "Default")]
	public string sortingLayer2;

	[InputAxisPopup(placeHolder = "Please select a input.")]
	public string input1;

	[InputAxisPopup(placeHolder = "Please select a input.", mouseMovement = false, joystickAxis = false, negativeButton = false)]
	public string input2;

	[AnimatorParameterPopup(placeHolder = "Please select a parameter.")]
	public string parameter1;

	[AnimatorParameterPopup(placeHolder = "Please select a parameter.", triggerType = false)]
	public string parameter2;
}
public class PreviewSample : MonoBehaviour
{
	[Preview]
	[Expandable]
	public GameObject prefab;

	[Preview]
	[Expandable]
	public Material material;

	[Preview]
	[Expandable]
	public Texture texture;
}
public class Sample : MonoBehaviour
{
	[Heading(0f, 0f, 0f, 0f, title = "Heading", order = 3)]
	[Color(0.5f, 0.5f, 1f, 1f, order = 2)]
	[Box(2f, 2f, 2f, 2f)]
	[StackableField]
	public string field;
}
public class ShowIfSample : MonoBehaviour
{
	public bool show1;

	public int show2;

	[Heading(0f, 0f, 0f, 0f, height = 8f, order = 1)]
	[ShowIf("$show1")]
	[StackableField]
	public string showIf1 = "Show if Show1 is true";

	[ShowIf("$show1", inverted = true)]
	[StackableField]
	public string showIf1b = "Show if Show1 is false";

	[ShowIf("#Visible")]
	[StackableField]
	public string showIf2 = "Show if Show2 is positive";

	[ShowIf("#Visible", order = 1)]
	[ShowIf("$show1", disable = false)]
	[StackableField]
	public string enableIf3 = "ShowIf1 or ShowIf2";

	[ShowIf("#Visible", order = 1)]
	[ShowIf("$show1", enable = false)]
	[StackableField]
	public string enableIf4 = "ShowIf1 and ShowIf2";

	public bool Visible()
	{
		return show2 >= 0;
	}
}
public class TabGroupSample : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string group3a = "Group with all children but group3c";

		public string group3b;

		public string group3c;

		public string group3d;
	}

	[TabGroup("Tab Group", "Tab1,Tab2,Tab3", "group2a,group3", 0f, 0f, 0f, 2f, order = 1)]
	[Group("Group 1", 2, new float[] { })]
	[StackableField]
	public string group1a = "Group with 2 following properties";

	[InGroup("Group 1")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1")]
	[StackableField]
	public string group1c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 2", false, "group2b,group2c", new float[] { })]
	[StackableField]
	public string group2a = "Group with 2 selected properties";

	[InGroup("Group 2")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2")]
	[StackableField]
	public string group2c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 3", true, ".group3c", new float[] { 0f })]
	[StackableField]
	public Children group3;
}
public class TabGroupSample2 : MonoBehaviour
{
	[Serializable]
	public class Children
	{
		public string group3a = "Group with all children but group3c";

		public string group3b;

		public string group3c;

		public string group3d;
	}

	[IconSize(16, 16, order = 2)]
	[TabGroup("Tab Group", "GameObject,Prefab,Scene", "group2a,group3", -14f, -5f, 2f, 0f, icons = "GameObject Icon,PrefabNormal Icon,SceneAsset Icon", alignment = TextAlignment.Center, width = 0.8f, style = "toolbarbutton", style2 = "Toolbar", order = 1)]
	[Group("Group 1", 2, new float[] { })]
	[StackableField]
	public string group1a = "Group with 2 following properties";

	[InGroup("Group 1")]
	[StackableField]
	public string group1b;

	[InGroup("Group 1")]
	[StackableField]
	public string group1c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 2", false, "group2b,group2c", new float[] { })]
	[StackableField]
	public string group2a = "Group with 2 selected properties";

	[InGroup("Group 2")]
	[StackableField]
	public string group2b;

	[InGroup("Group 2")]
	[StackableField]
	public string group2c;

	[InGroup("Tab Group", order = 1)]
	[Group("Group 3", true, ".group3c", new float[] { 0f })]
	[StackableField]
	public Children group3;
}
public class ValidateObjectSample : MonoBehaviour
{
	[NotNull]
	[StackableField]
	public GameObject notNull1;

	[NotNull]
	[StackableField]
	public GameObject notNull2;

	[AssetOnly]
	[StackableField]
	public GameObject assetOnly1;

	[AssetOnly]
	[StackableField]
	public GameObject assetOnly2;

	[SceneOnly]
	[StackableField]
	public GameObject sceneOnly1;

	[SceneOnly]
	[StackableField]
	public GameObject sceneOnly2;
}
public class ValidateValueSample : MonoBehaviour
{
	public int referenceValue = 100;

	[ValidateValue("%1 cannot larger than Reference Value.", "#CheckValue")]
	[StackableField]
	public int validateValue1;

	[ValidateValue("%1 cannot larger than Reference Value.", "#CheckValue")]
	[StackableField]
	public int validateValue2 = 200;

	[ValidateValue("%1 require ValidateValueSample.", "#CheckObject")]
	[StackableField]
	public GameObject validateObject1;

	[ValidateValue("%1 require ValidateValueSample.", "#CheckObject")]
	[StackableField]
	public GameObject validateObject2;

	[ValidateValue("%1 require ValidateValueSample.", "#CheckObject")]
	[StackableField]
	public GameObject validateObject3;

	[ValidateValue("More than 2 elements.", "#CheckArray")]
	[StackableField]
	public int[] validateArray;

	public bool CheckValue(int value)
	{
		return value <= referenceValue;
	}

	public bool CheckObject(GameObject go)
	{
		if (go != null)
		{
			return go.GetComponent<ValidateValueSample>() != null;
		}
		return false;
	}
}
public class BgmData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int ID;

		public int Layer;

		public int Parts;

		public int Bpm;

		public int Bars;

		public int Beats;

		public int UnitPerBar;

		public bool Intro;

		public bool Outro;

		public bool SingleClip;

		public int FadeBars;
	}

	public List<Param> param = new List<Param>();

	public Param FindByID(int id)
	{
		int count = param.Count;
		for (int i = 0; i < count; i++)
		{
			if (param[i].ID == id)
			{
				return param[i];
			}
		}
		UnityEngine.Debug.Log("Cannnot Find Bgm Data! id = " + id);
		return null;
	}
}
public class Entity_CharaName : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int id;

		public string name;

		public string ja;

		public string en;

		public string ch;
	}

	public List<Param> param = new List<Param>();
}
public class Entity_ScenarioRelatedData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int Sqid;

		public int Related;

		public bool Skippable;
	}

	public List<Param> param = new List<Param>();
}
public class LocalizeData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public string KEY;

		public string Japanese;

		public string English;

		public string German;

		public string French;

		public string Chinese;
	}

	public List<Param> param = new List<Param>();
}
public class ScenarioTableData : ScriptableObject
{
	[Serializable]
	public class Param
	{
		public int Chara;

		public string TextJp;

		public string TextEg;

		public string TextCh;

		public string Voice;

		public string TextGe;
	}

	public List<Param> param = new List<Param>();
}
public class Compression
{
	private class Node
	{
		public int mNext;

		public int mPrev;

		public int mPos;
	}

	private class Index
	{
		private Node[] mNodes = new Node[2304];

		private int[] mStack = new int[2048];

		private int mStackPos;

		public Index()
		{
			for (int i = 0; i < 2304; i++)
			{
				mNodes[i] = new Node();
			}
			for (int j = 2048; j < 2304; j++)
			{
				mNodes[j].mNext = (mNodes[j].mPrev = j);
			}
			for (int k = 0; k < 2048; k++)
			{
				mStack[k] = k;
			}
			mStackPos = 2048;
		}

		public int getFirst(byte c)
		{
			return mNodes[2048 + c].mNext;
		}

		public Node getNode(int i)
		{
			return mNodes[i];
		}

		public void add(byte c, int pos)
		{
			mStackPos--;
			int num = mStack[mStackPos];
			Node obj = mNodes[num];
			Node node = mNodes[2048 + c];
			obj.mNext = node.mNext;
			obj.mPrev = 2048 + c;
			obj.mPos = pos;
			mNodes[node.mNext].mPrev = num;
			node.mNext = num;
		}

		public void remove(byte c, int pos)
		{
			int mPrev = mNodes[2048 + c].mPrev;
			Node node = mNodes[mPrev];
			if (node.mPos != pos)
			{
				UnityEngine.Debug.LogError("n.mPos != pos");
			}
			mStack[mStackPos] = mNodes[node.mPrev].mNext;
			mStackPos++;
			mNodes[node.mPrev].mNext = node.mNext;
			mNodes[node.mNext].mPrev = node.mPrev;
		}

		public bool isEnd(int idx)
		{
			return idx >= 2048;
		}
	}

	private const int DIC_BITS = 11;

	private const int LENGTH_BITS = 4;

	private const int DIC_MASK = 2047;

	private const int DIC_MASK_HIGH = 1792;

	private const int DIC_MASK_SHIFTED = 112;

	private const int LENGTH_MASK = 15;

	private const int DIC_SIZE = 2048;

	private const int MAX_LENGTH = 18;

	public static byte[] Compress(byte[] bytes)
	{
		int num = bytes.Length;
		byte[] bytes2 = BitConverter.GetBytes(num);
		int num2 = bytes2.Length;
		byte[] array = new byte[num + num / 128 + 1];
		Compress(array, out var oSize, bytes);
		byte[] array2 = new byte[oSize + 4];
		Buffer.BlockCopy(bytes2, 0, array2, 0, num2);
		Buffer.BlockCopy(array, 0, array2, num2, oSize);
		return array2;
	}

	public static byte[] Decompress(byte[] bytes)
	{
		int oSize = BitConverter.ToInt32(bytes, 0);
		byte[] array = new byte[oSize];
		Decompress(array, out oSize, bytes);
		return array;
	}

	private static int min(int a, int b)
	{
		if (a >= b)
		{
			return b;
		}
		return a;
	}

	private static int max(int a, int b)
	{
		if (a <= b)
		{
			return b;
		}
		return a;
	}

	private static void Compress(byte[] oData, out int oSize, byte[] iData)
	{
		int num = iData.Length;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		Index index = new Index();
		while (num3 < num)
		{
			int num5 = 0;
			int num6 = 0;
			int num7 = min(18, num - num3);
			int num8 = index.getFirst(iData[num3]);
			while (!index.isEnd(num8))
			{
				Node node = index.getNode(num8);
				int mPos = node.mPos;
				int i;
				for (i = 1; i < num7 && iData[mPos + i] == iData[num3 + i]; i++)
				{
				}
				if (num5 < i)
				{
					num6 = mPos;
					num5 = i;
					if (num5 == num7)
					{
						break;
					}
				}
				num8 = node.mNext;
			}
			if (num5 >= 3)
			{
				for (int j = 0; j < num5; j++)
				{
					int num9 = num3 + j - 2048;
					if (num9 >= 0)
					{
						index.remove(iData[num9], num9);
					}
					index.add(iData[num3 + j], num3 + j);
				}
				if (num4 < num3)
				{
					oData[num2] = (byte)(num3 - num4 - 1);
					num2++;
					for (int k = num4; k < num3; k++)
					{
						oData[num2] = iData[k];
						num2++;
					}
				}
				int num10 = num5 - 3;
				int num11 = num3 - num6 - 1;
				int num12 = 0x80 | num10;
				num12 |= (num11 & 0x700) >> 4;
				oData[num2] = (byte)num12;
				oData[num2 + 1] = (byte)((uint)num11 & 0xFFu);
				num2 += 2;
				num3 += num5;
				num4 = num3;
				continue;
			}
			int num13 = num3 - 2048;
			if (num13 >= 0)
			{
				index.remove(iData[num13], num13);
			}
			index.add(iData[num3], num3);
			num3++;
			if (num3 - num4 == 128)
			{
				oData[num2] = (byte)(num3 - num4 - 1);
				num2++;
				for (int l = num4; l < num3; l++)
				{
					oData[num2] = iData[l];
					num2++;
				}
				num4 = num3;
			}
		}
		if (num4 < num3)
		{
			oData[num2] = (byte)(num3 - num4 - 1);
			num2++;
			for (int m = num4; m < num3; m++)
			{
				oData[num2] = iData[m];
				num2++;
			}
		}
		oSize = num2;
	}

	private static void Decompress(byte[] oData, out int oSize, byte[] iData)
	{
		int num = 0;
		int num2 = iData.Length;
		int num3;
		for (num3 = 4; num3 < num2; num3++)
		{
			int num4;
			if ((iData[num3] & 0x80u) != 0)
			{
				num4 = iData[num3] & 0xF;
				num4 += 3;
				int num5 = ((iData[num3] & 0x70) << 4) | iData[num3 + 1];
				num5++;
				for (int i = 0; i < num4; i++)
				{
					oData[num + i] = oData[num - num5 + i];
				}
				num3++;
			}
			else
			{
				num4 = iData[num3] + 1;
				for (int j = 0; j < num4; j++)
				{
					oData[num + j] = iData[num3 + 1 + j];
				}
				num3 += num4;
			}
			num += num4;
		}
		oSize = num;
	}
}
public class Crypt
{
	public static void EncryptXor(byte[] key, byte[] buffer)
	{
		EncryptXor(key, buffer, 0, buffer.Length);
	}

	public static void EncryptXor(byte[] key, byte[] buffer, int offset, int count)
	{
		if (key == null || key.Length == 0)
		{
			return;
		}
		int num = key.Length;
		for (int i = offset; i < offset + count; i++)
		{
			if (buffer[i] != 0)
			{
				byte b = key[i % num];
				buffer[i] ^= b;
				if (buffer[i] == 0)
				{
					buffer[i] = b;
				}
			}
		}
	}

	public static void DecryptXor(byte[] key, byte[] buffer)
	{
		DecryptXor(key, buffer, 0, buffer.Length);
	}

	public static void DecryptXor(byte[] key, byte[] buffer, int offset, int count)
	{
		if (key == null || key.Length == 0)
		{
			return;
		}
		int num = key.Length;
		for (int i = offset; i < offset + count; i++)
		{
			byte b = key[i % num];
			if (buffer[i] != 0 && buffer[i] != b)
			{
				buffer[i] ^= key[i % num];
			}
		}
	}
}
public class FileIOManager : FileIOManagerBase
{
	private byte[] cryptKeyBytes;

	[SerializeField]
	private string cryptKey = "InputOriginalKey";

	public byte[] CryptKeyBytes
	{
		get
		{
			if (cryptKeyBytes == null || cryptKeyBytes.Length == 0)
			{
				cryptKeyBytes = Encoding.UTF8.GetBytes(cryptKey);
			}
			return cryptKeyBytes;
		}
	}

	private void OnValidate()
	{
		cryptKeyBytes = Encoding.UTF8.GetBytes(cryptKey);
	}

	public override byte[] Decode(byte[] bytes)
	{
		return FileIOManagerBase.CustomDecode(CryptKeyBytes, bytes);
	}

	public override void DecodeNoCompress(byte[] bytes)
	{
		FileIOManagerBase.CustomDecodeNoCompress(CryptKeyBytes, bytes, 0, bytes.Length);
	}

	public override byte[] Encode(byte[] bytes)
	{
		return FileIOManagerBase.CustomEncode(CryptKeyBytes, bytes);
	}

	public override byte[] EncodeNoCompress(byte[] bytes)
	{
		int num = 0;
		do
		{
			int num2 = Math.Min(262144, bytes.Length - num);
			Buffer.BlockCopy(bytes, num, FileIOManagerBase.workBufferArray, 0, num2);
			FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, num2);
			Buffer.BlockCopy(FileIOManagerBase.workBufferArray, 0, bytes, num, num2);
			num += num2;
		}
		while (num < bytes.Length);
		return bytes;
	}

	public override bool Write(string path, byte[] bytes)
	{
		try
		{
			using (FileStream fileStream = new FileStream(path, FileMode.Create, FileAccess.Write))
			{
				int num = 0;
				do
				{
					int num2 = Math.Min(262144, bytes.Length - num);
					fileStream.Write(bytes, num, num2);
					num += num2;
				}
				while (num < bytes.Length);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.ToString());
			return false;
		}
	}

	public override bool ReadBinaryDecode(string path, Action<BinaryReader> callbackRead)
	{
		try
		{
			if (!Exists(path))
			{
				return false;
			}
			using (MemoryStream input = new MemoryStream(FileIOManagerBase.CustomDecode(CryptKeyBytes, FileReadAllBytes(path))))
			{
				using BinaryReader obj = new BinaryReader(input);
				callbackRead(obj);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogErrorFormat(this, "REALLY OOPS: '{1}' on read PATH = {0} ({2})", path, ex.GetType(), ex.Message);
			return false;
		}
	}

	public override bool WriteBinaryEncode(string path, Action<BinaryWriter> callbackWrite)
	{
		try
		{
			using (MemoryStream memoryStream = new MemoryStream())
			{
				using (BinaryWriter obj = new BinaryWriter(memoryStream))
				{
					callbackWrite(obj);
				}
				FileWriteAllBytes(path, FileIOManagerBase.CustomEncode(CryptKeyBytes, memoryStream.ToArray()));
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Error - Failed to write file, " + ex.ToString());
			return false;
		}
	}

	public override bool WriteEncode(string path, byte[] bytes)
	{
		try
		{
			FileWriteAllBytes(path, FileIOManagerBase.CustomEncode(CryptKeyBytes, bytes));
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError("Error - Failed to write file, " + ex.ToString());
			return false;
		}
	}

	public override bool WriteEncodeNoCompress(string path, byte[] bytes)
	{
		try
		{
			using (FileStream fileStream = new FileStream(path, FileMode.Create, FileAccess.Write))
			{
				int num = 0;
				do
				{
					int num2 = Math.Min(262144, bytes.Length - num);
					Buffer.BlockCopy(bytes, num, FileIOManagerBase.workBufferArray, 0, num2);
					FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, num2);
					fileStream.Write(FileIOManagerBase.workBufferArray, 0, num2);
					num += num2;
				}
				while (num < bytes.Length);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.ToString());
			return false;
		}
	}

	public override bool WriteSound(string path, AudioClip audioClip)
	{
		try
		{
			FileIOManagerBase.audioHeader[0] = audioClip.samples;
			FileIOManagerBase.audioHeader[2] = audioClip.frequency;
			FileIOManagerBase.audioHeader[1] = audioClip.channels;
			int num = audioClip.samples * audioClip.channels;
			using (FileStream fileStream = new FileStream(path, FileMode.Create, FileAccess.Write))
			{
				Buffer.BlockCopy(FileIOManagerBase.audioHeader, 0, FileIOManagerBase.workBufferArray, 0, 12);
				FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, 12);
				fileStream.Write(FileIOManagerBase.workBufferArray, 0, 12);
				int num2 = 0;
				do
				{
					int num3 = Math.Min(FileIOManagerBase.audioSamplesWorkArray.Length, num - num2);
					audioClip.GetData(FileIOManagerBase.audioSamplesWorkArray, num2 / audioClip.channels);
					for (int i = 0; i < num3; i++)
					{
						FileIOManagerBase.audioShortWorkArray[i] = (short)(32767f * FileIOManagerBase.audioSamplesWorkArray[i]);
					}
					int num4 = num3 * 2;
					Buffer.BlockCopy(FileIOManagerBase.audioShortWorkArray, 0, FileIOManagerBase.workBufferArray, 0, num4);
					FileIOManagerBase.CustomEncodeNoCompress(CryptKeyBytes, FileIOManagerBase.workBufferArray, 0, num4);
					fileStream.Write(FileIOManagerBase.workBufferArray, 0, num4);
					num2 += num3;
				}
				while (num2 < num);
			}
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.ToString());
			return false;
		}
	}

	public override bool CreateDirectory(string path)
	{
		string directoryName = System.IO.Path.GetDirectoryName(path);
		if (!Directory.Exists(directoryName))
		{
			Directory.CreateDirectory(directoryName);
			return true;
		}
		return false;
	}

	public override bool Exists(string path)
	{
		return File.Exists(path);
	}

	protected byte[] FileReadAllBytes(string path)
	{
		return File.ReadAllBytes(path);
	}

	protected void FileWriteAllBytes(string path, byte[] bytes)
	{
		File.WriteAllBytes(path, bytes);
	}

	public override void Delete(string path)
	{
		File.Delete(path);
	}
}
public abstract class FileIOManagerBase : MonoBehaviour
{
	protected enum SoundHeader
	{
		Samples,
		Channels,
		Frequency,
		Max
	}

	private const string sdkDirectoryName = "GameFile/";

	private static Func<byte[], byte[], byte[]> customEncode = DefaultEncode;

	private static Func<byte[], byte[], byte[]> customDecode = DefaultDecode;

	private static Action<byte[], byte[], int, int> customEncodeNoCompress = DefaultEncodeNoCompress;

	private static Action<byte[], byte[], int, int> customDecodeNoCompress = DefaultDecodeNoCompress;

	protected static int[] audioHeader = new int[3];

	protected const int audioHeaderSize = 12;

	protected const int maxWorkBufferSize = 262144;

	protected const int maxAudioWorkSize = 131072;

	protected static byte[] workBufferArray = new byte[262144];

	protected static short[] audioShortWorkArray = new short[131072];

	protected static float[] audioSamplesWorkArray = new float[131072];

	public static string SdkPersistentDataPath => FilePathUtil.Combine(UnityEngine.Application.persistentDataPath, "GameFile/");

	public static string SdkTemporaryCachePath => FilePathUtil.Combine(UnityEngine.Application.temporaryCachePath, "GameFile/");

	public static Func<byte[], byte[], byte[]> CustomEncode
	{
		get
		{
			return customEncode;
		}
		set
		{
			customEncode = value;
		}
	}

	public static Func<byte[], byte[], byte[]> CustomDecode
	{
		get
		{
			return customDecode;
		}
		set
		{
			customDecode = value;
		}
	}

	public static Action<byte[], byte[], int, int> CustomEncodeNoCompress
	{
		get
		{
			return customEncodeNoCompress;
		}
		set
		{
			customEncodeNoCompress = value;
		}
	}

	public static Action<byte[], byte[], int, int> CustomDecodeNoCompress
	{
		get
		{
			return customDecodeNoCompress;
		}
		set
		{
			customDecodeNoCompress = value;
		}
	}

	public static int ToMagicID(char id0, char id1, char id2, char id3)
	{
		return (int)(((uint)id3 << 24) + ((uint)id2 << 16) + ((uint)id1 << 8) + id0);
	}

	private static byte[] DefaultEncode(byte[] keyBytes, byte[] bytes)
	{
		byte[] array = Compression.Compress(bytes);
		Crypt.EncryptXor(keyBytes, array);
		return array;
	}

	private static byte[] DefaultDecode(byte[] keyBytes, byte[] bytes)
	{
		Crypt.DecryptXor(keyBytes, bytes);
		return Compression.Decompress(bytes);
	}

	private static void DefaultEncodeNoCompress(byte[] keyBytes, byte[] bytes, int offset, int count)
	{
		Crypt.EncryptXor(keyBytes, bytes, offset, count);
	}

	private static void DefaultDecodeNoCompress(byte[] keyBytes, byte[] bytes, int offset, int count)
	{
		Crypt.DecryptXor(keyBytes, bytes, offset, count);
	}

	public abstract byte[] Decode(byte[] bytes);

	public abstract void DecodeNoCompress(byte[] bytes);

	public abstract byte[] Encode(byte[] bytes);

	public abstract byte[] EncodeNoCompress(byte[] bytes);

	public abstract bool Write(string path, byte[] bytes);

	public abstract bool ReadBinaryDecode(string path, Action<BinaryReader> callbackRead);

	public abstract bool WriteBinaryEncode(string path, Action<BinaryWriter> callbackWrite);

	public abstract bool WriteEncode(string path, byte[] bytes);

	public abstract bool WriteEncodeNoCompress(string path, byte[] bytes);

	public abstract bool WriteSound(string path, AudioClip audioClip);

	public abstract bool CreateDirectory(string path);

	public abstract bool Exists(string path);

	public abstract void Delete(string path);
}
public class FilePathUtil
{
	public static string GetDirectoryNameOnly(string path)
	{
		return System.IO.Path.GetFileName(System.IO.Path.GetDirectoryName(path));
	}

	public static string GetDirectoryPath(string path)
	{
		int num = Mathf.Max(path.LastIndexOf('/'), path.LastIndexOf('\\'));
		if (num > 0)
		{
			path = path.Substring(0, num);
		}
		return path;
	}

	public static string Format(string path)
	{
		path = path.Replace("\\", "/");
		if (!path.Contains("://"))
		{
			path = path.Replace(":/", "://");
		}
		return path;
	}

	public static string GetFileName(string path)
	{
		return System.IO.Path.GetFileName(path);
	}

	public static string GetFileNameWithoutExtension(string path)
	{
		return System.IO.Path.GetFileNameWithoutExtension(path);
	}

	public static string GetPathWithoutExtension(string path)
	{
		int num = path.LastIndexOf('.');
		if (num > 0)
		{
			path = path.Substring(0, num);
		}
		return path;
	}

	public static string GetExtension(string path)
	{
		return System.IO.Path.GetExtension(path);
	}

	public static string ChangeExtension(string path, string extenstion)
	{
		return System.IO.Path.ChangeExtension(path, extenstion);
	}

	public static bool CheckExtention(string path, string ext)
	{
		return string.Compare(GetExtension(path), ext, ignoreCase: true) == 0;
	}

	public static bool CheckExtentionWithOutDouble(string path, string ext, string doubleExtension)
	{
		return CheckExtention(GetExtenstionWithOutDouble(path, doubleExtension), ext);
	}

	public static string GetExtenstionWithOutDouble(string path, string doubleExtension)
	{
		string extension = System.IO.Path.GetExtension(path);
		if (string.Compare(extension, doubleExtension, ignoreCase: true) != 0)
		{
			return extension;
		}
		path = path.Substring(0, path.Length - doubleExtension.Length);
		return System.IO.Path.GetExtension(path);
	}

	public static string AddDoubleExtensiton(string path, string doubleExtension)
	{
		if (!CheckExtention(path, doubleExtension))
		{
			path += doubleExtension;
		}
		return path;
	}

	public static string GetFileNameWithoutDoubleExtensiton(string path)
	{
		string fileNameWithoutExtension = System.IO.Path.GetFileNameWithoutExtension(path);
		if (fileNameWithoutExtension.Contains("."))
		{
			fileNameWithoutExtension = System.IO.Path.GetFileNameWithoutExtension(fileNameWithoutExtension);
		}
		return fileNameWithoutExtension;
	}

	public static bool IsAbsoluteUri(string path)
	{
		if (string.IsNullOrEmpty(path))
		{
			return false;
		}
		if (path.Length <= 1)
		{
			return false;
		}
		try
		{
			return new Uri(path, UriKind.RelativeOrAbsolute).IsAbsoluteUri;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(path + ":" + ex.Message);
			return false;
		}
	}

	public static string EncodeUrl(string url)
	{
		try
		{
			return new Uri(url.Replace('\\', '/')).AbsoluteUri;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(url + ":" + ex.Message);
			return url;
		}
	}

	public static string ToCacheClearUrl(string url)
	{
		return $"{url}?datetime={DateTime.Now.ToFileTime()}";
	}

	public static string ToStreamingAssetsUrl(string path)
	{
		if (UnityEngine.Application.platform == RuntimePlatform.Android)
		{
			return Combine(UnityEngine.Application.streamingAssetsPath, path);
		}
		return "file://" + Combine(UnityEngine.Application.streamingAssetsPath, path);
	}

	public static string Combine(params string[] args)
	{
		string text = "";
		foreach (string text2 in args)
		{
			if (!string.IsNullOrEmpty(text2))
			{
				text = System.IO.Path.Combine(text, text2);
			}
		}
		return text.Replace("\\", "/");
	}

	public static string RemoveDirectory(string path, string directoryPath)
	{
		path = Format(path);
		directoryPath = Format(directoryPath);
		if (!TryRemoveDirectory(path, directoryPath, out var newPath))
		{
			UnityEngine.Debug.LogError("RemoveDirectoryPath Error [" + path + "]  [" + directoryPath + "] ");
		}
		return newPath;
	}

	public static bool TryRemoveDirectory(string path, string directoryPath, out string newPath)
	{
		newPath = path;
		if (!path.StartsWith(directoryPath))
		{
			return false;
		}
		int num = directoryPath.Length;
		if (path.Length > num)
		{
			char c = path[num];
			if (c == '/' || c == '\\')
			{
				num++;
			}
		}
		newPath = path.Remove(0, num);
		return true;
	}

	internal static bool IsUnderDirectory(string path, string directoryPath)
	{
		path = Format(path);
		directoryPath = Format(directoryPath);
		return path.StartsWith(directoryPath);
	}
}
public class kageyamaDefine
{
	public enum AnimationIndex
	{
		KG_f011 = 10,
		KG_f012 = 11,
		KG_f013 = 12,
		KG_f014 = 13,
		SIZE = 4
	}
}
public class kamiyaDefine
{
	public enum AnimationIndex
	{
		KM_f021 = 20,
		SIZE = 1
	}
}
public class machikojiDefine
{
	public enum AnimationIndex
	{
		MC_059 = 58,
		SIZE = 1
	}
}
public class momonoDefine
{
	public enum AnimationIndex
	{
		MM_102 = 101,
		SIZE = 1
	}
}
public class morozumiDefine
{
	public enum AnimationIndex
	{
		MR_f012 = 11,
		MR_f013 = 12,
		MR_f014 = 13,
		MR_f015 = 14,
		SIZE = 4
	}
}
public class nikaidoDefine
{
	public enum AnimationIndex
	{
		NK_f015 = 14,
		NK_f016 = 15,
		NK_f017 = 16,
		SIZE = 3
	}
}
public class rouDefine
{
	public enum AnimationIndex
	{
		RU_f011 = 11,
		SIZE = 1
	}
}
public class sakuraiDefine
{
	public enum AnimationIndex
	{
		SK_060 = 58,
		SK_059 = 59,
		SIZE = 2
	}
}
public class togokuDefine
{
	public enum AnimationIndex
	{
		TG_f018 = 17,
		TG_f019 = 18,
		TG_f020 = 19,
		TG_f021 = 20,
		TG_f022 = 21,
		TG_f023 = 22,
		SIZE = 6
	}
}
public class AnimationController : MonoBehaviour
{
	private Animator animator;

	[SerializeField]
	private int animNum;

	private int lastNum;

	private void Start()
	{
		animator = GetComponentInChildren<Animator>();
		lastNum = 0;
	}

	private void Update()
	{
		if (animNum != lastNum)
		{
			animator.SetInteger("motion", animNum);
			animator.SetTrigger("startAnim");
			lastNum = animNum;
		}
	}

	public void SetAnimId(int id)
	{
		animNum = id;
	}
}
[ExecuteInEditMode]
public class AnimationUpdaterInEditor : MonoBehaviour
{
	private void Update()
	{
		UpdateAnimator();
	}

	private void OnGUI()
	{
		UpdateAnimator();
	}

	private void OnRenderObject()
	{
		UpdateAnimator();
	}

	private void UpdateAnimator()
	{
		base.transform.GetChild(0).GetComponent<Animator>().Update(1f);
	}
}
public class TextProFader : MonoBehaviour
{
	public float waitTime = 0.03f;

	public int omitLastNum;

	private TextMeshPro _textComponent;

	private bool _fading;

	private int _currentCharacter;

	private int _characterCount;

	private TMP_TextInfo _textInfo;

	private TMP_MeshInfo[] _cachedMeshInfo;

	private UnityAction _onEndAction;

	private IDisposable _currentFade;

	private Subject<Unit> _subjectBeforeFadeDelay = new Subject<Unit>();

	private Subject<Unit> _subjectStartFade = new Subject<Unit>();

	private Subject<Unit> _subjectEndFade = new Subject<Unit>();

	private Subject<Unit> _subjectTextChanged = new Subject<Unit>();

	private Func<IEnumerator> m_fadeEnumeratorFunction;

	private float m_fadeDelay;

	private Color32[] sourceVertexColors;

	private Color32[] newVertexColors;

	public IObservable<Unit> OnBeforeFadeDelay => _subjectBeforeFadeDelay;

	public IObservable<Unit> OnStartFade => _subjectStartFade;

	public IObservable<Unit> OnEndFade => _subjectEndFade;

	public IObservable<Unit> OnTextMeshChanged => _subjectTextChanged;

	public Vector3 LastCharacterPosition { get; private set; }

	public bool IsFinishedFade => _currentCharacter >= _characterCount - omitLastNum;

	private int RealCharacterCount => _characterCount - omitLastNum;

	private void Awake()
	{
		_textComponent = GetComponent<TextMeshPro>();
		_textInfo = _textComponent.textInfo;
		_currentCharacter = _textInfo.characterCount;
		TMPro_EventManager.TEXT_CHANGED_EVENT.Add(ON_TEXT_CHANGED);
		m_fadeEnumeratorFunction = () => RoutineTextFade();
	}

	private void OnDisable()
	{
		ForceEndFade();
	}

	private void OnDestroy()
	{
		if (_currentFade != null)
		{
			_currentFade.Dispose();
			_currentFade = null;
		}
		TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(ON_TEXT_CHANGED);
	}

	private void ON_TEXT_CHANGED(UnityEngine.Object obj)
	{
		if (obj == _textComponent)
		{
			OnChangeText();
		}
	}

	public void StartFade(float delay)
	{
		if (_currentFade != null)
		{
			_currentFade.Dispose();
			_currentFade = null;
		}
		_currentCharacter = 0;
		m_fadeDelay = delay;
		_currentFade = Observable.FromMicroCoroutine(m_fadeEnumeratorFunction).Subscribe();
	}

	private void ForceEndFade()
	{
		if (_currentFade != null)
		{
			_currentFade.Dispose();
			_currentFade = null;
		}
		if (_fading)
		{
			ProcessEndFade();
		}
	}

	private void UpdateCacheVertex()
	{
		_cachedMeshInfo = _textInfo.CopyMeshInfoVertexData();
		_characterCount = _textInfo.characterCount;
		UpdateLastCharacterPosition();
	}

	private void UpdateLastCharacterPosition()
	{
		int num = _textInfo.characterCount - 1;
		if (num < 0)
		{
			LastCharacterPosition = Vector2.zero;
			return;
		}
		Vector3 lastCharacterPosition = _textInfo.characterInfo[num].topLeft + _textInfo.characterInfo[num].topRight + _textInfo.characterInfo[num].bottomRight + _textInfo.characterInfo[num].bottomLeft;
		lastCharacterPosition /= 4f;
		LastCharacterPosition = lastCharacterPosition;
	}

	private void OnChangeText()
	{
		UpdateCacheVertex();
		ResetAllText();
		_subjectTextChanged.OnNext(Unit.Default);
	}

	private void ProcessEndFade()
	{
		_fading = false;
		_subjectEndFade.OnNext(Unit.Default);
	}

	private IEnumerator RoutineTextFade()
	{
		_ = (Color32)_textComponent.color;
		_fading = true;
		yield return null;
		ToggleAllText(flag: false);
		_subjectBeforeFadeDelay.OnNext(Unit.Default);
		float delayCount = m_fadeDelay;
		while (delayCount > 0f)
		{
			delayCount -= Time.deltaTime;
			yield return null;
		}
		_subjectStartFade.OnNext(Unit.Default);
		if (RealCharacterCount <= 0)
		{
			ProcessEndFade();
			yield break;
		}
		while (_currentCharacter < RealCharacterCount)
		{
			if (_textInfo.characterInfo[_currentCharacter].isVisible)
			{
				int materialReferenceIndex = _textInfo.characterInfo[_currentCharacter].materialReferenceIndex;
				int vertexIndex = _textInfo.characterInfo[_currentCharacter].vertexIndex;
				sourceVertexColors = _cachedMeshInfo[materialReferenceIndex].colors32;
				newVertexColors = _textInfo.meshInfo[materialReferenceIndex].colors32;
				Color32 color = sourceVertexColors[vertexIndex];
				newVertexColors[vertexIndex] = color;
				newVertexColors[vertexIndex + 1] = color;
				newVertexColors[vertexIndex + 2] = color;
				newVertexColors[vertexIndex + 3] = color;
				_textComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
			}
			_currentCharacter++;
			delayCount += waitTime;
			while (delayCount > 0f)
			{
				delayCount -= Time.deltaTime;
				yield return null;
			}
		}
		ProcessEndFade();
	}

	public void ToggleAllText(bool flag)
	{
		if (flag)
		{
			_currentCharacter = RealCharacterCount;
			ResetAllText();
			ForceEndFade();
		}
		else
		{
			_currentCharacter = 0;
			ResetAllText();
		}
	}

	private void ResetAllText()
	{
		Color32 color = _textComponent.color;
		for (int i = 0; i < _characterCount; i++)
		{
			if (_textInfo.characterInfo[i].isVisible)
			{
				int materialReferenceIndex = _textInfo.characterInfo[i].materialReferenceIndex;
				int vertexIndex = _textInfo.characterInfo[i].vertexIndex;
				newVertexColors = _textInfo.meshInfo[materialReferenceIndex].colors32;
				if (i < _currentCharacter)
				{
					sourceVertexColors = _cachedMeshInfo[materialReferenceIndex].colors32;
					color = sourceVertexColors[vertexIndex];
				}
				else
				{
					color = new Color32(0, 0, 0, 0);
				}
				newVertexColors[vertexIndex] = color;
				newVertexColors[vertexIndex + 1] = color;
				newVertexColors[vertexIndex + 2] = color;
				newVertexColors[vertexIndex + 3] = color;
				_textComponent.UpdateVertexData(TMP_VertexDataUpdateFlags.Colors32);
			}
		}
	}
}
public class DebugLogger : MonoBehaviour
{
	[Header("Prefabs")]
	[SerializeField]
	private DebugLogComponent _prefabLogComponent;

	[Header("Components")]
	[SerializeField]
	private Canvas m_canvas;

	[SerializeField]
	private RectTransform _logParent;

	[Header("Parameters - Text")]
	[SerializeField]
	private int m_maxLines = 10;

	[SerializeField]
	private float m_DecayPower = 0.92f;

	[Header("Parameters - Type Settings")]
	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private bool[] m_showFlags;

	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private Color[] m_typeColor;

	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private bool[] m_typeIsBold;

	[SerializeField]
	[EnumLabel(typeof(LogType))]
	private Sprite[] m_typeSprite;

	private Stack<DebugLogComponent> _unusedObjects = new Stack<DebugLogComponent>();

	private LinkedList<DebugLogComponent> _logObjects = new LinkedList<DebugLogComponent>();

	private int _logCount;

	public bool IsVisible { get; set; }

	public Color GetTypeColor(LogType tp)
	{
		return m_typeColor[(int)tp];
	}

	public bool GetTypeBold(LogType tp)
	{
		return m_typeIsBold[(int)tp];
	}

	public Sprite GetTypeSprite(LogType tp)
	{
		return m_typeSprite[(int)tp];
	}

	private void Awake()
	{
		UnityEngine.Application.logMessageReceived += OnLogMessage;
	}

	private void OnDestroy()
	{
		UnityEngine.Application.logMessageReceived -= OnLogMessage;
	}

	private void OnLogMessage(string text, string stackTrace, LogType type)
	{
		Observable.NextFrame().Subscribe(delegate
		{
			OutputLogMessage(text, stackTrace, type);
		});
	}

	private void OutputLogMessage(string text, string stackTrace, LogType type)
	{
		if (!m_showFlags[(int)type])
		{
			return;
		}
		if (_logCount > 0)
		{
			DebugLogComponent value = _logObjects.Last.Value;
			value.DecayAlpha(m_DecayPower);
			if (type == value.DisplayType && text == value.DisplayText)
			{
				value.StackCount();
				return;
			}
		}
		DebugLogComponent debugLogComponent = FindUnusedOrInstantiate();
		debugLogComponent.Init(this, text, stackTrace, type);
		_logObjects.AddLast(debugLogComponent);
		_logCount++;
		OmitOverflow();
	}

	private DebugLogComponent FindUnusedOrInstantiate()
	{
		if (_unusedObjects.Count <= 0)
		{
			return UnityEngine.Object.Instantiate(_prefabLogComponent, _logParent, worldPositionStays: false);
		}
		DebugLogComponent debugLogComponent = _unusedObjects.Pop();
		debugLogComponent.gameObject.SetActive(value: true);
		debugLogComponent.transform.SetSiblingIndex(99);
		return debugLogComponent;
	}

	private void OmitOverflow()
	{
		int num = _logCount - m_maxLines;
		if (num > 0)
		{
			for (int i = 0; i < num; i++)
			{
				DebugLogComponent value = _logObjects.First.Value;
				value.gameObject.SetActive(value: false);
				_unusedObjects.Push(value);
				_logObjects.RemoveFirst();
				_logCount--;
			}
		}
	}

	public void ToggleVisible(bool flag)
	{
		IsVisible = flag;
		m_canvas.enabled = flag;
		_logParent.gameObject.SetActive(flag);
	}
}
public class DebugMemory : MonoBehaviour
{
	[SerializeField]
	private TextMeshProUGUI m_unityMemoryText;

	public bool IsVisible { get; set; }

	private void Update()
	{
		long monoUsedSizeLong = Profiler.GetMonoUsedSizeLong();
		long monoHeapSizeLong = Profiler.GetMonoHeapSizeLong();
		long totalAllocatedMemoryLong = Profiler.GetTotalAllocatedMemoryLong();
		long totalReservedMemoryLong = Profiler.GetTotalReservedMemoryLong();
		m_unityMemoryText.text = $"mono:{monoUsedSizeLong / 1024}/{monoHeapSizeLong / 1024} kb({100.0 * (double)monoUsedSizeLong / (double)monoHeapSizeLong:f1}%)\ntotal:{totalAllocatedMemoryLong / 1024}/{totalReservedMemoryLong / 1024} kb({100.0 * (double)totalAllocatedMemoryLong / (double)totalReservedMemoryLong:f1}%)";
	}

	public void ToggleVisible(bool flag)
	{
		IsVisible = flag;
		base.enabled = flag;
		m_unityMemoryText.enabled = flag;
	}
}
public class DebugLogComponent : MonoBehaviour
{
	[SerializeField]
	private CanvasGroup _group;

	[SerializeField]
	private Image _icon;

	[SerializeField]
	private TextMeshProUGUI _textHeader;

	[SerializeField]
	private TextMeshProUGUI _textMini;

	[SerializeField]
	private TextMeshProUGUI _textBadge;

	private int _stackCount = 1;

	private string _text;

	private LogType _type;

	private IObservable<int> _onChangeBadge;

	public string DisplayText => _text;

	public LogType DisplayType => _type;

	public void Init(DebugLogger parent, string text, string stackTrace, LogType type)
	{
		Color typeColor = parent.GetTypeColor(type);
		bool typeBold = parent.GetTypeBold(type);
		_textHeader.text = text;
		_textHeader.color = typeColor;
		if (typeBold)
		{
			_textHeader.fontStyle = FontStyles.Bold;
		}
		else
		{
			_textHeader.fontStyle = FontStyles.Normal;
		}
		string value = stackTrace;
		if (string.IsNullOrEmpty(value))
		{
			_textMini.gameObject.SetActive(value: false);
		}
		else
		{
			value = GetFirstStackTrace(stackTrace);
			_textMini.gameObject.SetActive(value: true);
			_textMini.text = value;
			_textMini.color = typeColor;
		}
		_icon.sprite = parent.GetTypeSprite(type);
		_text = text;
		_type = type;
		_stackCount = 1;
		SetAlpha(1f);
		MakeObservable();
	}

	private void MakeObservable()
	{
		if (_onChangeBadge == null)
		{
			_onChangeBadge = this.ObserveEveryValueChanged((DebugLogComponent x) => x._stackCount);
			_onChangeBadge.Subscribe(delegate(int cnt)
			{
				UpdateBadge(cnt);
			});
		}
	}

	private string GetFirstStackTrace(string trace)
	{
		string[] array = trace.Split('\n');
		if (array.Length <= 1)
		{
			return trace;
		}
		string text = "";
		for (int i = 0; i < 2; i++)
		{
			if (i != 0 || !Regex.Match(array[i], "^UnityEngine\\.Debug").Success)
			{
				if (!string.IsNullOrEmpty(text))
				{
					text += Environment.NewLine;
				}
				Match match = Regex.Match(array[i], ".+[.:](.+) \\(at .+/(.+):(.+)\\)");
				if (match.Success)
				{
					text += $"  Src: <b>{match.Groups[2].Value}</b> / Func: <b>{match.Groups[1].Value}</b> / Line: <b>{match.Groups[3].Value}</b>";
					break;
				}
				text += array[i];
			}
		}
		return text;
	}

	public void StackCount()
	{
		_stackCount++;
	}

	private void UpdateBadge(int cnt)
	{
		if (cnt < 2)
		{
			_textBadge.text = "";
			return;
		}
		if (cnt > 99)
		{
			_textBadge.text = "99+";
			return;
		}
		_textBadge.text = cnt.ToString();
		SetAlpha(1f);
	}

	public void SetAlpha(float a)
	{
		_group.alpha = a;
	}

	public void DecayAlpha(float pow)
	{
		_group.alpha *= pow;
	}
}
public class DemoTimeChecker
{
	public static readonly DateTime m_startTime = new DateTime(2018, 10, 22, 20, 0, 0);

	public static readonly DateTime m_deadline = new DateTime(2018, 10, 23, 1, 0, 0);

	public static bool IsValid()
	{
		DateTime now = DateTime.Now;
		if (now <= m_deadline)
		{
			return now >= m_startTime;
		}
		return false;
	}

	public static bool IsBeforeStart()
	{
		return DateTime.Now < m_startTime;
	}

	public static bool IsAfterDeadline()
	{
		return DateTime.Now > m_deadline;
	}
}
public static class DefineValue
{
}
public static class KeyDefine
{
	public const string Horizontal = "Horizontal";

	public const string Vertical = "Vertical";

	public const string TriggerLeft = "TriggerLeft";

	public const string TriggerRight = "TriggerRight";

	public const string Button1 = "Button1";

	public const string MouseX = "Mouse X";

	public const string MouseY = "Mouse Y";

	public const string MouseScrollWheel = "Mouse ScrollWheel";

	public const string HorizontalLeft = "HorizontalLeft";

	public const string VerticalLeft = "VerticalLeft";

	public const string StickPushLeft = "StickPushLeft";

	public const string StickPushRight = "StickPushRight";

	public const string Button2 = "Button2";

	public const string Button3 = "Button3";

	public const string Button4 = "Button4";

	public const string ButtonStart = "ButtonStart";

	public const string Escape = "Escape";
}
public static class LayerDefine
{
	public const string Default = "Default";

	public const string TransparentFX = "TransparentFX";

	public const string IgnoreRaycast = "Ignore Raycast";

	public const string Water = "Water";

	public const string UI = "UI";

	public const string RayTarget = "RayTarget";

	public const string Chara = "Chara";

	public const string Environment = "Environment";

	public const string SelectionTarget = "SelectionTarget";

	public const string MirrorChara = "MirrorChara";

	public const string MirrorOnly = "MirrorOnly";

	public const string BokeSphere = "BokeSphere";

	public const string ImportantProp = "ImportantProp";
}
public enum SceneDefine
{
	SplashScreen,
	Title,
	Permanent,
	MainMenu,
	InGame,
	AdvBoot,
	Memory,
	ChangeChara,
	Backstreet,
	Crossing,
	TownA,
	TownB,
	Building,
	BuildingRoof,
	ConvinientStore,
	FancyShop,
	HotelRoom,
	EndProto,
	Flashback,
	SchoolRoof,
	TownC,
	BuildingF,
	MainTitle,
	Debug,
	CrossingEvening,
	CrossingNight,
	BackstreetEvening,
	BuildingNight,
	BuildingFNight,
	TougokuLivingNight,
	Bookstore,
	HotelNight,
	HotelNightLight,
	TownTougoku,
	Blank,
	EndOfChapter,
	TownANight,
	TougokuLiving,
	PlayDome,
	Uyuni,
	TougokuLibrary,
	ShibuyaRoad,
	BuildingStairs,
	ThemePark,
	TheBeginning,
	StartOfChapter,
	BuildingRoofMono,
	BuildingsElevatorHall,
	TougokuLibraryEvening,
	TougokuLibraryNight,
	BuildingRoofCrack,
	Opening,
	OpeningSecond,
	MMEnding,
	TGEnding,
	KGEnding,
	MZEnding,
	MCEnding,
	Ending,
	aTitleBack,
	bTitleBack,
	cTitleBack,
	BuildingRoofCatScene,
	SchoolRoofMono,
	FusionCatScene,
	EndingSecond,
	Dream
}
public static class SceneNameDefine
{
	public static string[] Names = new string[67]
	{
		"SplashScreen", "Title", "000Permanent", "001MainMenu", "002InGame", "010AdvBoot", "011Memory", "012ChangeChara", "100Backstreet", "110Crossing",
		"120TownA", "130TownB", "200Building", "210BuildingRoof", "300ConvinientStore", "310FancyShop", "320HotelRoom", "EndProto", "003Flashback", "500SchoolRoof",
		"140TownC", "220Building8F", "020MainTitle", "004Debug", "111CrossingEvening", "112CrossingNight", "101BackstreetEvening", "202BuildingNight", "222Building8FNight", "352TougokuLivingNight",
		"360Bookstore", "322HotelNight", "323HotelNightLight", "150TownTougoku", "021Blank", "022EndOfChapter", "122TownANight", "350TougokuLiving", "370PlayDome", "400Uyuni",
		"340TougokuLibrary", "160ShibuyaRoad", "230BuildingStairs", "380ThemePark", "099TheBeginning", "023StartOfChapter", "213BuildingRoofMono", "240BuildingsElevatorHall", "341TougokuLibraryEvening", "342TougokuLibraryNight",
		"214BuildingRoofCrack", "Opening", "OpeningSecond", "MMEnding", "TGEnding", "KGEnding", "MZEnding", "MCEnding", "024Ending1", "020aTitleBack1",
		"020bTitleBack2", "020cTitleBack3", "215BuildingRoofCatScene", "501SchoolRoofMono", "FusionCatScene", "025EndingSecond", "410Dream"
	};
}
public static class TagDefine
{
	public const string Untagged = "Untagged";

	public const string Respawn = "Respawn";

	public const string Finish = "Finish";

	public const string EditorOnly = "EditorOnly";

	public const string MainCamera = "MainCamera";

	public const string Player = "Player";

	public const string GameController = "GameController";
}
[Serializable]
public class FadeCatSceneBehaviour : PlayableBehaviour
{
	public Color StartColor = new Color(0f, 0f, 0f, 1f);

	public Color EndColor = new Color(0f, 0f, 0f, 0f);

	public override void OnPlayableCreate(Playable playable)
	{
	}
}
[Serializable]
public class FadeCatSceneClip : PlayableAsset, ITimelineClipAsset
{
	public FadeCatSceneBehaviour template = new FadeCatSceneBehaviour();

	public ClipCaps clipCaps => ClipCaps.Blending;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<FadeCatSceneBehaviour>.Create(graph, template);
	}
}
public class FadeCatSceneMixerBehaviour : PlayableBehaviour
{
	private UIFader m_TrackBinding;

	private Color start = new Color(0f, 0f, 0f, 1f);

	private Color end = new Color(0f, 0f, 0f, 1f);

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		m_TrackBinding = playerData as UIFader;
		if (m_TrackBinding == null)
		{
			return;
		}
		int inputCount = playable.GetInputCount();
		float t = 0f;
		bool flag = false;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScriptPlayable<FadeCatSceneBehaviour> playable2 = (ScriptPlayable<FadeCatSceneBehaviour>)playable.GetInput(i);
			FadeCatSceneBehaviour behaviour = playable2.GetBehaviour();
			if (inputWeight == 1f)
			{
				flag = true;
				t = (float)playable2.GetTime() / (float)playable2.GetDuration();
				start = behaviour.StartColor;
				end = behaviour.EndColor;
			}
		}
		if (!flag)
		{
			t = 1f;
		}
		m_TrackBinding.SetColour(Color.Lerp(start, end, t));
	}
}
[TrackColor(0f, 0.5f, 1f)]
[TrackClipType(typeof(FadeCatSceneClip))]
[TrackBindingType(typeof(UIFader))]
public class FadeCatSceneTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<FadeCatSceneMixerBehaviour>.Create(graph, inputCount);
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		base.GatherProperties(director, driver);
	}
}
[Serializable]
public class FadeObjectBehaviour : PlayableBehaviour
{
	public enum FadeType
	{
		fadein,
		fadeout
	}

	public FadeType mFadeType;

	public override void OnPlayableCreate(Playable playable)
	{
	}
}
[Serializable]
public class FadeObjectClip : PlayableAsset, ITimelineClipAsset
{
	public FadeObjectBehaviour template = new FadeObjectBehaviour();

	public ClipCaps clipCaps => ClipCaps.None;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<FadeObjectBehaviour>.Create(graph, template);
	}
}
public class FadeObjectMixerBehaviour : PlayableBehaviour
{
	protected List<Material> m_materials = new List<Material>();

	protected List<Material> m_originalMaterials = new List<Material>();

	private float alphaWaight;

	private FadeObjectBehaviour.FadeType LastFadeType = FadeObjectBehaviour.FadeType.fadeout;

	private Renderer[] m_renderers;

	protected const string _PARAM_ALPHA = "_Alpha";

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		GameObject gameObject = playerData as GameObject;
		if (!gameObject)
		{
			return;
		}
		if (m_materials.Count == 0)
		{
			m_renderers = gameObject.GetComponentsInChildren<Renderer>();
			AddMaterials(m_renderers);
		}
		int inputCount = playable.GetInputCount();
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < inputCount; i++)
		{
			float inputWeight = playable.GetInputWeight(i);
			ScriptPlayable<FadeObjectBehaviour> playable2 = (ScriptPlayable<FadeObjectBehaviour>)playable.GetInput(i);
			FadeObjectBehaviour behaviour = playable2.GetBehaviour();
			float num3 = (float)playable2.GetTime() / (float)playable2.GetDuration();
			num += ((behaviour.mFadeType == FadeObjectBehaviour.FadeType.fadein) ? num3 : (1f - num3)) * inputWeight;
			if (inputWeight == 1f)
			{
				LastFadeType = behaviour.mFadeType;
			}
			num2 += inputWeight;
		}
		if (num2 == 0f)
		{
			num = ((LastFadeType == FadeObjectBehaviour.FadeType.fadein) ? 1 : 0);
		}
		int count = m_materials.Count;
		for (int j = 0; j < count; j++)
		{
			m_materials[j].SetFloat("_Alpha", num);
		}
	}

	private void AddMaterials(Renderer[] renderers)
	{
		foreach (Renderer renderer in renderers)
		{
			Material[] sharedMaterials = renderer.sharedMaterials;
			Material[] array = new Material[sharedMaterials.Length];
			for (int j = 0; j < sharedMaterials.Length; j++)
			{
				Material material = sharedMaterials[j];
				int num = m_originalMaterials.IndexOf(material);
				Material material2 = null;
				if (num < 0)
				{
					m_originalMaterials.Add(material);
					material2 = new Material(material);
					m_materials.Add(material2);
				}
				else
				{
					material2 = m_materials[num];
				}
				array[j] = material2;
			}
			renderer.materials = array;
		}
	}
}
[TrackColor(0f, 0.5f, 1f)]
[TrackClipType(typeof(FadeObjectClip))]
[TrackBindingType(typeof(GameObject))]
public class FadeObjectTrack : TrackAsset
{
	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return ScriptPlayable<FadeObjectMixerBehaviour>.Create(graph, inputCount);
	}
}
public class DisableOnStart : MonoBehaviour
{
	[SerializeField]
	private bool m_isDisableOnFirstUpdate;

	private GameObject m_gameObject;

	private void Start()
	{
		m_gameObject = base.gameObject;
		if (!m_isDisableOnFirstUpdate)
		{
			SetActive();
		}
	}

	private void SetActive(bool isActive = false)
	{
		m_gameObject.SetActive(isActive);
		base.enabled = isActive;
	}

	private void Update()
	{
		if (m_isDisableOnFirstUpdate)
		{
			SetActive();
		}
	}
}
namespace UTJ
{
	[Serializable]
	public class AngleLimits
	{
		public bool active;

		[Range(-180f, 0f)]
		public float min;

		[Range(0f, 180f)]
		public float max;

		public static Vector3 GetAngleVector(Vector3 sideVector, Vector3 forwardVector, float degrees)
		{
			float f = (float)Math.PI / 180f * degrees;
			Vector3 a = Vector3Extension.Multiply(ref sideVector, Mathf.Sin(f));
			Vector3 b = Vector3Extension.Multiply(ref forwardVector, Mathf.Cos(f));
			return Vector3Extension.Add(ref a, ref b);
		}

		public void CopyTo(AngleLimits target)
		{
			target.active = active;
			target.min = min;
			target.max = max;
		}

		private static float ComputeFalloff(float value, float range)
		{
			if (MathHelper.Abs(ref range) <= 0.0001f)
			{
				return 0f;
			}
			float num = Mathf.Clamp01(value / range);
			return Mathf.Min(num, (float)Math.Sqrt(num));
		}

		public bool ConstrainVector(ref Vector3 basisSide, ref Vector3 basisUp, ref Vector3 basisForward, float springStrength, float deltaTime, ref Vector3 vector)
		{
			Vector3 b = Vector3Extension.Project(ref vector, ref basisUp);
			Vector3 a = Vector3Extension.Subtract(ref vector, ref b);
			float num = a.Length();
			Vector3 lhs = Vector3Extension.Divide(ref a, num);
			float value = Vector3Extension.DotProduct(ref lhs, ref basisSide);
			value = Mathf.Clamp(value, -1f, 1f);
			float num2 = 57.29578f * Mathf.Asin(value);
			float num3 = (0f - num2) * springStrength;
			num2 += num3 * deltaTime * deltaTime;
			float num4 = min;
			float num5 = max;
			float num6 = num2;
			num2 = Mathf.Clamp(num2, num4, num5);
			float num7 = ((num2 < 0f) ? num4 : num5);
			num2 = ComputeFalloff(num2, num7) * num7;
			float f = (float)Math.PI / 180f * num2;
			Vector3 a2 = Vector3Extension.Multiply(ref basisSide, Mathf.Sin(f));
			Vector3 b2 = Vector3Extension.Multiply(ref basisForward, Mathf.Cos(f));
			Vector3 target = Vector3Extension.Add(ref a2, ref b2);
			Vector3Extension.MultiplyTarget(num, ref target);
			Vector3Extension.Add(ref target, ref b, out vector);
			return num2 != num6;
		}
	}
	public struct Circle3
	{
		public Vector3 origin;

		public Vector3 upVector;

		public float radius;
	}
	public class SpringCapsuleCollider : MonoBehaviour
	{
		public float radius = 0.075f;

		public float height = 0.3f;

		public Renderer linkedRenderer;

		public Transform MyTransform;

		private void Start()
		{
			MyTransform = base.transform;
		}

		public SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 moverHeadPosition, ref Vector3 moverPosition, float moverRadius, ref Vector3 hitNormal)
		{
			if (radius <= 0.0001f)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			Matrix4x4 worldToLocalMatrix = MyTransform.worldToLocalMatrix;
			float num = worldToLocalMatrix.MultiplyVector(ref Vector3Extension.Right).Length();
			Vector3 localHeadPosition = worldToLocalMatrix.MultiplyPoint3x4(ref moverHeadPosition);
			Vector3 localSpherePosition = worldToLocalMatrix.MultiplyPoint3x4(ref moverPosition);
			float num2 = moverRadius * num;
			bool flag = localSpherePosition.y >= height;
			if (localSpherePosition.y <= 0f || flag)
			{
				Vector3 b = new Vector3(0f, flag ? height : 0f, 0f);
				float num3 = num2 + radius;
				if (Vector3Extension.DistanceSquared(ref localSpherePosition, ref b) >= num3 * num3)
				{
					return SpringBone.CollisionStatus.NoCollision;
				}
				if (Vector3Extension.DistanceSquared(ref localHeadPosition, ref b) <= radius * radius)
				{
					Vector3 a = Vector3Extension.Direction(ref localSpherePosition, ref b);
					Vector3 a2 = Vector3Extension.Multiply(ref a, num3);
					Vector3Extension.Add(ref a2, ref b, out localSpherePosition);
					moverPosition = MyTransform.TransformPoint(localSpherePosition);
					hitNormal = MyTransform.TransformDirection(a);
					Vector3Extension.Normalize(ref hitNormal);
					return SpringBone.CollisionStatus.HeadIsEmbedded;
				}
				float radiusA = Vector3Extension.Distance(ref localSpherePosition, ref localHeadPosition);
				Circle3 intersection = default(Circle3);
				if (SpringSphereCollider.ComputeIntersection(ref localHeadPosition, radiusA, ref b, num3, ref intersection))
				{
					localSpherePosition = SpringSphereCollider.ComputeNewTailPosition(ref intersection, ref localSpherePosition);
					moverPosition = MyTransform.TransformPoint(localSpherePosition);
					Vector3 direction = Vector3Extension.Direction(ref localSpherePosition, ref b);
					hitNormal = MyTransform.TransformDirection(direction);
					Vector3Extension.Normalize(ref hitNormal);
				}
				return SpringBone.CollisionStatus.TailCollision;
			}
			return CheckForCylinderCollisionAndReact(ref localHeadPosition, ref moverPosition, num2, ref localSpherePosition, ref hitNormal);
		}

		private SpringBone.CollisionStatus CheckForCylinderCollisionAndReact(ref Vector3 localHeadPosition, ref Vector3 worldMoverPosition, float localMoverRadius, ref Vector3 localSpherePosition, ref Vector3 hitNormal)
		{
			Vector2 vector = new Vector2(localSpherePosition.x, localSpherePosition.z);
			float num = radius + localMoverRadius;
			SpringBone.CollisionStatus result = SpringBone.CollisionStatus.NoCollision;
			if (vector.sqrMagnitude <= num * num)
			{
				Vector2 normalized = vector.normalized;
				vector = num * normalized;
				Vector3 position = new Vector3(vector.x, localSpherePosition.y, vector.y);
				worldMoverPosition = MyTransform.TransformPoint(position);
				hitNormal = MyTransform.TransformDirection(new Vector3(normalized.x, 0f, normalized.y));
				Vector3Extension.Normalize(ref hitNormal);
				result = ((new Vector2(localHeadPosition.x, localHeadPosition.z).sqrMagnitude <= radius * radius) ? SpringBone.CollisionStatus.HeadIsEmbedded : SpringBone.CollisionStatus.TailCollision);
			}
			return result;
		}
	}
	public class SpringPanelCollider : MonoBehaviour
	{
		public enum Axis
		{
			X,
			Y,
			Z,
			AxisCount
		}

		public float width = 0.25f;

		public float height = 0.25f;

		public Renderer linkedRenderer;

		public Vector3 GetPlaneNormal()
		{
			return base.transform.forward;
		}

		public SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 headPosition, float length, ref Vector3 tailPosition, float tailRadius, ref Vector3 hitNormal)
		{
			if (linkedRenderer != null && !linkedRenderer.enabled)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			Vector3 localTailPosition = base.transform.InverseTransformPoint(tailPosition);
			float magnitude = base.transform.InverseTransformDirection(tailRadius, 0f, 0f).magnitude;
			if (localTailPosition.z >= magnitude)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			Vector3 localHeadPosition = base.transform.InverseTransformPoint(headPosition);
			float magnitude2 = base.transform.InverseTransformDirection(length, 0f, 0f).magnitude;
			float num = 0.5f * width;
			float num2 = 0.5f * height;
			float num3 = num + magnitude;
			float num4 = num2 + magnitude;
			if (Mathf.Abs(localTailPosition.y) >= num4 || Mathf.Abs(localTailPosition.x) >= num3)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			SpringBone.CollisionStatus collisionStatus = SpringBone.CollisionStatus.TailCollision;
			if (localHeadPosition.z <= 0f && localTailPosition.z <= 0f)
			{
				if (Mathf.Abs(localHeadPosition.y) > num2)
				{
					num2 = ((localTailPosition.y < 0f) ? (0f - num2) : num2);
					localTailPosition = new Vector3(localTailPosition.x, num2, localTailPosition.z);
				}
				else if (Mathf.Abs(localHeadPosition.x) > num)
				{
					num = ((localTailPosition.x < 0f) ? (0f - num) : num);
					localTailPosition = new Vector3(num, localTailPosition.y, localTailPosition.z);
				}
				else
				{
					collisionStatus = SpringBone.CollisionStatus.HeadIsEmbedded;
					localTailPosition = localHeadPosition;
					localTailPosition.z = magnitude;
				}
			}
			else if (Mathf.Abs(localTailPosition.y) > num2)
			{
				num2 = ((localTailPosition.y < 0f) ? (0f - num2) : num2);
				Vector3 normalized = new Vector3(0f, localTailPosition.y - num2, localTailPosition.z).normalized;
				localTailPosition = new Vector3(localTailPosition.x, num2, 0f) + magnitude * normalized;
			}
			else if (Mathf.Abs(localTailPosition.x) > num)
			{
				num = ((localTailPosition.x < 0f) ? (0f - num) : num);
				Vector3 normalized2 = new Vector3(localTailPosition.x - num, 0f, localTailPosition.z).normalized;
				localTailPosition = new Vector3(num, localTailPosition.y, 0f) + magnitude * normalized2;
			}
			else
			{
				collisionStatus = CheckForCollisionWithAlignedPlaneAndReact(ref localHeadPosition, magnitude2, ref localTailPosition, magnitude, Axis.Z);
			}
			if (collisionStatus != 0)
			{
				tailPosition = base.transform.TransformPoint(localTailPosition);
				hitNormal = base.transform.forward.normalized;
			}
			return collisionStatus;
		}

		public static SpringBone.CollisionStatus CheckForCollisionWithAlignedPlaneAndReact(ref Vector3 localHeadPosition, float localLength, ref Vector3 localTailPosition, float localTailRadius, Axis upAxis)
		{
			if (localTailPosition[(int)upAxis] >= localTailRadius)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			SpringBone.CollisionStatus result = SpringBone.CollisionStatus.TailCollision;
			Vector3 vector = localHeadPosition;
			if (localHeadPosition[(int)upAxis] + localLength <= localTailRadius)
			{
				vector[(int)upAxis] += localLength;
				result = SpringBone.CollisionStatus.HeadIsEmbedded;
			}
			else
			{
				int index = (int)(upAxis + 1) % 3;
				int index2 = (int)(upAxis + 2) % 3;
				float num = localHeadPosition[(int)upAxis] - localTailRadius;
				float num2 = Mathf.Sqrt(localLength * localLength - num * num);
				Vector3 vector2 = Vector3Extension.Subtract(ref localTailPosition, ref localHeadPosition);
				Vector2 vector3 = new Vector2(vector2[index], vector2[index2]);
				float magnitude = vector3.magnitude;
				if (magnitude > 0.001f)
				{
					Vector2 vector4 = num2 / magnitude * vector3;
					vector[index] += vector4.x;
					vector[index2] += vector4.y;
					vector[(int)upAxis] = localTailRadius;
				}
			}
			localTailPosition = vector;
			return result;
		}
	}
	public class SpringSphereCollider : MonoBehaviour
	{
		private Vector3 m_localOrigin = Vector3.zero;

		public float radius = 0.1f;

		public Renderer linkedRenderer;

		public Transform MyTransform;

		private void Start()
		{
			MyTransform = base.transform;
		}

		public SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 headPosition, ref Vector3 tailPosition, float tailRadius, ref Vector3 hitNormal)
		{
			Vector3 localHeadPosition = MyTransform.InverseTransformPoint(headPosition);
			Vector3 localTailPosition = MyTransform.InverseTransformPoint(tailPosition);
			float localTailRadius = MyTransform.InverseTransformDirection(tailRadius, 0f, 0f).Length();
			SpringBone.CollisionStatus num = CheckForCollisionAndReact(ref localHeadPosition, ref localTailPosition, localTailRadius, ref m_localOrigin, radius);
			if (num != 0)
			{
				tailPosition = MyTransform.TransformPoint(localTailPosition);
				Vector3Extension.Normalize(ref localTailPosition);
				hitNormal = MyTransform.TransformDirection(localTailPosition);
				Vector3Extension.Normalize(ref hitNormal);
			}
			return num;
		}

		public static SpringBone.CollisionStatus CheckForCollisionAndReact(ref Vector3 localHeadPosition, ref Vector3 localTailPosition, float localTailRadius, ref Vector3 sphereLocalOrigin, float sphereRadius)
		{
			float num = sphereRadius + localTailRadius;
			if (Vector3Extension.DistanceSquared(ref localTailPosition, ref sphereLocalOrigin) >= num * num)
			{
				return SpringBone.CollisionStatus.NoCollision;
			}
			if (Vector3Extension.DistanceSquared(ref localHeadPosition, ref sphereLocalOrigin) >= sphereRadius * sphereRadius)
			{
				Vector3 target = Vector3Extension.Direction(ref localTailPosition, ref sphereLocalOrigin);
				Vector3Extension.MultiplyTarget(num, ref target);
				Vector3Extension.Add(ref sphereLocalOrigin, ref target, out localTailPosition);
				return SpringBone.CollisionStatus.HeadIsEmbedded;
			}
			float radiusA = Vector3Extension.Distance(ref localTailPosition, ref localHeadPosition);
			Circle3 intersection = default(Circle3);
			if (ComputeIntersection(ref localHeadPosition, radiusA, ref sphereLocalOrigin, num, ref intersection))
			{
				localTailPosition = ComputeNewTailPosition(ref intersection, ref localTailPosition);
			}
			return SpringBone.CollisionStatus.TailCollision;
		}

		public static bool ComputeIntersection(ref Vector3 originA, float radiusA, ref Vector3 originB, float radiusB, ref Circle3 intersection)
		{
			Vector3 v = Vector3Extension.Subtract(ref originB, ref originA);
			float num = Vector3Extension.LengthSquared(ref v);
			float num2 = (float)Math.Sqrt(num);
			if (num2 <= 0f)
			{
				return false;
			}
			float num3 = radiusA * radiusA;
			float num4 = radiusB * radiusB;
			float num5 = 0.5f / num2;
			float num6 = num - num4 + num3;
			float num7 = num6 * num5;
			float num8 = num6 * num6;
			float num9 = Mathf.Sqrt(4f * num * num3 - num8) * num5;
			Vector3 vector = Vector3Extension.Divide(ref v, num2);
			Vector3 origin = originA + num7 * vector;
			intersection.origin = origin;
			intersection.upVector = vector;
			intersection.radius = num9;
			return true;
		}

		public static Vector3 ComputeNewTailPosition(ref Circle3 intersection, ref Vector3 tailPosition)
		{
			Vector3 result = Vector3Extension.Subtract(ref tailPosition, ref intersection.origin);
			float d = Vector3.Dot(intersection.upVector, result);
			Vector3Extension.Multiply(ref intersection.upVector, d, out result);
			Vector3 a = Vector3Extension.Subtract(ref tailPosition, ref result);
			Vector3 v = Vector3Extension.Subtract(ref a, ref intersection.origin);
			Vector3Extension.Normalize(ref v);
			Vector3Extension.MultiplyTarget(intersection.radius, ref v);
			return Vector3Extension.Add(ref intersection.origin, ref v);
		}
	}
	public class DynamicsNull : MonoBehaviour
	{
	}
	public class HighLeg : MonoBehaviour
	{
		[Serializable]
		public class TransformPair
		{
			public Transform start;

			public Transform end;

			public Vector3 GetDirection()
			{
				return (end.position - start.position).normalized;
			}
		}

		public Transform hipPivot;

		public TransformPair[] legs;

		private void LateUpdate()
		{
			Vector3 forward = hipPivot.forward;
			Vector3 up = hipPivot.up;
			int num = legs.Length;
			float num2 = -1f;
			for (int i = 0; i < num; i++)
			{
				Vector3 direction = legs[i].GetDirection();
				if (Vector3.Dot(direction, forward) >= 0f)
				{
					num2 = Mathf.Max(Vector3.Dot(direction, up), num2);
				}
			}
			float num3 = Mathf.Sqrt(Mathf.Clamp01(1f - num2 * num2));
			Vector3 vector = up * num2 + forward * num3;
			Vector3 worldPosition = base.transform.position + vector;
			base.transform.LookAt(worldPosition, (num2 > -0.5f) ? up : forward);
		}
	}
	public class ForceProvider : MonoBehaviour
	{
		public virtual Vector3 GetForceOnBone(SpringBone springBone)
		{
			return Vector3.zero;
		}
	}
	public class ForceVolume : ForceProvider
	{
		public float strength = 0.01f;

		public override Vector3 GetForceOnBone(SpringBone springBone)
		{
			return strength * base.transform.forward;
		}

		private void OnDrawGizmos()
		{
			Vector3 position = base.transform.position;
			Vector3 destination = position + strength * 10f * base.transform.forward;
			GizmoUtil.DrawArrow(position, destination, Color.gray, 0.1f);
		}
	}
	public class WindVolume : ForceProvider
	{
		[Range(0f, 1f)]
		public float weight;

		public float strength = 100f;

		public float amplitude = 1f;

		public float period = 1.5f;

		public float spinPeriod = 1.5f;

		public float peakDistance = 0.2f;

		private const float PI2 = (float)Math.PI * 2f;

		private float positionalMultiplier;

		private float currentTime;

		private float timeFactor;

		private float spinTime;

		private Vector3 offsetVector;

		public override Vector3 GetForceOnBone(SpringBone springBone)
		{
			float num = weight * strength;
			if ((num <= 0.0001f) | (period <= 0.001f))
			{
				return Vector3.zero;
			}
			Vector3 vector = base.transform.InverseTransformPoint(springBone.transform.position);
			float positionalFactor = GetPositionalFactor(vector.x, vector.z);
			float num2 = Mathf.Sin(timeFactor + positionalFactor);
			Vector3 vector2 = num * (base.transform.forward + num2 * offsetVector).normalized;
			return springBone.windInfluence * vector2;
		}

		private float GetPositionalFactor(float x, float y)
		{
			return Mathf.Sin(positionalMultiplier * x) + Mathf.Cos(positionalMultiplier * y);
		}

		private float AddPeriodically(float currentValue, float deltaValue, float period)
		{
			float num;
			for (num = currentValue + deltaValue; num >= period; num -= period)
			{
			}
			return num;
		}

		private void Update()
		{
			if (!(weight <= 0.0001f) && !(period <= 0.001f))
			{
				peakDistance = Mathf.Max(peakDistance, 0.0001f);
				positionalMultiplier = (float)Math.PI * 2f / peakDistance;
				float deltaTime = Time.deltaTime;
				currentTime = AddPeriodically(currentTime, deltaTime, period);
				timeFactor = currentTime * ((float)Math.PI * 2f) / period;
				offsetVector = base.transform.up;
				if (Mathf.Abs(spinPeriod) > 0.001f)
				{
					spinTime = AddPeriodically(spinTime, deltaTime, spinPeriod);
					float f = spinTime * ((float)Math.PI * 2f) / spinPeriod;
					offsetVector = Mathf.Cos(f) * base.transform.right + Mathf.Sin(f) * base.transform.up;
				}
				offsetVector = amplitude * offsetVector;
			}
		}

		private void OnDrawGizmos()
		{
			Vector3 position = base.transform.position;
			float num = Mathf.Clamp(strength, 0.1f, 1f);
			Vector3 vector = position + num * base.transform.forward;
			Vector3[] array = new Vector3[3]
			{
				Vector3.zero,
				0.02f * base.transform.up,
				-0.02f * base.transform.up
			};
			foreach (Vector3 vector2 in array)
			{
				GizmoUtil.DrawArrow(position + vector2, vector + vector2, Color.gray, 0.1f);
			}
		}
	}
	public class DynamicsSetup
	{
		public class ImportSettings
		{
			public bool ImportSpringBones { get; set; }

			public bool ImportCollision { get; set; }

			public ImportSettings()
			{
				ImportSpringBones = true;
				ImportCollision = true;
			}

			public ImportSettings(ImportSettings sourceSettings)
			{
				ImportSpringBones = sourceSettings.ImportSpringBones;
				ImportCollision = sourceSettings.ImportCollision;
			}
		}

		public class ParseMessage
		{
			public string Message { get; private set; }

			public string SourceLine { get; private set; }

			public string Exception { get; private set; }

			public UnityEngine.Object Context { get; private set; }

			public ParseMessage(string message, string sourceLine = "", string exception = "", UnityEngine.Object context = null)
			{
				Message = message;
				SourceLine = sourceLine;
				Exception = exception;
				Context = context;
			}

			public ParseMessage(string message, IEnumerable<string> sourceLineItems, string exception = "", UnityEngine.Object context = null)
			{
				Message = message;
				SourceLine = ((sourceLineItems != null) ? (string.Join(", ", sourceLineItems.ToArray()) + "\n") : "");
				Exception = exception;
				Context = context;
			}

			public string ToLogMessage()
			{
				string text = Message;
				if (!string.IsNullOrEmpty(SourceLine))
				{
					text = text + "\n" + SourceLine;
				}
				if (!string.IsNullOrEmpty(Exception))
				{
					text = text + "\n\n" + Exception;
				}
				return text;
			}
		}

		public class ParseResults
		{
			public DynamicsSetup Setup { get; private set; }

			public List<ParseMessage> Errors { get; private set; }

			public bool HasErrors => Errors.Count > 0;

			public ParseResults()
			{
				Setup = null;
				Errors = new List<ParseMessage>(0);
			}

			public ParseResults(DynamicsSetup setup, IEnumerable<ParseMessage> errors)
			{
				Setup = setup;
				Errors = errors.ToList();
			}

			public static ParseResults Failure(string error)
			{
				return new ParseResults(null, new List<ParseMessage>
				{
					new ParseMessage(error)
				});
			}

			public static ParseResults Failure(IEnumerable<ParseMessage> errors)
			{
				return new ParseResults(null, errors);
			}

			public void LogErrors()
			{
				foreach (ParseMessage error in Errors)
				{
					UnityEngine.Debug.LogError(error.ToLogMessage(), error.Context);
				}
			}
		}

		private const int UnknownVersion = -1;

		private ImportSettings importSettings;

		private GameObject springBoneRoot;

		private GameObject colliderRoot;

		private SpringBoneSerialization.ParsedSpringBoneSetup springBoneSetup;

		private SpringColliderSerialization.ParsedColliderSetup colliderSetup;

		public static bool BuildFromRecordText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, ImportSettings importSettings = null, IEnumerable<string> requiredBones = null)
		{
			ParseResults parseResults = ParseFromRecordText(springBoneRoot, colliderRoot, recordText, importSettings);
			bool num = parseResults.Setup != null;
			if (num)
			{
				parseResults.Setup.Build(requiredBones);
			}
			return num;
		}

		public static ParseResults ParseFromRecordText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, ImportSettings importSettings = null)
		{
			if (springBoneRoot == null)
			{
				throw new ArgumentNullException("springBoneRoot");
			}
			if (colliderRoot == null)
			{
				throw new ArgumentNullException("colliderRoot");
			}
			if (recordText == null)
			{
				throw new ArgumentNullException("recordText");
			}
			ParseResults parseResults = InternalParseFromRecordText(springBoneRoot, colliderRoot, recordText, importSettings);
			parseResults.LogErrors();
			return parseResults;
		}

		public void Build(IEnumerable<string> requiredBones = null)
		{
			if (importSettings.ImportCollision && colliderSetup != null)
			{
				colliderSetup.BuildObjects(colliderRoot);
			}
			if (importSettings.ImportSpringBones && springBoneSetup != null)
			{
				springBoneSetup.BuildObjects(springBoneRoot, colliderRoot, requiredBones);
			}
		}

		public static int GetVersionFromSetupRecords(List<TextRecordParsing.Record> sourceRecords, out TextRecordParsing.Record versionRecord)
		{
			int output = -1;
			versionRecord = sourceRecords.FirstOrDefault((TextRecordParsing.Record item) => item.GetString(0).ToLowerInvariant() == "version");
			if (versionRecord != null)
			{
				versionRecord.TryGetInt(1, ref output);
			}
			return output;
		}

		public static object SerializeObjectFromStrings(Type type, IEnumerable<string> sourceItems, string firstOptionalField, ref ParseMessage error)
		{
			try
			{
				return new Queue<string>(sourceItems).DequeueObject(type, firstOptionalField);
			}
			catch (Exception ex)
			{
				error = new ParseMessage("Error building " + type.ToString(), sourceItems, ex.ToString());
			}
			return null;
		}

		public static T SerializeObjectFromStrings<T>(IEnumerable<string> sourceItems, string firstOptionalField, ref ParseMessage error) where T : class
		{
			return SerializeObjectFromStrings(typeof(T), sourceItems, firstOptionalField, ref error) as T;
		}

		private static int GetVersionFromSetupRecords(List<TextRecordParsing.Record> sourceRecords)
		{
			TextRecordParsing.Record versionRecord;
			return GetVersionFromSetupRecords(sourceRecords, out versionRecord);
		}

		private static bool VerifyVersionAndDetectContents(string recordText, ImportSettings importSettings, out string errorMessage)
		{
			errorMessage = "";
			int num = -1;
			try
			{
				num = GetVersionFromSetupRecords(TextRecordParsing.ParseRecordsFromText(recordText));
			}
			catch (Exception ex)
			{
				errorMessage = $"SpringBoneSetup: 元のテキストデータを読み込めませんでした！\n\n{ex.ToString()}";
				return false;
			}
			switch (num)
			{
			case -1:
				if (!recordText.ToLowerInvariant().Contains("[springbones]"))
				{
					importSettings.ImportSpringBones = false;
				}
				break;
			default:
				errorMessage = $"SpringBoneSetup: データのバージョンは対応していません！\nVersion: {num}";
				return false;
			case 3:
				importSettings.ImportCollision = false;
				break;
			case 4:
				break;
			}
			return true;
		}

		private static ParseResults InternalParseFromRecordText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, ImportSettings importSettings)
		{
			if (recordText.Length == 0)
			{
				return new ParseResults();
			}
			ImportSettings importSettings2 = ((importSettings != null) ? new ImportSettings(importSettings) : new ImportSettings());
			if (!VerifyVersionAndDetectContents(recordText, importSettings2, out var errorMessage))
			{
				return ParseResults.Failure(errorMessage);
			}
			List<ParseMessage> list = new List<ParseMessage>();
			SpringColliderSerialization.ParsedColliderSetup parsedColliderSetup = null;
			if (importSettings2.ImportCollision)
			{
				parsedColliderSetup = SpringColliderSerialization.ParsedColliderSetup.ReadColliderSetupFromText(colliderRoot, recordText);
				if (parsedColliderSetup == null)
				{
					list.Add(new ParseMessage("ダイナミクスセットアップが失敗しました：元データにエラーがあります"));
					return ParseResults.Failure(list);
				}
				list.AddRange(parsedColliderSetup.Errors);
			}
			SpringBoneSerialization.ParsedSpringBoneSetup parsedSpringBoneSetup = null;
			if (importSettings2.ImportSpringBones)
			{
				IEnumerable<string> inputValidColliderNames = parsedColliderSetup?.GetColliderNames();
				parsedSpringBoneSetup = SpringBoneSerialization.ParsedSpringBoneSetup.ReadSpringBoneSetupFromText(springBoneRoot, colliderRoot, recordText, inputValidColliderNames);
				if (parsedSpringBoneSetup == null)
				{
					list.Add(new ParseMessage("ダイナミクスセットアップが失敗しました：元データにエラーがあります"));
					return ParseResults.Failure(list);
				}
				list.AddRange(parsedSpringBoneSetup.Errors);
			}
			return new ParseResults(new DynamicsSetup
			{
				importSettings = importSettings2,
				springBoneRoot = springBoneRoot,
				colliderRoot = colliderRoot,
				springBoneSetup = parsedSpringBoneSetup,
				colliderSetup = parsedColliderSetup
			}, list);
		}
	}
	public static class SpringBoneSerialization
	{
		public class ExportSettings
		{
			public bool ExportSpringBones { get; set; }

			public bool ExportCollision { get; set; }

			public ExportSettings()
			{
				ExportSpringBones = true;
				ExportCollision = true;
			}
		}

		public class ParsedSpringBoneSetup
		{
			private IEnumerable<PivotSerializer> pivotRecords;

			private IEnumerable<SpringBoneSerializer> springBoneRecords;

			public IEnumerable<DynamicsSetup.ParseMessage> Errors { get; set; }

			public static ParsedSpringBoneSetup ReadSpringBoneSetupFromText(GameObject springBoneRoot, GameObject colliderRoot, string recordText, IEnumerable<string> inputValidColliderNames)
			{
				List<TextRecordParsing.Record> list = null;
				List<TextRecordParsing.Record> list2 = null;
				try
				{
					List<TextRecordParsing.Record> sourceRecords = TextRecordParsing.ParseRecordsFromText(recordText);
					TextRecordParsing.Record versionRecord = null;
					DynamicsSetup.GetVersionFromSetupRecords(sourceRecords, out versionRecord);
					list = TextRecordParsing.GetSectionRecords(sourceRecords, "SpringBones");
					if (list == null || list.Count == 0)
					{
						list = (from item in TextRecordParsing.GetSectionRecords(sourceRecords, null)
							where item != versionRecord
							select item).ToList();
					}
					list2 = TextRecordParsing.GetSectionRecords(sourceRecords, "Pivots");
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError("SpringBoneSetup: 元のテキストデータを読み込めませんでした！\n\n" + ex.ToString());
					return null;
				}
				List<DynamicsSetup.ParseMessage> list3 = new List<DynamicsSetup.ParseMessage>();
				IEnumerable<PivotSerializer> sourceRecords2 = SerializePivotRecords(list2, list3);
				IEnumerable<SpringBoneSerializer> sourceRecords3 = SerializeSpringBoneRecords(list, list3);
				List<string> list4 = (from item in springBoneRoot.GetComponentsInChildren<Transform>(includeInactive: true)
					select item.name).Distinct().ToList();
				List<PivotSerializer> list5 = new List<PivotSerializer>();
				VerifyPivotRecords(sourceRecords2, list4, list5, list3);
				List<string> list6 = new List<string>(list4);
				list6.AddRange(list5.Select((PivotSerializer record) => record.name));
				List<string> list7 = new List<string>();
				IEnumerable<Type> colliderTypes = SpringColliderSetup.GetColliderTypes();
				list7.AddRange(from item in colliderTypes.SelectMany((Type type) => colliderRoot.GetComponentsInChildren(type, includeInactive: true))
					select item.name);
				if (inputValidColliderNames != null)
				{
					list7.AddRange(inputValidColliderNames);
				}
				List<SpringBoneSerializer> validRecords = new List<SpringBoneSerializer>();
				VerifySpringBoneRecords(sourceRecords3, list4, list6, list7, validRecords, out var hasMissingColliders, list3);
				if (hasMissingColliders)
				{
					UnityEngine.Debug.LogWarning("スプリングボーンセットアップ：一部のコライダーが見つかりません");
				}
				return new ParsedSpringBoneSetup
				{
					pivotRecords = list5,
					springBoneRecords = validRecords,
					Errors = list3
				};
			}

			public void BuildObjects(GameObject springBoneRoot, GameObject colliderRoot, IEnumerable<string> requiredBones)
			{
				PersistentSpringManagerProperties persistentSpringManagerProperties = PersistentSpringManagerProperties.Create(springBoneRoot.GetComponentInChildren<SpringManager>());
				SpringBoneSetup.DestroySpringManagersAndBones(springBoneRoot);
				if (requiredBones != null)
				{
					FilterBoneRecordsByRequiredBonesAndCreateUnrecordedBones(springBoneRoot, requiredBones);
				}
				Dictionary<string, Transform> transforms = springBoneRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				foreach (PivotSerializer pivotRecord in pivotRecords)
				{
					BuildPivotFromSerializer(transforms, pivotRecord);
				}
				SpringBoneSetupMaps setupMaps = SpringBoneSetupMaps.Build(springBoneRoot, colliderRoot);
				foreach (SpringBoneSerializer springBoneRecord in springBoneRecords)
				{
					BuildSpringBoneFromSerializer(setupMaps, springBoneRecord);
				}
				SpringManager springManager = springBoneRoot.AddComponent<SpringManager>();
				persistentSpringManagerProperties?.ApplyTo(springManager);
				SpringBoneSetup.FindAndAssignSpringBones(springManager);
			}

			private void FilterBoneRecordsByRequiredBonesAndCreateUnrecordedBones(GameObject springBoneRoot, IEnumerable<string> requiredBones)
			{
				IEnumerable<SpringBoneSerializer> enumerable = springBoneRecords.Where((SpringBoneSerializer record) => requiredBones.Contains(record.baseData.boneName));
				IEnumerable<string> second = enumerable.Select((SpringBoneSerializer record) => record.baseData.boneName);
				foreach (GameObject item in from boneName in requiredBones.Except(second)
					select springBoneRoot.FindChildByName(boneName) into item
					where item != null
					select item.gameObject)
				{
					SpringBoneSetup.CreateSpringPivotNode(item.AddComponent<SpringBone>());
				}
				foreach (SpringBoneSerializer item2 in springBoneRecords.Except(enumerable))
				{
					UnityEngine.Debug.LogWarning(item2.baseData.boneName + "\nボーンリストにないので作成しません");
				}
				springBoneRecords = enumerable;
			}
		}

		private class PersistentSpringManagerProperties
		{
			private bool automaticUpdates;

			private int simulationFrameRate;

			private float dynamicRatio;

			private Vector3 gravity;

			private bool collideWithGround;

			private float groundHeight;

			private float bounce;

			private float friction;

			public static PersistentSpringManagerProperties Create(SpringManager sourceManager)
			{
				if (sourceManager == null)
				{
					return null;
				}
				return new PersistentSpringManagerProperties
				{
					automaticUpdates = sourceManager.automaticUpdates,
					simulationFrameRate = sourceManager.simulationFrameRate,
					dynamicRatio = sourceManager.dynamicRatio,
					gravity = sourceManager.gravity,
					collideWithGround = sourceManager.collideWithGround,
					groundHeight = sourceManager.groundHeight,
					bounce = sourceManager.bounce,
					friction = sourceManager.friction
				};
			}

			public void ApplyTo(SpringManager targetManager)
			{
				targetManager.automaticUpdates = automaticUpdates;
				targetManager.simulationFrameRate = simulationFrameRate;
				targetManager.dynamicRatio = dynamicRatio;
				targetManager.gravity = gravity;
				targetManager.collideWithGround = collideWithGround;
				targetManager.groundHeight = groundHeight;
				targetManager.bounce = bounce;
				targetManager.friction = friction;
			}
		}

		private class SpringBoneSetupMaps
		{
			public Dictionary<string, Transform> allChildren;

			public Dictionary<string, SpringSphereCollider> sphereColliders;

			public Dictionary<string, SpringCapsuleCollider> capsuleColliders;

			public Dictionary<string, SpringPanelCollider> panelColliders;

			public static SpringBoneSetupMaps Build(GameObject springBoneRoot, GameObject colliderRoot)
			{
				return new SpringBoneSetupMaps
				{
					allChildren = springBoneRoot.BuildNameToComponentMap<Transform>(includeInactive: true),
					sphereColliders = colliderRoot.BuildNameToComponentMap<SpringSphereCollider>(includeInactive: true),
					capsuleColliders = colliderRoot.BuildNameToComponentMap<SpringCapsuleCollider>(includeInactive: true),
					panelColliders = colliderRoot.BuildNameToComponentMap<SpringPanelCollider>(includeInactive: true)
				};
			}
		}

		private class PivotSerializer
		{
			public string name;

			public string parentName;

			public Vector3 eulerAngles;
		}

		private class AngleLimitSerializer
		{
			public bool enabled;

			public float min;

			public float max;
		}

		private class LengthLimitSerializer
		{
			public string objectName;

			public float ratio;
		}

		private class SpringBoneBaseSerializer
		{
			public string boneName;

			public float radius;

			public float stiffness;

			public float drag;

			public Vector3 springForce;

			public float windInfluence;

			public string pivotName;

			public AngleLimitSerializer yAngleLimits;

			public AngleLimitSerializer zAngleLimits;

			public float angularStiffness;

			public LengthLimitSerializer[] lengthLimits;
		}

		private class SpringBoneSerializer
		{
			public SpringBoneBaseSerializer baseData;

			public string[] colliderNames;
		}

		public static string BuildDynamicsSetupString(GameObject rootObject, ExportSettings exportSettings = null)
		{
			if (exportSettings == null)
			{
				exportSettings = new ExportSettings();
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("version,");
			stringBuilder.Append(4);
			stringBuilder.AppendLine();
			if (exportSettings.ExportSpringBones)
			{
				stringBuilder.Append(BuildSpringBoneSetupString(rootObject));
			}
			if (exportSettings.ExportCollision)
			{
				stringBuilder.Append(SpringColliderSerialization.BuildCollisionSetupString(rootObject));
			}
			return stringBuilder.ToString();
		}

		private static AngleLimitSerializer AngleLimitsToSerializer(AngleLimits sourceLimits)
		{
			return new AngleLimitSerializer
			{
				enabled = sourceLimits.active,
				min = sourceLimits.min,
				max = sourceLimits.max
			};
		}

		private static SpringBoneBaseSerializer SpringBoneToBaseSerializer(SpringBone sourceBone)
		{
			return new SpringBoneBaseSerializer
			{
				boneName = sourceBone.name,
				radius = sourceBone.radius,
				stiffness = sourceBone.stiffnessForce,
				drag = sourceBone.dragForce,
				springForce = sourceBone.springForce,
				windInfluence = sourceBone.windInfluence,
				pivotName = ((sourceBone.pivotNode != null) ? sourceBone.pivotNode.name : ""),
				yAngleLimits = AngleLimitsToSerializer(sourceBone.yAngleLimits),
				zAngleLimits = AngleLimitsToSerializer(sourceBone.zAngleLimits),
				angularStiffness = sourceBone.angularStiffness,
				lengthLimits = (from item in sourceBone.lengthLimitTargets
					where item != null
					select new LengthLimitSerializer
					{
						objectName = item.name,
						ratio = 1.01f
					}).ToArray()
			};
		}

		private static PivotSerializer PivotToSerializer(Transform sourcePivot)
		{
			return new PivotSerializer
			{
				name = sourcePivot.name,
				parentName = ((sourcePivot.parent != null) ? sourcePivot.parent.name : ""),
				eulerAngles = sourcePivot.localEulerAngles
			};
		}

		private static void AppendSpringBones(CSVBuilder builder, IEnumerable<SpringBone> springBones)
		{
			if (!springBones.Any())
			{
				return;
			}
			string[] list = new string[20]
			{
				"// bone", "radius", "stiffnessForce", "dragForce", "springForce x", "springForce y", "springForce z", "wind influence", "pivot node", "use y angle limit",
				"y angle min", "y angle max", "use z angle limit", "z angle min", "z angle max", "angle stiffness", "length limit count", "length limit target", "length limit ratio x N", "collider x N"
			};
			builder.AppendLine();
			builder.AppendLine("[SpringBones]");
			builder.AppendLine(list);
			foreach (SpringBone springBone in springBones)
			{
				SpringBoneBaseSerializer item2 = SpringBoneToBaseSerializer(springBone);
				builder.Append(item2);
				List<string> list2 = new List<string>();
				list2.AddRange(from item in springBone.sphereColliders
					where item != null
					select item.name);
				list2.AddRange(from item in springBone.capsuleColliders
					where item != null
					select item.name);
				list2.AddRange(from item in springBone.panelColliders
					where item != null
					select item.name);
				builder.AppendLine(list2.Distinct());
			}
		}

		private static void AppendPivots(CSVBuilder builder, IEnumerable<SpringBone> springBones)
		{
			IEnumerable<PivotSerializer> enumerable = from pivot in (from bone in springBones
					where bone.pivotNode != null && bone.pivotNode != bone.transform.parent && bone.pivotNode.parent != null
					select bone.pivotNode).Distinct()
				select PivotToSerializer(pivot);
			if (!enumerable.Any())
			{
				return;
			}
			string[] list = new string[5] { "// PivotName", "ParentName", "local rotation x", "y", "z" };
			builder.AppendLine();
			builder.AppendLine("[Pivots]");
			builder.AppendLine(list);
			foreach (PivotSerializer item in enumerable)
			{
				builder.Append(item);
				builder.AppendLine();
			}
		}

		private static string BuildSpringBoneSetupString(GameObject rootObject)
		{
			CSVBuilder cSVBuilder = new CSVBuilder();
			SpringBone[] componentsInChildren = rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true);
			AppendSpringBones(cSVBuilder, componentsInChildren);
			AppendPivots(cSVBuilder, componentsInChildren);
			return cSVBuilder.ToString();
		}

		private static IEnumerable<PivotSerializer> SerializePivotRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			List<PivotSerializer> list = new List<PivotSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				PivotSerializer pivotSerializer = DynamicsSetup.SerializeObjectFromStrings<PivotSerializer>(sourceRecord.Items, null, ref error);
				if (pivotSerializer != null)
				{
					list.Add(pivotSerializer);
				}
				else
				{
					errorRecords.Add(error);
				}
			}
			return list;
		}

		private static IEnumerable<SpringBoneSerializer> SerializeSpringBoneRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			List<SpringBoneSerializer> list = new List<SpringBoneSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				Queue<string> queue = sourceRecord.ToQueue();
				SpringBoneBaseSerializer springBoneBaseSerializer = null;
				DynamicsSetup.ParseMessage item2 = null;
				try
				{
					springBoneBaseSerializer = queue.DequeueObject<SpringBoneBaseSerializer>();
				}
				catch (Exception ex)
				{
					item2 = new DynamicsSetup.ParseMessage("Error building SpringBoneBaseSerializer", sourceRecord.Items, ex.ToString());
				}
				if (springBoneBaseSerializer != null)
				{
					IEnumerable<string> source = new List<string>(queue).Where((string item) => item.Length > 0);
					SpringBoneSerializer item3 = new SpringBoneSerializer
					{
						baseData = springBoneBaseSerializer,
						colliderNames = source.ToArray()
					};
					list.Add(item3);
				}
				else
				{
					errorRecords.Add(item2);
				}
			}
			return list;
		}

		private static bool VerifyPivotRecords(IEnumerable<PivotSerializer> sourceRecords, IEnumerable<string> validParentNames, List<PivotSerializer> validRecords, List<DynamicsSetup.ParseMessage> errors)
		{
			List<PivotSerializer> list = new List<PivotSerializer>(sourceRecords.Count());
			foreach (PivotSerializer sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage parseMessage = null;
				if (sourceRecord.name.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage("名前が指定されていない基点オブジェクトがあります");
				}
				string parentName = sourceRecord.parentName;
				if (parentName.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage(sourceRecord.name + " : 親名が指定されていません");
				}
				else if (!validParentNames.Contains(parentName))
				{
					parseMessage = new DynamicsSetup.ParseMessage(sourceRecord.name + " : 親が見つかりません: " + parentName);
				}
				if (parseMessage == null)
				{
					list.Add(sourceRecord);
				}
				else
				{
					errors.Add(parseMessage);
				}
			}
			validRecords.AddRange(list);
			return sourceRecords.Count() == list.Count();
		}

		private static bool VerifySpringBoneRecords(IEnumerable<SpringBoneSerializer> sourceRecords, IEnumerable<string> validBoneNames, IEnumerable<string> validPivotNames, IEnumerable<string> validColliderNames, List<SpringBoneSerializer> validRecords, out bool hasMissingColliders, List<DynamicsSetup.ParseMessage> errors)
		{
			hasMissingColliders = false;
			List<SpringBoneSerializer> list = new List<SpringBoneSerializer>(sourceRecords.Count());
			foreach (SpringBoneSerializer sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage parseMessage = null;
				SpringBoneBaseSerializer baseData = sourceRecord.baseData;
				if (baseData.boneName.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage("名前が指定されていない基点オブジェクトがあります");
				}
				else if (!validBoneNames.Contains(baseData.boneName))
				{
					parseMessage = new DynamicsSetup.ParseMessage(baseData.boneName + " : オブジェくトが見つかりません");
				}
				string pivotName = baseData.pivotName;
				if (pivotName.Length == 0)
				{
					parseMessage = new DynamicsSetup.ParseMessage(baseData.boneName + " : 基点名が指定されていません");
				}
				else if (!validPivotNames.Contains(pivotName))
				{
					parseMessage = new DynamicsSetup.ParseMessage(baseData.boneName + " : 基点オブジェクトが見つかりません: " + pivotName);
				}
				IEnumerable<string> source = sourceRecord.colliderNames.Where((string name) => !validColliderNames.Contains(name));
				if (source.Any())
				{
					hasMissingColliders = true;
					UnityEngine.Debug.LogWarning(baseData.boneName + " : コライダーが見つかりません:\n" + string.Join(" ", source.ToArray()));
				}
				if (parseMessage == null)
				{
					list.Add(sourceRecord);
				}
				else
				{
					errors.Add(parseMessage);
				}
			}
			validRecords.AddRange(list);
			return sourceRecords.Count() == list.Count();
		}

		private static AngleLimits BuildAngleLimitsFromSerializer(AngleLimitSerializer serializer)
		{
			return new AngleLimits
			{
				active = serializer.enabled,
				min = serializer.min,
				max = serializer.max
			};
		}

		private static Transform FindChildByName(Transform parent, string name)
		{
			for (int i = 0; i < parent.childCount; i++)
			{
				Transform child = parent.GetChild(i);
				if (child.name.ToLowerInvariant() == name.ToLowerInvariant())
				{
					return child;
				}
			}
			return null;
		}

		private static bool BuildPivotFromSerializer(Dictionary<string, Transform> transforms, PivotSerializer serializer)
		{
			Transform value;
			bool flag = transforms.TryGetValue(serializer.parentName, out value);
			if (flag)
			{
				Transform transform = FindChildByName(value, serializer.name);
				if (transform == null)
				{
					transform = new GameObject(serializer.name, typeof(SpringBonePivot)).transform;
					transform.parent = value;
				}
				transform.localScale = Vector3.one;
				transform.localEulerAngles = serializer.eulerAngles;
				transform.localPosition = Vector3.zero;
			}
			return flag;
		}

		private static bool BuildSpringBoneFromSerializer(SpringBoneSetupMaps setupMaps, SpringBoneSerializer serializer)
		{
			SpringBoneBaseSerializer baseData = serializer.baseData;
			Transform value = null;
			if (!setupMaps.allChildren.TryGetValue(baseData.boneName, out value))
			{
				UnityEngine.Debug.LogError("ボーンが見つかりません: " + baseData.boneName);
				return false;
			}
			SpringBone springBone = value.gameObject.AddComponent<SpringBone>();
			springBone.stiffnessForce = baseData.stiffness;
			springBone.dragForce = baseData.drag;
			springBone.springForce = baseData.springForce;
			springBone.windInfluence = baseData.windInfluence;
			springBone.angularStiffness = baseData.angularStiffness;
			springBone.yAngleLimits = BuildAngleLimitsFromSerializer(baseData.yAngleLimits);
			springBone.zAngleLimits = BuildAngleLimitsFromSerializer(baseData.zAngleLimits);
			springBone.radius = baseData.radius;
			string pivotName = baseData.pivotName;
			Transform value2 = null;
			if (pivotName.Length > 0 && !setupMaps.allChildren.TryGetValue(pivotName, out value2))
			{
				UnityEngine.Debug.LogError("Pivotオブジェクトが見つかりません: " + pivotName);
				value2 = null;
			}
			if (value2 == null)
			{
				value2 = springBone.transform.parent ?? springBone.transform;
			}
			else
			{
				IEnumerable<Transform> allBones = springBone.transform.root.gameObject.GetAllBones();
				if ((bool)value2.GetComponent<SpringBonePivot>() && SpringBoneSetup.IsPivotProbablySafeToDestroy(value2, allBones))
				{
					value2.position = springBone.transform.position;
				}
			}
			springBone.pivotNode = value2;
			springBone.lengthLimitTargets = (from lengthLimit in baseData.lengthLimits
				where setupMaps.allChildren.ContainsKey(lengthLimit.objectName)
				select setupMaps.allChildren[lengthLimit.objectName]).ToArray();
			springBone.sphereColliders = (from name in serializer.colliderNames
				where setupMaps.sphereColliders.ContainsKey(name)
				select setupMaps.sphereColliders[name]).ToArray();
			springBone.capsuleColliders = (from name in serializer.colliderNames
				where setupMaps.capsuleColliders.ContainsKey(name)
				select setupMaps.capsuleColliders[name]).ToArray();
			springBone.panelColliders = (from name in serializer.colliderNames
				where setupMaps.panelColliders.ContainsKey(name)
				select setupMaps.panelColliders[name]).ToArray();
			return true;
		}
	}
	public static class SpringBoneSetup
	{
		public static void DestroyUnityObject(UnityEngine.Object objectToDestroy)
		{
			UnityEngine.Object.DestroyImmediate(objectToDestroy);
		}

		public static void DestroySpringManagersAndBones(GameObject rootObject)
		{
			DestroyPivotObjects(rootObject);
			SpringManager[] componentsInChildren = rootObject.GetComponentsInChildren<SpringManager>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				DestroyUnityObject(componentsInChildren[i]);
			}
			SpringBone[] componentsInChildren2 = rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true);
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				DestroyUnityObject(componentsInChildren2[i]);
			}
		}

		public static void FindAndAssignSpringBones(SpringManager springManager, bool includeInactive = false)
		{
			if (springManager != null)
			{
				List<SpringBone> springBonesSortedByDepth = GetSpringBonesSortedByDepth(springManager.gameObject, includeInactive);
				springManager.springBones = springBonesSortedByDepth.ToArray();
			}
		}

		public static void AssignSpringBonesRecursively(Transform rootObject)
		{
			if (rootObject.childCount != 0)
			{
				if (rootObject.gameObject.GetComponent<SpringBone>() == null)
				{
					rootObject.gameObject.AddComponent<SpringBone>();
				}
				for (int i = 0; i < rootObject.childCount; i++)
				{
					AssignSpringBonesRecursively(rootObject.GetChild(i));
				}
			}
		}

		public static Dictionary<Transform, List<SpringBone>> GetPivotToSpringBoneMap(GameObject rootObject)
		{
			IEnumerable<Transform> skinBones = rootObject.GetAllBones();
			IEnumerable<SpringBone> enumerable = from bone in rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true)
				where bone.pivotNode != null && !skinBones.Contains(bone.pivotNode)
				select bone;
			Dictionary<Transform, List<SpringBone>> dictionary = new Dictionary<Transform, List<SpringBone>>();
			foreach (SpringBone item in enumerable)
			{
				List<SpringBone> value = null;
				if (!dictionary.TryGetValue(item.pivotNode, out value))
				{
					value = new List<SpringBone>();
				}
				value.Add(item);
				dictionary[item.pivotNode] = value;
			}
			return dictionary;
		}

		public static void FixAllPivotNodePositions(GameObject rootObject)
		{
			foreach (KeyValuePair<Transform, List<SpringBone>> item in GetPivotToSpringBoneMap(rootObject))
			{
				Vector3 zero = Vector3.zero;
				List<SpringBone> value = item.Value;
				foreach (SpringBone item2 in value)
				{
					zero += item2.transform.position;
				}
				zero /= (float)value.Count;
				item.Key.position = zero;
			}
		}

		public static GameObject CreateSpringPivotNode(SpringBone springBone)
		{
			GameObject gameObject = new GameObject(springBone.name + "_Pivot");
			gameObject.transform.parent = springBone.transform.parent;
			gameObject.transform.rotation = GetPivotRotation(springBone);
			gameObject.transform.position = springBone.transform.position;
			gameObject.AddComponent<SpringBonePivot>();
			Transform pivotNode = springBone.pivotNode;
			if (pivotNode != null)
			{
				IEnumerable<Transform> allBones = springBone.transform.root.gameObject.GetAllBones();
				if (IsPivotProbablySafeToDestroy(pivotNode, allBones))
				{
					DestroyUnityObject(pivotNode.gameObject);
				}
			}
			springBone.pivotNode = gameObject.transform;
			springBone.yAngleLimits.active = true;
			if (springBone.yAngleLimits.min > -0.5f && springBone.yAngleLimits.max < 0.5f)
			{
				springBone.yAngleLimits.min = -20f;
				springBone.yAngleLimits.max = 20f;
			}
			springBone.zAngleLimits.active = true;
			if (springBone.zAngleLimits.min > -0.5f && springBone.zAngleLimits.max < 0.5f)
			{
				springBone.zAngleLimits.min = 0f;
				springBone.zAngleLimits.max = 20f;
			}
			return gameObject;
		}

		public static bool IsPivotProbablySafeToDestroy(Transform pivot, IEnumerable<Transform> skinBones)
		{
			if (skinBones.Contains(pivot) || pivot.childCount > 0 || pivot.GetComponent<Renderer>() != null)
			{
				return false;
			}
			if (pivot.GetComponent<SpringBonePivot>() != null)
			{
				return true;
			}
			return pivot.name.ToLowerInvariant().EndsWith("_pivot");
		}

		private static void DestroyPivotObjects(GameObject rootObject)
		{
			if (!(rootObject == null))
			{
				IEnumerable<Transform> source = from springBone in rootObject.GetComponentsInChildren<SpringBone>(includeInactive: true)
					where springBone.pivotNode != null
					select springBone.pivotNode;
				IEnumerable<Transform> skinBones = rootObject.GetAllBones();
				List<GameObject> list = (from pivot in source
					where IsPivotProbablySafeToDestroy(pivot, skinBones)
					select pivot.gameObject).ToList();
				int count = list.Count;
				for (int i = 0; i < count; i++)
				{
					DestroyUnityObject(list[i]);
				}
			}
		}

		private static bool IsPivotSideDirectionValid(Vector3 lookDirection, Vector3 sideDirection)
		{
			if (sideDirection.sqrMagnitude >= 0.1f)
			{
				return Mathf.Abs(Vector3.Dot(lookDirection, sideDirection)) < 0.99f;
			}
			return false;
		}

		private static Vector3 FindClosestMeshNormalToPoint(Transform rootObject, Vector3 sourcePoint)
		{
			IEnumerable<Mesh> enumerable = from renderer in rootObject.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true)
				select renderer.sharedMesh into mesh
				where mesh != null && mesh.vertexCount > 0
				select mesh;
			float num = 1000000f;
			Vector3 result = Vector3.up;
			foreach (Mesh item in enumerable)
			{
				Vector3[] vertices = item.vertices;
				Vector3[] normals = item.normals;
				if (vertices == null || normals == null || vertices.Length != normals.Length)
				{
					continue;
				}
				int num2 = -1;
				int num3 = vertices.Length;
				for (int i = 0; i < num3; i++)
				{
					float sqrMagnitude = (vertices[i] - sourcePoint).sqrMagnitude;
					if (sqrMagnitude < num)
					{
						num2 = i;
						num = sqrMagnitude;
					}
				}
				if (num2 != -1)
				{
					result = item.normals[num2];
				}
			}
			return result;
		}

		private static bool TryToGetPivotSideDirection(SpringBone springBone, Vector3 lookDirection, out Vector3 sideDirection)
		{
			sideDirection = Vector3.up;
			Vector3 normalized = Vector3.Cross(FindClosestMeshNormalToPoint(springBone.transform.root, springBone.transform.position), lookDirection).normalized;
			Vector3 normalized2 = Vector3.Cross(lookDirection, normalized).normalized;
			bool num = IsPivotSideDirectionValid(lookDirection, normalized2);
			if (num)
			{
				sideDirection = normalized2;
			}
			return num;
		}

		private static Quaternion GetPivotRotation(SpringBone springBone)
		{
			Vector3 vector = springBone.ComputeChildPosition() - springBone.transform.position;
			vector.Normalize();
			if (!TryToGetPivotSideDirection(springBone, vector, out var sideDirection))
			{
				sideDirection = springBone.transform.position;
				sideDirection.y = 0f;
				sideDirection.Normalize();
				if (!IsPivotSideDirectionValid(vector, sideDirection))
				{
					sideDirection = Vector3.up;
					if (!IsPivotSideDirectionValid(vector, sideDirection))
					{
						sideDirection = Vector3.forward;
					}
				}
			}
			Vector3 position = springBone.transform.position;
			position.y = 0f;
			if (Vector3.Dot(sideDirection, position) < 0f)
			{
				sideDirection = -sideDirection;
			}
			Vector3 normalized = Vector3.Cross(vector, sideDirection).normalized;
			Quaternion quaternion = Quaternion.LookRotation(vector, normalized);
			Quaternion quaternion2 = Quaternion.Euler(180f, 90f, 0f);
			return quaternion * quaternion2;
		}

		private static List<SpringBone> GetSpringBonesSortedByDepth(GameObject rootObject, bool includeInactive)
		{
			var list = (from bone in rootObject.GetComponentsInChildren<SpringBone>(includeInactive)
				select new
				{
					bone = bone,
					depth = GameObjectUtil.GetTransformDepth(bone.transform)
				}).ToList();
			list.Sort((a, b) => a.depth.CompareTo(b.depth));
			return list.Select(item => item.bone).ToList();
		}
	}
	public static class SpringColliderSerialization
	{
		public class ParsedColliderSetup
		{
			private IEnumerable<IColliderSerializer> colliderRecords;

			private IEnumerable<TransformSerializer> dynamicsNullRecords;

			private List<TextRecordParsing.Record> componentRecords;

			public IEnumerable<DynamicsSetup.ParseMessage> Errors { get; set; }

			public static ParsedColliderSetup ReadColliderSetupFromText(GameObject colliderRoot, string recordText)
			{
				List<TextRecordParsing.Record> list = null;
				List<TextRecordParsing.Record> list2 = null;
				List<TextRecordParsing.Record> list3 = null;
				try
				{
					List<TextRecordParsing.Record> sourceRecords = TextRecordParsing.ParseRecordsFromText(recordText);
					TextRecordParsing.Record versionRecord = null;
					DynamicsSetup.GetVersionFromSetupRecords(sourceRecords, out versionRecord);
					list = TextRecordParsing.GetSectionRecords(sourceRecords, "Colliders");
					if (versionRecord == null && (list == null || list.Count == 0))
					{
						list = TextRecordParsing.GetSectionRecords(sourceRecords, null);
					}
					list2 = TextRecordParsing.GetSectionRecords(sourceRecords, "DynamicsNulls");
					list3 = TextRecordParsing.GetSectionRecords(sourceRecords, "Components");
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError("SpringColliderSetup: 元のテキストデータを読み込めませんでした！\n\n" + ex.ToString());
					return null;
				}
				List<DynamicsSetup.ParseMessage> list4 = new List<DynamicsSetup.ParseMessage>();
				IEnumerable<IColliderSerializer> enumerable = SerializeColliderRecords(list, list4);
				IEnumerable<TransformSerializer> sourceRecords2 = SerializeTransformRecords(list2, list4);
				List<string> list5 = (from item in colliderRoot.GetComponentsInChildren<Transform>(includeInactive: true)
					select item.name).ToList();
				List<TransformSerializer> list6 = new List<TransformSerializer>();
				VerifyTransformRecords(sourceRecords2, list5, list6, list4);
				list5.AddRange(list6.Select((TransformSerializer item) => item.name));
				List<IColliderSerializer> validRecords = new List<IColliderSerializer>();
				VerifyColliderRecords(enumerable, colliderRoot, list5, validRecords, list4);
				return new ParsedColliderSetup
				{
					colliderRecords = validRecords,
					dynamicsNullRecords = list6,
					componentRecords = list3,
					Errors = list4
				};
			}

			public void BuildObjects(GameObject colliderRoot)
			{
				SpringColliderSetup.DestroySpringColliders(colliderRoot);
				Dictionary<string, Transform> objectMap = colliderRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				BuildDynamicsNulls(objectMap, dynamicsNullRecords);
				objectMap = colliderRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				foreach (IColliderSerializer colliderRecord in colliderRecords)
				{
					BuildColliderFromRecord(objectMap, colliderRecord);
				}
				objectMap = colliderRoot.BuildNameToComponentMap<Transform>(includeInactive: true);
				BuildComponents(objectMap, componentRecords);
			}

			public IEnumerable<string> GetColliderNames()
			{
				return colliderRecords.Select((IColliderSerializer item) => item.GetBaseInfo().transform.name);
			}
		}

		private class TransformSerializer
		{
			public string name;

			public string parentName;

			public Vector3 position;

			public Vector3 eulerAngles;

			public Vector3 scale;
		}

		private class ColliderSerializerBaseInfo
		{
			public TransformSerializer transform;

			public string colliderType;
		}

		private interface IColliderSerializer
		{
			ColliderSerializerBaseInfo GetBaseInfo();

			Component BuildColliderComponent(GameObject gameObject);

			string GetLinkedRendererName();
		}

		private class SphereColliderSerializer : IColliderSerializer
		{
			public ColliderSerializerBaseInfo baseInfo;

			public float radius;

			public string linkedRenderer;

			public ColliderSerializerBaseInfo GetBaseInfo()
			{
				return baseInfo;
			}

			public Component BuildColliderComponent(GameObject gameObject)
			{
				SpringSphereCollider springSphereCollider = gameObject.AddComponent<SpringSphereCollider>();
				springSphereCollider.radius = radius;
				if (!string.IsNullOrEmpty(linkedRenderer))
				{
					springSphereCollider.linkedRenderer = TryToFindComponent<Renderer>(gameObject, linkedRenderer);
				}
				return springSphereCollider;
			}

			public string GetLinkedRendererName()
			{
				return linkedRenderer;
			}
		}

		private class CapsuleColliderSerializer : IColliderSerializer
		{
			public ColliderSerializerBaseInfo baseInfo;

			public float radius;

			public float height;

			public string linkedRenderer;

			public ColliderSerializerBaseInfo GetBaseInfo()
			{
				return baseInfo;
			}

			public Component BuildColliderComponent(GameObject gameObject)
			{
				SpringCapsuleCollider springCapsuleCollider = gameObject.AddComponent<SpringCapsuleCollider>();
				springCapsuleCollider.radius = radius;
				springCapsuleCollider.height = height;
				if (!string.IsNullOrEmpty(linkedRenderer))
				{
					springCapsuleCollider.linkedRenderer = TryToFindComponent<Renderer>(gameObject, linkedRenderer);
				}
				return springCapsuleCollider;
			}

			public string GetLinkedRendererName()
			{
				return linkedRenderer;
			}
		}

		private class PanelColliderSerializer : IColliderSerializer
		{
			public ColliderSerializerBaseInfo baseInfo;

			public float width;

			public float height;

			public string linkedRenderer;

			public ColliderSerializerBaseInfo GetBaseInfo()
			{
				return baseInfo;
			}

			public Component BuildColliderComponent(GameObject gameObject)
			{
				SpringPanelCollider springPanelCollider = gameObject.AddComponent<SpringPanelCollider>();
				springPanelCollider.width = width;
				springPanelCollider.height = height;
				if (!string.IsNullOrEmpty(linkedRenderer))
				{
					springPanelCollider.linkedRenderer = TryToFindComponent<Renderer>(gameObject, linkedRenderer);
				}
				return springPanelCollider;
			}

			public string GetLinkedRendererName()
			{
				return linkedRenderer;
			}
		}

		private const string SphereColliderToken = "sp";

		private const string CapsuleColliderToken = "cp";

		private const string PanelColliderToken = "pa";

		public static string BuildCollisionSetupString(GameObject colliderRoot)
		{
			CSVBuilder cSVBuilder = new CSVBuilder();
			AppendColliders(cSVBuilder, colliderRoot);
			AppendDynamicsNulls(cSVBuilder, colliderRoot);
			return cSVBuilder.ToString() + BuildComponentDefinitionString(colliderRoot);
		}

		private static void AppendColliders(CSVBuilder builder, GameObject colliderRoot)
		{
			IEnumerable<SphereColliderSerializer> enumerable = from item in colliderRoot.GetComponentsInChildren<SpringSphereCollider>(includeInactive: true)
				select SphereColliderToSerializer(item);
			IEnumerable<CapsuleColliderSerializer> enumerable2 = from item in colliderRoot.GetComponentsInChildren<SpringCapsuleCollider>(includeInactive: true)
				select CapsuleColliderToSerializer(item);
			IEnumerable<PanelColliderSerializer> enumerable3 = from item in colliderRoot.GetComponentsInChildren<SpringPanelCollider>(includeInactive: true)
				select PanelColliderToSerializer(item);
			if (!enumerable.Any() && !enumerable2.Any() && !enumerable3.Any())
			{
				return;
			}
			string[][] obj = new string[4][]
			{
				new string[13]
				{
					"// ColliderName", "ParentName", "pos x", "y", "z", "rot x", "y", "z", "scale x", "y",
					"z", "ColliderType", "Parameters"
				},
				new string[14]
				{
					"//", "", "", "", "", "", "", "", "", "",
					"", "Sp (Sphere)", "radius", "linkedRenderer"
				},
				new string[15]
				{
					"//", "", "", "", "", "", "", "", "", "",
					"", "Cp (Capsule)", "radius", "height", "linkedRenderer"
				},
				new string[15]
				{
					"//", "", "", "", "", "", "", "", "", "",
					"", "Pa (Panel)", "width", "height", "linkedRenderer"
				}
			};
			builder.AppendLine();
			builder.AppendLine("[Colliders]");
			string[][] array = obj;
			foreach (string[] list in array)
			{
				builder.AppendLine(list);
			}
			foreach (SphereColliderSerializer item in enumerable)
			{
				builder.Append(item);
				builder.AppendLine();
			}
			foreach (CapsuleColliderSerializer item2 in enumerable2)
			{
				builder.Append(item2);
				builder.AppendLine();
			}
			foreach (PanelColliderSerializer item3 in enumerable3)
			{
				builder.Append(item3);
				builder.AppendLine();
			}
		}

		private static string GetComponentName(Component component)
		{
			if (!(component != null))
			{
				return "";
			}
			return component.name;
		}

		private static TransformSerializer TransformToSerializer(Transform sourceTransform)
		{
			return new TransformSerializer
			{
				name = sourceTransform.name,
				parentName = GetComponentName(sourceTransform.parent),
				position = sourceTransform.localPosition,
				eulerAngles = sourceTransform.localEulerAngles,
				scale = sourceTransform.localScale
			};
		}

		private static ColliderSerializerBaseInfo TransformToColliderSerializerBaseInfo(Transform sourceTransform, string colliderType)
		{
			return new ColliderSerializerBaseInfo
			{
				transform = TransformToSerializer(sourceTransform),
				colliderType = colliderType
			};
		}

		private static SphereColliderSerializer SphereColliderToSerializer(SpringSphereCollider sourceCollider)
		{
			return new SphereColliderSerializer
			{
				baseInfo = TransformToColliderSerializerBaseInfo(sourceCollider.transform, "sp"),
				radius = sourceCollider.radius,
				linkedRenderer = GetComponentName(sourceCollider.linkedRenderer)
			};
		}

		private static CapsuleColliderSerializer CapsuleColliderToSerializer(SpringCapsuleCollider sourceCollider)
		{
			return new CapsuleColliderSerializer
			{
				baseInfo = TransformToColliderSerializerBaseInfo(sourceCollider.transform, "cp"),
				radius = sourceCollider.radius,
				height = sourceCollider.height,
				linkedRenderer = GetComponentName(sourceCollider.linkedRenderer)
			};
		}

		private static PanelColliderSerializer PanelColliderToSerializer(SpringPanelCollider sourceCollider)
		{
			return new PanelColliderSerializer
			{
				baseInfo = TransformToColliderSerializerBaseInfo(sourceCollider.transform, "pa"),
				width = sourceCollider.width,
				height = sourceCollider.height,
				linkedRenderer = GetComponentName(sourceCollider.linkedRenderer)
			};
		}

		private static void AppendDynamicsNulls(CSVBuilder builder, GameObject rootObject)
		{
			IEnumerable<TransformSerializer> enumerable = from item in rootObject.GetComponentsInChildren<DynamicsNull>(includeInactive: true)
				select TransformToSerializer(item.transform);
			if (!enumerable.Any())
			{
				return;
			}
			builder.AppendLine();
			builder.AppendLine("[DynamicsNulls]");
			foreach (TransformSerializer item in enumerable)
			{
				builder.Append(item);
				builder.AppendLine();
			}
		}

		private static string BuildComponentDefinitionString(GameObject colliderRoot)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("\n");
			stringBuilder.Append("[Components]");
			stringBuilder.Append("\n");
			IEnumerable<SpringSetupComponentDefiners.ComponentDefiner> componentDefiners = SpringSetupComponentDefiners.GetComponentDefiners();
			Transform[] componentsInChildren = colliderRoot.GetComponentsInChildren<Transform>(includeInactive: true);
			bool flag = false;
			Transform[] array = componentsInChildren;
			foreach (Transform transform in array)
			{
				bool flag2 = false;
				StringBuilder stringBuilder2 = new StringBuilder();
				foreach (SpringSetupComponentDefiners.ComponentDefiner item in componentDefiners)
				{
					if (item.TryToAppendDefinition(stringBuilder2, transform.gameObject))
					{
						flag2 = true;
					}
				}
				if (flag2)
				{
					AppendRecordItem(stringBuilder, transform.name);
					AppendRecordItem(stringBuilder, stringBuilder2.ToString());
					stringBuilder.Append("\n");
					flag = true;
				}
			}
			if (!flag)
			{
				return "";
			}
			return stringBuilder.ToString();
		}

		private static void AppendRecordItem<T>(StringBuilder builder, T item, char separator = ',')
		{
			builder.Append(item);
			builder.Append(separator);
		}

		private static Transform CreateNewGameObject(Transform parent, string name)
		{
			GameObject gameObject = new GameObject(name);
			if (gameObject == null)
			{
				UnityEngine.Debug.LogError("新しいオブジェクトを作成できませんでした: " + name);
				return null;
			}
			gameObject.transform.parent = parent;
			return gameObject.transform;
		}

		private static Transform GetChildByName(Transform parent, string name)
		{
			return (from index in Enumerable.Range(0, parent.childCount)
				select parent.GetChild(index) into child
				where child.name == name
				select child).FirstOrDefault();
		}

		private static T TryToFindComponent<T>(GameObject gameObject, string name) where T : Component
		{
			T result = null;
			if (name.Length > 0)
			{
				return gameObject.transform.root.gameObject.FindChildComponentByName<T>(name);
			}
			return result;
		}

		private static IEnumerable<IColliderSerializer> SerializeColliderRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			Dictionary<string, Type> dictionary = new Dictionary<string, Type>
			{
				{
					"sp",
					typeof(SphereColliderSerializer)
				},
				{
					"cp",
					typeof(CapsuleColliderSerializer)
				},
				{
					"pa",
					typeof(PanelColliderSerializer)
				}
			};
			List<IColliderSerializer> list = new List<IColliderSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				IColliderSerializer colliderSerializer = null;
				DynamicsSetup.ParseMessage error = null;
				ColliderSerializerBaseInfo colliderSerializerBaseInfo = DynamicsSetup.SerializeObjectFromStrings<ColliderSerializerBaseInfo>(sourceRecord.Items, null, ref error);
				if (colliderSerializerBaseInfo != null)
				{
					if (dictionary.TryGetValue(colliderSerializerBaseInfo.colliderType, out var value))
					{
						colliderSerializer = DynamicsSetup.SerializeObjectFromStrings(value, sourceRecord.Items, "linkedRenderer", ref error) as IColliderSerializer;
					}
					else
					{
						error = new DynamicsSetup.ParseMessage("Invalid collider type: " + colliderSerializerBaseInfo.colliderType, sourceRecord.Items);
					}
				}
				if (colliderSerializer != null)
				{
					list.Add(colliderSerializer);
				}
				else
				{
					errorRecords.Add(error);
				}
			}
			return list;
		}

		private static IEnumerable<TransformSerializer> SerializeTransformRecords(IEnumerable<TextRecordParsing.Record> sourceRecords, List<DynamicsSetup.ParseMessage> errorRecords)
		{
			List<TransformSerializer> list = new List<TransformSerializer>(sourceRecords.Count());
			foreach (TextRecordParsing.Record sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				TransformSerializer transformSerializer = DynamicsSetup.SerializeObjectFromStrings<TransformSerializer>(sourceRecord.Items, null, ref error);
				if (transformSerializer != null)
				{
					list.Add(transformSerializer);
				}
				else
				{
					errorRecords.Add(error);
				}
			}
			return list;
		}

		private static bool VerifyTransformRecord(TransformSerializer transformSerializer, IEnumerable<string> validParentNames, out DynamicsSetup.ParseMessage error)
		{
			error = null;
			string name = transformSerializer.name;
			if (name.Length == 0)
			{
				error = new DynamicsSetup.ParseMessage("コライダー名が指定されていないものがあります");
			}
			string parentName = transformSerializer.parentName;
			if (parentName.Length == 0)
			{
				error = new DynamicsSetup.ParseMessage(name + " : 親名が指定されていません");
			}
			else if (!validParentNames.Contains(parentName))
			{
				error = new DynamicsSetup.ParseMessage(name + " : 親が見つかりません: " + parentName);
			}
			return error == null;
		}

		private static bool VerifyTransformRecords(IEnumerable<TransformSerializer> sourceRecords, IEnumerable<string> validParentNames, List<TransformSerializer> validRecords, List<DynamicsSetup.ParseMessage> errors)
		{
			List<TransformSerializer> list = new List<TransformSerializer>(sourceRecords.Count());
			foreach (TransformSerializer sourceRecord in sourceRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				bool flag = VerifyTransformRecord(sourceRecord, validParentNames, out error);
				if (flag && list.Any((TransformSerializer item) => item.name == sourceRecord.name))
				{
					error = new DynamicsSetup.ParseMessage(sourceRecord.name + " : 名前が重複します");
					flag = false;
				}
				if (flag)
				{
					list.Add(sourceRecord);
				}
				else
				{
					errors.Add(error);
				}
			}
			validRecords.AddRange(list);
			return sourceRecords.Count() == list.Count;
		}

		private static bool VerifyColliderRecords(IEnumerable<IColliderSerializer> colliderRecords, GameObject rootObject, IEnumerable<string> validParentNames, List<IColliderSerializer> validRecords, List<DynamicsSetup.ParseMessage> errors)
		{
			List<IColliderSerializer> list = new List<IColliderSerializer>(colliderRecords.Count());
			foreach (IColliderSerializer colliderRecord in colliderRecords)
			{
				DynamicsSetup.ParseMessage error = null;
				string objectName = colliderRecord.GetBaseInfo().transform.name;
				bool flag = true;
				if (!VerifyTransformRecord(colliderRecord.GetBaseInfo().transform, validParentNames, out error))
				{
					flag = false;
				}
				string linkedRendererName = colliderRecord.GetLinkedRendererName();
				if (!string.IsNullOrEmpty(linkedRendererName) && rootObject.FindChildComponentByName<Renderer>(linkedRendererName) == null)
				{
					error = new DynamicsSetup.ParseMessage(objectName + " : linkedRendererが見つかりません: " + linkedRendererName);
					flag = false;
				}
				if (list.Any((IColliderSerializer item) => item.GetBaseInfo().transform.name == objectName))
				{
					error = new DynamicsSetup.ParseMessage(objectName + " : 名前が重複します");
					flag = false;
				}
				if (flag)
				{
					list.Add(colliderRecord);
				}
				else
				{
					errors.Add(error);
				}
			}
			validRecords.AddRange(list);
			return colliderRecords.Count() == list.Count;
		}

		private static GameObject BuildTransformFromRecord(Dictionary<string, Transform> objectMap, TransformSerializer serializer)
		{
			Transform value = null;
			if (!objectMap.TryGetValue(serializer.parentName, out value))
			{
				UnityEngine.Debug.LogError("親が見つかりませんでした: " + serializer.parentName);
				return null;
			}
			Transform transform = GetChildByName(value, serializer.name);
			if (transform == null)
			{
				transform = CreateNewGameObject(value, serializer.name);
				if (transform == null)
				{
					return null;
				}
			}
			transform.localScale = serializer.scale;
			transform.localEulerAngles = serializer.eulerAngles;
			transform.localPosition = serializer.position;
			return transform.gameObject;
		}

		private static bool BuildColliderFromRecord(Dictionary<string, Transform> objectMap, IColliderSerializer colliderSerializer)
		{
			GameObject gameObject = BuildTransformFromRecord(objectMap, colliderSerializer.GetBaseInfo().transform);
			bool num = gameObject != null;
			if (num)
			{
				colliderSerializer.BuildColliderComponent(gameObject);
			}
			return num;
		}

		private static void BuildDynamicsNulls(Dictionary<string, Transform> objectMap, IEnumerable<TransformSerializer> records)
		{
			foreach (Transform value in objectMap.Values)
			{
				DynamicsNull[] components = value.gameObject.GetComponents<DynamicsNull>();
				for (int i = 1; i < components.Length; i++)
				{
					UnityEngine.Object.DestroyImmediate(components[i]);
				}
			}
			foreach (TransformSerializer record in records)
			{
				GameObject gameObject = BuildTransformFromRecord(objectMap, record);
				if (gameObject != null && gameObject.GetComponent<DynamicsNull>() == null)
				{
					gameObject.AddComponent<DynamicsNull>();
				}
			}
		}

		private static void BuildComponents(Dictionary<string, Transform> objectMap, IEnumerable<TextRecordParsing.Record> records)
		{
			IEnumerable<SpringSetupComponentDefiners.ComponentDefiner> componentDefiners = SpringSetupComponentDefiners.GetComponentDefiners();
			foreach (TextRecordParsing.Record record in records)
			{
				Transform value = null;
				if (!objectMap.TryGetValue(record.GetString(0), out value))
				{
					continue;
				}
				GameObject gameObject = value.gameObject;
				Queue<string> definitionItems = new Queue<string>(record.Items.Skip(1));
				foreach (SpringSetupComponentDefiners.ComponentDefiner item in componentDefiners)
				{
					item.BuildFromDefinition(gameObject, definitionItems);
				}
			}
		}
	}
	public static class SpringColliderSetup
	{
		public static IEnumerable<Type> GetColliderTypes()
		{
			return new Type[3]
			{
				typeof(SpringSphereCollider),
				typeof(SpringCapsuleCollider),
				typeof(SpringPanelCollider)
			};
		}

		public static void DestroySpringColliders(GameObject colliderRoot)
		{
			DestroyComponentsOfType<SpringSphereCollider>(colliderRoot);
			DestroyComponentsOfType<SpringCapsuleCollider>(colliderRoot);
			DestroyComponentsOfType<SpringPanelCollider>(colliderRoot);
			SpringBone[] componentsInChildren = colliderRoot.GetComponentsInChildren<SpringBone>(includeInactive: true);
			foreach (SpringBone obj in componentsInChildren)
			{
				obj.sphereColliders = obj.sphereColliders.Where((SpringSphereCollider collider) => collider != null).ToArray();
				obj.capsuleColliders = obj.capsuleColliders.Where((SpringCapsuleCollider collider) => collider != null).ToArray();
				obj.panelColliders = obj.panelColliders.Where((SpringPanelCollider collider) => collider != null).ToArray();
			}
		}

		private static void DestroyComponentsOfType<T>(GameObject rootObject) where T : Component
		{
			T[] componentsInChildren = rootObject.GetComponentsInChildren<T>(includeInactive: true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				DestroyUnityObject(componentsInChildren[i]);
			}
		}

		private static void DestroyUnityObject(UnityEngine.Object objectToDestroy)
		{
			UnityEngine.Object.DestroyImmediate(objectToDestroy);
		}
	}
	public class SpringSetupComponentDefiners
	{
		public class ComponentDefiner
		{
			protected Type componentType;

			public ComponentDefiner(Type newType)
			{
				componentType = newType;
			}

			public bool TryToAppendDefinition(StringBuilder builder, GameObject rootObject)
			{
				Component component = rootObject.GetComponent(componentType);
				bool num = component != null;
				if (num)
				{
					AppendDefinition(builder, component);
				}
				return num;
			}

			public void AppendDefinition(StringBuilder builder, Component component)
			{
				AppendRecordItem(builder, GetTypeToken());
				AppendProperties(builder, component);
			}

			public Component BuildFromDefinition(GameObject owner, Queue<string> definitionItems)
			{
				if (definitionItems.Peek() != GetTypeToken())
				{
					return null;
				}
				definitionItems.Dequeue();
				Component result = null;
				try
				{
					InternalBuildFromDefinition(owner, definitionItems);
				}
				catch (Exception ex)
				{
					UnityEngine.Debug.LogError(GetTypeToken() + " 読み込みエラー\n\n" + ex.ToString());
					result = null;
				}
				return result;
			}

			protected virtual string GetTypeToken()
			{
				return componentType.ToString();
			}

			protected virtual void AppendProperties(StringBuilder builder, Component component)
			{
				IEnumerable<string> source = UnityComponentStringListBuilder.BuildBuilderStringList(component);
				builder.Append(string.Join(",", source.ToArray()));
				builder.Append(",");
			}

			protected static void AppendRecordItem<T>(StringBuilder builder, T item, char separator = ',')
			{
				builder.Append(item);
				builder.Append(separator);
			}

			protected static string GetComponentName(Component component)
			{
				if (!(component != null))
				{
					return "";
				}
				return component.name;
			}

			protected virtual Component InternalBuildFromDefinition(GameObject owner, Queue<string> definitionItems)
			{
				Component[] components = owner.GetComponents(componentType);
				Component component = owner.AddComponent(componentType);
				GameObject gameObject = owner.transform.root.gameObject;
				if (definitionItems.DequeueComponent(component, gameObject))
				{
					Component[] array = components;
					for (int i = 0; i < array.Length; i++)
					{
						UnityEngine.Object.DestroyImmediate(array[i]);
					}
				}
				else
				{
					UnityEngine.Object.DestroyImmediate(component);
					component = null;
				}
				return component;
			}
		}

		public static IEnumerable<ComponentDefiner> GetComponentDefiners()
		{
			return new ComponentDefiner[1]
			{
				new ComponentDefiner(typeof(HighLeg))
			};
		}
	}
	public class SpringBone : MonoBehaviour
	{
		public enum CollisionStatus
		{
			NoCollision,
			HeadIsEmbedded,
			TailCollision
		}

		[Range(0f, 5000f)]
		public float stiffnessForce = 0.01f;

		[Range(0f, 1f)]
		public float dragForce = 0.4f;

		public Vector3 springForce = new Vector3(0f, -0.0001f, 0f);

		[Range(0f, 1f)]
		public float windInfluence = 1f;

		public Transform pivotNode;

		public float angularStiffness = 100f;

		public AngleLimits yAngleLimits = new AngleLimits();

		public AngleLimits zAngleLimits = new AngleLimits();

		public Transform[] lengthLimitTargets;

		[Range(0f, 0.5f)]
		public float radius = 0.05f;

		public SpringSphereCollider[] sphereColliders;

		public SpringCapsuleCollider[] capsuleColliders;

		public SpringPanelCollider[] panelColliders;

		public Transform MyTransform;

		public Transform MyParent;

		private SpringManager manager;

		private Vector3 boneAxis = new Vector3(-1f, 0f, 0f);

		private float springLength;

		private Quaternion skinAnimationLocalRotation;

		private Quaternion initialLocalRotation;

		private Quaternion actualLocalRotation;

		private Vector3 currTipPos;

		private Vector3 prevTipPos;

		private float[] lengthsToLimitTargets;

		private static Vector3 hitNormal = new Vector3(0f, 0f, 1f);

		public Vector3 CurrentTipPosition => currTipPos;

		public void Initialize(SpringManager owner)
		{
			manager = owner;
			MyTransform = base.transform;
			MyParent = MyTransform.parent;
			Vector3 position = ComputeChildPosition();
			boneAxis = MyTransform.InverseTransformPoint(position).normalized;
			initialLocalRotation = MyTransform.localRotation;
			actualLocalRotation = initialLocalRotation;
			sphereColliders = sphereColliders.Where((SpringSphereCollider item) => item != null).ToArray();
			capsuleColliders = capsuleColliders.Where((SpringCapsuleCollider item) => item != null).ToArray();
			panelColliders = panelColliders.Where((SpringPanelCollider item) => item != null).ToArray();
			lengthLimitTargets = ((lengthLimitTargets != null) ? lengthLimitTargets.Where((Transform target) => target != null).ToArray() : new Transform[0]);
			InitializeSpringLengthAndTipPosition();
			if ((object)pivotNode == null)
			{
				pivotNode = MyParent ?? MyTransform;
			}
		}

		public Vector3 ComputeChildPosition()
		{
			IList<Transform> validChildren = GetValidChildren(MyTransform);
			int count = validChildren.Count;
			switch (count)
			{
			case 0:
				UnityEngine.Debug.LogWarning("SpringBone「" + base.name + "」に有効な子供がありません");
				return MyTransform.position + MyTransform.right * -0.1f;
			case 1:
				return validChildren[0].position;
			default:
			{
				Vector3 result = new Vector3(0f, 0f, 0f);
				float num = 0f;
				Vector3 right = MyTransform.position;
				for (int i = 0; i < count; i++)
				{
					Vector3 left = validChildren[i].position;
					result += left;
					num += Vector3Extension.Distance(ref left, ref right);
				}
				num /= (float)count;
				Vector3Extension.DivideOut(count, ref result);
				Vector3 v = Vector3Extension.Subtract(ref result, ref right);
				Vector3Extension.Normalize(ref v);
				Vector3Extension.MultiplyTarget(num, ref v);
				Vector3Extension.Add(ref right, ref v, out result);
				return result;
			}
			}
		}

		public void RemoveAllColliders()
		{
			sphereColliders = new SpringSphereCollider[0];
			capsuleColliders = new SpringCapsuleCollider[0];
			panelColliders = new SpringPanelCollider[0];
		}

		public void UpdateSpring(float deltaTime, Vector3 externalForce)
		{
			skinAnimationLocalRotation = MyTransform.localRotation;
			Vector3 a = MyTransform.position;
			Quaternion rotation = MyParent.rotation * initialLocalRotation;
			Vector3 target = Vector3Extension.Multiply(ref boneAxis, springLength);
			Vector3Extension.MultiplyTarget(ref rotation, ref target);
			Vector3 a2 = Vector3Extension.Add(ref a, ref target);
			Vector3Extension.Subtract(ref a2, ref currTipPos, out target);
			Vector3 result = default(Vector3);
			Vector3Extension.Multiply(ref target, stiffnessForce, out result);
			AddVectors(ref springForce, ref externalForce, ref result);
			float num = deltaTime * deltaTime;
			Vector3Extension.Multiply(ref result, 0.5f * num, out result);
			Vector3 vector = currTipPos;
			Vector3Extension.Subtract(ref currTipPos, ref prevTipPos, out target);
			target.Multiply(1f - dragForce);
			result.Add(ref target);
			currTipPos = Vector3Extension.Add(ref currTipPos, ref result);
			prevTipPos = vector;
			Vector3 a3 = Vector3Extension.Subtract(ref currTipPos, ref a);
			float num2 = a3.Length();
			a3 = ((num2 <= 0.001f) ? MyTransform.TransformDirection(boneAxis) : Vector3Extension.Divide(ref a3, num2));
			a3 = Vector3Extension.Multiply(ref a3, springLength);
			Vector3Extension.Add(ref a, ref a3, out currTipPos);
		}

		private void AddVectors(ref Vector3 left, ref Vector3 right, ref Vector3 target)
		{
			target.x += left.x + right.x;
			target.y += left.y + right.y;
			target.z += left.z + right.z;
		}

		public void SatisfyConstraintsAndComputeRotation(float deltaTime, float dynamicRatio)
		{
			if (manager.enableLengthLimits)
			{
				currTipPos = ApplyLengthLimits(deltaTime);
			}
			bool flag = false;
			if (manager.collideWithGround)
			{
				flag = CheckForGroundCollision();
			}
			if (manager.enableCollision && !flag)
			{
				flag = CheckForCollision();
			}
			if (manager.enableAngleLimits)
			{
				ApplyAngleLimits(deltaTime);
			}
			if (float.IsNaN(currTipPos.x) | float.IsNaN(currTipPos.y) | float.IsNaN(currTipPos.z))
			{
				Vector3 b = MyParent.rotation * initialLocalRotation * boneAxis * springLength;
				Vector3 a = MyTransform.position;
				Vector3Extension.Add(ref a, ref b, out currTipPos);
				prevTipPos = currTipPos;
			}
			actualLocalRotation = ComputeRotation(ref currTipPos);
			MyTransform.localRotation = Quaternion.Lerp(skinAnimationLocalRotation, actualLocalRotation, dynamicRatio);
		}

		public void ComputeRotation(float dynamicRatio)
		{
			if (float.IsNaN(currTipPos.x) | float.IsNaN(currTipPos.y) | float.IsNaN(currTipPos.z))
			{
				Quaternion quaternion = MyParent.rotation * initialLocalRotation;
				currTipPos = MyTransform.position + quaternion * Vector3Extension.Multiply(ref boneAxis, springLength);
				prevTipPos = currTipPos;
			}
			actualLocalRotation = ComputeRotation(ref currTipPos);
			MyTransform.localRotation = Quaternion.Lerp(skinAnimationLocalRotation, actualLocalRotation, dynamicRatio);
		}

		public Transform GetPivotTransform()
		{
			if ((object)pivotNode == null)
			{
				pivotNode = MyParent ?? MyTransform;
			}
			return pivotNode;
		}

		private static IList<Transform> GetValidChildren(Transform parent)
		{
			int childCount = parent.childCount;
			List<Transform> list = new List<Transform>(childCount);
			for (int i = 0; i < childCount; i++)
			{
				Transform child = parent.GetChild(i);
				if (child.GetComponent<SpringBonePivot>() == null)
				{
					list.Add(child);
				}
			}
			return list;
		}

		private void ApplyAngleLimits(float deltaTime)
		{
			if (yAngleLimits.active || zAngleLimits.active)
			{
				Vector3 b = MyTransform.position;
				Vector3 vector = Vector3Extension.Subtract(ref currTipPos, ref b);
				Quaternion rotation = pivotNode.rotation;
				Vector3 a = rotation.CreateRight();
				Vector3 basisForward = Vector3Extension.Multiply(ref a, -1f);
				Vector3 target = rotation.CreateUp();
				Vector3Extension.MultiplyTarget(-1f, ref target);
				Vector3 target2 = rotation.CreateForward();
				Vector3Extension.MultiplyTarget(-1f, ref target2);
				if (yAngleLimits.active)
				{
					yAngleLimits.ConstrainVector(ref target, ref target2, ref basisForward, angularStiffness, deltaTime, ref vector);
				}
				if (zAngleLimits.active)
				{
					zAngleLimits.ConstrainVector(ref target2, ref target, ref basisForward, angularStiffness, deltaTime, ref vector);
				}
				Vector3Extension.Add(ref b, ref vector, out currTipPos);
			}
		}

		private bool CheckForCollision()
		{
			Vector3 a = currTipPos;
			Vector3 headPosition = MyTransform.position;
			float num = MyTransform.TransformDirection(radius, 0f, 0f).Length();
			bool flag = IsCapsuleCollision(ref headPosition, ref currTipPos, num, ref hitNormal);
			if (!flag)
			{
				flag = IsSphereCollision(ref headPosition, ref currTipPos, num, ref hitNormal);
				if (!flag)
				{
					flag = IsPanelCollision(ref headPosition, springLength, ref currTipPos, num, ref hitNormal);
				}
			}
			if (flag)
			{
				Vector3 inDirection = Vector3Extension.Subtract(ref a, ref prevTipPos);
				Vector3 a2 = Vector3Extension.Reflect(ref inDirection, ref hitNormal);
				float d = Vector3.Dot(a2, hitNormal);
				Vector3 b = Vector3Extension.Multiply(ref hitNormal, d);
				Vector3 target = Vector3Extension.Subtract(ref a2, ref b);
				Vector3Extension.MultiplyTarget(1f - manager.friction, ref target);
				Vector3Extension.MultiplyTarget(manager.bounce, ref b);
				Vector3 b2 = Vector3Extension.Add(ref b, ref target);
				if (b2.LengthSquared() > 0.0001f)
				{
					float num2 = Vector3Extension.Distance(ref currTipPos, ref prevTipPos);
					prevTipPos = Vector3Extension.Subtract(ref currTipPos, ref b2);
					float amount = b2.Length() - num2;
					Vector3Extension.Normalize(ref b2);
					Vector3Extension.MultiplyTarget(amount, ref b2);
					Vector3Extension.AddTarget(ref currTipPos, ref b2);
				}
				else
				{
					prevTipPos = currTipPos;
				}
			}
			return flag;
		}

		private bool IsCapsuleCollision(ref Vector3 headPosition, ref Vector3 currTipPos, float scaledRadius, ref Vector3 hitNormal)
		{
			int num = capsuleColliders.Length;
			for (int i = 0; i < num; i++)
			{
				SpringCapsuleCollider springCapsuleCollider = capsuleColliders[i];
				if (springCapsuleCollider.enabled && springCapsuleCollider.CheckForCollisionAndReact(ref headPosition, ref currTipPos, scaledRadius, ref hitNormal) != 0)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsSphereCollision(ref Vector3 headPosition, ref Vector3 currTipPos, float scaledRadius, ref Vector3 hitNormal)
		{
			int num = sphereColliders.Length;
			for (int i = 0; i < num; i++)
			{
				SpringSphereCollider springSphereCollider = sphereColliders[i];
				if (springSphereCollider.enabled && springSphereCollider.CheckForCollisionAndReact(ref headPosition, ref currTipPos, scaledRadius, ref hitNormal) != 0)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsPanelCollision(ref Vector3 headPosition, float length, ref Vector3 tailPosition, float tailRadius, ref Vector3 hitNormal)
		{
			int num = panelColliders.Length;
			for (int i = 0; i < num; i++)
			{
				SpringPanelCollider springPanelCollider = panelColliders[i];
				if (springPanelCollider.enabled && springPanelCollider.CheckForCollisionAndReact(ref headPosition, springLength, ref currTipPos, tailRadius, ref hitNormal) != 0)
				{
					return true;
				}
			}
			return false;
		}

		private bool CheckForGroundCollision()
		{
			Vector3 headPosition = MyTransform.position;
			Vector3 right = headPosition;
			Vector3 tailPosition = currTipPos;
			float localTailRadius = MyTransform.TransformDirection(radius, 0f, 0f).Length();
			float localLength = Vector3Extension.Distance(ref currTipPos, ref right);
			float groundHeight = manager.groundHeight;
			right.y -= groundHeight;
			tailPosition.y -= groundHeight;
			CollisionStatus num = SpringPanelCollider.CheckForCollisionWithAlignedPlaneAndReact(ref right, localLength, ref tailPosition, localTailRadius, SpringPanelCollider.Axis.Y);
			if (num != 0)
			{
				tailPosition.y += groundHeight;
				currTipPos = FixBoneLength(ref headPosition, ref tailPosition, 0.5f * springLength, springLength);
				prevTipPos = currTipPos;
			}
			return num != CollisionStatus.NoCollision;
		}

		private Vector3 FixBoneLength(ref Vector3 headPosition, ref Vector3 tailPosition, float minLength, float maxLength)
		{
			Vector3 a = Vector3Extension.Subtract(ref tailPosition, ref headPosition);
			float num = a.Length();
			if (num <= 0.001f)
			{
				Vector3 target = MyTransform.TransformDirection(boneAxis);
				Vector3Extension.MultiplyTarget(minLength, ref target);
				return Vector3Extension.Add(ref headPosition, ref target);
			}
			float num2 = ((num < minLength) ? minLength : num);
			num2 = ((num2 > maxLength) ? maxLength : num2);
			Vector3 addTo = Vector3Extension.Multiply(ref a, num2 / num);
			Vector3Extension.AddTarget(ref addTo, ref headPosition);
			return addTo;
		}

		private void InitializeSpringLengthAndTipPosition()
		{
			Vector3 left = MyTransform.position;
			Vector3 right = ComputeChildPosition();
			springLength = Vector3Extension.Distance(ref left, ref right);
			currTipPos = right;
			prevTipPos = right;
			int num = lengthLimitTargets.Length;
			lengthsToLimitTargets = new float[num];
			for (int i = 0; i < num; i++)
			{
				Vector3 left2 = lengthLimitTargets[i].position;
				lengthsToLimitTargets[i] = Vector3Extension.Distance(ref left2, ref right);
			}
		}

		private Quaternion ComputeRotation(ref Vector3 tipPosition)
		{
			Vector3 b = MyTransform.position;
			Quaternion rotation = MyParent.rotation * initialLocalRotation;
			Vector3 vector = Vector3Extension.Subtract(ref tipPosition, ref b);
			Vector3 v = Quaternion.Inverse(rotation) * vector;
			Vector3Extension.Normalize(ref v);
			Quaternion quaternion = Quaternion.FromToRotation(boneAxis, v);
			return initialLocalRotation * quaternion;
		}

		private Vector3 ApplyLengthLimits(float deltaTime)
		{
			int num = lengthLimitTargets.Length;
			if (num == 0)
			{
				return currTipPos;
			}
			float num2 = 0.5f * deltaTime * deltaTime;
			Vector3 target = new Vector3(0f, 0f, 0f);
			for (int i = 0; i < num; i++)
			{
				Vector3 b = lengthLimitTargets[i].position;
				float num3 = lengthsToLimitTargets[i];
				Vector3 v = Vector3Extension.Subtract(ref currTipPos, ref b);
				float num4 = (float)Math.Sqrt(v.LengthSquared()) - num3;
				Vector3Extension.Normalize(ref v);
				Vector3Extension.MultiplyTarget(num2 * num4, ref v);
				Vector3Extension.SubtractTarget(ref target, ref v);
			}
			return Vector3Extension.Add(ref currTipPos, ref target);
		}
	}
	public class SpringBonePivot : MonoBehaviour
	{
	}
	public class SpringManager : MonoBehaviour
	{
		[Header("Properties")]
		public bool automaticUpdates = true;

		public bool isPaused;

		public int simulationFrameRate = 60;

		[Range(0f, 1f)]
		public float dynamicRatio = 0.5f;

		public Vector3 gravity = new Vector3(0f, -10f, 0f);

		[Range(0f, 1f)]
		public float bounce;

		[Range(0f, 1f)]
		public float friction = 1f;

		[Header("Constraints")]
		public bool enableAngleLimits = true;

		public bool enableCollision = true;

		public bool enableLengthLimits = true;

		[Header("Ground Collision")]
		public bool collideWithGround = true;

		public float groundHeight;

		[Header("Bones")]
		public SpringBone[] springBones;

		private bool[] boneIsAnimatedStates;

		private ForceProvider[] forceProviders;

		public void CleanUpBoneColliders()
		{
			SpringBone[] array = springBones;
			foreach (SpringBone obj in array)
			{
				obj.sphereColliders = obj.sphereColliders.Where((SpringSphereCollider collider) => collider != null).ToArray();
				obj.capsuleColliders = obj.capsuleColliders.Where((SpringCapsuleCollider collider) => collider != null).ToArray();
				obj.panelColliders = obj.panelColliders.Where((SpringPanelCollider collider) => collider != null).ToArray();
			}
		}

		public void FindSpringBones(bool includeInactive = false)
		{
			var list = (from bone in GetComponentsInChildren<SpringBone>(includeInactive)
				select new
				{
					bone = bone,
					depth = GetObjectDepth(bone.transform)
				}).ToList();
			list.Sort((a, b) => a.depth.CompareTo(b.depth));
			springBones = list.Select(item => item.bone).ToArray();
		}

		public void UpdateBoneIsAnimatedStates(IList<string> animatedBoneNames)
		{
			if (boneIsAnimatedStates == null || boneIsAnimatedStates.Length != springBones.Length)
			{
				boneIsAnimatedStates = new bool[springBones.Length];
			}
			int num = springBones.Length;
			for (int i = 0; i < num; i++)
			{
				boneIsAnimatedStates[i] = animatedBoneNames.Contains(springBones[i].name);
			}
		}

		public void UpdateDynamics()
		{
			int num = springBones.Length;
			if (isPaused)
			{
				for (int i = 0; i < num; i++)
				{
					SpringBone springBone = springBones[i];
					if (springBone.enabled)
					{
						springBone.ComputeRotation(boneIsAnimatedStates[i] ? dynamicRatio : 1f);
					}
				}
				return;
			}
			float deltaTime = ((simulationFrameRate > 0) ? (1f / (float)simulationFrameRate) : Time.deltaTime);
			for (int j = 0; j < num; j++)
			{
				SpringBone springBone2 = springBones[j];
				if (springBone2.enabled)
				{
					Vector3 sumOfForcesOnBone = GetSumOfForcesOnBone(springBone2);
					springBone2.UpdateSpring(deltaTime, sumOfForcesOnBone);
					springBone2.SatisfyConstraintsAndComputeRotation(deltaTime, boneIsAnimatedStates[j] ? dynamicRatio : 1f);
				}
			}
		}

		private static int GetObjectDepth(Transform inObject)
		{
			int num = 0;
			Transform transform = inObject;
			while (transform != null)
			{
				transform = transform.parent;
				num++;
			}
			return num;
		}

		private Vector3 GetSumOfForcesOnBone(SpringBone springBone)
		{
			Vector3 result = gravity;
			int num = forceProviders.Length;
			for (int i = 0; i < num; i++)
			{
				ForceProvider forceProvider = forceProviders[i];
				if (forceProvider.isActiveAndEnabled)
				{
					result += forceProvider.GetForceOnBone(springBone);
				}
			}
			return result;
		}

		private void Awake()
		{
			FindSpringBones(includeInactive: true);
			int num = springBones.Length;
			for (int i = 0; i < num; i++)
			{
				springBones[i].Initialize(this);
			}
			if (boneIsAnimatedStates == null || boneIsAnimatedStates.Length != num)
			{
				boneIsAnimatedStates = new bool[num];
			}
		}

		private void Start()
		{
			forceProviders = GameObjectUtil.FindComponentsOfType<ForceProvider>().ToArray();
		}

		private void LateUpdate()
		{
			if (automaticUpdates)
			{
				UpdateDynamics();
			}
		}
	}
	public class CSVBuilder
	{
		private StringBuilder builder;

		private char separatorCharacter;

		private string currentSeparator;

		public CSVBuilder(char newSeparatorCharacter = ',')
		{
			builder = new StringBuilder();
			separatorCharacter = newSeparatorCharacter;
			currentSeparator = "";
		}

		public void Append(string item)
		{
			builder.Append(currentSeparator);
			if (item == null)
			{
				item = "";
			}
			builder.Append(CSVUtilities.BuildCSVItem(item));
			currentSeparator = separatorCharacter.ToString();
		}

		public void Append(GameObject gameObject)
		{
			if (!(gameObject == null))
			{
				Append(gameObject.name);
				Component[] components = gameObject.GetComponents<Component>();
				Append(components.Length.ToString());
				Component[] array = components;
				foreach (Component component in array)
				{
					Append(component.GetType().ToString());
					Append(component);
				}
			}
		}

		public void Append(object item)
		{
			if (item == null)
			{
				return;
			}
			Type type = item.GetType();
			if (type == typeof(Transform))
			{
				Append(item as Transform);
			}
			else if (!type.IsPrimitive && !type.IsEnum)
			{
				BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
				FieldInfo[] fields = type.GetFields(bindingAttr);
				foreach (FieldInfo fieldInfo in fields)
				{
					InternalAppend(fieldInfo.FieldType, fieldInfo.GetValue(item));
				}
			}
			else
			{
				InternalAppend(type, item);
			}
		}

		public void Append(Vector3 vector)
		{
			Append(vector.x);
			Append(vector.y);
			Append(vector.z);
		}

		public void Append(Transform transform)
		{
			if (!(transform == null))
			{
				Append((transform.parent != null) ? transform.parent.name : "");
				Append(transform.localPosition);
				Append(transform.localRotation.eulerAngles);
				Append(transform.localScale);
			}
		}

		public void Append(IEnumerable<string> list)
		{
			foreach (string item in list)
			{
				Append(item);
			}
		}

		public void AppendLine()
		{
			builder.AppendLine();
			currentSeparator = "";
		}

		public void AppendLine(string item)
		{
			Append(item);
			AppendLine();
		}

		public void AppendLine(IEnumerable<string> list)
		{
			Append(list);
			AppendLine();
		}

		public override string ToString()
		{
			return builder.ToString();
		}

		private void InternalAppend(Type itemType, object item)
		{
			if (itemType.IsPrimitive || itemType.IsEnum || itemType == typeof(string))
			{
				Append(item.ToString());
			}
			else if (itemType.IsSubclassOf(typeof(UnityEngine.Object)))
			{
				UnityEngine.Object @object = item as UnityEngine.Object;
				Append((@object != null) ? @object.name : "");
			}
			else if (itemType.IsArray)
			{
				if (item is Array array && itemType.GetArrayRank() <= 1)
				{
					List<object> list = new List<object>();
					foreach (object item2 in array)
					{
						if (item2 != null)
						{
							list.Add(item2);
						}
					}
					Append(list.Count.ToString());
					{
						foreach (object item3 in list)
						{
							InternalAppend(itemType.GetElementType(), item3);
						}
						return;
					}
				}
				Append("0");
			}
			else
			{
				BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
				FieldInfo[] fields = itemType.GetFields(bindingAttr);
				foreach (FieldInfo fieldInfo in fields)
				{
					InternalAppend(fieldInfo.FieldType, fieldInfo.GetValue(item));
				}
			}
		}
	}
	public static class CSVUtilities
	{
		private const string DefaultSeparators = ",\t";

		public static string BuildCSVItem(string source)
		{
			return BuildCSVItem(source, ",\t");
		}

		public static string BuildCSVItem(string source, string separatorCharacters)
		{
			if (("\"\r\n" + separatorCharacters).ToCharArray().Any((char token) => source.Contains(token)))
			{
				return "\"" + source.Replace("\"", "\"\"") + "\"";
			}
			return source;
		}

		public static IList<string> ReadNextCSVRow(TextReader reader)
		{
			return ReadNextCSVRow(reader, ",\t");
		}

		public static IList<string> ReadNextCSVRow(TextReader reader, string separatorCharacters)
		{
			if (reader.Peek() == -1)
			{
				return new List<string>();
			}
			List<string> list = new List<string>();
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = false;
			bool flag2 = false;
			while (!flag2)
			{
				flag2 = reader.Peek() == -1;
				bool flag3 = flag2;
				if (!flag2)
				{
					char c = (char)reader.Read();
					if (!flag)
					{
						flag2 = c == '\r' || c == '\n';
						if (c == '\r' && (ushort)reader.Peek() == 10)
						{
							reader.Read();
						}
						flag3 = flag2 || separatorCharacters.Contains(c);
						if (!flag3)
						{
							if (c == '"')
							{
								flag = true;
							}
							else
							{
								stringBuilder.Append(c);
							}
						}
					}
					else if (c == '"')
					{
						int num = reader.Peek();
						if (num != -1 && (ushort)num == 34)
						{
							stringBuilder.Append('"');
							reader.Read();
						}
						else
						{
							flag = false;
						}
					}
					else
					{
						stringBuilder.Append(c);
					}
				}
				bool flag4 = flag2 && list.Count == 0 && stringBuilder.Length == 0;
				if (flag3 && !flag4)
				{
					list.Add(stringBuilder.ToString());
					stringBuilder.Length = 0;
				}
			}
			return list;
		}
	}
	public class DirectoryUtil
	{
		public static string[] GetDirectories(string path, string searchPattern = "*")
		{
			string[] array = null;
			try
			{
				array = Directory.GetDirectories(path, searchPattern);
			}
			catch (DirectoryNotFoundException ex)
			{
				UnityEngine.Debug.LogError(path + "\nディレクトリーが見つかりません\n\n" + ex.ToString());
			}
			catch (PathTooLongException ex2)
			{
				UnityEngine.Debug.LogError(path + "\nパスが長すぎます\n\n" + ex2.ToString());
			}
			catch (IOException ex3)
			{
				UnityEngine.Debug.LogError(path + "\nディレクトリーにアクセスできませんでした\n\n" + ex3.ToString());
			}
			catch (UnauthorizedAccessException ex4)
			{
				UnityEngine.Debug.LogError(path + "\nディレクトリーにアクセスする権限がありません\n\n" + ex4.ToString());
			}
			if (array == null)
			{
				array = new string[0];
			}
			return array;
		}

		public static IEnumerable<string> GetFilesRecursively(string path, string searchPattern = "*.*")
		{
			List<string> list = new List<string>();
			GetFilesRecursively(path, searchPattern, list);
			return list;
		}

		public static void GetFilesRecursively(string path, string searchPattern, List<string> files)
		{
			files.AddRange(GetFiles(path, searchPattern));
			string[] directories = GetDirectories(path);
			for (int i = 0; i < directories.Length; i++)
			{
				GetFilesRecursively(directories[i], searchPattern, files);
			}
		}

		public static string[] GetFiles(string path, string searchPattern = "*.*")
		{
			string[] array = null;
			try
			{
				array = Directory.GetFiles(path, searchPattern);
			}
			catch (DirectoryNotFoundException ex)
			{
				UnityEngine.Debug.LogError(path + "\nディレクトリーが見つかりません\n\n" + ex.ToString());
			}
			catch (PathTooLongException ex2)
			{
				UnityEngine.Debug.LogError(path + "\nパスが長すぎます\n\n" + ex2.ToString());
			}
			catch (IOException ex3)
			{
				UnityEngine.Debug.LogError(path + "\nディレクトリーにアクセスできませんでした\n\n" + ex3.ToString());
			}
			catch (UnauthorizedAccessException ex4)
			{
				UnityEngine.Debug.LogError(path + "\nディレクトリーにアクセスする権限がありません\n\n" + ex4.ToString());
			}
			if (array == null)
			{
				array = new string[0];
			}
			return array;
		}

		public static bool TryToCreateDirectory(string directoryName)
		{
			directoryName = PathUtil.NormalizePath(directoryName);
			if (Directory.Exists(directoryName))
			{
				return true;
			}
			bool flag = false;
			string text = "";
			try
			{
				Directory.CreateDirectory(directoryName);
				flag = true;
			}
			catch (IOException)
			{
				text = "Path is invalid";
			}
			catch (UnauthorizedAccessException)
			{
				text = "Access denied";
			}
			catch (ArgumentException)
			{
				text = ((directoryName.Length == 0) ? "Path is empty" : "Path contains invalid characters");
			}
			catch (NotSupportedException)
			{
				text = "Path is not supported";
			}
			if (!flag)
			{
				UnityEngine.Debug.LogError("Unable to create directory: " + directoryName + "\n" + text);
			}
			return flag;
		}
	}
	public class FileUtil
	{
		public static string ReadAllText(string inFilePath, Encoding inDefaultEncoding)
		{
			string text = "";
			Encoding encoding = TryToDetectEncoding(inFilePath, inDefaultEncoding);
			try
			{
				return File.ReadAllText(inFilePath, encoding);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("ReadAllText failed\n" + inFilePath + "\n\n" + ex.ToString());
				return "";
			}
		}

		public static string ReadAllText(string inFilePath)
		{
			return ReadAllText(inFilePath, TryToDetectEncoding(inFilePath, Encoding.Default));
		}

		public static string[] ReadAllLines(string inFilePath, Encoding inDefaultEncoding)
		{
			string[] array = new string[0];
			Encoding encoding = TryToDetectEncoding(inFilePath, inDefaultEncoding);
			try
			{
				return File.ReadAllLines(inFilePath, encoding);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("ReadAllLines failed\n" + inFilePath + "\n\n" + ex.ToString());
				return new string[0];
			}
		}

		public static string[] ReadAllLines(string inFilePath)
		{
			return ReadAllLines(inFilePath, TryToDetectEncoding(inFilePath, Encoding.Default));
		}

		public static bool WriteAllText(string filePath, string text, Encoding encoding = null)
		{
			if (encoding == null)
			{
				encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
			}
			bool flag = false;
			try
			{
				File.WriteAllText(filePath, text, encoding);
				return true;
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("保存失敗: " + filePath + "\n" + ex.ToString());
				return false;
			}
		}

		public static Encoding TryToDetectEncoding(string inFilePath, Encoding inDefaultEncoding)
		{
			byte[] key = new byte[3] { 239, 187, 191 };
			byte[] key2 = new byte[2] { 255, 254 };
			byte[] key3 = new byte[2] { 254, 255 };
			byte[] key4 = new byte[4] { 60, 63, 120, 109 };
			byte[] key5 = new byte[2] { 60, 0 };
			byte[] key6 = new byte[2] { 0, 60 };
			Dictionary<byte[], Encoding> obj = new Dictionary<byte[], Encoding>
			{
				[key] = Encoding.UTF8,
				[key2] = Encoding.Unicode,
				[key3] = Encoding.BigEndianUnicode,
				[key4] = Encoding.UTF8,
				[key5] = Encoding.Unicode,
				[key6] = Encoding.BigEndianUnicode
			};
			byte[] inBuffer = ReadFirstBytesOfFile(inFilePath, 4);
			foreach (KeyValuePair<byte[], Encoding> item in obj)
			{
				if (CheckIfBufferStartsWithHeader(inBuffer, item.Key))
				{
					return item.Value;
				}
			}
			return inDefaultEncoding;
		}

		public static Encoding TryToDetectEncoding(string inFilePath)
		{
			return TryToDetectEncoding(inFilePath, Encoding.Default);
		}

		public static void ExploreToDirectory(string directory)
		{
		}

		private static byte[] ReadFirstBytesOfFile(string inFilePath, int inNumBytesToRead)
		{
			byte[] array = new byte[inNumBytesToRead];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = 0;
			}
			FileStream fileStream = null;
			try
			{
				fileStream = new FileStream(inFilePath, FileMode.Open, FileAccess.Read);
				fileStream.Read(array, 0, inNumBytesToRead);
			}
			catch
			{
			}
			fileStream?.Dispose();
			return array;
		}

		private static bool CheckIfBufferStartsWithHeader(byte[] inBuffer, byte[] inHeader)
		{
			if (inBuffer.Length < inHeader.Length)
			{
				return false;
			}
			for (int i = 0; i < inHeader.Length; i++)
			{
				if (inBuffer[i] != inHeader[i])
				{
					return false;
				}
			}
			return true;
		}
	}
	public class GizmoUtil
	{
		public static void DrawArrow(Vector3 origin, Vector3 destination, Color color, float headRatio = 0.05f)
		{
			Gizmos.color = color;
			Gizmos.DrawLine(origin, destination);
			Vector3 vector = destination - origin;
			Vector3 vector2 = destination - headRatio * vector;
			Vector3 vector3 = 0.5f * headRatio * new Vector3(vector.y, vector.z, vector.x);
			Gizmos.DrawLine(destination, vector2 + vector3);
			Gizmos.DrawLine(destination, vector2 - vector3);
		}

		public static void DrawTransform(Transform transform, float drawScale, float headRatio = 0.05f)
		{
			if (transform != null)
			{
				DrawTransform(transform.position, transform.right, transform.up, transform.forward, drawScale, headRatio);
			}
		}

		public static void DrawTransform(Vector3 origin, Transform orientation, float drawScale, float headRatio = 0.05f)
		{
			if (orientation != null)
			{
				DrawTransform(origin, orientation.right, orientation.up, orientation.forward, drawScale, headRatio);
			}
		}

		public static void DrawTransform(Vector3 origin, Vector3 right, Vector3 up, Vector3 forward, float drawScale, float headRatio = 0.05f)
		{
			Color red = Color.red;
			Color green = Color.green;
			Color color = new Color(0f, 0.9f, 1f);
			DrawArrow(origin, origin + drawScale * right, red, headRatio);
			DrawArrow(origin, origin + drawScale * up, green, headRatio);
			DrawArrow(origin, origin + drawScale * forward, color, headRatio);
		}
	}
	public class TypedStringToValueMap
	{
		private Dictionary<string, object> map;

		public Type Type { get; private set; }

		public object DefaultValue { get; private set; }

		public object this[string key]
		{
			get
			{
				object value = DefaultValue;
				if (!map.TryGetValue(key, out value))
				{
					value = DefaultValue;
					UnityEngine.Debug.LogError("Value not found: " + key);
				}
				return value;
			}
		}

		public TypedStringToValueMap(Type inputType, Dictionary<string, object> inputMap, object inputDefaultValue)
		{
			Type = inputType;
			map = inputMap;
			DefaultValue = inputDefaultValue;
		}

		public static TypedStringToValueMap Create<T>(Dictionary<string, T> inputMap, T inputDefaultValue)
		{
			Dictionary<string, object> inputMap2 = ((IEnumerable<KeyValuePair<string, T>>)inputMap).ToDictionary((Func<KeyValuePair<string, T>, string>)((KeyValuePair<string, T> item) => item.Key), (Func<KeyValuePair<string, T>, object>)((KeyValuePair<string, T> item) => item.Value));
			return new TypedStringToValueMap(typeof(T), inputMap2, inputDefaultValue);
		}

		public static TypedStringToValueMap Create<T>(Dictionary<string, T> inputMap)
		{
			Dictionary<string, object> inputMap2 = ((IEnumerable<KeyValuePair<string, T>>)inputMap).ToDictionary((Func<KeyValuePair<string, T>, string>)((KeyValuePair<string, T> item) => item.Key), (Func<KeyValuePair<string, T>, object>)((KeyValuePair<string, T> item) => item.Value));
			return new TypedStringToValueMap(typeof(T), inputMap2, default(T));
		}

		public string GetKey(object value)
		{
			string text = (from item in map
				where item.Value == value
				select item.Key).FirstOrDefault();
			if (text == null)
			{
				return "";
			}
			return text;
		}
	}
	public static class UnityComponentStringListBuilder
	{
		public static void BuildBuilderStringList(object sourceObject, List<string> outputStrings, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			Type type = sourceObject.GetType();
			if (type.IsSubclassOf(typeof(Component)))
			{
				ConvertFieldsToStrings(sourceObject, type, valueMaps, outputStrings);
			}
			else
			{
				ConvertObjectToStrings(sourceObject, type, valueMaps, outputStrings);
			}
		}

		public static IEnumerable<string> BuildBuilderStringList(object sourceObject, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			List<string> list = new List<string>();
			BuildBuilderStringList(sourceObject, list, valueMaps);
			return list;
		}

		public static IEnumerable<string> BuildBuilderStringList(object sourceObject, TypedStringToValueMap valueMap)
		{
			return BuildBuilderStringList(sourceObject, new TypedStringToValueMap[1] { valueMap });
		}

		private static void ConvertFieldsToStrings(object sourceObject, Type type, IEnumerable<TypedStringToValueMap> valueMaps, List<string> outputStrings)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			FieldInfo[] fields = type.GetFields(bindingAttr);
			foreach (FieldInfo fieldInfo in fields)
			{
				ConvertObjectToStrings(fieldInfo.GetValue(sourceObject), fieldInfo.FieldType, valueMaps, outputStrings);
			}
		}

		private static void ConvertObjectToStrings(object sourceObject, Type type, IEnumerable<TypedStringToValueMap> valueMaps, List<string> outputStrings)
		{
			if (valueMaps != null)
			{
				TypedStringToValueMap typedStringToValueMap = valueMaps.Where((TypedStringToValueMap map) => map.Type == type).FirstOrDefault();
				if (typedStringToValueMap != null)
				{
					outputStrings.Add(typedStringToValueMap.GetKey(sourceObject));
					return;
				}
			}
			if (type.IsArray)
			{
				if (sourceObject != null)
				{
					MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public);
					int num = (int)methods.Where((MethodInfo method) => method.Name == "GetLength").First().Invoke(sourceObject, new object[1] { 0 });
					MethodInfo methodInfo = methods.Where((MethodInfo method) => method.Name == "GetValue" && method.GetParameters().Count() == 1 && method.GetParameters()[0].ParameterType == typeof(int)).First();
					List<object> list = new List<object>(num);
					for (int i = 0; i < num; i++)
					{
						object obj = methodInfo.Invoke(sourceObject, new object[1] { i });
						if (obj != null)
						{
							list.Add(obj);
						}
					}
					outputStrings.Add(list.Count.ToString());
					Type elementType = type.GetElementType();
					{
						foreach (object item in list)
						{
							ConvertObjectToStrings(item, elementType, valueMaps, outputStrings);
						}
						return;
					}
				}
				outputStrings.Add(0.ToString());
			}
			else if (sourceObject == null)
			{
				outputStrings.Add("");
			}
			else if (type.IsPrimitive)
			{
				outputStrings.Add(sourceObject.ToString());
			}
			else if (type.IsEnum)
			{
				outputStrings.Add(sourceObject.ToString());
			}
			else if (type == typeof(string))
			{
				outputStrings.Add((string)sourceObject);
			}
			else if (type == typeof(GameObject))
			{
				GameObject gameObject = sourceObject as GameObject;
				outputStrings.Add((gameObject != null) ? gameObject.name : "");
			}
			else if (type.IsSubclassOf(typeof(Component)))
			{
				Component component = sourceObject as Component;
				outputStrings.Add((component != null) ? component.name : "");
			}
			else
			{
				ConvertFieldsToStrings(sourceObject, type, valueMaps, outputStrings);
			}
		}
	}
	public class PathUtil
	{
		public static string NormalizePath(string path)
		{
			path = path.Trim();
			if (System.IO.Path.IsPathRooted(path))
			{
				path = System.IO.Path.GetFullPath(path);
			}
			return path.Replace('\\', '/');
		}

		public static string CombinePath(string parent, string child)
		{
			return NormalizePath(System.IO.Path.Combine(parent, child));
		}

		public static string CombinePaths(IEnumerable<string> paths)
		{
			string text = "";
			foreach (string path in paths)
			{
				text = System.IO.Path.Combine(text, path);
			}
			return NormalizePath(text);
		}

		public static string SystemPathToAssetPath(string inSystemPath)
		{
			Uri uri = new Uri(UnityEngine.Application.dataPath);
			Uri uri2 = new Uri(inSystemPath);
			return uri.MakeRelativeUri(uri2).ToString().Replace('\\', '/');
		}

		public static string AssetPathToSystemPath(string assetPath)
		{
			string directoryName = System.IO.Path.GetDirectoryName(UnityEngine.Application.dataPath);
			if (!assetPath.ToLowerInvariant().StartsWith("Assets".ToLowerInvariant()))
			{
				assetPath = CombinePath("Assets", assetPath);
			}
			return CombinePath(directoryName, assetPath);
		}

		public static string PathToResourcePath(string sourcePath)
		{
			sourcePath = sourcePath.Replace('\\', '/').Trim();
			string text = sourcePath.ToLowerInvariant();
			if (text.StartsWith("resources/"))
			{
				return sourcePath.Substring("resources/".Length);
			}
			int num = text.IndexOf("/resources/");
			if (num != -1)
			{
				return sourcePath.Substring(num + "/resources/".Length);
			}
			return "";
		}

		public static IEnumerable<string> GetUniquePaths(IEnumerable<string> inputPaths)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			foreach (string inputPath in inputPaths)
			{
				string key = inputPath.ToLowerInvariant().Replace('\\', '/');
				dictionary[key] = inputPath;
			}
			return dictionary.Values;
		}
	}
	public class StringUtil
	{
		public static bool GlobMatch(string stringToCheck, string pattern)
		{
			return new Regex("^" + Regex.Escape(pattern).Replace("\\*", ".*").Replace("\\?", ".") + "$", RegexOptions.IgnoreCase | RegexOptions.Singleline).IsMatch(stringToCheck);
		}

		public static string GlobFind(IEnumerable<string> stringsToCheck, string pattern)
		{
			foreach (string item in stringsToCheck)
			{
				if (GlobMatch(item, pattern))
				{
					return item;
				}
			}
			return null;
		}

		public static List<string> GlobFindAll(IEnumerable<string> stringsToCheck, string pattern)
		{
			List<string> list = new List<string>();
			foreach (string item in stringsToCheck)
			{
				if (GlobMatch(item, pattern))
				{
					list.Add(item);
				}
			}
			return list;
		}
	}
	public class TextRecordParsing
	{
		public class Record
		{
			private List<string> items = new List<string>();

			public int Count => items.Count;

			public IEnumerable<string> Items => items;

			public Record(IEnumerable<string> initialItems)
			{
				items = initialItems.ToList();
			}

			public string GetString(int index)
			{
				return TextRecordParsing.GetString(items, index);
			}

			public bool GetBool(int index)
			{
				return TextRecordParsing.GetBool(items, index);
			}

			public bool TryGetInt(int index, ref int output)
			{
				return GetInt(items, index, ref output);
			}

			public bool TryGetFloat(int index, ref float output)
			{
				return GetFloat(items, index, ref output);
			}

			public bool TryGetVector3(int startIndex, ref Vector3 output)
			{
				return GetVector3(items, startIndex, ref output);
			}

			public Queue<string> ToQueue()
			{
				return new Queue<string>(items);
			}
		}

		public const string DefaultSeparators = "\t,";

		public static IEnumerable<string> DefaultCommentPrefixes => new string[3] { "//", "#", ";" };

		public static string GetString(List<string> items, int index)
		{
			if (index < 0 || index >= items.Count)
			{
				return "";
			}
			return items[index];
		}

		public static bool GetBool(List<string> items, int index)
		{
			List<string> list = new List<string> { "0", "false" };
			string text = GetString(items, index).Trim().ToLowerInvariant();
			if (text.Length > 0)
			{
				return !list.Contains(text);
			}
			return false;
		}

		public static bool GetInt(List<string> items, int index, ref int output)
		{
			int result;
			bool num = int.TryParse(GetString(items, index), out result);
			if (num)
			{
				output = result;
			}
			return num;
		}

		public static bool GetFloat(List<string> items, int index, ref float output)
		{
			float result;
			bool num = float.TryParse(GetString(items, index), out result);
			if (num)
			{
				output = result;
			}
			return num;
		}

		public static bool GetVector3(List<string> items, int startIndex, ref Vector3 output)
		{
			bool flag = false;
			if (startIndex >= 0 && startIndex + 2 < items.Count)
			{
				float result = 0f;
				float result2 = 0f;
				float result3 = 0f;
				flag = float.TryParse(items[startIndex], out result) && float.TryParse(items[startIndex + 1], out result2) && float.TryParse(items[startIndex + 2], out result3);
				if (flag)
				{
					output.Set(result, result2, result3);
				}
			}
			return flag;
		}

		public static List<Record> ParseRecordsFromReader(TextReader reader, string entrySeparators = "\t,", IEnumerable<string> commentPrefixes = null)
		{
			commentPrefixes = commentPrefixes ?? DefaultCommentPrefixes;
			List<Record> list = new List<Record>();
			while (reader.Peek() != -1)
			{
				IEnumerable<string> enumerable = from item in CSVUtilities.ReadNextCSVRow(reader, entrySeparators)
					select item.Trim();
				if (enumerable.Any() && !LineIsCommentedOut(enumerable.First(), commentPrefixes))
				{
					list.Add(new Record(enumerable));
				}
			}
			return list;
		}

		public static List<Record> ParseRecordsFromFile(string sourcePath, Encoding encoding, string entrySeparators = "\t,", IEnumerable<string> commentPrefixes = null)
		{
			List<Record> result = null;
			try
			{
				using StreamReader reader = new StreamReader(sourcePath, encoding);
				result = ParseRecordsFromReader(reader, entrySeparators, commentPrefixes);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("TextRecordParsing 読み込みエラー: " + sourcePath + "\n" + ex.ToString());
				result = new List<Record>();
			}
			return result;
		}

		public static List<Record> ParseRecordsFromText(string sourceText, string entrySeparators = "\t,", IEnumerable<string> commentPrefixes = null)
		{
			List<Record> result = null;
			try
			{
				using StringReader reader = new StringReader(sourceText);
				result = ParseRecordsFromReader(reader, entrySeparators, commentPrefixes);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("TextRecordParsing 読み込みエラー\n" + ex.ToString());
				result = new List<Record>();
			}
			return result;
		}

		public static List<Record> GetSectionRecords(List<Record> sourceRecords, string sectionName)
		{
			int count = 0;
			if (!string.IsNullOrEmpty(sectionName))
			{
				sectionName = "[" + sectionName.ToLowerInvariant() + "]";
				count = sourceRecords.FindIndex((Record item) => item.GetString(0).Trim().ToLowerInvariant() == sectionName);
				if (count == -1)
				{
					return new List<Record>(0);
				}
				count++;
			}
			return sourceRecords.Skip(count).TakeWhile((Record item) => !item.GetString(0).Trim().StartsWith("[")).ToList();
		}

		private static bool LineIsCommentedOut(string trimmedLine, IEnumerable<string> commentPrefixes)
		{
			return commentPrefixes.Any((string prefix) => prefix.Length > 0 && trimmedLine.StartsWith(prefix));
		}
	}
}
namespace UTJ.StringQueueExtensions
{
	public static class ObjectBuilder
	{
		public static float DequeueFloat(this Queue<string> queue)
		{
			return float.Parse(queue.Dequeue());
		}

		public static int DequeueInt(this Queue<string> queue)
		{
			return int.Parse(queue.Dequeue());
		}

		public static Vector3 DequeueVector3(this Queue<string> queue)
		{
			float x = float.Parse(queue.Dequeue());
			float y = float.Parse(queue.Dequeue());
			float z = float.Parse(queue.Dequeue());
			return new Vector3(x, y, z);
		}

		public static Transform DequeueTransform(this Queue<string> queue, GameObject gameObject)
		{
			string parentName = queue.Dequeue();
			Transform transform = null;
			if (parentName.Length > 0)
			{
				Transform[] children = gameObject.GetComponentsInChildren<Transform>(includeInactive: true);
				transform = (from item in UnityEngine.Object.FindObjectsOfType<Transform>()
					where item.name == parentName && !children.Contains(item)
					select item).FirstOrDefault();
				if (transform == null)
				{
					UnityEngine.Debug.LogError("Valid parent not found: " + parentName);
				}
			}
			Transform transform2 = gameObject.transform;
			transform2.parent = transform;
			Vector3 localPosition = queue.DequeueVector3();
			Vector3 euler = queue.DequeueVector3();
			Vector3 localScale = queue.DequeueVector3();
			transform2.localRotation = Quaternion.Euler(euler);
			transform2.localScale = localScale;
			transform2.localPosition = localPosition;
			return transform2;
		}

		public static bool DequeueComponent(this Queue<string> queue, Component component, GameObject rootObject = null, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			Type type = component.GetType();
			bool result = true;
			try
			{
				queue.DequeueFields(type, component, rootObject, valueMaps);
			}
			catch (InvalidOperationException ex)
			{
				result = false;
				UnityEngine.Debug.LogError("Error dequeueing fields for " + type.ToString() + ":\nInsufficient data in source fields\n\n" + ex.ToString());
			}
			catch (Exception ex2)
			{
				result = false;
				UnityEngine.Debug.LogError("Error dequeueing fields for " + type.ToString() + "\n\n" + ex2.ToString());
			}
			return result;
		}

		public static void DequeueFields(this Queue<string> queue, Type classType, object item, GameObject rootObject = null, IEnumerable<TypedStringToValueMap> valueMaps = null)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			FieldInfo[] fields = classType.GetFields(bindingAttr);
			foreach (FieldInfo fieldInfo in fields)
			{
				object valueByType = queue.GetValueByType(fieldInfo.FieldType, rootObject, valueMaps);
				fieldInfo.SetValue(item, valueByType);
			}
		}

		public static void DequeueFields<T>(this Queue<string> queue, T item, string firstOptionalField = null) where T : class
		{
			queue.DequeueFields(typeof(T), item, firstOptionalField);
		}

		public static void DequeueFields(this Queue<string> queue, Type classType, object item, string firstOptionalField = null)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
			FieldInfo[] fields = classType.GetFields(bindingAttr);
			foreach (FieldInfo fieldInfo in fields)
			{
				if (queue.Count == 0 && !string.IsNullOrEmpty(firstOptionalField) && fieldInfo.Name == firstOptionalField)
				{
					break;
				}
				object valueByType = queue.GetValueByType(fieldInfo.FieldType, null, null);
				fieldInfo.SetValue(item, valueByType);
			}
		}

		public static T DequeueObject<T>(this Queue<string> queue, string firstOptionalField = null) where T : class, new()
		{
			T val = new T();
			queue.DequeueFields(typeof(T), val, firstOptionalField);
			return val;
		}

		public static object DequeueObject(this Queue<string> queue, Type type, string firstOptionalField = null)
		{
			object obj = Activator.CreateInstance(type);
			queue.DequeueFields(type, obj, firstOptionalField);
			return obj;
		}

		private static object ParsePrimitiveType(Type type, string valueSource)
		{
			MethodInfo methodInfo = (from method in type.GetMethods()
				where method.Name == "Parse" && method.IsStatic && method.GetParameters().Length == 1
				select method).FirstOrDefault();
			if (methodInfo != null)
			{
				return methodInfo.Invoke(null, new object[1] { valueSource });
			}
			UnityEngine.Debug.LogError("Parse not found: " + type.ToString());
			return null;
		}

		private static object ParseEnum(Type type, string valueSource)
		{
			object obj = null;
			try
			{
				obj = Enum.Parse(type, valueSource, ignoreCase: true);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError("Enum value not found: " + type.ToString() + " : " + valueSource + "\n\n" + ex.ToString());
				obj = null;
			}
			if (obj == null)
			{
				obj = Enum.GetValues(type).GetValue(0);
			}
			return obj;
		}

		private static object GetValueByType(this Queue<string> queue, Type type, GameObject rootObject, IEnumerable<TypedStringToValueMap> valueMaps)
		{
			if (valueMaps != null)
			{
				TypedStringToValueMap typedStringToValueMap = valueMaps.Where((TypedStringToValueMap map) => map.Type == type).FirstOrDefault();
				if (typedStringToValueMap != null)
				{
					return typedStringToValueMap[queue.Dequeue()];
				}
			}
			if (type.IsPrimitive)
			{
				return ParsePrimitiveType(type, queue.Dequeue());
			}
			if (type.IsEnum)
			{
				return ParseEnum(type, queue.Dequeue());
			}
			if (type == typeof(string))
			{
				return queue.Dequeue();
			}
			if (type == typeof(GameObject))
			{
				Component component = FindComponent(typeof(Transform), rootObject, queue.Dequeue());
				if (component != null)
				{
					return component.gameObject;
				}
				return null;
			}
			if (type.IsSubclassOf(typeof(Component)))
			{
				return FindComponent(type, rootObject, queue.Dequeue());
			}
			if (type.IsArray)
			{
				return queue.BuildArray(type.GetElementType(), rootObject, valueMaps);
			}
			object obj = Activator.CreateInstance(type);
			queue.DequeueFields(type, obj, rootObject, valueMaps);
			return obj;
		}

		private static Array BuildArray(this Queue<string> queue, Type elementType, GameObject rootObject, IEnumerable<TypedStringToValueMap> valueMaps)
		{
			int num = int.Parse(queue.Dequeue());
			Array array = Array.CreateInstance(elementType, num);
			for (int i = 0; i < num; i++)
			{
				object valueByType = queue.GetValueByType(elementType, rootObject, valueMaps);
				array.SetValue(valueByType, i);
			}
			return array;
		}

		private static Component FindComponent(Type type, GameObject root, string objectName)
		{
			IEnumerable<Component> source;
			if (!(root == null))
			{
				IEnumerable<Component> componentsInChildren = root.GetComponentsInChildren(type, includeInactive: true);
				source = componentsInChildren;
			}
			else
			{
				source = from item in UnityEngine.Object.FindObjectsOfType(type)
					select item as Component into item
					where item != null
					select item;
			}
			Component component = source.FirstOrDefault((Component child) => child.name == objectName);
			if (component == null)
			{
				UnityEngine.Debug.LogError("Component not found: " + objectName + "  Type: " + type.ToString());
			}
			return component;
		}
	}
}
namespace UTJ.GameObjectExtensions
{
	public static class GameObjectUtil
	{
		public enum SearchOptions
		{
			None,
			IgnoreNamespace
		}

		public static IEnumerable<T> FindComponentsOfType<T>() where T : Component
		{
			GameObject[] rootGameObjects = SceneManager.GetActiveScene().GetRootGameObjects();
			List<T> list = new List<T>();
			GameObject[] array = rootGameObjects;
			foreach (GameObject gameObject in array)
			{
				list.AddRange(gameObject.GetComponentsInChildren<T>(includeInactive: true));
			}
			return list;
		}

		public static IEnumerable<GameObject> GetAllGameObjects()
		{
			return from item in FindComponentsOfType<Transform>()
				select item.gameObject;
		}

		public static Dictionary<string, T> BuildNameToComponentMap<T>(this GameObject rootObject, bool includeInactive) where T : Component
		{
			T[] componentsInChildren = rootObject.GetComponentsInChildren<T>(includeInactive);
			Dictionary<string, T> dictionary = new Dictionary<string, T>(componentsInChildren.Length);
			T[] array = componentsInChildren;
			foreach (T val in array)
			{
				dictionary[val.name] = val;
			}
			return dictionary;
		}

		public static IEnumerable<Transform> GetAllBones(this GameObject rootObject)
		{
			SkinnedMeshRenderer[] componentsInChildren = rootObject.GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive: true);
			HashSet<Transform> hashSet = new HashSet<Transform>();
			SkinnedMeshRenderer[] array = componentsInChildren;
			for (int i = 0; i < array.Length; i++)
			{
				Transform[] bones = array[i].bones;
				foreach (Transform item in bones)
				{
					hashSet.Add(item);
				}
			}
			return hashSet;
		}

		public static Transform FindChildByName(this GameObject inRoot, string inName, SearchOptions searchOptions = SearchOptions.IgnoreNamespace)
		{
			return inRoot.FindChildComponentByName<Transform>(inName, searchOptions);
		}

		public static T FindChildComponentByName<T>(this GameObject inRoot, string inName, SearchOptions searchOptions = SearchOptions.IgnoreNamespace) where T : Component
		{
			string text = inName.ToLowerInvariant();
			if (searchOptions == SearchOptions.IgnoreNamespace)
			{
				text = RemoveNamespaceFromName(text);
			}
			T[] componentsInChildren = inRoot.GetComponentsInChildren<T>();
			int num = componentsInChildren.Length;
			for (int i = 0; i < num; i++)
			{
				T val = componentsInChildren[i];
				string text2 = val.gameObject.name.ToLowerInvariant();
				if (searchOptions == SearchOptions.IgnoreNamespace)
				{
					text2 = RemoveNamespaceFromName(text2);
				}
				if (text2 == text)
				{
					return val;
				}
			}
			return null;
		}

		public static T[] FindChildComponentsByName<T>(this GameObject inRoot, string[] inNames, SearchOptions searchOptions = SearchOptions.IgnoreNamespace) where T : Component
		{
			T[] componentsInChildren = inRoot.GetComponentsInChildren<T>();
			List<T> list = new List<T>();
			int num = componentsInChildren.Length;
			for (int i = 0; i < num; i++)
			{
				T val = componentsInChildren[i];
				string childName = val.gameObject.name.ToLowerInvariant();
				if (searchOptions == SearchOptions.IgnoreNamespace)
				{
					childName = RemoveNamespaceFromName(childName);
					if (Array.Exists(inNames, (string searchName) => RemoveNamespaceFromName(searchName.ToLowerInvariant()) == childName))
					{
						list.Add(val);
					}
				}
				else if (Array.Exists(inNames, (string searchName) => searchName.ToLowerInvariant() == childName))
				{
					list.Add(val);
				}
			}
			return list.ToArray();
		}

		public static string RemoveNamespaceFromName(string inName)
		{
			string[] array = inName.Split(new char[1] { ':' }, StringSplitOptions.None);
			if (array.Length == 0)
			{
				return "";
			}
			return array[^1];
		}

		public static int GetTransformDepth(Transform inObject)
		{
			int num = 0;
			Transform transform = inObject;
			while (transform != null)
			{
				transform = transform.parent;
				num++;
			}
			return num;
		}

		public static string GetUniqueName(string desiredName)
		{
			IEnumerable<string> source = from item in FindComponentsOfType<Transform>()
				select item.name;
			if (!source.Contains(desiredName))
			{
				return desiredName;
			}
			string text = desiredName;
			for (int i = 1; i <= 10000; i++)
			{
				text = desiredName + "_" + i;
				if (!source.Contains(text))
				{
					return text;
				}
			}
			UnityEngine.Debug.LogError("Too many similar names exist: " + desiredName);
			return text;
		}
	}
}
namespace StackableDecorator
{
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = true)]
	public abstract class StackableDecoratorAttribute : Attribute
	{
		public bool visible = true;

		public int order;

		public string byPass = string.Empty;
	}
	public abstract class Styled2DecoratorAttribute : StyledDecoratorAttribute
	{
		public string style2;
	}
	public abstract class StyledDecoratorAttribute : StackableDecoratorAttribute
	{
		public string style;

		public string title;

		public string icon;

		public string tooltip;
	}
	public abstract class ConditionalAttribute : StackableDecoratorAttribute
	{
		public bool inverted;

		public ConditionalAttribute(bool condition)
		{
		}

		public ConditionalAttribute(string condition)
		{
		}
	}
	public class EnableIfAttribute : ConditionalAttribute
	{
		public bool enable = true;

		public bool disable = true;

		public bool all = true;

		public EnableIfAttribute(bool condition)
			: base(condition)
		{
		}

		public EnableIfAttribute(string condition)
			: base(condition)
		{
		}
	}
	public class HelpBoxAttribute : ConditionalAttribute
	{
		public bool indented = true;

		public MessageType messageType = MessageType.Info;

		public bool below = true;

		public float height = -1f;

		public bool all = true;

		public HelpBoxAttribute(string message)
			: base(condition: true)
		{
		}

		public HelpBoxAttribute(string message, string condition)
			: base(condition)
		{
		}
	}
	public class ShowIfAttribute : ConditionalAttribute
	{
		public bool enable = true;

		public bool disable = true;

		public bool all = true;

		public ShowIfAttribute(bool condition)
			: base(condition)
		{
		}

		public ShowIfAttribute(string condition)
			: base(condition)
		{
		}
	}
	public class ClampValueAttribute : StackableDecoratorAttribute
	{
		public ClampValueAttribute(float min, float max)
		{
		}
	}
	public class MaxValueAttribute : StackableDecoratorAttribute
	{
		public MaxValueAttribute(float value)
		{
		}
	}
	public class MinValueAttribute : StackableDecoratorAttribute
	{
		public MinValueAttribute(float value)
		{
		}
	}
	public class RepeatValueAttribute : StackableDecoratorAttribute
	{
		public bool lowerInclusive = true;

		public bool upperInclusive;

		public RepeatValueAttribute(float min, float max)
		{
		}
	}
	public class AnimatorParameterPopupAttribute : StackableFieldAttribute
	{
		public bool floatType = true;

		public bool intType = true;

		public bool boolType = true;

		public bool triggerType = true;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;

		public AnimatorParameterPopupAttribute()
		{
		}

		public AnimatorParameterPopupAttribute(string animator)
		{
		}
	}
	public class AsImageAttribute : StackableFieldAttribute, INoCacheInspectorGUI
	{
		public float width = -1f;

		public float height = -1f;

		public string sizeGetter;
	}
	public class AsStringAttribute : StackableFieldAttribute
	{
		public bool label;

		public bool icon;

		public bool tooltip;
	}
	public class ColorFieldAttribute : StackableFieldAttribute
	{
		public bool showEyedropper = true;

		public bool showAlpha = true;

		public bool hdr;

		public float minBrightness;

		public float maxBrightness = 8f;

		public float minExposureValue = 0.125f;

		public float maxExposureValue = 3f;
	}
	public class CurveFieldAttribute : StackableFieldAttribute
	{
		public CurveFieldAttribute()
		{
		}

		public CurveFieldAttribute(float r, float g, float b)
		{
		}

		public CurveFieldAttribute(float xMin, float yMin, float xMax, float yMax)
		{
		}

		public CurveFieldAttribute(float r, float g, float b, float xMin, float yMin, float xMax, float yMax)
		{
		}
	}
	public class DropdownMaskAttribute : StackableFieldAttribute
	{
		public string placeHolder = string.Empty;

		public bool showAll = true;

		public bool showCombined;

		public bool sortCombined = true;

		public DropdownMaskAttribute(string names, string values)
		{
		}
	}
	public class DropdownValueAttribute : StackableFieldAttribute
	{
		public string names;

		public string placeHolder = string.Empty;

		public DropdownValueAttribute(string values)
		{
		}
	}
	public class EnumButtonAttribute : StackableFieldAttribute
	{
		public string styles;

		public string exclude = string.Empty;

		public int column = -1;

		public int hOffset;

		public int vOffset;
	}
	public class EnumMaskButtonAttribute : StackableFieldAttribute
	{
		public string styles;

		public bool all = true;

		public string exclude = string.Empty;

		public int column = -1;

		public int hOffset;

		public int vOffset;
	}
	public class EnumMaskPopupAttribute : StackableFieldAttribute
	{
		public string names;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;

		public bool showAll = true;

		public bool showCombined;

		public bool sortCombined = true;
	}
	public class EnumPopupAttribute : StackableFieldAttribute
	{
		public string names;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class ExpandableAttribute : StackableFieldAttribute
	{
	}
	public class InputAxisPopupAttribute : StackableFieldAttribute
	{
		public bool keyOrMouseButton = true;

		public bool mouseMovement = true;

		public bool joystickAxis = true;

		public bool negativeButton = true;

		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class LabelOnlyAttribute : StackableFieldAttribute
	{
	}
	public class LayerMaskPopupAttribute : StackableFieldAttribute
	{
		public string placeHolder = string.Empty;

		public bool showAll = true;
	}
	public class LayerPopupAttribute : StackableFieldAttribute
	{
		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class ListAttribute : StackableFieldAttribute
	{
		public bool expandable;

		public ListAttribute()
		{
		}

		public ListAttribute(string list)
		{
		}
	}
	public class ProgressBarAttribute : StackableFieldAttribute
	{
		public bool prefix;

		public bool showLabel = true;

		public bool showPercentage = true;

		public int decimalPlaces = 1;

		public bool clampPercentage = true;

		public ProgressBarAttribute(float max)
		{
		}

		public ProgressBarAttribute(float min, float max)
		{
		}
	}
	public class RangeSliderAttribute : StackableFieldAttribute
	{
		public bool integer;

		public bool showInLabel;

		public RangeSliderAttribute(float min, float max)
		{
		}
	}
	public class SimpleGridAttribute : StackableFieldAttribute, INoCacheInspectorGUI
	{
		public int column = 4;

		public float cellWidth = -1f;

		public float cellHeight = 16f;

		public float spacing = 2f;

		public float maxHeight = -1f;

		public string columnGetter;

		public string cellSizeGetter;

		public string maxHeightGetter;

		public SimpleGridAttribute()
		{
		}

		public SimpleGridAttribute(string list)
		{
		}
	}
	public class SimpleListAttribute : StackableFieldAttribute, INoCacheInspectorGUI
	{
		public float spacing = 2f;

		public float fixedHeight = -1f;

		public float maxHeight = -1f;

		public string maxHeightGetter;

		public SimpleListAttribute()
		{
		}

		public SimpleListAttribute(string list)
		{
		}
	}
	public class SliderAttribute : StackableFieldAttribute
	{
		public bool showField = true;

		public SliderAttribute(float min, float max)
		{
		}
	}
	public class SortingLayerPopupAttribute : StackableFieldAttribute
	{
		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	[AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
	public class StackableFieldAttribute : PropertyAttribute
	{
	}
	public class TagPopupAttribute : StackableFieldAttribute
	{
		public string exclude = string.Empty;

		public string placeHolder = string.Empty;
	}
	public class TextFieldAttribute : StackableFieldAttribute
	{
		private const int kLineHeight = 13;

		public string placeHolder = string.Empty;

		public TextFieldAttribute()
		{
		}

		public TextFieldAttribute(int lines)
		{
		}
	}
	public class ToggleLeftAttribute : StackableFieldAttribute
	{
	}
	public class OnClickAttribute : StackableDecoratorAttribute
	{
		public int button;

		public bool use = true;

		public bool after;

		public OnClickAttribute(string action)
		{
		}
	}
	public class OnDragDropAttribute : StackableDecoratorAttribute
	{
		public int button;

		public bool autoDrag = true;

		public bool autoDrop = true;

		public string drag = string.Empty;

		public string accept = string.Empty;

		public string drop = string.Empty;

		public bool use = true;

		public bool after;
	}
	public class OnValueChangedAttribute : StackableDecoratorAttribute
	{
		public OnValueChangedAttribute(string action)
		{
		}
	}
	public class FoldoutAttribute : Styled2DecoratorAttribute
	{
		public bool indented = true;

		public bool hierarchyMode = true;

		public bool indentChildren = true;
	}
	public class GroupAttribute : StackableDecoratorAttribute
	{
		public bool indented;

		public bool indentChildren;

		public float spacing = 2f;

		public bool fixedCell = true;

		public GroupAttribute(string name, bool children, string properties, params float[] heights)
		{
		}

		public GroupAttribute(string name, int properties, params float[] heights)
		{
		}
	}
	public class HorizontalGroupAttribute : StyledDecoratorAttribute
	{
		public bool indented = true;

		public bool prefix;

		public float spacing = 2f;

		public bool fixedCell = true;

		public HorizontalGroupAttribute(string name, bool children, string properties, params float[] widths)
		{
		}

		public HorizontalGroupAttribute(string name, int properties, params float[] widths)
		{
		}
	}
	public class InGroupAttribute : StackableDecoratorAttribute
	{
		public InGroupAttribute(string name)
		{
		}
	}
	public class TabGroupAttribute : Styled2DecoratorAttribute
	{
		public bool indented = true;

		public float width = -1f;

		public string icons = string.Empty;

		public string tooltips = string.Empty;

		public TextAlignment alignment = TextAlignment.Center;

		public string buttonStyles;

		public TabGroupAttribute(string name, string tabs, string properties, float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class BoxAttribute : StyledDecoratorAttribute
	{
		public bool indented = true;

		public BoxAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class ButtonsAttribute : StyledDecoratorAttribute
	{
		public string titles = string.Empty;

		public string icons = string.Empty;

		public string tooltips = string.Empty;

		public string actions = string.Empty;

		public string buttonStyles;

		public int column = -1;

		public int hOffset;

		public int vOffset;

		public float width = -1f;

		public float height = -1f;

		public bool indented = true;

		public bool below;

		public TextAlignment alignment;

		public ButtonsAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class HeadingAttribute : StyledDecoratorAttribute
	{
		public float width = -1f;

		public float height = -1f;

		public bool indented = true;

		public bool below;

		public TextAlignment alignment;

		public HeadingAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class ImageAttribute : StackableDecoratorAttribute, INoCacheInspectorGUI
	{
		public string image = string.Empty;

		public string texture = string.Empty;

		public float width = -1f;

		public float height = -1f;

		public bool GUID;

		public bool indented = true;

		public bool below;

		public TextAlignment alignment;

		public ImageAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class SideButtonsAttribute : StyledDecoratorAttribute
	{
		public string titles = string.Empty;

		public string icons = string.Empty;

		public string tooltips = string.Empty;

		public string actions = string.Empty;

		public string buttonStyles;

		public int column = -1;

		public int hOffset;

		public int vOffset;

		public float width = -1f;

		public float height = -1f;

		public float margin = 2f;

		public bool indented = true;

		public bool onLeft;

		public TextAlignment alignment;

		public SideButtonsAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class SideImageAttribute : StyledDecoratorAttribute, INoCacheInspectorGUI
	{
		public string image = string.Empty;

		public string texture = string.Empty;

		public float width = -1f;

		public float height = -1f;

		public float margin = 2f;

		public bool GUID;

		public bool indented = true;

		public bool onLeft;

		public bool reserveWidth;

		public TextAlignment alignment;

		public SideImageAttribute(float left = 0f, float right = 0f, float top = 0f, float bottom = 0f)
		{
		}
	}
	public class ColorAttribute : StackableDecoratorAttribute
	{
		public ColorAttribute(float r, float g, float b, float a)
		{
		}
	}
	public class DegToRadAttribute : StackableDecoratorAttribute
	{
	}
	public class HierarchyModeAttribute : StackableDecoratorAttribute
	{
		public HierarchyModeAttribute(bool hierarchyMode)
		{
		}
	}
	public class IconSizeAttribute : StackableDecoratorAttribute
	{
		public IconSizeAttribute(int width, int height)
		{
		}
	}
	public class IncludeChildrenAttribute : StackableDecoratorAttribute
	{
		public IncludeChildrenAttribute(bool includeChildren)
		{
		}
	}
	public class IndentLevelAttribute : StackableDecoratorAttribute
	{
		public bool absolute;

		public IndentLevelAttribute(int indentLevel)
		{
		}
	}
	public class LabelAttribute : StyledDecoratorAttribute
	{
		public LabelAttribute()
		{
		}

		public LabelAttribute(float width)
		{
		}
	}
	public class RadToDegAttribute : StackableDecoratorAttribute
	{
	}
	public class InlinePropertyAttribute : StyledDecoratorAttribute, INoCacheInspectorGUI
	{
		public bool indented = true;

		public bool always;

		public bool indentChildren = true;

		public float maxHeight = -1f;

		public string maxHeightGetter;

		public InlinePropertyAttribute(float left = 3f, float right = 3f, float top = 3f, float bottom = 3f)
		{
		}
	}
	public class PopupEditorAttribute : StyledDecoratorAttribute
	{
		public float width = 16f;

		public float height = 16f;
	}
	public class PreviewAttribute : StackableDecoratorAttribute, INoCacheInspectorGUI
	{
		public bool indented = true;

		public bool always;

		public float height = 100f;
	}
	public interface INoCacheInspectorGUI
	{
	}
	public interface IValidateProperty
	{
		MessageType messageType { get; }
	}
	public static class RectUtils
	{
		public static float defaultSpacing = 2f;

		public static Rect X(this Rect rect, float x)
		{
			rect.x = x;
			return rect;
		}

		public static Rect Y(this Rect rect, float y)
		{
			rect.y = y;
			return rect;
		}

		public static Rect Position(this Rect rect, float x, float y)
		{
			rect.x = x;
			rect.y = y;
			return rect;
		}

		public static Rect Size(this Rect rect, float width, float height)
		{
			rect.width = width;
			rect.height = height;
			return rect;
		}

		public static Rect Width(this Rect rect, float width)
		{
			rect.width = width;
			return rect;
		}

		public static Rect WidthFromRight(this Rect rect, float width)
		{
			rect.xMin = rect.xMax - width;
			return rect;
		}

		public static Rect Height(this Rect rect, float height)
		{
			rect.height = height;
			return rect;
		}

		public static Rect HeightFromBottom(this Rect rect, float height)
		{
			rect.yMin = rect.yMax - height;
			return rect;
		}

		public static Rect Left(this Rect rect, float width)
		{
			rect.width = Mathf.Min(rect.width, width);
			return rect;
		}

		public static Rect Right(this Rect rect, float width)
		{
			rect.xMin = rect.xMax - Mathf.Min(rect.width, width);
			return rect;
		}

		public static Rect Top(this Rect rect, float height)
		{
			rect.height = Mathf.Min(rect.height, height);
			return rect;
		}

		public static Rect Bottom(this Rect rect, float height)
		{
			rect.yMin = rect.yMax - Mathf.Min(rect.height, height);
			return rect;
		}

		public static Rect CutLeft(this Rect rect, float width)
		{
			rect.xMin = Mathf.Min(rect.xMin + width, rect.xMax);
			return rect;
		}

		public static Rect CutRight(this Rect rect, float width)
		{
			rect.xMax = Mathf.Max(rect.xMin, rect.xMax - width);
			return rect;
		}

		public static Rect CutTop(this Rect rect, float height)
		{
			rect.yMin = Mathf.Min(rect.yMin + height, rect.yMax);
			return rect;
		}

		public static Rect CutBottom(this Rect rect, float height)
		{
			rect.yMax = Mathf.Max(rect.yMin, rect.yMax - height);
			return rect;
		}

		public static Rect MoveLeft(this Rect rect)
		{
			return rect.MoveLeft(defaultSpacing);
		}

		public static Rect MoveLeft(this Rect rect, float spacing)
		{
			if (rect.width > 0f)
			{
				rect.x -= rect.width + spacing;
			}
			return rect;
		}

		public static Rect MoveRight(this Rect rect)
		{
			return rect.MoveRight(defaultSpacing);
		}

		public static Rect MoveRight(this Rect rect, float spacing)
		{
			if (rect.width > 0f)
			{
				rect.x += rect.width + spacing;
			}
			return rect;
		}

		public static Rect MoveUp(this Rect rect)
		{
			return rect.MoveUp(defaultSpacing);
		}

		public static Rect MoveUp(this Rect rect, float spacing)
		{
			if (rect.height > 0f)
			{
				rect.y -= rect.height + spacing;
			}
			return rect;
		}

		public static Rect MoveDown(this Rect rect)
		{
			return rect.MoveDown(defaultSpacing);
		}

		public static Rect MoveDown(this Rect rect, float spacing)
		{
			if (rect.height > 0f)
			{
				rect.y += rect.height + spacing;
			}
			return rect;
		}

		public static Rect Enlarge(this Rect rect, float size)
		{
			rect.xMin -= size;
			rect.xMax += size;
			rect.yMin -= size;
			rect.yMax += size;
			return rect;
		}

		public static Rect Enlarge(this Rect rect, float hsize, float vsize)
		{
			rect.xMin -= hsize;
			rect.xMax += hsize;
			rect.yMin -= vsize;
			rect.yMax += vsize;
			return rect;
		}

		public static Rect Enlarge(this Rect rect, float left, float right, float top, float bottom)
		{
			rect.xMin -= left;
			rect.xMax += right;
			rect.yMin -= top;
			rect.yMax += bottom;
			return rect;
		}

		public static Rect Shrink(this Rect rect, float size)
		{
			rect.xMin += size;
			rect.xMax -= size;
			rect.yMin += size;
			rect.yMax -= size;
			return rect;
		}

		public static Rect Shrink(this Rect rect, float hsize, float vsize)
		{
			rect.xMin += hsize;
			rect.xMax -= hsize;
			rect.yMin += vsize;
			rect.yMax -= vsize;
			return rect;
		}

		public static Rect Shrink(this Rect rect, float left, float right, float top, float bottom)
		{
			rect.xMin += left;
			rect.xMax -= right;
			rect.yMin += top;
			rect.yMax -= bottom;
			return rect;
		}

		public static IEnumerable<Rect> HorizontalDistribute(this Rect rect, int count)
		{
			return rect.HorizontalDistribute(defaultSpacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> HorizontalDistribute(this Rect rect, int count, float spacing)
		{
			return rect.HorizontalDistribute(spacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> RowDistribute(this Rect rect, IEnumerable<float> widths)
		{
			return rect.HorizontalDistribute(defaultSpacing, widths);
		}

		public static IEnumerable<Rect> HorizontalDistribute(this Rect rect, float spacing, IEnumerable<float> widths)
		{
			List<float> list = widths.ToList();
			float total = rect.width - spacing * (float)(list.Count((float w) => w != 0f) - 1);
			float num = 0f;
			for (int j = 0; j < list.Count; j++)
			{
				if (list[j] < 0f)
				{
					num += 0f - list[j];
					continue;
				}
				if (list[j] <= 1f)
				{
					list[j] *= rect.width;
				}
				list[j] = Mathf.Clamp(list[j], 0f, total);
				total -= list[j];
			}
			total /= num;
			Rect current = new Rect(rect);
			for (int i = 0; i < list.Count; i++)
			{
				float width = ((list[i] < 0f) ? (list[i] *= 0f - total) : list[i]);
				current.width = width;
				yield return current;
				current = current.MoveRight(spacing);
			}
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, int count)
		{
			return rect.VerticalDistribute(defaultSpacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, int count, float spacing)
		{
			return rect.VerticalDistribute(spacing, Enumerable.Repeat(-1f, count));
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, IEnumerable<float> heights)
		{
			return rect.VerticalDistribute(defaultSpacing, heights);
		}

		public static IEnumerable<Rect> VerticalDistribute(this Rect rect, float spacing, IEnumerable<float> heights)
		{
			rect = new Rect(rect.y, rect.x, rect.height, rect.width);
			return from r in rect.HorizontalDistribute(spacing, heights)
				select new Rect(r.y, r.x, r.height, r.width);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, int row, int column)
		{
			return rect.GridDistribute(-1f, -1f, row, column, defaultSpacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, int row, int column, float spacing)
		{
			return rect.GridDistribute(-1f, -1f, row, spacing, column, spacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, int row, float vSpacing, int column, float hSpacing)
		{
			return rect.GridDistribute(-1f, -1f, row, vSpacing, column, hSpacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, float width, float height, int row, int column, float spacing)
		{
			return rect.GridDistribute(width, height, row, spacing, column, spacing);
		}

		public static IEnumerable<Rect> GridDistribute(this Rect rect, float width, float height, int row, float vSpacing, int column, float hSpacing)
		{
			IEnumerable<Rect> enumerable = ((height < 0f) ? rect.VerticalDistribute(row, vSpacing) : rect.VerticalDistribute(vSpacing, Enumerable.Repeat(height, row)));
			foreach (Rect item in enumerable)
			{
				IEnumerable<Rect> enumerable2 = ((width < 0f) ? item.HorizontalDistribute(column, hSpacing) : item.HorizontalDistribute(hSpacing, Enumerable.Repeat(width, column)));
				foreach (Rect item2 in enumerable2)
				{
					yield return item2;
				}
			}
		}
	}
	public static class ReflectionUtils
	{
		public static T MakeFunc<T>(this MethodInfo method) where T : class
		{
			return Delegate.CreateDelegate(typeof(T), method) as T;
		}

		public static T MakeStaticFunc<T>(this MethodInfo method) where T : class
		{
			return Delegate.CreateDelegate(typeof(T), null, method) as T;
		}

		public static T MakeFuncGenericThis<T>(this MethodInfo method) where T : class
		{
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), "obj");
			return Expression.Lambda<T>(Expression.Call(Expression.Convert(parameterExpression, method.DeclaringType), method), new ParameterExpression[1] { parameterExpression }).Compile();
		}

		public static T MakeStaticFuncGenericInput<T>(this MethodInfo method) where T : class
		{
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), "input");
			UnaryExpression arg = Expression.Convert(parameterExpression, method.GetParameters()[0].ParameterType);
			return Expression.Lambda<T>(Expression.Call(method, arg), new ParameterExpression[1] { parameterExpression }).Compile();
		}

		public static T MakeFuncGenericInput<T>(this MethodInfo method) where T : class
		{
			ParameterExpression parameterExpression = Expression.Parameter(typeof(object), "obj");
			UnaryExpression instance = Expression.Convert(parameterExpression, method.DeclaringType);
			ParameterExpression parameterExpression2 = Expression.Parameter(typeof(object), "input");
			UnaryExpression unaryExpression = Expression.Convert(parameterExpression2, method.GetParameters()[0].ParameterType);
			return Expression.Lambda<T>(Expression.Call(instance, method, unaryExpression), new ParameterExpression[2] { parameterExpression, parameterExpression2 }).Compile();
		}
	}
	public static class TransformUtils
	{
		public static IEnumerable<Transform> GetAncestors(this Transform transform, bool self = true)
		{
			Transform current = (self ? transform : transform.parent);
			while (current != null)
			{
				yield return current;
				current = current.parent;
			}
		}

		public static IEnumerable<Transform> GetChildren(this Transform transform, bool self = true)
		{
			if (self)
			{
				yield return transform;
			}
			int count = transform.childCount;
			for (int i = 0; i < count; i++)
			{
				yield return transform.GetChild(i);
			}
		}

		public static IEnumerable<Transform> GetDescendants(this Transform transform, bool self = true)
		{
			if (self)
			{
				yield return transform;
			}
			foreach (Transform child in transform.GetChildren(self: false))
			{
				foreach (Transform descendant in child.GetDescendants())
				{
					yield return descendant;
				}
			}
		}

		public static GameObject GetRoot(this GameObject gameObject)
		{
			return gameObject.transform.root.gameObject;
		}

		public static IEnumerable<GameObject> GetAncestors(this GameObject gameObject, bool self = true)
		{
			return from t in gameObject.transform.GetAncestors(self)
				select t.gameObject;
		}

		public static IEnumerable<GameObject> GetChildren(this GameObject gameObject, bool self = true)
		{
			return from t in gameObject.transform.GetChildren(self)
				select t.gameObject;
		}

		public static IEnumerable<GameObject> GetDescendants(this GameObject gameObject, bool self = true)
		{
			return from t in gameObject.transform.GetDescendants(self)
				select t.gameObject;
		}
	}
	public enum MessageType
	{
		None,
		Info,
		Warning,
		Error
	}
	public static class Utils
	{
		public static bool IsPowerOfTwo(this long number)
		{
			if (number != 0L)
			{
				return (number & (number - 1)) == 0;
			}
			return false;
		}

		public static IEnumerable<T> Yield<T>(this T item)
		{
			yield return item;
		}

		public static TValue Get<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key, TValue def) where TValue : struct
		{
			if (!dict.TryGetValue(key, out var value))
			{
				value = (dict[key] = def);
			}
			return value;
		}

		public static TValue Get<TKey, TValue>(this Dictionary<TKey, TValue> dict, TKey key) where TValue : new()
		{
			if (!dict.TryGetValue(key, out var value))
			{
				value = (dict[key] = new TValue());
			}
			return value;
		}
	}
	public class AssetOnlyAttribute : ValidateObjectAttribute
	{
		public AssetOnlyAttribute()
		{
		}

		public AssetOnlyAttribute(string message)
		{
		}
	}
	public class NotNullAttribute : ValidateObjectAttribute
	{
		public NotNullAttribute()
		{
		}

		public NotNullAttribute(string message)
		{
		}
	}
	public class SceneOnlyAttribute : ValidateObjectAttribute
	{
		public SceneOnlyAttribute()
		{
		}

		public SceneOnlyAttribute(string message)
		{
		}
	}
	public abstract class ValidateAttribute : StackableDecoratorAttribute, IValidateProperty
	{
		public bool indented = true;

		public MessageType messageType = MessageType.Error;

		public bool below = true;

		public float height = -1f;

		MessageType IValidateProperty.messageType => messageType;
	}
	public abstract class ValidateObjectAttribute : ValidateAttribute
	{
	}
	public class ValidateValueAttribute : ValidateAttribute
	{
		public bool inverted;

		public ValidateValueAttribute(string message, string condition)
		{
		}
	}
}
namespace DG.Tweening
{
	public static class DOTweenModuleSprite
	{
		public static Tweener DOColor(this SpriteRenderer target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this SpriteRenderer target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Sequence DOGradientColor(this SpriteRenderer target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Tweener DOBlendableColor(this SpriteRenderer target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}
	}
	public static class DOTweenModuleUI
	{
		public static class Utils
		{
			public static Vector2 SwitchToRectTransform(RectTransform from, RectTransform to)
			{
				Vector2 vector = new Vector2(from.rect.width * 0.5f + from.rect.xMin, from.rect.height * 0.5f + from.rect.yMin);
				Vector2 screenPoint = RectTransformUtility.WorldToScreenPoint(null, from.position);
				screenPoint += vector;
				RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenPoint, null, out var localPoint);
				Vector2 vector2 = new Vector2(to.rect.width * 0.5f + to.rect.xMin, to.rect.height * 0.5f + to.rect.yMin);
				return to.anchoredPosition + localPoint - vector2;
			}
		}

		public static Tweener DOFade(this CanvasGroup target, float endValue, float duration)
		{
			return DOTween.To(() => target.alpha, delegate(float x)
			{
				target.alpha = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOColor(this Graphic target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Graphic target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOColor(this Image target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Image target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFillAmount(this Image target, float endValue, float duration)
		{
			if (endValue > 1f)
			{
				endValue = 1f;
			}
			else if (endValue < 0f)
			{
				endValue = 0f;
			}
			return DOTween.To(() => target.fillAmount, delegate(float x)
			{
				target.fillAmount = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Sequence DOGradientColor(this Image target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Tweener DOFlexibleSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.flexibleWidth, target.flexibleHeight), delegate(Vector2 x)
			{
				target.flexibleWidth = x.x;
				target.flexibleHeight = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOMinSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.minWidth, target.minHeight), delegate(Vector2 x)
			{
				target.minWidth = x.x;
				target.minHeight = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOPreferredSize(this LayoutElement target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.preferredWidth, target.preferredHeight), delegate(Vector2 x)
			{
				target.preferredWidth = x.x;
				target.preferredHeight = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOColor(this Outline target, Color endValue, float duration)
		{
			return DOTween.To(() => target.effectColor, delegate(Color x)
			{
				target.effectColor = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Outline target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.effectColor, delegate(Color x)
			{
				target.effectColor = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOScale(this Outline target, Vector2 endValue, float duration)
		{
			return DOTween.To(() => target.effectDistance, delegate(Vector2 x)
			{
				target.effectDistance = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOAnchorPos(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPosX(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(endValue, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPosY(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(0f, endValue), duration).SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3D(this RectTransform target, Vector3 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3DX(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(endValue, 0f, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3DY(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(0f, endValue, 0f), duration).SetOptions(AxisConstraint.Y, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorPos3DZ(this RectTransform target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchoredPosition3D, delegate(Vector3 x)
			{
				target.anchoredPosition3D = x;
			}, new Vector3(0f, 0f, endValue), duration).SetOptions(AxisConstraint.Z, snapping).SetTarget(target);
		}

		public static Tweener DOAnchorMax(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchorMax, delegate(Vector2 x)
			{
				target.anchorMax = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOAnchorMin(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.anchorMin, delegate(Vector2 x)
			{
				target.anchorMin = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOPivot(this RectTransform target, Vector2 endValue, float duration)
		{
			return DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOPivotX(this RectTransform target, float endValue, float duration)
		{
			return DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, new Vector2(endValue, 0f), duration).SetOptions(AxisConstraint.X).SetTarget(target);
		}

		public static Tweener DOPivotY(this RectTransform target, float endValue, float duration)
		{
			return DOTween.To(() => target.pivot, delegate(Vector2 x)
			{
				target.pivot = x;
			}, new Vector2(0f, endValue), duration).SetOptions(AxisConstraint.Y).SetTarget(target);
		}

		public static Tweener DOSizeDelta(this RectTransform target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.sizeDelta, delegate(Vector2 x)
			{
				target.sizeDelta = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOPunchAnchorPos(this RectTransform target, Vector2 punch, float duration, int vibrato = 10, float elasticity = 1f, bool snapping = false)
		{
			return DOTween.Punch(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, punch, duration, vibrato, elasticity).SetTarget(target).SetOptions(snapping);
		}

		public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, float strength = 100f, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			return DOTween.Shake(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, duration, strength, vibrato, randomness, ignoreZAxis: true, fadeOut).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake)
				.SetOptions(snapping);
		}

		public static Tweener DOShakeAnchorPos(this RectTransform target, float duration, Vector2 strength, int vibrato = 10, float randomness = 90f, bool snapping = false, bool fadeOut = true)
		{
			return DOTween.Shake(() => target.anchoredPosition, delegate(Vector3 x)
			{
				target.anchoredPosition = x;
			}, duration, strength, vibrato, randomness, fadeOut).SetTarget(target).SetSpecialStartupMode(SpecialStartupMode.SetShake)
				.SetOptions(snapping);
		}

		public static Sequence DOJumpAnchorPos(this RectTransform target, Vector2 endValue, float jumpPower, int numJumps, float duration, bool snapping = false)
		{
			if (numJumps < 1)
			{
				numJumps = 1;
			}
			float startPosY = 0f;
			float offsetY = -1f;
			bool offsetYSet = false;
			Sequence s = DOTween.Sequence();
			Tween t = DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(0f, jumpPower), duration / (float)(numJumps * 2)).SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad)
				.SetRelative()
				.SetLoops(numJumps * 2, LoopType.Yoyo)
				.OnStart(delegate
				{
					startPosY = target.anchoredPosition.y;
				});
			s.Append(DOTween.To(() => target.anchoredPosition, delegate(Vector2 x)
			{
				target.anchoredPosition = x;
			}, new Vector2(endValue.x, 0f), duration).SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)).Join(t).SetTarget(target)
				.SetEase(DOTween.defaultEaseType);
			s.OnUpdate(delegate
			{
				if (!offsetYSet)
				{
					offsetYSet = true;
					offsetY = (s.isRelative ? endValue.y : (endValue.y - startPosY));
				}
				Vector2 anchoredPosition = target.anchoredPosition;
				anchoredPosition.y += DOVirtual.EasedValue(0f, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
				target.anchoredPosition = anchoredPosition;
			});
			return s;
		}

		public static Tweener DONormalizedPos(this ScrollRect target, Vector2 endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => new Vector2(target.horizontalNormalizedPosition, target.verticalNormalizedPosition), delegate(Vector2 x)
			{
				target.horizontalNormalizedPosition = x.x;
				target.verticalNormalizedPosition = x.y;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOHorizontalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.horizontalNormalizedPosition, delegate(float x)
			{
				target.horizontalNormalizedPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOVerticalNormalizedPos(this ScrollRect target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.verticalNormalizedPosition, delegate(float x)
			{
				target.verticalNormalizedPosition = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOValue(this Slider target, float endValue, float duration, bool snapping = false)
		{
			return DOTween.To(() => target.value, delegate(float x)
			{
				target.value = x;
			}, endValue, duration).SetOptions(snapping).SetTarget(target);
		}

		public static Tweener DOColor(this Text target, Color endValue, float duration)
		{
			return DOTween.To(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOFade(this Text target, float endValue, float duration)
		{
			return DOTween.ToAlpha(() => target.color, delegate(Color x)
			{
				target.color = x;
			}, endValue, duration).SetTarget(target);
		}

		public static Tweener DOText(this Text target, string endValue, float duration, bool richTextEnabled = true, ScrambleMode scrambleMode = ScrambleMode.None, string scrambleChars = null)
		{
			return DOTween.To(() => target.text, delegate(string x)
			{
				target.text = x;
			}, endValue, duration).SetOptions(richTextEnabled, scrambleMode, scrambleChars).SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Graphic target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Image target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}

		public static Tweener DOBlendableColor(this Text target, Color endValue, float duration)
		{
			endValue -= target.color;
			Color to = new Color(0f, 0f, 0f, 0f);
			return DOTween.To(() => to, delegate(Color x)
			{
				Color color = x - to;
				to = x;
				target.color += color;
			}, endValue, duration).Blendable().SetTarget(target);
		}
	}
	public static class DOTweenModuleUnityVersion
	{
		public static Sequence DOGradientColor(this Material target, Gradient gradient, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static Sequence DOGradientColor(this Material target, Gradient gradient, string property, float duration)
		{
			Sequence sequence = DOTween.Sequence();
			GradientColorKey[] colorKeys = gradient.colorKeys;
			int num = colorKeys.Length;
			for (int i = 0; i < num; i++)
			{
				GradientColorKey gradientColorKey = colorKeys[i];
				if (i == 0 && gradientColorKey.time <= 0f)
				{
					target.color = gradientColorKey.color;
					continue;
				}
				float duration2 = ((i == num - 1) ? (duration - sequence.Duration(includeLoops: false)) : (duration * ((i == 0) ? gradientColorKey.time : (gradientColorKey.time - colorKeys[i - 1].time))));
				sequence.Append(target.DOColor(gradientColorKey.color, property, duration2).SetEase(Ease.Linear));
			}
			return sequence;
		}

		public static CustomYieldInstruction WaitForCompletion(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForCompletion(t);
		}

		public static CustomYieldInstruction WaitForRewind(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForRewind(t);
		}

		public static CustomYieldInstruction WaitForKill(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForKill(t);
		}

		public static CustomYieldInstruction WaitForElapsedLoops(this Tween t, int elapsedLoops, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
		}

		public static CustomYieldInstruction WaitForPosition(this Tween t, float position, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForPosition(t, position);
		}

		public static CustomYieldInstruction WaitForStart(this Tween t, bool returnCustomYieldInstruction)
		{
			if (!t.active)
			{
				if (DG.Tweening.Core.Debugger.logPriority > 0)
				{
					DG.Tweening.Core.Debugger.LogInvalidTween(t);
				}
				return null;
			}
			return new DOTweenCYInstruction.WaitForStart(t);
		}
	}
	public static class DOTweenCYInstruction
	{
		public class WaitForCompletion : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.IsComplete();
					}
					return false;
				}
			}

			public WaitForCompletion(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForRewind : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						if (t.playedOnce)
						{
							return t.position * (float)(t.CompletedLoops() + 1) > 0f;
						}
						return true;
					}
					return false;
				}
			}

			public WaitForRewind(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForKill : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting => t.active;

			public WaitForKill(Tween tween)
			{
				t = tween;
			}
		}

		public class WaitForElapsedLoops : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly int elapsedLoops;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.CompletedLoops() < elapsedLoops;
					}
					return false;
				}
			}

			public WaitForElapsedLoops(Tween tween, int elapsedLoops)
			{
				t = tween;
				this.elapsedLoops = elapsedLoops;
			}
		}

		public class WaitForPosition : CustomYieldInstruction
		{
			private readonly Tween t;

			private readonly float position;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return t.position * (float)(t.CompletedLoops() + 1) < position;
					}
					return false;
				}
			}

			public WaitForPosition(Tween tween, float position)
			{
				t = tween;
				this.position = position;
			}
		}

		public class WaitForStart : CustomYieldInstruction
		{
			private readonly Tween t;

			public override bool keepWaiting
			{
				get
				{
					if (t.active)
					{
						return !t.playedOnce;
					}
					return false;
				}
			}

			public WaitForStart(Tween tween)
			{
				t = tween;
			}
		}
	}
	public static class DOTweenModuleUtils
	{
		public static class Physics
		{
			public static void SetOrientationOnPath(PathOptions options, Tween t, Quaternion newRot, Transform trans)
			{
				trans.rotation = newRot;
			}

			public static bool HasRigidbody2D(Component target)
			{
				return false;
			}

			public static bool HasRigidbody(Component target)
			{
				return false;
			}

			public static TweenerCore<Vector3, DG.Tweening.Plugins.Core.PathCore.Path, PathOptions> CreateDOTweenPathTween(MonoBehaviour target, bool tweenRigidbody, bool isLocal, DG.Tweening.Plugins.Core.PathCore.Path path, float duration, PathMode pathMode)
			{
				if (!isLocal)
				{
					return target.transform.DOPath(path, duration, pathMode);
				}
				return target.transform.DOLocalPath(path, duration, pathMode);
			}
		}

		private static bool _initialized;

		public static void Init()
		{
			if (!_initialized)
			{
				_initialized = true;
				DOTweenExternalCommand.SetOrientationOnPath += Physics.SetOrientationOnPath;
			}
		}
	}
}
namespace UnityEngine.EventSystems
{
	public class LaserPointerEventData : PointerEventData
	{
		public LaserController laserController;

		public Vector3 dim3Position;

		public Vector3 dim3PressPosition;

		public LaserPointerEventData(EventSystem eventSystem)
			: base(eventSystem)
		{
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("<b>Position</b>: " + base.position);
			stringBuilder.AppendLine("<b>delta</b>: " + base.delta);
			stringBuilder.AppendLine("<b>scrollDelta</b>: " + base.scrollDelta);
			stringBuilder.AppendLine("<b>pointerEnter</b>: " + base.pointerEnter);
			stringBuilder.AppendLine("<b>pointerPress</b>: " + base.pointerPress);
			stringBuilder.AppendLine("<b>lastPointerPress</b>: " + base.lastPress);
			stringBuilder.AppendLine("<b>pointerDrag</b>: " + base.pointerDrag);
			return stringBuilder.ToString();
		}
	}
	public static class LaserPointerEventDataExtension
	{
		public static bool IsLaserPointer(this PointerEventData pointerEventData)
		{
			return pointerEventData is LaserPointerEventData;
		}

		public static LaserController GetLaserController(this PointerEventData pointerEventData)
		{
			return (pointerEventData as LaserPointerEventData).laserController;
		}
	}
}
namespace UnityEngine.Timeline
{
	public class VideoPlayableBehaviour : PlayableBehaviour
	{
		public VideoPlayer videoPlayer;

		public VideoClip videoClip;

		public bool mute;

		public bool loop = true;

		public double preloadTime = 0.3;

		public double clipInTime;

		private bool playedOnce;

		private bool preparing;

		public void PrepareVideo()
		{
			if (videoPlayer == null || videoClip == null)
			{
				return;
			}
			videoPlayer.targetCameraAlpha = 0f;
			if (videoPlayer.clip != videoClip)
			{
				StopVideo();
			}
			if (videoPlayer.isPrepared || preparing)
			{
				return;
			}
			videoPlayer.source = VideoSource.VideoClip;
			videoPlayer.clip = videoClip;
			videoPlayer.playOnAwake = false;
			videoPlayer.waitForFirstFrame = true;
			videoPlayer.isLooping = loop;
			for (ushort num = 0; num < videoClip.audioTrackCount; num++)
			{
				if (videoPlayer.audioOutputMode == VideoAudioOutputMode.Direct)
				{
					videoPlayer.SetDirectAudioMute(num, mute || !Application.isPlaying);
				}
				else if (videoPlayer.audioOutputMode == VideoAudioOutputMode.AudioSource)
				{
					AudioSource targetAudioSource = videoPlayer.GetTargetAudioSource(num);
					if (targetAudioSource != null)
					{
						targetAudioSource.mute = mute || !Application.isPlaying;
					}
				}
			}
			videoPlayer.loopPointReached += LoopPointReached;
			videoPlayer.time = clipInTime;
			videoPlayer.Prepare();
			preparing = true;
		}

		private void LoopPointReached(VideoPlayer vp)
		{
			playedOnce = !loop;
		}

		public override void PrepareFrame(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null) && !(videoClip == null))
			{
				videoPlayer.timeReference = (Application.isPlaying ? VideoTimeReference.ExternalTime : VideoTimeReference.Freerun);
				if (videoPlayer.isPlaying && Application.isPlaying)
				{
					videoPlayer.externalReferenceTime = playable.GetTime();
				}
				else if (!Application.isPlaying)
				{
					SyncVideoToPlayable(playable);
				}
			}
		}

		public override void OnBehaviourPlay(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null) && !playedOnce)
			{
				PlayVideo();
				SyncVideoToPlayable(playable);
			}
		}

		public override void OnBehaviourPause(Playable playable, FrameData info)
		{
			if (!(videoPlayer == null))
			{
				if (Application.isPlaying)
				{
					PauseVideo();
				}
				else
				{
					StopVideo();
				}
			}
		}

		public override void ProcessFrame(Playable playable, FrameData info, object playerData)
		{
			if (videoPlayer == null || videoPlayer.clip == null)
			{
				return;
			}
			videoPlayer.targetCameraAlpha = info.weight;
			if (!Application.isPlaying)
			{
				return;
			}
			for (ushort num = 0; num < videoPlayer.clip.audioTrackCount; num++)
			{
				if (videoPlayer.audioOutputMode == VideoAudioOutputMode.Direct)
				{
					videoPlayer.SetDirectAudioVolume(num, info.weight);
				}
				else if (videoPlayer.audioOutputMode == VideoAudioOutputMode.AudioSource)
				{
					AudioSource targetAudioSource = videoPlayer.GetTargetAudioSource(num);
					if (targetAudioSource != null)
					{
						targetAudioSource.volume = info.weight;
					}
				}
			}
		}

		public override void OnGraphStart(Playable playable)
		{
			playedOnce = false;
		}

		public override void OnGraphStop(Playable playable)
		{
			if (!Application.isPlaying)
			{
				StopVideo();
			}
		}

		public override void OnPlayableDestroy(Playable playable)
		{
			StopVideo();
		}

		public void PlayVideo()
		{
			if (!(videoPlayer == null))
			{
				videoPlayer.Play();
				preparing = false;
				if (!Application.isPlaying)
				{
					PauseVideo();
				}
			}
		}

		public void PauseVideo()
		{
			if (!(videoPlayer == null))
			{
				videoPlayer.Pause();
				preparing = false;
			}
		}

		public void StopVideo()
		{
			if (!(videoPlayer == null))
			{
				playedOnce = false;
				videoPlayer.Stop();
				preparing = false;
			}
		}

		private void SyncVideoToPlayable(Playable playable)
		{
			if (!(videoPlayer == null) && !(videoPlayer.clip == null))
			{
				videoPlayer.time = (clipInTime + playable.GetTime() * (double)videoPlayer.playbackSpeed) % videoPlayer.clip.length;
			}
		}
	}
	public sealed class VideoSchedulerPlayableBehaviour : PlayableBehaviour
	{
		private IEnumerable<TimelineClip> m_Clips;

		private PlayableDirector m_Director;

		internal PlayableDirector director
		{
			get
			{
				return m_Director;
			}
			set
			{
				m_Director = value;
			}
		}

		internal IEnumerable<TimelineClip> clips
		{
			get
			{
				return m_Clips;
			}
			set
			{
				m_Clips = value;
			}
		}

		public override void ProcessFrame(Playable playable, FrameData info, object playerData)
		{
			if (m_Clips == null)
			{
				return;
			}
			int num = 0;
			foreach (TimelineClip clip in m_Clips)
			{
				VideoPlayableBehaviour behaviour = ((ScriptPlayable<VideoPlayableBehaviour>)playable.GetInput(num)).GetBehaviour();
				if (behaviour != null)
				{
					double num2 = Math.Max(0.0, behaviour.preloadTime);
					if (m_Director.time >= clip.start + clip.duration || m_Director.time <= clip.start - num2)
					{
						behaviour.StopVideo();
					}
					else if (m_Director.time > clip.start - num2)
					{
						behaviour.PrepareVideo();
					}
				}
				num++;
			}
		}
	}
	[Serializable]
	public class VideoScriptPlayableAsset : PlayableAsset
	{
		public ExposedReference<VideoPlayer> videoPlayer;

		[SerializeField]
		[NotKeyable]
		public VideoClip videoClip;

		[SerializeField]
		[NotKeyable]
		public bool mute;

		[SerializeField]
		[NotKeyable]
		public bool loop = true;

		[SerializeField]
		[NotKeyable]
		public double preloadTime = 0.3;

		[SerializeField]
		[NotKeyable]
		public double clipInTime;

		public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
		{
			ScriptPlayable<VideoPlayableBehaviour> scriptPlayable = ScriptPlayable<VideoPlayableBehaviour>.Create(graph);
			VideoPlayableBehaviour behaviour = scriptPlayable.GetBehaviour();
			behaviour.videoPlayer = videoPlayer.Resolve(graph.GetResolver());
			behaviour.videoClip = videoClip;
			behaviour.mute = mute;
			behaviour.loop = loop;
			behaviour.preloadTime = preloadTime;
			behaviour.clipInTime = clipInTime;
			return scriptPlayable;
		}
	}
	[Serializable]
	[TrackClipType(typeof(VideoScriptPlayableAsset))]
	[TrackColor(0.008f, 0.698f, 0.655f)]
	public class VideoScriptPlayableTrack : TrackAsset
	{
		public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
		{
			PlayableDirector component = go.GetComponent<PlayableDirector>();
			ScriptPlayable<VideoSchedulerPlayableBehaviour> scriptPlayable = ScriptPlayable<VideoSchedulerPlayableBehaviour>.Create(graph, inputCount);
			VideoSchedulerPlayableBehaviour behaviour = scriptPlayable.GetBehaviour();
			if (behaviour != null)
			{
				behaviour.director = component;
				behaviour.clips = GetClips();
			}
			return scriptPlayable;
		}
	}
}
namespace MaxNeet
{
	public class SensitivityChecker : MonoBehaviour
	{
		public enum CalclateAXIS
		{
			X,
			Y,
			Z
		}

		private const float DEFAULT_FPS = 60f;

		[SerializeField]
		private CalclateAXIS currentAxis;

		[SerializeField]
		private float m_latestValue = 1000f;

		[SerializeField]
		private int m_secondsToCount = 6;

		[SerializeField]
		[Tooltip("700くらいだと停止っぽい")]
		private float m_sensitivity = 700f;

		public Action OnPausedAction;

		private Transform m_mainCamera;

		private List<float> m_chachedEulerAngles = new List<float>();

		private float m_frameRate = 60f;

		public float LatestValue => m_latestValue;

		private void OnEnable()
		{
			if (m_mainCamera == null)
			{
				m_mainCamera = Camera.main.transform;
			}
			if (m_mainCamera == null)
			{
				UnityEngine.Debug.LogError("シーンにメインカメラが存在しません");
				UnityEngine.Object.Destroy(this);
				return;
			}
			m_frameRate = UnityEngine.Application.targetFrameRate;
			if (m_frameRate < 0f)
			{
				m_frameRate = 60f;
			}
			StartCoroutine(CheckSensitivity());
		}

		private void OnDisable()
		{
			StopAllCoroutines();
		}

		private IEnumerator CheckSensitivity()
		{
			yield return new WaitForSeconds(1f);
			while (true)
			{
				yield return new WaitForSeconds(2f);
				if ((float)m_chachedEulerAngles.Count <= m_frameRate * (float)m_secondsToCount - 2f)
				{
					continue;
				}
				float num = (m_latestValue = GetVariance());
				UnityEngine.Debug.Log("キャッシュされてる分散値は:" + num);
				if (m_sensitivity > num)
				{
					UnityEngine.Debug.Log("停止を検出");
					if (OnPausedAction != null)
					{
						OnPausedAction();
					}
					m_chachedEulerAngles.Clear();
				}
			}
		}

		private float GetVariance()
		{
			float num = m_chachedEulerAngles.Average();
			float num2 = 0f;
			int count = m_chachedEulerAngles.Count;
			for (int i = 0; i < count; i++)
			{
				num2 += Mathf.Pow(m_chachedEulerAngles[i] - num, 2f);
			}
			return num2 / (float)m_secondsToCount;
		}

		private void Update()
		{
			UpdateEularAngleChach();
		}

		private void UpdateEularAngleChach()
		{
			float currentAngle = GetCurrentAngle();
			m_chachedEulerAngles.Add(currentAngle);
			if ((float)m_chachedEulerAngles.Count > m_frameRate * (float)m_secondsToCount)
			{
				m_chachedEulerAngles.RemoveAt(0);
			}
		}

		private float GetCurrentAngle()
		{
			return currentAxis switch
			{
				CalclateAXIS.X => m_mainCamera.eulerAngles.x * 100f, 
				CalclateAXIS.Y => m_mainCamera.eulerAngles.y * 100f, 
				CalclateAXIS.Z => m_mainCamera.eulerAngles.z * 100f, 
				_ => m_mainCamera.eulerAngles.x * 100f, 
			};
		}
	}
}
namespace Common
{
	public static class AudioSourceExtension
	{
		public static bool Play(this AudioSource source, AudioClip clip = null, float volume = 1f)
		{
			if (clip == null || volume <= 0f)
			{
				return false;
			}
			source.clip = clip;
			source.volume = volume;
			source.Play();
			return true;
		}
	}
	public static class CameraExtensions
	{
		public static void LayerCullingShow(this Camera cam, int layerMask)
		{
			cam.cullingMask |= layerMask;
		}

		public static void LayerCullingShow(this Camera cam, string layer)
		{
			cam.LayerCullingShow(1 << LayerMask.NameToLayer(layer));
		}

		public static void LayerCullingHide(this Camera cam, int layerMask)
		{
			cam.cullingMask &= ~layerMask;
		}

		public static void LayerCullingHide(this Camera cam, string layer)
		{
			cam.LayerCullingHide(1 << LayerMask.NameToLayer(layer));
		}

		public static void LayerCullingToggle(this Camera cam, int layerMask)
		{
			cam.cullingMask ^= layerMask;
		}

		public static void LayerCullingToggle(this Camera cam, string layer)
		{
			cam.LayerCullingToggle(1 << LayerMask.NameToLayer(layer));
		}

		public static bool LayerCullingIncludes(this Camera cam, int layerMask)
		{
			return (cam.cullingMask & layerMask) > 0;
		}

		public static bool LayerCullingIncludes(this Camera cam, string layer)
		{
			return cam.LayerCullingIncludes(1 << LayerMask.NameToLayer(layer));
		}

		public static void LayerCullingToggle(this Camera cam, int layerMask, bool isOn)
		{
			bool flag = cam.LayerCullingIncludes(layerMask);
			if (isOn && !flag)
			{
				cam.LayerCullingShow(layerMask);
			}
			else if (!isOn && flag)
			{
				cam.LayerCullingHide(layerMask);
			}
		}

		public static void LayerCullingToggle(this Camera cam, string layer, bool isOn)
		{
			cam.LayerCullingToggle(1 << LayerMask.NameToLayer(layer), isOn);
		}
	}
	public static class ColorExtension
	{
		public static Color WithAlpha(this Color color, float alpha)
		{
			return new Color(color.r, color.g, color.b, alpha);
		}
	}
	public static class GameObjectExtension
	{
		public static void Destroy(this GameObject self)
		{
			UnityEngine.Object.Destroy(self);
		}

		public static bool HasComponent<T>(this GameObject self) where T : Component
		{
			return self.GetComponent<T>() != null;
		}

		public static T GetOrAddComponent<T>(this GameObject self) where T : Component
		{
			return self.GetComponent<T>() ?? self.AddComponent<T>();
		}

		public static bool IsNull(GameObject obj)
		{
			return (object)obj == null;
		}
	}
	public static class MonoBehaviourExtension
	{
		public static void Destroy(this Component self)
		{
			UnityEngine.Object.Destroy(self);
		}

		public static void DestroyImmediate(this Component self)
		{
			UnityEngine.Object.DestroyImmediate(self);
		}

		public static bool HasComponent<T>(this Component self) where T : Component
		{
			return self.GetComponent<T>() != null;
		}
	}
	public static class QuaternionExtension
	{
		public static readonly Quaternion IDENTITY = new Quaternion(0f, 0f, 0f, 1f);

		private static Matrix4x4 _tempMatrix = Matrix4x4.identity;

		private static float[] _calculationFloats = new float[4];

		private static float[] _cauculattionMaterixElements = new float[4];

		public static Vector3 CreateUp(this Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Up, ref rotation);
		}

		public static Vector3 CreateUp(ref Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Up, ref rotation);
		}

		public static Vector3 CreateRight(ref Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Right, ref rotation);
		}

		public static Vector3 CreateRight(this Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Right, ref rotation);
		}

		public static Vector3 CreateForward(ref Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Forward, ref rotation);
		}

		public static Vector3 CreateForward(this Quaternion rotation)
		{
			return Vector3Extension.Multiply(ref Vector3Extension.Forward, ref rotation);
		}

		public static Quaternion GetLookAt(ref Vector3 position, ref Vector3 target)
		{
			Vector3 rhs = Vector3Extension.Direction(ref target, ref position);
			Vector3 v = Vector3Extension.CrossProduct(ref Vector3Extension.Up, ref rhs);
			Vector3Extension.Normalize(ref v);
			Vector3 v2 = Vector3Extension.CrossProduct(ref rhs, ref v);
			Vector3Extension.Normalize(ref v2);
			Matrix4x4 m = Matrix4x4.identity;
			m[0, 0] = v.x;
			m[0, 1] = v2.x;
			m[0, 2] = rhs.x;
			m[1, 0] = v.y;
			m[1, 1] = v2.y;
			m[1, 2] = rhs.y;
			m[2, 0] = v.z;
			m[2, 1] = v2.z;
			m[2, 2] = rhs.z;
			return GetRotation(ref m);
		}

		public static void CreateLookAt(ref Vector3 position, ref Vector3 target, ref Quaternion rotation)
		{
			Vector3 rhs = Vector3Extension.Direction(ref target, ref position);
			Vector3 v = Vector3Extension.CrossProduct(ref Vector3Extension.Up, ref rhs);
			Vector3Extension.Normalize(ref v);
			Vector3 v2 = Vector3Extension.CrossProduct(ref rhs, ref v);
			Vector3Extension.Normalize(ref v2);
			_tempMatrix = Matrix4x4.identity;
			_tempMatrix[0, 0] = v.x;
			_tempMatrix[0, 1] = v2.x;
			_tempMatrix[0, 2] = rhs.x;
			_tempMatrix[1, 0] = v.y;
			_tempMatrix[1, 1] = v2.y;
			_tempMatrix[1, 2] = rhs.y;
			_tempMatrix[2, 0] = v.z;
			_tempMatrix[2, 1] = v2.z;
			_tempMatrix[2, 2] = rhs.z;
			SetRotation(ref _tempMatrix, ref rotation);
		}

		public static Quaternion Slerp(ref Quaternion a, ref Quaternion b, float t)
		{
			t = Mathf.Clamp(t, 0f, 1f);
			return SlerpUnclamped(ref a, ref b, t);
		}

		private static Quaternion SlerpUnclamped(ref Quaternion a, ref Quaternion b, float t)
		{
			if (LengthSquared(ref a) == 0f)
			{
				if (LengthSquared(ref b) == 0f)
				{
					return IDENTITY;
				}
				return b;
			}
			if (LengthSquared(ref b) == 0f)
			{
				return a;
			}
			Vector3 lhs = new Vector3(a.x, a.y, a.z);
			Vector3 rhs = new Vector3(b.x, b.y, b.z);
			float w = a.w;
			float w2 = b.w;
			float num = w * w2 + Vector3Extension.DotProduct(ref lhs, ref rhs);
			if (num >= 1f || num <= -1f)
			{
				return a;
			}
			if (num < 0f)
			{
				Vector3 target = rhs;
				Vector3Extension.MultiplyTarget(-1f, ref target);
				b.x = target.x;
				b.y = target.y;
				b.z = target.z;
				w2 = 0f - w2;
				b.w = w2;
				num = 0f - num;
			}
			float num5;
			float num6;
			if (num < 0.99f)
			{
				float num2 = (float)Math.Acos(num);
				float num3 = (float)Math.Sin(num2);
				float num4 = 1f / num3;
				num5 = (float)Math.Sin(num2 * (1f - t)) * num4;
				num6 = (float)Math.Sin(num2 * t) * num4;
			}
			else
			{
				num5 = 1f - t;
				num6 = t;
			}
			float x = num5 * a.x + num6 * b.x;
			float y = num5 * a.y + num6 * b.y;
			float z = num5 * a.z + num6 * b.z;
			float w3 = num5 * a.w + num6 * b.w;
			Quaternion a2 = new Quaternion(x, y, z, w3);
			if (LengthSquared(ref a2) > 0f)
			{
				Normalize(ref a2);
				return a2;
			}
			return IDENTITY;
		}

		public static float LengthSquared(ref Quaternion a)
		{
			return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
		}

		public static float LengthSquared(this Quaternion a)
		{
			return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
		}

		public static void Normalize(ref Quaternion a)
		{
			float num = 1f / Length(ref a);
			a.x *= num;
			a.y *= num;
			a.z *= num;
			a.w *= num;
		}

		public static float Length(ref Quaternion a)
		{
			return (float)Math.Sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
		}

		private static void SetRotation(ref Matrix4x4 m, ref Quaternion result)
		{
			_cauculattionMaterixElements[0] = m.m00 - m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[1] = 0f - m.m00 + m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[2] = 0f - m.m00 - m.m11 + m.m22 + 1f;
			_cauculattionMaterixElements[3] = m.m00 + m.m11 + m.m22 + 1f;
			int num = _cauculattionMaterixElements.Length;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (_cauculattionMaterixElements[i] > _cauculattionMaterixElements[num2])
				{
					num2 = i;
				}
			}
			if (_cauculattionMaterixElements[num2] < 0f)
			{
				result = IDENTITY;
				return;
			}
			float num3 = Mathf.Sqrt(_cauculattionMaterixElements[num2]) * 0.5f;
			_calculationFloats[num2] = num3;
			float num4 = 0.25f / num3;
			switch (num2)
			{
			case 0:
				_calculationFloats[1] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m02 + m.m20) * num4;
				_calculationFloats[3] = (m.m21 - m.m12) * num4;
				break;
			case 1:
				_calculationFloats[0] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m02 - m.m20) * num4;
				break;
			case 2:
				_calculationFloats[0] = (m.m02 + m.m20) * num4;
				_calculationFloats[1] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m10 - m.m01) * num4;
				break;
			case 3:
				_calculationFloats[0] = (m.m21 - m.m12) * num4;
				_calculationFloats[1] = (m.m02 - m.m20) * num4;
				_calculationFloats[2] = (m.m10 - m.m01) * num4;
				break;
			}
			result.x = _calculationFloats[0];
			result.y = _calculationFloats[1];
			result.z = _calculationFloats[2];
			result.w = _calculationFloats[3];
		}

		private static Quaternion GetRotation(ref Matrix4x4 m)
		{
			_cauculattionMaterixElements[0] = m.m00 - m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[1] = 0f - m.m00 + m.m11 - m.m22 + 1f;
			_cauculattionMaterixElements[2] = 0f - m.m00 - m.m11 + m.m22 + 1f;
			_cauculattionMaterixElements[3] = m.m00 + m.m11 + m.m22 + 1f;
			int num = _cauculattionMaterixElements.Length;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (_cauculattionMaterixElements[i] > _cauculattionMaterixElements[num2])
				{
					num2 = i;
				}
			}
			if (_cauculattionMaterixElements[num2] < 0f)
			{
				return default(Quaternion);
			}
			float num3 = Mathf.Sqrt(_cauculattionMaterixElements[num2]) * 0.5f;
			_calculationFloats[num2] = num3;
			float num4 = 0.25f / num3;
			switch (num2)
			{
			case 0:
				_calculationFloats[1] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m02 + m.m20) * num4;
				_calculationFloats[3] = (m.m21 - m.m12) * num4;
				break;
			case 1:
				_calculationFloats[0] = (m.m10 + m.m01) * num4;
				_calculationFloats[2] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m02 - m.m20) * num4;
				break;
			case 2:
				_calculationFloats[0] = (m.m02 + m.m20) * num4;
				_calculationFloats[1] = (m.m21 + m.m12) * num4;
				_calculationFloats[3] = (m.m10 - m.m01) * num4;
				break;
			case 3:
				_calculationFloats[0] = (m.m21 - m.m12) * num4;
				_calculationFloats[1] = (m.m02 - m.m20) * num4;
				_calculationFloats[2] = (m.m10 - m.m01) * num4;
				break;
			}
			return new Quaternion(_calculationFloats[0], _calculationFloats[1], _calculationFloats[2], _calculationFloats[3]);
		}
	}
	public static class RectTransformExtension
	{
		public static float GetWidth(this RectTransform self)
		{
			return self.sizeDelta.x;
		}

		public static float GetHeight(this RectTransform self)
		{
			return self.sizeDelta.y;
		}

		public static void SetWidth(this RectTransform self, float width)
		{
			Vector2 sizeDelta = self.sizeDelta;
			sizeDelta.x = width;
			self.sizeDelta = sizeDelta;
		}

		public static void SetHeight(this RectTransform self, float height)
		{
			Vector2 sizeDelta = self.sizeDelta;
			sizeDelta.y = height;
			self.sizeDelta = sizeDelta;
		}

		public static void SetSize(this RectTransform self, float width, float height)
		{
			self.sizeDelta = new Vector2(width, height);
		}

		private static int CountCornersVisibleFrom(RectTransform rectTransform, Rect windowRect)
		{
			Vector3[] array = new Vector3[4];
			rectTransform.GetWorldCorners(array);
			int num = 0;
			foreach (Vector3 point in array)
			{
				if (windowRect.Contains(point))
				{
					num++;
				}
			}
			return num;
		}

		public static Rect GetWorldRect(this RectTransform rt, Vector2 scale)
		{
			Vector3[] array = new Vector3[4];
			rt.GetWorldCorners(array);
			Vector3 vector = array[0];
			Vector3 vector2 = array[2];
			float width = Mathf.Abs(vector2.x - vector.x);
			float height = Mathf.Abs(vector.y - vector2.y);
			return new Rect(vector.x, vector.y, width, height);
		}

		public static bool IsFullyVisibleFrom(this RectTransform rectTransform, Rect windowRect)
		{
			return CountCornersVisibleFrom(rectTransform, windowRect) == 4;
		}

		public static bool IsVisibleFrom(this RectTransform rectTransform, Rect windowRect)
		{
			return CountCornersVisibleFrom(rectTransform, windowRect) > 0;
		}
	}
	public static class StringExtension
	{
		public static bool FastStartsWith(this string a, string b)
		{
			int length = a.Length;
			int length2 = b.Length;
			int num = 0;
			int num2 = 0;
			while (num < length && num2 < length2 && a[num] == b[num2])
			{
				num++;
				num2++;
			}
			if (num2 != length2 || length < length2)
			{
				if (num == length)
				{
					return length2 >= length;
				}
				return false;
			}
			return true;
		}

		public static bool FastEndsWith(this string a, string b)
		{
			int num = a.Length - 1;
			int num2 = b.Length - 1;
			while (num >= 0 && num2 >= 0 && a[num] == b[num2])
			{
				num--;
				num2--;
			}
			if (num2 >= 0 || a.Length < b.Length)
			{
				if (num < 0)
				{
					return b.Length >= a.Length;
				}
				return false;
			}
			return true;
		}
	}
	public static class TransformExtension
	{
		public static Transform FindDeep(this Component self, string name, bool isIncludeInactive = false)
		{
			Transform[] componentsInChildren = self.GetComponentsInChildren<Transform>(isIncludeInactive);
			foreach (Transform transform in componentsInChildren)
			{
				if (transform.name == name)
				{
					return transform;
				}
			}
			return null;
		}

		public static void ResetLocal(this Transform transform)
		{
			transform.localPosition = Vector3.zero;
			transform.localRotation = Quaternion.identity;
			transform.localScale = Vector3.one;
		}

		public static void ResetLocal(this Transform transform, bool isResetPosition, bool isResetRotation, bool isResetScale)
		{
			if (isResetPosition)
			{
				transform.localPosition = Vector3.zero;
			}
			if (isResetRotation)
			{
				transform.localRotation = Quaternion.identity;
			}
			if (isResetScale)
			{
				transform.localScale = Vector3.one;
			}
		}

		public static void ResetWorld(this Transform transform)
		{
			transform.position = Vector3.zero;
			transform.rotation = Quaternion.identity;
		}

		public static void ResetWorld(this Transform transform, bool isResetPosition, bool isResetRotation)
		{
			if (isResetPosition)
			{
				transform.position = Vector3.zero;
			}
			if (isResetRotation)
			{
				transform.rotation = Quaternion.identity;
			}
		}

		public static void TranslateX(this Transform self, float x)
		{
			self.Translate(x, 0f, 0f);
		}

		public static void TranslateY(this Transform self, float y)
		{
			self.Translate(0f, y, 0f);
		}

		public static void TranslateZ(this Transform self, float z)
		{
			self.Translate(0f, 0f, z);
		}

		public static void AddChildren(this Transform self, GameObject[] children)
		{
			Array.ForEach(children, delegate(GameObject child)
			{
				child.transform.parent = self;
			});
		}

		public static Vector3 CreateUp(this Transform self)
		{
			Quaternion rotation = self.rotation;
			return Vector3Extension.Multiply(ref Vector3Extension.Up, ref rotation);
		}

		public static Vector3 CreateRight(this Transform self)
		{
			Quaternion rotation = self.rotation;
			return Vector3Extension.Multiply(ref Vector3Extension.Right, ref rotation);
		}

		public static Vector3 CreateForward(this Transform self)
		{
			Quaternion rotation = self.rotation;
			return Vector3Extension.Multiply(ref Vector3Extension.Forward, ref rotation);
		}
	}
	public static class Vector2Extension
	{
		public static float Length(this Vector2 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y);
		}

		public static float Length(ref Vector2 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y);
		}
	}
	public static class Vector3Extension
	{
		public const float kEpsilon = 1E-05f;

		public const float kEpsilonNormalSqrt = 1E-15f;

		public static Vector3 Zero = Vector3.zero;

		public static Vector3 Up = Vector3.up;

		public static Vector3 Right = Vector3.right;

		public static Vector3 Forward = Vector3.forward;

		public static void Add(this Vector3 a, ref Vector3 b)
		{
			a.x += b.x;
			a.y += b.y;
			a.z += b.z;
		}

		public static Vector3 Add(ref Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x + b.x;
			result.y = a.y + b.y;
			result.z = a.z + b.z;
			return result;
		}

		public static void Add(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x + b.x;
			result.y = a.y + b.y;
			result.z = a.z + b.z;
		}

		public static void AddTarget(ref Vector3 addTo, ref Vector3 addAmount)
		{
			addTo.x += addAmount.x;
			addTo.y += addAmount.y;
			addTo.z += addAmount.z;
		}

		public static void Subtract(this Vector3 a, ref Vector3 b)
		{
			a.x -= b.x;
			a.y -= b.y;
			a.z -= b.z;
		}

		public static Vector3 Subtract(ref Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x - b.x;
			result.y = a.y - b.y;
			result.z = a.z - b.z;
			return result;
		}

		public static void Subtract(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x - b.x;
			result.y = a.y - b.y;
			result.z = a.z - b.z;
		}

		public static void SubtractTarget(ref Vector3 target, ref Vector3 subtractAmount)
		{
			target.x -= subtractAmount.x;
			target.y -= subtractAmount.y;
			target.z -= subtractAmount.z;
		}

		public static Vector3 Multiply(this Vector3 a, float d)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * d;
			result.y = a.y * d;
			result.z = a.z * d;
			return result;
		}

		public static Vector3 Multiply(this Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * b.x;
			result.y = a.y * b.y;
			result.z = a.z * b.z;
			return result;
		}

		public static Vector3 Multiply(ref Vector3 a, float d)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * d;
			result.y = a.y * d;
			result.z = a.z * d;
			return result;
		}

		public static void Multiply(ref Vector3 a, float d, out Vector3 result)
		{
			result.x = a.x * d;
			result.y = a.y * d;
			result.z = a.z * d;
		}

		public static Vector3 Multiply(ref Vector3 a, ref Vector3 b)
		{
			Vector3 result = default(Vector3);
			result.x = a.x * b.x;
			result.y = a.y * b.y;
			result.z = a.z * b.z;
			return result;
		}

		public static void Multiply(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x * b.x;
			result.y = a.y * b.y;
			result.z = a.z * b.z;
		}

		public static Vector3 Multiply(ref Vector3 point, ref Quaternion rotation)
		{
			float num = rotation.x * 2f;
			float num2 = rotation.y * 2f;
			float num3 = rotation.z * 2f;
			float num4 = rotation.x * num;
			float num5 = rotation.y * num2;
			float num6 = rotation.z * num3;
			float num7 = rotation.x * num2;
			float num8 = rotation.x * num3;
			float num9 = rotation.y * num3;
			float num10 = rotation.w * num;
			float num11 = rotation.w * num2;
			float num12 = rotation.w * num3;
			Vector3 result = default(Vector3);
			result.x = (1f - (num5 + num6)) * point.x + (num7 - num12) * point.y + (num8 + num11) * point.z;
			result.y = (num7 + num12) * point.x + (1f - (num4 + num6)) * point.y + (num9 - num10) * point.z;
			result.z = (num8 - num11) * point.x + (num9 + num10) * point.y + (1f - (num4 + num5)) * point.z;
			return result;
		}

		public static void MultiplyTarget(float amount, ref Vector3 target)
		{
			target.x *= amount;
			target.y *= amount;
			target.z *= amount;
		}

		public static void MultiplyTarget(ref Vector3 amount, ref Vector3 target)
		{
			target.x *= amount.x;
			target.y *= amount.y;
			target.z *= amount.z;
		}

		public static void MultiplyTarget(ref Quaternion rotation, ref Vector3 target)
		{
			float num = rotation.x * 2f;
			float num2 = rotation.y * 2f;
			float num3 = rotation.z * 2f;
			float num4 = rotation.x * num;
			float num5 = rotation.y * num2;
			float num6 = rotation.z * num3;
			float num7 = rotation.x * num2;
			float num8 = rotation.x * num3;
			float num9 = rotation.y * num3;
			float num10 = rotation.w * num;
			float num11 = rotation.w * num2;
			float num12 = rotation.w * num3;
			target.x = (1f - (num5 + num6)) * target.x + (num7 - num12) * target.y + (num8 + num11) * target.z;
			target.y = (num7 + num12) * target.x + (1f - (num4 + num6)) * target.y + (num9 - num10) * target.z;
			target.z = (num8 - num11) * target.x + (num9 + num10) * target.y + (1f - (num4 + num5)) * target.z;
		}

		public static void Divide(this Vector3 a, float d)
		{
			a.x /= d;
			a.y /= d;
			a.z /= d;
		}

		public static Vector3 Divide(ref Vector3 a, float d)
		{
			Vector3 result = default(Vector3);
			result.x = a.x / d;
			result.y = a.y / d;
			result.z = a.z / d;
			return result;
		}

		public static void DivideOut(float d, ref Vector3 result)
		{
			result.x /= d;
			result.y /= d;
			result.z /= d;
		}

		public static void Divide(ref Vector3 a, float d, out Vector3 result)
		{
			result.x = a.x / d;
			result.y = a.y / d;
			result.z = a.z / d;
		}

		public static void Divide(ref Vector3 a, ref Vector3 b, out Vector3 result)
		{
			result.x = a.x / b.x;
			result.y = a.y / b.y;
			result.z = a.z / b.z;
		}

		public static Vector3 GetClosest(this Vector3 position, IEnumerable<Vector3> otherPositions)
		{
			Vector3 result = Vector3.zero;
			float num = float.PositiveInfinity;
			foreach (Vector3 otherPosition in otherPositions)
			{
				float sqrMagnitude = (position - otherPosition).sqrMagnitude;
				if (sqrMagnitude < num)
				{
					result = otherPosition;
					num = sqrMagnitude;
				}
			}
			return result;
		}

		public static void RotateAroundPivot(this Vector3 point, Vector3 pivot, Quaternion angle)
		{
			point = angle * (point - pivot) + pivot;
		}

		public static void RotateAroundPivot(this Vector3 point, Vector3 pivot, Vector3 euler)
		{
			point.RotateAroundPivot(pivot, Quaternion.Euler(euler));
		}

		public static void RotateAround(this Vector3 pos, ref Quaternion rotation, Vector3 point, Vector3 axis, float angle)
		{
			Vector3 vector = pos;
			Quaternion quaternion = Quaternion.AngleAxis(angle, axis);
			Vector3 vector2 = vector - point;
			vector2 = quaternion * vector2;
			pos = point + vector2;
			Quaternion quaternion2 = rotation;
			rotation *= Quaternion.Inverse(quaternion2) * quaternion * quaternion2;
		}

		public static float Normalize(ref Vector3 v, out Vector3 vv)
		{
			float num = (float)Math.Sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
			vv.x = v.x / num;
			vv.y = v.y / num;
			vv.z = v.z / num;
			return num;
		}

		public static float NormalizeXZ(ref Vector3 v)
		{
			float num = (float)Math.Sqrt(v.x * v.x + v.z * v.z);
			v.x /= num;
			v.z /= num;
			v.y = 0f;
			return num;
		}

		public static void Normalize(ref Vector3 v)
		{
			float num = v.Length();
			if (num <= 1E-05f)
			{
				v.x = 0f;
				v.y = 0f;
				v.z = 0f;
			}
			else
			{
				v.x /= num;
				v.y /= num;
				v.z /= num;
			}
		}

		public static float Angle(ref Vector3 a, ref Vector3 b)
		{
			float num = a.x * b.x + a.y * b.y + a.z * b.z;
			if (num < -1f)
			{
				num = -1f;
			}
			else if (num > 1f)
			{
				num = 1f;
			}
			return (float)Math.Acos(num) * 57.29578f;
		}

		public static float Length(this Vector3 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
		}

		public static float Length(ref Vector3 v)
		{
			return (float)Math.Sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
		}

		public static float LengthSquared(this Vector3 v)
		{
			return v.x * v.x + v.y * v.y + v.z * v.z;
		}

		public static float LengthSquared(ref Vector3 v)
		{
			return v.x * v.x + v.y * v.y + v.z * v.z;
		}

		public static float Distance(ref Vector3 left, ref Vector3 right)
		{
			float num = left.x - right.x;
			float num2 = left.y - right.y;
			float num3 = left.z - right.z;
			return (float)Math.Sqrt(num * num + num2 * num2 + num3 * num3);
		}

		public static float DistanceSquared(ref Vector3 left, ref Vector3 right)
		{
			float num = left.x - right.x;
			float num2 = left.y - right.y;
			float num3 = left.z - right.z;
			return num * num + num2 * num2 + num3 * num3;
		}

		public static float DotProduct(ref Vector3 lhs, ref Vector3 rhs)
		{
			return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
		}

		public static Vector3 CrossProduct(ref Vector3 lhs, ref Vector3 rhs)
		{
			return new Vector3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z, lhs.x * rhs.y - lhs.y * rhs.x);
		}

		public static void CrossProduct(ref Vector3 lhs, ref Vector3 rhs, out Vector3 result)
		{
			result.x = lhs.y * rhs.z - lhs.z * rhs.y;
			result.y = lhs.z * rhs.x - lhs.x * rhs.z;
			result.z = lhs.x * rhs.y - lhs.y * rhs.x;
		}

		public static Vector3 Direction(ref Vector3 left, ref Vector3 right)
		{
			float num = left.x - right.x;
			float num2 = left.y - right.y;
			float num3 = left.z - right.z;
			float num4 = (float)Math.Sqrt(num * num + num2 * num2 + num3 * num3);
			return new Vector3(num / num4, num2 / num4, num3 / num4);
		}

		public static Vector3 Project(ref Vector3 vector, ref Vector3 onNormal)
		{
			float num = DotProduct(ref onNormal, ref onNormal);
			if (num < Mathf.Epsilon)
			{
				return new Vector3(0f, 0f, 0f);
			}
			float d = DotProduct(ref vector, ref onNormal);
			Vector3 a = Multiply(ref onNormal, d);
			Divide(ref a, num);
			return a;
		}

		public static void Project(ref Vector3 vector, ref Vector3 onNormal, out Vector3 result)
		{
			float num = DotProduct(ref onNormal, ref onNormal);
			if (num < Mathf.Epsilon)
			{
				result = Zero;
				return;
			}
			float d = DotProduct(ref vector, ref onNormal);
			Multiply(ref onNormal, d, out result);
			Divide(ref result, num, out result);
		}

		public static Vector3 Reflect(ref Vector3 inDirection, ref Vector3 inNormal)
		{
			float d = -2f * DotProduct(ref inNormal, ref inDirection);
			Vector3 a = Multiply(ref inNormal, d);
			return Add(ref a, ref inDirection);
		}

		public static Vector3 Lerp(ref Vector3 a, ref Vector3 b, float t)
		{
			t = Mathf.Clamp01(t);
			return new Vector3(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t);
		}

		public static void Lerp(ref Vector3 a, ref Vector3 b, float t, out Vector3 result)
		{
			t = Mathf.Clamp01(t);
			result.x = a.x + (b.x - a.x) * t;
			result.y = a.y + (b.y - a.y) * t;
			result.z = a.z + (b.z - a.z) * t;
		}
	}
	public class Message
	{
		public string Type;

		public Message()
		{
			Type = GetType().Name;
		}
	}
	public delegate bool MessageHandlerDelegate(Message message);
	public class MessagingSystem : SingletonMonoBehaviour<MessagingSystem>
	{
		private const int _MAX_QUEUE_PROCESSING_TIME = 16667;

		private Dictionary<string, List<MessageHandlerDelegate>> m_listenerDict = new Dictionary<string, List<MessageHandlerDelegate>>();

		private Queue<Message> m_messageQueue = new Queue<Message>();

		private Stopwatch m_timer = new Stopwatch();

		public bool AttachListener(Type type, MessageHandlerDelegate handler)
		{
			if (type == null)
			{
				UnityEngine.Debug.Log("MessagingSystem: AttachListener failed due to having no message type specified");
				return false;
			}
			string key = type.Name;
			if (!m_listenerDict.ContainsKey(key))
			{
				m_listenerDict.Add(key, new List<MessageHandlerDelegate>());
			}
			List<MessageHandlerDelegate> list = m_listenerDict[key];
			if (list.Contains(handler))
			{
				UnityEngine.Debug.Log("Listner is already in list");
				return false;
			}
			list.Add(handler);
			return true;
		}

		public bool DetachListener(Type type, MessageHandlerDelegate handler)
		{
			if (type == null)
			{
				UnityEngine.Debug.Log("MessagingSystem: DetachListener failed due to having no message type specified");
				return false;
			}
			string key = type.Name;
			if (!m_listenerDict.ContainsKey(type.Name))
			{
				return false;
			}
			List<MessageHandlerDelegate> list = m_listenerDict[key];
			if (!list.Contains(handler))
			{
				return false;
			}
			list.Remove(handler);
			return true;
		}

		public bool QueueMessage(Message msg)
		{
			if (!m_listenerDict.ContainsKey(msg.Type))
			{
				return false;
			}
			m_messageQueue.Enqueue(msg);
			return true;
		}

		public bool TriggetMessageJustNow(Message msg)
		{
			return TriggerMessage(msg);
		}

		private bool TriggerMessage(Message msg)
		{
			string type = msg.Type;
			if (!m_listenerDict.ContainsKey(type))
			{
				UnityEngine.Debug.Log("MessagingSystem: Message \"" + type + "\" has no listeners!");
				return false;
			}
			List<MessageHandlerDelegate> list = m_listenerDict[type];
			for (int i = 0; i < list.Count; i++)
			{
				if (!list[i](msg))
				{
					UnityEngine.Debug.LogWarning("処理失敗:" + msg.Type);
				}
			}
			return true;
		}

		private void Update()
		{
			m_timer.Start();
			while (m_messageQueue.Count > 0)
			{
				UpdateMessage();
			}
		}

		private void UpdateMessage()
		{
			if (m_timer.Elapsed.Milliseconds > 16667)
			{
				m_timer.Stop();
				return;
			}
			Message message = m_messageQueue.Dequeue();
			if (!TriggerMessage(message))
			{
				UnityEngine.Debug.LogWarning("Error when processing message: " + message.Type);
			}
		}
	}
	public class DummyGraphic : Graphic
	{
		public override void SetMaterialDirty()
		{
		}

		public override void SetVerticesDirty()
		{
		}

		protected override void OnPopulateMesh(VertexHelper vh)
		{
			vh.Clear();
		}
	}
	public static class ColorDefine
	{
		public static Color TransparentBlack = new Color(0f, 0f, 0f, 0f);

		public static Color TransparentWhite = new Color(1f, 1f, 1f, 0f);

		public static Color White = Rgb(255, 255, 255);

		public static Color Whitesmoke = Rgb(245, 245, 245);

		public static Color Gainsboro = Rgb(220, 220, 220);

		public static Color Lightgrey = Rgb(211, 211, 211);

		public static Color Silver = Rgb(192, 192, 192);

		public static Color Darkgray = Rgb(169, 169, 169);

		public static Color Gray = Rgb(128, 128, 128);

		public static Color Dimgray = Rgb(105, 105, 105);

		public static Color Black = Rgb(0, 0, 0);

		public static Color Red = Rgb(255, 0, 0);

		public static Color Orangered = Rgb(255, 69, 0);

		public static Color Tomato = Rgb(255, 99, 71);

		public static Color Coral = Rgb(255, 127, 80);

		public static Color Salmon = Rgb(250, 128, 114);

		public static Color Lightsalmon = Rgb(255, 160, 122);

		public static Color Darksalmon = Rgb(233, 150, 122);

		public static Color Peru = Rgb(205, 133, 63);

		public static Color Saddlebrown = Rgb(139, 69, 19);

		public static Color Sienna = Rgb(160, 82, 45);

		public static Color Chocolate = Rgb(210, 105, 30);

		public static Color Sandybrown = Rgb(244, 164, 96);

		public static Color Darkred = Rgb(139, 0, 0);

		public static Color Maroon = Rgb(128, 0, 0);

		public static Color Brown = Rgb(165, 42, 42);

		public static Color Firebrick = Rgb(178, 34, 34);

		public static Color Crimson = Rgb(188, 6, 12);

		public static Color Indianred = Rgb(205, 92, 92);

		public static Color Lightcoral = Rgb(240, 128, 128);

		public static Color Rosybrown = Rgb(188, 143, 143);

		public static Color Palevioletred = Rgb(219, 112, 147);

		public static Color Deeppink = Rgb(255, 20, 147);

		public static Color Hotpink = Rgb(255, 105, 180);

		public static Color Lightpink = Rgb(255, 182, 193);

		public static Color Pink = Rgb(255, 192, 203);

		public static Color Mistyrose = Rgb(255, 228, 225);

		public static Color Linen = Rgb(250, 240, 230);

		public static Color Seashell = Rgb(255, 245, 238);

		public static Color Lavenderblush = Rgb(255, 240, 245);

		public static Color Snow = Rgb(255, 250, 250);

		public static Color Yellow = Rgb(255, 255, 0);

		public static Color Gold = Rgb(255, 215, 0);

		public static Color Orange = Rgb(255, 165, 0);

		public static Color Darkorange = Rgb(255, 140, 0);

		public static Color Goldenrod = Rgb(218, 165, 32);

		public static Color Darkgoldenrod = Rgb(184, 134, 11);

		public static Color Darkkhaki = Rgb(189, 183, 107);

		public static Color Burlywood = Rgb(222, 184, 135);

		public static Color Tan = Rgb(210, 180, 140);

		public static Color Khaki = Rgb(240, 230, 140);

		public static Color Peachpuff = Rgb(255, 218, 185);

		public static Color Navajowhite = Rgb(255, 222, 173);

		public static Color Palegoldenrod = Rgb(238, 232, 170);

		public static Color Moccasin = Rgb(255, 228, 181);

		public static Color Wheat = Rgb(245, 222, 179);

		public static Color Bisque = Rgb(255, 228, 196);

		public static Color Blanchedalmond = Rgb(255, 235, 205);

		public static Color Papayawhip = Rgb(255, 239, 213);

		public static Color Cornsilk = Rgb(255, 248, 220);

		public static Color Lightyellow = Rgb(255, 255, 224);

		public static Color Lightgoldenrodyellow = Rgb(250, 250, 210);

		public static Color Lemonchiffon = Rgb(255, 250, 205);

		public static Color Antiquewhite = Rgb(250, 235, 215);

		public static Color Beige = Rgb(245, 245, 220);

		public static Color Oldlace = Rgb(253, 245, 230);

		public static Color Ivory = Rgb(255, 255, 240);

		public static Color Floralwhite = Rgb(255, 250, 240);

		public static Color Greenyellow = Rgb(173, 255, 47);

		public static Color Yellowgreen = Rgb(154, 205, 50);

		public static Color Olive = Rgb(128, 128, 0);

		public static Color Darkolivegreen = Rgb(85, 107, 47);

		public static Color Olivedrab = Rgb(107, 142, 35);

		public static Color Chartreuse = Rgb(127, 255, 0);

		public static Color Lawngreen = Rgb(124, 252, 0);

		public static Color Lime = Rgb(0, 255, 0);

		public static Color Limegreen = Rgb(50, 205, 50);

		public static Color Forestgreen = Rgb(34, 139, 34);

		public static Color Green = Rgb(0, 128, 0);

		public static Color Darkgreen = Rgb(0, 100, 0);

		public static Color Seagreen = Rgb(46, 139, 87);

		public static Color Mediumseagreen = Rgb(60, 179, 113);

		public static Color Darkseagreen = Rgb(143, 188, 143);

		public static Color Lightgreen = Rgb(144, 238, 144);

		public static Color Palegreen = Rgb(152, 251, 152);

		public static Color Springgreen = Rgb(0, 255, 127);

		public static Color Mediumspringgreen = Rgb(0, 250, 154);

		public static Color Honeydew = Rgb(240, 255, 240);

		public static Color Mintcream = Rgb(245, 255, 250);

		public static Color Azure = Rgb(240, 255, 255);

		public static Color Lightcyan = Rgb(224, 255, 255);

		public static Color Aliceblue = Rgb(240, 248, 255);

		public static Color Darkslategray = Rgb(47, 79, 79);

		public static Color Darkslatenavy = Rgb(47, 47, 79);

		public static Color Darkslatered = Rgb(147, 47, 47);

		public static Color Steelblue = Rgb(70, 130, 180);

		public static Color Mediumaquamarine = Rgb(102, 205, 170);

		public static Color Aquamarine = Rgb(127, 255, 212);

		public static Color Mediumturquoise = Rgb(72, 209, 204);

		public static Color Turquoise = Rgb(64, 224, 208);

		public static Color Lightseagreen = Rgb(32, 178, 170);

		public static Color Darkcyan = Rgb(0, 139, 139);

		public static Color Teal = Rgb(0, 128, 128);

		public static Color Cadetblue = Rgb(95, 158, 160);

		public static Color Darkturquoise = Rgb(0, 206, 209);

		public static Color Aqua = Rgb(0, 255, 255);

		public static Color Cyan = Rgb(0, 255, 255);

		public static Color Lightblue = Rgb(173, 216, 230);

		public static Color Powderblue = Rgb(176, 224, 230);

		public static Color Paleturquoise = Rgb(175, 238, 238);

		public static Color Skyblue = Rgb(135, 206, 235);

		public static Color Lightskyblue = Rgb(135, 206, 250);

		public static Color Deepskyblue = Rgb(0, 191, 255);

		public static Color Dodgerblue = Rgb(30, 144, 255);

		public static Color Ghostwhite = Rgb(248, 248, 255);

		public static Color Lavender = Rgb(230, 230, 250);

		public static Color Lightsteelblue = Rgb(176, 196, 222);

		public static Color Slategray = Rgb(112, 128, 144);

		public static Color Lightslategray = Rgb(119, 136, 153);

		public static Color Indigo = Rgb(75, 0, 130);

		public static Color Darkslateblue = Rgb(72, 61, 139);

		public static Color Midnightblue = Rgb(25, 25, 112);

		public static Color Navy = Rgb(0, 0, 128);

		public static Color Darkblue = Rgb(0, 0, 139);

		public static Color Slateblue = Rgb(106, 90, 205);

		public static Color Mediumslateblue = Rgb(123, 104, 238);

		public static Color Cornflowerblue = Rgb(100, 149, 237);

		public static Color Royalblue = Rgb(65, 105, 225);

		public static Color Mediumblue = Rgb(0, 0, 205);

		public static Color Blue = Rgb(0, 0, 255);

		public static Color Thistle = Rgb(216, 191, 216);

		public static Color Plum = Rgb(221, 160, 221);

		public static Color Orchid = Rgb(218, 112, 214);

		public static Color Violet = Rgb(238, 130, 238);

		public static Color Fuchsia = Rgb(255, 0, 255);

		public static Color Magenta = Rgb(255, 0, 255);

		public static Color Mediumpurple = Rgb(147, 112, 219);

		public static Color Mediumorchid = Rgb(186, 85, 211);

		public static Color Darkorchid = Rgb(153, 50, 204);

		public static Color Blueviolet = Rgb(138, 43, 226);

		public static Color Darkviolet = Rgb(148, 0, 211);

		public static Color Purple = Rgb(128, 0, 128);

		public static Color Darkmagenta = Rgb(139, 0, 139);

		public static Color Mediumvioletred = Rgb(199, 21, 133);

		public static Color Midnightblack = Rgb(50, 50, 50);

		public static Color Midnightgray = Rgb(75, 75, 75);

		public static Color OutlineDay = Rgb(51, 51, 51);

		public static Color OutlineNight = Rgb(10, 10, 10);

		public static Color Rgb(int red, int green, int blue)
		{
			return new Color((float)red / 255f, (float)green / 255f, (float)blue / 255f);
		}
	}
	public class DontDestroyOnLoad : MonoBehaviour
	{
		private void Awake()
		{
		}
	}
	public static class Easing
	{
		public static float Linear(float start, float end, float value)
		{
			return Mathf.Lerp(start, end, value);
		}

		public static Vector2 Linear(Vector2 start, Vector2 end, float value)
		{
			return Vector2.Lerp(start, end, value);
		}

		public static Vector3 Linear(Vector3 start, Vector3 end, float value)
		{
			return Vector3.Lerp(start, end, value);
		}

		public static Vector4 Linear(Vector4 start, Vector4 end, float value)
		{
			return Vector4.Lerp(start, end, value);
		}

		public static Quaternion Linear(Quaternion start, Quaternion end, float value)
		{
			return Quaternion.Lerp(start, end, value);
		}

		public static float Clerp(float start, float end, float value)
		{
			float num = 0f;
			float num2 = 360f;
			float num3 = Mathf.Abs((num2 - num) * 0.5f);
			float num4 = 0f;
			float num5 = 0f;
			if (end - start < 0f - num3)
			{
				num5 = (num2 - start + end) * value;
				return start + num5;
			}
			if (end - start > num3)
			{
				num5 = (0f - (num2 - end + start)) * value;
				return start + num5;
			}
			return start + (end - start) * value;
		}

		public static float Spring(float start, float end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Vector2 Spring(Vector2 start, Vector2 end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Vector3 Spring(Vector3 start, Vector3 end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Vector4 Spring(Vector4 start, Vector4 end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		public static Color Spring(Color start, Color end, float value)
		{
			value = GetSpringValue(value);
			return start + (end - start) * value;
		}

		private static float GetSpringValue(float value)
		{
			value = Mathf.Clamp01(value);
			return (Mathf.Sin(value * (float)Math.PI * (0.2f + 2.5f * value * value * value)) * Mathf.Pow(1f - value, 2.2f) + value) * (1f + 1.2f * (1f - value));
		}

		public static float EaseInQuad(float start, float end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Vector2 EaseInQuad(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Vector3 EaseInQuad(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Vector4 EaseInQuad(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static Color EaseInQuad(Color start, Color end, float value)
		{
			end -= start;
			return end * value * value + start;
		}

		public static float EaseOutQuad(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * value * (value - 2f) + start;
		}

		public static Vector2 EaseOutQuad(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return -end * value * (value - 2f) + start;
		}

		public static Vector3 EaseOutQuad(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return -end * value * (value - 2f) + start;
		}

		public static Vector4 EaseOutQuad(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return -end * value * (value - 2f) + start;
		}

		public static Color EaseOutQuad(Color start, Color end, float value)
		{
			end -= start;
			return end * -1f * value * (value - 2f) + start;
		}

		public static float EaseInOutQuad(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value + start;
			}
			value -= 1f;
			return (0f - end) * 0.5f * (value * (value - 2f) - 1f) + start;
		}

		public static float EaseInCubic(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value + start;
		}

		public static float EaseOutCubic(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value + 1f) + start;
		}

		public static float EaseInOutCubic(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value + start;
			}
			value -= 2f;
			return end * 0.5f * (value * value * value + 2f) + start;
		}

		public static float EaseInQuart(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value + start;
		}

		public static float EaseOutQuart(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return (0f - end) * (value * value * value * value - 1f) + start;
		}

		public static float EaseInOutQuart(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value * value + start;
			}
			value -= 2f;
			return (0f - end) * 0.5f * (value * value * value * value - 2f) + start;
		}

		public static float EaseInQuint(float start, float end, float value)
		{
			end -= start;
			return end * value * value * value * value * value + start;
		}

		public static float EaseOutQuint(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * (value * value * value * value * value + 1f) + start;
		}

		public static float EaseInOutQuint(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * value * value * value * value * value + start;
			}
			value -= 2f;
			return end * 0.5f * (value * value * value * value * value + 2f) + start;
		}

		public static float EaseInSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Vector2 EaseInSine(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return -end * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Vector3 EaseInSine(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return -end * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Vector4 EaseInSine(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return -end * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static Color EaseInSine(Color start, Color end, float value)
		{
			end -= start;
			return end * -1f * Mathf.Cos(value * ((float)Math.PI / 2f)) + end + start;
		}

		public static float EaseOutSine(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Vector2 EaseOutSine(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Vector3 EaseOutSine(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Vector4 EaseOutSine(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static Color EaseOutSine(Color start, Color end, float value)
		{
			end -= start;
			return end * Mathf.Sin(value * ((float)Math.PI / 2f)) + start;
		}

		public static float EaseInOutSine(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Vector2 EaseInOutSine(Vector2 start, Vector2 end, float value)
		{
			end -= start;
			return -end * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Vector3 EaseInOutSine(Vector3 start, Vector3 end, float value)
		{
			end -= start;
			return -end * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Vector4 EaseInOutSine(Vector4 start, Vector4 end, float value)
		{
			end -= start;
			return -end * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static Color EaseInOutSine(Color start, Color end, float value)
		{
			end -= start;
			return end * -1f * 0.5f * (Mathf.Cos((float)Math.PI * value) - 1f) + start;
		}

		public static float EaseInExpo(float start, float end, float value)
		{
			end -= start;
			return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}

		public static float EaseOutExpo(float start, float end, float value)
		{
			end -= start;
			return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
		}

		public static float EaseInOutExpo(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
			}
			value -= 1f;
			return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
		}

		public static float EaseInCirc(float start, float end, float value)
		{
			end -= start;
			return (0f - end) * (Mathf.Sqrt(1f - value * value) - 1f) + start;
		}

		public static float EaseOutCirc(float start, float end, float value)
		{
			value -= 1f;
			end -= start;
			return end * Mathf.Sqrt(1f - value * value) + start;
		}

		public static float EaseInOutCirc(float start, float end, float value)
		{
			value /= 0.5f;
			end -= start;
			if (value < 1f)
			{
				return (0f - end) * 0.5f * (Mathf.Sqrt(1f - value * value) - 1f) + start;
			}
			value -= 2f;
			return end * 0.5f * (Mathf.Sqrt(1f - value * value) + 1f) + start;
		}

		public static float EaseInBounce(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			return end - EaseOutBounce(0f, end, num - value) + start;
		}

		public static float EaseOutBounce(float start, float end, float value)
		{
			value /= 1f;
			end -= start;
			if (value < 0.36363637f)
			{
				return end * (7.5625f * value * value) + start;
			}
			if (value < 0.72727275f)
			{
				value -= 0.54545456f;
				return end * (7.5625f * value * value + 0.75f) + start;
			}
			if ((double)value < 0.9090909090909091)
			{
				value -= 0.8181818f;
				return end * (7.5625f * value * value + 0.9375f) + start;
			}
			value -= 21f / 22f;
			return end * (7.5625f * value * value + 63f / 64f) + start;
		}

		public static float EaseInOutBounce(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			if (value < num * 0.5f)
			{
				return EaseInBounce(0f, end, value * 2f) * 0.5f + start;
			}
			return EaseOutBounce(0f, end, value * 2f - num) * 0.5f + end * 0.5f + start;
		}

		public static float EaseInBack(float start, float end, float value)
		{
			end -= start;
			value /= 1f;
			float num = 1.70158f;
			return end * value * value * ((num + 1f) * value - num) + start;
		}

		public static float EaseOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value -= 1f;
			return end * (value * value * ((num + 1f) * value + num) + 1f) + start;
		}

		public static float EaseInOutBack(float start, float end, float value)
		{
			float num = 1.70158f;
			end -= start;
			value /= 0.5f;
			if (value < 1f)
			{
				num *= 1.525f;
				return end * 0.5f * (value * value * ((num + 1f) * value - num)) + start;
			}
			value -= 2f;
			num *= 1.525f;
			return end * 0.5f * (value * value * ((num + 1f) * value + num) + 2f) + start;
		}

		public static float Punch(float amplitude, float value)
		{
			float num = 9f;
			if (value == 0f)
			{
				return 0f;
			}
			if (value == 1f)
			{
				return 0f;
			}
			float num2 = 0.3f;
			num = num2 / ((float)Math.PI * 2f) * Mathf.Asin(0f);
			return amplitude * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * 1f - num) * ((float)Math.PI * 2f) / num2);
		}

		public static float EaseInElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num) == 1f)
			{
				return start + end;
			}
			if (num4 == 0f || num4 < Mathf.Abs(end))
			{
				num4 = end;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
			}
			return 0f - num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + start;
		}

		public static float EaseOutElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num) == 1f)
			{
				return start + end;
			}
			if (num4 == 0f || num4 < Mathf.Abs(end))
			{
				num4 = end;
				num3 = num2 * 0.25f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
			}
			return num4 * Mathf.Pow(2f, -10f * value) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) + end + start;
		}

		public static float EaseInOutElastic(float start, float end, float value)
		{
			end -= start;
			float num = 1f;
			float num2 = num * 0.3f;
			float num3 = 0f;
			float num4 = 0f;
			if (value == 0f)
			{
				return start;
			}
			if ((value /= num * 0.5f) == 2f)
			{
				return start + end;
			}
			if (num4 == 0f || num4 < Mathf.Abs(end))
			{
				num4 = end;
				num3 = num2 / 4f;
			}
			else
			{
				num3 = num2 / ((float)Math.PI * 2f) * Mathf.Asin(end / num4);
			}
			if (value < 1f)
			{
				return -0.5f * (num4 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2)) + start;
			}
			return num4 * Mathf.Pow(2f, -10f * (value -= 1f)) * Mathf.Sin((value * num - num3) * ((float)Math.PI * 2f) / num2) * 0.5f + end + start;
		}
	}
	public class FPSCounter3DText : MonoBehaviour
	{
		protected const float m_fpsMeasurePeriod = 0.5f;

		[SerializeField]
		private TextMesh m_text;

		[SerializeField]
		private int m_errorFps = 55;

		[SerializeField]
		protected Color m_errorColour = Color.red;

		[SerializeField]
		protected int m_errorFontSize = 50;

		[SerializeField]
		private Vector3 m_errorPosition = Vector3.zero;

		[SerializeField]
		protected string m_displayText = "{0}";

		[SerializeField]
		protected bool m_isShowErrorText;

		private int m_fpsAccumulator;

		private float m_fpsNextPeriod;

		private int m_currentFps;

		private Transform m_transform;

		private Vector3 m_startPos;

		protected int m_startFontSize;

		protected Color m_startColour;

		private bool m_isError;

		private bool IsUpdateFps => Time.realtimeSinceStartup > m_fpsNextPeriod;

		private bool IsErrorFps => m_currentFps <= m_errorFps;

		private bool IsSlowFps => UnityEngine.Application.targetFrameRate < 60;

		private void Start()
		{
			m_isError = false;
			m_transform = base.transform;
			m_startPos = m_transform.localPosition;
			m_fpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
			if (m_text == null)
			{
				m_text = GetComponent<TextMesh>();
			}
			Setup();
		}

		protected virtual void Setup()
		{
		}

		private void Update()
		{
			m_fpsAccumulator++;
			if (IsUpdateFps)
			{
				UpdateFps();
				UpdateFpsChange();
			}
		}

		private void UpdateFps()
		{
			m_currentFps = (int)((float)m_fpsAccumulator / 0.5f);
			m_fpsAccumulator = 0;
			m_fpsNextPeriod += 0.5f;
			SetFPSText(string.Format(m_displayText, m_currentFps));
			m_text.text = string.Format(m_displayText, m_currentFps);
		}

		protected virtual void SetFPSText(string text)
		{
		}

		private void UpdateFpsChange()
		{
			if (m_isShowErrorText && m_isError)
			{
				UpdateError();
			}
			else
			{
				UpdateNormal();
			}
		}

		private void UpdateError()
		{
			if (IsSlowFps)
			{
				ResetNormal();
			}
			else if (m_currentFps >= m_errorFps)
			{
				ResetNormal();
			}
		}

		protected virtual void ResetNormal()
		{
			m_transform.localPosition = m_startPos;
			m_text.color = Color.white;
			m_text.fontSize = m_startFontSize;
			m_isError = false;
		}

		private void UpdateNormal()
		{
			if (!IsSlowFps && IsErrorFps)
			{
				ChangeToError();
			}
		}

		protected virtual void ChangeToError()
		{
			m_transform.localPosition = m_errorPosition;
			m_isError = true;
			m_text.color = m_errorColour;
			m_text.fontSize = m_errorFontSize;
		}
	}
	[RequireComponent(typeof(TextMeshProUGUI))]
	public class FPSCounterTMPro : MonoBehaviour
	{
		protected const float m_fpsMeasurePeriod = 0.5f;

		[SerializeField]
		[NotEditable]
		private TextMeshProUGUI m_text;

		[SerializeField]
		protected Color m_normalColour = Color.white;

		[SerializeField]
		private int m_warnFps = 59;

		[SerializeField]
		protected Color m_warnColour = Color.yellow;

		[SerializeField]
		private int m_errorFps = 50;

		[SerializeField]
		protected Color m_errorColour = Color.red;

		[SerializeField]
		protected string m_displayText = "{0}";

		private int m_fpsAccumulator;

		private float m_fpsNextPeriod;

		private int m_currentFps;

		protected int m_startFontSize;

		protected Color m_startColour;

		public bool IsVisible { get; set; }

		private bool IsUpdateFps => Time.realtimeSinceStartup > m_fpsNextPeriod;

		private bool IsErrorFps => m_currentFps <= m_errorFps;

		private bool IsSlowFps => UnityEngine.Application.targetFrameRate < 60;

		private void OnValidate()
		{
			if (m_text == null)
			{
				m_text = GetComponent<TextMeshProUGUI>();
			}
		}

		private void Start()
		{
			m_fpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
		}

		private void Update()
		{
			m_fpsAccumulator++;
			if (IsUpdateFps)
			{
				UpdateFps();
				UpdateFpsChange();
			}
		}

		private void UpdateFps()
		{
			m_currentFps = (int)((float)m_fpsAccumulator / 0.5f);
			m_fpsAccumulator = 0;
			m_fpsNextPeriod += 0.5f;
			m_text.text = StringUtility.Format(m_displayText, m_currentFps);
		}

		private void UpdateFpsChange()
		{
			if (m_currentFps <= m_errorFps)
			{
				m_text.color = m_errorColour;
			}
			else if (m_currentFps <= m_warnFps)
			{
				m_text.color = m_warnColour;
			}
			else
			{
				m_text.color = m_normalColour;
			}
		}

		public void ToggleVisible(bool flag)
		{
			IsVisible = flag;
			m_text.enabled = flag;
		}
	}
	[RequireComponent(typeof(Text))]
	public class FPSCounterUgui : MonoBehaviour
	{
		protected const float m_fpsMeasurePeriod = 0.5f;

		[SerializeField]
		private Text m_text;

		[SerializeField]
		private int m_errorFps = 55;

		[SerializeField]
		protected Color m_errorColour = Color.red;

		[SerializeField]
		protected int m_errorFontSize = 50;

		[SerializeField]
		protected string m_displayText = "{0}";

		[SerializeField]
		protected bool m_isShowErrorText;

		private int m_fpsAccumulator;

		private float m_fpsNextPeriod;

		private int m_currentFps;

		protected int m_startFontSize;

		protected Color m_startColour;

		private bool m_isError;

		public bool IsVisible { get; set; }

		private bool IsUpdateFps => Time.realtimeSinceStartup > m_fpsNextPeriod;

		private bool IsErrorFps => m_currentFps <= m_errorFps;

		private bool IsSlowFps => UnityEngine.Application.targetFrameRate < 60;

		private void Start()
		{
			m_isError = false;
			m_fpsNextPeriod = Time.realtimeSinceStartup + 0.5f;
			if (m_text == null)
			{
				m_text = GetComponent<Text>();
			}
			Setup();
		}

		protected virtual void Setup()
		{
		}

		private void Update()
		{
			m_fpsAccumulator++;
			if (IsUpdateFps)
			{
				UpdateFps();
				UpdateFpsChange();
			}
		}

		private void UpdateFps()
		{
			m_currentFps = (int)((float)m_fpsAccumulator / 0.5f);
			m_fpsAccumulator = 0;
			m_fpsNextPeriod += 0.5f;
			m_text.text = StringUtility.Format(m_displayText, m_currentFps);
		}

		protected virtual void SetFPSText(string text)
		{
		}

		private void UpdateFpsChange()
		{
			if (m_isShowErrorText && m_isError)
			{
				UpdateError();
			}
			else
			{
				UpdateNormal();
			}
		}

		private void UpdateError()
		{
			if (IsSlowFps)
			{
				ResetNormal();
			}
			else if (m_currentFps >= m_errorFps)
			{
				ResetNormal();
			}
		}

		protected virtual void ResetNormal()
		{
			m_text.color = Color.white;
			m_text.fontSize = m_startFontSize;
			m_isError = false;
		}

		private void UpdateNormal()
		{
			if (!IsSlowFps && IsErrorFps)
			{
				ChangeToError();
			}
		}

		protected virtual void ChangeToError()
		{
			m_isError = true;
			m_text.color = m_errorColour;
			m_text.fontSize = m_errorFontSize;
		}

		public void ToggleVisible(bool flag)
		{
			IsVisible = flag;
			m_text.enabled = flag;
		}
	}
	public class GameLogic : SingletonMonoBehaviour<GameLogic>
	{
		private IObservable<Unit> _obUpdate;

		public IObservable<Unit> UpdateObservable => _obUpdate;

		protected override void InitializeOnAwake()
		{
			_obUpdate = this.UpdateAsObservable();
		}

		public void RegisterUpdateableObject(IUpdateable obj)
		{
			_obUpdate.Where((Unit _) => obj.IsActive).Subscribe(delegate
			{
				obj.OnUpdate(Time.deltaTime);
			}).AddTo(obj.MyComponent);
		}

		public void DeregisterUpdateableObject(IUpdateable obj)
		{
		}
	}
	public abstract class IFader : MonoBehaviour
	{
		public const float DEFAULT_FADE_DURATION = 0.65f;

		[SerializeField]
		protected float m_fadeDuration = 0.65f;

		[SerializeField]
		protected bool m_isFadeOnStart = true;

		[SerializeField]
		protected Color m_startColour = Color.black;

		[SerializeField]
		protected Color m_targetColour = ColorDefine.TransparentBlack;

		[SerializeField]
		protected UnityEvent m_onStartFadeEnd;

		[SerializeField]
		protected UnityEvent m_onStartFadeEvents;

		[SerializeField]
		protected int m_waitFrameOnStart;

		[SerializeField]
		protected bool m_isDeactivateOnEnd;

		protected Tweener<Color> m_colourTweener = new Tweener<Color>(Color.Lerp);

		protected int m_frameCount;

		protected GameObject m_gameObject;

		protected Transform m_transform;

		public bool IsFading => m_colourTweener.IsActive;

		public float RemainingTime => m_colourTweener.RemainingTime;

		public virtual bool IsFadeVisible => false;

		public virtual Color CurrentColour => m_colourTweener.CurrentValue;

		private void Awake()
		{
			m_gameObject = base.gameObject;
			m_transform = base.transform;
			Initialize();
		}

		protected void Initialize()
		{
			OnInitialize();
		}

		private void OnDisable()
		{
			m_isFadeOnStart = false;
		}

		protected abstract void OnInitialize();

		public void StartFade(Color end)
		{
			StartFade(CurrentColour, end, m_fadeDuration, isDeactivateOnEnd: false);
		}

		public void StartFade(Color start, Color end)
		{
			StartFade(start, end, m_fadeDuration, isDeactivateOnEnd: false);
		}

		public void StartFade(Color end, Action onTweenEndMethod)
		{
			StartFade(CurrentColour, end, m_fadeDuration, isDeactivateOnEnd: false, onTweenEndMethod);
		}

		public void StartFade(Color start, Color end, Action onTweenEndMethod)
		{
			StartFade(start, end, m_fadeDuration, isDeactivateOnEnd: false, onTweenEndMethod);
		}

		public void StartFade(Color end, float duration, bool isDeactivateOnEnd, Action onTweenEndMethod = null)
		{
			StartFade(CurrentColour, end, duration, isDeactivateOnEnd, onTweenEndMethod);
		}

		public void StartFade(Color start, Color end, float duration, bool isDeactivateOnEnd, Action onTweenEndMethod = null)
		{
			if (start.a <= 0f)
			{
				start = end.WithAlpha(0f);
			}
			else if (end.a <= 0f)
			{
				end = start.WithAlpha(0f);
			}
			m_startColour = start;
			m_targetColour = end;
			m_isFadeOnStart = false;
			m_isDeactivateOnEnd = isDeactivateOnEnd;
			m_colourTweener.Start(start, end, duration, onTweenEndMethod);
			UpdateColour();
			OnFade();
			if (duration <= 0f)
			{
				OnFadeEnd();
			}
		}

		public void StartReverseFade(Action onTweenEndMethod = null, bool isActivateGameObject = true, bool isDeactivateOnEnd = false)
		{
			m_isDeactivateOnEnd = isDeactivateOnEnd;
			m_gameObject.SetActive(isActivateGameObject);
			m_colourTweener.StartReverse(onTweenEndMethod);
			UpdateColour();
			OnFade();
			if (!m_colourTweener.IsActive)
			{
				OnFadeEnd();
			}
		}

		public void StartReverseFade(float duration, bool isDeactivateOnEnd, Action onTweenEndMethod = null)
		{
			m_isDeactivateOnEnd = isDeactivateOnEnd;
			m_colourTweener.Duration = duration;
			m_colourTweener.StartReverse(onTweenEndMethod);
			UpdateColour();
			OnFade();
			if (!m_colourTweener.IsActive)
			{
				OnFadeEnd();
			}
		}

		protected virtual void OnFade()
		{
		}

		private void Update()
		{
			if (m_isFadeOnStart)
			{
				if (m_waitFrameOnStart > m_frameCount)
				{
					m_frameCount++;
					return;
				}
				m_isFadeOnStart = false;
				StartFade(m_startColour, m_targetColour, m_fadeDuration, isDeactivateOnEnd: true, OnStartFadeEnd);
				if (m_onStartFadeEvents != null)
				{
					m_onStartFadeEvents.Invoke();
				}
			}
			else if (m_colourTweener.IsActive)
			{
				m_colourTweener.Update(Time.deltaTime);
				UpdateColour();
				if (!m_colourTweener.IsActive)
				{
					OnFadeEnd();
				}
			}
		}

		protected virtual void OnFadeEnd()
		{
			if (m_isDeactivateOnEnd)
			{
				m_gameObject.SetActive(value: false);
			}
		}

		protected virtual void UpdateColour()
		{
		}

		protected virtual void OnStartFadeEnd()
		{
			if (m_onStartFadeEnd != null)
			{
				m_onStartFadeEnd.Invoke();
			}
			m_isFadeOnStart = false;
		}

		public virtual void SetColour(Color colour)
		{
		}

		public void SkipToEnd()
		{
			Initialize();
			m_colourTweener.Start(m_startColour, m_targetColour, 0.65f);
			m_colourTweener.Update(m_colourTweener.Duration);
			UpdateColour();
			if (m_isFadeOnStart)
			{
				OnStartFadeEnd();
			}
		}

		public void Dispose()
		{
			m_colourTweener.Dispose();
			m_isFadeOnStart = false;
		}

		public virtual void SetActive(bool isActive)
		{
			m_gameObject.SetActive(isActive);
		}
	}
	public interface IUpdateable
	{
		int Priority { get; set; }

		bool IsActive { get; set; }

		Component MyComponent { get; }

		void OnUpdate(float delta);
	}
	internal class ListPosition
	{
		protected int m_count;

		protected int m_height;

		protected int m_top;

		protected int m_end;

		public int Index { get; protected set; }

		public int Count
		{
			get
			{
				return m_count;
			}
			set
			{
				m_count = Math.Max(0, value);
				Select(Index, isLoop: false);
			}
		}

		public int Height
		{
			get
			{
				if (m_height <= 0)
				{
					return m_count;
				}
				return m_height;
			}
			set
			{
				m_height = Math.Max(0, value);
				Reform();
			}
		}

		public int Offset => Math.Max(0, Index - m_top);

		public int Top => m_top;

		public ListPosition()
		{
			m_count = 0;
			m_height = 0;
			Index = 0;
			m_top = 0;
			m_end = 0;
		}

		private void Reform()
		{
			int height = Height;
			if (Index < m_top)
			{
				m_top = Math.Max(0, Index);
			}
			m_end = Math.Min(m_top + height, m_count);
			if (Index + 1 >= m_end)
			{
				m_end = Index + 1;
				if (m_end > m_count)
				{
					m_end = m_count;
				}
			}
			m_top = Math.Max(0, m_end - height);
		}

		public void Select(int index, bool isLoop = true)
		{
			if (m_count > 0)
			{
				if (isLoop)
				{
					Index = (Clamp(index, -1, m_count) + m_count) % m_count;
				}
				else
				{
					Index = Clamp(index, 0, m_count - 1);
				}
				Reform();
			}
			else
			{
				Index = 0;
				m_top = 0;
				m_end = 0;
			}
		}

		private int Clamp(int value, int min, int max)
		{
			value = ((value > max) ? max : value);
			value = ((value < min) ? min : value);
			return value;
		}

		public void Next(int steps = 1, bool isLoop = true)
		{
			Select(Index + steps, isLoop && Index >= m_count - 1);
		}

		public void Back(int steps = 1, bool isLoop = true)
		{
			Select(Index - steps, isLoop && Index == 0);
		}

		public void Scroll(int step)
		{
			if (m_count > 0)
			{
				Index = Clamp(Index + step, 0, m_count - 1);
				if (step < 0)
				{
					step = Math.Max(m_top + step, 0) - m_top;
				}
				else if (step > 0)
				{
					step = Math.Min(m_end + step, m_count) - m_end;
				}
				m_top = Clamp(m_top + step, Index, m_count);
				m_end = Clamp(m_end + step, m_top, m_count);
			}
		}

		public void GetRange(ref int start, ref int end)
		{
			start = m_top;
			end = m_end;
		}
	}
	public static class MathHelper
	{
		public const float PI = (float)Math.PI;

		public const float PI_OVER_2 = (float)Math.PI / 2f;

		public const float PI_OVER_4 = (float)Math.PI / 4f;

		public const float TWO_PI = (float)Math.PI * 2f;

		public const float RADIAN_TO_DEGREE = 57.29578f;

		public const float DEGREE_TO_RADIAN = (float)Math.PI / 180f;

		public static readonly Vector3 RIGHT = new Vector3(1f, 0f, 0f);

		public static float Abs(ref float a)
		{
			if (!(a < 0f))
			{
				return a;
			}
			return 0f - a;
		}

		public static float Clamp01(float a)
		{
			a = ((a > 1f) ? 1f : a);
			if (!(a < 0f))
			{
				return a;
			}
			return 0f;
		}

		public static void Clamp01(ref float a)
		{
			a = ((a > 1f) ? 1f : a);
			a = ((a < 0f) ? 0f : a);
		}

		public static bool GetRandomBool()
		{
			return UnityEngine.Random.Range(0, 2) > 0;
		}

		public static float GetRate(float current, float target)
		{
			return Mathf.Clamp(current / target, 0f, 1f);
		}

		public static float GetPercentage(float start, float target, float current)
		{
			return (current - start) / (target - start);
		}

		public static float Pow2(float x)
		{
			return Mathf.Pow(x, 2f);
		}

		public static int CountDigit(int num)
		{
			if (num != 0)
			{
				return (int)Mathf.Log10(num) + 1;
			}
			return 1;
		}

		public static float GetAngle(Vector3 from, Vector3 to)
		{
			float x = to.x - from.x;
			return Mathf.Atan2(to.z - from.z, x);
		}

		public static Vector2 ContactPoint(Vector2 from, float radius)
		{
			float x = radius * ((from.x * radius + from.y * Mathf.Sqrt(Pow2(from.x) + Pow2(from.y) - Pow2(radius))) / (Pow2(from.x) + Pow2(from.y)));
			float y = radius * ((from.y * radius - from.x * Mathf.Sqrt(Pow2(from.x) + Pow2(from.y) - Pow2(radius))) / (Pow2(from.x) + Pow2(from.y)));
			return new Vector2(x, y);
		}

		public static Vector2 ContactPointLeft(Vector2 from, float radius, Vector2 circleP)
		{
			Vector2 vector = from - circleP;
			float x = radius * ((vector.x * radius + vector.y * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.x;
			float y = radius * ((vector.y * radius - vector.x * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.y;
			return new Vector2(x, y);
		}

		public static Vector2 ContactPointRight(Vector2 from, float radius, Vector2 circleP)
		{
			Vector2 vector = from - circleP;
			float x = radius * ((vector.x * radius - vector.y * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.x;
			float y = radius * ((vector.y * radius + vector.x * Mathf.Sqrt(Pow2(vector.x) + Pow2(vector.y) - Pow2(radius))) / (Pow2(vector.x) + Pow2(vector.y))) + circleP.y;
			return new Vector2(x, y);
		}

		public static Vector3 ContactPointLeftXY(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 vector3 = ContactPointLeft(vector, radius, vector2);
			Vector3 position = new Vector3(vector3.x, vector3.y, vector.z);
			return local.TransformPoint(position);
		}

		public static Vector3 ContactPointRightXY(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 vector3 = ContactPointRight(vector, radius, vector2);
			Vector3 position = new Vector3(vector3.x, vector3.y, vector.z);
			return local.TransformPoint(position);
		}

		public static Vector3 ContactPointLeftYZ(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 from2 = new Vector2(vector.z, vector.y);
			Vector2 circleP2 = new Vector2(vector2.z, vector2.y);
			Vector2 vector3 = ContactPointLeft(from2, radius, circleP2);
			Vector3 position = new Vector3(vector.x, vector3.y, vector3.x);
			return local.TransformPoint(position);
		}

		public static Vector3 ContactPointRightYZ(Vector3 from, float radius, Vector3 circleP, Transform local)
		{
			Vector3 vector = local.InverseTransformPoint(from);
			Vector3 vector2 = local.InverseTransformPoint(circleP);
			Vector2 from2 = new Vector2(vector.z, vector.y);
			Vector2 circleP2 = new Vector2(vector2.z, vector2.y);
			Vector2 vector3 = ContactPointRight(from2, radius, circleP2);
			Vector3 position = new Vector3(vector.x, vector3.y, vector3.x);
			return local.TransformPoint(position);
		}
	}
	[Serializable]
	public struct Point : IEquatable<Point>
	{
		private static readonly Point zeroPoint;

		public int X;

		public int Y;

		public static Point Zero => zeroPoint;

		internal string DebugDisplayString => X + "  " + Y;

		public Point(int x, int y)
		{
			X = x;
			Y = y;
		}

		public Point(int value)
		{
			X = value;
			Y = value;
		}

		public static Point operator +(Point value1, Point value2)
		{
			return new Point(value1.X + value2.X, value1.Y + value2.Y);
		}

		public static Point operator -(Point value1, Point value2)
		{
			return new Point(value1.X - value2.X, value1.Y - value2.Y);
		}

		public static Point operator *(Point value1, Point value2)
		{
			return new Point(value1.X * value2.X, value1.Y * value2.Y);
		}

		public static Point operator /(Point source, Point divisor)
		{
			return new Point(source.X / divisor.X, source.Y / divisor.Y);
		}

		public static bool operator ==(Point a, Point b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(Point a, Point b)
		{
			return !a.Equals(b);
		}

		public override bool Equals(object obj)
		{
			if (obj is Point)
			{
				return Equals((Point)obj);
			}
			return false;
		}

		public bool Equals(Point other)
		{
			if (X == other.X)
			{
				return Y == other.Y;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return X ^ Y;
		}

		public override string ToString()
		{
			return "{X:" + X + " Y:" + Y + "}";
		}

		public Vector2 ToVector2()
		{
			return new Vector2(X, Y);
		}
	}
	public abstract class Singleton<T> where T : class, new()
	{
		private static T m_instance;

		public static T Instance
		{
			get
			{
				return m_instance ?? (m_instance = new T());
			}
			protected set
			{
				m_instance = value;
			}
		}

		protected Singleton()
		{
			m_instance = this as T;
		}

		public virtual void Shutdown()
		{
			m_instance = null;
		}
	}
	public class SingletonMonoBehaviour<T> : MonoBehaviour where T : MonoBehaviour
	{
		protected const bool IsSearchObjectOnNullInstance = true;

		protected static T m_instance;

		public static bool HasInstance => m_instance != null;

		public static T Instance
		{
			get
			{
				if (m_instance == null && UnityEngine.Object.FindObjectsOfType(typeof(T)) is T[] array)
				{
					int num = array.Length;
					if (num == 1)
					{
						m_instance = array[0];
						return m_instance;
					}
					if (num > 1)
					{
						for (int i = 0; i < num; i++)
						{
							UnityEngine.Object.Destroy(array[i].gameObject);
						}
					}
				}
				return m_instance;
			}
		}

		public virtual void Shutdown(bool isDestroyObject = true)
		{
			m_instance = null;
			if (isDestroyObject)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnApplicationQuit()
		{
			m_instance = null;
		}

		private void OnDestroy()
		{
			if (m_instance == this)
			{
				m_instance = null;
				ShutdownOnDestroy();
			}
		}

		private void Awake()
		{
			OnAwake();
		}

		private void OnAwake()
		{
			if (m_instance == null)
			{
				m_instance = this as T;
				InitializeOnAwake();
			}
			else
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		protected virtual void InitializeOnAwake()
		{
		}

		protected virtual void ShutdownOnDestroy()
		{
		}
	}
	public class SingletonUpdatableComponent<T> : UpdateableComponent where T : UpdateableComponent
	{
		protected const bool IsSearchObjectOnNullInstance = true;

		protected static T m_instance;

		public static bool HasInstance => m_instance != null;

		public static T Instance
		{
			get
			{
				if (m_instance == null)
				{
					return UnityEngine.Object.FindObjectOfType(typeof(T)) as T;
				}
				return m_instance;
			}
		}

		public virtual void Destroy(bool isDestroyObject = true)
		{
			m_instance = null;
			if (isDestroyObject)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}

		private void OnApplicationQuit()
		{
			m_instance = null;
		}

		protected override void OnShutdown()
		{
			if (m_instance == this)
			{
				m_instance = null;
			}
		}

		protected override void Initialize()
		{
			if (m_instance == null)
			{
				m_instance = this as T;
				InitializeOnStart();
			}
			else
			{
				Destroy(base.gameObject);
			}
		}

		protected virtual void InitializeOnStart()
		{
		}
	}
	public static class StringUtility
	{
		public static string Format<T1>(string format, T1 arg1)
		{
			return string.Format(format, arg1.ToString());
		}

		public static string Format<T1, T2>(string format, T1 arg1, T2 arg2)
		{
			return string.Format(format, arg1.ToString(), arg2.ToString());
		}

		public static string Format<T1, T2, T3>(string format, T1 arg1, T2 arg2, T3 arg3)
		{
			return string.Format(format, arg1.ToString(), arg2.ToString(), arg3.ToString());
		}

		public static string Format<T1, T2, T3, T4>(string format, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			return string.Format(format, arg1.ToString(), arg2.ToString(), arg3.ToString(), arg4.ToString());
		}
	}
	public class Timer
	{
		private float m_currentTime;

		private float m_duration;

		public bool IsTimeUp => m_currentTime >= m_duration;

		public float RemainingTime => Mathf.Max(0f, m_duration - m_currentTime);

		public float RemainingMin => RemainingTime / 60f;

		public float Duration => m_duration;

		public float CurrentTime => m_currentTime;

		public float Rate
		{
			get
			{
				return Mathf.Clamp(m_currentTime / m_duration, 0f, 1f);
			}
			set
			{
				m_currentTime = Mathf.Clamp(m_duration * value, 0f, 1f);
			}
		}

		public Timer(float duration)
		{
			m_currentTime = 0f;
			m_duration = duration;
		}

		public void SetDuration(float duration, bool isReset = true)
		{
			m_duration = duration;
			if (isReset)
			{
				m_currentTime = 0f;
			}
		}

		public void SetToTimeup()
		{
			m_currentTime = m_duration;
		}

		public void Reset()
		{
			m_currentTime = 0f;
		}

		public void AddRemainingTime(float amonuntToAdd)
		{
			m_duration += amonuntToAdd;
		}

		public void Update(float delta)
		{
			m_currentTime = Mathf.Clamp(m_currentTime + delta, 0f, m_duration);
		}
	}
	public class Tweener<T>
	{
		public delegate T TweenMethod<TLerp>(T start, T end, float amount);

		private TweenMethod<T> m_lerpFunction;

		private List<Action> m_onTweenEndActions;

		private T m_start;

		private T m_target;

		private Timer m_timer;

		public T CurrentValue { get; private set; }

		public bool IsActive { get; private set; }

		public T StartValue => m_start;

		public T TargetValue => m_target;

		public float Duration
		{
			get
			{
				return m_timer.Duration;
			}
			set
			{
				m_timer.SetDuration(Mathf.Clamp(value, 0f, float.MaxValue));
			}
		}

		public float RemainingTime => m_timer.RemainingTime;

		public Tweener(TweenMethod<T> tweenMethod)
		{
			m_onTweenEndActions = new List<Action>(10);
			m_lerpFunction = tweenMethod;
			CurrentValue = default(T);
			m_start = default(T);
			m_target = default(T);
			m_timer = new Timer(0f);
			IsActive = false;
		}

		public Tweener(TweenMethod<T> tweenMethod, T initialValue)
		{
			m_onTweenEndActions = new List<Action>(10);
			m_lerpFunction = tweenMethod;
			CurrentValue = initialValue;
			m_start = initialValue;
			m_target = initialValue;
			m_timer = new Timer(0f);
			IsActive = false;
		}

		public void Start(T start, T end, float duration, Action onTweenEndMethod = null)
		{
			m_start = start;
			m_target = end;
			m_timer.SetDuration(duration);
			CurrentValue = m_start;
			if (onTweenEndMethod != null)
			{
				m_onTweenEndActions.Add(onTweenEndMethod);
			}
			if (duration <= 0f)
			{
				IsActive = false;
				CurrentValue = m_target;
				PlayActions();
			}
			else
			{
				IsActive = true;
			}
		}

		public void StartReverse(Action onTweenEndMethod = null)
		{
			Start(m_target, m_start, m_timer.Duration, onTweenEndMethod);
		}

		public void Update(float delta)
		{
			if (IsActive)
			{
				m_timer.Update(delta);
				if (m_timer.IsTimeUp)
				{
					m_timer.SetToTimeup();
					CurrentValue = m_target;
					IsActive = false;
					PlayActions();
				}
				ProcessInterpolation(m_timer.Rate);
			}
		}

		private void ProcessInterpolation(float percentage)
		{
			CurrentValue = m_lerpFunction(m_start, m_target, percentage);
		}

		public void SetCurrentValue(T current)
		{
			CurrentValue = current;
		}

		public void SetCurrentRate(float rate)
		{
			m_timer.Rate = rate;
		}

		public void AddAction(Action toAdd)
		{
			if (toAdd != null)
			{
				m_onTweenEndActions.Add(toAdd);
			}
		}

		private void PlayActions()
		{
			int count = m_onTweenEndActions.Count;
			for (int i = 0; i < count; i++)
			{
				m_onTweenEndActions[i]();
			}
			m_onTweenEndActions.RemoveRange(0, count);
		}

		public void Dispose()
		{
			IsActive = false;
			m_onTweenEndActions.Clear();
		}
	}
	public class UIFader : IFader
	{
		[SerializeField]
		private Graphic m_graphic;

		public Color StartColour => m_startColour;

		public Color EndColour => m_targetColour;

		public override bool IsFadeVisible => m_graphic.enabled;

		protected override void OnInitialize()
		{
			if (m_graphic == null)
			{
				m_graphic = GetComponent<Graphic>();
			}
		}

		protected override void OnFade()
		{
			Initialize();
			m_graphic.enabled = true;
			if (m_colourTweener.IsActive)
			{
				m_graphic.color = m_colourTweener.StartValue;
			}
			else
			{
				m_graphic.color = m_colourTweener.TargetValue;
			}
		}

		protected override void OnFadeEnd()
		{
			if (m_isDeactivateOnEnd)
			{
				m_graphic.enabled = false;
			}
		}

		protected override void UpdateColour()
		{
			m_graphic.color = m_colourTweener.CurrentValue;
		}

		public override void SetColour(Color colour)
		{
			if (m_graphic == null)
			{
				m_graphic = GetComponent<Graphic>();
			}
			m_graphic.color = colour;
			m_graphic.enabled = colour.a > 0f;
		}

		public void ResetColour(Color start, Color end)
		{
			m_startColour = start;
			m_targetColour = end;
			SetColour(start);
		}

		public override void SetActive(bool isActive)
		{
			m_graphic.enabled = isActive;
		}
	}
	public class UpdateableComponent : MonoBehaviour, IUpdateable
	{
		protected bool m_isActive;

		protected GameObject m_thisGameObject;

		public int Priority { get; set; }

		public bool IsActive
		{
			get
			{
				if (m_isActive && base.enabled)
				{
					return m_thisGameObject.activeInHierarchy;
				}
				return false;
			}
			set
			{
				m_isActive = value;
			}
		}

		public Component MyComponent => this;

		public GameObject Object => m_thisGameObject;

		protected IObservable<Unit> UpdateObservable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		private void Start()
		{
			m_thisGameObject = base.gameObject;
			Priority = 0;
			IsActive = true;
			if (SingletonMonoBehaviour<GameLogic>.HasInstance)
			{
				SingletonMonoBehaviour<GameLogic>.Instance.RegisterUpdateableObject(this);
			}
			Initialize();
		}

		private void OnDestroy()
		{
			if (SingletonMonoBehaviour<GameLogic>.HasInstance)
			{
				SingletonMonoBehaviour<GameLogic>.Instance.DeregisterUpdateableObject(this);
			}
			OnShutdown();
		}

		public virtual void OnUpdate(float delta)
		{
		}

		protected virtual void Initialize()
		{
		}

		protected virtual void OnShutdown()
		{
		}
	}
	public class VRDebugInput : MonoBehaviour
	{
		[SerializeField]
		private KeyCode m_recenterKey = KeyCode.R;

		[SerializeField]
		private KeyCode m_showDebugKey = KeyCode.D;

		[SerializeField]
		private List<GameObject> m_debugDisplayObjects;

		private void Update()
		{
			if (Input.GetKeyDown(m_recenterKey))
			{
				InputTracking.Recenter();
			}
			if (Input.GetKeyDown(m_showDebugKey))
			{
				ToggleShowDebug();
			}
		}

		public void ToggleShowDebug()
		{
			int count = m_debugDisplayObjects.Count;
			for (int i = 0; i < count; i++)
			{
				m_debugDisplayObjects[i].SetActive(!m_debugDisplayObjects[i].activeSelf);
			}
		}
	}
	public static class VRDeviceTypes
	{
		public const string _NONE = "None";

		public const string _OCULUS = "Oculus";

		public const string _OPEN_VR = "OpenVR";

		public const string _CARDBOARD = "cardboard";

		public const string _DAYDREAM = "daydream";

		public static bool IsVRMode()
		{
			if (!XRSettings.enabled || !XRSettings.isDeviceActive)
			{
				return false;
			}
			return XRSettings.loadedDeviceName != "None";
		}
	}
	public class VRUIMovement : MonoBehaviour
	{
		[SerializeField]
		private bool m_LookatCamera = true;

		[SerializeField]
		private Transform m_UIElement;

		[SerializeField]
		private Transform m_Camera;

		[SerializeField]
		private bool m_RotateWithCamera = true;

		[SerializeField]
		private float m_FollowSpeed = 10f;

		[SerializeField]
		private bool m_isLockY;

		private float m_DistanceFromCamera;

		private void Start()
		{
			m_DistanceFromCamera = Vector3.Distance(m_UIElement.position, m_Camera.position);
		}

		private void Update()
		{
			if (m_LookatCamera)
			{
				m_UIElement.rotation = Quaternion.LookRotation(m_UIElement.position - m_Camera.position);
			}
			if (m_RotateWithCamera)
			{
				Vector3 vector = ((!m_isLockY) ? m_Camera.forward : Vector3.ProjectOnPlane(m_Camera.forward, Vector3.up).normalized);
				Vector3 b = m_Camera.position + vector * m_DistanceFromCamera;
				b = Vector3.Lerp(m_UIElement.position, b, m_FollowSpeed * Time.deltaTime);
				if (m_isLockY)
				{
					b.y = m_UIElement.position.y;
				}
				m_UIElement.position = b;
			}
		}
	}
}
namespace Notte
{
	public static class ActionExtensions
	{
		public static void Call(this Action action)
		{
			action?.Invoke();
		}

		public static void Call<T>(this Action<T> action, T arg)
		{
			action?.Invoke(arg);
		}

		public static void Call<T1, T2>(this Action<T1, T2> action, T1 arg1, T2 arg2)
		{
			action?.Invoke(arg1, arg2);
		}

		public static void Call<T1, T2, T3>(this Action<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3)
		{
			action?.Invoke(arg1, arg2, arg3);
		}
	}
}
namespace TkChronos
{
	public class KaineLoader
	{
		public class PartsData : SimpleSoundLoader.SoundData
		{
			public int PartsID;

			public int Layer;

			public int Frequency = 44100;

			public PartsData(int id, int partsID, int layer, AudioClip clip, bool isStoreFrequency = false)
				: base(id, clip)
			{
				Layer = layer;
				PartsID = partsID;
				if (isStoreFrequency)
				{
					Frequency = clip.frequency;
				}
			}
		}

		public class ClipData
		{
			public List<AudioClip> Clips;

			public int Frequency;

			public ClipData()
			{
				Clips = null;
				Frequency = 0;
			}
		}

		private const string _FILE_PATH = "Audio/BGM/{0:D2}/{1:D2}_{2}_{3:D2}";

		private const int _ID_INTRO = 0;

		private const int _ID_OUTRO = 1;

		private const int _ID_PARTS_START = 2;

		private const int _DEFAULT_LIST_SIZE = 5;

		private BgmData m_data;

		private List<AsyncOperation> m_introRequests;

		private List<AsyncOperation> m_partsRequests;

		private List<AsyncOperation> m_outroRequests;

		private List<PartsData> m_introData;

		private List<PartsData> m_outroData;

		private List<PartsData>[] m_partsData;

		private List<AudioClip> m_introList;

		private List<AudioClip> m_outroList;

		private List<PartsData> m_outputPartsList;

		private ClipData m_clipData;

		public int FirstBgmID { get; private set; }

		public bool IsLoading { get; private set; }

		public bool HasRequest
		{
			get
			{
				if (m_introRequests.Count <= 0 && m_partsRequests.Count <= 0)
				{
					return m_outroRequests.Count > 0;
				}
				return true;
			}
		}

		public KaineLoader(BgmData data, int layerCount)
		{
			IsLoading = false;
			m_data = data;
			FirstBgmID = -1;
			m_introRequests = new List<AsyncOperation>();
			m_partsRequests = new List<AsyncOperation>();
			m_outroRequests = new List<AsyncOperation>();
			m_introData = new List<PartsData>();
			m_outroData = new List<PartsData>();
			m_introList = new List<AudioClip>(5);
			m_outroList = new List<AudioClip>(5);
			m_outputPartsList = new List<PartsData>(20);
			m_clipData = new ClipData();
			m_partsData = new List<PartsData>[layerCount];
			for (int i = 0; i < layerCount; i++)
			{
				m_partsData[i] = new List<PartsData>();
			}
		}

		public void Clear()
		{
			IsLoading = false;
			FirstBgmID = -1;
			m_introList.Clear();
			m_outroList.Clear();
			m_outputPartsList.Clear();
			ClearSoundData(m_introData);
			ClearSoundData(m_outroData);
			int num = m_partsData.Length;
			for (int i = 0; i < num; i++)
			{
				ClearSoundData(m_partsData[i]);
			}
			ClearRequestData(m_introRequests);
			ClearRequestData(m_partsRequests);
			ClearRequestData(m_outroRequests);
			Resources.UnloadUnusedAssets();
		}

		private void ClearSoundData(List<PartsData> list)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(list[i].Clip);
				list[i].Clip = null;
			}
			list.Clear();
		}

		private void ClearRequestData(List<AsyncOperation> list)
		{
			list.Clear();
		}

		public void ClearUnusedBgm(List<ISoundCommand> nextBgmList)
		{
			ClearUnusedData(nextBgmList, m_introData);
			ClearUnusedData(nextBgmList, m_outroData);
			int num = m_partsData.Length;
			for (int i = 0; i < num; i++)
			{
				ClearUnusedData(nextBgmList, m_partsData[i]);
			}
		}

		private void ClearUnusedData(List<ISoundCommand> nextList, List<PartsData> dataList)
		{
			if (nextList.Count <= 0)
			{
				return;
			}
			for (int i = 0; i < dataList.Count; i++)
			{
				bool flag = RemoveCommandWithID(nextList, dataList[i].ID);
				if (nextList.Count <= 0)
				{
					break;
				}
			}
			Resources.UnloadUnusedAssets();
		}

		private bool RemoveCommandWithID(List<ISoundCommand> list, int id)
		{
			bool result = false;
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].ID == id)
				{
					list.RemoveAt(i);
					i--;
					result = true;
				}
			}
			return result;
		}

		public void Load(List<ISoundCommand> bgmList, ISoundCommand firstBgm)
		{
			if (bgmList == null)
			{
				return;
			}
			ClearUnusedBgm(bgmList);
			int count = bgmList.Count;
			for (int i = 0; i < count; i++)
			{
				int iD = bgmList[i].ID;
				BgmData.Param param = m_data.FindByID(iD);
				LoadAllParts(iD, param);
				if (param.Intro)
				{
					LoadIntro(iD, param.Layer);
				}
				if (param.Outro)
				{
					LoadOutro(iD, param.Layer);
				}
				IsLoading = true;
			}
			FirstBgmID = -1;
			if (firstBgm != null)
			{
				FirstBgmID = firstBgm.ID;
			}
		}

		private void LoadAllParts(int id, BgmData.Param data)
		{
			int parts = data.Parts;
			for (int i = 0; i < data.Layer; i++)
			{
				for (int j = 0; j < parts; j++)
				{
					int partsID = j + 2;
					LoadParts(id, partsID, i, m_partsData[i], m_partsRequests);
				}
			}
		}

		private void LoadParts(int baseID, int partsID, int layer, List<PartsData> dataList, List<AsyncOperation> requestList)
		{
			string path = $"Audio/BGM/{baseID:D2}/{baseID:D2}_{layer}_{partsID:D2}";
			ResourceRequest resourceRequest = Resources.LoadAsync<AudioClip>(path);
			resourceRequest.completed += delegate(AsyncOperation obj)
			{
				OnLoadDataComplete(obj, dataList, baseID, partsID, layer, requestList, path);
			};
			requestList.Add(resourceRequest);
		}

		private void LoadIntro(int baseID, int numLayers)
		{
			LoadUniqueParts(baseID, 0, numLayers, m_introData, m_introRequests);
		}

		private void LoadOutro(int baseID, int numLayers)
		{
			LoadUniqueParts(baseID, 1, numLayers, m_outroData, m_outroRequests);
		}

		private void LoadUniqueParts(int baseID, int partsID, int numLayers, List<PartsData> dataList, List<AsyncOperation> requestList)
		{
			for (int i = 0; i < numLayers; i++)
			{
				LoadParts(baseID, partsID, i, dataList, requestList);
			}
		}

		private void OnLoadDataComplete(AsyncOperation obj, List<PartsData> soundList, int baseID, int partsID, int layer, List<AsyncOperation> requestList, string path)
		{
			requestList.Remove(obj);
			IsLoading = HasRequest;
			AudioClip audioClip = (obj as ResourceRequest).asset as AudioClip;
			if (!(audioClip == null))
			{
				soundList.Add(new PartsData(baseID, partsID, layer, audioClip, isStoreFrequency: true));
			}
		}

		public List<AudioClip> FindIntros(int baseID, int layer)
		{
			m_introList.Clear();
			return FindTracks(baseID, layer, m_introData, m_introList).Clips;
		}

		public List<AudioClip> FindOutros(int baseID, int layer)
		{
			m_outroList.Clear();
			return FindTracks(baseID, layer, m_outroData, m_outroList).Clips;
		}

		private ClipData FindTracks(int baseID, int layer, List<PartsData> dataList, List<AudioClip> list)
		{
			m_clipData.Clips = null;
			int count = dataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (dataList[i].ID == baseID && dataList[i].Layer == layer)
				{
					list.Add(dataList[i].Clip);
					m_clipData.Frequency = dataList[i].Frequency;
				}
			}
			m_clipData.Clips = list;
			return m_clipData;
		}

		public List<PartsData> FindPartsList(int baseID, int layer)
		{
			m_outputPartsList.Clear();
			int count = m_partsData[layer].Count;
			for (int i = 0; i < count; i++)
			{
				if (m_partsData[layer][i].ID == baseID && m_partsData[layer][i].Layer == layer)
				{
					m_outputPartsList.Add(m_partsData[layer][i]);
				}
			}
			return m_outputPartsList;
		}

		public int FindFrequency(int baseID)
		{
			int count = m_partsData[0].Count;
			for (int i = 0; i < count; i++)
			{
				if (m_partsData[0][i].ID == baseID)
				{
					return m_partsData[0][i].Frequency;
				}
			}
			return -1;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create Debug Settings", fileName = "DebugSettings")]
	public class DebugSettings : ScriptableObject
	{
		[SerializeField]
		public int ScenarioID;

		[SerializeField]
		public int SkipDestinationIndex = -1;
	}
	public class AvaterBodyObject : BaseAvaterObject
	{
		protected override bool InitialRenderEnabled => false;
	}
	public class AvaterHandObject : BaseAvaterObject
	{
		public enum Node
		{
			RightHand,
			LeftHand
		}

		[SerializeField]
		private Animator _animator;

		[SerializeField]
		[EnumLabel(typeof(Node))]
		private Transform[] _nodes;

		private int m_idParamIndex;

		private int m_startAnimationParamIndex;

		public override Animator AvaterAnimator => _animator;

		protected override bool InitialRenderEnabled => false;

		protected override void OnAwakeInitialize()
		{
			m_idParamIndex = Animator.StringToHash("motion");
			m_startAnimationParamIndex = Animator.StringToHash("motionTrigger");
		}

		public override void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (id < 300 && !(AvaterAnimator == null))
			{
				AvaterAnimator.SetInteger(m_idParamIndex, id);
				AvaterAnimator.SetTrigger(m_startAnimationParamIndex);
			}
		}

		public Transform GetNodeTransform(Node index)
		{
			return _nodes[(int)index];
		}
	}
	public class AvaterMaterialController : MonoBehaviour
	{
		private void Start()
		{
		}

		private void Update()
		{
		}
	}
	public class AvaterTrackedHandObject : BaseAvaterObject
	{
		public enum Node
		{
			TrackedGrabPivot
		}

		[SerializeField]
		private Animator _animator;

		[SerializeField]
		[EnumLabel(typeof(Node))]
		private Transform[] _nodes;

		private int m_idParamIndex;

		private int m_startAnimationParamIndex;

		private bool IsShowMenu;

		private Vector3 lastTrackedHandPosition;

		private float HideTimer;

		public override Animator AvaterAnimator => _animator;

		protected override bool InitialRenderEnabled => false;

		public bool IsTrackedHandShowing { get; set; }

		public bool SleepTrackedHandShowing { get; set; }

		public bool IsPreventSleeping { get; set; }

		public bool TrackedHandShowSetting { get; set; }

		public bool IsForceTrackedHandHiding { get; set; }

		public bool IsForceTrackedHandFadeHiding { get; set; }

		protected override void OnAwakeInitialize()
		{
			m_idParamIndex = Animator.StringToHash("motion");
			m_startAnimationParamIndex = Animator.StringToHash("motionTrigger");
			IsTrackedHandShowing = MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsFadeInOnNew;
			TrackedHandShowSetting = true;
			IsForceTrackedHandHiding = false;
			lastTrackedHandPosition = base.transform.position;
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Subscribe(delegate(bool opened)
				{
					ShowMenu(opened);
				}).AddTo(base.gameObject);
			}
		}

		public override void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (id < 300 && !(AvaterAnimator == null))
			{
				AvaterAnimator.SetInteger(m_idParamIndex, id);
				AvaterAnimator.SetTrigger(m_startAnimationParamIndex);
			}
		}

		public Transform GetNodeTransform(Node index)
		{
			return _nodes[(int)index];
		}

		public void ChangeTrackedHandShowing(float duration = 0.2f)
		{
			if (IsTrackedHandShowing && TrackedHandShowSetting && !IsForceTrackedHandHiding && !IsForceTrackedHandFadeHiding)
			{
				StartFadeIn(duration, delegate
				{
				});
			}
		}

		public void ChangeTrackedHandHiding(float duration = 0.2f)
		{
			StartFadeOut(duration, delegate
			{
			});
		}

		public void TrackedHandMoveCheck()
		{
			if (!IsShowMenu)
			{
				if (IsPreventSleeping)
				{
					if (!SleepTrackedHandShowing)
					{
						ChangeTrackedHandShowing();
						SleepTrackedHandShowing = true;
						HideTimer = 0f;
					}
				}
				else
				{
					float num = Vector3.Distance(base.transform.position, lastTrackedHandPosition);
					if (!SleepTrackedHandShowing)
					{
						if ((double)num > 0.02)
						{
							ChangeTrackedHandShowing();
							SleepTrackedHandShowing = true;
							HideTimer = 0f;
						}
					}
					else if ((double)num < 0.005)
					{
						if (HideTimer > 3f)
						{
							ChangeTrackedHandHiding();
							SleepTrackedHandShowing = false;
						}
						else
						{
							HideTimer += 0.1f;
						}
					}
					else
					{
						HideTimer = 0f;
					}
				}
			}
			lastTrackedHandPosition = base.transform.position;
		}

		public void ShowMenu(bool isHandFade)
		{
			if (isHandFade)
			{
				IsShowMenu = true;
				ChangeTrackedHandHiding();
			}
			else
			{
				IsShowMenu = false;
				ChangeTrackedHandShowing();
			}
		}

		public void ForceHideTrackedHand(bool fide)
		{
			if (fide)
			{
				IsForceTrackedHandHiding = true;
				ChangeTrackedHandHiding();
			}
			else
			{
				IsForceTrackedHandHiding = false;
				ChangeTrackedHandShowing();
			}
		}

		public void ForceFadeHideTrackedHand(bool fide)
		{
			if (fide)
			{
				IsForceTrackedHandFadeHiding = true;
				ChangeTrackedHandHiding();
			}
			else
			{
				IsForceTrackedHandFadeHiding = false;
				ChangeTrackedHandShowing();
			}
		}

		public void ForceFadeHideTrackedHand(bool fide, float duration)
		{
			if (fide)
			{
				IsForceTrackedHandFadeHiding = true;
				ChangeTrackedHandHiding(duration);
			}
			else
			{
				IsForceTrackedHandFadeHiding = false;
				ChangeTrackedHandShowing(duration);
			}
		}
	}
	public class AvaterTrackedHandObjectTimer : MonoBehaviour
	{
		private AvaterTrackedHandObject TrackedHandObject;

		private void Start()
		{
			TrackedHandObject = GetComponent<AvaterTrackedHandObject>();
			Observable.Interval(TimeSpan.FromMilliseconds(100.0)).Subscribe(delegate
			{
				TrackedHandObject.TrackedHandMoveCheck();
			}).AddTo(base.gameObject);
		}
	}
	public abstract class BaseAvaterObject : MonoBehaviour
	{
		private const float AVATER_MATERIAL_FADE_DURATION = 0.25f;

		private const float AVATER_DEFAULT_OUTLINE = 0f;

		private const string _PARAM_ALPHA = "_Alpha";

		private const string _PARAM_OUTLINE_SIZE = "_Outline";

		private const string _PARAM_OUTLINE_COLOR = "_OutlineColor";

		[SerializeField]
		private List<AdvCharaTextureData> _textures = new List<AdvCharaTextureData>();

		private List<Renderer> _renderers;

		private Material _currentMaterial;

		private Dictionary<int, Material> _fixedMaterials = new Dictionary<int, Material>();

		private bool _renderEnabled;

		private bool _isFading;

		private Color _defaultOutlineColor;

		private float _defaultOutlineSize;

		private Coroutine _currentFadeRoutine;

		private IDisposable _disposeSmoothOutlineColorChange;

		private IDisposable _disposeSmoothOutlineSizeChange;

		public bool IsFading => _isFading;

		public virtual Animator AvaterAnimator => null;

		public bool IsVisible => _renderEnabled;

		protected virtual bool InitialRenderEnabled => true;

		private float MaterialAlpha
		{
			get
			{
				if (!_renderEnabled)
				{
					return 0f;
				}
				return _currentMaterial.GetFloat("_Alpha");
			}
		}

		private void Awake()
		{
			FineRenderers();
			SetDefaultValues();
			OnAwakeInitialize();
		}

		private void FineRenderers()
		{
			_renderers = new List<Renderer>();
			_renderers.AddRange(GetComponents<Renderer>());
			_renderers.AddRange(GetComponentsInChildren<Renderer>());
			FindFixedMaterials();
			SetRenderEnabled(InitialRenderEnabled, force: true);
		}

		protected virtual void OnAwakeInitialize()
		{
		}

		private void FindFixedMaterials()
		{
			_renderers.ForEach(delegate(Renderer renderer)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				Material[] array = new Material[sharedMaterials.Length];
				for (int i = 0; i < sharedMaterials.Length; i++)
				{
					Material material = sharedMaterials[i];
					if (!(material == null))
					{
						if (!_fixedMaterials.TryGetValue(material.GetHashCode(), out var value))
						{
							value = new Material(material);
							value.SetFloat("_Alpha", 0f);
							_fixedMaterials.Add(material.GetHashCode(), value);
							if (_currentMaterial == null)
							{
								_currentMaterial = value;
							}
						}
						array[i] = value;
					}
				}
				renderer.materials = array;
			});
		}

		private void SetMaterialsAlpha(float alpha)
		{
			foreach (KeyValuePair<int, Material> fixedMaterial in _fixedMaterials)
			{
				fixedMaterial.Value.SetFloat("_Alpha", alpha);
			}
		}

		public void SetRenderEnabled(bool flag, bool force = false)
		{
			if (force || flag != _renderEnabled)
			{
				_renderEnabled = flag;
				int count = _renderers.Count;
				for (int i = 0; i < count; i++)
				{
					_renderers[i].enabled = _renderEnabled;
				}
			}
		}

		private void SetDefaultValues()
		{
			_defaultOutlineSize = 0f;
			_defaultOutlineColor = GetMaterialOutlineColor();
			SetOutlineSize(_defaultOutlineSize);
		}

		public void RevertToDefault()
		{
			SetOutlineSize(_defaultOutlineSize);
			SetOutlineColor(_defaultOutlineColor);
		}

		public Coroutine StartFadeIn()
		{
			return StartFadeIn(0.25f, delegate
			{
			});
		}

		public Coroutine StartFadeIn(Action onEnd)
		{
			return StartFadeIn(0.25f, onEnd);
		}

		public Coroutine StartFadeIn(float duration, Action onEnd)
		{
			if (MaterialAlpha >= 1f)
			{
				onEnd?.Invoke();
				return null;
			}
			float materialAlpha = MaterialAlpha;
			SetRenderEnabled(flag: true);
			if (_currentFadeRoutine != null)
			{
				StopCoroutine(_currentFadeRoutine);
			}
			_currentFadeRoutine = StartCoroutine(CoroutineFade(materialAlpha, 1f, duration, onEnd));
			return _currentFadeRoutine;
		}

		public Coroutine StartFadeOut()
		{
			return StartFadeOut(0.25f, delegate
			{
			});
		}

		public Coroutine StartFadeOut(Action onEnd)
		{
			return StartFadeOut(0.25f, onEnd);
		}

		public Coroutine StartFadeOut(float duration, Action onEnd)
		{
			if (!_renderEnabled || MaterialAlpha <= 0f)
			{
				onEnd?.Invoke();
				return null;
			}
			if (_currentFadeRoutine != null)
			{
				StopCoroutine(_currentFadeRoutine);
			}
			_currentFadeRoutine = StartCoroutine(CoroutineFade(MaterialAlpha, 0f, duration, onEnd));
			return _currentFadeRoutine;
		}

		private IEnumerator CoroutineFade(float fromA, float toA, float duration, Action onEnd)
		{
			_isFading = true;
			Tweener<float> _alphaTweener = new Tweener<float>(Mathf.Lerp);
			_alphaTweener.Start(fromA, toA, duration);
			while (_alphaTweener.IsActive)
			{
				yield return new WaitForEndOfFrame();
				_alphaTweener.Update(Time.deltaTime);
				SetMaterialsAlpha(_alphaTweener.CurrentValue);
			}
			_isFading = false;
			onEnd?.Invoke();
		}

		public void SetOutlineSize(float value)
		{
			DisposeSmoothOutlineSize();
			SetMaterialOutlineSize(value);
		}

		private void SetMaterialOutlineSize(float value)
		{
			foreach (Material value2 in _fixedMaterials.Values)
			{
				value2.SetFloat("_Outline", value);
			}
		}

		public void SetOutlineColor(Color value)
		{
			DisposeSmoothOutlineColor();
			SetMaterialOutlineColor(value);
		}

		private void SetMaterialOutlineColor(Color value)
		{
			foreach (Material value2 in _fixedMaterials.Values)
			{
				value2.SetColor("_OutlineColor", value);
			}
		}

		private float GetMaterialOutlineSize()
		{
			using (Dictionary<int, Material>.ValueCollection.Enumerator enumerator = _fixedMaterials.Values.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					return enumerator.Current.GetFloat("_Outline");
				}
			}
			return 0f;
		}

		private Color GetMaterialOutlineColor()
		{
			using (Dictionary<int, Material>.ValueCollection.Enumerator enumerator = _fixedMaterials.Values.GetEnumerator())
			{
				if (enumerator.MoveNext())
				{
					return enumerator.Current.GetColor("_OutlineColor");
				}
			}
			return Color.clear;
		}

		public void DisposeSmoothOutlineSize()
		{
			if (_disposeSmoothOutlineSizeChange != null)
			{
				_disposeSmoothOutlineSizeChange.Dispose();
				_disposeSmoothOutlineSizeChange = null;
			}
		}

		public void StartSmoothOutlineSizeChange(float duration, float after)
		{
			DisposeSmoothOutlineSize();
			_disposeSmoothOutlineSizeChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineSizeChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineSizeChange(float duration, float after)
		{
			float tick = 0f;
			float before = GetMaterialOutlineSize();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetMaterialOutlineSize(Mathf.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetMaterialOutlineSize(after);
		}

		public void DisposeSmoothOutlineColor()
		{
			if (_disposeSmoothOutlineColorChange != null)
			{
				_disposeSmoothOutlineColorChange.Dispose();
				_disposeSmoothOutlineColorChange = null;
			}
		}

		public void StartSmoothOutlineColorChange(float duration, Color after)
		{
			DisposeSmoothOutlineColor();
			_disposeSmoothOutlineColorChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineColorChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineColorChange(float duration, Color after)
		{
			float tick = 0f;
			Color before = GetMaterialOutlineColor();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetMaterialOutlineColor(Color.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetMaterialOutlineColor(after);
		}

		private Texture FindTextureByType(AdvCharaTextureData.TextureType type)
		{
			return _textures.Find((AdvCharaTextureData param) => param.Type == type)?.Texture;
		}

		private void SetTextureToMaterials(Texture texture)
		{
			foreach (Material value in _fixedMaterials.Values)
			{
				value.mainTexture = texture;
			}
		}

		public void ChangeTextureType(AdvCharaTextureData.TextureType type)
		{
			Texture texture = FindTextureByType(type);
			if (!(texture == null))
			{
				SetTextureToMaterials(texture);
			}
		}

		public virtual void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Avater Setting", fileName = "AvaterSetting")]
	public class DataAvaterSetting : ScriptableObject
	{
		[EnumLabel(typeof(PlayerAvater.AvaterParts))]
		public int[] MaxTypes = new int[2] { 1, 1 };
	}
	public class AvaterVanishEffect : MonoBehaviour
	{
		[SerializeField]
		private float _defaultFadeTime = 0.3f;

		[SerializeField]
		private float _defaultRemainTime = 0.5f;

		private Renderer[] _myRenderers;

		private SortedList<int, Material> _instancedMaterials;

		private IDisposable _dispoceEffect;

		private void Awake()
		{
			FindRenderer();
			CreateMaterialInstance();
			SetMaterialAlpha(0f);
			SetRendererEnable(flag: false);
		}

		private void FindRenderer()
		{
			_myRenderers = GetComponentsInChildren<Renderer>();
		}

		private void CreateMaterialInstance()
		{
			_instancedMaterials = new SortedList<int, Material>();
			Renderer[] myRenderers = _myRenderers;
			foreach (Renderer renderer in myRenderers)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				Material[] array = new Material[sharedMaterials.Length];
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					Material material = sharedMaterials[j];
					if (!_instancedMaterials.TryGetValue(material.GetHashCode(), out var value))
					{
						value = new Material(material);
						_instancedMaterials.Add(material.GetHashCode(), value);
					}
					array[j] = value;
				}
				renderer.materials = array;
			}
		}

		private void SetMaterialAlpha(float a)
		{
			foreach (Material value in _instancedMaterials.Values)
			{
				value.SetFloat("_Alpha", a);
			}
		}

		private void SetRendererEnable(bool flag)
		{
			Renderer[] myRenderers = _myRenderers;
			for (int i = 0; i < myRenderers.Length; i++)
			{
				myRenderers[i].enabled = flag;
			}
		}

		public void StartVanishEffect()
		{
			if (_dispoceEffect != null)
			{
				_dispoceEffect.Dispose();
				_dispoceEffect = null;
			}
			SetRendererEnable(flag: true);
			_dispoceEffect = Observable.FromMicroCoroutine((CancellationToken _) => CoroutineFade(0f, 1f, _defaultFadeTime)).SelectMany((Unit _) => CoroutineWait(_defaultRemainTime)).SelectMany((Unit _) => CoroutineFade(1f, 0f, _defaultFadeTime))
				.Subscribe(delegate
				{
					SetRendererEnable(flag: false);
					_dispoceEffect = null;
				})
				.AddTo(base.gameObject);
		}

		private IEnumerator CoroutineFade(float start, float end, float duration)
		{
			Tweener<float> _tweener = new Tweener<float>(Mathf.Lerp, start);
			_tweener.Start(start, end, duration);
			while (_tweener.IsActive)
			{
				_tweener.Update(Time.deltaTime);
				SetMaterialAlpha(_tweener.CurrentValue);
				yield return null;
			}
		}

		private IEnumerator CoroutineWait(float duration)
		{
			Common.Timer timer = new Common.Timer(duration);
			while (!timer.IsTimeUp)
			{
				timer.Update(Time.deltaTime);
				yield return null;
			}
		}
	}
	public class AvaterBodyLoader : BaseAvaterLoader
	{
		protected override string LoadFolderFormat => "Prefabs/Avaters/{0}/Body{0}";

		protected override bool DefaultFadeInOnNew => true;
	}
	public class AvaterHandLoader : BaseAvaterLoader
	{
		protected override string LoadFolderFormat => "Prefabs/Avaters/{0}/Hand{0}Type{1}";

		protected override bool DefaultFadeInOnNew => false;
	}
	public class AvaterTrackedHandLoader : BaseAvaterLoader
	{
		[SerializeField]
		private VRDeviceDefine.HandType _handType;

		private Transform _thisTrans;

		protected override bool DisabledToLoad => !SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands;

		protected override string LoadFolderFormat
		{
			get
			{
				if (_handType != 0)
				{
					return "Prefabs/Avaters/{0}/TrackedHandRight{0}";
				}
				return "Prefabs/Avaters/{0}/TrackedHandLeft{0}";
			}
		}

		protected override bool DefaultFadeInOnNew => true;

		private Transform ThisTrans
		{
			get
			{
				if (_thisTrans == null)
				{
					_thisTrans = base.transform;
				}
				return _thisTrans;
			}
		}

		public override void OnStartAvater()
		{
			if (DisabledToLoad)
			{
				base.gameObject.SetActive(value: false);
				return;
			}
			SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => base.IsLoaded && !base.IsPausedTracking).Subscribe(delegate
			{
				ThisTrans.localPosition = SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.GetHandPosition(_handType);
				ThisTrans.localRotation = SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.GetHandRotation(_handType);
			}).AddTo(base.gameObject);
		}
	}
	public abstract class BaseAvaterLoader : MonoBehaviour
	{
		protected const string FOLDER_BODY_FORMAT = "Prefabs/Avaters/{0}/Body{0}";

		protected const string FOLDER_HAND_FORMAT = "Prefabs/Avaters/{0}/Hand{0}Type{1}";

		protected const string FOLDER_TRACKEDHAND_LEFT_FORMAT = "Prefabs/Avaters/{0}/TrackedHandLeft{0}";

		protected const string FOLDER_TRACKEDHAND_RIGHT_FORMAT = "Prefabs/Avaters/{0}/TrackedHandRight{0}";

		private int _currentAvaterIndex;

		private BaseAvaterObject _currentAvaterObject;

		private SortedList<int, BaseAvaterObject> _loadedAvaters = new SortedList<int, BaseAvaterObject>();

		public bool IsFadeInOnNew { get; set; }

		public int InitialFadeInIndex { get; set; }

		public int AvaterTypeMax { get; set; }

		public bool IsPausedTracking { get; set; }

		public bool IsBusy { get; private set; }

		public bool IsLoaded { get; private set; }

		public BaseAvaterObject AvaterObject => _currentAvaterObject;

		protected virtual bool DisabledToLoad => false;

		protected virtual string LoadFolderFormat => "";

		protected virtual bool DefaultFadeInOnNew => true;

		private void Awake()
		{
			IsFadeInOnNew = DefaultFadeInOnNew;
			InitialFadeInIndex = 0;
			AvaterTypeMax = 1;
		}

		private void Start()
		{
			OnStartAvater();
		}

		public virtual void OnStartAvater()
		{
		}

		public Coroutine LoadAvater(GameDefine.CharaID charaId)
		{
			if (DisabledToLoad)
			{
				return null;
			}
			if (charaId == GameDefine.CharaID.NONE)
			{
				DestroyAvater();
				return null;
			}
			return StartCoroutine(CoroutineLoadAvater(charaId));
		}

		private IEnumerator CoroutineLoadAvater(GameDefine.CharaID charaId)
		{
			yield return new WaitUntil(() => !IsBusy);
			IsBusy = true;
			DestroyAvater();
			for (int i = 0; i < AvaterTypeMax; i++)
			{
				ResourceRequest request = Resources.LoadAsync<BaseAvaterObject>(string.Format(LoadFolderFormat, (int)charaId, i));
				yield return request;
				if (!(request.asset == null))
				{
					BaseAvaterObject baseAvaterObject = UnityEngine.Object.Instantiate(request.asset as BaseAvaterObject);
					baseAvaterObject.transform.SetParent(base.transform, worldPositionStays: false);
					_loadedAvaters.Add(i, baseAvaterObject);
				}
			}
			_currentAvaterIndex = InitialFadeInIndex;
			if (!_loadedAvaters.TryGetValue(_currentAvaterIndex, out _currentAvaterObject))
			{
				_currentAvaterObject = null;
			}
			IsBusy = false;
			IsLoaded = _loadedAvaters.Count != 0;
		}

		public void ChangeCurrentAvaterType(int type)
		{
			if (_currentAvaterObject != null && _currentAvaterIndex != type)
			{
				_currentAvaterObject.StartFadeOut();
			}
			_currentAvaterIndex = type;
			_currentAvaterObject = _loadedAvaters[_currentAvaterIndex];
			if (_currentAvaterObject != null)
			{
				_currentAvaterObject.StartFadeIn();
			}
		}

		public void DestroyAvater()
		{
			if (_loadedAvaters.Count == 0)
			{
				return;
			}
			foreach (BaseAvaterObject value in _loadedAvaters.Values)
			{
				UnityEngine.Object.Destroy(value.gameObject);
			}
			_currentAvaterObject = null;
			_loadedAvaters.Clear();
			IsLoaded = false;
		}
	}
	public class PlayerAvater : UpdateableComponent
	{
		public enum AvaterParts
		{
			Body,
			Hand,
			TrackedHandLeft,
			TrackedHandRight
		}

		public enum AvaterTrackTypes
		{
			CameraPositon,
			NeckPosition,
			HeadPositionAndRotation,
			HandPositionAndRotation
		}

		public enum FadeModes
		{
			None,
			Smooth,
			Dither
		}

		[Header("Components - Pivots")]
		[SerializeField]
		private Transform messagePivot;

		[SerializeField]
		private Transform bodyPivot;

		[SerializeField]
		private Transform handPivot;

		[Header("Components - Targets")]
		[SerializeField]
		private Transform positionPivot;

		[SerializeField]
		private Transform headRotationPivot;

		[SerializeField]
		private Transform handRotationPivot;

		[Header("Components - Loaders")]
		[SerializeField]
		private PlayerAvaterResourceController resources;

		[Header("Components - Misc")]
		[SerializeField]
		private AvaterVanishEffect vanishEffect;

		[Header("Parameters")]
		[SerializeField]
		private float threshouldStopLookingDegree = 80f;

		[SerializeField]
		private float speedFetchHead = 5f;

		[SerializeField]
		private float speedFetchHand = 10f;

		[SerializeField]
		private bool emitEffectOnVanish = true;

		private bool _isHandRotateAvailable;

		private Transform _fetchHeadTarget;

		private Transform _fetchHandTarget;

		private Quaternion _headLookQuat;

		private Quaternion _handLookQuat;

		public Transform MessagePivot => messagePivot;

		public PlayerAvaterResourceController AvaterResources => resources;

		public bool IsSkipSmooth { get; set; }

		public bool EmitEffectOnVanish
		{
			get
			{
				return emitEffectOnVanish;
			}
			set
			{
				emitEffectOnVanish = value;
			}
		}

		protected override void Initialize()
		{
			_fetchHeadTarget = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadObject.NeckAnchor;
			resources.OnBeforeUnloadAvater.Where((Unit _) => EmitEffectOnVanish).Subscribe(delegate
			{
				EmitVanishEffect();
			});
			SingletonMonoBehaviour<GameInputManager>.Instance.OnChangeMainHand.Subscribe(delegate(VRDeviceDefine.HandType handType)
			{
				switch (handType)
				{
				case VRDeviceDefine.HandType.Left:
					_fetchHandTarget = SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject.ThisTransform;
					break;
				case VRDeviceDefine.HandType.Right:
					_fetchHandTarget = SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject.ThisTransform;
					break;
				}
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			UpdateHeadPivotTransform(delta);
			if (_isHandRotateAvailable)
			{
				UpdateHandPivotTransform(delta);
			}
		}

		private void UpdateHeadPivotTransform(float deltaTime)
		{
			Vector3 position = _fetchHeadTarget.position;
			Quaternion rotation = _fetchHeadTarget.rotation;
			positionPivot.position = position;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			if (num < threshouldStopLookingDegree)
			{
				_headLookQuat = Quaternion.Euler(0f, (rotation * Quaternion.Euler(0f - num, 0f, 0f)).eulerAngles.y, 0f);
			}
			if (IsSkipSmooth)
			{
				headRotationPivot.rotation = _headLookQuat;
			}
			else
			{
				headRotationPivot.rotation = Quaternion.Slerp(headRotationPivot.rotation, _headLookQuat, speedFetchHead * deltaTime);
			}
		}

		private void UpdateHandPivotTransform(float deltaTime)
		{
			Quaternion rotation = _fetchHandTarget.rotation;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			_handLookQuat = Quaternion.Euler(0f, (rotation * Quaternion.Euler(0f - num, 0f, 0f)).eulerAngles.y, 0f);
			if (IsSkipSmooth)
			{
				handRotationPivot.rotation = _handLookQuat;
			}
			else
			{
				handRotationPivot.rotation = Quaternion.Slerp(handRotationPivot.rotation, _handLookQuat, speedFetchHand * deltaTime);
			}
		}

		public void SetRotationEnabled(AvaterParts partType, AvaterTrackTypes trackType)
		{
			Transform parent = trackType switch
			{
				AvaterTrackTypes.NeckPosition => positionPivot, 
				AvaterTrackTypes.HeadPositionAndRotation => headRotationPivot, 
				AvaterTrackTypes.HandPositionAndRotation => handRotationPivot, 
				_ => SingletonMonoBehaviour<PlayAreaManager>.Instance.CameraAnchorTransform, 
			};
			switch (partType)
			{
			case AvaterParts.Body:
				bodyPivot.SetParent(parent, worldPositionStays: false);
				break;
			case AvaterParts.Hand:
				handPivot.SetParent(parent, worldPositionStays: false);
				_isHandRotateAvailable = trackType == AvaterTrackTypes.HandPositionAndRotation;
				break;
			}
		}

		public void SetRotationEnableWithFade(AvaterParts partType, AvaterTrackTypes trackType, float duration)
		{
			BaseAvaterObject avaterObjectByIndex = AvaterResources.GetAvaterObjectByIndex(partType);
			if ((object)avaterObjectByIndex == null)
			{
				return;
			}
			if (!avaterObjectByIndex.IsVisible)
			{
				SetRotationEnabled(partType, trackType);
				return;
			}
			StartAvaterFade(partType, IsFadeIn: false, duration, delegate
			{
				SetRotationEnabled(partType, trackType);
				StartAvaterFade(partType, IsFadeIn: true, duration);
			});
		}

		public void SetOutlineParameters(AvaterParts partType, CommandAvaterOutline command)
		{
			BaseAvaterObject obj = AvaterResources.GetAvaterObjectByIndex(partType);
			if ((object)obj == null)
			{
				return;
			}
			switch (command.FadeMode)
			{
			case FadeModes.Smooth:
				if (command.FlagChangeSize)
				{
					obj.StartSmoothOutlineSizeChange(command.FadeDuration, command.OutlineSize);
				}
				if (command.FlagChangeColor)
				{
					obj.StartSmoothOutlineColorChange(command.FadeDuration, command.OutlineColor);
				}
				break;
			case FadeModes.Dither:
				StartAvaterFade(partType, IsFadeIn: false, command.FadeDuration / 2f, delegate
				{
					if (command.FlagChangeSize)
					{
						obj.SetOutlineSize(command.OutlineSize);
					}
					if (command.FlagChangeColor)
					{
						obj.SetOutlineColor(command.OutlineColor);
					}
					StartAvaterFade(partType, IsFadeIn: true, command.FadeDuration / 2f);
				});
				break;
			default:
				if (command.FlagChangeSize)
				{
					obj.SetOutlineSize(command.OutlineSize);
				}
				if (command.FlagChangeColor)
				{
					obj.SetOutlineColor(command.OutlineColor);
				}
				break;
			}
		}

		public Coroutine StartAvaterFade(AvaterParts partType, bool IsFadeIn, float duration, Action onEnd = null)
		{
			BaseAvaterObject avaterObjectByIndex = AvaterResources.GetAvaterObjectByIndex(partType);
			if ((object)avaterObjectByIndex == null)
			{
				return null;
			}
			if (IsFadeIn)
			{
				return avaterObjectByIndex.StartFadeIn(duration, onEnd);
			}
			return avaterObjectByIndex.StartFadeOut(duration, onEnd);
		}

		public void EmitVanishEffect()
		{
			vanishEffect.StartVanishEffect();
		}

		public void ClearScquenceRelations()
		{
			SetRotationEnabled(AvaterParts.Body, AvaterTrackTypes.HeadPositionAndRotation);
			SetRotationEnabled(AvaterParts.Hand, AvaterTrackTypes.HeadPositionAndRotation);
			if (AvaterResources.HasBody)
			{
				AvaterResources.BodyObject.RevertToDefault();
			}
			if (AvaterResources.HasHand)
			{
				AvaterResources.HandObject.RevertToDefault();
			}
		}
	}
	public class PlayerAvaterResourceController : MonoBehaviour
	{
		protected const string FOLDER_SETTING_FORMAT = "Prefabs/Avaters/{0}/AvaterSetting{0}";

		[Header("Components - Loader")]
		[SerializeField]
		[EnumLabel(typeof(PlayerAvater.AvaterParts))]
		private BaseAvaterLoader[] _avaterLoaders;

		private DataAvaterSetting _currentSetting;

		private Material[] _avaterMaterials;

		private GameDefine.CharaID _currentCharaId;

		private GameDefine.CharaID _fadeNextCharaId;

		private AdvCharaTextureSettings _currentAvaterSetting;

		private Subject<Unit> _subjectBeforeUnloadAvater = new Subject<Unit>();

		private Subject<Unit> _subjectAfterAvaterLoaded = new Subject<Unit>();

		public bool IsBusyLoading { get; private set; }

		public bool IsBusyChangingFade { get; private set; }

		public bool HasBody => BodyLoader.AvaterObject != null;

		public AvaterBodyLoader BodyLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.Body) as AvaterBodyLoader;

		public AvaterBodyObject BodyObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.Body) as AvaterBodyObject;

		public AvaterHandLoader HandLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.Hand) as AvaterHandLoader;

		public AvaterHandObject HandObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.Hand) as AvaterHandObject;

		public bool HasHand => HandLoader.AvaterObject != null;

		public AvaterTrackedHandLoader TrackedHandLeftLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.TrackedHandLeft) as AvaterTrackedHandLoader;

		public AvaterTrackedHandLoader TrackedHandRightLoader => GetLoaderByIndex(PlayerAvater.AvaterParts.TrackedHandRight) as AvaterTrackedHandLoader;

		public bool HasTrackedLeftHand => TrackedHandLeftLoader.AvaterObject != null;

		public bool HasTrackedRightHand => TrackedHandRightLoader.AvaterObject != null;

		public bool HasTrackedHands
		{
			get
			{
				if (!HasTrackedLeftHand)
				{
					return HasTrackedRightHand;
				}
				return true;
			}
		}

		public AvaterTrackedHandObject TrackedHandLeftObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.TrackedHandLeft) as AvaterTrackedHandObject;

		public AvaterTrackedHandObject TrackedHandRightObject => GetAvaterObjectByIndex(PlayerAvater.AvaterParts.TrackedHandRight) as AvaterTrackedHandObject;

		public IObservable<Unit> OnBeforeUnloadAvater => _subjectBeforeUnloadAvater;

		public IObservable<Unit> OnAfterAvaterLoaded => _subjectAfterAvaterLoaded;

		public BaseAvaterLoader GetLoaderByIndex(PlayerAvater.AvaterParts index)
		{
			return _avaterLoaders[(int)index];
		}

		public BaseAvaterObject GetAvaterObjectByIndex(PlayerAvater.AvaterParts index)
		{
			return GetLoaderByIndex(index).AvaterObject;
		}

		private void Start()
		{
			SingletonMonoBehaviour<LocalData>.Instance.OnChangeCharacter.Subscribe(delegate(GameDefine.CharaID charaId)
			{
				ChangeCharacterWithFades(charaId);
			}).AddTo(base.gameObject);
			OnAfterAvaterLoaded.Subscribe(delegate
			{
				ApplyTextureSetting();
			});
		}

		private void ChangeCharacterWithFades(GameDefine.CharaID charaId)
		{
			_fadeNextCharaId = charaId;
			if (IsBusyChangingFade && !IsBusyLoading)
			{
				_subjectAfterAvaterLoaded.OnNext(Unit.Default);
			}
			else
			{
				StartCoroutine(CoroutineChangeChacater());
			}
		}

		private IEnumerator CoroutineChangeChacater()
		{
			yield return new WaitUntil(() => !IsBusyChangingFade);
			yield return new WaitUntil(() => !IsBusyLoading);
			IsBusyChangingFade = true;
			if (_currentSetting != null)
			{
				yield return StartCoroutine(CoroutineUnloadFade());
			}
			GameDefine.CharaID fadeNextCharaId = _fadeNextCharaId;
			if (fadeNextCharaId == GameDefine.CharaID.NONE || fadeNextCharaId == GameDefine.CharaID.UNKNOWN)
			{
				IsBusyChangingFade = false;
				_subjectAfterAvaterLoaded.OnNext(Unit.Default);
				yield break;
			}
			yield return StartCoroutine(CoroutineLoadAvater(fadeNextCharaId));
			_subjectAfterAvaterLoaded.OnNext(Unit.Default);
			yield return StartCoroutine(CoroutineFadeIn());
			IsBusyChangingFade = false;
		}

		private void ChangeCharacter(GameDefine.CharaID charaId)
		{
			if (charaId == GameDefine.CharaID.NONE || charaId == GameDefine.CharaID.UNKNOWN)
			{
				UnloadAvater();
			}
			else
			{
				LoadAvaterComponents(charaId);
			}
		}

		private void LoadAvaterComponents(GameDefine.CharaID charaId)
		{
			_ = IsBusyLoading;
			StartCoroutine(CoroutineLoadAvater(charaId));
		}

		private IEnumerator CoroutineLoadAvater(GameDefine.CharaID charaId)
		{
			yield return new WaitUntil(() => !IsBusyLoading);
			IsBusyLoading = true;
			yield return StartCoroutine(CoroutineLoadAvaterSetting(charaId));
			Queue<Coroutine> _pendings = new Queue<Coroutine>();
			for (int i = 0; i < _avaterLoaders.Length; i++)
			{
				BaseAvaterLoader baseAvaterLoader = _avaterLoaders[i];
				baseAvaterLoader.AvaterTypeMax = _currentSetting.MaxTypes[i];
				_pendings.Enqueue(baseAvaterLoader.LoadAvater(charaId));
			}
			while (_pendings.Count > 0)
			{
				yield return _pendings.Dequeue();
			}
			_currentCharaId = charaId;
			IsBusyLoading = false;
		}

		private IEnumerator CoroutineLoadAvaterSetting(GameDefine.CharaID charaId)
		{
			ResourceRequest request = Resources.LoadAsync<DataAvaterSetting>(string.Format("Prefabs/Avaters/{0}/AvaterSetting{0}", (int)charaId));
			yield return request;
			if (!(request.asset == null))
			{
				_currentSetting = request.asset as DataAvaterSetting;
			}
		}

		private void UnloadAvater()
		{
			int num = _avaterLoaders.Length;
			for (int i = 0; i < num; i++)
			{
				BaseAvaterLoader baseAvaterLoader = _avaterLoaders[i];
				if (baseAvaterLoader.IsLoaded)
				{
					baseAvaterLoader.DestroyAvater();
				}
			}
			_currentSetting = null;
		}

		private IEnumerator CoroutineUnloadFade()
		{
			yield return new WaitUntil(() => !IsBusyLoading);
			_subjectBeforeUnloadAvater.OnNext(Unit.Default);
			_currentCharaId = GameDefine.CharaID.NONE;
			int num = _avaterLoaders.Length;
			Queue<Coroutine> _pendings = new Queue<Coroutine>();
			for (int i = 0; i < num; i++)
			{
				BaseAvaterLoader loader = _avaterLoaders[i];
				if (loader.IsLoaded && !(loader.AvaterObject == null))
				{
					_pendings.Enqueue(loader.AvaterObject.StartFadeOut(delegate
					{
						loader.DestroyAvater();
					}));
				}
			}
			while (_pendings.Count > 0)
			{
				yield return _pendings.Dequeue();
			}
			_currentSetting = null;
		}

		private IEnumerator CoroutineFadeIn()
		{
			yield return new WaitUntil(() => !IsBusyLoading);
			int num = _avaterLoaders.Length;
			Queue<Coroutine> _pendings = new Queue<Coroutine>();
			for (int i = 0; i < num; i++)
			{
				BaseAvaterLoader baseAvaterLoader = _avaterLoaders[i];
				if (baseAvaterLoader.IsLoaded && baseAvaterLoader.IsFadeInOnNew)
				{
					_pendings.Enqueue(baseAvaterLoader.AvaterObject.StartFadeIn());
				}
			}
			while (_pendings.Count > 0)
			{
				yield return _pendings.Dequeue();
			}
		}

		public void SetTextureSetting(AdvCharaTextureSettings setting)
		{
			_currentAvaterSetting = setting;
			ApplyTextureSetting();
		}

		private void ApplyTextureSetting()
		{
			if (_currentAvaterSetting == null)
			{
				SetDefaultSettings();
				return;
			}
			AdvCharaTextureData.TextureType type = _currentAvaterSetting.FindExceptionSettings(_currentCharaId)?.Type ?? _currentAvaterSetting.CharaTextureType;
			ChangeTextureType(type, PlayerAvater.AvaterParts.Body);
			ChangeTextureType(type, PlayerAvater.AvaterParts.Hand);
			ChangeTextureType(type, PlayerAvater.AvaterParts.TrackedHandLeft);
			ChangeTextureType(type, PlayerAvater.AvaterParts.TrackedHandRight);
		}

		public void ChangeTextureType(AdvCharaTextureData.TextureType type, PlayerAvater.AvaterParts partType)
		{
			GetAvaterObjectByIndex(partType)?.ChangeTextureType(type);
		}

		private void SetDefaultSettings()
		{
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.Body);
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.Hand);
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.TrackedHandLeft);
			ChangeTextureType(AdvCharaTextureData.TextureType.Normal, PlayerAvater.AvaterParts.TrackedHandRight);
		}
	}
	public class TrackedHandsComponent
	{
		public AvaterTrackedHandObject Left;

		public AvaterTrackedHandObject Right;
	}
	[RequireComponent(typeof(AdvCharaModel))]
	public class AdvChara : UpdateableComponent, IChara
	{
		[SerializeField]
		private GameDefine.CharaID m_id = GameDefine.CharaID.BASE;

		[SerializeField]
		private Transform m_headNode;

		[SerializeField]
		private Transform m_rightHandNode;

		[SerializeField]
		private Transform m_leftHandNode;

		[SerializeField]
		private GameObject m_boneRoot;

		[SerializeField]
		private List<AdvCharaOffCameraDisabler> m_disablers;

		[SerializeField]
		private string m_faceNodeName = "face";

		[SerializeField]
		private bool m_isDeactivateOnStart = true;

		public Vector3 NextPosition;

		private SpringManager m_springManager;

		private GenericLookTargetIK m_lookTarget;

		private GameObject m_gameObject;

		private GameObject m_headObject;

		private SkinnedMeshRenderer m_faceRenderer;

		private bool m_isAttached;

		private bool m_isForcusReserved;

		private Transform m_parent;

		private bool m_isVisible = true;

		private bool m_wasVisible;

		private bool m_isCheckDisabler;

		private DynamicProp[] m_propsAttached;

		public AdvCharaModel Model { get; private set; }

		public GenericLookTargetIK Look => m_lookTarget;

		public AdvCharaStyleChange StyleChange { get; private set; }

		public Transform Head => m_headNode;

		public Transform RightHand => m_rightHandNode;

		public Transform LeftHand => m_leftHandNode;

		public GameObject HeadObject => m_headObject;

		public GameObject BoneRoot => m_boneRoot;

		public GameDefine.CharaID ID => m_id;

		public SkinnedMeshRenderer FaceRenderer => m_faceRenderer;

		public Transform Transform { get; set; }

		public bool IsForcused { get; private set; }

		public bool IsRootBoneActive { get; private set; }

		public bool HasInitialLookAt { get; set; }

		public bool HasInitialMotion { get; set; }

		public bool HasInitialFacial { get; set; }

		protected override void Initialize()
		{
			m_wasVisible = m_isVisible;
			m_isAttached = false;
			m_gameObject = base.gameObject;
			m_headObject = m_headNode.gameObject;
			Transform = base.transform;
			m_parent = Transform.parent;
			IsForcused = true;
			ResetSaftyFlags();
			m_springManager = GetComponent<SpringManager>();
			m_lookTarget = GetComponent<GenericLookTargetIK>();
			InitializeProps();
			m_isCheckDisabler = m_disablers != null && m_disablers.Count > 0;
		}

		private void InitializeProps()
		{
			m_propsAttached = new DynamicProp[3];
			ResetProps();
		}

		private void ResetProps()
		{
			int num = m_propsAttached.Length;
			for (int i = 0; i < num; i++)
			{
				m_propsAttached[i] = null;
			}
		}

		public void Destroy()
		{
			if (m_gameObject != null)
			{
				UnityEngine.Object.Destroy(m_gameObject);
				m_gameObject = null;
			}
		}

		public override void OnUpdate(float delta)
		{
			if (m_isDeactivateOnStart)
			{
				Disable();
				m_isDeactivateOnStart = false;
				base.IsActive = false;
				SetRootBoneActive(isActive: false);
			}
			else if (m_isForcusReserved)
			{
				m_isForcusReserved = false;
				SetForcusedComponentActive(IsForcused);
			}
		}

		private void UpdateVisible()
		{
			if (!m_isCheckDisabler)
			{
				return;
			}
			bool flag = false;
			int count = m_disablers.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_disablers[i].IsVisible)
				{
					flag = true;
					break;
				}
			}
			if (flag != m_wasVisible)
			{
				m_disablers[0].SetEnables(flag);
			}
			m_wasVisible = flag;
		}

		public void SetVisible(bool isVisible)
		{
			m_isVisible |= isVisible;
		}

		public void Setup(GameDefine.CharaID id)
		{
			m_id = id;
			Transform = base.transform;
			StyleChange = GetComponent<AdvCharaStyleChange>();
			Model = GetComponent<AdvCharaModel>();
			Model.Setup(this);
			Transform transform = Transform.FindDeep(m_faceNodeName);
			m_faceRenderer = transform.GetComponent<SkinnedMeshRenderer>();
		}

		public void SetupNodes()
		{
		}

		public Transform GetNode(AdvCharaModel.Node node)
		{
			return node switch
			{
				AdvCharaModel.Node.Head => Head, 
				AdvCharaModel.Node.RightHand => RightHand, 
				AdvCharaModel.Node.LeftHand => LeftHand, 
				_ => Head, 
			};
		}

		public void Enable()
		{
			SetEnable(isEnable: true);
		}

		public void Disable()
		{
			SetEnable(isEnable: false);
		}

		public void SetEnable(bool isEnable)
		{
			m_isActive = isEnable;
			m_gameObject.SetActive(isEnable);
			m_wasVisible = isEnable;
			m_isVisible = isEnable;
		}

		public void AttachTo(Transform target, Vector3 offset, Vector3 rotation, Vector3 scale)
		{
			Transform.SetParent(target, worldPositionStays: false);
			Transform.localPosition = offset;
			Transform.localRotation = Quaternion.Euler(rotation);
			Transform.localScale = scale;
			m_isAttached = true;
		}

		public void Detach()
		{
			if (m_isAttached)
			{
				m_isAttached = false;
				Transform.SetParent(m_parent, worldPositionStays: false);
				Transform.localScale = Vector3.one;
			}
		}

		public void AttachMirroring(Vector3 scale, bool isMirroring, bool isTrackingHead)
		{
			if (!m_isAttached)
			{
				if (m_springManager != null)
				{
					m_springManager.enabled = !isMirroring;
				}
				Transform.localScale = scale;
				if (isMirroring && m_lookTarget != null)
				{
					m_lookTarget.IsPlayerMirrorAttach = isTrackingHead;
				}
				else
				{
					m_lookTarget.IsPlayerMirrorAttach = false;
				}
			}
		}

		public void DetachMirroring()
		{
			if (!m_isAttached)
			{
				Transform.localScale = Vector3.one;
				if (m_lookTarget != null)
				{
					m_lookTarget.IsPlayerMirrorAttach = false;
				}
				if (m_springManager != null)
				{
					m_springManager.enabled = true;
				}
			}
		}

		private void ResetSaftyFlags()
		{
			HasInitialLookAt = false;
			HasInitialMotion = false;
			HasInitialFacial = false;
		}

		public void OnEndSequence()
		{
			ResetSaftyFlags();
			if (!(m_gameObject == null))
			{
				if (m_lookTarget != null)
				{
					SetEnable(isEnable: true);
					SetForcus(isForcus: true);
					m_lookTarget.SetLookAtTransform(null, isSkip: true);
					m_lookTarget.UpdateLookAtProcess();
					m_lookTarget.IsUpdate = false;
					SetEnable(isEnable: false);
				}
				if (StyleChange != null)
				{
					StyleChange.CharaStyleChange(style: false);
				}
				OnNonForccus();
				DetachMirroring();
				Detach();
				Model.OnEndSequence();
				Disable();
			}
		}

		public void OnPlayVoice()
		{
			if (SingletonMonoBehaviour<CharactersManager>.Instance.IsLimitAnimatableChara && !IsForcused)
			{
				ReserveForcus(isForcusd: true);
			}
		}

		public void OnNonForccus()
		{
			if (SingletonMonoBehaviour<CharactersManager>.Instance.IsLimitAnimatableChara && IsForcused)
			{
				if (!base.Object.activeSelf)
				{
					IsForcused = false;
					return;
				}
				ReserveForcus(isForcusd: false);
				Model.SkipAnimation();
			}
		}

		public void ReserveForcus(bool isForcusd)
		{
			m_isForcusReserved = true;
			IsForcused = isForcusd;
		}

		private void SetForcusedComponentActive(bool isActive)
		{
			Model.Animator.enabled = isActive;
			if (m_springManager != null)
			{
				m_springManager.enabled = isActive;
			}
			if (m_lookTarget != null)
			{
				m_lookTarget.IsAnimatorEnable = isActive;
			}
		}

		public void SetForcus(bool isForcus)
		{
			IsForcused = isForcus;
			SetForcusedComponentActive(isForcus);
		}

		public void SetRootBoneActive(bool isActive)
		{
			IsRootBoneActive = isActive;
			if (m_boneRoot != null)
			{
				m_boneRoot.SetActive(isActive);
			}
		}

		public void OnAttachProp(DynamicProp prop, AdvCharaModel.Node node)
		{
			m_propsAttached[(int)node] = prop;
			SetRootBoneActive(isActive: true);
		}

		public void OnDettachProp(DynamicProp prop, AdvCharaModel.Node node)
		{
			if (m_propsAttached[(int)node] == prop)
			{
				m_propsAttached[(int)node] = null;
			}
			CheckDisableBoneRoot();
		}

		private void CheckDisableBoneRoot()
		{
			int num = m_propsAttached.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_propsAttached[i] != null)
				{
					return;
				}
			}
			SetRootBoneActive(isActive: false);
		}

		public void ApplySafetySettings()
		{
			if (base.IsActive)
			{
				if (!HasInitialMotion)
				{
					Model.PlayAnimation(100, isFade: false, !HasInitialFacial);
				}
				if (!HasInitialFacial && !GameDefine.IsShadow(ID))
				{
					Model.PlayAnimation(300, isFade: false, !HasInitialMotion);
				}
				if (!HasInitialLookAt && Look != null)
				{
					Look.SetLookAtTransform(null, isSkip: true);
					Look.BodyLookAtTrigger = true;
					Look.UpdateLookAtProcess();
				}
				else if (Look != null)
				{
					Look.BodyLookAtTrigger = true;
					Look.UpdateLookAtProcess();
				}
			}
		}
	}
	public class AdvCharaAnimation
	{
		public const int _INVALID_LAYER_ID = -1;

		public const string _PARAM_ID_STRING = "motion";

		public const string _PARAM_START_ANIMATION_STRING = "motionTrigger";

		public const string _PARAM_FACE_ID_STRING = "faceNo";

		public const string _PARAM_START_FACE_ANIMATION_STRING = "facialTrigger";

		private const string _LAYER_BASE = "Base Layer";

		private const string _LAYER_FACIAL = "Facial Layer";

		private const string _LAYER_HAIR = "Hair Layer";

		private Animator m_animator;

		private Transform m_transform;

		private int m_idParamIndex;

		private int m_startAnimationParamIndex;

		private int m_faceidParamIndex;

		private int m_faceStartAnimationParamIndex;

		private int m_layerFacial;

		private int m_layerHair;

		public int CurrentID { get; private set; }

		public AdvCharaAnimation(Animator animator, Transform transform)
		{
			CurrentID = 0;
			m_animator = animator;
			m_transform = transform;
			m_idParamIndex = Animator.StringToHash("motion");
			m_startAnimationParamIndex = Animator.StringToHash("motionTrigger");
			m_faceidParamIndex = Animator.StringToHash("faceNo");
			m_faceStartAnimationParamIndex = Animator.StringToHash("facialTrigger");
			m_layerFacial = m_animator.GetLayerIndex("Facial Layer");
			m_layerHair = m_animator.GetLayerIndex("Hair Layer");
			m_animator.keepAnimatorControllerStateOnDisable = true;
		}

		public void PlayAnimation(int id, bool isSkip = false)
		{
			CurrentID = id;
			if (IsFacialAnimation(id))
			{
				PlayFacialAnimation(id);
			}
			else
			{
				PlayBaseAnimation(id);
			}
			if (isSkip)
			{
				SkipAnimation();
			}
		}

		public static bool IsFacialAnimation(int id)
		{
			if (id >= 300)
			{
				return id < 400;
			}
			return false;
		}

		private void PlayFacialAnimation(int id)
		{
			m_animator.SetInteger(m_faceidParamIndex, id);
			m_animator.SetTrigger(m_faceStartAnimationParamIndex);
		}

		private void PlayBaseAnimation(int id)
		{
			m_animator.SetInteger(m_idParamIndex, id);
			m_animator.SetTrigger(m_startAnimationParamIndex);
			m_transform.localPosition = Vector3.zero;
			m_transform.localRotation = Quaternion.identity;
		}

		public void SkipAnimation()
		{
			if (m_animator.gameObject.activeInHierarchy)
			{
				m_animator.Update(100f);
				m_animator.Update(100f);
			}
			if (!IsInvalidLayer(m_layerHair))
			{
				ForceSkipLayerAnimation(m_layerHair);
				ForceSkipLayerAnimation(m_layerFacial);
			}
		}

		private void ForceSkipLayerAnimation(int layer)
		{
			AnimatorStateInfo currentAnimatorStateInfo = m_animator.GetCurrentAnimatorStateInfo(layer);
			m_animator.Play(currentAnimatorStateInfo.shortNameHash, layer, 0f);
		}

		private bool IsInvalidLayer(int layerID)
		{
			return layerID == -1;
		}

		public void PlayFacialAnimationWithAnimatorUpdate(string animationName)
		{
			m_animator.Play(animationName, m_layerFacial, 1f);
			SkipAnimation();
		}

		public void PlayAnimationWithAnimatorUpdate(string animationName)
		{
			m_transform.localPosition = Vector3.zero;
			m_transform.localRotation = Quaternion.identity;
			m_animator.Play(animationName, 0, 1f);
			SkipAnimation();
		}
	}
	public class AdvCharaHairControll : MonoBehaviour
	{
		private const string ANIMATION_MOTION_STR = "motion";

		protected int[] NkOmitMotionList = new int[2] { 143, 159 };

		[SerializeField]
		private Transform BodyTransform;

		[SerializeField]
		private Transform HeadTransform;

		[SerializeField]
		private Transform[] HairCenterTransforms;

		[SerializeField]
		private Transform[] HairRightTransforms;

		[SerializeField]
		private Transform[] HairLeftTransforms;

		private Vector3[] LastHairCenterRotation;

		private Vector3[] LastHairRightRotation;

		private Vector3[] LastHairLeftRotation;

		protected AdvChara Chara;

		[SerializeField]
		private float limitRotate;

		[SerializeField]
		private float[] aditionalValues;

		private float defaultBodyRotation;

		private void Start()
		{
			Chara = GetComponent<AdvChara>();
			_ = base.transform.forward;
			Vector3 forward = BodyTransform.forward;
			forward = base.transform.InverseTransformDirection(forward);
			Vector3Extension.Normalize(ref forward);
			defaultBodyRotation = Mathf.Atan2(x: new Vector2(forward.x, forward.z).Length(), y: forward.y) * 57.29578f;
			if (HairCenterTransforms != null)
			{
				LastHairCenterRotation = new Vector3[HairCenterTransforms.Length];
				for (int i = 0; i < HairCenterTransforms.Length; i++)
				{
					LastHairCenterRotation[i] = HairCenterTransforms[i].localRotation.eulerAngles;
				}
			}
			if (HairRightTransforms != null)
			{
				LastHairRightRotation = new Vector3[HairRightTransforms.Length];
				for (int j = 0; j < HairRightTransforms.Length; j++)
				{
					LastHairRightRotation[j] = HairRightTransforms[j].localRotation.eulerAngles;
				}
			}
			if (HairLeftTransforms != null)
			{
				LastHairLeftRotation = new Vector3[HairLeftTransforms.Length];
				for (int k = 0; k < HairLeftTransforms.Length; k++)
				{
					LastHairLeftRotation[k] = HairLeftTransforms[k].localRotation.eulerAngles;
				}
			}
		}

		public void SupportHairControll(bool isAnim)
		{
			if (CheckNkMotion())
			{
				return;
			}
			_ = BodyTransform.forward;
			Vector3 forward = HeadTransform.forward;
			forward = BodyTransform.InverseTransformDirection(forward);
			Vector3Extension.Normalize(ref forward);
			float num = Mathf.Atan2(x: new Vector2(forward.x, forward.z).Length(), y: forward.y) * 57.29578f;
			float num2 = Mathf.Atan2(forward.x, forward.z) * 57.29578f;
			num /= 2.5f;
			num2 /= 6f;
			if (HairCenterTransforms != null)
			{
				for (int i = 0; i < HairCenterTransforms.Length; i++)
				{
					Vector3 vector = LastHairCenterRotation[i];
					HairCenterTransforms[i].localRotation = Quaternion.Euler(vector.x - num / (float)(i + 1) - defaultBodyRotation, vector.y, vector.z);
				}
			}
			if (HairRightTransforms != null)
			{
				for (int j = 0; j < HairRightTransforms.Length; j++)
				{
					Vector3 vector2 = LastHairRightRotation[j];
					HairRightTransforms[j].localRotation = Quaternion.Euler(vector2.x + (0f - num + num2) / (float)(j + 1) - defaultBodyRotation, vector2.y, vector2.z);
				}
			}
			if (HairLeftTransforms != null)
			{
				for (int k = 0; k < HairLeftTransforms.Length; k++)
				{
					Vector3 vector3 = LastHairLeftRotation[k];
					HairLeftTransforms[k].localRotation = Quaternion.Euler(vector3.x + (0f - num - num2) / (float)(k + 1) - defaultBodyRotation, vector3.y, vector3.z);
				}
			}
		}

		private bool CheckNkMotion()
		{
			if (Chara.ID != GameDefine.CharaID.NIKAIDOU)
			{
				return false;
			}
			int integer = Chara.Model.Animator.GetInteger("motion");
			for (int i = 0; i < NkOmitMotionList.Length; i++)
			{
				if (NkOmitMotionList[i] == integer)
				{
					return true;
				}
			}
			return false;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create LookAt Morpth TargetData", fileName = "LookAtMorpthTargets")]
	public class AdvCharaLookAtMorpthTargetData : ScriptableObject
	{
		[Serializable]
		public class Data
		{
			public GameDefine.CharaID Chara;

			public int[] MorpthTargetIndex;
		}

		public Data[] DataList;

		public Data FindData(GameDefine.CharaID chara)
		{
			int num = DataList.Length;
			for (int i = 0; i < num; i++)
			{
				if (DataList[i].Chara == chara)
				{
					return DataList[i];
				}
			}
			return null;
		}
	}
	public class AdvCharaModel : UpdateableComponent
	{
		public enum AnimationMode
		{
			Pause,
			Action,
			None
		}

		public enum Node
		{
			Head,
			RightHand,
			LeftHand,
			Count
		}

		public const int _DEFAULT_MOTION_ID = 100;

		public const int _DEFAULT_FACIAL_ID = 300;

		public const float _DEFAULT_ALPHA = 0.2f;

		public const float _FADE_DURATION = 0.3f;

		public const float _OUTLINE_DURATION = 0.2f;

		public const float _MAX_FADE_ALPHA = 1f;

		public const float _MIN_FADE_ALPHA = 0.3f;

		protected const string _PARAM_ALPHA = "_Alpha";

		protected const string _PARAM_OUTLINE_SIZE = "_Outline";

		protected const string _PARAM_OUTLINE_COLOR = "_OutlineColor";

		private const int _HAIR_WAIT_FRAMES = 2;

		[SerializeField]
		private List<AdvCharaTextureData> m_textures;

		protected List<Material> m_originalMaterials = new List<Material>();

		protected List<Material> m_materials = new List<Material>();

		protected Tweener<float> m_alphaTweener;

		protected Tweener<float> m_threasholdTweener;

		protected Tweener<Color> m_ColorTweener;

		private Renderer[] m_renderers;

		private AdvCharaTextureData.TextureType m_currentTextureType;

		protected AdvCharaAnimation m_animation;

		protected GenericLookTargetIK m_lookTarget;

		protected AdvChara m_chara;

		protected float m_actionFadeDuration;

		protected float m_actionTargetAlpha;

		protected float m_actionStartAlpha;

		protected int m_actionID;

		protected bool m_actionFlag;

		protected Color m_actionColour;

		private Action m_onStartFadeEnd;

		private Action m_onEndFade;

		protected Action m_onAnimationWithFadeEndAction;

		protected Action m_onPingpongFadeStartEndAction;

		private Action m_onOutlineChangeColourFadeEnd;

		private Action m_onOutlineChangeSizeFadeEnd;

		private Action m_onOutlineChangeAllFadeEnd;

		private Action<long> m_onSkipHairUpdate;

		public Animator Animator { get; private set; }

		public bool IsFading => m_alphaTweener.IsActive;

		public bool IsOutlineSizeChanging => m_threasholdTweener.IsActive;

		public bool IsOutlineColorChanging => m_ColorTweener.IsActive;

		public int CurrentAnimationID => m_animation.CurrentID;

		public void Setup(AdvChara chara)
		{
			m_renderers = GetComponentsInChildren<Renderer>();
			AddMaterials(m_renderers);
			GetAdditionalMaterials();
			m_lookTarget = GetComponent<GenericLookTargetIK>();
			Transform child = base.transform.GetChild(0);
			Animator = child.GetComponent<Animator>();
			m_animation = new AdvCharaAnimation(Animator, child);
			m_alphaTweener = new Tweener<float>(Mathf.Lerp);
			m_threasholdTweener = new Tweener<float>(Mathf.Lerp);
			m_ColorTweener = new Tweener<Color>(Color.Lerp);
			m_chara = chara;
			InitializeActions();
			SetModelAlpha(0.3f);
		}

		private void InitializeActions()
		{
			CreateAnimationWithFadeAction();
			CreatePingpongFadeStartEndAction();
			m_onOutlineChangeColourFadeEnd = delegate
			{
				ChangeOutlineColourFromAction();
			};
			m_onOutlineChangeSizeFadeEnd = delegate
			{
				ChangeOutlineSizeFromAction();
			};
			m_onOutlineChangeAllFadeEnd = delegate
			{
				ChangeOutlineAllFromAction();
			};
			m_onSkipHairUpdate = delegate
			{
				m_lookTarget.UpdateLookAtProcess();
			};
		}

		protected virtual void CreateAnimationWithFadeAction()
		{
			m_onAnimationWithFadeEndAction = delegate
			{
				EnableAnimatorForFrame();
				PlayAnimationFromAction();
				StartFadeFromAction();
				SkipAnimationOnNonForcus();
			};
		}

		protected virtual void CreatePingpongFadeStartEndAction()
		{
			m_onPingpongFadeStartEndAction = delegate
			{
				PlayOnStartFadeEndAction();
				StartReverseAlphaTweenFromAction();
			};
		}

		private void PlayOnStartFadeEndAction()
		{
			if (m_onStartFadeEnd != null)
			{
				m_onStartFadeEnd();
				m_onStartFadeEnd = null;
			}
		}

		private void StartAlphaTweenFromAction()
		{
			m_alphaTweener.Start(1f, 0.3f, m_actionFadeDuration, m_onEndFade);
		}

		private void StartReverseAlphaTweenFromAction()
		{
			m_alphaTweener.Start(0.3f, 1f, m_actionFadeDuration, m_onEndFade);
		}

		private void ChangeOutlineColourFromAction()
		{
			StartOutlineColorChange(m_actionColour, 0f);
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void ChangeOutlineSizeFromAction()
		{
			StartOutlineSizeChange(m_actionStartAlpha, 0f);
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void ChangeOutlineAllFromAction()
		{
			StartOutlineColorChange(m_actionColour, 0f);
			StartOutlineSizeChange(m_actionStartAlpha, 0f);
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void PlayAnimationFromAction()
		{
			m_animation.PlayAnimation(m_actionID, m_actionFlag);
		}

		private void StartFadeFromAction()
		{
			StartFade(m_actionTargetAlpha, m_actionFadeDuration);
		}

		private void AddMaterials(Renderer[] renderers)
		{
			foreach (Renderer renderer in renderers)
			{
				Material[] sharedMaterials = renderer.sharedMaterials;
				Material[] array = new Material[sharedMaterials.Length];
				for (int j = 0; j < sharedMaterials.Length; j++)
				{
					Material material = sharedMaterials[j];
					int num = m_originalMaterials.IndexOf(material);
					Material material2 = null;
					if (num < 0)
					{
						m_originalMaterials.Add(material);
						material2 = new Material(material);
						m_materials.Add(material2);
					}
					else
					{
						material2 = m_materials[num];
					}
					array[j] = material2;
				}
				renderer.sharedMaterials = array;
			}
		}

		protected virtual void GetAdditionalMaterials()
		{
		}

		public override void OnUpdate(float delta)
		{
			if (m_alphaTweener.IsActive)
			{
				m_alphaTweener.Update(delta);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
			if (m_ColorTweener.IsActive)
			{
				m_ColorTweener.Update(delta);
				SetModelOutlineColor(m_ColorTweener.CurrentValue);
			}
			if (m_threasholdTweener.IsActive)
			{
				m_threasholdTweener.Update(delta);
				SetModelOutlineSize(m_threasholdTweener.CurrentValue);
			}
		}

		public virtual void SetModelAlpha(float alpha)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Alpha", alpha);
			}
		}

		public virtual void SetModelOutlineSize(float size)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Outline", size);
			}
		}

		public virtual void SetModelOutlineColor(Color color)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetColor("_OutlineColor", color);
			}
		}

		public virtual void StartFade(float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			if (IsFading)
			{
				m_alphaTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				m_alphaTweener.SetCurrentValue(targetAlpha);
				SetModelAlpha(targetAlpha);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_alphaTweener.Start(m_materials[0].GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
		}

		public void StartOutlineColorChange(Color targetColor, float duration = 0.2f, Action onTweenEnd = null)
		{
			if (IsOutlineColorChanging)
			{
				m_ColorTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				SetModelOutlineColor(targetColor);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_ColorTweener.Start(m_materials[0].GetColor("_OutlineColor"), targetColor, duration, onTweenEnd);
				SetModelOutlineColor(m_ColorTweener.CurrentValue);
			}
		}

		public void StartOutlineSizeChange(float targetSize, float duration = 0.2f, Action onTweenEnd = null)
		{
			if (IsOutlineSizeChanging)
			{
				m_threasholdTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				SetModelOutlineSize(targetSize);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_threasholdTweener.Start(m_materials[0].GetFloat("_Outline"), targetSize, duration, onTweenEnd);
				SetModelOutlineSize(m_threasholdTweener.CurrentValue);
			}
		}

		public void StartOutlineChangeWithFade(Color targetColor, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionTargetAlpha = 1f;
			m_actionFadeDuration = duration;
			m_actionColour = targetColor;
			StartFade(targetAlpha, duration, m_onOutlineChangeColourFadeEnd);
		}

		public void StartOutlineChangeWithFade(float targetSize, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionStartAlpha = targetSize;
			m_actionTargetAlpha = 1f;
			m_actionFadeDuration = duration;
			StartFade(targetAlpha, duration, m_onOutlineChangeSizeFadeEnd);
		}

		public void StartOutlineChangeWithFade(Color targetColor, float targetSize, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionStartAlpha = targetSize;
			m_actionTargetAlpha = 1f;
			m_actionColour = targetColor;
			m_actionFadeDuration = duration;
			StartFade(targetAlpha, duration, m_onOutlineChangeAllFadeEnd);
		}

		public void PlayPingPongFade(float targetAlpha, float duration = 0.3f, Action onStartFadeEnd = null, Action onFadeEnd = null)
		{
			PlayPingPongFade(m_alphaTweener.CurrentValue, targetAlpha, duration, onStartFadeEnd, onFadeEnd);
		}

		public void PlayPingPongFade(float startAlpha, float targetAlpha, float duration = 0.3f, Action onStartFadeEnd = null, Action onFadeEnd = null)
		{
			if (IsFading)
			{
				m_alphaTweener.AddAction(onStartFadeEnd);
				return;
			}
			m_actionStartAlpha = startAlpha;
			m_actionTargetAlpha = targetAlpha;
			m_actionFadeDuration = duration;
			m_onStartFadeEnd = onStartFadeEnd;
			m_onEndFade = onFadeEnd;
			m_alphaTweener.Start(startAlpha, targetAlpha, duration, m_onPingpongFadeStartEndAction);
			SetModelAlpha(m_alphaTweener.CurrentValue);
		}

		public virtual void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (isFade)
			{
				PlayAnimationWithFade(id, isSkipAnimation);
				return;
			}
			EnableAnimatorForFrame();
			m_animation.PlayAnimation(id, isSkipAnimation);
			SkipAnimationOnNonForcus();
		}

		public virtual void PlayAnimationWithFade(int id, bool isSkipAnimation, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionFlag = isSkipAnimation;
			m_actionID = id;
			m_actionFadeDuration = duration;
			m_actionTargetAlpha = 1f;
			StartFade(targetAlpha, duration, m_onAnimationWithFadeEndAction);
		}

		public void EnableAnimatorForFrame()
		{
			if (!m_chara.IsForcused)
			{
				m_chara.ReserveForcus(isForcusd: false);
				Animator.enabled = true;
			}
		}

		public void SkipAnimationOnNonForcus()
		{
			if (m_chara.IsForcused)
			{
				return;
			}
			m_animation.SkipAnimation();
			if (!(m_lookTarget == null))
			{
				if (m_lookTarget.HasHair)
				{
					Observable.TimerFrame(2).Subscribe(m_onSkipHairUpdate);
				}
				m_lookTarget.BodyLookAtTrigger = true;
			}
		}

		public void Hide()
		{
			SetRenderEnable(isEnable: false);
			base.IsActive = false;
		}

		public void Show()
		{
			SetRenderEnable(isEnable: true);
			base.IsActive = true;
		}

		public void SetRenderEnable(bool isEnable)
		{
			int num = m_renderers.Length;
			for (int i = 0; i < num; i++)
			{
				m_renderers[i].enabled = isEnable;
			}
		}

		public void SkipAnimation()
		{
			m_animation.SkipAnimation();
		}

		public void OnEndSequence()
		{
			SetModelOutlineSize(0.1f);
			SetModelOutlineColor(ColorDefine.OutlineDay);
		}

		public void SetTexture(AdvCharaTextureData.TextureType type)
		{
			if (m_textures != null && m_materials != null && type != m_currentTextureType)
			{
				Texture texture = FindTexture(type);
				if (!(texture == null))
				{
					SetTextureToMaterials(texture);
					m_currentTextureType = type;
				}
			}
		}

		private Texture FindTexture(AdvCharaTextureData.TextureType type)
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_textures[i].Type == type)
				{
					return m_textures[i].Texture;
				}
			}
			return null;
		}

		private void SetTextureToMaterials(Texture texture)
		{
			m_materials.ForEach(delegate(Material material)
			{
				material.mainTexture = texture;
			});
		}
	}
	public class AdvCharaModelPatty : AdvCharaModel
	{
		[SerializeField]
		private GameObject m_bodyObject;

		[SerializeField]
		private GameObject m_pattyObject;

		private Material m_bodyMaterial;

		private Material m_pattyMaterial;

		private int[] pattyShowMotionList = new int[21]
		{
			102, 104, 109, 114, 115, 119, 120, 121, 122, 123,
			126, 127, 128, 134, 138, 139, 140, 141, 153, 154,
			155
		};

		public const float _FADE_PATTY_DURATION = 0.05f;

		protected override void GetAdditionalMaterials()
		{
			m_bodyMaterial = m_bodyObject.GetComponent<SkinnedMeshRenderer>().sharedMaterial;
			m_pattyMaterial = m_pattyObject.GetComponent<SkinnedMeshRenderer>().sharedMaterial;
		}

		protected override void CreateAnimationWithFadeAction()
		{
			m_onAnimationWithFadeEndAction = delegate
			{
				if (!m_chara.IsForcused)
				{
					m_chara.ReserveForcus(isForcusd: false);
					base.Animator.enabled = true;
				}
				m_animation.PlayAnimation(m_actionID, m_actionFlag);
				SetPattyEnable(m_actionID);
				StartFade(1f, m_actionID, m_actionFadeDuration);
				if (!m_chara.IsForcused)
				{
					m_animation.SkipAnimation();
					m_lookTarget.BodyLookAtTrigger = true;
				}
			};
		}

		public void StartPattyFade(float targetAlpha, float duration = 0.05f, Action onTweenEnd = null)
		{
			if (base.IsFading)
			{
				m_alphaTweener.AddAction(onTweenEnd);
				return;
			}
			m_alphaTweener.Start(m_pattyMaterial.GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
			SetModelAlpha(m_alphaTweener.CurrentValue);
		}

		public void SetPattyModelAlpha(float alpha)
		{
			m_pattyMaterial.SetFloat("_Alpha", alpha);
		}

		public override void PlayAnimation(int id, bool isFade, bool isSkipAnimation)
		{
			if (isFade)
			{
				PlayAnimationWithFade(id, isSkipAnimation);
				return;
			}
			SetPattyEnable(id);
			m_animation.PlayAnimation(id, isSkipAnimation);
		}

		public override void PlayAnimationWithFade(int id, bool isSkipAnimation, float targetAlpha = 0.2f, float duration = 0.3f)
		{
			m_actionFlag = isSkipAnimation;
			m_actionID = id;
			m_actionFadeDuration = duration;
			m_actionTargetAlpha = 1f;
			StartFade(targetAlpha, id, duration, m_onAnimationWithFadeEndAction);
		}

		public void StartFade(float targetAlpha, int id, float duration = 0.3f, Action onTweenEnd = null)
		{
			if (base.IsFading)
			{
				m_alphaTweener.AddAction(onTweenEnd);
			}
			else if (duration <= 0f)
			{
				SetModelAlpha(targetAlpha);
				onTweenEnd?.Invoke();
			}
			else
			{
				m_alphaTweener.Start(m_bodyMaterial.GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
				SetModelAlpha(m_alphaTweener.CurrentValue, id);
			}
		}

		public void SetModelAlpha(float alpha, int id)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Alpha", alpha);
			}
			SetPattyEnable(id);
		}

		private void SetPattyEnable(int id)
		{
			if (id < 300 || id >= 400)
			{
				bool flag = CheckPattyEnable(id);
				if (flag)
				{
					SetPattyModelAlpha(m_bodyMaterial.GetFloat("_Alpha"));
				}
				else
				{
					SetPattyModelAlpha(0f);
				}
				m_pattyObject.SetActive(flag);
			}
		}

		private bool CheckPattyEnable(int id)
		{
			int num = pattyShowMotionList.Length;
			for (int i = 0; i < num; i++)
			{
				if (id == pattyShowMotionList[i])
				{
					return true;
				}
			}
			return false;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create Morpth TargetData", fileName = "MorpthTargets")]
	public class AdvCharaMorpthTargetData : ScriptableObject
	{
		[Serializable]
		public class Data
		{
			public GameDefine.CharaID Chara;

			public int[] MorpthTargetIndex;
		}

		public Data[] DataList;

		public Data FindData(GameDefine.CharaID chara)
		{
			int num = DataList.Length;
			for (int i = 0; i < num; i++)
			{
				if (DataList[i].Chara == chara)
				{
					return DataList[i];
				}
			}
			return null;
		}
	}
	public class AdvCharaOffCameraDisabler : MonoBehaviour
	{
		[SerializeField]
		private List<GameObject> m_diableObjectTargets;

		[SerializeField]
		private List<MonoBehaviour> m_disableComponetTargets;

		public bool IsVisible { get; private set; }

		private void Start()
		{
			IsVisible = true;
		}

		private void OnBecameVisible()
		{
			IsVisible = true;
		}

		private void OnBecameInvisible()
		{
			IsVisible = false;
		}

		public void SetActive(bool isActive)
		{
		}

		public void SetEnables(bool isEnabled)
		{
			int count = m_disableComponetTargets.Count;
			for (int i = 0; i < count; i++)
			{
				m_disableComponetTargets[i].enabled = isEnabled;
			}
			count = m_diableObjectTargets.Count;
			for (int j = 0; j < count; j++)
			{
				m_diableObjectTargets[j].SetActive(isEnabled);
			}
		}
	}
	public class AdvCharaStyleChange : MonoBehaviour
	{
		[Serializable]
		private struct ChangeBlendShapes
		{
			public SkinnedMeshRenderer skinnedMesh;

			public int blendShapeId;

			public bool reverse;

			public ChangeBlendShapes(SkinnedMeshRenderer renderer, int id, bool rev)
			{
				skinnedMesh = renderer;
				blendShapeId = id;
				reverse = rev;
			}
		}

		[SerializeField]
		private ChangeBlendShapes[] ChangeParams;

		[SerializeField]
		private SkinnedMeshRenderer[] SwitchSkinnedMeshs;

		private bool isChangeStyle;

		private void LateUpdate()
		{
			if (isChangeStyle && ChangeParams != null)
			{
				for (int i = 0; i < ChangeParams.Length; i++)
				{
					int num = 0;
					num = ((!ChangeParams[i].reverse) ? ((!isChangeStyle) ? 100 : 0) : (isChangeStyle ? 100 : 0));
					ChangeParams[i].skinnedMesh.SetBlendShapeWeight(ChangeParams[i].blendShapeId, num);
				}
			}
		}

		public void CharaStyleChange(bool style)
		{
			if (SwitchSkinnedMeshs != null)
			{
				for (int i = 0; i < SwitchSkinnedMeshs.Length; i++)
				{
					SwitchSkinnedMeshs[i].enabled = !style;
				}
			}
			if (ChangeParams != null)
			{
				for (int j = 0; j < ChangeParams.Length; j++)
				{
					int num = 0;
					num = ((!ChangeParams[j].reverse) ? ((!style) ? 100 : 0) : (style ? 100 : 0));
					ChangeParams[j].skinnedMesh.SetBlendShapeWeight(ChangeParams[j].blendShapeId, num);
				}
				isChangeStyle = style;
			}
		}
	}
	[Serializable]
	public class AdvCharaTextureData
	{
		public enum TextureType
		{
			Normal,
			Night,
			Room,
			Mono,
			Blood,
			BloodDark,
			MAX
		}

		public Texture Texture;

		public TextureType Type;
	}
	[Serializable]
	public class AdvCharaTextureSettings
	{
		[Serializable]
		public class UniqueSetting
		{
			public GameDefine.CharaID Chara = GameDefine.CharaID.NIKAIDOU;

			public AdvCharaTextureData.TextureType Type;
		}

		public AdvCharaTextureData.TextureType CharaTextureType;

		public List<UniqueSetting> Exceptions;

		public UniqueSetting FindExceptionSettings(GameDefine.CharaID chara)
		{
			if (Exceptions == null)
			{
				return null;
			}
			int count = Exceptions.Count;
			for (int i = 0; i < count; i++)
			{
				if (Exceptions[i].Chara == chara)
				{
					return Exceptions[i];
				}
			}
			return null;
		}

		public bool IsInException(GameDefine.CharaID chara)
		{
			if (Exceptions == null)
			{
				return false;
			}
			int count = Exceptions.Count;
			for (int i = 0; i < count; i++)
			{
				if (Exceptions[i].Chara == chara)
				{
					return true;
				}
			}
			return false;
		}
	}
	public class AdvCopyLipSync : MonoBehaviour
	{
		[SerializeField]
		private AdvCharaMorpthTargetData MorpthTargetData;

		private AdvCharaMorpthTargetData.Data AdvCharaMorpthData;

		[SerializeField]
		private SkinnedMeshRenderer skinnedMesh;

		private SkinnedMeshRenderer BaseSkinnedMesh;

		private AdvChara BaseChara;

		[SerializeField]
		private GameDefine.CharaID BaseCharaID = GameDefine.CharaID.BASE;

		private void Start()
		{
			skinnedMesh = GetComponent<AdvChara>().FaceRenderer;
			BaseChara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(BaseCharaID);
			if (BaseChara != null)
			{
				BaseSkinnedMesh = BaseChara.FaceRenderer;
			}
			AdvCharaMorpthData = MorpthTargetData.FindData(BaseCharaID);
		}

		private void LateUpdate()
		{
			if (BaseChara.Model.IsActive)
			{
				for (int i = 10; i <= 14; i++)
				{
					skinnedMesh.SetBlendShapeWeight(AdvCharaMorpthData.MorpthTargetIndex[i], BaseSkinnedMesh.GetBlendShapeWeight(AdvCharaMorpthData.MorpthTargetIndex[i]));
				}
			}
		}
	}
	public class CharactersManager : SingletonMonoBehaviour<CharactersManager>
	{
		[Serializable]
		public class Data
		{
			public AdvChara CharaPrefab;

			public GameDefine.CharaID ID;
		}

		private const string _PATH_PREFAB = "Prefabs/Characters/{0}";

		public const int _FORCUS_CHARA_COUNT = 2;

		private const bool IS_APPLY_ANIMATION_LIMIT = true;

		[SerializeField]
		private List<Data> m_charaPrefabList;

		private List<AdvChara> m_characters;

		private List<GameDefine.CharaID> m_lastVoiceCharas;

		private int m_voiceCharaCount;

		public Transform m_transform;

		public bool IsLimitAnimatableChara { get; set; }

		public bool IsIgnoreAnimationLimit { get; set; }

		protected override void InitializeOnAwake()
		{
			base.InitializeOnAwake();
			IsIgnoreAnimationLimit = false;
			IsLimitAnimatableChara = true;
			m_transform = base.transform;
			m_characters = new List<AdvChara>(10);
			m_voiceCharaCount = 0;
			m_lastVoiceCharas = new List<GameDefine.CharaID>(2);
			for (int i = 0; i < 2; i++)
			{
				m_lastVoiceCharas.Add(GameDefine.CharaID.BASE);
			}
			LoadCharaAtStart();
		}

		private void LoadCharaAtStart()
		{
			int count = m_charaPrefabList.Count;
			for (int i = 0; i < count; i++)
			{
				LoadChara(m_charaPrefabList[i].ID, m_charaPrefabList[i].CharaPrefab);
			}
		}

		public AdvChara LoadChara(GameDefine.CharaID id, AdvChara prefab)
		{
			if (prefab == null)
			{
				return null;
			}
			AdvChara advChara = UnityEngine.Object.Instantiate(prefab, m_transform, worldPositionStays: false);
			advChara.Setup(id);
			m_characters.Add(advChara);
			return advChara;
		}

		public void RemoveChara(GameDefine.CharaID id)
		{
			AdvChara chara = GetChara(id);
			if (!(chara == null))
			{
				m_characters.Remove(chara);
				UnityEngine.Object.Destroy(chara.gameObject);
				chara = null;
				Resources.UnloadUnusedAssets();
			}
		}

		public AdvChara GetChara(GameDefine.CharaID id)
		{
			if (GameDefine.IsUnknownChara(id))
			{
				id = GameDefine.UnknownToCharaID(id);
			}
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_characters[i].ID == id)
				{
					return m_characters[i];
				}
			}
			return null;
		}

		public void AddActiveCharaToList(List<AdvChara> list)
		{
			int count = m_charaPrefabList.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = GetChara(m_charaPrefabList[i].ID);
				if (!(chara == null) && chara.IsActive)
				{
					list.Add(chara);
				}
			}
		}

		public void OnEndSequence()
		{
			IsLimitAnimatableChara = true;
			IsIgnoreAnimationLimit = false;
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				m_characters[i].OnEndSequence();
			}
			ResetEndVoiceSequence();
		}

		private void ResetEndVoiceSequence()
		{
			for (int i = 0; i < m_voiceCharaCount; i++)
			{
				m_lastVoiceCharas[i] = GameDefine.CharaID.BASE;
			}
			m_voiceCharaCount = 0;
		}

		public void SetupInitialTalkCharaForcus(List<GameDefine.CharaID> list)
		{
			ResetEndVoiceSequence();
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = GetChara(list[i]);
				if (!(chara == null))
				{
					chara.OnPlayVoice();
					m_lastVoiceCharas[m_voiceCharaCount++] = list[i];
				}
			}
		}

		public void OnPlayVoice(GameDefine.CharaID chara)
		{
			if (IsLimitAnimatableChara && !IsCurrentChara(chara))
			{
				CheckLastSpeakRecords(chara);
				int count = m_characters.Count;
				for (int i = 0; i < count; i++)
				{
					ApplyOnSpeakForcus(chara, m_characters[i]);
				}
				m_lastVoiceCharas[m_voiceCharaCount++] = chara;
			}
		}

		private void CheckLastSpeakRecords(GameDefine.CharaID chara)
		{
			if (m_lastVoiceCharas.Count >= 2)
			{
				int index = -1;
				if (IsContainCharaInLastVoice(chara, ref index))
				{
					RemoveIndexFromCharaList(index);
				}
				else
				{
					RemoveFirstCharaFromVoiceList();
				}
			}
		}

		private void RemoveIndexFromCharaList(int index)
		{
			bool flag = false;
			int count = m_lastVoiceCharas.Count;
			for (int i = index; i < count - 1; i++)
			{
				m_lastVoiceCharas[i] = m_lastVoiceCharas[i + 1];
				flag = true;
			}
			if (!flag)
			{
				m_lastVoiceCharas[index] = GameDefine.CharaID.BASE;
			}
			m_voiceCharaCount = Mathf.Max(0, m_voiceCharaCount - 1);
		}

		private void RemoveFirstCharaFromVoiceList()
		{
			int count = m_lastVoiceCharas.Count;
			for (int i = 0; i < count - 1; i++)
			{
				m_lastVoiceCharas[i] = m_lastVoiceCharas[i + 1];
			}
			m_voiceCharaCount = Mathf.Max(0, m_voiceCharaCount - 1);
		}

		public void SetAnimationLimitation(bool isLimit)
		{
			IsLimitAnimatableChara = isLimit;
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				m_characters[i].SetForcus(!isLimit);
			}
		}

		private void ApplyOnSpeakForcus(GameDefine.CharaID speakChara, AdvChara chara)
		{
			if (!IsContainCharaInLastVoice(chara.ID))
			{
				if (chara.ID == speakChara)
				{
					chara.OnPlayVoice();
				}
				else
				{
					chara.OnNonForccus();
				}
			}
		}

		private bool IsContainCharaInLastVoice(GameDefine.CharaID id)
		{
			int count = m_lastVoiceCharas.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_lastVoiceCharas[i] == id)
				{
					return true;
				}
			}
			return false;
		}

		private bool IsContainCharaInLastVoice(GameDefine.CharaID id, ref int index)
		{
			int count = m_lastVoiceCharas.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_lastVoiceCharas[i] == id)
				{
					index = i;
					return true;
				}
			}
			return false;
		}

		public static bool IsCurrentChara(GameDefine.CharaID chara)
		{
			if (chara != GameDefine.CharaID.BASE)
			{
				return chara == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID;
			}
			return true;
		}

		public void SetCharaTextures(AdvCharaTextureSettings settings)
		{
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				AdvCharaTextureSettings.UniqueSetting uniqueSetting = settings.FindExceptionSettings(m_characters[i].ID);
				if (uniqueSetting == null)
				{
					m_characters[i].Model.SetTexture(settings.CharaTextureType);
				}
				else
				{
					m_characters[i].Model.SetTexture(uniqueSetting.Type);
				}
			}
		}

		public void OnPrepareFistFade(List<GameDefine.CharaID> list, bool isMemoryMode)
		{
			Observable.NextFrame().Subscribe(delegate
			{
				_ApplyFirstFadeSettings(list, isMemoryMode);
			});
		}

		private void _ApplyFirstFadeSettings(List<GameDefine.CharaID> list, bool isMemoryMode)
		{
			bool flag = !IsIgnoreAnimationLimit && !isMemoryMode;
			int count = m_characters.Count;
			for (int i = 0; i < count; i++)
			{
				m_characters[i].ApplySafetySettings();
				if (flag)
				{
					m_characters[i].SetForcus(isForcus: false);
				}
			}
			if (flag)
			{
				IsLimitAnimatableChara = true;
				SetupInitialTalkCharaForcus(list);
			}
		}
	}
	public static class CharaDefine
	{
		public const int FACIAL_START = 300;

		public const int FACIAL_END = 400;
	}
	public class FaceAnimationManager : MonoBehaviour
	{
		private Animator animator;

		public const string BLINK_TRIGGER_NAME = "blinkTrigger";

		public const string BLINK_PARAM_NAME = "blinkNo";

		private float m_BlinkTimer;

		private float m_NextBlink;

		private void Start()
		{
			animator = GetComponentInChildren<Animator>();
			m_BlinkTimer = 0f;
			m_NextBlink = UnityEngine.Random.Range(4f, 10f);
		}

		private void Update()
		{
			m_BlinkTimer += Time.deltaTime;
			if (m_BlinkTimer > m_NextBlink)
			{
				m_BlinkTimer = 0f;
				if ((double)UnityEngine.Random.Range(0f, 1f) > 0.3)
				{
					StartBlinkEye();
					m_NextBlink = UnityEngine.Random.Range(5.5f, 10f);
				}
			}
		}

		public void StartBlinkEye()
		{
			if ((double)UnityEngine.Random.Range(0f, 1f) > 0.08)
			{
				animator.SetInteger("blinkNo", 0);
			}
			else
			{
				animator.SetInteger("blinkNo", 1);
			}
			animator.SetTrigger("blinkTrigger");
		}
	}
	public class GenericLookTargetIK : MonoBehaviour
	{
		public struct WaightFreeze
		{
			public bool fleezeHeadWaight;

			public bool fleezeNeckWaight;

			public bool fleezeBodyWaight;

			public WaightFreeze(bool head, bool neck, bool body)
			{
				fleezeHeadWaight = head;
				fleezeNeckWaight = neck;
				fleezeBodyWaight = body;
			}
		}

		public struct WaightSettingData
		{
			public float headWaight;

			public float neckWaight;

			public float bodyWaight;

			public WaightSettingData(float head, float neck, float body)
			{
				headWaight = head;
				neckWaight = neck;
				bodyWaight = body;
			}
		}

		public static readonly WaightFreeze WaightFreezeAll = new WaightFreeze(head: true, neck: true, body: true);

		public static readonly WaightFreeze WaightFreezeNone = new WaightFreeze(head: false, neck: false, body: false);

		[SerializeField]
		private AdvCharaLookAtMorpthTargetData LookAtMorpthTargetData;

		private AdvCharaLookAtMorpthTargetData.Data MorpthTargetList;

		private Animator animator;

		private FaceAnimationManager faceAnimator;

		[SerializeField]
		public Transform m_HeadTransform;

		[SerializeField]
		public Transform m_NeckTransform;

		[SerializeField]
		public Transform m_bodyTransform;

		[SerializeField]
		private Transform lookAtObject;

		[SerializeField]
		private bool isChangeTarget;

		[SerializeField]
		private float m_ChangeTime = 1f;

		private float changeTimer;

		private float timer;

		private float rand;

		[SerializeField]
		private Transform LeftEyeTransform;

		[SerializeField]
		private Transform RightEyeTransform;

		private Vector3 defaultRotateL;

		private Quaternion defaultRotateLQuaternion;

		private Quaternion defaultRotateRQuaternion;

		[SerializeField]
		private float EyeLinitYMax = 30f;

		[SerializeField]
		private float EyeLimitYMin = -22f;

		[SerializeField]
		private float EyeLinitXInside = 35f;

		[SerializeField]
		private float EyeLimitXOutside = -35f;

		private Transform TargetTransform;

		private Transform NextTargetTransform;

		private Vector3 TargetPosition;

		[SerializeField]
		private Vector3 m_NextTargetPosition;

		private Vector3 m_OldTargetPosition;

		[SerializeField]
		private Transform m_DefaultLookTarget;

		private Transform m_transform;

		private Transform m_calculationTransform;

		[SerializeField]
		private SkinnedMeshRenderer faceMesh;

		[SerializeField]
		private GameDefine.CharaID m_id = GameDefine.CharaID.BASE;

		private string mLookupFaceMeshR;

		private string mLookupFaceMeshL;

		private string mLookdownFaceMeshR;

		private string mLookdownFaceMeshL;

		private string mLookdownTopFaceMeshR;

		private string mLookdownTopFaceMeshL;

		[SerializeField]
		[Range(0f, 100f)]
		private float mDefaultHeadWaight;

		[SerializeField]
		[Range(0f, 100f)]
		private float mDefaultNeckWaight;

		[SerializeField]
		[Range(0f, 100f)]
		private float mDefaultBodyWaight;

		[SerializeField]
		private float m_blinkWaitDuration = 0.005f;

		[SerializeField]
		private bool m_IsEyeLookAt = true;

		private float mWaightTimer;

		private float mWaightChangeTime = 1f;

		private bool isWaightChange;

		private float mHeadWaight;

		private float mNeckWaight;

		private float mBodyWaight;

		private float mNextHeadWaight;

		private float mNextNeckWaight;

		private float mNextBodyWaight;

		private float mLastHeadWaight;

		private float mLastNeckWaight;

		private float mLastBodyWaight;

		private bool mIsHeadWaightFreeze;

		private bool mIsNeckWaightFreeze;

		private bool mIsBodyWaightFreeze;

		private Quaternion lastHeadRotate;

		private Quaternion lastNeckRotate;

		private Quaternion lastBodyRotate;

		private AdvCharaHairControll HairController;

		private Quaternion m_tempLookRotation = QuaternionExtension.IDENTITY;

		private Quaternion m_tempPartsRotation = QuaternionExtension.IDENTITY;

		private TimeSpan m_blinkWaitTimeSpan;

		private Action<long> m_onBlinkWaitEndAction;

		public bool BodyLookAtTrigger { get; set; }

		public bool IsAnimatorEnable { get; set; }

		public bool IsPlayerMirrorAttach { get; set; }

		public bool IsUpdate { get; set; }

		public bool HasHair => HairController != null;

		private void Start()
		{
			m_transform = base.transform;
			SetupCalculationTransform(ref m_calculationTransform);
			faceAnimator = GetComponentInChildren<FaceAnimationManager>();
			m_OldTargetPosition = m_DefaultLookTarget.position;
			m_NextTargetPosition = m_OldTargetPosition;
			TargetTransform = m_DefaultLookTarget;
			TargetPosition = m_OldTargetPosition;
			IsUpdate = true;
			isChangeTarget = false;
			defaultRotateLQuaternion = LeftEyeTransform.localRotation;
			defaultRotateRQuaternion = RightEyeTransform.localRotation;
			defaultRotateL = defaultRotateLQuaternion.eulerAngles;
			MorpthTargetList = LookAtMorpthTargetData.FindData(m_id);
			mIsHeadWaightFreeze = false;
			mIsNeckWaightFreeze = false;
			mIsBodyWaightFreeze = false;
			mHeadWaight = mDefaultHeadWaight;
			mNeckWaight = mDefaultNeckWaight;
			mBodyWaight = mDefaultBodyWaight;
			IsPlayerMirrorAttach = false;
			IsAnimatorEnable = true;
			BodyLookAtTrigger = false;
			lastHeadRotate = m_HeadTransform.localRotation;
			lastNeckRotate = m_NeckTransform.localRotation;
			lastBodyRotate = m_bodyTransform.localRotation;
			HairController = GetComponent<AdvCharaHairControll>();
			m_blinkWaitTimeSpan = TimeSpan.FromSeconds(m_blinkWaitDuration);
			m_onBlinkWaitEndAction = delegate
			{
				OnEndChangeEyeTarget();
			};
		}

		private void SetupCalculationTransform(ref Transform target)
		{
			GameObject gameObject = new GameObject();
			gameObject.SetActive(value: false);
			target = gameObject.transform;
			target.SetParent(m_transform);
		}

		private void Update()
		{
			if (isWaightChange && mWaightChangeTime > 0f)
			{
				mWaightTimer += Time.deltaTime;
				mHeadWaight = Mathf.Lerp(mLastHeadWaight, mNextHeadWaight, mWaightTimer / mWaightChangeTime);
				mNeckWaight = Mathf.Lerp(mLastNeckWaight, mNextNeckWaight, mWaightTimer / mWaightChangeTime);
				mBodyWaight = Mathf.Lerp(mLastBodyWaight, mNextBodyWaight, mWaightTimer / mWaightChangeTime);
				if (mWaightTimer > mWaightChangeTime)
				{
					mLastHeadWaight = mNextHeadWaight;
					mLastNeckWaight = mNextNeckWaight;
					mLastBodyWaight = mNextBodyWaight;
					isWaightChange = false;
				}
			}
		}

		private void LateUpdate()
		{
			if (!IsUpdate)
			{
				UpdateHairControl();
			}
			else
			{
				UpdateLookAtProcess();
			}
		}

		public void UpdateLookAtProcess()
		{
			Vector3 lookAtPosition = Vector3.zero;
			RecordLastRotation();
			UpdateLookAt(ref lookAtPosition);
			UpdateChangeLookAt(ref lookAtPosition);
			UpdateHairControl();
		}

		private void RecordLastRotation()
		{
			if (IsAnimatorEnable || BodyLookAtTrigger)
			{
				lastHeadRotate = m_HeadTransform.localRotation;
				lastNeckRotate = m_NeckTransform.localRotation;
				lastBodyRotate = m_bodyTransform.localRotation;
			}
		}

		private void UpdateLookAt(ref Vector3 lookAtPosition)
		{
			if (isChangeTarget)
			{
				if (NextTargetTransform != null)
				{
					TargetPosition = NextTargetTransform.position;
				}
				changeTimer += Time.deltaTime;
				lookAtPosition = Vector3.Lerp(lookAtObject.position, TargetPosition, changeTimer / m_ChangeTime);
				GenericLookAtAnimation(ref lookAtPosition);
				if (changeTimer / m_ChangeTime >= 1f)
				{
					TargetTransform = NextTargetTransform;
					isChangeTarget = false;
				}
			}
			else
			{
				if (TargetTransform != null)
				{
					TargetPosition = TargetTransform.position;
				}
				lookAtPosition = TargetPosition;
				GenericLookAtAnimation(ref lookAtPosition);
			}
			lookAtObject.position = lookAtPosition;
		}

		private void UpdateChangeLookAt(ref Vector3 lookAtPosition)
		{
			if (m_NextTargetPosition != m_OldTargetPosition)
			{
				Vector3 b = m_HeadTransform.position;
				Vector3 a = m_NextTargetPosition;
				Vector3 from = Vector3Extension.Subtract(ref a, ref b);
				Vector3 to = Vector3Extension.Subtract(ref lookAtPosition, ref b);
				float num = Vector3.Angle(from, to);
				StartChangeLookAt(num >= 60f);
			}
		}

		public void UpdateHairControl()
		{
			if (HairController != null)
			{
				HairController.SupportHairControll(IsAnimatorEnable || BodyLookAtTrigger);
			}
		}

		private void StartChangeLookAt(bool isBlinkFlag)
		{
			if (isBlinkFlag && IsAnimatorEnable)
			{
				faceAnimator.StartBlinkEye();
			}
			ChangeEyeTarget(isBlinkFlag);
		}

		private void ChangeEyeTarget(bool isBlinkFlag)
		{
			m_OldTargetPosition = m_NextTargetPosition;
			if (isBlinkFlag)
			{
				Observable.Timer(m_blinkWaitTimeSpan).Subscribe(m_onBlinkWaitEndAction);
			}
			else
			{
				OnEndChangeEyeTarget();
			}
		}

		private void OnEndChangeEyeTarget()
		{
			isChangeTarget = true;
			changeTimer = 0f;
			TargetPosition = m_NextTargetPosition;
		}

		private void GenericLookAtAnimation(ref Vector3 lookAtPosition)
		{
			if (!IsAnimatorEnable && !BodyLookAtTrigger)
			{
				m_bodyTransform.localRotation = lastBodyRotate;
				m_NeckTransform.localRotation = lastNeckRotate;
				m_HeadTransform.localRotation = lastHeadRotate;
			}
			BodyLookAtTrigger = false;
			RotateHeadParts(m_bodyTransform, mBodyWaight, ref lookAtPosition);
			RotateHeadParts(m_NeckTransform, mNeckWaight, ref lookAtPosition);
			RotateHeadParts(m_HeadTransform, mHeadWaight, ref lookAtPosition);
			if (IsPlayerMirrorAttach)
			{
				float num = MainPosition.CameraTransform.rotation.eulerAngles.y;
				if (Mathf.Abs(num) > 180f)
				{
					float num2 = num % 180f;
					num = ((!(num2 >= 0f)) ? (num2 + 180f) : (num2 - 180f));
				}
				m_bodyTransform.Rotate(Vector3.up, (0f - num) / 2f);
				m_HeadTransform.Rotate(Vector3.up, (0f - num) / 2f);
			}
			timer += Time.deltaTime;
			if (timer >= 4f)
			{
				timer = 0f;
				if (UnityEngine.Random.value > 0.2f)
				{
					rand = (UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f) + UnityEngine.Random.Range(-1f, 1f)) / 5f;
				}
			}
			if (!m_IsEyeLookAt)
			{
				LeftEyeTransform.localRotation = defaultRotateLQuaternion;
				RightEyeTransform.localRotation = defaultRotateRQuaternion;
				return;
			}
			Vector3 inverseHeadLookAt = m_HeadTransform.InverseTransformDirection(lookAtPosition);
			CalculateEyeRotation(LeftEyeTransform, ref inverseHeadLookAt, EyeLimitXOutside, EyeLinitXInside);
			float rotateY = CalculateEyeRotation(RightEyeTransform, ref inverseHeadLookAt, 0f - EyeLinitXInside, 0f - EyeLimitXOutside);
			LookingMorph(rotateY);
		}

		private void RotateHeadParts(Transform parts, float weight, ref Vector3 lookAtPosition)
		{
			if (weight != 0f)
			{
				Vector3 position = parts.position;
				QuaternionExtension.CreateLookAt(ref position, ref lookAtPosition, ref m_tempLookRotation);
				m_tempPartsRotation = parts.rotation;
				m_tempPartsRotation = Quaternion.Slerp(m_tempPartsRotation, m_tempLookRotation, weight / 100f);
				parts.rotation = m_tempPartsRotation;
			}
		}

		private float CalculateEyeRotation(Transform eye, ref Vector3 inverseHeadLookAt, float eyeLimitOutside, float eyeLimitInside)
		{
			Vector3 b = m_HeadTransform.InverseTransformDirection(eye.position);
			Vector3 v = Vector3Extension.Subtract(ref inverseHeadLookAt, ref b);
			Vector3Extension.Normalize(ref v);
			float num = Mathf.Clamp(Mathf.Atan2(x: new Vector2(v.x, v.z).Length(), y: v.y) * 57.29578f + rand, EyeLimitYMin, EyeLinitYMax);
			float num2 = Mathf.Clamp(Mathf.Atan2(v.x, v.z) * 57.29578f + rand, eyeLimitOutside, eyeLimitInside);
			eye.localRotation = Quaternion.Euler(defaultRotateL.x + num, defaultRotateL.y + num2, defaultRotateL.z);
			return num;
		}

		private float ChangeEffectiveValue(float rotate)
		{
			if (rotate > 180f)
			{
				rotate -= 360f;
			}
			else if (rotate < -180f)
			{
				rotate += 360f;
			}
			return rotate;
		}

		public void SetLookAtTransform(Transform lookat, bool isSkip)
		{
			if (lookat != null)
			{
				if (TargetTransform != lookat)
				{
					changeTimer = 0f;
					NextTargetTransform = lookat;
					m_NextTargetPosition = lookat.position;
					TargetTransform = null;
				}
			}
			else
			{
				changeTimer = 0f;
				NextTargetTransform = m_DefaultLookTarget;
				m_NextTargetPosition = m_DefaultLookTarget.position;
				TargetTransform = null;
			}
			if (isSkip)
			{
				TargetPosition = m_NextTargetPosition;
				lookAtObject.position = m_NextTargetPosition;
			}
		}

		public void SetLookAtPosition(Vector3 lookAtPosition, bool isSkip)
		{
			if (m_NextTargetPosition != lookAtPosition)
			{
				changeTimer = 0f;
				TargetTransform = null;
				NextTargetTransform = null;
				m_NextTargetPosition = lookAtPosition;
			}
			if (isSkip)
			{
				TargetPosition = m_NextTargetPosition;
				lookAtObject.position = m_NextTargetPosition;
			}
		}

		public void SetChangeWaight(WaightFreeze waightFreeze, float changeTime = 1f)
		{
			bool flag = false;
			if (waightFreeze.fleezeBodyWaight ^ mIsBodyWaightFreeze)
			{
				mIsBodyWaightFreeze = waightFreeze.fleezeBodyWaight;
				mLastBodyWaight = mBodyWaight;
				if (mIsBodyWaightFreeze)
				{
					mNextBodyWaight = 0f;
				}
				else
				{
					mNextBodyWaight = mDefaultBodyWaight;
				}
				flag = true;
			}
			if (waightFreeze.fleezeNeckWaight ^ mIsNeckWaightFreeze)
			{
				mIsNeckWaightFreeze = waightFreeze.fleezeNeckWaight;
				mLastNeckWaight = mNeckWaight;
				if (mIsNeckWaightFreeze)
				{
					mNextNeckWaight = 0f;
				}
				else
				{
					mNextNeckWaight = mDefaultNeckWaight;
				}
				flag = true;
			}
			if (waightFreeze.fleezeHeadWaight ^ mIsHeadWaightFreeze)
			{
				mIsHeadWaightFreeze = waightFreeze.fleezeHeadWaight;
				mLastHeadWaight = mHeadWaight;
				if (mIsHeadWaightFreeze)
				{
					mNextHeadWaight = 0f;
				}
				else
				{
					mNextHeadWaight = mDefaultHeadWaight;
				}
				flag = true;
			}
			if (flag)
			{
				mWaightChangeTime = changeTime;
				mWaightTimer = 0f;
				isWaightChange = true;
			}
		}

		public void LookingMorph(float rotateY)
		{
			if (MorpthTargetList != null)
			{
				if (rotateY >= EyeLinitYMax / 10f)
				{
					float value = 100f * rotateY / EyeLinitYMax;
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[1], value);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[0], value);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[5], value);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[4], value);
				}
				else if (rotateY < EyeLimitYMin / 10f)
				{
					float value2 = 100f * rotateY / EyeLimitYMin;
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[7], value2);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[6], value2);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[3], value2);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[2], value2);
				}
				else
				{
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[1], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[0], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[3], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[2], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[5], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[4], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[7], 0f);
					faceMesh.SetBlendShapeWeight(MorpthTargetList.MorpthTargetIndex[6], 0f);
				}
			}
		}
	}
	public interface IChara
	{
		Transform Head { get; }

		Transform Transform { get; set; }

		GameDefine.CharaID ID { get; }

		void Destroy();

		void Enable();

		void Disable();

		void SetEnable(bool isEnable);
	}
	public class BaseProp : MonoBehaviour
	{
		[Header("Prop基本設定")]
		[SerializeField]
		[Tooltip("エディタ表示用のPropネーム")]
		private string _propAliasName = "";

		[SerializeField]
		[Tooltip("ONにするとコマンドを入れなくても自動的にプロップが置かれます\n部屋ドア等にお使いください")]
		private bool _showAlways;

		[Header("アンカー設定")]
		[SerializeField]
		[Tooltip("視線合わせなどで用いるアンカーのTransformをここで設定する")]
		private Transform[] _anchors;

		[Header("特殊設定 (基本触る必要なし)")]
		[SerializeField]
		[Tooltip("これが設定されている場合、コマンドの位置参照時にこのTransformを用いる")]
		private Transform _anchorOverride;

		[SerializeField]
		[Tooltip("これが設定されている場合、音源位置を上書きする")]
		private Transform _audioAnchorOverride;

		private GameObject _gameObject;

		private Transform _thisTransform;

		private Transform _parentTransform;

		private bool _isVisible;

		private BehaviorSubject<bool> _subjectOnChangeVisible;

		public Transform ThisTransform
		{
			get
			{
				if (_thisTransform == null)
				{
					_thisTransform = base.transform;
				}
				return _thisTransform;
			}
		}

		public GameObject ThisObject => _gameObject;

		public Transform ParentTransform => _parentTransform;

		public Transform AnchorTransform
		{
			get
			{
				if (!(_anchorOverride != null))
				{
					return ThisTransform;
				}
				return _anchorOverride;
			}
		}

		public Transform AudioAnchorTransform
		{
			get
			{
				if (!(_audioAnchorOverride != null))
				{
					return AnchorTransform;
				}
				return _audioAnchorOverride;
			}
		}

		public string PropName
		{
			get
			{
				if (!string.IsNullOrEmpty(_propAliasName))
				{
					return _propAliasName;
				}
				return base.gameObject.name;
			}
		}

		public int AnchorCount => _anchors.Length;

		public bool IsVisible => _isVisible;

		public bool ShowAlways => _showAlways;

		public virtual PropDefines.PropType ThisPropType => PropDefines.PropType.Static;

		public IObservable<bool> ChangeVisibleObservable
		{
			get
			{
				if (_subjectOnChangeVisible == null)
				{
					_subjectOnChangeVisible = new BehaviorSubject<bool>(_isVisible);
				}
				return _subjectOnChangeVisible;
			}
		}

		public virtual IObservable<PropActionParam> OnAction => null;

		private void Awake()
		{
			_gameObject = base.gameObject;
			_thisTransform = base.transform;
			_parentTransform = AnchorTransform.parent;
			OnAwakeInitialize();
		}

		protected virtual void OnAwakeInitialize()
		{
		}

		public virtual void SetInitial()
		{
		}

		private void Start()
		{
			OnStart();
			_gameObject.SetActive(_isVisible);
		}

		protected virtual void OnStart()
		{
		}

		public void SetVisible(bool flag)
		{
			if (_isVisible != flag)
			{
				_isVisible = flag;
				OnChangeVisible(_isVisible);
				if (_subjectOnChangeVisible != null)
				{
					_subjectOnChangeVisible.OnNext(_isVisible);
				}
			}
		}

		protected virtual void OnChangeVisible(bool flag)
		{
		}

		public virtual void SetAlpha(float alpha)
		{
		}

		public virtual void SetOutlineSize(float size)
		{
		}

		public virtual void SetOutlineColor(Color color)
		{
		}

		public virtual void StartSmoothOutlineSizeChange(float duration, float after)
		{
		}

		public virtual void StartSmoothOutlineColorChange(float duration, Color after)
		{
		}

		public virtual void ActionPropAnimation(int index)
		{
		}

		public virtual void ActionPropAnimation(string triggerName)
		{
		}

		public virtual void ActionPropAnimation(PropActionParam action)
		{
		}

		public virtual PropActionParam GetPropAction(int index)
		{
			return new PropActionParam();
		}

		public virtual PropActionParam GetPropAction(string triggerName)
		{
			return new PropActionParam();
		}

		public virtual void ResetPropTransform()
		{
		}

		public virtual void MoveProp(Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void MovePropAdditive(Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void MovePropOnLocal(Vector3 position, Quaternion rotation)
		{
		}

		public virtual void MovePropOnLocal(Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void MovePropRelation(Transform relationTransform, Vector3 position, Quaternion rotation, Vector3 scale)
		{
		}

		public virtual void AttachToTransform(Transform target, bool isStay)
		{
		}

		public virtual void SetAttachToChara(AdvChara chara, AdvCharaModel.Node nodeToAttach)
		{
		}

		public virtual void ActionBetweenDither(float fadeDuration, Action onBetween, Action onEnd)
		{
		}

		public virtual void ReadyToSmooth(float duration)
		{
		}

		public Transform GetAnchor(int index)
		{
			if (index <= -1)
			{
				return ThisTransform;
			}
			if (index >= _anchors.Length)
			{
				return ThisTransform;
			}
			return _anchors[index];
		}

		public virtual void ResetPropEverything()
		{
			ResetPropTransform();
			SetVisible(_showAlways);
		}
	}
	public class DynamicProp : BaseProp
	{
		private struct DestinationCoord
		{
			public Vector3 Position;

			public Quaternion Rotation;

			public Vector3 Scale;

			public static DestinationCoord identity
			{
				get
				{
					DestinationCoord result = default(DestinationCoord);
					result.Position = Vector3.zero;
					result.Rotation = Quaternion.identity;
					result.Scale = Vector3.one;
					return result;
				}
			}

			public DestinationCoord(Transform tf)
			{
				Position = tf.localPosition;
				Rotation = tf.localRotation;
				Scale = tf.localScale;
			}

			public DestinationCoord(Vector3 pos, Quaternion rot, Vector3 sca)
			{
				Position = pos;
				Rotation = rot;
				Scale = sca;
			}

			public static DestinationCoord Lerp(DestinationCoord a, DestinationCoord b, float t)
			{
				DestinationCoord result = default(DestinationCoord);
				result.Position = Vector3.Lerp(a.Position, b.Position, t);
				result.Rotation = Quaternion.Lerp(a.Rotation, b.Rotation, t);
				result.Scale = Vector3.Lerp(a.Scale, b.Scale, t);
				return result;
			}
		}

		private BehaviorSubject<PropActionParam> _subjectAction;

		[Header("Dynamic Prop設定")]
		[SerializeField]
		[Tooltip("プロップアクション用のアニメーター")]
		private Animator _propAnimator;

		[Header("プロップアクション (Animation) 設定")]
		[SerializeField]
		[Tooltip("プロップアクションのパラメーター")]
		private PropActionParam[] _propActions;

		private bool _isMoved;

		private Vector3 _initialPosition;

		private Quaternion _initialRotation;

		private Vector3 _initialScale;

		private List<Renderer> _targetRenderer;

		private SortedDictionary<string, PropActionParam> _dictAction = new SortedDictionary<string, PropActionParam>();

		private SortedDictionary<int, Material> _instancedMaterials;

		private AdvChara _attachedChara;

		private AdvCharaModel.Node _nodeToAttach;

		private DestinationCoord _smoothFrom;

		private DestinationCoord _smoothTo;

		private float _smoothDuration;

		private bool _isReadySmooth;

		private DitherFade _ditherfade;

		private IDisposable _disposeUpdate;

		private IDisposable _disposeSmoothMove;

		private IDisposable _disposeSmoothOutlineColorChange;

		private IDisposable _disposeSmoothOutlineSizeChange;

		private Action m_onStartDitherFadeEnd;

		private Action m_onBetween;

		private Action m_onEnd;

		private Action m_onEndMethodAction;

		private float m_fadeDuration;

		public override PropDefines.PropType ThisPropType => PropDefines.PropType.Dynamic;

		public override IObservable<PropActionParam> OnAction => _subjectAction;

		private bool IsAnimatorAvailable => _propAnimator != null;

		private IObservable<Unit> ObserverGameUpdate => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public PropActionParam[] PropActions => _propActions;

		protected override void OnAwakeInitialize()
		{
			_subjectAction = new BehaviorSubject<PropActionParam>(new PropActionParam());
			SetInitial();
			SetActionIndex();
			FindRenderer();
			InitializeActions();
			MakeRendererMaterials();
			MakeDitherFade();
		}

		public override void SetInitial()
		{
			_initialPosition = base.AnchorTransform.localPosition;
			_initialRotation = base.AnchorTransform.localRotation;
			_initialScale = base.AnchorTransform.localScale;
		}

		public void SetActionIndex()
		{
			if (PropActions == null)
			{
				return;
			}
			for (int i = 0; i < PropActions.Length; i++)
			{
				PropActionParam propActionParam = PropActions[i];
				if (propActionParam != null)
				{
					propActionParam.Index = i;
					_dictAction.Add(propActionParam.TriggerName, propActionParam);
				}
			}
		}

		private void InitializeActions()
		{
			m_onStartDitherFadeEnd = delegate
			{
				OnStartDitherFadeEnd();
			};
			m_onEndMethodAction = delegate
			{
				OnFadeAllEnd();
			};
		}

		private void OnStartDitherFadeEnd()
		{
			if (m_onBetween != null)
			{
				m_onBetween();
				m_onBetween = null;
			}
			if (base.IsVisible)
			{
				OnBetweenDitherEnd(m_fadeDuration, m_onEnd);
			}
		}

		protected override void OnStart()
		{
			if (IsAnimatorAvailable)
			{
				_propAnimator.enabled = false;
			}
		}

		private void FindRenderer()
		{
			_targetRenderer = new List<Renderer>();
			Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
			_targetRenderer.AddRange(componentsInChildren);
		}

		private void MakeRendererMaterials()
		{
			_instancedMaterials = new SortedDictionary<int, Material>();
			_targetRenderer.ForEach(delegate(Renderer renderer)
			{
				if (!(renderer == null))
				{
					Material[] sharedMaterials = renderer.sharedMaterials;
					Material[] array = new Material[sharedMaterials.Length];
					for (int i = 0; i < sharedMaterials.Length; i++)
					{
						Material material = sharedMaterials[i];
						if ((object)material != null)
						{
							if (!_instancedMaterials.TryGetValue(material.GetHashCode(), out var value))
							{
								value = new Material(material);
								value.name += " (IS)";
								_instancedMaterials.Add(material.GetHashCode(), value);
							}
							array[i] = value;
						}
					}
					renderer.sharedMaterials = array;
				}
			});
		}

		private void MakeDitherFade()
		{
			_ditherfade = new DitherFade(base.gameObject, new List<Material>(_instancedMaterials.Values));
		}

		private void OnEnable()
		{
			if (SingletonMonoBehaviour<GameLogic>.HasInstance)
			{
				_disposeUpdate = ObserverGameUpdate.Subscribe(delegate
				{
					OnGameUpdate();
				}).AddTo(base.gameObject);
			}
			else
			{
				_disposeUpdate = this.UpdateAsObservable().Subscribe(delegate
				{
					OnGameUpdate();
				}).AddTo(base.gameObject);
			}
		}

		private void OnDisable()
		{
			if (_disposeUpdate != null)
			{
				_disposeUpdate.Dispose();
				_disposeUpdate = null;
			}
			if (_disposeSmoothMove != null)
			{
				_disposeSmoothMove.Dispose();
				_disposeSmoothMove = null;
			}
		}

		private void OnGameUpdate()
		{
			if (IsAnimatorAvailable)
			{
				_propAnimator.Update(Time.deltaTime);
			}
		}

		protected override void OnChangeVisible(bool flag)
		{
			base.ThisObject.SetActive(flag);
			if (!flag)
			{
				CheckDettachFromChara();
			}
		}

		public override void ActionPropAnimation(int index)
		{
			PropActionParam propAction = GetPropAction(index);
			ActionPropAnimation(propAction);
		}

		public override void ActionPropAnimation(string triggerName)
		{
			PropActionParam propAction = GetPropAction(triggerName);
			ActionPropAnimation(propAction);
		}

		public override void ActionPropAnimation(PropActionParam action)
		{
			if (_propAnimator != null)
			{
				string triggerName = action.TriggerName;
				_propAnimator.SetTrigger(triggerName);
			}
			if (_subjectAction != null)
			{
				_subjectAction.OnNext(action);
			}
		}

		public override PropActionParam GetPropAction(int index)
		{
			if (index < 0 || index >= PropActions.Length)
			{
				return new PropActionParam();
			}
			PropActionParam propActionParam = PropActions[index];
			if (propActionParam == null)
			{
				return new PropActionParam();
			}
			return propActionParam;
		}

		public override PropActionParam GetPropAction(string triggerName)
		{
			if (!_dictAction.TryGetValue(triggerName, out var value))
			{
				return new PropActionParam();
			}
			return value;
		}

		public override void ResetPropTransform()
		{
			if (_isMoved)
			{
				AttachToTransform(null, isStay: true);
				OnBeforeMovement();
				base.AnchorTransform.localPosition = _initialPosition;
				base.AnchorTransform.localRotation = _initialRotation;
				base.AnchorTransform.localScale = _initialScale;
				_isMoved = false;
				CheckDettachFromChara();
				OnAfterMovement();
			}
		}

		public override void MoveProp(Vector3 position, Quaternion rotation, Vector3 scale)
		{
			OnBeforeMovement();
			scale.Scale(_initialScale);
			base.AnchorTransform.position = position;
			base.AnchorTransform.rotation = rotation * _initialRotation;
			base.AnchorTransform.localScale = scale;
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropAdditive(Vector3 position, Quaternion rotation, Vector3 scale)
		{
			OnBeforeMovement();
			base.AnchorTransform.localPosition += position;
			base.AnchorTransform.localRotation = rotation * base.AnchorTransform.localRotation;
			base.AnchorTransform.localScale.Scale(scale);
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropOnLocal(Vector3 position, Quaternion rotation)
		{
			OnBeforeMovement();
			base.AnchorTransform.localPosition = position;
			base.AnchorTransform.localRotation = rotation * _initialRotation;
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropOnLocal(Vector3 position, Quaternion rotation, Vector3 scale)
		{
			OnBeforeMovement();
			scale.Scale(_initialScale);
			base.AnchorTransform.localPosition = position;
			base.AnchorTransform.localRotation = rotation * _initialRotation;
			base.AnchorTransform.localScale = scale;
			_isMoved = true;
			OnAfterMovement();
		}

		public override void MovePropRelation(Transform relationTransform, Vector3 position, Quaternion rotation, Vector3 scale)
		{
			position = relationTransform.TransformPoint(position);
			rotation = relationTransform.rotation * rotation;
			MoveProp(position, rotation, scale);
		}

		private void OnBeforeMovement()
		{
			if (_isReadySmooth)
			{
				_smoothFrom = new DestinationCoord(base.ThisTransform);
			}
		}

		private void OnAfterMovement()
		{
			if (_isReadySmooth)
			{
				_smoothTo = new DestinationCoord(base.ThisTransform);
				_isReadySmooth = false;
				if (_disposeSmoothMove != null)
				{
					_disposeSmoothMove.Dispose();
				}
				_disposeSmoothMove = Observable.FromMicroCoroutine(CoroutineSmoothMove).Subscribe().AddTo(this);
			}
		}

		private IEnumerator CoroutineSmoothMove()
		{
			Tweener<DestinationCoord> tweener = new Tweener<DestinationCoord>(DestinationCoord.Lerp);
			tweener.Start(_smoothFrom, _smoothTo, _smoothDuration);
			while (tweener.IsActive)
			{
				base.AnchorTransform.localPosition = tweener.CurrentValue.Position;
				base.AnchorTransform.localRotation = tweener.CurrentValue.Rotation;
				base.AnchorTransform.localScale = tweener.CurrentValue.Scale;
				tweener.Update(Time.deltaTime);
				yield return null;
			}
			base.AnchorTransform.localPosition = tweener.CurrentValue.Position;
			base.AnchorTransform.localRotation = tweener.CurrentValue.Rotation;
			base.AnchorTransform.localScale = tweener.CurrentValue.Scale;
			yield return null;
		}

		public override void AttachToTransform(Transform target, bool isStay)
		{
			if (target == null)
			{
				target = base.ParentTransform;
				SetLayerRecursively(base.gameObject, LayerMask.NameToLayer("Environment"));
			}
			else
			{
				SetLayerRecursively(base.gameObject, LayerMask.NameToLayer("ImportantProp"));
			}
			base.AnchorTransform.SetParent(target, isStay);
			_isMoved = true;
		}

		private void SetLayerRecursively(GameObject obj, int newLayer)
		{
			if (null == obj)
			{
				return;
			}
			obj.layer = newLayer;
			foreach (Transform item in obj.transform)
			{
				if (!(null == item))
				{
					SetLayerRecursively(item.gameObject, newLayer);
				}
			}
		}

		public override void ActionBetweenDither(float fadeDuration, Action onBetween, Action onEnd)
		{
			if (base.IsVisible)
			{
				m_onBetween = onBetween;
				m_onEnd = onEnd;
				m_fadeDuration = fadeDuration;
				_ditherfade.StartFadeCoroutine(1f, 0f, fadeDuration, m_onStartDitherFadeEnd);
			}
			else
			{
				onBetween?.Invoke();
				if (base.IsVisible)
				{
					OnBetweenDitherEnd(fadeDuration, onEnd);
				}
			}
		}

		private void OnBetweenDitherEnd(float fadeDuration, Action onEnd)
		{
			_ditherfade.StartFadeCoroutine(0f, 1f, fadeDuration, m_onEndMethodAction);
		}

		private void OnFadeAllEnd()
		{
			if (m_onEnd != null)
			{
				m_onEnd();
				m_onEnd = null;
			}
		}

		public override void ReadyToSmooth(float duration)
		{
			_isReadySmooth = true;
			_smoothDuration = duration;
		}

		public override void SetAlpha(float alpha)
		{
			_ditherfade.SetModelAlpha(alpha);
		}

		public override void SetOutlineSize(float size)
		{
			_ditherfade.SetModelOutlineSize(size);
		}

		public override void SetOutlineColor(Color color)
		{
			_ditherfade.SetModelOutlineColor(color);
		}

		private float GetOutlineSize()
		{
			return _ditherfade.GetModelOutlineSize();
		}

		private Color GetOutlineColor()
		{
			return _ditherfade.GetModelOutlineColor();
		}

		private void DisposeSmoothOutlineSize()
		{
			if (_disposeSmoothOutlineSizeChange != null)
			{
				_disposeSmoothOutlineSizeChange.Dispose();
				_disposeSmoothOutlineSizeChange = null;
			}
		}

		public override void StartSmoothOutlineSizeChange(float duration, float after)
		{
			DisposeSmoothOutlineSize();
			_disposeSmoothOutlineSizeChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineSizeChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineSizeChange(float duration, float after)
		{
			float tick = 0f;
			float before = GetOutlineSize();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetOutlineSize(Mathf.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetOutlineSize(after);
		}

		private void DisposeSmoothOutlineColor()
		{
			if (_disposeSmoothOutlineColorChange != null)
			{
				_disposeSmoothOutlineColorChange.Dispose();
				_disposeSmoothOutlineColorChange = null;
			}
		}

		public override void StartSmoothOutlineColorChange(float duration, Color after)
		{
			DisposeSmoothOutlineColor();
			_disposeSmoothOutlineColorChange = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSmoothOutlineColorChange(duration, after)).Subscribe().AddTo(base.gameObject);
		}

		private IEnumerator RoutineSmoothOutlineColorChange(float duration, Color after)
		{
			float tick = 0f;
			Color before = GetOutlineColor();
			while (tick < duration)
			{
				tick += Time.deltaTime;
				SetOutlineColor(Color.Lerp(before, after, tick / duration));
				yield return null;
			}
			SetOutlineColor(after);
		}

		public override void SetAttachToChara(AdvChara chara, AdvCharaModel.Node nodeToAttach)
		{
			_nodeToAttach = nodeToAttach;
			_attachedChara = chara;
			chara.OnAttachProp(this, nodeToAttach);
		}

		private void CheckDettachFromChara()
		{
			if (_attachedChara != null)
			{
				_attachedChara.OnDettachProp(this, _nodeToAttach);
				_attachedChara = null;
			}
		}
	}
	public class StaticProp : BaseProp
	{
		public override PropDefines.PropType ThisPropType => PropDefines.PropType.Static;

		protected override void OnChangeVisible(bool flag)
		{
			base.gameObject.SetActive(flag);
		}

		public override void ActionPropAnimation(int index)
		{
		}
	}
	public class BaseScenePropController : MonoBehaviour
	{
		[Header("プロップ Prefab 設定")]
		[SerializeField]
		[PrefabField]
		private BaseProp[] _prefabPropsList = new BaseProp[0];

		private Transform _thisTransform;

		private Dictionary<int, BaseProp> _instancePropsList;

		public virtual PropDefines.PropType ManagePropType => PropDefines.PropType.Static;

		public int PropCount => _prefabPropsList.Length;

		public BaseProp[] PrefabPropsList
		{
			get
			{
				return _prefabPropsList;
			}
			set
			{
				_prefabPropsList = value;
			}
		}

		private void Awake()
		{
			_thisTransform = base.transform;
			_instancePropsList = new Dictionary<int, BaseProp>();
		}

		public BaseProp GetPropByIndex(int index)
		{
			if (!_instancePropsList.TryGetValue(index, out var value))
			{
				return MakeInstancePropByIndex(index);
			}
			return value;
		}

		private BaseProp MakeInstancePropByIndex(int index)
		{
			BaseProp baseProp = _prefabPropsList[index];
			if (baseProp == null)
			{
				return null;
			}
			BaseProp baseProp2 = UnityEngine.Object.Instantiate(baseProp, _thisTransform, worldPositionStays: false);
			_instancePropsList.Add(index, baseProp2);
			return baseProp2;
		}

		public void MakeInstancePropByList(List<int> indexes)
		{
			if (_instancePropsList.Count > 0)
			{
				ClearAllProps();
			}
			if (_prefabPropsList != null)
			{
				for (int i = 0; i < _prefabPropsList.Length; i++)
				{
					BaseProp baseProp = _prefabPropsList[i];
					if (!(baseProp == null) && baseProp.ShowAlways)
					{
						GetPropByIndex(i).SetVisible(flag: true);
					}
				}
			}
			if (indexes == null)
			{
				return;
			}
			foreach (int index in indexes)
			{
				GetPropByIndex(index);
			}
		}

		public void ClearAllProps()
		{
			foreach (BaseProp value in _instancePropsList.Values)
			{
				UnityEngine.Object.Destroy(value.gameObject);
			}
			_instancePropsList.Clear();
		}

		public void MakeAllInstance()
		{
			for (int i = 0; i < _prefabPropsList.Length; i++)
			{
				GetPropByIndex(i);
			}
		}

		public void SetAllVisible(bool flag)
		{
			foreach (BaseProp value in _instancePropsList.Values)
			{
				value.gameObject.SetActive(flag);
				value.ResetPropTransform();
			}
		}

		public void ResetInstancedProps()
		{
			foreach (BaseProp value in _instancePropsList.Values)
			{
				if (!(value == null))
				{
					value.ResetPropEverything();
				}
			}
		}

		private bool IsValidIndex(int index)
		{
			if (index >= 0)
			{
				return index < _prefabPropsList.Length;
			}
			return false;
		}
	}
	public class DynamicScenePropController : BaseScenePropController
	{
		public override PropDefines.PropType ManagePropType => PropDefines.PropType.Dynamic;
	}
	public class StaticScenePropController : BaseScenePropController
	{
		public override PropDefines.PropType ManagePropType => PropDefines.PropType.Static;
	}
	[Serializable]
	public class PropActionParam
	{
		[NonSerialized]
		public int Index = -1;

		public string TriggerName = "";

		public bool IsValid => Index != -1;
	}
	public static class PropDefines
	{
		public enum PropType
		{
			Static,
			Dynamic
		}

		public enum RelativeModes
		{
			World = 0,
			WorldAdditive = 1,
			Self = 10,
			Player = 20,
			PlayerAvaterBody = 21,
			PlayerAvaterHand = 22,
			Chara = 30,
			CharaNode = 31,
			OtherProp = 40,
			OtherPropAnchor = 41,
			RealHead = 50,
			RealHand = 51,
			RealFoot = 52
		}

		public enum FadeModes
		{
			None,
			Smooth,
			Dither
		}
	}
	public class MirrorPlane : UpdateableComponent
	{
		[SerializeField]
		private Camera _mirrorCamera;

		private Transform _thisTransform;

		private Transform _mirrorCameraTransform;

		private Transform MainCameraTransform => SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera.transform;

		protected override void Initialize()
		{
			_thisTransform = base.transform;
			_mirrorCameraTransform = _mirrorCamera.transform;
		}

		private void OnEnable()
		{
			_mirrorCamera.enabled = true;
		}

		private void OnDisable()
		{
			_mirrorCamera.enabled = false;
		}

		public override void OnUpdate(float delta)
		{
		}

		private void MoveMirrorCamera()
		{
			Vector3 position = MainCameraTransform.position;
			Vector3 localPosition = _thisTransform.InverseTransformPoint(position);
			localPosition.z = 0f;
			_mirrorCameraTransform.localPosition = localPosition;
		}
	}
	public class LoadingObject : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Transform _targetFetch;

		[SerializeField]
		private Animator _animator;

		[SerializeField]
		private Renderer _renderer;

		[SerializeField]
		private SpriteRenderer _specificRenderer;

		[Header("Parameters")]
		[SerializeField]
		private bool _specificMode;

		[SerializeField]
		private float _delayToShow = 0.5f;

		[SerializeField]
		private float _minimumShowingTime = 0.5f;

		[Header("Parameters - Specific Mode")]
		[SerializeField]
		private Sprite _defaultSprite;

		[Header("Parameters - Random Mode")]
		[SerializeField]
		private Sprite[] _randomSpriteList;

		private bool _isVisible;

		private void Start()
		{
			base.transform.SetParent(SingletonMonoBehaviour<PlayAreaManager>.Instance.VRAreaTransform);
			IObservable<bool> source = SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => flag);
			IObservable<bool> observable = SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag);
			if (_delayToShow > 0f)
			{
				source.SelectMany((bool _) => Observable.Timer(TimeSpan.FromSeconds(_delayToShow))).TakeUntil(observable).Subscribe(delegate
				{
					if (!_isVisible)
					{
						RefreshSprite();
						EmitBusy();
					}
					SetVisible(flag: true);
				})
					.AddTo(base.gameObject);
			}
			else
			{
				source.Subscribe(delegate
				{
					if (!_isVisible)
					{
						RefreshSprite();
						EmitBusy();
					}
					SetVisible(flag: true);
				}).AddTo(base.gameObject);
			}
			observable.Subscribe(delegate
			{
				SetVisible(flag: false);
			}).AddTo(base.gameObject);
		}

		private void EmitBusy()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(this);
			Observable.Timer(TimeSpan.FromSeconds(_minimumShowingTime)).Subscribe(delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.RemoveBusy(this);
			}).AddTo(base.gameObject);
		}

		private void RefreshSprite()
		{
			if (_specificMode)
			{
				_specificRenderer.sprite = FindSpecificLoadingSprite(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
			}
			else
			{
				_specificRenderer.sprite = GetRandomLoadingSprite();
			}
		}

		private void SetVisible(bool flag)
		{
			if (_isVisible != flag)
			{
				_isVisible = flag;
				_renderer.enabled = flag;
				_animator.enabled = flag;
				_specificRenderer.enabled = flag;
			}
		}

		private Sprite GetRandomLoadingSprite()
		{
			return _randomSpriteList[UnityEngine.Random.Range(0, _randomSpriteList.Length)];
		}

		private Sprite FindSpecificLoadingSprite(int id)
		{
			Sprite sprite = SingletonMonoBehaviour<DataManager>.Instance.FindLoadingSprite(id);
			if (sprite == null)
			{
				return _defaultSprite;
			}
			return sprite;
		}
	}
	[DisallowMultipleComponent]
	public class MainMenuManager : SingletonMonoBehaviour<MainMenuManager>, ISoundableMenu
	{
		public enum MenuMode
		{
			Closed = -2,
			Blank,
			Home,
			SkipMode,
			Note,
			Save,
			Load,
			Config,
			Help,
			Title,
			MAX
		}

		[Header("Components - Base")]
		[SerializeField]
		private Animator menuAnimator;

		[SerializeField]
		private Canvas menuCanvas;

		[SerializeField]
		private AudioSource uiSoundSource;

		[SerializeField]
		private GraphicRaycaster _thisRaycaster;

		[SerializeField]
		private GraphicRaycaster _mainMenuRaycaster;

		[Header("Components - UI")]
		[SerializeField]
		private MainMenuPositioner positioner;

		[SerializeField]
		private MenuButtonFloater backButton;

		[SerializeField]
		private MenuClock clockUI;

		[Header("Parameters")]
		[Tooltip("メニューオープン時のフェードカラー")]
		[SerializeField]
		private Color menuFadeColor = Color.black;

		private bool _isOpen;

		private bool _isOnlySub;

		private bool _prohibitByCommand;

		private bool _prohibitByBusyLag;

		private SubMenuManager _subMenuManager;

		private List<bool> m_prohibitions;

		private Subject<bool> _subjectToggleMenu = new Subject<bool>();

		public MenuMode Mode { get; private set; }

		public MenuMode FixedMode { get; set; }

		public bool IsProhibitByCommand
		{
			get
			{
				return _prohibitByCommand;
			}
			set
			{
				_prohibitByCommand = value;
			}
		}

		public bool IsProhibitByTimeline
		{
			get
			{
				if (!SingletonMonoBehaviour<InGameManager>.HasInstance)
				{
					return false;
				}
				if (!InGameManager.Timeline.IsHardSkip)
				{
					return InGameManager.Timeline.MessageProcessor.ForceMode == MessagePlayer.ForceModes.ForceAuto;
				}
				return true;
			}
		}

		public bool IsMenuAvailable
		{
			get
			{
				if (InGameManager.IsReadyInGame && !SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
				{
					return !_prohibitByBusyLag;
				}
				return false;
			}
		}

		public bool IsOpened => _isOpen;

		public bool IsRootMenu => Mode == MenuMode.Home;

		private UIFader menuFader
		{
			get
			{
				if (!SingletonMonoBehaviour<FadeManager>.HasInstance)
				{
					return null;
				}
				return SingletonMonoBehaviour<FadeManager>.Instance.menuFader;
			}
		}

		private IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public IObservable<bool> OnToggleMenu => _subjectToggleMenu;

		protected override void InitializeOnAwake()
		{
			_subMenuManager = GetComponent<SubMenuManager>();
			InitProhibitions();
		}

		private void Start()
		{
			menuCanvas.enabled = false;
			menuAnimator.Update(9f);
			menuAnimator.enabled = false;
			_subMenuManager.InitSubmenuByMainMenu(this);
			_subMenuManager.DisableAllSubMenu();
			MakeSubscribes();
			_thisRaycaster.enabled = false;
			_mainMenuRaycaster.enabled = false;
			_isOpen = false;
			Mode = MenuMode.Closed;
		}

		private void InitProhibitions()
		{
			FixedMode = MenuMode.Home;
			IsProhibitByCommand = false;
			m_prohibitions = new List<bool>(8);
			for (int i = 0; i < 8; i++)
			{
				m_prohibitions.Add(item: false);
			}
		}

		public void ResetProhibitions()
		{
			FixedMode = MenuMode.Home;
			IsProhibitByCommand = false;
			for (int i = 0; i < 8; i++)
			{
				m_prohibitions[i] = false;
			}
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				Observable.NextFrame().Subscribe(delegate
				{
					ForceSetPositionToMainCamera();
				}).AddTo(base.gameObject);
			}).AddTo(base.gameObject);
			backButton.ClickObservable.Subscribe(delegate
			{
				OnPressBackButton();
			}).AddTo(base.gameObject);
			backButton.AcceptedForcusObservable.Subscribe(delegate
			{
				PlaySeSelect();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				ResetProhibitions();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				ResetProhibitions();
			}).AddTo(base.gameObject);
			IObservable<bool> observable = SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => flag).Share();
			observable.Subscribe(delegate
			{
				_prohibitByBusyLag = true;
				ForceDisappearMenu();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag).SelectMany((bool _) => Observable.TimerFrame(40)).TakeUntil(observable)
				.RepeatUntilDestroy(base.gameObject)
				.Subscribe(delegate
				{
					_prohibitByBusyLag = false;
				})
				.AddTo(base.gameObject);
			IObservable<Unit> source = UpdateObserbable.Where((Unit _) => base.enabled).Share();
			source.Where((Unit _) => _isOpen).Subscribe(delegate
			{
				OnUpdateAnimation();
			}).AddTo(base.gameObject);
			source.Where((Unit _) => !_isOpen).Subscribe(delegate
			{
				OnUpdateClosing();
			}).AddTo(base.gameObject);
			OnToggleMenu.Subscribe(delegate(bool flag)
			{
				if (flag)
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.AddLaserNeed(this);
				}
				else
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.RemoveLaserNeed(this);
				}
			}).AddTo(base.gameObject);
		}

		private void OnEnable()
		{
			menuCanvas.enabled = true;
			clockUI.enabled = true;
		}

		private void OnDisable()
		{
			_subMenuManager.DisableAllSubMenu();
			menuCanvas.enabled = false;
			clockUI.enabled = false;
		}

		private void OnUpdateAnimation()
		{
			if (SetPositionToMainCamera())
			{
				menuAnimator.Play("Close");
				menuAnimator.Update(9f);
				menuAnimator.Play("Open");
			}
			menuAnimator.Update(Time.deltaTime);
		}

		private void OnUpdateClosing()
		{
			if (IsFinishedClose())
			{
				base.enabled = false;
			}
			else
			{
				menuAnimator.Update(Time.deltaTime);
			}
		}

		private bool IsFinishedClose()
		{
			if (_isOpen)
			{
				return false;
			}
			AnimatorStateInfo currentAnimatorStateInfo = menuAnimator.GetCurrentAnimatorStateInfo(0);
			if (!currentAnimatorStateInfo.IsName("Close"))
			{
				return false;
			}
			return currentAnimatorStateInfo.normalizedTime >= 1f;
		}

		public void OpenMenu(MenuMode initialMode = MenuMode.Home)
		{
			if (initialMode == MenuMode.Home)
			{
				if (!IsMenuAvailable)
				{
					return;
				}
				if (IsProhibitByCommand || IsProhibitByTimeline)
				{
					PlaySeErrorCannotOpen();
					return;
				}
				if (FixedMode != 0)
				{
					initialMode = FixedMode;
				}
			}
			ForceSetPositionToMainCamera();
			menuAnimator.SetBool("Open", value: true);
			_thisRaycaster.enabled = true;
			_mainMenuRaycaster.enabled = true;
			_isOpen = true;
			base.enabled = true;
			SetMenuMode(initialMode);
			_isOnlySub = initialMode != MenuMode.Home;
			ToggleMenuFade(flag: true);
			PlaySeOpen();
			_subjectToggleMenu.OnNext(value: true);
		}

		public void CloseMenu()
		{
			_subMenuManager.ForceCloseSubMenu();
			menuAnimator.SetBool("Open", value: false);
			_thisRaycaster.enabled = false;
			_mainMenuRaycaster.enabled = false;
			_isOpen = false;
			Mode = MenuMode.Closed;
			ToggleMenuFade(flag: false);
			PlaySeClose();
			_subjectToggleMenu.OnNext(value: false);
		}

		public void ForceDisappearMenu()
		{
			if (base.enabled)
			{
				_subMenuManager.ForceCloseSubMenu();
				menuAnimator.SetBool("Open", value: false);
				menuAnimator.Update(9f);
				_thisRaycaster.enabled = false;
				_mainMenuRaycaster.enabled = false;
				_isOpen = false;
				Mode = MenuMode.Closed;
				ToggleMenuFade(flag: false);
				_subjectToggleMenu.OnNext(value: false);
				base.enabled = false;
			}
		}

		private void ToggleMenuFade(bool flag)
		{
			if (!(menuFader == null))
			{
				if (flag)
				{
					menuFader.StartFade(menuFadeColor, 0.2f, isDeactivateOnEnd: false);
				}
				else
				{
					menuFader.StartFade(ColorDefine.TransparentBlack, 0.2f, isDeactivateOnEnd: true);
				}
			}
		}

		private void OnPressBackButton()
		{
			if (Mode == MenuMode.Home)
			{
				CloseMenu();
			}
			else
			{
				if (Mode == MenuMode.Closed)
				{
					return;
				}
				if (_subMenuManager.IsOpenedConfirm)
				{
					_subMenuManager.ForceCloseConfirm();
				}
				else if (OnCancelSubMenu())
				{
					if (_isOnlySub)
					{
						CloseMenu();
						return;
					}
					PlaySeCancel();
					SetMenuMode(MenuMode.Home);
				}
			}
		}

		public void OnPressHardwareBackButton()
		{
			OnPressBackButton();
		}

		public void SetMenuMode(MenuMode mode)
		{
			Mode = mode;
			OnChangeMode();
		}

		public void BackToHome()
		{
			if (_isOnlySub)
			{
				CloseMenu();
			}
			else
			{
				SetMenuMode(MenuMode.Home);
			}
		}

		private void OnChangeMode()
		{
			if (Mode == MenuMode.Home)
			{
				OpenHomeMenu();
			}
			else
			{
				OpenSubMenu();
			}
		}

		private void OpenHomeMenu()
		{
			menuAnimator.SetBool("Wipe", value: false);
			menuAnimator.SetBool("Ring", value: true);
			_subMenuManager.ToggleSubMenu(MenuMode.Home);
		}

		private void OpenSubMenu()
		{
			_subMenuManager.ToggleSubMenu(Mode);
			menuAnimator.SetBool("Wipe", value: true);
			if (_subMenuManager.IsCurrentWipesRing())
			{
				menuAnimator.SetBool("Ring", value: false);
			}
		}

		private bool OnCancelSubMenu()
		{
			return _subMenuManager.OnCancelButton();
		}

		public void OpenConfirm(string text, Action<bool> func)
		{
			_subMenuManager.OpenConfirm(new SubMenuBase.ConfirmParam(text, func));
		}

		public bool GetProhibitions(MenuMode target)
		{
			if (target == MenuMode.Closed)
			{
				return false;
			}
			return m_prohibitions[(int)target];
		}

		public void SetProhibitions(MenuMode target, bool flag)
		{
			if (target != MenuMode.Closed)
			{
				m_prohibitions[(int)target] = flag;
			}
		}

		private bool SetPositionToMainCamera()
		{
			return positioner.SetPositionToMainCamera();
		}

		private void ForceSetPositionToMainCamera()
		{
			positioner.SetPositionToMainCamera(forceAdjust: true);
		}

		public void AttachTo(Transform tf)
		{
			positioner.AttachTo(tf);
		}

		public void RevertToParent()
		{
			positioner.RevertToParent();
		}

		public void PlaySeOpen()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Open, uiSoundSource);
		}

		public void PlaySeClose()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Close, uiSoundSource);
		}

		public void PlaySeSelect()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Select, uiSoundSource);
		}

		public void PlaySeDecide()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Decide, uiSoundSource);
		}

		public void PlaySeConfirm()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Confirm, uiSoundSource);
		}

		public void PlaySeCancel()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Cancel, uiSoundSource);
		}

		public void PlaySeError()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error, uiSoundSource);
		}

		public void PlaySePaging()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, uiSoundSource);
		}

		public void PlaySeScrolling()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, uiSoundSource);
		}

		private void PlaySeErrorCannotOpen()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error);
		}
	}
	public class MainMenuPositioner : MonoBehaviour
	{
		[SerializeField]
		private float _autoRotateDegree = 20f;

		private Transform _contentTransform;

		private bool _isAttachedMain;

		public bool IsFixedToFront
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return false;
				}
				return MainPosition.WindowPositioner.IsFixedToFront;
			}
		}

		public float FrontFixYaw
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return 0f;
				}
				return MainPosition.WindowPositioner.FrontFixYaw;
			}
		}

		public float FrontFixPitch
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return 0f;
				}
				return MainPosition.WindowPositioner.FrontFixPitch;
			}
		}

		public bool IsFixVertical
		{
			get
			{
				if (!SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					return false;
				}
				return MainPosition.WindowPositioner.IsFixVertical;
			}
		}

		private void Awake()
		{
			_contentTransform = base.transform.GetChild(0);
		}

		public void AttachTo(Transform tf)
		{
			_contentTransform.SetParent(tf, worldPositionStays: false);
		}

		public void RevertToParent()
		{
			_contentTransform.SetParent(base.transform, worldPositionStays: false);
		}

		public bool SetPositionToMainCamera(bool forceAdjust = false)
		{
			Transform headTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
			Vector3 position = headTransform.position;
			Quaternion rotation = headTransform.rotation;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			Quaternion quaternion;
			if (IsFixedToFront)
			{
				if (IsFixVertical)
				{
					num = FrontFixPitch;
				}
				quaternion = Quaternion.Euler(num, MainPosition.MainTransform.eulerAngles.y + FrontFixYaw, 0f);
			}
			else
			{
				quaternion = Quaternion.Euler(num, (rotation * Quaternion.Euler(0f - num, 0f, 0f)).eulerAngles.y, 0f);
			}
			if (forceAdjust || Quaternion.Angle(_contentTransform.rotation, quaternion) > _autoRotateDegree)
			{
				_contentTransform.position = position;
				_contentTransform.rotation = quaternion;
				return true;
			}
			return false;
		}
	}
	public class MainMenuButton : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Transform visualTrans;

		[SerializeField]
		private Button button;

		[SerializeField]
		private Animator anim;

		[SerializeField]
		private Image buttonImage;

		[Header("Parameters")]
		[SerializeField]
		private MainMenuManager.MenuMode targetMode;

		[SerializeField]
		private Sprite _spriteNormal;

		[SerializeField]
		private Sprite _spriteFocused;

		[SerializeField]
		private Sprite _spriteDisabled;

		private bool m_isVisible = true;

		private bool m_isProhivited;

		private bool m_isButtonDown;

		private int m_buttonIndex;

		private Transform m_trans;

		private MainMenuButtonPositioner m_parent;

		private Vector3 m_originPos;

		private float m_floatCount;

		private float m_titleCount;

		public MainMenuManager.MenuMode TargetMode => targetMode;

		private float selectFloatDist => m_parent.selectFloatDist;

		private float selectFloatSpeed => m_parent.selectFloatSpeed;

		private float buttonDownDist => m_parent.buttonDownDist;

		private float titleFloatSpeed => m_parent.titleFloatSpeed;

		private Transform titleTarget => m_parent.titleTarget;

		private int focusIndex => m_parent.GetFocusIndex();

		private void Awake()
		{
			m_trans = base.transform;
			m_originPos = m_trans.localPosition;
			buttonImage.sprite = _spriteNormal;
			UpdateSpriteState();
		}

		private void UpdateSpriteState()
		{
			SpriteState spriteState = button.spriteState;
			spriteState.highlightedSprite = _spriteFocused;
			spriteState.disabledSprite = (m_isProhivited ? _spriteDisabled : _spriteFocused);
			button.spriteState = spriteState;
		}

		public void SetButtonIndex(int i)
		{
			m_buttonIndex = i;
		}

		public void SetParent(MainMenuButtonPositioner p)
		{
			m_parent = p;
		}

		public void Init()
		{
			MakeTriggers();
		}

		private void MakeTriggers()
		{
			ObservableEventTrigger observableEventTrigger = base.gameObject.AddComponent<ObservableEventTrigger>();
			observableEventTrigger.OnPointerEnterAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocused(data, isEntered: true);
			}).AddTo(base.gameObject);
			observableEventTrigger.OnPointerExitAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocused(data, isEntered: false);
			}).AddTo(base.gameObject);
			observableEventTrigger.OnPointerDownAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangePressed(data, isEntered: true);
			}).AddTo(base.gameObject);
			observableEventTrigger.OnPointerUpAsObservable().Subscribe(delegate(PointerEventData data)
			{
				OnChangePressed(data, isEntered: false);
			}).AddTo(base.gameObject);
			button.OnClickAsObservable().Subscribe(delegate
			{
				OnClickButton();
			}).AddTo(base.gameObject);
		}

		private void ChangeFocusIndex()
		{
			m_parent.ChangeFocusIndex(m_buttonIndex);
		}

		private void RemoveFocusIndex()
		{
			if (m_parent.GetFocusIndex() == m_buttonIndex)
			{
				m_parent.ChangeFocusIndex(-1);
			}
		}

		public void UpdateAll()
		{
			UpdatePosition();
			UpdateVisualPosition(Time.deltaTime);
		}

		private void UpdatePosition()
		{
			Vector3 originPos = m_originPos;
			Vector3 localPosition = originPos;
			float num = Time.deltaTime * titleFloatSpeed;
			if (m_parent.isTitled && m_isVisible)
			{
				m_titleCount = Mathf.Min(m_titleCount + num, 1f);
			}
			else
			{
				m_titleCount = Mathf.Max(m_titleCount - num, 0f);
			}
			if (m_titleCount > 0f)
			{
				localPosition = titleTarget.localPosition * m_titleCount + originPos * (1f - m_titleCount);
			}
			m_trans.localPosition = localPosition;
		}

		private void UpdateVisualPosition(float delta)
		{
			Vector3 localPosition = Vector3.zero;
			float num = Mathf.Min(delta * selectFloatSpeed, 1f);
			float num2 = 0f;
			if (m_parent.isTitled)
			{
				m_floatCount = 0f;
			}
			else
			{
				if (focusIndex >= 0)
				{
					num2 = 1f / (1f + (float)Mathf.Abs(focusIndex - m_buttonIndex) * 2f);
					if (m_isButtonDown)
					{
						num2 -= buttonDownDist;
					}
				}
				m_floatCount = num2 * num + m_floatCount * (1f - num);
				localPosition = new Vector3(0f, 0f, (0f - selectFloatDist) * m_floatCount);
			}
			visualTrans.localPosition = localPosition;
		}

		public void ForcePosition()
		{
			UpdateVisualPosition(100f);
		}

		public void ToggleVisible(bool flag)
		{
			anim.SetBool("Visible", flag);
			m_isVisible = flag;
		}

		public void ToggleInteractable(bool flag)
		{
			button.interactable = flag;
		}

		public void ToggleProhibitState(bool flag)
		{
			if (m_isProhivited != flag)
			{
				m_isProhivited = flag;
				UpdateSpriteState();
			}
		}

		private void OnChangeFocused(PointerEventData pointer, bool isEntered)
		{
			if (isEntered)
			{
				ChangeFocusIndex();
			}
			else
			{
				RemoveFocusIndex();
			}
			if (isEntered && button.interactable && !m_isButtonDown)
			{
				GameInputHelper.VibrateLaserForFocus(pointer.GetLaserController());
				SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeSelect();
			}
		}

		private void OnChangePressed(PointerEventData pointer, bool isEntered)
		{
			m_isButtonDown = isEntered;
			if (isEntered)
			{
				GameInputHelper.VibrateLaserForPress(pointer.GetLaserController());
				if (!button.interactable)
				{
					SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeError();
				}
			}
		}

		private void OnClickButton()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeDecide();
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetMenuMode(TargetMode);
		}
	}
	public class MainMenuButtonPositioner : UpdateableComponent
	{
		[SerializeField]
		private float _selectFloatDist = 0.15f;

		[SerializeField]
		private float _selectFloatSpeed = 10f;

		[SerializeField]
		private float _buttonDownDist = 0.05f;

		[SerializeField]
		private float _titleFloatSpeed = 4f;

		[SerializeField]
		private Transform _titleTarget;

		private MainMenuButton[] m_buttons;

		private int m_focusIndex = -1;

		public bool isTitled { get; private set; }

		public float selectFloatDist => _selectFloatDist;

		public float selectFloatSpeed => _selectFloatSpeed;

		public float buttonDownDist => _buttonDownDist;

		public float titleFloatSpeed => _titleFloatSpeed;

		public Transform titleTarget => _titleTarget;

		protected override void Initialize()
		{
			InitButtons();
		}

		private void InitButtons()
		{
			m_buttons = GetComponentsInChildren<MainMenuButton>();
			int num = 0;
			MainMenuButton[] buttons = m_buttons;
			foreach (MainMenuButton obj in buttons)
			{
				obj.SetParent(this);
				obj.SetButtonIndex(num);
				obj.Init();
				num++;
			}
		}

		public void ChangeFocusIndex(int i)
		{
			m_focusIndex = i;
		}

		public int GetFocusIndex()
		{
			return m_focusIndex;
		}

		public void SetTitle(int id)
		{
			isTitled = id != -1;
			for (int i = 0; i < m_buttons.Length; i++)
			{
				MainMenuButton mainMenuButton = m_buttons[i];
				mainMenuButton.ToggleVisible(!isTitled || i == id);
				mainMenuButton.ToggleProhibitState(!GetButtonAllowed(mainMenuButton));
				mainMenuButton.ToggleInteractable(GetButtonAvailable(mainMenuButton));
			}
		}

		public void SetTitleImmediete(int id)
		{
			isTitled = id != -1;
			for (int i = 0; i < m_buttons.Length; i++)
			{
				MainMenuButton mainMenuButton = m_buttons[i];
				mainMenuButton.ToggleVisible(!isTitled || i == id);
				mainMenuButton.ToggleProhibitState(!GetButtonAllowed(mainMenuButton));
				mainMenuButton.ToggleInteractable(GetButtonAvailable(mainMenuButton));
				mainMenuButton.ForcePosition();
			}
		}

		public bool GetButtonAvailable(MainMenuButton button)
		{
			if (isTitled)
			{
				return false;
			}
			return GetButtonAllowed(button);
		}

		public bool GetButtonAllowed(MainMenuButton button)
		{
			MainMenuManager.MenuMode targetMode = button.TargetMode;
			if (SingletonMonoBehaviour<MainMenuManager>.Instance.GetProhibitions(targetMode))
			{
				return false;
			}
			switch (targetMode)
			{
			case MainMenuManager.MenuMode.SkipMode:
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsInGame && InGameManager.Timeline.IsScenarioSkippable)
				{
					return InGameManager.Timeline.IsSkipAllowed;
				}
				return false;
			case MainMenuManager.MenuMode.Note:
				return SingletonMonoBehaviour<MasterManager>.Instance.IsInGame;
			case MainMenuManager.MenuMode.Save:
				return SingletonMonoBehaviour<MasterManager>.Instance.IsInGame;
			case MainMenuManager.MenuMode.Title:
				return !SingletonMonoBehaviour<MasterManager>.Instance.IsTitleScene;
			default:
				return true;
			}
		}

		public override void OnUpdate(float delta)
		{
			MainMenuButton[] buttons = m_buttons;
			for (int i = 0; i < buttons.Length; i++)
			{
				buttons[i].UpdateAll();
			}
		}
	}
	public class MenuButtonFloater : UpdateableComponent
	{
		[Header("Components")]
		[SerializeField]
		private Button buttonComponent;

		[SerializeField]
		private Transform floatTarget;

		[Header("Parameters")]
		[SerializeField]
		private float floatDistFocus = 20f;

		[SerializeField]
		private float floatDistPress = 10f;

		[SerializeField]
		private float floatDistDisabled = 15f;

		[SerializeField]
		private float floatSpeed = 10f;

		[SerializeField]
		private bool hideIfDisabled;

		[Header("Parameters - Text")]
		[SerializeField]
		private TextMeshProUGUI _textLabel;

		[SerializeField]
		private Color _textColorNormal = Color.white;

		[SerializeField]
		private Color _textColorHighlight = Color.white;

		[SerializeField]
		private Color _textColorPressed = Color.white;

		[SerializeField]
		private Color _textColorDisabled = Color.white;

		private Vector3 _originPos;

		private bool _buttonEnabled;

		private bool _focused;

		private bool _pressed;

		private float _floatCount;

		private Graphic _raycastGraphic;

		private IDisposable _disposerFade;

		private Subject<Unit> _subjectAcceptedForcus = new Subject<Unit>();

		private Subject<Unit> _subjectPressDownError = new Subject<Unit>();

		private IObservable<Unit> _onClick;

		public Button ButtonComponent => buttonComponent;

		public bool IsButtonEnabled => _buttonEnabled;

		public bool HideIfDisabled
		{
			get
			{
				return hideIfDisabled;
			}
			set
			{
				hideIfDisabled = value;
			}
		}

		public IObservable<Unit> AcceptedForcusObservable => _subjectAcceptedForcus;

		public IObservable<Unit> PressDownErrorObservable => _subjectPressDownError;

		public IObservable<Unit> ClickObservable => GetObservableClick();

		public IObservable<PointerEventData> OnFocusStart { get; private set; }

		public IObservable<PointerEventData> OnFocusEnd { get; private set; }

		public IObservable<PointerEventData> OnPressStart { get; private set; }

		public IObservable<PointerEventData> OnPressEnd { get; private set; }

		private void Awake()
		{
			_originPos = floatTarget.localPosition;
			_buttonEnabled = buttonComponent.interactable;
			_raycastGraphic = GetComponent<Graphic>();
			MakePointerEvents();
		}

		private void MakePointerEvents()
		{
			ObservableEventTrigger observableEventTrigger = base.gameObject.AddComponent<ObservableEventTrigger>();
			OnFocusStart = observableEventTrigger.OnPointerEnterAsObservable();
			OnFocusEnd = observableEventTrigger.OnPointerExitAsObservable();
			OnPressStart = observableEventTrigger.OnPointerDownAsObservable();
			OnPressEnd = observableEventTrigger.OnPointerUpAsObservable();
			OnFocusStart.Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocus(data, isEntered: true);
			});
			OnFocusEnd.Subscribe(delegate(PointerEventData data)
			{
				OnChangeFocus(data, isEntered: false);
			});
			OnPressStart.Subscribe(delegate(PointerEventData data)
			{
				OnChangePress(data, isEntered: true);
			});
			OnPressEnd.Subscribe(delegate(PointerEventData data)
			{
				OnChangePress(data, isEntered: false);
			});
			base.gameObject.OnEnableAsObservable().Subscribe(delegate
			{
				base.enabled = true;
				UpdateTextColor();
			});
			base.gameObject.OnDisableAsObservable().Subscribe(delegate
			{
				_focused = (_pressed = false);
			});
		}

		public override void OnUpdate(float deltaTime)
		{
			UpdateVisualPosition(deltaTime);
		}

		private void UpdateVisualPosition(float deltaTime)
		{
			Vector3 zero = Vector3.zero;
			float num = Mathf.Min(deltaTime * floatSpeed, 1f);
			float num2 = 0f;
			if (!_buttonEnabled)
			{
				num2 = floatDistDisabled / floatDistFocus;
			}
			else if (_focused && _pressed)
			{
				num2 = floatDistPress / floatDistFocus;
			}
			else if (_focused || _pressed)
			{
				num2 = 1f;
			}
			_floatCount = num2 * num + _floatCount * (1f - num);
			zero = new Vector3(0f, 0f, (0f - floatDistFocus) * _floatCount);
			floatTarget.localPosition = _originPos + zero;
			if (Mathf.Abs(_floatCount - num2) < 0.005f)
			{
				base.enabled = false;
			}
		}

		private void ToggleFocused(bool flag)
		{
			if (_focused != flag)
			{
				_focused = flag;
				base.enabled = true;
				UpdateTextColor();
			}
		}

		private void TogglePressed(bool flag)
		{
			if (_pressed != flag)
			{
				_pressed = flag;
				base.enabled = true;
				UpdateTextColor();
			}
		}

		public void ToggleEnabled(bool flag)
		{
			if (_buttonEnabled != flag)
			{
				_buttonEnabled = flag;
				buttonComponent.interactable = flag;
				if (!flag)
				{
					ToggleFocused(flag: false);
					TogglePressed(flag: false);
				}
				base.enabled = true;
				if (HideIfDisabled)
				{
					AnimateSpriteFade();
				}
				UpdateTextColor();
			}
		}

		private IObservable<Unit> GetObservableClick()
		{
			if (_onClick == null)
			{
				_onClick = buttonComponent.OnClickAsObservable();
			}
			return _onClick;
		}

		private void OnChangeFocus(PointerEventData pointer, bool isEntered)
		{
			ToggleFocused(isEntered);
			if (isEntered && _buttonEnabled && !_pressed)
			{
				GameInputHelper.VibrateLaserForFocus(pointer.GetLaserController());
				_subjectAcceptedForcus.OnNext(Unit.Default);
			}
		}

		private void OnChangePress(PointerEventData pointer, bool isEntered)
		{
			TogglePressed(isEntered);
			if (isEntered)
			{
				GameInputHelper.VibrateLaserForPress(pointer.GetLaserController());
				if (!_buttonEnabled)
				{
					_subjectPressDownError.OnNext(Unit.Default);
				}
			}
		}

		private void UpdateTextColor()
		{
			if (!(_textLabel == null))
			{
				if (!_buttonEnabled)
				{
					_textLabel.color = _textColorDisabled;
				}
				else if (_pressed)
				{
					_textLabel.color = _textColorPressed;
				}
				else if (_focused)
				{
					_textLabel.color = _textColorHighlight;
				}
				else
				{
					_textLabel.color = _textColorNormal;
				}
			}
		}

		private void AnimateSpriteFade()
		{
			if (_disposerFade != null)
			{
				_disposerFade.Dispose();
			}
			if (_raycastGraphic != null)
			{
				_raycastGraphic.raycastTarget = _buttonEnabled;
			}
			if (buttonComponent.targetGraphic != null)
			{
				buttonComponent.targetGraphic.raycastTarget = _buttonEnabled;
			}
			float targetAlpha = (_buttonEnabled ? 1f : 0f);
			_disposerFade = Observable.FromMicroCoroutine((CancellationToken _) => RoutineSpriteFade(targetAlpha)).Subscribe(delegate
			{
				_disposerFade = null;
			});
		}

		private IEnumerator RoutineSpriteFade(float alpha)
		{
			Graphic image = buttonComponent.targetGraphic;
			Color end = image.color.WithAlpha(alpha);
			Tweener<Color> tweener = new Tweener<Color>(Color.Lerp);
			tweener.Start(image.color, end, 0.2f);
			while (tweener.IsActive)
			{
				tweener.Update(Time.deltaTime);
				image.color = tweener.CurrentValue;
				yield return null;
			}
		}

		protected override void OnShutdown()
		{
			if (_disposerFade != null)
			{
				_disposerFade.Dispose();
			}
		}

		public void SetWidth(float w)
		{
			GetComponent<RectTransform>().SetWidth(w);
		}

		public void SetSprites(Sprite normal, Sprite selected)
		{
			Image image = buttonComponent.targetGraphic as Image;
			if (image != null)
			{
				image.sprite = normal;
			}
			SpriteState spriteState = buttonComponent.spriteState;
			spriteState.highlightedSprite = selected;
			spriteState.disabledSprite = selected;
			buttonComponent.spriteState = spriteState;
		}
	}
	public class ToggleButtonSet : MonoBehaviour
	{
		private int _currentValue = -1;

		private List<MenuButtonFloater> _buttonsList = new List<MenuButtonFloater>();

		private ISoundableMenu _soundableMenu;

		private Subject<int> _subjectToggleClick = new Subject<int>();

		public int CurrentValue
		{
			get
			{
				return _currentValue;
			}
			set
			{
				SetToggle(value);
			}
		}

		public IObservable<int> OnClickToggle => _subjectToggleClick;

		public ISoundableMenu SoundableMenu
		{
			set
			{
				_soundableMenu = value;
			}
		}

		public void AddToggleButton(MenuButtonFloater button)
		{
			int index = _buttonsList.Count;
			_buttonsList.Add(button);
			button.ClickObservable.Subscribe(delegate
			{
				if (_soundableMenu != null)
				{
					_soundableMenu.PlaySeDecide();
				}
				SetToggle(index);
				_subjectToggleClick.OnNext(index);
			}).AddTo(base.gameObject);
			button.AcceptedForcusObservable.Subscribe(delegate
			{
				if (_soundableMenu != null)
				{
					_soundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		public void SetToggle(int index)
		{
			_currentValue = index;
			for (int i = 0; i < _buttonsList.Count; i++)
			{
				_buttonsList[i].ToggleEnabled(i != index);
			}
		}
	}
	public interface ISoundableMenu
	{
		void PlaySeOpen();

		void PlaySeClose();

		void PlaySeSelect();

		void PlaySeDecide();

		void PlaySeConfirm();

		void PlaySeCancel();

		void PlaySeError();

		void PlaySePaging();

		void PlaySeScrolling();
	}
	public class APMImage : MonoBehaviour
	{
		[SerializeField]
		private Image image;

		[SerializeField]
		private Sprite spriteAM;

		[SerializeField]
		private Sprite spritePM;

		public void ChangeImage(bool isPM)
		{
			image.sprite = (isPM ? spritePM : spriteAM);
		}

		public void SetVisible(bool visible)
		{
			if (image.enabled != visible)
			{
				image.enabled = visible;
			}
		}
	}
	public class BacklogPanel : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private RectTransform _thisRect;

		[SerializeField]
		private Image _backImage;

		[SerializeField]
		private TextMeshProUGUI _TMPName;

		[SerializeField]
		private TextMeshProUGUI _TMPMessage;

		[SerializeField]
		private LayoutElement _layout;

		private bool _isActive;

		private bool _isVisible;

		private float _defaultHeight;

		private bool IsPhisicallyVisible
		{
			get
			{
				if (_isActive)
				{
					return _isVisible;
				}
				return false;
			}
		}

		public bool IsActive => _isActive;

		private void Awake()
		{
			_defaultHeight = _layout.preferredHeight;
		}

		public void SetVisible(bool flag)
		{
			_isVisible = flag;
			UpdateVisible();
		}

		public void CheckVisibility(RectTransform viewTrans, RectTransform parentTrans)
		{
			Rect rect = _thisRect.rect;
			Rect rect2 = viewTrans.rect;
			rect.y += parentTrans.localPosition.y + _thisRect.localPosition.y;
			SetVisible(rect.yMin <= rect2.yMax && rect.yMax >= rect2.yMin);
		}

		public void SetMessageActive(bool flag)
		{
			_isActive = flag;
			_layout.ignoreLayout = !flag;
			_layout.preferredHeight = (flag ? _defaultHeight : 0f);
			UpdateVisible();
		}

		public void UpdateVisible()
		{
			bool isPhisicallyVisible = IsPhisicallyVisible;
			_backImage.enabled = isPhisicallyVisible;
			_TMPName.enabled = isPhisicallyVisible;
			_TMPMessage.enabled = isPhisicallyVisible;
		}

		public void SetNameText(string str)
		{
			_TMPName.text = str;
		}

		public void SetMessageText(string str)
		{
			_TMPMessage.text = str;
		}

		public void Clear()
		{
			_TMPName.text = "";
			_TMPMessage.text = "";
			SetMessageActive(flag: false);
		}
	}
	public abstract class BaseConfigPart : MonoBehaviour
	{
		[Header("Components - Labels")]
		[SerializeField]
		private TextMeshProUGUI _labelComponent;

		[Header("Base Parameters")]
		[SerializeField]
		private SubMenuConfig.ConfigTypes type;

		public SubMenuConfig.ConfigTypes ConfigType => type;

		public string LabelText
		{
			set
			{
				if (_labelComponent != null)
				{
					_labelComponent.text = value;
				}
			}
		}

		public virtual IObservable<int> ValueSelectedObservable => null;

		public virtual int CurrentValueInt
		{
			get
			{
				return -1;
			}
			set
			{
			}
		}

		public virtual void SetSoundableMenu(ISoundableMenu ism)
		{
		}

		private void Start()
		{
			SubMenuConfig.ConfigTypes configTypes = type;
			if (configTypes == SubMenuConfig.ConfigTypes.PreferredHand && SingletonMonoBehaviour<GameInputManager>.Instance.IsOneSideController)
			{
				base.gameObject.SetActive(value: false);
			}
		}
	}
	public class ConfigPartToggles : BaseConfigPart
	{
		[Serializable]
		public class ToggleParam
		{
			public float Width = 16f;

			public Sprite SpriteNormal;

			public Sprite SpriteSelected;
		}

		[Header("Prefabs - Button")]
		[SerializeField]
		private MenuButtonFloater _prefabButton;

		[Header("Components - Toggle")]
		[SerializeField]
		private ToggleButtonSet _toggleButtonSet;

		[Header("Parameters - Toggle Setting")]
		[SerializeField]
		private ToggleParam[] _toggleParams;

		public override IObservable<int> ValueSelectedObservable => _toggleButtonSet.OnClickToggle;

		public override int CurrentValueInt
		{
			get
			{
				return _toggleButtonSet.CurrentValue;
			}
			set
			{
				_toggleButtonSet.CurrentValue = value;
			}
		}

		private void Awake()
		{
			Transform parent = _toggleButtonSet.transform;
			ToggleParam[] toggleParams = _toggleParams;
			foreach (ToggleParam toggleParam in toggleParams)
			{
				MenuButtonFloater menuButtonFloater = UnityEngine.Object.Instantiate(_prefabButton, parent, worldPositionStays: false);
				menuButtonFloater.SetSprites(toggleParam.SpriteNormal, toggleParam.SpriteSelected);
				menuButtonFloater.SetWidth(toggleParam.Width);
				_toggleButtonSet.AddToggleButton(menuButtonFloater);
			}
		}

		public override void SetSoundableMenu(ISoundableMenu ism)
		{
			_toggleButtonSet.SoundableMenu = ism;
		}
	}
	public class DegitImage : MonoBehaviour
	{
		[SerializeField]
		private Image image;

		[SerializeField]
		private Sprite[] spritesNum = new Sprite[10];

		private int _prevDegit = -1;

		public void ChangeImage(int degit)
		{
			if (_prevDegit != degit)
			{
				_prevDegit = degit;
				image.sprite = spritesNum[degit];
			}
		}
	}
	public class FileInfoPage : MonoBehaviour
	{
		[SerializeField]
		private MultiPagePart multiPage;

		[SerializeField]
		private Transform contentsTransform;

		private SubMenuFile _fileMenu;

		private List<FileInfoUI> _fileInfos;

		public MultiPagePart pagePart => multiPage;

		public ISoundableMenu SoundableMenu
		{
			set
			{
				for (int i = 0; i < _fileInfos.Count; i++)
				{
					_fileInfos[i].SoundableMenu = value;
				}
			}
		}

		public void SetParentFileMenu(SubMenuFile parent)
		{
			_fileMenu = parent;
		}

		public void MakeFileInfoUI(FileInfoUI prefab, int amount)
		{
			if (_fileInfos == null)
			{
				_fileInfos = new List<FileInfoUI>();
			}
			for (int i = _fileInfos.Count; i < amount; i++)
			{
				FileInfoUI fileInfoUI = UnityEngine.Object.Instantiate(prefab, contentsTransform, worldPositionStays: false);
				fileInfoUI.SetParentFileMenu(_fileMenu);
				_fileInfos.Add(fileInfoUI);
			}
		}

		public void UpdateInfos(List<GameFileSave.Header> headers, int idStart, bool isLoad)
		{
			for (int i = 0; i < _fileInfos.Count; i++)
			{
				int index = i + idStart;
				_fileInfos[i].InitByHeader(headers[index], isLoad);
			}
		}
	}
	public class FileInfoUI : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater buttonComponent;

		[SerializeField]
		private Image imageThumbnail;

		[SerializeField]
		private TextMeshProUGUI textIndex;

		[SerializeField]
		private TextMeshProUGUI textChapter;

		[SerializeField]
		private TextMeshProUGUI textDate;

		[Header("Parameters")]
		[SerializeField]
		private Color _textColorNormal;

		[SerializeField]
		private Color _textColorFocused;

		private int _fileID;

		private SubMenuFile _fileMenu;

		public ISoundableMenu SoundableMenu { get; set; }

		private void Start()
		{
			MakeSubscribes();
		}

		private void OnEnable()
		{
			SetTextsColor(_textColorNormal);
		}

		public void SetParentFileMenu(SubMenuFile parent)
		{
			_fileMenu = parent;
		}

		public void InitByHeader(GameFileSave.Header head, bool isLoad)
		{
			_fileID = head.fileIndex;
			bool flag = _fileID == 0;
			if (flag)
			{
				textIndex.text = "Auto Save";
			}
			else
			{
				textIndex.text = "File " + _fileID;
			}
			if (head.IsEmpty)
			{
				textChapter.text = "";
				textDate.text = "";
				imageThumbnail.enabled = false;
				buttonComponent.ToggleEnabled(!flag && !isLoad);
			}
			else if (head.IsCorrupted || !SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(head.SequenceID).IsValid)
			{
				textChapter.text = "<sprite=0><sprite=0><sprite=0><sprite=0><sprite=0>";
				textDate.text = "<sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0><sprite=0>";
				imageThumbnail.enabled = false;
				buttonComponent.ToggleEnabled(!flag && !isLoad);
			}
			else
			{
				textChapter.text = ChapterChecker.GetFormattedChapterNumber(head.SequenceID);
				textDate.text = head.SavedTime.ToString(GetDateTimeFormat());
				imageThumbnail.enabled = true;
				imageThumbnail.sprite = FindSaveThumbnailSprite(head.SequenceID);
				buttonComponent.ToggleEnabled(!flag || isLoad);
			}
		}

		private Sprite FindSaveThumbnailSprite(int id)
		{
			Sprite sprite = SingletonMonoBehaviour<DataManager>.Instance.FindSaveThumbnailSprite(id);
			if (sprite == null)
			{
				return null;
			}
			return sprite;
		}

		private void MakeSubscribes()
		{
			buttonComponent.ClickObservable.Subscribe(delegate
			{
				OnClickUIButton();
			}).AddTo(base.gameObject);
			buttonComponent.AcceptedForcusObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			buttonComponent.PressDownErrorObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeError();
				}
			}).AddTo(base.gameObject);
			buttonComponent.OnFocusStart.Subscribe(delegate
			{
				OnChangeFocused(focused: true);
			}).AddTo(base.gameObject);
			buttonComponent.OnFocusEnd.Subscribe(delegate
			{
				OnChangeFocused(focused: false);
			}).AddTo(base.gameObject);
		}

		private string GetDateTimeFormat()
		{
			return "yyyy/MM/dd HH:mm:ss";
		}

		private void OnClickUIButton()
		{
			_fileMenu.OnSelectFile(_fileID);
		}

		private void OnChangeFocused(bool focused)
		{
			if (!buttonComponent.IsButtonEnabled)
			{
				SetTextsColor(_textColorNormal);
			}
			else if (focused)
			{
				SetTextsColor(_textColorFocused);
			}
			else
			{
				SetTextsColor(_textColorNormal);
			}
		}

		private void SetTextsColor(Color color)
		{
			textIndex.color = color;
			textChapter.color = color;
			textDate.color = color;
		}
	}
	public class MenuClock : UpdateableComponent
	{
		[SerializeField]
		private DegitImage[] degits = new DegitImage[4];

		[SerializeField]
		private Image imageColon;

		[SerializeField]
		private APMImage objectAPM;

		[SerializeField]
		private bool is24Hour;

		private void UpdateImagesByTime(DateTime time)
		{
			int num = time.Hour;
			int minute = time.Minute;
			int millisecond = time.Millisecond;
			if (!is24Hour)
			{
				objectAPM.SetVisible(visible: true);
				ChangeAPMImage(num);
				if (num > 12)
				{
					num -= 12;
				}
			}
			else
			{
				objectAPM.SetVisible(visible: false);
			}
			ChangeDegitNumber(0, num / 10);
			ChangeDegitNumber(1, num % 10);
			ChangeDegitNumber(2, minute / 10);
			ChangeDegitNumber(3, minute % 10);
			ChangeColonAppearance(millisecond);
		}

		private void ChangeDegitNumber(int degitId, int degitNumber)
		{
			degits[degitId].ChangeImage(degitNumber);
		}

		private void ChangeColonAppearance(int ms)
		{
			if (ms < 500)
			{
				imageColon.color = Color.white;
			}
			else
			{
				imageColon.color = Color.clear;
			}
		}

		private void ChangeAPMImage(int hour)
		{
			objectAPM.ChangeImage(hour >= 12);
		}

		public override void OnUpdate(float deltaTime)
		{
			UpdateImagesByTime(DateTime.Now);
		}
	}
	public class MultiPageContent : UpdateableComponent
	{
		[SerializeField]
		private List<MultiPagePart> pages;

		[SerializeField]
		private MenuButtonFloater buttonPrev;

		[SerializeField]
		private MenuButtonFloater buttonNext;

		private int _currentPageIndex;

		public ISoundableMenu SoundableMenu { get; set; }

		public int CurrentPageIndex => _currentPageIndex;

		private int pageMax => pages.Count - 1;

		protected override void Initialize()
		{
			InitContent(_currentPageIndex);
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			buttonPrev.ClickObservable.Subscribe(delegate
			{
				PagePrev();
			}).AddTo(base.gameObject);
			buttonPrev.AcceptedForcusObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			buttonNext.ClickObservable.Subscribe(delegate
			{
				PageNext();
			}).AddTo(base.gameObject);
			buttonNext.AcceptedForcusObservable.Subscribe(delegate
			{
				if (SoundableMenu != null)
				{
					SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float deltaTime)
		{
			if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Left))
			{
				PagePrev();
			}
			if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Right))
			{
				PageNext();
			}
		}

		public void InitContent(int firstPage = -1)
		{
			if (pages == null)
			{
				pages = new List<MultiPagePart>();
				return;
			}
			_currentPageIndex = firstPage;
			for (int i = 0; i < pages.Count; i++)
			{
				MultiPagePart multiPagePart = pages[i];
				if (i == firstPage)
				{
					multiPagePart.ToggleVisible(flag: true, isNext: false, isInstant: true);
				}
				else
				{
					multiPagePart.ToggleVisible(flag: false, isNext: false, isInstant: true);
				}
			}
			UpdatePageButton();
		}

		public void AddPage(MultiPagePart page)
		{
			pages.Add(page);
		}

		public void GoToPage(int destPage, bool isInstant = false)
		{
			if (destPage != _currentPageIndex && destPage >= 0 && destPage <= pageMax)
			{
				bool isNext = _currentPageIndex < destPage;
				MultiPagePart multiPagePart = pages[_currentPageIndex];
				MultiPagePart multiPagePart2 = pages[destPage];
				_currentPageIndex = destPage;
				if (multiPagePart != null)
				{
					multiPagePart.ToggleVisible(flag: false, isNext, isInstant);
				}
				if (multiPagePart2 != null)
				{
					multiPagePart2.ToggleVisible(flag: true, isNext, isInstant);
				}
				UpdatePageButton();
			}
		}

		public void PagePrev()
		{
			if (_currentPageIndex > 0)
			{
				GoToPage(_currentPageIndex - 1);
				PageSound();
			}
		}

		public void PageNext()
		{
			if (_currentPageIndex < pageMax)
			{
				GoToPage(_currentPageIndex + 1);
				PageSound();
			}
		}

		private void UpdatePageButton()
		{
			bool flag = _currentPageIndex > 0;
			bool flag2 = _currentPageIndex < pageMax;
			buttonPrev.ToggleEnabled(flag);
			buttonNext.ToggleEnabled(flag2);
		}

		private void PageSound()
		{
			if (SoundableMenu != null)
			{
				SoundableMenu.PlaySePaging();
			}
		}
	}
	public class MultiPageFader : UpdateableComponent
	{
		[SerializeField]
		private Transform moveTarget;

		[SerializeField]
		private CanvasGroup canvasGroup;

		[SerializeField]
		private Vector3 fadeDistance = new Vector3(50f, 0f, 0f);

		[SerializeField]
		private float fadeSpeed = 4f;

		private bool _fading;

		private Vector3 _originPosition;

		private float _fadeValue;

		private float _targetFade;

		private UnityAction _onEndFade;

		private void Awake()
		{
			_originPosition = moveTarget.localPosition;
		}

		private void OnEnable()
		{
			_fading = true;
		}

		private void OnDisable()
		{
			_fading = false;
		}

		public override void OnUpdate(float deltaTime)
		{
			UpdateFadeTick();
			UpdateVisual();
			if (!_fading)
			{
				if (_onEndFade != null)
				{
					_onEndFade();
				}
				base.enabled = false;
			}
		}

		private void UpdateFadeTick()
		{
			bool flag = _fadeValue < _targetFade;
			float num = Time.deltaTime * fadeSpeed * (float)(flag ? 1 : (-1));
			_fadeValue += num;
			if (_fadeValue >= _targetFade == flag)
			{
				_fadeValue = _targetFade;
				_fading = false;
			}
		}

		private void UpdateVisual()
		{
			float num = _fadeValue * _fadeValue * (float)((_fadeValue > 0f) ? 1 : (-1));
			Vector3 localPosition = _originPosition + fadeDistance * num;
			float alpha = 1f - Mathf.Abs(_fadeValue);
			moveTarget.localPosition = localPosition;
			canvasGroup.alpha = alpha;
		}

		public void StartFade(float target)
		{
			base.enabled = true;
			_fading = true;
			_targetFade = target;
		}

		public void StartFade(float target, float start)
		{
			base.enabled = true;
			_fading = true;
			_targetFade = target;
			_fadeValue = start;
		}

		public void SetOnFadeEnd(UnityAction func)
		{
			_onEndFade = func;
		}

		public void ForceSetFade(float fade)
		{
			_fadeValue = fade;
			UpdateVisual();
		}
	}
	public class MultiPagePart : MonoBehaviour
	{
		[SerializeField]
		private CanvasGroup canvasGroup;

		[SerializeField]
		private MultiPageFader fader;

		private bool _visible = true;

		public void ResetPageState()
		{
			ToggleVisible(flag: false, isNext: false, isInstant: true);
		}

		public void ToggleVisible(bool flag, bool isNext, bool isInstant = false)
		{
			if (flag == _visible)
			{
				return;
			}
			if (!_visible)
			{
				OnStartVisible();
			}
			_visible = flag;
			if (isInstant)
			{
				if (_visible)
				{
					fader.ForceSetFade(0f);
				}
				else
				{
					OnEndVisible();
				}
			}
			else if (_visible)
			{
				canvasGroup.alpha = 0f;
				fader.StartFade(0f, isNext ? 1 : (-1));
				fader.SetOnFadeEnd(null);
			}
			else
			{
				fader.StartFade((!isNext) ? 1 : (-1));
				fader.SetOnFadeEnd(OnEndVisible);
			}
		}

		private void OnStartVisible()
		{
			base.gameObject.SetActive(value: true);
			canvasGroup.interactable = true;
		}

		private void OnEndVisible()
		{
			base.gameObject.SetActive(value: false);
			canvasGroup.interactable = false;
		}
	}
	public class SubMenuBacklog : SubMenuBase
	{
		private const int INITIAL_PANEL_INSTANCE = 64;

		private const int INITIALIZE_NUMBER_PER_RESERVE = 16;

		[Header("Prefabs")]
		[SerializeField]
		private BacklogPanel _prefabBacklogPanel;

		[Header("Components")]
		[SerializeField]
		private RectTransform _viewRect;

		[SerializeField]
		private RectTransform _backlogPanelParent;

		[SerializeField]
		private ScrollRect _scrollRect;

		private int _currentIndex = -1;

		private Stack<BacklogPanel> _unusedInstances = new Stack<BacklogPanel>();

		private List<BacklogPanel> _panelInstances = new List<BacklogPanel>();

		private IObservable<Vector2> _observableScroll;

		protected override void SubmenuStart()
		{
			MakeSubscribes();
			MakeInitialInstances();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnLoadCompleteInGame.Subscribe(delegate
			{
				MakeInGameSubscribes();
			}).AddTo(base.gameObject);
			_observableScroll = _scrollRect.OnValueChangedAsObservable();
			_observableScroll.Subscribe(delegate
			{
				foreach (BacklogPanel panelInstance in _panelInstances)
				{
					if (panelInstance.IsActive)
					{
						panelInstance.CheckVisibility(_viewRect, _backlogPanelParent);
					}
				}
			}).AddTo(base.gameObject);
			_observableScroll.ThrottleFirst(TimeSpan.FromSeconds(0.25)).Subscribe(delegate(Vector2 scrolls)
			{
				PlayScrollSound(scrolls);
			}).AddTo(base.gameObject);
			base.UpdateObserbable.Where((Unit _) => base.IsVisible).Subscribe(delegate
			{
				Vector2 vRScrollDelta = SingletonMonoBehaviour<GameInputManager>.Instance.GetVRScrollDelta(SingletonMonoBehaviour<GameInputManager>.Instance.CurrentMainHand);
				if (vRScrollDelta.sqrMagnitude > 0.001f)
				{
					_scrollRect.velocity = vRScrollDelta * -500f;
				}
			});
		}

		private void MakeInGameSubscribes()
		{
			if (SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				InGameManager.Timeline.PreloadRequestedObservable.Subscribe(delegate(TimelineDataReader dataReader)
				{
					PreMakeBacklog(dataReader.TextMessageList);
				});
				InGameManager.Timeline.MessageProcessor.OnAddMessageLog.Subscribe(delegate
				{
					AddBacklog();
				});
			}
		}

		private void MakeInitialInstances()
		{
			for (int i = 0; i < 64; i++)
			{
				_unusedInstances.Push(MakePanelInstance());
			}
		}

		private void MakeReserveInstances()
		{
			for (int i = 0; i < 16; i++)
			{
				_unusedInstances.Push(MakePanelInstance());
			}
		}

		private BacklogPanel MakePanelInstance()
		{
			BacklogPanel backlogPanel = UnityEngine.Object.Instantiate(_prefabBacklogPanel);
			backlogPanel.transform.SetParent(_backlogPanelParent, worldPositionStays: false);
			backlogPanel.Clear();
			backlogPanel.SetMessageActive(flag: false);
			return backlogPanel;
		}

		private BacklogPanel FindEmptyPanel()
		{
			if (_unusedInstances.Count <= 0)
			{
				MakeReserveInstances();
			}
			BacklogPanel backlogPanel = _unusedInstances.Pop();
			backlogPanel.transform.SetSiblingIndex(_panelInstances.Count);
			_panelInstances.Add(backlogPanel);
			return backlogPanel;
		}

		private void DisableAllPanel()
		{
			foreach (BacklogPanel panelInstance in _panelInstances)
			{
				panelInstance.Clear();
				_unusedInstances.Push(panelInstance);
			}
			_panelInstances.Clear();
			_currentIndex = -1;
		}

		private void AddBacklog()
		{
			_currentIndex++;
			_panelInstances[_currentIndex].SetMessageActive(flag: true);
		}

		public void PreMakeBacklog(List<CommandText> dataList)
		{
			DisableAllPanel();
			foreach (CommandText data in dataList)
			{
				BacklogPanel backlogPanel = FindEmptyPanel();
				backlogPanel.SetMessageText(data.Text);
				backlogPanel.SetNameText(data.CharaFullName);
			}
		}

		private void PlayScrollSound(Vector2 scrolls)
		{
		}

		protected override void OnOpenMenu()
		{
			_scrollRect.verticalScrollbar.value = 0f;
		}
	}
	public abstract class SubMenuBase : MonoBehaviour
	{
		public class ConfirmParam
		{
			public string Message;

			public Action<bool> OnDecide;

			public ConfirmParam(string message, Action<bool> onDecide)
			{
				Message = message;
				OnDecide = onDecide;
			}
		}

		[Header("Components - Base")]
		[SerializeField]
		private Canvas _submenuCanvas;

		[Header("Parameters - Base")]
		[SerializeField]
		private bool wipeRing;

		[SerializeField]
		private int _layerActive;

		[SerializeField]
		private int _layerInactive = -1;

		private bool _isVisible;

		private bool _isEnabled;

		private Animator _anim;

		private GraphicRaycaster _thisRaycaster;

		private Subject<Unit> _subjectEndSubmenu = new Subject<Unit>();

		private Subject<Unit> _subjectMenuCloseRequested = new Subject<Unit>();

		private Subject<ConfirmParam> _subjectConfirmRequested = new Subject<ConfirmParam>();

		private Subject<Unit> _subjectForceCancelConfirmeRequested = new Subject<Unit>();

		public bool isWipeRing => wipeRing;

		public bool IsVisible => _isVisible;

		public bool IsInitedBySubmenu { get; set; }

		public ISoundableMenu SoundableMenu { get; private set; }

		protected IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public IObservable<Unit> EndSubmenuObservable => _subjectEndSubmenu;

		public IObservable<Unit> MenuCloseRequestedObservable => _subjectMenuCloseRequested;

		public IObservable<ConfirmParam> ConfirmRequestedObservable => _subjectConfirmRequested;

		public IObservable<Unit> ForceCancelConfirmeRequestedObservable => _subjectForceCancelConfirmeRequested;

		private void Awake()
		{
			_thisRaycaster = GetComponent<GraphicRaycaster>();
			_anim = GetComponent<Animator>();
			_anim.enabled = false;
			_isEnabled = base.enabled;
			SubmenuAwake();
		}

		protected virtual void SubmenuAwake()
		{
		}

		private void Start()
		{
			MakeBaseSubscribes();
			SubmenuStart();
		}

		protected virtual void SubmenuStart()
		{
		}

		private void MakeBaseSubscribes()
		{
			UpdateObserbable.Where((Unit _) => base.enabled).Subscribe(delegate
			{
				_anim.Update(Time.deltaTime);
			}).AddTo(base.gameObject);
		}

		public void SetSoundableMenu(ISoundableMenu sound)
		{
			SoundableMenu = sound;
			OnSetSoundableMenu(sound);
		}

		public void ToggleEnable(bool flag)
		{
			if (flag != _isEnabled)
			{
				base.enabled = (_isEnabled = flag);
				base.gameObject.SetActive(flag);
				if (flag)
				{
					_anim.Update(9f);
				}
			}
		}

		public void SetVisible(bool visible)
		{
			if (_isVisible != visible)
			{
				_isVisible = visible;
				ToggleInterractable(visible);
				if (_isVisible)
				{
					ToggleEnable(flag: true);
					OnOpenMenu();
				}
				else
				{
					OnCloseMenu();
				}
				if (_submenuCanvas != null && _submenuCanvas.overrideSorting)
				{
					_submenuCanvas.sortingOrder = (_isVisible ? _layerActive : _layerInactive);
				}
				_anim.SetBool("Visible", _isVisible);
			}
		}

		protected void ToggleInterractable(bool flag)
		{
			_thisRaycaster.enabled = flag;
		}

		protected void BackToHome()
		{
			_subjectEndSubmenu.OnNext(Unit.Default);
		}

		protected void CloseMenu()
		{
			_subjectMenuCloseRequested.OnNext(Unit.Default);
		}

		protected void OpenConfirm(string text, Action<bool> func)
		{
			_subjectConfirmRequested.OnNext(new ConfirmParam(text, func));
		}

		protected void ForceCloseConfirm()
		{
			_subjectForceCancelConfirmeRequested.OnNext(Unit.Default);
		}

		protected virtual void OnOpenMenu()
		{
		}

		protected virtual void OnCloseMenu()
		{
		}

		public virtual bool OnCancelButton()
		{
			return true;
		}

		protected virtual void OnSetSoundableMenu(ISoundableMenu soundMenu)
		{
		}
	}
	public class SubMenuConfig : SubMenuBase
	{
		public enum ConfigTypes
		{
			PlayerHeight,
			MessageHeight,
			MessageSpeed,
			PreferredHand,
			VerticalFollow,
			MAX
		}

		[Header("Components")]
		[SerializeField]
		[EnumLabel(typeof(ConfigTypes))]
		private BaseConfigPart[] _configParts;

		[SerializeField]
		private MultiPageContent multiPage;

		private bool _isConfigValueChanged;

		private ConfigSave ConfigData => SingletonMonoBehaviour<GameData>.Instance.ConfigData;

		protected override void SubmenuStart()
		{
			ToggleEnablePage(flag: false);
			InitConfigStrings();
			MakeSubscribes();
		}

		private void ToggleEnablePage(bool flag)
		{
			multiPage.enabled = flag;
		}

		private void MakeSubscribes()
		{
			BaseConfigPart[] configParts = _configParts;
			foreach (BaseConfigPart baseConfigPart in configParts)
			{
				ConfigTypes type = baseConfigPart.ConfigType;
				baseConfigPart.ValueSelectedObservable.Subscribe(delegate(int index)
				{
					switch (type)
					{
					case ConfigTypes.PlayerHeight:
						ConfigData.PlayerHeight.Value = index - 2;
						break;
					case ConfigTypes.MessageHeight:
						ConfigData.MessageHeight.Value = index - 2;
						break;
					case ConfigTypes.MessageSpeed:
						ConfigData.MessageSpeed.Value = index - 2;
						break;
					case ConfigTypes.PreferredHand:
						if (index == 0)
						{
							ConfigData.PrefferedHand.Value = VRDeviceDefine.HandType.Left;
						}
						else
						{
							ConfigData.PrefferedHand.Value = VRDeviceDefine.HandType.Right;
						}
						break;
					case ConfigTypes.VerticalFollow:
						ConfigData.IsMessageFollowVertical.Value = index == 0;
						break;
					}
					_isConfigValueChanged = true;
				}).AddTo(base.gameObject);
			}
		}

		private void InitConfigStrings()
		{
			for (int i = 0; i < 5; i++)
			{
				BaseConfigPart baseConfigPart = _configParts[i];
				if (!(baseConfigPart == null))
				{
					ConfigTypes configType = baseConfigPart.ConfigType;
					baseConfigPart.LabelText = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString("Config." + configType);
				}
			}
		}

		private void InitButtonToggles()
		{
			for (int i = 0; i < 5; i++)
			{
				BaseConfigPart baseConfigPart = _configParts[i];
				if (!(baseConfigPart == null))
				{
					SetButtonToggles(baseConfigPart);
				}
			}
		}

		private void SetButtonToggles(BaseConfigPart buttonSet)
		{
			ConfigTypes configType = buttonSet.ConfigType;
			int currentValueInt = -1;
			switch (configType)
			{
			case ConfigTypes.PlayerHeight:
				currentValueInt = ConfigData.PlayerHeight.Value + 2;
				break;
			case ConfigTypes.MessageHeight:
				currentValueInt = ConfigData.MessageHeight.Value + 2;
				break;
			case ConfigTypes.MessageSpeed:
				currentValueInt = ConfigData.MessageSpeed.Value + 2;
				break;
			case ConfigTypes.PreferredHand:
				if (ConfigData.PrefferedHand.Value == VRDeviceDefine.HandType.Left)
				{
					currentValueInt = 0;
				}
				if (ConfigData.PrefferedHand.Value == VRDeviceDefine.HandType.Right)
				{
					currentValueInt = 1;
				}
				break;
			case ConfigTypes.VerticalFollow:
				currentValueInt = ((!ConfigData.IsMessageFollowVertical.Value) ? 1 : 0);
				break;
			}
			buttonSet.CurrentValueInt = currentValueInt;
		}

		protected override void OnOpenMenu()
		{
			ToggleEnablePage(flag: true);
			_isConfigValueChanged = false;
			InitButtonToggles();
		}

		protected override void OnCloseMenu()
		{
			ToggleEnablePage(flag: false);
			if (_isConfigValueChanged)
			{
				SingletonMonoBehaviour<GameData>.Instance.SaveConfigData();
				_isConfigValueChanged = false;
			}
		}

		protected override void OnSetSoundableMenu(ISoundableMenu soundMenu)
		{
			multiPage.SoundableMenu = soundMenu;
			BaseConfigPart[] configParts = _configParts;
			for (int i = 0; i < configParts.Length; i++)
			{
				configParts[i].SetSoundableMenu(soundMenu);
			}
		}
	}
	public class SubMenuConfirm : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshProUGUI _textComponent;

		[SerializeField]
		private MenuButtonFloater _buttonYes;

		[SerializeField]
		private MenuButtonFloater _buttonNo;

		private Action<bool> _onDecide;

		protected override void SubmenuStart()
		{
			_buttonYes.ClickObservable.Subscribe(delegate
			{
				OnChoose(isOk: true);
			}).AddTo(this);
			_buttonYes.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			_buttonNo.ClickObservable.Subscribe(delegate
			{
				OnChoose(isOk: false);
			}).AddTo(this);
			_buttonNo.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		private void OnChoose(bool isOk)
		{
			_onDecide(isOk);
			SetVisible(visible: false);
			if (isOk)
			{
				base.SoundableMenu.PlaySeDecide();
			}
			else
			{
				base.SoundableMenu.PlaySeCancel();
			}
		}

		public void SetParam(ConfirmParam param)
		{
			SetDialogText(param.Message);
			SetDecideCallback(param.OnDecide);
		}

		public void SetDialogText(string text)
		{
			_textComponent.text = text;
		}

		public void SetDecideCallback(Action<bool> func)
		{
			_onDecide = func;
		}

		public override bool OnCancelButton()
		{
			OnChoose(isOk: false);
			return true;
		}
	}
	public class SubMenuFile : SubMenuBase
	{
		private const int FILEINFO_PER_PAGE = 3;

		[Header("Prefabs")]
		[SerializeField]
		private FileInfoPage prefabInfoPage;

		[SerializeField]
		private FileInfoUI prefabInfoUI;

		[Header("Components")]
		[SerializeField]
		private Transform infoPageTransform;

		[SerializeField]
		private MultiPageContent multiPage;

		[Header("Parameters")]
		[SerializeField]
		private string _keyConfirmLoad = "ConfirmFileLoad";

		[SerializeField]
		private string _keyConfirmSave = "ConfirmFileOverride";

		private bool _isOpenedConfirm;

		private int _selectedId;

		private List<FileInfoPage> _infoPages;

		private int fileCountMax => 30;

		private bool IsMenuLoad => !IsMenuSave;

		private bool IsMenuSave => SingletonMonoBehaviour<MainMenuManager>.Instance.Mode == MainMenuManager.MenuMode.Save;

		protected override void SubmenuAwake()
		{
			ToggleEnablePage(flag: false);
			MakeAllComponents();
		}

		protected override void SubmenuStart()
		{
		}

		private void ToggleEnablePage(bool flag)
		{
			multiPage.enabled = flag;
		}

		private void MakeAllComponents()
		{
			int num = Mathf.CeilToInt(fileCountMax / 3);
			_infoPages = new List<FileInfoPage>();
			for (int i = 0; i < num; i++)
			{
				FileInfoPage fileInfoPage = UnityEngine.Object.Instantiate(prefabInfoPage, infoPageTransform, worldPositionStays: false);
				fileInfoPage.SetParentFileMenu(this);
				fileInfoPage.MakeFileInfoUI(prefabInfoUI, 3);
				multiPage.AddPage(fileInfoPage.pagePart);
				_infoPages.Add(fileInfoPage);
			}
		}

		protected override void OnOpenMenu()
		{
			_isOpenedConfirm = false;
			ToggleEnablePage(flag: true);
			UpdateFileInfos();
			multiPage.InitContent(SingletonMonoBehaviour<GameData>.Instance.SystemData.LastShowedFilePage);
		}

		protected override void OnCloseMenu()
		{
			SingletonMonoBehaviour<GameData>.Instance.SystemData.LastShowedFilePage = multiPage.CurrentPageIndex;
			ToggleEnablePage(flag: false);
		}

		private void UpdateFileInfos()
		{
			List<GameFileSave.Header> headers = SingletonMonoBehaviour<GameData>.Instance.FindHeaders();
			for (int i = 0; i < _infoPages.Count; i++)
			{
				FileInfoPage fileInfoPage = _infoPages[i];
				int idStart = 3 * i;
				fileInfoPage.UpdateInfos(headers, idStart, IsMenuLoad);
			}
		}

		public void OnSelectFile(int fileID)
		{
			if (_isOpenedConfirm)
			{
				return;
			}
			_isOpenedConfirm = true;
			ToggleInterractable(flag: false);
			_selectedId = fileID;
			if (IsMenuLoad)
			{
				OpenConfirm(string.Format(SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmLoad), GetFileName(fileID)), OnDecideLoad);
			}
			else if (IsMenuSave)
			{
				if (SingletonMonoBehaviour<GameData>.Instance.FindHeaders()[fileID].IsEmpty)
				{
					base.SoundableMenu.PlaySeDecide();
					OnDecideSave(decide: true);
				}
				else
				{
					OpenConfirm(string.Format(SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmSave), GetFileName(fileID)), OnDecideSave);
				}
			}
		}

		private void OnDecideLoad(bool decide)
		{
			_isOpenedConfirm = false;
			if (!decide)
			{
				ToggleInterractable(flag: true);
			}
			else
			{
				StartLoadGame(_selectedId);
			}
		}

		private void OnDecideSave(bool decide)
		{
			_isOpenedConfirm = false;
			if (!decide)
			{
				ToggleInterractable(flag: true);
				return;
			}
			SingletonMonoBehaviour<MasterManager>.Instance.SaveGame(_selectedId);
			BackToHome();
		}

		private string GetFileName(int fileID)
		{
			if (fileID == 0)
			{
				return "Auto Save";
			}
			return "File " + fileID;
		}

		protected virtual void StartLoadGame(int fileId)
		{
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(GameDefine.CharaID.NONE);
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioFromFileWithFade(fileId);
			CloseMenu();
		}

		protected override void OnSetSoundableMenu(ISoundableMenu soundMenu)
		{
			multiPage.SoundableMenu = soundMenu;
			for (int i = 0; i < _infoPages.Count; i++)
			{
				FileInfoPage fileInfoPage = _infoPages[i];
				if (!(fileInfoPage == null))
				{
					fileInfoPage.SoundableMenu = base.SoundableMenu;
				}
			}
		}
	}
	public class SubMenuHelp : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private Image _targetImage;

		[Header("Parameters - Key")]
		[SerializeField]
		private string _keyPrefix = "Help.";

		protected override void OnOpenMenu()
		{
			string key = _keyPrefix + SingletonMonoBehaviour<PlayAreaManager>.Instance.CurrentDeviceType;
			_targetImage.sprite = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeSprite(key);
		}
	}
	public class SubMenuManager : MonoBehaviour
	{
		[Header("Submenu Components")]
		[EnumLabel(typeof(MainMenuManager.MenuMode))]
		[SerializeField]
		private SubMenuBase[] _subMenus;

		[Header("Dialog Components")]
		[SerializeField]
		private SubMenuConfirm _subMenuConfirm;

		[Header("Other Components")]
		[SerializeField]
		private MainMenuButtonPositioner _menuPoser;

		private SubMenuBase _currentSub;

		public bool IsOpenedConfirm => _subMenuConfirm.IsVisible;

		public void InitSubmenuByMainMenu(MainMenuManager mm)
		{
			SubMenuBase[] subMenus = _subMenus;
			foreach (SubMenuBase subMenuBase in subMenus)
			{
				if (!(subMenuBase == null) && !subMenuBase.IsInitedBySubmenu)
				{
					subMenuBase.IsInitedBySubmenu = true;
					subMenuBase.SetSoundableMenu(mm);
					subMenuBase.EndSubmenuObservable.Subscribe(delegate
					{
						mm.BackToHome();
					});
					subMenuBase.MenuCloseRequestedObservable.Subscribe(delegate
					{
						mm.CloseMenu();
					});
					subMenuBase.ConfirmRequestedObservable.Subscribe(delegate(SubMenuBase.ConfirmParam conf)
					{
						OpenConfirm(conf);
					});
				}
			}
			_subMenuConfirm.SetSoundableMenu(mm);
		}

		public void ToggleSubMenu(MainMenuManager.MenuMode tp)
		{
			if (tp != MainMenuManager.MenuMode.Closed)
			{
				SetMenuTitle(tp);
				CloseCurrentSubMenu();
				if (tp != 0 && tp != MainMenuManager.MenuMode.Blank)
				{
					ShowSubMenu(tp);
				}
			}
		}

		private void ShowSubMenu(MainMenuManager.MenuMode tp)
		{
			SubMenuBase subMenuBase = _subMenus[(int)tp];
			if (!(subMenuBase == null))
			{
				subMenuBase.SetVisible(visible: true);
				_currentSub = subMenuBase;
			}
		}

		private void CloseCurrentSubMenu()
		{
			if (!(_currentSub == null))
			{
				_currentSub.SetVisible(visible: false);
				_currentSub = null;
			}
		}

		public void DisableAllSubMenu()
		{
			SubMenuBase[] subMenus = _subMenus;
			foreach (SubMenuBase subMenuBase in subMenus)
			{
				if (!(subMenuBase == null))
				{
					subMenuBase.ToggleEnable(flag: false);
				}
			}
			_subMenuConfirm.ToggleEnable(flag: false);
		}

		public void ForceCloseSubMenu()
		{
			CloseCurrentSubMenu();
		}

		public void OpenConfirm(SubMenuBase.ConfirmParam conf)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.PlaySeConfirm();
			_subMenuConfirm.SetVisible(visible: true);
			_subMenuConfirm.SetParam(conf);
		}

		public void ForceCloseConfirm()
		{
			_subMenuConfirm.OnCancelButton();
		}

		private void SetMenuTitle(MainMenuManager.MenuMode tp)
		{
			int title = (int)(tp - 1);
			_menuPoser.SetTitle(title);
		}

		public void SetMenuTitleImmediete(MainMenuManager.MenuMode tp)
		{
			int titleImmediete = (int)(tp - 1);
			_menuPoser.SetTitleImmediete(titleImmediete);
		}

		public bool IsCurrentWipesRing()
		{
			if (_currentSub == null)
			{
				return false;
			}
			return _currentSub.isWipeRing;
		}

		public bool OnCancelButton()
		{
			if (_currentSub == null)
			{
				return true;
			}
			return _currentSub.OnCancelButton();
		}
	}
	public class SubMenuNote : SubMenuBase
	{
	}
	public class SubMenuSkip : SubMenuBase
	{
		[Header("Texts")]
		[SerializeField]
		private string _keyConfirmText = "ConfirmSkip";

		private void OnDecide(bool decide)
		{
			if (decide)
			{
				InGameManager.Timeline.StartHardSkip();
				CloseMenu();
			}
			else
			{
				BackToHome();
			}
		}

		protected override void OnOpenMenu()
		{
			string localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmText);
			OpenConfirm(localizeString, OnDecide);
		}
	}
	public class SubMenuTitle : SubMenuBase
	{
		[Header("Texts")]
		[SerializeField]
		private string _keyConfirmText = "ConfirmBackTitle";

		[SerializeField]
		private string _keyConfirmTextInGame = "ConfirmBackTitleInGame";

		private void OnDecide(bool decide)
		{
			if (decide)
			{
				SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(GameDefine.CharaID.NONE);
				SingletonMonoBehaviour<MasterManager>.Instance.AutoSave();
				SingletonMonoBehaviour<MasterManager>.Instance.ExitInGameWithFade();
				CloseMenu();
			}
			else
			{
				BackToHome();
			}
		}

		protected override void OnOpenMenu()
		{
			string text = ((!SingletonMonoBehaviour<MasterManager>.Instance.IsInGame) ? SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmText) : SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirmTextInGame));
			OpenConfirm(text, OnDecide);
		}
	}
	public class EmotionImage : MonoBehaviour
	{
		public enum Types
		{
			Angry0,
			Angry1,
			Angry2,
			Ase0,
			Attention,
			Doyo,
			Explanation,
			Guru,
			Heart,
			Impatience,
			Kirakira,
			MAgazine,
			O,
			Smile,
			Surprised,
			Count
		}

		[SerializeField]
		private Ease m_scaleEaseType = Ease.OutBounce;

		[SerializeField]
		private float m_fadeOutDuration = 1f;

		private Tweener m_scaleTween;

		private Tweener m_fadeTween;

		private GameObject m_gameObject;

		private Transform m_transform;

		private SpriteRenderer m_sprite;

		private Vector3 m_startScale;

		private float m_scaleY;

		private float m_monoScale;

		private Transform m_attachTarget;

		private Transform m_lookAt;

		private float m_offsetY;

		private float m_offsetX;

		private bool m_isInitialized;

		private void Start()
		{
			Initialize();
			m_gameObject.SetActive(value: false);
		}

		public void Setup(EmotionImageGenerator.Data data, float tweenDuration, float monoScale)
		{
			m_monoScale = monoScale;
			Initialize();
			SetupTween(tweenDuration);
		}

		private void SetupTween(float duration)
		{
			m_fadeTween = m_sprite.DOFade(0f, m_fadeOutDuration).OnComplete(delegate
			{
				m_gameObject.SetActive(value: false);
			});
			m_fadeTween.SetAutoKill(autoKillOnCompletion: false);
			m_scaleTween = m_transform.DOScaleY(m_transform.localScale.y, duration).SetEase(m_scaleEaseType).OnComplete(delegate
			{
				StartFadeOut();
			});
			m_scaleTween.SetAutoKill(autoKillOnCompletion: false);
		}

		private void Initialize()
		{
			if (!m_isInitialized)
			{
				m_isInitialized = true;
				m_gameObject = base.gameObject;
				m_transform = base.transform;
				m_sprite = GetComponent<SpriteRenderer>();
				m_startScale = m_transform.localScale;
				m_scaleY = m_startScale.y;
				m_startScale.y = 0f;
			}
		}

		public void Open(Transform attachTarget, EmotionImageGenerator.Data data, float duration, ref Vector3 offset, bool isMono, Transform lookAt = null)
		{
			Color color = m_sprite.color;
			color.a = 1f;
			m_sprite.color = color;
			m_lookAt = lookAt;
			m_attachTarget = attachTarget;
			m_offsetY = data.Offset.y;
			m_offsetX = data.Offset.x;
			m_gameObject.SetActive(value: true);
			Vector3 target = m_startScale;
			if (isMono)
			{
				target.y = m_scaleY;
				Vector3Extension.MultiplyTarget(m_monoScale, ref target);
				m_sprite.sprite = data.SpriteMono;
				m_scaleTween.ChangeEndValue(target);
				m_offsetY += target.y - m_scaleY;
				target.y = 0f;
			}
			else
			{
				m_sprite.sprite = data.Sprite;
				m_scaleTween.ChangeEndValue(m_scaleY);
			}
			m_transform.localScale = target;
			UpdateLookAt();
			UpdatePosition(ref offset);
			m_scaleTween.ChangeStartValue(target);
			m_scaleTween.Restart();
		}

		public void StartFadeOut()
		{
			m_fadeTween.Restart();
		}

		private void UpdatePosition(ref Vector3 offset)
		{
			if (!(m_attachTarget == null))
			{
				Vector3 position = m_attachTarget.position;
				m_transform.position = position;
				m_transform.Translate(m_offsetX + offset.x, m_offsetY + offset.y, offset.z, Space.Self);
			}
		}

		private void UpdateLookAt()
		{
			if (m_lookAt != null)
			{
				m_transform.LookAt(m_transform.position + m_lookAt.rotation * Vector3.forward, m_lookAt.rotation * Vector3.up);
			}
		}
	}
	public class EmotionImageGenerator : MonoBehaviour
	{
		[Serializable]
		public class Data
		{
			public Sprite Sprite;

			public Sprite SpriteMono;

			public Vector3 Offset = new Vector3(0f, 1.5f, 0f);
		}

		private const int _POOL_LIST_SIZE = 5;

		[Header("Emotion Sprite Parameters")]
		[SerializeField]
		private List<Data> m_dataList;

		[Header("Misc. Parameters")]
		[SerializeField]
		private float m_emotionDuration = 1f;

		[SerializeField]
		private float m_emotionMonoScale = 2.083f;

		private List<EmotionImage> m_emotions;

		private ListPosition m_emotionListPos;

		private void Awake()
		{
			m_emotions = new List<EmotionImage>(5);
			InitializeTween();
			InitializeListPosition();
		}

		private void InitializeTween()
		{
			Data data = m_dataList[0];
			EmotionImage[] componentsInChildren = GetComponentsInChildren<EmotionImage>();
			int num = componentsInChildren.Length;
			for (int i = 0; i < num; i++)
			{
				componentsInChildren[i].Setup(data, m_emotionDuration, m_emotionMonoScale);
				m_emotions.Add(componentsInChildren[i]);
			}
		}

		private void InitializeListPosition()
		{
			m_emotionListPos = new ListPosition();
			m_emotionListPos.Count = m_emotions.Count;
			m_emotionListPos.Height = 1;
		}

		public void Generate(EmotionImage.Types type, GameDefine.CharaID charaID, ref Vector3 offset)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(charaID);
			if (!(chara == null))
			{
				Generate(type, chara.Head, ref offset, isMono: false);
			}
		}

		public void GenerateMono(MemoryModeManager memoryModeManager, EmotionImage.Types type, GameDefine.CharaID charaID, ref Vector3 offset)
		{
			AdvMemoryChara advMemoryChara = memoryModeManager.FindCharaType(charaID);
			if (!(advMemoryChara == null))
			{
				Generate(type, advMemoryChara.Head, ref offset, isMono: true);
			}
		}

		public void Generate(EmotionImage.Types type, Transform chara, ref Vector3 offset, bool isMono)
		{
			Data data = m_dataList[(int)type];
			m_emotions[m_emotionListPos.Index].Open(chara, data, m_emotionDuration, ref offset, isMono, MainPosition.MainTransform);
			m_emotionListPos.Next();
		}
	}
	public class AdvBackground : MonoBehaviour
	{
		public const float _DEFAULT_BLEND_WEIGHT = 100f;

		[Header("Scene Properties")]
		[SerializeField]
		private SkinnedMeshRenderer m_skinnedMesh;

		[SerializeField]
		private AudioSource m_ambientSource;

		[SerializeField]
		private GameObject m_background;

		[SerializeField]
		private StaticScenePropController m_propsStatic;

		[SerializeField]
		private DynamicScenePropController m_propsDynamic;

		[Header("Boundary")]
		[Tooltip("チェックを入れるとシーン中でのバウンダリーレンジを変更します")]
		[SerializeField]
		private bool m_overrideBoundary;

		[SerializeField]
		private float m_boundaryRadius = 2f;

		[Header("Clear Color")]
		[Tooltip("チェックを入れるとシーンロード時にクリアカラーを強制的に変更します")]
		[SerializeField]
		private bool m_forceSetClearColor;

		[SerializeField]
		private Color m_clearColor = ColorDefine.Black;

		[Header("Character Specifics")]
		[SerializeField]
		private AdvCharaTextureSettings m_charaTexture;

		private GameObject m_gameobject;

		public bool HasStaticProps
		{
			get
			{
				if (m_propsStatic != null)
				{
					return m_propsStatic.PropCount > 0;
				}
				return false;
			}
		}

		public bool HasDynamicProps
		{
			get
			{
				if (m_propsDynamic != null)
				{
					return m_propsDynamic.PropCount > 0;
				}
				return false;
			}
		}

		public StaticScenePropController StaticProps
		{
			get
			{
				return m_propsStatic;
			}
			set
			{
				m_propsStatic = value;
			}
		}

		public DynamicScenePropController DynamicProps
		{
			get
			{
				return m_propsDynamic;
			}
			set
			{
				m_propsDynamic = value;
			}
		}

		public AdvCharaTextureSettings CharaTextureSettings => m_charaTexture;

		public AudioSourceFader Audio { get; private set; }

		public bool HasAudioSource => Audio != null;

		private IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		private void Start()
		{
			if (m_forceSetClearColor)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(m_clearColor);
			}
			if (m_ambientSource != null)
			{
				Audio = new AudioSourceFader(m_ambientSource);
			}
			m_gameobject = base.gameObject;
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			UpdateObserbable.Where((Unit _) => HasAudioSource).Subscribe(delegate
			{
				Audio.Update(Time.deltaTime);
			}).AddTo(base.gameObject);
			base.gameObject.SetActive(SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId == (SceneDefine)base.gameObject.scene.buildIndex);
			SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Subscribe(delegate(Scene scene)
			{
				base.gameObject.SetActive(scene.buildIndex == base.gameObject.scene.buildIndex);
				if (m_overrideBoundary)
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.BoundaryRange = m_boundaryRadius;
				}
			}).AddTo(base.gameObject);
		}

		private void OnDestroy()
		{
			if (HasStaticProps)
			{
				StaticProps.ClearAllProps();
			}
			else if (HasDynamicProps)
			{
				DynamicProps.ClearAllProps();
			}
		}

		public void SetBlendShape(CommandEnvironmentBlendShape command)
		{
			SetBlendShape(command.Index, command.Weight);
		}

		public void SetBlendShape(int index, float weight)
		{
			if (!(m_skinnedMesh == null))
			{
				m_skinnedMesh.SetBlendShapeWeight(index, weight);
			}
		}

		public void ProcessPreloadProps(PropDefines.PropType type, List<int> indexes)
		{
			if (type == PropDefines.PropType.Static && HasStaticProps)
			{
				StaticProps.MakeInstancePropByList(indexes);
			}
			else if (type == PropDefines.PropType.Dynamic && HasDynamicProps)
			{
				DynamicProps.MakeInstancePropByList(indexes);
			}
		}

		public BaseScenePropController GetPropControllerByType(PropDefines.PropType type)
		{
			if (type == PropDefines.PropType.Static)
			{
				return StaticProps;
			}
			return DynamicProps;
		}

		public void SetActive(bool isActive)
		{
			if (m_background == null)
			{
				m_gameobject.SetActive(isActive);
			}
			else
			{
				m_background.SetActive(isActive);
			}
		}

		public void ClearScenarioRelations()
		{
			if (HasStaticProps)
			{
				StaticProps.ResetInstancedProps();
			}
			if (HasDynamicProps)
			{
				DynamicProps.ResetInstancedProps();
			}
			if (HasAudioSource)
			{
				Audio.Stop();
			}
		}

		public void ResetAll()
		{
			if (m_skinnedMesh != null)
			{
				m_skinnedMesh.SetBlendShapeWeight(0, 0f);
			}
		}
	}
	public class BokeSphereManager
	{
		public class Data<T>
		{
			public int ID;

			public T Content;

			public Data(int id, T content)
			{
				ID = id;
				Content = content;
			}
		}

		private List<Data<GameObject>> m_prefabss = new List<Data<GameObject>>();

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private GameObject m_sphere;

		public bool IsLoading => m_requests.Count > 0;

		public BokeSphereManager()
		{
			m_sphere = null;
			m_prefabss = new List<Data<GameObject>>();
			m_requests = new List<AsyncOperation>();
		}

		public void LoadAll(List<int> preloadIndexes)
		{
			preloadIndexes?.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<GameObject>("Prefabs/" + id);
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadComplete(obj, id);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void OnLoadComplete(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			GameObject gameObject = (obj as ResourceRequest).asset as GameObject;
			if (!(gameObject == null))
			{
				m_prefabss.Add(new Data<GameObject>(id, gameObject));
			}
		}

		private GameObject FindData(int id)
		{
			int count = m_prefabss.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_prefabss[i].ID == id)
				{
					return m_prefabss[i].Content;
				}
			}
			return null;
		}

		public void Play(CommandBokeSphere command)
		{
			GameObject gameObject = FindData((int)command.Envrionment);
			if (!(gameObject == null))
			{
				if (m_sphere != null)
				{
					UnityEngine.Object.Destroy(m_sphere);
					m_sphere = null;
				}
				m_sphere = UnityEngine.Object.Instantiate(gameObject);
				PlaceSphere(command);
				SingletonMonoBehaviour<PlayAreaManager>.Instance.RequestLayerMode(this, PlayAreaManager.LayerModes.BokeSphere);
			}
		}

		private void PlaceSphere(CommandBokeSphere command)
		{
			PlaceSphere(m_sphere.transform, command, SingletonMonoBehaviour<PlayAreaManager>.Instance.CameraAnchorTransform);
		}

		public static void PlaceSphere(Transform sphere, CommandBokeSphere command, Transform anchor)
		{
			if (command.IsPlaceAtPlayer)
			{
				SetParentTransform(sphere, anchor, command.Position);
				SetYawRotation(sphere, command.Rotation);
			}
			else
			{
				sphere.localPosition = command.Position;
				SetYawRotation(sphere, command.Rotation);
			}
		}

		private void SetParentTransform(Transform target, Vector3 offset)
		{
			SetParentTransform(m_sphere.transform, target, offset);
		}

		private static void SetParentTransform(Transform sphere, Transform target, Vector3 offset)
		{
			sphere.SetParent(target, worldPositionStays: false);
			sphere.localPosition = offset;
		}

		private static void SetYawRotation(Transform sphere, float rotation)
		{
			Vector3 localEulerAngles = sphere.localEulerAngles;
			localEulerAngles.y = rotation;
			sphere.localEulerAngles = localEulerAngles;
		}

		public void End(CommandBokeSphereEnd command)
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.BokeSphere);
			DestroySphere();
		}

		public void DestroySphere()
		{
			if (m_sphere != null)
			{
				UnityEngine.Object.Destroy(m_sphere);
				m_sphere = null;
			}
		}

		public void Clear()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.BokeSphere);
			DestroySphere();
			int count = m_prefabss.Count;
			for (int i = 0; i < count; i++)
			{
				m_prefabss[i].Content = null;
				m_prefabss[i] = null;
			}
			m_prefabss.Clear();
			Resources.UnloadUnusedAssets();
		}
	}
	public class FocusUpWindowGroup : MonoBehaviour
	{
		[Header("Components - Windows")]
		[SerializeField]
		private ForcusUpWindow[] m_windows;

		public ForcusUpWindow[] Windows => m_windows;

		private void Start()
		{
			if (m_windows == null || m_windows.Length == 0)
			{
				FindWindowFromChild();
				if (m_windows == null || m_windows.Length == 0)
				{
					UnityEngine.Debug.LogWarning("FocusUpGroup: I have no windows so I'm trying to find windows.");
					FindWindowFromChild();
				}
			}
		}

		private void FindWindowFromChild()
		{
			Transform transform = base.transform;
			int childCount = transform.childCount;
			List<ForcusUpWindow> list = new List<ForcusUpWindow>();
			for (int i = 0; i < childCount; i++)
			{
				ForcusUpWindow component = transform.GetChild(i).GetComponent<ForcusUpWindow>();
				if (component != null)
				{
					list.Add(component);
				}
			}
			m_windows = list.ToArray();
		}

		public ForcusUpWindow GetWindow(int id)
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_windows[i].ID == id)
				{
					return m_windows[i];
				}
			}
			return null;
		}

		public ForcusUpWindow FindNextWindow()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (!m_windows[i].HasID)
				{
					return m_windows[i];
				}
			}
			return m_windows[0];
		}

		public bool IsBusy()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_windows[i].IsBusy)
				{
					return true;
				}
			}
			return false;
		}

		public void ForEachAll(Action<ForcusUpWindow> callback)
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				callback(m_windows[i]);
			}
		}

		public void ForEachActives(Action<ForcusUpWindow> callback)
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_windows[i].HasID)
				{
					callback(m_windows[i]);
				}
			}
		}

		public void ResetAll()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				m_windows[i].ResetSetting();
				m_windows[i].SetVisible(isVisible: false);
			}
		}

		public void Clear()
		{
			int num = m_windows.Length;
			for (int i = 0; i < num; i++)
			{
				m_windows[i].ClearTexture();
			}
		}
	}
	public class ForcusUpWindow : UpdateableComponent
	{
		public enum FadeType
		{
			Popup,
			Dither,
			Move
		}

		public const float DEFAULT_DISTANCE = 5f;

		[SerializeField]
		private bool m_isDisableOnStart = true;

		[SerializeField]
		private bool m_isResetLocalOnStart = true;

		[SerializeField]
		private Ease m_easeType = Ease.OutBounce;

		[SerializeField]
		private Vector3 m_defaultScale = Vector3.one;

		private GameObject m_gameObject;

		private Transform m_tranform;

		private Material m_material;

		private bool m_isOpen;

		private Vector3 m_target;

		private DitherFade m_ditherFade;

		private Material _editorMaterial;

		public int ID { get; private set; }

		public bool IsBusy { get; private set; }

		public bool HasID => ID != -1;

		protected override void Initialize()
		{
			IsBusy = false;
			m_gameObject = base.gameObject;
			m_tranform = base.transform;
			ID = -1;
			m_target = Vector3Extension.Zero;
			m_material = GetComponent<MeshRenderer>().material;
			m_ditherFade = new DitherFade(base.gameObject);
			if (m_isResetLocalOnStart)
			{
				m_tranform.ResetLocal(isResetPosition: true, isResetRotation: true, isResetScale: false);
			}
			if (m_isDisableOnStart)
			{
				base.gameObject.SetActive(value: false);
			}
		}

		public override void OnUpdate(float delta)
		{
			m_ditherFade.Update(Time.deltaTime);
		}

		public void ClearTexture()
		{
			m_material.mainTexture = null;
		}

		public void OpenWorldPoint(Texture sprite, FadeType fadeType, float duration, int id, Vector3 pos, Vector3 scale, bool isAutoPosition, Ease moveEase = Ease.InOutSine, Action onEndAction = null)
		{
			OnOpen(sprite, pos, id);
			SetupWorldPosition(pos, MainPosition.MainTransform.position);
			Vector3Extension.MultiplyTarget(ref m_defaultScale, ref scale);
			switch (fadeType)
			{
			case FadeType.Popup:
				Popup(duration, scale, onEndAction);
				break;
			case FadeType.Dither:
				OpenDither(duration, scale, onEndAction);
				break;
			case FadeType.Move:
				MoveIn(duration, pos, moveEase, scale, onEndAction);
				break;
			}
		}

		public void Open(Texture sprite, FadeType fadeType, float duration, int id, Vector3 target, float distance, Vector3 offset, Vector3 scale, bool isAutoPosition, Ease moveEase = Ease.InOutSine, Action onEndAction = null)
		{
			OnOpen(sprite, target, id);
			CalculatePosition(target, MainPosition.MainTransform.position, 0f - distance, ref offset);
			Vector3Extension.MultiplyTarget(ref m_defaultScale, ref scale);
			switch (fadeType)
			{
			case FadeType.Popup:
				Popup(duration, scale, onEndAction);
				break;
			case FadeType.Dither:
				OpenDither(duration, scale, onEndAction);
				break;
			case FadeType.Move:
				MoveIn(duration, target, moveEase, scale, onEndAction);
				break;
			}
		}

		public void OnOpen(Texture sprite, Vector3 target, int id = 0)
		{
			ID = id;
			m_isOpen = true;
			IsBusy = true;
			m_gameObject.SetActive(value: true);
			m_material.mainTexture = sprite;
			m_target = target;
		}

		public void SetupWorldPosition(Vector3 pos, Vector3 viewrPosition)
		{
			m_tranform.position = pos;
			m_tranform.LookAt(viewrPosition);
			m_tranform.Rotate(Vector3.up, 180f);
		}

		public void CalculatePosition(Vector3 target, Vector3 viewrPosition, float distance, ref Vector3 offset)
		{
			m_tranform.localRotation = Quaternion.identity;
			Vector3 left = viewrPosition;
			Vector3 a = Vector3Extension.Direction(ref left, ref target);
			Vector3 addAmount = Vector3Extension.Multiply(ref a, distance);
			Vector3Extension.AddTarget(ref left, ref addAmount);
			Vector3Extension.AddTarget(ref left, ref offset);
			m_tranform.position = left;
			m_tranform.LookAt(viewrPosition);
			m_tranform.Rotate(Vector3.up, 180f);
		}

		private void Popup(float duration, Vector3 targetScale, Action onEndAction = null)
		{
			m_ditherFade.SetModelAlpha(1f);
			m_tranform.localScale = Vector3.zero;
			m_tranform.DOScale(targetScale, duration).SetEase(m_easeType).OnComplete(delegate
			{
				IsBusy = false;
				if (onEndAction != null)
				{
					onEndAction();
				}
			});
		}

		public void OpenDither(Texture sprite, Vector3 scale, float duration, Action onEndAction = null)
		{
			OpenDither(duration, scale, onEndAction);
		}

		private void OpenDither(float duration, Vector3 scale, Action onEndAction = null)
		{
			m_tranform.localScale = scale;
			m_ditherFade.SetModelAlpha(0f);
			m_ditherFade.StartFade(1f, duration, delegate
			{
				IsBusy = false;
				if (onEndAction != null)
				{
					onEndAction();
				}
			});
		}

		private void MoveIn(float duration, Vector3 target, Ease moveEase, Vector3 scale, Action onEndAction = null)
		{
			Vector3 localPosition = m_tranform.localPosition;
			m_target = target;
			m_tranform.position = m_target;
			m_tranform.localScale = scale;
			m_ditherFade.SetModelAlpha(1f);
			m_tranform.DOLocalMove(localPosition, duration).SetEase(moveEase).OnComplete(delegate
			{
				IsBusy = false;
				if (onEndAction != null)
				{
					onEndAction();
				}
			});
		}

		public void Close(float duration, FadeType fadeType, Ease moveEase, Action onEndAction = null)
		{
			if (!m_isOpen)
			{
				return;
			}
			m_isOpen = false;
			ID = -1;
			if (duration <= 0f)
			{
				OnClosed();
				return;
			}
			switch (fadeType)
			{
			case FadeType.Popup:
				PopClose(duration, onEndAction);
				break;
			case FadeType.Dither:
				DitherFadeOut(duration, onEndAction);
				break;
			case FadeType.Move:
				MoveOut(duration, moveEase, onEndAction);
				break;
			}
		}

		private void PopClose(float duration, Action onEndAction = null)
		{
			m_tranform.DOScale(Vector3.zero, duration).SetEase(m_easeType).OnComplete(delegate
			{
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
			});
		}

		private void DitherFadeOut(float duration, Action onEndAction = null)
		{
			if (duration <= 0f)
			{
				m_ditherFade.SetModelAlpha(0f);
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
				return;
			}
			m_ditherFade.StartFade(0f, duration, delegate
			{
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
			});
		}

		private void MoveOut(float duration, Ease moveEase, Action onEndAction = null)
		{
			m_tranform.DOMove(m_target, duration).SetEase(moveEase).OnComplete(delegate
			{
				if (onEndAction != null)
				{
					onEndAction();
				}
				OnClosed();
			});
			m_tranform.DOScale(Vector3.zero, duration).SetEase(moveEase);
		}

		public void ChangeTexture(Texture texture, float fadeDuration)
		{
			m_ditherFade.StartFade(0f, fadeDuration, delegate
			{
				m_material.mainTexture = texture;
				m_ditherFade.StartFade(1f, fadeDuration, delegate
				{
					IsBusy = false;
				});
			});
		}

		private void OnClosed()
		{
			ID = -1;
			IsBusy = false;
			m_target = Vector3Extension.Zero;
			m_gameObject.SetActive(value: false);
		}

		public void SetSprite(Texture texture)
		{
			Renderer component = GetComponent<Renderer>();
			if (_editorMaterial == null)
			{
				_editorMaterial = new Material(component.sharedMaterial);
				component.material = _editorMaterial;
			}
			_editorMaterial.mainTexture = texture;
		}

		public void Show()
		{
			SetVisible(isVisible: true);
		}

		public void Hide()
		{
			SetVisible(isVisible: false);
		}

		public void SetVisible(bool isVisible)
		{
			if (m_gameObject != null)
			{
				m_gameObject.SetActive(isVisible);
			}
			else if (base.gameObject != null)
			{
				base.gameObject.SetActive(isVisible);
			}
		}

		public void ResetSetting()
		{
			if (m_gameObject == null && base.gameObject != null)
			{
				m_gameObject = base.gameObject;
			}
			if (m_tranform == null && base.transform != null)
			{
				m_tranform = base.transform;
			}
			if (m_gameObject == null && base.gameObject != null)
			{
				m_gameObject = base.gameObject;
			}
			if (m_tranform == null && base.transform != null)
			{
				m_tranform = base.transform;
			}
			m_tranform.ResetLocal(isResetPosition: true, isResetRotation: true, isResetScale: false);
			m_tranform.localScale = m_defaultScale;
			OnClosed();
		}

		public void SetID(int id)
		{
			ID = id;
		}

		public void SetScale(Vector3 scale)
		{
			base.transform.localScale = Vector3Extension.Multiply(ref scale, ref m_defaultScale);
		}
	}
	public class ForcusUpWindowController : MonoBehaviour
	{
		public class Data<T>
		{
			public int ID;

			public T Content;

			public Data(int id, T content)
			{
				ID = id;
				Content = content;
			}
		}

		public enum SourceType
		{
			Point,
			Chara
		}

		private const string FILE_PATH = "{0}{1:D4}";

		[Header("Externals - Window group")]
		[SerializeField]
		private FocusUpWindowGroup m_windowGroup;

		[Header("Parameters")]
		[SerializeField]
		private float m_windowAnimationDuration = 0.6f;

		[SerializeField]
		private float m_windowCloseAnimationDuration = 0.6f;

		[SerializeField]
		private float m_ditherFadeDuration = 0.3f;

		[SerializeField]
		private float m_windowMoveDuration = 1.25f;

		private List<Data<Texture>> m_textures = new List<Data<Texture>>();

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		public bool IsLoading => m_requests.Count > 0;

		public ForcusUpWindow GetWindow(int id)
		{
			return m_windowGroup.GetWindow(id);
		}

		public ForcusUpWindow FindNextWindow()
		{
			return m_windowGroup.FindNextWindow();
		}

		public void LoadAllTextures(List<int> preloadIndexes)
		{
			preloadIndexes?.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<Texture>(string.Format("{0}{1:D4}", "Textures/Event/", id));
				int currentID = id;
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadComplete(obj, currentID);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void OnLoadComplete(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			Texture texture = (obj as ResourceRequest).asset as Texture;
			if (!(texture == null))
			{
				m_textures.Add(new Data<Texture>(id, texture));
			}
		}

		public bool IsBusy()
		{
			if (IsLoading)
			{
				return true;
			}
			return m_windowGroup.IsBusy();
		}

		public void OpenWindow(CommandForcusUpWindow command)
		{
			ForcusUpWindow forcusUpWindow = FindNextWindow();
			Texture texture = FindTexture(command.ID);
			if (!(texture == null))
			{
				float fadeDuration = GetFadeDuration(command.FadeType, isOpen: false);
				if (command.Source == SourceType.Chara)
				{
					OpenWindowAtChara(command, forcusUpWindow, fadeDuration, texture);
				}
				else if (command.Source == SourceType.Point)
				{
					forcusUpWindow.OpenWorldPoint(texture, command.FadeType, fadeDuration, command.WindowID, command.TargetPoint, command.Scale, isAutoPosition: true, command.MoveEaseType);
				}
			}
		}

		private void OpenWindowAtChara(CommandForcusUpWindow command, ForcusUpWindow window, float duration, Texture texture)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(command.Chara);
			if (!(chara == null))
			{
				PrepareChara(chara);
				Transform head = chara.Head;
				window.Open(texture, command.FadeType, duration, command.WindowID, head.position, command.Distance, command.Offset, command.Scale, isAutoPosition: true, command.MoveEaseType);
			}
		}

		private void PrepareChara(AdvChara chara)
		{
			if (!chara.IsActive)
			{
				chara.SetEnable(isEnable: true);
				chara.Model.PlayAnimation(100, isFade: false, isSkipAnimation: true);
				chara.SetEnable(isEnable: false);
			}
		}

		public Texture FindTexture(int id)
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_textures[i].ID == id)
				{
					return m_textures[i].Content;
				}
			}
			return null;
		}

		public void ChangeTexture(int windowID, int id, float fadeDuration)
		{
			ForcusUpWindow window = GetWindow(windowID);
			Texture texture = FindTexture(id);
			if (!(window == null) && !(texture == null))
			{
				window.ChangeTexture(texture, fadeDuration);
			}
		}

		public void CloseAll(bool isSkip, Ease moveEase = Ease.InOutCubic)
		{
			m_windowGroup.ForEachActives(delegate(ForcusUpWindow window)
			{
				CloseWindow(ForcusUpWindow.FadeType.Dither, window, moveEase, isSkip);
			});
		}

		public void CloseWindowByID(ForcusUpWindow.FadeType fadeType, int windowID, Ease moveEase, bool isSkip)
		{
			ForcusUpWindow window = GetWindow(windowID);
			if (!(window == null))
			{
				CloseWindow(fadeType, window, moveEase, isSkip);
			}
		}

		public void CloseWindow(ForcusUpWindow.FadeType fadeType, ForcusUpWindow window, Ease moveEase, bool isSkip)
		{
			if (!(window == null))
			{
				float duration = 0f;
				if (!isSkip)
				{
					duration = GetFadeDuration(fadeType, isOpen: false);
				}
				window.Close(duration, fadeType, moveEase);
			}
		}

		public float GetFadeDuration(ForcusUpWindow.FadeType type, bool isOpen)
		{
			switch (type)
			{
			case ForcusUpWindow.FadeType.Dither:
				return m_ditherFadeDuration;
			case ForcusUpWindow.FadeType.Move:
				return m_windowMoveDuration;
			default:
				if (isOpen)
				{
					return m_windowAnimationDuration;
				}
				return m_windowCloseAnimationDuration;
			}
		}

		public void SetAllWindowVisible(bool isVisible)
		{
			m_windowGroup.ForEachAll(delegate(ForcusUpWindow window)
			{
				window.SetVisible(isVisible);
			});
		}

		public void ResetAll()
		{
			m_windowGroup.ResetAll();
		}

		public void Clear()
		{
			m_windowGroup.Clear();
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(m_textures[i].Content);
				m_textures[i].Content = null;
				m_textures[i] = null;
			}
			m_textures.Clear();
			Resources.UnloadUnusedAssets();
		}
	}
	public class GameWindowPositioner : UpdateableComponent
	{
		public enum RotateFixType
		{
			None,
			Yaw,
			Pitch,
			Both
		}

		private const float PITCH_MIN = -100f;

		[Header("Components")]
		[SerializeField]
		private MessageWindowController messageWindows;

		[SerializeField]
		private Transform pitchTransform;

		[Header("Parameters")]
		[SerializeField]
		private float fetchSpeed = 3f;

		[SerializeField]
		private float accelSpeed = 0.5f;

		[SerializeField]
		private float threshouldDegree = 15f;

		[SerializeField]
		private float threshouldPitchChange = 5f;

		[SerializeField]
		private float pitchBetween = 45f;

		[SerializeField]
		private float pitchBase = 5f;

		[SerializeField]
		private float pitchAboveAdd = -10f;

		[SerializeField]
		private bool isTrackPosition;

		private Transform _thisTransform;

		private Quaternion _quatPitch;

		private Quaternion _quatYaw;

		private float _multFetch;

		private float _targetPitch;

		private float _targetYaw;

		public bool IsFixedToFront { get; set; }

		public bool IsFixVertical { get; set; }

		public float FrontFixYaw { get; set; }

		public float FrontFixPitch { get; set; }

		private bool IsFollowVertical => SingletonMonoBehaviour<GameData>.Instance.ConfigData.IsMessageFollowVertical.Value;

		protected override void Initialize()
		{
			_thisTransform = base.transform;
			ResetYaw();
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				ResetYaw();
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			if (isTrackPosition)
			{
				MoveToCamera();
			}
			RotateToCamera();
		}

		private void ResetYaw()
		{
			_targetYaw = 0f;
			_quatYaw = Quaternion.Euler(0f, _targetYaw, 0f);
		}

		private void MoveToCamera()
		{
			Transform transform = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera.transform;
			_thisTransform.position = transform.position;
		}

		private void RotateToCamera()
		{
			float num = Mathf.Clamp01(fetchSpeed * Time.deltaTime);
			Quaternion localRotation = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera.transform.localRotation;
			float num2 = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, localRotation * Vector3.forward, localRotation * Vector3.right));
			Quaternion quaternion = localRotation * Quaternion.Euler(0f - num2, 0f, 0f);
			float num3 = ((IsFollowVertical && !IsFixVertical) ? Mathf.Clamp(num2, -100f, 0.5f + pitchBase + threshouldPitchChange) : 0f);
			if (Mathf.Abs(Mathf.DeltaAngle(_targetPitch, num3) - pitchBase) >= pitchBetween / 2f + threshouldPitchChange)
			{
				float num4 = Mathf.Round((num3 - pitchBase) / pitchBetween) * pitchBetween;
				if (_targetPitch != num4)
				{
					_targetPitch = num4;
					_quatPitch = Quaternion.Euler(_targetPitch + ((_targetPitch < 0f) ? pitchAboveAdd : 0f), 0f, 0f);
					messageWindows.StartFadeIn();
				}
			}
			float y = quaternion.eulerAngles.y;
			float num5 = Mathf.DeltaAngle(_targetYaw, y);
			if (IsFixedToFront)
			{
				num *= 4f;
				_targetYaw = FrontFixYaw;
			}
			else if (Mathf.Abs(num5) >= threshouldDegree)
			{
				if (_multFetch < 1f)
				{
					_multFetch += Time.deltaTime * accelSpeed;
					if (_multFetch > 1f)
					{
						_multFetch = 1f;
					}
					_targetYaw += num5 * _multFetch;
				}
				else
				{
					_targetYaw = y;
				}
			}
			else if (_multFetch > 0f)
			{
				_multFetch -= Time.deltaTime * accelSpeed;
				if (_multFetch > 0f)
				{
					_targetYaw += num5 * _multFetch;
				}
				else
				{
					_multFetch = 0f;
				}
			}
			_quatYaw = Quaternion.Slerp(_quatYaw, Quaternion.Euler(0f, _targetYaw, 0f), num);
			_thisTransform.localRotation = _quatYaw;
			pitchTransform.localRotation = _quatPitch;
		}

		public void ClearScenarioRelations()
		{
			IsFixedToFront = false;
			IsFixVertical = false;
		}
	}
	public class InGameManager : SingletonMonoBehaviour<InGameManager>
	{
		[Header("Components")]
		[SerializeField]
		private TimelinePlayer _timelinePlayer;

		public static bool IsReadyInGame
		{
			get
			{
				if (SingletonMonoBehaviour<InGameManager>.HasInstance)
				{
					return SingletonMonoBehaviour<InGameManager>.Instance.IsReady;
				}
				return false;
			}
		}

		public static TimelinePlayer Timeline => SingletonMonoBehaviour<InGameManager>.Instance._timelinePlayer;

		public bool IsReady { get; private set; }

		protected override void InitializeOnAwake()
		{
			IsReady = false;
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.DisposeAllReservedScene();
				DisableReady();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.DisposeAllReservedScene();
			}).AddTo(base.gameObject);
		}

		public void ReadyOnStart()
		{
			IsReady = true;
			SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(_timelinePlayer);
			_timelinePlayer.ReserveLoadScenerio(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
		}

		public void DisableReady()
		{
			IsReady = false;
		}
	}
	[DisallowMultipleComponent]
	public class MainPosition : SingletonMonoBehaviour<MainPosition>
	{
		[Header("Components")]
		[SerializeField]
		private Transform _contentsTransform;

		[SerializeField]
		private Transform _attachTransform;

		[SerializeField]
		private Transform _frontVoiceLocator;

		[SerializeField]
		private AudioSource _audioSourceEffect;

		[SerializeField]
		private AudioSource _audioSourceVoice;

		[SerializeField]
		private PlayerAvater _playerAvater;

		[SerializeField]
		private GameWindowPositioner _windowPositioner;

		[Header("Parameters")]
		[SerializeField]
		private float _playerHeightMultiply = 0.2f;

		private Transform _myTransform;

		private Transform _cameraTarnsform;

		private Camera _mainCamera;

		private ReactiveProperty<bool> _prohibitHeightChange = new ReactiveProperty<bool>(initialValue: false);

		public static Transform MainTransform => SingletonMonoBehaviour<MainPosition>.Instance._myTransform;

		public static Transform ContentsTransform => SingletonMonoBehaviour<MainPosition>.Instance._contentsTransform;

		public static Transform AttachTransform => SingletonMonoBehaviour<MainPosition>.Instance._attachTransform;

		public static Transform CameraTransform => SingletonMonoBehaviour<MainPosition>.Instance._cameraTarnsform;

		public static Transform FrontVoiceLocator => SingletonMonoBehaviour<MainPosition>.Instance._frontVoiceLocator;

		public static AudioSource AudioSourceEffect => SingletonMonoBehaviour<MainPosition>.Instance._audioSourceEffect;

		public static AudioSource AudioSourceVoice => SingletonMonoBehaviour<MainPosition>.Instance._audioSourceVoice;

		public static Camera MainCamera => SingletonMonoBehaviour<MainPosition>.Instance._MainCamera;

		public static PlayerAvater Avater => SingletonMonoBehaviour<MainPosition>.Instance._playerAvater;

		public static GameWindowPositioner WindowPositioner => SingletonMonoBehaviour<MainPosition>.Instance._windowPositioner;

		private Camera _MainCamera
		{
			get
			{
				if (_mainCamera == null)
				{
					if (SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
					{
						_mainCamera = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera;
					}
					else
					{
						_mainCamera = Camera.main;
					}
				}
				return _mainCamera;
			}
		}

		private ConfigSave ConfigData => SingletonMonoBehaviour<GameData>.Instance.ConfigData;

		private float PlayerHeight => (float)ConfigData.PlayerHeight.Value * _playerHeightMultiply;

		public bool ProhibitHeightChange
		{
			get
			{
				return _prohibitHeightChange.Value;
			}
			set
			{
				_prohibitHeightChange.Value = value;
			}
		}

		protected override void InitializeOnAwake()
		{
			_myTransform = base.transform;
			base.InitializeOnAwake();
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.AttachTo(_attachTransform);
			}
			_cameraTarnsform = _MainCamera.transform;
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SetPlayerHeight(ConfigData.PlayerHeight.Value, skipFade: true);
			_prohibitHeightChange.Subscribe(delegate(bool flag)
			{
				if (flag)
				{
					SetPlayerHeight(0);
				}
				else
				{
					SetPlayerHeight(ConfigData.PlayerHeight.Value);
				}
			});
			(from _ in ConfigData.PlayerHeight.SkipLatestValueOnSubscribe()
				where !_prohibitHeightChange.Value
				select _).Subscribe(delegate(int height)
			{
				SetPlayerHeight(height);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				OnBeforeEndGame();
			}).AddTo(base.gameObject);
		}

		private void OnBeforeEndGame()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.RevertToParent();
			}
			SingletonMonoBehaviour<PlayAreaManager>.Instance.BackToInitialParent();
		}

		private void SetPlayerHeight(int heightParam, bool skipFade = false)
		{
			float multipliedPlayerHeight = GetMultipliedPlayerHeight(heightParam);
			Vector3 localPosition = new Vector3(0f, multipliedPlayerHeight, 0f);
			_contentsTransform.localPosition = localPosition;
			if (!skipFade && SingletonMonoBehaviour<FadeManager>.HasInstance)
			{
				SingletonMonoBehaviour<FadeManager>.Instance.FlashFade();
			}
		}

		private float GetMultipliedPlayerHeight(int heightParam)
		{
			return (float)heightParam * _playerHeightMultiply;
		}

		public void ClearScenarioRelations()
		{
			_prohibitHeightChange.Value = false;
			WindowPositioner.ClearScenarioRelations();
			Avater.ClearScquenceRelations();
		}
	}
	public class ChapterChecker
	{
		public const int _CHAPTER_START = 1;

		private static readonly string[] AlphabetCountings = new string[8] { "", "A", "B", "C", "D", "E", "F", "G" };

		public static bool IsHiddenChapterRevealed => SingletonMonoBehaviour<GameData>.Instance.GetFlag(SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ConditionToRevealHidden);

		public static int GetCurrentChapter()
		{
			return GetChapter(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
		}

		public static int GetChapter(int sequenceID)
		{
			return SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sequenceID).ChapterNumber;
		}

		public static string GetChapterLocalizeKey(int sequenceID)
		{
			ScenarioListData.Info scenarioInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sequenceID);
			ScenarioListData.Categories category = scenarioInfo.Category;
			int chapterNumber = scenarioInfo.ChapterNumber;
			if (category == ScenarioListData.Categories.Special)
			{
				ScenarioListData.SpecialTypes specialType = scenarioInfo.SpecialType;
				if (specialType == ScenarioListData.SpecialTypes.ChapterStart)
				{
					if (chapterNumber <= 19)
					{
						return GetChapterLocalizeKey(1, chapterNumber - 10);
					}
					return GetChapterLocalizeKey(2, chapterNumber - 20);
				}
				return "ChapterNameUnknown";
			}
			return GetChapterLocalizeKey((int)category, chapterNumber);
		}

		public static string GetChapterLocalizeKey(int category, int chapter)
		{
			return $"ChapterName.{category}.{chapter}";
		}

		public static string GetSpecialSceneLocalizeKey(int index)
		{
			return "ChapterNameBonus." + index;
		}

		public static string GetChapterNumberFormatLocalizeKey(ScenarioListData.Categories category)
		{
			return "ChapterFormat." + (int)category;
		}

		public static string GetChapterNumber(ScenarioListData.Categories category, int chapter)
		{
			return category switch
			{
				ScenarioListData.Categories.RouteFirst => chapter.ToString(), 
				ScenarioListData.Categories.RouteSecond => chapter.ToString(), 
				ScenarioListData.Categories.Character => AlphabetCountings[chapter], 
				_ => string.Empty, 
			};
		}

		public static string GetFormattedChapterNumber(int sequenceID)
		{
			ScenarioListData.Info scenarioInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sequenceID);
			ScenarioListData.Categories categories = scenarioInfo.Category;
			int num = scenarioInfo.ChapterNumber;
			if (categories == ScenarioListData.Categories.Special)
			{
				ScenarioListData.SpecialTypes specialType = scenarioInfo.SpecialType;
				if (specialType != ScenarioListData.SpecialTypes.Selection)
				{
					return "ChapterNameUnknown";
				}
				switch (num)
				{
				case 0:
					categories = ScenarioListData.Categories.RouteFirst;
					num = 4;
					break;
				case 10:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 2;
					break;
				case 20:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 3;
					break;
				case 30:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 5;
					break;
				case 40:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 6;
					break;
				case 50:
					categories = ScenarioListData.Categories.RouteFirst;
					num = 7;
					break;
				case 60:
					categories = ScenarioListData.Categories.RouteSecond;
					num = 8;
					break;
				}
			}
			string localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(GetChapterNumberFormatLocalizeKey(categories));
			string chapterNumber = GetChapterNumber(categories, num);
			return string.Format(localizeString, chapterNumber);
		}

		public static string GetChapterCategoryString(ScenarioListData.Categories category)
		{
			return category switch
			{
				ScenarioListData.Categories.RouteFirst => "Chapters", 
				ScenarioListData.Categories.RouteSecond => "Re: Chapters", 
				ScenarioListData.Categories.Character => "Sub Chapters", 
				ScenarioListData.Categories.Special => "Extra", 
				_ => "Unknown", 
			};
		}

		public static NewGameData.ChapterSetting[] GetChapterListData(ScenarioListData.Categories category)
		{
			return category switch
			{
				ScenarioListData.Categories.RouteFirst => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersFirst, 
				ScenarioListData.Categories.RouteSecond => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersSecond, 
				ScenarioListData.Categories.Character => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersCharacter, 
				ScenarioListData.Categories.Special => SingletonMonoBehaviour<DataManager>.Instance.GeneralData.NewGameLists.ChaptersSpecial, 
				_ => new NewGameData.ChapterSetting[0], 
			};
		}
	}
	public class SelectionController : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private SelectionObject _prefabCharaSelection;

		[SerializeField]
		private SelectionObject _prefabPropSelection;

		[SerializeField]
		private SelectionObject _prefabFocusupSelection;

		[SerializeField]
		private SelectionObject _prefabSelfSelection;

		[Header("Parameters - Durations")]
		[SerializeField]
		private float _fadeStartDuration = 0.5f;

		[SerializeField]
		private float _fadeEndDuration = 1.2f;

		[Header("Parameters - Outlines")]
		[SerializeField]
		private float _outlineSize = 0.25f;

		[Header("Parameters - Colors")]
		[SerializeField]
		private Color _colorWaiting1 = ColorDefine.TransparentBlack;

		[SerializeField]
		private Color _colorWaiting2 = ColorDefine.TransparentWhite;

		[SerializeField]
		private Color _colorHover = ColorDefine.TransparentWhite;

		private List<SelectionObject> _selections;

		private Queue<IDisposable> _disposes;

		private CommandSelection _currentData;

		private int _selectedIndex;

		private bool _isDecided;

		private bool _isSelecting;

		private Subject<int> _subjectPointerEnterSelection = new Subject<int>();

		private Subject<int> _subjectPointerExitSelection = new Subject<int>();

		private AsyncSubject<int> _subjectEndSelection = new AsyncSubject<int>();

		public IObservable<int> PointerEnterSelectionObservable => _subjectPointerEnterSelection;

		public IObservable<int> PointerExitSelectionObservable => _subjectPointerExitSelection;

		public IObservable<int> EndSelectionObservable => _subjectEndSelection;

		private IFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		private bool IsNeedSelectionLaser
		{
			get
			{
				if (_currentData != null)
				{
					return _currentData.SelectionMode != SelectionDefines.Modes.Finale;
				}
				return true;
			}
		}

		private bool IsNeedGeneralEffects => _currentData.SelectionMode != SelectionDefines.Modes.Finale;

		public bool IsDecided => _isDecided;

		public bool IsSelecting => _isSelecting;

		public bool ProhibitLaserInterraction { get; set; }

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeExitFade.Where((Unit _) => _isSelecting).Subscribe(delegate
			{
				DisposeSelection();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool _) => _isSelecting && !_isDecided).Subscribe(delegate(bool isMenu)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.ToggleLaserVisible(isMenu);
				foreach (SelectionObject selection in _selections)
				{
					selection.SetInterractable(!isMenu && !ProhibitLaserInterraction);
					selection.SetLaserVibisle(!isMenu && IsNeedSelectionLaser);
				}
			}).AddTo(base.gameObject);
		}

		public void StartSelection(CommandSelection command)
		{
			_isSelecting = true;
			_isDecided = false;
			_currentData = command;
			_disposes = new Queue<IDisposable>();
			if (Fader.IsFadeVisible)
			{
				OnEndIntroFade();
			}
			else
			{
				Fader.StartFade(ColorDefine.Black, _fadeStartDuration, isDeactivateOnEnd: false, OnEndIntroFade);
			}
		}

		private void OnEndIntroFade()
		{
			InitSelections();
			Fader.StartFade(ColorDefine.TransparentBlack, _fadeStartDuration, isDeactivateOnEnd: true);
			PlaySeOpen();
		}

		private void InitSelections()
		{
			_selections = new List<SelectionObject>();
			PrepareData();
			SingletonMonoBehaviour<PlayAreaManager>.Instance.ToggleLaserVisible(flag: false);
			if (!ProhibitLaserInterraction)
			{
				return;
			}
			foreach (SelectionObject selection in _selections)
			{
				selection.SetInterractable(flag: false);
			}
		}

		private void PrepareData()
		{
			for (int i = 0; i < _currentData.SelectionCount; i++)
			{
				CommandSelection.SelectionOptions selectionOptions = _currentData.SelectionList[i];
				switch (selectionOptions.SelectType)
				{
				case SelectionDefines.TargetTypes.Chara:
				{
					GameDefine.CharaID targetChara = selectionOptions.TargetChara;
					AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(targetChara);
					if (!(chara == null))
					{
						MakeCharaSelection(i, chara);
					}
					break;
				}
				case SelectionDefines.TargetTypes.Prop:
				{
					PropDefines.PropType targetPropType = selectionOptions.TargetPropType;
					int targetPropIndex = selectionOptions.TargetPropIndex;
					BaseScenePropController propControllerByType = InGameManager.Timeline.CurrentBackground.GetPropControllerByType(targetPropType);
					if (!(propControllerByType == null))
					{
						BaseProp propByIndex = propControllerByType.GetPropByIndex(targetPropIndex);
						if (!(propByIndex == null))
						{
							MakePropSelection(i, propByIndex);
						}
					}
					break;
				}
				case SelectionDefines.TargetTypes.FocusUp:
				{
					int targetFocusWindowIndex = selectionOptions.TargetFocusWindowIndex;
					ForcusUpWindow window = InGameManager.Timeline.FocusUpProcessor.GetWindow(targetFocusWindowIndex);
					if (!(window == null))
					{
						MakeFocusUpWindowSelection(i, window);
					}
					break;
				}
				case SelectionDefines.TargetTypes.Yourself:
					MakeSelfSelection(i);
					break;
				}
			}
		}

		private SelectionObject MakeSelection(int index, SelectionObject prefab)
		{
			SelectionObject selectionObject = UnityEngine.Object.Instantiate(prefab);
			selectionObject.SelectionIndex = index;
			selectionObject.ColorWaiting1 = _colorWaiting1;
			selectionObject.ColorWaiting2 = _colorWaiting2;
			_selections.Add(selectionObject);
			MakeSelectionSubscribes(selectionObject, index);
			selectionObject.SetLaserVibisle(IsNeedSelectionLaser);
			return selectionObject;
		}

		private void MakeCharaSelection(int index, AdvChara charaObject)
		{
			SelectionObject selectionObject = MakeSelection(index, _prefabCharaSelection);
			charaObject.Model.SetModelOutlineSize(_outlineSize);
			selectionObject.SetParentTransform(charaObject.Transform);
			selectionObject.SetLaserToTransform(charaObject.GetNode(AdvCharaModel.Node.Head));
			selectionObject.OnSelectionEnter.Subscribe(delegate
			{
				charaObject.Model.SetModelOutlineColor(_colorHover);
			}).AddTo(base.gameObject);
			selectionObject.GradiateColorObservable.Subscribe(delegate(Color color)
			{
				charaObject.Model.SetModelOutlineColor(color);
			});
			selectionObject.EndSelectionObservable.Subscribe(delegate(bool selected)
			{
				if (selected)
				{
					charaObject.Model.SetModelOutlineColor(_colorHover);
				}
				else
				{
					charaObject.Model.SetModelOutlineSize(0f);
					charaObject.Model.SetModelOutlineColor(ColorDefine.Black);
				}
			}).AddTo(base.gameObject);
		}

		private void MakePropSelection(int index, BaseProp obj)
		{
			SelectionObject selectionObject = MakeSelection(index, _prefabPropSelection);
			selectionObject.SetParentTransform(obj.AnchorTransform);
			selectionObject.SetLaserToTransform(obj.AnchorTransform);
		}

		private void MakeFocusUpWindowSelection(int index, ForcusUpWindow obj)
		{
			SelectionObject selectionObject = MakeSelection(index, _prefabFocusupSelection);
			selectionObject.SetParentTransform(obj.transform);
			selectionObject.SetLaserToTransform(obj.transform);
			selectionObject.OnSelectionEnter.Subscribe(delegate
			{
				selectionObject.SetOutlineColor(_colorHover);
			}).AddTo(base.gameObject);
			selectionObject.GradiateColorObservable.Subscribe(delegate(Color color)
			{
				selectionObject.SetOutlineColor(color);
			});
			selectionObject.EndSelectionObservable.Subscribe(delegate(bool selected)
			{
				if (selected)
				{
					selectionObject.SetOutlineColor(_colorHover);
				}
				else
				{
					selectionObject.SetOutlineColor(ColorDefine.TransparentBlack);
				}
			}).AddTo(base.gameObject);
		}

		private void MakeSelfSelection(int index)
		{
			PlayerAvater avater = MainPosition.Avater;
			SelectionObject selectionObject = MakeSelection(index, _prefabSelfSelection);
			selectionObject.SetParentTransform(avater.MessagePivot);
			selectionObject.SetLaserToTransform(avater.MessagePivot);
			if (MainPosition.Avater.AvaterResources.HasBody)
			{
				MainPosition.Avater.AvaterResources.BodyObject.SetOutlineSize(_outlineSize);
			}
			if (MainPosition.Avater.AvaterResources.HasHand)
			{
				MainPosition.Avater.AvaterResources.HandObject.SetOutlineSize(_outlineSize);
			}
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.SetOutlineSize(_outlineSize);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.SetOutlineSize(_outlineSize);
			}
			selectionObject.OnSelectionEnter.Subscribe(delegate
			{
				if (MainPosition.Avater.AvaterResources.HasBody)
				{
					MainPosition.Avater.AvaterResources.BodyObject.SetOutlineColor(_colorHover);
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					MainPosition.Avater.AvaterResources.HandObject.SetOutlineColor(_colorHover);
				}
			}).AddTo(base.gameObject);
			selectionObject.GradiateColorObservable.Subscribe(delegate(Color color)
			{
				if (MainPosition.Avater.AvaterResources.HasBody)
				{
					MainPosition.Avater.AvaterResources.BodyObject.SetOutlineColor(color);
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					MainPosition.Avater.AvaterResources.HandObject.SetOutlineColor(color);
				}
				if (MainPosition.Avater.AvaterResources.HasTrackedHands)
				{
					MainPosition.Avater.AvaterResources.TrackedHandLeftObject.SetOutlineColor(color);
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.SetOutlineColor(color);
				}
			}).AddTo(base.gameObject);
			selectionObject.EndSelectionObservable.Subscribe(delegate
			{
				if (MainPosition.Avater.AvaterResources.HasBody)
				{
					MainPosition.Avater.AvaterResources.BodyObject.RevertToDefault();
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					MainPosition.Avater.AvaterResources.HandObject.RevertToDefault();
				}
				if (MainPosition.Avater.AvaterResources.HasTrackedHands)
				{
					MainPosition.Avater.AvaterResources.TrackedHandLeftObject.RevertToDefault();
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.RevertToDefault();
				}
			}).AddTo(base.gameObject);
		}

		private void MakeSelectionSubscribes(SelectionObject selection, int index)
		{
			_disposes.Enqueue(selection.OnSelectionEnter.Subscribe(delegate(PointerEventData pointer)
			{
				PlaySeSelect(selection.SelectionAudioSource);
				GameInputHelper.VibrateLaserForFocus(pointer.GetLaserController());
				_subjectPointerEnterSelection.OnNext(index);
			}).AddTo(base.gameObject));
			_disposes.Enqueue(selection.OnSelectionExit.Subscribe(delegate
			{
				_subjectPointerExitSelection.OnNext(index);
			}).AddTo(base.gameObject));
			_disposes.Enqueue(selection.OnSelectionDown.Subscribe(delegate(PointerEventData pointer)
			{
				GameInputHelper.VibrateLaserForPress(pointer.GetLaserController());
			}).AddTo(base.gameObject));
			_disposes.Enqueue(selection.OnSelectionClick.Subscribe(delegate
			{
				PlaySeDecide(selection.SelectionAudioSource);
				OnSelected(index);
			}).AddTo(base.gameObject));
		}

		private void OnSelected(int index)
		{
			_selectedIndex = index;
			SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex = _selectedIndex;
			_isDecided = true;
			OnBeforeEndSelection();
			if (IsNeedGeneralEffects)
			{
				Fader.StartFade(ColorDefine.Black, _fadeEndDuration, isDeactivateOnEnd: false, EndSelection);
			}
			else
			{
				EndSelection();
			}
		}

		public void ForceSelect(int index)
		{
			if (_isSelecting && !_isDecided)
			{
				OnSelected(index);
			}
		}

		private void DisposeSelection()
		{
			_selectedIndex = -1;
			SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex = _selectedIndex;
			OnBeforeEndSelection();
			EndSelection();
		}

		private void OnBeforeEndSelection()
		{
			DisposeSelectEvents();
			SendSelectionEnd();
			Observable.NextFrame().Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.ToggleLaserVisible(flag: true);
			}).AddTo(base.gameObject);
		}

		private void DisposeSelectEvents()
		{
			while (_disposes.Count > 0)
			{
				_disposes.Dequeue().Dispose();
			}
		}

		private void SendSelectionEnd()
		{
			foreach (SelectionObject selection in _selections)
			{
				selection.EndSelection(selection.SelectionIndex == _selectedIndex);
			}
		}

		private void EndSelection()
		{
			ReleaseAllSelections();
			ProhibitLaserInterraction = false;
			_isSelecting = false;
			_currentData = null;
			_subjectEndSelection.OnNext(_selectedIndex);
			_subjectEndSelection.OnCompleted();
			_subjectEndSelection = new AsyncSubject<int>();
		}

		private void ReleaseAllSelections()
		{
			if (_selections == null)
			{
				return;
			}
			foreach (SelectionObject selection in _selections)
			{
				selection.gameObject.Destroy();
			}
			_selections.Clear();
		}

		public void PlaySeOpen()
		{
			if (IsNeedGeneralEffects)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Selection_Show);
			}
		}

		public void PlaySeSelect(AudioSource uiSoundSource)
		{
			if (IsNeedGeneralEffects)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Selection_Select, uiSoundSource);
			}
		}

		public void PlaySeDecide(AudioSource uiSoundSource)
		{
			if (IsNeedGeneralEffects)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Selection_Decide, uiSoundSource);
			}
		}
	}
	public static class SelectionDefines
	{
		public enum Modes
		{
			Normal,
			Finale
		}

		public enum TargetTypes
		{
			Chara,
			Prop,
			FocusUp,
			Yourself
		}

		public enum CollisionTypes
		{
			NoMake,
			MakeCollision
		}
	}
	public class SelectionLaser : UpdateableComponent
	{
		private const float LaserOffset = 0.05f;

		private const float LaserLength = 0.9f;

		[Header("Components")]
		[SerializeField]
		private LineRenderer _line;

		[Header("Parameters")]
		[SerializeField]
		private float _positionFadeTime = 2f;

		[SerializeField]
		private float _laserLength = 2f;

		private float laserTimer;

		private HandObject FromHand { get; set; }

		public Transform ToTransform { get; set; }

		private bool IsValid
		{
			get
			{
				if (FromHand != null)
				{
					return ToTransform != null;
				}
				return false;
			}
		}

		public bool Visible
		{
			get
			{
				return _line.enabled;
			}
			set
			{
				_line.enabled = value;
			}
		}

		protected override void Initialize()
		{
			laserTimer = 0f;
			SingletonMonoBehaviour<GameInputManager>.Instance.OnChangeMainHand.DelayFrame(1).Subscribe(delegate(VRDeviceDefine.HandType handType)
			{
				switch (handType)
				{
				case VRDeviceDefine.HandType.Left:
					FromHand = SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject;
					break;
				case VRDeviceDefine.HandType.Right:
					FromHand = SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject;
					break;
				default:
					FromHand = null;
					break;
				}
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			if (IsValid && _line.enabled)
			{
				int positionCount = _line.positionCount;
				Vector3 position = FromHand.ThisTransform.position;
				Vector3 b = position + FromHand.ThisTransform.forward * _laserLength;
				Vector3 b2 = Vector3.Lerp(ToTransform.position, b, Easing.EaseInOutCubic(0f, 1f, laserTimer / _positionFadeTime));
				for (int i = 0; i < positionCount; i++)
				{
					float t = (float)i / ((float)positionCount - 1f) * 0.9f + 0.05f;
					Vector3 position2 = Vector3.Lerp(position, b2, t);
					_line.SetPosition(i, position2);
				}
				laserTimer += delta;
			}
		}

		public void SetLaserColor(Color col)
		{
			LineRenderer line = _line;
			Color startColor = (_line.endColor = col);
			line.startColor = startColor;
		}
	}
	public class SelectionObject : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private AudioSource _audioSource;

		[SerializeField]
		private SelectionLaser _selectionLaser;

		[SerializeField]
		private Collider _collider;

		[Header("Components - Outline")]
		[SerializeField]
		private Renderer _colorRenderer;

		private Queue<IDisposable> _disposes;

		private bool _isHovered;

		private bool _interractable = true;

		private float _startTime;

		private Material _colorMaterial;

		private Subject<Color> _subjectGradiateColor = new Subject<Color>();

		private Subject<bool> _subjectEndSelection = new Subject<bool>();

		public int SelectionIndex { get; set; }

		public AudioSource SelectionAudioSource => _audioSource;

		public bool Interractable
		{
			get
			{
				return _interractable;
			}
			set
			{
				_interractable = value;
			}
		}

		public Color ColorWaiting1 { get; set; }

		public Color ColorWaiting2 { get; set; }

		public IObservable<PointerEventData> OnSelectionEnter { get; private set; }

		public IObservable<PointerEventData> OnSelectionExit { get; private set; }

		public IObservable<PointerEventData> OnSelectionDown { get; private set; }

		public IObservable<PointerEventData> OnSelectionUp { get; private set; }

		public IObservable<PointerEventData> OnSelectionClick { get; private set; }

		private IObservable<Unit> UpdateObserbable => SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable;

		public IObservable<Color> GradiateColorObservable => _subjectGradiateColor;

		public IObservable<bool> EndSelectionObservable => _subjectEndSelection;

		private float LiveTime => Time.time - _startTime;

		private void Awake()
		{
			_disposes = new Queue<IDisposable>();
			ObservableEventTrigger observableEventTrigger = base.gameObject.AddComponent<ObservableEventTrigger>();
			OnSelectionEnter = observableEventTrigger.OnPointerEnterAsObservable();
			OnSelectionExit = observableEventTrigger.OnPointerExitAsObservable();
			OnSelectionDown = observableEventTrigger.OnPointerDownAsObservable();
			OnSelectionUp = observableEventTrigger.OnPointerUpAsObservable();
			OnSelectionClick = observableEventTrigger.OnPointerClickAsObservable();
			if (_colorRenderer != null)
			{
				_colorMaterial = new Material(_colorRenderer.sharedMaterial);
				_colorRenderer.sharedMaterial = _colorMaterial;
			}
			_startTime = Time.time;
			GeneralSubscribes();
		}

		public void SetParentTransform(Transform t)
		{
			base.transform.SetParent(t, worldPositionStays: false);
		}

		public void SetLaserToTransform(Transform t)
		{
			_selectionLaser.ToTransform = t;
		}

		private void GeneralSubscribes()
		{
			_disposes.Enqueue(OnSelectionEnter.Subscribe(delegate
			{
				_isHovered = true;
			}));
			_disposes.Enqueue(OnSelectionExit.Subscribe(delegate
			{
				_isHovered = false;
			}));
			_disposes.Enqueue(UpdateObserbable.Where((Unit _) => Interractable && !_isHovered).Subscribe(delegate
			{
				float t = Mathf.Sin(LiveTime * (float)Math.PI) * 0.5f + 0.5f;
				Color value = Color.Lerp(ColorWaiting1, ColorWaiting2, t);
				_subjectGradiateColor.OnNext(value);
			}).AddTo(base.gameObject));
		}

		public void SetInterractable(bool flag)
		{
			_collider.enabled = flag;
		}

		public void SetLaserVibisle(bool flag)
		{
			_selectionLaser.Visible = flag;
		}

		public void SetOutlineColor(Color color)
		{
			if (_colorMaterial != null)
			{
				_colorMaterial.SetColor("_Color", color);
			}
		}

		public void EndSelection(bool selected)
		{
			DisposeSelectEvents();
			_isHovered = false;
			SetLaserVibisle(flag: false);
			SetInterractable(flag: false);
			_subjectEndSelection.OnNext(selected);
			_subjectEndSelection.OnCompleted();
		}

		private void DisposeSelectEvents()
		{
			while (_disposes.Count > 0)
			{
				_disposes.Dequeue().Dispose();
			}
		}
	}
	public abstract class BaseCommandEnable : BaseCommandToggleFlag
	{
		public BaseCommandEnable()
		{
		}

		public BaseCommandEnable(SequenceData.Param data)
			: base(data)
		{
		}

		protected override string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "無効";
			}
			return "有効";
		}
	}
	public abstract class BaseCommandProhibit : BaseCommandToggleFlag
	{
		public BaseCommandProhibit()
		{
		}

		public BaseCommandProhibit(SequenceData.Param data)
			: base(data)
		{
		}

		protected override string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "許可";
			}
			return "禁止";
		}
	}
	public abstract class BaseCommandSceneProp : ISequenceCommand
	{
		public PropDefines.PropType PropType;

		public int PropIndex;

		public bool IsDynamicProp => PropType == PropDefines.PropType.Dynamic;

		protected void LoadFromData(SequenceData.Param data)
		{
			PropType = (PropDefines.PropType)data.DataInt[0];
			PropIndex = data.DataInt[1];
		}

		protected bool GetPropAvailable(TimelinePlayer player)
		{
			if (player == null)
			{
				return false;
			}
			return PropType switch
			{
				PropDefines.PropType.Static => player.CurrentBackground.HasStaticProps, 
				PropDefines.PropType.Dynamic => player.CurrentBackground.HasDynamicProps, 
				_ => false, 
			};
		}

		protected BaseProp GetPropObject(TimelinePlayer player)
		{
			return GetPropObject(player, PropType, PropIndex);
		}

		protected BaseProp GetPropObject(TimelinePlayer player, PropDefines.PropType type, int index)
		{
			return type switch
			{
				PropDefines.PropType.Static => player.CurrentBackground.StaticProps.GetPropByIndex(index), 
				PropDefines.PropType.Dynamic => player.CurrentBackground.DynamicProps.GetPropByIndex(index), 
				_ => null, 
			};
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!GetPropAvailable(player))
			{
				throw new CommandFailedException(this, $"{PropType} が定義されていません");
			}
			BaseProp propObject = GetPropObject(player);
			if (propObject == null)
			{
				throw new CommandFailedException(this, $"プロップ {PropType}.{PropIndex} を取得できませんでした");
			}
			return PlayCommandWithProp(player, propObject);
		}

		protected virtual bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			throw new CommandFailedException(this, "Propコマンド内容が定義されていません");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)PropType);
			data.DataInt.Add(PropIndex);
		}
	}
	public abstract class BaseCommandSceneTo : ISequenceCommand
	{
		public int NextScquenceID = 10000;

		public bool IgnoreAutoSave;

		protected virtual SceneDefine SceneTransitionTo => SceneDefine.Blank;

		public override PreloadTypes PreloadType => PreloadTypes.UnityScene;

		public override int PreloadIndex => (int)SceneTransitionTo;

		public override bool PlayInHardSkip => true;

		public BaseCommandSceneTo()
		{
		}

		public BaseCommandSceneTo(SequenceData.Param data, int version)
		{
			NextScquenceID = data.GetInt(0);
			IgnoreAutoSave = IntToBool(data.GetInt(1));
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.CompleteScenario();
			SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = NextScquenceID;
			if (!IgnoreAutoSave)
			{
				player.ResolveReservedAutoSave();
			}
			player.ChangeSceneToSpecial(SceneTransitionTo);
			return false;
		}

		public override void OnEnd(TimelinePlayer player)
		{
			if (SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID == -1)
			{
				player.QuitToTitle();
			}
			else
			{
				player.ReserveLoadScenerio(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
			}
		}

		public override ISequenceCommand Clone()
		{
			return (BaseCommandSceneTo)MemberwiseClone();
		}

		protected string GetNextScquenceString()
		{
			string text = ((NextScquenceID < 0) ? "タイトルに戻る" : $"次のSqID: {NextScquenceID:00000}");
			if (IgnoreAutoSave)
			{
				text += " (オートセーブなし) ";
			}
			return text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(NextScquenceID);
			data.DataInt.Add(BoolToInt(IgnoreAutoSave));
		}
	}
	public abstract class BaseCommandToggleFlag : ISequenceCommand
	{
		public bool ToggleFlag = true;

		public BaseCommandToggleFlag()
		{
			ToggleFlag = true;
		}

		public BaseCommandToggleFlag(SequenceData.Param data)
		{
			ToggleFlag = data.DataInt[0] != 0;
		}

		protected virtual string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "無効";
			}
			return "有効";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(ToggleFlag));
		}
	}
	public abstract class BaseLogicCommand : ISequenceCommand
	{
		public bool IsLogicTrue { get; protected set; }

		public override bool IsLogic => true;
	}
	public class CommandAmbient : CommandSe2D
	{
		public const string NAME = "{0:D3}";

		public const string PATH = "{0}{1:D3}";

		public override Types Type => Types.PlayAmbient;

		public override PreloadTypes PreloadType => PreloadTypes.AmbientEffect;

		public override int PreloadIndex => base.ID;

		public CommandAmbient()
		{
		}

		public CommandAmbient(int id, float volume, bool isRepeat)
			: base(id, volume, isRepeat)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override string GetFilePath()
		{
			return string.Format("{0}{1:D3}", "Audio/Ambient/", base.ID);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAmbient)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"環境音：ID = {base.ID}, ループ = {IsRepeat}";
		}
	}
	public class CommandAmbientOff : CommandSe2DOff
	{
		public override Types Type => Types.StopAmbient;

		public CommandAmbientOff()
		{
		}

		public CommandAmbientOff(int id)
		{
			ID = id;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAmbientOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "環境音停止";
		}
	}
	public class CommandAutoWaitOverride : ISequenceCommand
	{
		public bool Enabled = true;

		public int MessageSpeed;

		public float Duration = 10f;

		public override Types Type => Types.CommandAutoWaitOverride;

		public CommandAutoWaitOverride()
		{
		}

		public CommandAutoWaitOverride(SequenceData.Param data, int version)
			: base(data, version)
		{
			Enabled = IntToBool(data.GetInt(0));
			MessageSpeed = data.GetInt(1);
			Duration = data.GetFloat(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.IsAutoWaitOverrided = Enabled;
			if (Enabled)
			{
				player.MessageProcessor.AutoWaitOverride = Duration;
				player.MessageProcessor.MessageSpeedOverride = MessageSpeed;
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAutoWaitOverride)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (!Enabled)
			{
				return "オートモード待ち時間上書き: 元に戻す";
			}
			return $"オートモード待ち時間上書き: {Duration:F2} 秒, メッセージ速度 {MessageSpeed}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(Enabled));
			data.DataInt.Add(MessageSpeed);
			data.DataFloat.Add(Duration);
		}
	}
	public class CommandAvaterOutline : ISequenceCommand
	{
		public PlayerAvater.AvaterParts TargetPart;

		public PlayerAvater.FadeModes FadeMode;

		public float FadeDuration = 0.3f;

		public float OutlineSize = 0.1f;

		public Color OutlineColor = new Color(0.75f, 0.75f, 0.75f);

		public bool FlagChangeSize = true;

		public bool FlagChangeColor = true;

		public override Types Type => Types.AvaterOutline;

		public CommandAvaterOutline()
		{
		}

		public CommandAvaterOutline(SequenceData.Param data, int saveVersion)
		{
			TargetPart = (PlayerAvater.AvaterParts)data.GetInt(0);
			FadeMode = (PlayerAvater.FadeModes)data.GetInt(1);
			FlagChangeSize = IntToBool(data.GetInt(2));
			FlagChangeColor = IntToBool(data.GetInt(3));
			OutlineSize = data.GetFloat(0);
			OutlineColor.r = data.GetFloat(1);
			OutlineColor.g = data.GetFloat(2);
			OutlineColor.b = data.GetFloat(3);
			OutlineColor.a = data.GetFloat(4);
			FadeDuration = data.GetFloat(5);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.SetOutlineParameters(TargetPart, this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAvaterOutline)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "<b>アバターアウトライン変更</b>:";
			text += $" 対象[<b>{TargetPart}</b>]";
			switch (FadeMode)
			{
			case PlayerAvater.FadeModes.None:
				text += " フェード[瞬時]";
				break;
			case PlayerAvater.FadeModes.Smooth:
				text += $" フェード[スムース {FadeDuration:F1} s]";
				break;
			case PlayerAvater.FadeModes.Dither:
				text += $" フェード[ディザ {FadeDuration:F1} s]";
				break;
			}
			text = ((!FlagChangeSize) ? (text + " 太さ[継承]") : (text + $" 太さ[{OutlineSize:F2}]"));
			if (FlagChangeColor)
			{
				return text + $" 色[<color=#{ColorUtility.ToHtmlStringRGB(OutlineColor)}>■■■</color>]";
			}
			return text + " 色[継承]";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetPart);
			data.DataInt.Add((int)FadeMode);
			data.DataInt.Add(BoolToInt(FlagChangeSize));
			data.DataInt.Add(BoolToInt(FlagChangeColor));
			data.DataFloat.Add(OutlineSize);
			data.DataFloat.Add(OutlineColor.r);
			data.DataFloat.Add(OutlineColor.g);
			data.DataFloat.Add(OutlineColor.b);
			data.DataFloat.Add(OutlineColor.a);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandAvaterTexture : ISequenceCommand
	{
		public PlayerAvater.AvaterParts TargetPart;

		public AdvCharaTextureData.TextureType TextureType;

		public override Types Type => Types.AvaterTexture;

		public CommandAvaterTexture()
		{
		}

		public CommandAvaterTexture(SequenceData.Param data, int version)
			: base(data, version)
		{
			TargetPart = (PlayerAvater.AvaterParts)data.DataInt[0];
			TextureType = (AdvCharaTextureData.TextureType)data.DataInt[1];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.AvaterResources.ChangeTextureType(TextureType, TargetPart);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandAvaterTexture)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "<b>アバターテクスチャ変更</b>: " + TargetPart.ToString() + " を " + TextureType;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetPart);
			data.DataInt.Add((int)TextureType);
		}
	}
	public class CommandBackgroundActive : ISequenceCommand
	{
		public bool IsActive;

		public SceneDefine Scene = SceneDefine.Crossing;

		private int m_layer;

		public override Types Type => Types.BackgroundActive;

		public CommandBackgroundActive()
		{
		}

		public CommandBackgroundActive(SequenceData.Param data, int version)
		{
			IsActive = IntToBool(data.DataInt[0]);
			Scene = (SceneDefine)data.DataInt[1];
			m_layer = LayerMask.NameToLayer("Environment");
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (Scene == SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId)
			{
				if (player.CurrentBackground != null)
				{
					player.CurrentBackground.SetActive(IsActive);
					return true;
				}
				FindAndActivateBackground(SingletonMonoBehaviour<TransitionManager>.Instance.CurrentScene);
				return true;
			}
			FindAndActivateBackground(SceneManager.GetSceneByBuildIndex((int)Scene));
			return true;
		}

		private void FindAndActivateBackground(Scene scene)
		{
			GameObject[] rootGameObjects = scene.GetRootGameObjects();
			int num = rootGameObjects.Length;
			for (int i = 0; i < num; i++)
			{
				if (rootGameObjects[i].layer == m_layer && !(rootGameObjects[i].GetComponent<AdvBackground>() == null))
				{
					rootGameObjects[i].SetActive(IsActive);
					break;
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBackgroundActive)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (!IsActive)
			{
				return "背景オフ : " + Scene;
			}
			return "背景オン : " + Scene;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsActive));
			data.DataInt.Add((int)Scene);
		}
	}
	public class CommandBgm : ISequenceCommand, ISoundCommand
	{
		private const int _MEMORY_AMBIENT_FADE_BARS = 4;

		public KainePlayer.Layers Layer;

		public bool IsStopMemoryAmbient = true;

		private bool m_hasPlayedBgm = true;

		public override Types Type => Types.PlayBgm;

		public override PreloadTypes PreloadType => PreloadTypes.BgmAdvanced;

		public override int PreloadIndex => ID;

		public int ID { get; set; }

		public AudioClip Clip { get; set; }

		public CommandBgm()
		{
		}

		public CommandBgm(int id, KainePlayer.Layers layer)
		{
			ID = id;
			Layer = layer;
		}

		public CommandBgm(SequenceData.Param data)
		{
			ID = data.DataInt[0];
			Layer = (KainePlayer.Layers)data.DataInt[1];
			if (data.DataInt.Count > 2)
			{
				IsStopMemoryAmbient = IntToBool(data.DataInt[2]);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			m_hasPlayedBgm = !SoundManager.Bgm.PreparePlay(ID, Layer);
			if (!IsStopMemoryAmbient || player.CurrentBackground == null || !player.CurrentBackground.HasAudioSource)
			{
				return m_hasPlayedBgm;
			}
			AudioSourceFader audio = player.CurrentBackground.Audio;
			if (!audio.IsPlaying)
			{
				return m_hasPlayedBgm;
			}
			audio.StopWithFade(SoundManager.Bgm.GetIntroDuration());
			return m_hasPlayedBgm;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!m_hasPlayedBgm)
			{
				m_hasPlayedBgm = true;
				SoundManager.Bgm.StartPlay(Layer);
			}
			return true;
		}

		public string GetFilePath()
		{
			return string.Empty;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgm)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"BGM再生 : BGMID {ID}, レイヤー {Layer}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataInt.Add((int)Layer);
			data.DataInt.Add(BoolToInt(IsStopMemoryAmbient));
		}
	}
	public class CommandBgmChangeLayer : ISequenceCommand
	{
		public KainePlayer.Layers Layer;

		public override Types Type => Types.BgmChangeLayer;

		public CommandBgmChangeLayer()
		{
			Layer = KainePlayer.Layers.Ambient;
		}

		public CommandBgmChangeLayer(KainePlayer.Layers layer)
		{
			Layer = layer;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.SetLayer(Layer);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmChangeLayer)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"BGMレイヤーを {Layer} に変更";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Layer);
		}
	}
	public class CommandBgmOff : ISequenceCommand
	{
		public BgmPlayer.StopMode StopMode = BgmPlayer.StopMode.Outro;

		public override Types Type => Types.StopBgm;

		public CommandBgmOff()
		{
			StopMode = BgmPlayer.StopMode.Outro;
		}

		public CommandBgmOff(BgmPlayer.StopMode mode)
		{
			StopMode = mode;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.Stop(StopMode);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"BGM停止 : {CreateModeTypeText()}";
		}

		protected string CreateModeTypeText()
		{
			return StopMode switch
			{
				BgmPlayer.StopMode.Fade => "フェードアウト", 
				BgmPlayer.StopMode.Outro => "アウトロ再生", 
				BgmPlayer.StopMode.Immidiate => "瞬間停止", 
				_ => string.Empty, 
			};
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)StopMode);
		}
	}
	public class CommandBgmSimple : ISequenceCommand, ISoundCommand
	{
		public const string FILENAME = "Audio/BgmSimple/{0:D4}";

		public float Volume = 1f;

		public float FadeDuration = 0.6f;

		public override Types Type => Types.PlayBgmSimple;

		public override PreloadTypes PreloadType => PreloadTypes.BgmSimple;

		public override int PreloadIndex => ID;

		public int ID { get; set; }

		public AudioClip Clip { get; set; }

		public CommandBgmSimple()
		{
		}

		public CommandBgmSimple(int id, float volume, float fadeDuration)
		{
			ID = id;
			Volume = volume;
			FadeDuration = fadeDuration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.PlaySimple(ID, Volume, FadeDuration);
			return true;
		}

		public virtual string GetFilePath()
		{
			return $"Audio/BgmSimple/{ID:D4}";
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmSimple)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"シンプルBGM再生：ID {ID}, 音量 {Volume}, フェード時間 {FadeDuration}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataFloat.Add(Volume);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandBgmSimpleOff : ISequenceCommand
	{
		public float FadeDuration = 0.6f;

		public override Types Type => Types.StopBgmSimple;

		public CommandBgmSimpleOff()
		{
		}

		public CommandBgmSimpleOff(float fadeDuration)
		{
			FadeDuration = fadeDuration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.StopSimple(FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmSimpleOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"シンプルBgm停止：フェード時間 : {FadeDuration}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandBgmSimpleVolume : ISequenceCommand
	{
		public float Volume;

		public float FadeDuration;

		public override Types Type => Types.BgmSimpleVolumeChange;

		public CommandBgmSimpleVolume()
		{
		}

		public CommandBgmSimpleVolume(float volume, float fadeDuration)
		{
			Volume = volume;
			FadeDuration = fadeDuration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.Bgm.SetSimpleVolume(Volume, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBgmSimpleVolume)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"シンプルBgm音量変更 : 音量 {Volume}, フェード時間 {FadeDuration}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Volume);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandBokeSphere : ISequenceCommand
	{
		public enum Environment
		{
			Crossing,
			Building,
			ElevatorHole,
			Hotel,
			BuildingRoofMono,
			BuildingRoof,
			PlayDome
		}

		public Environment Envrionment;

		public bool IsPlaceAtPlayer = true;

		public Vector3 Position;

		public float Rotation;

		public override Types Type => Types.BokeSphereStart;

		public override PreloadTypes PreloadType => PreloadTypes.BokeSphere;

		public override int PreloadIndex => (int)Envrionment;

		public CommandBokeSphere()
		{
		}

		public CommandBokeSphere(Environment environment, bool isPlaceAtChara, Vector3 pos, float rotationY)
		{
			Envrionment = environment;
			IsPlaceAtPlayer = isPlaceAtChara;
			Position = pos;
			Rotation = rotationY;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.BokeSphereProcessor.Play(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBokeSphere)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"ボケ背景を設置：種類 {Envrionment.ToString()}, オフセット {Position.ToString()}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Envrionment);
			data.DataInt.Add(BoolToInt(IsPlaceAtPlayer));
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataFloat.Add(Rotation);
		}
	}
	public class CommandBokeSphereEnd : ISequenceCommand
	{
		public bool IsKeepCullingSetting;

		public override Types Type => Types.BokeSphereEnd;

		public CommandBokeSphereEnd()
		{
		}

		public CommandBokeSphereEnd(SequenceData.Param data)
		{
			if (data.DataInt.Count > 0)
			{
				IsKeepCullingSetting = IntToBool(data.DataInt[0]);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.BokeSphereProcessor.End(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandBokeSphereEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"ボケ背景を取り除く: 背景表示消したままか？：{IsKeepCullingSetting}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsKeepCullingSetting));
		}
	}
	public class CommandChangeForcusUp : ISequenceCommand
	{
		public int WindowID;

		public int ID;

		public float FadeDuration = 0.4f;

		public override Types Type => Types.ForcusUpChange;

		public override PreloadTypes PreloadType => PreloadTypes.FocusUp;

		public override int PreloadIndex => ID;

		public CommandChangeForcusUp()
		{
		}

		public CommandChangeForcusUp(int windowID, int id, float fadeDuration)
		{
			WindowID = windowID;
			ID = id;
			FadeDuration = fadeDuration;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandChangeForcusUp)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FocusUpProcessor.ChangeTexture(WindowID, ID, FadeDuration);
			return true;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(WindowID);
			data.DataInt.Add(ID);
			data.DataFloat.Add(FadeDuration);
		}

		public override string CreateDescriptionText()
		{
			return $"フォーカスアップ変更: ウィンドウID:{WindowID}, 画像ID{ID}, フェード時間{FadeDuration}";
		}
	}
	public class CommandChangeScene : ISequenceCommand
	{
		public SceneDefine NextScene = SceneDefine.Title;

		public override Types Type => Types.Scene;

		public override PreloadTypes PreloadType => PreloadTypes.UnityScene;

		public override int PreloadIndex => (int)NextScene;

		public CommandChangeScene()
		{
			NextScene = SceneDefine.Title;
		}

		public CommandChangeScene(SceneDefine nextScene)
		{
			NextScene = nextScene;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.ChangeScene(NextScene);
			player.Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, 0f, isDeactivateOnEnd: false);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandChangeScene)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"Unityシーン変更 : {NextScene.ToString()}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)NextScene);
		}
	}
	public class CommandChangeSequence : ISequenceCommand
	{
		public int ID = -1;

		public override Types Type => Types.Sequence;

		public override bool PlayInHardSkip => true;

		public CommandChangeSequence()
		{
			ID = -1;
		}

		public CommandChangeSequence(int nextID)
		{
			ID = nextID;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, 0f, isDeactivateOnEnd: false);
			player.ReserveLoadScenerioWithComplete(ID);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandChangeSequence)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"演出ファイル読み込み : SID {ID:00000}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandCharaAttachPlayer : ICharaCommand
	{
		public static readonly Vector3 _ATTACHED_SCALE = new Vector3(0.5f, 0.5f, 0.5f);

		public Vector3 Position;

		public Vector3 Rotation;

		public bool IsBasePosition;

		public bool IsRotateWithPlayer;

		public bool IsAvoidScaling;

		public override Types Type => Types.CharaAttachPlayer;

		public CommandCharaAttachPlayer()
		{
		}

		public CommandCharaAttachPlayer(GameDefine.CharaID charaID)
			: base(charaID)
		{
		}

		public CommandCharaAttachPlayer(GameDefine.CharaID charaID, Vector3 pos, Vector3 rot)
			: base(charaID)
		{
			Position = pos;
			Rotation = rot;
		}

		public CommandCharaAttachPlayer(GameDefine.CharaID charaID, Vector3 pos, Vector3 rot, int flags)
			: base(charaID)
		{
			Position = pos;
			Rotation = rot;
			IsBasePosition = (flags & 1) != 0;
			IsRotateWithPlayer = (flags & 2) != 0;
			IsAvoidScaling = (flags & 4) != 0;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			Transform target = SingletonMonoBehaviour<PlayAreaManager>.Instance.CameraAnchorTransform;
			Vector3 position = Position;
			Vector3 scale = _ATTACHED_SCALE;
			if (IsBasePosition)
			{
				position.y -= 5.17f;
			}
			if (IsRotateWithPlayer)
			{
				target = MainPosition.Avater.MessagePivot;
			}
			if (IsAvoidScaling)
			{
				scale = Vector3.one;
			}
			chara.AttachTo(target, Position, Rotation, scale);
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: true);
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaAttachPlayer)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara} をプレイヤーにアタッチ (オフセット: {Position.ToString()})";
		}

		public override void Save(SequenceData.Param data)
		{
			int num = 0;
			if (IsBasePosition)
			{
				num++;
			}
			if (IsRotateWithPlayer)
			{
				num += 2;
			}
			if (IsAvoidScaling)
			{
				num += 4;
			}
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(num);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandCharaChange : ICharaCommand
	{
		public int NextScenarioID;

		public override Types Type => Types.CharaChange;

		public override bool PlayInHardSkip => true;

		public CommandCharaChange()
		{
		}

		public CommandCharaChange(GameDefine.CharaID nextChara, int nextScenarioID)
			: base(nextChara)
		{
			NextScenarioID = nextScenarioID;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.CompleteScenario();
			SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = NextScenarioID;
			SingletonMonoBehaviour<LocalData>.Instance.NextCharaID = Chara;
			player.ResolveReservedAutoSave();
			player.ChangeSceneToSpecial(SceneDefine.ChangeChara);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"キャラ変更演出呼び出し - {Chara}, 次SID {NextScenarioID:0000}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(NextScenarioID);
		}
	}
	public class CommandCharaCircularPosition : ICharaCommand
	{
		public bool IsFade = true;

		public float Radius = 7f;

		public float Angle;

		private AdvChara m_chara;

		private Action m_onStartFadeEnd;

		public override Types Type => Types.CharaCircularPosition;

		public CommandCharaCircularPosition()
			: base(GameDefine.CharaID.MOMONO)
		{
		}

		public CommandCharaCircularPosition(GameDefine.CharaID chara, float radius, float angle, bool isFade)
			: base(chara)
		{
			Radius = radius;
			Angle = angle;
			IsFade = isFade;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onStartFadeEnd = delegate
				{
					m_chara.Transform.localPosition = m_chara.NextPosition;
				};
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !chara.IsActive)
			{
				SetCharaPosition(chara.Transform, MainPosition.MainTransform);
				return true;
			}
			chara.NextPosition = CauclateCharaPosition(MainPosition.MainTransform);
			chara.Model.PlayPingPongFade(0.3f, 0.3f, m_onStartFadeEnd);
			return true;
		}

		public void SetCharaPosition(Transform chara, Transform player)
		{
			chara.position = CauclateCharaPosition(player);
		}

		public Vector3 CauclateCharaPosition(Transform player)
		{
			return CauclateCharaPosition(player, Angle, Radius);
		}

		public static Vector3 CauclateCharaPosition(Transform player, float angle, float radius)
		{
			Vector3 position = player.position;
			float num = angle + player.rotation.eulerAngles.y;
			position.x += Mathf.Sin((float)Math.PI / 180f * num) * radius;
			position.z += Mathf.Cos((float)Math.PI / 180f * num) * radius;
			position.y = 0f;
			return position;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaCircularPosition)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("{0} の円形位置配置: 半径 {1:0.0}, 角度 {2:0.0}{3}", Chara.ToString(), Radius, Angle, IsFade ? "" : " (フェードなし)");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataFloat.Add(Radius);
			data.DataFloat.Add(Angle);
		}
	}
	public class CommandCharaDetachPlayer : ICharaCommand
	{
		public override Types Type => Types.CharaDetachPlayer;

		public CommandCharaDetachPlayer()
		{
		}

		public CommandCharaDetachPlayer(GameDefine.CharaID chara)
			: base(chara)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			chara.Detach();
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: false);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: false);
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaDetachPlayer)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara} をプレイヤーからデタッチ";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
		}
	}
	public class CommandCharaFacial : CommandCharaMotion
	{
		public const int _DEFAULT_ID = 301;

		public override Types Type => Types.CharaFace;

		public CommandCharaFacial()
		{
			Motion = 301;
		}

		public CommandCharaFacial(GameDefine.CharaID chara, int motion, bool isFade, bool isPlayAnimation)
			: base(chara, motion, isFade: false, isPlayAnimation)
		{
		}

		protected override void SetCharaSafetyFlag(AdvChara chara)
		{
			chara.HasInitialFacial = true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaFacial)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara}のフェイシャルモーション {Motion} を再生: アニメ{IsPlayAnimation}";
		}
	}
	public class CommandCharaLookAt : ICharaCommand
	{
		public enum SourceType
		{
			Chara,
			Point,
			Prop,
			PropNode
		}

		public SourceType Source;

		public Vector3 Position;

		public GameDefine.CharaID Target = GameDefine.CharaID.BASE;

		public PropDefines.PropType Props;

		public int PropsId;

		public int PropsAnchorId;

		public bool IsPlayAnimation = true;

		public override Types Type => Types.CharaLootAt;

		public CommandCharaLookAt()
		{
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, GameDefine.CharaID target, bool isPlayAnimation, SourceType source)
			: base(chara)
		{
			Target = target;
			IsPlayAnimation = isPlayAnimation;
			Source = source;
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, bool isPlayAnimation, Vector3 targetPosition, SourceType sourceType = SourceType.Point)
			: base(chara)
		{
			Position = targetPosition;
			IsPlayAnimation = isPlayAnimation;
			Source = sourceType;
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, bool isPlayAnimation, PropDefines.PropType propsType, int propsId, SourceType source = SourceType.Prop)
			: base(chara)
		{
			IsPlayAnimation = isPlayAnimation;
			Props = propsType;
			PropsId = propsId;
			Source = source;
		}

		public CommandCharaLookAt(GameDefine.CharaID chara, bool isPlayAnimation, PropDefines.PropType propsType, int propsId, int propsAnchorId, SourceType source = SourceType.Prop)
			: base(chara)
		{
			IsPlayAnimation = isPlayAnimation;
			Props = propsType;
			PropsId = propsId;
			PropsAnchorId = propsAnchorId;
			Source = source;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				return true;
			}
			chara.HasInitialLookAt = true;
			chara.Look.IsUpdate = true;
			if (Source == SourceType.Point)
			{
				chara.Look.SetLookAtPosition(Position, IsPlayAnimation);
			}
			else if (Source == SourceType.Prop)
			{
				chara.Look.SetLookAtTransform(GetPropTransform(player), !IsPlayAnimation);
			}
			else
			{
				if (Target == GameDefine.CharaID.BASE)
				{
					chara.Look.SetLookAtTransform(MainPosition.CameraTransform, !IsPlayAnimation);
					return true;
				}
				if (Target == GameDefine.CharaID.UNKNOWN)
				{
					chara.Look.SetLookAtTransform(null, !IsPlayAnimation);
					return true;
				}
				AdvChara chara2 = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Target);
				if (chara2 == null)
				{
					return true;
				}
				chara.Look.SetLookAtTransform(chara2.Head, !IsPlayAnimation);
			}
			if (!player.HasPlayedFirstFade)
			{
				chara.Look.UpdateLookAtProcess();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaLookAt)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = (IsPlayAnimation ? "" : " (アニメスキップ)");
			switch (Source)
			{
			case SourceType.Point:
				return $"{Chara} が 座標 {Position} の方向を見る" + text;
			case SourceType.Prop:
				return $"{Chara} が プロップ {Props}.{PropsId} の方向を見る" + text;
			case SourceType.PropNode:
				return $"{Chara} が プロップ {Props}.{PropsId}.Anchor{PropsAnchorId} の方向を見る" + text;
			default:
				if (Target == GameDefine.CharaID.BASE)
				{
					return $"{Chara} が あなた の方向を見る" + text;
				}
				if (Target == GameDefine.CharaID.UNKNOWN)
				{
					return $"{Chara} の視点合わせを止める" + text;
				}
				return $"{Chara} が キャラクター {Target} の方向を見る" + text;
			}
		}

		private Transform GetPropTransform(TimelinePlayer player)
		{
			BaseProp propObject = GetPropObject(player, Props, PropsId);
			if (propObject == null)
			{
				return null;
			}
			return propObject.AnchorTransform;
		}

		private Transform GetPropAnchorTransform(TimelinePlayer player)
		{
			BaseProp propObject = GetPropObject(player, Props, PropsId);
			if (propObject == null)
			{
				return null;
			}
			return propObject.GetAnchor(PropsAnchorId);
		}

		private BaseProp GetPropObject(TimelinePlayer player, PropDefines.PropType type, int index)
		{
			return type switch
			{
				PropDefines.PropType.Static => player.CurrentBackground.StaticProps.GetPropByIndex(index), 
				PropDefines.PropType.Dynamic => player.CurrentBackground.DynamicProps.GetPropByIndex(index), 
				_ => null, 
			};
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)Target);
			data.DataInt.Add(BoolToInt(IsPlayAnimation));
			data.DataInt.Add((int)Source);
			if (Source == SourceType.Point)
			{
				data.DataFloat.Add(Position.x);
				data.DataFloat.Add(Position.y);
				data.DataFloat.Add(Position.z);
			}
			else if (Source == SourceType.Prop)
			{
				data.DataInt.Add((int)Props);
				data.DataInt.Add(PropsId);
			}
			else if (Source == SourceType.PropNode)
			{
				data.DataInt.Add((int)Props);
				data.DataInt.Add(PropsId);
				data.DataInt.Add(PropsAnchorId);
			}
		}
	}
	public class CommandCharaMotion : ICharaCommand
	{
		public int Motion;

		public bool IsFade = true;

		public bool IsPlayAnimation = true;

		public override Types Type => Types.CharaMotion;

		public CommandCharaMotion()
		{
		}

		public CommandCharaMotion(GameDefine.CharaID chara, int motion, bool isFade, bool isPlayAnimation)
			: base(chara)
		{
			Motion = motion;
			IsFade = isFade;
			IsPlayAnimation = isPlayAnimation;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				return true;
			}
			SetCharaSafetyFlag(chara);
			if (!chara.IsActive && !player.HasPlayedFirstFade)
			{
				ForceUpdateAnimation(chara);
				return true;
			}
			chara.Model.PlayAnimation(Motion, IsFade, !IsPlayAnimation);
			return true;
		}

		private void ForceUpdateAnimation(AdvChara chara)
		{
			chara.SetForcus(isForcus: true);
			chara.SetEnable(isEnable: true);
			chara.Model.PlayAnimation(Motion, IsFade, isSkipAnimation: true);
			chara.SetEnable(isEnable: false);
		}

		protected virtual void SetCharaSafetyFlag(AdvChara chara)
		{
			chara.HasInitialMotion = true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaMotion)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara} のキャラクターモーション {Motion} を再生";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(Motion);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataInt.Add(BoolToInt(IsPlayAnimation));
		}
	}
	public class CommandCharaOff : CommandCharaOn
	{
		public override Types Type => Types.CharaOff;

		protected override bool IsActivateChara => false;

		public CommandCharaOff()
		{
		}

		public CommandCharaOff(SequenceData.Param data, int version, bool isFade)
			: base(data, version, isFade)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaInListActive(player, isActive: false);
			return true;
		}

		public override string CreateDescriptionText()
		{
			return $"シーンから消える:フェード{FadeDuration}秒";
		}
	}
	public class CommandCharaOn : ICharaCommand
	{
		private class PlayData
		{
			public AdvChara Chara;

			public Action EnableAction;

			public PlayData(AdvChara chara, Action onFade)
			{
				Chara = chara;
				EnableAction = onFade;
			}
		}

		public float FadeDuration = 0.3f;

		public List<GameDefine.CharaID> CharaList;

		private List<PlayData> m_charaData;

		public override Types Type => Types.CharaOn;

		protected virtual bool IsActivateChara => true;

		public CommandCharaOn()
		{
			CharaList = new List<GameDefine.CharaID>();
			CharaList.Add(GameDefine.CharaID.NIKAIDOU);
		}

		public CommandCharaOn(SequenceData.Param data, int version, bool isFade)
		{
			CharaList = new List<GameDefine.CharaID>();
			int startIndex = 0;
			IsMemoryMode = false;
			if (version > 5)
			{
				IsMemoryMode = IntToBool(data.DataInt[startIndex++]);
			}
			CreateCharaEnableListFromData(data, startIndex);
			if (data.DataFloat.Count > 0)
			{
				FadeDuration = data.DataFloat[0];
				if (!isFade)
				{
					FadeDuration = 0f;
				}
				InitializeCharaList();
			}
		}

		protected virtual void InitializeCharaList()
		{
			if (!SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				return;
			}
			m_charaData = new List<PlayData>();
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(CharaList[i]);
				m_charaData.Add(new PlayData(chara, delegate
				{
					chara.SetEnable(IsActivateChara);
				}));
			}
		}

		private void CreateCharaEnableListFromData(SequenceData.Param data, int startIndex)
		{
			int count = data.DataInt.Count;
			for (int i = startIndex; i < count; i++)
			{
				CharaList.Add((GameDefine.CharaID)data.DataInt[i]);
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaOn)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaInListActive(player, isActive: true);
			return true;
		}

		protected virtual void SetCharaInListActive(TimelinePlayer player, bool isActive)
		{
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				SetCharaActive(player, i, isActive);
			}
		}

		protected virtual void SetCharaActive(TimelinePlayer player, int index, bool isActive)
		{
			AdvChara chara = m_charaData[index].Chara;
			if (isActive != chara.IsActive)
			{
				float targetAlpha = 0f;
				if (isActive)
				{
					targetAlpha = 1f;
					chara.SetEnable(isActive);
					chara.Model.SetModelAlpha(0f);
				}
				chara.Model.StartFade(targetAlpha, FadeDuration, m_charaData[index].EnableAction);
			}
		}

		public override string CreateDescriptionText()
		{
			string arg = ((FadeDuration <= 0f) ? "(瞬間)" : $"(フェード {FadeDuration:0.0} 秒)");
			return $"シーンに登場 {arg}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsMemoryMode));
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				data.DataInt.Add((int)CharaList[i]);
			}
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandCharaOutlineChange : ICharaCommand
	{
		private const float DEFAULT_ALPHA = 0.2f;

		public Color NextColor = new Color(0.75f, 0.75f, 0.75f);

		public float Duration = 0.5f;

		public float Threshold = 0.1f;

		public bool ChangeColor = true;

		public bool ChangeSize = true;

		public float FadeDuration = 0.3f;

		public override Types Type => Types.OutlineChange;

		public CommandCharaOutlineChange()
		{
		}

		public CommandCharaOutlineChange(SequenceData.Param data, int version)
		{
			Chara = (GameDefine.CharaID)data.DataInt[0];
			NextColor = new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]);
			Duration = data.DataFloat[4];
			Threshold = data.DataFloat[5];
			ChangeColor = IntToBool(data.DataInt[1]);
			ChangeSize = IntToBool(data.DataInt[2]);
			FadeDuration = data.DataFloat[6];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaOutlineChange(player, Chara, NextColor, Duration, Threshold, ChangeColor, ChangeSize, FadeDuration);
			return true;
		}

		protected void SetCharaOutlineChange(TimelinePlayer player, GameDefine.CharaID charaID, Color color, float duration, float threashold, bool changeColor, bool changeSize, float fadeDuration)
		{
			if (charaID == GameDefine.CharaID.BASE || charaID == GameDefine.CharaID.NONE)
			{
				return;
			}
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (fadeDuration > 0f)
			{
				if (changeColor && changeSize)
				{
					chara.Model.StartOutlineChangeWithFade(color, 0.2f, fadeDuration);
				}
				else if (changeColor)
				{
					chara.Model.StartOutlineChangeWithFade(threashold, 0.2f, fadeDuration);
				}
				else if (changeSize)
				{
					chara.Model.StartOutlineChangeWithFade(color, threashold, 0.2f, fadeDuration);
				}
			}
			else
			{
				if (changeColor)
				{
					chara.Model.StartOutlineColorChange(color, Duration);
				}
				if (changeSize)
				{
					chara.Model.StartOutlineSizeChange(threashold, Duration);
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaOutlineChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "アウトライン設定変更, 閾値:" + Threshold;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataFloat.Add(NextColor.r);
			data.DataFloat.Add(NextColor.g);
			data.DataFloat.Add(NextColor.b);
			data.DataFloat.Add(NextColor.a);
			data.DataFloat.Add(Duration);
			data.DataFloat.Add(Threshold);
			data.DataInt.Add(BoolToInt(ChangeColor));
			data.DataInt.Add(BoolToInt(ChangeSize));
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandCharaPosition : ICharaCommand
	{
		public Vector3 Position = Vector3.zero;

		public bool IsFade = true;

		public bool IsReletiveToPlayer = true;

		public bool IsLockY = true;

		private AdvChara m_chara;

		private Action m_onStartFadeEnd;

		public override Types Type => Types.CharaPosition;

		public CommandCharaPosition()
		{
		}

		public CommandCharaPosition(GameDefine.CharaID chara, Vector3 pos, bool isReletiveToPlayer, bool isFade, bool isLockY)
		{
			Position = pos;
			Chara = chara;
			IsReletiveToPlayer = isReletiveToPlayer;
			IsFade = isFade;
			IsLockY = isLockY;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onStartFadeEnd = delegate
				{
					SetCharaPosition(m_chara);
				};
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaPosition)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !chara.IsActive || chara.Transform.position == Position)
			{
				SetCharaPosition(chara);
				return true;
			}
			SetNextPosition(chara);
			chara.Model.PlayPingPongFade(0.3f, 0.3f, m_onStartFadeEnd);
			return true;
		}

		protected virtual void SetNextPosition(AdvChara chara)
		{
			chara.NextPosition = Position;
		}

		protected virtual void SetCharaPosition(AdvChara chara)
		{
			if (IsReletiveToPlayer)
			{
				SetCharaPositionReletiveToPlayer(MainPosition.MainTransform, chara);
			}
			else
			{
				chara.Transform.localPosition = Position;
			}
		}

		public void SetCharaPositionReletiveToPlayer(Transform player, AdvChara chara)
		{
			SetCharaPositionReletiveToPlayer(player, chara.Transform);
		}

		public void SetCharaPositionReletiveToPlayer(Transform player, Transform chara)
		{
			chara.localPosition = GetPositionReletiveToTarget(player);
		}

		public static void SetCharaPositionReletiveToPlayer(Transform player, AdvChara chara, ref Vector3 pos, bool isLockY)
		{
			chara.Transform.localPosition = GetPositionReletiveToTarget(player, ref pos, isLockY);
		}

		public static void SetCharaNextPositionReletiveToPlayer(Transform player, AdvChara chara, ref Vector3 pos, bool isLockY)
		{
			chara.NextPosition = GetPositionReletiveToTarget(player, ref pos, isLockY);
		}

		public Vector3 GetPositionReletiveToTarget(Transform target)
		{
			return GetPositionReletiveToTarget(target, ref Position, IsLockY);
		}

		public static Vector3 GetPositionReletiveToTarget(Transform target, ref Vector3 position, bool isLockY)
		{
			Vector3 position2 = target.position;
			Vector3 forward = target.forward;
			float y = position2.y;
			position2 += forward * position.z;
			position2 += target.right * position.x;
			if (isLockY)
			{
				position2.y += position.y - y;
			}
			else
			{
				position2.y -= 5.17f;
			}
			return position2;
		}

		public Vector3 GetCharaPosition(Transform player)
		{
			if (IsReletiveToPlayer)
			{
				return GetPositionReletiveToTarget(player);
			}
			return Position;
		}

		public override string CreateDescriptionText()
		{
			string text = (IsFade ? "" : " (フェードなし)");
			if (IsReletiveToPlayer)
			{
				return $"{Chara} のキャラ位置: プレイヤー相対位置 {Position.ToString()}" + text;
			}
			return $"{Chara} のキャラ位置: ワールド位置 {Position.ToString()}" + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsReletiveToPlayer));
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataInt.Add(BoolToInt(IsLockY));
		}
	}
	public class CommandCharaPositionReletive : CommandCharaPosition
	{
		public override Types Type => Types.CharaPositionReletive;

		public CommandCharaPositionReletive()
		{
		}

		public CommandCharaPositionReletive(GameDefine.CharaID chara, Vector3 position, bool isFade)
			: base(chara, position, isReletiveToPlayer: false, isFade, isLockY: false)
		{
		}

		protected override void SetCharaPosition(AdvChara chara)
		{
			chara.Transform.Translate(Position, Space.Self);
		}

		protected override void SetNextPosition(AdvChara chara)
		{
			Vector3 a = chara.Transform.localPosition;
			Vector3Extension.Add(ref a, ref Position, out chara.NextPosition);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaPositionReletive)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"キャラ相対配置: {Position}";
		}
	}
	public class CommandCharaRotation : ICharaCommand
	{
		public Vector3 Rotation = Vector3.zero;

		public bool IsReletiveToPlayer = true;

		public bool IsFade = true;

		private AdvChara m_chara;

		private Action m_onFade;

		public override Types Type => Types.CharaRotate;

		public CommandCharaRotation()
		{
		}

		public CommandCharaRotation(GameDefine.CharaID chara, Vector3 rotation, bool isReletiveToPlayer, bool isFade)
		{
			Rotation = rotation;
			Chara = chara;
			IsReletiveToPlayer = isReletiveToPlayer;
			IsFade = isFade;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onFade = delegate
				{
					SetCharaRotation(m_chara);
				};
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaRotation)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !chara.IsActive)
			{
				SetCharaRotation(chara);
				return true;
			}
			chara.Model.PlayPingPongFade(0.3f, 0.3f, m_onFade);
			return true;
		}

		protected virtual void SetCharaRotation(AdvChara chara)
		{
			if (IsReletiveToPlayer)
			{
				SetCharaRotationReletiveToPlayer(MainPosition.MainTransform, chara);
			}
			else
			{
				chara.Transform.localEulerAngles = Rotation;
			}
		}

		public void SetCharaRotationReletiveToPlayer(Transform player, AdvChara chara)
		{
			SetCharaRotationReletiveToPlayer(player, chara.Transform, ref Rotation);
		}

		public static void SetCharaRotationReletiveToPlayer(Transform player, Transform chara, ref Vector3 rotation)
		{
			chara.eulerAngles = player.rotation.eulerAngles;
			chara.Rotate(rotation);
		}

		public override string CreateDescriptionText()
		{
			string text = (IsFade ? "" : " (フェードなし)");
			if (IsReletiveToPlayer)
			{
				return $"{Chara} のキャラ回転: プレイヤー相対位置 {Rotation.ToString()}" + text;
			}
			return $"{Chara} のキャラ回転: ワールド位置 {Rotation.ToString()}" + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsReletiveToPlayer));
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandCharaRotationReletive : CommandCharaRotation
	{
		public override Types Type => Types.CharaRotateReletive;

		public CommandCharaRotationReletive()
		{
		}

		public CommandCharaRotationReletive(GameDefine.CharaID chara, Vector3 rotation, bool isReletiveToPlayer, bool isFade)
			: base(chara, rotation, isReletiveToPlayer, isFade)
		{
		}

		protected override void SetCharaRotation(AdvChara chara)
		{
			chara.Transform.Rotate(Rotation, Space.Self);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaRotationReletive)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("{0} のキャラ相対回転 : {1}{2}", Chara, Rotation, IsFade ? "" : " (フェードなし)");
		}
	}
	public class CommandCharaSetMirrorMode : ICharaCommand
	{
		public enum MirrorModeTypes
		{
			NoMirror,
			DrawOnlyMirror
		}

		public MirrorModeTypes MirrorMode;

		public bool isTrackingPlayerHead;

		public override Types Type => Types.CharaSetMirrorMode;

		public CommandCharaSetMirrorMode()
		{
		}

		public CommandCharaSetMirrorMode(GameDefine.CharaID chara, int modeInt, bool isTrackingHead = false)
		{
			Chara = chara;
			MirrorMode = (MirrorModeTypes)modeInt;
			isTrackingPlayerHead = isTrackingHead;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaSetMirrorMode)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaMirrorMode();
			return true;
		}

		protected void SetCharaMirrorMode()
		{
			Vector3 scale = Vector3.one;
			bool isMirroring = false;
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			if (MirrorMode == MirrorModeTypes.DrawOnlyMirror)
			{
				scale = new Vector3(-1f, 1f, 1f);
				isMirroring = true;
			}
			chara.AttachMirroring(scale, isMirroring, isTrackingPlayerHead);
		}

		public override string ToString()
		{
			return $"{Type.ToString()} : {Chara.ToString()}";
		}

		public override string CreateDescriptionText()
		{
			string arg = "";
			string arg2 = "なし";
			switch (MirrorMode)
			{
			case MirrorModeTypes.NoMirror:
				arg = "鏡から消える";
				break;
			case MirrorModeTypes.DrawOnlyMirror:
				arg = "鏡だけに映る";
				break;
			}
			if (isTrackingPlayerHead)
			{
				arg2 = "あり";
			}
			return $"{Chara} が{arg} （頭トラッキング{arg2}）";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)MirrorMode);
			data.DataInt.Add(BoolToInt(isTrackingPlayerHead));
		}
	}
	public class CommandCharaStyleChange : ICharaCommand
	{
		public bool IsChange;

		public override Types Type => Types.CharaStyleChange;

		public CommandCharaStyleChange()
		{
		}

		public CommandCharaStyleChange(SequenceData.Param data, int version)
		{
			Chara = (GameDefine.CharaID)data.DataInt[0];
			IsChange = IntToBool(data.DataInt[1]);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaStyleChange(player, Chara, IsChange);
			return true;
		}

		protected void SetCharaStyleChange(TimelinePlayer player, GameDefine.CharaID charaID, bool isChange)
		{
			SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara).StyleChange.CharaStyleChange(isChange);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaStyleChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string arg = "";
			string arg2 = "非表示";
			if (!IsChange)
			{
				arg2 = "表示";
			}
			switch (Chara)
			{
			case GameDefine.CharaID.SAKURAI:
			case GameDefine.CharaID.TOUGOKU:
			case GameDefine.CharaID.KAGEYAMA:
				arg = "靴";
				break;
			case GameDefine.CharaID.HITOKAGE:
				arg = "髪ゆら";
				break;
			}
			return $"{Chara} の{arg}を{arg2}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsChange));
		}
	}
	public class CommandCharaTexture : ICharaCommand
	{
		public AdvCharaTextureData.TextureType TextureType;

		private AdvChara m_chara;

		public override Types Type => Types.CharaTexture;

		public CommandCharaTexture()
		{
		}

		public CommandCharaTexture(SequenceData.Param data, int version)
		{
			Chara = (GameDefine.CharaID)data.DataInt[0];
			TextureType = (AdvCharaTextureData.TextureType)data.DataInt[1];
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			m_chara.Model.SetTexture(TextureType);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaTexture)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"キャラテクスチャ切り替え：種類{TextureType}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)TextureType);
		}
	}
	public class CommandCharaTransform : ICharaCommand
	{
		public enum MoveType
		{
			World,
			Self,
			ReletivePlayer,
			Radius
		}

		public enum RotationType
		{
			World,
			Self,
			ReletivePlayer
		}

		public Vector3 Position = Vector3Extension.Zero;

		public Vector3 Rotation = Vector3Extension.Zero;

		public int Motion;

		public int Facial = 301;

		public float Radius = 7f;

		public float Angle;

		public MoveType MoveMode;

		public RotationType RotationMode;

		public bool IsMove;

		public bool IsRotate;

		public bool IsMotion;

		public bool IsFacial;

		public bool IsFade = true;

		public bool IsPlayAnimationMotion = true;

		public bool IsPlayAnimationFace = true;

		public bool IsLockY = true;

		private AdvChara m_chara;

		private Action m_onStartFadeEnd;

		public override Types Type => Types.CharaTransform;

		public CommandCharaTransform()
		{
		}

		public CommandCharaTransform(GameDefine.CharaID chara, bool isMove, bool isRotate, bool isMotion, bool isFacial, bool isFade)
			: base(chara)
		{
			IsMove = isMove;
			IsRotate = isRotate;
			IsMotion = isMotion;
			IsFacial = isFacial;
			IsFade = isFade;
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
				m_onStartFadeEnd = delegate
				{
					ApplyTransform(m_chara, MainPosition.MainTransform, isFade: true);
				};
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (m_chara == null)
			{
				return true;
			}
			if (!IsFade || !m_chara.IsActive)
			{
				PlayNow(player.HasPlayedFirstFade);
				return true;
			}
			SetCharaNextPosition(m_chara, MainPosition.MainTransform);
			m_chara.Model.PlayPingPongFade(1f, 0.3f, 0.3f, m_onStartFadeEnd);
			return true;
		}

		private void PlayNow(bool hasPlayedFirstFade)
		{
			if (!m_chara.IsActive && (!hasPlayedFirstFade || !m_chara.IsForcused))
			{
				m_chara.SetForcus(isForcus: true);
				m_chara.SetEnable(isEnable: true);
				ApplyTransform(m_chara, MainPosition.MainTransform, isFade: false);
				if (hasPlayedFirstFade)
				{
					m_chara.SetForcus(isForcus: false);
				}
				m_chara.SetEnable(isEnable: false);
			}
			else
			{
				ApplyTransform(m_chara, MainPosition.MainTransform, isFade: false);
			}
		}

		public void ApplyTransform(AdvChara chara, Transform player, bool isFade)
		{
			SetCharaPosition(chara, player, isFade);
			SetCharaRotation(chara.Transform, player);
			PlayMotion(chara);
			PlayFacial(chara);
		}

		private void SetCharaNextPosition(AdvChara chara, Transform player)
		{
			if (IsMove)
			{
				if (MoveMode == MoveType.Self)
				{
					Vector3 a = chara.Transform.position;
					Vector3Extension.Add(ref a, ref Position, out chara.NextPosition);
				}
				else if (MoveMode == MoveType.ReletivePlayer)
				{
					CommandCharaPosition.SetCharaNextPositionReletiveToPlayer(player, chara, ref Position, IsLockY);
				}
				else if (MoveMode == MoveType.Radius)
				{
					chara.NextPosition = CommandCharaCircularPosition.CauclateCharaPosition(player, Angle, Radius);
				}
				else
				{
					chara.NextPosition = Position;
				}
			}
		}

		private void SetCharaPosition(AdvChara chara, Transform player, bool isFade)
		{
			if (IsMove)
			{
				if (isFade)
				{
					chara.Transform.position = chara.NextPosition;
				}
				else if (MoveMode == MoveType.Self)
				{
					chara.Transform.Translate(Position, Space.Self);
				}
				else if (MoveMode == MoveType.ReletivePlayer)
				{
					CommandCharaPosition.SetCharaPositionReletiveToPlayer(player, chara, ref Position, IsLockY);
				}
				else if (MoveMode == MoveType.Radius)
				{
					chara.Transform.position = CommandCharaCircularPosition.CauclateCharaPosition(player, Angle, Radius);
				}
				else
				{
					chara.Transform.position = Position;
				}
			}
		}

		private void SetCharaRotation(Transform chara, Transform player)
		{
			if (IsRotate)
			{
				SetCharaRotation(RotationMode, chara, player, ref Rotation);
			}
		}

		public static void SetCharaRotation(RotationType mode, Transform chara, Transform player, ref Vector3 rotation)
		{
			switch (mode)
			{
			case RotationType.Self:
				chara.Rotate(rotation, Space.Self);
				break;
			case RotationType.ReletivePlayer:
				CommandCharaRotation.SetCharaRotationReletiveToPlayer(player, chara, ref rotation);
				break;
			default:
				chara.localEulerAngles = rotation;
				break;
			}
		}

		private void PlayMotion(AdvChara chara)
		{
			if (IsMotion)
			{
				chara.HasInitialMotion = true;
				PlayAnimation(chara, Motion, IsPlayAnimationMotion);
			}
		}

		private void PlayFacial(AdvChara chara)
		{
			if (IsFacial)
			{
				chara.HasInitialFacial = true;
				PlayAnimation(chara, Facial, IsPlayAnimationFace);
			}
		}

		private void PlayAnimation(AdvChara chara, int animation, bool isPlay)
		{
			chara.Model.EnableAnimatorForFrame();
			chara.Model.PlayAnimation(animation, isFade: false, !isPlay);
			chara.Model.SkipAnimationOnNonForcus();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCharaTransform)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"キャラ総合:{Chara}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsMove));
			data.DataInt.Add(BoolToInt(IsRotate));
			data.DataInt.Add(BoolToInt(IsMotion));
			data.DataInt.Add(BoolToInt(IsFacial));
			data.DataInt.Add(BoolToInt(IsFade));
			SavePosition(data);
			SaveRotation(data);
			SaveMotion(data);
			SaveFacial(data);
		}

		private void SavePosition(SequenceData.Param data)
		{
			if (IsMove)
			{
				data.DataInt.Add((int)MoveMode);
				if (MoveMode == MoveType.Radius)
				{
					data.DataFloat.Add(Angle);
					data.DataFloat.Add(Radius);
					return;
				}
				data.DataFloat.Add(Position.x);
				data.DataFloat.Add(Position.y);
				data.DataFloat.Add(Position.z);
				data.DataInt.Add(BoolToInt(IsLockY));
			}
		}

		private void SaveRotation(SequenceData.Param data)
		{
			if (IsRotate)
			{
				data.DataInt.Add((int)RotationMode);
				data.DataFloat.Add(Rotation.x);
				data.DataFloat.Add(Rotation.y);
				data.DataFloat.Add(Rotation.z);
			}
		}

		private void SaveMotion(SequenceData.Param data)
		{
			if (IsMotion)
			{
				data.DataInt.Add(Motion);
				data.DataInt.Add(BoolToInt(IsPlayAnimationMotion));
			}
		}

		private void SaveFacial(SequenceData.Param data)
		{
			if (IsFacial)
			{
				data.DataInt.Add(Facial);
				data.DataInt.Add(BoolToInt(IsPlayAnimationFace));
			}
		}

		public void ApplyPositionRotation(AdvChara chara, Transform player)
		{
			SetCharaPosition(chara, player, isFade: false);
			SetCharaRotation(chara.Transform, player);
		}
	}
	public class CommandClearColour : ISequenceCommand
	{
		public Color ClearColour;

		public override Types Type => Types.CameraClearColour;

		public CommandClearColour()
		{
		}

		public CommandClearColour(Color col)
		{
			ClearColour = col;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ClearColour);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandClearColour)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"カメラのクリアカラー設定：{ClearColour}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(ClearColour.r);
			data.DataFloat.Add(ClearColour.g);
			data.DataFloat.Add(ClearColour.b);
		}
	}
	public class CommandCpuGpuLevel : ISequenceCommand
	{
		public int CpuLevel = 2;

		public int GpuLevel = 2;

		public override Types Type => Types.CpuGpuLevel;

		public CommandCpuGpuLevel()
		{
		}

		public CommandCpuGpuLevel(SequenceData.Param data, int version)
		{
			CpuLevel = data.DataInt[0];
			GpuLevel = data.DataInt[1];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			OVRManager.cpuLevel = CpuLevel;
			OVRManager.gpuLevel = GpuLevel;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandCpuGpuLevel)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"CpuGpuレベル変更（GOのみ）：Cpu = {CpuLevel}, Gpu = {GpuLevel}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(CpuLevel);
			data.DataInt.Add(GpuLevel);
		}
	}
	public class CommandEditorNote : ISequenceCommand
	{
		public string Text = "メモを記入してください";

		public override Types Type => Types.EditorNote;

		public CommandEditorNote()
		{
		}

		public CommandEditorNote(string text)
		{
			Text = text;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEditorNote)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			int num = Text.IndexOf('\n');
			string result = Text;
			if (num >= 0)
			{
				result = Text.Substring(0, num);
			}
			return result;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataString.Add(Text);
		}
	}
	public class CommandEmotion : ICharaCommand
	{
		public EmotionImage.Types Emotion = EmotionImage.Types.Attention;

		public Vector3 Offset = Vector3Extension.Zero;

		public override Types Type => Types.Emotion;

		public CommandEmotion()
		{
		}

		public CommandEmotion(GameDefine.CharaID chara, EmotionImage.Types emotion, Vector3 offset)
			: base(chara)
		{
			Emotion = emotion;
			Offset = offset;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.EmotionProcessor.Generate(Emotion, Chara, ref Offset);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEmotion)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"{Chara} から漫符 {Emotion} を出す (オフセット{Offset.ToString()})";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)Emotion);
			data.DataFloat.Add(Offset.x);
			data.DataFloat.Add(Offset.y);
			data.DataFloat.Add(Offset.z);
		}
	}
	public class CommandEnableTypingSound : BaseCommandEnable
	{
		public override Types Type => Types.EnableTypingSound;

		public CommandEnableTypingSound()
		{
		}

		public CommandEnableTypingSound(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.IsEmitSoundOnMessage = ToggleFlag;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnableTypingSound)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "メッセージタイプライター音の切り替え: " + GetFlagText();
		}

		protected override string GetFlagText()
		{
			if (!ToggleFlag)
			{
				return "鳴らさない";
			}
			return "鳴らす";
		}
	}
	public class CommandEndDemo : ISequenceCommand
	{
		public override Types Type => Types.EndDemo;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.EndDemo();
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEndDemo)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "デモ終了シーンへ移動 (ゲーム終了)";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandEndInGame : ISequenceCommand
	{
		public enum EndTypes
		{
			ToTitle = 0,
			NewGame = 1,
			NewGameSecond = 2,
			OnlyForDemo = 126,
			ToEndDemo = 127,
			InstantExit = 255
		}

		public EndTypes EndType;

		public int NextScenarioAfterContinue = 10000;

		public override Types Type => Types.EndInGame;

		public override bool PlayInHardSkip => true;

		public CommandEndInGame()
		{
		}

		public CommandEndInGame(SequenceData.Param data)
		{
			EndType = (EndTypes)data.GetInt(0);
			NextScenarioAfterContinue = data.GetInt(1);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.CompleteScenario();
			if (NextScenarioAfterContinue >= 0)
			{
				SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = NextScenarioAfterContinue;
				player.ResolveReservedAutoSave();
			}
			switch (EndType)
			{
			case EndTypes.ToTitle:
				player.QuitToTitle();
				break;
			case EndTypes.InstantExit:
				player.QuitApplication();
				break;
			case EndTypes.ToEndDemo:
				player.EndDemo();
				break;
			default:
				throw new CommandFailedException(this, EndType.ToString() + " is not implement!");
			case EndTypes.OnlyForDemo:
				break;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEndInGame)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			switch (EndType)
			{
			case EndTypes.ToTitle:
				text = "タイトルに戻る";
				break;
			case EndTypes.NewGame:
				text = "新規ゲームを自動開始";
				break;
			case EndTypes.NewGameSecond:
				text = "2週目ゲームを自動開始";
				break;
			case EndTypes.OnlyForDemo:
				text = "デモ終了シーン (デモバージョンの時だけ)";
				break;
			case EndTypes.ToEndDemo:
				text = "デモ終了シーン";
				break;
			case EndTypes.InstantExit:
				text = "アプリ強制終了";
				break;
			}
			if (NextScenarioAfterContinue >= 0)
			{
				text += $"(Continue時Sqid: {NextScenarioAfterContinue:00000})";
			}
			return "ゲームを終了 -> " + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)EndType);
			data.DataInt.Add(NextScenarioAfterContinue);
		}
	}
	public class CommandEnvironmentBlendShape : ISequenceCommand
	{
		public int Index;

		public float Weight = 100f;

		public override Types Type => Types.EnvrionmentBlendShape;

		public CommandEnvironmentBlendShape()
		{
		}

		public CommandEnvironmentBlendShape(int index, float weight)
		{
			Index = index;
			Weight = weight;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AdvBackground currentBackground = player.CurrentBackground;
			if (currentBackground == null)
			{
				SayOops("I cannot find AdvBackground.");
				return true;
			}
			currentBackground.SetBlendShape(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentBlendShape)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "背景ブレンド：Index = " + Index + ", Weight = " + Weight;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataFloat.Add(Weight);
		}
	}
	public class CommandEnvironmentPropsOff : CommandEnvironmentPropsOn
	{
		public override Types Type => Types.EnvironmentPropsOff;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsOff()
		{
			IsActive = false;
		}

		public CommandEnvironmentPropsOff(int index)
			: base(index, isActive: false)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return base.PlayCommand(player);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "背景Props非表示: ID = " + Index;
		}
	}
	public class CommandEnvironmentPropsOn : ISequenceCommand
	{
		public int Index;

		public bool IsActive;

		public override Types Type => Types.EnvironmentPropsOn;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsOn()
		{
		}

		public CommandEnvironmentPropsOn(int index, bool isActive)
		{
			Index = index;
			IsActive = isActive;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsOn)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "背景Props表示: ID = " + Index;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataInt.Add(BoolToInt(IsActive));
		}
	}
	public class CommandEnvironmentPropsPosition : ISequenceCommand
	{
		public int Index;

		public Vector3 Position = Vector3.zero;

		public override Types Type => Types.EnvironmentPropsPosition;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsPosition()
		{
		}

		public CommandEnvironmentPropsPosition(int index, Vector3 pos)
		{
			Index = index;
			Position = pos;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsPosition)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "背景Props移動: ID = " + Index + ", Pos = " + Position;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
		}
	}
	public class CommandEnvironmentPropsRotation : ISequenceCommand
	{
		public int Index;

		public Vector3 Rotation = Vector3.zero;

		public override Types Type => Types.EnvironmentPropsRotation;

		public override bool IsDeprecated => true;

		public CommandEnvironmentPropsRotation()
		{
		}

		public CommandEnvironmentPropsRotation(int index, Vector3 rotation)
		{
			Index = index;
			Rotation = rotation;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandEnvironmentPropsRotation)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "背景Props回転: ID = " + Index + ", 回転 = " + Rotation;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Index);
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandFadeIn : ISequenceCommand
	{
		public Color StartColour = ColorDefine.TransparentBlack;

		public Color EndColour = ColorDefine.Black;

		public float Duration = 0.6f;

		public bool IsDeactivateOnEnd;

		public override Types Type => Types.FadeIn;

		public CommandFadeIn()
		{
		}

		public CommandFadeIn(Color start, Color end, float duration, bool isDeactivateOnEnd)
		{
			StartColour = start;
			EndColour = end;
			Duration = duration;
			IsDeactivateOnEnd = isDeactivateOnEnd;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFadeIn)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			float duration = Duration;
			player.Fader.StartFade(StartColour, EndColour, duration, IsDeactivateOnEnd, player.ReleaseCommandWait);
			if (!player.HasPlayedFirstFade && duration <= 0f)
			{
				return true;
			}
			if (!player.HasPlayedFirstFade)
			{
				player.PrepareOnFirstFade();
			}
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceFadeHideTrackedHand(EndColour.a == 1f, duration);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceFadeHideTrackedHand(EndColour.a == 1f, duration);
			}
			return duration <= 0f;
		}

		public override string CreateDescriptionText()
		{
			if (StartColour.a <= 0f)
			{
				return $"フェードイン ({Duration:0.0} 秒)";
			}
			if (StartColour.a >= 1f)
			{
				return $"フェードアウト ({Duration:0.0} 秒)";
			}
			return $"フェード ({Duration:0.0} 秒)";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(StartColour.r);
			data.DataFloat.Add(StartColour.g);
			data.DataFloat.Add(StartColour.b);
			data.DataFloat.Add(StartColour.a);
			data.DataFloat.Add(EndColour.r);
			data.DataFloat.Add(EndColour.g);
			data.DataFloat.Add(EndColour.b);
			data.DataFloat.Add(EndColour.a);
			data.DataFloat.Add(Duration);
			data.DataInt.Add(BoolToInt(IsDeactivateOnEnd));
		}
	}
	public class CommandFadeWithoutText : ISequenceCommand
	{
		public Color StartColour = ColorDefine.TransparentBlack;

		public Color EndColour = ColorDefine.Black;

		public float Duration = 0.2f;

		public override Types Type => Types.FadeWithoutText;

		public CommandFadeWithoutText()
		{
		}

		public CommandFadeWithoutText(Color start, Color end, float duration)
		{
			StartColour = start;
			EndColour = end;
			Duration = duration;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFadeWithoutText)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MoverFader.Play(this);
			if (!player.HasPlayedFirstFade)
			{
				player.PrepareOnFirstFade();
				return false;
			}
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: true);
			}
			return Duration <= 0f;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.MoverFader.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(StartColour.r);
			data.DataFloat.Add(StartColour.g);
			data.DataFloat.Add(StartColour.b);
			data.DataFloat.Add(StartColour.a);
			data.DataFloat.Add(EndColour.r);
			data.DataFloat.Add(EndColour.g);
			data.DataFloat.Add(EndColour.b);
			data.DataFloat.Add(EndColour.a);
			data.DataFloat.Add(Duration);
		}

		public override string CreateDescriptionText()
		{
			return $"テキスト以外フェード開始";
		}
	}
	public class CommandFadeWithoutTextEnd : CommandFadeWithoutText
	{
		public override Types Type => Types.FadeWithoutTextEnd;

		public CommandFadeWithoutTextEnd()
		{
		}

		public CommandFadeWithoutTextEnd(Color start, Color end, float duration)
			: base(start, end, duration)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MoverFader.End(this);
			if (MainPosition.Avater.AvaterResources.HasTrackedHands)
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.ForceHideTrackedHand(fide: false);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.ForceHideTrackedHand(fide: false);
			}
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.MoverFader.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFadeWithoutTextEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"テキスト以外フェード終了";
		}
	}
	public class CommandFixWindow : ISequenceCommand
	{
		public bool FixVertical;

		public float TargetFixYaw;

		public float TargetFixPitch;

		public override Types Type => Types.FixWindowStart;

		public CommandFixWindow()
		{
		}

		public CommandFixWindow(SequenceData.Param data)
		{
			FixVertical = IntToBool(data.GetInt(0));
			TargetFixYaw = data.GetFloat(0);
			TargetFixPitch = data.GetFloat(1);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.WindowPositioner.IsFixedToFront = true;
			MainPosition.WindowPositioner.FrontFixYaw = TargetFixYaw;
			MainPosition.WindowPositioner.IsFixVertical = FixVertical;
			MainPosition.WindowPositioner.FrontFixPitch = TargetFixPitch;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFixWindow)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"<b>メッセージウィンドウ固定開始</b>: 角度[{TargetFixYaw:0.00}] 縦追従無効[{FixVertical}]";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(FixVertical));
			data.DataFloat.Add(TargetFixYaw);
			data.DataFloat.Add(TargetFixPitch);
		}
	}
	public class CommandFixWindowEnd : ISequenceCommand
	{
		public override Types Type => Types.FixWindowEnd;

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.WindowPositioner.IsFixedToFront = false;
			MainPosition.WindowPositioner.IsFixVertical = false;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFixWindowEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "メッセージウィンドウ固定終了";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandFlashbackChange : CommandFlashbackStart
	{
		public override Types Type => Types.FlashBackChange;

		public CommandFlashbackChange()
		{
		}

		public CommandFlashbackChange(int id)
			: base(id)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FlashbackProcessor.ChangeSprite(ID);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.FlashbackProcessor.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFlashbackChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "フラッシュバック変更: ID = " + ID;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandFlashbackEnd : ISequenceCommand
	{
		public override Types Type => Types.FlashBackEnd;

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FlashbackProcessor.Close();
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.FlashbackProcessor.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFlashbackEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "フラッシュバック終了";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandFlashbackStart : ISequenceCommand
	{
		public const int _DEFAULT_ID = 0;

		public int ID;

		public float EndDistance = 40f;

		public override Types Type => Types.FlashBackStart;

		public override PreloadTypes PreloadType => PreloadTypes.FlashBack;

		public override int PreloadIndex => ID;

		public CommandFlashbackStart()
		{
		}

		public CommandFlashbackStart(int id)
		{
			ID = id;
		}

		public CommandFlashbackStart(SequenceData.Param data)
		{
			ID = data.DataInt[0];
			if (data.DataFloat.Count > 0)
			{
				EndDistance = data.DataFloat[0];
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FlashbackProcessor.Play(player.MainPositionTransform, player.Fader, this);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.FlashbackProcessor.IsBusy)
			{
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandFlashbackStart)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "フラッシュバック開始：ID = " + ID + ", 距離： " + EndDistance;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataFloat.Add(EndDistance);
		}
	}
	public class CommandForcusUpOff : ISequenceCommand
	{
		public int WindowID;

		public ForcusUpWindow.FadeType FadeType = ForcusUpWindow.FadeType.Move;

		public bool IsSkip;

		public Ease MoveEaseType = Ease.InOutCubic;

		public override Types Type => Types.ForcusUpOff;

		public CommandForcusUpOff()
		{
		}

		public CommandForcusUpOff(int windowID, ForcusUpWindow.FadeType fadeType, bool isSkip, Ease moveEaseType)
		{
			WindowID = windowID;
			FadeType = fadeType;
			IsSkip = isSkip;
			MoveEaseType = moveEaseType;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FocusUpProcessor.CloseWindowByID(FadeType, WindowID, MoveEaseType, IsSkip);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandForcusUpOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"フォーカスアップ消去: ウィンドウID:{WindowID}, 演出{FadeType}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(WindowID);
			data.DataInt.Add((int)FadeType);
			data.DataInt.Add(BoolToInt(IsSkip));
			data.DataInt.Add((int)MoveEaseType);
		}
	}
	public class CommandForcusUpWindow : ICharaCommand
	{
		public int ID;

		public int WindowID;

		public ForcusUpWindowController.SourceType Source = ForcusUpWindowController.SourceType.Chara;

		public ForcusUpWindow.FadeType FadeType = ForcusUpWindow.FadeType.Move;

		public float Distance = 5f;

		public Vector3 Offset = Vector3Extension.Zero;

		public Vector3 Scale = Vector3.one;

		public Vector3 TargetPoint = Vector3Extension.Zero;

		public Ease MoveEaseType = Ease.OutCubic;

		public int PropsID;

		public override Types Type => Types.ForcusUp;

		public override PreloadTypes PreloadType => PreloadTypes.FocusUp;

		public override int PreloadIndex => ID;

		public CommandForcusUpWindow()
		{
		}

		public CommandForcusUpWindow(int id, int windowID, ForcusUpWindowController.SourceType source, ForcusUpWindow.FadeType fade, GameDefine.CharaID chara, float distance, Vector3 offset, Vector3 scale, Vector3 targetPos, Ease moveEaseType, int propsID = -1)
		{
			ID = id;
			WindowID = windowID;
			FadeType = fade;
			Chara = chara;
			Source = source;
			Distance = distance;
			Offset = offset;
			MoveEaseType = moveEaseType;
			Scale = scale;
			TargetPoint = targetPos;
			PropsID = propsID;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.FocusUpProcessor.OpenWindow(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandForcusUpWindow)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"フォーカスアップ表示: ウィンドウID:{WindowID}, 画像ID:{ID}, 演出{FadeType}, キャラ{Chara}, オフセット{Offset}, スケール{Scale}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataInt.Add(WindowID);
			data.DataInt.Add((int)FadeType);
			data.DataInt.Add((int)Chara);
			data.DataInt.Add((int)MoveEaseType);
			data.DataInt.Add((int)Source);
			data.DataInt.Add(PropsID);
			data.DataFloat.Add(Distance);
			data.DataFloat.Add(Offset.x);
			data.DataFloat.Add(Offset.y);
			data.DataFloat.Add(Offset.z);
			data.DataFloat.Add(Scale.x);
			data.DataFloat.Add(Scale.y);
			data.DataFloat.Add(Scale.z);
			data.DataFloat.Add(TargetPoint.x);
			data.DataFloat.Add(TargetPoint.y);
			data.DataFloat.Add(TargetPoint.z);
		}
	}
	public class CommandLogicElse : BaseLogicCommand
	{
		public override Types Type => Types.LogicElse;

		public CommandLogicElse()
		{
		}

		public CommandLogicElse(SequenceData.Param data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			base.IsLogicTrue = !player.RemoveLastLogicStack();
			if (!player.IsLastLogicTrue())
			{
				base.IsLogicTrue = false;
			}
			player.AddLogicStack(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandLogicElse)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "} ELSE {";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandLogicEndIf : BaseLogicCommand
	{
		public override Types Type => Types.LogicEndIf;

		public CommandLogicEndIf()
		{
		}

		public CommandLogicEndIf(SequenceData.Param data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.RemoveLastLogicStack();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandLogicEndIf)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "} ENDIF";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandLogicIfFlag : BaseLogicCommand
	{
		public CommandParameters.Conditions ConditionType;

		public int FlagIndex;

		public bool FlagEquals;

		public override Types Type => Types.LogicIfFlag;

		public CommandLogicIfFlag()
		{
			ConditionType = CommandParameters.Conditions.Switch;
			FlagEquals = true;
		}

		public CommandLogicIfFlag(SequenceData.Param data)
		{
			ConditionType = (CommandParameters.Conditions)data.DataInt[0];
			FlagIndex = data.DataInt[1];
			FlagEquals = data.DataInt[2] != 0;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsLastLogicTrue())
			{
				switch (ConditionType)
				{
				case CommandParameters.Conditions.Enum:
					SayOops("Enum は未実装");
					break;
				case CommandParameters.Conditions.False:
					base.IsLogicTrue = !FlagEquals;
					break;
				case CommandParameters.Conditions.True:
					base.IsLogicTrue = FlagEquals;
					break;
				case CommandParameters.Conditions.Switch:
					base.IsLogicTrue = SingletonMonoBehaviour<GameData>.Instance.SystemData.GetFlag(FlagIndex) == FlagEquals;
					break;
				case CommandParameters.Conditions.Readed:
					if (FlagIndex < 0)
					{
						base.IsLogicTrue = SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(player.LoadedScenarioID) == FlagEquals;
					}
					else
					{
						base.IsLogicTrue = SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(FlagIndex) == FlagEquals;
					}
					break;
				case CommandParameters.Conditions.LastSelection:
					base.IsLogicTrue = SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex == FlagIndex;
					break;
				}
			}
			else
			{
				base.IsLogicTrue = false;
			}
			player.AddLogicStack(this);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandLogicIfFlag)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"条件: {GetConditionTargetString()} == {FlagEquals} {{";
		}

		private string GetConditionTargetString()
		{
			switch (ConditionType)
			{
			case CommandParameters.Conditions.Enum:
				return "ENUM は未実装";
			case CommandParameters.Conditions.False:
				return "FALSE";
			case CommandParameters.Conditions.True:
				return "TRUE";
			case CommandParameters.Conditions.Switch:
				return $"スイッチID[{(GameFlags)FlagIndex}]";
			case CommandParameters.Conditions.Readed:
				if (FlagIndex < 0)
				{
					return string.Format("シナリオID[{0}]既読済み", "この演出番号");
				}
				return $"シナリオID[{FlagIndex:D5}]既読済み";
			case CommandParameters.Conditions.LastSelection:
				return $"最後の選択肢で {FlagIndex} を選択";
			default:
				return "UNKNOWN";
			}
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)ConditionType);
			data.DataInt.Add(FlagIndex);
			data.DataInt.Add(FlagEquals ? 1 : 0);
		}
	}
	public class CommandMemoryAmbient : CommandBgmSimple
	{
		public override Types Type => Types.MemoryAmbient;

		public CommandMemoryAmbient()
		{
		}

		public CommandMemoryAmbient(int id, float volume, float fadeDuration)
			: base(id, volume, fadeDuration)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!player.CurrentBackground.HasAudioSource)
			{
				return true;
			}
			SoundManager.Bgm.PlaySimple(player.CurrentBackground.Audio, base.ID, Volume, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryAmbient)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"回想環境音再生：ID {base.ID}, 音量 {Volume}, フェード時間 {FadeDuration}";
		}
	}
	public class CommandMemoryAmbientOff : CommandBgmSimpleOff
	{
		public override Types Type => Types.MemoryAmbientOff;

		public CommandMemoryAmbientOff()
		{
		}

		public CommandMemoryAmbientOff(SequenceData.Param data, int version)
			: base(data.DataFloat[0])
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!player.CurrentBackground.HasAudioSource)
			{
				return true;
			}
			SoundManager.Bgm.StopSimpleBgm(player.CurrentBackground.Audio, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryAmbientOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"回想環境音停止：フェード時間 : {FadeDuration}";
		}
	}
	public class CommandMemoryAmbientVolume : CommandBgmSimpleVolume
	{
		public override Types Type => Types.MemoryAmbientVolume;

		public CommandMemoryAmbientVolume()
		{
		}

		public CommandMemoryAmbientVolume(SequenceData.Param data, int version)
			: base(data.DataFloat[0], data.DataFloat[1])
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (!player.CurrentBackground.HasAudioSource)
			{
				return true;
			}
			SoundManager.Bgm.SetSimpleVolume(player.CurrentBackground.Audio, Volume, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryAmbientVolume)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"回想環境音 音量変更 : 音量 {Volume}, フェード時間 {FadeDuration}";
		}
	}
	public class CommandMemoryCharaOff : CommandMemoryCharaOn
	{
		public override Types Type => Types.MemoryCharaOff;

		public CommandMemoryCharaOff()
		{
		}

		public CommandMemoryCharaOff(SequenceData.Param data, int version, bool isFade)
			: base(data, version, isFade)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SetCharaInListActive(player, isActive: false);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryCharaOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string arg = ((FadeDuration <= 0f) ? "(瞬間)" : $"(フェード {FadeDuration:0.0} 秒)");
			return $"回想キャラ退場 {arg}";
		}
	}
	public class CommandMemoryCharaOn : CommandCharaOn
	{
		private bool m_isActivate;

		public override Types Type => Types.MemoryCharaOn;

		public override PreloadTypes PreloadType => PreloadTypes.MemoryChara;

		public override int PreloadIndex => (int)CharaList[0];

		public CommandMemoryCharaOn()
		{
		}

		public CommandMemoryCharaOn(SequenceData.Param data, int version, bool isFade)
			: base(data, version, isFade)
		{
		}

		protected override void SetCharaInListActive(TimelinePlayer player, bool isActive)
		{
			m_isActivate = isActive;
			int count = CharaList.Count;
			for (int i = 0; i < count; i++)
			{
				SetCharaActive(player, CharaList[i], isActive);
			}
		}

		private void SetCharaActive(TimelinePlayer player, GameDefine.CharaID charaID, bool isActive)
		{
			AdvMemoryChara advMemoryChara = player.MemoryModeProcessor.FindChara(charaID);
			float targetAlpha = 0f;
			if (isActive)
			{
				targetAlpha = 1f;
				advMemoryChara.SetEnable(isActive);
				advMemoryChara.SetAlpha(0f);
			}
			advMemoryChara.StartFadeWithChangeActive(targetAlpha, isActive, FadeDuration);
		}

		private void OnFadeEnd(AdvMemoryChara chara)
		{
			chara.SetEnable(m_isActivate);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryCharaOn)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string arg = ((FadeDuration <= 0f) ? "(瞬間)" : $"(フェード {FadeDuration:0.0} 秒)");
			return $"回想キャラ登場 {arg}";
		}
	}
	public class CommandMemoryCharaTransform : ICharaCommand
	{
		public CommandCharaTransform.RotationType RotationMode;

		public bool IsMove;

		public bool IsRotate;

		public bool IsFade = true;

		public float Radius = 7f;

		public float Angle;

		public Vector3 Offset = Vector3Extension.Zero;

		public Vector3 Rotation = Vector3Extension.Zero;

		private AdvMemoryChara m_chara;

		private Action m_onFadeEndAction;

		public override Types Type => Types.MemoryCharaTransform;

		public CommandMemoryCharaTransform()
		{
			Chara = GameDefine.CharaID.TOUGOKU_C;
		}

		public CommandMemoryCharaTransform(SequenceData.Param data, int version, bool hasPassedFirstFade)
		{
			int intIndex = 0;
			int index = 0;
			Chara = (GameDefine.CharaID)data.DataInt[intIndex++];
			IsFade = IntToBool(data.DataInt[intIndex++]);
			IsMove = IntToBool(data.DataInt[intIndex++]);
			IsRotate = IntToBool(data.DataInt[intIndex++]);
			LoadPosition(data, ref index);
			LoadRotation(data, ref intIndex, ref index);
			if (!hasPassedFirstFade)
			{
				IsFade = false;
			}
			m_onFadeEndAction = delegate
			{
				_ApplyTransform();
			};
		}

		private void LoadPosition(SequenceData.Param data, ref int index)
		{
			if (IsMove)
			{
				Angle = data.DataFloat[index++];
				Radius = data.DataFloat[index++];
				Offset = new Vector3(data.DataFloat[index++], data.DataFloat[index++], data.DataFloat[index++]);
			}
		}

		private void LoadRotation(SequenceData.Param data, ref int intIndex, ref int floatIndex)
		{
			if (IsRotate)
			{
				RotationMode = (CommandCharaTransform.RotationType)data.DataInt[intIndex++];
				Rotation = new Vector3(data.DataFloat[floatIndex++], data.DataFloat[floatIndex++], data.DataFloat[floatIndex++]);
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			m_chara = player.MemoryModeProcessor.FindChara(Chara);
			if (m_chara == null)
			{
				SayOops("I couldn't find Character: " + Chara);
				return true;
			}
			if (!IsFade || !m_chara.IsActive)
			{
				ApplyTransform(m_chara, m_chara.Transform, MainPosition.MainTransform);
				return true;
			}
			m_chara.PlayPingPongFade(0.3f, m_onFadeEndAction);
			return true;
		}

		private void _ApplyTransform()
		{
			ApplyTransform(m_chara, m_chara.Transform, MainPosition.MainTransform);
		}

		public void ApplyTransform(AdvMemoryChara chara, Transform charaTransform, Transform player)
		{
			if (IsMove)
			{
				SetCharaPosition(chara, charaTransform, player);
			}
			if (IsRotate)
			{
				CommandCharaTransform.SetCharaRotation(RotationMode, charaTransform, player, ref Rotation);
			}
		}

		public void SetCharaPosition(AdvMemoryChara chara, Transform charaTransform, Transform player)
		{
			if (chara != null)
			{
				chara.SetMoveFlag();
			}
			charaTransform.localPosition = CommandCharaCircularPosition.CauclateCharaPosition(player, Angle, Radius);
			charaTransform.Translate(Offset, Space.Self);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryCharaTransform)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("回想キャラ{0}の変形：{1}", Chara.ToString(), IsFade ? "" : " (フェードなし)");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataInt.Add(BoolToInt(IsMove));
			data.DataInt.Add(BoolToInt(IsRotate));
			SavePosition(data);
			SaveRotation(data);
		}

		private void SavePosition(SequenceData.Param data)
		{
			if (IsMove)
			{
				data.DataFloat.Add(Angle);
				data.DataFloat.Add(Radius);
				data.DataFloat.Add(Offset.x);
				data.DataFloat.Add(Offset.y);
				data.DataFloat.Add(Offset.z);
			}
		}

		private void SaveRotation(SequenceData.Param data)
		{
			if (IsRotate)
			{
				data.DataInt.Add((int)RotationMode);
				data.DataFloat.Add(Rotation.x);
				data.DataFloat.Add(Rotation.y);
				data.DataFloat.Add(Rotation.z);
			}
		}
	}
	public class CommandMemoryEmotion : CommandEmotion
	{
		public override Types Type => Types.MemoryEmotion;

		public CommandMemoryEmotion()
		{
		}

		public CommandMemoryEmotion(GameDefine.CharaID chara, EmotionImage.Types emotion, Vector3 offset)
			: base(chara, emotion, offset)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.EmotionProcessor.GenerateMono(player.MemoryModeProcessor, Emotion, Chara, ref Offset);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryEmotion)MemberwiseClone();
		}
	}
	public class CommandMemoryModeEnd : ISequenceCommand
	{
		public override Types Type => Types.MemoryEnd;

		public override bool PlayInHardSkip => true;

		public CommandMemoryModeEnd()
		{
		}

		public CommandMemoryModeEnd(SequenceData.Param data, int version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MemoryModeProcessor.End();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryModeEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "回想モード終了";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandMemoryModeStart : ISequenceCommand
	{
		public AdvBackgroundMemory.SpotlightTypes SpotlightType;

		public override Types Type => Types.MemoryStart;

		public override bool PlayInHardSkip => true;

		public override PreloadTypes PreloadType => PreloadTypes.MemoryModeStart;

		public override int PreloadIndex => 0;

		public CommandMemoryModeStart()
		{
		}

		public CommandMemoryModeStart(SequenceData.Param data, int version)
		{
			if (data.DataInt.Count > 0)
			{
				SpotlightType = (AdvBackgroundMemory.SpotlightTypes)data.DataInt[0];
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MemoryModeProcessor.Play(SpotlightType);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMemoryModeStart)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "回想モード開始";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)SpotlightType);
		}
	}
	public class CommandMenuFixMode : ISequenceCommand
	{
		public MainMenuManager.MenuMode TargetMenuMode = MainMenuManager.MenuMode.SkipMode;

		public override Types Type => Types.MenuFixMode;

		public CommandMenuFixMode()
		{
		}

		public CommandMenuFixMode(SequenceData.Param data, int version)
			: base(data, version)
		{
			TargetMenuMode = (MainMenuManager.MenuMode)data.DataInt[0];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.FixedMode = TargetMenuMode;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMenuFixMode)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "<b>メニュー項目を固定</b>: " + TargetMenuMode;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetMenuMode);
		}
	}
	public class CommandMessageForceMode : ISequenceCommand
	{
		public MessagePlayer.ForceModes TargetMode;

		public override Types Type => Types.MessageForceMode;

		public CommandMessageForceMode()
		{
		}

		public CommandMessageForceMode(SequenceData.Param data)
		{
			TargetMode = (MessagePlayer.ForceModes)data.GetInt(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.ForceMode = TargetMode;
			if (TargetMode == MessagePlayer.ForceModes.ForceAuto && SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandMessageForceMode)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			switch (TargetMode)
			{
			case MessagePlayer.ForceModes.Freedom:
				text = "強制を解除";
				break;
			case MessagePlayer.ForceModes.NoAuto:
				text = "オート機能を禁止";
				break;
			case MessagePlayer.ForceModes.NoSkip:
				text = "スキップ機能を禁止";
				break;
			case MessagePlayer.ForceModes.NoAutoSkip:
				text = "オート機能とスキップ機能を禁止";
				break;
			case MessagePlayer.ForceModes.ForceAuto:
				text = "強制オートモード";
				break;
			}
			return "メッセージ強制モード -> " + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetMode);
		}
	}
	public class CommandNoAnimationLimit : ISequenceCommand
	{
		public override Types Type => Types.NoAnimationLimit;

		public CommandNoAnimationLimit()
		{
		}

		public CommandNoAnimationLimit(SequenceData.Param data, int version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<CharactersManager>.Instance.IsIgnoreAnimationLimit = true;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandNoAnimationLimit)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "アニメーション制限解除";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public static class CommandParameters
	{
		public enum Fade
		{
			START_R,
			START_G,
			START_B,
			START_A,
			END_R,
			END_G,
			END_B,
			END_A,
			DURATION
		}

		public enum CharaPosition
		{
			X,
			Y,
			Z
		}

		public enum ForcusOff
		{
			Window,
			Fade
		}

		public enum Transform
		{
			PositionX,
			PositionY,
			PositionZ,
			RotationX,
			RotationY,
			RotationZ
		}

		public enum Bgm
		{
			Volume,
			Fade
		}

		public enum Conditions
		{
			Enum = -1,
			False,
			True,
			Switch,
			Readed,
			LastSelection
		}

		public const int TEXT_CHARA = 0;

		public const int TEXT_TEXT_INDEX = 1;

		public const int TEXT_VOICE_INDEX = 2;

		public const int CHARA_CHARA = 0;

		public const int CHARA_EMOTION = 1;

		public const int SCENE_NEXT_SCENE = 0;

		public const int SEQUENCE_NEXT_ID = 0;

		public const int CHARA_POSITION_IS_RELETIVE = 1;

		public const int CHARA_POSITION_IS_SKIP_FADE = 2;

		public const int WAIT_TIME = 0;

		public const int FORCUS_UP_ID = 0;

		public const int FORCUS_UP_WINDOW = 1;

		public const int FORCUS_UP_FADE = 2;

		public const int FORCUS_UP_CHARA = 3;

		public const int PROPS_TYPE = 0;

		public const int PROPS_ID = 1;

		public const int PROPS_CHARA = 2;

		public const int PROPS_NODE = 3;

		public const int ID = 0;

		public const int LOOP = 1;

		public const int BGM_FADE_DURATION = 0;

		public const int SE_SOURCE = 2;

		public const int SE_PARAM_ONE = 3;

		public const int SE_PARAM_TWO = 4;

		public const int SE_PARAM_THREE = 5;

		public const int LOOKAT_SKIP_ANIM = 2;

		public const int LOOKAT_SOURCE = 3;

		public const int LOOKAT_PROPTYPE = 4;

		public const int LOOKAT_PROPID = 5;

		public const int LOOKAT_PROPNODEID = 6;
	}
	public class CommandPlayAreaBoundary : ISequenceCommand
	{
		public bool IsOverride = true;

		public float OverrideRange = 2f;

		public override Types Type => Types.PlayAreaBoundary;

		public CommandPlayAreaBoundary()
		{
		}

		public CommandPlayAreaBoundary(SequenceData.Param data, int version)
			: base(data, version)
		{
			IsOverride = IntToBool(data.GetInt(0));
			OverrideRange = data.GetFloat(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (IsOverride)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.BoundaryRange = OverrideRange;
			}
			else
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.ResetBoundaryRange();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayAreaBoundary)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (IsOverride)
			{
				return "プレイエリア半径: 半径 " + OverrideRange.ToString("F2") + " m";
			}
			return "プレイエリア半径: 元に戻す";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsOverride));
			data.DataFloat.Add(OverrideRange);
		}
	}
	public class CommandPlayerArmMotion : ISequenceCommand
	{
		public int Motion;

		public bool IsFade = true;

		public bool IsPlayAnimation = true;

		public override Types Type => Types.PlayerArmMotion;

		public CommandPlayerArmMotion()
		{
		}

		public CommandPlayerArmMotion(int motion, bool isFade, bool PlayAnimation)
		{
			Motion = motion;
			IsFade = isFade;
			IsPlayAnimation = PlayAnimation;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.AvaterResources.HandObject.PlayAnimation(Motion, IsFade, IsPlayAnimation);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerArmMotion)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"プレイヤーの腕モーション {Motion} を再生";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(Motion);
			data.DataInt.Add(BoolToInt(IsFade));
			data.DataInt.Add(BoolToInt(IsPlayAnimation));
		}
	}
	public class CommandPlayerAvaterTrack : ISequenceCommand
	{
		public PlayerAvater.AvaterParts TargetPart;

		public PlayerAvater.AvaterTrackTypes TrackType;

		public float FadeDuration = 0.3f;

		public override Types Type => Types.PlayerAvaterTrack;

		public CommandPlayerAvaterTrack()
		{
		}

		public CommandPlayerAvaterTrack(SequenceData.Param data, int saveVersion)
		{
			TargetPart = (PlayerAvater.AvaterParts)data.GetInt(0);
			TrackType = (PlayerAvater.AvaterTrackTypes)data.GetInt(1);
			FadeDuration = data.GetFloat(0);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.SetRotationEnableWithFade(TargetPart, TrackType, FadeDuration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerAvaterTrack)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"アバター{TargetPart}の回転トラッキング = {TrackType}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetPart);
			data.DataInt.Add((int)TrackType);
			data.DataFloat.Add(FadeDuration);
		}
	}
	public class CommandPlayerAvaterVisible : ISequenceCommand
	{
		public bool IsVisible;

		public override Types Type => Types.AvaterVisible;

		public CommandPlayerAvaterVisible()
		{
		}

		public CommandPlayerAvaterVisible(SequenceData.Param data, int version)
		{
			IsVisible = IntToBool(data.DataInt[0]);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.Avater.Object.SetActive(IsVisible);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerAvaterVisible)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			if (!IsVisible)
			{
				return "<b>アバターオブジェクト無効化</b>";
			}
			return "<b>アバターオブジェクト有効化</b>";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(BoolToInt(IsVisible));
		}
	}
	public class CommandPlayerPosition : ISequenceCommand
	{
		public Vector3 Position = Vector3.zero;

		public override Types Type => Types.PlayerPosition;

		public CommandPlayerPosition()
		{
		}

		public CommandPlayerPosition(Vector3 pos)
		{
			Position = pos;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			Vector3 position = Position;
			position.y += 5.17f;
			MainPosition.MainTransform.localPosition = position;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerPosition)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"プレイヤー位置を変更: {Position}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
		}
	}
	public class CommandPlayerRotation : ISequenceCommand
	{
		public Vector3 Rotation;

		public override Types Type => Types.PlayerRotation;

		public CommandPlayerRotation()
		{
		}

		public CommandPlayerRotation(Vector3 rot)
		{
			Rotation = rot;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			MainPosition.MainTransform.eulerAngles = Rotation;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerRotation)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"プレイヤーを回転: {Rotation}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
		}
	}
	public class CommandPlayerSetChara : ICharaCommand
	{
		public bool ShowHands;

		public int HandModelIndex;

		public bool ShowTrackingHands;

		public override Types Type => Types.SetPlayerChara;

		public override PreloadTypes PreloadType => PreloadTypes.Avater;

		public override int PreloadIndex => (int)Chara;

		public CommandPlayerSetChara()
			: base(GameDefine.CharaID.SAKURAI)
		{
			ShowHands = false;
		}

		public CommandPlayerSetChara(GameDefine.CharaID chara, bool showHands = false, int HandModelIndex = 0, bool showTrackingHands = true)
			: base(chara)
		{
			ShowHands = showHands;
			this.HandModelIndex = HandModelIndex;
			if (ShowHands)
			{
				ShowTrackingHands = false;
			}
			else
			{
				ShowTrackingHands = showTrackingHands;
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID == Chara)
			{
				if (MainPosition.Avater.AvaterResources.HasTrackedHands)
				{
					if (ShowTrackingHands)
					{
						MainPosition.Avater.AvaterResources.TrackedHandLeftObject.StartFadeIn();
						MainPosition.Avater.AvaterResources.TrackedHandRightObject.StartFadeIn();
					}
					else
					{
						MainPosition.Avater.AvaterResources.TrackedHandLeftObject.StartFadeOut();
						MainPosition.Avater.AvaterResources.TrackedHandRightObject.StartFadeOut();
					}
					MainPosition.Avater.AvaterResources.TrackedHandLeftObject.IsTrackedHandShowing = ShowTrackingHands;
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.IsTrackedHandShowing = ShowTrackingHands;
				}
				if (MainPosition.Avater.AvaterResources.HasHand)
				{
					if (ShowHands)
					{
						MainPosition.Avater.AvaterResources.HandLoader.ChangeCurrentAvaterType(HandModelIndex);
					}
					else
					{
						MainPosition.Avater.AvaterResources.HandObject.StartFadeOut();
					}
				}
				return true;
			}
			MainPosition.Avater.AvaterResources.OnAfterAvaterLoaded.First().Subscribe(delegate
			{
				OnEndAvaterLoad(player);
			});
			MainPosition.Avater.AvaterResources.HandLoader.IsFadeInOnNew = ShowHands;
			MainPosition.Avater.AvaterResources.HandLoader.InitialFadeInIndex = HandModelIndex;
			MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsFadeInOnNew = ShowTrackingHands;
			MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsFadeInOnNew = ShowTrackingHands;
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(Chara);
			return false;
		}

		public void OnEndAvaterLoad(TimelinePlayer player)
		{
			player.ReleaseCommandWait();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPlayerSetChara)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"プレイヤーキャラクターを {Chara} に設定";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(BoolToInt(ShowHands));
			data.DataInt.Add(HandModelIndex);
			data.DataInt.Add(BoolToInt(ShowTrackingHands));
		}
	}
	public class CommandProhibitHeightChange : BaseCommandProhibit
	{
		public override Types Type => Types.ProhibitHeightChange;

		public CommandProhibitHeightChange()
		{
		}

		public CommandProhibitHeightChange(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.ProhibitHeightChange = ToggleFlag;
			SingletonMonoBehaviour<MainPosition>.Instance.ProhibitHeightChange = ToggleFlag;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitHeightChange)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "ユーザー高さ変更禁止の切り替え: " + GetFlagText();
		}
	}
	public class CommandProhibitMenuSelection : BaseCommandProhibit
	{
		public MainMenuManager.MenuMode TargetMenuMode = MainMenuManager.MenuMode.SkipMode;

		public override Types Type => Types.ProhibitMenuSelection;

		public CommandProhibitMenuSelection()
		{
		}

		public CommandProhibitMenuSelection(SequenceData.Param data)
			: base(data)
		{
			TargetMenuMode = (MainMenuManager.MenuMode)data.DataInt[1];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(TargetMenuMode, ToggleFlag);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitMenuSelection)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"メニュー項目 {TargetMenuMode} の許可の切り替え: " + GetFlagText();
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add((int)TargetMenuMode);
		}
	}
	public class CommandProhibitMessageSound : BaseCommandProhibit
	{
		public override Types Type => Types.ProhibitMessageSound;

		public CommandProhibitMessageSound()
		{
		}

		public CommandProhibitMessageSound(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.IsPlayPageSound = !ToggleFlag;
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitMessageSound)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "メッセージ送りサウンド許可の切り替え: " + GetFlagText();
		}
	}
	public class CommandProhibitOpenMenu : BaseCommandProhibit
	{
		public override Types Type => Types.ProhibitOpenMenu;

		public CommandProhibitOpenMenu()
		{
		}

		public CommandProhibitOpenMenu(SequenceData.Param data)
			: base(data)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = ToggleFlag;
			if (SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProhibitOpenMenu)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "メニュー切り替え許可の切り替え: " + GetFlagText();
		}
	}
	public class CommandProps : ISequenceCommand
	{
		public override Types Type => Types.Props;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandProps)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Deprecated";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandPropsChara : ICharaCommand
	{
		public override Types Type => Types.PropsChara;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPropsChara)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Deprecated";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandPropsCharaOff : CommandPropsOff
	{
		public override Types Type => Types.PropsCharaOff;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandPropsOff : ISequenceCommand
	{
		public override Types Type => Types.PropsOff;

		public override bool IsDeprecated => true;

		public override bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandPropsOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Deprecated";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandSceneProp : BaseCommandSceneProp
	{
		public bool Visible = true;

		public bool IsOverrideTransform;

		public bool IsAttachTo;

		public PropDefines.RelativeModes RelativeMode;

		public PropDefines.FadeModes FadeMode;

		public int OptionIntOne;

		public int OptionIntTwo;

		public int OptionIntThree;

		public float FadeDuration = 0.3f;

		public float Delay;

		public Vector3 Position = Vector3.zero;

		public Vector3 Rotation = Vector3.zero;

		public Vector3 Scale = Vector3.one;

		private BaseProp m_prop;

		private TimelinePlayer m_player;

		private AdvChara m_chara;

		private Action m_onBetweenDitherAction;

		private TimeSpan m_delaySpan;

		public override Types Type => Types.SceneProp;

		public override PreloadTypes PreloadType
		{
			get
			{
				if (PropType != 0)
				{
					return PreloadTypes.PropDynamic;
				}
				return PreloadTypes.PropStatic;
			}
		}

		public override int PreloadIndex => PropIndex;

		private bool IsWillAttach
		{
			get
			{
				if (base.IsDynamicProp && IsAttachTo)
				{
					return IsOverrideTransform;
				}
				return false;
			}
		}

		public GameDefine.CharaID RelationCharaID
		{
			get
			{
				return (GameDefine.CharaID)OptionIntOne;
			}
			set
			{
				OptionIntOne = (int)value;
			}
		}

		public AdvCharaModel.Node RelationCharaNode
		{
			get
			{
				return (AdvCharaModel.Node)OptionIntTwo;
			}
			set
			{
				OptionIntTwo = (int)value;
			}
		}

		public AvaterHandObject.Node RelationAvaterHandNode
		{
			get
			{
				return (AvaterHandObject.Node)OptionIntTwo;
			}
			set
			{
				OptionIntTwo = (int)value;
			}
		}

		public PropDefines.PropType RelationPropType
		{
			get
			{
				return (PropDefines.PropType)OptionIntOne;
			}
			set
			{
				OptionIntOne = (int)value;
			}
		}

		public int RelationPropIndex
		{
			get
			{
				return OptionIntTwo;
			}
			set
			{
				OptionIntTwo = value;
			}
		}

		public int RelationPropAnchorIndex
		{
			get
			{
				return OptionIntThree;
			}
			set
			{
				OptionIntThree = value;
			}
		}

		public VRDeviceDefine.HandType RelationRealHand
		{
			get
			{
				return (VRDeviceDefine.HandType)OptionIntOne;
			}
			set
			{
				OptionIntOne = (int)value;
			}
		}

		public CommandSceneProp()
		{
			PropType = PropDefines.PropType.Static;
		}

		public CommandSceneProp(SequenceData.Param data)
		{
			LoadFromData(data);
			int flagsFromInt = data.DataInt[2];
			SetFlagsFromInt(flagsFromInt);
			RelativeMode = (PropDefines.RelativeModes)data.DataInt[3];
			FadeMode = (PropDefines.FadeModes)data.DataInt[4];
			OptionIntOne = data.DataInt[5];
			OptionIntTwo = data.DataInt[6];
			OptionIntThree = data.DataInt[7];
			FadeDuration = data.DataFloat[0];
			Position = new Vector3(data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]);
			Rotation = new Vector3(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6]);
			Scale = new Vector3(data.DataFloat[7], data.DataFloat[8], data.DataFloat[9]);
			if (data.DataFloat.Count >= 11)
			{
				Delay = data.DataFloat[10];
				if (Delay > 0f)
				{
					m_delaySpan = TimeSpan.FromSeconds(Delay);
				}
			}
			if (SingletonMonoBehaviour<CharactersManager>.HasInstance)
			{
				m_chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(RelationCharaID);
			}
			m_onBetweenDitherAction = delegate
			{
				OnBetweenDither();
			};
		}

		private void OnBetweenDither()
		{
			if (!(m_prop == null))
			{
				m_prop.SetVisible(Visible);
				MoveProp(m_player, m_prop);
				m_prop = null;
				m_player = null;
			}
		}

		protected override bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			m_player = player;
			m_prop = prop;
			if (Delay > 0f)
			{
				OnDelay(prop);
				Observable.Timer(m_delaySpan).Subscribe(delegate
				{
					RunCommand();
				}).AddTo(player.gameObject);
				return true;
			}
			RunCommand();
			return true;
		}

		private void OnDelay(BaseProp prop)
		{
			if (FadeMode == PropDefines.FadeModes.Dither && (RelativeMode == PropDefines.RelativeModes.Chara || RelativeMode == PropDefines.RelativeModes.CharaNode))
			{
				prop.SetAlpha(0f);
			}
		}

		private void RunCommand()
		{
			if (PropType == PropDefines.PropType.Dynamic)
			{
				if (FadeMode == PropDefines.FadeModes.Dither)
				{
					m_prop.ActionBetweenDither(FadeDuration, m_onBetweenDitherAction, null);
				}
				else if (FadeMode == PropDefines.FadeModes.Smooth)
				{
					m_prop.SetVisible(Visible);
					m_prop.ReadyToSmooth(FadeDuration);
					MoveProp(m_player, m_prop);
				}
				else
				{
					m_prop.SetVisible(Visible);
					MoveProp(m_player, m_prop);
				}
			}
			else
			{
				m_prop.SetVisible(Visible);
			}
		}

		private void MoveProp(TimelinePlayer player, BaseProp prop)
		{
			if (!IsOverrideTransform)
			{
				prop.ResetPropTransform();
				return;
			}
			if (RelativeMode == PropDefines.RelativeModes.Self)
			{
				prop.MovePropAdditive(Position, Quaternion.Euler(Rotation), Scale);
				return;
			}
			Transform anchorTransform = prop.AnchorTransform;
			Transform transform = null;
			switch (RelativeMode)
			{
			case PropDefines.RelativeModes.WorldAdditive:
				Position += anchorTransform.position;
				break;
			case PropDefines.RelativeModes.Player:
				transform = MainPosition.AttachTransform;
				break;
			case PropDefines.RelativeModes.PlayerAvaterBody:
				SayOops(RelativeMode.ToString() + "はまだ実装されていない！");
				break;
			case PropDefines.RelativeModes.PlayerAvaterHand:
				transform = MainPosition.Avater.AvaterResources.HandObject.GetNodeTransform(RelationAvaterHandNode);
				break;
			case PropDefines.RelativeModes.Chara:
			{
				AdvChara chara2 = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(RelationCharaID);
				if (chara2 == null)
				{
					throw new CommandFailedException(this, $"キャラクター {RelationCharaID} を取得できませんでした");
				}
				transform = chara2.Transform;
				prop.SetAttachToChara(m_chara, RelationCharaNode);
				break;
			}
			case PropDefines.RelativeModes.CharaNode:
			{
				AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(RelationCharaID);
				if (chara == null)
				{
					throw new CommandFailedException(this, $"キャラクター {RelationCharaID} を取得できませんでした");
				}
				Transform node = chara.GetNode(RelationCharaNode);
				if (node == null)
				{
					throw new CommandFailedException(this, $"キャラクター {RelationCharaID} のノード {RelationCharaNode} を取得できませんでした");
				}
				transform = node;
				prop.SetAttachToChara(m_chara, RelationCharaNode);
				break;
			}
			case PropDefines.RelativeModes.OtherProp:
			{
				BaseProp propObject = GetPropObject(player, RelationPropType, RelationPropIndex);
				if (propObject == null)
				{
					throw new CommandFailedException(this, $"プロップ {RelationPropType}.{RelationPropIndex} を取得できませんでした");
				}
				transform = propObject.AnchorTransform;
				break;
			}
			case PropDefines.RelativeModes.OtherPropAnchor:
			{
				BaseProp propObject2 = GetPropObject(player, RelationPropType, RelationPropIndex);
				if (propObject2 == null)
				{
					throw new CommandFailedException(this, $"プロップ {RelationPropType}.{RelationPropIndex} を取得できませんでした");
				}
				transform = propObject2.GetAnchor(RelationPropAnchorIndex);
				break;
			}
			case PropDefines.RelativeModes.RealHead:
				transform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
				break;
			case PropDefines.RelativeModes.RealHand:
				if (SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands)
				{
					AvaterTrackedHandObject avaterTrackedHandObject = ((RelationRealHand == VRDeviceDefine.HandType.Left) ? MainPosition.Avater.AvaterResources.TrackedHandLeftObject : ((RelationRealHand != VRDeviceDefine.HandType.Right) ? ((SingletonMonoBehaviour<GameInputManager>.Instance.PrefferdHand == VRDeviceDefine.HandType.Left) ? MainPosition.Avater.AvaterResources.TrackedHandLeftObject : MainPosition.Avater.AvaterResources.TrackedHandRightObject) : MainPosition.Avater.AvaterResources.TrackedHandRightObject));
					transform = avaterTrackedHandObject.GetNodeTransform(AvaterTrackedHandObject.Node.TrackedGrabPivot);
				}
				else
				{
					transform = ((RelationRealHand != 0) ? ((RelationRealHand != VRDeviceDefine.HandType.Right) ? ((SingletonMonoBehaviour<GameInputManager>.Instance.PrefferdHand == VRDeviceDefine.HandType.Left) ? SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject.transform : SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject.transform) : SingletonMonoBehaviour<PlayAreaManager>.Instance.RightHandObject.transform) : SingletonMonoBehaviour<PlayAreaManager>.Instance.LeftHandObject.transform);
				}
				break;
			case PropDefines.RelativeModes.RealFoot:
				throw new CommandFailedException(this, "足首をくじきました");
			default:
				SayOops(RelativeMode.ToString() + "はまだ実装されていない！");
				break;
			case PropDefines.RelativeModes.World:
				break;
			}
			Quaternion rotation = Quaternion.Euler(Rotation);
			if (transform == null)
			{
				prop.AttachToTransform(null, isStay: true);
				prop.MoveProp(Position, rotation, Scale);
			}
			else if (IsAttachTo)
			{
				prop.AttachToTransform(transform, isStay: true);
				prop.MovePropOnLocal(Position, rotation, Scale);
			}
			else
			{
				prop.AttachToTransform(null, isStay: true);
				prop.MovePropRelation(transform, Position, rotation, Scale);
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneProp)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = (IsWillAttach ? "アタッチ" : "") + (Visible ? "配置" : "消去");
			string text2 = "";
			if (base.IsDynamicProp)
			{
				text2 = " - ";
				text2 = ((!IsOverrideTransform) ? (text2 + "Prefab設定位置") : (RelativeMode switch
				{
					PropDefines.RelativeModes.World => text2 + "ワールド座標" + Position.ToString(), 
					PropDefines.RelativeModes.WorldAdditive => text2 + "ワールド座標[加算]" + Position.ToString(), 
					PropDefines.RelativeModes.Self => text2 + "現在位置から" + Position.ToString(), 
					PropDefines.RelativeModes.Player => text2 + "プレイヤー位置から" + Position.ToString(), 
					PropDefines.RelativeModes.PlayerAvaterBody => text2 + "プレイヤーボディのTODOから" + Position.ToString(), 
					PropDefines.RelativeModes.PlayerAvaterHand => text2 + "プレイヤーハンドのTODOから" + Position.ToString(), 
					PropDefines.RelativeModes.Chara => text2 + $"キャラ{RelationCharaID}の足元から" + Position.ToString(), 
					PropDefines.RelativeModes.CharaNode => text2 + $"キャラ{RelationCharaID}のノード{RelationCharaNode}から" + Position.ToString(), 
					PropDefines.RelativeModes.OtherProp => text2 + $"プロップ{RelationPropType}.{RelationPropIndex}から" + Position.ToString(), 
					PropDefines.RelativeModes.OtherPropAnchor => text2 + $"プロップ{RelationPropType}.{RelationPropIndex}のアンカー{RelationPropAnchorIndex}から" + Position.ToString(), 
					PropDefines.RelativeModes.RealHead => text2 + "リアルの頭から" + Position.ToString(), 
					PropDefines.RelativeModes.RealHand => (RelationRealHand != 0) ? ((RelationRealHand != VRDeviceDefine.HandType.Right) ? (text2 + "リアルの手から" + Position.ToString()) : (text2 + "リアルの右手から" + Position.ToString())) : (text2 + "リアルの左手から" + Position.ToString()), 
					PropDefines.RelativeModes.RealFoot => text2 + "リアルの足から" + Position.ToString(), 
					_ => text2 + "謎の場所から" + Position.ToString(), 
				}));
			}
			return $"シーンプロップ '{PropType}.{PropIndex}' を {text}{text2}";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			int flagInt = GetFlagInt();
			data.DataInt.Add(flagInt);
			data.DataInt.Add((int)RelativeMode);
			data.DataInt.Add((int)FadeMode);
			data.DataInt.Add(OptionIntOne);
			data.DataInt.Add(OptionIntTwo);
			data.DataInt.Add(OptionIntThree);
			data.DataFloat.Add(FadeDuration);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
			data.DataFloat.Add(Rotation.x);
			data.DataFloat.Add(Rotation.y);
			data.DataFloat.Add(Rotation.z);
			data.DataFloat.Add(Scale.x);
			data.DataFloat.Add(Scale.y);
			data.DataFloat.Add(Scale.z);
			data.DataFloat.Add(Delay);
		}

		private int GetFlagInt()
		{
			return (Visible ? 1 : 0) + (IsOverrideTransform ? 2 : 0) + (IsAttachTo ? 4 : 0);
		}

		private void SetFlagsFromInt(int flags)
		{
			Visible = (flags & 1) != 0;
			IsOverrideTransform = (flags & 2) != 0;
			IsAttachTo = (flags & 4) != 0;
		}
	}
	public class CommandScenePropAction : BaseCommandSceneProp
	{
		public int ActionIndex;

		public override Types Type => Types.ScenePropAction;

		public CommandScenePropAction()
		{
			PropType = PropDefines.PropType.Dynamic;
		}

		public CommandScenePropAction(SequenceData.Param data)
		{
			LoadFromData(data);
			PropType = PropDefines.PropType.Dynamic;
			ActionIndex = data.DataInt[2];
		}

		protected override bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			prop.ActionPropAnimation(ActionIndex);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandScenePropAction)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"シーンプロップ '{PropType}.{PropIndex}' のアクション 'Index.{ActionIndex}' を実行";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add(ActionIndex);
		}
	}
	public class CommandScenePropOutline : BaseCommandSceneProp
	{
		public PropDefines.FadeModes FadeMode;

		public float FadeDuration = 0.3f;

		public float OutlineSize = 0.1f;

		public Color OutlineColor = new Color(0.75f, 0.75f, 0.75f);

		public bool FlagChangeSize = true;

		public bool FlagChangeColor = true;

		public override Types Type => Types.ScenePropOutline;

		public CommandScenePropOutline()
		{
			PropType = PropDefines.PropType.Dynamic;
		}

		public CommandScenePropOutline(SequenceData.Param data, int version)
		{
			LoadFromData(data);
			int @int = data.GetInt(2);
			SetFlagsFromInt(@int);
			FadeMode = (PropDefines.FadeModes)data.GetInt(3);
			FadeDuration = data.GetFloat(0);
			OutlineSize = data.GetFloat(1);
			OutlineColor.r = data.GetFloat(2);
			OutlineColor.g = data.GetFloat(3);
			OutlineColor.b = data.GetFloat(4);
			OutlineColor.a = data.GetFloat(5);
		}

		protected override bool PlayCommandWithProp(TimelinePlayer player, BaseProp prop)
		{
			switch (FadeMode)
			{
			case PropDefines.FadeModes.Smooth:
				if (FlagChangeSize)
				{
					prop.StartSmoothOutlineSizeChange(FadeDuration, OutlineSize);
				}
				if (FlagChangeColor)
				{
					prop.StartSmoothOutlineColorChange(FadeDuration, OutlineColor);
				}
				break;
			case PropDefines.FadeModes.Dither:
				prop.ActionBetweenDither(FadeDuration, delegate
				{
					if (FlagChangeSize)
					{
						prop.SetOutlineSize(OutlineSize);
					}
					if (FlagChangeColor)
					{
						prop.SetOutlineColor(OutlineColor);
					}
				}, null);
				break;
			default:
				if (FlagChangeSize)
				{
					prop.SetOutlineSize(OutlineSize);
				}
				if (FlagChangeColor)
				{
					prop.SetOutlineColor(OutlineColor);
				}
				break;
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandScenePropOutline)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "<b>プロップアウトライン変更</b>:";
			text += $" 対象[<b>{PropType}.{PropIndex}</b>]";
			switch (FadeMode)
			{
			case PropDefines.FadeModes.None:
				text += " フェード[瞬時]";
				break;
			case PropDefines.FadeModes.Smooth:
				text += $" フェード[スムース {FadeDuration:F1} s]";
				break;
			case PropDefines.FadeModes.Dither:
				text += $" フェード[ディザ {FadeDuration:F1} s]";
				break;
			}
			text = ((!FlagChangeSize) ? (text + " 太さ[継承]") : (text + $" 太さ[{OutlineSize:F2}]"));
			if (FlagChangeColor)
			{
				return text + $" 色[<color=#{ColorUtility.ToHtmlStringRGB(OutlineColor)}>■■■</color>]";
			}
			return text + " 色[継承]";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			int flagInt = GetFlagInt();
			data.DataInt.Add(flagInt);
			data.DataInt.Add((int)FadeMode);
			data.DataFloat.Add(FadeDuration);
			data.DataFloat.Add(OutlineSize);
			data.DataFloat.Add(OutlineColor.r);
			data.DataFloat.Add(OutlineColor.g);
			data.DataFloat.Add(OutlineColor.b);
			data.DataFloat.Add(OutlineColor.a);
		}

		private int GetFlagInt()
		{
			return (FlagChangeSize ? 1 : 0) + (FlagChangeColor ? 2 : 0);
		}

		private void SetFlagsFromInt(int flags)
		{
			FlagChangeSize = (flags & 1) != 0;
			FlagChangeColor = (flags & 2) != 0;
		}
	}
	public class CommandSceneToChapterEnd : BaseCommandSceneTo
	{
		public bool ForceBackToTitle;

		public bool SkipSubtitle;

		public bool SkipConfirm;

		private bool m_hasProcessed;

		public override Types Type => Types.SceneToChapterEnd;

		protected override SceneDefine SceneTransitionTo => SceneDefine.EndOfChapter;

		public CommandSceneToChapterEnd()
		{
		}

		public CommandSceneToChapterEnd(SequenceData.Param data, int version)
			: base(data, version)
		{
			ForceBackToTitle = IntToBool(data.GetInt(2));
			SkipSubtitle = IntToBool(data.GetInt(3));
			SkipConfirm = IntToBool(data.GetInt(4));
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = true;
			if (SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
			return base.PlayCommand(player);
		}

		public override void OnEnd(TimelinePlayer player)
		{
			if (!m_hasProcessed)
			{
				m_hasProcessed = true;
				if (ForceBackToTitle && !SingletonMonoBehaviour<MasterManager>.Instance.IsSuperAutoMode)
				{
					player.QuitToTitle();
				}
				else
				{
					base.OnEnd(player);
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToChapterEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "章おわりシーンへ移動 -> " + GetNextScquenceString();
			if (ForceBackToTitle)
			{
				text += " (セーブ後タイトルへ戻る)";
			}
			return text;
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add(BoolToInt(ForceBackToTitle));
			data.DataInt.Add(BoolToInt(SkipSubtitle));
			data.DataInt.Add(BoolToInt(SkipConfirm));
		}
	}
	public class CommandSceneToChapterStart : BaseCommandSceneTo
	{
		public override Types Type => Types.SceneToChapterStart;

		protected override SceneDefine SceneTransitionTo => SceneDefine.StartOfChapter;

		public CommandSceneToChapterStart()
		{
		}

		public CommandSceneToChapterStart(SequenceData.Param data, int version)
			: base(data, version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return base.PlayCommand(player);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToChapterStart)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "章はじめシーンへ移動 -> " + GetNextScquenceString();
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
		}
	}
	public class CommandSceneToOpening : BaseCommandSceneTo
	{
		public int RouteCount = 1;

		public override Types Type => Types.SceneToOpening;

		protected override SceneDefine SceneTransitionTo => GetSceneTo();

		public CommandSceneToOpening()
		{
		}

		public CommandSceneToOpening(SequenceData.Param data, int version)
			: base(data, version)
		{
			RouteCount = data.GetInt(2);
		}

		private SceneDefine GetSceneTo()
		{
			return RouteCount switch
			{
				1 => SceneDefine.Opening, 
				2 => SceneDefine.OpeningSecond, 
				_ => SceneDefine.Opening, 
			};
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToOpening)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"オープニング No.{RouteCount} シーンへ -> " + GetNextScquenceString();
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add(RouteCount);
		}
	}
	public class CommandSceneToSpecial : BaseCommandSceneTo
	{
		public SceneDefine NextScene = SceneDefine.Blank;

		public override Types Type => Types.SceneToSpecial;

		protected override SceneDefine SceneTransitionTo => NextScene;

		public CommandSceneToSpecial()
		{
		}

		public CommandSceneToSpecial(SequenceData.Param data, int version)
			: base(data, version)
		{
			NextScene = (SceneDefine)data.GetInt(2);
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return base.PlayCommand(player);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneToSpecial)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"特殊シーン {SceneTransitionTo.ToString()} へ移動 -> {GetNextScquenceString()}";
		}

		public override void Save(SequenceData.Param data)
		{
			base.Save(data);
			data.DataInt.Add((int)NextScene);
		}
	}
	public class CommandSceneUnload : ISequenceCommand
	{
		public override Types Type => Types.SceneUnload;

		public override PreloadTypes PreloadType => PreloadTypes.UnityScene;

		public override int PreloadIndex => 34;

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.ChangeScene(SceneDefine.Blank);
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSceneUnload)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "Unityシーンをアンロード";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandSe2D : ISequenceCommand, ISoundCommand
	{
		public const string FILENAME = "Audio/SE/{0:D4}";

		public float Volume = 1f;

		public bool IsRepeat;

		public override Types Type => Types.PlaySE2D;

		public override PreloadTypes PreloadType => PreloadTypes.SoundEffect;

		public override int PreloadIndex => ID;

		public int ID { get; set; }

		public int SoundID => ID;

		public AudioClip Clip { get; set; }

		public CommandSe2D()
		{
		}

		public CommandSe2D(int id, float volume, bool isRepeat)
		{
			ID = id;
			Volume = volume;
			IsRepeat = isRepeat;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (IsSakuraiFootStep(ID))
			{
				Volume = 0.35f;
			}
			SoundManager.SE.PlayClip(Clip, Volume, null, IsRepeat);
			return true;
		}

		private bool IsSakuraiFootStep(int id)
		{
			if (id != 6 && id != 9 && id != 10 && id != 41 && id != 46 && id != 55)
			{
				return id == 73;
			}
			return true;
		}

		public virtual string GetFilePath()
		{
			return $"Audio/SE/{ID:D4}";
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSe2D)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return string.Format("2D効果音を再生: SoundID:{0}, 音量:{1:p1} {2}", ID, Volume, IsRepeat ? "(Loop)" : "");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
			data.DataInt.Add(BoolToInt(IsRepeat));
			data.DataFloat.Add(Volume);
		}
	}
	public class CommandSe2DOff : ISequenceCommand
	{
		public int ID;

		public override Types Type => Types.StopSE2D;

		public CommandSe2DOff()
		{
		}

		public CommandSe2DOff(int id)
		{
			ID = id;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.SE.Stop();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSe2DOff)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"2D効果音ID {ID} を停止";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandSe3D : CommandSe2D
	{
		public enum SourceType
		{
			Point,
			Chara,
			CharaNode,
			Prop,
			PropNode
		}

		public SourceType Source;

		public Vector3 Position;

		public int FirstIndex;

		public int SecondIndex;

		public int ThirdIndex;

		public override Types Type => Types.PlaySE3D;

		public override PreloadTypes PreloadType => PreloadTypes.SoundEffect;

		public override int PreloadIndex => base.ID;

		public GameDefine.CharaID TargetChara => (GameDefine.CharaID)FirstIndex;

		public AdvCharaModel.Node TargetCharaNode => (AdvCharaModel.Node)SecondIndex;

		public PropDefines.PropType TargetPropType
		{
			get
			{
				return (PropDefines.PropType)FirstIndex;
			}
			set
			{
				FirstIndex = (int)value;
			}
		}

		public int TargetPropIndex => SecondIndex;

		public int TargetPropNodeIndex => ThirdIndex;

		public CommandSe3D()
		{
		}

		public CommandSe3D(SequenceData.Param data)
		{
			base.ID = data.DataInt[0];
			FlagToParams(data.DataInt[1]);
			Source = (SourceType)data.DataInt[2];
			FirstIndex = TryGetDataInt(data.DataInt, 3);
			SecondIndex = TryGetDataInt(data.DataInt, 4);
			ThirdIndex = TryGetDataInt(data.DataInt, 5);
			Volume = data.DataFloat[0];
			Position = new Vector3(TryGetDataFloat(data.DataFloat, 1), TryGetDataFloat(data.DataFloat, 2), TryGetDataFloat(data.DataFloat, 3));
		}

		private int TryGetDataInt(List<int> list, int index, int defaultValue = 0)
		{
			if (list.Count <= index)
			{
				return defaultValue;
			}
			return list[index];
		}

		private float TryGetDataFloat(List<float> list, int index, float defaultValue = 0f)
		{
			if (list.Count <= index)
			{
				return defaultValue;
			}
			return list[index];
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (Source == SourceType.Chara)
			{
				MoveToCharaPosition();
			}
			else if (Source == SourceType.Prop)
			{
				MoveToPropPosition(player.CurrentBackground);
			}
			else if (Source == SourceType.PropNode)
			{
				MoveToPropAnchorPosition(player.CurrentBackground);
			}
			SoundManager.SE.PlayClip3D(base.Clip, base.ID, Volume, ref Position, IsRepeat);
			return true;
		}

		private void MoveToCharaPosition()
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara((GameDefine.CharaID)FirstIndex);
			if (!(chara == null))
			{
				if (chara.Model.IsFading)
				{
					Position = chara.NextPosition;
					return;
				}
				Vector3 addAmount = chara.Transform.localPosition;
				Vector3Extension.AddTarget(ref Position, ref addAmount);
			}
		}

		private void MoveToPropPosition(AdvBackground bg)
		{
			BaseProp propByIndex = bg.GetPropControllerByType(TargetPropType).GetPropByIndex(TargetPropIndex);
			if (!(propByIndex == null))
			{
				Vector3 addAmount = propByIndex.AudioAnchorTransform.position;
				Vector3Extension.AddTarget(ref Position, ref addAmount);
			}
		}

		private void MoveToPropAnchorPosition(AdvBackground bg)
		{
			BaseProp propByIndex = bg.GetPropControllerByType(TargetPropType).GetPropByIndex(TargetPropIndex);
			if (!(propByIndex == null))
			{
				Transform anchor = propByIndex.GetAnchor(TargetPropNodeIndex);
				if (!(anchor == null))
				{
					Position = anchor.TransformPoint(Position);
				}
			}
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSe3D)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			switch (Source)
			{
			case SourceType.Point:
				text = $"座標指定{Position.ToString()}";
				break;
			case SourceType.Chara:
				text = $"キャラクター{TargetChara}";
				break;
			case SourceType.Prop:
				text = $"プロップ{TargetPropType}.{TargetPropIndex}";
				break;
			case SourceType.PropNode:
				text = $"プロップ{TargetPropType}.{TargetPropIndex}.Anchor{TargetPropNodeIndex}";
				break;
			}
			return string.Format("3D効果音を再生: SoundID:{0}, 音源:{1}, 音量:{2:p1} {3}", base.ID, text, Volume, IsRepeat ? "(Loop)" : "");
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(base.ID);
			data.DataInt.Add(ParamsToFlag());
			data.DataInt.Add((int)Source);
			data.DataInt.Add(FirstIndex);
			data.DataInt.Add(SecondIndex);
			data.DataInt.Add(ThirdIndex);
			data.DataFloat.Add(Volume);
			data.DataFloat.Add(Position.x);
			data.DataFloat.Add(Position.y);
			data.DataFloat.Add(Position.z);
		}

		private void FlagToParams(int flags)
		{
			IsRepeat = (flags & 1) != 0;
		}

		private int ParamsToFlag()
		{
			if (!IsRepeat)
			{
				return 0;
			}
			return 1;
		}
	}
	public class CommandSe3DOff : CommandSe2DOff
	{
		public override Types Type => Types.StopSE3D;

		public CommandSe3DOff()
		{
		}

		public CommandSe3DOff(int id)
			: base(id)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SoundManager.SE.Stop3D(ID);
			return true;
		}

		public override string CreateDescriptionText()
		{
			return $"3D効果音ID {ID} を停止";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(ID);
		}
	}
	public class CommandSelection : ISequenceCommand
	{
		public class SelectionOptions
		{
			public const int PARAM_MAX = 6;

			public SelectionDefines.CollisionTypes MakeCollisionType;

			public int TypeInt;

			public int TargetIndexOne;

			public int TargetIndexTwo;

			public int TargetIndexThree;

			public int NextSequenceIndex;

			public SelectionDefines.TargetTypes SelectType
			{
				get
				{
					return (SelectionDefines.TargetTypes)TypeInt;
				}
				set
				{
					TypeInt = (int)value;
				}
			}

			public GameDefine.CharaID TargetChara
			{
				get
				{
					return (GameDefine.CharaID)TargetIndexOne;
				}
				set
				{
					TargetIndexOne = (int)value;
				}
			}

			public PropDefines.PropType TargetPropType
			{
				get
				{
					return (PropDefines.PropType)TargetIndexOne;
				}
				set
				{
					TargetIndexOne = (int)value;
				}
			}

			public int TargetPropIndex
			{
				get
				{
					return TargetIndexTwo;
				}
				set
				{
					TargetIndexTwo = value;
				}
			}

			public int TargetFocusWindowIndex
			{
				get
				{
					return TargetIndexOne;
				}
				set
				{
					TargetIndexOne = value;
				}
			}

			public void Save(SequenceData.Param data)
			{
				data.DataInt.Add((int)MakeCollisionType);
				data.DataInt.Add(TypeInt);
				data.DataInt.Add(TargetIndexOne);
				data.DataInt.Add(TargetIndexTwo);
				data.DataInt.Add(TargetIndexThree);
				data.DataInt.Add(NextSequenceIndex);
			}

			public static SelectionOptions Load(SequenceData.Param data, int startIndex)
			{
				SelectionOptions selectionOptions = new SelectionOptions();
				if (data.DataInt.Count < startIndex + 6)
				{
					return selectionOptions;
				}
				selectionOptions.MakeCollisionType = (SelectionDefines.CollisionTypes)data.GetInt(startIndex);
				selectionOptions.TypeInt = data.GetInt(startIndex + 1);
				selectionOptions.TargetIndexOne = data.GetInt(startIndex + 2);
				selectionOptions.TargetIndexTwo = data.GetInt(startIndex + 3);
				selectionOptions.TargetIndexThree = data.GetInt(startIndex + 4);
				selectionOptions.NextSequenceIndex = data.GetInt(startIndex + 5);
				return selectionOptions;
			}
		}

		public const int MIN_OPTIION = 1;

		public const int MAX_OPTIION = 4;

		private int _selectionCount = 2;

		private int _selectionMode;

		public List<SelectionOptions> SelectionList = new List<SelectionOptions>();

		public override Types Type => Types.Selection;

		public override bool PlayInHardSkip => true;

		public int SelectionCount
		{
			get
			{
				return _selectionCount;
			}
			set
			{
				_selectionCount = Mathf.Clamp(value, 1, 4);
			}
		}

		public SelectionDefines.Modes SelectionMode
		{
			get
			{
				return (SelectionDefines.Modes)_selectionMode;
			}
			set
			{
				_selectionMode = (int)value;
			}
		}

		public CommandSelection()
		{
			for (int i = 0; i < 4; i++)
			{
				SelectionList.Add(new SelectionOptions());
			}
		}

		public CommandSelection(SequenceData.Param data, int version)
		{
			int num = 2;
			SelectionCount = data.GetInt(0);
			if (version <= 6)
			{
				num = 1;
			}
			else
			{
				_selectionMode = data.GetInt(1);
			}
			for (int i = 0; i < 4; i++)
			{
				if (i < SelectionCount)
				{
					int startIndex = num + i * 6;
					SelectionOptions item = SelectionOptions.Load(data, startIndex);
					SelectionList.Add(item);
				}
				else
				{
					SelectionList.Add(new SelectionOptions());
				}
			}
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			SelectionController selectionProcessor = player.SelectionProcessor;
			selectionProcessor.EndSelectionObservable.Where((int index) => index > -1).Subscribe(delegate(int index)
			{
				OnEndSelection(player, index);
			});
			selectionProcessor.StartSelection(this);
			player.MessageProcessor.ForceMode = MessagePlayer.ForceModes.NoAutoSkip;
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(MainMenuManager.MenuMode.SkipMode, flag: true);
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(MainMenuManager.MenuMode.Note, flag: true);
			return false;
		}

		private void OnEndSelection(TimelinePlayer player, int index)
		{
			SingletonMonoBehaviour<LocalData>.Instance.IsOmitNextAutoSave = true;
			if (SelectionMode == SelectionDefines.Modes.Finale)
			{
				player.ReleaseCommandWait();
				return;
			}
			int nextSequenceIndex = SelectionList[index].NextSequenceIndex;
			player.ReserveLoadScenerioWithComplete(nextSequenceIndex);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSelection)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			string text = "";
			if (SelectionMode == SelectionDefines.Modes.Finale)
			{
				text = "条件分岐コマンドで制御";
			}
			else
			{
				for (int i = 0; i < SelectionCount; i++)
				{
					if (i > 0)
					{
						text += " or ";
					}
					text += $"SID[{SelectionList[i].NextSequenceIndex:00000}]";
				}
			}
			return "選択肢を表示して分岐: " + text;
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(SelectionCount);
			data.DataInt.Add(_selectionMode);
			for (int i = 0; i < SelectionCount; i++)
			{
				SelectionList[i].Save(data);
			}
		}
	}
	public class CommandSetGameFlag : ISequenceCommand
	{
		public GameFlags TargetFlag;

		public bool ValueToSet;

		public override Types Type => Types.SetGameFlag;

		public override bool PlayInHardSkip => true;

		public CommandSetGameFlag()
		{
			ValueToSet = true;
		}

		public CommandSetGameFlag(SequenceData.Param data)
			: this()
		{
			TargetFlag = (GameFlags)data.DataInt[0];
			ValueToSet = data.DataInt[1] != 0;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			AnalyticsUtility.SendFlagEvent(TargetFlag, ValueToSet);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(TargetFlag, ValueToSet);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandSetGameFlag)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"フラグ [{TargetFlag}] = {ValueToSet}";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)TargetFlag);
			data.DataInt.Add(ValueToSet ? 1 : 0);
		}
	}
	public class CommandShakeWindow : ISequenceCommand
	{
		public float Duration = 0.35f;

		public override Types Type => Types.ShakeWindow;

		public CommandShakeWindow()
		{
			Duration = 0.35f;
		}

		public CommandShakeWindow(float duration)
		{
			Duration = duration;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.ShakeNextWindow(Duration);
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandShakeWindow)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "次のウィンドウをシェイクさせる";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Duration);
		}
	}
	public class CommandStartCutscene : ISequenceCommand
	{
		public override Types Type => Types.StartCutscene;

		public CommandStartCutscene()
		{
		}

		public CommandStartCutscene(SequenceData.Param data, int version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.CurrentCutScene == null)
			{
				player.ForceFindCutScene();
			}
			player.CurrentCutScene.PrepareTimeline();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandStartCutscene)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "カットシーン強制開始";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandTest : ISequenceCommand
	{
		public override Types Type => Types.Test;

		public override bool PlayCommand(TimelinePlayer player)
		{
			UnityEngine.Debug.Log("WOW it's a test command!");
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandTest)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "テストコマンド";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandText : ISequenceCommand
	{
		public bool Is2DVoice;

		private MemoryModeManager m_memoryModeManager;

		public override Types Type => Types.Text;

		public GameDefine.CharaID Chara { get; set; }

		public GameDefine.CharaID CharaType { get; private set; }

		public int TextIndex { get; set; }

		public int VoiceIndex { get; set; }

		public string Text { get; set; }

		public string VoiceFile { get; private set; }

		public bool IsMemoryMode { get; private set; }

		public bool IsMonologue => Chara == GameDefine.CharaID.BASE;

		public string CharaFullName
		{
			get
			{
				if (!IsMonologue)
				{
					return SingletonMonoBehaviour<DataManager>.Instance.CharaData.FindName(Chara);
				}
				return string.Empty;
			}
		}

		public CommandText()
		{
		}

		public CommandText(GameDefine.CharaID chara, string text, int textIndex, string voiceFile, int voiceIndex = -1, bool is2DVoice = false)
		{
			Chara = chara;
			Text = text;
			TextIndex = textIndex;
			VoiceIndex = voiceIndex;
			Is2DVoice = is2DVoice;
			VoiceFile = voiceFile;
			CharaType = chara;
			if (GameDefine.IsUnknownChara(CharaType))
			{
				CharaType = GameDefine.UnknownToCharaID(CharaType);
			}
			CharaType = GameDefine.GetOriginalCharaID(CharaType);
		}

		public override ISequenceCommand Clone()
		{
			return (CommandText)MemberwiseClone();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			ProcessMemoryMode(player);
			player.MessageProcessor.AddMessageLog(this);
			return false;
		}

		private void ProcessMemoryMode(TimelinePlayer player)
		{
			m_memoryModeManager = player.MemoryModeProcessor;
			IsMemoryMode = player.IsMemoryMode;
			if (IsMemoryMode)
			{
				m_memoryModeManager.SetTalkChara(Chara);
			}
		}

		public Data_Character.Param FindCharacterData()
		{
			if (Chara == GameDefine.CharaID.BASE)
			{
				return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(GameDefine.CharaID.BASE);
			}
			if (GameDefine.IsModChara(Chara))
			{
				return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(GameDefine.CharaID.BASE);
			}
			if (GameDefine.IsUnknownChara(Chara))
			{
				return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(GameDefine.UnknownToCharaID(Chara));
			}
			return SingletonMonoBehaviour<DataManager>.Instance.CharaTextData.FindDataByID(Chara);
		}

		public IChara FindCharacter()
		{
			if (Chara == GameDefine.CharaID.BASE)
			{
				return null;
			}
			if (IsMemoryMode)
			{
				return m_memoryModeManager.FindCharaType(Chara);
			}
			return SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(Chara);
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			player.UpdateMessageInput();
			return false;
		}

		public override string CreateDescriptionText()
		{
			return string.Format("{1} のメッセージテキスト (ID = {0})", TextIndex, Chara);
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add((int)Chara);
			data.DataInt.Add(TextIndex);
			data.DataInt.Add(VoiceIndex);
			data.DataInt.Add(BoolToInt(Is2DVoice));
		}
	}
	public class CommandWaitBgmBar : ISequenceCommand
	{
		public int WaitBars = 1;

		private Common.Timer m_waitTimer;

		public override Types Type => Types.WaitBgmBar;

		public CommandWaitBgmBar()
		{
			m_waitTimer = null;
		}

		public CommandWaitBgmBar(int waitBars)
			: this()
		{
			WaitBars = waitBars;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsSkipMode)
			{
				return true;
			}
			float bgmBarDuration = SingletonMonoBehaviour<SoundManager>.Instance.GetBgmBarDuration(WaitBars, isCountCurrentBar: true);
			if (bgmBarDuration <= 0f)
			{
				return true;
			}
			m_waitTimer = new Common.Timer(bgmBarDuration);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (m_waitTimer == null)
			{
				SayOops("I cannot find timer for waiting.");
				return true;
			}
			m_waitTimer.Update(timeDelta);
			if (m_waitTimer.IsTimeUp)
			{
				m_waitTimer = null;
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitBgmBar)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "BGMの " + WaitBars + " 小節目までウェイト";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataInt.Add(WaitBars);
		}
	}
	public class CommandWaitBgmEnd : ISequenceCommand
	{
		public override Types Type => Types.WaitBgmEnd;

		public override bool PlayCommand(TimelinePlayer player)
		{
			bool num = IsEnd();
			if (!num && !SoundManager.Bgm.IsKaineStopping)
			{
				SoundManager.Bgm.Stop(BgmPlayer.StopMode.Fade);
			}
			return num;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			return IsEnd();
		}

		private bool IsEnd()
		{
			return !SingletonMonoBehaviour<SoundManager>.Instance.IsPlayingBgm();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitBgmEnd)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "BGMの終了までウェイト";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWaitInput : ISequenceCommand
	{
		public override Types Type => Types.WaitInput;

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsSkipMode)
			{
				return true;
			}
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			player.UpdateMessageInput();
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitInput)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "プレイヤーの入力までウェイト";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWaitSE : ISequenceCommand
	{
		public override Types Type => Types.WaitSE;

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			return !SoundManager.SE.IsPlayingAny();
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			return !SoundManager.SE.IsPlayingAny();
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitSE)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"効果音待ち";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWaitTime : ISequenceCommand
	{
		public float Duration = 0.5f;

		private Common.Timer m_waitTimer;

		public override Types Type => Types.Wait;

		public CommandWaitTime()
		{
			Duration = 0.5f;
		}

		public CommandWaitTime(float time)
		{
			Duration = time;
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			if (player.IsSkipMode)
			{
				return true;
			}
			m_waitTimer = new Common.Timer(Duration);
			return false;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (m_waitTimer == null)
			{
				SayOops("I cannot find timer for waiting.");
				return true;
			}
			m_waitTimer.Update(timeDelta);
			if (m_waitTimer.IsTimeUp)
			{
				m_waitTimer = null;
				return true;
			}
			return false;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitTime)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return $"ウェイト: {Duration} 秒";
		}

		public override void Save(SequenceData.Param data)
		{
			data.DataFloat.Add(Duration);
		}
	}
	public class CommandWaitTimeline : ISequenceCommand
	{
		public override Types Type => Types.WaitTimeline;

		public CommandWaitTimeline()
		{
		}

		public CommandWaitTimeline(SequenceData.Param data, int version)
			: base(data, version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.SetIndigaterVisible(flag: false);
			SingletonMonoBehaviour<MainMenuManager>.Instance.SetProhibitions(MainMenuManager.MenuMode.Note, flag: true);
			return player.CurrentCutScene.IsFinished;
		}

		public override bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			if (!player.IsSkipMode)
			{
				return player.CurrentCutScene.IsFinished;
			}
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWaitTimeline)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "カットシーンの終了まで待機";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public class CommandWindowThroughEffect : ISequenceCommand
	{
		public override Types Type => Types.WindowThroughEffect;

		public CommandWindowThroughEffect()
		{
		}

		public CommandWindowThroughEffect(SequenceData.Param data, int version)
			: base(data, version)
		{
		}

		public override bool PlayCommand(TimelinePlayer player)
		{
			player.MessageProcessor.EffectThroughNextWindow();
			return true;
		}

		public override ISequenceCommand Clone()
		{
			return (CommandWindowThroughEffect)MemberwiseClone();
		}

		public override string CreateDescriptionText()
		{
			return "次のウィンドウを突き抜けエフェクト";
		}

		public override void Save(SequenceData.Param data)
		{
		}
	}
	public abstract class ICharaCommand : ISequenceCommand
	{
		public GameDefine.CharaID Chara = GameDefine.CharaID.NIKAIDOU;

		public bool IsMemoryMode;

		public ICharaCommand()
		{
		}

		public ICharaCommand(GameDefine.CharaID chara)
		{
			Chara = chara;
		}
	}
	[Serializable]
	public abstract class ISequenceCommand
	{
		public enum Types
		{
			Text = 0,
			CharaActive = 1,
			CharaOn = 2,
			CharaOff = 3,
			CharaPosition = 4,
			CharaRotate = 5,
			PlaySE2D = 6,
			StopSE2D = 7,
			PlayBgm = 8,
			StopBgm = 9,
			Wait = 10,
			WaitInput = 11,
			FadeIn = 12,
			FadeOut = 13,
			CharaMotion = 14,
			CharaFace = 15,
			PlayerPosition = 16,
			PlayerRotation = 17,
			Emotion = 18,
			ShakeWindow = 19,
			Selection = 20,
			ForcusUp = 21,
			ForcusUpOff = 22,
			Environment = 23,
			Scene = 24,
			Sequence = 25,
			Props = 26,
			PropsOff = 27,
			PropsChara = 28,
			PropsCharaOff = 29,
			PlaySE3D = 30,
			StopSE3D = 31,
			EndDemo = 32,
			PlayAmbient = 33,
			StopAmbient = 34,
			CharaLootAt = 35,
			CharaChange = 36,
			FlashBackStart = 37,
			FlashBackEnd = 38,
			FlashBackChange = 39,
			ForcusUpChange = 40,
			FadeWithoutText = 41,
			FadeWithoutTextEnd = 42,
			CharaAttachPlayer = 43,
			CharaDetachPlayer = 44,
			BokeSphereStart = 45,
			BokeSphereEnd = 46,
			FixWindowStart = 47,
			FixWindowEnd = 48,
			SetPlayerChara = 49,
			CharaCircularPosition = 50,
			BgmChangeLayer = 51,
			EnvrionmentBlendShape = 52,
			EnvironmentPropsPosition = 53,
			EnvironmentPropsRotation = 54,
			EnvironmentPropsOn = 55,
			EnvironmentPropsOff = 56,
			WaitBgmBar = 57,
			LogicIfFlag = 58,
			LogicElse = 59,
			LogicEndIf = 60,
			SetGameFlag = 61,
			WaitBgmEnd = 62,
			CharaRotateReletive = 63,
			CharaPositionReletive = 64,
			CharaSetMirrorMode = 65,
			CameraClearColour = 66,
			PlayBgmSimple = 67,
			StopBgmSimple = 68,
			BgmSimpleVolumeChange = 69,
			SceneProp = 70,
			ScenePropAction = 71,
			CharaTransform = 72,
			PlayerArmMotion = 73,
			WaitSE = 74,
			ProhibitOpenMenu = 75,
			ProhibitMenuSelection = 76,
			ProhibitMessageSound = 77,
			SceneToChapterStart = 78,
			SceneToChapterEnd = 79,
			EndInGame = 80,
			MessageForceMode = 81,
			SceneUnload = 82,
			MemoryCharaOn = 83,
			MemoryCharaOff = 84,
			MemoryCharaTransform = 85,
			MemoryStart = 86,
			MemoryEnd = 87,
			EnableTypingSound = 88,
			MemoryEmotion = 89,
			MemoryAmbient = 90,
			MemoryAmbientOff = 91,
			MemoryAmbientVolume = 92,
			PlayerAvaterTrack = 93,
			SceneToOpening = 94,
			SceneToSpecial = 95,
			WaitTimeline = 96,
			NoAnimationLimit = 97,
			OutlineChange = 98,
			WindowThroughEffect = 99,
			CpuGpuLevel = 100,
			StartCutscene = 101,
			BackgroundActive = 102,
			CharaStyleChange = 103,
			AvaterVisible = 104,
			CommandAutoWaitOverride = 105,
			AvaterOutline = 106,
			CharaTexture = 107,
			PlayAreaBoundary = 108,
			AvaterTexture = 109,
			ScenePropOutline = 110,
			MenuFixMode = 111,
			ProhibitHeightChange = 112,
			EditorNote = 999999,
			Test = 1000000,
			Undefined = 1000001
		}

		public enum PreloadTypes
		{
			None = -1,
			TextVoice,
			BgmSimple,
			BgmAdvanced,
			SoundEffect,
			AmbientEffect,
			FocusUp,
			FlashBack,
			BokeSphere,
			PropStatic,
			PropDynamic,
			Avater,
			MemoryChara,
			UnityScene,
			CpuGpuLevel,
			MemoryModeStart,
			MAX
		}

		public virtual Types Type => Types.Undefined;

		public virtual bool IsDeprecated => false;

		public virtual bool IsLogic => false;

		public virtual bool PlayInHardSkip => false;

		public virtual PreloadTypes PreloadType => PreloadTypes.None;

		public virtual int PreloadIndex => -1;

		public bool IsNeedPreload
		{
			get
			{
				if (PreloadType != PreloadTypes.None)
				{
					return PreloadIndex != -1;
				}
				return false;
			}
		}

		public ISequenceCommand()
		{
		}

		public ISequenceCommand(SequenceData.Param data, int version)
			: this()
		{
		}

		public abstract ISequenceCommand Clone();

		public override string ToString()
		{
			return Type.ToString();
		}

		public virtual bool PlayCommand(TimelinePlayer player)
		{
			return true;
		}

		public virtual void OnStart(TimelinePlayer player)
		{
		}

		public virtual void OnEnd(TimelinePlayer player)
		{
		}

		public virtual bool UpdateCommand(TimelinePlayer player, float timeDelta)
		{
			return false;
		}

		public abstract string CreateDescriptionText();

		public abstract void Save(SequenceData.Param data);

		protected int BoolToInt(bool flag)
		{
			if (!flag)
			{
				return 0;
			}
			return 1;
		}

		protected bool IntToBool(int value)
		{
			if (value != 0)
			{
				return true;
			}
			return false;
		}

		protected int BoolListToInt(List<bool> flags)
		{
			int num = 0;
			for (int i = 0; i < flags.Count; i++)
			{
				if (flags[i])
				{
					num += 1 << i;
				}
			}
			return num;
		}

		protected List<bool> IntToBoolList(int flags, int max)
		{
			List<bool> list = new List<bool>(max);
			for (int i = 0; i < max; i++)
			{
				list.Add((flags & (1 << i)) != 0);
			}
			return list;
		}

		protected void SayOops(string text)
		{
		}
	}
	public interface ISoundCommand
	{
		int ID { get; set; }

		AudioClip Clip { get; set; }

		string GetFilePath();
	}
	public class MessagePlayer : MonoBehaviour
	{
		public enum PlayModes
		{
			Normal,
			Auto,
			Skip,
			Log,
			None
		}

		public enum ForceModes
		{
			Freedom,
			NoAuto,
			NoSkip,
			NoAutoSkip,
			ForceAuto
		}

		[Header("Components - External")]
		[SerializeField]
		private MessageWindowController m_messageController;

		[SerializeField]
		private MessageIndigaterComponents m_indigaters;

		private PlayModes m_mode;

		private ForceModes m_forceMode;

		private Subject<Unit> _subjectMessagePaged = new Subject<Unit>();

		private Subject<CommandText> _subjectAddMessageLog = new Subject<CommandText>();

		private Subject<Unit> _subjectFlushMessageLog = new Subject<Unit>();

		private ReactiveProperty<bool> _reactiveIsRemoveInterface = new ReactiveProperty<bool>(initialValue: false);

		private MessageWindowController windowController => m_messageController;

		public bool IsPlayPageSound { get; set; }

		public bool IsMemoryMode { get; set; }

		public bool IsAutoMode => m_mode == PlayModes.Auto;

		public bool IsSkipMode => m_mode == PlayModes.Skip;

		public bool IsEmitSoundOnMessage
		{
			get
			{
				return m_messageController.IsEmitSoundOnMessage;
			}
			set
			{
				m_messageController.IsEmitSoundOnMessage = value;
			}
		}

		public ForceModes ForceMode
		{
			get
			{
				return m_forceMode;
			}
			set
			{
				ChangeForceMode(value);
			}
		}

		public bool CanInterract => m_forceMode != ForceModes.ForceAuto;

		public bool IsAutoWaitOverrided { get; set; }

		public float AutoWaitOverride { get; set; }

		public int MessageSpeedOverride { get; set; }

		public bool IsAutoWaitNeedOverride
		{
			get
			{
				if (IsAutoWaitOverrided)
				{
					return AutoWaitOverride >= 0f;
				}
				return false;
			}
		}

		public bool ProhibitHeightChange
		{
			get
			{
				return windowController.ProhibitHeightChange;
			}
			set
			{
				windowController.ProhibitHeightChange = value;
			}
		}

		public bool IsSuperAutoMode => false;

		public IObservable<Unit> OnMessagePaged => _subjectMessagePaged;

		public IObservable<CommandText> OnAddMessageLog => _subjectAddMessageLog;

		public IObservable<Unit> OnFlushMessageLog => _subjectFlushMessageLog;

		public IReadOnlyReactiveProperty<bool> RemoveInterfaceReactive => _reactiveIsRemoveInterface;

		public bool IsRemoveInterface
		{
			get
			{
				return _reactiveIsRemoveInterface.Value;
			}
			set
			{
				_reactiveIsRemoveInterface.Value = value;
			}
		}

		private void Start()
		{
			windowController.SetPlayer(this);
			InitStates();
			MakeSubscribe();
		}

		private void MakeSubscribe()
		{
			RemoveInterfaceReactive.Subscribe(delegate
			{
				UpdateIndigater();
			});
		}

		public void ClearScenarioRelations()
		{
			FlushMessageLog();
			InitStates();
			windowController.ClearScenarioRelations();
		}

		private void InitStates()
		{
			IsPlayPageSound = true;
			IsMemoryMode = false;
			IsEmitSoundOnMessage = false;
			IsAutoWaitOverrided = false;
			ForceMode = ForceModes.Freedom;
			if (IsSuperAutoMode && m_mode == PlayModes.Normal)
			{
				SetPlayMode(PlayModes.Auto);
			}
			SetIndigaterVisible(flag: true);
			UpdateIndigater();
		}

		public void FlushMessageLog()
		{
			windowController.FlushWindows();
			_subjectFlushMessageLog.OnNext(Unit.Default);
		}

		public void AddMessageLog(CommandText data)
		{
			windowController.NewTextMessage(data);
			_subjectAddMessageLog.OnNext(data);
		}

		public void AddMessageEmergency(CommandText data)
		{
			windowController.NewTextMessage(data);
			windowController.ShowLastWindowAllText();
		}

		public void OnPushMainButton()
		{
			if (CanInterract)
			{
				if (!IsFinishText())
				{
					ShowAllText();
				}
				else
				{
					PlayNextText();
				}
			}
		}

		public void OnProcessAuto()
		{
			PlayNextText();
		}

		private void PlayNextText()
		{
			SoundManager.Voice.StopCurrentVoice();
			if (IsPlayPageSound)
			{
				PlayNextPageSE();
			}
			windowController.OnNextPageInput();
			_subjectMessagePaged.OnNext(Unit.Default);
		}

		private void PlayNextPageSE()
		{
			if (IsMemoryMode)
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_TypeNext, windowController.MessageAudioSource);
			}
			else
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Next, windowController.MessageAudioSource);
			}
		}

		public void ShowAllText()
		{
			windowController.ShowLastWindowAllText();
		}

		public bool IsAutoCounterOk()
		{
			if (!IsAutoWaitNeedOverride)
			{
				if (IsFinishText())
				{
					return IsFinishVoice();
				}
				return false;
			}
			return true;
		}

		private bool IsFinishText()
		{
			return windowController.IsLastWindowAllVisible();
		}

		private bool IsFinishVoice()
		{
			return !SoundManager.Voice.IsPlayingVoice();
		}

		public void ShakeWindow(float duration)
		{
			windowController.ShakeLastWindow(duration);
		}

		public void ShakeNextWindow(float duration)
		{
			_subjectAddMessageLog.First().Subscribe(delegate
			{
				ShakeWindow(duration);
			});
		}

		public void EffectThroughWindow()
		{
			windowController.StartThroughEffect();
		}

		public void EffectThroughNextWindow()
		{
			_subjectAddMessageLog.First().Subscribe(delegate
			{
				EffectThroughWindow();
			});
		}

		public void ResetPlayMode()
		{
			SetPlayMode(PlayModes.Normal);
		}

		public void SetPlayMode(PlayModes m)
		{
			if (m_mode != m)
			{
				m_mode = m;
				UpdateIndigater();
			}
		}

		public bool GetCanToggleModeTo(PlayModes m)
		{
			if (!CanInterract)
			{
				return false;
			}
			switch (m)
			{
			case PlayModes.Normal:
				return true;
			case PlayModes.Auto:
				if (ForceMode != ForceModes.NoAuto)
				{
					return ForceMode != ForceModes.NoAutoSkip;
				}
				return false;
			case PlayModes.Skip:
				if (ForceMode != ForceModes.NoSkip)
				{
					return ForceMode != ForceModes.NoAutoSkip;
				}
				return false;
			default:
				return true;
			}
		}

		public void SetIndigaterVisible(bool flag)
		{
			m_indigaters.ToggleEnabled(flag);
		}

		private void UpdateIndigater()
		{
			m_indigaters.ToggleVisibleAutoPlay(!IsRemoveInterface && m_mode == PlayModes.Auto && ForceMode != ForceModes.ForceAuto);
		}

		private void ChangeForceMode(ForceModes nextMode)
		{
			if (!IsSuperAutoMode && nextMode != m_forceMode)
			{
				ForceModes forceMode = m_forceMode;
				m_forceMode = nextMode;
				OnEndForceMode(forceMode);
				OnStartForceMode(m_forceMode);
				UpdateIndigater();
			}
		}

		private void OnEndForceMode(ForceModes oldMode)
		{
			if (oldMode == ForceModes.ForceAuto && IsAutoMode)
			{
				ResetPlayMode();
			}
		}

		private void OnStartForceMode(ForceModes nextMode)
		{
			switch (nextMode)
			{
			case ForceModes.NoAuto:
				if (IsAutoMode)
				{
					ResetPlayMode();
				}
				break;
			case ForceModes.NoSkip:
				if (IsSkipMode)
				{
					ResetPlayMode();
				}
				break;
			case ForceModes.NoAutoSkip:
				if (IsAutoMode || IsSkipMode)
				{
					ResetPlayMode();
				}
				break;
			case ForceModes.ForceAuto:
				SetPlayMode(PlayModes.Auto);
				break;
			}
		}
	}
	public class MoverFadeSequencer
	{
		private IFader m_fader;

		private Camera m_camera;

		private Color m_backgroundColour;

		private bool m_isBusy;

		private Color m_previousBackgroundColour;

		private float m_fadeDurationAction;

		private Action m_onStartFadeEndAction;

		private Action m_onStartReverseFadeEndAction;

		private Action m_onEndAction;

		public bool IsPlaying { get; private set; }

		public Color BackgroundColor => m_backgroundColour;

		public Color PreviousBackgroundColor => m_previousBackgroundColour;

		public bool IsBusy
		{
			get
			{
				if (!m_isBusy)
				{
					return m_fader.IsFading;
				}
				return true;
			}
		}

		public MoverFadeSequencer(IFader fader, Camera camera, Color backgroundColour)
		{
			m_isBusy = false;
			IsPlaying = fader;
			m_fader = fader;
			m_backgroundColour = backgroundColour;
			m_camera = camera;
			m_onStartFadeEndAction = delegate
			{
				OnStartFadeEnd();
			};
			m_onStartReverseFadeEndAction = delegate
			{
				m_isBusy = false;
				m_fader.SetActive(isActive: false);
			};
			m_onEndAction = delegate
			{
				m_isBusy = false;
				IsPlaying = false;
			};
		}

		public void Play(CommandFadeWithoutText command)
		{
			m_isBusy = true;
			IsPlaying = true;
			m_fadeDurationAction = command.Duration;
			m_backgroundColour = command.EndColour;
			if (m_fadeDurationAction <= 0f)
			{
				SetupStates();
				m_fader.SetColour(command.StartColour);
				m_onStartReverseFadeEndAction();
			}
			else
			{
				m_fader.StartFade(command.StartColour, command.EndColour, m_fadeDurationAction, isDeactivateOnEnd: false, m_onStartFadeEndAction);
			}
		}

		private void OnStartFadeEnd()
		{
			SetupStates();
			m_fader.StartReverseFade(m_fadeDurationAction, isDeactivateOnEnd: false, m_onStartReverseFadeEndAction);
		}

		private void SetupStates()
		{
			m_previousBackgroundColour = m_camera.backgroundColor;
			m_camera.backgroundColor = m_backgroundColour;
			SingletonMonoBehaviour<PlayAreaManager>.Instance.RequestLayerMode(this, PlayAreaManager.LayerModes.InFade);
		}

		public void End(CommandFadeWithoutTextEnd command)
		{
			m_isBusy = true;
			m_fadeDurationAction = command.Duration;
			m_fader.SetColour(command.EndColour);
			ResetCameraSettings();
			m_fader.StartFade(command.EndColour, command.StartColour, m_fadeDurationAction, isDeactivateOnEnd: true, m_onEndAction);
		}

		private void OnEndFadeEnd()
		{
			ResetCameraSettings();
		}

		public void ResetCameraSettings()
		{
			m_camera.backgroundColor = m_previousBackgroundColour;
			SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.InFade);
		}

		public void Reset()
		{
			m_isBusy = false;
			IsPlaying = false;
			ResetCameraSettings();
		}
	}
	public class NotFoundScenarioException : Exception
	{
		public int failedIndex = -1;

		public NotFoundScenarioException()
			: base("シナリオデータが見つかりませんでした")
		{
		}

		public NotFoundScenarioException(int index)
			: base($"シナリオ '{index:00000}' が見つかりませんでした")
		{
			failedIndex = index;
		}
	}
	public class NotFoundSequenceException : Exception
	{
		public int failedIndex = -1;

		public NotFoundSequenceException()
			: base("シーケンスデータのロードに失敗しました")
		{
		}

		public NotFoundSequenceException(int index)
			: base($"シーケンス '{index:00000}' が見つかりませんでした")
		{
			failedIndex = index;
		}
	}
	public class CommandFailedException : Exception
	{
		public ISequenceCommand failedCommand;

		public CommandFailedException()
			: base("コマンド上で例外")
		{
		}

		public CommandFailedException(ISequenceCommand command)
			: base($"コマンド {command.Type} 上でエラー")
		{
			failedCommand = command;
		}

		public CommandFailedException(ISequenceCommand command, string message)
			: base(string.Format("コマンド {0} 上でエラー: " + message, command.Type))
		{
			failedCommand = command;
		}
	}
	public class SequenceOverflowException : Exception
	{
		public SequenceOverflowException()
			: base("タイムラインのインデックスがシナリオの範囲を超えてしまいました。")
		{
		}
	}
	public class SequenceDataConverter
	{
		public enum Versions
		{
			_VERSION_SKIP_REVERSE,
			_VERSION_FACIAL_SKIP_REVERSE,
			_VERSION_FORCUS_UP_SCALE,
			_FORCUS_UP_SOURCES,
			_TEXT_2D_VOICE,
			_MEMORY_MODE,
			_SELECTION_MODE,
			Current
		}

		private int m_voiceIndex;

		private SequenceTable m_sequenceTable;

		private ScenarioTextTable m_textTable;

		private int m_version;

		private bool m_isEditor;

		private bool m_isConverted;

		private bool m_hasPassesFirstFade;

		private List<ISequenceCommand> m_commandList;

		private Subject<ISequenceCommand> _subjectLoadCommand = new Subject<ISequenceCommand>();

		public IObservable<ISequenceCommand> OnLoadCommand => _subjectLoadCommand;

		private bool IsDebugPlay => false;

		public SequenceDataConverter(ScenarioTextTable textTable, SequenceTable sequenceTable, bool isEditor = false)
		{
			m_isEditor = isEditor;
			m_hasPassesFirstFade = isEditor;
			m_voiceIndex = 0;
			m_textTable = textTable;
			m_sequenceTable = sequenceTable;
			m_version = m_sequenceTable.GetVersion();
		}

		public List<ISequenceCommand> Convert()
		{
			if (m_isConverted)
			{
				return m_commandList;
			}
			if (!m_isEditor)
			{
				m_hasPassesFirstFade = false;
			}
			int count = m_sequenceTable.GetCount();
			m_commandList = new List<ISequenceCommand>(count);
			for (int i = 0; i < count; i++)
			{
				ISequenceCommand sequenceCommand = ConvertCommand(m_sequenceTable.GetData(i));
				if (sequenceCommand != null)
				{
					if (sequenceCommand.IsDeprecated)
					{
						UnityEngine.Debug.LogWarningFormat("Command '{0}' is Deprecated (index: {1}). Please remove that command.", sequenceCommand.Type, i);
					}
					m_commandList.Add(sequenceCommand);
					_subjectLoadCommand.OnNext(sequenceCommand);
				}
			}
			CheckUnusedTexts();
			_subjectLoadCommand.OnCompleted();
			m_isConverted = true;
			return m_commandList;
		}

		private ISequenceCommand ConvertCommand(SequenceData.Param data)
		{
			switch (data.CommandType)
			{
			case ISequenceCommand.Types.Text:
				return CreateTextCommand(data);
			case ISequenceCommand.Types.CharaOn:
				return CreateCharaOnCommand(data);
			case ISequenceCommand.Types.CharaOff:
				return CreateCharaOffCommand(data);
			case ISequenceCommand.Types.CharaPosition:
				return CreateCharaPositionCommand(data);
			case ISequenceCommand.Types.CharaRotate:
				return CreateCharaRotationCommand(data);
			case ISequenceCommand.Types.CharaMotion:
				return CreateCharaMotionCommand(data);
			case ISequenceCommand.Types.CharaFace:
				return CreateCharaFacialCommand(data);
			case ISequenceCommand.Types.CharaLootAt:
				return CreateCharaLookAtCommand(data);
			case ISequenceCommand.Types.PlayerPosition:
				return CreatePlayerPositionCommand(data);
			case ISequenceCommand.Types.PlayerRotation:
				return CreatePlayerRotationCommand(data);
			case ISequenceCommand.Types.Scene:
				return CreateChangeSceneCommand(data);
			case ISequenceCommand.Types.Sequence:
				return CreateChangeSequenceCommand(data);
			case ISequenceCommand.Types.FadeIn:
				return CreateFadeInCommand(data);
			case ISequenceCommand.Types.Wait:
				return CreateWaitTimeCommand(data);
			case ISequenceCommand.Types.WaitInput:
				return new CommandWaitInput();
			case ISequenceCommand.Types.ForcusUp:
				return CreateForcusUpCommand(data);
			case ISequenceCommand.Types.ForcusUpOff:
				return CreateForcusUpOffCommand(data);
			case ISequenceCommand.Types.ShakeWindow:
				return CreateShakeWindowCommand(data);
			case ISequenceCommand.Types.Emotion:
				return CreateEmotionCommand(data);
			case ISequenceCommand.Types.Props:
				return CreatePropsCommand(data);
			case ISequenceCommand.Types.PropsOff:
				return CreatePropsOffCommand(data);
			case ISequenceCommand.Types.PropsChara:
				return CreatePropsCharaCommand(data);
			case ISequenceCommand.Types.PropsCharaOff:
				return CreatePropsCharaOffCommand(data);
			case ISequenceCommand.Types.PlayBgm:
				return CreateBgmCommand(data);
			case ISequenceCommand.Types.StopBgm:
				return CreateBgmOffCommand(data);
			case ISequenceCommand.Types.PlaySE2D:
				return CreateSe2DCommand(data);
			case ISequenceCommand.Types.StopSE2D:
				return CreateSe2DOffCommand(data);
			case ISequenceCommand.Types.StopSE3D:
				return CreateSe3DOffCommand(data);
			case ISequenceCommand.Types.PlaySE3D:
				return CreateSe3DCommand(data);
			case ISequenceCommand.Types.PlayAmbient:
				return CreatePlayAmbientCommand(data);
			case ISequenceCommand.Types.StopAmbient:
				return CreateStopAmbientCommand(data);
			case ISequenceCommand.Types.Selection:
				return CreateSelectionCommand(data);
			case ISequenceCommand.Types.Environment:
				return null;
			case ISequenceCommand.Types.EndDemo:
				return new CommandEndDemo();
			case ISequenceCommand.Types.CharaChange:
				return CreateCharaChangeCommand(data);
			case ISequenceCommand.Types.FlashBackStart:
				return CreateFlashbackStartCommand(data);
			case ISequenceCommand.Types.FlashBackEnd:
				return CreateFlashbackEndCommand(data);
			case ISequenceCommand.Types.FlashBackChange:
				return CreateFlashbackChangeCommand(data);
			case ISequenceCommand.Types.ForcusUpChange:
				return CreateChangeForcusUpCommand(data);
			case ISequenceCommand.Types.FadeWithoutText:
				return CreateFadeWithoutTextCommand(data);
			case ISequenceCommand.Types.FadeWithoutTextEnd:
				return CreateFadeWithoutTextEndCommand(data);
			case ISequenceCommand.Types.CharaAttachPlayer:
				return CreateCharaAttachPlayerCommand(data);
			case ISequenceCommand.Types.CharaDetachPlayer:
				return CreateCharaDetachPlayerCommand(data);
			case ISequenceCommand.Types.BokeSphereStart:
				return CreateBokeSphereCommand(data);
			case ISequenceCommand.Types.BokeSphereEnd:
				return CreateBokeSphereEndCommand(data);
			case ISequenceCommand.Types.FixWindowStart:
				return CreateFixWindowCommand(data);
			case ISequenceCommand.Types.FixWindowEnd:
				return CreateFixWindowEndCommand(data);
			case ISequenceCommand.Types.SetPlayerChara:
				return CreatePlayerSetCharaCommand(data);
			case ISequenceCommand.Types.CharaCircularPosition:
				return CreateCharaCircularPositionCommand(data);
			case ISequenceCommand.Types.BgmChangeLayer:
				return CreateBgmChangeLayerCommand(data);
			case ISequenceCommand.Types.EnvrionmentBlendShape:
				return CreateEnvironmentBlendShapeCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsPosition:
				return CreateEnvironmentPropsPositionCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsRotation:
				return CreateEnvironmentPropsRotationCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsOn:
				return CreateEnvironmentPropsOnCommand(data);
			case ISequenceCommand.Types.EnvironmentPropsOff:
				return CreateEnvironmentPropsOffCommand(data);
			case ISequenceCommand.Types.WaitBgmBar:
				return CreateWaitBgmBarCommand(data);
			case ISequenceCommand.Types.LogicIfFlag:
				return CreateLogicIfFlagCommand(data);
			case ISequenceCommand.Types.LogicElse:
				return CreateLogicElseCommand(data);
			case ISequenceCommand.Types.LogicEndIf:
				return CreateLogicEndIfCommand(data);
			case ISequenceCommand.Types.SetGameFlag:
				return CreateSetGameFlagCommand(data);
			case ISequenceCommand.Types.WaitBgmEnd:
				return CreateWaitBgmEndCommand(data);
			case ISequenceCommand.Types.CharaRotateReletive:
				return CreateCharaRotationReletiveCommand(data);
			case ISequenceCommand.Types.CharaPositionReletive:
				return CreateCharaPositionReletiveCommand(data);
			case ISequenceCommand.Types.CharaSetMirrorMode:
				return CreateCharaSetMirrorModeCommand(data);
			case ISequenceCommand.Types.CameraClearColour:
				return CreateCameraClearColourCommand(data);
			case ISequenceCommand.Types.PlayBgmSimple:
				return CreateBgmSimpleCommand(data);
			case ISequenceCommand.Types.StopBgmSimple:
				return CreateBgmSimpleOffCommand(data);
			case ISequenceCommand.Types.BgmSimpleVolumeChange:
				return CreateBgmSimpleVolumeCommand(data);
			case ISequenceCommand.Types.SceneProp:
				return CreateScenePropCommand(data);
			case ISequenceCommand.Types.ScenePropAction:
				return CreateScenePropActionCommand(data);
			case ISequenceCommand.Types.EditorNote:
				return CreateEditorNoteCommand(data);
			case ISequenceCommand.Types.CharaTransform:
				return CreateCharaTransformCommand(data);
			case ISequenceCommand.Types.PlayerArmMotion:
				return CreatePlayerArmMotionCommand(data);
			case ISequenceCommand.Types.WaitSE:
				return CreateWaitSECommand(data);
			case ISequenceCommand.Types.ProhibitOpenMenu:
				return CreateProhibitOpenMenuCommand(data);
			case ISequenceCommand.Types.ProhibitMenuSelection:
				return CreateProhibitMenuSelectionCommand(data);
			case ISequenceCommand.Types.ProhibitMessageSound:
				return CreateProhibitMessageSoundCommand(data);
			case ISequenceCommand.Types.SceneToChapterStart:
				return CreateSceneToChapterStartCommand(data);
			case ISequenceCommand.Types.SceneToChapterEnd:
				return CreateSceneToChapterEndCommand(data);
			case ISequenceCommand.Types.EndInGame:
				return CreateEndInGameCommand(data);
			case ISequenceCommand.Types.MessageForceMode:
				return CreateMessageForceModeCommand(data);
			case ISequenceCommand.Types.SceneUnload:
				return CreateSceneUnloadCommand(data);
			case ISequenceCommand.Types.EnableTypingSound:
				return CreateEnableTypingSoundCommand(data);
			case ISequenceCommand.Types.MemoryCharaOn:
				return CreateMemoryCharaOnCommand(data);
			case ISequenceCommand.Types.MemoryCharaOff:
				return CreateMemoryCharaOffCommand(data);
			case ISequenceCommand.Types.MemoryCharaTransform:
				return CreateMemoryCharaTransformCommand(data);
			case ISequenceCommand.Types.MemoryStart:
				return CreateMemoryModeStartCommand(data);
			case ISequenceCommand.Types.MemoryEnd:
				return CreateMemoryModeEndCommand(data);
			case ISequenceCommand.Types.MemoryEmotion:
				return CreateMemoryEmotionCommand(data);
			case ISequenceCommand.Types.MemoryAmbient:
				return CreateMemoryAmbientCommand(data);
			case ISequenceCommand.Types.MemoryAmbientOff:
				return CreateMemoryAmbientOffCommand(data);
			case ISequenceCommand.Types.MemoryAmbientVolume:
				return CreateMemoryAmbientVolumeCommand(data);
			case ISequenceCommand.Types.PlayerAvaterTrack:
				return CreatePlayerAvaterTrackCommand(data);
			case ISequenceCommand.Types.SceneToOpening:
				return CreateSceneToOpeningCommand(data);
			case ISequenceCommand.Types.SceneToSpecial:
				return CreateSceneToSpecialCommand(data);
			case ISequenceCommand.Types.WaitTimeline:
				return CreateWaitTimelineCommand(data);
			case ISequenceCommand.Types.NoAnimationLimit:
				return CreateNoAnimationLimitCommand(data);
			case ISequenceCommand.Types.OutlineChange:
				return CreateCharaOutlineChangeCommand(data);
			case ISequenceCommand.Types.WindowThroughEffect:
				return CreateWindowThroughEffectCommand(data);
			case ISequenceCommand.Types.CpuGpuLevel:
				return CreateCpuGpuLevelCommand(data);
			case ISequenceCommand.Types.StartCutscene:
				return CreateStartCutsceneCommand(data);
			case ISequenceCommand.Types.BackgroundActive:
				return CreateBackgroundActiveCommand(data);
			case ISequenceCommand.Types.CharaStyleChange:
				return CreateCharaStyleChangeCommand(data);
			case ISequenceCommand.Types.AvaterVisible:
				return CreatePlayerAvaterVisibleCommand(data);
			case ISequenceCommand.Types.CommandAutoWaitOverride:
				return CreateAutoWaitOverrideCommand(data);
			case ISequenceCommand.Types.AvaterOutline:
				return CreateAvaterOutlineCommand(data);
			case ISequenceCommand.Types.CharaTexture:
				return CreateCharaTextureCommand(data);
			case ISequenceCommand.Types.PlayAreaBoundary:
				return CreatePlayAreaBoundaryCommand(data);
			case ISequenceCommand.Types.AvaterTexture:
				return CreateAvaterTextureCommand(data);
			case ISequenceCommand.Types.ScenePropOutline:
				return CreateScenePropOutlineCommand(data);
			case ISequenceCommand.Types.MenuFixMode:
				return CreateMenuFixModeCommand(data);
			case ISequenceCommand.Types.ProhibitHeightChange:
				return CreateProhibitHeightChangeCommand(data);
			default:
				UnityEngine.Debug.LogErrorFormat("OOPS: I couldn't convert command '{0}'!", data.CommandType);
				return null;
			}
		}

		private bool IntToBool(int value)
		{
			if (value != 0)
			{
				return true;
			}
			return false;
		}

		private CommandText CreateTextCommand(SequenceData.Param data)
		{
			int num = data.DataInt[1];
			ScenarioTableData.Param data2 = m_textTable.GetData(num);
			if (data2 == null)
			{
				UnityEngine.Debug.Log($"Missing scenario index: {num}");
				return null;
			}
			GameDefine.CharaID charaID = ((data2.Chara == 0) ? GameDefine.CharaID.BASE : ((GameDefine.CharaID)data2.Chara));
			int voiceIndex = -1;
			if (m_isEditor)
			{
				if (data2 != null)
				{
					charaID = GameDefine.GetCharaID(data2.Chara);
				}
				if (data.DataInt.Count > 2)
				{
					voiceIndex = data.DataInt[2];
				}
				else if (charaID != GameDefine.CharaID.BASE)
				{
					voiceIndex = m_voiceIndex++;
				}
			}
			else if (data.DataInt.Count > 2)
			{
				voiceIndex = data.DataInt[2];
			}
			string text = ((data2 == null) ? $"Missing scenario index: {num}" : GetMessageText(data2));
			bool is2DVoice = false;
			int num2 = 3;
			if (m_version > 4 && data.DataInt.Count > num2)
			{
				is2DVoice = IntToBool(data.DataInt[num2]);
			}
			return new CommandText(charaID, text, data.DataInt[1], data2.Voice, voiceIndex, is2DVoice);
		}

		private void CheckUnusedTexts()
		{
		}

		private void AddUnusedText(List<int> unusedList)
		{
			int count = unusedList.Count;
			for (int i = 0; i < count; i++)
			{
				ScenarioTableData.Param data = m_textTable.GetData(unusedList[i]);
				if (data != null)
				{
					GameDefine.CharaID chara = GameDefine.CharaID.BASE;
					if (data.Chara != 0 && data.Chara != 100)
					{
						chara = (GameDefine.CharaID)data.Chara;
					}
					CommandText commandText = new CommandText(chara, data.TextJp, unusedList[i], data.Voice);
					m_commandList.Add(commandText);
					_subjectLoadCommand.OnNext(commandText);
				}
			}
		}

		private string GetMessageText(ScenarioTableData.Param textData)
		{
			if (m_isEditor || SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				return textData.TextJp;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Chinese)
			{
				return textData.TextCh;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.German)
			{
				return textData.TextGe;
			}
			return textData.TextEg;
		}

		private CommandCharaOn CreateCharaOnCommand(SequenceData.Param data)
		{
			return new CommandCharaOn(data, m_version, m_hasPassesFirstFade);
		}

		private CommandCharaOff CreateCharaOffCommand(SequenceData.Param data)
		{
			return new CommandCharaOff(data, m_version, m_hasPassesFirstFade);
		}

		private List<GameDefine.CharaID> CreateCharaEnableListFromData(SequenceData.Param data, int startIndex)
		{
			List<GameDefine.CharaID> list = new List<GameDefine.CharaID>();
			int count = data.DataInt.Count;
			for (int i = startIndex; i < count; i++)
			{
				list.Add((GameDefine.CharaID)data.DataInt[i]);
			}
			return list;
		}

		private CommandCharaPosition CreateCharaPositionCommand(SequenceData.Param data)
		{
			bool isLockY = true;
			if (data.DataInt.Count > 3)
			{
				isLockY = IntToBool(data.DataInt[3]);
			}
			bool flag = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaPosition((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[1]), flag, isLockY);
		}

		private CommandCharaRotation CreateCharaRotationCommand(SequenceData.Param data)
		{
			bool flag = false;
			if (data.DataInt.Count > 2)
			{
				flag = IntToBool(data.DataInt[2]);
			}
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaRotation((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[1]), flag);
		}

		private CommandCharaMotion CreateCharaMotionCommand(SequenceData.Param data)
		{
			int num = 0;
			bool flag = false;
			if (data.DataInt.Count > 3)
			{
				flag = IntToBool(data.DataInt[3]);
			}
			bool flag2 = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
				flag2 = !flag2;
			}
			if (!m_hasPassesFirstFade)
			{
				flag2 = false;
			}
			return new CommandCharaMotion((GameDefine.CharaID)data.DataInt[num++], data.DataInt[num++], flag2, flag);
		}

		private CommandCharaFacial CreateCharaFacialCommand(SequenceData.Param data)
		{
			int num = 0;
			bool flag = false;
			if (data.DataInt.Count > 3)
			{
				flag = IntToBool(data.DataInt[3]);
			}
			int version = m_version;
			if (version == 0 || version == 1)
			{
				flag = !flag;
			}
			return new CommandCharaFacial((GameDefine.CharaID)data.DataInt[num++], data.DataInt[num++], IntToBool(data.DataInt[num++]), flag);
		}

		private CommandCharaLookAt CreateCharaLookAtCommand(SequenceData.Param data)
		{
			int num = 0;
			int count = data.DataInt.Count;
			if (count < 3)
			{
				return new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], (GameDefine.CharaID)data.DataInt[num++], isPlayAnimation: false, CommandCharaLookAt.SourceType.Chara);
			}
			bool flag = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			CommandCharaLookAt.SourceType sourceType = CommandCharaLookAt.SourceType.Chara;
			if (count >= 4)
			{
				sourceType = (CommandCharaLookAt.SourceType)data.DataInt[3];
			}
			return sourceType switch
			{
				CommandCharaLookAt.SourceType.Point => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], flag, new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), sourceType), 
				CommandCharaLookAt.SourceType.Prop => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], flag, (PropDefines.PropType)data.DataInt[4], data.DataInt[5], sourceType), 
				CommandCharaLookAt.SourceType.PropNode => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], flag, (PropDefines.PropType)data.DataInt[4], data.DataInt[5], data.DataInt[6], sourceType), 
				_ => new CommandCharaLookAt((GameDefine.CharaID)data.DataInt[num++], (GameDefine.CharaID)data.DataInt[num++], flag, sourceType), 
			};
		}

		private CommandPlayerPosition CreatePlayerPositionCommand(SequenceData.Param data)
		{
			return new CommandPlayerPosition(new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandPlayerRotation CreatePlayerRotationCommand(SequenceData.Param data)
		{
			return new CommandPlayerRotation(new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandChangeScene CreateChangeSceneCommand(SequenceData.Param data)
		{
			return new CommandChangeScene((SceneDefine)data.DataInt[0]);
		}

		private CommandChangeSequence CreateChangeSequenceCommand(SequenceData.Param data)
		{
			return new CommandChangeSequence(data.DataInt[0]);
		}

		private CommandFadeIn CreateFadeInCommand(SequenceData.Param data)
		{
			m_hasPassesFirstFade = true;
			bool isDeactivateOnEnd = false;
			if (data.DataInt.Count >= 1)
			{
				isDeactivateOnEnd = IntToBool(data.DataInt[0]);
			}
			return new CommandFadeIn(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), new Color(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6], data.DataFloat[7]), data.DataFloat[8], isDeactivateOnEnd);
		}

		private CommandWaitTime CreateWaitTimeCommand(SequenceData.Param data)
		{
			return new CommandWaitTime(data.DataFloat[0]);
		}

		private CommandForcusUpWindow CreateForcusUpCommand(SequenceData.Param data)
		{
			Vector3 scale = Vector3.one;
			if (m_version > 2)
			{
				int num = 4;
				scale = new Vector3(data.DataFloat[num++], data.DataFloat[num++], data.DataFloat[num++]);
			}
			ForcusUpWindowController.SourceType source = ForcusUpWindowController.SourceType.Chara;
			int propsID = -1;
			Vector3 zero = Vector3.zero;
			if (m_version > 3)
			{
				int num2 = 7;
				zero.x = data.DataFloat[num2++];
				zero.y = data.DataFloat[num2++];
				zero.z = data.DataFloat[num2++];
				num2 = 5;
				source = (ForcusUpWindowController.SourceType)data.DataInt[num2++];
				propsID = data.DataInt[num2++];
			}
			return new CommandForcusUpWindow(data.DataInt[0], data.DataInt[1], source, (ForcusUpWindow.FadeType)data.DataInt[2], (GameDefine.CharaID)data.DataInt[3], data.DataFloat[0], new Vector3(data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), scale, zero, (Ease)data.DataInt[4], propsID);
		}

		private CommandForcusUpOff CreateForcusUpOffCommand(SequenceData.Param data)
		{
			bool isSkip = false;
			if (data.DataInt.Count >= 3)
			{
				isSkip = IntToBool(data.DataInt[2]);
			}
			if (data.DataInt.Count >= 4)
			{
				return new CommandForcusUpOff(data.DataInt[0], (ForcusUpWindow.FadeType)data.DataInt[1], isSkip, (Ease)data.DataInt[3]);
			}
			return new CommandForcusUpOff(data.DataInt[0], (ForcusUpWindow.FadeType)data.DataInt[1], isSkip, Ease.InOutCubic);
		}

		private CommandShakeWindow CreateShakeWindowCommand(SequenceData.Param data)
		{
			return new CommandShakeWindow(data.DataFloat[0]);
		}

		private CommandEmotion CreateEmotionCommand(SequenceData.Param data)
		{
			if (data.DataFloat.Count <= 0)
			{
				return new CommandEmotion((GameDefine.CharaID)data.DataInt[0], (EmotionImage.Types)data.DataInt[1], Vector3Extension.Zero);
			}
			return new CommandEmotion((GameDefine.CharaID)data.DataInt[0], (EmotionImage.Types)data.DataInt[1], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandProps CreatePropsCommand(SequenceData.Param data)
		{
			return new CommandProps();
		}

		private CommandPropsOff CreatePropsOffCommand(SequenceData.Param data)
		{
			return new CommandPropsOff();
		}

		private CommandPropsChara CreatePropsCharaCommand(SequenceData.Param data)
		{
			return new CommandPropsChara();
		}

		private CommandPropsCharaOff CreatePropsCharaOffCommand(SequenceData.Param data)
		{
			return new CommandPropsCharaOff();
		}

		private CommandBgm CreateBgmCommand(SequenceData.Param data)
		{
			return new CommandBgm(data);
		}

		private CommandBgmOff CreateBgmOffCommand(SequenceData.Param data)
		{
			return new CommandBgmOff((BgmPlayer.StopMode)data.DataInt[0]);
		}

		private CommandSe2D CreateSe2DCommand(SequenceData.Param data)
		{
			return new CommandSe2D(data.DataInt[0], data.DataFloat[0], IntToBool(data.DataInt[1]));
		}

		private CommandSe2DOff CreateSe2DOffCommand(SequenceData.Param data)
		{
			return new CommandSe2DOff(data.DataInt[0]);
		}

		private CommandSe3D CreateSe3DCommand(SequenceData.Param data)
		{
			return new CommandSe3D(data);
		}

		private CommandSe3DOff CreateSe3DOffCommand(SequenceData.Param data)
		{
			return new CommandSe3DOff(data.DataInt[0]);
		}

		private CommandAmbient CreatePlayAmbientCommand(SequenceData.Param data)
		{
			return new CommandAmbient(data.DataInt[0], data.DataFloat[0], IntToBool(data.DataInt[1]));
		}

		private CommandAmbientOff CreateStopAmbientCommand(SequenceData.Param data)
		{
			return new CommandAmbientOff(data.DataInt[0]);
		}

		private CommandSelection CreateSelectionCommand(SequenceData.Param data)
		{
			m_hasPassesFirstFade = true;
			return new CommandSelection(data, m_version);
		}

		private CommandCharaChange CreateCharaChangeCommand(SequenceData.Param data)
		{
			return new CommandCharaChange((GameDefine.CharaID)data.DataInt[0], data.DataInt[1]);
		}

		private CommandFlashbackStart CreateFlashbackStartCommand(SequenceData.Param data)
		{
			return new CommandFlashbackStart(data);
		}

		private CommandFlashbackEnd CreateFlashbackEndCommand(SequenceData.Param data)
		{
			return new CommandFlashbackEnd();
		}

		private CommandFlashbackChange CreateFlashbackChangeCommand(SequenceData.Param data)
		{
			return new CommandFlashbackChange(data.DataInt[0]);
		}

		private CommandChangeForcusUp CreateChangeForcusUpCommand(SequenceData.Param data)
		{
			return new CommandChangeForcusUp(data.DataInt[0], data.DataInt[1], data.DataFloat[0]);
		}

		private CommandFadeWithoutText CreateFadeWithoutTextCommand(SequenceData.Param data)
		{
			m_hasPassesFirstFade = true;
			return new CommandFadeWithoutText(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), new Color(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6], data.DataFloat[7]), data.DataFloat[8]);
		}

		private CommandFadeWithoutTextEnd CreateFadeWithoutTextEndCommand(SequenceData.Param data)
		{
			return new CommandFadeWithoutTextEnd(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2], data.DataFloat[3]), new Color(data.DataFloat[4], data.DataFloat[5], data.DataFloat[6], data.DataFloat[7]), data.DataFloat[8]);
		}

		private CommandCharaAttachPlayer CreateCharaAttachPlayerCommand(SequenceData.Param data)
		{
			if (data.DataFloat.Count <= 0)
			{
				return new CommandCharaAttachPlayer((GameDefine.CharaID)data.DataInt[0]);
			}
			int flags = ((data.DataInt.Count > 1) ? data.DataInt[1] : 0);
			return new CommandCharaAttachPlayer((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), new Vector3(data.DataFloat[3], data.DataFloat[4], data.DataFloat[5]), flags);
		}

		private CommandCharaDetachPlayer CreateCharaDetachPlayerCommand(SequenceData.Param data)
		{
			return new CommandCharaDetachPlayer((GameDefine.CharaID)data.DataInt[0]);
		}

		private CommandBokeSphere CreateBokeSphereCommand(SequenceData.Param data)
		{
			return new CommandBokeSphere((CommandBokeSphere.Environment)data.DataInt[0], IntToBool(data.DataInt[1]), new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), data.DataFloat[3]);
		}

		private CommandBokeSphereEnd CreateBokeSphereEndCommand(SequenceData.Param data)
		{
			return new CommandBokeSphereEnd(data);
		}

		private CommandFixWindow CreateFixWindowCommand(SequenceData.Param data)
		{
			return new CommandFixWindow(data);
		}

		private CommandFixWindowEnd CreateFixWindowEndCommand(SequenceData.Param data)
		{
			return new CommandFixWindowEnd();
		}

		private CommandPlayerSetChara CreatePlayerSetCharaCommand(SequenceData.Param data)
		{
			if (data.DataInt.Count <= 1)
			{
				return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0]);
			}
			if (data.DataInt.Count <= 2)
			{
				return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0], IntToBool(data.DataInt[1]));
			}
			if (data.DataInt.Count <= 3)
			{
				return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0], IntToBool(data.DataInt[1]), data.DataInt[2]);
			}
			return new CommandPlayerSetChara((GameDefine.CharaID)data.DataInt[0], IntToBool(data.DataInt[1]), data.DataInt[2], IntToBool(data.DataInt[3]));
		}

		private CommandCharaCircularPosition CreateCharaCircularPositionCommand(SequenceData.Param data)
		{
			bool flag = IntToBool(data.DataInt[1]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaCircularPosition((GameDefine.CharaID)data.DataInt[0], data.DataFloat[0], data.DataFloat[1], flag);
		}

		private CommandBgmChangeLayer CreateBgmChangeLayerCommand(SequenceData.Param data)
		{
			return new CommandBgmChangeLayer((KainePlayer.Layers)data.DataInt[0]);
		}

		private CommandEnvironmentBlendShape CreateEnvironmentBlendShapeCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentBlendShape(data.DataInt[0], data.DataFloat[0]);
		}

		private CommandEnvironmentPropsPosition CreateEnvironmentPropsPositionCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsPosition(data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandEnvironmentPropsRotation CreateEnvironmentPropsRotationCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsRotation(data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandEnvironmentPropsOn CreateEnvironmentPropsOnCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsOn(data.DataInt[0], IntToBool(data.DataInt[1]));
		}

		private CommandEnvironmentPropsOff CreateEnvironmentPropsOffCommand(SequenceData.Param data)
		{
			return new CommandEnvironmentPropsOff(data.DataInt[0]);
		}

		private CommandWaitBgmBar CreateWaitBgmBarCommand(SequenceData.Param data)
		{
			return new CommandWaitBgmBar(data.DataInt[0]);
		}

		private CommandLogicIfFlag CreateLogicIfFlagCommand(SequenceData.Param data)
		{
			return new CommandLogicIfFlag(data);
		}

		private CommandLogicElse CreateLogicElseCommand(SequenceData.Param data)
		{
			return new CommandLogicElse(data);
		}

		private CommandLogicEndIf CreateLogicEndIfCommand(SequenceData.Param data)
		{
			return new CommandLogicEndIf(data);
		}

		private CommandSetGameFlag CreateSetGameFlagCommand(SequenceData.Param data)
		{
			return new CommandSetGameFlag(data);
		}

		private CommandWaitBgmEnd CreateWaitBgmEndCommand(SequenceData.Param data)
		{
			return new CommandWaitBgmEnd();
		}

		private CommandCharaRotationReletive CreateCharaRotationReletiveCommand(SequenceData.Param data)
		{
			bool flag = IntToBool(data.DataInt[2]);
			if (m_version == 0)
			{
				flag = !flag;
			}
			if (!m_hasPassesFirstFade)
			{
				flag = false;
			}
			return new CommandCharaRotationReletive((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[1]), flag);
		}

		private CommandCharaPositionReletive CreateCharaPositionReletiveCommand(SequenceData.Param data)
		{
			return new CommandCharaPositionReletive((GameDefine.CharaID)data.DataInt[0], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]), IntToBool(data.DataInt[2]));
		}

		private CommandCharaSetMirrorMode CreateCharaSetMirrorModeCommand(SequenceData.Param data)
		{
			if (data.DataInt.Count <= 2)
			{
				return new CommandCharaSetMirrorMode((GameDefine.CharaID)data.DataInt[0], data.DataInt[1]);
			}
			return new CommandCharaSetMirrorMode((GameDefine.CharaID)data.DataInt[0], data.DataInt[1], IntToBool(data.DataInt[2]));
		}

		private CommandClearColour CreateCameraClearColourCommand(SequenceData.Param data)
		{
			return new CommandClearColour(new Color(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandBgmSimple CreateBgmSimpleCommand(SequenceData.Param data)
		{
			return new CommandBgmSimple(data.DataInt[0], data.DataFloat[0], data.DataFloat[1]);
		}

		private CommandBgmSimpleOff CreateBgmSimpleOffCommand(SequenceData.Param data)
		{
			return new CommandBgmSimpleOff(data.DataFloat[0]);
		}

		private CommandBgmSimpleVolume CreateBgmSimpleVolumeCommand(SequenceData.Param data)
		{
			return new CommandBgmSimpleVolume(data.DataFloat[0], data.DataFloat[1]);
		}

		private CommandSceneProp CreateScenePropCommand(SequenceData.Param data)
		{
			return new CommandSceneProp(data);
		}

		private CommandScenePropAction CreateScenePropActionCommand(SequenceData.Param data)
		{
			return new CommandScenePropAction(data);
		}

		private CommandEditorNote CreateEditorNoteCommand(SequenceData.Param data)
		{
			if (!IsDebugPlay && !m_isEditor)
			{
				return null;
			}
			return new CommandEditorNote(data.DataString[0]);
		}

		private CommandCharaTransform CreateCharaTransformCommand(SequenceData.Param data)
		{
			int index = 0;
			int intIndex = 0;
			int chara = data.DataInt[intIndex++];
			bool isMove = IntToBool(data.DataInt[intIndex++]);
			bool isRotate = IntToBool(data.DataInt[intIndex++]);
			bool isMotion = IntToBool(data.DataInt[intIndex++]);
			bool isFacial = IntToBool(data.DataInt[intIndex++]);
			bool isFade = IntToBool(data.DataInt[intIndex++]);
			if (!m_hasPassesFirstFade)
			{
				isFade = false;
			}
			CommandCharaTransform commandCharaTransform = new CommandCharaTransform((GameDefine.CharaID)chara, isMove, isRotate, isMotion, isFacial, isFade);
			LoadPosition(data, commandCharaTransform, ref intIndex, ref index);
			LoadRotation(data, commandCharaTransform, ref intIndex, ref index);
			LoadMotion(data, commandCharaTransform, ref intIndex, ref index);
			LoadFacial(data, commandCharaTransform, ref intIndex, ref index);
			return commandCharaTransform;
		}

		private void LoadPosition(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsMove)
			{
				command.MoveMode = (CommandCharaTransform.MoveType)data.DataInt[intIndex++];
				if (command.MoveMode == CommandCharaTransform.MoveType.Radius)
				{
					command.Angle = data.DataFloat[index++];
					command.Radius = data.DataFloat[index++];
				}
				else
				{
					command.Position = new Vector3(data.DataFloat[index++], data.DataFloat[index++], data.DataFloat[index++]);
					command.IsLockY = IntToBool(data.DataInt[intIndex++]);
				}
			}
		}

		private void LoadRotation(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsRotate)
			{
				command.RotationMode = (CommandCharaTransform.RotationType)data.DataInt[intIndex++];
				command.Rotation = new Vector3(data.DataFloat[index++], data.DataFloat[index++], data.DataFloat[index++]);
			}
		}

		private void LoadMotion(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsMotion)
			{
				command.Motion = data.DataInt[intIndex++];
				command.IsPlayAnimationMotion = IntToBool(data.DataInt[intIndex++]);
			}
		}

		private void LoadFacial(SequenceData.Param data, CommandCharaTransform command, ref int intIndex, ref int index)
		{
			if (command.IsFacial)
			{
				command.Facial = data.DataInt[intIndex++];
				command.IsPlayAnimationFace = IntToBool(data.DataInt[intIndex++]);
			}
		}

		private CommandPlayerArmMotion CreatePlayerArmMotionCommand(SequenceData.Param data)
		{
			return new CommandPlayerArmMotion(data.DataInt[0], IntToBool(data.DataInt[1]), IntToBool(data.DataInt[2]));
		}

		private CommandWaitSE CreateWaitSECommand(SequenceData.Param data)
		{
			return new CommandWaitSE();
		}

		private CommandProhibitOpenMenu CreateProhibitOpenMenuCommand(SequenceData.Param data)
		{
			return new CommandProhibitOpenMenu(data);
		}

		private CommandProhibitMenuSelection CreateProhibitMenuSelectionCommand(SequenceData.Param data)
		{
			return new CommandProhibitMenuSelection(data);
		}

		private CommandProhibitMessageSound CreateProhibitMessageSoundCommand(SequenceData.Param data)
		{
			return new CommandProhibitMessageSound(data);
		}

		private CommandSceneToChapterStart CreateSceneToChapterStartCommand(SequenceData.Param data)
		{
			return new CommandSceneToChapterStart(data, m_version);
		}

		private CommandSceneToChapterEnd CreateSceneToChapterEndCommand(SequenceData.Param data)
		{
			return new CommandSceneToChapterEnd(data, m_version);
		}

		private CommandEndInGame CreateEndInGameCommand(SequenceData.Param data)
		{
			return new CommandEndInGame(data);
		}

		private CommandMessageForceMode CreateMessageForceModeCommand(SequenceData.Param data)
		{
			return new CommandMessageForceMode(data);
		}

		private CommandSceneUnload CreateSceneUnloadCommand(SequenceData.Param data)
		{
			return new CommandSceneUnload();
		}

		private CommandMemoryCharaOn CreateMemoryCharaOnCommand(SequenceData.Param data)
		{
			return new CommandMemoryCharaOn(data, m_version, m_hasPassesFirstFade);
		}

		private CommandEnableTypingSound CreateEnableTypingSoundCommand(SequenceData.Param data)
		{
			return new CommandEnableTypingSound(data);
		}

		private CommandMemoryCharaOff CreateMemoryCharaOffCommand(SequenceData.Param data)
		{
			return new CommandMemoryCharaOff(data, m_version, m_hasPassesFirstFade);
		}

		private CommandMemoryCharaTransform CreateMemoryCharaTransformCommand(SequenceData.Param data)
		{
			return new CommandMemoryCharaTransform(data, m_version, m_hasPassesFirstFade);
		}

		private CommandMemoryModeStart CreateMemoryModeStartCommand(SequenceData.Param data)
		{
			return new CommandMemoryModeStart(data, m_version);
		}

		private CommandMemoryModeEnd CreateMemoryModeEndCommand(SequenceData.Param data)
		{
			return new CommandMemoryModeEnd(data, m_version);
		}

		private CommandMemoryEmotion CreateMemoryEmotionCommand(SequenceData.Param data)
		{
			return new CommandMemoryEmotion((GameDefine.CharaID)data.DataInt[0], (EmotionImage.Types)data.DataInt[1], new Vector3(data.DataFloat[0], data.DataFloat[1], data.DataFloat[2]));
		}

		private CommandMemoryAmbient CreateMemoryAmbientCommand(SequenceData.Param data)
		{
			return new CommandMemoryAmbient(data.DataInt[0], data.DataFloat[0], data.DataFloat[1]);
		}

		private CommandMemoryAmbientOff CreateMemoryAmbientOffCommand(SequenceData.Param data)
		{
			return new CommandMemoryAmbientOff(data, m_version);
		}

		private CommandMemoryAmbientVolume CreateMemoryAmbientVolumeCommand(SequenceData.Param data)
		{
			return new CommandMemoryAmbientVolume(data, m_version);
		}

		private CommandPlayerAvaterTrack CreatePlayerAvaterTrackCommand(SequenceData.Param data)
		{
			return new CommandPlayerAvaterTrack(data, m_version);
		}

		private CommandSceneToOpening CreateSceneToOpeningCommand(SequenceData.Param data)
		{
			return new CommandSceneToOpening(data, m_version);
		}

		private CommandSceneToSpecial CreateSceneToSpecialCommand(SequenceData.Param data)
		{
			return new CommandSceneToSpecial(data, m_version);
		}

		private CommandWaitTimeline CreateWaitTimelineCommand(SequenceData.Param data)
		{
			return new CommandWaitTimeline(data, m_version);
		}

		private CommandNoAnimationLimit CreateNoAnimationLimitCommand(SequenceData.Param data)
		{
			return new CommandNoAnimationLimit(data, m_version);
		}

		private CommandCharaOutlineChange CreateCharaOutlineChangeCommand(SequenceData.Param data)
		{
			return new CommandCharaOutlineChange(data, m_version);
		}

		private CommandWindowThroughEffect CreateWindowThroughEffectCommand(SequenceData.Param data)
		{
			return new CommandWindowThroughEffect(data, m_version);
		}

		private CommandCpuGpuLevel CreateCpuGpuLevelCommand(SequenceData.Param data)
		{
			return new CommandCpuGpuLevel(data, m_version);
		}

		private CommandStartCutscene CreateStartCutsceneCommand(SequenceData.Param data)
		{
			return new CommandStartCutscene(data, m_version);
		}

		private CommandBackgroundActive CreateBackgroundActiveCommand(SequenceData.Param data)
		{
			return new CommandBackgroundActive(data, m_version);
		}

		private CommandCharaStyleChange CreateCharaStyleChangeCommand(SequenceData.Param data)
		{
			return new CommandCharaStyleChange(data, m_version);
		}

		private CommandPlayerAvaterVisible CreatePlayerAvaterVisibleCommand(SequenceData.Param data)
		{
			return new CommandPlayerAvaterVisible(data, m_version);
		}

		private CommandAutoWaitOverride CreateAutoWaitOverrideCommand(SequenceData.Param data)
		{
			return new CommandAutoWaitOverride(data, m_version);
		}

		private CommandAvaterOutline CreateAvaterOutlineCommand(SequenceData.Param data)
		{
			return new CommandAvaterOutline(data, m_version);
		}

		private CommandCharaTexture CreateCharaTextureCommand(SequenceData.Param data)
		{
			return new CommandCharaTexture(data, m_version);
		}

		private CommandPlayAreaBoundary CreatePlayAreaBoundaryCommand(SequenceData.Param data)
		{
			return new CommandPlayAreaBoundary(data, m_version);
		}

		private CommandAvaterTexture CreateAvaterTextureCommand(SequenceData.Param data)
		{
			return new CommandAvaterTexture(data, m_version);
		}

		private CommandScenePropOutline CreateScenePropOutlineCommand(SequenceData.Param data)
		{
			return new CommandScenePropOutline(data, m_version);
		}

		private CommandMenuFixMode CreateMenuFixModeCommand(SequenceData.Param data)
		{
			return new CommandMenuFixMode(data, m_version);
		}

		private CommandProhibitHeightChange CreateProhibitHeightChangeCommand(SequenceData.Param data)
		{
			return new CommandProhibitHeightChange(data);
		}
	}
	public class SequencePreSetupper
	{
		private TimelineDataReader m_dataReader;

		public SequencePreSetupper(TimelineDataReader reader)
		{
			m_dataReader = reader;
		}

		public void PreloadAudioData()
		{
			List<CommandSe2D> seCommandList = m_dataReader.SeCommandList;
			int count = seCommandList.Count;
			for (int i = 0; i < count; i++)
			{
				if (!(seCommandList[i].Clip != null))
				{
					seCommandList[i].Clip = SoundManager.SE.FindClip(seCommandList[i].ID);
				}
			}
		}
	}
	public static class SpecialSceneHelper
	{
		public static void EndSpecialScene()
		{
			if (!SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				SingletonMonoBehaviour<MasterManager>.Instance.ExitInGame();
			}
			else
			{
				InGameManager.Timeline.EndSpecialScene();
			}
		}
	}
	public class TimelineDataReader
	{
		private const int _START_INDEX = -1;

		private SequenceTable m_sequenceTable;

		private ScenarioTextTable m_scenarioTextTable;

		private List<ISequenceCommand> m_commandList;

		private List<CommandText> m_textMessageList = new List<CommandText>();

		private Dictionary<ISequenceCommand.PreloadTypes, List<int>> m_generalPreloadList;

		private Dictionary<ISequenceCommand.PreloadTypes, List<ISoundCommand>> m_soundPreloadList;

		private GameDefine.CharaID m_playerChara = GameDefine.CharaID.BASE;

		private List<CommandSe2D> m_seCommandList;

		private ISoundCommand m_firstBgm;

		public int ScenarioID { get; private set; }

		public int CurrentIndex { get; private set; }

		public bool IsInitialized { get; set; }

		public bool HasMemoryMode { get; private set; }

		public ISequenceCommand CurrentCommand => m_commandList[CurrentIndex];

		public List<ISequenceCommand> CommandList => m_commandList;

		public List<CommandText> TextMessageList => m_textMessageList;

		public List<CommandSe2D> SeCommandList => m_seCommandList;

		public List<GameDefine.CharaID> InitialTalkChara { get; private set; }

		public ISoundCommand FirstBgmCommand => m_firstBgm;

		public bool IsOverflowed => CurrentIndex >= m_commandList.Count;

		public GameDefine.CharaID PlayerChara => m_playerChara;

		public TimelineDataReader()
		{
			IsInitialized = false;
			HasMemoryMode = false;
			m_firstBgm = null;
			m_scenarioTextTable = new ScenarioTextTable();
			m_sequenceTable = new SequenceTable();
			InitialTalkChara = new List<GameDefine.CharaID>();
			m_generalPreloadList = new Dictionary<ISequenceCommand.PreloadTypes, List<int>>();
			m_soundPreloadList = new Dictionary<ISequenceCommand.PreloadTypes, List<ISoundCommand>>();
			m_seCommandList = new List<CommandSe2D>();
			ResetCurrentIndex();
		}

		public void ResetCurrentIndex()
		{
			CurrentIndex = -1;
		}

		public void Clear()
		{
			HasMemoryMode = false;
			m_firstBgm = null;
			m_scenarioTextTable.Clear();
			m_sequenceTable.Clear();
			if (m_commandList != null)
			{
				m_commandList.Clear();
			}
			if (m_textMessageList != null)
			{
				m_textMessageList.Clear();
			}
			if (m_seCommandList != null)
			{
				m_seCommandList.Clear();
			}
			InitialTalkChara.Clear();
			m_generalPreloadList.Clear();
			m_soundPreloadList.Clear();
			ResetCurrentIndex();
		}

		public void IncrementIndex()
		{
			CurrentIndex++;
		}

		public void LoadScenrario(int id)
		{
			Clear();
			ScenarioID = id;
			m_scenarioTextTable.Load(id);
			m_sequenceTable.Load(id);
			if (!m_scenarioTextTable.isValid)
			{
				throw new NotFoundScenarioException(id);
			}
			if (!m_sequenceTable.isValid)
			{
				throw new NotFoundSequenceException(id);
			}
			SequenceDataConverter sequenceDataConverter = new SequenceDataConverter(m_scenarioTextTable, m_sequenceTable);
			IObservable<CommandText> source = sequenceDataConverter.OnLoadCommand.OfType<ISequenceCommand, CommandText>().Share();
			source.Where((CommandText command) => GetIsNeedToAddInitialTalk(command)).Take(2).Subscribe(delegate(CommandText command)
			{
				AddTalkCharaList(command);
			});
			source.Subscribe(delegate(CommandText command)
			{
				m_textMessageList.Add(command);
			});
			sequenceDataConverter.OnLoadCommand.Where((ISequenceCommand command) => command.IsNeedPreload).Subscribe(delegate(ISequenceCommand command)
			{
				OnLoadPreloadCommand(command);
			});
			sequenceDataConverter.OnLoadCommand.Where((ISequenceCommand command) => command.Type == ISequenceCommand.Types.SetPlayerChara).Take(1).Subscribe(delegate(ISequenceCommand command)
			{
				OnLoadFirstPlayerChara(command);
			});
			try
			{
				m_commandList = sequenceDataConverter.Convert();
			}
			catch (Exception)
			{
				throw;
			}
			IsInitialized = true;
			sequenceDataConverter = null;
			GC.Collect();
		}

		private void OnLoadPreloadCommand(ISequenceCommand command)
		{
			int preloadIndex = command.PreloadIndex;
			if (preloadIndex <= -1)
			{
				return;
			}
			switch (command.PreloadType)
			{
			case ISequenceCommand.PreloadTypes.BgmSimple:
			case ISequenceCommand.PreloadTypes.BgmAdvanced:
			case ISequenceCommand.PreloadTypes.SoundEffect:
			case ISequenceCommand.PreloadTypes.AmbientEffect:
			{
				if (!m_soundPreloadList.TryGetValue(command.PreloadType, out var value2))
				{
					value2 = new List<ISoundCommand>();
				}
				if (value2.Find((ISoundCommand scmd) => scmd.ID == preloadIndex) == null)
				{
					value2.Add(command as ISoundCommand);
					m_soundPreloadList[command.PreloadType] = value2;
				}
				if (command.PreloadType == ISequenceCommand.PreloadTypes.SoundEffect)
				{
					m_seCommandList.Add(command as CommandSe2D);
				}
				else if (command.PreloadType == ISequenceCommand.PreloadTypes.BgmAdvanced && m_firstBgm == null)
				{
					m_firstBgm = command as ISoundCommand;
				}
				break;
			}
			case ISequenceCommand.PreloadTypes.MemoryModeStart:
				HasMemoryMode = true;
				break;
			case ISequenceCommand.PreloadTypes.MemoryChara:
			{
				List<int> list = null;
				if (!m_generalPreloadList.TryGetValue(command.PreloadType, out list))
				{
					list = new List<int>();
				}
				(command as CommandMemoryCharaOn).CharaList.ForEach(delegate(GameDefine.CharaID id)
				{
					if (!list.Contains((int)id))
					{
						list.Add((int)id);
					}
				});
				m_generalPreloadList[command.PreloadType] = list;
				break;
			}
			default:
			{
				if (!m_generalPreloadList.TryGetValue(command.PreloadType, out var value))
				{
					value = new List<int>();
				}
				if (!value.Contains(preloadIndex))
				{
					value.Add(preloadIndex);
					m_generalPreloadList[command.PreloadType] = value;
				}
				break;
			}
			case ISequenceCommand.PreloadTypes.None:
				break;
			}
		}

		public List<int> GetGeneralPreloadList(ISequenceCommand.PreloadTypes type)
		{
			if (!m_generalPreloadList.TryGetValue(type, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadBgmAdvancedList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.BgmAdvanced, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadBgmSimpleList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.BgmSimple, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadSeList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.SoundEffect, out var value))
			{
				return null;
			}
			return value;
		}

		public List<ISoundCommand> GetPreloadAmbientList()
		{
			if (!m_soundPreloadList.TryGetValue(ISequenceCommand.PreloadTypes.AmbientEffect, out var value))
			{
				return null;
			}
			return value;
		}

		private void OnLoadFirstPlayerChara(ISequenceCommand command)
		{
			m_playerChara = (command as CommandPlayerSetChara).Chara;
		}

		private void AddTalkCharaList(CommandText command)
		{
			InitialTalkChara.Add(command.Chara);
		}

		private bool GetIsNeedToAddInitialTalk(CommandText command)
		{
			if (command.Chara == m_playerChara || command.Chara == GameDefine.CharaID.BASE || InitialTalkChara.Contains(command.Chara))
			{
				return false;
			}
			return true;
		}
	}
	public class TimelinePlayer : UpdateableComponent
	{
		public enum WaitMode
		{
			None,
			Infinity,
			Time,
			Loading,
			AfterLoad,
			HardSkip,
			SpecialScene,
			Emergency,
			Exit
		}

		private const SceneDefine INITIAL_SCENE = SceneDefine.AdvBoot;

		private WaitMode m_wait;

		[Header("External Components")]
		[SerializeField]
		private MessagePlayer m_messagePlayer;

		[SerializeField]
		private EmotionImageGenerator m_emotions;

		[SerializeField]
		private ForcusUpWindowController m_forcusUpWindow;

		[SerializeField]
		private FlashbackRoot m_flashbackRoot;

		[SerializeField]
		private SelectionController m_selectionController;

		private int _scenarioToLoad = -1;

		private SceneDefine m_initialScene;

		private TimelineDataReader m_dataReader;

		private SequencePreSetupper m_preSetupper;

		private AdvBackground m_background;

		private AdvCutScene m_cutScene;

		private TimelineInput m_playerInput;

		private MoverFadeSequencer m_moverFader;

		private BokeSphereManager m_bokeSphere;

		private ISequenceCommand m_waitingCommand;

		private LinkedList<BaseLogicCommand> m_commandLogicStacks = new LinkedList<BaseLogicCommand>();

		private ScenarioListData.Info _currentInfo;

		private Subject<int> _subjectScenarioCompleted = new Subject<int>();

		private Subject<TimelineDataReader> _subjectPreloadRequested = new Subject<TimelineDataReader>();

		private bool IsScenarioLoaded
		{
			get
			{
				if (m_dataReader != null)
				{
					return m_dataReader.IsInitialized;
				}
				return false;
			}
		}

		private bool IsScenarioReserved => _scenarioToLoad != -1;

		private bool IsWaitingCommand => m_waitingCommand != null;

		private bool IsWaitingSceneLoad { get; set; }

		private bool IsReservedAutoSave { get; set; }

		public IObservable<int> OnScenarioCompleted => _subjectScenarioCompleted;

		public IObservable<TimelineDataReader> PreloadRequestedObservable => _subjectPreloadRequested;

		public bool IsWaiting
		{
			get
			{
				if (IsScenarioLoaded && !IsScenarioReserved && m_wait == WaitMode.None && !IsWaitingSceneLoad)
				{
					return IsWaitingCommand;
				}
				return true;
			}
		}

		public bool IsScenarioSkippable
		{
			get
			{
				if (_currentInfo == null)
				{
					return false;
				}
				if (!SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingNormal))
				{
					return false;
				}
				switch (_currentInfo.SkipMode)
				{
				case ScenarioListData.SkipModes.Normal:
					return SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
				case ScenarioListData.SkipModes.Related:
					if (!SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID))
					{
						return SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(RelatedScenarioID);
					}
					return true;
				case ScenarioListData.SkipModes.Flag:
					if (!SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID))
					{
						return SingletonMonoBehaviour<GameData>.Instance.SystemData.GetFlag(_currentInfo.FlagToSkip);
					}
					return true;
				case ScenarioListData.SkipModes.Always:
					return true;
				default:
					return false;
				}
			}
		}

		public bool IsSkipAllowed => m_messagePlayer.GetCanToggleModeTo(MessagePlayer.PlayModes.Skip);

		public bool IsSkipMode => MessageProcessor.IsSkipMode;

		public bool IsHardSkip => m_wait == WaitMode.HardSkip;

		public bool IsMemoryMode => MemoryModeProcessor.IsPlaying;

		public bool HasPlayedFirstFade { get; set; }

		public Transform MainPositionTransform => MainPosition.MainTransform;

		public UIFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		public MoverFadeSequencer MoverFader => m_moverFader;

		public MessagePlayer MessageProcessor => m_messagePlayer;

		public EmotionImageGenerator EmotionProcessor => m_emotions;

		public ForcusUpWindowController FocusUpProcessor => m_forcusUpWindow;

		public FlashbackRoot FlashbackProcessor => m_flashbackRoot;

		public BokeSphereManager BokeSphereProcessor => m_bokeSphere;

		public SelectionController SelectionProcessor => m_selectionController;

		public AdvBackground CurrentBackground => m_background;

		public AdvCutScene CurrentCutScene => m_cutScene;

		public MemoryModeManager MemoryModeProcessor { get; private set; }

		public int LoadedScenarioID
		{
			get
			{
				if (!IsScenarioLoaded)
				{
					return -1;
				}
				return m_dataReader.ScenarioID;
			}
		}

		public int RelatedScenarioID
		{
			get
			{
				if (_currentInfo == null)
				{
					return -1;
				}
				return _currentInfo.RelatedSqid;
			}
		}

		public int SequenceCurrentIndex
		{
			get
			{
				if (!IsScenarioLoaded)
				{
					return -1;
				}
				return m_dataReader.CurrentIndex;
			}
		}

		public WaitMode LegacyWait => m_wait;

		public ISequenceCommand WaitingCommand => m_waitingCommand;

		protected override void Initialize()
		{
			GC.Collect();
			Resources.UnloadUnusedAssets();
			HasPlayedFirstFade = false;
			m_bokeSphere = new BokeSphereManager();
			m_wait = WaitMode.None;
			m_dataReader = new TimelineDataReader();
			m_preSetupper = new SequencePreSetupper(m_dataReader);
			m_playerInput = GetComponent<TimelineInput>();
			FindFlashback();
			m_moverFader = new MoverFadeSequencer(SingletonMonoBehaviour<FadeManager>.Instance.sceneFader, MainPosition.MainCamera, Color.black);
			MemoryModeProcessor = new MemoryModeManager(this);
			MakeSubscribes();
		}

		private void FindFlashback()
		{
			if (m_flashbackRoot == null)
			{
				m_flashbackRoot = UnityEngine.Object.FindObjectOfType<FlashbackRoot>();
			}
		}

		private void FindBackground()
		{
			m_background = UnityEngine.Object.FindObjectOfType<AdvBackground>();
			if (m_background != null)
			{
				SingletonMonoBehaviour<CharactersManager>.Instance.SetCharaTextures(m_background.CharaTextureSettings);
				MainPosition.Avater.AvaterResources.SetTextureSetting(m_background.CharaTextureSettings);
			}
		}

		private void StopBackgroundAmbient()
		{
			if (m_background != null && m_background.HasAudioSource)
			{
				m_background.Audio.Stop();
			}
		}

		private void FindCutScene()
		{
			m_cutScene = UnityEngine.Object.FindObjectOfType<AdvCutScene>();
			if (m_cutScene != null)
			{
				m_cutScene.ForwardCommandObservable.Where((Unit _) => IsWaitingCommand && m_waitingCommand.Type == ISequenceCommand.Types.WaitTimeline).Subscribe(delegate
				{
					ReleaseCommandWait();
				}).AddTo(base.gameObject);
			}
		}

		public void ForceFindCutScene()
		{
			FindCutScene();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeExitFade.Subscribe(delegate
			{
				m_wait = WaitMode.Emergency;
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				ClearScenarioRelations();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				ClearInGameObjects();
			}).AddTo(base.gameObject);
			m_messagePlayer.OnMessagePaged.Subscribe(delegate
			{
				ReleaseCommandWait();
			}).AddTo(base.gameObject);
			OnScenarioCompleted.Subscribe(delegate(int id)
			{
				SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag(id);
			}).AddTo(base.gameObject);
		}

		public override void OnUpdate(float delta)
		{
			if (m_wait == WaitMode.Loading)
			{
				UpdateLoading();
				return;
			}
			if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy || !SingletonMonoBehaviour<InGameManager>.Instance.IsReady || m_wait == WaitMode.Emergency)
			{
				UpdateEmergency();
				return;
			}
			try
			{
				m_playerInput.UpdateInputModeChange();
				if (IsWaitingCommand && m_waitingCommand.UpdateCommand(this, delta))
				{
					ReleaseCommandWait();
				}
				while (!IsWaiting)
				{
					NextPage();
				}
				if (IsScenarioReserved)
				{
					LoadReservedScenario();
				}
			}
			catch (Exception e)
			{
				EmergencyStop(e);
				throw;
			}
		}

		public void UpdateMessageInput()
		{
			m_playerInput.UpdateMessageInput();
		}

		public void UpdateWaitInput()
		{
			if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				ReleaseCommandWait();
			}
		}

		private void UpdateLoading()
		{
			if (!SingletonMonoBehaviour<SoundManager>.Instance.IsLoading && !m_forcusUpWindow.IsLoading && !m_flashbackRoot.IsLoading && !MemoryModeProcessor.IsLoading && !m_bokeSphere.IsLoading && !SingletonMonoBehaviour<TransitionManager>.Instance.IsSceneReservedAndLoading(m_initialScene))
			{
				if (IsWaitingSceneLoad)
				{
					ReleaseSceneWait();
				}
				else
				{
					OnScenarioLoadComplete();
				}
			}
		}

		private void UpdateEmergency()
		{
			if (IsScenarioReserved)
			{
				try
				{
					LoadReservedScenario();
				}
				catch (Exception e)
				{
					EmergencyStop(e);
					throw;
				}
			}
		}

		private void NextPage()
		{
			m_dataReader.IncrementIndex();
			CheckSkipMode();
			SetupCurrentPage();
		}

		private void CheckSkipMode()
		{
			if (IsSkipMode && SingletonMonoBehaviour<LocalData>.Instance.SkipDestinationIndex != -1 && m_dataReader.CurrentIndex >= SingletonMonoBehaviour<LocalData>.Instance.SkipDestinationIndex)
			{
				EndSkipMode();
			}
		}

		private void EndSkipMode()
		{
			SingletonMonoBehaviour<LocalData>.Instance.SkipDestinationIndex = -1;
			m_messagePlayer.ResetPlayMode();
		}

		public void SetupCurrentPage()
		{
			if (m_dataReader.IsOverflowed)
			{
				throw new SequenceOverflowException();
			}
			ISequenceCommand currentCommand = m_dataReader.CurrentCommand;
			if ((currentCommand.IsLogic || IsLastLogicTrue()) && !currentCommand.PlayCommand(this))
			{
				m_waitingCommand = currentCommand;
				m_waitingCommand.OnStart(this);
			}
		}

		public void StartHardSkip()
		{
			if (IsHardSkip)
			{
				return;
			}
			m_wait = WaitMode.HardSkip;
			float num = 0.5f;
			SingletonMonoBehaviour<SoundManager>.Instance.StopAll(BgmPlayer.StopMode.Fade, num);
			if (m_background != null && m_background.HasAudioSource)
			{
				m_background.Audio.StopWithFade(num);
			}
			AnalyticsUtility.SendSkipEvent();
			if (CurrentCutScene != null)
			{
				CurrentCutScene.DisposeTimeline();
			}
			Fader.Dispose();
			Fader.StartFade(ColorDefine.Black, num, isDeactivateOnEnd: false, delegate
			{
				Observable.NextFrame().Subscribe(delegate
				{
					HardSkipSequence();
				});
			});
		}

		private void HardSkipSequence()
		{
			while (IsHardSkip)
			{
				m_dataReader.IncrementIndex();
				if (m_dataReader.IsOverflowed)
				{
					throw new SequenceOverflowException();
				}
				ISequenceCommand currentCommand = m_dataReader.CurrentCommand;
				if ((currentCommand.IsLogic || (IsLastLogicTrue() && currentCommand.PlayInHardSkip)) && !currentCommand.PlayCommand(this))
				{
					m_waitingCommand = currentCommand;
					m_waitingCommand.OnStart(this);
					if (IsHardSkip)
					{
						ReleaseLegacyWait();
					}
				}
			}
		}

		public void ReleaseCommandWait()
		{
			if (m_waitingCommand != null)
			{
				ISequenceCommand waitingCommand = m_waitingCommand;
				m_waitingCommand = null;
				waitingCommand.OnEnd(this);
			}
		}

		public void ReleaseLegacyWait()
		{
			if (m_wait != 0)
			{
				m_wait = WaitMode.None;
			}
		}

		public void StartLegacyWait(float duration)
		{
			m_wait = WaitMode.Time;
			Observable.Timer(TimeSpan.FromSeconds(duration)).Subscribe(delegate
			{
				ReleaseLegacyWait();
			}).AddTo(base.gameObject);
		}

		public void StartInfinityWait()
		{
			m_wait = WaitMode.Infinity;
		}

		public void PrepareOnFirstFade()
		{
			if (!HasPlayedFirstFade)
			{
				SingletonMonoBehaviour<CharactersManager>.Instance.OnPrepareFistFade(m_dataReader.InitialTalkChara, IsMemoryMode);
				HasPlayedFirstFade = true;
			}
		}

		private void ClearLogicStack()
		{
			m_commandLogicStacks.Clear();
		}

		public void AddLogicStack(BaseLogicCommand command)
		{
			m_commandLogicStacks.AddLast(command);
		}

		public bool RemoveLastLogicStack()
		{
			if (m_commandLogicStacks.Last == null)
			{
				EmergencyStop("IFもELSEも無いのにENDIFを実行しました。");
				return true;
			}
			bool isLogicTrue = m_commandLogicStacks.Last.Value.IsLogicTrue;
			m_commandLogicStacks.RemoveLast();
			return isLogicTrue;
		}

		public bool IsLastLogicTrue()
		{
			if (m_commandLogicStacks.Last == null)
			{
				return true;
			}
			return m_commandLogicStacks.Last.Value.IsLogicTrue;
		}

		public void ReserveLoadScenerioWithComplete(int id)
		{
			CompleteScenario();
			ReserveLoadScenerio(id);
		}

		public void CompleteScenario()
		{
			_subjectScenarioCompleted.OnNext(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID);
			if (SingletonMonoBehaviour<LocalData>.Instance.IsOmitNextAutoSave)
			{
				SingletonMonoBehaviour<LocalData>.Instance.IsOmitNextAutoSave = false;
			}
			else
			{
				ReserveAutoSave();
			}
		}

		public void ReserveLoadScenerio(int id)
		{
			if (!IsScenarioReserved)
			{
				OnScenarioReserved();
			}
			SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID = id;
			_scenarioToLoad = id;
		}

		private void OnScenarioReserved()
		{
			SoundManager.Voice.StopCurrentVoice();
		}

		public void ResolveReservedAutoSave()
		{
			if (IsReservedAutoSave)
			{
				IsReservedAutoSave = false;
				SingletonMonoBehaviour<MasterManager>.Instance.AutoSave();
			}
		}

		private void LoadReservedScenario()
		{
			int nextSqid = _scenarioToLoad;
			_scenarioToLoad = -1;
			SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(this);
			Observable.NextFrame().Subscribe(delegate
			{
				try
				{
					ResolveReservedAutoSave();
					if (IsScenarioLoaded)
					{
						ClearScenarioRelations();
					}
					m_dataReader.LoadScenrario(nextSqid);
					if (!IsScenarioLoaded)
					{
						EmergencyStop($"シーケンス {nextSqid:00000} は不慮の事故により読み込めませんでした");
					}
					else
					{
						OnLoadScenario();
					}
				}
				catch (Exception e)
				{
					EmergencyStop(e);
					throw;
				}
			}).AddTo(base.gameObject);
		}

		private void ClearScenarioRelations()
		{
			ReleaseLegacyWait();
			ReleaseCommandWait();
			ClearLogicStack();
			if (m_background != null)
			{
				m_background.ClearScenarioRelations();
				m_background = null;
			}
			m_messagePlayer.ClearScenarioRelations();
			m_forcusUpWindow.CloseAll(isSkip: true);
			m_forcusUpWindow.Clear();
			m_flashbackRoot.OnScenarioEnd();
			m_bokeSphere.Clear();
			MemoryModeProcessor.OnScenarioEnd();
			SingletonMonoBehaviour<CharactersManager>.Instance.OnEndSequence();
			SingletonMonoBehaviour<MainPosition>.Instance.ClearScenarioRelations();
			SingletonMonoBehaviour<SoundManager>.Instance.StopSimpleBgm();
			SoundManager.SE.Stop();
			SoundManager.SE.StopAll3D();
			DisposeFades();
			HasPlayedFirstFade = false;
		}

		private void DisposeFades()
		{
			if (MoverFader.IsPlaying)
			{
				MoverFader.Reset();
			}
			if (SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.IsFading)
			{
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.Dispose();
			}
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ColorDefine.Black);
			SingletonMonoBehaviour<PlayAreaManager>.Instance.ResetBoundaryRange();
		}

		private void OnLoadScenario()
		{
			m_wait = WaitMode.Loading;
			_currentInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(m_dataReader.ScenarioID);
			ValidateMode();
			PreloadScenarioAssets();
			SingletonMonoBehaviour<CharactersManager>.Instance.SetAnimationLimitation(isLimit: false);
			if (IsSkipMode)
			{
				m_messagePlayer.ResetPlayMode();
			}
		}

		private void ValidateMode()
		{
			if (MemoryModeProcessor.IsPlaying && !m_dataReader.HasMemoryMode)
			{
				MemoryModeProcessor.End();
			}
		}

		private void PreloadScenarioAssets()
		{
			SoundManager.SE.LoadAllSE(m_dataReader.GetPreloadSeList());
			SoundManager.Voice.LoadAllVoices(m_dataReader.ScenarioID, m_dataReader.TextMessageList, m_dataReader.PlayerChara, m_dataReader.HasMemoryMode);
			SoundManager.Bgm.Load(m_dataReader.GetPreloadBgmAdvancedList(), m_dataReader.GetPreloadBgmSimpleList(), m_dataReader.FirstBgmCommand);
			m_forcusUpWindow.LoadAllTextures(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.FocusUp));
			m_flashbackRoot.LoadAllTextures(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.FlashBack));
			m_bokeSphere.LoadAll(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.BokeSphere));
			MemoryModeProcessor.Load(m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.MemoryChara));
			List<int> generalPreloadList = m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.UnityScene);
			m_initialScene = ((generalPreloadList != null && generalPreloadList.Count > 0) ? ((SceneDefine)generalPreloadList[0]) : SceneDefine.Blank);
			SingletonMonoBehaviour<TransitionManager>.Instance.ReserveSceneFromList(generalPreloadList);
			_subjectPreloadRequested.OnNext(m_dataReader);
		}

		private void PreloadSceneProps()
		{
			if (m_background != null)
			{
				m_background.ProcessPreloadProps(PropDefines.PropType.Static, m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.PropStatic));
				m_background.ProcessPreloadProps(PropDefines.PropType.Dynamic, m_dataReader.GetGeneralPreloadList(ISequenceCommand.PreloadTypes.PropDynamic));
			}
		}

		private void OnScenarioLoadComplete()
		{
			m_wait = WaitMode.AfterLoad;
			ResetPlayerPosition();
			SingletonMonoBehaviour<SoundManager>.Instance.PrepareFirstBgm();
			GC.Collect();
			Resources.UnloadUnusedAssets();
			(from _ in Observable.NextFrame()
				where m_wait == WaitMode.AfterLoad
				select _).Subscribe(delegate
			{
				ReleaseLegacyWait();
				SingletonMonoBehaviour<MasterManager>.Instance.RemoveBusy(this);
				SingletonMonoBehaviour<MainMenuManager>.Instance.ResetProhibitions();
				Fader.StartFade(Color.black, 0f, isDeactivateOnEnd: false);
			}).AddTo(base.gameObject);
		}

		private void ResetPlayerPosition()
		{
			MainPositionTransform.localPosition = GameDefine.PLAYER_DEFAULT_POSITION;
		}

		private void ReserveAutoSave()
		{
			IsReservedAutoSave = true;
		}

		public void ChangeScene(SceneDefine nextScene)
		{
			IsWaitingSceneLoad = true;
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(nextScene, OnSceneLoaded);
		}

		private void OnSceneLoaded()
		{
			FindBackground();
			FindCutScene();
			PreloadSceneProps();
			m_preSetupper.PreloadAudioData();
			if (!SingletonMonoBehaviour<SoundManager>.Instance.IsLoading)
			{
				ReleaseSceneWait();
			}
			else
			{
				m_wait = WaitMode.Loading;
			}
		}

		private void ReleaseSceneWait()
		{
			IsWaitingSceneLoad = false;
			ReleaseLegacyWait();
			ReleaseCommandWait();
			GC.Collect();
			Resources.UnloadUnusedAssets();
		}

		public void ChangeSceneToSpecial(SceneDefine scene)
		{
			IsWaitingSceneLoad = true;
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(scene, OnSpecialSceneLoaded);
		}

		private void OnSpecialSceneLoaded()
		{
			FindBackground();
			FindCutScene();
			m_wait = WaitMode.SpecialScene;
			IsWaitingSceneLoad = false;
			m_messagePlayer.ClearScenarioRelations();
			SingletonMonoBehaviour<CharactersManager>.Instance.OnEndSequence();
			DisposeFades();
		}

		public void EndSpecialScene()
		{
			if (m_wait == WaitMode.SpecialScene)
			{
				ReleaseCommandWait();
			}
		}

		public void QuitToTitle()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ExitInGame();
		}

		public void EndDemo()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ExitInGame(SceneDefine.EndProto);
		}

		public void QuitApplication()
		{
			UnityEngine.Application.Quit();
		}

		private void ClearInGameObjects()
		{
			if (m_wait != WaitMode.Exit)
			{
				m_wait = WaitMode.Exit;
				ClearScenarioRelations();
				SingletonMonoBehaviour<SoundManager>.Instance.ClearAllExceptBgm();
			}
		}

		private void EmergencyStop()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(new Color(1f, 0f, 0f, 0.5f));
			SingletonMonoBehaviour<SoundManager>.Instance.StopAll();
			m_wait = WaitMode.Emergency;
			_scenarioToLoad = -1;
		}

		public void EmergencyStop(string message)
		{
			EmergencyStop();
		}

		public void EmergencyStop(Exception e)
		{
			EmergencyStop($"{e.GetType()} が発生しました\n{e.Message}");
		}
	}
	public class MessageIndigaterComponents : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private SpriteRenderer _spriteAutoPlay;

		private bool _visibleAll = true;

		private bool _visibleAutoplay;

		public void ToggleEnabled(bool flag)
		{
			_visibleAll = flag;
			UpdateVisibility();
		}

		public void ToggleVisibleAutoPlay(bool flag)
		{
			_visibleAutoplay = flag;
			UpdateVisibility();
		}

		private void UpdateVisibility()
		{
			_spriteAutoPlay.enabled = _visibleAll && _visibleAutoplay;
		}
	}
	public class MessageWindow : MonoBehaviour
	{
		private const float MAX_TIME_THROUGH_EFFECT = 1f;

		public MessageWindowData data;

		[Header("Components")]
		[SerializeField]
		private Transform contentsTransform;

		[SerializeField]
		private MessageWindowText messageText;

		[SerializeField]
		private MessageWindowText nameText;

		[SerializeField]
		private MessageWindowWaitIcon waitIcon;

		[SerializeField]
		private MessageWindowWave[] waves;

		[SerializeField]
		private MessageWindowSkin skin;

		private MessageWindowController _parent;

		private Common.Timer _shakeTimer = new Common.Timer(0f);

		private bool _isVisible = true;

		private bool _isMonorogue;

		private bool _isThroughEffect;

		private float _timeSinceThrough;

		private bool isDataAvailable
		{
			get
			{
				if (data != null)
				{
					return data.enabled;
				}
				return false;
			}
		}

		private bool isShake => !_shakeTimer.IsTimeUp;

		private float windowGlobalAlpha
		{
			get
			{
				if (_parent == null)
				{
					return 1f;
				}
				return _parent.windowGlobalAlpha;
			}
		}

		private bool IsEmitSoundOnMessage
		{
			get
			{
				if (_parent != null)
				{
					return _parent.IsEmitSoundOnMessage;
				}
				return false;
			}
		}

		private AudioSource MessageAudioSource => _parent.MessageAudioSource;

		public bool IsSkipMode => _parent.IsSkipMode;

		public bool IsTextAllVisible => messageText.IsAllVisible;

		public MessageWindowText MessageText => messageText;

		public void SetController(MessageWindowController mane)
		{
			_parent = mane;
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			IObservable<Unit> source = SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => base.enabled).Share();
			source.Where((Unit _) => !_isMonorogue).Subscribe(delegate
			{
				UpdateWaves();
			}).AddTo(base.gameObject);
			source.Where((Unit _) => isShake).Subscribe(delegate
			{
				ProcessLegacyShake(Time.deltaTime);
			}).AddTo(base.gameObject);
			source.Where((Unit _) => _isThroughEffect).ThrottleFirst(TimeSpan.FromSeconds(0.05)).Subscribe(delegate
			{
				ProcessThroughShake(0.05f);
			})
				.AddTo(base.gameObject);
			source.Where((Unit _) => isDataAvailable).Subscribe(delegate
			{
				data.UpdateWindowPosition();
			}).AddTo(base.gameObject);
			source.Where((Unit _) => skin.IsNeedUpdate).Subscribe(delegate
			{
				skin.UpdateAll();
			}).AddTo(base.gameObject);
			messageText.OnBeforeFadeDelay.Subscribe(delegate
			{
				ToggleWaitingIcon(flag: false);
			}).AddTo(base.gameObject);
			messageText.OnStartFade.Where((Unit _) => data.IsMonologue && IsEmitSoundOnMessage).Subscribe(delegate
			{
				SoundManager.SE.PlaySystemLoop(SoundDefine.SystemSE.Message_TypeLoop, MessageAudioSource);
			}).AddTo(base.gameObject);
			messageText.OnEndFade.Subscribe(delegate
			{
				ToggleWaitingIcon(flag: true);
			}).AddTo(base.gameObject);
			messageText.OnEndFade.Where((Unit _) => data.IsMonologue && IsEmitSoundOnMessage).Subscribe(delegate
			{
				SoundManager.SE.StopSystemLoop(MessageAudioSource);
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_TypeEnd, MessageAudioSource);
			}).AddTo(base.gameObject);
		}

		private void OnEnable()
		{
			if (_isVisible)
			{
				contentsTransform.gameObject.SetActive(value: true);
			}
		}

		private void OnDisable()
		{
			contentsTransform.gameObject.SetActive(value: false);
		}

		public void InstantActivate()
		{
			SetVisible(flag: true);
		}

		private void SetVisible(bool flag)
		{
			if (_isVisible != flag)
			{
				_isVisible = flag;
				contentsTransform.gameObject.SetActive(_isVisible);
			}
		}

		public void SetMessageText(string text)
		{
			messageText.SetText(text);
			ToggleWaitingIcon(flag: false);
		}

		public void SetNameText(string text)
		{
			nameText.SetText(text);
		}

		public void SetLineLength(float numByJp)
		{
			messageText.SetLineLength(numByJp);
		}

		public void SetLineLengthDiff(float diffByJp)
		{
			messageText.SetLineLengthDiff(diffByJp);
		}

		public void SetTextSpeed(int toggleValue)
		{
			messageText.SetTextSpeed(toggleValue);
		}

		public void ToggleMonorogue(bool flag)
		{
			if (_isMonorogue != flag)
			{
				_isMonorogue = flag;
				if (_isMonorogue)
				{
					nameText.gameObject.SetActive(value: false);
					messageText.ToggleCentering(flag: true);
					skin.ToggleSkinVisible(flag: false);
				}
				else
				{
					nameText.gameObject.SetActive(value: true);
					messageText.ToggleCentering(flag: false);
					skin.ToggleSkinVisible(flag: true);
				}
			}
		}

		public void ToggleWaitingIcon(bool flag)
		{
			waitIcon.gameObject.SetActive(flag);
			if (flag)
			{
				waitIcon.SetPosition(messageText.LastCharacterPosition);
			}
		}

		private void OnEndMessageShowing()
		{
			ToggleWaitingIcon(flag: true);
		}

		private void UpdateWaves()
		{
			for (int i = 0; i < waves.Length; i++)
			{
				MessageWindowWave messageWindowWave = waves[i];
				messageWindowWave.UpdateScale();
				if (isDataAvailable)
				{
					messageWindowWave.WaveByTarget(data.GetWaveTarget());
				}
			}
		}

		public void SetMessageAlpga(float alpha)
		{
			if (alpha <= 0.01f)
			{
				SetVisible(flag: false);
				return;
			}
			float num = alpha * windowGlobalAlpha;
			SetVisible(flag: true);
			skin.SetMessageAlpha(num);
			waitIcon.SetAlpha(num);
		}

		public void SetSkinColor(Color skinColor)
		{
			skin.SetSkinColor(skinColor);
		}

		private void ProcessLegacyShake(float timeDelta)
		{
			Vector3 zero = Vector3.zero;
			Vector3 one = Vector3.one;
			_shakeTimer.Update(timeDelta);
			if (isShake)
			{
				zero.x = RandomPow4() * 0.2f;
				zero.y = RandomPow4() * 0.2f;
			}
			contentsTransform.localPosition = zero;
			contentsTransform.localScale = one;
		}

		private void ProcessThroughShake(float timeDelta)
		{
			Vector3 zero = Vector3.zero;
			Vector3 one = Vector3.one;
			if (Time.time > _timeSinceThrough + 1f)
			{
				_isThroughEffect = false;
			}
			else
			{
				float num = (Time.time - _timeSinceThrough) / 1f;
				float num2 = 1f - num;
				float num3 = 0.1f * num2;
				float num4 = 0.4f * num2;
				zero.x = RandomPow4() * num3;
				zero.y = RandomPow4() * num3;
				zero.z = -0.1f * num2 * num2;
				one += new Vector3(RandomPow4() * num4, RandomPow4() * num4, 0f);
				if (num <= 0.6f)
				{
					SetMessageAlpga(0.5f);
				}
				else
				{
					SetMessageAlpga(1f);
				}
			}
			contentsTransform.localPosition = zero;
			contentsTransform.localScale = one;
		}

		private float RandomPow4()
		{
			return (UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f)) / 4f - 0.5f;
		}

		public void StartShake(float time = 1f)
		{
			_shakeTimer.SetDuration(time);
			SingletonMonoBehaviour<GameInputManager>.Instance.Vibrate(VRDeviceDefine.HandType.Both, time, 1f);
		}

		public void StartShakeOnFade(float time = 1f)
		{
			messageText.OnStartFade.Merge(messageText.OnEndFade).Take(1).Subscribe(delegate
			{
				StartShake(time);
			})
				.AddTo(base.gameObject);
		}

		public void StartTextFade(float delay)
		{
			messageText.StartFade(delay);
		}

		public void InstantShow()
		{
			messageText.SetTextVisible(flag: true);
		}

		public void StartThroughEffect()
		{
			_isThroughEffect = true;
			_timeSinceThrough = Time.time;
		}
	}
	public class MessageWindowController : UpdateableComponent
	{
		private enum FadeMode
		{
			FadeOutEnd = -10,
			FadeOut = -1,
			NoFade = 0,
			FadeIn = 1
		}

		private const int NUM_RESERVE_WINDOWS = 3;

		private const int MAX_SHOW_WINDOWS = 2;

		private const float FADE_DURATION = 0.2f;

		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private MessageWindow prefabTextWindow;

		[Header("Components")]
		[SerializeField]
		private AudioSource messageAudioSource;

		[Header("Parameters")]
		[SerializeField]
		private float delayMessageShow = 0.25f;

		[SerializeField]
		private float heightConfigChange = 0.125f;

		[SerializeField]
		private float heightChangeTime = 0.2f;

		private Transform _thisTransform;

		private MessagePlayer _messagePlayer;

		private List<MessageWindow> m_objectWindows;

		private List<MessageWindow> m_usedWindows;

		private MessageWindow m_lastTextWindow;

		private FadeMode _fadeMode;

		private float _timeSinceFadeStart = -999f;

		private Vector3 _defaultPosition;

		private float _viewHeight;

		private bool m_isEmitSoundOnMessage;

		private Coroutine _crHeightChange;

		private ReactiveProperty<bool> _prohibitHeightChange = new ReactiveProperty<bool>(initialValue: false);

		private ConfigSave ConfigData => SingletonMonoBehaviour<GameData>.Instance.ConfigData;

		public float windowGlobalAlpha { get; private set; }

		public bool IsSkipMode
		{
			get
			{
				if (_messagePlayer != null)
				{
					return _messagePlayer.IsSkipMode;
				}
				return false;
			}
		}

		public bool IsEmitSoundOnMessage
		{
			get
			{
				return m_isEmitSoundOnMessage;
			}
			set
			{
				m_isEmitSoundOnMessage = value;
			}
		}

		public AudioSource MessageAudioSource => messageAudioSource;

		public bool IsAutoWaitOverrided => _messagePlayer.IsAutoWaitOverrided;

		public int MessageSpeedOverride => _messagePlayer.MessageSpeedOverride;

		public bool ProhibitHeightChange
		{
			get
			{
				return _prohibitHeightChange.Value;
			}
			set
			{
				_prohibitHeightChange.Value = value;
			}
		}

		public int CurrentMessageSpeed
		{
			get
			{
				if (!IsAutoWaitOverrided)
				{
					return ConfigData.MessageSpeed.Value;
				}
				return MessageSpeedOverride;
			}
		}

		protected override void Initialize()
		{
			_thisTransform = base.transform;
			m_objectWindows = new List<MessageWindow>();
			m_usedWindows = new List<MessageWindow>();
			windowGlobalAlpha = 1f;
			InitDefaultHeight();
			MakeWindowInstances();
			MakeSubscribes();
		}

		public void SetPlayer(MessagePlayer player)
		{
			_messagePlayer = player;
		}

		private void InitDefaultHeight()
		{
			_defaultPosition = _thisTransform.localPosition;
		}

		private void MakeWindowInstances()
		{
			if (m_objectWindows.Count < 3)
			{
				for (int i = m_objectWindows.Count; i < 3; i++)
				{
					MakwNewWindow();
				}
			}
		}

		private void MakeSubscribes()
		{
			_prohibitHeightChange.Subscribe(delegate(bool flag)
			{
				if (flag)
				{
					OnChangeMessageHeight(0);
				}
				else
				{
					OnChangeMessageHeight(ConfigData.MessageHeight.Value);
				}
			});
			_messagePlayer.RemoveInterfaceReactive.Where((bool flag) => flag).Subscribe(delegate
			{
				StartFadeOut();
			}).AddTo(base.gameObject);
			_messagePlayer.RemoveInterfaceReactive.Where((bool flag) => !flag).Subscribe(delegate
			{
				StartFadeIn();
			}).AddTo(base.gameObject);
			ConfigData.MessageHeight.Where((int _) => !_prohibitHeightChange.Value).Subscribe(delegate(int height)
			{
				OnChangeMessageHeight(height);
			}).AddTo(base.gameObject);
			ConfigData.MessageSpeed.Where((int _) => !IsAutoWaitOverrided).Subscribe(delegate(int height)
			{
				ChangeMessageSpeed(height);
			}).AddTo(base.gameObject);
		}

		private void OnChangeMessageHeight(int height)
		{
			if (_crHeightChange != null)
			{
				StopCoroutine(_crHeightChange);
				_crHeightChange = null;
			}
			_crHeightChange = StartCoroutine(ProcessHeightAnimation(_viewHeight, height));
		}

		private IEnumerator ProcessHeightAnimation(float from, float to)
		{
			Tweener<float> tweener = new Tweener<float>(Easing.EaseOutCubic);
			tweener.Start(from, to, heightChangeTime);
			while (tweener.IsActive)
			{
				yield return new WaitForEndOfFrame();
				tweener.Update(Time.deltaTime);
				SetWindowPosition(tweener.CurrentValue);
			}
		}

		private void SetWindowPosition(float height)
		{
			_viewHeight = height;
			_thisTransform.localPosition = _defaultPosition + new Vector3(0f, heightConfigChange * _viewHeight, 0f);
		}

		private void ChangeMessageSpeed(int speed)
		{
			if (m_lastTextWindow != null)
			{
				m_lastTextWindow.SetTextSpeed(speed);
				m_lastTextWindow.StartTextFade(0f);
			}
		}

		public override void OnUpdate(float delta)
		{
			UpdateFade();
		}

		private void UpdateFade()
		{
			if (_fadeMode == FadeMode.NoFade)
			{
				return;
			}
			float num = Time.time - _timeSinceFadeStart;
			if (num >= 0.2f)
			{
				StopFade();
				return;
			}
			float num2 = num / 0.2f;
			switch (_fadeMode)
			{
			case FadeMode.FadeIn:
				windowGlobalAlpha = num2;
				break;
			case FadeMode.FadeOut:
				windowGlobalAlpha = 1f - num2;
				break;
			}
		}

		private MessageWindow MakwNewWindow()
		{
			MessageWindow messageWindow = UnityEngine.Object.Instantiate(prefabTextWindow, _thisTransform);
			messageWindow.enabled = false;
			messageWindow.SetController(this);
			m_objectWindows.Add(messageWindow);
			return messageWindow;
		}

		private MessageWindow FindEmptyWindow()
		{
			for (int i = 0; i < m_objectWindows.Count; i++)
			{
				MessageWindow messageWindow = m_objectWindows[i];
				if (!messageWindow.enabled)
				{
					return messageWindow;
				}
			}
			return MakwNewWindow();
		}

		private void PageNextWindow()
		{
			for (int i = 0; i < m_usedWindows.Count; i++)
			{
				MessageWindow messageWindow = m_usedWindows[i];
				MessageWindowData data = messageWindow.data;
				int num = data.GetOrder() + 1;
				if (num > 3)
				{
					messageWindow.enabled = false;
					m_usedWindows.RemoveAt(i);
					i--;
				}
				else
				{
					data.SetOrder(num);
				}
			}
		}

		private void CreateNewWindow(CommandText data)
		{
			MessageWindow messageWindow = FindEmptyWindow();
			MessageWindowData data2 = messageWindow.data;
			data2.InitWindowByData(data);
			messageWindow.SetTextSpeed(CurrentMessageSpeed);
			if (IsSkipMode)
			{
				data2.SetPositionToOrder(1);
				data2.SetOrder(1);
				data2.PlayVoice();
				messageWindow.InstantShow();
				messageWindow.ToggleWaitingIcon(flag: true);
			}
			else
			{
				data2.SetPositionToOrder(0);
				messageWindow.StartTextFade(delayMessageShow);
				data2.SetOrder(1);
				data2.PlayVoice();
			}
			m_lastTextWindow = messageWindow;
			m_usedWindows.Add(messageWindow);
			messageWindow.enabled = true;
		}

		public void FlushWindows()
		{
			foreach (MessageWindow usedWindow in m_usedWindows)
			{
				usedWindow.enabled = false;
			}
			m_usedWindows.Clear();
		}

		public void NewTextMessage(CommandText data)
		{
			CreateNewWindow(data);
		}

		public void OnNextPageInput()
		{
			HideWaitingIcon();
			PageNextWindow();
		}

		public bool IsLastWindowAllVisible()
		{
			if (!m_lastTextWindow)
			{
				return true;
			}
			return m_lastTextWindow.IsTextAllVisible;
		}

		public void ShowLastWindowAllText()
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.InstantShow();
			}
		}

		public void ShakeLastWindow(float duration)
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.StartShakeOnFade(duration);
			}
		}

		public void StartThroughEffect()
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.StartThroughEffect();
			}
		}

		public void HideWaitingIcon()
		{
			if ((bool)m_lastTextWindow)
			{
				m_lastTextWindow.ToggleWaitingIcon(flag: false);
			}
		}

		public void StopFade()
		{
			switch (_fadeMode)
			{
			case FadeMode.FadeIn:
				windowGlobalAlpha = 1f;
				break;
			case FadeMode.FadeOut:
				windowGlobalAlpha = 0f;
				break;
			}
			_fadeMode = FadeMode.NoFade;
		}

		public void StartFadeIn()
		{
			if (!_messagePlayer.IsRemoveInterface)
			{
				_fadeMode = FadeMode.FadeIn;
				_timeSinceFadeStart = Time.time;
				windowGlobalAlpha = 0f;
			}
		}

		public void StartFadeOut()
		{
			_fadeMode = FadeMode.FadeOut;
			_timeSinceFadeStart = Time.time;
		}

		public void SetLineLength(float numByJp)
		{
			for (int i = 0; i < m_objectWindows.Count; i++)
			{
				m_objectWindows[i].SetLineLength(numByJp);
			}
		}

		public void ClearScenarioRelations()
		{
			_prohibitHeightChange.Value = false;
		}
	}
	public class MessageWindowData : MonoBehaviour
	{
		[Header("Parameters")]
		[SerializeField]
		private float fadeSpeed = 10f;

		[SerializeField]
		private float alphaMultiply = 0.9f;

		private Transform _thisTransform;

		private Transform _parentTransform;

		private MessageWindow _message;

		private CommandText _textData;

		private Data_Character.Param _charaData;

		private IChara _charaObject;

		private int _messageOrder;

		private float _fadeOrder;

		private Vector3 _originPos;

		private bool _isOriginGlobal;

		private Transform _originTrans;

		public bool IsMonologue
		{
			get
			{
				if (_textData != null)
				{
					return _textData.IsMonologue;
				}
				return true;
			}
		}

		private bool IsSkipMode => _message.IsSkipMode;

		private void Awake()
		{
			_thisTransform = GetComponent<Transform>();
			_message = GetComponent<MessageWindow>();
		}

		private void Start()
		{
			_parentTransform = _thisTransform.parent;
			base.enabled = false;
		}

		public void InitWindowByData(CommandText data)
		{
			_textData = data;
			_charaData = data.FindCharacterData();
			_charaObject = data.FindCharacter();
			_message.SetMessageText(_textData.Text);
			_message.SetNameText(_textData.CharaFullName);
			_message.ToggleMonorogue(_textData.IsMonologue);
			if (_charaData != null && !data.IsMonologue)
			{
				_message.SetSkinColor(_charaData.colorBackground.WithAlpha(alphaMultiply));
			}
			if (_textData.IsMonologue)
			{
				SetOriginPosition(new Vector3(0f, -1f, 0f), isGlobal: false);
			}
			else if (_charaObject == null || data.CharaType == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID)
			{
				Transform messagePivot = MainPosition.Avater.MessagePivot;
				SetOriginTransform(messagePivot);
			}
			else
			{
				Transform head = _charaObject.Head;
				SetOriginTransform(head);
			}
			_message.ToggleWaitingIcon(flag: false);
			base.enabled = true;
		}

		public void UpdateWindowPosition()
		{
			float num = (float)_messageOrder - _fadeOrder;
			if (!Mathf.Approximately(0f, num))
			{
				float num2 = Time.deltaTime * fadeSpeed;
				if (IsSkipMode)
				{
					_fadeOrder = _messageOrder;
				}
				else
				{
					_fadeOrder += num * num2;
				}
				_thisTransform.localPosition = GetFadePosition();
				_message.SetMessageAlpga(GetFadeAlpha());
			}
		}

		private Vector3 GetFadePosition()
		{
			float fadeOrder = _fadeOrder;
			if (fadeOrder < 1f)
			{
				float num = Mathf.Clamp(fadeOrder, 0f, 1f);
				Vector3 vector = new Vector3(0f, 0f, 0f);
				Vector3 vector2 = ((_originTrans != null) ? _parentTransform.InverseTransformPoint(_originTrans.position) : ((!_isOriginGlobal) ? _originPos : _parentTransform.InverseTransformPoint(_originPos)));
				return vector2 * (1f - num) + vector * num;
			}
			return new Vector3(0f, (fadeOrder - 1f) * -0.6f, (fadeOrder - 1f) * -0.6f);
		}

		private float GetFadeAlpha()
		{
			float fadeOrder = _fadeOrder;
			if (fadeOrder < 1f)
			{
				return fadeOrder;
			}
			return 1f - (fadeOrder - 1f);
		}

		public void SetPositionToOrder()
		{
			_fadeOrder = _messageOrder;
			_thisTransform.localPosition = GetFadePosition();
			_message.SetMessageAlpga(GetFadeAlpha());
		}

		public void SetPositionToOrder(int order)
		{
			_messageOrder = order;
			SetPositionToOrder();
		}

		public void SetOrder(int o)
		{
			_messageOrder = o;
		}

		public int GetOrder()
		{
			return _messageOrder;
		}

		private void SetOriginPosition(Vector3 pos, bool isGlobal)
		{
			_originPos = pos;
			_isOriginGlobal = isGlobal;
			_originTrans = null;
		}

		private void SetOriginTransform(Transform trans)
		{
			_originTrans = trans;
		}

		public Transform GetWaveTarget()
		{
			if (_charaObject != null)
			{
				if (_charaObject.ID == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID)
				{
					return _thisTransform;
				}
				if (_charaObject.Transform != null)
				{
					return _charaObject.Transform;
				}
				return _thisTransform;
			}
			return _thisTransform;
		}

		public void PlayVoice()
		{
			if (_textData.Chara != GameDefine.CharaID.BASE)
			{
				SoundManager.Voice.PlayVoiceByData(_textData);
			}
		}

		public void StopVoice()
		{
		}
	}
	public class MessageWindowSkin : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshPro messageText;

		[SerializeField]
		private SpriteRenderer[] skinSprites;

		[SerializeField]
		private TextMeshPro[] skinTexts;

		private bool _isSkinDirty;

		private Color _messageColor = Color.white;

		private float _messageAlpha = 1f;

		private Color _skinColor = Color.white;

		public bool IsNeedUpdate => _isSkinDirty;

		public void UpdateAll()
		{
			if (_isSkinDirty)
			{
				UpdateMessageColor();
				UpdateSkinColor();
				_isSkinDirty = false;
			}
		}

		private void UpdateMessageColor()
		{
			Color messageColor = _messageColor;
			messageColor.a *= _messageAlpha;
			messageText.color = messageColor;
		}

		private void UpdateSkinColor()
		{
			Color skinColor = _skinColor;
			skinColor.a *= _messageAlpha;
			for (int i = 0; i < skinSprites.Length; i++)
			{
				skinSprites[i].color = skinColor;
			}
			for (int j = 0; j < skinTexts.Length; j++)
			{
				skinTexts[j].color = skinColor;
			}
		}

		private float GetRisanAlpha(float alpha, int parts)
		{
			return Mathf.Round(alpha * (float)parts) / (float)parts;
		}

		public void SetMessageAlpha(float alpha)
		{
			alpha = Mathf.Clamp01(GetRisanAlpha(alpha, 8));
			_isSkinDirty = _isSkinDirty || _messageAlpha != alpha;
			_messageAlpha = alpha;
		}

		public void SetSkinColor(Color color)
		{
			_skinColor = color;
			_isSkinDirty = true;
		}

		public void ToggleSkinVisible(bool flag)
		{
			for (int i = 0; i < skinSprites.Length; i++)
			{
				skinSprites[i].gameObject.SetActive(flag);
			}
			for (int j = 0; j < skinTexts.Length; j++)
			{
				skinTexts[j].gameObject.SetActive(flag);
			}
		}
	}
	public class MessageWindowText : MonoBehaviour
	{
		[Header("Parameters")]
		[SerializeField]
		private float defaultMessageLength = -1f;

		[SerializeField]
		private float defaultWaitTime = 0.03f;

		[SerializeField]
		private float difftimePerToggle = 0.009f;

		[SerializeField]
		private string dummyCharacter = "■";

		private Vector2 _defaultSize;

		private RectTransform _thisTransform;

		private TextMeshPro _textComponent;

		private TextProFader _fader;

		public IObservable<Unit> OnBeforeFadeDelay => _fader.OnBeforeFadeDelay;

		public IObservable<Unit> OnStartFade => _fader.OnStartFade;

		public IObservable<Unit> OnEndFade => _fader.OnEndFade;

		public Vector3 LastCharacterPosition => _fader.LastCharacterPosition;

		public bool IsAllVisible
		{
			get
			{
				if (HasFader)
				{
					return _fader.IsFinishedFade;
				}
				return true;
			}
		}

		private bool HasFader => _fader != null;

		private void Awake()
		{
			_thisTransform = GetComponent<RectTransform>();
			_textComponent = GetComponent<TextMeshPro>();
			_fader = GetComponent<TextProFader>();
			_defaultSize = _thisTransform.sizeDelta;
			if (HasFader)
			{
				_fader.omitLastNum = 1;
			}
		}

		public void SetText(string str)
		{
			if (HasFader)
			{
				str += dummyCharacter;
			}
			_textComponent.text = str;
		}

		public void SetTextVisible(bool flag)
		{
			if (HasFader)
			{
				_fader.ToggleAllText(flag);
			}
		}

		public void StartFade(float delay)
		{
			if (HasFader)
			{
				_fader.StartFade(delay);
			}
		}

		public void SetLineLength(float numByJp)
		{
			if (!(defaultMessageLength <= 0f))
			{
				float num = _defaultSize.x / defaultMessageLength;
				Vector2 defaultSize = _defaultSize;
				defaultSize.x = num * numByJp;
				_thisTransform.sizeDelta = defaultSize;
			}
		}

		public void SetLineLengthDiff(float diffByJp)
		{
			if (!(defaultMessageLength <= 0f))
			{
				SetLineLength(defaultMessageLength + diffByJp);
			}
		}

		public void ToggleCentering(bool flag)
		{
			_textComponent.alignment = TextAlignmentOptions.Top;
		}

		public void SetTextSpeed(int toggleValue)
		{
			_fader.waitTime = defaultWaitTime - difftimePerToggle * (float)toggleValue;
		}
	}
	public class MessageWindowWaitIcon : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private SpriteRenderer _sprite;

		[Header("Parameter")]
		[SerializeField]
		private Vector3 offset = new Vector3(0.055f, 0.045f, 0f);

		private Transform _thisTrans;

		private Animator _thisAnimator;

		private void Awake()
		{
			_thisTrans = base.transform;
			_thisAnimator = GetComponent<Animator>();
		}

		private void OnEnable()
		{
			_thisAnimator.enabled = true;
			_thisAnimator.Play(0);
		}

		private void OnDisable()
		{
			_thisAnimator.enabled = false;
		}

		public void SetPosition(Vector3 pos)
		{
			if (!(_thisTrans == null))
			{
				_thisTrans.localPosition = pos + offset;
			}
		}

		public void SetAlpha(float alpha)
		{
			_sprite.color = _sprite.color.WithAlpha(alpha);
		}
	}
	public class MessageWindowWave : MonoBehaviour
	{
		private const float THRESHOULD_ANGLE_SCALE = 30f;

		[SerializeField]
		private bool isLeft;

		private Transform thisTrans;

		private float _scaleBase = 1f;

		private float _scaleAngle = 1f;

		private bool _wayIsLeft = true;

		private void Awake()
		{
			thisTrans = base.transform;
		}

		public void UpdateScale()
		{
			Vector3 localScale = thisTrans.localScale;
			float y = _scaleBase * _scaleAngle;
			localScale.y = y;
			thisTrans.localScale = localScale;
		}

		public void ChangeWaveSize(float length)
		{
			_scaleBase = length;
		}

		public void WaveByTarget(Transform target)
		{
			if (!(target == null))
			{
				Vector3 position = MainPosition.CameraTransform.position;
				Vector3 to = thisTrans.position - position;
				Vector3 from = target.position - position;
				to.y = (from.y = 0f);
				float num = Vector3.SignedAngle(from, to, Vector3.up);
				float num2 = Mathf.Abs(num);
				bool flag = num <= 0f;
				if (_wayIsLeft != flag)
				{
					_wayIsLeft = flag;
					thisTrans.localEulerAngles = new Vector3(0f, (!_wayIsLeft) ? 180 : 0, 0f);
				}
				if (isLeft)
				{
					_scaleAngle = ((0f - num <= 30f) ? 1f : (15f / (15f + num2 - 30f)));
				}
				else
				{
					_scaleAngle = ((num <= 30f) ? 1f : (15f / (15f + num2 - 30f)));
				}
			}
		}
	}
	public class SpriteScroller : UpdateableComponent
	{
		[SerializeField]
		private SpriteRenderer thisRenderer;

		[SerializeField]
		private Vector2 scrollSpeed = new Vector2(1f, 0f);

		[SerializeField]
		private Vector2 scrollSize = new Vector2(1f, 1f);

		private Transform _thisTransform;

		private Vector2 _texPos = new Vector2(0f, 0f);

		private void Awake()
		{
			_thisTransform = base.transform;
		}

		public override void OnUpdate(float deltaTime)
		{
			Vector2 vector = scrollSpeed * deltaTime;
			_texPos.x = Mathf.Repeat(_texPos.x + vector.x, 1f);
			_texPos.y = Mathf.Repeat(_texPos.y + vector.y, 1f);
			Vector3 localPosition = new Vector3(_texPos.x * scrollSize.x - scrollSize.x / 2f, _texPos.y * scrollSize.y, 0f);
			_thisTransform.localPosition = localPosition;
		}
	}
	public class FlashbackImage : MonoBehaviour
	{
		private const string _PARAM_COLOUR = "Color";

		private Material m_material;

		private Tweener<float> m_alphaTween;

		private void Start()
		{
			m_material = GetComponent<Renderer>().material;
		}

		public void SetSprite(Texture sp)
		{
			m_material.mainTexture = sp;
		}

		public void Clear()
		{
			m_material.mainTexture = null;
		}
	}
	public class FlashbackRoot : MonoBehaviour
	{
		public class Data<T>
		{
			public int ID;

			public T Content;

			public Data(int id, T content)
			{
				ID = id;
				Content = content;
			}
		}

		private const string FILE_PATH = "{0}{1:D4}";

		[Header("Components")]
		[SerializeField]
		private ForcusUpWindow m_imageWindow;

		[Header("Parameters - Image")]
		[SerializeField]
		private float m_imageFadeDuration = 0.15f;

		[Header("Parameters - Fog")]
		[SerializeField]
		private float m_fogFadeDuration = 1f;

		[SerializeField]
		private float m_fogEndFadeDuration = 3f;

		[SerializeField]
		private float m_fogStartDistance;

		[SerializeField]
		private float m_fogEndDistance = 1000f;

		[SerializeField]
		private float m_fogDistanceOnEnd = 40000f;

		[SerializeField]
		private Color m_fogColour = Color.black;

		[SerializeField]
		private FogMode m_fogMode = FogMode.Linear;

		private GameObject m_gameObject;

		private Transform m_transform;

		private Transform m_playerRoot;

		private List<Data<Texture>> m_textures = new List<Data<Texture>>();

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private List<AdvChara> m_enabledCharas = new List<AdvChara>();

		private Vector3 m_imageScale = Vector3.one;

		public Transform Transform => m_transform;

		public bool IsFading { get; private set; }

		public bool IsLoading => m_requests.Count > 0;

		public bool IsBusy
		{
			get
			{
				if (!IsLoading && !IsFading)
				{
					return m_imageWindow.IsBusy;
				}
				return true;
			}
		}

		public bool IsPlaying { get; private set; }

		public bool HasImage { get; private set; }

		private void Start()
		{
			HasImage = false;
			IsPlaying = false;
			IsFading = false;
			m_gameObject = base.gameObject;
			m_transform = base.transform;
			m_imageScale = m_imageWindow.transform.localScale;
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Where((int _) => IsPlaying || IsLoading).Subscribe(delegate
			{
				OnEndFogEnd();
			}).AddTo(base.gameObject);
		}

		public void LoadAllTextures(List<int> preloadIndexes)
		{
			preloadIndexes?.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<Texture>(string.Format("{0}{1:D4}", "Textures/Event/", id));
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadComplete(obj, id);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void OnLoadComplete(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			Texture texture = (obj as ResourceRequest).asset as Texture;
			if (!(texture == null))
			{
				m_textures.Add(new Data<Texture>(id, texture));
			}
		}

		public void Clear()
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(m_textures[i].Content);
				m_textures[i].Content = null;
				m_textures[i] = null;
			}
			m_textures.Clear();
			Resources.UnloadUnusedAssets();
		}

		public void SetActive(bool isActive)
		{
			m_gameObject.SetActive(isActive);
		}

		public void Play(Transform playerRoot, IFader fader, CommandFlashbackStart command)
		{
			Play(playerRoot, fader, command.ID, command.EndDistance);
		}

		public void Play(Transform playerRoot, IFader fader, int id, float fogEndTargetDistance)
		{
			HasImage = id != -1;
			IsPlaying = true;
			IsFading = true;
			m_playerRoot = playerRoot;
			SoundManager.Voice.IsForce2DMode = true;
			RecordActiveChara();
			FadeAllChara(0f, 0.3f, isActivate: false);
			InitializeFogState(m_fogEndDistance);
			StartFogFadeIn(id, fogEndTargetDistance);
			MoveToPlayer();
		}

		private void InitializeFogState(float fogEndDistance)
		{
			RenderSettings.fog = true;
			RenderSettings.fogColor = m_fogColour;
			RenderSettings.fogMode = m_fogMode;
			RenderSettings.fogStartDistance = m_fogStartDistance;
			RenderSettings.fogEndDistance = fogEndDistance;
		}

		private void StartFogFadeIn(int id, float fogEndTargetDistance)
		{
			DOTween.To(() => RenderSettings.fogEndDistance, delegate(float density)
			{
				RenderSettings.fogEndDistance = density;
			}, fogEndTargetDistance, m_fogFadeDuration).OnComplete(delegate
			{
				OnStartFadeInEnd(id);
			});
		}

		private void RecordActiveChara()
		{
			m_enabledCharas.Clear();
			SingletonMonoBehaviour<CharactersManager>.Instance.AddActiveCharaToList(m_enabledCharas);
		}

		private void FadeAllChara(float targetAlpha, float duration, bool isActivate)
		{
			int count = m_enabledCharas.Count;
			for (int i = 0; i < count; i++)
			{
				AdvChara chara = m_enabledCharas[i];
				if (isActivate)
				{
					chara.SetEnable(isActivate);
					chara.Model.StartFade(targetAlpha, duration);
				}
				else
				{
					chara.Model.StartFade(targetAlpha, duration, delegate
					{
						chara.SetEnable(isActivate);
					});
				}
			}
		}

		private void MoveToPlayer()
		{
			m_transform.position = m_playerRoot.position;
			m_transform.rotation = m_playerRoot.rotation;
		}

		private Texture FindImage(int id)
		{
			int count = m_textures.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_textures[i].ID == id)
				{
					return m_textures[i].Content;
				}
			}
			return null;
		}

		private void OnStartFadeInEnd(int id)
		{
			SetActive(isActive: true);
			if (!HasImage)
			{
				OnStartImageFadeEnd();
			}
			else
			{
				ShowFlashbackImage(id);
			}
		}

		private void ShowFlashbackImage(int id)
		{
			Texture sprite = FindImage(id);
			m_imageWindow.OnOpen(sprite, Vector3Extension.Zero);
			m_imageWindow.OpenDither(sprite, m_imageScale, m_imageFadeDuration, delegate
			{
				OnStartImageFadeEnd();
			});
		}

		private void OnStartImageFadeEnd()
		{
			IsFading = false;
		}

		public void ChangeSprite(int id)
		{
			m_imageWindow.ChangeTexture(FindImage(id), m_imageFadeDuration);
		}

		public void Close()
		{
			IsFading = true;
			if (HasImage)
			{
				m_imageWindow.Close(m_imageFadeDuration, ForcusUpWindow.FadeType.Dither, Ease.InOutSine);
			}
			FadeAllChara(1f, 0.3f, isActivate: true);
			DOTween.To(() => RenderSettings.fogEndDistance, delegate(float density)
			{
				RenderSettings.fogEndDistance = density;
			}, m_fogDistanceOnEnd, m_fogEndFadeDuration).OnComplete(delegate
			{
				OnEndFogEnd();
			});
		}

		private void OnEndFogEnd()
		{
			RenderSettings.fog = false;
			IsFading = false;
			IsPlaying = false;
			HasImage = false;
			SoundManager.Voice.IsForce2DMode = false;
			SetActive(isActive: false);
			m_enabledCharas.Clear();
		}

		public void OnScenarioEnd()
		{
			m_imageWindow.Close(0f, ForcusUpWindow.FadeType.Move, Ease.InOutSine);
			RenderSettings.fogEndDistance = m_fogDistanceOnEnd;
			OnEndFogEnd();
			Clear();
		}
	}
	public class DebugConsole : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private GameObject _consoleParent;

		[SerializeField]
		private GameObject _consoleContents;

		[SerializeField]
		private TextMeshProUGUI m_versionText;

		private ObservableEventTrigger _rootEventTrigger;

		private bool _isVisible;

		public bool IsVisible => _isVisible;

		private void Awake()
		{
			ToggleVisible(flag: false);
			_rootEventTrigger = _consoleParent.AddComponent<ObservableEventTrigger>();
		}

		private void Start()
		{
			_rootEventTrigger.OnPointerEnterAsObservable().Subscribe(delegate
			{
				ToggleVisible(flag: true);
			}).AddTo(this);
			_rootEventTrigger.OnPointerExitAsObservable().Subscribe(delegate
			{
				ToggleVisible(flag: false);
			}).AddTo(this);
			m_versionText.text = $"Version:{UnityEngine.Application.version}";
		}

		private void ToggleVisible(bool flag)
		{
			_isVisible = flag;
			_consoleContents.SetActive(flag);
		}
	}
	public class DebugIngameStatus : MonoBehaviour
	{
		[SerializeField]
		private TextMeshProUGUI _textComponent;

		public bool IsVisible { get; set; }

		private void Awake()
		{
			_textComponent.text = "";
			(from _ in this.UpdateAsObservable()
				where IsVisible
				select _).Subscribe(delegate
			{
				OnUpdate();
			});
		}

		private void OnUpdate()
		{
			string text = "";
			text += $"Active Scene: <b>{SceneManager.GetActiveScene().name}</b>\n";
			if (SingletonMonoBehaviour<MasterManager>.HasInstance)
			{
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
				{
					text += "Busy [";
					foreach (Component value in SingletonMonoBehaviour<MasterManager>.Instance.BusyComponentList.Values)
					{
						text = text + value.ToString() + ", ";
					}
					text += "]\n";
				}
				else
				{
					text += "Active\n";
				}
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsInGame)
				{
					if (SingletonMonoBehaviour<InGameManager>.HasInstance)
					{
						TimelinePlayer timeline = InGameManager.Timeline;
						text += $"SQID: <b>{timeline.LoadedScenarioID:00000}</b>\n";
						text += $"CmdLine Index: <b>{timeline.SequenceCurrentIndex}</b>\n";
						ISequenceCommand waitingCommand = timeline.WaitingCommand;
						string arg = ((waitingCommand != null) ? waitingCommand.Type.ToString() : "None");
						text += $"Wait: Leg <b>{timeline.LegacyWait}</b> - Cmd <b>{arg}</b>";
					}
					else
					{
						text += " (Not Initialized)";
					}
				}
				else
				{
					text += "Not InGame";
				}
			}
			else
			{
				text += "Game Not Initialized";
			}
			_textComponent.text = text;
		}

		public void ToggleVisible(bool flag)
		{
			IsVisible = flag;
			base.enabled = flag;
			_textComponent.enabled = flag;
		}
	}
	public class DebugManager : SingletonMonoBehaviour<DebugManager>
	{
		[Serializable]
		public class SuperAutoSelectionState
		{
			public int sqid = -1;

			public int nextSelection = -1;
		}

		[Header("Components - Displays")]
		[SerializeField]
		private FPSCounterTMPro _fpsCounter;

		[SerializeField]
		private DebugMemory _memoryDispley;

		[SerializeField]
		private DebugLogger _logDisplay;

		[SerializeField]
		private DebugIngameStatus _gameStatusDisplay;

		[Header("Components - Others")]
		[SerializeField]
		private DebugConsole _console;

		[Header("Parameter - Defaults")]
		[SerializeField]
		private bool _startShowFps;

		[SerializeField]
		private bool _startShowMemory;

		[SerializeField]
		private bool _startShowLog;

		[SerializeField]
		private bool _startShowGameStatus;

		[Header("Parameter - Selection")]
		[SerializeField]
		private List<SuperAutoSelectionState> _selectionState;

		public bool IsSuperAutoMode { get; set; }

		public bool IsVisibleFps => _fpsCounter.IsVisible;

		public bool IsVisibleMemory => _memoryDispley.IsVisible;

		public bool IsVisibleLog => _logDisplay.IsVisible;

		public bool IsVisibleGameStatus => _gameStatusDisplay.IsVisible;

		public bool IsVisibleConsole => _console.IsVisible;

		protected override void InitializeOnAwake()
		{
			_fpsCounter.ToggleVisible(_startShowFps);
			_memoryDispley.ToggleVisible(_startShowMemory);
			_logDisplay.ToggleVisible(_startShowLog);
			_gameStatusDisplay.ToggleVisible(_startShowGameStatus);
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
			{
				base.transform.SetParent(SingletonMonoBehaviour<PlayAreaManager>.Instance.transform, worldPositionStays: false);
			}
			else
			{
				UnityEngine.Debug.LogWarning("OOPS: DebugManager couldn't find PlayAreaManager.");
			}
		}

		public void ToggleVisibleFps(bool flag)
		{
			_fpsCounter.ToggleVisible(flag);
		}

		public void ToggleVisibleMemory(bool flag)
		{
			_memoryDispley.ToggleVisible(flag);
		}

		public void ToggleVisibleLog(bool flag)
		{
			_logDisplay.ToggleVisible(flag);
		}

		public void ToggleVisibleGameStatus(bool flag)
		{
			_gameStatusDisplay.ToggleVisible(flag);
		}

		private SuperAutoSelectionState FindSelectionState(int sqid)
		{
			SuperAutoSelectionState superAutoSelectionState = _selectionState.Find((SuperAutoSelectionState state) => state.sqid == sqid);
			if (superAutoSelectionState == null)
			{
				superAutoSelectionState = new SuperAutoSelectionState();
				superAutoSelectionState.sqid = sqid;
				_selectionState.Add(superAutoSelectionState);
			}
			return superAutoSelectionState;
		}

		public int GetNextAutoSelection(int sqid, int selectionMax)
		{
			SuperAutoSelectionState superAutoSelectionState = FindSelectionState(sqid);
			if (superAutoSelectionState.nextSelection < 0)
			{
				superAutoSelectionState.nextSelection = selectionMax - 1;
			}
			int nextSelection = superAutoSelectionState.nextSelection;
			superAutoSelectionState.nextSelection--;
			if (superAutoSelectionState.nextSelection < 0)
			{
				superAutoSelectionState.nextSelection = selectionMax - 1;
			}
			return nextSelection;
		}
	}
	public abstract class DebugBaseSelectToggle<T> : MonoBehaviour
	{
		[SerializeField]
		private Toggle _toggle;

		[SerializeField]
		protected TextMeshProUGUI _label;

		public IObservable<bool> OnChangeToggle { get; private set; }

		private void Awake()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			if (OnChangeToggle == null)
			{
				OnChangeToggle = _toggle.OnValueChangedAsObservable();
			}
		}

		public void Initialize(T myValue, ToggleGroup group, bool isSelected)
		{
			_toggle.group = group;
			_toggle.isOn = isSelected;
			SetText(myValue);
			Color white = Color.white;
			_label.color = white;
			MakeSubscribes();
		}

		protected abstract void SetText(T text);
	}
	public class DebugChapterPage : MonoBehaviour
	{
		public int MajorCategoryInt { get; set; }

		public void SetVisible(bool flag)
		{
			base.gameObject.SetActive(flag);
		}
	}
	public class DebugMSAASelectToggle : DebugBaseSelectToggle<int>
	{
		protected override void SetText(int text)
		{
			_label.text = text.ToString();
		}
	}
	public class DebugResolutionSelectToggle : DebugBaseSelectToggle<float>
	{
		protected override void SetText(float text)
		{
			_label.text = text.ToString();
		}
	}
	public class DebugScenarioInfo : MonoBehaviour
	{
		[SerializeField]
		private Image _imageThumbnail;

		[SerializeField]
		private TextMeshProUGUI _textHeader;

		[SerializeField]
		private TextMeshProUGUI _textContents;

		[SerializeField]
		private Sprite _defaultThumbnail;

		private int CurrentSqid
		{
			get
			{
				if (!SingletonMonoBehaviour<MasterManager>.Instance.IsInGame)
				{
					return -1;
				}
				return InGameManager.Timeline.LoadedScenarioID;
			}
		}

		private void Start()
		{
			_textHeader.fontStyle = FontStyles.Bold;
			this.ObserveEveryValueChanged((DebugScenarioInfo _) => CurrentSqid).Subscribe(delegate(int sqid)
			{
				UpdateInfo(sqid);
			});
		}

		private void UpdateInfo(int sqid)
		{
			if (sqid <= -1)
			{
				_imageThumbnail.sprite = _defaultThumbnail;
				_textHeader.text = "Scenario Not Loaded";
				_textContents.text = "";
				return;
			}
			ScenarioListData.Info scenarioInfo = SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(sqid);
			if (scenarioInfo.Index <= -1)
			{
				_imageThumbnail.sprite = _defaultThumbnail;
				_textHeader.text = "Unknown Scenario: " + sqid.ToString("D5");
				_textContents.text = "";
				return;
			}
			_imageThumbnail.sprite = ((scenarioInfo.SaveThumbnail == null) ? _defaultThumbnail : scenarioInfo.SaveThumbnail);
			_textHeader.text = scenarioInfo.FileName;
			if (scenarioInfo.Category == ScenarioListData.Categories.Special)
			{
				_textContents.text = "Special Type: " + scenarioInfo.SpecialType;
			}
			else
			{
				_textContents.text = "Category: " + scenarioInfo.Category;
			}
			TextMeshProUGUI textContents = _textContents;
			textContents.text = textContents.text + " (Chapter " + scenarioInfo.ChapterNumber + ")";
			if (scenarioInfo.RelatedSqid >= 0)
			{
				TextMeshProUGUI textContents2 = _textContents;
				textContents2.text = textContents2.text + "\nRelated SQID: " + scenarioInfo.RelatedSqid.ToString("D5");
			}
			else
			{
				_textContents.text += "\nRelated SQID: (Not Related)";
			}
			TextMeshProUGUI textContents3 = _textContents;
			textContents3.text = textContents3.text + "\nSkip Mode: " + scenarioInfo.SkipMode;
			TextMeshProUGUI textContents4 = _textContents;
			textContents4.text = textContents4.text + "\nReaded: " + YesNoString(SingletonMonoBehaviour<GameData>.Instance.SystemData.IsScenarioReaded(sqid));
		}

		private string YesNoString(bool flag)
		{
			if (!flag)
			{
				return "No";
			}
			return "Yes";
		}
	}
	public class DebugUIFlags : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private SceneSelectToggle _prefabToggle;

		[Header("Components")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private Button _buttonAllOn;

		[SerializeField]
		private Button _buttonAllOff;

		[SerializeField]
		private Button _buttonReadedOn;

		[SerializeField]
		private Button _buttonReadedOff;

		[SerializeField]
		private Button _buttonR1On;

		[SerializeField]
		private Button _buttonR2On;

		[SerializeField]
		private Button _buttonSubOn;

		[SerializeField]
		private Button _buttonSubmit;

		private List<SceneSelectToggle> _toggles = new List<SceneSelectToggle>();

		private void Start()
		{
			MakeScenarioToggles();
			MakeSubscribes();
		}

		private void OnEnable()
		{
			RefreshToggles();
		}

		private void OnDestroy()
		{
			_toggles.Clear();
		}

		private void MakeScenarioToggles()
		{
			foreach (GameFlags flagName in Enum.GetValues(typeof(GameFlags)))
			{
				if (flagName != GameFlags.Max)
				{
					SceneSelectToggle sceneSelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, _toggleParent, worldPositionStays: false);
					sceneSelectToggle.InitForFlag(flagName);
					sceneSelectToggle.OnChangeToggle.Subscribe(delegate(bool flag)
					{
						OnSelectToggle(flagName, flag);
					}).AddTo(this);
					_toggles.Add(sceneSelectToggle);
				}
			}
		}

		private void MakeSubscribes()
		{
			_buttonSubmit.OnClickAsObservable().Subscribe(delegate
			{
				SaveSystemFile();
			}).AddTo(this);
			_buttonAllOn.OnClickAsObservable().Subscribe(delegate
			{
				ToggleAll(flag: true);
			}).AddTo(this);
			_buttonAllOff.OnClickAsObservable().Subscribe(delegate
			{
				ToggleAll(flag: false);
			}).AddTo(this);
			_buttonReadedOn.OnClickAsObservable().Subscribe(delegate
			{
				ToggleReadedAll(flag: true);
			}).AddTo(this);
			_buttonReadedOff.OnClickAsObservable().Subscribe(delegate
			{
				ToggleReadedAll(flag: false);
			}).AddTo(this);
			_buttonR1On.OnClickAsObservable().Subscribe(delegate
			{
				FlanEnableForR1();
			}).AddTo(this);
			_buttonR2On.OnClickAsObservable().Subscribe(delegate
			{
				FlanEnableForR2();
			}).AddTo(this);
			_buttonSubOn.OnClickAsObservable().Subscribe(delegate
			{
				FlanEnableForSubChap();
			}).AddTo(this);
		}

		private void OnSelectToggle(GameFlags flagName, bool flag)
		{
			if (flag != SingletonMonoBehaviour<GameData>.Instance.GetFlag(flagName))
			{
				UnityEngine.Debug.LogFormat("DebugFlag: {0} = <b>{1}</b>", flagName, flag);
				SingletonMonoBehaviour<GameData>.Instance.SetFlag(flagName, flag);
			}
		}

		private void SaveSystemFile()
		{
			SingletonMonoBehaviour<GameData>.Instance.SaveSystemData();
			UnityEngine.Debug.Log("System File Saved!");
		}

		public void RefreshToggles()
		{
			foreach (SceneSelectToggle toggle in _toggles)
			{
				toggle.RefreshForFlag();
			}
		}

		public void ToggleAll(bool flag)
		{
			foreach (GameFlags value in Enum.GetValues(typeof(GameFlags)))
			{
				if (value != GameFlags.Max)
				{
					SingletonMonoBehaviour<GameData>.Instance.SetFlag(value, flag);
				}
			}
			UnityEngine.Debug.LogFormat("DebugFlag: ゲームフラグを全て <b>{0}</b> にしました", flag);
			RefreshToggles();
		}

		public void ToggleReadedAll(bool flag)
		{
			if (flag)
			{
				SingletonMonoBehaviour<GameData>.Instance.SystemData.MakeAllReaded();
			}
			else
			{
				SingletonMonoBehaviour<GameData>.Instance.SystemData.ClearReadedFlag();
			}
			UnityEngine.Debug.LogFormat("DebugFlag: 既読フラグを全て <b>{0}</b> にしました", flag);
		}

		public void FlanEnableForR1()
		{
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route1Chapter7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter1_7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingNormal, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.SkipNoifyShowed, value: true);
			foreach (ScenarioListData.Info value in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				if (value.Category == ScenarioListData.Categories.RouteFirst)
				{
					SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag_Debug(value.Index);
				}
			}
			UnityEngine.Debug.Log("DebugFlag: 1週目のフラグとED1を全て <b>True</b> にしました");
			RefreshToggles();
		}

		public void FlanEnableForR2()
		{
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter8, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter9, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.Route2Chapter10, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_0, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_1, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_2, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_3, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_4, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_5, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_6, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_7, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_8, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_9, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.CompleteChapter2_10, value: true);
			foreach (ScenarioListData.Info value in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				if (value.Category == ScenarioListData.Categories.RouteSecond)
				{
					SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag_Debug(value.Index);
				}
			}
			UnityEngine.Debug.Log("DebugFlag: 2週目のフラグを全て <b>True</b> にしました");
			RefreshToggles();
		}

		public void FlanEnableForSubChap()
		{
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterKageyama, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterMachikouji, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterMomono, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterMorozumi, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.ChapterTougoku, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingAlternate, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingKageyama, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingMachikouji, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingMomono, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingMorozumi, value: true);
			SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.EndingTougoku, value: true);
			foreach (ScenarioListData.Info value in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				if (value.Category == ScenarioListData.Categories.Character)
				{
					SingletonMonoBehaviour<GameData>.Instance.SystemData.AddReadFlag_Debug(value.Index);
				}
			}
			UnityEngine.Debug.Log("DebugFlag: キャラクター章のフラグを全て <b>True</b> にしました");
			RefreshToggles();
		}
	}
	public class DebugUIMSAA : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private DebugMSAASelectToggle _prefabToggle;

		[Header("Components - General")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private ToggleGroup _toggleGroup;

		[SerializeField]
		private int[] m_msaaLevels;

		private void Start()
		{
			MakeToggles();
		}

		private void MakeToggles()
		{
			int num = m_msaaLevels.Length;
			for (int i = 0; i < num; i++)
			{
				DebugMSAASelectToggle debugMSAASelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, _toggleParent, worldPositionStays: false);
				debugMSAASelectToggle.Initialize(m_msaaLevels[i], _toggleGroup, m_msaaLevels[i] == QualitySettings.antiAliasing);
				int index = i;
				debugMSAASelectToggle.OnChangeToggle.Where((bool flag) => flag).Subscribe(delegate
				{
					OnSelectToggle(index);
				}).AddTo(this);
			}
		}

		private void OnSelectToggle(int index)
		{
			UnityEngine.Debug.Log("Selected MSAA Toggle! index = " + index + ", level = " + m_msaaLevels[index]);
			QualitySettings.antiAliasing = m_msaaLevels[index];
		}
	}
	public class DebugUIOptions : MonoBehaviour
	{
		[SerializeField]
		private Toggle _toggleFps;

		[SerializeField]
		private Toggle _toggleMemory;

		[SerializeField]
		private Toggle _toggleLog;

		[SerializeField]
		private Toggle _toggleGameStatus;

		[SerializeField]
		private Toggle _toggleSuperAuto;

		[SerializeField]
		private Button _buttonLanguage;

		[SerializeField]
		private Button _buttonClearStatButton;

		[SerializeField]
		private Button _buttonReset;

		[SerializeField]
		private TextMeshProUGUI _labelLanguage;

		[SerializeField]
		private TextMeshProUGUI _labelClearStatButton;

		private ReactiveProperty<int> _clearPressedCount = new ReactiveProperty<int>(4);

		private void Start()
		{
			_toggleFps.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleFps;
			_toggleMemory.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleMemory;
			_toggleLog.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleLog;
			_toggleGameStatus.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsVisibleGameStatus;
			_toggleSuperAuto.isOn = SingletonMonoBehaviour<DebugManager>.Instance.IsSuperAutoMode;
			_toggleFps.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleFps(flag);
			});
			_toggleMemory.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleMemory(flag);
			});
			_toggleLog.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleLog(flag);
			});
			_toggleGameStatus.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.ToggleVisibleGameStatus(flag);
			});
			_toggleSuperAuto.OnValueChangedAsObservable().Subscribe(delegate(bool flag)
			{
				SingletonMonoBehaviour<DebugManager>.Instance.IsSuperAutoMode = flag;
			});
			_buttonLanguage.OnClickAsObservable().Subscribe(delegate
			{
				ToggleNextLanguage();
			});
			_buttonReset.OnClickAsObservable().Subscribe(delegate
			{
				ResetGame();
			});
			_buttonClearStatButton.OnClickAsObservable().Subscribe(delegate
			{
				StatClearButtonPressed();
			});
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Subscribe(delegate(GameDefine.Languages lang)
			{
				_labelLanguage.text = lang.ToString();
			}).AddTo(base.gameObject);
			_clearPressedCount.Where((int count) => count > 0).Subscribe(delegate(int count)
			{
				_labelClearStatButton.text = "実績を消去: " + count;
			});
			_clearPressedCount.Where((int count) => count == 0).DelayFrame(1).Subscribe(delegate
			{
				_clearPressedCount.Value = 4;
			});
		}

		private void ToggleNextLanguage()
		{
			int num = (int)(SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value + 1);
			if (num >= 5)
			{
				num = 0;
			}
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value = (GameDefine.Languages)num;
		}

		private void StatClearButtonPressed()
		{
			if (_clearPressedCount.Value > 0)
			{
				_clearPressedCount.Value--;
			}
		}

		private void ResetGame()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
		}
	}
	public class DebugUIResolution : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private DebugResolutionSelectToggle _prefabToggle;

		[Header("Components - General")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private ToggleGroup _toggleGroup;

		[SerializeField]
		private float[] m_resolutions;

		private void Start()
		{
			MakeToggles();
		}

		private void MakeToggles()
		{
			int num = m_resolutions.Length;
			for (int i = 0; i < num; i++)
			{
				DebugResolutionSelectToggle debugResolutionSelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, _toggleParent, worldPositionStays: false);
				debugResolutionSelectToggle.Initialize(m_resolutions[i], _toggleGroup, m_resolutions[i] == XRSettings.eyeTextureResolutionScale);
				int index = i;
				debugResolutionSelectToggle.OnChangeToggle.Where((bool flag) => flag).Subscribe(delegate
				{
					OnSelectToggle(index);
				}).AddTo(this);
			}
		}

		private void OnSelectToggle(int index)
		{
			UnityEngine.Debug.Log("Selected Resolution Toggle! index = " + index + ", resolution = " + m_resolutions[index]);
			XRSettings.eyeTextureResolutionScale = m_resolutions[index];
		}
	}
	public class DebugUIScenario : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		private SceneSelectToggle _prefabToggle;

		[SerializeField]
		private DebugChapterPage _prefabPageComponent;

		[Header("Components - General")]
		[SerializeField]
		private Transform _toggleParent;

		[SerializeField]
		private ToggleGroup _toggleGroup;

		[SerializeField]
		private Button _buttonSubmit;

		[SerializeField]
		private TextMeshProUGUI _buttonLabel;

		[Header("Components - Paging")]
		[SerializeField]
		private Button _buttonPagePrev;

		[SerializeField]
		private Button _buttonPageNext;

		[SerializeField]
		private TextMeshProUGUI _labelCurrentPage;

		[Header("Parameters")]
		[SerializeField]
		private string _labelFormat = "ロード: {0:00000}";

		private int _sceneToLoad = -1;

		private int _currentPage;

		private SortedList<int, DebugChapterPage> _instancePage = new SortedList<int, DebugChapterPage>();

		private BehaviorSubject<int> _subjectPaged;

		private IObservable<int> OnPaged => _subjectPaged;

		private void Start()
		{
			MakeSubscribes();
			MakeScenarioToggles();
		}

		private void MakeSubscribes()
		{
			_subjectPaged = new BehaviorSubject<int>(_currentPage);
			_buttonSubmit.OnClickAsObservable().Subscribe(delegate
			{
				OnPushLoad();
			}).AddTo(this);
			_buttonPagePrev.OnClickAsObservable().Subscribe(delegate
			{
				PageCategory(-1);
			});
			_buttonPageNext.OnClickAsObservable().Subscribe(delegate
			{
				PageCategory(1);
			});
			OnPaged.Subscribe(delegate(int pageInt)
			{
				_labelCurrentPage.text = $"Chap. {pageInt:00}";
			});
		}

		private void MakeScenarioToggles()
		{
			int num = -1;
			DebugChapterPage debugChapterPage = null;
			_currentPage = -1;
			foreach (ScenarioListData.Info info in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Values)
			{
				int num2 = info.Index / 1000;
				if (num != num2)
				{
					num = num2;
					if (_currentPage == -1)
					{
						_currentPage = num2;
					}
					debugChapterPage = MakeScenarioPage(num2);
				}
				SceneSelectToggle sceneSelectToggle = UnityEngine.Object.Instantiate(_prefabToggle, debugChapterPage.transform, worldPositionStays: false);
				sceneSelectToggle.InitForScenario(info, _toggleGroup);
				sceneSelectToggle.OnChangeToggle.Where((bool flag) => flag).Subscribe(delegate
				{
					OnSelectToggle(info.Index);
				}).AddTo(this);
			}
			_subjectPaged.OnNext(_currentPage);
		}

		private DebugChapterPage MakeScenarioPage(int majorCategoryInt)
		{
			DebugChapterPage obj = UnityEngine.Object.Instantiate(_prefabPageComponent, _toggleParent, worldPositionStays: false);
			obj.MajorCategoryInt = majorCategoryInt;
			_instancePage.Add(majorCategoryInt, obj);
			OnPaged.Subscribe(delegate(int pageInt)
			{
				bool visible = obj.MajorCategoryInt == pageInt;
				obj.SetVisible(visible);
			});
			return obj;
		}

		private void OnSelectToggle(int index)
		{
			_sceneToLoad = index;
			_buttonLabel.text = string.Format(_labelFormat, index);
		}

		private void OnPushLoad()
		{
			if (_sceneToLoad == -1)
			{
				UnityEngine.Debug.LogError("REALLY OOPS: Scenario not selected");
				return;
			}
			UnityEngine.Debug.LogFormat("Debug console loads scenario '{0}'", _sceneToLoad);
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioWithFade(_sceneToLoad);
		}

		private void PageCategory(int diff)
		{
			int num = _instancePage.IndexOfKey(_currentPage);
			num += diff;
			if (num < 0)
			{
				num = _instancePage.Count - 1;
			}
			if (num >= _instancePage.Count)
			{
				num = 0;
			}
			_currentPage = _instancePage.Keys[num];
			_subjectPaged.OnNext(_currentPage);
		}
	}
	public class SceneSelectToggle : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Toggle _toggle;

		[SerializeField]
		private TextMeshProUGUI _label;

		private GameFlags _flagId;

		public IObservable<bool> OnChangeToggle { get; private set; }

		private void Awake()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			if (OnChangeToggle == null)
			{
				OnChangeToggle = _toggle.OnValueChangedAsObservable();
			}
		}

		public void InitForScenario(ScenarioListData.Info info, ToggleGroup group)
		{
			MakeSubscribes();
			int index = info.Index;
			_toggle.group = group;
			_label.text = index.ToString("00000");
			Color color = Color.HSVToRGB(Mathf.Repeat(1f / 64f * Mathf.Floor(index / 100), 1f), 0.7f - 0.4f * ((float)(index % 100) / 100f), 1f);
			if (!info.IsValid)
			{
				color.a = 0.25f;
			}
			_label.color = color;
			ToggleInterractable(info.IsValid);
		}

		public void InitForFlag(GameFlags flag)
		{
			MakeSubscribes();
			_flagId = flag;
			int num = (int)flag;
			_label.text = $"{num:00}: {flag.ToString()}";
			_label.color = Color.HSVToRGB(Mathf.Repeat(0.071f * Mathf.Floor(num / 10), 1f), 0.7f - 0.5f * ((float)(num % 10) / 10f), 1f);
			_toggle.isOn = SingletonMonoBehaviour<GameData>.Instance.GetFlag(flag);
		}

		public void RefreshForFlag()
		{
			_toggle.isOn = SingletonMonoBehaviour<GameData>.Instance.GetFlag(_flagId);
		}

		public void ToggleInterractable(bool flag)
		{
			_toggle.interactable = flag;
		}
	}
	public class AdvBoot : MonoBehaviour
	{
		[SerializeField]
		private bool m_isDestroyOnStart = true;

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartInGame();
			if (m_isDestroyOnStart)
			{
				UnityEngine.Object.Destroy(base.gameObject);
			}
		}
	}
	public class AdvBackgroundMemory : AdvBackground
	{
		public enum SpotlightTypes
		{
			Day,
			Evening,
			Night
		}

		[Serializable]
		public class TextureData
		{
			public Texture Texture;

			public SpotlightTypes Type;
		}

		[SerializeField]
		private MeshRenderer m_spotLight;

		[SerializeField]
		private List<TextureData> m_spotLightTextures;

		public void SetSpotlightType(SpotlightTypes type)
		{
			m_spotLight.sharedMaterial.mainTexture = m_spotLightTextures.Find((TextureData data) => data.Type == type).Texture;
		}
	}
	public class AdvMemoryChara : UpdateableComponent, IChara
	{
		[SerializeField]
		private int m_charaID;

		private const float _SHAKE_DURATION = 1.05f;

		private readonly Vector3 _SHAKE_AMOUNT = new Vector3(0.05f, 0.05f, 0f);

		private DitherFade m_fader;

		private Material m_material;

		private Tweener m_shakeTweener;

		private bool m_hasMoved;

		private bool m_isHoldShakeOnFade;

		private Action m_onEndFade;

		private Action m_onEndFadeSentAction;

		private Action m_onEndFadeSetEnable;

		private Action m_onStartFadeEnd;

		private Action m_onStartFadeEndSentAction;

		private float m_fadeDurationOnAction;

		private bool m_isEnableOnFadeEnd = true;

		public Transform Transform { get; set; }

		public Transform Head { get; private set; }

		public GameDefine.CharaID ID => (GameDefine.CharaID)(Mathf.Ceil(m_charaID / 100) * 100f);

		public int CharaID => m_charaID;

		public bool IsReady { get; private set; }

		protected override void Initialize()
		{
			if (Transform == null)
			{
				Transform = base.transform;
			}
			Head = Transform.GetChild(0);
			m_shakeTweener = null;
			m_thisGameObject = base.gameObject;
			CreateMaterial();
			m_fader = new DitherFade(m_thisGameObject, m_material);
			IsReady = true;
			m_isHoldShakeOnFade = false;
			InitializeShake();
			StopShake();
			Disable();
			m_onEndFade = delegate
			{
				OnFadeEnd();
			};
			m_onStartFadeEnd = delegate
			{
				OnStartFadeEnd();
			};
			m_onStartFadeEndSentAction = null;
			m_onEndFadeSetEnable = delegate
			{
				OnFadeEndSetEnable();
			};
			m_onEndFadeSentAction = null;
			m_fadeDurationOnAction = 0f;
			base.Initialize();
		}

		private void CreateMaterial()
		{
			Renderer component = GetComponent<Renderer>();
			if (!(component == null))
			{
				Material sharedMaterial = component.sharedMaterial;
				if (!(sharedMaterial == null))
				{
					m_material = new Material(sharedMaterial);
					component.sharedMaterial = m_material;
				}
			}
		}

		public void Destroy()
		{
			m_onEndFadeSentAction = null;
			m_onStartFadeEnd = null;
			m_material = null;
			UnityEngine.Object.Destroy(m_material);
			if (m_thisGameObject != null)
			{
				Transform.SetParent(null);
				UnityEngine.Object.Destroy(m_thisGameObject);
				m_thisGameObject = null;
			}
		}

		public void Setup(int id = -1)
		{
			if (id != -1)
			{
				m_charaID = id;
			}
			if (Transform == null)
			{
				Transform = base.transform;
			}
		}

		public override void OnUpdate(float delta)
		{
			if (IsReady)
			{
				m_fader.Update(delta);
				base.OnUpdate(delta);
			}
		}

		public void Enable()
		{
			SetEnable(isEnable: true);
		}

		public void Disable()
		{
			SetEnable(isEnable: false);
		}

		public void SetEnable(bool isEnable)
		{
			m_isActive = isEnable;
			m_thisGameObject.SetActive(isEnable);
		}

		public void SetAlpha(float alpha)
		{
			m_fader.SetModelAlpha(alpha);
		}

		public void StartFade(float targetAlpha, float duration = 0.3f, Action onFadeEnd = null)
		{
			if (duration <= 0f)
			{
				m_fader.SetModelAlpha(targetAlpha);
				onFadeEnd?.Invoke();
			}
			else
			{
				m_onEndFadeSentAction = onFadeEnd;
				m_fader.StartFade(targetAlpha, duration, m_onEndFade);
				StopShake();
			}
		}

		public void StartFadeWithChangeActive(float targetAlpha, bool isActivate, float duration = 0.3f)
		{
			if (duration <= 0f)
			{
				m_fader.SetModelAlpha(targetAlpha);
				SetEnable(isActivate);
			}
			else
			{
				m_isEnableOnFadeEnd = isActivate;
				m_fader.StartFade(targetAlpha, duration, m_onEndFadeSetEnable);
				StopShake();
			}
		}

		private void OnFadeEndSetEnable()
		{
			SetEnable(m_isEnableOnFadeEnd);
		}

		public void PlayPingPongFade(float duration = 0.3f, Action onStartFadeEnd = null, Action onFadeEnd = null)
		{
			StopShake();
			m_onStartFadeEndSentAction = onStartFadeEnd;
			m_onEndFadeSentAction = onFadeEnd;
			m_fadeDurationOnAction = duration;
			m_fader.StartFade(0.3f, duration, m_onStartFadeEnd);
		}

		private void OnStartFadeEnd()
		{
			if (m_onStartFadeEndSentAction != null)
			{
				m_onStartFadeEndSentAction();
			}
			m_fader.StartFade(1f, m_fadeDurationOnAction, m_onEndFade);
		}

		private void OnFadeEnd()
		{
			if (m_onEndFadeSentAction != null)
			{
				m_onEndFadeSentAction();
				m_onEndFadeSentAction = null;
			}
			if (m_isHoldShakeOnFade)
			{
				ProcessShake();
				m_isHoldShakeOnFade = false;
			}
		}

		public void InitializeShake()
		{
			StopShake();
			m_hasMoved = false;
			m_shakeTweener = Transform.DOShakePosition(1.05f, _SHAKE_AMOUNT, 1, 90f, snapping: false, fadeOut: false).SetLoops(-1, LoopType.Incremental);
		}

		public void Shake()
		{
			if (m_fader.IsFading)
			{
				m_isHoldShakeOnFade = true;
				StopShake();
			}
			else
			{
				ProcessShake();
			}
		}

		private void ProcessShake()
		{
			if (m_shakeTweener == null || m_hasMoved)
			{
				InitializeShake();
			}
			else
			{
				TweenExtensions.Play(m_shakeTweener);
			}
		}

		public void StopShake()
		{
			if (m_shakeTweener != null)
			{
				TweenExtensions.Pause(m_shakeTweener);
			}
		}

		public void SetMoveFlag()
		{
			m_hasMoved = true;
		}
	}
	public class MemoryCharaManager : ResourceDataLoader<AdvMemoryChara>
	{
		private List<AdvMemoryChara> m_charaList;

		public override bool IsLoading
		{
			get
			{
				if (base.IsLoading)
				{
					return true;
				}
				return m_charaList.Exists((AdvMemoryChara chara) => !chara.IsReady);
			}
		}

		public MemoryCharaManager()
			: base(isUnload: false)
		{
			m_charaList = new List<AdvMemoryChara>();
		}

		protected override string CreateFilePath(int id)
		{
			return StringUtility.Format("{0}{1}", "MemoryChara/", id);
		}

		protected override void OnDataRemoved(int id)
		{
			IChara chara = FindChara(id);
			m_charaList.Remove(chara as AdvMemoryChara);
			chara.Destroy();
			chara = null;
			base.OnDataRemoved(id);
		}

		protected override void OnLoadComplete(Data data)
		{
			AdvMemoryChara advMemoryChara = UnityEngine.Object.Instantiate(data.LoadData);
			advMemoryChara.Setup(data.ID);
			advMemoryChara.transform.SetParent(SingletonMonoBehaviour<CharactersManager>.Instance.m_transform);
			m_charaList.Add(advMemoryChara);
		}

		public override void Clear()
		{
			int count = m_charaList.Count;
			for (int i = 0; i < count; i++)
			{
				UnityEngine.Object.Destroy(m_charaList[i].Object);
			}
			m_charaList.Clear();
			base.Clear();
		}

		public AdvMemoryChara FindChara(GameDefine.CharaID id)
		{
			return FindCharaByID(id);
		}

		public AdvMemoryChara FindChara(int id)
		{
			return FindCharaByID((GameDefine.CharaID)id);
		}

		public AdvMemoryChara FindCharaType(GameDefine.CharaID id)
		{
			if (GameDefine.IsUnknownChara(id))
			{
				id = GameDefine.UnknownToCharaID(id);
			}
			return FindCharaByID(id);
		}

		private AdvMemoryChara FindCharaByID(GameDefine.CharaID id)
		{
			int count = m_charaList.Count;
			for (int i = 0; i < count; i++)
			{
				if (IsSamePerson(m_charaList[i].ID, id))
				{
					return m_charaList[i];
				}
			}
			return null;
		}

		private bool IsSamePerson(GameDefine.CharaID left, GameDefine.CharaID right)
		{
			int num = Mathf.CeilToInt((int)left / 100);
			int num2 = Mathf.CeilToInt((int)right / 100);
			return num == num2;
		}

		public void SetTalkChara(GameDefine.CharaID id)
		{
			int count = m_charaList.Count;
			for (int i = 0; i < count; i++)
			{
				if (IsSamePerson(id, m_charaList[i].ID))
				{
					m_charaList[i].Shake();
				}
				else
				{
					m_charaList[i].StopShake();
				}
			}
		}
	}
	public class MemoryModeManager
	{
		private MemoryCharaManager m_charaManager;

		private TimelinePlayer m_timeline;

		private bool m_wasAnimationLimit;

		public bool IsPlaying { get; private set; }

		public bool IsLoading => m_charaManager.IsLoading;

		public MemoryModeManager(TimelinePlayer owner)
		{
			m_wasAnimationLimit = false;
			IsPlaying = false;
			m_timeline = owner;
			m_charaManager = new MemoryCharaManager();
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Where((int _) => IsPlaying || IsLoading).Subscribe(delegate
			{
				End();
			}).AddTo(owner.gameObject);
		}

		public void Load(List<int> preloadIndexes)
		{
			m_charaManager.Load(preloadIndexes);
		}

		public void Clear()
		{
			m_charaManager.Clear();
		}

		public void OnScenarioEnd()
		{
		}

		public void Play(AdvBackgroundMemory.SpotlightTypes spotlightType)
		{
			if (!IsPlaying)
			{
				IsPlaying = true;
			}
			m_timeline.MessageProcessor.IsMemoryMode = true;
			m_timeline.MessageProcessor.IsEmitSoundOnMessage = IsPlaying;
			SetupSpotlight(spotlightType);
			m_wasAnimationLimit = SingletonMonoBehaviour<CharactersManager>.Instance.IsLimitAnimatableChara;
			SingletonMonoBehaviour<CharactersManager>.Instance.SetAnimationLimitation(isLimit: false);
		}

		private void SetupSpotlight(AdvBackgroundMemory.SpotlightTypes spotlightType)
		{
			if (!(m_timeline.CurrentBackground == null))
			{
				(m_timeline.CurrentBackground as AdvBackgroundMemory).SetSpotlightType(spotlightType);
			}
		}

		public void End()
		{
			IsPlaying = false;
			m_timeline.MessageProcessor.IsMemoryMode = false;
			m_timeline.MessageProcessor.IsEmitSoundOnMessage = IsPlaying;
			m_charaManager.Clear();
			SingletonMonoBehaviour<CharactersManager>.Instance.SetAnimationLimitation(m_wasAnimationLimit);
		}

		public AdvMemoryChara FindChara(GameDefine.CharaID id)
		{
			return m_charaManager.FindChara(id);
		}

		public AdvMemoryChara FindCharaType(GameDefine.CharaID id)
		{
			return m_charaManager.FindCharaType(id);
		}

		public void SetTalkChara(GameDefine.CharaID id)
		{
			m_charaManager.SetTalkChara(id);
		}
	}
	public class CharaChangeSequence : MonoBehaviour
	{
		[SerializeField]
		private TextMesh m_text;

		private Transform m_transform;

		private IFader m_fader;

		private void Start()
		{
			m_fader = SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;
			m_transform = base.transform;
			m_text.text = SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID.ToString();
			m_fader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, 1.5f, isDeactivateOnEnd: false, delegate
			{
				ChangeChara();
			});
		}

		private void ChangeChara()
		{
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacterToNext();
			m_text.text = SingletonMonoBehaviour<LocalData>.Instance.NextCharaID.ToString();
			m_transform.DOLocalMove(m_transform.localPosition, 1f).OnComplete(delegate
			{
				m_fader.StartReverseFade(delegate
				{
					End();
				});
			});
		}

		private void End()
		{
			SpecialSceneHelper.EndSpecialScene();
		}
	}
	public class VideoPreloader : MonoBehaviour
	{
		[Header("External Components")]
		[SerializeField]
		private AdvCutScene _cutScene;

		[SerializeField]
		private VideoPlayer _videoPlayer;

		private void Start()
		{
			StartPrepareVideo();
			_cutScene.StartTimelineObservable.Subscribe(delegate
			{
				OnStartTimeline();
			});
		}

		private void StartPrepareVideo()
		{
			if (!_videoPlayer.isPrepared)
			{
				_videoPlayer.Prepare();
			}
		}

		private void OnStartTimeline()
		{
			if (!_videoPlayer.isPrepared)
			{
				_cutScene.AddPauseRequest(this);
				Observable.FromEvent<VideoPlayer.EventHandler, VideoPlayer>((Action<VideoPlayer> h) => h.Invoke, delegate(VideoPlayer.EventHandler h)
				{
					_videoPlayer.prepareCompleted += h;
				}, delegate(VideoPlayer.EventHandler h)
				{
					_videoPlayer.prepareCompleted -= h;
				}).Take(1).Subscribe(delegate
				{
					OnEndPrepareVideo();
				})
					.AddTo(base.gameObject);
			}
		}

		private void OnEndPrepareVideo()
		{
			_cutScene.RemovePauseRequest(this);
		}
	}
	public class TitleBackground : MonoBehaviour
	{
		[Header("Parameters - Camera")]
		[SerializeField]
		private Color _clearColor = Color.white;

		[Header("Parameters - Fog")]
		[SerializeField]
		private bool _enableFog;

		[SerializeField]
		private Color _fogColor = Color.white;

		[SerializeField]
		private float _fogStart;

		[SerializeField]
		private float _fogEnd;

		private void Start()
		{
			if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
			{
				SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag).Take(1).Subscribe(delegate
				{
					ApplyBackgroundParameters();
				})
					.AddTo(base.gameObject);
			}
			else
			{
				ApplyBackgroundParameters();
			}
		}

		private void ApplyBackgroundParameters()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(_clearColor);
			RenderSettings.fog = _enableFog;
			if (_enableFog)
			{
				RenderSettings.fogColor = _fogColor;
				RenderSettings.fogStartDistance = _fogStart;
				RenderSettings.fogEndDistance = _fogEnd;
			}
		}
	}
	public class ChapterSelectButton : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _buttonComponent;

		[SerializeField]
		private TextMeshProUGUI _textComponent;

		[SerializeField]
		private LocalizerChapterText _localizer;

		[Header("Parameters")]
		[SerializeField]
		private Material _fontNormal;

		[SerializeField]
		private Material _fontFocused;

		public MenuButtonFloater Button => _buttonComponent;

		public TextMeshProUGUI Label => _textComponent;

		public int StartSequence { get; set; }

		private void Start()
		{
			_buttonComponent.OnFocusStart.Subscribe(delegate
			{
				_textComponent.fontSharedMaterial = _fontFocused;
			});
			_buttonComponent.OnFocusEnd.Subscribe(delegate
			{
				_textComponent.fontSharedMaterial = _fontNormal;
			});
		}

		public void SetPrefixText(string str)
		{
			_localizer.PrefixText = str;
		}

		public void SetLocalizeKey(string key)
		{
			_localizer.LocalizeKey = key;
		}
	}
	public class ChapterSelectGroup : MonoBehaviour
	{
		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private ChapterSelectButton _prefabButton;

		[Header("Components")]
		[SerializeField]
		private TextMeshProUGUI _headerText;

		[Header("Parameters")]
		[SerializeField]
		private ScenarioListData.Categories _category;

		private NewGameData.ChapterSetting[] _chapterSettings;

		private Subject<NewGameData.ChapterSetting> _subjectChapterSelected = new Subject<NewGameData.ChapterSetting>();

		public ISoundableMenu SoundableMenu { get; set; }

		public IObservable<NewGameData.ChapterSetting> ChapterSelectedObservable => _subjectChapterSelected;

		private void Start()
		{
			if (CheckAvailable())
			{
				MakeInstances();
			}
			else
			{
				base.gameObject.SetActive(value: false);
			}
		}

		private bool CheckAvailable()
		{
			if (_prefabButton == null)
			{
				return false;
			}
			_chapterSettings = ChapterChecker.GetChapterListData(_category);
			if (ChapterChecker.IsHiddenChapterRevealed)
			{
				return true;
			}
			NewGameData.ChapterSetting[] chapterSettings = _chapterSettings;
			foreach (NewGameData.ChapterSetting chapterSetting in chapterSettings)
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag(chapterSetting.ConditionToSelect))
				{
					return true;
				}
			}
			return false;
		}

		private void MakeInstances()
		{
			if (_headerText != null)
			{
				_headerText.text = ChapterChecker.GetChapterCategoryString(_category);
			}
			NewGameData.ChapterSetting[] chapterSettings = _chapterSettings;
			foreach (NewGameData.ChapterSetting chapterSetting in chapterSettings)
			{
				ChapterSelectButton chapterSelectButton = UnityEngine.Object.Instantiate(_prefabButton, base.transform, worldPositionStays: false);
				if (!chapterSetting.IgnoreListUp && (ChapterChecker.IsHiddenChapterRevealed || SingletonMonoBehaviour<GameData>.Instance.GetFlag(chapterSetting.ConditionToSelect)))
				{
					NewGameData.ChapterSetting chapScoped = chapterSetting;
					if (!SingletonMonoBehaviour<GameData>.Instance.GetFlag(chapterSetting.ConditionToSelect))
					{
						chapterSelectButton.SetLocalizeKey("ChapterNameHidden");
						chapterSelectButton.Button.HideIfDisabled = false;
						chapterSelectButton.Button.ToggleEnabled(flag: false);
						chapterSelectButton.Button.PressDownErrorObservable.Subscribe(delegate
						{
							if (SoundableMenu != null)
							{
								SoundableMenu.PlaySeError();
							}
						}).AddTo(base.gameObject);
						continue;
					}
					if (_category == ScenarioListData.Categories.Special)
					{
						chapterSelectButton.SetLocalizeKey(ChapterChecker.GetSpecialSceneLocalizeKey(chapterSetting.Index));
					}
					else
					{
						chapterSelectButton.SetPrefixText(ChapterChecker.GetChapterNumber(chapterSetting.Category, chapterSetting.Index) + ". ");
						chapterSelectButton.SetLocalizeKey(ChapterChecker.GetChapterLocalizeKey((int)_category, chapterSetting.Index));
					}
					chapterSelectButton.StartSequence = chapterSetting.StartSqid;
					chapterSelectButton.Button.ClickObservable.Subscribe(delegate
					{
						_subjectChapterSelected.OnNext(chapScoped);
					});
					chapterSelectButton.Button.AcceptedForcusObservable.Subscribe(delegate
					{
						if (SoundableMenu != null)
						{
							SoundableMenu.PlaySeSelect();
						}
					}).AddTo(base.gameObject);
				}
				else
				{
					chapterSelectButton.Button.ToggleEnabled(flag: false);
				}
			}
		}

		public void MoveByLocalPosition(float rotateFactor, float posZFactor)
		{
			Vector3 localPosition = base.transform.localPosition;
			Quaternion localRotation = Quaternion.Euler(0f, localPosition.x * rotateFactor, 0f);
			localPosition.z = (Mathf.Cos(localPosition.x * rotateFactor * ((float)Math.PI / 180f)) - 1f) * posZFactor;
			base.transform.localRotation = localRotation;
			base.transform.localPosition = localPosition;
		}
	}
	public class LanguageSelectButton : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _buttonComponent;

		[SerializeField]
		private TextMeshProUGUI _textComponent;

		public MenuButtonFloater Button => _buttonComponent;

		public TextMeshProUGUI Label => _textComponent;

		public GameDefine.Languages targetLang { get; set; }

		private void Start()
		{
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Subscribe(delegate(GameDefine.Languages lang)
			{
				_buttonComponent.ToggleEnabled(targetLang != lang);
			}).AddTo(base.gameObject);
		}
	}
	public class LocalizerChapterText : LocalizerUGUIText
	{
		public string PrefixText { get; set; }

		protected override void UpdateLocalize(GameDefine.Languages lang)
		{
			_target.text = PrefixText + base.LocalizeParent.GetLocalizeString(base.LocalizeKey, lang);
		}
	}
	public class TitleAudioComponent : MonoBehaviour
	{
		public enum ClipName
		{
			GameStart,
			Select,
			Decide,
			Cancel,
			MAX
		}

		[SerializeField]
		private AudioSource _source;

		[SerializeField]
		private AudioClip _bgmClip;

		[SerializeField]
		[EnumLabel(typeof(ClipName))]
		private AudioClip[] _clips;

		[SerializeField]
		private float _bgmVolume = 1f;

		public void PlayTitleBGM()
		{
			SoundManager.Bgm.PlaySimple(_bgmClip, _bgmVolume, _bgmClip.length * 0.5f);
		}

		public void PlayBGM(AudioClip bgmClip)
		{
			SoundManager.Bgm.PlaySimple(bgmClip, _bgmVolume, bgmClip.length * 0.5f);
		}

		public void StopTitleBGM(float fadeTime = -1f)
		{
			SoundManager.Bgm.StopSimple(fadeTime);
		}

		public void PlaySound(ClipName cname)
		{
			AudioClip clip = _clips[(int)cname];
			SoundManager.SE.PlayClip(clip, SingletonMonoBehaviour<GameData>.Instance.ConfigData.SeVolume.Value, _source);
		}
	}
	[DisallowMultipleComponent]
	public class TitleBackgroundLoader : MonoBehaviour
	{
		[Serializable]
		public class TitleBackParam
		{
			public GameFlags TargetFlag;

			public bool FlagEquals;

			public SceneDefine SceneToLoad;

			[Expandable]
			[Preview]
			public AudioClip TitleBGM;

			public Sprite LogoSprite;
		}

		[SerializeField]
		private TitleAudioComponent _audio;

		[SerializeField]
		private List<TitleBackParam> _backgrounds;

		private TitleBackParam _targetParam;

		private bool _backgroundLoaded;

		private AsyncSubject<TitleBackParam> _subjectLoadedBackground = new AsyncSubject<TitleBackParam>();

		public IObservable<TitleBackParam> OnLoadedBackground => _subjectLoadedBackground;

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.OnBeforeTransition.Where((Scene scene) => _backgroundLoaded && scene.buildIndex == base.gameObject.scene.buildIndex).Subscribe(delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.UnloadSceneAsync(_targetParam.SceneToLoad, delegate
				{
				});
				_backgroundLoaded = false;
			}).AddTo(base.gameObject);
			OnLoadedBackground.Where((TitleBackParam param) => param != null && param.TitleBGM != null).Subscribe(delegate(TitleBackParam param)
			{
				PlayTitleBGM(param.TitleBGM);
			});
		}

		public void StartTitleBackLoad()
		{
			_targetParam = _backgrounds.FindLast((TitleBackParam param) => SingletonMonoBehaviour<GameData>.Instance.GetFlag(param.TargetFlag) == param.FlagEquals);
			if (_targetParam == null)
			{
				Observable.NextFrame().Subscribe(delegate
				{
					_subjectLoadedBackground.OnNext(null);
					_subjectLoadedBackground.OnCompleted();
				});
				return;
			}
			SingletonMonoBehaviour<TransitionManager>.Instance.AddSceneAsyncAsObservable(_targetParam.SceneToLoad).Subscribe(delegate
			{
				_backgroundLoaded = true;
				_subjectLoadedBackground.OnNext(_targetParam);
				_subjectLoadedBackground.OnCompleted();
			});
		}

		private void PlayTitleBGM(AudioClip bgmClip)
		{
			_audio.PlayBGM(bgmClip);
		}
	}
	[DisallowMultipleComponent]
	public class MainTitleManager : SingletonMonoBehaviour<MainTitleManager>
	{
		private enum TitleState
		{
			Initalize,
			IntroFadeIn,
			FadeOutToScene,
			Main,
			WaitForMenu,
			End,
			MAX
		}

		[Header("Components - Genaral")]
		[SerializeField]
		private TitleMenuController _menuManager;

		[SerializeField]
		private TitleAudioComponent _audioComponent;

		[SerializeField]
		private TitleBackgroundLoader _background;

		[SerializeField]
		private SpriteRenderer _logoSprite;

		[Header("Parameters - Fades")]
		[SerializeField]
		private float _fadeInTime = 0.5f;

		[SerializeField]
		private float _fadeOutTime = 2.25f;

		[SerializeField]
		private float _bgmFadeTime = 1.5f;

		private TitleState _state;

		public TitleAudioComponent AudioComponent => _audioComponent;

		private UIFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		private void Start()
		{
			TitleInitialize();
			MakeSubscribe();
		}

		private void TitleInitialize()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.AddLaserNeed(this);
			_background.StartTitleBackLoad();
		}

		private void OnBeforeEndMenu()
		{
			_menuManager.ToggleInteractable(flag: false);
			SingletonMonoBehaviour<PlayAreaManager>.Instance.RemoveLaserNeed(this);
		}

		protected override void ShutdownOnDestroy()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.RemoveLaserNeed(this);
		}

		private void MakeSubscribe()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Subscribe(delegate(bool flag)
			{
				OnMenuToggled(flag);
			}).AddTo(base.gameObject);
			_background.OnLoadedBackground.Subscribe(delegate(TitleBackgroundLoader.TitleBackParam param)
			{
				_logoSprite.sprite = param.LogoSprite;
				if (SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
				{
					SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Where((bool flag) => !flag).Take(1).Subscribe(delegate
					{
						TitleInitializeDelay();
					})
						.AddTo(base.gameObject);
				}
				else
				{
					TitleInitializeDelay();
				}
			});
		}

		private void OnMenuToggled(bool flag)
		{
			_menuManager.ToggleInteractable(!flag);
		}

		private void TitleInitializeDelay()
		{
			Fader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, _fadeInTime, isDeactivateOnEnd: true);
			_menuManager.ToggleInteractable(flag: true);
		}

		public void PlaySound(TitleAudioComponent.ClipName clipname)
		{
			_audioComponent.PlaySound(clipname);
		}

		public void ReserveNewGame()
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, StartNewGame);
			OnBeforeEndMenu();
		}

		public void ReserveContinueGame()
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, StartContinueGame);
			OnBeforeEndMenu();
		}

		public void ReserveSqidGame(int sqid)
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.StartScenario(sqid);
			});
			OnBeforeEndMenu();
		}

		public void ReserveLoadGame(int fileId)
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioFromFile(fileId);
			});
			OnBeforeEndMenu();
		}

		public void ReserveBonusScene(SceneDefine scene)
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, delegate
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(scene);
			});
			OnBeforeEndMenu();
		}

		public void ReserveEndGame()
		{
			_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
			_audioComponent.StopTitleBGM(_bgmFadeTime);
			Fader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, _fadeOutTime, isDeactivateOnEnd: false, QuitGame);
			OnBeforeEndMenu();
		}

		public void OpenLoadMenu()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Load);
		}

		public void OpenConfigMenu()
		{
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Config);
		}

		private void StartNewGame()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenario(SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetNewGameSqid());
		}

		private void StartContinueGame()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenarioFromAutoSave();
		}

		private void QuitGame()
		{
			UnityEngine.Application.Quit();
		}
	}
	public class SubTitleMenuChapter : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private ChapterSelectGroup[] _chapterSelectGroups;

		[Header("Parameters")]
		[SerializeField]
		private float _posZFactor;

		[SerializeField]
		private float _rotateFactor;

		[SerializeField]
		private string _confirmKeyNormal = "ConfirmChapter";

		[SerializeField]
		private string _confirmKeyExtra = "ConfirmExtra";

		private IObservable<NewGameData.ChapterSetting> _obChapterSelected;

		protected override void SubmenuStart()
		{
			ChapterSelectGroup[] chapterSelectGroups = _chapterSelectGroups;
			foreach (ChapterSelectGroup chapterSelectGroup in chapterSelectGroups)
			{
				if (_obChapterSelected == null)
				{
					_obChapterSelected = chapterSelectGroup.ChapterSelectedObservable;
				}
				else
				{
					_obChapterSelected = _obChapterSelected.Merge(chapterSelectGroup.ChapterSelectedObservable);
				}
				chapterSelectGroup.SoundableMenu = base.SoundableMenu;
			}
			_obChapterSelected = _obChapterSelected.Share();
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			_obChapterSelected.Subscribe(delegate(NewGameData.ChapterSetting chap)
			{
				string localizeString;
				string localizeString2;
				if (chap.Category == ScenarioListData.Categories.Special)
				{
					localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(ChapterChecker.GetSpecialSceneLocalizeKey(chap.Index));
					localizeString2 = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_confirmKeyExtra);
				}
				else
				{
					localizeString = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(ChapterChecker.GetChapterLocalizeKey((int)chap.Category, chap.Index));
					localizeString2 = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_confirmKeyNormal);
				}
				ToggleInterractable(flag: false);
				OpenConfirm(string.Format(localizeString2, localizeString), delegate(bool flag)
				{
					if (!flag)
					{
						ToggleInterractable(flag: true);
					}
					else
					{
						OnConfirmed(chap);
					}
				});
			});
		}

		protected override void OnOpenMenu()
		{
			ChapterSelectGroup[] chapterSelectGroups = _chapterSelectGroups;
			for (int i = 0; i < chapterSelectGroups.Length; i++)
			{
				chapterSelectGroups[i].MoveByLocalPosition(_rotateFactor, _posZFactor);
			}
		}

		private void OnConfirmed(NewGameData.ChapterSetting chap)
		{
			if (chap.StartSqid == -1)
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveBonusScene(chap.BonusScene);
			}
			else
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveSqidGame(chap.StartSqid);
			}
		}
	}
	public class SubTitleMenuConfirm : SubMenuConfirm
	{
	}
	public class SubTitleMenuContinue : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _buttonContinue;

		[SerializeField]
		private TextMeshProUGUI _textLabel;

		[SerializeField]
		private Image _imageThumgnail;

		private bool _uiInitialized;

		protected override void SubmenuStart()
		{
			_buttonContinue.ClickObservable.Subscribe(delegate
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveContinueGame();
			});
			_buttonContinue.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
			_buttonContinue.PressDownErrorObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeError();
				}
			}).AddTo(base.gameObject);
		}

		protected override void OnOpenMenu()
		{
			if (!_uiInitialized)
			{
				_uiInitialized = true;
				UpdateFileInfos();
			}
		}

		private void UpdateFileInfos()
		{
			GameFileSave.Header header = SingletonMonoBehaviour<GameData>.Instance.FindHeaders()[0];
			if (header.IsEmpty || header.IsCorrupted)
			{
				if (header.IsCorrupted)
				{
					_textLabel.text = "<sprite=0><sprite=0><sprite=0><sprite=0><sprite=0>";
				}
				else
				{
					_textLabel.text = "No Auto Save";
				}
				_imageThumgnail.enabled = false;
				_buttonContinue.ToggleEnabled(flag: false);
				_buttonContinue.ButtonComponent.targetGraphic.color = ColorDefine.White.WithAlpha(0.5f);
			}
			else
			{
				_textLabel.text = ChapterChecker.GetFormattedChapterNumber(header.SequenceID);
				if (IsNoThumbSequence(header.SequenceID))
				{
					_imageThumgnail.enabled = false;
					return;
				}
				_imageThumgnail.sprite = FindSaveThumbnailSprite(header.SequenceID);
				_imageThumgnail.enabled = _imageThumgnail.sprite != null;
			}
		}

		private Sprite FindSaveThumbnailSprite(int id)
		{
			Sprite sprite = SingletonMonoBehaviour<DataManager>.Instance.FindSaveThumbnailSprite(id);
			if (sprite == null)
			{
				return null;
			}
			return sprite;
		}

		private bool IsNoThumbSequence(int sqid)
		{
			if (sqid != 10000)
			{
				return sqid == 20000;
			}
			return true;
		}
	}
	public class SubTitleMenuFile : SubMenuFile
	{
		protected override void StartLoadGame(int fileId)
		{
			SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveLoadGame(fileId);
		}
	}
	public class SubTitleMenuLanguage : SubMenuBase
	{
		private const string KeyLanguage = "Language";

		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private LanguageSelectButton _prefabButton;

		[Header("Components")]
		[SerializeField]
		private Transform _targetAttach;

		private bool _isConfigValueChanged;

		private IObservable<GameDefine.Languages> _obSelected;

		protected override void SubmenuStart()
		{
			for (int i = 0; i < 5; i++)
			{
				GameDefine.Languages language = (GameDefine.Languages)i;
				if (!CheckAvailableLanguage(language))
				{
					continue;
				}
				LanguageSelectButton languageSelectButton = UnityEngine.Object.Instantiate(_prefabButton, _targetAttach, worldPositionStays: false);
				languageSelectButton.targetLang = language;
				languageSelectButton.Label.text = GetLanguageString(language);
				IObservable<GameDefine.Languages> observable = languageSelectButton.Button.ClickObservable.Select((Unit _) => language);
				if (_obSelected == null)
				{
					_obSelected = observable;
				}
				else
				{
					_obSelected = _obSelected.Merge(observable);
				}
				languageSelectButton.Button.ClickObservable.Subscribe(delegate
				{
					if (base.SoundableMenu != null)
					{
						base.SoundableMenu.PlaySeDecide();
					}
				}).AddTo(base.gameObject);
				languageSelectButton.Button.AcceptedForcusObservable.Subscribe(delegate
				{
					if (base.SoundableMenu != null)
					{
						base.SoundableMenu.PlaySeSelect();
					}
				}).AddTo(base.gameObject);
			}
			_obSelected = _obSelected.Share();
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			_obSelected.Subscribe(delegate(GameDefine.Languages language)
			{
				SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value = language;
				_isConfigValueChanged = true;
			});
		}

		private bool CheckAvailableLanguage(GameDefine.Languages lang)
		{
			if (GameDefine.IsLanguageImplemented(lang))
			{
				return !SingletonMonoBehaviour<PlayAreaManager>.Instance.IsLanguageProhibited(lang);
			}
			return false;
		}

		private string GetLanguageString(GameDefine.Languages lang)
		{
			return SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString("Language", lang);
		}

		protected override void OnCloseMenu()
		{
			if (_isConfigValueChanged)
			{
				SingletonMonoBehaviour<GameData>.Instance.SaveConfigData();
				_isConfigValueChanged = false;
			}
		}
	}
	public class SubTitleMenuNewGame : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _theButton;

		private bool IsFirstBoot => !SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.Route1Chapter0);

		protected override void SubmenuStart()
		{
			if (IsFirstBoot)
			{
				_theButton.ClickObservable.Subscribe(delegate
				{
					SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveNewGame();
					CloseMenu();
				});
				_theButton.AcceptedForcusObservable.Subscribe(delegate
				{
					if (base.SoundableMenu != null)
					{
						base.SoundableMenu.PlaySeSelect();
					}
				}).AddTo(base.gameObject);
			}
			else
			{
				_theButton.gameObject.SetActive(value: false);
			}
		}
	}
	public class SubTitleMenuQuit : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _theButton;

		protected override void SubmenuStart()
		{
			_theButton.ClickObservable.Subscribe(delegate
			{
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveEndGame();
				CloseMenu();
			});
			_theButton.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}
	}
	public class SubTitleMenuSkipNotify : SubMenuBase
	{
		[Header("Components")]
		[SerializeField]
		private MenuButtonFloater _theButton;

		protected override void SubmenuStart()
		{
			_theButton.ClickObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeDecide();
				}
				SingletonMonoBehaviour<GameData>.Instance.SetFlag(GameFlags.SkipNoifyShowed, value: true);
				SingletonMonoBehaviour<MainTitleManager>.Instance.ReserveContinueGame();
			});
			_theButton.AcceptedForcusObservable.Subscribe(delegate
			{
				if (base.SoundableMenu != null)
				{
					base.SoundableMenu.PlaySeSelect();
				}
			}).AddTo(base.gameObject);
		}

		protected override void OnCloseMenu()
		{
		}
	}
	public class TitleMenuController : MonoBehaviour, ISoundableMenu
	{
		private enum TitleMenuType
		{
			Continue,
			Load,
			Chapter,
			Config,
			Language,
			Quit,
			NewGame,
			Help,
			SkipNotify,
			MAX
		}

		[Header("Components - General")]
		[SerializeField]
		private MainTitleManager _mainTitle;

		[SerializeField]
		private CanvasGroup _canvasGroup;

		[SerializeField]
		private AudioSource _uiSoundSource;

		[SerializeField]
		private Animator _animatorLogo;

		[Header("Components - Submenus")]
		[SerializeField]
		[EnumLabel(typeof(TitleMenuType))]
		private MenuButtonFloater[] _titleButtons;

		[SerializeField]
		[EnumLabel(typeof(TitleMenuType))]
		private SubMenuBase[] _submenus;

		[Header("Components - Confirm")]
		[SerializeField]
		private SubMenuConfirm _subMenuConfirm;

		[Header("Components - Special")]
		[SerializeField]
		private GameObject _primaryMenuSetNormal;

		[SerializeField]
		private GameObject _primaryMenuSetFirst;

		[SerializeField]
		private GameObject _secondaryMenuSetNormal;

		[Header("Marameters")]
		[SerializeField]
		private TitleMenuType _initialSubMenu;

		[SerializeField]
		private TitleMenuType _initialSubMenuFirst;

		[SerializeField]
		private TitleMenuType _initialSubMenuContinuous;

		[SerializeField]
		private TitleMenuType _initialSubMenuSkipNotify;

		private TitleMenuType _currentInitialMenu = TitleMenuType.MAX;

		private TitleMenuType _currentSubMenu = TitleMenuType.MAX;

		private bool IsFirstBoot => !SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.Route1Chapter0);

		private bool IsSkipNotifyNeeded
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingNormal))
				{
					return !SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.SkipNoifyShowed);
				}
				return false;
			}
		}

		private bool IsSessionTitleShowed
		{
			get
			{
				return SingletonMonoBehaviour<LocalData>.Instance.IsSessionTitleShowed;
			}
			set
			{
				SingletonMonoBehaviour<LocalData>.Instance.IsSessionTitleShowed = value;
			}
		}

		public bool IsOpenedConfirm => _subMenuConfirm.IsVisible;

		public bool IsRootMenu
		{
			get
			{
				if (_currentSubMenu != TitleMenuType.NewGame && _currentSubMenu != TitleMenuType.SkipNotify)
				{
					return _currentSubMenu == _currentInitialMenu;
				}
				return true;
			}
		}

		private void Start()
		{
			for (int i = 0; i < _titleButtons.Length; i++)
			{
				MenuButtonFloater menuButtonFloater = _titleButtons[i];
				if (!(menuButtonFloater == null) && i < 9)
				{
					TitleMenuType type = (TitleMenuType)i;
					menuButtonFloater.ClickObservable.Subscribe(delegate
					{
						PlaySeDecide();
						OnSelectMenu(type);
					}).AddTo(base.gameObject);
					menuButtonFloater.AcceptedForcusObservable.Subscribe(delegate
					{
						PlaySeSelect();
					}).AddTo(base.gameObject);
				}
			}
			SubMenuBase[] submenus = _submenus;
			foreach (SubMenuBase subMenuBase in submenus)
			{
				if (!(subMenuBase == null))
				{
					subMenuBase.SetSoundableMenu(this);
					subMenuBase.EndSubmenuObservable.Subscribe(delegate
					{
						ToggleSubMenu(_currentInitialMenu);
					});
					subMenuBase.ConfirmRequestedObservable.Subscribe(delegate(SubMenuBase.ConfirmParam conf)
					{
						OpenConfirm(conf);
					});
				}
			}
			_subMenuConfirm.SetSoundableMenu(this);
			if (IsFirstBoot)
			{
				_primaryMenuSetNormal.SetActive(value: false);
				_primaryMenuSetFirst.SetActive(value: true);
				_currentInitialMenu = _initialSubMenuFirst;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenuFirst);
				});
			}
			else if (IsSkipNotifyNeeded)
			{
				IsSessionTitleShowed = true;
				_primaryMenuSetNormal.SetActive(value: false);
				_primaryMenuSetFirst.SetActive(value: false);
				_secondaryMenuSetNormal.SetActive(value: false);
				_currentInitialMenu = _initialSubMenuSkipNotify;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenuSkipNotify);
				});
			}
			else if (!IsSessionTitleShowed)
			{
				IsSessionTitleShowed = true;
				_primaryMenuSetNormal.SetActive(value: true);
				_primaryMenuSetFirst.SetActive(value: false);
				_currentInitialMenu = _initialSubMenuContinuous;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenu);
				});
			}
			else
			{
				_primaryMenuSetNormal.SetActive(value: true);
				_primaryMenuSetFirst.SetActive(value: false);
				_currentInitialMenu = _initialSubMenuContinuous;
				Observable.NextFrame().Subscribe(delegate
				{
					ToggleSubMenu(_initialSubMenuContinuous);
				});
			}
		}

		private void OnSelectMenu(TitleMenuType type)
		{
			if (HasSubMenu(type))
			{
				ToggleSubMenu(type);
			}
			else if (type == TitleMenuType.Config)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Config);
			}
		}

		private void ToggleSubMenu(TitleMenuType type)
		{
			if (_currentSubMenu == type)
			{
				return;
			}
			if (_subMenuConfirm.IsVisible)
			{
				ForceCloseConfirm();
			}
			if (_currentSubMenu != TitleMenuType.MAX)
			{
				MenuButtonFloater selectButton = GetSelectButton(_currentSubMenu);
				if (selectButton != null)
				{
					selectButton.ToggleEnabled(flag: true);
				}
				GetSubMenu(_currentSubMenu).SetVisible(visible: false);
			}
			_currentSubMenu = type;
			_animatorLogo.SetInteger("MenuIndex", (int)type);
			if (_currentSubMenu != TitleMenuType.MAX)
			{
				MenuButtonFloater selectButton2 = GetSelectButton(_currentSubMenu);
				if (selectButton2 != null)
				{
					selectButton2.ToggleEnabled(flag: false);
				}
				GetSubMenu(_currentSubMenu).SetVisible(visible: true);
			}
		}

		private SubMenuBase GetSubMenu(TitleMenuType type)
		{
			return _submenus[(int)type];
		}

		private bool HasSubMenu(TitleMenuType type)
		{
			return _submenus[(int)type] != null;
		}

		private MenuButtonFloater GetSelectButton(TitleMenuType type)
		{
			return _titleButtons[(int)type];
		}

		public void ToggleInteractable(bool flag)
		{
			_canvasGroup.interactable = flag;
			_canvasGroup.blocksRaycasts = flag;
		}

		public void OpenConfirm(SubMenuBase.ConfirmParam conf)
		{
			PlaySeConfirm();
			_subMenuConfirm.SetVisible(visible: true);
			_subMenuConfirm.SetParam(conf);
		}

		public void ForceCloseConfirm()
		{
			_subMenuConfirm.OnCancelButton();
		}

		public void OnPressBackButton()
		{
			if (!IsRootMenu)
			{
				if (IsOpenedConfirm)
				{
					ForceCloseConfirm();
				}
				else if (OnCancelSubMenu())
				{
					PlaySeCancel();
					ToggleSubMenu(_currentInitialMenu);
				}
			}
		}

		private bool OnCancelSubMenu()
		{
			SubMenuBase subMenu = GetSubMenu(_currentSubMenu);
			if (subMenu == null)
			{
				return true;
			}
			return subMenu.OnCancelButton();
		}

		public void PlaySeOpen()
		{
		}

		public void PlaySeClose()
		{
		}

		public void PlaySeSelect()
		{
			_mainTitle.AudioComponent.PlaySound(TitleAudioComponent.ClipName.Select);
		}

		public void PlaySeDecide()
		{
			_mainTitle.AudioComponent.PlaySound(TitleAudioComponent.ClipName.Decide);
		}

		public void PlaySeConfirm()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Confirm, _uiSoundSource);
		}

		public void PlaySeCancel()
		{
			_mainTitle.AudioComponent.PlaySound(TitleAudioComponent.ClipName.Cancel);
		}

		public void PlaySeError()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error, _uiSoundSource);
		}

		public void PlaySePaging()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, _uiSoundSource);
		}

		public void PlaySeScrolling()
		{
			SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Message_Log, _uiSoundSource);
		}
	}
	public class TitleMenuInput : UpdateableComponent
	{
		[SerializeField]
		private TitleMenuController _controller;

		public bool IsRootMenu => _controller.IsRootMenu;

		private GameInputManager input => SingletonMonoBehaviour<GameInputManager>.Instance;

		public override void OnUpdate(float delta)
		{
			if (input.IsMovileDevice)
			{
				if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.DeviceBack))
				{
					if (IsRootMenu)
					{
						input.OnBackFromRoot();
					}
					else
					{
						OnCancelButtonPressed();
					}
				}
				else if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
				{
					OnCancelButtonPressed();
				}
			}
			else if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
			{
				OnCancelButtonPressed();
			}
		}

		public void OnCancelButtonPressed()
		{
			_controller.OnPressBackButton();
		}
	}
	public class TitleVersionText : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshProUGUI m_textMesh;

		[Header("Parameters")]
		[SerializeField]
		private string m_textCopyright = string.Empty;

		[SerializeField]
		private string m_textVersionPrefix = string.Empty;

		private void Start()
		{
			m_textMesh.text = m_textCopyright + "\n" + m_textVersionPrefix + UnityEngine.Application.version;
		}
	}
	public class ChapterEndController : MonoBehaviour
	{
		[Header("External Components")]
		[SerializeField]
		private ChapterEndObject _endObject;

		[Header("Parameters - Time")]
		[SerializeField]
		private float _timeFirstWait = 1.5f;

		[SerializeField]
		private float _timeStartFade = 0.5f;

		[SerializeField]
		private float _timeShowing = 5f;

		[SerializeField]
		private float _timeEndFade = 2f;

		[SerializeField]
		private double _waitBeforeConfirm = 1.0;

		[SerializeField]
		private double _waitAfterSave = 1.0;

		[Header("Parameters - Texts")]
		[SerializeField]
		private string _keyConfirm = "ConfirmEndChapterSave";

		public bool SkipSubtitle;

		public bool SkipConfirm;

		private Subject<Unit> _subjectCompleteStartFade = new Subject<Unit>();

		private Subject<Unit> _subjectCompleteEndFade = new Subject<Unit>();

		private Subject<Unit> _subjectEndConfirm = new Subject<Unit>();

		private void Start()
		{
			_endObject.SetAlpha(0f);
			if (SingletonMonoBehaviour<TransitionManager>.Instance.CurrentScene.buildIndex == base.gameObject.scene.buildIndex)
			{
				EnterSceneDoing();
				Observable.TimerFrame(6).Delay(TimeSpan.FromSeconds(_timeFirstWait)).Subscribe(delegate
				{
					FirstPrepare();
				})
					.AddTo(base.gameObject);
			}
			else
			{
				IObservable<Scene> source = SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Where((Scene scene) => scene.buildIndex == base.gameObject.scene.buildIndex).Share();
				source.Subscribe(delegate
				{
					EnterSceneDoing();
				}).AddTo(base.gameObject);
				source.DelayFrame(6).Delay(TimeSpan.FromSeconds(_timeFirstWait)).Subscribe(delegate
				{
					FirstPrepare();
				})
					.AddTo(base.gameObject);
			}
			_subjectCompleteStartFade.SelectMany(Observable.FromMicroCoroutine((CancellationToken _) => RoutineWaitingShowing())).Subscribe(delegate
			{
				EndFade();
			}).AddTo(base.gameObject);
			_subjectCompleteEndFade.Delay(TimeSpan.FromSeconds(_waitBeforeConfirm)).Subscribe(delegate
			{
				OpenSaveConfirm();
			}).AddTo(base.gameObject);
			_subjectEndConfirm.Delay(TimeSpan.FromSeconds(_waitAfterSave)).Subscribe(delegate
			{
				CleanUp();
			}).AddTo(base.gameObject);
		}

		private void EnterSceneDoing()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ColorDefine.Black);
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
			SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = true;
			SingletonMonoBehaviour<LocalData>.Instance.ChangeCharacter(GameDefine.CharaID.UNKNOWN);
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				MainPosition.MainTransform.position = Vector3.zero;
				MainPosition.MainTransform.rotation = Quaternion.identity;
				MainPosition.WindowPositioner.IsFixedToFront = true;
				MainPosition.WindowPositioner.FrontFixYaw = 0f;
				MainPosition.WindowPositioner.IsFixVertical = false;
			}
			if (SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				FindParameter();
				if (!SkipSubtitle)
				{
					_endObject.SetChapterTextBySqid(InGameManager.Timeline.LoadedScenarioID);
				}
			}
		}

		private void FindParameter()
		{
			if (!(InGameManager.Timeline.WaitingCommand is CommandSceneToChapterEnd commandSceneToChapterEnd))
			{
				UnityEngine.Debug.LogWarning("OOPS: Chapter End Command Not Found");
				return;
			}
			SkipSubtitle = commandSceneToChapterEnd.SkipSubtitle;
			SkipConfirm = commandSceneToChapterEnd.SkipConfirm;
		}

		private void FirstPrepare()
		{
			if (SingletonMonoBehaviour<InGameManager>.HasInstance)
			{
				InGameManager.Timeline.MessageProcessor.SetIndigaterVisible(flag: false);
			}
			if (SkipSubtitle)
			{
				OpenSaveConfirm();
			}
			else
			{
				StartFade();
			}
		}

		private void StartFade()
		{
			_endObject.SetAlpha(1f);
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, _timeStartFade, isDeactivateOnEnd: true, delegate
			{
				_subjectCompleteStartFade.OnNext(Unit.Default);
			});
		}

		private IEnumerator RoutineWaitingShowing()
		{
			Common.Timer _timer = new Common.Timer(_timeShowing);
			while (!_timer.IsTimeUp)
			{
				yield return null;
				_timer.Update(Time.deltaTime);
				if (SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(SingletonMonoBehaviour<GameInputManager>.Instance.CurrentMainHand, VRDeviceDefine.Buttons.MainAction))
				{
					_timer.SetToTimeup();
				}
			}
		}

		private void EndFade()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, _timeEndFade, isDeactivateOnEnd: false, delegate
			{
				_subjectCompleteEndFade.OnNext(Unit.Default);
			});
		}

		private void OpenSaveConfirm()
		{
			if (SkipConfirm)
			{
				CleanUp();
				return;
			}
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu(MainMenuManager.MenuMode.Blank);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OpenConfirm(SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyConfirm), OnDecideConfirm);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Select((bool flag) => !flag).First().Subscribe(delegate
			{
				OnCloseMenu();
			})
				.AddTo(base.gameObject);
		}

		private void OnDecideConfirm(bool isOk)
		{
			if (isOk)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.SetMenuMode(MainMenuManager.MenuMode.Save);
			}
			else
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.CloseMenu();
			}
		}

		private void OnCloseMenu()
		{
			_subjectEndConfirm.OnNext(Unit.Default);
		}

		private void CleanUp()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.IsProhibitByCommand = false;
			}
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				MainPosition.WindowPositioner.IsFixedToFront = false;
			}
			_endObject.SetAlpha(0f);
			SpecialSceneHelper.EndSpecialScene();
		}
	}
	public class ChapterEndObject : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private TextMeshPro _chapterText;

		[SerializeField]
		private SpriteRenderer[] _skinSprite;

		public void SetChapterTextBySqid(int sqid)
		{
			_chapterText.text = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(ChapterChecker.GetChapterLocalizeKey(sqid));
		}

		public void SetAlpha(float alpha)
		{
			int num = _skinSprite.Length;
			for (int i = 0; i < num; i++)
			{
				SpriteRenderer obj = _skinSprite[i];
				obj.color = obj.color.WithAlpha(alpha);
			}
			_chapterText.color = _chapterText.color.WithAlpha(alpha);
		}
	}
	public class ChapterStartController : MonoBehaviour
	{
		[Header("Parameters - Time")]
		[SerializeField]
		private float _intervalShake = 0.08f;

		[SerializeField]
		private float _timeToFadeOut = 5f;

		[SerializeField]
		private float _timeToEnd = 2f;

		private AdvBackground _thisBackground;

		private BaseProp _prop;

		private void Start()
		{
			_thisBackground = GetComponent<AdvBackground>();
			_prop = _thisBackground.DynamicProps.GetPropByIndex(0);
			_prop.SetVisible(flag: true);
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				MainPosition.MainTransform.position = Vector3.zero;
				MainPosition.MainTransform.rotation = Quaternion.identity;
			}
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.TransparentBlack, 0f, isDeactivateOnEnd: true);
			Observable.NextFrame().Subscribe(delegate
			{
				StartAnimations();
			}).AddTo(base.gameObject);
		}

		private void StartAnimations()
		{
			int shakeActionIndex = _prop.GetPropAction("StartShake").Index;
			if (SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID == -1)
			{
				_prop.ActionPropAnimation(1);
			}
			else
			{
				_prop.ActionPropAnimation(ChapterChecker.GetChapter(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID));
			}
			_prop.ActionPropAnimation("FadeIn");
			Observable.Interval(TimeSpan.FromSeconds(_intervalShake)).Subscribe(delegate
			{
				_prop.ActionPropAnimation(shakeActionIndex);
			}).AddTo(base.gameObject);
			Observable.Timer(TimeSpan.FromSeconds(_timeToFadeOut)).First().Subscribe(delegate
			{
				FadeOutToNext();
			})
				.AddTo(base.gameObject);
		}

		private void FadeOutToNext()
		{
			_prop.ActionPropAnimation("FadeOut");
			Observable.Timer(TimeSpan.FromSeconds(_timeToEnd)).First().Subscribe(delegate
			{
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
				SpecialSceneHelper.EndSpecialScene();
			})
				.AddTo(base.gameObject);
		}
	}
	public class ChapterTextProp : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		private Transform _targetMove;

		[SerializeField]
		private TextMeshPro _textComponent;

		[Header("Parameters - Shake")]
		[SerializeField]
		private float _shakeSize = 1.2f;

		private DynamicProp _prop;

		private void Awake()
		{
			_prop = GetComponent<DynamicProp>();
		}

		private void Start()
		{
			int shakeActionIndex = _prop.GetPropAction("StartShake").Index;
			_prop.OnAction.Where((PropActionParam action) => action.Index <= 9).Subscribe(delegate(PropActionParam action)
			{
				_textComponent.text = $"＃{action.Index}™";
			}).AddTo(this);
			_prop.OnAction.Where((PropActionParam action) => action.Index == shakeActionIndex).Subscribe(delegate
			{
				_targetMove.localPosition = new Vector3(_shakeSize * RandomPow4(), _shakeSize * RandomPow4(), 0f);
			}).AddTo(this);
		}

		private float RandomPow4()
		{
			return (UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f) + UnityEngine.Random.Range(0f, 1f)) / 4f - 0.5f;
		}
	}
	public class StartFirstEnding : MonoBehaviour
	{
		[SerializeField]
		private float EndingCameraFarClipPlane = 3000f;

		private Camera MainCamera;

		private float DefaultFarClipPlane;

		private void Start()
		{
			MainCamera = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera;
			DefaultFarClipPlane = MainCamera.farClipPlane;
			MainCamera.farClipPlane = EndingCameraFarClipPlane;
		}

		private void OnDestroy()
		{
			MainCamera.farClipPlane = DefaultFarClipPlane;
		}
	}
	public class FirstHelpPropController : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private DynamicProp _prop;

		[SerializeField]
		private Image _targetImage;

		[SerializeField]
		private TextMeshProUGUI _targetText;

		[Header("Parameters - Key")]
		[SerializeField]
		private string _spriteKeyPrefix = "Help.";

		[SerializeField]
		private string _triggerKey = "Help.TriggerNext";

		private void Start()
		{
			_prop.ChangeVisibleObservable.Where((bool flag) => flag).Take(1).Subscribe(delegate
			{
				string key = _spriteKeyPrefix + SingletonMonoBehaviour<PlayAreaManager>.Instance.CurrentDeviceType;
				_targetImage.sprite = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeSprite(key);
				_targetText.text = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_triggerKey);
			})
				.AddTo(base.gameObject);
		}
	}
	public class FinalKnifeController : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private BaseProp _prop;

		[SerializeField]
		private Collider _knifeCollider;

		private void Awake()
		{
			if (_knifeCollider == null)
			{
				UnityEngine.Debug.LogError("Knife Collider is not defined");
				return;
			}
			_prop.OnAction.Take(1).Subscribe(delegate
			{
				SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.SkipLatestValueOnSubscribe().Subscribe(delegate(VRDeviceDefine.HandType handType)
				{
					AvaterTrackedHandObject avaterTrackedHandObject = null;
					avaterTrackedHandObject = ((handType != 0) ? MainPosition.Avater.AvaterResources.TrackedHandRightObject : MainPosition.Avater.AvaterResources.TrackedHandLeftObject);
					Transform nodeTransform = avaterTrackedHandObject.GetNodeTransform(AvaterTrackedHandObject.Node.TrackedGrabPivot);
					_prop.AttachToTransform(nodeTransform, isStay: false);
				}).AddTo(base.gameObject);
			});
			_prop.OnAction.Take(1).Subscribe(delegate
			{
				_knifeCollider.gameObject.name = "KNIFECOLLIDER";
				Rigidbody rigidbody = base.gameObject.AddComponent<Rigidbody>();
				rigidbody.useGravity = false;
				rigidbody.isKinematic = true;
			});
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Subscribe(delegate(bool isOpen)
				{
					_prop.SetVisible(!isOpen);
				}).AddTo(base.gameObject);
			}
		}
	}
	public class FinalSelectionController : MonoBehaviour
	{
		public enum SelfColliderTypes
		{
			Body,
			HandLeft,
			HandRight
		}

		[Header("Prefabs")]
		[SerializeField]
		[PrefabField]
		private GameObject _prefabNKCollider;

		[SerializeField]
		[PrefabField]
		[EnumLabel(typeof(SelfColliderTypes))]
		private GameObject[] _prefabSelfColliders;

		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private BaseProp _prop;

		[Header("Parameters - Hand Motion")]
		[SerializeField]
		private int _motionIdNormal;

		[SerializeField]
		private int _motionIdSelf;

		[SerializeField]
		private int _motionIdUnequipped;

		[Header("Parameters - For Quest")]
		[SerializeField]
		private float _nkYOffset = -1.6f;

		[SerializeField]
		private float _nkDistance = 0.2f;

		[SerializeField]
		private float _nkScale = 0.2857143f;

		[SerializeField]
		private float _handScale = 0.71428573f;

		[SerializeField]
		private float _motionToggleAngle = 75f;

		private bool _isSelfStabbable;

		private GameObject _obNKCollider;

		private GameObject[] _obSelfColliders;

		private ReactiveProperty<bool> _reactiveSelfPointing;

		private bool IsTrueRouteAvailable
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingTougoku) && SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingKageyama) && SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingMorozumi) && SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingMachikouji))
				{
					return SingletonMonoBehaviour<GameData>.Instance.GetFlag(GameFlags.EndingMomono);
				}
				return false;
			}
		}

		private AvaterTrackedHandObject _trackedHandPrefferedObject
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandRightObject;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandLeftObject;
			}
		}

		private AvaterTrackedHandObject _trackedHandOppositeObject
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandLeftObject;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandRightObject;
			}
		}

		private AvaterTrackedHandLoader _trackedHandPrefferedLoader
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandRightLoader;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandLeftLoader;
			}
		}

		private AvaterTrackedHandLoader _trackedHandOppositeLoader
		{
			get
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value != 0)
				{
					return MainPosition.Avater.AvaterResources.TrackedHandLeftLoader;
				}
				return MainPosition.Avater.AvaterResources.TrackedHandRightLoader;
			}
		}

		private void Awake()
		{
			_prop.OnAction.Where((PropActionParam param) => param.Index == 0).Subscribe(delegate
			{
				_isSelfStabbable = IsTrueRouteAvailable;
				SingletonMonoBehaviour<LocalData>.Instance.LastSelectionIndex = (_isSelfStabbable ? 1 : 0);
			});
			(from param in _prop.OnAction
				where param.Index == 1
				select param into _
				where !SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands
				select _).Subscribe(delegate
			{
				(from index in InGameManager.Timeline.SelectionProcessor.PointerEnterSelectionObservable.TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable)
					where index == 1
					select index).Subscribe(delegate
				{
					MainPosition.Avater.SetRotationEnableWithFade(PlayerAvater.AvaterParts.Hand, PlayerAvater.AvaterTrackTypes.HeadPositionAndRotation, 0.2f);
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(_motionIdSelf, isFade: false, isSkipAnimation: true);
				}).AddTo(base.gameObject);
				(from index in InGameManager.Timeline.SelectionProcessor.PointerExitSelectionObservable.TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable)
					where index == 1
					select index).Subscribe(delegate
				{
					MainPosition.Avater.SetRotationEnableWithFade(PlayerAvater.AvaterParts.Hand, PlayerAvater.AvaterTrackTypes.HandPositionAndRotation, 0.2f);
					MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(_motionIdNormal, isFade: false, isSkipAnimation: true);
				}).AddTo(base.gameObject);
			});
			IObservable<PropActionParam> source = (from param in _prop.OnAction
				where param.Index == 2
				select param into _
				where SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.UseTrackedHands
				select _).Take(1);
			source.Subscribe(delegate
			{
				_reactiveSelfPointing = new ReactiveProperty<bool>(initialValue: false);
				InitNikaidouForQuest();
				InitHandForQuest();
				if (_isSelfStabbable)
				{
					InitKnifePosingUpdationForQuest();
				}
				InGameManager.Timeline.SelectionProcessor.ProhibitLaserInterraction = true;
			});
			source.Delay(TimeSpan.FromSeconds(1.0)).TakeUntilDestroy(base.gameObject).Subscribe(delegate
			{
				InitNKColliderForQuest();
				if (_isSelfStabbable)
				{
					InitSelfColliderForQuest();
				}
			});
		}

		private void InitNikaidouForQuest()
		{
			AdvChara charaNK = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(GameDefine.CharaID.NIKAIDOU);
			if (charaNK == null)
			{
				UnityEngine.Debug.LogError("I cannot find character Nikaidoh");
				return;
			}
			charaNK.Transform.localScale *= _nkScale;
			charaNK.Transform.position = GetNKSpot(_nkYOffset);
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.TakeUntil(this.OnDestroyAsObservable()).Subscribe(delegate
			{
				charaNK.Transform.position = GetNKSpot(_nkYOffset);
			});
			(from _ in this.OnDestroyAsObservable()
				where charaNK != null
				select _).Subscribe(delegate
			{
				charaNK.Transform.localScale = Vector3.one;
			});
		}

		private void InitHandForQuest()
		{
			MainPosition.Avater.AvaterResources.TrackedHandLeftObject.transform.localScale *= _handScale;
			MainPosition.Avater.AvaterResources.TrackedHandLeftObject.IsPreventSleeping = true;
			MainPosition.Avater.AvaterResources.TrackedHandRightObject.transform.localScale *= _handScale;
			MainPosition.Avater.AvaterResources.TrackedHandRightObject.IsPreventSleeping = true;
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Where((VRDeviceDefine.HandType handType) => handType == VRDeviceDefine.HandType.Left).Subscribe(delegate
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.PlayAnimation(GetCurrentMotionId(_reactiveSelfPointing.Value), isFade: false, isSkipAnimation: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(_motionIdUnequipped, isFade: false, isSkipAnimation: true);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Where((VRDeviceDefine.HandType handType) => handType == VRDeviceDefine.HandType.Right).Subscribe(delegate
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.PlayAnimation(_motionIdUnequipped, isFade: false, isSkipAnimation: true);
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.PlayAnimation(GetCurrentMotionId(_reactiveSelfPointing.Value), isFade: false, isSkipAnimation: true);
			}).AddTo(base.gameObject);
			(from _ in this.OnDestroyAsObservable()
				where SingletonMonoBehaviour<MainPosition>.HasInstance && MainPosition.Avater.AvaterResources.HasTrackedHands
				select _).Subscribe(delegate
			{
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.transform.localScale = Vector3.one;
				MainPosition.Avater.AvaterResources.TrackedHandLeftObject.IsPreventSleeping = false;
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.transform.localScale = Vector3.one;
				MainPosition.Avater.AvaterResources.TrackedHandRightObject.IsPreventSleeping = false;
			});
		}

		private void InitNKColliderForQuest()
		{
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(GameDefine.CharaID.NIKAIDOU);
			_obNKCollider = UnityEngine.Object.Instantiate(_prefabNKCollider, chara.Transform, worldPositionStays: false);
			(from collider in _obNKCollider.OnTriggerEnterAsObservable()
				where collider.gameObject.name == "KNIFECOLLIDER"
				select collider).TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable).Subscribe(delegate
			{
				InGameManager.Timeline.SelectionProcessor.ForceSelect(0);
				MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsPausedTracking = true;
				MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsPausedTracking = true;
				StabVibrate();
			}).AddTo(_obNKCollider);
			this.OnDestroyAsObservable().Subscribe(delegate
			{
				if (_obNKCollider != null)
				{
					UnityEngine.Object.Destroy(_obNKCollider);
				}
				if (SingletonMonoBehaviour<MainPosition>.HasInstance)
				{
					MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsPausedTracking = false;
					MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsPausedTracking = false;
				}
			});
		}

		private void InitSelfColliderForQuest()
		{
			int selfLn = _prefabSelfColliders.Length;
			_obSelfColliders = new GameObject[selfLn];
			for (int i = 0; i < selfLn; i++)
			{
				Transform parent = null;
				SelfColliderTypes selfColliderTypes = (SelfColliderTypes)i;
				switch (selfColliderTypes)
				{
				case SelfColliderTypes.Body:
					parent = MainPosition.Avater.AvaterResources.BodyObject.transform;
					break;
				case SelfColliderTypes.HandLeft:
					parent = MainPosition.Avater.AvaterResources.TrackedHandLeftObject.transform;
					break;
				case SelfColliderTypes.HandRight:
					parent = MainPosition.Avater.AvaterResources.TrackedHandRightObject.transform;
					break;
				}
				GameObject instance = UnityEngine.Object.Instantiate(_prefabSelfColliders[i], parent, worldPositionStays: false);
				switch (selfColliderTypes)
				{
				case SelfColliderTypes.Body:
					_reactiveSelfPointing.Subscribe(delegate(bool isSelf)
					{
						instance.SetActive(isSelf);
					});
					break;
				case SelfColliderTypes.HandLeft:
					SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Select((VRDeviceDefine.HandType handType) => handType != VRDeviceDefine.HandType.Left).Subscribe(delegate(bool isNotKnifeHand)
					{
						instance.SetActive(isNotKnifeHand);
					}).AddTo(base.gameObject);
					break;
				case SelfColliderTypes.HandRight:
					SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Select((VRDeviceDefine.HandType handType) => handType != VRDeviceDefine.HandType.Right).Subscribe(delegate(bool isNotKnifeHand)
					{
						instance.SetActive(isNotKnifeHand);
					}).AddTo(base.gameObject);
					break;
				}
				(from collider in instance.OnTriggerEnterAsObservable()
					where collider.gameObject.name == "KNIFECOLLIDER"
					select collider).TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable).Subscribe(delegate
				{
					InGameManager.Timeline.SelectionProcessor.ForceSelect(1);
					MainPosition.Avater.AvaterResources.TrackedHandLeftLoader.IsPausedTracking = true;
					MainPosition.Avater.AvaterResources.TrackedHandRightLoader.IsPausedTracking = true;
					StabVibrate();
				}).AddTo(instance);
				_obSelfColliders[i] = instance;
			}
			this.OnDestroyAsObservable().Subscribe(delegate
			{
				for (int j = 0; j < selfLn; j++)
				{
					if (!(_obSelfColliders[j] == null))
					{
						UnityEngine.Object.Destroy(_obSelfColliders[j]);
					}
				}
			});
		}

		private void StabVibrate()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.Vibrate(SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value, 0.4f, 1f);
		}

		private void InitKnifePosingUpdationForQuest()
		{
			SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.TakeUntil(InGameManager.Timeline.SelectionProcessor.EndSelectionObservable).Subscribe(delegate
			{
				UpdateCheckingSelf();
			}).AddTo(base.gameObject);
			_reactiveSelfPointing.Subscribe(delegate(bool isSelf)
			{
				_trackedHandPrefferedObject.PlayAnimation(GetCurrentMotionId(isSelf), isFade: false, isSkipAnimation: true);
			});
		}

		private void UpdateCheckingSelf()
		{
			Transform headTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
			Transform transform = _trackedHandPrefferedLoader.transform;
			_reactiveSelfPointing.Value = Quaternion.Angle(headTransform.rotation, transform.rotation) >= _motionToggleAngle;
		}

		private Vector3 GetNKSpot(float yOffset)
		{
			Vector3 vector = SingletonMonoBehaviour<MainPosition>.Instance.transform.position + SingletonMonoBehaviour<MainPosition>.Instance.transform.forward * _nkDistance;
			return new Vector3(vector.x, vector.y + yOffset, vector.z);
		}

		private int GetCurrentMotionId(bool isSelf)
		{
			if (!isSelf)
			{
				return _motionIdNormal;
			}
			return _motionIdSelf;
		}
	}
	public class SetLookAtPlayer : MonoBehaviour
	{
		[SerializeField]
		private GenericLookTargetIK genericLookAt;

		private void Start()
		{
			genericLookAt.SetLookAtTransform(MainPosition.MainCamera.transform, isSkip: true);
		}
	}
	public class MomonoShowerGuard : MonoBehaviour
	{
		[Header("Components")]
		[SerializeField]
		[NotEditable]
		private BaseProp _prop;
	}
	[RequireComponent(typeof(SpriteRenderer))]
	public class DemoSpriteSwitcher : MonoBehaviour
	{
		[SerializeField]
		private Sprite m_jpSprite;

		[SerializeField]
		private Sprite m_egSprite;

		private void Start()
		{
			SpriteRenderer component = GetComponent<SpriteRenderer>();
			if (!(component == null))
			{
				if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
				{
					component.sprite = m_jpSprite;
				}
				else
				{
					component.sprite = m_egSprite;
				}
			}
		}
	}
	public class EndProto : MonoBehaviour
	{
		private void Start()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack);
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				ExitToTitle();
			}).AddTo(base.gameObject);
		}

		private void ExitToTitle()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.TransparentBlack, ColorDefine.Black, delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
			});
		}
	}
	public class SplashScreen : MonoBehaviour
	{
		[SerializeField]
		private Animator _splashAnimator;

		private void Start()
		{
			Observable.NextFrame().Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.CheckLanguage();
				SingletonMonoBehaviour<PlayAreaManager>.Instance.StartApplicationPlatformValidate(delegate(bool validated)
				{
					if (!validated)
					{
						UnityEngine.Debug.LogError("<b>FATAL: Platform Validation Failed</b>");
						UnityEngine.Application.Quit();
					}
					else
					{
						StartSplashScreen();
					}
				});
			});
		}

		private void StartSplashScreen()
		{
			VrUtility.OnLoadEnd();
			IObservable<Unit> source = this.UpdateAsObservable().Skip(6).Share();
			source.Take(1).Subscribe(delegate
			{
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.TransparentBlack);
				SingletonMonoBehaviour<GameData>.Instance.SystemData.ResetTimeCaches();
			}).AddTo(base.gameObject);
			source.Subscribe(delegate
			{
				_splashAnimator.Update(Time.deltaTime);
			}).AddTo(base.gameObject);
		}

		public void OnEndAnimation()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
		}
	}
	public class Title : MonoBehaviour
	{
		private enum States
		{
			Initalize,
			FadeIn,
			Play,
			FadeOut,
			End
		}

		[Header("Components - Genaral")]
		[SerializeField]
		private TitleAudioComponent _audioComponent;

		[Header("Parameter - Scenario")]
		[SerializeField]
		private int m_scenarioToLoad;

		[Header("Parameter - Other")]
		[SerializeField]
		private float m_fadeoutDuration = 2.25f;

		[Header("Parameter - Text")]
		[SerializeField]
		private TextMeshPro m_subtitleText;

		[SerializeField]
		private string m_subtitleJp = "";

		[SerializeField]
		private string m_subtitleEg = "";

		private States m_state;

		private UIFader Fader => SingletonMonoBehaviour<FadeManager>.Instance.sceneFader;

		private bool IsMenuOpened
		{
			get
			{
				if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
				{
					return SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened;
				}
				return false;
			}
		}

		private void Start()
		{
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				m_subtitleText.text = m_subtitleJp;
			}
			else
			{
				m_subtitleText.text = m_subtitleEg;
			}
			SingletonMonoBehaviour<TransitionManager>.Instance.SetActiveScene(SceneDefine.Title);
		}

		private void Update()
		{
			switch (m_state)
			{
			case States.Initalize:
				Fader.StartFade(ColorDefine.Black, ColorDefine.TransparentBlack, 0.6f, isDeactivateOnEnd: true, OnFadeInEnd);
				m_state = States.FadeIn;
				_audioComponent.PlayTitleBGM();
				break;
			case States.Play:
				if (SingletonMonoBehaviour<GameInputManager>.HasInstance && !IsMenuOpened && SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
				{
					_audioComponent.PlaySound(TitleAudioComponent.ClipName.GameStart);
					_audioComponent.StopTitleBGM(0.6f);
					FadeOut();
				}
				break;
			case States.FadeIn:
			case States.FadeOut:
			case States.End:
				break;
			}
		}

		public void OnFadeInEnd()
		{
			m_state = States.Play;
		}

		private void FadeOut()
		{
			Fader.StartReverseFade(m_fadeoutDuration, isDeactivateOnEnd: false, OnFadeOutEnd);
			m_state = States.FadeOut;
		}

		private void OnFadeOutEnd()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.StartScenario(m_scenarioToLoad);
		}
	}
	public class DataManager : SingletonMonoBehaviour<DataManager>
	{
		public GeneralDataController GeneralData { get; private set; }

		public CharaTable CharaData { get; private set; }

		public CharaTextDataTable CharaTextData { get; private set; }

		public SequenceTable SequenceData { get; private set; }

		protected override void InitializeOnAwake()
		{
			base.InitializeOnAwake();
			GeneralData = new GeneralDataController();
			CharaData = new CharaTable();
			CharaTextData = new CharaTextDataTable();
			SequenceData = new SequenceTable();
			GeneralData.Load();
			CharaData.Load();
			CharaTextData.Load();
		}

		public void Clear()
		{
			GeneralData.Clear();
			CharaData.Clear();
			CharaTextData.Clear();
			SequenceData.Clear();
			GeneralData = null;
			CharaData = null;
			CharaTextData = null;
			SequenceData = null;
		}

		public override void Shutdown(bool isDestroyObject = true)
		{
			Clear();
			base.Shutdown(isDestroyObject);
		}

		public Sprite FindLoadingSprite(int sqid)
		{
			if (sqid <= -1)
			{
				return null;
			}
			return GetChapterData(sqid)?.SpriteLoadScreen;
		}

		public Sprite FindSaveThumbnailSprite(int sqid)
		{
			if (sqid <= -1)
			{
				return null;
			}
			return GeneralData.GetScenarioInfo(sqid).SaveThumbnail;
		}

		private NewGameData.ChapterSetting GetChapterData(int sqid)
		{
			if (!GeneralData.ScenarioList.TryGetValue(sqid, out var seqData))
			{
				return null;
			}
			return Array.Find(ChapterChecker.GetChapterListData(seqData.Category), (NewGameData.ChapterSetting info) => info.Category == seqData.Category && info.Index == seqData.ChapterNumber);
		}
	}
	public static class AchievementDefine
	{
		public enum Keys
		{
			ACH_CHRONOS_COMPLETE_01_01 = 0,
			ACH_CHRONOS_COMPLETE_01_02 = 1,
			ACH_CHRONOS_COMPLETE_01_03 = 2,
			ACH_CHRONOS_COMPLETE_01_04 = 3,
			ACH_CHRONOS_COMPLETE_01_05 = 4,
			ACH_CHRONOS_COMPLETE_01_06 = 5,
			ACH_CHRONOS_COMPLETE_01_07 = 6,
			ACH_CHRONOS_COMPLETE_02_01 = 7,
			ACH_CHRONOS_COMPLETE_02_02 = 8,
			ACH_CHRONOS_COMPLETE_02_03 = 9,
			ACH_CHRONOS_COMPLETE_02_04 = 10,
			ACH_CHRONOS_COMPLETE_02_05 = 11,
			ACH_CHRONOS_COMPLETE_02_06 = 12,
			ACH_CHRONOS_COMPLETE_02_07 = 13,
			ACH_CHRONOS_COMPLETE_02_08 = 14,
			ACH_CHRONOS_COMPLETE_02_09 = 15,
			ACH_CHRONOS_COMPLETE_02_10 = 16,
			ACH_CHRONOS_COMPLETE_02_11 = 17,
			ACH_CHRONOS_COMPLETE_MOMONO = 18,
			ACH_CHRONOS_COMPLETE_TOUGOKU = 19,
			ACH_CHRONOS_COMPLETE_KAGEYAMA = 20,
			ACH_CHRONOS_COMPLETE_MOROZUMI = 21,
			ACH_CHRONOS_COMPLETE_MACHIKOUJI = 22,
			ACH_CHRONOS_MOMONO_SHOWER = 23,
			NULL = 1023
		}

		public static IObservable<Keys> FlagToKeys(this IObservable<GameFlags> flagObservable)
		{
			return flagObservable.Select((GameFlags flag) => flag switch
			{
				GameFlags.CompleteChapter1_1 => Keys.ACH_CHRONOS_COMPLETE_01_01, 
				GameFlags.CompleteChapter1_2 => Keys.ACH_CHRONOS_COMPLETE_01_02, 
				GameFlags.CompleteChapter1_3 => Keys.ACH_CHRONOS_COMPLETE_01_03, 
				GameFlags.CompleteChapter1_4 => Keys.ACH_CHRONOS_COMPLETE_01_04, 
				GameFlags.CompleteChapter1_5 => Keys.ACH_CHRONOS_COMPLETE_01_05, 
				GameFlags.CompleteChapter1_6 => Keys.ACH_CHRONOS_COMPLETE_01_06, 
				GameFlags.CompleteChapter1_7 => Keys.ACH_CHRONOS_COMPLETE_01_07, 
				GameFlags.CompleteChapter2_1 => Keys.ACH_CHRONOS_COMPLETE_02_01, 
				GameFlags.CompleteChapter2_2 => Keys.ACH_CHRONOS_COMPLETE_02_02, 
				GameFlags.CompleteChapter2_3 => Keys.ACH_CHRONOS_COMPLETE_02_03, 
				GameFlags.CompleteChapter2_4 => Keys.ACH_CHRONOS_COMPLETE_02_04, 
				GameFlags.CompleteChapter2_5 => Keys.ACH_CHRONOS_COMPLETE_02_05, 
				GameFlags.CompleteChapter2_6 => Keys.ACH_CHRONOS_COMPLETE_02_06, 
				GameFlags.CompleteChapter2_7 => Keys.ACH_CHRONOS_COMPLETE_02_07, 
				GameFlags.CompleteChapter2_8 => Keys.ACH_CHRONOS_COMPLETE_02_08, 
				GameFlags.CompleteChapter2_9 => Keys.ACH_CHRONOS_COMPLETE_02_09, 
				GameFlags.CompleteChapter2_10 => Keys.ACH_CHRONOS_COMPLETE_02_10, 
				GameFlags.CompleteChapter2_11 => Keys.ACH_CHRONOS_COMPLETE_02_11, 
				GameFlags.EndingMomono => Keys.ACH_CHRONOS_COMPLETE_MOMONO, 
				GameFlags.EndingTougoku => Keys.ACH_CHRONOS_COMPLETE_TOUGOKU, 
				GameFlags.EndingKageyama => Keys.ACH_CHRONOS_COMPLETE_KAGEYAMA, 
				GameFlags.EndingMorozumi => Keys.ACH_CHRONOS_COMPLETE_MOROZUMI, 
				GameFlags.EndingMachikouji => Keys.ACH_CHRONOS_COMPLETE_MACHIKOUJI, 
				_ => Keys.NULL, 
			});
		}
	}
	public static class CharaAnimDefine
	{
		public enum AnimID
		{

		}

		public enum SkAnimID
		{

		}

		public enum RuAnimID
		{

		}

		public enum MmAnimID
		{

		}

		public enum TgAnimID
		{

		}

		public enum KmAnimID
		{

		}

		public enum MrAnimID
		{

		}

		public enum McAnimID
		{

		}

		public enum KgAnimID
		{

		}
	}
	public static class GameDefine
	{
		public enum Languages
		{
			Japanese,
			English,
			German,
			French,
			Chinese,
			Max
		}

		public enum CharaIndex
		{
			NONE = 0,
			BASE = 1,
			SAKURAI = 2,
			NIKAIDOU = 3,
			ROU = 4,
			MOMONO = 5,
			TOUGOKU = 6,
			KAMIYA = 7,
			MOROZUMI = 8,
			MACHIKOUJI = 9,
			KAGEYAMA = 10,
			RIN = 11,
			HITOKAGE = 12,
			UNKNOWN = 13,
			SAKURAI_MIRROR = 14,
			TOGOKU_MIRROR = 15,
			TOUGOKU_SISTER = 20,
			TOUGOKU_PAPA = 21,
			NIKAIDOU_MAMA = 22,
			MACHIKOUJI_MAMA = 23,
			YANKEEEE = 24,
			HITTAKURI = 25,
			TEACHER = 26,
			DOG = 27,
			CLASSMATE_M_S_A = 30,
			CLASSMATE_M_S_B = 31,
			CLASSMATE_M_S_C = 32,
			CLASSMATE_F_S_A = 33,
			CLASSMATE_F_S_B = 34,
			CLASSMATE_F_S_C = 35,
			CLASSMATE_M_C_A = 36,
			CLASSMATE_M_C_B = 37,
			CLASSMATE_M_C_C = 38,
			CLASSMATE_F_C_A = 39,
			CLASSMATE_F_C_B = 40,
			CLASSMATE_F_C_C = 41,
			Count = 42
		}

		public enum CharaID
		{
			NONE = 0,
			BASE = 100,
			SAKURAI = 200,
			SAKURAI_S = 201,
			SAKURAI_C = 202,
			NIKAIDOU = 300,
			NIKAIDOU_S = 301,
			NIKAIDOU_C = 302,
			ROU = 400,
			ROU_MEMORY = 401,
			MOMONO = 500,
			MOMONO_S = 501,
			MOMONO_C = 502,
			TOUGOKU = 600,
			TOUGOKU_S = 601,
			TOUGOKU_C = 602,
			KAMIYA = 700,
			KAMIYA_S = 701,
			KAMIYA_C = 702,
			MOROZUMI = 800,
			MOROZUMI_S = 801,
			MOROZUMI_C = 802,
			MACHIKOUJI = 900,
			MACHIKOUJI_S = 901,
			MACHIKOUJI_C = 902,
			KAGEYAMA = 1000,
			KAGEYAMA_S = 1001,
			KAGEYAMA_C = 1002,
			RIN = 1100,
			RIN_S = 1101,
			RIN_C = 1102,
			HITOKAGE = 1200,
			SAKURAI_MIRROR = 1400,
			TOGOKU_MIRROR = 1500,
			TOUGOKU_SISTER = 2000,
			TOUGOKU_PAPA = 2100,
			NIKAIDOU_MAMA = 2200,
			MACHIKOUJI_MAMA = 2300,
			YANKEEEE = 2400,
			HITTAKURI = 2500,
			TEACHER = 2600,
			DOG = 2700,
			CLASSMATE_M_S_A = 3000,
			CLASSMATE_M_S_B = 3100,
			CLASSMATE_M_S_C = 3200,
			CLASSMATE_F_S_A = 3300,
			CLASSMATE_F_S_B = 3400,
			CLASSMATE_F_S_C = 3500,
			CLASSMATE_M_C_A = 3600,
			CLASSMATE_M_C_B = 3700,
			CLASSMATE_M_C_C = 3800,
			CLASSMATE_F_C_A = 3900,
			CLASSMATE_F_C_B = 4000,
			CLASSMATE_F_C_C = 4100,
			UNKNOWN_SAKURAI = 10200,
			UNKNOWN_NIKAIDOU = 10300,
			UNKNOWN_ROU = 10400,
			UNKNOWN_MOMONO = 10500,
			UNKNOWN_TOUGOKU = 10600,
			UNKNOWN_KAMIYA = 10700,
			UNKNOWN_MOROZUMI = 10800,
			UNKNOWN_MACHIKOUJI = 10900,
			UNKNOWN_KAGEYAMA = 11000,
			UNKNOWN_RIN = 11100,
			UNKNOWN_HITOKAGE = 11200,
			MOMONO_RIN = 100500,
			UNKNOWN = 99999
		}

		public const int TEMP_SCENARIO_ID = -99999;

		public const int INVALID_VALUE = -1;

		public const float FADE_DURATION = 0.6f;

		public const float MODEL_SCALE = 3.5f;

		public const float PLAYER_Y_ADJUSTMENT = 5.17f;

		public static readonly Vector3 PLAYER_DEFAULT_POSITION = new Vector3(0f, 5.17f, 0f);

		public const string NAME_UNKNOWN = "???";

		public const float CHARA_SCALER = 3.5f;

		public static readonly Vector3 CHARA_SCALE = new Vector3(0.2857143f, 0.2857143f, 0.2857143f);

		public const int CHARA_ID_ADJUSTMENT = 100;

		public const int CHARA_UNKNOWN_ADJUSTMENT = 10000;

		public const int CHARA_SPECIAL_ADJUSTMENT = 100000;

		public static readonly int CHARA_UNKNOWN_DIGITS = (int)Mathf.Log10(10000f) + 1;

		public static CharaID CharaIndexToID(CharaIndex index)
		{
			return (CharaID)((int)index * 100);
		}

		public static CharaIndex CharaIDToIndex(CharaID charaID)
		{
			return (CharaIndex)((int)charaID / 100);
		}

		public static bool IsUnknownChara(CharaID charaID)
		{
			return MathHelper.CountDigit((int)charaID) == CHARA_UNKNOWN_DIGITS;
		}

		public static bool IsAnotherVersion(CharaID id)
		{
			return (int)id % 10 > 0;
		}

		public static CharaID GetOriginalCharaID(CharaID id)
		{
			return (CharaID)(Mathf.CeilToInt((int)id / 100) * 100);
		}

		public static CharaID UnknownToCharaID(CharaID charaID)
		{
			return charaID - 10000;
		}

		public static CharaID GetCharaID(int id)
		{
			if (id == 0)
			{
				return CharaID.BASE;
			}
			return (CharaID)id;
		}

		public static bool IsModChara(CharaID id)
		{
			if (id >= CharaID.TOUGOKU_SISTER)
			{
				return id < CharaID.UNKNOWN_SAKURAI;
			}
			return false;
		}

		public static bool IsShadow(CharaID id)
		{
			if (id != CharaID.HITOKAGE)
			{
				return id == CharaID.UNKNOWN_HITOKAGE;
			}
			return true;
		}

		public static bool IsSpecialChara(CharaID id)
		{
			return id > (CharaID)100000;
		}

		public static CharaID ConvertSpecialToNormal(CharaID id)
		{
			if (id < (CharaID)100000)
			{
				return id;
			}
			return id - 100000;
		}

		public static bool IsLanguageImplemented(Languages lang)
		{
			if ((uint)lang <= 2u || lang == Languages.Chinese)
			{
				return true;
			}
			return false;
		}
	}
	public static class PathDefine
	{
		public const string _GENERAL = "General/";

		public const string _NEWGAME_DATA = "General/NewGameData";

		public const string _SCENARIO_LIST_DATA = "General/ScenarioList";

		public const string _TABLES = "Tables/";

		public const string _SETTINGS = "Settings/";

		public const string _SETTINGS_SOUND = "Settings/Sound/";

		public const string _PREFABS = "Prefabs/";

		public const string _PROPS = "Prefabs/Props/";

		public const string _TEXTURES = "Textures/";

		public const string _EVENT_IMAGE = "Textures/Event/";

		public const string _CHARA_PREFABS = "Prefabs/Characters/";

		public const string _PLAYER_AVATER = "Prefabs/Avaters/";

		public const string _AUDIO = "Audio/";

		public const string _AUDIO_BGM = "Audio/BGM/";

		public const string _AUDIO_BGM_SIMPLE = "Audio/BgmSimple/";

		public const string _AUDIO_SE = "Audio/SE/";

		public const string _AUDIO_AMBIENT = "Audio/Ambient/";

		public const string _AUDIO_VOICE = "Audio/Voice/";

		public const string _AUDIO_VOICE_MOB = "Audio/Voice/Mob/";

		public const string _MEMORY_CHARA = "MemoryChara/";
	}
	public static class SoundDefine
	{
		public enum SystemSE
		{
			Null,
			Message_Next,
			Message_Log,
			Selection_Show,
			Selection_Select,
			Selection_Decide,
			Selection_Cancel,
			Menu_Open,
			Menu_Close,
			Menu_Select,
			Menu_Decide,
			Menu_Confirm,
			Menu_Cancel,
			Menu_Error,
			Message_TypeLoop,
			Message_TypeEnd,
			Message_TypeNext
		}

		public enum SE
		{
			Footstep = 10000
		}

		public enum Bgm
		{
			IF = 100
		}
	}
	public static class VRDeviceDefine
	{
		public enum PlatformType
		{
			Disabled,
			Unsupported,
			OpenVR,
			Oculus,
			Playstation
		}

		public enum DeviceType
		{
			Disabled,
			Unsupported,
			Vive,
			OculusRift,
			OculusGo,
			OculusQuest,
			GearVR,
			OtherOpenVRDevice,
			Playstation
		}

		public enum HandType
		{
			Left,
			Right,
			Both,
			None
		}

		public enum Buttons
		{
			DeviceSystem,
			DeviceBack,
			SubAction,
			Cancel,
			MainAction,
			PositionReset,
			RemoveInterface,
			SkipScene,
			Up,
			Down,
			Left,
			Right
		}

		public class NotSupportedDeviceException : Exception
		{
			public NotSupportedDeviceException()
				: base("Detected VR device that is not implemented.")
			{
			}

			public NotSupportedDeviceException(string s)
				: base($"Detected VR device '{s}' that is not implemented.")
			{
			}

			public NotSupportedDeviceException(DeviceType type)
				: this(type.ToString())
			{
			}
		}
	}
	public class GameData : SingletonMonoBehaviour<GameData>
	{
		public const int _SAVE_FILE_SLOTS = 30;

		public const int INDEX_AUTOSAVE = 0;

		[Header("Components")]
		[SerializeField]
		private FileIOManager m_fileIOManager;

		[Header("Parameters - Filename")]
		[SerializeField]
		private string m_directoryName = "Save";

		[SerializeField]
		private string m_saveFileName = "save";

		[SerializeField]
		private string m_systemFileName = "system";

		[SerializeField]
		private string m_configFileName = "config";

		private bool _needsRefreshHeaders = true;

		private List<GameFileSave.Header> _headerList;

		private Subject<GameFlags> _subjectFlagActivated = new Subject<GameFlags>();

		public GameFileSave CurrentSaveData { get; private set; }

		public SystemSave SystemData { get; private set; }

		public ConfigSave ConfigData { get; private set; }

		public bool IsHeaderCreated => !_needsRefreshHeaders;

		public IObservable<GameFlags> FlagActivatedObservable => _subjectFlagActivated;

		protected override void InitializeOnAwake()
		{
			string path = ToDirPath();
			m_fileIOManager.CreateDirectory(path);
			CurrentSaveData = new GameFileSave(ToFilePath(m_saveFileName));
			SystemData = new SystemSave(ToFilePath(m_systemFileName));
			ConfigData = new ConfigSave(ToFilePath(m_configFileName));
			LoadSystemData();
			LoadConfigData();
			FindHeaders();
			base.InitializeOnAwake();
		}

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnQuitApplication.Subscribe(delegate
			{
				SaveSystemData();
			});
		}

		private string ToFilePath(string fileName)
		{
			return FilePathUtil.Combine(ToDirPath(), fileName);
		}

		private string ToDirPath()
		{
			return FilePathUtil.Combine(FileIOManagerBase.SdkPersistentDataPath, m_directoryName + "/");
		}

		public bool LoadSaveData(int loadFileIndex)
		{
			return LoadSaveData(CurrentSaveData, loadFileIndex);
		}

		private bool LoadSaveData(GameFileSave loadTo, int loadFileIndex)
		{
			loadTo.SetPath(ToFilePath(m_saveFileName) + loadFileIndex);
			if (!m_fileIOManager.Exists(loadTo.Path))
			{
				return false;
			}
			return m_fileIOManager.ReadBinaryDecode(loadTo.Path, loadTo.Load);
		}

		public bool IsExistSaveData(int loadFileIndex)
		{
			return m_fileIOManager.Exists(ToFilePath(m_saveFileName) + loadFileIndex);
		}

		public void LoadSystemData()
		{
			LoadData(SystemData);
		}

		public void LoadConfigData()
		{
			LoadData(ConfigData);
		}

		private void LoadData(BaseSave data)
		{
			if (m_fileIOManager.Exists(data.Path))
			{
				if (!m_fileIOManager.ReadBinaryDecode(data.Path, data.Load))
				{
					data.Clear();
				}
			}
			else
			{
				data.Clear();
			}
		}

		public void Save(int slotIndex)
		{
			SaveSystemData();
			SetupSaveDataToSave();
			SaveToSlot(slotIndex);
		}

		private void SetupSaveDataToSave()
		{
			CurrentSaveData.SequenceID = SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID;
		}

		public void SaveSystemData()
		{
			SaveDataToFile(SystemData);
		}

		public void SaveConfigData()
		{
			SaveDataToFile(ConfigData);
		}

		private void SaveDataToFile(BaseSave data)
		{
			m_fileIOManager.WriteBinaryEncode(data.Path, data.Save);
		}

		public void SaveToSlot(int slotIndex)
		{
			CurrentSaveData.SetPath(ToFilePath(m_saveFileName + slotIndex));
			SaveDataToFile(CurrentSaveData);
			_needsRefreshHeaders = true;
		}

		public void DeleteAll()
		{
			DeleteAllSaveFiles();
			DeleteFile(ToFilePath(m_configFileName));
			DeleteFile(ToFilePath(m_systemFileName));
		}

		public void DeleteAllWithoutConfig()
		{
			DeleteAllSaveFiles();
			DeleteFile(ToFilePath(m_systemFileName));
		}

		public void DeleteAllSaveFiles()
		{
			string text = ToFilePath(m_saveFileName);
			for (int i = 0; i < 30; i++)
			{
				DeleteFile(text + i);
			}
		}

		public void DeleteFile(string path)
		{
			m_fileIOManager.Delete(path);
		}

		public bool GetFlag(GameFlags gameFlag)
		{
			return SystemData.GetFlag(gameFlag);
		}

		public void SetFlag(GameFlags gameFlag, bool value)
		{
			SystemData.SetFlag(gameFlag, value);
			if (value)
			{
				_subjectFlagActivated.OnNext(gameFlag);
			}
		}

		public List<GameFileSave.Header> FindHeaders()
		{
			if (_needsRefreshHeaders)
			{
				return CreateHeaders();
			}
			return _headerList;
		}

		public List<GameFileSave.Header> CreateHeaders()
		{
			_headerList = new List<GameFileSave.Header>();
			for (int i = 0; i < 30; i++)
			{
				GameFileSave gameFileSave = new GameFileSave(ToFilePath(m_saveFileName));
				if (!IsExistSaveData(i))
				{
					_headerList.Add(gameFileSave.CreateEmptyHeader(i));
				}
				else if (LoadSaveData(gameFileSave, i))
				{
					_headerList.Add(gameFileSave.CreateHeader(i));
				}
				else
				{
					_headerList.Add(gameFileSave.CreateCorruptedHeader(i));
				}
			}
			_needsRefreshHeaders = false;
			return _headerList;
		}
	}
	public enum GameFlags
	{
		Route1Chapter0,
		Route1Chapter1,
		Route1Chapter2,
		Route1Chapter3,
		Route1Chapter4,
		Route1Chapter5,
		Route1Chapter6,
		Route1Chapter7,
		Route1Chapter8,
		Route1Chapter9,
		Route2Chapter0,
		Route2Chapter1,
		Route2Chapter2,
		Route2Chapter3,
		Route2Chapter4,
		Route2Chapter5,
		Route2Chapter6,
		Route2Chapter7,
		Route2Chapter8,
		Route2Chapter9,
		ChapterTougoku,
		ChapterKageyama,
		ChapterMomono,
		ChapterMorozumi,
		ChapterMachikouji,
		EndingNormal,
		EndingTougoku,
		EndingKageyama,
		EndingMomono,
		EndingMorozumi,
		EndingMachikouji,
		EndingTrue,
		EndingAlternate,
		Route2Chapter10,
		Route2Chapter11,
		Route2Chapter12,
		Route2Chapter13,
		Route2Chapter14,
		CompleteChapter1_0,
		CompleteChapter1_1,
		CompleteChapter1_2,
		CompleteChapter1_3,
		CompleteChapter1_4,
		CompleteChapter1_5,
		CompleteChapter1_6,
		CompleteChapter1_7,
		CompleteChapter1_8,
		CompleteChapter1_9,
		CompleteChapter2_0,
		CompleteChapter2_1,
		CompleteChapter2_2,
		CompleteChapter2_3,
		CompleteChapter2_4,
		CompleteChapter2_5,
		CompleteChapter2_6,
		CompleteChapter2_7,
		CompleteChapter2_8,
		CompleteChapter2_9,
		CompleteChapter2_10,
		CompleteChapter2_11,
		CompleteChapter2_12,
		SkipNoifyShowed,
		Max
	}
	public class GeneralDataController
	{
		private Dictionary<int, ScenarioListData.Info> _scenarioList;

		public NewGameData NewGameLists { get; private set; }

		public Dictionary<int, ScenarioListData.Info> ScenarioList => _scenarioList;

		public void Load()
		{
			NewGameLists = Resources.Load<NewGameData>("General/NewGameData");
			MakeScenarioList();
		}

		private void MakeScenarioList()
		{
			ScenarioListData scenarioListData = Resources.Load<ScenarioListData>("General/ScenarioList");
			if (scenarioListData == null)
			{
				return;
			}
			_scenarioList = new Dictionary<int, ScenarioListData.Info>();
			foreach (ScenarioListData.Info info in scenarioListData.InfoList)
			{
				_scenarioList.Add(info.Index, info);
			}
		}

		public void Clear()
		{
			_scenarioList = null;
		}

		public ScenarioListData.Info GetScenarioInfo(int squid)
		{
			if (!_scenarioList.TryGetValue(squid, out var value))
			{
				value = new ScenarioListData.Info();
				value.IgnoreFileSave = true;
			}
			return value;
		}

		public int GetNewGameSqid()
		{
			return NewGameLists.SqidNewGame;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/New Game Data", fileName = "NewGameData")]
	public class NewGameData : ScriptableObject
	{
		[Serializable]
		public class ChapterSetting
		{
			public ScenarioListData.Categories Category = ScenarioListData.Categories.RouteFirst;

			public int Index;

			public int StartSqid = -1;

			public SceneDefine BonusScene = SceneDefine.Title;

			public GameFlags ConditionToSelect;

			public Sprite SpriteSaveThumbnail;

			public Sprite SpriteLoadScreen;

			public bool IgnoreListUp;
		}

		public int SqidNewGame = -1;

		public GameFlags ConditionToRevealHidden = GameFlags.EndingNormal;

		public ChapterSetting[] ChaptersFirst;

		public ChapterSetting[] ChaptersSecond;

		public ChapterSetting[] ChaptersCharacter;

		public ChapterSetting[] ChaptersSpecial;
	}
	public class ScenarioListData : ScriptableObject
	{
		public enum Categories
		{
			Test,
			RouteFirst,
			RouteSecond,
			Character,
			Special,
			Other
		}

		public enum SpecialTypes
		{
			NotSpecial = -1,
			Null,
			ChangeCharacter,
			Selection,
			ChapterStart,
			NullFour,
			NullFive,
			NullSix,
			NullSeven,
			NullEight,
			NullNine
		}

		public enum SkipModes
		{
			Normal,
			Related,
			Flag,
			Always,
			Never
		}

		[Serializable]
		public class Info
		{
			[HideInInspector]
			public string FileName = "";

			[NotEditable]
			public int Index = -1;

			[SerializeField]
			private bool _customChapter;

			[EnableIf("$_customChapter")]
			[StackableField]
			public Categories Category;

			[EnableIf("$_customChapter")]
			[StackableField]
			public SpecialTypes SpecialType = SpecialTypes.NotSpecial;

			[EnableIf("$_customChapter")]
			[StackableField]
			public int ChapterNumber;

			[NotEditable]
			public bool HasTextData;

			[NotEditable]
			public bool HasSequenceData;

			[EnumButton]
			public SkipModes SkipMode;

			[ShowIf("#_isFlagToSkip")]
			[StackableField]
			public GameFlags FlagToSkip;

			public bool IgnoreFileSave;

			public int RelatedSqid = -1;

			public string ScenarioName = "";

			[Preview]
			[Expandable]
			public Sprite SaveThumbnail;

			public bool IsExists
			{
				get
				{
					if (!HasTextData)
					{
						return HasSequenceData;
					}
					return true;
				}
			}

			public bool IsValid
			{
				get
				{
					if (HasTextData)
					{
						return HasSequenceData;
					}
					return false;
				}
			}

			public void ResetExistFlags()
			{
				HasTextData = false;
				HasSequenceData = false;
			}

			public void CalculateIndex()
			{
				if (_customChapter)
				{
					UpdateFileName();
					return;
				}
				switch (Index / 10000)
				{
				case 0:
					Category = Categories.Test;
					ChapterNumber = Index;
					break;
				case 1:
					Category = Categories.RouteFirst;
					ChapterNumber = Index / 1000 % 10;
					break;
				case 2:
					Category = Categories.RouteSecond;
					if (Index < 27000)
					{
						ChapterNumber = Index / 1000 % 10;
					}
					else if (Index <= 27119)
					{
						ChapterNumber = 7;
					}
					else if (Index <= 27999)
					{
						ChapterNumber = 8;
					}
					else if (Index <= 28039)
					{
						ChapterNumber = 9;
					}
					else if (Index <= 28279)
					{
						ChapterNumber = 10;
					}
					else
					{
						ChapterNumber = 11;
					}
					break;
				case 4:
					Category = Categories.Character;
					ChapterNumber = 2;
					break;
				case 5:
					Category = Categories.Character;
					ChapterNumber = 3;
					break;
				case 6:
					Category = Categories.Character;
					ChapterNumber = 4;
					break;
				case 7:
					Category = Categories.Character;
					ChapterNumber = 5;
					break;
				case 8:
					Category = Categories.Character;
					ChapterNumber = 1;
					break;
				case 9:
					Category = Categories.Special;
					CalctSpecialCategoryChapter();
					break;
				default:
					Category = Categories.Other;
					ChapterNumber = Index;
					break;
				}
				UpdateFileName();
			}

			private void UpdateFileName()
			{
				if (Category == Categories.Special)
				{
					FileName = $"{Index:D5} ({Category}.{SpecialType}.{ChapterNumber})";
				}
				else
				{
					FileName = $"{Index:D5} ({Category}.{ChapterNumber})";
				}
			}

			private void CalctSpecialCategoryChapter()
			{
				int num = Index % 1000;
				SpecialType = (SpecialTypes)((Index - 90000) / 1000);
				switch (SpecialType)
				{
				case SpecialTypes.ChangeCharacter:
				case SpecialTypes.Selection:
					ChapterNumber = num;
					break;
				case SpecialTypes.ChapterStart:
					ChapterNumber = num / 10;
					break;
				default:
					ChapterNumber = num;
					break;
				}
			}

			private bool _isFlagToSkip()
			{
				return SkipMode == SkipModes.Flag;
			}
		}

		public List<Info> InfoList = new List<Info>();

		public void ResetExistFlags()
		{
			InfoList.ForEach(delegate(Info info)
			{
				info.ResetExistFlags();
			});
		}

		public void RecalcAll()
		{
			InfoList.ForEach(delegate(Info info)
			{
				info.CalculateIndex();
			});
		}

		public int RemoveUnused()
		{
			return InfoList.RemoveAll((Info i) => !i.IsExists);
		}

		public void SortListByIndex()
		{
			InfoList.Sort((Info a, Info b) => a.Index - b.Index);
		}

		public Info FindByIndex(int index)
		{
			return InfoList.Find((Info info) => info.Index == index);
		}

		public Info InsertNewInfo()
		{
			Info info = new Info();
			InfoList.Add(info);
			return info;
		}
	}
	public class LocalData : SingletonMonoBehaviour<LocalData>
	{
		public int ProgressID;

		public int LastSelectionIndex = -1;

		private Subject<GameDefine.CharaID> _subjectOnChangeCharacter = new Subject<GameDefine.CharaID>();

		public int NextScenarioID { get; set; }

		public int SkipDestinationIndex { get; set; }

		public GameDefine.CharaID CurrentCharaID { get; private set; }

		public GameDefine.CharaID NextCharaID { get; set; }

		public bool IsSessionTitleShowed { get; set; }

		public bool IsOmitNextAutoSave { get; set; }

		public IObservable<GameDefine.CharaID> OnChangeCharacter => _subjectOnChangeCharacter;

		protected override void InitializeOnAwake()
		{
			Reset();
			base.InitializeOnAwake();
		}

		private void Start()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate(int scenarioId)
			{
				Reset();
				NextScenarioID = scenarioId;
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				Reset();
			}).AddTo(base.gameObject);
		}

		public void Reset()
		{
			NextScenarioID = -1;
			SkipDestinationIndex = -1;
			CurrentCharaID = GameDefine.CharaID.NONE;
			NextCharaID = GameDefine.CharaID.NONE;
			ProgressID = 0;
			LastSelectionIndex = -1;
			IsOmitNextAutoSave = false;
		}

		public void ChangeCharacter(GameDefine.CharaID target)
		{
			if (CurrentCharaID != target)
			{
				CurrentCharaID = target;
				_subjectOnChangeCharacter.OnNext(CurrentCharaID);
			}
		}

		public void ChangeCharacterToNext()
		{
			ChangeCharacter(NextCharaID);
			NextCharaID = GameDefine.CharaID.NONE;
		}
	}
	public abstract class BaseLocalizerComponent : MonoBehaviour
	{
		[Header("Parameters - Base")]
		[SerializeField]
		private string _localizeKey;

		[SerializeField]
		private bool _lockLanguage;

		[SerializeField]
		private GameDefine.Languages _lockTarget;

		private bool _initialized;

		public string LocalizeKey
		{
			get
			{
				return _localizeKey;
			}
			set
			{
				_localizeKey = value;
				if (_initialized && !string.IsNullOrEmpty(_localizeKey))
				{
					UpdateLocalize(CurrentLanguage);
				}
			}
		}

		protected LocalizeManager LocalizeParent => SingletonMonoBehaviour<LocalizeManager>.Instance;

		protected IReadOnlyReactiveProperty<GameDefine.Languages> ChangeLanguageObservable => SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language;

		protected GameDefine.Languages CurrentLanguage
		{
			get
			{
				if (!_lockLanguage)
				{
					return SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value;
				}
				return _lockTarget;
			}
		}

		private void OnValidate()
		{
			ValidateComponent();
		}

		private void Start()
		{
			if (_lockLanguage)
			{
				(from _ in ChangeLanguageObservable.First()
					select _lockTarget into _
					where !string.IsNullOrEmpty(_localizeKey)
					select _).Subscribe(UpdateLocalize);
			}
			else
			{
				ChangeLanguageObservable.Where((GameDefine.Languages _) => !string.IsNullOrEmpty(_localizeKey)).Subscribe(UpdateLocalize).AddTo(base.gameObject);
			}
			_initialized = true;
		}

		protected abstract void ValidateComponent();

		protected abstract void UpdateLocalize(GameDefine.Languages lang);
	}
	public class LocalizerTextMesh : BaseLocalizerComponent
	{
		[Header("Parameters - Text Mesh")]
		[SerializeField]
		[NotEditable]
		private TextMeshPro _target;

		protected override void ValidateComponent()
		{
			if (_target == null)
			{
				_target = GetComponent<TextMeshPro>();
			}
		}

		protected override void UpdateLocalize(GameDefine.Languages lang)
		{
			_target.text = base.LocalizeParent.GetLocalizeString(base.LocalizeKey, lang);
		}
	}
	public class LocalizerUGUIText : BaseLocalizerComponent
	{
		[Header("Parameters - Text Mesh")]
		[SerializeField]
		[NotEditable]
		protected TextMeshProUGUI _target;

		protected override void ValidateComponent()
		{
			if (_target == null)
			{
				_target = GetComponent<TextMeshProUGUI>();
			}
		}

		protected override void UpdateLocalize(GameDefine.Languages lang)
		{
			_target.text = base.LocalizeParent.GetLocalizeString(base.LocalizeKey, lang);
		}
	}
	public class LocalizeManager : SingletonMonoBehaviour<LocalizeManager>
	{
		private const string PathToTextData = "Localize/LocalizeData";

		private const string PathToSpriteSet = "Localize/LocalizeSpriteSet";

		private Dictionary<string, LocalizeData.Param> _stringTranslates;

		private Dictionary<string, LocalizeSpriteSet.Param> _spriteTranslates;

		public IReadOnlyReactiveProperty<GameDefine.Languages> ChangeLanguageObservable => SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language;

		protected override void InitializeOnAwake()
		{
			base.InitializeOnAwake();
			LoadStringLocalizeData();
			LoadSpriteLocalizeData();
		}

		private void LoadStringLocalizeData()
		{
			LocalizeData localizeData = Resources.Load<LocalizeData>("Localize/LocalizeData");
			if (localizeData == null)
			{
				return;
			}
			_stringTranslates = new Dictionary<string, LocalizeData.Param>();
			foreach (LocalizeData.Param item in localizeData.param)
			{
				_stringTranslates.Add(item.KEY, item);
			}
		}

		private void LoadSpriteLocalizeData()
		{
			LocalizeSpriteSet localizeSpriteSet = Resources.Load<LocalizeSpriteSet>("Localize/LocalizeSpriteSet");
			if (localizeSpriteSet == null)
			{
				return;
			}
			_spriteTranslates = new Dictionary<string, LocalizeSpriteSet.Param>();
			foreach (LocalizeSpriteSet.Param item in localizeSpriteSet.param)
			{
				_spriteTranslates.Add(item.KEY, item);
			}
		}

		public string GetLocalizeString(string key)
		{
			return GetLocalizeString(key, ChangeLanguageObservable.Value);
		}

		public string GetLocalizeString(string key, GameDefine.Languages lang)
		{
			if (!_stringTranslates.TryGetValue(key, out var value))
			{
				return string.Empty;
			}
			return lang switch
			{
				GameDefine.Languages.Japanese => value.Japanese, 
				GameDefine.Languages.English => value.English, 
				GameDefine.Languages.German => value.German, 
				GameDefine.Languages.French => value.French, 
				GameDefine.Languages.Chinese => value.Chinese, 
				_ => string.Empty, 
			};
		}

		public Sprite GetLocalizeSprite(string key)
		{
			return GetLocalizeSprite(key, ChangeLanguageObservable.Value);
		}

		public Sprite GetLocalizeSprite(string key, GameDefine.Languages lang)
		{
			if (!_spriteTranslates.TryGetValue(key, out var value))
			{
				return null;
			}
			return value.Sprites[(int)lang];
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Sprite Localize Set", fileName = "LocalizeSpriteSet")]
	public class LocalizeSpriteSet : ScriptableObject
	{
		[Serializable]
		public class Param
		{
			public string KEY;

			[EnumLabel(typeof(GameDefine.Languages))]
			public Sprite[] Sprites;
		}

		public List<Param> param = new List<Param>();
	}
	[Serializable]
	public abstract class BaseSave
	{
		public class LoadingErrorException : Exception
		{
			public LoadingErrorException()
				: base("OOPS: Loading is failed by some reason.")
			{
			}

			public LoadingErrorException(string message)
				: base($"Loading says OOPS: {message}")
			{
			}
		}

		public class LoadingGameVersionErrorException : LoadingErrorException
		{
			public LoadingGameVersionErrorException()
				: base("Invalid version")
			{
			}

			public LoadingGameVersionErrorException(int current, int old)
				: base($"Game version fail (current = '{current}', got '{old}'.)")
			{
			}
		}

		public class LoadingFileVersionErrorException : LoadingErrorException
		{
			public LoadingFileVersionErrorException()
				: base("Invalid version")
			{
			}

			public LoadingFileVersionErrorException(int current, int old)
				: base($"File version fail (current = '{current}', got '{old}'.)")
			{
			}
		}

		private static readonly int MagicID = FileIOManagerBase.ToMagicID('S', 'a', 'v', 'e');

		protected int m_fileVersion;

		protected int m_gameVersion;

		public virtual int GameVersion => 0;

		public virtual int FileVersion { get; private set; }

		public string Path { get; protected set; }

		public BaseSave(string path)
		{
			Path = path;
		}

		public virtual void Clear()
		{
			m_gameVersion = GameVersion;
			m_fileVersion = FileVersion;
		}

		public void Load(BinaryReader reader)
		{
			Clear();
			if (reader.ReadInt32() != MagicID)
			{
				throw new LoadingErrorException("Wrong Magic ID");
			}
			m_gameVersion = reader.ReadInt32();
			if (GameVersion < m_gameVersion)
			{
				throw new LoadingGameVersionErrorException(GameVersion, m_gameVersion);
			}
			if (GameVersion > m_gameVersion)
			{
				OnLoadOldGameVersion(m_gameVersion, reader);
			}
			m_fileVersion = reader.ReadInt32();
			if (FileVersion < m_fileVersion)
			{
				throw new LoadingFileVersionErrorException(FileVersion, m_fileVersion);
			}
			if (FileVersion > m_fileVersion)
			{
				OnLoadOldFileVersion(m_fileVersion, reader);
			}
			LoadDataFromFile(m_fileVersion, reader);
		}

		protected abstract void LoadDataFromFile(int oldFileVersion, BinaryReader reader);

		protected virtual void OnLoadOldGameVersion(int oldVersion, BinaryReader reader)
		{
		}

		protected virtual void OnLoadOldFileVersion(int oldVersion, BinaryReader reader)
		{
			throw new LoadingFileVersionErrorException(FileVersion, oldVersion);
		}

		public void Save(BinaryWriter writer)
		{
			writer.Write(MagicID);
			writer.Write(GameVersion);
			writer.Write(FileVersion);
			SaveDataToFile(writer);
		}

		protected abstract void SaveDataToFile(BinaryWriter writer);
	}
	[Serializable]
	public class ConfigSave : BaseSave
	{
		public const float _DEFAULT_BGM_VOLUME = 1f;

		public const float _DEFAULT_SE_VOLUME = 1f;

		public const float _DEFAULT_VOICE_VOLUME = 1f;

		private const int _VERSION = 2;

		public override int FileVersion => 2;

		public ReactiveProperty<GameDefine.Languages> Language { get; private set; }

		public ReactiveProperty<float> BgmVolume { get; private set; }

		public ReactiveProperty<float> SeVolume { get; private set; }

		public ReactiveProperty<float> VoiceVolume { get; private set; }

		public ReactiveProperty<int> PlayerHeight { get; private set; }

		public ReactiveProperty<int> MessageHeight { get; private set; }

		public ReactiveProperty<int> MessageLength { get; private set; }

		public ReactiveProperty<int> MessageSpeed { get; private set; }

		public ReactiveProperty<VRDeviceDefine.HandType> PrefferedHand { get; private set; }

		public ReactiveProperty<bool> IsMessageFollowVertical { get; private set; }

		public ConfigSave(string path)
			: base(path)
		{
			Language = new ReactiveProperty<GameDefine.Languages>();
			BgmVolume = new ReactiveProperty<float>(1f);
			SeVolume = new ReactiveProperty<float>(1f);
			VoiceVolume = new ReactiveProperty<float>(1f);
			PlayerHeight = new ReactiveProperty<int>();
			MessageHeight = new ReactiveProperty<int>();
			MessageLength = new ReactiveProperty<int>();
			MessageSpeed = new ReactiveProperty<int>();
			PrefferedHand = new ReactiveProperty<VRDeviceDefine.HandType>(VRDeviceDefine.HandType.Right);
			IsMessageFollowVertical = new ReactiveProperty<bool>(initialValue: true);
			Language.Value = GetDeviceLanguage();
		}

		public static GameDefine.Languages GetDeviceLanguage()
		{
			if (UnityEngine.Application.systemLanguage == SystemLanguage.Japanese)
			{
				return GameDefine.Languages.Japanese;
			}
			if (UnityEngine.Application.systemLanguage == SystemLanguage.Chinese || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseSimplified || UnityEngine.Application.systemLanguage == SystemLanguage.ChineseTraditional)
			{
				return GameDefine.Languages.Chinese;
			}
			if (UnityEngine.Application.systemLanguage == SystemLanguage.German)
			{
				return GameDefine.Languages.German;
			}
			return GameDefine.Languages.English;
		}

		public override void Clear()
		{
			base.Clear();
			BgmVolume.Value = 1f;
			SeVolume.Value = 1f;
			VoiceVolume.Value = 1f;
			PlayerHeight.Value = 0;
			MessageHeight.Value = 0;
			MessageLength.Value = 0;
			MessageSpeed.Value = 0;
			PrefferedHand.Value = VRDeviceDefine.HandType.Right;
			IsMessageFollowVertical.Value = true;
			Language.Value = GetDeviceLanguage();
		}

		protected override void LoadDataFromFile(int oldFileVersion, BinaryReader reader)
		{
			try
			{
				BgmVolume.Value = reader.ReadSingle();
				SeVolume.Value = reader.ReadSingle();
				VoiceVolume.Value = reader.ReadSingle();
				PlayerHeight.Value = reader.ReadInt32();
				MessageHeight.Value = reader.ReadInt32();
				MessageLength.Value = reader.ReadInt32();
				MessageSpeed.Value = reader.ReadInt32();
				PrefferedHand.Value = (VRDeviceDefine.HandType)reader.ReadInt32();
				IsMessageFollowVertical.Value = reader.ReadBoolean();
				Language.Value = (GameDefine.Languages)reader.ReadInt32();
			}
			catch (EndOfStreamException)
			{
			}
		}

		protected override void SaveDataToFile(BinaryWriter writer)
		{
			writer.Write(BgmVolume.Value);
			writer.Write(SeVolume.Value);
			writer.Write(VoiceVolume.Value);
			writer.Write(PlayerHeight.Value);
			writer.Write(MessageHeight.Value);
			writer.Write(MessageLength.Value);
			writer.Write(MessageSpeed.Value);
			writer.Write((int)PrefferedHand.Value);
			writer.Write(IsMessageFollowVertical.Value);
			writer.Write((int)Language.Value);
		}

		public void ResetLanguageToSafe()
		{
			Language.Value = GameDefine.Languages.English;
		}
	}
	[Serializable]
	public class GameFileSave : BaseSave
	{
		[Serializable]
		public class Header
		{
			public int fileIndex;

			public bool IsEmpty;

			public bool IsCorrupted;

			public int SequenceID;

			public DateTimeOffset SavedTime;

			public Header(int id, bool isEmpty = false)
			{
				fileIndex = id;
				IsEmpty = isEmpty;
			}
		}

		private const int _VERSION = 1;

		public int SequenceID;

		public DateTimeOffset SavedTime;

		public override int FileVersion => 1;

		public GameFileSave(string path)
			: base(path)
		{
		}

		public override void Clear()
		{
			base.Clear();
			SequenceID = 0;
		}

		public void SetPath(string path)
		{
			base.Path = path;
		}

		protected override void LoadDataFromFile(int oldFileVersion, BinaryReader reader)
		{
			try
			{
				SequenceID = reader.ReadInt32();
				long ticks = reader.ReadInt64();
				TimeSpan offset = new TimeSpan(reader.ReadInt64());
				SavedTime = new DateTimeOffset(ticks, offset);
			}
			catch (EndOfStreamException)
			{
			}
		}

		protected override void SaveDataToFile(BinaryWriter writer)
		{
			SavedTime = DateTimeOffset.Now;
			writer.Write(SequenceID);
			writer.Write(SavedTime.Ticks);
			writer.Write(SavedTime.Offset.Ticks);
		}

		public Header CreateHeader(int fileIndex)
		{
			return new Header(fileIndex)
			{
				SequenceID = SequenceID,
				SavedTime = SavedTime
			};
		}

		public Header CreateEmptyHeader(int fileIndex)
		{
			return new Header(fileIndex, isEmpty: true);
		}

		public Header CreateCorruptedHeader(int fileIndex)
		{
			return new Header(fileIndex)
			{
				IsCorrupted = true
			};
		}
	}
	[Serializable]
	public class SystemSave : BaseSave
	{
		private const int _VERSION = 3;

		[SerializeField]
		private bool[] _gameFlags = new bool[62];

		[SerializeField]
		private List<int> _scenarioReaded = new List<int>();

		[SerializeField]
		private TimeSpan _totalPlayTime = TimeSpan.Zero;

		[SerializeField]
		private int _lastShowedFilePage;

		private DateTimeOffset _timeLastSaveModified;

		public override int FileVersion => 3;

		public TimeSpan TotalPlayTime
		{
			get
			{
				UpdatePlayTime();
				return _totalPlayTime;
			}
		}

		public int PlayTimeMin
		{
			get
			{
				UpdatePlayTime();
				return (int)Math.Floor(_totalPlayTime.TotalMinutes);
			}
		}

		public int LastShowedFilePage
		{
			get
			{
				return _lastShowedFilePage;
			}
			set
			{
				_lastShowedFilePage = value;
			}
		}

		public SystemSave(string path)
			: base(path)
		{
		}

		public override void Clear()
		{
			base.Clear();
			ResetAllFlags();
			ResetTime();
		}

		private void ResetAllFlags()
		{
			int num = _gameFlags.Length;
			for (int i = 0; i < num; i++)
			{
				_gameFlags[i] = false;
			}
			_scenarioReaded.Clear();
		}

		private void ResetTime()
		{
			_timeLastSaveModified = DateTimeOffset.Now;
			_totalPlayTime = TimeSpan.Zero;
		}

		public bool GetFlag(GameFlags flag)
		{
			return _gameFlags[(int)flag];
		}

		public bool GetFlag(int flagId)
		{
			return _gameFlags[flagId];
		}

		public void SetFlag(GameFlags flag, bool value)
		{
			_gameFlags[(int)flag] = value;
		}

		public bool AddReadFlag(int scenarioId)
		{
			if (IsScenarioReaded(scenarioId))
			{
				return false;
			}
			_scenarioReaded.Add(scenarioId);
			return true;
		}

		public bool IsScenarioReaded(int scenarioId)
		{
			return _scenarioReaded.Exists((int id) => id == scenarioId);
		}

		public void MakeAllReaded()
		{
			foreach (int key in SingletonMonoBehaviour<DataManager>.Instance.GeneralData.ScenarioList.Keys)
			{
				if (!IsScenarioReaded(key))
				{
					_scenarioReaded.Add(key);
				}
			}
		}

		public void ClearReadedFlag()
		{
			_scenarioReaded.Clear();
		}

		public void AddReadFlag_Debug(int scenarioId)
		{
		}

		protected override void LoadDataFromFile(int oldFileVersion, BinaryReader reader)
		{
			try
			{
				int num = reader.ReadInt32();
				for (int i = 0; i < num; i++)
				{
					_gameFlags[i] = reader.ReadBoolean();
				}
				int num2 = reader.ReadInt32();
				for (int j = 0; j < num2; j++)
				{
					int item = reader.ReadInt32();
					_scenarioReaded.Add(item);
				}
				_totalPlayTime = new TimeSpan(reader.ReadInt64());
				ResetTimeCaches();
				_lastShowedFilePage = reader.ReadInt32();
			}
			catch (EndOfStreamException)
			{
			}
		}

		protected override void OnLoadOldFileVersion(int oldVersion, BinaryReader reader)
		{
		}

		protected override void SaveDataToFile(BinaryWriter writer)
		{
			int num = _gameFlags.Length;
			writer.Write(num);
			for (int i = 0; i < num; i++)
			{
				writer.Write(_gameFlags[i]);
			}
			int count = _scenarioReaded.Count;
			writer.Write(count);
			for (int j = 0; j < count; j++)
			{
				int value = _scenarioReaded[j];
				writer.Write(value);
			}
			UpdatePlayTime();
			writer.Write(_totalPlayTime.Ticks);
			writer.Write(_lastShowedFilePage);
		}

		public void ResetTimeCaches()
		{
			_timeLastSaveModified = DateTimeOffset.Now;
		}

		private void UpdatePlayTime()
		{
			DateTimeOffset now = DateTimeOffset.Now;
			TimeSpan timeSpan = now - _timeLastSaveModified;
			_totalPlayTime += timeSpan;
			_timeLastSaveModified = now;
		}
	}
	public class SceneSoundData : ScriptableObject
	{
		[Serializable]
		public class DataSet
		{
			public GameDefine.CharaID Chara;

			public List<Data> Data;
		}

		[Serializable]
		public class Data
		{
			public float DistanceFromCenter;

			public DearVRSource.RoomList RoomList = DearVRSource.RoomList.Direct_Signal;

			public float GainLevel;

			public float ReflectionLP;

			public float ReflectionLevel;

			public float ReverbLevel;

			public float DirectLevel;

			public float AzimuthCorrection;

			public float DistanceCorrection;
		}

		public List<DataSet> DataList;

		public DataSet FindDataSet(GameDefine.CharaID chara)
		{
			int count = DataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (DataList[i].Chara == chara)
				{
					return DataList[i];
				}
			}
			return null;
		}

		public bool TryFindDataSet(GameDefine.CharaID chara, ref DataSet data)
		{
			int count = DataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (DataList[i].Chara == chara)
				{
					data = DataList[i];
					return true;
				}
			}
			return false;
		}
	}
	public class CharaTable : IExcelTable<Entity_CharaName>
	{
		private const string _FILE_NAME = "CharaName";

		public override int GetCount()
		{
			return m_data.param.Count;
		}

		public override void Load()
		{
			m_data = Resources.Load<Entity_CharaName>("Settings/CharaName");
		}

		public Entity_CharaName.Param GetData(int index)
		{
			return m_data.param[index];
		}

		public Entity_CharaName.Param FindDataByID(GameDefine.CharaID charaID)
		{
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].id == (int)charaID)
				{
					return m_data.param[i];
				}
			}
			return null;
		}

		public Entity_CharaName.Param FindDataByName(string name)
		{
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].name == name)
				{
					return m_data.param[i];
				}
			}
			return null;
		}

		public string FindName(GameDefine.CharaID charaID)
		{
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.CharaID.UNKNOWN;
			}
			Entity_CharaName.Param param = FindDataByID(charaID);
			if (param == null)
			{
				return string.Empty;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				return param.ja;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Chinese)
			{
				return param.ch;
			}
			return param.en;
		}

		public GameDefine.CharaID NameToID(string name)
		{
			return (GameDefine.CharaID)(FindDataByName(name)?.id ?? 100);
		}
	}
	public class CharaTextDataTable : IExcelTable<Data_Character>
	{
		private const string _FILE_NAME = "DataCharacter";

		public override int GetCount()
		{
			return m_data.param.Count;
		}

		public override void Load()
		{
			m_data = Resources.Load<Data_Character>("Settings/DataCharacter");
		}

		public Data_Character.Param GetData(int index)
		{
			return m_data.param[index];
		}

		public Data_Character.Param FindDataByID(GameDefine.CharaID charaID)
		{
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.UnknownToCharaID(charaID);
			}
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].id == charaID)
				{
					return m_data.param[i];
				}
			}
			return null;
		}

		public Data_Character.Param FindDataByName(string name)
		{
			int count = m_data.param.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_data.param[i].name == name)
				{
					return m_data.param[i];
				}
			}
			return null;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create Character Data", fileName = "DataCharacter")]
	public class Data_Character : ScriptableObject
	{
		[Serializable]
		public class Param
		{
			public GameDefine.CharaID id;

			public string name;

			public Color colorBackground = Color.white;

			public Color colorText = Color.black;
		}

		public List<Param> param;
	}
	public abstract class IExcelTable<T> where T : ScriptableObject
	{
		protected T m_data;

		public bool isValid => m_data != null;

		public IExcelTable()
		{
			m_data = null;
		}

		public abstract void Load();

		public abstract int GetCount();

		public virtual void Clear()
		{
			if (m_data != null)
			{
				Resources.UnloadAsset(m_data);
				m_data = null;
			}
		}

		public virtual void ClearImmediate()
		{
			if (m_data != null)
			{
				UnityEngine.Object.DestroyImmediate(m_data, allowDestroyingAssets: true);
				m_data = null;
			}
		}
	}
	public class ScenarioTextTable : IExcelTable<ScenarioTableData>
	{
		private const string _FILE_NAME = "ScenarioData{0:D5}";

		private const string _PATH = "Tables/ScenarioData{0:D5}";

		public ScenarioTextTable()
		{
		}

		public ScenarioTextTable(ScenarioTableData data)
		{
			m_data = data;
		}

		public override int GetCount()
		{
			if (m_data == null)
			{
				return 0;
			}
			return m_data.param.Count;
		}

		public override void Load()
		{
			throw new NotImplementedException();
		}

		public void Load(int scenarioID)
		{
			Clear();
			m_data = Resources.Load<ScenarioTableData>($"Tables/ScenarioData{scenarioID:D5}");
		}

		public void Load(string fullPath)
		{
			Clear();
			m_data = Resources.Load<ScenarioTableData>(fullPath);
		}

		public ScenarioTableData.Param GetData(int index)
		{
			if (index < 0 || index >= m_data.param.Count)
			{
				return null;
			}
			return m_data.param[index];
		}

		public string GetText(int index)
		{
			if (index < 0 || index >= m_data.param.Count)
			{
				return string.Empty;
			}
			if (SingletonMonoBehaviour<GameData>.Instance == null || SingletonMonoBehaviour<GameData>.Instance.ConfigData == null)
			{
				return m_data.param[index].TextJp;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Japanese)
			{
				return m_data.param[index].TextJp;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.Chinese)
			{
				return m_data.param[index].TextCh;
			}
			if (SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value == GameDefine.Languages.German)
			{
				return m_data.param[index].TextGe;
			}
			return m_data.param[index].TextEg;
		}
	}
	[CreateAssetMenu(menuName = "Chronos/Create SequenceData", fileName = "SequenceData00000")]
	public class SequenceData : ScriptableObject
	{
		[Serializable]
		public class Param
		{
			public ISequenceCommand.Types CommandType;

			public List<int> DataInt = new List<int>();

			public List<float> DataFloat = new List<float>();

			public List<string> DataString = new List<string>();

			public int GetInt(int index, int defaultValue = 0)
			{
				if (index < DataInt.Count)
				{
					return DataInt[index];
				}
				return defaultValue;
			}

			public float GetFloat(int index, float defaultValue = 0f)
			{
				if (index < DataFloat.Count)
				{
					return DataFloat[index];
				}
				return defaultValue;
			}

			public string GetString(int index, string defaultValue = "")
			{
				if (index < DataString.Count)
				{
					return DataString[index];
				}
				return defaultValue;
			}

			public Vector3 GetVector3(int startIndex)
			{
				if (startIndex < DataFloat.Count + 2)
				{
					return new Vector3(DataFloat[startIndex], DataFloat[startIndex + 1], DataFloat[startIndex + 2]);
				}
				return Vector3.zero;
			}

			public Vector3 GetVector3(int startIndex, Vector3 defaultValue)
			{
				if (startIndex < DataFloat.Count + 2)
				{
					return new Vector3(DataFloat[startIndex], DataFloat[startIndex + 1], DataFloat[startIndex + 2]);
				}
				return defaultValue;
			}
		}

		public int Version;

		public List<Param> param;
	}
	public class SequenceTable : IExcelTable<SequenceData>
	{
		public const string _FILE_NAME = "SequenceData{0:D5}";

		private const string _PATH = "Tables/SequenceData{0:D5}";

		public SequenceTable()
		{
		}

		public SequenceTable(SequenceData data)
		{
			m_data = data;
		}

		public override int GetCount()
		{
			if (m_data == null || m_data.param == null)
			{
				return 0;
			}
			return m_data.param.Count;
		}

		public override void Load()
		{
		}

		public void Load(int scenarioID)
		{
			Clear();
			m_data = Resources.Load<SequenceData>($"Tables/SequenceData{scenarioID:D5}");
		}

		public void Load(string fullPath)
		{
			Clear();
			m_data = Resources.Load<SequenceData>(fullPath);
		}

		public SequenceData.Param GetData(int index)
		{
			return m_data.param[index];
		}

		public int GetVersion()
		{
			return m_data.Version;
		}

		public void SetData(SequenceData data)
		{
			m_data = data;
		}
	}
	public class AdvCutScene : MonoBehaviour
	{
		[Header("Components - Timeline")]
		[SerializeField]
		private PlayableDirector _playableDirector;

		[SerializeField]
		private bool m_isForceCpuThrottle;

		[SerializeField]
		private int m_startWaitFrames = 2;

		private bool _isPlayStarted;

		private bool _isFinished;

		private bool _pauseRequested;

		private IDisposable _disposeTimeline;

		private HashSet<Component> _pauseRequestList = new HashSet<Component>();

		private Subject<Unit> _subjectStartTimeline = new Subject<Unit>();

		private Subject<Unit> _subjectCompleteTimeline = new Subject<Unit>();

		private Subject<Unit> _subjectForwardCommand = new Subject<Unit>();

		public bool IsFinished => _isFinished;

		public PlayableDirector Director => _playableDirector;

		public IObservable<Unit> StartTimelineObservable => _subjectStartTimeline;

		public IObservable<Unit> CompleteTimelineObservable => _subjectCompleteTimeline;

		public IObservable<Unit> ForwardCommandObservable => _subjectForwardCommand;

		private void Start()
		{
			_isFinished = false;
			BindFader(SingletonMonoBehaviour<FadeManager>.Instance.sceneFader);
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.OnBeforeTransition.Take(1).Subscribe(delegate
			{
				DisposeTimeline();
			});
			if (!SingletonMonoBehaviour<MasterManager>.Instance.IsInGame)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(ColorDefine.TransparentBlack);
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.TransparentBlack, 0f, isDeactivateOnEnd: true);
				CompleteTimelineObservable.Take(1).Subscribe(delegate
				{
					SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
				});
				IObservable<Unit> source = SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel));
				Observable.TakeUntil(other: SingletonMonoBehaviour<GameLogic>.Instance.UpdateObservable.Where((Unit _) => SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonUp(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel)), source: source.SelectMany((Unit _) => Observable.Timer(TimeSpan.FromSeconds(1.0)))).RepeatUntilDestroy(base.gameObject).Subscribe(delegate
				{
					SingletonMonoBehaviour<MasterManager>.Instance.ForceToTitle();
				});
			}
			int buildIndex = base.gameObject.scene.buildIndex;
			if (SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId == (SceneDefine)buildIndex)
			{
				PrepareTimeline();
			}
			else
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Where((Scene scene) => scene.buildIndex == buildIndex).Take(1).Subscribe(delegate
				{
					PrepareTimeline();
				})
					.AddTo(base.gameObject);
			}
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => _isPlayStarted && !_isFinished && flag).Subscribe(delegate
			{
				AddPauseRequest(this);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => _isPlayStarted && !_isFinished && !flag).Subscribe(delegate
			{
				RemovePauseRequest(this);
			}).AddTo(base.gameObject);
		}

		public void PrepareTimeline()
		{
			if (m_isForceCpuThrottle)
			{
				VrUtility.OnLoadStart(isChangeGraphics: false);
			}
			if (m_startWaitFrames <= 0)
			{
				StartTimeline();
				return;
			}
			Observable.TimerFrame(m_startWaitFrames).Subscribe(delegate
			{
				StartTimeline();
			});
		}

		private void StartTimeline()
		{
			_disposeTimeline = _playableDirector.PlayAsStream().Subscribe(delegate
			{
				_isFinished = true;
				_subjectForwardCommand.OnNext(Unit.Default);
				_subjectCompleteTimeline.OnNext(Unit.Default);
			});
			_isPlayStarted = true;
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeExitFade.Subscribe(delegate
			{
				DisposeTimeline();
			}).AddTo(base.gameObject);
			_subjectStartTimeline.OnNext(Unit.Default);
		}

		public void AddPauseRequest(Component comp)
		{
			if (_pauseRequestList.Add(comp) && !_pauseRequested)
			{
				_pauseRequested = true;
				UpdatePause();
			}
		}

		public void RemovePauseRequest(Component comp)
		{
			if (_pauseRequestList.Remove(comp) && _pauseRequestList.Count == 0 && _pauseRequested)
			{
				_pauseRequested = false;
				UpdatePause();
			}
		}

		private void UpdatePause()
		{
			if (_isPlayStarted && !_isFinished)
			{
				if (_pauseRequested)
				{
					_playableDirector.Pause();
				}
				else
				{
					_playableDirector.Play();
				}
			}
		}

		public void DisposeTimeline()
		{
			if (_disposeTimeline != null)
			{
				if (m_isForceCpuThrottle)
				{
					VrUtility.OnLoadEnd(isChangeGraphics: false);
				}
				_isPlayStarted = false;
				_disposeTimeline.Dispose();
			}
		}

		private void OnDestroy()
		{
			DisposeTimeline();
		}

		private void OnApplicationQuit()
		{
			DisposeTimeline();
		}

		private void BindFader(UIFader uiFader)
		{
			PlayableBinding playableBinding = _playableDirector.playableAsset.outputs.FirstOrDefault((PlayableBinding c) => c.streamName == "Fade Cat Scene Track");
			if (playableBinding.sourceObject != null)
			{
				_playableDirector.SetGenericBinding(playableBinding.sourceObject, uiFader);
			}
		}
	}
	public static class AnalyticsUtility
	{
		private const string _KEY_FLAG_FIRST = "Flag: {0}";

		private const string _KEY_FLAG_AGAIN = "Flag Again: {0}";

		private const string _KEY_PLAYTIME = "Playtime: {0}";

		private const string _KEY_SKIP = "Skip";

		private const string _PARAM_SCENARIO_ID = "Scenario ID";

		private const string _PARAM_FLAGS = "Flags";

		private const string _PARAM_TIME = "PlayTime";

		private static Dictionary<string, object> _flagParameters = new Dictionary<string, object>();

		private static Dictionary<string, object> _skipParameters = new Dictionary<string, object>();

		public static void Initialize()
		{
			_flagParameters.Add("Flags", 0);
			_flagParameters.Add("PlayTime", 0);
			_skipParameters.Add("Scenario ID", 0);
			_skipParameters.Add("Flags", 0);
			_skipParameters.Add("PlayTime", 0);
		}

		public static void SendSkipEvent()
		{
			SetupFlagParamToSend(_skipParameters);
			SetupPlaytimeParamToSend(_skipParameters);
			SetupScenarioIDParamToSend(_skipParameters);
			AnalyticsEvent.Custom("Skip", _skipParameters);
		}

		public static void SendFlagEvent(GameFlags flag, bool flagValue)
		{
			if (IsSendFlagData(flag, flagValue))
			{
				SetupFlagParamToSend(_flagParameters);
				SetupPlaytimeParamToSend(_flagParameters);
				if (SingletonMonoBehaviour<GameData>.Instance.SystemData.GetFlag(flag))
				{
					AnalyticsEvent.Custom($"Flag Again: {flag}", _flagParameters);
				}
				else
				{
					AnalyticsEvent.Custom($"Flag: {flag}", _flagParameters);
				}
			}
		}

		private static bool IsSendFlagData(GameFlags flag, bool flagValue)
		{
			return flagValue;
		}

		private static void SetupParamToSend()
		{
		}

		private static void SetupFlagParamToSend(Dictionary<string, object> param)
		{
			long num = 0L;
			int num2 = 62;
			for (int i = 0; i < num2; i++)
			{
				if (SingletonMonoBehaviour<GameData>.Instance.GetFlag((GameFlags)i))
				{
					num += 1 << i;
				}
			}
			param["Flags"] = num;
		}

		private static void SetupPlaytimeParamToSend(Dictionary<string, object> param)
		{
			param["PlayTime"] = SingletonMonoBehaviour<GameData>.Instance.SystemData.PlayTimeMin;
		}

		private static void SetupScenarioIDParamToSend(Dictionary<string, object> param)
		{
			if (param.ContainsKey("Scenario ID"))
			{
				param["Scenario ID"] = SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID;
			}
		}
	}
	public class AudioFader : UpdateableComponent
	{
		[SerializeField]
		private AudioSource source;

		[SerializeField]
		private float defaultFadeTime = 1.5f;

		private Common.Timer m_fadeTimer;

		private UnityAction m_onEndFade;

		private AudioClip m_autoNextClip;

		private float m_initialVolume;

		protected override void Initialize()
		{
			if (source == null)
			{
				source = GetComponent<AudioSource>();
			}
			InitFade(source, defaultFadeTime);
		}

		public override void OnUpdate(float delta)
		{
			if (m_fadeTimer == null)
			{
				base.enabled = false;
				return;
			}
			m_fadeTimer.Update(delta);
			if (m_fadeTimer.IsTimeUp)
			{
				source.Stop();
				source.volume = m_initialVolume;
				if (m_onEndFade != null)
				{
					m_onEndFade();
				}
				base.enabled = false;
			}
			else
			{
				float rate = m_fadeTimer.Rate;
				source.volume = m_initialVolume * (1f - rate);
			}
		}

		public void InitFade(AudioSource s, float time)
		{
			m_fadeTimer = new Common.Timer(time);
			source = s;
			ResetVolumeToSource();
			base.enabled = false;
		}

		public void ResetVolumeToSource()
		{
			m_initialVolume = source.volume;
		}

		public void SetVolume(float v)
		{
			m_initialVolume = v;
		}

		public void SetOnEndFade(UnityAction ev)
		{
			m_onEndFade = ev;
		}

		public void SetAutoNextClip(AudioClip clip)
		{
			m_autoNextClip = clip;
			if (clip != null)
			{
				SetOnEndFade(PlayNextClip);
			}
		}

		public void StartFade(float time = -1f)
		{
			if (!base.enabled && source.isPlaying)
			{
				if (time >= 0f)
				{
					m_fadeTimer.SetDuration(time, isReset: false);
				}
				m_fadeTimer.Reset();
				base.enabled = true;
			}
		}

		public void PlayNextClip()
		{
			if (!(m_autoNextClip == null))
			{
				source.clip = m_autoNextClip;
				m_autoNextClip = null;
				source.Play();
			}
		}
	}
	public class BgmPlayer
	{
		public enum StopMode
		{
			Immidiate,
			Fade,
			Outro
		}

		private const int _LAYERS = 3;

		private const int _INITIAL_CLIP_LIST_SIZE = 12;

		private KainePlayer m_player;

		private KaineLoader m_loader;

		private SimpleSoundLoader m_simpleLoader;

		private BgmData m_data;

		private int m_currentID;

		private int m_reservedID;

		private KainePlayer.Layers m_reservedLayer;

		private bool m_isTrackPrepared;

		private List<AudioClip>[] m_clips;

		private AudioSourceFader m_actionSource;

		private Action m_onSimpleBgmEnd;

		public bool IsPlaying => m_player.IsPlaying;

		public bool IsLoading => m_loader.IsLoading;

		public bool IsKaineStopping => m_player.IsStopping;

		public bool IsBgmReserved => m_reservedID != -1;

		public BgmPlayer(KainePlayer kaine, BgmData data)
		{
			m_actionSource = null;
			m_currentID = -1;
			m_reservedID = -1;
			m_player = kaine;
			m_data = data;
			m_isTrackPrepared = false;
			m_loader = new KaineLoader(data, 3);
			m_simpleLoader = new SimpleSoundLoader();
			m_clips = new List<AudioClip>[3];
			for (int i = 0; i < 3; i++)
			{
				m_clips[i] = new List<AudioClip>(12);
			}
			m_player.OnEndPlay = delegate
			{
				OnEndBgm();
			};
			m_onSimpleBgmEnd = delegate
			{
				OnSimpleBgmStopFadeEnd();
			};
		}

		public void InitialLoad()
		{
			List<ISoundCommand> list = new List<ISoundCommand>();
			List<ISoundCommand> simpleBgmList = new List<ISoundCommand>();
			list.Add(new CommandBgm(0, KainePlayer.Layers.Lead));
			Load(list, simpleBgmList, null);
		}

		public void Clear()
		{
			m_isTrackPrepared = false;
			int num = m_clips.Length;
			for (int i = 0; i < num; i++)
			{
				m_clips[i].Clear();
			}
			m_player.Clear();
			m_loader.Clear();
			m_simpleLoader.Clear();
			m_currentID = -1;
			m_reservedID = -1;
			m_actionSource = null;
		}

		public void Load(List<ISoundCommand> bgmList, List<ISoundCommand> simpleBgmList, ISoundCommand firstBgm)
		{
			m_loader.Load(bgmList, firstBgm);
			m_simpleLoader.Load(simpleBgmList);
		}

		public void Play(int id, KainePlayer.Layers layer)
		{
			if (id == m_currentID)
			{
				if (layer != m_player.CurrentLayer)
				{
					SetLayer(layer);
				}
			}
			else if (m_player.IsPlaying)
			{
				m_reservedID = id;
				m_reservedLayer = layer;
				if (!m_player.IsStopping)
				{
					m_player.StopAllLayersWithFade();
				}
			}
			else
			{
				PrepareTrack(id);
				m_currentID = id;
				m_isTrackPrepared = false;
				m_player.PlayBgm(layer);
			}
		}

		public bool PreparePlay(int id, KainePlayer.Layers layer)
		{
			if (id == m_currentID)
			{
				if (layer != m_player.CurrentLayer)
				{
					SetLayer(layer);
				}
				return false;
			}
			if (m_player.IsPlaying)
			{
				m_reservedID = id;
				m_reservedLayer = layer;
				if (!m_player.IsStopping)
				{
					m_player.StopAllLayersWithFade();
				}
				return false;
			}
			PrepareTrack(id);
			m_currentID = id;
			m_isTrackPrepared = false;
			return true;
		}

		public void StartPlay(KainePlayer.Layers layer)
		{
			m_player.PlayBgm(layer);
		}

		public void PrepareFirstTrack()
		{
			if (m_loader.FirstBgmID != -1 && !IsPlaying)
			{
				m_isTrackPrepared = false;
				PrepareTrack(m_loader.FirstBgmID);
			}
		}

		private void PrepareTrack(int id)
		{
			if (m_isTrackPrepared || (id == m_currentID && m_currentID != -1))
			{
				m_isTrackPrepared = true;
				return;
			}
			SetupTrackInfo(id);
			SetupClipsToLayers(id);
			m_isTrackPrepared = true;
		}

		private void SetupTrackInfo(int id)
		{
			BgmData.Param param = m_data.FindByID(id);
			m_player.SetupTrackInfo(param.Bpm, param.Bars, param.Beats, param.UnitPerBar, param.FadeBars, param.Layer, param.Intro, param.SingleClip);
		}

		private void SetupClipsToLayers(int id)
		{
			m_player.Clear();
			int frequency = m_loader.FindFrequency(id);
			for (int i = 0; i < m_player.NumberOfLayers; i++)
			{
				m_player.SetupPartsClips(i, ConvertToClipList(m_loader.FindPartsList(id, i), i));
				m_player.SetupIntroClips(i, frequency, m_loader.FindIntros(id, i));
				m_player.SetupOutroClips(i, m_loader.FindOutros(id, i));
			}
		}

		private List<AudioClip> ConvertToClipList(List<KaineLoader.PartsData> dataList, int layer)
		{
			m_clips[layer].Clear();
			int count = dataList.Count;
			for (int i = 0; i < count; i++)
			{
				m_clips[layer].Add(dataList[i].Clip);
			}
			return m_clips[layer];
		}

		public void Stop(StopMode mode)
		{
			switch (mode)
			{
			case StopMode.Fade:
				m_player.StopAllLayersWithFade();
				break;
			case StopMode.Immidiate:
				m_player.StopAllLayers();
				break;
			case StopMode.Outro:
				m_player.ReserveOutro();
				break;
			}
		}

		private void OnEndBgm()
		{
			m_currentID = -1;
			m_actionSource = null;
			if (IsBgmReserved)
			{
				Play(m_reservedID, m_reservedLayer);
				m_reservedID = -1;
			}
		}

		public void SetLayer(KainePlayer.Layers layer)
		{
			m_player.ChangeLayer(layer);
		}

		public float GetSecondsFromBars(int numBars, bool isCountCurrentBar, bool isCheckPlaying = true)
		{
			return m_player.GetTimeFromBars(numBars, isCountCurrentBar, isCheckPlaying);
		}

		public float GetIntroDuration()
		{
			return m_player.GetIntroDuration();
		}

		public void PlaySimple(int id, float volume, float fadeDuration = 0.6f)
		{
			AudioClip audioClip = m_simpleLoader.FindAudio(id);
			if (!(audioClip == null))
			{
				PlaySimple(audioClip, volume, fadeDuration);
			}
		}

		public void PlaySimple(AudioClip clip, float volume, float fadeDuration = 0.6f)
		{
			m_player.PlaySimpleBgm(clip, volume, fadeDuration);
		}

		public void StopSimple(float fadeDuration)
		{
			m_player.StopSimpleBgm(fadeDuration);
		}

		public void SetSimpleVolume(float volume, float fadeDuration)
		{
			m_player.SetSimpleVolume(volume, fadeDuration);
		}

		public void PlaySimple(AudioSourceFader source, int id, float volume, float fadeDuration = 0.6f)
		{
			AudioClip audioClip = m_simpleLoader.FindAudio(id);
			if (!(audioClip == null))
			{
				source.PlayWithFade(volume, 0f, fadeDuration, audioClip);
			}
		}

		public void StopSimpleBgm(AudioSourceFader source, float fadeDuration)
		{
			if (fadeDuration <= 0f)
			{
				source.Stop();
				return;
			}
			m_actionSource = source;
			source.StopWithFade(fadeDuration, m_onSimpleBgmEnd);
		}

		private void OnSimpleBgmStopFadeEnd()
		{
			m_actionSource.SetClip(null);
			m_actionSource = null;
		}

		public void SetSimpleVolume(AudioSourceFader source, float volume, float fadeDuration)
		{
			source.FadeVolume(fadeDuration, volume);
		}
	}
	public class CharaVoiceSource : MonoBehaviour
	{
		[SerializeField]
		private AudioSource m_audioSource;

		[SerializeField]
		private DearVRSource m_dearVr;

		[SerializeField]
		private OVRLipSyncContextCanned m_lipSyncContext;

		[SerializeField]
		private OVRLipSyncContextMorphTarget m_lipSyncContextMorph;

		[SerializeField]
		private GameDefine.CharaID m_charaID = GameDefine.CharaID.TOUGOKU;

		[SerializeField]
		private int[] m_mouthMorphIndex;

		private Transform m_target;

		private Transform m_transform;

		private GameObject m_targetObject;

		private SkinnedMeshRenderer m_skinnedMeshRenderer;

		private bool m_isPlaying;

		private bool m_isClipPlaying;

		private bool m_isLipsync;

		public AudioSource AudioSource => m_audioSource;

		public DearVRSource DearVr => m_dearVr;

		public GameDefine.CharaID CharaID => m_charaID;

		public OVRLipSyncContextCanned LipSyncContext => m_lipSyncContext;

		public OVRLipSyncContextMorphTarget LipSyncContextMorph => m_lipSyncContextMorph;

		private void Start()
		{
			m_isLipsync = false;
			m_isPlaying = false;
			m_isClipPlaying = false;
			m_transform = base.transform;
		}

		private void Update()
		{
			if (m_isPlaying)
			{
				if (m_isClipPlaying && !m_audioSource.isPlaying)
				{
					m_isClipPlaying = false;
					ResetLipsync();
				}
				if (!m_dearVr.clipIsPlaying)
				{
					StopVoice();
				}
				else if (!(m_target == null) && !(m_targetObject == null) && m_targetObject.activeSelf)
				{
					m_transform.position = m_target.position;
					m_transform.rotation = m_target.rotation;
				}
			}
		}

		public void SetupToLocator(GameDefine.CharaID charaID, Transform targetLocator)
		{
			m_charaID = charaID;
			m_targetObject = null;
			m_target = targetLocator;
			m_transform.position = targetLocator.position;
		}

		public void SetupChara(GameDefine.CharaID charaID)
		{
			m_charaID = charaID;
			AdvChara chara = SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(charaID);
			m_target = chara.Head;
			if (m_target != null)
			{
				m_targetObject = chara.HeadObject;
				m_transform.position = m_target.position;
			}
			SetSkinnedMesh(chara.FaceRenderer);
		}

		public void SetSkinnedMesh(SkinnedMeshRenderer renderer)
		{
			m_lipSyncContextMorph.skinnedMeshRenderer = renderer;
			m_skinnedMeshRenderer = renderer;
		}

		public void Play(bool isLipsync)
		{
			m_isLipsync = isLipsync;
			m_isPlaying = true;
			m_isClipPlaying = true;
			m_dearVr.DearVRPlay();
			if (isLipsync)
			{
				m_lipSyncContext.enabled = true;
				m_lipSyncContextMorph.enabled = true;
			}
		}

		public void StopVoice()
		{
			m_isClipPlaying = false;
			m_isPlaying = false;
			m_dearVr.DearVRStop();
			ResetLipsync();
		}

		private void ResetLipsync()
		{
			if (m_isLipsync)
			{
				m_isLipsync = false;
				ResetMouthMorph(m_skinnedMeshRenderer);
				m_lipSyncContext.enabled = false;
				m_lipSyncContextMorph.enabled = false;
			}
		}

		public void ResetMouthMorph(SkinnedMeshRenderer renderer)
		{
			if (!(renderer == null) && m_mouthMorphIndex != null)
			{
				int num = m_mouthMorphIndex.Length;
				for (int i = 0; i < num; i++)
				{
					renderer.SetBlendShapeWeight(m_mouthMorphIndex[i], 0f);
				}
				LipSyncContext.ResetContext();
			}
		}

		public void SetupDearVR(ref SceneSoundData settingData)
		{
			if (!(settingData == null))
			{
				SceneSoundData.DataSet dataSet = settingData.FindDataSet(m_charaID);
				if (dataSet != null)
				{
					SceneSoundData.Data data = FindSoundData(dataSet);
					m_dearVr.RoomPreset = data.RoomList;
					m_dearVr.GainLevel = data.GainLevel;
					m_dearVr.ReflectionLP = data.ReflectionLP;
					m_dearVr.ReflectionLevel = data.ReflectionLevel;
					m_dearVr.ReverbLevel = data.ReverbLevel;
					m_dearVr.DirectLevel = data.DirectLevel;
					m_dearVr.AzimuthCorrection = data.AzimuthCorrection;
					m_dearVr.DistanceCorrection = data.DistanceCorrection;
				}
			}
		}

		private SceneSoundData.Data FindSoundData(SceneSoundData.DataSet data)
		{
			Vector3 left = MainPosition.MainTransform.position;
			Vector3 right = m_target.position;
			float num = Vector3Extension.DistanceSquared(ref left, ref right);
			int count = data.Data.Count;
			for (int i = 0; i < count; i++)
			{
				if (num <= data.Data[i].DistanceFromCenter * data.Data[i].DistanceFromCenter)
				{
					return data.Data[i];
				}
			}
			return data.Data[count - 1];
		}

		public void SetupMorphTarget(AdvCharaMorpthTargetData dataList, VoiceLoader.Data voiceData)
		{
			AdvCharaMorpthTargetData.Data data = dataList.FindData(m_charaID);
			m_mouthMorphIndex = data.MorpthTargetIndex;
			m_lipSyncContextMorph.VisemeToBlendTargets = data.MorpthTargetIndex;
			m_lipSyncContext.currentSequence = voiceData.LipSyncData;
		}
	}
	public class DearVrPlayer : MonoBehaviour
	{
		[SerializeField]
		private DearVRSource m_dearVRSource;

		[SerializeField]
		private AudioSource m_audioSource;

		private Transform m_transform;

		public int CurrentID { get; private set; }

		public bool IsPlaying => m_audioSource.isPlaying;

		private void Start()
		{
			CurrentID = -1;
			m_transform = base.transform;
		}

		public void SetupPosition(ref Vector3 position)
		{
			m_transform.localPosition = position;
		}

		public void Setup(SceneSoundData settingData, ref Vector3 position, GameDefine.CharaID charaID = GameDefine.CharaID.BASE)
		{
			m_transform.localPosition = position;
			SceneSoundData.DataSet data = null;
			if (settingData.TryFindDataSet(charaID, ref data))
			{
				SceneSoundData.Data data2 = FindSoundData(data);
				m_dearVRSource.RoomPreset = data2.RoomList;
				m_dearVRSource.GainLevel = data2.GainLevel;
				m_dearVRSource.ReflectionLP = data2.ReflectionLP;
				m_dearVRSource.ReflectionLevel = data2.ReflectionLevel;
				m_dearVRSource.ReverbLevel = data2.ReverbLevel;
				m_dearVRSource.DirectLevel = data2.DirectLevel;
				m_dearVRSource.AzimuthCorrection = data2.AzimuthCorrection;
				m_dearVRSource.DistanceCorrection = data2.DistanceCorrection;
			}
		}

		private SceneSoundData.Data FindSoundData(SceneSoundData.DataSet data)
		{
			Vector3 left = SingletonMonoBehaviour<MainPosition>.Instance.transform.position;
			Vector3 right = m_transform.position;
			left.y = 0f;
			right.y = 0f;
			float num = Vector3Extension.DistanceSquared(ref left, ref right);
			int count = data.Data.Count;
			for (int i = 0; i < count; i++)
			{
				if (num <= data.Data[i].DistanceFromCenter * data.Data[i].DistanceFromCenter)
				{
					return data.Data[i];
				}
			}
			return data.Data[count - 1];
		}

		public void Play(AudioClip clip, int soundID, float volume, bool isLoop = false)
		{
			CurrentID = soundID;
			m_audioSource.loop = isLoop;
			m_audioSource.clip = clip;
			m_audioSource.volume = volume;
			m_dearVRSource.DearVRPlay();
		}

		public void Stop()
		{
			m_dearVRSource.DearVRStop();
		}
	}
	public class SePlayer
	{
		private AudioSource m_sourceSystemSe;

		private DearVrPlayer[] m_dearVrSourceSE;

		private ListPosition m_3dSEIndex;

		private SceneSoundData m_sceneSettings;

		private SimpleSoundLoader m_loader;

		private List<AudioClip> m_systemSoundClips;

		private bool m_hasValidSceneData;

		public bool IsLoading => m_loader.IsLoading;

		public float Volume => SingletonMonoBehaviour<GameData>.Instance.ConfigData.SeVolume.Value;

		private AudioSource SourceMain => MainPosition.AudioSourceEffect;

		public SePlayer(AudioSource sourceSystemSe, List<AudioClip> systemSoundClips, DearVrPlayer[] dearVrSource)
		{
			m_loader = new SimpleSoundLoader();
			m_dearVrSourceSE = dearVrSource;
			m_sourceSystemSe = sourceSystemSe;
			m_systemSoundClips = systemSoundClips;
			m_3dSEIndex = new ListPosition
			{
				Count = dearVrSource.Length
			};
			m_3dSEIndex.Height = m_3dSEIndex.Count;
			m_3dSEIndex.Select(0);
		}

		public void Clear()
		{
			m_loader.Clear();
		}

		public AudioClip FindClip(int id)
		{
			return m_loader.FindAudio(id);
		}

		public void SetSceneSettings(SceneSoundData data)
		{
			m_sceneSettings = data;
			m_hasValidSceneData = data != null;
		}

		public bool IsPlaying2D()
		{
			return SourceMain.isPlaying;
		}

		public bool IsPlayingAny()
		{
			if (SourceMain.isPlaying)
			{
				return true;
			}
			int num = m_dearVrSourceSE.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_dearVrSourceSE[i].IsPlaying)
				{
					return true;
				}
			}
			return false;
		}

		public void PlaySystem(SoundDefine.SystemSE se, AudioSource source = null)
		{
			if (source == null)
			{
				source = m_sourceSystemSe;
			}
			if ((int)se < m_systemSoundClips.Count)
			{
				AudioClip clip = m_systemSoundClips[(int)se];
				source.PlayOneShot(clip);
			}
		}

		public void PlaySystemLoop(SoundDefine.SystemSE se, AudioSource source = null)
		{
			if (source == null)
			{
				source = m_sourceSystemSe;
			}
			if ((int)se < m_systemSoundClips.Count)
			{
				AudioClip clip = m_systemSoundClips[(int)se];
				source.loop = true;
				source.clip = clip;
				source.Play();
			}
		}

		public void StopSystemLoop(AudioSource source = null)
		{
			if (source == null)
			{
				source = m_sourceSystemSe;
			}
			source.Stop();
			source.clip = null;
			source.loop = false;
		}

		public void PlayClip(AudioClip clip, float volume, AudioSource source = null, bool loop = false)
		{
			if (source == null)
			{
				source = SourceMain;
			}
			source.volume = volume;
			if (!loop)
			{
				source.PlayOneShot(clip);
				return;
			}
			source.loop = true;
			source.clip = clip;
			source.Play();
		}

		public void Play(int id, float volume, AudioSource source = null, bool loop = false)
		{
			AudioClip audioClip = m_loader.FindAudio(id);
			if (!(audioClip == null))
			{
				PlayClip(audioClip, volume, source, loop);
			}
		}

		public void Stop(AudioSource source = null)
		{
			if (source == null)
			{
				source = SourceMain;
			}
			source.Stop();
			source.clip = null;
			source.loop = false;
		}

		public void LoadAllSE(List<ISoundCommand> seList)
		{
			m_loader.Load(seList);
		}

		public void Play3D(int id, float volume, ref Vector3 position, bool isLoop = false)
		{
			AudioClip clip = null;
			if (m_loader.TryFindAudio(id, ref clip))
			{
				PlayClip3D(clip, id, volume, ref position, isLoop);
			}
		}

		public void PlayClip3D(AudioClip clip, int id, float volume, ref Vector3 position, bool isLoop = false)
		{
			DearVrPlayer dearVrPlayer = m_dearVrSourceSE[m_3dSEIndex.Index];
			if (m_hasValidSceneData)
			{
				dearVrPlayer.Setup(m_sceneSettings, ref position);
			}
			else
			{
				dearVrPlayer.SetupPosition(ref position);
			}
			dearVrPlayer.Play(clip, id, volume, isLoop);
			m_3dSEIndex.Next();
		}

		public void Stop3D(int id)
		{
			DearVrPlayer dearVrPlayer = Find3DPlayer(id);
			if (!(dearVrPlayer == null))
			{
				dearVrPlayer.Stop();
			}
		}

		private DearVrPlayer Find3DPlayer(int soundID)
		{
			int num = m_dearVrSourceSE.Length;
			for (int i = 0; i < num; i++)
			{
				if (m_dearVrSourceSE[i].CurrentID == soundID)
				{
					return m_dearVrSourceSE[i];
				}
			}
			return null;
		}

		public void StopAll3D()
		{
			int num = m_dearVrSourceSE.Length;
			for (int i = 0; i < num; i++)
			{
				m_dearVrSourceSE[i].Stop();
			}
		}
	}
	public class SimpleSoundLoader
	{
		public class SoundData
		{
			public int ID;

			public AudioClip Clip;

			public SoundData(int id, AudioClip clip)
			{
				ID = id;
				Clip = clip;
			}
		}

		private const int _DEFAULT_LIST_SIZE = 10;

		private List<SoundData> m_soundDataList;

		private List<AsyncOperation> m_requests;

		public bool IsLoading { get; private set; }

		public bool HasRequest => m_requests.Count > 0;

		public SimpleSoundLoader()
		{
			IsLoading = false;
			m_soundDataList = new List<SoundData>(10);
			m_requests = new List<AsyncOperation>(10);
		}

		public void Clear()
		{
			IsLoading = false;
			ClearSoundData(m_soundDataList);
			ClearRequestData(m_requests);
		}

		public AudioClip FindAudio(int id)
		{
			return FindAudio(m_soundDataList, id);
		}

		public AudioClip FindAudio(List<SoundData> list, int id)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				if (list[i].ID == id)
				{
					return list[i].Clip;
				}
			}
			return null;
		}

		public bool TryFindAudio(int id, ref AudioClip clip)
		{
			int count = m_soundDataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_soundDataList[i].ID == id)
				{
					clip = m_soundDataList[i].Clip;
					return true;
				}
			}
			return false;
		}

		public void ClearUnusedData(List<ISoundCommand> nextList, List<SoundData> dataList)
		{
			for (int i = 0; i < dataList.Count; i++)
			{
				bool flag = RemoveCommandWithID(nextList, dataList[i].ID);
				if (nextList.Count <= 0)
				{
					break;
				}
				if (!flag)
				{
					Resources.UnloadAsset(dataList[i].Clip);
					dataList[i].Clip = null;
					dataList.RemoveAt(i);
					i--;
				}
			}
			Resources.UnloadUnusedAssets();
		}

		private bool IsContainSound(List<ISoundCommand> list, int idToCheck)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				if (list[i].ID == idToCheck)
				{
					return true;
				}
			}
			return false;
		}

		private bool RemoveCommandWithID(List<ISoundCommand> list, int id)
		{
			bool result = false;
			for (int i = 0; i < list.Count; i++)
			{
				if (list[i].ID == id)
				{
					list.RemoveAt(i);
					i--;
					result = true;
				}
			}
			return result;
		}

		private void ClearSoundData(List<SoundData> list)
		{
			int count = list.Count;
			for (int i = 0; i < count; i++)
			{
				Resources.UnloadAsset(list[i].Clip);
				list[i].Clip = null;
			}
			list.Clear();
			Resources.UnloadUnusedAssets();
		}

		private void ClearRequestData(List<AsyncOperation> list)
		{
			list.Clear();
		}

		public void Load(List<ISoundCommand> soundList)
		{
			if (soundList != null)
			{
				LoadAll(soundList, m_soundDataList);
			}
		}

		private void LoadAll(List<ISoundCommand> soundCommands, List<SoundData> soundList)
		{
			ClearUnusedData(soundCommands, soundList);
			int count = soundCommands.Count;
			for (int i = 0; i < count; i++)
			{
				int id = soundCommands[i].ID;
				ResourceRequest resourceRequest = Resources.LoadAsync<AudioClip>(soundCommands[i].GetFilePath());
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadSoundDataComplete(obj, soundList, id);
				};
				m_requests.Add(resourceRequest);
			}
			IsLoading = HasRequest;
		}

		private void OnLoadSoundDataComplete(AsyncOperation obj, List<SoundData> soundList, int id)
		{
			m_requests.Remove(obj);
			IsLoading = HasRequest;
			AudioClip audioClip = (obj as ResourceRequest).asset as AudioClip;
			if (!(audioClip == null))
			{
				soundList.Add(new SoundData(id, audioClip));
			}
		}
	}
	public class SoundManager : SingletonMonoBehaviour<SoundManager>
	{
		[Header("Scriptable Data")]
		[SerializeField]
		private AdvCharaMorpthTargetData m_charaMorphData;

		[SerializeField]
		private BgmData m_bgmData;

		[Header("Components - Kaine")]
		[SerializeField]
		private KainePlayer m_kaine;

		[Header("Components - Sources")]
		[SerializeField]
		private AudioSource sourceSystemSe;

		[SerializeField]
		private CharaVoiceSource m_charaVoiceSource;

		[SerializeField]
		private DearVrPlayer[] m_dearVrSourceSE;

		[Header("Components - Sound Clips")]
		[SerializeField]
		[EnumLabel(typeof(SoundDefine.SystemSE))]
		private List<AudioClip> systemSoundClips;

		[Header("Parameters - Other")]
		[SerializeField]
		[Range(0f, 1f)]
		private float m_playerVolume = 1f;

		private List<AsyncOperation> m_requests;

		private SceneSoundData m_sceneSettings;

		private BgmPlayer m_bgmPlayer;

		private VoicePlayer m_voicePlayer;

		private SePlayer m_sePlayer;

		private AudioSource sourceMain => MainPosition.AudioSourceEffect;

		private float volumeBgm => SingletonMonoBehaviour<GameData>.Instance.ConfigData.BgmVolume.Value;

		private float volumeSe => SingletonMonoBehaviour<GameData>.Instance.ConfigData.SeVolume.Value;

		private float volumeVoice => SingletonMonoBehaviour<GameData>.Instance.ConfigData.VoiceVolume.Value;

		public static SePlayer SE => SingletonMonoBehaviour<SoundManager>.Instance.m_sePlayer;

		public static BgmPlayer Bgm => SingletonMonoBehaviour<SoundManager>.Instance.m_bgmPlayer;

		public static VoicePlayer Voice => SingletonMonoBehaviour<SoundManager>.Instance.m_voicePlayer;

		public bool IsLoading
		{
			get
			{
				if (!m_bgmPlayer.IsLoading && !m_voicePlayer.IsLoading && !m_sePlayer.IsLoading)
				{
					return m_requests.Count > 0;
				}
				return true;
			}
		}

		protected override void InitializeOnAwake()
		{
			m_requests = new List<AsyncOperation>();
			m_bgmPlayer = new BgmPlayer(m_kaine, m_bgmData);
			m_voicePlayer = new VoicePlayer(m_charaVoiceSource, m_charaMorphData, m_playerVolume);
			m_sePlayer = new SePlayer(sourceSystemSe, systemSoundClips, m_dearVrSourceSE);
			base.InitializeOnAwake();
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.OnCompleteTransition.Subscribe(delegate(Scene scene)
			{
				LoadSceneSetting(scene.name);
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeStartInGame.Subscribe(delegate
			{
				StopAll();
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MasterManager>.Instance.OnBeforeEndInGame.Subscribe(delegate
			{
				StopAll();
			}).AddTo(base.gameObject);
		}

		public void StopAll(BgmPlayer.StopMode stopMode = BgmPlayer.StopMode.Immidiate, float simpleBgmFadeDuration = 0f, AudioSource seSource = null)
		{
			StopBgm(stopMode);
			StopSimpleBgm(simpleBgmFadeDuration);
			if (SingletonMonoBehaviour<MainPosition>.HasInstance)
			{
				m_sePlayer.Stop(seSource);
			}
		}

		public void ClearAll()
		{
			m_requests.Clear();
			m_voicePlayer.Clear();
			ClearBgm();
			m_sePlayer.Clear();
			ClearSceneSetting();
		}

		public void ClearAllExceptBgm()
		{
			m_requests.Clear();
			m_voicePlayer.Clear();
			m_sePlayer.Clear();
			ClearSceneSetting();
		}

		public void PlayBgm(int id, KainePlayer.Layers layer)
		{
			m_bgmPlayer.Play(id, layer);
		}

		public void StopBgm(BgmPlayer.StopMode mode)
		{
			m_bgmPlayer.Stop(mode);
		}

		public void StopSimpleBgm(float fadeDuration = -1f)
		{
			m_bgmPlayer.StopSimple(fadeDuration);
		}

		public void SetBgmLayer(KainePlayer.Layers layer)
		{
			m_bgmPlayer.SetLayer(layer);
		}

		public void ClearBgm()
		{
			m_bgmPlayer.Clear();
		}

		public float GetBgmBarDuration(int numBars, bool isCountCurrentBar)
		{
			return m_bgmPlayer.GetSecondsFromBars(numBars, isCountCurrentBar);
		}

		public bool IsPlayingBgm()
		{
			return m_bgmPlayer.IsPlaying;
		}

		public void PrepareFirstBgm()
		{
			m_bgmPlayer.PrepareFirstTrack();
		}

		public void LoadSceneSetting(string name)
		{
			ClearSceneSetting();
			ResourceRequest resourceRequest = Resources.LoadAsync<SceneSoundData>(string.Format("{0}{1}", "Settings/Sound/", name));
			resourceRequest.completed += delegate(AsyncOperation obj)
			{
				m_requests.Remove(obj);
				m_sceneSettings = (obj as ResourceRequest).asset as SceneSoundData;
				m_voicePlayer.SetSceneSettings(m_sceneSettings);
				m_sePlayer.SetSceneSettings(m_sceneSettings);
				_ = m_sceneSettings == null;
			};
			m_requests.Add(resourceRequest);
		}

		public void ClearSceneSetting()
		{
			if (m_sceneSettings != null)
			{
				Resources.UnloadAsset(m_sceneSettings);
				m_sceneSettings = null;
			}
		}
	}
	public class VoiceLoader
	{
		public class Data
		{
			public AudioClip Clip;

			public OVRLipSyncSequence LipSyncData;

			public Data(int id, AudioClip clip, OVRLipSyncSequence lipSyncData = null)
			{
				Clip = clip;
				LipSyncData = lipSyncData;
			}
		}

		private class PlayData
		{
			private List<Data> m_data;

			public GameDefine.CharaID Chara { get; private set; }

			public int Index { get; private set; }

			public AudioClip CurrentVoice => m_data[Index].Clip;

			public PlayData(GameDefine.CharaID chara)
			{
				Chara = chara;
				m_data = new List<Data>(30);
				Reset();
			}

			public void Reset()
			{
				Index = 0;
				int count = m_data.Count;
				for (int i = 0; i < count; i++)
				{
					Resources.UnloadAsset(m_data[i].Clip);
					Resources.UnloadAsset(m_data[i].LipSyncData);
					m_data[i].Clip = null;
					m_data[i].LipSyncData = null;
				}
				m_data.Clear();
			}

			public void Next()
			{
				Index++;
			}

			public Data NextData()
			{
				if (Index >= m_data.Count)
				{
					return null;
				}
				return m_data[Index++];
			}

			public void AddData(int id, AudioClip clip, OVRLipSyncSequence lipSyncData)
			{
				m_data.Add(new Data(id, clip, lipSyncData));
			}

			public void AddData(Data data)
			{
				m_data.Add(data);
			}
		}

		private const string _UNKNOWN_VOICE_PATH = "{0}";

		private const string _CHARA_VOICE_PATH = "{0}/{1}";

		private const string _VOICE_PATH = "{0}{1}/{2}";

		private const string _LIPSYNC_FILENAME = "{0}_lipSync";

		private const GameDefine.CharaIndex _MOD_INDEX = GameDefine.CharaIndex.HITOKAGE;

		private const GameDefine.CharaID _MOB_ID = GameDefine.CharaID.HITOKAGE;

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private List<PlayData> m_playData;

		public bool IsLoading => m_requests.Count > 0;

		public VoiceLoader()
		{
			m_playData = new List<PlayData>();
			for (int i = 2; i <= 12; i++)
			{
				m_playData.Add(new PlayData(GameDefine.CharaIndexToID((GameDefine.CharaIndex)i)));
			}
			m_playData.Add(new PlayData(GameDefine.CharaID.MOMONO_RIN));
		}

		public void Clear()
		{
			int count = m_playData.Count;
			for (int i = 0; i < count; i++)
			{
				m_playData[i].Reset();
			}
			Resources.UnloadUnusedAssets();
		}

		private GameDefine.CharaID ConvertCharaID(GameDefine.CharaID chara)
		{
			if (GameDefine.IsModChara(chara))
			{
				return GameDefine.CharaID.HITOKAGE;
			}
			if (GameDefine.IsUnknownChara(chara))
			{
				chara = GameDefine.UnknownToCharaID(chara);
			}
			return GameDefine.GetOriginalCharaID(chara);
		}

		private PlayData FindPlayData(GameDefine.CharaID chara)
		{
			chara = ConvertCharaID(chara);
			int count = m_playData.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_playData[i].Chara == chara)
				{
					return m_playData[i];
				}
			}
			return null;
		}

		public Data GetData(GameDefine.CharaID chara)
		{
			return FindPlayData(chara)?.NextData();
		}

		private void AddData(GameDefine.CharaID chara, Data data)
		{
			PlayData playData = FindPlayData(chara);
			if (data != null)
			{
				playData.AddData(data);
			}
		}

		private string GetVoicePath(CommandText data, int index)
		{
			return string.Format("{0}{1}/{2}", "Audio/Voice/", SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID, index);
		}

		public void Load(int scenarioID, List<CommandText> commandList, GameDefine.CharaID charaID, bool isMemoryMode)
		{
			Clear();
			int count = commandList.Count;
			for (int i = 0; i < count; i++)
			{
				CommandText command = commandList[i];
				if (command.Chara == GameDefine.CharaID.BASE || command.Chara == GameDefine.CharaID.NONE)
				{
					continue;
				}
				int index = i;
				Data data = new Data(index, null);
				string path = CreateFilePath(command);
				ResourceRequest resourceRequest = Resources.LoadAsync<AudioClip>(path);
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadClipComplete(obj, data, command.Chara, path, command, scenarioID, index);
				};
				m_requests.Add(resourceRequest);
				if (!isMemoryMode && command.Chara != charaID)
				{
					ResourceRequest resourceRequest2 = Resources.LoadAsync<OVRLipSyncSequence>($"{path}_lipSync");
					resourceRequest2.completed += delegate(AsyncOperation obj)
					{
						OnLoadSyncDataComplete(obj, data, command, scenarioID, index);
					};
					m_requests.Add(resourceRequest2);
				}
				AddData(command.Chara, data);
			}
			Resources.UnloadUnusedAssets();
		}

		private string CreateFilePath(CommandText command)
		{
			GameDefine.CharaID charaID = command.Chara;
			if (GameDefine.IsModChara(charaID))
			{
				return string.Format("{0}{1}", "Audio/Voice/Mob/", command.VoiceFile);
			}
			if (GameDefine.IsSpecialChara(charaID))
			{
				return string.Format("{0}{1}/{2}", "Audio/Voice/", (int)GameDefine.ConvertSpecialToNormal(charaID), command.VoiceFile);
			}
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.UnknownToCharaID(charaID);
			}
			int num = (int)charaID % 10;
			int num2 = (int)(charaID - num);
			return string.Format("{0}{1}/{2}", "Audio/Voice/", num2, command.VoiceFile);
		}

		private Dictionary<GameDefine.CharaID, int> CreateIndexDictionary()
		{
			Dictionary<GameDefine.CharaID, int> dictionary = new Dictionary<GameDefine.CharaID, int>();
			for (int i = 2; i < 11; i++)
			{
				dictionary.Add(GameDefine.CharaIndexToID((GameDefine.CharaIndex)i), 0);
			}
			return dictionary;
		}

		private void OnLoadClipComplete(AsyncOperation obj, Data data, GameDefine.CharaID chara, string path, CommandText command, int scenarioID, int commandIndex)
		{
			m_requests.Remove(obj);
			AudioClip audioClip = (obj as ResourceRequest).asset as AudioClip;
			if (!(audioClip == null))
			{
				data.Clip = audioClip;
			}
		}

		private void OnLoadSyncDataComplete(AsyncOperation obj, Data data, CommandText command, int scenarioID, int commandIndex)
		{
			m_requests.Remove(obj);
			OVRLipSyncSequence oVRLipSyncSequence = (obj as ResourceRequest).asset as OVRLipSyncSequence;
			if (!(oVRLipSyncSequence == null))
			{
				data.LipSyncData = oVRLipSyncSequence;
			}
		}
	}
	public class VoicePlayer
	{
		private VoiceLoader m_loader;

		private CharaVoiceSource m_charaVoiceSource;

		private AdvCharaMorpthTargetData m_charaMorphData;

		private SceneSoundData m_sceneSettings;

		private float m_playerVolume;

		private AudioSource m_currentVoice;

		private AudioSource SourceMainVoice => MainPosition.AudioSourceVoice;

		public float Volume => SingletonMonoBehaviour<GameData>.Instance.ConfigData.VoiceVolume.Value;

		public bool IsLoading => m_loader.IsLoading;

		public bool IsForce2DMode { get; set; }

		public VoicePlayer(CharaVoiceSource charaVoiceSource, AdvCharaMorpthTargetData charaMorphData, float playerVolume)
		{
			IsForce2DMode = false;
			m_charaVoiceSource = charaVoiceSource;
			m_charaMorphData = charaMorphData;
			m_sceneSettings = null;
			m_playerVolume = playerVolume;
			m_loader = new VoiceLoader();
			m_currentVoice = null;
		}

		public void SetSceneSettings(SceneSoundData data)
		{
			m_sceneSettings = data;
		}

		public void Clear()
		{
			IsForce2DMode = false;
			m_loader.Clear();
		}

		public void LoadAllVoices(int scenarioID, List<CommandText> commandList, GameDefine.CharaID charaID, bool isMemoryMode)
		{
			m_loader.Load(scenarioID, commandList, charaID, isMemoryMode);
		}

		public bool IsPlayingVoice()
		{
			if (m_currentVoice == null)
			{
				return false;
			}
			return m_currentVoice.isPlaying;
		}

		public void PlayVoice(AudioClip clip, AudioSource source = null, bool loop = false)
		{
			float volume = Volume;
			if (source == null)
			{
				source = SourceMainVoice;
				volume = m_playerVolume;
			}
			source.volume = volume;
			source.loop = loop;
			m_currentVoice = source;
			source.clip = clip;
			source.Play();
		}

		public void PlayVoice(GameDefine.CharaID chara, AudioSource source = null, bool loop = false)
		{
			VoiceLoader.Data data = m_loader.GetData(chara);
			if (data != null)
			{
				PlayVoice(data.Clip, source, loop);
			}
		}

		public void PlayVoiceDearVr(GameDefine.CharaID charaID, CharaVoiceSource source, bool loop = false)
		{
			VoiceLoader.Data data = m_loader.GetData(charaID);
			if (data != null && !(data.Clip == null))
			{
				source.AudioSource.volume = Volume;
				source.AudioSource.loop = loop;
				m_currentVoice = source.AudioSource;
				source.AudioSource.clip = data.Clip;
				if (GameDefine.IsSpecialChara(charaID))
				{
					charaID = GameDefine.ConvertSpecialToNormal(charaID);
				}
				source.SetupChara(charaID);
				source.SetupDearVR(ref m_sceneSettings);
				source.SetupMorphTarget(m_charaMorphData, data);
				source.Play(isLipsync: true);
			}
		}

		public void PlayVoiceDearVrInMemoryMode(GameDefine.CharaID charaID, CharaVoiceSource source, Transform locator, VoiceLoader.Data data, bool loop = false)
		{
			if (data != null)
			{
				source.AudioSource.volume = Volume;
				source.AudioSource.loop = loop;
				m_currentVoice = source.AudioSource;
				source.AudioSource.clip = data.Clip;
				source.SetupToLocator(charaID, locator);
				source.SetupDearVR(ref m_sceneSettings);
				source.Play(isLipsync: false);
			}
		}

		public void PlayVoiceByData(CommandText data, bool loop = false)
		{
			GameDefine.CharaID charaID = data.Chara;
			if (GameDefine.IsUnknownChara(charaID))
			{
				charaID = GameDefine.UnknownToCharaID(charaID);
			}
			if (data.IsMemoryMode)
			{
				PlayMemoryModeVoice(data, loop);
				return;
			}
			if (charaID == GameDefine.CharaID.BASE || data.Is2DVoice || charaID == SingletonMonoBehaviour<LocalData>.Instance.CurrentCharaID)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			GameDefine.CharaID id = charaID;
			if (GameDefine.IsSpecialChara(id))
			{
				id = GameDefine.ConvertSpecialToNormal(id);
			}
			if (SingletonMonoBehaviour<CharactersManager>.Instance.GetChara(id) == null)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			if (IsForce2DMode)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			PlayVoiceDearVr(charaID, m_charaVoiceSource, loop);
			SingletonMonoBehaviour<CharactersManager>.Instance.OnPlayVoice(charaID);
		}

		private void PlayMemoryModeVoice(CommandText data, bool loop)
		{
			IChara chara = data.FindCharacter();
			if (chara == null)
			{
				PlayVoice(data.Chara, null, loop);
				return;
			}
			AdvMemoryChara advMemoryChara = chara as AdvMemoryChara;
			PlayVoiceDearVrInMemoryMode((GameDefine.CharaID)advMemoryChara.CharaID, m_charaVoiceSource, MainPosition.FrontVoiceLocator, m_loader.GetData(data.Chara));
		}

		public void StopCurrentVoice()
		{
			if (SourceMainVoice.isPlaying)
			{
				SourceMainVoice.Stop();
			}
			SourceMainVoice.clip = null;
			if (IsPlayingVoice())
			{
				m_charaVoiceSource.StopVoice();
				m_currentVoice.Stop();
			}
		}
	}
	public class DitherFade
	{
		public const float _DEFAULT_FADE_DURATION = 0.3f;

		private const string _PARAM_ALPHA = "_Alpha";

		private const string _PARAM_OUTLINE_SIZE = "_Outline";

		private const string _PARAM_OUTLINE_COLOR = "_OutlineColor";

		private List<Material> m_materials;

		private Tweener<float> m_alphaTweener;

		private GameObject m_owner;

		private Func<IEnumerator> m_fadeCoroutineFunc;

		private float m_fromAlpha;

		private float m_targetAlpha;

		private float m_duration;

		public bool IsFading => m_alphaTweener.IsActive;

		public DitherFade(GameObject owner)
		{
			m_owner = owner;
			Renderer[] componentsInChildren = m_owner.GetComponentsInChildren<Renderer>();
			FindRendererMaterials(componentsInChildren);
			MakeTweener();
			CreateActions();
		}

		public DitherFade(GameObject owner, Material mat)
		{
			m_owner = owner;
			m_materials = new List<Material>(1);
			m_materials.Add(mat);
			MakeTweener();
			CreateActions();
		}

		public DitherFade(GameObject owner, Material[] mats)
		{
			m_owner = owner;
			m_materials = new List<Material>(mats);
			MakeTweener();
			CreateActions();
		}

		public DitherFade(GameObject owner, List<Material> mats)
		{
			m_owner = owner;
			m_materials = mats;
			MakeTweener();
			CreateActions();
		}

		private void CreateActions()
		{
			m_fadeCoroutineFunc = () => CoroutineFade();
		}

		private void FindRendererMaterials(Renderer[] renderers)
		{
			m_materials = new List<Material>();
			int num = renderers.Length;
			for (int i = 0; i < num; i++)
			{
				Material[] materials = renderers[i].materials;
				int num2 = materials.Length;
				for (int j = 0; j < num2; j++)
				{
					m_materials.Add(materials[j]);
				}
			}
		}

		private void MakeTweener()
		{
			m_alphaTweener = new Tweener<float>(Mathf.Lerp);
		}

		public void Update(float delta)
		{
			if (m_alphaTweener.IsActive)
			{
				m_alphaTweener.Update(delta);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
		}

		public void SetModelAlpha(float alpha)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Alpha", alpha);
			}
		}

		public void SetModelOutlineSize(float size)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetFloat("_Outline", size);
			}
		}

		public void SetModelOutlineColor(Color color)
		{
			int count = m_materials.Count;
			for (int i = 0; i < count; i++)
			{
				m_materials[i].SetColor("_OutlineColor", color);
			}
		}

		public float GetModelOutlineSize()
		{
			return m_materials[0].GetFloat("_Outline");
		}

		public Color GetModelOutlineColor()
		{
			return m_materials[0].GetColor("_OutlineColor");
		}

		public void StartFade(float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			m_alphaTweener.Start(m_materials[0].GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
		}

		public IDisposable StartFadeCoroutine(float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			return StartFadeCoroutine(m_materials[0].GetFloat("_Alpha"), targetAlpha, duration, onTweenEnd);
		}

		public IDisposable StartFadeCoroutine(float fromAlpha, float targetAlpha, float duration = 0.3f, Action onTweenEnd = null)
		{
			m_fromAlpha = fromAlpha;
			m_targetAlpha = targetAlpha;
			m_duration = duration;
			return Observable.FromMicroCoroutine(m_fadeCoroutineFunc).Subscribe(delegate
			{
				if (onTweenEnd != null)
				{
					onTweenEnd();
				}
			}).AddTo(m_owner);
		}

		private IEnumerator CoroutineFade()
		{
			while (m_alphaTweener.IsActive)
			{
				yield return null;
			}
			m_alphaTweener.Start(m_fromAlpha, m_targetAlpha, m_duration);
			SetModelAlpha(m_alphaTweener.CurrentValue);
			while (m_alphaTweener.IsActive)
			{
				yield return null;
				m_alphaTweener.Update(Time.deltaTime);
				SetModelAlpha(m_alphaTweener.CurrentValue);
			}
			yield return null;
		}

		public void AddOnFadeEndAction(Action action)
		{
			m_alphaTweener.AddAction(action);
		}
	}
	public class FadeManager : SingletonMonoBehaviour<FadeManager>
	{
		public UIFader sceneFader;

		public UIFader menuFader;

		public UIFader importantFader;

		public void FlashFade()
		{
			bool isDeactivateOnEnd = menuFader.EndColour.a <= 0.1f;
			menuFader.StartFade(ColorDefine.Black, menuFader.EndColour, 0.2f, isDeactivateOnEnd);
		}
	}
	public class GameInputHelper
	{
		public static void VibrateLaser(LaserController laser, float length, float power)
		{
			laser.Vibrate(length, power);
		}

		public static void VibrateLaserForFocus(LaserController laser)
		{
			VibrateLaser(laser, 0.05f, 0.2f);
		}

		public static void VibrateLaserForPress(LaserController laser)
		{
			VibrateLaser(laser, 0.1f, 0.6f);
		}
	}
	public class GameInputManager : SingletonMonoBehaviour<GameInputManager>
	{
		[Header("Parameters")]
		[SerializeField]
		private float _touchScrollSensivility = 4f;

		private TouchpadScroller[] _scrollers = new TouchpadScroller[3];

		private VRDeviceDefine.HandType _currentMainHand = VRDeviceDefine.HandType.None;

		private Subject<Unit> _subjectPositionReset = new Subject<Unit>();

		private BehaviorSubject<VRDeviceDefine.HandType> _subjectChangeMainHand = new BehaviorSubject<VRDeviceDefine.HandType>(VRDeviceDefine.HandType.None);

		private IObservable<Unit> _update;

		private IObservable<bool> _onToggleTrackedLeft;

		private IObservable<bool> _onToggleTrackedRight;

		public bool IsMenuOpened
		{
			get
			{
				if (!SingletonMonoBehaviour<MainMenuManager>.HasInstance)
				{
					return false;
				}
				return SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened;
			}
		}

		public bool IsMovileDevice => inputVR.IsMovileDevice;

		public bool IsRecenteredController => inputVR.IsRecenteredController;

		public VRDeviceDefine.HandType CurrentMainHand => _currentMainHand;

		public VRDeviceDefine.HandType PrefferdHand => SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand.Value;

		public IObservable<VRDeviceDefine.HandType> PrefferdHandObservable => SingletonMonoBehaviour<GameData>.Instance.ConfigData.PrefferedHand;

		public bool IsMainHandAvailable => _currentMainHand != VRDeviceDefine.HandType.None;

		public VRDeviceDefine.HandType AvailableHand => inputVR.AvailableHand;

		public bool IsTwoSideController => AvailableHand == VRDeviceDefine.HandType.Both;

		public bool IsOneSideController
		{
			get
			{
				if (AvailableHand != 0)
				{
					return AvailableHand == VRDeviceDefine.HandType.Right;
				}
				return true;
			}
		}

		public IObservable<Unit> OnPositionReset => _subjectPositionReset;

		public IObservable<bool> OnToggleTrackedLeft => _onToggleTrackedLeft;

		public IObservable<bool> OnToggleTrackedRight => _onToggleTrackedRight;

		public IObservable<VRDeviceDefine.HandType> OnChangeMainHand => _subjectChangeMainHand;

		private BaseVRPlatform inputVR => SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR;

		protected override void InitializeOnAwake()
		{
			for (int i = 0; i < _scrollers.Length; i++)
			{
				TouchpadScroller touchpadScroller = new TouchpadScroller();
				touchpadScroller.Manager = this;
				touchpadScroller.TargetHand = (VRDeviceDefine.HandType)i;
				touchpadScroller.Sensivility = _touchScrollSensivility;
				touchpadScroller.StartOffset = 0.1f;
				_scrollers[i] = touchpadScroller;
			}
			_update = this.UpdateAsObservable();
			_update.Where((Unit _) => inputVR.IsTouchpadAvailable).Subscribe(delegate
			{
				UpdateAxisDelta();
			}).AddTo(base.gameObject);
			_update.Where((Unit _) => IsRecenteredController).ThrottleFirstFrame(30).Subscribe(delegate
			{
				RecenterPosition();
			})
				.AddTo(base.gameObject);
			_onToggleTrackedLeft = this.ObserveEveryValueChanged((GameInputManager x) => x.IsHandTracked(VRDeviceDefine.HandType.Left));
			_onToggleTrackedRight = this.ObserveEveryValueChanged((GameInputManager x) => x.IsHandTracked(VRDeviceDefine.HandType.Right));
		}

		private void Start()
		{
			SetUIMask();
			InitMainHandProcess();
			RecenterPositionWithoutFade();
		}

		private void SetUIMask()
		{
			LaserInputModule.module.SetUICameraMask((1 << LayerMask.NameToLayer("UI")) | (1 << LayerMask.NameToLayer("SelectionTarget")));
		}

		private void InitMainHandProcess()
		{
			PrefferdHandObservable.Where((VRDeviceDefine.HandType type) => IsTwoSideController && !IsMainHand(type)).Subscribe(delegate(VRDeviceDefine.HandType type)
			{
				SetMainHand(type);
			});
			_update.Where((Unit _) => IsOneSideController && !IsMainHand(inputVR.AvailableHand)).Subscribe(delegate
			{
				SetMainHand(inputVR.AvailableHand);
			});
		}

		private void SetMainHand(VRDeviceDefine.HandType type)
		{
			if (_currentMainHand != type)
			{
				_currentMainHand = type;
				_subjectChangeMainHand.OnNext(_currentMainHand);
			}
		}

		private void CheckMainHand()
		{
			if (!IsTwoSideController)
			{
				if (IsHandTracked(VRDeviceDefine.HandType.Right))
				{
					SetMainHand(VRDeviceDefine.HandType.Right);
				}
				else if (IsHandTracked(VRDeviceDefine.HandType.Left))
				{
					SetMainHand(VRDeviceDefine.HandType.Left);
				}
				else
				{
					SetMainHand(VRDeviceDefine.HandType.None);
				}
			}
		}

		public bool IsMainHand(VRDeviceDefine.HandType checkType)
		{
			if (!IsMainHandAvailable)
			{
				return false;
			}
			if (_currentMainHand == VRDeviceDefine.HandType.Both)
			{
				return true;
			}
			return checkType == _currentMainHand;
		}

		private void UpdateAxisDelta()
		{
			for (int i = 0; i < _scrollers.Length; i++)
			{
				_scrollers[i].UpdateAxisDelta(Time.deltaTime);
			}
		}

		public void RecenterPositionWithoutFade()
		{
			SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.Recenter();
			_subjectPositionReset.OnNext(Unit.Default);
		}

		public void RecenterPosition()
		{
			SingletonMonoBehaviour<FadeManager>.Instance.FlashFade();
			SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.Recenter();
			_subjectPositionReset.OnNext(Unit.Default);
		}

		public void MoveToController(Transform tf, VRDeviceDefine.HandType hand)
		{
			tf.localPosition = GetHandPosition(hand);
			tf.localRotation = GetHandRotation(hand);
		}

		public bool IsHandTracked(VRDeviceDefine.HandType hand)
		{
			return inputVR.IsHandTracked(hand);
		}

		public Vector3 GetHandPosition(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetHandPosition(hand);
		}

		public Quaternion GetHandRotation(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetHandRotation(hand);
		}

		public bool GetVRButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return inputVR.GetVRButton(hand, button);
		}

		public bool GetVRButtonDown(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return inputVR.GetVRButtonDown(hand, button);
		}

		public bool GetVRButtonUp(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return inputVR.GetVRButtonUp(hand, button);
		}

		public bool GetAxisPadStartTouch(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisPadStartTouch(hand);
		}

		public bool GetAxisPadTouching(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisPadTouching(hand);
		}

		public Vector2 GetAxisPad2D(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisPad2D(hand);
		}

		public Vector2 GetAxisStick2D(VRDeviceDefine.HandType hand)
		{
			return inputVR.GetAxisStick2D(hand);
		}

		public Vector2 GetVRScrollDelta(VRDeviceDefine.HandType hand)
		{
			Vector2 axisStick2D = GetAxisStick2D(hand);
			if (inputVR.IsTouchpadAvailable)
			{
				axisStick2D += _scrollers[(int)hand].AxisDelta;
			}
			return axisStick2D;
		}

		public void Vibrate(VRDeviceDefine.HandType hand, float length, float power)
		{
			inputVR.Vibrate(hand, length, power);
		}

		public void OnBackFromRoot()
		{
			inputVR.OnBackFromRoot();
		}
	}
	public class TouchpadScroller
	{
		public GameInputManager Manager;

		public VRDeviceDefine.HandType TargetHand;

		public float Sensivility;

		public float StartOffset;

		private Vector2 _axisDelta;

		private Vector2 _oldAxis;

		private Vector2 _lastSpeed;

		private Common.Timer _timerSmooth = new Common.Timer(0f);

		public bool IsTouching { get; private set; }

		public bool IsScrolling { get; private set; }

		public Vector2 AxisDelta => _axisDelta;

		public void UpdateAxisDelta(float deltaTime)
		{
			if (Manager.GetAxisPadTouching(TargetHand))
			{
				Vector2 axisPad2D = Manager.GetAxisPad2D(TargetHand);
				if (IsTouching)
				{
					Vector2 vector = axisPad2D - _oldAxis;
					if (IsScrolling)
					{
						if (!Manager.GetAxisPadStartTouch(TargetHand))
						{
							_axisDelta = (axisPad2D - _oldAxis) * (0f - Sensivility);
							_lastSpeed = _axisDelta;
						}
						_oldAxis = axisPad2D;
					}
					else
					{
						_lastSpeed = Vector2.zero;
						if (vector.sqrMagnitude >= StartOffset * StartOffset)
						{
							IsScrolling = true;
						}
					}
				}
				else
				{
					IsTouching = true;
					_oldAxis = axisPad2D;
				}
			}
			else
			{
				_ = IsScrolling;
				IsTouching = false;
				IsScrolling = false;
				if (_timerSmooth.IsTimeUp)
				{
					_axisDelta = (_oldAxis = Vector2.zero);
					return;
				}
				_oldAxis = Vector2.zero;
				_timerSmooth.Update(deltaTime);
				_axisDelta = Vector2.Lerp(_lastSpeed, Vector2.zero, _timerSmooth.Rate);
			}
		}
	}
	public class TriggerValueWatcher
	{
		private Func<float> _triggerValueCallback;

		private float _threshould;

		public bool IsDown { get; private set; }

		public bool IsPressing { get; private set; }

		public bool IsUp { get; private set; }

		public float Value { get; private set; }

		public TriggerValueWatcher(Func<float> triggerValue, float threshould)
		{
			_triggerValueCallback = triggerValue;
			_threshould = threshould;
		}

		public void StartWatch(GameObject updateObject)
		{
			updateObject.UpdateAsObservable().Subscribe(delegate
			{
				UpdateTrigger();
			}).AddTo(updateObject);
		}

		public void UpdateTrigger()
		{
			IsDown = false;
			IsUp = false;
			Value = _triggerValueCallback();
			bool flag = Value >= _threshould;
			if (flag != IsPressing)
			{
				IsPressing = flag;
				if (IsPressing)
				{
					IsDown = true;
				}
				else
				{
					IsUp = true;
				}
			}
		}
	}
	public class MainMenuCaller : UpdateableComponent
	{
		[Header("Parameters")]
		[Tooltip("メニュー機能を無効にするにはチェックを外してください")]
		[SerializeField]
		private bool canOpenManually = true;

		[Tooltip("ルートUI時に戻るを押したときにデバイスメニューを表示するか設定します。公開時はTrueに設定してください (デバイスメニューに戻れないと審査に引っかかります)")]
		[SerializeField]
		private bool useDeviceMenu = true;

		public bool IsMenuOpened
		{
			get
			{
				if (!SingletonMonoBehaviour<MainMenuManager>.HasInstance)
				{
					return false;
				}
				return SingletonMonoBehaviour<MainMenuManager>.Instance.IsOpened;
			}
		}

		private GameInputManager input => SingletonMonoBehaviour<GameInputManager>.Instance;

		public override void OnUpdate(float delta)
		{
			if (SingletonMonoBehaviour<MasterManager>.Instance.IsTitleScene || SingletonMonoBehaviour<MasterManager>.Instance.IsBusy)
			{
				return;
			}
			if (input.IsMovileDevice)
			{
				if (canOpenManually)
				{
					if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.DeviceBack))
					{
						if (!useDeviceMenu || !IsMenuOpened)
						{
							input.OnBackFromRoot();
						}
						else
						{
							OnCancelButtonPressed();
						}
					}
					else if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
					{
						OnCancelButtonPressed();
					}
				}
				else if (useDeviceMenu && input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.DeviceBack))
				{
					input.OnBackFromRoot();
				}
			}
			else if (canOpenManually && input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.Cancel))
			{
				OnCancelButtonPressed();
			}
		}

		public void OnCancelButtonPressed()
		{
			if (SingletonMonoBehaviour<MainMenuManager>.HasInstance)
			{
				if (IsMenuOpened)
				{
					SingletonMonoBehaviour<MainMenuManager>.Instance.OnPressHardwareBackButton();
				}
				else
				{
					SingletonMonoBehaviour<MainMenuManager>.Instance.OpenMenu();
				}
			}
		}
	}
	public class TimelineInput : MonoBehaviour
	{
		private Common.Timer m_autoTimer;

		private Common.Timer m_autoStartTimer;

		private bool m_horzToggle;

		private bool _isPageOk;

		private bool _isPageReadyOk;

		private bool _preventedByMenu;

		[Header("Parameters - Auto Mode")]
		[SerializeField]
		private float m_autoWaitMonologue = 1f;

		[SerializeField]
		private float m_autoWaitSelif = 0.2f;

		[SerializeField]
		private float m_autoWaitStartPress = 1f;

		private TimelinePlayer m_player;

		private bool IsAutoWaitNeedOverride => m_messagePlayer.IsAutoWaitNeedOverride;

		private float AutoWaitOverride => m_messagePlayer.AutoWaitOverride;

		private MessagePlayer m_messagePlayer => m_player.MessageProcessor;

		private GameInputManager input => SingletonMonoBehaviour<GameInputManager>.Instance;

		private bool IsAutoMode => m_messagePlayer.IsAutoMode;

		private bool IsSkipMode => m_messagePlayer.IsSkipMode;

		private bool IsChangingAuto => m_autoStartTimer.CurrentTime > 0f;

		private bool IsPlayable
		{
			get
			{
				if (SingletonMonoBehaviour<InGameManager>.HasInstance && SingletonMonoBehaviour<InGameManager>.Instance.IsReady)
				{
					return !_preventedByMenu;
				}
				return false;
			}
		}

		private bool CanInterract => m_messagePlayer.CanInterract;

		private bool IsOpenedDebugConsole => false;

		private void Start()
		{
			m_player = GetComponent<TimelinePlayer>();
			m_autoTimer = new Common.Timer(m_autoWaitMonologue);
			m_autoStartTimer = new Common.Timer(m_autoWaitStartPress);
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			m_messagePlayer.OnAddMessageLog.Subscribe(delegate(CommandText message)
			{
				if (IsAutoWaitNeedOverride)
				{
					m_autoTimer.SetDuration(AutoWaitOverride);
				}
				else
				{
					m_autoTimer.SetDuration(message.IsMonologue ? m_autoWaitMonologue : m_autoWaitSelif);
				}
			});
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => flag).Subscribe(delegate
			{
				_preventedByMenu = true;
			}).AddTo(base.gameObject);
			SingletonMonoBehaviour<MainMenuManager>.Instance.OnToggleMenu.Where((bool flag) => !flag).DelayFrame(1).Subscribe(delegate
			{
				_preventedByMenu = false;
			})
				.AddTo(base.gameObject);
		}

		public void UpdateInputModeChange()
		{
			if (!IsAutoMode && IsPlayable && input.GetVRButton(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				UpdateAutoModeStartInput();
			}
			else if (IsChangingAuto)
			{
				m_autoStartTimer.Reset();
			}
			if (IsPlayable)
			{
				if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
				{
					if (IsOpenedDebugConsole)
					{
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else if (m_messagePlayer.IsRemoveInterface)
					{
						m_messagePlayer.IsRemoveInterface = false;
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else if (!CanInterract)
					{
						if (m_messagePlayer.IsPlayPageSound)
						{
							SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error);
						}
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else if (IsAutoMode || IsSkipMode)
					{
						m_messagePlayer.SetPlayMode(MessagePlayer.PlayModes.Normal);
						_isPageOk = false;
						_isPageReadyOk = false;
					}
					else
					{
						_isPageReadyOk = true;
					}
				}
			}
			else if (IsSkipMode)
			{
				m_messagePlayer.SetPlayMode(MessagePlayer.PlayModes.Normal);
			}
			if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.RemoveInterface))
			{
				m_messagePlayer.IsRemoveInterface = !m_messagePlayer.IsRemoveInterface;
			}
		}

		public void UpdateMessageInput()
		{
			if (!IsPlayable)
			{
				if (IsAutoWaitNeedOverride)
				{
					m_autoTimer.Update(Time.deltaTime);
				}
				else if (IsAutoMode && m_autoTimer.CurrentTime > 0f)
				{
					m_autoTimer.Reset();
				}
				return;
			}
			if (IsSkipMode)
			{
				m_messagePlayer.OnProcessAuto();
				return;
			}
			if (input.GetVRButtonDown(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				_isPageOk = _isPageReadyOk;
			}
			if (input.GetVRButtonUp(VRDeviceDefine.HandType.Both, VRDeviceDefine.Buttons.MainAction))
			{
				if (!IsSkipMode && !_isPageOk)
				{
					_isPageOk = true;
				}
				else
				{
					m_messagePlayer.OnPushMainButton();
				}
			}
			else if (IsAutoWaitNeedOverride)
			{
				m_autoTimer.Update(Time.deltaTime);
				if (IsAutoMode && m_autoTimer.IsTimeUp && !SingletonMonoBehaviour<PlayAreaManager>.Instance.IsOutOfBoundary.Value)
				{
					m_autoTimer.Reset();
					m_messagePlayer.OnProcessAuto();
				}
			}
			else
			{
				if (!IsAutoMode)
				{
					return;
				}
				if (SingletonMonoBehaviour<PlayAreaManager>.Instance.IsOutOfBoundary.Value)
				{
					if (m_autoTimer.CurrentTime > 0f)
					{
						m_autoTimer.Reset();
					}
				}
				else if (!IsChangingAuto && m_messagePlayer.IsAutoCounterOk())
				{
					m_autoTimer.Update(Time.deltaTime);
					if (m_autoTimer.IsTimeUp)
					{
						m_autoTimer.Reset();
						m_messagePlayer.OnProcessAuto();
					}
				}
			}
		}

		private void UpdateAutoModeStartInput()
		{
			if (m_autoStartTimer.IsTimeUp)
			{
				return;
			}
			m_autoStartTimer.Update(Time.deltaTime);
			if (!m_autoStartTimer.IsTimeUp)
			{
				return;
			}
			_isPageOk = false;
			if (!CanInterract || !m_messagePlayer.GetCanToggleModeTo(MessagePlayer.PlayModes.Auto))
			{
				SoundManager.SE.PlaySystem(SoundDefine.SystemSE.Menu_Error);
				return;
			}
			if (!IsAutoWaitNeedOverride)
			{
				m_autoTimer.Reset();
			}
			m_messagePlayer.SetPlayMode(MessagePlayer.PlayModes.Auto);
		}
	}
	public class PlayAreaPositioner : MonoBehaviour
	{
		[Header("Parameters - Positioning")]
		[Tooltip("Start()が呼ばれたらPlayAreaを呼び寄せます")]
		[SerializeField]
		private bool _positionOnStart = true;

		[Tooltip("Falseにすると、PlayAreaを子にするのをやめます")]
		[SerializeField]
		private bool _ignoreParentize;

		[Header("Parameters - Color")]
		[SerializeField]
		private bool _setColorOnAttach;

		[SerializeField]
		private Color _clearColor = ColorDefine.Black;

		private void Start()
		{
			if (_positionOnStart)
			{
				AttachPlayArea();
			}
		}

		public void AttachPlayArea()
		{
			if (SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
			{
				Transform myTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.MyTransform;
				if (_ignoreParentize)
				{
					myTransform.position = base.transform.position;
					myTransform.rotation = base.transform.rotation;
				}
				else
				{
					myTransform.SetParent(base.transform, worldPositionStays: false);
					myTransform.ResetLocal();
				}
				if (_setColorOnAttach)
				{
					SingletonMonoBehaviour<PlayAreaManager>.Instance.SetClearColor(_clearColor);
				}
			}
		}

		public void Detach()
		{
			if (!_ignoreParentize && SingletonMonoBehaviour<PlayAreaManager>.HasInstance)
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.MyTransform.SetParent(null);
			}
		}
	}
	public abstract class ResourceDataLoader<T> where T : UnityEngine.Object
	{
		public class Data
		{
			public int ID;

			public T LoadData;

			public Data(int id, T data)
			{
				ID = id;
				LoadData = data;
			}
		}

		private List<AsyncOperation> m_requests = new List<AsyncOperation>();

		private List<Data> m_dataList = new List<Data>();

		private bool m_isUnload;

		public virtual bool IsLoading => m_requests.Count > 0;

		public ResourceDataLoader(bool isUnload)
		{
			m_isUnload = isUnload;
			m_dataList = new List<Data>();
		}

		public virtual void Clear()
		{
			int count = m_dataList.Count;
			for (int i = 0; i < count; i++)
			{
				if (m_isUnload)
				{
					Resources.UnloadAsset(m_dataList[i].LoadData);
				}
				m_dataList[i].LoadData = null;
				m_dataList[i] = null;
			}
			m_dataList.Clear();
			m_requests.Clear();
			Resources.UnloadUnusedAssets();
		}

		public virtual void Load(List<int> preloadIndexes)
		{
			if (preloadIndexes == null)
			{
				return;
			}
			UnloadUnusedData(preloadIndexes);
			preloadIndexes.ForEach(delegate(int id)
			{
				ResourceRequest resourceRequest = Resources.LoadAsync<T>(CreateFilePath(id));
				resourceRequest.completed += delegate(AsyncOperation obj)
				{
					OnLoadEnd(obj, id);
				};
				m_requests.Add(resourceRequest);
			});
		}

		private void UnloadUnusedData(List<int> preloadIndexes)
		{
			if (preloadIndexes.Count <= 0)
			{
				return;
			}
			for (int i = 0; i < m_dataList.Count; i++)
			{
				bool flag = RemoveCommandWithID(preloadIndexes, m_dataList[i].ID);
				if (preloadIndexes.Count <= 0)
				{
					break;
				}
				if (!flag)
				{
					Resources.UnloadAsset(m_dataList[i].LoadData);
					m_dataList[i].LoadData = null;
					OnDataRemoved(m_dataList[i].ID);
					m_dataList.RemoveAt(i);
					i--;
				}
			}
			Resources.UnloadUnusedAssets();
		}

		private bool RemoveCommandWithID(List<int> list, int id)
		{
			return list.RemoveAll((int i) => i == id) > 0;
		}

		protected virtual void OnDataRemoved(int id)
		{
		}

		protected abstract string CreateFilePath(int id);

		private void OnLoadEnd(AsyncOperation obj, int id)
		{
			m_requests.Remove(obj);
			T val = (obj as ResourceRequest).asset as T;
			if (!(val == null))
			{
				m_dataList.Add(new Data(id, val));
				OnLoadComplete(m_dataList[m_dataList.Count - 1]);
			}
		}

		protected virtual void OnLoadComplete(Data data)
		{
		}
	}
	public class MasterManager : SingletonMonoBehaviour<MasterManager>
	{
		[Header("Parameters - Scenes")]
		[SerializeField]
		private SceneDefine _titleScene = SceneDefine.Title;

		[SerializeField]
		private SceneDefine _blankScene = SceneDefine.Blank;

		[SerializeField]
		private List<SceneDefine> _ingameSceneDefines = new List<SceneDefine>();

		[Header("Parameters - Others")]
		[SerializeField]
		private float _fadeDurationExit = 1f;

		private List<Scene> _loadedInGameScenes = new List<Scene>();

		private SortedDictionary<int, Component> _busyComponentList = new SortedDictionary<int, Component>();

		private int _loadedCount;

		private SceneDefine _unloadToScene;

		private Subject<Unit> _subjectLoadCompleteInGame = new Subject<Unit>();

		private Subject<Unit> _subjectBeforeExitFade = new Subject<Unit>();

		private Subject<Unit> _subjectBeforeEndInGame = new Subject<Unit>();

		private Subject<int> _subjectBeforeStartInGame = new Subject<int>();

		private Subject<bool> _subjectToggleBusyProcess = new Subject<bool>();

		private AsyncSubject<Unit> _subjectQuitApplication = new AsyncSubject<Unit>();

		public bool IsInGame { get; private set; }

		public bool IsBusy { get; private set; }

		public bool IsTitleScene => SingletonMonoBehaviour<TransitionManager>.Instance.CurrentSceneId == TitleScene;

		public SceneDefine TitleScene => _titleScene;

		public bool IsSuperAutoMode => false;

		public SortedDictionary<int, Component> BusyComponentList => _busyComponentList;

		public IObservable<Unit> OnLoadCompleteInGame => _subjectLoadCompleteInGame;

		public IObservable<Unit> OnBeforeExitFade => _subjectBeforeExitFade;

		public IObservable<Unit> OnBeforeEndInGame => _subjectBeforeEndInGame;

		public IObservable<int> OnBeforeStartInGame => _subjectBeforeStartInGame;

		public IObservable<bool> OnToggleBusyProcess => _subjectToggleBusyProcess;

		public IObservable<Unit> OnQuitApplication => _subjectQuitApplication;

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			OnBeforeExitFade.Subscribe(delegate
			{
				SingletonMonoBehaviour<SoundManager>.Instance.StopAll(BgmPlayer.StopMode.Fade, _fadeDurationExit);
				SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.Dispose();
			});
		}

		public void ForceToTitle()
		{
			SingletonMonoBehaviour<SoundManager>.Instance.StopAll();
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.Dispose();
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.SetColour(ColorDefine.Black);
			if (IsInGame)
			{
				ExitInGame();
			}
			else if (IsTitleScene)
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(_blankScene, (TransitionManager.OnComplete)delegate
				{
					SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(TitleScene);
				});
			}
			else
			{
				SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(TitleScene);
			}
		}

		public void StartInGame(int scenarioId = -1)
		{
			AddBusy(this);
			_subjectBeforeStartInGame.OnNext(scenarioId);
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(_blankScene, (TransitionManager.OnComplete)delegate
			{
				if (IsInGame)
				{
					OnLoadedAllInGame();
				}
				else
				{
					int count = _ingameSceneDefines.Count;
					for (int i = 0; i < count; i++)
					{
						SceneDefine sceneId = _ingameSceneDefines[i];
						SingletonMonoBehaviour<TransitionManager>.Instance.AddSceneAsync(sceneId, OnLoadedInGameScene);
					}
				}
			});
		}

		private void OnLoadedInGameScene(Scene scene)
		{
			_loadedCount++;
			_loadedInGameScenes.Add(scene);
			if (_loadedCount >= _ingameSceneDefines.Count)
			{
				_subjectLoadCompleteInGame.OnNext(Unit.Default);
				OnLoadedAllInGame();
			}
		}

		private void OnLoadedAllInGame()
		{
			RenderSettings.fog = false;
			IsInGame = true;
			RemoveBusy(this);
			SingletonMonoBehaviour<InGameManager>.Instance.ReadyOnStart();
		}

		public void ExitFade(Action onFadeEnd)
		{
			_subjectBeforeExitFade.OnNext(Unit.Default);
			SingletonMonoBehaviour<FadeManager>.Instance.sceneFader.StartFade(ColorDefine.Black, _fadeDurationExit, isDeactivateOnEnd: false, onFadeEnd);
		}

		public void ExitInGameWithFade()
		{
			ExitInGameWithFade(TitleScene);
		}

		public void ExitInGameWithFade(SceneDefine nextScene)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<InGameManager>.Instance.DisableReady();
			}
			ExitFade(delegate
			{
				ExitInGame(nextScene);
			});
		}

		public void ExitInGame()
		{
			ExitInGame(TitleScene);
		}

		public void ExitInGame(SceneDefine nextScene)
		{
			_subjectBeforeEndInGame.OnNext(Unit.Default);
			_unloadToScene = nextScene;
			if (IsInGame)
			{
				IsInGame = false;
				for (int num = _loadedInGameScenes.Count - 1; num >= 0; num--)
				{
					_ = _loadedInGameScenes[num];
					SingletonMonoBehaviour<TransitionManager>.Instance.UnloadSceneAsync(SceneDefine.InGame, delegate
					{
						OnUnloadInGame();
					});
				}
				_loadedInGameScenes.Clear();
			}
			else
			{
				OnUnLoadedAllInGame();
			}
		}

		private void OnUnloadInGame()
		{
			_loadedCount--;
			if (_loadedCount <= 0)
			{
				OnUnLoadedAllInGame();
			}
		}

		private void OnUnLoadedAllInGame()
		{
			SingletonMonoBehaviour<TransitionManager>.Instance.ChangeActiveSceneAsync(_unloadToScene);
		}

		public void StartScenarioWithFade(int scenarioToLoad)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<InGameManager>.Instance.DisableReady();
			}
			ExitFade(delegate
			{
				StartScenario(scenarioToLoad);
			});
		}

		public void StartScenario(int scenarioToLoad)
		{
			StartInGame(scenarioToLoad);
		}

		public void StartScenarioFromFileWithFade(int fileIndex)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<InGameManager>.Instance.DisableReady();
			}
			ExitFade(delegate
			{
				StartScenarioFromFile(fileIndex);
			});
		}

		public void StartScenarioFromFile(int fileIndex)
		{
			SingletonMonoBehaviour<GameData>.Instance.LoadSaveData(fileIndex);
			StartInGame(SingletonMonoBehaviour<GameData>.Instance.CurrentSaveData.SequenceID);
		}

		public void StartScenarioFromAutoSave()
		{
			StartScenarioFromFile(0);
		}

		public void SaveGame(int fileIndex)
		{
			if (IsInGame)
			{
				SingletonMonoBehaviour<GameData>.Instance.Save(fileIndex);
			}
		}

		public void AutoSave()
		{
			if (!SingletonMonoBehaviour<DataManager>.Instance.GeneralData.GetScenarioInfo(SingletonMonoBehaviour<LocalData>.Instance.NextScenarioID).IgnoreFileSave)
			{
				SaveGame(0);
			}
		}

		public void AddBusy(Component comp)
		{
			int hashCode = comp.GetHashCode();
			if (!_busyComponentList.ContainsKey(hashCode))
			{
				_busyComponentList.Add(hashCode, comp);
				ToggleBusy(flag: true);
			}
		}

		public void RemoveBusy(Component comp)
		{
			int hashCode = comp.GetHashCode();
			if (_busyComponentList.Remove(hashCode) && _busyComponentList.Count == 0)
			{
				ToggleBusy(flag: false);
			}
		}

		private void ToggleBusy(bool flag)
		{
			if (flag != IsBusy)
			{
				IsBusy = flag;
				_subjectToggleBusyProcess.OnNext(flag);
			}
		}

		private void OnApplicationQuit()
		{
			_subjectQuitApplication.OnNext(Unit.Default);
			_subjectQuitApplication.OnCompleted();
		}
	}
	public class PermanentObjectLoader : MonoBehaviour
	{
		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void LoadPermanentObjects()
		{
			UnityEngine.Debug.unityLogger.logEnabled = false;
			AnalyticsUtility.Initialize();
			VrUtility.OnLoadStart(isChangeGraphics: false);
			InitializeDoTween();
			SceneDefine[] array = new SceneDefine[2]
			{
				SceneDefine.Permanent,
				SceneDefine.MainMenu
			};
			for (int i = 0; i < array.Length; i++)
			{
				int num = (int)array[i];
				if (!SceneManager.GetSceneByBuildIndex(num).IsValid())
				{
					SceneManager.LoadScene(num, LoadSceneMode.Additive);
				}
			}
		}

		private static bool IsBootScene(Scene scene)
		{
			return false;
		}

		private static bool IsGameScene(SceneDefine scene)
		{
			return !IsNonGameScene(scene);
		}

		private static bool IsNonGameScene(SceneDefine scene)
		{
			if (scene != SceneDefine.Backstreet)
			{
				return scene != SceneDefine.Crossing;
			}
			return false;
		}

		private static bool IsInGamePermanentScene(SceneDefine scene)
		{
			if (scene != SceneDefine.InGame)
			{
				return scene == SceneDefine.MainMenu;
			}
			return true;
		}

		private static void InitializeDoTween()
		{
			DOTween.Init();
		}
	}
	public class TransitionManager : SingletonMonoBehaviour<TransitionManager>
	{
		public delegate void OnComplete();

		public delegate void OnCompleteScene(Scene loadedScene);

		private Scene _currentScene;

		private AsyncOperation _asyncLoad;

		private bool _isChangeingScene;

		private Dictionary<int, AsyncOperation> _loadReservedScenes = new Dictionary<int, AsyncOperation>();

		private Subject<Scene> _subjectBeforeTransition = new Subject<Scene>();

		private Subject<Scene> _subjectCompleteTransition = new Subject<Scene>();

		public float ProgressChange
		{
			get
			{
				if (_asyncLoad == null)
				{
					if (!_isChangeingScene)
					{
						return 1f;
					}
					return 0f;
				}
				return _asyncLoad.progress;
			}
		}

		public Scene CurrentScene => _currentScene;

		public SceneDefine CurrentSceneId => GetSceneIdByScene(_currentScene);

		public IObservable<Scene> OnBeforeTransition => _subjectBeforeTransition;

		public IObservable<Scene> OnCompleteTransition => _subjectCompleteTransition;

		protected override void InitializeOnAwake()
		{
			ResetCurrentScene();
			OnBeforeTransition.Where((Scene _) => !SingletonMonoBehaviour<MasterManager>.Instance.IsInGame).Subscribe(delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.AddBusy(this);
			});
			OnCompleteTransition.Subscribe(delegate
			{
				SingletonMonoBehaviour<MasterManager>.Instance.RemoveBusy(this);
			});
		}

		private void OnDestroy()
		{
			_subjectCompleteTransition.OnCompleted();
		}

		public void ResetCurrentScene()
		{
			_currentScene = SceneManager.GetActiveScene();
		}

		public void SetActiveScene(SceneDefine sceneId)
		{
			SetActiveScene((int)sceneId);
		}

		public void SetActiveScene(int sceneId)
		{
			Scene sceneByBuildIndex = SceneManager.GetSceneByBuildIndex(sceneId);
			if (sceneByBuildIndex.IsValid())
			{
				SetActiveScene(sceneByBuildIndex);
			}
		}

		public void SetActiveScene(Scene scene)
		{
			SceneManager.SetActiveScene(scene);
			ResetCurrentScene();
		}

		public void ChangeActiveSceneAsync(SceneDefine sceneId)
		{
			ChangeActiveSceneAsync((int)sceneId);
		}

		public void ChangeActiveSceneAsync(int sceneId)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineSceneTransition(ob, sceneId)).Subscribe(delegate
			{
			});
		}

		public void ChangeActiveSceneAsync(SceneDefine sceneId, OnComplete onLoaded)
		{
			ChangeActiveSceneAsync((int)sceneId, onLoaded);
		}

		public void ChangeActiveSceneAsync(int sceneId, OnComplete onLoaded)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineSceneTransition(ob, sceneId)).Subscribe(delegate
			{
				onLoaded();
			});
		}

		public void ChangeActiveSceneAsync(SceneDefine sceneId, OnCompleteScene onLoaded)
		{
			ChangeActiveSceneAsync((int)sceneId, onLoaded);
		}

		public void ChangeActiveSceneAsync(int sceneId, OnCompleteScene onLoaded)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineSceneTransition(ob, sceneId)).Subscribe(delegate(Scene scene)
			{
				onLoaded(scene);
			});
		}

		private IEnumerator CoroutineSceneTransition(IObserver<Scene> ob, int sceneId)
		{
			if (_currentScene.IsValid() && sceneId == _currentScene.buildIndex)
			{
				yield return null;
				_currentScene = SceneManager.GetSceneByBuildIndex(sceneId);
				ob.OnNext(_currentScene);
				ob.OnCompleted();
				yield break;
			}
			if (_isChangeingScene)
			{
				ob.OnCompleted();
				yield break;
			}
			_subjectBeforeTransition.OnNext(_currentScene);
			_isChangeingScene = true;
			if (_currentScene.IsValid())
			{
				yield return SceneManager.UnloadSceneAsync(_currentScene);
			}
			if (_loadReservedScenes.ContainsKey(sceneId))
			{
				yield return _loadReservedScenes[sceneId];
				_loadReservedScenes.Remove(sceneId);
			}
			else
			{
				_asyncLoad = SceneManager.LoadSceneAsync(sceneId, LoadSceneMode.Additive);
				yield return _asyncLoad;
			}
			Scene scene = (_currentScene = SceneManager.GetSceneByBuildIndex(sceneId));
			SceneManager.SetActiveScene(scene);
			GC.Collect();
			Resources.UnloadUnusedAssets();
			_isChangeingScene = false;
			_subjectCompleteTransition.OnNext(scene);
			ob.OnNext(scene);
			ob.OnCompleted();
		}

		public void AddScene(SceneDefine sceneId)
		{
			AddScene((int)sceneId);
		}

		public void AddScene(int sceneId)
		{
			SceneManager.LoadScene(sceneId, LoadSceneMode.Additive);
		}

		public void AddSceneAsync(SceneDefine sceneId, OnCompleteScene onLoaded)
		{
			AddSceneAsync((int)sceneId, onLoaded);
		}

		public void AddSceneAsync(int sceneId, OnCompleteScene onLoaded)
		{
			Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineAddScene(ob, sceneId)).Subscribe(delegate(Scene scene)
			{
				onLoaded(scene);
			});
		}

		public IObservable<Scene> AddSceneAsyncAsObservable(SceneDefine sceneId)
		{
			return AddSceneAsyncAsObservable((int)sceneId);
		}

		public IObservable<Scene> AddSceneAsyncAsObservable(int sceneId)
		{
			return Observable.FromCoroutine((IObserver<Scene> ob) => CoroutineAddScene(ob, sceneId));
		}

		private IEnumerator CoroutineAddScene(IObserver<Scene> ob, int sceneId)
		{
			if (_loadReservedScenes.ContainsKey(sceneId))
			{
				yield return _loadReservedScenes[sceneId];
			}
			else
			{
				yield return SceneManager.LoadSceneAsync(sceneId, LoadSceneMode.Additive);
			}
			Scene sceneByBuildIndex = SceneManager.GetSceneByBuildIndex(sceneId);
			ob.OnNext(sceneByBuildIndex);
			ob.OnCompleted();
		}

		public void UnloadSceneAsync(SceneDefine sceneId, OnComplete onUnloaded)
		{
			UnloadSceneAsync((int)sceneId, onUnloaded);
		}

		public void UnloadSceneAsync(int sceneId, OnComplete onUnloaded)
		{
			Observable.FromCoroutine((CancellationToken _) => CoroutineUnloadScene(sceneId)).Subscribe(delegate
			{
				if (onUnloaded != null)
				{
					onUnloaded();
				}
			});
		}

		public IObservable<Unit> UnloadSceneAsyncAsObservable(int sceneId, OnComplete onUnloaded)
		{
			return Observable.FromCoroutine((CancellationToken _) => CoroutineUnloadScene(sceneId));
		}

		private IEnumerator CoroutineUnloadScene(int sceneId)
		{
			yield return SceneManager.UnloadSceneAsync(sceneId);
		}

		public void ReserveSceneFromList(List<int> sceneList)
		{
			if (sceneList == null || sceneList.Count <= 0)
			{
				return;
			}
			foreach (int scene in sceneList)
			{
				ReserveScene(scene);
			}
		}

		public void ReserveScene(SceneDefine sceneId)
		{
			ReserveScene((int)sceneId);
		}

		private void ReserveScene(int sceneId)
		{
			if (!SceneManager.GetSceneByBuildIndex(sceneId).IsValid() && !_loadReservedScenes.ContainsKey(sceneId))
			{
				AsyncOperation asyncOperation = SceneManager.LoadSceneAsync(sceneId, LoadSceneMode.Additive);
				_loadReservedScenes.Add(sceneId, asyncOperation);
				asyncOperation.priority = -128;
				asyncOperation.completed += delegate
				{
				};
			}
		}

		public void DisposeAllReservedScene()
		{
			foreach (KeyValuePair<int, AsyncOperation> loadReservedScene in _loadReservedScenes)
			{
				UnloadSceneAsync(loadReservedScene.Key, null);
			}
			_loadReservedScenes.Clear();
		}

		public bool IsSceneReservedAndLoading(SceneDefine sceneId)
		{
			return IsSceneReservedAndLoading((int)sceneId);
		}

		public bool IsSceneReservedAndLoading(int sceneId)
		{
			if (_loadReservedScenes.ContainsKey(sceneId))
			{
				return !_loadReservedScenes[sceneId].isDone;
			}
			return false;
		}

		public SceneDefine GetSceneIdByScene(Scene scene)
		{
			return (SceneDefine)scene.buildIndex;
		}
	}
	public abstract class BaseVRPlatform : MonoBehaviour
	{
		public virtual bool IsMovileDevice => false;

		public virtual bool IsTouchpadAvailable => false;

		public virtual bool UseTrackedHands => false;

		public virtual bool IsAvailableRecenter => true;

		public virtual int AntiAiliasRate => 8;

		public virtual float EyeTextureScale => 1.25f;

		public virtual float TargetFPS => 90f;

		public virtual float PitchControllerOffset => 0f;

		public virtual VRDeviceDefine.HandType AvailableHand => VRDeviceDefine.HandType.None;

		public virtual VRDeviceDefine.DeviceType CurrentDeviceType => VRDeviceDefine.DeviceType.Unsupported;

		public virtual bool IsRecenteredController => false;

		public virtual void OnInitialize()
		{
			throw new NotImplementedVRPlatformException();
		}

		public virtual bool IsHandTracked(VRDeviceDefine.HandType hand)
		{
			return false;
		}

		public virtual Vector3 GetHandPosition(VRDeviceDefine.HandType hand)
		{
			return Vector3.zero;
		}

		public virtual Quaternion GetHandRotation(VRDeviceDefine.HandType hand)
		{
			return Quaternion.identity;
		}

		public virtual bool GetVRButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return false;
		}

		public virtual bool GetVRButtonDown(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return false;
		}

		public virtual bool GetVRButtonUp(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			return false;
		}

		public virtual bool GetAxisPadStartTouch(VRDeviceDefine.HandType hand)
		{
			return false;
		}

		public virtual bool GetAxisPadTouching(VRDeviceDefine.HandType hand)
		{
			return false;
		}

		public virtual Vector2 GetAxisPad2D(VRDeviceDefine.HandType hand)
		{
			return Vector2.zero;
		}

		public virtual Vector2 GetAxisStick2D(VRDeviceDefine.HandType hand)
		{
			return Vector2.zero;
		}

		public virtual void Vibrate(VRDeviceDefine.HandType hand, float length, float power)
		{
		}

		public virtual bool IsLanguageProhibited(GameDefine.Languages lang)
		{
			return false;
		}

		public virtual void OnBackFromRoot()
		{
		}

		public virtual void OnStartBusy()
		{
		}

		public virtual void OnEndBusy()
		{
		}

		public virtual void UnlockAchievement(AchievementDefine.Keys key)
		{
		}

		public virtual void ClearAllAchievements()
		{
		}

		public virtual void Recenter()
		{
			InputTracking.Recenter();
		}

		public virtual void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			OnEndValidate(obj: true);
		}
	}
	public class HandObject : MonoBehaviour
	{
		[SerializeField]
		private GameObject _handModel;

		private bool _isTracked;

		private bool _isMainHand;

		private bool _isControllerVisible;

		private bool _isLaserVisible = true;

		private Transform _thisTransform;

		private LaserController _laser;

		private VRDeviceDefine.HandType _handType;

		public Transform ThisTransform => _thisTransform;

		public float CurrentLaserLength => _laser.CurrentLength;

		private VRDeviceDefine.HandType HandType => _handType;

		private void Awake()
		{
			_thisTransform = base.transform;
			_laser = GetComponent<LaserController>();
			_laser.InputTriggerDown = GetTriggerDown;
			_laser.InputTriggerUp = GetTriggerUp;
			_laser.InputVibrate = Vibrate;
			_handType = ((_laser.GetHandType() != 0) ? VRDeviceDefine.HandType.Right : VRDeviceDefine.HandType.Left);
		}

		private void Start()
		{
			if (HandType == VRDeviceDefine.HandType.Left)
			{
				SingletonMonoBehaviour<GameInputManager>.Instance.OnToggleTrackedLeft.Subscribe(delegate(bool tracked)
				{
					ToggleTracked(tracked);
				}).AddTo(base.gameObject);
			}
			else if (HandType == VRDeviceDefine.HandType.Right)
			{
				SingletonMonoBehaviour<GameInputManager>.Instance.OnToggleTrackedRight.Subscribe(delegate(bool tracked)
				{
					ToggleTracked(tracked);
				}).AddTo(base.gameObject);
			}
			SingletonMonoBehaviour<GameInputManager>.Instance.OnChangeMainHand.DelayFrame(1).Subscribe(delegate(VRDeviceDefine.HandType type)
			{
				if (type == HandType)
				{
					_isMainHand = true;
					Vibrate(0.1f, 0.5f);
					UpdateLaserEnable();
				}
				else
				{
					_isMainHand = false;
					UpdateLaserEnable();
				}
			}).AddTo(base.gameObject);
		}

		private void UpdateLaserEnable()
		{
			_laser.enabled = _isTracked && _isMainHand;
		}

		private void ToggleTracked(bool flag)
		{
			_isTracked = flag;
			UpdateLaserEnable();
			UpdateVisibleController();
		}

		public void ToggleVisible(bool flag)
		{
			_isControllerVisible = flag;
			UpdateLaserEnable();
			UpdateVisibleController();
		}

		public void ToggleLaserVisible(bool flag)
		{
			_isLaserVisible = flag;
			_laser.IsVisibleLaser = _isLaserVisible;
		}

		public void ToggleLaserAutoDisappear(bool flag)
		{
			_laser.IsAutoDisappear = flag;
		}

		private void UpdateVisibleController()
		{
			bool active = _isTracked && _isControllerVisible;
			_handModel.SetActive(active);
		}

		private bool GetTriggerDown()
		{
			return SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonDown(HandType, VRDeviceDefine.Buttons.MainAction);
		}

		private bool GetTriggerUp()
		{
			return SingletonMonoBehaviour<GameInputManager>.Instance.GetVRButtonUp(HandType, VRDeviceDefine.Buttons.MainAction);
		}

		private Vector2 GetScrollDelta()
		{
			return SingletonMonoBehaviour<GameInputManager>.Instance.GetVRScrollDelta(HandType);
		}

		public void Vibrate(float length, float power)
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.Vibrate(HandType, length, power);
		}
	}
	public class HeadObject : MonoBehaviour
	{
		[SerializeField]
		private Transform _neckAnchor;

		public Transform NeckAnchor => _neckAnchor;
	}
	public class VRPlatformNone : BaseVRPlatform
	{
		public override void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			UnityEngine.Debug.LogError("Non-VR Mode not supported.");
			OnEndValidate(obj: false);
		}
	}
	public class VRPlatformOculus : BaseVRPlatform
	{
		private const float VIBRATION_MIN_VALUE = 40f;

		private const float VIBRATION_MAX_VALUE = 255f;

		private const float VIBRATION_BYTE_PER_SECOND = 320f;

		private const int GO_MAX_CPU_LEVEL = 4;

		private const int GO_MIN_CPU_LEVEL = 2;

		private bool recenterEmitted;

		private VRDeviceDefine.DeviceType _currentDeviceType;

		public override bool IsMovileDevice => isOculusGo;

		public override bool IsTouchpadAvailable => isOculusGo;

		public override bool UseTrackedHands => isOculusQuest;

		public override bool IsAvailableRecenter => false;

		public override bool IsRecenteredController => recenterEmitted;

		public override int AntiAiliasRate
		{
			get
			{
				if (!isOculusGo)
				{
					return 8;
				}
				return 4;
			}
		}

		public override float EyeTextureScale => 1.25f;

		public override float TargetFPS
		{
			get
			{
				if (!isOculusGo)
				{
					return 90f;
				}
				return 60f;
			}
		}

		public override float PitchControllerOffset => 0f;

		public override VRDeviceDefine.HandType AvailableHand
		{
			get
			{
				if (IsMovileDevice)
				{
					return VRDeviceDefine.HandType.None;
				}
				return VRDeviceDefine.HandType.Both;
			}
		}

		public override VRDeviceDefine.DeviceType CurrentDeviceType => _currentDeviceType;

		private bool isOculusGo => _currentDeviceType == VRDeviceDefine.DeviceType.OculusGo;

		private bool isOculusQuest => _currentDeviceType == VRDeviceDefine.DeviceType.OculusQuest;

		public override void OnInitialize()
		{
			OVRPlugin.SystemHeadset systemHeadsetType = OVRPlugin.GetSystemHeadsetType();
			if ((uint)(systemHeadsetType - 8) <= 1u)
			{
				_currentDeviceType = VRDeviceDefine.DeviceType.OculusQuest;
			}
			else
			{
				_currentDeviceType = VRDeviceDefine.DeviceType.OculusRift;
			}
			if (isOculusGo)
			{
				InitWithGo();
			}
			else
			{
				MakeSubscribePositionReset();
			}
			OVRManager.display.displayFrequency = TargetFPS;
		}

		private void MakeSubscribePositionReset()
		{
			(from _ in this.UpdateAsObservable()
				where IsTouchRecenterDown()
				select _).Subscribe(delegate
			{
				StartCoroutine(CoroutineEmitRecenter());
			}).AddTo(base.gameObject);
		}

		private void InitWithGo()
		{
			OVRManager.tiledMultiResLevel = OVRManager.TiledMultiResLevel.LMSHigh;
		}

		private bool IsTouchRecenterPushing()
		{
			if (!OVRInput.Get(OVRInput.Button.PrimaryHandTrigger))
			{
				return OVRInput.Get(OVRInput.Button.SecondaryHandTrigger);
			}
			return true;
		}

		private bool IsTouchRecenterDown()
		{
			if (!OVRInput.GetDown(OVRInput.Button.PrimaryHandTrigger))
			{
				return OVRInput.GetDown(OVRInput.Button.SecondaryHandTrigger);
			}
			return true;
		}

		private IEnumerator CoroutineEmitRecenter()
		{
			for (float emitTime = 0f; emitTime <= 0.5f; emitTime += Time.deltaTime)
			{
				if (!IsTouchRecenterPushing())
				{
					yield break;
				}
				yield return new WaitForEndOfFrame();
			}
			recenterEmitted = true;
			yield return new WaitForEndOfFrame();
			recenterEmitted = false;
		}

		public override bool IsHandTracked(VRDeviceDefine.HandType hand)
		{
			OVRInput.Controller controllerType = ((hand == VRDeviceDefine.HandType.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			return OVRInput.GetControllerPositionTracked(controllerType);
		}

		public override Vector3 GetHandPosition(VRDeviceDefine.HandType hand)
		{
			OVRInput.Controller controllerType = ((hand == VRDeviceDefine.HandType.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			return OVRInput.GetLocalControllerPosition(controllerType);
		}

		public override Quaternion GetHandRotation(VRDeviceDefine.HandType hand)
		{
			OVRInput.Controller controllerType = ((hand == VRDeviceDefine.HandType.Left) ? OVRInput.Controller.LTouch : OVRInput.Controller.RTouch);
			return OVRInput.GetLocalControllerRotation(controllerType);
		}

		public override bool GetVRButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return OVRInput.Get(DefineToOVRButton(button));
			}
			if (hand == VRDeviceDefine.HandType.Both)
			{
				if (IsNeedBothRaw(button))
				{
					if (!GetVRButton(VRDeviceDefine.HandType.Left, button))
					{
						return GetVRButton(VRDeviceDefine.HandType.Right, button);
					}
					return true;
				}
				return OVRInput.Get(DefineToOVRButton(button));
			}
			return OVRInput.Get(DefineToOVRRawButton(hand, button));
		}

		public override bool GetVRButtonDown(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return OVRInput.GetDown(DefineToOVRButton(button));
			}
			if (hand == VRDeviceDefine.HandType.Both)
			{
				if (IsNeedBothRaw(button))
				{
					if (!GetVRButtonDown(VRDeviceDefine.HandType.Left, button))
					{
						return GetVRButtonDown(VRDeviceDefine.HandType.Right, button);
					}
					return true;
				}
				return OVRInput.GetDown(DefineToOVRButton(button));
			}
			return OVRInput.GetDown(DefineToOVRRawButton(hand, button));
		}

		public override bool GetVRButtonUp(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return OVRInput.GetUp(DefineToOVRButton(button));
			}
			if (hand == VRDeviceDefine.HandType.Both)
			{
				if (IsNeedBothRaw(button))
				{
					if (!GetVRButtonUp(VRDeviceDefine.HandType.Left, button))
					{
						return GetVRButtonUp(VRDeviceDefine.HandType.Right, button);
					}
					return true;
				}
				return OVRInput.GetUp(DefineToOVRButton(button));
			}
			return OVRInput.GetUp(DefineToOVRRawButton(hand, button));
		}

		private OVRInput.Button DefineToOVRButton(VRDeviceDefine.Buttons button)
		{
			if (isOculusGo)
			{
				switch (button)
				{
				case VRDeviceDefine.Buttons.DeviceBack:
					return OVRInput.Button.Back;
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.Button.One;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.Button.PrimaryIndexTrigger;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.Button.Down;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.Button.Up;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.Button.Right;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.Button.Left;
				}
			}
			else
			{
				switch (button)
				{
				case VRDeviceDefine.Buttons.DeviceBack:
					return OVRInput.Button.Back;
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.Button.Two | OVRInput.Button.Start;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.Button.One | OVRInput.Button.PrimaryIndexTrigger;
				case VRDeviceDefine.Buttons.PositionReset:
					return OVRInput.Button.PrimaryHandTrigger;
				case VRDeviceDefine.Buttons.RemoveInterface:
					return OVRInput.Button.PrimaryThumbstick;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.Button.Up;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.Button.Down;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.Button.Left;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.Button.Right;
				}
			}
			return OVRInput.Button.None;
		}

		private OVRInput.RawButton DefineToOVRRawButton(VRDeviceDefine.HandType hand, VRDeviceDefine.Buttons button)
		{
			switch (hand)
			{
			case VRDeviceDefine.HandType.Left:
				switch (button)
				{
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.RawButton.Y | OVRInput.RawButton.Start;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.RawButton.X | OVRInput.RawButton.LIndexTrigger;
				case VRDeviceDefine.Buttons.PositionReset:
					if (!isOculusQuest)
					{
						return OVRInput.RawButton.LHandTrigger;
					}
					return OVRInput.RawButton.None;
				case VRDeviceDefine.Buttons.RemoveInterface:
					return OVRInput.RawButton.LThumbstick;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.RawButton.LThumbstickUp;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.RawButton.LThumbstickDown;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.RawButton.LThumbstickLeft;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.RawButton.LThumbstickRight;
				}
				break;
			case VRDeviceDefine.HandType.Right:
				switch (button)
				{
				case VRDeviceDefine.Buttons.Cancel:
					return OVRInput.RawButton.B;
				case VRDeviceDefine.Buttons.MainAction:
					return OVRInput.RawButton.A | OVRInput.RawButton.RIndexTrigger;
				case VRDeviceDefine.Buttons.PositionReset:
					if (!isOculusQuest)
					{
						return OVRInput.RawButton.RHandTrigger;
					}
					return OVRInput.RawButton.None;
				case VRDeviceDefine.Buttons.RemoveInterface:
					return OVRInput.RawButton.RThumbstick;
				case VRDeviceDefine.Buttons.Up:
					return OVRInput.RawButton.RThumbstickUp;
				case VRDeviceDefine.Buttons.Down:
					return OVRInput.RawButton.RThumbstickDown;
				case VRDeviceDefine.Buttons.Left:
					return OVRInput.RawButton.RThumbstickLeft;
				case VRDeviceDefine.Buttons.Right:
					return OVRInput.RawButton.RThumbstickRight;
				}
				break;
			}
			return OVRInput.RawButton.None;
		}

		private bool IsNeedBothRaw(VRDeviceDefine.Buttons button)
		{
			if (IsMovileDevice)
			{
				return false;
			}
			if ((uint)(button - 3) <= 3u || (uint)(button - 8) <= 3u)
			{
				return true;
			}
			return false;
		}

		public override bool GetAxisPadStartTouch(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return OVRInput.GetDown(OVRInput.Touch.PrimaryTouchpad);
			}
			return false;
		}

		public override bool GetAxisPadTouching(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return OVRInput.Get(OVRInput.Touch.PrimaryTouchpad);
			}
			return false;
		}

		public override Vector2 GetAxisPad2D(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return OVRInput.Get(OVRInput.Axis2D.PrimaryTouchpad);
			}
			return Vector2.zero;
		}

		public override Vector2 GetAxisStick2D(VRDeviceDefine.HandType hand)
		{
			if (isOculusGo)
			{
				return Vector2.zero;
			}
			return hand switch
			{
				VRDeviceDefine.HandType.Left => OVRInput.Get(OVRInput.RawAxis2D.LThumbstick), 
				VRDeviceDefine.HandType.Right => OVRInput.Get(OVRInput.RawAxis2D.RThumbstick), 
				_ => OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick), 
			};
		}

		public override void Vibrate(VRDeviceDefine.HandType hand, float length, float power)
		{
			if (!IsMovileDevice && !(length <= 0f) && OVRHaptics.Config.SampleSizeInBytes != 0)
			{
				int num = Mathf.FloorToInt(320f * length);
				byte b = (byte)Mathf.Lerp(40f, 255f, power);
				byte[] array = new byte[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = b;
				}
				OVRHapticsClip clip = new OVRHapticsClip(array, array.Length);
				switch (hand)
				{
				case VRDeviceDefine.HandType.Left:
					OVRHaptics.LeftChannel.Mix(clip);
					break;
				case VRDeviceDefine.HandType.Right:
					OVRHaptics.RightChannel.Mix(clip);
					break;
				default:
					OVRHaptics.LeftChannel.Mix(clip);
					OVRHaptics.RightChannel.Mix(clip);
					break;
				}
			}
		}

		public override bool IsLanguageProhibited(GameDefine.Languages lang)
		{
			if (lang == GameDefine.Languages.Chinese)
			{
				return true;
			}
			return false;
		}

		public override void OnBackFromRoot()
		{
			if (IsMovileDevice)
			{
				OVRManager.PlatformUIConfirmQuit();
			}
		}

		public override void OnStartBusy()
		{
			OVRManager.cpuLevel = 4;
		}

		public override void OnEndBusy()
		{
			OVRManager.cpuLevel = 2;
		}

		public override void Recenter()
		{
			OVRManager.display.RecenterPose();
		}

		public override void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			try
			{
				Core.AsyncInitialize();
				Entitlements.IsUserEntitledToApplication().OnComplete(delegate(Oculus.Platform.Message msg)
				{
					if (msg.IsError)
					{
						UnityEngine.Debug.LogError("OVRPlatform: You are NOT entitled to use this app.");
						OnEndValidate(obj: false);
					}
					else
					{
						UnityEngine.Debug.Log("OVRPlatform: You are entitled to use this app.");
						OnEndValidate(obj: true);
					}
				});
			}
			catch (UnityException exception)
			{
				UnityEngine.Debug.LogError("OVRPlatform: Platform failed to initialize due to exception.");
				UnityEngine.Debug.LogException(exception);
				OnEndValidate(obj: false);
			}
		}
	}
	public class VRPlatformOpenVR : BaseVRPlatform
	{
	}
	public class VRPlatformPlaystation : BaseVRPlatform
	{
	}
	public class NotImplementedVRPlatformException : Exception
	{
		public NotImplementedVRPlatformException()
		{
		}

		public NotImplementedVRPlatformException(string message)
			: base(message)
		{
		}
	}
	public class FailedVRPlatformInitializationException : Exception
	{
		public FailedVRPlatformInitializationException()
		{
		}

		public FailedVRPlatformInitializationException(string message)
			: base(message)
		{
		}
	}
	public class PlayAreaManager : SingletonMonoBehaviour<PlayAreaManager>
	{
		public enum LayerModes
		{
			Normal,
			BokeSphere,
			InFade,
			Minimum,
			Nothing,
			MAX
		}

		[Header("Prefabs - Platform Components")]
		[SerializeField]
		[EnumLabel(typeof(VRDeviceDefine.PlatformType))]
		private BaseVRPlatform[] _prefabPlatforms;

		[Header("Components - VR Component")]
		[SerializeField]
		private TrackingObjectComponents userTrackComponent;

		[Header("Parameters")]
		[SerializeField]
		private float _cameraFarClip = 2000f;

		[SerializeField]
		[EnumLabel(typeof(LayerModes))]
		private LayerMask[] _layerSettings = new LayerMask[5];

		private Transform _initialParent;

		private TrackingObjectComponents _currentComponent;

		private HeadObject _headObject;

		private HandObject _leftHandObject;

		private HandObject _rightHandObject;

		private PlayAreaMover _mover;

		private LayerModes _currentLayerMode;

		private HashSet<object>[] _changeLayerRequestLists = new HashSet<object>[5];

		private HashSet<object> _needLaserList;

		public Transform MyTransform { get; private set; }

		public VRDeviceDefine.PlatformType LoadedVR { get; private set; }

		public VRDeviceDefine.DeviceType CurrentDeviceType => InputVR.CurrentDeviceType;

		public bool IsVRLoaded
		{
			get
			{
				VRDeviceDefine.PlatformType loadedVR = LoadedVR;
				if ((uint)loadedVR <= 1u)
				{
					return false;
				}
				return true;
			}
		}

		public bool IsSucceedInitialize { get; set; }

		public BaseVRPlatform InputVR { get; private set; }

		public Transform CameraAnchorTransform => _mover.Anchor;

		public Transform VRAreaTransform => _currentComponent.transform;

		public Transform HeadTransform => _currentComponent.headComponent;

		public HeadObject HeadObject
		{
			get
			{
				if (_headObject != null)
				{
					return _headObject;
				}
				_headObject = userTrackComponent.headComponent.GetComponent<HeadObject>();
				return _headObject;
			}
		}

		public HandObject LeftHandObject
		{
			get
			{
				if (_leftHandObject != null)
				{
					return _leftHandObject;
				}
				_leftHandObject = userTrackComponent.leftHandComponent.GetComponent<HandObject>();
				return _leftHandObject;
			}
		}

		public HandObject RightHandObject
		{
			get
			{
				if (_rightHandObject != null)
				{
					return _rightHandObject;
				}
				_rightHandObject = userTrackComponent.rightHandComponent.GetComponent<HandObject>();
				return _rightHandObject;
			}
		}

		public Camera EyeCamera => _currentComponent.eyeCameraComponent;

		public IReadOnlyReactiveProperty<bool> IsOutOfBoundary => _mover.IsOutOfBoundary;

		public float BoundaryRange
		{
			get
			{
				return _mover.BoundaryRange;
			}
			set
			{
				_mover.BoundaryRange = value;
			}
		}

		protected override void InitializeOnAwake()
		{
			MyTransform = base.transform;
			_initialParent = MyTransform.parent;
			_mover = GetComponent<PlayAreaMover>();
			MakeList();
			ActivateVRDevice();
		}

		private void MakeList()
		{
			_needLaserList = new HashSet<object>();
			int num = _changeLayerRequestLists.Length;
			for (int i = 0; i < num; i++)
			{
				_changeLayerRequestLists[i] = new HashSet<object>();
			}
		}

		private void ActivateVRDevice()
		{
			SetLoadedVRFromString();
			if (!IsVRLoaded)
			{
				UnityEngine.Debug.LogError("No VR Loaded!");
				return;
			}
			try
			{
				BaseVRPlatform original = _prefabPlatforms[(int)LoadedVR];
				InputVR = UnityEngine.Object.Instantiate(original, base.transform, worldPositionStays: false);
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogErrorFormat("VR Platform '<b>{0}</b>' Instantiating Error.", LoadedVR);
				UnityEngine.Debug.LogException(exception);
				throw;
			}
			if (InputVR == null)
			{
				UnityEngine.Debug.LogErrorFormat("Component for VR Platform '<b>{0}</b>' is missing.", LoadedVR);
				return;
			}
			try
			{
				InputVR.OnInitialize();
			}
			catch (NotImplementedVRPlatformException ex)
			{
				UnityEngine.Debug.LogErrorFormat("VR Platform '<b>{0}</b>' is not implemented.\n{1}", LoadedVR, ex.StackTrace);
				throw;
			}
			catch (Exception ex2)
			{
				UnityEngine.Debug.LogErrorFormat("VR Platform '<b>{0}</b>'  Initialization Error by {1}\n{2}", LoadedVR, ex2.GetType().ToString(), ex2.StackTrace);
				throw;
			}
			AttachTrackingObjects();
			InitMover();
			InitMisc();
			IsSucceedInitialize = true;
		}

		private void SetLoadedVRFromString()
		{
			if (!XRSettings.enabled)
			{
				LoadedVR = VRDeviceDefine.PlatformType.Disabled;
				return;
			}
			VRDeviceDefine.PlatformType loadedVR = VRDeviceDefine.PlatformType.Unsupported;
			string loadedDeviceName = XRSettings.loadedDeviceName;
			if (loadedDeviceName == "Oculus")
			{
				loadedVR = VRDeviceDefine.PlatformType.Oculus;
			}
			else if (loadedDeviceName == "OpenVR")
			{
				loadedVR = VRDeviceDefine.PlatformType.OpenVR;
			}
			LoadedVR = loadedVR;
		}

		private void AttachTrackingObjects()
		{
			TrackingObjectComponents component = InputVR.GetComponent<TrackingObjectComponents>();
			if (!(component == null))
			{
				_currentComponent = component;
				userTrackComponent.headComponent.SetParent(component.headComponent, worldPositionStays: false);
				userTrackComponent.leftHandComponent.SetParent(component.leftHandComponent, worldPositionStays: false);
				userTrackComponent.leftHandComponent.Rotate(InputVR.PitchControllerOffset, 0f, 0f);
				userTrackComponent.rightHandComponent.SetParent(component.rightHandComponent, worldPositionStays: false);
				userTrackComponent.rightHandComponent.Rotate(InputVR.PitchControllerOffset, 0f, 0f);
			}
		}

		private void InitMover()
		{
			_mover.InitTransforms(VRAreaTransform, _currentComponent.eyeCameraComponent.transform);
		}

		private void InitMisc()
		{
			QualitySettings.antiAliasing = InputVR.AntiAiliasRate;
			XRSettings.eyeTextureResolutionScale = InputVR.EyeTextureScale;
			EyeCamera.farClipPlane = _cameraFarClip;
		}

		private void Start()
		{
			MakeSubscribes();
		}

		private void MakeSubscribes()
		{
			SingletonMonoBehaviour<MasterManager>.Instance.OnToggleBusyProcess.Subscribe(delegate(bool busy)
			{
				if (busy)
				{
					InputVR.OnStartBusy();
					RequestLayerMode(this, LayerModes.Minimum);
				}
				else
				{
					InputVR.OnEndBusy();
					DisposeLayerMode(this, LayerModes.Minimum);
				}
				ToggleLaserVisible(!busy);
			}).AddTo(this);
			(from key in SingletonMonoBehaviour<GameData>.Instance.FlagActivatedObservable.FlagToKeys()
				where key != AchievementDefine.Keys.NULL
				select key).Subscribe(delegate(AchievementDefine.Keys key)
			{
				InputVR.UnlockAchievement(key);
			}).AddTo(this);
		}

		public void SetClearColor(Color color)
		{
			_currentComponent.eyeCameraComponent.backgroundColor = color;
		}

		public void ToggleLaserVisible(bool flag)
		{
			LeftHandObject.ToggleLaserVisible(flag);
			RightHandObject.ToggleLaserVisible(flag);
		}

		public void AddLaserNeed(object comp)
		{
			if (!_needLaserList.Contains(comp) && _needLaserList.Add(comp))
			{
				LeftHandObject.ToggleLaserAutoDisappear(flag: false);
				RightHandObject.ToggleLaserAutoDisappear(flag: false);
			}
		}

		public void RemoveLaserNeed(object comp)
		{
			if (_needLaserList.Remove(comp))
			{
				bool flag = _needLaserList.Count == 0;
				LeftHandObject.ToggleLaserAutoDisappear(flag);
				RightHandObject.ToggleLaserAutoDisappear(flag);
			}
		}

		public void BackToInitialParent()
		{
			MyTransform.SetParent(_initialParent);
		}

		private void SetLayerMode(LayerModes mode)
		{
			_currentLayerMode = mode;
			_currentComponent.eyeCameraComponent.cullingMask = _layerSettings[(int)mode];
		}

		public void RequestLayerMode(object comp, LayerModes mode)
		{
			if (_changeLayerRequestLists[(int)mode].Add(comp) && _currentLayerMode < mode)
			{
				_currentLayerMode = mode;
				SetLayerMode(_currentLayerMode);
			}
		}

		public void DisposeLayerMode(object comp, LayerModes mode)
		{
			if (_changeLayerRequestLists[(int)mode].Remove(comp) && _currentLayerMode <= mode)
			{
				while (_currentLayerMode != 0 && _changeLayerRequestLists[(int)_currentLayerMode].Count <= 0)
				{
					_currentLayerMode--;
				}
				SetLayerMode(_currentLayerMode);
			}
		}

		public void ResetBoundaryRange()
		{
			_mover.ResetBoundaryRange();
		}

		public void CheckLanguage()
		{
			if (IsLanguageProhibited(SingletonMonoBehaviour<GameData>.Instance.ConfigData.Language.Value))
			{
				SingletonMonoBehaviour<GameData>.Instance.ConfigData.ResetLanguageToSafe();
			}
		}

		public bool IsLanguageProhibited(GameDefine.Languages lang)
		{
			return InputVR.IsLanguageProhibited(lang);
		}

		public void UnlockAchievement(AchievementDefine.Keys key)
		{
			InputVR.UnlockAchievement(key);
		}

		public void ClearAllAchievements()
		{
		}

		public void StartApplicationPlatformValidate(Action<bool> OnEndValidate)
		{
			InputVR.StartApplicationPlatformValidate(OnEndValidate);
		}
	}
	public class PlayAreaMover : UpdateableComponent
	{
		[Header("Components")]
		[SerializeField]
		private Transform _anchorTransform;

		[SerializeField]
		private PlayAreaWarnObject _warnObject;

		[Header("Parameters - Main Switch")]
		[SerializeField]
		private bool _useSmmothFetch = true;

		[SerializeField]
		private bool _usePositionWarning = true;

		[Header("Parameters - Smooth Centering")]
		[SerializeField]
		private Vector3 _positionTarget = Vector3.zero;

		[SerializeField]
		private float _closeDistance = 0.2f;

		[SerializeField]
		private float _trackSpeed = 0.5f;

		[SerializeField]
		private float _trackBrake = 2.5f;

		[SerializeField]
		private float _trackPercent = 0.001f;

		[Header("Parameters - Position Warning")]
		[SerializeField]
		private float _defaultRange = 0.15f;

		[SerializeField]
		private bool _forceResentering = true;

		[SerializeField]
		private float _recenterTimeout = 20f;

		[SerializeField]
		private Color _warnFadeColor;

		private float _boundaryRange;

		private Vector2 _flattedPosition;

		private Vector3 _moveVelocity;

		private Transform _areaTransform;

		private Transform _cameraTransform;

		private Common.Timer _oobTimer = new Common.Timer(1f);

		private ReactiveProperty<bool> _isOutOfBoundary = new ReactiveProperty<bool>(initialValue: false);

		public Transform Anchor => _anchorTransform;

		public IReadOnlyReactiveProperty<bool> IsOutOfBoundary => _isOutOfBoundary;

		public float BoundaryRange
		{
			get
			{
				return _boundaryRange;
			}
			set
			{
				_boundaryRange = value;
			}
		}

		public void InitTransforms(Transform playarea, Transform camtrans)
		{
			_areaTransform = playarea;
			_cameraTransform = camtrans;
			_boundaryRange = _defaultRange;
		}

		protected override void Initialize()
		{
			SingletonMonoBehaviour<GameInputManager>.Instance.OnPositionReset.Subscribe(delegate
			{
				ResetToRoot();
			}).AddTo(base.gameObject);
			if (!_usePositionWarning)
			{
				return;
			}
			if (!SingletonMonoBehaviour<PlayAreaManager>.Instance.InputVR.IsAvailableRecenter)
			{
				_forceResentering = false;
				_warnObject.IsTimerVisible = false;
			}
			_isOutOfBoundary.Subscribe(delegate(bool flag)
			{
				_warnObject.SetVisible(flag);
				_oobTimer.SetDuration(_recenterTimeout);
				SingletonMonoBehaviour<FadeManager>.Instance.importantFader.SetColour(flag ? _warnFadeColor : ColorDefine.TransparentBlack);
			});
			_isOutOfBoundary.Where((bool flag) => flag).Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.RequestLayerMode(this, PlayAreaManager.LayerModes.Minimum);
			});
			_isOutOfBoundary.Where((bool flag) => !flag).Subscribe(delegate
			{
				SingletonMonoBehaviour<PlayAreaManager>.Instance.DisposeLayerMode(this, PlayAreaManager.LayerModes.Minimum);
			});
			base.UpdateObservable.Where((Unit _) => base.IsActive && _isOutOfBoundary.Value && _forceResentering && !_oobTimer.IsTimeUp).Subscribe(delegate
			{
				_oobTimer.Update(Time.deltaTime);
				if (_oobTimer.IsTimeUp)
				{
					SingletonMonoBehaviour<GameInputManager>.Instance.RecenterPosition();
				}
				else
				{
					_warnObject.SetTimeRemainingText(Mathf.CeilToInt(_oobTimer.RemainingTime));
					_warnObject.SetProgressValue(1f - _oobTimer.Rate);
				}
			});
		}

		public override void OnUpdate(float deltaTime)
		{
			if (_useSmmothFetch)
			{
				UpdateSmoothCentering(deltaTime);
			}
			UpdateAnchor();
		}

		private void UpdateAnchor()
		{
			_anchorTransform.localPosition = _cameraTransform.localPosition + _areaTransform.localPosition;
			_flattedPosition = new Vector2(_anchorTransform.localPosition.x, _anchorTransform.localPosition.z);
			_isOutOfBoundary.Value = _flattedPosition.sqrMagnitude > _boundaryRange * _boundaryRange;
		}

		private void UpdateSmoothCentering(float deltaTime)
		{
			Vector3 vector = _positionTarget - (_areaTransform.localPosition + _cameraTransform.localPosition);
			Vector3 zero = Vector3.zero;
			if (vector.sqrMagnitude >= _closeDistance * _closeDistance)
			{
				zero = vector * deltaTime * _trackSpeed;
				_moveVelocity = Vector3.Lerp(_moveVelocity, zero, _trackPercent);
			}
			else
			{
				_moveVelocity = Vector3.Lerp(_moveVelocity, zero, _trackPercent * _trackBrake);
			}
			_areaTransform.localPosition += _moveVelocity;
		}

		private void ResetToRoot()
		{
			_areaTransform.localPosition = Vector3.zero;
			_moveVelocity = Vector3.zero;
		}

		public void ResetBoundaryRange()
		{
			_boundaryRange = _defaultRange;
		}
	}
	public class PlayAreaWarnObject : MonoBehaviour
	{
		[Header("Components - Skin")]
		[SerializeField]
		private TextMeshPro _textTitle;

		[SerializeField]
		private TextMeshPro _textDespriction;

		[SerializeField]
		private ProgressBarSpriteSet _progress;

		[Header("Components - Key")]
		[SerializeField]
		private string _keyTitle = "OutOfAreaTitle";

		[SerializeField]
		private string _keyDesp = "OutOfAreaDesp";

		private Transform _targetFetch;

		private string _despCache = "";

		private int _lastSecond = -1;

		public bool IsTimerVisible { get; set; }

		private void Awake()
		{
			_targetFetch = base.transform;
			IsTimerVisible = true;
			SetVisible(flag: false);
		}

		private void Start()
		{
			SingletonMonoBehaviour<LocalizeManager>.Instance.ChangeLanguageObservable.Subscribe(delegate(GameDefine.Languages lang)
			{
				_textTitle.text = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyTitle, lang);
				_despCache = SingletonMonoBehaviour<LocalizeManager>.Instance.GetLocalizeString(_keyDesp, lang);
				_lastSecond = -1;
			});
		}

		public void SetVisible(bool flag)
		{
			_textTitle.enabled = flag;
			_textDespriction.enabled = flag;
			_progress.SetVisible(IsTimerVisible && flag);
			if (flag)
			{
				if (!IsTimerVisible)
				{
					_textDespriction.text = _despCache;
				}
				SetPositionToMainCamera();
			}
		}

		public void SetProgressValue(float value)
		{
			_progress.SetValue(value);
		}

		public void SetTimeRemainingText(int remainSecond)
		{
			if (remainSecond != _lastSecond)
			{
				_lastSecond = remainSecond;
				_textDespriction.text = string.Format(_despCache, remainSecond);
			}
		}

		private bool SetPositionToMainCamera()
		{
			Transform headTransform = SingletonMonoBehaviour<PlayAreaManager>.Instance.HeadTransform;
			Vector3 position = headTransform.position;
			Quaternion rotation = headTransform.rotation;
			float num = Mathf.DeltaAngle(90f, Vector3.SignedAngle(Vector3.up, rotation * Vector3.forward, rotation * Vector3.right));
			Quaternion quaternion = rotation * Quaternion.Euler(0f - num, 0f, 0f);
			Quaternion rotation2 = Quaternion.Euler(Mathf.Clamp(num, -25f, 25f), quaternion.eulerAngles.y, 0f);
			_targetFetch.position = position;
			_targetFetch.rotation = rotation2;
			return false;
		}
	}
	public class ProgressBarSpriteSet : MonoBehaviour
	{
		public enum StretchModes
		{
			Horizontal,
			Vertical
		}

		[Header("Components")]
		[SerializeField]
		private SpriteRenderer _backSprite;

		[SerializeField]
		private SpriteRenderer _frontSprite;

		[Header("Parameters")]
		[SerializeField]
		private StretchModes _stretchMode;

		private Vector2 MaxSize => _backSprite.size;

		public void SetVisible(bool flag)
		{
			_backSprite.enabled = flag;
			_frontSprite.enabled = flag;
		}

		public void SetValue(float percentage)
		{
			Vector2 maxSize = MaxSize;
			switch (_stretchMode)
			{
			case StretchModes.Horizontal:
				maxSize.x *= percentage;
				break;
			case StretchModes.Vertical:
				maxSize.y *= percentage;
				break;
			}
			_frontSprite.size = maxSize;
		}
	}
	public class TrackingObjectComponents : MonoBehaviour
	{
		public Camera eyeCameraComponent;

		public Transform headComponent;

		public Transform leftHandComponent;

		public Transform rightHandComponent;
	}
	public class VRSpaceCanvas : MonoBehaviour
	{
		private void Start()
		{
			GetComponent<Canvas>().worldCamera = SingletonMonoBehaviour<PlayAreaManager>.Instance.EyeCamera;
		}
	}
	public static class VrUtility
	{
		private const int _MAX_CPU_LEVEL = 4;

		private const int _MIN_CPU_LEVEL = 2;

		public static void SetToMaxCpuLevel()
		{
			OVRManager.cpuLevel = 4;
		}

		public static void SetToMinCpuLevel()
		{
			OVRManager.cpuLevel = 2;
		}

		public static void OnLoadStart(bool isChangeGraphics = true)
		{
			OVRManager.cpuLevel = 4;
		}

		public static void OnLoadEnd(bool isChangeGraphics = true)
		{
			OVRManager.cpuLevel = 2;
		}
	}
}
namespace Kaine
{
	[Serializable]
	public class AudioLayer : IAudioLayer
	{
		[SerializeField]
		private AudioSource[] m_audioSources;

		private List<AudioClip> m_clips;

		private AudioClip m_introClip;

		private AudioClip m_outroClip;

		private AudioSourceFader[] m_players;

		private int m_indexCurrent;

		private int m_indexNext;

		private bool m_isFadeIntro;

		private bool m_isLoop;

		public AudioSource Current => m_audioSources[m_indexCurrent];

		public AudioSource Next => m_audioSources[m_indexNext];

		public AudioSourceFader CurrentPlayer => m_players[m_indexCurrent];

		public AudioSourceFader NextPlayer => m_players[m_indexNext];

		public bool IsPlaying
		{
			get
			{
				if (!Current.isPlaying)
				{
					return Next.isPlaying;
				}
				return true;
			}
		}

		public bool HasIntro => m_introClip != null;

		public bool HasOutro => m_outroClip != null;

		public AudioLayer()
		{
			m_isLoop = false;
			m_isFadeIntro = false;
			m_clips = new List<AudioClip>();
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void Initialize()
		{
			int num = m_audioSources.Length;
			m_players = new AudioSourceFader[num];
			for (int i = 0; i < num; i++)
			{
				m_players[i] = new AudioSourceFader(m_audioSources[i]);
			}
		}

		public void Clear()
		{
			int num = m_audioSources.Length;
			for (int i = 0; i < num; i++)
			{
				m_audioSources[i].loop = false;
				m_audioSources[i].clip = null;
			}
			m_isFadeIntro = false;
			m_isLoop = false;
			m_clips.Clear();
			m_introClip = null;
			m_outroClip = null;
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void PlayScheduled(double time, int sample = 0)
		{
			Current.timeSamples = sample;
			Current.PlayScheduled(time);
		}

		public void PlayScheduledWithFade(double time, float fadeDuration)
		{
			CurrentPlayer.PlayScheduledWithFade(time, fadeDuration);
		}

		public void PlayNextScheduled(double time, int sample = 0)
		{
			Next.timeSamples = sample;
			Next.PlayScheduled(time);
		}

		public void PlayIntro(int nextClipIndex, double time, float fadeDuration = 1.25f)
		{
			Current.clip = m_introClip;
			if (!m_isLoop)
			{
				SetupNextClip(nextClipIndex);
			}
			if (m_isFadeIntro)
			{
				CurrentPlayer.PlayScheduledWithFade(time, fadeDuration);
			}
			else
			{
				Current.PlayScheduled(time);
			}
		}

		public void Stop()
		{
			if (Current.isPlaying)
			{
				Current.Stop();
			}
			if (Next.isPlaying)
			{
				Next.Stop();
			}
		}

		public void StopWithFade(float duration)
		{
			if (Current.isPlaying)
			{
				CurrentPlayer.StopWithFade(duration);
			}
			if (Next.isPlaying)
			{
				NextPlayer.StopWithFade(duration);
			}
		}

		public void Swap()
		{
			int indexCurrent = m_indexCurrent;
			m_indexCurrent = m_indexNext;
			m_indexNext = indexCurrent;
		}

		public void SetupIntroClips(List<AudioClip> clips)
		{
			m_introClip = null;
			m_isFadeIntro = false;
			if (clips.Count > 0)
			{
				m_introClip = clips[0];
				Current.clip = m_introClip;
			}
			else if (m_clips.Count > 0)
			{
				m_introClip = m_clips[0];
				m_isFadeIntro = true;
				Current.clip = m_introClip;
			}
		}

		public void SetupPartsClips(List<AudioClip> clips)
		{
			m_clips = clips;
		}

		public void SetupOutroClips(List<AudioClip> clips)
		{
			m_outroClip = null;
			if (clips.Count > 0)
			{
				m_outroClip = clips[0];
			}
		}

		public void SetupNextClip(int clipIndex)
		{
			if (clipIndex == -1)
			{
				Next.clip = m_introClip;
			}
			else
			{
				Next.clip = m_clips[clipIndex];
			}
		}

		public void SetNextClipToOutro()
		{
			Next.clip = m_outroClip;
		}

		public void SetTimeSample(int sample)
		{
			Current.timeSamples = sample;
		}

		public void SetVolume(float volume, float fadeDuration = 0.5f)
		{
			if (Current.isPlaying)
			{
				CurrentPlayer.FadeVolume(fadeDuration, volume);
				NextPlayer.FadeVolume(fadeDuration, volume);
			}
			else
			{
				Current.volume = volume;
				Next.volume = volume;
			}
		}

		public void Update(float delta)
		{
			int num = m_players.Length;
			for (int i = 0; i < num; i++)
			{
				m_players[i].Update(delta);
			}
		}

		public void SetLoop(bool isLoop)
		{
			m_isLoop = isLoop;
			Current.loop = isLoop;
			Next.loop = isLoop;
		}
	}
	[CreateAssetMenu(menuName = "Kaine/Create Layer Volume Data", fileName = "AudioLayerVolueme")]
	public class AudioLayerVolumeData : ScriptableObject
	{
		[Serializable]
		public class Data
		{
			[Range(0f, 1f)]
			public float[] Volume;
		}

		public Data[] DataList;
	}
	public class AudioSourceFader
	{
		private AudioSource m_source;

		private Tweener<float> m_volumeFader;

		public bool IsPlaying => m_source.isPlaying;

		public AudioSourceFader(AudioSource source)
		{
			m_source = source;
			m_volumeFader = new Tweener<float>(Mathf.Lerp);
		}

		public void Update(float delta)
		{
			if (m_volumeFader.IsActive)
			{
				m_volumeFader.Update(delta);
				m_source.volume = m_volumeFader.CurrentValue;
			}
		}

		public void Fade(float targetVolume, float duration, Action onFadeEnd = null)
		{
			m_volumeFader.Start(m_source.volume, targetVolume, duration, onFadeEnd);
		}

		public void Fade(float startVolume, float targetVolume, float duration, Action onFadeEnd = null)
		{
			m_volumeFader.Start(startVolume, targetVolume, duration, onFadeEnd);
			m_source.volume = startVolume;
		}

		public void PlayWithFade(float targetVolume, float startVolume = 0f, float fadeDuration = 0.5f, AudioClip clip = null)
		{
			if (clip != null)
			{
				m_source.clip = clip;
			}
			if (m_source.Play(clip))
			{
				if (fadeDuration <= 0f)
				{
					m_source.volume = targetVolume;
				}
				else
				{
					Fade(startVolume, targetVolume, fadeDuration);
				}
			}
		}

		public void PlayScheduledWithFade(double time, float fadeDuration = 0.5f, AudioClip clip = null)
		{
			PlayScheduledWithFade(m_source.volume, time, fadeDuration, clip);
		}

		public void PlayScheduledWithFade(float targetVolume, double time, float fadeDuration = 0.5f, AudioClip clip = null)
		{
			if (clip != null)
			{
				m_source.clip = clip;
			}
			m_source.PlayScheduled(time);
			if (fadeDuration > 0f)
			{
				Fade(0f, targetVolume, fadeDuration);
			}
		}

		public void Stop()
		{
			m_source.Stop();
			m_volumeFader.Dispose();
		}

		public void StopWithFade(float fadeDutation = 0.5f, Action onComplete = null)
		{
			if (!m_source.isPlaying)
			{
				return;
			}
			if (fadeDutation >= 0f)
			{
				Fade(m_source.volume, 0f, fadeDutation, delegate
				{
					m_source.Stop();
					if (onComplete != null)
					{
						onComplete();
					}
				});
			}
			else
			{
				Stop();
			}
		}

		public void SetVolume(float volume)
		{
			m_source.volume = volume;
		}

		public void FadeVolume(float fadeDuration, float targetVolume)
		{
			if (fadeDuration <= 0f)
			{
				m_source.volume = targetVolume;
			}
			else
			{
				Fade(targetVolume, fadeDuration);
			}
		}

		public void FadeVolume(float fadeDuration, float targetVolume, float startVolume)
		{
			if (fadeDuration <= 0f)
			{
				m_source.volume = targetVolume;
			}
			else
			{
				Fade(startVolume, targetVolume, fadeDuration);
			}
		}

		public void SetClip(AudioClip clip)
		{
			m_source.clip = clip;
		}

		public void SetLoop(bool loop)
		{
			m_source.loop = loop;
		}
	}
	[Serializable]
	public class CoreAudioLayer : IAudioLayer
	{
		[SerializeField]
		private Music[] m_musicEngines;

		private List<AudioClip> m_clips;

		private AudioClip m_introClip;

		private AudioClip m_outroClip;

		private int m_indexCurrent;

		private int m_indexNext;

		private bool m_isLoopIntro;

		public Music Current => m_musicEngines[m_indexCurrent];

		public Music Next => m_musicEngines[m_indexNext];

		public int ClipCount => m_clips.Count;

		public bool IsPlaying
		{
			get
			{
				if (!Current.IsPlaying)
				{
					return Next.IsPlaying;
				}
				return true;
			}
		}

		public bool HasIntro => m_introClip != null;

		public bool HasOutro => m_outroClip != null;

		public CoreAudioLayer()
		{
			m_isLoopIntro = false;
			m_clips = new List<AudioClip>();
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void Clear()
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].enabled = true;
				m_musicEngines[i].CurrentSource.clip = null;
				m_musicEngines[i].CurrentSource.loop = false;
			}
			m_clips.Clear();
			m_introClip = null;
			m_outroClip = null;
			m_isLoopIntro = false;
			m_indexCurrent = 0;
			m_indexNext = 1;
		}

		public void SetupSectionSettings(int bpm, int beats, int unitPerBar)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].CurrentSection.Tempo = bpm;
				m_musicEngines[i].CurrentSection.UnitPerBeat = beats;
				m_musicEngines[i].CurrentSection.UnitPerBar = unitPerBar;
			}
		}

		public void SetupIntroClips(List<AudioClip> clips, int frequency)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].SampleRate = ((frequency <= 0) ? 44100 : frequency);
			}
			SetupIntroClips(clips);
		}

		public void SetupIntroClips(List<AudioClip> clips)
		{
			m_introClip = null;
			if (clips.Count > 0)
			{
				m_introClip = clips[0];
			}
			else if (m_clips.Count > 0)
			{
				m_introClip = m_clips[0];
			}
		}

		public void SetupPartsClips(List<AudioClip> clips)
		{
			m_clips = clips;
		}

		public void SetupOutroClips(List<AudioClip> clips)
		{
			m_outroClip = null;
			if (clips.Count > 0)
			{
				m_outroClip = clips[0];
			}
		}

		public void PlayScheduled(double time, int sample = 0)
		{
			Current.CurrentSource.timeSamples = sample;
			Current.PlayScheduled(time);
		}

		public void PlayScheduledWithFade(double time, float fadeDuration)
		{
			Current.PlayScheduledWithFade(time, fadeDuration);
		}

		public void PlayNextScheduled(double time, int sample = 0)
		{
			Next.CurrentSource.timeSamples = sample;
			Next.PlayScheduled(time);
		}

		public void PlayIntro(int nextClipIndex, double time, float fadeDuration = 1.25f)
		{
			Current.CurrentSource.clip = m_introClip;
			Current.SetupClips();
			if (m_isLoopIntro)
			{
				Current.PlayScheduledWithFade(time, fadeDuration);
				return;
			}
			SetupNextClip(nextClipIndex);
			Next.SetupClips();
			if (fadeDuration > 0f)
			{
				Current.PlayScheduledWithFade(time, fadeDuration);
			}
			else
			{
				Current.PlayScheduled(time);
			}
		}

		public void Stop()
		{
			StopWithFade(0f);
		}

		public void StopWithFade(float duration)
		{
			if (Current.IsPlaying)
			{
				Current.Player.StopWithFade(duration);
			}
			if (Next.IsPlaying)
			{
				Next.Player.StopWithFade(duration);
			}
		}

		public void Swap()
		{
			int indexCurrent = m_indexCurrent;
			m_indexCurrent = m_indexNext;
			m_indexNext = indexCurrent;
		}

		public void SetupNextClip(int clipIndex)
		{
			if (clipIndex == -1)
			{
				Next.SetupClips(m_introClip);
			}
			else
			{
				Next.SetupClips(m_clips[clipIndex]);
			}
		}

		public void SetNextClipToOutro()
		{
			Next.SetupClips(m_outroClip);
		}

		public void SetVolume(float volume, float fadeDuration = 0.5f)
		{
			if (Current.IsPlaying)
			{
				Current.Player.FadeVolume(fadeDuration, volume);
				Next.Player.FadeVolume(fadeDuration, volume);
			}
			else
			{
				Current.SetVolume(volume);
				Next.SetVolume(volume);
			}
		}

		public void SetTimeSample(int sample)
		{
			Current.CurrentSource.timeSamples = sample;
		}

		public void Update(float delta)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].UpdateFade(delta);
			}
		}

		public void SetLoop(bool isLoop)
		{
			m_isLoopIntro = isLoop;
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].CurrentSource.loop = isLoop;
			}
		}

		public void SetEngineEnable(bool isEnable)
		{
			int num = m_musicEngines.Length;
			for (int i = 0; i < num; i++)
			{
				m_musicEngines[i].enabled = isEnable;
			}
		}
	}
	public interface IAudioLayer
	{
		bool IsPlaying { get; }

		bool HasIntro { get; }

		bool HasOutro { get; }

		void Clear();

		void PlayIntro(int nextClipIndex, double time, float fadeDuration);

		void PlayScheduled(double time, int sample);

		void PlayScheduledWithFade(double time, float fadeDuration);

		void PlayNextScheduled(double time, int sample);

		void Stop();

		void StopWithFade(float duration);

		void Swap();

		void SetupIntroClips(List<AudioClip> clips);

		void SetupPartsClips(List<AudioClip> clips);

		void SetupOutroClips(List<AudioClip> clips);

		void SetupNextClip(int clipIndex);

		void SetNextClipToOutro();

		void SetVolume(float volume, float fadeDuration);

		void SetTimeSample(int sample);

		void SetLoop(bool isLoop);
	}
	public class KainePlayer : MonoBehaviour
	{
		public enum Indexs
		{
			Main,
			Next
		}

		public enum Layers
		{
			Ambient,
			Base,
			Lead
		}

		public enum States
		{
			Play,
			Stop,
			ReserveOutro,
			WaitPlayOutro,
			PlayingOutro
		}

		private const double _MEASURE_BAR_COUNT = 1.0;

		private const int _INTRO_FADE_BARS = 4;

		public const float _DEFAULT_FADE_DURATION = 1.25f;

		public const int _DEFAULT_FREQUENCY = 44100;

		public const Layers _CORE_LAYER = Layers.Ambient;

		public const int _INTRO_CLIP_INDEX = -1;

		[Header("Components")]
		[SerializeField]
		private CoreAudioLayer m_coreLayer;

		[SerializeField]
		private AudioLayer[] m_layers;

		[SerializeField]
		private AudioLayerVolumeData m_voluemeData;

		[Header("Parts Settings")]
		[SerializeField]
		private int m_changeClipBar = 8;

		[SerializeField]
		private int m_barLength = 9;

		[SerializeField]
		private int m_revurbLenght = 1;

		[SerializeField]
		private bool m_isConnectSameClip;

		[SerializeField]
		[Tooltip("アウトロ予約が入ってる時に入れ替えを行う小節位置")]
		private int m_reserveProcessBar = 1;

		public Action OnEndPlay;

		private GameObject m_gameObject;

		private int m_scheduleBar;

		private int m_currentClipIndex;

		private int m_nextClipIndex;

		private int m_numLayers;

		private Layers m_nextLayer;

		private bool m_isWaitChangeClip;

		private bool m_isReserveLayerChange;

		private States m_state;

		private bool m_isSingleClipMode;

		private bool m_isSimpleMode;

		private AudioSourceFader m_simpleSource;

		private Action m_onEndSimpleBgmFade;

		public bool IsPlaying
		{
			get
			{
				if (!m_coreLayer.IsPlaying)
				{
					return m_simpleSource.IsPlaying;
				}
				return true;
			}
		}

		public bool IsPlayingParts => m_coreLayer.IsPlaying;

		public double TimePerBar => 60.0 * (double)m_coreLayer.Current.CurrentSection.UnitPerBeat * 1.0 / m_coreLayer.Current.CurrentSection.Tempo;

		public bool IsReserveOutro => m_state == States.ReserveOutro;

		public bool IsWaitOutro => m_state == States.WaitPlayOutro;

		public bool IsPlayingOutro => m_state == States.PlayingOutro;

		public bool IsStopped => m_state == States.Stop;

		public bool IsStopping
		{
			get
			{
				if (!IsStopped && !IsReserveOutro && !IsWaitOutro)
				{
					return IsPlayingOutro;
				}
				return true;
			}
		}

		public bool IsNearConnection => m_coreLayer.Current.Just.Bar >= m_scheduleBar;

		public Layers CurrentLayer { get; private set; }

		public int NumberOfLayers => m_numLayers;

		public int NumberOfAdditionalLayers => m_numLayers - 1;

		private bool IsSinglePartTrack => m_coreLayer.ClipCount == 1;

		private void Start()
		{
			m_isSimpleMode = false;
			m_gameObject = base.gameObject;
			m_isSingleClipMode = false;
			m_state = States.Play;
			m_scheduleBar = m_changeClipBar - 1;
			m_isWaitChangeClip = false;
			m_isReserveLayerChange = false;
			if (m_layers.Length != 0)
			{
				m_simpleSource = new AudioSourceFader(m_layers[0].Current);
			}
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Initialize();
			}
			CreateActions();
		}

		private void CreateActions()
		{
			m_onEndSimpleBgmFade = delegate
			{
				m_isSimpleMode = false;
				m_simpleSource.SetClip(null);
				m_simpleSource.SetLoop(loop: false);
			};
		}

		public void Clear()
		{
			m_isSimpleMode = false;
			m_coreLayer.Clear();
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Clear();
			}
		}

		public static bool IsCoreLayer(Layers layer)
		{
			return layer == Layers.Ambient;
		}

		public IAudioLayer GetLayer(Layers layer)
		{
			if (layer == Layers.Ambient)
			{
				return m_coreLayer;
			}
			return m_layers[(int)(layer - 1)];
		}

		public void SetupTrackInfo(int bpm, int bars, int beats, int unitPerBar, int fadeBars, int layers, bool hasIntro, bool isSingleClip)
		{
			SetBarLength(bars);
			m_coreLayer.SetupSectionSettings(bpm, beats, unitPerBar);
			m_numLayers = layers;
			m_isSingleClipMode = isSingleClip;
		}

		public void SetBarLength(int bars)
		{
			m_barLength = bars;
			m_changeClipBar = m_barLength - m_revurbLenght;
			m_scheduleBar = m_changeClipBar - 1;
		}

		public void SetupIntroClips(int layer, int frequency, List<AudioClip> clips)
		{
			if (IsCoreLayer((Layers)layer))
			{
				m_coreLayer.SetupIntroClips(clips, frequency);
			}
			else
			{
				GetLayer((Layers)layer).SetupIntroClips(clips);
			}
		}

		public void SetupOutroClips(int layer, List<AudioClip> clips)
		{
			GetLayer((Layers)layer).SetupOutroClips(clips);
		}

		public void SetupPartsClips(int layer, List<AudioClip> clips)
		{
			GetLayer((Layers)layer).SetupPartsClips(clips);
		}

		public void PlayBgm(Layers layer)
		{
			m_isSimpleMode = false;
			CurrentLayer = layer;
			if (m_isSingleClipMode)
			{
				SetupSinglePartsTrack();
			}
			else
			{
				SetLoop(isLoop: false);
				SetupNextClipIndex();
				SetNextClipsInAllLayers(m_nextClipIndex);
			}
			PlayLayers(layer, 0, 0.0, isPlaySound: false);
			PlayIntro();
		}

		private void SetupSinglePartsTrack()
		{
			SetLoop(isLoop: true);
		}

		public void SetLoop(bool isLoop)
		{
			m_coreLayer.SetLoop(isLoop);
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].SetLoop(isLoop);
			}
		}

		private void PlayIntro()
		{
			float fadeDuration = (IsSinglePartTrack ? ((float)TimePerBar * 4f) : 0f);
			double dspTime = AudioSettings.dspTime;
			m_coreLayer.PlayIntro(m_nextClipIndex, dspTime, fadeDuration);
			int currentLayer = (int)CurrentLayer;
			for (int i = 0; i < currentLayer; i++)
			{
				m_layers[i].PlayIntro(m_nextClipIndex, dspTime, fadeDuration);
			}
			m_state = States.Play;
		}

		public void PlaySimpleBgm(AudioClip clip, float volume = 1f, float fadeDuration = 0.5f)
		{
			m_isSimpleMode = true;
			m_simpleSource.PlayWithFade(volume, 0f, fadeDuration, clip);
			m_simpleSource.SetLoop(loop: true);
		}

		public void SetSimpleVolume(float volume, float fadeDuration)
		{
			m_simpleSource.FadeVolume(fadeDuration, volume);
		}

		private void Update()
		{
			if (!m_coreLayer.IsPlaying)
			{
				if (m_isSimpleMode && m_simpleSource.IsPlaying)
				{
					UpdateSimpleBgm();
				}
			}
			else
			{
				UpdateFade();
				UpdateWaitBar();
				UpdateChangeClip();
			}
		}

		private void UpdateSimpleBgm()
		{
			if (m_isSimpleMode && m_simpleSource.IsPlaying)
			{
				m_simpleSource.Update(Time.deltaTime);
			}
		}

		private void UpdateFade()
		{
			float deltaTime = Time.deltaTime;
			m_coreLayer.Update(deltaTime);
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Update(deltaTime);
			}
		}

		private void UpdateWaitBar()
		{
			if (!m_coreLayer.Current.IsJustChangedBar() || IsPlayingOutro || IsStopped || m_isSingleClipMode)
			{
				return;
			}
			int bar = m_coreLayer.Current.Just.Bar;
			if (bar == m_scheduleBar)
			{
				PlayNext();
			}
			else if (bar == m_changeClipBar)
			{
				SwapMusic();
				if (m_isReserveLayerChange)
				{
					PlayLayers(m_nextLayer, m_coreLayer.Current.TimeSamples, AudioSettings.dspTime, isPlaySound: true, CalculateLayerChangeDuration());
				}
			}
			if (IsReserveOutro && bar == m_reserveProcessBar)
			{
				SetOutroClip();
			}
		}

		private void PlayNext()
		{
			if (IsWaitOutro)
			{
				m_state = States.PlayingOutro;
				float waitDuration = (float)TimePerBar * (float)(m_barLength + m_revurbLenght + 1);
				SubscribeOnEndEvent(waitDuration);
			}
			PlayNextScheduled();
		}

		private void PlayNextScheduled()
		{
			double time = AudioSettings.dspTime + TimePerBar;
			m_coreLayer.Next.PlayScheduled(time);
			PlayScheduledLayers(time);
		}

		private void PlayLayers(Layers layer, int sample, double time, bool isPlaySound, float fadeDuration = 0f)
		{
			AudioLayerVolumeData.Data data = m_voluemeData.DataList[(int)layer];
			int num = m_layers.Length;
			int volumeDataCount = data.Volume.Length;
			m_coreLayer.SetVolume(data.Volume[0], fadeDuration);
			for (int i = 0; i < num; i++)
			{
				SetupLayerOnPlay(data, layer, i, volumeDataCount, sample, time, isPlaySound, fadeDuration);
			}
			CurrentLayer = layer;
			m_isReserveLayerChange = false;
			UpdateLayerText();
		}

		private void SetupLayerOnPlay(AudioLayerVolumeData.Data volumeData, Layers layer, int index, int volumeDataCount, int sample, double time, bool isPlaySound, float fadeDuration = 0f)
		{
			int num = index + 1;
			IAudioLayer layer2 = GetLayer((Layers)num);
			if (index >= (int)layer)
			{
				if (layer2.IsPlaying)
				{
					layer2.StopWithFade(fadeDuration);
				}
				return;
			}
			SetLayerVolume(m_layers[index], num, volumeDataCount, volumeData.Volume[num], fadeDuration);
			if (isPlaySound && !layer2.IsPlaying)
			{
				layer2.SetTimeSample(sample);
				layer2.PlayScheduledWithFade(time, fadeDuration);
			}
		}

		private void SetLayerVolume(IAudioLayer layer, int layerIndex, int volumeDataCount, float volume, float fadeDuration)
		{
			if (layerIndex < volumeDataCount)
			{
				layer.SetVolume(volume, fadeDuration);
			}
		}

		private void PlayScheduledLayers(double time)
		{
			int currentLayer = (int)CurrentLayer;
			for (int i = 0; i < currentLayer; i++)
			{
				m_layers[i].PlayNextScheduled(time);
			}
		}

		private void UpdateChangeClip()
		{
			if (m_isWaitChangeClip && !m_isSingleClipMode)
			{
				bool isPlaying = m_coreLayer.Next.IsPlaying;
				if ((!isPlaying || m_coreLayer.Next.IsJustChangedBar()) && (!isPlaying || m_coreLayer.Next.Just.Bar == m_barLength))
				{
					ChangeClip();
				}
			}
		}

		private void ChangeClip()
		{
			m_isWaitChangeClip = false;
			if (!IsWaitOutro)
			{
				SetNextClip();
			}
		}

		private void SetNextClip()
		{
			SetupNextClipIndex();
			m_coreLayer.SetupNextClip(m_nextClipIndex);
			SetNextClipsInAllLayers(m_nextClipIndex);
		}

		private void SetOutroClip()
		{
			m_coreLayer.SetNextClipToOutro();
			SetNextToOutroClipsInAllLayers();
			m_state = States.WaitPlayOutro;
		}

		private void SwapMusic()
		{
			m_coreLayer.Swap();
			SwapSourcesInAllLayers();
			m_isWaitChangeClip = !IsPlayingOutro && !IsWaitOutro;
		}

		private void SwapSourcesInAllLayers()
		{
			int num = m_layers.Length;
			for (int i = 0; i < num; i++)
			{
				m_layers[i].Swap();
			}
		}

		private void SetNextClipsInAllLayers(int clipIndex)
		{
			for (int i = 0; i < NumberOfAdditionalLayers; i++)
			{
				m_layers[i].SetupNextClip(clipIndex);
			}
		}

		private void SetNextToOutroClipsInAllLayers()
		{
			for (int i = 0; i < NumberOfAdditionalLayers; i++)
			{
				m_layers[i].SetNextClipToOutro();
			}
		}

		private int GetNextClipIndex()
		{
			int clipCount = m_coreLayer.ClipCount;
			if (clipCount <= 0)
			{
				return -1;
			}
			if (m_isSingleClipMode || clipCount <= 1)
			{
				return 0;
			}
			int num = UnityEngine.Random.Range(0, clipCount);
			while (!m_isConnectSameClip && num == m_currentClipIndex)
			{
				num = UnityEngine.Random.Range(0, clipCount);
			}
			return num;
		}

		private void SetupNextClipIndex()
		{
			m_currentClipIndex = m_nextClipIndex;
			m_nextClipIndex = GetNextClipIndex();
		}

		private void UpdateClipNameText()
		{
		}

		private void UpdateLayerText()
		{
		}

		public void StopSimpleBgm(float fadeDuration)
		{
			if (m_isSimpleMode)
			{
				if (fadeDuration <= 0f)
				{
					m_simpleSource.Stop();
					m_simpleSource.SetClip(null);
					m_simpleSource.SetLoop(loop: false);
					m_isSimpleMode = false;
				}
				else
				{
					m_simpleSource.StopWithFade(fadeDuration, m_onEndSimpleBgmFade);
				}
			}
		}

		public void StopAllLayers()
		{
			if (IsPlayingParts)
			{
				m_coreLayer.Stop();
				int num = m_layers.Length;
				for (int i = 0; i < num; i++)
				{
					m_layers[i].Stop();
				}
				Observable.NextFrame(FrameCountType.EndOfFrame).Subscribe(delegate
				{
					OnEndBgm();
				});
				m_state = States.Stop;
			}
		}

		public void StopAllLayersWithFade()
		{
			if (IsPlayingParts)
			{
				float timeUntilNextBarEnd = GetTimeUntilNextBarEnd();
				m_coreLayer.StopWithFade(timeUntilNextBarEnd);
				int num = m_layers.Length;
				for (int i = 0; i < num; i++)
				{
					m_layers[i].StopWithFade(timeUntilNextBarEnd);
				}
				SubscribeOnEndEvent(timeUntilNextBarEnd);
				m_state = States.Stop;
			}
		}

		private void SubscribeOnEndEvent(float waitDuration)
		{
			Observable.Timer(TimeSpan.FromSeconds(waitDuration)).Subscribe(delegate
			{
				OnEndBgm();
			}).AddTo(m_gameObject);
		}

		private void OnEndBgm()
		{
			m_state = States.Stop;
			if (OnEndPlay != null)
			{
				OnEndPlay();
			}
		}

		public float GetTimeUntilNextBarEnd()
		{
			double deltaTimePastFromBar = m_coreLayer.Current.DeltaTimePastFromBar;
			double timePerBar = TimePerBar;
			return (float)(timePerBar - deltaTimePastFromBar + timePerBar);
		}

		public float GetTimeFromBars(int numBars, bool isCountCurrentBar, bool isCheckPlaying = true)
		{
			if (isCheckPlaying && !IsPlayingParts)
			{
				return 0f;
			}
			double timePerBar = TimePerBar;
			if (isCountCurrentBar)
			{
				double deltaTimePastFromBar = m_coreLayer.Current.DeltaTimePastFromBar;
				return (float)(timePerBar - deltaTimePastFromBar + timePerBar * (double)numBars);
			}
			return (float)(timePerBar * (double)numBars);
		}

		public float GetIntroDuration()
		{
			return GetTimeFromBars(m_changeClipBar, isCountCurrentBar: true, isCheckPlaying: false);
		}

		public void ReserveOutro()
		{
			if (IsPlayingParts)
			{
				if (IsReserveOutro || IsNearConnection || m_coreLayer.Next.IsPlaying)
				{
					m_state = States.ReserveOutro;
				}
				else
				{
					SetOutroClip();
				}
			}
		}

		public void ChangeLayer(Layers nextLayer)
		{
			if (IsPlayingParts)
			{
				if (m_isSingleClipMode)
				{
					m_nextLayer = nextLayer;
					PlayLayers(m_nextLayer, m_coreLayer.Current.TimeSamples, AudioSettings.dspTime, isPlaySound: true, (float)TimePerBar * 4f);
				}
				else
				{
					m_nextLayer = nextLayer;
					m_isReserveLayerChange = true;
				}
			}
		}

		public bool IsRemainingBarIsLonger(int barsToCheck)
		{
			return m_changeClipBar - m_coreLayer.Current.Just.Bar >= barsToCheck;
		}

		public float CalculateLayerChangeDuration()
		{
			return GetTimeFromBars(m_changeClipBar, isCountCurrentBar: false);
		}
	}
	[ExecuteInEditMode]
	[RequireComponent(typeof(AudioSource))]
	public class Music : UpdateableComponent
	{
		[Serializable]
		public class Section
		{
			public enum ClipType
			{
				None,
				Loop,
				Through,
				End
			}

			public string Name;

			public int UnitPerBeat;

			public int UnitPerBar;

			public double Tempo;

			public int StartBar;

			public int StartTimeSamples;

			public ClipType LoopType;

			public Section(int startBar, int mtBeat = 4, int mtBar = 16, double tempo = 120.0)
			{
				StartBar = startBar;
				UnitPerBeat = mtBeat;
				UnitPerBar = mtBar;
				Tempo = tempo;
			}

			public void OnValidate(int startTimeSample)
			{
				StartTimeSamples = startTimeSample;
			}

			public override string ToString()
			{
				return $"\"{Name}\" StartBar:{StartBar}, Tempo:{Tempo}";
			}
		}

		public enum SyncType
		{
			NextBeat,
			Next2Beat,
			NextBar,
			Next2Bar,
			Next4Bar,
			Next8Bar,
			SectionEnd
		}

		public List<Section> Sections;

		public bool IsLoop;

		public int EntryPointSample;

		public TextMesh DebugText;

		public bool CreateSectionClips;

		private MusicTiming just_;

		private MusicTiming near_;

		private bool isJustChanged_;

		private bool isNearChanged_;

		private bool isFormerHalf_;

		private double timeSecFromJust_;

		private int numRepeat_;

		private double musicTimeUnit_;

		private AudioSource musicSource_;

		private AudioSourceFader m_fader;

		private int sectionIndex_;

		private int currentSample_;

		private int samplingRate_;

		private int samplesPerUnit_;

		private int samplesPerBeat_;

		private int samplesPerBar_;

		private int samplesInLoop_;

		private MusicTiming oldNear_;

		private MusicTiming oldJust_;

		private int numLoopBar_ = -1;

		private List<AudioSource> quantizedCue_ = new List<AudioSource>();

		private readonly float PITCH_UNIT = Mathf.Pow(2f, 1f / 12f);

		private List<AudioSource> sectionSources_ = new List<AudioSource>();

		private bool isTransitioning_;

		private MusicTiming transitionTiming_ = new MusicTiming(0, 0, 0);

		public Section this[int index]
		{
			get
			{
				if (0 <= index && index < SectionCount_)
				{
					return Sections[index];
				}
				return null;
			}
		}

		public int SamplePerBar => samplesPerBar_;

		public int SamplePerBeat => samplesPerBeat_;

		public int SamplePerUnit => samplesPerUnit_;

		public int SampleRate
		{
			get
			{
				return samplingRate_;
			}
			set
			{
				samplingRate_ = value;
			}
		}

		public bool IsPlaying => IsPlaying_;

		public MusicTiming Just => just_;

		public MusicTiming Near => near_;

		public bool IsJustChanged => isJustChanged_;

		public bool IsNearChanged => isNearChanged_;

		public bool IsFormerHalf => isFormerHalf_;

		public double TimeSecFromJust => timeSecFromJust_;

		public int NumRepeat => numRepeat_;

		public double Lag => Lag_;

		public double LagAbs => LagAbs_;

		public double LagUnit => LagUnit_;

		public double MusicTimeUnit => musicTimeUnit_;

		public float MusicalTime => MusicalTime_;

		public float MusicalTimeBar => MusicalTimeBar_;

		public double DeltaTimePerBar => 60.0 * (double)CurrentSection_.UnitPerBeat * 1.0 / CurrentSection_.Tempo;

		public double DeltaTimePastFromBar => (double)(TimeSamples_ - just_.Bar * samplesPerBar_) / (double)samplingRate_;

		public double DeltaTimeUntilNextBar => DeltaTimePerBar - DeltaTimePastFromBar;

		public float AudioTimeSec => AudioTimeSec_;

		public int TimeSamples => TimeSamples_;

		public int UnitPerBar => UnitPerBar_;

		public int UnitPerBeat => UnitPerBeat_;

		public AudioSource CurrentSource => musicSource_;

		public AudioSourceFader Player => m_fader;

		public Section CurrentSection => CurrentSection_;

		public int CurrentSectionIndex => sectionIndex_;

		public int SectionCount => SectionCount_;

		public string CurrentMusicName => base.name;

		public bool IsTransitioning => isTransitioning_;

		private double Lag_
		{
			get
			{
				if (isFormerHalf_)
				{
					return timeSecFromJust_;
				}
				return timeSecFromJust_ - musicTimeUnit_;
			}
		}

		private double LagAbs_
		{
			get
			{
				if (isFormerHalf_)
				{
					return timeSecFromJust_;
				}
				return musicTimeUnit_ - timeSecFromJust_;
			}
		}

		private double LagUnit_ => Lag / musicTimeUnit_;

		private float MusicalTime_ => (float)((double)just_.GetMusicalTime(CurrentSection_) + timeSecFromJust_ / musicTimeUnit_);

		private float MusicalTimeBar_ => MusicalTime_ / (float)CurrentSection_.UnitPerBar;

		private float AudioTimeSec_ => musicSource_.time;

		private int TimeSamples_ => musicSource_.timeSamples;

		private int SectionCount_ => Sections.Count;

		private int UnitPerBar_ => CurrentSection.UnitPerBar;

		private int UnitPerBeat_ => CurrentSection.UnitPerBeat;

		private bool IsPlaying_ => musicSource_.isPlaying;

		private Section CurrentSection_ => Sections[sectionIndex_];

		public float MusicalTimeFrom(MusicTiming timing)
		{
			int a = 0;
			for (int i = 0; i < SectionCount; i++)
			{
				if (i + 1 < SectionCount)
				{
					if (timing.Bar < Sections[i + 1].StartBar)
					{
						a = i;
						break;
					}
				}
				else
				{
					a = i;
				}
			}
			int num = Mathf.Min(a, sectionIndex_);
			int num2 = Mathf.Max(a, sectionIndex_);
			MusicTiming musicTiming = new MusicTiming((timing < Just) ? timing : Just);
			MusicTiming musicTiming2 = ((timing > Just) ? timing : Just);
			int num3 = 0;
			for (int j = num; j <= num2; j++)
			{
				if (j < num2)
				{
					num3 += Sections[j + 1].StartBar * Sections[j].UnitPerBar - musicTiming.GetMusicalTime(Sections[j]);
					musicTiming.Set(Sections[j + 1].StartBar);
				}
				else
				{
					num3 += musicTiming2.GetMusicalTime(Sections[j]) - musicTiming.GetMusicalTime(Sections[j]);
				}
			}
			return (float)((double)(((!(timing > Just)) ? 1 : (-1)) * num3) + TimeSecFromJust / MusicTimeUnit);
		}

		public float MusicalCos(float cycle = 16f, float offset = 0f, float min = 0f, float max = 1f)
		{
			return Mathf.Lerp(min, max, ((float)Math.Cos(Math.PI * 2.0 * (double)(MusicalTime + offset) / (double)cycle) + 1f) / 2f);
		}

		public Section GetSection(int index)
		{
			return Sections[index];
		}

		public bool IsJustChangedWhen(Predicate<MusicTiming> pred)
		{
			return IsJustChangedWhen_(pred);
		}

		public bool IsJustChangedBar()
		{
			return IsJustChangedBar_();
		}

		public bool IsJustChangedBeat()
		{
			return IsJustChangedBeat_();
		}

		public bool IsJustChangedAt(int bar = 0, int beat = 0, int unit = 0)
		{
			return IsJustChangedAt_(bar, beat, unit);
		}

		public bool IsJustChangedAt(MusicTiming t)
		{
			return IsJustChangedAt_(t.Bar, t.Beat, t.Unit);
		}

		public bool IsJustChangedSection()
		{
			return IsJustChangedAt(CurrentSection_.StartBar);
		}

		public bool IsNearChangedWhen(Predicate<MusicTiming> pred)
		{
			return IsNearChangedWhen_(pred);
		}

		public bool IsNearChangedBar()
		{
			return IsNearChangedBar_();
		}

		public bool IsNearChangedBeat()
		{
			return IsNearChangedBeat_();
		}

		public bool IsNearChangedAt(int bar, int beat = 0, int unit = 0)
		{
			return IsNearChangedAt_(bar, beat, unit);
		}

		public bool IsNearChangedAt(MusicTiming t)
		{
			return IsNearChangedAt_(t.Bar, t.Beat, t.Unit);
		}

		public void QuantizePlay(AudioSource source, int transpose = 0, float allowRange = 0.3f)
		{
			source.pitch = Mathf.Pow(PITCH_UNIT, transpose);
			if (IsFormerHalf && LagUnit < (double)allowRange)
			{
				source.Play();
			}
			else
			{
				quantizedCue_.Add(source);
			}
		}

		public void Pause()
		{
			musicSource_.Pause();
		}

		public void Resume()
		{
			musicSource_.Play();
		}

		public void Stop()
		{
			musicSource_.Stop();
		}

		public void Seek(MusicTiming timing)
		{
			Section section = null;
			for (int i = 0; i < SectionCount; i++)
			{
				if (i + 1 < SectionCount)
				{
					if (timing.Bar < Sections[i + 1].StartBar)
					{
						section = Sections[i];
					}
				}
				else
				{
					section = Sections[i];
				}
			}
			int num = timing.GetMusicalTime(section) - section.StartBar * section.UnitPerBar;
			musicSource_.timeSamples = section.StartTimeSamples + (int)((double)num * MusicTimeUnit * (double)samplingRate_);
		}

		public void SetVolume(float volume)
		{
			musicSource_.volume = volume;
		}

		public void SetNextSection(int sectionIndex, SyncType syncType = SyncType.NextBar)
		{
			SetNextSection_(sectionIndex, syncType);
		}

		public void SetNextSection(string name, SyncType syncType = SyncType.NextBar)
		{
			SetNextSection(Sections.FindIndex((Section s) => s.Name == name), syncType);
		}

		private bool IsNearChangedWhen_(Predicate<MusicTiming> pred)
		{
			if (isNearChanged_)
			{
				return pred(near_);
			}
			return false;
		}

		private bool IsNearChangedBar_()
		{
			if (isNearChanged_ && near_.Beat == 0)
			{
				return near_.Unit == 0;
			}
			return false;
		}

		private bool IsNearChangedBeat_()
		{
			if (isNearChanged_)
			{
				return near_.Unit == 0;
			}
			return false;
		}

		private bool IsNearChangedAt_(int bar, int beat = 0, int unit = 0)
		{
			if (isNearChanged_ && near_.Bar == bar && near_.Beat == beat)
			{
				return near_.Unit == unit;
			}
			return false;
		}

		private bool IsJustChangedWhen_(Predicate<MusicTiming> pred)
		{
			if (isJustChanged_)
			{
				return pred(just_);
			}
			return false;
		}

		private bool IsJustChangedBar_()
		{
			if (isJustChanged_ && just_.Beat == 0)
			{
				return just_.Unit == 0;
			}
			return false;
		}

		private bool IsJustChangedBeat_()
		{
			if (isJustChanged_)
			{
				return just_.Unit == 0;
			}
			return false;
		}

		private bool IsJustChangedAt_(int bar = 0, int beat = 0, int unit = 0)
		{
			if (isJustChanged_ && just_.Bar == bar && just_.Beat == beat)
			{
				return just_.Unit == unit;
			}
			return false;
		}

		private void Awake()
		{
			musicSource_ = GetComponent<AudioSource>();
			m_fader = new AudioSourceFader(musicSource_);
			near_ = new MusicTiming(0, 0, -1);
			just_ = new MusicTiming(near_);
			oldNear_ = new MusicTiming(near_);
			oldJust_ = new MusicTiming(just_);
			SetupClips();
		}

		public void SetupClips(AudioClip clip)
		{
			musicSource_.clip = clip;
			SetupClips();
		}

		public void SetupClips()
		{
			if (!(musicSource_.clip == null))
			{
				SetupLoop();
				ResetSettings();
				OnSectionChanged();
			}
		}

		private void SetupLoop()
		{
			if (IsLoop && musicSource_.loop)
			{
				samplesInLoop_ = musicSource_.clip.samples;
				Section section = Sections[Sections.Count - 1];
				double num = 60.0 / section.Tempo;
				int num2 = (int)((double)(samplingRate_ * section.UnitPerBar) * (num / (double)section.UnitPerBeat));
				numLoopBar_ = section.StartBar + Mathf.RoundToInt((float)(samplesInLoop_ - section.StartTimeSamples) / (float)num2);
			}
		}

		private void CreateAudioFromSections()
		{
		}

		public override void OnUpdate(float delta)
		{
			if (IsPlaying_)
			{
				UpdateTiming();
			}
		}

		private void OnValidate()
		{
			if (musicSource_ == null)
			{
				musicSource_ = GetComponent<AudioSource>();
			}
			if (samplingRate_ == 0)
			{
				samplingRate_ = ((musicSource_ != null && musicSource_.clip != null) ? musicSource_.clip.frequency : 44100);
			}
			if (Sections == null || Sections.Count == 0)
			{
				Sections = new List<Section>();
				Sections.Add(new Section(0));
				Sections[0].OnValidate(EntryPointSample);
				return;
			}
			bool flag = true;
			int num = EntryPointSample;
			for (int i = 0; i < Sections.Count; i++)
			{
				if (Sections[i].StartTimeSamples != num)
				{
					flag = false;
				}
				if (!flag)
				{
					Sections[i].OnValidate(num);
				}
				if (i + 1 < Sections.Count)
				{
					if (Sections[i + 1].StartBar < Sections[i].StartBar)
					{
						Sections[i + 1].StartBar = Sections[i].StartBar + 1;
					}
					int num2 = (Sections[i + 1].StartBar - Sections[i].StartBar) * Sections[i].UnitPerBar;
					num += (int)((double)(num2 / Sections[i].UnitPerBeat) * (60.0 / Sections[i].Tempo) * (double)samplingRate_);
				}
			}
		}

		private void OnDestroy()
		{
		}

		private void ResetSettings()
		{
			isJustChanged_ = false;
			isNearChanged_ = false;
			near_.Set(0, 0, -1);
			just_.Set(0, 0, -1);
			oldNear_.Set(0, 0, -1);
			oldJust_.Set(0, 0, -1);
			timeSecFromJust_ = 0.0;
			isFormerHalf_ = true;
			numRepeat_ = 0;
			sectionIndex_ = 0;
		}

		private void OnSectionChanged()
		{
			if (Sections != null && Sections.Count != 0)
			{
				if (CurrentSection_.Tempo <= 0.0)
				{
					samplesPerUnit_ = 0;
					samplesPerBeat_ = 0;
					samplesPerBar_ = 0;
					musicTimeUnit_ = 0.0;
				}
				else
				{
					double num = 60.0 / CurrentSection_.Tempo;
					samplesPerUnit_ = (int)((double)samplingRate_ * (num / (double)CurrentSection_.UnitPerBeat));
					samplesPerBeat_ = (int)((double)samplingRate_ * num);
					samplesPerBar_ = (int)((double)(samplingRate_ * CurrentSection_.UnitPerBar) * (num / (double)CurrentSection_.UnitPerBeat));
					musicTimeUnit_ = (double)samplesPerUnit_ / (double)samplingRate_;
				}
			}
		}

		public void Play()
		{
			OnPlayStart();
			musicSource_.Play();
		}

		public void PlayScheduled(double time)
		{
			OnPlayStart();
			musicSource_.PlayScheduled(time);
		}

		public void PlayScheduledWithFade(double time, float fadeDuration)
		{
			OnPlayStart();
			m_fader.PlayScheduledWithFade(time, fadeDuration);
		}

		private void OnPlayStart()
		{
			if (IsPlaying)
			{
				Stop();
			}
			ResetSettings();
		}

		private void SetNextSection_(int sectionIndex, SyncType syncType = SyncType.NextBar)
		{
			if (CreateSectionClips && !isTransitioning_ && sectionIndex >= 0 && SectionCount > sectionIndex && sectionIndex != sectionIndex_)
			{
				int num = 0;
				transitionTiming_.Copy(just_);
				switch (syncType)
				{
				case SyncType.NextBeat:
					num = samplesPerBeat_;
					transitionTiming_.Beat++;
					transitionTiming_.Unit = 0;
					break;
				case SyncType.Next2Beat:
					num = samplesPerBeat_ * 2;
					transitionTiming_.Beat += 2;
					transitionTiming_.Unit = 0;
					break;
				case SyncType.NextBar:
					num = samplesPerBar_;
					transitionTiming_.Bar++;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.Next2Bar:
					num = samplesPerBar_ * 2;
					transitionTiming_.Bar += 2;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.Next4Bar:
					num = samplesPerBar_ * 4;
					transitionTiming_.Bar += 4;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.Next8Bar:
					num = samplesPerBar_ * 8;
					transitionTiming_.Bar += 8;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				case SyncType.SectionEnd:
					num = samplesInLoop_;
					transitionTiming_.Bar = CurrentSection_.StartBar + numLoopBar_;
					transitionTiming_.Beat = (transitionTiming_.Unit = 0);
					break;
				}
				transitionTiming_.Fix(CurrentSection_);
				if (CurrentSection_.LoopType == Section.ClipType.Loop && transitionTiming_.Bar >= CurrentSection_.StartBar + numLoopBar_)
				{
					transitionTiming_.Bar -= numLoopBar_;
				}
				if (num > 0)
				{
					double num2 = AudioSettings.dspTime + (double)(num - musicSource_.timeSamples % num) / (double)samplingRate_ / (double)musicSource_.pitch;
					sectionSources_[sectionIndex].PlayScheduled(num2);
					sectionSources_[sectionIndex_].SetScheduledEndTime(num2);
					isTransitioning_ = true;
				}
			}
		}

		private void UpdateTiming()
		{
			currentSample_ = musicSource_.timeSamples;
			isNearChanged_ = false;
			isJustChanged_ = false;
			int num = currentSample_ - ((!CreateSectionClips) ? CurrentSection_.StartTimeSamples : 0);
			if (num >= 0)
			{
				just_.Bar = num / samplesPerBar_ + CurrentSection_.StartBar;
				just_.Beat = num % samplesPerBar_ / samplesPerBeat_;
				just_.Unit = num % samplesPerBar_ % samplesPerBeat_ / samplesPerUnit_;
				just_.Fix(CurrentSection_);
				just_.Bar -= CurrentSection_.StartBar;
				timeSecFromJust_ = (double)(num - just_.Bar * samplesPerBar_ - just_.Beat * samplesPerBeat_ - just_.Unit * samplesPerUnit_) / (double)samplingRate_;
				isFormerHalf_ = timeSecFromJust_ * (double)samplingRate_ < (double)(samplesPerUnit_ / 2);
				just_.Bar += CurrentSection_.StartBar;
				near_.Copy(just_);
				if (!isFormerHalf_)
				{
					near_.Increment(CurrentSection_);
				}
				if (samplesInLoop_ != 0 && currentSample_ + samplesPerUnit_ / 2 >= samplesInLoop_)
				{
					near_.Init();
				}
				isNearChanged_ = !near_.Equals(oldNear_);
				isJustChanged_ = !just_.Equals(oldJust_);
				oldNear_.Copy(near_);
				oldJust_.Copy(just_);
			}
		}

		private void OnJustChanged()
		{
			int count = quantizedCue_.Count;
			for (int i = 0; i < count; i++)
			{
				quantizedCue_[i].Play();
			}
			quantizedCue_.Clear();
		}

		private void OnBeat()
		{
		}

		private void OnBar()
		{
		}

		private void OnRepeated()
		{
			numRepeat_++;
		}

		public void UpdateFade(float delta)
		{
			m_fader.Update(delta);
		}
	}
	[Serializable]
	public class MusicTiming : IComparable<MusicTiming>, IEquatable<MusicTiming>
	{
		public int Bar;

		public int Beat;

		public int Unit;

		public MusicTiming(int bar = 0, int beat = 0, int unit = 0)
		{
			Bar = bar;
			Beat = beat;
			Unit = unit;
		}

		public MusicTiming(MusicTiming copy)
		{
			Copy(copy);
		}

		public MusicTiming()
		{
			Init();
		}

		public void Init()
		{
			Bar = 0;
			Beat = 0;
			Unit = 0;
		}

		public void Copy(MusicTiming copy)
		{
			Bar = copy.Bar;
			Beat = copy.Beat;
			Unit = copy.Unit;
		}

		public void Set(int bar, int beat = 0, int unit = 0)
		{
			Bar = bar;
			Beat = beat;
			Unit = unit;
		}

		public int GetCurrentMusicalTime(Music music)
		{
			return GetMusicalTime(music.CurrentSection);
		}

		public int GetMusicalTime(Music.Section section)
		{
			return Bar * section.UnitPerBar + Beat * section.UnitPerBeat + Unit;
		}

		public void Fix(Music.Section section)
		{
			int num = Bar * section.UnitPerBar + Beat * section.UnitPerBeat + Unit;
			Bar = num / section.UnitPerBar;
			Beat = (num - Bar * section.UnitPerBar) / section.UnitPerBeat;
			Unit = num - Bar * section.UnitPerBar - Beat * section.UnitPerBeat;
		}

		public void Increment(Music.Section section)
		{
			Unit++;
			Fix(section);
		}

		public void Decrement(Music.Section section)
		{
			Unit--;
			Fix(section);
		}

		public void IncrementBeat(Music.Section section)
		{
			Beat++;
			Fix(section);
		}

		public void Add(MusicTiming t, Music.Section section)
		{
			Bar += t.Bar;
			Beat += t.Beat;
			Unit += t.Unit;
			Fix(section);
		}

		public void Subtract(MusicTiming t, Music.Section section)
		{
			Bar -= t.Bar;
			Beat -= t.Beat;
			Unit -= t.Unit;
			Fix(section);
		}

		public static bool operator >(MusicTiming t, MusicTiming t2)
		{
			if (t.Bar <= t2.Bar && (t.Bar != t2.Bar || t.Beat <= t2.Beat))
			{
				if (t.Bar == t2.Bar && t.Beat == t2.Beat)
				{
					return t.Unit > t2.Unit;
				}
				return false;
			}
			return true;
		}

		public static bool operator <(MusicTiming t, MusicTiming t2)
		{
			if (!(t > t2))
			{
				return !t.Equals(t2);
			}
			return false;
		}

		public static bool operator <=(MusicTiming t, MusicTiming t2)
		{
			return !(t > t2);
		}

		public static bool operator >=(MusicTiming t, MusicTiming t2)
		{
			if (!(t > t2))
			{
				return t.Equals(t2);
			}
			return true;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj == this)
			{
				return true;
			}
			if (GetType() != obj.GetType())
			{
				return false;
			}
			return Equals(obj as MusicTiming);
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public bool Equals(MusicTiming other)
		{
			if (Bar == other.Bar && Beat == other.Beat)
			{
				return Unit == other.Unit;
			}
			return false;
		}

		public int CompareTo(MusicTiming tother)
		{
			if (Equals(tother))
			{
				return 0;
			}
			if (this > tother)
			{
				return 1;
			}
			return -1;
		}

		public override string ToString()
		{
			return Bar + " " + Beat + " " + Unit;
		}
	}
}
